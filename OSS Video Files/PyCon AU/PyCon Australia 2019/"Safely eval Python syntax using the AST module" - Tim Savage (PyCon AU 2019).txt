Title: "Safely eval Python syntax using the AST module" - Tim Savage (PyCon AU 2019)
Publication date: 2019-08-02
Playlist: PyCon Australia 2019
Description: 
	Tim Savage

Allow your users to supply queries or define rules using Python syntax and safely eval them. Processing an AST into safely executable code.

https://2019.pycon-au.org/talks/safely-eval-python-syntax-using-the-ast-module

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 2 - 6 2019.

Video licence: CC BY-NC-SA 4.0 - https://creativecommons.org/licenses/by-nc-sa/4.0/

Python, PyCon, PyConAU

Fri Aug  2 10:30:00 2019 at C3.3
Captions: 
	00:00:01,129 --> 00:00:06,029
so it'd be cool to let users provide

00:00:03,840 --> 00:00:09,960
rules or queries you think Python syntax

00:00:06,029 --> 00:00:11,790
right but that's really unsafe Tim

00:00:09,960 --> 00:00:13,740
Savage is the development leave for

00:00:11,790 --> 00:00:15,719
Westpac data bank and he's going to show

00:00:13,740 --> 00:00:17,730
us how to do that in a way that's not

00:00:15,719 --> 00:00:20,260
terribly unsafe using the ast module

00:00:17,730 --> 00:00:27,300
please make him feel welcome

00:00:20,260 --> 00:00:27,300
[Applause]

00:00:45,710 --> 00:00:59,989
okay secondly funds to start I'd hang up

00:00:49,210 --> 00:01:08,600
go fullscreen on we're not gonna get

00:00:59,989 --> 00:01:23,090
that going at me oh can I tried it

00:01:08,600 --> 00:01:25,940
before hand so yeah the standard advice

00:01:23,090 --> 00:01:28,160
and pretty much any scripting language

00:01:25,940 --> 00:01:30,979
is typically you should never use eval

00:01:28,160 --> 00:01:34,430
I'm sure we've all heard that whether

00:01:30,979 --> 00:01:36,700
we're doing Python or JavaScript or any

00:01:34,430 --> 00:01:39,800
other sort of a language of those types

00:01:36,700 --> 00:01:41,420
so I'm going to go through some

00:01:39,800 --> 00:01:44,750
approaches you can use to make that safe

00:01:41,420 --> 00:01:47,630
and make that secure so it's to briefly

00:01:44,750 --> 00:01:50,060
introduce myself my name's Tim Savage

00:01:47,630 --> 00:01:53,000
I've been doing Python now about 15

00:01:50,060 --> 00:01:57,340
something years I currently work for Wes

00:01:53,000 --> 00:02:04,189
back as I mentioned earlier dealing with

00:01:57,340 --> 00:02:05,479
secure handling of data and yeah I'll

00:02:04,189 --> 00:02:06,950
reference some of that stuff that we've

00:02:05,479 --> 00:02:13,670
sort of used some of these techniques

00:02:06,950 --> 00:02:16,070
and some of that we've done so I think I

00:02:13,670 --> 00:02:17,930
just wanted to briefly start before I

00:02:16,070 --> 00:02:20,680
get into exactly how to do a lot of

00:02:17,930 --> 00:02:24,040
stuff with some some use cases on on

00:02:20,680 --> 00:02:26,269
Wade won't do this where would be used

00:02:24,040 --> 00:02:27,950
even though I've been sort of dropped

00:02:26,269 --> 00:02:30,320
into the Django thing this was

00:02:27,950 --> 00:02:31,880
originally a security talk but some of

00:02:30,320 --> 00:02:34,100
this stuff will apply to things you

00:02:31,880 --> 00:02:38,390
might want to do in a Django application

00:02:34,100 --> 00:02:43,760
especially API azor using some of these

00:02:38,390 --> 00:02:46,790
techniques so some of the use cases I'm

00:02:43,760 --> 00:02:48,950
going to go through here are within

00:02:46,790 --> 00:02:53,480
within our platform we use a lot of

00:02:48,950 --> 00:02:56,060
eventing when certain things occur and

00:02:53,480 --> 00:02:57,889
we won't you know trigger certain

00:02:56,060 --> 00:02:58,819
operations on those events particularly

00:02:57,889 --> 00:03:01,819
notification

00:02:58,819 --> 00:03:04,909
our operations team want to know when

00:03:01,819 --> 00:03:06,319
certain things happen I'm not sure if

00:03:04,909 --> 00:03:09,200
anyone's ever worked in a bank

00:03:06,319 --> 00:03:12,379
environment a release takes us about

00:03:09,200 --> 00:03:14,749
four weeks so if someone wants a quick

00:03:12,379 --> 00:03:17,750
notification or a change made a full

00:03:14,749 --> 00:03:18,980
week wait is often not very good so we'd

00:03:17,750 --> 00:03:21,650
like a way to be out of them just to

00:03:18,980 --> 00:03:24,889
create their own sort of notifications

00:03:21,650 --> 00:03:26,120
and that's fun technique we can use and

00:03:24,889 --> 00:03:29,329
then there's a sort of the next one

00:03:26,120 --> 00:03:32,719
they're doing queries expanding that and

00:03:29,329 --> 00:03:35,719
to changing how that query operates

00:03:32,719 --> 00:03:38,419
effectively coding above a dsl kind of

00:03:35,719 --> 00:03:44,750
approach which is something else we can

00:03:38,419 --> 00:03:46,459
do so playing first up I'm just going to

00:03:44,750 --> 00:03:48,560
run through some of the reasons while

00:03:46,459 --> 00:03:51,469
we're doing this and what can and can't

00:03:48,560 --> 00:03:58,909
happen again

00:03:51,469 --> 00:04:01,340
the advice is not to do this but there

00:03:58,909 --> 00:04:04,549
are some good valid uses for eval the

00:04:01,340 --> 00:04:07,009
standard library has a few to call out

00:04:04,549 --> 00:04:10,099
one main example was named tap all users

00:04:07,009 --> 00:04:12,290
eval internally it sort of generates

00:04:10,099 --> 00:04:14,169
code and then you you valid to actually

00:04:12,290 --> 00:04:20,209
produce your final names type of object

00:04:14,169 --> 00:04:26,000
so there are some good uses for it but

00:04:20,209 --> 00:04:29,720
why is it dangerous you know this you

00:04:26,000 --> 00:04:31,759
can so the interface does provide a

00:04:29,720 --> 00:04:36,560
couple of ways that you could probably

00:04:31,759 --> 00:04:38,860
think of making it safe it accepts you

00:04:36,560 --> 00:04:44,840
know your Global's and your local

00:04:38,860 --> 00:04:46,310
objects so you can simplify that but it

00:04:44,840 --> 00:04:48,650
also has all the built-ins are all there

00:04:46,310 --> 00:04:50,840
now you could go through and replace all

00:04:48,650 --> 00:04:52,130
those with you know num nums and

00:04:50,840 --> 00:04:55,060
what-have-you to try and keep that

00:04:52,130 --> 00:05:00,080
simple you know just to remove

00:04:55,060 --> 00:05:04,460
possibilities of you know executing to

00:05:00,080 --> 00:05:07,639
open various buildings but pythons

00:05:04,460 --> 00:05:08,029
meetup and we can do these kind of

00:05:07,639 --> 00:05:11,830
things

00:05:08,029 --> 00:05:11,830
now that doesn't technically

00:05:11,849 --> 00:05:16,340
use anything that's going to be in your

00:05:13,680 --> 00:05:18,659
Global's or the local variables there so

00:05:16,340 --> 00:05:21,810
does anyone have any idea that actually

00:05:18,659 --> 00:05:25,409
does I'm sure there's some security

00:05:21,810 --> 00:05:27,180
people or Python people here they dive

00:05:25,409 --> 00:05:30,120
into that stuff well what does it

00:05:27,180 --> 00:05:35,069
actually do is print out every single

00:05:30,120 --> 00:05:37,379
type which is currently important so as

00:05:35,069 --> 00:05:44,039
you can probably imagine if you can do

00:05:37,379 --> 00:05:45,360
that you can instantiate anything so we

00:05:44,039 --> 00:05:47,009
can have a look at a little example of

00:05:45,360 --> 00:05:53,069
this and what kind of nasty things could

00:05:47,009 --> 00:05:57,629
happen if a user was to seen this in by

00:05:53,069 --> 00:06:04,889
your API for example any ideas what they

00:05:57,629 --> 00:06:07,310
could possibly do well the built-in quit

00:06:04,889 --> 00:06:10,800
is actually an instance of quitter so

00:06:07,310 --> 00:06:13,529
that comes in we've removed everything

00:06:10,800 --> 00:06:17,129
from our locals and Global's but as soon

00:06:13,529 --> 00:06:19,110
as it runs boom your application is gone

00:06:17,129 --> 00:06:21,060
you know it will quit the interpreter

00:06:19,110 --> 00:06:23,520
and you've effectively had your system

00:06:21,060 --> 00:06:27,960
dossed we obviously don't want that to

00:06:23,520 --> 00:06:29,789
happen now I will just call out some of

00:06:27,960 --> 00:06:33,120
these examples have come from you bet

00:06:29,789 --> 00:06:35,250
child was talk I would if you want to

00:06:33,120 --> 00:06:36,870
know more about that that's the place to

00:06:35,250 --> 00:06:38,789
have a look I'm not gonna go through

00:06:36,870 --> 00:06:41,939
complete details of all the nasty things

00:06:38,789 --> 00:06:48,159
of eval he covers it very very well

00:06:41,939 --> 00:06:50,659
there so how can we

00:06:48,159 --> 00:06:55,490
safely execute that code so that we know

00:06:50,659 --> 00:06:57,560
there's nothing dangerous in it so I

00:06:55,490 --> 00:07:00,889
just want to get a quick feel here of

00:06:57,560 --> 00:07:02,750
who's familiar with ast module who's

00:07:00,889 --> 00:07:06,610
heard of it who knows it inside out

00:07:02,750 --> 00:07:09,889
few people who's never heard of it

00:07:06,610 --> 00:07:12,710
thought issue here - all right so

00:07:09,889 --> 00:07:16,639
there's T module is in the standard

00:07:12,710 --> 00:07:20,770
library I'm sorry there it creates a

00:07:16,639 --> 00:07:23,930
syntax tree of any code you pass into it

00:07:20,770 --> 00:07:26,870
it's used by all your favorite tools PI

00:07:23,930 --> 00:07:29,270
test and black and bandit & Co which I

00:07:26,870 --> 00:07:31,639
do hope that you are using or at least

00:07:29,270 --> 00:07:36,219
some of those tools especially if you

00:07:31,639 --> 00:07:36,219
have code open to the Internet

00:07:36,879 --> 00:07:42,199
so yeah that's a quick look at what the

00:07:39,620 --> 00:07:44,270
syntax tree looks like so here's one

00:07:42,199 --> 00:07:48,979
where I've passed this fairly simple

00:07:44,270 --> 00:07:54,529
expression object at x equals double

00:07:48,979 --> 00:07:57,889
equals 1 to 3 and we can see this has

00:07:54,529 --> 00:08:00,250
been formatted so if a tree of what that

00:07:57,889 --> 00:08:03,139
actually comes out to be so we've got a

00:08:00,250 --> 00:08:07,779
expression the body of our expression is

00:08:03,139 --> 00:08:10,750
a comparison the left side is attribute

00:08:07,779 --> 00:08:13,940
C here it all comes down loads out

00:08:10,750 --> 00:08:16,639
interestingly if you want to know what

00:08:13,940 --> 00:08:17,810
Python is doing better this is actually

00:08:16,639 --> 00:08:19,789
a really cool module to look at your

00:08:17,810 --> 00:08:21,349
code see see what's actually happening

00:08:19,789 --> 00:08:23,900
under the hood Python it might help you

00:08:21,349 --> 00:08:26,330
understand some of the behaviors that

00:08:23,900 --> 00:08:28,969
you see in Python it's actually really

00:08:26,330 --> 00:08:34,820
cool thing to look at so that's what AST

00:08:28,969 --> 00:08:36,020
is we have with in there st these are

00:08:34,820 --> 00:08:38,329
all sort of things that make up that

00:08:36,020 --> 00:08:40,219
tree they're all internal they're called

00:08:38,329 --> 00:08:43,430
nodes we have literal variables that

00:08:40,219 --> 00:08:47,930
you'll unusual strings and integers and

00:08:43,430 --> 00:08:51,589
bulls filthy variables if the

00:08:47,930 --> 00:08:54,470
expressions operators comparisons and

00:08:51,589 --> 00:08:56,980
subscripting and depressions comprar

00:08:54,470 --> 00:09:01,779
engines statements

00:08:56,980 --> 00:09:03,820
assignment print cetera and all this

00:09:01,779 --> 00:09:06,100
kinda stuff so it can represent

00:09:03,820 --> 00:09:10,920
everything you can do in Python can be

00:09:06,100 --> 00:09:15,040
represented present in ast tree so

00:09:10,920 --> 00:09:16,630
looking at that tree we now need to sort

00:09:15,040 --> 00:09:20,019
of get an idea of what are we going to

00:09:16,630 --> 00:09:21,930
allow to be executed Mumia if someone's

00:09:20,019 --> 00:09:24,100
past and some code how we're going to

00:09:21,930 --> 00:09:26,529
check that and make it safe

00:09:24,100 --> 00:09:29,500
well obviously first thing is it's going

00:09:26,529 --> 00:09:31,630
to pen on your application what are you

00:09:29,500 --> 00:09:33,850
trying to protect what are you going

00:09:31,630 --> 00:09:35,769
trying to allow there's no

00:09:33,850 --> 00:09:38,910
one-size-fits-all here like any security

00:09:35,769 --> 00:09:41,560
you're going to have to determine which

00:09:38,910 --> 00:09:43,959
parts or which piece of code you're

00:09:41,560 --> 00:09:48,490
going to allowed her to be used some

00:09:43,959 --> 00:09:51,190
good examples here you might only want

00:09:48,490 --> 00:09:53,470
to allow certain functions so any and

00:09:51,190 --> 00:09:55,120
all they could be useful within a

00:09:53,470 --> 00:09:57,779
particular context you want to allow

00:09:55,120 --> 00:10:00,100
those but obviously you don't want open

00:09:57,779 --> 00:10:01,959
you don't want to use it just being open

00:10:00,100 --> 00:10:04,120
up any file on your on their file system

00:10:01,959 --> 00:10:05,860
well import to bring in other things

00:10:04,120 --> 00:10:07,870
that could have other dangerous things

00:10:05,860 --> 00:10:10,720
obviously removing all you done to me

00:10:07,870 --> 00:10:12,430
expression under attributes can be a

00:10:10,720 --> 00:10:14,470
good idea as well that would effectively

00:10:12,430 --> 00:10:16,420
new to that example I put down a start

00:10:14,470 --> 00:10:20,890
by not allowing them to just grab

00:10:16,420 --> 00:10:23,769
anything from your tree so I've got a

00:10:20,890 --> 00:10:25,449
quick example of this and obviously

00:10:23,769 --> 00:10:32,620
there's gonna be something fun with my

00:10:25,449 --> 00:10:34,750
code examples gonna work so I'm gonna

00:10:32,620 --> 00:10:37,720
bring in some vy first so the games you

00:10:34,750 --> 00:10:39,990
have a look at this gotta be tiny on the

00:10:37,720 --> 00:10:39,990
string

00:10:40,480 --> 00:10:47,860
so the ast module itself actually has a

00:10:44,990 --> 00:10:51,050
really good example of of how to filter

00:10:47,860 --> 00:10:52,910
an expression straight away the first if

00:10:51,050 --> 00:10:54,079
you look at the source code of it and

00:10:52,910 --> 00:10:59,060
I've kind of cribbed that a little bit

00:10:54,079 --> 00:11:01,970
for this example but expanded a little

00:10:59,060 --> 00:11:04,069
more to do the more useful things so

00:11:01,970 --> 00:11:08,089
here what we've got is we've got this

00:11:04,069 --> 00:11:10,449
faked event and I've got a little

00:11:08,089 --> 00:11:13,490
program here that will allow you to

00:11:10,449 --> 00:11:15,399
write expressions that will compare this

00:11:13,490 --> 00:11:17,810
event and see if it's going to match

00:11:15,399 --> 00:11:22,279
we're only allowed to do certain things

00:11:17,810 --> 00:11:24,439
we don't want to leave open any possible

00:11:22,279 --> 00:11:29,839
function that you could execute within

00:11:24,439 --> 00:11:32,360
Python so first up we're gonna allow

00:11:29,839 --> 00:11:37,699
comparisons that's something that would

00:11:32,360 --> 00:11:41,120
like it to do to do that obviously we're

00:11:37,699 --> 00:11:43,100
going to do a bit of recursion and pass

00:11:41,120 --> 00:11:48,740
in the left are we allowing that left

00:11:43,100 --> 00:11:52,220
node to come in check the comparators so

00:11:48,740 --> 00:11:54,019
the comparators are where the right side

00:11:52,220 --> 00:11:55,730
of your equation you can actually have

00:11:54,019 --> 00:11:57,769
multiple and that allows for the case of

00:11:55,730 --> 00:12:01,759
when you've got a whole bunch of things

00:11:57,769 --> 00:12:03,110
strung together let you do that

00:12:01,759 --> 00:12:07,550
we're going to allow any literal or

00:12:03,110 --> 00:12:09,529
constant as a final I'm going to limit

00:12:07,550 --> 00:12:13,130
what calls are available so in our

00:12:09,529 --> 00:12:16,660
particular case here you can use Linh to

00:12:13,130 --> 00:12:16,660
compare the link for something that's it

00:12:18,130 --> 00:12:22,459
I'm also gonna layout starts with and

00:12:21,079 --> 00:12:27,470
ends with attributes attributes

00:12:22,459 --> 00:12:29,000
functions so that you can use string dot

00:12:27,470 --> 00:12:33,279
starts with ins with to match certain

00:12:29,000 --> 00:12:35,540
things and that's obviously an named

00:12:33,279 --> 00:12:39,199
name is so you can load any variable

00:12:35,540 --> 00:12:40,519
that would be kind of useful but we are

00:12:39,199 --> 00:12:42,889
going to filter that running and allow

00:12:40,519 --> 00:12:45,410
you to use names which are actually part

00:12:42,889 --> 00:12:47,240
of the Arvind because yeah we're gonna

00:12:45,410 --> 00:12:49,160
keep those kind of simple we'll pull

00:12:47,240 --> 00:12:49,470
things out early on before we even get

00:12:49,160 --> 00:12:52,320
in

00:12:49,470 --> 00:12:58,350
that code the rest of this is pretty

00:12:52,320 --> 00:13:07,320
boring just functional stuff so that but

00:12:58,350 --> 00:13:09,290
we will just run it okay so we can type

00:13:07,320 --> 00:13:14,580
in any expression we'd like in here so

00:13:09,290 --> 00:13:17,460
obviously a simple one that's matched so

00:13:14,580 --> 00:13:18,060
that's the budget so that's all being

00:13:17,460 --> 00:13:20,580
checked

00:13:18,060 --> 00:13:29,190
that's an allowed expression similarly

00:13:20,580 --> 00:13:31,140
we can use Lin to get matched but if we

00:13:29,190 --> 00:13:39,930
come along and go okay we're gonna do a

00:13:31,140 --> 00:13:41,250
bit of it's gonna say it's not found so

00:13:39,930 --> 00:13:43,920
it's gonna filter that out so we've

00:13:41,250 --> 00:13:45,090
immediately prevented someone from

00:13:43,920 --> 00:13:48,660
starting to do something potentially

00:13:45,090 --> 00:13:49,770
nasty now while we're only going to our

00:13:48,660 --> 00:13:50,970
comparisons here they're gonna have to

00:13:49,770 --> 00:13:52,770
check that against something it could

00:13:50,970 --> 00:13:55,020
also it could be used to confirm that is

00:13:52,770 --> 00:13:57,060
it that you know that particularly user

00:13:55,020 --> 00:14:07,170
exists so that someone we don't want to

00:13:57,060 --> 00:14:10,680
happen so that's gonna block it out so

00:14:07,170 --> 00:14:15,870
back to eval so we validated the syntax

00:14:10,680 --> 00:14:17,100
we know it's safe what else oh yeah we

00:14:15,870 --> 00:14:18,630
could say that's it that's all we need

00:14:17,100 --> 00:14:21,600
to do we're happy we can now execute

00:14:18,630 --> 00:14:25,440
that code it's not going to call

00:14:21,600 --> 00:14:27,590
dangerous things to our application but

00:14:25,440 --> 00:14:30,930
we can go a bit further than that

00:14:27,590 --> 00:14:33,450
ast the ast tree can be edited you can

00:14:30,930 --> 00:14:36,990
add things into that tree you might want

00:14:33,450 --> 00:14:40,950
to put additional checks a good example

00:14:36,990 --> 00:14:42,900
from the data bank codebase is we had to

00:14:40,950 --> 00:14:47,010
be able to define rules for matching

00:14:42,900 --> 00:14:48,330
different sets of data together now we

00:14:47,010 --> 00:14:50,220
didn't really want to reinvent our own

00:14:48,330 --> 00:14:54,120
syntax for doing that the original code

00:14:50,220 --> 00:14:55,980
was actually done in sequel but we had

00:14:54,120 --> 00:14:58,500
some quite nasty things where we had to

00:14:55,980 --> 00:15:02,520
have two columns we had to be able to

00:14:58,500 --> 00:15:05,100
match them but there were both addresses

00:15:02,520 --> 00:15:06,870
one contributor well one dataset might

00:15:05,100 --> 00:15:09,839
have those inverted so we needed to do

00:15:06,870 --> 00:15:11,100
sort of a cross thing now python has a

00:15:09,839 --> 00:15:13,920
really good way of doing that we can

00:15:11,100 --> 00:15:16,080
have sets we can do n dissection on them

00:15:13,920 --> 00:15:20,190
if there's an intersection but try and

00:15:16,080 --> 00:15:25,950
write that sequel is horrendous and you

00:15:20,190 --> 00:15:29,839
don't often want to go into that we also

00:15:25,950 --> 00:15:32,640
heard a few other cases so with Python

00:15:29,839 --> 00:15:35,790
equality of two variables that have none

00:15:32,640 --> 00:15:39,240
in them is true but that didn't really

00:15:35,790 --> 00:15:41,580
make sense in our application equality

00:15:39,240 --> 00:15:42,240
of two variables was null and we want

00:15:41,580 --> 00:15:44,610
that to be false

00:15:42,240 --> 00:15:45,690
because we don't want false positives

00:15:44,610 --> 00:15:49,399
we're trying to find two matching

00:15:45,690 --> 00:15:51,750
entries here and if they're both num

00:15:49,399 --> 00:15:55,200
yeah could be the matching but in our

00:15:51,750 --> 00:15:58,140
context is not so we changed the

00:15:55,200 --> 00:16:03,839
behavior of equals in that case to give

00:15:58,140 --> 00:16:05,339
us the functionality that we needed so

00:16:03,839 --> 00:16:07,770
you can define your own dear self

00:16:05,339 --> 00:16:09,779
another really cool use here is

00:16:07,770 --> 00:16:11,880
permissions you might say well we have

00:16:09,779 --> 00:16:14,520
certain columns that we only want

00:16:11,880 --> 00:16:16,890
certain users to be able to do searching

00:16:14,520 --> 00:16:18,690
on so you could apply permissions to

00:16:16,890 --> 00:16:22,760
certain things and we can check that all

00:16:18,690 --> 00:16:25,170
into our into a syntax tree

00:16:22,760 --> 00:16:28,470
the other alternative obviously is just

00:16:25,170 --> 00:16:30,779
generating code so if you can pass

00:16:28,470 --> 00:16:33,839
through a tree you could extract the

00:16:30,779 --> 00:16:35,790
pieces that you want and generate code

00:16:33,839 --> 00:16:37,200
so here's this example we were talking

00:16:35,790 --> 00:16:39,570
about before twice just talking about

00:16:37,200 --> 00:16:41,010
then we have their expression but we

00:16:39,570 --> 00:16:42,990
want it to be slightly different so

00:16:41,010 --> 00:16:46,470
we're just going to say if the lift name

00:16:42,990 --> 00:16:49,190
is none we'll consider that false we

00:16:46,470 --> 00:16:54,120
don't want it to be considered a match

00:16:49,190 --> 00:16:56,670
instantly bring in permissions that's

00:16:54,120 --> 00:16:59,189
about all I have

00:16:56,670 --> 00:17:01,350
I kiss because I am in the Janko comp I

00:16:59,189 --> 00:17:06,179
will have to relate this back to Django

00:17:01,350 --> 00:17:09,569
in some ways obviously security is

00:17:06,179 --> 00:17:14,089
multiple levels so this will allow you

00:17:09,569 --> 00:17:16,829
to very verify some syntax is correct

00:17:14,089 --> 00:17:19,709
but there is saw one caveat and that if

00:17:16,829 --> 00:17:22,260
someone just throws if you put a couple

00:17:19,709 --> 00:17:26,339
of megabytes worth of deeply nested

00:17:22,260 --> 00:17:29,820
stuff into an AST you're going to get a

00:17:26,339 --> 00:17:32,760
stack overflow it's going to crash you

00:17:29,820 --> 00:17:34,289
do want to filter input size this is

00:17:32,760 --> 00:17:35,940
kind of outside the scope of this but

00:17:34,289 --> 00:17:37,770
you know if you're doing web

00:17:35,940 --> 00:17:39,870
applications that's something you do you

00:17:37,770 --> 00:17:43,110
have to consider make sure you thought

00:17:39,870 --> 00:17:45,360
of that size again also verify who's

00:17:43,110 --> 00:17:47,490
putting that data in and we don't want

00:17:45,360 --> 00:17:49,110
to just let anyone to put in anything

00:17:47,490 --> 00:17:52,950
make sure the logged in or the usual

00:17:49,110 --> 00:18:00,889
security layers I think that's about all

00:17:52,950 --> 00:18:07,429
I didn't have any questions all right

00:18:00,889 --> 00:18:07,429
thank you are there yeah thank you

00:18:10,940 --> 00:18:14,899
are there any questions in the audience

00:18:19,370 --> 00:18:27,090
hi thanks for the talk how easy is it

00:18:24,419 --> 00:18:29,190
using this ast stuff to actually like

00:18:27,090 --> 00:18:31,440
100% lock it down from anything that

00:18:29,190 --> 00:18:32,870
could go wrong like my mind was going to

00:18:31,440 --> 00:18:35,789
things like or what if we rebound

00:18:32,870 --> 00:18:37,620
methods to like names that we are that

00:18:35,789 --> 00:18:40,260
are allowed by over like our AST rules

00:18:37,620 --> 00:18:42,600
things like that have you like sort of

00:18:40,260 --> 00:18:46,049
tried to pen test your own security I

00:18:42,600 --> 00:18:48,899
guess yeah so again working from a bank

00:18:46,049 --> 00:18:51,960
everything we had was pen tested this

00:18:48,899 --> 00:18:53,760
went through pen testing we got feedback

00:18:51,960 --> 00:18:57,419
from the pen testers that were making

00:18:53,760 --> 00:19:02,520
their job hard so I was quite happy with

00:18:57,419 --> 00:19:04,770
the outcome like I said earlier on it's

00:19:02,520 --> 00:19:06,600
going to be very dependent on your

00:19:04,770 --> 00:19:07,559
particular use case there's no

00:19:06,600 --> 00:19:09,690
one-size-fits-all

00:19:07,559 --> 00:19:12,059
if you only want really simple

00:19:09,690 --> 00:19:15,260
expressions then lock it right down to

00:19:12,059 --> 00:19:18,419
wearing it allow this very basic stuff

00:19:15,260 --> 00:19:19,559
if you've got more complex stuff then

00:19:18,419 --> 00:19:21,210
you're gonna have to do that you're

00:19:19,559 --> 00:19:24,330
going to have to think outside the box

00:19:21,210 --> 00:19:29,390
and yeah I tempted pen test it give it

00:19:24,330 --> 00:19:32,600
to someone else to try yeah absolutely

00:19:29,390 --> 00:19:32,600
more questions

00:19:34,880 --> 00:19:43,400
I think did you ever try to use the

00:19:40,250 --> 00:19:45,410
module to vet other languages like for

00:19:43,400 --> 00:19:47,570
example if you have embedded sequel or

00:19:45,410 --> 00:19:51,140
is this something that you will only use

00:19:47,570 --> 00:19:55,360
for Python in this particular case it is

00:19:51,140 --> 00:19:57,170
only really for Python ast is obviously

00:19:55,360 --> 00:20:01,580
specifically for Python there may be

00:19:57,170 --> 00:20:04,250
other modules around for checking sequel

00:20:01,580 --> 00:20:07,180
but no this is Pacifico Python for

00:20:04,250 --> 00:20:10,670
sequel we did do other checking in

00:20:07,180 --> 00:20:13,000
obviously your standard I'm using

00:20:10,670 --> 00:20:16,450
parameterize queries for sequel is

00:20:13,000 --> 00:20:16,450
always a good idea

00:20:16,750 --> 00:20:28,010
alright thanks for the talk

00:20:25,400 --> 00:20:31,220
umm we have a bunch of code that walked

00:20:28,010 --> 00:20:32,480
through a sts and something that we've

00:20:31,220 --> 00:20:34,940
been hit by multiple times in the past

00:20:32,480 --> 00:20:36,260
is when we upgrade the version of Python

00:20:34,940 --> 00:20:38,720
we're actually running is accounting for

00:20:36,260 --> 00:20:40,760
the new node types in the grabber

00:20:38,720 --> 00:20:43,670
because the release notes typically

00:20:40,760 --> 00:20:46,610
don't have great underlying support for

00:20:43,670 --> 00:20:48,250
what the actual new underlying ast nodes

00:20:46,610 --> 00:20:50,330
are do you have any experience with

00:20:48,250 --> 00:20:52,760
upgrading Python versions and dealing

00:20:50,330 --> 00:20:54,440
with the ast library and if you do do

00:20:52,760 --> 00:20:56,150
you have any recommendations for how you

00:20:54,440 --> 00:20:59,210
can more easily do that upgrade process

00:20:56,150 --> 00:21:00,710
and account for all ast changes yeah we

00:20:59,210 --> 00:21:04,850
were kind of lucky in it we didn't

00:21:00,710 --> 00:21:06,980
actually go through any upwards but in

00:21:04,850 --> 00:21:11,560
saying that whitelisting is always going

00:21:06,980 --> 00:21:11,560
to be a good option here I mean the the

00:21:11,980 --> 00:21:17,000
properties also that attributes that are

00:21:14,780 --> 00:21:20,810
available on each of those nodes are

00:21:17,000 --> 00:21:22,610
pretty locked down now obviously when

00:21:20,810 --> 00:21:25,430
async and all those things came through

00:21:22,610 --> 00:21:27,440
you do see some extra nodes for async

00:21:25,430 --> 00:21:28,520
but if you have white listed them and

00:21:27,440 --> 00:21:30,980
saying these are the only ones we

00:21:28,520 --> 00:21:32,860
support then any new ones you know by

00:21:30,980 --> 00:21:36,530
default they're not going to be allowed

00:21:32,860 --> 00:21:38,860
so within your up to you whether you

00:21:36,530 --> 00:21:41,240
want to allow those extra things about

00:21:38,860 --> 00:21:42,500
yeah obviously things like I think it

00:21:41,240 --> 00:21:43,620
could be a bit weird because then you

00:21:42,500 --> 00:21:45,940
have to

00:21:43,620 --> 00:21:49,060
I've not actually tried availing any

00:21:45,940 --> 00:21:51,760
asynchronous guys oh yeah that could be

00:21:49,060 --> 00:21:55,810
interesting right give us a question

00:21:51,760 --> 00:21:58,900
here hi you mentioned that you're using

00:21:55,810 --> 00:22:01,690
air stays to do things like adjust the

00:21:58,900 --> 00:22:04,090
behavior of equals evaluations with nuns

00:22:01,690 --> 00:22:06,640
yeah I was thinking is there scope for

00:22:04,090 --> 00:22:10,000
if you can lock out functions entirely

00:22:06,640 --> 00:22:13,300
but say you wanted to do allow the user

00:22:10,000 --> 00:22:15,490
to make variable assignments in a lot

00:22:13,300 --> 00:22:18,690
like a temporary namespace or something

00:22:15,490 --> 00:22:20,860
can you can you modify the behavior of

00:22:18,690 --> 00:22:23,140
functions to limit it rather than just

00:22:20,860 --> 00:22:24,700
turn stuff off completely yeah you could

00:22:23,140 --> 00:22:27,940
actually completely replace things I

00:22:24,700 --> 00:22:29,950
mean one one thing you could entirely do

00:22:27,940 --> 00:22:34,780
is that you could just pause that tree

00:22:29,950 --> 00:22:37,090
and generate completely different code I

00:22:34,780 --> 00:22:39,430
mean I did play around with an idea of

00:22:37,090 --> 00:22:43,000
converting a comprehension into a sequel

00:22:39,430 --> 00:22:44,080
query which you could do it could be a

00:22:43,000 --> 00:22:48,430
bit weird you've still got the

00:22:44,080 --> 00:22:50,380
limitations of Python syntax but yeah

00:22:48,430 --> 00:22:59,370
there's anything you could really do on

00:22:50,380 --> 00:23:02,370
that alright another question somewhere

00:22:59,370 --> 00:23:02,370
dynamic

00:23:04,320 --> 00:23:08,710
if first the comment on translating

00:23:06,820 --> 00:23:11,080
patent sequel there's a project called

00:23:08,710 --> 00:23:13,090
Pony rme oh no I'll just

00:23:11,080 --> 00:23:15,190
most saying that there's and the second

00:23:13,090 --> 00:23:17,289
question okay the second question of I

00:23:15,190 --> 00:23:18,640
white have you thought about doing this

00:23:17,289 --> 00:23:24,130
at the bytecode level rather than the

00:23:18,640 --> 00:23:26,350
ast level we didn't really have a need

00:23:24,130 --> 00:23:28,830
for going out the bytecode level I

00:23:26,350 --> 00:23:33,490
haven't looked at that no it was mainly

00:23:28,830 --> 00:23:34,630
at the ast level yeah ast was just

00:23:33,490 --> 00:23:36,220
convenient for doing these kind of

00:23:34,630 --> 00:23:39,929
things and the kind of stuff we were

00:23:36,220 --> 00:23:39,929
doing it kind of fit in today model

00:23:41,520 --> 00:23:51,309
alright another question we yeah another

00:23:46,570 --> 00:23:53,650
five minutes so ready sorry it's not the

00:23:51,309 --> 00:24:11,830
question it's more like a comment so we

00:23:53,650 --> 00:24:15,730
also using thanks Tim I saw you trapping

00:24:11,830 --> 00:24:19,059
the syntax error if there is a syntax

00:24:15,730 --> 00:24:21,730
error they do you get any thing from the

00:24:19,059 --> 00:24:23,260
AST posit you get half a thing that you

00:24:21,730 --> 00:24:27,309
can then work with to give feedback to

00:24:23,260 --> 00:24:28,600
the user it would depend where we were

00:24:27,309 --> 00:24:30,130
trapping that I mean if we were trapping

00:24:28,600 --> 00:24:32,559
that at the a still if I don't think you

00:24:30,130 --> 00:24:35,260
do I think you've lost that

00:24:32,559 --> 00:24:37,809
obviously there's syntax I mean you will

00:24:35,260 --> 00:24:39,309
get things like the line number or the

00:24:37,809 --> 00:24:43,150
offset and you get all those usual

00:24:39,309 --> 00:24:44,919
things that Python provides and we did

00:24:43,150 --> 00:24:46,480
try to modify that and provide that back

00:24:44,919 --> 00:24:50,049
to use it because obviously we want to

00:24:46,480 --> 00:24:51,490
make it friendly to them it's it's the

00:24:50,049 --> 00:24:53,860
people who are using this in our

00:24:51,490 --> 00:24:55,990
particular case where operations not

00:24:53,860 --> 00:24:56,950
particularly Python developers so we

00:24:55,990 --> 00:25:00,669
wanted to make that as easy as possible

00:24:56,950 --> 00:25:02,620
and so we it has been those usual

00:25:00,669 --> 00:25:06,340
comments that some of pythons arrows

00:25:02,620 --> 00:25:09,659
aren't that obvious in some cases so we

00:25:06,340 --> 00:25:09,659
did try and enhance those a little bit

00:25:10,340 --> 00:25:16,440
there was a question in the back here hi

00:25:14,460 --> 00:25:19,050
so you mentioned the release process

00:25:16,440 --> 00:25:20,910
takes around four weeks I wonder how do

00:25:19,050 --> 00:25:22,680
you tackle when you mentioned that a new

00:25:20,910 --> 00:25:24,480
Python version comes out and it's

00:25:22,680 --> 00:25:26,760
possible that you get an expression

00:25:24,480 --> 00:25:29,640
supply to which your current like

00:25:26,760 --> 00:25:31,350
validator does not support that we will

00:25:29,640 --> 00:25:37,710
from there let's say when the a thing

00:25:31,350 --> 00:25:41,520
was introduced well we owe our releases

00:25:37,710 --> 00:25:43,350
a docker image so a new release of

00:25:41,520 --> 00:25:46,980
Python won't really affect us because we

00:25:43,350 --> 00:25:48,480
would release and you you know how you

00:25:46,980 --> 00:25:50,160
docker image with whatever Python that

00:25:48,480 --> 00:25:53,730
we particularly use so yeah we are kind

00:25:50,160 --> 00:25:55,410
of protected from that again Bank

00:25:53,730 --> 00:25:57,990
environments they're not gonna do major

00:25:55,410 --> 00:26:00,180
releases so free or even point releases

00:25:57,990 --> 00:26:05,310
like that without thorough testing for

00:26:00,180 --> 00:26:05,760
getting him in Europe all right more

00:26:05,310 --> 00:26:12,000
questions

00:26:05,760 --> 00:26:14,940
two minutes left hi thanks for the talk

00:26:12,000 --> 00:26:16,560
you mentioned if you throw a like a

00:26:14,940 --> 00:26:19,830
deeply recursive function at it it will

00:26:16,560 --> 00:26:21,540
blow up yes does I assume it does it

00:26:19,830 --> 00:26:24,570
just give like a fairly standard

00:26:21,540 --> 00:26:27,090
recursive exception that you can catch

00:26:24,570 --> 00:26:30,230
and throw it back to the user in a

00:26:27,090 --> 00:26:34,080
normal way it doesn't blow up too deep I

00:26:30,230 --> 00:26:34,620
haven't actually tried doing too far to

00:26:34,080 --> 00:26:36,810
blow that up

00:26:34,620 --> 00:26:39,780
this was the warning in ast module

00:26:36,810 --> 00:26:41,880
itself so the AST docs have their cope

00:26:39,780 --> 00:26:43,320
with the thing here saying don't put

00:26:41,880 --> 00:26:46,710
deeply nested things in here it could

00:26:43,320 --> 00:26:48,600
have bad side effects and again this

00:26:46,710 --> 00:26:51,360
face if mentioned if you're putting this

00:26:48,600 --> 00:26:54,290
on a website pleasing them emphasize

00:26:51,360 --> 00:26:57,960
that going into that that's sort of

00:26:54,290 --> 00:26:59,670
expected behavior anyway but I'm not a

00:26:57,960 --> 00:27:02,420
hundred percent sent on that it may give

00:26:59,670 --> 00:27:05,070
you a recursion error it made it crash

00:27:02,420 --> 00:27:11,720
and we probably want to avoid that later

00:27:05,070 --> 00:27:11,720
situation alright one more minute

00:27:12,780 --> 00:27:18,340
there is a library it's called simple

00:27:16,120 --> 00:27:21,580
wall did you do you see this library did

00:27:18,340 --> 00:27:24,670
you look into it so its uses the same

00:27:21,580 --> 00:27:34,060
idea but it just you know gives you

00:27:24,670 --> 00:27:38,150
something yeah all right then we have a

00:27:34,060 --> 00:27:44,679
token of appreciation for him thank you

00:27:38,150 --> 00:27:44,679

YouTube URL: https://www.youtube.com/watch?v=7e-2nUqnNqE


