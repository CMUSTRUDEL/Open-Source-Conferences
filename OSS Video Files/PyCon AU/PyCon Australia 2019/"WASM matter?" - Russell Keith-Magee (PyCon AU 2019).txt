Title: "WASM matter?" - Russell Keith-Magee (PyCon AU 2019)
Publication date: 2019-08-03
Playlist: PyCon Australia 2019
Description: 
	One of the biggest developments in web technology in the last few years is the emergence of WASM - Web Assembly. But what is WASM? Can you use it in your web projects? Should you? And if so... how?

https://2019.pycon-au.org/talks/wasm-matter

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 2 - 6 2019.

Video licence: CC BY-NC-SA 4.0 - https://creativecommons.org/licenses/by-nc-sa/4.0/

Python, PyCon, PyConAU

Fri Aug  2 13:30:00 2019 at C3.3
Captions: 
	00:00:00,000 --> 00:00:04,580
javascript and give him a warm welcome

00:00:09,290 --> 00:00:14,580
well thank you Marcus so yes my name is

00:00:12,150 --> 00:00:17,340
Russell keith mcgee in my day job I am a

00:00:14,580 --> 00:00:19,050
data engineer at savato we're a brand

00:00:17,340 --> 00:00:20,670
intelligence platform we use Python and

00:00:19,050 --> 00:00:23,189
data science to deliver consumer

00:00:20,670 --> 00:00:24,480
insights predictive analytics we help

00:00:23,189 --> 00:00:26,010
our customers improve the impact of

00:00:24,480 --> 00:00:27,660
their brand marketing they give me the

00:00:26,010 --> 00:00:29,849
flexibility to attend conferences like

00:00:27,660 --> 00:00:32,610
Jango Khan and PyCon which I'm very

00:00:29,849 --> 00:00:34,170
thankful but I became involved in and

00:00:32,610 --> 00:00:36,390
unknown to the Python community through

00:00:34,170 --> 00:00:39,870
my work on Jango I joined the core team

00:00:36,390 --> 00:00:41,700
way back in 2006 I'm not as active in

00:00:39,870 --> 00:00:43,739
the core team as I once was though and

00:00:41,700 --> 00:00:46,829
that is at least in part because of the

00:00:43,739 --> 00:00:47,579
way that the web has changed over the

00:00:46,829 --> 00:00:49,440
last few years

00:00:47,579 --> 00:00:52,170
web development has become increasingly

00:00:49,440 --> 00:00:54,180
JavaScript heavy 15 years ago when I

00:00:52,170 --> 00:00:56,699
started working with Jango you could

00:00:54,180 --> 00:00:58,649
almost ignore JavaScript now your logic

00:00:56,699 --> 00:01:00,570
was all server side and the client was

00:00:58,649 --> 00:01:02,309
just navigating through a static series

00:01:00,570 --> 00:01:04,260
of pages that okay may have been

00:01:02,309 --> 00:01:05,430
generated from dynamic content but they

00:01:04,260 --> 00:01:08,040
were static when they were delivered to

00:01:05,430 --> 00:01:10,680
the user it is a lot harder to ignore

00:01:08,040 --> 00:01:12,860
JavaScript these days users expect a

00:01:10,680 --> 00:01:14,970
rich client-side experience and

00:01:12,860 --> 00:01:16,740
JavaScript is the only language that's

00:01:14,970 --> 00:01:20,189
available in the browser so that means

00:01:16,740 --> 00:01:23,540
you need to use JavaScript note though

00:01:20,189 --> 00:01:26,100
that I say use JavaScript not write

00:01:23,540 --> 00:01:28,979
JavaScript what I'd like to talk about

00:01:26,100 --> 00:01:30,930
today is a development in the JavaScript

00:01:28,979 --> 00:01:33,119
ecosystem that has the potential to

00:01:30,930 --> 00:01:35,369
reduce the significance of JavaScript as

00:01:33,119 --> 00:01:37,140
a language and opens up a lot more

00:01:35,369 --> 00:01:39,750
possibilities for Python and by

00:01:37,140 --> 00:01:42,479
extension Django that development is

00:01:39,750 --> 00:01:44,909
webassembly or wasm to explain what

00:01:42,479 --> 00:01:46,619
wisdom is we have to dig into how you

00:01:44,909 --> 00:01:49,380
actually get code to run on your

00:01:46,619 --> 00:01:51,600
computer in the first place when code

00:01:49,380 --> 00:01:53,310
runs on your computer it is running as

00:01:51,600 --> 00:01:55,770
machine language binary instructions

00:01:53,310 --> 00:01:57,960
specific to one particular CPU and

00:01:55,770 --> 00:02:00,060
operating system those binary

00:01:57,960 --> 00:02:01,829
instructions aren't easy to write by

00:02:00,060 --> 00:02:03,420
hand and so one of the first programming

00:02:01,829 --> 00:02:05,310
interfaces was assembly language

00:02:03,420 --> 00:02:08,190
assembly language is a human readable

00:02:05,310 --> 00:02:10,080
version of machine language in every

00:02:08,190 --> 00:02:12,360
machine language construct is exposed

00:02:10,080 --> 00:02:13,710
directly as an assembly language analog

00:02:12,360 --> 00:02:16,050
so assembly saw

00:02:13,710 --> 00:02:18,660
code can be easily assembled into a

00:02:16,050 --> 00:02:21,330
machine language binary executable now I

00:02:18,660 --> 00:02:23,280
say human readable assembly code isn't

00:02:21,330 --> 00:02:25,320
that easy to read all right for that

00:02:23,280 --> 00:02:27,390
matter and so developers wrote

00:02:25,320 --> 00:02:28,770
abstractions the first level of

00:02:27,390 --> 00:02:32,130
abstraction comes in the form of

00:02:28,770 --> 00:02:34,110
compiled languages like C in a compiled

00:02:32,130 --> 00:02:35,910
language you take your source code you

00:02:34,110 --> 00:02:38,580
run it through a compiler that produces

00:02:35,910 --> 00:02:39,870
the equivalent assembly language which

00:02:38,580 --> 00:02:41,900
can then be converted into machine

00:02:39,870 --> 00:02:44,700
language to produce and executable

00:02:41,900 --> 00:02:46,590
modern compilers often compiled directly

00:02:44,700 --> 00:02:49,050
to machine language but internally the

00:02:46,590 --> 00:02:51,540
same transition is happening when you

00:02:49,050 --> 00:02:53,280
send AC program to someone else what

00:02:51,540 --> 00:02:55,350
you're passing around isn't C source

00:02:53,280 --> 00:02:57,660
code its source code converted into a

00:02:55,350 --> 00:02:59,970
machine language form so that it can run

00:02:57,660 --> 00:03:02,670
on the CPU of one particular computer it

00:02:59,970 --> 00:03:05,070
doesn't contain any remnants of the

00:03:02,670 --> 00:03:07,950
original source code the compiled

00:03:05,070 --> 00:03:10,350
executable form is tightly bound to a

00:03:07,950 --> 00:03:12,300
specific CPU architecture and to the

00:03:10,350 --> 00:03:15,360
libraries provided by a specific

00:03:12,300 --> 00:03:16,980
operating system the next level of

00:03:15,360 --> 00:03:19,740
abstraction is an interpreted language

00:03:16,980 --> 00:03:21,630
like Python and like JavaScript when you

00:03:19,740 --> 00:03:23,370
send a JavaScript program to someone

00:03:21,630 --> 00:03:26,310
else what you are sending is the source

00:03:23,370 --> 00:03:28,290
code however at the end of the day a

00:03:26,310 --> 00:03:31,050
computer does everything in machine

00:03:28,290 --> 00:03:33,540
language the interpreter is a machine

00:03:31,050 --> 00:03:35,430
language native executable that can read

00:03:33,540 --> 00:03:37,530
the source code and interpret the

00:03:35,430 --> 00:03:39,780
Machine language consequences of the

00:03:37,530 --> 00:03:41,100
source code it has been given the

00:03:39,780 --> 00:03:43,020
benefit of this approach is that the

00:03:41,100 --> 00:03:44,790
code you pass around isn't machine

00:03:43,020 --> 00:03:46,860
dependent the same JavaScript source

00:03:44,790 --> 00:03:48,720
code runs the same everywhere because it

00:03:46,860 --> 00:03:50,670
is the interpreter that's doing the hard

00:03:48,720 --> 00:03:52,650
part of working out what machine

00:03:50,670 --> 00:03:55,070
language instructions are needed on this

00:03:52,650 --> 00:03:57,960
machine to produce the desired effect

00:03:55,070 --> 00:03:59,970
now let's say we are using JavaScript

00:03:57,960 --> 00:04:01,950
and we define ourselves an add function

00:03:59,970 --> 00:04:04,350
it takes two arguments it adds them

00:04:01,950 --> 00:04:06,450
together and it returns the result when

00:04:04,350 --> 00:04:08,460
this is run through your interpreter the

00:04:06,450 --> 00:04:11,940
interpreter has to convert it into CPU

00:04:08,460 --> 00:04:14,910
instructions but which CPU instructions

00:04:11,940 --> 00:04:17,390
if first and second are both integers

00:04:14,910 --> 00:04:19,799
then we need to do an integer add

00:04:17,390 --> 00:04:21,210
operation if first and second are

00:04:19,799 --> 00:04:23,370
strings we need to do with string

00:04:21,210 --> 00:04:24,900
concatenation if first and second are

00:04:23,370 --> 00:04:26,310
different types then you know all bets

00:04:24,900 --> 00:04:27,240
are off different data gets a lot more

00:04:26,310 --> 00:04:29,610
complicated

00:04:27,240 --> 00:04:32,100
that means the interpreter has to be

00:04:29,610 --> 00:04:34,080
ready to do almost anything because the

00:04:32,100 --> 00:04:36,330
code will allow it to do almost anything

00:04:34,080 --> 00:04:38,099
the price you pay for that flexibility

00:04:36,330 --> 00:04:41,490
is that your code is a little bit slower

00:04:38,099 --> 00:04:43,199
however because JavaScript is now so

00:04:41,490 --> 00:04:44,880
important to the end-user experience in

00:04:43,199 --> 00:04:47,550
the browser the runtime performance of

00:04:44,880 --> 00:04:50,310
JavaScript engines has seen a lot of

00:04:47,550 --> 00:04:52,530
performance attention once your code

00:04:50,310 --> 00:04:54,120
starts running you might find that

00:04:52,530 --> 00:04:55,979
because of the way the code is being

00:04:54,120 --> 00:04:59,099
invoked the arguments are always

00:04:55,979 --> 00:05:01,289
integers and the interpreter can exploit

00:04:59,099 --> 00:05:03,210
that once the code is executing the

00:05:01,289 --> 00:05:05,310
interpreter can identify patterns of

00:05:03,210 --> 00:05:08,220
execution it can see that our add method

00:05:05,310 --> 00:05:10,860
is only ever being invoked with integers

00:05:08,220 --> 00:05:13,259
and therefore develop an optimized

00:05:10,860 --> 00:05:15,690
interpretation of the add method that

00:05:13,259 --> 00:05:16,979
will only do integer math because of

00:05:15,690 --> 00:05:19,199
that narrowed scope the optimizer

00:05:16,979 --> 00:05:21,449
optimised version is faster because it

00:05:19,199 --> 00:05:23,610
is closer to the bare bare metal machine

00:05:21,449 --> 00:05:26,430
language X instructions that the

00:05:23,610 --> 00:05:27,960
computer actually needs to execute this

00:05:26,430 --> 00:05:29,909
is effectively the same thing that a

00:05:27,960 --> 00:05:32,070
compiler is doing on a compiled language

00:05:29,909 --> 00:05:34,050
but it is happening at runtime and for

00:05:32,070 --> 00:05:35,550
that reason the process of what the can

00:05:34,050 --> 00:05:37,949
what the interpreter is doing is called

00:05:35,550 --> 00:05:39,599
just-in-time compilation because the

00:05:37,949 --> 00:05:42,090
conversion to machine language is

00:05:39,599 --> 00:05:44,130
happening just in time for the code to

00:05:42,090 --> 00:05:47,759
execute in contrast to the ahead-of-time

00:05:44,130 --> 00:05:50,490
compilation in a compiled language so a

00:05:47,759 --> 00:05:53,099
just-in-time or jitan interpreter will

00:05:50,490 --> 00:05:56,099
optimize the code at runtime to make it

00:05:53,099 --> 00:05:58,469
run faster the question then becomes can

00:05:56,099 --> 00:06:00,690
we gain the system can we do something

00:05:58,469 --> 00:06:02,690
to our code that will make it easier for

00:06:00,690 --> 00:06:05,639
the interpreter to identify possible

00:06:02,690 --> 00:06:09,389
optimizations turns out the answer is

00:06:05,639 --> 00:06:11,880
yes for example in JavaScript the result

00:06:09,389 --> 00:06:15,780
of a logical or with an integer is

00:06:11,880 --> 00:06:18,060
always an integer so if we or an integer

00:06:15,780 --> 00:06:23,580
with zero you will get the original

00:06:18,060 --> 00:06:26,130
integer so and so if we or both of our

00:06:23,580 --> 00:06:28,620
functions arguments with zero the

00:06:26,130 --> 00:06:31,139
interpreter can know that the addition

00:06:28,620 --> 00:06:33,449
operation must be an integer operation

00:06:31,139 --> 00:06:35,250
it doesn't matter what type first and

00:06:33,449 --> 00:06:36,960
second are the addition is an integer

00:06:35,250 --> 00:06:39,979
addition and the result but also

00:06:36,960 --> 00:06:39,979
therefore be an integer

00:06:41,010 --> 00:06:44,760
sorry oh this is something that then has

00:06:43,260 --> 00:06:48,570
a director interpretation in machine

00:06:44,760 --> 00:06:50,610
language and that is therefore fast okay

00:06:48,570 --> 00:06:52,980
so that's a neat trick but why do we

00:06:50,610 --> 00:06:54,540
care after all we have to deface our

00:06:52,980 --> 00:06:56,520
code pretty badly in order to realize

00:06:54,540 --> 00:06:58,950
that optimization so is it really worth

00:06:56,520 --> 00:07:00,300
it well now if you're looking at this as

00:06:58,950 --> 00:07:03,420
a way to speed up your handwritten

00:07:00,300 --> 00:07:05,460
JavaScript probably not but take a look

00:07:03,420 --> 00:07:07,290
at what we've just been able to do by

00:07:05,460 --> 00:07:09,360
doing nothing more than annotating our

00:07:07,290 --> 00:07:11,400
JavaScript code we have been able to

00:07:09,360 --> 00:07:14,130
convince the JavaScript interpreter to

00:07:11,400 --> 00:07:17,820
give us near direct access to optimized

00:07:14,130 --> 00:07:19,650
CPU level integer arithmetic it's a very

00:07:17,820 --> 00:07:21,000
roundabout way of expressing it and the

00:07:19,650 --> 00:07:22,680
optimization doesn't happen until the

00:07:21,000 --> 00:07:24,900
code is actually running but we have

00:07:22,680 --> 00:07:27,410
used an interpreted language to expose a

00:07:24,900 --> 00:07:30,090
primitive machine language construct if

00:07:27,410 --> 00:07:32,670
we can expose one machine language

00:07:30,090 --> 00:07:35,730
construct can we expose all the

00:07:32,670 --> 00:07:37,050
capabilities of a machine language few

00:07:35,730 --> 00:07:38,460
years back a team at Mozilla looked at

00:07:37,050 --> 00:07:40,410
the JavaScript language as a whole to

00:07:38,460 --> 00:07:41,940
determine if there was a subset subset

00:07:40,410 --> 00:07:43,890
of JavaScript code annotations and

00:07:41,940 --> 00:07:46,320
conventions that you can use to trick a

00:07:43,890 --> 00:07:47,970
jetting JavaScript interpreter to expose

00:07:46,320 --> 00:07:49,980
new direct access to the full

00:07:47,970 --> 00:07:53,670
capabilities of your CPU and what they

00:07:49,980 --> 00:07:57,210
came up with is called a smj s.a.s MJS

00:07:53,670 --> 00:07:57,750
is 100% legal javascript code it is not

00:07:57,210 --> 00:07:59,910
pretty

00:07:57,750 --> 00:08:01,290
JavaScript code it is it uses only a

00:07:59,910 --> 00:08:03,090
subset of everything that's in the full

00:08:01,290 --> 00:08:04,470
JavaScript spec and the code is covered

00:08:03,090 --> 00:08:06,030
with annotations and weird coding

00:08:04,470 --> 00:08:08,790
conventions like the zero was from

00:08:06,030 --> 00:08:10,410
before but in combination those

00:08:08,790 --> 00:08:12,210
annotations and conventions provide a

00:08:10,410 --> 00:08:14,010
set of low-level primitives for

00:08:12,210 --> 00:08:16,350
performing integer and floating-point

00:08:14,010 --> 00:08:17,540
arithmetic allocating memory defining

00:08:16,350 --> 00:08:20,370
and invoking functions and so on

00:08:17,540 --> 00:08:22,920
capabilities that map directly on to the

00:08:20,370 --> 00:08:25,050
capabilities of machine language they

00:08:22,920 --> 00:08:27,090
have effectively defined a way to expose

00:08:25,050 --> 00:08:29,160
the machine language capabilities of a

00:08:27,090 --> 00:08:30,930
CPU using nothing but a platform

00:08:29,160 --> 00:08:33,750
independent like interpreted language

00:08:30,930 --> 00:08:38,940
JavaScript which means it is effectively

00:08:33,750 --> 00:08:40,950
a cross CPU assembly language but even a

00:08:38,940 --> 00:08:43,530
smj s can be improved upon what is

00:08:40,950 --> 00:08:45,720
delivered by ASM jeaious is still just

00:08:43,530 --> 00:08:48,000
JavaScript code admittedly it's almost

00:08:45,720 --> 00:08:50,550
illegible JavaScript code but it needs

00:08:48,000 --> 00:08:53,190
to be transmitted in text format then

00:08:50,550 --> 00:08:54,410
paused then interpreted then executed

00:08:53,190 --> 00:08:57,350
and then

00:08:54,410 --> 00:08:59,210
if we know ahead of time that our code

00:08:57,350 --> 00:09:01,580
will be compatible with that fast

00:08:59,210 --> 00:09:03,950
JavaScript subset can we send our code

00:09:01,580 --> 00:09:06,470
to the browser in a ready-to-use format

00:09:03,950 --> 00:09:09,310
and that's what web assembly is always

00:09:06,470 --> 00:09:11,780
on web assembly is a binary format

00:09:09,310 --> 00:09:13,850
formalizing the asm.js language subset

00:09:11,780 --> 00:09:16,700
in a format that can be delivered to the

00:09:13,850 --> 00:09:18,830
browser in a pre parsed pre hinted for

00:09:16,700 --> 00:09:21,440
juicing purposes form that makes it

00:09:18,830 --> 00:09:23,960
smaller to transmit than asm.js code

00:09:21,440 --> 00:09:25,850
because it's binary it is faster to

00:09:23,960 --> 00:09:28,400
start because you don't have to parse

00:09:25,850 --> 00:09:30,170
the code and it's more consistent in

00:09:28,400 --> 00:09:32,240
operation because you are telling the

00:09:30,170 --> 00:09:35,360
JIT exactly what operations are legal

00:09:32,240 --> 00:09:37,970
and where the optimizations are so

00:09:35,360 --> 00:09:39,470
that's how we got here but how do we

00:09:37,970 --> 00:09:42,350
actually use it well the development

00:09:39,470 --> 00:09:43,730
story for wasm pretty closely mirrors

00:09:42,350 --> 00:09:44,960
the story that I have already had just

00:09:43,730 --> 00:09:47,570
gone through telling you about running

00:09:44,960 --> 00:09:50,720
your normal executable binaries where

00:09:47,570 --> 00:09:52,550
zoom is ultimately a binary format but

00:09:50,720 --> 00:09:54,860
unless you belong to the standing in a

00:09:52,550 --> 00:09:57,050
hammock School of Engineering you are

00:09:54,860 --> 00:09:58,970
not going to write every resum right

00:09:57,050 --> 00:10:01,250
where's encode directly what you want is

00:09:58,970 --> 00:10:03,380
a human readable text based assembly

00:10:01,250 --> 00:10:06,020
format that can compile directly to

00:10:03,380 --> 00:10:07,370
Azzam what's your the toolchain you need

00:10:06,020 --> 00:10:09,260
to do this is called the web assembly

00:10:07,370 --> 00:10:10,430
binary toolkit this gives you a whole

00:10:09,260 --> 00:10:12,230
bunch of tools for manipulating

00:10:10,430 --> 00:10:14,360
compiling decompiling wesam code

00:10:12,230 --> 00:10:16,070
including an assembly language compiler

00:10:14,360 --> 00:10:17,000
that lets you write where's encode in a

00:10:16,070 --> 00:10:21,770
text format called

00:10:17,000 --> 00:10:23,600
wait for web assembly text what looks

00:10:21,770 --> 00:10:25,820
like a weird hybrid between Lisp and

00:10:23,600 --> 00:10:27,620
assembly it is a core set of primitive

00:10:25,820 --> 00:10:29,720
operations with a brace syntax to make

00:10:27,620 --> 00:10:31,670
scoping rules explicit sorry

00:10:29,720 --> 00:10:34,850
here is our integer addition example in

00:10:31,670 --> 00:10:37,520
what we define a module a module

00:10:34,850 --> 00:10:39,890
contains a function called add add takes

00:10:37,520 --> 00:10:42,200
two parameters first and second they are

00:10:39,890 --> 00:10:44,750
declared as being 32-bit signed integers

00:10:42,200 --> 00:10:47,450
I 32s and the function returns a signed

00:10:44,750 --> 00:10:49,130
32-bit integer as well and I 32 we then

00:10:47,450 --> 00:10:51,020
get the body of the method and executing

00:10:49,130 --> 00:10:52,850
where's a method is a stack based

00:10:51,020 --> 00:10:54,560
machine virtual machine so to do our

00:10:52,850 --> 00:10:56,420
addition we need to load the values

00:10:54,560 --> 00:10:58,610
provided as arguments onto our operating

00:10:56,420 --> 00:11:00,470
stack we load the first the argument

00:10:58,610 --> 00:11:02,300
first we load the argument second we now

00:11:00,470 --> 00:11:04,490
have two arguments on our stack and we

00:11:02,300 --> 00:11:06,680
can invoke the integer 32-bit add

00:11:04,490 --> 00:11:07,760
operation which pops two values off the

00:11:06,680 --> 00:11:09,790
stack does the addition

00:11:07,760 --> 00:11:12,620
pushes the result back onto the stack

00:11:09,790 --> 00:11:14,600
the rebound at the end of the method the

00:11:12,620 --> 00:11:16,339
value that is on top of the stack at the

00:11:14,600 --> 00:11:17,870
completion of execution of the method is

00:11:16,339 --> 00:11:19,040
considered to be the return value for

00:11:17,870 --> 00:11:22,130
that method and so we've just

00:11:19,040 --> 00:11:23,959
implemented an ad that completes our

00:11:22,130 --> 00:11:25,250
method definition so now we can export

00:11:23,959 --> 00:11:26,480
that function to say we want other

00:11:25,250 --> 00:11:29,180
modules to be able to see this ad

00:11:26,480 --> 00:11:32,180
function and that's it if we save that

00:11:29,180 --> 00:11:34,399
code as example dot bat and we run the

00:11:32,180 --> 00:11:36,949
compiler called wet to wasm over it you

00:11:34,399 --> 00:11:40,610
get example dot plasm which is a forty

00:11:36,949 --> 00:11:43,550
one byte binary file containing those

00:11:40,610 --> 00:11:45,019
instructions to use that ways on file

00:11:43,550 --> 00:11:47,360
you do need to write a little bit of

00:11:45,019 --> 00:11:49,459
JavaScript we fetch the wasm document

00:11:47,360 --> 00:11:51,139
same just using the fetcher fetch API on

00:11:49,459 --> 00:11:52,850
your in your job in JavaScript from the

00:11:51,139 --> 00:11:54,860
browser we use the payload of that

00:11:52,850 --> 00:11:56,630
document to instantiate a web assembly

00:11:54,860 --> 00:11:58,010
module and then we can access the

00:11:56,630 --> 00:12:00,620
exports of that module and invoke them

00:11:58,010 --> 00:12:02,060
in this case the the add method the add

00:12:00,620 --> 00:12:03,350
method returns an integer we can do

00:12:02,060 --> 00:12:05,000
whatever we need to do with that integer

00:12:03,350 --> 00:12:07,000
in this case we're going to set the text

00:12:05,000 --> 00:12:09,380
content of an element on our web page

00:12:07,000 --> 00:12:11,449
now to be clear this isn't some

00:12:09,380 --> 00:12:12,829
theoretical future thing either this

00:12:11,449 --> 00:12:15,079
code that the example code I've just

00:12:12,829 --> 00:12:16,370
shown you will work in any browser that

00:12:15,079 --> 00:12:18,290
has been released in the last two years

00:12:16,370 --> 00:12:19,370
there are a couple of optimizations you

00:12:18,290 --> 00:12:21,050
can do if you're using Chrome and

00:12:19,370 --> 00:12:23,560
Firefox in terms of loading it that

00:12:21,050 --> 00:12:25,940
fetch example is funny completes that

00:12:23,560 --> 00:12:27,199
only completes its load once the

00:12:25,940 --> 00:12:28,699
document is entirely loaded there is an

00:12:27,199 --> 00:12:30,949
incremental compiler that's part of an

00:12:28,699 --> 00:12:33,199
evolving JavaScript spec but this code

00:12:30,949 --> 00:12:36,589
will work in any browser that's up to

00:12:33,199 --> 00:12:38,389
two years old okay so that's a simple

00:12:36,589 --> 00:12:39,649
example edition example but integer

00:12:38,389 --> 00:12:42,079
addition is only going to get you so far

00:12:39,649 --> 00:12:44,480
so what else can you do with Wesson

00:12:42,079 --> 00:12:47,660
well where's on is an assembly language

00:12:44,480 --> 00:12:50,000
it is primitive very primitive the full

00:12:47,660 --> 00:12:52,490
wisdom instruction specification is one

00:12:50,000 --> 00:12:55,100
relatively terse HTML page and it only

00:12:52,490 --> 00:12:56,690
has five sections first there are

00:12:55,100 --> 00:12:57,380
numeric instructions add subtract

00:12:56,690 --> 00:12:59,540
multiply divide

00:12:57,380 --> 00:13:01,190
bullying's like and' and or' function

00:12:59,540 --> 00:13:03,350
operations like square root ceiling and

00:13:01,190 --> 00:13:04,760
floor Max and min and comparison

00:13:03,350 --> 00:13:06,769
operators like equality less than

00:13:04,760 --> 00:13:09,110
greater than these can be invoked on

00:13:06,769 --> 00:13:11,600
integers and floats in 32 and 64-bit

00:13:09,110 --> 00:13:13,730
ranges signed and unsigned then there

00:13:11,600 --> 00:13:15,709
are variable instructions operations to

00:13:13,730 --> 00:13:17,510
get and set variables in your local

00:13:15,709 --> 00:13:18,980
scope there's also a thing called T

00:13:17,510 --> 00:13:20,750
which lets you set the variable and keep

00:13:18,980 --> 00:13:22,550
it on the stack at the same time

00:13:20,750 --> 00:13:24,530
next there are control instructions

00:13:22,550 --> 00:13:26,030
mechanisms to do branch control looping

00:13:24,530 --> 00:13:27,950
invocation of other functions returning

00:13:26,030 --> 00:13:29,510
a value from a function there are memory

00:13:27,950 --> 00:13:31,490
instructions there are mechanisms to

00:13:29,510 --> 00:13:33,410
allocate a block of memory for the wasm

00:13:31,490 --> 00:13:35,600
interpreter to use to load and store

00:13:33,410 --> 00:13:37,250
values in that memory memory is

00:13:35,600 --> 00:13:39,590
implement implemented as an array of

00:13:37,250 --> 00:13:41,300
bytes it's just a great big array that

00:13:39,590 --> 00:13:42,950
can be grown can't be shrunk but you can

00:13:41,300 --> 00:13:44,840
point to point locations in that memory

00:13:42,950 --> 00:13:46,970
and do things with that content of

00:13:44,840 --> 00:13:48,740
memory and lastly there are parametric

00:13:46,970 --> 00:13:50,150
instructions which Lele exists to let

00:13:48,740 --> 00:13:52,940
you discard values that exist on the

00:13:50,150 --> 00:13:54,670
stack these instructions are then

00:13:52,940 --> 00:13:56,750
wrapped up into a module a module

00:13:54,670 --> 00:13:57,950
obviously includes function definitions

00:13:56,750 --> 00:14:00,020
why we've already seen but it includes

00:13:57,950 --> 00:14:01,640
other information too there are types

00:14:00,020 --> 00:14:03,680
and tables that let you define more

00:14:01,640 --> 00:14:05,240
complex data structures reference other

00:14:03,680 --> 00:14:07,850
functions in your ways and module

00:14:05,240 --> 00:14:09,140
memories defined sequences of blocks of

00:14:07,850 --> 00:14:11,990
memory that you want to pre allocate

00:14:09,140 --> 00:14:13,880
Global's define global variables exports

00:14:11,990 --> 00:14:15,500
to find the public interface that your

00:14:13,880 --> 00:14:17,810
weather module will expose to Inc

00:14:15,500 --> 00:14:19,670
outside users and there are imports that

00:14:17,810 --> 00:14:21,260
let you say these are external modules

00:14:19,670 --> 00:14:23,600
that this weather module expects to

00:14:21,260 --> 00:14:25,070
exist and lastly there's a space for you

00:14:23,600 --> 00:14:26,630
to define data and code that will

00:14:25,070 --> 00:14:29,030
execute when the module is instantiated

00:14:26,630 --> 00:14:31,130
the one thing you might notice that we

00:14:29,030 --> 00:14:32,000
have not spoken about any discussion of

00:14:31,130 --> 00:14:34,339
text strings

00:14:32,000 --> 00:14:37,370
that's because wisdom does not natively

00:14:34,339 --> 00:14:39,320
support strings a string in wisdom is

00:14:37,370 --> 00:14:41,450
handled the same way your CPU handles it

00:14:39,320 --> 00:14:43,370
it only knows about integers and floats

00:14:41,450 --> 00:14:45,290
so to create a string you allocate a

00:14:43,370 --> 00:14:47,000
block of memory you use an integer as a

00:14:45,290 --> 00:14:49,339
pointer to the position of that memory

00:14:47,000 --> 00:14:50,960
in the overall memory block you then use

00:14:49,339 --> 00:14:52,760
whatever contents is at that memory

00:14:50,960 --> 00:14:54,950
block to be a list of integers and

00:14:52,760 --> 00:14:57,440
assign some sort of significance to

00:14:54,950 --> 00:15:00,140
those integers B at a ski or utf-8

00:14:57,440 --> 00:15:01,610
encoded Unicode code points when I say

00:15:00,140 --> 00:15:03,589
wears them exposes primitives that's

00:15:01,610 --> 00:15:06,890
what I mean primitives remember this is

00:15:03,589 --> 00:15:08,510
an assembly language but just as very

00:15:06,890 --> 00:15:10,550
few people write more assembly code

00:15:08,510 --> 00:15:13,190
anymore very few people really need to

00:15:10,550 --> 00:15:15,110
write raw wasm a much easier approach is

00:15:13,190 --> 00:15:17,750
to use a compiler for a language that

00:15:15,110 --> 00:15:20,000
can target wisdom the most notable of

00:15:17,750 --> 00:15:22,130
these is in scripting and scripting is a

00:15:20,000 --> 00:15:23,780
back-end to the clang C compiler if

00:15:22,130 --> 00:15:25,760
you've got a language that clang can

00:15:23,780 --> 00:15:28,520
compile black C and many others in

00:15:25,760 --> 00:15:32,450
script n' can turn that code into a wasm

00:15:28,520 --> 00:15:34,490
binary so let's define a simple c

00:15:32,450 --> 00:15:36,470
function to do some addition

00:15:34,490 --> 00:15:38,120
we use an inscription compiler directive

00:15:36,470 --> 00:15:40,130
to mark the function as keepalive which

00:15:38,120 --> 00:15:41,270
is in script ins notation for I want

00:15:40,130 --> 00:15:44,209
this module or this method to be

00:15:41,270 --> 00:15:47,930
exported we use the in scripting C

00:15:44,209 --> 00:15:50,660
compiler EMCC to compile example dot C

00:15:47,930 --> 00:15:52,850
into example dot j s and note that we're

00:15:50,660 --> 00:15:55,760
not compiling to example but as 'm

00:15:52,850 --> 00:15:58,310
directly using c means that there is

00:15:55,760 --> 00:16:00,709
some overhead using any using a language

00:15:58,310 --> 00:16:02,450
abstraction means there is some overhead

00:16:00,709 --> 00:16:04,250
of using that abstraction there are a

00:16:02,450 --> 00:16:06,160
bunch of c related infrastructure that

00:16:04,250 --> 00:16:08,540
needs to exist for the c code to work

00:16:06,160 --> 00:16:10,790
example dot j s contains all that

00:16:08,540 --> 00:16:12,620
bootstrapping code we also need to tell

00:16:10,790 --> 00:16:14,240
MCC the name of the module that we

00:16:12,620 --> 00:16:16,459
wanted to have as we export it and we

00:16:14,240 --> 00:16:20,120
tell it to export the C R app runtime

00:16:16,459 --> 00:16:21,950
method which I'll come to in a moment if

00:16:20,120 --> 00:16:24,020
there was a module contained an entry

00:16:21,950 --> 00:16:26,089
point so if it had a main method in the

00:16:24,020 --> 00:16:28,610
in this in the C code we could just

00:16:26,089 --> 00:16:30,649
include the example J s file in our HTML

00:16:28,610 --> 00:16:32,839
and that code would execute as soon as

00:16:30,649 --> 00:16:35,089
that JavaScript file was loaded in our

00:16:32,839 --> 00:16:36,770
hey but if we if we want to like use

00:16:35,089 --> 00:16:38,839
methods in that module we need to hook

00:16:36,770 --> 00:16:41,990
into the lifecycle of that module so in

00:16:38,839 --> 00:16:44,600
our HTML we pre declare an example

00:16:41,990 --> 00:16:46,579
object and we define a method to run

00:16:44,600 --> 00:16:48,740
when the whether a runtime has been in

00:16:46,579 --> 00:16:51,050
initialized in that method we define a

00:16:48,740 --> 00:16:52,970
wrapper for our C method using example

00:16:51,050 --> 00:16:54,709
dot C wrap which essentially Maps the

00:16:52,970 --> 00:16:57,440
JavaScript types onto the arguments that

00:16:54,709 --> 00:16:59,089
are going to exist in our you know seem

00:16:57,440 --> 00:17:01,430
to see method as exposed to the

00:16:59,089 --> 00:17:03,140
JavaScript runtime we then include the

00:17:01,430 --> 00:17:05,449
example script which augments the rest

00:17:03,140 --> 00:17:08,630
of the example object with all the other

00:17:05,449 --> 00:17:10,520
web assembly pieces now for this simple

00:17:08,630 --> 00:17:12,020
example there is a lot of overhead it's

00:17:10,520 --> 00:17:14,030
a lot more complicated there's a lot

00:17:12,020 --> 00:17:15,470
more over here this example produces

00:17:14,030 --> 00:17:17,600
about a hundred kilobytes of

00:17:15,470 --> 00:17:20,870
bootstrapping support code and about 21

00:17:17,600 --> 00:17:23,300
kilobytes of where's and binary however

00:17:20,870 --> 00:17:26,300
a lot of that overhead is included just

00:17:23,300 --> 00:17:28,309
in case and by default C compilers tend

00:17:26,300 --> 00:17:30,920
to optimize for compilation speed rather

00:17:28,309 --> 00:17:33,170
than output size so when you are ready

00:17:30,920 --> 00:17:34,820
to go into production you can tell the

00:17:33,170 --> 00:17:36,350
compiler to go into optimized mode and

00:17:34,820 --> 00:17:38,660
strip out everything that isn't needed

00:17:36,350 --> 00:17:41,420
and that can dramatically reduce your

00:17:38,660 --> 00:17:42,770
payload size that optimization can be

00:17:41,420 --> 00:17:44,090
done at various levels which takes a

00:17:42,770 --> 00:17:46,400
little bit longer to compile the more

00:17:44,090 --> 00:17:47,790
optimization you do at optimization

00:17:46,400 --> 00:17:50,700
level 3 the

00:17:47,790 --> 00:17:53,210
put of that same C file is about 19

00:17:50,700 --> 00:17:56,640
kilobytes of minimized JavaScript and

00:17:53,210 --> 00:17:59,700
165 bytes of wasm which is a lot closer

00:17:56,640 --> 00:18:03,300
to our original handcrafted 41 byte bat

00:17:59,700 --> 00:18:06,150
file there is still some overhead though

00:18:03,300 --> 00:18:08,220
but remember you do get benefits from

00:18:06,150 --> 00:18:10,460
that overhead like for example not

00:18:08,220 --> 00:18:13,380
having to write assembly code by hand

00:18:10,460 --> 00:18:15,030
strings are handled almost completely

00:18:13,380 --> 00:18:17,100
transparently you can declare a c

00:18:15,030 --> 00:18:19,590
function as a string we're taking a

00:18:17,100 --> 00:18:21,660
string argument a character pointer as

00:18:19,590 --> 00:18:23,940
an argument it returns a c string again

00:18:21,660 --> 00:18:25,530
a character pointer on the JavaScript

00:18:23,940 --> 00:18:27,000
side we wrapped that function as being

00:18:25,530 --> 00:18:28,710
something that accepts and returns

00:18:27,000 --> 00:18:33,000
strings and you can invoke that function

00:18:28,710 --> 00:18:34,410
with JavaScript strings inscription also

00:18:33,000 --> 00:18:36,660
makes it easy to interact with

00:18:34,410 --> 00:18:38,550
JavaScript simple scripts can be invoked

00:18:36,660 --> 00:18:40,440
directly within script and run script

00:18:38,550 --> 00:18:42,330
which you can see it on my func direct a

00:18:40,440 --> 00:18:45,990
function call at the bottom there first

00:18:42,330 --> 00:18:47,970
call just call an alert in stored as a

00:18:45,990 --> 00:18:50,790
string but here's another example you

00:18:47,970 --> 00:18:53,250
can also embed JavaScript code in your C

00:18:50,790 --> 00:18:55,020
code so inscription provides an e MJS

00:18:53,250 --> 00:18:58,050
directive which lets you define a

00:18:55,020 --> 00:19:00,210
prototype for a JavaScript method define

00:18:58,050 --> 00:19:01,800
the JavaScript in your C file and when

00:19:00,210 --> 00:19:04,290
you compile it you can just call that

00:19:01,800 --> 00:19:07,020
function as if it was C but it will run

00:19:04,290 --> 00:19:08,670
as JavaScript so in this case we've got

00:19:07,020 --> 00:19:11,400
two different ways of showing an alert

00:19:08,670 --> 00:19:13,650
and the in CAS ad is also doing an

00:19:11,400 --> 00:19:15,990
addition the addition is being done in

00:19:13,650 --> 00:19:18,330
JavaScript it's being wrapped in C being

00:19:15,990 --> 00:19:21,630
invoked over wasm from javascript in

00:19:18,330 --> 00:19:25,200
your original source file standing in a

00:19:21,630 --> 00:19:27,060
hammock you also get access to a bunch

00:19:25,200 --> 00:19:27,990
of other tools and api's that are part

00:19:27,060 --> 00:19:30,480
of the in script and tool chain

00:19:27,990 --> 00:19:31,980
inscription provides bindings to html5

00:19:30,480 --> 00:19:34,170
events so you can write native

00:19:31,980 --> 00:19:36,270
implementations of keyboard mouse scroll

00:19:34,170 --> 00:19:36,660
handlers you get access to a file system

00:19:36,270 --> 00:19:38,880
API

00:19:36,660 --> 00:19:41,370
you are still sandboxed you can't read

00:19:38,880 --> 00:19:43,260
files on your users file system but you

00:19:41,370 --> 00:19:45,960
do get a virtual file system that you

00:19:43,260 --> 00:19:48,390
can feed binary blobs of data and access

00:19:45,960 --> 00:19:50,160
them as if they were C as C files you

00:19:48,390 --> 00:19:52,170
can use the browser's fetch API to

00:19:50,160 --> 00:19:54,060
access network resources and you can

00:19:52,170 --> 00:19:58,140
access all sorts of hardware optimized

00:19:54,060 --> 00:20:00,000
api's like WebGL and web they are now

00:19:58,140 --> 00:20:01,590
inscription was the first player in this

00:20:00,000 --> 00:20:03,510
compiled language space but it isn't the

00:20:01,590 --> 00:20:06,120
only player anymore for example the rust

00:20:03,510 --> 00:20:08,370
compiler can compile directly to resin

00:20:06,120 --> 00:20:09,600
the rust project has really good docs

00:20:08,370 --> 00:20:11,400
and tutorials about how to write and

00:20:09,600 --> 00:20:14,130
deploy logic for your web app in Rusk if

00:20:11,400 --> 00:20:16,590
you want to go down that path okay so

00:20:14,130 --> 00:20:18,720
that's how you generate wisdom code but

00:20:16,590 --> 00:20:21,720
why is wisdom of interest to us as

00:20:18,720 --> 00:20:23,820
Python and Django users well there are

00:20:21,720 --> 00:20:26,730
two primary use cases for wisdom in

00:20:23,820 --> 00:20:29,039
production right now the first is

00:20:26,730 --> 00:20:32,010
deploying a full application that

00:20:29,039 --> 00:20:34,679
already exists and is written in C for

00:20:32,010 --> 00:20:36,860
example if you go to quake JS comm you

00:20:34,679 --> 00:20:40,200
will find a full port of quake 3

00:20:36,860 --> 00:20:41,669
compiled and running in your browser it

00:20:40,200 --> 00:20:44,460
takes about a minute or two to download

00:20:41,669 --> 00:20:46,860
but once it's there it's a full 3d

00:20:44,460 --> 00:20:49,890
first-person shooter running in your

00:20:46,860 --> 00:20:52,559
browser why does it work well quake is

00:20:49,890 --> 00:20:54,809
written in C it uses OpenGL and it uses

00:20:52,559 --> 00:20:56,520
keyboard inputs those features map

00:20:54,809 --> 00:20:58,830
really well onto the capabilities of

00:20:56,520 --> 00:21:00,450
wasm as a mechanism of deploying an

00:20:58,830 --> 00:21:01,309
application that has already that has

00:21:00,450 --> 00:21:05,279
already been written

00:21:01,309 --> 00:21:06,539
QT as all is a widget framework they are

00:21:05,279 --> 00:21:09,000
working on web assembly support as well

00:21:06,539 --> 00:21:11,100
so if you have a QT app you can compile

00:21:09,000 --> 00:21:12,000
that app and deliver it over the web and

00:21:11,100 --> 00:21:14,789
you'll get something that looks like

00:21:12,000 --> 00:21:17,130
your QT app running inside a browser now

00:21:14,789 --> 00:21:18,779
I won't say it's trivial to do this but

00:21:17,130 --> 00:21:20,850
the in script and build tool chain Maps

00:21:18,779 --> 00:21:23,100
really well onto the auto comfort all

00:21:20,850 --> 00:21:24,659
chain so if you have a C project with a

00:21:23,100 --> 00:21:27,840
configure script which you know a lot of

00:21:24,659 --> 00:21:29,700
C projects out there do it's not that

00:21:27,840 --> 00:21:31,710
difficult to get it compiled and running

00:21:29,700 --> 00:21:36,960
in the browser for suitable definitions

00:21:31,710 --> 00:21:38,880
of not that complicated use case 2 is an

00:21:36,960 --> 00:21:40,710
optimization use case to identify hot

00:21:38,880 --> 00:21:42,330
loops or critical business capabilities

00:21:40,710 --> 00:21:44,730
and replace them with where some

00:21:42,330 --> 00:21:45,990
implementations for example Google has

00:21:44,730 --> 00:21:48,809
published a demonstrator app called

00:21:45,990 --> 00:21:51,090
squash squash is an app for doing image

00:21:48,809 --> 00:21:52,860
manipulation for exploring the before

00:21:51,090 --> 00:21:54,360
and after effects of various forms of

00:21:52,860 --> 00:21:56,399
image compression resizing and

00:21:54,360 --> 00:21:58,890
resampling algorithms the actual app

00:21:56,399 --> 00:22:00,960
itself is a node app that delivers the

00:21:58,890 --> 00:22:02,549
basic app content and UI and buttons you

00:22:00,960 --> 00:22:05,580
can click on on user interface elements

00:22:02,549 --> 00:22:08,039
but under the hood it uses wasm to do

00:22:05,580 --> 00:22:10,110
all the image processing almost all of

00:22:08,039 --> 00:22:12,570
the image codec libraries out there are

00:22:10,110 --> 00:22:14,309
written in C or have a C implementation

00:22:12,570 --> 00:22:15,299
available for them so instead of trying

00:22:14,309 --> 00:22:17,850
to re-implement

00:22:15,299 --> 00:22:20,970
leap jpg in JavaScript you can use

00:22:17,850 --> 00:22:23,789
wisdom to compile lib jpg as well and

00:22:20,970 --> 00:22:26,039
then invoke it as AC function over over

00:22:23,789 --> 00:22:28,080
the in scripting interface if you've got

00:22:26,039 --> 00:22:31,259
AC library that you need to use

00:22:28,080 --> 00:22:32,940
client-side you now can or if you are

00:22:31,259 --> 00:22:34,769
writing a web app that has a hot loop

00:22:32,940 --> 00:22:36,539
that has something that is very very CPU

00:22:34,769 --> 00:22:38,399
intensive and isn't performing well in

00:22:36,539 --> 00:22:41,070
JavaScript you can go and take that

00:22:38,399 --> 00:22:43,019
method rewrite it in C or rust compile

00:22:41,070 --> 00:22:44,909
it as wisdom deliver that as a payload

00:22:43,019 --> 00:22:46,259
and invoke that hot loop as a function

00:22:44,909 --> 00:22:49,529
that should hopefully run natively and

00:22:46,259 --> 00:22:51,330
run fast if you just want to quickly

00:22:49,529 --> 00:22:52,440
play around with wisdom the best tool

00:22:51,330 --> 00:22:54,450
that I can recommend at the moment is

00:22:52,440 --> 00:22:56,489
web assembly not studio that is a URL

00:22:54,450 --> 00:22:58,080
not a product name if you stick that

00:22:56,489 --> 00:22:59,940
into your browser you will get a simple

00:22:58,080 --> 00:23:02,580
wisdom development environment looks

00:22:59,940 --> 00:23:03,389
very much like an IDE and you can play

00:23:02,580 --> 00:23:04,830
around with that without having to

00:23:03,389 --> 00:23:05,789
download the rest of the tool chains and

00:23:04,830 --> 00:23:08,340
everything it's you can write the code

00:23:05,789 --> 00:23:10,049
press compile and it will run if you

00:23:08,340 --> 00:23:11,519
like what you see there then by all

00:23:10,049 --> 00:23:13,230
means go and download the web assembly

00:23:11,519 --> 00:23:14,999
binary toolkit or in script and rust

00:23:13,230 --> 00:23:16,409
swears and tooling the tutorials are

00:23:14,999 --> 00:23:19,590
actually not too bad for most of those

00:23:16,409 --> 00:23:21,389
tools okay so those are the visible use

00:23:19,590 --> 00:23:24,210
cases right now but what does the future

00:23:21,389 --> 00:23:24,960
hold how do we make use of Python in the

00:23:24,210 --> 00:23:27,330
Wesen world

00:23:24,960 --> 00:23:28,799
well again think back to the start of

00:23:27,330 --> 00:23:30,869
this talk I spoke about the path of

00:23:28,799 --> 00:23:32,549
getting code to run from assembly

00:23:30,869 --> 00:23:33,989
language to compiled language to

00:23:32,549 --> 00:23:35,309
interpreted language and then I

00:23:33,989 --> 00:23:36,749
described a similar path for wisdom

00:23:35,309 --> 00:23:38,489
defining an assembly language and

00:23:36,749 --> 00:23:40,440
compilers the target that assembly

00:23:38,489 --> 00:23:42,539
language there is one more step we can

00:23:40,440 --> 00:23:45,659
take we can write language interpreters

00:23:42,539 --> 00:23:47,039
that can be deployed as wisdom now I

00:23:45,659 --> 00:23:48,480
can't say that this is ready for

00:23:47,039 --> 00:23:50,309
primetime but there are a couple of

00:23:48,480 --> 00:23:52,289
projects that are exploring this space

00:23:50,309 --> 00:23:54,570
the most notable it will be pi ax died

00:23:52,289 --> 00:23:56,940
from Mozilla pi ax died is literally the

00:23:54,570 --> 00:23:58,559
C Python source code compiled within

00:23:56,940 --> 00:24:00,330
scripting they've also gone to the

00:23:58,559 --> 00:24:02,070
trouble of compiling numpy and Syfy and

00:24:00,330 --> 00:24:04,649
matplotlib and a couple other key parts

00:24:02,070 --> 00:24:06,899
of the Python ecosystem as that have C

00:24:04,649 --> 00:24:08,669
extension modules if you take the wagon

00:24:06,899 --> 00:24:10,679
binary produced by n script and

00:24:08,669 --> 00:24:12,720
compiling C Python and hook it up to

00:24:10,679 --> 00:24:14,970
some input elements in a web page you

00:24:12,720 --> 00:24:16,499
get Python in the browser you get a pull

00:24:14,970 --> 00:24:19,529
Python shell in the browser and the PI

00:24:16,499 --> 00:24:21,710
died demo is effectively a 100%

00:24:19,529 --> 00:24:23,909
client-side Python environment

00:24:21,710 --> 00:24:25,259
comparable to a Jupiter notebook session

00:24:23,909 --> 00:24:26,759
so instead like Jupiter is normally a

00:24:25,259 --> 00:24:27,210
client side talking to a kernel in the

00:24:26,759 --> 00:24:29,070
backend

00:24:27,210 --> 00:24:29,470
there's no kernel it's just a web page a

00:24:29,070 --> 00:24:30,789
sing

00:24:29,470 --> 00:24:33,760
webpage compiling and running your

00:24:30,789 --> 00:24:37,120
Python code it is a full Python parser

00:24:33,760 --> 00:24:39,460
compiler and runtime the downside is

00:24:37,120 --> 00:24:41,530
that it is big the wesam file for pi

00:24:39,460 --> 00:24:43,210
died is for just C Python is around

00:24:41,530 --> 00:24:44,679
three megabytes if you want the rest of

00:24:43,210 --> 00:24:45,940
the C Python standard library and all

00:24:44,679 --> 00:24:47,440
the other bits and pieces it gets bigger

00:24:45,940 --> 00:24:49,390
and bigger I think about 12 megabyte for

00:24:47,440 --> 00:24:52,419
pi died and that's before you've given

00:24:49,390 --> 00:24:53,980
it any Python code to run so if c python

00:24:52,419 --> 00:24:55,990
is too big maybe we just need a smaller

00:24:53,980 --> 00:24:57,880
Python what about micro Python it's

00:24:55,990 --> 00:24:59,919
written in C can we compile that well

00:24:57,880 --> 00:25:02,919
yes you can and it's been done and it's

00:24:59,919 --> 00:25:04,900
on NPM you can install via NPM a

00:25:02,919 --> 00:25:06,730
JavaScript package providing the micro

00:25:04,900 --> 00:25:08,230
Python virtual machine and it is yes

00:25:06,730 --> 00:25:10,650
smaller than Piatt died the official

00:25:08,230 --> 00:25:12,640
distribution is just shy of one megabyte

00:25:10,650 --> 00:25:14,740
this project all these projects are

00:25:12,640 --> 00:25:16,450
still experimental they ask but they are

00:25:14,740 --> 00:25:17,559
very interesting developments but they

00:25:16,450 --> 00:25:20,590
both take a very similar approach

00:25:17,559 --> 00:25:23,500
exposing a full Python repple row read

00:25:20,590 --> 00:25:24,940
eval print loop into the browser my own

00:25:23,500 --> 00:25:26,980
experimentation in this space has been

00:25:24,940 --> 00:25:28,720
somewhat different Batavia is a

00:25:26,980 --> 00:25:30,760
mechanism that provides Python in the

00:25:28,720 --> 00:25:33,580
browser by just implementing the C

00:25:30,760 --> 00:25:36,280
Python virtual machine if you transmit c

00:25:33,580 --> 00:25:38,380
python bytecode on the wire you don't

00:25:36,280 --> 00:25:39,669
need a compiler and a parser in the

00:25:38,380 --> 00:25:42,159
browser you just need the bytecode

00:25:39,669 --> 00:25:44,650
machine but Tavia currently does that by

00:25:42,159 --> 00:25:46,090
implementing c python bytecode virtual

00:25:44,650 --> 00:25:48,730
machines are either c python vitae code

00:25:46,090 --> 00:25:50,260
virtual machine in pure javascript but

00:25:48,730 --> 00:25:51,850
whereas it might provide an alternative

00:25:50,260 --> 00:25:53,890
here if you were to take the C Python

00:25:51,850 --> 00:25:55,539
sources or the microbiomes sources strip

00:25:53,890 --> 00:25:57,460
out the pipe of the parser and the

00:25:55,539 --> 00:26:00,039
compiler you will end up with a much

00:25:57,460 --> 00:26:01,870
smaller Python interpreter but one that

00:26:00,039 --> 00:26:05,049
is entirely capable of running C Python

00:26:01,870 --> 00:26:07,059
bytecode or micro Python bytecode it

00:26:05,049 --> 00:26:08,620
would actually support the C module

00:26:07,059 --> 00:26:09,929
extension API as well if you were if you

00:26:08,620 --> 00:26:11,650
were compiling the C Python version

00:26:09,929 --> 00:26:13,980
compile that with some smart

00:26:11,650 --> 00:26:17,590
tree-shaking and entirely client sides

00:26:13,980 --> 00:26:19,270
Python starts to look plausible and that

00:26:17,590 --> 00:26:21,159
C module capability is itself a point of

00:26:19,270 --> 00:26:22,690
interest one of the major reasons that

00:26:21,159 --> 00:26:24,370
people write C modules for Python is for

00:26:22,690 --> 00:26:26,500
performance reasons take a hot loop in

00:26:24,370 --> 00:26:28,150
your Python code write it in C but using

00:26:26,500 --> 00:26:28,929
a C module means your Python code can no

00:26:28,150 --> 00:26:30,220
longer work

00:26:28,929 --> 00:26:32,980
cross-platform at least not without

00:26:30,220 --> 00:26:35,830
recompilation but if you compile your C

00:26:32,980 --> 00:26:38,409
module into wasm you get a cross compr

00:26:35,830 --> 00:26:39,909
across platform binary all you need then

00:26:38,409 --> 00:26:42,970
is the ability to invoke that cross

00:26:39,909 --> 00:26:43,160
platform from cross-platform binary from

00:26:42,970 --> 00:26:44,870
you

00:26:43,160 --> 00:26:46,880
Python code which is what a Python

00:26:44,870 --> 00:26:48,410
module called was Irma dance where Zuma

00:26:46,880 --> 00:26:50,150
is part of a larger project that's

00:26:48,410 --> 00:26:51,770
attempting to make it across platform

00:26:50,150 --> 00:26:55,250
wineries as a distribution platform in

00:26:51,770 --> 00:26:58,670
themselves also well worth looking at so

00:26:55,250 --> 00:27:00,170
wrapping up in the mid-90s Java was the

00:26:58,670 --> 00:27:03,350
hotness because it was going to deliver

00:27:00,170 --> 00:27:04,520
write once run everywhere code it was

00:27:03,350 --> 00:27:06,470
able to run everywhere because it

00:27:04,520 --> 00:27:08,540
specified a bytecode format and provide

00:27:06,470 --> 00:27:11,870
a cross-platform letter virtual machine

00:27:08,540 --> 00:27:13,400
but it strongly coupled that that

00:27:11,870 --> 00:27:16,370
experienced that program experience to a

00:27:13,400 --> 00:27:18,470
new programming language called Java and

00:27:16,370 --> 00:27:20,720
the whole world got really enthusiastic

00:27:18,470 --> 00:27:22,520
about Java and Java isn't going anywhere

00:27:20,720 --> 00:27:24,440
but it also hasn't taken over the entire

00:27:22,520 --> 00:27:27,530
world other programming languages still

00:27:24,440 --> 00:27:30,530
exist it wasn't possible to displace the

00:27:27,530 --> 00:27:31,850
entire ecosystem javascript was invented

00:27:30,530 --> 00:27:33,530
at about the same time and it's called

00:27:31,850 --> 00:27:35,900
javascript because of the hype around

00:27:33,530 --> 00:27:37,430
Java it has nothing to do with Java but

00:27:35,900 --> 00:27:39,680
it needed to be called something Java

00:27:37,430 --> 00:27:41,120
because of that marketing hype because

00:27:39,680 --> 00:27:43,330
it was going to be as cross-platform and

00:27:41,120 --> 00:27:45,830
as important as Java was in the mid-90s

00:27:43,330 --> 00:27:48,340
it just essentially as it was there to

00:27:45,830 --> 00:27:50,660
be capitalizing on that marketing buzz

00:27:48,340 --> 00:27:52,250
javascript didn't have a standardized

00:27:50,660 --> 00:27:53,690
bytecode form at all provide a virtual

00:27:52,250 --> 00:27:55,490
machine to make a cross-platform he'd

00:27:53,690 --> 00:27:56,960
only worked in the browser but over time

00:27:55,490 --> 00:27:58,520
the importance of the web as a platform

00:27:56,960 --> 00:28:00,590
has meant that people have tried to

00:27:58,520 --> 00:28:02,210
bring JavaScript everywhere they've

00:28:00,590 --> 00:28:04,850
tried to reinvent the universe using

00:28:02,210 --> 00:28:07,040
only JavaScript making exactly the same

00:28:04,850 --> 00:28:10,970
mistake that Java made focusing on the

00:28:07,040 --> 00:28:12,740
language not the runtime the great irony

00:28:10,970 --> 00:28:14,360
here is that the promise that Java

00:28:12,740 --> 00:28:16,910
originally made write once run

00:28:14,360 --> 00:28:19,160
everywhere that promise may end up being

00:28:16,910 --> 00:28:20,870
delivered by JavaScript a language that

00:28:19,160 --> 00:28:23,210
borrowed the Java name for purely

00:28:20,870 --> 00:28:25,490
marketing purposes but even then we're

00:28:23,210 --> 00:28:28,910
going to get the capability by ignoring

00:28:25,490 --> 00:28:31,220
the language javascript has the

00:28:28,910 --> 00:28:32,720
potential to actually be a universal

00:28:31,220 --> 00:28:34,010
computing platform not because of

00:28:32,720 --> 00:28:35,570
JavaScript the language but because of

00:28:34,010 --> 00:28:37,730
the importance of the web as a platform

00:28:35,570 --> 00:28:39,620
and all of the effort that has been put

00:28:37,730 --> 00:28:42,650
into optimizing JavaScript runtimes as a

00:28:39,620 --> 00:28:44,390
result almost by accident we have ended

00:28:42,650 --> 00:28:45,770
up with wisdom a mechanism for

00:28:44,390 --> 00:28:47,600
describing cross-platform native

00:28:45,770 --> 00:28:49,400
executables and that ultimately is

00:28:47,600 --> 00:28:50,930
better for everyone because it abandons

00:28:49,400 --> 00:28:53,060
the idea that there is one programming

00:28:50,930 --> 00:28:54,800
language to rule them all let's every

00:28:53,060 --> 00:28:56,840
language find its own niche and lets

00:28:54,800 --> 00:28:58,400
other languages including Python

00:28:56,840 --> 00:29:00,980
coexist and cooperate with that

00:28:58,400 --> 00:29:02,000
ecosystem there is a lot of work that

00:29:00,980 --> 00:29:03,650
still needs to be done before we can

00:29:02,000 --> 00:29:04,850
speak about having an experience as a

00:29:03,650 --> 00:29:06,380
web developer that doesn't involve

00:29:04,850 --> 00:29:07,970
JavaScript at all or at least only

00:29:06,380 --> 00:29:09,350
involves JavaScript as an execution

00:29:07,970 --> 00:29:11,120
platform for our Python or whatever

00:29:09,350 --> 00:29:12,140
other language you want I would like to

00:29:11,120 --> 00:29:13,789
be able to spend a whole lot more time

00:29:12,140 --> 00:29:15,710
working on this stuff on batavia other

00:29:13,789 --> 00:29:17,000
aspects of the Python ecosystem so by

00:29:15,710 --> 00:29:18,679
way of a quick plug if you'd like to

00:29:17,000 --> 00:29:20,240
support my work you can join the berate

00:29:18,679 --> 00:29:21,289
project as a financial member or if you

00:29:20,240 --> 00:29:23,330
prefer you can back me on github

00:29:21,289 --> 00:29:24,470
sponsors I am here for the rest of park

00:29:23,330 --> 00:29:26,000
on through to the end of the sprints if

00:29:24,470 --> 00:29:27,350
any of this stuff interest you please

00:29:26,000 --> 00:29:29,510
come and have a chat I'd be delighted to

00:29:27,350 --> 00:29:36,429
chat about any of it thank you very much

00:29:29,510 --> 00:29:36,429

YouTube URL: https://www.youtube.com/watch?v=eJMT1aImS9Q


