Title: Python: Ludicrous mode (with Django)
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Tyson Clugg

http://2017.pycon-au.org/schedule/presentation/101/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:02,090 --> 00:00:06,779
okay

00:00:03,600 --> 00:00:08,490
up next we have Tyson clogged transit

00:00:06,779 --> 00:00:12,059
clogged has been hacking Jango since

00:00:08,490 --> 00:00:14,849
2007 alongside Jenga core developer

00:00:12,059 --> 00:00:16,890
Chris Maloney Tyson worked with Kurtis

00:00:14,849 --> 00:00:19,140
on security critical infrastructure

00:00:16,890 --> 00:00:21,210
including the access control system

00:00:19,140 --> 00:00:22,980
developed for the Melbourne Cup which

00:00:21,210 --> 00:00:25,380
was subsequently used by tikka tech

00:00:22,980 --> 00:00:27,420
these days Tyson can be found working

00:00:25,380 --> 00:00:31,740
for new Atlas either drinking coffee

00:00:27,420 --> 00:00:34,410
eating bomb in Bonn mean family bond me

00:00:31,740 --> 00:00:44,760
in Collingwood or relaxing at his home

00:00:34,410 --> 00:00:46,469
on the side of mount dandenong hi thanks

00:00:44,760 --> 00:00:50,539
I'm Tyson you can find me on Twitter

00:00:46,469 --> 00:00:54,420
Tyson club obviously I met new Atlas and

00:00:50,539 --> 00:00:56,610
we're not big we're not Google but we

00:00:54,420 --> 00:00:58,500
are in the top 1% of websites worldwide

00:00:56,610 --> 00:00:59,489
especially in the United States in fact

00:00:58,500 --> 00:01:01,829
I think at the moment we're writing

00:00:59,489 --> 00:01:03,270
about number two and a half thousand

00:01:01,829 --> 00:01:06,869
which for the United States isn't too

00:01:03,270 --> 00:01:08,670
bad for ranking there there's not going

00:01:06,869 --> 00:01:11,040
to be any Q&A and I think we're gonna

00:01:08,670 --> 00:01:14,790
have time so if you go into the slack

00:01:11,040 --> 00:01:18,299
channel on pike on a you has Ludacris

00:01:14,790 --> 00:01:21,270
you can find that I will put the entire

00:01:18,299 --> 00:01:23,640
talk up there upload it there so don't

00:01:21,270 --> 00:01:26,280
need to go and take screenshots or

00:01:23,640 --> 00:01:28,200
whatever no photos necessary yeah we'll

00:01:26,280 --> 00:01:30,180
go check in slack afterwards and also

00:01:28,200 --> 00:01:34,049
immediately after I'll be available to

00:01:30,180 --> 00:01:36,810
talk outside as well so the purpose of

00:01:34,049 --> 00:01:39,600
this talk is all about latency latency

00:01:36,810 --> 00:01:41,759
is such a critical feature to making

00:01:39,600 --> 00:01:43,829
your website replication high

00:01:41,759 --> 00:01:48,299
performance and it's quite different to

00:01:43,829 --> 00:01:50,460
bandwidth bandwidth measures how how

00:01:48,299 --> 00:01:52,770
much data you can transmit over a period

00:01:50,460 --> 00:01:54,659
of time whereas latency measures the

00:01:52,770 --> 00:01:58,140
delay between when the signal is starts

00:01:54,659 --> 00:01:59,850
being sent and when it arrives for

00:01:58,140 --> 00:02:01,770
optical and electrical networks it's

00:01:59,850 --> 00:02:03,329
essentially the speed of light although

00:02:01,770 --> 00:02:06,990
over copper it's only 2/3 the speed of

00:02:03,329 --> 00:02:11,160
light and to give you an idea one

00:02:06,990 --> 00:02:13,950
nanosecond is only about this far so if

00:02:11,160 --> 00:02:17,040
you even go from one machine to the next

00:02:13,950 --> 00:02:19,230
in a data center like literally across

00:02:17,040 --> 00:02:21,900
to the next machine chances are you're

00:02:19,230 --> 00:02:23,730
going to go that far if you're talking

00:02:21,900 --> 00:02:25,680
about across the data center where it

00:02:23,730 --> 00:02:28,290
might be 300 meters it within the same

00:02:25,680 --> 00:02:30,030
data center then chances are it's going

00:02:28,290 --> 00:02:32,010
to be more likely 300 meters and if

00:02:30,030 --> 00:02:34,050
you've ever installed cat5e or cat6

00:02:32,010 --> 00:02:36,810
network cables and you have that 300

00:02:34,050 --> 00:02:38,459
meter roll of cable that's like that is

00:02:36,810 --> 00:02:40,320
one microsecond of latency that you're

00:02:38,459 --> 00:02:42,690
holding it's actually 305 metres but

00:02:40,320 --> 00:02:44,280
close enough and if you're talking about

00:02:42,690 --> 00:02:46,170
one second you can go around the earth

00:02:44,280 --> 00:02:49,290
seven and a half times and that sort of

00:02:46,170 --> 00:02:50,430
period so if you're experiencing latency

00:02:49,290 --> 00:02:51,600
issues like that you're doing something

00:02:50,430 --> 00:02:55,230
wrong and that's what we're going to

00:02:51,600 --> 00:02:56,880
talk about today so let's have a look at

00:02:55,230 --> 00:03:00,030
some quick scenarios that might explain

00:02:56,880 --> 00:03:02,670
it Alice wants to send 36 got a gig of

00:03:00,030 --> 00:03:05,130
data to Bob and it might be all the

00:03:02,670 --> 00:03:09,090
going with throwing episodes or it might

00:03:05,130 --> 00:03:12,450
be TPS reports we don't know but there's

00:03:09,090 --> 00:03:16,530
different scenarios here that you would

00:03:12,450 --> 00:03:19,160
use high bandwidth versus low latency in

00:03:16,530 --> 00:03:23,040
different ways so let's talk about that

00:03:19,160 --> 00:03:30,920
why is my slide not advancing because my

00:03:23,040 --> 00:03:30,920
focus is elsewhere so it's a Mario one

00:03:35,130 --> 00:03:40,530
excuse me there we go

00:03:38,250 --> 00:03:43,770
scenario 1 avian carrier we want to send

00:03:40,530 --> 00:03:45,300
36 feet of data 10 kilometers so avian

00:03:43,770 --> 00:03:47,100
character if not who where is carrier

00:03:45,300 --> 00:03:49,860
pigeon so we're going to send a USB

00:03:47,100 --> 00:03:52,260
stick via bird now the USB stick of

00:03:49,860 --> 00:03:53,460
course can take a lot of data but the

00:03:52,260 --> 00:03:56,160
bird is going to take a little while to

00:03:53,460 --> 00:03:59,190
take it there so it's got a 20 minute

00:03:56,160 --> 00:04:02,040
round-trip time it has a TCP handshake

00:03:59,190 --> 00:04:03,390
if you're using TCP with this it's gonna

00:04:02,040 --> 00:04:06,630
take a while it's gonna take you 30

00:04:03,390 --> 00:04:09,780
minutes to send the data you've got

00:04:06,630 --> 00:04:11,850
excellent bandwidth available but the

00:04:09,780 --> 00:04:13,590
throughput is diminished because of the

00:04:11,850 --> 00:04:16,290
TCP handshake before you can actually

00:04:13,590 --> 00:04:18,750
send the data and the first packet of

00:04:16,290 --> 00:04:22,290
data arrives after 30 minutes as does

00:04:18,750 --> 00:04:23,580
the last so too much latency if Bob

00:04:22,290 --> 00:04:26,070
wants to start watching Game of Thrones

00:04:23,580 --> 00:04:29,700
right now but it's great if he can wait

00:04:26,070 --> 00:04:31,770
and it's fast enough to for Bob to

00:04:29,700 --> 00:04:34,760
finish his TPS report in a few hours

00:04:31,770 --> 00:04:37,260
if that's the sort of timeframe he's got

00:04:34,760 --> 00:04:39,450
scenario 2 we're talking about NBN here

00:04:37,260 --> 00:04:41,790
in Australia and their basic farber to

00:04:39,450 --> 00:04:46,860
the premises which is actually somewhat

00:04:41,790 --> 00:04:50,690
fast 36 gig of data is on their basic

00:04:46,860 --> 00:04:52,950
plan only one megabit per second the

00:04:50,690 --> 00:04:55,940
66.7 nanosecond round-trip time is

00:04:52,950 --> 00:04:58,260
actually quite good so it's less than a

00:04:55,940 --> 00:05:01,680
millisecond so ping times are quite good

00:04:58,260 --> 00:05:03,810
but the bandwidth is quite low so the

00:05:01,680 --> 00:05:07,080
TCP handshake that's all fine we can do

00:05:03,810 --> 00:05:10,020
that in 100 nanoseconds we can send 36

00:05:07,080 --> 00:05:12,600
gig of data in 10 hours that's a lot

00:05:10,020 --> 00:05:15,090
slower than our avian carrier in this

00:05:12,600 --> 00:05:17,970
instance so you know the old snake and

00:05:15,090 --> 00:05:21,690
it's pretty good in terms of throughput

00:05:17,970 --> 00:05:24,690
but latency it's horrible so we get very

00:05:21,690 --> 00:05:27,450
good throughput but it's too slow if Bob

00:05:24,690 --> 00:05:30,870
wants to finish his TPS report and get

00:05:27,450 --> 00:05:33,120
it done before close visitors today its

00:05:30,870 --> 00:05:34,860
low latency so he can start watching his

00:05:33,120 --> 00:05:37,890
game with thrown episodes like right now

00:05:34,860 --> 00:05:39,600
so that's pretty good latency on the web

00:05:37,890 --> 00:05:41,400
when you're actually talking about

00:05:39,600 --> 00:05:44,130
latency on the web there's lots of

00:05:41,400 --> 00:05:45,090
different sources of latency now we talk

00:05:44,130 --> 00:05:47,790
about different parts of the application

00:05:45,090 --> 00:05:48,900
stack here and the very first thing

00:05:47,790 --> 00:05:52,500
that's fundamental to

00:05:48,900 --> 00:05:54,180
any web communication is CCCP so you

00:05:52,500 --> 00:05:56,160
need to do a DNS lookup if you're going

00:05:54,180 --> 00:05:59,220
to new Atlas comm our website where you

00:05:56,160 --> 00:06:00,660
can get some amazing news then you need

00:05:59,220 --> 00:06:02,820
to look up new Atlas comm get the

00:06:00,660 --> 00:06:04,680
request get the response perhaps you

00:06:02,820 --> 00:06:07,229
need to do some verification of your DNS

00:06:04,680 --> 00:06:09,990
responses as well then you go through

00:06:07,229 --> 00:06:13,470
the TCP handshake again and eventually

00:06:09,990 --> 00:06:16,530
you end up with a connection a TCP

00:06:13,470 --> 00:06:17,880
connection the next layer is more likely

00:06:16,530 --> 00:06:19,229
going to be that you're going to have to

00:06:17,880 --> 00:06:21,539
do a TLS handshake

00:06:19,229 --> 00:06:24,360
so the TLS handshake is going to take

00:06:21,539 --> 00:06:27,030
more time again there's client hello

00:06:24,360 --> 00:06:29,370
server hello certificate verification

00:06:27,030 --> 00:06:31,440
and all the other steps now

00:06:29,370 --> 00:06:32,520
interestingly there's actually a point

00:06:31,440 --> 00:06:36,419
in here where you can do some further

00:06:32,520 --> 00:06:39,389
optimization with the OS OCSP responses

00:06:36,419 --> 00:06:41,070
if you get the certificate done in such

00:06:39,389 --> 00:06:44,490
a way that it includes all of the

00:06:41,070 --> 00:06:46,380
information that the client will need to

00:06:44,490 --> 00:06:48,539
verify your certificate you can make

00:06:46,380 --> 00:06:51,030
things go faster again so this is before

00:06:48,539 --> 00:06:52,349
you even got to Jango you've got all of

00:06:51,030 --> 00:06:55,560
these other things that can cause

00:06:52,349 --> 00:06:58,590
latency for a visit to your website so

00:06:55,560 --> 00:07:00,440
let's keep going so then we get to http

00:06:58,590 --> 00:07:03,840
you finally got your TLS connection

00:07:00,440 --> 00:07:06,599
because these days it's like not many

00:07:03,840 --> 00:07:09,030
people are using unencrypted stuff and

00:07:06,599 --> 00:07:11,449
we start talking about the HTTP request

00:07:09,030 --> 00:07:13,770
this is really interesting because

00:07:11,449 --> 00:07:16,470
request headers are probably the first

00:07:13,770 --> 00:07:18,539
thing that happen and request headers

00:07:16,470 --> 00:07:20,190
include things like cookies if you have

00:07:18,539 --> 00:07:23,940
in excessive amounts of cookies or very

00:07:20,190 --> 00:07:26,550
large cookies on your domain then they

00:07:23,940 --> 00:07:30,889
get sent with every request and the

00:07:26,550 --> 00:07:34,440
problem is that that means if you're on

00:07:30,889 --> 00:07:37,139
let's say mobile network that all of

00:07:34,440 --> 00:07:39,570
that data has to get sent before you can

00:07:37,139 --> 00:07:41,130
start getting the response and that's

00:07:39,570 --> 00:07:42,419
just going to slow things down so this

00:07:41,130 --> 00:07:46,110
is where they talk about cookie free

00:07:42,419 --> 00:07:47,550
domains for some requests once the

00:07:46,110 --> 00:07:51,479
request actually arrives and you've got

00:07:47,550 --> 00:07:54,120
the server processing and various things

00:07:51,479 --> 00:07:56,639
that Django will do for you by default

00:07:54,120 --> 00:08:00,029
in the middleware so sessions for

00:07:56,639 --> 00:08:01,590
example typically if you're using file

00:08:00,029 --> 00:08:02,340
based sessions it has to go off the disk

00:08:01,590 --> 00:08:04,949
and

00:08:02,340 --> 00:08:07,169
from disk you could be using cookie

00:08:04,949 --> 00:08:08,430
storage instead that means that it

00:08:07,169 --> 00:08:13,080
doesn't have to go anywhere it's got all

00:08:08,430 --> 00:08:15,810
the data it needs in your cookie off so

00:08:13,080 --> 00:08:18,150
the auth module in Django it has to go

00:08:15,810 --> 00:08:21,540
off to the database and read your user

00:08:18,150 --> 00:08:23,910
and say oh yeah this is Tyson and he's

00:08:21,540 --> 00:08:25,530
an admin on the site and I'm going to

00:08:23,910 --> 00:08:28,530
stick that onto the request as a request

00:08:25,530 --> 00:08:30,500
user sites if using the sites framework

00:08:28,530 --> 00:08:33,630
once again you have to go and look up

00:08:30,500 --> 00:08:35,849
number one to find out what your site

00:08:33,630 --> 00:08:37,710
name is and confirm that it exists in

00:08:35,849 --> 00:08:39,680
the site's table and you know go and

00:08:37,710 --> 00:08:42,150
stick it onto the request as well

00:08:39,680 --> 00:08:43,440
compiled templates application queries

00:08:42,150 --> 00:08:46,350
there's all sorts of things that go on

00:08:43,440 --> 00:08:50,070
in Django before you've even got to your

00:08:46,350 --> 00:08:54,000
view code to then process the response

00:08:50,070 --> 00:08:57,300
headers and the body so subsequent HTTP

00:08:54,000 --> 00:08:59,220
requests you've just done your first

00:08:57,300 --> 00:09:00,390
request for your index page and then

00:08:59,220 --> 00:09:01,710
you've got to go and get your scripts

00:09:00,390 --> 00:09:03,240
your style sheets your images and all

00:09:01,710 --> 00:09:07,020
the other bits and pieces that make up

00:09:03,240 --> 00:09:10,020
your application so surprise surprise

00:09:07,020 --> 00:09:13,140
there's more stuff to be done and if you

00:09:10,020 --> 00:09:15,510
talk let's say 300 milliseconds to get

00:09:13,140 --> 00:09:16,680
that initial page out and then it's like

00:09:15,510 --> 00:09:19,740
oh yeah but you need these other

00:09:16,680 --> 00:09:21,300
resources to show the page then if you

00:09:19,740 --> 00:09:23,220
haven't responded for 300 milliseconds

00:09:21,300 --> 00:09:28,050
that's another 300 milliseconds people

00:09:23,220 --> 00:09:29,940
have to wait HTTP to goes some way

00:09:28,050 --> 00:09:31,500
towards addressing some of these things

00:09:29,940 --> 00:09:33,450
where you say like you know here's my

00:09:31,500 --> 00:09:34,860
initial page and then the browser's

00:09:33,450 --> 00:09:36,930
figured out that it needs to go and

00:09:34,860 --> 00:09:39,270
request your style sheets and things so

00:09:36,930 --> 00:09:41,490
it allows many requests in parallel for

00:09:39,270 --> 00:09:42,779
a start over a single TCP connection

00:09:41,490 --> 00:09:45,990
which means you only have to do that one

00:09:42,779 --> 00:09:48,180
TCP and TLS handshake which we saw can

00:09:45,990 --> 00:09:52,620
be a significant source of round-trips

00:09:48,180 --> 00:09:55,200
so that's important and it can help

00:09:52,620 --> 00:09:56,910
reduce latency of subsequent requests by

00:09:55,200 --> 00:09:59,220
guessing which resources the client

00:09:56,910 --> 00:10:01,290
needs hey you've requested our index

00:09:59,220 --> 00:10:03,860
page you're probably going to need Java

00:10:01,290 --> 00:10:06,900
Script bundle you're going to need our

00:10:03,860 --> 00:10:08,900
CSS bundle and you know here's a couple

00:10:06,900 --> 00:10:11,070
of images that you might need as well

00:10:08,900 --> 00:10:13,020
that can be a bit problematic though

00:10:11,070 --> 00:10:14,610
because of course incorrectly guessing

00:10:13,020 --> 00:10:16,180
what the client needs and saying hey

00:10:14,610 --> 00:10:18,610
you're going to need this that that

00:10:16,180 --> 00:10:19,690
and that might be completely wasteful if

00:10:18,610 --> 00:10:24,870
they've already got those in their local

00:10:19,690 --> 00:10:27,100
cash so fun

00:10:24,870 --> 00:10:28,330
Django streaming responses I'm just

00:10:27,100 --> 00:10:30,940
going to open this up because the last

00:10:28,330 --> 00:10:32,500
ones are paid anyway streaming responses

00:10:30,940 --> 00:10:36,730
are good because in terms of latency

00:10:32,500 --> 00:10:39,250
when you attempt to request like we've

00:10:36,730 --> 00:10:40,779
seen back responses rather than saying

00:10:39,250 --> 00:10:43,209
I'm going to build up the entire

00:10:40,779 --> 00:10:44,980
response and then just like shove it

00:10:43,209 --> 00:10:47,110
down the wire at the very end after I've

00:10:44,980 --> 00:10:48,940
built it up it's quite inefficient so

00:10:47,110 --> 00:10:53,459
it's actually better to get whatever

00:10:48,940 --> 00:10:56,770
data you can get out immediately so

00:10:53,459 --> 00:10:58,750
let's say you've got let's are you

00:10:56,770 --> 00:11:02,470
downloading a CSV report for some big

00:10:58,750 --> 00:11:04,209
application so rather than like you know

00:11:02,470 --> 00:11:06,190
loading that all into memory number one

00:11:04,209 --> 00:11:07,690
consuming lots of server memory you can

00:11:06,190 --> 00:11:10,720
do a streaming response where you say

00:11:07,690 --> 00:11:12,790
I'm going to read the data from the

00:11:10,720 --> 00:11:14,680
database and as I get the first row I'm

00:11:12,790 --> 00:11:17,380
going to stream that out and say here's

00:11:14,680 --> 00:11:18,190
row number one here's row number two and

00:11:17,380 --> 00:11:20,170
keep going

00:11:18,190 --> 00:11:22,750
so Django lets you do that within a view

00:11:20,170 --> 00:11:26,650
you can actually say that your response

00:11:22,750 --> 00:11:29,709
the content is a generator expression so

00:11:26,650 --> 00:11:33,010
you can then just yield strings which is

00:11:29,709 --> 00:11:35,380
really cool I'm not going to go into too

00:11:33,010 --> 00:11:37,510
much technical detail about any of these

00:11:35,380 --> 00:11:39,040
particular steps the goal here is just

00:11:37,510 --> 00:11:41,230
to open your eyes to some of these

00:11:39,040 --> 00:11:43,690
points of latency across the entire

00:11:41,230 --> 00:11:44,890
stack if you've got any particular

00:11:43,690 --> 00:11:47,560
questions about teeth pulling with

00:11:44,890 --> 00:11:49,029
limitation jump on hashtag ludicrous it

00:11:47,560 --> 00:11:52,600
in slack and we'll talk about it there

00:11:49,029 --> 00:11:54,220
or just outside after the talk there's

00:11:52,600 --> 00:11:58,270
some issues with streaming responses

00:11:54,220 --> 00:12:00,850
though so number one you can't change

00:11:58,270 --> 00:12:04,720
the response status after you've already

00:12:00,850 --> 00:12:06,970
sent it HTTP in your responses the first

00:12:04,720 --> 00:12:12,040
thing that happens is that you respond

00:12:06,970 --> 00:12:16,450
with 404 not found or 302 see other or

00:12:12,040 --> 00:12:19,300
in this case 200 okay and you start

00:12:16,450 --> 00:12:21,339
sending your data back but then if you

00:12:19,300 --> 00:12:23,470
get like halfway through and you

00:12:21,339 --> 00:12:26,170
encounter a row that causes your Python

00:12:23,470 --> 00:12:28,720
code to blow up and you have an

00:12:26,170 --> 00:12:30,070
exception there's no way to go back and

00:12:28,720 --> 00:12:32,710
say actually sorry

00:12:30,070 --> 00:12:35,530
200 okay it was a 500 internal server

00:12:32,710 --> 00:12:37,870
error perhaps one day someone is going

00:12:35,530 --> 00:12:40,960
to see the light in HD b3 will allow us

00:12:37,870 --> 00:12:42,910
to change the response code after the

00:12:40,960 --> 00:12:46,720
fact and say actually sorry that wasn't

00:12:42,910 --> 00:12:48,790
200 okay that was 500 so maybe one of

00:12:46,720 --> 00:12:51,280
you guys will help work on that the

00:12:48,790 --> 00:12:55,390
other thing is in Django if you're using

00:12:51,280 --> 00:12:58,630
template response as the view there's no

00:12:55,390 --> 00:13:01,330
streaming equivalent of it I'd like for

00:12:58,630 --> 00:13:05,260
that to change so maybe we can do

00:13:01,330 --> 00:13:08,220
something about that all right

00:13:05,260 --> 00:13:12,490
caching people have talked about various

00:13:08,220 --> 00:13:17,560
things in terms of like making sure that

00:13:12,490 --> 00:13:19,300
your your view returns data in a quick

00:13:17,560 --> 00:13:21,370
manner and the first thing that comes up

00:13:19,300 --> 00:13:23,830
is caching it's like well let's not do

00:13:21,370 --> 00:13:25,630
this big database query let's instead

00:13:23,830 --> 00:13:27,190
just stick it in cash and go and get the

00:13:25,630 --> 00:13:29,890
data from like Redis or whatever it

00:13:27,190 --> 00:13:31,840
happens to be or memcached so it lets

00:13:29,890 --> 00:13:34,680
you keep the result of expensive things

00:13:31,840 --> 00:13:40,360
like you know a big fat database query

00:13:34,680 --> 00:13:41,680
in more local location exposes one of

00:13:40,360 --> 00:13:48,130
the two difficulties of computer science

00:13:41,680 --> 00:13:50,440
of course which is always a trick the

00:13:48,130 --> 00:13:53,500
bigger issue is that most projects use

00:13:50,440 --> 00:13:55,030
single central cache server so we talked

00:13:53,500 --> 00:13:57,040
about the function of distance and you

00:13:55,030 --> 00:13:59,170
talk about you know like across the data

00:13:57,040 --> 00:14:01,570
center being you know 300 meters or if

00:13:59,170 --> 00:14:03,820
you're talking about using Amazon and if

00:14:01,570 --> 00:14:06,220
you're in there US East one Virginia

00:14:03,820 --> 00:14:09,010
data center it's actually not a single

00:14:06,220 --> 00:14:11,290
data center it's a collection of data

00:14:09,010 --> 00:14:14,050
centers all across Virginia and the

00:14:11,290 --> 00:14:17,710
reality is that any two of those data

00:14:14,050 --> 00:14:18,690
centers at best might be you know ten

00:14:17,710 --> 00:14:23,380
kilometers apart

00:14:18,690 --> 00:14:25,600
realistically might be a lot more so if

00:14:23,380 --> 00:14:28,570
you're saying that your web server in

00:14:25,600 --> 00:14:31,270
one particular data center is then

00:14:28,570 --> 00:14:33,670
talking to a cache server even in the

00:14:31,270 --> 00:14:36,700
same region it's not particularly good

00:14:33,670 --> 00:14:40,510
for cache locality that means to say

00:14:36,700 --> 00:14:42,490
that the request has gone off to the

00:14:40,510 --> 00:14:43,930
cache server and it comes back you know

00:14:42,490 --> 00:14:45,339
it could be coming back

00:14:43,930 --> 00:14:46,510
milliseconds later or whatever happens

00:14:45,339 --> 00:14:48,370
to be depending on what's going on

00:14:46,510 --> 00:14:51,070
particularly bad if you're talking about

00:14:48,370 --> 00:14:53,320
case server being on the u.s. west coast

00:14:51,070 --> 00:14:57,760
versus the web server being on the u.s.

00:14:53,320 --> 00:15:00,160
East Coast it happens so you better to

00:14:57,760 --> 00:15:01,930
use what's in Django is the locked

00:15:00,160 --> 00:15:04,899
memcache where appropriate where you

00:15:01,930 --> 00:15:08,230
actually have within the same Python

00:15:04,899 --> 00:15:09,940
process ability to cache some data so

00:15:08,230 --> 00:15:13,290
that means that you don't have to go out

00:15:09,940 --> 00:15:13,290
across the wire a long long way

00:15:13,600 --> 00:15:18,700
check out django utils cache for some

00:15:15,640 --> 00:15:22,870
neat helpers on that template fragment

00:15:18,700 --> 00:15:25,570
caching so when you're rendering a

00:15:22,870 --> 00:15:28,120
template in django you get your

00:15:25,570 --> 00:15:29,350
opportunity to do all sorts of funky

00:15:28,120 --> 00:15:31,930
things and you can put your template

00:15:29,350 --> 00:15:33,850
logic all sorts of cool stuff the best

00:15:31,930 --> 00:15:37,330
thing that you can do is start using the

00:15:33,850 --> 00:15:40,270
cache template tag and there's actually

00:15:37,330 --> 00:15:42,010
an advanced version of that that you can

00:15:40,270 --> 00:15:45,370
use as well that another project

00:15:42,010 --> 00:15:48,339
provides but it gives you the

00:15:45,370 --> 00:15:52,990
opportunity to wrap up lots of different

00:15:48,339 --> 00:15:55,089
API calls in one case hit so rather than

00:15:52,990 --> 00:15:57,220
hey give me this data from the cache

00:15:55,089 --> 00:15:58,870
server I now give me the next piece of

00:15:57,220 --> 00:16:00,070
data from the case you now give me the

00:15:58,870 --> 00:16:02,680
third piece of the data from the cache

00:16:00,070 --> 00:16:03,640
server it says just give me all of this

00:16:02,680 --> 00:16:07,209
in one hit

00:16:03,640 --> 00:16:11,140
so you're undoing one round-trip once

00:16:07,209 --> 00:16:13,450
again round-trips I guess you could say

00:16:11,140 --> 00:16:16,390
the number of trips that you do across

00:16:13,450 --> 00:16:19,000
the wire to a remote location that is

00:16:16,390 --> 00:16:21,040
the primary things like your going

00:16:19,000 --> 00:16:23,800
distance to get there so you want to

00:16:21,040 --> 00:16:25,959
reduce those round trips to try and

00:16:23,800 --> 00:16:32,430
reduce the amount of time that you're

00:16:25,959 --> 00:16:35,890
spending on caching so templates and

00:16:32,430 --> 00:16:40,149
template fragment caching it only really

00:16:35,890 --> 00:16:41,920
works if you're using lazy context so

00:16:40,149 --> 00:16:46,570
we'll go into lazy context in a minute

00:16:41,920 --> 00:16:49,120
but it's really really important the

00:16:46,570 --> 00:16:51,010
Jenga add cache tag provides a no case

00:16:49,120 --> 00:16:53,500
tag and also provides the improved

00:16:51,010 --> 00:16:56,010
implementation of the cache tag so I'd

00:16:53,500 --> 00:16:59,130
suggest you go and look at that package

00:16:56,010 --> 00:17:02,440
so lazier value

00:16:59,130 --> 00:17:05,440
the fundamental idea is that you don't

00:17:02,440 --> 00:17:07,750
do any calculation until the last

00:17:05,440 --> 00:17:11,770
possible moment when you know that you

00:17:07,750 --> 00:17:14,140
need that data so you don't go and pre

00:17:11,770 --> 00:17:16,750
calculate something and then stick it in

00:17:14,140 --> 00:17:19,240
the context from your view instead you

00:17:16,750 --> 00:17:22,030
provide you know maybe a link to the

00:17:19,240 --> 00:17:24,430
model of instant that you need and then

00:17:22,030 --> 00:17:26,860
say like in the view you give it the

00:17:24,430 --> 00:17:29,890
ability to calculate that logic perhaps

00:17:26,860 --> 00:17:33,160
via a template tag or otherwise so that

00:17:29,890 --> 00:17:35,380
you are not performing that expensive

00:17:33,160 --> 00:17:37,750
calculation or expensive database lookup

00:17:35,380 --> 00:17:41,050
whatever it happens to be until it's

00:17:37,750 --> 00:17:43,420
absolutely required the cool thing is of

00:17:41,050 --> 00:17:46,720
course that if you don't need to call it

00:17:43,420 --> 00:17:49,300
at all perhaps because the information

00:17:46,720 --> 00:17:50,680
is being cashed at a higher level then

00:17:49,300 --> 00:17:54,420
you haven't wasted any time doing the

00:17:50,680 --> 00:17:56,920
calculations or retrieving the data

00:17:54,420 --> 00:18:00,280
Jango query sets are lazy by default

00:17:56,920 --> 00:18:02,080
take advantage of this as long as you

00:18:00,280 --> 00:18:06,250
don't force a valuation of them early

00:18:02,080 --> 00:18:07,840
that is so when you hear about Jango

00:18:06,250 --> 00:18:11,290
query sets being lazy that means that

00:18:07,840 --> 00:18:14,650
you can essentially if you can say here

00:18:11,290 --> 00:18:18,370
define my query set as blog objects

00:18:14,650 --> 00:18:19,870
filter date equals today it won't

00:18:18,370 --> 00:18:23,050
actually go and do the database query

00:18:19,870 --> 00:18:28,240
until you look through those instances

00:18:23,050 --> 00:18:31,750
for example so part of lazy evaluation

00:18:28,240 --> 00:18:38,620
part two is that Jango internally gives

00:18:31,750 --> 00:18:42,880
you this really neat thing where a so

00:18:38,620 --> 00:18:45,820
here we can see that in our context data

00:18:42,880 --> 00:18:49,180
you can't push things in but normally

00:18:45,820 --> 00:18:51,550
we'd have you know query count to

00:18:49,180 --> 00:18:52,960
actually get the count you would

00:18:51,550 --> 00:18:55,210
actually call it with parens and it will

00:18:52,960 --> 00:18:57,850
give you the value but Jango in its

00:18:55,210 --> 00:18:59,350
templates when it sees a callable it

00:18:57,850 --> 00:19:02,350
will call it for you which is really

00:18:59,350 --> 00:19:04,750
cool because you can just provide it as

00:19:02,350 --> 00:19:06,520
required don't have a look in Jango

00:19:04,750 --> 00:19:09,930
utils functional for some really neat

00:19:06,520 --> 00:19:09,930
helpers regarding all of this too

00:19:10,390 --> 00:19:15,280
we reset optimization your query set

00:19:13,570 --> 00:19:17,920
itself can be optimized to reduce

00:19:15,280 --> 00:19:20,980
latency select relative and prefetch

00:19:17,920 --> 00:19:23,080
related can help you do it can help you

00:19:20,980 --> 00:19:25,300
avoid more round trips to the database

00:19:23,080 --> 00:19:29,020
server so go and have a look at the

00:19:25,300 --> 00:19:30,700
documentation for those two things use

00:19:29,020 --> 00:19:32,710
annotate and aggregate where appropriate

00:19:30,700 --> 00:19:35,920
to go and get the database to do the

00:19:32,710 --> 00:19:37,630
work on counting things on doing

00:19:35,920 --> 00:19:42,820
whatever it happens that you need your

00:19:37,630 --> 00:19:45,610
view to do you Django debug toolbar to

00:19:42,820 --> 00:19:48,580
keep an eye on exactly what queries

00:19:45,610 --> 00:19:50,350
you're running if you can't see what's

00:19:48,580 --> 00:19:54,240
going on there's no way you can optimize

00:19:50,350 --> 00:19:54,240
it we'll come back to that in a minute

00:19:54,700 --> 00:19:59,200
use test case a certain um queries to

00:19:56,890 --> 00:20:01,120
ensure that you don't fix something only

00:19:59,200 --> 00:20:03,970
to have someone do some work on it a bit

00:20:01,120 --> 00:20:05,530
later and then unfix it for you all

00:20:03,970 --> 00:20:08,650
right so you can actually go and check

00:20:05,530 --> 00:20:10,600
to see that the work that you did is

00:20:08,650 --> 00:20:12,610
being maintained and that you're not all

00:20:10,600 --> 00:20:13,540
of a sudden you know causing things to

00:20:12,610 --> 00:20:16,990
go nuts

00:20:13,540 --> 00:20:18,970
later on the final thing is considered

00:20:16,990 --> 00:20:22,330
denormalization of your database schema

00:20:18,970 --> 00:20:27,000
to put the data where it's needed so

00:20:22,330 --> 00:20:29,440
that means that you might for example

00:20:27,000 --> 00:20:31,840
for an author put the total number of

00:20:29,440 --> 00:20:33,310
articles that they have blog posts or

00:20:31,840 --> 00:20:35,500
whatever happens to be on the author

00:20:33,310 --> 00:20:37,210
table itself so you don't need to

00:20:35,500 --> 00:20:39,990
actually go and count them every time

00:20:37,210 --> 00:20:43,060
you show you know this author has 200

00:20:39,990 --> 00:20:49,810
posts or perhaps you don't even show it

00:20:43,060 --> 00:20:52,560
at all so a quick recap latency is

00:20:49,810 --> 00:20:56,230
primarily a function of distance a

00:20:52,560 --> 00:20:58,930
faster router CPU or whatever it happens

00:20:56,230 --> 00:21:01,600
to be won't help much all right

00:20:58,930 --> 00:21:05,800
bigger bandwidth won't help latency is a

00:21:01,600 --> 00:21:08,950
function of distance you avoid round

00:21:05,800 --> 00:21:11,710
trips to reduce latency this is really

00:21:08,950 --> 00:21:13,870
important so every cache request that

00:21:11,710 --> 00:21:17,050
you make every database request that you

00:21:13,870 --> 00:21:20,230
make every API call to an external

00:21:17,050 --> 00:21:24,020
service that you make is going to affect

00:21:20,230 --> 00:21:26,490
your latency

00:21:24,020 --> 00:21:29,430
analyze your whole stack looking for

00:21:26,490 --> 00:21:31,800
issues we're talking datacenter level

00:21:29,430 --> 00:21:33,660
like don't put your cache server on the

00:21:31,800 --> 00:21:40,200
opposite end of the continent to your

00:21:33,660 --> 00:21:43,830
web server youth streaming responses

00:21:40,200 --> 00:21:46,470
were appropriate don't wait until you've

00:21:43,830 --> 00:21:49,940
done all of your processing before you

00:21:46,470 --> 00:21:49,940
start getting that data to the client

00:21:50,540 --> 00:21:56,400
cache aggregate results as in to say

00:21:53,700 --> 00:21:58,380
don't make a case request for every

00:21:56,400 --> 00:21:59,730
little thing along the way and a common

00:21:58,380 --> 00:22:02,810
thing that I've seen here too is people

00:21:59,730 --> 00:22:06,270
using things like database query level

00:22:02,810 --> 00:22:07,410
caching where they say hey I'm gonna do

00:22:06,270 --> 00:22:09,330
this cool thing it means we don't have

00:22:07,410 --> 00:22:12,000
to go to the database every time we just

00:22:09,330 --> 00:22:14,070
go to the cache server instead to try

00:22:12,000 --> 00:22:15,990
and get this data but often that means

00:22:14,070 --> 00:22:18,960
that they end up going to both anyway or

00:22:15,990 --> 00:22:21,450
that they do it in a poor way adding

00:22:18,960 --> 00:22:23,700
lots of caching at different things

00:22:21,450 --> 00:22:25,290
isn't necessarily going to help adding

00:22:23,700 --> 00:22:26,580
caching willy-nilly without actually

00:22:25,290 --> 00:22:28,290
thinking about what you're doing is a

00:22:26,580 --> 00:22:31,820
bad thing sometimes it's actually better

00:22:28,290 --> 00:22:35,730
to remove layers be lazy

00:22:31,820 --> 00:22:37,260
so obviously don't calculate any data

00:22:35,730 --> 00:22:40,440
until the last possible moment when you

00:22:37,260 --> 00:22:43,850
have to all right so Django provides

00:22:40,440 --> 00:22:47,640
some cool things to do that use it

00:22:43,850 --> 00:22:50,210
measure using Django debug toolbar new

00:22:47,640 --> 00:22:52,620
relic or otherwise and then optimize

00:22:50,210 --> 00:22:54,390
there's no point in jumping in and

00:22:52,620 --> 00:22:56,760
getting your sleeves up and going right

00:22:54,390 --> 00:22:59,670
I'm gonna optimize everything if there's

00:22:56,760 --> 00:23:01,410
no actual value in doing so find out

00:22:59,670 --> 00:23:02,730
using whatever profiling tools you've

00:23:01,410 --> 00:23:04,380
got new relic is actually really good

00:23:02,730 --> 00:23:08,340
for this one because it lets you drill

00:23:04,380 --> 00:23:10,380
down to like your cache server requests

00:23:08,340 --> 00:23:12,240
your database server requests API calls

00:23:10,380 --> 00:23:15,060
and other things as well and it shows

00:23:12,240 --> 00:23:18,780
you which things are going slow so I

00:23:15,060 --> 00:23:22,050
recommend that once you've actually

00:23:18,780 --> 00:23:23,580
measured then optimize as appropriate

00:23:22,050 --> 00:23:25,440
and don't forget use things like a

00:23:23,580 --> 00:23:29,010
certain um query so that you don't break

00:23:25,440 --> 00:23:31,140
it again in the future so what about

00:23:29,010 --> 00:23:33,870
ludacris mode why is this Python

00:23:31,140 --> 00:23:35,370
ludicrous mode well most people still

00:23:33,870 --> 00:23:37,260
think about speeds in terms of bandwidth

00:23:35,370 --> 00:23:39,150
start thinking about latency

00:23:37,260 --> 00:23:42,390
take a high-level look at your

00:23:39,150 --> 00:23:44,610
algorithms and don't do ludicrous things

00:23:42,390 --> 00:23:50,000
such as crew the database and then not

00:23:44,610 --> 00:23:52,680
use the data project ludicrous on Monday

00:23:50,000 --> 00:23:54,120
at the sprints I'd love to start working

00:23:52,680 --> 00:23:56,460
on streaming template response within

00:23:54,120 --> 00:23:59,490
Django so I'd love for people to help me

00:23:56,460 --> 00:24:00,900
out with that HTTP three maybe that

00:23:59,490 --> 00:24:02,400
someone can get on the working group

00:24:00,900 --> 00:24:05,010
anyone who's got some influence there

00:24:02,400 --> 00:24:08,160
and actually I have late status codes

00:24:05,010 --> 00:24:10,440
that would be pretty cool so we could

00:24:08,160 --> 00:24:13,680
then say sorry that didn't work out for

00:24:10,440 --> 00:24:18,110
our streaming response let's change the

00:24:13,680 --> 00:24:21,810
status code thank you very much

00:24:18,110 --> 00:24:25,530
new Atlas comm is one of the top 1% of

00:24:21,810 --> 00:24:27,510
websites worldwide maybe you want to

00:24:25,530 --> 00:24:30,300
work with us on our team it'll be lots

00:24:27,510 --> 00:24:33,630
of fun maybe you just want some help

00:24:30,300 --> 00:24:36,990
with your current stack come and talk to

00:24:33,630 --> 00:24:40,410
me I'm on slack in the hash tag Ludacris

00:24:36,990 --> 00:24:42,690
channel on slack my nick is TC and I'd

00:24:40,410 --> 00:24:50,759
love to see you around thank you

00:24:42,690 --> 00:24:52,440
[Applause]

00:24:50,759 --> 00:24:59,070
I'll take a couple of quick questions

00:24:52,440 --> 00:25:00,869
but we don't have much time I'll also be

00:24:59,070 --> 00:25:03,809
available immediately after the talk

00:25:00,869 --> 00:25:05,759
just outside the door but obviously I

00:25:03,809 --> 00:25:07,649
expect that you will all go off to

00:25:05,759 --> 00:25:10,739
another talk I'll be available again

00:25:07,649 --> 00:25:13,409
from one o'clock until half-past one on

00:25:10,739 --> 00:25:13,999
the channel so and I'll be around as

00:25:13,409 --> 00:25:25,559
well

00:25:13,999 --> 00:25:27,419
any questions with with regards to cache

00:25:25,559 --> 00:25:31,169
invalidation do you tend to send signals

00:25:27,419 --> 00:25:34,409
from the source of the change to other

00:25:31,169 --> 00:25:35,539
servers to tell them to renew their the

00:25:34,409 --> 00:25:38,669
entries in the cache or how

00:25:35,539 --> 00:25:40,109
approximately does that work for new

00:25:38,669 --> 00:25:43,409
Atlas comm we've actually got a novel

00:25:40,109 --> 00:25:45,840
approach where we use the x-men system

00:25:43,409 --> 00:25:48,299
column of Postgres which refers to which

00:25:45,840 --> 00:25:50,909
transaction that row became visible in I

00:25:48,299 --> 00:25:52,559
hope to release this as an open source

00:25:50,909 --> 00:25:55,229
thing and talk about it in the future

00:25:52,559 --> 00:25:57,539
but it means that occasion validation

00:25:55,229 --> 00:25:59,789
for us and having to worry about exactly

00:25:57,539 --> 00:26:02,489
how that works is largely a thing of the

00:25:59,789 --> 00:26:05,809
past come and talk to me if you'd like

00:26:02,489 --> 00:26:05,809
to learn more thanks

00:26:12,730 --> 00:26:19,179
great talk Tyson okay just quickly I

00:26:16,690 --> 00:26:21,039
didn't see in the slides but the part of

00:26:19,179 --> 00:26:23,139
the stack II the whiskey server and the

00:26:21,039 --> 00:26:25,149
reverse proxies and that kind of thing

00:26:23,139 --> 00:26:28,149
just maybe a couple of ideas around that

00:26:25,149 --> 00:26:30,460
so sure so obviously if you're talking

00:26:28,149 --> 00:26:32,409
about AWS which is what new Atlas is

00:26:30,460 --> 00:26:35,350
running on then you've got opportunities

00:26:32,409 --> 00:26:38,740
to for example have multiple application

00:26:35,350 --> 00:26:40,809
server gateways or and then talking to

00:26:38,740 --> 00:26:43,450
your backends so make sure that they're

00:26:40,809 --> 00:26:45,700
in the same data center is a good start

00:26:43,450 --> 00:26:48,309
consider if you actually really need

00:26:45,700 --> 00:26:50,200
them it is generally a good idea but

00:26:48,309 --> 00:26:52,240
sometimes for some applications it might

00:26:50,200 --> 00:26:54,250
not be a good idea it comes down to your

00:26:52,240 --> 00:26:56,429
particular application your use case you

00:26:54,250 --> 00:26:59,500
use a base security needs and otherwise

00:26:56,429 --> 00:27:01,570
but certainly like just number one

00:26:59,500 --> 00:27:04,210
making sure at least that they're in the

00:27:01,570 --> 00:27:08,769
same data center not attempting to say

00:27:04,210 --> 00:27:11,830
you know put your front end a SGI sorry

00:27:08,769 --> 00:27:13,029
your front end application gateway on

00:27:11,830 --> 00:27:20,320
the opposite side of the country for

00:27:13,029 --> 00:27:21,549
example any more questions yeah I think

00:27:20,320 --> 00:27:24,100
that's it then

00:27:21,549 --> 00:27:26,740
Tyson on behalf of PyCon australia i'd

00:27:24,100 --> 00:27:30,840
like to present a small gift for your

00:27:26,740 --> 00:27:30,840
amazing talk thank you very much

00:27:34,060 --> 00:27:41,220
I look forward to seeing you all

00:27:37,810 --> 00:27:41,220

YouTube URL: https://www.youtube.com/watch?v=JCRkyqS3zxQ


