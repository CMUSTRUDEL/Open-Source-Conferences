Title: Introduction to profiling python performance with USDT
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Chris Miceli

http://2017.pycon-au.org/schedule/presentation/39/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:02,840 --> 00:00:08,550
okay hello everyone

00:00:05,130 --> 00:00:10,440
up next we have Chris Michelli chris is

00:00:08,550 --> 00:00:12,750
a production engineer at Facebook in the

00:00:10,440 --> 00:00:15,210
live video infrastructure team working

00:00:12,750 --> 00:00:17,490
on Facebook live building infrastructure

00:00:15,210 --> 00:00:19,650
tooling extensively in Python 3 has as

00:00:17,490 --> 00:00:22,140
well as being particularly excited in

00:00:19,650 --> 00:00:24,240
the BPF work done by Brendan Craig and

00:00:22,140 --> 00:00:34,530
Co including the Python tooling around

00:00:24,240 --> 00:00:36,780
batch all yours Chris hello and welcome

00:00:34,530 --> 00:00:38,460
everyone as was just said my name is

00:00:36,780 --> 00:00:40,890
Chris Miceli and today I'm going to talk

00:00:38,460 --> 00:00:43,230
to you about debugging systems using the

00:00:40,890 --> 00:00:46,140
new u.s. DT probes which have been

00:00:43,230 --> 00:00:47,399
introduced as of Python 3.6 because

00:00:46,140 --> 00:00:48,660
everyone runs the latest this is

00:00:47,399 --> 00:00:52,770
everyone's going to be able to run this

00:00:48,660 --> 00:00:54,719
now and as we said I work on our video

00:00:52,770 --> 00:00:56,850
infrastructure team I work on the live

00:00:54,719 --> 00:00:58,680
streaming stuff in particular we have a

00:00:56,850 --> 00:01:00,359
lot of support systems in Python as well

00:00:58,680 --> 00:01:03,090
as Python throughout the Facebook

00:01:00,359 --> 00:01:05,850
infrastructure so there's a lot of work

00:01:03,090 --> 00:01:07,380
around this to gain visibility we're

00:01:05,850 --> 00:01:09,590
going to go into like why we kind of use

00:01:07,380 --> 00:01:12,799
this sort of stuff throughout the talk

00:01:09,590 --> 00:01:15,840
so yeah let's just jump straight in so

00:01:12,799 --> 00:01:18,150
I'd like to preface this stop this talk

00:01:15,840 --> 00:01:20,220
by saying I am NOT the person that wrote

00:01:18,150 --> 00:01:21,570
it I'm not like an expert but this is

00:01:20,220 --> 00:01:24,210
something that I've spent a few months

00:01:21,570 --> 00:01:26,220
playing with and I'm hoping to bridge

00:01:24,210 --> 00:01:27,479
that first learning gap so there's that

00:01:26,220 --> 00:01:28,920
there's a bit of a learning thing when

00:01:27,479 --> 00:01:31,259
you first get into it that you kind of

00:01:28,920 --> 00:01:33,900
want to know hopefully you can walk away

00:01:31,259 --> 00:01:35,820
from this and start using it if not

00:01:33,900 --> 00:01:37,130
chase me up afterwards and I'll help you

00:01:35,820 --> 00:01:39,840
out

00:01:37,130 --> 00:01:42,659
I'd also like to say unfortunately I

00:01:39,840 --> 00:01:44,130
can't go over things I can't go over to

00:01:42,659 --> 00:01:46,380
bugging this in Windows because I

00:01:44,130 --> 00:01:48,390
believe this isn't supported I haven't

00:01:46,380 --> 00:01:51,509
come across it at all yet I'm a Linux

00:01:48,390 --> 00:01:53,369
person so I've had some some unix-based

00:01:51,509 --> 00:01:55,280
systems stuff as well that I've been

00:01:53,369 --> 00:01:57,719
looking into for this sort of purpose

00:01:55,280 --> 00:01:59,310
but most of this is concentrated on

00:01:57,719 --> 00:02:04,140
Linux but will work across a whole bunch

00:01:59,310 --> 00:02:07,649
of operating systems so to describe to

00:02:04,140 --> 00:02:09,330
bugging as only two things is very very

00:02:07,649 --> 00:02:10,860
simplistic but I'm going to do that

00:02:09,330 --> 00:02:13,980
otherwise I'm going to go over my time

00:02:10,860 --> 00:02:16,680
so let's say that you've got to roll

00:02:13,980 --> 00:02:19,739
one being the application level which is

00:02:16,680 --> 00:02:21,930
your process with your code running in

00:02:19,739 --> 00:02:23,730
it and when you are set when you're

00:02:21,930 --> 00:02:26,069
going to debug something like a Python

00:02:23,730 --> 00:02:28,560
program you're going to look at things

00:02:26,069 --> 00:02:31,830
like the stack traces you're going to

00:02:28,560 --> 00:02:33,239
look at logging or you know the de facto

00:02:31,830 --> 00:02:35,099
which is to stick a bunch of print

00:02:33,239 --> 00:02:37,550
statements everywhere run it for a while

00:02:35,099 --> 00:02:40,019
and then grep for them

00:02:37,550 --> 00:02:41,130
protip you put your like user name at

00:02:40,019 --> 00:02:42,330
the start and then you can just grab

00:02:41,130 --> 00:02:45,269
your user name and all the stuff you put

00:02:42,330 --> 00:02:46,590
in there you can find it but let's

00:02:45,269 --> 00:02:48,959
pretend you don't want to do this and

00:02:46,590 --> 00:02:49,769
you're you're going to start looking in

00:02:48,959 --> 00:02:53,160
two different ways

00:02:49,769 --> 00:02:55,799
so the second way you can look at

00:02:53,160 --> 00:02:59,730
debugging as a problem is for a system

00:02:55,799 --> 00:03:02,310
so a system would be the operating

00:02:59,730 --> 00:03:04,200
system it runs on with the context of

00:03:02,310 --> 00:03:06,090
the hardware and all the things

00:03:04,200 --> 00:03:07,970
underneath your program that you kind of

00:03:06,090 --> 00:03:11,459
get for free like you open a socket and

00:03:07,970 --> 00:03:12,810
voila you have a network connection that

00:03:11,459 --> 00:03:14,670
isn't how it works

00:03:12,810 --> 00:03:15,810
sorry if I'm breaking this news to

00:03:14,670 --> 00:03:17,579
everyone and they do it haven't heard

00:03:15,810 --> 00:03:21,680
that before there's a bit more involved

00:03:17,579 --> 00:03:25,590
so this system involves all those parts

00:03:21,680 --> 00:03:28,590
so what we're going to talk about works

00:03:25,590 --> 00:03:29,549
for both systems and applications but we

00:03:28,590 --> 00:03:31,319
are going to try and focus on

00:03:29,549 --> 00:03:33,650
applications because that's what we

00:03:31,319 --> 00:03:36,630
recently gained in the new Python 3.6

00:03:33,650 --> 00:03:39,780
but this picture kinda encapsulates what

00:03:36,630 --> 00:03:42,840
I'm getting at so you have each house as

00:03:39,780 --> 00:03:45,269
a program and they have probes which

00:03:42,840 --> 00:03:46,709
have been injected into them so you know

00:03:45,269 --> 00:03:49,079
you might have this particular house has

00:03:46,709 --> 00:03:51,569
been walked into and that probe goes off

00:03:49,079 --> 00:03:55,290
and like fires right so someone walked

00:03:51,569 --> 00:03:57,389
into that house then on its own that

00:03:55,290 --> 00:03:59,670
doesn't tell us very much however you go

00:03:57,389 --> 00:04:03,030
along and you say alright well this land

00:03:59,670 --> 00:04:04,950
underneath here cracked right so all the

00:04:03,030 --> 00:04:08,310
houses that happen to be on that land

00:04:04,950 --> 00:04:09,959
now it impacted right the very very

00:04:08,310 --> 00:04:12,359
important thing that I'd like to kind of

00:04:09,959 --> 00:04:14,940
touch on here is the context around all

00:04:12,359 --> 00:04:16,440
of this is very very important so we're

00:04:14,940 --> 00:04:18,959
going to talk about garbage collection a

00:04:16,440 --> 00:04:21,989
bit later and garbage collection very

00:04:18,959 --> 00:04:23,550
much depends on on the state of the

00:04:21,989 --> 00:04:25,950
system whether it is a very big problem

00:04:23,550 --> 00:04:27,139
right so we'll get we'll get into that

00:04:25,950 --> 00:04:29,360
more

00:04:27,139 --> 00:04:31,520
so something I'd also like to point out

00:04:29,360 --> 00:04:33,770
is we're going to talk about tracing so

00:04:31,520 --> 00:04:35,330
like capturing these probes and that

00:04:33,770 --> 00:04:37,520
would be what this picture is doing

00:04:35,330 --> 00:04:39,680
right now right so this picture is

00:04:37,520 --> 00:04:42,190
literally saying okay the land is

00:04:39,680 --> 00:04:45,259
cracked and the house was walked into so

00:04:42,190 --> 00:04:46,819
whether they are related will will kind

00:04:45,259 --> 00:04:47,690
of try and find out but like that's what

00:04:46,819 --> 00:04:49,129
I'm trying to get at you know

00:04:47,690 --> 00:04:50,930
everything's kind of contextual II

00:04:49,129 --> 00:04:51,949
important and these are the pieces of

00:04:50,930 --> 00:04:57,650
the puzzle that were going to be working

00:04:51,949 --> 00:04:59,719
with today so - deep - again like I'm

00:04:57,650 --> 00:05:02,539
trying to like distill the fundamentals

00:04:59,719 --> 00:05:04,969
of debugging here it's only two pieces

00:05:02,539 --> 00:05:08,780
it is creating data points that you can

00:05:04,969 --> 00:05:12,080
then use later on and then deriving

00:05:08,780 --> 00:05:14,690
meaning from those data points right as

00:05:12,080 --> 00:05:17,419
I said context is key just entering the

00:05:14,690 --> 00:05:18,979
house means nothing if the land is

00:05:17,419 --> 00:05:21,740
cracking underneath it then it might

00:05:18,979 --> 00:05:23,990
mean something so these are all things

00:05:21,740 --> 00:05:26,629
that you kind of need to do as far as

00:05:23,990 --> 00:05:29,389
this talk is concerned what we are very

00:05:26,629 --> 00:05:31,789
interested in is what this means for us

00:05:29,389 --> 00:05:34,580
one is adding probes and then as I said

00:05:31,789 --> 00:05:37,310
before it's about these traces these

00:05:34,580 --> 00:05:39,979
programs which are you know kind of new

00:05:37,310 --> 00:05:44,509
now but they will give us insight as to

00:05:39,979 --> 00:05:47,630
what is actually going on so let's talk

00:05:44,509 --> 00:05:49,009
about collecting data okay so this is

00:05:47,630 --> 00:05:51,979
all going to be quite useless if we

00:05:49,009 --> 00:05:54,080
can't collect data right there are two

00:05:51,979 --> 00:05:56,840
kind of probes that exist out in the

00:05:54,080 --> 00:05:59,150
world you have kernel probes which is

00:05:56,840 --> 00:06:01,009
the state of the operating system you

00:05:59,150 --> 00:06:03,500
know when you go and you're writing to

00:06:01,009 --> 00:06:07,370
block systems underneath you know what's

00:06:03,500 --> 00:06:10,400
going on there and then you have user

00:06:07,370 --> 00:06:11,990
land processes so you've got like you

00:06:10,400 --> 00:06:14,900
know garbage collection is the fantastic

00:06:11,990 --> 00:06:15,949
example for Python 3.6 which I like I'm

00:06:14,900 --> 00:06:19,400
going to keep going back to that because

00:06:15,949 --> 00:06:20,900
I really like it and these are this

00:06:19,400 --> 00:06:25,099
state of your application as it's kind

00:06:20,900 --> 00:06:26,870
of going along so Linux gives you a

00:06:25,099 --> 00:06:29,060
bunch of these user land probes and

00:06:26,870 --> 00:06:32,449
kernel probes basically for free by

00:06:29,060 --> 00:06:34,039
running a recent kernel so there are a

00:06:32,449 --> 00:06:35,979
good set of tools which exist we are

00:06:34,039 --> 00:06:40,300
going to talk about those in a moment

00:06:35,979 --> 00:06:42,849
these tools have a good starting set so

00:06:40,300 --> 00:06:44,530
you could go to the BCC repository for

00:06:42,849 --> 00:06:46,569
example go through the tool section and

00:06:44,530 --> 00:06:48,159
find one off tools and just kind of

00:06:46,569 --> 00:06:52,629
start playing and understanding what's

00:06:48,159 --> 00:06:54,909
going on from there I keep saying USD T

00:06:52,629 --> 00:06:56,710
and those because if I try and say user

00:06:54,909 --> 00:06:59,590
land statically defined trace points

00:06:56,710 --> 00:07:03,069
every time I'm gonna end up standing

00:06:59,590 --> 00:07:05,259
here making a mess of my words so what

00:07:03,069 --> 00:07:08,889
they are paraphrasing from the DTrace

00:07:05,259 --> 00:07:11,440
website they are the these probes which

00:07:08,889 --> 00:07:14,949
are stuck into programs when inactive

00:07:11,440 --> 00:07:16,360
cost very very little they shouldn't

00:07:14,949 --> 00:07:18,879
have any performance implications

00:07:16,360 --> 00:07:20,919
however when you do need to investigate

00:07:18,879 --> 00:07:23,229
how say the Python interpreter is

00:07:20,919 --> 00:07:25,690
running you can jump into that very very

00:07:23,229 --> 00:07:27,099
quickly and very very powerfully but I

00:07:25,690 --> 00:07:30,759
just basically chained them on like a

00:07:27,099 --> 00:07:32,650
light switch right so before Python got

00:07:30,759 --> 00:07:35,469
them they'd been added to Java and

00:07:32,650 --> 00:07:37,210
nodejs in the past with very very

00:07:35,469 --> 00:07:40,210
similar functionality for like garbage

00:07:37,210 --> 00:07:43,120
collection function entry and exit and

00:07:40,210 --> 00:07:44,650
they'd also been added to important

00:07:43,120 --> 00:07:48,520
production systems that people run such

00:07:44,650 --> 00:07:49,870
as MySQL and Postgres and there are a

00:07:48,520 --> 00:07:51,699
lot of cool libraries that are starting

00:07:49,870 --> 00:07:54,250
to get them now so this is a developing

00:07:51,699 --> 00:07:57,039
area but a notable one here is G Lib C

00:07:54,250 --> 00:08:00,460
has probes in it I believe therefore

00:07:57,039 --> 00:08:01,509
malach but you know I think I could

00:08:00,460 --> 00:08:04,150
shoot myself in the foot and say the

00:08:01,509 --> 00:08:06,509
wrong thing doesn't matter over the last

00:08:04,150 --> 00:08:08,620
five to ten years that is when all this

00:08:06,509 --> 00:08:10,270
revolution to being able to trace these

00:08:08,620 --> 00:08:13,830
kinds of things as started to happen

00:08:10,270 --> 00:08:16,090
I believe D tracers released was in 2005

00:08:13,830 --> 00:08:20,710
and since then people have started

00:08:16,090 --> 00:08:22,449
adding probes all around systems so this

00:08:20,710 --> 00:08:25,719
is kind of grown with the movement

00:08:22,449 --> 00:08:27,729
towards DevOps sre production

00:08:25,719 --> 00:08:29,620
engineering the these are the driving

00:08:27,729 --> 00:08:31,300
forces of these sorts of probes and

00:08:29,620 --> 00:08:34,180
understanding of how a system is running

00:08:31,300 --> 00:08:36,039
but if you look at how applications are

00:08:34,180 --> 00:08:37,360
being developed today it is very very

00:08:36,039 --> 00:08:39,490
different to how they used to be

00:08:37,360 --> 00:08:42,099
developed you know these days you've got

00:08:39,490 --> 00:08:45,220
containers you've got you know multiple

00:08:42,099 --> 00:08:47,649
systems microservices you've got you

00:08:45,220 --> 00:08:50,079
know no one has one IBM mainframe that

00:08:47,649 --> 00:08:52,180
runs everything anymore right so it's a

00:08:50,079 --> 00:08:53,980
changing world and this is trying to

00:08:52,180 --> 00:08:57,670
simplify that so you can see what

00:08:53,980 --> 00:09:00,820
happening in a system so what did we get

00:08:57,670 --> 00:09:02,760
with Python 3.6 we got garbage

00:09:00,820 --> 00:09:06,070
collection beginning and ending and

00:09:02,760 --> 00:09:09,430
we've got function entrance and exit it

00:09:06,070 --> 00:09:11,290
sounds kind of boring right however when

00:09:09,430 --> 00:09:15,639
you do have these function entry and

00:09:11,290 --> 00:09:18,389
exit you have the file name the line

00:09:15,639 --> 00:09:20,949
number which is being executed the

00:09:18,389 --> 00:09:22,540
function name as well as a pointer to

00:09:20,949 --> 00:09:24,190
the frame so you have a lot of

00:09:22,540 --> 00:09:27,100
information that you can then use to

00:09:24,190 --> 00:09:30,310
derive meaningful you know meaningful

00:09:27,100 --> 00:09:33,519
assumptions or things like that but this

00:09:30,310 --> 00:09:35,470
is just the start right so from now we

00:09:33,519 --> 00:09:36,850
can look at adding pull requests for

00:09:35,470 --> 00:09:38,889
different things that I think are kind

00:09:36,850 --> 00:09:40,510
of important so two that I want to kind

00:09:38,889 --> 00:09:42,310
of highlight here today while I've got

00:09:40,510 --> 00:09:46,000
the appropriate audience work is

00:09:42,310 --> 00:09:48,220
instrumentation around the GI l would be

00:09:46,000 --> 00:09:49,480
fantastic it would mean that we can then

00:09:48,220 --> 00:09:52,029
see when there is some sort of

00:09:49,480 --> 00:09:55,240
contention in a system under synthetic

00:09:52,029 --> 00:09:56,470
or real production load obviously you

00:09:55,240 --> 00:09:59,860
couldn't run it all the time but we'll

00:09:56,470 --> 00:10:02,199
get into that later and another one that

00:09:59,860 --> 00:10:04,089
is very very important and I've been

00:10:02,199 --> 00:10:06,730
burned by before so I care about it is

00:10:04,089 --> 00:10:09,819
library imports Python lets you import a

00:10:06,730 --> 00:10:13,300
library whenever you want right and then

00:10:09,819 --> 00:10:15,220
on top of that you have this concept of

00:10:13,300 --> 00:10:17,350
there's a library called demand import

00:10:15,220 --> 00:10:21,399
which allows you to lazy load your

00:10:17,350 --> 00:10:24,130
import whenever you kind of need it the

00:10:21,399 --> 00:10:25,720
problem with that is you will be running

00:10:24,130 --> 00:10:27,160
a program it'll be happily chugging

00:10:25,720 --> 00:10:28,930
along and then there's this big pause

00:10:27,160 --> 00:10:30,010
and that's because it's hit something

00:10:28,930 --> 00:10:31,660
it's like oh I need to import this

00:10:30,010 --> 00:10:34,060
library now and it happens to fan out

00:10:31,660 --> 00:10:35,500
and import a whole lot of stuff if you

00:10:34,060 --> 00:10:37,329
had probes for this kind of stuff

00:10:35,500 --> 00:10:39,010
debugging it would be a breeze you

00:10:37,329 --> 00:10:41,290
basically turn it on you notice all

00:10:39,010 --> 00:10:42,970
these import probes come up and you say

00:10:41,290 --> 00:10:44,709
ok this is happening because of these

00:10:42,970 --> 00:10:47,589
imports they happen to be big they

00:10:44,709 --> 00:10:49,660
happen to be doing whatever so these are

00:10:47,589 --> 00:10:51,839
just two ideas that I thought of but

00:10:49,660 --> 00:10:55,060
they're I'm sure there are plenty more

00:10:51,839 --> 00:10:57,040
whilst I do mention that there are a lot

00:10:55,060 --> 00:11:01,240
of probes which you could add here

00:10:57,040 --> 00:11:04,240
please note that a lot of the subsystem

00:11:01,240 --> 00:11:06,880
of Linux a lot of like helper libraries

00:11:04,240 --> 00:11:07,450
like GMC things like that they do have

00:11:06,880 --> 00:11:09,840
trace points

00:11:07,450 --> 00:11:12,310
already so adding things which are

00:11:09,840 --> 00:11:14,470
basically doing the same thing can be

00:11:12,310 --> 00:11:16,210
problematic not problematic but you

00:11:14,470 --> 00:11:18,520
wouldn't duplicate it a great example

00:11:16,210 --> 00:11:20,320
would be files like if you're opening

00:11:18,520 --> 00:11:22,180
files and you thought okay I'm going to

00:11:20,320 --> 00:11:24,730
add a probe for whenever I open a file

00:11:22,180 --> 00:11:27,490
or a socket or whatever that is

00:11:24,730 --> 00:11:28,900
instrumented elsewhere so you don't

00:11:27,490 --> 00:11:30,730
really need to add that to the Python

00:11:28,900 --> 00:11:33,030
interpreter as well things that are

00:11:30,730 --> 00:11:37,510
Python specific such as importing and

00:11:33,030 --> 00:11:39,550
Jil they are very very useful for us so

00:11:37,510 --> 00:11:41,430
I would highly recommend thinking of

00:11:39,550 --> 00:11:43,690
things that are very Python centric

00:11:41,430 --> 00:11:48,580
application centric and kind of like

00:11:43,690 --> 00:11:50,890
fanning out from there so from there

00:11:48,580 --> 00:11:53,310
we've we've gone we've said okay we've

00:11:50,890 --> 00:11:56,920
got all this data that's perfectly fine

00:11:53,310 --> 00:11:58,870
now how do we analyze it so anyone

00:11:56,920 --> 00:12:02,110
that's been watching this area very very

00:11:58,870 --> 00:12:05,080
closely will have noticed that there are

00:12:02,110 --> 00:12:07,000
lots of tools trying to I'm not gonna

00:12:05,080 --> 00:12:08,560
say compete to be like the number one

00:12:07,000 --> 00:12:12,550
tool but there's a lot of action in this

00:12:08,560 --> 00:12:15,850
area so I'm going to try and pick a

00:12:12,550 --> 00:12:18,340
couple that I am a big fan of or I've

00:12:15,850 --> 00:12:20,380
used in the past and kind of distill

00:12:18,340 --> 00:12:23,020
them for you give you an introduction

00:12:20,380 --> 00:12:24,550
but just note that these aren't the only

00:12:23,020 --> 00:12:27,780
ones that exists you're going to find

00:12:24,550 --> 00:12:30,580
them kind of they're kind of everywhere

00:12:27,780 --> 00:12:33,490
but that's the nature of a growing area

00:12:30,580 --> 00:12:37,660
so without further ado let's talk about

00:12:33,490 --> 00:12:39,840
system tap so system tap is a language

00:12:37,660 --> 00:12:42,550
that we're going to go through later and

00:12:39,840 --> 00:12:45,450
it will give you low-level access to the

00:12:42,550 --> 00:12:48,160
system because what will happen is your

00:12:45,450 --> 00:12:50,410
program will then get compiled into a

00:12:48,160 --> 00:12:52,390
kernel module that you can then inject

00:12:50,410 --> 00:12:55,390
into your system so then it will have

00:12:52,390 --> 00:12:57,220
access to a lot of information as to the

00:12:55,390 --> 00:13:01,600
underpinnings of your operating system

00:12:57,220 --> 00:13:04,890
as well as what's kind of happening and

00:13:01,600 --> 00:13:07,690
that comes with its own set of caveats

00:13:04,890 --> 00:13:11,440
the systemtap community was how people

00:13:07,690 --> 00:13:14,230
did this on linux for quite a while it

00:13:11,440 --> 00:13:17,980
there are more competing things coming

00:13:14,230 --> 00:13:20,830
out now however it is very very actively

00:13:17,980 --> 00:13:23,110
maintained it they have a lot of

00:13:20,830 --> 00:13:24,820
ample code they work very very closely

00:13:23,110 --> 00:13:26,920
with the Linux kernel developers so they

00:13:24,820 --> 00:13:30,100
can adopt new things they're a very very

00:13:26,920 --> 00:13:32,790
active community the only thing that I

00:13:30,100 --> 00:13:34,930
would like to kind of preface my

00:13:32,790 --> 00:13:37,600
recommendation of using systemtap with

00:13:34,930 --> 00:13:39,340
is if you happen to be at a pinch and

00:13:37,600 --> 00:13:43,210
you said okay I have to use this right

00:13:39,340 --> 00:13:45,120
now everything's on fire systemtap can

00:13:43,210 --> 00:13:47,920
be complicated to get started with

00:13:45,120 --> 00:13:50,230
whether that is just me or everyone else

00:13:47,920 --> 00:13:52,690
I run Arch Linux on my personal laptop

00:13:50,230 --> 00:13:54,520
and so I thought okay I'll just install

00:13:52,690 --> 00:13:55,990
it pull down the package well the

00:13:54,520 --> 00:13:58,450
package isn't maintained anymore and my

00:13:55,990 --> 00:14:01,630
kernel is you know a long way into the

00:13:58,450 --> 00:14:04,330
future so I have to then compile it then

00:14:01,630 --> 00:14:05,290
running it wasn't necessarily easy so I

00:14:04,330 --> 00:14:07,090
had to then look through all the

00:14:05,290 --> 00:14:09,250
documentation it's just worth knowing

00:14:07,090 --> 00:14:11,340
that if the world is on fire that is not

00:14:09,250 --> 00:14:13,660
the time to try and fire everything up

00:14:11,340 --> 00:14:15,370
so just kind of experiment with these

00:14:13,660 --> 00:14:18,330
kind of things early is what I want to

00:14:15,370 --> 00:14:24,760
kind of you know push everyone towards

00:14:18,330 --> 00:14:27,490
so let's talk about EBP f.e BPF is the

00:14:24,760 --> 00:14:29,380
extended berkeley packet filter it's a

00:14:27,490 --> 00:14:31,240
virtual machine interface which we can

00:14:29,380 --> 00:14:35,800
now use to access some inner workings of

00:14:31,240 --> 00:14:39,850
the kernel it was imagined in a 1992

00:14:35,800 --> 00:14:41,380
white paper which then we now built out

00:14:39,850 --> 00:14:44,680
for network filtering that's what it was

00:14:41,380 --> 00:14:47,890
initial purpose was network filtering it

00:14:44,680 --> 00:14:50,590
powers TCP dump is one of the notable

00:14:47,890 --> 00:14:52,590
examples but I believe it may even be

00:14:50,590 --> 00:14:57,280
the underpinning of the lid pcap stuff

00:14:52,590 --> 00:14:59,530
but don't hold me to that one so it the

00:14:57,280 --> 00:15:01,810
whole concept behind this is we should

00:14:59,530 --> 00:15:04,420
be able to expose kernel information

00:15:01,810 --> 00:15:06,280
through user land right so you should be

00:15:04,420 --> 00:15:10,990
able to compile byte code for this VM

00:15:06,280 --> 00:15:13,300
and get information out it was expanded

00:15:10,990 --> 00:15:15,670
to include the entirety of the Linux

00:15:13,300 --> 00:15:18,160
kernel entirely that they're exposed to

00:15:15,670 --> 00:15:21,910
more of the Linux kernel as of around

00:15:18,160 --> 00:15:24,130
Linux 4.1 and so anyone with a

00:15:21,910 --> 00:15:27,850
moderately recent kernel will have this

00:15:24,130 --> 00:15:30,040
built in there's still a lot of work

00:15:27,850 --> 00:15:32,740
underway to build out this virtual

00:15:30,040 --> 00:15:34,700
machine but it is very very strong and

00:15:32,740 --> 00:15:38,330
very well well maintained

00:15:34,700 --> 00:15:39,740
so at this point you know telling you

00:15:38,330 --> 00:15:41,150
about a virtual machine that you can't

00:15:39,740 --> 00:15:44,180
write code for is kind of useless

00:15:41,150 --> 00:15:46,760
however that's where BCC comes into the

00:15:44,180 --> 00:15:49,600
fold BCC is a tool chain which has been

00:15:46,760 --> 00:15:51,800
ripped by written by the IO Weiser

00:15:49,600 --> 00:15:54,310
community it's an open source community

00:15:51,800 --> 00:15:58,010
I believe it's now part of the Linux

00:15:54,310 --> 00:16:01,820
family and the open source foundation

00:15:58,010 --> 00:16:03,860
sorry and it contains two big pieces the

00:16:01,820 --> 00:16:05,750
first piece is the back end which is

00:16:03,860 --> 00:16:09,350
allows you to write a piece of seed that

00:16:05,750 --> 00:16:12,440
will get compiled to the e BPF bytecode

00:16:09,350 --> 00:16:14,180
and then there's a front end to analyze

00:16:12,440 --> 00:16:18,020
this which is written in which you can

00:16:14,180 --> 00:16:21,590
access in Python or Ruby but no one's

00:16:18,020 --> 00:16:23,270
gonna do that here to be honest so

00:16:21,590 --> 00:16:24,980
something I want to make very very clear

00:16:23,270 --> 00:16:28,340
when you first get started with this

00:16:24,980 --> 00:16:31,820
stuff it is very very tempting to think

00:16:28,340 --> 00:16:34,690
that BCC is EBP F I got very very

00:16:31,820 --> 00:16:36,830
confused to begin with just remember one

00:16:34,690 --> 00:16:37,550
facilitates using the other and then

00:16:36,830 --> 00:16:41,150
you'll be fine

00:16:37,550 --> 00:16:42,740
so something I also want to mention was

00:16:41,150 --> 00:16:44,270
because the front end is going to be

00:16:42,740 --> 00:16:46,490
written you're going to probably write

00:16:44,270 --> 00:16:48,860
it in Python you have access to taking

00:16:46,490 --> 00:16:50,660
the data that you get out of the virtual

00:16:48,860 --> 00:16:52,250
machine and literally plug it into

00:16:50,660 --> 00:16:53,600
anything like if you want to put into

00:16:52,250 --> 00:16:56,270
stats D you want to put into any

00:16:53,600 --> 00:17:00,290
reporting frameworks that you have it is

00:16:56,270 --> 00:17:04,460
trivially possible also I'd like to say

00:17:00,290 --> 00:17:07,130
that this BCC repository has a huge

00:17:04,460 --> 00:17:08,600
number of tools that have been example

00:17:07,130 --> 00:17:11,600
programs that people have need to run in

00:17:08,600 --> 00:17:13,460
the past or the porting of existing

00:17:11,600 --> 00:17:16,040
programs which people have been using in

00:17:13,460 --> 00:17:17,630
the past to this new framework and I've

00:17:16,040 --> 00:17:19,490
got a few that I've been using so you've

00:17:17,630 --> 00:17:21,170
got exact snip which lets you see

00:17:19,490 --> 00:17:23,690
programs which are being executed on

00:17:21,170 --> 00:17:25,340
your machine you have B i/o latency

00:17:23,690 --> 00:17:27,680
which you can see the latency of block

00:17:25,340 --> 00:17:29,150
IO on your machine and then you have

00:17:27,680 --> 00:17:32,090
something called file life which lets

00:17:29,150 --> 00:17:33,620
you see short-lived files I had a huge

00:17:32,090 --> 00:17:36,080
problem with that once and this saved me

00:17:33,620 --> 00:17:38,360
big time the biggest thing that I can

00:17:36,080 --> 00:17:40,580
say for these tools is that you can read

00:17:38,360 --> 00:17:42,680
them and understand them in about 15

00:17:40,580 --> 00:17:45,140
minutes and the reason why that's useful

00:17:42,680 --> 00:17:48,020
is you you might say that hey this

00:17:45,140 --> 00:17:49,400
script is very very close to what I want

00:17:48,020 --> 00:17:50,750
I'm going to change a few different

00:17:49,400 --> 00:17:52,640
things and for this very specific

00:17:50,750 --> 00:17:54,890
debugging scenario which I'm currently

00:17:52,640 --> 00:17:58,400
dealing with I can then figure out

00:17:54,890 --> 00:18:00,170
what's going on that is something that

00:17:58,400 --> 00:18:02,750
you can't really do with a lot of things

00:18:00,170 --> 00:18:04,940
when it comes to the boat like some

00:18:02,750 --> 00:18:06,350
tools you use a completely and flexible

00:18:04,940 --> 00:18:08,210
I wanted to make it very clear that

00:18:06,350 --> 00:18:09,340
these are very flexible to whatever you

00:18:08,210 --> 00:18:13,370
want

00:18:09,340 --> 00:18:14,780
so DTrace it and probably shouldn't be

00:18:13,370 --> 00:18:18,020
left to last this is what actually

00:18:14,780 --> 00:18:19,790
started the whole revolution really when

00:18:18,020 --> 00:18:21,770
de três first came out it won a whole

00:18:19,790 --> 00:18:23,840
bunch of awards it was originally

00:18:21,770 --> 00:18:26,240
written by Sun systems for Solaris

00:18:23,840 --> 00:18:29,630
however there are ports for the various

00:18:26,240 --> 00:18:33,380
BSD flavors as well as Mac OS so anyway

00:18:29,630 --> 00:18:34,880
the MacBook now can use DTrace as I said

00:18:33,380 --> 00:18:38,420
it runner it went a whole bunch of

00:18:34,880 --> 00:18:41,030
awards unfortunately I can't do a DTrace

00:18:38,420 --> 00:18:43,400
demo this isn't my MacBook I use Linux

00:18:41,030 --> 00:18:45,860
so unfortunately I can't give you an

00:18:43,400 --> 00:18:47,660
example however I will say that when I

00:18:45,860 --> 00:18:49,790
did read all the documentation for the

00:18:47,660 --> 00:18:52,670
various traces this one had the most

00:18:49,790 --> 00:18:54,590
documentation and it is very very easy

00:18:52,670 --> 00:18:56,240
to get started with DTrace if the

00:18:54,590 --> 00:18:58,520
documentation is anything to go by and

00:18:56,240 --> 00:19:01,520
it's been used the most widely in the

00:18:58,520 --> 00:19:03,380
community most like there was an effect

00:19:01,520 --> 00:19:07,460
there was an unofficial attempt to port

00:19:03,380 --> 00:19:08,750
dtrace over to linux I'm not sure the

00:19:07,460 --> 00:19:10,220
status of that at the moment but I

00:19:08,750 --> 00:19:13,780
believe most people are now moving

00:19:10,220 --> 00:19:16,070
towards EBP F like that's how you know

00:19:13,780 --> 00:19:20,540
fundamental to the game dtrace was when

00:19:16,070 --> 00:19:22,970
it first came around so I've probably

00:19:20,540 --> 00:19:24,950
bored you enough with the the theory of

00:19:22,970 --> 00:19:27,800
all this when am I actually going to use

00:19:24,950 --> 00:19:30,170
it funny we should mention garbage

00:19:27,800 --> 00:19:32,570
collection again however Instagram and

00:19:30,170 --> 00:19:34,610
Django there was a big effort to

00:19:32,570 --> 00:19:37,820
understand what the memory footprint was

00:19:34,610 --> 00:19:40,040
so this engineering article here is

00:19:37,820 --> 00:19:41,780
talking about how Instagram went through

00:19:40,040 --> 00:19:43,520
all the process of trying to understand

00:19:41,780 --> 00:19:47,770
what is happening with their garbage

00:19:43,520 --> 00:19:49,970
collection and basically turn it off

00:19:47,770 --> 00:19:53,240
however in the article there was

00:19:49,970 --> 00:19:54,800
mentioned that they couldn't get enough

00:19:53,240 --> 00:19:56,900
information as to what's happening with

00:19:54,800 --> 00:19:59,330
garbage collection which happens to sit

00:19:56,900 --> 00:20:01,580
very perfectly with this talk because I

00:19:59,330 --> 00:20:03,560
can then produce you an example we

00:20:01,580 --> 00:20:07,880
we can then debug with the to talk with

00:20:03,560 --> 00:20:10,010
two of the tools so this is my de facto

00:20:07,880 --> 00:20:13,160
go-to example when I'm dealing with the

00:20:10,010 --> 00:20:15,440
USD T probes as they are today so it is

00:20:13,160 --> 00:20:16,700
very advanced code as you can see you

00:20:15,440 --> 00:20:19,310
probably all understand it by now

00:20:16,700 --> 00:20:21,170
however we have a simple printer

00:20:19,310 --> 00:20:22,700
function the reason we use this is

00:20:21,170 --> 00:20:24,830
because when I want to see function

00:20:22,700 --> 00:20:26,470
entry and exit this is Python bytecode

00:20:24,830 --> 00:20:28,850
and so I'll be able to watch that and

00:20:26,470 --> 00:20:33,130
apart from that all it does is print

00:20:28,850 --> 00:20:36,530
sleep and then force garbage collection

00:20:33,130 --> 00:20:38,030
so like I can spend no time on that

00:20:36,530 --> 00:20:41,480
because there's nothing that exciting

00:20:38,030 --> 00:20:43,520
this is systemtap though so systemtap as

00:20:41,480 --> 00:20:47,090
I said is its own language it reads

00:20:43,520 --> 00:20:49,280
similarly to pseudocode when you get to

00:20:47,090 --> 00:20:51,140
see running examples of it but can be a

00:20:49,280 --> 00:20:54,320
little bit complicated and contrived to

00:20:51,140 --> 00:20:56,690
understand at first so let's let's start

00:20:54,320 --> 00:20:59,750
we look at C Python Python which is my

00:20:56,690 --> 00:21:01,610
build of Python with the dtrace markers

00:20:59,750 --> 00:21:03,230
in it we want to know when garbage

00:21:01,610 --> 00:21:05,960
collection starts we're gonna increment

00:21:03,230 --> 00:21:08,720
the counter and then every three seconds

00:21:05,960 --> 00:21:10,940
I'm gonna say hey my garbage collected

00:21:08,720 --> 00:21:15,920
this many times believe it or not the

00:21:10,940 --> 00:21:17,810
answer was three so EBP F again as I

00:21:15,920 --> 00:21:20,030
said before there is a back end and a

00:21:17,810 --> 00:21:21,770
front end this code might be a little

00:21:20,030 --> 00:21:25,910
bit difficult to read but we can try and

00:21:21,770 --> 00:21:28,490
distill it very quickly so the BPP F

00:21:25,910 --> 00:21:31,580
texts we have the import for p trace

00:21:28,490 --> 00:21:33,800
then we have BPF table that is going to

00:21:31,580 --> 00:21:37,990
be called counts it is going to be a

00:21:33,800 --> 00:21:41,000
shared array a shared dictionary between

00:21:37,990 --> 00:21:44,450
the virtual machine and our front end

00:21:41,000 --> 00:21:46,910
code that's just a macro obviously then

00:21:44,450 --> 00:21:48,320
we have count me so count me is the

00:21:46,910 --> 00:21:52,820
function which we are going to execute

00:21:48,320 --> 00:21:54,680
whenever we see the GC probe very very

00:21:52,820 --> 00:21:58,100
interestingly named anyway it will just

00:21:54,680 --> 00:22:03,140
up increment a field in that dictionary

00:21:58,100 --> 00:22:05,360
and that's all okay then we have the

00:22:03,140 --> 00:22:07,160
front end of it which is like literally

00:22:05,360 --> 00:22:08,210
these are just concatenated one under

00:22:07,160 --> 00:22:10,640
another it's not like there's any

00:22:08,210 --> 00:22:13,460
special importing going on all we do

00:22:10,640 --> 00:22:15,820
then is we find the ability like we find

00:22:13,460 --> 00:22:19,730
the library with the Python

00:22:15,820 --> 00:22:22,039
markers then we look for we on the third

00:22:19,730 --> 00:22:24,409
line there we enable garbage collection

00:22:22,039 --> 00:22:26,450
and we say when this event happens run

00:22:24,409 --> 00:22:28,370
this function right that's all that's

00:22:26,450 --> 00:22:30,260
happening there and then we then we

00:22:28,370 --> 00:22:32,750
inject it and then underneath that is

00:22:30,260 --> 00:22:36,710
probably the easy bit where every three

00:22:32,750 --> 00:22:38,570
seconds we read this dictionary pull the

00:22:36,710 --> 00:22:39,830
values out and then reset the counter so

00:22:38,570 --> 00:22:43,730
that it goes back and says three every

00:22:39,830 --> 00:22:45,110
time so I was going to put a slide here

00:22:43,730 --> 00:22:48,830
which had threes all on it but I think

00:22:45,110 --> 00:22:51,169
everyone gets the point so the

00:22:48,830 --> 00:22:54,580
difference is that they like EBP F has

00:22:51,169 --> 00:22:57,139
more code right however like the

00:22:54,580 --> 00:22:58,970
difference between them is mainly in the

00:22:57,139 --> 00:23:02,029
implementations ones in the virtual

00:22:58,970 --> 00:23:03,440
machine ones a kernel module and system

00:23:02,029 --> 00:23:05,570
tap you have to learn an entire new

00:23:03,440 --> 00:23:07,159
language you can get started with EBP F

00:23:05,570 --> 00:23:09,740
with knowledge of a little bit of C and

00:23:07,159 --> 00:23:11,380
reading through header files and Python

00:23:09,740 --> 00:23:15,200
but I didn't need to mention that here

00:23:11,380 --> 00:23:16,639
so a couple of caveats so the first

00:23:15,200 --> 00:23:19,549
thing is you can't run them all the time

00:23:16,639 --> 00:23:21,169
they they are expensive so you will use

00:23:19,549 --> 00:23:23,299
them when the world is on fire and you

00:23:21,169 --> 00:23:25,909
want to know what's going on so the

00:23:23,299 --> 00:23:28,490
second caveat is that the kernel and

00:23:25,909 --> 00:23:29,990
systemtap are developed like distinctly

00:23:28,490 --> 00:23:33,529
so you can have version

00:23:29,990 --> 00:23:35,720
incompatibilities that is more rare than

00:23:33,529 --> 00:23:37,549
the situation where you can't install

00:23:35,720 --> 00:23:38,929
kernel modules there are a lot of people

00:23:37,549 --> 00:23:41,059
who can't install kernel modules for

00:23:38,929 --> 00:23:43,760
like PCI compliance reasons for example

00:23:41,059 --> 00:23:46,070
is worth noting that in those situations

00:23:43,760 --> 00:23:49,730
system tap might be a little bit funny

00:23:46,070 --> 00:23:51,980
to get running the last thing I want to

00:23:49,730 --> 00:23:55,820
mention is you want to know these before

00:23:51,980 --> 00:23:57,679
you need them yeah if you have to try

00:23:55,820 --> 00:23:59,419
and calmly read this while everything's

00:23:57,679 --> 00:24:03,559
going terribly you're gonna have a

00:23:59,419 --> 00:24:06,950
really bad time so with all that said go

00:24:03,559 --> 00:24:09,200
and have a play have fun and if you have

00:24:06,950 --> 00:24:11,809
any questions let me know otherwise

00:24:09,200 --> 00:24:16,490
these these are the best parts to get

00:24:11,809 --> 00:24:18,380
started reading julia evans has had some

00:24:16,490 --> 00:24:21,380
very fantastic blog entries recently and

00:24:18,380 --> 00:24:22,970
Brendan Greg is basically I don't say

00:24:21,380 --> 00:24:25,549
The Godfather but he's like the de facto

00:24:22,970 --> 00:24:26,840
person everyone is reading when they're

00:24:25,549 --> 00:24:28,279
talking about systems performance he's

00:24:26,840 --> 00:24:29,420
got a fantastic book on it too and

00:24:28,279 --> 00:24:30,890
that's the repo

00:24:29,420 --> 00:24:34,040
been talking about the whole time if

00:24:30,890 --> 00:24:37,980
anyone has questions please let me know

00:24:34,040 --> 00:24:37,980
[Applause]

00:24:40,000 --> 00:24:48,080
questions and you can come up at the end

00:24:44,090 --> 00:24:58,730
if if you're nervous or worried that I

00:24:48,080 --> 00:25:01,670
won't know I Kris I might know me there

00:24:58,730 --> 00:25:02,900
are security implications around this so

00:25:01,670 --> 00:25:04,910
yes

00:25:02,900 --> 00:25:06,920
running anything as a kernel module on

00:25:04,910 --> 00:25:09,920
your system has security implications of

00:25:06,920 --> 00:25:12,620
some description I imagine that in many

00:25:09,920 --> 00:25:14,180
cases people don't like I would

00:25:12,620 --> 00:25:15,950
understand if a lot of people don't have

00:25:14,180 --> 00:25:18,590
root access on their machine which means

00:25:15,950 --> 00:25:20,390
that they couldn't do this as well so

00:25:18,590 --> 00:25:22,160
there is the like giving people access

00:25:20,390 --> 00:25:23,990
to do this sort of thing can be a

00:25:22,160 --> 00:25:26,030
problem but generally running things

00:25:23,990 --> 00:25:28,610
inside your kernel that are arbitrarily

00:25:26,030 --> 00:25:30,650
compiled off a language someone wrote in

00:25:28,610 --> 00:25:32,600
the Internet can be a bit of a problem

00:25:30,650 --> 00:25:35,360
as I said PCI environments are a

00:25:32,600 --> 00:25:37,340
fantastic example where you can't just

00:25:35,360 --> 00:25:40,760
run kernel modules because you feel like

00:25:37,340 --> 00:25:42,620
it so the virtual machine could have

00:25:40,760 --> 00:25:44,530
bugs as well there is there's always

00:25:42,620 --> 00:25:46,940
that chance

00:25:44,530 --> 00:25:49,880
however yeah like you would be doing

00:25:46,940 --> 00:25:51,470
this in order to gain insight I imagine

00:25:49,880 --> 00:25:53,900
that when you're reproducing this into a

00:25:51,470 --> 00:25:56,210
staging environment those constraints

00:25:53,900 --> 00:25:57,380
are relaxed a little bit if you've got

00:25:56,210 --> 00:25:58,790
shadowing environments that's even

00:25:57,380 --> 00:26:02,660
better because people won't see this

00:25:58,790 --> 00:26:07,340
kind of thing so yeah there are security

00:26:02,660 --> 00:26:10,840
implications but you know that happens

00:26:07,340 --> 00:26:10,840
when you give anyone root on any box

00:26:16,520 --> 00:26:22,280
you didn't mention s trace where does

00:26:18,890 --> 00:26:25,790
that fit in to the skin things so s

00:26:22,280 --> 00:26:28,240
trace is is a different realm of

00:26:25,790 --> 00:26:30,670
debugging this sort of stuff that is the

00:26:28,240 --> 00:26:33,140
interactions with the system more than

00:26:30,670 --> 00:26:36,200
understanding how your program is doing

00:26:33,140 --> 00:26:38,390
like so I was attempting to talk just

00:26:36,200 --> 00:26:41,480
about the Python stuff but then falls

00:26:38,390 --> 00:26:44,960
into like kernel understanding s trace

00:26:41,480 --> 00:26:46,520
is the interface so you'll see like file

00:26:44,960 --> 00:26:49,100
opens and stuff happening through s

00:26:46,520 --> 00:26:50,210
trace but this is more about like giving

00:26:49,100 --> 00:26:52,340
you insight to the Python interpreter

00:26:50,210 --> 00:26:55,150
and what the Python interpreter is doing

00:26:52,340 --> 00:27:04,030
throughout the process of your system

00:26:55,150 --> 00:27:04,030
justin is s trace slower than ebps

00:27:04,570 --> 00:27:11,300
that's a good question I would have to

00:27:09,230 --> 00:27:15,380
run a sample but I believe that it would

00:27:11,300 --> 00:27:18,440
be significantly slower I don't know

00:27:15,380 --> 00:27:20,510
whether that I don't know whether they

00:27:18,440 --> 00:27:22,220
are interchangeable is the other thing

00:27:20,510 --> 00:27:25,190
so I don't know whether comparing them

00:27:22,220 --> 00:27:27,320
is apples with apples so I can do that

00:27:25,190 --> 00:27:30,010
and I will post an update somewhere that

00:27:27,320 --> 00:27:30,010
everyone can read it

00:27:34,269 --> 00:27:40,460
hi do you know if it's possible when you

00:27:37,130 --> 00:27:43,070
enable the traces to limit it to just

00:27:40,460 --> 00:27:45,500
one path new process or is it going to

00:27:43,070 --> 00:27:49,490
be everything on the system so you can

00:27:45,500 --> 00:27:51,470
all of them so in the case of e BPF I

00:27:49,490 --> 00:27:53,210
have to stipulate the process ID that

00:27:51,470 --> 00:27:55,490
will I don't have to but I can stipulate

00:27:53,210 --> 00:27:57,980
the process ID that I care about and in

00:27:55,490 --> 00:28:00,049
system tap where I had my string which

00:27:57,980 --> 00:28:03,590
was the command I was running remember

00:28:00,049 --> 00:28:06,379
how it said see I can go back you see

00:28:03,590 --> 00:28:08,539
how I have C Python Python there if you

00:28:06,379 --> 00:28:10,399
replace that with a process ID it will

00:28:08,539 --> 00:28:11,149
only bind to that process ID yeah

00:28:10,399 --> 00:28:20,720
perfect

00:28:11,149 --> 00:28:22,879
great no more okay to finish off Chris

00:28:20,720 --> 00:28:26,509
I'd like to present you a small gift on

00:28:22,879 --> 00:28:30,129
behalf of quite than Australia for you

00:28:26,509 --> 00:28:30,129
awesome talk thank you very much

00:28:34,490 --> 00:28:36,550

YouTube URL: https://www.youtube.com/watch?v=Zv3--YaaIe0


