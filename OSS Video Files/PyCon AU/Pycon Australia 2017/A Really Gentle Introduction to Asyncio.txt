Title: A Really Gentle Introduction to Asyncio
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Gregory Saunders

http://2017.pycon-au.org/schedule/presentation/36/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:00,589 --> 00:00:06,170
hello thank you so much for being here

00:00:03,210 --> 00:00:08,849
you it's always nice to see a full room

00:00:06,170 --> 00:00:11,910
we're here to see a really gentle

00:00:08,849 --> 00:00:13,710
introduction to a sink i/o if you were

00:00:11,910 --> 00:00:17,310
hoping to watch another talk he's still

00:00:13,710 --> 00:00:20,220
in time to leave the room hurriedly so

00:00:17,310 --> 00:00:22,580
I'm here to introduce Greg Saunders who

00:00:20,220 --> 00:00:23,820
has been programming in Python since

00:00:22,580 --> 00:00:25,800
00:00:23,820 --> 00:00:27,060
that was version 1.2 according to his

00:00:25,800 --> 00:00:29,310
recollection which is better than mine

00:00:27,060 --> 00:00:31,289
he's got a PhD in computer science and

00:00:29,310 --> 00:00:34,469
works in the financial industry he has

00:00:31,289 --> 00:00:36,510
for the past 10 years and he currently

00:00:34,469 --> 00:00:39,809
works for octavo which is financial

00:00:36,510 --> 00:00:49,170
services firm as a software developer so

00:00:39,809 --> 00:00:51,480
please hand for Greg well thank you for

00:00:49,170 --> 00:00:53,940
that warm welcome I imagine many people

00:00:51,480 --> 00:00:55,980
have tried to give a a gentle

00:00:53,940 --> 00:00:58,739
introduction a sink i/o so I'll add my

00:00:55,980 --> 00:01:01,850
name to that list hopefully I will be

00:00:58,739 --> 00:01:04,290
among the better and not the worst ones

00:01:01,850 --> 00:01:06,720
well obviously I've just been introduced

00:01:04,290 --> 00:01:09,960
so all of that is you've already been

00:01:06,720 --> 00:01:12,750
told but that's me so let's move

00:01:09,960 --> 00:01:15,900
straight into it in the talk today I

00:01:12,750 --> 00:01:17,759
want to start by sort of asking us why

00:01:15,900 --> 00:01:18,210
we even need a sink i/o in the first

00:01:17,759 --> 00:01:20,189
place

00:01:18,210 --> 00:01:23,640
then I want to talk about how we can do

00:01:20,189 --> 00:01:25,350
two things at once without threads then

00:01:23,640 --> 00:01:27,270
we'll get a handle on the future talk

00:01:25,350 --> 00:01:29,070
about the Select module talk about

00:01:27,270 --> 00:01:32,100
transports protocols and we'll put it

00:01:29,070 --> 00:01:34,170
all together in a live demo tempting the

00:01:32,100 --> 00:01:40,439
hand of fate there's live demos always

00:01:34,170 --> 00:01:43,770
do so why do we need a sink IO IO is

00:01:40,439 --> 00:01:45,420
really slow really nice though I'm sure

00:01:43,770 --> 00:01:46,649
you all know this right you've all been

00:01:45,420 --> 00:01:49,640
downloading something from the internet

00:01:46,649 --> 00:01:53,490
and it takes way longer than it should

00:01:49,640 --> 00:01:57,119
so mmm if you think about it the I had a

00:01:53,490 --> 00:01:58,770
look on Google the common SSD latency

00:01:57,119 --> 00:02:00,869
time which is a time from when you make

00:01:58,770 --> 00:02:03,149
a request to when you get your data can

00:02:00,869 --> 00:02:05,340
be measured in the milliseconds

00:02:03,149 --> 00:02:08,220
there's 1,000 milliseconds in a second

00:02:05,340 --> 00:02:10,500
but there's literally billions of CPU

00:02:08,220 --> 00:02:13,740
cycles every second so if you're waiting

00:02:10,500 --> 00:02:16,890
for that IO to happen you're wasting

00:02:13,740 --> 00:02:19,350
lots of CPU cycles so how can we use

00:02:16,890 --> 00:02:22,470
that time efficiently that's what we

00:02:19,350 --> 00:02:24,740
want to do and one way to do that

00:02:22,470 --> 00:02:27,240
it's the so called reactor pattern

00:02:24,740 --> 00:02:29,400
there's the the description from

00:02:27,240 --> 00:02:31,980
Wikipedia I'll let you read that it's

00:02:29,400 --> 00:02:34,080
been around for a while and the basic

00:02:31,980 --> 00:02:36,570
idea is what we're going to do is going

00:02:34,080 --> 00:02:38,550
to wait for some event to happen because

00:02:36,570 --> 00:02:40,560
I always so slow these events aren't

00:02:38,550 --> 00:02:42,750
going to happen very often in computing

00:02:40,560 --> 00:02:44,970
terms and then we're going to do

00:02:42,750 --> 00:02:50,190
something when the event occurs we're

00:02:44,970 --> 00:02:54,840
going to react to that event so just

00:02:50,190 --> 00:02:56,490
comparing async i/o to threads an async

00:02:54,840 --> 00:02:58,290
i/o program is typically a

00:02:56,490 --> 00:02:59,280
single-threaded program which means you

00:02:58,290 --> 00:03:01,890
don't have to worry about

00:02:59,280 --> 00:03:04,320
synchronization you don't have to worry

00:03:01,890 --> 00:03:07,500
about locks and semaphores and queues

00:03:04,320 --> 00:03:10,350
and such like this now you can write a

00:03:07,500 --> 00:03:12,000
multi-threaded async i/o program but

00:03:10,350 --> 00:03:13,860
typically the threads will be relatively

00:03:12,000 --> 00:03:15,660
independent of each other so you'll have

00:03:13,860 --> 00:03:19,650
less to worry about in terms of

00:03:15,660 --> 00:03:22,050
synchronization interestingly in a

00:03:19,650 --> 00:03:24,870
multi-threaded program the switching

00:03:22,050 --> 00:03:26,670
between threads occurs whenever the CPU

00:03:24,870 --> 00:03:30,810
or sorry whenever the operating system

00:03:26,670 --> 00:03:33,720
thinks it's a good idea but in async i/o

00:03:30,810 --> 00:03:37,590
the context switching among the the

00:03:33,720 --> 00:03:38,910
quote unquote threads is actually

00:03:37,590 --> 00:03:40,680
controlled by the application the

00:03:38,910 --> 00:03:42,660
application defines the points when this

00:03:40,680 --> 00:03:45,060
can occur which means they can occur at

00:03:42,660 --> 00:03:49,350
a points that are appropriate for the

00:03:45,060 --> 00:03:51,690
application not just randomly as happens

00:03:49,350 --> 00:03:54,170
with threads so I think i/o is

00:03:51,690 --> 00:03:56,880
particularly good for i/o band asks

00:03:54,170 --> 00:03:59,400
whereas threads are typically better if

00:03:56,880 --> 00:04:02,240
your task or at least part of your task

00:03:59,400 --> 00:04:05,430
is heavily CPU bound it's doing a lot of

00:04:02,240 --> 00:04:08,900
computational work and so you want to

00:04:05,430 --> 00:04:11,520
shunt that work off to a separate thread

00:04:08,900 --> 00:04:13,530
as opposed to an async i/o where you

00:04:11,520 --> 00:04:15,030
typically have very little work to do

00:04:13,530 --> 00:04:19,380
you just need to do it every time

00:04:15,030 --> 00:04:21,060
there's an i/o event okay so that's a

00:04:19,380 --> 00:04:24,419
bit of a justification for why we might

00:04:21,060 --> 00:04:27,420
want a sync I own so how can we have

00:04:24,419 --> 00:04:30,720
concurrency without threads

00:04:27,420 --> 00:04:35,520
how can we do that can anyone tell me

00:04:30,720 --> 00:04:37,550
what this is a picture of yes an Amiga

00:04:35,520 --> 00:04:42,570
500 give the man a mars bar

00:04:37,550 --> 00:04:45,090
yes great great computer I had one of

00:04:42,570 --> 00:04:46,770
these when I was young back in 1989 I

00:04:45,090 --> 00:04:49,140
imagined some people in this room

00:04:46,770 --> 00:04:51,270
weren't even born then leaving art we

00:04:49,140 --> 00:04:55,530
did have computers back then this was a

00:04:51,270 --> 00:04:57,630
particularly great one this little

00:04:55,530 --> 00:05:00,680
computer has a single core cpu running

00:04:57,630 --> 00:05:05,700
at the whopping seven megahertz that

00:05:00,680 --> 00:05:07,140
megahertz right either it had pre out

00:05:05,700 --> 00:05:09,870
there world actually the predecessor

00:05:07,140 --> 00:05:12,450
model - this was released in 1985 the

00:05:09,870 --> 00:05:15,210
Amiga 500 was just a cost reduce version

00:05:12,450 --> 00:05:18,300
of the Amiga 1000 and it had pre-emptive

00:05:15,210 --> 00:05:20,400
multitasking way back in 1985 so you can

00:05:18,300 --> 00:05:22,920
have concurrency even if you don't have

00:05:20,400 --> 00:05:25,920
a multi-core CPU even if you don't have

00:05:22,920 --> 00:05:28,410
a particularly fast CPU right the way

00:05:25,920 --> 00:05:31,590
that it works of course is that you just

00:05:28,410 --> 00:05:34,380
do a little bit of work for one piece of

00:05:31,590 --> 00:05:35,640
football on task and then you switch and

00:05:34,380 --> 00:05:37,560
do a little piece of work for notice and

00:05:35,640 --> 00:05:40,500
you do that lots of times every second

00:05:37,560 --> 00:05:41,820
and it looks like the tasks are running

00:05:40,500 --> 00:05:44,960
concurrently but they're not really

00:05:41,820 --> 00:05:48,240
right so that's how we can have

00:05:44,960 --> 00:05:51,960
concurrency without multi-core CPUs or

00:05:48,240 --> 00:05:57,000
threads or anything like that so let's

00:05:51,960 --> 00:06:07,770
have a quick demo and we'll see what we

00:05:57,000 --> 00:06:10,050
can do with this what I'm going to try

00:06:07,770 --> 00:06:14,310
and do is do a little bit of a duet with

00:06:10,050 --> 00:06:18,140
Python and I think I know if I can get

00:06:14,310 --> 00:06:21,510
this to disappear okay here's my little

00:06:18,140 --> 00:06:23,550
duet with Python hopefully you all know

00:06:21,510 --> 00:06:24,750
the song anything you can do I can do

00:06:23,550 --> 00:06:28,560
better I won't try and sing it because

00:06:24,750 --> 00:06:30,090
you'll all just run away so Annie's

00:06:28,560 --> 00:06:32,610
lines are anything you can do I can do

00:06:30,090 --> 00:06:36,540
better and Frank responds no you can't

00:06:32,610 --> 00:06:38,520
and any response yes I can so that's

00:06:36,540 --> 00:06:40,379
what it's going to do so let's just run

00:06:38,520 --> 00:06:50,009
it to see what happens

00:06:40,379 --> 00:06:52,240
see if it actually works we can't grow

00:06:50,009 --> 00:06:54,370
anything you can do I can do better I

00:06:52,240 --> 00:06:56,740
know you can't yes I can no you can't

00:06:54,370 --> 00:07:00,250
yes I can and so on so we've got two

00:06:56,740 --> 00:07:04,449
pieces of code running kind of

00:07:00,250 --> 00:07:05,919
concurrently and what we've got down the

00:07:04,449 --> 00:07:07,810
bottom here I'll just scroll up to show

00:07:05,919 --> 00:07:10,599
you that is the loop which is making

00:07:07,810 --> 00:07:13,240
this happen so we pop Annie and Frank

00:07:10,599 --> 00:07:15,069
onto our queue and then we sorry we push

00:07:13,240 --> 00:07:18,159
them onto our queue and then while the

00:07:15,069 --> 00:07:19,889
keys not empty we just pop the first

00:07:18,159 --> 00:07:22,030
thing off the queue print its line

00:07:19,889 --> 00:07:27,180
append it back onto the end of the queue

00:07:22,030 --> 00:07:30,370
and keep going until the end okay now

00:07:27,180 --> 00:07:32,199
Annie and Frank in this case what are

00:07:30,370 --> 00:07:35,729
called generators everyone familiar with

00:07:32,199 --> 00:07:37,029
generators yeah oh good most of you are

00:07:35,729 --> 00:07:39,969
excuse me

00:07:37,029 --> 00:07:42,779
generators are these Python functions

00:07:39,969 --> 00:07:45,729
that have these special yield keywords

00:07:42,779 --> 00:07:48,849
and basically what happens is when a

00:07:45,729 --> 00:07:51,340
generator yields it yields a result back

00:07:48,849 --> 00:07:53,620
to whoever called it but it maintains

00:07:51,340 --> 00:07:56,560
its state so that we can come back to it

00:07:53,620 --> 00:07:59,319
later on and carry on from where we left

00:07:56,560 --> 00:08:01,650
off right that's how this little demo

00:07:59,319 --> 00:08:05,500
works now an interesting little thing

00:08:01,650 --> 00:08:08,020
about about generators is that they're

00:08:05,500 --> 00:08:09,699
actually bi-directional and what I mean

00:08:08,020 --> 00:08:11,949
by bi-directional is that you don't just

00:08:09,699 --> 00:08:14,620
get information out of a generator you

00:08:11,949 --> 00:08:16,330
can send information in to a generator

00:08:14,620 --> 00:08:18,210
so I'll just quickly show you how you

00:08:16,330 --> 00:08:22,810
might do that

00:08:18,210 --> 00:08:24,520
sing your dots and now the generators

00:08:22,810 --> 00:08:26,139
that we have here aren't expecting us to

00:08:24,520 --> 00:08:28,810
send anything into them so I'm just

00:08:26,139 --> 00:08:31,120
going to send none into them but you

00:08:28,810 --> 00:08:32,949
could you could send an actual value

00:08:31,120 --> 00:08:35,140
into them and that would work fine and

00:08:32,949 --> 00:08:35,829
we'll just run that and there we go it

00:08:35,140 --> 00:08:37,839
still works

00:08:35,829 --> 00:08:39,070
okay so generators they're

00:08:37,839 --> 00:08:42,010
bi-directional that will become

00:08:39,070 --> 00:08:46,449
important later okay let's go back to my

00:08:42,010 --> 00:08:48,940
presentation here okay so there's our

00:08:46,449 --> 00:08:51,370
generators there's our loop so what we

00:08:48,940 --> 00:08:54,190
got here mmm so we've got two directors

00:08:51,370 --> 00:08:56,290
running kind of concurrently we've got

00:08:54,190 --> 00:08:57,910
switches that akhirat application

00:08:56,290 --> 00:09:01,750
defined points wherever the yield is

00:08:57,910 --> 00:09:05,830
right and there's a loop that's managing

00:09:01,750 --> 00:09:07,690
running these things right now what have

00:09:05,830 --> 00:09:10,690
we really achieved I mean come on I

00:09:07,690 --> 00:09:12,280
could have just printed each of the

00:09:10,690 --> 00:09:13,510
lines in order and got me exactly the

00:09:12,280 --> 00:09:15,220
same result the code would have been

00:09:13,510 --> 00:09:16,000
shorter it wouldn't be much simpler why

00:09:15,220 --> 00:09:18,730
did I bother

00:09:16,000 --> 00:09:22,600
well what I've been able to do is I've

00:09:18,730 --> 00:09:24,010
been able to arrange the code in logical

00:09:22,600 --> 00:09:26,380
units I've been able to put Annie's

00:09:24,010 --> 00:09:28,300
lines in one function or generator and

00:09:26,380 --> 00:09:32,230
Frank's lines in another I've been able

00:09:28,300 --> 00:09:35,790
to arrange them in a logical way right

00:09:32,230 --> 00:09:35,790
and that's really what we've achieved

00:09:36,120 --> 00:09:41,680
now in async i/o we use generators but

00:09:40,090 --> 00:09:44,890
they're called co-routines they're

00:09:41,680 --> 00:09:47,380
special kinds of generators and the loop

00:09:44,890 --> 00:09:49,750
that executes them is called the event

00:09:47,380 --> 00:09:54,520
loop okay and it's the thing that is

00:09:49,750 --> 00:09:57,040
responding to events okay so now let's

00:09:54,520 --> 00:09:59,140
talk about futures I'm running a bit

00:09:57,040 --> 00:10:01,210
behind time so I'll go quickly what is

00:09:59,140 --> 00:10:02,080
the future okay so all problems in

00:10:01,210 --> 00:10:03,250
computer science can be solved by

00:10:02,080 --> 00:10:05,140
another level of indirection hopefully

00:10:03,250 --> 00:10:06,670
you've all heard that quote a future is

00:10:05,140 --> 00:10:08,710
just an indirect reference to a

00:10:06,670 --> 00:10:11,050
forthcoming result which is a fancy way

00:10:08,710 --> 00:10:13,630
of saying I'm gonna have a result for

00:10:11,050 --> 00:10:15,730
you just I don't have it yet okay that's

00:10:13,630 --> 00:10:17,860
all that it means and you can ask the

00:10:15,730 --> 00:10:19,750
future to call you back when it has the

00:10:17,860 --> 00:10:23,280
result so what are some real-world

00:10:19,750 --> 00:10:26,500
examples of futures checks in the mail

00:10:23,280 --> 00:10:28,030
don't call us we'll call you can you

00:10:26,500 --> 00:10:29,160
lend me 50 bucks I'll totally pay you

00:10:28,030 --> 00:10:31,300
back

00:10:29,160 --> 00:10:34,390
totally that's what makes it a future

00:10:31,300 --> 00:10:35,470
right so let's let's have a look at what

00:10:34,390 --> 00:10:40,240
it might look like if we were using

00:10:35,470 --> 00:10:50,650
futures in our demo where's my it gone

00:10:40,240 --> 00:10:53,080
there it is okay so here we have a

00:10:50,650 --> 00:10:56,350
version of our little duet which is

00:10:53,080 --> 00:10:58,510
using futures so Annie is going to print

00:10:56,350 --> 00:11:01,660
out her first two lines and then she's

00:10:58,510 --> 00:11:05,530
gonna create a callback so that when

00:11:01,660 --> 00:11:08,050
Frank is done with his line she'll get

00:11:05,530 --> 00:11:09,940
called back to say yes she can

00:11:08,050 --> 00:11:12,459
and then Frank is going to print his

00:11:09,940 --> 00:11:16,810
line and then he's gonna tell Annie

00:11:12,459 --> 00:11:18,730
that he's done okay and so I'm gonna use

00:11:16,810 --> 00:11:21,220
some async I hope code here to run this

00:11:18,730 --> 00:11:22,720
whoops didn't mean to do that and and

00:11:21,220 --> 00:11:25,600
basically all this is doing is creating

00:11:22,720 --> 00:11:27,100
a future for us we call any we give any

00:11:25,600 --> 00:11:30,790
the future so that she can register a

00:11:27,100 --> 00:11:32,920
callback we call Frank and then we just

00:11:30,790 --> 00:11:35,050
run until the future has finished

00:11:32,920 --> 00:11:36,640
running which this this last line all

00:11:35,050 --> 00:11:40,329
its really doing is making sure that the

00:11:36,640 --> 00:11:44,709
the callback actually occurs so if I run

00:11:40,329 --> 00:11:46,510
that you can see any printer line Frank

00:11:44,709 --> 00:11:48,370
Prince's line and then Annie gets called

00:11:46,510 --> 00:11:52,089
back and prints her line

00:11:48,370 --> 00:11:58,269
so that's futures okay back to my

00:11:52,089 --> 00:12:00,070
presentation okay so problem is that

00:11:58,269 --> 00:12:01,930
Cole backs aren't really the nicest way

00:12:00,070 --> 00:12:03,399
to do things imagine if you if you had

00:12:01,930 --> 00:12:04,959
to do everything with Cole backs right

00:12:03,399 --> 00:12:07,149
you'd be defining callbacks all over the

00:12:04,959 --> 00:12:09,490
place you'd need to pass futures around

00:12:07,149 --> 00:12:11,589
every which way but loose and register

00:12:09,490 --> 00:12:13,180
your callbacks on them it just wouldn't

00:12:11,589 --> 00:12:16,209
be very nice wouldn't it be great if we

00:12:13,180 --> 00:12:17,950
could write our code in line like that

00:12:16,209 --> 00:12:21,760
first version of the generators that we

00:12:17,950 --> 00:12:25,600
had and do it that way so again we'll

00:12:21,760 --> 00:12:38,829
switch over to the live demo and where's

00:12:25,600 --> 00:12:42,190
our John keeps disappearing than me okay

00:12:38,829 --> 00:12:45,700
so here's a version which allows us to

00:12:42,190 --> 00:12:48,520
do the code in line so now what's

00:12:45,700 --> 00:12:52,029
happening here is we're using an async

00:12:48,520 --> 00:12:54,399
i/o generator the keyword async before

00:12:52,029 --> 00:12:57,339
the DEF there is what turns our

00:12:54,399 --> 00:13:01,570
generator into an async i/o co-routine

00:12:57,339 --> 00:13:05,740
okay and the I weight is really just a

00:13:01,570 --> 00:13:08,110
fancy way of doing a yield right so

00:13:05,740 --> 00:13:09,640
Annie's going to print her lines then

00:13:08,110 --> 00:13:11,290
she's gonna wait for Frank to print his

00:13:09,640 --> 00:13:12,490
line then she's going to do her line

00:13:11,290 --> 00:13:16,480
again and she's gonna keep doing that

00:13:12,490 --> 00:13:19,690
until the entire chorus is sung right so

00:13:16,480 --> 00:13:21,790
now we've got our code in line right we

00:13:19,690 --> 00:13:24,010
can write our code in such a way that it

00:13:21,790 --> 00:13:29,640
it stops at the points where it needs to

00:13:24,010 --> 00:13:33,490
and then carries on when it's ready okay

00:13:29,640 --> 00:13:37,810
so what's actually happening here is

00:13:33,490 --> 00:13:42,310
that the event loop in async IO is going

00:13:37,810 --> 00:13:44,230
to handle this callbacks for us it's

00:13:42,310 --> 00:13:46,540
going to set up the callbacks handle

00:13:44,230 --> 00:13:49,900
them for us and allow us to write our

00:13:46,540 --> 00:13:51,130
code in this nice clean logical way so

00:13:49,900 --> 00:13:56,410
that we don't have to register the

00:13:51,130 --> 00:13:58,840
callbacks ourselves go back here now the

00:13:56,410 --> 00:14:02,230
way that does this is what's called a

00:13:58,840 --> 00:14:05,920
task in async i/o so a task is just a

00:14:02,230 --> 00:14:08,560
piece of data structure that runs a cur

00:14:05,920 --> 00:14:10,420
routine in the event loop and at each

00:14:08,560 --> 00:14:13,060
step the Karoo teen is going to do

00:14:10,420 --> 00:14:16,510
basically one of three things it's going

00:14:13,060 --> 00:14:18,520
to a weight or yield a future write and

00:14:16,510 --> 00:14:20,290
what the task is going to do is it's

00:14:18,520 --> 00:14:21,670
going to say write oh I can't continue

00:14:20,290 --> 00:14:24,760
with this curve routine until that

00:14:21,670 --> 00:14:27,070
future is ready right so it will put it

00:14:24,760 --> 00:14:29,890
aside right and later when that future

00:14:27,070 --> 00:14:32,430
becomes ready it'll say AHA the futures

00:14:29,890 --> 00:14:35,470
ready I can continue running this task

00:14:32,430 --> 00:14:38,110
the other thing that the coyote might do

00:14:35,470 --> 00:14:41,350
is it might a weight or yield another Co

00:14:38,110 --> 00:14:43,390
routine right and in that case the the

00:14:41,350 --> 00:14:45,310
task will say oh I've got a Co routine

00:14:43,390 --> 00:14:48,190
to run I'll start running it and when it

00:14:45,310 --> 00:14:50,200
needs to wait for something it'll do the

00:14:48,190 --> 00:14:51,730
same thing over again all right and the

00:14:50,200 --> 00:14:54,310
last thing occur routine might do is

00:14:51,730 --> 00:14:57,880
return a results right in which case the

00:14:54,310 --> 00:15:00,970
task knows okay this thing is done right

00:14:57,880 --> 00:15:04,930
it's finished okay so that's what a task

00:15:00,970 --> 00:15:07,990
is now let's talk about the Select

00:15:04,930 --> 00:15:10,120
module who's heard of the Select module

00:15:07,990 --> 00:15:12,400
Python yeah finish mattering your hands

00:15:10,120 --> 00:15:15,280
basically select is an OS function that

00:15:12,400 --> 00:15:17,080
helps us wait for IO right it basically

00:15:15,280 --> 00:15:19,960
you give it a whole bunch of i/o

00:15:17,080 --> 00:15:22,690
channels like files or network sockets

00:15:19,960 --> 00:15:24,400
and it tells you which of them are ready

00:15:22,690 --> 00:15:25,840
for reading or writing whatever you

00:15:24,400 --> 00:15:27,580
might need to do with them and you can

00:15:25,840 --> 00:15:29,650
tell it to wait for a fixed amount of

00:15:27,580 --> 00:15:35,640
time or indefinitely so let's have a

00:15:29,650 --> 00:15:35,640
really quick look at that vector point

00:15:36,800 --> 00:15:42,990
okay so here's a really contrived

00:15:39,810 --> 00:15:44,160
example of how we might use select well

00:15:42,990 --> 00:15:46,260
we're going to open a couple of files

00:15:44,160 --> 00:15:48,480
we're going to put the files onto a list

00:15:46,260 --> 00:15:50,670
we're going to put stood it out onto a

00:15:48,480 --> 00:15:53,370
list and basically we're going to use

00:15:50,670 --> 00:15:55,290
the Select call to tell us when these

00:15:53,370 --> 00:15:58,500
things are ready and when they're ready

00:15:55,290 --> 00:16:01,890
we read from them or write to them okay

00:15:58,500 --> 00:16:05,330
and this will print out the the contents

00:16:01,890 --> 00:16:07,320
of the files that we were just reading

00:16:05,330 --> 00:16:11,790
kind of interleaved with each other

00:16:07,320 --> 00:16:14,790
right so if you think about it this is

00:16:11,790 --> 00:16:17,370
kind of useful for our event loop our

00:16:14,790 --> 00:16:21,450
event loop can use this select method to

00:16:17,370 --> 00:16:22,230
figure out when IO is ready and then do

00:16:21,450 --> 00:16:25,800
something with it

00:16:22,230 --> 00:16:28,830
right that's the core of how I think IO

00:16:25,800 --> 00:16:31,350
works it's using select or something

00:16:28,830 --> 00:16:35,130
like it to wait for IO events to occur

00:16:31,350 --> 00:16:38,130
and then schedule and run the

00:16:35,130 --> 00:16:45,600
appropriate callbacks to make our events

00:16:38,130 --> 00:16:47,880
happen so that's a select module okay so

00:16:45,600 --> 00:16:51,770
now let's quickly talk about transports

00:16:47,880 --> 00:16:54,180
and protocols so what is a transport a

00:16:51,770 --> 00:16:56,370
transport is just a way of moving data

00:16:54,180 --> 00:16:59,430
from one place to another that's all

00:16:56,370 --> 00:17:01,080
okay it's responsible for doing ion

00:16:59,430 --> 00:17:05,810
buffering there's several of them in

00:17:01,080 --> 00:17:07,620
async i/o TCP UDP SSL pipes so pipes are

00:17:05,810 --> 00:17:09,810
communicating with sub processes

00:17:07,620 --> 00:17:12,020
basically so with it's just a way of

00:17:09,810 --> 00:17:15,020
getting data from one point to another

00:17:12,020 --> 00:17:17,730
okay so that's all the transport is the

00:17:15,020 --> 00:17:20,460
API for transport includes methods like

00:17:17,730 --> 00:17:24,510
clothes writes pause reading resume

00:17:20,460 --> 00:17:26,130
reading etc but not there's no read

00:17:24,510 --> 00:17:28,290
method there's no read method because

00:17:26,130 --> 00:17:30,750
you're gonna get a call back when your

00:17:28,290 --> 00:17:33,510
data is ready you don't want to block

00:17:30,750 --> 00:17:35,190
waiting for your data to be read you

00:17:33,510 --> 00:17:39,150
just want to get call back when you get

00:17:35,190 --> 00:17:40,800
some data so just quickly the sub

00:17:39,150 --> 00:17:43,020
process pipes is another kind of

00:17:40,800 --> 00:17:45,690
transports it has methods like get the

00:17:43,020 --> 00:17:47,910
process ideas or sub process terminate

00:17:45,690 --> 00:17:48,580
the process kill the process very

00:17:47,910 --> 00:17:51,490
violent can be

00:17:48,580 --> 00:17:55,539
scientists anyway and Datagram

00:17:51,490 --> 00:17:58,360
transports so send bots on so you don't

00:17:55,539 --> 00:18:00,279
create transports directly right instead

00:17:58,360 --> 00:18:02,049
the event loop is going to supply

00:18:00,279 --> 00:18:03,039
methods for us that help us create them

00:18:02,049 --> 00:18:06,490
we'll see you soon Tamara I'm going to

00:18:03,039 --> 00:18:07,659
give you a demo right so the examples of

00:18:06,490 --> 00:18:09,279
their methods that the event loop

00:18:07,659 --> 00:18:11,710
supplies for you are things like create

00:18:09,279 --> 00:18:13,990
connection creates a executor sub

00:18:11,710 --> 00:18:17,830
process now

00:18:13,990 --> 00:18:19,659
a transport is only transmitting data or

00:18:17,830 --> 00:18:20,590
transporting data from one point to

00:18:19,659 --> 00:18:23,380
another right

00:18:20,590 --> 00:18:25,090
there's no way to interpret the data in

00:18:23,380 --> 00:18:26,559
order to do that you need something else

00:18:25,090 --> 00:18:30,010
and the thing you need it's called a

00:18:26,559 --> 00:18:32,529
protocol so each of these functions that

00:18:30,010 --> 00:18:35,470
creates a transport for us takes as its

00:18:32,529 --> 00:18:38,110
first argument a factory function for a

00:18:35,470 --> 00:18:42,669
protocol so let's talk a little bit

00:18:38,110 --> 00:18:45,850
about protocols so protocols basically

00:18:42,669 --> 00:18:47,860
process data as it comes in and they're

00:18:45,850 --> 00:18:49,750
used to ask the transport to send data

00:18:47,860 --> 00:18:54,580
out now if you think about it a protocol

00:18:49,750 --> 00:18:57,130
is it's a set of rules to manage

00:18:54,580 --> 00:18:59,860
communication between a couple of things

00:18:57,130 --> 00:19:01,000
so it you know one side is supposed to

00:18:59,860 --> 00:19:01,929
do this and then the other slides

00:19:01,000 --> 00:19:05,649
supposed to do that

00:19:01,929 --> 00:19:07,480
that's what a protocol is so in a sink

00:19:05,649 --> 00:19:09,190
i/o you have several different types of

00:19:07,480 --> 00:19:11,980
protocols streaming protocols Datagram

00:19:09,190 --> 00:19:14,380
protocols so process protocols and what

00:19:11,980 --> 00:19:17,470
you do as the async i/o programmers you

00:19:14,380 --> 00:19:19,840
create a subclass of one of these

00:19:17,470 --> 00:19:23,639
protocols and define how your

00:19:19,840 --> 00:19:23,639
application is supposed to behave and

00:19:24,510 --> 00:19:28,899
then your product that your program

00:19:26,710 --> 00:19:31,090
responds to events in accordance with

00:19:28,899 --> 00:19:32,620
the protocol you've defined now I'm

00:19:31,090 --> 00:19:33,820
going to give you a quick demo in order

00:19:32,620 --> 00:19:35,230
to do that I'm going to be using

00:19:33,820 --> 00:19:36,549
Google's protobuf if you don't know

00:19:35,230 --> 00:19:39,279
protobuf don't worry it's pretty simple

00:19:36,549 --> 00:19:41,620
what it does is that it deep

00:19:39,279 --> 00:19:43,269
materializes and deserialize as messages

00:19:41,620 --> 00:19:46,139
for me so that I can transmit them over

00:19:43,269 --> 00:19:50,500
a byte stream like a network connection

00:19:46,139 --> 00:19:52,600
now the raw data in in a network message

00:19:50,500 --> 00:19:54,250
could contain more than one message

00:19:52,600 --> 00:19:56,799
there's no way of knowing how many

00:19:54,250 --> 00:19:58,240
messages it contains so what I'm going

00:19:56,799 --> 00:20:01,539
to do is I'm going to begin each message

00:19:58,240 --> 00:20:02,500
with a 2-byte length field that tells me

00:20:01,539 --> 00:20:04,230
how long it is

00:20:02,500 --> 00:20:06,820
if you want to know more about protobuf

00:20:04,230 --> 00:20:09,370
then you can go onto YouTube have a look

00:20:06,820 --> 00:20:11,470
at my talk from last year on para buff

00:20:09,370 --> 00:20:14,620
it's pretty good give it give me a

00:20:11,470 --> 00:20:15,940
thumbs up and uh mmm I just want to

00:20:14,620 --> 00:20:17,440
remind you you know you've only got a

00:20:15,940 --> 00:20:19,630
limited number of chances to give

00:20:17,440 --> 00:20:25,299
someone a thumbs down in your life so

00:20:19,630 --> 00:20:27,130
don't give one to me okay all right so

00:20:25,299 --> 00:20:33,990
quickly running over to our protocol

00:20:27,130 --> 00:20:35,950
demo so here is our protocol server and

00:20:33,990 --> 00:20:38,080
what I've done is I've created a

00:20:35,950 --> 00:20:40,360
subclass of aceing Kyoto Protocol and

00:20:38,080 --> 00:20:44,640
it's got a couple of methods connection

00:20:40,360 --> 00:20:46,929
made write data received and then

00:20:44,640 --> 00:20:49,240
connection lost right so when we receive

00:20:46,929 --> 00:20:51,130
data we're going to read the length from

00:20:49,240 --> 00:20:54,120
the data and then we're going to use

00:20:51,130 --> 00:20:57,490
protobuf the underscore PB 2 is protobuf

00:20:54,120 --> 00:20:59,049
to deserialize our message and we're

00:20:57,490 --> 00:21:01,630
going to calculate a reply which is just

00:20:59,049 --> 00:21:04,179
the sum of of the message fields and

00:21:01,630 --> 00:21:08,830
we're going to use our transport to send

00:21:04,179 --> 00:21:13,230
a message back to the clients okay

00:21:08,830 --> 00:21:13,230
and if we have a look at the client

00:21:14,909 --> 00:21:18,100
there's the client so when the

00:21:16,840 --> 00:21:20,169
connection is made we're going to create

00:21:18,100 --> 00:21:22,299
a request we're going to send it to the

00:21:20,169 --> 00:21:24,250
other end by writing it to the transport

00:21:22,299 --> 00:21:29,200
and when we get a reply from the

00:21:24,250 --> 00:21:30,909
transport we'll print our answer now

00:21:29,200 --> 00:21:31,809
hopefully you can see right what's going

00:21:30,909 --> 00:21:34,090
to happen is it's going to send a

00:21:31,809 --> 00:21:35,559
message saying please add 3 & 4 for me

00:21:34,090 --> 00:21:38,200
the server is going to add 3 & 4 send a

00:21:35,559 --> 00:21:39,909
message back saying it's 7 and it'll

00:21:38,200 --> 00:21:42,520
print out the answer I'm running on time

00:21:39,909 --> 00:21:44,520
so I'll move on but hopefully you can

00:21:42,520 --> 00:21:49,179
see that that's what's going to happen

00:21:44,520 --> 00:21:53,080
so and how can we put this all together

00:21:49,179 --> 00:21:57,240
so at Optima we have a lot of programs

00:21:53,080 --> 00:21:59,530
that are reactive like the I think i/o

00:21:57,240 --> 00:22:01,840
reactive model that I was talking about

00:21:59,530 --> 00:22:03,490
earlier they receive information from

00:22:01,840 --> 00:22:05,559
somewhere they do something with it and

00:22:03,490 --> 00:22:08,679
they send information back or maybe they

00:22:05,559 --> 00:22:10,179
send it on to somewhere else and so

00:22:08,679 --> 00:22:13,929
we've got a lot of applications like

00:22:10,179 --> 00:22:16,600
this and so we've wanted to come up with

00:22:13,929 --> 00:22:18,070
a way of testing them and we're using a

00:22:16,600 --> 00:22:21,220
technology very similar to I think I owe

00:22:18,070 --> 00:22:23,290
to do that so imagine a very simple

00:22:21,220 --> 00:22:26,200
automatic teller machine app right

00:22:23,290 --> 00:22:29,140
really really contrived simple okay the

00:22:26,200 --> 00:22:31,810
the customer is going to request of our

00:22:29,140 --> 00:22:33,190
ATM that it make a deposit or withdrawal

00:22:31,810 --> 00:22:35,110
the ATM is going to send a message to

00:22:33,190 --> 00:22:38,050
the bank saying what's the balance in

00:22:35,110 --> 00:22:39,400
this person's account and and then the

00:22:38,050 --> 00:22:43,300
ATM is going to decide whether they can

00:22:39,400 --> 00:22:46,320
make their deposit or withdrawal so

00:22:43,300 --> 00:22:46,320
let's go and have a look at this

00:23:16,890 --> 00:23:22,809
okay so our protocol is really simple

00:23:20,530 --> 00:23:25,360
here's our protocol right we have a

00:23:22,809 --> 00:23:26,830
request from our customer basically

00:23:25,360 --> 00:23:29,110
asking either to make a deposit or

00:23:26,830 --> 00:23:30,400
withdrawal for a certain amount and we

00:23:29,110 --> 00:23:32,049
have a reply that indicates whether

00:23:30,400 --> 00:23:34,540
they're successful or not and what the

00:23:32,049 --> 00:23:36,220
remaining balance is and the protocol to

00:23:34,540 --> 00:23:38,020
the bank is also very simple we're going

00:23:36,220 --> 00:23:42,309
to send the customer ID to the bank and

00:23:38,020 --> 00:23:43,240
it's going to send back the balance now

00:23:42,309 --> 00:23:46,570
mmm

00:23:43,240 --> 00:23:49,090
the application itself right we don't

00:23:46,570 --> 00:23:51,070
need to know how that works forget time

00:23:49,090 --> 00:23:52,780
I'll show it to you but what I want to

00:23:51,070 --> 00:23:55,540
do is I want to test and see that it's

00:23:52,780 --> 00:23:58,270
working so how can I do that who's

00:23:55,540 --> 00:24:00,700
familiar with PI test yeah

00:23:58,270 --> 00:24:03,370
oh good most of you okay PI test great

00:24:00,700 --> 00:24:05,950
testing framework allows us to write

00:24:03,370 --> 00:24:08,470
unit tests that look a bit like this now

00:24:05,950 --> 00:24:10,360
I'm using PI test async IO to test my

00:24:08,470 --> 00:24:13,660
agent guy okay as you might expect and

00:24:10,360 --> 00:24:17,500
here you can see I've written a test

00:24:13,660 --> 00:24:19,870
method which is using our async a weight

00:24:17,500 --> 00:24:21,669
syntax and the first thing it's going to

00:24:19,870 --> 00:24:23,830
do is it's going to ask the client to

00:24:21,669 --> 00:24:25,900
send a request over withdrawal for Jane

00:24:23,830 --> 00:24:28,330
Doe and then it's going to get the

00:24:25,900 --> 00:24:29,590
results back after a while and it's

00:24:28,330 --> 00:24:31,600
going to check that the result was

00:24:29,590 --> 00:24:34,750
successful or not now I happen to know

00:24:31,600 --> 00:24:39,070
that James account balance has $100 in

00:24:34,750 --> 00:24:41,350
it so it should work and John's also

00:24:39,070 --> 00:24:43,570
should work but the anonymous person

00:24:41,350 --> 00:24:45,790
well they don't have enough money so

00:24:43,570 --> 00:24:47,710
that should not work now that looks

00:24:45,790 --> 00:24:49,960
pretty simple how did I may manage to

00:24:47,710 --> 00:25:00,010
make this all happen well all the magic

00:24:49,960 --> 00:25:02,020
is in contest okay so I have a couple of

00:25:00,010 --> 00:25:04,660
methods right at the top that are just

00:25:02,020 --> 00:25:07,900
reading the length field and the message

00:25:04,660 --> 00:25:09,669
from our a data stream or writing the

00:25:07,900 --> 00:25:11,290
link field and the message back into our

00:25:09,669 --> 00:25:14,080
data stream so that's just some

00:25:11,290 --> 00:25:16,540
convenience and here we go we've got our

00:25:14,080 --> 00:25:19,390
ATM client protocol this is the Boop's

00:25:16,540 --> 00:25:23,650
this is the client which is going to

00:25:19,390 --> 00:25:25,270
send a message to our ATM okay so when

00:25:23,650 --> 00:25:26,710
the connection is made we remember the

00:25:25,270 --> 00:25:29,470
transport that the connection was made

00:25:26,710 --> 00:25:30,230
with when we receive some message from

00:25:29,470 --> 00:25:32,080
the ATM

00:25:30,230 --> 00:25:36,080
which will be in response to our request

00:25:32,080 --> 00:25:38,950
we deserialize it and we're going to

00:25:36,080 --> 00:25:41,870
tell a future that the result is ready

00:25:38,950 --> 00:25:43,730
five minutes okay and in our send

00:25:41,870 --> 00:25:45,080
request method right we're going to

00:25:43,730 --> 00:25:46,520
create a request object we're going to

00:25:45,080 --> 00:25:49,100
set the field to the request object

00:25:46,520 --> 00:25:52,160
we're going to send the message on to

00:25:49,100 --> 00:25:54,920
the server the ATM and we're going to

00:25:52,160 --> 00:25:58,010
create a future right remember a future

00:25:54,920 --> 00:25:59,510
is just a promise that a result is going

00:25:58,010 --> 00:26:01,940
to be coming soon and we're going to

00:25:59,510 --> 00:26:03,890
send the future back to whoever called

00:26:01,940 --> 00:26:06,080
us so you can see what's going to happen

00:26:03,890 --> 00:26:07,940
right someone's going to send a request

00:26:06,080 --> 00:26:10,520
we're going to give them back the future

00:26:07,940 --> 00:26:14,810
and then when we get our data back from

00:26:10,520 --> 00:26:18,190
the ATM right we're going to tell the

00:26:14,810 --> 00:26:21,860
future that the result is ready and

00:26:18,190 --> 00:26:25,600
we'll get and and the hope is calling us

00:26:21,860 --> 00:26:29,300
we'll get our result now here is our

00:26:25,600 --> 00:26:31,370
server this is the server side so when

00:26:29,300 --> 00:26:32,510
we get the connection we just remember

00:26:31,370 --> 00:26:34,880
the transport that the connection was

00:26:32,510 --> 00:26:38,810
made with and then when we receive a

00:26:34,880 --> 00:26:41,330
request from the ATM we're going to

00:26:38,810 --> 00:26:44,570
extract the customer ID from the request

00:26:41,330 --> 00:26:49,780
we're going to create a reply and we're

00:26:44,570 --> 00:26:53,000
going to send it back okay now mmm

00:26:49,780 --> 00:26:56,060
whenever we start our test we're going

00:26:53,000 --> 00:26:59,180
to need a a bank server to be running so

00:26:56,060 --> 00:27:01,490
that the ATM can connect to it right so

00:26:59,180 --> 00:27:04,400
here's how we start up our Bank server

00:27:01,490 --> 00:27:05,900
we just use the create server method I

00:27:04,400 --> 00:27:09,080
told you about earlier to create a bank

00:27:05,900 --> 00:27:11,810
server we send it back into the test and

00:27:09,080 --> 00:27:15,560
then when the test is over we close the

00:27:11,810 --> 00:27:17,150
server okay and we're also going to need

00:27:15,560 --> 00:27:19,130
a client that's sorry we're also going

00:27:17,150 --> 00:27:21,890
to need the ATM process to be running

00:27:19,130 --> 00:27:25,880
right so here we're going to use sub

00:27:21,890 --> 00:27:28,970
process to create a sub process which is

00:27:25,880 --> 00:27:30,530
going to be our ATM program right we're

00:27:28,970 --> 00:27:32,900
gonna wait half a second so that it's

00:27:30,530 --> 00:27:34,610
ready okay because it takes a little

00:27:32,900 --> 00:27:37,400
while to startup and connect to the

00:27:34,610 --> 00:27:39,170
server send it back to the test right

00:27:37,400 --> 00:27:42,320
and then when the test is over we

00:27:39,170 --> 00:27:44,030
terminate our ATM process and lastly

00:27:42,320 --> 00:27:47,960
we're going to need a client

00:27:44,030 --> 00:27:49,550
right that connects to our ATM so we use

00:27:47,960 --> 00:27:50,870
our create connection method I told you

00:27:49,550 --> 00:27:53,090
about earlier right

00:27:50,870 --> 00:27:57,490
and that's going to be the client that

00:27:53,090 --> 00:28:01,310
the test can use to communicate with our

00:27:57,490 --> 00:28:03,680
ATM so if we go back to the tests you

00:28:01,310 --> 00:28:06,770
can see now that everything that's

00:28:03,680 --> 00:28:09,770
required for this test is right here in

00:28:06,770 --> 00:28:12,470
the one test framework right we've got

00:28:09,770 --> 00:28:15,020
the server the bank server we've got the

00:28:12,470 --> 00:28:18,860
ATM client and we've got a way of

00:28:15,020 --> 00:28:21,380
starting up our ATM process so for every

00:28:18,860 --> 00:28:24,890
test so now let me get rid of the file

00:28:21,380 --> 00:28:26,300
list there okay for every test we're

00:28:24,890 --> 00:28:28,430
going to start up the bank server we're

00:28:26,300 --> 00:28:30,890
going to start up the ATM process and

00:28:28,430 --> 00:28:33,530
start up the client send our request get

00:28:30,890 --> 00:28:36,500
our results and it all happens really

00:28:33,530 --> 00:28:40,460
simply and we can write as many of these

00:28:36,500 --> 00:28:58,760
tests as we like right so let me just

00:28:40,460 --> 00:29:00,440
see if I can get that to run for you I'm

00:28:58,760 --> 00:29:02,150
running to long time I can't figure this

00:29:00,440 --> 00:29:05,330
works but trust me it worked for me last

00:29:02,150 --> 00:29:07,430
night okay

00:29:05,330 --> 00:29:11,660
how am i doing my over I'm going to turn

00:29:07,430 --> 00:29:15,560
up yes okay so I'll just quickly show my

00:29:11,660 --> 00:29:16,880
last slide so this is what we've managed

00:29:15,560 --> 00:29:18,560
to achieve right we've got a test

00:29:16,880 --> 00:29:21,320
framework with both the server side and

00:29:18,560 --> 00:29:24,380
the client side starts up our ATM and

00:29:21,320 --> 00:29:26,930
runs as many tests as we need and so

00:29:24,380 --> 00:29:28,790
we're using async IO to test a whole

00:29:26,930 --> 00:29:30,110
other application which could have been

00:29:28,790 --> 00:29:33,740
written in any language I happen to

00:29:30,110 --> 00:29:35,720
write it in Python but it could have

00:29:33,740 --> 00:29:38,180
been written in any language we like we

00:29:35,720 --> 00:29:40,130
just fire it up and it connects to our

00:29:38,180 --> 00:29:42,920
server we connect to it from our clients

00:29:40,130 --> 00:29:48,490
and we run our tests so there you go a

00:29:42,920 --> 00:29:48,490
sink i/o you know nutshells okay

00:29:53,470 --> 00:29:57,559
thank you so you can find documentation

00:29:56,090 --> 00:29:59,960
in the Python standard library on the

00:29:57,559 --> 00:30:02,390
Python website check out especially the

00:29:59,960 --> 00:30:04,070
develop with a CI async i/o section

00:30:02,390 --> 00:30:06,500
which has got some some warnings and

00:30:04,070 --> 00:30:10,720
some gotchas in there to help you write

00:30:06,500 --> 00:30:10,720
your programs and time for questions

00:30:24,390 --> 00:30:31,789

YouTube URL: https://www.youtube.com/watch?v=3mb9jFAHRfw


