Title: Horrors of Distributed Systems
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Andrew Godwin

http://2017.pycon-au.org/schedule/presentation/52/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:03,179
it's really fun when you follow speakers

00:00:01,860 --> 00:00:04,950
on Twitter finding out they're going

00:00:03,179 --> 00:00:06,109
bungee jumping the day before they're

00:00:04,950 --> 00:00:12,630
supposed to be at your conference

00:00:06,109 --> 00:00:20,070
thankfully he survived and still smiling

00:00:12,630 --> 00:00:22,500
yes little bit tall andrew has a whole

00:00:20,070 --> 00:00:24,119
lot of words that I can't read um it's a

00:00:22,500 --> 00:00:26,970
member of the Django core team senior

00:00:24,119 --> 00:00:28,920
engineer at Eventbrite original author

00:00:26,970 --> 00:00:30,599
of the migrations framework and now he's

00:00:28,920 --> 00:00:32,099
down south to talk to us about the

00:00:30,599 --> 00:00:39,660
horrors of distributed systems let's

00:00:32,099 --> 00:00:41,820
make him feel welcome Thank You Katie

00:00:39,660 --> 00:00:43,140
and I do have video but I can refrain

00:00:41,820 --> 00:00:45,600
from showing you my whole date photos

00:00:43,140 --> 00:00:47,430
just yet so this talk is about

00:00:45,600 --> 00:00:50,039
distributed systems but a little more

00:00:47,430 --> 00:00:51,809
about myself first of all as Katie said

00:00:50,039 --> 00:00:53,399
I'm a django core developer and I work

00:00:51,809 --> 00:00:55,680
at Eventbrite on a lot of their back-end

00:00:53,399 --> 00:00:58,980
stuff people ask me what I do there

00:00:55,680 --> 00:01:01,410
basically everything from Django down

00:00:58,980 --> 00:01:03,329
databases back and stuff SOA

00:01:01,410 --> 00:01:05,430
architectural all that kind of stuff and

00:01:03,329 --> 00:01:08,460
more recently I do a lot of work on

00:01:05,430 --> 00:01:10,439
Django channels which is what I've

00:01:08,460 --> 00:01:12,960
become let's say infamous for in recent

00:01:10,439 --> 00:01:15,689
years and so what I wanted to do here

00:01:12,960 --> 00:01:17,939
like last year at django con Australia I

00:01:15,689 --> 00:01:19,110
can talk about channels this year wanted

00:01:17,939 --> 00:01:21,270
to give you a bit of a different talk

00:01:19,110 --> 00:01:25,049
and it's about the more general problem

00:01:21,270 --> 00:01:26,460
channels is part of a set of tools to

00:01:25,049 --> 00:01:28,619
solve a bigger problem of distributed

00:01:26,460 --> 00:01:30,210
systems I want to describe to you like

00:01:28,619 --> 00:01:32,220
some of the problems you encounter when

00:01:30,210 --> 00:01:34,860
designing those and things that when I

00:01:32,220 --> 00:01:36,600
was designing channels and some of the

00:01:34,860 --> 00:01:39,780
member write systems and SLA that you

00:01:36,600 --> 00:01:41,970
sort of start coming across so first of

00:01:39,780 --> 00:01:44,100
all they're really hard if anyone tells

00:01:41,970 --> 00:01:45,420
you that distribute systems are easy or

00:01:44,100 --> 00:01:47,520
they're plug-and-play

00:01:45,420 --> 00:01:49,409
or they can sell you on the box that's

00:01:47,520 --> 00:01:52,049
going to work like magic walk away from

00:01:49,409 --> 00:01:53,520
them they are lying to your face they

00:01:52,049 --> 00:01:54,210
are one of the hardest things in

00:01:53,520 --> 00:01:55,829
computer science

00:01:54,210 --> 00:01:59,070
apart from naming things and cache

00:01:55,829 --> 00:02:00,450
invalidation and all the other jokes but

00:01:59,070 --> 00:02:02,549
they're really nasty and so this talk is

00:02:00,450 --> 00:02:05,430
think I'm in two parts the first part is

00:02:02,549 --> 00:02:06,659
why can't you just hate you have myriad

00:02:05,430 --> 00:02:08,729
of ways in which they make your life

00:02:06,659 --> 00:02:09,780
hell and the second part is that we can

00:02:08,729 --> 00:02:12,840
turn these things you probably familiar

00:02:09,780 --> 00:02:14,060
with into problems in distributed

00:02:12,840 --> 00:02:17,520
systems in particular

00:02:14,060 --> 00:02:19,560
so let's start out with first particular

00:02:17,520 --> 00:02:21,900
thing which is non binary failure this

00:02:19,560 --> 00:02:23,400
is my personal favorite bugbear that I

00:02:21,900 --> 00:02:24,420
always try and catch a few new

00:02:23,400 --> 00:02:26,910
developers with they're sort of a

00:02:24,420 --> 00:02:28,830
slightly weird way but the idea is

00:02:26,910 --> 00:02:31,050
people believe that either something

00:02:28,830 --> 00:02:33,000
works or it doesn't work this is the

00:02:31,050 --> 00:02:35,160
wonderful world that as programmers we

00:02:33,000 --> 00:02:37,560
live in we're like well it's great like

00:02:35,160 --> 00:02:39,990
either my database is up

00:02:37,560 --> 00:02:42,240
I can query it or it's down I can't talk

00:02:39,990 --> 00:02:44,430
to it and I show an error page what you

00:02:42,240 --> 00:02:47,280
don't consider is that it's a spectrum

00:02:44,430 --> 00:02:49,140
there is at one end fully up there is

00:02:47,280 --> 00:02:50,820
other end fully down but there's many

00:02:49,140 --> 00:02:52,740
many things in between and so I'm gonna

00:02:50,820 --> 00:02:54,270
discuss a couple of those ways that come

00:02:52,740 --> 00:02:57,030
up in particular cases and why they're

00:02:54,270 --> 00:02:59,970
nasty so the first one that's very

00:02:57,030 --> 00:03:01,320
exciting is discs and RAM so hands up if

00:02:59,970 --> 00:03:04,320
you think when you write a file and read

00:03:01,320 --> 00:03:05,310
it back it's gonna be the same good

00:03:04,320 --> 00:03:08,450
you've all learned already

00:03:05,310 --> 00:03:11,010
oh no so one of the fun things about

00:03:08,450 --> 00:03:13,350
modern hard drives and SSDs in

00:03:11,010 --> 00:03:14,910
particular is that SSDs because the work

00:03:13,350 --> 00:03:16,890
the technology that makes them work is a

00:03:14,910 --> 00:03:18,420
little bit strange it involves electrons

00:03:16,890 --> 00:03:21,030
captured in quantum states and

00:03:18,420 --> 00:03:22,560
yadda-yadda what this what this means is

00:03:21,030 --> 00:03:24,420
they're quite susceptible to bit flips

00:03:22,560 --> 00:03:27,420
which is where one of the bits and a

00:03:24,420 --> 00:03:30,330
file flips from 0 to 1 or 1 to 0 after a

00:03:27,420 --> 00:03:32,670
certain amount of time and Esther SSDs

00:03:30,330 --> 00:03:35,190
do this very quickly normal hard drives

00:03:32,670 --> 00:03:37,380
is about 10 20 years or so it's quite a

00:03:35,190 --> 00:03:39,420
long time and if you keep them nice and

00:03:37,380 --> 00:03:43,140
cold it takes longer and longer but

00:03:39,420 --> 00:03:45,060
enterprise SSDs just a week on the shelf

00:03:43,140 --> 00:03:46,080
without power and there's a very high

00:03:45,060 --> 00:03:49,380
chance that have at least one bit

00:03:46,080 --> 00:03:50,850
flipped even consumer grade SSDs so like

00:03:49,380 --> 00:03:52,830
the enterprise ones they're hot the high

00:03:50,850 --> 00:03:54,870
speed one they flip more often the ones

00:03:52,830 --> 00:03:57,180
in your laptops leave them off for like

00:03:54,870 --> 00:03:58,350
3 to 6 months and at least a few of the

00:03:57,180 --> 00:04:01,020
bits and them will have flipped from 0

00:03:58,350 --> 00:04:03,330
to 1 which ones you don't know you can't

00:04:01,020 --> 00:04:06,330
work it out but some of them will of and

00:04:03,330 --> 00:04:07,740
so bit rot is real people and it happens

00:04:06,330 --> 00:04:10,440
and this is not just SSDs every

00:04:07,740 --> 00:04:12,960
technology has this SD cards and flash

00:04:10,440 --> 00:04:13,670
cards the same base technology have this

00:04:12,960 --> 00:04:16,320
as well

00:04:13,670 --> 00:04:17,970
cd-roms are much better for this like

00:04:16,320 --> 00:04:19,980
the longest kind of technology we have

00:04:17,970 --> 00:04:22,980
right now is blu-ray believe it or not a

00:04:19,980 --> 00:04:24,600
good blu-ray disc kept in a nice sealed

00:04:22,980 --> 00:04:26,900
thing will last about a century or two

00:04:24,600 --> 00:04:29,280
we think but even then it's not great

00:04:26,900 --> 00:04:32,070
but the other thing that's much more

00:04:29,280 --> 00:04:33,120
real is memory now often you're not

00:04:32,070 --> 00:04:34,770
writing things to disk and weave them

00:04:33,120 --> 00:04:37,530
back right away but you are using memory

00:04:34,770 --> 00:04:39,270
a lot and one of the big things you

00:04:37,530 --> 00:04:41,730
probably heard about ECC memory error

00:04:39,270 --> 00:04:43,590
correcting memory why do we have this

00:04:41,730 --> 00:04:45,000
why is it so expensive why do we need to

00:04:43,590 --> 00:04:47,370
make some money on it well it turns out

00:04:45,000 --> 00:04:49,140
there's a good reason Google did a big

00:04:47,370 --> 00:04:51,020
big load of research on the data center

00:04:49,140 --> 00:04:53,850
and they worked out that if you have

00:04:51,020 --> 00:04:56,520
non-ecc memory like you have on all your

00:04:53,850 --> 00:04:58,440
normal computers probably you get one

00:04:56,520 --> 00:05:00,000
bit flip per gigabyte roughly every two

00:04:58,440 --> 00:05:01,410
hours they have in a different unit I

00:05:00,000 --> 00:05:03,720
try to turn it for you here into more

00:05:01,410 --> 00:05:05,460
reasonable formats well that means is if

00:05:03,720 --> 00:05:08,490
you have a served with 32 gig of ram

00:05:05,460 --> 00:05:11,820
with non-ecc memory one of the bits and

00:05:08,490 --> 00:05:14,280
those 415 every four minutes it could be

00:05:11,820 --> 00:05:17,120
somebody's password hopefully not it

00:05:14,280 --> 00:05:19,350
makes it more secure though right

00:05:17,120 --> 00:05:21,480
it could be somebody's picture it could

00:05:19,350 --> 00:05:23,610
be something like a bank balance and so

00:05:21,480 --> 00:05:25,530
these are things like you can't just

00:05:23,610 --> 00:05:27,900
assume that file either is there or it's

00:05:25,530 --> 00:05:29,490
not there or even that like the checksum

00:05:27,900 --> 00:05:31,320
the you're using is correcting to make

00:05:29,490 --> 00:05:34,440
sure that like oh let's double and

00:05:31,320 --> 00:05:36,930
triple redundancies my favorite thing

00:05:34,440 --> 00:05:39,540
and this is the network so who here

00:05:36,930 --> 00:05:42,630
assumes that if they can't talk to the

00:05:39,540 --> 00:05:46,230
server the network is down you're

00:05:42,630 --> 00:05:47,640
learning too fast so a lot of people we

00:05:46,230 --> 00:05:50,040
have a health check the health return go

00:05:47,640 --> 00:05:51,780
I'm going to try and ping the server if

00:05:50,040 --> 00:05:52,980
we get a response from the server it

00:05:51,780 --> 00:05:54,960
being called up we're going to use the

00:05:52,980 --> 00:05:56,640
server if I don't get a response from

00:05:54,960 --> 00:05:58,110
the server it's going to be down and

00:05:56,640 --> 00:06:00,560
we're not going to use the server like

00:05:58,110 --> 00:06:03,810
well that's that's lovely that's great

00:06:00,560 --> 00:06:06,270
except of course when there is very high

00:06:03,810 --> 00:06:08,310
latency to the server let's say it's

00:06:06,270 --> 00:06:10,620
about a second or two latency your pings

00:06:08,310 --> 00:06:13,170
still return your code thinks it's there

00:06:10,620 --> 00:06:14,640
your website will try and run but you

00:06:13,170 --> 00:06:16,860
could try and do like lots of queries

00:06:14,640 --> 00:06:19,260
let's say you're doing a hundred SQL

00:06:16,860 --> 00:06:21,690
queries it's a bad move to start with on

00:06:19,260 --> 00:06:23,820
something usually like 10 milliseconds

00:06:21,690 --> 00:06:25,530
latency and it climbs to just 50 or 70

00:06:23,820 --> 00:06:27,630
milliseconds you also I can take this

00:06:25,530 --> 00:06:29,220
age is an age of surrender and this is

00:06:27,630 --> 00:06:32,970
one of the things that really get to you

00:06:29,220 --> 00:06:34,770
because it Cascades and has a bigger and

00:06:32,970 --> 00:06:36,570
bigger effect the further you go if

00:06:34,770 --> 00:06:38,040
you've got like a big service-oriented

00:06:36,570 --> 00:06:40,350
framework with lots of micro services

00:06:38,040 --> 00:06:40,680
and you've got a lot of deep queries

00:06:40,350 --> 00:06:42,870
through the

00:06:40,680 --> 00:06:44,880
micro-services this cascade effect

00:06:42,870 --> 00:06:47,820
amplifies each layer down you go for

00:06:44,880 --> 00:06:49,320
network is unreliable and there's other

00:06:47,820 --> 00:06:51,270
things too like packet loss and bad

00:06:49,320 --> 00:06:53,300
neighbors bad neighbors and particulars

00:06:51,270 --> 00:06:55,680
a big problem on things like AWS we're

00:06:53,300 --> 00:06:57,360
sure you have a virtual machine but the

00:06:55,680 --> 00:06:59,160
physical machine that your virtual

00:06:57,360 --> 00:07:00,960
machine is on is shared with other

00:06:59,160 --> 00:07:03,389
people and sometimes those people are

00:07:00,960 --> 00:07:04,919
very bad people and so it's common

00:07:03,389 --> 00:07:08,250
practice these days and some companies

00:07:04,919 --> 00:07:10,410
to just launch an ec2 instance test it

00:07:08,250 --> 00:07:12,720
see if it's good if it's not close it

00:07:10,410 --> 00:07:14,610
down find a new one tested again just to

00:07:12,720 --> 00:07:17,250
try and find good neighbors or a good

00:07:14,610 --> 00:07:19,740
machine and this is the case truth to

00:07:17,250 --> 00:07:21,660
with even Amazon's own stuff I think one

00:07:19,740 --> 00:07:24,840
of the outages they had many years ago

00:07:21,660 --> 00:07:28,470
now like five years ago with EBS was

00:07:24,840 --> 00:07:29,910
that their network backplane for EBS for

00:07:28,470 --> 00:07:32,130
the block storage for the file system

00:07:29,910 --> 00:07:33,509
was sort of weirdly shared with the

00:07:32,130 --> 00:07:34,620
incoming request stuff and it got

00:07:33,509 --> 00:07:36,810
overloaded and they just couldn't

00:07:34,620 --> 00:07:38,750
respond to file system requests because

00:07:36,810 --> 00:07:40,919
they were secretly Network requests

00:07:38,750 --> 00:07:43,710
packet loss is another puppy problem too

00:07:40,919 --> 00:07:46,710
as you are all experiencing here in this

00:07:43,710 --> 00:07:48,180
room with the Wi-Fi the packet loss is

00:07:46,710 --> 00:07:50,039
particularly nasty because it can be

00:07:48,180 --> 00:07:52,020
very variable you can have really good

00:07:50,039 --> 00:07:53,400
ping one second they can massively go

00:07:52,020 --> 00:07:55,190
away and lose it the next one and

00:07:53,400 --> 00:07:57,150
there's some very interesting bugs with

00:07:55,190 --> 00:07:59,550
networking in like oh there's a certain

00:07:57,150 --> 00:08:03,120
length and my favorite story of like oh

00:07:59,550 --> 00:08:04,440
I can only send emails 500 miles which

00:08:03,120 --> 00:08:05,760
is something having a very short like

00:08:04,440 --> 00:08:08,190
response time and like the actual

00:08:05,760 --> 00:08:12,690
physical length mattered and this comes

00:08:08,190 --> 00:08:15,090
on the ton in space so you I presume all

00:08:12,690 --> 00:08:18,000
deal in computers and it's wonderful and

00:08:15,090 --> 00:08:19,289
the real world is merely this thing that

00:08:18,000 --> 00:08:21,000
exists we have to live in and feed

00:08:19,289 --> 00:08:24,599
ourselves but computers are the big hot

00:08:21,000 --> 00:08:26,759
thing and as part of this we can happily

00:08:24,599 --> 00:08:29,039
ignore the laws of physics because what

00:08:26,759 --> 00:08:30,389
are they for anyway a load of scientists

00:08:29,039 --> 00:08:33,180
and their ivory towers talking about to

00:08:30,389 --> 00:08:35,610
be the speed of light and in particular

00:08:33,180 --> 00:08:37,320
the speed of light might not seem

00:08:35,610 --> 00:08:39,329
important to you is compete computers

00:08:37,320 --> 00:08:42,829
it's you're all local it's in a small

00:08:39,329 --> 00:08:46,320
box and mmm that's kind of true I mean

00:08:42,829 --> 00:08:48,839
it's not entirely true this is a very

00:08:46,320 --> 00:08:50,579
famous thing from Rear Admiral Grace

00:08:48,839 --> 00:08:53,490
Hopper she used to often ask for a

00:08:50,579 --> 00:08:54,450
nanosecond of wire this here is a

00:08:53,490 --> 00:08:57,710
nanosecond why

00:08:54,450 --> 00:08:59,850
it is the length of wire that a signal

00:08:57,710 --> 00:09:02,070
electrical signal will travel travel in

00:08:59,850 --> 00:09:04,560
one nanosecond electricity travels

00:09:02,070 --> 00:09:07,020
around 2/3 the speed of light in copper

00:09:04,560 --> 00:09:09,000
it varies by material but 2/3 is a good

00:09:07,020 --> 00:09:11,490
guess and most stuff and what this means

00:09:09,000 --> 00:09:13,950
is that let's say you've got one

00:09:11,490 --> 00:09:15,810
nanosecond here and you're trying to

00:09:13,950 --> 00:09:18,210
build a computer that has components

00:09:15,810 --> 00:09:19,560
more than that far apart if you're try

00:09:18,210 --> 00:09:20,910
and do a clock cycle that's more often

00:09:19,560 --> 00:09:22,770
in 1 nanosecond you can't do it

00:09:20,910 --> 00:09:25,500
physically can't get the signal along

00:09:22,770 --> 00:09:27,540
that piece of wire and this problem writ

00:09:25,500 --> 00:09:29,670
large is a problem in distributed

00:09:27,540 --> 00:09:31,800
systems you can't communicate with each

00:09:29,670 --> 00:09:33,420
other fast enough because the wires are

00:09:31,800 --> 00:09:35,790
longer I'm talking about long wires

00:09:33,420 --> 00:09:37,440
we're not we're in Australia and it

00:09:35,790 --> 00:09:40,350
turns out Australia is very far away

00:09:37,440 --> 00:09:41,700
from everything else I I got some

00:09:40,350 --> 00:09:44,070
scientists check this out they came back

00:09:41,700 --> 00:09:47,220
with some numbers for me so you can see

00:09:44,070 --> 00:09:48,660
here that Melbourne to us East one the

00:09:47,220 --> 00:09:51,540
most common a diverse region cuz it's

00:09:48,660 --> 00:09:53,760
the cheapest one it's roughly 16,000 k's

00:09:51,540 --> 00:09:56,670
give or take about a couple of hundred

00:09:53,760 --> 00:09:58,590
and this means at the speed of light and

00:09:56,670 --> 00:10:00,150
this is the speed of light not 2/3 like

00:09:58,590 --> 00:10:01,700
purely like who send a signal

00:10:00,150 --> 00:10:04,650
mysteriously curving around the earth

00:10:01,700 --> 00:10:06,180
over over to the west virginia 50

00:10:04,650 --> 00:10:08,400
milliseconds one way that means the

00:10:06,180 --> 00:10:11,400
minimal time according to the laws of

00:10:08,400 --> 00:10:14,130
physics ever is a hundred milliseconds

00:10:11,400 --> 00:10:17,370
now i open slack in a web browser

00:10:14,130 --> 00:10:19,050
it made ninety-six rep requests you can

00:10:17,370 --> 00:10:22,560
imagine how if that was talking to

00:10:19,050 --> 00:10:25,170
something in US east one it will take

00:10:22,560 --> 00:10:27,440
about 10 seconds to load and sure enough

00:10:25,170 --> 00:10:29,399
that's my experience

00:10:27,440 --> 00:10:31,290
but this is that this is a problem in

00:10:29,399 --> 00:10:33,300
general because if you are writing

00:10:31,290 --> 00:10:34,860
systems that are distributed it's one

00:10:33,300 --> 00:10:37,110
thing to have multiple servers or

00:10:34,860 --> 00:10:39,149
multiple nodes the next service when you

00:10:37,110 --> 00:10:41,279
go Geographic you have multiple

00:10:39,149 --> 00:10:42,839
datacenters in multiple countries like

00:10:41,279 --> 00:10:46,290
trying to make things agree around the

00:10:42,839 --> 00:10:47,700
world and what's happening like is one

00:10:46,290 --> 00:10:50,459
of the most difficult things to consider

00:10:47,700 --> 00:10:52,260
Eventbrite just now is looking at how do

00:10:50,459 --> 00:10:55,290
we start doing more regional and

00:10:52,260 --> 00:10:58,050
geographic data and it's like all of the

00:10:55,290 --> 00:10:59,730
senior engineers just going all the time

00:10:58,050 --> 00:11:03,600
because it's a really hard problem to

00:10:59,730 --> 00:11:05,610
think about and one of the secrets of

00:11:03,600 --> 00:11:07,769
distributed systems that they often

00:11:05,610 --> 00:11:09,660
don't tell you but it's a good secret is

00:11:07,769 --> 00:11:12,240
there is a very easy way to make them

00:11:09,660 --> 00:11:14,459
work and that is by having a nice wait

00:11:12,240 --> 00:11:17,010
period of consensus you build a system

00:11:14,459 --> 00:11:19,380
where all you do is you do an operation

00:11:17,010 --> 00:11:21,209
in different nodes you send information

00:11:19,380 --> 00:11:24,570
around and you try and wait for

00:11:21,209 --> 00:11:26,160
consensus you try and see oh you know

00:11:24,570 --> 00:11:28,529
so-and-so did this we can all agree and

00:11:26,160 --> 00:11:30,540
do stuff this is in fact how computers

00:11:28,529 --> 00:11:33,089
work internally like your computers have

00:11:30,540 --> 00:11:35,010
multiple cores on their processes those

00:11:33,089 --> 00:11:37,020
cores are separate computers but there

00:11:35,010 --> 00:11:39,120
had to be so close they can decide on

00:11:37,020 --> 00:11:41,670
consensus very quickly imagine taking

00:11:39,120 --> 00:11:44,130
those to multiple milliseconds apart and

00:11:41,670 --> 00:11:45,870
it gets longer and longer you can build

00:11:44,130 --> 00:11:47,970
a pretty good distributed system if you

00:11:45,870 --> 00:11:49,589
wait 20 seconds for each confirmation

00:11:47,970 --> 00:11:50,970
but your throughput is going to be

00:11:49,589 --> 00:11:52,950
absolutely terrible you may as well have

00:11:50,970 --> 00:11:58,260
somebody just waiting on pen and paper

00:11:52,950 --> 00:12:00,290
and putting postcards in the mail the

00:11:58,260 --> 00:12:02,970
other common fallacy that's always fun

00:12:00,290 --> 00:12:04,380
is that time is the same everywhere now

00:12:02,970 --> 00:12:06,270
not so about time zones those are

00:12:04,380 --> 00:12:09,899
terrible as well

00:12:06,270 --> 00:12:13,800
that's a whole separate talk time itself

00:12:09,899 --> 00:12:15,720
is all full and wrong so we have this

00:12:13,800 --> 00:12:18,950
this this human app heard of him Albert

00:12:15,720 --> 00:12:21,270
Einstein he was a scientist a while back

00:12:18,950 --> 00:12:24,990
he count thing called general relativity

00:12:21,270 --> 00:12:26,370
and what it means is in without doing a

00:12:24,990 --> 00:12:29,610
long visit lecture it means that in

00:12:26,370 --> 00:12:31,470
order to solve how the universe works we

00:12:29,610 --> 00:12:34,170
had have time dilation that time runs at

00:12:31,470 --> 00:12:35,850
different speeds everywhere and for a

00:12:34,170 --> 00:12:37,890
while it was thought to be theoretical

00:12:35,850 --> 00:12:40,649
and like it's a bit it's a bit weird and

00:12:37,890 --> 00:12:44,790
sci-fi and then we proved it not only do

00:12:40,649 --> 00:12:46,830
we prove it every day you have Hardware

00:12:44,790 --> 00:12:48,920
on you that deals a time dilation the

00:12:46,830 --> 00:12:51,060
GPS satellites in orbit around the Earth

00:12:48,920 --> 00:12:52,580
because they are further out of the

00:12:51,060 --> 00:12:55,140
gravitational pull of the earth

00:12:52,580 --> 00:12:57,029
experience a slightly different slow of

00:12:55,140 --> 00:13:01,020
time to us it runs very slightly I

00:12:57,029 --> 00:13:04,170
believe faster for them and so because

00:13:01,020 --> 00:13:06,839
GPS is based on sending you exact time

00:13:04,170 --> 00:13:08,160
signals I see the difference I'd like to

00:13:06,839 --> 00:13:09,360
send you time signals you work out how

00:13:08,160 --> 00:13:11,399
far away they are by how a long way to

00:13:09,360 --> 00:13:12,870
get to you you have to deal with time

00:13:11,399 --> 00:13:15,209
delay sure it's one of the big things

00:13:12,870 --> 00:13:18,959
and it's not just mysterious physics

00:13:15,209 --> 00:13:21,570
clocks are not accurate ever since the

00:13:18,959 --> 00:13:24,450
sixteen 1700s we started trying to make

00:13:21,570 --> 00:13:25,950
good naval clocks but the quest for an

00:13:24,450 --> 00:13:27,839
accurate clock has been ongoing it's

00:13:25,950 --> 00:13:30,000
really really difficult atomic clocks

00:13:27,839 --> 00:13:31,260
are very good but if you've seen one

00:13:30,000 --> 00:13:32,820
lately there's still like a briefcase

00:13:31,260 --> 00:13:35,190
sighs I'm not sure you want one of those

00:13:32,820 --> 00:13:38,279
to carry around and so your computer has

00:13:35,190 --> 00:13:40,829
probably a quartz oscillator it's pretty

00:13:38,279 --> 00:13:43,170
good but as the temperature changes the

00:13:40,829 --> 00:13:44,640
frequency of the quartz changes so you

00:13:43,170 --> 00:13:46,950
put a temperature sensor to try and

00:13:44,640 --> 00:13:48,630
correct for the temperature and you get

00:13:46,950 --> 00:13:51,120
pretty close but it's still a drift a

00:13:48,630 --> 00:13:54,540
little bit and what this means is you

00:13:51,120 --> 00:13:57,480
can't rely on someone's idea of time

00:13:54,540 --> 00:13:59,970
being aligned or even being the same

00:13:57,480 --> 00:14:01,890
speed as yours and this means a lot of

00:13:59,970 --> 00:14:04,050
problems you're like oh well if we were

00:14:01,890 --> 00:14:05,880
to society on what time is we can just

00:14:04,050 --> 00:14:08,310
have time stamps and ever went first

00:14:05,880 --> 00:14:09,600
wins that's a great idea to you realize

00:14:08,310 --> 00:14:12,240
that two people can both go first

00:14:09,600 --> 00:14:14,810
legitimately in different time-space

00:14:12,240 --> 00:14:16,580
frames and

00:14:14,810 --> 00:14:17,660
at some point you get like the weird

00:14:16,580 --> 00:14:19,550
problems of like you're in a ship and

00:14:17,660 --> 00:14:25,010
your twin brother is aging slower than

00:14:19,550 --> 00:14:27,470
you thankfully as programmers now this

00:14:25,010 --> 00:14:29,960
isn't a big problem for you but if any

00:14:27,470 --> 00:14:32,630
of you ever go to Mars you will have a

00:14:29,960 --> 00:14:34,070
big issue with this in particular so now

00:14:32,630 --> 00:14:36,440
I've given you sort of a brief tour of

00:14:34,070 --> 00:14:38,840
some of the more spectacular parts of

00:14:36,440 --> 00:14:40,820
all four bits computers let's talk about

00:14:38,840 --> 00:14:43,010
how it applies to actual distributed

00:14:40,820 --> 00:14:44,120
systems themselves and the most

00:14:43,010 --> 00:14:45,350
important thing and the thing that

00:14:44,120 --> 00:14:48,170
channels is built around is

00:14:45,350 --> 00:14:50,210
communication and it's what we all rely

00:14:48,170 --> 00:14:51,830
upon the internet servers are talking to

00:14:50,210 --> 00:14:55,070
each other just even in our computers

00:14:51,830 --> 00:14:57,470
processes talking to each other now as I

00:14:55,070 --> 00:14:59,870
said before networks are unreliable you

00:14:57,470 --> 00:15:02,450
cannot assume they will send anything at

00:14:59,870 --> 00:15:05,270
all in the right order as you sent it

00:15:02,450 --> 00:15:07,720
originally or even potentially that it

00:15:05,270 --> 00:15:10,940
arise after a percent in some cases and

00:15:07,720 --> 00:15:13,610
so it boils down to basically this

00:15:10,940 --> 00:15:15,410
choice and your choice is how do you

00:15:13,610 --> 00:15:18,410
acknowledge when messages are received

00:15:15,410 --> 00:15:20,060
and the choice is do you acknowledge

00:15:18,410 --> 00:15:22,250
them when you receive them but before

00:15:20,060 --> 00:15:24,050
you've worked on them or do you

00:15:22,250 --> 00:15:26,090
knowledge them when you receive them and

00:15:24,050 --> 00:15:29,540
worked on them and they're done and this

00:15:26,090 --> 00:15:32,330
choice boils down to this choice at most

00:15:29,540 --> 00:15:34,310
once or at least once if you ignore as a

00:15:32,330 --> 00:15:37,580
message as you receive it before the

00:15:34,310 --> 00:15:39,860
work is done you get a case where you

00:15:37,580 --> 00:15:42,890
can receive the message acknowledge it

00:15:39,860 --> 00:15:44,900
and then your machine dies and at this

00:15:42,890 --> 00:15:48,170
point you've got a pond with well we

00:15:44,900 --> 00:15:50,870
don't know it's finished and so we just

00:15:48,170 --> 00:15:54,110
have to go well we assume it's done

00:15:50,870 --> 00:15:56,000
we'll move on that is at most once your

00:15:54,110 --> 00:15:58,220
message either gets through because that

00:15:56,000 --> 00:16:00,440
didn't die in the process or it doesn't

00:15:58,220 --> 00:16:03,710
get through and so you just lose it to

00:16:00,440 --> 00:16:05,600
time the alternative is at the end we

00:16:03,710 --> 00:16:07,790
have a process that takes the message

00:16:05,600 --> 00:16:10,100
does all the processing and dies before

00:16:07,790 --> 00:16:11,510
it sends acknowledgement and then we

00:16:10,100 --> 00:16:14,000
didn't get the emotion once you send it

00:16:11,510 --> 00:16:14,930
again and again and this becomes at

00:16:14,000 --> 00:16:16,340
least once

00:16:14,930 --> 00:16:19,780
whatever your messages get back to on

00:16:16,340 --> 00:16:22,850
multiple times and this sort of basic

00:16:19,780 --> 00:16:24,650
separation that's not a binary is one of

00:16:22,850 --> 00:16:27,140
the key problems in communication in

00:16:24,650 --> 00:16:28,490
distributed systems but of course it's

00:16:27,140 --> 00:16:31,820
not a binary I told you that

00:16:28,490 --> 00:16:33,770
beginning it is more of a spectrum the

00:16:31,820 --> 00:16:37,160
more effort you put in the better you

00:16:33,770 --> 00:16:39,560
can get and people claim to get up here

00:16:37,160 --> 00:16:42,230
in particular quite recently

00:16:39,560 --> 00:16:45,470
Kafka put in a brand new system that

00:16:42,230 --> 00:16:47,510
gets very very very close to this with

00:16:45,470 --> 00:16:50,000
caveats it's like sort of it's exactly

00:16:47,510 --> 00:16:52,160
once asterisk asterisk asterisk and is

00:16:50,000 --> 00:16:54,230
like for certain applications that are

00:16:52,160 --> 00:16:56,990
definable on streams and idempotent and

00:16:54,230 --> 00:16:58,880
so on but if you're very cheap and don't

00:16:56,990 --> 00:17:01,209
really care you can live somewhere like

00:16:58,880 --> 00:17:03,819
here or here on the diagram like oh

00:17:01,209 --> 00:17:05,929
message sort of get through all the time

00:17:03,819 --> 00:17:08,420
but as you get more and more sort of

00:17:05,929 --> 00:17:10,429
enterprise-e and customers complain

00:17:08,420 --> 00:17:12,650
about things and downtime costs money

00:17:10,429 --> 00:17:15,010
you end up getting closer and closer to

00:17:12,650 --> 00:17:17,209
the middle and a lot of our research in

00:17:15,010 --> 00:17:19,400
distributed systems and messaging is how

00:17:17,209 --> 00:17:22,130
to get close to that middle section now

00:17:19,400 --> 00:17:25,010
what channel's does is it is on the left

00:17:22,130 --> 00:17:26,720
side of this graph it is on the at most

00:17:25,010 --> 00:17:28,970
one side which means that it will

00:17:26,720 --> 00:17:32,059
occasionally drop a message for you this

00:17:28,970 --> 00:17:34,190
is more because of the way that the

00:17:32,059 --> 00:17:36,230
things it was designed to run prefer

00:17:34,190 --> 00:17:38,570
that kind of thing and we think about

00:17:36,230 --> 00:17:40,640
what the operations are you think about

00:17:38,570 --> 00:17:43,429
that difference of at most once or at

00:17:40,640 --> 00:17:46,010
least once and the operations that are

00:17:43,429 --> 00:17:48,380
best suited for them are different so

00:17:46,010 --> 00:17:50,690
things like saving some updates to text

00:17:48,380 --> 00:17:52,429
or liking a tweet if you do them more

00:17:50,690 --> 00:17:54,980
than once that's fine you can hit like

00:17:52,429 --> 00:17:56,540
you know 10 times and tweak and we doses

00:17:54,980 --> 00:17:57,890
keep storing yes he likes it you

00:17:56,540 --> 00:18:00,679
definitely like say it's fine

00:17:57,890 --> 00:18:02,330
that's not really a problem and so in

00:18:00,679 --> 00:18:03,830
that case at least once it's perfectly

00:18:02,330 --> 00:18:05,660
fine that's the sort of stream of

00:18:03,830 --> 00:18:08,000
information that we can deduplicate or

00:18:05,660 --> 00:18:09,350
ignore or is what we call idempotent

00:18:08,000 --> 00:18:11,120
that doing the same thing twice

00:18:09,350 --> 00:18:13,220
doesn't have any more effect than the

00:18:11,120 --> 00:18:14,990
same thing once but there are other

00:18:13,220 --> 00:18:16,730
things we don't do them more than once

00:18:14,990 --> 00:18:18,860
in particular things we do at work like

00:18:16,730 --> 00:18:20,450
charging money to people people get a

00:18:18,860 --> 00:18:22,010
little bit shirty if you charge them

00:18:20,450 --> 00:18:23,270
three or four times like herbs Kafka's

00:18:22,010 --> 00:18:27,170
fault don't worry about us

00:18:23,270 --> 00:18:28,580
and so in in my case we were on the side

00:18:27,170 --> 00:18:31,220
of not doing it we'd much rather not

00:18:28,580 --> 00:18:32,929
charge somebody varies you know very

00:18:31,220 --> 00:18:34,820
occasionally then charge somebody twice

00:18:32,929 --> 00:18:36,530
very occasionally that's true things

00:18:34,820 --> 00:18:38,120
like sending email as well and again

00:18:36,530 --> 00:18:40,100
this is very much a choice of like what

00:18:38,120 --> 00:18:42,230
is your product what are you doing

00:18:40,100 --> 00:18:44,330
and of everybody we have two different

00:18:42,230 --> 00:18:46,940
systems for events one for each kind

00:18:44,330 --> 00:18:49,100
some things are at least once and some

00:18:46,940 --> 00:18:50,989
things are at most once channels powers

00:18:49,100 --> 00:18:54,619
the at most ones part Kafka powers the

00:18:50,989 --> 00:18:57,200
at least one spot the other part of

00:18:54,619 --> 00:19:00,080
distributive stuff is consensus and this

00:18:57,200 --> 00:19:01,970
is the hard Holy Grail part talking

00:19:00,080 --> 00:19:04,009
between computers is one thing making

00:19:01,970 --> 00:19:06,859
them agree like a roomful of programmers

00:19:04,009 --> 00:19:08,840
is a very different thing and not only

00:19:06,859 --> 00:19:11,480
they need to agree they need to agree

00:19:08,840 --> 00:19:13,460
over an unreliable network with

00:19:11,480 --> 00:19:15,350
unreliable storage and RAM remember it

00:19:13,460 --> 00:19:17,629
isn't always the same and different

00:19:15,350 --> 00:19:19,970
ideas of what their time is and this

00:19:17,629 --> 00:19:22,549
results in a problem that is so

00:19:19,970 --> 00:19:24,590
difficult that it's probably a whole

00:19:22,549 --> 00:19:26,749
separate company it is a whole separate

00:19:24,590 --> 00:19:28,279
conference by itself I'm not going to

00:19:26,749 --> 00:19:30,590
try and go through too much of it here

00:19:28,279 --> 00:19:32,149
but basically there's a thing called the

00:19:30,590 --> 00:19:34,850
two generals problem it's a very famous

00:19:32,149 --> 00:19:37,100
example in distributed computing and the

00:19:34,850 --> 00:19:39,200
idea is you have two generals on

00:19:37,100 --> 00:19:40,999
opposite hills and they're trying to

00:19:39,200 --> 00:19:42,889
send message to each other to decide

00:19:40,999 --> 00:19:44,989
when to attack the problem is between

00:19:42,889 --> 00:19:47,179
them is a hostile Network it's the enemy

00:19:44,989 --> 00:19:49,549
and so they try and send messengers

00:19:47,179 --> 00:19:51,289
through the net enemy and they might not

00:19:49,549 --> 00:19:52,730
get through they might get through they

00:19:51,289 --> 00:19:54,080
have no way of knowing you send them

00:19:52,730 --> 00:19:57,169
into the ether and you do you don't

00:19:54,080 --> 00:19:58,669
understand and you can show that it's

00:19:57,169 --> 00:20:01,850
basically impossible for them to decide

00:19:58,669 --> 00:20:03,619
on a time because of the unstable

00:20:01,850 --> 00:20:06,769
network you can't well did the mesh like

00:20:03,619 --> 00:20:09,440
get sent through was it right like how

00:20:06,769 --> 00:20:11,629
do we elect whose leader like if I if I

00:20:09,440 --> 00:20:13,249
send a message to Tim saying hey I want

00:20:11,629 --> 00:20:15,470
to attack at 10 a.m. and I get reply

00:20:13,249 --> 00:20:17,210
back slightly yes was that a No did they

00:20:15,470 --> 00:20:20,149
see it and so it becomes a really

00:20:17,210 --> 00:20:22,340
difficult problem and it's not just

00:20:20,149 --> 00:20:23,960
longing for big distributed systems it

00:20:22,340 --> 00:20:26,359
happened to you as well there are very

00:20:23,960 --> 00:20:28,460
real-world examples of distributive

00:20:26,359 --> 00:20:30,639
problems happening to small projects and

00:20:28,460 --> 00:20:33,350
a couple of my favorite examples here

00:20:30,639 --> 00:20:36,409
replicas lag so databases have

00:20:33,350 --> 00:20:38,090
replication lag so say you have a main

00:20:36,409 --> 00:20:40,519
database my C call or post careers

00:20:38,090 --> 00:20:42,649
whatever your fancy is and you have rep

00:20:40,519 --> 00:20:44,059
because of that database and the

00:20:42,649 --> 00:20:46,309
replicas because of the way that sort of

00:20:44,059 --> 00:20:48,710
consumed from the main database they run

00:20:46,309 --> 00:20:51,289
behind by you know ten milliseconds to a

00:20:48,710 --> 00:20:54,080
second it varies a little bit and let's

00:20:51,289 --> 00:20:56,210
say that what you want to do is you have

00:20:54,080 --> 00:20:58,760
some salary tasks that say in

00:20:56,210 --> 00:21:02,030
index new files you upload or like do

00:20:58,760 --> 00:21:04,790
thumbnailing and so you upload your file

00:21:02,030 --> 00:21:07,480
you right to the main database and you

00:21:04,790 --> 00:21:10,370
file salary tasks now if you're unlucky

00:21:07,480 --> 00:21:12,830
the salary task will pick up and run

00:21:10,370 --> 00:21:14,660
before the replica has got the copy of

00:21:12,830 --> 00:21:17,540
the changing made you can imagine that

00:21:14,660 --> 00:21:20,180
celery could do it in 10 milliseconds

00:21:17,540 --> 00:21:22,190
replication takes 100 milliseconds and

00:21:20,180 --> 00:21:25,160
then suddenly you've got your centerr

00:21:22,190 --> 00:21:27,230
each horse is running basically behind

00:21:25,160 --> 00:21:28,940
time it's like in the past as far as

00:21:27,230 --> 00:21:31,700
you're concerned and so the thing you

00:21:28,940 --> 00:21:33,620
you just saved isn't there this happens

00:21:31,700 --> 00:21:35,150
even outside systems like webhooks for

00:21:33,620 --> 00:21:36,980
example an event right we had a problem

00:21:35,150 --> 00:21:38,870
where we send webhooks

00:21:36,980 --> 00:21:40,340
you can say I want to have a web ebooks

00:21:38,870 --> 00:21:42,680
entity whenever I get a new ticket sold

00:21:40,340 --> 00:21:45,110
for example and we had this whole system

00:21:42,680 --> 00:21:49,370
done it was really great built by me of

00:21:45,110 --> 00:21:50,720
course but maintained by my colleague

00:21:49,370 --> 00:21:54,680
Bartek who is much better at than I am

00:21:50,720 --> 00:21:57,650
and it was so fast that it was sending

00:21:54,680 --> 00:21:59,270
web hooks before the replication lag had

00:21:57,650 --> 00:22:01,160
happened and replication lag and

00:21:59,270 --> 00:22:04,640
Eventbrite is usually under a second but

00:22:01,160 --> 00:22:06,290
acacia - and big on sale cases and we

00:22:04,640 --> 00:22:07,730
were getting cases where people were

00:22:06,290 --> 00:22:09,980
getting sent the webhook they were

00:22:07,730 --> 00:22:12,200
receiving it sending us an API request

00:22:09,980 --> 00:22:14,150
and getting API response given to them

00:22:12,200 --> 00:22:16,400
before the replication had happened

00:22:14,150 --> 00:22:17,930
everything was working that fast and you

00:22:16,400 --> 00:22:20,540
just can't solve that you can't pin

00:22:17,930 --> 00:22:22,520
things in that situation the other thing

00:22:20,540 --> 00:22:24,650
is things like time stamps it's very

00:22:22,520 --> 00:22:26,450
common to say oh we're gonna put some

00:22:24,650 --> 00:22:28,640
time stamps in these into these database

00:22:26,450 --> 00:22:31,520
rows to decide that the global ordering

00:22:28,640 --> 00:22:34,220
now I may imagine before time is not a

00:22:31,520 --> 00:22:36,920
thing time is merely a concept box in my

00:22:34,220 --> 00:22:39,140
philosophy philosophy lecture and so if

00:22:36,920 --> 00:22:40,970
you put time stamps in there roughly

00:22:39,140 --> 00:22:42,980
agree as long as you're okay with that

00:22:40,970 --> 00:22:44,990
you're fine if you aren't absolute

00:22:42,980 --> 00:22:46,610
ordering you have to have a central time

00:22:44,990 --> 00:22:48,560
source a single serve you send it all

00:22:46,610 --> 00:22:50,600
through a common way of doing this in

00:22:48,560 --> 00:22:52,190
Django is having the database write time

00:22:50,600 --> 00:22:53,960
stamps rather than your application

00:22:52,190 --> 00:22:57,110
because often your application is on

00:22:53,960 --> 00:22:58,370
four or five or ten or 50 machines with

00:22:57,110 --> 00:23:00,770
different clocks and different speeds

00:22:58,370 --> 00:23:02,330
but your database often has one master

00:23:00,770 --> 00:23:03,890
database and that's the one that you

00:23:02,330 --> 00:23:07,160
should use the time time stamps on the

00:23:03,890 --> 00:23:10,380
clock from this is one of the sort of

00:23:07,160 --> 00:23:13,950
many things about engineering right it's

00:23:10,380 --> 00:23:16,890
fast cheap and good pick any two if you

00:23:13,950 --> 00:23:18,630
want all three then you're completely

00:23:16,890 --> 00:23:20,340
delusional and this happens to in

00:23:18,630 --> 00:23:22,110
distributed systems and one of most

00:23:20,340 --> 00:23:25,230
common things here is databases we have

00:23:22,110 --> 00:23:28,050
what's called the see a P theorem which

00:23:25,230 --> 00:23:30,500
says that database or data store in

00:23:28,050 --> 00:23:33,300
general can be any two of these three

00:23:30,500 --> 00:23:35,790
consistent available or partition

00:23:33,300 --> 00:23:37,350
tolerant that is consistency is that if

00:23:35,790 --> 00:23:38,670
you ask different machines are the same

00:23:37,350 --> 00:23:40,890
database they'll give you the same

00:23:38,670 --> 00:23:41,940
answer available is if you ask some

00:23:40,890 --> 00:23:44,100
machine it's we're going to give you an

00:23:41,940 --> 00:23:45,960
answer and partition tolerance if you

00:23:44,100 --> 00:23:48,059
take machines divide the network and

00:23:45,960 --> 00:23:50,460
join up again data isn't destroyed in

00:23:48,059 --> 00:23:52,650
the process you usually always want

00:23:50,460 --> 00:23:55,260
partition tolerant otherwise whenever

00:23:52,650 --> 00:23:57,059
you have a network separation stuff just

00:23:55,260 --> 00:23:58,950
vanishes it's not a great solution for

00:23:57,059 --> 00:24:00,840
most data and so your choice ends up

00:23:58,950 --> 00:24:02,640
usually being consistent or available

00:24:00,840 --> 00:24:05,400
which is do you want it to always be

00:24:02,640 --> 00:24:07,500
there and not always agree with you what

00:24:05,400 --> 00:24:08,460
you want you to always agree but not

00:24:07,500 --> 00:24:10,710
always be there

00:24:08,460 --> 00:24:13,260
Postgres is usually considered to be

00:24:10,710 --> 00:24:15,750
consistent and something like say

00:24:13,260 --> 00:24:18,179
Cassandra will be always available like

00:24:15,750 --> 00:24:19,350
you can read two different servers in

00:24:18,179 --> 00:24:20,730
Cassandra for the same key and get

00:24:19,350 --> 00:24:25,559
different values back for a short period

00:24:20,730 --> 00:24:26,640
and this is one of the things like all

00:24:25,559 --> 00:24:29,070
of distribute stuff is full of

00:24:26,640 --> 00:24:30,330
trade-offs and I only have half an hour

00:24:29,070 --> 00:24:32,010
I can't give you a full rundown of what

00:24:30,330 --> 00:24:34,050
to do but I'm gonna try and give you a

00:24:32,010 --> 00:24:35,460
few tips around like how to think about

00:24:34,050 --> 00:24:37,740
these systems and way to start looking

00:24:35,460 --> 00:24:38,850
if you find yourself talking to problems

00:24:37,740 --> 00:24:41,880
that look like these kind of problems

00:24:38,850 --> 00:24:44,460
what to start thinking about so first of

00:24:41,880 --> 00:24:47,250
all the most important thing is defining

00:24:44,460 --> 00:24:49,800
interfaces clearly it is easiest to

00:24:47,250 --> 00:24:51,630
think about a distributed system what it

00:24:49,800 --> 00:24:53,370
is inseparable components when you can

00:24:51,630 --> 00:24:56,309
reason about components by themselves

00:24:53,370 --> 00:24:58,410
and then just take them in as a black

00:24:56,309 --> 00:25:01,020
box zoom out and sort of how they

00:24:58,410 --> 00:25:03,480
interact if you have a million lines of

00:25:01,020 --> 00:25:05,550
code with art with no clearly defined

00:25:03,480 --> 00:25:08,220
boundaries you're gonna have a hell of a

00:25:05,550 --> 00:25:10,950
time trying to debug it if you have ten

00:25:08,220 --> 00:25:13,620
pieces of nicely compartmentalized codes

00:25:10,950 --> 00:25:15,030
that have defined interfaces working out

00:25:13,620 --> 00:25:17,130
what the problem is is much much easier

00:25:15,030 --> 00:25:19,410
and a big part of all the design of

00:25:17,130 --> 00:25:20,940
these big systems is how do I separate

00:25:19,410 --> 00:25:22,410
these things down how do I make

00:25:20,940 --> 00:25:23,309
components and make them talk to each

00:25:22,410 --> 00:25:25,169
other

00:25:23,309 --> 00:25:26,639
be things that channels is making it

00:25:25,169 --> 00:25:28,320
easier for things to talk to each other

00:25:26,639 --> 00:25:30,059
and understand like hey I'm passing

00:25:28,320 --> 00:25:32,039
messages around I want to do this over

00:25:30,059 --> 00:25:35,730
here and having Django be one of those

00:25:32,039 --> 00:25:37,950
parts the other thing I've mentioned in

00:25:35,730 --> 00:25:39,990
a couple slides before is that Chroniton

00:25:37,950 --> 00:25:41,669
design is a big part of this when you're

00:25:39,990 --> 00:25:44,190
making trade-offs what are the

00:25:41,669 --> 00:25:46,230
trade-offs you get to make is how your

00:25:44,190 --> 00:25:48,720
application is designed it might be the

00:25:46,230 --> 00:25:50,610
case that there's a very small tweak in

00:25:48,720 --> 00:25:52,529
the desire like if we don't show an

00:25:50,610 --> 00:25:54,899
accurate user count here we can save

00:25:52,529 --> 00:25:56,070
like 10 seconds on the back end and the

00:25:54,899 --> 00:25:58,139
best thing to do is work with your

00:25:56,070 --> 00:25:59,940
team's product managers and designers

00:25:58,139 --> 00:26:02,159
anyone else who's involved in those

00:25:59,940 --> 00:26:04,289
decisions and have a holistic approach

00:26:02,159 --> 00:26:06,210
to just trying to solve the whole

00:26:04,289 --> 00:26:08,460
problem like have everyone sit in a room

00:26:06,210 --> 00:26:10,499
and work out how he can best solve these

00:26:08,460 --> 00:26:13,259
things in one big go I've seen

00:26:10,499 --> 00:26:15,240
situations where you know we've got a

00:26:13,259 --> 00:26:17,580
design through and the design would be

00:26:15,240 --> 00:26:19,769
near impossible to implement as it is

00:26:17,580 --> 00:26:22,409
but a couple of the mall tweaks and it's

00:26:19,769 --> 00:26:23,519
like doable in about a week that's sort

00:26:22,409 --> 00:26:25,909
of stuff where you can sit there and go

00:26:23,519 --> 00:26:28,740
like well do we need to show somebody

00:26:25,909 --> 00:26:30,029
this thing straightaway if we don't we

00:26:28,740 --> 00:26:32,789
can be inconsistent do we need to show

00:26:30,029 --> 00:26:34,950
them this thing you know do we just give

00:26:32,789 --> 00:26:35,940
them a particular value so your example

00:26:34,950 --> 00:26:38,039
the web ebooks example I told you

00:26:35,940 --> 00:26:40,259
earlier what we're going to do what

00:26:38,039 --> 00:26:42,990
we're doing is you're delaying on Web

00:26:40,259 --> 00:26:44,399
books by five seconds because you don't

00:26:42,990 --> 00:26:46,470
care if you get it like five seconds

00:26:44,399 --> 00:26:47,970
late but we know how long our

00:26:46,470 --> 00:26:49,799
replication lag is and so if we just

00:26:47,970 --> 00:26:52,139
give you the web book five seconds late

00:26:49,799 --> 00:26:53,789
you come through to the API and it's

00:26:52,139 --> 00:26:56,220
solved that's the case with that the

00:26:53,789 --> 00:26:57,990
product design is changed sure but it's

00:26:56,220 --> 00:26:59,490
perfectly fine we ask people they

00:26:57,990 --> 00:27:01,230
they're happy with it it's still pretty

00:26:59,490 --> 00:27:03,179
fast for them and it made the

00:27:01,230 --> 00:27:05,070
engineering much simpler it's like one

00:27:03,179 --> 00:27:06,539
it's literally like a time door sleep in

00:27:05,070 --> 00:27:08,369
there basically it's much much easier to

00:27:06,539 --> 00:27:11,539
do than like oh this crazy system of

00:27:08,369 --> 00:27:14,700
synchronizing and pinning and finally

00:27:11,539 --> 00:27:18,450
don't reinvent the wheel now I know I'm

00:27:14,700 --> 00:27:21,090
I in Vice susceptibility myself it's

00:27:18,450 --> 00:27:22,710
great to go it's a really hard problem I

00:27:21,090 --> 00:27:26,039
just write one from scratch be so clean

00:27:22,710 --> 00:27:27,809
and lovely and sure you could do that

00:27:26,039 --> 00:27:29,940
and I encourage you to release try it

00:27:27,809 --> 00:27:31,470
because you'll learn a lot trying it but

00:27:29,940 --> 00:27:36,389
don't try it and then use it in

00:27:31,470 --> 00:27:37,200
production try it on your own time to do

00:27:36,389 --> 00:27:39,210
your own stuff with

00:27:37,200 --> 00:27:41,190
because that's the way you sort of learn

00:27:39,210 --> 00:27:43,350
and grow like I used to do things like

00:27:41,190 --> 00:27:45,180
make Minecraft servers to try and learn

00:27:43,350 --> 00:27:47,370
about like high volume networking stuff

00:27:45,180 --> 00:27:48,840
because like some point nobody really

00:27:47,370 --> 00:27:51,660
cares it goes down to five minutes

00:27:48,840 --> 00:27:53,280
and distributed in a particular is for

00:27:51,660 --> 00:27:55,470
the really hard problems some of the

00:27:53,280 --> 00:27:57,420
greatest minds of computing and working

00:27:55,470 --> 00:27:59,310
on solving like consensus and

00:27:57,420 --> 00:28:01,320
communication and how to have agreement

00:27:59,310 --> 00:28:02,850
and there are algorithms for this that

00:28:01,320 --> 00:28:04,320
are long and complicated and if you do

00:28:02,850 --> 00:28:06,510
one part of them wrong and the whole

00:28:04,320 --> 00:28:08,790
thing blows up in your face and so

00:28:06,510 --> 00:28:12,240
unless you are feeling particularly say

00:28:08,790 --> 00:28:13,800
I'd no self flagellation don't reinvent

00:28:12,240 --> 00:28:15,600
it go and find the software that works

00:28:13,800 --> 00:28:18,180
go and build on things like you know

00:28:15,600 --> 00:28:20,880
Cassandra or react or writers cluster of

00:28:18,180 --> 00:28:24,180
us your sort of thing and you can take

00:28:20,880 --> 00:28:26,400
things underneath build on them and if

00:28:24,180 --> 00:28:27,690
you do become big scale if you do become

00:28:26,400 --> 00:28:31,140
a big site that has its own specialized

00:28:27,690 --> 00:28:32,640
problems then you can go back take that

00:28:31,140 --> 00:28:35,130
bottom layer and make it more

00:28:32,640 --> 00:28:38,370
specialized but most of you are never

00:28:35,130 --> 00:28:40,680
going to be Google or Facebook or any of

00:28:38,370 --> 00:28:44,430
the big sites and so don't try and make

00:28:40,680 --> 00:28:48,150
your own magical databases tributed if

00:28:44,430 --> 00:28:52,020
you if you do good luck and that's it so

00:28:48,150 --> 00:28:53,250
yeah basically they're hard I hope you

00:28:52,020 --> 00:28:55,250
learned a little bit about what to do

00:28:53,250 --> 00:29:05,470
with them and thank you very much

00:28:55,250 --> 00:29:10,850
[Applause]

00:29:05,470 --> 00:29:14,299
hello hello if I have enough lag will

00:29:10,850 --> 00:29:17,030
this work yes

00:29:14,299 --> 00:29:24,569
thank you very much

00:29:17,030 --> 00:29:24,569

YouTube URL: https://www.youtube.com/watch?v=jx1Hkxe64Xs


