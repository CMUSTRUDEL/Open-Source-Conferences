Title: Remote DNA Sequencing and Analysis; Nanopore sequencing, FPGA boards and a fortunate Epiphany
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Alexis Lucattini

http://2017.pycon-au.org/schedule/presentation/73/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:02,700
things you didn't a few years ago you

00:00:01,170 --> 00:00:05,520
wouldn't have thought that the Python

00:00:02,700 --> 00:00:08,429
would have been involved in creating so

00:00:05,520 --> 00:00:10,830
our next speaker is Alexis Luca tini

00:00:08,429 --> 00:00:13,530
he's with the Australian genome research

00:00:10,830 --> 00:00:15,480
facility and when we first saw the topic

00:00:13,530 --> 00:00:17,699
for this talk we were fascinated that

00:00:15,480 --> 00:00:19,050
Python was going to be involved so I'm

00:00:17,699 --> 00:00:26,039
sure it'll be a really interesting talk

00:00:19,050 --> 00:00:29,099
please welcome Alexis hey guys I've

00:00:26,039 --> 00:00:32,880
created this using are actually just to

00:00:29,099 --> 00:00:35,430
stir things up a little bit it works

00:00:32,880 --> 00:00:37,649
through our third-party cords ringin

00:00:35,430 --> 00:00:38,969
so I have and I've posted them to

00:00:37,649 --> 00:00:42,390
Twitter as well so you should be able to

00:00:38,969 --> 00:00:43,500
see my Twitter account up there and so

00:00:42,390 --> 00:00:45,030
if you press pay you enter the

00:00:43,500 --> 00:00:46,350
presentation note and you'll see what

00:00:45,030 --> 00:00:48,059
I'm seeing here where you'll see

00:00:46,350 --> 00:00:50,670
otherwise what's on the slides here so

00:00:48,059 --> 00:00:53,660
yeah my name is Alexis I did my bachelor

00:00:50,670 --> 00:00:56,670
of biomedicine at Melbourne University

00:00:53,660 --> 00:00:59,219
all my friends did med didn't really

00:00:56,670 --> 00:01:01,980
think that as an option didn't get into

00:00:59,219 --> 00:01:04,519
med took a hell of passion for computers

00:01:01,980 --> 00:01:07,200
so went into masters of bioinformatics

00:01:04,519 --> 00:01:10,439
we did a research component there where

00:01:07,200 --> 00:01:12,299
I worked at the AG RF on a little mini

00:01:10,439 --> 00:01:14,909
iron which is a DNA sequencer that I'll

00:01:12,299 --> 00:01:16,170
get into very shortly and now I'm

00:01:14,909 --> 00:01:18,509
actually working at this Jen genome

00:01:16,170 --> 00:01:21,150
research facility full time where I

00:01:18,509 --> 00:01:23,040
spend a bit at that time also playing

00:01:21,150 --> 00:01:25,320
around with the mid iron and also

00:01:23,040 --> 00:01:28,110
working through our an ASIC data and

00:01:25,320 --> 00:01:32,100
also debugging old Perl code which is so

00:01:28,110 --> 00:01:34,079
much fun isn't it so we're going to talk

00:01:32,100 --> 00:01:36,090
today about the min I'm not the one on

00:01:34,079 --> 00:01:39,000
the right here but actually this little

00:01:36,090 --> 00:01:41,729
device here which is a little DNA

00:01:39,000 --> 00:01:44,250
sequencer DNA sequences themselves are

00:01:41,729 --> 00:01:46,350
generally the size of massive computers

00:01:44,250 --> 00:01:48,600
so we'll we'll talk about that very soon

00:01:46,350 --> 00:01:50,790
the complexities in base culling so

00:01:48,600 --> 00:01:52,500
that's inferring the analog electrical

00:01:50,790 --> 00:01:56,610
data that you get off of mean iron into

00:01:52,500 --> 00:01:59,189
CA GS and T's that make up who we are

00:01:56,610 --> 00:02:02,040
a very short introduction onto FPGAs if

00:01:59,189 --> 00:02:03,450
you here for the last talk it's nothing

00:02:02,040 --> 00:02:07,190
like that at all

00:02:03,450 --> 00:02:09,770
I really don't know much about FPGAs and

00:02:07,190 --> 00:02:12,599
doing this I still do really don't and

00:02:09,770 --> 00:02:13,660
and will also talk about the parallel

00:02:12,599 --> 00:02:17,410
aboard which is the

00:02:13,660 --> 00:02:20,710
little device here similar to your

00:02:17,410 --> 00:02:28,930
little high boards as well this one was

00:02:20,710 --> 00:02:30,160
created by adapt IVA in 2014 so first of

00:02:28,930 --> 00:02:32,200
all the minion which I showed it before

00:02:30,160 --> 00:02:34,530
it's the world's first portable DNA

00:02:32,200 --> 00:02:36,520
sequencer it's gained a lot of traction

00:02:34,530 --> 00:02:37,270
particularly on the Twittersphere the

00:02:36,520 --> 00:02:39,280
internet-of-things

00:02:37,270 --> 00:02:41,770
sphere particularly because of its low

00:02:39,280 --> 00:02:44,080
capital cost and very easy library

00:02:41,770 --> 00:02:45,520
preparation so preparing the DNA such

00:02:44,080 --> 00:02:47,890
that you can actually put it and load it

00:02:45,520 --> 00:02:49,870
onto this machine people have done it on

00:02:47,890 --> 00:02:52,240
Ted as well where they've just grabbed a

00:02:49,870 --> 00:02:54,220
couple of pets and done it and you can

00:02:52,240 --> 00:02:55,930
really do the library prep itself all it

00:02:54,220 --> 00:02:58,900
requires is for pets and a little micro

00:02:55,930 --> 00:03:00,910
spinning fuge to spin down liquids it

00:02:58,900 --> 00:03:03,510
was founded by an excellent employee

00:03:00,910 --> 00:03:06,340
eliminar the main DNA sequencing

00:03:03,510 --> 00:03:08,640
facility gurus in the world they own 90%

00:03:06,340 --> 00:03:13,120
of the share of the sequencing market

00:03:08,640 --> 00:03:18,459
and they're not friends anymore anyway

00:03:13,120 --> 00:03:21,690
let's just go so how does this work so

00:03:18,459 --> 00:03:24,280
at a very micro level here on the side

00:03:21,690 --> 00:03:26,860
unfortunately doesn't like to embed

00:03:24,280 --> 00:03:30,459
videos too easily so this is actually

00:03:26,860 --> 00:03:32,500
itself a link to another video so at the

00:03:30,459 --> 00:03:34,959
micro level here what we have is we have

00:03:32,500 --> 00:03:37,510
DNA which is negatively charged going

00:03:34,959 --> 00:03:38,650
from a negative we have a voltage going

00:03:37,510 --> 00:03:40,959
so it's wanting to go to the positive

00:03:38,650 --> 00:03:42,430
side similar to maybe gel

00:03:40,959 --> 00:03:44,770
electrophoresis you might have done in

00:03:42,430 --> 00:03:47,770
high school and as it goes through this

00:03:44,770 --> 00:03:49,840
pore it creates because it's negative

00:03:47,770 --> 00:03:52,360
negatively charged it creates a current

00:03:49,840 --> 00:03:55,030
and each nucleotide is slightly

00:03:52,360 --> 00:03:56,650
different in the way it's chemical

00:03:55,030 --> 00:03:58,450
composition and so each of them gives

00:03:56,650 --> 00:04:01,030
off a slightly different charge as we

00:03:58,450 --> 00:04:04,870
see down here it's not quite as simple

00:04:01,030 --> 00:04:06,880
as what we we've got there and we'll

00:04:04,870 --> 00:04:08,800
talk about that that's soon but it does

00:04:06,880 --> 00:04:12,959
provide a few other benefits that other

00:04:08,800 --> 00:04:12,959
sequencing technologies do not

00:04:15,480 --> 00:04:19,889
oh this is my first our studio slide

00:04:17,669 --> 00:04:22,079
presentation as well so the main

00:04:19,889 --> 00:04:25,020
benefits the low capital cost the fast

00:04:22,079 --> 00:04:27,240
library prep it's portable as well which

00:04:25,020 --> 00:04:29,580
is pretty cool so this is founded by a

00:04:27,240 --> 00:04:33,180
group in Birmingham who are the real

00:04:29,580 --> 00:04:35,610
main frontiers of nanopore sequencing so

00:04:33,180 --> 00:04:38,760
they went around Brazil during the xik

00:04:35,610 --> 00:04:41,100
of viral outbreak tracking the Zika

00:04:38,760 --> 00:04:44,180
virus and at the DNA in testing and

00:04:41,100 --> 00:04:48,150
seeing how quickly this virus mutating

00:04:44,180 --> 00:04:50,070
and that can answer questions down the

00:04:48,150 --> 00:04:51,270
line being like does a vaccine gonna be

00:04:50,070 --> 00:04:52,889
worth it or is it going to be something

00:04:51,270 --> 00:04:54,510
like HIV where we'll never really be

00:04:52,889 --> 00:04:56,669
able to develop a vaccine because of its

00:04:54,510 --> 00:04:57,690
rate of mutations so that was really

00:04:56,669 --> 00:05:01,229
cool and that's something that could

00:04:57,690 --> 00:05:06,120
really only be done in real time with a

00:05:01,229 --> 00:05:08,310
nanopore sequencer but there are some

00:05:06,120 --> 00:05:12,510
huge limitations to this still compared

00:05:08,310 --> 00:05:14,820
to say Illumina the accuracy of our base

00:05:12,510 --> 00:05:18,780
calling is only around about eighty-five

00:05:14,820 --> 00:05:20,490
percent the yields of it really really

00:05:18,780 --> 00:05:22,500
slow as well I mean you're not gonna be

00:05:20,490 --> 00:05:24,750
able to cover only now can we really

00:05:22,500 --> 00:05:27,030
start to cover a whole human genome and

00:05:24,750 --> 00:05:29,070
only once Illumina technology will

00:05:27,030 --> 00:05:31,169
easily do this 30 times or so for

00:05:29,070 --> 00:05:33,360
consensus and accuracy that's really

00:05:31,169 --> 00:05:37,260
what we're after so per yield as well

00:05:33,360 --> 00:05:38,910
it's also very expensive and as we'll

00:05:37,260 --> 00:05:41,520
discuss soon the portability of it this

00:05:38,910 --> 00:05:44,990
sequencing machine isn't that useful at

00:05:41,520 --> 00:05:49,530
the moment and the bioinformatics is

00:05:44,990 --> 00:05:51,539
still catching up so the bioinformatics

00:05:49,530 --> 00:05:53,160
around this and analyzing this data was

00:05:51,539 --> 00:05:54,720
always sort of focused on Illumina

00:05:53,160 --> 00:05:57,479
because that's all there was an Illumina

00:05:54,720 --> 00:05:59,430
reads a bit shorter and but they're also

00:05:57,479 --> 00:06:01,050
much more accurate and so put this

00:05:59,430 --> 00:06:02,789
picture here of a jigsaw puzzle so when

00:06:01,050 --> 00:06:04,470
it comes to sort of assembling back a

00:06:02,789 --> 00:06:06,780
human genome you have all these really

00:06:04,470 --> 00:06:09,240
short strings of DNA and you want to put

00:06:06,780 --> 00:06:13,470
them all together into these massive the

00:06:09,240 --> 00:06:15,570
human genome is three Giga bases so it

00:06:13,470 --> 00:06:18,360
requires a lot of RAM and a lot of CPU

00:06:15,570 --> 00:06:19,740
power to put this all back together but

00:06:18,360 --> 00:06:21,570
the mirror actually provides you long

00:06:19,740 --> 00:06:26,190
reads so it's like having bigger jigsaw

00:06:21,570 --> 00:06:28,140
pieces but they're a bit blurrier so

00:06:26,190 --> 00:06:29,190
together with Illumina can actually you

00:06:28,140 --> 00:06:30,800
know be friends and

00:06:29,190 --> 00:06:35,550
can actually have a decent quality

00:06:30,800 --> 00:06:37,020
genome but the rebuttal to this is that

00:06:35,550 --> 00:06:40,200
this is significantly improving over

00:06:37,020 --> 00:06:43,590
time so in my time in the wet lab when I

00:06:40,200 --> 00:06:45,930
started back in early March in April

00:06:43,590 --> 00:06:47,640
last year this was the the yield that we

00:06:45,930 --> 00:06:48,870
were getting off this machine we're next

00:06:47,640 --> 00:06:51,990
to nothing we should look better I think

00:06:48,870 --> 00:06:53,340
as a logarithmic graph and now we're

00:06:51,990 --> 00:06:56,580
getting up to around about eight Giga

00:06:53,340 --> 00:07:00,330
bases so two to threefold coverage of

00:06:56,580 --> 00:07:03,990
the human genome the limitations on

00:07:00,330 --> 00:07:05,430
portable sequencing are that so when so

00:07:03,990 --> 00:07:06,780
Oxford nanopore they're kind of

00:07:05,430 --> 00:07:09,240
reminding a bit like they see I was a

00:07:06,780 --> 00:07:10,740
bit like Steve Jobs was so you know they

00:07:09,240 --> 00:07:12,600
come out with a new sort of chemistry

00:07:10,740 --> 00:07:15,480
and like this is the next big thing you

00:07:12,600 --> 00:07:16,710
know even if it's just like OS X 10.8 to

00:07:15,480 --> 00:07:17,700
ten point nine kind of thing and you

00:07:16,710 --> 00:07:20,160
think what do you what are you talking

00:07:17,700 --> 00:07:22,320
about and their designs as well they're

00:07:20,160 --> 00:07:25,530
trying to really I think to be like the

00:07:22,320 --> 00:07:27,390
next Apple in in this spot and you know

00:07:25,530 --> 00:07:31,140
in there particularly when they were

00:07:27,390 --> 00:07:32,790
pitching to the the vendors you know it

00:07:31,140 --> 00:07:34,380
was basically you'd prick yourself in

00:07:32,790 --> 00:07:35,700
blood and you put it on a USB stick and

00:07:34,380 --> 00:07:37,500
we'd do all the analysis for you but

00:07:35,700 --> 00:07:40,590
unfortunately we what we found is that

00:07:37,500 --> 00:07:42,840
the mirror on really only focuses on one

00:07:40,590 --> 00:07:46,620
of these three things that you require

00:07:42,840 --> 00:07:48,300
for DNA sequencing DNA itself is tightly

00:07:46,620 --> 00:07:51,630
wrapped up in ourselves because it

00:07:48,300 --> 00:07:52,500
doesn't want to mutate and be affected

00:07:51,630 --> 00:07:54,750
by other things that could potentially

00:07:52,500 --> 00:07:56,160
cause it to change and then give us

00:07:54,750 --> 00:07:59,400
cancer or something so it's quite hard

00:07:56,160 --> 00:08:01,740
to get DNA out of a cell to begin with

00:07:59,400 --> 00:08:04,200
sure it can you can take it out into the

00:08:01,740 --> 00:08:06,480
middle of nowhere and stick some stick

00:08:04,200 --> 00:08:07,830
of pet in it and get the DNA out that

00:08:06,480 --> 00:08:10,500
you won't actually know what you've got

00:08:07,830 --> 00:08:12,930
until you go back to where your HP C is

00:08:10,500 --> 00:08:18,270
so that you can then infer the squiggle

00:08:12,930 --> 00:08:20,160
data into CA GS and T's which is kind of

00:08:18,270 --> 00:08:21,870
frustrating yet so and you know really

00:08:20,160 --> 00:08:24,660
defeats the purpose of the portable

00:08:21,870 --> 00:08:25,950
sequencing so first of all sort of go

00:08:24,660 --> 00:08:32,400
into about how actually this base

00:08:25,950 --> 00:08:34,140
calling calling works so it's not so

00:08:32,400 --> 00:08:38,130
this picture here that I'm trying to add

00:08:34,140 --> 00:08:41,490
to it show here you know it's that's on

00:08:38,130 --> 00:08:42,750
this side there we are there's a mess so

00:08:41,490 --> 00:08:44,069
we say we've got

00:08:42,750 --> 00:08:45,810
maybe not be able to read this but this

00:08:44,069 --> 00:08:47,160
spike here sort of corresponds to a G

00:08:45,810 --> 00:08:48,779
but that's not that's not really the

00:08:47,160 --> 00:08:50,509
case what what's actually going on is

00:08:48,779 --> 00:08:52,769
it's more representative of five or six

00:08:50,509 --> 00:08:57,110
nucleotides that are in the poor in any

00:08:52,769 --> 00:08:59,699
given moment rather than one and so to

00:08:57,110 --> 00:09:01,259
to infer them what's what's in there

00:08:59,699 --> 00:09:03,689
you've you've got to use something like

00:09:01,259 --> 00:09:07,740
a hidden Markov model or now recurrent

00:09:03,689 --> 00:09:09,300
neural network to so as the so to take

00:09:07,740 --> 00:09:10,860
these sample points and so you've got

00:09:09,300 --> 00:09:13,050
say six bases in there and then they

00:09:10,860 --> 00:09:15,420
move out and so these five bases become

00:09:13,050 --> 00:09:18,000
the position before it and you've got a

00:09:15,420 --> 00:09:21,269
new base in and so transferring from

00:09:18,000 --> 00:09:24,389
quema of k represents 5 or K represents

00:09:21,269 --> 00:09:27,180
six and changing between those

00:09:24,389 --> 00:09:29,639
particular two states so just as a

00:09:27,180 --> 00:09:31,500
refresher is a picture of a hidden

00:09:29,639 --> 00:09:36,449
Markov model which you can find on

00:09:31,500 --> 00:09:39,300
Wikipedia so we have in this in this

00:09:36,449 --> 00:09:40,980
situation in the backed the story of

00:09:39,300 --> 00:09:42,149
this one was the Alice and Bob with

00:09:40,980 --> 00:09:46,259
friends on the other side of the world

00:09:42,149 --> 00:09:47,910
and Alice kind of knew the where where

00:09:46,259 --> 00:09:49,439
Bob lived and the the state's between

00:09:47,910 --> 00:09:51,389
rainy and sunny and the likelihood of

00:09:49,439 --> 00:09:53,490
changing between the two but you didn't

00:09:51,389 --> 00:09:54,779
know what any given day was and when Bob

00:09:53,490 --> 00:09:56,850
would ring her up and tell her what he

00:09:54,779 --> 00:09:59,490
was doing that day so Bob would either

00:09:56,850 --> 00:10:00,809
only be cleaning or only be shopping or

00:09:59,490 --> 00:10:04,350
only be walking there wasn't wasn't

00:10:00,809 --> 00:10:06,480
really a fun fun person so she would

00:10:04,350 --> 00:10:07,889
then try and infer whether or not it was

00:10:06,480 --> 00:10:09,959
rainy or whether or not was sunny

00:10:07,889 --> 00:10:13,379
so to her the rainy and sunny a hidden

00:10:09,959 --> 00:10:17,730
and so to us we don't really know what

00:10:13,379 --> 00:10:19,379
particular state a is currently in the

00:10:17,730 --> 00:10:23,209
in the genome but we do know when it

00:10:19,379 --> 00:10:25,589
when it changes and what that could mean

00:10:23,209 --> 00:10:26,730
about where where it currently is and

00:10:25,589 --> 00:10:29,129
you just sort of keep going along like

00:10:26,730 --> 00:10:31,050
that so Alice would be stalking lis

00:10:29,129 --> 00:10:32,970
having a little note down this is what

00:10:31,050 --> 00:10:35,129
he did today what he did the day after

00:10:32,970 --> 00:10:37,379
and trying to keep keep a record so that

00:10:35,129 --> 00:10:39,000
she can then infer whether or not it's

00:10:37,379 --> 00:10:40,800
rainy and sunny and whether or not he'll

00:10:39,000 --> 00:10:43,620
then is likely to go to walk to the

00:10:40,800 --> 00:10:48,360
shops tomorrow or go for a walk or go or

00:10:43,620 --> 00:10:52,589
clean before he tells her it's a it's

00:10:48,360 --> 00:10:55,410
the best I could do for an analogy there

00:10:52,589 --> 00:10:56,790
so but we've switched it's switch to an

00:10:55,410 --> 00:10:59,940
RNN recently our

00:10:56,790 --> 00:11:04,860
for a recurrent neural network and in

00:10:59,940 --> 00:11:05,880
particular of an R and L STM type so our

00:11:04,860 --> 00:11:07,470
nanun hmm

00:11:05,880 --> 00:11:10,110
other than for these kind of weird

00:11:07,470 --> 00:11:14,070
examples are used in speech recognition

00:11:10,110 --> 00:11:15,900
or in handwriting recognition whether or

00:11:14,070 --> 00:11:17,820
not you're trying to determine whether

00:11:15,900 --> 00:11:18,540
or not whose handwriting it is or

00:11:17,820 --> 00:11:21,660
whether or not you're trying to

00:11:18,540 --> 00:11:25,080
determine if that is this word in that

00:11:21,660 --> 00:11:26,370
you could read in text or if what

00:11:25,080 --> 00:11:28,910
they're saying and then writing it down

00:11:26,370 --> 00:11:33,420
and like for closed captions purposes

00:11:28,910 --> 00:11:35,550
but the LS TM in this provides can

00:11:33,420 --> 00:11:38,100
provide contextual based information so

00:11:35,550 --> 00:11:42,150
by sort of going through and back

00:11:38,100 --> 00:11:43,380
propagating through from before where

00:11:42,150 --> 00:11:45,390
we've only got these two states were

00:11:43,380 --> 00:11:48,330
hidden Markov model we could then be

00:11:45,390 --> 00:11:50,820
like going back before being like was it

00:11:48,330 --> 00:11:54,150
something rainy before that and before

00:11:50,820 --> 00:11:55,860
that one and before that one for R so in

00:11:54,150 --> 00:11:58,050
the case of context-based speaking we're

00:11:55,860 --> 00:12:01,110
talking about whether or not people were

00:11:58,050 --> 00:12:03,150
talking say the word poor and poor B P

00:12:01,110 --> 00:12:06,000
double O R P oh you are very hard to

00:12:03,150 --> 00:12:08,730
pick up and convert that to text when

00:12:06,000 --> 00:12:12,510
you don't know the context and an LST M

00:12:08,730 --> 00:12:14,790
seems to be quite good at doing that so

00:12:12,510 --> 00:12:16,670
in these and they seem to be quite more

00:12:14,790 --> 00:12:22,350
useful in terms of nanopore sequencing

00:12:16,670 --> 00:12:24,590
because there seems to be things that

00:12:22,350 --> 00:12:27,630
are occurring much further later Liam

00:12:24,590 --> 00:12:30,090
previously that seemed to be able to

00:12:27,630 --> 00:12:32,970
improve the accuracy of what's currently

00:12:30,090 --> 00:12:34,470
currently going through the nuclear at

00:12:32,970 --> 00:12:37,260
the particularly nucleotide at that

00:12:34,470 --> 00:12:40,170
point no explaining that that quite well

00:12:37,260 --> 00:12:41,670
but maybe so what I'm trying to point

00:12:40,170 --> 00:12:44,160
out is that this spike here that's

00:12:41,670 --> 00:12:46,740
corresponding to a G may also be related

00:12:44,160 --> 00:12:50,370
to something that's you know 10 or 12

00:12:46,740 --> 00:12:51,750
bases back but if our came a base model

00:12:50,370 --> 00:12:54,360
there's only on five on six so then

00:12:51,750 --> 00:12:58,590
we're not going to not going to be able

00:12:54,360 --> 00:13:00,080
to pick that up so this is where the LST

00:12:58,590 --> 00:13:06,180
M comes in quite handy

00:13:00,080 --> 00:13:08,450
so I mentioned in my my abstract that so

00:13:06,180 --> 00:13:10,680
what's with the what's with the FPGA so

00:13:08,450 --> 00:13:11,910
Ont Oxford nanopore

00:13:10,680 --> 00:13:14,250
Technologies announced that they were

00:13:11,910 --> 00:13:16,170
looking into an FPGA in March 2017 and

00:13:14,250 --> 00:13:18,120
this was because previously what you

00:13:16,170 --> 00:13:19,529
would have to do was once you had all

00:13:18,120 --> 00:13:21,810
your data or human iron you would send

00:13:19,529 --> 00:13:23,250
it up to the cloud and this could

00:13:21,810 --> 00:13:25,890
potentially mean sending up 1 million

00:13:23,250 --> 00:13:27,120
files to an Amazon web server waiting

00:13:25,890 --> 00:13:29,520
for them to finish and then downloading

00:13:27,120 --> 00:13:33,270
them again which was exceptionally

00:13:29,520 --> 00:13:34,589
painful and this was costing Oxford

00:13:33,270 --> 00:13:36,330
nanopore around about a hundred thousand

00:13:34,589 --> 00:13:37,800
dollars a month so they scrapped that

00:13:36,330 --> 00:13:39,450
and said you guys have to do the base

00:13:37,800 --> 00:13:42,450
calling yourselves and they provided a

00:13:39,450 --> 00:13:44,430
CPU based algorithm to do so there's

00:13:42,450 --> 00:13:46,260
also a few open-source algorithms that I

00:13:44,430 --> 00:13:48,620
recommend if you if you're interested in

00:13:46,260 --> 00:13:56,630
this kind of stuff going through and

00:13:48,620 --> 00:13:59,370
contributing too so it was quite for us

00:13:56,630 --> 00:14:01,080
where we've got 1 million and we have a

00:13:59,370 --> 00:14:03,810
whole bunch of HP C's this was ok

00:14:01,080 --> 00:14:05,580
because we could in real time be able to

00:14:03,810 --> 00:14:08,700
take the data off them you know iearnt

00:14:05,580 --> 00:14:09,870
run it through HP C's a few of my bio

00:14:08,700 --> 00:14:11,910
phonetic colleagues might get a bit

00:14:09,870 --> 00:14:14,760
annoyed cuz like who's submitting all

00:14:11,910 --> 00:14:17,640
these jobs but nonetheless it was it

00:14:14,760 --> 00:14:20,220
could it was doable but obviously not

00:14:17,640 --> 00:14:22,230
portable in this case so so where does

00:14:20,220 --> 00:14:24,570
that leave those trying to leave trying

00:14:22,230 --> 00:14:25,980
the field sequencing applications well

00:14:24,570 --> 00:14:27,360
they couldn't do it unless they had

00:14:25,980 --> 00:14:29,580
something like this little thing which

00:14:27,360 --> 00:14:32,040
is currently in sort of the vaporware

00:14:29,580 --> 00:14:34,020
world where the min iron would plug into

00:14:32,040 --> 00:14:37,260
an FPGA that would then plug into your

00:14:34,020 --> 00:14:41,850
laptop where the FPGA PFF PDA had done

00:14:37,260 --> 00:14:43,320
all the base going for you and that's

00:14:41,850 --> 00:14:45,270
this is kind of where I thought well in

00:14:43,320 --> 00:14:46,620
my limited spare time maybe maybe I

00:14:45,270 --> 00:14:49,440
could try something and beat them to it

00:14:46,620 --> 00:14:51,450
and having seen that the parallel aboard

00:14:49,440 --> 00:14:54,240
that popped up on my newsfeed once

00:14:51,450 --> 00:14:56,300
contained in FPGA I mean how hard could

00:14:54,240 --> 00:14:58,680
this be

00:14:56,300 --> 00:15:02,040
and I certainly don't regret creating

00:14:58,680 --> 00:15:03,620
this presentation and my investigations

00:15:02,040 --> 00:15:05,700
into this at all if I've learnt a lot

00:15:03,620 --> 00:15:09,450
and I've learned a lot about parallel

00:15:05,700 --> 00:15:10,709
processing at the same time so now we'll

00:15:09,450 --> 00:15:14,940
go into a little bit of an introduction

00:15:10,709 --> 00:15:17,579
on what FPGA is o stands for a field

00:15:14,940 --> 00:15:19,410
programmable gate array which sounds a

00:15:17,579 --> 00:15:19,960
bit like field powered gatorade I think

00:15:19,410 --> 00:15:23,080
so

00:15:19,960 --> 00:15:26,260
so that hopefully the lamest joke of

00:15:23,080 --> 00:15:29,890
today if someone has a lamb a joke I

00:15:26,260 --> 00:15:34,360
don't want to hear it but actually so

00:15:29,890 --> 00:15:36,310
what is an FPGA so kind of like if you

00:15:34,360 --> 00:15:37,870
can remember back to either like your

00:15:36,310 --> 00:15:40,450
introduction engineering and stuff

00:15:37,870 --> 00:15:45,899
you'll remember he did and or not and

00:15:40,450 --> 00:15:48,940
nor and NAND gates and it's kind of a

00:15:45,899 --> 00:15:52,560
grid of those that are all sort of hard

00:15:48,940 --> 00:15:55,380
wired together to sort of mimic

00:15:52,560 --> 00:15:57,760
algorithmic logic that you've put in

00:15:55,380 --> 00:15:59,740
that you've programmed it to be so they

00:15:57,760 --> 00:16:02,980
are quite the dynamic compared to say

00:15:59,740 --> 00:16:05,800
some other kind of hardware based chips

00:16:02,980 --> 00:16:07,810
where you send it out and that's it you

00:16:05,800 --> 00:16:10,000
can actually go back to an FPGA and you

00:16:07,810 --> 00:16:12,310
can actually reconfigure the logic which

00:16:10,000 --> 00:16:15,670
is quite useful and so you can have

00:16:12,310 --> 00:16:20,770
quite complex FPGAs will then have also

00:16:15,670 --> 00:16:22,300
a little bits of ram into interlocked

00:16:20,770 --> 00:16:25,510
within them as well so you can quickly

00:16:22,300 --> 00:16:28,240
go from having an object putting it

00:16:25,510 --> 00:16:29,589
through somewhere in the FPGA and then

00:16:28,240 --> 00:16:32,650
outputting up to another piece of the

00:16:29,589 --> 00:16:36,370
FPGA so you can jump through between TPU

00:16:32,650 --> 00:16:38,020
and FPGA quite quite easily and it

00:16:36,370 --> 00:16:39,520
offers parallelization on a massive

00:16:38,020 --> 00:16:43,990
scale and the reason this is is because

00:16:39,520 --> 00:16:46,270
of the FPGA is clock ticks so it kind of

00:16:43,990 --> 00:16:49,660
works between FPGA I generally work

00:16:46,270 --> 00:16:52,120
between ten megahertz and hundreds of

00:16:49,660 --> 00:16:53,560
megahertz in frequency and so what a

00:16:52,120 --> 00:16:56,200
clock is doing is just oscillating

00:16:53,560 --> 00:16:59,529
between zero and one and so if you're in

00:16:56,200 --> 00:17:01,510
each of these logic blocks the they're

00:16:59,529 --> 00:17:03,250
going through each time the voltage is

00:17:01,510 --> 00:17:05,230
zero they're doing nothing and then when

00:17:03,250 --> 00:17:07,540
it flicks they're gonna be like okay so

00:17:05,230 --> 00:17:09,309
are they to the zero and ones together

00:17:07,540 --> 00:17:09,790
in the NAND gate will either go back to

00:17:09,309 --> 00:17:13,660
zero

00:17:09,790 --> 00:17:16,059
during that microsecond or the or if

00:17:13,660 --> 00:17:19,089
it's one on one in anger it will go and

00:17:16,059 --> 00:17:21,160
decide to become a one and this offers

00:17:19,089 --> 00:17:23,020
paralyzation at a massive scale because

00:17:21,160 --> 00:17:25,770
every single logic block is doing this

00:17:23,020 --> 00:17:28,089
at the same time within the fpga itself

00:17:25,770 --> 00:17:30,070
and they're quite an old technology

00:17:28,089 --> 00:17:31,720
FPGAs you know they came around in the

00:17:30,070 --> 00:17:33,670
80s but this they're still very useful

00:17:31,720 --> 00:17:37,570
and because

00:17:33,670 --> 00:17:39,520
can do really specific tasks really

00:17:37,570 --> 00:17:41,290
really quickly and so they use currently

00:17:39,520 --> 00:17:43,180
in blacks a video or imaging processing

00:17:41,290 --> 00:17:45,520
so whether or not this is something

00:17:43,180 --> 00:17:47,860
where you've got a 360 degree camera on

00:17:45,520 --> 00:17:50,050
a GoPro and you just need to get it so

00:17:47,860 --> 00:17:51,310
that provides an image for you to be

00:17:50,050 --> 00:17:53,650
able to look at that you can look at

00:17:51,310 --> 00:17:56,290
visually whether or not signal

00:17:53,650 --> 00:17:58,690
processing is another example or motor

00:17:56,290 --> 00:18:00,460
control instead of the example of that

00:17:58,690 --> 00:18:04,450
and I've created some links in there

00:18:00,460 --> 00:18:05,980
NASA also uses FPGAs and their BOTS and

00:18:04,450 --> 00:18:08,140
stuff that can travel on Mars and

00:18:05,980 --> 00:18:10,480
whatnot which is which is pretty cool

00:18:08,140 --> 00:18:11,950
and it also means that they can because

00:18:10,480 --> 00:18:14,530
of the way that you can actually program

00:18:11,950 --> 00:18:17,020
an FPGA it also means that they can then

00:18:14,530 --> 00:18:19,390
decide if there is a bug on their bot in

00:18:17,020 --> 00:18:21,640
Mars that they can reprogram it not

00:18:19,390 --> 00:18:23,530
easily but they do work for NASA so I

00:18:21,640 --> 00:18:26,980
guess they they know a thing or two

00:18:23,530 --> 00:18:29,020
about that kind of stuff it's

00:18:26,980 --> 00:18:30,820
programming an FPGA is quite difficult

00:18:29,020 --> 00:18:32,410
it's hardware programming and there's

00:18:30,820 --> 00:18:36,280
anyone who saw the talk just before

00:18:32,410 --> 00:18:39,490
would know there's quite a few there's

00:18:36,280 --> 00:18:41,290
very few libraries available it requires

00:18:39,490 --> 00:18:43,810
a different programming mindset from my

00:18:41,290 --> 00:18:45,610
limited experience working with VHDL a

00:18:43,810 --> 00:18:47,200
very long where you need to be wary of

00:18:45,610 --> 00:18:48,790
this sort of clock cycle feature at the

00:18:47,200 --> 00:18:51,940
same time as wanting to try and

00:18:48,790 --> 00:18:57,790
implement your logic there are quite if

00:18:51,940 --> 00:18:59,560
I've had a look at a few and as the talk

00:18:57,790 --> 00:19:01,990
before would say now there's even a

00:18:59,560 --> 00:19:05,560
Python version of FPGA that there are a

00:19:01,990 --> 00:19:07,570
few sort of C based FPGA converters out

00:19:05,560 --> 00:19:10,240
there see the FPGA converters out there

00:19:07,570 --> 00:19:14,920
now that will allow you to do your FPGA

00:19:10,240 --> 00:19:16,360
programming in C so having had a look at

00:19:14,920 --> 00:19:18,790
this thinking mmm

00:19:16,360 --> 00:19:21,580
maybe later I'll get back to this this

00:19:18,790 --> 00:19:23,350
FPGA thing I looked at the other

00:19:21,580 --> 00:19:28,030
component of the parallel aboard which

00:19:23,350 --> 00:19:33,720
is the Epiphany server so the Epiphany

00:19:28,030 --> 00:19:37,660
component is adaptive is sort of

00:19:33,720 --> 00:19:39,340
equivalent processing unit of like an

00:19:37,660 --> 00:19:41,890
alternative to say Intel on a video for

00:19:39,340 --> 00:19:44,470
their CPUs and this boards actually

00:19:41,890 --> 00:19:47,080
exceptionally efficient in the way it

00:19:44,470 --> 00:19:47,410
works because it's promoting rather than

00:19:47,080 --> 00:19:50,200
doing

00:19:47,410 --> 00:19:53,830
having a couple of cause that have a lot

00:19:50,200 --> 00:19:57,490
of power it's many cause that all have

00:19:53,830 --> 00:20:02,950
very little power so this means that

00:19:57,490 --> 00:20:04,660
it's actually quite a bit more efficient

00:20:02,950 --> 00:20:08,080
because data is not having to run from

00:20:04,660 --> 00:20:10,750
the memory node on the on a CPU all the

00:20:08,080 --> 00:20:13,300
way over to the local Ram and back and

00:20:10,750 --> 00:20:15,580
forth it's not too much of that talking

00:20:13,300 --> 00:20:19,060
because everything should be located

00:20:15,580 --> 00:20:21,610
within its own little block but they can

00:20:19,060 --> 00:20:23,410
all talk to each other as well in case

00:20:21,610 --> 00:20:24,790
that your program is a bit too large and

00:20:23,410 --> 00:20:28,390
then you do need multiple nodes to do

00:20:24,790 --> 00:20:30,670
one particular thing and it's highly

00:20:28,390 --> 00:20:32,860
scalable scalable we have a what's here

00:20:30,670 --> 00:20:39,070
is a 64-bit processor the parallel board

00:20:32,860 --> 00:20:40,600
itself the one that I got is only 16 but

00:20:39,070 --> 00:20:42,460
nonetheless you can actually program

00:20:40,600 --> 00:20:44,590
this to have up to a million different

00:20:42,460 --> 00:20:45,970
if you have enough money obviously to

00:20:44,590 --> 00:20:47,140
stick these all things together you can

00:20:45,970 --> 00:20:51,490
actually have it so that it's got a

00:20:47,140 --> 00:20:52,800
million cores which is pretty amazing

00:20:51,490 --> 00:20:55,090
I've never seen anyone do it

00:20:52,800 --> 00:20:57,430
unfortunately I've seen up to four or

00:20:55,090 --> 00:20:59,560
five of these all stacked up in Iraq and

00:20:57,430 --> 00:21:01,660
it looked looked pretty cool so

00:20:59,560 --> 00:21:05,500
programming in the epiphany is a bit

00:21:01,660 --> 00:21:08,860
different it's using the it's very

00:21:05,500 --> 00:21:10,900
similar to see this is an eclipse-based

00:21:08,860 --> 00:21:12,510
they've provided you they provide one

00:21:10,900 --> 00:21:14,800
with an eclipse-based

00:21:12,510 --> 00:21:16,630
library you could say so when you start

00:21:14,800 --> 00:21:18,640
off your CD Projekt epiphany project

00:21:16,630 --> 00:21:23,020
you'll say how many cause the specify

00:21:18,640 --> 00:21:24,610
the number of cores the number of rows

00:21:23,020 --> 00:21:29,560
in each core number of columns in each

00:21:24,610 --> 00:21:30,790
core so row number of the first core :

00:21:29,560 --> 00:21:32,500
number of the second core and this can

00:21:30,790 --> 00:21:36,910
all be sort of this can all be

00:21:32,500 --> 00:21:39,670
determined quite easily by the your

00:21:36,910 --> 00:21:42,610
adopt either a software development kit

00:21:39,670 --> 00:21:44,410
that so depending on which type of board

00:21:42,610 --> 00:21:46,780
you've got it'll tell you what which one

00:21:44,410 --> 00:21:48,640
of these you need to enter and

00:21:46,780 --> 00:21:50,590
programming is it's very similar to see

00:21:48,640 --> 00:21:56,460
you but you have these sort of extra

00:21:50,590 --> 00:21:56,460
things like get core ID there's my mouse

00:21:56,580 --> 00:22:00,600
here which will allow you to

00:22:01,340 --> 00:22:05,030
sort of set to a particular core being

00:22:03,680 --> 00:22:06,770
like I want you to do this and I don't

00:22:05,030 --> 00:22:11,270
think HelloWorld is probably the best

00:22:06,770 --> 00:22:14,360
example for parallelization because it

00:22:11,270 --> 00:22:17,030
doesn't really make make sense as a as a

00:22:14,360 --> 00:22:18,740
topic yes you can parallel hello world

00:22:17,030 --> 00:22:19,850
from 12 different things then I'll

00:22:18,740 --> 00:22:22,340
probably come back to you in the same

00:22:19,850 --> 00:22:24,140
time it's just one did but you're not

00:22:22,340 --> 00:22:28,700
really getting to test the compiler very

00:22:24,140 --> 00:22:31,120
well at all no test the server at all so

00:22:28,700 --> 00:22:33,550
this is where a Python comes in which is

00:22:31,120 --> 00:22:37,610
created by NIC Brown up in Edinburgh

00:22:33,550 --> 00:22:39,830
which is an implementation of Python for

00:22:37,610 --> 00:22:42,110
the epiphysis specifically for the

00:22:39,830 --> 00:22:48,710
Epiphany so as we saw before this is a

00:22:42,110 --> 00:22:53,450
this is a this is a prime number test so

00:22:48,710 --> 00:22:56,300
we have 16 total cores and we're testing

00:22:53,450 --> 00:23:00,440
each of them so we're gonna use core 1

00:22:56,300 --> 00:23:03,950
to the test to test number one we use

00:23:00,440 --> 00:23:08,870
core 2 to test number 2 etc up to 16 and

00:23:03,950 --> 00:23:12,280
then we'll add on 16 here so the test

00:23:08,870 --> 00:23:17,080
number call 1 will then test number 17

00:23:12,280 --> 00:23:19,370
and core 2 will test number 18 and so on

00:23:17,080 --> 00:23:21,890
and this is actually this is from a

00:23:19,370 --> 00:23:23,570
YouTube video that also in my notes as

00:23:21,890 --> 00:23:26,180
well that you can wait and you can check

00:23:23,570 --> 00:23:29,240
up so interesting though the results of

00:23:26,180 --> 00:23:33,290
this was such that the Epiphany board

00:23:29,240 --> 00:23:36,820
itself was only ever so slightly faster

00:23:33,290 --> 00:23:39,590
that the arm presser um

00:23:36,820 --> 00:23:42,020
the arm CPU that's also on this board to

00:23:39,590 --> 00:23:45,050
run Ubuntu and stuff was which was a bit

00:23:42,020 --> 00:23:47,330
disappointing to see and my tests of

00:23:45,050 --> 00:23:49,340
running and Aaron in on the ARM

00:23:47,330 --> 00:23:52,130
processor were that it was around about

00:23:49,340 --> 00:23:54,170
2000 times slower than I needed to be

00:23:52,130 --> 00:23:56,510
for it to be running in real time so I

00:23:54,170 --> 00:23:58,310
could technically stick stack up 2000 of

00:23:56,510 --> 00:23:59,510
these all in a row but then I have

00:23:58,310 --> 00:24:02,150
something about the same size as their

00:23:59,510 --> 00:24:05,510
HPC which was kind of defeating the

00:24:02,150 --> 00:24:07,790
purpose again so I thought well why

00:24:05,510 --> 00:24:09,920
don't I sit on this and because we've

00:24:07,790 --> 00:24:11,390
got coming up announced by our table

00:24:09,920 --> 00:24:14,140
that they had a thousand and twenty four

00:24:11,390 --> 00:24:16,780
core thing coming along

00:24:14,140 --> 00:24:19,120
which would have been here made on the

00:24:16,780 --> 00:24:22,750
news headlines in the IT world back in

00:24:19,120 --> 00:24:24,970
October last year which would have and

00:24:22,750 --> 00:24:28,840
the Epiphany V V stands for 5 not

00:24:24,970 --> 00:24:31,660
vaporware that was just my little take

00:24:28,840 --> 00:24:33,970
on this so unfortunately the problem

00:24:31,660 --> 00:24:38,260
with this is that the main developer

00:24:33,970 --> 00:24:41,260
andreas Olufsen has left parallel ax to

00:24:38,260 --> 00:24:43,600
take up job opportunity in DARPA which

00:24:41,260 --> 00:24:45,070
I'm all happy for I mean imagine working

00:24:43,600 --> 00:24:47,200
in DARPA that would be pretty amazing

00:24:45,070 --> 00:24:48,820
and he's looking for someone to take it

00:24:47,200 --> 00:24:52,360
over because he reckons that if no one

00:24:48,820 --> 00:24:54,900
does then this 1,024 course server which

00:24:52,360 --> 00:24:58,140
will hopefully be the same size as this

00:24:54,900 --> 00:25:00,580
will just remain forever as a prototype

00:24:58,140 --> 00:25:03,760
so if you are looking at getting a new

00:25:00,580 --> 00:25:05,020
job and you like processing and I've

00:25:03,760 --> 00:25:06,490
inspired you enough on the parallel

00:25:05,020 --> 00:25:11,490
aboard then I would highly recommend

00:25:06,490 --> 00:25:13,870
that you do this because this would then

00:25:11,490 --> 00:25:15,549
contention seriously speed things up as

00:25:13,870 --> 00:25:17,679
well and we get to a point that maybe

00:25:15,549 --> 00:25:18,730
hey if we put four of these together we

00:25:17,679 --> 00:25:22,600
have something that'll work with the

00:25:18,730 --> 00:25:24,340
midnight in real time and that's totally

00:25:22,600 --> 00:25:25,660
portable stacking four of the on top you

00:25:24,340 --> 00:25:27,690
can just throw that in your backpack not

00:25:25,660 --> 00:25:31,540
in your pocket like this but it releases

00:25:27,690 --> 00:25:33,580
it's somewhat portable so the things

00:25:31,540 --> 00:25:37,990
that I've learned in this project that

00:25:33,580 --> 00:25:39,220
puppy boards highly educational even if

00:25:37,990 --> 00:25:41,799
I haven't managed to get this project

00:25:39,220 --> 00:25:43,900
off the ground I've learned so much

00:25:41,799 --> 00:25:46,150
about first of all setting up servers

00:25:43,900 --> 00:25:48,340
permission root permissions they're

00:25:46,150 --> 00:25:50,890
amazing especially when you didn't have

00:25:48,340 --> 00:25:52,600
root permissions to begin with which I

00:25:50,890 --> 00:25:54,309
do it work but it's also giving me like

00:25:52,600 --> 00:25:56,350
a much greater appreciation for system

00:25:54,309 --> 00:25:58,990
systems administration teams because you

00:25:56,350 --> 00:26:03,040
like they do actually do a lot of stuff

00:25:58,990 --> 00:26:04,840
that's not just installing packages for

00:26:03,040 --> 00:26:07,330
you but they're actually you know hard

00:26:04,840 --> 00:26:10,290
monitoring servers and and all the

00:26:07,330 --> 00:26:12,580
things FPGA is really hard to program

00:26:10,290 --> 00:26:18,340
that's something else I learnt but maybe

00:26:12,580 --> 00:26:19,360
I'll look at this new FPGA Python but

00:26:18,340 --> 00:26:22,830
they're important in our day to day

00:26:19,360 --> 00:26:25,179
lives are quite underestimated and you

00:26:22,830 --> 00:26:27,190
just because they're an old technology I

00:26:25,179 --> 00:26:27,760
don't think time is necessarily wasted

00:26:27,190 --> 00:26:29,170
and learning out

00:26:27,760 --> 00:26:31,060
program needs or learning how these work

00:26:29,170 --> 00:26:32,440
and machine learning as well as

00:26:31,060 --> 00:26:36,100
something that's really worth

00:26:32,440 --> 00:26:39,850
investigating it's not just a hot word

00:26:36,100 --> 00:26:42,820
anymore but it so my little quote is

00:26:39,850 --> 00:26:45,130
learn it before it learned you and I

00:26:42,820 --> 00:26:46,750
think that's that's all to it don't have

00:26:45,130 --> 00:26:55,840
a thing well thank you very much for

00:26:46,750 --> 00:26:57,940
listening thanks very much we've got

00:26:55,840 --> 00:27:00,490
time for a couple of quick questions if

00:26:57,940 --> 00:27:11,560
anyone's got got a question they'd like

00:27:00,490 --> 00:27:14,350
to ask I was just wondering if you've

00:27:11,560 --> 00:27:16,120
tried running this on the intel phi kind

00:27:14,350 --> 00:27:18,130
of coprocessor given it gives you

00:27:16,120 --> 00:27:18,880
something similar to this a bunch of x86

00:27:18,130 --> 00:27:19,990
processors

00:27:18,880 --> 00:27:21,460
yeah it's worried something I didn't

00:27:19,990 --> 00:27:23,710
mention the reason that we need

00:27:21,460 --> 00:27:25,950
something out there is because you can

00:27:23,710 --> 00:27:29,110
run these particular

00:27:25,950 --> 00:27:32,350
ireland's on a laptop but even like the

00:27:29,110 --> 00:27:34,660
i7 core laptops like the powerful ones

00:27:32,350 --> 00:27:39,490
will still take a week to run a 48 hour

00:27:34,660 --> 00:27:41,680
mu9 run which is quite not I mean the

00:27:39,490 --> 00:27:43,780
Intel fires are sort of like a GPU where

00:27:41,680 --> 00:27:46,210
they give you 60 yeah 100 cores or

00:27:43,780 --> 00:27:47,680
something like that yeah I don't know if

00:27:46,210 --> 00:27:51,280
they do a portable one but I know Nvidia

00:27:47,680 --> 00:27:55,330
do like a embedded kind of GPU sort of -

00:27:51,280 --> 00:27:57,090
yeah I know that so the the current

00:27:55,330 --> 00:27:59,890
algorithms developed by Oxford nanopore

00:27:57,090 --> 00:28:01,960
somewhat design for CPUs it would seem

00:27:59,890 --> 00:28:07,840
people that have tried them on GPUs have

00:28:01,960 --> 00:28:11,320
got different outputs yeah yeah the

00:28:07,840 --> 00:28:13,720
other thing is we've got Melbourne Uni -

00:28:11,320 --> 00:28:14,950
we've got access to the cloud FPGA

00:28:13,720 --> 00:28:18,970
instances if you wanna have a play

00:28:14,950 --> 00:28:20,470
around with them yeah yeah when you get

00:28:18,970 --> 00:28:21,610
tired of your little board or need more

00:28:20,470 --> 00:28:24,990
power or something like that although

00:28:21,610 --> 00:28:28,410
it's not portable obviously yeah thanks

00:28:24,990 --> 00:28:28,410
was there another question

00:28:34,660 --> 00:28:39,770
so these boards have up to you know

00:28:37,580 --> 00:28:42,500
thousands of cause on a single die or

00:28:39,770 --> 00:28:44,480
single chip at least is that right yeah

00:28:42,500 --> 00:28:46,550
the next version if it gets off the

00:28:44,480 --> 00:28:48,760
ground will so this one's got two cores

00:28:46,550 --> 00:28:51,410
on the ARM processor and 16 on the

00:28:48,760 --> 00:28:55,220
Epiphany processor the access through

00:28:51,410 --> 00:28:57,050
the FPGA itself and how core like what

00:28:55,220 --> 00:28:59,990
sort of arm core is it's cortex m0

00:28:57,050 --> 00:29:03,770
cortex m4 like is it floating-point

00:28:59,990 --> 00:29:07,970
relatively powerful um running these

00:29:03,770 --> 00:29:09,950
things it's not but I think it was an a

00:29:07,970 --> 00:29:13,190
nine or something which promoted but

00:29:09,950 --> 00:29:18,170
yeah that it's reasonably powerful and

00:29:13,190 --> 00:29:21,890
there's no lag or anything running like

00:29:18,170 --> 00:29:23,510
they're just running generally Ponty on

00:29:21,890 --> 00:29:25,010
it and it seems quite good and how much

00:29:23,510 --> 00:29:26,120
benefit do you get from the fact that

00:29:25,010 --> 00:29:28,850
they're all interconnected in that

00:29:26,120 --> 00:29:30,890
fabric how would a how would an

00:29:28,850 --> 00:29:33,650
equivalent algorithm compare where you

00:29:30,890 --> 00:29:37,490
could just get a thousand cloud callers

00:29:33,650 --> 00:29:39,560
or something like that yeah that well

00:29:37,490 --> 00:29:41,120
parallel routes like adapt a verbose

00:29:39,560 --> 00:29:42,800
that there is there's really no lag

00:29:41,120 --> 00:29:45,260
between having those nodes

00:29:42,800 --> 00:29:47,330
interconnected so but I haven't done a

00:29:45,260 --> 00:29:50,390
whole testing on so the algorithm is

00:29:47,330 --> 00:29:58,130
highly dependent on that reduced lag it

00:29:50,390 --> 00:30:03,820
would seem so yeah um so you described a

00:29:58,130 --> 00:30:03,820
little bit about the nano support

00:30:05,230 --> 00:30:14,720
yep that algorithm that does the

00:30:10,900 --> 00:30:17,150
converting to the CNG pairs that's only

00:30:14,720 --> 00:30:19,280
the first stage you've got then an

00:30:17,150 --> 00:30:22,960
algorithm later on that takes the

00:30:19,280 --> 00:30:26,590
proto's sequences and converts it into

00:30:22,960 --> 00:30:30,770
like that jigsaw thing what does that

00:30:26,590 --> 00:30:33,860
algorithm look like there's quite a few

00:30:30,770 --> 00:30:35,930
of those it's not something that I tried

00:30:33,860 --> 00:30:37,850
on on here but it it's definitely

00:30:35,930 --> 00:30:40,400
possible they've people have really

00:30:37,850 --> 00:30:43,040
optimized those in the far past few

00:30:40,400 --> 00:30:47,420
years to get them to be really quick

00:30:43,040 --> 00:30:52,070
so they're often cpu-based as well but

00:30:47,420 --> 00:30:54,170
they're it's a good example there's a

00:30:52,070 --> 00:30:56,780
lot of them that'll run things like hash

00:30:54,170 --> 00:30:59,360
tables and stuff against a genome subtly

00:30:56,780 --> 00:31:01,550
index the genome and run against those

00:30:59,360 --> 00:31:02,740
so they've managed to make them powerful

00:31:01,550 --> 00:31:05,180
enough so that they're sort of

00:31:02,740 --> 00:31:09,290
proportional to the log size of the

00:31:05,180 --> 00:31:12,830
genome itself in a way as far as this

00:31:09,290 --> 00:31:15,080
goes when it comes to the bottlenecks it

00:31:12,830 --> 00:31:17,330
seems to be basic calling and converting

00:31:15,080 --> 00:31:20,480
that analog signal into nucleotides

00:31:17,330 --> 00:31:22,280
rather than then converting and rather

00:31:20,480 --> 00:31:32,630
than trying to find where those

00:31:22,280 --> 00:31:33,980
nucleotides map to a genome okay that's

00:31:32,630 --> 00:31:40,550
probably all we've got time for question

00:31:33,980 --> 00:31:42,620
why so please thank Alexis again and in

00:31:40,550 --> 00:31:44,950
payment for your presentation a cutting

00:31:42,620 --> 00:31:44,950

YouTube URL: https://www.youtube.com/watch?v=FXDEycbWgqE


