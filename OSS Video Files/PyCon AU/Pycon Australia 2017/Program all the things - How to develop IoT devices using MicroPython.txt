Title: Program all the things - How to develop IoT devices using MicroPython
Publication date: 2017-08-04
Playlist: Pycon Australia 2017
Description: 
	Anna Gerber

http://2017.pycon-au.org/schedule/presentation/93/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:00,030 --> 00:00:08,010
hello everyone and welcome to PyCon and

00:00:04,560 --> 00:00:09,960
i as a software developer and maker she

00:00:08,010 --> 00:00:11,849
enjoys developing and facilitating

00:00:09,960 --> 00:00:14,549
workshops thank you so much Anna for

00:00:11,849 --> 00:00:17,730
that and she's an organizer of notebooks

00:00:14,549 --> 00:00:20,160
note what's a you a co-organizer of RIS

00:00:17,730 --> 00:00:22,439
banality meeting groups and an author of

00:00:20,160 --> 00:00:24,960
make JavaScript robotics so it's a

00:00:22,439 --> 00:00:28,330
pleasure to introduce you Anna thank you

00:00:24,960 --> 00:00:33,260
so much now over to you thank you all

00:00:28,330 --> 00:00:36,450
[Applause]

00:00:33,260 --> 00:00:39,149
right so you've already seen some of

00:00:36,450 --> 00:00:41,520
what micro PI thing can do so my talk is

00:00:39,149 --> 00:00:42,719
really much much more simple it's how

00:00:41,520 --> 00:00:46,500
you would get started with developing

00:00:42,719 --> 00:00:47,879
IOT devices using micropipette so just

00:00:46,500 --> 00:00:50,879
some more background about me so I'm a

00:00:47,879 --> 00:00:53,940
senior nodejs developer console keynote

00:00:50,879 --> 00:00:55,800
so I apologize if some of my pythons is

00:00:53,940 --> 00:00:58,859
not quite idiomatic

00:00:55,800 --> 00:01:01,230
but I do teach Python i I teach a

00:00:58,859 --> 00:01:04,680
Saturday robotics class with kids and I

00:01:01,230 --> 00:01:06,720
run workshops using Arduino 'z and

00:01:04,680 --> 00:01:09,720
various other devices to teach robotics

00:01:06,720 --> 00:01:13,049
and Internet of Things both with micro

00:01:09,720 --> 00:01:16,560
Python and with Arduino IDE so I'm a bit

00:01:13,049 --> 00:01:18,210
of a maker hobbyist and the project that

00:01:16,560 --> 00:01:19,590
I'm going to be drawing some examples on

00:01:18,210 --> 00:01:21,240
today is just the one that's pictured

00:01:19,590 --> 00:01:23,070
there unfortunately the robot did not

00:01:21,240 --> 00:01:24,930
survive in my suitcase very well the

00:01:23,070 --> 00:01:29,400
trip from Brisbane so it may or may not

00:01:24,930 --> 00:01:31,860
work but what it is is it's a little pet

00:01:29,400 --> 00:01:34,770
that is there to remind me when I need

00:01:31,860 --> 00:01:36,420
to do exercise and it kind of nags me

00:01:34,770 --> 00:01:37,380
and then I can press a button and let it

00:01:36,420 --> 00:01:41,070
know that I've actually done the

00:01:37,380 --> 00:01:44,310
exercise so a very very simple IOT demo

00:01:41,070 --> 00:01:45,509
device so I thought I'd talk through a

00:01:44,310 --> 00:01:48,360
bit of the process that I go through

00:01:45,509 --> 00:01:51,240
when I'm developing my hobbyist devices

00:01:48,360 --> 00:01:52,829
so I guess the first thing you do is

00:01:51,240 --> 00:01:53,850
kind of look at the requirements you

00:01:52,829 --> 00:01:56,490
know what you're what you want your

00:01:53,850 --> 00:01:59,340
project to do and then to choose the

00:01:56,490 --> 00:02:01,020
architecture select a language and the

00:01:59,340 --> 00:02:03,119
development tools as well as the

00:02:01,020 --> 00:02:05,670
hardware based on those requirements so

00:02:03,119 --> 00:02:07,740
for a lot of the really simple sort of

00:02:05,670 --> 00:02:09,660
projects like this is pet for example

00:02:07,740 --> 00:02:11,580
the architecture is not going to be very

00:02:09,660 --> 00:02:12,840
complex it's going to be one or two

00:02:11,580 --> 00:02:15,870
devices

00:02:12,840 --> 00:02:18,060
probably not not very intelligent

00:02:15,870 --> 00:02:20,280
devices mostly just gathering data from

00:02:18,060 --> 00:02:22,290
sensors or with some very simple

00:02:20,280 --> 00:02:25,230
actuators like some LEDs or something

00:02:22,290 --> 00:02:29,180
like that most of the work is going to

00:02:25,230 --> 00:02:32,930
be done by a cloud service or an app so

00:02:29,180 --> 00:02:35,340
that will effect a choice of hardware so

00:02:32,930 --> 00:02:36,540
once you've done that pick some hardware

00:02:35,340 --> 00:02:38,000
I'll talk a little bit about the

00:02:36,540 --> 00:02:40,860
hardware they've chosen for this project

00:02:38,000 --> 00:02:42,750
write some programs to read from the

00:02:40,860 --> 00:02:45,900
sensors control the actuators and then

00:02:42,750 --> 00:02:49,290
develop the communication between what's

00:02:45,900 --> 00:02:51,090
essentially a very dumb device with the

00:02:49,290 --> 00:02:53,069
applications that running in the cloud

00:02:51,090 --> 00:02:54,989
that are actually doing all of the the

00:02:53,069 --> 00:02:58,489
processing and the analytics on their

00:02:54,989 --> 00:03:02,190
data so a lot of IOT is really there to

00:02:58,489 --> 00:03:05,280
to get some actionable insights out of

00:03:02,190 --> 00:03:06,870
your data so analyze that data do

00:03:05,280 --> 00:03:09,870
something with it so in my case it'll be

00:03:06,870 --> 00:03:12,090
analyzing how much I've exercised and

00:03:09,870 --> 00:03:16,260
then work out how frequently it needs to

00:03:12,090 --> 00:03:18,209
nag me to actually get me to exercise so

00:03:16,260 --> 00:03:21,720
microphone Damien's already covered this

00:03:18,209 --> 00:03:23,970
but the reason I chose to use micro

00:03:21,720 --> 00:03:26,010
Python was that I was teaching a lot of

00:03:23,970 --> 00:03:29,160
classes using Arduino idea and I was

00:03:26,010 --> 00:03:32,040
already using esp8266 based

00:03:29,160 --> 00:03:33,900
microcontrollers and I found that

00:03:32,040 --> 00:03:37,799
because the students that I was teaching

00:03:33,900 --> 00:03:40,859
had already been exposed to Python that

00:03:37,799 --> 00:03:42,690
micro Python was a really intuitive sort

00:03:40,859 --> 00:03:46,019
of leap for them so trying to teach them

00:03:42,690 --> 00:03:48,239
some of these concepts using C++ C in

00:03:46,019 --> 00:03:50,549
Arduino IDE was was quite challenging so

00:03:48,239 --> 00:03:52,950
I started using micro Python for my

00:03:50,549 --> 00:03:54,690
classes and then I thought well why

00:03:52,950 --> 00:03:56,940
don't I start using micro Python for my

00:03:54,690 --> 00:03:58,380
own projects because it's really making

00:03:56,940 --> 00:04:01,829
things a lot simpler and more intuitive

00:03:58,380 --> 00:04:03,590
a lot faster to develop so Damian's

00:04:01,829 --> 00:04:06,120
already covered what micro Python is

00:04:03,590 --> 00:04:08,040
basically version of Python for

00:04:06,120 --> 00:04:10,950
constrained environments particularly

00:04:08,040 --> 00:04:12,329
microcontrollers and the thing that also

00:04:10,950 --> 00:04:14,120
really appealed to me is it's open

00:04:12,329 --> 00:04:16,079
source and there's a lot of really great

00:04:14,120 --> 00:04:21,239
documentation and libraries available

00:04:16,079 --> 00:04:23,750
for it so selecting hardware there is a

00:04:21,239 --> 00:04:26,850
lot of hardware that's supported by

00:04:23,750 --> 00:04:29,820
micro Python so these are some

00:04:26,850 --> 00:04:31,290
those of some of the ports the hardware

00:04:29,820 --> 00:04:34,590
that I chose to use for this project is

00:04:31,290 --> 00:04:36,390
the esp8266 and the reason that I chose

00:04:34,590 --> 00:04:38,940
that is just because in the hobbyist

00:04:36,390 --> 00:04:40,530
community it's pretty ubiquitous a lot

00:04:38,940 --> 00:04:42,750
of the projects that you used to build

00:04:40,530 --> 00:04:44,760
on say an Arduino with with the shield

00:04:42,750 --> 00:04:46,950
like it an Ethernet or a Wi-Fi shield a

00:04:44,760 --> 00:04:49,080
lot of people are now using esp8266

00:04:46,950 --> 00:04:51,810
based microcontrollers it's because

00:04:49,080 --> 00:04:55,200
they're so widely available they're

00:04:51,810 --> 00:04:57,890
really well documented and you know

00:04:55,200 --> 00:05:00,800
they're really quite inexpensive as well

00:04:57,890 --> 00:05:03,510
when it comes to the esp8266

00:05:00,800 --> 00:05:05,460
microcontroller there are lots and lots

00:05:03,510 --> 00:05:08,700
of different dev boards out there that

00:05:05,460 --> 00:05:11,940
you can choose these are the three that

00:05:08,700 --> 00:05:13,740
I typically go to for my projects so

00:05:11,940 --> 00:05:17,160
there's the Adafruit further huzzah

00:05:13,740 --> 00:05:20,910
esp8266 the we must D one many and the

00:05:17,160 --> 00:05:23,780
node MCU version one microcontroller and

00:05:20,910 --> 00:05:26,310
these are all very very similar

00:05:23,780 --> 00:05:28,290
development boards they all have

00:05:26,310 --> 00:05:33,810
obviously onboard Wi-Fi because the

00:05:28,290 --> 00:05:36,930
esp8266 based boards they all have up to

00:05:33,810 --> 00:05:38,160
four mega flash the modern versions of

00:05:36,930 --> 00:05:40,320
them will have forming the flash 80

00:05:38,160 --> 00:05:42,300
megahertz processor they all operate on

00:05:40,320 --> 00:05:44,100
3.3 volt logic which is a little bit

00:05:42,300 --> 00:05:45,630
different than say if you're coming from

00:05:44,100 --> 00:05:48,240
the arduino world which is typically

00:05:45,630 --> 00:05:50,340
5-volt logic so you have to sort of

00:05:48,240 --> 00:05:53,700
adjust some of your circuits and

00:05:50,340 --> 00:05:55,950
programs to to cater for that and they

00:05:53,700 --> 00:05:58,380
have a decent number of digital i/o pins

00:05:55,950 --> 00:06:00,890
up to 11 some I think one of these

00:05:58,380 --> 00:06:05,460
devices has nine and one is 10 one is 11

00:06:00,890 --> 00:06:07,260
they only have one analog one ADC pin

00:06:05,460 --> 00:06:08,880
which is a bit of a limitation if you're

00:06:07,260 --> 00:06:12,150
doing stuff with a lot of different

00:06:08,880 --> 00:06:13,590
analog sensors but for a lot of my

00:06:12,150 --> 00:06:15,600
really simple projects I really only

00:06:13,590 --> 00:06:18,510
want to deal with one sensor at a time

00:06:15,600 --> 00:06:20,970
and then you can also connect more

00:06:18,510 --> 00:06:23,250
sensors using something like an i2c bus

00:06:20,970 --> 00:06:25,340
so you can work around it or you could

00:06:23,250 --> 00:06:28,110
connect an external ADC if you wanted to

00:06:25,340 --> 00:06:31,050
so I found these to be really great for

00:06:28,110 --> 00:06:34,500
hobbyists projects and for developing

00:06:31,050 --> 00:06:37,110
prototypes because you've you've got you

00:06:34,500 --> 00:06:39,060
know a decent number of pins exposed

00:06:37,110 --> 00:06:40,129
there and they're all designed to plug

00:06:39,060 --> 00:06:42,589
straight into a breadboard

00:06:40,129 --> 00:06:44,839
to make it really easy to work with they

00:06:42,589 --> 00:06:46,729
do also all support ITC and SPI

00:06:44,839 --> 00:06:49,009
officially there's only software ITC on

00:06:46,729 --> 00:06:52,069
these boards but you know that's good

00:06:49,009 --> 00:06:53,419
enough for prototyping and the board

00:06:52,069 --> 00:06:56,419
that I'm using today is the Adafruit

00:06:53,419 --> 00:07:00,349
further hazhar purely because it's got

00:06:56,419 --> 00:07:02,119
an onboard lithium battery charger which

00:07:00,349 --> 00:07:04,399
just makes it really easy if you're

00:07:02,119 --> 00:07:06,019
developing a small standalone device you

00:07:04,399 --> 00:07:09,229
can plug the battery straight in it

00:07:06,019 --> 00:07:10,699
charges through the micro USB cable so

00:07:09,229 --> 00:07:12,050
that makes it really useful for

00:07:10,699 --> 00:07:15,499
prototyping without having to worry

00:07:12,050 --> 00:07:16,939
about power requirements so this is what

00:07:15,499 --> 00:07:20,300
the pin layout looks like on that

00:07:16,939 --> 00:07:22,490
particular board I apologize is probably

00:07:20,300 --> 00:07:24,379
not very readable but this is pretty

00:07:22,490 --> 00:07:26,749
indicative of the others you've got a

00:07:24,379 --> 00:07:27,919
number of i/o pins down one side and on

00:07:26,749 --> 00:07:29,479
the other side you've got things like

00:07:27,919 --> 00:07:33,409
your 5 volt and your ground and that

00:07:29,479 --> 00:07:35,839
sort of thing so the typical process

00:07:33,409 --> 00:07:39,439
that I use when I'm working on

00:07:35,839 --> 00:07:41,959
developing a project first of all I work

00:07:39,439 --> 00:07:44,899
out the interactions so Internet of

00:07:41,959 --> 00:07:46,490
Things devices you know the ones that I

00:07:44,899 --> 00:07:49,209
build anyway it tends to be very

00:07:46,490 --> 00:07:50,919
interactive and they're designed for

00:07:49,209 --> 00:07:54,019
demonstrating or for working with

00:07:50,919 --> 00:07:56,839
students so I think about the way that I

00:07:54,019 --> 00:07:58,909
want it to work and what what I wanted

00:07:56,839 --> 00:08:01,759
to achieve so for this particular device

00:07:58,909 --> 00:08:04,309
I it's very simple in terms of the

00:08:01,759 --> 00:08:05,869
circuit and the code but really the

00:08:04,309 --> 00:08:08,629
interactions are the important thing it

00:08:05,869 --> 00:08:10,449
needs to be kind of cute and it needs to

00:08:08,629 --> 00:08:13,129
have personality so that will actually

00:08:10,449 --> 00:08:16,339
engage with me and make me want to do my

00:08:13,129 --> 00:08:18,709
exercise so once you've designed the way

00:08:16,339 --> 00:08:20,779
that you want to it to feel and look I

00:08:18,709 --> 00:08:23,059
guess then you work out what components

00:08:20,779 --> 00:08:26,089
you need and what board that you need

00:08:23,059 --> 00:08:29,990
and then the process that I use is they

00:08:26,089 --> 00:08:31,550
typically design my circuit which is

00:08:29,990 --> 00:08:33,110
just plugging in the different

00:08:31,550 --> 00:08:35,419
components which pins I want them to go

00:08:33,110 --> 00:08:36,829
on and then write a program for each

00:08:35,419 --> 00:08:39,409
individual component and get that

00:08:36,829 --> 00:08:42,380
working independently so sort of a

00:08:39,409 --> 00:08:45,500
modular approach so for this particular

00:08:42,380 --> 00:08:49,160
project which has a buzzer a button and

00:08:45,500 --> 00:08:50,809
some LEDs as well as a screen it would

00:08:49,160 --> 00:08:52,850
be developing the programs for each one

00:08:50,809 --> 00:08:53,610
of those and then having functions for

00:08:52,850 --> 00:08:55,200
the

00:08:53,610 --> 00:08:57,990
you know what I want to display on each

00:08:55,200 --> 00:09:00,750
one or how I want it to interact for

00:08:57,990 --> 00:09:02,370
each one and then work on developing the

00:09:00,750 --> 00:09:05,070
program that actually does the

00:09:02,370 --> 00:09:07,850
communication up with my cloud service

00:09:05,070 --> 00:09:11,700
or whatever I'm running on the backend

00:09:07,850 --> 00:09:14,370
and then finally use the repple to

00:09:11,700 --> 00:09:15,870
interactively tweak so one of the great

00:09:14,370 --> 00:09:17,760
things about micro Python is it does

00:09:15,870 --> 00:09:20,880
have that interactive read eval print

00:09:17,760 --> 00:09:23,040
loop so I can go in and I can work out

00:09:20,880 --> 00:09:24,720
exactly what timings I need or exactly

00:09:23,040 --> 00:09:27,750
what colors I want to display on the

00:09:24,720 --> 00:09:30,240
LEDs that sort of thing without having

00:09:27,750 --> 00:09:32,279
to say an Arduino we'd have to go and

00:09:30,240 --> 00:09:34,110
compile it and upload it it would be a

00:09:32,279 --> 00:09:37,529
very slow process being able to do that

00:09:34,110 --> 00:09:40,620
pretty much instantaneously really cuts

00:09:37,529 --> 00:09:42,600
down on the prototyping time when it

00:09:40,620 --> 00:09:46,170
comes to designing those and developing

00:09:42,600 --> 00:09:47,850
those interactions and behavior so for

00:09:46,170 --> 00:09:52,110
this particular project that you can see

00:09:47,850 --> 00:09:53,490
here this is the circuit so it's really

00:09:52,110 --> 00:09:58,320
simple it's only a few components

00:09:53,490 --> 00:10:01,199
there's a 12 ring neopixel there's an O

00:09:58,320 --> 00:10:04,199
LED screen there's a button and there's

00:10:01,199 --> 00:10:08,180
a piezo buzzer that just beeps so that

00:10:04,199 --> 00:10:10,640
I'm forced to pay attention to it so

00:10:08,180 --> 00:10:12,750
what I do is I'll just step you through

00:10:10,640 --> 00:10:13,890
basically what I did for each one of

00:10:12,750 --> 00:10:16,350
those components and how I put it

00:10:13,890 --> 00:10:18,570
together so the first thing I did

00:10:16,350 --> 00:10:19,860
actually was I developed the shell for

00:10:18,570 --> 00:10:21,720
it so this is something that I just

00:10:19,860 --> 00:10:23,579
threw together in a 3d modeling program

00:10:21,720 --> 00:10:25,860
so this is what it looks like on the

00:10:23,579 --> 00:10:28,800
inside it's not a telephone it's it's

00:10:25,860 --> 00:10:31,519
the neopixel and you can see the 3d

00:10:28,800 --> 00:10:34,380
model for the case on the outside so

00:10:31,519 --> 00:10:38,120
this is kind of the shell here that's

00:10:34,380 --> 00:10:40,829
got the OLEDs screen on the inside with

00:10:38,120 --> 00:10:42,570
appearing as eyes and on the inside

00:10:40,829 --> 00:10:49,250
we've got the near pixel and the button

00:10:42,570 --> 00:10:51,360
and the buzzer so before you actually

00:10:49,250 --> 00:10:53,459
put it all together though you need to

00:10:51,360 --> 00:10:55,470
make sure that you've kind of hooked

00:10:53,459 --> 00:10:56,519
everything up and prepared the board

00:10:55,470 --> 00:10:58,079
because you don't want to have to be

00:10:56,519 --> 00:10:59,399
doing things that involve having to

00:10:58,079 --> 00:11:03,120
unplug everything once you've got in the

00:10:59,399 --> 00:11:05,940
case so this is all coming pretty much

00:11:03,120 --> 00:11:06,990
from the documentation for micro path

00:11:05,940 --> 00:11:09,600
and so I won't talk through

00:11:06,990 --> 00:11:11,100
a lot of detail but it's really really

00:11:09,600 --> 00:11:12,720
simple to get it up and running you

00:11:11,100 --> 00:11:14,520
pretty much just install whatever

00:11:12,720 --> 00:11:17,790
drivers you need to talk to the board

00:11:14,520 --> 00:11:19,589
USB serial drivers make sure you've got

00:11:17,790 --> 00:11:22,410
the ESP tool installed on your system

00:11:19,589 --> 00:11:24,180
and then you can use that ESP tool to

00:11:22,410 --> 00:11:27,930
erase the flash if you've used it before

00:11:24,180 --> 00:11:29,550
so I quite often recycle these from

00:11:27,930 --> 00:11:31,830
various projects so they might have had

00:11:29,550 --> 00:11:32,399
some arduino ide code in them that might

00:11:31,830 --> 00:11:36,510
have had Lua

00:11:32,399 --> 00:11:39,270
node MCU environment on them so flash it

00:11:36,510 --> 00:11:41,640
to make sure everything's nice and clean

00:11:39,270 --> 00:11:43,020
and then upload the latest version of

00:11:41,640 --> 00:11:46,830
microwave which you can download from

00:11:43,020 --> 00:11:48,810
the github pages from the releases so

00:11:46,830 --> 00:11:52,800
yeah really simple once you've done that

00:11:48,810 --> 00:11:54,420
you're pretty much ready to go then

00:11:52,800 --> 00:11:56,279
connecting to the board I prefer to use

00:11:54,420 --> 00:11:59,130
a command line I usually see a screen

00:11:56,279 --> 00:12:03,149
from my Mac to connect so just a matter

00:11:59,130 --> 00:12:06,839
of connecting at the 1 1 5 200 board

00:12:03,149 --> 00:12:08,250
rate and then when I'm doing things

00:12:06,839 --> 00:12:10,680
interactively what I'll do is I'll

00:12:08,250 --> 00:12:12,690
develop the code in say sublime text and

00:12:10,680 --> 00:12:15,690
then I just paste it across into my

00:12:12,690 --> 00:12:17,670
terminal using ctrl e to enter paste

00:12:15,690 --> 00:12:20,070
mode with micro Python and I'll

00:12:17,670 --> 00:12:23,430
demonstrate this in a minute talk

00:12:20,070 --> 00:12:25,440
through it first and then if I write

00:12:23,430 --> 00:12:27,630
longer longer files that I don't want to

00:12:25,440 --> 00:12:29,310
paste in I upload them using the am py

00:12:27,630 --> 00:12:31,140
tool which is from Adafruit which I find

00:12:29,310 --> 00:12:35,190
really useful particularly for loading

00:12:31,140 --> 00:12:37,200
up libraries onto the board when I'm

00:12:35,190 --> 00:12:42,510
working with students so I tend to use

00:12:37,200 --> 00:12:44,730
the web Ruppel so that's the web ripple

00:12:42,510 --> 00:12:46,829
there you can pretty much connect to the

00:12:44,730 --> 00:12:48,570
boards so if you've got it set up as an

00:12:46,829 --> 00:12:51,930
access point you can connect directly to

00:12:48,570 --> 00:12:53,430
it or if you have it set up to connect

00:12:51,930 --> 00:12:56,339
to your Wi-Fi network you can just go to

00:12:53,430 --> 00:12:59,190
the IP address and the port is eight to

00:12:56,339 --> 00:13:01,770
six six access it by the Weber Apple

00:12:59,190 --> 00:13:04,950
which just gives you a nice interface

00:13:01,770 --> 00:13:06,300
like this that lets you type in code so

00:13:04,950 --> 00:13:08,190
that's your Apple on the left hand side

00:13:06,300 --> 00:13:11,270
and it gives you a really simple way of

00:13:08,190 --> 00:13:14,160
uploading the files as well to the board

00:13:11,270 --> 00:13:16,560
if you are using that though originally

00:13:14,160 --> 00:13:19,440
it used to be enabled by default but now

00:13:16,560 --> 00:13:20,640
if it's not for I guess obvious security

00:13:19,440 --> 00:13:21,990
reasons so

00:13:20,640 --> 00:13:24,060
if you do want to use it you just need

00:13:21,990 --> 00:13:27,690
to make sure you import the Weber apples

00:13:24,060 --> 00:13:29,310
setup and then enable it on boot or if

00:13:27,690 --> 00:13:31,769
you prefer just import it as you need it

00:13:29,310 --> 00:13:38,339
and start it and stop it directly from

00:13:31,769 --> 00:13:40,430
the repple so when you do set up your

00:13:38,339 --> 00:13:42,959
device at first it will be set up as

00:13:40,430 --> 00:13:44,610
with an ad-hoc Wi-Fi network and the

00:13:42,959 --> 00:13:48,060
default password is micro Python with

00:13:44,610 --> 00:13:51,300
capital N it's a really good idea to

00:13:48,060 --> 00:13:52,649
change that so especially if you're

00:13:51,300 --> 00:13:54,570
coming to something like this so that

00:13:52,649 --> 00:13:55,649
someone doesn't hack into device while

00:13:54,570 --> 00:14:02,279
you're in the middle of a demo it has

00:13:55,649 --> 00:14:03,899
happened so yes so yeah this is how you

00:14:02,279 --> 00:14:06,990
do that you just set it up in the main

00:14:03,899 --> 00:14:09,870
dot py and upload that aren't your your

00:14:06,990 --> 00:14:11,880
board and yeah then you could at least

00:14:09,870 --> 00:14:13,620
got a different password probably can

00:14:11,880 --> 00:14:17,550
still hack into it but it might take

00:14:13,620 --> 00:14:22,380
them a bit longer so that's getting set

00:14:17,550 --> 00:14:24,480
up developing programs so I typically

00:14:22,380 --> 00:14:27,720
start with the simplest thing so in this

00:14:24,480 --> 00:14:30,120
particular example it's the button so a

00:14:27,720 --> 00:14:34,140
button just needs two wires I've got

00:14:30,120 --> 00:14:38,160
mine connected up on pin 12 just ground

00:14:34,140 --> 00:14:40,410
in pin 12 and it's super super easy to

00:14:38,160 --> 00:14:41,640
get this working on micro pythons so you

00:14:40,410 --> 00:14:45,329
pretty much important the machine

00:14:41,640 --> 00:14:48,510
library or did you just the pin classes

00:14:45,329 --> 00:14:50,279
all we need in this case set it up using

00:14:48,510 --> 00:14:52,529
the pin class on the pin that you want

00:14:50,279 --> 00:14:54,750
so pin 12 till it's an input mode and

00:14:52,529 --> 00:14:56,399
I've also set it up with the additional

00:14:54,750 --> 00:14:58,199
parameter to tell it to use the built-in

00:14:56,399 --> 00:15:00,600
pull-up resistor on the board because I

00:14:58,199 --> 00:15:02,519
didn't want to have an extra resistor in

00:15:00,600 --> 00:15:05,370
my circuit don't have a lot of space in

00:15:02,519 --> 00:15:07,110
there and once you've done that you can

00:15:05,370 --> 00:15:11,610
just get the button value using button

00:15:07,110 --> 00:15:13,290
dot value so if you want to do something

00:15:11,610 --> 00:15:15,240
in response to that button press or the

00:15:13,290 --> 00:15:18,149
simplest way to do it is just to pull

00:15:15,240 --> 00:15:20,850
the value of the button so just setting

00:15:18,149 --> 00:15:22,140
up a loop taking a reading it's always a

00:15:20,850 --> 00:15:25,079
good idea to take a couple of readings

00:15:22,140 --> 00:15:27,269
to compare and then yeah pretty much you

00:15:25,079 --> 00:15:30,470
can just use that to work out when the

00:15:27,269 --> 00:15:30,470
button is pressed and when it's released

00:15:30,620 --> 00:15:34,380
so you can do a really similar thing

00:15:33,029 --> 00:15:36,390
with analog sensors I don't

00:15:34,380 --> 00:15:38,760
having analog sensor in this particular

00:15:36,390 --> 00:15:40,680
example but if you are using your analog

00:15:38,760 --> 00:15:45,300
sensor you just use machined or ADC

00:15:40,680 --> 00:15:47,490
instead of using a pin so very very

00:15:45,300 --> 00:15:50,250
simple the only gotcha on these

00:15:47,490 --> 00:15:53,280
particular boards the esp8266 is is that

00:15:50,250 --> 00:15:55,530
you can only have a 1 volt voltage on

00:15:53,280 --> 00:15:57,060
that pin so if you are using a sensor

00:15:55,530 --> 00:15:58,980
that you've Sayed taken from an Arduino

00:15:57,060 --> 00:16:01,530
kit or something like that you need to

00:15:58,980 --> 00:16:02,880
make sure that you have set it up with a

00:16:01,530 --> 00:16:07,950
voltage divider so that you don't

00:16:02,880 --> 00:16:12,390
destroy your board ok so that's a button

00:16:07,950 --> 00:16:17,400
a buzzer also very simple two wires I've

00:16:12,390 --> 00:16:19,680
got mine plugged into pin 14 and again

00:16:17,400 --> 00:16:21,420
really really simple stuff this one's a

00:16:19,680 --> 00:16:24,300
bit different because rather than just

00:16:21,420 --> 00:16:26,190
being a digital reading on or off this

00:16:24,300 --> 00:16:29,010
is actually an output device and I'm

00:16:26,190 --> 00:16:32,190
writing to it so you can write to a

00:16:29,010 --> 00:16:35,630
digital pin using high and low or on and

00:16:32,190 --> 00:16:38,550
off but you can also write using PWM

00:16:35,630 --> 00:16:40,740
pulse width modulation so for something

00:16:38,550 --> 00:16:43,710
like piezo buzzer if you want to play

00:16:40,740 --> 00:16:45,420
different tones you'd set it up so you

00:16:43,710 --> 00:16:48,780
still import the pin class but also

00:16:45,420 --> 00:16:50,010
import PWM I've set up just a couple of

00:16:48,780 --> 00:16:53,310
different notes these are just the

00:16:50,010 --> 00:16:56,940
frequencies of those notes and then set

00:16:53,310 --> 00:16:58,140
it up on pin 14 in output mode and then

00:16:56,940 --> 00:17:01,260
it's as simple as just using the

00:16:58,140 --> 00:17:05,520
frequency so here's our dot freak to

00:17:01,260 --> 00:17:08,819
play the time and then finally DN it

00:17:05,520 --> 00:17:10,230
because as soon as you initialize it it

00:17:08,819 --> 00:17:11,579
will start making so this is not one

00:17:10,230 --> 00:17:13,530
that you want to do using the ripple

00:17:11,579 --> 00:17:15,540
necessarily because it's just kind of be

00:17:13,530 --> 00:17:17,430
squealing the whole time and when you

00:17:15,540 --> 00:17:21,510
have a whole class of kids doing that it

00:17:17,430 --> 00:17:26,430
gets a bit so yeah make sure you have

00:17:21,510 --> 00:17:28,560
that D in it there in the end one of the

00:17:26,430 --> 00:17:30,390
the components is really really popular

00:17:28,560 --> 00:17:32,520
with the students that I teach and that

00:17:30,390 --> 00:17:34,980
I love putting in my devices are

00:17:32,520 --> 00:17:38,160
neopixels so this is a two fruits

00:17:34,980 --> 00:17:39,930
marketing term for the ws2812 be light

00:17:38,160 --> 00:17:42,690
source which are pretty much just

00:17:39,930 --> 00:17:45,850
extremely brightly colored addressable

00:17:42,690 --> 00:17:47,230
LEDs and they are awesome

00:17:45,850 --> 00:17:50,470
they come in lots of different form

00:17:47,230 --> 00:17:53,049
factors you can get them in strips by

00:17:50,470 --> 00:17:54,700
the meter or you get them as individual

00:17:53,049 --> 00:17:58,660
components you can buy them in these

00:17:54,700 --> 00:18:01,390
rings or in the bar form and these can

00:17:58,660 --> 00:18:03,460
be in theory they need five volts but

00:18:01,390 --> 00:18:05,200
you can dry them off 3.3 volts which is

00:18:03,460 --> 00:18:07,210
great because you don't need an external

00:18:05,200 --> 00:18:11,140
battery if you're using only a small

00:18:07,210 --> 00:18:13,870
number of pixels so I've found pretty

00:18:11,140 --> 00:18:16,809
much out to about thirty or forty pixels

00:18:13,870 --> 00:18:19,419
is usually fine on just coming off the

00:18:16,809 --> 00:18:20,590
microcontroller pin up once you get

00:18:19,419 --> 00:18:23,830
beyond that you want to add some

00:18:20,590 --> 00:18:27,880
batteries so you can find out all about

00:18:23,830 --> 00:18:29,980
them on the Adafruit website but they're

00:18:27,880 --> 00:18:33,789
really really easy that pretty much

00:18:29,980 --> 00:18:35,919
designed to run off a single pin so

00:18:33,789 --> 00:18:38,429
you've got your power source and your

00:18:35,919 --> 00:18:41,740
ground but then you connect a single

00:18:38,429 --> 00:18:43,720
digital i/o pin to any number of pixels

00:18:41,740 --> 00:18:46,210
and you can chain them together as well

00:18:43,720 --> 00:18:47,740
so each ring will have an out pin as

00:18:46,210 --> 00:18:49,510
well that you can chain onto additional

00:18:47,740 --> 00:18:51,159
rings so if you've got a project that

00:18:49,510 --> 00:18:55,390
needs to have lots of pixels you connect

00:18:51,159 --> 00:18:58,419
them that way now there is a built in

00:18:55,390 --> 00:19:00,909
near pixel class in mica Python which is

00:18:58,419 --> 00:19:04,570
why I really like using these it's very

00:19:00,909 --> 00:19:06,909
very simple so you can just import the

00:19:04,570 --> 00:19:09,360
new pixel class and the pin class so you

00:19:06,909 --> 00:19:11,830
set up the pin first as an output pin

00:19:09,360 --> 00:19:13,870
and then you set up the neopixel class

00:19:11,830 --> 00:19:15,280
to use that pin and you tell her the

00:19:13,870 --> 00:19:17,799
number of pixels that you want to

00:19:15,280 --> 00:19:20,500
control and then it's as simple as just

00:19:17,799 --> 00:19:26,380
sending a couple of RGB values red green

00:19:20,500 --> 00:19:30,010
blue values to a pin to a pixel within

00:19:26,380 --> 00:19:33,190
that so this is an example of just some

00:19:30,010 --> 00:19:34,990
really simple code that I wrote that

00:19:33,190 --> 00:19:38,200
will you know actually iterate through

00:19:34,990 --> 00:19:40,750
the pixels and for the near pixel at

00:19:38,200 --> 00:19:42,370
that pixel number it'll set it to a

00:19:40,750 --> 00:19:44,710
particular color so it's just going to

00:19:42,370 --> 00:19:47,110
set them all to be particular color or

00:19:44,710 --> 00:19:50,740
clear them by setting the values all to

00:19:47,110 --> 00:19:52,929
zero and obviously you can do much more

00:19:50,740 --> 00:19:55,210
interesting things you can set different

00:19:52,929 --> 00:19:57,690
colors you can have animations and that

00:19:55,210 --> 00:19:57,690
sort of thing

00:19:58,610 --> 00:20:03,030
so those are all built-in libraries one

00:20:01,590 --> 00:20:05,220
of the really cool things about micro

00:20:03,030 --> 00:20:07,799
Python ecosystem is that there are lots

00:20:05,220 --> 00:20:09,510
of third-party libraries as well and I

00:20:07,799 --> 00:20:11,909
found the ones that Adafruit develops to

00:20:09,510 --> 00:20:13,559
be particularly cool they already had a

00:20:11,909 --> 00:20:17,580
lot of libraries that I was using in

00:20:13,559 --> 00:20:19,080
Arduino sort of sea land and some of

00:20:17,580 --> 00:20:21,659
them have been ported across to micro

00:20:19,080 --> 00:20:24,659
Python so one that I was using for the

00:20:21,659 --> 00:20:30,390
screen and the eyes here is the SSD 1306

00:20:24,659 --> 00:20:32,730
a LED library and pretty much getting

00:20:30,390 --> 00:20:36,720
that working you just go and grab the

00:20:32,730 --> 00:20:40,020
MPI file from the repository and then

00:20:36,720 --> 00:20:42,000
upload it to the board using a mpy and

00:20:40,020 --> 00:20:43,919
this is an example this screen is an i2c

00:20:42,000 --> 00:20:48,210
component so it's an example of using

00:20:43,919 --> 00:20:54,240
i2c so you import the library set up the

00:20:48,210 --> 00:20:56,309
IPC component use an ITC class and just

00:20:54,240 --> 00:20:57,929
for backwards compatibility with arduino

00:20:56,309 --> 00:21:00,270
so not sure how many of you are familiar

00:20:57,929 --> 00:21:04,710
with working with arduino but typically

00:21:00,270 --> 00:21:07,020
on arduino analog pins four and five are

00:21:04,710 --> 00:21:08,909
the pins that are used for ITC and

00:21:07,020 --> 00:21:11,730
although technically you can use any of

00:21:08,909 --> 00:21:14,520
the pins on the esp8266 for ITC because

00:21:11,730 --> 00:21:18,299
it's software ITC by convention

00:21:14,520 --> 00:21:21,750
pretty much everyone uses 4 & 5 so you

00:21:18,299 --> 00:21:24,270
set up your LED display using that ITC

00:21:21,750 --> 00:21:26,960
clasp just telling it the dimensions of

00:21:24,270 --> 00:21:29,789
display and then you're ready to display

00:21:26,960 --> 00:21:32,130
so very very simple to get up and

00:21:29,789 --> 00:21:36,270
running with third-party libraries as

00:21:32,130 --> 00:21:38,429
well but once you've got all those bits

00:21:36,270 --> 00:21:39,900
and pieces all kind of doing something

00:21:38,429 --> 00:21:41,370
what you want to do is to be able to

00:21:39,900 --> 00:21:43,919
pull it all together and to actually get

00:21:41,370 --> 00:21:47,039
it talking to something in the cloud I

00:21:43,919 --> 00:21:49,470
mean that's Internet of Things so we

00:21:47,039 --> 00:21:51,659
need to have the Internet component by

00:21:49,470 --> 00:21:55,110
far the simplest way to get that up and

00:21:51,659 --> 00:21:58,020
running is just using HTTP POST requests

00:21:55,110 --> 00:22:02,460
so run a really simple web server on the

00:21:58,020 --> 00:22:04,860
esp8266 and talk to that so this is an

00:22:02,460 --> 00:22:08,280
example and I'll actually do this as a

00:22:04,860 --> 00:22:11,900
demo hopefully it'll work an example of

00:22:08,280 --> 00:22:13,730
a basic web server based on

00:22:11,900 --> 00:22:16,330
one that was sort of I think it might

00:22:13,730 --> 00:22:20,809
have been one of the Adafruit examples

00:22:16,330 --> 00:22:24,860
so you pretty much have the HTML that

00:22:20,809 --> 00:22:26,600
you want to display and we've set up the

00:22:24,860 --> 00:22:27,850
NIR pixels and we've got that color

00:22:26,600 --> 00:22:31,130
white function that we saw just before

00:22:27,850 --> 00:22:33,409
and then to kind of pull this all

00:22:31,130 --> 00:22:37,690
together and make it a network enabled

00:22:33,409 --> 00:22:42,650
device we just use socket modules so

00:22:37,690 --> 00:22:45,230
pretty much just a loop that reads the

00:22:42,650 --> 00:22:48,320
requesters they come in and is looking

00:22:45,230 --> 00:22:50,090
for just a particular string in that

00:22:48,320 --> 00:22:54,140
request so it's looking for an ear pixel

00:22:50,090 --> 00:22:56,960
on or near pixel off and will simply

00:22:54,140 --> 00:22:59,000
respond by turning the new pixels on or

00:22:56,960 --> 00:23:01,190
off just to a single color in this case

00:22:59,000 --> 00:23:02,750
based on whether or not that's in the

00:23:01,190 --> 00:23:07,490
string so let me just show you that

00:23:02,750 --> 00:23:14,559
working live demo hopefully this will

00:23:07,490 --> 00:23:14,559
work all right

00:23:21,740 --> 00:23:25,309
this is the one I've got connected I

00:23:23,600 --> 00:23:34,100
apologize I have way too many channels

00:23:25,309 --> 00:23:36,620
open alright so this one let's just

00:23:34,100 --> 00:23:40,570
check it's still alive

00:23:36,620 --> 00:23:44,750
yep see if I can zoom in on that a bit

00:23:40,570 --> 00:23:50,179
kids alright so this has this is the

00:23:44,750 --> 00:23:52,880
Myka Python repple and to run that web

00:23:50,179 --> 00:23:58,220
server code what I'll do is I'll just go

00:23:52,880 --> 00:24:01,850
grab it I've got it set up I did have it

00:23:58,220 --> 00:24:04,490
I just find it that looks like it there

00:24:01,850 --> 00:24:06,020
so all I do is I'll just I could upload

00:24:04,490 --> 00:24:08,920
that as a file but I'm just gonna copy

00:24:06,020 --> 00:24:10,429
and paste it straight into the ruffball

00:24:08,920 --> 00:24:13,660
there it is

00:24:10,429 --> 00:24:18,470
so hit ctrl e and you go into paste mode

00:24:13,660 --> 00:24:22,370
paste that in and then ctrl D oh no I

00:24:18,470 --> 00:24:28,130
forgot to import the library let me just

00:24:22,370 --> 00:24:30,640
go and check yeah let me just go grab

00:24:28,130 --> 00:24:30,640
that from

00:24:33,130 --> 00:24:39,520
yeah

00:24:35,270 --> 00:24:39,520
that's why you should not do live demos

00:24:43,090 --> 00:24:47,649
already are hand machined up in I

00:24:49,179 --> 00:24:56,320
probably edited this just before yeah

00:24:54,260 --> 00:25:06,950
thank you

00:24:56,320 --> 00:25:09,799
all right let's try this okay all right

00:25:06,950 --> 00:25:12,020
so now that's running as a webserver and

00:25:09,799 --> 00:25:15,980
what I will do is I'll just go and I'll

00:25:12,020 --> 00:25:20,299
join that access point just right there

00:25:15,980 --> 00:25:28,640
and if I go to a browser let's just open

00:25:20,299 --> 00:25:34,039
this one 6h now by default it will be on

00:25:28,640 --> 00:25:35,779
1 & 2 1 6 8 4.1 yes good so I should in

00:25:34,039 --> 00:25:42,380
theory be able to hit the on and off

00:25:35,779 --> 00:25:47,690
button yeah and it's not working these

00:25:42,380 --> 00:25:52,070
would be read live demos yes so anyway

00:25:47,690 --> 00:25:58,130
that does work when the robot is not

00:25:52,070 --> 00:26:05,980
broken oh no time it's not okay that

00:25:58,130 --> 00:26:05,980
could be why show it again

00:26:16,570 --> 00:26:30,380
oh yeah control dude thank you yeah okay

00:26:26,350 --> 00:26:41,779
try this again just so this is how you

00:26:30,380 --> 00:26:43,909
connect Joey Jody

00:26:41,779 --> 00:26:55,730
fingers crossed oh let me try it one

00:26:43,909 --> 00:26:57,230
more time right yes that's why I was

00:26:55,730 --> 00:27:00,080
changing them to blue and I must have

00:26:57,230 --> 00:27:03,470
somehow messed my code up should have

00:27:00,080 --> 00:27:10,039
stuck with the red all right I thought

00:27:03,470 --> 00:27:12,080
it looked angry sorry okay that's that's

00:27:10,039 --> 00:27:16,070
how you do a web server

00:27:12,080 --> 00:27:18,140
I find that basic HTTP web server kind

00:27:16,070 --> 00:27:20,570
of approach works really well for demos

00:27:18,140 --> 00:27:22,100
and for prototyping but if you want to

00:27:20,570 --> 00:27:24,620
integrate with kind of the wider

00:27:22,100 --> 00:27:27,770
Internet of Things world you should

00:27:24,620 --> 00:27:30,049
probably use MQTT or something like MQTT

00:27:27,770 --> 00:27:33,070
so very simple messaging this is an

00:27:30,049 --> 00:27:38,510
example of a really simple MQTT program

00:27:33,070 --> 00:27:40,730
that pretty much sends the button events

00:27:38,510 --> 00:27:43,549
to a server so this is what I would use

00:27:40,730 --> 00:27:47,659
to notify that yes I have indeed done my

00:27:43,549 --> 00:27:51,289
exercise so you import the UM TTT which

00:27:47,659 --> 00:27:53,450
is built-in and you can there's some

00:27:51,289 --> 00:27:55,760
examples you can find that do stuff with

00:27:53,450 --> 00:27:57,169
Jason and putting in adjacent file done

00:27:55,760 --> 00:27:58,789
dramatically riding it and loading it in

00:27:57,169 --> 00:28:00,260
on start I highly recommend you do that

00:27:58,789 --> 00:28:03,260
I couldn't fit it on one slide though so

00:28:00,260 --> 00:28:04,880
I've got rid of all of that but it works

00:28:03,260 --> 00:28:06,440
the same way so it has all of your

00:28:04,880 --> 00:28:09,980
configuration in terms of which server

00:28:06,440 --> 00:28:13,520
and which channel which topic you're

00:28:09,980 --> 00:28:15,409
using an MQTT so it's just pub/sub so in

00:28:13,520 --> 00:28:17,210
this case it's like my button code from

00:28:15,409 --> 00:28:19,700
before I'm getting the button value

00:28:17,210 --> 00:28:21,200
getting a second reading comparing that

00:28:19,700 --> 00:28:23,299
to work out if I've actually got the

00:28:21,200 --> 00:28:26,630
button pressed and if it is that I'm

00:28:23,299 --> 00:28:28,700
publishing that button press event so

00:28:26,630 --> 00:28:30,470
let me just have a quick

00:28:28,700 --> 00:28:37,840
quick go and see if this can actually

00:28:30,470 --> 00:28:47,390
run very very quickly get rid of that

00:28:37,840 --> 00:28:50,350
all right so that would be need to

00:28:47,390 --> 00:28:53,179
actually make sure I'm running an MQTT

00:28:50,350 --> 00:28:57,650
service I'm running mosquito here on my

00:28:53,179 --> 00:29:01,400
local laptop and in another terminal I

00:28:57,650 --> 00:29:03,520
would need to have a mosquito client

00:29:01,400 --> 00:29:09,080
that's subscribing to the button events

00:29:03,520 --> 00:29:19,669
see that and then finally I need to have

00:29:09,080 --> 00:29:22,000
my mqtt program running here and then

00:29:19,669 --> 00:29:26,450
let me go back to that all the window

00:29:22,000 --> 00:29:28,130
hopefully when I press the button yeah

00:29:26,450 --> 00:29:29,750
it's getting pressed events there so

00:29:28,130 --> 00:29:31,010
this is not very impressive because like

00:29:29,750 --> 00:29:32,510
this is kind of what's happening on the

00:29:31,010 --> 00:29:35,510
back end but you get the idea you could

00:29:32,510 --> 00:29:39,470
have it storing the database or doing

00:29:35,510 --> 00:29:40,580
something cool so there's that and it's

00:29:39,470 --> 00:29:42,620
super as you can see it's super easy

00:29:40,580 --> 00:29:49,130
much easier than the web server to get

00:29:42,620 --> 00:29:52,820
right alright so there are lots of other

00:29:49,130 --> 00:29:53,240
languages you can use for doing this so

00:29:52,820 --> 00:29:58,160
Lua

00:29:53,240 --> 00:30:01,040
Arduino it's pre node.js for example but

00:29:58,160 --> 00:30:03,520
I really like using micro Python because

00:30:01,040 --> 00:30:05,540
the code is really clean and intuitive

00:30:03,520 --> 00:30:07,970
excellent for teaching students are

00:30:05,540 --> 00:30:10,340
already using Python and as I said that

00:30:07,970 --> 00:30:12,860
interactive repple you can't beat that

00:30:10,340 --> 00:30:14,900
for just working out what you're doing

00:30:12,860 --> 00:30:16,490
in terms of the interactions and the

00:30:14,900 --> 00:30:19,250
other really cool thing I think is going

00:30:16,490 --> 00:30:20,600
to be big is edge computing that's the

00:30:19,250 --> 00:30:22,160
idea where you do your processing as

00:30:20,600 --> 00:30:23,540
close to the data collection point as

00:30:22,160 --> 00:30:25,880
possible at the edges of your networks

00:30:23,540 --> 00:30:28,130
so on the board or on a gateway device

00:30:25,880 --> 00:30:29,720
and we all know that python is awesome

00:30:28,130 --> 00:30:32,360
for doing data processing and that sort

00:30:29,720 --> 00:30:34,970
of thing so I think there's really going

00:30:32,360 --> 00:30:37,580
to be great applications for edge

00:30:34,970 --> 00:30:40,460
computing with micro Python I've run out

00:30:37,580 --> 00:30:42,050
of time so this is we can find out more

00:30:40,460 --> 00:30:44,690
my blog

00:30:42,050 --> 00:30:46,100
on Twitter or yeah the micro Python

00:30:44,690 --> 00:30:57,470
documentation is awesome so thank you

00:30:46,100 --> 00:30:59,000
very much thank you Anna that was a

00:30:57,470 --> 00:31:05,870
wonderful talk

00:30:59,000 --> 00:31:16,490
and I'm sure your students enjoy it as

00:31:05,870 --> 00:31:19,220
much as we did thank you there's a ten

00:31:16,490 --> 00:31:21,610
minutes break now till the next one

00:31:19,220 --> 00:31:21,610

YouTube URL: https://www.youtube.com/watch?v=8Uw1UW0_nHE


