Title: Using Python For Creating Hardware To Record FOSS Conferences
Publication date: 2017-08-05
Playlist: Pycon Australia 2017
Description: 
	Tim 'mithro' Ansell

http://2017.pycon-au.org/schedule/presentation/72/

#pyconau

This talk was given at PyCon Australia 2017 which was held from 3-8 August, 2017 in Melbourne, Victoria.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2017, we're returning to Melbourne, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

August 3-8 2017, Melbourne, Victoria

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:04,350
TuneIn tea I've been asked to make this

00:00:02,159 --> 00:00:05,490
the shortest introduction possible so we

00:00:04,350 --> 00:00:08,250
can get through get into the

00:00:05,490 --> 00:00:10,469
presentation so this afternoon it's a

00:00:08,250 --> 00:00:12,509
pleasure to have Tim Ansel speaking you

00:00:10,469 --> 00:00:14,040
might remember him from such projects as

00:00:12,509 --> 00:00:15,120
the hardware that runs all the video

00:00:14,040 --> 00:00:21,900
stuff at this conference

00:00:15,120 --> 00:00:27,390
so please welcome Tim Freese talk hi Ron

00:00:21,900 --> 00:00:29,580
I'm Tim you can contact me on Twitter

00:00:27,390 --> 00:00:34,770
with Atma Thoreau if you want to see the

00:00:29,580 --> 00:00:37,350
slides that is a link to it pi HW icon

00:00:34,770 --> 00:00:39,870
2017 and the project I'm mostly going to

00:00:37,350 --> 00:00:42,780
be talking about is the HDMI to USB and

00:00:39,870 --> 00:00:45,210
I've got 107 slides and 30 minutes to

00:00:42,780 --> 00:00:48,050
get through them so this is gonna be fun

00:00:45,210 --> 00:00:52,020
I'm gonna talk very fast for some of it

00:00:48,050 --> 00:00:59,640
so maybe my slide would go to the next

00:00:52,020 --> 00:01:03,480
one so I love Python I might have

00:00:59,640 --> 00:01:05,729
started a conference about it and I

00:01:03,480 --> 00:01:08,220
really love Python but I'm also

00:01:05,729 --> 00:01:10,110
practical I think that you should use

00:01:08,220 --> 00:01:16,680
the right tool for the right job

00:01:10,110 --> 00:01:19,409
not everything is a nail and so a couple

00:01:16,680 --> 00:01:24,479
of years ago I would have not said that

00:01:19,409 --> 00:01:30,240
Python was the right choice to do FPGA

00:01:24,479 --> 00:01:34,710
hardware stuff but now I say yes and

00:01:30,240 --> 00:01:37,110
this is the story of why you should as

00:01:34,710 --> 00:01:39,750
well and how it's going to make you more

00:01:37,110 --> 00:01:45,420
productive and this slide here is to

00:01:39,750 --> 00:01:52,890
remind me to stop and take a drink so

00:01:45,420 --> 00:01:55,439
story time so I created a free software

00:01:52,890 --> 00:01:57,060
project could Tim videos the URL was

00:01:55,439 --> 00:02:00,390
team videos to us

00:01:57,060 --> 00:02:04,020
so Tim videos us I'm very creative with

00:02:00,390 --> 00:02:06,869
naming things and its aim is to record

00:02:04,020 --> 00:02:11,000
and livestream conferences so this is

00:02:06,869 --> 00:02:14,750
what a recording and live streaming of a

00:02:11,000 --> 00:02:14,750
conference set up looks like

00:02:15,140 --> 00:02:22,830
you've got a mixing station back here

00:02:18,030 --> 00:02:25,380
that actually runs Python we have some

00:02:22,830 --> 00:02:25,860
capture systems up the front and not the

00:02:25,380 --> 00:02:29,010
back

00:02:25,860 --> 00:02:33,780
they run Python we have a streaming

00:02:29,010 --> 00:02:36,930
system in the cloud that runs Python we

00:02:33,780 --> 00:02:40,769
have a website that runs Jing though

00:02:36,930 --> 00:02:42,540
which is Python and you know a

00:02:40,769 --> 00:02:45,360
conference like this presentations are

00:02:42,540 --> 00:02:47,730
in Python and some say even I'm on

00:02:45,360 --> 00:02:49,319
Python but there are two things that I

00:02:47,730 --> 00:02:55,680
didn't point out and they're these

00:02:49,319 --> 00:02:59,549
capture hardware they might not run

00:02:55,680 --> 00:03:01,069
Python they do now but I will explain

00:02:59,549 --> 00:03:05,340
how we got there

00:03:01,069 --> 00:03:08,010
so what we want to do is capture the

00:03:05,340 --> 00:03:10,860
slides there on the screen and to do

00:03:08,010 --> 00:03:13,260
that we basically put a box in between

00:03:10,860 --> 00:03:15,269
the presenter and the screen and

00:03:13,260 --> 00:03:19,019
basically do a man-in-the-middle attack

00:03:15,269 --> 00:03:22,109
of their video and so we developed some

00:03:19,019 --> 00:03:25,290
hardware to do that the PS is a webcam

00:03:22,109 --> 00:03:26,790
and a serial port the webcam has the

00:03:25,290 --> 00:03:29,220
presentation video and then we pipe it

00:03:26,790 --> 00:03:31,049
into whatever capture software we want

00:03:29,220 --> 00:03:33,060
we also have a serial port which gives

00:03:31,049 --> 00:03:35,430
us all types of very interesting debug

00:03:33,060 --> 00:03:40,440
information about what's going on in the

00:03:35,430 --> 00:03:42,780
system and that allows us to tell what's

00:03:40,440 --> 00:03:44,880
going on like is the presenter sending

00:03:42,780 --> 00:03:46,500
the wrong resolution or is the cable

00:03:44,880 --> 00:03:48,690
dodgy or any of these type of things

00:03:46,500 --> 00:03:51,420
without having to just guess we can

00:03:48,690 --> 00:03:54,900
actually know what's going on which is

00:03:51,420 --> 00:03:57,750
really cool the whole system is based

00:03:54,900 --> 00:03:59,340
around FPGA and FPGA are these cool

00:03:57,750 --> 00:04:01,799
things that make hardware problems

00:03:59,340 --> 00:04:04,560
software problems and software's really

00:04:01,799 --> 00:04:07,170
great in that you can make a mistake and

00:04:04,560 --> 00:04:09,930
you can fix it later when you make a

00:04:07,170 --> 00:04:12,690
mistake in hardware you either live with

00:04:09,930 --> 00:04:15,350
it or you do a product recall and huge

00:04:12,690 --> 00:04:18,930
hassle with all these type of things

00:04:15,350 --> 00:04:21,599
whereas with FPGA is you just fix the

00:04:18,930 --> 00:04:23,940
description on the hardware send out an

00:04:21,599 --> 00:04:26,789
update and you get new stuff you want to

00:04:23,940 --> 00:04:28,410
get new features and so that's really

00:04:26,789 --> 00:04:31,599
good

00:04:28,410 --> 00:04:37,180
the two major languages that are used to

00:04:31,599 --> 00:04:39,159
program for FPGAs Bariloche and VHDL you

00:04:37,180 --> 00:04:43,810
might notice something that neither of

00:04:39,159 --> 00:04:47,050
these are Python however I did sales

00:04:43,810 --> 00:04:50,919
practical and most people use these

00:04:47,050 --> 00:04:54,310
tools so it's generally a good idea to

00:04:50,919 --> 00:04:56,349
go with what the most popular solution

00:04:54,310 --> 00:04:58,870
to a problem is unless there's a very

00:04:56,349 --> 00:05:02,770
very good reason otherwise and at the

00:04:58,870 --> 00:05:05,440
time we didn't have a good use case

00:05:02,770 --> 00:05:07,659
about why we should be special why we

00:05:05,440 --> 00:05:12,729
shouldn't use the tools everybody else

00:05:07,659 --> 00:05:15,430
was using and so we decided to make a

00:05:12,729 --> 00:05:19,360
choice of developing the firmware for

00:05:15,430 --> 00:05:23,500
the FPGA in a mixture of VHDL and

00:05:19,360 --> 00:05:26,259
Verilog and we had a mostly working for

00:05:23,500 --> 00:05:31,599
this board here which is the Digital

00:05:26,259 --> 00:05:35,860
atlas but it took us three years we only

00:05:31,599 --> 00:05:37,599
had a basic set of features we didn't

00:05:35,860 --> 00:05:41,889
have things like Ethernet support or

00:05:37,599 --> 00:05:44,159
buffering or any of these really more

00:05:41,889 --> 00:05:49,389
advanced features we want to support and

00:05:44,159 --> 00:05:52,810
the licensing around the VHDL Bariloche

00:05:49,389 --> 00:05:54,669
we're using is complicated we're using

00:05:52,810 --> 00:05:57,310
some very log and VHDL that was

00:05:54,669 --> 00:06:00,340
automatically generated by the FPGA

00:05:57,310 --> 00:06:02,319
vendor and technically their clause says

00:06:00,340 --> 00:06:04,569
you can only use it on their hardware I

00:06:02,319 --> 00:06:07,090
mean most the time it only makes sense

00:06:04,569 --> 00:06:09,520
to use it on their hardware because it

00:06:07,090 --> 00:06:11,580
uses specific it's optimized for the way

00:06:09,520 --> 00:06:14,289
they hardware works but it does mean

00:06:11,580 --> 00:06:16,750
technically it's not open source if you

00:06:14,289 --> 00:06:18,039
can't use this reuse the code or a

00:06:16,750 --> 00:06:21,270
different piece of hardware that's not

00:06:18,039 --> 00:06:24,330
open source so complicated licensing and

00:06:21,270 --> 00:06:26,710
then I decided to make my own hardware

00:06:24,330 --> 00:06:29,080
because I wanted my hardware to be open

00:06:26,710 --> 00:06:31,870
source anybody can you know make copies

00:06:29,080 --> 00:06:33,819
modify it change it and so we developed

00:06:31,870 --> 00:06:38,080
our own open hardware it's very similar

00:06:33,819 --> 00:06:41,110
in design to the commercial Atlas board

00:06:38,080 --> 00:06:45,159
we were using but it's not identical

00:06:41,110 --> 00:06:47,560
and it's different enough in that it has

00:06:45,159 --> 00:06:50,139
a bunch more features that we would've

00:06:47,560 --> 00:06:52,150
loved to have on the dev board but there

00:06:50,139 --> 00:06:55,659
is dev board it's not specifically

00:06:52,150 --> 00:06:58,569
designed for us it has expansion

00:06:55,659 --> 00:07:03,340
capabilities and it has some high speed

00:06:58,569 --> 00:07:05,979
stuff and it's very similar but it's

00:07:03,340 --> 00:07:08,169
different enough that is not identical

00:07:05,979 --> 00:07:12,430
we can't just run the same code on both

00:07:08,169 --> 00:07:16,139
of them and both very loud and VHDL make

00:07:12,430 --> 00:07:18,909
it quite hard to have this type of

00:07:16,139 --> 00:07:20,590
specialization where you have two very

00:07:18,909 --> 00:07:24,780
similar things so you want to share a

00:07:20,590 --> 00:07:27,580
large amount of stuff but you want to

00:07:24,780 --> 00:07:30,340
have some type of customizations and

00:07:27,580 --> 00:07:35,139
those customizations may run quite deep

00:07:30,340 --> 00:07:39,039
into the system like the data width of

00:07:35,139 --> 00:07:41,620
something might be 16 bits instead of 8

00:07:39,039 --> 00:07:45,219
bits and that runs throughout the whole

00:07:41,620 --> 00:07:47,800
system and you don't want to have to

00:07:45,219 --> 00:07:49,449
rewrite your system to have an 8-bit

00:07:47,800 --> 00:07:51,039
version a 16-bit version you just want

00:07:49,449 --> 00:07:56,169
to be out to adapt to the width and

00:07:51,039 --> 00:07:58,900
things like that so we're in kind of a

00:07:56,169 --> 00:07:59,889
quandary it taken us a long time I was

00:07:58,900 --> 00:08:06,279
getting nowhere I was getting

00:07:59,889 --> 00:08:10,150
demotivated and I came across this this

00:08:06,279 --> 00:08:15,099
is the mix EO it had a very similar

00:08:10,150 --> 00:08:18,279
design to our board and if you've ever

00:08:15,099 --> 00:08:21,639
heard of this idea of come convergent

00:08:18,279 --> 00:08:24,669
evolution or the time like 10 points in

00:08:21,639 --> 00:08:26,830
time an idea is right this is kind of

00:08:24,669 --> 00:08:28,419
another proof of this because I'd never

00:08:26,830 --> 00:08:30,509
seen this board before until after I've

00:08:28,419 --> 00:08:32,440
designed the hardware it looks almost

00:08:30,509 --> 00:08:34,409
identical to the way we designed our

00:08:32,440 --> 00:08:38,079
hardware

00:08:34,409 --> 00:08:41,219
it had no capture and these guys were

00:08:38,079 --> 00:08:45,579
crazy they decided they were going to

00:08:41,219 --> 00:08:48,940
write all their FPGA stuff in Python

00:08:45,579 --> 00:08:50,680
they had a HDMI cord they had a DDR Ram

00:08:48,940 --> 00:08:54,069
core they had Ethernet and they are a

00:08:50,680 --> 00:08:55,000
supporting twenty boards and so I was a

00:08:54,069 --> 00:08:57,310
bit skeptical

00:08:55,000 --> 00:08:58,990
you know there wasn't a huge community

00:08:57,310 --> 00:09:03,600
there are small group

00:08:58,990 --> 00:09:03,600
how could a such small group of people

00:09:04,020 --> 00:09:11,140
do something using a tool that nobody

00:09:06,820 --> 00:09:14,470
else does uses and have this thing but I

00:09:11,140 --> 00:09:16,240
thought why not try Python I like Python

00:09:14,470 --> 00:09:19,210
I'm skeptical

00:09:16,240 --> 00:09:26,080
and so what I did is I have more money

00:09:19,210 --> 00:09:28,770
than time and I contacted this guy could

00:09:26,080 --> 00:09:33,030
Florent who runs enjoy digital and

00:09:28,770 --> 00:09:37,660
contracted him to use the median and

00:09:33,030 --> 00:09:41,260
stuff to replicate our current existing

00:09:37,660 --> 00:09:46,960
functionality using their technology he

00:09:41,260 --> 00:09:50,500
had already done this technology and

00:09:46,960 --> 00:09:53,260
used it quite frequently and he was

00:09:50,500 --> 00:09:56,020
happy to take my money and in four weeks

00:09:53,260 --> 00:09:59,320
he totally replicated our testing setup

00:09:56,020 --> 00:10:01,810
with a whole bunch more features than we

00:09:59,320 --> 00:10:05,950
had previously and this kind of blew me

00:10:01,810 --> 00:10:11,170
away the ad buffering it supported both

00:10:05,950 --> 00:10:16,300
our boards had a soft CPU internally had

00:10:11,170 --> 00:10:18,910
Ethernet support and so in the end we

00:10:16,300 --> 00:10:21,070
had a system which had four weeks of

00:10:18,910 --> 00:10:23,740
full-time development but only four

00:10:21,070 --> 00:10:27,010
weeks that we'd paid that was

00:10:23,740 --> 00:10:30,250
python-based it had truly four slices

00:10:27,010 --> 00:10:31,930
that you used no vendor generated stuff

00:10:30,250 --> 00:10:35,080
everything they generated themselves

00:10:31,930 --> 00:10:36,550
including like the DRM support model

00:10:35,080 --> 00:10:40,030
boards and it was like really good

00:10:36,550 --> 00:10:44,290
whereas our previous one our previous

00:10:40,030 --> 00:10:46,510
attempt was VHT own very log based and

00:10:44,290 --> 00:10:53,950
it was hard to extend questionable force

00:10:46,510 --> 00:10:56,020
and it taken us years to do so that was

00:10:53,950 --> 00:10:57,910
really good because it allowed us to use

00:10:56,020 --> 00:11:00,310
it in production and we're using this

00:10:57,910 --> 00:11:05,530
boards right now it's recording this

00:11:00,310 --> 00:11:07,450
talk it's recording other rooms we've

00:11:05,530 --> 00:11:08,920
still got a lot more awesome stuff we'd

00:11:07,450 --> 00:11:11,019
like to do like I said FB

00:11:08,920 --> 00:11:12,490
yeas make hardware problems software

00:11:11,019 --> 00:11:13,029
problems so we can continue to improve

00:11:12,490 --> 00:11:15,490
it

00:11:13,029 --> 00:11:18,250
and that's going really well it's being

00:11:15,490 --> 00:11:19,899
used up icons it's being used at

00:11:18,250 --> 00:11:23,920
linux.com today it's been used at Deb

00:11:19,899 --> 00:11:26,170
Kampf used up icons in the US around the

00:11:23,920 --> 00:11:28,930
u.s. not the big one but lots of the

00:11:26,170 --> 00:11:31,380
other ones like pyro higher and so

00:11:28,930 --> 00:11:36,459
that's really good

00:11:31,380 --> 00:11:39,310
so in summary the story we had was

00:11:36,459 --> 00:11:43,690
creating this hardware as hard like but

00:11:39,310 --> 00:11:46,779
by switching to this Python based we got

00:11:43,690 --> 00:11:48,610
more functionality in less time and we

00:11:46,779 --> 00:11:49,899
actually had a system we could use at

00:11:48,610 --> 00:11:55,930
the end of it

00:11:49,899 --> 00:12:00,100
so go Python but advise you and the

00:11:55,930 --> 00:12:02,260
audience I'd be skeptical like why did

00:12:00,100 --> 00:12:06,910
this happen and that's what the rest of

00:12:02,260 --> 00:12:10,480
my talk is going to be about why were we

00:12:06,910 --> 00:12:13,630
able to do this and why have we've been

00:12:10,480 --> 00:12:17,949
so much more productive in a Python

00:12:13,630 --> 00:12:22,180
based system then we were in a vhdl very

00:12:17,949 --> 00:12:25,870
long system so let's dive deeper and let

00:12:22,180 --> 00:12:30,910
me convince you that the reason this is

00:12:25,870 --> 00:12:34,690
good it's partly Python reason but also

00:12:30,910 --> 00:12:37,320
the things that the way we worked in the

00:12:34,690 --> 00:12:41,620
way the system connected together

00:12:37,320 --> 00:12:47,370
enabled us to accelerate our development

00:12:41,620 --> 00:12:49,990
and so why is it hard to fbj development

00:12:47,370 --> 00:12:54,069
the first one and this is particularly

00:12:49,990 --> 00:12:56,170
that I find frustrating is that hardware

00:12:54,069 --> 00:12:58,480
description languages like very log and

00:12:56,170 --> 00:13:02,649
VHDL have been around quite a long time

00:12:58,480 --> 00:13:05,680
and a lot of the features and

00:13:02,649 --> 00:13:07,389
development of them happened before we

00:13:05,680 --> 00:13:10,089
kind of learned how to do

00:13:07,389 --> 00:13:12,790
object-oriented programming and other

00:13:10,089 --> 00:13:18,600
things like test-driven development and

00:13:12,790 --> 00:13:21,579
modern CI things the next thing is that

00:13:18,600 --> 00:13:23,500
writing hardware is actually hard it's

00:13:21,579 --> 00:13:29,140
kind of their name

00:13:23,500 --> 00:13:31,570
if you really matters like you a lot of

00:13:29,140 --> 00:13:34,930
hardware if you get one single little

00:13:31,570 --> 00:13:36,610
bit wrong it doesn't work you don't get

00:13:34,930 --> 00:13:38,610
any debugging you don't get any

00:13:36,610 --> 00:13:41,830
information about what happened it just

00:13:38,610 --> 00:13:48,280
doesn't work and that makes hardware

00:13:41,830 --> 00:13:54,430
really hard as well FPGA tool chains to

00:13:48,280 --> 00:13:58,540
be kind slow that kind of beat

00:13:54,430 --> 00:14:04,390
proprietary tool chains that extremely

00:13:58,540 --> 00:14:08,650
frustrating and so that anytime you have

00:14:04,390 --> 00:14:14,890
to touch an FPGA tool chain you are sad

00:14:08,650 --> 00:14:19,710
and so how do we solve the problem that

00:14:14,890 --> 00:14:23,920
hto languages are old well what we do is

00:14:19,710 --> 00:14:26,590
we create a language that lets us

00:14:23,920 --> 00:14:30,040
generate one of the old languages but

00:14:26,590 --> 00:14:32,200
lets us talk and think about things at a

00:14:30,040 --> 00:14:35,800
high level and then generates all the

00:14:32,200 --> 00:14:38,500
nasty old code and so this is what this

00:14:35,800 --> 00:14:40,750
median thing is it's it doesn't convert

00:14:38,500 --> 00:14:42,790
Python you can't write Python code and

00:14:40,750 --> 00:14:45,970
haven't run an FPGA what it lets you

00:14:42,790 --> 00:14:49,750
express is Hardware concepts using

00:14:45,970 --> 00:14:53,200
Python and it then generates very log

00:14:49,750 --> 00:14:55,270
and handles interfacing to the pariah

00:14:53,200 --> 00:14:58,060
tree tool chains like running through

00:14:55,270 --> 00:15:00,040
the steps that needs to convert the very

00:14:58,060 --> 00:15:03,010
log into something you can load on the

00:15:00,040 --> 00:15:05,290
FPGA then they have this thing called me

00:15:03,010 --> 00:15:08,940
sock which is basically a library of

00:15:05,290 --> 00:15:15,610
modules that you can hook together and

00:15:08,940 --> 00:15:19,780
my sock is really well enables us to get

00:15:15,610 --> 00:15:22,150
a lot of things done but it's the reason

00:15:19,780 --> 00:15:25,660
my sock is really easy to use is because

00:15:22,150 --> 00:15:29,560
the interfaces are defined up at Python

00:15:25,660 --> 00:15:36,010
level rather than down at very log level

00:15:29,560 --> 00:15:38,500
which means we get a very easy

00:15:36,010 --> 00:15:41,380
to hook together because Python code

00:15:38,500 --> 00:15:46,030
like you've all used classes in Python

00:15:41,380 --> 00:15:52,320
that's very easy to understand one quick

00:15:46,030 --> 00:15:55,600
thing is Florent intro digital has a

00:15:52,320 --> 00:15:58,980
compatible fork of misocutlet X so

00:15:55,600 --> 00:15:58,980
you'll hear me use them interchangeably

00:15:59,130 --> 00:16:05,830
Florent has a more generous

00:16:03,520 --> 00:16:08,200
interpretation of what features should

00:16:05,830 --> 00:16:11,470
be added and what features should be

00:16:08,200 --> 00:16:13,180
removed so we generally use like X

00:16:11,470 --> 00:16:15,400
because it's got a lot more experimental

00:16:13,180 --> 00:16:20,820
stuff that most people wouldn't consider

00:16:15,400 --> 00:16:20,820
stable yet and so that's why we use that

00:16:21,150 --> 00:16:27,370
the thing with the Python HDL is it

00:16:24,730 --> 00:16:30,210
needs to end up on the FPGA and the way

00:16:27,370 --> 00:16:32,440
we do that is by generating very log and

00:16:30,210 --> 00:16:35,800
so you can think of me again as an easy

00:16:32,440 --> 00:16:38,040
way to generate very log and so this is

00:16:35,800 --> 00:16:41,170
what kind of what the code looks like

00:16:38,040 --> 00:16:43,840
this is a combinational statement which

00:16:41,170 --> 00:16:45,250
says that a is always equal to B you can

00:16:43,840 --> 00:16:47,530
think of it like connecting a wire

00:16:45,250 --> 00:16:49,510
between the two and synchronous is

00:16:47,530 --> 00:16:54,340
basically any time the clock edge

00:16:49,510 --> 00:16:57,670
changes a is set to B so a simple

00:16:54,340 --> 00:17:01,560
blinking LED this is what the Python

00:16:57,670 --> 00:17:04,630
code looks like you've got a simple

00:17:01,560 --> 00:17:07,329
synchronous counter there increases on

00:17:04,630 --> 00:17:09,570
the clock edge and then we set one of

00:17:07,329 --> 00:17:14,190
the high bits in the counter to an LED

00:17:09,570 --> 00:17:17,230
I'm using combinational statement and so

00:17:14,190 --> 00:17:19,270
this is really powerful because python

00:17:17,230 --> 00:17:21,940
is a powerful modern productive language

00:17:19,270 --> 00:17:24,910
that were all used to and we can also

00:17:21,940 --> 00:17:26,589
generate the exact very log we need for

00:17:24,910 --> 00:17:31,540
example our memory controller core

00:17:26,589 --> 00:17:33,580
supports SRAM DDR ddr2 ddr3 but it

00:17:31,540 --> 00:17:37,510
produces the minimal amount of error log

00:17:33,580 --> 00:17:38,650
where for the ddr3 output if you select

00:17:37,510 --> 00:17:41,260
ddr3 or

00:17:38,650 --> 00:17:43,540
if you select it out to you get the ddr2

00:17:41,260 --> 00:17:45,520
version but you don't get both in the

00:17:43,540 --> 00:17:47,910
output you only get the minimal very log

00:17:45,520 --> 00:17:47,910
needed

00:17:49,150 --> 00:17:57,340
so other things like we can basically

00:17:52,780 --> 00:18:00,490
say that our counter and have our signal

00:17:57,340 --> 00:18:01,750
automatically sized to the number that

00:18:00,490 --> 00:18:05,080
we want to put in there

00:18:01,750 --> 00:18:08,230
so this basically makes our counter we

00:18:05,080 --> 00:18:10,360
can change how fast the LED flashes by

00:18:08,230 --> 00:18:13,660
changing how many cycles it would count

00:18:10,360 --> 00:18:17,080
to we can also do things like for loops

00:18:13,660 --> 00:18:20,920
so we can say have it pass in a list of

00:18:17,080 --> 00:18:24,960
LEDs and flash all of them this is

00:18:20,920 --> 00:18:27,309
really hard to do in Bariloche and VHDL

00:18:24,960 --> 00:18:31,590
unless you use some of the more modern

00:18:27,309 --> 00:18:33,910
features or very welcomed VHDL and I

00:18:31,590 --> 00:18:35,770
always found it impossible to understand

00:18:33,910 --> 00:18:40,210
the very low can be HD old versions and

00:18:35,770 --> 00:18:42,610
so the solution is we use Python to

00:18:40,210 --> 00:18:44,650
generate HDL and that's how we solve a

00:18:42,610 --> 00:18:50,020
but that's not the only thing we do and

00:18:44,650 --> 00:18:54,820
I'm rapidly running out of time so I'm

00:18:50,020 --> 00:18:56,170
gonna have to talk quicker so the other

00:18:54,820 --> 00:18:58,350
thing is where I think hardware it's

00:18:56,170 --> 00:18:58,350
hard

00:18:58,500 --> 00:19:04,390
well we've moved to Python we still have

00:19:03,010 --> 00:19:07,120
to understand hard work we start the

00:19:04,390 --> 00:19:12,700
right hardware hardware is really hard

00:19:07,120 --> 00:19:17,260
to debug it's not great software it's

00:19:12,700 --> 00:19:19,840
much easier than hardware so what we do

00:19:17,260 --> 00:19:23,350
is we try to reduce the hardware that we

00:19:19,840 --> 00:19:25,480
write and we only write the essential

00:19:23,350 --> 00:19:30,280
pieces of hardware that we need and

00:19:25,480 --> 00:19:34,929
instead have a soft CPU inside the FPGA

00:19:30,280 --> 00:19:42,090
that can run code normal code normal C

00:19:34,929 --> 00:19:45,280
code so we do less in the FPGA by

00:19:42,090 --> 00:19:49,960
pushing the problem up the stack and we

00:19:45,280 --> 00:19:52,900
can write most things in C and how many

00:19:49,960 --> 00:19:56,110
people here understand see how many

00:19:52,900 --> 00:19:57,970
people here understand very log so just

00:19:56,110 --> 00:20:01,720
for the video they're like two people

00:19:57,970 --> 00:20:03,100
who understand very log and like 30 to

00:20:01,720 --> 00:20:05,530
40 people understand see

00:20:03,100 --> 00:20:07,360
so it also means more people can write

00:20:05,530 --> 00:20:10,090
the C code and debug the C code and

00:20:07,360 --> 00:20:13,059
understand the C code we compile with

00:20:10,090 --> 00:20:15,010
GCC everybody's probably used you see if

00:20:13,059 --> 00:20:19,780
you've done the C code and we can update

00:20:15,010 --> 00:20:22,059
it easy every time we update this C code

00:20:19,780 --> 00:20:24,880
we can load it on to the FPGA without

00:20:22,059 --> 00:20:27,400
having to reprogram the whole FPGA and

00:20:24,880 --> 00:20:30,760
that means that we can update at a much

00:20:27,400 --> 00:20:34,270
better cycle the updation cycle for this

00:20:30,760 --> 00:20:37,480
firmware we can t FTP load it and it

00:20:34,270 --> 00:20:40,929
will take like five to six seconds to

00:20:37,480 --> 00:20:45,760
upload the firmware compared to many

00:20:40,929 --> 00:20:46,990
minutes to do FPGA stuff so me suck

00:20:45,760 --> 00:20:50,260
gives you a soft CPU

00:20:46,990 --> 00:20:52,450
the other cool thing is it's agnostic to

00:20:50,260 --> 00:20:54,820
the soft CPU architecture it has a

00:20:52,450 --> 00:20:56,860
multiple choice you can change one

00:20:54,820 --> 00:21:00,880
variable and you change from the LM 32

00:20:56,860 --> 00:21:05,190
architecture to the open risk 1k and it

00:21:00,880 --> 00:21:05,190
also has a common set of systems for

00:21:05,549 --> 00:21:11,620
exposing features of your hardware to

00:21:08,890 --> 00:21:12,010
the CPU and it generates code stubs for

00:21:11,620 --> 00:21:17,049
you

00:21:12,010 --> 00:21:19,600
so we have a generic GPIO CSR register

00:21:17,049 --> 00:21:23,650
object in my sock and so this is what

00:21:19,600 --> 00:21:27,520
your blinky example looks like we just

00:21:23,650 --> 00:21:30,789
create a GPIO out register and say

00:21:27,520 --> 00:21:32,980
connect it to the LED and then we write

00:21:30,789 --> 00:21:35,919
some C code we can automatically

00:21:32,980 --> 00:21:40,330
generate a function that we just call

00:21:35,919 --> 00:21:43,090
zero to turn the LED off and one to turn

00:21:40,330 --> 00:21:45,429
it back on it doesn't matter where the

00:21:43,090 --> 00:21:47,380
code decided to allocate this in the

00:21:45,429 --> 00:21:49,630
memory or anything like that we just

00:21:47,380 --> 00:21:53,080
call the function and people kind of

00:21:49,630 --> 00:21:55,780
know how to call C functions the real

00:21:53,080 --> 00:21:58,780
example of this is that we have SRAM

00:21:55,780 --> 00:22:02,110
DRAM controller the initialization for

00:21:58,780 --> 00:22:04,000
the DRAM happens once startup it's a

00:22:02,110 --> 00:22:06,640
reasonably complicated thing to do and

00:22:04,000 --> 00:22:08,799
it's much easier to understand this in C

00:22:06,640 --> 00:22:11,830
code than it is in very log of VHDL code

00:22:08,799 --> 00:22:14,260
and we only need it once so we can load

00:22:11,830 --> 00:22:15,909
it into the FPGA at the beginning

00:22:14,260 --> 00:22:18,570
initialize the RAM and then do something

00:22:15,909 --> 00:22:24,050
else useful with

00:22:18,570 --> 00:22:28,440
soft CPU as some downsides you do need a

00:22:24,050 --> 00:22:30,480
compiler and Binny tools as a small

00:22:28,440 --> 00:22:31,680
community around these architectures

00:22:30,480 --> 00:22:34,140
because these architectures are

00:22:31,680 --> 00:22:38,250
basically designed for FPGAs and your

00:22:34,140 --> 00:22:40,260
eye can see which is not Python so I

00:22:38,250 --> 00:22:44,490
have a project to put micro Python on

00:22:40,260 --> 00:22:48,660
FPGAs so we can run micro Python on the

00:22:44,490 --> 00:22:50,280
soft CPU and we'll be hacking on that at

00:22:48,660 --> 00:22:52,650
the sprints you can go to that URL and

00:22:50,280 --> 00:22:55,470
find out more and you should find one of

00:22:52,650 --> 00:22:58,140
these two people or me if you're

00:22:55,470 --> 00:23:02,010
interested hacking on that you mostly

00:22:58,140 --> 00:23:04,620
see at this stage but definitely once we

00:23:02,010 --> 00:23:08,390
get it we've got it like basic UART and

00:23:04,620 --> 00:23:12,570
all that type of stuff running so yeah

00:23:08,390 --> 00:23:15,300
so in summary the way we solve Hardware

00:23:12,570 --> 00:23:21,360
being hard is we do less of it and that

00:23:15,300 --> 00:23:22,650
accelerates our development again and

00:23:21,360 --> 00:23:26,280
now I've got five minutes to go through

00:23:22,650 --> 00:23:30,600
another one of these so FPGA tool chains

00:23:26,280 --> 00:23:32,220
are slow FPGA two trains are slow

00:23:30,600 --> 00:23:33,210
because they're actually trying to solve

00:23:32,220 --> 00:23:35,970
a hard problem

00:23:33,210 --> 00:23:39,630
they take your description of some type

00:23:35,970 --> 00:23:45,300
of hardware and then try and map it onto

00:23:39,630 --> 00:23:47,220
the internals of FPGA this is in some

00:23:45,300 --> 00:23:52,040
way similar to a traveling salesman type

00:23:47,220 --> 00:23:55,500
problem it is not generally solvable and

00:23:52,040 --> 00:23:57,600
the more description you have that has

00:23:55,500 --> 00:24:00,900
to fit on there the harder job it has

00:23:57,600 --> 00:24:04,260
and so the more code the slower the

00:24:00,900 --> 00:24:07,080
compiled and when I say slow compile

00:24:04,260 --> 00:24:09,630
I mean industry people are quite

00:24:07,080 --> 00:24:15,530
familiar with compile times in the

00:24:09,630 --> 00:24:18,120
orders of hours so what's inside lfpg

00:24:15,530 --> 00:24:20,430
this is kind of what's inside our FPGA

00:24:18,120 --> 00:24:22,770
we have a CPU a bus that connects things

00:24:20,430 --> 00:24:26,670
some memory interfaces and then a

00:24:22,770 --> 00:24:29,190
peripheral or peripherals that's a lot

00:24:26,670 --> 00:24:31,820
of code and as I said more code means a

00:24:29,190 --> 00:24:31,820
slower compile

00:24:32,090 --> 00:24:40,200
so one thing we've already done is we've

00:24:35,970 --> 00:24:42,330
moved as much of the hardware code as we

00:24:40,200 --> 00:24:44,610
can into the soft CPU that means the

00:24:42,330 --> 00:24:47,910
FPGA tool train doesn't need to see that

00:24:44,610 --> 00:24:50,490
and that makes the compiler faster but

00:24:47,910 --> 00:24:53,510
it's not the only thing we do so looking

00:24:50,490 --> 00:24:56,100
at this most of the time when developing

00:24:53,510 --> 00:24:58,710
would develop a new peripheral new

00:24:56,100 --> 00:25:02,370
something new HDMI thing we're not

00:24:58,710 --> 00:25:05,400
developing new CPU or memory controller

00:25:02,370 --> 00:25:07,080
and there's this kind of thing off to

00:25:05,400 --> 00:25:10,650
the side the computer that you're

00:25:07,080 --> 00:25:14,190
running things on and so you kind of see

00:25:10,650 --> 00:25:16,080
that we have two CPUs here so what

00:25:14,190 --> 00:25:18,180
happens if we got rid of the CPU on the

00:25:16,080 --> 00:25:20,430
FPGA and just use the CPU on the

00:25:18,180 --> 00:25:23,640
developers computer and so that's what

00:25:20,430 --> 00:25:27,150
we do we have a bridge interface which

00:25:23,640 --> 00:25:31,110
basically lets us run the code on your

00:25:27,150 --> 00:25:38,730
computer and access the hardware in the

00:25:31,110 --> 00:25:40,170
FPGA like your the CPU on the FPGA we

00:25:38,730 --> 00:25:40,950
have multiple ways of doing that we can

00:25:40,170 --> 00:25:43,590
use a UART

00:25:40,950 --> 00:25:49,710
or we can use Gigabit Ethernet or we can

00:25:43,590 --> 00:25:50,130
use PCI Express I've got five more

00:25:49,710 --> 00:25:54,900
minutes

00:25:50,130 --> 00:25:57,330
and so that cpus aren't small our cpu is

00:25:54,900 --> 00:25:59,580
actually very resource efficient and

00:25:57,330 --> 00:26:01,500
quite small compared to most cpu

00:25:59,580 --> 00:26:04,230
implementations but it's still another

00:26:01,500 --> 00:26:06,600
chunk that we've moved off death pga and

00:26:04,230 --> 00:26:10,110
the bridge implementations extremely

00:26:06,600 --> 00:26:13,050
small competitor cpu so that saves a lot

00:26:10,110 --> 00:26:16,620
of resources and hence we get much

00:26:13,050 --> 00:26:18,120
faster compile times but if you're

00:26:16,620 --> 00:26:19,920
looking at this what we normally care

00:26:18,120 --> 00:26:22,280
about is just one peripheral and would

00:26:19,920 --> 00:26:24,510
still go a lot of our stuff here so

00:26:22,280 --> 00:26:26,850
let's get rid of all that stuff as well

00:26:24,510 --> 00:26:29,370
and like we only care about one

00:26:26,850 --> 00:26:32,610
peripheral time we're working on we

00:26:29,370 --> 00:26:34,290
don't care about the fact that the

00:26:32,610 --> 00:26:36,720
ethernet core might work while

00:26:34,290 --> 00:26:38,430
developing the HDMI cord we only care

00:26:36,720 --> 00:26:41,040
about we're working on HDMI call let's

00:26:38,430 --> 00:26:43,940
concentrate on that and so we go in

00:26:41,040 --> 00:26:46,490
further and we cut back

00:26:43,940 --> 00:26:49,460
basically the whole system to just the

00:26:46,490 --> 00:26:51,680
peripheral that you're working on the

00:26:49,460 --> 00:26:53,810
bridge and the bus that connects the

00:26:51,680 --> 00:26:56,120
whole thing and then do as much

00:26:53,810 --> 00:26:59,300
development as we can on the developers

00:26:56,120 --> 00:27:03,440
computer rather than in the FPGA and so

00:26:59,300 --> 00:27:05,780
this makes compile times which FPGA tool

00:27:03,440 --> 00:27:09,280
chains are bear that in the order of

00:27:05,780 --> 00:27:12,340
minutes instead of in the order of hours

00:27:09,280 --> 00:27:15,440
because the FPGA is very far very

00:27:12,340 --> 00:27:18,110
uncongested and has much more leeway in

00:27:15,440 --> 00:27:21,770
how it lays out things and so less code

00:27:18,110 --> 00:27:24,410
means faster compile times the other

00:27:21,770 --> 00:27:27,380
thing is that we have python or now

00:27:24,410 --> 00:27:30,890
developer computer and so we have a

00:27:27,380 --> 00:27:33,410
python api that we can talk to the

00:27:30,890 --> 00:27:36,320
bridge in and we can do things like read

00:27:33,410 --> 00:27:39,920
and write registers over whatever

00:27:36,320 --> 00:27:43,070
interface exists like where this code is

00:27:39,920 --> 00:27:44,960
agnostic to the weather its fire you art

00:27:43,070 --> 00:27:48,350
or whether it's by gigabit ethernet or

00:27:44,960 --> 00:27:50,900
whether it's by PCIe and it lets us just

00:27:48,350 --> 00:27:53,030
write directly onto the wishbone bus the

00:27:50,900 --> 00:27:54,590
registers and read the registers so this

00:27:53,030 --> 00:27:56,270
makes it really easy to bug because

00:27:54,590 --> 00:27:58,940
you're like why isn't this Hardware

00:27:56,270 --> 00:28:00,950
working read a register and see the

00:27:58,940 --> 00:28:04,040
value oh wait that valley doesn't look

00:28:00,950 --> 00:28:06,350
at all like what I expect it to be and

00:28:04,040 --> 00:28:09,370
so that's really powerful and we can do

00:28:06,350 --> 00:28:13,250
things like look at the memory map or

00:28:09,370 --> 00:28:15,530
this is like in our blink Lib example

00:28:13,250 --> 00:28:17,960
this one here would turn on the LED

00:28:15,530 --> 00:28:21,230
because it writes to the LED GPIO

00:28:17,960 --> 00:28:23,180
register and we get things like that

00:28:21,230 --> 00:28:24,770
complete we can see what registers are

00:28:23,180 --> 00:28:28,910
available and the names that they were

00:28:24,770 --> 00:28:31,010
given in our code that information is

00:28:28,910 --> 00:28:33,730
normally lost when you do fpga

00:28:31,010 --> 00:28:37,040
development just know that because

00:28:33,730 --> 00:28:40,670
somebody said so that this location is

00:28:37,040 --> 00:28:43,280
where the register is and if moves you

00:28:40,670 --> 00:28:46,250
spend hours debugging going why doesn't

00:28:43,280 --> 00:28:49,220
this code that used to work not work now

00:28:46,250 --> 00:28:53,300
oh because somebody moved the UART from

00:28:49,220 --> 00:28:55,310
0 mm to 0 4000 and they did that for

00:28:53,300 --> 00:28:57,800
some good reason but they forgot to tell

00:28:55,310 --> 00:29:01,070
us and now we spent hours debug

00:28:57,800 --> 00:29:03,920
something that we wouldn't otherwise so

00:29:01,070 --> 00:29:05,360
instead we can just use like WB dot regs

00:29:03,920 --> 00:29:10,670
dot UART

00:29:05,360 --> 00:29:13,070
instead so in summary FPGA tool chains

00:29:10,670 --> 00:29:15,380
are slow so we try and work on very

00:29:13,070 --> 00:29:16,820
small bits at a time it also makes

00:29:15,380 --> 00:29:19,940
easier to debug because there's less

00:29:16,820 --> 00:29:22,910
interactions going on and so summary of

00:29:19,940 --> 00:29:25,580
summary how we're so much more efficient

00:29:22,910 --> 00:29:29,510
than a lot of people in this area is

00:29:25,580 --> 00:29:31,460
that we use a Python HDL we reduce the

00:29:29,510 --> 00:29:37,310
amount of hardware that we write and we

00:29:31,460 --> 00:29:39,320
work on small bits at a time and most of

00:29:37,310 --> 00:29:44,270
this power comes from the media and my

00:29:39,320 --> 00:29:47,360
sock light X things the python HDL is

00:29:44,270 --> 00:29:49,070
median it gives you the soft CPU and it

00:29:47,360 --> 00:29:51,350
gives you these bridges which allow you

00:29:49,070 --> 00:29:53,810
to cut back what you're developing on at

00:29:51,350 --> 00:29:55,340
a time another thing I haven't mentioned

00:29:53,810 --> 00:29:58,340
here is it gives you a very good

00:29:55,340 --> 00:30:00,590
internal scoping tool that has a Python

00:29:58,340 --> 00:30:03,020
interface that uses just the bridges to

00:30:00,590 --> 00:30:07,520
talk about and that would be number four

00:30:03,020 --> 00:30:11,300
if I had more time so all the stuff I'm

00:30:07,520 --> 00:30:13,160
working on is I'm a source we would love

00:30:11,300 --> 00:30:17,110
you to be involved in it and we would

00:30:13,160 --> 00:30:17,110
love you to come and help hack on it

00:30:17,740 --> 00:30:23,180
we've tried to make it as easy as

00:30:19,970 --> 00:30:25,520
possible to set up you have to install

00:30:23,180 --> 00:30:27,800
the if you want to work on the FPGA side

00:30:25,520 --> 00:30:30,080
of things you have to install the FPGA

00:30:27,800 --> 00:30:32,120
toolchain which is a bad experience

00:30:30,080 --> 00:30:35,000
sadly because it's proprietary software

00:30:32,120 --> 00:30:36,230
I can't do anything about that but if

00:30:35,000 --> 00:30:38,210
you don't want to if you just want to

00:30:36,230 --> 00:30:40,460
work on the firmware side of things as

00:30:38,210 --> 00:30:43,820
of like two hours ago you no longer need

00:30:40,460 --> 00:30:46,550
the FPGA tool train so that's really

00:30:43,820 --> 00:30:50,420
good um you can use a pre-built firmware

00:30:46,550 --> 00:30:53,180
for FPGA that we have as part of CI and

00:30:50,420 --> 00:30:58,850
there's so much more we could do with

00:30:53,180 --> 00:31:01,190
your help and I have a tendency to send

00:30:58,850 --> 00:31:03,710
people hardware who help me so if you're

00:31:01,190 --> 00:31:05,570
looking for a new fpga board maybe send

00:31:03,710 --> 00:31:08,150
me a few pull requests and I'll see what

00:31:05,570 --> 00:31:11,360
I can do there are definitely people and

00:31:08,150 --> 00:31:12,620
audiences who have gotten hardware from

00:31:11,360 --> 00:31:17,090
me

00:31:12,620 --> 00:31:21,230
in the past and I should have told them

00:31:17,090 --> 00:31:22,720
that this has audio let's see if this

00:31:21,230 --> 00:31:28,580
works

00:31:22,720 --> 00:31:37,340
where's the plug am I going to blind

00:31:28,580 --> 00:31:40,340
them with the sound or deaf in them and

00:31:37,340 --> 00:31:48,500
so we'll be at the Sprint's this is a

00:31:40,340 --> 00:31:51,880
video I made a long time ago which

00:31:48,500 --> 00:31:51,880
apparently internet doesn't like

00:31:59,250 --> 00:32:05,860
if you haven't been to my clubs for it

00:32:02,440 --> 00:32:08,679
before you should definitely try it and

00:32:05,860 --> 00:32:10,750
make sure you stay for the next one the

00:32:08,679 --> 00:32:12,309
Sprint's are great because they don't

00:32:10,750 --> 00:32:14,440
just let you put a face to a name they

00:32:12,309 --> 00:32:15,440
leave with a person to like is that

00:32:14,440 --> 00:32:18,479
working

00:32:15,440 --> 00:32:23,149
Brittany is an excellent way to get

00:32:18,479 --> 00:32:23,149
everyone together especially the new

00:32:24,229 --> 00:32:30,239
already submitted packages got tickets

00:32:27,450 --> 00:32:33,829
close down the tremendous for us and you

00:32:30,239 --> 00:32:33,829
know the interest keep you honest about

00:32:35,269 --> 00:32:39,119
we've been really excited to see all of

00:32:37,529 --> 00:32:40,919
you people here at Pike I've got a rush

00:32:39,119 --> 00:32:43,549
out there there's a lot of what to do

00:32:40,919 --> 00:32:43,549
see you later

00:32:51,450 --> 00:32:57,389
- in the u.s. we have Sprint's here

00:32:54,059 --> 00:33:01,049
after this Python will be there hacking

00:32:57,389 --> 00:33:03,269
on this hardware and we I've got a lot

00:33:01,049 --> 00:33:05,879
of hardware here that you can come and

00:33:03,269 --> 00:33:09,929
play with look at figure out what is

00:33:05,879 --> 00:33:14,549
going on and I also have a couple of

00:33:09,929 --> 00:33:19,259
laptops - with the stuff preset up if

00:33:14,549 --> 00:33:21,869
you just want to understand how this

00:33:19,259 --> 00:33:25,950
workflow might work and this is kind of

00:33:21,869 --> 00:33:28,739
what happens when you get your Hardware

00:33:25,950 --> 00:33:30,749
wrong so I'll leave that running and I

00:33:28,739 --> 00:33:36,109
think we're properly out of time for

00:33:30,749 --> 00:33:38,070
questions but I will be around and

00:33:36,109 --> 00:33:50,039
hopefully you won't get a problem like

00:33:38,070 --> 00:33:53,339
this thank you very much thank you all

00:33:50,039 --> 00:33:55,259
right we've got a slightly less than 10

00:33:53,339 --> 00:33:57,979
minute break to the next speech so

00:33:55,259 --> 00:33:57,979

YouTube URL: https://www.youtube.com/watch?v=zdLiI-XLTcI


