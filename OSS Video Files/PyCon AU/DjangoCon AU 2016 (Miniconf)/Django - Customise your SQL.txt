Title: Django - Customise your SQL
Publication date: 2016-08-16
Playlist: DjangoCon AU 2016 (Miniconf)
Description: 
	Josh Smeaton
https://2016.pycon-au.org/schedule/86/view_talk
Learn about the different methods of altering the SQL that the Django ORM generates. Write complex reporting queries, perform calculations within the database, or drop down to writing the entire query in pure SQL. Take advantage of your specific database features.
Captions: 
	00:00:00,979 --> 00:00:07,109
alright ladies and gentlemen we're back

00:00:04,140 --> 00:00:08,340
now for those who who are interested the

00:00:07,109 --> 00:00:10,349
there are still plenty of slots

00:00:08,340 --> 00:00:12,330
available and apparently a Star Wars

00:00:10,349 --> 00:00:13,769
Episode going on there's still plenty of

00:00:12,330 --> 00:00:15,809
slots available for lightning talks this

00:00:13,769 --> 00:00:17,490
afternoon so if you are interested in a

00:00:15,809 --> 00:00:18,960
lightning talk come see me put something

00:00:17,490 --> 00:00:21,210
in my little collection of lightning

00:00:18,960 --> 00:00:23,880
talk things here our next speaker is

00:00:21,210 --> 00:00:25,130
another Jango Corps dev this is Josh

00:00:23,880 --> 00:00:27,630
Baden who's here to talk about

00:00:25,130 --> 00:00:30,840
customizing your sequel inside during

00:00:27,630 --> 00:00:34,910
the Jango RM thank you very much thank

00:00:30,840 --> 00:00:40,050
you can you hear me what's up phone yep

00:00:34,910 --> 00:00:44,399
hi I'm Josh I work on the on the Jango

00:00:40,050 --> 00:00:46,219
one I play with cycle quite a lot you

00:00:44,399 --> 00:00:49,500
can find me on the web under Joshua

00:00:46,219 --> 00:00:51,690
Jango IRC Twitter github the slack

00:00:49,500 --> 00:00:54,899
tunnel etc I work for a company called

00:00:51,690 --> 00:00:57,510
engage we do call center apps reporting

00:00:54,899 --> 00:00:59,280
a lot of reporting which means a lot of

00:00:57,510 --> 00:01:00,960
sequel which kind of bleeds into the

00:00:59,280 --> 00:01:02,370
next point and the bit of a sequel nerd

00:01:00,960 --> 00:01:05,100
I've kind of got a love-hate

00:01:02,370 --> 00:01:06,600
relationship with it I have a lot of

00:01:05,100 --> 00:01:09,240
customers asking me how their reports

00:01:06,600 --> 00:01:11,159
work and I try not to tell them I don't

00:01:09,240 --> 00:01:13,979
know too often so I have to dig into a

00:01:11,159 --> 00:01:15,570
lot of those I'm the primary author of

00:01:13,979 --> 00:01:18,330
expressions which is a new feature to

00:01:15,570 --> 00:01:19,890
Jango as of 1.8 so it's a year and a

00:01:18,330 --> 00:01:23,670
half old now or two years old something

00:01:19,890 --> 00:01:28,009
like that and after that was committed I

00:01:23,670 --> 00:01:30,329
was invited onto the core team for that

00:01:28,009 --> 00:01:33,360
okay so some recent developments in

00:01:30,329 --> 00:01:34,590
Jango that you know help users go a bit

00:01:33,360 --> 00:01:36,119
of a way for being able to you know

00:01:34,590 --> 00:01:40,409
really get in there and alter the circle

00:01:36,119 --> 00:01:42,150
that Jango generates starts off with 1.7

00:01:40,409 --> 00:01:44,970
so there are a couple of patches landed

00:01:42,150 --> 00:01:47,670
for 1.7 that kind of got us to a

00:01:44,970 --> 00:01:51,240
reasonable point for users and the main

00:01:47,670 --> 00:01:52,710
one was lookups so here the lookup is

00:01:51,240 --> 00:01:54,600
that a pointer yes

00:01:52,710 --> 00:01:57,540
so the lookup here is the contains

00:01:54,600 --> 00:01:59,790
method so pre 1.7 you were at the mercy

00:01:57,540 --> 00:02:03,360
of what Jango offered you so it was

00:01:59,790 --> 00:02:05,159
greater than equals less than is no that

00:02:03,360 --> 00:02:06,509
kind of thing but there was no way to

00:02:05,159 --> 00:02:08,700
write your own so if you had custom

00:02:06,509 --> 00:02:11,069
fields that require custom lookups say

00:02:08,700 --> 00:02:13,920
you were working with arrays in Postgres

00:02:11,069 --> 00:02:16,680
or H store etc there was no way

00:02:13,920 --> 00:02:19,680
to actually write your own lookups so

00:02:16,680 --> 00:02:21,390
that changed in 1.7 so filters are where

00:02:19,680 --> 00:02:23,760
clauses so lookup sir for generating

00:02:21,390 --> 00:02:25,560
conditions in a where clause so you have

00:02:23,760 --> 00:02:27,780
the left side which is the field you're

00:02:25,560 --> 00:02:29,250
querying the contains which is the

00:02:27,780 --> 00:02:30,420
operator that sits in between and then

00:02:29,250 --> 00:02:33,959
the right side which is the data that

00:02:30,420 --> 00:02:34,830
you're passing between transforms are

00:02:33,959 --> 00:02:38,130
very similar

00:02:34,830 --> 00:02:40,140
you might confuse this here because it's

00:02:38,130 --> 00:02:43,680
just you know underscore lookups so here

00:02:40,140 --> 00:02:48,569
it's actually the lower portion right

00:02:43,680 --> 00:02:49,709
there that is a function so the

00:02:48,569 --> 00:02:52,980
left-hand side you've got your field

00:02:49,709 --> 00:02:55,670
name if you apply lowered to it it'll

00:02:52,980 --> 00:02:58,799
you know use a bit a single function to

00:02:55,670 --> 00:03:01,260
lower that that name and then you can

00:02:58,799 --> 00:03:03,390
apply an operator so a lookup contains

00:03:01,260 --> 00:03:05,340
there so this will find any products

00:03:03,390 --> 00:03:07,350
where the name contains the word Jumper

00:03:05,340 --> 00:03:10,319
lowercase uppercase mixed case it

00:03:07,350 --> 00:03:13,620
doesn't really matter okay so

00:03:10,319 --> 00:03:16,739
expressions so 1.8 we got expressions

00:03:13,620 --> 00:03:19,109
and this is the feature that I'm mostly

00:03:16,739 --> 00:03:21,450
responsible for there were some helpers

00:03:19,109 --> 00:03:24,239
along the way so that was good but this

00:03:21,450 --> 00:03:28,530
allowed you to really get in there and

00:03:24,239 --> 00:03:32,370
annotate on queries with new data

00:03:28,530 --> 00:03:33,959
so ad select fields you could do complex

00:03:32,370 --> 00:03:36,150
aggregations so you could add two fields

00:03:33,959 --> 00:03:38,850
together you could add two aggregations

00:03:36,150 --> 00:03:41,579
together before that you could only have

00:03:38,850 --> 00:03:44,100
a grenade on one field so what this

00:03:41,579 --> 00:03:46,980
query does is it's a cell's by month

00:03:44,100 --> 00:03:48,840
query so it'll take a cell date it'll

00:03:46,980 --> 00:03:50,700
truncate it down to the first of the

00:03:48,840 --> 00:03:52,470
month so all of the data within that

00:03:50,700 --> 00:03:54,780
month becomes one field it groups by

00:03:52,470 --> 00:03:59,700
that one field the new take account and

00:03:54,780 --> 00:04:05,430
there's your sales per month query all

00:03:59,700 --> 00:04:07,709
right so sales reporting a lot a lot of

00:04:05,430 --> 00:04:09,380
queries come down to variations of sales

00:04:07,709 --> 00:04:11,700
reporting especially when you're doing

00:04:09,380 --> 00:04:13,319
well any kind of reporting when you're

00:04:11,700 --> 00:04:15,720
doing aggregation that kind of thing so

00:04:13,319 --> 00:04:18,120
I've written up a little store so it's a

00:04:15,720 --> 00:04:20,280
clothing store called clothe me there's

00:04:18,120 --> 00:04:25,190
two models there's a cell model there's

00:04:20,280 --> 00:04:25,190
product model so let's step through this

00:04:26,819 --> 00:04:33,669
okay so this is an i python or Jupiter

00:04:30,280 --> 00:04:36,699
notebook so it's got the code actually

00:04:33,669 --> 00:04:39,340
runs and this is real code here so this

00:04:36,699 --> 00:04:42,779
is this is our basic query so we take a

00:04:39,340 --> 00:04:45,759
sale we group it by a product category

00:04:42,779 --> 00:04:48,610
we then annotate the sales and the

00:04:45,759 --> 00:04:51,879
revenue and we get revenue and sales per

00:04:48,610 --> 00:04:55,870
products that's fairly simple stuff this

00:04:51,879 --> 00:04:57,879
was always possible but then your boss

00:04:55,870 --> 00:04:59,800
comes in and they say we don't care

00:04:57,879 --> 00:05:02,289
about clothing for kids what that's not

00:04:59,800 --> 00:05:06,129
our target market get rid of it and you

00:05:02,289 --> 00:05:09,819
go okay boss anything for you and you

00:05:06,129 --> 00:05:12,310
write an excludes filter so to exclude

00:05:09,819 --> 00:05:15,009
you use exclude instead of filter you

00:05:12,310 --> 00:05:17,669
filter out the kids category and then

00:05:15,009 --> 00:05:23,770
you do the grouping as you did before

00:05:17,669 --> 00:05:25,330
but then your DBA and your ops person

00:05:23,770 --> 00:05:30,250
they come over and they say this query

00:05:25,330 --> 00:05:31,839
sucks this query is no good and that's

00:05:30,250 --> 00:05:35,169
the query that Jango actually generates

00:05:31,839 --> 00:05:37,750
for it and you can see that there's not

00:05:35,169 --> 00:05:39,729
it doesn't user not equals like you

00:05:37,750 --> 00:05:43,719
normally would for a cycle who writes

00:05:39,729 --> 00:05:45,250
sequel care who's aware of cycle good

00:05:43,719 --> 00:05:46,330
because a lot of the time you hear a lot

00:05:45,250 --> 00:05:47,770
about people using arms and not

00:05:46,330 --> 00:05:48,939
understanding the sacral beneath so it's

00:05:47,770 --> 00:05:51,639
good that people have a good

00:05:48,939 --> 00:05:52,960
understanding okay so traditionally here

00:05:51,639 --> 00:05:54,399
for this kind of report you'd put a not

00:05:52,960 --> 00:05:57,779
equals there and you wouldn't put a knot

00:05:54,399 --> 00:06:00,129
at the front but Jango doesn't do that

00:05:57,779 --> 00:06:01,599
now this version the query uses five

00:06:00,129 --> 00:06:04,990
extra characters which is why your ops

00:06:01,599 --> 00:06:07,479
people are blowing up right matters

00:06:04,990 --> 00:06:09,969
web-scale and Django actually has a lot

00:06:07,479 --> 00:06:13,270
more work to do for negated queries as

00:06:09,969 --> 00:06:14,949
well because it's got to take in sub

00:06:13,270 --> 00:06:19,360
queries into consideration it's got to a

00:06:14,949 --> 00:06:22,779
whole lot more processing so with

00:06:19,360 --> 00:06:25,479
lookups now we can write our way and my

00:06:22,779 --> 00:06:27,639
phone's died it's all good we can write

00:06:25,479 --> 00:06:29,740
our way and so we can decide write

00:06:27,639 --> 00:06:32,349
Django we don't like how you do your not

00:06:29,740 --> 00:06:34,949
exclude we're going to write our own so

00:06:32,349 --> 00:06:37,750
right here we're doing your not equals

00:06:34,949 --> 00:06:39,129
we're providing a lookup name of any so

00:06:37,750 --> 00:06:41,080
that's the underscore underscore

00:06:39,129 --> 00:06:43,059
na or underscore underscore contains

00:06:41,080 --> 00:06:45,939
that's the lookup name and that's that's

00:06:43,059 --> 00:06:48,999
the meet of a lookup of a transform as

00:06:45,939 --> 00:06:51,039
well so the main method is an ad circle

00:06:48,999 --> 00:06:52,899
method and what that does is it takes

00:06:51,039 --> 00:06:55,149
the left-hand side compiles it down to

00:06:52,899 --> 00:06:58,269
sequel which is what the process LHS is

00:06:55,149 --> 00:06:59,919
it takes the right side which is your

00:06:58,269 --> 00:07:02,229
value that you're comparing it to it

00:06:59,919 --> 00:07:04,569
compiles that down to sequel it then

00:07:02,229 --> 00:07:06,339
uses string interpolation which is

00:07:04,569 --> 00:07:09,189
generally bad but we're hoping that you

00:07:06,339 --> 00:07:11,229
know users are not and not providing

00:07:09,189 --> 00:07:12,819
data here but that's why we've also got

00:07:11,229 --> 00:07:15,789
the params on the end to account for

00:07:12,819 --> 00:07:17,709
circle injection and then we return the

00:07:15,789 --> 00:07:21,939
circle that you know the query needs to

00:07:17,709 --> 00:07:24,099
run and I've timed it you save 30

00:07:21,939 --> 00:07:27,240
microseconds by writing a career that

00:07:24,099 --> 00:07:27,240
way so your abs people are happy

00:07:27,990 --> 00:07:37,209
okay so Milton lovely old Milton he

00:07:34,599 --> 00:07:38,949
doesn't like categories he doesn't care

00:07:37,209 --> 00:07:40,899
about products he just wants to say

00:07:38,949 --> 00:07:43,439
revenue by quarter because he's got

00:07:40,899 --> 00:07:45,249
quarterly reports to write quarterly

00:07:43,439 --> 00:07:50,469
investors care about this kind of stuff

00:07:45,249 --> 00:07:52,659
too I guess so Django doesn't have the

00:07:50,469 --> 00:07:56,259
concept of truncating to a quarter

00:07:52,659 --> 00:07:58,240
so as of Django 1.10 you've got a whole

00:07:56,259 --> 00:08:00,669
lot of date based lookup so you've got

00:07:58,240 --> 00:08:03,039
extra queries which will let you pull

00:08:00,669 --> 00:08:04,659
out a year or a month or a day but

00:08:03,039 --> 00:08:06,909
you've also got truncation queries that

00:08:04,659 --> 00:08:08,529
will let you a grenade the dates so you

00:08:06,909 --> 00:08:10,509
can reduce it you can get rid of the

00:08:08,529 --> 00:08:12,849
time reduce it down to a date you can

00:08:10,509 --> 00:08:14,649
get rid of the day reducer to a month or

00:08:12,849 --> 00:08:20,860
so they're the ones that are built in by

00:08:14,649 --> 00:08:22,839
standard but Milton wants quarterly so

00:08:20,860 --> 00:08:26,919
we write our own function to do this so

00:08:22,839 --> 00:08:29,319
transforms function based expressions

00:08:26,919 --> 00:08:30,699
but they also come with lookup named

00:08:29,319 --> 00:08:32,800
parameters so you can also use it in a

00:08:30,699 --> 00:08:35,620
filter clause that's not terribly

00:08:32,800 --> 00:08:38,019
relevant here we'll just call this a

00:08:35,620 --> 00:08:40,719
function so what this does it takes a

00:08:38,019 --> 00:08:42,219
function name which is date trunk in

00:08:40,719 --> 00:08:48,160
Postgres we're writing this for Postgres

00:08:42,219 --> 00:08:50,829
because we don't use MS sequel yeah we

00:08:48,160 --> 00:08:52,389
provide a template parameter usually you

00:08:50,829 --> 00:08:53,080
don't need to change this but because we

00:08:52,389 --> 00:08:55,450
want a hardcore

00:08:53,080 --> 00:08:56,529
hard codes the quarter parameter in

00:08:55,450 --> 00:08:59,740
we're changing that as well

00:08:56,529 --> 00:09:01,630
we're giving a double-cut name so okay

00:08:59,740 --> 00:09:05,920
we've gotten the NIP method that takes a

00:09:01,630 --> 00:09:08,769
single expression expressions functions

00:09:05,920 --> 00:09:11,740
transforms they all work together so you

00:09:08,769 --> 00:09:14,140
can combine you can merge you can add

00:09:11,740 --> 00:09:15,459
subtract them all together so everything

00:09:14,140 --> 00:09:17,470
takes an expression everything operates

00:09:15,459 --> 00:09:21,100
on expressions it's a big tree of

00:09:17,470 --> 00:09:23,769
expression objects so we set the output

00:09:21,100 --> 00:09:25,480
field to date/time and that just means

00:09:23,769 --> 00:09:27,310
that whatever is coming back from the

00:09:25,480 --> 00:09:29,320
database is going to be loaded into a

00:09:27,310 --> 00:09:30,820
date/time field so then it can do

00:09:29,320 --> 00:09:32,890
conversions so then you can do lookups

00:09:30,820 --> 00:09:33,279
on it so everything kind of plays nice

00:09:32,890 --> 00:09:36,750
together

00:09:33,279 --> 00:09:40,269
Django understands model fields right

00:09:36,750 --> 00:09:43,140
okay so we've got a couple more methods

00:09:40,269 --> 00:09:46,000
here these aren't strictly necessary but

00:09:43,140 --> 00:09:47,079
there's a lot of methods that you can

00:09:46,000 --> 00:09:49,750
override to provide more functionality

00:09:47,079 --> 00:09:52,630
depending on what you want to do so here

00:09:49,750 --> 00:09:55,480
we've got a basic convert method and

00:09:52,630 --> 00:10:00,209
what that does is it checks to see if we

00:09:55,480 --> 00:10:02,380
were expecting a date and if we've got a

00:10:00,209 --> 00:10:05,649
date/time coming back from the database

00:10:02,380 --> 00:10:09,160
it just truncates the the time away and

00:10:05,649 --> 00:10:11,410
returns a date for you as well we've got

00:10:09,160 --> 00:10:14,620
a as sequel Lite method

00:10:11,410 --> 00:10:16,810
there's expressions use an expressions

00:10:14,620 --> 00:10:19,240
API so it's a set of about six or seven

00:10:16,810 --> 00:10:21,940
different methods and in properties and

00:10:19,240 --> 00:10:24,880
one of the cool things about this is

00:10:21,940 --> 00:10:26,620
that different backends you can provide

00:10:24,880 --> 00:10:28,839
support for different backends directly

00:10:26,620 --> 00:10:30,339
in the front-end objects so that was

00:10:28,839 --> 00:10:32,740
never possible before if you wanted to

00:10:30,339 --> 00:10:33,940
build your own expression or lookup what

00:10:32,740 --> 00:10:36,160
you had to do is build a front-end

00:10:33,940 --> 00:10:37,570
object like this you also needed to add

00:10:36,160 --> 00:10:39,850
all of the cycle into the backend that

00:10:37,570 --> 00:10:41,620
you wanted to support so if you wanted

00:10:39,850 --> 00:10:43,690
to support something like MongoDB you'd

00:10:41,620 --> 00:10:45,459
have to places to you know add your

00:10:43,690 --> 00:10:47,949
expressions or if you wanted to support

00:10:45,459 --> 00:10:51,130
NS able to places to put your

00:10:47,949 --> 00:10:52,750
expressions and your cycle so here

00:10:51,130 --> 00:10:55,180
because cycle light doesn't support

00:10:52,750 --> 00:10:56,589
truncating into quarter we boot it off

00:10:55,180 --> 00:10:57,670
we give them a nice error message so

00:10:56,589 --> 00:11:01,480
they don't see the database error

00:10:57,670 --> 00:11:01,779
message now that's kind of a lot to take

00:11:01,480 --> 00:11:03,699
in

00:11:01,779 --> 00:11:06,940
resolve expression is one of the main

00:11:03,699 --> 00:11:08,950
parts of the query API

00:11:06,940 --> 00:11:10,209
and basically what it does is it gives

00:11:08,950 --> 00:11:11,440
you access to the query that you're

00:11:10,209 --> 00:11:13,510
adding it to and lets you do any

00:11:11,440 --> 00:11:15,850
pre-processing that you might need to do

00:11:13,510 --> 00:11:18,730
now the main thing to remember about

00:11:15,850 --> 00:11:20,920
resolve expression is that you need to

00:11:18,730 --> 00:11:23,980
do everything on a copy of the object so

00:11:20,920 --> 00:11:25,540
if you call the superclass it'll return

00:11:23,980 --> 00:11:27,610
a copy for you and that's so you're not

00:11:25,540 --> 00:11:30,820
mutating objects that have been used

00:11:27,610 --> 00:11:33,160
across multiple query sets so all this

00:11:30,820 --> 00:11:35,200
does is provides some helpful error

00:11:33,160 --> 00:11:36,880
messages again if the inputs coming

00:11:35,200 --> 00:11:38,170
through is in a date or date/time field

00:11:36,880 --> 00:11:40,209
get rid of it

00:11:38,170 --> 00:11:48,399
same thing for the output field and then

00:11:40,209 --> 00:11:50,250
it just returns a copy okay so we wrote

00:11:48,399 --> 00:11:52,959
a whole lot of code just to support

00:11:50,250 --> 00:11:55,690
quarterly aggregation right so you jump

00:11:52,959 --> 00:11:57,160
onto IRC because you need to you need to

00:11:55,690 --> 00:11:58,540
support time zones you don't know how to

00:11:57,160 --> 00:12:00,490
support time zones so you're going there

00:11:58,540 --> 00:12:02,430
for a bit of help and funky Bob tells

00:12:00,490 --> 00:12:06,700
you to read the docs because in 1.10

00:12:02,430 --> 00:12:09,580
you've got a whole lot more so now that

00:12:06,700 --> 00:12:11,170
trunk base is in 1.10 and like I said

00:12:09,580 --> 00:12:12,600
all the truncation and extraction

00:12:11,170 --> 00:12:15,339
functions that we spoke about before

00:12:12,600 --> 00:12:19,600
your code reduces a lot so all you have

00:12:15,339 --> 00:12:22,029
to do is override the kind class

00:12:19,600 --> 00:12:23,740
property give it a lookup name if you

00:12:22,029 --> 00:12:24,459
want to support transforms and then

00:12:23,740 --> 00:12:28,180
you're good to go

00:12:24,459 --> 00:12:29,740
so this query down here we're still

00:12:28,180 --> 00:12:32,980
doing the same thing we're excluding

00:12:29,740 --> 00:12:34,660
kids and we're aggregating to our

00:12:32,980 --> 00:12:39,630
quarterly and we use in double cut

00:12:34,660 --> 00:12:39,630
quarter here and we get a count of 506

00:12:41,250 --> 00:12:49,420
okay so here's the actual report that

00:12:45,100 --> 00:12:51,040
Milton asked for we're doing the same

00:12:49,420 --> 00:12:53,770
thing restricting by kids

00:12:51,040 --> 00:12:57,640
we're annotating on the quarterly so

00:12:53,770 --> 00:13:00,550
we're adding the quarter function as a

00:12:57,640 --> 00:13:02,709
select attribute so then we can restrict

00:13:00,550 --> 00:13:05,529
it and group it by using values called

00:13:02,709 --> 00:13:08,079
later on so what we'd like to eventually

00:13:05,529 --> 00:13:10,180
support is just throwing sale date

00:13:08,079 --> 00:13:12,700
underscore underscore quarter into the

00:13:10,180 --> 00:13:15,730
values call and completely avoid the

00:13:12,700 --> 00:13:16,990
need to annotate that on as well that

00:13:15,730 --> 00:13:18,490
would be a great theme to support if

00:13:16,990 --> 00:13:19,580
you're looking for something to do at

00:13:18,490 --> 00:13:21,590
the sprints and there's point

00:13:19,580 --> 00:13:24,290
of Django developers to kind of help you

00:13:21,590 --> 00:13:27,320
do that too so we grouped by the quarter

00:13:24,290 --> 00:13:28,730
we take the revenue we take the sales we

00:13:27,320 --> 00:13:32,230
order it by quarter and the awesome

00:13:28,730 --> 00:13:32,230
Scott is a nice little report

00:13:36,550 --> 00:13:41,540
all right so bosses are happy but now

00:13:39,650 --> 00:13:44,030
they want more I think they're just kind

00:13:41,540 --> 00:13:45,980
of frustrated at the moment with how

00:13:44,030 --> 00:13:48,770
good you are so now they want to break

00:13:45,980 --> 00:13:50,360
up revenue into their biggest market so

00:13:48,770 --> 00:13:52,310
Victoria New South Wales in Australia

00:13:50,360 --> 00:13:54,350
they say that's where you know all our

00:13:52,310 --> 00:13:55,580
customers are show us those individually

00:13:54,350 --> 00:14:01,000
so we can start targeting customers

00:13:55,580 --> 00:14:03,980
there so for this we'll need a

00:14:01,000 --> 00:14:07,340
conditional expression so we need to

00:14:03,980 --> 00:14:08,890
pivot data essentially so we've got we

00:14:07,340 --> 00:14:11,840
could create a row that said Victoria

00:14:08,890 --> 00:14:13,670
Quarter blah blah blah but that'll get

00:14:11,840 --> 00:14:15,440
unwieldly the more columns that you read

00:14:13,670 --> 00:14:17,060
into the grouping so what you want to do

00:14:15,440 --> 00:14:18,920
is you want to extract the data out and

00:14:17,060 --> 00:14:21,140
put it into a new column which is what

00:14:18,920 --> 00:14:24,770
some in case do so you want to take the

00:14:21,140 --> 00:14:27,290
aggregate of a condition so when the

00:14:24,770 --> 00:14:29,960
state equals Victoria you want to get

00:14:27,290 --> 00:14:32,030
the sale price and when it's not then

00:14:29,960 --> 00:14:36,560
you just want to say you know empty and

00:14:32,030 --> 00:14:38,150
then sum it all together now if anyone's

00:14:36,560 --> 00:14:41,330
familiar with Excel and I'm sure many

00:14:38,150 --> 00:14:43,460
people are that sounds like some if so

00:14:41,330 --> 00:14:45,950
there's a sum if function in Excel which

00:14:43,460 --> 00:14:47,930
takes a condition it takes the field

00:14:45,950 --> 00:14:51,710
that you want to sum up and add it all

00:14:47,930 --> 00:14:54,470
together so instead of writing that big

00:14:51,710 --> 00:14:56,780
wieldy case when expression with the sum

00:14:54,470 --> 00:15:00,770
will write a big function instead and

00:14:56,780 --> 00:15:03,110
that will approximate well it'll do the

00:15:00,770 --> 00:15:04,730
same thing like I said before all

00:15:03,110 --> 00:15:07,280
expressions are just a big object tree

00:15:04,730 --> 00:15:09,740
so you can combine them in the

00:15:07,280 --> 00:15:10,940
interesting ways you can rename them you

00:15:09,740 --> 00:15:17,510
can do exactly what we're doing here

00:15:10,940 --> 00:15:20,960
which is copying the the signature of of

00:15:17,510 --> 00:15:23,090
the case when structure build it all up

00:15:20,960 --> 00:15:24,890
together and then we can use that

00:15:23,090 --> 00:15:28,030
instead of a big long case where in

00:15:24,890 --> 00:15:28,030
string now query sets

00:15:32,720 --> 00:15:45,960
okay so let's put that all together all

00:15:42,870 --> 00:15:49,710
right here's our final query and it's

00:15:45,960 --> 00:15:52,770
getting pretty big and a little bit hard

00:15:49,710 --> 00:15:55,140
to read on this screen but we do the

00:15:52,770 --> 00:15:57,390
same thing we did before we're excluding

00:15:55,140 --> 00:15:59,640
kids from the calculation because that's

00:15:57,390 --> 00:16:02,820
not what we're interested in we're

00:15:59,640 --> 00:16:06,690
adding the quarterly date or we're

00:16:02,820 --> 00:16:08,070
aggregating up to a quarterly date we're

00:16:06,690 --> 00:16:10,890
then grouping by that quarter we're

00:16:08,070 --> 00:16:13,050
taking the revenue of the sale some of

00:16:10,890 --> 00:16:15,120
the sale price to generate revenue we're

00:16:13,050 --> 00:16:17,940
taking the count of sales to get the

00:16:15,120 --> 00:16:19,350
number of sales we're calculating the

00:16:17,940 --> 00:16:21,450
revenue of Victoria we're calculating

00:16:19,350 --> 00:16:23,310
the revenue of New South Wales and we're

00:16:21,450 --> 00:16:25,640
ordering it by quarter so that's looking

00:16:23,310 --> 00:16:25,640
pretty good

00:16:27,020 --> 00:16:32,670
but boss doesn't like it

00:16:29,510 --> 00:16:34,350
he's over it he changes his mind all the

00:16:32,670 --> 00:16:36,750
time because he's not a very nice guy

00:16:34,350 --> 00:16:38,400
and what he wants is a growth report

00:16:36,750 --> 00:16:40,760
instead he hears about all these SAS

00:16:38,400 --> 00:16:43,350
companies doing month over month growth

00:16:40,760 --> 00:16:45,060
and he wants her he wants to be

00:16:43,350 --> 00:16:46,589
difficult he knows month over month he's

00:16:45,060 --> 00:16:47,880
supported by Jango but he wants to be

00:16:46,589 --> 00:16:49,589
difficult he wants quarter-over-quarter

00:16:47,880 --> 00:16:53,910
growth instead and goes that should be

00:16:49,589 --> 00:16:56,430
easy you've done this up until now so

00:16:53,910 --> 00:16:58,220
this is the sequel that would get us

00:16:56,430 --> 00:17:01,980
there let's go back a minute

00:16:58,220 --> 00:17:06,390
quarter-over-quarter growth would be

00:17:01,980 --> 00:17:08,189
easy if we could compare the difference

00:17:06,390 --> 00:17:10,829
between revenue from one quarter to the

00:17:08,189 --> 00:17:13,230
next so if you could write some sequel

00:17:10,829 --> 00:17:15,630
that was able to investigate the wrote

00:17:13,230 --> 00:17:18,209
law see the row behind it then we could

00:17:15,630 --> 00:17:20,220
calculate that quite easily but standard

00:17:18,209 --> 00:17:21,689
cycle doesn't all that's debatable

00:17:20,220 --> 00:17:24,300
standard circle doesn't really have a

00:17:21,689 --> 00:17:25,679
mechanism for doing that some of the

00:17:24,300 --> 00:17:27,870
newer standards do though and they're

00:17:25,679 --> 00:17:30,330
called analytical functions Postgres

00:17:27,870 --> 00:17:33,420
supports them MS equal service supports

00:17:30,330 --> 00:17:37,130
them Oracle supports them my circle my

00:17:33,420 --> 00:17:37,130
circle doesn't support them

00:17:38,240 --> 00:17:44,480
cheap laughs my cycle bagging sorry okay

00:17:42,440 --> 00:17:46,940
so if we were writing this query out

00:17:44,480 --> 00:17:50,470
this is probably what we'd write so

00:17:46,940 --> 00:17:53,210
we've got we've got our original query

00:17:50,470 --> 00:17:55,880
truncated a little bit for space over

00:17:53,210 --> 00:17:58,370
here so we'd write our normal date trunk

00:17:55,880 --> 00:18:01,070
we'd group by it would I calculate the

00:17:58,370 --> 00:18:02,420
revenue we do all our grouping etc easy

00:18:01,070 --> 00:18:05,060
that'll give us the table that we had

00:18:02,420 --> 00:18:07,880
before but now we need to calculate

00:18:05,060 --> 00:18:09,350
growth in the growth revenue the revenue

00:18:07,880 --> 00:18:10,640
that happened the quarter before and use

00:18:09,350 --> 00:18:11,540
those together and that's what the lag

00:18:10,640 --> 00:18:14,150
function does

00:18:11,540 --> 00:18:17,210
so what lag does is that lets you see a

00:18:14,150 --> 00:18:20,240
row before based on some ordering so

00:18:17,210 --> 00:18:23,090
we're ordering by quarter lag by default

00:18:20,240 --> 00:18:26,210
looks at the row one before so if you

00:18:23,090 --> 00:18:30,710
take revenue of your current row divided

00:18:26,210 --> 00:18:32,840
by the revenue of the row before and

00:18:30,710 --> 00:18:34,220
then you know do your percentage

00:18:32,840 --> 00:18:36,470
calculations you get a nice little

00:18:34,220 --> 00:18:38,720
growth so we've got the circle to do

00:18:36,470 --> 00:18:41,420
that but how do we get Jango to execute

00:18:38,720 --> 00:18:43,220
leus the on doesn't support analytical

00:18:41,420 --> 00:18:46,730
queries the lawn doesn't really support

00:18:43,220 --> 00:18:48,680
sub queries well it doesn't let you mess

00:18:46,730 --> 00:18:52,430
around that much with it so our options

00:18:48,680 --> 00:18:54,500
are limited but Jango does give you the

00:18:52,430 --> 00:18:55,850
database connection directly and you're

00:18:54,500 --> 00:18:57,680
able to get the cursor out of that

00:18:55,850 --> 00:19:01,460
directly so you might have heard about

00:18:57,680 --> 00:19:03,350
rural queries Jango brought our objects

00:19:01,460 --> 00:19:05,720
raw you might have heard about objects

00:19:03,350 --> 00:19:07,190
objects extra but those aren't actually

00:19:05,720 --> 00:19:09,710
going to do anything for you in this

00:19:07,190 --> 00:19:13,190
case so what we do we grab the sequel

00:19:09,710 --> 00:19:16,100
from before we take a cursor we execute

00:19:13,190 --> 00:19:17,660
it we get all the column names so we can

00:19:16,100 --> 00:19:21,860
zip it up together and form a nice

00:19:17,660 --> 00:19:23,870
little table we execute the query and

00:19:21,860 --> 00:19:25,850
we've got our results directly into

00:19:23,870 --> 00:19:30,680
Jango so we just skipped all the arm

00:19:25,850 --> 00:19:34,460
altogether but that's fine oh that's

00:19:30,680 --> 00:19:36,230
fine because the arm is just a

00:19:34,460 --> 00:19:39,260
convenience it's supposed to make the

00:19:36,230 --> 00:19:41,390
easy things easy the standard things

00:19:39,260 --> 00:19:44,420
easy and Jango wasn't really built with

00:19:41,390 --> 00:19:47,150
reporting in mind right it was built for

00:19:44,420 --> 00:19:50,390
CMS's it was built for you know

00:19:47,150 --> 00:19:52,080
categories and shops and one-time

00:19:50,390 --> 00:19:53,520
passwords

00:19:52,080 --> 00:19:57,450
it didn't really have these big

00:19:53,520 --> 00:20:01,220
analytical queries in mind but as long

00:19:57,450 --> 00:20:03,600
as you are targeting a specific database

00:20:01,220 --> 00:20:06,029
which most people are most people don't

00:20:03,600 --> 00:20:08,100
run these kinds of queries on multiple

00:20:06,029 --> 00:20:09,690
database types unless you're writing

00:20:08,100 --> 00:20:12,090
reusable apps and then you've got to do

00:20:09,690 --> 00:20:14,130
what you've got to do but you can skip

00:20:12,090 --> 00:20:18,179
the on go directly to the database save

00:20:14,130 --> 00:20:20,039
yourself some time save do you on from

00:20:18,179 --> 00:20:21,840
doing a whole lot of work and get the

00:20:20,039 --> 00:20:35,669
job done quicker you DBAs will be happy

00:20:21,840 --> 00:20:37,230
to and that's me okay once again up for

00:20:35,669 --> 00:20:42,570
questions and I think Marcus wants to

00:20:37,230 --> 00:20:46,710
ask a question so you said that you

00:20:42,570 --> 00:20:50,190
can't do the leg functions through the

00:20:46,710 --> 00:20:53,520
RM you can still so from what from my

00:20:50,190 --> 00:20:56,880
experience on the or m dot annotate can

00:20:53,520 --> 00:20:59,220
put stuff into the selectors so I can

00:20:56,880 --> 00:21:03,080
come up with a thing that then boils

00:20:59,220 --> 00:21:05,520
down to a bit of sequel which represents

00:21:03,080 --> 00:21:07,770
how would you do that

00:21:05,520 --> 00:21:10,559
I've been thinking about how that would

00:21:07,770 --> 00:21:14,580
be supported for a while and there's

00:21:10,559 --> 00:21:15,720
windowing clauses that would be a little

00:21:14,580 --> 00:21:16,799
bit weird to construct with you on

00:21:15,720 --> 00:21:20,070
although you could do it because they're

00:21:16,799 --> 00:21:21,809
all just objects but then or during the

00:21:20,070 --> 00:21:25,770
query set that you're wanting to write

00:21:21,809 --> 00:21:27,570
an analytical function over and writing

00:21:25,770 --> 00:21:29,190
the sub query in such a way that the

00:21:27,570 --> 00:21:32,190
analytical function would work that's

00:21:29,190 --> 00:21:34,020
the difficult bit so you can write some

00:21:32,190 --> 00:21:35,700
analytical queries without worrying

00:21:34,020 --> 00:21:39,870
about the rest of the aggregation or

00:21:35,700 --> 00:21:41,640
teaching the aggregation framework to or

00:21:39,870 --> 00:21:43,080
what analytical functions were and then

00:21:41,640 --> 00:21:45,510
it might be able to support basic ones

00:21:43,080 --> 00:21:50,429
but in general it's not possible just

00:21:45,510 --> 00:21:53,070
yet most of the time the or gives you

00:21:50,429 --> 00:21:54,510
quite a good abstraction and you never

00:21:53,070 --> 00:21:58,649
have to worry about you know have to

00:21:54,510 --> 00:22:00,570
think in SQL terms that mostly that that

00:21:58,649 --> 00:22:03,389
what's almost all the time that only

00:22:00,570 --> 00:22:04,500
time I've noticed it sort of leaking

00:22:03,389 --> 00:22:07,290
through to

00:22:04,500 --> 00:22:09,060
exposed SQL is when you are selecting

00:22:07,290 --> 00:22:12,390
some objects and filtering on the

00:22:09,060 --> 00:22:14,880
reverse end of a foreign key and then

00:22:12,390 --> 00:22:18,120
you have to use distinct to sort of

00:22:14,880 --> 00:22:19,920
throw away the objects no right to make

00:22:18,120 --> 00:22:23,280
them distinct and if your order if you

00:22:19,920 --> 00:22:26,130
accidentally or somehow or rather are

00:22:23,280 --> 00:22:27,990
ordering on something that's also in the

00:22:26,130 --> 00:22:29,310
reverse end of the Frankie even distinct

00:22:27,990 --> 00:22:30,870
doesn't work because suddenly they're

00:22:29,310 --> 00:22:33,300
all out of order and so you kind of have

00:22:30,870 --> 00:22:35,280
to know about you have to kind of know

00:22:33,300 --> 00:22:37,590
that SQL is there under that

00:22:35,280 --> 00:22:40,560
circumstance and probably not many other

00:22:37,590 --> 00:22:45,090
circumstances does that worry anybody

00:22:40,560 --> 00:22:46,470
else yes yes because you don't get any

00:22:45,090 --> 00:22:48,270
error messages either you just get

00:22:46,470 --> 00:22:50,070
correct results you kind of have the

00:22:48,270 --> 00:22:52,560
abstraction breaks you know it does it

00:22:50,070 --> 00:22:54,630
totally breaks down and there's ideas of

00:22:52,560 --> 00:22:57,780
how to fix that well the problem itself

00:22:54,630 --> 00:23:01,380
is the ormm doesn't know whether it

00:22:57,780 --> 00:23:03,510
should reuse a sub query or not and

00:23:01,380 --> 00:23:04,770
that's kind of what the nautical filter

00:23:03,510 --> 00:23:06,900
was all about people have been asking

00:23:04,770 --> 00:23:08,190
about that for years because of that

00:23:06,900 --> 00:23:10,860
issue that you just mentioned when

00:23:08,190 --> 00:23:13,010
you're doing excludes across many to

00:23:10,860 --> 00:23:15,600
many is or when you're doing reverse

00:23:13,010 --> 00:23:18,450
reverse daughter's it's essentially the

00:23:15,600 --> 00:23:21,390
same problem yeah so yes it worries

00:23:18,450 --> 00:23:22,770
people it worries us in particular it

00:23:21,390 --> 00:23:24,270
would be much better if it blew up and

00:23:22,770 --> 00:23:25,890
just said write your own cycle for this

00:23:24,270 --> 00:23:28,050
particular case rather than handing back

00:23:25,890 --> 00:23:29,700
incorrect results I think I agree yeah

00:23:28,050 --> 00:23:32,190
and thank you for the expressions things

00:23:29,700 --> 00:23:36,090
it's it's really useful awesome thank

00:23:32,190 --> 00:23:37,110
you thank you for a very enlightening

00:23:36,090 --> 00:23:39,330
talk

00:23:37,110 --> 00:23:42,000
Python has their philosophy of batteries

00:23:39,330 --> 00:23:44,550
included how many of these extra like

00:23:42,000 --> 00:23:46,320
queries like the quarterly truncation

00:23:44,550 --> 00:23:51,260
for example do you think will end up in

00:23:46,320 --> 00:23:56,160
Jango cause hopefully hopefully a lot

00:23:51,260 --> 00:23:58,710
not to me I know that's I know that goes

00:23:56,160 --> 00:24:01,830
a bit against it well we don't want a

00:23:58,710 --> 00:24:03,690
whole lot of of functions that only work

00:24:01,830 --> 00:24:05,670
on one particular database or only work

00:24:03,690 --> 00:24:09,360
on like a small subset of them that's

00:24:05,670 --> 00:24:10,530
why the Postgres contrib Postgres module

00:24:09,360 --> 00:24:12,030
was really good because they could throw

00:24:10,530 --> 00:24:14,010
a whole lot of functions in there for

00:24:12,030 --> 00:24:15,570
all the new field types and stuff

00:24:14,010 --> 00:24:17,910
without polluting the rest of the

00:24:15,570 --> 00:24:19,380
namespace

00:24:17,910 --> 00:24:21,450
things that people are going to use

00:24:19,380 --> 00:24:22,050
fairly often I think should make it in

00:24:21,450 --> 00:24:24,750
there

00:24:22,050 --> 00:24:27,960
whole lot of string based functions are

00:24:24,750 --> 00:24:29,430
in their date process in which is really

00:24:27,960 --> 00:24:31,590
really common especially in reporting

00:24:29,430 --> 00:24:34,380
type scenarios that's just made it in

00:24:31,590 --> 00:24:36,120
there in an easy to easier to use form

00:24:34,380 --> 00:24:40,260
it was hidden before but it was still

00:24:36,120 --> 00:24:42,540
accessible there's there's scope for

00:24:40,260 --> 00:24:45,090
while there's more room for a bigger

00:24:42,540 --> 00:24:46,740
scope provided that you know people want

00:24:45,090 --> 00:24:48,120
to convene it commit it if they want to

00:24:46,740 --> 00:24:49,470
write it and ask for it to be added

00:24:48,120 --> 00:24:51,660
that's that's awesome and it's a great

00:24:49,470 --> 00:24:55,080
way to get new bees into development as

00:24:51,660 --> 00:24:57,360
well I think with the API and having

00:24:55,080 --> 00:25:00,900
those things in what support is there

00:24:57,360 --> 00:25:02,640
for alternate backends because I noticed

00:25:00,900 --> 00:25:06,150
one of the method calls they was called

00:25:02,640 --> 00:25:07,890
as SQLite and if you've got an alternate

00:25:06,150 --> 00:25:10,980
back end that isn't part of Jango core

00:25:07,890 --> 00:25:13,920
is there a way of getting those queries

00:25:10,980 --> 00:25:17,400
translated into your backends yes so

00:25:13,920 --> 00:25:20,790
what that does every connection has or

00:25:17,400 --> 00:25:22,560
every back end has a vendor property so

00:25:20,790 --> 00:25:24,570
Postgres is Postgres circulator cycle

00:25:22,560 --> 00:25:27,960
light if you had it would be

00:25:24,570 --> 00:25:32,100
MS cycle ms cycle so if you define an as

00:25:27,960 --> 00:25:34,020
vendor when the expression is been

00:25:32,100 --> 00:25:35,850
compiled or that as cycle method is

00:25:34,020 --> 00:25:38,670
being run the as cycle method gets

00:25:35,850 --> 00:25:42,230
skipped the standard method method gets

00:25:38,670 --> 00:25:45,990
called instead and that's how we bring I

00:25:42,230 --> 00:25:47,310
guess all these extra features to

00:25:45,990 --> 00:25:48,720
backends that we might not want to

00:25:47,310 --> 00:25:51,570
support backends can also add their own

00:25:48,720 --> 00:25:55,220
methods to existing existing expressions

00:25:51,570 --> 00:25:57,420
as well with monkey patching so it's yes

00:25:55,220 --> 00:26:00,860
how else would you do it and without

00:25:57,420 --> 00:26:03,420
going in and changing the code right

00:26:00,860 --> 00:26:04,860
yeah that that's been discussed but a

00:26:03,420 --> 00:26:06,950
registration pattern is still going to

00:26:04,860 --> 00:26:10,380
be a similar thing it's just going to be

00:26:06,950 --> 00:26:12,120
slightly fancier way of of doing the

00:26:10,380 --> 00:26:15,810
same thing with just assigning it as

00:26:12,120 --> 00:26:21,000
vendor method it might have been added I

00:26:15,810 --> 00:26:22,560
don't occurs all right all right there's

00:26:21,000 --> 00:26:25,550
no other questions thank you very much

00:26:22,560 --> 00:26:25,550
Josh awesome thank you

00:26:25,620 --> 00:26:27,680

YouTube URL: https://www.youtube.com/watch?v=9rEB6ra4aB8


