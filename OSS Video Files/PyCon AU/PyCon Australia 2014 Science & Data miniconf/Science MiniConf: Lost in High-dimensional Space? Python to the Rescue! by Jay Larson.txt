Title: Science MiniConf: Lost in High-dimensional Space? Python to the Rescue! by Jay Larson
Publication date: 2014-08-11
Playlist: PyCon Australia 2014 Science & Data miniconf
Description: 
	PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:05,170 --> 00:00:11,170
great so at Jay Larson Jay worked at the

00:00:09,070 --> 00:00:13,420
Argonne National Lab and the University

00:00:11,170 --> 00:00:15,660
of Chicago and nasa's goddard space

00:00:13,420 --> 00:00:20,950
flight center and is now a fellow in

00:00:15,660 --> 00:00:23,050
mathematical sciences at anu and he's

00:00:20,950 --> 00:00:25,720
the author of over 70 refereed

00:00:23,050 --> 00:00:27,640
publications in theoretical physics and

00:00:25,720 --> 00:00:29,680
plasma physics and climate ology and

00:00:27,640 --> 00:00:33,580
weather forecasting and computer science

00:00:29,680 --> 00:00:36,070
and he was a code lead developer of the

00:00:33,580 --> 00:00:39,610
model coupling toolkit and architect on

00:00:36,070 --> 00:00:42,909
the community climate system model and a

00:00:39,610 --> 00:00:47,140
Python wrapper for that pie ccsm so he

00:00:42,909 --> 00:00:49,479
has a undergrad and PhD degrees in maths

00:00:47,140 --> 00:00:50,830
and physics and he's going to be talking

00:00:49,479 --> 00:00:58,629
us today about high dimensional grid of

00:00:50,830 --> 00:01:02,080
data please welcome Jay hey yeah hey

00:00:58,629 --> 00:01:06,310
thanks can everybody hear me okay we're

00:01:02,080 --> 00:01:08,440
off to a good start yes so as I pointed

00:01:06,310 --> 00:01:12,430
out I am basically a recovering

00:01:08,440 --> 00:01:14,619
theoretical physicist and asst and as

00:01:12,430 --> 00:01:16,359
some of my colleagues say have I have I

00:01:14,619 --> 00:01:19,960
tried to make amends for my theoretical

00:01:16,359 --> 00:01:25,329
physics well no that's why I'm still in

00:01:19,960 --> 00:01:29,619
recovery anyway so I'm going to spend

00:01:25,329 --> 00:01:32,950
some time talking about well just a few

00:01:29,619 --> 00:01:35,829
basic tricks that one can use to play

00:01:32,950 --> 00:01:38,590
around in high-dimensional space now the

00:01:35,829 --> 00:01:41,170
problem is probably describing the

00:01:38,590 --> 00:01:44,679
problem itself is going to take a little

00:01:41,170 --> 00:01:48,280
bit of time so we'll we'll try to do

00:01:44,679 --> 00:01:51,030
that as best as possible without you

00:01:48,280 --> 00:01:54,909
know burning up all the time doing that

00:01:51,030 --> 00:02:02,259
so the next 20 minutes will go by

00:01:54,909 --> 00:02:04,479
quickly I suspect so let's go okay so as

00:02:02,259 --> 00:02:09,610
the title says lost in high-dimensional

00:02:04,479 --> 00:02:11,710
space python to the rescue well what do

00:02:09,610 --> 00:02:14,200
I mean by that well I just mean there's

00:02:11,710 --> 00:02:18,980
a large number of spatial dimensions for

00:02:14,200 --> 00:02:20,840
a problem and suppose you want to disc

00:02:18,980 --> 00:02:23,180
thais each of those dimensions and

00:02:20,840 --> 00:02:25,970
suppose further just for the sake of

00:02:23,180 --> 00:02:29,510
argument you want to discretize them

00:02:25,970 --> 00:02:32,420
with the same number of access points in

00:02:29,510 --> 00:02:36,709
each dimension okay just work with me on

00:02:32,420 --> 00:02:39,200
this now should you choose to do that

00:02:36,709 --> 00:02:41,299
you'll find the number of grid points in

00:02:39,200 --> 00:02:44,799
this D dimensional space will grow

00:02:41,299 --> 00:02:48,079
exponentially with that dimension and

00:02:44,799 --> 00:02:50,810
there is a very glamorous and well-known

00:02:48,079 --> 00:02:58,010
term for this it's called the curse of

00:02:50,810 --> 00:03:00,170
dimensionality now there are attempts to

00:02:58,010 --> 00:03:02,299
try to tackle this in high dimensional

00:03:00,170 --> 00:03:05,209
systems one of the best tools for it is

00:03:02,299 --> 00:03:10,209
something called a sparse grid now a

00:03:05,209 --> 00:03:14,150
sparse grid is a mechanism for providing

00:03:10,209 --> 00:03:19,150
fine scale detail in each of the

00:03:14,150 --> 00:03:22,510
individual dimensions and providing some

00:03:19,150 --> 00:03:25,160
varying degrees of detail in shared

00:03:22,510 --> 00:03:29,090
multi-dimensional subspaces but not the

00:03:25,160 --> 00:03:31,669
complete story and these things

00:03:29,090 --> 00:03:33,680
typically are constructed from a number

00:03:31,669 --> 00:03:37,400
of course or grids that are called

00:03:33,680 --> 00:03:40,489
component grids and those have fine

00:03:37,400 --> 00:03:44,209
scales in some dimensions course skills

00:03:40,489 --> 00:03:46,190
and others and when you bring all of

00:03:44,209 --> 00:03:50,000
these things together you get something

00:03:46,190 --> 00:03:53,180
looks like the diagram above in two

00:03:50,000 --> 00:03:56,720
dimensions and so you'll say that see

00:03:53,180 --> 00:03:59,750
that says level six sparse grid on

00:03:56,720 --> 00:04:05,180
closed unit square well what is level

00:03:59,750 --> 00:04:07,299
six well again for the sake of reference

00:04:05,180 --> 00:04:12,340
here we're talking about power of two

00:04:07,299 --> 00:04:16,010
partitions of axes the code I've written

00:04:12,340 --> 00:04:17,570
does not make these assumptions but just

00:04:16,010 --> 00:04:19,699
to kind of give you an idea of how

00:04:17,570 --> 00:04:22,010
mathematicians usually look at these

00:04:19,699 --> 00:04:27,560
things and manipulate them and argue

00:04:22,010 --> 00:04:31,430
about them power of 2 so 2 to the sixth

00:04:27,560 --> 00:04:32,249
is 64 so the full grid in that case

00:04:31,430 --> 00:04:35,969
would be 6

00:04:32,249 --> 00:04:40,859
be well 65 x 65 because it has the

00:04:35,969 --> 00:04:43,319
boundaries as well and what you're

00:04:40,859 --> 00:04:46,259
seeing there is you can see a dot where

00:04:43,319 --> 00:04:48,929
each of those sparse grid points shows

00:04:46,259 --> 00:04:52,829
up we'll talk about exactly how that's

00:04:48,929 --> 00:04:55,879
generated in the slider to now here is

00:04:52,829 --> 00:04:59,339
something for the cube that's a level 5

00:04:55,879 --> 00:05:02,609
sparse grid on the closed unit cube so

00:04:59,339 --> 00:05:06,869
it has the boundaries and so that means

00:05:02,609 --> 00:05:09,479
the maximum resolution is 32 well 33

00:05:06,869 --> 00:05:14,189
grid points in any given dimension for

00:05:09,479 --> 00:05:15,749
the full grid i would add these pictures

00:05:14,189 --> 00:05:18,659
were generated with the code i've

00:05:15,749 --> 00:05:23,969
written to do these things so it

00:05:18,659 --> 00:05:27,289
literally is this stuff you know we just

00:05:23,969 --> 00:05:29,789
did some math the sizes of the dots

00:05:27,289 --> 00:05:33,209
correspond to how many of the component

00:05:29,789 --> 00:05:35,939
grids on which that grid point lives so

00:05:33,209 --> 00:05:39,419
you can see some of them are quite small

00:05:35,939 --> 00:05:40,979
and some of them are quite large so

00:05:39,419 --> 00:05:47,219
they're common to many grids if they're

00:05:40,979 --> 00:05:50,399
large okay so these things are very

00:05:47,219 --> 00:05:52,199
powerful for reducing you know you can

00:05:50,399 --> 00:05:54,539
get a lot of bang for the buck so to

00:05:52,199 --> 00:05:57,329
speak because you can get a lot of

00:05:54,539 --> 00:06:01,159
coverage you can get some fine scale

00:05:57,329 --> 00:06:05,159
information you won't get all of it and

00:06:01,159 --> 00:06:08,369
asymptotically the growth rate of the

00:06:05,159 --> 00:06:11,009
number of grid points look something

00:06:08,369 --> 00:06:14,449
like this on a sparse grid and here is

00:06:11,009 --> 00:06:17,219
the full grid which is exponential with

00:06:14,449 --> 00:06:20,819
the dimensionality as you can see this

00:06:17,219 --> 00:06:23,729
grows a little more weakly and you can

00:06:20,819 --> 00:06:27,059
define a complexity ratio as well the

00:06:23,729 --> 00:06:29,219
complexity reduction ratio just by the

00:06:27,059 --> 00:06:34,679
reduction sizes of the sets of grid

00:06:29,219 --> 00:06:38,279
points and I think it's you know it's

00:06:34,679 --> 00:06:41,610
pretty dramatic you may notice here that

00:06:38,279 --> 00:06:42,710
this this color bar it's a common scale

00:06:41,610 --> 00:06:46,760
this is

00:06:42,710 --> 00:06:49,580
log base 10 of those results because

00:06:46,760 --> 00:06:53,120
we're talking about going up to 20

00:06:49,580 --> 00:06:58,520
dimensions and up to thousands of grid

00:06:53,120 --> 00:07:02,230
points on each axis so so these things

00:06:58,520 --> 00:07:05,830
are very useful in a lot of applications

00:07:02,230 --> 00:07:08,480
optimization density estimation in

00:07:05,830 --> 00:07:13,070
systems that have large numbers of

00:07:08,480 --> 00:07:17,750
variables solvers which is more the area

00:07:13,070 --> 00:07:20,900
where I work and in particular on trying

00:07:17,750 --> 00:07:22,760
to use some of the redundancy in this to

00:07:20,900 --> 00:07:27,500
come up with algorithm based fault

00:07:22,760 --> 00:07:29,420
tolerance and there are all kinds of

00:07:27,500 --> 00:07:31,550
reasons why you'd want to do that are

00:07:29,420 --> 00:07:35,420
any people in here involved in

00:07:31,550 --> 00:07:38,360
high-performance computing and a few of

00:07:35,420 --> 00:07:40,880
you so there are a few people if I say

00:07:38,360 --> 00:07:47,660
the word exascale they know what it

00:07:40,880 --> 00:07:49,970
means how about everybody else now it's

00:07:47,660 --> 00:07:51,770
not like I said skull and bones are a

00:07:49,970 --> 00:07:56,600
bunch of guys who have to leave the room

00:07:51,770 --> 00:07:58,670
now okay anyway on these systems large

00:07:56,600 --> 00:08:02,000
numbers of hardware components can mean

00:07:58,670 --> 00:08:04,730
that you get lots of failures you know

00:08:02,000 --> 00:08:06,920
happening during run time and you need

00:08:04,730 --> 00:08:09,080
to be able to code your applications to

00:08:06,920 --> 00:08:12,560
be able to deal with that and so that's

00:08:09,080 --> 00:08:16,280
kind of one of the main drivers behind a

00:08:12,560 --> 00:08:17,870
lot of this work now how do you

00:08:16,280 --> 00:08:20,630
construct these things yes I know

00:08:17,870 --> 00:08:23,900
there's a lot of math there let's not

00:08:20,630 --> 00:08:26,540
concentrate on that too deeply just

00:08:23,900 --> 00:08:28,520
suffice to say there's something you can

00:08:26,540 --> 00:08:30,830
call the scale lattice that gives you

00:08:28,520 --> 00:08:34,370
some idea of how finally your

00:08:30,830 --> 00:08:37,070
partitioning space on each axis and in

00:08:34,370 --> 00:08:41,840
multi-dimensional space so you think of

00:08:37,070 --> 00:08:44,300
this is just a big grid and the

00:08:41,840 --> 00:08:51,200
coordinates of that point are integers

00:08:44,300 --> 00:08:53,120
and that on each site the index for that

00:08:51,200 --> 00:08:56,450
dimension tells you you have say two to

00:08:53,120 --> 00:09:01,550
the I or 1 plus 2 to the eye

00:08:56,450 --> 00:09:03,500
points on that axis and so you can

00:09:01,550 --> 00:09:10,100
define these collections of component

00:09:03,500 --> 00:09:13,910
grids on the scale lattice and then the

00:09:10,100 --> 00:09:16,610
idea is that you have these things you

00:09:13,910 --> 00:09:18,080
can look at redundancy relationships

00:09:16,610 --> 00:09:21,830
between them you can come up with

00:09:18,080 --> 00:09:24,170
combination formulas for say suppose you

00:09:21,830 --> 00:09:27,020
solve a problem on all these different

00:09:24,170 --> 00:09:27,980
grids how would you combine them you

00:09:27,020 --> 00:09:31,220
know how would you do a linear

00:09:27,980 --> 00:09:34,580
superposition of them to calculate on

00:09:31,220 --> 00:09:38,420
the sparse grid an approximation to the

00:09:34,580 --> 00:09:41,030
full grid solution and the level of

00:09:38,420 --> 00:09:44,120
complexity reduction you get for this is

00:09:41,030 --> 00:09:45,950
quite dramatic so even though this

00:09:44,120 --> 00:09:47,390
sounds a little bit crazy that suddenly

00:09:45,950 --> 00:09:50,480
you're managing lots of these different

00:09:47,390 --> 00:09:54,740
grids you may be doing considerably less

00:09:50,480 --> 00:10:01,340
work it may paralyze quite well and you

00:09:54,740 --> 00:10:03,740
may get fault tolerance for that so this

00:10:01,340 --> 00:10:08,450
is how these kind of things work you

00:10:03,740 --> 00:10:10,640
pick a set of coarser component grids

00:10:08,450 --> 00:10:13,310
well I'll show you better geometric

00:10:10,640 --> 00:10:16,790
picture of this in a moment solve the

00:10:13,310 --> 00:10:21,020
problem on each grid compute a linear

00:10:16,790 --> 00:10:22,850
combination solution and perhaps you

00:10:21,020 --> 00:10:25,280
also have to then do some interpolation

00:10:22,850 --> 00:10:28,520
if you happen to have the full grid

00:10:25,280 --> 00:10:30,530
solution is a benchmark against which

00:10:28,520 --> 00:10:34,460
you can try to ground truth your

00:10:30,530 --> 00:10:36,530
techniques and then also propagate the

00:10:34,460 --> 00:10:39,200
solution back to the component grids if

00:10:36,530 --> 00:10:42,010
you're trying to do this iteratively so

00:10:39,200 --> 00:10:45,050
you can think of these update cycles and

00:10:42,010 --> 00:10:48,200
if you have error bounds for your

00:10:45,050 --> 00:10:52,730
schemes you can go to town you know

00:10:48,200 --> 00:10:55,750
modeling errors now what there is here

00:10:52,730 --> 00:10:58,310
is just a general combination formula

00:10:55,750 --> 00:11:01,520
with the coefficients this is something

00:10:58,310 --> 00:11:03,770
called the classic combination don't

00:11:01,520 --> 00:11:06,970
worry about the exact form of this right

00:11:03,770 --> 00:11:10,150
now there will not be a quiz on this

00:11:06,970 --> 00:11:14,050
here is the intuitive picture I promise

00:11:10,150 --> 00:11:17,230
so if you look over here how well does

00:11:14,050 --> 00:11:20,860
this show if I do that that's reasonably

00:11:17,230 --> 00:11:24,130
well so this is in scale space in two

00:11:20,860 --> 00:11:27,820
dimensions on the scale lattice so here

00:11:24,130 --> 00:11:30,160
this first cell is essentially one grid

00:11:27,820 --> 00:11:32,800
point in that direction and one grid

00:11:30,160 --> 00:11:36,520
point vertically there and if you just

00:11:32,800 --> 00:11:39,300
go outwards you find though these are

00:11:36,520 --> 00:11:42,460
kind of higher resolution in X or Y

00:11:39,300 --> 00:11:46,000
depending upon where you go and you may

00:11:42,460 --> 00:11:48,520
notice this redundancy thing I talked

00:11:46,000 --> 00:11:50,320
about if you think about two grids here

00:11:48,520 --> 00:11:52,540
you're adding them together there is an

00:11:50,320 --> 00:11:54,370
overlap between their grid points and

00:11:52,540 --> 00:11:55,990
that's what that negative sign is about

00:11:54,370 --> 00:12:02,140
so you're trying to correct for some

00:11:55,990 --> 00:12:05,080
redundancy and then the beauty of this

00:12:02,140 --> 00:12:07,860
is that you can get situations in which

00:12:05,080 --> 00:12:11,500
if you lose a grid suppose you compute

00:12:07,860 --> 00:12:16,480
even more solutions on other component

00:12:11,500 --> 00:12:24,690
grids you can recover and compute an

00:12:16,480 --> 00:12:28,690
approximation to the solution ok ok so

00:12:24,690 --> 00:12:33,280
that's the general game plan as far as

00:12:28,690 --> 00:12:35,410
math goes now what I've described

00:12:33,280 --> 00:12:37,930
obviously there's some complexity to

00:12:35,410 --> 00:12:40,090
this there's some high-level complexity

00:12:37,930 --> 00:12:42,520
we're talking about well I've got to

00:12:40,090 --> 00:12:46,630
manage all of these things I'm running

00:12:42,520 --> 00:12:48,100
and at first if you go back to this

00:12:46,630 --> 00:12:50,770
picture you say well what are you

00:12:48,100 --> 00:12:52,510
talking about Jay it's like come on you

00:12:50,770 --> 00:12:56,920
can count them on your fingers and toes

00:12:52,510 --> 00:12:58,960
that's not many well again if we're

00:12:56,920 --> 00:13:00,760
talking about higher dimensional systems

00:12:58,960 --> 00:13:02,890
very quickly the number of these

00:13:00,760 --> 00:13:05,410
component grids can grow I mean it grows

00:13:02,890 --> 00:13:08,650
like binomial coefficients sums of

00:13:05,410 --> 00:13:13,150
binomial coefficients so it can grow

00:13:08,650 --> 00:13:15,010
quickly and but manageable so if you

00:13:13,150 --> 00:13:17,650
talk about a six dimensional problem

00:13:15,010 --> 00:13:21,040
saying a plasma physics code where

00:13:17,650 --> 00:13:23,350
you're doing things in phase space you

00:13:21,040 --> 00:13:23,830
can easily get up into a thousand or

00:13:23,350 --> 00:13:25,660
more

00:13:23,830 --> 00:13:28,450
phone and grids so you're talking about

00:13:25,660 --> 00:13:30,790
something where you might be managing a

00:13:28,450 --> 00:13:33,910
lot of things that are running each one

00:13:30,790 --> 00:13:36,010
might be parallel so we're talking about

00:13:33,910 --> 00:13:38,440
as a high level complexity thing there's

00:13:36,010 --> 00:13:45,010
a lot of stuff to drive and monitor and

00:13:38,440 --> 00:13:48,100
combine and ah and that is a reason for

00:13:45,010 --> 00:13:51,100
using Python at the high level now at

00:13:48,100 --> 00:13:55,870
the low level we're talking about mesh

00:13:51,100 --> 00:13:59,140
and grid representation and the mesh is

00:13:55,870 --> 00:14:01,480
again that's tractable for Cartesian

00:13:59,140 --> 00:14:04,150
grid you think well I just need all the

00:14:01,480 --> 00:14:06,700
access points in each dimension the way

00:14:04,150 --> 00:14:11,260
I happen to do this is it's literally a

00:14:06,700 --> 00:14:13,620
list of number i raise the do this that

00:14:11,260 --> 00:14:17,440
part's easy now the gridded field

00:14:13,620 --> 00:14:19,780
representation in high dimensions that's

00:14:17,440 --> 00:14:25,360
more of a problem because of course it's

00:14:19,780 --> 00:14:28,140
growing multiplicatively um so this

00:14:25,360 --> 00:14:30,760
brings us to one of the central things I

00:14:28,140 --> 00:14:34,390
need to start working with arrays in

00:14:30,760 --> 00:14:36,970
high dimensions now if you look at what

00:14:34,390 --> 00:14:39,640
other languages support as far as things

00:14:36,970 --> 00:14:43,960
go ie Python sort of sits in the middle

00:14:39,640 --> 00:14:46,540
on some kind of logarithmic scale of the

00:14:43,960 --> 00:14:48,550
number of dimensions it readily support

00:14:46,540 --> 00:14:52,210
I don't know for a fact whether or not

00:14:48,550 --> 00:14:54,130
you can recompile numpy successfully to

00:14:52,210 --> 00:14:58,990
jack up the number of dimensions i would

00:14:54,130 --> 00:15:02,620
think almost certainly you can and but

00:14:58,990 --> 00:15:06,570
more importantly it's this this syntax

00:15:02,620 --> 00:15:09,100
for dealing with the array elements and

00:15:06,570 --> 00:15:10,510
the first tool out of the box people

00:15:09,100 --> 00:15:13,240
would use for this is virtual

00:15:10,510 --> 00:15:15,100
linearization or they just unravel multi

00:15:13,240 --> 00:15:17,200
dimensional index space to a single

00:15:15,100 --> 00:15:21,400
index and inside of numpy that's what's

00:15:17,200 --> 00:15:23,230
going on but if you're just walking into

00:15:21,400 --> 00:15:25,750
this and programming it yourself you say

00:15:23,230 --> 00:15:29,050
do I have to do this and C++ or Fortran

00:15:25,750 --> 00:15:36,040
and mess around with it well I would

00:15:29,050 --> 00:15:37,420
hope not and numpy offers a lot of

00:15:36,040 --> 00:15:39,790
advantages the

00:15:37,420 --> 00:15:42,900
one is this thing at the bottom indexing

00:15:39,790 --> 00:15:46,450
objects have people use these before

00:15:42,900 --> 00:15:49,270
show of hands a few people okay yeah

00:15:46,450 --> 00:15:52,540
there it took me a while to discover

00:15:49,270 --> 00:15:55,150
this I'm a little ashamed of how long it

00:15:52,540 --> 00:15:57,340
took me to discover it but the idea is

00:15:55,150 --> 00:16:01,540
that you can use the Python slice

00:15:57,340 --> 00:16:05,560
intrinsic and create these things and

00:16:01,540 --> 00:16:07,600
then work with them directly and so if

00:16:05,560 --> 00:16:09,400
you look at that first example box there

00:16:07,600 --> 00:16:12,550
you can see the syntax for that's quite

00:16:09,400 --> 00:16:15,820
satisfying it's easy to build okay i

00:16:12,550 --> 00:16:20,170
need a tuple of these slices and off I

00:16:15,820 --> 00:16:22,780
go as opposed to brute force where you

00:16:20,170 --> 00:16:28,960
pick oh how many dimensions is it and so

00:16:22,780 --> 00:16:30,610
on okay now for that classic combination

00:16:28,960 --> 00:16:33,460
you may recall there were problems with

00:16:30,610 --> 00:16:34,930
finding parts of the scale space that

00:16:33,460 --> 00:16:38,830
meet conditions that they're in the

00:16:34,930 --> 00:16:42,880
classic combination again numpy really

00:16:38,830 --> 00:16:46,030
can rescue on this because and you know

00:16:42,880 --> 00:16:50,310
numpy dot where basically it's that

00:16:46,030 --> 00:16:50,310
simple play with things like that and

00:16:52,050 --> 00:16:56,860
another problem you run into is finding

00:16:55,270 --> 00:16:58,690
neighbors say you want to construct a

00:16:56,860 --> 00:17:01,780
finite different scheme or you want to

00:16:58,690 --> 00:17:04,180
do high dimensional interpolation now if

00:17:01,780 --> 00:17:07,000
you think about a high-dimensional

00:17:04,180 --> 00:17:09,070
analogue to what is called the

00:17:07,000 --> 00:17:12,670
five-point spent stencil in two

00:17:09,070 --> 00:17:17,950
dimensions which is yep north south east

00:17:12,670 --> 00:17:21,640
west again it's rather easy you can just

00:17:17,950 --> 00:17:25,570
use the numpy identity matrix and just

00:17:21,640 --> 00:17:27,940
pull rows off of it and kind of go plus

00:17:25,570 --> 00:17:31,360
or minus off of things to figure out how

00:17:27,940 --> 00:17:35,170
to index these things and and find

00:17:31,360 --> 00:17:37,870
neighbors now as far as something more

00:17:35,170 --> 00:17:41,860
complex if you talk about the compact

00:17:37,870 --> 00:17:45,010
stencil you need to look at using some

00:17:41,860 --> 00:17:47,110
toys like itertools and but literally I

00:17:45,010 --> 00:17:48,950
mean this little block of code here you

00:17:47,110 --> 00:17:51,680
can go do this

00:17:48,950 --> 00:18:01,790
in the number of dimensions supported

00:17:51,680 --> 00:18:05,390
and there you go and I think we're

00:18:01,790 --> 00:18:08,540
really near the end and I I've kind of

00:18:05,390 --> 00:18:10,220
revealed just a few tricks and I I don't

00:18:08,540 --> 00:18:11,960
know if these are new to many people or

00:18:10,220 --> 00:18:14,960
not they were new to me when i ran

00:18:11,960 --> 00:18:19,670
across them and I was quite happy to

00:18:14,960 --> 00:18:21,530
find them and quite relieved so this is

00:18:19,670 --> 00:18:23,360
all being incorporated in something

00:18:21,530 --> 00:18:28,610
called the Python grids and fields

00:18:23,360 --> 00:18:31,370
toolkit whose development well is them

00:18:28,610 --> 00:18:34,850
I'm the main guy writing the code day

00:18:31,370 --> 00:18:37,640
today and I have some help from people

00:18:34,850 --> 00:18:42,530
while one guy at fujitsu and a student

00:18:37,640 --> 00:18:44,720
at the ANU named Brendan Harding and at

00:18:42,530 --> 00:18:47,290
this point we're looking at releasing an

00:18:44,720 --> 00:18:51,710
early version of this late this year and

00:18:47,290 --> 00:18:55,430
this is part of an even bigger agenda of

00:18:51,710 --> 00:19:00,350
building a numerical analysis friendly

00:18:55,430 --> 00:19:03,530
MapReduce framework MapReduce most

00:19:00,350 --> 00:19:06,320
people know MapReduce is brilliant when

00:19:03,530 --> 00:19:08,450
you don't know structure a priori right

00:19:06,320 --> 00:19:11,180
because you just turn it into keys and

00:19:08,450 --> 00:19:15,110
values and if you've got a big global

00:19:11,180 --> 00:19:18,860
sort that's fast as blazes it comes

00:19:15,110 --> 00:19:20,330
right out well a lot of this kind of

00:19:18,860 --> 00:19:22,790
functional programming is very

00:19:20,330 --> 00:19:26,390
attractive for doing this stuff but we

00:19:22,790 --> 00:19:27,980
know the structure a priori so it's

00:19:26,390 --> 00:19:32,120
really about building something that

00:19:27,980 --> 00:19:35,060
will do that and that's pretty much the

00:19:32,120 --> 00:19:38,570
story all of this is under construction

00:19:35,060 --> 00:19:43,240
I hope to have a lot of it released in

00:19:38,570 --> 00:19:43,240
the new year and thank you for your time

00:19:43,780 --> 00:19:49,960
thank you very much

00:19:46,960 --> 00:19:49,960
thanks

00:19:55,630 --> 00:19:57,690

YouTube URL: https://www.youtube.com/watch?v=fSOMF2KG9Y4


