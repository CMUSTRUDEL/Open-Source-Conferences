Title: Multiplying really really big matrices by Paul Leopardi
Publication date: 2014-08-11
Playlist: PyCon Australia 2014 Science & Data miniconf
Description: 
	PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:05,870 --> 00:00:13,740
right so question um who here has used

00:00:10,410 --> 00:00:17,820
numpy or soap I either to multiply

00:00:13,740 --> 00:00:20,600
matrices Oh amazing it's about half the

00:00:17,820 --> 00:00:23,340
people here much more than I thought

00:00:20,600 --> 00:00:27,619
because my second question is who here

00:00:23,340 --> 00:00:27,619
has either seen or tasted a pineapple

00:00:28,070 --> 00:00:34,890
right so you are all in the right place

00:00:31,460 --> 00:00:37,350
that's not a pineapple that's a really

00:00:34,890 --> 00:00:39,989
really big thing it's a closest big

00:00:37,350 --> 00:00:42,059
thing I could think of oh well it

00:00:39,989 --> 00:00:45,180
certainly the closest big thing to hear

00:00:42,059 --> 00:00:49,350
that I can remember so that's why it's

00:00:45,180 --> 00:00:54,780
there because it's big and it's a

00:00:49,350 --> 00:00:59,219
pineapple ok so this um this talk is

00:00:54,780 --> 00:01:01,800
really about a particular application in

00:00:59,219 --> 00:01:05,460
bioinformatics it's an application in

00:01:01,800 --> 00:01:09,569
bioinformatics where you are comparing

00:01:05,460 --> 00:01:12,360
two biological sequences and for example

00:01:09,569 --> 00:01:16,679
i'm going to say their DNA sequences but

00:01:12,360 --> 00:01:19,380
you could actually compare proteins and

00:01:16,679 --> 00:01:22,289
use the same sort of mathematical

00:01:19,380 --> 00:01:25,140
structure but but the idea is that

00:01:22,289 --> 00:01:28,229
there's two ways of comparing biological

00:01:25,140 --> 00:01:30,470
sequences one is are what we heard about

00:01:28,229 --> 00:01:32,399
this morning which is by aligning the

00:01:30,470 --> 00:01:34,080
sequences splitting up each of the

00:01:32,399 --> 00:01:39,390
sequences of the bits and aligning them

00:01:34,080 --> 00:01:42,479
and another is by statistics there are a

00:01:39,390 --> 00:01:46,380
statistical comparison of two sequences

00:01:42,479 --> 00:01:49,470
using features of the sequences and so

00:01:46,380 --> 00:01:51,360
it's the second one that I'm going to

00:01:49,470 --> 00:01:55,170
talk about there is a particular

00:01:51,360 --> 00:01:59,700
statistic on pairs of sequences called

00:01:55,170 --> 00:02:01,440
d2 statistic and I should have mentioned

00:01:59,700 --> 00:02:05,489
from the previous slide this is our

00:02:01,440 --> 00:02:11,039
joint work with solvent for a and Conrad

00:02:05,489 --> 00:02:17,130
burden at at Anu and in fact it's stems

00:02:11,039 --> 00:02:18,400
from a an IRC grant which was also with

00:02:17,130 --> 00:02:21,879
sue Wilson

00:02:18,400 --> 00:02:24,310
having to do to do with analyzing the

00:02:21,879 --> 00:02:26,620
the properties of this do to statistic

00:02:24,310 --> 00:02:27,700
under certain assumptions which I won't

00:02:26,620 --> 00:02:30,909
go into here because they're not

00:02:27,700 --> 00:02:33,489
relevant to this talk but the main point

00:02:30,909 --> 00:02:38,590
from this slide sorry for too many words

00:02:33,489 --> 00:02:42,400
is that this d2 statistic is just the

00:02:38,590 --> 00:02:46,470
inner product of two vectors so it's

00:02:42,400 --> 00:02:46,470
just very simple from that point of view

00:02:48,810 --> 00:02:58,569
so why do I say that so I mean here we

00:02:53,200 --> 00:03:02,079
go we have two biological sequences a

00:02:58,569 --> 00:03:04,299
and B and so we're trying to define this

00:03:02,079 --> 00:03:08,019
thing called a d2 statistic all it is is

00:03:04,299 --> 00:03:10,480
you take a fixed word size and you move

00:03:08,019 --> 00:03:12,760
that word size along each of the two

00:03:10,480 --> 00:03:16,060
sequences and you get words of that link

00:03:12,760 --> 00:03:19,239
so here we have a word sites cave k 7

00:03:16,060 --> 00:03:22,269
you move that that little window of

00:03:19,239 --> 00:03:25,660
length 7 along along the sequence to get

00:03:22,269 --> 00:03:27,940
each of the words and what you do is you

00:03:25,660 --> 00:03:33,400
go say ok I've got this particular word

00:03:27,940 --> 00:03:35,500
say 80 g CTTT and what you want to do is

00:03:33,400 --> 00:03:39,069
count how many matches they are there

00:03:35,500 --> 00:03:42,250
are between the two sequences so in this

00:03:39,069 --> 00:03:45,099
particular case there are two matches

00:03:42,250 --> 00:03:46,959
the first one being from that the that

00:03:45,099 --> 00:03:51,669
word occurring on the left hand side of

00:03:46,959 --> 00:03:54,430
the a and the one instance on the B and

00:03:51,669 --> 00:03:57,510
the second match being this one over

00:03:54,430 --> 00:04:00,639
here where it's almost up to the end and

00:03:57,510 --> 00:04:02,769
matching the first be so we've got two

00:04:00,639 --> 00:04:07,239
matches for that word one match for the

00:04:02,769 --> 00:04:10,989
other AG see it's like an eye test isn't

00:04:07,239 --> 00:04:13,510
it um whatever that is so we've got a

00:04:10,989 --> 00:04:15,489
total of three matches so that's one way

00:04:13,510 --> 00:04:20,049
you can figure out what this d2

00:04:15,489 --> 00:04:24,340
statistic is which sounds very daft but

00:04:20,049 --> 00:04:26,860
in fact um if you think about it for a

00:04:24,340 --> 00:04:29,050
little while you can see what you're

00:04:26,860 --> 00:04:32,080
actually doing is you're creating

00:04:29,050 --> 00:04:35,139
histograms so each of the two

00:04:32,080 --> 00:04:37,659
sequences you go through and you count

00:04:35,139 --> 00:04:40,180
the number of occurrences of each of the

00:04:37,659 --> 00:04:41,379
possible words of that length and then

00:04:40,180 --> 00:04:42,819
you just take the inner product between

00:04:41,379 --> 00:04:50,979
the two and that'll give you the right

00:04:42,819 --> 00:04:52,569
number and really apologies for too much

00:04:50,979 --> 00:04:54,490
mathematics intimidate words but anyway

00:04:52,569 --> 00:04:58,389
what what I wanted to explain from this

00:04:54,490 --> 00:05:02,409
is that you have this this idea if you

00:04:58,389 --> 00:05:06,729
just you go through each pair over of

00:05:02,409 --> 00:05:10,000
sequences are and you create this count

00:05:06,729 --> 00:05:13,060
vector for each sequence and pairwise

00:05:10,000 --> 00:05:15,219
you just get into products so then you

00:05:13,060 --> 00:05:18,639
really have now a two step process and

00:05:15,219 --> 00:05:20,620
the two steps are first step is for each

00:05:18,639 --> 00:05:24,879
biological sequence that you start with

00:05:20,620 --> 00:05:27,419
you create account vector of the word

00:05:24,879 --> 00:05:30,520
counts for that particular fixed size

00:05:27,419 --> 00:05:33,219
corresponding to that sequence and then

00:05:30,520 --> 00:05:36,639
the second step is pairwise you do inner

00:05:33,219 --> 00:05:39,039
products so then you can think of our

00:05:36,639 --> 00:05:42,099
having a database with queries so your

00:05:39,039 --> 00:05:44,169
database contains the word count vectors

00:05:42,099 --> 00:05:46,930
corresponding to the biological

00:05:44,169 --> 00:05:49,930
sequences that you know about and your

00:05:46,930 --> 00:05:51,639
query has to do with the sequences you

00:05:49,930 --> 00:05:53,199
want to find out about and you just

00:05:51,639 --> 00:05:56,370
create the word count vectors for that

00:05:53,199 --> 00:05:59,469
and then what you wind up with is

00:05:56,370 --> 00:06:02,050
essentially as a sequence of inner

00:05:59,469 --> 00:06:03,729
products between the vectors you want to

00:06:02,050 --> 00:06:05,229
find out about and the vectors you

00:06:03,729 --> 00:06:11,349
already know or guess what that is it's

00:06:05,229 --> 00:06:14,919
a matrix multiplication but but it's a

00:06:11,349 --> 00:06:22,779
matrix multiplication where we have one

00:06:14,919 --> 00:06:24,099
particular problem and that's the one

00:06:22,779 --> 00:06:26,500
particular problem and the one

00:06:24,099 --> 00:06:28,599
particular fix so the matrix

00:06:26,500 --> 00:06:31,469
multiplication has a particular problem

00:06:28,599 --> 00:06:34,599
and the particular problem is that

00:06:31,469 --> 00:06:38,500
sometimes biologists are interested in

00:06:34,599 --> 00:06:41,770
large k and if K gets particularly large

00:06:38,500 --> 00:06:46,050
and you're dealing with DNA sequences

00:06:41,770 --> 00:06:49,129
for to the K gets very very large and

00:06:46,050 --> 00:06:52,169
if you have something that did that be

00:06:49,129 --> 00:06:54,509
then you don't want to have four vectors

00:06:52,169 --> 00:06:56,729
you want to have sparse ones and that

00:06:54,509 --> 00:07:01,759
means that your matrices will become

00:06:56,729 --> 00:07:04,770
sparse by but even so if you've got a

00:07:01,759 --> 00:07:10,139
database which is large enough you know

00:07:04,770 --> 00:07:13,349
you want to have for example a column

00:07:10,139 --> 00:07:17,129
for each of the sequences that you have

00:07:13,349 --> 00:07:18,659
converted into account vector well maybe

00:07:17,129 --> 00:07:20,250
the number of columns as millions maybe

00:07:18,659 --> 00:07:23,159
it's billions it depends on what it is

00:07:20,250 --> 00:07:27,300
your application is so it's quite

00:07:23,159 --> 00:07:30,960
possible that if you're using a ton of

00:07:27,300 --> 00:07:33,780
laptop like Oh what I've got that your

00:07:30,960 --> 00:07:36,300
database even if it's represented as a

00:07:33,780 --> 00:07:40,229
sparse matrix may not have fit into

00:07:36,300 --> 00:07:44,099
memory so that's the that's the issue

00:07:40,229 --> 00:07:47,190
and possibly should have split this into

00:07:44,099 --> 00:07:53,639
two slides that's the issue the slide is

00:07:47,190 --> 00:07:57,919
talking about the solution okay so who

00:07:53,639 --> 00:08:02,069
here has used sipos sparse matrices a

00:07:57,919 --> 00:08:07,110
few certainly less than know what a

00:08:02,069 --> 00:08:08,849
pineapple is so okay so this this idea

00:08:07,110 --> 00:08:10,440
of sparse matrices and sparse matrix

00:08:08,849 --> 00:08:13,879
multiplication a lot of that is actually

00:08:10,440 --> 00:08:16,139
built into scifi and there's some

00:08:13,879 --> 00:08:18,029
complications involved really building

00:08:16,139 --> 00:08:19,770
the sparse matrix figuring out well

00:08:18,029 --> 00:08:22,590
firstly figuring out what type of sparse

00:08:19,770 --> 00:08:24,300
matrix is more than one of them building

00:08:22,590 --> 00:08:25,979
them and then multiplying all

00:08:24,300 --> 00:08:27,719
multiplying I'm actually is fairly

00:08:25,979 --> 00:08:30,270
straightforward this building and pick

00:08:27,719 --> 00:08:35,190
up a guy out that's the hard part okay

00:08:30,270 --> 00:08:37,740
so who here has used numpy mem map very

00:08:35,190 --> 00:08:43,409
very small number of people how have you

00:08:37,740 --> 00:08:46,260
found the use of numba mmmm so it wasn't

00:08:43,409 --> 00:08:47,820
actually so just out of curiosity not

00:08:46,260 --> 00:08:51,750
actually an application and sort of the

00:08:47,820 --> 00:08:53,940
guy behind out of curiosity

00:08:51,750 --> 00:08:56,100
right so I'm definitely in the wrong

00:08:53,940 --> 00:09:00,240
room I should just sit down and shut up

00:08:56,100 --> 00:09:02,010
now um ok so the UM does the idea is you

00:09:00,240 --> 00:09:04,740
got something that's too big to fit in

00:09:02,010 --> 00:09:08,250
the memory well what can you do well one

00:09:04,740 --> 00:09:10,680
thing you can do for summer Rae that's

00:09:08,250 --> 00:09:13,260
too big and to fit into memory is to use

00:09:10,680 --> 00:09:16,050
a thing called a nun poem end map and

00:09:13,260 --> 00:09:18,810
the idea of that is that you hive off

00:09:16,050 --> 00:09:22,590
what's supposed to be in memory to disk

00:09:18,810 --> 00:09:26,090
somewhere and numpy magically does

00:09:22,590 --> 00:09:30,390
something that allows you to access it

00:09:26,090 --> 00:09:34,140
and luckily there's enough documentation

00:09:30,390 --> 00:09:36,630
in man map to be able to sort of make

00:09:34,140 --> 00:09:38,310
sense of that process I mean when you

00:09:36,630 --> 00:09:45,390
took a look at the documentation and map

00:09:38,310 --> 00:09:48,470
did any of it make any sense ok so what

00:09:45,390 --> 00:09:51,720
what I wound up doing in this particular

00:09:48,470 --> 00:09:54,990
application was a combination of the two

00:09:51,720 --> 00:09:57,780
things and that is to to split the

00:09:54,990 --> 00:09:59,670
matrix multiplication up into I've got

00:09:57,780 --> 00:10:03,000
this database it's got a lot of columns

00:09:59,670 --> 00:10:06,810
I'm going to split the database up into

00:10:03,000 --> 00:10:08,690
slices by colon and then the slices are

00:10:06,810 --> 00:10:12,150
the things that I'm actually going to be

00:10:08,690 --> 00:10:14,220
referencing via the numpy members and

00:10:12,150 --> 00:10:17,280
that's what the dot points are at the

00:10:14,220 --> 00:10:20,089
bottom have to do with is that there's

00:10:17,280 --> 00:10:23,580
some classes that I need to set up and

00:10:20,089 --> 00:10:26,900
two processes while two functions that I

00:10:23,580 --> 00:10:30,240
need to UM create one is the one that

00:10:26,900 --> 00:10:31,830
creates the mem maps and the other one

00:10:30,240 --> 00:10:34,589
is the one that uses them here maps do

00:10:31,830 --> 00:10:39,300
the multiplication so this is what this

00:10:34,589 --> 00:10:44,980
talk is about it's all about slices and

00:10:39,300 --> 00:10:48,020
mem maps and slices

00:10:44,980 --> 00:10:51,800
so those people who have fallen asleep

00:10:48,020 --> 00:10:53,750
so far that's that is a pineapple well

00:10:51,800 --> 00:11:01,150
that's what's left of a pineapple after

00:10:53,750 --> 00:11:01,150
you've sliced it a bit what's that sorry

00:11:01,900 --> 00:11:05,570
is this image is a worker the United

00:11:04,339 --> 00:11:07,400
States Department of Health and Human

00:11:05,570 --> 00:11:10,339
Services taken or made as part of that

00:11:07,400 --> 00:11:12,140
person's official duties as a work of

00:11:10,339 --> 00:11:13,880
the US federal government these images

00:11:12,140 --> 00:11:15,920
in the public domain of contributions

00:11:13,880 --> 00:11:22,940
for all of my images to make sure that

00:11:15,920 --> 00:11:30,650
I'm kosher as far as yes so first piece

00:11:22,940 --> 00:11:33,770
of code and right so code there's class

00:11:30,650 --> 00:11:37,100
that defines the end of a slice not so

00:11:33,770 --> 00:11:42,830
interesting there's a class that

00:11:37,100 --> 00:11:45,589
basically are defines what I mean by the

00:11:42,830 --> 00:11:47,990
men map that I meant maps three of them

00:11:45,589 --> 00:11:50,930
that I'm going to use for a sparse

00:11:47,990 --> 00:11:53,180
matrix so what happens is that when you

00:11:50,930 --> 00:11:55,790
when you assemble the sparse matrix um

00:11:53,180 --> 00:11:59,240
you need data to assemble into a sparse

00:11:55,790 --> 00:12:02,120
matrix and that data data is the data

00:11:59,240 --> 00:12:04,339
the rose and the column indices that go

00:12:02,120 --> 00:12:07,160
into building the sparse matrix well if

00:12:04,339 --> 00:12:09,020
the sparse matrix is ginormous then

00:12:07,160 --> 00:12:11,690
guess what all of them are going to be

00:12:09,020 --> 00:12:14,150
members so all of this class does is

00:12:11,690 --> 00:12:20,209
just encapsulates the information you

00:12:14,150 --> 00:12:22,730
need for our further mem maps and has a

00:12:20,209 --> 00:12:25,250
nice sort of wrap up at the end when you

00:12:22,730 --> 00:12:28,670
did a delete to get rid of the files and

00:12:25,250 --> 00:12:30,350
the directories you need so that's the

00:12:28,670 --> 00:12:32,360
thing you are you you're storing them

00:12:30,350 --> 00:12:36,080
maps and therefore arm you need to

00:12:32,360 --> 00:12:42,290
actually deal with the file structure on

00:12:36,080 --> 00:12:45,370
the machine ok first fairly whole

00:12:42,290 --> 00:12:45,370
horrible routine

00:12:45,970 --> 00:12:54,830
what you want to do is when you're

00:12:51,440 --> 00:12:59,630
building this um these men match you're

00:12:54,830 --> 00:13:03,140
taking one count vector at a time to

00:12:59,630 --> 00:13:09,320
build your database of biological

00:13:03,140 --> 00:13:14,600
sequences and watch our what you do is

00:13:09,320 --> 00:13:17,720
firstly set up here of this type of that

00:13:14,600 --> 00:13:19,580
should be siphoned with a with an H this

00:13:17,720 --> 00:13:21,680
is coded in siphoned by the way rather

00:13:19,580 --> 00:13:24,290
than Python this way we've got these

00:13:21,680 --> 00:13:26,210
cedar fence and some strange syntax

00:13:24,290 --> 00:13:29,089
there but most of the rest of the syntax

00:13:26,210 --> 00:13:33,520
is actually pythons syntaxin many of us

00:13:29,089 --> 00:13:37,310
the same but here's the guts you

00:13:33,520 --> 00:13:40,900
actually have to explicitly call

00:13:37,310 --> 00:13:45,380
something which sets up my maps and

00:13:40,900 --> 00:13:47,480
gives the file names and do has to deal

00:13:45,380 --> 00:13:49,339
with a whole bunch of junk basically but

00:13:47,480 --> 00:13:59,570
you do that yes you set up the mem maps

00:13:49,339 --> 00:14:04,670
um and then if scrolling thing he works

00:13:59,570 --> 00:14:09,760
yes good and then once you set it up the

00:14:04,670 --> 00:14:19,430
files for the mayor maps you have a nice

00:14:09,760 --> 00:14:21,520
loop which assembles it by slice what

00:14:19,430 --> 00:14:28,610
can get to the beginning of the loop

00:14:21,520 --> 00:14:35,560
yeah okay that's all we do we we

00:14:28,610 --> 00:14:35,560
assembled these men maps by slice so

00:14:36,160 --> 00:14:40,490
then do our less track the number of

00:14:38,180 --> 00:14:42,730
nonzero so the first thing is similar

00:14:40,490 --> 00:14:45,709
count vectors collins of a sparse matrix

00:14:42,730 --> 00:14:48,050
so the first thing is that this thing

00:14:45,709 --> 00:14:51,290
called jen date DNA frequency all that

00:14:48,050 --> 00:14:52,970
is is just get the next vector that i'm

00:14:51,290 --> 00:14:57,850
going to put into a column of my

00:14:52,970 --> 00:15:01,910
database then

00:14:57,850 --> 00:15:04,520
keep track of lists are tracked the

00:15:01,910 --> 00:15:06,410
number of non-zeros you have sparse

00:15:04,520 --> 00:15:07,970
matrices that's what you need to do is

00:15:06,410 --> 00:15:09,680
keep track of the number of nonzero is

00:15:07,970 --> 00:15:13,370
to make sure you know how big it is and

00:15:09,680 --> 00:15:15,589
also each of the these different data

00:15:13,370 --> 00:15:18,680
rows and calls are indexed by the number

00:15:15,589 --> 00:15:21,709
of non-zeros you keep track of the

00:15:18,680 --> 00:15:23,510
columns you keep track in this

00:15:21,709 --> 00:15:28,010
particular case they added structure

00:15:23,510 --> 00:15:32,120
I've got of these slices are and you

00:15:28,010 --> 00:15:36,110
append the data to onto the mem maps and

00:15:32,120 --> 00:15:39,920
and that's it when we reach the last

00:15:36,110 --> 00:15:42,380
slice we we append some information

00:15:39,920 --> 00:15:44,330
about where the end of the slices as we

00:15:42,380 --> 00:15:47,240
go through we keep track of where the

00:15:44,330 --> 00:15:50,959
ends of the slices are right at the end

00:15:47,240 --> 00:15:56,830
we we create a tuple that corresponds to

00:15:50,959 --> 00:16:01,550
our shape and then we do the usual call

00:15:56,830 --> 00:16:03,950
well no we don't not at this point at

00:16:01,550 --> 00:16:07,279
this point all we do is we create one of

00:16:03,950 --> 00:16:09,890
these men map classes which just takes

00:16:07,279 --> 00:16:12,589
our data that we've got so far which is

00:16:09,890 --> 00:16:17,089
our the date of the rows a call to shape

00:16:12,589 --> 00:16:20,320
and the ends list and that's it so all

00:16:17,089 --> 00:16:23,900
we've done so far has just taken the the

00:16:20,320 --> 00:16:28,040
each of the individual vectors and

00:16:23,900 --> 00:16:30,440
pulled them into our three men maps and

00:16:28,040 --> 00:16:37,360
that's the database part haven't got to

00:16:30,440 --> 00:16:37,360
the query pay yet sir

00:16:38,889 --> 00:16:50,259
is the query part our query part looks

00:16:46,679 --> 00:16:55,119
specifically and try saying that after

00:16:50,259 --> 00:16:59,199
lunch like um and I didn't have a beard

00:16:55,119 --> 00:17:00,910
by the way um it looks like a matrix

00:16:59,199 --> 00:17:03,519
multiplication well the first part does

00:17:00,910 --> 00:17:06,699
here there's a try except and in the

00:17:03,519 --> 00:17:08,740
first part of that to try all I'm doing

00:17:06,699 --> 00:17:10,929
is just a matrix multiplication and

00:17:08,740 --> 00:17:14,289
making making sure that I have a dense

00:17:10,929 --> 00:17:16,000
result because I'm assuming that the

00:17:14,289 --> 00:17:18,939
result can be dense in the result will

00:17:16,000 --> 00:17:21,279
fit in memory so that that part is easy

00:17:18,939 --> 00:17:23,470
so that means if my right hand side is

00:17:21,279 --> 00:17:27,459
just a matrix I have a matrix

00:17:23,470 --> 00:17:29,860
multiplication and I assume that if it

00:17:27,459 --> 00:17:32,590
doesn't work and it bombs out that if it

00:17:29,860 --> 00:17:35,860
bombs out because of a value error then

00:17:32,590 --> 00:17:41,950
it's because I have my new class that

00:17:35,860 --> 00:17:46,000
has this please not numpy mem maps at

00:17:41,950 --> 00:17:49,120
the back of it and all this rest of the

00:17:46,000 --> 00:17:52,210
routine setting up to medical variables

00:17:49,120 --> 00:17:54,760
etc etc is just the matrix

00:17:52,210 --> 00:18:00,639
multiplication and that matrix

00:17:54,760 --> 00:18:03,130
multiplication uses those slices so it

00:18:00,639 --> 00:18:06,070
says before my matrix multiplication by

00:18:03,130 --> 00:18:08,440
column slices of the right hand side so

00:18:06,070 --> 00:18:10,809
it just goes through that this list of

00:18:08,440 --> 00:18:16,149
slices which is the thing that I stored

00:18:10,809 --> 00:18:21,429
in the class and picks up the slices

00:18:16,149 --> 00:18:25,210
from the men map so you've got data rows

00:18:21,429 --> 00:18:27,580
calls it pulls out that particular part

00:18:25,210 --> 00:18:29,409
of the sliced having to do with the date

00:18:27,580 --> 00:18:32,260
of the Rosen that calls into those local

00:18:29,409 --> 00:18:36,190
variables and then figures out what the

00:18:32,260 --> 00:18:39,240
shape is and creates and I'll scroll

00:18:36,190 --> 00:18:39,240
that up so you can see it

00:18:43,179 --> 00:18:55,010
yeah and then creates sipos sparse

00:18:49,730 --> 00:18:59,630
matrix using this shape and just the CSR

00:18:55,010 --> 00:19:02,480
matrix call in sopo sparse so creates

00:18:59,630 --> 00:19:04,399
the sparse matrix so the sparse matrix

00:19:02,480 --> 00:19:08,570
is just the sparse matrix colors went

00:19:04,399 --> 00:19:10,880
into a slice and up a whole thing does

00:19:08,570 --> 00:19:12,950
the matrix multiplication your matrix

00:19:10,880 --> 00:19:16,130
multiplication is just for that slice

00:19:12,950 --> 00:19:20,570
and just goes around in a loop so the

00:19:16,130 --> 00:19:22,250
idea is to be able to do that with with

00:19:20,570 --> 00:19:24,740
a reasonable amount of memory on a

00:19:22,250 --> 00:19:30,380
single processor machine with a vast

00:19:24,740 --> 00:19:33,890
database and you may say well you know

00:19:30,380 --> 00:19:36,770
what's the point well there are our

00:19:33,890 --> 00:19:40,549
alternatives one alternative is dealt

00:19:36,770 --> 00:19:43,940
with mpi if you do it with mpi you need

00:19:40,549 --> 00:19:48,440
to have well for it to make sense you

00:19:43,940 --> 00:19:50,840
need to have a cluster that way you know

00:19:48,440 --> 00:19:52,669
you can use your cluster to a maximum

00:19:50,840 --> 00:19:57,559
advantage but if you've only got a

00:19:52,669 --> 00:20:02,720
laptop this is one way of doing that big

00:19:57,559 --> 00:20:06,350
matrix multiplication task a version of

00:20:02,720 --> 00:20:08,299
the code is up on github not this

00:20:06,350 --> 00:20:10,549
version of the code because I was just

00:20:08,299 --> 00:20:15,470
chomping on it at once time and I

00:20:10,549 --> 00:20:16,610
haven't put it up yet and yeah I'm not

00:20:15,470 --> 00:20:19,429
going to read out that blue at the

00:20:16,610 --> 00:20:24,470
bottom of basically that's a pineapple

00:20:19,429 --> 00:20:32,160
under construction and and that's it for

00:20:24,470 --> 00:20:45,580
the moment but if you go must fall

00:20:32,160 --> 00:20:48,190
we have any questions yes young too yeah

00:20:45,580 --> 00:20:50,140
um thank you i'm just a few questions

00:20:48,190 --> 00:20:52,360
firstly i'm assuming you're just doing

00:20:50,140 --> 00:20:54,220
came accounting have you got any

00:20:52,360 --> 00:20:55,450
comments about how fast your code is

00:20:54,220 --> 00:20:59,040
there's normally if i'm doing came

00:20:55,450 --> 00:21:01,600
accounting I want it to be fast um it is

00:20:59,040 --> 00:21:03,070
usually quick for the sword of

00:21:01,600 --> 00:21:05,770
prototyping work i'm currently doing

00:21:03,070 --> 00:21:08,320
have you compared this to two other came

00:21:05,770 --> 00:21:12,550
accounting libraries ah no I could no

00:21:08,320 --> 00:21:18,790
haven't I'm the aunt the the point is

00:21:12,550 --> 00:21:20,530
that is that I want to be able to do

00:21:18,790 --> 00:21:22,300
this particular in a product Xena

00:21:20,530 --> 00:21:25,780
product itself that matters and rather

00:21:22,300 --> 00:21:28,960
than the coke accounts the other thing

00:21:25,780 --> 00:21:30,970
is that i have seen at least some of

00:21:28,960 --> 00:21:34,690
some of the coma count libraries that

00:21:30,970 --> 00:21:37,090
are available via biopython and you know

00:21:34,690 --> 00:21:38,980
i can use them in fact i'm one of the

00:21:37,090 --> 00:21:41,110
things that i didn't show you is some of

00:21:38,980 --> 00:21:43,710
the rest of the code it pulls up pulls

00:21:41,110 --> 00:21:45,970
up biopython okay news is that

00:21:43,710 --> 00:21:48,640
especially for faster file reading if

00:21:45,970 --> 00:21:50,410
you know anything about that so the

00:21:48,640 --> 00:21:53,440
other question i'm assuming the memory

00:21:50,410 --> 00:21:56,190
is the big problem um have you looked at

00:21:53,440 --> 00:21:58,960
using like a bloom filter i'm assuming

00:21:56,190 --> 00:22:02,230
the bloom filter people normally use

00:21:58,960 --> 00:22:04,660
bloom filter algorithm to sort of get

00:22:02,230 --> 00:22:05,860
around this memory issue I don't know

00:22:04,660 --> 00:22:09,450
what that is i'll have to talk to you

00:22:05,860 --> 00:22:09,450
about okay cool thank you

00:22:13,130 --> 00:22:22,550
there's one other question oh yes um yes

00:22:18,230 --> 00:22:25,070
they're a strong reason why your class

00:22:22,550 --> 00:22:27,620
couldn't match the interface of scifi

00:22:25,070 --> 00:22:29,330
dot sports directly so that that would

00:22:27,620 --> 00:22:32,780
just work when you do a dot product

00:22:29,330 --> 00:22:34,550
using the site by dogs um only because I

00:22:32,780 --> 00:22:36,230
throw it together rather quickly and

00:22:34,550 --> 00:22:37,970
hadn't really thought very well about

00:22:36,230 --> 00:22:41,360
about what the interface should look

00:22:37,970 --> 00:22:43,310
like ok well sure there could be strong

00:22:41,360 --> 00:22:44,990
reasons why I didn't doesn't work but it

00:22:43,310 --> 00:22:46,850
maybe it would and that would be

00:22:44,990 --> 00:22:49,070
exciting but he had a bit mean it would

00:22:46,850 --> 00:22:52,040
be nice anyway if there was an extension

00:22:49,070 --> 00:22:56,030
to sparse matrices that that did all of

00:22:52,040 --> 00:22:59,540
this sort of did all of this sort of man

00:22:56,030 --> 00:23:01,340
map stuff in the background but I was

00:22:59,540 --> 00:23:03,170
just thinking that if there was then

00:23:01,340 --> 00:23:05,420
maybe it shouldn't be coated in Python

00:23:03,170 --> 00:23:11,330
or even in size and it should be you

00:23:05,420 --> 00:23:12,920
know back somewhere inside syfy yeah I

00:23:11,330 --> 00:23:14,240
was just wondering so you're saying that

00:23:12,920 --> 00:23:15,290
you can actually get reasonable

00:23:14,240 --> 00:23:17,120
performance about this and you can

00:23:15,290 --> 00:23:20,300
actually run that on your local machine

00:23:17,120 --> 00:23:23,000
yeah it runs on a laptop with you know

00:23:20,300 --> 00:23:26,720
with with you know reasonable size

00:23:23,000 --> 00:23:28,250
databases and I haven't done a lot of

00:23:26,720 --> 00:23:30,470
timing on it I've only put the code

00:23:28,250 --> 00:23:32,180
together quite recently sure fair enough

00:23:30,470 --> 00:23:33,350
so have you tried it on something like a

00:23:32,180 --> 00:23:38,050
larger machine does they get any

00:23:33,350 --> 00:23:40,760
appreciable performance increase ah I

00:23:38,050 --> 00:23:43,460
can't answer that question that I very

00:23:40,760 --> 00:23:45,770
well then I'm one point that i can make

00:23:43,460 --> 00:23:47,450
though is that if you have if you have a

00:23:45,770 --> 00:23:49,880
large enough machine you're probably

00:23:47,450 --> 00:23:52,940
better off trying to use trying to use

00:23:49,880 --> 00:23:56,030
MPI especially if you've got a cluster

00:23:52,940 --> 00:23:57,680
then that main the main thing the main

00:23:56,030 --> 00:24:00,140
problems you're trying to get rid of

00:23:57,680 --> 00:24:01,700
here is alleviated simply by the fact

00:24:00,140 --> 00:24:03,050
that you've got multiple machines that

00:24:01,700 --> 00:24:05,060
each would each of which has enough

00:24:03,050 --> 00:24:07,730
memory to be able to do the job so

00:24:05,060 --> 00:24:09,290
piling all those machines together means

00:24:07,730 --> 00:24:11,720
you can take the database and split it

00:24:09,290 --> 00:24:14,260
up across the machines and you know that

00:24:11,720 --> 00:24:16,970
that gets rid of the issue altogether I

00:24:14,260 --> 00:24:19,340
have a question too yeah and that's

00:24:16,970 --> 00:24:22,520
whether you'd be willing to contribute

00:24:19,340 --> 00:24:24,440
your coder to side pipes paths it might

00:24:22,520 --> 00:24:26,190
belong there quite it might fit their

00:24:24,440 --> 00:24:27,919
quite nicely I would

00:24:26,190 --> 00:24:30,750
I think it needs a lot of work done

00:24:27,919 --> 00:24:33,090
basically it needs to be as as as you

00:24:30,750 --> 00:24:35,549
suggested refactored to get the

00:24:33,090 --> 00:24:38,309
interface right but also there needs to

00:24:35,549 --> 00:24:41,009
be a bunch of a bunch of instrumentation

00:24:38,309 --> 00:24:42,509
done on timing and otherwise to make

00:24:41,009 --> 00:24:44,789
sure that it's actually working properly

00:24:42,509 --> 00:24:47,370
and one of the issues i had was really

00:24:44,789 --> 00:24:49,289
just seeing what the performance of men

00:24:47,370 --> 00:24:51,389
map actually is for this sort of task

00:24:49,289 --> 00:24:54,350
and maybe member wasn't written for this

00:24:51,389 --> 00:24:56,879
sort of this sort of an application so

00:24:54,350 --> 00:24:58,529
and I don't know enough about the guts

00:24:56,879 --> 00:25:01,710
of men map to be able to go in in

00:24:58,529 --> 00:25:03,330
history minute so I'm told me about it

00:25:01,710 --> 00:25:06,419
later and we'll try and figure out how

00:25:03,330 --> 00:25:09,019
how that could work terrific okay well

00:25:06,419 --> 00:25:09,019
thanks again

00:25:14,050 --> 00:25:16,110

YouTube URL: https://www.youtube.com/watch?v=DxWHXQ-G7cc


