Title: Testtools and Test Repository - the Python test frameworks OpenStack uses by Robert Collins
Publication date: 2013-07-12
Playlist: OpenStack Pycon AU 2013 (Miniconf)
Description: 
	PyCon Australia is the national conference for users of the Python Programming Language. In July 2013, we're returning to Hobart, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

July 5--7 2013, Hobart, Tasmania
Captions: 
	00:00:00,920 --> 00:00:08,910
testing right okay so I'm going to talk

00:00:05,640 --> 00:00:13,259
a bit about both test tools and test

00:00:08,910 --> 00:00:16,350
repository given i've only got half hour

00:00:13,259 --> 00:00:18,600
time slot and both topics can easily go

00:00:16,350 --> 00:00:20,070
to an hour or so to be an ldp drill own

00:00:18,600 --> 00:00:23,519
and talk about different things I

00:00:20,070 --> 00:00:25,980
thought I'd do something a bit more ad

00:00:23,519 --> 00:00:27,689
hoc and seed subside okay here's a quick

00:00:25,980 --> 00:00:30,359
overview really quick overview the two

00:00:27,689 --> 00:00:31,859
and then drilling based on audience

00:00:30,359 --> 00:00:37,230
interests so I've got a bunch of tabs

00:00:31,859 --> 00:00:39,719
here with various bits of content first

00:00:37,230 --> 00:00:43,200
off to just give them a bit of context

00:00:39,719 --> 00:00:44,940
the test tools is a Python testing

00:00:43,200 --> 00:00:48,719
library so it's kind of similar than

00:00:44,940 --> 00:00:52,410
those or unit test two it's been around

00:00:48,719 --> 00:00:55,710
for a while and it is the synthesis of

00:00:52,410 --> 00:00:58,079
the testing experiences that Jonny Lang

00:00:55,710 --> 00:01:00,410
and myself and a number of other people

00:00:58,079 --> 00:01:02,340
have had over time and it's got a

00:01:00,410 --> 00:01:04,379
semi-official goal of actually getting

00:01:02,340 --> 00:01:06,630
all of the stuff into upstream pythons

00:01:04,379 --> 00:01:10,920
unit tests but we have so far failed at

00:01:06,630 --> 00:01:13,470
doing this and I'm hoping to change that

00:01:10,920 --> 00:01:15,180
soon since I managed to get permission

00:01:13,470 --> 00:01:17,460
to spend some time on it from my manager

00:01:15,180 --> 00:01:18,330
and there's some interest in the Python

00:01:17,460 --> 00:01:21,540
community with some of the features

00:01:18,330 --> 00:01:23,939
we've got so that would be great but

00:01:21,540 --> 00:01:27,960
right now it's a Python testing library

00:01:23,939 --> 00:01:35,759
and documentation zat test tools read

00:01:27,960 --> 00:01:37,920
the docs dawggg the openstep projects

00:01:35,759 --> 00:01:39,960
until recently were largely using those

00:01:37,920 --> 00:01:42,810
and they have been migrating across on

00:01:39,960 --> 00:01:48,780
to test tools over the last hour i got i

00:01:42,810 --> 00:01:51,270
don't know year or so one of the big

00:01:48,780 --> 00:01:56,040
reasons for doing that is that test

00:01:51,270 --> 00:01:59,040
tools has some really good structures

00:01:56,040 --> 00:02:02,189
for writing tests at scale and OpenStack

00:01:59,040 --> 00:02:04,020
with I think what was the quote affair

00:02:02,189 --> 00:02:05,969
over a thousand active technical

00:02:04,020 --> 00:02:08,280
contributes as you owe me to asset tom

00:02:05,969 --> 00:02:09,670
is that act of technical contributors or

00:02:08,280 --> 00:02:12,160
just the total ever

00:02:09,670 --> 00:02:15,610
I don't know it's just a number i pulled

00:02:12,160 --> 00:02:18,730
off a website and the thousand

00:02:15,610 --> 00:02:20,980
developers i know if it is since the

00:02:18,730 --> 00:02:23,140
beginning of the project right so that's

00:02:20,980 --> 00:02:26,410
over a thousand committers ever and i

00:02:23,140 --> 00:02:28,989
believe at the end of the grizzly cycle

00:02:26,410 --> 00:02:31,090
there they had had 800 people commit in

00:02:28,989 --> 00:02:36,160
the last six months so the fairly large

00:02:31,090 --> 00:02:37,500
proportion are still active that all the

00:02:36,160 --> 00:02:40,269
problems you get with a large project

00:02:37,500 --> 00:02:42,610
how do you share information how do you

00:02:40,269 --> 00:02:44,650
keep the code agile and be able to build

00:02:42,610 --> 00:02:47,350
things start showing up in your test

00:02:44,650 --> 00:02:49,510
Suites in a very massive way and one of

00:02:47,350 --> 00:02:51,220
the key things test halls has is that

00:02:49,510 --> 00:02:53,380
it's aimed at that it's aimed at

00:02:51,220 --> 00:02:55,360
projects with tens of thousands of tests

00:02:53,380 --> 00:02:59,500
where the structure of your test matters

00:02:55,360 --> 00:03:02,049
as much or more than the structure of

00:02:59,500 --> 00:03:03,640
the rest of your code this test code

00:03:02,049 --> 00:03:05,200
tends to be larger than the code it's

00:03:03,640 --> 00:03:07,510
covering so you actually end up having

00:03:05,200 --> 00:03:08,799
more of a maintenance burden that if you

00:03:07,510 --> 00:03:13,630
you know just look at how much code

00:03:08,799 --> 00:03:20,079
you've got in different places the test

00:03:13,630 --> 00:03:23,829
repository is a test runner runner so it

00:03:20,079 --> 00:03:25,600
runs the tests that so it asks another

00:03:23,829 --> 00:03:27,730
test run to run your tests for you and

00:03:25,600 --> 00:03:29,590
that's interesting because it gives you

00:03:27,730 --> 00:03:31,450
the ability to run different runners for

00:03:29,590 --> 00:03:34,060
different purposes so for example

00:03:31,450 --> 00:03:36,190
tempest and OpenStack is a case we may

00:03:34,060 --> 00:03:38,200
end up writing a specific runner for the

00:03:36,190 --> 00:03:40,390
tempest tests but we can still have

00:03:38,200 --> 00:03:43,989
tests are at the front end saying hey

00:03:40,390 --> 00:03:46,810
please run these tests at lets you write

00:03:43,989 --> 00:03:49,060
your UI for selecting tests for talking

00:03:46,810 --> 00:03:50,950
about tests annotating them gathering

00:03:49,060 --> 00:03:53,769
performance data storing that data

00:03:50,950 --> 00:03:55,120
mining it once and then you can move

00:03:53,769 --> 00:03:56,230
test runs across to get different

00:03:55,120 --> 00:03:58,769
features or deal with different

00:03:56,230 --> 00:03:58,769
languages

00:04:02,110 --> 00:04:07,340
open sex being picking up test

00:04:04,430 --> 00:04:10,580
repository at pretty much the same rate

00:04:07,340 --> 00:04:12,170
as test tools and the CI team at open

00:04:10,580 --> 00:04:14,510
stack of ones that you said hey look

00:04:12,170 --> 00:04:16,970
would really like to switch on to test

00:04:14,510 --> 00:04:20,570
repository because they've got a massive

00:04:16,970 --> 00:04:23,060
testing problem I think it's over 700

00:04:20,570 --> 00:04:25,100
test runs a day they do across all of

00:04:23,060 --> 00:04:27,950
the projects and every one of those is

00:04:25,100 --> 00:04:29,150
essentially a devstack instance like you

00:04:27,950 --> 00:04:32,240
guys have been bringing up on your

00:04:29,150 --> 00:04:35,590
laptop's running the full test suite for

00:04:32,240 --> 00:04:37,670
a project or for all running tempest

00:04:35,590 --> 00:04:39,740
there's a huge amount of data they're

00:04:37,670 --> 00:04:41,630
huge amount of log files that need to be

00:04:39,740 --> 00:04:43,130
gathered and being able to

00:04:41,630 --> 00:04:45,740
programmatically talk about what's going

00:04:43,130 --> 00:04:48,380
on and have a highly reliable

00:04:45,740 --> 00:04:56,480
environment that is really it's a big

00:04:48,380 --> 00:04:58,490
deal the testing environment and

00:04:56,480 --> 00:05:01,760
OpenStack HD is front ended by thing

00:04:58,490 --> 00:05:06,410
called talks which came out of a pipe I

00:05:01,760 --> 00:05:08,990
project that back group of authors so

00:05:06,410 --> 00:05:11,510
talk sets up a virtual em for you and

00:05:08,990 --> 00:05:12,830
we'll install the necessary dependencies

00:05:11,510 --> 00:05:14,090
for your project into the virtual amp

00:05:12,830 --> 00:05:17,300
and then run your tests in the virtual

00:05:14,090 --> 00:05:19,280
in so this lets you run it on a host

00:05:17,300 --> 00:05:22,340
platform with a fairly large degree of

00:05:19,280 --> 00:05:24,440
Independence and because of that you

00:05:22,340 --> 00:05:26,360
don't actually see the fact using tests

00:05:24,440 --> 00:05:29,570
are most of the time you run toc stay

00:05:26,360 --> 00:05:31,550
cheap I 27 that's its upper virtually in

00:05:29,570 --> 00:05:33,320
person that runs tests our tests are

00:05:31,550 --> 00:05:35,210
thenns runs your actual test runner

00:05:33,320 --> 00:05:36,770
which is test tools and your tests run

00:05:35,210 --> 00:05:40,630
under that so there's a quite a big

00:05:36,770 --> 00:05:42,800
chain involved as well so that's the

00:05:40,630 --> 00:05:45,530
30-second overview that took I don't

00:05:42,800 --> 00:05:49,300
know five minutes which bits are of most

00:05:45,530 --> 00:05:49,300
interest to folk here just

00:05:50,540 --> 00:05:57,260
if it's not interesting i can go get the

00:05:52,790 --> 00:05:58,940
coffee all right well i'll talk about

00:05:57,260 --> 00:06:01,780
the bit that I've got the most slides

00:05:58,940 --> 00:06:01,780
for then how about that

00:06:08,400 --> 00:06:18,030
White's white pages I love them oh yeah

00:06:12,240 --> 00:06:20,449
right okay su only switch back this is

00:06:18,030 --> 00:06:22,949
this works better for me so because

00:06:20,449 --> 00:06:27,300
frankly I've forgotten the speaker notes

00:06:22,949 --> 00:06:29,729
for this right so Tess repository is a

00:06:27,300 --> 00:06:31,919
pipe I project it's Python it builds

00:06:29,729 --> 00:06:35,610
something called subunit and as I said

00:06:31,919 --> 00:06:36,870
before it runs tests runners so I ended

00:06:35,610 --> 00:06:42,560
up doing this woman's work on the

00:06:36,870 --> 00:06:44,820
bizarre project so bizarre I'd know in

00:06:42,560 --> 00:06:46,530
2006 or something it was getting to the

00:06:44,820 --> 00:06:49,169
point where it was just too slow to run

00:06:46,530 --> 00:06:51,000
the tests they were taking 15 or 20

00:06:49,169 --> 00:06:53,820
minutes and that's way too long to be

00:06:51,000 --> 00:06:55,289
waiting for a test run if you're editing

00:06:53,820 --> 00:06:57,060
a line of code and you want to make sure

00:06:55,289 --> 00:06:59,669
it works that needs to be a very fast

00:06:57,060 --> 00:07:01,770
cycle if you can run just one test

00:06:59,669 --> 00:07:03,479
that's tolerable but then you still have

00:07:01,770 --> 00:07:04,830
to do this big run before you can be

00:07:03,479 --> 00:07:08,610
sure everything works and you can commit

00:07:04,830 --> 00:07:10,620
it into track and latency slows down

00:07:08,610 --> 00:07:14,070
velocity it's it's a you know the

00:07:10,620 --> 00:07:17,220
relationships pretty well understood so

00:07:14,070 --> 00:07:19,380
I I started writing paralyzation for

00:07:17,220 --> 00:07:22,169
that and parallelization and python is

00:07:19,380 --> 00:07:25,080
non-trivial you've got multiprocessing

00:07:22,169 --> 00:07:27,150
which is kind of slow you've got

00:07:25,080 --> 00:07:29,340
threading which is very slow because

00:07:27,150 --> 00:07:32,300
python has a global interpreter lock and

00:07:29,340 --> 00:07:35,490
doesn't actually free free 3d anything

00:07:32,300 --> 00:07:37,050
if you don't use multiprocessing and you

00:07:35,490 --> 00:07:39,270
fall off different threads then you've

00:07:37,050 --> 00:07:41,130
got to manage the complexity of forking

00:07:39,270 --> 00:07:43,310
separate processes gathering the mouth

00:07:41,130 --> 00:07:46,289
afterwards making sure each of the ram

00:07:43,310 --> 00:07:48,780
so i wrote an implementation that did

00:07:46,289 --> 00:07:50,370
that I realized how this isn't going to

00:07:48,780 --> 00:07:55,889
be very reusable at stuck in the middle

00:07:50,370 --> 00:07:58,229
of bees at our there's a separate

00:07:55,889 --> 00:07:59,930
project I had sitting around called

00:07:58,229 --> 00:08:03,360
subunit which is a serialization

00:07:59,930 --> 00:08:05,159
protocol for test activity so if you

00:08:03,360 --> 00:08:08,220
look think about something like Jane who

00:08:05,159 --> 00:08:11,159
here is not familiar with j unit not the

00:08:08,220 --> 00:08:12,690
testing library but the xml file the

00:08:11,159 --> 00:08:16,380
identity of a file that records your

00:08:12,690 --> 00:08:18,199
test results all right so two people you

00:08:16,380 --> 00:08:21,299
can deal

00:08:18,199 --> 00:08:23,039
it's a it's an XML file that says these

00:08:21,299 --> 00:08:24,449
are tests they took this long to run

00:08:23,039 --> 00:08:27,149
here are the test names and here's the

00:08:24,449 --> 00:08:29,099
outcomes but Edd's xml you have to read

00:08:27,149 --> 00:08:30,569
the whole file there's no defined order

00:08:29,099 --> 00:08:33,930
in XML you can't just read a little bit

00:08:30,569 --> 00:08:35,279
you can't stream it if you try and use

00:08:33,930 --> 00:08:37,469
that to communicate between two

00:08:35,279 --> 00:08:39,029
processes as tests are running it's a

00:08:37,469 --> 00:08:42,089
horrible disaster it just doesn't work

00:08:39,029 --> 00:08:44,490
well and it could be interrupted it

00:08:42,089 --> 00:08:47,009
won't be valid XML if someone's test

00:08:44,490 --> 00:08:50,209
kills off the the test process and you

00:08:47,009 --> 00:08:52,649
never actually see the end of it so

00:08:50,209 --> 00:08:55,350
subunit said hey let's since you have a

00:08:52,649 --> 00:08:56,819
streaming protocol that has these other

00:08:55,350 --> 00:08:58,290
properties and you can convert that to

00:08:56,819 --> 00:08:59,939
xml to hand it off to something like

00:08:58,290 --> 00:09:03,600
Jenkins and say yeah I had a test run

00:08:59,939 --> 00:09:05,389
here's some XML that describes it so to

00:09:03,600 --> 00:09:08,040
make beads that are paralyzed I took

00:09:05,389 --> 00:09:09,959
subunit and I use that between a child

00:09:08,040 --> 00:09:11,279
and parent process and the parent just

00:09:09,959 --> 00:09:13,439
said I'm going to run these tests and

00:09:11,279 --> 00:09:15,990
the children went around them and that

00:09:13,439 --> 00:09:17,790
worked really really well BTW does tests

00:09:15,990 --> 00:09:20,399
grew until it took about 45 minutes to

00:09:17,790 --> 00:09:22,529
an hour to run and I could paralyze them

00:09:20,399 --> 00:09:25,079
all on 22 instance and run them in 30

00:09:22,529 --> 00:09:29,579
seconds so I was like yeah that that

00:09:25,079 --> 00:09:31,290
works and I ended up running multiple

00:09:29,579 --> 00:09:34,920
ec2 instances when I need them even more

00:09:31,290 --> 00:09:38,790
grunt so paralyzation wonderful but

00:09:34,920 --> 00:09:41,129
still not reusable so tests are took all

00:09:38,790 --> 00:09:43,379
of the logic about scheduling and said

00:09:41,129 --> 00:09:45,300
look as long as I can enumerate the

00:09:43,379 --> 00:09:46,860
tests I can then schedule them and you

00:09:45,300 --> 00:09:48,180
subunits communicate about them and it

00:09:46,860 --> 00:09:51,569
will all just hang together really

00:09:48,180 --> 00:09:54,779
really nicely and so it does and that's

00:09:51,569 --> 00:09:56,759
what I've just been talking about other

00:09:54,779 --> 00:09:58,889
key bits of Sabean I didn't Lynch is

00:09:56,759 --> 00:10:00,600
that it's got a well-defined grammar so

00:09:58,889 --> 00:10:02,689
it's a feature of it that you should be

00:10:00,600 --> 00:10:06,329
a limp lamented easily for any language

00:10:02,689 --> 00:10:08,279
it's a binary protocol which means that

00:10:06,329 --> 00:10:09,930
it's got its own check sums on each

00:10:08,279 --> 00:10:12,209
packet it can tell if it's being

00:10:09,930 --> 00:10:15,889
corrupted it's not subject to human

00:10:12,209 --> 00:10:17,459
editing and getting things wrong and it

00:10:15,889 --> 00:10:20,129
understands they're all used to be

00:10:17,459 --> 00:10:22,139
running on the same output pipe as the

00:10:20,129 --> 00:10:23,910
UTS runner so if other stuff turns up as

00:10:22,139 --> 00:10:26,100
long as it isn't intermix within a

00:10:23,910 --> 00:10:27,860
single packet everything will be okay

00:10:26,100 --> 00:10:33,279
and

00:10:27,860 --> 00:10:36,800
didn't practice it works well tests are

00:10:33,279 --> 00:10:38,600
better tests are so tests are is needs

00:10:36,800 --> 00:10:40,880
to know how to run your tests run your

00:10:38,600 --> 00:10:44,260
test runner has to output subunit but

00:10:40,880 --> 00:10:48,050
how do you run so this config file says

00:10:44,260 --> 00:10:50,329
to run tests run python dash IAM subunit

00:10:48,050 --> 00:10:53,600
run subunits that the pythons Oviatt

00:10:50,329 --> 00:10:55,310
library and discover dot dollar sign

00:10:53,600 --> 00:10:56,899
this top dollar so nerdy option and the

00:10:55,310 --> 00:11:00,589
next two lines say how to build those

00:10:56,899 --> 00:11:03,950
variables and the subunit run module is

00:11:00,589 --> 00:11:07,490
just a front end to test tools so it

00:11:03,950 --> 00:11:09,649
wraps the test tools test execution with

00:11:07,490 --> 00:11:11,329
a subunit reporter so that what would

00:11:09,649 --> 00:11:17,060
normally say this test starts and the

00:11:11,329 --> 00:11:19,339
stairs finish becomes subunit events you

00:11:17,060 --> 00:11:22,130
can put a whole bunch of stuff in here

00:11:19,339 --> 00:11:24,709
you can filter out some tag tests so one

00:11:22,130 --> 00:11:26,360
thing like this test run that does and

00:11:24,709 --> 00:11:28,190
widget which is another test run that

00:11:26,360 --> 00:11:29,839
speaks subunit but zoeb has this concept

00:11:28,190 --> 00:11:30,500
called layers and the idea of a layer is

00:11:29,839 --> 00:11:32,990
that you have something that's very

00:11:30,500 --> 00:11:34,579
expensive to set up like a database so

00:11:32,990 --> 00:11:38,750
all your tests that need it will declare

00:11:34,579 --> 00:11:40,699
I use this layer and when you run it it

00:11:38,750 --> 00:11:42,470
tells you I'm sitting up the layer and

00:11:40,699 --> 00:11:44,149
the layer is now set up but it's not

00:11:42,470 --> 00:11:46,279
actually a test it's not something that

00:11:44,149 --> 00:11:50,810
you want to see when you say what tests

00:11:46,279 --> 00:11:53,209
ran you filter it out so those tests get

00:11:50,810 --> 00:11:57,199
tagged but the synthetic tests in get

00:11:53,209 --> 00:11:59,269
tagged and you can filter them out you

00:11:57,199 --> 00:12:01,160
can control the concurrency and the

00:11:59,269 --> 00:12:02,570
instance provision executing disposed

00:12:01,160 --> 00:12:04,459
but it's a really kind of interesting in

00:12:02,570 --> 00:12:07,699
a cloud environment because they let you

00:12:04,459 --> 00:12:11,000
tell test I how to start up a new

00:12:07,699 --> 00:12:12,949
virtual machine or a new Alex sea

00:12:11,000 --> 00:12:15,170
container or whatever I mean you put

00:12:12,949 --> 00:12:16,970
your own scripts in there and it will

00:12:15,170 --> 00:12:19,220
call them when it wants to run tests

00:12:16,970 --> 00:12:21,380
it'll say hey I'm going to be running 50

00:12:19,220 --> 00:12:23,720
different tests runners in parallel

00:12:21,380 --> 00:12:26,089
please give me a handle for each of them

00:12:23,720 --> 00:12:28,790
so that I can execute some commands on

00:12:26,089 --> 00:12:31,790
them and away you go and this that you

00:12:28,790 --> 00:12:34,490
orchestrate significant and cross

00:12:31,790 --> 00:12:35,600
machine parallelism without those sit

00:12:34,490 --> 00:12:37,040
there it assumes everything is going

00:12:35,600 --> 00:12:38,870
around the local machine so the default

00:12:37,040 --> 00:12:41,230
is just to run it right right here in

00:12:38,870 --> 00:12:41,230
front of you

00:12:43,710 --> 00:12:49,930
so test our needs the runner to allow to

00:12:47,490 --> 00:12:52,480
enumerate the tests which subunit the

00:12:49,930 --> 00:12:54,970
run all takes care of and it needs to be

00:12:52,480 --> 00:12:56,980
able to ask for some specific tests to

00:12:54,970 --> 00:12:58,540
be executed which it does were passing

00:12:56,980 --> 00:13:03,430
in a file that lists the test studies

00:12:58,540 --> 00:13:05,560
one per line to deal with things like

00:13:03,430 --> 00:13:07,930
temp as well I'm looking at extending

00:13:05,560 --> 00:13:09,580
this to allow it to be sort of a much

00:13:07,930 --> 00:13:12,340
richer description so you can say these

00:13:09,580 --> 00:13:13,810
tests need to be run together if you run

00:13:12,340 --> 00:13:16,750
this one you must always run that one

00:13:13,810 --> 00:13:18,190
that sort of thing which most projects

00:13:16,750 --> 00:13:24,730
don't need but the projects that do need

00:13:18,190 --> 00:13:26,230
it really really need it this is just a

00:13:24,730 --> 00:13:31,180
quick example of what it looks like to

00:13:26,230 --> 00:13:33,400
run nova tests using tests are so you

00:13:31,180 --> 00:13:35,350
can see here first of all it does a list

00:13:33,400 --> 00:13:38,730
find out the tests there are two run and

00:13:35,350 --> 00:13:41,680
then it runs multiple copies of the

00:13:38,730 --> 00:13:43,540
subunit actual test runner and each

00:13:41,680 --> 00:13:46,300
temporary file there is just listing a

00:13:43,540 --> 00:13:47,830
petition of the tests one of the things

00:13:46,300 --> 00:13:49,780
tests are does that's really quite nice

00:13:47,830 --> 00:13:51,940
as it looks at how long that took to run

00:13:49,780 --> 00:13:53,620
and it groups the test so that each

00:13:51,940 --> 00:13:56,050
partition is roughly the same amount of

00:13:53,620 --> 00:13:58,060
time so if you've got two or three

00:13:56,050 --> 00:14:00,640
really slow tests they won't all end up

00:13:58,060 --> 00:14:02,350
in the same test runner because if that

00:14:00,640 --> 00:14:03,970
happens it's bad right you end up with

00:14:02,350 --> 00:14:05,320
one runner that takes thirty or forty

00:14:03,970 --> 00:14:06,940
percent longer than the other runners to

00:14:05,320 --> 00:14:08,410
run what you want to do is have all the

00:14:06,940 --> 00:14:10,860
runners were really really hard and then

00:14:08,410 --> 00:14:14,260
stop pretty much at the same time and

00:14:10,860 --> 00:14:16,450
turns out most hits a pretty consistent

00:14:14,260 --> 00:14:18,010
by how long they take to run so you can

00:14:16,450 --> 00:14:19,360
get pretty consistent results by just

00:14:18,010 --> 00:14:25,330
recording how long they took to run last

00:14:19,360 --> 00:14:29,950
time and go and folder that this is an

00:14:25,330 --> 00:14:31,690
example of listing the tests so it goes

00:14:29,950 --> 00:14:34,660
you run it it comes back with a full

00:14:31,690 --> 00:14:36,760
Python test ID for each test note the

00:14:34,660 --> 00:14:39,900
tests are doesn't care about the this

00:14:36,760 --> 00:14:41,890
format you can return a you know a hex

00:14:39,900 --> 00:14:44,110
description or you'd or whatever you

00:14:41,890 --> 00:14:46,240
want it doesn't care it just passes it

00:14:44,110 --> 00:14:48,620
back through to the user

00:14:46,240 --> 00:14:49,820
but the bits that are nice and the bits

00:14:48,620 --> 00:14:51,529
that are really relevant to folk are

00:14:49,820 --> 00:14:54,380
working with openstack is what will get

00:14:51,529 --> 00:14:56,150
into now you can ask tests are what

00:14:54,380 --> 00:14:59,600
failed the last time you ran your tests

00:14:56,150 --> 00:15:01,520
now the Nova tests take a good long time

00:14:59,600 --> 00:15:02,990
to run if we go back up here you can see

00:15:01,520 --> 00:15:06,890
that even with significant

00:15:02,990 --> 00:15:08,480
parallelization that's five minutes kind

00:15:06,890 --> 00:15:09,980
of slow so I've been able to say hey

00:15:08,480 --> 00:15:12,470
what failing tests are there what tests

00:15:09,980 --> 00:15:14,330
if I get to fix up it is really really

00:15:12,470 --> 00:15:16,730
useful so failing desh desh list will

00:15:14,330 --> 00:15:19,040
list the failing tests if you just run

00:15:16,730 --> 00:15:22,370
tests are failing it will show the

00:15:19,040 --> 00:15:24,050
actual output of the fail tests so it's

00:15:22,370 --> 00:15:25,580
all captured there in the database you

00:15:24,050 --> 00:15:28,550
can you can query it and look at it at

00:15:25,580 --> 00:15:30,950
your at your leisure and you can also

00:15:28,550 --> 00:15:33,380
run those tests you can say please run

00:15:30,950 --> 00:15:35,029
just the failing tests for me and it

00:15:33,380 --> 00:15:37,190
will query its database see what tests

00:15:35,029 --> 00:15:43,790
are failing and pass that through to the

00:15:37,190 --> 00:15:48,220
run plumbing for you now I mentioned

00:15:43,790 --> 00:15:48,220
tests before sorry crisco

00:15:53,610 --> 00:15:58,540
not directly because what you probably

00:15:57,190 --> 00:16:00,310
want to do if you're going to do that is

00:15:58,540 --> 00:16:01,930
you want so so Chris asks is there some

00:16:00,310 --> 00:16:04,360
way to ask you to run the failing test

00:16:01,930 --> 00:16:06,000
and also the tests that were ran with

00:16:04,360 --> 00:16:09,120
them that led up to the failure

00:16:06,000 --> 00:16:11,290
presumably you want to do to reproduce

00:16:09,120 --> 00:16:13,000
issues right so there's actually

00:16:11,290 --> 00:16:15,010
dedicated command and test out which

00:16:13,000 --> 00:16:17,770
i'll come back to cool analyze isolation

00:16:15,010 --> 00:16:19,839
which does exactly that it runs the

00:16:17,770 --> 00:16:21,580
failing scenario with all of those tests

00:16:19,839 --> 00:16:23,230
in the same partition so it doesn't mix

00:16:21,580 --> 00:16:27,250
it up across different runners different

00:16:23,230 --> 00:16:30,040
run instances and it bisects to see

00:16:27,250 --> 00:16:32,560
which ones cause the failure so I think

00:16:30,040 --> 00:16:35,020
that's pretty much everything here's

00:16:32,560 --> 00:16:36,490
your cake and the icing and and so it's

00:16:35,020 --> 00:16:38,830
still what kind of caveats I'll come

00:16:36,490 --> 00:16:41,470
back to that but tied into that right

00:16:38,830 --> 00:16:43,870
what is a test it really needs to be

00:16:41,470 --> 00:16:45,760
independent it's not it's not a test if

00:16:43,870 --> 00:16:48,520
it depends on some other thing running

00:16:45,760 --> 00:16:51,220
first not in the sort of unit tests

00:16:48,520 --> 00:16:53,589
definition of a test so it needs to be a

00:16:51,220 --> 00:16:56,709
single item Akkad that you can run with

00:16:53,589 --> 00:16:58,720
no cross dependencies and when the test

00:16:56,709 --> 00:17:02,170
runs it starts and stops and does some

00:16:58,720 --> 00:17:04,270
stuff in the middle and you need to be

00:17:02,170 --> 00:17:07,120
able to list them if you can't enumerate

00:17:04,270 --> 00:17:08,980
it you can't identify that it needs to

00:17:07,120 --> 00:17:11,860
be scheduled somewhere and executed and

00:17:08,980 --> 00:17:21,610
if you can't do that then test our will

00:17:11,860 --> 00:17:23,290
never run it okay so how do you handle

00:17:21,610 --> 00:17:25,329
the situation when your test and modify

00:17:23,290 --> 00:17:27,010
some global state well you need

00:17:25,329 --> 00:17:28,420
something in your test environment to

00:17:27,010 --> 00:17:30,340
make sure that you reset it to a known

00:17:28,420 --> 00:17:32,440
good either at the beginning of the test

00:17:30,340 --> 00:17:35,200
setup your environment so that you're

00:17:32,440 --> 00:17:36,550
ready for your test to run or after the

00:17:35,200 --> 00:17:39,460
test put it back to the way it should be

00:17:36,550 --> 00:17:40,750
and if you don't have that then there

00:17:39,460 --> 00:17:43,420
are lots and lots of the resorts of

00:17:40,750 --> 00:17:45,340
photos that aren't going to bite you but

00:17:43,420 --> 00:17:47,230
the basic test is there as a developer

00:17:45,340 --> 00:17:48,550
you should be able to just without tests

00:17:47,230 --> 00:17:51,010
are in the picture just using your

00:17:48,550 --> 00:17:53,590
normal test runner directly run just

00:17:51,010 --> 00:17:55,600
that one test and be confident that it's

00:17:53,590 --> 00:17:59,679
going to work otherwise how can you edit

00:17:55,600 --> 00:18:02,890
the test tempest doesn't have this

00:17:59,679 --> 00:18:04,010
property today this makes tempest are

00:18:02,890 --> 00:18:05,750
very hard for

00:18:04,010 --> 00:18:08,870
able to work on it's something I'm

00:18:05,750 --> 00:18:12,590
hoping to get some time to hack on but I

00:18:08,870 --> 00:18:14,930
haven't you so I mentioned data mining

00:18:12,590 --> 00:18:18,620
before and testings reactions you can

00:18:14,930 --> 00:18:20,930
have two sorts of interactions you can

00:18:18,620 --> 00:18:24,680
have processed global process wide state

00:18:20,930 --> 00:18:26,210
but interacts between tests so here's an

00:18:24,680 --> 00:18:30,190
example if you have a test that mocks

00:18:26,210 --> 00:18:33,020
out the built-ins modules open attribute

00:18:30,190 --> 00:18:35,240
this is a great way to really screw up

00:18:33,020 --> 00:18:36,740
the next test because if you don't put

00:18:35,240 --> 00:18:38,810
that open back the way it should be

00:18:36,740 --> 00:18:42,620
pretty much nothing that those i/o is

00:18:38,810 --> 00:18:44,090
going to work including by the way the

00:18:42,620 --> 00:18:45,380
reporting functions within your test

00:18:44,090 --> 00:18:49,250
runner that might need to report an

00:18:45,380 --> 00:18:50,690
error so mocking out open is not the

00:18:49,250 --> 00:18:53,390
smartest thing you can do in terms of

00:18:50,690 --> 00:18:54,590
structuring a test but there's nothing

00:18:53,390 --> 00:18:56,540
that will ever do that will cause

00:18:54,590 --> 00:18:58,580
another separate test runner instance to

00:18:56,540 --> 00:19:00,440
fail it's completely isolated because

00:18:58,580 --> 00:19:02,390
it's within that one process so the

00:19:00,440 --> 00:19:04,700
other form of isolation you can have in

00:19:02,390 --> 00:19:06,500
terms of modifying global stages when

00:19:04,700 --> 00:19:08,660
you're modifying a database on disk a

00:19:06,500 --> 00:19:10,550
postgresql thing may be talking to an

00:19:08,660 --> 00:19:11,930
API server if you've actually got some

00:19:10,550 --> 00:19:14,030
external state that you're modifying

00:19:11,930 --> 00:19:19,310
that's a lovely way you can cause

00:19:14,030 --> 00:19:21,770
interactions so same worker in different

00:19:19,310 --> 00:19:23,630
worker now the other thing you can have

00:19:21,770 --> 00:19:26,240
is that you might have things that only

00:19:23,630 --> 00:19:27,770
caused the issue while they're executing

00:19:26,240 --> 00:19:29,300
so you can have things a cause an issue

00:19:27,770 --> 00:19:30,890
and when the if you try and do something

00:19:29,300 --> 00:19:33,920
else while that thing is executing so

00:19:30,890 --> 00:19:36,080
cross worker maybe you listen on a

00:19:33,920 --> 00:19:38,570
well-known port you open port 9000 you

00:19:36,080 --> 00:19:39,680
and you call listen and two different

00:19:38,570 --> 00:19:42,820
tests Roger at the same time they're

00:19:39,680 --> 00:19:47,840
going to fail but do we know evidence

00:19:42,820 --> 00:19:50,630
that one test did it in a minute down

00:19:47,840 --> 00:19:52,250
the the the test run right it's only a

00:19:50,630 --> 00:19:55,610
problem while that test is actually

00:19:52,250 --> 00:19:56,990
active versus for example if you delete

00:19:55,610 --> 00:19:58,790
the database file other tests are

00:19:56,990 --> 00:20:00,260
looking for we're all be visible

00:19:58,790 --> 00:20:03,290
throughout the end of the test run so

00:20:00,260 --> 00:20:04,670
the analysis you need to do to separate

00:20:03,290 --> 00:20:08,570
out which tests are in check in which

00:20:04,670 --> 00:20:12,460
ways is complex now I haven't encoded

00:20:08,570 --> 00:20:15,230
all of it as code yet but what I do have

00:20:12,460 --> 00:20:17,390
I think it's coming up now

00:20:15,230 --> 00:20:20,059
okay more data mining slowest tests

00:20:17,390 --> 00:20:21,799
right so this is again we've got the

00:20:20,059 --> 00:20:24,200
timing for all of the tests we can

00:20:21,799 --> 00:20:28,610
report on any individual tests very

00:20:24,200 --> 00:20:32,740
easily so this command is kind of my

00:20:28,610 --> 00:20:35,990
favorite bling in tests are and this

00:20:32,740 --> 00:20:38,360
takes the current list of failures it

00:20:35,990 --> 00:20:40,730
runs all of them on their own with no

00:20:38,360 --> 00:20:43,280
parallelization so it will just run this

00:20:40,730 --> 00:20:45,530
failure new tech completely new test

00:20:43,280 --> 00:20:48,799
from the process this failure etc if any

00:20:45,530 --> 00:20:50,929
of those fail then they fail on their

00:20:48,799 --> 00:20:54,200
own isolations are relevant they're just

00:20:50,929 --> 00:20:57,530
completely broken if any of them pass

00:20:54,200 --> 00:20:58,850
then the only reason they failed was a

00:20:57,530 --> 00:21:00,470
sporadic failure which could be an

00:20:58,850 --> 00:21:02,540
internal timing failure in the test or

00:21:00,470 --> 00:21:04,640
it could be isolation so the next thing

00:21:02,540 --> 00:21:05,750
it does then runs that test and all of

00:21:04,640 --> 00:21:11,350
the tests that were run in the same

00:21:05,750 --> 00:21:15,110
worker process up to it if it passes

00:21:11,350 --> 00:21:17,210
then it's not sure what's going on it

00:21:15,110 --> 00:21:20,929
could be that means it's probably either

00:21:17,210 --> 00:21:22,910
an in that test issue so timing within

00:21:20,929 --> 00:21:24,710
the test or something or it's a cross

00:21:22,910 --> 00:21:26,480
test runner interaction and although

00:21:24,710 --> 00:21:28,640
we've got the data to report on that I

00:21:26,480 --> 00:21:30,890
haven't written any Kota to deal with it

00:21:28,640 --> 00:21:32,720
but if you assume it fails a limb by sea

00:21:30,890 --> 00:21:35,510
and run half the tests that led up to it

00:21:32,720 --> 00:21:37,010
and find okay that succeeds then try the

00:21:35,510 --> 00:21:38,809
other half and you know just keep

00:21:37,010 --> 00:21:40,160
working down until you say okay if you

00:21:38,809 --> 00:21:41,960
run this test and then this test this

00:21:40,160 --> 00:21:44,570
test fails if you run this test on its

00:21:41,960 --> 00:21:49,010
own it passes so right there that's you

00:21:44,570 --> 00:21:51,350
know a suspicious combination yet

00:21:49,010 --> 00:21:53,330
described by bart right right I really

00:21:51,350 --> 00:21:54,530
need to decide what style of slides I'm

00:21:53,330 --> 00:21:57,710
doing the one where I go through really

00:21:54,530 --> 00:22:00,590
quickly although I respect to it so yeah

00:21:57,710 --> 00:22:03,890
I really love that that's as a data

00:22:00,590 --> 00:22:05,600
point but how useful this was when Nova

00:22:03,890 --> 00:22:07,160
brought in tests are they didn't have

00:22:05,600 --> 00:22:09,260
any paralyzation at the time so their

00:22:07,160 --> 00:22:12,250
test runs were getting quite slow Jim

00:22:09,260 --> 00:22:12,250
how long a beginning Chris

00:22:14,450 --> 00:22:17,110
I'm saying though

00:22:19,059 --> 00:22:30,100
no without parallel yeah so there's five

00:22:27,999 --> 00:22:32,379
minutes with eight cause i think it was

00:22:30,100 --> 00:22:35,830
so i want to say i was getting up

00:22:32,379 --> 00:22:41,019
towards half an hour I've I think test

00:22:35,830 --> 00:22:42,580
our sport you but whether it's 15 or

00:22:41,019 --> 00:22:47,679
half an hour it's still much longer than

00:22:42,580 --> 00:22:50,289
you really want so what happens when you

00:22:47,679 --> 00:22:52,269
don't have things been tested as they

00:22:50,289 --> 00:22:55,179
break so as soon as they tried to bring

00:22:52,269 --> 00:22:56,559
in paralyzation everything broken stars

00:22:55,179 --> 00:22:59,019
broken that's terrible this was really

00:22:56,559 --> 00:23:01,330
really hard and I said like hey I'm hang

00:22:59,019 --> 00:23:04,409
on all of these failures are failures

00:23:01,330 --> 00:23:07,840
due to tests that are not actually

00:23:04,409 --> 00:23:12,070
cleaning up properly after themselves so

00:23:07,840 --> 00:23:13,869
the analyzed isolation stuff was at that

00:23:12,070 --> 00:23:15,639
point I've been doing it by hand but it

00:23:13,869 --> 00:23:17,740
was in my head as I can't let me turn it

00:23:15,639 --> 00:23:20,259
into an actual tool for you and it saved

00:23:17,740 --> 00:23:22,029
them for guys so much time just tracking

00:23:20,259 --> 00:23:23,230
it around because I just run it until

00:23:22,029 --> 00:23:25,149
the head of failure then throw it

00:23:23,230 --> 00:23:27,220
through to the NIS isolation to get the

00:23:25,149 --> 00:23:29,110
output and instead of having to go

00:23:27,220 --> 00:23:30,789
brothel in through code trying to cross

00:23:29,110 --> 00:23:32,490
reference they could say what this test

00:23:30,789 --> 00:23:36,159
does and what this test does these

00:23:32,490 --> 00:23:37,659
interact badly other caveats it doesn't

00:23:36,159 --> 00:23:39,519
handle three-way combinations if you

00:23:37,659 --> 00:23:41,499
need to run these two tests and then

00:23:39,519 --> 00:23:43,749
this one will fail it can't detect that

00:23:41,499 --> 00:23:45,639
at the moment my hunch is that that's

00:23:43,749 --> 00:23:47,409
like under five percent of isolation

00:23:45,639 --> 00:23:52,110
errors and I'm not sure about return on

00:23:47,409 --> 00:23:52,110
investment time but question at the back

00:23:58,649 --> 00:24:05,669
I get to

00:24:12,710 --> 00:24:29,400
yep so the question is you know if you

00:24:27,900 --> 00:24:30,690
randomized everything every run even

00:24:29,400 --> 00:24:32,640
though you weren't parallel would it

00:24:30,690 --> 00:24:34,440
avoid that sort of oh my god I've hit

00:24:32,640 --> 00:24:36,510
the wall when you do start trying to

00:24:34,440 --> 00:24:39,630
paralyze and I think it would quite a

00:24:36,510 --> 00:24:42,000
significant degree help because you

00:24:39,630 --> 00:24:43,860
would I guess in principle you'd have a

00:24:42,000 --> 00:24:45,179
fifty percent chance that the bad test

00:24:43,860 --> 00:24:47,790
is before after you in any particular

00:24:45,179 --> 00:24:49,980
run however there's a couple of problems

00:24:47,790 --> 00:24:51,660
with it one is that unless you make sure

00:24:49,980 --> 00:24:53,610
your plumbing is really robust it's hard

00:24:51,660 --> 00:24:55,440
to reproduce the exact same order which

00:24:53,610 --> 00:24:57,390
means it's hard to debug what went wrong

00:24:55,440 --> 00:24:58,770
when it failed and that can be

00:24:57,390 --> 00:25:00,120
frustrating for developers who actually

00:24:58,770 --> 00:25:03,660
want to get a feature done rather than

00:25:00,120 --> 00:25:04,830
work on plumbing and arguably its tests

00:25:03,660 --> 00:25:07,470
that were broken not plumbing in the

00:25:04,830 --> 00:25:10,919
first place but that's not always going

00:25:07,470 --> 00:25:13,350
to fly well the sea the second problem

00:25:10,919 --> 00:25:15,000
is that if you want to look at

00:25:13,350 --> 00:25:17,040
optimizing performance then these are

00:25:15,000 --> 00:25:19,470
limited set of optimizations you can do

00:25:17,040 --> 00:25:21,900
consider the layers example in soap test

00:25:19,470 --> 00:25:23,700
run or I gave before you can't randomize

00:25:21,900 --> 00:25:25,590
things outside of the layer without

00:25:23,700 --> 00:25:27,059
incurring the cost of a teardown and

00:25:25,590 --> 00:25:28,440
bring back up of that layer and the

00:25:27,059 --> 00:25:30,660
whole point of layers as they represent

00:25:28,440 --> 00:25:34,980
expensive things like selenium test run

00:25:30,660 --> 00:25:37,470
or databases or whatever so that's

00:25:34,980 --> 00:25:38,760
interacting factor and I've got a kind

00:25:37,470 --> 00:25:40,440
of similar things his resources that

00:25:38,760 --> 00:25:43,410
also is aimed at the sense of

00:25:40,440 --> 00:25:45,150
optimizations so I think it's kind of a

00:25:43,410 --> 00:25:46,260
crutch I think it's a great thing to

00:25:45,150 --> 00:25:47,669
have when you have it but it's not

00:25:46,260 --> 00:25:49,410
something I ever want to depend on I

00:25:47,669 --> 00:25:51,480
will note that once you have

00:25:49,410 --> 00:25:53,820
paralyzation which is very easy like

00:25:51,480 --> 00:25:56,160
it's a four line config file and use

00:25:53,820 --> 00:25:59,250
test our and you get paralyzation right

00:25:56,160 --> 00:26:01,410
from the get-go that gives you permit

00:25:59,250 --> 00:26:03,540
ation on every single run but it also

00:26:01,410 --> 00:26:06,320
captures exactly what ran and it gives

00:26:03,540 --> 00:26:06,320
you tools to debugger

00:26:08,550 --> 00:26:18,280
I talked about the aid of a PR before

00:26:14,160 --> 00:26:20,260
all right this is this is about down to

00:26:18,280 --> 00:26:21,970
spit up virtual machines or containers

00:26:20,260 --> 00:26:24,190
whatever to run your tests on so

00:26:21,970 --> 00:26:26,800
basically how many of them do you need

00:26:24,190 --> 00:26:28,450
create them use them get rid of them and

00:26:26,800 --> 00:26:30,880
in the future I'd like to have a tool

00:26:28,450 --> 00:26:33,100
that encapsulates that and holds up five

00:26:30,880 --> 00:26:38,470
minutes to go cards so that you can tell

00:26:33,100 --> 00:26:42,700
how long it is going to take to run one

00:26:38,470 --> 00:26:44,920
of the things that don't say that please

00:26:42,700 --> 00:26:47,350
don't say that and so one of the things

00:26:44,920 --> 00:26:49,540
that we don't do yet and test repository

00:26:47,350 --> 00:26:51,400
is online scheduling so at the moment we

00:26:49,540 --> 00:26:53,470
calculate what the petitions are going

00:26:51,400 --> 00:26:54,730
to be what tests will run where based on

00:26:53,470 --> 00:26:56,710
the static data we have from the

00:26:54,730 --> 00:26:58,270
previous run and what I think would be

00:26:56,710 --> 00:27:03,970
really really cool is being able to

00:26:58,270 --> 00:27:06,580
dynamically so if we knew we had say 20

00:27:03,970 --> 00:27:08,830
machines that could run tests and we've

00:27:06,580 --> 00:27:10,150
got a whole bunch of tests and we think

00:27:08,830 --> 00:27:12,370
we know which ones are fast and which

00:27:10,150 --> 00:27:14,050
ones are slow if we could schedule I

00:27:12,370 --> 00:27:16,270
don't know in minutes with the test run

00:27:14,050 --> 00:27:17,650
on each machine so it takes a second or

00:27:16,270 --> 00:27:20,050
so to get the test runner up and running

00:27:17,650 --> 00:27:22,200
right so there's a that's maybe a half a

00:27:20,050 --> 00:27:25,420
percent or a percent overhead in

00:27:22,200 --> 00:27:27,220
triggering that run but then if one

00:27:25,420 --> 00:27:29,860
machine finishes a lot earlier than the

00:27:27,220 --> 00:27:31,450
others we can give us some work and when

00:27:29,860 --> 00:27:33,370
unpredictable things like one machine

00:27:31,450 --> 00:27:35,470
has SSDs and the other machine has real

00:27:33,370 --> 00:27:37,540
hard disks can influence to your own

00:27:35,470 --> 00:27:39,600
behavior that rather than having to

00:27:37,540 --> 00:27:41,650
encode that in and get make the

00:27:39,600 --> 00:27:44,320
scheduling algorithm much more complex

00:27:41,650 --> 00:27:45,700
we can just make it react better when

00:27:44,320 --> 00:27:47,620
that sort of factor is in the

00:27:45,700 --> 00:27:50,500
environment and I think there would be

00:27:47,620 --> 00:27:52,179
nice free from a user perspective I've

00:27:50,500 --> 00:27:55,870
got some plumbing I need to do to do

00:27:52,179 --> 00:27:58,510
that I'd like to enhance the analyze

00:27:55,870 --> 00:28:01,120
isolation stuff to deal with concurrent

00:27:58,510 --> 00:28:04,000
run workers that actually trigger across

00:28:01,120 --> 00:28:06,910
worker problems I'd like to deal with

00:28:04,000 --> 00:28:08,620
three variable interactions I'd also

00:28:06,910 --> 00:28:11,230
like to deal with positive interaction

00:28:08,620 --> 00:28:14,410
so one of the ones that isn't assessed

00:28:11,230 --> 00:28:17,050
well today is when tests and tests be if

00:28:14,410 --> 00:28:18,850
you run tests be on its own it fails so

00:28:17,050 --> 00:28:20,530
analyze isolation will say this is a

00:28:18,850 --> 00:28:22,930
genuine failure but

00:28:20,530 --> 00:28:25,300
be will only actually pass if you also

00:28:22,930 --> 00:28:27,850
run a before it so it's the inverse of

00:28:25,300 --> 00:28:31,180
the one that's probes for that would be

00:28:27,850 --> 00:28:32,650
lovely to handle and I'd love to sort of

00:28:31,180 --> 00:28:36,060
write a little query language to talk

00:28:32,650 --> 00:28:38,140
about here's the database describe the

00:28:36,060 --> 00:28:40,930
data you want to get out of it and go

00:28:38,140 --> 00:28:42,580
and get it I mean there's some basic

00:28:40,930 --> 00:28:44,290
stuff you can do today like grip will

00:28:42,580 --> 00:28:46,240
quite happily bring back all the tests

00:28:44,290 --> 00:28:47,620
that had this particular exception but

00:28:46,240 --> 00:28:50,290
it'll be lovely to describe that and

00:28:47,620 --> 00:28:52,420
sort of as a MapReduce kind of API

00:28:50,290 --> 00:28:57,880
because I say map produced because we

00:28:52,420 --> 00:28:59,860
are gathering thousands of test runs in

00:28:57,880 --> 00:29:01,660
subunit format per week in the open

00:28:59,860 --> 00:29:03,250
state project so we actually have a big

00:29:01,660 --> 00:29:04,990
data problem we should be able to get

00:29:03,250 --> 00:29:06,580
some fascinating information about what

00:29:04,990 --> 00:29:08,170
tests are flaky and how often they fail

00:29:06,580 --> 00:29:10,090
and what context they fail and that

00:29:08,170 --> 00:29:11,800
people have moment got all something

00:29:10,090 --> 00:29:15,340
went wrong and Tempest but if we

00:29:11,800 --> 00:29:17,530
capturing subunit data for it like let's

00:29:15,340 --> 00:29:19,210
su make use of them and I'll my turn to

00:29:17,530 --> 00:29:20,290
make an HTTP repository so the rather

00:29:19,210 --> 00:29:22,570
than just capturing everything locally

00:29:20,290 --> 00:29:24,640
you could say I'm working on OpenStack

00:29:22,570 --> 00:29:26,500
I'm doing a public you know it's a

00:29:24,640 --> 00:29:28,990
public patch it's not for my proprietary

00:29:26,500 --> 00:29:31,060
whatever extension I can just feed the

00:29:28,990 --> 00:29:33,040
data from our test front straight up to

00:29:31,060 --> 00:29:37,030
the OpenStack foundation of information

00:29:33,040 --> 00:29:39,160
about how long the taking okay also the

00:29:37,030 --> 00:29:40,630
way they're failing so other people who

00:29:39,160 --> 00:29:42,280
see the same failure if it's what if

00:29:40,630 --> 00:29:44,110
it's not the code you're working on by

00:29:42,280 --> 00:29:45,790
the library dependency on that

00:29:44,110 --> 00:29:48,310
particular version of ubuntu suddenly

00:29:45,790 --> 00:29:52,030
you can start surfacing that sort of

00:29:48,310 --> 00:29:55,030
stuff five minutes five minutes five

00:29:52,030 --> 00:29:57,970
minutes what else have we got I've got

00:29:55,030 --> 00:30:03,190
an etherpad so what does extra tests at

00:29:57,970 --> 00:30:07,570
the bottom mean I someone wrote extra

00:30:03,190 --> 00:30:10,510
tests at the very bottom of this I don't

00:30:07,570 --> 00:30:12,130
know what it means I wanted I saw that

00:30:10,510 --> 00:30:14,310
before I was like I wonder what that

00:30:12,130 --> 00:30:14,310
means

00:30:24,270 --> 00:30:29,640
every time you're on staff that ice age

00:30:32,210 --> 00:30:36,510
there is an offline option to it you can

00:30:34,890 --> 00:30:38,340
I fact I remember if you put that in

00:30:36,510 --> 00:30:44,730
your local RC or whether you pass it to

00:30:38,340 --> 00:30:50,370
the command line in your local I see ya

00:30:44,730 --> 00:30:52,170
so put that in the etherpad so yeah that

00:30:50,370 --> 00:30:53,400
that will make it a lot faster and avoid

00:30:52,170 --> 00:30:56,070
bandwidth and so on but it should

00:30:53,400 --> 00:30:57,240
already have all of the dependencies and

00:30:56,070 --> 00:31:03,810
so on the stores I shouldn't need to

00:30:57,240 --> 00:31:05,430
download anything all right then there's

00:31:03,810 --> 00:31:08,190
something wacky there that's not mean

00:31:05,430 --> 00:31:11,150
Devon it's been to check and find it's

00:31:08,190 --> 00:31:13,650
up to date and then have nothing to do

00:31:11,150 --> 00:31:17,840
yeah so you probably all want to see it

00:31:13,650 --> 00:31:17,840
offline equals true in your local I see

00:31:30,119 --> 00:31:36,179
I'm the next speaker though so yes yes

00:31:32,939 --> 00:31:37,769
so the next presentation getting started

00:31:36,179 --> 00:31:39,809
with OpenStack development was

00:31:37,769 --> 00:31:41,609
originally going to be taken by our good

00:31:39,809 --> 00:31:44,879
friend from Campbell all right Michael

00:31:41,609 --> 00:31:47,719
still and yes you can you can see is

00:31:44,879 --> 00:31:47,719

YouTube URL: https://www.youtube.com/watch?v=Oe_HhBBbqbw


