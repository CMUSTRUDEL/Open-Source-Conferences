Title: A sack full of angry snakes: Taming your python dependencies with Nix
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Thomas Woolford

https://2020.pycon.org.au/program/USWEYZ

Scientists, Researchers and Software Engineering projects should be paying attention to the reproducibility of their results. The best way to guarantee that the project you build today will be the same when built next week is to exactly specify your dependency tree. 

Imperative package management approaches (such as apt/pip/conda) provide few assurances that the package version you get today is the same version you'll get tomorrow, or that installing packages in a different order won't change the versions resolved. The problem gets even harder when you want to integrate with native extensions that rely on platform libraries and the ephemeral contents of /usr/share/. 

In this talk I'll discuss how Nix package manager can provide a complete dependency management solution for python projects on Linux and Mac. Nix can install and track exact, reproducible versions of python packages and their transitive dependencies including platform libraries, down to the compiler version that created them. No more guessing why your teammate can trigger a bug that you can't reproduce.

Nix can use this dependency info to quickly get new teammates up and running with a full development environment, no worries about the setup instructions being out of date or incompatible with their chosen OS flavor. Finally, Nix can build your project in a sealed build environment that prevents your project sneakily including files that haven't been declared as dependencies. You can then confidently deploy these builds as minimal docker images, VM images, or directly via nix package caches.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Fri Sep  4 13:20:00 2020 at Obvious
Captions: 
	00:00:01,920 --> 00:00:05,839
hi everyone and welcome back i hope you

00:00:03,919 --> 00:00:07,839
had a like really nice break

00:00:05,839 --> 00:00:09,679
up next we have thomas telling all

00:00:07,839 --> 00:00:10,480
telling us all about managing python

00:00:09,679 --> 00:00:13,200
packages

00:00:10,480 --> 00:00:14,639
with nyx i'm really excited to like

00:00:13,200 --> 00:00:15,200
learn more about nyx i've heard of it

00:00:14,639 --> 00:00:16,720
but

00:00:15,200 --> 00:00:18,720
that's about as best as we've gotten so

00:00:16,720 --> 00:00:20,560
far uh thomas

00:00:18,720 --> 00:00:22,320
is a lapsed web developer turned

00:00:20,560 --> 00:00:23,279
contractor working in software-defined

00:00:22,320 --> 00:00:25,119
radar

00:00:23,279 --> 00:00:26,640
like radio waves radar that sounds cool

00:00:25,119 --> 00:00:28,960
radio race right now

00:00:26,640 --> 00:00:30,000
nice uh an advocate of functional

00:00:28,960 --> 00:00:32,880
functional software

00:00:30,000 --> 00:00:34,480
design and a lover of curly boys he's

00:00:32,880 --> 00:00:37,200
perpetually chasing

00:00:34,480 --> 00:00:37,760
he's perpetually chasing the next yak to

00:00:37,200 --> 00:00:39,440
shave

00:00:37,760 --> 00:00:41,680
dragging along all who will listen and

00:00:39,440 --> 00:00:43,200
having a blast learning new things

00:00:41,680 --> 00:00:45,039
uh and thomas has let us know that he's

00:00:43,200 --> 00:00:46,399
happy to take questions so if we please

00:00:45,039 --> 00:00:48,719
feel free to ask them in the chat

00:00:46,399 --> 00:00:49,920
and i'll collate them and we'll try to

00:00:48,719 --> 00:00:53,760
have time to get to them

00:00:49,920 --> 00:00:53,760
thank you so much take it away thomas

00:00:53,840 --> 00:00:58,399
hi everyone i'm thomas um in another

00:00:56,879 --> 00:00:59,280
life i used to be a web developer and

00:00:58,399 --> 00:01:01,359
now i work in

00:00:59,280 --> 00:01:02,320
software-defined radar in the defense

00:01:01,359 --> 00:01:05,519
space

00:01:02,320 --> 00:01:07,040
um i am talking about

00:01:05,519 --> 00:01:08,720
taming your python dependencies with

00:01:07,040 --> 00:01:12,320
nics

00:01:08,720 --> 00:01:12,880
so talking about packaging it's nobody's

00:01:12,320 --> 00:01:15,360
favorite

00:01:12,880 --> 00:01:16,159
content it's nobody's favorite topic

00:01:15,360 --> 00:01:18,080
conversation

00:01:16,159 --> 00:01:19,520
it's kind of like doing the dishes after

00:01:18,080 --> 00:01:20,479
you've had a big meal like it's got to

00:01:19,520 --> 00:01:22,960
be done

00:01:20,479 --> 00:01:24,640
but you want to spend as little time on

00:01:22,960 --> 00:01:26,960
it as you can

00:01:24,640 --> 00:01:28,080
my first brush with pi uh packaging was

00:01:26,960 --> 00:01:30,240
as i just started

00:01:28,080 --> 00:01:31,200
university this is my my very first

00:01:30,240 --> 00:01:34,320
laptop

00:01:31,200 --> 00:01:35,920
and i had met a group of fantastic

00:01:34,320 --> 00:01:38,000
people at the comp side club

00:01:35,920 --> 00:01:40,000
at university and they taught me about

00:01:38,000 --> 00:01:43,439
this awesome thing called python

00:01:40,000 --> 00:01:44,560
and getting into python uh i learnt

00:01:43,439 --> 00:01:47,119
about django which

00:01:44,560 --> 00:01:48,159
still it changed my life it sort of

00:01:47,119 --> 00:01:51,840
defined the first

00:01:48,159 --> 00:01:53,439
five years of my career at least um

00:01:51,840 --> 00:01:55,680
one of the things that we tried to do at

00:01:53,439 --> 00:01:57,520
the time was to

00:01:55,680 --> 00:01:59,119
build a land management system you know

00:01:57,520 --> 00:01:59,840
a forum for people who love going to

00:01:59,119 --> 00:02:01,840
lands

00:01:59,840 --> 00:02:04,000
and as part of that we needed to install

00:02:01,840 --> 00:02:05,200
uh the python imaging library to handle

00:02:04,000 --> 00:02:07,280
all the pictures that we wanted people

00:02:05,200 --> 00:02:09,520
to be able to upload

00:02:07,280 --> 00:02:10,479
but at the time there wasn't really a

00:02:09,520 --> 00:02:13,840
good way

00:02:10,479 --> 00:02:14,959
for people on uh windows specifically xp

00:02:13,840 --> 00:02:18,080
for me at the time

00:02:14,959 --> 00:02:20,560
uh to get uh native dependencies

00:02:18,080 --> 00:02:21,120
like uh pill installed it needed a whole

00:02:20,560 --> 00:02:24,319
bunch of c

00:02:21,120 --> 00:02:26,959
stuff um but the package at the time

00:02:24,319 --> 00:02:28,160
it it wanted to compile it on your

00:02:26,959 --> 00:02:28,959
computer and i just couldn't get it

00:02:28,160 --> 00:02:30,560
working

00:02:28,959 --> 00:02:32,000
uh eventually i found the awesome people

00:02:30,560 --> 00:02:35,200
at pythonware who

00:02:32,000 --> 00:02:37,440
provided these fantastic installers um

00:02:35,200 --> 00:02:39,040
and and i was able to get these things

00:02:37,440 --> 00:02:40,319
installed but it was just a lot harder

00:02:39,040 --> 00:02:41,200
than it needed to be and i ended up

00:02:40,319 --> 00:02:43,440
carting around

00:02:41,200 --> 00:02:45,280
like a whole bunch of installer

00:02:43,440 --> 00:02:47,440
executables for quite a while

00:02:45,280 --> 00:02:50,319
just in case i needed to be able to

00:02:47,440 --> 00:02:52,400
install it again

00:02:50,319 --> 00:02:53,599
so how do python packages actually get

00:02:52,400 --> 00:02:56,879
installed

00:02:53,599 --> 00:02:59,120
like uh still today

00:02:56,879 --> 00:03:00,319
um as true as it was then most of them

00:02:59,120 --> 00:03:03,360
get installed into

00:03:00,319 --> 00:03:06,000
site packages if you're lucky

00:03:03,360 --> 00:03:07,200
uh and you're on a unix like thing uh

00:03:06,000 --> 00:03:07,840
that can be installed by a package

00:03:07,200 --> 00:03:09,920
manager

00:03:07,840 --> 00:03:11,599
if you're not um you end up just

00:03:09,920 --> 00:03:12,319
installing them out of executables like

00:03:11,599 --> 00:03:14,800
i did

00:03:12,319 --> 00:03:15,440
or uh running you know set up the pi

00:03:14,800 --> 00:03:19,120
install

00:03:15,440 --> 00:03:21,680
on a zip file that you download um

00:03:19,120 --> 00:03:23,200
if you needed to run analytics machine

00:03:21,680 --> 00:03:25,280
which i didn't have access to at the

00:03:23,200 --> 00:03:28,400
time you needed route to install

00:03:25,280 --> 00:03:31,200
and no one was no one was really going

00:03:28,400 --> 00:03:34,319
to give me root at that time

00:03:31,200 --> 00:03:35,040
easy install sort of made that easier it

00:03:34,319 --> 00:03:37,200
uh

00:03:35,040 --> 00:03:39,360
it allowed people to get stuff from

00:03:37,200 --> 00:03:42,480
piper directly from the command line

00:03:39,360 --> 00:03:43,760
and this allowed me to get a lot of

00:03:42,480 --> 00:03:46,000
stuff installed in the day it was

00:03:43,760 --> 00:03:48,000
fantastic it was made a lot better by

00:03:46,000 --> 00:03:49,760
pip pip actually knew how to install

00:03:48,000 --> 00:03:52,159
multiple things at once

00:03:49,760 --> 00:03:54,080
and introduced requirements files which

00:03:52,159 --> 00:03:56,480
uh made it made it easier to install

00:03:54,080 --> 00:03:57,120
everything like in a big group so that

00:03:56,480 --> 00:03:59,280
you

00:03:57,120 --> 00:04:01,200
you could have one file that defined

00:03:59,280 --> 00:04:03,599
everything that you required

00:04:01,200 --> 00:04:04,879
and you know all of their versions as

00:04:03,599 --> 00:04:07,920
well

00:04:04,879 --> 00:04:10,239
um eventually

00:04:07,920 --> 00:04:11,120
virtualenv came out and that was that

00:04:10,239 --> 00:04:13,760
was

00:04:11,120 --> 00:04:15,360
something that i had to struggle to

00:04:13,760 --> 00:04:18,560
convince people to install

00:04:15,360 --> 00:04:20,400
because like it sort of took

00:04:18,560 --> 00:04:22,479
took control of your python package

00:04:20,400 --> 00:04:23,759
installation and separated them off

00:04:22,479 --> 00:04:25,680
into these little mini virtual

00:04:23,759 --> 00:04:27,199
environment mini environments where you

00:04:25,680 --> 00:04:28,080
could install a bunch of packages for

00:04:27,199 --> 00:04:30,720
just one project

00:04:28,080 --> 00:04:32,639
and you could have mutually incompatible

00:04:30,720 --> 00:04:33,919
uh packages installed at the same time

00:04:32,639 --> 00:04:35,759
for different projects

00:04:33,919 --> 00:04:37,440
it was fantastic python three i believe

00:04:35,759 --> 00:04:39,520
builds it in with v

00:04:37,440 --> 00:04:40,639
v e and v bend don't know how you say

00:04:39,520 --> 00:04:42,720
that

00:04:40,639 --> 00:04:43,680
but this allowed us to separate projects

00:04:42,720 --> 00:04:45,360
and if

00:04:43,680 --> 00:04:47,600
you had a lot of projects on the go as i

00:04:45,360 --> 00:04:49,440
did at that time it it was really

00:04:47,600 --> 00:04:51,120
invaluable in making sure that you don't

00:04:49,440 --> 00:04:53,919
break one project that you're working on

00:04:51,120 --> 00:04:57,120
by installing something for another

00:04:53,919 --> 00:04:57,520
these days scipy anaconda beware we have

00:04:57,120 --> 00:04:59,520
these

00:04:57,520 --> 00:05:01,120
fantastic curated package sets that

00:04:59,520 --> 00:05:04,160
integrate a lot more tightly

00:05:01,120 --> 00:05:06,320
um but it sort of feels like um we're

00:05:04,160 --> 00:05:07,360
moving away from that open bazaar of of

00:05:06,320 --> 00:05:10,400
of pie pie

00:05:07,360 --> 00:05:12,639
where you could get anything at any time

00:05:10,400 --> 00:05:15,199
for for slightly more closed

00:05:12,639 --> 00:05:18,400
user-friendly solutions

00:05:15,199 --> 00:05:19,360
um oh that's not going to show up all

00:05:18,400 --> 00:05:20,960
right there's supposed to be a picture

00:05:19,360 --> 00:05:23,120
there

00:05:20,960 --> 00:05:24,479
um there's a lot of issues that aren't

00:05:23,120 --> 00:05:27,440
still fully solved

00:05:24,479 --> 00:05:28,320
um we're still sort of doing incremental

00:05:27,440 --> 00:05:30,000
installations

00:05:28,320 --> 00:05:31,759
so you install like these package

00:05:30,000 --> 00:05:32,479
managers they install things one after

00:05:31,759 --> 00:05:34,960
the earlier

00:05:32,479 --> 00:05:35,840
and the order that you install things

00:05:34,960 --> 00:05:38,080
really

00:05:35,840 --> 00:05:39,039
um has a big difference on what you

00:05:38,080 --> 00:05:41,759
actually get

00:05:39,039 --> 00:05:43,680
so uh i've got this picture and took it

00:05:41,759 --> 00:05:45,360
from daniel wheeler's fantastic sci-fi

00:05:43,680 --> 00:05:46,080
2019 talk which you should definitely

00:05:45,360 --> 00:05:49,680
watch

00:05:46,080 --> 00:05:51,120
um this is uh anaconda anaconda building

00:05:49,680 --> 00:05:53,440
a thing called mayan

00:05:51,120 --> 00:05:55,680
if you ask anna connor to install phi pi

00:05:53,440 --> 00:05:57,919
which is a differential equation stover

00:05:55,680 --> 00:05:59,280
it will go and get numpy for you and it

00:05:57,919 --> 00:06:02,400
will build it with the blas

00:05:59,280 --> 00:06:04,960
mkl back end if you then

00:06:02,400 --> 00:06:06,000
install sweep i that also requires numpy

00:06:04,960 --> 00:06:06,720
and it will just use the one that's

00:06:06,000 --> 00:06:10,479
there

00:06:06,720 --> 00:06:13,199
but if you install svpi first which is a

00:06:10,479 --> 00:06:15,120
finite element package that requires

00:06:13,199 --> 00:06:17,840
numpy but it requests it to be built

00:06:15,120 --> 00:06:20,639
with open blasts as the back end

00:06:17,840 --> 00:06:22,319
so the order that you requested to

00:06:20,639 --> 00:06:23,360
install fee pi and swipe i really

00:06:22,319 --> 00:06:24,560
determines the

00:06:23,360 --> 00:06:27,199
like the back end that it's actually

00:06:24,560 --> 00:06:29,199
going to use and like depending on what

00:06:27,199 --> 00:06:30,880
processor architecture you're running on

00:06:29,199 --> 00:06:32,479
like blast and open blast have very

00:06:30,880 --> 00:06:34,479
different performance profiles so you

00:06:32,479 --> 00:06:36,639
can imagine if you and the

00:06:34,479 --> 00:06:37,919
developer next to you or the scientist

00:06:36,639 --> 00:06:40,080
next to you are

00:06:37,919 --> 00:06:41,680
trying to benchmark a piece of you know

00:06:40,080 --> 00:06:43,919
high performance code

00:06:41,680 --> 00:06:45,360
and one of these installed five pi first

00:06:43,919 --> 00:06:47,600
and the other person's installed

00:06:45,360 --> 00:06:49,199
sphere pipe first you may be pulling out

00:06:47,600 --> 00:06:52,560
hair going here why is the performance

00:06:49,199 --> 00:06:54,880
so different between our two builds

00:06:52,560 --> 00:06:55,680
um these diamond dependency graphs are

00:06:54,880 --> 00:06:58,240
you know

00:06:55,680 --> 00:07:03,840
still one of those great unsolved um

00:06:58,240 --> 00:07:03,840
great unsolved

00:07:04,000 --> 00:07:08,080
uh are still unsolved in many cases but

00:07:06,080 --> 00:07:09,840
uh you know

00:07:08,080 --> 00:07:11,759
the tooling is doing a lot better these

00:07:09,840 --> 00:07:13,199
days um

00:07:11,759 --> 00:07:15,280
you've also got the problem of native

00:07:13,199 --> 00:07:18,960
dependencies so often when you

00:07:15,280 --> 00:07:20,800
install a uh package it's uh the

00:07:18,960 --> 00:07:23,039
you know the standard advice is go and

00:07:20,800 --> 00:07:26,560
install you know build essentials

00:07:23,039 --> 00:07:28,240
um because your package is probably uh

00:07:26,560 --> 00:07:30,160
this package is probably going to want

00:07:28,240 --> 00:07:32,400
to compile something

00:07:30,160 --> 00:07:33,680
or link against something and so you

00:07:32,400 --> 00:07:36,240
know if you install

00:07:33,680 --> 00:07:37,840
lxml it's going to want to compile or

00:07:36,240 --> 00:07:40,080
link against libxml

00:07:37,840 --> 00:07:42,000
if you want pyqt it's going to compile

00:07:40,080 --> 00:07:45,120
you know csims to

00:07:42,000 --> 00:07:46,400
to talk to qt pi crypto requires you

00:07:45,120 --> 00:07:48,879
know open ssl

00:07:46,400 --> 00:07:50,800
or a similar ssl like a crypto loop

00:07:48,879 --> 00:07:52,639
under the hood

00:07:50,800 --> 00:07:54,160
we've uh we solved it a little bit with

00:07:52,639 --> 00:07:55,680
wheels because they can

00:07:54,160 --> 00:07:58,560
contain shared libraries that get

00:07:55,680 --> 00:08:00,479
packaged up along with um

00:07:58,560 --> 00:08:01,680
with the wheel but you know how do you

00:08:00,479 --> 00:08:04,080
patch wheels across

00:08:01,680 --> 00:08:05,520
many virtually if if there's a problem

00:08:04,080 --> 00:08:07,039
in one of your shared libraries do you

00:08:05,520 --> 00:08:08,960
do you have to go and patch every single

00:08:07,039 --> 00:08:10,879
one um

00:08:08,960 --> 00:08:13,360
it would be good if there was a way that

00:08:10,879 --> 00:08:15,520
we could you know

00:08:13,360 --> 00:08:16,400
update that once and have all those

00:08:15,520 --> 00:08:20,080
projects

00:08:16,400 --> 00:08:22,160
uh benefit from that update um

00:08:20,080 --> 00:08:23,759
there's also system dependencies you

00:08:22,160 --> 00:08:24,800
know your operating system provides a

00:08:23,759 --> 00:08:27,039
lot of services

00:08:24,800 --> 00:08:28,720
and can have services running for you

00:08:27,039 --> 00:08:30,240
that you might depend upon

00:08:28,720 --> 00:08:32,719
for instance you know if you're running

00:08:30,240 --> 00:08:35,360
a uh a web project

00:08:32,719 --> 00:08:36,000
your tests may require ephemeral pg like

00:08:35,360 --> 00:08:38,399
postgres

00:08:36,000 --> 00:08:40,000
that can be set up and torn down really

00:08:38,399 --> 00:08:42,000
quickly it might require redis

00:08:40,000 --> 00:08:43,919
to properly test your caching layer

00:08:42,000 --> 00:08:44,800
these kinds of dependencies aren't

00:08:43,919 --> 00:08:46,480
really well

00:08:44,800 --> 00:08:49,120
captured with the current set of tooling

00:08:46,480 --> 00:08:50,000
for python packages

00:08:49,120 --> 00:08:52,160
i also want to talk about

00:08:50,000 --> 00:08:55,120
reproducibility

00:08:52,160 --> 00:08:57,240
so in the scientific um in the

00:08:55,120 --> 00:09:00,720
scientific field there's this great

00:08:57,240 --> 00:09:04,560
reproducibility crisis um

00:09:00,720 --> 00:09:05,440
a lot of papers uh a lot of research is

00:09:04,560 --> 00:09:07,680
published

00:09:05,440 --> 00:09:09,200
either without code at all because it's

00:09:07,680 --> 00:09:11,600
considered proprietary

00:09:09,200 --> 00:09:12,720
or with you know just a big table dump

00:09:11,600 --> 00:09:15,040
and that you know

00:09:12,720 --> 00:09:16,320
even when you've got a table dump um of

00:09:15,040 --> 00:09:17,680
all the code you don't really know

00:09:16,320 --> 00:09:19,040
exactly how it was built like

00:09:17,680 --> 00:09:21,279
you know what operating system did they

00:09:19,040 --> 00:09:23,360
build it on what version of the

00:09:21,279 --> 00:09:24,399
is like did the developer who actually

00:09:23,360 --> 00:09:26,320
ran this study

00:09:24,399 --> 00:09:27,680
like did he have a patched version of

00:09:26,320 --> 00:09:30,320
that one package

00:09:27,680 --> 00:09:32,240
um that you know worked around a bug are

00:09:30,320 --> 00:09:34,560
you going to hit that same bug

00:09:32,240 --> 00:09:36,000
so there's the 10-year reproducibility

00:09:34,560 --> 00:09:39,360
reproducibility challenge

00:09:36,000 --> 00:09:41,519
and they are challenging people to

00:09:39,360 --> 00:09:43,279
get creative pull out a paper from 10

00:09:41,519 --> 00:09:44,800
years ago pull out some research they

00:09:43,279 --> 00:09:45,680
did or even just an old project from 10

00:09:44,800 --> 00:09:48,160
years ago and see

00:09:45,680 --> 00:09:49,680
like can i still get this to run like is

00:09:48,160 --> 00:09:52,399
this still something that i

00:09:49,680 --> 00:09:54,320
that we should be able to rerun and

00:09:52,399 --> 00:09:57,600
revalidate today

00:09:54,320 --> 00:09:59,279
and can you even do it i also want to

00:09:57,600 --> 00:10:01,839
talk about what reproducibility

00:09:59,279 --> 00:10:03,600
isn't it's not about proving software

00:10:01,839 --> 00:10:05,040
providence this is something i often see

00:10:03,600 --> 00:10:07,920
brought up as a destroyment

00:10:05,040 --> 00:10:08,640
you know that you need reproducibility

00:10:07,920 --> 00:10:11,519
to

00:10:08,640 --> 00:10:12,240
like to prove that you know the binary i

00:10:11,519 --> 00:10:14,079
got from

00:10:12,240 --> 00:10:15,519
person a is the same as the one that i

00:10:14,079 --> 00:10:17,440
would have built myself

00:10:15,519 --> 00:10:18,640
it's not really about that i think code

00:10:17,440 --> 00:10:20,959
signing has sort of

00:10:18,640 --> 00:10:21,760
uh standardized code signing has sort of

00:10:20,959 --> 00:10:23,200
made that

00:10:21,760 --> 00:10:25,040
not really an issue but what

00:10:23,200 --> 00:10:27,839
reproducibility is about is

00:10:25,040 --> 00:10:28,399
it's more about operational concerns i

00:10:27,839 --> 00:10:30,320
want to know

00:10:28,399 --> 00:10:31,519
how can i onboard a new developer like

00:10:30,320 --> 00:10:32,800
in under a week

00:10:31,519 --> 00:10:34,480
they shouldn't have to sit down and

00:10:32,800 --> 00:10:35,120
spend a week installing all of the

00:10:34,480 --> 00:10:37,920
different

00:10:35,120 --> 00:10:38,959
uh packages all the different dev tools

00:10:37,920 --> 00:10:41,040
um

00:10:38,959 --> 00:10:42,640
reproducible software requires

00:10:41,040 --> 00:10:44,399
reproducible build environments and

00:10:42,640 --> 00:10:44,800
reproducible build environments are also

00:10:44,399 --> 00:10:47,920
great

00:10:44,800 --> 00:10:49,519
development environments and if we can

00:10:47,920 --> 00:10:50,480
reproduce them automatically then we

00:10:49,519 --> 00:10:52,320
should just be able to

00:10:50,480 --> 00:10:53,839
load them onto a new devs computer

00:10:52,320 --> 00:10:55,600
straight away

00:10:53,839 --> 00:10:57,120
i also want to know how do i

00:10:55,600 --> 00:10:58,800
containerize this thing

00:10:57,120 --> 00:11:00,399
unless you're shipping static binaries

00:10:58,800 --> 00:11:01,200
you should probably package apps with a

00:11:00,399 --> 00:11:04,399
container

00:11:01,200 --> 00:11:05,360
i don't think that that's uh like a

00:11:04,399 --> 00:11:08,240
contentious

00:11:05,360 --> 00:11:09,600
uh position to take these days like uh

00:11:08,240 --> 00:11:12,320
containerization

00:11:09,600 --> 00:11:13,120
you know snap d flat pack uh docker

00:11:12,320 --> 00:11:14,640
images

00:11:13,120 --> 00:11:16,240
they're just a really great thing to

00:11:14,640 --> 00:11:18,000
have if you want to get like

00:11:16,240 --> 00:11:20,640
reproducible sets of software

00:11:18,000 --> 00:11:22,000
developed and like deployed out to a lot

00:11:20,640 --> 00:11:24,160
of people

00:11:22,000 --> 00:11:26,839
docker files are a great start they can

00:11:24,160 --> 00:11:29,440
have fairly surprising semantics

00:11:26,839 --> 00:11:32,399
and they can produce fairly

00:11:29,440 --> 00:11:34,800
fat images and so then there's something

00:11:32,399 --> 00:11:36,720
that i would like to avoid

00:11:34,800 --> 00:11:38,160
i'll also want to ask questions like you

00:11:36,720 --> 00:11:38,880
know why can't i replicate that

00:11:38,160 --> 00:11:41,200
production

00:11:38,880 --> 00:11:42,000
uh bug in my development environment

00:11:41,200 --> 00:11:44,079
someone probably

00:11:42,000 --> 00:11:45,040
me patched the system libraries at some

00:11:44,079 --> 00:11:47,760
point and

00:11:45,040 --> 00:11:48,480
i didn't notice or forgot this is a true

00:11:47,760 --> 00:11:50,480
story

00:11:48,480 --> 00:11:52,480
i have spent a week debugging an issue

00:11:50,480 --> 00:11:54,480
like that before

00:11:52,480 --> 00:11:56,000
and it's very easy even with virtual

00:11:54,480 --> 00:11:59,120
environments where you've

00:11:56,000 --> 00:12:02,399
specified it to contain system packages

00:11:59,120 --> 00:12:04,160
as well to have an issue like this

00:12:02,399 --> 00:12:06,560
i also want to know you know how do i

00:12:04,160 --> 00:12:07,040
release my code along with my academic

00:12:06,560 --> 00:12:08,880
paper

00:12:07,040 --> 00:12:10,399
or maybe even not an academic paper but

00:12:08,880 --> 00:12:11,120
like just just a report to a different

00:12:10,399 --> 00:12:13,519
department

00:12:11,120 --> 00:12:14,240
like how how can i give them something

00:12:13,519 --> 00:12:17,440
and say

00:12:14,240 --> 00:12:19,120
oh yes this will run for you just as

00:12:17,440 --> 00:12:20,800
well as it works for me

00:12:19,120 --> 00:12:23,600
and will my peers be able to reproduce

00:12:20,800 --> 00:12:26,560
my results in 10 years time

00:12:23,600 --> 00:12:28,399
so i want to introduce you to nyx nyx is

00:12:26,560 --> 00:12:30,000
a powerful package manager for linux and

00:12:28,399 --> 00:12:34,079
other uni uh that makes package

00:12:30,000 --> 00:12:36,000
management reliable and reproducible

00:12:34,079 --> 00:12:37,839
nyx is kind of an overloaded word here

00:12:36,000 --> 00:12:38,639
so we'll go through what it actually is

00:12:37,839 --> 00:12:41,519
so nyx

00:12:38,639 --> 00:12:42,399
is a pure functional lazy configuration

00:12:41,519 --> 00:12:44,880
language

00:12:42,399 --> 00:12:46,959
the pure functional part makes it really

00:12:44,880 --> 00:12:48,800
easy to give it guarantees about

00:12:46,959 --> 00:12:50,240
reproducibility because if you always

00:12:48,800 --> 00:12:51,920
give it the same inputs it's always

00:12:50,240 --> 00:12:53,760
going to give you the same outputs and

00:12:51,920 --> 00:12:57,040
it's lazy in that it will only build as

00:12:53,760 --> 00:12:57,040
much as you actually need

00:12:57,440 --> 00:13:03,120
nyx in italics is a package manager that

00:13:00,959 --> 00:13:05,360
builds and manages environments

00:13:03,120 --> 00:13:07,680
using that next language has over a

00:13:05,360 --> 00:13:09,600
hundred contributors since 2003 and it

00:13:07,680 --> 00:13:10,480
contains a swiss army knife of tools

00:13:09,600 --> 00:13:13,440
like nixon

00:13:10,480 --> 00:13:15,519
next shell and its channel on top of

00:13:13,440 --> 00:13:17,680
those things is built next packages

00:13:15,519 --> 00:13:20,480
this is a community curated collection

00:13:17,680 --> 00:13:22,480
of nyx package definitions

00:13:20,480 --> 00:13:24,480
nyx packages has over forty thousand

00:13:22,480 --> 00:13:26,720
packages and over three thousand of

00:13:24,480 --> 00:13:28,800
those are python packages

00:13:26,720 --> 00:13:30,639
these people the volunteers have done a

00:13:28,800 --> 00:13:31,760
lot of work uh doing the tricky part of

00:13:30,639 --> 00:13:33,920
packaging up

00:13:31,760 --> 00:13:35,200
a lot of um these packages that have

00:13:33,920 --> 00:13:37,680
traditionally been hard

00:13:35,200 --> 00:13:39,920
and relied on a lot of native libraries

00:13:37,680 --> 00:13:41,920
it has multiple stable releases per year

00:13:39,920 --> 00:13:43,440
and it has a very fast-moving unstable

00:13:41,920 --> 00:13:47,040
challenge

00:13:43,440 --> 00:13:48,880
unstable channel where

00:13:47,040 --> 00:13:50,880
you can you can preview a lot of changes

00:13:48,880 --> 00:13:54,079
that are going to come out

00:13:50,880 --> 00:13:57,199
um nixos is a gnu linux distribution dev

00:13:54,079 --> 00:13:58,639
click configured declaratively with nics

00:13:57,199 --> 00:14:01,199
and it has an awesome module system

00:13:58,639 --> 00:14:02,720
makes it simple to specify services and

00:14:01,199 --> 00:14:04,560
configuration without actually

00:14:02,720 --> 00:14:06,639
worrying about which packages that's

00:14:04,560 --> 00:14:09,600
going to require like it

00:14:06,639 --> 00:14:10,240
handles that under the hood for you now

00:14:09,600 --> 00:14:13,040
i want to

00:14:10,240 --> 00:14:14,800
like define some terms so in in nics we

00:14:13,040 --> 00:14:15,279
talk about expressions and expressions

00:14:14,800 --> 00:14:17,040
are

00:14:15,279 --> 00:14:18,480
pure functions that describe your

00:14:17,040 --> 00:14:22,079
desired package

00:14:18,480 --> 00:14:24,240
or package set their dependencies become

00:14:22,079 --> 00:14:25,680
parameters to these different to this

00:14:24,240 --> 00:14:27,199
function and this is

00:14:25,680 --> 00:14:29,760
fairly standard for people who work with

00:14:27,199 --> 00:14:31,920
dependency injection systems

00:14:29,760 --> 00:14:34,079
a derivation is the result of an

00:14:31,920 --> 00:14:36,560
expression instantiated into a

00:14:34,079 --> 00:14:37,360
div file and that file concretely

00:14:36,560 --> 00:14:39,279
defines

00:14:37,360 --> 00:14:41,360
the build inputs and build process for a

00:14:39,279 --> 00:14:43,440
package including all the hashes of the

00:14:41,360 --> 00:14:44,880
inputs

00:14:43,440 --> 00:14:47,920
and it will give you a derivation that

00:14:44,880 --> 00:14:47,920
has a hash on the output

00:14:48,000 --> 00:14:51,920
the result is the build output from

00:14:50,399 --> 00:14:53,040
following the rules given in the

00:14:51,920 --> 00:14:54,959
derivation

00:14:53,040 --> 00:14:57,360
it contains only absolute parts of other

00:14:54,959 --> 00:14:59,839
derivations in its closure

00:14:57,360 --> 00:15:01,040
and this is what you would typically be

00:14:59,839 --> 00:15:03,440
installing

00:15:01,040 --> 00:15:05,519
the closure is the graph of outputs

00:15:03,440 --> 00:15:07,600
referenced by a particular result

00:15:05,519 --> 00:15:08,959
and these are all loaded into the next

00:15:07,600 --> 00:15:10,639
store

00:15:08,959 --> 00:15:13,760
and the next story is the graph database

00:15:10,639 --> 00:15:14,880
that all the outputs are cached into

00:15:13,760 --> 00:15:17,279
so how do you actually go about

00:15:14,880 --> 00:15:19,519
installing nix well it's fairly simple

00:15:17,279 --> 00:15:21,199
depending on your tolerance for

00:15:19,519 --> 00:15:22,639
installing things cold off the internet

00:15:21,199 --> 00:15:24,000
you can go and download this it's

00:15:22,639 --> 00:15:25,760
a fairly simple script and you can

00:15:24,000 --> 00:15:26,160
inspect it for yourself but if you're

00:15:25,760 --> 00:15:28,480
doing

00:15:26,160 --> 00:15:29,360
a single user installation for a

00:15:28,480 --> 00:15:31,360
development sheet

00:15:29,360 --> 00:15:32,399
development machine you can just install

00:15:31,360 --> 00:15:33,920
it no daemon

00:15:32,399 --> 00:15:36,720
and what that means is that when you run

00:15:33,920 --> 00:15:39,360
all the next tools they will run as you

00:15:36,720 --> 00:15:41,040
if you're in a multi-user installation

00:15:39,360 --> 00:15:42,639
this is a machine that you want multiple

00:15:41,040 --> 00:15:44,240
people to interact with i recommend

00:15:42,639 --> 00:15:45,920
installing in daemon mode

00:15:44,240 --> 00:15:47,360
and that will install the next daemon

00:15:45,920 --> 00:15:48,480
and the next daemon is actually what

00:15:47,360 --> 00:15:50,320
will

00:15:48,480 --> 00:15:52,000
build things into the store and manage

00:15:50,320 --> 00:15:53,680
the store for you and it provides an

00:15:52,000 --> 00:15:55,279
interface to the next tools

00:15:53,680 --> 00:15:57,279
to be able to request things to change

00:15:55,279 --> 00:15:59,360
in the store

00:15:57,279 --> 00:16:00,480
enabling non-free packages like eg if

00:15:59,360 --> 00:16:02,240
you want to use chrome

00:16:00,480 --> 00:16:04,000
and the chrome web driver you need to

00:16:02,240 --> 00:16:04,959
allow on free that's not enabled by

00:16:04,000 --> 00:16:06,399
default

00:16:04,959 --> 00:16:08,720
and you can just drop this line into

00:16:06,399 --> 00:16:10,560
your next packages config

00:16:08,720 --> 00:16:11,920
uninstalling is very easy if you decide

00:16:10,560 --> 00:16:12,560
that you don't like it after giving it a

00:16:11,920 --> 00:16:14,320
try

00:16:12,560 --> 00:16:17,440
it installs a path in your profile just

00:16:14,320 --> 00:16:21,680
get rid of that and rmrf the next store

00:16:17,440 --> 00:16:23,440
gone easy so uh nick's end is the ad hoc

00:16:21,680 --> 00:16:24,880
package management system that comes

00:16:23,440 --> 00:16:27,040
with nyx

00:16:24,880 --> 00:16:28,959
you can query for available packages you

00:16:27,040 --> 00:16:29,600
can install packages you can upgrade

00:16:28,959 --> 00:16:31,279
packages

00:16:29,600 --> 00:16:33,199
and you can uninstall packages fairly

00:16:31,279 --> 00:16:36,079
standard stuff but crucially

00:16:33,199 --> 00:16:37,440
doing all of these things all of these

00:16:36,079 --> 00:16:40,720
things can be rolled back

00:16:37,440 --> 00:16:45,759
um they're not actually destructive

00:16:40,720 --> 00:16:47,120
operations you can always revert so

00:16:45,759 --> 00:16:49,759
what actually gets put into the next

00:16:47,120 --> 00:16:51,600
door if we query out my python version

00:16:49,759 --> 00:16:55,759
that i've just installed it tells you

00:16:51,600 --> 00:16:57,600
it tells me that um we're relying on

00:16:55,759 --> 00:16:59,600
all of these packages under the hood

00:16:57,600 --> 00:17:02,000
this is the transitive closure

00:16:59,600 --> 00:17:04,400
of python 3 on my system and this is

00:17:02,000 --> 00:17:07,839
what i've got installed into my

00:17:04,400 --> 00:17:10,400
user profile we can also

00:17:07,839 --> 00:17:11,520
perform package maintenance you can

00:17:10,400 --> 00:17:13,679
update your channel

00:17:11,520 --> 00:17:16,240
so you can pull down patches and back

00:17:13,679 --> 00:17:18,959
ports for your currently active channels

00:17:16,240 --> 00:17:19,439
1909 and 2003 are currently active and

00:17:18,959 --> 00:17:22,400
getting

00:17:19,439 --> 00:17:23,439
uh back ports and unstable is moving

00:17:22,400 --> 00:17:25,280
ahead at a

00:17:23,439 --> 00:17:28,559
great pace i think they're gonna branch

00:17:25,280 --> 00:17:31,520
for 1909 at 2009 soon and that'll be

00:17:28,559 --> 00:17:32,160
exciting um you can also roll back

00:17:31,520 --> 00:17:34,320
updates

00:17:32,160 --> 00:17:35,840
so it's a generational garbage collected

00:17:34,320 --> 00:17:37,919
system for packages

00:17:35,840 --> 00:17:39,360
so if you want to roll back you just

00:17:37,919 --> 00:17:40,400
roll back to the last generation and the

00:17:39,360 --> 00:17:42,160
last generation is

00:17:40,400 --> 00:17:45,039
the thing you had before you installed

00:17:42,160 --> 00:17:47,360
or removed that last thing

00:17:45,039 --> 00:17:48,080
you can perform um some garbage

00:17:47,360 --> 00:17:50,160
collection

00:17:48,080 --> 00:17:51,600
so if you decide that you're not gonna

00:17:50,160 --> 00:17:53,200
need to roll back to anything you know

00:17:51,600 --> 00:17:54,320
more than 30 days ago you can delete

00:17:53,200 --> 00:17:56,880
older generations

00:17:54,320 --> 00:17:58,640
by a certain amount of time um you can

00:17:56,880 --> 00:17:59,360
also ask the next door to garbage

00:17:58,640 --> 00:18:00,799
collect any

00:17:59,360 --> 00:18:02,160
packages that might have been installed

00:18:00,799 --> 00:18:03,679
to build something but now that thing

00:18:02,160 --> 00:18:06,720
has been built and you just want to get

00:18:03,679 --> 00:18:06,720
rid of all the sources

00:18:06,960 --> 00:18:13,039
um we can also hard link duplicate

00:18:10,400 --> 00:18:14,080
files in order to share space so taming

00:18:13,039 --> 00:18:17,360
snakes

00:18:14,080 --> 00:18:18,320
um next build is the system for building

00:18:17,360 --> 00:18:20,799
environments

00:18:18,320 --> 00:18:22,160
um you can arsenic's field build to

00:18:20,799 --> 00:18:25,440
build your environment

00:18:22,160 --> 00:18:27,919
into the local store and it will

00:18:25,440 --> 00:18:29,440
output a link that gives you a shell

00:18:27,919 --> 00:18:30,799
script that you can

00:18:29,440 --> 00:18:32,240
run and it will activate that

00:18:30,799 --> 00:18:34,559
environment it will put everything that

00:18:32,240 --> 00:18:37,120
you've asked it to put on your path

00:18:34,559 --> 00:18:38,480
and give you access to those dev tools

00:18:37,120 --> 00:18:40,240
next shell is very much

00:18:38,480 --> 00:18:42,080
a similar thing it'll give you a

00:18:40,240 --> 00:18:43,760
transient shell

00:18:42,080 --> 00:18:45,360
that has all those things and in pure

00:18:43,760 --> 00:18:47,280
mode it will give you just those things

00:18:45,360 --> 00:18:49,760
and nothing else

00:18:47,280 --> 00:18:51,280
um next derivations are running long

00:18:49,760 --> 00:18:53,919
time so go through this quickly

00:18:51,280 --> 00:18:55,600
um they're fairly simple things build

00:18:53,919 --> 00:18:57,280
python package

00:18:55,600 --> 00:18:59,600
is part of the standard library of next

00:18:57,280 --> 00:19:00,559
packages it gives you a very quick way

00:18:59,600 --> 00:19:02,480
of

00:19:00,559 --> 00:19:04,400
declaring packages and what their inputs

00:19:02,480 --> 00:19:09,520
and outputs are

00:19:04,400 --> 00:19:11,120
integrating with c-libs is handled

00:19:09,520 --> 00:19:12,559
with the sea leaves that are already

00:19:11,120 --> 00:19:16,320
built into next packages

00:19:12,559 --> 00:19:18,240
um you can you can reference

00:19:16,320 --> 00:19:19,360
those uh directly through your build

00:19:18,240 --> 00:19:21,679
inputs

00:19:19,360 --> 00:19:22,480
um and it will only reference like the

00:19:21,679 --> 00:19:24,960
actual

00:19:22,480 --> 00:19:26,240
shed objects that result from those you

00:19:24,960 --> 00:19:27,840
don't actually need to

00:19:26,240 --> 00:19:29,440
reference any of the build tools in your

00:19:27,840 --> 00:19:31,600
output

00:19:29,440 --> 00:19:33,679
this will give you a dependency graph

00:19:31,600 --> 00:19:34,720
and it it only requires runtime

00:19:33,679 --> 00:19:36,320
dependencies

00:19:34,720 --> 00:19:37,520
only includes runtime dependencies so

00:19:36,320 --> 00:19:38,080
you can actually throw away everything

00:19:37,520 --> 00:19:40,000
that you used to

00:19:38,080 --> 00:19:42,240
build it and just distribute the things

00:19:40,000 --> 00:19:44,000
that were built

00:19:42,240 --> 00:19:46,559
for reproducibility you could pin that

00:19:44,000 --> 00:19:49,360
package set so if you want

00:19:46,559 --> 00:19:50,720
mixed packages like from a specific date

00:19:49,360 --> 00:19:53,919
you can go and look that up

00:19:50,720 --> 00:19:55,120
get a commit hash from github and you

00:19:53,919 --> 00:19:56,880
can

00:19:55,120 --> 00:19:58,400
pin your packages so that you always get

00:19:56,880 --> 00:20:00,400
exactly the same packages every time you

00:19:58,400 --> 00:20:03,039
run this script

00:20:00,400 --> 00:20:03,919
tooling in the ecosystem many other

00:20:03,039 --> 00:20:06,720
build tools

00:20:03,919 --> 00:20:07,679
many other tools are included with nics

00:20:06,720 --> 00:20:09,360
vm and emacs

00:20:07,679 --> 00:20:12,240
configuration tools and plugins are part

00:20:09,360 --> 00:20:14,240
of nix packages you can

00:20:12,240 --> 00:20:15,840
create a completely reproducible vim and

00:20:14,240 --> 00:20:18,240
emacs configuration

00:20:15,840 --> 00:20:18,960
um it could include cross-compilation

00:20:18,240 --> 00:20:21,600
tool chains

00:20:18,960 --> 00:20:24,080
that don't pollute your cross

00:20:21,600 --> 00:20:25,760
compilation targets with system headers

00:20:24,080 --> 00:20:27,600
uh makes it very very easy for working

00:20:25,760 --> 00:20:28,559
on cross compilation it has docker image

00:20:27,600 --> 00:20:32,000
creation tools

00:20:28,559 --> 00:20:35,039
nixory.ev is mixery.dev is a fantastic

00:20:32,000 --> 00:20:37,520
online tool for generating um

00:20:35,039 --> 00:20:38,880
for generating docker images on the fly

00:20:37,520 --> 00:20:40,640
from nyx packages

00:20:38,880 --> 00:20:42,559
it also has os image building tools if

00:20:40,640 --> 00:20:45,520
you want to build lean bare metal

00:20:42,559 --> 00:20:47,120
os images uh container and vm based

00:20:45,520 --> 00:20:48,320
system test tools are great if you have

00:20:47,120 --> 00:20:49,840
distributed

00:20:48,320 --> 00:20:51,520
systems that you're building they can

00:20:49,840 --> 00:20:53,520
provide a lot of test infrastructure for

00:20:51,520 --> 00:20:55,280
those systems

00:20:53,520 --> 00:20:56,480
um talking about python specifically

00:20:55,280 --> 00:20:56,960
there's two projects i want to talk

00:20:56,480 --> 00:21:00,799
about

00:20:56,960 --> 00:21:04,240
macnix is a system that provides

00:21:00,799 --> 00:21:05,919
a very like pip like uh interface it's

00:21:04,240 --> 00:21:06,720
also got a kickass logo i love their

00:21:05,919 --> 00:21:08,799
logo

00:21:06,720 --> 00:21:10,000
um it pulls packages from either nyx

00:21:08,799 --> 00:21:12,559
packages or pi pi

00:21:10,000 --> 00:21:14,840
either as sdis or wheels so it gives you

00:21:12,559 --> 00:21:18,400
it gives you like a per package basis

00:21:14,840 --> 00:21:19,120
um way to to pick up uh packages that

00:21:18,400 --> 00:21:20,720
you actually want

00:21:19,120 --> 00:21:23,200
and it's especially good for packages

00:21:20,720 --> 00:21:24,799
that have like um gnarly c dependencies

00:21:23,200 --> 00:21:26,480
you can pull those from next packages

00:21:24,799 --> 00:21:28,320
and pull the rest from wherever you want

00:21:26,480 --> 00:21:28,640
the only downside is that it does have a

00:21:28,320 --> 00:21:30,240
big

00:21:28,640 --> 00:21:31,840
pi pi dependency database that you need

00:21:30,240 --> 00:21:33,600
to download but you only need to do that

00:21:31,840 --> 00:21:35,840
once

00:21:33,600 --> 00:21:37,280
poetry to next i absolutely love poetry

00:21:35,840 --> 00:21:40,240
genex

00:21:37,280 --> 00:21:42,320
poetry linux uses poetry which is a

00:21:40,240 --> 00:21:45,679
fantastic python package manager

00:21:42,320 --> 00:21:47,600
um and it just pulls in the lock

00:21:45,679 --> 00:21:49,440
file so if you've already got a poetry

00:21:47,600 --> 00:21:50,559
um package it'll pull in the project

00:21:49,440 --> 00:21:52,240
file and the log file

00:21:50,559 --> 00:21:54,480
the log file contains all the hashes

00:21:52,240 --> 00:21:56,960
that you need anyway and so it will

00:21:54,480 --> 00:21:57,600
produce a fully reproducible build just

00:21:56,960 --> 00:22:00,320
from that

00:21:57,600 --> 00:22:02,400
straight into next door and that

00:22:00,320 --> 00:22:05,679
reproducible build can be shared out

00:22:02,400 --> 00:22:09,200
using any of the existing nyx tools

00:22:05,679 --> 00:22:11,120
um lorien durant duram is a great tool i

00:22:09,200 --> 00:22:12,720
think it was discussed earlier

00:22:11,120 --> 00:22:14,960
it allows you to set up a whole bunch of

00:22:12,720 --> 00:22:17,280
environments variables based on

00:22:14,960 --> 00:22:18,640
an input in this case we're using nyx's

00:22:17,280 --> 00:22:21,679
uh mkshell

00:22:18,640 --> 00:22:24,159
to give you a shell environment and lori

00:22:21,679 --> 00:22:26,720
will allow you to re-reload that

00:22:24,159 --> 00:22:28,640
environment whenever it changes

00:22:26,720 --> 00:22:30,799
we can also deploy docker docker

00:22:28,640 --> 00:22:32,400
building you can build on a mac and it

00:22:30,799 --> 00:22:33,039
will build packages for linux because

00:22:32,400 --> 00:22:36,320
docker

00:22:33,039 --> 00:22:38,320
only understands linux binaries

00:22:36,320 --> 00:22:40,240
and you can you can load that image and

00:22:38,320 --> 00:22:40,960
run it just as if it was any other linux

00:22:40,240 --> 00:22:44,880
pack

00:22:40,960 --> 00:22:46,240
environment i also want to plug these

00:22:44,880 --> 00:22:49,360
fantastic resources

00:22:46,240 --> 00:22:52,000
um nyx.dev is a fantastic guide

00:22:49,360 --> 00:22:54,400
very in-depth a very good narrative

00:22:52,000 --> 00:22:55,760
structure for learning about nyx

00:22:54,400 --> 00:22:57,600
the next manual is incredibly

00:22:55,760 --> 00:23:00,799
comprehensive and comes with a lot of

00:22:57,600 --> 00:23:02,480
fantastic examples uh nyx pills is a

00:23:00,799 --> 00:23:08,159
deep dive into nick's

00:23:02,480 --> 00:23:11,039
the system and like the the uh

00:23:08,159 --> 00:23:11,039
uh and the um

00:23:13,039 --> 00:23:16,799
the the system behind it um and yeah

00:23:15,440 --> 00:23:19,360
have a look at these other great things

00:23:16,799 --> 00:23:22,799
especially these other great talks by um

00:23:19,360 --> 00:23:25,520
uh scipy uh by danny wheeler and asco

00:23:22,799 --> 00:23:27,360
and thank you very much and i'm happy to

00:23:25,520 --> 00:23:29,039
take any questions

00:23:27,360 --> 00:23:30,559
uh thanks so much for that thomas

00:23:29,039 --> 00:23:32,400
unfortunately we don't have any time for

00:23:30,559 --> 00:23:35,120
questions

00:23:32,400 --> 00:23:36,320
right now before the break um but just

00:23:35,120 --> 00:23:36,559
from that it sounds like there's a lot

00:23:36,320 --> 00:23:38,799
of

00:23:36,559 --> 00:23:40,400
really great entry points into mix and

00:23:38,799 --> 00:23:42,240
like once you said

00:23:40,400 --> 00:23:43,760
generational garbage collected package

00:23:42,240 --> 00:23:45,440
management like i was hooked

00:23:43,760 --> 00:23:47,679
and i'm really excited to go try that

00:23:45,440 --> 00:23:50,799
out in some of my personal projects now

00:23:47,679 --> 00:23:51,679
um up after the break we have florian

00:23:50,799 --> 00:23:55,039
haas talking about

00:23:51,679 --> 00:23:55,360
h.a proxy and django and we will see you

00:23:55,039 --> 00:23:58,480
all

00:23:55,360 --> 00:23:58,480
in about 10 minutes

00:23:59,120 --> 00:24:07,760
thank you

00:24:05,679 --> 00:24:07,760

YouTube URL: https://www.youtube.com/watch?v=8ng4v1g5q7s


