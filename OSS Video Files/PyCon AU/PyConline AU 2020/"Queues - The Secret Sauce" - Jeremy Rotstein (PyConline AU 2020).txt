Title: "Queues - The Secret Sauce" - Jeremy Rotstein (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Jeremy Rotstein

https://2020.pycon.org.au/program/NKWBA3

.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 14:40:00 2020 at Floperator
Captions: 
	00:00:01,280 --> 00:00:05,399
hey everybody welcome back uh

00:00:03,520 --> 00:00:06,560
we are in the flip-flop raider

00:00:05,399 --> 00:00:09,280
auditorium

00:00:06,560 --> 00:00:10,320
and up next we have jeremy rothstein uh

00:00:09,280 --> 00:00:12,480
jeremy rothstein

00:00:10,320 --> 00:00:15,839
is a systems engineer with a background

00:00:12,480 --> 00:00:18,560
in industrial control systems

00:00:15,839 --> 00:00:20,480
and he has been running the show all day

00:00:18,560 --> 00:00:21,199
here in the flip flop radar auditorium

00:00:20,480 --> 00:00:23,279
so

00:00:21,199 --> 00:00:24,240
even though you haven't you haven't uh

00:00:23,279 --> 00:00:26,960
seen him yet

00:00:24,240 --> 00:00:28,160
you have felt his presence um and now he

00:00:26,960 --> 00:00:29,199
is actually going to give a talk

00:00:28,160 --> 00:00:30,480
directly so for

00:00:29,199 --> 00:00:32,640
for the first time he's going to be in

00:00:30,480 --> 00:00:35,200
the limelight so um thank you very much

00:00:32,640 --> 00:00:38,079
take it away jeremy

00:00:35,200 --> 00:00:39,920
now is thanks uh tom yeah i'm used to

00:00:38,079 --> 00:00:42,239
being behind the curtain

00:00:39,920 --> 00:00:44,399
um so yeah certainly feels a little bit

00:00:42,239 --> 00:00:48,800
weird uh being on the other side

00:00:44,399 --> 00:00:48,800
uh intentionally at least

00:00:49,200 --> 00:00:55,920
so the name of the guy in this picture

00:00:52,719 --> 00:00:58,559
is alex martelly

00:00:55,920 --> 00:00:59,680
he's authored several well-known books

00:00:58,559 --> 00:01:02,399
on python

00:00:59,680 --> 00:01:03,760
um if you haven't read his books you've

00:01:02,399 --> 00:01:07,200
probably seen something

00:01:03,760 --> 00:01:08,320
of his on stack overflow where he's got

00:01:07,200 --> 00:01:12,240
a pretty high

00:01:08,320 --> 00:01:15,759
karma score as you can see um

00:01:12,240 --> 00:01:19,520
in one of his posts he called cues the

00:01:15,759 --> 00:01:24,320
secret source of c python threading

00:01:19,520 --> 00:01:24,320
um now what the hell did he mean by that

00:01:24,560 --> 00:01:28,080
before i answer that question let's go

00:01:26,240 --> 00:01:29,040
through a little background about how

00:01:28,080 --> 00:01:32,479
cues work

00:01:29,040 --> 00:01:33,520
um cues are used for communicating

00:01:32,479 --> 00:01:34,960
internally

00:01:33,520 --> 00:01:37,119
between different tasks of the

00:01:34,960 --> 00:01:37,600
application that are running at the same

00:01:37,119 --> 00:01:39,360
time

00:01:37,600 --> 00:01:41,360
without locking up the entire

00:01:39,360 --> 00:01:43,360
application waiting for messages to be

00:01:41,360 --> 00:01:46,560
sent or received

00:01:43,360 --> 00:01:46,960
so in this example here i'm using async

00:01:46,560 --> 00:01:50,079
i o

00:01:46,960 --> 00:01:50,640
cues but in synchronous land there's a

00:01:50,079 --> 00:01:52,320
similar

00:01:50,640 --> 00:01:54,399
queue primitive for communicating

00:01:52,320 --> 00:01:56,320
between threads

00:01:54,399 --> 00:01:57,759
so if you're not up to speed with the

00:01:56,320 --> 00:02:00,320
whole async io

00:01:57,759 --> 00:02:01,520
concept in this example and the ones

00:02:00,320 --> 00:02:04,479
that follow

00:02:01,520 --> 00:02:05,360
just replacing your head async io task

00:02:04,479 --> 00:02:08,879
with

00:02:05,360 --> 00:02:12,080
thread um there's also a

00:02:08,879 --> 00:02:13,520
cue concept for commuting communicating

00:02:12,080 --> 00:02:17,200
across processes

00:02:13,520 --> 00:02:19,200
um which i won't get into here

00:02:17,200 --> 00:02:21,920
um so on the left you can see we create

00:02:19,200 --> 00:02:24,640
the queue in one task

00:02:21,920 --> 00:02:25,520
that's the publisher's side and put a

00:02:24,640 --> 00:02:29,280
message

00:02:25,520 --> 00:02:30,160
in the queue hello world in python there

00:02:29,280 --> 00:02:33,040
can be many

00:02:30,160 --> 00:02:33,760
publishers to a queue but in general

00:02:33,040 --> 00:02:36,800
only one

00:02:33,760 --> 00:02:38,560
consumer of accused message out of the

00:02:36,800 --> 00:02:42,239
box

00:02:38,560 --> 00:02:44,480
um in another task in a synchro language

00:02:42,239 --> 00:02:46,560
we wait for a new message to be

00:02:44,480 --> 00:02:49,599
available on the queue

00:02:46,560 --> 00:02:52,400
so the task two co-routine

00:02:49,599 --> 00:02:53,360
which we're calling the subscriber um is

00:02:52,400 --> 00:02:56,080
blocked while

00:02:53,360 --> 00:02:58,159
waiting for a new message um but task

00:02:56,080 --> 00:03:01,680
one and any other tasks are still

00:02:58,159 --> 00:03:01,680
able to execute

00:03:02,480 --> 00:03:08,959
uh this is a photo taken at the

00:03:05,680 --> 00:03:12,720
mozilla offices uh i believe um

00:03:08,959 --> 00:03:12,720
let's do a little bit of enhancements

00:03:13,360 --> 00:03:17,120
you would think uh they of all people

00:03:16,080 --> 00:03:19,920
would know

00:03:17,120 --> 00:03:20,480
a little about the inherent dangers of

00:03:19,920 --> 00:03:23,599
writing

00:03:20,480 --> 00:03:23,599
multi-threaded code

00:03:24,319 --> 00:03:27,840
the problem with multi-threaded code is

00:03:27,040 --> 00:03:30,560
locking down

00:03:27,840 --> 00:03:32,239
mutable shared resources or resources

00:03:30,560 --> 00:03:35,519
that can only be used by

00:03:32,239 --> 00:03:38,000
one task at a time the solution

00:03:35,519 --> 00:03:40,239
normally is to serialize access to

00:03:38,000 --> 00:03:42,400
shared resources using locks

00:03:40,239 --> 00:03:43,360
preventing any other tasks using the

00:03:42,400 --> 00:03:46,000
shared resource

00:03:43,360 --> 00:03:46,879
until the current user of the resource

00:03:46,000 --> 00:03:50,640
releases

00:03:46,879 --> 00:03:52,720
the lock a common shared resource that

00:03:50,640 --> 00:03:53,360
often needs protecting is a connection

00:03:52,720 --> 00:03:56,799
object

00:03:53,360 --> 00:03:58,159
uh say from a database although modern

00:03:56,799 --> 00:04:02,879
libraries often do the

00:03:58,159 --> 00:04:02,879
heavy lifting for you uh these days

00:04:03,280 --> 00:04:06,799
but the problem with that is you have to

00:04:04,959 --> 00:04:09,040
remember to use the lock everywhere the

00:04:06,799 --> 00:04:11,040
con object is required because that con

00:04:09,040 --> 00:04:12,159
object is available to all threads at

00:04:11,040 --> 00:04:15,280
all times

00:04:12,159 --> 00:04:17,040
so the need to sprinkle locks everywhere

00:04:15,280 --> 00:04:20,079
throughout your code might be fine

00:04:17,040 --> 00:04:21,919
for smaller code bases but is

00:04:20,079 --> 00:04:24,560
fiendishly difficult to get right all

00:04:21,919 --> 00:04:25,040
the time and can lead to hard to track

00:04:24,560 --> 00:04:28,400
down

00:04:25,040 --> 00:04:29,120
bugs and deadlocks which i guess is why

00:04:28,400 --> 00:04:32,000
mozilla

00:04:29,120 --> 00:04:32,000
put that sign up

00:04:32,639 --> 00:04:36,880
you may be thinking uh what about using

00:04:34,639 --> 00:04:38,479
async ios isn't that single threaded so

00:04:36,880 --> 00:04:42,080
it gets around the problem

00:04:38,479 --> 00:04:43,919
we're done right now

00:04:42,080 --> 00:04:45,120
even though i've written it in large red

00:04:43,919 --> 00:04:48,320
font um

00:04:45,120 --> 00:04:50,880
it's actually a subtle point i think

00:04:48,320 --> 00:04:52,000
yes the async io event loop runs in one

00:04:50,880 --> 00:04:53,600
thread only

00:04:52,000 --> 00:04:56,639
and eliminates a certain class of

00:04:53,600 --> 00:04:58,400
problems uh present in multi-threading

00:04:56,639 --> 00:05:00,560
but you can still introduce race

00:04:58,400 --> 00:05:01,120
conditions uh just at the application

00:05:00,560 --> 00:05:05,120
level

00:05:01,120 --> 00:05:07,280
in asynco land very very easily

00:05:05,120 --> 00:05:09,120
but if the libraries you're using are

00:05:07,280 --> 00:05:11,199
well designed and able to hook into the

00:05:09,120 --> 00:05:12,880
event loop then yes you can just use the

00:05:11,199 --> 00:05:14,320
shared resource concurrently across

00:05:12,880 --> 00:05:17,440
multiple async

00:05:14,320 --> 00:05:20,240
tasks but even then sometimes you just

00:05:17,440 --> 00:05:21,360
you don't trust that an async io library

00:05:20,240 --> 00:05:24,639
that you're using is safe

00:05:21,360 --> 00:05:26,320
from task-based race conditions or

00:05:24,639 --> 00:05:28,080
you just want to bring some order to

00:05:26,320 --> 00:05:30,960
your async io application

00:05:28,080 --> 00:05:32,080
or sometimes you you really need or want

00:05:30,960 --> 00:05:34,880
to use

00:05:32,080 --> 00:05:37,440
a library that is not async io friendly

00:05:34,880 --> 00:05:41,120
and needs to be run in a separate thread

00:05:37,440 --> 00:05:44,080
called an executor to keep the async io

00:05:41,120 --> 00:05:44,960
event loop fast um some well-known

00:05:44,080 --> 00:05:48,639
examples

00:05:44,960 --> 00:05:53,840
uh of these libraries uh sql alchemy

00:05:48,639 --> 00:05:56,960
and and requests for example

00:05:53,840 --> 00:05:59,680
so with that in mind uh the real i guess

00:05:56,960 --> 00:06:00,880
secret source that alex was hinting at

00:05:59,680 --> 00:06:04,240
in the earlier slide

00:06:00,880 --> 00:06:05,039
is to use cues to serialize or in other

00:06:04,240 --> 00:06:08,319
words

00:06:05,039 --> 00:06:09,600
funnel requests that require the shared

00:06:08,319 --> 00:06:11,919
resource

00:06:09,600 --> 00:06:12,720
into a handler that processes the

00:06:11,919 --> 00:06:15,600
requests

00:06:12,720 --> 00:06:17,440
one by one sequentially for that shared

00:06:15,600 --> 00:06:20,000
resource

00:06:17,440 --> 00:06:22,240
the really cool thing about this example

00:06:20,000 --> 00:06:24,639
is that that dangerous con object

00:06:22,240 --> 00:06:27,120
we're calling it that can only be safely

00:06:24,639 --> 00:06:31,360
be used by one task at a time

00:06:27,120 --> 00:06:33,600
is defined inside the handle requests

00:06:31,360 --> 00:06:35,360
task which means it doesn't exist

00:06:33,600 --> 00:06:37,680
outside it which means there's zero

00:06:35,360 --> 00:06:38,880
possibility of it being used elsewhere

00:06:37,680 --> 00:06:42,560
at the same time by

00:06:38,880 --> 00:06:44,560
other tasks and causing nasty issues

00:06:42,560 --> 00:06:45,919
so you're making a request using an

00:06:44,560 --> 00:06:49,360
internal api

00:06:45,919 --> 00:06:53,440
on the left side that's that query

00:06:49,360 --> 00:06:55,440
comma fute tuple and

00:06:53,440 --> 00:06:58,400
the task of the current team is

00:06:55,440 --> 00:07:01,199
processing your request

00:06:58,400 --> 00:07:02,880
that's the handle handle requests task

00:07:01,199 --> 00:07:06,240
and returning your results

00:07:02,880 --> 00:07:07,919
so kind of like a http request response

00:07:06,240 --> 00:07:09,360
architecture that you're probably

00:07:07,919 --> 00:07:13,199
familiar with

00:07:09,360 --> 00:07:15,840
and as i said uh con is confined

00:07:13,199 --> 00:07:17,120
inside that long running handle requests

00:07:15,840 --> 00:07:20,080
black box

00:07:17,120 --> 00:07:21,520
nice and safe so this this approach

00:07:20,080 --> 00:07:24,960
generally scales better

00:07:21,520 --> 00:07:28,639
um for larger code bases that

00:07:24,960 --> 00:07:30,000
than locks and i think it's it's easier

00:07:28,639 --> 00:07:33,680
to reason about

00:07:30,000 --> 00:07:33,680
as well i hope you do too

00:07:34,720 --> 00:07:38,479
uh the next killer app of cues that i

00:07:37,599 --> 00:07:41,919
want to talk about

00:07:38,479 --> 00:07:44,720
is for internal event dispatching um

00:07:41,919 --> 00:07:46,879
so for larger asynchronous applications

00:07:44,720 --> 00:07:49,039
it can often be a really good idea to

00:07:46,879 --> 00:07:51,440
have an internal event bus

00:07:49,039 --> 00:07:52,080
where different tasks can publish events

00:07:51,440 --> 00:07:55,199
and

00:07:52,080 --> 00:07:56,800
subscribe to events an event bus is

00:07:55,199 --> 00:07:58,960
it's just a fancy name for something

00:07:56,800 --> 00:08:00,000
that sits in the middle and coordinates

00:07:58,960 --> 00:08:02,160
communication

00:08:00,000 --> 00:08:03,599
between multiple publishers and multiple

00:08:02,160 --> 00:08:05,520
subscribers

00:08:03,599 --> 00:08:07,599
it's a way of turning queues which we

00:08:05,520 --> 00:08:11,039
saw in the previous example

00:08:07,599 --> 00:08:14,479
um as a many-to-one solution

00:08:11,039 --> 00:08:18,240
out of the box into a a mini to me

00:08:14,479 --> 00:08:20,080
solution in this example we've got a

00:08:18,240 --> 00:08:23,199
queue that all the events get published

00:08:20,080 --> 00:08:27,280
to uh that's the event underscore queue

00:08:23,199 --> 00:08:30,240
thing in the middle um

00:08:27,280 --> 00:08:31,039
and the messages being published contain

00:08:30,240 --> 00:08:33,919
a color

00:08:31,039 --> 00:08:36,000
and an object of that color on the left

00:08:33,919 --> 00:08:37,839
so you can see we've got some publishers

00:08:36,000 --> 00:08:40,080
publishing red events we've got some

00:08:37,839 --> 00:08:42,000
publishers publishing green events and

00:08:40,080 --> 00:08:44,880
on the subscriber side

00:08:42,000 --> 00:08:47,519
we've got individual queues for each

00:08:44,880 --> 00:08:48,720
event type a subscriber wants to listen

00:08:47,519 --> 00:08:51,680
to

00:08:48,720 --> 00:08:53,839
so different different to the the global

00:08:51,680 --> 00:08:55,440
event

00:08:53,839 --> 00:08:57,760
uh we've got subscribers listening for

00:08:55,440 --> 00:08:58,560
red events uh green events and we've

00:08:57,760 --> 00:09:00,320
even got one

00:08:58,560 --> 00:09:02,480
subscriber that's listening for red and

00:09:00,320 --> 00:09:04,000
green events hence those those two

00:09:02,480 --> 00:09:05,600
listening cues you see there in the

00:09:04,000 --> 00:09:08,959
middle

00:09:05,600 --> 00:09:11,600
um just as as an aside as well um

00:09:08,959 --> 00:09:12,160
one of the main uh i guess complicating

00:09:11,600 --> 00:09:13,920
factors

00:09:12,160 --> 00:09:15,519
that you need to consider when using

00:09:13,920 --> 00:09:18,480
this type of architecture is that

00:09:15,519 --> 00:09:18,959
it does make debugging much harder um

00:09:18,480 --> 00:09:22,880
and

00:09:18,959 --> 00:09:25,760
the reason we is that the event bus

00:09:22,880 --> 00:09:26,399
gets in the way basically um of being to

00:09:25,760 --> 00:09:28,320
trace

00:09:26,399 --> 00:09:29,839
all the way back to the original source

00:09:28,320 --> 00:09:32,480
of the message

00:09:29,839 --> 00:09:33,920
so if a subscriber throws an exception

00:09:32,480 --> 00:09:36,480
um

00:09:33,920 --> 00:09:37,920
you you have trouble finding the

00:09:36,480 --> 00:09:40,000
originating publisher

00:09:37,920 --> 00:09:42,399
so the way around it how i normally do

00:09:40,000 --> 00:09:44,720
it is just to have really good logging

00:09:42,399 --> 00:09:46,240
of all the messages coming into the

00:09:44,720 --> 00:09:49,279
event queue and their source

00:09:46,240 --> 00:09:51,519
and all the messages going out

00:09:49,279 --> 00:09:53,120
and where where their destination is

00:09:51,519 --> 00:09:55,600
that's normally good enough but

00:09:53,120 --> 00:09:58,640
there's some other methods i can get to

00:09:55,600 --> 00:09:58,640
after the talk as well

00:09:58,880 --> 00:10:04,640
um here's a really simple implementation

00:10:02,000 --> 00:10:07,519
of an event bus

00:10:04,640 --> 00:10:09,040
um you can see i've set a long running

00:10:07,519 --> 00:10:11,200
task because it's running in a

00:10:09,040 --> 00:10:14,320
in an infinite loop and it's listening

00:10:11,200 --> 00:10:14,320
for events

00:10:14,800 --> 00:10:18,240
it's reading the event type of the

00:10:16,399 --> 00:10:21,040
message and then

00:10:18,240 --> 00:10:22,320
gets all the individual subscriber cues

00:10:21,040 --> 00:10:25,519
for that event type

00:10:22,320 --> 00:10:28,959
and simply publishes the events to

00:10:25,519 --> 00:10:31,600
each subscribe queue sequentially

00:10:28,959 --> 00:10:33,440
for graceful shutdowns we've got a

00:10:31,600 --> 00:10:35,680
sentinel message called shutdown

00:10:33,440 --> 00:10:37,440
which causes the task to break out of

00:10:35,680 --> 00:10:40,880
the loop and

00:10:37,440 --> 00:10:42,640
exit you can set it up to send that

00:10:40,880 --> 00:10:44,160
shutdown message to the event queue when

00:10:42,640 --> 00:10:47,600
the user presses

00:10:44,160 --> 00:10:50,720
ctrl c for example uh

00:10:47,600 --> 00:10:54,000
so nice graceful shutdown that's it

00:10:50,720 --> 00:10:54,720
that's that's an event bus um not too

00:10:54,000 --> 00:10:58,720
scary

00:10:54,720 --> 00:11:01,680
i hope um here's an example of how you

00:10:58,720 --> 00:11:03,279
actually publish a message to that event

00:11:01,680 --> 00:11:06,160
event queue as you can see

00:11:03,279 --> 00:11:08,000
uh the event is represented as a

00:11:06,160 --> 00:11:09,760
dictionary although i probably

00:11:08,000 --> 00:11:11,600
use an immutable data structure for

00:11:09,760 --> 00:11:14,640
peace of mind

00:11:11,600 --> 00:11:16,959
with the event name acting as uh

00:11:14,640 --> 00:11:16,959
the key

00:11:17,839 --> 00:11:21,440
on the subscriber side this is a

00:11:19,519 --> 00:11:24,399
slightly different example to the

00:11:21,440 --> 00:11:24,399
the green and red

00:11:24,800 --> 00:11:28,720
yeah we're modeling a a restaurant's

00:11:27,600 --> 00:11:31,360
kitchen

00:11:28,720 --> 00:11:33,680
that receives requests from front of

00:11:31,360 --> 00:11:37,279
house to make meals or perform

00:11:33,680 --> 00:11:37,279
other kitchen related work

00:11:37,440 --> 00:11:41,519
so as you see as you can see we've got a

00:11:40,079 --> 00:11:44,320
contact manager

00:11:41,519 --> 00:11:46,880
that returns an object with a list of

00:11:44,320 --> 00:11:50,880
subscribers that are listening for the

00:11:46,880 --> 00:11:53,519
order up or the shutdown events

00:11:50,880 --> 00:11:56,320
the context manager handles any

00:11:53,519 --> 00:11:59,920
unsubscribing or subscribing work

00:11:56,320 --> 00:12:00,320
that needs to be done now we're using

00:11:59,920 --> 00:12:03,360
this

00:12:00,320 --> 00:12:07,120
fancy async io for loop

00:12:03,360 --> 00:12:08,959
thing which allows us to loop through

00:12:07,120 --> 00:12:13,600
events as they come in

00:12:08,959 --> 00:12:13,600
without blocking the event loop

00:12:13,839 --> 00:12:18,000
the actual work being performed is just

00:12:17,120 --> 00:12:21,040
to

00:12:18,000 --> 00:12:21,040
make the secret source

00:12:21,279 --> 00:12:27,680
and to handle graceful shutdowns

00:12:25,440 --> 00:12:29,680
when the shutdown message is received or

00:12:27,680 --> 00:12:34,160
if you look above that red box

00:12:29,680 --> 00:12:37,519
i've got an 8 hours constant there

00:12:34,160 --> 00:12:38,480
either case it will break out of that

00:12:37,519 --> 00:12:41,279
loop and say

00:12:38,480 --> 00:12:42,320
kitchen is closed so that's how you

00:12:41,279 --> 00:12:45,600
handle it

00:12:42,320 --> 00:12:45,600
for graceful shutdown

00:12:46,320 --> 00:12:51,040
so that's basically uh what i wanted to

00:12:49,600 --> 00:12:54,079
talk about with cues

00:12:51,040 --> 00:12:54,720
in summary um choose a really general

00:12:54,079 --> 00:12:56,480
purpose

00:12:54,720 --> 00:12:58,480
you can use them for lots and lots of

00:12:56,480 --> 00:13:00,560
different things um

00:12:58,480 --> 00:13:01,920
mainly communicating between different

00:13:00,560 --> 00:13:04,480
concurrent activities

00:13:01,920 --> 00:13:05,040
uh which surprise surprise is basically

00:13:04,480 --> 00:13:08,160
the real

00:13:05,040 --> 00:13:11,120
the wheel world works um and yeah

00:13:08,160 --> 00:13:11,440
the two main killer apps that i want you

00:13:11,120 --> 00:13:14,399
to

00:13:11,440 --> 00:13:16,000
remember um from this talk uh

00:13:14,399 --> 00:13:19,120
serializing access

00:13:16,000 --> 00:13:22,480
to dangerous objects

00:13:19,120 --> 00:13:23,040
and and using cues to implement uh event

00:13:22,480 --> 00:13:26,720
bus

00:13:23,040 --> 00:13:28,160
uh architecture that many to want many

00:13:26,720 --> 00:13:30,720
um architecture where you've got

00:13:28,160 --> 00:13:34,480
multiple publishers and multiple

00:13:30,720 --> 00:13:36,959
subscribers so that's about it

00:13:34,480 --> 00:13:36,959
thank you

00:13:38,079 --> 00:13:41,680
awesome thank you so much jeremy um i

00:13:40,160 --> 00:13:43,000
feel like cues are one of those things

00:13:41,680 --> 00:13:44,880
that unless you do a lot of

00:13:43,000 --> 00:13:48,079
multi-processing work

00:13:44,880 --> 00:13:50,399
you forget they exist and then you

00:13:48,079 --> 00:13:51,920
end up inventing a terrible version of

00:13:50,399 --> 00:13:54,320
it yourself so

00:13:51,920 --> 00:13:56,160
for someone i've spent a lot of my time

00:13:54,320 --> 00:13:57,360
avoiding multi-processing precisely

00:13:56,160 --> 00:13:59,760
because i know it's hard

00:13:57,360 --> 00:14:00,560
and so when i do find myself doing it

00:13:59,760 --> 00:14:02,399
and find myself

00:14:00,560 --> 00:14:04,079
rediscovering cues i'm like oh thank

00:14:02,399 --> 00:14:07,440
goodness this already exists because

00:14:04,079 --> 00:14:07,839
yep yeah yeah i i only use them pretty

00:14:07,440 --> 00:14:11,120
much

00:14:07,839 --> 00:14:13,680
exclusively for insider an application

00:14:11,120 --> 00:14:15,600
or a process i never really use it for

00:14:13,680 --> 00:14:17,680
communicating between processes i

00:14:15,600 --> 00:14:20,880
typically use something like

00:14:17,680 --> 00:14:23,519
redis um for for providing that that

00:14:20,880 --> 00:14:24,639
event bus architecture in in a platform

00:14:23,519 --> 00:14:27,680
independent way

00:14:24,639 --> 00:14:31,040
um so yeah that's how i

00:14:27,680 --> 00:14:33,199
approach it thank you so much jeremy uh

00:14:31,040 --> 00:14:36,079
we now have an extended break we will be

00:14:33,199 --> 00:14:39,440
resuming at 4 p.m adelaide time

00:14:36,079 --> 00:14:42,560
uh so take a break

00:14:39,440 --> 00:14:43,440
have a couple coffees how many of you

00:14:42,560 --> 00:14:47,360
already had today

00:14:43,440 --> 00:14:55,680
um and we will see you again soon

00:14:47,360 --> 00:14:55,680

YouTube URL: https://www.youtube.com/watch?v=MB_8iZbYKi8


