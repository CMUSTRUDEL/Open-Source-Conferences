Title: "Taking Django's ORM Async" - Andrew Godwin (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Andrew Godwin

https://2020.pycon.org.au/program/SLXVBU

The quest to add "hybrid" asynchronous support to Django - where it can run both synchronous and asynchronous code - is a long one. Django 3.1 reached an important milestone with synchronous and asynchronous views, and now the next big step is to take a long, hard look at the thing that makes up over half the Django codebase: the ORM.

The ORM is gigantic, old, and complex - and has an API designed and tweaked over many years. We'll look at some of those design decisions and how they reflect in the world of async, the challenges that underlie a hybrid API, as well as how the safety-first nature of the ORM has to evolve to deal with new and exciting async ways of breaking things.

We'll also dive into what it means to have asynchronous database backends, and how support for those are progressing in the Python world - and how we're trying to ship something that's useful before fully asynchronous database APIs are done.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Fri Sep  4 17:10:00 2020 at Python 2
Captions: 
	00:00:04,160 --> 00:00:05,839
hello everyone

00:00:05,040 --> 00:00:08,240
and i hope you're having a good

00:00:05,839 --> 00:00:09,519
afternoon wherever you are now i'm very

00:00:08,240 --> 00:00:11,679
excited to get to talk to you

00:00:09,519 --> 00:00:13,360
this afternoon about django and async

00:00:11,679 --> 00:00:15,519
but first one small note

00:00:13,360 --> 00:00:17,279
um i'm doing this from the past and not

00:00:15,519 --> 00:00:18,160
just the past in terms of time zones but

00:00:17,279 --> 00:00:20,960
like the actual

00:00:18,160 --> 00:00:22,400
real actual past what this means is of

00:00:20,960 --> 00:00:24,080
course that future me

00:00:22,400 --> 00:00:25,840
is in the chat to answer your questions

00:00:24,080 --> 00:00:26,400
so you have questions anytime during the

00:00:25,840 --> 00:00:28,080
talk

00:00:26,400 --> 00:00:29,840
please pop in there and i'll try and

00:00:28,080 --> 00:00:31,359
answer the best i can if you're watching

00:00:29,840 --> 00:00:33,120
this in even more of the future

00:00:31,359 --> 00:00:34,800
on a video on youtube or some other site

00:00:33,120 --> 00:00:35,680
then unfortunately you can't quite do

00:00:34,800 --> 00:00:37,040
that but

00:00:35,680 --> 00:00:38,879
i'm sure you can find me and i always

00:00:37,040 --> 00:00:40,559
have to answer questions so with that

00:00:38,879 --> 00:00:42,399
let's get on to talking about some async

00:00:40,559 --> 00:00:44,320
and some django

00:00:42,399 --> 00:00:46,160
now before i dive straight into talking

00:00:44,320 --> 00:00:47,520
about django and async and the rm

00:00:46,160 --> 00:00:48,879
because it's all very exciting

00:00:47,520 --> 00:00:51,120
let's start with a little bit about me

00:00:48,879 --> 00:00:53,039
first so for those who don't know me

00:00:51,120 --> 00:00:54,480
i'm andrew goblin i have been a django

00:00:53,039 --> 00:00:57,120
core developer for

00:00:54,480 --> 00:00:58,559
let's just say quite a while and in that

00:00:57,120 --> 00:01:00,160
time i've done a few different projects

00:00:58,559 --> 00:01:00,640
but probably the most notable ones are

00:01:00,160 --> 00:01:03,039
south

00:01:00,640 --> 00:01:04,000
and then it's sort of successor django

00:01:03,039 --> 00:01:05,360
migrations

00:01:04,000 --> 00:01:07,119
and then of course most recently a lot

00:01:05,360 --> 00:01:09,520
of work on async django

00:01:07,119 --> 00:01:10,159
now uh one small fact is i'm not

00:01:09,520 --> 00:01:12,159
currently

00:01:10,159 --> 00:01:13,680
and unfortunately in australia i am

00:01:12,159 --> 00:01:15,520
instead in the wonderful world

00:01:13,680 --> 00:01:17,360
of colorado in particular in denver

00:01:15,520 --> 00:01:19,119
colorado at some point

00:01:17,360 --> 00:01:20,880
when you can get here i encourage you

00:01:19,119 --> 00:01:21,759
all to come visit it's a beautiful place

00:01:20,880 --> 00:01:23,840
full of mountains

00:01:21,759 --> 00:01:25,439
and it has distinctly less animals that

00:01:23,840 --> 00:01:27,920
can kill you than australia

00:01:25,439 --> 00:01:29,119
but until then we have to just be

00:01:27,920 --> 00:01:32,240
content with what we have

00:01:29,119 --> 00:01:33,200
uh where we are now so let's talk first

00:01:32,240 --> 00:01:34,560
about the good news

00:01:33,200 --> 00:01:36,479
in case you missed it with everything

00:01:34,560 --> 00:01:38,960
that's going on async views

00:01:36,479 --> 00:01:40,560
have been released django 31 is out you

00:01:38,960 --> 00:01:43,360
can download it use it today

00:01:40,560 --> 00:01:44,240
and in django31 you can just simply do

00:01:43,360 --> 00:01:46,240
async def

00:01:44,240 --> 00:01:48,000
in front of a view rather than def and

00:01:46,240 --> 00:01:49,920
bam you have an async view

00:01:48,000 --> 00:01:51,680
now this is the result of a large amount

00:01:49,920 --> 00:01:53,920
of very complex and

00:01:51,680 --> 00:01:55,280
interwoven work i have some previous

00:01:53,920 --> 00:01:56,719
talks including some from previous

00:01:55,280 --> 00:01:58,479
python ius you can

00:01:56,719 --> 00:02:00,159
go and look at to learn about that kind

00:01:58,479 --> 00:02:02,719
of stuff but essentially

00:02:00,159 --> 00:02:03,439
it is to you the end user reasonably

00:02:02,719 --> 00:02:05,200
simple

00:02:03,439 --> 00:02:06,840
and so my hope is like that's the good

00:02:05,200 --> 00:02:09,920
first stepping stone

00:02:06,840 --> 00:02:10,399
into a more async friendly django and

00:02:09,920 --> 00:02:11,760
one thing to

00:02:10,399 --> 00:02:13,920
say up front here is that i've always

00:02:11,760 --> 00:02:14,959
said that the goal is not to make django

00:02:13,920 --> 00:02:16,560
async only

00:02:14,959 --> 00:02:18,560
the goal is to make django the place to

00:02:16,560 --> 00:02:19,360
have like a hybrid async world where you

00:02:18,560 --> 00:02:20,879
can have

00:02:19,360 --> 00:02:22,800
most of the code synchronous because

00:02:20,879 --> 00:02:24,319
honestly it's easier and often

00:02:22,800 --> 00:02:25,760
it's perfectly good enough for what you

00:02:24,319 --> 00:02:27,120
need and then just the performance

00:02:25,760 --> 00:02:29,200
critical bits or the things that do lots

00:02:27,120 --> 00:02:30,800
of i o waiting can be in asic mode

00:02:29,200 --> 00:02:32,800
so the goal has always been a hybrid

00:02:30,800 --> 00:02:34,239
jangle that does both and async fuse are

00:02:32,800 --> 00:02:36,879
a perfect example of that

00:02:34,239 --> 00:02:37,760
you can do an async def next to a normal

00:02:36,879 --> 00:02:39,760
synchronous def

00:02:37,760 --> 00:02:41,760
for views put them in the same url's pi

00:02:39,760 --> 00:02:43,519
file they serve off either synchronous

00:02:41,760 --> 00:02:43,920
asynchronous servers with some caveats

00:02:43,519 --> 00:02:45,840
in

00:02:43,920 --> 00:02:47,280
the asynchronous on synchronous server

00:02:45,840 --> 00:02:49,040
case but generally

00:02:47,280 --> 00:02:50,319
it just goes pretty well it's kind of

00:02:49,040 --> 00:02:50,959
i'm really pleased with how it turned

00:02:50,319 --> 00:02:52,560
out

00:02:50,959 --> 00:02:53,680
and interestingly one of the very first

00:02:52,560 --> 00:02:55,760
things when i started talking about all

00:02:53,680 --> 00:02:57,599
this asian stuff in django about

00:02:55,760 --> 00:02:59,440
let's say four or five years ago

00:02:57,599 --> 00:03:01,280
probably um i think it was a djangocon

00:02:59,440 --> 00:03:03,440
us but don't quote me on that

00:03:01,280 --> 00:03:04,480
was the ordering like this was always a

00:03:03,440 --> 00:03:06,159
big project

00:03:04,480 --> 00:03:07,599
taking django async was always going to

00:03:06,159 --> 00:03:09,200
be difficult and so

00:03:07,599 --> 00:03:10,800
even back then i had broken it down to

00:03:09,200 --> 00:03:13,440
three different phases

00:03:10,800 --> 00:03:13,840
the first phase was basically developing

00:03:13,440 --> 00:03:16,080
and

00:03:13,840 --> 00:03:17,599
constructing a way for janga to run on

00:03:16,080 --> 00:03:18,400
some kind of native asynchronous

00:03:17,599 --> 00:03:20,480
platform

00:03:18,400 --> 00:03:21,680
that was asgi it evolved from the

00:03:20,480 --> 00:03:23,519
channels project

00:03:21,680 --> 00:03:25,200
and that basically came around in

00:03:23,519 --> 00:03:26,640
january 3.0

00:03:25,200 --> 00:03:28,640
it wasn't very useful by itself it was

00:03:26,640 --> 00:03:30,000
more of a foundational thing but lots of

00:03:28,640 --> 00:03:31,040
hidden things you didn't see were

00:03:30,000 --> 00:03:33,840
included in django

00:03:31,040 --> 00:03:35,599
zero for example things like uh async

00:03:33,840 --> 00:03:36,159
safety for the orm was built in from the

00:03:35,599 --> 00:03:37,840
start

00:03:36,159 --> 00:03:39,680
things like the ability for there to be

00:03:37,840 --> 00:03:41,280
more than one uh handler there's a

00:03:39,680 --> 00:03:43,040
whiskey handler and an ascii handler

00:03:41,280 --> 00:03:44,720
all that kind of like ground laying

00:03:43,040 --> 00:03:47,360
stuff that we need later on

00:03:44,720 --> 00:03:49,680
and then of course phase two async views

00:03:47,360 --> 00:03:50,720
was made manifest in django 3.1 and is

00:03:49,680 --> 00:03:53,360
now released

00:03:50,720 --> 00:03:55,280
and so those first two phases honestly

00:03:53,360 --> 00:03:57,280
worked pretty much as i planned them

00:03:55,280 --> 00:03:58,959
there were many missteps along the way

00:03:57,280 --> 00:04:00,480
and i didn't do things quite the way i'd

00:03:58,959 --> 00:04:02,400
want to in many cases

00:04:00,480 --> 00:04:03,920
but they ended up looking and feeling

00:04:02,400 --> 00:04:05,120
the way i kind of intended them to and

00:04:03,920 --> 00:04:08,080
that's the point

00:04:05,120 --> 00:04:09,760
and so now we find ourselves facing down

00:04:08,080 --> 00:04:11,840
the precipice of phase three

00:04:09,760 --> 00:04:13,519
and in some ways it's kind of unfair to

00:04:11,840 --> 00:04:15,599
call these one two and three

00:04:13,519 --> 00:04:16,959
because it implies equal weighting and

00:04:15,599 --> 00:04:18,799
that's really not the case when you come

00:04:16,959 --> 00:04:22,400
to these three things

00:04:18,799 --> 00:04:23,680
the rm is honestly most of django this

00:04:22,400 --> 00:04:25,120
is true by lines of code

00:04:23,680 --> 00:04:27,199
it's certainly true by complexity and

00:04:25,120 --> 00:04:28,960
understanding it is a big

00:04:27,199 --> 00:04:30,320
hairy beast sitting in the center of

00:04:28,960 --> 00:04:32,720
what we know and love

00:04:30,320 --> 00:04:34,560
and having to dive into it and add

00:04:32,720 --> 00:04:37,520
asynchronous support

00:04:34,560 --> 00:04:39,360
that is no small task in itself it's

00:04:37,520 --> 00:04:41,520
kind of a reason why i've always put off

00:04:39,360 --> 00:04:42,639
orm until like this last well not the

00:04:41,520 --> 00:04:44,479
last but this

00:04:42,639 --> 00:04:46,400
this part of the project after the view

00:04:44,479 --> 00:04:47,040
stuff first of course was the fact that

00:04:46,400 --> 00:04:48,720
like

00:04:47,040 --> 00:04:50,960
having an async go around without acing

00:04:48,720 --> 00:04:51,759
views would be kind of pointless let's

00:04:50,960 --> 00:04:52,960
be real

00:04:51,759 --> 00:04:55,280
but the other part is that like it's

00:04:52,960 --> 00:04:55,680
just a lot of work and i need to get my

00:04:55,280 --> 00:04:57,600
own

00:04:55,680 --> 00:04:59,360
async abilities and skills up as part of

00:04:57,600 --> 00:05:00,560
that process and i also needed to make

00:04:59,360 --> 00:05:01,919
sure that like

00:05:00,560 --> 00:05:03,600
things were developing the community's

00:05:01,919 --> 00:05:04,960
going forward like async is still pretty

00:05:03,600 --> 00:05:06,000
young in python's history

00:05:04,960 --> 00:05:07,759
so we need to make sure that stuff is

00:05:06,000 --> 00:05:09,440
all in the right place and fortunately

00:05:07,759 --> 00:05:11,520
now i think it is

00:05:09,440 --> 00:05:13,199
so let's talk about what it takes to go

00:05:11,520 --> 00:05:15,840
into the rm and change stuff

00:05:13,199 --> 00:05:16,720
and first and foremost is django's api

00:05:15,840 --> 00:05:19,360
design

00:05:16,720 --> 00:05:20,320
now i have long been a problem proponent

00:05:19,360 --> 00:05:22,880
of like

00:05:20,320 --> 00:05:24,000
what makes django is the way we design

00:05:22,880 --> 00:05:26,160
apis

00:05:24,000 --> 00:05:27,759
for the developer in a hurry who wants

00:05:26,160 --> 00:05:29,360
to have things work safely

00:05:27,759 --> 00:05:30,880
it's always been one of the the bywords

00:05:29,360 --> 00:05:32,240
of django that if you just do things the

00:05:30,880 --> 00:05:33,600
default way we suggest

00:05:32,240 --> 00:05:35,919
they generally come out working pretty

00:05:33,600 --> 00:05:37,759
well pretty stable and with very very

00:05:35,919 --> 00:05:40,320
few security holes

00:05:37,759 --> 00:05:41,039
that's kind of the idea behind jang is

00:05:40,320 --> 00:05:43,360
that like

00:05:41,039 --> 00:05:44,880
as you get bigger as your site grows and

00:05:43,360 --> 00:05:46,479
i've worked for many sites to do this

00:05:44,880 --> 00:05:48,160
you can just remove parts of django and

00:05:46,479 --> 00:05:50,800
replace them as you see fit

00:05:48,160 --> 00:05:52,639
but the the ghost the spirit of django

00:05:50,800 --> 00:05:54,320
still remains the idea that like

00:05:52,639 --> 00:05:55,759
that layout and the idea you can remove

00:05:54,320 --> 00:05:56,720
pieces progressively and have them all

00:05:55,759 --> 00:05:58,240
work properly

00:05:56,720 --> 00:06:00,080
that's still there that's what i love

00:05:58,240 --> 00:06:00,800
about it and part of that honestly most

00:06:00,080 --> 00:06:03,759
of that

00:06:00,800 --> 00:06:05,280
is in the api design so let's look at

00:06:03,759 --> 00:06:06,400
some of the features of the django orm

00:06:05,280 --> 00:06:07,520
that you probably all know and are

00:06:06,400 --> 00:06:10,479
familiar with

00:06:07,520 --> 00:06:11,120
that when you come to async they end up

00:06:10,479 --> 00:06:12,880
being

00:06:11,120 --> 00:06:14,400
just a little bit different and in most

00:06:12,880 --> 00:06:15,919
cases we can get around it but

00:06:14,400 --> 00:06:18,080
i want you to sort of appreciate some of

00:06:15,919 --> 00:06:19,039
the difficulties in the way that the

00:06:18,080 --> 00:06:20,960
async

00:06:19,039 --> 00:06:22,479
extensions were added onto python as a

00:06:20,960 --> 00:06:24,080
language design

00:06:22,479 --> 00:06:26,479
the implications those give us for

00:06:24,080 --> 00:06:28,720
django and how we design the arm

00:06:26,479 --> 00:06:30,319
so when you come to async there's a

00:06:28,720 --> 00:06:31,520
couple of key caveats

00:06:30,319 --> 00:06:33,440
and i think the biggest one i've called

00:06:31,520 --> 00:06:34,880
this up before for async views is that

00:06:33,440 --> 00:06:36,080
when you look at a function or a

00:06:34,880 --> 00:06:38,080
callable

00:06:36,080 --> 00:06:40,400
you can't tell if it returns a co

00:06:38,080 --> 00:06:42,000
routine the way python chose to do async

00:06:40,400 --> 00:06:42,960
is rather having a separate function

00:06:42,000 --> 00:06:46,000
callable type

00:06:42,960 --> 00:06:47,600
instead it has it says that a

00:06:46,000 --> 00:06:49,440
asynchronous co-routine function is a

00:06:47,600 --> 00:06:50,880
function that returns a curating object

00:06:49,440 --> 00:06:52,319
if you use generators and the yield

00:06:50,880 --> 00:06:53,919
keyword is very familiar this is why

00:06:52,319 --> 00:06:54,960
python chord shows it's a very sensible

00:06:53,919 --> 00:06:56,560
move in that respect

00:06:54,960 --> 00:06:58,319
and in fact async was based off

00:06:56,560 --> 00:07:00,560
generators originally

00:06:58,319 --> 00:07:01,360
now the problem with this is that of

00:07:00,560 --> 00:07:02,880
course everything everything's a

00:07:01,360 --> 00:07:05,919
callable everything's a function

00:07:02,880 --> 00:07:07,199
uh if it is written as async def uh in

00:07:05,919 --> 00:07:08,800
the actual source code

00:07:07,199 --> 00:07:10,240
then there's a special flag set on it

00:07:08,800 --> 00:07:11,919
that says oh yes this function object

00:07:10,240 --> 00:07:13,759
actually is a co-routine function

00:07:11,919 --> 00:07:15,360
and there's a thing called isco routine

00:07:13,759 --> 00:07:17,120
function in asynchronous that will tell

00:07:15,360 --> 00:07:18,000
you this but that's not true of all

00:07:17,120 --> 00:07:19,759
functions

00:07:18,000 --> 00:07:21,360
if you just write a standard def

00:07:19,759 --> 00:07:22,639
function that returns a co routine

00:07:21,360 --> 00:07:24,080
that's still a fairly good routine

00:07:22,639 --> 00:07:25,039
function that we should do async things

00:07:24,080 --> 00:07:26,240
with

00:07:25,039 --> 00:07:28,240
but we can't tell it's one from the

00:07:26,240 --> 00:07:29,360
outside it's like you know here on

00:07:28,240 --> 00:07:31,440
screen right now

00:07:29,360 --> 00:07:32,400
these are both perfectly valid coating

00:07:31,440 --> 00:07:34,639
functions

00:07:32,400 --> 00:07:35,680
they essentially return the same kind of

00:07:34,639 --> 00:07:37,039
thing

00:07:35,680 --> 00:07:39,039
but one of them you can tell from the

00:07:37,039 --> 00:07:40,400
outside before you run it what it does

00:07:39,039 --> 00:07:42,080
and the other one you can't tell from

00:07:40,400 --> 00:07:43,759
the outside what it does and

00:07:42,080 --> 00:07:46,000
what comes down to at the end of this is

00:07:43,759 --> 00:07:48,240
that pisces um python doesn't have

00:07:46,000 --> 00:07:50,000
a separate call an async call method it

00:07:48,240 --> 00:07:52,319
just has a call method

00:07:50,000 --> 00:07:54,160
so what this means is as a function on

00:07:52,319 --> 00:07:56,240
the other end of that contract

00:07:54,160 --> 00:07:57,759
you don't know if the thing calling you

00:07:56,240 --> 00:07:59,520
is expecting a co routine back because

00:07:57,759 --> 00:08:01,360
it's in like an asynchronous context

00:07:59,520 --> 00:08:02,560
or if it's just a sort of normal old

00:08:01,360 --> 00:08:04,080
python function that wants a normal

00:08:02,560 --> 00:08:06,160
synchronous result

00:08:04,080 --> 00:08:08,000
and so what this means is you can't have

00:08:06,160 --> 00:08:10,400
one function that does two things

00:08:08,000 --> 00:08:11,280
so you have to name space every function

00:08:10,400 --> 00:08:13,199
you're providing

00:08:11,280 --> 00:08:14,720
to have both a synchronous and an

00:08:13,199 --> 00:08:16,400
asynchronous variant

00:08:14,720 --> 00:08:19,120
let's take a look at example at the get

00:08:16,400 --> 00:08:21,520
method on managers in the orm

00:08:19,120 --> 00:08:22,400
now i would love to be able to say oh

00:08:21,520 --> 00:08:24,960
await

00:08:22,400 --> 00:08:25,440
model objects get id but we can't do

00:08:24,960 --> 00:08:27,199
that

00:08:25,440 --> 00:08:28,720
because the get method has to only be

00:08:27,199 --> 00:08:29,919
one of synchronous asynchronous and of

00:08:28,720 --> 00:08:30,639
course we're not going to break anything

00:08:29,919 --> 00:08:32,959
here

00:08:30,639 --> 00:08:34,719
so instead we have to name space it now

00:08:32,959 --> 00:08:36,640
this particular name spacing is

00:08:34,719 --> 00:08:38,000
shall we say pending we're still not

00:08:36,640 --> 00:08:39,839
quite sure how to separate out properly

00:08:38,000 --> 00:08:41,279
it might be dot a it might have like get

00:08:39,839 --> 00:08:42,959
underscore async

00:08:41,279 --> 00:08:44,399
whatever this ends up being it will be

00:08:42,959 --> 00:08:45,600
something like this but the idea is that

00:08:44,399 --> 00:08:47,440
the async variants

00:08:45,600 --> 00:08:48,959
will be named differently and you will

00:08:47,440 --> 00:08:50,399
have to access them differently

00:08:48,959 --> 00:08:52,320
this is just something thrust upon us by

00:08:50,399 --> 00:08:54,480
the way python's async is designed

00:08:52,320 --> 00:08:56,160
it's there's a trade-off like it's a

00:08:54,480 --> 00:08:58,080
good design in many ways

00:08:56,160 --> 00:08:59,440
this is the unfortunate one of the few

00:08:58,080 --> 00:09:00,959
unfortunate cons from it

00:08:59,440 --> 00:09:02,880
so this is what we get in terms of

00:09:00,959 --> 00:09:04,720
functions this is not too bad in many

00:09:02,880 --> 00:09:06,160
ways i do like this because it means

00:09:04,720 --> 00:09:08,080
if you are calling an asynchronous

00:09:06,160 --> 00:09:09,279
variant you can read through a code and

00:09:08,080 --> 00:09:11,279
make sure that yes we're definitely

00:09:09,279 --> 00:09:12,959
calling all the async functions

00:09:11,279 --> 00:09:14,800
because the other kind of weird side

00:09:12,959 --> 00:09:16,160
effect of python is that if you call a

00:09:14,800 --> 00:09:19,200
synchronous function

00:09:16,160 --> 00:09:21,120
in an asynchronous context by mistake

00:09:19,200 --> 00:09:22,320
then it just runs and it runs really

00:09:21,120 --> 00:09:23,680
slow and blocks your whole process but

00:09:22,320 --> 00:09:25,040
it doesn't throw an error

00:09:23,680 --> 00:09:27,200
and so it's actually quite nice have an

00:09:25,040 --> 00:09:28,959
extra safety barrier of oh these are the

00:09:27,200 --> 00:09:30,560
definite separate asynchronous functions

00:09:28,959 --> 00:09:31,920
that definitely aren't going to block

00:09:30,560 --> 00:09:33,920
because the failure mode of calling

00:09:31,920 --> 00:09:35,839
synchronous stuff is your website gets

00:09:33,920 --> 00:09:38,480
mysteriously slower no one knows why

00:09:35,839 --> 00:09:40,320
until someone finally goes

00:09:38,480 --> 00:09:41,600
somewhere even this function you've

00:09:40,320 --> 00:09:42,800
called get the wrong way

00:09:41,600 --> 00:09:45,279
so that's one of the sort of trade-offs

00:09:42,800 --> 00:09:45,600
you have to deal with now the other main

00:09:45,279 --> 00:09:47,600
one

00:09:45,600 --> 00:09:49,440
and this is maybe the biggest blow in

00:09:47,600 --> 00:09:51,839
some ways the django's design

00:09:49,440 --> 00:09:52,720
is you can't do asynchronous attribute

00:09:51,839 --> 00:09:54,880
access

00:09:52,720 --> 00:09:56,560
now if you're not familiar um in python

00:09:54,880 --> 00:09:58,240
you can overwrite objects

00:09:56,560 --> 00:10:00,560
so that the attribute access when you do

00:09:58,240 --> 00:10:01,360
dot name is run through a custom

00:10:00,560 --> 00:10:03,200
function

00:10:01,360 --> 00:10:04,959
this is what django does for a lot of

00:10:03,200 --> 00:10:06,640
its fields on models

00:10:04,959 --> 00:10:08,880
in particular when you have a foreign

00:10:06,640 --> 00:10:10,959
key field on a model

00:10:08,880 --> 00:10:12,640
if you haven't loaded it when you do dot

00:10:10,959 --> 00:10:14,480
foreign key dot name

00:10:12,640 --> 00:10:16,560
in the background django will quickly go

00:10:14,480 --> 00:10:18,320
oh and go and talk the database

00:10:16,560 --> 00:10:20,399
query that thing for you as a single get

00:10:18,320 --> 00:10:20,959
query pull it back load the object into

00:10:20,399 --> 00:10:22,399
memory

00:10:20,959 --> 00:10:24,079
and then serve you the result of that

00:10:22,399 --> 00:10:26,000
object now of course

00:10:24,079 --> 00:10:27,920
the thing with async is we're not

00:10:26,000 --> 00:10:31,120
allowed to do any io

00:10:27,920 --> 00:10:34,079
outside of asynchronous context and

00:10:31,120 --> 00:10:35,760
we can't do actual access asynchronously

00:10:34,079 --> 00:10:37,360
so what that means is

00:10:35,760 --> 00:10:39,120
we are not allowed to do that background

00:10:37,360 --> 00:10:39,839
database fetch in an asynchronous mode

00:10:39,120 --> 00:10:42,079
because

00:10:39,839 --> 00:10:43,120
if you did dot name or so dot foreign

00:10:42,079 --> 00:10:45,200
key dot name

00:10:43,120 --> 00:10:46,160
in asynchronous context and we left the

00:10:45,200 --> 00:10:48,240
old synchronous code

00:10:46,160 --> 00:10:49,920
in django would again block the whole

00:10:48,240 --> 00:10:50,560
process run a synchronous query pull it

00:10:49,920 --> 00:10:54,399
back

00:10:50,560 --> 00:10:56,880
and that's not what you want so

00:10:54,399 --> 00:10:58,240
this stung me for a while but then one

00:10:56,880 --> 00:10:59,680
of the nice things is

00:10:58,240 --> 00:11:02,000
you probably shouldn't be doing this

00:10:59,680 --> 00:11:05,040
anyway and so

00:11:02,000 --> 00:11:05,600
if you do a query like this again async

00:11:05,040 --> 00:11:07,519
get

00:11:05,600 --> 00:11:08,720
function it like the way this is written

00:11:07,519 --> 00:11:10,160
is you know still

00:11:08,720 --> 00:11:12,000
uh being decided but imagine it was

00:11:10,160 --> 00:11:15,040
written like this um

00:11:12,000 --> 00:11:16,640
this would error uh basically

00:11:15,040 --> 00:11:18,880
if you are trying to access a foreign

00:11:16,640 --> 00:11:20,880
key you didn't fetch um in future

00:11:18,880 --> 00:11:22,720
if you are in async mode and only in

00:11:20,880 --> 00:11:23,600
async mode django will throw an error

00:11:22,720 --> 00:11:26,240
saying hey

00:11:23,600 --> 00:11:27,120
you can't do implicit access during

00:11:26,240 --> 00:11:28,880
async mode

00:11:27,120 --> 00:11:30,800
please use select related because what

00:11:28,880 --> 00:11:32,480
you can do is you can do this

00:11:30,800 --> 00:11:34,800
and honestly you probably should be

00:11:32,480 --> 00:11:36,320
doing this there are very few edge cases

00:11:34,800 --> 00:11:37,200
where you don't want to select related

00:11:36,320 --> 00:11:39,120
on a query

00:11:37,200 --> 00:11:41,279
where you're pulling foreign keys so in

00:11:39,120 --> 00:11:43,040
many ways this isn't too much of a

00:11:41,279 --> 00:11:45,120
problem to have because we're kind of

00:11:43,040 --> 00:11:47,040
encouraging the right thing to do anyway

00:11:45,120 --> 00:11:48,560
now of course we'll still allow

00:11:47,040 --> 00:11:49,760
attribute access and synchronous mode

00:11:48,560 --> 00:11:51,360
will work perfectly fine

00:11:49,760 --> 00:11:53,680
we can tell inside functions what mode

00:11:51,360 --> 00:11:55,839
the outside is in at least

00:11:53,680 --> 00:11:56,959
but in asynchronous mode you'll kind of

00:11:55,839 --> 00:11:59,040
have to select related

00:11:56,959 --> 00:12:00,720
there are some very very like terminal

00:11:59,040 --> 00:12:01,440
edge cases where the django rrm and

00:12:00,720 --> 00:12:03,519
query logic

00:12:01,440 --> 00:12:04,800
doesn't handle separated right and for

00:12:03,519 --> 00:12:06,079
those i apologize

00:12:04,800 --> 00:12:07,760
you may eventually have to break out and

00:12:06,079 --> 00:12:08,320
do your own separate query inside a for

00:12:07,760 --> 00:12:11,760
loop

00:12:08,320 --> 00:12:12,720
but for 95 of all cases i think you'll

00:12:11,760 --> 00:12:14,160
find that

00:12:12,720 --> 00:12:16,000
being forced to sleep related is

00:12:14,160 --> 00:12:17,120
probably a good thing and in fact i'm

00:12:16,000 --> 00:12:18,880
almost tempted to have this option we

00:12:17,120 --> 00:12:21,600
can just turn on all the time where

00:12:18,880 --> 00:12:22,240
django just doesn't let you use non uh

00:12:21,600 --> 00:12:24,480
doesn't use

00:12:22,240 --> 00:12:26,320
implicit active access at all you always

00:12:24,480 --> 00:12:27,600
have to use that related because

00:12:26,320 --> 00:12:30,480
i can think of several projects i've

00:12:27,600 --> 00:12:32,880
worked on where i have made that mistake

00:12:30,480 --> 00:12:33,920
no no number of times like just a huge

00:12:32,880 --> 00:12:36,240
amount of times

00:12:33,920 --> 00:12:38,639
and pulled up django debug toolbar and

00:12:36,240 --> 00:12:39,519
said why are there 400 queries oh i

00:12:38,639 --> 00:12:41,920
forgot to

00:12:39,519 --> 00:12:42,959
i'm doing the query inside the loop so

00:12:41,920 --> 00:12:44,079
that's kind of the thing we're going for

00:12:42,959 --> 00:12:46,160
there

00:12:44,079 --> 00:12:47,680
so that's kind of the bad stuff and

00:12:46,160 --> 00:12:49,440
let's go on to the good stuff

00:12:47,680 --> 00:12:51,040
so some of the nice things are there are

00:12:49,440 --> 00:12:52,959
nice analogues of some of the things

00:12:51,040 --> 00:12:55,040
we're used to in synchronous world

00:12:52,959 --> 00:12:56,079
in the asynchronous world maybe my

00:12:55,040 --> 00:12:59,680
favorite one of these

00:12:56,079 --> 00:13:01,760
is iteration now when you call for

00:12:59,680 --> 00:13:03,360
or any other sort of iteration

00:13:01,760 --> 00:13:05,279
primitives in python on

00:13:03,360 --> 00:13:06,880
an object it again looks for a special

00:13:05,279 --> 00:13:07,760
method in this case double underscore

00:13:06,880 --> 00:13:09,440
ita

00:13:07,760 --> 00:13:10,560
and the nice thing is there's an async

00:13:09,440 --> 00:13:11,040
version of this called double elements

00:13:10,560 --> 00:13:13,760
called a

00:13:11,040 --> 00:13:14,800
iter and so on query sets which of

00:13:13,760 --> 00:13:16,160
course is

00:13:14,800 --> 00:13:18,720
most of the things you're iterating over

00:13:16,160 --> 00:13:20,560
in the rm we can supply both

00:13:18,720 --> 00:13:22,160
and when you do async 4 which is the

00:13:20,560 --> 00:13:24,240
async version of 4

00:13:22,160 --> 00:13:25,200
it can call the a it's a method rather

00:13:24,240 --> 00:13:26,959
than the it's a method

00:13:25,200 --> 00:13:29,200
and we can give you that lovely full

00:13:26,959 --> 00:13:31,120
asynchronous path database

00:13:29,200 --> 00:13:33,040
and not block the process so what this

00:13:31,120 --> 00:13:33,440
means is if you're writing asynchronous

00:13:33,040 --> 00:13:35,519
code

00:13:33,440 --> 00:13:37,200
again you can just basically take your

00:13:35,519 --> 00:13:38,720
synchronous for loop

00:13:37,200 --> 00:13:40,320
make sure you put select latest in the

00:13:38,720 --> 00:13:42,320
main main query

00:13:40,320 --> 00:13:44,079
and then change forward to async 4 and

00:13:42,320 --> 00:13:45,040
generally it mostly works like you want

00:13:44,079 --> 00:13:46,959
and this is one of the really nice

00:13:45,040 --> 00:13:48,000
features there's other things like async

00:13:46,959 --> 00:13:50,160
with and other things like that

00:13:48,000 --> 00:13:51,920
too but this is maybe the most important

00:13:50,160 --> 00:13:53,920
one for the orm

00:13:51,920 --> 00:13:55,440
because thinking about like again api

00:13:53,920 --> 00:13:56,000
design is crucial right we want to make

00:13:55,440 --> 00:13:57,680
sure that

00:13:56,000 --> 00:13:59,920
the api is designed in a way that people

00:13:57,680 --> 00:14:02,399
appreciate this is part of that

00:13:59,920 --> 00:14:03,120
and so i think it's really nice to have

00:14:02,399 --> 00:14:05,040
the core like

00:14:03,120 --> 00:14:07,120
looping through iteration part of django

00:14:05,040 --> 00:14:08,639
be honestly pretty similar between both

00:14:07,120 --> 00:14:10,959
worlds

00:14:08,639 --> 00:14:12,160
so let's talk a bit about the plan to

00:14:10,959 --> 00:14:14,399
make all this work

00:14:12,160 --> 00:14:15,440
and at the top of this i want to put big

00:14:14,399 --> 00:14:18,480
disclaimer

00:14:15,440 --> 00:14:20,399
this is a plan we

00:14:18,480 --> 00:14:22,079
i mean i and a few others have started

00:14:20,399 --> 00:14:23,600
like roughly planning this

00:14:22,079 --> 00:14:25,680
not much code at all been written yet

00:14:23,600 --> 00:14:28,160
certainly none of it's been committed

00:14:25,680 --> 00:14:30,000
this is all started to change but this

00:14:28,160 --> 00:14:31,839
is kind of based on what i've been

00:14:30,000 --> 00:14:33,760
poking around with what i think the best

00:14:31,839 --> 00:14:36,079
path forward is

00:14:33,760 --> 00:14:37,279
so again let's look at some phases you

00:14:36,079 --> 00:14:38,639
can tell i've been doing

00:14:37,279 --> 00:14:40,880
principal engineering for too long i now

00:14:38,639 --> 00:14:42,880
do project planning in phases

00:14:40,880 --> 00:14:45,440
three phases here again too the first

00:14:42,880 --> 00:14:47,199
one is to have an asynchronous model api

00:14:45,440 --> 00:14:48,800
so in my opinion the key thing is to get

00:14:47,199 --> 00:14:50,639
the api design locked down

00:14:48,800 --> 00:14:52,240
so you can start writing apps using it

00:14:50,639 --> 00:14:54,560
even if behind the scenes you'll see in

00:14:52,240 --> 00:14:57,040
a second is not quite the same

00:14:54,560 --> 00:14:58,160
as being pure async the idea is that if

00:14:57,040 --> 00:14:59,760
you have async code

00:14:58,160 --> 00:15:01,279
that you can write async views with

00:14:59,760 --> 00:15:02,959
asynchronou accessing them and it all

00:15:01,279 --> 00:15:04,720
looks and works nicely and crucially

00:15:02,959 --> 00:15:07,760
is safe we'll get all the safety in a

00:15:04,720 --> 00:15:09,279
bit later transactions especially

00:15:07,760 --> 00:15:11,279
secondly once we make that sort of top

00:15:09,279 --> 00:15:12,240
level async friendly we then go into the

00:15:11,279 --> 00:15:14,639
sort of the core

00:15:12,240 --> 00:15:16,160
guts of the django rm which is the query

00:15:14,639 --> 00:15:16,959
internals and the compiler and other

00:15:16,160 --> 00:15:18,880
things like that

00:15:16,959 --> 00:15:20,160
we make those async friendly now the

00:15:18,880 --> 00:15:22,480
nice thing is a lot of that stuff

00:15:20,160 --> 00:15:24,720
is cpu bad like the compiler doesn't

00:15:22,480 --> 00:15:26,959
need to be told much about acing at all

00:15:24,720 --> 00:15:27,839
mostly it's the path through the query

00:15:26,959 --> 00:15:29,440
from the query set

00:15:27,839 --> 00:15:30,959
into the connection that needs to be

00:15:29,440 --> 00:15:32,079
made async i'll show you a diagram in a

00:15:30,959 --> 00:15:34,240
second of that

00:15:32,079 --> 00:15:36,480
and then finally once we've made so that

00:15:34,240 --> 00:15:38,560
that top part uh all asynchronous

00:15:36,480 --> 00:15:39,759
we then have the database adapters now

00:15:38,560 --> 00:15:41,360
as you'll see in a bit

00:15:39,759 --> 00:15:43,279
we don't have to make those asynchronous

00:15:41,360 --> 00:15:45,519
but if you want the best performance

00:15:43,279 --> 00:15:46,959
and some databases already support this

00:15:45,519 --> 00:15:48,160
you do want native

00:15:46,959 --> 00:15:50,160
asynchronous performance at your

00:15:48,160 --> 00:15:51,120
database layer as well so let's diagram

00:15:50,160 --> 00:15:53,360
how this looks

00:15:51,120 --> 00:15:55,199
so phase one as i said you take those

00:15:53,360 --> 00:15:55,839
sort of user-facing apis which is

00:15:55,199 --> 00:15:58,399
generally

00:15:55,839 --> 00:15:59,759
the base model class the query set class

00:15:58,399 --> 00:16:00,880
and the manager class or the base

00:15:59,759 --> 00:16:01,600
manager class and all the things come

00:16:00,880 --> 00:16:03,600
off of it

00:16:01,600 --> 00:16:05,360
and you make those have the async varia

00:16:03,600 --> 00:16:07,279
async understanding so things like

00:16:05,360 --> 00:16:09,680
air like i said for looping over in for

00:16:07,279 --> 00:16:12,399
loops async get async update

00:16:09,680 --> 00:16:13,920
ac create like basically async versions

00:16:12,399 --> 00:16:15,199
of all the operations that cause a

00:16:13,920 --> 00:16:16,959
change the database

00:16:15,199 --> 00:16:18,560
now for query set this is surprisingly a

00:16:16,959 --> 00:16:20,320
few things because whenever you do

00:16:18,560 --> 00:16:20,800
filter or other things in a query set

00:16:20,320 --> 00:16:22,959
chain

00:16:20,800 --> 00:16:24,079
they're all lazy we don't have to change

00:16:22,959 --> 00:16:24,959
those everything actually does anything

00:16:24,079 --> 00:16:27,199
in a query set

00:16:24,959 --> 00:16:28,399
is when you finally iterate over it so

00:16:27,199 --> 00:16:30,560
in fact query set

00:16:28,399 --> 00:16:31,600
mostly stays untouched and there's a few

00:16:30,560 --> 00:16:34,000
things in there that do

00:16:31,600 --> 00:16:35,759
cause an actual evaluation i think

00:16:34,000 --> 00:16:37,120
values list does it for example

00:16:35,759 --> 00:16:39,199
but most things don't so we can keep

00:16:37,120 --> 00:16:40,880
those all the same not much need for

00:16:39,199 --> 00:16:42,959
like async name spacing everywhere in

00:16:40,880 --> 00:16:44,079
your query sets so that's phase one and

00:16:42,959 --> 00:16:46,320
as you can see here

00:16:44,079 --> 00:16:47,600
the rest of django below those sort of

00:16:46,320 --> 00:16:49,600
initial user facing things

00:16:47,600 --> 00:16:50,800
is running threaded essentially this is

00:16:49,600 --> 00:16:51,440
kind of a version of what you can do

00:16:50,800 --> 00:16:52,959
today

00:16:51,440 --> 00:16:54,720
if you use async views you have to

00:16:52,959 --> 00:16:56,720
basically take your rm code

00:16:54,720 --> 00:16:58,639
and wrap it in a sync to async wrapper

00:16:56,720 --> 00:17:00,079
that we provide as part of django

00:16:58,639 --> 00:17:01,680
um and this is doing that in a sort of

00:17:00,079 --> 00:17:03,120
more formalized more safe way

00:17:01,680 --> 00:17:04,640
rather than just like make a separate

00:17:03,120 --> 00:17:06,079
inner function and decorate it and put

00:17:04,640 --> 00:17:07,760
it and feed it in properly

00:17:06,079 --> 00:17:09,520
you can just call the air in a way you

00:17:07,760 --> 00:17:11,280
think is correct from an async world

00:17:09,520 --> 00:17:13,039
and django will handle the async

00:17:11,280 --> 00:17:14,160
handoffs making sure the threads are

00:17:13,039 --> 00:17:15,120
good and making sure everything runs

00:17:14,160 --> 00:17:16,559
correctly

00:17:15,120 --> 00:17:18,799
it is of course still threaded behind

00:17:16,559 --> 00:17:19,120
the scenes but if you're doing say you

00:17:18,799 --> 00:17:21,280
know

00:17:19,120 --> 00:17:22,400
10 days queries in parallel python

00:17:21,280 --> 00:17:23,280
threading overhead isn't going to hurt

00:17:22,400 --> 00:17:24,480
you very much

00:17:23,280 --> 00:17:26,799
you're going to get still going to get

00:17:24,480 --> 00:17:28,880
massive increases like imagine if

00:17:26,799 --> 00:17:31,360
what your site does is it does three or

00:17:28,880 --> 00:17:33,360
four like medium length complex queries

00:17:31,360 --> 00:17:34,960
that don't depend on each other in the

00:17:33,360 --> 00:17:36,400
future you can literally

00:17:34,960 --> 00:17:38,080
pull all those and run them all in

00:17:36,400 --> 00:17:39,360
parallel in an async view

00:17:38,080 --> 00:17:41,120
and then get back the result in a

00:17:39,360 --> 00:17:42,480
quarter of the time and that's the kind

00:17:41,120 --> 00:17:43,600
of real benefit you can see that's

00:17:42,480 --> 00:17:45,120
honestly one of the reasons i think the

00:17:43,600 --> 00:17:47,200
erm is the place where async's

00:17:45,120 --> 00:17:48,400
really going to shine but let's talk

00:17:47,200 --> 00:17:49,600
about what we do after we've got this

00:17:48,400 --> 00:17:50,000
one running so this is probably the

00:17:49,600 --> 00:17:51,120
first

00:17:50,000 --> 00:17:53,840
step and probably will be the first

00:17:51,120 --> 00:17:55,200
thing in a django release by itself

00:17:53,840 --> 00:17:58,160
and then we need to go in and make it

00:17:55,200 --> 00:17:59,919
sort of a bit deeper so we bring down

00:17:58,160 --> 00:18:01,679
that level of where the async boundary

00:17:59,919 --> 00:18:02,240
lies and make it the other side of the

00:18:01,679 --> 00:18:04,000
query

00:18:02,240 --> 00:18:05,919
so now all the django's internal query

00:18:04,000 --> 00:18:06,400
logic and execution and mapping is all

00:18:05,919 --> 00:18:08,559
done

00:18:06,400 --> 00:18:09,760
with asynchronous friendliness in mind

00:18:08,559 --> 00:18:11,440
it may not be pure async but it

00:18:09,760 --> 00:18:12,640
understands how things interact

00:18:11,440 --> 00:18:14,880
and then the only thing running threaded

00:18:12,640 --> 00:18:15,520
is of the database adapters things like

00:18:14,880 --> 00:18:16,799
when you

00:18:15,520 --> 00:18:18,400
sort of type in your database setting

00:18:16,799 --> 00:18:20,160
like those bits of code like oh here's

00:18:18,400 --> 00:18:20,880
my sql adapter here's the poster adapter

00:18:20,160 --> 00:18:23,039
and so on

00:18:20,880 --> 00:18:24,000
um those will still run async and then

00:18:23,039 --> 00:18:26,080
finally

00:18:24,000 --> 00:18:27,039
we will then pull the boundary all the

00:18:26,080 --> 00:18:29,600
way down

00:18:27,039 --> 00:18:30,400
and make the whole thing asynchronous

00:18:29,600 --> 00:18:32,960
now

00:18:30,400 --> 00:18:33,679
there is a big asterisk on this one the

00:18:32,960 --> 00:18:36,799
very bottom

00:18:33,679 --> 00:18:38,960
of this diagram right there uh

00:18:36,799 --> 00:18:40,640
is not controlled by django these

00:18:38,960 --> 00:18:43,360
libraries are third party

00:18:40,640 --> 00:18:44,160
and we have to make sure there are good

00:18:43,360 --> 00:18:46,080
enough

00:18:44,160 --> 00:18:47,200
mature enough third-party database

00:18:46,080 --> 00:18:48,000
libraries we can write again to make

00:18:47,200 --> 00:18:49,600
this work

00:18:48,000 --> 00:18:51,039
that's one of the reasons like we know

00:18:49,600 --> 00:18:53,360
we're never going to have to be able to

00:18:51,039 --> 00:18:55,200
drop thread of support entirely in fact

00:18:53,360 --> 00:18:58,320
in many ways we may never get to phase

00:18:55,200 --> 00:18:59,360
three and that's perfectly okay

00:18:58,320 --> 00:19:01,520
most of the performance gains you're

00:18:59,360 --> 00:19:03,600
going to see from

00:19:01,520 --> 00:19:05,200
from the async rm are still being

00:19:03,600 --> 00:19:06,720
present when it's fully threaded and i

00:19:05,200 --> 00:19:08,640
expect that we will get

00:19:06,720 --> 00:19:09,760
full azing adapters in time maybe not

00:19:08,640 --> 00:19:11,520
for oracle

00:19:09,760 --> 00:19:13,120
but certainly for postgres and my sql

00:19:11,520 --> 00:19:14,559
and sql lite potentially though

00:19:13,120 --> 00:19:16,480
it's single file thread is a little bit

00:19:14,559 --> 00:19:17,520
different and

00:19:16,480 --> 00:19:19,919
one of the other reasons this is

00:19:17,520 --> 00:19:21,280
difficult too is that python has a

00:19:19,919 --> 00:19:23,600
database api standard

00:19:21,280 --> 00:19:25,200
it's called db api 2. it's been with us

00:19:23,600 --> 00:19:27,679
for a very long time now

00:19:25,200 --> 00:19:28,720
and it's great but the problem is like

00:19:27,679 --> 00:19:31,760
whiskey

00:19:28,720 --> 00:19:33,919
it's not ready for an async world and

00:19:31,760 --> 00:19:35,440
honestly for very good reasons most

00:19:33,919 --> 00:19:37,039
database library authors have already

00:19:35,440 --> 00:19:38,480
had too much to do on their plates

00:19:37,039 --> 00:19:40,640
and don't want to have to talk about

00:19:38,480 --> 00:19:41,840
another kind of standard and then

00:19:40,640 --> 00:19:42,880
implementing it and then all agreeing on

00:19:41,840 --> 00:19:44,559
how it works and there's a lot of

00:19:42,880 --> 00:19:46,400
so like this this is kind of what belies

00:19:44,559 --> 00:19:47,280
all of this so at least in the short and

00:19:46,400 --> 00:19:48,720
medium term

00:19:47,280 --> 00:19:50,640
it's gonna be django's job to wrap all

00:19:48,720 --> 00:19:52,080
that up for you i do expect we'll

00:19:50,640 --> 00:19:55,200
probably ship

00:19:52,080 --> 00:19:58,080
at least in the medium term a pure uh

00:19:55,200 --> 00:19:59,039
a pure asynchronous uh back end probably

00:19:58,080 --> 00:20:00,960
on a different

00:19:59,039 --> 00:20:03,200
uh library once we have right now for

00:20:00,960 --> 00:20:04,880
example for postgres there's a couple of

00:20:03,200 --> 00:20:06,240
uh nicely maturing asynchronous

00:20:04,880 --> 00:20:09,039
libraries for talking to postgres

00:20:06,240 --> 00:20:10,480
but they're not psycho pg2 and so we

00:20:09,039 --> 00:20:11,679
would have to go and change a lot of our

00:20:10,480 --> 00:20:14,240
code and the

00:20:11,679 --> 00:20:15,039
assumptions about how psychopg2 works

00:20:14,240 --> 00:20:17,039
and

00:20:15,039 --> 00:20:18,640
if you have looked at django's bug

00:20:17,039 --> 00:20:20,240
tracker for any length of time

00:20:18,640 --> 00:20:22,640
you will know that most of the bugs are

00:20:20,240 --> 00:20:25,360
in weird edge database cases that

00:20:22,640 --> 00:20:26,480
is our job to fix i don't want to just

00:20:25,360 --> 00:20:28,559
throw away those fixes

00:20:26,480 --> 00:20:30,000
that's kind of where it becomes uh you

00:20:28,559 --> 00:20:32,400
know interesting

00:20:30,000 --> 00:20:33,200
but i need to reiterate this databases

00:20:32,400 --> 00:20:35,280
via threads

00:20:33,200 --> 00:20:36,480
are not terrible threading is bad like

00:20:35,280 --> 00:20:38,799
it's not going to be scaled

00:20:36,480 --> 00:20:40,080
indefinitely but if you're just booting

00:20:38,799 --> 00:20:40,960
them up just to run a query and shutting

00:20:40,080 --> 00:20:43,200
them down again

00:20:40,960 --> 00:20:44,400
you can have a pool of 10 to 20 threads

00:20:43,200 --> 00:20:45,840
that significantly speeds up the

00:20:44,400 --> 00:20:47,840
application's performance

00:20:45,840 --> 00:20:50,320
and of course in async mode you can do

00:20:47,840 --> 00:20:53,520
queries and also do api calls

00:20:50,320 --> 00:20:55,440
in the modern world of very heavy like

00:20:53,520 --> 00:20:58,480
micro service architectures

00:20:55,440 --> 00:20:59,360
having asynchronous http or grpc or

00:20:58,480 --> 00:21:02,240
other calls

00:20:59,360 --> 00:21:02,880
incredibly useful as well um in my

00:21:02,240 --> 00:21:04,640
experience

00:21:02,880 --> 00:21:06,559
most large software design if you are a

00:21:04,640 --> 00:21:07,120
big company it's spent waiting on other

00:21:06,559 --> 00:21:08,720
things

00:21:07,120 --> 00:21:10,320
so like as you get bigger that gets more

00:21:08,720 --> 00:21:11,679
important but even as a small shop

00:21:10,320 --> 00:21:13,600
i think the orm is where it will shine

00:21:11,679 --> 00:21:14,240
where you can do its queries quickly and

00:21:13,600 --> 00:21:16,799
understand them

00:21:14,240 --> 00:21:17,679
and see how they go now let's talk about

00:21:16,799 --> 00:21:19,600
the one final

00:21:17,679 --> 00:21:22,720
sort of flying the ointment here and

00:21:19,600 --> 00:21:22,720
that is transactions

00:21:22,799 --> 00:21:26,720
transactions are very tricky and the

00:21:24,960 --> 00:21:28,960
reason for this is transactions run

00:21:26,720 --> 00:21:30,000
on database cursors and database cursors

00:21:28,960 --> 00:21:31,520
are one per thread

00:21:30,000 --> 00:21:33,280
this is a part of django as a big thread

00:21:31,520 --> 00:21:35,440
local in the middle of it

00:21:33,280 --> 00:21:37,200
if we are going to support transactions

00:21:35,440 --> 00:21:39,200
we have to be able to support them

00:21:37,200 --> 00:21:40,640
all in one thread and this is a problem

00:21:39,200 --> 00:21:41,200
when you're going from async to sync

00:21:40,640 --> 00:21:42,480
world

00:21:41,200 --> 00:21:43,919
internally when you go from an

00:21:42,480 --> 00:21:44,640
asynchronous context to a synchronous

00:21:43,919 --> 00:21:46,559
context

00:21:44,640 --> 00:21:48,080
django boots up a separate thread and

00:21:46,559 --> 00:21:49,360
then runs stuff in a separate thread

00:21:48,080 --> 00:21:51,280
and then brings it back to the main

00:21:49,360 --> 00:21:52,720
asynchronous thread when it's done

00:21:51,280 --> 00:21:54,559
what that means is we can't share

00:21:52,720 --> 00:21:56,080
transactions across that boundary

00:21:54,559 --> 00:21:57,840
so i'm not quite sure what the solution

00:21:56,080 --> 00:21:58,559
here is yet but it's probably quite

00:21:57,840 --> 00:22:00,720
likely

00:21:58,559 --> 00:22:02,320
that when you use transaction.atomic it

00:22:00,720 --> 00:22:03,600
won't cross over asynchronous

00:22:02,320 --> 00:22:04,640
synchronous boundaries

00:22:03,600 --> 00:22:06,320
and we're gonna have to work out how to

00:22:04,640 --> 00:22:07,840
signal that so it's pretty safe it may

00:22:06,320 --> 00:22:08,799
be if this error maybe have to wrap it

00:22:07,840 --> 00:22:10,400
in a certain way

00:22:08,799 --> 00:22:12,080
maybe a different version of atomic that

00:22:10,400 --> 00:22:13,520
is async compatible

00:22:12,080 --> 00:22:15,120
but that's kind of one of the key things

00:22:13,520 --> 00:22:16,880
like it's gonna really suck

00:22:15,120 --> 00:22:18,400
unless you find a good way of doing it

00:22:16,880 --> 00:22:19,919
there is some promising research into

00:22:18,400 --> 00:22:21,360
getting around this from some other

00:22:19,919 --> 00:22:22,480
database libraries i want to look into

00:22:21,360 --> 00:22:23,760
but for now

00:22:22,480 --> 00:22:25,200
i expect this will be maybe the main

00:22:23,760 --> 00:22:27,120
sticking point of the first part of that

00:22:25,200 --> 00:22:29,200
conversion of making an async friendly

00:22:27,120 --> 00:22:30,320
api

00:22:29,200 --> 00:22:32,799
another thing to mention is some things

00:22:30,320 --> 00:22:34,400
just don't need async um i'm honestly

00:22:32,799 --> 00:22:34,799
very glad that migrations doesn't need

00:22:34,400 --> 00:22:36,159
it

00:22:34,799 --> 00:22:37,440
it runs once in the background

00:22:36,159 --> 00:22:38,880
synchronously like it does not need

00:22:37,440 --> 00:22:41,200
performance improvements in that sense

00:22:38,880 --> 00:22:43,039
like it all runs in serial anyway

00:22:41,200 --> 00:22:44,880
so we're going to leave those bits well

00:22:43,039 --> 00:22:46,320
alone um introspection is another thing

00:22:44,880 --> 00:22:48,320
some a lot of the internals are fields

00:22:46,320 --> 00:22:49,280
like conversion to and from python also

00:22:48,320 --> 00:22:51,039
the same

00:22:49,280 --> 00:22:52,880
um honestly the service area that we

00:22:51,039 --> 00:22:54,320
have to make async isn't too bad it is

00:22:52,880 --> 00:22:56,640
very tragical i wouldn't be here giving

00:22:54,320 --> 00:22:58,880
this talk saying it's totally possible

00:22:56,640 --> 00:23:00,240
but it is still a lot of it so

00:22:58,880 --> 00:23:00,799
thankfully we can ignore some pieces

00:23:00,240 --> 00:23:02,159
again like

00:23:00,799 --> 00:23:04,480
you know we can ignore things like forms

00:23:02,159 --> 00:23:08,159
right now in competitive views

00:23:04,480 --> 00:23:10,080
but other things we have to tackle so

00:23:08,159 --> 00:23:11,919
what's first like what is the first

00:23:10,080 --> 00:23:14,000
thing that we're working on here well

00:23:11,919 --> 00:23:15,760
before those phases we need to decide on

00:23:14,000 --> 00:23:17,280
what that async api design looks like

00:23:15,760 --> 00:23:19,120
and i'm not a fan of designing in a

00:23:17,280 --> 00:23:20,640
vacuum i want to do it sort of with the

00:23:19,120 --> 00:23:22,559
real thing with a concrete

00:23:20,640 --> 00:23:24,559
thing to play around with so we do that

00:23:22,559 --> 00:23:25,919
as well we need to grapple with

00:23:24,559 --> 00:23:27,520
transactions and again that's kind of

00:23:25,919 --> 00:23:29,039
part of the api design and make sure it

00:23:27,520 --> 00:23:31,120
fits and works well

00:23:29,039 --> 00:23:32,960
and finally i need to figure out the

00:23:31,120 --> 00:23:34,480
thing that underlies transactions which

00:23:32,960 --> 00:23:36,400
is async connection management

00:23:34,480 --> 00:23:38,080
how we pull things and have multiple

00:23:36,400 --> 00:23:40,640
protections in one async thread

00:23:38,080 --> 00:23:42,240
or multiple like separations separate

00:23:40,640 --> 00:23:44,000
threads do we share them across sync

00:23:42,240 --> 00:23:45,360
threads there's a whole world of things

00:23:44,000 --> 00:23:47,360
some adapters don't like other things

00:23:45,360 --> 00:23:49,679
sql light's especially sensitive to this

00:23:47,360 --> 00:23:51,200
it's kind of a pain but on top of all of

00:23:49,679 --> 00:23:53,840
this the thing to remember is

00:23:51,200 --> 00:23:55,279
async is only important for i o bound

00:23:53,840 --> 00:23:56,320
code this is one of the reasons we're

00:23:55,279 --> 00:23:57,679
doing the orm

00:23:56,320 --> 00:23:59,039
it's not important for things like cpu

00:23:57,679 --> 00:24:00,480
boundary computation python is still

00:23:59,039 --> 00:24:01,360
putting them on single core behind the

00:24:00,480 --> 00:24:03,120
scenes

00:24:01,360 --> 00:24:05,360
but things that i o bound is super

00:24:03,120 --> 00:24:06,799
important for and that's why the orm is

00:24:05,360 --> 00:24:11,120
a huge part of this

00:24:06,799 --> 00:24:14,000
like django is the rm i've used the orm

00:24:11,120 --> 00:24:15,440
so much over my probably 15 years at

00:24:14,000 --> 00:24:17,440
this point using django

00:24:15,440 --> 00:24:19,120
and it is a huge win for us to make it

00:24:17,440 --> 00:24:20,799
async especially if it's easy

00:24:19,120 --> 00:24:22,960
like the ability to write a query

00:24:20,799 --> 00:24:25,120
quickly and easily that just

00:24:22,960 --> 00:24:27,120
can run in parallel and it's safe and

00:24:25,120 --> 00:24:29,520
you get the results back like to me

00:24:27,120 --> 00:24:30,240
that's the promise of what async django

00:24:29,520 --> 00:24:32,320
is

00:24:30,240 --> 00:24:33,760
and so i'm hoping that's what we get um

00:24:32,320 --> 00:24:34,799
there is a lot to come

00:24:33,760 --> 00:24:37,279
i'm not going to commit to anything

00:24:34,799 --> 00:24:39,279
being 3.2 but i'm soft aiming for at

00:24:37,279 --> 00:24:41,360
least that first phase to be in there

00:24:39,279 --> 00:24:43,120
um but of course we live in interesting

00:24:41,360 --> 00:24:45,039
times so we'll see

00:24:43,120 --> 00:24:46,960
but yeah thank you very much for

00:24:45,039 --> 00:24:49,120
listening to this i hope you're excited

00:24:46,960 --> 00:24:50,880
about async django as much as i am

00:24:49,120 --> 00:24:52,559
and hopefully i'll see you soon

00:24:50,880 --> 00:24:53,760
somewhere talk about asynchango

00:24:52,559 --> 00:24:55,039
and if you're interested in helping out

00:24:53,760 --> 00:24:56,080
with this kind of stuff please come to

00:24:55,039 --> 00:24:57,120
the django forums

00:24:56,080 --> 00:24:58,559
we're happy to discuss it we have a

00:24:57,120 --> 00:24:59,120
whole async forum there to discuss

00:24:58,559 --> 00:25:01,360
things

00:24:59,120 --> 00:25:11,679
but until then thank you very much and

00:25:01,360 --> 00:25:11,679

YouTube URL: https://www.youtube.com/watch?v=ibAmA4QQDhs


