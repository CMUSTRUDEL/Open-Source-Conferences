Title: "3 ways to test S3 in Python" - Sanjay Siddhanti (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Sanjay Siddhanti

https://2020.pycon.org.au/program/VXXUWE

- Benefits of testing code that uses S3
- In-depth code examples of three ways to test S3:

1. Mock out the S3 API responses using botocore stubs
2. Mock the S3 API using moto
3. Spin up a LocalStack S3 instance and test against that

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 16:00:00 2020 at Python 2
Captions: 
	00:00:00,240 --> 00:00:03,600
from your afternoon break to the python

00:00:01,920 --> 00:00:05,520
2 memorial concert hall

00:00:03,600 --> 00:00:07,359
our next presenter is sanjay siddhanti

00:00:05,520 --> 00:00:08,880
we'll be talking about testing code that

00:00:07,359 --> 00:00:11,840
uses s3

00:00:08,880 --> 00:00:13,280
you'll be in the venulis chat but you

00:00:11,840 --> 00:00:15,040
will be in the venulis chat during the

00:00:13,280 --> 00:00:16,720
presentation for conversation and any

00:00:15,040 --> 00:00:19,279
questions you may have

00:00:16,720 --> 00:00:19,279
taken away

00:00:23,199 --> 00:00:27,840
hi i'm sanjay siddhanti and today i'll

00:00:26,160 --> 00:00:31,199
talk about three ways to test your

00:00:27,840 --> 00:00:33,040
python code that uses amazon s3

00:00:31,199 --> 00:00:34,239
in this talk i'm going to start by

00:00:33,040 --> 00:00:36,320
motivating

00:00:34,239 --> 00:00:38,320
why someone should want to test code

00:00:36,320 --> 00:00:41,280
that uses s3

00:00:38,320 --> 00:00:41,920
then i'll introduce a really simple

00:00:41,280 --> 00:00:44,480
create

00:00:41,920 --> 00:00:45,760
read update delete app that's backed by

00:00:44,480 --> 00:00:48,160
s3

00:00:45,760 --> 00:00:50,640
we will go through the process of

00:00:48,160 --> 00:00:53,280
writing tests for this application

00:00:50,640 --> 00:00:54,399
using three different libraries and at

00:00:53,280 --> 00:00:56,480
the end of the talk

00:00:54,399 --> 00:00:57,520
i will compare and contrast all of the

00:00:56,480 --> 00:01:00,320
libraries

00:00:57,520 --> 00:01:03,199
and discuss which tool is best for

00:01:00,320 --> 00:01:05,280
whatever job you're trying to accomplish

00:01:03,199 --> 00:01:07,360
but first i want to talk about testing

00:01:05,280 --> 00:01:10,080
external systems

00:01:07,360 --> 00:01:11,200
sometimes people are testing code under

00:01:10,080 --> 00:01:13,119
time pressure

00:01:11,200 --> 00:01:15,200
they need to ship the feature and move

00:01:13,119 --> 00:01:18,320
on and when this happens

00:01:15,200 --> 00:01:19,840
a really common thing that i see is to

00:01:18,320 --> 00:01:22,400
skip all the code that

00:01:19,840 --> 00:01:22,960
interacts with external systems whether

00:01:22,400 --> 00:01:26,799
that be

00:01:22,960 --> 00:01:29,920
s3 or a web server or a database

00:01:26,799 --> 00:01:31,759
my hypothesis about this is that

00:01:29,920 --> 00:01:33,200
testing code that interacts with

00:01:31,759 --> 00:01:36,240
external systems is

00:01:33,200 --> 00:01:37,520
unfamiliar and intimidating to a lot of

00:01:36,240 --> 00:01:39,600
people

00:01:37,520 --> 00:01:41,680
everybody knows how to write a unit test

00:01:39,600 --> 00:01:44,720
for a pure function

00:01:41,680 --> 00:01:46,240
but not everyone knows how to test s3

00:01:44,720 --> 00:01:48,000
for example

00:01:46,240 --> 00:01:50,240
a lot of people also think that these

00:01:48,000 --> 00:01:53,360
tests are not necessary

00:01:50,240 --> 00:01:55,680
people say that by doing these you're

00:01:53,360 --> 00:01:58,079
just testing the api

00:01:55,680 --> 00:01:59,200
but i don't think this is fair you're

00:01:58,079 --> 00:02:01,759
actually testing

00:01:59,200 --> 00:02:03,840
any assumptions your code makes you're

00:02:01,759 --> 00:02:05,600
testing business logic that goes along

00:02:03,840 --> 00:02:08,560
with using the api

00:02:05,600 --> 00:02:09,759
and honestly testing the api can be okay

00:02:08,560 --> 00:02:11,920
sometimes because

00:02:09,759 --> 00:02:13,920
as i'll show later in the talk some of

00:02:11,920 --> 00:02:16,400
these services have really complicated

00:02:13,920 --> 00:02:17,440
apis and it's very easy to introduce

00:02:16,400 --> 00:02:19,760
bugs

00:02:17,440 --> 00:02:20,640
and that segues me into the third point

00:02:19,760 --> 00:02:23,920
which is that

00:02:20,640 --> 00:02:27,120
i believe that these tests even just

00:02:23,920 --> 00:02:31,200
a few of them can go a long way towards

00:02:27,120 --> 00:02:33,760
catching bugs in critical business logic

00:02:31,200 --> 00:02:36,400
just to think about your own code

00:02:33,760 --> 00:02:39,440
everyone should take a minute and think

00:02:36,400 --> 00:02:41,519
do you have a system that uses s3 for

00:02:39,440 --> 00:02:44,720
some critical piece of logic

00:02:41,519 --> 00:02:47,519
whether it be static web hosting or

00:02:44,720 --> 00:02:49,040
storing files or using it in an etl

00:02:47,519 --> 00:02:51,680
process

00:02:49,040 --> 00:02:53,200
in this talk i hope to not only convince

00:02:51,680 --> 00:02:56,080
you that testing s3

00:02:53,200 --> 00:02:57,440
is important but i also hope to give you

00:02:56,080 --> 00:02:59,680
some new tools

00:02:57,440 --> 00:03:02,319
so you know how to get started next time

00:02:59,680 --> 00:03:05,040
you have this problem

00:03:02,319 --> 00:03:05,599
let's get started by introducing a

00:03:05,040 --> 00:03:08,560
simple

00:03:05,599 --> 00:03:10,159
create read update delete app for

00:03:08,560 --> 00:03:13,200
cooking recipes

00:03:10,159 --> 00:03:16,000
that's backed by s3 this app is

00:03:13,200 --> 00:03:16,400
only about 20 lines of code if you don't

00:03:16,000 --> 00:03:19,519
count

00:03:16,400 --> 00:03:22,239
imports and doc strings

00:03:19,519 --> 00:03:23,519
the application uses an s3 bucket called

00:03:22,239 --> 00:03:25,599
recipes

00:03:23,519 --> 00:03:26,799
there's a class a python class called

00:03:25,599 --> 00:03:30,239
recipe

00:03:26,799 --> 00:03:33,440
the class has a name and instructions

00:03:30,239 --> 00:03:34,480
both of which are strings it has a

00:03:33,440 --> 00:03:37,840
method called

00:03:34,480 --> 00:03:40,640
get by name this allows you to look up

00:03:37,840 --> 00:03:42,560
a recipe in the s3 bucket based on its

00:03:40,640 --> 00:03:45,280
unique name

00:03:42,560 --> 00:03:46,319
it also has a method to update the

00:03:45,280 --> 00:03:48,879
instructions

00:03:46,319 --> 00:03:50,879
for a recipe you'd use this when you

00:03:48,879 --> 00:03:53,280
have an existing recipe

00:03:50,879 --> 00:03:54,239
and you want to put in new instructions

00:03:53,280 --> 00:03:56,480
for it

00:03:54,239 --> 00:03:57,599
it works by getting the existing recipe

00:03:56,480 --> 00:04:01,599
by name

00:03:57,599 --> 00:04:03,599
updating the instructions and that's it

00:04:01,599 --> 00:04:05,599
there's a delete method that allows you

00:04:03,599 --> 00:04:09,360
to get rid of recipes that

00:04:05,599 --> 00:04:12,000
you no longer want to store in s3

00:04:09,360 --> 00:04:14,159
there's a helper method that helps

00:04:12,000 --> 00:04:16,479
serialize the data to json

00:04:14,159 --> 00:04:18,000
which is how we'll write it to the file

00:04:16,479 --> 00:04:20,799
in s3

00:04:18,000 --> 00:04:21,680
and finally there's a method called save

00:04:20,799 --> 00:04:24,960
that

00:04:21,680 --> 00:04:26,080
actually persists the data to s3 so this

00:04:24,960 --> 00:04:29,120
is really short

00:04:26,080 --> 00:04:32,080
and really simple so let's get into

00:04:29,120 --> 00:04:33,520
writing tests for it we're going to go

00:04:32,080 --> 00:04:35,600
through three options

00:04:33,520 --> 00:04:38,160
and the first one i want to talk about

00:04:35,600 --> 00:04:40,400
is called bottom core stubs

00:04:38,160 --> 00:04:41,520
you might be thinking okay this is built

00:04:40,400 --> 00:04:45,600
into bottle core

00:04:41,520 --> 00:04:48,400
so this is the recommended way to do it

00:04:45,600 --> 00:04:49,040
but actually the subtitle for this

00:04:48,400 --> 00:04:52,639
section

00:04:49,040 --> 00:04:54,720
is called how not to test s3

00:04:52,639 --> 00:04:57,600
i want to show you how painful this

00:04:54,720 --> 00:04:59,520
process is of using bottle core stubs

00:04:57,600 --> 00:05:02,720
so that you'll appreciate the next two

00:04:59,520 --> 00:05:02,720
solutions even more

00:05:02,880 --> 00:05:06,639
bottle core stabs work by letting you

00:05:05,440 --> 00:05:09,680
create a

00:05:06,639 --> 00:05:10,720
stub s3 client so i'll give a bit of

00:05:09,680 --> 00:05:13,440
background here

00:05:10,720 --> 00:05:14,880
first we're creating a pi test fixture

00:05:13,440 --> 00:05:17,680
within that fixture

00:05:14,880 --> 00:05:18,080
we're making a bottle core stub we stub

00:05:17,680 --> 00:05:22,080
out

00:05:18,080 --> 00:05:24,880
the s3 client and then we yield that

00:05:22,080 --> 00:05:26,320
what happens within a pi test fixture is

00:05:24,880 --> 00:05:29,280
that when we yield

00:05:26,320 --> 00:05:29,840
the test has access to this stubbed out

00:05:29,280 --> 00:05:34,639
s3

00:05:29,840 --> 00:05:38,160
client and it can use it as shown below

00:05:34,639 --> 00:05:41,440
the the s3 stub works by

00:05:38,160 --> 00:05:44,080
allowing you to basically add on

00:05:41,440 --> 00:05:44,800
stubbed out responses to it and then pop

00:05:44,080 --> 00:05:47,039
them off

00:05:44,800 --> 00:05:47,919
one by one so let's go through an

00:05:47,039 --> 00:05:49,600
example

00:05:47,919 --> 00:05:51,520
let's say we want to write a really

00:05:49,600 --> 00:05:54,639
simple test to

00:05:51,520 --> 00:05:57,120
create a recipe and then get

00:05:54,639 --> 00:05:58,319
the same recipe just create it and then

00:05:57,120 --> 00:06:00,400
fetch it

00:05:58,319 --> 00:06:01,759
to do this with bottle core stubs we

00:06:00,400 --> 00:06:04,319
have to stub out

00:06:01,759 --> 00:06:05,440
both of the s3 requests that would be

00:06:04,319 --> 00:06:08,000
involved there

00:06:05,440 --> 00:06:09,840
the first one is a put object request

00:06:08,000 --> 00:06:11,759
when we create the recipe

00:06:09,840 --> 00:06:14,479
and the second one is a get object

00:06:11,759 --> 00:06:16,240
request when we want to fetch it

00:06:14,479 --> 00:06:18,000
so here's an example of how we would

00:06:16,240 --> 00:06:20,319
stub out the put object

00:06:18,000 --> 00:06:22,080
response we have to put in a bunch of

00:06:20,319 --> 00:06:25,360
these fields that

00:06:22,080 --> 00:06:27,440
honestly i didn't even really look at

00:06:25,360 --> 00:06:28,880
before writing these tests like the

00:06:27,440 --> 00:06:31,840
request id

00:06:28,880 --> 00:06:34,400
the number of retry attempts and so on

00:06:31,840 --> 00:06:36,400
and actually for brevity i omitted

00:06:34,400 --> 00:06:37,600
lots of fields from this stub but

00:06:36,400 --> 00:06:39,520
there's many more

00:06:37,600 --> 00:06:41,039
uh that actually come back in the

00:06:39,520 --> 00:06:44,720
request

00:06:41,039 --> 00:06:47,440
once we've created this this stub

00:06:44,720 --> 00:06:48,800
this stubbed out response we can add it

00:06:47,440 --> 00:06:52,080
to the

00:06:48,800 --> 00:06:54,560
fake s3 client we're using as shown in

00:06:52,080 --> 00:06:56,639
this line

00:06:54,560 --> 00:06:58,479
the next part is that we need to stub

00:06:56,639 --> 00:06:59,280
out what the get request will give us

00:06:58,479 --> 00:07:02,000
back

00:06:59,280 --> 00:07:04,720
this one's even harder because the get

00:07:02,000 --> 00:07:06,000
object api will return a streaming body

00:07:04,720 --> 00:07:08,800
with the content

00:07:06,000 --> 00:07:10,400
so i have to create that myself manually

00:07:08,800 --> 00:07:12,479
so here what i'm doing is

00:07:10,400 --> 00:07:13,440
i know what the contents of the file are

00:07:12,479 --> 00:07:16,800
going to be

00:07:13,440 --> 00:07:20,000
and so i'm using that to manually

00:07:16,800 --> 00:07:21,680
create my own streaming body that

00:07:20,000 --> 00:07:25,680
looks pretty similar to what i would

00:07:21,680 --> 00:07:28,240
expect the s3 response to contain

00:07:25,680 --> 00:07:29,199
then i can stub out the full get object

00:07:28,240 --> 00:07:31,440
response

00:07:29,199 --> 00:07:33,680
again it has a bunch of stuff that we

00:07:31,440 --> 00:07:37,039
probably don't care too much about

00:07:33,680 --> 00:07:37,840
like request id last modified content

00:07:37,039 --> 00:07:40,319
length

00:07:37,840 --> 00:07:41,360
but most importantly it has this

00:07:40,319 --> 00:07:45,520
streaming body

00:07:41,360 --> 00:07:47,599
in it and we can add that to the stubber

00:07:45,520 --> 00:07:50,319
now that we've stubbed out both of the

00:07:47,599 --> 00:07:52,479
responses that we expect to need

00:07:50,319 --> 00:07:54,960
we can activate the stubborn which means

00:07:52,479 --> 00:07:58,400
we can start actually making requests

00:07:54,960 --> 00:08:00,800
that use s3 and every time we do that

00:07:58,400 --> 00:08:01,520
a response will be popped off of the

00:08:00,800 --> 00:08:04,720
stub

00:08:01,520 --> 00:08:07,360
in a first in first out manner so

00:08:04,720 --> 00:08:07,919
first we're going to make the put object

00:08:07,360 --> 00:08:10,000
request

00:08:07,919 --> 00:08:11,039
so we create a python object here for

00:08:10,000 --> 00:08:13,199
the recipe

00:08:11,039 --> 00:08:14,080
and then we save it which we'll call put

00:08:13,199 --> 00:08:17,039
object to

00:08:14,080 --> 00:08:18,319
put that data in s3 and what's happening

00:08:17,039 --> 00:08:21,440
under the hood here

00:08:18,319 --> 00:08:23,520
is that our mocked out put object

00:08:21,440 --> 00:08:26,639
response is being returned instead of

00:08:23,520 --> 00:08:29,440
actually hitting s3 um and then

00:08:26,639 --> 00:08:29,919
we can fetch the object the same way i'm

00:08:29,440 --> 00:08:32,800
using

00:08:29,919 --> 00:08:34,640
get by name and what's happening under

00:08:32,800 --> 00:08:38,640
the hood here is that our

00:08:34,640 --> 00:08:42,479
our second stubbed out response

00:08:38,640 --> 00:08:45,519
is being returned so you'll see that

00:08:42,479 --> 00:08:48,480
bottom core subs are functional

00:08:45,519 --> 00:08:49,440
they did allow us to write a working

00:08:48,480 --> 00:08:51,839
test here

00:08:49,440 --> 00:08:52,880
and that's where it's something but i

00:08:51,839 --> 00:08:56,160
really do not

00:08:52,880 --> 00:08:58,080
like to work with them and there's a few

00:08:56,160 --> 00:09:01,440
reasons for that

00:08:58,080 --> 00:09:04,080
creating stubs is very time consuming

00:09:01,440 --> 00:09:05,200
it requires a lot of prep one way to

00:09:04,080 --> 00:09:08,560
speed it up

00:09:05,200 --> 00:09:11,279
is to run the real code interactively

00:09:08,560 --> 00:09:13,040
for example with a debugger or an

00:09:11,279 --> 00:09:16,080
ipython shell

00:09:13,040 --> 00:09:17,839
and copy the response out but

00:09:16,080 --> 00:09:19,760
even that doesn't work because some

00:09:17,839 --> 00:09:21,600
things need to be replaced

00:09:19,760 --> 00:09:22,959
like the streaming body that i showed

00:09:21,600 --> 00:09:25,360
above

00:09:22,959 --> 00:09:26,320
another issue is that these stubs are

00:09:25,360 --> 00:09:29,519
fragile

00:09:26,320 --> 00:09:33,519
and fake responses are returned

00:09:29,519 --> 00:09:34,800
first in first out so if you call the s3

00:09:33,519 --> 00:09:38,160
apis

00:09:34,800 --> 00:09:40,800
in a different order than you added

00:09:38,160 --> 00:09:41,360
the responses to the stubborn it will

00:09:40,800 --> 00:09:44,800
throw

00:09:41,360 --> 00:09:46,720
an error it has no flexibility

00:09:44,800 --> 00:09:47,920
the third problem is that to make the

00:09:46,720 --> 00:09:51,279
stubs look

00:09:47,920 --> 00:09:53,279
even somewhat realistic you have to mock

00:09:51,279 --> 00:09:54,560
all sorts of fields that your code

00:09:53,279 --> 00:09:57,279
doesn't care about

00:09:54,560 --> 00:09:58,959
and you end up bloating your tests with

00:09:57,279 --> 00:10:01,120
fake responses

00:09:58,959 --> 00:10:02,000
we can actually see that here in our

00:10:01,120 --> 00:10:04,399
test

00:10:02,000 --> 00:10:05,519
the actual test itself was about five

00:10:04,399 --> 00:10:08,399
lines of code

00:10:05,519 --> 00:10:10,480
but we added tons and tons of code just

00:10:08,399 --> 00:10:12,800
to get the stubs in place

00:10:10,480 --> 00:10:14,320
and finally one thing i don't like is

00:10:12,800 --> 00:10:16,800
that bottle core subs

00:10:14,320 --> 00:10:19,200
leak implementation details from the

00:10:16,800 --> 00:10:22,640
module that's being tested

00:10:19,200 --> 00:10:25,680
so for example if a module switched its

00:10:22,640 --> 00:10:30,240
internal implementation from using the

00:10:25,680 --> 00:10:33,440
list objects api to list objects v2 api

00:10:30,240 --> 00:10:34,480
this test would fail because it depends

00:10:33,440 --> 00:10:37,519
on a specific

00:10:34,480 --> 00:10:40,640
api being called this creates an

00:10:37,519 --> 00:10:42,240
unnecessary dependency on the private

00:10:40,640 --> 00:10:44,000
api of the module

00:10:42,240 --> 00:10:46,079
instead of just testing the

00:10:44,000 --> 00:10:48,959
functionality or the public api

00:10:46,079 --> 00:10:50,320
which is the better thing to do so now

00:10:48,959 --> 00:10:52,640
that we've seen some

00:10:50,320 --> 00:10:53,920
some problems with bottle course tabs

00:10:52,640 --> 00:10:55,839
let's move on to

00:10:53,920 --> 00:10:57,120
the second solution which is called

00:10:55,839 --> 00:11:00,000
motto

00:10:57,120 --> 00:11:01,519
modo is a python library that makes it

00:11:00,000 --> 00:11:05,440
really easy to mock out

00:11:01,519 --> 00:11:07,600
aws services in tests

00:11:05,440 --> 00:11:08,640
here we're creating a similar python

00:11:07,600 --> 00:11:10,959
fixture or pi

00:11:08,640 --> 00:11:12,800
test fixture to what i showed you just

00:11:10,959 --> 00:11:14,880
before

00:11:12,800 --> 00:11:16,079
but what we're doing is we're just

00:11:14,880 --> 00:11:19,600
calling a

00:11:16,079 --> 00:11:21,519
function from motto called mock s3

00:11:19,600 --> 00:11:23,279
within this context manager when we've

00:11:21,519 --> 00:11:27,040
called this function

00:11:23,279 --> 00:11:30,800
um all requests to s3 will be directed

00:11:27,040 --> 00:11:32,880
at motto's virtual aws account so we

00:11:30,800 --> 00:11:34,240
basically have a clean slate to start

00:11:32,880 --> 00:11:37,440
with

00:11:34,240 --> 00:11:39,519
that means that we can create a client

00:11:37,440 --> 00:11:42,320
and this bottle 3 client is going to

00:11:39,519 --> 00:11:45,920
point at motto's aws account

00:11:42,320 --> 00:11:49,519
and we need to create our initial bucket

00:11:45,920 --> 00:11:52,560
that we'll be using once we've done this

00:11:49,519 --> 00:11:54,800
testing our code is super simple so

00:11:52,560 --> 00:11:58,240
let's go back to that same test

00:11:54,800 --> 00:12:01,279
we want to um we want to create

00:11:58,240 --> 00:12:02,639
a recipe and then fetch it so here we

00:12:01,279 --> 00:12:06,240
create the recipe

00:12:02,639 --> 00:12:09,200
and persist it to s3 on the first line

00:12:06,240 --> 00:12:10,320
and then after that we fetch the recipe

00:12:09,200 --> 00:12:12,240
by its name

00:12:10,320 --> 00:12:13,760
and we make some assertions about the

00:12:12,240 --> 00:12:16,480
data that's in it

00:12:13,760 --> 00:12:18,959
this is really easy we didn't have to do

00:12:16,480 --> 00:12:22,639
any mocks or any stubs

00:12:18,959 --> 00:12:25,120
besides just setting up this one mock s3

00:12:22,639 --> 00:12:26,000
function and calling it and it didn't

00:12:25,120 --> 00:12:29,200
really require

00:12:26,000 --> 00:12:30,399
any changes to our original code now

00:12:29,200 --> 00:12:33,519
let's go ahead and test

00:12:30,399 --> 00:12:36,000
the rest of the application too

00:12:33,519 --> 00:12:37,040
so another useful test to do is to make

00:12:36,000 --> 00:12:40,480
sure that

00:12:37,040 --> 00:12:43,120
we are not able to fetch recipes that

00:12:40,480 --> 00:12:44,480
don't actually exist so let's try to

00:12:43,120 --> 00:12:48,079
fetch a recipe

00:12:44,480 --> 00:12:51,200
that doesn't exist like sandwich and

00:12:48,079 --> 00:12:53,920
here we'll tell pie test that we expect

00:12:51,200 --> 00:12:55,440
this line of code to raise the no such

00:12:53,920 --> 00:12:58,240
key exception

00:12:55,440 --> 00:13:00,320
and if it doesn't then the test should

00:12:58,240 --> 00:13:03,440
fail

00:13:00,320 --> 00:13:06,079
we also want to be able to test updating

00:13:03,440 --> 00:13:08,240
a recipe and there's specific semantics

00:13:06,079 --> 00:13:09,279
around that that our application chooses

00:13:08,240 --> 00:13:12,000
to use

00:13:09,279 --> 00:13:13,279
so let's say we were making nachos and

00:13:12,000 --> 00:13:14,880
we had

00:13:13,279 --> 00:13:17,120
original instructions and then we

00:13:14,880 --> 00:13:18,720
decided we wanted to add more detail to

00:13:17,120 --> 00:13:22,000
them

00:13:18,720 --> 00:13:24,639
on on this line over here we

00:13:22,000 --> 00:13:26,560
create the recipe and we persist it to

00:13:24,639 --> 00:13:29,920
s3

00:13:26,560 --> 00:13:31,680
then we call update which will create a

00:13:29,920 --> 00:13:34,959
new python object

00:13:31,680 --> 00:13:36,639
that has the new instructions on it

00:13:34,959 --> 00:13:38,320
but the key thing is that we haven't

00:13:36,639 --> 00:13:40,560
called saves yet

00:13:38,320 --> 00:13:41,680
the semantics of this particular

00:13:40,560 --> 00:13:43,680
application

00:13:41,680 --> 00:13:44,800
are that things should not be persisted

00:13:43,680 --> 00:13:48,079
to s3

00:13:44,800 --> 00:13:48,959
until you call save so let's let's check

00:13:48,079 --> 00:13:52,000
this

00:13:48,959 --> 00:13:53,760
when we fetch the recipe from s3

00:13:52,000 --> 00:13:55,760
even though we've already called update

00:13:53,760 --> 00:13:58,000
we still get the old instructions back

00:13:55,760 --> 00:14:00,880
because we haven't called save

00:13:58,000 --> 00:14:02,160
then when we go ahead and call save and

00:14:00,880 --> 00:14:05,680
we fetched the data

00:14:02,160 --> 00:14:08,079
again from s3 and now we see that the

00:14:05,680 --> 00:14:08,800
the new instructions are there in that

00:14:08,079 --> 00:14:11,360
file

00:14:08,800 --> 00:14:14,480
so this is useful to help us test the

00:14:11,360 --> 00:14:17,360
semantics of our application

00:14:14,480 --> 00:14:20,000
we also want to test that we can delete

00:14:17,360 --> 00:14:23,199
a recipe if we don't want it anymore

00:14:20,000 --> 00:14:27,040
so here on the first line of this test

00:14:23,199 --> 00:14:29,760
i'm creating recipe putting it in s3

00:14:27,040 --> 00:14:30,959
then we're calling the list objects v2

00:14:29,760 --> 00:14:34,079
api

00:14:30,959 --> 00:14:37,519
we're seeing that we see one file

00:14:34,079 --> 00:14:41,440
in our s3 bucket and the file name is

00:14:37,519 --> 00:14:45,279
nachos as we expect then we call delete

00:14:41,440 --> 00:14:47,920
on that file or delete on that recipe

00:14:45,279 --> 00:14:48,399
and we list the objects from the s3

00:14:47,920 --> 00:14:50,240
bucket

00:14:48,399 --> 00:14:51,760
again and this time we don't see any

00:14:50,240 --> 00:14:55,519
objects in the bucket

00:14:51,760 --> 00:14:58,800
so we know that the delete worked so

00:14:55,519 --> 00:15:02,160
with these few tests we just got to

00:14:58,800 --> 00:15:05,279
basically 100 test coverage for

00:15:02,160 --> 00:15:08,160
our small little application and

00:15:05,279 --> 00:15:09,360
overall i think motto does a really

00:15:08,160 --> 00:15:12,560
excellent job

00:15:09,360 --> 00:15:15,920
of implementing the s3 api

00:15:12,560 --> 00:15:19,600
modo is really easy to use

00:15:15,920 --> 00:15:22,639
it feels just like the real s3

00:15:19,600 --> 00:15:25,279
and it doesn't require any code changes

00:15:22,639 --> 00:15:26,160
so i'm very happy with this solution and

00:15:25,279 --> 00:15:29,519
i want to present

00:15:26,160 --> 00:15:32,160
one more option called local stack

00:15:29,519 --> 00:15:33,199
local stack is a library that allows you

00:15:32,160 --> 00:15:38,160
to bring up

00:15:33,199 --> 00:15:38,160
an entire aws cloud stack locally

00:15:38,399 --> 00:15:41,920
unlike motto local stack is not

00:15:40,880 --> 00:15:44,880
something that

00:15:41,920 --> 00:15:46,880
you can just pip install and import into

00:15:44,880 --> 00:15:47,759
your application and expect to use it

00:15:46,880 --> 00:15:50,079
immediately

00:15:47,759 --> 00:15:50,800
you actually need to bring up a local

00:15:50,079 --> 00:15:53,519
server

00:15:50,800 --> 00:15:54,480
first the easiest way to do this is with

00:15:53,519 --> 00:15:57,680
docker

00:15:54,480 --> 00:16:00,000
so below i've posted i've posted my

00:15:57,680 --> 00:16:03,120
docker compose.dml file

00:16:00,000 --> 00:16:03,839
that i used to bring up local stack and

00:16:03,120 --> 00:16:06,720
then

00:16:03,839 --> 00:16:08,399
run pi test against it and i'll show you

00:16:06,720 --> 00:16:11,519
how to use it

00:16:08,399 --> 00:16:14,079
the thing i want to focus on most is

00:16:11,519 --> 00:16:15,759
this initial fixture right here you'll

00:16:14,079 --> 00:16:18,160
see this fixture is

00:16:15,759 --> 00:16:20,000
very similar to the other ones we wrote

00:16:18,160 --> 00:16:20,959
but with one key difference instead of

00:16:20,000 --> 00:16:24,320
calling

00:16:20,959 --> 00:16:27,199
mock s3 here we're actually using

00:16:24,320 --> 00:16:27,839
the bottom three client but when we

00:16:27,199 --> 00:16:30,320
create it

00:16:27,839 --> 00:16:30,959
we're we're pointing it at a specific

00:16:30,320 --> 00:16:33,279
endpoint

00:16:30,959 --> 00:16:36,959
so we're pointing it at the end point

00:16:33,279 --> 00:16:39,040
where we have local stack running

00:16:36,959 --> 00:16:42,320
what this will do is we what we

00:16:39,040 --> 00:16:45,199
basically have now is an s3 client

00:16:42,320 --> 00:16:46,320
that's pointing to our virtual local

00:16:45,199 --> 00:16:49,680
stack aws

00:16:46,320 --> 00:16:53,279
account so again we need to create

00:16:49,680 --> 00:16:56,880
the initial s3 bucket and then we use

00:16:53,279 --> 00:17:00,079
a mock.patch here to patch the get

00:16:56,880 --> 00:17:03,120
s3 function which returns the s3

00:17:00,079 --> 00:17:06,480
bottom 3 client for s3 and we have it

00:17:03,120 --> 00:17:08,799
return our local stack botto3 client

00:17:06,480 --> 00:17:10,720
instead

00:17:08,799 --> 00:17:11,839
the reason i wanted to focus on this

00:17:10,720 --> 00:17:14,079
fixture

00:17:11,839 --> 00:17:15,280
is it's actually the only thing we have

00:17:14,079 --> 00:17:18,640
to do differently

00:17:15,280 --> 00:17:22,079
between local stack tests and

00:17:18,640 --> 00:17:25,439
motto tests with this fixture in place

00:17:22,079 --> 00:17:28,799
we can run the same exact tests

00:17:25,439 --> 00:17:30,880
that we used for motto i've repeated

00:17:28,799 --> 00:17:32,880
them below for completeness

00:17:30,880 --> 00:17:35,039
but i'm not going to go over them again

00:17:32,880 --> 00:17:36,880
because we didn't modify them

00:17:35,039 --> 00:17:38,320
and i think this is a really powerful

00:17:36,880 --> 00:17:41,200
property is

00:17:38,320 --> 00:17:42,080
that when when two libraries do a good

00:17:41,200 --> 00:17:45,120
job

00:17:42,080 --> 00:17:45,760
of implementing the api one way you can

00:17:45,120 --> 00:17:48,000
tell that

00:17:45,760 --> 00:17:52,000
is that you can actually swap them out

00:17:48,000 --> 00:17:52,000
and you don't see any behavior changes

00:17:52,240 --> 00:17:55,760
so i'll just scroll through these tests

00:17:55,120 --> 00:17:58,559
here

00:17:55,760 --> 00:18:00,720
to show you that they're the same and

00:17:58,559 --> 00:18:03,600
all of this code is also available

00:18:00,720 --> 00:18:03,600
on my github

00:18:05,440 --> 00:18:09,520
so in summary local stack in addition to

00:18:08,799 --> 00:18:12,480
modo

00:18:09,520 --> 00:18:14,640
also does a really great job of

00:18:12,480 --> 00:18:17,360
implementing the s3 api

00:18:14,640 --> 00:18:18,799
so that leaves us with two really good

00:18:17,360 --> 00:18:22,080
solutions

00:18:18,799 --> 00:18:24,799
so i want to pause for a moment and talk

00:18:22,080 --> 00:18:27,039
about testing external systems

00:18:24,799 --> 00:18:29,520
at the beginning of this talk we said

00:18:27,039 --> 00:18:30,720
that testing external systems is really

00:18:29,520 --> 00:18:32,960
hard

00:18:30,720 --> 00:18:35,360
people are intimidated by it or

00:18:32,960 --> 00:18:37,840
unfamiliar with it

00:18:35,360 --> 00:18:39,760
and i hope you've seen here that it

00:18:37,840 --> 00:18:43,120
doesn't have to be hard

00:18:39,760 --> 00:18:45,760
my advice is to look for libraries that

00:18:43,120 --> 00:18:47,919
look and feel like the service you're

00:18:45,760 --> 00:18:50,000
trying to test

00:18:47,919 --> 00:18:50,960
if you find yourself writing

00:18:50,000 --> 00:18:54,320
time-consuming

00:18:50,960 --> 00:18:57,760
mocks or doing things that feel brittle

00:18:54,320 --> 00:18:58,400
or fragile then there might be a better

00:18:57,760 --> 00:19:01,440
solution

00:18:58,400 --> 00:19:04,559
out there and in our case

00:19:01,440 --> 00:19:08,080
both model and local stack meet the bar

00:19:04,559 --> 00:19:11,200
that of technologies that we want to use

00:19:08,080 --> 00:19:11,760
they both implement the s3 api they both

00:19:11,200 --> 00:19:14,799
feel

00:19:11,760 --> 00:19:16,720
like the real s3 and neither of them

00:19:14,799 --> 00:19:18,559
required any code changes to our

00:19:16,720 --> 00:19:20,320
application

00:19:18,559 --> 00:19:22,720
and i want you to know that this isn't

00:19:20,320 --> 00:19:25,760
just about theory

00:19:22,720 --> 00:19:27,360
and it's not about writing tests for fun

00:19:25,760 --> 00:19:30,240
these types of tests have actually

00:19:27,360 --> 00:19:33,760
helped me catch real bugs in my career

00:19:30,240 --> 00:19:37,039
and here i'll name a few of them

00:19:33,760 --> 00:19:38,720
first i misunderstood how s3 versions

00:19:37,039 --> 00:19:40,559
were created when i still

00:19:38,720 --> 00:19:42,720
when i first started working with

00:19:40,559 --> 00:19:44,799
version files in s3

00:19:42,720 --> 00:19:46,320
this led me to make an assumption that

00:19:44,799 --> 00:19:49,600
was incorrect

00:19:46,320 --> 00:19:51,679
i assumed that if i had the same file

00:19:49,600 --> 00:19:54,320
contents i could copy those

00:19:51,679 --> 00:19:56,320
those objects to another bucket and the

00:19:54,320 --> 00:19:58,240
versions would be the same

00:19:56,320 --> 00:19:59,520
i wrote a test and realized this was

00:19:58,240 --> 00:20:02,320
wrong

00:19:59,520 --> 00:20:03,840
i also didn't understand the proper way

00:20:02,320 --> 00:20:07,200
to permanently delete

00:20:03,840 --> 00:20:10,000
versioned objects again both of these

00:20:07,200 --> 00:20:13,280
examples the top two examples

00:20:10,000 --> 00:20:15,440
could be considered testing the api

00:20:13,280 --> 00:20:16,640
but really in this case it was testing

00:20:15,440 --> 00:20:19,280
my code

00:20:16,640 --> 00:20:21,120
programmed by me and i was the one who

00:20:19,280 --> 00:20:23,840
made incorrect assumptions

00:20:21,120 --> 00:20:26,400
about the api and that's why these tests

00:20:23,840 --> 00:20:28,880
were still valuable

00:20:26,400 --> 00:20:29,440
another bug i found was that i work on

00:20:28,880 --> 00:20:33,200
etl

00:20:29,440 --> 00:20:34,080
processes and one time i found that i

00:20:33,200 --> 00:20:37,039
wasn't moving

00:20:34,080 --> 00:20:37,919
files around to the correct destination

00:20:37,039 --> 00:20:39,840
and

00:20:37,919 --> 00:20:42,720
testing helped me catch that before

00:20:39,840 --> 00:20:46,159
anything went out to production

00:20:42,720 --> 00:20:48,240
so i want to conclude by talking about

00:20:46,159 --> 00:20:51,200
which library you should use if you

00:20:48,240 --> 00:20:54,640
picked up a new project today

00:20:51,200 --> 00:20:56,559
both model and local stack are useful

00:20:54,640 --> 00:20:58,320
in that they can actually both be used

00:20:56,559 --> 00:21:02,080
to test code in multiple

00:20:58,320 --> 00:21:05,039
languages so motto is a pure python

00:21:02,080 --> 00:21:07,120
library but if you wanted to use it to

00:21:05,039 --> 00:21:09,520
test code in other languages

00:21:07,120 --> 00:21:10,640
you could spin up a local server it

00:21:09,520 --> 00:21:13,840
supports that mode

00:21:10,640 --> 00:21:15,200
similar to how we use localstack they're

00:21:13,840 --> 00:21:18,240
also useful because

00:21:15,200 --> 00:21:21,760
they both implement mocks for many

00:21:18,240 --> 00:21:24,960
other aws services in addition to s3

00:21:21,760 --> 00:21:28,159
for example they implement mocks for

00:21:24,960 --> 00:21:32,000
ec2 rds lambda

00:21:28,159 --> 00:21:35,440
and at least a dozen other services

00:21:32,000 --> 00:21:37,360
the benefit of this is that by investing

00:21:35,440 --> 00:21:39,200
in one of these libraries you get more

00:21:37,360 --> 00:21:41,440
than just testing s3

00:21:39,200 --> 00:21:42,640
you get to learn or you get a library

00:21:41,440 --> 00:21:46,240
that will help you test

00:21:42,640 --> 00:21:48,320
all of your other aws resources

00:21:46,240 --> 00:21:49,280
now for the differences between the two

00:21:48,320 --> 00:21:52,320
of them

00:21:49,280 --> 00:21:52,720
so motto is pure python and it requires

00:21:52,320 --> 00:21:55,039
no

00:21:52,720 --> 00:21:56,480
extra build step if you're using a

00:21:55,039 --> 00:21:58,480
python test suite

00:21:56,480 --> 00:22:00,240
after all we're here at a python

00:21:58,480 --> 00:22:03,200
conference right now

00:22:00,240 --> 00:22:04,240
i would say motto is super easy you just

00:22:03,200 --> 00:22:05,840
pip install it and

00:22:04,240 --> 00:22:08,799
import it into your code and you don't

00:22:05,840 --> 00:22:11,039
have to set up any other infrastructure

00:22:08,799 --> 00:22:12,000
on the other hand local stacks

00:22:11,039 --> 00:22:15,200
architecture

00:22:12,000 --> 00:22:18,000
and internal implementation details are

00:22:15,200 --> 00:22:19,840
probably more realistic to what you

00:22:18,000 --> 00:22:21,919
would expect a cloud service to be

00:22:19,840 --> 00:22:25,039
implemented like

00:22:21,919 --> 00:22:27,360
for most people this won't matter but if

00:22:25,039 --> 00:22:30,559
you wanted to do unit tests

00:22:27,360 --> 00:22:33,360
that test um like large-scale

00:22:30,559 --> 00:22:34,720
reads and writes for example then local

00:22:33,360 --> 00:22:37,760
stacks architecture

00:22:34,720 --> 00:22:40,080
might be better suited for that in my

00:22:37,760 --> 00:22:43,280
opinion you really can't go wrong

00:22:40,080 --> 00:22:46,000
with either solution for me personally

00:22:43,280 --> 00:22:46,720
if i'm using a python project i use

00:22:46,000 --> 00:22:48,960
motto

00:22:46,720 --> 00:22:51,280
because it doesn't require an extra

00:22:48,960 --> 00:22:52,159
build step and it does the job perfectly

00:22:51,280 --> 00:22:54,720
well

00:22:52,159 --> 00:22:55,679
but if i'm already using a different

00:22:54,720 --> 00:22:58,480
language

00:22:55,679 --> 00:22:59,280
and i either way i would need to spin up

00:22:58,480 --> 00:23:01,679
a server

00:22:59,280 --> 00:23:02,960
in docker then i go ahead and use

00:23:01,679 --> 00:23:05,120
localstack because

00:23:02,960 --> 00:23:08,400
it seems like it might be a little bit

00:23:05,120 --> 00:23:10,720
more realistic or more powerful

00:23:08,400 --> 00:23:12,159
so thank you so much for watching my

00:23:10,720 --> 00:23:15,600
talk

00:23:12,159 --> 00:23:17,600
all of my code is available on my github

00:23:15,600 --> 00:23:19,679
and you can also reach out to me on

00:23:17,600 --> 00:23:21,760
twitter with any feedback or

00:23:19,679 --> 00:23:30,720
questions and i'd be very happy to hear

00:23:21,760 --> 00:23:30,720

YouTube URL: https://www.youtube.com/watch?v=NBICMF0i4Ok


