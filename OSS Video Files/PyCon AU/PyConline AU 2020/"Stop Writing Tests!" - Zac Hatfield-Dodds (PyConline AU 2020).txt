Title: "Stop Writing Tests!" - Zac Hatfield-Dodds (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Zac Hatfield-Dodds

https://2020.pycon.org.au/program/TCT3GH

We often think of manual testing as slower and less effective than automated testing,
but most test suites haven't automated that much!  Computers can execute all our 
pre-defined tests very quickly - and this is definitely a good thing, especially for 
regression tests - but the tricky parts are still done by humans.

We select test cases (inputs) and check that the corresponding outputs make sense;
we write functions that "arrange, act, and assert" for our tests; and we decide -
or script via CI systems - which tests to execute and when.

So lets explore some next-generation tools that we could use to automate these 
remaining parts of a testing workflow!

PROPERTY-BASED TESTING helps you to write more powerful tests by automating selection 
of test cases: instead of listing input-output pairs, you describe the kind of data 
you want and write a test that passes *for all X...*.  We'll see a live demo, and 
learn something about the Python builtins in the process!

CODE INTROSPECTION, and a handy templating tool, can help write tests for you.
Do you need to know any more than which code to test, and what properties should hold?

ADAPTIVE FUZZING tools take CI to its logical conclusion: instead of running a fixed
set of tests on each push, they sit on a server and run tests full-time... fine-tuning
themselves to find bugs in *your* project and pulling each new commit as it lands!

By the end of this talk, you'll know what these three kinds of tools can do - 
and how to get started with automating the *rest* of your testing tomorrow.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 11:35:00 2020 at Curlyboi
Captions: 
	00:00:00,080 --> 00:00:03,919
hey everybody welcome back to the curly

00:00:02,320 --> 00:00:07,040
boy theater for our

00:00:03,919 --> 00:00:09,599
third talk of this block we have

00:00:07,040 --> 00:00:10,400
zach hatfield dodds with stop writing

00:00:09,599 --> 00:00:13,120
tests

00:00:10,400 --> 00:00:14,000
hi zack how you doing i'm going well

00:00:13,120 --> 00:00:17,440
excited to give

00:00:14,000 --> 00:00:19,760
you a couple of demos

00:00:17,440 --> 00:00:20,640
okay let's see how we go that would be

00:00:19,760 --> 00:00:23,039
great

00:00:20,640 --> 00:00:24,640
so zack is a researcher at the

00:00:23,039 --> 00:00:26,400
australian national university

00:00:24,640 --> 00:00:28,240
and maintains a number of packages

00:00:26,400 --> 00:00:29,679
mostly focused on testing

00:00:28,240 --> 00:00:31,359
and we're not at his desk grumbling

00:00:29,679 --> 00:00:32,800
about the body state of software

00:00:31,359 --> 00:00:34,320
that can be found with a book a block of

00:00:32,800 --> 00:00:36,320
chocolate and a plan to go somewhere out

00:00:34,320 --> 00:00:40,320
of phone range for a walk

00:00:36,320 --> 00:00:42,640
sounds great so zack stop writing tests

00:00:40,320 --> 00:00:45,920
i'll kick it over to you

00:00:42,640 --> 00:00:47,600
thanks very much all right i just want

00:00:45,920 --> 00:00:50,000
to start with

00:00:47,600 --> 00:00:51,680
a little introduction to this talk i've

00:00:50,000 --> 00:00:54,000
called it stop writing tests

00:00:51,680 --> 00:00:54,879
that doesn't mean stop testing it means

00:00:54,000 --> 00:00:57,360
i want you

00:00:54,879 --> 00:00:58,559
to write less tests and automate more of

00:00:57,360 --> 00:01:01,199
your testing

00:00:58,559 --> 00:01:03,039
so while i'm a little provocative here

00:01:01,199 --> 00:01:04,080
and i don't literally want you to never

00:01:03,039 --> 00:01:07,040
write a test again

00:01:04,080 --> 00:01:08,320
i am actually quite serious about this

00:01:07,040 --> 00:01:10,320
so this talk is about

00:01:08,320 --> 00:01:13,360
how can we take automated testing and

00:01:10,320 --> 00:01:14,880
make it even more automated

00:01:13,360 --> 00:01:16,320
but before i get into it i want to

00:01:14,880 --> 00:01:16,720
acknowledge that i'm giving this talk

00:01:16,320 --> 00:01:18,320
from

00:01:16,720 --> 00:01:20,640
none of all in nambri country in

00:01:18,320 --> 00:01:21,280
canberra i was actually born just over

00:01:20,640 --> 00:01:23,920
to

00:01:21,280 --> 00:01:25,759
the corner of this slide i live just off

00:01:23,920 --> 00:01:28,640
the other side and i study and work in

00:01:25,759 --> 00:01:28,640
the middle at au

00:01:29,680 --> 00:01:34,799
so into the body of the talk i'm going

00:01:32,799 --> 00:01:36,479
to talk to you today about testing and

00:01:34,799 --> 00:01:37,119
that means i want to define my terms a

00:01:36,479 --> 00:01:39,520
little

00:01:37,119 --> 00:01:41,119
so when i say testing i mean an activity

00:01:39,520 --> 00:01:42,720
where we execute code

00:01:41,119 --> 00:01:44,960
in order to find bugs or check for

00:01:42,720 --> 00:01:45,759
regressions and let's go through that in

00:01:44,960 --> 00:01:47,920
a couple of

00:01:45,759 --> 00:01:48,960
steps so first of all testing is an

00:01:47,920 --> 00:01:50,799
activity

00:01:48,960 --> 00:01:52,479
it's a kind of a thing that we do when

00:01:50,799 --> 00:01:54,240
we're developing code or when we're

00:01:52,479 --> 00:01:54,960
otherwise working with it and in

00:01:54,240 --> 00:01:56,719
particular

00:01:54,960 --> 00:01:58,079
it's where we execute code while i

00:01:56,719 --> 00:02:00,880
really love tools like

00:01:58,079 --> 00:02:01,680
black or iso or my pi or flake8 or

00:02:00,880 --> 00:02:03,600
pylind

00:02:01,680 --> 00:02:04,960
that can really help us find bugs or

00:02:03,600 --> 00:02:06,799
prevent bugs in our code

00:02:04,960 --> 00:02:08,000
because they don't actually execute the

00:02:06,799 --> 00:02:10,160
code in order to find them

00:02:08,000 --> 00:02:11,280
i don't consider them to be testing and

00:02:10,160 --> 00:02:12,400
i'm not going to be talking about them

00:02:11,280 --> 00:02:14,800
today

00:02:12,400 --> 00:02:15,920
and the second bit to find bugs or check

00:02:14,800 --> 00:02:17,440
for regressions

00:02:15,920 --> 00:02:19,040
actually speaks to a quite deep

00:02:17,440 --> 00:02:20,800
philosophical difference in what we

00:02:19,040 --> 00:02:22,400
think testing is about

00:02:20,800 --> 00:02:24,160
some people will say that testing is

00:02:22,400 --> 00:02:26,000
about finding bugs that the goal is

00:02:24,160 --> 00:02:27,040
actually to confirm that our software is

00:02:26,000 --> 00:02:28,480
correct

00:02:27,040 --> 00:02:30,400
whereas some other people think of it

00:02:28,480 --> 00:02:31,440
more as a tool for software engineering

00:02:30,400 --> 00:02:34,319
in the sense of

00:02:31,440 --> 00:02:35,920
developing software plus time if we're

00:02:34,319 --> 00:02:36,959
checking for regressions our goal is

00:02:35,920 --> 00:02:39,440
actually not to find

00:02:36,959 --> 00:02:41,200
bugs but to confirm that no bugs haven't

00:02:39,440 --> 00:02:44,319
come back into the software

00:02:41,200 --> 00:02:45,519
as we change it but either way and i'm

00:02:44,319 --> 00:02:47,040
just going to ignore that whole

00:02:45,519 --> 00:02:48,080
philosophical question for the rest of

00:02:47,040 --> 00:02:50,480
the talk

00:02:48,080 --> 00:02:52,239
we have kind of four fundamental steps

00:02:50,480 --> 00:02:54,800
in the testing process

00:02:52,239 --> 00:02:55,599
we choose some inputs to the code that

00:02:54,800 --> 00:02:58,400
we're testing

00:02:55,599 --> 00:03:00,640
we run the code that we're testing and

00:02:58,400 --> 00:03:02,800
we check whether it did the right thing

00:03:00,640 --> 00:03:04,319
and then we repeat that until we decide

00:03:02,800 --> 00:03:07,840
that we've done enough

00:03:04,319 --> 00:03:11,040
testing okay so choose inputs

00:03:07,840 --> 00:03:12,400
run the code check the behavior repeat

00:03:11,040 --> 00:03:14,239
everything i'm going to talk about

00:03:12,400 --> 00:03:15,040
follows that structure and the real

00:03:14,239 --> 00:03:18,640
question is

00:03:15,040 --> 00:03:20,560
how much of it can we automate

00:03:18,640 --> 00:03:22,400
so structure of the talk is really going

00:03:20,560 --> 00:03:24,159
to go through why would we generate test

00:03:22,400 --> 00:03:24,959
cases rather than coming up with them by

00:03:24,159 --> 00:03:26,959
hand

00:03:24,959 --> 00:03:28,480
i'm going to talk about how to test

00:03:26,959 --> 00:03:30,560
general properties of your code

00:03:28,480 --> 00:03:32,319
both what kinds of general properties

00:03:30,560 --> 00:03:33,840
are often testable and then

00:03:32,319 --> 00:03:36,000
what kind of tools and techniques would

00:03:33,840 --> 00:03:37,680
you use to test them and then finally

00:03:36,000 --> 00:03:38,400
i'm going to get into some exciting new

00:03:37,680 --> 00:03:40,159
stuff with

00:03:38,400 --> 00:03:43,360
fuzzing your test suite and i'll explain

00:03:40,159 --> 00:03:43,360
what that means later

00:03:43,519 --> 00:03:49,120
so when we talk about automated testing

00:03:47,440 --> 00:03:50,879
i'm going to argue that what we usually

00:03:49,120 --> 00:03:54,080
mean

00:03:50,879 --> 00:03:57,200
is still surprisingly human

00:03:54,080 --> 00:03:58,959
that in automated testing we the

00:03:57,200 --> 00:04:01,680
software engineers or qa people

00:03:58,959 --> 00:04:02,640
come up with our test cases we decide

00:04:01,680 --> 00:04:04,560
what to test

00:04:02,640 --> 00:04:06,480
what inputs to test it with and exactly

00:04:04,560 --> 00:04:08,159
how the logic should go

00:04:06,480 --> 00:04:10,159
and then we write a bit of code which

00:04:08,159 --> 00:04:12,319
executes that for us

00:04:10,159 --> 00:04:13,680
so in a sense we've automated the

00:04:12,319 --> 00:04:17,040
repetitive part of it

00:04:13,680 --> 00:04:19,519
where we actually run through that test

00:04:17,040 --> 00:04:20,239
process again and again but we haven't

00:04:19,519 --> 00:04:22,160
automated

00:04:20,239 --> 00:04:24,320
or gotten the computer to do any of the

00:04:22,160 --> 00:04:26,639
intellectual labor for us

00:04:24,320 --> 00:04:27,600
and so this picture that i've got behind

00:04:26,639 --> 00:04:29,840
me is

00:04:27,600 --> 00:04:31,919
of the original mechanical turk a kind

00:04:29,840 --> 00:04:35,199
of clockwork automaton which

00:04:31,919 --> 00:04:37,120
allegedly played chess

00:04:35,199 --> 00:04:39,040
it caused an enormous stir in europe at

00:04:37,120 --> 00:04:41,199
the time

00:04:39,040 --> 00:04:43,440
and enormous arguments as people tried

00:04:41,199 --> 00:04:45,040
to work out how is this possible

00:04:43,440 --> 00:04:47,199
this was well before the days of chess

00:04:45,040 --> 00:04:48,960
software or even digital computers

00:04:47,199 --> 00:04:50,479
and so some people decided it was

00:04:48,960 --> 00:04:52,639
impossible on the basis that

00:04:50,479 --> 00:04:54,160
no machine could ever play chess well

00:04:52,639 --> 00:04:56,720
they weren't quite right

00:04:54,160 --> 00:04:58,800
and others on the basis that it wasn't

00:04:56,720 --> 00:05:00,639
possible for machines to play chess

00:04:58,800 --> 00:05:02,800
yet and there must be a human tucked

00:05:00,639 --> 00:05:07,039
inside it controlling the whole thing

00:05:02,800 --> 00:05:07,039
and of course they were correct

00:05:08,080 --> 00:05:11,919
so when i get into showing you some

00:05:10,000 --> 00:05:13,440
examples of testing

00:05:11,919 --> 00:05:15,680
i need to talk a little bit about the

00:05:13,440 --> 00:05:18,000
kind of examples i'm using

00:05:15,680 --> 00:05:19,759
and i want to acknowledge that the

00:05:18,000 --> 00:05:20,720
examples i'm talking about are going to

00:05:19,759 --> 00:05:22,000
be small

00:05:20,720 --> 00:05:24,000
they're going to be examples that have

00:05:22,000 --> 00:05:26,080
to fit on a slide or at most

00:05:24,000 --> 00:05:27,680
on a screen they have to be small enough

00:05:26,080 --> 00:05:28,479
and easy enough to understand that i can

00:05:27,680 --> 00:05:30,720
talk to

00:05:28,479 --> 00:05:32,720
talk you through them quickly in a talk

00:05:30,720 --> 00:05:34,000
uh but i just want to promise you

00:05:32,720 --> 00:05:36,400
and you will have to take my word for

00:05:34,000 --> 00:05:38,639
this that all of this these techniques

00:05:36,400 --> 00:05:40,160
actually do scale they do work for more

00:05:38,639 --> 00:05:43,520
complicated systems

00:05:40,160 --> 00:05:45,919
and i promise you david i'm not going to

00:05:43,520 --> 00:05:48,960
talk about reversing lists

00:05:45,919 --> 00:05:51,199
let's sort a list instead

00:05:48,960 --> 00:05:52,000
so let's imagine that i've defined some

00:05:51,199 --> 00:05:53,919
amazing new

00:05:52,000 --> 00:05:55,520
sorting function and there are many

00:05:53,919 --> 00:05:57,840
different ways to sort lists you've got

00:05:55,520 --> 00:05:58,720
insertion sorts merge sorts quick sorts

00:05:57,840 --> 00:06:02,400
bubble sorts

00:05:58,720 --> 00:06:04,080
bogo sorts bogo bogo sorts

00:06:02,400 --> 00:06:06,560
which can take different amounts of time

00:06:04,080 --> 00:06:08,560
for different kinds of inputs they can

00:06:06,560 --> 00:06:10,400
have all kinds of subtle algorithms

00:06:08,560 --> 00:06:12,000
trade-offs between speed

00:06:10,400 --> 00:06:14,160
memory performance or various other

00:06:12,000 --> 00:06:17,120
things

00:06:14,160 --> 00:06:18,720
and so sorting a list being much more

00:06:17,120 --> 00:06:20,080
complicated than reversing a list i

00:06:18,720 --> 00:06:22,400
think is actually a suitable thing to

00:06:20,080 --> 00:06:24,080
think about testing

00:06:22,400 --> 00:06:25,680
so if we just imagine that i've written

00:06:24,080 --> 00:06:27,199
a great new sorting function i want to

00:06:25,680 --> 00:06:30,080
show you

00:06:27,199 --> 00:06:31,680
i might test it and the way i usually

00:06:30,080 --> 00:06:33,360
actually start testing code that i've

00:06:31,680 --> 00:06:35,360
written is i just fire up the python

00:06:33,360 --> 00:06:36,160
session in the terminal or in a jupyter

00:06:35,360 --> 00:06:39,280
notebook

00:06:36,160 --> 00:06:40,560
and i just call the function and so you

00:06:39,280 --> 00:06:42,319
can see here that

00:06:40,560 --> 00:06:44,800
if i call my new sorting function with

00:06:42,319 --> 00:06:46,160
sorted list it gives me the right answer

00:06:44,800 --> 00:06:48,160
and if i call it with a list which is

00:06:46,160 --> 00:06:49,280
not sorted it also gives me the right

00:06:48,160 --> 00:06:51,199
answer

00:06:49,280 --> 00:06:52,800
and so thinking about splitting up the

00:06:51,199 --> 00:06:54,800
behaviors of your software

00:06:52,800 --> 00:06:56,560
into categories like this is often

00:06:54,800 --> 00:06:58,080
called partition testing

00:06:56,560 --> 00:07:00,240
and the goal is generally to make sure

00:06:58,080 --> 00:07:02,800
you have a test case which demonstrates

00:07:00,240 --> 00:07:04,560
each kind of area or category of the

00:07:02,800 --> 00:07:08,080
behavior your software should have

00:07:04,560 --> 00:07:09,520
and that it gets it right and so once

00:07:08,080 --> 00:07:11,919
we've done our manual testing

00:07:09,520 --> 00:07:13,840
we can write this down in a test file

00:07:11,919 --> 00:07:14,880
run it with pi test or maybe unit test

00:07:13,840 --> 00:07:16,800
if you prefer

00:07:14,880 --> 00:07:18,880
and this will automate it so it's much

00:07:16,800 --> 00:07:21,840
cheaper to re-execute those tests every

00:07:18,880 --> 00:07:23,520
time i change the software after this

00:07:21,840 --> 00:07:25,759
of course we don't want to repeat

00:07:23,520 --> 00:07:27,039
ourselves so finally

00:07:25,759 --> 00:07:29,199
and this makes most sense when you've

00:07:27,039 --> 00:07:30,000
got more than two cases we can write a

00:07:29,199 --> 00:07:31,759
parameterized

00:07:30,000 --> 00:07:33,039
test sometimes this is called table

00:07:31,759 --> 00:07:34,479
driven testing

00:07:33,039 --> 00:07:36,720
and i actually really like this

00:07:34,479 --> 00:07:40,319
technique it's a great way to record

00:07:36,720 --> 00:07:42,560
regressions or examples that caused bugs

00:07:40,319 --> 00:07:44,160
and it's really easy to add more cases

00:07:42,560 --> 00:07:46,160
as you discover more about the behavior

00:07:44,160 --> 00:07:48,879
of your software

00:07:46,160 --> 00:07:51,919
there's only one problem when i told you

00:07:48,879 --> 00:07:55,120
that i defined a sorting function

00:07:51,919 --> 00:07:58,000
i lied my sorting function

00:07:55,120 --> 00:07:59,120
runs really fast because it only ever

00:07:58,000 --> 00:08:01,919
returns the list

00:07:59,120 --> 00:08:01,919
one two three

00:08:02,400 --> 00:08:07,120
so what's wrong with this i mean it's a

00:08:04,960 --> 00:08:10,400
working implementation right it passed

00:08:07,120 --> 00:08:13,680
all the tests that i wrote for it

00:08:10,400 --> 00:08:16,080
so maybe we need some way

00:08:13,680 --> 00:08:18,479
that lets us write tests where we don't

00:08:16,080 --> 00:08:20,160
have to know all the answers in advance

00:08:18,479 --> 00:08:21,919
and this is going to be the foundation

00:08:20,160 --> 00:08:23,440
of all the other techniques that i teach

00:08:21,919 --> 00:08:25,440
you about today

00:08:23,440 --> 00:08:26,879
how do we write tests that can detect

00:08:25,440 --> 00:08:28,639
bugs without

00:08:26,879 --> 00:08:30,720
us knowing in advance what the correct

00:08:28,639 --> 00:08:32,959
answer should be

00:08:30,720 --> 00:08:35,360
and it turns out this also makes it much

00:08:32,959 --> 00:08:37,200
easier to test really complex software

00:08:35,360 --> 00:08:39,120
in research where we genuinely don't

00:08:37,200 --> 00:08:41,360
know what the correct answer should be

00:08:39,120 --> 00:08:43,039
in large or complicated or

00:08:41,360 --> 00:08:45,200
non-deterministic systems where it's

00:08:43,039 --> 00:08:48,000
just really hard to work it out

00:08:45,200 --> 00:08:49,360
and it also encourages us to put in kind

00:08:48,000 --> 00:08:51,120
of weird or wacky

00:08:49,360 --> 00:08:52,640
examples where coming up with the

00:08:51,120 --> 00:08:53,600
correct answer and writing it out would

00:08:52,640 --> 00:08:56,160
just be

00:08:53,600 --> 00:08:57,279
kind of annoying and that little

00:08:56,160 --> 00:09:00,080
annoyance

00:08:57,279 --> 00:09:01,200
stops a surprising amount of testing and

00:09:00,080 --> 00:09:04,240
so what we have here

00:09:01,200 --> 00:09:06,080
is a test that given let's just say like

00:09:04,240 --> 00:09:07,279
any list of things which we should be

00:09:06,080 --> 00:09:09,440
able to sort

00:09:07,279 --> 00:09:11,680
if we get the result by sorting it and

00:09:09,440 --> 00:09:13,120
then compare each element to the next

00:09:11,680 --> 00:09:14,880
element in the list

00:09:13,120 --> 00:09:16,160
it should be less than or equal to that

00:09:14,880 --> 00:09:18,000
element right

00:09:16,160 --> 00:09:19,360
and this will be true of any correct

00:09:18,000 --> 00:09:21,680
sorting function

00:09:19,360 --> 00:09:23,120
and importantly this makes it really

00:09:21,680 --> 00:09:25,680
easy to find

00:09:23,120 --> 00:09:27,839
some input which detects that our

00:09:25,680 --> 00:09:30,000
sorting implementation is buggy

00:09:27,839 --> 00:09:32,720
if we just put in for example one two

00:09:30,000 --> 00:09:35,360
three four and we get one two three back

00:09:32,720 --> 00:09:36,480
that won't actually detect it but if we

00:09:35,360 --> 00:09:38,800
put in

00:09:36,480 --> 00:09:38,800
say

00:09:40,000 --> 00:09:45,200
well come to think of it this test won't

00:09:43,360 --> 00:09:45,920
actually detect the bug we need another

00:09:45,200 --> 00:09:47,760
property

00:09:45,920 --> 00:09:50,480
we also need to check that we have the

00:09:47,760 --> 00:09:53,360
same number of each element not that

00:09:50,480 --> 00:09:54,240
just that the result is a list which is

00:09:53,360 --> 00:09:56,959
in order

00:09:54,240 --> 00:09:59,839
but that the result is has the same

00:09:56,959 --> 00:10:01,920
elements as the input

00:09:59,839 --> 00:10:04,000
but i want to make the point that this

00:10:01,920 --> 00:10:05,839
test before can actually test

00:10:04,000 --> 00:10:07,360
or find problems in many other

00:10:05,839 --> 00:10:08,240
implementations of sorting which are

00:10:07,360 --> 00:10:10,240
buggy

00:10:08,240 --> 00:10:12,079
and so partial properties like this

00:10:10,240 --> 00:10:13,040
which don't fully define the answer but

00:10:12,079 --> 00:10:15,760
can nonetheless

00:10:13,040 --> 00:10:16,720
find some bugs are in fact really

00:10:15,760 --> 00:10:18,079
powerful

00:10:16,720 --> 00:10:20,079
because they let you describe the

00:10:18,079 --> 00:10:20,640
behavior of your system at a much higher

00:10:20,079 --> 00:10:22,800
level

00:10:20,640 --> 00:10:24,880
than just demonstrating an exact input

00:10:22,800 --> 00:10:28,640
and output you can say something about

00:10:24,880 --> 00:10:29,839
what should be true for all inputs

00:10:28,640 --> 00:10:32,640
so this technique is called

00:10:29,839 --> 00:10:35,920
property-based testing and i want you to

00:10:32,640 --> 00:10:35,920
write property-based tests

00:10:37,120 --> 00:10:40,880
one of the big reasons for that is that

00:10:39,920 --> 00:10:43,120
often

00:10:40,880 --> 00:10:44,640
we don't know what but what inputs will

00:10:43,120 --> 00:10:46,160
cause problems

00:10:44,640 --> 00:10:48,480
and it's the things that we don't think

00:10:46,160 --> 00:10:51,360
of that often trigger bugs right if

00:10:48,480 --> 00:10:53,040
we had to know what the bug was in order

00:10:51,360 --> 00:10:54,480
to write a test which would find it

00:10:53,040 --> 00:10:56,560
our tests are going to be much less

00:10:54,480 --> 00:10:57,360
effective and property-based testing

00:10:56,560 --> 00:10:59,519
tools

00:10:57,360 --> 00:11:01,200
help us get out of that and in

00:10:59,519 --> 00:11:02,880
particular they help us get out of that

00:11:01,200 --> 00:11:04,880
by generating

00:11:02,880 --> 00:11:07,680
and getting the computer to generate for

00:11:04,880 --> 00:11:09,600
us many many random examples

00:11:07,680 --> 00:11:12,000
of the kinds of inputs that we think our

00:11:09,600 --> 00:11:13,920
code should support

00:11:12,000 --> 00:11:16,560
you might think random testing seems

00:11:13,920 --> 00:11:18,079
kind of flaky it's not necessarily flaky

00:11:16,560 --> 00:11:18,959
if using right tools and i'll get into

00:11:18,079 --> 00:11:21,200
that later

00:11:18,959 --> 00:11:23,040
but it turns out is also almost as

00:11:21,200 --> 00:11:24,480
effective as partition testing

00:11:23,040 --> 00:11:26,480
it turns out if you just randomly

00:11:24,480 --> 00:11:27,440
generate a bunch of inputs you're likely

00:11:26,480 --> 00:11:28,720
to generate at least

00:11:27,440 --> 00:11:30,959
some which are in each of those

00:11:28,720 --> 00:11:32,560
partitions of your software's behavior

00:11:30,959 --> 00:11:34,640
and it also means that you don't have to

00:11:32,560 --> 00:11:36,079
know what the partitions are

00:11:34,640 --> 00:11:37,440
and can even detect if your

00:11:36,079 --> 00:11:38,880
understanding of the partitions is

00:11:37,440 --> 00:11:41,760
incorrect in a way that

00:11:38,880 --> 00:11:44,880
wouldn't happen with automated execution

00:11:41,760 --> 00:11:46,800
of handwritten tests

00:11:44,880 --> 00:11:48,640
so the foolproof plan to get you

00:11:46,800 --> 00:11:50,720
property-based testing is to pip

00:11:48,640 --> 00:11:52,560
install hypothesis if you're on a

00:11:50,720 --> 00:11:56,079
supported version of python

00:11:52,560 --> 00:11:58,720
that is python35 or above it'll just

00:11:56,079 --> 00:12:00,320
work that's pretty much it you just pip

00:11:58,720 --> 00:12:02,959
install hypothesis and then

00:12:00,320 --> 00:12:04,560
import it you can skim the documentation

00:12:02,959 --> 00:12:05,600
and then shortly afterwards you will be

00:12:04,560 --> 00:12:09,519
drowning in bugs

00:12:05,600 --> 00:12:11,360
i promise let's give an example of

00:12:09,519 --> 00:12:13,200
not how you would write a property based

00:12:11,360 --> 00:12:14,320
test but how you could migrate an

00:12:13,200 --> 00:12:17,839
existing test

00:12:14,320 --> 00:12:17,839
to use hypothesis

00:12:18,000 --> 00:12:21,519
let's imagine that you're working on

00:12:19,680 --> 00:12:23,120
something like git so this is not an

00:12:21,519 --> 00:12:25,120
algorithms problem

00:12:23,120 --> 00:12:26,639
it's kind of standard business elogic

00:12:25,120 --> 00:12:27,920
you're doing something with a stateful

00:12:26,639 --> 00:12:30,959
system and you're checking

00:12:27,920 --> 00:12:32,399
the state of that system in this case we

00:12:30,959 --> 00:12:34,399
want to check the property that

00:12:32,399 --> 00:12:36,639
if you check out a new branch that is

00:12:34,399 --> 00:12:38,480
you create a new branch in your repo

00:12:36,639 --> 00:12:39,839
then the current branch is the branch

00:12:38,480 --> 00:12:41,760
you just created

00:12:39,839 --> 00:12:43,200
and so here we have a test and it kind

00:12:41,760 --> 00:12:44,800
of runs through that right it says when

00:12:43,200 --> 00:12:46,880
you get a temporary directory you create

00:12:44,800 --> 00:12:48,720
the repository you check out new branch

00:12:46,880 --> 00:12:51,279
created and then that's your active

00:12:48,720 --> 00:12:53,200
branch but

00:12:51,279 --> 00:12:55,920
it's kind of a shaggy dog story right

00:12:53,200 --> 00:12:57,519
it's full of particular details like

00:12:55,920 --> 00:12:58,959
does this work for repositories that are

00:12:57,519 --> 00:13:00,800
not freshly initialized

00:12:58,959 --> 00:13:02,959
does it work for repositories in other

00:13:00,800 --> 00:13:04,880
areas doesn't work for other branch

00:13:02,959 --> 00:13:07,760
names

00:13:04,880 --> 00:13:08,560
well the first thing we could do is kind

00:13:07,760 --> 00:13:10,959
of express

00:13:08,560 --> 00:13:11,680
without any library that which branch

00:13:10,959 --> 00:13:13,600
name it is

00:13:11,680 --> 00:13:14,959
shouldn't matter and we can express that

00:13:13,600 --> 00:13:17,440
just by making it a

00:13:14,959 --> 00:13:18,959
default argument to the function right

00:13:17,440 --> 00:13:20,079
whatever your test runner is this will

00:13:18,959 --> 00:13:23,120
run exactly the same

00:13:20,079 --> 00:13:24,880
code but we've kind of expressed that

00:13:23,120 --> 00:13:27,680
the specific branch name shouldn't

00:13:24,880 --> 00:13:29,600
matter it's a variable now

00:13:27,680 --> 00:13:30,800
and if we use hypothesis we could say

00:13:29,600 --> 00:13:33,600
hey hypothesis

00:13:30,800 --> 00:13:34,079
given a branch name argument which is

00:13:33,600 --> 00:13:38,720
just

00:13:34,079 --> 00:13:42,320
the string new branch run the same test

00:13:38,720 --> 00:13:43,839
and okay this actually still does

00:13:42,320 --> 00:13:45,360
exactly the same thing right but now

00:13:43,839 --> 00:13:46,480
you're using hypothesis that's a great

00:13:45,360 --> 00:13:48,639
start

00:13:46,480 --> 00:13:50,480
and then because we might want to share

00:13:48,639 --> 00:13:53,360
this between many tests we have

00:13:50,480 --> 00:13:54,639
multiple tests that use branch names if

00:13:53,360 --> 00:13:56,800
we write

00:13:54,639 --> 00:13:58,639
a function that returns our branch name

00:13:56,800 --> 00:13:59,279
strategy we can then share that between

00:13:58,639 --> 00:14:02,560
them

00:13:59,279 --> 00:14:04,480
and that means that if we discover odd

00:14:02,560 --> 00:14:05,519
branch names and we teach hypothesis how

00:14:04,480 --> 00:14:07,199
to generate them

00:14:05,519 --> 00:14:08,639
all of our tests will get that benefit

00:14:07,199 --> 00:14:10,480
automatically

00:14:08,639 --> 00:14:11,760
and if we have a bunch of variations of

00:14:10,480 --> 00:14:14,000
the kinds of data we have

00:14:11,760 --> 00:14:15,279
and a bunch of tests this means that we

00:14:14,000 --> 00:14:16,959
scale additively

00:14:15,279 --> 00:14:19,600
rather than as the square of those

00:14:16,959 --> 00:14:20,959
things so as our test suite grows or we

00:14:19,600 --> 00:14:23,760
add more features this is going to be

00:14:20,959 --> 00:14:23,760
much franklier

00:14:24,399 --> 00:14:31,680
if we try to say that any unicode

00:14:27,600 --> 00:14:34,399
string is a valid branch name

00:14:31,680 --> 00:14:35,199
we're going to have a lot of problems uh

00:14:34,399 --> 00:14:37,199
white space

00:14:35,199 --> 00:14:39,440
doesn't work the empty string doesn't

00:14:37,199 --> 00:14:41,680
work uh it turns out branch names

00:14:39,440 --> 00:14:43,680
starting or ending in dashes don't work

00:14:41,680 --> 00:14:45,440
there's a whole bunch of reserved words

00:14:43,680 --> 00:14:47,279
there's length limits for various online

00:14:45,440 --> 00:14:49,040
services so

00:14:47,279 --> 00:14:51,360
we just kind of give up right and we say

00:14:49,040 --> 00:14:52,800
look this is probably more complicated

00:14:51,360 --> 00:14:54,160
we can come back to this later once

00:14:52,800 --> 00:14:56,160
we've got things working

00:14:54,160 --> 00:14:58,800
but for now if we just have like an

00:14:56,160 --> 00:14:59,279
ascii branch name with a reasonable

00:14:58,800 --> 00:15:02,560
length

00:14:59,279 --> 00:15:05,360
this test should pass and then

00:15:02,560 --> 00:15:07,600
eventually if we come back to our test

00:15:05,360 --> 00:15:09,680
this is what a finalized property based

00:15:07,600 --> 00:15:13,199
test for this might look like we say

00:15:09,680 --> 00:15:15,680
given any branch name and any repository

00:15:13,199 --> 00:15:17,839
if we just assume that is reject any

00:15:15,680 --> 00:15:20,320
repos where the branch name is already

00:15:17,839 --> 00:15:22,000
a branch in that repository and then we

00:15:20,320 --> 00:15:25,199
check out and create that branch name

00:15:22,000 --> 00:15:27,600
then that's the active branch

00:15:25,199 --> 00:15:28,560
this is a story where once the computer

00:15:27,600 --> 00:15:30,079
can check it

00:15:28,560 --> 00:15:32,320
this actually expresses pretty much

00:15:30,079 --> 00:15:35,440
exactly what we meant by the first test

00:15:32,320 --> 00:15:37,199
but we're likely to find or we can find

00:15:35,440 --> 00:15:39,040
a whole bunch of bugs which just weren't

00:15:37,199 --> 00:15:41,839
possible to observe when we only used a

00:15:39,040 --> 00:15:41,839
single example

00:15:42,800 --> 00:15:47,920
but what if you've migrated your tests

00:15:44,880 --> 00:15:50,399
or you're working on a new project

00:15:47,920 --> 00:15:52,000
this is where i announce and give you

00:15:50,399 --> 00:15:55,040
the first ever live demo

00:15:52,000 --> 00:15:56,320
of the hypothesis ghostwriter a new tool

00:15:55,040 --> 00:15:59,199
that i've been working on

00:15:56,320 --> 00:16:00,079
which can inspect your code and write

00:15:59,199 --> 00:16:04,720
your tests

00:16:00,079 --> 00:16:04,720
for you so let's go see what this looks

00:16:06,839 --> 00:16:11,519
like

00:16:09,040 --> 00:16:12,560
all right so here i have one terminal

00:16:11,519 --> 00:16:16,160
which i will

00:16:12,560 --> 00:16:16,160
try to increase the text size in

00:16:16,240 --> 00:16:23,839
one text editor likewise and

00:16:20,639 --> 00:16:25,120
the way the ghostwriter works is we just

00:16:23,839 --> 00:16:28,000
have a hypothesis

00:16:25,120 --> 00:16:29,680
write command and so you can tell

00:16:28,000 --> 00:16:30,880
hypothesis to write your property-based

00:16:29,680 --> 00:16:33,920
test for you

00:16:30,880 --> 00:16:35,040
whether that's based on a module or a

00:16:33,920 --> 00:16:36,880
particular function

00:16:35,040 --> 00:16:38,399
you can tell it to catch and ignore

00:16:36,880 --> 00:16:40,480
particular exceptions

00:16:38,399 --> 00:16:41,839
you can ask it for unit test instead of

00:16:40,480 --> 00:16:42,880
pi test style

00:16:41,839 --> 00:16:45,040
and then there are a number of

00:16:42,880 --> 00:16:47,279
properties that you can ask it to test

00:16:45,040 --> 00:16:48,399
and so those general properties are you

00:16:47,279 --> 00:16:51,279
can have

00:16:48,399 --> 00:16:53,040
a fuzz test that is a test which just

00:16:51,279 --> 00:16:55,279
runs your code without making any

00:16:53,040 --> 00:16:56,720
assertions about the results

00:16:55,279 --> 00:16:58,639
that turns out to actually be a really

00:16:56,720 --> 00:16:59,680
useful starting point because hypothesis

00:16:58,639 --> 00:17:01,519
has already worked out

00:16:59,680 --> 00:17:02,880
what arguments to pass what kind of

00:17:01,519 --> 00:17:04,319
strategies to use

00:17:02,880 --> 00:17:06,559
and you can just fill out the body of

00:17:04,319 --> 00:17:08,319
the test logic yourself or you can leave

00:17:06,559 --> 00:17:09,520
it it turns out just calling your code

00:17:08,319 --> 00:17:11,600
with valid input

00:17:09,520 --> 00:17:14,079
can find at least a my code an

00:17:11,600 --> 00:17:15,919
embarrassing number of bugs

00:17:14,079 --> 00:17:17,439
we can test that a function is item

00:17:15,919 --> 00:17:19,039
potent for example

00:17:17,439 --> 00:17:20,480
if you sort a list that you've already

00:17:19,039 --> 00:17:21,439
sorted that shouldn't make any further

00:17:20,480 --> 00:17:23,360
changes

00:17:21,439 --> 00:17:26,000
we can test that two functions are

00:17:23,360 --> 00:17:28,480
equivalent that one's really useful for

00:17:26,000 --> 00:17:29,520
things like performance optimizations if

00:17:28,480 --> 00:17:31,440
you test that

00:17:29,520 --> 00:17:32,960
a multi-threaded version always gets the

00:17:31,440 --> 00:17:33,760
same results as a single threaded

00:17:32,960 --> 00:17:36,480
version

00:17:33,760 --> 00:17:38,320
or that your new rewrite of some system

00:17:36,480 --> 00:17:42,320
does the same thing as the old version

00:17:38,320 --> 00:17:45,280
super useful or my personal favorite

00:17:42,320 --> 00:17:46,320
is that we can test uh round trip

00:17:45,280 --> 00:17:49,360
properties

00:17:46,320 --> 00:17:52,480
that is if we for example

00:17:49,360 --> 00:17:55,520
dump some json to a string and then

00:17:52,480 --> 00:18:00,080
load that json

00:17:55,520 --> 00:18:01,919
back into python objects

00:18:00,080 --> 00:18:04,160
should get the same object that we

00:18:01,919 --> 00:18:07,679
started with right

00:18:04,160 --> 00:18:07,679
and so if we write this test

00:18:08,320 --> 00:18:12,960
we can see that okay there are way more

00:18:10,960 --> 00:18:15,600
arguments to these json functions

00:18:12,960 --> 00:18:17,600
than i actually anticipated but

00:18:15,600 --> 00:18:18,400
hypothesis has sorted that out and has

00:18:17,600 --> 00:18:21,679
written them all

00:18:18,400 --> 00:18:24,720
for us so the bit that we need to do

00:18:21,679 --> 00:18:27,360
right and we hopefully have a to do note

00:18:24,720 --> 00:18:28,320
which says hypothesis couldn't work out

00:18:27,360 --> 00:18:31,280
what we should call

00:18:28,320 --> 00:18:32,720
with as the object and that's because

00:18:31,280 --> 00:18:34,559
the standard library is not type

00:18:32,720 --> 00:18:36,240
annotated and object is

00:18:34,559 --> 00:18:37,679
not the kind of name that hypothesis is

00:18:36,240 --> 00:18:39,120
willing to guess it knows what that

00:18:37,679 --> 00:18:42,240
should be

00:18:39,120 --> 00:18:43,039
but we can quickly define recursive json

00:18:42,240 --> 00:18:45,760
data

00:18:43,039 --> 00:18:47,440
so we say okay json data is recursive

00:18:45,760 --> 00:18:50,640
our base case

00:18:47,440 --> 00:18:53,280
is that it's either none or

00:18:50,640 --> 00:18:53,280
a boolean

00:18:55,600 --> 00:19:03,360
or okay it could be an

00:18:58,799 --> 00:19:07,280
integer or it could be

00:19:03,360 --> 00:19:12,000
a float or it could be

00:19:07,280 --> 00:19:14,799
unicode text and then

00:19:12,000 --> 00:19:15,919
to make this recursive given some bit of

00:19:14,799 --> 00:19:18,960
json

00:19:15,919 --> 00:19:18,960
x we have

00:19:19,919 --> 00:19:26,559
either lists of json or

00:19:23,360 --> 00:19:29,760
we can have dictionaries

00:19:26,559 --> 00:19:33,520
of string keys

00:19:29,760 --> 00:19:33,520
to json values

00:19:33,760 --> 00:19:38,640
all right so that wasn't too hard we'd

00:19:37,280 --> 00:19:42,720
have to write the whole test

00:19:38,640 --> 00:19:42,720
and now if we run pi test on it

00:19:43,360 --> 00:19:46,799
and we'll ask for some hypothesis

00:19:45,840 --> 00:19:48,880
statistics

00:19:46,799 --> 00:19:50,840
which i don't usually bother with but it

00:19:48,880 --> 00:19:53,840
kind of gives you a sense of what it's

00:19:50,840 --> 00:19:53,840
doing

00:19:55,840 --> 00:19:59,280
we can see that

00:19:59,840 --> 00:20:02,160
whoa

00:20:03,200 --> 00:20:10,480
looks like the test failed and

00:20:07,280 --> 00:20:11,919
we get a bunch of metadata about events

00:20:10,480 --> 00:20:13,840
and that looks a little more complicated

00:20:11,919 --> 00:20:17,039
than i expected

00:20:13,840 --> 00:20:20,000
but here we are the problem is

00:20:17,039 --> 00:20:21,600
if we give this and we have infinity as

00:20:20,000 --> 00:20:24,400
our object

00:20:21,600 --> 00:20:24,960
then we learn that we can't actually

00:20:24,400 --> 00:20:28,559
encode

00:20:24,960 --> 00:20:32,000
infinity if we have specified

00:20:28,559 --> 00:20:35,039
that where is this

00:20:32,000 --> 00:20:36,080
allow nand is false so the json standard

00:20:35,039 --> 00:20:39,280
doesn't actually allow

00:20:36,080 --> 00:20:40,799
non-finite values alternatively

00:20:39,280 --> 00:20:43,760
we could have found that if our object

00:20:40,799 --> 00:20:45,840
is not a number and we have allowed nan

00:20:43,760 --> 00:20:47,840
then encoding and decoding it is still

00:20:45,840 --> 00:20:49,360
not equal because

00:20:47,840 --> 00:20:52,400
that's just how the floating point not a

00:20:49,360 --> 00:20:52,400
number works

00:20:52,640 --> 00:20:56,559
all right so much for that let's look at

00:20:54,640 --> 00:20:59,600
a couple of other examples

00:20:56,559 --> 00:21:00,320
uh i just want to run this one briefly

00:20:59,600 --> 00:21:02,640
right

00:21:00,320 --> 00:21:04,320
but the reason it's called

00:21:02,640 --> 00:21:06,159
property-based testing is because this

00:21:04,320 --> 00:21:08,640
originates in haskell

00:21:06,159 --> 00:21:09,440
where people talk a lot about algebraic

00:21:08,640 --> 00:21:11,600
properties

00:21:09,440 --> 00:21:13,200
and that could mean you have things like

00:21:11,600 --> 00:21:14,880
binary operators like addition or

00:21:13,200 --> 00:21:16,960
multiplication which can be

00:21:14,880 --> 00:21:18,000
commutative or associative or have an

00:21:16,960 --> 00:21:19,840
identity

00:21:18,000 --> 00:21:21,200
and hey look you can write those with

00:21:19,840 --> 00:21:23,440
hypothesis too

00:21:21,200 --> 00:21:24,880
uh look that's all i'm going to say

00:21:23,440 --> 00:21:26,640
about it because we're not writing

00:21:24,880 --> 00:21:27,440
haskell and most of our code doesn't

00:21:26,640 --> 00:21:29,280
look like that

00:21:27,440 --> 00:21:31,440
but if yours is you can take advantage

00:21:29,280 --> 00:21:34,000
of that

00:21:31,440 --> 00:21:34,799
so the final thing that i want to

00:21:34,000 --> 00:21:38,480
demonstrate

00:21:34,799 --> 00:21:41,039
and this is kind of exciting for me is

00:21:38,480 --> 00:21:42,880
the first ever demo of a hypothesis

00:21:41,039 --> 00:21:45,280
fuzzer

00:21:42,880 --> 00:21:46,240
so far everything we've talked about has

00:21:45,280 --> 00:21:47,919
been

00:21:46,240 --> 00:21:49,360
pretty much a traditional kind of test

00:21:47,919 --> 00:21:51,360
suite that is

00:21:49,360 --> 00:21:52,720
you write better tests with hypothesis

00:21:51,360 --> 00:21:53,440
and the computer does some of the work

00:21:52,720 --> 00:21:55,120
for you

00:21:53,440 --> 00:21:56,799
but it still kind of works the same way

00:21:55,120 --> 00:21:58,640
you write the test then you run the test

00:21:56,799 --> 00:22:00,640
then they tell you what they found

00:21:58,640 --> 00:22:02,559
but if we're generating test cases we

00:22:00,640 --> 00:22:05,039
could actually take this a step further

00:22:02,559 --> 00:22:06,799
we can ask hypothesis to sit on a server

00:22:05,039 --> 00:22:07,360
and just keep coming up with new test

00:22:06,799 --> 00:22:10,240
cases

00:22:07,360 --> 00:22:12,000
indefinitely and let us know whenever it

00:22:10,240 --> 00:22:13,679
finds a bug

00:22:12,000 --> 00:22:15,520
so i'm going to start this fuzz of

00:22:13,679 --> 00:22:18,960
running on

00:22:15,520 --> 00:22:18,960
a couple of

00:22:19,840 --> 00:22:22,880
test suites and this works pretty much

00:22:22,159 --> 00:22:26,080
like hypoth

00:22:22,880 --> 00:22:28,080
like pi test does it all inspect

00:22:26,080 --> 00:22:29,840
the code it'll collect the tests it'll

00:22:28,080 --> 00:22:30,640
pick out the ones that use hypothesis

00:22:29,840 --> 00:22:33,760
for us

00:22:30,640 --> 00:22:34,559
and then it will start running them and

00:22:33,760 --> 00:22:40,240
it looks

00:22:34,559 --> 00:22:44,159
something like this

00:22:40,240 --> 00:22:46,400
there we are so hypothesis

00:22:44,159 --> 00:22:48,240
using pi test has found a couple of

00:22:46,400 --> 00:22:49,840
different tests in this test suite

00:22:48,240 --> 00:22:51,919
it's found a number of them from my

00:22:49,840 --> 00:22:53,760
hypothesis json schema library

00:22:51,919 --> 00:22:56,320
which are testing various kinds of

00:22:53,760 --> 00:22:59,600
schemas and we've also found

00:22:56,320 --> 00:23:01,919
this one that uh if we run

00:22:59,600 --> 00:23:03,840
black on any valid python source code

00:23:01,919 --> 00:23:05,679
generated with hypothesis

00:23:03,840 --> 00:23:06,880
running black on it again shouldn't make

00:23:05,679 --> 00:23:08,240
any further edits

00:23:06,880 --> 00:23:10,159
and that's actually running in black's

00:23:08,240 --> 00:23:11,840
test suite now

00:23:10,159 --> 00:23:13,760
what's happened here is that each of

00:23:11,840 --> 00:23:16,240
these has spun up into another process

00:23:13,760 --> 00:23:17,840
we have as many processes as calls on my

00:23:16,240 --> 00:23:19,039
machine so hopefully the stream doesn't

00:23:17,840 --> 00:23:21,200
flake out

00:23:19,039 --> 00:23:24,000
and each of them is just churning away

00:23:21,200 --> 00:23:25,280
generating new test cases

00:23:24,000 --> 00:23:27,039
but what makes this particularly

00:23:25,280 --> 00:23:28,559
different to just running hypothesis

00:23:27,039 --> 00:23:30,480
with pi test in a loop

00:23:28,559 --> 00:23:32,080
is that this runs under coverage of

00:23:30,480 --> 00:23:34,960
instrumentation

00:23:32,080 --> 00:23:36,000
so each test will be run under coverage

00:23:34,960 --> 00:23:38,240
and whenever we see an

00:23:36,000 --> 00:23:39,919
input which does something new we

00:23:38,240 --> 00:23:43,039
actually keep track of that

00:23:39,919 --> 00:23:45,279
and we use it to generate further inputs

00:23:43,039 --> 00:23:47,120
and the net result is that we can kind

00:23:45,279 --> 00:23:49,120
of ratchet our way through the possible

00:23:47,120 --> 00:23:51,039
things this program can do

00:23:49,120 --> 00:23:53,600
and when we discover new behavior we can

00:23:51,039 --> 00:23:55,279
keep it keep it and take advantage of it

00:23:53,600 --> 00:23:57,120
in later runs

00:23:55,279 --> 00:23:58,720
the fuzzer is also smart enough to keep

00:23:57,120 --> 00:24:00,240
track of examples it's seen before and

00:23:58,720 --> 00:24:02,000
replay them immediately

00:24:00,240 --> 00:24:04,000
so the discovery process doesn't have to

00:24:02,000 --> 00:24:06,159
start from scratch every time

00:24:04,000 --> 00:24:08,720
it starts by replaying everything it's

00:24:06,159 --> 00:24:08,720
seen before

00:24:09,840 --> 00:24:17,360
so this

00:24:12,960 --> 00:24:20,000
it turns out is scarily effective

00:24:17,360 --> 00:24:21,120
my libraries because i write hypothesis

00:24:20,000 --> 00:24:24,799
tend to be

00:24:21,120 --> 00:24:26,080
fairly well tested just running the same

00:24:24,799 --> 00:24:28,080
tests using this coverage

00:24:26,080 --> 00:24:31,520
instrumentation has

00:24:28,080 --> 00:24:33,520
already found me five or six new bugs

00:24:31,520 --> 00:24:35,679
and this is just running this overnight

00:24:33,520 --> 00:24:38,320
when i had previously run

00:24:35,679 --> 00:24:39,279
the tests over a week's worth of

00:24:38,320 --> 00:24:41,440
overnights

00:24:39,279 --> 00:24:43,520
without ever finding a bug so in

00:24:41,440 --> 00:24:44,159
something like one percent of the cpu

00:24:43,520 --> 00:24:47,520
time

00:24:44,159 --> 00:24:49,600
using this instrumentation made my tests

00:24:47,520 --> 00:24:50,960
way more effective and if you're

00:24:49,600 --> 00:24:52,600
interested in learning more you can

00:24:50,960 --> 00:24:53,840
google high profiles or go to

00:24:52,600 --> 00:24:55,279
hyperfuzz.com

00:24:53,840 --> 00:24:59,360
and i have a bunch of documentation

00:24:55,279 --> 00:25:02,799
about how this works and why this works

00:24:59,360 --> 00:25:05,919
it also works for way

00:25:02,799 --> 00:25:09,919
way way way more tests

00:25:05,919 --> 00:25:12,320
so if i run it on my grad

00:25:09,919 --> 00:25:12,320
which is

00:25:13,520 --> 00:25:17,600
if i fuzz my grad

00:25:19,679 --> 00:25:26,240
you're gonna see that we have

00:25:22,799 --> 00:25:28,320
here about as many tests as processes so

00:25:26,240 --> 00:25:29,600
each test runs in its own process does

00:25:28,320 --> 00:25:32,559
its own thing

00:25:29,600 --> 00:25:33,520
but if we have many more tests then we

00:25:32,559 --> 00:25:35,600
split them out

00:25:33,520 --> 00:25:37,440
and each process will work out how to

00:25:35,600 --> 00:25:38,080
prioritize the tests that are making

00:25:37,440 --> 00:25:41,120
progress

00:25:38,080 --> 00:25:42,480
the fastest and so this will take a

00:25:41,120 --> 00:25:44,960
while but i'm basically just going to

00:25:42,480 --> 00:25:46,480
leave it up

00:25:44,960 --> 00:25:49,440
because i think i'm up to the bit where

00:25:46,480 --> 00:25:57,840
i say i'm happy to take questions

00:25:49,440 --> 00:25:57,840
so thank you

00:26:00,320 --> 00:26:06,880
thank you thank you so much zach

00:26:03,919 --> 00:26:07,679
and um yeah i'm sure that you've uh

00:26:06,880 --> 00:26:12,159
tested

00:26:07,679 --> 00:26:12,159
the knowledge of quite a lot of us yeah

00:26:13,520 --> 00:26:19,760
um okay so i think uh we might be a

00:26:18,159 --> 00:26:24,080
little bit out of time

00:26:19,760 --> 00:26:27,919
uh but we could take perhaps one or two

00:26:24,080 --> 00:26:30,640
from the chat if my chat is loading

00:26:27,919 --> 00:26:31,840
could i get uh my producer to maybe send

00:26:30,640 --> 00:26:34,400
some through if

00:26:31,840 --> 00:26:35,760
um possible because i'm having a bit of

00:26:34,400 --> 00:26:40,400
an issue here

00:26:35,760 --> 00:26:40,400
just getting the one to load

00:26:42,559 --> 00:26:47,679
okay most likely

00:26:47,840 --> 00:26:52,880
nope okay we're having a hunt for some

00:26:51,440 --> 00:26:55,520
questions but otherwise

00:26:52,880 --> 00:26:57,360
um i think uh will you be sticking

00:26:55,520 --> 00:26:59,200
around for a little bit afterwards in uh

00:26:57,360 --> 00:27:00,799
the video hallway or yeah i will be in

00:26:59,200 --> 00:27:02,960
the chat

00:27:00,799 --> 00:27:04,559
okay will you be in the video hallway

00:27:02,960 --> 00:27:07,039
chat or in the text

00:27:04,559 --> 00:27:08,240
chat what would you prefer to do oh look

00:27:07,039 --> 00:27:10,880
let's go video chat

00:27:08,240 --> 00:27:12,080
uh but i will check all right chat later

00:27:10,880 --> 00:27:14,880
as well if you want to leave something

00:27:12,080 --> 00:27:17,600
there for me instead

00:27:14,880 --> 00:27:18,559
excellent so oh we have a question

00:27:17,600 --> 00:27:20,880
actually

00:27:18,559 --> 00:27:22,720
from glenn can i ask about functions

00:27:20,880 --> 00:27:25,520
with side effects how useful is

00:27:22,720 --> 00:27:27,919
property-based testing for that

00:27:25,520 --> 00:27:29,360
it is super useful uh property-based

00:27:27,919 --> 00:27:31,039
testing doesn't mean you have to be

00:27:29,360 --> 00:27:31,840
using pure functions without side

00:27:31,039 --> 00:27:34,480
effects

00:27:31,840 --> 00:27:35,840
the only requirement is that each time

00:27:34,480 --> 00:27:37,760
you run the test function

00:27:35,840 --> 00:27:39,440
should be independent so you can have

00:27:37,760 --> 00:27:41,679
whatever side effects you like

00:27:39,440 --> 00:27:43,760
as long as you clean up after yourself

00:27:41,679 --> 00:27:45,760
or your side effects don't affect later

00:27:43,760 --> 00:27:47,600
runs of the same function

00:27:45,760 --> 00:27:49,120
so for example if you write a function

00:27:47,600 --> 00:27:51,440
and it writes a log file

00:27:49,120 --> 00:27:52,399
that's fine if it reads the log file and

00:27:51,440 --> 00:27:53,600
then writes to it

00:27:52,399 --> 00:27:55,360
then you're going to get different

00:27:53,600 --> 00:27:55,840
results if you run with the same input

00:27:55,360 --> 00:27:58,720
twice

00:27:55,840 --> 00:28:00,000
and that could be a problem dave asked

00:27:58,720 --> 00:28:02,240
about numpy

00:28:00,000 --> 00:28:03,120
it totally does work with numpy and we

00:28:02,240 --> 00:28:05,760
even have a whole

00:28:03,120 --> 00:28:07,440
optional sub module for numpy support so

00:28:05,760 --> 00:28:09,360
if you want to define

00:28:07,440 --> 00:28:10,720
tests that generate arrays of particular

00:28:09,360 --> 00:28:13,840
shapes or with

00:28:10,720 --> 00:28:16,240
mutually broadcastable shapes or

00:28:13,840 --> 00:28:18,080
with integer array indexing or like

00:28:16,240 --> 00:28:20,159
anything else you want to do with numpy

00:28:18,080 --> 00:28:23,679
we support it and it works rather well

00:28:20,159 --> 00:28:23,679
for even in numpy's test suite

00:28:23,919 --> 00:28:28,320
excellent thank you so much zach and

00:28:26,880 --> 00:28:30,000
thank you for coming along and being

00:28:28,320 --> 00:28:33,120
part of pike online are you today

00:28:30,000 --> 00:28:34,399
that we're really glad to have you

00:28:33,120 --> 00:28:38,240
all right it's been great and i look

00:28:34,399 --> 00:28:38,240
forward to chatting to everyone later

00:28:38,799 --> 00:28:44,320
awesome so just

00:28:41,840 --> 00:28:45,200
before we close up the curly boy theater

00:28:44,320 --> 00:28:47,440
for

00:28:45,200 --> 00:28:48,960
an hour for a bit of a lunch break or

00:28:47,440 --> 00:28:50,080
whatever kind of break it is for your

00:28:48,960 --> 00:28:52,240
time zone

00:28:50,080 --> 00:28:53,919
um just a reminder that the lightning

00:28:52,240 --> 00:28:56,080
talk submissions close in

00:28:53,919 --> 00:28:57,760
30 minutes so if you want to talk in the

00:28:56,080 --> 00:28:59,840
lightning talks on sunday

00:28:57,760 --> 00:29:01,840
get in now you can visit the sunday

00:28:59,840 --> 00:29:03,679
program page for details

00:29:01,840 --> 00:29:04,880
and remember your talk doesn't have to

00:29:03,679 --> 00:29:06,080
be just about python

00:29:04,880 --> 00:29:08,080
it's just something that you're really

00:29:06,080 --> 00:29:09,840
jazzed about you also don't need to have

00:29:08,080 --> 00:29:11,360
a finished talk in order to submit a

00:29:09,840 --> 00:29:12,320
proposal just an idea of what you want

00:29:11,360 --> 00:29:14,320
to talk about

00:29:12,320 --> 00:29:16,320
so if you visit the sunday page in the

00:29:14,320 --> 00:29:18,000
program all the details you need to sign

00:29:16,320 --> 00:29:21,360
up for lightning talks tomorrow will

00:29:18,000 --> 00:29:23,039
be there and now we are going to go

00:29:21,360 --> 00:29:24,559
for a break for an hour i think and if

00:29:23,039 --> 00:29:37,679
you want to keep chatting to zach

00:29:24,559 --> 00:29:37,679

YouTube URL: https://www.youtube.com/watch?v=tiy031EoDXo


