Title: "Decoding: programming beyond text files" - Nick Moore (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Nick Moore

https://2020.pycon.org.au/program/LYRJGY

We'll explore the history of typewriters and find homoiconicity where you might not
be expecting it.

We'll talk about structured data and explore the early visions of hypertext.

We'll look at some specific examples of unusual programming environments 
and consider how a fresh look at these ideas can be applied to modern development.

And finally we'll consider what a difference this could make to the work of programming.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 16:00:00 2020 at Curlyboi
Captions: 
	00:00:01,040 --> 00:00:06,960
hey folks welcome back to the curly boy

00:00:03,600 --> 00:00:08,240
theater uh we are in our last block of

00:00:06,960 --> 00:00:10,000
talks for the day

00:00:08,240 --> 00:00:11,519
i can't believe we've made it this far

00:00:10,000 --> 00:00:14,719
it's been a good one

00:00:11,519 --> 00:00:15,679
um and next up we have nick moore who's

00:00:14,719 --> 00:00:18,160
going to be

00:00:15,679 --> 00:00:19,439
talking about decoding programming

00:00:18,160 --> 00:00:22,080
beyond text files

00:00:19,439 --> 00:00:23,760
i'm very excited to hear this talk um

00:00:22,080 --> 00:00:25,359
nick is a freelance software consultant

00:00:23,760 --> 00:00:27,359
from melbourne australia

00:00:25,359 --> 00:00:28,960
nick is also online his connection is

00:00:27,359 --> 00:00:30,480
just not up to video streaming at the

00:00:28,960 --> 00:00:31,119
moment but he will be lurking in the

00:00:30,480 --> 00:00:33,600
venulis

00:00:31,119 --> 00:00:34,640
chat so that he will be able to heckle

00:00:33,600 --> 00:00:37,760
himself

00:00:34,640 --> 00:00:39,840
and answer all of your questions for you

00:00:37,760 --> 00:00:41,680
he would also like me to tell you that

00:00:39,840 --> 00:00:43,920
the url on the first slide has a

00:00:41,680 --> 00:00:46,079
transcript of this talk if anybody wants

00:00:43,920 --> 00:00:49,760
that for later

00:00:46,079 --> 00:00:59,840
but other than that i will take

00:00:49,760 --> 00:00:59,840
myself off and let nick start

00:01:02,000 --> 00:01:05,439
we're used to thinking of programs as

00:01:03,600 --> 00:01:07,040
text files according to computing

00:01:05,439 --> 00:01:07,600
folklore the first step on the road to

00:01:07,040 --> 00:01:10,000
being a

00:01:07,600 --> 00:01:12,880
real programmer is to pick a text editor

00:01:10,000 --> 00:01:14,960
that reflects your personal style

00:01:12,880 --> 00:01:16,799
we choose our favorite text editor we

00:01:14,960 --> 00:01:18,400
argue passionately about code formatting

00:01:16,799 --> 00:01:20,000
standards and we feel guilty when our

00:01:18,400 --> 00:01:21,280
diffs are ugly

00:01:20,000 --> 00:01:23,200
but what if these things are just a

00:01:21,280 --> 00:01:27,040
vestigial hangover from computing's

00:01:23,200 --> 00:01:27,840
earliest evolution as gerald weinberg

00:01:27,040 --> 00:01:29,280
says

00:01:27,840 --> 00:01:31,840
things are like they are because they

00:01:29,280 --> 00:01:32,400
got that way complex systems don't just

00:01:31,840 --> 00:01:33,840
happen

00:01:32,400 --> 00:01:35,600
they evolve through a series of

00:01:33,840 --> 00:01:37,840
decisions each of which seemed like a

00:01:35,600 --> 00:01:39,520
good idea at the time

00:01:37,840 --> 00:01:41,119
a lot of the things we take for granted

00:01:39,520 --> 00:01:42,079
in programming come from these early

00:01:41,119 --> 00:01:43,360
decisions

00:01:42,079 --> 00:01:45,520
it's easy to assume that they're

00:01:43,360 --> 00:01:46,960
purposeful even immutable

00:01:45,520 --> 00:01:48,560
in this talk i'll discuss some

00:01:46,960 --> 00:01:50,240
alternatives and where they could

00:01:48,560 --> 00:01:53,439
perhaps lead

00:01:50,240 --> 00:01:55,360
but first some computing history

00:01:53,439 --> 00:01:57,040
this story begins in the mid 19th

00:01:55,360 --> 00:01:58,960
century when the first printing

00:01:57,040 --> 00:02:00,799
telegraphs transformed telegraphy

00:01:58,960 --> 00:02:02,079
from using morse code to using a

00:02:00,799 --> 00:02:03,840
typewriter like keyboard and a

00:02:02,079 --> 00:02:05,920
mechanical printer

00:02:03,840 --> 00:02:07,759
using morse code required an operator to

00:02:05,920 --> 00:02:08,399
tap out a difficult encoding of dots and

00:02:07,759 --> 00:02:10,239
dashes

00:02:08,399 --> 00:02:12,800
and to receive messages by translating

00:02:10,239 --> 00:02:14,640
these audible signals back into letters

00:02:12,800 --> 00:02:15,920
by switching to an automatic encoder

00:02:14,640 --> 00:02:16,480
messages could be sent with less

00:02:15,920 --> 00:02:18,000
training

00:02:16,480 --> 00:02:19,760
and having messages print on paper

00:02:18,000 --> 00:02:21,680
allowed records to be kept

00:02:19,760 --> 00:02:23,120
over the next hundred years or so this

00:02:21,680 --> 00:02:24,000
technology developed into the

00:02:23,120 --> 00:02:25,680
teleprinter

00:02:24,000 --> 00:02:27,520
a device which allowed an operator to

00:02:25,680 --> 00:02:28,239
type a message on a standard typewriter

00:02:27,520 --> 00:02:29,840
keyboard

00:02:28,239 --> 00:02:31,920
and have it printed instantly on the

00:02:29,840 --> 00:02:33,599
other side of the world

00:02:31,920 --> 00:02:35,519
various standards evolve to encode

00:02:33,599 --> 00:02:37,440
characters but eventually most devices

00:02:35,519 --> 00:02:38,480
settle on ascii as a data interchange

00:02:37,440 --> 00:02:41,040
format

00:02:38,480 --> 00:02:42,560
ask you to find 7-bit characters with 32

00:02:41,040 --> 00:02:44,080
control characters used to do things

00:02:42,560 --> 00:02:46,400
like advance the printer paper

00:02:44,080 --> 00:02:47,920
or ring a bell if you've ever wondered

00:02:46,400 --> 00:02:48,800
why your linux terminal thinks it's a

00:02:47,920 --> 00:02:50,800
typewriter

00:02:48,800 --> 00:02:53,840
or why it misbehaves when you cat a

00:02:50,800 --> 00:02:55,680
binary this is why

00:02:53,840 --> 00:02:57,760
during the same period punch cards were

00:02:55,680 --> 00:02:59,120
also being developed as a storage medium

00:02:57,760 --> 00:03:01,680
punch cards were used for machine

00:02:59,120 --> 00:03:03,280
control music and information storage

00:03:01,680 --> 00:03:04,720
a whole industry sprang up to support

00:03:03,280 --> 00:03:05,680
the use of cards for indexing and

00:03:04,720 --> 00:03:07,120
collation

00:03:05,680 --> 00:03:08,959
methods for sorting and searching

00:03:07,120 --> 00:03:10,080
notched cards using long needles were

00:03:08,959 --> 00:03:11,760
invented

00:03:10,080 --> 00:03:13,280
very early computers were developed to

00:03:11,760 --> 00:03:15,519
process cards by counting and

00:03:13,280 --> 00:03:18,239
accumulating values punched into them

00:03:15,519 --> 00:03:19,680
the information age had become there

00:03:18,239 --> 00:03:21,280
were many standards developed for

00:03:19,680 --> 00:03:22,879
machine readable punched cards

00:03:21,280 --> 00:03:24,879
with different dimensions and numbers of

00:03:22,879 --> 00:03:27,599
holes but the ibm

00:03:24,879 --> 00:03:29,120
80 column card introduced in 1928 became

00:03:27,599 --> 00:03:30,080
the most common standard for punched

00:03:29,120 --> 00:03:32,319
cards

00:03:30,080 --> 00:03:34,879
millions of these cards were produced

00:03:32,319 --> 00:03:37,040
the 80 column ibm card led naturally to

00:03:34,879 --> 00:03:38,560
the 80 column ibm video terminal

00:03:37,040 --> 00:03:41,440
each terminal row could display the

00:03:38,560 --> 00:03:43,440
contents of a single punched card

00:03:41,440 --> 00:03:45,519
early languages like fortran began in

00:03:43,440 --> 00:03:47,519
this era they are very line-oriented

00:03:45,519 --> 00:03:49,760
each statement is a single line suitable

00:03:47,519 --> 00:03:51,840
punching into a single card

00:03:49,760 --> 00:03:54,080
punch cards themselves can't easily be

00:03:51,840 --> 00:03:56,400
edited but programs can be corrected and

00:03:54,080 --> 00:03:58,239
rearranged a line at a time by inserting

00:03:56,400 --> 00:03:59,519
removing and replacing cards from the

00:03:58,239 --> 00:04:01,120
deck

00:03:59,519 --> 00:04:03,120
sections of code can be gathered into

00:04:01,120 --> 00:04:04,239
modules held with rubber bands and these

00:04:03,120 --> 00:04:05,840
modules can be copied

00:04:04,239 --> 00:04:07,280
shared between programs and stored on

00:04:05,840 --> 00:04:10,720
shelves literal

00:04:07,280 --> 00:04:12,720
libraries of code to write a program the

00:04:10,720 --> 00:04:15,360
programmer punches statements into cards

00:04:12,720 --> 00:04:16,560
one statement per card when the program

00:04:15,360 --> 00:04:18,320
is ready to be run

00:04:16,560 --> 00:04:20,799
the cards are fed to another program the

00:04:18,320 --> 00:04:22,160
compiler this compiles them into a long

00:04:20,799 --> 00:04:23,759
strip of punch tape

00:04:22,160 --> 00:04:26,000
punch tape is very much denser than

00:04:23,759 --> 00:04:28,240
punched cards with binary representation

00:04:26,000 --> 00:04:29,919
and no extraneous white space but it is

00:04:28,240 --> 00:04:31,199
much harder for humans to read and

00:04:29,919 --> 00:04:33,120
manipulate

00:04:31,199 --> 00:04:34,800
and this split between the continuous

00:04:33,120 --> 00:04:35,520
and the line oriented has continued to

00:04:34,800 --> 00:04:37,199
this day

00:04:35,520 --> 00:04:39,680
with files divided into easily

00:04:37,199 --> 00:04:42,479
manipulated line-oriented text files

00:04:39,680 --> 00:04:44,320
like decks of punched cards and compact

00:04:42,479 --> 00:04:47,680
difficult to edit binary files

00:04:44,320 --> 00:04:49,280
like punch tapes while punched cards

00:04:47,680 --> 00:04:50,000
often had their contents typed along the

00:04:49,280 --> 00:04:51,680
top edge

00:04:50,000 --> 00:04:53,120
actually reading code in this way was

00:04:51,680 --> 00:04:54,479
not very convenient

00:04:53,120 --> 00:04:56,240
so people tended to print out their

00:04:54,479 --> 00:04:58,160
programs for analysis

00:04:56,240 --> 00:04:59,840
pictured here is mit computer scientist

00:04:58,160 --> 00:05:02,000
margaret hamilton with the listings of

00:04:59,840 --> 00:05:04,240
the apollo mission lunar module software

00:05:02,000 --> 00:05:06,240
developed by her and her team there's a

00:05:04,240 --> 00:05:08,479
lot of code there

00:05:06,240 --> 00:05:10,240
printing code continued on into the 90s

00:05:08,479 --> 00:05:10,960
when i first started my computer science

00:05:10,240 --> 00:05:12,720
degree

00:05:10,960 --> 00:05:14,800
most of us accessed the shared unique

00:05:12,720 --> 00:05:15,600
computers through 80 column vt220

00:05:14,800 --> 00:05:16,960
terminals

00:05:15,600 --> 00:05:18,639
and it was pretty normal to print your

00:05:16,960 --> 00:05:19,919
code out on the enormous dot matrix

00:05:18,639 --> 00:05:21,759
printers so you could read it while

00:05:19,919 --> 00:05:24,240
debugging your code on the limited space

00:05:21,759 --> 00:05:26,240
of the 80x25 monitor

00:05:24,240 --> 00:05:27,919
with larger monitors printing code is no

00:05:26,240 --> 00:05:29,840
longer necessary and with increased

00:05:27,919 --> 00:05:32,000
reliance on external libraries

00:05:29,840 --> 00:05:33,199
it's no longer particularly useful

00:05:32,000 --> 00:05:36,320
stacks of printouts

00:05:33,199 --> 00:05:37,759
are a thing of the past line oriented

00:05:36,320 --> 00:05:38,880
files are somewhat of a universal

00:05:37,759 --> 00:05:40,800
standard

00:05:38,880 --> 00:05:42,240
miner quibbles about the interpretation

00:05:40,800 --> 00:05:43,840
of line feeds aside

00:05:42,240 --> 00:05:46,320
pretty much all systems can read and

00:05:43,840 --> 00:05:47,600
edit ascii line-oriented text

00:05:46,320 --> 00:05:50,080
but beyond that there's not much

00:05:47,600 --> 00:05:51,440
agreement on how files are structured

00:05:50,080 --> 00:05:53,600
there have been many attempts to make a

00:05:51,440 --> 00:05:55,919
universal format for structured data

00:05:53,600 --> 00:05:58,319
beginning with the ascii standard itself

00:05:55,919 --> 00:06:01,759
ascii contains four control characters

00:05:58,319 --> 00:06:04,080
fsgs rs and us which stand for

00:06:01,759 --> 00:06:06,960
file separator group separator record

00:06:04,080 --> 00:06:09,039
separator and unit separator

00:06:06,960 --> 00:06:10,800
these provide four levels of record

00:06:09,039 --> 00:06:12,479
structure

00:06:10,800 --> 00:06:14,639
but because they've been difficult to

00:06:12,479 --> 00:06:16,639
enter in a regular text editor

00:06:14,639 --> 00:06:18,240
and because no text editor was really

00:06:16,639 --> 00:06:21,840
written to use them

00:06:18,240 --> 00:06:23,520
they've been largely ignored ever since

00:06:21,840 --> 00:06:26,880
the most widespread structured data

00:06:23,520 --> 00:06:28,880
format is comma-separated values or csv

00:06:26,880 --> 00:06:30,960
this format is not particularly well

00:06:28,880 --> 00:06:32,960
standardized and it's extremely limited

00:06:30,960 --> 00:06:34,800
in what it can express

00:06:32,960 --> 00:06:36,639
but its compatibility with text oriented

00:06:34,800 --> 00:06:37,360
tools makes it a natural bridge between

00:06:36,639 --> 00:06:40,560
the structured

00:06:37,360 --> 00:06:42,720
and the unstructured more recently

00:06:40,560 --> 00:06:44,400
complex structured formats like xml and

00:06:42,720 --> 00:06:45,440
json have attempted to build a better

00:06:44,400 --> 00:06:47,360
bridge

00:06:45,440 --> 00:06:49,520
they're editable in a text editor but

00:06:47,360 --> 00:06:51,120
still possible by the computer

00:06:49,520 --> 00:06:52,880
but these formats are caught between

00:06:51,120 --> 00:06:55,199
being a good binary standard

00:06:52,880 --> 00:06:56,960
and a good text standard they are at

00:06:55,199 --> 00:06:59,199
once defined by their standards as

00:06:56,960 --> 00:07:02,479
recursively passable structured data

00:06:59,199 --> 00:07:04,080
and by convention as line-oriented text

00:07:02,479 --> 00:07:06,160
programming languages have a similar

00:07:04,080 --> 00:07:06,800
problem c is nominally white space

00:07:06,160 --> 00:07:08,479
agnostic

00:07:06,800 --> 00:07:10,479
you can write a c program all on one

00:07:08,479 --> 00:07:12,160
very long line if you're not afraid of

00:07:10,479 --> 00:07:14,160
your co-workers

00:07:12,160 --> 00:07:15,440
c is passed according to a well-defined

00:07:14,160 --> 00:07:17,840
context-free grammar

00:07:15,440 --> 00:07:19,360
so there's no need to worry about lines

00:07:17,840 --> 00:07:21,280
except for the minor issue of c

00:07:19,360 --> 00:07:23,360
preprocessor directives which are line

00:07:21,280 --> 00:07:25,199
oriented and the use of line numbers in

00:07:23,360 --> 00:07:26,800
compiler error messages

00:07:25,199 --> 00:07:28,319
writing either of these languages means

00:07:26,800 --> 00:07:30,000
keeping the compiler's grammar and the

00:07:28,319 --> 00:07:32,319
human reader's expectations in

00:07:30,000 --> 00:07:34,560
sync some languages have a pretty well

00:07:32,319 --> 00:07:36,160
defined right way to layout code in text

00:07:34,560 --> 00:07:38,240
and a tool to enforce it

00:07:36,160 --> 00:07:39,280
python's black and goes go format for

00:07:38,240 --> 00:07:40,880
example

00:07:39,280 --> 00:07:42,080
you can edit your code and then pass it

00:07:40,880 --> 00:07:43,759
through the appropriate tool to make

00:07:42,080 --> 00:07:45,120
sure your formatting agrees exactly with

00:07:43,759 --> 00:07:46,800
the rest of your team

00:07:45,120 --> 00:07:48,160
but you still have to understand both

00:07:46,800 --> 00:07:49,919
worlds

00:07:48,160 --> 00:07:51,360
the programming language lisp is

00:07:49,919 --> 00:07:54,240
famously homoiconic

00:07:51,360 --> 00:07:55,039
meaning same representation lisp

00:07:54,240 --> 00:07:56,840
programs

00:07:55,039 --> 00:07:58,400
manipulate data structures called s

00:07:56,840 --> 00:08:00,800
expressions list

00:07:58,400 --> 00:08:02,400
programs are themselves s expressions so

00:08:00,800 --> 00:08:05,919
it's natural for list programs to

00:08:02,400 --> 00:08:07,919
manipulate other lisp programs

00:08:05,919 --> 00:08:09,919
on the other hand the c standard library

00:08:07,919 --> 00:08:10,960
only has really good support for line

00:08:09,919 --> 00:08:12,639
oriented reads

00:08:10,960 --> 00:08:14,319
and that's what ends up baked into most

00:08:12,639 --> 00:08:15,520
other programming languages including

00:08:14,319 --> 00:08:17,120
python

00:08:15,520 --> 00:08:18,720
so if you're writing a program that

00:08:17,120 --> 00:08:21,039
reads files it's easier

00:08:18,720 --> 00:08:22,639
to write it in a line-oriented way even

00:08:21,039 --> 00:08:23,759
if it is a program for manipulating

00:08:22,639 --> 00:08:25,759
source code

00:08:23,759 --> 00:08:27,599
this is why the c preprocessor and

00:08:25,759 --> 00:08:28,400
revision control systems are all line

00:08:27,599 --> 00:08:31,280
oriented

00:08:28,400 --> 00:08:32,479
it's the easiest way to do it but most

00:08:31,280 --> 00:08:35,120
syntax is not line

00:08:32,479 --> 00:08:36,959
oriented in fact in many languages you

00:08:35,120 --> 00:08:38,399
can write perfectly valid programs all

00:08:36,959 --> 00:08:40,159
on one very long line

00:08:38,399 --> 00:08:42,959
so why are we still writing in text

00:08:40,159 --> 00:08:43,440
files in short we write line-oriented

00:08:42,959 --> 00:08:45,040
code

00:08:43,440 --> 00:08:46,320
because the code we already wrote is

00:08:45,040 --> 00:08:48,000
good at reading and writing

00:08:46,320 --> 00:08:50,240
line-oriented files

00:08:48,000 --> 00:08:51,839
our languages aren't homo-iconic but if

00:08:50,240 --> 00:08:52,480
we're careful with how we format our

00:08:51,839 --> 00:08:55,760
code

00:08:52,480 --> 00:08:57,760
we can pretend they are python doesn't

00:08:55,760 --> 00:08:59,680
execute your python source directly

00:08:57,760 --> 00:09:00,800
instead it first passes it into an

00:08:59,680 --> 00:09:04,080
intermediate format

00:09:00,800 --> 00:09:06,240
the abstract syntax tree or ast

00:09:04,080 --> 00:09:08,160
this is a convenient way to arrange the

00:09:06,240 --> 00:09:10,480
code in memory before compiling it to

00:09:08,160 --> 00:09:12,720
python bytecode

00:09:10,480 --> 00:09:14,240
kt bell talked in more detail about the

00:09:12,720 --> 00:09:16,800
ast earlier today

00:09:14,240 --> 00:09:17,680
but just to summarize the ast is a tree

00:09:16,800 --> 00:09:19,440
of nodes

00:09:17,680 --> 00:09:21,760
each of which represents some part of

00:09:19,440 --> 00:09:22,560
the program an if statement or a block

00:09:21,760 --> 00:09:24,000
of statements

00:09:22,560 --> 00:09:26,640
part of an expression or a single

00:09:24,000 --> 00:09:28,720
identifier for example

00:09:26,640 --> 00:09:31,120
they're arranged in a tree representing

00:09:28,720 --> 00:09:32,880
the non-linear structure of your program

00:09:31,120 --> 00:09:36,160
you can pick under the hood of the ast

00:09:32,880 --> 00:09:38,399
compilation process using the ast module

00:09:36,160 --> 00:09:40,399
when we compile code the compiler has to

00:09:38,399 --> 00:09:41,920
pass it into an ast

00:09:40,399 --> 00:09:44,080
while we're editing the code most

00:09:41,920 --> 00:09:45,519
editors do some kind of parsing just for

00:09:44,080 --> 00:09:47,120
syntax highlighting

00:09:45,519 --> 00:09:48,959
then they write it out to disk as line

00:09:47,120 --> 00:09:50,000
oriented text and the compiler has to

00:09:48,959 --> 00:09:52,800
pass it again

00:09:50,000 --> 00:09:54,399
if it can writing code which doesn't

00:09:52,800 --> 00:09:57,360
compile is kind of useless

00:09:54,399 --> 00:09:59,279
so why not just edit the ast directly an

00:09:57,360 --> 00:10:00,800
editor which worked directly on ast

00:09:59,279 --> 00:10:02,480
nodes would never allow you to write

00:10:00,800 --> 00:10:05,360
syntactically incorrect code

00:10:02,480 --> 00:10:06,399
by definition syntax highlighting would

00:10:05,360 --> 00:10:07,839
become trivial

00:10:06,399 --> 00:10:09,600
you could display the code in whatever

00:10:07,839 --> 00:10:11,839
way suits you fonts

00:10:09,600 --> 00:10:14,320
line lengths indentation sizes are all

00:10:11,839 --> 00:10:16,160
just a style sheet over the ast

00:10:14,320 --> 00:10:18,399
and it's easy to convert the ast to

00:10:16,160 --> 00:10:20,160
python source or a tree-like format such

00:10:18,399 --> 00:10:21,920
as json

00:10:20,160 --> 00:10:24,160
the development environment could also

00:10:21,920 --> 00:10:26,000
compile directly to python bytecode

00:10:24,160 --> 00:10:28,800
and can even keep track of changes and

00:10:26,000 --> 00:10:30,800
update bytecode in place on running code

00:10:28,800 --> 00:10:32,880
i'm a huge fan of rapid development

00:10:30,800 --> 00:10:34,640
cycles waiting to see updates is a

00:10:32,880 --> 00:10:36,640
distraction and a drag

00:10:34,640 --> 00:10:38,399
imagine a development environment smart

00:10:36,640 --> 00:10:40,240
enough to keep track of the bytecodes

00:10:38,399 --> 00:10:42,480
you changed and re-run only the tests

00:10:40,240 --> 00:10:44,560
which executed those bytecodes

00:10:42,480 --> 00:10:46,480
a structured editor has the potential to

00:10:44,560 --> 00:10:48,640
do all this and more

00:10:46,480 --> 00:10:51,200
text editors were a useful way to

00:10:48,640 --> 00:10:53,040
bootstrap a unix development environment

00:10:51,200 --> 00:10:54,480
the same editor could be used to write

00:10:53,040 --> 00:10:57,200
code or edit data

00:10:54,480 --> 00:10:58,560
or write a memo it's the unix worse is

00:10:57,200 --> 00:11:00,399
better philosophy

00:10:58,560 --> 00:11:03,200
simplicity wins out over correctness

00:11:00,399 --> 00:11:05,040
consistency and completeness

00:11:03,200 --> 00:11:06,640
with structured editing we could provide

00:11:05,040 --> 00:11:08,000
an interface to the programmer that

00:11:06,640 --> 00:11:08,720
allowed them to concentrate on

00:11:08,000 --> 00:11:11,600
programming

00:11:08,720 --> 00:11:13,600
not manipulating text by reducing

00:11:11,600 --> 00:11:14,160
languages to a simple grammar of nested

00:11:13,600 --> 00:11:16,720
syntax

00:11:14,160 --> 00:11:18,640
entities plus styling to apply a typical

00:11:16,720 --> 00:11:20,320
presentation for that language

00:11:18,640 --> 00:11:22,240
we can have a single structured editor

00:11:20,320 --> 00:11:23,839
cover many languages

00:11:22,240 --> 00:11:25,360
we could even use our structured editor

00:11:23,839 --> 00:11:27,839
for writing text documents

00:11:25,360 --> 00:11:30,000
after all html and latex are structured

00:11:27,839 --> 00:11:31,920
languages too

00:11:30,000 --> 00:11:33,680
okay so it'd be relatively easy to

00:11:31,920 --> 00:11:35,279
replace the text editor with something

00:11:33,680 --> 00:11:36,959
ast oriented

00:11:35,279 --> 00:11:38,959
a bigger issue for the adoption of

00:11:36,959 --> 00:11:40,480
non-line oriented files is revision

00:11:38,959 --> 00:11:42,240
control

00:11:40,480 --> 00:11:43,760
to allow multiple programmers to work on

00:11:42,240 --> 00:11:45,760
the same file concurrently

00:11:43,760 --> 00:11:47,120
revision control systems must merge

00:11:45,760 --> 00:11:49,120
changes

00:11:47,120 --> 00:11:50,480
first a common ancestor is identified

00:11:49,120 --> 00:11:52,480
and then the changes made by each

00:11:50,480 --> 00:11:54,399
programmer are extracted

00:11:52,480 --> 00:11:56,240
each file is compared to its ancestor

00:11:54,399 --> 00:11:57,040
line by line looking for parts which

00:11:56,240 --> 00:12:00,240
have been added

00:11:57,040 --> 00:12:01,600
removed or modified then the two sets of

00:12:00,240 --> 00:12:03,519
changes are combined

00:12:01,600 --> 00:12:05,360
combining changes is one of those things

00:12:03,519 --> 00:12:07,950
which sounds easy but is remarkably

00:12:05,360 --> 00:12:09,120
difficult with an algorithm form

00:12:07,950 --> 00:12:10,959
[Music]

00:12:09,120 --> 00:12:12,720
the standard diff and merge tools are

00:12:10,959 --> 00:12:15,120
line-oriented they coordinate the

00:12:12,720 --> 00:12:16,959
addition and removal of lines of text

00:12:15,120 --> 00:12:18,800
they have no understanding of the deeper

00:12:16,959 --> 00:12:20,880
syntax or semantics of the file

00:12:18,800 --> 00:12:22,160
and only really work on text files with

00:12:20,880 --> 00:12:24,240
many line breaks

00:12:22,160 --> 00:12:25,279
reformatting or shuffling parts around

00:12:24,240 --> 00:12:27,200
leads to very large

00:12:25,279 --> 00:12:28,959
change sets which rarely merge without

00:12:27,200 --> 00:12:31,200
conflicts

00:12:28,959 --> 00:12:33,120
a conflict arises when multiple changes

00:12:31,200 --> 00:12:34,720
occur to the same section of the code

00:12:33,120 --> 00:12:37,120
and the merge tool cannot determine

00:12:34,720 --> 00:12:38,880
which outcome should take precedence

00:12:37,120 --> 00:12:40,320
generally these conflicts are marked to

00:12:38,880 --> 00:12:43,040
warn the programmer that they will have

00:12:40,320 --> 00:12:45,040
to take manual action to resolve them

00:12:43,040 --> 00:12:46,880
this also means that the output of a

00:12:45,040 --> 00:12:49,519
merger to valid programs is not

00:12:46,880 --> 00:12:51,200
necessarily a valid passable program

00:12:49,519 --> 00:12:53,200
this is problematic for our structured

00:12:51,200 --> 00:12:55,839
editor which has no idea how to handle a

00:12:53,200 --> 00:12:58,240
syntactically invalid program

00:12:55,839 --> 00:12:59,680
however a merged utility which does

00:12:58,240 --> 00:13:00,639
understand the syntax tree of the

00:12:59,680 --> 00:13:02,880
programming language

00:13:00,639 --> 00:13:05,680
can avoid these issues whatever the

00:13:02,880 --> 00:13:07,120
language json or xml c or python

00:13:05,680 --> 00:13:09,600
we can exploit the structure of the

00:13:07,120 --> 00:13:11,680
syntax tree to compare and merge syntax

00:13:09,600 --> 00:13:12,880
tree nodes instead of lines

00:13:11,680 --> 00:13:15,040
instead of just looking for the

00:13:12,880 --> 00:13:15,519
insertion deletion and modification of

00:13:15,040 --> 00:13:17,360
lines

00:13:15,519 --> 00:13:18,639
our change operations become about

00:13:17,360 --> 00:13:20,720
subtrees

00:13:18,639 --> 00:13:22,560
common subtrees can be identified and

00:13:20,720 --> 00:13:23,920
list-like structures such as blocks can

00:13:22,560 --> 00:13:25,760
be merged

00:13:23,920 --> 00:13:27,760
changes where a subtree is moved can be

00:13:25,760 --> 00:13:30,000
identified and treated as a move

00:13:27,760 --> 00:13:32,000
rather than a delete and insert this

00:13:30,000 --> 00:13:33,680
would be a godsend for anyone who's ever

00:13:32,000 --> 00:13:35,360
felt guilty for making a large

00:13:33,680 --> 00:13:37,760
conflicting change by altering the

00:13:35,360 --> 00:13:40,000
indentation of a whole block

00:13:37,760 --> 00:13:42,240
there are some difficulties for a start

00:13:40,000 --> 00:13:44,480
the python ast doesn't encode comments

00:13:42,240 --> 00:13:45,519
which some people may feel are kind of

00:13:44,480 --> 00:13:47,040
important

00:13:45,519 --> 00:13:48,720
they'd have to be added into the tree

00:13:47,040 --> 00:13:50,079
somehow

00:13:48,720 --> 00:13:51,600
the merge tool would have to work out

00:13:50,079 --> 00:13:53,360
how to represent conflicts while

00:13:51,600 --> 00:13:54,800
fulfilling its promise to always emit

00:13:53,360 --> 00:13:56,480
valid code

00:13:54,800 --> 00:13:58,160
when two developers make overlapping

00:13:56,480 --> 00:14:00,160
changes a conflict occurs

00:13:58,160 --> 00:14:01,920
it needs a human to resolve it in

00:14:00,160 --> 00:14:04,399
conventional mergers it's marked with

00:14:01,920 --> 00:14:06,079
some special lines

00:14:04,399 --> 00:14:07,680
the merge program doesn't even bother to

00:14:06,079 --> 00:14:09,680
make these look like program code

00:14:07,680 --> 00:14:11,920
after all the program syntax is almost

00:14:09,680 --> 00:14:14,160
certainly broken anyway

00:14:11,920 --> 00:14:16,320
a structured merge has to emit passable

00:14:14,160 --> 00:14:18,160
code so conflict markers have to be

00:14:16,320 --> 00:14:20,320
inserted as a syntax tree node

00:14:18,160 --> 00:14:21,760
such as a comment and other parts of the

00:14:20,320 --> 00:14:25,120
tree may have to be patched up to

00:14:21,760 --> 00:14:25,120
maintain the correct structure

00:14:25,199 --> 00:14:29,519
the exact rules for how to merge tree

00:14:27,199 --> 00:14:31,519
structures are not easy to define

00:14:29,519 --> 00:14:33,360
how far can a subtree move before we

00:14:31,519 --> 00:14:35,120
treat it as a new subtree

00:14:33,360 --> 00:14:37,360
if one programmer changes the contents

00:14:35,120 --> 00:14:39,440
of a subtree and another program

00:14:37,360 --> 00:14:41,519
duplicates that subtree should the

00:14:39,440 --> 00:14:43,839
changes be inserted twice

00:14:41,519 --> 00:14:45,680
but as the saying goes we do these

00:14:43,839 --> 00:14:47,120
things not because they are easy

00:14:45,680 --> 00:14:48,880
but because we thought they were going

00:14:47,120 --> 00:14:50,639
to be easy

00:14:48,880 --> 00:14:53,680
if we try to merge these change sets

00:14:50,639 --> 00:14:56,839
with a conventional match

00:14:53,680 --> 00:14:59,040
we might end up with a conflict like

00:14:56,839 --> 00:15:00,800
this

00:14:59,040 --> 00:15:02,320
but with the structural merge which

00:15:00,800 --> 00:15:06,000
understands what a block actually

00:15:02,320 --> 00:15:06,000
is we might end up with this

00:15:07,120 --> 00:15:10,880
which while it probably doesn't do what

00:15:09,199 --> 00:15:13,519
you want is at least

00:15:10,880 --> 00:15:16,800
valid positive python and you can edit

00:15:13,519 --> 00:15:16,800
it in your structured editor

00:15:16,880 --> 00:15:19,839
i've talked about history a lot to try

00:15:18,639 --> 00:15:22,399
and explain where a lot of the

00:15:19,839 --> 00:15:24,320
assumptions we make about code come from

00:15:22,399 --> 00:15:26,320
but not every historical system is

00:15:24,320 --> 00:15:28,320
founded on those same assumptions

00:15:26,320 --> 00:15:30,880
back in the 60s ted nelson coined the

00:15:28,320 --> 00:15:33,519
term hypertext as follows

00:15:30,880 --> 00:15:35,920
a body of written or pictorial material

00:15:33,519 --> 00:15:37,680
interconnected in such a complex way

00:15:35,920 --> 00:15:41,839
that it could not be conveniently

00:15:37,680 --> 00:15:43,759
presented or represented on paper

00:15:41,839 --> 00:15:45,360
modern computer systems are definitely

00:15:43,759 --> 00:15:47,279
interconnected and complex

00:15:45,360 --> 00:15:48,560
and cannot be conveniently represented

00:15:47,279 --> 00:15:50,720
on paper

00:15:48,560 --> 00:15:52,000
so presenting them as a printable linear

00:15:50,720 --> 00:15:54,560
80 column document

00:15:52,000 --> 00:15:55,680
is a little strange to come at this from

00:15:54,560 --> 00:15:58,160
another perspective

00:15:55,680 --> 00:16:00,320
here's a rectangle representing the 800

00:15:58,160 --> 00:16:03,759
by 500 pixel resolution

00:16:00,320 --> 00:16:05,519
of the vt220 80 column display

00:16:03,759 --> 00:16:08,079
here's a somewhat larger rectangle

00:16:05,519 --> 00:16:09,759
representing a modern 4k monitor

00:16:08,079 --> 00:16:12,160
we have a lot more room to move these

00:16:09,759 --> 00:16:14,880
days we can even consider

00:16:12,160 --> 00:16:16,240
using graphics freed from worrying about

00:16:14,880 --> 00:16:18,160
our programs as text

00:16:16,240 --> 00:16:20,480
we can present them and work with them

00:16:18,160 --> 00:16:22,240
in a way which is more interesting

00:16:20,480 --> 00:16:24,399
the education sector has begun to

00:16:22,240 --> 00:16:26,320
explore the world of visual programming

00:16:24,399 --> 00:16:28,639
scratch and a number of scratch-like

00:16:26,320 --> 00:16:30,480
imitators move the main input mechanism

00:16:28,639 --> 00:16:31,839
of programming from typing to drag and

00:16:30,480 --> 00:16:33,600
drop

00:16:31,839 --> 00:16:35,839
other environments such as labview and

00:16:33,600 --> 00:16:37,440
code red allow programming by dragging

00:16:35,839 --> 00:16:39,920
connections between nodes

00:16:37,440 --> 00:16:41,680
modeling the flow of signals and data

00:16:39,920 --> 00:16:43,600
these are data flow languages where the

00:16:41,680 --> 00:16:45,279
order of code execution is completely

00:16:43,600 --> 00:16:47,040
unrelated to the way components are

00:16:45,279 --> 00:16:48,560
arranged on the page

00:16:47,040 --> 00:16:50,240
it therefore makes a lot of sense that

00:16:48,560 --> 00:16:53,360
their presentation is mobile

00:16:50,240 --> 00:16:55,040
two-dimensional and non-linear

00:16:53,360 --> 00:16:56,800
spreadsheets are another example of a

00:16:55,040 --> 00:16:58,639
data flow language formulae

00:16:56,800 --> 00:17:00,240
aren't evaluated based on their position

00:16:58,639 --> 00:17:02,880
on the sheet but rather by their

00:17:00,240 --> 00:17:05,760
position within a directed acyclic graph

00:17:02,880 --> 00:17:07,199
of cells while spreadsheets may not be a

00:17:05,760 --> 00:17:08,319
programmer's idea of a programming

00:17:07,199 --> 00:17:08,959
language they are one of the most

00:17:08,319 --> 00:17:11,600
accessible

00:17:08,959 --> 00:17:13,039
and widespread forms of programming

00:17:11,600 --> 00:17:14,400
these sorts of languages have been held

00:17:13,039 --> 00:17:16,079
back by a lack of tooling

00:17:14,400 --> 00:17:18,000
it's hard to get work done effectively

00:17:16,079 --> 00:17:20,480
in a language without the ability to

00:17:18,000 --> 00:17:21,600
merge and track changes efficiently

00:17:20,480 --> 00:17:23,760
but the same is true of more

00:17:21,600 --> 00:17:25,839
conventional languages in javascript for

00:17:23,760 --> 00:17:27,839
example function definitions are hoisted

00:17:25,839 --> 00:17:29,200
to the top of their closing scope

00:17:27,839 --> 00:17:33,600
so for example you can define

00:17:29,200 --> 00:17:35,360
co-recursive functions like this

00:17:33,600 --> 00:17:37,360
these two functions are not really

00:17:35,360 --> 00:17:39,440
defined in any particular order

00:17:37,360 --> 00:17:41,520
it's irrelevant which comes first they

00:17:39,440 --> 00:17:43,679
could be swapped without consequence

00:17:41,520 --> 00:17:45,360
the same is true much of the time for

00:17:43,679 --> 00:17:47,120
python classes and methods

00:17:45,360 --> 00:17:49,520
they refer to each other but the order

00:17:47,120 --> 00:17:51,280
of their declaration is unimportant

00:17:49,520 --> 00:17:53,200
javascript is also famous for its

00:17:51,280 --> 00:17:55,760
callback hell of functions which pass

00:17:53,200 --> 00:17:57,440
pointers to other functions

00:17:55,760 --> 00:17:59,280
this is a close match to the underlying

00:17:57,440 --> 00:18:00,720
event model which reflects the reality

00:17:59,280 --> 00:18:02,480
of network programming

00:18:00,720 --> 00:18:04,880
but it can make reading the code rather

00:18:02,480 --> 00:18:06,640
bewildering one solution to this is to

00:18:04,880 --> 00:18:08,799
use promises to hide the essential

00:18:06,640 --> 00:18:10,480
callback structure of the code

00:18:08,799 --> 00:18:12,080
another solution might be to work out a

00:18:10,480 --> 00:18:13,360
more readable way to represent this

00:18:12,080 --> 00:18:15,280
essential structure

00:18:13,360 --> 00:18:17,520
don't change the event model change the

00:18:15,280 --> 00:18:17,520
view

00:18:18,080 --> 00:18:22,080
inspired by these examples i developed

00:18:19,919 --> 00:18:24,160
flobot a visual data flow based language

00:18:22,080 --> 00:18:26,320
for controlling robotic toys

00:18:24,160 --> 00:18:27,679
sensors and actuators are represented by

00:18:26,320 --> 00:18:28,480
nodes at the top and the bottom of the

00:18:27,679 --> 00:18:30,160
screen

00:18:28,480 --> 00:18:32,000
their shapes indicate their purpose

00:18:30,160 --> 00:18:33,679
sensors only have outputs and actuators

00:18:32,000 --> 00:18:35,360
only have inputs

00:18:33,679 --> 00:18:37,679
there are also functions which have both

00:18:35,360 --> 00:18:39,360
inputs and outputs the robot's behavior

00:18:37,679 --> 00:18:40,240
can be adjusted by dragging connections

00:18:39,360 --> 00:18:43,039
between sensors

00:18:40,240 --> 00:18:44,640
functions and actuators changes to

00:18:43,039 --> 00:18:46,720
connections are reflected in immediate

00:18:44,640 --> 00:18:48,640
changes to the robot's behavior

00:18:46,720 --> 00:18:50,320
invalid connections like connecting

00:18:48,640 --> 00:18:53,039
analog to digital or an output to

00:18:50,320 --> 00:18:54,799
another output are simply not permitted

00:18:53,039 --> 00:18:56,559
i found that this was a great advantage

00:18:54,799 --> 00:18:57,120
in that there are no wrong flowbot

00:18:56,559 --> 00:19:00,000
programs

00:18:57,120 --> 00:19:01,840
only surprising ones the flowbot

00:19:00,000 --> 00:19:04,000
programs are compiled to python which is

00:19:01,840 --> 00:19:04,960
then executed by micropython embedded on

00:19:04,000 --> 00:19:07,039
the robot

00:19:04,960 --> 00:19:08,960
flobot is effectively a visual editor

00:19:07,039 --> 00:19:10,799
for a subset of python

00:19:08,960 --> 00:19:12,640
with a little more work code can be

00:19:10,799 --> 00:19:14,080
flipped between the visual data flow

00:19:12,640 --> 00:19:16,799
representation

00:19:14,080 --> 00:19:18,160
and the native python representation not

00:19:16,799 --> 00:19:19,919
all python syntax

00:19:18,160 --> 00:19:22,160
makes sense in the visual metaphor of

00:19:19,919 --> 00:19:24,160
flowbot so those parts could be rendered

00:19:22,160 --> 00:19:26,080
as a black box function

00:19:24,160 --> 00:19:28,559
but the general shape of the code the

00:19:26,080 --> 00:19:31,520
flow of events from sensors to actuators

00:19:28,559 --> 00:19:33,440
would exist in both representations

00:19:31,520 --> 00:19:35,600
this idea of code having multiple

00:19:33,440 --> 00:19:37,360
representations simultaneously is

00:19:35,600 --> 00:19:39,200
particularly interesting

00:19:37,360 --> 00:19:40,799
different representations might prove

00:19:39,200 --> 00:19:42,240
more effective for different people or

00:19:40,799 --> 00:19:44,000
for different tasks

00:19:42,240 --> 00:19:45,840
perhaps it will prove useful just to

00:19:44,000 --> 00:19:49,440
change your own perspective from time to

00:19:45,840 --> 00:19:51,840
time just to unstick your thinking

00:19:49,440 --> 00:19:53,520
this goes beyond just code if a function

00:19:51,840 --> 00:19:54,559
is a structured piece of information

00:19:53,520 --> 00:19:57,919
within a project

00:19:54,559 --> 00:20:00,320
then so is an issue or a requirement

00:19:57,919 --> 00:20:02,320
we track changes to code very closely

00:20:00,320 --> 00:20:03,120
why not track changes to issues the same

00:20:02,320 --> 00:20:04,559
way

00:20:03,120 --> 00:20:06,240
we have editors capable of

00:20:04,559 --> 00:20:07,760
cross-referencing functions to their

00:20:06,240 --> 00:20:09,200
callers and callees

00:20:07,760 --> 00:20:11,280
perhaps we could do the same with

00:20:09,200 --> 00:20:14,480
requirements and issues and tie every

00:20:11,280 --> 00:20:16,400
line of code to the issue which it fixes

00:20:14,480 --> 00:20:17,919
programs are complicated and structured

00:20:16,400 --> 00:20:19,200
and deserved better than to be treated

00:20:17,919 --> 00:20:21,120
as text files

00:20:19,200 --> 00:20:23,520
perhaps that's true of our documentation

00:20:21,120 --> 00:20:23,520
as well

00:20:25,440 --> 00:20:29,760
now we're thinking of code as trees of

00:20:27,120 --> 00:20:31,919
nodes and documents as trees of nodes

00:20:29,760 --> 00:20:33,600
perhaps it's time to abandon the idea of

00:20:31,919 --> 00:20:36,080
files altogether

00:20:33,600 --> 00:20:38,559
project would be one giant tree perhaps

00:20:36,080 --> 00:20:39,840
an append only structure or a crdt

00:20:38,559 --> 00:20:42,080
into which we would pack all the

00:20:39,840 --> 00:20:42,720
discussion requirements issues code and

00:20:42,080 --> 00:20:45,919
so on

00:20:42,720 --> 00:20:47,840
cross-referenced and change controlled

00:20:45,919 --> 00:20:50,000
our systems are often spread across

00:20:47,840 --> 00:20:52,559
multiple platforms in multiple languages

00:20:50,000 --> 00:20:53,440
often across multiple consonants code

00:20:52,559 --> 00:20:56,000
isn't just code

00:20:53,440 --> 00:20:56,640
there's requirements issues discussions

00:20:56,000 --> 00:20:58,880
tests

00:20:56,640 --> 00:21:01,280
apis and logs all scattered across

00:20:58,880 --> 00:21:02,799
disparate incompatible systems

00:21:01,280 --> 00:21:04,559
to solve a problem we have to jump

00:21:02,799 --> 00:21:07,280
between issues and line numbers

00:21:04,559 --> 00:21:07,919
log messages and version ids imagine for

00:21:07,280 --> 00:21:09,600
a moment

00:21:07,919 --> 00:21:11,760
navigating through all those resources

00:21:09,600 --> 00:21:12,799
seamlessly connecting and correcting as

00:21:11,760 --> 00:21:15,120
you go

00:21:12,799 --> 00:21:16,559
all spread across several million pixels

00:21:15,120 --> 00:21:18,799
in front of you

00:21:16,559 --> 00:21:31,840
it sounds like science fiction what are

00:21:18,799 --> 00:21:31,840
we waiting for

00:21:37,679 --> 00:21:39,760

YouTube URL: https://www.youtube.com/watch?v=Ay6iM_I9694


