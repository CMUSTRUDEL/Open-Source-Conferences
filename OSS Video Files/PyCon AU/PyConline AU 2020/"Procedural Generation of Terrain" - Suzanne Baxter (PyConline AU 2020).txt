Title: "Procedural Generation of Terrain" - Suzanne Baxter (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Suzanne Baxter

https://2020.pycon.org.au/program/KLALFC

Procedural generation is the process of programmatically creating data. Its value is in generating large quantities of similar but not identical assets such as textures and models. This talk will cover the topic of using procedural generation to create a landscape, which will give an illustration of the strengths of procedural generation and ways to overcome its weaknesses.

More specifically, the topics covered are:
- using layered opensimplex noise to create a heightmap, as well as an overview of types of noise and the shortcomings of purely noise-based terrain
- using image processing techniques to add mountain ranges in a manner more consistent with real-world geography than noise alone would allow
- further enhancing the terrain by converting it from a heightmap to voxels, and then applying an erosion simulation

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 13:35:00 2020 at Floperator
Captions: 
	00:00:00,719 --> 00:00:04,960
welcome back everybody um up next we

00:00:03,439 --> 00:00:07,520
have suzanne baxter

00:00:04,960 --> 00:00:08,960
uh suzanne is a mathematical physicist

00:00:07,520 --> 00:00:11,759
and junior lecturer

00:00:08,960 --> 00:00:13,920
for the learn programming academy uh she

00:00:11,759 --> 00:00:15,440
took up python programming during her

00:00:13,920 --> 00:00:16,800
degree independently of her studies

00:00:15,440 --> 00:00:17,520
because it seemed like a good idea at

00:00:16,800 --> 00:00:19,199
the time

00:00:17,520 --> 00:00:21,760
and she asserts that it is still a good

00:00:19,199 --> 00:00:23,519
idea uh we'll be playing a pre-recorded

00:00:21,760 --> 00:00:25,599
talk by her and she'll be in the chat

00:00:23,519 --> 00:00:26,640
answering questions as we go so without

00:00:25,599 --> 00:00:31,840
any further ado

00:00:26,640 --> 00:00:31,840
take it away suzanne

00:00:32,480 --> 00:00:36,960
hello everyone and welcome to my talk on

00:00:34,960 --> 00:00:39,200
procedural generation

00:00:36,960 --> 00:00:40,879
my name is suzanne baxter and i'm a

00:00:39,200 --> 00:00:43,120
freelance python programmer with a

00:00:40,879 --> 00:00:44,719
degree in mathematical physics

00:00:43,120 --> 00:00:46,160
today i'm going to show you how to

00:00:44,719 --> 00:00:48,960
create the terrain

00:00:46,160 --> 00:00:51,280
of an island using procedural generation

00:00:48,960 --> 00:00:53,760
in python

00:00:51,280 --> 00:00:54,800
procedural generation is the process of

00:00:53,760 --> 00:00:57,360
creating something

00:00:54,800 --> 00:00:59,840
programmatically sometimes but not

00:00:57,360 --> 00:01:00,800
always with random or pseudo-random

00:00:59,840 --> 00:01:02,559
elements

00:01:00,800 --> 00:01:04,239
it is most commonly used to create

00:01:02,559 --> 00:01:07,439
levels textures

00:01:04,239 --> 00:01:09,200
and assets for video games it works best

00:01:07,439 --> 00:01:10,000
when you want a lot of similar but not

00:01:09,200 --> 00:01:12,640
identical

00:01:10,000 --> 00:01:13,280
examples of the same thing like plant

00:01:12,640 --> 00:01:16,080
models

00:01:13,280 --> 00:01:18,320
or levels with the same theme another

00:01:16,080 --> 00:01:19,280
benefit of procedural generation is

00:01:18,320 --> 00:01:21,840
saving memory

00:01:19,280 --> 00:01:24,640
by not needing to store as much content

00:01:21,840 --> 00:01:26,720
because it's being generated on demand

00:01:24,640 --> 00:01:28,400
but technology has advanced to the point

00:01:26,720 --> 00:01:29,759
where this is no longer the main

00:01:28,400 --> 00:01:32,079
incentive

00:01:29,759 --> 00:01:34,400
in most disciplines random noise is

00:01:32,079 --> 00:01:37,040
something to be minimized or avoided

00:01:34,400 --> 00:01:38,799
but procedural generation uses it as a

00:01:37,040 --> 00:01:41,840
common raw material

00:01:38,799 --> 00:01:44,640
especially for creating terrain however

00:01:41,840 --> 00:01:45,759
not all noise is equally useful to

00:01:44,640 --> 00:01:48,799
demonstrate

00:01:45,759 --> 00:01:50,320
here's a picture of random noise it has

00:01:48,799 --> 00:01:52,799
a tendency to cluster

00:01:50,320 --> 00:01:53,759
but doesn't have any recognizable

00:01:52,799 --> 00:01:55,439
structure

00:01:53,759 --> 00:01:57,759
it doesn't look like anything in

00:01:55,439 --> 00:01:59,680
particular what we need is something

00:01:57,759 --> 00:02:03,119
that looks random globally

00:01:59,680 --> 00:02:04,079
and acts predictably locally this looks

00:02:03,119 --> 00:02:06,560
a bit better

00:02:04,079 --> 00:02:08,640
this is purlin noise developed by ken

00:02:06,560 --> 00:02:10,680
perlin in 1983

00:02:08,640 --> 00:02:11,840
because of his dissatisfaction with

00:02:10,680 --> 00:02:14,640
computer-generated

00:02:11,840 --> 00:02:16,080
imagery of the time we're not going to

00:02:14,640 --> 00:02:17,920
use it because it has visible

00:02:16,080 --> 00:02:20,239
directional artifacts

00:02:17,920 --> 00:02:22,239
but i'm mentioning it anyway because

00:02:20,239 --> 00:02:24,879
it's historically important

00:02:22,239 --> 00:02:26,640
very commonly used and libraries for

00:02:24,879 --> 00:02:29,040
producing it come built in

00:02:26,640 --> 00:02:30,000
to several game engines what we are

00:02:29,040 --> 00:02:32,720
going to use

00:02:30,000 --> 00:02:33,440
is open simplex noise because it's more

00:02:32,720 --> 00:02:36,160
efficient

00:02:33,440 --> 00:02:37,599
looks better and a python library for it

00:02:36,160 --> 00:02:39,599
already exists

00:02:37,599 --> 00:02:42,239
so we don't have to implement one

00:02:39,599 --> 00:02:44,160
ourselves which is particularly good

00:02:42,239 --> 00:02:47,120
because the mechanism for producing it

00:02:44,160 --> 00:02:49,440
is quite complicated mathematically

00:02:47,120 --> 00:02:50,959
one layer of noise on its own doesn't

00:02:49,440 --> 00:02:53,840
look very impressive

00:02:50,959 --> 00:02:54,160
and the solution to this is to add more

00:02:53,840 --> 00:02:56,239
one

00:02:54,160 --> 00:02:57,599
effective way to do this is to create a

00:02:56,239 --> 00:02:59,840
fractal structure

00:02:57,599 --> 00:03:01,599
by resizing the noise and adding it back

00:02:59,840 --> 00:03:03,440
to itself

00:03:01,599 --> 00:03:05,599
each successive layer of noise has

00:03:03,440 --> 00:03:07,360
structures half the size and magnitude

00:03:05,599 --> 00:03:09,519
half as strong

00:03:07,360 --> 00:03:11,599
for this terrain i used a two

00:03:09,519 --> 00:03:14,800
dimensional numpy array

00:03:11,599 --> 00:03:16,879
and seven layers of noise i also applied

00:03:14,800 --> 00:03:18,800
a circular gradient to force down the

00:03:16,879 --> 00:03:21,599
edges so that it would be an island

00:03:18,800 --> 00:03:22,879
rather than a section of inland terrain

00:03:21,599 --> 00:03:25,440
normalized the height

00:03:22,879 --> 00:03:26,239
and padded the edges a bit at the end of

00:03:25,440 --> 00:03:29,280
this stage

00:03:26,239 --> 00:03:29,760
and after each of the next stage the

00:03:29,280 --> 00:03:32,319
grid

00:03:29,760 --> 00:03:34,480
is saved as a file the end result is a

00:03:32,319 --> 00:03:36,400
height map that looks like this

00:03:34,480 --> 00:03:38,879
you can easily see where i padded the

00:03:36,400 --> 00:03:39,680
edges but that will disappear after the

00:03:38,879 --> 00:03:42,720
erosion

00:03:39,680 --> 00:03:44,799
and the edge would be underwater anyway

00:03:42,720 --> 00:03:47,040
it's not immediately obvious on the

00:03:44,799 --> 00:03:47,760
island but even with a large number of

00:03:47,040 --> 00:03:49,920
layers

00:03:47,760 --> 00:03:51,280
purely noise-based terrain tends to look

00:03:49,920 --> 00:03:54,239
blobby and uniform

00:03:51,280 --> 00:03:56,159
on large scales it looks like a real

00:03:54,239 --> 00:03:57,760
landscape when you take small parts of

00:03:56,159 --> 00:04:00,560
it in isolation

00:03:57,760 --> 00:04:02,720
but not when you consider it as a whole

00:04:00,560 --> 00:04:03,519
there are ways of mitigating this using

00:04:02,720 --> 00:04:06,400
even more

00:04:03,519 --> 00:04:08,159
noise manipulation but that's not what

00:04:06,400 --> 00:04:10,159
we're going to do

00:04:08,159 --> 00:04:12,720
the next thing we're going to do to this

00:04:10,159 --> 00:04:13,680
island is add some mountains along one

00:04:12,720 --> 00:04:15,920
edge

00:04:13,680 --> 00:04:17,519
one of the drawbacks of noise is that it

00:04:15,920 --> 00:04:19,840
doesn't naturally produce

00:04:17,519 --> 00:04:21,359
long and thin structures like mountain

00:04:19,840 --> 00:04:24,080
ranges and rivers

00:04:21,359 --> 00:04:26,000
so i used a different technique i made a

00:04:24,080 --> 00:04:28,160
mask covering the part of the island

00:04:26,000 --> 00:04:30,240
that was above a certain height

00:04:28,160 --> 00:04:31,440
then offset this mask in a random

00:04:30,240 --> 00:04:33,440
direction

00:04:31,440 --> 00:04:35,759
i overlaid the offset version with the

00:04:33,440 --> 00:04:38,000
original and took a sliver of area that

00:04:35,759 --> 00:04:40,400
was covered by one but not the other

00:04:38,000 --> 00:04:43,280
i then used psychic image to reduce that

00:04:40,400 --> 00:04:45,280
sliver to a line warped and blurred it

00:04:43,280 --> 00:04:46,800
and multiplied it by another layer of

00:04:45,280 --> 00:04:48,720
noise to roughen it

00:04:46,800 --> 00:04:51,199
i then added it back to the original

00:04:48,720 --> 00:04:51,199
terrain

00:04:52,240 --> 00:04:55,759
up until this point i've stored the

00:04:54,160 --> 00:04:58,160
terrain as a height map

00:04:55,759 --> 00:05:00,080
which is a 2d grid of values where each

00:04:58,160 --> 00:05:01,919
value represents the height at that

00:05:00,080 --> 00:05:03,919
coordinate

00:05:01,919 --> 00:05:06,320
this is a fairly common format and for

00:05:03,919 --> 00:05:09,440
many genres it's entirely adequate

00:05:06,320 --> 00:05:12,320
but it does have limitations it doesn't

00:05:09,440 --> 00:05:14,080
lend itself well to destructible terrain

00:05:12,320 --> 00:05:16,240
which might be a problem depending on

00:05:14,080 --> 00:05:18,240
what genre of game you're making

00:05:16,240 --> 00:05:19,919
and it doesn't allow for caves and

00:05:18,240 --> 00:05:22,240
overhangs either

00:05:19,919 --> 00:05:23,600
for that reason i converted my height

00:05:22,240 --> 00:05:25,759
map to voxels

00:05:23,600 --> 00:05:27,520
in a three-dimensional grid before i

00:05:25,759 --> 00:05:30,080
applied the erosion

00:05:27,520 --> 00:05:31,840
each entry in the grid represents a cube

00:05:30,080 --> 00:05:34,800
in 3d space

00:05:31,840 --> 00:05:37,680
and each point containing solid ground

00:05:34,800 --> 00:05:40,400
starts with a density value of 1.

00:05:37,680 --> 00:05:42,400
each empty cube has a density value of

00:05:40,400 --> 00:05:44,800
zero

00:05:42,400 --> 00:05:46,320
the general idea behind the hydraulic

00:05:44,800 --> 00:05:48,160
erosion simulation

00:05:46,320 --> 00:05:50,560
is that you have water droplets falling

00:05:48,160 --> 00:05:52,639
as rain onto your landscape

00:05:50,560 --> 00:05:53,680
when a droplet hits the ground and as it

00:05:52,639 --> 00:05:55,759
rolls along

00:05:53,680 --> 00:05:57,039
it picks up earth and dissolves minerals

00:05:55,759 --> 00:05:59,759
which i model

00:05:57,039 --> 00:06:02,000
as subtracting from density of voxels it

00:05:59,759 --> 00:06:04,479
passes over or through

00:06:02,000 --> 00:06:06,479
as it evaporates its capacity to hold

00:06:04,479 --> 00:06:08,319
material diminishes and it starts

00:06:06,479 --> 00:06:11,600
depositing instead

00:06:08,319 --> 00:06:12,400
adding to the voxels over time mountains

00:06:11,600 --> 00:06:15,520
are worn down

00:06:12,400 --> 00:06:17,360
and basins are filled in this part of

00:06:15,520 --> 00:06:19,520
the process was by far the most

00:06:17,360 --> 00:06:22,240
computationally expensive

00:06:19,520 --> 00:06:24,479
taking about 15 minutes per island to do

00:06:22,240 --> 00:06:26,560
25 000 droplets

00:06:24,479 --> 00:06:27,680
while the other processes took only

00:06:26,560 --> 00:06:30,479
seconds

00:06:27,680 --> 00:06:32,240
however this was on one cpu core without

00:06:30,479 --> 00:06:35,280
any parallelization

00:06:32,240 --> 00:06:37,360
optimization or usage of the gpu

00:06:35,280 --> 00:06:40,560
so with a bit of work you can get it to

00:06:37,360 --> 00:06:40,560
go much faster

00:06:40,880 --> 00:06:45,280
the code is quite long so it's spaced

00:06:43,120 --> 00:06:47,520
out over several slides

00:06:45,280 --> 00:06:49,840
first we have our imports some setup

00:06:47,520 --> 00:06:51,599
code and a helper function

00:06:49,840 --> 00:06:53,360
now we have a class for the droplet

00:06:51,599 --> 00:06:56,000
itself with its properties

00:06:53,360 --> 00:06:57,759
it has a velocity a maximum amount of

00:06:56,000 --> 00:07:00,000
material it can carry

00:06:57,759 --> 00:07:01,120
and a location determined randomly on

00:07:00,000 --> 00:07:03,520
creation

00:07:01,120 --> 00:07:05,120
as well as a valid attribute to

00:07:03,520 --> 00:07:08,400
determine when to remove

00:07:05,120 --> 00:07:10,400
that droplet and move on to the next one

00:07:08,400 --> 00:07:12,160
only other properties are either for

00:07:10,400 --> 00:07:14,840
deriving those properties

00:07:12,160 --> 00:07:16,960
or assessing the droplet's immediate

00:07:14,840 --> 00:07:20,000
surroundings

00:07:16,960 --> 00:07:22,479
the is inside method determines whether

00:07:20,000 --> 00:07:25,199
the droplet has rolled off the map

00:07:22,479 --> 00:07:26,960
and eroded in deposit does exactly what

00:07:25,199 --> 00:07:28,960
it sounds like it should do

00:07:26,960 --> 00:07:30,000
eroding from a non-empty voxel in the

00:07:28,960 --> 00:07:32,080
immediate vicinity

00:07:30,000 --> 00:07:34,160
if there is one and the droplet has the

00:07:32,080 --> 00:07:36,479
capacity to carry more earth

00:07:34,160 --> 00:07:40,479
and depositing if it is on the ground

00:07:36,479 --> 00:07:40,479
and has picked up more than it can carry

00:07:42,400 --> 00:07:46,479
the move method accelerates the droplet

00:07:44,960 --> 00:07:48,720
down if it is airborne

00:07:46,479 --> 00:07:49,759
then shifts the droplet into an adjacent

00:07:48,720 --> 00:07:52,160
empty cell

00:07:49,759 --> 00:07:54,319
in a direction as close to its existing

00:07:52,160 --> 00:07:56,879
velocity as possible

00:07:54,319 --> 00:07:58,000
if a change of direction is required the

00:07:56,879 --> 00:08:00,160
droplet's velocity

00:07:58,000 --> 00:08:02,160
is nudged in that direction plus a

00:08:00,160 --> 00:08:04,639
random perturbation

00:08:02,160 --> 00:08:08,560
the check stuck method determines

00:08:04,639 --> 00:08:08,560
whether the droplet has rolled to a stop

00:08:10,080 --> 00:08:14,560
finally we have the main loop which

00:08:12,160 --> 00:08:15,360
alternates between moving and eroding as

00:08:14,560 --> 00:08:18,000
long as it is

00:08:15,360 --> 00:08:20,639
doing so is productive for that droplet

00:08:18,000 --> 00:08:22,240
the simulation does this for 25 000

00:08:20,639 --> 00:08:24,960
drops

00:08:22,240 --> 00:08:27,840
the end result looked like this the

00:08:24,960 --> 00:08:29,919
original on the left for comparison

00:08:27,840 --> 00:08:31,039
as you can see a few things have

00:08:29,919 --> 00:08:33,760
happened

00:08:31,039 --> 00:08:36,240
the first is that the eroded terrain has

00:08:33,760 --> 00:08:39,360
developed several creases and ridges

00:08:36,240 --> 00:08:40,719
around the central peak this was exactly

00:08:39,360 --> 00:08:42,640
what i wanted

00:08:40,719 --> 00:08:44,720
the other thing that has happened is

00:08:42,640 --> 00:08:47,440
that the indentations in land

00:08:44,720 --> 00:08:48,480
have been filled in for an erosion

00:08:47,440 --> 00:08:51,519
simulation

00:08:48,480 --> 00:08:53,600
25 000 droplets is not very many

00:08:51,519 --> 00:08:56,320
so i could have run it for longer for a

00:08:53,600 --> 00:08:58,160
more pronounced effect

00:08:56,320 --> 00:08:59,680
here's the final product in all its

00:08:58,160 --> 00:09:01,760
three-dimensional glory

00:08:59,680 --> 00:09:02,800
i got the 3d mesh from the grid of

00:09:01,760 --> 00:09:05,200
voxels

00:09:02,800 --> 00:09:07,839
using psychic images implementation of

00:09:05,200 --> 00:09:09,839
the marching cube's algorithm

00:09:07,839 --> 00:09:11,200
it's worth noting that no part of the

00:09:09,839 --> 00:09:14,800
process used true

00:09:11,200 --> 00:09:16,560
randomness it was all pseudorandom

00:09:14,800 --> 00:09:19,440
what this means is that while it

00:09:16,560 --> 00:09:22,880
superficially appears random at first

00:09:19,440 --> 00:09:24,320
it's actually deterministic if i run the

00:09:22,880 --> 00:09:27,360
code 10 times

00:09:24,320 --> 00:09:29,680
i get the same result every time

00:09:27,360 --> 00:09:32,080
the pseudo-random generators were all

00:09:29,680 --> 00:09:33,360
seeded with the same number to generate

00:09:32,080 --> 00:09:35,120
their values

00:09:33,360 --> 00:09:36,800
and the island i've been using as an

00:09:35,120 --> 00:09:40,160
example was created

00:09:36,800 --> 00:09:42,560
by using a seed of zero

00:09:40,160 --> 00:09:45,200
by changing the seed i can choose from

00:09:42,560 --> 00:09:48,080
among millions of possible outcomes

00:09:45,200 --> 00:09:50,959
these islands seeds zero through to five

00:09:48,080 --> 00:09:53,040
are just the tip of the iceberg

00:09:50,959 --> 00:09:54,080
the erosion simulation while

00:09:53,040 --> 00:09:56,240
illustrative

00:09:54,080 --> 00:09:59,760
is too slow to use to dynamically

00:09:56,240 --> 00:10:01,839
generate levels for a game

00:09:59,760 --> 00:10:04,399
players are permissive of loading times

00:10:01,839 --> 00:10:05,120
when creating a large world but i would

00:10:04,399 --> 00:10:08,000
like to use

00:10:05,120 --> 00:10:09,120
larger maps and 15 minutes is already

00:10:08,000 --> 00:10:11,360
too long

00:10:09,120 --> 00:10:13,120
for that reason the next step is to

00:10:11,360 --> 00:10:16,160
rewrite the erosion code

00:10:13,120 --> 00:10:18,399
to take full advantage of modern gpus

00:10:16,160 --> 00:10:21,440
however that is a new and separate

00:10:18,399 --> 00:10:23,440
endeavor to be undertaken another time

00:10:21,440 --> 00:10:33,680
so thank you for watching and enjoy the

00:10:23,440 --> 00:10:33,680

YouTube URL: https://www.youtube.com/watch?v=GbEBMNoRfEU


