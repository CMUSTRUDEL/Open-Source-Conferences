Title: Text files full of punctuation? There must be a better way to code.
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Katie Bell

https://2020.pycon.org.au/program/HHPFHW

The vast majority of code is written through some kind of text editor, whether it's notepad, a sophisticated IDE, or a heavily customised Vim environment. These tools mitigate common text editing problems like unclosed brackets and syntax errors, but can't eliminate them completely. 

In this talk we'll explore the underlying nature of code as a tree structure using Python's abstract syntax trees, and we'll compare real world examples of coding interfaces which represent these trees in different ways.

So much of our thinking and tooling revolves around code being represented as text files that to step outside of this world means re-imagining how version control works and what real programming even is.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 11:35:00 2020 at Python 2
Captions: 
	00:00:00,560 --> 00:00:04,319
hello everyone and welcome back to the

00:00:02,000 --> 00:00:06,240
python 2 memorial concert hall

00:00:04,319 --> 00:00:07,759
next up we have katie bell with text

00:00:06,240 --> 00:00:08,880
fast forward punctuation must be a

00:00:07,759 --> 00:00:10,400
better way to code

00:00:08,880 --> 00:00:11,759
katie has been a professional developer

00:00:10,400 --> 00:00:13,360
for more than 10 years and has been a

00:00:11,759 --> 00:00:14,639
friendly face in python communities for

00:00:13,360 --> 00:00:15,839
a lot of that time

00:00:14,639 --> 00:00:17,680
please feel free to share your

00:00:15,839 --> 00:00:19,439
experiences comments and questions and

00:00:17,680 --> 00:00:23,199
chat and venueless throughout to

00:00:19,439 --> 00:00:25,439
join the conversation thank you

00:00:23,199 --> 00:00:27,039
all right let's get into it um my talk

00:00:25,439 --> 00:00:29,840
is there must be

00:00:27,039 --> 00:00:31,760
a better way to code and what i mean by

00:00:29,840 --> 00:00:32,800
this when i talk about the way that it

00:00:31,760 --> 00:00:35,280
is now

00:00:32,800 --> 00:00:35,840
is this process where we write code by

00:00:35,280 --> 00:00:38,960
typing

00:00:35,840 --> 00:00:40,719
characters into a text file right you

00:00:38,960 --> 00:00:42,320
might use an ide you might have the most

00:00:40,719 --> 00:00:46,079
complicated vim macros

00:00:42,320 --> 00:00:47,760
uh ready available to you but ultimately

00:00:46,079 --> 00:00:49,920
most of what we do with code is writing

00:00:47,760 --> 00:00:51,120
characters into a text file

00:00:49,920 --> 00:00:53,680
and this is a pretty good way to write

00:00:51,120 --> 00:00:56,640
code a keyboard is a really fast way

00:00:53,680 --> 00:00:58,320
to enter code into the system and we

00:00:56,640 --> 00:00:59,840
have this idea in our heads

00:00:58,320 --> 00:01:01,440
that when we write code if we're a

00:00:59,840 --> 00:01:01,920
really great programmer we look like

00:01:01,440 --> 00:01:04,479
this

00:01:01,920 --> 00:01:05,040
and we're typing line after line really

00:01:04,479 --> 00:01:06,560
fast

00:01:05,040 --> 00:01:08,080
uh and the computer's doing exactly what

00:01:06,560 --> 00:01:10,479
we want

00:01:08,080 --> 00:01:11,520
but i have spent a lot of time watching

00:01:10,479 --> 00:01:13,840
people write code

00:01:11,520 --> 00:01:14,880
i've done a bunch of teaching i have

00:01:13,840 --> 00:01:16,799
done pair programming

00:01:14,880 --> 00:01:18,479
i've done live coding interviews and

00:01:16,799 --> 00:01:19,600
i've even watched people live stream

00:01:18,479 --> 00:01:22,560
their coding process

00:01:19,600 --> 00:01:23,520
online and when people write code it

00:01:22,560 --> 00:01:25,680
doesn't look like

00:01:23,520 --> 00:01:26,640
they're typing super fast what it looks

00:01:25,680 --> 00:01:28,479
like

00:01:26,640 --> 00:01:30,000
is something like this it's actually

00:01:28,479 --> 00:01:31,600
quite awkward to watch so i'm gonna put

00:01:30,000 --> 00:01:33,439
you through a little bit of that pain

00:01:31,600 --> 00:01:34,640
and we're gonna watch uh someone write

00:01:33,439 --> 00:01:37,280
code

00:01:34,640 --> 00:01:38,840
and this is in vs code just ignore the

00:01:37,280 --> 00:01:42,880
things that pop up vs code is doing its

00:01:38,840 --> 00:01:44,399
thing uh and so we write code

00:01:42,880 --> 00:01:46,240
okay we haven't made any mistakes yet it

00:01:44,399 --> 00:01:47,759
seems pretty fluent um

00:01:46,240 --> 00:01:49,040
write another line of code all right

00:01:47,759 --> 00:01:50,479
we're taking that people variable we're

00:01:49,040 --> 00:01:52,720
dividing it

00:01:50,479 --> 00:01:54,320
uh okay but there's a problem here that

00:01:52,720 --> 00:01:55,920
people variable is coming out as a

00:01:54,320 --> 00:01:57,360
string from the input function and now

00:01:55,920 --> 00:01:58,079
we're trying to divide it so we need to

00:01:57,360 --> 00:02:01,520
fix that

00:01:58,079 --> 00:02:02,159
so we go back uh we go back to the

00:02:01,520 --> 00:02:04,159
beginning

00:02:02,159 --> 00:02:05,200
we wrap it in an in function we then

00:02:04,159 --> 00:02:07,520
have to go to the end

00:02:05,200 --> 00:02:08,800
and add the close bracket and we want to

00:02:07,520 --> 00:02:11,599
change this print function a little bit

00:02:08,800 --> 00:02:14,640
oh so there's a typo there we fix that

00:02:11,599 --> 00:02:18,000
we add another string to this

00:02:14,640 --> 00:02:19,040
and then we go back well we need to make

00:02:18,000 --> 00:02:21,040
that into a string

00:02:19,040 --> 00:02:23,360
so we can add it to the other string so

00:02:21,040 --> 00:02:25,840
we go back we move the cursor over

00:02:23,360 --> 00:02:27,440
and then we put the uh the close bracket

00:02:25,840 --> 00:02:28,400
in we put the close bracket in the wrong

00:02:27,440 --> 00:02:29,920
place

00:02:28,400 --> 00:02:31,599
and it's still synthetically valid but

00:02:29,920 --> 00:02:33,040
we then need to fix up the white space

00:02:31,599 --> 00:02:35,920
so we've done a little bit of extra work

00:02:33,040 --> 00:02:36,879
there just to sort of tidy up the code

00:02:35,920 --> 00:02:38,959
and

00:02:36,879 --> 00:02:40,480
this is not a terrible way to write code

00:02:38,959 --> 00:02:41,280
but i want to look in a little bit

00:02:40,480 --> 00:02:42,959
closer

00:02:41,280 --> 00:02:44,640
at what's actually going on as we're

00:02:42,959 --> 00:02:46,400
writing those edits because we're not

00:02:44,640 --> 00:02:48,879
just writing lines of code

00:02:46,400 --> 00:02:50,000
left to right top to bottom we go back

00:02:48,879 --> 00:02:53,040
we edit the code we

00:02:50,000 --> 00:02:55,040
fix things we change it so

00:02:53,040 --> 00:02:56,239
looking at this program uh in case you

00:02:55,040 --> 00:02:57,840
hadn't already figured it out

00:02:56,239 --> 00:02:59,760
uh this program is a thing to help us

00:02:57,840 --> 00:03:02,640
divide up the tim tams in a packet so

00:02:59,760 --> 00:03:03,120
tim tams uh come with 11 biscuits in a

00:03:02,640 --> 00:03:05,360
packet

00:03:03,120 --> 00:03:06,879
that is difficult to divide up because

00:03:05,360 --> 00:03:08,640
it's a prime number so we have a little

00:03:06,879 --> 00:03:11,280
program to help us

00:03:08,640 --> 00:03:12,720
and this program asks how many people

00:03:11,280 --> 00:03:13,519
want tim tams maybe there are four

00:03:12,720 --> 00:03:15,519
people

00:03:13,519 --> 00:03:17,280
that means everyone can get two terms

00:03:15,519 --> 00:03:18,800
each but then there are three left over

00:03:17,280 --> 00:03:21,440
that we'll have to fight over

00:03:18,800 --> 00:03:22,879
so fairly simple little program we're

00:03:21,440 --> 00:03:23,440
going to dive into what is actually

00:03:22,879 --> 00:03:25,599
going on

00:03:23,440 --> 00:03:27,680
as we're writing this program and when

00:03:25,599 --> 00:03:29,120
you run a python program

00:03:27,680 --> 00:03:32,239
this is the process that it goes through

00:03:29,120 --> 00:03:33,280
you start off with a text file

00:03:32,239 --> 00:03:35,440
and when you give it to the python

00:03:33,280 --> 00:03:36,560
interpreter the first thing it does is

00:03:35,440 --> 00:03:40,000
pass that file

00:03:36,560 --> 00:03:42,560
into the asd the abstract syntax tree

00:03:40,000 --> 00:03:43,040
and that ast uh is the structure of the

00:03:42,560 --> 00:03:45,440
code

00:03:43,040 --> 00:03:46,080
that is then used to generate the byte

00:03:45,440 --> 00:03:48,400
code

00:03:46,080 --> 00:03:49,120
that then is run in the python virtual

00:03:48,400 --> 00:03:51,360
machine

00:03:49,120 --> 00:03:52,480
as you're executing your python code and

00:03:51,360 --> 00:03:56,239
we're going to zoom in

00:03:52,480 --> 00:03:58,239
on this uh ast part and have a look

00:03:56,239 --> 00:03:59,439
at what is the ast for that code that we

00:03:58,239 --> 00:04:02,560
just wrote

00:03:59,439 --> 00:04:03,599
and conveniently python has a module

00:04:02,560 --> 00:04:06,560
called ast

00:04:03,599 --> 00:04:07,120
which lets us inspect and manipulate and

00:04:06,560 --> 00:04:11,360
edit

00:04:07,120 --> 00:04:13,120
the ast for a piece of code so

00:04:11,360 --> 00:04:14,799
it's very simple to use i absolutely

00:04:13,120 --> 00:04:17,680
recommend trying this at home

00:04:14,799 --> 00:04:19,759
uh you can use ast.pars and you give it

00:04:17,680 --> 00:04:23,120
the code

00:04:19,759 --> 00:04:24,639
and it gives you back a tree

00:04:23,120 --> 00:04:26,479
and that tree is the tree structure

00:04:24,639 --> 00:04:28,639
representation of the code and there's a

00:04:26,479 --> 00:04:31,120
convenient ast.dump function

00:04:28,639 --> 00:04:32,560
which lets you dump out uh the tree so

00:04:31,120 --> 00:04:34,639
you can have a look at it

00:04:32,560 --> 00:04:35,919
and it looks something like this uh

00:04:34,639 --> 00:04:38,880
don't bother reading this

00:04:35,919 --> 00:04:39,440
we're gonna break it down so at the top

00:04:38,880 --> 00:04:41,759
level

00:04:39,440 --> 00:04:43,840
this tree structure starts with a module

00:04:41,759 --> 00:04:44,639
and that module has a body in it and in

00:04:43,840 --> 00:04:46,800
that body

00:04:44,639 --> 00:04:48,080
we have a list of statements that make

00:04:46,800 --> 00:04:49,919
up our program

00:04:48,080 --> 00:04:52,560
and this program has three statements

00:04:49,919 --> 00:04:54,720
the first one is an assignment statement

00:04:52,560 --> 00:04:56,479
and then there are two expressions where

00:04:54,720 --> 00:04:58,479
we're calling a function sorry function

00:04:56,479 --> 00:05:00,160
call expression

00:04:58,479 --> 00:05:02,000
and so the top level of our structure

00:05:00,160 --> 00:05:04,560
looks a little bit like this

00:05:02,000 --> 00:05:05,440
but as we were writing the code uh we

00:05:04,560 --> 00:05:07,440
started off

00:05:05,440 --> 00:05:08,800
with the first line of valid code that

00:05:07,440 --> 00:05:12,479
we wrote looked like

00:05:08,800 --> 00:05:15,199
this right we had uh our assignment

00:05:12,479 --> 00:05:16,960
statement and we're assigning to the

00:05:15,199 --> 00:05:18,720
people variable

00:05:16,960 --> 00:05:20,880
and the value that we're giving to that

00:05:18,720 --> 00:05:24,320
people variable we get from

00:05:20,880 --> 00:05:26,080
another function call expression

00:05:24,320 --> 00:05:27,440
and the arguments to that function call

00:05:26,080 --> 00:05:29,520
expression are

00:05:27,440 --> 00:05:31,039
a string and that string is the how many

00:05:29,520 --> 00:05:33,199
people want tim tam's

00:05:31,039 --> 00:05:35,520
string so we have a little tree

00:05:33,199 --> 00:05:37,039
structure it's a fairly simple structure

00:05:35,520 --> 00:05:39,440
i have simplified it a little bit from

00:05:37,039 --> 00:05:42,320
what it does look like in the ast

00:05:39,440 --> 00:05:44,320
but when we add that int so that we're

00:05:42,320 --> 00:05:45,840
converting this to an integer

00:05:44,320 --> 00:05:47,360
before we store it in the people

00:05:45,840 --> 00:05:50,080
variable we

00:05:47,360 --> 00:05:50,560
got another node in our abstract syntax

00:05:50,080 --> 00:05:52,880
tree

00:05:50,560 --> 00:05:53,759
now and that is another call to the in

00:05:52,880 --> 00:05:56,160
function

00:05:53,759 --> 00:05:58,080
and we haven't changed any of the other

00:05:56,160 --> 00:05:58,720
nodes in our tree we've just added one

00:05:58,080 --> 00:06:00,880
in

00:05:58,720 --> 00:06:02,560
and even though we did two edits to our

00:06:00,880 --> 00:06:04,240
line of code one at the beginning and

00:06:02,560 --> 00:06:07,680
one at the end

00:06:04,240 --> 00:06:10,080
we have done one operation to our tree

00:06:07,680 --> 00:06:11,199
looking at the next line we started out

00:06:10,080 --> 00:06:13,199
with a fairly simple

00:06:11,199 --> 00:06:14,560
okay we're printing the people variable

00:06:13,199 --> 00:06:16,880
divided by 11.

00:06:14,560 --> 00:06:18,400
and here we have uh that division sign

00:06:16,880 --> 00:06:21,199
the integer division

00:06:18,400 --> 00:06:22,240
is the binary binary operator called

00:06:21,199 --> 00:06:25,039
floor div

00:06:22,240 --> 00:06:25,600
in the as team now florida has a left

00:06:25,039 --> 00:06:27,840
side

00:06:25,600 --> 00:06:29,840
and a right side where it divides the

00:06:27,840 --> 00:06:31,759
left side by the right side

00:06:29,840 --> 00:06:34,720
and the result of that binary operation

00:06:31,759 --> 00:06:37,680
is then given to the print function

00:06:34,720 --> 00:06:38,639
which then prints it and when we added

00:06:37,680 --> 00:06:41,360
to this

00:06:38,639 --> 00:06:42,639
we added a another string so we have

00:06:41,360 --> 00:06:45,199
another operation

00:06:42,639 --> 00:06:47,039
a binary add operation so these

00:06:45,199 --> 00:06:47,600
operators aren't just kind of going left

00:06:47,039 --> 00:06:50,560
to right

00:06:47,600 --> 00:06:52,000
they are structured in this tree so our

00:06:50,560 --> 00:06:55,039
add operation

00:06:52,000 --> 00:06:56,000
takes the result of the division

00:06:55,039 --> 00:06:58,319
operation

00:06:56,000 --> 00:06:59,039
and then adds it to a string now this is

00:06:58,319 --> 00:07:01,599
going to cause an

00:06:59,039 --> 00:07:02,800
error so we need to do one more edit we

00:07:01,599 --> 00:07:06,960
need to add

00:07:02,800 --> 00:07:09,680
a string function add a call to the stir

00:07:06,960 --> 00:07:11,039
to convert that integer into a string

00:07:09,680 --> 00:07:13,440
before we do the addition

00:07:11,039 --> 00:07:14,720
so that is adding another node into the

00:07:13,440 --> 00:07:16,080
tree

00:07:14,720 --> 00:07:18,720
and the technique i want you to get from

00:07:16,080 --> 00:07:19,520
this is that when we are editing the

00:07:18,720 --> 00:07:22,479
code

00:07:19,520 --> 00:07:23,840
we're not just editing characters in a

00:07:22,479 --> 00:07:26,880
text file

00:07:23,840 --> 00:07:29,919
we are doing tree operations on

00:07:26,880 --> 00:07:30,800
our code tree fundamental structure of

00:07:29,919 --> 00:07:33,360
code

00:07:30,800 --> 00:07:35,280
is a tree and when we edit that code

00:07:33,360 --> 00:07:36,400
we're doing operations on that tree we

00:07:35,280 --> 00:07:38,240
are adding nodes

00:07:36,400 --> 00:07:39,759
we are removing nodes to that tree and

00:07:38,240 --> 00:07:41,199
we are taking some nodes

00:07:39,759 --> 00:07:42,960
and moving them to reattach them

00:07:41,199 --> 00:07:44,800
somewhere else

00:07:42,960 --> 00:07:46,240
and you can express all of the

00:07:44,800 --> 00:07:48,960
operations that you do on code

00:07:46,240 --> 00:07:49,840
in this kind of form and when you're

00:07:48,960 --> 00:07:51,599
writing code

00:07:49,840 --> 00:07:53,759
even though you're writing code in a

00:07:51,599 --> 00:07:57,520
text file what you're doing

00:07:53,759 --> 00:07:59,759
in your head is manipulating this tree

00:07:57,520 --> 00:08:01,199
and then translating the change that you

00:07:59,759 --> 00:08:03,280
want in the tree

00:08:01,199 --> 00:08:04,800
back into the code and you do this

00:08:03,280 --> 00:08:06,160
mostly without realizing that you're

00:08:04,800 --> 00:08:09,360
operating on a tree

00:08:06,160 --> 00:08:11,120
in your head and

00:08:09,360 --> 00:08:12,400
the question i want you to be asking is

00:08:11,120 --> 00:08:15,680
why do we do it

00:08:12,400 --> 00:08:17,599
this way right we have a text file

00:08:15,680 --> 00:08:18,800
we convert it into a tree but it was

00:08:17,599 --> 00:08:21,039
already in my head

00:08:18,800 --> 00:08:23,120
as a tree then that tree is converted

00:08:21,039 --> 00:08:26,560
into bytecode and that by code is run

00:08:23,120 --> 00:08:28,960
on the python virtual machine and

00:08:26,560 --> 00:08:30,960
we could have it work in a different way

00:08:28,960 --> 00:08:33,599
we could have something else

00:08:30,960 --> 00:08:35,360
something else that will construct this

00:08:33,599 --> 00:08:36,320
abstract syntax tree some other

00:08:35,360 --> 00:08:38,399
interface

00:08:36,320 --> 00:08:39,599
where we could manipulate our abstract

00:08:38,399 --> 00:08:42,719
syntax tree

00:08:39,599 --> 00:08:43,360
and write our code without it having to

00:08:42,719 --> 00:08:46,880
use

00:08:43,360 --> 00:08:48,880
that text form if the ast

00:08:46,880 --> 00:08:50,800
for python isn't exactly what we want

00:08:48,880 --> 00:08:52,080
maybe we have a different tree structure

00:08:50,800 --> 00:08:54,399
and that different tree structure could

00:08:52,080 --> 00:08:57,360
generate bytecode there's no reason

00:08:54,399 --> 00:08:58,160
we can't do these things and in fact

00:08:57,360 --> 00:09:00,399
people have

00:08:58,160 --> 00:09:02,320
not necessarily with python although i

00:09:00,399 --> 00:09:05,279
have seen it done with python

00:09:02,320 --> 00:09:06,240
but there are coding interfaces that are

00:09:05,279 --> 00:09:09,440
out there

00:09:06,240 --> 00:09:10,080
that are not text-based files where the

00:09:09,440 --> 00:09:11,760
code is

00:09:10,080 --> 00:09:13,279
a bunch of characters sitting in a text

00:09:11,760 --> 00:09:15,920
file

00:09:13,279 --> 00:09:18,240
and generally we would call these visual

00:09:15,920 --> 00:09:19,839
coding or visual coding interfaces

00:09:18,240 --> 00:09:22,000
and we're going to go through a couple

00:09:19,839 --> 00:09:23,839
of example visual coding interfaces to

00:09:22,000 --> 00:09:25,040
see how they work and see how their tree

00:09:23,839 --> 00:09:27,920
structure works

00:09:25,040 --> 00:09:29,680
and what the pros and cons are for these

00:09:27,920 --> 00:09:32,000
visual interfaces

00:09:29,680 --> 00:09:34,240
and when i talk to people about visual

00:09:32,000 --> 00:09:36,959
coding and interfaces other than text

00:09:34,240 --> 00:09:37,680
one of the ones that comes up the most

00:09:36,959 --> 00:09:39,839
is scratch

00:09:37,680 --> 00:09:41,120
because it is really popular and a lot

00:09:39,839 --> 00:09:42,959
of people have maybe not

00:09:41,120 --> 00:09:45,519
not always used it but at least seen it

00:09:42,959 --> 00:09:47,519
or heard of it and it is very popular

00:09:45,519 --> 00:09:49,200
interface that helps beginner

00:09:47,519 --> 00:09:52,000
programmers and students

00:09:49,200 --> 00:09:53,839
and kids learn to code for the first

00:09:52,000 --> 00:09:57,279
time in a way that's easier

00:09:53,839 --> 00:10:00,560
than writing a text file and

00:09:57,279 --> 00:10:02,720
it looks like this once it loads so

00:10:00,560 --> 00:10:04,160
we have a series of blocks and those

00:10:02,720 --> 00:10:06,320
blocks make up our program

00:10:04,160 --> 00:10:08,000
and when we want to add a new block we

00:10:06,320 --> 00:10:09,040
don't need to magically know what it is

00:10:08,000 --> 00:10:11,040
that we want to type

00:10:09,040 --> 00:10:12,240
we can search through the list of blocks

00:10:11,040 --> 00:10:15,120
to find something

00:10:12,240 --> 00:10:16,720
that we want to add and we can insert it

00:10:15,120 --> 00:10:18,640
into the program

00:10:16,720 --> 00:10:20,640
and you'll notice that we have binary

00:10:18,640 --> 00:10:23,440
operators like we saw

00:10:20,640 --> 00:10:24,800
in our ast and those binary operators we

00:10:23,440 --> 00:10:26,800
can then kind of put

00:10:24,800 --> 00:10:29,120
into the code so when we're writing the

00:10:26,800 --> 00:10:32,079
code we're generally doing

00:10:29,120 --> 00:10:34,079
again more tree operations by

00:10:32,079 --> 00:10:37,200
manipulating the structure of the code

00:10:34,079 --> 00:10:38,720
in a visual way and scratch is a really

00:10:37,200 --> 00:10:40,160
great language there's a reason that it

00:10:38,720 --> 00:10:42,480
is so popular

00:10:40,160 --> 00:10:44,399
for teachers and for kids because it is

00:10:42,480 --> 00:10:46,320
really easy to get started with

00:10:44,399 --> 00:10:48,720
and it's very easy to understand and

00:10:46,320 --> 00:10:51,760
manipulate the code even if you've never

00:10:48,720 --> 00:10:53,839
seen code or understood code before uh

00:10:51,760 --> 00:10:55,600
but it is not something that you would

00:10:53,839 --> 00:10:57,600
see people using in the real world as

00:10:55,600 --> 00:10:59,040
like a paid professional programmer

00:10:57,600 --> 00:11:01,680
um and there are a number of reasons for

00:10:59,040 --> 00:11:02,959
this this is absolutely not what scratch

00:11:01,680 --> 00:11:05,760
was intended to do

00:11:02,959 --> 00:11:07,680
um it has a fairly slow run time people

00:11:05,760 --> 00:11:10,399
have made amazing programs in scratch

00:11:07,680 --> 00:11:11,600
little platformer games and quite

00:11:10,399 --> 00:11:13,200
complicated things

00:11:11,600 --> 00:11:14,959
but it still isn't at the level of

00:11:13,200 --> 00:11:17,680
performance that you would get from

00:11:14,959 --> 00:11:19,040
from professional tools it is not

00:11:17,680 --> 00:11:20,560
something that people would use in the

00:11:19,040 --> 00:11:21,360
real world for some kind of product that

00:11:20,560 --> 00:11:24,640
they wanted to

00:11:21,360 --> 00:11:27,360
sell and it has a fairly limited

00:11:24,640 --> 00:11:28,000
set of functionality that is not the

00:11:27,360 --> 00:11:29,519
level of

00:11:28,000 --> 00:11:31,760
range and freedom and low-level

00:11:29,519 --> 00:11:33,360
functions that are available to you

00:11:31,760 --> 00:11:34,880
in a more mainstream programming

00:11:33,360 --> 00:11:36,399
language or a text-based programming

00:11:34,880 --> 00:11:38,240
language

00:11:36,399 --> 00:11:40,240
but the biggest criticism and this is

00:11:38,240 --> 00:11:41,680
the one that kids butt up against

00:11:40,240 --> 00:11:44,079
once they have been doing scratch for a

00:11:41,680 --> 00:11:46,079
while is even though you know

00:11:44,079 --> 00:11:47,279
exactly what block you want to put into

00:11:46,079 --> 00:11:49,600
your program next

00:11:47,279 --> 00:11:50,399
you have to go and find it and drag it

00:11:49,600 --> 00:11:53,040
over

00:11:50,399 --> 00:11:54,000
and that process is slow it's great for

00:11:53,040 --> 00:11:55,519
when you're beginning

00:11:54,000 --> 00:11:57,600
you don't know what block it is that you

00:11:55,519 --> 00:11:59,519
want to use next but

00:11:57,600 --> 00:12:01,680
when you have i've been doing scratch

00:11:59,519 --> 00:12:03,200
for a while it becomes very tedious to

00:12:01,680 --> 00:12:04,959
have to go and search for the block that

00:12:03,200 --> 00:12:06,880
you want

00:12:04,959 --> 00:12:08,480
so we're going to go through these one

00:12:06,880 --> 00:12:09,040
at a time because these are often things

00:12:08,480 --> 00:12:11,279
that

00:12:09,040 --> 00:12:12,480
are cited as to reasons why visual

00:12:11,279 --> 00:12:15,600
coding doesn't

00:12:12,480 --> 00:12:16,480
work or can't work and i want to debunk

00:12:15,600 --> 00:12:19,040
those

00:12:16,480 --> 00:12:20,000
the first one is a slow run time we've

00:12:19,040 --> 00:12:23,200
already kind of seen

00:12:20,000 --> 00:12:25,360
that we could create an ast

00:12:23,200 --> 00:12:27,279
or some kind of tree structure and then

00:12:25,360 --> 00:12:29,279
use one of our existing

00:12:27,279 --> 00:12:30,399
runtimes like the python runtime or we

00:12:29,279 --> 00:12:32,720
could compile it

00:12:30,399 --> 00:12:34,079
there's uh there's no reason why a

00:12:32,720 --> 00:12:34,959
visual coding language has to have a

00:12:34,079 --> 00:12:36,160
slow runtime

00:12:34,959 --> 00:12:39,040
so we're just going to move past that

00:12:36,160 --> 00:12:40,480
one but the no real world used one

00:12:39,040 --> 00:12:42,320
uh is interesting because there are

00:12:40,480 --> 00:12:44,959
visual coding languages out there

00:12:42,320 --> 00:12:45,680
that uh you might not have seen or heard

00:12:44,959 --> 00:12:47,920
of

00:12:45,680 --> 00:12:49,760
uh that do have real world use and the

00:12:47,920 --> 00:12:53,519
first one i want to focus on

00:12:49,760 --> 00:12:55,360
is from unreal engine and you might have

00:12:53,519 --> 00:12:56,399
heard of unreal engine uh if not you

00:12:55,360 --> 00:12:57,440
might have heard of some of the games

00:12:56,399 --> 00:12:58,000
that have been written with unreal

00:12:57,440 --> 00:13:00,560
engine

00:12:58,000 --> 00:13:01,279
like bioshock or fortnite an unreal

00:13:00,560 --> 00:13:04,240
engine

00:13:01,279 --> 00:13:05,680
has a visual coding system in it built

00:13:04,240 --> 00:13:07,760
into the tooling

00:13:05,680 --> 00:13:09,200
so as an example we're going to look at

00:13:07,760 --> 00:13:11,680
this little game

00:13:09,200 --> 00:13:13,360
where there is a player and on the

00:13:11,680 --> 00:13:15,760
ground there's a kind of white

00:13:13,360 --> 00:13:16,800
panel this is our box and we're going to

00:13:15,760 --> 00:13:19,440
look at the code

00:13:16,800 --> 00:13:20,000
for what happens when that box is

00:13:19,440 --> 00:13:23,200
interacting

00:13:20,000 --> 00:13:24,720
with something so this is

00:13:23,200 --> 00:13:27,040
uh blueprints and i have taken this

00:13:24,720 --> 00:13:28,639
directly out of the blueprints tutorial

00:13:27,040 --> 00:13:30,959
so nothing particularly fancy going on

00:13:28,639 --> 00:13:34,160
here uh we have

00:13:30,959 --> 00:13:36,800
i'm gonna grab my pointer

00:13:34,160 --> 00:13:38,800
we have this red box here at the start

00:13:36,800 --> 00:13:39,360
this is the on component begin overlap

00:13:38,800 --> 00:13:41,519
so this is

00:13:39,360 --> 00:13:42,480
an event handler for the event that

00:13:41,519 --> 00:13:47,040
happens

00:13:42,480 --> 00:13:49,279
when a something overlaps with this box

00:13:47,040 --> 00:13:51,360
and we can follow this white line to see

00:13:49,279 --> 00:13:51,920
what the execution flow of the program

00:13:51,360 --> 00:13:53,760
is

00:13:51,920 --> 00:13:55,360
the first thing that it hits is a branch

00:13:53,760 --> 00:13:57,519
which is an if statement

00:13:55,360 --> 00:13:59,120
and that branch has a condition which is

00:13:57,519 --> 00:14:02,639
an equality operator

00:13:59,120 --> 00:14:05,760
so look very familiar and it's checking

00:14:02,639 --> 00:14:07,199
uh if this uh actor that has interacted

00:14:05,760 --> 00:14:08,079
with the box that has collided with the

00:14:07,199 --> 00:14:10,480
box

00:14:08,079 --> 00:14:11,279
uh is equal to the player so we're just

00:14:10,480 --> 00:14:13,040
making sure

00:14:11,279 --> 00:14:15,440
that the thing that touched the block

00:14:13,040 --> 00:14:18,000
the box is the player

00:14:15,440 --> 00:14:20,320
and this is a binary operator just like

00:14:18,000 --> 00:14:23,120
the one that we've seen in our ast

00:14:20,320 --> 00:14:24,880
in python and if that binary operator

00:14:23,120 --> 00:14:28,320
returns true

00:14:24,880 --> 00:14:30,720
it will then cast the object to

00:14:28,320 --> 00:14:32,320
a character object and this is not a

00:14:30,720 --> 00:14:34,720
beginner programming concept

00:14:32,320 --> 00:14:37,120
casting right this is a you know a

00:14:34,720 --> 00:14:39,120
fairly featured programming language

00:14:37,120 --> 00:14:41,040
and that character object we can then

00:14:39,120 --> 00:14:43,040
call a function on that character

00:14:41,040 --> 00:14:45,040
which is the launch character function

00:14:43,040 --> 00:14:48,160
and we give it a launch velocity

00:14:45,040 --> 00:14:48,880
in three dimensions and what does this

00:14:48,160 --> 00:14:51,120
do

00:14:48,880 --> 00:14:53,040
well when we run this blueprint the

00:14:51,120 --> 00:14:56,800
player can interact with the box

00:14:53,040 --> 00:15:00,000
and be launched into the air right

00:14:56,800 --> 00:15:01,760
and this blueprints tool isn't something

00:15:00,000 --> 00:15:03,760
that is specifically targeted

00:15:01,760 --> 00:15:04,880
at beginners right this is something

00:15:03,760 --> 00:15:07,040
that is used

00:15:04,880 --> 00:15:08,800
in the professional games industry on

00:15:07,040 --> 00:15:11,920
professional games

00:15:08,800 --> 00:15:13,600
uh it is to a certain extent targeted at

00:15:11,920 --> 00:15:14,639
people who would be otherwise very

00:15:13,600 --> 00:15:18,320
uncomfortable with c

00:15:14,639 --> 00:15:21,760
plus code um like designers

00:15:18,320 --> 00:15:24,399
artists um but it is

00:15:21,760 --> 00:15:27,040
also used by professional developers

00:15:24,399 --> 00:15:29,199
because sometimes it is nicer to use

00:15:27,040 --> 00:15:31,199
when they're working on the interactions

00:15:29,199 --> 00:15:32,560
for particular objects in the game so it

00:15:31,199 --> 00:15:34,800
is something that is used

00:15:32,560 --> 00:15:38,480
by professional c plus plus developers

00:15:34,800 --> 00:15:40,079
as well because sometimes it's nicer

00:15:38,480 --> 00:15:42,079
so i'm going to cross out no real world

00:15:40,079 --> 00:15:45,120
use because we do have examples

00:15:42,079 --> 00:15:45,680
of visual coding languages that are

00:15:45,120 --> 00:15:47,600
building

00:15:45,680 --> 00:15:49,279
our code trees in the real world for

00:15:47,600 --> 00:15:52,800
professional developers

00:15:49,279 --> 00:15:54,480
the next one uh i want to look at is

00:15:52,800 --> 00:15:56,880
whether or not visual coding languages

00:15:54,480 --> 00:15:58,320
have to be slower to edit than text

00:15:56,880 --> 00:15:59,680
programming languages

00:15:58,320 --> 00:16:01,600
and one of the things that's interesting

00:15:59,680 --> 00:16:04,720
when you ask people about blueprints

00:16:01,600 --> 00:16:05,600
is that sometimes writing the logic in

00:16:04,720 --> 00:16:08,079
blueprints is

00:16:05,600 --> 00:16:08,959
faster than writing the equivalent c

00:16:08,079 --> 00:16:11,120
plus code

00:16:08,959 --> 00:16:12,240
and game developers depending on what it

00:16:11,120 --> 00:16:13,920
is that they're writing

00:16:12,240 --> 00:16:15,759
would sometimes use blueprints because

00:16:13,920 --> 00:16:16,560
that process of iterating on it and

00:16:15,759 --> 00:16:18,399
editing it

00:16:16,560 --> 00:16:20,320
and experimenting with it is faster than

00:16:18,399 --> 00:16:20,639
writing the code and then compiling it

00:16:20,320 --> 00:16:24,399
the

00:16:20,639 --> 00:16:25,680
the cycle is shorter but you've probably

00:16:24,399 --> 00:16:28,399
already used

00:16:25,680 --> 00:16:28,959
a visual coding interface for editing

00:16:28,399 --> 00:16:30,639
code

00:16:28,959 --> 00:16:31,920
because it's faster you wouldn't

00:16:30,639 --> 00:16:32,320
necessarily have realized it so if

00:16:31,920 --> 00:16:35,920
you've done

00:16:32,320 --> 00:16:36,880
any web development you've probably used

00:16:35,920 --> 00:16:39,279
this

00:16:36,880 --> 00:16:40,800
and this is of course the chrome

00:16:39,279 --> 00:16:43,920
inspector so here i am

00:16:40,800 --> 00:16:45,680
this is the uh 2020 python site

00:16:43,920 --> 00:16:46,880
and i've opened the chrome inspector and

00:16:45,680 --> 00:16:48,000
i can navigate through the tree

00:16:46,880 --> 00:16:51,279
structure of the dom

00:16:48,000 --> 00:16:55,519
in this page and i've got the css here

00:16:51,279 --> 00:16:55,519
as well and so i can

00:16:55,759 --> 00:17:02,160
go back try that again in the css

00:16:59,519 --> 00:17:03,440
i can check and uncheck these little

00:17:02,160 --> 00:17:06,400
checkboxes

00:17:03,440 --> 00:17:08,160
to edit the code these like curly braces

00:17:06,400 --> 00:17:09,839
that you see here in the css

00:17:08,160 --> 00:17:12,000
they don't have to be there we're not

00:17:09,839 --> 00:17:15,280
actually editing a text file

00:17:12,000 --> 00:17:16,160
we are manipulating the structure of the

00:17:15,280 --> 00:17:18,559
css

00:17:16,160 --> 00:17:19,439
and styles on the page it just happens

00:17:18,559 --> 00:17:22,559
to be

00:17:19,439 --> 00:17:24,640
in a way that looks a lot like the code

00:17:22,559 --> 00:17:26,319
but we're not this isn't saved to a text

00:17:24,640 --> 00:17:28,799
file this isn't

00:17:26,319 --> 00:17:31,280
a text file edit that i am doing as i'm

00:17:28,799 --> 00:17:32,720
manipulating these numbers up and down

00:17:31,280 --> 00:17:34,400
and it lets us do nice little things

00:17:32,720 --> 00:17:35,760
like you have a color picker

00:17:34,400 --> 00:17:39,039
when you're choosing the color and you

00:17:35,760 --> 00:17:42,160
don't have to type out an rgb value

00:17:39,039 --> 00:17:44,559
so we use the chrome inspector to edit

00:17:42,160 --> 00:17:47,360
css when we want to iterate and develop

00:17:44,559 --> 00:17:48,080
because it is faster than writing the

00:17:47,360 --> 00:17:51,440
equivalent

00:17:48,080 --> 00:17:52,960
css and then reloading it into the page

00:17:51,440 --> 00:17:54,320
and it doesn't do exactly all of the

00:17:52,960 --> 00:17:55,679
things that you can do with css you

00:17:54,320 --> 00:17:58,720
still have to at some point

00:17:55,679 --> 00:18:01,679
have a stored file which is your css

00:17:58,720 --> 00:18:02,320
um but all of the examples we've looked

00:18:01,679 --> 00:18:04,799
at

00:18:02,320 --> 00:18:06,400
have in some way a limitation that lets

00:18:04,799 --> 00:18:07,600
you that doesn't let you do every single

00:18:06,400 --> 00:18:10,160
thing that you could do

00:18:07,600 --> 00:18:11,919
with an equivalent text-based language

00:18:10,160 --> 00:18:13,760
and so as a last example

00:18:11,919 --> 00:18:15,760
i want to look at this one uh which is

00:18:13,760 --> 00:18:16,720
bolt which is also from a game engine

00:18:15,760 --> 00:18:19,520
this is from

00:18:16,720 --> 00:18:20,400
unity and bolt is an interesting

00:18:19,520 --> 00:18:23,440
language because

00:18:20,400 --> 00:18:26,320
it was specifically designed to be

00:18:23,440 --> 00:18:27,520
a one-to-one translation of c-sharp the

00:18:26,320 --> 00:18:30,320
scripting language

00:18:27,520 --> 00:18:31,840
in unity and leslie bonin the creator of

00:18:30,320 --> 00:18:33,679
bolt said if you're a coder

00:18:31,840 --> 00:18:35,200
you probably won't need the flow graphs

00:18:33,679 --> 00:18:36,640
in the boltz interface

00:18:35,200 --> 00:18:38,480
because bolt gives you pretty much a one

00:18:36,640 --> 00:18:39,280
to one translation of the code anything

00:18:38,480 --> 00:18:40,960
you can do in bolt

00:18:39,280 --> 00:18:42,799
you can do in code and he kind of

00:18:40,960 --> 00:18:45,520
expects that coders will want to

00:18:42,799 --> 00:18:46,640
code in c sharp instead of involved but

00:18:45,520 --> 00:18:49,039
the point here is

00:18:46,640 --> 00:18:50,320
you don't have to choose one or the

00:18:49,039 --> 00:18:52,640
other they are

00:18:50,320 --> 00:18:54,960
functionally equivalent and this is

00:18:52,640 --> 00:18:56,240
making some assumptions because

00:18:54,960 --> 00:18:58,320
both version one does have some

00:18:56,240 --> 00:19:00,080
limitations but there is a bolt version

00:18:58,320 --> 00:19:00,799
two coming out which i believe is meant

00:19:00,080 --> 00:19:03,200
to

00:19:00,799 --> 00:19:04,720
uh not have such limitations but if we

00:19:03,200 --> 00:19:07,919
have a closer look at bolt

00:19:04,720 --> 00:19:11,919
um this is also an event handler for

00:19:07,919 --> 00:19:14,000
a collision event and we've got here

00:19:11,919 --> 00:19:15,919
a collision that happens between

00:19:14,000 --> 00:19:16,880
something another branch with an if

00:19:15,919 --> 00:19:19,120
statement where we check

00:19:16,880 --> 00:19:21,120
if the thing that we collided with is an

00:19:19,120 --> 00:19:24,080
enemy if it is an enemy

00:19:21,120 --> 00:19:25,360
we create an explosion and we use a

00:19:24,080 --> 00:19:27,440
minus operator here

00:19:25,360 --> 00:19:28,960
subtraction operator to reduce the

00:19:27,440 --> 00:19:31,840
health of the player

00:19:28,960 --> 00:19:32,960
by the amount of the by the magnitude of

00:19:31,840 --> 00:19:34,559
the force with which the collision

00:19:32,960 --> 00:19:37,280
happened

00:19:34,559 --> 00:19:38,880
and as you're editing this bolt code it

00:19:37,280 --> 00:19:40,320
is also generating the c sharp code

00:19:38,880 --> 00:19:43,600
right these are functionally

00:19:40,320 --> 00:19:45,280
equivalent there are other

00:19:43,600 --> 00:19:46,640
issues that do come up with visual

00:19:45,280 --> 00:19:47,679
coding editors that i don't have

00:19:46,640 --> 00:19:49,120
examples to debug

00:19:47,679 --> 00:19:51,039
and these are things like when you have

00:19:49,120 --> 00:19:52,160
these graphs layout graph layouts with

00:19:51,039 --> 00:19:53,840
lots of lines

00:19:52,160 --> 00:19:55,520
when you get complex code it starts to

00:19:53,840 --> 00:19:57,120
look like spaghetti and it's very

00:19:55,520 --> 00:19:58,480
difficult to kind of keep it laid out in

00:19:57,120 --> 00:19:59,919
a logical way

00:19:58,480 --> 00:20:02,080
and the other thing you'll notice is

00:19:59,919 --> 00:20:04,400
especially with uh bolt

00:20:02,080 --> 00:20:05,520
is this code takes up a really large

00:20:04,400 --> 00:20:06,960
amount of space

00:20:05,520 --> 00:20:08,960
on the screen you can't fit a lot of

00:20:06,960 --> 00:20:09,520
code into your screen and down here we

00:20:08,960 --> 00:20:11,760
have

00:20:09,520 --> 00:20:13,919
the equivalent c sharp code which is in

00:20:11,760 --> 00:20:16,320
a much smaller space

00:20:13,919 --> 00:20:18,000
so that information density is a factor

00:20:16,320 --> 00:20:18,880
for a lot of visual coding languages as

00:20:18,000 --> 00:20:21,840
well

00:20:18,880 --> 00:20:23,760
but i want you to imagine that we live

00:20:21,840 --> 00:20:25,919
in this idealistic future world where we

00:20:23,760 --> 00:20:29,280
have solved these problems

00:20:25,919 --> 00:20:32,320
and imagine that our

00:20:29,280 --> 00:20:34,640
code is stored as a tree

00:20:32,320 --> 00:20:35,919
and that tree is just a pure tree

00:20:34,640 --> 00:20:37,360
doesn't have any of the information

00:20:35,919 --> 00:20:38,480
about how it should be laid out or

00:20:37,360 --> 00:20:40,559
displayed to the user

00:20:38,480 --> 00:20:41,679
it doesn't have white space and uh

00:20:40,559 --> 00:20:43,200
wrapping and all that kind of stuff

00:20:41,679 --> 00:20:45,760
built into it it is just

00:20:43,200 --> 00:20:47,679
the logical code tree and the way that

00:20:45,760 --> 00:20:51,039
it is displayed and edited

00:20:47,679 --> 00:20:53,039
is up to the editor itself

00:20:51,039 --> 00:20:54,159
so just imagine this world because it's

00:20:53,039 --> 00:20:56,159
a nice world

00:20:54,159 --> 00:20:58,000
right we don't have to deal with style

00:20:56,159 --> 00:20:58,400
guides maybe we still have style guides

00:20:58,000 --> 00:21:00,559
for

00:20:58,400 --> 00:21:02,640
naming conventions but otherwise we

00:21:00,559 --> 00:21:05,200
wouldn't have to have uh

00:21:02,640 --> 00:21:07,120
guido wasting his time doing a change

00:21:05,200 --> 00:21:08,559
that is purely style edits

00:21:07,120 --> 00:21:10,720
and none of us would have to fix up the

00:21:08,559 --> 00:21:11,520
styling as we go because it's something

00:21:10,720 --> 00:21:13,120
to do

00:21:11,520 --> 00:21:15,520
with the editor and the way the editor

00:21:13,120 --> 00:21:17,919
is displaying it if you

00:21:15,520 --> 00:21:18,799
wanted to have very large indentation in

00:21:17,919 --> 00:21:20,640
your code

00:21:18,799 --> 00:21:22,320
you could that is an editor setting it

00:21:20,640 --> 00:21:23,679
doesn't affect anyone else who is

00:21:22,320 --> 00:21:25,120
editing the same code

00:21:23,679 --> 00:21:27,120
and we wouldn't have to spend our time

00:21:25,120 --> 00:21:28,559
arguing over tabs versus spaces or how

00:21:27,120 --> 00:21:30,799
many spaces

00:21:28,559 --> 00:21:33,919
because that is up to you it's your

00:21:30,799 --> 00:21:36,960
choice what your editor settings are

00:21:33,919 --> 00:21:38,480
on that note we also would have fewer

00:21:36,960 --> 00:21:41,200
merge conflicts

00:21:38,480 --> 00:21:42,480
right in this example i have taken our

00:21:41,200 --> 00:21:45,280
timtam code

00:21:42,480 --> 00:21:46,880
and i have wrapped it in a function and

00:21:45,280 --> 00:21:49,039
i haven't changed any of that code this

00:21:46,880 --> 00:21:51,120
is actually a non-functional change

00:21:49,039 --> 00:21:52,320
but git will tell me that i have changed

00:21:51,120 --> 00:21:54,720
every single line

00:21:52,320 --> 00:21:57,679
of this code and if we were expressing

00:21:54,720 --> 00:22:00,320
our edits to the code in a tree form

00:21:57,679 --> 00:22:02,080
we would be able to merge a lot more of

00:22:00,320 --> 00:22:04,400
these edits in a sensible way

00:22:02,080 --> 00:22:05,520
where we know it's safe because even

00:22:04,400 --> 00:22:07,679
though they're affecting

00:22:05,520 --> 00:22:09,200
the way that the code is represented

00:22:07,679 --> 00:22:11,600
those lines of code themselves

00:22:09,200 --> 00:22:13,280
haven't changed this would also mean

00:22:11,600 --> 00:22:14,000
that if you have a patch on something

00:22:13,280 --> 00:22:15,440
upstream

00:22:14,000 --> 00:22:17,200
it would be easier to maintain that

00:22:15,440 --> 00:22:18,799
patch because it would conflict less

00:22:17,200 --> 00:22:20,320
with the other edits that are happening

00:22:18,799 --> 00:22:22,400
upstream

00:22:20,320 --> 00:22:23,440
we might also end up with different

00:22:22,400 --> 00:22:25,520
editors that

00:22:23,440 --> 00:22:26,480
suit the different kinds of devices that

00:22:25,520 --> 00:22:28,559
we have

00:22:26,480 --> 00:22:29,679
right editing code while typing

00:22:28,559 --> 00:22:32,559
punctuation

00:22:29,679 --> 00:22:33,120
uh with wide lines and bad wrapping is

00:22:32,559 --> 00:22:35,520
gonna be

00:22:33,120 --> 00:22:36,240
painful on a small screen or a touch

00:22:35,520 --> 00:22:37,760
device

00:22:36,240 --> 00:22:39,600
but we might be able to have different

00:22:37,760 --> 00:22:41,039
editors that are better suited to these

00:22:39,600 --> 00:22:43,440
different devices

00:22:41,039 --> 00:22:44,240
if we weren't including the way the code

00:22:43,440 --> 00:22:47,679
is laid out

00:22:44,240 --> 00:22:50,799
as a part of the code as it's stored

00:22:47,679 --> 00:22:51,440
we might even have support from multiple

00:22:50,799 --> 00:22:53,760
languages

00:22:51,440 --> 00:22:55,200
because the way the code is displayed is

00:22:53,760 --> 00:22:56,080
separate from the underlying structure

00:22:55,200 --> 00:22:57,600
of the code

00:22:56,080 --> 00:22:59,520
we would have to translate things like

00:22:57,600 --> 00:23:01,919
function names and variable names

00:22:59,520 --> 00:23:02,960
but popular libraries could have

00:23:01,919 --> 00:23:05,120
translation packs

00:23:02,960 --> 00:23:07,200
and it would be workable right if we

00:23:05,120 --> 00:23:08,159
have the way the code is displayed and

00:23:07,200 --> 00:23:09,919
stored

00:23:08,159 --> 00:23:12,000
separated from the structure in which

00:23:09,919 --> 00:23:14,000
it's stored

00:23:12,000 --> 00:23:15,200
to do all of these things though like we

00:23:14,000 --> 00:23:18,159
would be breaking free

00:23:15,200 --> 00:23:20,000
of everything that we have already all

00:23:18,159 --> 00:23:21,600
of our tooling all of our ides

00:23:20,000 --> 00:23:23,200
and our version control systems all of

00:23:21,600 --> 00:23:26,640
these things are built

00:23:23,200 --> 00:23:27,679
around the world of text and i think we

00:23:26,640 --> 00:23:30,720
will break free

00:23:27,679 --> 00:23:32,320
of this world but it is

00:23:30,720 --> 00:23:34,640
it is going to be quite a long

00:23:32,320 --> 00:23:35,760
transition and it means relearning and

00:23:34,640 --> 00:23:37,120
rethinking

00:23:35,760 --> 00:23:39,360
almost everything about how we write

00:23:37,120 --> 00:23:41,039
code but i think that world

00:23:39,360 --> 00:23:43,600
will be a better place and it will

00:23:41,039 --> 00:23:45,120
unlock a bunch of cool things

00:23:43,600 --> 00:23:46,799
that will make our lives easier as

00:23:45,120 --> 00:23:50,320
developers

00:23:46,799 --> 00:23:52,559
if we can get there so thank you

00:23:50,320 --> 00:23:54,240
i would appreciate questions discussions

00:23:52,559 --> 00:23:55,840
comments anything i want to have

00:23:54,240 --> 00:23:57,360
this is the sort of thing where people

00:23:55,840 --> 00:23:58,480
have a lot of different ideas that are

00:23:57,360 --> 00:24:01,039
all really great

00:23:58,480 --> 00:24:02,000
um you might also notice that later on

00:24:01,039 --> 00:24:05,120
today

00:24:02,000 --> 00:24:06,320
nick is giving a talk which is a on a

00:24:05,120 --> 00:24:07,919
very similar topic but he's going to

00:24:06,320 --> 00:24:09,200
have a very different take on it and a

00:24:07,919 --> 00:24:10,400
different perspective and i'm really

00:24:09,200 --> 00:24:12,000
looking forward to that talk

00:24:10,400 --> 00:24:14,320
so if you want to think more about this

00:24:12,000 --> 00:24:17,200
uh absolutely go see that talk

00:24:14,320 --> 00:24:18,799
but otherwise i think we are out of time

00:24:17,200 --> 00:24:20,320
for questions

00:24:18,799 --> 00:24:21,919
great thank you very much for your

00:24:20,320 --> 00:24:22,559
presentation katie there's been some

00:24:21,919 --> 00:24:24,799
great chat

00:24:22,559 --> 00:24:25,760
in the venulis uh platform about it

00:24:24,799 --> 00:24:26,799
during the talk

00:24:25,760 --> 00:24:28,720
which would be great to read through

00:24:26,799 --> 00:24:30,000
later i reckon this definitely gives us

00:24:28,720 --> 00:24:31,679
a little love to think about and i

00:24:30,000 --> 00:24:32,159
appreciate the breaking down of barriers

00:24:31,679 --> 00:24:34,159
to

00:24:32,159 --> 00:24:35,840
visual coding in a really visual way as

00:24:34,159 --> 00:24:38,320
well

00:24:35,840 --> 00:24:39,520
um next up we have a long break for

00:24:38,320 --> 00:24:41,600
australian lunch times

00:24:39,520 --> 00:24:42,559
i hope folks get up rest your eyes maybe

00:24:41,600 --> 00:24:44,720
eat some food

00:24:42,559 --> 00:24:46,240
or maybe rapidly write your lightning

00:24:44,720 --> 00:24:47,360
talk submissions because they close in

00:24:46,240 --> 00:24:50,799
30 minutes at 12

00:24:47,360 --> 00:24:52,080
30am acst i'll be dropping the link in

00:24:50,799 --> 00:24:53,679
chat but if you have anything you want

00:24:52,080 --> 00:24:55,919
to talk about it doesn't have to be

00:24:53,679 --> 00:24:57,840
python related drop a submission in the

00:24:55,919 --> 00:25:08,720
link that'll drop in chat

00:24:57,840 --> 00:25:08,720

YouTube URL: https://www.youtube.com/watch?v=U33L10xoWzM


