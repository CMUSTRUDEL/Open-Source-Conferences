Title: Practicality Beats Purity: The Zen of Python’s Escape Hatch?
Publication date: 2020-09-07
Playlist: PyConline AU 2020
Description: 
	Christopher Neugebauer

https://2020.pycon.org.au/program/VVNEZR

When you type “import this” into a Python interpreter, you get PEP-20, 20* aphorisms that describe what “Good” Python code looks like. Most of these are prescriptive, and have been used to settle countless arguments about how Python should grow, or how new ideas should be implemented.

But in these 20 aphorisms (which you may know as the “Zen of Python”), there are some inherent contradictions. 

When “explicit is better than implicit” and “simple is better than complex”, what does it mean when being explicit means you must introduce complexity? 

When “readability counts” and “special cases aren’t special enough to break the rules”, what does it mean when making code more readable presents a special case in your codebase?

The answer lies in one often-forgotten aphorism: “practicality beats purity”. When you can weigh practicality as a factor, you can decide that other factors are restrictive, and discard them as “impractical”. This idea shows up in many places in Python:

Type hints can help you to be explicit, but they introduce complexity. Focusing on practicality means you can adopt type hints only when you need them. Decorators are simple, but can be used to introduce ambiguity. In many cases, the practical benefits of decorators outweigh their potential for misuse.

But how far can the pursuit of practicality let you go? Does practicality let you treat the other 19 aphorisms as optional? Does practicality give you an escape hatch from the rest of the Zen of Python? 

In this talk, we’ll look at how practicality has been a guiding principle in the evolution of Python. We’ll look at how to weigh practicality in the face of the other 19 aphorisms of PEP-20, and we’ll look at how focusing on practicality can guide you towards these other attributes of good Python.

--- 
(* per PEP-20, the Zen of Python contains “20 aphorisms, only 19 of which have been written down.”)

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 10:25:00 2020 at Curlyboi
Captions: 
	00:00:01,040 --> 00:00:05,520
hey everybody welcome back to the curly

00:00:03,439 --> 00:00:06,960
boy theater after heidi's amazing

00:00:05,520 --> 00:00:08,960
keynote this morning

00:00:06,960 --> 00:00:10,480
i'm lily ryan and i'll be your mc today

00:00:08,960 --> 00:00:13,759
in the curly boy theater

00:00:10,480 --> 00:00:15,120
and first up we have christopher

00:00:13,759 --> 00:00:18,160
neugebauer talking about

00:00:15,120 --> 00:00:19,279
the zen of python now chris is here with

00:00:18,160 --> 00:00:21,920
me

00:00:19,279 --> 00:00:22,320
live but this talk will be pre-recorded

00:00:21,920 --> 00:00:24,880
so

00:00:22,320 --> 00:00:26,400
chris will be able to answer all of your

00:00:24,880 --> 00:00:27,519
questions in the venue's chat on the

00:00:26,400 --> 00:00:29,279
side of the page

00:00:27,519 --> 00:00:30,640
while he's speaking which is part of the

00:00:29,279 --> 00:00:32,399
advantages of having an online

00:00:30,640 --> 00:00:33,920
conference

00:00:32,399 --> 00:00:35,520
to tell you a bit about chris

00:00:33,920 --> 00:00:36,239
christopher neugebauer is an australian

00:00:35,520 --> 00:00:38,320
developer

00:00:36,239 --> 00:00:39,760
speaker and serial community conference

00:00:38,320 --> 00:00:42,800
organizer who presently

00:00:39,760 --> 00:00:44,800
lives in the united states he serves as

00:00:42,800 --> 00:00:46,079
director and vice chair of the python

00:00:44,800 --> 00:00:47,840
software foundation

00:00:46,079 --> 00:00:49,760
and when all this is not currently

00:00:47,840 --> 00:00:50,399
preventing it is co-organizer of the

00:00:49,760 --> 00:00:52,800
acclaimed

00:00:50,399 --> 00:00:53,920
north bay python conference a boutique

00:00:52,800 --> 00:00:56,640
one-track conference

00:00:53,920 --> 00:00:57,600
run in a live music view and a live

00:00:56,640 --> 00:01:00,879
music venue

00:00:57,600 --> 00:01:02,719
in petaluma california very excited to

00:01:00,879 --> 00:01:04,960
have chris here today

00:01:02,719 --> 00:01:06,240
how are you doing i'm doing very well

00:01:04,960 --> 00:01:08,960
thanks ali i'm

00:01:06,240 --> 00:01:10,799
excited to share this talk with you i'm

00:01:08,960 --> 00:01:14,159
excited to hear it

00:01:10,799 --> 00:01:26,000
okay i think av we are ready

00:01:14,159 --> 00:01:28,880
for the talk

00:01:26,000 --> 00:01:30,720
there over the last few years i've been

00:01:28,880 --> 00:01:31,680
talking about what makes good python

00:01:30,720 --> 00:01:33,360
code

00:01:31,680 --> 00:01:35,119
often by talking about how python

00:01:33,360 --> 00:01:36,560
approaches ideas from other programming

00:01:35,119 --> 00:01:38,320
languages

00:01:36,560 --> 00:01:40,000
and today i'm here to talk about the zen

00:01:38,320 --> 00:01:42,720
of python which has been with us

00:01:40,000 --> 00:01:44,640
since time immemorial we've been using

00:01:42,720 --> 00:01:47,439
the zen of python to help us figure out

00:01:44,640 --> 00:01:49,119
how to write good python code

00:01:47,439 --> 00:01:51,680
and because many of us are people who

00:01:49,119 --> 00:01:53,439
get into arguments on the internet

00:01:51,680 --> 00:01:55,200
we use the zen of python as fuel for

00:01:53,439 --> 00:01:56,799
those arguments

00:01:55,200 --> 00:01:59,600
i think it's a good year to talk about

00:01:56,799 --> 00:02:01,280
the zen of python and its limitations

00:01:59,600 --> 00:02:03,840
and to talk about whether it does what

00:02:01,280 --> 00:02:05,360
we think it does

00:02:03,840 --> 00:02:06,960
and i've been a huge fan of the zen of

00:02:05,360 --> 00:02:09,119
python for many years

00:02:06,960 --> 00:02:10,239
this was reinforced for me 10 pycon

00:02:09,119 --> 00:02:12,879
australians ago

00:02:10,239 --> 00:02:15,360
when richard jones gave a fantastic

00:02:12,879 --> 00:02:18,160
sadly unrecorded deep dive talk called

00:02:15,360 --> 00:02:19,520
the zen of python and he showed how the

00:02:18,160 --> 00:02:22,080
zen of python was used

00:02:19,520 --> 00:02:23,440
in python at its standard library here's

00:02:22,080 --> 00:02:24,239
the abstract to that talk in its

00:02:23,440 --> 00:02:27,680
entirety

00:02:24,239 --> 00:02:27,680
it really was that good

00:02:28,000 --> 00:02:31,280
anyway that talk shaped how i think

00:02:29,680 --> 00:02:33,040
about writing python code

00:02:31,280 --> 00:02:34,800
because i saw how to put the zen of

00:02:33,040 --> 00:02:36,480
python into practice

00:02:34,800 --> 00:02:38,640
and it taught me ways to recognize

00:02:36,480 --> 00:02:42,239
whether some code was good python

00:02:38,640 --> 00:02:44,160
or bad python but in my talk at last

00:02:42,239 --> 00:02:46,080
year's pycon australia

00:02:44,160 --> 00:02:48,080
i looked to the zen of python to answer

00:02:46,080 --> 00:02:52,959
a question in a talk i'd written

00:02:48,080 --> 00:02:57,040
and for the first time i was left bereft

00:02:52,959 --> 00:02:59,599
i had found a design problem in python

00:02:57,040 --> 00:03:00,959
and the zen of python couldn't save me

00:02:59,599 --> 00:03:02,400
and that's what i've come here to talk

00:03:00,959 --> 00:03:05,920
about

00:03:02,400 --> 00:03:07,760
tim peters 20 python theses

00:03:05,920 --> 00:03:10,000
and no that spelling is how he

00:03:07,760 --> 00:03:12,400
introduced it

00:03:10,000 --> 00:03:13,440
and only 19 of them have been written

00:03:12,400 --> 00:03:15,200
down

00:03:13,440 --> 00:03:16,560
but it's still known as the zen of

00:03:15,200 --> 00:03:19,280
python

00:03:16,560 --> 00:03:23,040
or pep 20 or that thing that appears in

00:03:19,280 --> 00:03:25,360
your terminal when you type import this

00:03:23,040 --> 00:03:27,120
and here are those 20 theses now

00:03:25,360 --> 00:03:28,720
immediately in that very mailing list

00:03:27,120 --> 00:03:30,720
thread where tim introduced it

00:03:28,720 --> 00:03:32,400
people thought it was fantastic and it

00:03:30,720 --> 00:03:34,400
described everything that they thought

00:03:32,400 --> 00:03:37,599
python was about at the time

00:03:34,400 --> 00:03:39,840
it was concise it was opinionated it

00:03:37,599 --> 00:03:41,920
explained in very clear terms how python

00:03:39,840 --> 00:03:44,840
thought differently to pearl

00:03:41,920 --> 00:03:46,720
and in the 1990s that was super

00:03:44,840 --> 00:03:48,400
important

00:03:46,720 --> 00:03:50,319
and in the years following people

00:03:48,400 --> 00:03:53,280
started to identify languages

00:03:50,319 --> 00:03:55,120
with a prescriptive design philosophy a

00:03:53,280 --> 00:03:56,879
good example of that is java

00:03:55,120 --> 00:03:58,720
which was intended to be familiar to c

00:03:56,879 --> 00:04:01,040
developers like c

00:03:58,720 --> 00:04:02,159
plus was but without all the ways that

00:04:01,040 --> 00:04:04,879
let's uh that c

00:04:02,159 --> 00:04:06,239
plus let you shoot yourself in the foot

00:04:04,879 --> 00:04:08,640
looking at the zen of python

00:04:06,239 --> 00:04:10,239
especially its first few lines also made

00:04:08,640 --> 00:04:12,720
people think that python

00:04:10,239 --> 00:04:14,239
had a prescriptive design philosophy

00:04:12,720 --> 00:04:17,840
this was in contrast to

00:04:14,239 --> 00:04:17,840
say perl

00:04:17,919 --> 00:04:21,359
now for the longest time i have referred

00:04:19,919 --> 00:04:22,960
to the zen of python

00:04:21,359 --> 00:04:24,720
i have referred to it when introducing

00:04:22,960 --> 00:04:26,479
speakers at conferences

00:04:24,720 --> 00:04:28,639
i've used it to answer questions that

00:04:26,479 --> 00:04:30,400
have been raised in my talks

00:04:28,639 --> 00:04:33,199
and i've used it to solve design

00:04:30,400 --> 00:04:35,040
problems in my code

00:04:33,199 --> 00:04:36,400
i've definitely thought of the zen of

00:04:35,040 --> 00:04:38,400
python as evidence

00:04:36,400 --> 00:04:41,120
that python has a prescriptive design

00:04:38,400 --> 00:04:41,120
philosophy

00:04:41,360 --> 00:04:47,919
but it isn't today i want to show you

00:04:44,960 --> 00:04:49,600
why the zen of python isn't prescriptive

00:04:47,919 --> 00:04:51,360
and why it's a terrible way to settle

00:04:49,600 --> 00:04:54,240
arguments about the right way to do

00:04:51,360 --> 00:04:56,240
things in python

00:04:54,240 --> 00:04:58,479
today we're going to look at two design

00:04:56,240 --> 00:05:00,240
decisions made since the zen of python

00:04:58,479 --> 00:05:02,240
that was written that appear to have

00:05:00,240 --> 00:05:03,680
ignored the zen of python

00:05:02,240 --> 00:05:06,240
we're going to look at some code that

00:05:03,680 --> 00:05:08,479
zen of python thinks is reasonable

00:05:06,240 --> 00:05:10,240
but isn't and we're going to look at

00:05:08,479 --> 00:05:11,120
whether the zen of python ruins our

00:05:10,240 --> 00:05:15,280
understanding of

00:05:11,120 --> 00:05:15,280
why python is the way that it is

00:05:15,440 --> 00:05:20,320
so i mentioned earlier that i got

00:05:17,759 --> 00:05:22,720
confused by the zen of python last year

00:05:20,320 --> 00:05:25,039
the python feature that confused me was

00:05:22,720 --> 00:05:27,039
the decorator

00:05:25,039 --> 00:05:28,880
the decorator exists because sometimes

00:05:27,039 --> 00:05:30,880
in python you need to modify the

00:05:28,880 --> 00:05:32,400
behavior of a function

00:05:30,880 --> 00:05:34,160
people have been modifying the behavior

00:05:32,400 --> 00:05:35,919
of functions since well before

00:05:34,160 --> 00:05:37,600
decorators existed

00:05:35,919 --> 00:05:39,199
and one popular way to do this was

00:05:37,600 --> 00:05:41,600
through a thing called the decorate

00:05:39,199 --> 00:05:41,600
pattern

00:05:42,000 --> 00:05:46,800
the decorate pattern looked like this

00:05:44,080 --> 00:05:48,800
first up you define a function

00:05:46,800 --> 00:05:49,840
and then you pass that function into

00:05:48,800 --> 00:05:52,560
another function

00:05:49,840 --> 00:05:53,680
assigning it back to the original name

00:05:52,560 --> 00:05:56,400
now this approach is

00:05:53,680 --> 00:06:00,479
fine for short bits of code but things

00:05:56,400 --> 00:06:00,479
can fall apart really really quickly

00:06:00,800 --> 00:06:04,000
if you need to decorate the same

00:06:02,160 --> 00:06:05,120
function twice things get a bit

00:06:04,000 --> 00:06:07,199
repetitive

00:06:05,120 --> 00:06:08,319
and you have to decorate your function

00:06:07,199 --> 00:06:11,440
from the inside

00:06:08,319 --> 00:06:16,000
out so the last decorator you apply

00:06:11,440 --> 00:06:16,000
is the outermost behavior at call time

00:06:16,240 --> 00:06:20,639
and it suffers from really poor concept

00:06:18,160 --> 00:06:22,319
grouping the decorator can substantially

00:06:20,639 --> 00:06:24,479
change the behavior of a function

00:06:22,319 --> 00:06:26,800
but here it appears after the method

00:06:24,479 --> 00:06:26,800
body

00:06:28,080 --> 00:06:31,759
and if your method's long it might not

00:06:29,840 --> 00:06:34,080
even appear on the same window

00:06:31,759 --> 00:06:35,759
this can make for unreadable code and as

00:06:34,080 --> 00:06:38,880
we know from the zen of python

00:06:35,759 --> 00:06:41,440
readability counts and so

00:06:38,880 --> 00:06:43,360
pep318 gave us some syntax for decorate

00:06:41,440 --> 00:06:45,919
pattern

00:06:43,360 --> 00:06:46,560
we have decorators now we know that def

00:06:45,919 --> 00:06:48,560
means that

00:06:46,560 --> 00:06:50,479
we're defining a function or a method

00:06:48,560 --> 00:06:53,599
and so seeing a decorator means

00:06:50,479 --> 00:06:55,520
that function has modified behavior

00:06:53,599 --> 00:06:56,960
in this case we know that the new

00:06:55,520 --> 00:06:57,919
behavior is firstly that it's

00:06:56,960 --> 00:07:01,599
synchronized

00:06:57,919 --> 00:07:03,440
and secondly that's a class method

00:07:01,599 --> 00:07:05,199
now this won't be surprising if you saw

00:07:03,440 --> 00:07:07,840
my talk last year

00:07:05,199 --> 00:07:09,599
but that understanding of decorators

00:07:07,840 --> 00:07:11,840
isn't exactly true

00:07:09,599 --> 00:07:13,440
if you put a decorator before a function

00:07:11,840 --> 00:07:14,960
definition it doesn't change the

00:07:13,440 --> 00:07:17,120
behavior of the function

00:07:14,960 --> 00:07:18,960
it actually changes the definition of a

00:07:17,120 --> 00:07:21,039
function

00:07:18,960 --> 00:07:23,120
let me show you what i mean let's say

00:07:21,039 --> 00:07:26,080
you define a function called squares

00:07:23,120 --> 00:07:27,599
which multiplies a number by itself you

00:07:26,080 --> 00:07:30,000
can call that function and you get a

00:07:27,599 --> 00:07:33,680
value and everything is great

00:07:30,000 --> 00:07:35,360
now here's a decorator it's called apply

00:07:33,680 --> 00:07:36,800
when you decorate a function with it you

00:07:35,360 --> 00:07:38,960
provide a transform

00:07:36,800 --> 00:07:40,000
lambda which accepts a function as a

00:07:38,960 --> 00:07:41,440
parameter

00:07:40,000 --> 00:07:44,560
and when you decorate the function with

00:07:41,440 --> 00:07:46,400
apply it calls the transform function

00:07:44,560 --> 00:07:47,759
with the decorated function as its

00:07:46,400 --> 00:07:49,919
parameter

00:07:47,759 --> 00:07:51,919
and instead of returning a callable it

00:07:49,919 --> 00:07:54,080
returns the result of that transform

00:07:51,919 --> 00:07:56,879
function

00:07:54,080 --> 00:07:59,039
so if we take our squares function and

00:07:56,879 --> 00:08:00,800
decorate it with apply

00:07:59,039 --> 00:08:02,400
and and let's pass in map as our

00:08:00,800 --> 00:08:05,919
transform function

00:08:02,400 --> 00:08:09,199
now after we define our function squares

00:08:05,919 --> 00:08:10,840
isn't a callable it's a list

00:08:09,199 --> 00:08:13,840
because that's what our transformer

00:08:10,840 --> 00:08:13,840
returns

00:08:14,240 --> 00:08:19,280
so we created a function using def to be

00:08:17,039 --> 00:08:20,400
called once at definition time and then

00:08:19,280 --> 00:08:22,160
discarded

00:08:20,400 --> 00:08:24,879
just because that's what the decorator

00:08:22,160 --> 00:08:28,560
does we define a callable

00:08:24,879 --> 00:08:28,560
but we end up with a list in its place

00:08:28,720 --> 00:08:32,560
and the fact that the thing that we

00:08:29,919 --> 00:08:35,919
define is no longer necessarily callable

00:08:32,560 --> 00:08:37,440
isn't obvious from syntax but it's there

00:08:35,919 --> 00:08:38,640
pretty plainly in the old decorate

00:08:37,440 --> 00:08:40,240
syntax

00:08:38,640 --> 00:08:43,200
there's nothing that says that this

00:08:40,240 --> 00:08:45,839
thing has to return a function

00:08:43,200 --> 00:08:46,720
and that brings us to the zen of python

00:08:45,839 --> 00:08:50,640
which says that

00:08:46,720 --> 00:08:54,160
explicit is better than implicit

00:08:50,640 --> 00:08:54,640
in python def name explicitly means that

00:08:54,160 --> 00:08:57,680
name

00:08:54,640 --> 00:09:01,440
is a callable that's a

00:08:57,680 --> 00:09:04,480
contract with you the developer

00:09:01,440 --> 00:09:06,399
and apply lets you break that contract

00:09:04,480 --> 00:09:09,200
so decorators let you break the contract

00:09:06,399 --> 00:09:11,920
of death quite easily

00:09:09,200 --> 00:09:13,440
could they have done any better well

00:09:11,920 --> 00:09:15,120
what if we made it so the things that

00:09:13,440 --> 00:09:17,440
decorators put in their place are

00:09:15,120 --> 00:09:19,040
callables well that would solve our

00:09:17,440 --> 00:09:21,200
immediate ambiguity

00:09:19,040 --> 00:09:22,880
but since decorators were invented this

00:09:21,200 --> 00:09:23,519
thing called a property descriptor came

00:09:22,880 --> 00:09:25,200
along

00:09:23,519 --> 00:09:27,200
and i think property descriptors are

00:09:25,200 --> 00:09:29,360
very pythonic and they're implemented

00:09:27,200 --> 00:09:31,760
using decorators as well

00:09:29,360 --> 00:09:32,480
once you decorate a method with property

00:09:31,760 --> 00:09:34,880
you don't

00:09:32,480 --> 00:09:37,760
call the method you defined by calling

00:09:34,880 --> 00:09:39,920
it you know by putting parens there

00:09:37,760 --> 00:09:41,440
you call it by accessing or assigning to

00:09:39,920 --> 00:09:44,480
the attribute that it's a property

00:09:41,440 --> 00:09:46,480
defined for so you're calling code as a

00:09:44,480 --> 00:09:48,240
side effect of a completely different

00:09:46,480 --> 00:09:49,680
operation

00:09:48,240 --> 00:09:51,279
and you have to know that this property

00:09:49,680 --> 00:09:52,320
thing does this weird behavior

00:09:51,279 --> 00:09:54,800
modification

00:09:52,320 --> 00:09:56,880
that's hugely implicit even if it's more

00:09:54,800 --> 00:09:59,040
readable

00:09:56,880 --> 00:10:02,000
so we see that decorators turn function

00:09:59,040 --> 00:10:03,360
definition into implicit behavior

00:10:02,000 --> 00:10:05,200
which depends on what the decorator

00:10:03,360 --> 00:10:07,760
function does so

00:10:05,200 --> 00:10:11,760
if we follow the zen of python then

00:10:07,760 --> 00:10:11,760
decorators must not be pythonic

00:10:12,959 --> 00:10:17,519
so let's skip ahead 13 years of python

00:10:15,120 --> 00:10:19,200
evolution and ahead to 2015

00:10:17,519 --> 00:10:21,760
which was a much more interesting time

00:10:19,200 --> 00:10:24,800
in por in core python world

00:10:21,760 --> 00:10:26,160
because python had got popular and you

00:10:24,800 --> 00:10:27,360
know that if you run mailing lists for

00:10:26,160 --> 00:10:28,880
things that are popular

00:10:27,360 --> 00:10:30,959
you know that random people from the

00:10:28,880 --> 00:10:31,839
internet show up and these random people

00:10:30,959 --> 00:10:33,920
had never got

00:10:31,839 --> 00:10:36,160
involved in language design before but

00:10:33,920 --> 00:10:37,920
they saw guido's keynote at pycon 2015

00:10:36,160 --> 00:10:38,880
and they decided to contribute to design

00:10:37,920 --> 00:10:40,560
discussions

00:10:38,880 --> 00:10:43,200
that were previously only amongst core

00:10:40,560 --> 00:10:43,200
developers

00:10:43,279 --> 00:10:46,880
those people came from a generation of

00:10:45,040 --> 00:10:48,079
python developers who learned to solve

00:10:46,880 --> 00:10:51,120
design problems

00:10:48,079 --> 00:10:52,959
with the zen of python

00:10:51,120 --> 00:10:54,560
and understood that simple is better

00:10:52,959 --> 00:10:56,000
than complex

00:10:54,560 --> 00:10:58,079
and there's no better demonstration of

00:10:56,000 --> 00:10:58,480
python simplicity than looking at the

00:10:58,079 --> 00:11:01,519
first

00:10:58,480 --> 00:11:03,600
program you write in java

00:11:01,519 --> 00:11:06,160
you need to know an awful lot about how

00:11:03,600 --> 00:11:07,839
to program to write hello world in java

00:11:06,160 --> 00:11:09,279
you need to know about types you need to

00:11:07,839 --> 00:11:10,000
know about classes you need to know

00:11:09,279 --> 00:11:12,320
about

00:11:10,000 --> 00:11:15,760
function definitions and python's

00:11:12,320 --> 00:11:18,800
version is just so much simpler

00:11:15,760 --> 00:11:21,040
but this simplicity is limited

00:11:18,800 --> 00:11:23,839
a python requires you to test behaviors

00:11:21,040 --> 00:11:25,680
with unexpected types

00:11:23,839 --> 00:11:27,519
automatically translating code was

00:11:25,680 --> 00:11:29,600
difficult which shot us in the foot when

00:11:27,519 --> 00:11:31,440
we transitioned between python 2 and

00:11:29,600 --> 00:11:33,360
python 3.

00:11:31,440 --> 00:11:36,640
and tools like ids were much more

00:11:33,360 --> 00:11:38,320
complicated to use as a result

00:11:36,640 --> 00:11:41,200
and as the zen of python says well

00:11:38,320 --> 00:11:43,680
explicit is better than implicit

00:11:41,200 --> 00:11:45,680
and so it was that we used a feature

00:11:43,680 --> 00:11:46,320
that got added in python 3 to let you

00:11:45,680 --> 00:11:49,680
provide

00:11:46,320 --> 00:11:50,959
argument and return annotations to use

00:11:49,680 --> 00:11:53,120
uh to give you the opportunity to

00:11:50,959 --> 00:11:54,880
provide argument and return hints

00:11:53,120 --> 00:11:56,560
and now you can specify your function's

00:11:54,880 --> 00:11:58,399
contract with its callers

00:11:56,560 --> 00:12:00,399
and these can be automatically tested by

00:11:58,399 --> 00:12:03,279
a type checker

00:12:00,399 --> 00:12:04,399
but in doing so things become less

00:12:03,279 --> 00:12:06,639
simple

00:12:04,399 --> 00:12:07,839
providing type hints is an extra piece

00:12:06,639 --> 00:12:10,959
of complexity

00:12:07,839 --> 00:12:12,160
that wasn't there previously and as you

00:12:10,959 --> 00:12:14,000
add type hints

00:12:12,160 --> 00:12:17,680
your code can get crowded and verbose

00:12:14,000 --> 00:12:17,680
and that reminds people of java

00:12:18,320 --> 00:12:22,959
but type hinting resolves ambiguity that

00:12:20,399 --> 00:12:25,519
doesn't need to be there

00:12:22,959 --> 00:12:26,880
basically type hinting laid bare a

00:12:25,519 --> 00:12:29,360
contradiction

00:12:26,880 --> 00:12:30,639
you had to choose between simplicity or

00:12:29,360 --> 00:12:33,360
explicitness

00:12:30,639 --> 00:12:33,920
ambiguity or ugliness you would have to

00:12:33,360 --> 00:12:37,120
choose

00:12:33,920 --> 00:12:39,519
where to accept your complexity

00:12:37,120 --> 00:12:42,000
the zen of python couldn't resolve this

00:12:39,519 --> 00:12:42,000
argument

00:12:42,720 --> 00:12:46,880
so we see two cases where the zen of

00:12:44,560 --> 00:12:48,320
python just didn't help matters

00:12:46,880 --> 00:12:50,240
and if you think the zen of python is

00:12:48,320 --> 00:12:51,120
there to tell you what pythonic choices

00:12:50,240 --> 00:12:52,720
are

00:12:51,120 --> 00:12:54,880
well you're probably asking yourself

00:12:52,720 --> 00:12:58,560
question right now

00:12:54,880 --> 00:13:00,399
is python pythonic well the answer to

00:12:58,560 --> 00:13:02,639
that one comes from actually reading the

00:13:00,399 --> 00:13:04,320
zen of python

00:13:02,639 --> 00:13:05,680
we saw that decorators are a feature

00:13:04,320 --> 00:13:08,079
that significantly improve the

00:13:05,680 --> 00:13:10,639
readability of python code

00:13:08,079 --> 00:13:13,200
but in doing so they take away a feature

00:13:10,639 --> 00:13:16,639
of python with quite explicit behavior

00:13:13,200 --> 00:13:18,560
and turn it into something implicit

00:13:16,639 --> 00:13:20,320
and we saw that adding type hints takes

00:13:18,560 --> 00:13:21,360
a simple structure and understanding of

00:13:20,320 --> 00:13:24,639
python code

00:13:21,360 --> 00:13:26,880
and makes it more complex

00:13:24,639 --> 00:13:28,560
and we saw that not including type hints

00:13:26,880 --> 00:13:29,360
means that the expected behavior of

00:13:28,560 --> 00:13:32,079
functions

00:13:29,360 --> 00:13:34,000
is implicit these are two cases where

00:13:32,079 --> 00:13:37,279
the zen of python does not guide you

00:13:34,000 --> 00:13:37,279
towards a good solution

00:13:37,360 --> 00:13:41,040
and as tim said if the answer to any

00:13:40,079 --> 00:13:44,560
python design

00:13:41,040 --> 00:13:48,160
issue isn't obvious after reading those

00:13:44,560 --> 00:13:48,880
you should give up if you take the zen

00:13:48,160 --> 00:13:51,680
of python

00:13:48,880 --> 00:13:53,519
at face value you'd have to say it's

00:13:51,680 --> 00:13:55,680
failed to guide python in the right

00:13:53,519 --> 00:13:57,760
direction

00:13:55,680 --> 00:13:58,720
but i hear you say these are special

00:13:57,760 --> 00:14:01,360
cases

00:13:58,720 --> 00:14:03,839
these do important things and the zen of

00:14:01,360 --> 00:14:06,399
python says something about that as well

00:14:03,839 --> 00:14:08,720
it says special cases aren't special

00:14:06,399 --> 00:14:11,600
enough to break the rules

00:14:08,720 --> 00:14:12,160
but almost as an afterthought it also

00:14:11,600 --> 00:14:17,279
says

00:14:12,160 --> 00:14:19,120
that practicality beats purity

00:14:17,279 --> 00:14:20,639
so what does it mean for practicality to

00:14:19,120 --> 00:14:22,800
beat purity

00:14:20,639 --> 00:14:24,320
well it means that not everything neatly

00:14:22,800 --> 00:14:26,320
fits into one of those catchy little

00:14:24,320 --> 00:14:27,120
boxes that the zen of python created for

00:14:26,320 --> 00:14:29,360
you

00:14:27,120 --> 00:14:31,279
it means that sometimes you need to make

00:14:29,360 --> 00:14:33,839
choices

00:14:31,279 --> 00:14:35,760
by the zen of python allowing implicit

00:14:33,839 --> 00:14:37,279
behavior means that decorators aren't

00:14:35,760 --> 00:14:40,000
pythonic

00:14:37,279 --> 00:14:40,880
but decorators encoded an existing use

00:14:40,000 --> 00:14:42,720
case

00:14:40,880 --> 00:14:44,240
remember in the before times when you

00:14:42,720 --> 00:14:46,240
wanted to decorate a function

00:14:44,240 --> 00:14:48,639
you would need to sacrifice readability

00:14:46,240 --> 00:14:50,399
for functionality

00:14:48,639 --> 00:14:51,680
as they were eventually implemented

00:14:50,399 --> 00:14:52,959
decorators let you do

00:14:51,680 --> 00:14:55,680
everything that people were doing

00:14:52,959 --> 00:14:57,440
beforehand it meant that every

00:14:55,680 --> 00:15:00,399
use case where people were decorating

00:14:57,440 --> 00:15:02,959
functions was covered by the new syntax

00:15:00,399 --> 00:15:05,680
and it allowed for innovations like

00:15:02,959 --> 00:15:08,399
property descriptors

00:15:05,680 --> 00:15:10,720
type hints solved a real use case that

00:15:08,399 --> 00:15:13,199
real python developers could not solve

00:15:10,720 --> 00:15:14,639
with python

00:15:13,199 --> 00:15:17,360
inferring the types that a function

00:15:14,639 --> 00:15:18,880
would accept or return was difficult

00:15:17,360 --> 00:15:20,880
this limited the tools that you could

00:15:18,880 --> 00:15:23,040
use with older python code

00:15:20,880 --> 00:15:25,279
and by the zen of python well if you

00:15:23,040 --> 00:15:26,959
believe that explicit is implicit

00:15:25,279 --> 00:15:29,040
then python's original approach to

00:15:26,959 --> 00:15:31,360
typing was not pythonic

00:15:29,040 --> 00:15:34,399
but it did make a practical choice for

00:15:31,360 --> 00:15:37,360
writing programs quickly

00:15:34,399 --> 00:15:38,000
the solution isn't simple good type

00:15:37,360 --> 00:15:41,120
symptom

00:15:38,000 --> 00:15:43,839
systems are inherently complex

00:15:41,120 --> 00:15:46,720
bad type systems make it really complex

00:15:43,839 --> 00:15:49,199
to write code

00:15:46,720 --> 00:15:50,000
but type hints enable simplicity in

00:15:49,199 --> 00:15:53,759
tests

00:15:50,000 --> 00:15:56,079
in tooling and in automatic translation

00:15:53,759 --> 00:15:58,480
so python chose a system where you could

00:15:56,079 --> 00:15:59,839
choose to opt out of static typing

00:15:58,480 --> 00:16:01,839
completely

00:15:59,839 --> 00:16:03,279
there's a rich and useful type system

00:16:01,839 --> 00:16:06,160
for people who need it

00:16:03,279 --> 00:16:07,519
and if you don't you can opt out

00:16:06,160 --> 00:16:09,279
completely

00:16:07,519 --> 00:16:10,880
which is the very definition of a

00:16:09,279 --> 00:16:13,120
practical choice

00:16:10,880 --> 00:16:14,880
if you prefer static typing if you

00:16:13,120 --> 00:16:18,079
prefer dynamic typing

00:16:14,880 --> 00:16:22,079
or if you want a mix of both you can get

00:16:18,079 --> 00:16:24,000
the programming language you want

00:16:22,079 --> 00:16:26,240
so python design decisions value

00:16:24,000 --> 00:16:27,519
simplicity explicitness and a whole

00:16:26,240 --> 00:16:30,880
bunch of other things

00:16:27,519 --> 00:16:32,800
but it also values practicality

00:16:30,880 --> 00:16:35,440
now this is a real factor in design

00:16:32,800 --> 00:16:36,240
decisions but it acknowledges that not

00:16:35,440 --> 00:16:40,000
every design

00:16:36,240 --> 00:16:40,000
problem fits into rules

00:16:40,399 --> 00:16:46,079
or to put it another way python doesn't

00:16:43,360 --> 00:16:48,160
tell you how to do things

00:16:46,079 --> 00:16:50,079
but the zen of python also talks about

00:16:48,160 --> 00:16:52,320
being able to do things

00:16:50,079 --> 00:16:53,759
it says that there should be one and

00:16:52,320 --> 00:16:56,399
preferably only one

00:16:53,759 --> 00:16:57,680
obvious way to do it and this is an

00:16:56,399 --> 00:16:59,920
approach that's actually served the

00:16:57,680 --> 00:17:01,839
language pretty well over the years

00:16:59,920 --> 00:17:03,120
basically it says that you should find a

00:17:01,839 --> 00:17:05,360
way to do something

00:17:03,120 --> 00:17:07,280
and then keep iterating until it is

00:17:05,360 --> 00:17:09,280
obvious that that is the way to do

00:17:07,280 --> 00:17:11,039
things

00:17:09,280 --> 00:17:13,120
but that means that in order for there

00:17:11,039 --> 00:17:15,039
to be a one obvious way

00:17:13,120 --> 00:17:16,720
you need to try out a bunch of other

00:17:15,039 --> 00:17:18,799
ways first

00:17:16,720 --> 00:17:20,079
and quite often one of the ways that we

00:17:18,799 --> 00:17:24,959
choose on that path

00:17:20,079 --> 00:17:26,640
might seem like the one obvious way

00:17:24,959 --> 00:17:28,880
i've given talks in the past where

00:17:26,640 --> 00:17:30,960
multi-processing and requests were the

00:17:28,880 --> 00:17:33,360
one obvious way

00:17:30,960 --> 00:17:34,640
they in turn replaced threading and url

00:17:33,360 --> 00:17:37,520
open

00:17:34,640 --> 00:17:41,600
today i tell you to use async io and i

00:17:37,520 --> 00:17:41,600
tell you to use aio http

00:17:41,679 --> 00:17:46,240
these things became the one obvious way

00:17:43,840 --> 00:17:47,919
because someone decided that the old way

00:17:46,240 --> 00:17:50,320
wasn't obvious enough

00:17:47,919 --> 00:17:52,640
and they experimented finding the

00:17:50,320 --> 00:17:55,120
obvious way involves experimentation

00:17:52,640 --> 00:17:57,039
and a certain acceptance that there

00:17:55,120 --> 00:17:58,000
needs to be a way to do it and you have

00:17:57,039 --> 00:18:01,200
to try out

00:17:58,000 --> 00:18:03,039
various ways to find that way

00:18:01,200 --> 00:18:04,480
and generally speaking python is a

00:18:03,039 --> 00:18:05,919
language that gives you the tools to

00:18:04,480 --> 00:18:07,760
bend things to your will

00:18:05,919 --> 00:18:09,280
you know things like django's orm

00:18:07,760 --> 00:18:11,600
they're only possible

00:18:09,280 --> 00:18:12,559
because python lets you subvert normal

00:18:11,600 --> 00:18:15,600
behavior

00:18:12,559 --> 00:18:17,840
and replace it with something different

00:18:15,600 --> 00:18:19,679
so let's take a feature that python has

00:18:17,840 --> 00:18:20,880
deliberately long chosen not to

00:18:19,679 --> 00:18:23,440
implement

00:18:20,880 --> 00:18:24,720
the switch statement actually in this

00:18:23,440 --> 00:18:25,760
case we're going to look at its more

00:18:24,720 --> 00:18:28,160
modern variant

00:18:25,760 --> 00:18:30,720
pattern matching because python really

00:18:28,160 --> 00:18:33,120
should be keeping up with the times

00:18:30,720 --> 00:18:35,280
as an example let's look at one of those

00:18:33,120 --> 00:18:37,919
terrible programming interview questions

00:18:35,280 --> 00:18:37,919
fizzbuzz

00:18:38,320 --> 00:18:42,480
now to solve fizzbuzz in python you need

00:18:41,120 --> 00:18:45,280
you usually need a bunch of

00:18:42,480 --> 00:18:47,200
if and lf statements to solve it but

00:18:45,280 --> 00:18:49,039
this version is tedious to write

00:18:47,200 --> 00:18:50,880
you need to make sure you spell the out

00:18:49,039 --> 00:18:51,280
variable correctly in every single one

00:18:50,880 --> 00:18:54,320
of those

00:18:51,280 --> 00:18:57,120
if blocks and you might say ah

00:18:54,320 --> 00:18:58,000
you can refactor this with a function

00:18:57,120 --> 00:19:01,039
and i'd say

00:18:58,000 --> 00:19:03,120
yeah you could

00:19:01,039 --> 00:19:04,799
but it doesn't really help you're still

00:19:03,120 --> 00:19:06,640
writing return a bunch of times and

00:19:04,799 --> 00:19:07,360
you've added an extra line of code and

00:19:06,640 --> 00:19:09,919
you've added

00:19:07,360 --> 00:19:10,720
a level of indirection what i would

00:19:09,919 --> 00:19:12,799
prefer

00:19:10,720 --> 00:19:14,559
is something more like what kotlin has

00:19:12,799 --> 00:19:16,320
to offer

00:19:14,559 --> 00:19:18,000
you get to pull the variable assignment

00:19:16,320 --> 00:19:19,280
out of this when block

00:19:18,000 --> 00:19:21,039
and you're left with just the

00:19:19,280 --> 00:19:23,440
conditionals and the block of code to

00:19:21,039 --> 00:19:26,400
execute when that condition is true

00:19:23,440 --> 00:19:28,080
it's simple it's concise and i really

00:19:26,400 --> 00:19:30,480
want something like that in python

00:19:28,080 --> 00:19:32,880
and as we know from the zen of python

00:19:30,480 --> 00:19:34,720
there should be one way to do it

00:19:32,880 --> 00:19:36,160
and i know that the core team has been

00:19:34,720 --> 00:19:39,039
pursuing pattern matching

00:19:36,160 --> 00:19:40,960
but the zen of python also says that now

00:19:39,039 --> 00:19:44,799
is better than never

00:19:40,960 --> 00:19:44,799
so what tools do we have right now

00:19:45,280 --> 00:19:48,480
well if you think about it these are

00:19:47,039 --> 00:19:50,559
just blocks of code that gets

00:19:48,480 --> 00:19:52,160
executed under certain circumstances and

00:19:50,559 --> 00:19:53,600
return a value

00:19:52,160 --> 00:19:55,840
these are the conditions where those

00:19:53,600 --> 00:19:57,440
blocks get executed

00:19:55,840 --> 00:20:01,039
and this is where the value of the

00:19:57,440 --> 00:20:02,799
executed block of code gets stored

00:20:01,039 --> 00:20:04,400
so what we need is just a way to group

00:20:02,799 --> 00:20:06,000
several blocks of code

00:20:04,400 --> 00:20:07,440
a way to define the conditions when

00:20:06,000 --> 00:20:09,760
those blocks execute

00:20:07,440 --> 00:20:10,559
and a way to store the output of what of

00:20:09,760 --> 00:20:13,840
whichever block

00:20:10,559 --> 00:20:15,679
executed so you might ask yourself does

00:20:13,840 --> 00:20:18,080
python have the tools that we need to

00:20:15,679 --> 00:20:21,679
implement this

00:20:18,080 --> 00:20:23,520
well first up we have at case

00:20:21,679 --> 00:20:25,200
it's just a boring standard function

00:20:23,520 --> 00:20:26,240
decorator it even just returns the

00:20:25,200 --> 00:20:27,840
original function

00:20:26,240 --> 00:20:30,159
there's not really anything magic going

00:20:27,840 --> 00:20:32,080
on here

00:20:30,159 --> 00:20:34,480
there is magic in this switch decorator

00:20:32,080 --> 00:20:35,280
though it chews up the contents of a

00:20:34,480 --> 00:20:37,039
class

00:20:35,280 --> 00:20:38,320
runs all of the functions you gave to

00:20:37,039 --> 00:20:40,400
case decorators

00:20:38,320 --> 00:20:43,440
and executes the method with the first

00:20:40,400 --> 00:20:43,440
matcher that passes

00:20:44,240 --> 00:20:48,640
together at switch and at case are

00:20:46,480 --> 00:20:49,679
written in 37 really sparse lines of

00:20:48,640 --> 00:20:51,520
python code

00:20:49,679 --> 00:20:54,480
it doesn't use anything creepy like

00:20:51,520 --> 00:20:56,720
inspect or bytecode decompilation

00:20:54,480 --> 00:20:58,799
but together they can turn a class with

00:20:56,720 --> 00:21:00,720
some methods into a functioning pattern

00:20:58,799 --> 00:21:03,200
matching implementation

00:21:00,720 --> 00:21:04,640
and the implementation of fizzbuzz isn't

00:21:03,200 --> 00:21:06,640
awful

00:21:04,640 --> 00:21:08,240
it suffers from a lot of repetition if

00:21:06,640 --> 00:21:10,559
you read the code it's not obvious why

00:21:08,240 --> 00:21:12,559
this is a class with methods

00:21:10,559 --> 00:21:13,679
but these are the tools that python has

00:21:12,559 --> 00:21:16,080
given us

00:21:13,679 --> 00:21:17,440
on balance i think it's less readable

00:21:16,080 --> 00:21:19,440
than the function version

00:21:17,440 --> 00:21:21,440
but i would much rather inline this than

00:21:19,440 --> 00:21:23,120
the multi-if version with variable

00:21:21,440 --> 00:21:25,120
assignments

00:21:23,120 --> 00:21:27,039
this might not be the final obvious way

00:21:25,120 --> 00:21:29,679
to do it but it solves a problem for me

00:21:27,039 --> 00:21:30,080
now and i can see situations where this

00:21:29,679 --> 00:21:32,320
could

00:21:30,080 --> 00:21:33,520
be the obvious way and as the zen of

00:21:32,320 --> 00:21:36,080
python says

00:21:33,520 --> 00:21:36,720
well now is better than never which is

00:21:36,080 --> 00:21:39,120
to say

00:21:36,720 --> 00:21:42,159
if you need something maybe you should

00:21:39,120 --> 00:21:45,840
implement it with the tools you have

00:21:42,159 --> 00:21:48,559
but it also provides a word of caution

00:21:45,840 --> 00:21:50,000
it says that never is often better than

00:21:48,559 --> 00:21:52,159
right now

00:21:50,000 --> 00:21:54,000
and so if we follow the zen of python's

00:21:52,159 --> 00:21:56,240
guidance we find ourselves in a

00:21:54,000 --> 00:21:57,039
situation where the only way to do

00:21:56,240 --> 00:21:58,640
things

00:21:57,039 --> 00:22:01,039
involves doing something that isn't

00:21:58,640 --> 00:22:02,880
obvious so we shouldn't do it because

00:22:01,039 --> 00:22:04,880
it's bad python

00:22:02,880 --> 00:22:06,320
but we've seen that python grows because

00:22:04,880 --> 00:22:08,000
people try things out

00:22:06,320 --> 00:22:10,159
decide that the best current approach

00:22:08,000 --> 00:22:13,039
doesn't work and improve upon it

00:22:10,159 --> 00:22:14,799
so what is practicality here is it using

00:22:13,039 --> 00:22:16,480
the tools that we have to structure code

00:22:14,799 --> 00:22:18,880
in the way that we want

00:22:16,480 --> 00:22:20,960
or is it making use of what python gives

00:22:18,880 --> 00:22:22,480
us and accepting that there may just

00:22:20,960 --> 00:22:25,280
never be a good way to do

00:22:22,480 --> 00:22:27,840
something even if it seems obvious at

00:22:25,280 --> 00:22:27,840
the time

00:22:28,480 --> 00:22:33,440
so i've spent the last 10 years thinking

00:22:31,280 --> 00:22:35,919
about python in a certain way

00:22:33,440 --> 00:22:37,760
and last year i found myself confused by

00:22:35,919 --> 00:22:41,039
the advice of the rules that we

00:22:37,760 --> 00:22:42,400
use to write good python code i've been

00:22:41,039 --> 00:22:44,640
thinking about this fundamental

00:22:42,400 --> 00:22:46,000
assumption about how python wants us to

00:22:44,640 --> 00:22:49,039
do things

00:22:46,000 --> 00:22:51,039
this prescriptive design philosophy

00:22:49,039 --> 00:22:52,559
that i thought the zen of python gives

00:22:51,039 --> 00:22:55,919
us or

00:22:52,559 --> 00:22:56,799
put another way can we follow a set of

00:22:55,919 --> 00:23:00,880
rules

00:22:56,799 --> 00:23:03,039
and always end up with good python code

00:23:00,880 --> 00:23:05,919
over the course of today's talk we saw

00:23:03,039 --> 00:23:09,120
that even in fundamental design cases

00:23:05,919 --> 00:23:12,400
the zen of python or pep 20 gives

00:23:09,120 --> 00:23:15,520
contradictory advice

00:23:12,400 --> 00:23:18,480
accepting one of these 20 theses often

00:23:15,520 --> 00:23:18,960
means giving no weight to another one of

00:23:18,480 --> 00:23:22,240
those

00:23:18,960 --> 00:23:24,159
same 20 theses

00:23:22,240 --> 00:23:25,280
so it's not a matter of deciding whether

00:23:24,159 --> 00:23:27,919
following the rules

00:23:25,280 --> 00:23:29,679
will give us good python code it's a

00:23:27,919 --> 00:23:31,679
matter of whether we can even follow the

00:23:29,679 --> 00:23:34,400
rules at all

00:23:31,679 --> 00:23:36,000
pep20 doesn't help us be prescriptive

00:23:34,400 --> 00:23:39,200
but there's a pep that's all about

00:23:36,000 --> 00:23:40,799
being prescriptive and that's pep 8 it's

00:23:39,200 --> 00:23:44,240
a style guide

00:23:40,799 --> 00:23:45,679
it tells you exactly what you should do

00:23:44,240 --> 00:23:47,600
it's the very definition of a

00:23:45,679 --> 00:23:48,559
prescriptive pep it should be exactly

00:23:47,600 --> 00:23:52,240
what we want

00:23:48,559 --> 00:23:52,559
but if you actually read pep 8 as far as

00:23:52,240 --> 00:23:55,279
the

00:23:52,559 --> 00:23:56,640
first heading you're confronted with

00:23:55,279 --> 00:23:59,520
this

00:23:56,640 --> 00:24:01,600
a foolish consistency is the hobgoblin

00:23:59,520 --> 00:24:03,919
of little minds

00:24:01,600 --> 00:24:05,600
what does that mean well it doesn't mean

00:24:03,919 --> 00:24:07,520
that's bad to be consistent

00:24:05,600 --> 00:24:10,000
in fact it it means quite the opposite

00:24:07,520 --> 00:24:11,520
it means that you can be consistent

00:24:10,000 --> 00:24:14,640
but you shouldn't be mindlessly

00:24:11,520 --> 00:24:16,799
consistent it means you need to think

00:24:14,640 --> 00:24:19,840
and to consider whether it makes sense

00:24:16,799 --> 00:24:19,840
to be consistent

00:24:19,919 --> 00:24:23,520
so the most prescriptive of all the peps

00:24:22,320 --> 00:24:26,240
says that you shouldn't be

00:24:23,520 --> 00:24:27,360
foolishly consistent python is not

00:24:26,240 --> 00:24:29,440
prescriptive

00:24:27,360 --> 00:24:32,159
but it's easy to think that it is but

00:24:29,440 --> 00:24:34,799
it's not that

00:24:32,159 --> 00:24:36,799
python is opinionated it's a language

00:24:34,799 --> 00:24:38,720
that has a strong opinion of how

00:24:36,799 --> 00:24:40,640
things should be done and the zen of

00:24:38,720 --> 00:24:41,840
python is just a list of one man's

00:24:40,640 --> 00:24:44,400
opinions

00:24:41,840 --> 00:24:45,600
mind you they're generally good opinions

00:24:44,400 --> 00:24:48,640
which you can use as

00:24:45,600 --> 00:24:49,760
guidelines to design better software but

00:24:48,640 --> 00:24:52,880
they're just that

00:24:49,760 --> 00:24:54,080
opinions and opinions no matter how much

00:24:52,880 --> 00:24:57,279
you agree with them

00:24:54,080 --> 00:24:59,120
aren't actually rules no matter how much

00:24:57,279 --> 00:25:00,400
your favorite part of the zen of python

00:24:59,120 --> 00:25:02,000
guides your development

00:25:00,400 --> 00:25:04,480
it doesn't mean that it's the only

00:25:02,000 --> 00:25:06,080
factor in making good code

00:25:04,480 --> 00:25:07,520
remember that different people have

00:25:06,080 --> 00:25:09,679
different use cases

00:25:07,520 --> 00:25:12,080
and python grows because we support

00:25:09,679 --> 00:25:13,919
those use cases

00:25:12,080 --> 00:25:16,080
keeping a narrow view on the use cases

00:25:13,919 --> 00:25:16,880
that you value doesn't keep the language

00:25:16,080 --> 00:25:20,240
simple

00:25:16,880 --> 00:25:22,240
it keeps it simple for you when problems

00:25:20,240 --> 00:25:23,840
come up that python can't solve

00:25:22,240 --> 00:25:25,600
keep an open mind that people are

00:25:23,840 --> 00:25:27,520
actually having these problems

00:25:25,600 --> 00:25:28,640
and that we can make python simple for

00:25:27,520 --> 00:25:30,640
them as well

00:25:28,640 --> 00:25:32,400
like that should be our guiding

00:25:30,640 --> 00:25:34,159
principle

00:25:32,400 --> 00:25:36,000
and while python is an opinionated

00:25:34,159 --> 00:25:36,799
language it has a strong design

00:25:36,000 --> 00:25:38,480
aesthetic

00:25:36,799 --> 00:25:40,880
it's that way because the people who've

00:25:38,480 --> 00:25:42,720
designed python made choices about how

00:25:40,880 --> 00:25:45,520
to improve the language

00:25:42,720 --> 00:25:46,159
if you want to write good code sometimes

00:25:45,520 --> 00:25:49,279
that means

00:25:46,159 --> 00:25:52,320
valuing some design options over

00:25:49,279 --> 00:25:53,360
others sometimes both opinions you must

00:25:52,320 --> 00:25:56,640
choose between

00:25:53,360 --> 00:25:58,559
are from the zen of python so how do you

00:25:56,640 --> 00:26:02,400
choose

00:25:58,559 --> 00:26:05,760
choose practicality over purity

00:26:02,400 --> 00:26:07,279
right thank you if you've got questions

00:26:05,760 --> 00:26:08,640
come join me in the hallway track after

00:26:07,279 --> 00:26:10,640
this talk i think there's a link

00:26:08,640 --> 00:26:13,120
somewhere visible to you now

00:26:10,640 --> 00:26:15,200
if you're watching this on delay please

00:26:13,120 --> 00:26:16,919
ping me by email or twitter

00:26:15,200 --> 00:26:18,400
there are notes for this talk at

00:26:16,919 --> 00:26:20,480
chrisjrn.com

00:26:18,400 --> 00:26:22,400
and finally thanks to everyone at pycon

00:26:20,480 --> 00:26:23,840
online for making this happen

00:26:22,400 --> 00:26:26,799
i'm looking forward to not giving

00:26:23,840 --> 00:26:39,840
another talk under these circumstances

00:26:26,799 --> 00:26:39,840
see you next year bye

00:26:41,600 --> 00:26:45,360
thank you so much chris that was an

00:26:43,520 --> 00:26:47,279
excellent talk and we were all really

00:26:45,360 --> 00:26:49,039
excited to have you here in the chat

00:26:47,279 --> 00:26:51,279
able to talk to us while you were

00:26:49,039 --> 00:26:55,279
talking

00:26:51,279 --> 00:26:55,279
uh yeah it was a very meta experience

00:26:56,720 --> 00:27:00,000
well we don't hope we hope that there

00:26:58,400 --> 00:27:01,919
aren't very many more under this kind of

00:27:00,000 --> 00:27:04,320
circumstances you said but

00:27:01,919 --> 00:27:06,159
um for the moment uh you're gonna be in

00:27:04,320 --> 00:27:07,679
the video hallway is that right

00:27:06,159 --> 00:27:09,279
yep ducking into one of the two video

00:27:07,679 --> 00:27:11,360
hallways depending on who's uh

00:27:09,279 --> 00:27:12,960
which whichever one is uh quietest so if

00:27:11,360 --> 00:27:13,600
you've got any questions or want to talk

00:27:12,960 --> 00:27:15,919
about

00:27:13,600 --> 00:27:16,720
python philosophy uh you know where to

00:27:15,919 --> 00:27:18,159
find me

00:27:16,720 --> 00:27:20,240
uh thanks everyone for coming on the

00:27:18,159 --> 00:27:21,600
discussion was great

00:27:20,240 --> 00:27:24,799
i really look forward to seeing you all

00:27:21,600 --> 00:27:28,159
in person real soon now

00:27:24,799 --> 00:27:29,679
thank you for the talk as well um

00:27:28,159 --> 00:27:30,880
so right now we're going to have a

00:27:29,679 --> 00:27:32,240
little bit of a break while we get our

00:27:30,880 --> 00:27:33,679
next speaker ready

00:27:32,240 --> 00:27:43,679
um but we hope to see you back here in

00:27:33,679 --> 00:27:43,679

YouTube URL: https://www.youtube.com/watch?v=XU9_3AlCy84


