Title: "Publishing well-formed Python packages" - Julin S (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Julin S

https://2020.pycon.org.au/program/HWU9J7

#### Why
Most of the well established projects follow some practices and has some mechanism in place to ensure better maintainability.

But we can find a good number of packages online which are being developed without an equivalent mechanism.

In this talk, I will mention some tools, which when used, can lay the foundation for a well formed package.

#### Well-formed package

A package whose source has some structure which makes testing and development more efficient and less error-prone.

Such a package also makes working with its source a more pleasant experience.

A well-formed package makes things easier for both the developer and the user.

But it is easier to get started with a structure than to maintain that form. Which calls for a mechanism to maintain that structure.

#### How

The source code should adopt a style and stick with it. A linting tool like pylint can help with it.
Or you could use black.

Use type annotations along with tools like mypy.

Eliminate unused code with `vulture`.

Add tests to be sure that the different functionalities work as intended using tools like pytest or the built-in unittest.
This will be extremely useful to be sure that further modifications do not break existing code.

Ensure proper test coverage with coverage.py
After all, adding tests isn't everything. One got to make sure it reaches every nook and corner.

Automate tests with tox, nox, etc.

Package the project in tune with the future of packaging.
setuptools, flit or poetry

And add some CI/CD.

Other tools like pre-commit, bumpversion, etc may also be used.

#### Intended audience

People who create and publish python packages.
The presentation is from the package developer's perspective and not exactly about the innards of the different python packaging tools.

#### Pre-requisites

Basic Python programming.
Git

## Tentative talk outline

 - Linting
 - Type checking
 - Eliminating dead code
 - Tests
 - Test coverage
 - Test automation
 - Packaging
 - CI/CD
 - Other tools
 - Future of packaging

#### Speaker info (anonymized):

Using Python for 5 years. Interested in text processing.

Published a few packages to PyPI using different packaging tools.

The proposed talk is derived from experience of creating them.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 13:00:00 2020 at Floperator
Captions: 
	00:00:00,160 --> 00:00:05,920
to the flip-flopperator auditorium

00:00:03,120 --> 00:00:06,640
um coming up next we have a pre-recorded

00:00:05,920 --> 00:00:09,679
talk by

00:00:06,640 --> 00:00:11,440
julen chaji uh julian has been working

00:00:09,679 --> 00:00:14,160
in python for around five years and

00:00:11,440 --> 00:00:14,880
likes text processing uh and will be

00:00:14,160 --> 00:00:18,480
talking to

00:00:14,880 --> 00:00:20,880
us now about well-formed python packages

00:00:18,480 --> 00:00:21,920
so we will show you that now julian will

00:00:20,880 --> 00:00:24,240
be in

00:00:21,920 --> 00:00:25,359
the chat answering questions as the talk

00:00:24,240 --> 00:00:27,279
proceeds so

00:00:25,359 --> 00:00:30,000
feel free to have a chat in there as we

00:00:27,279 --> 00:00:33,920
go cool take it away

00:00:30,000 --> 00:00:36,800
phone python packages i'm julian

00:00:33,920 --> 00:00:39,200
let's get into it so well form package

00:00:36,800 --> 00:00:41,360
so what do we mean by well phone package

00:00:39,200 --> 00:00:43,280
it's not a widely accepted timers and it

00:00:41,360 --> 00:00:47,360
says something that i coin

00:00:43,280 --> 00:00:50,160
just as i said so a package which can be

00:00:47,360 --> 00:00:51,600
which can be easily modified which can

00:00:50,160 --> 00:00:54,160
be adapted for

00:00:51,600 --> 00:00:55,600
for the changing needs it must be well

00:00:54,160 --> 00:00:57,520
tested so that

00:00:55,600 --> 00:00:59,280
whenever we make it change we need not

00:00:57,520 --> 00:01:01,039
be worried about if it will break

00:00:59,280 --> 00:01:03,280
anything that is already existing

00:01:01,039 --> 00:01:04,879
so if there are well written tests for

00:01:03,280 --> 00:01:06,320
that we can be

00:01:04,879 --> 00:01:08,400
we can just run the test and see if

00:01:06,320 --> 00:01:11,600
everything still works that's a

00:01:08,400 --> 00:01:13,520
big advantage so it ensures uh it

00:01:11,600 --> 00:01:15,520
is of collaboration i mean other others

00:01:13,520 --> 00:01:16,159
can work on different branches and come

00:01:15,520 --> 00:01:19,200
in with

00:01:16,159 --> 00:01:19,520
their changes and we can we can there's

00:01:19,200 --> 00:01:22,880
a

00:01:19,520 --> 00:01:26,479
well-structured way where we can see

00:01:22,880 --> 00:01:30,560
if the their contributions adheres to

00:01:26,479 --> 00:01:33,759
certain for the certain standards uh

00:01:30,560 --> 00:01:35,600
and vegan and well tested and all and it

00:01:33,759 --> 00:01:37,360
wants and we can be sure that

00:01:35,600 --> 00:01:38,960
it won't break or what's already

00:01:37,360 --> 00:01:42,479
existing and

00:01:38,960 --> 00:01:44,479
it's quite readable stuff like that

00:01:42,479 --> 00:01:45,759
so a linting tool what can a lending

00:01:44,479 --> 00:01:48,399
tool do it can

00:01:45,759 --> 00:01:49,360
uh tell you in advice you can inform you

00:01:48,399 --> 00:01:51,200
warn you

00:01:49,360 --> 00:01:54,159
if you're if you're doing something

00:01:51,200 --> 00:01:55,040
which which usually leads to some

00:01:54,159 --> 00:01:58,240
problematic

00:01:55,040 --> 00:02:02,079
code like doing if true

00:01:58,240 --> 00:02:04,960
and stuff like that and um

00:02:02,079 --> 00:02:05,360
to a great extent but not as capable as

00:02:04,960 --> 00:02:08,239
code

00:02:05,360 --> 00:02:08,879
uh like what tools like vulture it can

00:02:08,239 --> 00:02:12,000
detect

00:02:08,879 --> 00:02:16,000
that code unused imports

00:02:12,000 --> 00:02:16,000
says syntax syntacticals

00:02:16,560 --> 00:02:23,360
mishaps and it can

00:02:20,160 --> 00:02:24,319
advise you as to improving the call

00:02:23,360 --> 00:02:28,640
readability

00:02:24,319 --> 00:02:31,120
and uh consistent formatting uh style

00:02:28,640 --> 00:02:31,840
linting it does everything pilot and one

00:02:31,120 --> 00:02:34,640
more thing

00:02:31,840 --> 00:02:36,720
pylint is highly configurable you can

00:02:34,640 --> 00:02:39,920
use the pylin.rc file

00:02:36,720 --> 00:02:43,120
to configure it to your your

00:02:39,920 --> 00:02:46,319
to your wish you can see you could say

00:02:43,120 --> 00:02:49,360
for by default pylint has a hundred

00:02:46,319 --> 00:02:53,920
character line limit though

00:02:49,360 --> 00:02:56,319
8 mentions 80 or 79 lessons 80 i think

00:02:53,920 --> 00:02:58,000
um you have it so it's highly

00:02:56,319 --> 00:03:00,159
configurable and high you

00:02:58,000 --> 00:03:02,080
and there are other tools like flake 8

00:03:00,159 --> 00:03:06,879
which are

00:03:02,080 --> 00:03:09,040
which are more lenient of course and uh

00:03:06,879 --> 00:03:10,640
differs from pilot uh to a certain

00:03:09,040 --> 00:03:13,840
extent so my pie

00:03:10,640 --> 00:03:16,239
my pi actually enables a python

00:03:13,840 --> 00:03:17,599
program or package to combine the

00:03:16,239 --> 00:03:21,040
advantages of a

00:03:17,599 --> 00:03:24,480
statically typed system with the uh with

00:03:21,040 --> 00:03:26,640
ease of use and comfort of

00:03:24,480 --> 00:03:28,080
of a dynamically typed language in

00:03:26,640 --> 00:03:30,799
python

00:03:28,080 --> 00:03:32,400
so it actually started us out as a

00:03:30,799 --> 00:03:34,879
variation of

00:03:32,400 --> 00:03:35,760
a different variation all altogether of

00:03:34,879 --> 00:03:38,640
python

00:03:35,760 --> 00:03:40,480
which was then adapted to make it into a

00:03:38,640 --> 00:03:43,920
package which works with python the

00:03:40,480 --> 00:03:47,040
see python code itself a long time ago

00:03:43,920 --> 00:03:50,319
it's been around for a long time and it

00:03:47,040 --> 00:03:51,920
uses uh the type of notations which are

00:03:50,319 --> 00:03:52,560
being introduced into the python

00:03:51,920 --> 00:03:56,000
language

00:03:52,560 --> 00:04:01,280
introduced and enhanced many times uh

00:03:56,000 --> 00:04:04,080
to check if the the if the type of the

00:04:01,280 --> 00:04:04,720
expected type of a variable does not

00:04:04,080 --> 00:04:07,840
match

00:04:04,720 --> 00:04:10,640
with the variable the type that that

00:04:07,840 --> 00:04:11,599
it becomes later it is very quite

00:04:10,640 --> 00:04:15,519
capable

00:04:11,599 --> 00:04:18,400
and very helpful as as

00:04:15,519 --> 00:04:19,040
expressed by the by its use in a lot of

00:04:18,400 --> 00:04:22,079
packages

00:04:19,040 --> 00:04:24,400
and prominent ones too so it's

00:04:22,079 --> 00:04:25,600
it's a static i mean static static

00:04:24,400 --> 00:04:29,680
analysis of code

00:04:25,600 --> 00:04:32,320
it's what it does so vulture

00:04:29,680 --> 00:04:33,120
pulsar can be used for that eliminate

00:04:32,320 --> 00:04:36,479
detecting

00:04:33,120 --> 00:04:38,880
that code and it will point out an

00:04:36,479 --> 00:04:40,320
and unused code and of course unused

00:04:38,880 --> 00:04:43,280
code and often lead to

00:04:40,320 --> 00:04:44,639
errors which are hard to find now while

00:04:43,280 --> 00:04:48,400
she usually comes in

00:04:44,639 --> 00:04:49,840
usable i mean at least especially comes

00:04:48,400 --> 00:04:53,040
in useful

00:04:49,840 --> 00:04:56,479
when in projects which have had a lot of

00:04:53,040 --> 00:04:59,840
changes a long time and

00:04:56,479 --> 00:05:02,400
somehow things things uh

00:04:59,840 --> 00:05:03,440
got accumulated things got a bit messy

00:05:02,400 --> 00:05:05,840
and

00:05:03,440 --> 00:05:06,720
it can be used to detect i mean find

00:05:05,840 --> 00:05:10,000
virtual

00:05:06,720 --> 00:05:12,400
code is probably not used and it has

00:05:10,000 --> 00:05:13,039
a confidence system it will say it is

00:05:12,400 --> 00:05:15,039
this much

00:05:13,039 --> 00:05:16,479
concept confident that this part of code

00:05:15,039 --> 00:05:19,199
is not used

00:05:16,479 --> 00:05:20,800
and but it may not always be correct uh

00:05:19,199 --> 00:05:24,080
it usually is

00:05:20,800 --> 00:05:27,199
it seems but not always

00:05:24,080 --> 00:05:30,240
it in contrast to some

00:05:27,199 --> 00:05:33,280
other uh that code detection methods

00:05:30,240 --> 00:05:33,919
uh which are usually dynamically i mean

00:05:33,280 --> 00:05:36,960
it actually

00:05:33,919 --> 00:05:40,000
runs through all the possibilities to

00:05:36,960 --> 00:05:40,000
see if uh

00:05:40,720 --> 00:05:45,120
if any coverage is there and that code

00:05:43,759 --> 00:05:47,840
is there

00:05:45,120 --> 00:05:49,680
uh because it's tactical analysis i mean

00:05:47,840 --> 00:05:50,240
it does static analysis so it's a lot

00:05:49,680 --> 00:05:53,680
faster

00:05:50,240 --> 00:05:57,280
i mean but it the call

00:05:53,680 --> 00:05:59,120
calls to advantage ratio i mean

00:05:57,280 --> 00:06:01,759
it's more advantageous compared to the

00:05:59,120 --> 00:06:04,800
cost it takes

00:06:01,759 --> 00:06:08,160
so once we have all the code uh

00:06:04,800 --> 00:06:11,280
source code as we as we needed

00:06:08,160 --> 00:06:12,720
ready we need to see if it works as we

00:06:11,280 --> 00:06:15,440
intended it to be

00:06:12,720 --> 00:06:17,600
so we test it so unit testing can be

00:06:15,440 --> 00:06:20,080
done with pi test

00:06:17,600 --> 00:06:21,360
of course there is input modules python

00:06:20,080 --> 00:06:24,800
built-in modules

00:06:21,360 --> 00:06:26,240
unit tests but pytus is a lot more

00:06:24,800 --> 00:06:28,800
easier to use and

00:06:26,240 --> 00:06:29,440
easier to learn as well so i would

00:06:28,800 --> 00:06:31,680
suggest

00:06:29,440 --> 00:06:33,680
using pi test if you need not use unit

00:06:31,680 --> 00:06:36,960
test or

00:06:33,680 --> 00:06:38,400
so so the advantage of having test is as

00:06:36,960 --> 00:06:41,759
i said earlier is that

00:06:38,400 --> 00:06:43,120
if we make more changes into the project

00:06:41,759 --> 00:06:45,440
as time goes on

00:06:43,120 --> 00:06:46,880
we need not be worried or to be broke

00:06:45,440 --> 00:06:48,880
something early maybe we could have

00:06:46,880 --> 00:06:50,960
broken something earlier we just run the

00:06:48,880 --> 00:06:52,639
test that we had and see if it still

00:06:50,960 --> 00:06:56,400
works even without changes

00:06:52,639 --> 00:06:58,319
so having test is a great way

00:06:56,400 --> 00:07:00,639
to ensure that things all work as

00:06:58,319 --> 00:07:01,120
intended despite having made changes to

00:07:00,639 --> 00:07:03,199
it

00:07:01,120 --> 00:07:05,520
so it will even if if we broke something

00:07:03,199 --> 00:07:07,759
up if our changes proc something we

00:07:05,520 --> 00:07:09,199
this test will probably give us an idea

00:07:07,759 --> 00:07:12,080
as what could went wrong

00:07:09,199 --> 00:07:12,880
so what did we do do wrong so we can fix

00:07:12,080 --> 00:07:15,680
it

00:07:12,880 --> 00:07:16,000
so testing is important so having the

00:07:15,680 --> 00:07:18,240
test

00:07:16,000 --> 00:07:19,759
alone is not enough we have to ensure

00:07:18,240 --> 00:07:23,360
that these tests cover

00:07:19,759 --> 00:07:25,360
the entire code base as necessary

00:07:23,360 --> 00:07:26,479
for example suppose we have a

00:07:25,360 --> 00:07:29,680
conditional

00:07:26,479 --> 00:07:33,280
statement if our test test if our

00:07:29,680 --> 00:07:36,880
pi test test test only the if

00:07:33,280 --> 00:07:37,680
conditions uh else part and leave the

00:07:36,880 --> 00:07:40,639
other

00:07:37,680 --> 00:07:41,840
true part alone we can't be sure that we

00:07:40,639 --> 00:07:44,879
did not have

00:07:41,840 --> 00:07:46,240
the l if part works as we intended so we

00:07:44,879 --> 00:07:47,759
need a coverage

00:07:46,240 --> 00:07:49,280
we need to check the coverage test

00:07:47,759 --> 00:07:51,919
coverage to see if

00:07:49,280 --> 00:07:54,000
the test cover all the parts as needed

00:07:51,919 --> 00:07:55,680
for that we could use coverage dot by

00:07:54,000 --> 00:07:59,360
package i mean this coverage

00:07:55,680 --> 00:08:00,160
module you can work with pythes quite

00:07:59,360 --> 00:08:02,960
well

00:08:00,160 --> 00:08:04,639
or or if you want to use pi test plugin

00:08:02,960 --> 00:08:06,879
user spytisco

00:08:04,639 --> 00:08:09,120
for the mod for the demo at the end of

00:08:06,879 --> 00:08:12,560
the presentation i'm using coverage

00:08:09,120 --> 00:08:13,199
along with pythest so once we have our

00:08:12,560 --> 00:08:16,560
test

00:08:13,199 --> 00:08:17,440
ensure prop test coverage and we need we

00:08:16,560 --> 00:08:20,160
we can use

00:08:17,440 --> 00:08:22,080
a way to automate all these tests that's

00:08:20,160 --> 00:08:24,879
where talks comes comes in

00:08:22,080 --> 00:08:25,440
it's a test automation tool we can run

00:08:24,879 --> 00:08:27,840
the

00:08:25,440 --> 00:08:29,440
whatever test that we want across

00:08:27,840 --> 00:08:31,440
different environments different

00:08:29,440 --> 00:08:32,719
different python implementations like if

00:08:31,440 --> 00:08:36,080
you if you if

00:08:32,719 --> 00:08:37,760
by pi pi c python or anything

00:08:36,080 --> 00:08:39,440
actually any test that you want it can

00:08:37,760 --> 00:08:40,320
run and it does that can run on a

00:08:39,440 --> 00:08:43,760
command line

00:08:40,320 --> 00:08:44,800
it can be used to run it so our my pi

00:08:43,760 --> 00:08:46,560
checks can be done

00:08:44,800 --> 00:08:47,920
while should test file in everything can

00:08:46,560 --> 00:08:50,080
be done on file talks

00:08:47,920 --> 00:08:51,279
so with just one command or if you want

00:08:50,080 --> 00:08:53,600
there are some commands

00:08:51,279 --> 00:08:55,600
can be run separately as well what torx

00:08:53,600 --> 00:08:57,600
does is that it installs it creates a

00:08:55,600 --> 00:09:00,080
virtual environment on its own

00:08:57,600 --> 00:09:01,440
if you're unable to build a isolated

00:09:00,080 --> 00:09:04,800
blue light thing

00:09:01,440 --> 00:09:06,560
uh it is in installs at our

00:09:04,800 --> 00:09:08,080
package into virtual and beyond that it

00:09:06,560 --> 00:09:09,680
creates just for the test

00:09:08,080 --> 00:09:11,440
and see if everything works well so it's

00:09:09,680 --> 00:09:14,959
isolated so

00:09:11,440 --> 00:09:18,080
so we can be more sure of its efficiency

00:09:14,959 --> 00:09:20,320
efficacy so once our tests all pass

00:09:18,080 --> 00:09:21,120
via everything works well fine good

00:09:20,320 --> 00:09:23,920
great

00:09:21,120 --> 00:09:24,720
so we will we will need to build and

00:09:23,920 --> 00:09:26,640
package

00:09:24,720 --> 00:09:29,760
and distribute our so that others can

00:09:26,640 --> 00:09:32,399
use it we can share our code our work

00:09:29,760 --> 00:09:33,920
so others can actually benefit from it

00:09:32,399 --> 00:09:37,040
so

00:09:33,920 --> 00:09:40,320
the commonly used tools are setup tools

00:09:37,040 --> 00:09:42,480
flit and poetry setup tools is

00:09:40,320 --> 00:09:45,440
for a beginner level it's a bit tricky

00:09:42,480 --> 00:09:45,440
to get used to

00:09:45,680 --> 00:09:49,760
so i would recommend at least if you are

00:09:47,760 --> 00:09:53,279
getting started with

00:09:49,760 --> 00:09:53,680
to use flit or poetry for the demo i'm

00:09:53,279 --> 00:09:56,640
using

00:09:53,680 --> 00:09:57,200
flit because by the way flit can't

00:09:56,640 --> 00:10:00,320
handle

00:09:57,200 --> 00:10:02,560
only pure python projects uh if you want

00:10:00,320 --> 00:10:05,600
to see extensions and role you better go

00:10:02,560 --> 00:10:08,320
with the setup tools for poetry

00:10:05,600 --> 00:10:08,320
and yeah

00:10:08,720 --> 00:10:15,040
so flit can actually build

00:10:11,839 --> 00:10:18,079
and can be used to publish it to the pi

00:10:15,040 --> 00:10:21,440
pi or wherever wherever you were

00:10:18,079 --> 00:10:24,240
but keep in mind one thing before

00:10:21,440 --> 00:10:25,880
publishing to the actual pipi.org you

00:10:24,240 --> 00:10:27,279
might want to create an account in

00:10:25,880 --> 00:10:29,839
test.pypi

00:10:27,279 --> 00:10:30,880
and push and publish it there and see if

00:10:29,839 --> 00:10:34,240
everything works fine

00:10:30,880 --> 00:10:37,519
only then you push it to the pi api

00:10:34,240 --> 00:10:39,040
server that would be best so that even

00:10:37,519 --> 00:10:40,880
if you run into some trouble

00:10:39,040 --> 00:10:42,640
you can fix it without before without

00:10:40,880 --> 00:10:44,880
going into the production

00:10:42,640 --> 00:10:45,760
the example program that i'm going to

00:10:44,880 --> 00:10:48,240
show

00:10:45,760 --> 00:10:50,320
it's nymphs names is a game where you

00:10:48,240 --> 00:10:52,959
have a set of heaps

00:10:50,320 --> 00:10:54,079
which each have keep having a number of

00:10:52,959 --> 00:10:57,360
names

00:10:54,079 --> 00:11:00,240
uh something called as names think of

00:10:57,360 --> 00:11:01,279
think of it as a matchstick if you like

00:11:00,240 --> 00:11:04,320
so each heap

00:11:01,279 --> 00:11:07,600
has a certain amount of names

00:11:04,320 --> 00:11:09,519
so there will be two players

00:11:07,600 --> 00:11:11,200
for for our example secrets confined

00:11:09,519 --> 00:11:14,240
into two players

00:11:11,200 --> 00:11:17,120
so um

00:11:14,240 --> 00:11:18,000
so is if during instance the turn-based

00:11:17,120 --> 00:11:20,800
game

00:11:18,000 --> 00:11:22,240
during each turn a player the player

00:11:20,800 --> 00:11:25,760
whose turn it is

00:11:22,240 --> 00:11:29,440
will take uh any number of nymphs from

00:11:25,760 --> 00:11:32,880
any of the heaps but

00:11:29,440 --> 00:11:35,600
whoever takes the last name in the all

00:11:32,880 --> 00:11:37,519
among all the hips is the loser other

00:11:35,600 --> 00:11:40,720
guy other other player wins

00:11:37,519 --> 00:11:43,360
that's it let's see an example here

00:11:40,720 --> 00:11:44,320
so we have a two heaps he zero and hip

00:11:43,360 --> 00:11:46,640
one

00:11:44,320 --> 00:11:47,600
hip zero has eight names he one have

00:11:46,640 --> 00:11:50,800
five names

00:11:47,600 --> 00:11:53,839
we have two players john and jane

00:11:50,800 --> 00:11:58,160
so let's say it's john's turn at first

00:11:53,839 --> 00:12:01,040
so he takes two names from h heap zero

00:11:58,160 --> 00:12:01,279
so he revolves now there are six names

00:12:01,040 --> 00:12:04,240
in

00:12:01,279 --> 00:12:05,519
heap zero and five names in heap one

00:12:04,240 --> 00:12:08,959
jane takes two from

00:12:05,519 --> 00:12:12,560
heap one so there is no three

00:12:08,959 --> 00:12:15,839
names in heap one

00:12:12,560 --> 00:12:18,480
and six in heap zero chain takes six

00:12:15,839 --> 00:12:18,480
from zero

00:12:18,639 --> 00:12:23,279
afterwards and only heap one has only

00:12:21,279 --> 00:12:27,040
one left

00:12:23,279 --> 00:12:29,040
so jane wins i i hope you got some idea

00:12:27,040 --> 00:12:33,760
of the game

00:12:29,040 --> 00:12:33,760
let's go to the code demo part now

00:12:34,639 --> 00:12:40,480
let's get started with our demo for

00:12:38,079 --> 00:12:43,279
for the for this demo i'm using flit for

00:12:40,480 --> 00:12:46,320
uh building and packaging

00:12:43,279 --> 00:12:48,800
so let's get started we use flit

00:12:46,320 --> 00:12:50,160
in it to generate the pipe project or

00:12:48,800 --> 00:12:52,880
thermal file

00:12:50,160 --> 00:12:54,000
uh you alright some questions just

00:12:52,880 --> 00:12:58,720
answer them

00:12:54,000 --> 00:12:59,120
um my email id you can skip this if you

00:12:58,720 --> 00:13:01,920
like

00:12:59,120 --> 00:13:03,519
but i'm entering some of them i'm using

00:13:01,920 --> 00:13:05,440
mit license

00:13:03,519 --> 00:13:07,040
okay now the pi project to terminal file

00:13:05,440 --> 00:13:08,399
has been generated here along with the

00:13:07,040 --> 00:13:10,000
license

00:13:08,399 --> 00:13:11,920
so let's have a look at the pipe project

00:13:10,000 --> 00:13:15,600
the tamil file

00:13:11,920 --> 00:13:16,800
it has the information to tell the tool

00:13:15,600 --> 00:13:20,079
that

00:13:16,800 --> 00:13:21,519
we are using flit for building and some

00:13:20,079 --> 00:13:25,040
data related to

00:13:21,519 --> 00:13:28,880
that we will edit some of these

00:13:25,040 --> 00:13:29,519
options uh later on okay now we have to

00:13:28,880 --> 00:13:32,560
generate

00:13:29,519 --> 00:13:35,519
the directories to store the source code

00:13:32,560 --> 00:13:36,079
and the test files now i'm using the src

00:13:35,519 --> 00:13:39,920
layout

00:13:36,079 --> 00:13:43,839
i prefer to play it safer so

00:13:39,920 --> 00:13:48,720
let's create them src names

00:13:43,839 --> 00:13:52,399
in the test directories voila oops

00:13:48,720 --> 00:13:53,120
yeah this is now i'm descending into the

00:13:52,399 --> 00:13:57,600
source

00:13:53,120 --> 00:14:01,360
names directory and then creating

00:13:57,600 --> 00:14:02,639
two files one is the name spyfile where

00:14:01,360 --> 00:14:04,399
i will have the

00:14:02,639 --> 00:14:06,320
more most of the source code i mean

00:14:04,399 --> 00:14:08,959
almost all of the source code

00:14:06,320 --> 00:14:10,000
and the init five file to indicate that

00:14:08,959 --> 00:14:13,120
this is a

00:14:10,000 --> 00:14:16,320
package so any

00:14:13,120 --> 00:14:20,880
let's open up the init.pi

00:14:16,320 --> 00:14:24,000
file in the names.py file we define

00:14:20,880 --> 00:14:24,000
a class nibs

00:14:24,480 --> 00:14:31,519
this class represents the entire nims

00:14:27,519 --> 00:14:34,560
game along with the data required for it

00:14:31,519 --> 00:14:37,920
so the constructor has these

00:14:34,560 --> 00:14:41,680
four uh values the

00:14:37,920 --> 00:14:44,959
heaps is a list of integers

00:14:41,680 --> 00:14:48,240
where each integer corresponds to

00:14:44,959 --> 00:14:51,600
the number of names in a heap

00:14:48,240 --> 00:14:54,639
inside the names game

00:14:51,600 --> 00:14:58,399
so for example the index

00:14:54,639 --> 00:14:59,120
uh one of the heaps list corresponds to

00:14:58,399 --> 00:15:02,160
the number of

00:14:59,120 --> 00:15:05,199
names present in the heap one and

00:15:02,160 --> 00:15:08,399
the same way heap 0

00:15:05,199 --> 00:15:12,079
has a number of names present

00:15:08,399 --> 00:15:15,440
in heap 0 i mean in

00:15:12,079 --> 00:15:18,399
heaps of zero the index zero yeah

00:15:15,440 --> 00:15:19,680
and n hip it's a total number of heaps

00:15:18,399 --> 00:15:23,040
present in the

00:15:19,680 --> 00:15:24,959
entire nymph game and maximums has the

00:15:23,040 --> 00:15:26,320
total number of i mean maximum number of

00:15:24,959 --> 00:15:30,320
names possible in

00:15:26,320 --> 00:15:33,680
in a in a hip and turn

00:15:30,320 --> 00:15:34,880
shows whose turn it is which players

00:15:33,680 --> 00:15:37,920
turn it is

00:15:34,880 --> 00:15:38,480
next so in our game there are two

00:15:37,920 --> 00:15:42,320
players

00:15:38,480 --> 00:15:45,360
the the computer and the user

00:15:42,320 --> 00:15:45,839
so the turn the value of turn is a

00:15:45,360 --> 00:15:49,279
string

00:15:45,839 --> 00:15:53,040
where user uh corresponds to the

00:15:49,279 --> 00:15:56,320
user stand and com corresponds to the uh

00:15:53,040 --> 00:15:58,880
turn of the computer itself and

00:15:56,320 --> 00:16:00,000
this value self.total the total

00:15:58,880 --> 00:16:02,399
attribute

00:16:00,000 --> 00:16:05,040
contains the total number of names

00:16:02,399 --> 00:16:07,519
present in the or among all the

00:16:05,040 --> 00:16:08,720
heaps available in the game when this

00:16:07,519 --> 00:16:11,279
value becomes

00:16:08,720 --> 00:16:12,560
less than or equal to 1 we have a winner

00:16:11,279 --> 00:16:14,639
and the game is over

00:16:12,560 --> 00:16:16,880
let's next is define a function which

00:16:14,639 --> 00:16:19,360
will change the turn

00:16:16,880 --> 00:16:21,279
change the value of the turn attribute

00:16:19,360 --> 00:16:24,160
after each turn of the game

00:16:21,279 --> 00:16:25,600
so we'll call that functions change turn

00:16:24,160 --> 00:16:28,880
the method

00:16:25,600 --> 00:16:30,639
and it looks like this so it's quite

00:16:28,880 --> 00:16:32,320
obvious what it does uh

00:16:30,639 --> 00:16:34,240
if the value is used it will turn it

00:16:32,320 --> 00:16:34,800
into com to value if it's coming it's

00:16:34,240 --> 00:16:37,519
time to

00:16:34,800 --> 00:16:38,240
turn so just switching the value that's

00:16:37,519 --> 00:16:41,279
it

00:16:38,240 --> 00:16:43,519
let us try running pylind on the program

00:16:41,279 --> 00:16:43,519
now

00:16:43,680 --> 00:16:47,759
uh the old one is there okay

00:16:48,160 --> 00:16:52,639
violin complains oh we did not import

00:16:51,279 --> 00:16:54,720
the random

00:16:52,639 --> 00:16:56,480
module even though we are using it in

00:16:54,720 --> 00:16:59,920
the constructor there

00:16:56,480 --> 00:17:04,640
so we will import it and

00:16:59,920 --> 00:17:08,160
all we are missing module dog strings

00:17:04,640 --> 00:17:10,319
i hope that's okay that's a module dog

00:17:08,160 --> 00:17:12,799
string and the class needs a dog string

00:17:10,319 --> 00:17:12,799
as well

00:17:16,000 --> 00:17:22,079
represents names game

00:17:20,240 --> 00:17:25,679
okay these are just random things that i

00:17:22,079 --> 00:17:25,679
came up with these dark springs

00:17:30,240 --> 00:17:35,360
okay let's see what violin says now

00:17:35,840 --> 00:17:41,679
says trailing new lines in line 23.

00:17:39,280 --> 00:17:43,440
let us see oh that's that's that doesn't

00:17:41,679 --> 00:17:47,120
matter really right now

00:17:43,440 --> 00:17:49,120
so too few public mothers we will fix

00:17:47,120 --> 00:17:51,760
that soon enough so let's move on

00:17:49,120 --> 00:17:53,600
let us create the methods representing

00:17:51,760 --> 00:17:54,640
the terms of the user and the computer

00:17:53,600 --> 00:17:58,720
next

00:17:54,640 --> 00:18:01,120
so we go here and do this

00:17:58,720 --> 00:18:01,919
this compton function represents the

00:18:01,120 --> 00:18:04,880
turn of

00:18:01,919 --> 00:18:06,480
the computer and this use return that of

00:18:04,880 --> 00:18:09,919
the user

00:18:06,480 --> 00:18:14,080
so let us try running my pi on this

00:18:09,919 --> 00:18:16,080
at this point says nothing no problem

00:18:14,080 --> 00:18:18,960
that's probably because you have not

00:18:16,080 --> 00:18:22,400
made use of a type annotations on which

00:18:18,960 --> 00:18:24,720
a my pair relies on so let's do some

00:18:22,400 --> 00:18:28,960
typing

00:18:24,720 --> 00:18:32,160
let's uh import some

00:18:28,960 --> 00:18:33,840
names that we will be using here from

00:18:32,160 --> 00:18:36,480
the typing module

00:18:33,840 --> 00:18:38,640
in the constructor heaps is a list of

00:18:36,480 --> 00:18:42,400
integers

00:18:38,640 --> 00:18:46,000
he is an integer likewise with the

00:18:42,400 --> 00:18:50,080
max names but turn

00:18:46,000 --> 00:18:51,840
is a string so

00:18:50,080 --> 00:18:53,919
this player has written type already

00:18:51,840 --> 00:18:57,360
annotated

00:18:53,919 --> 00:18:59,200
compton compton returns

00:18:57,360 --> 00:19:00,640
and as mentioned in the dark string at

00:18:59,200 --> 00:19:04,160
tuple

00:19:00,640 --> 00:19:07,760
of in two integers

00:19:04,160 --> 00:19:10,880
and use the term likewise same

00:19:07,760 --> 00:19:14,480
tuple of two integers the

00:19:10,880 --> 00:19:18,080
the heap id the heap index and the

00:19:14,480 --> 00:19:21,520
nim count the number of names so uh

00:19:18,080 --> 00:19:21,520
let's try running my pi again

00:19:21,679 --> 00:19:25,200
it says we missed something let's have a

00:19:23,280 --> 00:19:29,120
look what it is

00:19:25,200 --> 00:19:32,640
oh we have not returned its id

00:19:29,120 --> 00:19:34,400
and names like we were supposed to

00:19:32,640 --> 00:19:36,480
if that's the only thing yeah my pain

00:19:34,400 --> 00:19:38,799
has no problems now

00:19:36,480 --> 00:19:40,480
no problem okay but something else is

00:19:38,799 --> 00:19:44,080
missing let's try running

00:19:40,480 --> 00:19:44,080
pylint once again

00:19:47,200 --> 00:19:53,039
see at line 45 there's some problem

00:19:51,200 --> 00:19:55,440
it's a static method it does not use

00:19:53,039 --> 00:19:55,440
itself

00:19:55,600 --> 00:19:58,880
so we get rid of that

00:20:00,640 --> 00:20:06,240
and pylon is more or less happy he's

00:20:03,120 --> 00:20:08,080
happier at least

00:20:06,240 --> 00:20:09,679
so we are running out of time so let's

00:20:08,080 --> 00:20:12,640
see the rest of the functions there are

00:20:09,679 --> 00:20:12,640
four of them i think

00:20:14,159 --> 00:20:20,400
yeah this function here play is actually

00:20:18,000 --> 00:20:21,360
the driver function the game loop is

00:20:20,400 --> 00:20:24,159
present here this

00:20:21,360 --> 00:20:24,159
is the game loop

00:20:25,039 --> 00:20:32,840
and the next turn function

00:20:28,640 --> 00:20:37,679
here represents eastern in the

00:20:32,840 --> 00:20:40,080
game and this validate function

00:20:37,679 --> 00:20:42,720
validates the input this is used only if

00:20:40,080 --> 00:20:44,559
uh not only is to validate the heap id

00:20:42,720 --> 00:20:48,000
whether the heap id given

00:20:44,559 --> 00:20:50,240
as uh is valid he by something that

00:20:48,000 --> 00:20:51,200
exists and there are enough names to be

00:20:50,240 --> 00:20:53,440
taken

00:20:51,200 --> 00:20:54,240
and and all those checks will be done in

00:20:53,440 --> 00:20:55,840
this function

00:20:54,240 --> 00:20:58,240
right now our package looks something

00:20:55,840 --> 00:21:00,720
like this

00:20:58,240 --> 00:21:02,559
so let's have another look at our pry

00:21:00,720 --> 00:21:03,679
project or thermal file that we created

00:21:02,559 --> 00:21:07,120
earlier

00:21:03,679 --> 00:21:09,280
and tell them that we require

00:21:07,120 --> 00:21:12,320
a python version greater than or equal

00:21:09,280 --> 00:21:14,240
to 3.6

00:21:12,320 --> 00:21:16,640
and also mention the development

00:21:14,240 --> 00:21:19,679
dependencies we use these packages

00:21:16,640 --> 00:21:21,520
while developing this package nymphs now

00:21:19,679 --> 00:21:24,880
let us try installing

00:21:21,520 --> 00:21:26,559
the development dependencies with let

00:21:24,880 --> 00:21:31,840
installed sim

00:21:26,559 --> 00:21:31,840
link yeah it is

00:21:42,840 --> 00:21:45,840
there

00:22:15,360 --> 00:22:20,320
so let us use fighters to run the test

00:22:17,840 --> 00:22:22,880
that we have set up

00:22:20,320 --> 00:22:23,760
our pi test pass is okay the tests have

00:22:22,880 --> 00:22:26,640
passed but

00:22:23,760 --> 00:22:29,520
have our test actually covered all the

00:22:26,640 --> 00:22:32,480
cases that we want to cover

00:22:29,520 --> 00:22:33,360
let us use coverage to check that

00:22:32,480 --> 00:22:36,799
correspond

00:22:33,360 --> 00:22:40,400
with pi test we are using it lightest

00:22:36,799 --> 00:22:43,280
yes we have let's see the result

00:22:40,400 --> 00:22:43,919
of the coverage report yes it's hundred

00:22:43,280 --> 00:22:47,440
percent

00:22:43,919 --> 00:22:49,600
so it's okay it works now let's use

00:22:47,440 --> 00:22:51,120
talks to set up consolidate all the

00:22:49,600 --> 00:22:54,000
steps into one place so we can

00:22:51,120 --> 00:22:55,520
actually automate it and even use uh

00:22:54,000 --> 00:22:57,919
different versions of python or maybe

00:22:55,520 --> 00:23:01,120
even different implementation of python

00:22:57,919 --> 00:23:04,880
to test run all these tests so let's

00:23:01,120 --> 00:23:07,760
set up talks.eni file this is the talks

00:23:04,880 --> 00:23:08,480
configuration file that i have used so

00:23:07,760 --> 00:23:12,000
it uses

00:23:08,480 --> 00:23:14,720
python 3.6 3.7 3.8 and pi

00:23:12,000 --> 00:23:15,600
pi 3 another implementation it's not c

00:23:14,720 --> 00:23:18,480
python

00:23:15,600 --> 00:23:19,679
and vulture we used see if there's any

00:23:18,480 --> 00:23:23,440
dead code

00:23:19,679 --> 00:23:23,760
and my pythagorean pylon linting checks

00:23:23,440 --> 00:23:26,559
and

00:23:23,760 --> 00:23:27,679
test coverage buildup and the tests have

00:23:26,559 --> 00:23:30,480
passed

00:23:27,679 --> 00:23:31,440
let us build the package that we have

00:23:30,480 --> 00:23:35,120
created

00:23:31,440 --> 00:23:37,840
with flit build

00:23:35,120 --> 00:23:39,039
oh before that we have to edit our init

00:23:37,840 --> 00:23:42,080
file

00:23:39,039 --> 00:23:46,480
in inside the directory

00:23:42,080 --> 00:23:48,400
otherwise it won't be happy like this

00:23:46,480 --> 00:23:50,080
update the version number it was already

00:23:48,400 --> 00:23:53,840
done

00:23:50,080 --> 00:23:54,640
expose the class name to the outside

00:23:53,840 --> 00:23:58,159
fold

00:23:54,640 --> 00:23:58,159
add at the dock string

00:23:58,320 --> 00:24:05,840
and that's it now build

00:24:01,600 --> 00:24:05,840
the package with flit build

00:24:06,000 --> 00:24:09,200
now you can publish your package using

00:24:08,320 --> 00:24:12,000
flit

00:24:09,200 --> 00:24:12,559
publish now i'm not actually going to

00:24:12,000 --> 00:24:15,440
run

00:24:12,559 --> 00:24:18,080
this command because running will by

00:24:15,440 --> 00:24:21,120
default will try to push to the pipe bi

00:24:18,080 --> 00:24:23,360
server which i don't want to and

00:24:21,120 --> 00:24:24,880
would be nice to do but you what you

00:24:23,360 --> 00:24:28,559
could do is uh

00:24:24,880 --> 00:24:31,760
configure your uh pipe

00:24:28,559 --> 00:24:34,000
rc file so that

00:24:31,760 --> 00:24:36,000
you will kind of push to test dot pr

00:24:34,000 --> 00:24:38,720
type i first

00:24:36,000 --> 00:24:39,279
so you you can fool around there see if

00:24:38,720 --> 00:24:41,440
your

00:24:39,279 --> 00:24:43,200
package has any problems fix them and

00:24:41,440 --> 00:24:46,400
once you're sure you can

00:24:43,200 --> 00:24:49,679
push to the pipe.org server

00:24:46,400 --> 00:24:52,640
so we have a package already let's

00:24:49,679 --> 00:24:54,320
try it out shall we i have here an

00:24:52,640 --> 00:24:57,039
example program

00:24:54,320 --> 00:24:57,039
let's run it

00:24:58,840 --> 00:25:03,919
okay uh

00:25:01,360 --> 00:25:06,159
it's my turn the user's done i will take

00:25:03,919 --> 00:25:06,159
uh

00:25:06,400 --> 00:25:13,200
one name from first heap

00:25:09,840 --> 00:25:14,159
oh the computer beat me to it it took

00:25:13,200 --> 00:25:16,240
three names

00:25:14,159 --> 00:25:17,760
from heap zero and one even if it was

00:25:16,240 --> 00:25:21,039
generating random numbers it

00:25:17,760 --> 00:25:25,760
generated the right random number so

00:25:21,039 --> 00:25:25,760
that's it so that's it thanks for being

00:25:26,679 --> 00:25:29,679

YouTube URL: https://www.youtube.com/watch?v=_b8D4v7YIME


