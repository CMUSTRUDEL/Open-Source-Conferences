Title: "A Reflection on Software Testing" - Richard Jones (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Richard Jones

https://2020.pycon.org.au/program/MXZVY8

This is an opinionated talk about issues I have observed during my career around software testing, including our conversations about it, but also the many materials produced describing how it should be done. One of my inspirations for this talk is the realisation that in some ways we have lost our way with testing, losing sight of some of the very early wisdom.

I will talk about some of those conversations we have, the language we use, but I will also present some advice, with concrete examples, of how we all might improve how we approach and implement testing.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 13:00:00 2020 at Python 2
Captions: 
	00:00:06,560 --> 00:00:10,240
hi everyone i'm richard

00:00:08,320 --> 00:00:12,719
today i'm going to talk about software

00:00:10,240 --> 00:00:14,559
testing reflecting on some of the things

00:00:12,719 --> 00:00:16,720
that i've learned

00:00:14,559 --> 00:00:17,920
when i started out writing software the

00:00:16,720 --> 00:00:20,960
idea of testing it

00:00:17,920 --> 00:00:23,359
using other code was super daunting

00:00:20,960 --> 00:00:25,920
especially in c which is what most of my

00:00:23,359 --> 00:00:28,160
code was written in at the time

00:00:25,920 --> 00:00:29,679
since then i've been on a journey to be

00:00:28,160 --> 00:00:32,320
both introduced to

00:00:29,679 --> 00:00:33,760
and independently learn about various

00:00:32,320 --> 00:00:37,440
ideas and techniques

00:00:33,760 --> 00:00:38,960
around testing the code i'm working on

00:00:37,440 --> 00:00:41,360
along the way i've had many

00:00:38,960 --> 00:00:43,200
conversations with other developers

00:00:41,360 --> 00:00:46,239
where we express the concern that

00:00:43,200 --> 00:00:46,239
testing is hard

00:00:46,719 --> 00:00:52,640
test driven development or tdd is

00:00:49,920 --> 00:00:53,680
so much harder than test after

00:00:52,640 --> 00:00:56,840
development

00:00:53,680 --> 00:00:58,000
also known as eventually consistent

00:00:56,840 --> 00:01:01,359
testing

00:00:58,000 --> 00:01:04,320
do any of these resonate with you

00:01:01,359 --> 00:01:06,479
my test suite is more code than the code

00:01:04,320 --> 00:01:08,560
being tested

00:01:06,479 --> 00:01:10,799
my tests are more complicated than the

00:01:08,560 --> 00:01:14,960
code being tested

00:01:10,799 --> 00:01:18,720
my mocks break all the time

00:01:14,960 --> 00:01:21,759
tdd is too hard i can't predict the code

00:01:18,720 --> 00:01:22,560
that i'm going to write i'm not

00:01:21,759 --> 00:01:24,880
confident

00:01:22,560 --> 00:01:25,600
the code is going to work without

00:01:24,880 --> 00:01:29,040
testing it

00:01:25,600 --> 00:01:31,680
manually it can be hard it can be

00:01:29,040 --> 00:01:34,079
complicated and it can be frustrating

00:01:31,680 --> 00:01:36,320
as a more experienced developer i have

00:01:34,079 --> 00:01:38,400
worked through a lot of that difficulty

00:01:36,320 --> 00:01:39,439
and frustration and come out the other

00:01:38,400 --> 00:01:41,119
side

00:01:39,439 --> 00:01:42,640
and i'd like to reflect on some of the

00:01:41,119 --> 00:01:45,759
things that i've experienced

00:01:42,640 --> 00:01:48,399
and learned along the way

00:01:45,759 --> 00:01:49,439
this talk is broadly split into two

00:01:48,399 --> 00:01:51,680
parts

00:01:49,439 --> 00:01:53,840
in the first i will talk about some

00:01:51,680 --> 00:01:55,840
things that i believe are making testing

00:01:53,840 --> 00:01:57,840
harder than it needs to be

00:01:55,840 --> 00:01:59,680
and in the second i will talk about some

00:01:57,840 --> 00:02:02,960
things i think we can do

00:01:59,680 --> 00:02:02,960
to make testing easier

00:02:03,119 --> 00:02:06,399
i'd like to talk a bit about the

00:02:04,799 --> 00:02:09,520
conversations we're having

00:02:06,399 --> 00:02:10,959
around testing if there's one thing we

00:02:09,520 --> 00:02:13,840
developers do well

00:02:10,959 --> 00:02:15,280
it's be bad at conveying ideas outside

00:02:13,840 --> 00:02:17,360
of code

00:02:15,280 --> 00:02:18,720
disagreeing about the meanings of

00:02:17,360 --> 00:02:22,000
specific words

00:02:18,720 --> 00:02:24,560
is the distillation of that

00:02:22,000 --> 00:02:26,800
so many times in so many environments

00:02:24,560 --> 00:02:29,120
i've had conversations about testing

00:02:26,800 --> 00:02:30,800
that have gotten bogged down or have

00:02:29,120 --> 00:02:33,519
ended ambiguously

00:02:30,800 --> 00:02:35,920
because we have different internal ideas

00:02:33,519 --> 00:02:37,200
about what very common words and phrases

00:02:35,920 --> 00:02:39,599
mean

00:02:37,200 --> 00:02:41,200
for example if i asked you to define

00:02:39,599 --> 00:02:44,080
what an end-to-end test

00:02:41,200 --> 00:02:44,720
is i can guarantee that your current

00:02:44,080 --> 00:02:47,360
previous

00:02:44,720 --> 00:02:49,360
or future software collaborators will

00:02:47,360 --> 00:02:51,360
have learned and internalized

00:02:49,360 --> 00:02:53,360
subtly or even wildly different

00:02:51,360 --> 00:02:55,360
definitions

00:02:53,360 --> 00:02:56,480
through a vast and very long game of

00:02:55,360 --> 00:02:58,319
telephone

00:02:56,480 --> 00:03:00,560
we've all come to differing

00:02:58,319 --> 00:03:04,000
understandings of what testing is

00:03:00,560 --> 00:03:06,560
and how to do it and this can lead to

00:03:04,000 --> 00:03:07,760
frustration and even conflict which

00:03:06,560 --> 00:03:09,760
stems from that

00:03:07,760 --> 00:03:10,879
difference in our internalized

00:03:09,760 --> 00:03:13,040
expectation

00:03:10,879 --> 00:03:15,920
of what we're trying to achieve compared

00:03:13,040 --> 00:03:15,920
to somebody else

00:03:17,040 --> 00:03:20,400
similarly if i asked you to define any

00:03:19,760 --> 00:03:23,760
of

00:03:20,400 --> 00:03:26,000
unit integration or functional test

00:03:23,760 --> 00:03:27,920
i can also guarantee that you'll have

00:03:26,000 --> 00:03:29,840
different definitions to mine

00:03:27,920 --> 00:03:31,760
or any other num any number of other

00:03:29,840 --> 00:03:35,200
developers

00:03:31,760 --> 00:03:38,319
so what is a unit in a unit test

00:03:35,200 --> 00:03:39,360
is it a function is it a class is it a

00:03:38,319 --> 00:03:42,560
module

00:03:39,360 --> 00:03:44,560
is it a business rule

00:03:42,560 --> 00:03:46,400
going right back to the very earliest

00:03:44,560 --> 00:03:49,680
definition of unit testing

00:03:46,400 --> 00:03:53,280
a unit was defined by kentbeck as a

00:03:49,680 --> 00:03:55,599
unit of code in isolation

00:03:53,280 --> 00:03:57,280
code tests were not necessarily well

00:03:55,599 --> 00:03:59,760
sized or focused

00:03:57,280 --> 00:04:00,319
and not well isolated from each other in

00:03:59,760 --> 00:04:03,519
scope

00:04:00,319 --> 00:04:03,519
or even execution

00:04:03,760 --> 00:04:07,599
sometimes tests would leak state and

00:04:06,159 --> 00:04:09,840
affect other tests

00:04:07,599 --> 00:04:10,879
sometimes causing them to pass

00:04:09,840 --> 00:04:15,360
incorrectly

00:04:10,879 --> 00:04:17,600
or causing them to fail unexpectedly

00:04:15,360 --> 00:04:19,199
so this is where unit testing started

00:04:17,600 --> 00:04:20,160
but through that game of telephone i

00:04:19,199 --> 00:04:22,560
mentioned

00:04:20,160 --> 00:04:24,880
the meaning has been altered and some

00:04:22,560 --> 00:04:28,720
important aspects of the message

00:04:24,880 --> 00:04:32,320
lost many developers will assert

00:04:28,720 --> 00:04:35,520
that a unit is defined by some specific

00:04:32,320 --> 00:04:40,320
code shape like a single function or

00:04:35,520 --> 00:04:42,240
single class personally i find a slight

00:04:40,320 --> 00:04:43,759
variation of kent beck's definition to

00:04:42,240 --> 00:04:45,840
be very helpful

00:04:43,759 --> 00:04:49,440
note that i don't define it by an amount

00:04:45,840 --> 00:04:52,000
of code just an isolated behavior

00:04:49,440 --> 00:04:52,800
how that behavior is defined is entirely

00:04:52,000 --> 00:04:54,840
dependent

00:04:52,800 --> 00:04:56,560
on the specifics of the application in

00:04:54,840 --> 00:04:58,880
question

00:04:56,560 --> 00:05:01,520
we need to be flexible in allowing as

00:04:58,880 --> 00:05:02,320
little or as much code to be covered by

00:05:01,520 --> 00:05:06,160
the test

00:05:02,320 --> 00:05:09,440
as needed to isolate that behavior

00:05:06,160 --> 00:05:10,160
tests can and should test several

00:05:09,440 --> 00:05:12,320
classes

00:05:10,160 --> 00:05:14,720
working together if that is what is

00:05:12,320 --> 00:05:14,720
needed

00:05:14,880 --> 00:05:18,720
another very common point of confusion

00:05:17,199 --> 00:05:20,960
is having conversations

00:05:18,720 --> 00:05:21,840
where developers will use the terms end

00:05:20,960 --> 00:05:24,880
to end or

00:05:21,840 --> 00:05:27,360
integrated to encompass their own idea

00:05:24,880 --> 00:05:27,919
of a set of constraints on a test

00:05:27,360 --> 00:05:30,320
without

00:05:27,919 --> 00:05:32,639
expressing those constraints and leaving

00:05:30,320 --> 00:05:33,280
as implied some characteristics of the

00:05:32,639 --> 00:05:37,280
tests

00:05:33,280 --> 00:05:40,080
that distinguish them from unit tests

00:05:37,280 --> 00:05:42,720
what are the ends though are they a

00:05:40,080 --> 00:05:45,120
front end and a back end

00:05:42,720 --> 00:05:46,560
are they a start and an end of a

00:05:45,120 --> 00:05:48,880
workflow

00:05:46,560 --> 00:05:50,240
popular tooling exposes some of this

00:05:48,880 --> 00:05:53,360
confusion

00:05:50,240 --> 00:05:56,240
for example

00:05:53,360 --> 00:05:56,720
for example the angular project cookie

00:05:56,240 --> 00:05:59,759
cutter

00:05:56,720 --> 00:06:03,039
angular cli it creates projects with an

00:05:59,759 --> 00:06:05,280
e to e folder short for end to end

00:06:03,039 --> 00:06:07,280
which contains browser-based user

00:06:05,280 --> 00:06:09,919
interface tests

00:06:07,280 --> 00:06:10,720
the implication here is that end-to-end

00:06:09,919 --> 00:06:13,360
is driven

00:06:10,720 --> 00:06:14,560
through the ui backed onto a mocked back

00:06:13,360 --> 00:06:17,280
end

00:06:14,560 --> 00:06:18,080
the angular e2e docs muddy the waters

00:06:17,280 --> 00:06:21,039
even more

00:06:18,080 --> 00:06:24,319
by including the phrase also knows known

00:06:21,039 --> 00:06:24,319
as integration testing

00:06:25,600 --> 00:06:28,960
more recently i've been developing react

00:06:27,919 --> 00:06:32,160
applications

00:06:28,960 --> 00:06:34,319
and searching for react e to e testing

00:06:32,160 --> 00:06:36,080
results in many different opinions about

00:06:34,319 --> 00:06:38,720
what that might look like

00:06:36,080 --> 00:06:40,000
do you automate a browser do you mock

00:06:38,720 --> 00:06:43,360
out your back end

00:06:40,000 --> 00:06:43,360
many opinions are bound

00:06:44,720 --> 00:06:48,080
if you start talking about integrated

00:06:46,639 --> 00:06:50,479
testing then things get

00:06:48,080 --> 00:06:51,120
even more variable as i've already

00:06:50,479 --> 00:06:53,840
mentioned

00:06:51,120 --> 00:06:55,199
for some people e to e means integrated

00:06:53,840 --> 00:06:57,680
and vice versa

00:06:55,199 --> 00:06:58,560
for some people an integrated test can

00:06:57,680 --> 00:07:00,800
only consider

00:06:58,560 --> 00:07:01,759
a fully deployed environment with the

00:07:00,800 --> 00:07:04,560
application

00:07:01,759 --> 00:07:06,400
its dependent services and any databases

00:07:04,560 --> 00:07:09,199
required to support them

00:07:06,400 --> 00:07:10,800
these are often manually run tests and

00:07:09,199 --> 00:07:14,160
require a ton of work

00:07:10,800 --> 00:07:17,120
to set up for others

00:07:14,160 --> 00:07:19,919
a set of services in a mesh with is

00:07:17,120 --> 00:07:23,280
sufficient to test specific interactions

00:07:19,919 --> 00:07:23,280
though still with no mocking

00:07:23,520 --> 00:07:26,960
perhaps all dependent services except

00:07:26,080 --> 00:07:30,800
the database

00:07:26,960 --> 00:07:31,919
are mocked for a slowly growing number

00:07:30,800 --> 00:07:33,759
of developers

00:07:31,919 --> 00:07:36,400
integration testing is done through

00:07:33,759 --> 00:07:38,560
contracts using a tool like pact

00:07:36,400 --> 00:07:40,479
to declare interactions between

00:07:38,560 --> 00:07:43,440
consumers and providers

00:07:40,479 --> 00:07:44,000
and to verify those tests are still

00:07:43,440 --> 00:07:46,639
valid

00:07:44,000 --> 00:07:46,639
over time

00:07:47,680 --> 00:07:52,080
as i've mentioned for some developers

00:07:50,000 --> 00:07:52,639
the testing of a user interface over at

00:07:52,080 --> 00:07:55,599
back end

00:07:52,639 --> 00:07:57,199
is an integrated test i've also

00:07:55,599 --> 00:07:58,080
encountered some more fine grained

00:07:57,199 --> 00:08:00,479
definitions

00:07:58,080 --> 00:08:02,960
stating that a test that encompasses

00:08:00,479 --> 00:08:06,720
presentation layer over business logic

00:08:02,960 --> 00:08:08,479
is integration further i've had

00:08:06,720 --> 00:08:10,560
developers who have a very specific

00:08:08,479 --> 00:08:12,639
concept of what a unit test is

00:08:10,560 --> 00:08:14,560
claim that any test that crosses a

00:08:12,639 --> 00:08:17,840
module or class boundary

00:08:14,560 --> 00:08:19,919
is an integration test or even anything

00:08:17,840 --> 00:08:22,400
outside of a single function

00:08:19,919 --> 00:08:24,960
but is any of that helpful having those

00:08:22,400 --> 00:08:26,639
hard boundaries and rules internalized

00:08:24,960 --> 00:08:28,560
that will invariably only lead to

00:08:26,639 --> 00:08:32,479
confusion frustration

00:08:28,560 --> 00:08:34,800
and even conflict with other developers

00:08:32,479 --> 00:08:36,880
probably the clearest demonstration of

00:08:34,800 --> 00:08:39,680
this wild difference in opinion

00:08:36,880 --> 00:08:40,080
is the testing pyramid first presented

00:08:39,680 --> 00:08:43,440
by

00:08:40,080 --> 00:08:45,760
mike cohn in 2009 it was a good idea and

00:08:43,440 --> 00:08:48,240
simple in presentation

00:08:45,760 --> 00:08:49,920
the basic premise is that more effort

00:08:48,240 --> 00:08:52,480
should be spent in the fatteds

00:08:49,920 --> 00:08:53,279
fatter sections of the pyramid the

00:08:52,480 --> 00:08:56,320
labels are

00:08:53,279 --> 00:08:56,959
reasonably straightforward unit and ui

00:08:56,320 --> 00:08:59,519
tests

00:08:56,959 --> 00:09:02,000
are reasonable concepts to agree on but

00:08:59,519 --> 00:09:04,880
the service layer is interesting

00:09:02,000 --> 00:09:06,959
it refers to larger components or higher

00:09:04,880 --> 00:09:09,360
level functionality

00:09:06,959 --> 00:09:11,040
cohen's example is to test the addition

00:09:09,360 --> 00:09:13,440
or subtraction feature

00:09:11,040 --> 00:09:16,320
of a calculator without poking at the

00:09:13,440 --> 00:09:18,880
buttons in the user interface

00:09:16,320 --> 00:09:20,080
but still we'd have to agree on what the

00:09:18,880 --> 00:09:23,839
boundaries are

00:09:20,080 --> 00:09:23,839
of a service layer test

00:09:26,560 --> 00:09:32,000
but then do an image for testing pyramid

00:09:29,760 --> 00:09:35,120
and marvel at the difference in opinion

00:09:32,000 --> 00:09:37,200
present in the varieties of pyramids

00:09:35,120 --> 00:09:39,200
the variation can encompass such things

00:09:37,200 --> 00:09:42,480
as different types of testing

00:09:39,200 --> 00:09:44,240
manual or automated testing for purposes

00:09:42,480 --> 00:09:46,480
that i've not mentioned thus far

00:09:44,240 --> 00:09:48,959
such as acceptance testing which is

00:09:46,480 --> 00:09:50,240
about meeting contractual obligations

00:09:48,959 --> 00:09:51,920
placed on software

00:09:50,240 --> 00:09:54,000
so that it be fit for its intended

00:09:51,920 --> 00:09:57,040
purpose

00:09:54,000 --> 00:09:58,959
some diagrams break out layers so

00:09:57,040 --> 00:10:00,880
service could become a variety of

00:09:58,959 --> 00:10:05,440
different things like component

00:10:00,880 --> 00:10:08,160
integration or api tests

00:10:05,440 --> 00:10:09,519
yet another pyramid introduces software

00:10:08,160 --> 00:10:12,880
life cycle phases

00:10:09,519 --> 00:10:14,480
into the breakdown of tests with alpha

00:10:12,880 --> 00:10:16,880
and beta testing

00:10:14,480 --> 00:10:18,240
the pyramid's vertical axis now covers

00:10:16,880 --> 00:10:22,240
both complexity

00:10:18,240 --> 00:10:25,279
or cost and waterfall project completion

00:10:22,240 --> 00:10:25,279
completion stages

00:10:26,160 --> 00:10:31,120
some pyramids go so far as to assign

00:10:28,800 --> 00:10:33,680
percentage numbers to the slices of the

00:10:31,120 --> 00:10:36,959
pyramid as if to say that the visual

00:10:33,680 --> 00:10:39,440
slice size isn't enough you must also

00:10:36,959 --> 00:10:40,000
measure the number of tests to ensure

00:10:39,440 --> 00:10:42,720
that

00:10:40,000 --> 00:10:44,240
six percent of your tests are workflow

00:10:42,720 --> 00:10:45,839
tests

00:10:44,240 --> 00:10:48,160
which are somehow different to

00:10:45,839 --> 00:10:50,079
integration tests and business logic

00:10:48,160 --> 00:10:52,480
tests in ways that aren't necessarily

00:10:50,079 --> 00:10:52,480
clear

00:10:52,720 --> 00:10:55,760
this is all derived from a very limited

00:10:55,040 --> 00:10:57,760
selection

00:10:55,760 --> 00:11:00,160
of the hundreds of pyramids that come up

00:10:57,760 --> 00:11:02,640
in a quick search

00:11:00,160 --> 00:11:05,040
and all of them are slightly or wildly

00:11:02,640 --> 00:11:05,040
different

00:11:07,920 --> 00:11:11,040
one version i like beyond mike cohen's

00:11:10,240 --> 00:11:14,079
original

00:11:11,040 --> 00:11:16,480
is by steve fenton in 2015

00:11:14,079 --> 00:11:17,519
instead of using words like unit and

00:11:16,480 --> 00:11:20,160
integration

00:11:17,519 --> 00:11:22,160
that we can't agree on it talks about

00:11:20,160 --> 00:11:25,360
qualities of the tests

00:11:22,160 --> 00:11:26,160
in his diagram malleability refers to

00:11:25,360 --> 00:11:28,560
the tests

00:11:26,160 --> 00:11:31,040
hindering changes to the code being

00:11:28,560 --> 00:11:31,040
tested

00:11:31,360 --> 00:11:34,800
so that gave me an idea

00:11:35,519 --> 00:11:38,640
what if we stopped trying to shoehorn

00:11:37,839 --> 00:11:41,279
our thinking

00:11:38,640 --> 00:11:43,760
into word-shaped boxes and all the

00:11:41,279 --> 00:11:45,920
confusion that arises from that

00:11:43,760 --> 00:11:48,320
and rather we step back and think about

00:11:45,920 --> 00:11:52,000
what broader qualities of tests

00:11:48,320 --> 00:11:54,320
make them good or should be avoided

00:11:52,000 --> 00:11:56,320
much like the zen of python provides us

00:11:54,320 --> 00:11:58,639
with aphorisms to

00:11:56,320 --> 00:11:59,680
allow us to reflect on the code that we

00:11:58,639 --> 00:12:01,680
are writing

00:11:59,680 --> 00:12:05,519
perhaps there is something similar that

00:12:01,680 --> 00:12:05,519
can help us in testing that code

00:12:06,399 --> 00:12:09,519
i found this list of suggested goals of

00:12:08,800 --> 00:12:12,079
testing

00:12:09,519 --> 00:12:14,160
written by kent beck and it partially

00:12:12,079 --> 00:12:17,120
inspired this talk

00:12:14,160 --> 00:12:17,760
it talks about test isolation and

00:12:17,120 --> 00:12:25,839
testing

00:12:17,760 --> 00:12:25,839
behavior and not structure

00:12:26,800 --> 00:12:30,240
kent does explain that not all of those

00:12:29,279 --> 00:12:33,200
goals

00:12:30,240 --> 00:12:34,240
of testing apply to all types of tests

00:12:33,200 --> 00:12:36,959
for example

00:12:34,240 --> 00:12:37,760
he says monitoring abandons being

00:12:36,959 --> 00:12:40,800
predictive

00:12:37,760 --> 00:12:42,880
and to some degree being automated

00:12:40,800 --> 00:12:44,880
i think the list has merit and i've

00:12:42,880 --> 00:12:48,320
drawn upon it for inspiration but i have

00:12:44,880 --> 00:12:48,320
some thoughts of my own as well

00:12:49,279 --> 00:12:54,160
as an aside i find in general that

00:12:52,160 --> 00:12:54,880
there's three levels of memorability for

00:12:54,160 --> 00:12:57,120
me

00:12:54,880 --> 00:12:57,920
when i'm trying to recall complex sets

00:12:57,120 --> 00:13:01,279
of ideas

00:12:57,920 --> 00:13:03,839
like this the first and the most popular

00:13:01,279 --> 00:13:07,040
with professional trainers of management

00:13:03,839 --> 00:13:10,160
process scrum etc is the

00:13:07,040 --> 00:13:13,440
mnemonic acronym things like

00:13:10,160 --> 00:13:16,480
solid acid true smart

00:13:13,440 --> 00:13:18,639
ideal invest spider

00:13:16,480 --> 00:13:20,959
they're great words i bet you all have

00:13:18,639 --> 00:13:22,320
an understanding of what acid might mean

00:13:20,959 --> 00:13:25,600
in general terms

00:13:22,320 --> 00:13:28,399
like it is it's a good reliable database

00:13:25,600 --> 00:13:30,959
but what does the i stand for what does

00:13:28,399 --> 00:13:33,279
it really mean

00:13:30,959 --> 00:13:34,000
or from solid you might be able to

00:13:33,279 --> 00:13:36,880
remember that

00:13:34,000 --> 00:13:37,760
the l stands for the lisk of uncertainty

00:13:36,880 --> 00:13:40,399
principle

00:13:37,760 --> 00:13:41,440
which isn't its actual name but if

00:13:40,399 --> 00:13:43,279
you're like me

00:13:41,440 --> 00:13:44,959
then you're stumped if you can remember

00:13:43,279 --> 00:13:49,839
what liskov was on about

00:13:44,959 --> 00:13:49,839
that is the actual meaning behind the l

00:13:51,360 --> 00:13:55,920
the second tool of memorability as

00:13:53,680 --> 00:13:58,639
presented by kent just now

00:13:55,920 --> 00:13:59,279
is to and but he is by far not alone in

00:13:58,639 --> 00:14:02,160
this

00:13:59,279 --> 00:14:02,880
is a list of words like inspiring

00:14:02,160 --> 00:14:05,360
specific

00:14:02,880 --> 00:14:06,079
and composable it can be easier to

00:14:05,360 --> 00:14:08,720
remember

00:14:06,079 --> 00:14:10,399
these specific words but after a while

00:14:08,720 --> 00:14:14,839
the meaning intended by them

00:14:10,399 --> 00:14:17,839
is lost what did kent mean by

00:14:14,839 --> 00:14:17,839
composable

00:14:18,959 --> 00:14:22,079
the final and by far the most memorable

00:14:21,279 --> 00:14:25,279
for me

00:14:22,079 --> 00:14:25,760
is phrases i can quote the zen of python

00:14:25,279 --> 00:14:27,680
to you

00:14:25,760 --> 00:14:29,279
and i can expound on each of those

00:14:27,680 --> 00:14:31,680
aphorisms because

00:14:29,279 --> 00:14:33,279
as a series of words their intent is

00:14:31,680 --> 00:14:35,600
much clearer

00:14:33,279 --> 00:14:37,199
beautiful is better than ugly explicit

00:14:35,600 --> 00:14:39,680
is better than implicit

00:14:37,199 --> 00:14:41,120
simple is better than complex complex is

00:14:39,680 --> 00:14:44,240
better than complicated

00:14:41,120 --> 00:14:46,240
and so on now it might be

00:14:44,240 --> 00:14:47,519
that you are a little hazy on the deeper

00:14:46,240 --> 00:14:49,920
meaning behind

00:14:47,519 --> 00:14:52,320
complex is better than complicated but

00:14:49,920 --> 00:14:58,959
i'll wager it's still more memorable

00:14:52,320 --> 00:15:00,800
as a concept to think about

00:14:58,959 --> 00:15:02,240
and just on that last one i would like

00:15:00,800 --> 00:15:04,720
to aside in my

00:15:02,240 --> 00:15:08,160
aside because it would be helpful as i

00:15:04,720 --> 00:15:10,959
continue to talk about tests

00:15:08,160 --> 00:15:12,959
a simple thing is easily understood it

00:15:10,959 --> 00:15:15,040
is plain unadorned

00:15:12,959 --> 00:15:17,440
and generally encapsulates a single

00:15:15,040 --> 00:15:19,839
concept

00:15:17,440 --> 00:15:22,480
a complex thing is composed of simple

00:15:19,839 --> 00:15:25,279
things in a straightforward combination

00:15:22,480 --> 00:15:26,000
with clear dependencies hopefully in one

00:15:25,279 --> 00:15:28,959
direction

00:15:26,000 --> 00:15:28,959
between the parts

00:15:29,759 --> 00:15:34,639
a complicated thing is comprised of many

00:15:32,720 --> 00:15:38,639
interconnecting parts with no

00:15:34,639 --> 00:15:38,639
clear dependencies between them

00:15:39,519 --> 00:15:43,120
understanding these definitions it

00:15:41,759 --> 00:15:44,880
follows that simple

00:15:43,120 --> 00:15:47,680
is better than complex which is better

00:15:44,880 --> 00:15:49,680
than complicated

00:15:47,680 --> 00:15:52,000
i'll be coming back to this idea of

00:15:49,680 --> 00:15:55,600
simple over-complex over-complicated

00:15:52,000 --> 00:15:58,399
more during this talk

00:15:55,600 --> 00:16:02,320
so with that in mind i present to you a

00:15:58,399 --> 00:16:09,839
set of aspects of testing to contemplate

00:16:02,320 --> 00:16:11,600
i will now explore each of these in turn

00:16:09,839 --> 00:16:13,839
going right back to the whole thing

00:16:11,600 --> 00:16:16,880
about the beginning of unit tests

00:16:13,839 --> 00:16:20,000
this bears repeating tests

00:16:16,880 --> 00:16:24,480
must be isolated from each other

00:16:20,000 --> 00:16:27,600
a unit is a unit of code in isolation

00:16:24,480 --> 00:16:28,800
tests should always be isolated so that

00:16:27,600 --> 00:16:32,079
they do not impact

00:16:28,800 --> 00:16:35,040
other tests this was a foundational goal

00:16:32,079 --> 00:16:35,040
of unit testing

00:16:35,680 --> 00:16:41,199
they should not alter permanent state or

00:16:38,480 --> 00:16:44,079
modify the testing environment

00:16:41,199 --> 00:16:45,120
no test should ever rely on another test

00:16:44,079 --> 00:16:48,560
having run

00:16:45,120 --> 00:16:48,560
to itself pass

00:16:49,519 --> 00:16:53,440
tests that are isolated from each other

00:16:51,680 --> 00:16:55,440
will return the same result

00:16:53,440 --> 00:16:57,839
regardless of the order in which they

00:16:55,440 --> 00:16:57,839
are run

00:16:57,920 --> 00:17:02,560
if nothing changes the test result

00:17:00,480 --> 00:17:05,120
should not change

00:17:02,560 --> 00:17:06,160
running the test one or a hundred or a

00:17:05,120 --> 00:17:10,559
million times

00:17:06,160 --> 00:17:10,559
will get will achieve the same results

00:17:11,760 --> 00:17:15,679
tests should never leak state and affect

00:17:14,480 --> 00:17:18,160
other tests

00:17:15,679 --> 00:17:20,000
perhaps causing them to pass incorrectly

00:17:18,160 --> 00:17:23,600
or perhaps causing them to fail

00:17:20,000 --> 00:17:25,760
unexpectedly once you

00:17:23,600 --> 00:17:26,799
have isolated tests they should be

00:17:25,760 --> 00:17:29,440
exercised

00:17:26,799 --> 00:17:30,240
constantly at a minimum during

00:17:29,440 --> 00:17:33,200
development

00:17:30,240 --> 00:17:33,440
before commit after commit they should

00:17:33,200 --> 00:17:36,480
be

00:17:33,440 --> 00:17:37,280
exercised by a computer without the need

00:17:36,480 --> 00:17:40,320
for a human

00:17:37,280 --> 00:17:47,840
intervention this removes the need for a

00:17:40,320 --> 00:17:47,840
human to remember to run the tests

00:17:49,520 --> 00:17:54,320
tests should be sensitive to changes in

00:17:51,840 --> 00:17:57,039
the behavior of the code under test

00:17:54,320 --> 00:18:00,640
and not to the structure or detail of

00:17:57,039 --> 00:18:03,520
the code under test

00:18:00,640 --> 00:18:04,640
ideally our unit of testing should not

00:18:03,520 --> 00:18:09,039
be a function

00:18:04,640 --> 00:18:09,039
it should be an isolated behavior

00:18:10,160 --> 00:18:14,400
testing an isolated behavior will

00:18:12,640 --> 00:18:17,520
improve your test suite's

00:18:14,400 --> 00:18:18,160
malleability its ability to continue to

00:18:17,520 --> 00:18:19,840
pass

00:18:18,160 --> 00:18:21,840
regardless of the underlying

00:18:19,840 --> 00:18:24,799
implementation

00:18:21,840 --> 00:18:27,200
what is a behavior though it could be

00:18:24,799 --> 00:18:30,000
calculating the total value of an order

00:18:27,200 --> 00:18:30,640
based on the line items received it

00:18:30,000 --> 00:18:33,760
could be

00:18:30,640 --> 00:18:37,520
calculating the duration of a train

00:18:33,760 --> 00:18:37,520
running between two stops

00:18:37,600 --> 00:18:40,960
if an order can sometimes have a

00:18:39,520 --> 00:18:43,039
discount applied to it

00:18:40,960 --> 00:18:44,320
that is a separate behavior that should

00:18:43,039 --> 00:18:47,440
be tested

00:18:44,320 --> 00:18:48,400
that is don't have one test that tests

00:18:47,440 --> 00:18:52,160
the total

00:18:48,400 --> 00:18:52,160
with and without a discount

00:18:52,240 --> 00:18:55,280
if you need to test multiple similar

00:18:54,320 --> 00:18:57,600
behaviors

00:18:55,280 --> 00:18:58,960
you can use a tool like pi tests

00:18:57,600 --> 00:19:01,280
parametrize

00:18:58,960 --> 00:19:02,559
it allows you to invoke a function

00:19:01,280 --> 00:19:05,679
multiple times

00:19:02,559 --> 00:19:05,679
with different inputs

00:19:06,080 --> 00:19:10,000
so here we are testing the calculation

00:19:08,799 --> 00:19:12,880
of the order total

00:19:10,000 --> 00:19:16,160
with one line with several lines and

00:19:12,880 --> 00:19:16,160
with a discount applied

00:19:16,880 --> 00:19:21,200
we write one function which expresses

00:19:19,200 --> 00:19:23,600
the general method of the test

00:19:21,200 --> 00:19:26,640
calculating the order total and then

00:19:23,600 --> 00:19:30,320
provide a number of behaviour scenarios

00:19:26,640 --> 00:19:31,200
in which it must work if the behavior

00:19:30,320 --> 00:19:34,240
changes

00:19:31,200 --> 00:19:36,240
the test result should change tests

00:19:34,240 --> 00:19:39,600
should not change their result if the

00:19:36,240 --> 00:19:42,080
implementation of the code changes

00:19:39,600 --> 00:19:43,280
if you do not witness a test failing you

00:19:42,080 --> 00:19:46,960
can never be certain

00:19:43,280 --> 00:19:49,039
its success is valid

00:19:46,960 --> 00:19:50,960
as a general practice the first thing

00:19:49,039 --> 00:19:52,000
you should do is write enough of a

00:19:50,960 --> 00:19:55,039
failing test

00:19:52,000 --> 00:19:58,000
to express a behavior that fails

00:19:55,039 --> 00:19:59,280
then write enough code to make that test

00:19:58,000 --> 00:20:02,720
pass

00:19:59,280 --> 00:20:05,679
and then repeat this is

00:20:02,720 --> 00:20:07,600
test driven development in a nutshell

00:20:05,679 --> 00:20:08,000
once you're happy with the scope of your

00:20:07,600 --> 00:20:10,960
test

00:20:08,000 --> 00:20:12,640
and code refactor as appropriate to

00:20:10,960 --> 00:20:14,720
clean up the code

00:20:12,640 --> 00:20:16,400
this process is sometimes known as red

00:20:14,720 --> 00:20:20,000
green refactor

00:20:16,400 --> 00:20:21,840
the tests start out red which is failing

00:20:20,000 --> 00:20:24,000
they are made to become green through

00:20:21,840 --> 00:20:26,159
the writing of sufficient code

00:20:24,000 --> 00:20:27,200
and then you refactor to make the code

00:20:26,159 --> 00:20:30,080
pretty or

00:20:27,200 --> 00:20:30,080
otherwise better

00:20:30,400 --> 00:20:34,400
one common stumbling block here for a

00:20:32,960 --> 00:20:37,600
lot of developers

00:20:34,400 --> 00:20:39,760
is the very first step of tdd writing a

00:20:37,600 --> 00:20:42,320
failing test

00:20:39,760 --> 00:20:43,520
often they stumble saying but i don't

00:20:42,320 --> 00:20:46,559
know what the code is

00:20:43,520 --> 00:20:48,720
that i'm writing the test for something

00:20:46,559 --> 00:20:50,320
that can help here is knowing that your

00:20:48,720 --> 00:20:53,440
test doesn't need

00:20:50,320 --> 00:20:55,039
or want to know about the details of the

00:20:53,440 --> 00:20:57,120
implementation

00:20:55,039 --> 00:20:58,080
indeed knowing too much about the

00:20:57,120 --> 00:21:00,960
implementation

00:20:58,080 --> 00:21:00,960
is to be avoided

00:21:01,360 --> 00:21:05,520
rather if you're unsure what the code is

00:21:04,159 --> 00:21:08,159
going to look like

00:21:05,520 --> 00:21:09,039
start with the absolute most basic

00:21:08,159 --> 00:21:10,720
assertion

00:21:09,039 --> 00:21:12,720
about the functionality that you're

00:21:10,720 --> 00:21:14,640
writing

00:21:12,720 --> 00:21:16,080
for example if you're writing a brand

00:21:14,640 --> 00:21:18,400
new system that

00:21:16,080 --> 00:21:19,919
must manage trains which travel around a

00:21:18,400 --> 00:21:22,000
network over time

00:21:19,919 --> 00:21:23,039
which might also have a bunch of other

00:21:22,000 --> 00:21:25,600
requirements

00:21:23,039 --> 00:21:27,600
like crewing the trains or moving cargo

00:21:25,600 --> 00:21:31,919
around and so on

00:21:27,600 --> 00:21:34,640
it is probably overwhelming start small

00:21:31,919 --> 00:21:35,600
start with a train and a single property

00:21:34,640 --> 00:21:37,440
of the train

00:21:35,600 --> 00:21:39,520
making up what you think will be a nice

00:21:37,440 --> 00:21:45,600
api as you go along

00:21:39,520 --> 00:21:48,159
if you don't already have one defined

00:21:45,600 --> 00:21:49,200
so in this example invented to put on

00:21:48,159 --> 00:21:51,760
this slide

00:21:49,200 --> 00:21:53,600
we write a test which creates a train

00:21:51,760 --> 00:21:55,440
moves it around the network

00:21:53,600 --> 00:21:56,880
and then we ask it to calculate its

00:21:55,440 --> 00:21:59,760
duration

00:21:56,880 --> 00:22:00,400
even if this isn't the final api for how

00:21:59,760 --> 00:22:03,600
trains

00:22:00,400 --> 00:22:05,039
work it's a good starting point it will

00:22:03,600 --> 00:22:07,360
fail

00:22:05,039 --> 00:22:09,280
and that's okay because now you can

00:22:07,360 --> 00:22:11,600
start writing some code

00:22:09,280 --> 00:22:13,120
and just enough code to make the test

00:22:11,600 --> 00:22:15,280
pass

00:22:13,120 --> 00:22:16,400
and now you've also got a test that will

00:22:15,280 --> 00:22:18,400
always ensure

00:22:16,400 --> 00:22:19,760
that you're calculating the duration of

00:22:18,400 --> 00:22:22,320
trains correctly

00:22:19,760 --> 00:22:24,000
regardless of the implementation of how

00:22:22,320 --> 00:22:27,280
that works

00:22:24,000 --> 00:22:30,720
tests shouldn't execute too much code or

00:22:27,280 --> 00:22:33,200
too many behaviors this helps keep them

00:22:30,720 --> 00:22:34,240
reasonably isolated but also prevents

00:22:33,200 --> 00:22:37,760
having large

00:22:34,240 --> 00:22:40,559
complicated and fragile tests

00:22:37,760 --> 00:22:41,840
ideally tests should exercise only one

00:22:40,559 --> 00:22:44,080
behavior

00:22:41,840 --> 00:22:45,919
but how that behavior is defined is

00:22:44,080 --> 00:22:49,440
entirely dependent on the specifics of

00:22:45,919 --> 00:22:52,480
the application in question

00:22:49,440 --> 00:22:53,120
tests can and should exercise several

00:22:52,480 --> 00:22:56,159
functions

00:22:53,120 --> 00:22:57,280
or classes working together if that is

00:22:56,159 --> 00:23:00,240
what is needed

00:22:57,280 --> 00:23:00,240
for the behavior

00:23:02,159 --> 00:23:05,600
focus does not mean that you should

00:23:04,240 --> 00:23:08,880
restrict your test

00:23:05,600 --> 00:23:09,440
or isolate it to a specific quantum of

00:23:08,880 --> 00:23:12,720
code

00:23:09,440 --> 00:23:15,760
like a function or a class or even

00:23:12,720 --> 00:23:18,720
a single module that level of isolation

00:23:15,760 --> 00:23:19,919
is not feasible and attempting to do so

00:23:18,720 --> 00:23:22,960
will almost certainly

00:23:19,919 --> 00:23:27,360
result in complicated code or

00:23:22,960 --> 00:23:30,000
tests that contain far too much mocking

00:23:27,360 --> 00:23:32,640
if you do find that your test even when

00:23:30,000 --> 00:23:34,480
focused on a specific behavior

00:23:32,640 --> 00:23:35,679
requires significant setup of

00:23:34,480 --> 00:23:38,240
dependencies

00:23:35,679 --> 00:23:39,440
then perhaps the code being tested is

00:23:38,240 --> 00:23:43,039
doing too much

00:23:39,440 --> 00:23:44,960
and itself is not well focused

00:23:43,039 --> 00:23:46,559
it could be that you're testing too much

00:23:44,960 --> 00:23:50,480
of the implementation

00:23:46,559 --> 00:23:53,200
rather than the behavior where possible

00:23:50,480 --> 00:23:54,159
tests should exercise one behavior that

00:23:53,200 --> 00:23:56,799
is simple

00:23:54,159 --> 00:23:57,840
or if not simple then of low complexity

00:23:56,799 --> 00:24:00,880
but hopefully

00:23:57,840 --> 00:24:00,880
never complicated

00:24:00,960 --> 00:24:04,240
tests should not have assertions about

00:24:03,679 --> 00:24:07,679
different

00:24:04,240 --> 00:24:10,640
behavioral expectations if a test

00:24:07,679 --> 00:24:12,720
fails it should fail for one reason and

00:24:10,640 --> 00:24:16,159
not prevent a separate test assertion

00:24:12,720 --> 00:24:19,279
from being made again pi test

00:24:16,159 --> 00:24:21,200
parametrize can help greatly here

00:24:19,279 --> 00:24:22,480
tests should never have conditional

00:24:21,200 --> 00:24:25,360
branches

00:24:22,480 --> 00:24:28,159
make a new test or use parameterize to

00:24:25,360 --> 00:24:30,320
express multiple scenarios

00:24:28,159 --> 00:24:31,600
i haven't talked about mocking yet and

00:24:30,320 --> 00:24:34,320
some folks equate

00:24:31,600 --> 00:24:35,520
isolation with a need for mocking so

00:24:34,320 --> 00:24:38,640
let's talk about that

00:24:35,520 --> 00:24:40,880
and dependencies in tests

00:24:38,640 --> 00:24:42,080
when i talk about dependencies i'm

00:24:40,880 --> 00:24:44,480
referring to both

00:24:42,080 --> 00:24:45,440
third-party code you're pulling in as a

00:24:44,480 --> 00:24:47,919
package

00:24:45,440 --> 00:24:49,440
but also the internal components of your

00:24:47,919 --> 00:24:51,600
application

00:24:49,440 --> 00:24:53,279
for example the data models that your

00:24:51,600 --> 00:24:55,440
business logic depends on

00:24:53,279 --> 00:24:58,320
or the business logic that invoked by

00:24:55,440 --> 00:25:01,440
your user interface

00:24:58,320 --> 00:25:04,640
the term test double was coined by

00:25:01,440 --> 00:25:07,520
gerard meseros as a way of talking about

00:25:04,640 --> 00:25:08,480
mocking stubbing faking and all that

00:25:07,520 --> 00:25:11,440
without those

00:25:08,480 --> 00:25:11,440
confusing words

00:25:11,760 --> 00:25:15,039
to make remembering the idea of test

00:25:13,840 --> 00:25:18,720
double easier

00:25:15,039 --> 00:25:21,200
think stunt double it's a meta term

00:25:18,720 --> 00:25:22,720
that we can use to encapsulate a wide

00:25:21,200 --> 00:25:25,600
variety of methods

00:25:22,720 --> 00:25:27,440
to replace dependencies in test code so

00:25:25,600 --> 00:25:28,159
that you can invoke your application

00:25:27,440 --> 00:25:30,240
code

00:25:28,159 --> 00:25:33,440
to test it without invoking the

00:25:30,240 --> 00:25:33,440
dependencies as well

00:25:34,400 --> 00:25:40,000
there's many words that are used to

00:25:36,400 --> 00:25:43,279
refer to specific doubling techniques

00:25:40,000 --> 00:25:46,559
fake fixture dummy stub mock

00:25:43,279 --> 00:25:48,960
spy as with other terms in testing

00:25:46,559 --> 00:25:51,440
people have varying ideas about what

00:25:48,960 --> 00:25:51,440
they mean

00:25:54,320 --> 00:25:58,720
but broadly there are several qualities

00:25:56,960 --> 00:26:01,679
that are present or absent

00:25:58,720 --> 00:26:02,400
in doubles they can provide input to

00:26:01,679 --> 00:26:04,799
your code

00:26:02,400 --> 00:26:05,440
which is not used perhaps you're just

00:26:04,799 --> 00:26:08,960
filling in

00:26:05,440 --> 00:26:08,960
unused function arguments

00:26:09,440 --> 00:26:13,440
they can provide input to your code as a

00:26:12,000 --> 00:26:15,919
dependency would

00:26:13,440 --> 00:26:16,720
here your code needs specific data to

00:26:15,919 --> 00:26:18,640
operate

00:26:16,720 --> 00:26:19,840
and you're providing it something that's

00:26:18,640 --> 00:26:20,720
got enough of the shape of the

00:26:19,840 --> 00:26:23,840
dependency

00:26:20,720 --> 00:26:25,919
to work they can

00:26:23,840 --> 00:26:27,279
accept output from your code as the

00:26:25,919 --> 00:26:28,880
dependency would

00:26:27,279 --> 00:26:30,960
your code is going to invoke the

00:26:28,880 --> 00:26:33,440
dependency with some data

00:26:30,960 --> 00:26:34,720
and you need that to work sometimes you

00:26:33,440 --> 00:26:39,840
want it to record

00:26:34,720 --> 00:26:39,840
that invocation or spy on it

00:26:40,799 --> 00:26:45,760
they can statelessly translate output to

00:26:43,440 --> 00:26:47,840
input based on a rule set

00:26:45,760 --> 00:26:48,799
that is given your code invokes the

00:26:47,840 --> 00:26:51,039
dependency

00:26:48,799 --> 00:26:52,000
it expects the double to respond to it

00:26:51,039 --> 00:26:55,039
with some specific

00:26:52,000 --> 00:26:57,440
data your double now has logic coded

00:26:55,039 --> 00:26:57,440
into it

00:27:00,159 --> 00:27:04,480
your double can provide assertions

00:27:02,320 --> 00:27:06,880
regarding the output received

00:27:04,480 --> 00:27:08,080
now the double has validation rules

00:27:06,880 --> 00:27:10,400
coded into it

00:27:08,080 --> 00:27:11,120
and it's primed to check the data your

00:27:10,400 --> 00:27:13,120
application

00:27:11,120 --> 00:27:15,520
sends to it to check there's only

00:27:13,120 --> 00:27:18,159
expected behavior

00:27:15,520 --> 00:27:20,159
now rather than have the cool rules

00:27:18,159 --> 00:27:23,200
coded directly in the test

00:27:20,159 --> 00:27:26,799
a developer must also look to the double

00:27:23,200 --> 00:27:26,799
to know all of the rules

00:27:26,960 --> 00:27:30,640
finally a double may implement

00:27:29,679 --> 00:27:33,840
state-driven

00:27:30,640 --> 00:27:37,840
behaviors of the dependency here you're

00:27:33,840 --> 00:27:37,840
basically rewriting the dependency

00:27:40,080 --> 00:27:44,080
those last few qualities where the

00:27:42,000 --> 00:27:47,760
double is getting more complicated

00:27:44,080 --> 00:27:50,559
should be avoided wherever possible

00:27:47,760 --> 00:27:51,360
simple immutable doubles often called

00:27:50,559 --> 00:27:54,080
stubs or

00:27:51,360 --> 00:27:56,240
mocks depending on who you talk to allow

00:27:54,080 --> 00:27:57,200
you to replace a dependency of code

00:27:56,240 --> 00:27:59,600
being tested

00:27:57,200 --> 00:28:00,559
with a double whose interface looks and

00:27:59,600 --> 00:28:04,480
behaves

00:28:00,559 --> 00:28:04,480
like the surface of the dependency

00:28:05,679 --> 00:28:11,440
complex mutable doubles called mocks or

00:28:08,880 --> 00:28:14,080
fakes depending on who you talk to

00:28:11,440 --> 00:28:15,520
extend that idea by adding mutability

00:28:14,080 --> 00:28:17,679
having their own state

00:28:15,520 --> 00:28:18,880
that can change during the execution of

00:28:17,679 --> 00:28:21,279
the test

00:28:18,880 --> 00:28:22,960
this greatly complicates their design by

00:28:21,279 --> 00:28:24,080
encapsulating aspects of the

00:28:22,960 --> 00:28:27,360
implementation

00:28:24,080 --> 00:28:29,279
of your dependencies into the tests

00:28:27,360 --> 00:28:30,880
you would want to limit the use of these

00:28:29,279 --> 00:28:34,159
complicated doubles

00:28:30,880 --> 00:28:37,039
in your test suite by the way

00:28:34,159 --> 00:28:39,360
a database is a complicated mutable

00:28:37,039 --> 00:28:39,360
double

00:28:41,840 --> 00:28:45,279
if you'll find you're using these

00:28:43,679 --> 00:28:48,080
complicated doubles

00:28:45,279 --> 00:28:49,200
for even seemingly core tests of single

00:28:48,080 --> 00:28:52,000
behaviors

00:28:49,200 --> 00:28:52,399
you may be in trouble and need to step

00:28:52,000 --> 00:28:54,799
back

00:28:52,399 --> 00:28:56,399
and look at your architecture perhaps it

00:28:54,799 --> 00:28:59,840
is too tightly coupled

00:28:56,399 --> 00:28:59,840
too complicated

00:29:00,080 --> 00:29:04,559
i should note if you find you want a

00:29:02,399 --> 00:29:06,799
higher level test of your application

00:29:04,559 --> 00:29:08,480
that covers a number of behaviors in a

00:29:06,799 --> 00:29:11,760
large portion of the code

00:29:08,480 --> 00:29:14,080
then using complex mutable doubles

00:29:11,760 --> 00:29:16,960
is most likely going to be the only way

00:29:14,080 --> 00:29:19,840
to achieve that goal

00:29:16,960 --> 00:29:21,120
a great library for providing simple

00:29:19,840 --> 00:29:24,159
immutable doubles

00:29:21,120 --> 00:29:24,159
is called pretend

00:29:24,320 --> 00:29:28,080
i will be making use of it in some of my

00:29:26,559 --> 00:29:31,039
examples to come

00:29:28,080 --> 00:29:31,039
it works like this

00:29:33,919 --> 00:29:37,440
here x will be an object with a single

00:29:36,720 --> 00:29:41,279
attribute

00:29:37,440 --> 00:29:44,480
country code which has the value us

00:29:41,279 --> 00:29:46,799
unlike the python standard library mocks

00:29:44,480 --> 00:29:47,520
x will not respond to any other

00:29:46,799 --> 00:29:50,720
attribute

00:29:47,520 --> 00:29:52,840
or method nor does it have any methods

00:29:50,720 --> 00:29:54,240
for making assertions about what you

00:29:52,840 --> 00:29:56,480
accessed

00:29:54,240 --> 00:29:59,679
if you want to add a method to the stub

00:29:56,480 --> 00:29:59,679
provide a function to it

00:30:01,679 --> 00:30:06,799
this allows us to provide simple

00:30:04,240 --> 00:30:08,720
functions that do or don't take args

00:30:06,799 --> 00:30:11,039
and provide input back to our

00:30:08,720 --> 00:30:13,039
application code

00:30:11,039 --> 00:30:14,320
magic mocks like those found in the

00:30:13,039 --> 00:30:18,000
standard library

00:30:14,320 --> 00:30:20,320
are never a good idea magic mocks will

00:30:18,000 --> 00:30:21,600
automatically mutate themselves in

00:30:20,320 --> 00:30:24,559
response to the code

00:30:21,600 --> 00:30:27,520
under test adding attributes or even

00:30:24,559 --> 00:30:27,520
callable methods

00:30:28,000 --> 00:30:34,080
these objects frequently result in tests

00:30:31,200 --> 00:30:37,840
falsely passing in the face of typos or

00:30:34,080 --> 00:30:37,840
other coding errors

00:30:38,080 --> 00:30:41,360
doubles should always be explicitly

00:30:40,720 --> 00:30:43,520
coded

00:30:41,360 --> 00:30:45,840
to the shape of the dependency being

00:30:43,520 --> 00:30:48,240
replaced

00:30:45,840 --> 00:30:48,960
and when you must use doubles keep them

00:30:48,240 --> 00:30:51,840
as simple

00:30:48,960 --> 00:30:52,880
as possible don't re-implement your

00:30:51,840 --> 00:30:55,760
dependency

00:30:52,880 --> 00:30:55,760
just to double it

00:30:56,000 --> 00:31:00,159
monkey patching is a technique commonly

00:30:58,399 --> 00:31:01,200
used in tests to replace the

00:31:00,159 --> 00:31:04,159
implementation

00:31:01,200 --> 00:31:07,360
inside a dependency with some double so

00:31:04,159 --> 00:31:10,240
that your test can be isolated

00:31:07,360 --> 00:31:13,279
this is a simple example of a of monkey

00:31:10,240 --> 00:31:13,279
patching in action

00:31:14,399 --> 00:31:20,480
the simple book face implementation has

00:31:16,720 --> 00:31:22,799
a tight coupling to the bookface library

00:31:20,480 --> 00:31:24,960
this makes it more complicated it is now

00:31:22,799 --> 00:31:26,880
composed of complicated things

00:31:24,960 --> 00:31:28,320
but it also becomes more difficult to

00:31:26,880 --> 00:31:32,000
replace that dependency

00:31:28,320 --> 00:31:34,559
in tests we have to monkey patch

00:31:32,000 --> 00:31:37,200
the external module to replace its

00:31:34,559 --> 00:31:39,279
implementation of the dependency

00:31:37,200 --> 00:31:41,039
this is dangerous it might have

00:31:39,279 --> 00:31:44,840
unexpected side effects

00:31:41,039 --> 00:31:46,000
and it's fragile to changes in that

00:31:44,840 --> 00:31:48,240
module

00:31:46,000 --> 00:31:49,360
we can use a technique called inverting

00:31:48,240 --> 00:31:52,480
the dependency

00:31:49,360 --> 00:31:55,039
to change the code to look like this

00:31:52,480 --> 00:31:56,159
simplebookface now accepts a service

00:31:55,039 --> 00:31:58,399
called graph

00:31:56,159 --> 00:32:00,240
which provides the functionality the

00:31:58,399 --> 00:32:02,960
application logic needs

00:32:00,240 --> 00:32:05,679
but decouples us from the tight coupling

00:32:02,960 --> 00:32:07,519
to the third party module

00:32:05,679 --> 00:32:11,200
note that there's no import of the

00:32:07,519 --> 00:32:11,200
bookface library any longer

00:32:12,559 --> 00:32:17,039
the implementation of simplebookface is

00:32:15,120 --> 00:32:19,519
much simpler

00:32:17,039 --> 00:32:20,720
your high level application code or

00:32:19,519 --> 00:32:22,720
bootstrap code

00:32:20,720 --> 00:32:24,960
would be responsible for creating an

00:32:22,720 --> 00:32:29,840
implementation of a graph service

00:32:24,960 --> 00:32:29,840
that could be provided to simplebookface

00:32:30,000 --> 00:32:34,559
in the test we no longer perform that

00:32:32,399 --> 00:32:37,679
fragile and complicated mocking

00:32:34,559 --> 00:32:40,559
to replace the dependency we can create

00:32:37,679 --> 00:32:40,559
a simple stub

00:32:40,840 --> 00:32:44,480
instead

00:32:42,000 --> 00:32:46,640
so this is a simple example and while

00:32:44,480 --> 00:32:48,320
the motivation behind making this change

00:32:46,640 --> 00:32:50,559
probably makes sense to you

00:32:48,320 --> 00:32:52,320
you're most likely going to be wondering

00:32:50,559 --> 00:32:55,039
how to apply that approach

00:32:52,320 --> 00:32:57,600
to your own larger more complicated

00:32:55,039 --> 00:32:59,679
application

00:32:57,600 --> 00:33:02,159
i'm going to now take some time to

00:32:59,679 --> 00:33:06,159
introduce a great architectural trick

00:33:02,159 --> 00:33:08,600
which is to think like the onion does

00:33:06,159 --> 00:33:09,840
or more specifically the onion

00:33:08,600 --> 00:33:12,399
architecture

00:33:09,840 --> 00:33:14,000
by geoffrey palermo and tweaked and

00:33:12,399 --> 00:33:17,200
improved by many others

00:33:14,000 --> 00:33:20,399
since then this is a simplified version

00:33:17,200 --> 00:33:20,399
of the architecture

00:33:20,960 --> 00:33:24,559
at your applications core you define the

00:33:23,600 --> 00:33:28,159
data domain

00:33:24,559 --> 00:33:31,360
in the most primitive form you can think

00:33:28,159 --> 00:33:32,960
basic python data types and classes that

00:33:31,360 --> 00:33:35,279
have no knowledge of data

00:33:32,960 --> 00:33:36,480
outside of themselves except for

00:33:35,279 --> 00:33:40,640
referring to others

00:33:36,480 --> 00:33:42,159
by id you surround that data domain with

00:33:40,640 --> 00:33:45,120
your application logic

00:33:42,159 --> 00:33:46,080
which uses the domain and services

00:33:45,120 --> 00:33:49,760
provided by

00:33:46,080 --> 00:33:50,960
external apis this is sometimes known as

00:33:49,760 --> 00:33:54,399
the policy layer

00:33:50,960 --> 00:33:55,679
but i find that term confusing the user

00:33:54,399 --> 00:33:58,559
interface and api

00:33:55,679 --> 00:33:59,440
code exist side by side in the outer

00:33:58,559 --> 00:34:02,960
layer

00:33:59,440 --> 00:34:02,960
neither depending on the other

00:34:04,000 --> 00:34:07,200
this could also be thought of as the i o

00:34:06,720 --> 00:34:09,280
layer

00:34:07,200 --> 00:34:10,879
where your application interfaces with

00:34:09,280 --> 00:34:14,399
things with other things

00:34:10,879 --> 00:34:16,159
people or systems it is sometimes known

00:34:14,399 --> 00:34:18,399
as the infrastructure layer

00:34:16,159 --> 00:34:20,240
which refers to the facilities and

00:34:18,399 --> 00:34:22,639
services that the application

00:34:20,240 --> 00:34:22,639
needs

00:34:23,839 --> 00:34:26,960
this architectural approach has many

00:34:26,079 --> 00:34:28,639
benefits

00:34:26,960 --> 00:34:30,320
one of which is that it allows the

00:34:28,639 --> 00:34:34,079
application to scale

00:34:30,320 --> 00:34:37,040
very cleanly when new features are added

00:34:34,079 --> 00:34:39,200
it's super nice for agile development

00:34:37,040 --> 00:34:41,839
where whole features can be added

00:34:39,200 --> 00:34:43,839
altered and removed as the application

00:34:41,839 --> 00:34:45,919
matures

00:34:43,839 --> 00:34:48,000
but there's also concrete benefits for

00:34:45,919 --> 00:34:51,919
testing which is why i'm talking about

00:34:48,000 --> 00:34:54,320
it so how do we make the onion work

00:34:51,919 --> 00:34:54,320
really

00:34:56,879 --> 00:35:00,880
now there's a bunch of code on this

00:34:58,400 --> 00:35:01,839
slide and i'll let your eyes wander over

00:35:00,880 --> 00:35:05,119
it a bit for a bit

00:35:01,839 --> 00:35:05,119
before i walk through it

00:35:13,280 --> 00:35:17,760
there are four different sections of

00:35:15,200 --> 00:35:21,680
code here representing components

00:35:17,760 --> 00:35:21,680
of each of the parts of the onion

00:35:23,520 --> 00:35:29,359
the domain which defines our data as

00:35:26,160 --> 00:35:31,680
very simple classes

00:35:29,359 --> 00:35:33,119
the application which implements our

00:35:31,680 --> 00:35:35,520
applications logic

00:35:33,119 --> 00:35:39,680
like calculating the total price of an

00:35:35,520 --> 00:35:39,680
order from its component order lines

00:35:43,520 --> 00:35:47,680
the ui which displays an order by id and

00:35:47,200 --> 00:35:51,119
date

00:35:47,680 --> 00:35:53,119
with its calculated total price note the

00:35:51,119 --> 00:35:54,400
dependency container that we use to

00:35:53,119 --> 00:35:59,760
obtain our orders

00:35:54,400 --> 00:36:02,720
store i'll be coming back to that

00:35:59,760 --> 00:36:05,040
and apis which interface to our

00:36:02,720 --> 00:36:07,680
complicated external dependencies

00:36:05,040 --> 00:36:12,240
in this case requests to provide the

00:36:07,680 --> 00:36:14,480
functionality that the application needs

00:36:12,240 --> 00:36:15,760
one of the most important aspects of the

00:36:14,480 --> 00:36:18,079
onion approach

00:36:15,760 --> 00:36:20,400
is that the code in the outer layers

00:36:18,079 --> 00:36:26,960
depend on the code in the inner layers

00:36:20,400 --> 00:36:29,359
and not the other way around

00:36:26,960 --> 00:36:31,200
but richard i hear you say that

00:36:29,359 --> 00:36:34,079
application logic is using

00:36:31,200 --> 00:36:36,240
the api from the outer layer well it

00:36:34,079 --> 00:36:38,640
might look like that at a glance

00:36:36,240 --> 00:36:39,280
but there is no import from that outer

00:36:38,640 --> 00:36:42,240
layer

00:36:39,280 --> 00:36:44,160
into the application logic the

00:36:42,240 --> 00:36:46,240
application logic could use

00:36:44,160 --> 00:36:48,480
any orders store as long as it's

00:36:46,240 --> 00:36:51,119
compatible

00:36:48,480 --> 00:36:52,000
the application logic has the dependency

00:36:51,119 --> 00:36:55,119
it needs

00:36:52,000 --> 00:36:58,320
provided to it or injected into it

00:36:55,119 --> 00:37:00,480
from outside similarly

00:36:58,320 --> 00:37:03,520
the user interface doesn't have a hard

00:37:00,480 --> 00:37:05,920
coupling to our requests api code either

00:37:03,520 --> 00:37:07,839
instead we decouple it using a

00:37:05,920 --> 00:37:10,320
dependency container

00:37:07,839 --> 00:37:11,839
in this code the dependency container is

00:37:10,320 --> 00:37:13,839
just a dictionary

00:37:11,839 --> 00:37:16,880
in practice it might have additional

00:37:13,839 --> 00:37:19,119
safety rails which i'll come to

00:37:16,880 --> 00:37:20,240
in practice it might have additional

00:37:19,119 --> 00:37:23,280
safety rails

00:37:20,240 --> 00:37:25,280
which i'll come to we can register

00:37:23,280 --> 00:37:26,800
any implementation of orders store we

00:37:25,280 --> 00:37:29,440
like with that container

00:37:26,800 --> 00:37:31,599
including in tests which i'll also come

00:37:29,440 --> 00:37:31,599
to

00:37:32,160 --> 00:37:36,000
rather than have hard coupling between

00:37:35,119 --> 00:37:38,480
our code and

00:37:36,000 --> 00:37:39,520
its dependencies we have it asked for

00:37:38,480 --> 00:37:43,119
the dependencies

00:37:39,520 --> 00:37:45,040
it needs this allows us to both

00:37:43,119 --> 00:37:47,839
decouple our code from specific

00:37:45,040 --> 00:37:50,640
dependencies allowing flexibility in our

00:37:47,839 --> 00:37:53,680
implementation and deployments

00:37:50,640 --> 00:37:54,560
and provides doubles very easily in our

00:37:53,680 --> 00:37:56,160
tests

00:37:54,560 --> 00:37:58,720
where we can plug them into the

00:37:56,160 --> 00:38:00,720
dependency resolution system

00:37:58,720 --> 00:38:02,960
in this case it's just a function

00:38:00,720 --> 00:38:05,839
argument

00:38:02,960 --> 00:38:06,880
in typed languages we might formally

00:38:05,839 --> 00:38:09,359
declare that

00:38:06,880 --> 00:38:11,920
orders store implements some specific

00:38:09,359 --> 00:38:11,920
interface

00:38:12,560 --> 00:38:16,240
python has typing now too so we can do

00:38:15,040 --> 00:38:18,800
this

00:38:16,240 --> 00:38:19,599
the application logic can code a

00:38:18,800 --> 00:38:22,320
protocol

00:38:19,599 --> 00:38:22,800
which declares what its requirements are

00:38:22,320 --> 00:38:26,640
for an

00:38:22,800 --> 00:38:30,400
order store we declare that protocol

00:38:26,640 --> 00:38:33,440
to include two methods one called by id

00:38:30,400 --> 00:38:35,359
and the other one called get lines the

00:38:33,440 --> 00:38:36,800
ellipses are used to indicate that

00:38:35,359 --> 00:38:39,599
there's no functionality

00:38:36,800 --> 00:38:39,599
in the protocol

00:38:40,560 --> 00:38:44,400
any orders store now provided to the

00:38:43,280 --> 00:38:47,119
application code

00:38:44,400 --> 00:38:50,720
will be checked by a type checker to

00:38:47,119 --> 00:38:53,280
ensure we're providing the correct thing

00:38:50,720 --> 00:38:53,760
pyrite is a great python type checking

00:38:53,280 --> 00:38:56,079
tool

00:38:53,760 --> 00:38:56,880
that you can run on the command line and

00:38:56,079 --> 00:39:01,839
also has

00:38:56,880 --> 00:39:01,839
fantastic support in visual studio code

00:39:05,520 --> 00:39:09,119
we can also use a typed dependency

00:39:08,079 --> 00:39:13,680
resolver too

00:39:09,119 --> 00:39:16,480
like t-res or tray from pi pi

00:39:13,680 --> 00:39:17,599
to ensure that our implementation of

00:39:16,480 --> 00:39:21,040
order stores

00:39:17,599 --> 00:39:22,960
are valid too trey validates our

00:39:21,040 --> 00:39:25,200
registration of dependencies

00:39:22,960 --> 00:39:26,960
and provides us with their type when we

00:39:25,200 --> 00:39:29,359
resolve them

00:39:26,960 --> 00:39:31,440
going back to the example though without

00:39:29,359 --> 00:39:34,240
all that typing malarkey which is

00:39:31,440 --> 00:39:36,079
super useful but also super optional we

00:39:34,240 --> 00:39:38,640
can see how the data model

00:39:36,079 --> 00:39:39,760
and application logic are now testable

00:39:38,640 --> 00:39:43,119
without needing

00:39:39,760 --> 00:39:45,359
complicated dependencies we've decoupled

00:39:43,119 --> 00:39:48,640
them

00:39:45,359 --> 00:39:51,599
creating some orders and order lines

00:39:48,640 --> 00:39:52,240
to test the application is easy we need

00:39:51,599 --> 00:39:56,800
a minimum

00:39:52,240 --> 00:39:59,280
of doubles to test now

00:39:56,800 --> 00:40:00,560
something i want to reinforce is that

00:39:59,280 --> 00:40:03,680
the inner layers

00:40:00,560 --> 00:40:06,480
be as simple as possible

00:40:03,680 --> 00:40:07,359
you might be tempted to interface your

00:40:06,480 --> 00:40:10,319
database

00:40:07,359 --> 00:40:11,200
right there next to your data classes

00:40:10,319 --> 00:40:15,599
orms

00:40:11,200 --> 00:40:18,560
make this super easy but they're a trap

00:40:15,599 --> 00:40:20,319
the database is a horribly complicated

00:40:18,560 --> 00:40:23,280
external dependency

00:40:20,319 --> 00:40:24,079
it belongs out here and should provide

00:40:23,280 --> 00:40:26,560
services

00:40:24,079 --> 00:40:27,440
which can drive your application like

00:40:26,560 --> 00:40:30,400
our orders

00:40:27,440 --> 00:40:31,200
store did if you need to run a whole

00:40:30,400 --> 00:40:33,599
database

00:40:31,200 --> 00:40:35,040
or even a pretend one to be able to run

00:40:33,599 --> 00:40:37,599
your unit tests

00:40:35,040 --> 00:40:38,400
then it could be that your architecture

00:40:37,599 --> 00:40:41,119
is too

00:40:38,400 --> 00:40:41,119
complicated

00:40:44,240 --> 00:40:50,720
on the subject of dependency injection

00:40:47,599 --> 00:40:53,520
in python the pi test testing framework

00:40:50,720 --> 00:40:53,920
uses dependency injection for its own

00:40:53,520 --> 00:40:55,920
test

00:40:53,920 --> 00:40:58,400
fixture management which greatly

00:40:55,920 --> 00:41:00,319
simplifies writing tests

00:40:58,400 --> 00:41:02,079
but we also have libraries like

00:41:00,319 --> 00:41:07,839
dependency injector

00:41:02,079 --> 00:41:07,839
and t-res and others

00:41:07,920 --> 00:41:11,200
this has been a whirlwind introduction

00:41:10,640 --> 00:41:13,599
to

00:41:11,200 --> 00:41:14,319
the onion architecture dependency

00:41:13,599 --> 00:41:17,760
injection

00:41:14,319 --> 00:41:20,319
and inversion of control and i recommend

00:41:17,760 --> 00:41:21,680
searching up some articles to learn more

00:41:20,319 --> 00:41:24,240
it's a lot to take in

00:41:21,680 --> 00:41:25,280
but my intent today is to introduce the

00:41:24,240 --> 00:41:27,839
ideas

00:41:25,280 --> 00:41:29,680
as potential ways to work through

00:41:27,839 --> 00:41:31,920
architectural complexities

00:41:29,680 --> 00:41:34,880
that can make testing harder than it

00:41:31,920 --> 00:41:38,000
need to be

00:41:34,880 --> 00:41:39,599
okay moving on tests should run as

00:41:38,000 --> 00:41:42,319
quickly as possible

00:41:39,599 --> 00:41:43,040
this enquire encourages frequent if not

00:41:42,319 --> 00:41:46,880
constant

00:41:43,040 --> 00:41:49,680
execution of your test suite

00:41:46,880 --> 00:41:51,200
if your ui tests are speedy then sure

00:41:49,680 --> 00:41:54,079
use them constantly

00:41:51,200 --> 00:41:56,640
but if they're not do them but make them

00:41:54,079 --> 00:41:56,640
optional

00:41:58,640 --> 00:42:02,240
good test running tools will give you

00:42:00,720 --> 00:42:05,680
the ability to re-run

00:42:02,240 --> 00:42:07,839
tests constantly while you work

00:42:05,680 --> 00:42:08,800
this is great because you very quickly

00:42:07,839 --> 00:42:11,920
get feedback

00:42:08,800 --> 00:42:11,920
when you break something

00:42:12,720 --> 00:42:16,720
if you only run the tests once you're

00:42:14,640 --> 00:42:17,200
done then you may have to go back

00:42:16,720 --> 00:42:20,160
through

00:42:17,200 --> 00:42:22,560
hours of work figure out where you broke

00:42:20,160 --> 00:42:22,560
things

00:42:24,400 --> 00:42:28,960
you can use a tool like pi test watch to

00:42:27,359 --> 00:42:32,480
continually run your pi

00:42:28,960 --> 00:42:35,280
test suite while you work

00:42:32,480 --> 00:42:35,760
here pi test watch has noticed that the

00:42:35,280 --> 00:42:38,720
code

00:42:35,760 --> 00:42:39,920
changed and it's re-run the tests but i

00:42:38,720 --> 00:42:42,160
broke it

00:42:39,920 --> 00:42:44,960
but i was told about it immediately

00:42:42,160 --> 00:42:47,280
which is super good

00:42:44,960 --> 00:42:50,000
it's also a good idea to run pi test

00:42:47,280 --> 00:42:52,720
over multiple cpu cores

00:42:50,000 --> 00:42:53,440
to get both an added speed boost but

00:42:52,720 --> 00:42:56,000
also

00:42:53,440 --> 00:42:59,680
sneakily check that your test isolations

00:42:56,000 --> 00:43:01,680
where isolation is working

00:42:59,680 --> 00:43:03,280
if a test fails because it's running on

00:43:01,680 --> 00:43:05,280
a separate core

00:43:03,280 --> 00:43:08,240
then something is definitely leaking

00:43:05,280 --> 00:43:10,720
state in your test suite

00:43:08,240 --> 00:43:14,640
if confidence is only achievable with

00:43:10,720 --> 00:43:14,640
slow tests still do them

00:43:15,440 --> 00:43:19,520
a fantastic example of that is using a

00:43:18,240 --> 00:43:22,960
browser-based test

00:43:19,520 --> 00:43:25,440
to exercise your website application

00:43:22,960 --> 00:43:26,160
now i can already hear the groans of the

00:43:25,440 --> 00:43:28,560
audience

00:43:26,160 --> 00:43:30,640
who have probably attempted to automate

00:43:28,560 --> 00:43:33,280
selenium in the past

00:43:30,640 --> 00:43:34,720
fear not dear audience the world has

00:43:33,280 --> 00:43:36,800
improved

00:43:34,720 --> 00:43:38,319
much cleaner and more reliable

00:43:36,800 --> 00:43:41,359
frameworks have been built

00:43:38,319 --> 00:43:42,319
on top of selenium which to be fair was

00:43:41,359 --> 00:43:46,640
only ever

00:43:42,319 --> 00:43:49,440
designed as a browser automation tool

00:43:46,640 --> 00:43:50,079
frameworks such as cypress and selenium

00:43:49,440 --> 00:43:52,960
base

00:43:50,079 --> 00:43:55,599
now make writing tests much simpler and

00:43:52,960 --> 00:43:58,240
more reliable

00:43:55,599 --> 00:43:59,839
this is an example selenium-based test

00:43:58,240 --> 00:44:00,720
which attempts to login to our

00:43:59,839 --> 00:44:03,359
application

00:44:00,720 --> 00:44:04,480
using a test login verifying that we see

00:44:03,359 --> 00:44:08,880
the user login

00:44:04,480 --> 00:44:11,200
correctly just think about the volume of

00:44:08,880 --> 00:44:13,680
lower level tests that you'd need to

00:44:11,200 --> 00:44:16,400
write in order to get the same coverage

00:44:13,680 --> 00:44:18,319
of functionality as this test the

00:44:16,400 --> 00:44:20,720
confidence that this test provides is

00:44:18,319 --> 00:44:20,720
huge

00:44:20,960 --> 00:44:25,760
tests should never require explanation

00:44:24,079 --> 00:44:28,079
they should certainly have a stated

00:44:25,760 --> 00:44:29,119
purpose which is usually encapsulated in

00:44:28,079 --> 00:44:31,040
their name

00:44:29,119 --> 00:44:32,240
but tests should be readable and

00:44:31,040 --> 00:44:34,480
understandable

00:44:32,240 --> 00:44:36,000
for the reader invoking the motivation

00:44:34,480 --> 00:44:39,680
for writing this particular

00:44:36,000 --> 00:44:43,040
test test failures should be obvious

00:44:39,680 --> 00:44:46,240
and informative tests should be

00:44:43,040 --> 00:44:46,720
easy or easier to write relative to the

00:44:46,240 --> 00:44:50,640
code

00:44:46,720 --> 00:44:52,800
being tested

00:44:50,640 --> 00:44:54,560
things that might hinder understanding

00:44:52,800 --> 00:44:58,960
of a test

00:44:54,560 --> 00:45:02,839
mutable or otherwise complicated mocks

00:44:58,960 --> 00:45:04,800
conditional branches tests that are not

00:45:02,839 --> 00:45:06,960
focused

00:45:04,800 --> 00:45:09,280
having said that if the test just

00:45:06,960 --> 00:45:10,560
reiterates the code being tested

00:45:09,280 --> 00:45:12,640
then there's a good chance you're

00:45:10,560 --> 00:45:14,640
testing the implementation

00:45:12,640 --> 00:45:15,839
perhaps consider whether you could

00:45:14,640 --> 00:45:19,119
broaden the test

00:45:15,839 --> 00:45:20,960
to cover more code

00:45:19,119 --> 00:45:22,560
and i'll repeat myself there should

00:45:20,960 --> 00:45:25,520
never be conditional branching

00:45:22,560 --> 00:45:27,520
in a test if the reader has to reason

00:45:25,520 --> 00:45:30,880
about the behavior in a test

00:45:27,520 --> 00:45:34,640
then it's just too complicated

00:45:30,880 --> 00:45:36,640
finally if all of your tests pass

00:45:34,640 --> 00:45:38,160
then the code under test should be

00:45:36,640 --> 00:45:41,119
suitable for production

00:45:38,160 --> 00:45:42,160
if the tests pass then any new work or

00:45:41,119 --> 00:45:44,400
refactoring

00:45:42,160 --> 00:45:46,720
should be considered safe this

00:45:44,400 --> 00:45:49,760
encompasses both the number of tests

00:45:46,720 --> 00:45:52,400
that is the coverage and the quality of

00:45:49,760 --> 00:45:52,400
the tests

00:45:53,200 --> 00:45:56,400
i'm not going to put a specific number

00:45:55,440 --> 00:45:59,119
on what i think

00:45:56,400 --> 00:46:01,119
good test coverage is and say that you

00:45:59,119 --> 00:46:03,280
should attain that level also

00:46:01,119 --> 00:46:05,359
because confidence from test coverage

00:46:03,280 --> 00:46:07,040
will vary considerably from project to

00:46:05,359 --> 00:46:09,200
project

00:46:07,040 --> 00:46:10,160
a project i'm currently employed to work

00:46:09,200 --> 00:46:13,200
on has

00:46:10,160 --> 00:46:15,200
around 60 coverage and that's pretty

00:46:13,200 --> 00:46:17,359
good

00:46:15,200 --> 00:46:18,800
a side project that i have open sourced

00:46:17,359 --> 00:46:21,280
has 100

00:46:18,800 --> 00:46:22,640
coverage so i have confidence that i'm

00:46:21,280 --> 00:46:24,720
not going to break it

00:46:22,640 --> 00:46:28,160
when picking it up to apply some

00:46:24,720 --> 00:46:30,560
community pull request

00:46:28,160 --> 00:46:32,640
as for quality well hopefully that's

00:46:30,560 --> 00:46:34,960
covered by the other aspects of testing

00:46:32,640 --> 00:46:37,200
that i've talked about today

00:46:34,960 --> 00:46:38,079
the practice of test driven development

00:46:37,200 --> 00:46:42,160
contribute

00:46:38,079 --> 00:46:44,079
contributes greatly to this confidence

00:46:42,160 --> 00:46:46,880
a number of other testing methods can

00:46:44,079 --> 00:46:49,359
also contribute greatly to confidence

00:46:46,880 --> 00:46:50,560
smoke tests in particular can ensure

00:46:49,359 --> 00:46:53,440
that your application

00:46:50,560 --> 00:46:54,079
passes a limited set of very high level

00:46:53,440 --> 00:46:56,319
tests

00:46:54,079 --> 00:46:57,359
that ensure that critical functionality

00:46:56,319 --> 00:47:01,119
is present

00:46:57,359 --> 00:47:03,599
when deployed for example once deployed

00:47:01,119 --> 00:47:05,280
your smoke test can ensure that the

00:47:03,599 --> 00:47:08,000
front page of your website

00:47:05,280 --> 00:47:10,319
has expected content and perhaps that a

00:47:08,000 --> 00:47:14,319
user might log in

00:47:10,319 --> 00:47:16,880
keep such tests reasonably simple

00:47:14,319 --> 00:47:18,079
don't necessarily test a complicated

00:47:16,880 --> 00:47:21,440
interaction

00:47:18,079 --> 00:47:24,160
where perhaps a specific user can log in

00:47:21,440 --> 00:47:25,280
navigate to their orders page select an

00:47:24,160 --> 00:47:28,800
in-flight order

00:47:25,280 --> 00:47:29,520
and modify it that particular

00:47:28,800 --> 00:47:32,079
interaction

00:47:29,520 --> 00:47:32,880
might require significant investment to

00:47:32,079 --> 00:47:35,280
implement

00:47:32,880 --> 00:47:38,800
and be fragile to simple changes in the

00:47:35,280 --> 00:47:41,760
user interface design

00:47:38,800 --> 00:47:42,720
those more complicated interactions

00:47:41,760 --> 00:47:46,000
should be covered

00:47:42,720 --> 00:47:47,520
by other tests run continuously during

00:47:46,000 --> 00:47:50,079
development

00:47:47,520 --> 00:47:51,760
the smoke test exists to ensure that the

00:47:50,079 --> 00:47:54,400
deployment of your application is

00:47:51,760 --> 00:47:57,440
working correctly

00:47:54,400 --> 00:47:58,000
my final word is to not take any of this

00:47:57,440 --> 00:48:01,599
advice

00:47:58,000 --> 00:48:03,440
as inflexible rules getting fixated on

00:48:01,599 --> 00:48:06,640
hard rules about testing

00:48:03,440 --> 00:48:07,440
has only caused us confusion consider

00:48:06,640 --> 00:48:10,160
these thoughts

00:48:07,440 --> 00:48:10,960
that i've presented reflect on how they

00:48:10,160 --> 00:48:14,960
might apply

00:48:10,960 --> 00:48:16,000
to your efforts i do hope some of this

00:48:14,960 --> 00:48:18,839
advice today

00:48:16,000 --> 00:48:21,839
will help you achieve confidence in your

00:48:18,839 --> 00:48:21,839

YouTube URL: https://www.youtube.com/watch?v=rY45dmzrCu4


