Title: "Introducing Lambda Calculus with Python" - Indranil Ghosh (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Indranil Ghosh

https://2020.pycon.org.au/program/AL8WB3

We will be focusing on untyped lambda calculus and start by the simple definition of a function, that can be implemented with Python lambda. We will then discuss the concepts of **abstraction** and **application** in lambda calculus and then move on to understand what a **substitution** is and how can these be implemented in Python. We will finally study some combinators which are the basic building blocks of combinatory logic, before ending with encoding datatypes in lambda calculus and implementing the same with Python lambda. Datatypes we will be discussing are:

1. Boolean values like TRUE and FALSE
2. Logical operators like AND, OR and NOT
3. Church Numerals
4. Predicates
5. Recursions

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 14:40:00 2020 at Python 2
Captions: 
	00:00:00,080 --> 00:00:03,600
give you an introduction so next up we

00:00:01,920 --> 00:00:05,680
have intranell gauche to present

00:00:03,600 --> 00:00:07,520
introducing lambda calculus and python

00:00:05,680 --> 00:00:09,200
he's a final year masters student in the

00:00:07,520 --> 00:00:12,480
department of physics from

00:00:09,200 --> 00:00:13,759
per university in kolkata india

00:00:12,480 --> 00:00:14,960
please make him welcome for this talk

00:00:13,759 --> 00:00:17,840
and thank you for waiting through the

00:00:14,960 --> 00:00:19,840
technical issues

00:00:17,840 --> 00:00:22,480
hello everyone so today i'm going to

00:00:19,840 --> 00:00:26,080
introduce a lambda calculus with python

00:00:22,480 --> 00:00:28,080
so this talk actually introduces some

00:00:26,080 --> 00:00:29,439
basic concepts of lambda calculus along

00:00:28,080 --> 00:00:30,640
with some hands-on practice and

00:00:29,439 --> 00:00:32,719
implementation

00:00:30,640 --> 00:00:34,079
of the application of using lambda

00:00:32,719 --> 00:00:36,399
function with python

00:00:34,079 --> 00:00:37,200
so this would be basically helpful for

00:00:36,399 --> 00:00:39,280
students

00:00:37,200 --> 00:00:40,879
who have a background in either

00:00:39,280 --> 00:00:43,440
mathematics or computer science or

00:00:40,879 --> 00:00:43,440
physics so

00:00:43,760 --> 00:00:48,160
yeah so i'll be uh trying to uh cover uh

00:00:46,480 --> 00:00:51,199
most of the parts so

00:00:48,160 --> 00:00:52,559
i would uh like to first introduce the

00:00:51,199 --> 00:00:54,079
basic theoretical concepts like

00:00:52,559 --> 00:00:54,719
abstraction and application in lambda

00:00:54,079 --> 00:00:56,879
calculus

00:00:54,719 --> 00:00:58,320
along with some substitution of what is

00:00:56,879 --> 00:01:01,359
a substitution

00:00:58,320 --> 00:01:02,640
then i would mainly cover uh some data

00:01:01,359 --> 00:01:05,040
types encodings like

00:01:02,640 --> 00:01:05,680
boolean values logical operators charge

00:01:05,040 --> 00:01:08,799
numerals

00:01:05,680 --> 00:01:12,560
some predicates and uh two recursions

00:01:08,799 --> 00:01:14,479
so and if

00:01:12,560 --> 00:01:16,479
next i would like to acknowledge dr

00:01:14,479 --> 00:01:17,600
david busley's talk uh which actually

00:01:16,479 --> 00:01:20,479
inspired me to uh

00:01:17,600 --> 00:01:21,360
study lambda calculus uh in uh with

00:01:20,479 --> 00:01:24,000
python so

00:01:21,360 --> 00:01:25,520
uh i was uh starting with untyped lambda

00:01:24,000 --> 00:01:27,920
calculus at first so

00:01:25,520 --> 00:01:28,880
uh then i thought why not uh go ahead

00:01:27,920 --> 00:01:31,759
and try with uh

00:01:28,880 --> 00:01:32,720
so try this mathematical concepts in uh

00:01:31,759 --> 00:01:34,880
in python

00:01:32,720 --> 00:01:36,479
so i came up with this stock named uh

00:01:34,880 --> 00:01:38,960
lambda calculus from the ground up

00:01:36,479 --> 00:01:40,720
which uh dr david brisley uh delivered

00:01:38,960 --> 00:01:44,240
at python 2000

00:01:40,720 --> 00:01:46,079
like on 2019 cleveland so uh

00:01:44,240 --> 00:01:48,560
i would also like to express my sincere

00:01:46,079 --> 00:01:49,600
gratitude to the pycon online au 2020

00:01:48,560 --> 00:01:52,399
organizers like

00:01:49,600 --> 00:01:52,880
they have tremendously helped me uh to

00:01:52,399 --> 00:01:56,159
uh

00:01:52,880 --> 00:01:59,360
i mean make this talk possible so

00:01:56,159 --> 00:02:01,119
for assisting me all kinds of stuffs

00:01:59,360 --> 00:02:02,719
so okay so i will start with some

00:02:01,119 --> 00:02:06,000
history so

00:02:02,719 --> 00:02:09,759
at first uh this lambda calculus was uh

00:02:06,000 --> 00:02:10,160
started uh by uh alonzo church while he

00:02:09,759 --> 00:02:11,920
was

00:02:10,160 --> 00:02:13,360
teaching mathematics and philosophy at

00:02:11,920 --> 00:02:15,680
princeton university

00:02:13,360 --> 00:02:16,480
and uh the motivation behind the study

00:02:15,680 --> 00:02:18,080
was to uh

00:02:16,480 --> 00:02:19,520
study some mathematical properties of

00:02:18,080 --> 00:02:21,520
computable functions

00:02:19,520 --> 00:02:23,440
so there is some controversy regarding

00:02:21,520 --> 00:02:26,480
the choice of the lambda symbol uh

00:02:23,440 --> 00:02:28,879
like uh how uh why church uh

00:02:26,480 --> 00:02:30,400
came up with this uh symbol or why the

00:02:28,879 --> 00:02:32,560
name lambda was chosen

00:02:30,400 --> 00:02:33,920
but uh he stated later that it was

00:02:32,560 --> 00:02:37,519
completely accidental

00:02:33,920 --> 00:02:39,599
no controversy regarding that so

00:02:37,519 --> 00:02:41,519
uh some notes to remember like lambda

00:02:39,599 --> 00:02:42,319
calculus is able to simulate uh any

00:02:41,519 --> 00:02:44,560
turing machine

00:02:42,319 --> 00:02:46,480
making it turning complete uh it lies in

00:02:44,560 --> 00:02:48,400
the heart of functional programming uh

00:02:46,480 --> 00:02:49,920
and has other pertinent applications in

00:02:48,400 --> 00:02:51,599
philosophy category theory or

00:02:49,920 --> 00:02:54,160
computational linguistics

00:02:51,599 --> 00:02:55,680
uh it's uh i mean uh lambda calculus is

00:02:54,160 --> 00:02:57,120
simulated in some functional programming

00:02:55,680 --> 00:03:00,400
languages like uh

00:02:57,120 --> 00:03:03,120
lisp scheme meta language uh or haskell

00:03:00,400 --> 00:03:05,360
so haskell is uh i mean list skip and

00:03:03,120 --> 00:03:08,480
haskell are very popular but

00:03:05,360 --> 00:03:12,000
some of you guys may have uh i mean

00:03:08,480 --> 00:03:14,319
heard about meta language ml so uh

00:03:12,000 --> 00:03:16,319
the basic uh fundamental thing about

00:03:14,319 --> 00:03:19,599
lambda calculus is that uh

00:03:16,319 --> 00:03:20,879
this i mean we functions are actually

00:03:19,599 --> 00:03:22,959
values so these are the

00:03:20,879 --> 00:03:25,120
this this uh line we should keep in mind

00:03:22,959 --> 00:03:27,360
that functions are actually values

00:03:25,120 --> 00:03:28,959
so university we uh mainly uh focus on

00:03:27,360 --> 00:03:30,879
the untyped lambda calculus and we use

00:03:28,959 --> 00:03:33,040
python 3 as our programming tool

00:03:30,879 --> 00:03:34,959
so although not a purely functional

00:03:33,040 --> 00:03:37,040
programming language python python

00:03:34,959 --> 00:03:38,560
has had uh lambda functionalities added

00:03:37,040 --> 00:03:41,680
to its syntax during uh

00:03:38,560 --> 00:03:43,360
1994. so uh

00:03:41,680 --> 00:03:45,120
we all know what a function is so i will

00:03:43,360 --> 00:03:46,000
start with introducing a function so a

00:03:45,120 --> 00:03:49,120
function uh

00:03:46,000 --> 00:03:52,239
f is a binary mapping uh which uh

00:03:49,120 --> 00:03:54,720
lets two uh i mean uh values like

00:03:52,239 --> 00:03:56,480
it it's a binary mapping from a set of

00:03:54,720 --> 00:03:59,280
inputs x which is called domain

00:03:56,480 --> 00:04:00,480
to a possible set of outputs called y y

00:03:59,280 --> 00:04:02,480
which is called codamine

00:04:00,480 --> 00:04:03,840
but each input actually corresponds to

00:04:02,480 --> 00:04:07,040
exactly one output so

00:04:03,840 --> 00:04:08,480
um one uh value in x uh can be mapped to

00:04:07,040 --> 00:04:11,120
only a single vector and y

00:04:08,480 --> 00:04:12,720
so like uh if we define this f x equals

00:04:11,120 --> 00:04:16,160
to x plus one whole square

00:04:12,720 --> 00:04:19,280
and uh uh if where f maps

00:04:16,160 --> 00:04:21,120
x to x plus one whole square and uh so

00:04:19,280 --> 00:04:23,199
we can go with two examples like f of

00:04:21,120 --> 00:04:25,680
five is actually 36 so

00:04:23,199 --> 00:04:26,320
five is mapped to 36 only a single value

00:04:25,680 --> 00:04:28,560
so

00:04:26,320 --> 00:04:31,280
uh it's not possible that any other

00:04:28,560 --> 00:04:32,560
value will be mapped to 36 so only 5 can

00:04:31,280 --> 00:04:35,040
be mapped to 36

00:04:32,560 --> 00:04:36,160
similarly 2.7 can only be mapped to

00:04:35,040 --> 00:04:39,520
13.69

00:04:36,160 --> 00:04:40,960
and so on uh so this uh function f x

00:04:39,520 --> 00:04:43,280
equals to x plus 1 whole square in

00:04:40,960 --> 00:04:46,400
lambda in calculus uh

00:04:43,280 --> 00:04:46,960
form can be written in this expression

00:04:46,400 --> 00:04:50,080
so

00:04:46,960 --> 00:04:51,600
lambda symbol x separated by a dot given

00:04:50,080 --> 00:04:53,600
by x plus 1

00:04:51,600 --> 00:04:54,960
followed by x plus 1 whole square so

00:04:53,600 --> 00:04:56,960
this dot is the

00:04:54,960 --> 00:04:58,880
separation symbol and the term after the

00:04:56,960 --> 00:05:01,120
separation symbol is the expression so

00:04:58,880 --> 00:05:02,479
here x is the domain x specifies the

00:05:01,120 --> 00:05:03,759
domain and x plus one whole square

00:05:02,479 --> 00:05:06,639
specifies the codomain

00:05:03,759 --> 00:05:07,280
so uh this dot is the separation symbol

00:05:06,639 --> 00:05:10,400
uh

00:05:07,280 --> 00:05:11,840
uh and uh tells that uh

00:05:10,400 --> 00:05:13,440
after the separation symbol is the

00:05:11,840 --> 00:05:15,600
expression to which the input

00:05:13,440 --> 00:05:17,520
x is mapped so x is mapped to x plus one

00:05:15,600 --> 00:05:20,320
whole square so this is the basic thing

00:05:17,520 --> 00:05:23,360
to keep in mind

00:05:20,320 --> 00:05:27,120
so i uh so i chose

00:05:23,360 --> 00:05:29,919
example to make it more clearer so

00:05:27,120 --> 00:05:31,520
so uh now uh to pass an argument like

00:05:29,919 --> 00:05:32,080
five or two point seven like we did in

00:05:31,520 --> 00:05:34,320
uh

00:05:32,080 --> 00:05:35,120
the basic uh function example like uh

00:05:34,320 --> 00:05:39,120
here

00:05:35,120 --> 00:05:42,240
uh if f5 let's go to 36 and f4 2.7 13.69

00:05:39,120 --> 00:05:44,639
we can do the similar thing in lambda uh

00:05:42,240 --> 00:05:45,680
lambda calculus in the following way so

00:05:44,639 --> 00:05:48,560
like the first

00:05:45,680 --> 00:05:49,520
term like the first one fx equals i mean

00:05:48,560 --> 00:05:51,840
f of 5

00:05:49,520 --> 00:05:52,560
can be actually written as this so uh

00:05:51,840 --> 00:05:55,199
lambda x

00:05:52,560 --> 00:05:56,560
dot x plus 1 whole square followed by

00:05:55,199 --> 00:05:58,639
another parenthesis uh

00:05:56,560 --> 00:06:00,880
which takes in the argument so 5 is the

00:05:58,639 --> 00:06:02,000
argument which is passed to lambda x dot

00:06:00,880 --> 00:06:03,919
x plus 1 whole square

00:06:02,000 --> 00:06:06,319
or in this case or the second case

00:06:03,919 --> 00:06:07,840
lambda x dot x plus 1 whole square 2.7

00:06:06,319 --> 00:06:09,520
so the expression inside the first

00:06:07,840 --> 00:06:11,600
parenthesis is the abstraction

00:06:09,520 --> 00:06:12,639
and the whole expression i mean the only

00:06:11,600 --> 00:06:14,000
this uh

00:06:12,639 --> 00:06:15,680
expression is called the abstraction

00:06:14,000 --> 00:06:17,600
lambda x dot x plus 1 whole square and

00:06:15,680 --> 00:06:18,400
the total thing taking in the argument

00:06:17,600 --> 00:06:21,680
together

00:06:18,400 --> 00:06:24,400
is called an application of the function

00:06:21,680 --> 00:06:25,759
in python we can do this uh in a very uh

00:06:24,400 --> 00:06:27,520
similar fashion like

00:06:25,759 --> 00:06:29,600
suppose we want to uh simulate the

00:06:27,520 --> 00:06:30,240
square function so uh like lambda x dot

00:06:29,600 --> 00:06:32,800
x square

00:06:30,240 --> 00:06:34,560
uh taking in 9 as an argument so is

00:06:32,800 --> 00:06:38,240
written in python as uh

00:06:34,560 --> 00:06:38,639
lambda so very uh similar analogy like

00:06:38,240 --> 00:06:40,560
uh

00:06:38,639 --> 00:06:43,120
lambda is replaced by the lambda called

00:06:40,560 --> 00:06:44,639
lmbta uh separated by a space here

00:06:43,120 --> 00:06:46,400
we see that there is no space after the

00:06:44,639 --> 00:06:47,120
lambda but in python we should give a

00:06:46,400 --> 00:06:49,280
space here

00:06:47,120 --> 00:06:50,479
the syntax there is uh prepared like

00:06:49,280 --> 00:06:53,520
that and

00:06:50,479 --> 00:06:57,199
here this x is the uh this x this is the

00:06:53,520 --> 00:06:59,520
uh domain the separate separation symbol

00:06:57,199 --> 00:07:01,919
dot is actually replaced by a colon here

00:06:59,520 --> 00:07:04,000
so and the x squared is written in uh as

00:07:01,919 --> 00:07:06,000
x squared like we do in uh python

00:07:04,000 --> 00:07:07,280
so and nine is passed as an argument we

00:07:06,000 --> 00:07:10,639
will see that 81

00:07:07,280 --> 00:07:13,919
is the result so as uh

00:07:10,639 --> 00:07:15,680
theory tells us so we have already seen

00:07:13,919 --> 00:07:17,919
what an abstraction and application is

00:07:15,680 --> 00:07:19,440
so a new expression uh lambda x

00:07:17,919 --> 00:07:21,919
dot a can always be generated from an

00:07:19,440 --> 00:07:24,400
applica from an uh

00:07:21,919 --> 00:07:25,599
sorry uh from an expression a and a

00:07:24,400 --> 00:07:28,319
variable x this is called

00:07:25,599 --> 00:07:29,680
abstraction and a new expression a uh

00:07:28,319 --> 00:07:31,840
applied to b is called the application

00:07:29,680 --> 00:07:35,759
of the expression a to the expression b

00:07:31,840 --> 00:07:38,000
so we can also uh try this with

00:07:35,759 --> 00:07:39,280
two lambda functions in a in a single

00:07:38,000 --> 00:07:42,720
expression so like uh

00:07:39,280 --> 00:07:44,800
lambda so we can pass lambda x dot x

00:07:42,720 --> 00:07:46,479
square plus y square so it is a

00:07:44,800 --> 00:07:47,840
this total is a function of two

00:07:46,479 --> 00:07:50,400
variables so

00:07:47,840 --> 00:07:51,440
this is actually f of x comma y equals

00:07:50,400 --> 00:07:53,360
to uh

00:07:51,440 --> 00:07:55,120
x square plus y square so this can be

00:07:53,360 --> 00:07:57,280
written as lambda y dot

00:07:55,120 --> 00:07:59,280
lambda x dot x square plus y square so

00:07:57,280 --> 00:08:02,879
it is taking in two uh

00:07:59,280 --> 00:08:02,879
variables so uh

00:08:03,360 --> 00:08:06,960
yeah so applying this to the so at first

00:08:05,360 --> 00:08:08,800
we apply uh our

00:08:06,960 --> 00:08:10,960
so we passed 2 as an argument to the

00:08:08,800 --> 00:08:13,280
whole expression so we will see that

00:08:10,960 --> 00:08:15,280
all the y's are replaced by uh 2 at

00:08:13,280 --> 00:08:17,360
first so this will be evaluated to

00:08:15,280 --> 00:08:18,800
lambda x dot x 1 plus 2 square

00:08:17,360 --> 00:08:20,080
substituting the y variables in the

00:08:18,800 --> 00:08:21,120
expression this is actually the beta

00:08:20,080 --> 00:08:23,360
reduction

00:08:21,120 --> 00:08:24,800
uh so when the reduced lambda function

00:08:23,360 --> 00:08:26,400
is subjected to another application like

00:08:24,800 --> 00:08:29,120
we pass three as an argument

00:08:26,400 --> 00:08:29,440
all the x's will be replaced by uh 3 and

00:08:29,120 --> 00:08:30,879
so

00:08:29,440 --> 00:08:32,880
we will get 3 squared plus 12 square

00:08:30,879 --> 00:08:33,680
equals to 13. so the whole expression is

00:08:32,880 --> 00:08:35,839
like this

00:08:33,680 --> 00:08:37,839
it's written like this so we pass 2 as

00:08:35,839 --> 00:08:38,880
an argument first then we pass 3 as an

00:08:37,839 --> 00:08:41,599
argument later

00:08:38,880 --> 00:08:43,360
to the previous thing so in python uh we

00:08:41,599 --> 00:08:43,919
see that this is the expression and in

00:08:43,360 --> 00:08:46,160
python

00:08:43,919 --> 00:08:47,920
in similar way we can uh express this so

00:08:46,160 --> 00:08:50,320
lambda y uh colon lambda

00:08:47,920 --> 00:08:50,959
x colon x square plus y square with two

00:08:50,320 --> 00:08:52,800
as

00:08:50,959 --> 00:08:54,240
the first argument first and followed by

00:08:52,800 --> 00:08:55,040
three as the second argument so we will

00:08:54,240 --> 00:08:58,959
get 13

00:08:55,040 --> 00:09:00,800
as theories so we can also uh

00:08:58,959 --> 00:09:02,880
try our hands on with other applications

00:09:00,800 --> 00:09:05,200
like the application of so we can

00:09:02,880 --> 00:09:07,120
pass another lambda function as an

00:09:05,200 --> 00:09:07,680
argument to some other lambda function

00:09:07,120 --> 00:09:09,519
so

00:09:07,680 --> 00:09:11,120
which after substitution becomes so this

00:09:09,519 --> 00:09:12,320
is actually the identity function so

00:09:11,120 --> 00:09:15,600
lambda x dot x

00:09:12,320 --> 00:09:17,440
uh applied to lambda y dot y so

00:09:15,600 --> 00:09:19,279
this becomes uh we'll see that this

00:09:17,440 --> 00:09:20,560
become becomes lambda y dot y this is

00:09:19,279 --> 00:09:22,800
the identity function so

00:09:20,560 --> 00:09:24,080
we can also uh try this out in python so

00:09:22,800 --> 00:09:27,040
lambda x dot uh

00:09:24,080 --> 00:09:28,720
colon x uh followed by lambda y column y

00:09:27,040 --> 00:09:30,399
applied uh applied to this

00:09:28,720 --> 00:09:32,399
and we will get if we pass five as an

00:09:30,399 --> 00:09:33,120
argument to l so we stored this function

00:09:32,399 --> 00:09:35,839
in l

00:09:33,120 --> 00:09:36,880
so uh and then if we pass five as an

00:09:35,839 --> 00:09:40,640
argument 12 will

00:09:36,880 --> 00:09:42,160
get back 5. so so a constant function is

00:09:40,640 --> 00:09:43,519
uh so we can also define a constant

00:09:42,160 --> 00:09:46,560
function like lambda

00:09:43,519 --> 00:09:48,080
z dot c so it is like whatever argument

00:09:46,560 --> 00:09:51,040
you pass it will always return

00:09:48,080 --> 00:09:51,519
z so like lambda z uh seven uh with

00:09:51,040 --> 00:09:53,200
three

00:09:51,519 --> 00:09:54,560
as an argument first we will it will

00:09:53,200 --> 00:09:56,959
return seven and similarly

00:09:54,560 --> 00:09:57,920
if we pass lambda y dot y two uh this

00:09:56,959 --> 00:10:01,360
lambda z dot

00:09:57,920 --> 00:10:04,240
eleven will get eleven so this is the

00:10:01,360 --> 00:10:05,920
uh so yeah so we uh saw this lambda y

00:10:04,240 --> 00:10:07,440
dot lambda x dot x square plus y square

00:10:05,920 --> 00:10:08,720
and this is actually

00:10:07,440 --> 00:10:11,279
this is actually called the carried

00:10:08,720 --> 00:10:13,200
version of f x comma y equals to x plus

00:10:11,279 --> 00:10:14,880
x square plus y square so it was named

00:10:13,200 --> 00:10:16,800
after haskell curry after who

00:10:14,880 --> 00:10:19,120
the programming language sql is also

00:10:16,800 --> 00:10:19,680
named so he was a pioneer in combinatory

00:10:19,120 --> 00:10:22,640
logic

00:10:19,680 --> 00:10:24,160
so this can uh so f of x so this can

00:10:22,640 --> 00:10:27,040
also be written in lambda so

00:10:24,160 --> 00:10:28,480
uh using lambda so lambda x comma y uh

00:10:27,040 --> 00:10:30,880
colon x square plus y square

00:10:28,480 --> 00:10:31,680
uh with three comma two s two arguments

00:10:30,880 --> 00:10:34,720
password

00:10:31,680 --> 00:10:37,200
return 30. so

00:10:34,720 --> 00:10:39,360
i am already i think out of time but so

00:10:37,200 --> 00:10:41,600
i will keep some uh

00:10:39,360 --> 00:10:42,560
theory so like any valid expression in

00:10:41,600 --> 00:10:44,480
lambda so i will

00:10:42,560 --> 00:10:45,920
tell what a lambda term is so any valid

00:10:44,480 --> 00:10:46,880
expression in lambda calculus is called

00:10:45,920 --> 00:10:50,480
the lambda term

00:10:46,880 --> 00:10:52,880
so we saw here like uh so here

00:10:50,480 --> 00:10:54,399
uh like y or x are variables so any

00:10:52,880 --> 00:10:56,480
variable is a lambda

00:10:54,399 --> 00:10:58,480
also the abstraction is also a lambda

00:10:56,480 --> 00:11:00,800
term so like lambda x dot a

00:10:58,480 --> 00:11:02,160
and also another application can be

00:11:00,800 --> 00:11:04,480
called as a lambda term

00:11:02,160 --> 00:11:07,600
so we'll keep in mind what a lambda term

00:11:04,480 --> 00:11:09,920
is so i will skip this uh

00:11:07,600 --> 00:11:11,519
uh theory so i will also tell there are

00:11:09,920 --> 00:11:13,600
three kinds of variable operations in a

00:11:11,519 --> 00:11:15,360
lambda term like binding free and bound

00:11:13,600 --> 00:11:18,160
so if you go through the slides you will

00:11:15,360 --> 00:11:20,399
get the idea so the slides will be uh

00:11:18,160 --> 00:11:22,560
i mean online so i'll try to skip this

00:11:20,399 --> 00:11:22,560
uh

00:11:23,839 --> 00:11:28,480
yeah so now uh i will tell what a

00:11:25,519 --> 00:11:30,640
combinatory so combinator uh

00:11:28,480 --> 00:11:31,920
is a term whose free variable is

00:11:30,640 --> 00:11:33,519
actually a null set so

00:11:31,920 --> 00:11:35,920
if we study free variable you will

00:11:33,519 --> 00:11:38,079
understand that but uh

00:11:35,920 --> 00:11:39,760
this is the basic thing like uh in the

00:11:38,079 --> 00:11:40,720
free variable of a lambda term if it

00:11:39,760 --> 00:11:42,880
gives a null set

00:11:40,720 --> 00:11:44,800
it's a combinator so the identity

00:11:42,880 --> 00:11:46,399
function we saw before it's a combinator

00:11:44,800 --> 00:11:48,560
uh and we can also define another

00:11:46,399 --> 00:11:51,600
combinator like beta b combinator so

00:11:48,560 --> 00:11:52,240
b is actually written as lambda u v w

00:11:51,600 --> 00:11:54,800
dot u

00:11:52,240 --> 00:11:56,000
applied to v applied to w so this lambda

00:11:54,800 --> 00:11:58,720
u v w is actually

00:11:56,000 --> 00:12:00,160
the short term for lambda u dot lambda v

00:11:58,720 --> 00:12:02,480
dot lambda w

00:12:00,160 --> 00:12:03,760
so uh we can also show that uh b is a

00:12:02,480 --> 00:12:06,000
combinator so if we

00:12:03,760 --> 00:12:07,360
uh find out the free variable of uh the

00:12:06,000 --> 00:12:09,760
b combinator we will

00:12:07,360 --> 00:12:10,560
get a null set so the mathematics is

00:12:09,760 --> 00:12:14,320
very simple

00:12:10,560 --> 00:12:16,000
uh so like uh you can get the id

00:12:14,320 --> 00:12:17,600
so we can define this combinator in

00:12:16,000 --> 00:12:20,639
python like it would be uh

00:12:17,600 --> 00:12:24,320
combinator like lambda u uh dot lambda v

00:12:20,639 --> 00:12:27,600
dot lambda lambda w uh uh

00:12:24,320 --> 00:12:29,839
with uh u uh applied to v applied to w

00:12:27,600 --> 00:12:30,880
so if we pass b we will see that it's a

00:12:29,839 --> 00:12:32,720
function so

00:12:30,880 --> 00:12:34,959
we can also define a k combinator like k

00:12:32,720 --> 00:12:37,200
equals to lambda u uh dot lambda

00:12:34,959 --> 00:12:38,079
w and similar way in python so the

00:12:37,200 --> 00:12:40,240
behavior of k

00:12:38,079 --> 00:12:41,440
is to choose uh the left argument if two

00:12:40,240 --> 00:12:43,120
arguments are passed

00:12:41,440 --> 00:12:44,880
uh like if one and two are passed

00:12:43,120 --> 00:12:47,120
through two k will get one and if

00:12:44,880 --> 00:12:49,200
two and one are first okay we'll get two

00:12:47,120 --> 00:12:49,839
uh so it picks that picks up the left

00:12:49,200 --> 00:12:51,279
element

00:12:49,839 --> 00:12:53,360
and we can also define another

00:12:51,279 --> 00:12:55,519
combinator like c combinator uh so c

00:12:53,360 --> 00:12:57,519
equals to lambda u v w if like lambda u

00:12:55,519 --> 00:12:59,360
dot lambda v dot lambda w dot u

00:12:57,519 --> 00:13:00,560
v and w so these are different

00:12:59,360 --> 00:13:04,399
combinators we can

00:13:00,560 --> 00:13:06,480
try with uh try with python so

00:13:04,399 --> 00:13:08,959
i will skip this reduction part we

00:13:06,480 --> 00:13:12,240
already saw what a beta reduction is

00:13:08,959 --> 00:13:14,639
so yeah so uh

00:13:12,240 --> 00:13:16,320
like uh now we'll uh import some data uh

00:13:14,639 --> 00:13:17,760
types and charge numerals so like true

00:13:16,320 --> 00:13:20,160
and false value so true

00:13:17,760 --> 00:13:21,120
true can be uh written as lambda u dot

00:13:20,160 --> 00:13:22,800
lambda v dot

00:13:21,120 --> 00:13:24,639
u so it is also called the t combinator

00:13:22,800 --> 00:13:26,800
equivalent to the k combinator we saw

00:13:24,639 --> 00:13:28,560
about so it will always uh it acts as a

00:13:26,800 --> 00:13:29,440
switch as told by david basically in his

00:13:28,560 --> 00:13:31,760
talk so

00:13:29,440 --> 00:13:33,200
uh i got this down switch from his stock

00:13:31,760 --> 00:13:36,160
only so like uh

00:13:33,200 --> 00:13:37,040
yeah so it was uh like the behavior of

00:13:36,160 --> 00:13:39,680
true is to

00:13:37,040 --> 00:13:41,040
actually uh choose the left element as

00:13:39,680 --> 00:13:42,959
we saw in k combinator

00:13:41,040 --> 00:13:44,399
so if two arguments are passed two

00:13:42,959 --> 00:13:46,959
elements are passed as an

00:13:44,399 --> 00:13:48,720
as arguments and for the false we will

00:13:46,959 --> 00:13:50,800
write lambda u dot lambda v dot v

00:13:48,720 --> 00:13:52,880
and the behavior of false is to uh

00:13:50,800 --> 00:13:54,639
actually uh choose uh

00:13:52,880 --> 00:13:56,399
the right element so if we pass one

00:13:54,639 --> 00:13:59,680
comma zero to false it will

00:13:56,399 --> 00:14:00,480
choose zero so like the similar way we

00:13:59,680 --> 00:14:03,279
can go with

00:14:00,480 --> 00:14:03,920
not like lambda u dot u false and true

00:14:03,279 --> 00:14:06,480
uh

00:14:03,920 --> 00:14:07,279
and also with and like lambda u dot

00:14:06,480 --> 00:14:10,720
lambda

00:14:07,279 --> 00:14:13,839
u v w so we can uh go uh

00:14:10,720 --> 00:14:15,199
defining this in lambda uh calculus with

00:14:13,839 --> 00:14:17,680
lambda function in python

00:14:15,199 --> 00:14:19,360
so very trivial so we can we need to

00:14:17,680 --> 00:14:22,079
remember these things and we can

00:14:19,360 --> 00:14:24,720
go with trying them so simulating the

00:14:22,079 --> 00:14:28,399
behaviors of all these uh

00:14:24,720 --> 00:14:30,079
logical operators so like we can also go

00:14:28,399 --> 00:14:33,360
with or and if then else

00:14:30,079 --> 00:14:35,199
so next we'll try and putting some uh

00:14:33,360 --> 00:14:37,279
numbers called charge numerals so like

00:14:35,199 --> 00:14:38,399
zero is actually written as lambda f dot

00:14:37,279 --> 00:14:40,560
lambda u dot u

00:14:38,399 --> 00:14:41,600
and one is actually written as lambda f

00:14:40,560 --> 00:14:44,480
dot lambda u

00:14:41,600 --> 00:14:46,480
dot f of u so to understand uh the

00:14:44,480 --> 00:14:48,399
behavior we actually need to define a

00:14:46,480 --> 00:14:50,320
plus one function which will return uh

00:14:48,399 --> 00:14:50,880
taking in an argument n it will return n

00:14:50,320 --> 00:14:52,800
plus one

00:14:50,880 --> 00:14:54,880
so it's a very trivial function so like

00:14:52,800 --> 00:14:57,040
to understand is zero if we pass zero

00:14:54,880 --> 00:14:59,040
alone it will give it will return uh as

00:14:57,040 --> 00:15:00,320
a function so but uh if we want to

00:14:59,040 --> 00:15:02,320
understand the behavior of

00:15:00,320 --> 00:15:03,440
zero we need to pass plus one and zero

00:15:02,320 --> 00:15:05,839
as arguments to it

00:15:03,440 --> 00:15:06,720
also for one we need to pass plus one

00:15:05,839 --> 00:15:08,720
applied to zero

00:15:06,720 --> 00:15:10,240
as argument so it will return one for

00:15:08,720 --> 00:15:13,920
two also if we uh write

00:15:10,240 --> 00:15:16,160
two plus one and zero will get uh

00:15:13,920 --> 00:15:17,199
two uh it will get you will get back the

00:15:16,160 --> 00:15:20,639
two integer

00:15:17,199 --> 00:15:22,880
so i'll move on so like uh

00:15:20,639 --> 00:15:26,240
we can also define successors uh

00:15:22,880 --> 00:15:29,600
addition multiplications and powers

00:15:26,240 --> 00:15:33,279
so we can define uh

00:15:29,600 --> 00:15:35,040
uh in so we can uh define some tuples

00:15:33,279 --> 00:15:35,759
like people can be replaced uh this one

00:15:35,040 --> 00:15:38,320
by lambda

00:15:35,759 --> 00:15:39,360
lambda v dot lambda f dot if applied to

00:15:38,320 --> 00:15:42,959
u nv

00:15:39,360 --> 00:15:44,320
so we can go with uh tupel we can go

00:15:42,959 --> 00:15:46,880
with the left we can put right

00:15:44,320 --> 00:15:48,399
so left will uh indicate the left

00:15:46,880 --> 00:15:49,759
element of the tuple right will indicate

00:15:48,399 --> 00:15:52,839
the right element of the token

00:15:49,759 --> 00:15:56,560
and empty will uh give us an empty uh

00:15:52,839 --> 00:15:59,440
list so we can define predecessor

00:15:56,560 --> 00:16:01,199
uh subtraction where and also we can

00:15:59,440 --> 00:16:02,240
check this predicate if it if a number

00:16:01,199 --> 00:16:05,360
is zero or not so

00:16:02,240 --> 00:16:06,240
we define uh e0 and then we check is

00:16:05,360 --> 00:16:09,120
zero

00:16:06,240 --> 00:16:10,800
and z if we if we check 0 is a 0 or not

00:16:09,120 --> 00:16:13,279
so e 0 applied to 0

00:16:10,800 --> 00:16:15,120
and we it will it's supposed to return

00:16:13,279 --> 00:16:15,519
true right so we already know that uh

00:16:15,120 --> 00:16:17,040
the

00:16:15,519 --> 00:16:18,639
behavior of 2 is to choose the left

00:16:17,040 --> 00:16:22,000
element so it will

00:16:18,639 --> 00:16:25,440
from 1 and 0 it will return uh one only

00:16:22,000 --> 00:16:27,519
so it's working uh correctly so we can

00:16:25,440 --> 00:16:30,720
also check with a one so each zero one

00:16:27,519 --> 00:16:33,920
one and zero it will turn zero

00:16:30,720 --> 00:16:35,519
uh so we can define uh left less than

00:16:33,920 --> 00:16:38,399
equals two also with this so

00:16:35,519 --> 00:16:40,000
the last thing uh uh so i want to define

00:16:38,399 --> 00:16:44,560
what that y combinator is

00:16:40,000 --> 00:16:45,680
so uh so y combinator is lambda u dot

00:16:44,560 --> 00:16:48,399
lambda v dot u

00:16:45,680 --> 00:16:49,600
uh applied to v and v and uh lambda

00:16:48,399 --> 00:16:52,639
lambda v dot u

00:16:49,600 --> 00:16:55,519
uh v and v so for a lambda term so we

00:16:52,639 --> 00:16:57,279
saw what a lambda term is uh for a

00:16:55,519 --> 00:17:00,160
lambda term a belonging to uh

00:16:57,279 --> 00:17:02,079
so for a lambda term a y combinator

00:17:00,160 --> 00:17:04,160
applied to a is a fixed point of a so

00:17:02,079 --> 00:17:05,439
this is the behavior of y combinator so

00:17:04,160 --> 00:17:07,520
this is because it can be shown

00:17:05,439 --> 00:17:10,640
mathematically that a applied to

00:17:07,520 --> 00:17:11,039
y ah combinator and a it will be reduced

00:17:10,640 --> 00:17:14,000
to

00:17:11,039 --> 00:17:14,640
y uh combinator applied to a so this is

00:17:14,000 --> 00:17:17,679
like uh

00:17:14,640 --> 00:17:20,559
the fixed uh so it it's it acts like a

00:17:17,679 --> 00:17:21,919
fixed point theorem so and also we

00:17:20,559 --> 00:17:23,439
should uh keep in mind that unlike

00:17:21,919 --> 00:17:26,400
haskell python does not support

00:17:23,439 --> 00:17:28,400
lazy evaluation so to understand fact

00:17:26,400 --> 00:17:31,200
and and even fibonacci and

00:17:28,400 --> 00:17:32,000
so factorial n and fibonacci n uh we

00:17:31,200 --> 00:17:33,520
need to understand

00:17:32,000 --> 00:17:35,120
something so this is like uh trying to

00:17:33,520 --> 00:17:36,480
define uh uh

00:17:35,120 --> 00:17:38,799
recursive functions with previous

00:17:36,480 --> 00:17:40,720
methods will lead to uh

00:17:38,799 --> 00:17:42,559
uh maximum recursion depth error so we

00:17:40,720 --> 00:17:44,400
cannot uh go with like

00:17:42,559 --> 00:17:46,080
uh it will try to evaluate all the

00:17:44,400 --> 00:17:47,760
branches of the including uh

00:17:46,080 --> 00:17:49,919
parallelly at the same time so we need

00:17:47,760 --> 00:17:52,320
my internet

00:17:49,919 --> 00:17:54,160
just a couple of minutes over um if you

00:17:52,320 --> 00:17:56,080
can wrap up at the end of the slide

00:17:54,160 --> 00:18:00,240
yeah i have only three uh three modes

00:17:56,080 --> 00:18:01,440
right so i will wrap up this is that

00:18:00,240 --> 00:18:04,880
fine

00:18:01,440 --> 00:18:06,559
yeah yeah just uh okay yeah so we need

00:18:04,880 --> 00:18:08,400
to uh redefine some previous functions

00:18:06,559 --> 00:18:09,280
by adding extra functions for function

00:18:08,400 --> 00:18:11,440
calls like

00:18:09,280 --> 00:18:13,679
before starting to uh encode so like uh

00:18:11,440 --> 00:18:15,679
we defined true before but uh

00:18:13,679 --> 00:18:16,880
to work with fibonacci or factorial in

00:18:15,679 --> 00:18:19,919
we need to define a

00:18:16,880 --> 00:18:21,360
true new s lambda u lambda v and

00:18:19,919 --> 00:18:23,440
u should be passed as a function

00:18:21,360 --> 00:18:24,320
similarly for false v should be passed

00:18:23,440 --> 00:18:26,640
as a function

00:18:24,320 --> 00:18:28,000
and e zero nu would be defined like uh

00:18:26,640 --> 00:18:30,160
the false and the true should be

00:18:28,000 --> 00:18:31,840
replaced by false new and true mu

00:18:30,160 --> 00:18:33,520
and the y combinator as we defined

00:18:31,840 --> 00:18:36,559
before like here uh we will

00:18:33,520 --> 00:18:39,200
uh define that uh with lambda function

00:18:36,559 --> 00:18:40,000
in python so uh so understand the

00:18:39,200 --> 00:18:42,559
factorial n

00:18:40,000 --> 00:18:43,360
we will define n1 at first so n1 is

00:18:42,559 --> 00:18:45,840
lambda f

00:18:43,360 --> 00:18:47,200
lambda n one if n equals to equal to

00:18:45,840 --> 00:18:50,480
zero else it will return

00:18:47,200 --> 00:18:54,640
n into f of n minus one as we do in uh

00:18:50,480 --> 00:18:58,000
factorial so now to understand uh

00:18:54,640 --> 00:19:00,880
to find the uh i mean factorial of a num

00:18:58,000 --> 00:19:02,640
argument uh end we will pass y applied

00:19:00,880 --> 00:19:04,480
to n one to that so like y

00:19:02,640 --> 00:19:06,240
n one applied to six will return seven

00:19:04,480 --> 00:19:07,039
twenty so six at the factorial of six is

00:19:06,240 --> 00:19:09,919
seventeen p

00:19:07,039 --> 00:19:11,280
we know that so y uh applied to n1 so y

00:19:09,919 --> 00:19:14,880
is the y combinator here

00:19:11,280 --> 00:19:16,720
applied to n1 applied to 6 will give 720

00:19:14,880 --> 00:19:19,280
and the last thing like uh for uh

00:19:16,720 --> 00:19:19,679
fibonacci uh so to find the nf fibonacci

00:19:19,280 --> 00:19:22,480
number

00:19:19,679 --> 00:19:23,440
like we define n2 equals to lambda f uh

00:19:22,480 --> 00:19:25,840
lambda n

00:19:23,440 --> 00:19:26,559
uh it will return one if n less than

00:19:25,840 --> 00:19:28,240
equals to true

00:19:26,559 --> 00:19:29,760
else it will return f of n minus one

00:19:28,240 --> 00:19:30,720
plus f of n minus two like we do in

00:19:29,760 --> 00:19:33,200
fibonacci uh

00:19:30,720 --> 00:19:35,039
case so again y combinator applied to n

00:19:33,200 --> 00:19:37,120
two applied to nine will give 34

00:19:35,039 --> 00:19:38,240
so yeah so this is the ninth fibonacci

00:19:37,120 --> 00:19:40,960
number so

00:19:38,240 --> 00:19:43,039
okay so here are the references that

00:19:40,960 --> 00:19:44,480
inspector thank you

00:19:43,039 --> 00:19:46,240
great thank you so much for your talking

00:19:44,480 --> 00:19:47,840
lambda calculus and python internet

00:19:46,240 --> 00:19:50,840
and thank you for handling technical

00:19:47,840 --> 00:19:53,840
difficulties so well

00:19:50,840 --> 00:19:53,840

YouTube URL: https://www.youtube.com/watch?v=_Ob5YOJRQoA


