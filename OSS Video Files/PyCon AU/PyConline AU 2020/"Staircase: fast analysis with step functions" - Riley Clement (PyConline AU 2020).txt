Title: "Staircase: fast analysis with step functions" - Riley Clement (PyConline AU 2020)
Publication date: 2020-09-08
Playlist: PyConline AU 2020
Description: 
	Riley Clement

https://2020.pycon.org.au/program/3TDS8K

This talk introduces the Staircase package â€“ a new open source package with applications in data analysis.  It aims to take the audience on a journey from basics to more advanced usage at a comfortable pace.   A tutorial-esque style will be used to introduce fundamentals, followed by four examples abstracted from real world use cases.

If you work with timestamped data and enjoy a little bit of math, mixed with a terrible sense of humour, then this talk could be right up your alley.

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

Python, PyCon, PyConAU, PyConline

Sat Sep  5 10:25:00 2020 at Obvious
Captions: 
	00:00:00,560 --> 00:00:03,840
hello and welcome to the one obvious

00:00:03,199 --> 00:00:06,000
room

00:00:03,840 --> 00:00:07,680
starting off today's proceedings we have

00:00:06,000 --> 00:00:09,840
riley with his presentation

00:00:07,680 --> 00:00:10,800
staircase fast analysis with step

00:00:09,840 --> 00:00:17,920
functions

00:00:10,800 --> 00:00:17,920
take it away

00:00:18,800 --> 00:00:22,640
good morning pike on australia my name

00:00:21,039 --> 00:00:24,560
is riley and i'm coming to you live from

00:00:22,640 --> 00:00:26,000
newcastle

00:00:24,560 --> 00:00:27,840
well now i suppose that is a bit of a

00:00:26,000 --> 00:00:28,320
lie if you're watching this saturday

00:00:27,840 --> 00:00:30,800
morning

00:00:28,320 --> 00:00:31,519
and i'm probably outside getting some

00:00:30,800 --> 00:00:33,280
exercise

00:00:31,519 --> 00:00:34,640
going for a run perhaps scaling a

00:00:33,280 --> 00:00:36,559
staircase

00:00:34,640 --> 00:00:37,840
speaking of which i'm going to run you

00:00:36,559 --> 00:00:39,360
through staircase

00:00:37,840 --> 00:00:41,600
open source python package that i

00:00:39,360 --> 00:00:42,640
created i developed it for myself and my

00:00:41,600 --> 00:00:44,719
teammates at work

00:00:42,640 --> 00:00:45,760
but it's published publicly on pi pi and

00:00:44,719 --> 00:00:47,200
anaconda

00:00:45,760 --> 00:00:48,960
and the source code is available on

00:00:47,200 --> 00:00:52,120
github there's also

00:00:48,960 --> 00:00:54,079
comprehensive documentation located at

00:00:52,120 --> 00:00:55,920
railing.readthedocs.io

00:00:54,079 --> 00:00:58,399
why railing because it's the staircase

00:00:55,920 --> 00:01:01,199
guide why staircase

00:00:58,399 --> 00:01:02,879
good question so what's in a name the

00:01:01,199 --> 00:01:04,239
staircase package gets its name from the

00:01:02,879 --> 00:01:05,360
mathematical functions known as

00:01:04,239 --> 00:01:07,920
staircase functions

00:01:05,360 --> 00:01:09,360
perhaps better known as step functions

00:01:07,920 --> 00:01:10,000
the package exists to model step

00:01:09,360 --> 00:01:12,080
functions as

00:01:10,000 --> 00:01:13,760
objects and use them with arithmetic

00:01:12,080 --> 00:01:15,520
operators logical operators

00:01:13,760 --> 00:01:16,880
comparators much of which is naturally

00:01:15,520 --> 00:01:18,320
derived from the mathematics of

00:01:16,880 --> 00:01:20,799
functions

00:01:18,320 --> 00:01:21,920
but what is a step function well it's

00:01:20,799 --> 00:01:23,840
much too early in the morning for

00:01:21,920 --> 00:01:25,360
precise mathematical definitions

00:01:23,840 --> 00:01:27,280
just as it's too early in the morning

00:01:25,360 --> 00:01:27,840
for a beer but if you're the type of

00:01:27,280 --> 00:01:29,200
person

00:01:27,840 --> 00:01:30,400
that wants precise mathematical

00:01:29,200 --> 00:01:31,360
definitions you can find them in the

00:01:30,400 --> 00:01:35,600
documentation

00:01:31,360 --> 00:01:38,880
and hey tears to you for everybody else

00:01:35,600 --> 00:01:42,240
step function not step function

00:01:38,880 --> 00:01:45,360
step function not step function

00:01:42,240 --> 00:01:48,000
step function but not the good kind

00:01:45,360 --> 00:01:49,520
so we're in this big wide world outside

00:01:48,000 --> 00:01:54,079
of the safety of the maths classroom

00:01:49,520 --> 00:01:55,439
are we going to find step functions

00:01:54,079 --> 00:01:57,360
so the number of people watching this

00:01:55,439 --> 00:01:59,200
talk is a discrete variable

00:01:57,360 --> 00:02:01,759
at any moment in time the number of

00:01:59,200 --> 00:02:04,320
people watching has to be a whole number

00:02:01,759 --> 00:02:05,600
this gives rise to a step function and

00:02:04,320 --> 00:02:06,719
whether or not people are watching this

00:02:05,600 --> 00:02:08,879
video at all

00:02:06,719 --> 00:02:10,399
is a step function it takes a value of

00:02:08,879 --> 00:02:12,560
zero if nobody is watching

00:02:10,399 --> 00:02:14,720
and it takes a value of one if there's

00:02:12,560 --> 00:02:18,480
one or more people watching

00:02:14,720 --> 00:02:20,560
there's probably just the one hey mum

00:02:18,480 --> 00:02:21,680
share price is another example of a step

00:02:20,560 --> 00:02:23,440
function

00:02:21,680 --> 00:02:25,040
because share prices don't transition

00:02:23,440 --> 00:02:26,640
smoothly from one price to an x

00:02:25,040 --> 00:02:29,200
they jump now it might only be a

00:02:26,640 --> 00:02:31,440
fraction of a cent but it's still a jump

00:02:29,200 --> 00:02:32,959
so all of these examples and many of the

00:02:31,440 --> 00:02:34,319
use cases i'll show you

00:02:32,959 --> 00:02:35,680
are all time based but it's worth

00:02:34,319 --> 00:02:36,000
keeping in mind that step functions

00:02:35,680 --> 00:02:38,160
don't

00:02:36,000 --> 00:02:39,920
have to be time based speaking of

00:02:38,160 --> 00:02:41,360
examples let's ease into it with some

00:02:39,920 --> 00:02:43,599
basics

00:02:41,360 --> 00:02:45,200
so i'm demoing in jupiter lab here i've

00:02:43,599 --> 00:02:45,680
used pip to install the staircase

00:02:45,200 --> 00:02:47,599
package

00:02:45,680 --> 00:02:49,519
and we're ready to go so i'll start by

00:02:47,599 --> 00:02:50,160
importing staircase and we'll refer to

00:02:49,519 --> 00:02:52,879
it as

00:02:50,160 --> 00:02:53,440
sc now the star of the show if you will

00:02:52,879 --> 00:02:56,480
is the

00:02:53,440 --> 00:02:58,959
stairs class stairs are to the staircase

00:02:56,480 --> 00:03:01,040
package what data frame is to pandas

00:02:58,959 --> 00:03:02,720
we create stairs objects and you can

00:03:01,040 --> 00:03:03,360
think of these objects as a step

00:03:02,720 --> 00:03:05,200
function

00:03:03,360 --> 00:03:07,280
and in fact i'll probably use the term

00:03:05,200 --> 00:03:09,920
stairs object and step function

00:03:07,280 --> 00:03:10,959
interchangeably so we can create a

00:03:09,920 --> 00:03:13,920
stairs object

00:03:10,959 --> 00:03:15,840
like so that was pretty easy wasn't it

00:03:13,920 --> 00:03:18,720
do we have a step function

00:03:15,840 --> 00:03:20,000
yes this step function is defined over

00:03:18,720 --> 00:03:21,280
all the real numbers

00:03:20,000 --> 00:03:23,519
and initially it will have the same

00:03:21,280 --> 00:03:25,920
value everywhere if we were to plot it

00:03:23,519 --> 00:03:27,760
we'd be plotting a horizontal line now

00:03:25,920 --> 00:03:29,599
the default for this initial value

00:03:27,760 --> 00:03:31,120
is zero but you can pass a parameter in

00:03:29,599 --> 00:03:33,440
when creating a stairs object if you

00:03:31,120 --> 00:03:35,840
want to set a different initial value

00:03:33,440 --> 00:03:37,760
now it's not much of a step function if

00:03:35,840 --> 00:03:39,120
there aren't any steps so let's go ahead

00:03:37,760 --> 00:03:43,040
and create one between 1

00:03:39,120 --> 00:03:45,200
and 3 using the layer function

00:03:43,040 --> 00:03:46,799
so what's that done well it's added a

00:03:45,200 --> 00:03:49,440
layer or interval

00:03:46,799 --> 00:03:50,400
of height two between one and three so

00:03:49,440 --> 00:03:52,400
the step function

00:03:50,400 --> 00:03:53,760
starts at x equals negative infinity

00:03:52,400 --> 00:03:55,840
with a value of zero

00:03:53,760 --> 00:03:56,959
and at x equals one it jumps up to a

00:03:55,840 --> 00:03:58,959
value of two

00:03:56,959 --> 00:04:00,319
and at x equals three it jumps back down

00:03:58,959 --> 00:04:03,680
to 0.

00:04:00,319 --> 00:04:05,519
now we can plot this like so but

00:04:03,680 --> 00:04:07,439
the plotting function only plots those

00:04:05,519 --> 00:04:08,560
sections of the step function which have

00:04:07,439 --> 00:04:10,560
a finite length

00:04:08,560 --> 00:04:12,560
so you won't see the function extend off

00:04:10,560 --> 00:04:16,400
to negative or positive infinity

00:04:12,560 --> 00:04:17,600
when you call plot so let's go ahead and

00:04:16,400 --> 00:04:20,560
add another layer in

00:04:17,600 --> 00:04:20,959
let's say between six and ten and this

00:04:20,560 --> 00:04:22,479
time

00:04:20,959 --> 00:04:24,000
we're not going to specify the third

00:04:22,479 --> 00:04:25,919
parameter it's an

00:04:24,000 --> 00:04:28,000
optional parameter which has a default

00:04:25,919 --> 00:04:29,680
of one so if we plot this

00:04:28,000 --> 00:04:31,360
again you can see that we've added this

00:04:29,680 --> 00:04:34,160
interval of height one

00:04:31,360 --> 00:04:35,040
between six and ten and it's been added

00:04:34,160 --> 00:04:38,479
to our existing

00:04:35,040 --> 00:04:40,400
stairs object so we'll now create

00:04:38,479 --> 00:04:43,199
another stairs object we'll call it

00:04:40,400 --> 00:04:43,440
s2 and this time we'll add intervals

00:04:43,199 --> 00:04:46,880
which

00:04:43,440 --> 00:04:50,160
overlap so one between four and seven

00:04:46,880 --> 00:04:52,560
and one between six and eight

00:04:50,160 --> 00:04:53,600
so both intervals have the default

00:04:52,560 --> 00:04:55,520
height of one

00:04:53,600 --> 00:04:57,280
and where they overlap the value of the

00:04:55,520 --> 00:04:58,800
step function is two

00:04:57,280 --> 00:05:00,639
because when adding an interval you are

00:04:58,800 --> 00:05:02,479
adding it to what is already existing

00:05:00,639 --> 00:05:04,000
you are layering it on top of what's

00:05:02,479 --> 00:05:06,400
already there

00:05:04,000 --> 00:05:08,160
and this talk of layering and adding it

00:05:06,400 --> 00:05:10,080
might lead you to wonder if you can only

00:05:08,160 --> 00:05:10,639
have positive interval heights and the

00:05:10,080 --> 00:05:12,960
answer is

00:05:10,639 --> 00:05:14,479
no you can have negative values and they

00:05:12,960 --> 00:05:16,720
can even be fractions

00:05:14,479 --> 00:05:17,919
or it could even be zero for anyone that

00:05:16,720 --> 00:05:18,479
likes to feel like they're doing

00:05:17,919 --> 00:05:20,320
something

00:05:18,479 --> 00:05:22,720
without actually doing anything and we

00:05:20,320 --> 00:05:24,320
all know someone like that

00:05:22,720 --> 00:05:26,080
the next thing i'll demo is adding

00:05:24,320 --> 00:05:27,440
multiple intervals with the one call to

00:05:26,080 --> 00:05:29,520
the layer function

00:05:27,440 --> 00:05:30,720
and i'll use this to recreate this s2

00:05:29,520 --> 00:05:32,960
stairs object

00:05:30,720 --> 00:05:34,560
that we already have but to use the

00:05:32,960 --> 00:05:36,320
layer function in this way you need to

00:05:34,560 --> 00:05:38,560
gather the start points into some sort

00:05:36,320 --> 00:05:41,120
of vector be it a list or a tuple

00:05:38,560 --> 00:05:42,800
or a panda series and you gather

00:05:41,120 --> 00:05:43,919
endpoints into a vector and you pass

00:05:42,800 --> 00:05:45,759
those vectors in

00:05:43,919 --> 00:05:47,440
as the parameters for start points and

00:05:45,759 --> 00:05:49,199
end points

00:05:47,440 --> 00:05:50,880
and when you do this the intervals will

00:05:49,199 --> 00:05:52,479
all get a default height of 1

00:05:50,880 --> 00:05:54,560
unless you also pass in a third

00:05:52,479 --> 00:05:55,280
parameter which would be a vector of

00:05:54,560 --> 00:05:57,199
heights

00:05:55,280 --> 00:05:59,280
and here's a fun fact if all the heights

00:05:57,199 --> 00:06:00,800
are the same then the order of the start

00:05:59,280 --> 00:06:02,160
points doesn't matter

00:06:00,800 --> 00:06:03,919
and the order of the endpoints doesn't

00:06:02,160 --> 00:06:06,080
matter and that can certainly be used to

00:06:03,919 --> 00:06:07,840
your advantage

00:06:06,080 --> 00:06:09,199
now you might notice that when we call

00:06:07,840 --> 00:06:12,400
plot we are getting back

00:06:09,199 --> 00:06:13,600
our matplotlib axes we can then do all

00:06:12,400 --> 00:06:15,600
the things with that axis that

00:06:13,600 --> 00:06:17,759
matplotlib allows us to

00:06:15,600 --> 00:06:20,560
and we can also pass that axis in as a

00:06:17,759 --> 00:06:22,400
parameter into the stairs plot function

00:06:20,560 --> 00:06:24,560
and we use it here to plot both of these

00:06:22,400 --> 00:06:26,560
step functions together

00:06:24,560 --> 00:06:28,160
and any argument that the plot function

00:06:26,560 --> 00:06:30,479
in matplotlib can take

00:06:28,160 --> 00:06:32,960
can also be used with the plot function

00:06:30,479 --> 00:06:36,400
on the stairs object

00:06:32,960 --> 00:06:38,400
so here ends the basics demo and i know

00:06:36,400 --> 00:06:40,160
this might be very sad but that's okay

00:06:38,400 --> 00:06:43,440
the basics demo lives on

00:06:40,160 --> 00:06:45,360
in our minds in our hearts but also in

00:06:43,440 --> 00:06:46,800
the documentation you can see here we've

00:06:45,360 --> 00:06:48,560
got staircase basics

00:06:46,800 --> 00:06:50,319
it goes through and does everything i

00:06:48,560 --> 00:06:51,759
just did but also demonstrates the

00:06:50,319 --> 00:06:54,319
addition of step functions

00:06:51,759 --> 00:06:55,120
subtraction taking the maximum of step

00:06:54,319 --> 00:06:57,120
functions

00:06:55,120 --> 00:06:58,560
uh doing comparisons between functions

00:06:57,120 --> 00:06:59,599
you know where one function might be

00:06:58,560 --> 00:07:02,000
larger than another

00:06:59,599 --> 00:07:03,280
or equal to another and for an even

00:07:02,000 --> 00:07:04,479
further understanding of what you can do

00:07:03,280 --> 00:07:05,919
with these things you can head to the

00:07:04,479 --> 00:07:08,000
api which details

00:07:05,919 --> 00:07:10,080
all the functions all the arithmetic

00:07:08,000 --> 00:07:11,680
operators the relational operators the

00:07:10,080 --> 00:07:14,080
logical operators

00:07:11,680 --> 00:07:15,039
aggregation functions and it'll give you

00:07:14,080 --> 00:07:17,280
little descriptions

00:07:15,039 --> 00:07:18,960
and examples for each of these right so

00:07:17,280 --> 00:07:20,720
now you've graduated from basics

00:07:18,960 --> 00:07:22,639
let's get into the first use case that

00:07:20,720 --> 00:07:24,319
my team and i throw staircase at

00:07:22,639 --> 00:07:25,919
to set the scene we get a maintenance

00:07:24,319 --> 00:07:28,319
schedule for an asset and that

00:07:25,919 --> 00:07:30,000
asset is composed of components it's

00:07:28,319 --> 00:07:31,199
these components which are specified in

00:07:30,000 --> 00:07:32,800
the maintenance schedule

00:07:31,199 --> 00:07:34,479
the maintenance schedule will say this

00:07:32,800 --> 00:07:34,880
component is under maintenance from this

00:07:34,479 --> 00:07:37,919
time

00:07:34,880 --> 00:07:39,919
to this time and if a component is out

00:07:37,919 --> 00:07:40,960
the asset is there and that's all we

00:07:39,919 --> 00:07:42,960
really care about

00:07:40,960 --> 00:07:44,560
we just want to know when is the asset

00:07:42,960 --> 00:07:47,360
under maintenance

00:07:44,560 --> 00:07:48,479
so essentially the problem is to take

00:07:47,360 --> 00:07:49,360
the maintenance intervals for the

00:07:48,479 --> 00:07:50,800
components

00:07:49,360 --> 00:07:53,280
create their union to give us the

00:07:50,800 --> 00:07:55,759
maintenance intervals for the asset

00:07:53,280 --> 00:07:57,599
so let's get into it okay so we'll start

00:07:55,759 --> 00:08:00,560
with some standard imports

00:07:57,599 --> 00:08:02,240
staircase of course and matplotlib and

00:08:00,560 --> 00:08:03,599
behind the scenes i've imported a data

00:08:02,240 --> 00:08:04,720
frame containing our maintenance

00:08:03,599 --> 00:08:07,360
schedule data

00:08:04,720 --> 00:08:08,160
and it looks like this each row

00:08:07,360 --> 00:08:10,000
represents an

00:08:08,160 --> 00:08:12,800
outage or period of maintenance for a

00:08:10,000 --> 00:08:14,560
single sub-component of our asset

00:08:12,800 --> 00:08:16,319
now if we were to look at the first five

00:08:14,560 --> 00:08:17,199
rows here it's maintenance that is

00:08:16,319 --> 00:08:19,520
spanning the 12th

00:08:17,199 --> 00:08:21,039
13th 14th of january and if we were to

00:08:19,520 --> 00:08:24,319
visualize these first five

00:08:21,039 --> 00:08:26,560
maintenance jobs they look like this

00:08:24,319 --> 00:08:28,240
so each subcomponent has an interval of

00:08:26,560 --> 00:08:30,000
time that it is not available

00:08:28,240 --> 00:08:31,440
and remember we want to get the union of

00:08:30,000 --> 00:08:33,680
these intervals to arrive at a

00:08:31,440 --> 00:08:35,760
maintenance interval at the asset level

00:08:33,680 --> 00:08:41,760
and for this example that would look

00:08:35,760 --> 00:08:44,159
like this

00:08:41,760 --> 00:08:45,760
so how do we solve this problem using

00:08:44,159 --> 00:08:47,360
staircase

00:08:45,760 --> 00:08:49,279
well we're going to need to start with

00:08:47,360 --> 00:08:51,839
the stairs object which

00:08:49,279 --> 00:08:53,120
will be initially zero valued everywhere

00:08:51,839 --> 00:08:53,680
but i'm also going to pass in a

00:08:53,120 --> 00:08:57,279
parameter

00:08:53,680 --> 00:08:59,680
called use dates now if not specified

00:08:57,279 --> 00:09:00,959
this parameter defaults to false but

00:08:59,680 --> 00:09:02,800
when specified true

00:09:00,959 --> 00:09:04,080
it tells the stairs object that we're

00:09:02,800 --> 00:09:05,839
going to be working with pandas

00:09:04,080 --> 00:09:07,839
timestamps

00:09:05,839 --> 00:09:08,880
that is the step function will be a

00:09:07,839 --> 00:09:12,800
function defined

00:09:08,880 --> 00:09:14,720
over time now here comes the fun bit

00:09:12,800 --> 00:09:16,320
remember with the layer function the

00:09:14,720 --> 00:09:19,040
parameters are start

00:09:16,320 --> 00:09:20,560
end and optionally a value but these

00:09:19,040 --> 00:09:23,200
parameters can be vectors

00:09:20,560 --> 00:09:25,040
so array like objects which means we can

00:09:23,200 --> 00:09:28,240
dump in those columns in our data frame

00:09:25,040 --> 00:09:31,519
labeled start and end like so

00:09:28,240 --> 00:09:31,519
and we've got our step function

00:09:31,760 --> 00:09:35,120
now let's create a larger axis to plot

00:09:34,800 --> 00:09:38,720
on

00:09:35,120 --> 00:09:38,720
and repeat so we can see it clearer

00:09:39,360 --> 00:09:44,320
so this step function is a count of

00:09:42,080 --> 00:09:47,680
components under maintenance

00:09:44,320 --> 00:09:49,760
over time now we're only interested in

00:09:47,680 --> 00:09:52,640
those parts where the step function

00:09:49,760 --> 00:09:52,640
is not zero

00:09:52,959 --> 00:09:57,920
so what's this using this

00:09:56,160 --> 00:10:00,320
relational operator to make this

00:09:57,920 --> 00:10:01,279
comparison has given back another stairs

00:10:00,320 --> 00:10:03,120
object

00:10:01,279 --> 00:10:05,200
and if we plot it on the same graph

00:10:03,120 --> 00:10:07,360
above then we can see it's a step

00:10:05,200 --> 00:10:10,160
function which is boolean valued

00:10:07,360 --> 00:10:10,959
zero or one in fact we could have used a

00:10:10,160 --> 00:10:13,760
function called

00:10:10,959 --> 00:10:15,760
make boolean to create the same thing it

00:10:13,760 --> 00:10:19,279
will snap any non-zero value of that

00:10:15,760 --> 00:10:21,440
step function to a value of one

00:10:19,279 --> 00:10:22,399
so that's the calculation done all that

00:10:21,440 --> 00:10:24,240
we need to do now

00:10:22,399 --> 00:10:26,399
is extract the information out of our

00:10:24,240 --> 00:10:27,360
stairs object and we can do that using a

00:10:26,399 --> 00:10:30,160
function called

00:10:27,360 --> 00:10:32,240
two data frame and what that does is

00:10:30,160 --> 00:10:35,120
give us the endpoints and the values

00:10:32,240 --> 00:10:36,800
for each segment of our stat function

00:10:35,120 --> 00:10:38,320
but we're only really interested in

00:10:36,800 --> 00:10:40,959
those parts of the step function

00:10:38,320 --> 00:10:41,600
which have a value of one so we can

00:10:40,959 --> 00:10:44,320
filter

00:10:41,600 --> 00:10:46,480
using the query function of data frames

00:10:44,320 --> 00:10:48,560
and here's the data we need

00:10:46,480 --> 00:10:50,640
we can write it out to csv if that's

00:10:48,560 --> 00:10:52,160
what we need to do

00:10:50,640 --> 00:10:54,000
so we're already on to our second use

00:10:52,160 --> 00:10:55,040
case in this next one we'll be looking

00:10:54,000 --> 00:10:56,959
at queue analysis

00:10:55,040 --> 00:10:59,360
and again relying on data that is time

00:10:56,959 --> 00:11:00,880
stamped these timestamps are values

00:10:59,360 --> 00:11:03,279
at which time something has changed

00:11:00,880 --> 00:11:05,440
state or a variable has changed value

00:11:03,279 --> 00:11:06,959
in the context of cues this variable is

00:11:05,440 --> 00:11:08,640
the size of the queue

00:11:06,959 --> 00:11:10,640
a real world example that my team works

00:11:08,640 --> 00:11:12,720
with a lot is vessel queues

00:11:10,640 --> 00:11:14,560
a vessel arrives offshore at which point

00:11:12,720 --> 00:11:16,399
it enters the queue it waits

00:11:14,560 --> 00:11:18,079
until it can enter the harbour at which

00:11:16,399 --> 00:11:20,880
point it leaves the queue

00:11:18,079 --> 00:11:22,240
so let's see how it's done so again

00:11:20,880 --> 00:11:24,000
we're starting with some standard

00:11:22,240 --> 00:11:26,800
imports and i've already loaded a data

00:11:24,000 --> 00:11:29,760
frame into memory which looks like this

00:11:26,800 --> 00:11:31,440
at each row corresponds to a vessel the

00:11:29,760 --> 00:11:32,399
enter column tells us when the vessel

00:11:31,440 --> 00:11:33,839
entered the queue

00:11:32,399 --> 00:11:35,760
and the leave column tells us when the

00:11:33,839 --> 00:11:38,000
vessel left the queue

00:11:35,760 --> 00:11:39,519
the tons that tells us the size of the

00:11:38,000 --> 00:11:41,200
cargo which is being loaded onto the

00:11:39,519 --> 00:11:43,440
ships

00:11:41,200 --> 00:11:44,640
now i'm only interested in the queue for

00:11:43,440 --> 00:11:46,800
the year 2020

00:11:44,640 --> 00:11:49,440
and yes i know we're still in 2020 but

00:11:46,800 --> 00:11:52,000
we can thank marty mcfly for the data

00:11:49,440 --> 00:11:52,480
so if the vessel was in the queue at any

00:11:52,000 --> 00:11:54,880
point

00:11:52,480 --> 00:11:57,440
in 2020 then it needs to be in the data

00:11:54,880 --> 00:12:00,560
set for this approach to work

00:11:57,440 --> 00:12:03,040
speaking of which what is the approach

00:12:00,560 --> 00:12:04,959
so let's go ahead and create a stairs

00:12:03,040 --> 00:12:07,600
object for our queue

00:12:04,959 --> 00:12:09,120
we're going to be using dates and we can

00:12:07,600 --> 00:12:11,120
use the layer function

00:12:09,120 --> 00:12:12,639
and pass the endpoints of our intervals

00:12:11,120 --> 00:12:14,639
in that is

00:12:12,639 --> 00:12:16,399
the vector of enter times and the vector

00:12:14,639 --> 00:12:19,760
of leave times

00:12:16,399 --> 00:12:22,880
and now we plot so there we are

00:12:19,760 --> 00:12:24,480
that's the vessel queue over 2020 and

00:12:22,880 --> 00:12:26,720
using functionality in the staircase

00:12:24,480 --> 00:12:29,040
package we can answer questions like

00:12:26,720 --> 00:12:30,800
what is the maximum queue size what is

00:12:29,040 --> 00:12:32,560
the median queue size

00:12:30,800 --> 00:12:34,639
what fraction of the year is the queue

00:12:32,560 --> 00:12:36,240
greater than say 15

00:12:34,639 --> 00:12:37,680
what times during the year is the queue

00:12:36,240 --> 00:12:40,560
greater than 15.

00:12:37,680 --> 00:12:41,760
what is the average queue size per month

00:12:40,560 --> 00:12:43,760
these are all things which are

00:12:41,760 --> 00:12:45,680
relatively trivial to calculate with

00:12:43,760 --> 00:12:47,519
staircase

00:12:45,680 --> 00:12:48,880
but for the moment i want to stay on the

00:12:47,519 --> 00:12:52,800
topic of creating

00:12:48,880 --> 00:12:56,800
q step functions in addition to vessel q

00:12:52,800 --> 00:12:58,720
my team also looks at vessel q in tons

00:12:56,800 --> 00:12:59,839
this is where the value of the q at any

00:12:58,720 --> 00:13:01,200
point in time

00:12:59,839 --> 00:13:03,839
is not the number of vessels in the

00:13:01,200 --> 00:13:06,800
queue but the total weight of the cargo

00:13:03,839 --> 00:13:08,320
destined for the vessels in the queue so

00:13:06,800 --> 00:13:10,399
this is where the third

00:13:08,320 --> 00:13:12,079
optional parameter in the layer function

00:13:10,399 --> 00:13:14,079
comes in handy

00:13:12,079 --> 00:13:15,120
if we refer back to the first row of our

00:13:14,079 --> 00:13:17,760
data frame

00:13:15,120 --> 00:13:19,360
we want our step function to increase at

00:13:17,760 --> 00:13:22,720
5 23 pm

00:13:19,360 --> 00:13:25,760
on the 29th of december 2019

00:13:22,720 --> 00:13:28,560
and we want it to decrease at 4 40 a.m

00:13:25,760 --> 00:13:30,079
on the first day of 2020 but we want it

00:13:28,560 --> 00:13:35,360
to increase and decrease

00:13:30,079 --> 00:13:39,120
at those points by 129 000 tons

00:13:35,360 --> 00:13:39,920
so we get this by passing in the tons

00:13:39,120 --> 00:13:41,920
column

00:13:39,920 --> 00:13:44,320
as the third parameter to the layer

00:13:41,920 --> 00:13:44,320
function

00:13:45,760 --> 00:13:49,839
there's our vessel queue in tons

00:13:49,920 --> 00:13:54,240
now this chart is pretty noisy and we

00:13:52,880 --> 00:13:56,639
typically look to plot

00:13:54,240 --> 00:13:58,000
the daily average of the vessel q in

00:13:56,639 --> 00:14:00,399
turns

00:13:58,000 --> 00:14:02,800
and that's not so hard to do the stairs

00:14:00,399 --> 00:14:05,440
class has a function called mean

00:14:02,800 --> 00:14:06,240
and it calculates exactly that

00:14:05,440 --> 00:14:07,760
parameters

00:14:06,240 --> 00:14:09,600
are optional to this function but it's

00:14:07,760 --> 00:14:10,240
wise to specify the endpoints of the

00:14:09,600 --> 00:14:13,040
range

00:14:10,240 --> 00:14:14,160
that you want to calculate the mean over

00:14:13,040 --> 00:14:16,720
for example

00:14:14,160 --> 00:14:20,160
for the first day of 2020 the boundaries

00:14:16,720 --> 00:14:23,360
are given by these timestamps here

00:14:20,160 --> 00:14:26,639
and if we use those as parameters to q

00:14:23,360 --> 00:14:27,680
dot mean then we get the average q tons

00:14:26,639 --> 00:14:32,320
for the first day

00:14:27,680 --> 00:14:34,560
in 2020. so to get daily average

00:14:32,320 --> 00:14:37,040
we can create a date range for 2020

00:14:34,560 --> 00:14:40,240
using pandas

00:14:37,040 --> 00:14:42,720
and then this snippet of code here

00:14:40,240 --> 00:14:44,320
this will create a series indexed by

00:14:42,720 --> 00:14:46,079
every day in 2020

00:14:44,320 --> 00:14:47,440
and the data is being created using a

00:14:46,079 --> 00:14:49,279
list comprehension

00:14:47,440 --> 00:14:51,120
and it goes through and calculates the

00:14:49,279 --> 00:14:54,639
mean for each of those days

00:14:51,120 --> 00:14:56,480
with the help of python zip function

00:14:54,639 --> 00:14:58,079
and that's all there is to it you can

00:14:56,480 --> 00:14:59,120
use the plot function that comes with

00:14:58,079 --> 00:15:01,040
pandas series

00:14:59,120 --> 00:15:02,720
or you can use the data with matplotlib

00:15:01,040 --> 00:15:04,480
or seaborn to jazz it up

00:15:02,720 --> 00:15:05,519
so in that last use case i mentioned

00:15:04,480 --> 00:15:06,800
that there are some interesting

00:15:05,519 --> 00:15:07,920
questions that can be answered with the

00:15:06,800 --> 00:15:09,519
staircase package

00:15:07,920 --> 00:15:11,680
but we stopped short of actually taking

00:15:09,519 --> 00:15:12,720
them on in this next one we'll go a

00:15:11,680 --> 00:15:15,040
little bit further

00:15:12,720 --> 00:15:16,880
and flex a bit of staircase muscle we'll

00:15:15,040 --> 00:15:19,279
be looking at asset utilization

00:15:16,880 --> 00:15:20,000
we'll have a group of three assets x y

00:15:19,279 --> 00:15:21,920
and z

00:15:20,000 --> 00:15:23,279
which can be in a state of on or off

00:15:21,920 --> 00:15:25,760
used or not used

00:15:23,279 --> 00:15:26,800
working or not working think bays in a

00:15:25,760 --> 00:15:29,519
car wash

00:15:26,800 --> 00:15:30,880
or hot plates on a stove perhaps poor to

00:15:29,519 --> 00:15:32,560
lose at a festival

00:15:30,880 --> 00:15:35,040
although if there's only three portals

00:15:32,560 --> 00:15:37,360
at a festival i'd give it a mess

00:15:35,040 --> 00:15:39,600
so once again we've got some imports and

00:15:37,360 --> 00:15:41,440
a data frame which looks like this

00:15:39,600 --> 00:15:42,639
so each round the data frame corresponds

00:15:41,440 --> 00:15:45,120
to an interval of time

00:15:42,639 --> 00:15:46,240
that the asset is being used so really

00:15:45,120 --> 00:15:47,440
it's not that different from the

00:15:46,240 --> 00:15:49,279
maintenance data that we saw in the

00:15:47,440 --> 00:15:51,199
first use case

00:15:49,279 --> 00:15:52,959
now we'll aim to get a stairs object for

00:15:51,199 --> 00:15:54,480
each of our three assets

00:15:52,959 --> 00:15:56,320
and i think if i was to give you a

00:15:54,480 --> 00:15:58,320
separate data frame for each asset

00:15:56,320 --> 00:15:59,759
you would know how to do that

00:15:58,320 --> 00:16:00,240
essentially that's what we're going to

00:15:59,759 --> 00:16:01,759
do

00:16:00,240 --> 00:16:04,079
but we're going to use the data frame

00:16:01,759 --> 00:16:06,800
group by function to do it

00:16:04,079 --> 00:16:08,000
so we'll start with that data frame

00:16:06,800 --> 00:16:10,800
group by the asset

00:16:08,000 --> 00:16:12,880
variable and apply a function which

00:16:10,800 --> 00:16:16,639
creates a stairs object

00:16:12,880 --> 00:16:17,920
and we'll call that function make stairs

00:16:16,639 --> 00:16:20,079
and i suppose we better go ahead and

00:16:17,920 --> 00:16:22,560
define it so this function

00:16:20,079 --> 00:16:23,759
will take a parameter d and d will be a

00:16:22,560 --> 00:16:25,920
data frame

00:16:23,759 --> 00:16:28,000
and it will create a stairs object using

00:16:25,920 --> 00:16:30,639
the pattern that you are familiar with

00:16:28,000 --> 00:16:32,079
and then we'll return it so if we

00:16:30,639 --> 00:16:35,120
execute this cell

00:16:32,079 --> 00:16:38,639
we get a series index by asset name

00:16:35,120 --> 00:16:40,240
where the values are stairs objects

00:16:38,639 --> 00:16:42,399
now if i want to plot the step function

00:16:40,240 --> 00:16:46,160
for the utilization of asset x

00:16:42,399 --> 00:16:48,560
then i can do so like this however

00:16:46,160 --> 00:16:50,399
it's a pretty noisy chart looks like

00:16:48,560 --> 00:16:51,040
there's a lot of transitions between one

00:16:50,399 --> 00:16:52,480
and zero

00:16:51,040 --> 00:16:54,079
which corresponds to on and off

00:16:52,480 --> 00:16:56,800
respectively

00:16:54,079 --> 00:16:58,720
so let's zoom in on day one of 2020 by

00:16:56,800 --> 00:16:59,440
capturing the axes returned by the plot

00:16:58,720 --> 00:17:03,040
function

00:16:59,440 --> 00:17:05,199
and setting limits on the x-axis

00:17:03,040 --> 00:17:07,039
and you can see there we might expect to

00:17:05,199 --> 00:17:09,039
switch between zero and one

00:17:07,039 --> 00:17:10,079
many times per day and this is why we

00:17:09,039 --> 00:17:13,520
see a wall of blue

00:17:10,079 --> 00:17:13,520
when we plot the entire year

00:17:13,919 --> 00:17:17,360
now given these assets belong to a group

00:17:16,079 --> 00:17:18,480
we might be interested in the

00:17:17,360 --> 00:17:20,559
utilization

00:17:18,480 --> 00:17:22,400
of the group and that would correspond

00:17:20,559 --> 00:17:23,199
to a step function which is derived by

00:17:22,400 --> 00:17:26,240
adding together

00:17:23,199 --> 00:17:27,600
the stairs objects in our series and we

00:17:26,240 --> 00:17:30,799
can do that using

00:17:27,600 --> 00:17:32,799
the series sum function

00:17:30,799 --> 00:17:34,559
so what it's done there is use the

00:17:32,799 --> 00:17:35,600
addition operator which is defined in

00:17:34,559 --> 00:17:37,679
the stairs class

00:17:35,600 --> 00:17:39,360
which is a binary operator and used it

00:17:37,679 --> 00:17:42,640
to sum the entire series

00:17:39,360 --> 00:17:44,000
which is pretty cool now we can assign

00:17:42,640 --> 00:17:46,799
this result to a variable

00:17:44,000 --> 00:17:48,000
which i'll call s some because i lack

00:17:46,799 --> 00:17:50,480
imagination

00:17:48,000 --> 00:17:51,520
and will answer the question of how many

00:17:50,480 --> 00:17:55,440
hours in total

00:17:51,520 --> 00:17:55,440
has the group spent being used

00:17:55,679 --> 00:17:59,440
and you might say nobody has asked for

00:17:57,679 --> 00:18:00,080
that but nobody asks for this

00:17:59,440 --> 00:18:04,240
presentation

00:18:00,080 --> 00:18:06,240
either so the answer is given by the

00:18:04,240 --> 00:18:08,240
area under the function

00:18:06,240 --> 00:18:09,760
which we can get by calling integrate on

00:18:08,240 --> 00:18:11,840
this stairs object

00:18:09,760 --> 00:18:14,160
which when using dates returns the

00:18:11,840 --> 00:18:16,000
result in hours

00:18:14,160 --> 00:18:17,840
now when we call integrate under the

00:18:16,000 --> 00:18:18,799
hood it'll break the area up into

00:18:17,840 --> 00:18:20,400
rectangles

00:18:18,799 --> 00:18:22,160
but it won't consider rectangles of

00:18:20,400 --> 00:18:23,600
infinite area and that's what you'll

00:18:22,160 --> 00:18:26,000
have if your step function

00:18:23,600 --> 00:18:27,520
isn't zero at both negative infinity and

00:18:26,000 --> 00:18:29,039
positive infinity

00:18:27,520 --> 00:18:30,640
and this has the potential to trip you

00:18:29,039 --> 00:18:32,160
up which is why it's a good idea

00:18:30,640 --> 00:18:35,840
to provide the range over which you want

00:18:32,160 --> 00:18:38,400
to calculate just in case

00:18:35,840 --> 00:18:40,440
so we can see there we have a total of

00:18:38,400 --> 00:18:43,200
00:18:40,440 --> 00:18:43,760
176.7 hours of work by this group of

00:18:43,200 --> 00:18:46,960
assets

00:18:43,760 --> 00:18:48,640
over the year 2020 and if we change the

00:18:46,960 --> 00:18:50,400
integrate function to mean

00:18:48,640 --> 00:18:52,400
then we get the average utilization of

00:18:50,400 --> 00:18:53,200
the group expressed as a number of

00:18:52,400 --> 00:18:55,760
assets

00:18:53,200 --> 00:18:58,080
so on average half of our three assets

00:18:55,760 --> 00:19:00,240
are being used

00:18:58,080 --> 00:19:02,240
what if we want to know how often none

00:19:00,240 --> 00:19:04,160
of our assets are being used

00:19:02,240 --> 00:19:06,559
we can do that using the equality

00:19:04,160 --> 00:19:10,240
operator which will give a binary valued

00:19:06,559 --> 00:19:13,520
step function

00:19:10,240 --> 00:19:15,520
calculating the mean tells us that 13.67

00:19:13,520 --> 00:19:17,440
of the time none of our assets were

00:19:15,520 --> 00:19:19,440
being used

00:19:17,440 --> 00:19:21,120
you might want to know how often exactly

00:19:19,440 --> 00:19:24,320
one asset is being used

00:19:21,120 --> 00:19:26,960
or two assets are being used and so on

00:19:24,320 --> 00:19:28,320
and we can take the calculation above

00:19:26,960 --> 00:19:32,000
generalize it

00:19:28,320 --> 00:19:34,320
using this variable i and put this

00:19:32,000 --> 00:19:37,440
all inside a list comprehension which

00:19:34,320 --> 00:19:39,600
then lives inside a panda series

00:19:37,440 --> 00:19:40,880
and we'll name this series u for

00:19:39,600 --> 00:19:43,600
utilization

00:19:40,880 --> 00:19:43,600
and execute

00:19:44,080 --> 00:19:48,240
so now we have the fraction of time that

00:19:46,559 --> 00:19:50,240
our group has spent in each of these

00:19:48,240 --> 00:19:52,160
utilization states

00:19:50,240 --> 00:19:54,320
and if i sum them up you can see that it

00:19:52,160 --> 00:19:57,760
adds to one which gives you confidence

00:19:54,320 --> 00:19:57,760
that the calculation is correct

00:19:57,919 --> 00:20:01,840
and why not plot this data using series

00:20:00,000 --> 00:20:04,640
plotting functions to get a quick visual

00:20:01,840 --> 00:20:04,640
of what's going on

00:20:05,200 --> 00:20:09,600
now let's answer some random questions

00:20:06,960 --> 00:20:12,080
for the sake of answering questions

00:20:09,600 --> 00:20:12,640
what percentage of time is asset x

00:20:12,080 --> 00:20:16,240
working

00:20:12,640 --> 00:20:19,039
while asset y is not the answer is

00:20:16,240 --> 00:20:21,440
approximately 25 percent

00:20:19,039 --> 00:20:23,200
how many assets were being used at 10 40

00:20:21,440 --> 00:20:27,520
am on the 5th of september

00:20:23,200 --> 00:20:30,000
2020 the answer is two

00:20:27,520 --> 00:20:32,880
instead of utilization can we reframe it

00:20:30,000 --> 00:20:35,520
in terms of non-utilization or idleness

00:20:32,880 --> 00:20:37,120
sure we have three machines so we start

00:20:35,520 --> 00:20:38,000
with a step function that has a value of

00:20:37,120 --> 00:20:39,679
three everywhere

00:20:38,000 --> 00:20:41,360
and subtract our utilization step

00:20:39,679 --> 00:20:43,360
function

00:20:41,360 --> 00:20:44,640
can we plot the daily mean utilization

00:20:43,360 --> 00:20:47,280
as a time series

00:20:44,640 --> 00:20:49,520
yes would you be out of bed yet probably

00:20:47,280 --> 00:20:51,840
not what fraction of time was either

00:20:49,520 --> 00:20:53,520
asset x or y being used but not both at

00:20:51,840 --> 00:20:53,919
the same time and can we express this as

00:20:53,520 --> 00:20:55,760
a time

00:20:53,919 --> 00:20:57,520
series but also include monthly averages

00:20:55,760 --> 00:21:00,480
and plus okay

00:20:57,520 --> 00:21:01,120
one last use case we're almost there so

00:21:00,480 --> 00:21:03,440
this one

00:21:01,120 --> 00:21:04,640
uses data associated with edges in a

00:21:03,440 --> 00:21:07,600
state diagram

00:21:04,640 --> 00:21:08,320
so what's a state diagram a state

00:21:07,600 --> 00:21:10,559
diagram

00:21:08,320 --> 00:21:12,559
describes the behavior of a system it is

00:21:10,559 --> 00:21:14,320
essentially a graph with directed edges

00:21:12,559 --> 00:21:16,080
where nodes in the graph correspond to

00:21:14,320 --> 00:21:16,720
states that the system can be in and

00:21:16,080 --> 00:21:18,559
edges

00:21:16,720 --> 00:21:20,000
represent the transition from one state

00:21:18,559 --> 00:21:21,840
to another if an

00:21:20,000 --> 00:21:23,679
edge does not exist between two states

00:21:21,840 --> 00:21:25,620
then it is not possible to move between

00:21:23,679 --> 00:21:26,380
those states

00:21:25,620 --> 00:21:28,400
[Applause]

00:21:26,380 --> 00:21:30,559
[Music]

00:21:28,400 --> 00:21:32,000
so the data could be inputs to a finite

00:21:30,559 --> 00:21:34,640
state machine or perhaps

00:21:32,000 --> 00:21:36,480
outputs of a markov chain for my team

00:21:34,640 --> 00:21:38,559
it's outputs of a simulation model

00:21:36,480 --> 00:21:40,320
which simulates the movement of an asset

00:21:38,559 --> 00:21:43,280
through different states

00:21:40,320 --> 00:21:44,080
operating state breakdown state idle

00:21:43,280 --> 00:21:46,799
stake

00:21:44,080 --> 00:21:48,320
maintenance state every time an event

00:21:46,799 --> 00:21:50,000
happens in the simulation model

00:21:48,320 --> 00:21:51,919
which triggers a transition between

00:21:50,000 --> 00:21:53,440
states it's logged

00:21:51,919 --> 00:21:55,360
so now i'll show you how we can use

00:21:53,440 --> 00:21:56,000
staircase to measure the time spent in

00:21:55,360 --> 00:21:57,679
each state

00:21:56,000 --> 00:22:00,640
without having to write code which

00:21:57,679 --> 00:22:02,240
encapsulates a state diagram

00:22:00,640 --> 00:22:04,080
so yet again we'll start with some

00:22:02,240 --> 00:22:06,240
imports and a data frame

00:22:04,080 --> 00:22:07,200
a data frame details the time at which

00:22:06,240 --> 00:22:08,799
events happen

00:22:07,200 --> 00:22:11,360
and those events trigger changes in

00:22:08,799 --> 00:22:13,520
state in the pictured state diagram

00:22:11,360 --> 00:22:15,760
we'll also assume that we start in state

00:22:13,520 --> 00:22:19,280
a at time 0.

00:22:15,760 --> 00:22:22,080
the first event w at time 14.5

00:22:19,280 --> 00:22:23,919
triggers a transition from state a to b

00:22:22,080 --> 00:22:26,240
then at time 14.7

00:22:23,919 --> 00:22:27,440
we return to state a triggered by event

00:22:26,240 --> 00:22:30,480
x

00:22:27,440 --> 00:22:32,960
we repeat these two moves at time 32.8

00:22:30,480 --> 00:22:34,320
and 40.9 respectively before

00:22:32,960 --> 00:22:37,919
transitioning to state c

00:22:34,320 --> 00:22:40,240
at time 55. you get the idea

00:22:37,919 --> 00:22:41,280
now the challenge is that events w and x

00:22:40,240 --> 00:22:45,120
cause transitions

00:22:41,280 --> 00:22:46,960
between states a and b but also c and d

00:22:45,120 --> 00:22:48,559
so when encountering these events you

00:22:46,960 --> 00:22:51,200
won't know what state you move to

00:22:48,559 --> 00:22:52,640
without knowing what state you're in so

00:22:51,200 --> 00:22:53,919
this is where you may be tempted to try

00:22:52,640 --> 00:22:55,120
and approach using the data frame

00:22:53,919 --> 00:22:56,960
itero's function

00:22:55,120 --> 00:22:58,559
consuming the events one by one and

00:22:56,960 --> 00:22:59,360
keeping track of a current state and

00:22:58,559 --> 00:23:01,200
time

00:22:59,360 --> 00:23:02,720
but i suspect that won't be that fast so

00:23:01,200 --> 00:23:04,159
i'm not going to do that

00:23:02,720 --> 00:23:06,320
what we're going to do is create a

00:23:04,159 --> 00:23:07,600
stairs object to represent a compound

00:23:06,320 --> 00:23:11,520
state a b

00:23:07,600 --> 00:23:13,440
meaning in state a or b

00:23:11,520 --> 00:23:14,880
the entering of this compound state is

00:23:13,440 --> 00:23:16,960
triggered by event q

00:23:14,880 --> 00:23:17,919
and the departure is triggered by event

00:23:16,960 --> 00:23:19,760
p

00:23:17,919 --> 00:23:21,760
so we filter out these events and create

00:23:19,760 --> 00:23:24,080
our step function for the compound state

00:23:21,760 --> 00:23:26,240
like so

00:23:24,080 --> 00:23:27,280
note the first layer method is needed to

00:23:26,240 --> 00:23:31,120
recognize the fact

00:23:27,280 --> 00:23:33,360
that a is the initial state at time zero

00:23:31,120 --> 00:23:35,280
likewise we create one for the compound

00:23:33,360 --> 00:23:39,200
state cd

00:23:35,280 --> 00:23:39,200
and for the compound state bd

00:23:39,520 --> 00:23:42,960
so now for the fun part if our step

00:23:41,840 --> 00:23:45,440
function for a b

00:23:42,960 --> 00:23:47,200
equals one then we're in state a or b

00:23:45,440 --> 00:23:50,880
and if our step function for b

00:23:47,200 --> 00:23:53,039
d equals one then we're in state b or d

00:23:50,880 --> 00:23:53,919
so wherever these step functions both

00:23:53,039 --> 00:23:57,120
equal 1

00:23:53,919 --> 00:23:58,640
we must be in state b which means we can

00:23:57,120 --> 00:24:01,760
obtain a step function for b

00:23:58,640 --> 00:24:02,480
by multiplying a b and b d together and

00:24:01,760 --> 00:24:05,120
staircase

00:24:02,480 --> 00:24:06,880
makes this calculation trivial and of

00:24:05,120 --> 00:24:07,440
course if we're in the compound state a

00:24:06,880 --> 00:24:09,679
b

00:24:07,440 --> 00:24:10,640
but not in state b then we must be in

00:24:09,679 --> 00:24:12,320
state a

00:24:10,640 --> 00:24:14,159
so the step function for a can be

00:24:12,320 --> 00:24:16,960
obtained by subtracting b

00:24:14,159 --> 00:24:19,600
from a b we can then take the same

00:24:16,960 --> 00:24:23,520
approach to derive step functions for c

00:24:19,600 --> 00:24:24,320
and d finally the time spent in each

00:24:23,520 --> 00:24:26,159
state

00:24:24,320 --> 00:24:27,760
or the fraction of total time spent in

00:24:26,159 --> 00:24:29,279
each state can be found using the

00:24:27,760 --> 00:24:30,159
integrate and mean functions

00:24:29,279 --> 00:24:33,440
respectively

00:24:30,159 --> 00:24:34,880
that we saw in the last use case so that

00:24:33,440 --> 00:24:37,200
wraps up the presentation

00:24:34,880 --> 00:24:38,480
thanks for joining me don't forget check

00:24:37,200 --> 00:24:39,679
out the documentation if you want to

00:24:38,480 --> 00:24:41,520
explore further

00:24:39,679 --> 00:24:42,720
and move over snakes and letters i'm

00:24:41,520 --> 00:24:47,840
hoping you've learned enough

00:24:42,720 --> 00:24:47,840

YouTube URL: https://www.youtube.com/watch?v=CS1dZ-01b-Q


