Title: Try A Little Randomness by Larry Hastings
Publication date: 2014-08-05
Playlist: PyCon Australia 2014
Description: 
	This talk is all about random numbers--What are they? What different kinds are there?  What are they useful for?  And why are computers really bad at them?  Come learn all about random numbers, both the good and the bad.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:09,019 --> 00:00:15,299
randomness with Larry Hastings larry has

00:00:12,360 --> 00:00:18,000
been a user of and contributed to python

00:00:15,299 --> 00:00:19,769
since the late 90s he is a Python core

00:00:18,000 --> 00:00:29,460
developer and is the release manager for

00:00:19,769 --> 00:00:32,070
Python 3.4 and 3.50 Valera okay so this

00:00:29,460 --> 00:00:34,050
is try a little randomness it's a sort

00:00:32,070 --> 00:00:36,780
of an intro one-on-one course to random

00:00:34,050 --> 00:00:39,330
numbers and computer science so what are

00:00:36,780 --> 00:00:41,610
random numbers I expect most of us have

00:00:39,330 --> 00:00:42,660
a basic idea of what a random number is

00:00:41,610 --> 00:00:44,850
but if I was going to be a little bit

00:00:42,660 --> 00:00:47,520
more precise I would say a random number

00:00:44,850 --> 00:00:49,550
is a number of produced on request from

00:00:47,520 --> 00:00:53,870
a specific range so it's always bounded

00:00:49,550 --> 00:00:55,650
and which cannot be predicted in advance

00:00:53,870 --> 00:00:57,090
random numbers are produced through

00:00:55,650 --> 00:00:58,890
what's called a non deterministic

00:00:57,090 --> 00:01:01,500
process this is sort of topological

00:00:58,890 --> 00:01:03,660
because determinism is the opposite of

00:01:01,500 --> 00:01:05,939
randomness so you produce random numbers

00:01:03,660 --> 00:01:07,380
through a random process therefore is by

00:01:05,939 --> 00:01:09,180
definition a non deterministic process

00:01:07,380 --> 00:01:10,230
the reason I draw attention to this is

00:01:09,180 --> 00:01:12,930
because I'm going to it's going to come

00:01:10,230 --> 00:01:14,570
up in a bit so what use are random

00:01:12,930 --> 00:01:16,620
members what would you use one for well

00:01:14,570 --> 00:01:18,330
often they're used in simulations

00:01:16,620 --> 00:01:21,240
particular what's called the Monte Carlo

00:01:18,330 --> 00:01:25,020
simulation which is a simulation of some

00:01:21,240 --> 00:01:26,930
real process where the data that you're

00:01:25,020 --> 00:01:29,190
using to simulate whatever process it is

00:01:26,930 --> 00:01:30,960
you're simulating using random numbers

00:01:29,190 --> 00:01:32,430
so some examples of that and this is

00:01:30,960 --> 00:01:35,280
used all over the place the simulation

00:01:32,430 --> 00:01:37,380
just side a couple it's used in weather

00:01:35,280 --> 00:01:39,170
simulations to figure out what the

00:01:37,380 --> 00:01:41,490
weather is going to be like in a week

00:01:39,170 --> 00:01:42,900
people use it for similarly physics

00:01:41,490 --> 00:01:45,990
everything from simulated nuclear

00:01:42,900 --> 00:01:49,950
explosions to microcrystal fact

00:01:45,990 --> 00:01:52,400
fractures and it's used in economics to

00:01:49,950 --> 00:01:56,100
simulate the behavior of crowds and

00:01:52,400 --> 00:01:58,640
populations my favorite variety of

00:01:56,100 --> 00:02:00,869
simulation is what's called a video game

00:01:58,640 --> 00:02:03,720
if you think about a video games really

00:02:00,869 --> 00:02:05,430
just our simulations and so you would

00:02:03,720 --> 00:02:07,409
use random numbers for gambling

00:02:05,430 --> 00:02:08,879
simulations but really just about any

00:02:07,409 --> 00:02:10,140
video game is going to use random

00:02:08,879 --> 00:02:12,000
numbers like for instance if you had a

00:02:10,140 --> 00:02:14,459
grunt and you're going to shoot at them

00:02:12,000 --> 00:02:15,840
and he wants to dodge whether he dodges

00:02:14,459 --> 00:02:18,120
or not and whether he dodges left to

00:02:15,840 --> 00:02:19,050
right that's probably decided with at

00:02:18,120 --> 00:02:21,120
least a little bit of random

00:02:19,050 --> 00:02:24,330
numbers in it so how do you get yourself

00:02:21,120 --> 00:02:26,190
a random number well the usual way is

00:02:24,330 --> 00:02:27,960
with an unpredictable physical process

00:02:26,190 --> 00:02:30,420
basically anything you would ever think

00:02:27,960 --> 00:02:33,330
about betting on so rolling a die

00:02:30,420 --> 00:02:35,870
flipping a coin spinning a wheel picking

00:02:33,330 --> 00:02:38,280
a shuffled card or betting on a horse

00:02:35,870 --> 00:02:39,900
computers don't use those simulator

00:02:38,280 --> 00:02:42,140
those approaches though and sad they

00:02:39,900 --> 00:02:44,850
tend to sample some sort of noisy signal

00:02:42,140 --> 00:02:46,290
and then always here the better so some

00:02:44,850 --> 00:02:49,140
examples of ways that people produce

00:02:46,290 --> 00:02:50,700
random numbers for computers there's a

00:02:49,140 --> 00:02:52,620
website called random.org where you can

00:02:50,700 --> 00:02:54,750
download high quality guaranteed random

00:02:52,620 --> 00:02:56,820
numbers the way they produced them they

00:02:54,750 --> 00:02:58,920
had a radio tuned to atmospheric static

00:02:56,820 --> 00:03:01,350
and they're sampling it turning into

00:02:58,920 --> 00:03:03,440
digital data and turning into a high

00:03:01,350 --> 00:03:05,370
quality stream of random numbers

00:03:03,440 --> 00:03:07,470
similarly there's a website called hot

00:03:05,370 --> 00:03:10,500
bits and he actually has a piece of

00:03:07,470 --> 00:03:12,030
cesium 137 and he's got that hooked up

00:03:10,500 --> 00:03:13,560
to a little a Geiger counter and he's

00:03:12,030 --> 00:03:17,130
those tix that are coming and he's

00:03:13,560 --> 00:03:18,480
turning those into random numbers back

00:03:17,130 --> 00:03:20,700
in the 90s there were some clever guys

00:03:18,480 --> 00:03:23,400
at SGI they created something cold water

00:03:20,700 --> 00:03:26,160
and where they had a webcam pointed out

00:03:23,400 --> 00:03:27,270
a whole bunch of lava lamps and they

00:03:26,160 --> 00:03:30,300
would use that to generate random

00:03:27,270 --> 00:03:32,130
numbers and finally modern CPUs actually

00:03:30,300 --> 00:03:34,140
will occasionally have an instruction

00:03:32,130 --> 00:03:36,930
that specially generates random numbers

00:03:34,140 --> 00:03:38,970
on intel Ivy Bridge and above there's

00:03:36,930 --> 00:03:40,230
one called our dear and I think the way

00:03:38,970 --> 00:03:42,750
this works is they have a deliberately

00:03:40,230 --> 00:03:44,010
flaky transistor on the CPU and they

00:03:42,750 --> 00:03:46,980
sort of look at it and see what number

00:03:44,010 --> 00:03:49,260
it's giving off right now modern

00:03:46,980 --> 00:03:50,580
operating systems also have facility for

00:03:49,260 --> 00:03:52,140
producing random members they call this

00:03:50,580 --> 00:03:53,310
the entropy pool or least that's what

00:03:52,140 --> 00:03:55,040
it's called it a Linux I don't know

00:03:53,310 --> 00:03:57,060
other operating systems have other names

00:03:55,040 --> 00:03:59,340
but the basic idea here is that the

00:03:57,060 --> 00:04:01,110
operating system is monitoring things

00:03:59,340 --> 00:04:03,690
that have some noise associated with

00:04:01,110 --> 00:04:06,540
them some external process like for

00:04:03,690 --> 00:04:08,340
instance when did the last network

00:04:06,540 --> 00:04:10,230
packet show up and if you look at it

00:04:08,340 --> 00:04:12,570
with very fine grained resolution for

00:04:10,230 --> 00:04:13,830
the time you can get some nice random

00:04:12,570 --> 00:04:17,760
data out of that particularly if you

00:04:13,830 --> 00:04:19,410
look at the very tail end of the data so

00:04:17,760 --> 00:04:22,049
the you know the microseconds rather

00:04:19,410 --> 00:04:24,000
than the seconds similarly when these

00:04:22,049 --> 00:04:26,880
are last pressed keys or released keys

00:04:24,000 --> 00:04:28,500
or if they move the mouse and how far

00:04:26,880 --> 00:04:30,419
they moved it and what direction they

00:04:28,500 --> 00:04:31,870
moved it and when they moved it and then

00:04:30,419 --> 00:04:33,640
of course if you've got our dear and you

00:04:31,870 --> 00:04:35,260
use that as well so what the entropy

00:04:33,640 --> 00:04:37,420
fool does you take all this stuff you

00:04:35,260 --> 00:04:39,310
kind of mushroom mine it together with a

00:04:37,420 --> 00:04:40,990
whole bunch of crazy math and you get a

00:04:39,310 --> 00:04:43,870
nice stream of random number out of the

00:04:40,990 --> 00:04:47,050
back now that's the end of my talk about

00:04:43,870 --> 00:04:48,430
random numbers because most of the time

00:04:47,050 --> 00:04:49,840
when computer scientists talk about

00:04:48,430 --> 00:04:51,640
random Brewers they don't actually mean

00:04:49,840 --> 00:04:53,740
random numbers they mean what are called

00:04:51,640 --> 00:04:55,390
pseudo random numbers pseudo-random

00:04:53,740 --> 00:04:57,160
numbers are very similar to random

00:04:55,390 --> 00:05:00,310
numbers but they are not technically

00:04:57,160 --> 00:05:02,410
random numbers but pseudo-random numbers

00:05:00,310 --> 00:05:04,360
are in fact so common in computer

00:05:02,410 --> 00:05:05,860
science that most of the time whenever

00:05:04,360 --> 00:05:08,140
somebody is talking about random numbers

00:05:05,860 --> 00:05:09,670
they actually mean pseudo-random numbers

00:05:08,140 --> 00:05:11,770
and they just didn't bother saying the

00:05:09,670 --> 00:05:13,090
pseudo in front I'm going to try and be

00:05:11,770 --> 00:05:14,560
very consistent for the rest of the talk

00:05:13,090 --> 00:05:16,480
I'll try to always say pseudo random

00:05:14,560 --> 00:05:18,670
number but if I say random number and

00:05:16,480 --> 00:05:19,990
you're not sure you're probably safe to

00:05:18,670 --> 00:05:22,720
assume that I actually meant to the

00:05:19,990 --> 00:05:24,340
round number so what are pseudo random

00:05:22,720 --> 00:05:25,990
numbers well they're very similar to

00:05:24,340 --> 00:05:28,270
random numbers there are a number

00:05:25,990 --> 00:05:31,780
produced on request from a specific

00:05:28,270 --> 00:05:34,360
range which mostly probably can't be

00:05:31,780 --> 00:05:35,830
predicted in advance but and here is the

00:05:34,360 --> 00:05:38,290
big difference they are produced through

00:05:35,830 --> 00:05:41,200
a deterministic non random process a

00:05:38,290 --> 00:05:42,730
completely repeatable process why would

00:05:41,200 --> 00:05:44,350
you use a pseudo-random number when you

00:05:42,730 --> 00:05:46,530
might be able to use real random numbers

00:05:44,350 --> 00:05:48,820
well actually that's the problem

00:05:46,530 --> 00:05:50,920
pseudo-random numbers you can produce as

00:05:48,820 --> 00:05:53,140
many as you want you've got some state

00:05:50,920 --> 00:05:54,610
and you have an algorithm that you run

00:05:53,140 --> 00:05:56,890
and it produces a random number for you

00:05:54,610 --> 00:05:58,870
and you can keep doing that as long as

00:05:56,890 --> 00:06:00,520
you want random numbers real random

00:05:58,870 --> 00:06:02,140
numbers maybe you constrained by some

00:06:00,520 --> 00:06:03,460
sort of data rate like the Geiger

00:06:02,140 --> 00:06:06,460
counter is only going to prove so many

00:06:03,460 --> 00:06:07,540
ticks per second and if you don't if you

00:06:06,460 --> 00:06:09,580
need a lot more random numbers in that

00:06:07,540 --> 00:06:10,780
you may just run out you may be sitting

00:06:09,580 --> 00:06:13,210
around waiting for more and room numbers

00:06:10,780 --> 00:06:15,220
that show up so pseudo-random numbers

00:06:13,210 --> 00:06:16,600
you can have as many as you want the

00:06:15,220 --> 00:06:18,940
other thing about 22 random numbers that

00:06:16,600 --> 00:06:20,560
they are refreeze reproducible so it's

00:06:18,940 --> 00:06:21,910
this is kind of a nice quality in a lot

00:06:20,560 --> 00:06:24,010
of ways like if you have a simulation

00:06:21,910 --> 00:06:25,510
where you're blooming some algae or

00:06:24,010 --> 00:06:26,980
something like that and you say well

00:06:25,510 --> 00:06:28,180
what would be like if we change this a

00:06:26,980 --> 00:06:29,320
little bit we change this here and we

00:06:28,180 --> 00:06:31,150
change that there do you rerun the

00:06:29,320 --> 00:06:34,420
simulation but you use the same stream

00:06:31,150 --> 00:06:35,650
random numbers you can be sure that the

00:06:34,420 --> 00:06:37,210
only thing that's really changing are

00:06:35,650 --> 00:06:39,160
the variables whereas if you were using

00:06:37,210 --> 00:06:40,690
a stream of random numbers the numbers

00:06:39,160 --> 00:06:42,310
would be very different and who knows

00:06:40,690 --> 00:06:44,560
that could affect that all of your

00:06:42,310 --> 00:06:45,460
simulation so how do you get yourself a

00:06:44,560 --> 00:06:47,530
pseudo-random number

00:06:45,460 --> 00:06:49,030
you use some mass some very very

00:06:47,530 --> 00:06:51,550
complicated math you generally the more

00:06:49,030 --> 00:06:53,470
complicated the better and this is here

00:06:51,550 --> 00:06:54,759
where we hit our first quote I have two

00:06:53,470 --> 00:06:56,710
quotes through and thrown in the talk

00:06:54,759 --> 00:06:59,050
there's a famous quote from John von

00:06:56,710 --> 00:07:02,110
Neumann he was using pseudo-random

00:06:59,050 --> 00:07:04,240
numbers for a simulation for artillery I

00:07:02,110 --> 00:07:06,250
think and he said anyone who considers

00:07:04,240 --> 00:07:07,930
erath medical methods of producing

00:07:06,250 --> 00:07:10,150
random digits is of course in the state

00:07:07,930 --> 00:07:11,889
of sin now this he was talking about the

00:07:10,150 --> 00:07:13,630
differentiation between random and

00:07:11,889 --> 00:07:15,099
pseudo random I think they just didn't

00:07:13,630 --> 00:07:19,150
use the term pseudo-random back then but

00:07:15,099 --> 00:07:20,770
now we do so there are two main concepts

00:07:19,150 --> 00:07:25,630
associated with a pseudo-random number

00:07:20,770 --> 00:07:27,820
generator or prng appear in G always has

00:07:25,630 --> 00:07:29,349
something they call the seed and this is

00:07:27,820 --> 00:07:31,389
really just all the internal state of

00:07:29,349 --> 00:07:33,340
the pseudo-random number generator so

00:07:31,389 --> 00:07:36,490
one important concept to keep in mind is

00:07:33,340 --> 00:07:39,970
that it's a entirely predictable process

00:07:36,490 --> 00:07:41,169
if you have a predictor state and you

00:07:39,970 --> 00:07:42,970
run the process on it you're going to

00:07:41,169 --> 00:07:44,289
produce the same output even if you

00:07:42,970 --> 00:07:45,340
reset it back to that state again later

00:07:44,289 --> 00:07:47,340
you're going to get the same output

00:07:45,340 --> 00:07:50,440
again and that's going to come up a lot

00:07:47,340 --> 00:07:51,550
the other thing about the other concept

00:07:50,440 --> 00:07:53,500
to keep in mind with a pseudo-random

00:07:51,550 --> 00:07:56,610
number generator is what's called the

00:07:53,500 --> 00:07:59,110
period something to keep in mind is that

00:07:56,610 --> 00:08:01,000
pseudo-random number generators will

00:07:59,110 --> 00:08:02,440
repeat it's not a question of if they

00:08:01,000 --> 00:08:04,210
repeat it's all a question of when they

00:08:02,440 --> 00:08:07,570
will repeat because they're always going

00:08:04,210 --> 00:08:09,039
to loop back around let's say so the

00:08:07,570 --> 00:08:10,659
reason for this is it's really an

00:08:09,039 --> 00:08:12,789
application to pigeonhole principle if

00:08:10,659 --> 00:08:14,050
you think about it let's say that we

00:08:12,789 --> 00:08:17,320
have a pseudo-random number generator

00:08:14,050 --> 00:08:20,500
and its seed its state is a 32-bit

00:08:17,320 --> 00:08:24,550
number well 32-bit number has a maximum

00:08:20,500 --> 00:08:26,380
number of 4.6 billion possible values so

00:08:24,550 --> 00:08:28,750
if that represents each of those states

00:08:26,380 --> 00:08:30,849
represents a state of the pseudo-random

00:08:28,750 --> 00:08:33,070
number generator if you run at 4.7

00:08:30,849 --> 00:08:34,329
billion times you're going to have at

00:08:33,070 --> 00:08:35,860
some point you're going to have a

00:08:34,329 --> 00:08:37,360
duplicate state where you hit that one

00:08:35,860 --> 00:08:39,430
before and if you hit that one before

00:08:37,360 --> 00:08:41,169
they ruse the same output you produce

00:08:39,430 --> 00:08:43,060
the same applet here I've got a whole

00:08:41,169 --> 00:08:45,760
all astray shun for it so let's say this

00:08:43,060 --> 00:08:46,959
is our state this is s this is the

00:08:45,760 --> 00:08:49,750
current state of the pseudo-random

00:08:46,959 --> 00:08:51,640
number generator and we operate on and

00:08:49,750 --> 00:08:54,130
boom we produce two things we produce

00:08:51,640 --> 00:08:56,829
the number and and we produce a new

00:08:54,130 --> 00:08:58,329
state s Prime if you do that again

00:08:56,829 --> 00:08:59,020
you're going to get another state and

00:08:58,329 --> 00:09:00,520
another end

00:08:59,020 --> 00:09:02,710
number and you keep doing and doing and

00:09:00,520 --> 00:09:04,330
doing than doing it sooner or later it

00:09:02,710 --> 00:09:07,270
seems pretty likely you're going to run

00:09:04,330 --> 00:09:09,310
into a state where if you operate on it

00:09:07,270 --> 00:09:11,320
boom you'll produce your original state

00:09:09,310 --> 00:09:13,500
again and you produce a random number of

00:09:11,320 --> 00:09:16,180
course and at that point you've looped

00:09:13,500 --> 00:09:18,820
so like I said it's not a question of if

00:09:16,180 --> 00:09:21,070
it's a question of when now good

00:09:18,820 --> 00:09:22,810
pseudo-random number generator is going

00:09:21,070 --> 00:09:24,520
to have a nice long period it's going to

00:09:22,810 --> 00:09:26,380
happen it's going to produce many many

00:09:24,520 --> 00:09:28,000
many many numbers before it repeats and

00:09:26,380 --> 00:09:31,180
the output is going to be

00:09:28,000 --> 00:09:34,930
indistinguishable from noise we'll talk

00:09:31,180 --> 00:09:36,250
about good versus bad in a minute but to

00:09:34,930 --> 00:09:38,200
talk about good pseudo-random number

00:09:36,250 --> 00:09:39,430
generators the industry standards is

00:09:38,200 --> 00:09:42,610
what's called the Mercian twister

00:09:39,430 --> 00:09:44,830
Mersenne twister was released in 1977 by

00:09:42,610 --> 00:09:46,810
two japanese computer science

00:09:44,830 --> 00:09:49,420
researchers and they made it open source

00:09:46,810 --> 00:09:51,310
and patent free so everybody can use it

00:09:49,420 --> 00:09:54,040
and I think everybody basically does use

00:09:51,310 --> 00:09:59,830
it it has an incredibly long period of

00:09:54,040 --> 00:10:02,020
two to the 9937 minus 1 this number 2 to

00:09:59,830 --> 00:10:03,700
the huge number minus one that's what's

00:10:02,020 --> 00:10:05,620
called a Mersenne Prime that's why it's

00:10:03,700 --> 00:10:07,600
called the Mersenne twister were saying

00:10:05,620 --> 00:10:09,010
for the Mersenne Prime twister because

00:10:07,600 --> 00:10:10,660
there's some mathematical operation

00:10:09,010 --> 00:10:12,960
inside that they call twisting that I

00:10:10,660 --> 00:10:15,580
don't understand how it works inside now

00:10:12,960 --> 00:10:18,330
the gets to this period because of the

00:10:15,580 --> 00:10:21,700
seed the seed is enormous it's 19,000

00:10:18,330 --> 00:10:23,680
937 by it's almost 20 k and I'm going to

00:10:21,700 --> 00:10:27,160
point out to you that that is that

00:10:23,680 --> 00:10:28,480
requires 624 32-bit words and the reason

00:10:27,160 --> 00:10:30,040
I say that is I'm going to talk about

00:10:28,480 --> 00:10:31,240
that number just remember that for a

00:10:30,040 --> 00:10:33,130
minute on the next slide I'm going to

00:10:31,240 --> 00:10:36,220
talk about the number 6 24 in connection

00:10:33,130 --> 00:10:38,740
with the Mersenne Prime the Mersenne

00:10:36,220 --> 00:10:40,480
Prime the Mercian twister is the default

00:10:38,740 --> 00:10:42,820
pseudo-random number generator that

00:10:40,480 --> 00:10:46,600
shipped in Python 23 and all subsequent

00:10:42,820 --> 00:10:48,220
versions so if you use Python use the

00:10:46,600 --> 00:10:49,990
random module and again that's not the

00:10:48,220 --> 00:10:52,930
pseudorandom module to the random module

00:10:49,990 --> 00:10:54,910
it's you are using the more sane twister

00:10:52,930 --> 00:10:57,910
but this is hardly unique to python it's

00:10:54,910 --> 00:10:59,440
used as the default random number

00:10:57,910 --> 00:11:01,720
generator pseudo-random number generator

00:10:59,440 --> 00:11:04,450
in the bunch of languages and in a bunch

00:11:01,720 --> 00:11:06,310
of mathematical packages and in fact a

00:11:04,450 --> 00:11:08,950
whole bunch of mathematical libraries

00:11:06,310 --> 00:11:11,140
that are all open source so it's

00:11:08,950 --> 00:11:12,510
essentially the industry standard prng

00:11:11,140 --> 00:11:14,190
these days

00:11:12,510 --> 00:11:18,300
now there's something that's even better

00:11:14,190 --> 00:11:19,950
than the myrrh st. wistar there's

00:11:18,300 --> 00:11:21,300
another class above and beyond the

00:11:19,950 --> 00:11:25,110
normal PRNG that's called a

00:11:21,300 --> 00:11:26,640
cryptographically secure PRNG or CSP RNG

00:11:25,110 --> 00:11:27,860
because otherwise I'm going to stumble

00:11:26,640 --> 00:11:30,180
over myself saying it a

00:11:27,860 --> 00:11:32,250
cryptographically secure PRNG is

00:11:30,180 --> 00:11:34,470
suitable for use with cryptography where

00:11:32,250 --> 00:11:35,910
you need random numbers at times like

00:11:34,470 --> 00:11:38,670
you're going to generate a one-time pad

00:11:35,910 --> 00:11:40,320
or a public and private key pair you

00:11:38,670 --> 00:11:41,550
want those to be random numbers but you

00:11:40,320 --> 00:11:43,470
don't want anybody to be able to guess

00:11:41,550 --> 00:11:46,650
what they were so you want something

00:11:43,470 --> 00:11:48,090
that is secure against attack this is

00:11:46,650 --> 00:11:50,010
kind of an area of research and it's not

00:11:48,090 --> 00:11:51,300
really well established but as I

00:11:50,010 --> 00:11:52,800
understand that there are two basic

00:11:51,300 --> 00:11:54,210
rules that people use to decide whether

00:11:52,800 --> 00:11:56,700
something is a cryptographically secure

00:11:54,210 --> 00:12:00,150
PNG or not the first is what's called

00:11:56,700 --> 00:12:03,090
the next bit test where you can have as

00:12:00,150 --> 00:12:06,030
much output as you want out of the prng

00:12:03,090 --> 00:12:07,530
and the next bit says says you should

00:12:06,030 --> 00:12:11,310
not be able to predict the next bit

00:12:07,530 --> 00:12:13,710
generated by the prng with anything more

00:12:11,310 --> 00:12:16,350
than fifty percent accuracy and this is

00:12:13,710 --> 00:12:20,360
where the Mercedes URLs it's not CSP RNG

00:12:16,350 --> 00:12:23,430
safe because if you observe 624

00:12:20,360 --> 00:12:25,500
subsequent outputs of the Mersenne

00:12:23,430 --> 00:12:28,050
twister you can reconstruct the internal

00:12:25,500 --> 00:12:30,500
state and that allows you to predict all

00:12:28,050 --> 00:12:33,950
of the numbers going on henceforth so

00:12:30,500 --> 00:12:35,850
the Mercedes juror is not CSP RNG

00:12:33,950 --> 00:12:37,890
similarly the other test is what's

00:12:35,850 --> 00:12:41,130
called the state compromise extension

00:12:37,890 --> 00:12:43,140
your CS prng must not have a state

00:12:41,130 --> 00:12:45,570
compromise extension and what this means

00:12:43,140 --> 00:12:49,050
is that if the internal state of the

00:12:45,570 --> 00:12:50,970
trng becomes known you cannot take it

00:12:49,050 --> 00:12:52,830
and extend it backwards in time and

00:12:50,970 --> 00:12:55,080
produce previous states and then

00:12:52,830 --> 00:12:57,270
therefore figure out what the previous

00:12:55,080 --> 00:12:59,820
numbers generated were and again the

00:12:57,270 --> 00:13:01,650
Mersenne twister fails at this it is

00:12:59,820 --> 00:13:06,150
reversible and you can run it backwards

00:13:01,650 --> 00:13:09,020
and produce previous numbers in general

00:13:06,150 --> 00:13:12,810
the way that people implement secure see

00:13:09,020 --> 00:13:15,060
CSP our energies is using existing

00:13:12,810 --> 00:13:16,290
secure technologies so they'll take the

00:13:15,060 --> 00:13:18,570
existing math and they'll combine it

00:13:16,290 --> 00:13:20,030
with cipher or a cryptographically

00:13:18,570 --> 00:13:22,140
secure hash or something like that

00:13:20,030 --> 00:13:23,580
they're only a couple of them and they

00:13:22,140 --> 00:13:25,230
tend to be very expensive and so people

00:13:23,580 --> 00:13:26,070
really only use it for stuff that's very

00:13:25,230 --> 00:13:29,040
specifically

00:13:26,070 --> 00:13:30,960
doing it with cryptography now where we

00:13:29,040 --> 00:13:33,660
have good PR and jeez we also have bad

00:13:30,960 --> 00:13:34,740
PR NGS and this is kind of fun topics

00:13:33,660 --> 00:13:36,750
we're going to spend a little time on

00:13:34,740 --> 00:13:38,520
this a bad p energy is going to have a

00:13:36,750 --> 00:13:40,680
short period and it's going to have

00:13:38,520 --> 00:13:42,630
hidden patterns in the data it's going

00:13:40,680 --> 00:13:45,690
to have its output is not going to be

00:13:42,630 --> 00:13:47,460
basically equivalent to noise this can

00:13:45,690 --> 00:13:49,980
run you into real trouble let's say that

00:13:47,460 --> 00:13:52,920
you have a simulation you're simulating

00:13:49,980 --> 00:13:54,120
the movement of people across the

00:13:52,920 --> 00:13:56,160
country like people are deciding to move

00:13:54,120 --> 00:13:58,650
from one city you know another if there

00:13:56,160 --> 00:14:00,450
are patterns inside of your random data

00:13:58,650 --> 00:14:02,820
when you feed that data into your

00:14:00,450 --> 00:14:05,900
algorithms it may result in patterns

00:14:02,820 --> 00:14:09,390
emerging in the simulation that

00:14:05,900 --> 00:14:11,940
shouldn't really be there so you can

00:14:09,390 --> 00:14:14,990
have misleading results if you use bad

00:14:11,940 --> 00:14:17,970
random data going into your simulation

00:14:14,990 --> 00:14:21,000
you can also have exploitable things

00:14:17,970 --> 00:14:23,280
like in my in my video game example I

00:14:21,000 --> 00:14:24,420
remember specific case I remember

00:14:23,280 --> 00:14:26,490
watching somebody who was going to play

00:14:24,420 --> 00:14:29,370
a game on the original nintendo

00:14:26,490 --> 00:14:31,440
entertainment system and they were very

00:14:29,370 --> 00:14:33,000
carefully they were power cycling it and

00:14:31,440 --> 00:14:35,520
then starting the game right away and

00:14:33,000 --> 00:14:37,200
what they were trying to do here was the

00:14:35,520 --> 00:14:38,970
Nintendo Entertainment System didn't

00:14:37,200 --> 00:14:41,190
have any source for random numbers apart

00:14:38,970 --> 00:14:43,230
from just using like the system clock in

00:14:41,190 --> 00:14:44,700
which reset whenever you power cycled it

00:14:43,230 --> 00:14:46,260
and what they were trying to do was to

00:14:44,700 --> 00:14:48,210
get it into a state where they had a

00:14:46,260 --> 00:14:49,650
very favorable seed and therefore they

00:14:48,210 --> 00:14:53,700
were going to have very favorable easier

00:14:49,650 --> 00:14:57,210
to play game so there's a particular

00:14:53,700 --> 00:14:59,040
form of pseudo-random number generator

00:14:57,210 --> 00:15:00,660
called the linear congruent generator I

00:14:59,040 --> 00:15:02,240
don't understand these terms at all by

00:15:00,660 --> 00:15:06,930
the way I'm just repeating what I read

00:15:02,240 --> 00:15:09,270
but an also lcg is a very simple random

00:15:06,930 --> 00:15:11,160
number generator of the form what you do

00:15:09,270 --> 00:15:13,410
is you you have a seed which is just a

00:15:11,160 --> 00:15:15,360
number this is like a 32-bit number and

00:15:13,410 --> 00:15:16,590
you're storing it somewhere and the way

00:15:15,360 --> 00:15:19,110
that the random number generator works

00:15:16,590 --> 00:15:20,640
is you remember the old seed because you

00:15:19,110 --> 00:15:22,470
returned it as new random number and

00:15:20,640 --> 00:15:24,570
then you compute the new seed in the new

00:15:22,470 --> 00:15:27,510
seed you take that seed you multiply it

00:15:24,570 --> 00:15:30,090
by a multiplan multiple can you add a

00:15:27,510 --> 00:15:31,410
constant and then you throw away all the

00:15:30,090 --> 00:15:35,160
top it's and you just keep the bottom

00:15:31,410 --> 00:15:37,320
however your word size is bits so this

00:15:35,160 --> 00:15:39,340
is used a bunch of times back in the bad

00:15:37,320 --> 00:15:41,110
old days of computer science

00:15:39,340 --> 00:15:42,850
it has some positive attributes it's

00:15:41,110 --> 00:15:45,250
very fast it has very small code size

00:15:42,850 --> 00:15:49,750
very small data size but it is

00:15:45,250 --> 00:15:51,790
essentially a bad pure ng so there's a

00:15:49,750 --> 00:15:54,100
very famous back here in G of this form

00:15:51,790 --> 00:15:55,840
an LC g called rand new i'm not sure

00:15:54,100 --> 00:15:57,580
where it comes from i'm guessing maybe

00:15:55,840 --> 00:15:59,710
fortran because a lot of people talk

00:15:57,580 --> 00:16:02,950
about it and it's of the same form the

00:15:59,710 --> 00:16:06,030
constant zero that you add but you x 55

00:16:02,950 --> 00:16:08,980
539 and the word sizes to the 31st

00:16:06,030 --> 00:16:11,200
Donald Knuth once said its very name

00:16:08,980 --> 00:16:13,090
randu is enough to bring dismay into the

00:16:11,200 --> 00:16:16,480
eyes and stomachs of many computer

00:16:13,090 --> 00:16:18,430
scientists now what's interesting is

00:16:16,480 --> 00:16:22,150
that it is still used at least in one

00:16:18,430 --> 00:16:24,910
place not randu but an LC g visual

00:16:22,150 --> 00:16:28,330
studio ships a compiler called visual

00:16:24,910 --> 00:16:30,400
studio C++ which is also AC compiler the

00:16:28,330 --> 00:16:32,050
c compiler ships with a standard library

00:16:30,400 --> 00:16:33,820
in the standard libraries of function

00:16:32,050 --> 00:16:36,090
called Rand which produces a random

00:16:33,820 --> 00:16:39,040
number and s van which use deceit it and

00:16:36,090 --> 00:16:41,260
visual studios rand is the same now as

00:16:39,040 --> 00:16:42,820
it was probably 20 years ago and they're

00:16:41,260 --> 00:16:44,200
actually shipping their invaded right

00:16:42,820 --> 00:16:47,080
now for the next version and it still

00:16:44,200 --> 00:16:48,670
hasn't changed and it's still an LC g so

00:16:47,080 --> 00:16:49,900
it's an LC g of this form um you're

00:16:48,670 --> 00:16:51,550
multiplying by two hundred fourteen

00:16:49,900 --> 00:16:53,110
thousand and thirteen and they're adding

00:16:51,550 --> 00:16:56,140
a number that's about 2.5 million and

00:16:53,110 --> 00:16:58,000
you only keeping the bottom 32 bits rand

00:16:56,140 --> 00:17:00,280
itself actually only returns the bottom

00:16:58,000 --> 00:17:01,180
it actually returns the top 15 bits or

00:17:00,280 --> 00:17:04,450
something like that there's like some

00:17:01,180 --> 00:17:06,490
bit shifting going around just to show

00:17:04,450 --> 00:17:08,200
you what it looks like this is this

00:17:06,490 --> 00:17:10,450
isn't the copyrighted version out of

00:17:08,200 --> 00:17:13,000
their library I reimplemented it but

00:17:10,450 --> 00:17:15,670
this is equivalent to visual studios r

00:17:13,000 --> 00:17:16,930
and I translated the Python for you just

00:17:15,670 --> 00:17:19,020
in case that makes it any easier but

00:17:16,930 --> 00:17:23,650
it's really a very simple implementation

00:17:19,020 --> 00:17:25,150
and this is basically terrible uh it's

00:17:23,650 --> 00:17:27,400
crime shocking that they're still

00:17:25,150 --> 00:17:31,090
shipping it in 2014 or even 2015's their

00:17:27,400 --> 00:17:33,670
plan it's not clear why the two theories

00:17:31,090 --> 00:17:35,170
I've heard are then a they keep it for

00:17:33,670 --> 00:17:36,430
backwards compatibility but everybody

00:17:35,170 --> 00:17:39,820
knows that it's a bad idea and nobody

00:17:36,430 --> 00:17:41,140
should use it and be visual studios c

00:17:39,820 --> 00:17:43,390
compiler really isn't getting a lot of

00:17:41,140 --> 00:17:46,900
love these days microsoft is more

00:17:43,390 --> 00:17:49,420
interested in C++ and C sharp but to

00:17:46,900 --> 00:17:52,150
give you an idea of how bad it is I went

00:17:49,420 --> 00:17:52,990
to the trouble of graphing this stuff so

00:17:52,150 --> 00:17:56,550
what I did is I took

00:17:52,990 --> 00:17:59,970
big white texture a big white image as

00:17:56,550 --> 00:18:01,990
256 x 256 and i took a whole bunch of

00:17:59,970 --> 00:18:04,090
random or pseudo-random data and i

00:18:01,990 --> 00:18:05,980
plotted it I basically iterated across

00:18:04,090 --> 00:18:08,290
in X and then I would take the bottom

00:18:05,980 --> 00:18:10,420
eight bits of the number and just make

00:18:08,290 --> 00:18:13,000
it a little darker so I'm going over

00:18:10,420 --> 00:18:14,740
darkening everything I did that with

00:18:13,000 --> 00:18:16,330
genuinely random data i downloaded off

00:18:14,740 --> 00:18:18,640
of random.org and it looks like this now

00:18:16,330 --> 00:18:20,830
you might have expected this to be a

00:18:18,640 --> 00:18:24,390
sort of uniform gray field but that's

00:18:20,830 --> 00:18:26,410
not what you get random numbers

00:18:24,390 --> 00:18:28,030
distribute there's something called the

00:18:26,410 --> 00:18:30,040
Poisson distribution and again I don't

00:18:28,030 --> 00:18:31,720
understand the math really but what

00:18:30,040 --> 00:18:33,190
poisson distribution suggest to you is

00:18:31,720 --> 00:18:35,080
that random numbers tend to clump

00:18:33,190 --> 00:18:36,460
together so you don't get something

00:18:35,080 --> 00:18:37,960
totally uniform and said you get a

00:18:36,460 --> 00:18:39,880
grouping over here and maybe a big

00:18:37,960 --> 00:18:43,059
ripping here and then there's a gap over

00:18:39,880 --> 00:18:44,500
here and that's just because randomly

00:18:43,059 --> 00:18:46,960
it's not going to be uniform it's going

00:18:44,500 --> 00:18:49,179
to be randomly more and less over here

00:18:46,960 --> 00:18:51,010
what i say is that this more or less

00:18:49,179 --> 00:18:54,640
looks like static like if you had a TV

00:18:51,010 --> 00:18:56,410
tuned to know station at all and so this

00:18:54,640 --> 00:18:57,520
is generally what we should expect and

00:18:56,410 --> 00:18:59,290
this is what we get with genuinely

00:18:57,520 --> 00:19:01,179
random data either the same thing that

00:18:59,290 --> 00:19:03,100
the MER st. twister and we get something

00:19:01,179 --> 00:19:05,020
that looks about the same it looks like

00:19:03,100 --> 00:19:06,970
static but if you do that with the

00:19:05,020 --> 00:19:09,250
visual studio r and then you get

00:19:06,970 --> 00:19:12,010
something that has some patterns seeming

00:19:09,250 --> 00:19:14,140
to emerge there's these streaks these

00:19:12,010 --> 00:19:15,309
vertical streaks I there's one about one

00:19:14,140 --> 00:19:18,010
third of the way and there's another one

00:19:15,309 --> 00:19:20,230
about two thirds of the way and what

00:19:18,010 --> 00:19:23,890
this is telling us is that on that

00:19:20,230 --> 00:19:25,480
iteration through the data there are

00:19:23,890 --> 00:19:26,710
areas where you're never going to have a

00:19:25,480 --> 00:19:28,179
kit you're always going to hit these

00:19:26,710 --> 00:19:29,920
black spots and you're never going to

00:19:28,179 --> 00:19:32,230
get a number on that iteration in those

00:19:29,920 --> 00:19:34,750
white spots but an even better

00:19:32,230 --> 00:19:36,880
visualization this is why I talked about

00:19:34,750 --> 00:19:39,550
ran do in the first place if you take

00:19:36,880 --> 00:19:41,500
triplets out of the rand new algorithm

00:19:39,550 --> 00:19:44,890
and you just use them as coordinates in

00:19:41,500 --> 00:19:47,050
a 3d sphere excuse me the 3d cube you

00:19:44,890 --> 00:19:49,240
get a plot that looks like this there

00:19:47,050 --> 00:19:51,700
are 15 hyper planes here and what this

00:19:49,240 --> 00:19:53,110
is saying is that the randu triplets

00:19:51,700 --> 00:19:55,480
that are generated by the algorithm will

00:19:53,110 --> 00:19:57,100
only ever appear along those 15

00:19:55,480 --> 00:20:02,410
hyperplanes you'll never get a number of

00:19:57,100 --> 00:20:04,900
this in between them so in summary there

00:20:02,410 --> 00:20:06,980
are random numbers and they're generated

00:20:04,900 --> 00:20:08,510
for computers using a noisy signal

00:20:06,980 --> 00:20:10,160
you don't actually see them very often

00:20:08,510 --> 00:20:11,750
and you generally don't get a whole lot

00:20:10,160 --> 00:20:13,580
of them so most people instead use

00:20:11,750 --> 00:20:15,559
pseudo-random numbers Sodor Animal

00:20:13,580 --> 00:20:17,480
numbers are plentiful they are

00:20:15,559 --> 00:20:19,850
deterministic so they're repeatable

00:20:17,480 --> 00:20:21,200
because of that they have something

00:20:19,850 --> 00:20:23,150
called the seed which is all their state

00:20:21,200 --> 00:20:26,000
in a period which is how many numbers

00:20:23,150 --> 00:20:27,169
you get before it repeats there's bad

00:20:26,000 --> 00:20:28,720
ones there's good ones and there's

00:20:27,169 --> 00:20:30,799
cryptographically secure ones and

00:20:28,720 --> 00:20:34,720
everybody should just use the Mersenne

00:20:30,799 --> 00:20:34,720
twister and be done with it that's it

00:20:46,080 --> 00:20:48,140

YouTube URL: https://www.youtube.com/watch?v=PRbfdK2Xxh0


