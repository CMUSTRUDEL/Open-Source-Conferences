Title: What in the World is Asyncio? by Josh Bartlett
Publication date: 2014-08-05
Playlist: PyCon Australia 2014
Description: 
	The Python 3.4 standard library contains a new module called "asyncio" (formerly "tulip"), which allows you to write single-threaded asynchronous code based on PEP 3156. This presentation will begin with an outline of what asyncio provides and how to use it, highlighting the kinds of use cases that it was designed for. The presentation will then go through a number of example use cases and within the context of these use cases, will compare asyncio with Twisted, one of the existing libraries for asynchronous programming. Finally, the presentation will touch on the question of interoperability between asyncio and libraries like Twisted, Pyramid and gevent.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:08,400 --> 00:00:12,840
oh good morning everyone I am indeed

00:00:10,769 --> 00:00:17,369
Josh and the talk is what in the world

00:00:12,840 --> 00:00:18,990
is a sink IO so before I get started the

00:00:17,369 --> 00:00:20,939
talk properly though you're probably

00:00:18,990 --> 00:00:24,990
wondering who is this guy and why should

00:00:20,939 --> 00:00:29,849
I listen to you so I first learnt to

00:00:24,990 --> 00:00:31,500
program using gw-basic on an xt oh yeah

00:00:29,849 --> 00:00:34,019
we have one tear down the front here I

00:00:31,500 --> 00:00:37,620
think that's some about yeah

00:00:34,019 --> 00:00:39,720
characteristic of that statement so then

00:00:37,620 --> 00:00:42,000
I graduated through the various dialects

00:00:39,720 --> 00:00:44,339
of basic learned a bit of Pascal and

00:00:42,000 --> 00:00:45,540
some C and then some Delfy and some C++

00:00:44,339 --> 00:00:48,030
and then I came across this language

00:00:45,540 --> 00:00:50,040
called Python and I found Python

00:00:48,030 --> 00:00:51,659
intriguing and a little bit scary at

00:00:50,040 --> 00:00:53,519
first probably a lot of you have had

00:00:51,659 --> 00:00:56,070
similar experiences when you first met

00:00:53,519 --> 00:00:58,320
pipe and it went something like um hold

00:00:56,070 --> 00:01:01,350
on a minute are you saying that my if

00:00:58,320 --> 00:01:03,479
statement I don't have to close it with

00:01:01,350 --> 00:01:06,000
some sort of end keyword or curly brace

00:01:03,479 --> 00:01:11,580
but that feels wrong what what if my

00:01:06,000 --> 00:01:13,680
code escapes or something and um you

00:01:11,580 --> 00:01:15,600
mean I can insert objects between two

00:01:13,680 --> 00:01:17,760
different elements of this array thing

00:01:15,600 --> 00:01:19,770
without implementing a linked list from

00:01:17,760 --> 00:01:22,020
scratch and there's something fishy

00:01:19,770 --> 00:01:24,900
going on with my string manipulation it

00:01:22,020 --> 00:01:28,320
fits on one line and what it looks like

00:01:24,900 --> 00:01:30,480
it will do is what it does um I don't

00:01:28,320 --> 00:01:34,409
know man I don't know I'd feel like I

00:01:30,480 --> 00:01:35,790
was cheating if I use Python so I've

00:01:34,409 --> 00:01:37,740
been using Python for more than 10 years

00:01:35,790 --> 00:01:39,240
now and as was mentioned in the

00:01:37,740 --> 00:01:41,100
introduction I work for netbox blue

00:01:39,240 --> 00:01:44,400
where I spend 99% of my time working

00:01:41,100 --> 00:01:47,490
with Python netbooks Blue has been using

00:01:44,400 --> 00:01:49,200
Python Python for a very long time yep

00:01:47,490 --> 00:01:50,970
the first networks blue code that was

00:01:49,200 --> 00:01:53,880
written in Python was written for Python

00:01:50,970 --> 00:01:56,030
1.3 back when python 1.3 was the latest

00:01:53,880 --> 00:01:59,760
stable version of piper

00:01:56,030 --> 00:02:02,430
so we have about 300,000 lines of Python

00:01:59,760 --> 00:02:04,500
code and it's good to work in a job

00:02:02,430 --> 00:02:07,860
where I can work mostly in Python in my

00:02:04,500 --> 00:02:09,840
spare time I also do some work on some

00:02:07,860 --> 00:02:11,730
open source projects so for example this

00:02:09,840 --> 00:02:13,379
is a screenshot from a game called troz

00:02:11,730 --> 00:02:16,010
nut which is written in Python using

00:02:13,379 --> 00:02:18,180
twisted and PI game I've also written

00:02:16,010 --> 00:02:19,739
there was some applause here this is the

00:02:18,180 --> 00:02:22,090
release manager of twisted applausing

00:02:19,739 --> 00:02:25,330
Lee applauded

00:02:22,090 --> 00:02:27,790
I also have written a window manager for

00:02:25,330 --> 00:02:29,640
x11 using Python and twisted I'm so just

00:02:27,790 --> 00:02:32,830
little projects like that

00:02:29,640 --> 00:02:34,660
so the talk today is I'm sorry before I

00:02:32,830 --> 00:02:36,940
get to the talk understanding my

00:02:34,660 --> 00:02:39,790
audience so a quick poll

00:02:36,940 --> 00:02:42,520
have you a contributed to pep 31:56

00:02:39,790 --> 00:02:44,890
and/or tulip be you've used async IO

00:02:42,520 --> 00:02:46,930
extensively see you've used twisted

00:02:44,890 --> 00:02:49,510
tornado or some other a sync frame work

00:02:46,930 --> 00:02:52,180
like that fairly extensively do you

00:02:49,510 --> 00:02:53,800
played with async programming or you're

00:02:52,180 --> 00:02:55,810
here because they sent a sync sounds

00:02:53,800 --> 00:02:58,810
kind of cool so hands up for a you've

00:02:55,810 --> 00:03:00,790
contributed to the pep or the excellent

00:02:58,810 --> 00:03:03,130
excellent good know I know and put their

00:03:00,790 --> 00:03:07,030
hands up be you've used async IO

00:03:03,130 --> 00:03:08,920
extensively a few people okay I probably

00:03:07,030 --> 00:03:10,480
don't have a lot of new stuff for you

00:03:08,920 --> 00:03:13,810
but maybe you can help me answer

00:03:10,480 --> 00:03:16,180
questions at the end I see have you

00:03:13,810 --> 00:03:18,400
who's used twisted or tornado or some

00:03:16,180 --> 00:03:20,350
other async framework a fair bit out of

00:03:18,400 --> 00:03:21,250
interest how many of those is twisted

00:03:20,350 --> 00:03:25,030
because that's what I'm most familiar

00:03:21,250 --> 00:03:26,830
with okay and any any other frameworks

00:03:25,030 --> 00:03:30,310
that people have used extensively for

00:03:26,830 --> 00:03:33,400
async stuff not really okay cool so that

00:03:30,310 --> 00:03:34,690
means that sorry was there no okay that

00:03:33,400 --> 00:03:36,760
means that when I compare things with

00:03:34,690 --> 00:03:37,780
twisted the people who've done a sink

00:03:36,760 --> 00:03:41,950
before will actually know what I'm

00:03:37,780 --> 00:03:44,170
talking about I D I've used some async

00:03:41,950 --> 00:03:46,210
played with it a bit okay a good number

00:03:44,170 --> 00:03:48,760
of you and II you thought it sounded

00:03:46,210 --> 00:03:51,310
kind of cool okay the rest of you good

00:03:48,760 --> 00:03:54,070
good I know who I'm aiming at now and so

00:03:51,310 --> 00:03:56,080
my plan for this talk is to look at what

00:03:54,070 --> 00:03:58,180
is async IO and that will include a bit

00:03:56,080 --> 00:04:00,760
of what's async programming at all as

00:03:58,180 --> 00:04:03,940
well as some history of async IO and

00:04:00,760 --> 00:04:07,330
async programming in Python then how do

00:04:03,940 --> 00:04:08,740
we use async IO so I'll give you some

00:04:07,330 --> 00:04:11,800
examples of the sorts of functions you

00:04:08,740 --> 00:04:13,570
use and some code examples is it

00:04:11,800 --> 00:04:15,580
compatible with other async libraries

00:04:13,570 --> 00:04:18,790
and then if I have time at the end maybe

00:04:15,580 --> 00:04:22,180
a few a few tips for using it so the

00:04:18,790 --> 00:04:24,640
first question is what is a sink IO so a

00:04:22,180 --> 00:04:27,940
sink IO is a new module in the standard

00:04:24,640 --> 00:04:29,560
library in Python 3.4 so the obvious

00:04:27,940 --> 00:04:32,919
place to go to ask what it is and what

00:04:29,560 --> 00:04:34,330
it does is the Python 3 library dogs and

00:04:32,919 --> 00:04:36,819
this is what the pattern 3

00:04:34,330 --> 00:04:38,439
library Doc's say about async IO this

00:04:36,819 --> 00:04:40,120
module provides infrastructure for

00:04:38,439 --> 00:04:42,400
writing single threaded concurrent code

00:04:40,120 --> 00:04:44,889
using co-routines multiplexing IO access

00:04:42,400 --> 00:04:46,659
over sockets and other resources running

00:04:44,889 --> 00:04:49,360
network clients and servers and other

00:04:46,659 --> 00:04:51,340
related primitives now this is a very

00:04:49,360 --> 00:04:52,960
good description of what it does but I

00:04:51,340 --> 00:04:55,930
imagine for a lot of you guys out there

00:04:52,960 --> 00:04:58,240
this isn't all that helpful so I've got

00:04:55,930 --> 00:05:02,050
a simplified definition of async IO for

00:04:58,240 --> 00:05:04,840
you here async IO provides you with an

00:05:02,050 --> 00:05:08,830
asynchronous main loop as well as some

00:05:04,840 --> 00:05:11,590
IO our interfaces and primitives for use

00:05:08,830 --> 00:05:13,990
on that main loop but the obvious

00:05:11,590 --> 00:05:15,610
question here is what is an async main

00:05:13,990 --> 00:05:18,840
loop what do we mean by asynchronous

00:05:15,610 --> 00:05:20,830
programming here the basic problem that

00:05:18,840 --> 00:05:23,669
asynchronous programming is trying to

00:05:20,830 --> 00:05:28,599
address is the problem of concurrency or

00:05:23,669 --> 00:05:30,069
multitasking if you like so for example

00:05:28,599 --> 00:05:33,699
say I wanted to write another web

00:05:30,069 --> 00:05:35,409
framework in Python I might want it to

00:05:33,699 --> 00:05:37,449
appear as though my web framework is

00:05:35,409 --> 00:05:40,180
doing multiple things at once so I might

00:05:37,449 --> 00:05:43,000
want to be able to start to process

00:05:40,180 --> 00:05:46,000
Bob's web request before I've completely

00:05:43,000 --> 00:05:47,800
finished responding to Alice's even

00:05:46,000 --> 00:05:49,839
especially that would especially be the

00:05:47,800 --> 00:05:51,430
case if alice is asking something that's

00:05:49,839 --> 00:05:53,259
going to take me a long time to process

00:05:51,430 --> 00:05:54,639
or I'm going to have to wait on other

00:05:53,259 --> 00:05:56,110
resources I'm going to have to fetch

00:05:54,639 --> 00:05:57,729
something from the internet before I can

00:05:56,110 --> 00:06:02,080
respond to Alice that sort of thing so

00:05:57,729 --> 00:06:04,319
the sorts of approaches that people have

00:06:02,080 --> 00:06:07,089
dissolving this concurrency problem

00:06:04,319 --> 00:06:10,000
there are a number of them so multiple

00:06:07,089 --> 00:06:12,219
processes if you use multiple processes

00:06:10,000 --> 00:06:14,229
you have the guarantee that each of

00:06:12,219 --> 00:06:15,759
these processes is separate you don't

00:06:14,229 --> 00:06:17,409
have to worry about any sort of global

00:06:15,759 --> 00:06:19,599
interpreter lock if you using C Python

00:06:17,409 --> 00:06:22,690
don't have to worry about any sort of

00:06:19,599 --> 00:06:24,520
shared memory issues what you do have to

00:06:22,690 --> 00:06:26,440
worry about is if your processes have to

00:06:24,520 --> 00:06:27,819
communicate with each other you'll need

00:06:26,440 --> 00:06:30,430
to serialize whatever you're

00:06:27,819 --> 00:06:32,440
communicating down to bytes to send it

00:06:30,430 --> 00:06:34,029
across between them over named pipes or

00:06:32,440 --> 00:06:35,710
UNIX sockets or whatever you choose as

00:06:34,029 --> 00:06:38,589
your preferred in the process

00:06:35,710 --> 00:06:41,289
communication um if you choose to go

00:06:38,589 --> 00:06:43,300
with threading you get around this issue

00:06:41,289 --> 00:06:45,219
of having to serialize things down the

00:06:43,300 --> 00:06:47,050
advantage of threading is that you have

00:06:45,219 --> 00:06:50,000
some shared memory

00:06:47,050 --> 00:06:53,180
the disadvantage of threading is that

00:06:50,000 --> 00:06:54,980
you have some shared memory so the

00:06:53,180 --> 00:06:56,780
shared memory is good in that it will

00:06:54,980 --> 00:06:59,690
allow you to pass complex objects

00:06:56,780 --> 00:07:01,760
between different threads it's bad

00:06:59,690 --> 00:07:04,400
because if two different threads have

00:07:01,760 --> 00:07:06,170
access to the same object and you've got

00:07:04,400 --> 00:07:09,380
some thread scheduler deciding which

00:07:06,170 --> 00:07:13,070
thread is going to run when you have to

00:07:09,380 --> 00:07:15,470
think very carefully about how you write

00:07:13,070 --> 00:07:17,120
your code such that you don't make

00:07:15,470 --> 00:07:19,100
mistakes where two things try and write

00:07:17,120 --> 00:07:21,590
to the same thing at once and expect

00:07:19,100 --> 00:07:23,960
something to happen so threading has a

00:07:21,590 --> 00:07:26,440
bit of a problem in terms of cognitive

00:07:23,960 --> 00:07:28,670
load on someone reading threaded code

00:07:26,440 --> 00:07:30,740
the third one I have here is called

00:07:28,670 --> 00:07:33,290
green threads so in Python we're talking

00:07:30,740 --> 00:07:36,710
about things like G event or our green

00:07:33,290 --> 00:07:39,110
'lets and basically the rough summary of

00:07:36,710 --> 00:07:40,700
this is that it's threads but instead of

00:07:39,110 --> 00:07:42,920
being managed by your operating system

00:07:40,700 --> 00:07:45,530
it's managed by your third party library

00:07:42,920 --> 00:07:47,210
so you're still doing switching between

00:07:45,530 --> 00:07:50,630
between these green lights between these

00:07:47,210 --> 00:07:52,190
green threads at arbitrary times you

00:07:50,630 --> 00:07:55,550
still have to worry about locking and

00:07:52,190 --> 00:07:57,410
that sort of thing one of the possible

00:07:55,550 --> 00:08:00,770
advantages of this over native operating

00:07:57,410 --> 00:08:02,720
system threads is that you're threading

00:08:00,770 --> 00:08:05,180
your green that's library may be able to

00:08:02,720 --> 00:08:06,920
optimize for your language when it's

00:08:05,180 --> 00:08:09,440
going to swap tasks or that sort of

00:08:06,920 --> 00:08:11,090
thing the disadvantage is that you don't

00:08:09,440 --> 00:08:12,860
get all of the optimizations that the

00:08:11,090 --> 00:08:15,650
operating system already has to do

00:08:12,860 --> 00:08:17,210
threads so I'm going to sort of lump

00:08:15,650 --> 00:08:18,860
those two green threads and threads in

00:08:17,210 --> 00:08:21,500
together for the purposes of this talk

00:08:18,860 --> 00:08:23,180
and the final one here is asynchronous

00:08:21,500 --> 00:08:26,030
programming and that's what we're mostly

00:08:23,180 --> 00:08:29,390
talking about in this presentation and

00:08:26,030 --> 00:08:32,750
basically what this is is we're going to

00:08:29,390 --> 00:08:35,419
do this multitasking thing by having an

00:08:32,750 --> 00:08:38,030
event loop in a single thread in a

00:08:35,419 --> 00:08:39,950
single process now this might seem like

00:08:38,030 --> 00:08:41,810
a step backwards from using threads for

00:08:39,950 --> 00:08:44,450
concurrency why would you use a single

00:08:41,810 --> 00:08:46,250
thread in a single process um so let me

00:08:44,450 --> 00:08:48,230
demonstrate what I meant about threading

00:08:46,250 --> 00:08:50,210
introducing cognitive load now I

00:08:48,230 --> 00:08:52,550
apologize it may be hard for those of

00:08:50,210 --> 00:08:54,500
you at the back to read this what I have

00:08:52,550 --> 00:08:56,330
here is an example so this is an example

00:08:54,500 --> 00:08:59,450
of code that you might write for single

00:08:56,330 --> 00:09:02,000
single threading so we have

00:08:59,450 --> 00:09:04,460
this is completely contrived I made it

00:09:02,000 --> 00:09:06,110
up just for the slide what we're doing

00:09:04,460 --> 00:09:08,810
is we're doing some loop over a bunch of

00:09:06,110 --> 00:09:11,750
URLs and we're concurrently getting

00:09:08,810 --> 00:09:13,760
getting this URL from the internet I've

00:09:11,750 --> 00:09:15,290
deliberately put something in the URL

00:09:13,760 --> 00:09:19,130
parameters so that we have to do these

00:09:15,290 --> 00:09:22,310
in order so we have to do this loop over

00:09:19,130 --> 00:09:24,020
these things what we want to do is we

00:09:22,310 --> 00:09:25,570
want to be able to run this code at the

00:09:24,020 --> 00:09:28,040
same time as something else is happening

00:09:25,570 --> 00:09:30,410
now if we're going to do this using

00:09:28,040 --> 00:09:32,750
threading what we have to think about is

00:09:30,410 --> 00:09:35,660
that at every line of code here what

00:09:32,750 --> 00:09:38,750
would happen if the scheduler said okay

00:09:35,660 --> 00:09:40,840
your thread stopped your thread you get

00:09:38,750 --> 00:09:43,970
to start what happens if another thread

00:09:40,840 --> 00:09:45,980
if the process gets interrupted during

00:09:43,970 --> 00:09:47,510
this and another thread gets to run that

00:09:45,980 --> 00:09:50,230
could happen between statements here

00:09:47,510 --> 00:09:53,180
could happen inside function calls here

00:09:50,230 --> 00:09:55,010
so those of you who have done a fair bit

00:09:53,180 --> 00:09:57,610
with threading you'll know that there's

00:09:55,010 --> 00:09:59,930
one glaring error here and that is that

00:09:57,610 --> 00:10:02,690
see if you can't even see that on there

00:09:59,930 --> 00:10:04,520
okay is that I check whether self-taught

00:10:02,690 --> 00:10:06,020
URLs is empty and then on the following

00:10:04,520 --> 00:10:08,690
line I popped something from it if it's

00:10:06,020 --> 00:10:10,370
not empty it might become empty between

00:10:08,690 --> 00:10:12,260
there so if we're modifying this for

00:10:10,370 --> 00:10:14,210
threads we at the very least we have to

00:10:12,260 --> 00:10:17,150
make it a while true loop with a try

00:10:14,210 --> 00:10:18,680
except around around our pop do it this

00:10:17,150 --> 00:10:20,570
way this will work as long as we know

00:10:18,680 --> 00:10:24,200
that the pop of whatever self dot URLs

00:10:20,570 --> 00:10:25,760
is is itself thread safe also you might

00:10:24,200 --> 00:10:27,950
have something down here where you have

00:10:25,760 --> 00:10:29,390
to introduce a lock because you but have

00:10:27,950 --> 00:10:31,280
multiple threads dealing with the same

00:10:29,390 --> 00:10:33,560
resource so this is the sort of thing

00:10:31,280 --> 00:10:37,550
you have to think about when you are

00:10:33,560 --> 00:10:38,840
dealing with thready so async you don't

00:10:37,550 --> 00:10:41,330
have to worry about this sort of thing

00:10:38,840 --> 00:10:42,860
because and whereas with threading you

00:10:41,330 --> 00:10:44,450
have some thread scheduler in the

00:10:42,860 --> 00:10:47,180
operating system or in your language

00:10:44,450 --> 00:10:50,420
that's saying okay this thread stops

00:10:47,180 --> 00:10:53,270
this thread goes with asynchronous

00:10:50,420 --> 00:10:55,610
programming basically once the event

00:10:53,270 --> 00:10:57,560
loop has started a task the task can do

00:10:55,610 --> 00:11:00,410
whatever it likes until it says to the

00:10:57,560 --> 00:11:02,930
event loop okay I'm done now or it says

00:11:00,410 --> 00:11:04,850
alright I'm going to go to sleep and I

00:11:02,930 --> 00:11:06,530
want you to wake me next time we have

00:11:04,850 --> 00:11:08,000
data on this particular socket or

00:11:06,530 --> 00:11:10,040
something like that so you have this

00:11:08,000 --> 00:11:12,470
explicit scheduling so this is called

00:11:10,040 --> 00:11:13,070
cooperative multitasking where your task

00:11:12,470 --> 00:11:15,410
gets to

00:11:13,070 --> 00:11:18,230
side when it's going to hand control

00:11:15,410 --> 00:11:20,000
back to the main loop so the caveat with

00:11:18,230 --> 00:11:21,500
this is that because this is cooperative

00:11:20,000 --> 00:11:23,120
multitasking you do have to be

00:11:21,500 --> 00:11:25,520
cooperative

00:11:23,120 --> 00:11:28,520
you have to write functions that are not

00:11:25,520 --> 00:11:31,940
going to say are excellent the main loop

00:11:28,520 --> 00:11:34,340
has given me control I will calculate pi

00:11:31,940 --> 00:11:36,890
250 decimal places and then return

00:11:34,340 --> 00:11:38,690
control if you have long-running things

00:11:36,890 --> 00:11:40,850
the rest of your program is never going

00:11:38,690 --> 00:11:45,500
to get to run so that's the caveat on

00:11:40,850 --> 00:11:47,690
that so the trade-off I guess so on to

00:11:45,500 --> 00:11:52,670
what async IO is a bit of history of

00:11:47,690 --> 00:11:54,350
async in Python so in 1999 Python 1.5.2

00:11:52,670 --> 00:11:57,770
shipped with these modules called

00:11:54,350 --> 00:12:01,910
async core and async chat or async hat

00:11:57,770 --> 00:12:03,560
if you pronounce the single see the

00:12:01,910 --> 00:12:06,620
thing with these modules is that they're

00:12:03,560 --> 00:12:10,940
very rigid very few people use them it's

00:12:06,620 --> 00:12:12,800
hard to extend 2002 twisted 1.0 was

00:12:10,940 --> 00:12:15,530
released twisted gives you an async

00:12:12,800 --> 00:12:17,450
framework and that was basically the

00:12:15,530 --> 00:12:18,050
main async framework to use for a number

00:12:17,450 --> 00:12:22,070
of years

00:12:18,050 --> 00:12:24,620
come 2009 - mm oh sorry I missed this

00:12:22,070 --> 00:12:27,350
one 2006 now this may not seem async

00:12:24,620 --> 00:12:29,330
related but when python 2.5 was released

00:12:27,350 --> 00:12:31,190
it had this interesting thing where

00:12:29,330 --> 00:12:33,860
generators that's functions that can

00:12:31,190 --> 00:12:37,610
yield you can push values send values

00:12:33,860 --> 00:12:40,430
back into the generators that has some

00:12:37,610 --> 00:12:42,890
interesting repercussions for async in

00:12:40,430 --> 00:12:45,200
terms of being able to write co-routines

00:12:42,890 --> 00:12:47,030
that you can read nicely so I'll show

00:12:45,200 --> 00:12:48,890
you an example of that later but you

00:12:47,030 --> 00:12:53,780
couldn't do that into a python 2.5 was

00:12:48,890 --> 00:12:55,700
was released then 2009 to 2011

00:12:53,780 --> 00:12:57,560
you had frameworks like tornado as well

00:12:55,700 --> 00:12:59,780
as a lot of web frameworks that gained

00:12:57,560 --> 00:13:01,790
popularity that did some async stuff and

00:12:59,780 --> 00:13:05,480
there was a revived interest in this

00:13:01,790 --> 00:13:07,640
idea of async programming so the problem

00:13:05,480 --> 00:13:09,830
was that there was no one obvious way of

00:13:07,640 --> 00:13:11,870
doing it because you could do it the

00:13:09,830 --> 00:13:15,560
twisted way or that's a tornado way or

00:13:11,870 --> 00:13:18,230
any one of these other frameworks but

00:13:15,560 --> 00:13:19,790
they were different so the Python

00:13:18,230 --> 00:13:22,730
community recognized this was a problem

00:13:19,790 --> 00:13:25,250
came together and put together this pep

00:13:22,730 --> 00:13:26,690
called pep 31 53 which was a very

00:13:25,250 --> 00:13:29,090
abstract pep

00:13:26,690 --> 00:13:30,860
sort of saying what we'd like a sink

00:13:29,090 --> 00:13:33,830
stuff to do in providing some sort of

00:13:30,860 --> 00:13:36,260
idea about how network stuff should look

00:13:33,830 --> 00:13:38,840
on a sink didn't really achieve much

00:13:36,260 --> 00:13:41,480
concrete and but what it did achieve was

00:13:38,840 --> 00:13:43,280
it got people talking about this and so

00:13:41,480 --> 00:13:47,600
a year and a half later at the end of

00:13:43,280 --> 00:13:49,760
2012 we had pep 3156 and this is what a

00:13:47,600 --> 00:13:53,360
sink i/o module is based on originally

00:13:49,760 --> 00:13:56,210
codenamed chulip and this provides a

00:13:53,360 --> 00:13:59,780
whole bunch of clear ideas about what

00:13:56,210 --> 00:14:01,100
the async interfaces for piping should

00:13:59,780 --> 00:14:04,370
be as well as a reference implementation

00:14:01,100 --> 00:14:06,560
for it and that reference implementation

00:14:04,370 --> 00:14:09,440
is async IO which we have in the Python

00:14:06,560 --> 00:14:12,800
3.4 standard library as well as being

00:14:09,440 --> 00:14:14,960
able to pip install it in Python 3.3 you

00:14:12,800 --> 00:14:17,210
can't use it as is earlier than that

00:14:14,960 --> 00:14:18,710
because the language syntax doesn't

00:14:17,210 --> 00:14:23,870
support some of the stuff that async oh

00:14:18,710 --> 00:14:25,610
it does so that's the history of it how

00:14:23,870 --> 00:14:27,290
do you use it so the first thing that

00:14:25,610 --> 00:14:30,170
you need to know is that async I owed

00:14:27,290 --> 00:14:31,550
the implementation is an event loop so

00:14:30,170 --> 00:14:34,280
you need to get the event loop you need

00:14:31,550 --> 00:14:37,280
to know how to start it so there's this

00:14:34,280 --> 00:14:40,970
function called run forever basically

00:14:37,280 --> 00:14:44,690
says start this loop this event loop run

00:14:40,970 --> 00:14:46,280
it until someone calls stop you also

00:14:44,690 --> 00:14:48,680
have this one here called run into a

00:14:46,280 --> 00:14:50,210
complete I'm so a sinker has a thing

00:14:48,680 --> 00:14:51,320
called a future which represents

00:14:50,210 --> 00:14:54,050
something that hasn't finished yet

00:14:51,320 --> 00:14:55,670
I'll explain those in a sec I run into a

00:14:54,050 --> 00:14:57,350
complete you pass in a future and it

00:14:55,670 --> 00:14:59,920
will run the main loop until this future

00:14:57,350 --> 00:15:02,690
is done and then return control to you

00:14:59,920 --> 00:15:06,980
so how this would look if you were start

00:15:02,690 --> 00:15:08,840
writing an async i/o program you in your

00:15:06,980 --> 00:15:10,720
main function you'd start a bunch of

00:15:08,840 --> 00:15:12,860
async things start something's listening

00:15:10,720 --> 00:15:13,310
get the event loop and tell it to run

00:15:12,860 --> 00:15:18,010
forever

00:15:13,310 --> 00:15:19,910
there's your simple async i/o program

00:15:18,010 --> 00:15:22,130
scheduling things so when you're writing

00:15:19,910 --> 00:15:25,160
an async program you cannot say time dot

00:15:22,130 --> 00:15:27,110
sleep because time that sleep says ah I

00:15:25,160 --> 00:15:29,690
have control of the flow of execution

00:15:27,110 --> 00:15:33,490
I'm going to go to sleep and not return

00:15:29,690 --> 00:15:36,410
control to the event loop this is not

00:15:33,490 --> 00:15:37,910
very cooperative so here are some

00:15:36,410 --> 00:15:40,220
functions that you can use in a sink i/o

00:15:37,910 --> 00:15:43,790
your you call on your event

00:15:40,220 --> 00:15:44,900
call soon and that means okay event loop

00:15:43,790 --> 00:15:47,720
next time you have the opportunity

00:15:44,900 --> 00:15:49,070
please call this function and that gives

00:15:47,720 --> 00:15:50,660
you the guarantee that the order that

00:15:49,070 --> 00:15:52,190
you call the call soon's will be the

00:15:50,660 --> 00:15:54,290
order that the main live calls the

00:15:52,190 --> 00:15:56,960
functions which is useful in some

00:15:54,290 --> 00:15:58,550
situations you have call later where you

00:15:56,960 --> 00:16:00,620
give it how many seconds time you want

00:15:58,550 --> 00:16:02,780
it to call this callback and then you

00:16:00,620 --> 00:16:04,850
have call out which is saying call it at

00:16:02,780 --> 00:16:08,810
this particular time and of course this

00:16:04,850 --> 00:16:10,550
event loop time function because you can

00:16:08,810 --> 00:16:12,620
even though async area provides a

00:16:10,550 --> 00:16:14,000
reference implementation for the main

00:16:12,620 --> 00:16:15,650
loop you could write other

00:16:14,000 --> 00:16:17,540
implementations they're not guaranteed

00:16:15,650 --> 00:16:19,130
to or use time that time they might use

00:16:17,540 --> 00:16:21,860
time that monatomic that might be a good

00:16:19,130 --> 00:16:23,120
idea if you call event loop time that's

00:16:21,860 --> 00:16:27,350
going to give you what the event loop

00:16:23,120 --> 00:16:29,810
says is the time now so okay so we can

00:16:27,350 --> 00:16:31,940
do scheduling we can start the event

00:16:29,810 --> 00:16:34,580
loop how do we do things that are going

00:16:31,940 --> 00:16:36,170
to take a while I say I think I has this

00:16:34,580 --> 00:16:37,700
idea of something called a future and a

00:16:36,170 --> 00:16:39,650
future basically is an object

00:16:37,700 --> 00:16:42,290
representing something that may not have

00:16:39,650 --> 00:16:47,000
finished yet but someday it will either

00:16:42,290 --> 00:16:49,430
finish or it'll fail so if you call a

00:16:47,000 --> 00:16:51,260
function that returns a future these are

00:16:49,430 --> 00:16:53,420
the things that you can do with it you

00:16:51,260 --> 00:16:55,670
can add a done callback that says once

00:16:53,420 --> 00:16:58,490
this is complete or fails call this

00:16:55,670 --> 00:17:01,760
function that function in the callback

00:16:58,490 --> 00:17:03,740
can then call dot result to get what the

00:17:01,760 --> 00:17:06,080
result of that call was or dot exception

00:17:03,740 --> 00:17:07,880
to say what went wrong the interesting

00:17:06,080 --> 00:17:11,930
thing about the dot result function here

00:17:07,880 --> 00:17:13,640
is that if the function that returned

00:17:11,930 --> 00:17:15,830
the future if there was a failure so

00:17:13,640 --> 00:17:17,360
there's an exception in this future when

00:17:15,830 --> 00:17:19,940
you call dot result it will rear a x'

00:17:17,360 --> 00:17:21,350
that exception for you so you have to be

00:17:19,940 --> 00:17:23,510
aware of that when you call dot result

00:17:21,350 --> 00:17:26,390
that's the point that exceptions could

00:17:23,510 --> 00:17:28,130
be bubbling up from this future so what

00:17:26,390 --> 00:17:31,130
this could look like supposing I wanted

00:17:28,130 --> 00:17:32,390
to write a function that words so I'm

00:17:31,130 --> 00:17:33,950
going to assume that I already have a

00:17:32,390 --> 00:17:34,550
function available that will do a web

00:17:33,950 --> 00:17:36,380
request

00:17:34,550 --> 00:17:38,210
give me a future and when that web

00:17:36,380 --> 00:17:40,790
request is done it will call back the

00:17:38,210 --> 00:17:43,400
future with the result and I want to

00:17:40,790 --> 00:17:45,440
write a function that is going to do

00:17:43,400 --> 00:17:47,780
that web request and then decode the

00:17:45,440 --> 00:17:50,900
result as JSON for example and return

00:17:47,780 --> 00:17:51,440
that back that would look something like

00:17:50,900 --> 00:17:53,210
this

00:17:51,440 --> 00:17:56,330
so we have

00:17:53,210 --> 00:17:57,860
here we're going to create a future for

00:17:56,330 --> 00:18:00,320
our function because we have to return a

00:17:57,860 --> 00:18:01,580
future I should mention this is not

00:18:00,320 --> 00:18:03,679
actually the best way of doing it using

00:18:01,580 --> 00:18:05,059
async i/o this is demoing futures I'll

00:18:03,679 --> 00:18:07,399
show you a better way of doing it using

00:18:05,059 --> 00:18:09,440
async arrow in a sec but using futures

00:18:07,399 --> 00:18:10,940
this is how you would do it at the top

00:18:09,440 --> 00:18:13,610
here we create a future that we're going

00:18:10,940 --> 00:18:17,960
to return to the users because we're a

00:18:13,610 --> 00:18:19,429
function that takes time then I'm going

00:18:17,960 --> 00:18:21,740
to call this get page function that

00:18:19,429 --> 00:18:23,480
returns me a future and add a callback

00:18:21,740 --> 00:18:26,270
to it saying once you're done do this

00:18:23,480 --> 00:18:29,419
now in this page data received function

00:18:26,270 --> 00:18:31,730
here you'll see that I get the result of

00:18:29,419 --> 00:18:33,710
the page future in a try except because

00:18:31,730 --> 00:18:35,510
if that raises an exception I want to

00:18:33,710 --> 00:18:37,390
call set exception on my result future

00:18:35,510 --> 00:18:40,730
to let it propagate back to my caller

00:18:37,390 --> 00:18:43,070
otherwise i decode the data as JSON and

00:18:40,730 --> 00:18:45,200
return it and I return my future so this

00:18:43,070 --> 00:18:46,850
is a little bit complicated but you can

00:18:45,200 --> 00:18:48,799
see that this is sort of how futures

00:18:46,850 --> 00:18:51,200
work you set a callback it gets called

00:18:48,799 --> 00:18:53,120
you get the result from it the thing is

00:18:51,200 --> 00:18:54,470
that I was complaining before about how

00:18:53,120 --> 00:18:57,470
with threading you have to think really

00:18:54,470 --> 00:18:59,360
hard when you're reading the code in

00:18:57,470 --> 00:19:01,399
order to be sure you know what it's

00:18:59,360 --> 00:19:02,870
going to do now you don't have to reason

00:19:01,399 --> 00:19:04,760
really hard to be sure you know what

00:19:02,870 --> 00:19:06,980
this is going to do but it is kind of

00:19:04,760 --> 00:19:10,480
hard to read like you look at this code

00:19:06,980 --> 00:19:12,649
and you think why is it doing that

00:19:10,480 --> 00:19:14,299
especially since this is trying to do

00:19:12,649 --> 00:19:18,110
something simple basically this is

00:19:14,299 --> 00:19:20,779
trying to say get a webpage decode it as

00:19:18,110 --> 00:19:22,399
JSON return it I'm so this is where

00:19:20,779 --> 00:19:24,080
co-routines come in if you're writing

00:19:22,399 --> 00:19:26,149
something that is essentially a linear

00:19:24,080 --> 00:19:28,159
sequence of steps but you want to be

00:19:26,149 --> 00:19:30,679
nice and returned control to the reactor

00:19:28,159 --> 00:19:32,390
you can use something in async Oh called

00:19:30,679 --> 00:19:34,279
co-routines and so this is what this

00:19:32,390 --> 00:19:39,380
code would look like using co-routines

00:19:34,279 --> 00:19:42,140
a little bit simply you might say data

00:19:39,380 --> 00:19:44,750
equals yield from get page return JSON

00:19:42,140 --> 00:19:46,669
notice of data so basically what you

00:19:44,750 --> 00:19:48,440
need to know here is that the words

00:19:46,669 --> 00:19:50,470
yield from here now this is a syntax

00:19:48,440 --> 00:19:53,360
feature of Python from three-point-three

00:19:50,470 --> 00:19:58,070
it's used for generators to be able to

00:19:53,360 --> 00:20:00,710
call other generators what it's you

00:19:58,070 --> 00:20:02,690
overloaded to mean in async i/o is wait

00:20:00,710 --> 00:20:04,820
for this return control to the main loop

00:20:02,690 --> 00:20:06,919
and tell it to wake me when this is done

00:20:04,820 --> 00:20:11,149
so you can yield from

00:20:06,919 --> 00:20:12,799
future that means return control to the

00:20:11,149 --> 00:20:15,230
event loop and then you decorate your

00:20:12,799 --> 00:20:20,960
co-routines with the async taco routine

00:20:15,230 --> 00:20:23,720
decorator so the code that we had before

00:20:20,960 --> 00:20:25,820
that was doing lots of a loop over URLs

00:20:23,720 --> 00:20:28,220
doing gets of that this is what it looks

00:20:25,820 --> 00:20:30,649
like in a single thread without async

00:20:28,220 --> 00:20:32,570
what it would look like with async is

00:20:30,649 --> 00:20:35,299
you decorate it with co-routine and you

00:20:32,570 --> 00:20:36,799
change your URL open to whatever this

00:20:35,299 --> 00:20:39,470
function is that returns a future and

00:20:36,799 --> 00:20:41,929
yield from and that's all you have to do

00:20:39,470 --> 00:20:43,129
so essentially what you have is if

00:20:41,929 --> 00:20:46,190
you're comparing it with threading it's

00:20:43,129 --> 00:20:47,509
like you have a lock all the time you're

00:20:46,190 --> 00:20:49,129
never going to have to worry about

00:20:47,509 --> 00:20:51,409
another thread interpreting until you

00:20:49,129 --> 00:20:52,879
explicitly say yield from so you can

00:20:51,409 --> 00:20:55,039
easily reason about this code because

00:20:52,879 --> 00:20:59,779
you know exactly where the shed EULA can

00:20:55,039 --> 00:21:01,129
shed you on another task so very briefly

00:20:59,779 --> 00:21:04,009
I want to finish to have time for

00:21:01,129 --> 00:21:08,269
questions so compatibility in theory

00:21:04,009 --> 00:21:10,940
this is compatible with other async

00:21:08,269 --> 00:21:13,159
frameworks because it defines a clear

00:21:10,940 --> 00:21:16,190
set of interfaces so it's possible to

00:21:13,159 --> 00:21:17,960
write an async i/o it's possible to

00:21:16,190 --> 00:21:20,779
write an event loop that fulfills async

00:21:17,960 --> 00:21:22,909
IOT's interfaces but does everything in

00:21:20,779 --> 00:21:24,529
the back end using twisted and doing

00:21:22,909 --> 00:21:26,619
that would allow you to use third-party

00:21:24,529 --> 00:21:28,909
code that's written purely for async i/o

00:21:26,619 --> 00:21:30,619
but run it on an event loop that's

00:21:28,909 --> 00:21:32,570
running twisted using all of your other

00:21:30,619 --> 00:21:34,789
twisted code that you've already got so

00:21:32,570 --> 00:21:36,590
this is kind of cool in practice though

00:21:34,789 --> 00:21:39,919
most of the adapters you need to do this

00:21:36,590 --> 00:21:43,940
are not actually written yet but it's a

00:21:39,919 --> 00:21:46,549
good step and then of course the also

00:21:43,940 --> 00:21:49,820
the interface definition in the pep for

00:21:46,549 --> 00:21:51,320
networking is very heavily based on the

00:21:49,820 --> 00:21:53,840
way twisted does networking so it's

00:21:51,320 --> 00:21:55,429
possible to write network protocols for

00:21:53,840 --> 00:21:57,470
different frameworks and basically write

00:21:55,429 --> 00:22:01,639
compatibility adapters between them as

00:21:57,470 --> 00:22:03,440
well ah some gotchas as i mentioned

00:22:01,639 --> 00:22:05,629
before you have to be cooperative

00:22:03,440 --> 00:22:07,879
you don't call time not sleep you don't

00:22:05,629 --> 00:22:10,100
call URL open you don't call anything

00:22:07,879 --> 00:22:11,539
that's going to take time any

00:22:10,100 --> 00:22:13,460
significant amount of time because that

00:22:11,539 --> 00:22:16,549
will stop the rest of your async program

00:22:13,460 --> 00:22:18,379
from doing anything if you have to use a

00:22:16,549 --> 00:22:20,480
third-party library that's going to do

00:22:18,379 --> 00:22:22,490
this that's not been written with a Seng

00:22:20,480 --> 00:22:24,440
in mind so it's going to do blocking

00:22:22,490 --> 00:22:25,910
calls and what you can do is you can

00:22:24,440 --> 00:22:27,830
actually put those in a thread there's a

00:22:25,910 --> 00:22:29,990
function in async i/o that will run this

00:22:27,830 --> 00:22:31,640
in a thread and return your future that

00:22:29,990 --> 00:22:33,020
will be called when it's done so it

00:22:31,640 --> 00:22:34,640
looks to the rest of your program like

00:22:33,020 --> 00:22:36,650
this is a sink but actually it's running

00:22:34,640 --> 00:22:38,710
in a thread I'm set to work around if

00:22:36,650 --> 00:22:43,929
you have to do this

00:22:38,710 --> 00:22:46,070
so my conclusion here async i/o is good

00:22:43,929 --> 00:22:47,660
use co-routines wherever possible

00:22:46,070 --> 00:22:49,040
because when you're using the

00:22:47,660 --> 00:22:51,650
co-routines you don't have to worry

00:22:49,040 --> 00:22:54,380
about the horrible callback based stuff

00:22:51,650 --> 00:22:56,630
i say horrible because the bigger your

00:22:54,380 --> 00:23:00,470
program gets the more difficult it is to

00:22:56,630 --> 00:23:03,710
read the callback stuff don't block the

00:23:00,470 --> 00:23:05,360
event loop that is bad and remember that

00:23:03,710 --> 00:23:07,370
when you're writing code readable code

00:23:05,360 --> 00:23:09,740
is maintainable code so always keep that

00:23:07,370 --> 00:23:10,340
in mind when you're programming so

00:23:09,740 --> 00:23:26,679
that's me

00:23:10,340 --> 00:23:29,960
ah and we do have time for questions um

00:23:26,679 --> 00:23:31,460
in terms of compatibility is it

00:23:29,960 --> 00:23:35,960
compatible right now with Lib main link

00:23:31,460 --> 00:23:37,640
I haven't actually used that is that is

00:23:35,960 --> 00:23:39,830
it asynchronous in the same sense as

00:23:37,640 --> 00:23:42,350
it's basically the same thing it's words

00:23:39,830 --> 00:23:44,750
used by gnome and KDE right in that case

00:23:42,350 --> 00:23:46,610
yes it would be compatible but again

00:23:44,750 --> 00:23:49,160
similar to what I said with twisters I

00:23:46,610 --> 00:23:52,010
don't think anyone's actually reason the

00:23:49,160 --> 00:23:54,040
adapters there so what it's not

00:23:52,010 --> 00:23:56,179
compatible with is things like gee event

00:23:54,040 --> 00:23:58,130
because the event is doing the green

00:23:56,179 --> 00:24:00,710
thread stuff and that is very different

00:23:58,130 --> 00:24:03,140
but if it's something like cady's main

00:24:00,710 --> 00:24:05,900
loop then it's compatible in the sense

00:24:03,140 --> 00:24:08,720
that you could write a an event loop

00:24:05,900 --> 00:24:11,090
that fulfills async i/o interface that

00:24:08,720 --> 00:24:14,330
runs using the KD main loop or live main

00:24:11,090 --> 00:24:15,950
loop um and then extension is futures in

00:24:14,330 --> 00:24:19,190
interface as well because for instance

00:24:15,950 --> 00:24:21,559
on top of Lib main loop Geely provides a

00:24:19,190 --> 00:24:24,020
data structure it's effectively

00:24:21,559 --> 00:24:28,429
identical yes the API looks almost the

00:24:24,020 --> 00:24:30,169
same could you make your features

00:24:28,429 --> 00:24:33,409
implementation actually use this under

00:24:30,169 --> 00:24:36,409
the hood so yes sir languages yeah so

00:24:33,409 --> 00:24:39,919
can along with writing your main loop

00:24:36,409 --> 00:24:42,249
for writing your implementation of an

00:24:39,919 --> 00:24:44,539
async a compatible main loop that uses

00:24:42,249 --> 00:24:47,539
live event you would you could write

00:24:44,539 --> 00:24:49,820
wrappers that basically make your your

00:24:47,539 --> 00:24:51,830
version of futures fulfill async is

00:24:49,820 --> 00:24:53,539
future interface so that any libraries

00:24:51,830 --> 00:24:56,470
that are using it can use it the same

00:24:53,539 --> 00:24:56,470
way cool thank you

00:24:58,210 --> 00:25:05,899
hi Josh hi just wondering um python

00:25:04,100 --> 00:25:07,879
overloads yield from to achieve the

00:25:05,899 --> 00:25:09,559
asynchronous results yes do you know

00:25:07,879 --> 00:25:11,509
offhand why they didn't introduce in

00:25:09,559 --> 00:25:14,720
your key word it seems to be a little

00:25:11,509 --> 00:25:16,940
bit oblique um okay I wasn't following

00:25:14,720 --> 00:25:19,909
the entire discussion and the Guido was

00:25:16,940 --> 00:25:22,100
very adamant that async IO that or

00:25:19,909 --> 00:25:24,619
chillip as it was known then had to run

00:25:22,100 --> 00:25:28,070
on Python 3 and PI 3 was already

00:25:24,619 --> 00:25:30,350
released right so he said we sure we

00:25:28,070 --> 00:25:32,360
want this in in the standard library in

00:25:30,350 --> 00:25:35,509
the future but we need to be able to run

00:25:32,360 --> 00:25:37,149
this now so I think that was part of it

00:25:35,509 --> 00:25:39,559
I don't quite know his reasoning there

00:25:37,149 --> 00:25:41,990
but essentially like when you think

00:25:39,559 --> 00:25:43,789
about it though yielding like writing Co

00:25:41,990 --> 00:25:44,600
routine is all about giving control back

00:25:43,789 --> 00:25:47,360
to the caller

00:25:44,600 --> 00:25:48,799
so it's the same sort of concept the

00:25:47,360 --> 00:25:52,279
reasoning for using yield from rather

00:25:48,799 --> 00:25:54,590
than yield is because yield from means

00:25:52,279 --> 00:25:57,080
that you from a Co routine you can yield

00:25:54,590 --> 00:25:58,999
from another Co routine and your stack

00:25:57,080 --> 00:26:02,029
trace will look perfect because the

00:25:58,999 --> 00:26:03,559
language does it's just another level in

00:26:02,029 --> 00:26:08,779
the stack you don't have to do some sort

00:26:03,559 --> 00:26:10,070
of wrapper around it yeah hey the only

00:26:08,779 --> 00:26:11,659
question that I had is I haven't been

00:26:10,070 --> 00:26:13,700
following this because I used twisted

00:26:11,659 --> 00:26:15,649
already n yeah it kind of makes it

00:26:13,700 --> 00:26:17,749
redundant but what's the community kind

00:26:15,649 --> 00:26:20,600
of membranes about on library support

00:26:17,749 --> 00:26:23,480
and all that sort of side things um ok

00:26:20,600 --> 00:26:25,730
so when you say library support I mean

00:26:23,480 --> 00:26:27,740
interested it's like okay I need to go

00:26:25,730 --> 00:26:29,210
and get track or I need to get this tool

00:26:27,740 --> 00:26:30,950
or that tool it's not something that

00:26:29,210 --> 00:26:32,330
anyone else uses it's a library written

00:26:30,950 --> 00:26:35,779
specifically for twisted it would be

00:26:32,330 --> 00:26:37,609
nice to unify the community of libraries

00:26:35,779 --> 00:26:39,499
into something that is supported by the

00:26:37,609 --> 00:26:41,450
standard library yes so there was a lot

00:26:39,499 --> 00:26:41,870
of input especially from twisting and

00:26:41,450 --> 00:26:44,570
also from

00:26:41,870 --> 00:26:45,710
tornado and from a bunch of other from

00:26:44,570 --> 00:26:48,290
key developers from a bunch of other

00:26:45,710 --> 00:26:50,240
ones into the development of this so

00:26:48,290 --> 00:26:53,660
there is community support for async i/o

00:26:50,240 --> 00:26:56,360
as a concept async IO is not going to

00:26:53,660 --> 00:26:59,330
replace all of twisted ever because

00:26:56,360 --> 00:27:01,190
async IO is focusing on the event loop

00:26:59,330 --> 00:27:05,090
like the asynchronous side of things and

00:27:01,190 --> 00:27:06,550
the I guess the interface for network

00:27:05,090 --> 00:27:08,900
stuff so that people can do it the same

00:27:06,550 --> 00:27:12,740
whereas twisted has a whole lot more in

00:27:08,900 --> 00:27:15,320
there as well but the hope from the

00:27:12,740 --> 00:27:17,750
people developing this is that people

00:27:15,320 --> 00:27:20,210
will start to work on libraries that do

00:27:17,750 --> 00:27:21,679
use the async i/o interfaces and people

00:27:20,210 --> 00:27:23,990
with frameworks like twisting or tornado

00:27:21,679 --> 00:27:26,990
will start working towards making their

00:27:23,990 --> 00:27:28,790
interfaces compatible with it so that

00:27:26,990 --> 00:27:30,980
rather than having to go and fetch a

00:27:28,790 --> 00:27:32,330
library that's purely for twisted you

00:27:30,980 --> 00:27:35,210
could fetch a library that's written

00:27:32,330 --> 00:27:36,380
just for pure async IO but runs on

00:27:35,210 --> 00:27:38,000
twisted because you brought the

00:27:36,380 --> 00:27:40,460
compatibility layer or whatever it might

00:27:38,000 --> 00:27:42,920
be yeah be nice for you know true lab

00:27:40,460 --> 00:27:48,770
enabled Django or flask or something

00:27:42,920 --> 00:27:50,059
like that yeah so for various reasons

00:27:48,770 --> 00:27:51,650
and so this will have to be the last

00:27:50,059 --> 00:27:54,320
question I've just mentioned that get

00:27:51,650 --> 00:27:56,929
all these reasons in in a program I have

00:27:54,320 --> 00:27:58,900
to start an HTTP server and SMTP server

00:27:56,929 --> 00:28:04,070
and I found them in a standard library

00:27:58,900 --> 00:28:07,970
HTTP server is ready SMTP server uses SM

00:28:04,070 --> 00:28:10,250
core are there any plans to make this

00:28:07,970 --> 00:28:11,660
sane and somehow use it user think I

00:28:10,250 --> 00:28:16,280
also I can start them together

00:28:11,660 --> 00:28:22,460
um I think plans is probably a bit too

00:28:16,280 --> 00:28:24,530
ambitious a turn maybe dreams I guess

00:28:22,460 --> 00:28:26,660
the thing is that I mean the old adage

00:28:24,530 --> 00:28:30,350
is that that the standard library is

00:28:26,660 --> 00:28:33,170
where good libraries go to die like this

00:28:30,350 --> 00:28:35,660
the standard library makes huge efforts

00:28:33,170 --> 00:28:39,080
at backwards compatibility so if you

00:28:35,660 --> 00:28:41,360
were to if you were to try and make them

00:28:39,080 --> 00:28:43,670
compatible right now you would ruin any

00:28:41,360 --> 00:28:46,309
code that already uses those HTTP and

00:28:43,670 --> 00:28:48,350
things so I think there's a hope that

00:28:46,309 --> 00:28:50,030
people will develop these sorts of

00:28:48,350 --> 00:28:52,040
things that are compatible but I

00:28:50,030 --> 00:28:53,669
wouldn't hope that the existing ones in

00:28:52,040 --> 00:28:59,849
the standard library are going to be

00:28:53,669 --> 00:29:01,320
the basis for if that makes sense or you

00:28:59,849 --> 00:29:05,820
can use twisted for exactly what you

00:29:01,320 --> 00:29:08,690
described all right if we could have a

00:29:05,820 --> 00:29:08,690
round of applause for Joe

00:29:16,980 --> 00:29:19,040

YouTube URL: https://www.youtube.com/watch?v=N4YjNKSQVAI


