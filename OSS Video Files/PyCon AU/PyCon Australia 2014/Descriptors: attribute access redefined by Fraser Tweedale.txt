Title: Descriptors: attribute access redefined by Fraser Tweedale
Publication date: 2014-08-05
Playlist: PyCon Australia 2014
Description: 
	Descriptors are a powerful feature of Python that can be used to augment or replace traditional attribute access with arbitrary behaviours.  Such versatility makes the descriptor protocol a valuable tool for any Python programmer, yet although most of us have used descriptors, fewer have implemented one.

This presentation will explain the use cases that motivate descriptors and how other features in Python fall short.  We will then look at some of the descriptors that the audience may already have used (even if they didn't know they were using descriptors!)  This will be followed with an explanation of the descriptor protocol and some implementation and usage examples.

I will discuss some of the finer details of descriptor implementation and will conclude with a look at Elk - a declarative object system authored by the presenter and inspired by Perl's Moose - and the descriptors that power it.

PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:05,310 --> 00:00:12,130
okay so in this talk we're going to look

00:00:08,380 --> 00:00:14,680
at what problem descriptors solve how

00:00:12,130 --> 00:00:18,130
descriptors are implemented and how will

00:00:14,680 --> 00:00:20,050
you use them and yeah showing something

00:00:18,130 --> 00:00:22,029
cool it uses descriptors so I'm going to

00:00:20,050 --> 00:00:24,880
show you something that I think is cool

00:00:22,029 --> 00:00:27,640
hopefully you think it's cool to a bit

00:00:24,880 --> 00:00:29,650
of assumed knowledge so if you know

00:00:27,640 --> 00:00:31,810
Python classes and you're familiar with

00:00:29,650 --> 00:00:33,730
decorator syntax you'll be fine

00:00:31,810 --> 00:00:35,470
it will also help if you are familiar

00:00:33,730 --> 00:00:39,729
with get a tree and set a tree and

00:00:35,470 --> 00:00:41,979
friends so the motivation of descriptors

00:00:39,729 --> 00:00:46,360
the first point I'd like to make is that

00:00:41,979 --> 00:00:48,400
attribute access is an abstraction in

00:00:46,360 --> 00:00:50,860
Python there's a default implementation

00:00:48,400 --> 00:00:53,979
that is to read and write values in an

00:00:50,860 --> 00:00:56,970
instance dictionary but that doesn't

00:00:53,979 --> 00:01:00,269
have to be the implementation of

00:00:56,970 --> 00:01:02,920
attribute access and there are reasons

00:01:00,269 --> 00:01:07,000
so ya the default implementation is well

00:01:02,920 --> 00:01:09,909
understood it's often appropriate but it

00:01:07,000 --> 00:01:12,460
is also useful to be able to augment or

00:01:09,909 --> 00:01:16,869
indeed replace the default behavior of

00:01:12,460 --> 00:01:19,679
attribute access so some use cases might

00:01:16,869 --> 00:01:22,380
be our ends or other data abstractions

00:01:19,679 --> 00:01:25,000
type checking or other kinds of

00:01:22,380 --> 00:01:28,570
validation callbacks

00:01:25,000 --> 00:01:31,929
so for extensibility or for audit trail

00:01:28,570 --> 00:01:34,960
you might have other use cases yeah

00:01:31,929 --> 00:01:36,729
things I haven't thought of so what

00:01:34,960 --> 00:01:39,340
about get a tree and set a tree can you

00:01:36,729 --> 00:01:41,049
use these mechanisms to do this sort of

00:01:39,340 --> 00:01:43,929
thing well yes you can but there are

00:01:41,049 --> 00:01:45,880
some limitations so you can only have

00:01:43,929 --> 00:01:49,810
one get at refer class and likewise for

00:01:45,880 --> 00:01:51,880
cetera delaÃ®tre so if you want different

00:01:49,810 --> 00:01:53,890
behaviors for attribute access in a

00:01:51,880 --> 00:01:57,460
single class you have to multiplex them

00:01:53,890 --> 00:01:59,439
all into the one method and you cannot

00:01:57,460 --> 00:02:02,319
easily share and reuse these

00:01:59,439 --> 00:02:06,520
implementations except through

00:02:02,319 --> 00:02:09,610
inheritance so we want custom attribute

00:02:06,520 --> 00:02:12,090
access behaviors we want those attribute

00:02:09,610 --> 00:02:15,459
access behaviors to be easily reusable

00:02:12,090 --> 00:02:16,980
it would be nice if we could have a

00:02:15,459 --> 00:02:19,920
declarative way

00:02:16,980 --> 00:02:22,680
to use these non-default attribute

00:02:19,920 --> 00:02:24,900
access behaviors and it would also be

00:02:22,680 --> 00:02:28,650
nice if we can easily parameterize those

00:02:24,900 --> 00:02:31,950
behaviors so you can use descriptors to

00:02:28,650 --> 00:02:33,599
do this in the standard library there

00:02:31,950 --> 00:02:35,819
are some descriptors that you have

00:02:33,599 --> 00:02:38,459
probably used so the first one is

00:02:35,819 --> 00:02:43,230
property so is there anyone who hasn't

00:02:38,459 --> 00:02:44,849
used property hands up if no one

00:02:43,230 --> 00:02:46,560
everyone's familiar with in great so

00:02:44,849 --> 00:02:50,430
property is actually implemented using

00:02:46,560 --> 00:02:53,310
descriptors there's also class method

00:02:50,430 --> 00:02:56,459
and static method and these ones are

00:02:53,310 --> 00:02:59,190
used to in the case of class method

00:02:56,459 --> 00:03:02,010
instead of having the object itself as

00:02:59,190 --> 00:03:04,260
the first argument to a method so the

00:03:02,010 --> 00:03:07,349
invocate you can replace that with the

00:03:04,260 --> 00:03:09,060
class object and with static method you

00:03:07,349 --> 00:03:11,549
just throw it out - away with the in

00:03:09,060 --> 00:03:14,060
vikander argument altogether so these

00:03:11,549 --> 00:03:16,260
are also implemented using descriptors

00:03:14,060 --> 00:03:19,799
there's also func tool star partial

00:03:16,260 --> 00:03:21,510
method and a few others but those three

00:03:19,799 --> 00:03:24,510
at the top are certainly ones that most

00:03:21,510 --> 00:03:26,370
Python programmers are familiar with but

00:03:24,510 --> 00:03:28,620
they might not have been aware that

00:03:26,370 --> 00:03:32,609
under the hood they were actually using

00:03:28,620 --> 00:03:35,639
descriptors so what's a descriptor well

00:03:32,609 --> 00:03:37,709
there's a descriptive protocol and it's

00:03:35,639 --> 00:03:40,049
these three methods so descriptor is a

00:03:37,709 --> 00:03:42,180
new style class that implements one or

00:03:40,049 --> 00:03:46,680
more of these methods these methods

00:03:42,180 --> 00:03:51,440
being done to get dunder set and dunder

00:03:46,680 --> 00:03:54,840
delete now in these method signatures

00:03:51,440 --> 00:03:57,630
self is the descriptor instance so it's

00:03:54,840 --> 00:04:01,470
an instance of a class that has these

00:03:57,630 --> 00:04:05,519
methods the owner argument here in get

00:04:01,470 --> 00:04:08,160
is the class in which you are using

00:04:05,519 --> 00:04:14,599
descriptors so it's not the descriptor

00:04:08,160 --> 00:04:20,099
class and instance is an instance of

00:04:14,599 --> 00:04:22,229
owner however in the case of get where

00:04:20,099 --> 00:04:25,260
the owner method appears if you're using

00:04:22,229 --> 00:04:27,750
get to access that attribute on the

00:04:25,260 --> 00:04:30,150
class object that's using the

00:04:27,750 --> 00:04:30,600
descriptors rather than an instance of

00:04:30,150 --> 00:04:33,120
the class

00:04:30,600 --> 00:04:35,520
then you're not dealing with an instance

00:04:33,120 --> 00:04:40,290
in that case the instance is going to be

00:04:35,520 --> 00:04:40,950
none so this is an example of a

00:04:40,290 --> 00:04:46,140
descriptor

00:04:40,950 --> 00:04:49,170
it's called type constraint and it is a

00:04:46,140 --> 00:04:53,460
new style class so it's subclasses

00:04:49,170 --> 00:04:55,980
object we have a constructor method

00:04:53,460 --> 00:04:58,470
dunder init and it just takes a

00:04:55,980 --> 00:05:01,740
constraint which will be a type or a

00:04:58,470 --> 00:05:02,970
topple of types and in the constructor

00:05:01,740 --> 00:05:05,340
we're just going to save the constraint

00:05:02,970 --> 00:05:09,330
and we're going to initialize a weak key

00:05:05,340 --> 00:05:12,360
dictionary for storing the data that

00:05:09,330 --> 00:05:16,590
we're going to store in and access in

00:05:12,360 --> 00:05:19,140
these descriptors dandy yet now this is

00:05:16,590 --> 00:05:20,970
what actually makes it a descriptor so

00:05:19,140 --> 00:05:24,240
the interpreter when it's resolving

00:05:20,970 --> 00:05:29,670
attribute access will look and see is

00:05:24,240 --> 00:05:32,480
the does the type of the object that

00:05:29,670 --> 00:05:37,560
we're performing the attribute access on

00:05:32,480 --> 00:05:40,470
for this attribute is it an object that

00:05:37,560 --> 00:05:43,430
has this method if so it's a descriptor

00:05:40,470 --> 00:05:46,640
so that's all a descriptor is and

00:05:43,430 --> 00:05:48,930
there's also a set method for this one

00:05:46,640 --> 00:05:52,830
the interesting thing that we do in this

00:05:48,930 --> 00:05:55,380
descriptor is inset where we check

00:05:52,830 --> 00:05:58,170
whether the value that we're setting is

00:05:55,380 --> 00:06:03,270
an instance or sorry is not an instance

00:05:58,170 --> 00:06:06,420
of the constraint that we supplied to

00:06:03,270 --> 00:06:10,290
the constructor in that case we raise a

00:06:06,420 --> 00:06:12,380
type error however if it is an instance

00:06:10,290 --> 00:06:15,120
then we fall through to the else and

00:06:12,380 --> 00:06:17,850
we're going to set the value in the weak

00:06:15,120 --> 00:06:20,250
key dictionary up here now the reason we

00:06:17,850 --> 00:06:22,440
used weak key dictionary is for garbage

00:06:20,250 --> 00:06:25,080
collection reasons because we're storing

00:06:22,440 --> 00:06:28,980
instance data in the descriptor rather

00:06:25,080 --> 00:06:31,500
than the instance itself we want to be

00:06:28,980 --> 00:06:33,750
able to allow that instance to fall out

00:06:31,500 --> 00:06:35,700
of scope and be garbage collected so we

00:06:33,750 --> 00:06:37,320
use a weak key dictionary otherwise

00:06:35,700 --> 00:06:39,450
we'll just hold on to that memory

00:06:37,320 --> 00:06:41,059
forever just probably not what you want

00:06:39,450 --> 00:06:45,689
to do

00:06:41,059 --> 00:06:49,309
so we now have a reusable alternative

00:06:45,689 --> 00:06:51,869
implementation of attribute access and

00:06:49,309 --> 00:06:54,179
the particular implementation we have

00:06:51,869 --> 00:06:57,149
this one that checks the type of the

00:06:54,179 --> 00:07:00,029
value when we set it it's also

00:06:57,149 --> 00:07:02,129
parameterised over the constraint so you

00:07:00,029 --> 00:07:04,019
can instantiate a type constraint

00:07:02,129 --> 00:07:07,649
descriptor that checks whether something

00:07:04,019 --> 00:07:10,169
is an integer or you can check that it's

00:07:07,649 --> 00:07:14,939
a string or any arbitrary type because

00:07:10,169 --> 00:07:20,759
as you saw in the implementation it just

00:07:14,939 --> 00:07:23,669
uses the is instance facility okay great

00:07:20,759 --> 00:07:26,309
so how do we use it this is how you use

00:07:23,669 --> 00:07:29,939
a descriptor you assign an instance of a

00:07:26,309 --> 00:07:32,489
descriptor class to a class attribute in

00:07:29,939 --> 00:07:34,860
the class definition so here's a class

00:07:32,489 --> 00:07:38,039
it's just a two-dimensional point we

00:07:34,860 --> 00:07:41,009
have attributes x and y and each of

00:07:38,039 --> 00:07:44,610
these is an instance of type constraint

00:07:41,009 --> 00:07:48,419
and we use for the constraint parameter

00:07:44,610 --> 00:07:51,509
numbers dot real so that will be

00:07:48,419 --> 00:07:53,879
integers floats but not complex numbers

00:07:51,509 --> 00:07:57,209
and certainly not strings or other kinds

00:07:53,879 --> 00:07:59,789
of crazy things then we have a

00:07:57,209 --> 00:08:03,179
constructor method that just takes the X

00:07:59,789 --> 00:08:07,050
and the y and sets self dot x equals x

00:08:03,179 --> 00:08:10,019
self dot y equals y but if you construct

00:08:07,050 --> 00:08:11,849
this with a string or a complex number

00:08:10,019 --> 00:08:13,949
you're going to get a type error when

00:08:11,849 --> 00:08:16,679
you construct it because at this point

00:08:13,949 --> 00:08:20,519
here the descriptors done the set method

00:08:16,679 --> 00:08:23,999
is going to be invoked and it's going to

00:08:20,519 --> 00:08:26,669
perform that type check so this is just

00:08:23,999 --> 00:08:28,889
an example of a fairly simple descriptor

00:08:26,669 --> 00:08:30,599
and a fairly simple class using that

00:08:28,889 --> 00:08:33,329
descriptor but you can see you have the

00:08:30,599 --> 00:08:36,899
advantage of type checking and that type

00:08:33,329 --> 00:08:39,089
checker descriptor can be reused in any

00:08:36,899 --> 00:08:41,459
class you want and because it's

00:08:39,089 --> 00:08:44,189
parameterised parameterised over the

00:08:41,459 --> 00:08:45,569
constraint so the types that you're

00:08:44,189 --> 00:08:47,850
interested in constraining that

00:08:45,569 --> 00:08:49,620
attribute to you can reuse it in all

00:08:47,850 --> 00:08:52,170
kinds of different situations too if you

00:08:49,620 --> 00:08:53,639
have a class that you you know have

00:08:52,170 --> 00:08:54,060
attributes that are supposed to be

00:08:53,639 --> 00:08:56,580
strings

00:08:54,060 --> 00:08:59,550
then you can instantiate a type

00:08:56,580 --> 00:09:01,440
constraint descriptor with an argument

00:08:59,550 --> 00:09:03,540
of string and it'll make sure that you

00:09:01,440 --> 00:09:08,700
can only ever set a string for that

00:09:03,540 --> 00:09:11,010
attribute okay so the example on the

00:09:08,700 --> 00:09:13,500
previous slide uses two type constraint

00:09:11,010 --> 00:09:17,550
descriptor instances one for X 1 for Y

00:09:13,500 --> 00:09:20,580
and they use declaratively so it's as

00:09:17,550 --> 00:09:23,760
though you are saying x and y is

00:09:20,580 --> 00:09:26,550
constrained to real numbers I think

00:09:23,760 --> 00:09:28,950
you'll agree that you know this fairly

00:09:26,550 --> 00:09:33,960
fairly literate code it's clear what

00:09:28,950 --> 00:09:35,820
that's supposed to be doing now we could

00:09:33,960 --> 00:09:39,000
use other kinds of descriptors alongside

00:09:35,820 --> 00:09:40,290
x and y so this gets around the problem

00:09:39,000 --> 00:09:43,380
with guitarra where we would have to

00:09:40,290 --> 00:09:45,660
multiplex these different behaviors into

00:09:43,380 --> 00:09:48,960
a single implementation of get a char or

00:09:45,660 --> 00:09:50,700
likewise with set addre in this case if

00:09:48,960 --> 00:09:53,010
we have two different attributes that we

00:09:50,700 --> 00:09:54,690
want different behaviors for we just use

00:09:53,010 --> 00:09:58,770
the appropriate descriptor for each of

00:09:54,690 --> 00:10:01,980
them okay another example is class

00:09:58,770 --> 00:10:03,990
method so who's is anyone not familiar

00:10:01,980 --> 00:10:08,700
with class method I did explain it

00:10:03,990 --> 00:10:11,160
briefly before okay so in this case

00:10:08,700 --> 00:10:14,040
again we have a constructor this one's

00:10:11,160 --> 00:10:16,790
going to take a function now that allows

00:10:14,040 --> 00:10:19,680
us to use it with the decorator syntax

00:10:16,790 --> 00:10:21,480
we have a done to get no dunder set

00:10:19,680 --> 00:10:26,040
because it doesn't make make a lot of

00:10:21,480 --> 00:10:30,150
sense in this case and in Dunton yet we

00:10:26,040 --> 00:10:32,580
simply take the original function and

00:10:30,150 --> 00:10:34,680
wrap it up in a new function that just

00:10:32,580 --> 00:10:38,730
takes an arbitrary number of positional

00:10:34,680 --> 00:10:43,200
and keyword arguments and we then call

00:10:38,730 --> 00:10:45,300
the stored function with the owner so

00:10:43,200 --> 00:10:47,520
that's the class on which this

00:10:45,300 --> 00:10:50,700
descriptor is being used as the first

00:10:47,520 --> 00:10:53,630
argument and then just splat out the

00:10:50,700 --> 00:10:58,230
positional and the keyword arguments and

00:10:53,630 --> 00:11:00,630
return the new function and so that

00:10:58,230 --> 00:11:04,500
allows us to use this descriptor just

00:11:00,630 --> 00:11:06,340
like the built-in class method decorator

00:11:04,500 --> 00:11:09,550
in the standard library

00:11:06,340 --> 00:11:11,610
so we have a food class here we use the

00:11:09,550 --> 00:11:16,690
class method descriptor we just defined

00:11:11,610 --> 00:11:18,190
with the decorator syntax and in this

00:11:16,690 --> 00:11:19,540
case you know it's just an example so

00:11:18,190 --> 00:11:22,240
we're going to say hey yeah you know we

00:11:19,540 --> 00:11:24,040
call the class method okay right so

00:11:22,240 --> 00:11:25,570
that's just another example of a

00:11:24,040 --> 00:11:29,529
different kind of descriptor you can

00:11:25,570 --> 00:11:32,110
define and how you would use it so

00:11:29,529 --> 00:11:35,230
implementing descriptors they've been

00:11:32,110 --> 00:11:38,470
around since python 2.2 there in all of

00:11:35,230 --> 00:11:42,820
the alternative implementations so you

00:11:38,470 --> 00:11:44,050
can almost certainly use descriptors if

00:11:42,820 --> 00:11:45,910
it wasn't apparent I'd just like to

00:11:44,050 --> 00:11:48,490
reiterate the point that a single

00:11:45,910 --> 00:11:51,880
descriptor instance for a given

00:11:48,490 --> 00:11:55,210
attribute is shared by all instances of

00:11:51,880 --> 00:11:56,410
that class so with the type constraint

00:11:55,210 --> 00:12:00,130
example it doesn't matter how many

00:11:56,410 --> 00:12:02,350
points you instantiate there's only ever

00:12:00,130 --> 00:12:04,660
going to be one instance of descriptor

00:12:02,350 --> 00:12:06,700
for X and another instance of descriptor

00:12:04,660 --> 00:12:11,440
for y and that's it just two instances

00:12:06,700 --> 00:12:13,990
of the descriptor object and you can

00:12:11,440 --> 00:12:18,520
implement descriptors using the C API if

00:12:13,990 --> 00:12:19,900
you need to do that for some reason so

00:12:18,520 --> 00:12:23,500
some other implementation considerations

00:12:19,900 --> 00:12:28,630
when keys collide so if you have data in

00:12:23,500 --> 00:12:30,640
an instance dictionary keyed by the same

00:12:28,630 --> 00:12:32,350
key as something in the class dictionary

00:12:30,640 --> 00:12:34,540
and that's something is a descriptor

00:12:32,350 --> 00:12:38,920
just stay with me it's it's a little bit

00:12:34,540 --> 00:12:42,070
convoluted what happens okay so

00:12:38,920 --> 00:12:44,920
descriptors that define get and set are

00:12:42,070 --> 00:12:47,950
called data descriptors those that only

00:12:44,920 --> 00:12:50,230
define get are called non-data

00:12:47,950 --> 00:12:51,790
descriptor z' so the class method

00:12:50,230 --> 00:12:54,820
example would be an example of a

00:12:51,790 --> 00:12:57,610
non-data descriptor so what's the

00:12:54,820 --> 00:13:00,400
difference the key collision for a

00:12:57,610 --> 00:13:02,500
descriptor in a class dictionary and a

00:13:00,400 --> 00:13:04,750
value in an instance dictionary for data

00:13:02,500 --> 00:13:08,800
descriptors the descriptor mechanism

00:13:04,750 --> 00:13:10,540
always takes precedence so the data in

00:13:08,800 --> 00:13:13,270
the instance dictionary will be ignored

00:13:10,540 --> 00:13:16,240
in all cases but for a non-data

00:13:13,270 --> 00:13:17,610
descriptor the instance dictionary will

00:13:16,240 --> 00:13:19,530
take precedence

00:13:17,610 --> 00:13:21,210
so you're probably not going to run into

00:13:19,530 --> 00:13:23,460
issues with this but it is important to

00:13:21,210 --> 00:13:25,680
know what the interpreter is actually

00:13:23,460 --> 00:13:29,190
doing when it resolves the attribute

00:13:25,680 --> 00:13:31,890
access so to define a read-only data

00:13:29,190 --> 00:13:34,740
descriptor you must implement under set

00:13:31,890 --> 00:13:36,930
but in that case you would just raise an

00:13:34,740 --> 00:13:39,750
attribute error and say hey sorry I'm

00:13:36,930 --> 00:13:44,370
read-only you will need to define a

00:13:39,750 --> 00:13:46,680
under set storing values okay so if

00:13:44,370 --> 00:13:48,750
you're going to use descriptors as a

00:13:46,680 --> 00:13:51,000
data abstraction and you do need to

00:13:48,750 --> 00:13:53,730
store data somewhere you need to decide

00:13:51,000 --> 00:13:56,670
where to store it so you have two main

00:13:53,730 --> 00:13:59,010
avenues here you could store it against

00:13:56,670 --> 00:14:02,940
the instance so somewhere in the

00:13:59,010 --> 00:14:05,760
instance dictionary of the instance of

00:14:02,940 --> 00:14:09,900
the class using the descriptor not the

00:14:05,760 --> 00:14:11,730
descriptor instance or you could store

00:14:09,900 --> 00:14:13,500
it in the descriptor object itself and

00:14:11,730 --> 00:14:17,790
that's what we did in the week key

00:14:13,500 --> 00:14:19,860
dictionary example we saw just before so

00:14:17,790 --> 00:14:22,920
I prefer storing it in the instance

00:14:19,860 --> 00:14:25,110
dictionary somewhere somehow because I

00:14:22,920 --> 00:14:27,810
think instance data should be owned by

00:14:25,110 --> 00:14:29,820
the instance object and it also does

00:14:27,810 --> 00:14:32,310
away with any issues around garbage

00:14:29,820 --> 00:14:34,260
collection once your object falls out of

00:14:32,310 --> 00:14:36,450
scope it can go and get garbage

00:14:34,260 --> 00:14:38,790
collected and you don't need any extra

00:14:36,450 --> 00:14:42,630
mechanisms in your descriptor to handle

00:14:38,790 --> 00:14:45,060
that scenario however there may be

00:14:42,630 --> 00:14:46,860
something about your use case or there

00:14:45,060 --> 00:14:49,230
may be space or performance

00:14:46,860 --> 00:14:51,540
considerations that commend one

00:14:49,230 --> 00:14:54,690
particular approach over the other if

00:14:51,540 --> 00:14:56,870
you're not sure try both ways do some

00:14:54,690 --> 00:15:00,120
empirical testing work out what the

00:14:56,870 --> 00:15:02,670
appropriate way of storing data is going

00:15:00,120 --> 00:15:04,370
to be in your case so I'm not telling

00:15:02,670 --> 00:15:06,960
you which way to do it I'm just saying I

00:15:04,370 --> 00:15:11,160
prefer a particular way where it's

00:15:06,960 --> 00:15:13,920
feasible descriptors and metaclasses

00:15:11,160 --> 00:15:15,540
okay so I've heard a few people at the

00:15:13,920 --> 00:15:18,720
conference here saying our medical asses

00:15:15,540 --> 00:15:21,690
you know don't use the 99% of the time

00:15:18,720 --> 00:15:25,950
you do not need one if you want to use a

00:15:21,690 --> 00:15:28,650
matter class you must know why you need

00:15:25,950 --> 00:15:31,209
it okay I generally agree with that but

00:15:28,650 --> 00:15:33,579
I also believe in knowing your tools

00:15:31,209 --> 00:15:34,959
your tools so I would encourage people

00:15:33,579 --> 00:15:37,600
to go and actually learn about

00:15:34,959 --> 00:15:39,249
metaclasses and experiment with them not

00:15:37,600 --> 00:15:41,470
at work necessarily but just in your own

00:15:39,249 --> 00:15:43,980
free time because there are use cases

00:15:41,470 --> 00:15:47,740
where they're great

00:15:43,980 --> 00:15:49,769
so the metaclasses can look in the class

00:15:47,740 --> 00:15:52,869
dictionary when the class is defined and

00:15:49,769 --> 00:15:55,480
if it sees particular descriptors of

00:15:52,869 --> 00:15:59,709
interest it can go and can set up some

00:15:55,480 --> 00:16:01,720
additional state or set up some scaffold

00:15:59,709 --> 00:16:04,600
ups and network connections or whatever

00:16:01,720 --> 00:16:08,189
crazy things you want to do and then you

00:16:04,600 --> 00:16:10,779
can have your descriptors interact with

00:16:08,189 --> 00:16:13,240
with that extra context that the

00:16:10,779 --> 00:16:15,879
metaclass sets up you can do some pretty

00:16:13,240 --> 00:16:18,129
powerful things but make sure your use

00:16:15,879 --> 00:16:21,279
case justifies the complexity know why

00:16:18,129 --> 00:16:23,619
you're doing it I'm not going to talk

00:16:21,279 --> 00:16:25,869
more about how to use metaclasses here

00:16:23,619 --> 00:16:29,769
it's a in-depth topic for a different

00:16:25,869 --> 00:16:33,059
talk perhaps but I will not say that

00:16:29,769 --> 00:16:36,549
this is what I did in ELQ okay what ELQ

00:16:33,059 --> 00:16:38,829
ELQ is an object system for Python

00:16:36,549 --> 00:16:41,499
inspired by news for Perl

00:16:38,829 --> 00:16:43,899
so are there any any form of Perl

00:16:41,499 --> 00:16:45,839
mongers here and the other reformed

00:16:43,899 --> 00:16:51,549
filmin that's one over here okay

00:16:45,839 --> 00:16:55,240
okay so um Perl 5 has a fairly obtuse

00:16:51,549 --> 00:16:57,399
object system by default but almost

00:16:55,240 --> 00:16:59,529
anyone doing object-oriented programming

00:16:57,399 --> 00:17:03,040
in Perl is going to be using a library

00:16:59,529 --> 00:17:06,339
called the moose moose is awesome when I

00:17:03,040 --> 00:17:08,919
first went on to a Python project after

00:17:06,339 --> 00:17:13,959
writing Perl for a couple of years I

00:17:08,919 --> 00:17:16,419
really really missed moose now I did get

00:17:13,959 --> 00:17:18,429
used to Python and not having moose but

00:17:16,419 --> 00:17:20,169
I never stopped wondering what would

00:17:18,429 --> 00:17:24,069
this look like if I implemented it in

00:17:20,169 --> 00:17:25,809
Python and then one day you know I had a

00:17:24,069 --> 00:17:28,980
free weekend with not much else to do so

00:17:25,809 --> 00:17:32,380
ok great I'm gonna do it so I wrote help

00:17:28,980 --> 00:17:35,230
so the features include roles method

00:17:32,380 --> 00:17:38,140
modifiers attribute delegation default

00:17:35,230 --> 00:17:40,360
values lazy initialization read-only

00:17:38,140 --> 00:17:43,150
attributes required attributes type

00:17:40,360 --> 00:17:47,110
constraints and a whole lot more

00:17:43,150 --> 00:17:49,690
and the things with the star using

00:17:47,110 --> 00:17:51,580
descriptives somewhere in their

00:17:49,690 --> 00:17:53,970
implementation so some of those are

00:17:51,580 --> 00:17:57,250
implemented entirely using descriptors

00:17:53,970 --> 00:17:59,610
others are implemented using the

00:17:57,250 --> 00:18:04,870
descriptor you know just for one small

00:17:59,610 --> 00:18:06,550
facet of the implementation and you also

00:18:04,870 --> 00:18:10,030
get constructors for free so you don't

00:18:06,550 --> 00:18:11,500
need to write a dunder init and it works

00:18:10,030 --> 00:18:14,770
well with inheritance and there's a

00:18:11,500 --> 00:18:18,550
comprehensive test suite so this is an

00:18:14,770 --> 00:18:21,640
example so again we're going to use the

00:18:18,550 --> 00:18:25,770
two dimensional point as an example so

00:18:21,640 --> 00:18:29,860
class point and we just extend elk elk

00:18:25,770 --> 00:18:35,170
to attributes x and y and they are al

00:18:29,860 --> 00:18:37,750
got mutes this is a descriptor so we'll

00:18:35,170 --> 00:18:40,540
say they're read/write attributes the

00:18:37,750 --> 00:18:43,630
type constraint is that they must be a

00:18:40,540 --> 00:18:46,890
real number and they are required

00:18:43,630 --> 00:18:50,860
attributes they cannot be omitted and

00:18:46,890 --> 00:18:53,440
likewise for Y and just as an example of

00:18:50,860 --> 00:18:57,910
the inheritance class point 3d point and

00:18:53,440 --> 00:18:59,740
we just add in a Z attribute okay so

00:18:57,910 --> 00:19:00,250
what happens when you try to use this

00:18:59,740 --> 00:19:02,350
class

00:19:00,250 --> 00:19:03,670
well let's instantiate it with no

00:19:02,350 --> 00:19:06,670
arguments boom

00:19:03,670 --> 00:19:08,260
trace back attribute era there was a

00:19:06,670 --> 00:19:10,030
required attribute and you didn't

00:19:08,260 --> 00:19:14,860
provide it okay so we're gonna fail

00:19:10,030 --> 00:19:17,410
early that's a good thing okay well

00:19:14,860 --> 00:19:19,840
we'll supply x and y this time but that

00:19:17,410 --> 00:19:23,170
does not look like a real number and

00:19:19,840 --> 00:19:25,929
sure enough we'll get a type error I'm

00:19:23,170 --> 00:19:28,590
sorry the Y attribute must be a real

00:19:25,929 --> 00:19:31,929
number so again we're gonna fail early

00:19:28,590 --> 00:19:33,780
if you do something unreasonable that's

00:19:31,929 --> 00:19:37,300
a good thing

00:19:33,780 --> 00:19:42,340
okay well we'll construct the point at

00:19:37,300 --> 00:19:44,920
the origin X and Y has zero but then

00:19:42,340 --> 00:19:48,130
we'll try and set the attribute Y to be

00:19:44,920 --> 00:19:52,620
the string mm-hmm no sorry still can't

00:19:48,130 --> 00:19:55,980
do that still need to be a real number

00:19:52,620 --> 00:19:57,990
or if we take the attribute take the

00:19:55,980 --> 00:20:00,270
object we constructed so we have a point

00:19:57,990 --> 00:20:02,450
at the origin and we want to delete the

00:20:00,270 --> 00:20:04,590
X attribute again it's going to be

00:20:02,450 --> 00:20:06,539
prevented it's going to raise an

00:20:04,590 --> 00:20:08,760
attribute error and say sorry that was a

00:20:06,539 --> 00:20:11,210
required attribute I'm not going to let

00:20:08,760 --> 00:20:11,210
you delete it

00:20:11,750 --> 00:20:16,799
okay so that was just a very basic

00:20:14,850 --> 00:20:19,130
introduction to ELQ and what it looks

00:20:16,799 --> 00:20:21,750
like to use out some of its facilities

00:20:19,130 --> 00:20:25,080
how is it implemented let's look at the

00:20:21,750 --> 00:20:26,250
descriptors and have a look at some of

00:20:25,080 --> 00:20:29,789
the things we're doing to make this

00:20:26,250 --> 00:20:33,090
behaviour possible okay so this is the

00:20:29,789 --> 00:20:34,789
dunder get for the al-kitab ute

00:20:33,090 --> 00:20:37,169
descriptor

00:20:34,789 --> 00:20:40,470
first of all we'll I'll just mention

00:20:37,169 --> 00:20:44,159
about this decorator so because we're

00:20:40,470 --> 00:20:48,299
working with dictionaries but in the

00:20:44,159 --> 00:20:51,899
context of attribute access we want to

00:20:48,299 --> 00:20:54,990
catch key errors and raise an attribute

00:20:51,899 --> 00:20:57,029
error instead so this descriptor sorry

00:20:54,990 --> 00:21:02,760
this decorator just takes care of that

00:20:57,029 --> 00:21:07,740
for us okay ignoring this if self if

00:21:02,760 --> 00:21:12,960
instance is non return self if the ID of

00:21:07,740 --> 00:21:15,830
this descriptor or object is not in the

00:21:12,960 --> 00:21:20,429
Alcatraz dictionary on the instance and

00:21:15,830 --> 00:21:22,770
if it's not in the alt lazy sorry and if

00:21:20,429 --> 00:21:27,299
it is in the elf lazy dictionary in the

00:21:22,770 --> 00:21:31,340
instance then we're going to invoke this

00:21:27,299 --> 00:21:35,520
closure here which will construct a

00:21:31,340 --> 00:21:38,279
value for that attribute and we're going

00:21:35,520 --> 00:21:42,720
to set that so we're going to call self

00:21:38,279 --> 00:21:46,649
dot dunder set which is a descriptor

00:21:42,720 --> 00:21:49,559
method and set that value so this

00:21:46,649 --> 00:21:52,860
section of the code here is implementing

00:21:49,559 --> 00:21:55,890
the lazy initialization feature so if

00:21:52,860 --> 00:21:58,230
you have a attribute whose value is

00:21:55,890 --> 00:21:59,970
expensive to compute and you might not

00:21:58,230 --> 00:22:02,760
need it you can actually defer that

00:21:59,970 --> 00:22:04,860
computation until someone's actually

00:22:02,760 --> 00:22:05,970
asking for it then you can incur that

00:22:04,860 --> 00:22:09,420
cost set

00:22:05,970 --> 00:22:14,790
the attribute and at the end we return

00:22:09,420 --> 00:22:16,890
it now as I said earlier I personally

00:22:14,790 --> 00:22:19,980
favor storing instance data in the

00:22:16,890 --> 00:22:23,250
instance so the convention that I use is

00:22:19,980 --> 00:22:26,790
this dunder elk atrÃ¡s attribute of the

00:22:23,250 --> 00:22:29,960
instance which is a dictionary but in

00:22:26,790 --> 00:22:33,300
order to have multiple alka tributes

00:22:29,960 --> 00:22:36,060
living harmoniously side by side in the

00:22:33,300 --> 00:22:38,190
same object we need to make sure that

00:22:36,060 --> 00:22:40,590
their keys don't collide so for that we

00:22:38,190 --> 00:22:43,170
just use the ID of the descriptive

00:22:40,590 --> 00:22:47,310
instance which is going to be unique for

00:22:43,170 --> 00:22:50,850
every descriptor instance so that avoids

00:22:47,310 --> 00:22:54,150
us having to assign additional keys or

00:22:50,850 --> 00:22:55,950
names to our descriptors manually we

00:22:54,150 --> 00:22:59,160
just use the fact that every object in

00:22:55,950 --> 00:23:02,490
Python has a unique ID to key the

00:22:59,160 --> 00:23:05,220
dictionary this just returns an int in C

00:23:02,490 --> 00:23:07,200
Python it is the addressing memory of

00:23:05,220 --> 00:23:11,210
that object but that's an implementation

00:23:07,200 --> 00:23:16,470
details pretty much beside the point

00:23:11,210 --> 00:23:18,420
okay with dunder set we're going to see

00:23:16,470 --> 00:23:21,630
a few more features in play here so if

00:23:18,420 --> 00:23:24,480
the mode of self the descriptor object

00:23:21,630 --> 00:23:27,660
is read-only so you saw on the slide

00:23:24,480 --> 00:23:30,660
back before we had made equals our W

00:23:27,660 --> 00:23:31,950
readwrite but if it's read-only then

00:23:30,660 --> 00:23:34,440
we're going to say no sorry

00:23:31,950 --> 00:23:38,700
- read-only attribute gonna raise an

00:23:34,440 --> 00:23:41,850
attribute error if the type is not none

00:23:38,700 --> 00:23:45,150
so there is a type constraint and the

00:23:41,850 --> 00:23:46,650
value is not an instance of something

00:23:45,150 --> 00:23:48,270
that we've given in the type constraint

00:23:46,650 --> 00:23:50,670
then we're going to raise a type error

00:23:48,270 --> 00:23:52,980
so this is very similar to the type

00:23:50,670 --> 00:23:56,390
constraint descriptors behavior that we

00:23:52,980 --> 00:23:59,490
implemented earlier in this in the talk

00:23:56,390 --> 00:24:02,670
so yes indeed type error sorry the

00:23:59,490 --> 00:24:06,390
attribute must be a whatever this type

00:24:02,670 --> 00:24:08,400
is and then finally if we make it to the

00:24:06,390 --> 00:24:11,460
end then we're going to set that value

00:24:08,400 --> 00:24:15,040
in the Alcatraz dictionary keyed by the

00:24:11,460 --> 00:24:19,090
ID of the descriptor object

00:24:15,040 --> 00:24:22,120
and in delete again we're going to catch

00:24:19,090 --> 00:24:27,430
key errors and turn them into attribute

00:24:22,120 --> 00:24:29,320
errors and if it's a required attribute

00:24:27,430 --> 00:24:31,090
then we're going to raise attribute

00:24:29,320 --> 00:24:34,240
error sorry you can't delete that it's a

00:24:31,090 --> 00:24:36,490
required attribute otherwise we will

00:24:34,240 --> 00:24:38,740
delete that from the Alcatraz dictionary

00:24:36,490 --> 00:24:42,760
again the key is the idea of the

00:24:38,740 --> 00:24:45,160
descriptor object okay so that's all I

00:24:42,760 --> 00:24:47,230
wanted to show you hopefully I have

00:24:45,160 --> 00:24:49,750
proven to you that you can do some

00:24:47,230 --> 00:24:53,230
useful things with descriptors and that

00:24:49,750 --> 00:24:55,470
is a useful feature of Python that you

00:24:53,230 --> 00:24:58,470
hopefully will want to learn more about

00:24:55,470 --> 00:25:03,760
so that when you hit these use cases

00:24:58,470 --> 00:25:06,660
where get a tray and set etre don't

00:25:03,760 --> 00:25:09,000
quite cut it you have in your toolbox

00:25:06,660 --> 00:25:11,890
descriptors and you can go forth and

00:25:09,000 --> 00:25:14,350
implement what you would need to do in a

00:25:11,890 --> 00:25:17,560
nice elegant reusable way so what have

00:25:14,350 --> 00:25:19,900
we seen we've seen that we want reusable

00:25:17,560 --> 00:25:22,420
alternative attribute access behaviors

00:25:19,900 --> 00:25:27,070
and there are many use cases for those

00:25:22,420 --> 00:25:28,290
on zort validation etc they'd get actor

00:25:27,070 --> 00:25:30,610
and friends don't cut it

00:25:28,290 --> 00:25:33,550
but that descriptors can solve these

00:25:30,610 --> 00:25:35,110
problems we've seen the descriptive

00:25:33,550 --> 00:25:37,690
protocol and some implementation

00:25:35,110 --> 00:25:39,940
examples and some examples of how to use

00:25:37,690 --> 00:25:42,480
descriptors we've looked at a few

00:25:39,940 --> 00:25:45,820
technical trade-offs and gotchas and

00:25:42,480 --> 00:25:47,140
hopefully with the al key example i've

00:25:45,820 --> 00:25:48,460
shown you that yeah you can do some

00:25:47,140 --> 00:25:50,500
useful and powerful things with

00:25:48,460 --> 00:25:53,200
descriptors and especially when you

00:25:50,500 --> 00:25:54,850
combine them with metaclasses but make

00:25:53,200 --> 00:25:57,100
sure that your use case justifies the

00:25:54,850 --> 00:25:57,730
complexity but going on about

00:25:57,100 --> 00:26:00,820
metaclasses

00:25:57,730 --> 00:26:02,830
they're really cool resources there's

00:26:00,820 --> 00:26:06,610
the how-to guide and the data model

00:26:02,830 --> 00:26:08,290
reference in the Python Docs that's alch

00:26:06,610 --> 00:26:09,910
if you're interested in ELQ and that's

00:26:08,290 --> 00:26:11,230
moose if you're interested in moose just

00:26:09,910 --> 00:26:14,470
to see what it was that I was actually

00:26:11,230 --> 00:26:18,180
trying to accomplish and yeah thanks for

00:26:14,470 --> 00:26:18,180
listening and are there any questions

00:26:27,320 --> 00:26:41,570
can you go to the mic is it possible to

00:26:36,540 --> 00:26:45,810
chain description descriptors to change

00:26:41,570 --> 00:26:47,760
say you had a type requirement and also

00:26:45,810 --> 00:26:52,380
like an input validation and you wanted

00:26:47,760 --> 00:26:54,090
to apply them both to an attribute the

00:26:52,380 --> 00:26:56,070
descriptive protocol doesn't give you a

00:26:54,090 --> 00:26:59,550
way to do that but it might be possible

00:26:56,070 --> 00:27:01,500
to use multiple inheritance and both

00:26:59,550 --> 00:27:05,130
those descriptors and combine those

00:27:01,500 --> 00:27:09,540
behaviors in in a way that sees you not

00:27:05,130 --> 00:27:11,700
repeating yourself too much alright cool

00:27:09,540 --> 00:27:13,410
chaining of descriptors this sort of

00:27:11,700 --> 00:27:16,620
possible it was actually in some

00:27:13,410 --> 00:27:18,270
respects required the class method

00:27:16,620 --> 00:27:20,910
example you gave is actually technically

00:27:18,270 --> 00:27:22,560
wrong it's actually very you're only

00:27:20,910 --> 00:27:25,500
doing those mirroring what is actually a

00:27:22,560 --> 00:27:27,420
bug in the Python library I launched a

00:27:25,500 --> 00:27:31,680
bug about it but technically in that

00:27:27,420 --> 00:27:33,410
example in the way you I don't have even

00:27:31,680 --> 00:27:36,240
bring the slide up quickly or not but

00:27:33,410 --> 00:27:38,250
you in the get you done it's going get

00:27:36,240 --> 00:27:41,190
you were actually then calling self dot

00:27:38,250 --> 00:27:44,430
func with the class method argument

00:27:41,190 --> 00:27:46,470
that's the first target technically

00:27:44,430 --> 00:27:48,750
you're supposed to actually do a done

00:27:46,470 --> 00:27:51,540
let's go get on the we have the

00:27:48,750 --> 00:27:53,280
class method and then call the result if

00:27:51,540 --> 00:27:54,840
you're gonna honor that descriptive

00:27:53,280 --> 00:27:57,210
protocol properly when calling that rat

00:27:54,840 --> 00:27:59,310
function so I don't know quite what he

00:27:57,210 --> 00:28:01,290
meant by chaining but to me that's what

00:27:59,310 --> 00:28:04,050
I've interpreters chaining is that

00:28:01,290 --> 00:28:05,910
you're honoring the application of it

00:28:04,050 --> 00:28:08,420
descriptive protocol on something you're

00:28:05,910 --> 00:28:10,200
wrapping it should be applied down

00:28:08,420 --> 00:28:12,210
because otherwise technically you're

00:28:10,200 --> 00:28:14,450
breaking the perform object model okay

00:28:12,210 --> 00:28:16,920
right well I'd like to talk to you about

00:28:14,450 --> 00:28:19,380
your specific points about the class

00:28:16,920 --> 00:28:22,040
method example I tried it and it did

00:28:19,380 --> 00:28:24,690
work however my interpretation of the

00:28:22,040 --> 00:28:27,030
the previous question is more about

00:28:24,690 --> 00:28:28,770
composing the behavior of multiple

00:28:27,030 --> 00:28:31,860
descriptors into a single descriptor

00:28:28,770 --> 00:28:34,260
that exhibits both of those behaviors

00:28:31,860 --> 00:28:35,610
that case in terms of we're on trial

00:28:34,260 --> 00:28:37,140
whether it works or not it will it'll

00:28:35,610 --> 00:28:39,390
give you what you perceive as the

00:28:37,140 --> 00:28:41,429
desired result but if you take your

00:28:39,390 --> 00:28:43,080
class method implementation and wrap it

00:28:41,429 --> 00:28:46,170
around another class method

00:28:43,080 --> 00:28:47,660
implementation or bad example just if

00:28:46,170 --> 00:28:49,260
you were to wrap it around another

00:28:47,660 --> 00:28:51,600
decorator which happened to be

00:28:49,260 --> 00:28:54,179
implemented is scripter the fact that

00:28:51,600 --> 00:28:55,650
you have not done the descriptive

00:28:54,179 --> 00:28:58,500
protocol and the unit one means that it

00:28:55,650 --> 00:29:01,290
will now no longer function so to do

00:28:58,500 --> 00:29:03,570
with an st that's what he calls nesting

00:29:01,290 --> 00:29:06,540
yep so I see what you're getting at and

00:29:03,570 --> 00:29:08,400
yes that was a naive example and you

00:29:06,540 --> 00:29:13,770
know I'd like to to work on a better

00:29:08,400 --> 00:29:14,940
example with you shortly just great to

00:29:13,770 --> 00:29:17,370
look I really enjoyed it

00:29:14,940 --> 00:29:19,049
have you done any analysis on what sort

00:29:17,370 --> 00:29:23,429
of overhead you have with this sort of

00:29:19,049 --> 00:29:26,730
thing like inheriting from the elk mm-hm

00:29:23,429 --> 00:29:29,460
without specifically I haven't that was

00:29:26,730 --> 00:29:31,380
specifically not an objective of elk so

00:29:29,460 --> 00:29:33,390
performance you know I'd be really

00:29:31,380 --> 00:29:36,179
interested if people do want to use it

00:29:33,390 --> 00:29:37,860
or do want to profile it I'd love to

00:29:36,179 --> 00:29:40,380
find out what the performance and the

00:29:37,860 --> 00:29:44,429
overhead is like but for me it was

00:29:40,380 --> 00:29:46,410
really just an exercise in the question

00:29:44,429 --> 00:29:50,419
of what would it look like if the Moose

00:29:46,410 --> 00:29:52,440
existed in Python and how can I make a

00:29:50,419 --> 00:29:55,380
something that implements the features

00:29:52,440 --> 00:29:57,780
of moose but feels Python it feels like

00:29:55,380 --> 00:29:59,400
idiomatic Python so that was my

00:29:57,780 --> 00:30:01,380
objective without but yeah I'd be

00:29:59,400 --> 00:30:03,630
interested to to know those things yeah

00:30:01,380 --> 00:30:05,549
I suppose my question follows quite well

00:30:03,630 --> 00:30:07,470
from that do you know anyone using ilk I

00:30:05,549 --> 00:30:09,210
don't know if anyone's using it and I'd

00:30:07,470 --> 00:30:12,049
love to know if they are yeah

00:30:09,210 --> 00:30:15,660
Noddy I don't even use it for anything I

00:30:12,049 --> 00:30:18,200
just wrote it for fun okay we're out of

00:30:15,660 --> 00:30:18,200
time thank you

00:30:26,919 --> 00:30:28,980

YouTube URL: https://www.youtube.com/watch?v=xYBVjVEJtEg


