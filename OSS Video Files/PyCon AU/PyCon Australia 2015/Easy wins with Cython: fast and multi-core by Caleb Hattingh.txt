Title: Easy wins with Cython: fast and multi-core by Caleb Hattingh
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Python has often been criticised for slow runtime performance, and for the GIL which prevents multi-core concurrency. Cython provides tools for addressing both issues, and in a way that is simple enough for the average programmer to use.

This talk will show:

- How to get started with Cython
- Tools to make day-to-day Cython work easier
- How to dramatically speed up a slow function
- How to distribute work over multiple CPU cores

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:11,090 --> 00:00:16,890
okay we might make a start and let other

00:00:13,799 --> 00:00:18,540
people filter in as we go so next up we

00:00:16,890 --> 00:00:20,070
have Caleb Caleb has worked

00:00:18,540 --> 00:00:22,020
professionally both as a software

00:00:20,070 --> 00:00:24,110
developer and as a chemical engineer and

00:00:22,020 --> 00:00:26,790
has been using Python for about 14 years

00:00:24,110 --> 00:00:28,619
he's also one of Pi cons most avid

00:00:26,790 --> 00:00:32,810
retweet us and today he is here to talk

00:00:28,619 --> 00:00:32,810
to us about siphon give it up for Caleb

00:00:36,559 --> 00:00:40,500
thanks everyone for coming it means a

00:00:39,239 --> 00:00:42,840
great deal to me to be able to do this

00:00:40,500 --> 00:00:43,440
and hopefully teach you something thank

00:00:42,840 --> 00:00:46,440
you very much

00:00:43,440 --> 00:00:48,600
so is anyone else tired about hearing

00:00:46,440 --> 00:00:50,040
about how python is slow and about how

00:00:48,600 --> 00:00:51,690
the Gil present the brilliance

00:00:50,040 --> 00:00:54,510
concurrency I've been hearing that for

00:00:51,690 --> 00:00:56,760
over a decade now and in the course the

00:00:54,510 --> 00:00:58,290
work that I do the speed is a frequent

00:00:56,760 --> 00:00:59,940
concern that one has about getting a

00:00:58,290 --> 00:01:02,550
simulator to run fast and it and it's

00:00:59,940 --> 00:01:04,110
really easy to bypass and the objective

00:01:02,550 --> 00:01:05,489
of my talk today is to explain to you

00:01:04,110 --> 00:01:07,920
that there are ways you can do that and

00:01:05,489 --> 00:01:09,030
they're not that difficult so I'm going

00:01:07,920 --> 00:01:10,380
to try and make a pitch it's a sales

00:01:09,030 --> 00:01:12,119
pitch about how up there's this thing

00:01:10,380 --> 00:01:15,300
called that you can use when you really

00:01:12,119 --> 00:01:16,560
need to to go really really fast but

00:01:15,300 --> 00:01:18,000
it's easy and that and that's the point

00:01:16,560 --> 00:01:20,700
of my talk not how fast you can go but

00:01:18,000 --> 00:01:23,159
how easy it can be to get into so let's

00:01:20,700 --> 00:01:25,320
begin I'm not going to speak about this

00:01:23,159 --> 00:01:26,340
my last slide covers me and I want to

00:01:25,320 --> 00:01:28,340
make sure I have time to cover

00:01:26,340 --> 00:01:30,600
everything so I'm just gonna move on

00:01:28,340 --> 00:01:31,979
there's a lot of stuff in the world of

00:01:30,600 --> 00:01:33,600
siphon and I'm not gonna cover at all

00:01:31,979 --> 00:01:35,310
I'm going to focus on only two things

00:01:33,600 --> 00:01:36,930
the first is making a code fast and the

00:01:35,310 --> 00:01:39,240
second is how to use all the CPUs in

00:01:36,930 --> 00:01:40,950
your machine or in a cluster shared

00:01:39,240 --> 00:01:43,110
memory concurrency multi-threaded shared

00:01:40,950 --> 00:01:44,880
memory concurrency and it's going to be

00:01:43,110 --> 00:01:46,799
easy I'm going to show you really really

00:01:44,880 --> 00:01:48,330
easy way of getting into this world you

00:01:46,799 --> 00:01:50,010
don't have to know everything but it's

00:01:48,330 --> 00:01:52,710
not that hard to get a little bit of

00:01:50,010 --> 00:01:54,450
code and make it faster I'm going to

00:01:52,710 --> 00:01:55,770
hide all the noise as well so I have a

00:01:54,450 --> 00:01:56,760
tool force before dealing with setup

00:01:55,770 --> 00:02:00,330
tools so you don't have to worry about

00:01:56,760 --> 00:02:01,650
that so the question that comes up a lot

00:02:00,330 --> 00:02:04,619
online if you read forums and everything

00:02:01,650 --> 00:02:06,840
is Python fast the first good answer

00:02:04,619 --> 00:02:08,340
that usually reply with is well what do

00:02:06,840 --> 00:02:12,120
you mean by fast it needs to just be

00:02:08,340 --> 00:02:15,360
fast enough for the task at hand a much

00:02:12,120 --> 00:02:17,250
better question to ask in reply is what

00:02:15,360 --> 00:02:19,349
do you mean by Python exactly because

00:02:17,250 --> 00:02:21,989
the thing is Python itself is actually

00:02:19,349 --> 00:02:23,280
written in C and it's optimized one way

00:02:21,989 --> 00:02:25,650
to say that is to say that

00:02:23,280 --> 00:02:29,100
Python is as fast at doing what it what

00:02:25,650 --> 00:02:30,000
it intends to do but that's not what

00:02:29,100 --> 00:02:30,959
people are talking about people are

00:02:30,000 --> 00:02:34,440
talking about when they write Python

00:02:30,959 --> 00:02:36,840
code they have that it is slow right so

00:02:34,440 --> 00:02:38,040
if you're new to this world what what is

00:02:36,840 --> 00:02:40,920
really happening is a pattern is

00:02:38,040 --> 00:02:42,870
extremely dynamic Python treats your

00:02:40,920 --> 00:02:44,580
code like a box of chocolates and your

00:02:42,870 --> 00:02:47,250
variables can change type all the time

00:02:44,580 --> 00:02:48,690
so your Python code is treated like a

00:02:47,250 --> 00:02:50,069
box of chocolates and what the

00:02:48,690 --> 00:02:52,200
interpreter does is every time it sees a

00:02:50,069 --> 00:02:54,620
new variable or even same variable in a

00:02:52,200 --> 00:02:57,180
loop takes the chocolate out of the box

00:02:54,620 --> 00:02:58,739
see this you're this kind of chocolate

00:02:57,180 --> 00:03:00,300
okay I'll do that with you and then

00:02:58,739 --> 00:03:01,620
reaches in it takes another chocolate of

00:03:00,300 --> 00:03:02,790
the box and oh you're that kind of

00:03:01,620 --> 00:03:05,070
chocolate now I'll do that with you and

00:03:02,790 --> 00:03:06,900
even if you have a very very big box and

00:03:05,070 --> 00:03:08,670
every single chocolate is exactly the

00:03:06,900 --> 00:03:09,390
same time and you want to do the same

00:03:08,670 --> 00:03:11,670
thing with it

00:03:09,390 --> 00:03:13,860
Python doesn't care it will check each

00:03:11,670 --> 00:03:17,010
time to make sure that your variable is

00:03:13,860 --> 00:03:20,040
the same thing so one way to deal with

00:03:17,010 --> 00:03:22,410
that is to tell Python or some aspect of

00:03:20,040 --> 00:03:23,400
the execution engine that you are really

00:03:22,410 --> 00:03:25,050
dealing with the same thing all the time

00:03:23,400 --> 00:03:26,970
and this this is where the idea comes

00:03:25,050 --> 00:03:28,739
from that you can give the time to

00:03:26,970 --> 00:03:30,239
things in your loops and then we'll go

00:03:28,739 --> 00:03:31,380
much faster because all this machinery

00:03:30,239 --> 00:03:33,900
about checking what you're actually

00:03:31,380 --> 00:03:36,540
working with and and how to order that

00:03:33,900 --> 00:03:38,730
an execution engine goes away right so

00:03:36,540 --> 00:03:40,560
that's what cyclin does among other

00:03:38,730 --> 00:03:43,290
things for our purposes that's what it

00:03:40,560 --> 00:03:44,880
does you can tell Python what your types

00:03:43,290 --> 00:03:46,350
of your variables are so that it doesn't

00:03:44,880 --> 00:03:49,470
have to check and then it can process

00:03:46,350 --> 00:03:53,120
things efficiently part of what you need

00:03:49,470 --> 00:03:55,079
to get this to work is a compiler so

00:03:53,120 --> 00:03:56,370
I've got a slide I'm not gonna go

00:03:55,079 --> 00:03:57,690
through them but I've gotten a slide see

00:03:56,370 --> 00:03:58,859
other ways to install compilers on a

00:03:57,690 --> 00:04:01,320
bunch of different operating systems

00:03:58,859 --> 00:04:03,780
I've written a blog post which is that

00:04:01,320 --> 00:04:05,340
URL shortened link at the bottom about

00:04:03,780 --> 00:04:08,160
how you can get it set up on Windows for

00:04:05,340 --> 00:04:10,170
32-bit and 64-bit on PI to 7 and PI 3 4

00:04:08,160 --> 00:04:12,570
there are other guides as well online a

00:04:10,170 --> 00:04:15,420
quick word about Windows I open and use

00:04:12,570 --> 00:04:17,549
too much time but you can't tell people

00:04:15,420 --> 00:04:19,530
to get a real operating system if what

00:04:17,549 --> 00:04:20,910
they work on is windows I feel

00:04:19,530 --> 00:04:22,890
incredibly strongly about that it's

00:04:20,910 --> 00:04:25,229
extremely insensitive I can't tell my

00:04:22,890 --> 00:04:27,180
eight-year-old students you know get a

00:04:25,229 --> 00:04:29,970
real operating system they're all

00:04:27,180 --> 00:04:31,530
running Windows it's I think that's

00:04:29,970 --> 00:04:32,940
important point to make you guys are the

00:04:31,530 --> 00:04:34,740
experts you make sure that your code

00:04:32,940 --> 00:04:37,729
works on a machine I think that's a fit

00:04:34,740 --> 00:04:37,729
that's a fair point

00:04:38,450 --> 00:04:45,690
okay so this is this is a tool that does

00:04:41,940 --> 00:04:47,370
really nothing clever whatsoever it just

00:04:45,690 --> 00:04:49,500
wraps the setup tools machinery to build

00:04:47,370 --> 00:04:51,360
your Python stuff it's a command line

00:04:49,500 --> 00:04:53,790
tool you basically say easy Python my

00:04:51,360 --> 00:04:57,120
site and file and it produces a binary

00:04:53,790 --> 00:04:59,010
object there's no magic behind it if you

00:04:57,120 --> 00:05:01,170
look into the code it's a single file

00:04:59,010 --> 00:05:02,610
list 100 lines it really just creates a

00:05:01,170 --> 00:05:06,110
setup that PI and does the compilation

00:05:02,610 --> 00:05:08,010
for you to make it simpler to use right

00:05:06,110 --> 00:05:09,870
so we're going to begin we're going to

00:05:08,010 --> 00:05:11,670
begin extremely simply there is no

00:05:09,870 --> 00:05:13,320
complexity here whatsoever there's a

00:05:11,670 --> 00:05:15,510
main file and there's a simple dot PI

00:05:13,320 --> 00:05:17,550
module we import the simple dot PI

00:05:15,510 --> 00:05:18,990
module and we run the function inside it

00:05:17,550 --> 00:05:19,650
it takes two arguments it multiplies

00:05:18,990 --> 00:05:21,840
them together

00:05:19,650 --> 00:05:23,160
nothing nothing strange whatsoever

00:05:21,840 --> 00:05:26,490
everyone in the room should be very

00:05:23,160 --> 00:05:28,620
comfortable with this there are four

00:05:26,490 --> 00:05:30,330
terminal I'm just printing up what the

00:05:28,620 --> 00:05:32,850
files are and the way I run the program

00:05:30,330 --> 00:05:36,180
is I say Python main dot PI and it

00:05:32,850 --> 00:05:38,130
prints the autistics give you a moment

00:05:36,180 --> 00:05:40,560
to just digest that nothing complicated

00:05:38,130 --> 00:05:42,180
whatsoever now I'm going to use syphon

00:05:40,560 --> 00:05:43,530
and apply it to this problem and what

00:05:42,180 --> 00:05:48,660
I'm going to do is I'm going to siphon

00:05:43,530 --> 00:05:52,200
eyes that file there simple duck pie so

00:05:48,660 --> 00:05:53,940
that's that's the change I've just

00:05:52,200 --> 00:05:56,820
highlighted in yellow at the top what

00:05:53,940 --> 00:06:01,140
I've done I've added an X to the file

00:05:56,820 --> 00:06:03,360
name and then I call my magic set of

00:06:01,140 --> 00:06:06,780
tools handler easy sighs and simple doc

00:06:03,360 --> 00:06:09,410
pyx and after that process finishes and

00:06:06,780 --> 00:06:11,640
you see a compiler stuff go on screen

00:06:09,410 --> 00:06:12,930
you list Adam turmoil you get a couple

00:06:11,640 --> 00:06:15,510
of files here on the next slide I'll go

00:06:12,930 --> 00:06:17,490
into that detail the red thing there is

00:06:15,510 --> 00:06:21,210
a shared object that's your binary

00:06:17,490 --> 00:06:23,400
library which you can import main main

00:06:21,210 --> 00:06:26,070
type I will import that in the same way

00:06:23,400 --> 00:06:28,680
that it imported a PI file and the run

00:06:26,070 --> 00:06:31,190
function sided so the first thing I want

00:06:28,680 --> 00:06:33,600
to I want to drive home is syphon is a

00:06:31,190 --> 00:06:35,820
superset of Python you don't have to

00:06:33,600 --> 00:06:37,740
change your code you can compile syphon

00:06:35,820 --> 00:06:40,830
that you can compile normal Python

00:06:37,740 --> 00:06:42,630
through syphon completely transparently

00:06:40,830 --> 00:06:44,640
you end up with a binary thing at the

00:06:42,630 --> 00:06:46,740
end but all the Python code inside the

00:06:44,640 --> 00:06:48,690
site installer works and in fact it gets

00:06:46,740 --> 00:06:49,830
executed by the same Python engine the

00:06:48,690 --> 00:06:52,110
interpreter still runs the

00:06:49,830 --> 00:06:53,909
inside the boundary the binary file it's

00:06:52,110 --> 00:06:56,430
only when you begin to add types do the

00:06:53,909 --> 00:06:58,050
things inside the size and file that you

00:06:56,430 --> 00:07:00,240
begin to get access to the underlying C

00:06:58,050 --> 00:07:01,919
library X and the speed and so on but

00:07:00,240 --> 00:07:03,840
that's the first thing I really want to

00:07:01,919 --> 00:07:05,819
drive home is that getting starting to

00:07:03,840 --> 00:07:07,259
play with cyclin is is really really

00:07:05,819 --> 00:07:11,099
easy to do it doesn't involve a lot of

00:07:07,259 --> 00:07:13,860
work okay so this is this is what the

00:07:11,099 --> 00:07:16,110
tool made we're an easy cyclin on our

00:07:13,860 --> 00:07:18,240
simple that pyx and the yellow stuff

00:07:16,110 --> 00:07:20,460
there is new stuff the blue is also new

00:07:18,240 --> 00:07:22,770
ask me about that in question time I'm

00:07:20,460 --> 00:07:24,389
not going to cover that but it's cool so

00:07:22,770 --> 00:07:27,930
the build folder comes from the

00:07:24,389 --> 00:07:33,349
compilation process simple dot C is a C

00:07:27,930 --> 00:07:35,580
file that syphon made from our pyx file

00:07:33,349 --> 00:07:39,659
so what syphon does is convert your UX

00:07:35,580 --> 00:07:42,030
bar into AC file and simple that Esso is

00:07:39,659 --> 00:07:43,590
the binary shared object that you get

00:07:42,030 --> 00:07:47,729
after you compile the C finding Linkwood

00:07:43,590 --> 00:07:50,460
against python easy size and simpler pyx

00:07:47,729 --> 00:07:52,500
and it spit out it's not too complicated

00:07:50,460 --> 00:07:55,349
yet right it's pretty pretty

00:07:52,500 --> 00:07:56,729
straightforward so I try to come up with

00:07:55,349 --> 00:07:58,590
a case study and and the problem with

00:07:56,729 --> 00:07:59,699
syphon is that it's a tool that has been

00:07:58,590 --> 00:08:02,190
developed in the scientific community

00:07:59,699 --> 00:08:05,310
and they usually introduce syphon at the

00:08:02,190 --> 00:08:08,190
same time as fourier transforms or you

00:08:05,310 --> 00:08:10,919
know scientific learning it's difficult

00:08:08,190 --> 00:08:12,599
to tease apart the bits that are useful

00:08:10,919 --> 00:08:14,039
for non-scientific things from the

00:08:12,599 --> 00:08:16,289
problem that really really complicated

00:08:14,039 --> 00:08:17,759
science that neuroscientists present at

00:08:16,289 --> 00:08:20,129
conferences about brain imaging and so

00:08:17,759 --> 00:08:22,319
on so I tried pretty hard to think of a

00:08:20,129 --> 00:08:24,150
good example and the one thing that came

00:08:22,319 --> 00:08:25,830
up with this text because different axes

00:08:24,150 --> 00:08:27,539
are common to everyone right I didn't

00:08:25,830 --> 00:08:30,240
want to go the death root because morbid

00:08:27,539 --> 00:08:30,900
so went with the tax route okay so what

00:08:30,240 --> 00:08:33,930
we're gonna do is were going to

00:08:30,900 --> 00:08:36,149
calculate everyone's tax so this is a

00:08:33,930 --> 00:08:37,740
tax table and this you're extremely

00:08:36,149 --> 00:08:39,320
young you should know what this is

00:08:37,740 --> 00:08:41,310
because it influences you every year

00:08:39,320 --> 00:08:42,959
basically in a progressive taxation

00:08:41,310 --> 00:08:44,970
system the more you earn that greater

00:08:42,959 --> 00:08:46,560
your tax rate is so it's a pretty it's

00:08:44,970 --> 00:08:48,750
an if-else statement that's really what

00:08:46,560 --> 00:08:50,250
it is your taxable income gets checked

00:08:48,750 --> 00:08:52,500
on the left and depending on which bin

00:08:50,250 --> 00:08:56,910
you're in then your rate gets worked out

00:08:52,500 --> 00:08:59,430
on the right pretty straightforward the

00:08:56,910 --> 00:09:01,260
Python code is pretty much a one-to-one

00:08:59,430 --> 00:09:03,110
translation from the tax table and this

00:09:01,260 --> 00:09:05,329
is one of the things why we like

00:09:03,110 --> 00:09:08,029
why I use it it's because the code is

00:09:05,329 --> 00:09:09,740
extremely readable I would argue you

00:09:08,029 --> 00:09:11,630
perhaps I'm biased but I think that's

00:09:09,740 --> 00:09:16,339
actually more readable than the tax

00:09:11,630 --> 00:09:18,140
table because get a sense of how to play

00:09:16,339 --> 00:09:21,740
it right so I'm going to switch between

00:09:18,140 --> 00:09:23,360
the siphon the pure siphon version of

00:09:21,740 --> 00:09:26,480
that and this so I'm going to just go

00:09:23,360 --> 00:09:30,290
forward and back so that's the siphon

00:09:26,480 --> 00:09:32,720
code I've added CP in front of the dip

00:09:30,290 --> 00:09:35,570
the return type is a double precision

00:09:32,720 --> 00:09:37,700
number and the argument amount is a

00:09:35,570 --> 00:09:39,860
double precision number and that's it

00:09:37,700 --> 00:09:41,750
right so I changed the extension of that

00:09:39,860 --> 00:09:43,550
thing to pyx

00:09:41,750 --> 00:09:45,769
and around through easy silent and I get

00:09:43,550 --> 00:09:47,510
a binary thing up again you don't have

00:09:45,769 --> 00:09:50,180
to use easy siphon that's not required

00:09:47,510 --> 00:09:51,800
whatsoever the guy for siphon says you

00:09:50,180 --> 00:09:53,839
have to write a set up top I file and

00:09:51,800 --> 00:09:55,190
put say which things must get compiled

00:09:53,839 --> 00:09:57,350
with what arguments and then you'll get

00:09:55,190 --> 00:09:59,180
the same outcome easy cycling just does

00:09:57,350 --> 00:10:02,440
that it's really just careful thing

00:09:59,180 --> 00:10:08,779
there's no magic so go back quickly -

00:10:02,440 --> 00:10:10,459
cycling - cycling so I'm trying to

00:10:08,779 --> 00:10:11,660
impress impress on you that the logic

00:10:10,459 --> 00:10:13,370
really hasn't changed in the function

00:10:11,660 --> 00:10:14,779
it's really just types that I'm applying

00:10:13,370 --> 00:10:19,370
there and that mysterious CP at the

00:10:14,779 --> 00:10:21,230
front right I'm hoping everywhere I have

00:10:19,370 --> 00:10:22,490
a blindness for things that I'm used to

00:10:21,230 --> 00:10:23,779
so I'm just trying to make sure I'm

00:10:22,490 --> 00:10:27,860
absolutely sure that you really follow

00:10:23,779 --> 00:10:29,480
what's going on okay so there I eleven

00:10:27,860 --> 00:10:30,800
and half million registered taxpayers in

00:10:29,480 --> 00:10:32,380
Australia I just went with ten million

00:10:30,800 --> 00:10:34,940
just to just to make it simpler i

00:10:32,380 --> 00:10:36,170
randomized a bunch of income so five

00:10:34,940 --> 00:10:37,940
thousand dollars a year to five hundred

00:10:36,170 --> 00:10:39,170
thousand dollars a year big long list

00:10:37,940 --> 00:10:40,820
and I want to calculate everyone's tax

00:10:39,170 --> 00:10:42,470
and then add it up pretty pretty

00:10:40,820 --> 00:10:44,240
straightforward calculation if you are

00:10:42,470 --> 00:10:46,220
doing a games engine like it like an

00:10:44,240 --> 00:10:47,540
economic simulation of some kind you

00:10:46,220 --> 00:10:49,190
might want to do this calculation many

00:10:47,540 --> 00:10:51,290
times if you are trying to optimize a

00:10:49,190 --> 00:10:52,519
tax table for some objective you would

00:10:51,290 --> 00:10:53,870
have to do this a lot of time so there's

00:10:52,519 --> 00:10:56,390
an issue of speed you might want to be

00:10:53,870 --> 00:10:58,699
able to do this pretty quickly right so

00:10:56,390 --> 00:11:01,339
I've got my generator in there to call

00:10:58,699 --> 00:11:03,740
tax Python for iron incomes where

00:11:01,339 --> 00:11:05,029
incomes is my 10 million list of array

00:11:03,740 --> 00:11:07,010
and then I sum them all together so how

00:11:05,029 --> 00:11:09,050
long does there take to run all of these

00:11:07,010 --> 00:11:11,120
things were running my computer and I'm

00:11:09,050 --> 00:11:12,410
going to show you times and I don't want

00:11:11,120 --> 00:11:13,790
you to take away from this what the

00:11:12,410 --> 00:11:15,470
absolute times are but what I'm really

00:11:13,790 --> 00:11:16,350
trying to impress on is the kind of

00:11:15,470 --> 00:11:18,090
reduction you can

00:11:16,350 --> 00:11:22,260
and how little work you need to put in

00:11:18,090 --> 00:11:24,780
to access their so text 12 seconds right

00:11:22,260 --> 00:11:27,300
the Python function I've got my list sum

00:11:24,780 --> 00:11:29,370
it up 12 seconds it's okay 12 seconds is

00:11:27,300 --> 00:11:31,920
not bad if I have to do that a thousand

00:11:29,370 --> 00:11:34,380
times it begins to become difficult to

00:11:31,920 --> 00:11:37,620
really play with the system and reason

00:11:34,380 --> 00:11:40,320
about it so the function that I have

00:11:37,620 --> 00:11:41,160
made a syphon version of earlier the one

00:11:40,320 --> 00:11:45,650
that I just showed you on the previous

00:11:41,160 --> 00:11:52,080
slide that's eight times faster right

00:11:45,650 --> 00:11:54,300
hold on okay so first question is that

00:11:52,080 --> 00:11:56,100
loop there is actually still Python code

00:11:54,300 --> 00:11:57,870
I'm still calling my function in a loop

00:11:56,100 --> 00:12:01,500
that runs in Python so what happens if

00:11:57,870 --> 00:12:05,280
you put the loop in cyclone as well it's

00:12:01,500 --> 00:12:07,860
a good question so we can also loop in

00:12:05,280 --> 00:12:09,000
siphon I'll show you the code a little

00:12:07,860 --> 00:12:11,400
bit later because I don't want that

00:12:09,000 --> 00:12:12,900
noise to interfere with the impact I'm

00:12:11,400 --> 00:12:20,730
about to make which is that takes 50

00:12:12,900 --> 00:12:24,870
milliseconds okay so that's that's a

00:12:20,730 --> 00:12:26,820
speed-up of 220 times which is more than

00:12:24,870 --> 00:12:28,680
I'm used to you with numerical code I'm

00:12:26,820 --> 00:12:31,800
used to getting about 170 times speed-up

00:12:28,680 --> 00:12:33,300
but significant it's it's it's

00:12:31,800 --> 00:12:35,190
game-changing actually to be able to do

00:12:33,300 --> 00:12:37,680
this but but but again what I want to

00:12:35,190 --> 00:12:39,540
impress upon you is how little work we

00:12:37,680 --> 00:12:40,560
have to do for this result although I'm

00:12:39,540 --> 00:12:42,540
still going to show you what the loop

00:12:40,560 --> 00:12:44,370
looks like it's not too bad but pretty

00:12:42,540 --> 00:12:46,110
pretty tractable right you can you can

00:12:44,370 --> 00:12:47,670
get a hotspot in your code and you can

00:12:46,110 --> 00:12:50,940
make a couple of very small changes and

00:12:47,670 --> 00:12:53,700
and kind of get a reasonable speed up I

00:12:50,940 --> 00:12:55,920
don't think you could make it go much

00:12:53,700 --> 00:12:58,080
faster if you wrote C natively and I

00:12:55,920 --> 00:13:00,420
don't know C that well so I definitely

00:12:58,080 --> 00:13:03,810
couldn't do it so this is a huge benefit

00:13:00,420 --> 00:13:07,050
to me in the work that I've had to do so

00:13:03,810 --> 00:13:08,490
I just want to show you quick

00:13:07,050 --> 00:13:09,720
comparisons with some other methods that

00:13:08,490 --> 00:13:12,030
you may have heard about for speeding up

00:13:09,720 --> 00:13:13,590
code ask me about them in question time

00:13:12,030 --> 00:13:15,690
I'm not going to go into them too much

00:13:13,590 --> 00:13:17,400
detail but just to give you an idea of

00:13:15,690 --> 00:13:18,270
other tools that exist and what you

00:13:17,400 --> 00:13:23,100
might be able to do with it

00:13:18,270 --> 00:13:25,560
so the first thing is numpy right with

00:13:23,100 --> 00:13:28,560
this kind of problem numpy actually

00:13:25,560 --> 00:13:29,760
doesn't help you the reason is because

00:13:28,560 --> 00:13:30,270
we're doing slightly different

00:13:29,760 --> 00:13:32,820
operations

00:13:30,270 --> 00:13:34,320
on each element in our array if you're

00:13:32,820 --> 00:13:37,200
doing the same thing to every element in

00:13:34,320 --> 00:13:39,780
an array numpy is awesome it's fantastic

00:13:37,200 --> 00:13:41,520
you can crunch enormous quantities of

00:13:39,780 --> 00:13:42,750
numbers and it's great but with this

00:13:41,520 --> 00:13:44,460
kind of scenario where you're doing a

00:13:42,750 --> 00:13:46,050
different slightly different calculation

00:13:44,460 --> 00:13:48,000
on each element in a long list of

00:13:46,050 --> 00:13:49,500
numbers numpy actually doesn't help you

00:13:48,000 --> 00:13:51,510
at all because the calculation is still

00:13:49,500 --> 00:13:54,120
getting done at the Python level so I

00:13:51,510 --> 00:13:55,860
just want to show you there the one we

00:13:54,120 --> 00:13:58,020
did where we use Python code and we

00:13:55,860 --> 00:13:59,700
called our siphon function you can wrap

00:13:58,020 --> 00:14:01,050
that in an umpire vectorize statement

00:13:59,700 --> 00:14:02,970
and you really don't get very much speed

00:14:01,050 --> 00:14:05,190
up at all it's pretty much doing a

00:14:02,970 --> 00:14:07,080
glorified loop around your stuff and

00:14:05,190 --> 00:14:09,180
it's letting your function play with

00:14:07,080 --> 00:14:10,680
non-price broadcasting rules so so with

00:14:09,180 --> 00:14:11,580
this kind of situation umpire doesn't

00:14:10,680 --> 00:14:15,390
help you that that's the conclusion

00:14:11,580 --> 00:14:17,220
there with pi PI I'm not a pi PI expert

00:14:15,390 --> 00:14:19,260
I've used a little bit I homebrew

00:14:17,220 --> 00:14:21,480
installed whatever pi PI was in the list

00:14:19,260 --> 00:14:24,480
and I ran that on my Python version and

00:14:21,480 --> 00:14:27,330
I got 50 times I think that's pretty

00:14:24,480 --> 00:14:29,190
reasonable for really very not not very

00:14:27,330 --> 00:14:30,840
much effort on my part I think that's

00:14:29,190 --> 00:14:32,490
worth looking at I love the pi PI

00:14:30,840 --> 00:14:33,900
project and not against them whatsoever

00:14:32,490 --> 00:14:37,950
and I wish them every success I

00:14:33,900 --> 00:14:39,720
regularly try out new pi pi releases on

00:14:37,950 --> 00:14:42,900
some of my code and the last one is

00:14:39,720 --> 00:14:45,120
number so number is also in the 50

00:14:42,900 --> 00:14:46,560
millisecond ballpark in fact you get

00:14:45,120 --> 00:14:49,050
really the same answer that you get in

00:14:46,560 --> 00:14:50,700
siphon and what do you have to do with

00:14:49,050 --> 00:14:53,070
numbers you just have to add that jet

00:14:50,700 --> 00:14:55,140
decorator to your functions to the loop

00:14:53,070 --> 00:14:56,670
and enter your tax calculation function

00:14:55,140 --> 00:14:58,950
and then you get the same answer

00:14:56,670 --> 00:15:00,510
but know more about that ask me about in

00:14:58,950 --> 00:15:03,540
question time why this talk is not about

00:15:00,510 --> 00:15:05,700
number and why it's about sizing so this

00:15:03,540 --> 00:15:08,070
is the loop that I said originally we

00:15:05,700 --> 00:15:10,770
just had a some generator in Python

00:15:08,070 --> 00:15:11,970
where we just had an if statement loop

00:15:10,770 --> 00:15:14,040
and we just walked over our tax

00:15:11,970 --> 00:15:15,750
calculation and summed it up this is

00:15:14,040 --> 00:15:18,030
what the loop looks like in siphon and

00:15:15,750 --> 00:15:20,010
once you start using siphon a lot pretty

00:15:18,030 --> 00:15:21,240
much most of your size and code is it is

00:15:20,010 --> 00:15:22,080
going to look like this this is almost

00:15:21,240 --> 00:15:24,930
idiomatic

00:15:22,080 --> 00:15:26,310
right so you've got your return type

00:15:24,930 --> 00:15:28,830
there it's going to return a double

00:15:26,310 --> 00:15:30,000
double precision number you have an

00:15:28,830 --> 00:15:31,230
array of doubles which are going to come

00:15:30,000 --> 00:15:32,520
in and and this is this is pretty

00:15:31,230 --> 00:15:34,950
idiomatic it's going to look like that

00:15:32,520 --> 00:15:36,510
if it's integers you'll say int : if

00:15:34,950 --> 00:15:39,600
it's something else it'll be something

00:15:36,510 --> 00:15:41,010
else like that there you've got all the

00:15:39,600 --> 00:15:42,430
types of the variables that you're going

00:15:41,010 --> 00:15:43,779
to use in your function but

00:15:42,430 --> 00:15:45,160
that's that's the entire function this

00:15:43,779 --> 00:15:47,680
is something else that is the loop that

00:15:45,160 --> 00:15:49,300
does the the call out to the other thing

00:15:47,680 --> 00:15:51,940
that we siphoned and and it returns

00:15:49,300 --> 00:15:56,770
total there most of your site that will

00:15:51,940 --> 00:15:58,750
look like this if you do it so we don't

00:15:56,770 --> 00:16:01,870
so that's how to speed up coding siphon

00:15:58,750 --> 00:16:03,640
I think it's it's a remarkably efficient

00:16:01,870 --> 00:16:06,010
use of your time to learn a little bit

00:16:03,640 --> 00:16:08,950
of siphon and get massive enormous speed

00:16:06,010 --> 00:16:10,990
ups in your code and you get to bleed it

00:16:08,950 --> 00:16:12,430
in you get all the benefits of Python in

00:16:10,990 --> 00:16:13,839
your code that is Python and doesn't

00:16:12,430 --> 00:16:15,610
need to run fast and in the bits that

00:16:13,839 --> 00:16:17,920
need to run fast can run pretty much

00:16:15,610 --> 00:16:19,839
native C speed I think that's enormous

00:16:17,920 --> 00:16:22,149
ly beneficial and and we don't sell this

00:16:19,839 --> 00:16:24,850
the scientific community community does

00:16:22,149 --> 00:16:27,820
not sell this strongly enough I think to

00:16:24,850 --> 00:16:32,230
the non-scientific audience multi-core

00:16:27,820 --> 00:16:34,330
so concurrency JavaScript so we're not

00:16:32,230 --> 00:16:37,600
talking back on currency that is you

00:16:34,330 --> 00:16:39,070
know single core asynchronous i/o bound

00:16:37,600 --> 00:16:42,130
type processes what we're talking about

00:16:39,070 --> 00:16:43,870
here is multi-core multi-threaded shared

00:16:42,130 --> 00:16:45,370
memory concurrency shared memory so you

00:16:43,870 --> 00:16:50,050
have got multiple threads that are

00:16:45,370 --> 00:16:55,209
accessing the same memory so if you

00:16:50,050 --> 00:16:56,650
truly love the Gil set a tree so this is

00:16:55,209 --> 00:16:58,300
the same loop that I just showed you

00:16:56,650 --> 00:17:00,370
right this is the work that's gonna come

00:16:58,300 --> 00:17:03,010
in there are our array of incomes at the

00:17:00,370 --> 00:17:04,270
top and it's exactly the same loop that

00:17:03,010 --> 00:17:06,069
only changes what a marketing yellow

00:17:04,270 --> 00:17:08,230
there when used to have a context

00:17:06,069 --> 00:17:11,949
handler with no Gil that releases the

00:17:08,230 --> 00:17:13,990
lock that's it that's the change so that

00:17:11,949 --> 00:17:15,670
code will now run and it won't consume

00:17:13,990 --> 00:17:18,870
the lock from Python and it will run

00:17:15,670 --> 00:17:22,660
happily on its own on a separate call

00:17:18,870 --> 00:17:24,160
one tiny cache I've marked the name of

00:17:22,660 --> 00:17:26,260
the function there in red there's just

00:17:24,160 --> 00:17:28,120
one little thing that you have to do one

00:17:26,260 --> 00:17:29,530
of the provisions of this context

00:17:28,120 --> 00:17:32,200
handler is that every function that you

00:17:29,530 --> 00:17:34,540
call inside of it just has to be marked

00:17:32,200 --> 00:17:36,550
with the no Gil directive and what that

00:17:34,540 --> 00:17:38,200
does is the compile it allows compiler

00:17:36,550 --> 00:17:40,510
to check that you're not calling Python

00:17:38,200 --> 00:17:42,190
anywhere in your code but that's really

00:17:40,510 --> 00:17:45,190
what it does you can't you can't release

00:17:42,190 --> 00:17:46,809
the lock if any part of your code inside

00:17:45,190 --> 00:17:49,120
the context handler is calling it to

00:17:46,809 --> 00:17:52,150
Python so it all has to be typed and it

00:17:49,120 --> 00:17:54,550
becomes native see on the backend so

00:17:52,150 --> 00:17:55,740
what that looks like is they just add

00:17:54,550 --> 00:17:58,750
that

00:17:55,740 --> 00:18:00,520
our loop has context handler that says

00:17:58,750 --> 00:18:02,050
with no Gil just show you back there

00:18:00,520 --> 00:18:03,970
that's what it looks like there and of

00:18:02,050 --> 00:18:05,710
course into our function and our

00:18:03,970 --> 00:18:11,230
function just has to get that mark on

00:18:05,710 --> 00:18:13,180
the top so that's it so now we have to

00:18:11,230 --> 00:18:15,130
set up our threads and this is this is

00:18:13,180 --> 00:18:17,730
my favorite part of the talk I think

00:18:15,130 --> 00:18:22,780
this is just the most awesome thing

00:18:17,730 --> 00:18:24,280
Python threads are awesome right the guy

00:18:22,780 --> 00:18:26,830
just said my story was cool

00:18:24,280 --> 00:18:33,060
and he called me bro we've been we've

00:18:26,830 --> 00:18:36,610
we've it's become like a a a cargo cult

00:18:33,060 --> 00:18:38,170
inside Python that threads are bad don't

00:18:36,610 --> 00:18:39,760
you threads they're not really threads

00:18:38,170 --> 00:18:41,530
they're not running concurrently but the

00:18:39,760 --> 00:18:43,990
thing is we just released the lock we

00:18:41,530 --> 00:18:48,910
just released that so can threads work

00:18:43,990 --> 00:18:50,830
for us again right so I'm going to leave

00:18:48,910 --> 00:18:52,600
this slider I've got some time left I'm

00:18:50,830 --> 00:18:54,010
going to leave the slider for quite a

00:18:52,600 --> 00:18:55,900
while I want you to take it in I think

00:18:54,010 --> 00:18:57,550
this is the this is the most awesome

00:18:55,900 --> 00:18:59,320
thing I've seen in a long time and in

00:18:57,550 --> 00:19:02,950
preparing these slides I had originally

00:18:59,320 --> 00:19:05,380
had Python 2 threading this thread pool

00:19:02,950 --> 00:19:07,420
executors is a Python 3 thing that I

00:19:05,380 --> 00:19:11,620
played with and I think it's just

00:19:07,420 --> 00:19:15,580
marvelous so it comes with Python 3 you

00:19:11,620 --> 00:19:18,160
can't get that in Python 2 it's a thing

00:19:15,580 --> 00:19:20,620
that you run in a context handler I've

00:19:18,160 --> 00:19:23,410
got 4 CPUs in my laptop so I make the

00:19:20,620 --> 00:19:25,930
workers before they you get this thing

00:19:23,410 --> 00:19:30,250
which is in job handler which I called

00:19:25,930 --> 00:19:33,010
exe there numpy provides an array split

00:19:30,250 --> 00:19:35,080
function which splits your work into the

00:19:33,010 --> 00:19:37,900
number of pieces you say but it returns

00:19:35,080 --> 00:19:40,150
views so that's that's not copied stuff

00:19:37,900 --> 00:19:44,110
it returns for views on your chunk of

00:19:40,150 --> 00:19:46,300
memory right so you get sections or

00:19:44,110 --> 00:19:49,630
sections is a list of 4 things that are

00:19:46,300 --> 00:19:51,160
views into a single Arab memory and then

00:19:49,630 --> 00:19:52,960
we've got our iterator where we submit

00:19:51,160 --> 00:19:55,840
jobs and the way the jobs get submitted

00:19:52,960 --> 00:19:57,010
is you give you a function so that's my

00:19:55,840 --> 00:19:58,660
loop that's my loop that does the

00:19:57,010 --> 00:20:01,510
summation is type text and the S is the

00:19:58,660 --> 00:20:02,950
section so the jobs that you submit is

00:20:01,510 --> 00:20:04,930
your your work function and the

00:20:02,950 --> 00:20:08,260
arguments for the work function and I

00:20:04,930 --> 00:20:09,220
get jobs I wait for them to return

00:20:08,260 --> 00:20:12,150
routes

00:20:09,220 --> 00:20:14,980
and I sum them back on the way out you

00:20:12,150 --> 00:20:17,140
cannot get bugs into this if you've ever

00:20:14,980 --> 00:20:20,200
written native through its in C it's

00:20:17,140 --> 00:20:21,700
it's the kind of thing you do that your

00:20:20,200 --> 00:20:23,530
takeaway is I should never do this again

00:20:21,700 --> 00:20:26,500
this is this is terrible

00:20:23,530 --> 00:20:28,660
right in Windows nonetheless I've done

00:20:26,500 --> 00:20:30,010
it before in Windows it's it's awful

00:20:28,660 --> 00:20:31,809
multi-threaded programming is supposed

00:20:30,010 --> 00:20:35,770
to be awful right you can't get this

00:20:31,809 --> 00:20:37,330
wrong it's it's very nearly brain-dead

00:20:35,770 --> 00:20:38,650
once you once you get this pattern going

00:20:37,330 --> 00:20:40,710
and I thought this was really amazing

00:20:38,650 --> 00:20:44,350
that's that this is my big takeaway from

00:20:40,710 --> 00:20:46,090
from preparing this talk so we've

00:20:44,350 --> 00:20:47,679
released the lock and we've got our

00:20:46,090 --> 00:20:49,030
thread set up and we're submitting jobs

00:20:47,679 --> 00:20:50,350
to them so do we get what kind of

00:20:49,030 --> 00:20:54,790
benefit do we do do get any benefit at

00:20:50,350 --> 00:20:57,340
all so remarkably we we get massive

00:20:54,790 --> 00:20:58,990
benefit right I've got the number of

00:20:57,340 --> 00:21:00,520
threads there on the bottom and I'm

00:20:58,990 --> 00:21:03,070
running on my macbook it's got four

00:21:00,520 --> 00:21:04,630
cores at one thread we get our 50

00:21:03,070 --> 00:21:07,360
milliseconds that's up there on the top

00:21:04,630 --> 00:21:09,400
lip and two threads comes down three and

00:21:07,360 --> 00:21:12,160
four and around four it kind of levels

00:21:09,400 --> 00:21:14,230
out the the improvement is fake that you

00:21:12,160 --> 00:21:15,730
see as it goes up to eight the this

00:21:14,230 --> 00:21:17,470
noise and that variation is within the

00:21:15,730 --> 00:21:18,480
noise so pretty much a four kind of

00:21:17,470 --> 00:21:22,240
flattens out because that's how many

00:21:18,480 --> 00:21:25,750
CPUs I've got that's that efficiency is

00:21:22,240 --> 00:21:27,670
92 percent so I'm getting 92 percent of

00:21:25,750 --> 00:21:29,380
what you would expect in an ideal world

00:21:27,670 --> 00:21:31,780
where you know the amount of work that

00:21:29,380 --> 00:21:33,330
you can do is exactly equal to the

00:21:31,780 --> 00:21:35,770
number of cores you add to the system

00:21:33,330 --> 00:21:39,100
I've got no doubt that if I ran this on

00:21:35,770 --> 00:21:40,660
AWS ec2 cluster with 64 CPUs that it

00:21:39,100 --> 00:21:42,100
wouldn't be as high as that but it would

00:21:40,660 --> 00:21:43,990
be significant and depending on the size

00:21:42,100 --> 00:21:45,940
of my work I'm pretty sure I'd get I get

00:21:43,990 --> 00:21:47,260
a really big improvement and I have a

00:21:45,940 --> 00:21:49,120
pretty good confidence that it's going

00:21:47,260 --> 00:21:52,200
to run and work I really don't expect

00:21:49,120 --> 00:21:54,520
any bugs because the code is so short so

00:21:52,200 --> 00:21:59,850
that's 14 milliseconds they don't let

00:21:54,520 --> 00:21:59,850
I'm now down at on mine that book and it

00:22:03,330 --> 00:22:07,659
just to just be absolutely clear I'm not

00:22:05,919 --> 00:22:09,129
trying to say that you know using more

00:22:07,659 --> 00:22:12,970
cause is better than a single core

00:22:09,129 --> 00:22:14,919
that's obvious but to take away that I

00:22:12,970 --> 00:22:17,710
want you to get is it's not that

00:22:14,919 --> 00:22:19,480
difficult to get that if you've got code

00:22:17,710 --> 00:22:20,980
that is slow and you want to make a bit

00:22:19,480 --> 00:22:22,840
of it fast like there's some part of

00:22:20,980 --> 00:22:25,360
your code that's just really bogging

00:22:22,840 --> 00:22:26,980
down your your your application it's not

00:22:25,360 --> 00:22:28,659
that hard to get there and the tools are

00:22:26,980 --> 00:22:30,940
available to make that relatively easy

00:22:28,659 --> 00:22:32,409
to do and you can do this and in certain

00:22:30,940 --> 00:22:33,700
classes of problems it's easy to do

00:22:32,409 --> 00:22:38,139
multi-threaded programming it and this

00:22:33,700 --> 00:22:39,669
is one of them so it's so great right we

00:22:38,139 --> 00:22:41,230
should we should siphon everything like

00:22:39,669 --> 00:22:42,970
all of our programs we should run

00:22:41,230 --> 00:22:45,429
through this thing and you know get this

00:22:42,970 --> 00:22:49,659
optimal speed and everything the thing

00:22:45,429 --> 00:22:51,190
is no no that doesn't work and I've

00:22:49,659 --> 00:22:53,860
tried that because it's intoxicating

00:22:51,190 --> 00:22:55,960
it's like it you know it's like fine

00:22:53,860 --> 00:23:02,309
wine or crap or something

00:22:55,960 --> 00:23:06,759
it's when you come down it really hurts

00:23:02,309 --> 00:23:09,340
so good advice use you siphon very

00:23:06,759 --> 00:23:10,840
sparingly measure make sure which bits

00:23:09,340 --> 00:23:13,779
of your code are taking a long time to

00:23:10,840 --> 00:23:15,879
run just do those bits the smaller the

00:23:13,779 --> 00:23:18,009
smaller that you can confine the scope

00:23:15,879 --> 00:23:20,139
of your cycling work to get the maximum

00:23:18,009 --> 00:23:22,509
benefit is really really what you want

00:23:20,139 --> 00:23:26,460
to be doing the world gets lonely and

00:23:22,509 --> 00:23:26,460
scary place as you move away from Python

00:23:26,820 --> 00:23:31,419
yeah I've suffered

00:23:29,200 --> 00:23:35,169
I've suffered a great deal from trying

00:23:31,419 --> 00:23:37,899
to add syphon to too too much code the

00:23:35,169 --> 00:23:40,210
90/10 rule very much applies find the

00:23:37,899 --> 00:23:45,639
10% of your code that is taking 90% at

00:23:40,210 --> 00:23:46,960
the time and just focus there I wish I

00:23:45,639 --> 00:23:48,580
could tell you a lot more there are

00:23:46,960 --> 00:23:50,320
other things that siphon does that that

00:23:48,580 --> 00:23:51,419
that are magical and amazing it's not

00:23:50,320 --> 00:23:53,490
just this there are other things

00:23:51,419 --> 00:23:55,539
extension types in siphon are

00:23:53,490 --> 00:23:57,970
ridiculously easy to do they're

00:23:55,539 --> 00:24:00,549
basically Python classes with little

00:23:57,970 --> 00:24:03,100
bits of extra magic and they run

00:24:00,549 --> 00:24:04,990
extremely fast and it's easy to make

00:24:03,100 --> 00:24:08,440
things that work and and don't fail

00:24:04,990 --> 00:24:10,029
because of bad memory access so it's

00:24:08,440 --> 00:24:12,159
pretty easy to do right one of the

00:24:10,029 --> 00:24:14,139
criticisms with cycling is well now you

00:24:12,159 --> 00:24:15,280
need to know both C and Python together

00:24:14,139 --> 00:24:17,500
to do anything and that's

00:24:15,280 --> 00:24:19,330
not true I don't know see that well I

00:24:17,500 --> 00:24:21,820
learned a little bit as I go but I am

00:24:19,330 --> 00:24:24,300
NOT a C programmer and I have used -

00:24:21,820 --> 00:24:24,300
Everly

00:24:25,830 --> 00:24:29,710
so there are other projects that also

00:24:27,880 --> 00:24:32,320
try and tackle the the speed question

00:24:29,710 --> 00:24:33,580
but not only the speed question and they

00:24:32,320 --> 00:24:35,640
also have slightly different trade-offs

00:24:33,580 --> 00:24:39,100
in how they want to approach things

00:24:35,640 --> 00:24:40,780
pi PI wants to tackle the problem of

00:24:39,100 --> 00:24:43,630
just native Python without any

00:24:40,780 --> 00:24:45,100
decoration of types number has a very

00:24:43,630 --> 00:24:48,240
strong focus on trying to get Fortran

00:24:45,100 --> 00:24:50,680
speed for number crunching shared skin

00:24:48,240 --> 00:24:53,200
has their own thing York is another one

00:24:50,680 --> 00:24:57,730
and Nami experience vectorizing

00:24:53,200 --> 00:24:59,800
calculations easily but this is a happy

00:24:57,730 --> 00:25:00,880
ecosystem sometimes they seems to be a

00:24:59,800 --> 00:25:02,950
little bit of confrontation between the

00:25:00,880 --> 00:25:05,410
groups but mostly they get along well

00:25:02,950 --> 00:25:07,210
and everyone is trying to follow the

00:25:05,410 --> 00:25:08,980
same dream which is to make Python

00:25:07,210 --> 00:25:11,050
applicable test many domains as possible

00:25:08,980 --> 00:25:12,970
I personally have high hopes for a

00:25:11,050 --> 00:25:14,800
pipeline number I'm very supportive of

00:25:12,970 --> 00:25:15,940
those projects and I do check them out

00:25:14,800 --> 00:25:19,930
regularly when they bring out new

00:25:15,940 --> 00:25:21,790
releases and that's my slide I'm

00:25:19,930 --> 00:25:24,640
starting a company which is kind of

00:25:21,790 --> 00:25:26,230
insane don't have the funding or the

00:25:24,640 --> 00:25:29,650
know-how to do that but I'm trying

00:25:26,230 --> 00:25:32,550
anyway and I've got a minute to spare so

00:25:29,650 --> 00:25:32,550
got more question time

00:25:42,170 --> 00:25:46,650
thanks Kellan that's awesome I just

00:25:44,310 --> 00:25:49,170
wanted to give a plug for Python XY

00:25:46,650 --> 00:25:52,890
which is a Windows bundle which includes

00:25:49,170 --> 00:25:54,890
dev C++ which is mingw and is a simple

00:25:52,890 --> 00:25:57,590
install which gives Windows people

00:25:54,890 --> 00:25:59,460
psyched and ready to go

00:25:57,590 --> 00:26:03,420
anaconda does the same so they're pretty

00:25:59,460 --> 00:26:04,950
good as well thank you and when wind

00:26:03,420 --> 00:26:06,540
python is the other one which is similar

00:26:04,950 --> 00:26:13,590
to flatten X Y the same guide to crisp

00:26:06,540 --> 00:26:16,110
oh that's pretty good as well thanks

00:26:13,590 --> 00:26:18,030
your example was of something which is

00:26:16,110 --> 00:26:19,190
what I'd call data parallelizable which

00:26:18,030 --> 00:26:21,510
is that you can essentially

00:26:19,190 --> 00:26:23,210
independently process sub parts of the

00:26:21,510 --> 00:26:26,220
data and then do a combined at the end

00:26:23,210 --> 00:26:28,890
do you have their best patterns for

00:26:26,220 --> 00:26:30,660
doing non data parallelizable tasks

00:26:28,890 --> 00:26:32,880
that's a great question and I'm probably

00:26:30,660 --> 00:26:34,260
the wrong person to do that I don't have

00:26:32,880 --> 00:26:36,300
a computer science background so

00:26:34,260 --> 00:26:38,820
whatever I learn is what I need to do

00:26:36,300 --> 00:26:41,130
accomplish things so I learned the hard

00:26:38,820 --> 00:26:43,190
way which is stumbling blindly through

00:26:41,130 --> 00:26:46,710
the forest trying to make my way through

00:26:43,190 --> 00:26:49,620
Caleb great talk thank you you wanted us

00:26:46,710 --> 00:26:56,610
to ask you about simple HTML so consider

00:26:49,620 --> 00:26:58,770
yourself asked good ok so that's that

00:26:56,610 --> 00:27:01,500
file so the HTML that comes up looks

00:26:58,770 --> 00:27:03,540
like that so what it is it's pretty

00:27:01,500 --> 00:27:05,730
clever it's it's a HTML file with some

00:27:03,540 --> 00:27:09,330
coloring and syntax highlighting and and

00:27:05,730 --> 00:27:12,690
the yellow indicates the proximity to

00:27:09,330 --> 00:27:14,130
the Python runtime so if a line is white

00:27:12,690 --> 00:27:16,020
it means there's no proximity which

00:27:14,130 --> 00:27:17,520
means that gets compiled completely

00:27:16,020 --> 00:27:19,590
natively and it's independent of Python

00:27:17,520 --> 00:27:21,530
if there's some yellow that there is

00:27:19,590 --> 00:27:24,330
some proximity to the Python runtime and

00:27:21,530 --> 00:27:28,800
you can see this this line here at the

00:27:24,330 --> 00:27:31,050
bottom is vaguely yellow it's got a got

00:27:28,800 --> 00:27:32,490
a lighter shade of yellow if you click

00:27:31,050 --> 00:27:34,440
on any of these lines it'll show you the

00:27:32,490 --> 00:27:36,780
underlying C code that represents that

00:27:34,440 --> 00:27:39,390
line right and what you see when you

00:27:36,780 --> 00:27:41,100
open that line up is that southland has

00:27:39,390 --> 00:27:43,500
put a check in to see whether you're

00:27:41,100 --> 00:27:44,400
referencing in that either something

00:27:43,500 --> 00:27:46,260
that doesn't exist

00:27:44,400 --> 00:27:48,870
so it's an out-of-balance check that's

00:27:46,260 --> 00:27:50,490
happening you can add an additional

00:27:48,870 --> 00:27:52,500
decorator

00:27:50,490 --> 00:27:54,750
above or below the wraparound siphon

00:27:52,500 --> 00:27:57,360
don't wrap around that says bounce check

00:27:54,750 --> 00:27:59,970
false and if you've said that to be

00:27:57,360 --> 00:28:01,650
false then that pale yellow line goes

00:27:59,970 --> 00:28:03,120
away and it no longer does the balance

00:28:01,650 --> 00:28:07,220
check and you get another five percent

00:28:03,120 --> 00:28:10,260
speed so I think it's safe by default so

00:28:07,220 --> 00:28:12,390
any way that your code could fail for

00:28:10,260 --> 00:28:14,690
for the usual suspects like out of

00:28:12,390 --> 00:28:17,310
balance accesses and similar things

00:28:14,690 --> 00:28:20,040
integers that wraparound siphons default

00:28:17,310 --> 00:28:22,320
is is to be safe so Python exceptions

00:28:20,040 --> 00:28:24,030
get thrown when those things occur which

00:28:22,320 --> 00:28:27,480
is enormous ly beneficial you don't you

00:28:24,030 --> 00:28:29,880
don't get you know really bad crashes

00:28:27,480 --> 00:28:31,320
and access violations and so on so

00:28:29,880 --> 00:28:32,370
that's that's the view file that's what

00:28:31,320 --> 00:28:33,420
you get so you can click on any other

00:28:32,370 --> 00:28:36,210
lines and you can see what the

00:28:33,420 --> 00:28:38,280
underlying C code is it's not really

00:28:36,210 --> 00:28:39,540
pretty code and the variables all become

00:28:38,280 --> 00:28:41,520
really strange variables with lots of

00:28:39,540 --> 00:28:43,320
underscores around them so it kind of

00:28:41,520 --> 00:28:44,730
looks ugly but if you work with us a

00:28:43,320 --> 00:28:46,500
lock you'll have to deal with that and

00:28:44,730 --> 00:28:48,810
what I usually do is I just try and

00:28:46,500 --> 00:28:51,030
figure out if my code is too complex and

00:28:48,810 --> 00:28:52,110
I figure out what what bit I can change

00:28:51,030 --> 00:28:53,550
to make it a bit simpler and try to

00:28:52,110 --> 00:29:00,330
reason about what it's doing without

00:28:53,550 --> 00:29:03,030
digging too much of the scene so here we

00:29:00,330 --> 00:29:04,830
are adding some types to be coded like

00:29:03,030 --> 00:29:06,960
what about the overflows the type

00:29:04,830 --> 00:29:08,990
checking this seems to be a simple

00:29:06,960 --> 00:29:12,330
example of double actually what if a

00:29:08,990 --> 00:29:14,490
caster or a Const cat star is added is

00:29:12,330 --> 00:29:16,740
it not like going to be toted yes to you

00:29:14,490 --> 00:29:21,690
siphon second thing is like instead of

00:29:16,740 --> 00:29:23,760
using a dot B Y X or this way of making

00:29:21,690 --> 00:29:28,020
it as a type Python why can't we write a

00:29:23,760 --> 00:29:29,640
native siphon code in C and use it as an

00:29:28,020 --> 00:29:36,080
extension in Python is it not more

00:29:29,640 --> 00:29:38,370
faster great question it is not faster

00:29:36,080 --> 00:29:40,440
not only is it not faster it's more

00:29:38,370 --> 00:29:42,600
difficult to write if you do it in C and

00:29:40,440 --> 00:29:45,540
unless you're a good C programmer you're

00:29:42,600 --> 00:29:47,970
probably going to get it wrong that has

00:29:45,540 --> 00:29:49,470
been my experience making code easy to

00:29:47,970 --> 00:29:53,640
write is the is your best protection

00:29:49,470 --> 00:29:55,710
against against bugs I think a good C

00:29:53,640 --> 00:29:56,880
programmer probably can do tricks that

00:29:55,710 --> 00:29:58,710
can get faster than what can be

00:29:56,880 --> 00:30:00,120
represented but the guys who make scythe

00:29:58,710 --> 00:30:02,620
and they're incredibly smart people like

00:30:00,120 --> 00:30:04,570
way I am I'm not enable

00:30:02,620 --> 00:30:06,730
I'm here just you're pitching it to you

00:30:04,570 --> 00:30:08,110
but they're really good and they know

00:30:06,730 --> 00:30:10,150
all the tricks and many of them are

00:30:08,110 --> 00:30:12,910
Fortran program is actually long time

00:30:10,150 --> 00:30:15,550
Fortran program is it significant number

00:30:12,910 --> 00:30:16,690
crunching stuff I think if you really

00:30:15,550 --> 00:30:18,760
know what you're doing in C you're

00:30:16,690 --> 00:30:22,570
probably maybe you can probably you can

00:30:18,760 --> 00:30:25,090
but I'm not that guy and I don't think I

00:30:22,570 --> 00:30:26,830
don't think most people are the first

00:30:25,090 --> 00:30:28,800
part your question was what is the types

00:30:26,830 --> 00:30:32,170
of more complex right

00:30:28,800 --> 00:30:34,570
as you add psych and stuff to your code

00:30:32,170 --> 00:30:37,030
you you move in a continuum from Python

00:30:34,570 --> 00:30:39,700
to C so whatever you can do in C you

00:30:37,030 --> 00:30:41,860
actually can do in siphon you can do

00:30:39,700 --> 00:30:45,970
costs there's there's a syntax for doing

00:30:41,860 --> 00:30:47,830
costs in front of variables so you can

00:30:45,970 --> 00:30:49,210
do that and you can handle complex cases

00:30:47,830 --> 00:30:52,620
but the code becomes a bit more complex

00:30:49,210 --> 00:30:52,620
to work with but you can do it

00:30:59,950 --> 00:31:05,020
yes oh you'll get a Python exception if

00:31:02,200 --> 00:31:07,540
you overflow unless you turn that off

00:31:05,020 --> 00:31:09,160
and then you and then you won't get an

00:31:07,540 --> 00:31:11,530
overflow exception you'll actually get a

00:31:09,160 --> 00:31:16,900
crash some kind of access violation or

00:31:11,530 --> 00:31:19,150
something so yeah okay can we get a you

00:31:16,900 --> 00:31:20,530
want you raise at the end pi pi which is

00:31:19,150 --> 00:31:22,090
one project I would like you actually

00:31:20,530 --> 00:31:23,440
have the numbers for how fast pi PI does

00:31:22,090 --> 00:31:26,340
this because this would seem to be the

00:31:23,440 --> 00:31:29,850
sweet spot for what type I can do I had

00:31:26,340 --> 00:31:29,850
do you mean

00:31:36,640 --> 00:31:41,940
oh wait I went too far right yes

00:31:52,090 --> 00:31:56,710
here we go okay so oh sorry but I missed

00:31:55,600 --> 00:32:00,130
it I must've missed this line I'm sorry

00:31:56,710 --> 00:32:02,200
I do apologize I am so so I don't want

00:32:00,130 --> 00:32:03,370
to say that's the best pipe I can do

00:32:02,200 --> 00:32:06,100
against the performance or the other

00:32:03,370 --> 00:32:07,720
stuff it's a it's a naive I homebrew

00:32:06,100 --> 00:32:08,890
installed pipe I and I ran my Python

00:32:07,720 --> 00:32:10,480
code through it and that's what I got so

00:32:08,890 --> 00:32:12,490
so fifty times without doing anything

00:32:10,480 --> 00:32:13,540
else is actually pretty good and the

00:32:12,490 --> 00:32:15,340
other one is other probably other

00:32:13,540 --> 00:32:17,020
projects in the community that this sort

00:32:15,340 --> 00:32:18,760
of relates to the type annotations

00:32:17,020 --> 00:32:22,030
that's coming in the upcoming three five

00:32:18,760 --> 00:32:24,520
is there any plan for siphon to use

00:32:22,030 --> 00:32:27,940
those type annotations in instead of in

00:32:24,520 --> 00:32:30,220
addition to its own declarations or I

00:32:27,940 --> 00:32:34,440
speak under correction but I don't think

00:32:30,220 --> 00:32:36,550
so okay and it's kind of disappointing

00:32:34,440 --> 00:32:40,300
more than if it wasn't made to kind of

00:32:36,550 --> 00:32:41,950
marry the the types and taxes together

00:32:40,300 --> 00:32:44,170
so what we're probably gonna have is you

00:32:41,950 --> 00:32:45,670
know in siphon three stuff when the type

00:32:44,170 --> 00:32:46,870
annotations become popular we're going

00:32:45,670 --> 00:32:48,850
to have it twice you're going to have

00:32:46,870 --> 00:32:50,410
certain types and in the other types

00:32:48,850 --> 00:32:53,130
which will be disappointing I think we

00:32:50,410 --> 00:32:53,130
should not do that

00:33:00,390 --> 00:33:02,450

YouTube URL: https://www.youtube.com/watch?v=NfnMJMkhDoQ


