Title: On Being Pythonic by Peter Lovett
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Design Patterns, standard designs and idioms in Python

Pythonic (Noun): Uses Python idioms well, that it is natural or shows fluency in the language.

Even though youâ€™re using Python syntax and keywords, your code still smells like C, Java or Perl. Or just feels like it's not the best way. This tour of Python is about changing the way you think, and to write Python that makes the best use of the language. As a result, your Python will be cleaner, simpler, nicer, and be more readable.

Even though you know the syntax to make a class and inherit, you don't know when you should. Composition? IsA, HasA, IsLikeA? What about factories, singletons, iterators and adapters?

Mashing together a long and painful background of C, C++, Perl and Java coding, a mind-expanding trip down the Elements of Reusable Object-Oriented Software rabbit hole, and over 30 years programming experience, Peter brings some clarity, reason and ideas on Pythonic idioms and OO design as implemented in Python.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:09,590 --> 00:00:14,120
alright next up we have Peter love it

00:00:11,750 --> 00:00:16,430
Peter is a programmer son of a

00:00:14,120 --> 00:00:18,830
programmer and all three of his sons can

00:00:16,430 --> 00:00:22,270
program in Python let's continue the

00:00:18,830 --> 00:00:22,270
legacy give him a round of applause

00:00:23,020 --> 00:00:28,150
excellent thank you

00:00:24,410 --> 00:00:31,790
and welcome to my talk on being pythonic

00:00:28,150 --> 00:00:33,200
um I'm just gonna jump straight in so a

00:00:31,790 --> 00:00:36,470
little bit about me I've been a

00:00:33,200 --> 00:00:37,970
programmer for a long time I've run my

00:00:36,470 --> 00:00:40,220
own company called plus plus and I run

00:00:37,970 --> 00:00:46,310
the training courses in C C++ Perl

00:00:40,220 --> 00:00:50,720
Python Java Ruby SQL XML etc this this

00:00:46,310 --> 00:00:52,670
talk is about about being pythonic and I

00:00:50,720 --> 00:00:55,160
would want to make the point that I'm

00:00:52,670 --> 00:00:57,080
not the final arbiter on what pythonic

00:00:55,160 --> 00:00:59,420
is but I want to ask you some questions

00:00:57,080 --> 00:01:02,780
and I want to get your brains thinking

00:00:59,420 --> 00:01:05,449
about what makes good Python I've got

00:01:02,780 --> 00:01:09,229
two apologies to make firstly there was

00:01:05,449 --> 00:01:11,150
a little mix-up in the printing of the

00:01:09,229 --> 00:01:12,770
schedule and this called this talk was

00:01:11,150 --> 00:01:15,109
originally called design patterns in

00:01:12,770 --> 00:01:18,009
Python but I've actually expanded it and

00:01:15,109 --> 00:01:20,659
covered some more ground the the

00:01:18,009 --> 00:01:21,890
organizers asked me to do this so I'm

00:01:20,659 --> 00:01:23,689
going to be moving through a number of

00:01:21,890 --> 00:01:25,729
different things and also looking at

00:01:23,689 --> 00:01:27,409
design patterns but it's all around

00:01:25,729 --> 00:01:28,819
Python so I think you'll enjoy it and

00:01:27,409 --> 00:01:30,499
learn a few things if you haven't

00:01:28,819 --> 00:01:35,450
learned anything by the end of the time

00:01:30,499 --> 00:01:36,979
please come and hassle me be the second

00:01:35,450 --> 00:01:38,630
apology I want to make which is not an

00:01:36,979 --> 00:01:41,530
apology and I liked kaleb's talked

00:01:38,630 --> 00:01:43,909
earlier that I'm running on Windows and

00:01:41,530 --> 00:01:46,149
I'm doing that for a few reasons one a

00:01:43,909 --> 00:01:49,460
lot of my clients use Windows and

00:01:46,149 --> 00:01:50,749
corporates use Windows and if I'm on if

00:01:49,460 --> 00:01:53,539
I'm going to be doing Python I've got to

00:01:50,749 --> 00:01:58,520
make sure it works on Windows hence I'm

00:01:53,539 --> 00:02:01,100
on Windows I do know NYX as well so

00:01:58,520 --> 00:02:03,200
pythonic what is it by finding has a

00:02:01,100 --> 00:02:06,049
noun that according to Wikipedia means

00:02:03,200 --> 00:02:07,759
uses Python idioms well that is natural

00:02:06,049 --> 00:02:09,709
or shows fluency in the language and

00:02:07,759 --> 00:02:11,930
conforms with pythons minimalist

00:02:09,709 --> 00:02:14,360
philosophy and emphasis on readability

00:02:11,930 --> 00:02:15,530
and everything that I'm going to be

00:02:14,360 --> 00:02:20,000
looking at for the next 45 minutes

00:02:15,530 --> 00:02:22,340
covers covers that ground okay there's a

00:02:20,000 --> 00:02:23,090
Python which I just wanted to throw in

00:02:22,340 --> 00:02:25,670
there too

00:02:23,090 --> 00:02:27,440
that pythons in Australia are safe

00:02:25,670 --> 00:02:29,709
they're non-venomous they're not

00:02:27,440 --> 00:02:29,709
dangerous

00:02:30,489 --> 00:02:34,069
apparently overseas there are some

00:02:32,390 --> 00:02:36,950
bigger ones that'll do you some harm but

00:02:34,069 --> 00:02:38,629
in Australia that's that's the third son

00:02:36,950 --> 00:02:41,540
by the way who's not here I'm very

00:02:38,629 --> 00:02:44,480
fortunate to have the older two here for

00:02:41,540 --> 00:02:46,870
me pythonic means readable logical and

00:02:44,480 --> 00:02:50,000
sensible and so that's what I want to

00:02:46,870 --> 00:02:55,489
challenge you with let's do some code

00:02:50,000 --> 00:02:58,519
that's readable logical sensible take a

00:02:55,489 --> 00:03:00,700
second off and say be kind I guess this

00:02:58,519 --> 00:03:03,170
is also what pythonic means to me

00:03:00,700 --> 00:03:07,700
platonic means be kind for everyone you

00:03:03,170 --> 00:03:09,049
meet is fighting a great battle for some

00:03:07,700 --> 00:03:16,519
of us it's because we've got a Java

00:03:09,049 --> 00:03:23,180
background but some of us at C++ some of

00:03:16,519 --> 00:03:24,440
you come from Perl so an outline of what

00:03:23,180 --> 00:03:27,400
I'm going to cover I'm going to cover

00:03:24,440 --> 00:03:30,200
Python idioms patterns in the language

00:03:27,400 --> 00:03:32,780
program design issues about being

00:03:30,200 --> 00:03:38,090
pythonic and then we will look at some

00:03:32,780 --> 00:03:40,099
design patterns as well so let's do this

00:03:38,090 --> 00:03:42,980
now I'm also going to be brave so please

00:03:40,099 --> 00:03:45,920
be kind because I'm going to be doing a

00:03:42,980 --> 00:03:49,549
lot of code Python is about code oh I

00:03:45,920 --> 00:03:53,120
didn't mean to have all that python is

00:03:49,549 --> 00:03:56,690
about code and we're all programmers so

00:03:53,120 --> 00:03:58,069
I want to do some code I'm got a list of

00:03:56,690 --> 00:04:00,200
numbers here and I'm going to calculate

00:03:58,069 --> 00:04:04,519
the average and the average of those

00:04:00,200 --> 00:04:07,110
numbers is was that too hard let's make

00:04:04,519 --> 00:04:11,850
that a three for you

00:04:07,110 --> 00:04:13,740
zette better calculate the I'm gonna

00:04:11,850 --> 00:04:16,380
make it hard for you yes I know it's

00:04:13,740 --> 00:04:19,709
after lunch and of course the answer to

00:04:16,380 --> 00:04:22,620
that is there is no average function so

00:04:19,709 --> 00:04:25,410
the options to start with are find out

00:04:22,620 --> 00:04:27,750
what functions you've got average is

00:04:25,410 --> 00:04:29,340
surprisingly not one of them your

00:04:27,750 --> 00:04:31,380
options from here is to go to three

00:04:29,340 --> 00:04:33,480
point four which has the statistics

00:04:31,380 --> 00:04:36,180
package which has average or jump on

00:04:33,480 --> 00:04:39,300
over to numpy and use numpy one of num

00:04:36,180 --> 00:04:43,140
pies array of different multitudes of

00:04:39,300 --> 00:04:44,400
different means nan means etc I'm often

00:04:43,140 --> 00:04:46,260
at a client where I'm actually not

00:04:44,400 --> 00:04:47,760
allowed to bring stuff in I'm stuck with

00:04:46,260 --> 00:04:50,460
the version of Python that they've got

00:04:47,760 --> 00:04:51,630
and I can't bring extra modules in so

00:04:50,460 --> 00:04:53,630
I've just got to make do with what I've

00:04:51,630 --> 00:04:57,510
got generally the batteries are included

00:04:53,630 --> 00:05:00,600
unquote but python doesn't have an

00:04:57,510 --> 00:05:02,160
average function so we're programmers

00:05:00,600 --> 00:05:05,160
let's do some programming let's go and

00:05:02,160 --> 00:05:09,480
write an average function it'll take a

00:05:05,160 --> 00:05:13,380
list I'll need a total I'll need an

00:05:09,480 --> 00:05:16,970
index a counter why is it I side side

00:05:13,380 --> 00:05:20,100
question why do we use I for our integer

00:05:16,970 --> 00:05:27,210
from Fortran because this is for the

00:05:20,100 --> 00:05:29,700
Fortran programmers God is real keep on

00:05:27,210 --> 00:05:35,669
looping while I is less than the linn of

00:05:29,700 --> 00:05:40,740
a and total gets added to by the eighth

00:05:35,669 --> 00:05:46,310
element and then at the end I'll have to

00:05:40,740 --> 00:05:50,160
go and return total divided by Len good

00:05:46,310 --> 00:05:51,270
and when I go and run that I see that I

00:05:50,160 --> 00:05:54,479
should have paid more attention to

00:05:51,270 --> 00:05:58,050
calebs talk about siphon and this is

00:05:54,479 --> 00:06:00,660
very slow we have no idea what the

00:05:58,050 --> 00:06:05,970
problem is but if I siphon eyes dit it

00:06:00,660 --> 00:06:09,810
would certainly run faster yes I think

00:06:05,970 --> 00:06:12,169
so I'm a C programmer so I'll increment

00:06:09,810 --> 00:06:12,169
I

00:06:13,510 --> 00:06:21,390
questions syntax error runtime error

00:06:16,810 --> 00:06:29,290
logic error syntax error

00:06:21,390 --> 00:06:32,200
let's check no it's the positive of the

00:06:29,290 --> 00:06:33,880
positive of I actually I'm just noticing

00:06:32,200 --> 00:06:34,120
that's not quite as big this was further

00:06:33,880 --> 00:06:35,980
out

00:06:34,120 --> 00:06:42,940
cariann I don't know if she's here but

00:06:35,980 --> 00:06:46,000
um you know pad plus plus which is just

00:06:42,940 --> 00:06:47,200
a glory in Windows ctrl + ctrl - gives

00:06:46,000 --> 00:06:50,470
you that zoom that she desperately

00:06:47,200 --> 00:06:53,080
wanted of course + + eyes the positive

00:06:50,470 --> 00:06:55,390
of the positive of eye and that's not

00:06:53,080 --> 00:06:57,160
actually doing anything I'm actually

00:06:55,390 --> 00:06:59,380
quite distressed that Python doesn't

00:06:57,160 --> 00:07:02,800
have a + + operator because I named my

00:06:59,380 --> 00:07:06,730
company + + so I'm now gonna have to go

00:07:02,800 --> 00:07:12,450
and rename my company 2 + equals 1 just

00:07:06,730 --> 00:07:14,790
doesn't have that same journey sake quoi

00:07:12,450 --> 00:07:18,460
pardon my french

00:07:14,790 --> 00:07:22,150
now I had originally written this for 3

00:07:18,460 --> 00:07:24,850
but let me make that 2 and the average

00:07:22,150 --> 00:07:27,550
is 2 which i think is given what I had

00:07:24,850 --> 00:07:29,610
the XS that I had for lunch seems about

00:07:27,550 --> 00:07:34,720
right

00:07:29,610 --> 00:07:38,290
trap the trap for players we've got

00:07:34,720 --> 00:07:40,740
integer division huh so readable logical

00:07:38,290 --> 00:07:43,300
sensible I could make that just a dot

00:07:40,740 --> 00:07:46,750
not obvious enough needs to be more

00:07:43,300 --> 00:07:50,590
obvious maybe that maybe I should start

00:07:46,750 --> 00:07:53,560
being a bit more future minded and jump

00:07:50,590 --> 00:07:55,750
on over to the future and import the new

00:07:53,560 --> 00:07:59,740
division behavior would be a nice idea

00:07:55,750 --> 00:08:04,480
at nice nice twist or maybe I could use

00:07:59,740 --> 00:08:06,820
a float function any of those three

00:08:04,480 --> 00:08:13,840
would solve that problem and we have a

00:08:06,820 --> 00:08:21,330
result good how many decimal places on 2

00:08:13,840 --> 00:08:21,330
3 4 5 6 7 8 9 10 11 y 11 anyone

00:08:22,880 --> 00:08:28,720
floating-point numbers in Python have

00:08:25,040 --> 00:08:28,720
how many decimal places in them

00:08:29,620 --> 00:08:35,680
Python floats RC doubles how many how

00:08:32,900 --> 00:08:39,140
many significant digits in a sea double

00:08:35,680 --> 00:08:39,650
lots not infinite 15 so why don't I get

00:08:39,140 --> 00:08:42,470
00:08:39,650 --> 00:08:46,160
that's the stir of the object stir gives

00:08:42,470 --> 00:08:48,500
you 12 digits rather than the 15 that's

00:08:46,160 --> 00:08:50,210
actually a nice nice thing because

00:08:48,500 --> 00:08:53,000
actually helps us avoid the little messy

00:08:50,210 --> 00:08:56,030
bits at the bottom end of of

00:08:53,000 --> 00:08:59,180
floating-point numbers in being pythonic

00:08:56,030 --> 00:09:01,550
watch out for floating-point numbers

00:08:59,180 --> 00:09:08,410
anyone here good at maths who's my maths

00:09:01,550 --> 00:09:08,410
people 1 plus 1 minus 2 anyone anyone

00:09:08,500 --> 00:09:18,860
zero one point one plus one point one

00:09:14,450 --> 00:09:21,520
minus two point to any one zero point

00:09:18,860 --> 00:09:26,080
zero good let me give you a harder one

00:09:21,520 --> 00:09:32,440
plus one point whew one point one minus

00:09:26,080 --> 00:09:32,440
three point three zero point zero close

00:09:35,140 --> 00:09:39,520
look it's basically zero

00:09:40,360 --> 00:09:46,759
but it's not zero so watch out for

00:09:44,480 --> 00:09:48,139
floating-point numbers if that part of

00:09:46,759 --> 00:09:49,850
the talk that was just a side a side

00:09:48,139 --> 00:09:55,639
note watch out for floating-point

00:09:49,850 --> 00:09:59,870
numbers now this works as I can attest

00:09:55,639 --> 00:10:02,689
but it's not it's not a beautiful this

00:09:59,870 --> 00:10:04,550
is not pythonic I need to make it more

00:10:02,689 --> 00:10:07,129
pythonic because there's a lot of easy

00:10:04,550 --> 00:10:09,439
mistakes that I can make in here easy

00:10:07,129 --> 00:10:14,660
mistakes like starting at the wrong

00:10:09,439 --> 00:10:17,779
value out of bounds array index out of

00:10:14,660 --> 00:10:20,149
bounds at least it'll catch it but doing

00:10:17,779 --> 00:10:22,040
a loop with a while is what C

00:10:20,149 --> 00:10:26,209
programmers do and this isn't the C talk

00:10:22,040 --> 00:10:29,149
this is the Python talk another

00:10:26,209 --> 00:10:31,759
interesting thing is that just as a side

00:10:29,149 --> 00:10:35,449
note I'm using slicing they're not all

00:10:31,759 --> 00:10:38,540
iterables are sliceable can anyone tell

00:10:35,449 --> 00:10:41,509
me what one of the built-in core types

00:10:38,540 --> 00:10:45,050
that's not container types that's not

00:10:41,509 --> 00:10:49,009
sliceable lovely so this isn't going to

00:10:45,050 --> 00:10:51,920
work with sets so this is very unpaid

00:10:49,009 --> 00:10:58,160
phonic it would be much better to have a

00:10:51,920 --> 00:11:00,529
followed for I in range then I don't

00:10:58,160 --> 00:11:06,620
need to worry about my initial initial

00:11:00,529 --> 00:11:09,709
value while it's less than the whoops

00:11:06,620 --> 00:11:11,990
Len of a I'll be saying whoops a lot and

00:11:09,709 --> 00:11:14,870
then I don't need to have the increment

00:11:11,990 --> 00:11:18,740
saving lines creating clearer better

00:11:14,870 --> 00:11:29,630
code and to double check yes it still

00:11:18,740 --> 00:11:31,910
works almost good

00:11:29,630 --> 00:11:34,040
but this is this is still giving me the

00:11:31,910 --> 00:11:35,509
problem of that slicing and what if I

00:11:34,040 --> 00:11:37,399
don't want to slice well that's not the

00:11:35,509 --> 00:11:39,470
way we use for loops in Python if you

00:11:37,399 --> 00:11:42,529
want to be pythonic we don't use for

00:11:39,470 --> 00:11:47,300
loops with counters we do the for item

00:11:42,529 --> 00:11:50,990
in iterable and if I do the for item in

00:11:47,300 --> 00:11:56,630
iterable then I can just add onto it the

00:11:50,990 --> 00:12:01,100
item and that gives me an error up

00:11:56,630 --> 00:12:04,990
because I need to Len a there or lemon a

00:12:01,100 --> 00:12:11,180
which is different that's something else

00:12:04,990 --> 00:12:17,600
plus one don't forget about your order

00:12:11,180 --> 00:12:19,190
of operations is that's a syntax error

00:12:17,600 --> 00:12:23,480
there easy I don't worry about syntax

00:12:19,190 --> 00:12:24,589
errors they're just normal and I didn't

00:12:23,480 --> 00:12:27,589
need to add because I've got the line'

00:12:24,589 --> 00:12:31,699
and I don't need to get some extra set

00:12:27,589 --> 00:12:33,860
of brackets cool well this is an

00:12:31,699 --> 00:12:35,480
improvement but somewhere somewhere

00:12:33,860 --> 00:12:43,699
along the lines somebody's going to go

00:12:35,480 --> 00:12:45,680
and do this and that's gonna give me so

00:12:43,699 --> 00:12:47,779
programmers go well what I'll need to do

00:12:45,680 --> 00:12:49,579
is that I need to do some error checking

00:12:47,779 --> 00:12:53,420
I need to do some error handling and

00:12:49,579 --> 00:12:58,790
I'll be doing things like if the Len of

00:12:53,420 --> 00:13:00,800
that is zero what am I going to do well

00:12:58,790 --> 00:13:04,610
the worst possible thing you could do

00:13:00,800 --> 00:13:06,560
would be print error and that's called

00:13:04,610 --> 00:13:08,360
coupling and tight coupling and not

00:13:06,560 --> 00:13:12,290
every one of the systems that I work on

00:13:08,360 --> 00:13:13,939
actually have a console I do some

00:13:12,290 --> 00:13:16,310
embedded work some of my clients have

00:13:13,939 --> 00:13:17,870
embedded work Python running embedded we

00:13:16,310 --> 00:13:20,509
don't have a console we don't have a

00:13:17,870 --> 00:13:22,699
screen so you just can't do a print and

00:13:20,509 --> 00:13:25,189
if I'm just gonna be really bad then

00:13:22,699 --> 00:13:27,980
I'll go and do that as well because I

00:13:25,189 --> 00:13:32,329
can't have programs that just go and

00:13:27,980 --> 00:13:35,329
crash randomly or just stop working

00:13:32,329 --> 00:13:38,600
although that gives me the behaviour

00:13:35,329 --> 00:13:42,529
after at least give me logging so next

00:13:38,600 --> 00:13:43,250
to untie chthonic don't do prints print

00:13:42,529 --> 00:13:54,350
an error that

00:13:43,250 --> 00:13:57,770
improvement and import logging and PS

00:13:54,350 --> 00:14:00,650
windows I am not running as root but

00:13:57,770 --> 00:14:04,070
anyway well that's one option that I

00:14:00,650 --> 00:14:06,920
could do for for the error checking I'm

00:14:04,070 --> 00:14:08,690
not real happy with that a better option

00:14:06,920 --> 00:14:11,240
would actually go or another option

00:14:08,690 --> 00:14:12,590
would be a cert if you're not familiar

00:14:11,240 --> 00:14:16,070
with a cert if you're not using a

00:14:12,590 --> 00:14:18,950
certain extent in your code I encourage

00:14:16,070 --> 00:14:20,960
you to use a cert a cert is a really

00:14:18,950 --> 00:14:22,780
nice way of dealing with logic errors

00:14:20,960 --> 00:14:25,280
things that couldn't possibly happen

00:14:22,780 --> 00:14:28,250
although I would debate whether this

00:14:25,280 --> 00:14:31,160
actually falls into that category assert

00:14:28,250 --> 00:14:34,490
that the Len is equal to zero you assert

00:14:31,160 --> 00:14:38,420
that something be true maybe you think

00:14:34,490 --> 00:14:41,540
greater then and I have an assertion

00:14:38,420 --> 00:14:43,670
error but this isn't really a logic

00:14:41,540 --> 00:14:45,050
error this was a wrong parameter and I

00:14:43,670 --> 00:14:47,780
don't know whether assert is the

00:14:45,050 --> 00:14:49,600
appropriate language construct to use

00:14:47,780 --> 00:14:51,770
for this there are lots of other places

00:14:49,600 --> 00:14:53,810
preconditions in a function post

00:14:51,770 --> 00:14:55,640
conditions in a function for those I

00:14:53,810 --> 00:14:58,100
like assert but I don't know if this

00:14:55,640 --> 00:14:59,450
really corresponds to the sort of

00:14:58,100 --> 00:15:02,720
problem that I want to solve through the

00:14:59,450 --> 00:15:08,000
cert so let's go back to if and say if

00:15:02,720 --> 00:15:13,820
the Len is 0 or that's I don't know what

00:15:08,000 --> 00:15:22,060
that does if the Len is 0 then maybe I

00:15:13,820 --> 00:15:25,130
should go and raise an exception and

00:15:22,060 --> 00:15:26,690
that's nice that works raises an

00:15:25,130 --> 00:15:29,300
exception I could chuck a better error

00:15:26,690 --> 00:15:31,520
message on the end and at least that

00:15:29,300 --> 00:15:36,680
gives the caller the ability to recover

00:15:31,520 --> 00:15:41,150
from the problem Pearce that's not a

00:15:36,680 --> 00:15:43,610
great pythonic error exception is too

00:15:41,150 --> 00:15:45,470
generic though I should probably if I'm

00:15:43,610 --> 00:15:51,950
gonna follow that path what you should

00:15:45,470 --> 00:15:53,610
have is a not computable maybe extend

00:15:51,950 --> 00:15:55,290
exception

00:15:53,610 --> 00:15:58,140
and you don't actually really actually

00:15:55,290 --> 00:16:00,360
have to do anything at all there but at

00:15:58,140 --> 00:16:03,779
least then I can raise a particular

00:16:00,360 --> 00:16:05,810
exception that might make more sense to

00:16:03,779 --> 00:16:08,670
the caller and give us a way of

00:16:05,810 --> 00:16:13,440
explicitly capturing the right right

00:16:08,670 --> 00:16:15,390
return that's an option or if that's too

00:16:13,440 --> 00:16:21,420
much effort why don't I just go and

00:16:15,390 --> 00:16:26,430
raise a zero division error there we go

00:16:21,420 --> 00:16:30,149
that's better although actually that's

00:16:26,430 --> 00:16:36,420
exactly what it was doing before and so

00:16:30,149 --> 00:16:39,029
that would lead me to sing the Python

00:16:36,420 --> 00:16:40,950
idioms part - error handling I've given

00:16:39,029 --> 00:16:43,829
you some options there but I would draw

00:16:40,950 --> 00:16:45,930
your attention to I was coming at this

00:16:43,829 --> 00:16:48,180
from a C programmers perspective and C

00:16:45,930 --> 00:16:50,490
programmers do defensive programming we

00:16:48,180 --> 00:16:52,589
need to defend our programs against the

00:16:50,490 --> 00:16:56,430
user which might actually be another

00:16:52,589 --> 00:17:00,839
programmer but in Python AAFP is better

00:16:56,430 --> 00:17:03,679
than l byl so that is it's easier to ask

00:17:00,839 --> 00:17:05,790
for forgiveness than permission

00:17:03,679 --> 00:17:07,470
versus the kind of programming that I'm

00:17:05,790 --> 00:17:09,569
currently doing which is look before you

00:17:07,470 --> 00:17:13,860
leap which is a defensive programming

00:17:09,569 --> 00:17:16,439
it's platonic because it's easier to ask

00:17:13,860 --> 00:17:18,540
for forgiveness that is it's easier to

00:17:16,439 --> 00:17:20,459
wrap the call in a try cat a try except

00:17:18,540 --> 00:17:23,640
block sorry I was doing Java last week

00:17:20,459 --> 00:17:25,829
be kind to me it's easier to wrap it in

00:17:23,640 --> 00:17:27,209
a try except block then ask for

00:17:25,829 --> 00:17:30,090
permission

00:17:27,209 --> 00:17:31,500
side note that works really well in

00:17:30,090 --> 00:17:33,450
Python it's not a particularly good

00:17:31,500 --> 00:17:35,880
strategy in personal relationships and I

00:17:33,450 --> 00:17:37,740
don't encourage that in your marriage I

00:17:35,880 --> 00:17:44,040
have from personal experience pound that

00:17:37,740 --> 00:17:49,200
is in fact you get the picture so coming

00:17:44,040 --> 00:17:54,980
back to my pythons instead of that maybe

00:17:49,200 --> 00:17:57,570
I could return a useful value like none

00:17:54,980 --> 00:17:59,760
although that's a that's actually what

00:17:57,570 --> 00:18:01,860
just a return would do and there was a

00:17:59,760 --> 00:18:05,130
great talk yesterday about the monads

00:18:01,860 --> 00:18:06,680
and the the the complexity that comes up

00:18:05,130 --> 00:18:08,870
here with uh normally

00:18:06,680 --> 00:18:10,610
victus to give me a float but sometimes

00:18:08,870 --> 00:18:15,860
it gives me something that's not a float

00:18:10,610 --> 00:18:19,540
so that's not great I suppose I could go

00:18:15,860 --> 00:18:22,820
and just do a quick little double check

00:18:19,540 --> 00:18:24,770
when you do a float you get the float of

00:18:22,820 --> 00:18:27,070
something can you get the float of a

00:18:24,770 --> 00:18:27,070
string

00:18:27,910 --> 00:18:40,940
no what about infinity what about not a

00:18:36,950 --> 00:18:44,180
number not numbers really tasty it's

00:18:40,940 --> 00:18:48,620
really tasty piece of float it is

00:18:44,180 --> 00:18:52,550
actually a result of type float so the

00:18:48,620 --> 00:18:54,170
type of that is that it's a float so

00:18:52,550 --> 00:18:58,040
this this this program now always

00:18:54,170 --> 00:19:04,640
returns a float and I like that I'll go

00:18:58,040 --> 00:19:09,080
and return a float of now if I get a

00:19:04,640 --> 00:19:11,270
space in the right place and now this

00:19:09,080 --> 00:19:13,730
always returns a float nice thing is

00:19:11,270 --> 00:19:16,430
floats propagate too so a square root of

00:19:13,730 --> 00:19:19,040
not a number is not a number not a

00:19:16,430 --> 00:19:20,420
number times five is not a number but it

00:19:19,040 --> 00:19:22,730
doesn't actually crash and it's still

00:19:20,420 --> 00:19:24,440
always returning a float there's some

00:19:22,730 --> 00:19:27,260
value in that and that might be a useful

00:19:24,440 --> 00:19:30,110
one for you to to know about just as a

00:19:27,260 --> 00:19:32,300
side note you can also test with math

00:19:30,110 --> 00:19:34,430
don't use an M whether you've got Nan's

00:19:32,300 --> 00:19:37,640
and for those familiar with pandas and

00:19:34,430 --> 00:19:39,980
numpy Nan's crop up all the time in

00:19:37,640 --> 00:19:42,590
those tools so maybe I can build that

00:19:39,980 --> 00:19:47,500
into my tool there there's some value in

00:19:42,590 --> 00:19:49,790
there lovely well sooner or later

00:19:47,500 --> 00:19:55,010
someone's going to come along and say

00:19:49,790 --> 00:20:01,460
numbers ears are three and when my

00:19:55,010 --> 00:20:04,310
program goes and runs it doesn't work so

00:20:01,460 --> 00:20:08,840
the Java programmers go oh we just need

00:20:04,310 --> 00:20:11,240
to check the type of the arguments now

00:20:08,840 --> 00:20:13,490
I've got a little bit of a fuzzy bit

00:20:11,240 --> 00:20:16,400
going on here about types and python has

00:20:13,490 --> 00:20:19,640
an a little bit of an uncomfortable

00:20:16,400 --> 00:20:20,420
relationship with types we are a young

00:20:19,640 --> 00:20:23,240
we are

00:20:20,420 --> 00:20:25,640
dynamically typed language but let me

00:20:23,240 --> 00:20:29,390
just remind you of the types that we've

00:20:25,640 --> 00:20:31,370
got we've got static typing where the

00:20:29,390 --> 00:20:35,750
types of the variables is known at

00:20:31,370 --> 00:20:37,910
compile time such as in C and Java if I

00:20:35,750 --> 00:20:39,710
disregard arrays of objects and if I

00:20:37,910 --> 00:20:43,070
disregard pointers to void and stuff

00:20:39,710 --> 00:20:45,560
like that static typing but not strict

00:20:43,070 --> 00:20:47,810
for example Visual Basic allows us to

00:20:45,560 --> 00:20:51,500
define the types including this is a

00:20:47,810 --> 00:20:54,980
variant type which can change dynamic

00:20:51,500 --> 00:20:58,450
typing but not strict perl bash you want

00:20:54,980 --> 00:20:58,450
a number I could make that into a number

00:20:58,570 --> 00:21:03,380
with generally it works fine and then

00:21:01,220 --> 00:21:06,260
occasionally it works horribly or

00:21:03,380 --> 00:21:08,710
dynamic typing but strict which is where

00:21:06,260 --> 00:21:11,840
Python falls in as a general overall

00:21:08,710 --> 00:21:15,110
categorization and will refer to this as

00:21:11,840 --> 00:21:21,140
duck typing so let me do some duck

00:21:15,110 --> 00:21:23,660
typing so then what I don't want to do

00:21:21,140 --> 00:21:27,590
is what the Java people if the type of

00:21:23,660 --> 00:21:34,840
thing is equal is not equal to the type

00:21:27,590 --> 00:21:34,840
of list that's not what we want to do

00:21:35,080 --> 00:21:41,960
because I'm nailing it into it must be a

00:21:39,230 --> 00:21:46,340
list it's also pretty ugly and slow as

00:21:41,960 --> 00:21:55,750
well so instead of that I could use is

00:21:46,340 --> 00:21:55,750
instance if is instance a is of list

00:21:56,020 --> 00:22:01,370
that's okay

00:21:58,720 --> 00:22:04,880
but what about other things that could

00:22:01,370 --> 00:22:09,410
be could be averaged like Audino

00:22:04,880 --> 00:22:12,050
something like that so I could perfectly

00:22:09,410 --> 00:22:17,240
easily perfectly desire to average a

00:22:12,050 --> 00:22:19,760
tuple but a tuple is not a list so I'm

00:22:17,240 --> 00:22:24,130
going to shy away from those and say

00:22:19,760 --> 00:22:24,130
what we've got there is unpaid phonic

00:22:25,840 --> 00:22:30,370
most of you are familiar with Python

00:22:30,440 --> 00:22:36,710
just checking we're in the right you're

00:22:32,360 --> 00:22:42,410
all still awake and you all know about

00:22:36,710 --> 00:22:44,150
the dir command dir to go and get item

00:22:42,410 --> 00:22:47,030
for example and I start looking and I

00:22:44,150 --> 00:22:50,150
find that things like tuples and things

00:22:47,030 --> 00:22:52,040
like lists have a get item so and they

00:22:50,150 --> 00:22:54,980
also have iterables so maybe I'll just

00:22:52,040 --> 00:22:59,660
go and check to see whether there is the

00:22:54,980 --> 00:23:07,310
particular thing I want get item for

00:22:59,660 --> 00:23:08,900
example in the dir of that object that'd

00:23:07,310 --> 00:23:10,640
work that would check to see whether

00:23:08,900 --> 00:23:13,540
it's got the behavior that I want

00:23:10,640 --> 00:23:18,980
because when we're talking about ducks

00:23:13,540 --> 00:23:20,480
were we talking about ducks teaching

00:23:18,980 --> 00:23:22,300
ducks the type takes a while but it

00:23:20,480 --> 00:23:26,660
saves you a lot of work afterwards

00:23:22,300 --> 00:23:29,330
that's not what duck typing is duck

00:23:26,660 --> 00:23:32,660
typing is I don't care whether it's a

00:23:29,330 --> 00:23:34,700
duck I care whether it can quack I don't

00:23:32,660 --> 00:23:37,610
care whether it's a list whether it's a

00:23:34,700 --> 00:23:39,530
I don't care about its type I just care

00:23:37,610 --> 00:23:42,890
whether it's got the behaviors that I

00:23:39,530 --> 00:23:45,950
want now one way that I could go and

00:23:42,890 --> 00:23:49,940
check the duck typing would be with that

00:23:45,950 --> 00:23:52,520
that's pretty ugly better options would

00:23:49,940 --> 00:23:54,950
be has a tur to see whether it has the

00:23:52,520 --> 00:23:57,610
attribute but just remember that in

00:23:54,950 --> 00:24:01,730
Python there's no difference really

00:23:57,610 --> 00:24:03,620
honestly basically between attributes

00:24:01,730 --> 00:24:06,140
which are functions and attributes which

00:24:03,620 --> 00:24:07,970
are data and you can't tell from dir

00:24:06,140 --> 00:24:09,980
which of those are functions and which

00:24:07,970 --> 00:24:12,680
of those are data how can I tell which

00:24:09,980 --> 00:24:14,530
ones are callable well I could find out

00:24:12,680 --> 00:24:16,760
whether it's got the appropriate

00:24:14,530 --> 00:24:19,910
attribute but that doesn't tell me that

00:24:16,760 --> 00:24:22,880
it's a function I'd also have to check

00:24:19,910 --> 00:24:26,450
to see whether its callable and go and

00:24:22,880 --> 00:24:32,270
see whether it's whether a doc get item

00:24:26,450 --> 00:24:37,820
is callable maybe are not interested in

00:24:32,270 --> 00:24:40,540
whether it's a list because the problem

00:24:37,820 --> 00:24:43,640
is is that somebody will come along and

00:24:40,540 --> 00:24:47,680
create a new list called my

00:24:43,640 --> 00:24:51,560
list which will look just like a list

00:24:47,680 --> 00:24:53,030
but has some extras this is this is

00:24:51,560 --> 00:24:58,460
inheritance this is what we do all the

00:24:53,030 --> 00:25:02,090
time and I'm a pushy kind of guy so I'll

00:24:58,460 --> 00:25:09,860
go and push which of course we'll just

00:25:02,090 --> 00:25:13,600
do a self dot append that item is it a

00:25:09,860 --> 00:25:18,080
list well it's not a list but maybe

00:25:13,600 --> 00:25:20,480
using is subclass would be an

00:25:18,080 --> 00:25:25,730
appropriate thing to use to find out

00:25:20,480 --> 00:25:30,680
whether its subclasses list or maybe I

00:25:25,730 --> 00:25:32,450
could just let it go and crash now I'm

00:25:30,680 --> 00:25:34,640
going to leave that bit in there and

00:25:32,450 --> 00:25:37,810
take a little excursion off and go there

00:25:34,640 --> 00:25:42,350
are other kinds of iterables that are

00:25:37,810 --> 00:25:44,420
horrible which don't have a Len somebody

00:25:42,350 --> 00:25:49,100
give me an iterable that doesn't have a

00:25:44,420 --> 00:25:50,420
Len dictionaries dictionaries have a Len

00:25:49,100 --> 00:25:52,510
and that will tell you how many keys

00:25:50,420 --> 00:25:55,940
good guess

00:25:52,510 --> 00:25:58,220
sweet generators iterators all of those

00:25:55,940 --> 00:26:00,830
sorts of puppies are issuable but they

00:25:58,220 --> 00:26:05,120
don't have a Len now I've got meself a

00:26:00,830 --> 00:26:07,640
nice little set of extras here such as a

00:26:05,120 --> 00:26:09,170
quick little generator you want to

00:26:07,640 --> 00:26:13,780
generator if you don't know what

00:26:09,170 --> 00:26:13,780
generators are that's a generator

00:26:13,930 --> 00:26:19,070
generator is a clever little piece of

00:26:16,340 --> 00:26:22,820
trickery that goes and creates an

00:26:19,070 --> 00:26:24,710
iterable being pythonic we often use

00:26:22,820 --> 00:26:28,510
underscore some people prefer underscore

00:26:24,710 --> 00:26:31,400
underscore it's much nicer than junk or

00:26:28,510 --> 00:26:34,670
dummy for an argument that you actually

00:26:31,400 --> 00:26:36,080
don't really actually need it's just a

00:26:34,670 --> 00:26:38,300
way of us there's nothing special about

00:26:36,080 --> 00:26:40,670
underscore in that scenario it's just a

00:26:38,300 --> 00:26:43,960
I don't care what it is I don't need it

00:26:40,670 --> 00:26:46,730
I don't use it and and then I'm yielding

00:26:43,960 --> 00:26:50,150
so that is definitely something that I

00:26:46,730 --> 00:26:53,690
can iterate through but it doesn't have

00:26:50,150 --> 00:26:55,880
a Len so what's the most pythonic work

00:26:53,690 --> 00:27:00,350
so the iterable part of it will work

00:26:55,880 --> 00:27:03,179
so if I go and pass our R and rent

00:27:00,350 --> 00:27:11,210
object that is a generator to that

00:27:03,179 --> 00:27:11,210
average function then pop him up there I

00:27:11,929 --> 00:27:18,840
can run it but it doesn't have a Len so

00:27:16,860 --> 00:27:22,320
what would be the most pythonic way of

00:27:18,840 --> 00:27:25,710
dealing with this the quick answer is I

00:27:22,320 --> 00:27:27,470
don't know I'm not the final arbiter on

00:27:25,710 --> 00:27:30,419
this but let me give you some options

00:27:27,470 --> 00:27:33,750
one way which we would commonly use is

00:27:30,419 --> 00:27:36,240
build me a list build me a list from the

00:27:33,750 --> 00:27:37,740
generator now I've got a list now I've

00:27:36,240 --> 00:27:40,169
got a list I've got something that's got

00:27:37,740 --> 00:27:43,080
a Len now that I've got a Len the

00:27:40,169 --> 00:27:48,690
average I wanted that to come up with

00:27:43,080 --> 00:27:54,659
four but it's different every time if I

00:27:48,690 --> 00:27:57,450
keep doing it enough 13 hmm but that's

00:27:54,659 --> 00:28:00,809
building a new list and that may not be

00:27:57,450 --> 00:28:03,720
efficient now what's the most pythonic

00:28:00,809 --> 00:28:06,539
option here well I could pop perhaps go

00:28:03,720 --> 00:28:08,039
and build a list inside here but if it's

00:28:06,539 --> 00:28:09,630
already a list building a list from a

00:28:08,039 --> 00:28:10,950
list that would be wasteful maybe I

00:28:09,630 --> 00:28:14,100
could check to see whether it's got a

00:28:10,950 --> 00:28:15,480
Len if it's got a Len then I don't need

00:28:14,100 --> 00:28:18,769
to do anything I can eat a write through

00:28:15,480 --> 00:28:21,840
it and do the Lyn otherwise I could

00:28:18,769 --> 00:28:24,000
build a list from it I'm just giving you

00:28:21,840 --> 00:28:27,299
some options there I don't actually know

00:28:24,000 --> 00:28:29,100
what the answer is okay

00:28:27,299 --> 00:28:31,470
I could enumerate through it that'll be

00:28:29,100 --> 00:28:34,500
a nice one yeah you get the answer from

00:28:31,470 --> 00:28:36,029
the whatever the index reached watch out

00:28:34,500 --> 00:28:38,100
what you start at remember that you

00:28:36,029 --> 00:28:41,220
numerator has a nice handy second

00:28:38,100 --> 00:28:44,929
argument which will gives you a start at

00:28:41,220 --> 00:28:44,929
position normally it starts from 0 ah

00:28:45,559 --> 00:28:55,070
yeah yeah that would be good

00:28:49,429 --> 00:28:58,200
accumulators yep I'm actually going to

00:28:55,070 --> 00:29:00,960
leave that although I might just mention

00:28:58,200 --> 00:29:05,610
a little bit on if I was creating my own

00:29:00,960 --> 00:29:08,909
list from scratch then a collections dot

00:29:05,610 --> 00:29:09,690
would be useful something like

00:29:08,909 --> 00:29:14,009
collections

00:29:09,690 --> 00:29:14,730
eatable would be a nice one maybe while

00:29:14,009 --> 00:29:21,950
you're at it

00:29:14,730 --> 00:29:21,950
go and get collections dot ABC dot size

00:29:22,009 --> 00:29:25,590
I'm really interested and I don't

00:29:24,360 --> 00:29:27,299
actually know because I'm plagued with

00:29:25,590 --> 00:29:29,970
three five yet but I'm really interested

00:29:27,299 --> 00:29:33,210
to see how we could get the argument

00:29:29,970 --> 00:29:34,649
types to implements those interfaces and

00:29:33,210 --> 00:29:38,820
that would give me a really nice

00:29:34,649 --> 00:29:50,029
solution and so when I get to three five

00:29:38,820 --> 00:29:52,740
I will redo this talk okay yep okay so

00:29:50,029 --> 00:29:55,230
that's that's probably enough of my

00:29:52,740 --> 00:29:58,169
average function but I've given you some

00:29:55,230 --> 00:30:01,590
things to think about while we're

00:29:58,169 --> 00:30:06,330
talking about Python let's go and have a

00:30:01,590 --> 00:30:09,659
look at some other aspects of pythonic

00:30:06,330 --> 00:30:12,419
design system design I'm just putting

00:30:09,659 --> 00:30:14,100
these here first for completeness but um

00:30:12,419 --> 00:30:15,809
you should be fairly up on all of these

00:30:14,100 --> 00:30:19,679
these are pretty obvious similar code

00:30:15,809 --> 00:30:21,539
maker function Cody will correct me if

00:30:19,679 --> 00:30:23,279
I'm wrong and apologies Cody for

00:30:21,539 --> 00:30:25,710
insulting you in front of all of these

00:30:23,279 --> 00:30:28,440
people but when Cody I think it was his

00:30:25,710 --> 00:30:32,100
first game he wrote had a main line of

00:30:28,440 --> 00:30:33,570
just over three thousand lines that was

00:30:32,100 --> 00:30:35,490
quite a program I hadn't really helped

00:30:33,570 --> 00:30:39,179
him and he was doing an exercise for pi

00:30:35,490 --> 00:30:41,159
week the gaming challenge and he hadn't

00:30:39,179 --> 00:30:43,049
really kind of figured out functions so

00:30:41,159 --> 00:30:46,379
he just sort of copied and pasted copied

00:30:43,049 --> 00:30:48,960
and pasted copied and pasted if I was

00:30:46,379 --> 00:30:52,379
creating a pythonic IDE I would actually

00:30:48,960 --> 00:30:58,200
remove copy and paste copy and paste is

00:30:52,379 --> 00:31:00,899
evil he then got functions and made his

00:30:58,200 --> 00:31:02,580
program a lot smaller so pythonic design

00:31:00,899 --> 00:31:05,370
I don't want to see three thousand line

00:31:02,580 --> 00:31:07,379
main lines that's too long break it up

00:31:05,370 --> 00:31:09,269
into functions if you got duplicated

00:31:07,379 --> 00:31:10,590
functions make a module these are all

00:31:09,269 --> 00:31:12,809
straightforward things that I think you

00:31:10,590 --> 00:31:15,149
should be wary of related modules make a

00:31:12,809 --> 00:31:18,840
package but this is Python remember the

00:31:15,149 --> 00:31:21,960
Zen flat is better than nested I don't

00:31:18,840 --> 00:31:23,280
want five levels of nesting of packages

00:31:21,960 --> 00:31:26,400
inside packages inside

00:31:23,280 --> 00:31:28,770
packages this isn't Java if you need a

00:31:26,400 --> 00:31:34,740
type make a class if you've got similar

00:31:28,770 --> 00:31:38,610
classes look at inheritance that was

00:31:34,740 --> 00:31:43,290
part 2 part 3 and the final part is

00:31:38,610 --> 00:31:46,080
class design when you're coming to

00:31:43,290 --> 00:31:48,390
design classes like my list I need to

00:31:46,080 --> 00:31:50,850
look at what is the data and how does it

00:31:48,390 --> 00:31:54,030
behave and I want to emphasize that

00:31:50,850 --> 00:31:56,910
getters and setters are evil getters and

00:31:54,030 --> 00:31:59,580
setters are what eclipse makes job makes

00:31:56,910 --> 00:32:01,860
Java programmers do where every

00:31:59,580 --> 00:32:03,630
attribute has one getter and one setter

00:32:01,860 --> 00:32:06,570
and that's not object-oriented design

00:32:03,630 --> 00:32:08,400
that's certainly it's data hiding it's a

00:32:06,570 --> 00:32:11,010
it's hiding the data underneath a layer

00:32:08,400 --> 00:32:14,130
but getters and setters are evil Python

00:32:11,010 --> 00:32:16,110
has the lovely options of properties the

00:32:14,130 --> 00:32:20,340
property command the property decorator

00:32:16,110 --> 00:32:22,170
to give you that functionality because

00:32:20,340 --> 00:32:24,240
the general rule in object-oriented

00:32:22,170 --> 00:32:28,290
design is touch your data as little as

00:32:24,240 --> 00:32:30,060
possible that data is precious and don't

00:32:28,290 --> 00:32:32,190
you do the work get somebody else to do

00:32:30,060 --> 00:32:38,160
it in other words one method calls

00:32:32,190 --> 00:32:40,620
another method talking about class

00:32:38,160 --> 00:32:43,050
design at a high level we need to

00:32:40,620 --> 00:32:44,490
consider the three phrases that you'll

00:32:43,050 --> 00:32:46,560
come across when you start looking at

00:32:44,490 --> 00:32:50,010
object-oriented design which is is ax

00:32:46,560 --> 00:32:52,020
has ER and is like a these are just

00:32:50,010 --> 00:32:56,960
useful terms for you to be familiar with

00:32:52,020 --> 00:32:59,850
so if I had a class here a book class

00:32:56,960 --> 00:33:02,790
which is actually a specialized kind of

00:32:59,850 --> 00:33:06,240
a document really a book is a document

00:33:02,790 --> 00:33:09,150
with an ISBN and I just threw this in

00:33:06,240 --> 00:33:13,110
here for Brendan I'll instantiate an

00:33:09,150 --> 00:33:19,850
object of class book call it B so the is

00:33:13,110 --> 00:33:25,590
a has a and is like a well the B is a

00:33:19,850 --> 00:33:31,590
book either as instantiation has ur a

00:33:25,590 --> 00:33:33,780
book has a ISBN a book has a title

00:33:31,590 --> 00:33:37,440
because it inherited it from document

00:33:33,780 --> 00:33:42,480
and is like a a

00:33:37,440 --> 00:33:44,490
is like a document these sorts of design

00:33:42,480 --> 00:33:48,800
constructions crop up when you starting

00:33:44,490 --> 00:33:51,000
to make patterns that is design patterns

00:33:48,800 --> 00:33:52,710
now when people talk about design

00:33:51,000 --> 00:33:56,310
patterns they're usually referring to

00:33:52,710 --> 00:33:58,860
this book which is a great book I will

00:33:56,310 --> 00:34:02,400
say and it's heavy going this is this is

00:33:58,860 --> 00:34:05,430
hard work and it's aimed at C++ and Java

00:34:02,400 --> 00:34:07,440
programmers and building on learning

00:34:05,430 --> 00:34:09,149
from previous design I'm not going to

00:34:07,440 --> 00:34:10,770
recommend that book to you and I'm not

00:34:09,149 --> 00:34:14,790
going to recommend the concept even of

00:34:10,770 --> 00:34:17,640
those design patterns there is some of

00:34:14,790 --> 00:34:21,510
the 23 design patterns that that book

00:34:17,640 --> 00:34:24,270
refers to and the interesting thing is

00:34:21,510 --> 00:34:27,360
Peter Norvig one of the the engineers at

00:34:24,270 --> 00:34:29,850
Google did a very good paper on design

00:34:27,360 --> 00:34:32,490
patterns in paths in dynamic languages

00:34:29,850 --> 00:34:34,380
and showed that at least 16 of the 23

00:34:32,490 --> 00:34:38,149
are actually no longer necessary because

00:34:34,380 --> 00:34:40,890
the language supports it like directly

00:34:38,149 --> 00:34:43,350
because the design pattern book is all

00:34:40,890 --> 00:34:46,110
around the strictures of those languages

00:34:43,350 --> 00:34:50,570
C++ and Java Python has its own patterns

00:34:46,110 --> 00:34:52,350
in Python everything's an object and

00:34:50,570 --> 00:34:55,350
functions are easier remember that

00:34:52,350 --> 00:34:57,570
functions are first class objects let me

00:34:55,350 --> 00:35:01,710
give you a factory and a sorting example

00:34:57,570 --> 00:35:05,760
there's a factory because a class design

00:35:01,710 --> 00:35:07,980
is in fact an object you can pass it to

00:35:05,760 --> 00:35:13,920
a function done

00:35:07,980 --> 00:35:16,290
that's factories next and something like

00:35:13,920 --> 00:35:17,610
that is just so trivial in Python if I

00:35:16,290 --> 00:35:22,860
took the comments out it's like four

00:35:17,610 --> 00:35:27,050
lines sorting here you go this is for my

00:35:22,860 --> 00:35:29,280
Java friends the sorting example in Java

00:35:27,050 --> 00:35:32,780
it's actually a nice design it's just

00:35:29,280 --> 00:35:32,780
hard work everything in Java is like

00:35:33,200 --> 00:35:39,390
sorting in Python is trivial because I I

00:35:37,830 --> 00:35:41,130
can go and do a sort

00:35:39,390 --> 00:35:43,140
although the sorting order that that

00:35:41,130 --> 00:35:45,980
will give me will probably be not the

00:35:43,140 --> 00:35:45,980
order that I want

00:35:46,080 --> 00:35:49,400
forgive me Python three people I'm using

00:35:48,300 --> 00:35:51,050
comp

00:35:49,400 --> 00:35:55,730
but I could do the same sort of thing

00:35:51,050 --> 00:35:57,830
with ki and creating an anonymous

00:35:55,730 --> 00:36:03,620
function or an a named function if you'd

00:35:57,830 --> 00:36:05,510
like to do the sort the proper patterns

00:36:03,620 --> 00:36:08,120
that I'll look at include Singleton's

00:36:05,510 --> 00:36:12,200
are we already have Singleton's they're

00:36:08,120 --> 00:36:16,850
modules so if you've got a class that

00:36:12,200 --> 00:36:19,910
just has static methods then that's a

00:36:16,850 --> 00:36:22,040
module pop it into a module done let's

00:36:19,910 --> 00:36:27,410
look at iterators adapters proxies

00:36:22,040 --> 00:36:30,590
there it is in C++ I read that slide

00:36:27,410 --> 00:36:34,850
lint program over this presentation that

00:36:30,590 --> 00:36:37,040
said you've gone off the page and also

00:36:34,850 --> 00:36:38,960
complained about me using my in the

00:36:37,040 --> 00:36:41,620
thanks that says thanks to my wife and

00:36:38,960 --> 00:36:46,780
it wasn't happy about that either

00:36:41,620 --> 00:36:49,820
don't tell her in java using an iterator

00:36:46,780 --> 00:36:51,890
used to be ugly now it looks like that

00:36:49,820 --> 00:36:54,170
and I just like to throw this to you

00:36:51,890 --> 00:37:02,150
because the Java people even pronounce

00:36:54,170 --> 00:37:05,180
that in the actual code for a job or

00:37:02,150 --> 00:37:06,860
iterable implements and that's where I'm

00:37:05,180 --> 00:37:09,470
looking at the type hinting helping me

00:37:06,860 --> 00:37:15,310
out and the inner class and yes it's

00:37:09,470 --> 00:37:17,570
even got a next homage to Python 2 and

00:37:15,310 --> 00:37:20,420
therefore an iterator example in Python

00:37:17,570 --> 00:37:22,130
is trivial and I've forgive me again I'm

00:37:20,420 --> 00:37:25,130
jumping between two and three here I've

00:37:22,130 --> 00:37:28,720
got a three version there and I do like

00:37:25,130 --> 00:37:33,110
this we're actually mixing in that class

00:37:28,720 --> 00:37:35,120
an adapter adapters again there's

00:37:33,110 --> 00:37:36,950
actually quite a difference quite a lot

00:37:35,120 --> 00:37:39,380
of selections that I could do here I've

00:37:36,950 --> 00:37:42,110
got a B class object but I want it to

00:37:39,380 --> 00:37:44,990
have a function one or I don't want to

00:37:42,110 --> 00:37:50,360
have it function one I don't want that

00:37:44,990 --> 00:37:56,180
pin to fit in anymore don't have it so

00:37:50,360 --> 00:37:57,590
adapters again trivial in Python proxies

00:37:56,180 --> 00:38:00,710
this is I've actually just done this a

00:37:57,590 --> 00:38:03,020
subtly different way building an object

00:38:00,710 --> 00:38:06,320
inside it as opposed to it

00:38:03,020 --> 00:38:08,480
being one it being like one and I'll put

00:38:06,320 --> 00:38:12,680
at least some slides up later for those

00:38:08,480 --> 00:38:14,990
that want to grab them so market

00:38:12,680 --> 00:38:18,770
collection market classes like iterable

00:38:14,990 --> 00:38:21,980
sized abstract classes inheriting from

00:38:18,770 --> 00:38:23,930
for example collections sequence gives

00:38:21,980 --> 00:38:28,010
me an abstract class or define the

00:38:23,930 --> 00:38:33,080
metaclass and Java people yes we can do

00:38:28,010 --> 00:38:35,450
multiple based classes which brings me

00:38:33,080 --> 00:38:38,900
to thanks my wife am I allowed to say

00:38:35,450 --> 00:38:41,810
that and family I want to thank the

00:38:38,900 --> 00:38:44,480
Python committee again for allowing me

00:38:41,810 --> 00:38:47,900
to have a have a talk thank you

00:38:44,480 --> 00:38:50,300
and to the inspiration for the phrase on

00:38:47,900 --> 00:38:52,420
being from Brenda brown and Krista

00:38:50,300 --> 00:38:52,420
Tippett

00:39:02,130 --> 00:39:07,390
okay we've got about five minutes for

00:39:04,420 --> 00:39:10,090
questions anyone I have a young

00:39:07,390 --> 00:39:26,470
enticement every young every question

00:39:10,090 --> 00:39:29,140
gets a mr. happy yeah so what's this is

00:39:26,470 --> 00:39:31,630
more about plus plus all right what

00:39:29,140 --> 00:39:38,530
level what level of training do you

00:39:31,630 --> 00:39:40,960
cater for to and from yeah a lot so my

00:39:38,530 --> 00:39:44,170
background is some C C++ so I'm coming

00:39:40,960 --> 00:39:46,240
from the nasty in the hardened I'm

00:39:44,170 --> 00:39:48,130
actually the I run training courses for

00:39:46,240 --> 00:39:50,110
all sorts of clients everything from

00:39:48,130 --> 00:39:53,050
non-programmers which I'm very surprised

00:39:50,110 --> 00:39:56,590
to find and I'm hoping that the the

00:39:53,050 --> 00:39:59,590
impetus into schools means that that

00:39:56,590 --> 00:40:01,930
part of my job will decay over time I

00:39:59,590 --> 00:40:04,420
actually run a whole range of courses

00:40:01,930 --> 00:40:06,370
and you can see them at my website so

00:40:04,420 --> 00:40:08,620
through the very advanced sort of end

00:40:06,370 --> 00:40:13,000
oh yeah just wanted to point out

00:40:08,620 --> 00:40:16,150
something with our certs yes Pisces will

00:40:13,000 --> 00:40:18,010
suppress them - oh sorry what did you

00:40:16,150 --> 00:40:20,710
say sorry with the asserts if you put an

00:40:18,010 --> 00:40:22,780
assert in your code yep

00:40:20,710 --> 00:40:24,310
a new PI - exits for say a Windows

00:40:22,780 --> 00:40:26,710
deployment I guess yes yes I'm familiar

00:40:24,310 --> 00:40:32,620
with flow - XE and the other thing being

00:40:26,710 --> 00:40:35,050
aware of is that python - well capital o

00:40:32,620 --> 00:40:38,410
option optimizers and that also removes

00:40:35,050 --> 00:40:40,540
asserts so asserts have a value but they

00:40:38,410 --> 00:40:41,860
also produce a performance penalty

00:40:40,540 --> 00:40:44,770
because they evaluate them every time

00:40:41,860 --> 00:40:48,160
you can have a mr. happy

00:40:44,770 --> 00:40:52,360
are you got one and - o which optimizes

00:40:48,160 --> 00:40:53,080
it's not quite as good as sizing it - oh

00:40:52,360 --> 00:40:55,150
oh

00:40:53,080 --> 00:40:58,180
fully optimizes which just removes

00:40:55,150 --> 00:41:00,670
docstrings but yes it's worthwhile

00:40:58,180 --> 00:41:03,580
knowing about assert that it's not

00:41:00,670 --> 00:41:05,830
permanent good great while you're still

00:41:03,580 --> 00:41:08,200
testing though if you don't thanks for

00:41:05,830 --> 00:41:10,930
the talk ah

00:41:08,200 --> 00:41:13,079
so if I could to me didn't use many of

00:41:10,930 --> 00:41:17,829
the functional level things like yes

00:41:13,079 --> 00:41:18,460
yeah yeah true so are they they good

00:41:17,829 --> 00:41:20,680
consideration

00:41:18,460 --> 00:41:23,950
I guess the range the getting the length

00:41:20,680 --> 00:41:25,990
absolutely and um actually I didn't go

00:41:23,950 --> 00:41:27,790
into it in here but I would love to be

00:41:25,990 --> 00:41:29,829
using or throwing in things like

00:41:27,790 --> 00:41:33,750
itertools a lot in there funk tools

00:41:29,829 --> 00:41:37,480
gives us an enormous range of extra

00:41:33,750 --> 00:41:41,109
simplicity so if you're coming from the

00:41:37,480 --> 00:41:45,490
readable sensible then I'd be happy to

00:41:41,109 --> 00:41:47,410
use those I'm I just want to ask you is

00:41:45,490 --> 00:41:48,700
there any recommendations of books or

00:41:47,410 --> 00:41:50,410
maybe even your own work that you have

00:41:48,700 --> 00:41:51,640
for somebody that's kind of trying to

00:41:50,410 --> 00:41:53,859
get their head around the design

00:41:51,640 --> 00:41:55,240
patterns in Python that's coming from

00:41:53,859 --> 00:41:57,270
different languages that's a great

00:41:55,240 --> 00:41:59,859
question

00:41:57,270 --> 00:42:05,500
the quick answer is I don't know with

00:41:59,859 --> 00:42:07,420
any I actually got a lot of value out of

00:42:05,500 --> 00:42:10,329
two books when I first entered this

00:42:07,420 --> 00:42:12,250
realm one which was C++ for C

00:42:10,329 --> 00:42:15,400
programmers which was actually purely

00:42:12,250 --> 00:42:18,160
about thinking in objects because that's

00:42:15,400 --> 00:42:19,690
the conceptual shift it's a little

00:42:18,160 --> 00:42:21,940
interesting in Python because it's

00:42:19,690 --> 00:42:24,460
pretty it is in fact a much more

00:42:21,940 --> 00:42:27,040
object-oriented language than Java where

00:42:24,460 --> 00:42:29,619
Java is a terrible mishmash of languages

00:42:27,040 --> 00:42:31,540
with fundamental primitive types and

00:42:29,619 --> 00:42:35,440
class types and different rules for them

00:42:31,540 --> 00:42:37,000
all so whereas in Python everything's an

00:42:35,440 --> 00:42:39,040
object but we still actually program it

00:42:37,000 --> 00:42:41,680
a lot like a procedural language which

00:42:39,040 --> 00:42:43,720
is actually not a great thing to quickly

00:42:41,680 --> 00:42:47,200
answer the question I don't know of any

00:42:43,720 --> 00:42:51,099
good pythonic object-orientation books

00:42:47,200 --> 00:42:52,780
although nick might know of one mark

00:42:51,099 --> 00:42:54,520
Summerfield's Python in practice the

00:42:52,780 --> 00:42:55,690
first few chapters are design patterns

00:42:54,520 --> 00:43:01,869
okay great

00:42:55,690 --> 00:43:04,960
thank you in purple yes you talked a lot

00:43:01,869 --> 00:43:07,210
about inheritance yes are there times

00:43:04,960 --> 00:43:09,730
when you consider composition should be

00:43:07,210 --> 00:43:11,650
preferred over inheritance good how does

00:43:09,730 --> 00:43:13,180
Python do you feel Python supports that

00:43:11,650 --> 00:43:14,559
yeah that's a great question now I

00:43:13,180 --> 00:43:17,619
didn't actually get to the composition

00:43:14,559 --> 00:43:20,980
talk yesterday which was unfortunate

00:43:17,619 --> 00:43:22,570
because I wanted to but I would actually

00:43:20,980 --> 00:43:24,520
there are they're at

00:43:22,570 --> 00:43:28,180
where it's quite appropriate to do the

00:43:24,520 --> 00:43:31,590
is subclass now if I'm doing is subclass

00:43:28,180 --> 00:43:35,530
composition doesn't help that at all so

00:43:31,590 --> 00:43:39,520
the the the object-oriented question of

00:43:35,530 --> 00:43:42,940
is this like one of those as opposed to

00:43:39,520 --> 00:43:52,200
does this have one of those is the issue

00:43:42,940 --> 00:43:52,200
so the one that I had here of my book

00:43:52,770 --> 00:44:07,540
which was there yes it's quite not with

00:44:02,350 --> 00:44:08,980
my book went there it's reasonable to

00:44:07,540 --> 00:44:10,570
say that a book is like a document

00:44:08,980 --> 00:44:15,430
there's many similarities in their

00:44:10,570 --> 00:44:17,980
behavior but a book document is not like

00:44:15,430 --> 00:44:22,150
a title a title is part of its

00:44:17,980 --> 00:44:23,980
composition so the important thing to

00:44:22,150 --> 00:44:26,080
note there is that a book will stand in

00:44:23,980 --> 00:44:28,090
at any place where a document would work

00:44:26,080 --> 00:44:29,440
so if I've got somewhere where a

00:44:28,090 --> 00:44:31,030
document would work because I've

00:44:29,440 --> 00:44:33,100
inherited from document unlike a

00:44:31,030 --> 00:44:36,910
document and I can be used anywhere that

00:44:33,100 --> 00:44:39,160
a document could be used I could

00:44:36,910 --> 00:44:41,650
actually do composition and then recode

00:44:39,160 --> 00:44:43,240
the API or the methods that I want the

00:44:41,650 --> 00:44:45,490
interface that I want to get that

00:44:43,240 --> 00:44:54,580
behavior but then his subclass wouldn't

00:44:45,490 --> 00:44:56,530
work so yeah oh sorry um I was just

00:44:54,580 --> 00:44:57,850
seeking closure on your average function

00:44:56,530 --> 00:45:01,330
can you show us what would be the

00:44:57,850 --> 00:45:03,610
pythonic way yeah look actually I will

00:45:01,330 --> 00:45:07,800
and this will be a bit bit um a bit

00:45:03,610 --> 00:45:13,240
unfortunate so what I would say would be

00:45:07,800 --> 00:45:16,270
that maybe without so many parens you

00:45:13,240 --> 00:45:17,920
know to be honest I went on a bit of a

00:45:16,270 --> 00:45:26,490
journey but I'm actually quite happy

00:45:17,920 --> 00:45:26,490
with that oh sorry yes I'm correct

00:45:27,200 --> 00:45:31,980
you know that's not perfect and there's

00:45:29,850 --> 00:45:33,570
many deficiencies of that but I'm

00:45:31,980 --> 00:45:35,700
actually quite happy with that from a

00:45:33,570 --> 00:45:38,190
pythonic perspective because it's

00:45:35,700 --> 00:45:40,530
actually satisfying the readable the

00:45:38,190 --> 00:45:51,240
fact that it crashes if they give it a

00:45:40,530 --> 00:45:53,220
no length good yeah is that about time

00:45:51,240 --> 00:45:54,510
yeah that's a I'm not hanging around so

00:45:53,220 --> 00:45:56,130
if you've got any more questions or if

00:45:54,510 --> 00:45:57,690
you'd like a mr. happy and you didn't

00:45:56,130 --> 00:46:00,750
get one you're welcome to come and get

00:45:57,690 --> 00:46:03,900
one okay and just before we end we have

00:46:00,750 --> 00:46:07,170
to do this it has to happen okay here is

00:46:03,900 --> 00:46:09,920
your honorary mug lovely thank you give

00:46:07,170 --> 00:46:09,920
him a round of applause

00:46:20,680 --> 00:46:22,740

YouTube URL: https://www.youtube.com/watch?v=R4AeB85gEeU


