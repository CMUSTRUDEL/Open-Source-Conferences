Title: Python's New Type Hints in Actionâ€¦ In JavaScript by Christopher Neugebauer
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Depending on who you ask, PEP 484's Type Hints are either the next big thing in Python, or the harbinger of doom upon our entire community. Which is it?

Allowing optional static typing in Python will bring with it some benefits that other languages have had for years: IDEs will be able to do code completion better; a whole class of boring tests will fall out automatically; and some bugs will be easier to catch. 

But this is also undeniably a huge change of direction: will it mean you have to substantially change your code style? Will Python's simple expressiveness suddenly become unattainable thanks to clumsy Java-style type declarations?

To show how PEP 484's Gradual Typing system works, we're going to look at TypeScript, a minimal implementation of Gradual Typing over JavaScript. We'll see how the type system works, and how it fits into the already thriving JavaScript developer community, where most people aren't using type hints at all.

We'll draw some parallels with how Python's implementation will work, and see what Python can learn from a language that has successfully made the jump to a type-hinted world.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,019 --> 00:00:17,130
bought today depending on who you ask PP

00:00:12,869 --> 00:00:19,140
484 type hints are either the next big

00:00:17,130 --> 00:00:21,570
thing in Python or a harbinger of doom

00:00:19,140 --> 00:00:25,380
for your entire community which is it

00:00:21,570 --> 00:00:27,169
going to be well Christopher nike bauer

00:00:25,380 --> 00:00:30,689
is going to talk about this this morning

00:00:27,169 --> 00:00:33,660
so afternoon actually so over to you all

00:00:30,689 --> 00:00:35,460
right this is a surprisingly full room

00:00:33,660 --> 00:00:38,719
at a Python conference for talking about

00:00:35,460 --> 00:00:41,309
Thai painting I can only assume that

00:00:38,719 --> 00:00:42,840
that either you're all very very boring

00:00:41,309 --> 00:00:44,850
people because as we know types of

00:00:42,840 --> 00:00:47,430
fundamentally boring and unnecessary or

00:00:44,850 --> 00:00:48,870
you all completely hate Python and

00:00:47,430 --> 00:00:52,649
everything it stands for I'm not

00:00:48,870 --> 00:00:58,760
entirely sure which it is um why do you

00:00:52,649 --> 00:01:01,890
hate fight then them's fighting words

00:00:58,760 --> 00:01:03,480
okay so my name is it's Christopher

00:01:01,890 --> 00:01:05,519
negh'var I have cleverly hidden my

00:01:03,480 --> 00:01:07,259
twitter handle on the on the slide there

00:01:05,519 --> 00:01:09,630
somewhere if you wish to heckle me

00:01:07,259 --> 00:01:11,369
online during the talk I don't promise

00:01:09,630 --> 00:01:12,780
to respond i kind of need to give a talk

00:01:11,369 --> 00:01:15,090
rather than replying to you but i will

00:01:12,780 --> 00:01:18,569
gladly reply after the talk is finished

00:01:15,090 --> 00:01:20,880
so yes we're here to talk about type

00:01:18,569 --> 00:01:22,979
painting in python and to start talking

00:01:20,880 --> 00:01:25,049
about pipe in your pipe and we need to

00:01:22,979 --> 00:01:28,889
look at how Python has come to where it

00:01:25,049 --> 00:01:31,549
is and pythons it has existed since 1991

00:01:28,889 --> 00:01:34,139
and up until about two thousand eight

00:01:31,549 --> 00:01:36,209
Python used duck typing you know where

00:01:34,139 --> 00:01:38,279
you can just supply any old object in

00:01:36,209 --> 00:01:41,639
there the hope that has the methods on

00:01:38,279 --> 00:01:43,700
it that you need and if it works you

00:01:41,639 --> 00:01:47,840
know that's fine that's how Python works

00:01:43,700 --> 00:01:50,579
people like duck typing in Python now

00:01:47,840 --> 00:01:52,829
when they were planning Python version 3

00:01:50,579 --> 00:01:54,599
they introduced this feature called

00:01:52,829 --> 00:01:58,349
function annotations this is where you

00:01:54,599 --> 00:02:00,329
specify annotations to an argument using

00:01:58,349 --> 00:02:05,189
a thing after the colon in the argument

00:02:00,329 --> 00:02:06,810
list and you can specify return return

00:02:05,189 --> 00:02:08,520
annotations using that arrow that

00:02:06,810 --> 00:02:11,250
appears at the end of the function

00:02:08,520 --> 00:02:15,150
declaration this was introduced in pep

00:02:11,250 --> 00:02:17,250
3107 it was released in Python 3.0 so

00:02:15,150 --> 00:02:18,960
it's been around for quite some time now

00:02:17,250 --> 00:02:22,230
these function annotations did not

00:02:18,960 --> 00:02:23,610
actually need to be type annotations if

00:02:22,230 --> 00:02:25,620
you wanted to for example

00:02:23,610 --> 00:02:27,420
Oh generate documentation you could put

00:02:25,620 --> 00:02:29,550
strings at the end of them and use a

00:02:27,420 --> 00:02:31,230
tool and inspected your objects to spit

00:02:29,550 --> 00:02:33,300
out documentation you could put strings

00:02:31,230 --> 00:02:34,590
you can put strings as the return

00:02:33,300 --> 00:02:37,110
annotation if you wanted type

00:02:34,590 --> 00:02:39,620
annotations could be anything because

00:02:37,110 --> 00:02:42,690
there wasn't really any use for them now

00:02:39,620 --> 00:02:45,270
after these type in its annotations were

00:02:42,690 --> 00:02:47,730
introduced in Python 3 nobody really did

00:02:45,270 --> 00:02:50,550
anything with this feature type checking

00:02:47,730 --> 00:02:52,500
was definitely in the rationale for for

00:02:50,550 --> 00:02:53,670
that pep I've read it it says type

00:02:52,500 --> 00:02:56,040
checking will be a thing that will

00:02:53,670 --> 00:02:57,450
happen at some point in the time they

00:02:56,040 --> 00:02:58,860
didn't say how they were going to do it

00:02:57,450 --> 00:03:00,959
I what they were going to do with it so

00:02:58,860 --> 00:03:03,480
for the next six years of developing

00:03:00,959 --> 00:03:08,459
Python nobody did anything with with

00:03:03,480 --> 00:03:11,280
type annotations so this year pet 484

00:03:08,459 --> 00:03:14,280
came about which proposes doing using

00:03:11,280 --> 00:03:16,380
these annotations in Python to do type

00:03:14,280 --> 00:03:18,870
checking and providing a standardized

00:03:16,380 --> 00:03:20,370
way to do it these annotations here show

00:03:18,870 --> 00:03:26,040
a function that takes a string and

00:03:20,370 --> 00:03:27,480
returns a string using type hints so pet

00:03:26,040 --> 00:03:29,760
for eight fours approach is to use

00:03:27,480 --> 00:03:32,330
annotation and a bunch of hint objects

00:03:29,760 --> 00:03:34,920
in a standard LED module called typing

00:03:32,330 --> 00:03:36,900
it provides a type checker to provide

00:03:34,920 --> 00:03:39,630
actual type checking linting

00:03:36,900 --> 00:03:42,390
functionality and all the type hinting

00:03:39,630 --> 00:03:44,220
functionality in Python 35 has been

00:03:42,390 --> 00:03:47,880
implemented without changing the

00:03:44,220 --> 00:03:49,140
language as it currently exists now for

00:03:47,880 --> 00:03:51,209
those of you who don't know how the

00:03:49,140 --> 00:03:53,700
Python enhancement process works

00:03:51,209 --> 00:03:55,440
basically features efficiently come into

00:03:53,700 --> 00:03:58,230
existence using this three phase process

00:03:55,440 --> 00:04:00,870
firstly somebody suggests a pep and it

00:03:58,230 --> 00:04:03,750
gets discussed on mailing lists Stage

00:04:00,870 --> 00:04:05,610
two is that the pep is adopted and stage

00:04:03,750 --> 00:04:07,590
three is that actually gets added to

00:04:05,610 --> 00:04:10,110
Python now this is how it works in

00:04:07,590 --> 00:04:13,230
theory in practice these three steps are

00:04:10,110 --> 00:04:15,630
also required basically everybody starts

00:04:13,230 --> 00:04:17,669
ignoring the feature completely if they

00:04:15,630 --> 00:04:20,489
get ignored for three to four releases

00:04:17,669 --> 00:04:22,200
and then eventually somebody like rain

00:04:20,489 --> 00:04:24,180
and hediger or David Beasley gives a

00:04:22,200 --> 00:04:26,310
talk at pycon which says this is how you

00:04:24,180 --> 00:04:28,440
actually use this thing everyone goes

00:04:26,310 --> 00:04:31,260
yes that's fantastic and then they use

00:04:28,440 --> 00:04:33,660
it this means that by the time people

00:04:31,260 --> 00:04:35,310
are using a thing it's mature somebody

00:04:33,660 --> 00:04:35,990
incall Python knows how to use it and

00:04:35,310 --> 00:04:39,860
nobody

00:04:35,990 --> 00:04:42,020
really questions it unfortunately this

00:04:39,860 --> 00:04:44,180
year it went slightly wrong in that gido

00:04:42,020 --> 00:04:46,100
was given a keynote slot at PyCon to

00:04:44,180 --> 00:04:48,350
discuss the feature this year two and a

00:04:46,100 --> 00:04:50,300
half thousand people were watching jido

00:04:48,350 --> 00:04:52,520
talk about this thing that had not yet

00:04:50,300 --> 00:04:55,520
gone into Python and didn't have an

00:04:52,520 --> 00:05:00,230
implementation and so this part did not

00:04:55,520 --> 00:05:02,900
happen and what that means is that

00:05:00,230 --> 00:05:05,120
despite saying this Python will remain

00:05:02,900 --> 00:05:08,990
dynamically typed tight pants will never

00:05:05,120 --> 00:05:13,120
be mandatory even by convention grumpy

00:05:08,990 --> 00:05:16,550
old people like Jack say this Python

00:05:13,120 --> 00:05:18,770
Python for is hidden inside this Python

00:05:16,550 --> 00:05:20,390
enhancement proposal it is going to

00:05:18,770 --> 00:05:23,050
completely change paths and this is

00:05:20,390 --> 00:05:26,660
terrible get the hell away from it

00:05:23,050 --> 00:05:28,790
basically the discussions around pet 44

00:05:26,660 --> 00:05:32,330
have turned into a tar pit and this is

00:05:28,790 --> 00:05:36,080
terrible so that brings us to the point

00:05:32,330 --> 00:05:39,200
of this talk I I think we should go and

00:05:36,080 --> 00:05:42,290
use thi painting now except we have a

00:05:39,200 --> 00:05:46,220
slight problem with this it is not yet

00:05:42,290 --> 00:05:48,350
implemented nobody is using it which

00:05:46,220 --> 00:05:51,170
means we can't really use it in Python

00:05:48,350 --> 00:05:55,130
so let's look at a language that

00:05:51,170 --> 00:05:57,800
hopefully you already know a language

00:05:55,130 --> 00:06:00,260
most people unfortunately no at the

00:05:57,800 --> 00:06:02,810
moment is JavaScript and there is a

00:06:00,260 --> 00:06:05,870
language that implements the type hints

00:06:02,810 --> 00:06:10,010
that Python there are Python 3.5 in pep

00:06:05,870 --> 00:06:12,890
484 is is trying to implement and it's

00:06:10,010 --> 00:06:16,520
called typescript given the name it is

00:06:12,890 --> 00:06:19,670
just JavaScript with added type hints so

00:06:16,520 --> 00:06:21,410
it's actually a a Microsoft technology

00:06:19,670 --> 00:06:23,120
which is why I am slightly out of

00:06:21,410 --> 00:06:26,380
character wearing a collared shirt today

00:06:23,120 --> 00:06:26,380
it's actually a contractual obligation

00:06:28,199 --> 00:06:33,490
it's it's open source available under an

00:06:31,150 --> 00:06:35,229
apache license and it's starting to get

00:06:33,490 --> 00:06:37,240
pretty mature it's had a 1 point 0

00:06:35,229 --> 00:06:41,080
release it's been available in various

00:06:37,240 --> 00:06:43,479
stages of development since 2012 so this

00:06:41,080 --> 00:06:45,820
is your HelloWorld in Java Script

00:06:43,479 --> 00:06:47,350
probably familiar with it has a console

00:06:45,820 --> 00:06:50,440
dot log in there there is a string it

00:06:47,350 --> 00:06:52,750
says hello world and this is the same

00:06:50,440 --> 00:06:54,400
thing in typescript as you can see you

00:06:52,750 --> 00:06:59,740
are deeply familiar with this language

00:06:54,400 --> 00:07:01,930
already typescript is just JavaScript

00:06:59,740 --> 00:07:04,000
you need to start writing more

00:07:01,930 --> 00:07:06,820
complicated code in order to see the

00:07:04,000 --> 00:07:09,100
difference so this is a JavaScript

00:07:06,820 --> 00:07:11,229
function that construct a string from a

00:07:09,100 --> 00:07:13,060
string parameter so there's a there's a

00:07:11,229 --> 00:07:16,780
name parameter in that in that function

00:07:13,060 --> 00:07:19,960
and it returns a string in typescript we

00:07:16,780 --> 00:07:22,780
have a type hint for the for the input

00:07:19,960 --> 00:07:24,880
value and a type hint for the output so

00:07:22,780 --> 00:07:27,160
if you call that hello function with an

00:07:24,880 --> 00:07:29,229
on string parameter it will fail type

00:07:27,160 --> 00:07:31,750
checking and likewise assigning the

00:07:29,229 --> 00:07:34,270
return of that of that function to

00:07:31,750 --> 00:07:37,720
something that isn't expecting a string

00:07:34,270 --> 00:07:39,460
will also fail typescript being an

00:07:37,720 --> 00:07:40,780
extension over typescript over

00:07:39,460 --> 00:07:42,159
JavaScript will not run in your

00:07:40,780 --> 00:07:44,800
browser's you need to run it through a

00:07:42,159 --> 00:07:46,780
compiler to erase the types you

00:07:44,800 --> 00:07:48,940
basically get exactly the same code as

00:07:46,780 --> 00:07:50,979
you would have written in JavaScript out

00:07:48,940 --> 00:07:52,930
from the typescript compiler so you can

00:07:50,979 --> 00:07:54,849
go and distribute that as JavaScript it

00:07:52,930 --> 00:07:56,409
runs exactly the same way as your

00:07:54,849 --> 00:07:58,449
JavaScript would have there's no type

00:07:56,409 --> 00:08:00,970
checking done in the browser because all

00:07:58,449 --> 00:08:05,590
the type annotations go away when you

00:08:00,970 --> 00:08:08,289
compile it now in this piece of in this

00:08:05,590 --> 00:08:11,409
piece of code because the variable a is

00:08:08,289 --> 00:08:14,650
a string and the two upper case method

00:08:11,409 --> 00:08:17,320
on a string also returns a string we can

00:08:14,650 --> 00:08:19,840
provide that variable B to the function

00:08:17,320 --> 00:08:21,550
hello because the type shaker has

00:08:19,840 --> 00:08:24,310
figured out so that's that it is a

00:08:21,550 --> 00:08:26,590
string this is type inference it means

00:08:24,310 --> 00:08:28,510
you don't need to manually hint every

00:08:26,590 --> 00:08:31,780
single function in every single variable

00:08:28,510 --> 00:08:35,770
you have some time are sometimes the

00:08:31,780 --> 00:08:38,440
compiler can figure it out for you this

00:08:35,770 --> 00:08:40,479
is very similar code but it's invalid

00:08:38,440 --> 00:08:42,909
typescript because math

00:08:40,479 --> 00:08:44,769
course returns a number and so even

00:08:42,909 --> 00:08:47,500
though we didn't annotate that variable

00:08:44,769 --> 00:08:51,130
D the compiler knows that D will be a

00:08:47,500 --> 00:08:53,290
number and so what this means is that if

00:08:51,130 --> 00:08:55,630
you only write or if you write code and

00:08:53,290 --> 00:08:57,970
it only interfaces with type checked

00:08:55,630 --> 00:09:00,430
functions then you get type checking on

00:08:57,970 --> 00:09:02,500
everything you write for free even if

00:09:00,430 --> 00:09:06,449
you don't specify type annotations on

00:09:02,500 --> 00:09:06,449
your own variables on your own functions

00:09:07,500 --> 00:09:12,730
even better if every single return point

00:09:10,389 --> 00:09:14,110
of a function is of a given type you get

00:09:12,730 --> 00:09:15,940
the type checking for free on that

00:09:14,110 --> 00:09:18,550
function so this this function here

00:09:15,940 --> 00:09:20,290
clearly returns a number so type

00:09:18,550 --> 00:09:21,639
inference knows that this thing that was

00:09:20,290 --> 00:09:23,440
that we're getting out of the function

00:09:21,639 --> 00:09:25,779
is a number and we can pass it into

00:09:23,440 --> 00:09:28,180
something that expects a number this

00:09:25,779 --> 00:09:29,589
version here is invalid because it

00:09:28,180 --> 00:09:33,459
returns a string even though we don't

00:09:29,589 --> 00:09:35,529
say it returns a string so thanks to

00:09:33,459 --> 00:09:37,510
type inference even if you don't care to

00:09:35,529 --> 00:09:39,699
annotate your own functions just

00:09:37,510 --> 00:09:42,010
consumer type in today p I you will

00:09:39,699 --> 00:09:43,959
benefit from testing your own code

00:09:42,010 --> 00:09:49,000
against a third parties provided

00:09:43,959 --> 00:09:51,730
constraints so so this type checking

00:09:49,000 --> 00:09:54,399
thing is pretty excellent but it's a

00:09:51,730 --> 00:09:58,329
language that relatively few people are

00:09:54,399 --> 00:10:00,100
using in comparison with JavaScript the

00:09:58,329 --> 00:10:01,899
people who wrote jquery which I presume

00:10:00,100 --> 00:10:03,550
everybody who has written JavaScript has

00:10:01,899 --> 00:10:06,100
used at some point the authors of that

00:10:03,550 --> 00:10:08,740
they don't know about typescript so does

00:10:06,100 --> 00:10:10,779
that mean you can't use it in typescript

00:10:08,740 --> 00:10:13,420
well there's this thing called gradual

00:10:10,779 --> 00:10:17,380
typing which is the crux of typescript

00:10:13,420 --> 00:10:20,319
typing system gradual typing refers to

00:10:17,380 --> 00:10:22,569
type systems that do not require every

00:10:20,319 --> 00:10:25,750
function do not require every variable

00:10:22,569 --> 00:10:28,540
in the in your program to participate in

00:10:25,750 --> 00:10:31,540
the type system gradual typing means

00:10:28,540 --> 00:10:33,550
that only some code needs to participate

00:10:31,540 --> 00:10:36,399
in the type system and it can do it

00:10:33,550 --> 00:10:39,220
without interfering with code that

00:10:36,399 --> 00:10:43,389
doesn't participate in a type system so

00:10:39,220 --> 00:10:45,730
the way this system works is that you

00:10:43,389 --> 00:10:47,170
get two ways to opt into getting on type

00:10:45,730 --> 00:10:49,240
checking the first is that you can

00:10:47,170 --> 00:10:51,490
explicitly declare a type so in this

00:10:49,240 --> 00:10:53,050
code snippet I've got a variable spam I

00:10:51,490 --> 00:10:57,370
say it's a string

00:10:53,050 --> 00:10:59,560
therefore it is definitely a string the

00:10:57,370 --> 00:11:02,440
other is to ignore writing tight pants

00:10:59,560 --> 00:11:04,209
yourself and see if the thief the

00:11:02,440 --> 00:11:07,390
typescript compiler can make a guess at

00:11:04,209 --> 00:11:09,310
it assigning a number to an unprinted

00:11:07,390 --> 00:11:12,339
variable means that the variable is

00:11:09,310 --> 00:11:14,800
inferred to be a number so math dot cos

00:11:12,339 --> 00:11:17,140
it returns a number therefore this

00:11:14,800 --> 00:11:21,610
variable here is known to be of type

00:11:17,140 --> 00:11:24,399
number now javascript has type coercion

00:11:21,610 --> 00:11:26,380
behavior that you may sometimes want so

00:11:24,399 --> 00:11:30,970
like that variable there is a string

00:11:26,380 --> 00:11:33,430
containing the number 42 in text and you

00:11:30,970 --> 00:11:37,209
can pass that into a javascript function

00:11:33,430 --> 00:11:39,190
that expects a numeric value type

00:11:37,209 --> 00:11:42,490
coercion turns it back into a number for

00:11:39,190 --> 00:11:46,300
us that is actually invalid typescript

00:11:42,490 --> 00:11:49,060
as it currently stands so what you can

00:11:46,300 --> 00:11:52,060
do is declare a variable to be of type

00:11:49,060 --> 00:11:54,430
any when you declare a variable to be of

00:11:52,060 --> 00:11:57,010
type any it doesn't participate in the

00:11:54,430 --> 00:11:59,200
type system it could be any type of

00:11:57,010 --> 00:12:03,940
value and you can use that variable

00:11:59,200 --> 00:12:06,250
anywhere any is the thing that makes

00:12:03,940 --> 00:12:08,320
typescripts type system actually work

00:12:06,250 --> 00:12:10,899
things that come out of plain old

00:12:08,320 --> 00:12:13,270
JavaScript without type hints at all are

00:12:10,899 --> 00:12:15,839
assumed to be any until you as a

00:12:13,270 --> 00:12:18,880
developer make assertions about its type

00:12:15,839 --> 00:12:20,320
so there's no type constraints at all on

00:12:18,880 --> 00:12:23,200
stuff that comes out of plain old

00:12:20,320 --> 00:12:25,450
JavaScript that is until the compiler is

00:12:23,200 --> 00:12:29,410
completely certain that type constraints

00:12:25,450 --> 00:12:31,240
can apply and what that means is that

00:12:29,410 --> 00:12:33,010
this is completely different to static

00:12:31,240 --> 00:12:35,680
typing as you get in languages like Java

00:12:33,010 --> 00:12:38,829
you do not need to introduce any type

00:12:35,680 --> 00:12:40,329
constraints into your code until you are

00:12:38,829 --> 00:12:42,880
ready to start dealing with type

00:12:40,329 --> 00:12:45,480
constraints they're not compulsory they

00:12:42,880 --> 00:12:51,300
don't take effect until they're ready

00:12:45,480 --> 00:12:55,510
this anything are can cast to anything

00:12:51,300 --> 00:12:57,490
basically you can take you can take a

00:12:55,510 --> 00:12:59,620
variable that is any this is clearly a

00:12:57,490 --> 00:13:01,420
string but it will coerce to a number in

00:12:59,620 --> 00:13:03,550
JavaScript you can make an assertion

00:13:01,420 --> 00:13:06,570
that that is a number so for example if

00:13:03,550 --> 00:13:10,680
you're taking numeric input from a

00:13:06,570 --> 00:13:12,570
field in your in your HTML thing like

00:13:10,680 --> 00:13:15,570
that will come back as a string from the

00:13:12,570 --> 00:13:17,190
the from the API you can say this is

00:13:15,570 --> 00:13:19,740
actually a number and I can start using

00:13:17,190 --> 00:13:22,410
it in exactly the same way that that you

00:13:19,740 --> 00:13:25,410
would a number so this is actually

00:13:22,410 --> 00:13:27,420
breaking type constraints which you can

00:13:25,410 --> 00:13:30,120
do if your confidence that you can break

00:13:27,420 --> 00:13:32,540
them this means that typescript can take

00:13:30,120 --> 00:13:34,860
the flavor of Java scripts weak typing

00:13:32,540 --> 00:13:39,750
wherever it is actually wherever you

00:13:34,860 --> 00:13:41,190
actually need it so this means that it's

00:13:39,750 --> 00:13:43,020
actually the most powerful and

00:13:41,190 --> 00:13:46,860
liberating aspect of this typing system

00:13:43,020 --> 00:13:50,490
let's take a look at why so I have a

00:13:46,860 --> 00:13:54,570
definition of some interface let's call

00:13:50,490 --> 00:13:56,850
it jquery now no reason at all I assure

00:13:54,570 --> 00:13:59,520
you absolutely no reason and say I have

00:13:56,850 --> 00:14:04,340
a library called that was written in

00:13:59,520 --> 00:14:07,530
playing on JavaScript called jQuery I

00:14:04,340 --> 00:14:10,230
can make a variable called dollars which

00:14:07,530 --> 00:14:12,150
is an instance of this this jquery thing

00:14:10,230 --> 00:14:14,490
from plain old JavaScript and I can make

00:14:12,150 --> 00:14:19,410
an assertion that is one of these jQuery

00:14:14,490 --> 00:14:21,480
things are that I defined myself from

00:14:19,410 --> 00:14:24,120
here on in every single call into that

00:14:21,480 --> 00:14:25,740
dollar variable will be validated

00:14:24,120 --> 00:14:29,010
against the interface that I asserted

00:14:25,740 --> 00:14:31,440
that it matched jquery's authors didn't

00:14:29,010 --> 00:14:33,840
need to define the spec for this we've

00:14:31,440 --> 00:14:35,550
defined this spec and the type system is

00:14:33,840 --> 00:14:37,800
fully happy because we've made this

00:14:35,550 --> 00:14:39,900
assertion it doesn't actually need to

00:14:37,800 --> 00:14:41,820
match it doesn't actually need to have

00:14:39,900 --> 00:14:44,520
the the type of the object under the

00:14:41,820 --> 00:14:47,460
hood it's just analyzed by the by the

00:14:44,520 --> 00:14:49,230
type checker the onus becomes on us to

00:14:47,460 --> 00:14:52,560
make sure the interface we've written is

00:14:49,230 --> 00:14:54,300
correct and doesn't get in our way so

00:14:52,560 --> 00:14:56,250
taking advantage of such an interface is

00:14:54,300 --> 00:14:58,950
actually pretty easy you point out a

00:14:56,250 --> 00:15:00,780
reference using a specialized comment at

00:14:58,950 --> 00:15:02,760
the top of your file this is very

00:15:00,780 --> 00:15:05,460
similar to doing an import in Python

00:15:02,760 --> 00:15:09,480
it's very similar to doing include in C

00:15:05,460 --> 00:15:11,310
or C++ and then there are entire

00:15:09,480 --> 00:15:13,770
communities out there that are making

00:15:11,310 --> 00:15:16,770
repositories of typescript interfaces

00:15:13,770 --> 00:15:19,240
for popular j/s libraries this one

00:15:16,770 --> 00:15:21,070
definitely typed is the biggest

00:15:19,240 --> 00:15:23,320
it has several hundred interfaces

00:15:21,070 --> 00:15:27,580
especially for things like jQuery are

00:15:23,320 --> 00:15:30,220
for nodejs and what this means is that

00:15:27,580 --> 00:15:33,070
because you can provide these interfaces

00:15:30,220 --> 00:15:35,260
any code that somebody else has written

00:15:33,070 --> 00:15:37,930
in vanilla JavaScript can take advantage

00:15:35,260 --> 00:15:39,130
of the type system in typescript you

00:15:37,930 --> 00:15:41,800
just need somewhere you should go and

00:15:39,130 --> 00:15:43,420
write the Declaration and what this

00:15:41,800 --> 00:15:45,730
means is that you can go and use

00:15:43,420 --> 00:15:48,220
typescript for non-trivial JavaScript

00:15:45,730 --> 00:15:53,170
code right now and I encourage you to do

00:15:48,220 --> 00:15:54,910
so so back to Python given that we are

00:15:53,170 --> 00:15:56,529
at a Python conference I should spend

00:15:54,910 --> 00:16:02,620
the majority of my time speaking about

00:15:56,529 --> 00:16:05,170
Python Pep 484 is now implemented as of

00:16:02,620 --> 00:16:07,270
a couple of months ago it proposes using

00:16:05,170 --> 00:16:09,910
these function annotations as a way to

00:16:07,270 --> 00:16:11,830
express type hints and all the type

00:16:09,910 --> 00:16:14,290
hinting features are implemented within

00:16:11,830 --> 00:16:17,200
the existing language the only concrete

00:16:14,290 --> 00:16:19,870
addition being a file that defines these

00:16:17,200 --> 00:16:22,000
type of some primitive type hints and a

00:16:19,870 --> 00:16:24,250
type checker this is different to

00:16:22,000 --> 00:16:25,480
typescript which is a language extension

00:16:24,250 --> 00:16:27,550
you need to run it through a compiler

00:16:25,480 --> 00:16:30,339
before you get code with the types

00:16:27,550 --> 00:16:32,709
erased because the language features are

00:16:30,339 --> 00:16:34,600
already in Python and don't have a

00:16:32,709 --> 00:16:38,230
defined runtime purpose they just get

00:16:34,600 --> 00:16:40,779
thrown away and it actually implements

00:16:38,230 --> 00:16:43,890
gradual typing in pretty much exactly

00:16:40,779 --> 00:16:47,709
the same way the typescript does and

00:16:43,890 --> 00:16:50,770
it's completely non-invasive existing

00:16:47,709 --> 00:16:52,209
Python 3 code will run as Python 3.5

00:16:50,770 --> 00:16:54,130
code even though type checking is

00:16:52,209 --> 00:16:56,140
available if you have been using

00:16:54,130 --> 00:16:58,839
annotations for something other than

00:16:56,140 --> 00:17:03,520
type checking beforehand it will still

00:16:58,839 --> 00:17:06,189
work and code that if you aren't using

00:17:03,520 --> 00:17:08,380
annotations code will start to benefit

00:17:06,189 --> 00:17:12,610
from type annotations as interface and

00:17:08,380 --> 00:17:15,100
start getting provided now if you think

00:17:12,610 --> 00:17:17,530
that the syntax for type annotations is

00:17:15,100 --> 00:17:19,000
ugly unfortunately that's not going to

00:17:17,530 --> 00:17:20,949
be a fixable thing because it's been in

00:17:19,000 --> 00:17:22,420
Python for six years now but if you

00:17:20,949 --> 00:17:24,730
don't want to pollute the main body of

00:17:22,420 --> 00:17:28,510
your code with type hints you don't have

00:17:24,730 --> 00:17:32,940
to you can write a dot pyi file that

00:17:28,510 --> 00:17:35,740
mimics the structure of your dot py file

00:17:32,940 --> 00:17:37,570
this means that your code will be able

00:17:35,740 --> 00:17:39,400
to work in Python too if you're aiming

00:17:37,570 --> 00:17:41,380
on maintaining compatibility between

00:17:39,400 --> 00:17:45,190
Python 2 and Python 3 in the same code

00:17:41,380 --> 00:17:46,840
base it also mimics sort of having a

00:17:45,190 --> 00:17:48,940
unit test structure you have a separate

00:17:46,840 --> 00:17:50,770
file which defines a whole bunch of of

00:17:48,940 --> 00:17:54,580
assertions on your code that is separate

00:17:50,770 --> 00:17:56,380
to the code itself so it's not a huge

00:17:54,580 --> 00:17:58,990
impost over like what you are already

00:17:56,380 --> 00:18:01,630
doing with unit tests the approach is

00:17:58,990 --> 00:18:07,200
basically the same as these PSD files

00:18:01,630 --> 00:18:07,200
from typescript or c headers C++ headers

00:18:07,830 --> 00:18:13,860
now once you run your code in Python

00:18:11,470 --> 00:18:16,690
these tight pants are completely ignored

00:18:13,860 --> 00:18:18,100
so it's effectively type eurasia even

00:18:16,690 --> 00:18:21,040
though you still have all this data

00:18:18,100 --> 00:18:22,450
available at runtime there's no effect

00:18:21,040 --> 00:18:24,040
on how your code would actually run

00:18:22,450 --> 00:18:27,700
because doing runtime type checking

00:18:24,040 --> 00:18:28,840
would be a huge performance problem it's

00:18:27,700 --> 00:18:31,390
not something you would want to do in

00:18:28,840 --> 00:18:33,040
prod that's said actually instrumenting

00:18:31,390 --> 00:18:35,770
your code to validate type constraints

00:18:33,040 --> 00:18:38,680
at runtime can be a useful thing in

00:18:35,770 --> 00:18:40,660
development especially under tests it

00:18:38,680 --> 00:18:43,270
can find bugs you might not have known

00:18:40,660 --> 00:18:45,430
you otherwise had and so I would not be

00:18:43,270 --> 00:18:47,800
surprised if a runtime type checker did

00:18:45,430 --> 00:18:49,330
eventually show up in Python but it will

00:18:47,800 --> 00:18:54,310
never be compulsory because that would

00:18:49,330 --> 00:18:56,620
be stupid so why do you as a as a Python

00:18:54,310 --> 00:19:00,220
developer care about tight pants you've

00:18:56,620 --> 00:19:02,200
been writing Python it's the languages

00:19:00,220 --> 00:19:03,730
existed for 24 years now without type

00:19:02,200 --> 00:19:07,150
hence why would you actually care about

00:19:03,730 --> 00:19:09,580
it and using them now well firstly who

00:19:07,150 --> 00:19:12,370
here writes unit tests in there there

00:19:09,580 --> 00:19:13,540
python code you can also braised your

00:19:12,370 --> 00:19:14,830
hand if you'd like to pretend that

00:19:13,540 --> 00:19:16,720
you're right unit test because really

00:19:14,830 --> 00:19:19,750
you should be great everyone in the room

00:19:16,720 --> 00:19:22,080
rates unit tests fantastic okay who here

00:19:19,750 --> 00:19:24,280
writes unit tests that completely

00:19:22,080 --> 00:19:26,110
comprehensively checks that their

00:19:24,280 --> 00:19:30,550
functions behave correctly when passing

00:19:26,110 --> 00:19:34,120
invalid types into their functions 344

00:19:30,550 --> 00:19:35,410
people your coat your test coverage is

00:19:34,120 --> 00:19:38,010
insufficient because you are not

00:19:35,410 --> 00:19:41,620
checking that your code will run out

00:19:38,010 --> 00:19:43,300
wouldn't Python tie painting will give

00:19:41,620 --> 00:19:46,110
you comprehensive tests for this

00:19:43,300 --> 00:19:47,790
effectively for free by writing ace

00:19:46,110 --> 00:19:50,190
single thing for every single parameter

00:19:47,790 --> 00:19:54,600
in your functions you will get better

00:19:50,190 --> 00:19:59,160
test coverage for fewer tests if you use

00:19:54,600 --> 00:20:01,440
pilot for example you can run your code

00:19:59,160 --> 00:20:02,910
again well you already have a linking

00:20:01,440 --> 00:20:05,309
phase you can run your code against the

00:20:02,910 --> 00:20:07,320
type checker and get type checking

00:20:05,309 --> 00:20:09,330
against all of the libraries that you

00:20:07,320 --> 00:20:11,190
run your code against to make sure you

00:20:09,330 --> 00:20:15,840
are running your stuff against other

00:20:11,190 --> 00:20:18,120
people's ap is correctly if you document

00:20:15,840 --> 00:20:21,330
your return types your argument types in

00:20:18,120 --> 00:20:22,860
docstrings those aren't verifiable but

00:20:21,330 --> 00:20:25,679
using tight pants will be able to

00:20:22,860 --> 00:20:28,440
generate accurate documentation that you

00:20:25,679 --> 00:20:31,230
can test it's like doc tests for types

00:20:28,440 --> 00:20:33,360
but it's formal if your documentation is

00:20:31,230 --> 00:20:36,540
wrong your type checking tests will

00:20:33,360 --> 00:20:40,169
completely fail and perhaps most

00:20:36,540 --> 00:20:43,679
importantly gido setting in his keynote

00:20:40,169 --> 00:20:47,340
that if you're using an IDE only fifty

00:20:43,679 --> 00:20:50,210
to sixty percent of statements in Python

00:20:47,340 --> 00:20:53,850
can have their types correctly inferred

00:20:50,210 --> 00:20:56,250
that's terrible it means that forty to

00:20:53,850 --> 00:20:59,940
fifty percent of things will give you an

00:20:56,250 --> 00:21:02,850
incorrect Type O and incorrect return

00:20:59,940 --> 00:21:05,160
type response so I de use in Python is

00:21:02,850 --> 00:21:07,140
terrible but tight pants will get that

00:21:05,160 --> 00:21:11,460
up to like seventy or eighty percent of

00:21:07,140 --> 00:21:13,400
correctly inferable correctly inferable

00:21:11,460 --> 00:21:15,929
return types that would be a huge

00:21:13,400 --> 00:21:17,850
improvement for people learning Python

00:21:15,929 --> 00:21:19,530
or people who are coming from like Java

00:21:17,850 --> 00:21:24,809
and expecting their IDs to work

00:21:19,530 --> 00:21:28,350
correctly um so I finish this talk with

00:21:24,809 --> 00:21:30,150
a quick discussion of duck typing being

00:21:28,350 --> 00:21:32,010
able to rely on individual parts of an

00:21:30,150 --> 00:21:33,960
interface rather than expecting an

00:21:32,010 --> 00:21:35,940
interface is completely match it's a

00:21:33,960 --> 00:21:39,559
huge part of why python is so easy to

00:21:35,940 --> 00:21:42,990
use it means you can write code that

00:21:39,559 --> 00:21:45,720
feels completely natural to use but is

00:21:42,990 --> 00:21:48,960
very very difficult to specify formally

00:21:45,720 --> 00:21:51,049
using a type system I assume that most

00:21:48,960 --> 00:21:54,929
of you have used requests before

00:21:51,049 --> 00:21:57,960
requests relies heavily on duck typing

00:21:54,929 --> 00:22:00,659
to provide flexibility in its interface

00:21:57,960 --> 00:22:03,149
and the core developers of requests are

00:22:00,659 --> 00:22:05,779
of the view that they'll never be able

00:22:03,149 --> 00:22:07,860
to provide good type hints for um

00:22:05,779 --> 00:22:10,429
they'll never be able to provide good

00:22:07,860 --> 00:22:13,649
tight pants for requests that make sense

00:22:10,429 --> 00:22:16,649
so the files parameter in requests lets

00:22:13,649 --> 00:22:19,529
you specify file names or content blobs

00:22:16,649 --> 00:22:22,169
or actual file like handles to be

00:22:19,529 --> 00:22:25,440
uploaded when you submit a request as

00:22:22,169 --> 00:22:27,630
well as HTTP headers it may let you

00:22:25,440 --> 00:22:30,000
provide a single item it may let you

00:22:27,630 --> 00:22:31,770
provide a sequence of named items it may

00:22:30,000 --> 00:22:35,520
let you provide those items as addiction

00:22:31,770 --> 00:22:37,830
with filenames and handles in them it

00:22:35,520 --> 00:22:40,950
gives you all of the options so you can

00:22:37,830 --> 00:22:43,860
construct data to upload and fit your

00:22:40,950 --> 00:22:46,950
own use case as you please this here is

00:22:43,860 --> 00:22:50,610
the shortest possible annotation using

00:22:46,950 --> 00:22:54,240
pet 484 syntax to provide the files

00:22:50,610 --> 00:22:56,220
parameter in requests you would never

00:22:54,240 --> 00:22:57,929
get something that behaves like the

00:22:56,220 --> 00:23:00,120
files parameter in requests in something

00:22:57,929 --> 00:23:03,720
like Java where tie painting is

00:23:00,120 --> 00:23:05,970
compulsory this this thing here it gives

00:23:03,720 --> 00:23:07,860
absolutely no clarity you could write a

00:23:05,970 --> 00:23:11,610
bit of prose put it in the documentation

00:23:07,860 --> 00:23:13,230
and say this is how this works and

00:23:11,610 --> 00:23:16,559
people would understand it better than

00:23:13,230 --> 00:23:18,240
reading that so how do you deal with

00:23:16,559 --> 00:23:20,490
type assertions like this how do you

00:23:18,240 --> 00:23:23,760
power the developers of requests provide

00:23:20,490 --> 00:23:26,669
type assertions like that well you just

00:23:23,760 --> 00:23:29,130
don't the type system is not compulsory

00:23:26,669 --> 00:23:30,809
and requests doesn't need to be fully

00:23:29,130 --> 00:23:33,750
type hinted in order for you to take

00:23:30,809 --> 00:23:35,940
advantage of requests the documentation

00:23:33,750 --> 00:23:38,100
of it is fantastic it tells you how to

00:23:35,940 --> 00:23:40,020
use the files parameter and the behavior

00:23:38,100 --> 00:23:41,970
of requests is opaque enough in this

00:23:40,020 --> 00:23:44,279
case that the type hints would never

00:23:41,970 --> 00:23:46,289
actually be useful saying that files

00:23:44,279 --> 00:23:48,600
will take an any and then actually

00:23:46,289 --> 00:23:53,610
describing what it expects would make

00:23:48,600 --> 00:23:55,860
far more sense so whilst requests itself

00:23:53,610 --> 00:23:58,799
makes no guarantees about what comes out

00:23:55,860 --> 00:24:00,720
of requests we know that the behavior we

00:23:58,799 --> 00:24:03,090
know the behavior what will be calling

00:24:00,720 --> 00:24:06,059
gradual typing means we can make those

00:24:03,090 --> 00:24:08,100
type assertions about libraries with

00:24:06,059 --> 00:24:10,919
weaker type guarantees and make stronger

00:24:08,100 --> 00:24:11,160
guarantees ourselves so for example in

00:24:10,919 --> 00:24:13,650
this

00:24:11,160 --> 00:24:16,410
one we have response on we note returns

00:24:13,650 --> 00:24:17,970
a JSON object but we know that the API

00:24:16,410 --> 00:24:20,640
that we're calling is going to return a

00:24:17,970 --> 00:24:22,530
dictionary so we can say this returns a

00:24:20,640 --> 00:24:25,110
dictionary and that's a safe and

00:24:22,530 --> 00:24:27,420
sensible thing to say we know that these

00:24:25,110 --> 00:24:29,400
type of Sir shins apply and then we can

00:24:27,420 --> 00:24:33,150
provide constraints to the rest of our

00:24:29,400 --> 00:24:35,460
code by wrapping the call to requests

00:24:33,150 --> 00:24:39,330
which is weakly typed into our own

00:24:35,460 --> 00:24:41,480
assertions so type hints are made about

00:24:39,330 --> 00:24:44,280
making things super specific and

00:24:41,480 --> 00:24:46,920
verifiable like Java like Haskell that's

00:24:44,280 --> 00:24:48,660
not how Python works and doing that will

00:24:46,920 --> 00:24:51,600
make coding completely different to

00:24:48,660 --> 00:24:53,070
python but you can use tight pants to

00:24:51,600 --> 00:24:55,530
improve your code improve the

00:24:53,070 --> 00:24:58,650
verifiability of your code where it

00:24:55,530 --> 00:25:01,200
makes sense it's opt-in and you can opt

00:24:58,650 --> 00:25:04,590
into it gradually add them where they

00:25:01,200 --> 00:25:07,110
make sense it's not the end of the world

00:25:04,590 --> 00:25:10,620
you don't have to do it if you don't

00:25:07,110 --> 00:25:12,690
want to and there are benefits so to get

00:25:10,620 --> 00:25:15,210
an idea of how this works in code that

00:25:12,690 --> 00:25:17,580
you might be used to writing yourself a

00:25:15,210 --> 00:25:20,520
tryout type script language it's great

00:25:17,580 --> 00:25:26,310
and that is the end I think we have like

00:25:20,520 --> 00:25:31,020
five minutes for questions like to come

00:25:26,310 --> 00:25:33,000
up here on to the microphone somebody

00:25:31,020 --> 00:25:38,490
get in the queue before Russell hurry

00:25:33,000 --> 00:25:41,670
hurry hurry can we have someone other

00:25:38,490 --> 00:25:43,980
than um just looking at the requests

00:25:41,670 --> 00:25:46,590
example you've given uh yeah you can

00:25:43,980 --> 00:25:50,070
formally specified it can be done yes

00:25:46,590 --> 00:25:53,300
couldn't you just call that incredibly

00:25:50,070 --> 00:25:55,920
ungainly and unhelpful definition a

00:25:53,300 --> 00:25:57,720
content like object or whatever handle

00:25:55,920 --> 00:25:59,040
is useful for it and then doc you just

00:25:57,720 --> 00:26:00,330
throw that all the way through your code

00:25:59,040 --> 00:26:01,890
and because that's effectively what

00:26:00,330 --> 00:26:03,810
you're documenting is that it's not any

00:26:01,890 --> 00:26:05,130
object it's an object that has one of a

00:26:03,810 --> 00:26:06,690
very small number of specified

00:26:05,130 --> 00:26:08,820
properties well that one has a

00:26:06,690 --> 00:26:10,530
surprisingly large number of specified

00:26:08,820 --> 00:26:13,530
properly actual and making sure that

00:26:10,530 --> 00:26:15,750
it's comprehensive and up-to-date as

00:26:13,530 --> 00:26:17,880
they change the behavior whilst not

00:26:15,750 --> 00:26:19,680
breaking every other use case for it

00:26:17,880 --> 00:26:21,360
would be quite difficult but wouldn't

00:26:19,680 --> 00:26:23,070
that kind of be the point though is that

00:26:21,360 --> 00:26:23,500
they go say okay well we want content

00:26:23,070 --> 00:26:25,390
like

00:26:23,500 --> 00:26:27,610
x2 now be able to handle each writable

00:26:25,390 --> 00:26:29,650
if reports of open files and then all of

00:26:27,610 --> 00:26:32,590
their code will fail linting where it

00:26:29,650 --> 00:26:35,770
doesn't match that they could do it if

00:26:32,590 --> 00:26:37,390
they want to do it short that appears to

00:26:35,770 --> 00:26:39,220
be not a priority in for them or then

00:26:37,390 --> 00:26:42,850
your Kali it's there but it's also a

00:26:39,220 --> 00:26:44,950
massively complicated complicated thing

00:26:42,850 --> 00:26:47,710
and it's likely to be full of bugs they

00:26:44,950 --> 00:26:50,530
might you know they like duck typing and

00:26:47,710 --> 00:26:53,010
you can wrap assertions as you need to

00:26:50,530 --> 00:26:56,190
yourself so why not do that sure okay

00:26:53,010 --> 00:26:58,510
you don't is that you don't have to

00:26:56,190 --> 00:27:02,380
adopt the approach that they have

00:26:58,510 --> 00:27:04,360
adopted but if you want to add type

00:27:02,380 --> 00:27:06,310
hints you can you can provide your own

00:27:04,360 --> 00:27:11,110
assertions they don't need to that's the

00:27:06,310 --> 00:27:13,660
point thank you for your talk I just

00:27:11,110 --> 00:27:16,540
like to comment and a question I guess

00:27:13,660 --> 00:27:19,090
about providing an API for others to

00:27:16,540 --> 00:27:21,850
consume and putting tie pins in your API

00:27:19,090 --> 00:27:23,470
right um I would consider that to be a

00:27:21,850 --> 00:27:25,120
little bit harmful because you don't

00:27:23,470 --> 00:27:27,250
know what is going to be passed into

00:27:25,120 --> 00:27:29,230
your API and duck typing in this

00:27:27,250 --> 00:27:31,960
instance seems to be quite useful I

00:27:29,230 --> 00:27:34,630
understand that pi linting is you know

00:27:31,960 --> 00:27:36,370
linting in general is going to help you

00:27:34,630 --> 00:27:39,280
reduce any errors but if it just

00:27:36,370 --> 00:27:41,110
introduces noise isn't that harmful to

00:27:39,280 --> 00:27:43,360
the lending process okay so my

00:27:41,110 --> 00:27:45,340
understanding of how the type checker is

00:27:43,360 --> 00:27:47,860
going to work is that if your code

00:27:45,340 --> 00:27:50,620
matches an interface that is expected so

00:27:47,860 --> 00:27:53,080
you can define a an interface for your

00:27:50,620 --> 00:27:54,850
library and then type check against that

00:27:53,080 --> 00:27:56,500
and if the interface is matched it will

00:27:54,850 --> 00:28:05,950
go through the type checker does that

00:27:56,500 --> 00:28:07,900
sound about right it has holes okay can

00:28:05,950 --> 00:28:11,520
we get this on black so the comment from

00:28:07,900 --> 00:28:11,520
Robert is that it has lots of holes

00:28:14,390 --> 00:28:18,290
right so I spent some time looking at

00:28:16,670 --> 00:28:21,920
this just when it came up and i'm very

00:28:18,290 --> 00:28:23,510
pro i want to be able to use it the

00:28:21,920 --> 00:28:25,550
problem is that this is kind of the

00:28:23,510 --> 00:28:27,860
first generation of a full python and

00:28:25,550 --> 00:28:29,510
we're double said hey look we can't

00:28:27,860 --> 00:28:30,950
build things like representing duck

00:28:29,510 --> 00:28:33,650
typing in this until this is at she

00:28:30,950 --> 00:28:35,570
settled down them come naturally so yeah

00:28:33,650 --> 00:28:36,620
so the easiest example i can think of

00:28:35,570 --> 00:28:38,810
and then we were is going to fall down

00:28:36,620 --> 00:28:40,640
for I've got an API and I expect to be

00:28:38,810 --> 00:28:42,350
really permissive about what people can

00:28:40,640 --> 00:28:44,030
call me is that if you want to take a

00:28:42,350 --> 00:28:45,800
string its definition of string is a

00:28:44,030 --> 00:28:47,930
singular one there is only one string

00:28:45,800 --> 00:28:48,980
type but in Python I can pass and a

00:28:47,930 --> 00:28:50,510
whole bunch of things that look like

00:28:48,980 --> 00:28:55,400
strings talk about soon as quite close

00:28:50,510 --> 00:28:58,670
ranks don't okay um the observation I

00:28:55,400 --> 00:29:00,740
would I would make here is that go does

00:28:58,670 --> 00:29:02,930
the go the language does this very very

00:29:00,740 --> 00:29:05,450
well in that you can specify interfaces

00:29:02,930 --> 00:29:09,290
that contain the things that you will

00:29:05,450 --> 00:29:11,300
eventually start calling and if your if

00:29:09,290 --> 00:29:13,190
your object contains that interface it

00:29:11,300 --> 00:29:14,810
will start to accept it that would

00:29:13,190 --> 00:29:19,940
probably make a lot of sense in a form

00:29:14,810 --> 00:29:21,770
of in a formal type checker in in the

00:29:19,940 --> 00:29:24,410
way that python is starting to do it

00:29:21,770 --> 00:29:25,940
because it formalizes duck typing I

00:29:24,410 --> 00:29:27,470
don't think it does it yet but that

00:29:25,940 --> 00:29:31,180
would be a noble goal and would probably

00:29:27,470 --> 00:29:33,800
fix the use cases that you're suggesting

00:29:31,180 --> 00:29:36,020
actually formalizing the interface as it

00:29:33,800 --> 00:29:37,370
is going to be used but that is not what

00:29:36,020 --> 00:29:38,930
it does at the moment but I think it

00:29:37,370 --> 00:29:42,470
would eventually get there because that

00:29:38,930 --> 00:29:45,160
would make the most sense looks like we

00:29:42,470 --> 00:29:45,160
have a Nick Coughlin

00:29:45,540 --> 00:29:52,240
and we'll have to make this like the

00:29:47,890 --> 00:29:53,560
last question I'm just doing this as a

00:29:52,240 --> 00:29:55,180
quick follow-up this is one of the

00:29:53,560 --> 00:29:58,600
reasons why it's still why it's an

00:29:55,180 --> 00:30:01,330
external linter because if you have code

00:29:58,600 --> 00:30:06,100
that doesn't currently type check then

00:30:01,330 --> 00:30:07,930
you can just not run my pie and and it

00:30:06,100 --> 00:30:11,610
and it will keep running fine but but

00:30:07,930 --> 00:30:15,250
it's a opt-in system for a reason cool

00:30:11,610 --> 00:30:17,440
Andrew this is super super exciting

00:30:15,250 --> 00:30:18,730
especially for the science community do

00:30:17,440 --> 00:30:21,310
you want to hazard a guess about how

00:30:18,730 --> 00:30:22,960
this might look for numpy will we be

00:30:21,310 --> 00:30:27,090
able to specify dimensionality

00:30:22,960 --> 00:30:27,090
constraints as well as type constraints

00:30:30,780 --> 00:30:39,370
somebody is asking me to do maths in my

00:30:33,280 --> 00:30:41,500
head on stage and I am NOT certain you'd

00:30:39,370 --> 00:30:44,650
probably need to ask somebody like like

00:30:41,500 --> 00:30:46,660
travis olefins or somebody like that if

00:30:44,650 --> 00:30:48,040
they've actually looked at it and I

00:30:46,660 --> 00:30:49,630
really think we've we've only got five

00:30:48,040 --> 00:30:51,640
minutes till the next talk so if you

00:30:49,630 --> 00:30:54,010
want to ask me about this I can offer

00:30:51,640 --> 00:30:55,600
many opinions about this stuff but only

00:30:54,010 --> 00:30:56,620
in the hallway track I thank you all for

00:30:55,600 --> 00:30:58,720
coming along I hope you learned

00:30:56,620 --> 00:31:03,010
something we haven't quite finished for

00:30:58,720 --> 00:31:05,980
them you've got to have a mug this this

00:31:03,010 --> 00:31:08,260
little mug was dug up underneath a

00:31:05,980 --> 00:31:14,080
convict settlement just outside Darwin

00:31:08,260 --> 00:31:15,730
outside Hobart from the dirts that

00:31:14,080 --> 00:31:18,900
convict settlement was probably my

00:31:15,730 --> 00:31:18,900
laptop at some point

00:31:27,380 --> 00:31:29,440

YouTube URL: https://www.youtube.com/watch?v=_PPQLeimyOM


