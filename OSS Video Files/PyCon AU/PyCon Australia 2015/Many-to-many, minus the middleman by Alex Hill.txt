Title: Many-to-many, minus the middleman by Alex Hill
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	This talk is about an alternative Django ManyToManyField implementation that uses (abuses?) PostgreSQL's full-text search engine instead of an intermediary table to store its relationships. As well as showing off some handy things you can do with this field, we'll talk along the way about full-text search in Postgres, inverted indexes, and how Django's ManyToManyField is implemented.

Behind the scenes, ManyToManyField uses an intermediary table to record its relationships – a classic relational database technique you most likely mastered in Databases 101. But to believe some present-day commentators, classic relational databases with their fixed schemas and their ACID habit belong back in the 70s where they came from.

Enter Postgres, the hip, switched-on parent who works as a public defender and gets on uncomfortably well with your friends. Postgres builds on a wealth of relational history while embracing modern non-relational ideas in a thoughtful, sane way.

In this talk, we'll press full-text search, one of Postgres' repertoire of many useful features, into a service it performs remarkably well despite being designed for quite a different purpose. Code and benchmarks provided!

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:09,559 --> 00:00:13,500
so a bit of a change in program for

00:00:11,790 --> 00:00:15,629
those who weren't here earlier we have

00:00:13,500 --> 00:00:16,830
Alex Hill talking on jango for us this

00:00:15,629 --> 00:00:20,070
was originally going to be a lightning

00:00:16,830 --> 00:00:22,110
talk but he has happily stepped in for

00:00:20,070 --> 00:00:29,790
some issues with the the the other

00:00:22,110 --> 00:00:32,220
speaker so give it up for Alex thanks

00:00:29,790 --> 00:00:33,570
everyone this was going to be a

00:00:32,220 --> 00:00:35,610
lightning talk today but it was actually

00:00:33,570 --> 00:00:37,200
supposed to be a talk at django con and

00:00:35,610 --> 00:00:38,910
friday was anyone at django con on

00:00:37,200 --> 00:00:41,670
friday yeah so you would have noticed

00:00:38,910 --> 00:00:44,060
this in their program it didn't happen

00:00:41,670 --> 00:00:46,830
for reasons which are kind of related to

00:00:44,060 --> 00:00:49,230
what Russ talked about in his lightning

00:00:46,830 --> 00:00:53,640
talk yesterday so I just want to say

00:00:49,230 --> 00:00:55,470
thanks Ross few understanding and yeah

00:00:53,640 --> 00:00:59,160
and for everything he said yesterday was

00:00:55,470 --> 00:01:01,440
really great so my talk is called

00:00:59,160 --> 00:01:03,750
many-to-many minus the middleman it's

00:01:01,440 --> 00:01:08,729
about Django many many fields basically

00:01:03,750 --> 00:01:10,590
the goal is to implement a custom many

00:01:08,729 --> 00:01:12,240
familiar field that mimics the behavior

00:01:10,590 --> 00:01:17,450
of Jango's default many-to-many field

00:01:12,240 --> 00:01:21,659
but just without that intermediate table

00:01:17,450 --> 00:01:23,550
so we'll come to the how in a second but

00:01:21,659 --> 00:01:27,930
first just to give you some context I

00:01:23,550 --> 00:01:29,790
work at a bookshop in Perth we're called

00:01:27,930 --> 00:01:31,650
like a technical and specialist bookshop

00:01:29,790 --> 00:01:35,670
which means that we just have a lot of

00:01:31,650 --> 00:01:37,020
like quite yeah quite fine grain

00:01:35,670 --> 00:01:37,979
categorizations because like there's

00:01:37,020 --> 00:01:40,049
people who are into really esoteric

00:01:37,979 --> 00:01:42,690
things so this is big list of all of our

00:01:40,049 --> 00:01:45,310
categories and you can see Django in

00:01:42,690 --> 00:01:50,420
there somewhere

00:01:45,310 --> 00:01:52,130
maybe yeah so obviously we want to have

00:01:50,420 --> 00:01:56,300
a hierarchy of things for people to

00:01:52,130 --> 00:01:57,620
navigate on the website but we want

00:01:56,300 --> 00:01:59,150
though some of those subjects to appear

00:01:57,620 --> 00:02:01,460
in multiple places within the hierarchy

00:01:59,150 --> 00:02:03,590
and books can be in multiple subjects so

00:02:01,460 --> 00:02:05,000
you already have like this quite complex

00:02:03,590 --> 00:02:07,270
thing for example if you want an

00:02:05,000 --> 00:02:09,770
Australian biography you can go through

00:02:07,270 --> 00:02:11,390
australiana two biographies like go

00:02:09,770 --> 00:02:14,660
through biography of Australia Anna we

00:02:11,390 --> 00:02:16,520
want all of those books to show up and

00:02:14,660 --> 00:02:19,010
we want that list to just be maintained

00:02:16,520 --> 00:02:23,480
in one place we don't have to maintain

00:02:19,010 --> 00:02:25,280
two separate things so in Django this is

00:02:23,480 --> 00:02:30,230
what it looks like we have a node which

00:02:25,280 --> 00:02:32,540
is a so a node is like a yeah node in

00:02:30,230 --> 00:02:34,760
the navigation tree has a slug and its

00:02:32,540 --> 00:02:36,320
associated with the subject books are

00:02:34,760 --> 00:02:39,740
associated with potentially many

00:02:36,320 --> 00:02:44,450
subjects and the subject is just subject

00:02:39,740 --> 00:02:46,220
yet so that's okay you know if we want

00:02:44,450 --> 00:02:47,690
to get all the books at a current node

00:02:46,220 --> 00:02:51,680
for someone who's browsing the web site

00:02:47,690 --> 00:02:53,239
that's easy to do either of these two

00:02:51,680 --> 00:02:57,050
ways that'll work but what we actually

00:02:53,239 --> 00:02:58,580
want to do is get like a subtree of that

00:02:57,050 --> 00:03:00,350
so we want to give someone's here we

00:02:58,580 --> 00:03:03,020
want to get all of the books that are in

00:03:00,350 --> 00:03:04,690
that entire tree below that point so

00:03:03,020 --> 00:03:11,360
that means the query gets a bit more

00:03:04,690 --> 00:03:14,030
complicated so we can do this so we're

00:03:11,360 --> 00:03:16,280
going you know subjects to nodes with a

00:03:14,030 --> 00:03:18,170
slug that starts with that and it gets

00:03:16,280 --> 00:03:19,340
everything under that problem with that

00:03:18,170 --> 00:03:21,170
is because there's all these many to

00:03:19,340 --> 00:03:23,209
many relationships in there you get

00:03:21,170 --> 00:03:25,489
multiple results so you get books coming

00:03:23,209 --> 00:03:27,860
up twice so you need to do distinct and

00:03:25,489 --> 00:03:31,070
then that makes that query a lot slower

00:03:27,860 --> 00:03:33,380
as it turns out so then what you can do

00:03:31,070 --> 00:03:36,890
is do something like this where you're

00:03:33,380 --> 00:03:37,880
kind of doing a sub-query and all that

00:03:36,890 --> 00:03:40,940
it just kind of gets really complicated

00:03:37,880 --> 00:03:42,709
I actually really like SQL I like

00:03:40,940 --> 00:03:44,650
looking at it I like writing it and I

00:03:42,709 --> 00:03:48,780
don't like looking at big unwieldy

00:03:44,650 --> 00:03:53,010
queries generated by an RM

00:03:48,780 --> 00:03:58,500
so yeah lots of lots of indexes I mean

00:03:53,010 --> 00:04:01,709
it's more yeah it's modest like I like

00:03:58,500 --> 00:04:04,500
to know what I like an RM which will do

00:04:01,709 --> 00:04:06,630
exactly what I wanted to do basically I

00:04:04,500 --> 00:04:08,610
don't necessarily want my schema to

00:04:06,630 --> 00:04:11,250
conform to what the RM limits me too i

00:04:08,610 --> 00:04:12,810
want the RM to just like be a way that i

00:04:11,250 --> 00:04:13,860
can get at my data in the way that i

00:04:12,810 --> 00:04:16,470
want and that's kind of the whole

00:04:13,860 --> 00:04:18,510
motivation for this so what we thought

00:04:16,470 --> 00:04:21,690
it was a better way of doing this would

00:04:18,510 --> 00:04:24,510
be to have kind of broader subjects and

00:04:21,690 --> 00:04:26,400
each of those nodes be like an X like a

00:04:24,510 --> 00:04:30,450
boolean expression of those subjects so

00:04:26,400 --> 00:04:32,520
you have basically tags so you have like

00:04:30,450 --> 00:04:36,240
an Australian tag biography tag and both

00:04:32,520 --> 00:04:38,000
of these things just say things that in

00:04:36,240 --> 00:04:41,070
that intersection of those two tags and

00:04:38,000 --> 00:04:44,520
I wouldn't even I wouldn't want to try

00:04:41,070 --> 00:04:46,650
and do that with with the kind of

00:04:44,520 --> 00:04:49,080
standard relational model I'll use Jang

00:04:46,650 --> 00:04:50,760
postgres full-text search a lot and so

00:04:49,080 --> 00:04:52,440
that's immediately what I thought of

00:04:50,760 --> 00:04:57,419
because you can do all those kinds of

00:04:52,440 --> 00:05:00,390
bullying queries in full text search so

00:04:57,419 --> 00:05:01,950
these subject codes use form a kind of

00:05:00,390 --> 00:05:05,310
natural tags so we're tagging these

00:05:01,950 --> 00:05:08,450
books each of those nodes has a TS query

00:05:05,310 --> 00:05:14,370
stored against it and then we can just

00:05:08,450 --> 00:05:17,070
directly run that query the TS query

00:05:14,370 --> 00:05:18,660
supports like orange together queries so

00:05:17,070 --> 00:05:20,820
to get that sub tree that we talked

00:05:18,660 --> 00:05:23,370
about you just select all those books or

00:05:20,820 --> 00:05:25,680
them all into one query and then again

00:05:23,370 --> 00:05:29,100
that's just one one query with that

00:05:25,680 --> 00:05:35,340
postgres matching operator and that's

00:05:29,100 --> 00:05:37,830
yeah fast and indexable so it was anyone

00:05:35,340 --> 00:05:41,960
at races postgres talk earlier I don't

00:05:37,830 --> 00:05:46,530
need to go into this postgres is great

00:05:41,960 --> 00:05:48,660
ok so does any knows what an inverted

00:05:46,530 --> 00:05:51,390
index is

00:05:48,660 --> 00:05:53,730
who knows how it works okay everyone

00:05:51,390 --> 00:05:55,620
else you can raise your hand because an

00:05:53,730 --> 00:05:57,870
inverted index if you've used a cookbook

00:05:55,620 --> 00:06:01,350
or a text book ever that's what's in the

00:05:57,870 --> 00:06:04,280
back of that the point of an inverted

00:06:01,350 --> 00:06:06,710
index is to take a document which has

00:06:04,280 --> 00:06:11,490
like a document made up of multiple

00:06:06,710 --> 00:06:13,860
terms will say and instead of storing

00:06:11,490 --> 00:06:15,600
documents with all the terms you saw

00:06:13,860 --> 00:06:17,250
terms and then all of the documents that

00:06:15,600 --> 00:06:19,740
contain those terms so just like an

00:06:17,250 --> 00:06:23,730
index like this so that's kind of where

00:06:19,740 --> 00:06:25,410
the inversion comes from so in

00:06:23,730 --> 00:06:28,260
publishing it's called a concordance and

00:06:25,410 --> 00:06:30,150
this is a really old idea like scholars

00:06:28,260 --> 00:06:33,350
have been assembling these four

00:06:30,150 --> 00:06:36,330
important texts for hundreds of years

00:06:33,350 --> 00:06:39,870
the oldest recorded one is from 1230 I

00:06:36,330 --> 00:06:43,980
think it's not not that but so it's not

00:06:39,870 --> 00:06:46,620
a new idea at all so this is that same

00:06:43,980 --> 00:06:50,820
idea kind of expressed in Python syntax

00:06:46,620 --> 00:06:54,150
so you have these books with all of

00:06:50,820 --> 00:06:56,700
these tags and this is the the inverted

00:06:54,150 --> 00:06:58,950
kind of expression of that we have tags

00:06:56,700 --> 00:07:06,470
stored once and then with references to

00:06:58,950 --> 00:07:08,730
the books okay so the first kind of step

00:07:06,470 --> 00:07:12,720
towards what I'm going to do is just to

00:07:08,730 --> 00:07:18,600
implement these things with Django's new

00:07:12,720 --> 00:07:20,700
custom types and custom lookups so it's

00:07:18,600 --> 00:07:22,919
a bit more to it than that but basically

00:07:20,700 --> 00:07:25,740
that is all you have to do to make this

00:07:22,919 --> 00:07:27,450
work and if you've used postgres text

00:07:25,740 --> 00:07:30,000
search before you'll know about the two

00:07:27,450 --> 00:07:32,790
TS query into TS vector because we're

00:07:30,000 --> 00:07:34,470
basically just using bra strings of text

00:07:32,790 --> 00:07:35,850
we don't need to do any stemming on the

00:07:34,470 --> 00:07:37,590
more like eliminate stop words or

00:07:35,850 --> 00:07:39,419
anything we don't really need to use

00:07:37,590 --> 00:07:43,110
those we can just use the types directly

00:07:39,419 --> 00:07:45,000
which is really convenient and then to

00:07:43,110 --> 00:07:49,230
do a custom look up as in you know

00:07:45,000 --> 00:07:52,440
filter tags under under matches that is

00:07:49,230 --> 00:07:53,820
all you have to do so it's it's really

00:07:52,440 --> 00:07:57,990
cool what you can do with all this stuff

00:07:53,820 --> 00:07:59,129
now that's all new in the last well one

00:07:57,990 --> 00:08:01,199
or two versions

00:07:59,129 --> 00:08:03,719
and I think I don't I think it's kind of

00:08:01,199 --> 00:08:09,809
flown under the radar a bit and deserves

00:08:03,719 --> 00:08:11,459
a lot of kudos yeah so this is what it

00:08:09,809 --> 00:08:16,679
looks like you just have a tag field and

00:08:11,459 --> 00:08:18,779
a tag query and you just call that

00:08:16,679 --> 00:08:24,629
custom look up and there's the query you

00:08:18,779 --> 00:08:26,429
get so that gets us some of the way but

00:08:24,629 --> 00:08:28,469
what we really want to do I'll just skip

00:08:26,429 --> 00:08:31,229
over that slide what we really wanted to

00:08:28,469 --> 00:08:32,699
do is to imitate a menu too many fields

00:08:31,229 --> 00:08:35,189
so instead of having to type out that

00:08:32,699 --> 00:08:36,599
query what we want to do is have those

00:08:35,189 --> 00:08:40,019
you know those nodes and just say

00:08:36,599 --> 00:08:42,089
notebooks and have that you know

00:08:40,019 --> 00:08:46,709
automatically work as in a normal

00:08:42,089 --> 00:08:48,660
many-to-many field the advantage of that

00:08:46,709 --> 00:08:51,209
is that yeah you get like automatic

00:08:48,660 --> 00:08:53,579
accesses you can use them in filter

00:08:51,209 --> 00:08:57,079
chaining and all that kind of thing as

00:08:53,579 --> 00:08:59,339
opposed to yeah running this kind of

00:08:57,079 --> 00:09:00,839
query whenever you want or you know

00:08:59,339 --> 00:09:02,459
putting it as an attribute on the model

00:09:00,839 --> 00:09:07,769
or something like that as a property on

00:09:02,459 --> 00:09:10,529
the model yeah so it's actually so I

00:09:07,769 --> 00:09:12,329
drove in to the RM which I don't know

00:09:10,529 --> 00:09:15,990
how much you guys have looked into it

00:09:12,329 --> 00:09:17,610
but it can get kind of hairy so you have

00:09:15,990 --> 00:09:18,810
two models in a many-to-many

00:09:17,610 --> 00:09:20,759
relationship one of them has a

00:09:18,810 --> 00:09:22,290
many-to-many field the other one ends up

00:09:20,759 --> 00:09:25,230
with this many-to-many rail which kind

00:09:22,290 --> 00:09:26,880
of proxies a bunch of methods through

00:09:25,230 --> 00:09:28,769
the many many field to the other model

00:09:26,880 --> 00:09:31,439
and all this stuff so that's in the

00:09:28,769 --> 00:09:33,180
class and then the instances get reverse

00:09:31,439 --> 00:09:34,709
many related objects descriptors in many

00:09:33,180 --> 00:09:36,509
related objects descriptors and those

00:09:34,709 --> 00:09:43,290
produce many related managers and it's

00:09:36,509 --> 00:09:45,290
all just like a big butt so what I yeah

00:09:43,290 --> 00:09:49,740
the other thing is so there's a lot of

00:09:45,290 --> 00:09:51,360
assumptions in there that the joins that

00:09:49,740 --> 00:09:54,120
Django generates are going to be based

00:09:51,360 --> 00:09:55,470
on primary keys so you know you have a

00:09:54,120 --> 00:09:57,569
primary key and a foreign key and

00:09:55,470 --> 00:09:59,160
they're just going to be equal values in

00:09:57,569 --> 00:10:02,189
two different tables there a lot of

00:09:59,160 --> 00:10:06,080
assumptions which you kind of have to

00:10:02,189 --> 00:10:09,330
work around for that it's

00:10:06,080 --> 00:10:11,580
so when it comes down to it this is how

00:10:09,330 --> 00:10:13,760
these are the two sources of giant

00:10:11,580 --> 00:10:17,120
information that Django gets so this

00:10:13,760 --> 00:10:20,960
there's one method get' joining columns

00:10:17,120 --> 00:10:24,150
which returns kind of pairs of columns

00:10:20,960 --> 00:10:26,610
to join on to create this to create the

00:10:24,150 --> 00:10:27,960
join condition and so I thought okay

00:10:26,610 --> 00:10:30,180
well we'll just return nothing from that

00:10:27,960 --> 00:10:33,800
and then there's get extra restriction

00:10:30,180 --> 00:10:36,630
which is used in generic foreign key to

00:10:33,800 --> 00:10:40,080
to add that extra restriction on the

00:10:36,630 --> 00:10:42,660
content type unfortunately that all that

00:10:40,080 --> 00:10:45,720
needs to return is anything that has an

00:10:42,660 --> 00:10:48,270
as SQL method so basically anything that

00:10:45,720 --> 00:10:51,240
generates SQL you can return from that

00:10:48,270 --> 00:10:57,840
and it should be included in the join so

00:10:51,240 --> 00:10:59,190
as as in the lookup thing that that's

00:10:57,840 --> 00:11:00,870
all we need to implement for the lookup

00:10:59,190 --> 00:11:04,530
so look up is an example of something

00:11:00,870 --> 00:11:08,010
that we can return directly from that

00:11:04,530 --> 00:11:11,010
get extra restriction and it should all

00:11:08,010 --> 00:11:14,550
work and it does with a few caveats that

00:11:11,010 --> 00:11:15,780
i'll come to later so this is what it

00:11:14,550 --> 00:11:18,030
looked like you have your tag field and

00:11:15,780 --> 00:11:21,060
your tag query as before but then you

00:11:18,030 --> 00:11:24,620
just have this extra thing which I've

00:11:21,060 --> 00:11:26,990
got a tag many many relation where you

00:11:24,620 --> 00:11:29,040
just like a normal man eternity field

00:11:26,990 --> 00:11:32,640
point out the model that it's pointing

00:11:29,040 --> 00:11:33,960
to give it a related name and then you

00:11:32,640 --> 00:11:35,850
can just use that like an or many too

00:11:33,960 --> 00:11:40,520
many field but the join condition is

00:11:35,850 --> 00:11:43,860
that the matching operator from postgres

00:11:40,520 --> 00:11:45,840
so do you do that then that's the SQL

00:11:43,860 --> 00:11:47,940
that you get out so there's no IDs or

00:11:45,840 --> 00:11:50,780
anything it's just a kind of dynamically

00:11:47,940 --> 00:11:55,860
generated relation based on those tags

00:11:50,780 --> 00:12:00,720
and so at the moment this is all kind of

00:11:55,860 --> 00:12:01,890
read-only you can't add to these fields

00:12:00,720 --> 00:12:06,000
as you can with with a normal

00:12:01,890 --> 00:12:11,190
many-to-many field it also works with

00:12:06,000 --> 00:12:13,530
filtered chaining so um that uses clause

00:12:11,190 --> 00:12:15,270
in that filter there will expand out

00:12:13,530 --> 00:12:16,850
into a proper join as you see they're

00:12:15,270 --> 00:12:22,850
just using the same

00:12:16,850 --> 00:12:27,380
Ching operator so the benefits is

00:12:22,850 --> 00:12:29,540
obviously only only really useful in

00:12:27,380 --> 00:12:31,339
specific situations it's not you can't

00:12:29,540 --> 00:12:32,630
replace every many-to-many filled with

00:12:31,339 --> 00:12:34,040
this but for some things I think it

00:12:32,630 --> 00:12:37,490
works really well like this tagging

00:12:34,040 --> 00:12:40,459
situation because you don't need to

00:12:37,490 --> 00:12:42,769
maintain actual you know many so many

00:12:40,459 --> 00:12:44,839
tables the queries that you get out or a

00:12:42,769 --> 00:12:48,050
lot simpler that probably won't matter

00:12:44,839 --> 00:12:50,959
for some people but I find that you know

00:12:48,050 --> 00:12:56,480
I read a lot of SQL so I like that about

00:12:50,959 --> 00:13:01,430
it and it's also faster in almost all

00:12:56,480 --> 00:13:05,050
cases that I've tested so I tested a big

00:13:01,430 --> 00:13:08,149
data set of about 10 million records

00:13:05,050 --> 00:13:13,880
sorry not like big data as in big data

00:13:08,149 --> 00:13:16,009
just like a data set fiddleman and it

00:13:13,880 --> 00:13:18,529
was at least two times faster in all of

00:13:16,009 --> 00:13:20,569
the cases that I tried there so that's

00:13:18,529 --> 00:13:23,649
than just doing a traditional many too

00:13:20,569 --> 00:13:28,370
many and the actual many-to-many table

00:13:23,649 --> 00:13:32,839
in that case was about 100 times bigger

00:13:28,370 --> 00:13:36,970
than the index that yeah than the text

00:13:32,839 --> 00:13:39,589
search index that was backing this field

00:13:36,970 --> 00:13:42,850
so that's working but I thought there's

00:13:39,589 --> 00:13:46,279
no reason to really leave it at that

00:13:42,850 --> 00:13:48,410
what we can as over what what we might

00:13:46,279 --> 00:13:50,779
be able to do is just have a generic

00:13:48,410 --> 00:13:55,310
field that you just provide some join

00:13:50,779 --> 00:13:57,949
condition too and it just you know gives

00:13:55,310 --> 00:14:00,410
you your accesses and your filter

00:13:57,949 --> 00:14:04,250
chaining and all that kind of stuff for

00:14:00,410 --> 00:14:06,589
free and and that works that works well

00:14:04,250 --> 00:14:09,620
so you just this is basically exactly

00:14:06,589 --> 00:14:11,410
equivalent this new relationship feel

00:14:09,620 --> 00:14:13,610
that I've made you provide it with

00:14:11,410 --> 00:14:16,040
specific join conditions that can be

00:14:13,610 --> 00:14:18,949
anything that has an as SQL method and

00:14:16,040 --> 00:14:21,920
then these arguments are kind of

00:14:18,949 --> 00:14:24,170
annotated field names so our for remote

00:14:21,920 --> 00:14:26,850
and alpha local so it's saying the

00:14:24,170 --> 00:14:28,529
remote subjects

00:14:26,850 --> 00:14:31,410
yeah so this is where I've switched over

00:14:28,529 --> 00:14:33,540
to my lightning talk slides but so

00:14:31,410 --> 00:14:41,430
saying the remote subjects tag matches

00:14:33,540 --> 00:14:43,430
the local interests tag in this case so

00:14:41,430 --> 00:14:45,870
we can also use this to do a

00:14:43,430 --> 00:14:47,990
materialized path thing like I was

00:14:45,870 --> 00:14:51,029
talking about you know before having a

00:14:47,990 --> 00:14:54,540
having a tree structure where you you

00:14:51,029 --> 00:14:57,930
have slugs and your kind of matching

00:14:54,540 --> 00:15:01,440
everything below that so this will be

00:14:57,930 --> 00:15:05,339
that sub tree relation there will now

00:15:01,440 --> 00:15:07,709
return everything with a slug that

00:15:05,339 --> 00:15:11,610
starts with that and that'll just behave

00:15:07,709 --> 00:15:16,050
as a normal menu too many field I

00:15:11,610 --> 00:15:24,079
actually can just see if this works and

00:15:16,050 --> 00:15:24,079
give you a demo all right

00:15:31,769 --> 00:15:39,480
alright so just create a bunch of pages

00:15:36,059 --> 00:15:44,220
you can imagine these being you know

00:15:39,480 --> 00:15:49,559
URLs and a some kind of page tree not

00:15:44,220 --> 00:15:52,069
all gets inserted as normal so i'll just

00:15:49,559 --> 00:15:52,069
select

00:15:57,850 --> 00:16:04,480
so this is selecting that languages /

00:16:01,779 --> 00:16:09,910
dynamic node okay so we've got that and

00:16:04,480 --> 00:16:21,100
if we go sub tree oh yes sorry it should

00:16:09,910 --> 00:16:29,199
be able to do that I can go more it's

00:16:21,100 --> 00:16:31,209
good more okay so when we do that that

00:16:29,199 --> 00:16:33,130
doesn't work because what you get back

00:16:31,209 --> 00:16:36,639
from that is a relationship manager just

00:16:33,130 --> 00:16:37,930
like a normal many related manager that

00:16:36,639 --> 00:16:39,910
you would get if you tried to just

00:16:37,930 --> 00:16:42,279
access that property directly on a

00:16:39,910 --> 00:16:46,470
many-to-many field so like a normal

00:16:42,279 --> 00:16:54,759
field what we actually need to do is

00:16:46,470 --> 00:16:58,720
that's weird what's going on I can't

00:16:54,759 --> 00:17:01,690
explain that all right there you go so

00:16:58,720 --> 00:17:06,699
you do sub treat at all and if you look

00:17:01,690 --> 00:17:08,829
at the query it's using a prefix

00:17:06,699 --> 00:17:12,089
matching there so slug texts like that

00:17:08,829 --> 00:17:14,439
and it's giving us all of those pages

00:17:12,089 --> 00:17:23,220
and it works the other way around as

00:17:14,439 --> 00:17:23,220
well so if we go we select the page one

00:17:29,900 --> 00:17:41,260
well oh yeah yep

00:17:37,150 --> 00:17:44,400
okay good and then if we do ascendance

00:17:41,260 --> 00:17:47,440
i've called it that's the reverse

00:17:44,400 --> 00:17:50,560
accessor and that gives us everything

00:17:47,440 --> 00:17:52,840
going back up the tree just based on

00:17:50,560 --> 00:17:55,360
that same relation so this all of this

00:17:52,840 --> 00:18:00,340
kind of replace replace replace stuff is

00:17:55,360 --> 00:18:03,250
something that the the Django starts

00:18:00,340 --> 00:18:07,330
with look up does for some reason I'm

00:18:03,250 --> 00:18:09,430
not entirely sure of that yeah so this

00:18:07,330 --> 00:18:12,310
you cannot you can use this with a lot

00:18:09,430 --> 00:18:15,130
of stuff the the matches operator that

00:18:12,310 --> 00:18:18,400
works with ID with integer arrays all

00:18:15,130 --> 00:18:23,110
sorts of arrays anything that you can

00:18:18,400 --> 00:18:25,150
express as something with as SQL you can

00:18:23,110 --> 00:18:28,870
basically put into this field and it

00:18:25,150 --> 00:18:32,490
will give you a yet a relation field

00:18:28,870 --> 00:18:32,490
based on that those conditions

00:18:40,840 --> 00:18:47,740
okay so this is the the caveat that I

00:18:43,870 --> 00:18:49,840
was talking about before these are those

00:18:47,740 --> 00:18:51,730
two methods of getting joined

00:18:49,840 --> 00:18:54,659
restrictions that we talked about

00:18:51,730 --> 00:18:57,279
earlier and this is basically just that

00:18:54,659 --> 00:18:59,710
the this is the actual code from the

00:18:57,279 --> 00:19:01,210
join class in the Django RM which

00:18:59,710 --> 00:19:05,500
generates this with a lot of stuff

00:19:01,210 --> 00:19:07,870
deleted but yeah so as you can see it

00:19:05,500 --> 00:19:09,640
looks at these those join pairs remember

00:19:07,870 --> 00:19:13,570
so we return nothing from that so that

00:19:09,640 --> 00:19:16,470
it would give us no SQL for those and

00:19:13,570 --> 00:19:20,500
then it gets the extra conditions and

00:19:16,470 --> 00:19:22,120
ann's them with the conditions that they

00:19:20,500 --> 00:19:26,830
generated up here from the from the

00:19:22,120 --> 00:19:29,559
pairs of columns and so the problem is

00:19:26,830 --> 00:19:31,630
that if there's no SQL generated here

00:19:29,559 --> 00:19:35,140
then you get this and Klaus with no left

00:19:31,630 --> 00:19:37,659
hand side and so that's invalid this is

00:19:35,140 --> 00:19:39,820
the fix that you need to do it so that

00:19:37,659 --> 00:19:43,510
I've opened a patch for that and it's

00:19:39,820 --> 00:19:45,820
been accepted for 1.9 if anyone in the

00:19:43,510 --> 00:19:49,929
room thinks that this might be cool and

00:19:45,820 --> 00:20:02,080
could maybe slip it into 1.8 LTS that'll

00:19:49,929 --> 00:20:04,059
be great yeah and so yeah that's that's

00:20:02,080 --> 00:20:06,090
the end of my presentation thanks very

00:20:04,059 --> 00:20:06,090
much

00:20:12,710 --> 00:20:17,669
anybody does have any questions I'd love

00:20:15,029 --> 00:20:23,460
to take them yeah we got a couple of

00:20:17,669 --> 00:20:25,080
minutes for questions anyone sorry can

00:20:23,460 --> 00:20:27,299
you just confirm the version this is all

00:20:25,080 --> 00:20:32,190
based on 1.8 code it's a won't work on

00:20:27,299 --> 00:20:34,200
1.7 is that right uh the no it won't I

00:20:32,190 --> 00:20:38,100
don't think so because 1.7 doesn't have

00:20:34,200 --> 00:20:39,600
the joint class and so well it would

00:20:38,100 --> 00:20:45,529
need to be patched as well i think that

00:20:39,600 --> 00:20:47,730
the basically the code is the same but

00:20:45,529 --> 00:20:50,090
yeah I mean that would have to be

00:20:47,730 --> 00:20:53,549
patched and that seems unlikely okay

00:20:50,090 --> 00:20:55,350
regarding your question just I'm one of

00:20:53,549 --> 00:20:57,120
the Django core teams are just letting

00:20:55,350 --> 00:21:01,169
you know because it depends whether this

00:20:57,120 --> 00:21:03,149
classifies as a as a bug or a feature if

00:21:01,169 --> 00:21:04,710
you can demonstrate this is a bug in the

00:21:03,149 --> 00:21:06,750
implementation in 1.8 and the fact that

00:21:04,710 --> 00:21:08,549
you can generate causes which are

00:21:06,750 --> 00:21:10,679
invalid SQL would indicate it's a bug

00:21:08,549 --> 00:21:13,139
means it as a candidate for backport so

00:21:10,679 --> 00:21:15,690
it may well get into one point IELTS so

00:21:13,139 --> 00:21:17,909
cool yeah i mean i'm not you know no

00:21:15,690 --> 00:21:25,320
pressure usually expecting about but

00:21:17,909 --> 00:21:27,480
yeah anyway other questions I think that

00:21:25,320 --> 00:21:30,059
you sort of skipped a little bit earlier

00:21:27,480 --> 00:21:33,480
saying that this method was only read

00:21:30,059 --> 00:21:38,580
only yeah that also includes like the

00:21:33,480 --> 00:21:40,139
second part the yeah so normally you

00:21:38,580 --> 00:21:43,529
know in with a magnetic field you can

00:21:40,139 --> 00:21:45,509
assign to it and add to it yeah with

00:21:43,529 --> 00:21:47,879
this basically because because the

00:21:45,509 --> 00:21:50,730
conditions can be anything there's not

00:21:47,879 --> 00:21:52,980
really you know if you have a condition

00:21:50,730 --> 00:21:55,549
like that starts with what does it mean

00:21:52,980 --> 00:21:57,960
to add something to that you know

00:21:55,549 --> 00:22:00,720
because you don't have this like idea

00:21:57,960 --> 00:22:02,370
quality thing you can't just say okay to

00:22:00,720 --> 00:22:03,870
add this you know to satisfy this

00:22:02,370 --> 00:22:06,450
condition with a new thing that I'm

00:22:03,870 --> 00:22:08,220
adding to that relationship I just need

00:22:06,450 --> 00:22:10,590
to set its ID to this like you don't

00:22:08,220 --> 00:22:12,809
have that necessarily because the join

00:22:10,590 --> 00:22:14,429
condition could be arbitrary so at the

00:22:12,809 --> 00:22:15,809
moment yeah it's just read only so you

00:22:14,429 --> 00:22:19,049
might be able to do some introspection

00:22:15,809 --> 00:22:20,369
and you know see if the columns involved

00:22:19,049 --> 00:22:28,279
if you can work with them but I haven't

00:22:20,369 --> 00:22:28,279
looked into that yet yep anyone else yep

00:22:29,570 --> 00:22:34,889
that's a really clean solution looks

00:22:33,029 --> 00:22:38,519
really awesome I was just wondering if

00:22:34,889 --> 00:22:42,059
you had a look at extra you can voice

00:22:38,519 --> 00:22:45,629
additional SQL into a query that you've

00:22:42,059 --> 00:22:49,830
otherwise prepared using the ORM so I've

00:22:45,629 --> 00:22:53,399
used that to do non equality conditions

00:22:49,830 --> 00:22:56,070
for where for example yeah and i did use

00:22:53,399 --> 00:22:59,009
that with so we started using this this

00:22:56,070 --> 00:23:01,710
tags subject matching thing and

00:22:59,009 --> 00:23:03,720
initially I was using extra and then

00:23:01,710 --> 00:23:06,809
moved to you know the custom look up and

00:23:03,720 --> 00:23:08,639
then kind of move to this so basically

00:23:06,809 --> 00:23:10,109
the the reason that I wanted to get it

00:23:08,639 --> 00:23:11,850
as a field is just so that you can take

00:23:10,109 --> 00:23:13,440
advantage of all of the you know the

00:23:11,850 --> 00:23:15,239
privileges that the field has like

00:23:13,440 --> 00:23:17,279
having those automatic accesses and

00:23:15,239 --> 00:23:19,499
being able to you be used through

00:23:17,279 --> 00:23:21,869
filters and all that kind of stuff you

00:23:19,499 --> 00:23:24,919
can do quite a lot by just doing extra

00:23:21,869 --> 00:23:28,230
and then using that query as a sub query

00:23:24,919 --> 00:23:29,429
but I think this kind of you know gets

00:23:28,230 --> 00:23:30,809
it at the bottom and then everything

00:23:29,429 --> 00:23:33,570
that's built on top of fields you can

00:23:30,809 --> 00:23:37,220
you can take advantage of so yeah that's

00:23:33,570 --> 00:23:37,220
the kind of motivation for it

00:23:37,470 --> 00:23:40,870
probably have time for one more if

00:23:39,760 --> 00:23:47,650
there's anyone else who has a question

00:23:40,870 --> 00:23:49,000
or not okay um token of appreciation you

00:23:47,650 --> 00:23:51,070
get one of these because you did a full

00:23:49,000 --> 00:23:53,460
speech yay give him another round of

00:23:51,070 --> 00:23:53,460
applause

00:24:00,640 --> 00:24:02,700

YouTube URL: https://www.youtube.com/watch?v=lNh-tS8i-J4


