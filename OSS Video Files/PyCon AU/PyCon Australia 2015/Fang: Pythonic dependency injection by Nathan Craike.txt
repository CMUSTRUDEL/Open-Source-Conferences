Title: Fang: Pythonic dependency injection by Nathan Craike
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Dependency injection (DI) is a technique most often used in "big OO" languages like Java and C#. It's usually dismissed by Python developers as only needed because of these other languages' deficiencies: static typing, restrictive object systems, lack of reflection, etc.

However, there are other dynamically-typed languages which do use forms of dependency injection. From looking at these systems, we can see there are some advantages to dependency injection _even if_ you're not using a traditional "big OO" language with static types and interfaces. Dependency-injected code can be more modular, much easier to test, easier to analyse, and easier to modify or extend to meet new requirements.

Despite this, there aren't many dependency-injection systems for Python. The few that do exist aren't "Pythonic", or implement DI in ways that compromise a lot of its benefits.

Fang is a library which adds dependency injection to Python in a way which provides real benefits for code clarity, ease of testing, and maintainability, while still fitting naturally into Python's idioms. Fang describes dependencies concisely but explicitly, and doesn't restrict the developer to a particular paradigm on how dependencies are validated or met.

This talk will give a brief overview of how DI is used across a few languages (both traditional OO and dynamic languages) and highlight what elements of DI can be beneficial in Python. The talk will then demo how Fang can be used to add DI to Python code, and show some of the benefits to code clarity, unit testing and code analysis.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:13,110 --> 00:00:18,930
I'm from Brisbane I worked for a few

00:00:16,590 --> 00:00:20,640
years at netbox blue software

00:00:18,930 --> 00:00:23,759
development company and now I'm working

00:00:20,640 --> 00:00:25,910
as a sysadmin for a web agency where we

00:00:23,759 --> 00:00:28,619
deal with a lot of JavaScript and

00:00:25,910 --> 00:00:34,730
another language beginning with P which

00:00:28,619 --> 00:00:37,739
isn't Python yeah

00:00:34,730 --> 00:00:39,379
but sort of to keep myself saying I did

00:00:37,739 --> 00:00:43,530
some Python development in my free time

00:00:39,379 --> 00:00:46,680
and this Fang is a tool I wrote to solve

00:00:43,530 --> 00:00:50,780
a particular problem that I have had a

00:00:46,680 --> 00:00:53,309
lot with Python I love the language but

00:00:50,780 --> 00:00:55,620
there are certain things around how we

00:00:53,309 --> 00:00:58,829
do dependencies and how the input system

00:00:55,620 --> 00:01:01,170
works which makes Python a little tricky

00:00:58,829 --> 00:01:02,910
to deal with sometimes and looking at

00:01:01,170 --> 00:01:07,619
how other languages solve these problems

00:01:02,910 --> 00:01:09,420
I came up with what I think is a pitch

00:01:07,619 --> 00:01:12,119
for a solution I don't know if it's

00:01:09,420 --> 00:01:15,450
perfect but it's something I'd like to

00:01:12,119 --> 00:01:16,950
start a conversation about so the

00:01:15,450 --> 00:01:21,209
library I've written call is called Fang

00:01:16,950 --> 00:01:26,310
it's only about 300 lines and I'll show

00:01:21,209 --> 00:01:27,720
you that so first of all Fang I describe

00:01:26,310 --> 00:01:29,369
as a dependency injection framework

00:01:27,720 --> 00:01:31,410
should first define what dependency

00:01:29,369 --> 00:01:34,800
injection is it's a general sort of

00:01:31,410 --> 00:01:37,440
pattern where the code you write doesn't

00:01:34,800 --> 00:01:39,090
actually directly refer to things that

00:01:37,440 --> 00:01:41,759
it needs instead it ask something else

00:01:39,090 --> 00:01:43,470
to them and the things that need in some

00:01:41,759 --> 00:01:47,009
languages they're classes but they can

00:01:43,470 --> 00:01:49,080
also be libraries or objects and a

00:01:47,009 --> 00:01:51,929
dependency injection framework is that

00:01:49,080 --> 00:01:55,590
other thing that it uses to get its

00:01:51,929 --> 00:01:58,880
dependencies in a lot of big languages

00:01:55,590 --> 00:02:02,160
like Java and c-sharp a lot bigger

00:01:58,880 --> 00:02:03,599
classical languages it has some other

00:02:02,160 --> 00:02:06,030
names like an inversion of control

00:02:03,599 --> 00:02:08,340
container and ioc container or

00:02:06,030 --> 00:02:10,080
informally often just a container here's

00:02:08,340 --> 00:02:14,670
a container library i wrote and that

00:02:10,080 --> 00:02:16,020
means something to java people but i'm

00:02:14,670 --> 00:02:17,700
just going to call it a dependency

00:02:16,020 --> 00:02:21,480
injection tool or a dependency injection

00:02:17,700 --> 00:02:22,959
framework dependency injections most

00:02:21,480 --> 00:02:25,870
popular

00:02:22,959 --> 00:02:29,290
Java and c-sharp and there are loads and

00:02:25,870 --> 00:02:31,420
loads of libraries to do it a lot of

00:02:29,290 --> 00:02:36,670
them use XML for configuration a lot of

00:02:31,420 --> 00:02:39,250
them c-sharp has its own more XML they

00:02:36,670 --> 00:02:43,560
make a lot of use of what we'd think of

00:02:39,250 --> 00:02:50,530
as classical features like static typing

00:02:43,560 --> 00:02:52,450
interfaces XML and most of all most of

00:02:50,530 --> 00:02:54,250
them assume that the smallest bit of

00:02:52,450 --> 00:02:57,370
code that you're going to ever deal with

00:02:54,250 --> 00:02:59,200
it is a class now none of these are

00:02:57,370 --> 00:03:02,260
popular ideas in Python we don't like

00:02:59,200 --> 00:03:03,489
static types we don't use interfaces

00:03:02,260 --> 00:03:08,019
that much

00:03:03,489 --> 00:03:09,489
we have informal interfaces and we don't

00:03:08,019 --> 00:03:12,329
always deal with classes sometimes we

00:03:09,489 --> 00:03:12,329
just talk about functions

00:03:13,190 --> 00:03:17,980
so from that why would you even want

00:03:15,470 --> 00:03:20,270
dependency injection in Piketon

00:03:17,980 --> 00:03:22,610
usually we think of it as a tool for

00:03:20,270 --> 00:03:25,100
other languages we don't need it we can

00:03:22,610 --> 00:03:29,720
just use monkey-patching or all these

00:03:25,100 --> 00:03:31,190
great mocking libraries we have we can

00:03:29,720 --> 00:03:33,260
just write some extra dynamic code

00:03:31,190 --> 00:03:35,270
that'll figure out what we need it's

00:03:33,260 --> 00:03:39,200
it's not something we need in Python is

00:03:35,270 --> 00:03:40,820
the usual school of thought so for me

00:03:39,200 --> 00:03:45,710
the best argument for dependency

00:03:40,820 --> 00:03:48,050
injection is easier unit testing we have

00:03:45,710 --> 00:03:51,590
lots of great mocking tools but it's

00:03:48,050 --> 00:03:53,540
still a bit of a hassle because often

00:03:51,590 --> 00:03:55,220
you're trying to mock things where you

00:03:53,540 --> 00:03:57,350
just can't get at the scope that you

00:03:55,220 --> 00:03:58,970
want to change names off sorry for those

00:03:57,350 --> 00:04:01,400
of you haven't really used mocking tools

00:03:58,970 --> 00:04:03,050
much the idea is that there's a

00:04:01,400 --> 00:04:06,290
particular scope in Python somewhere

00:04:03,050 --> 00:04:08,540
that has a name that refers to a real

00:04:06,290 --> 00:04:09,560
object and for the purposes of your test

00:04:08,540 --> 00:04:12,350
you want to replace it with something

00:04:09,560 --> 00:04:14,390
else and these tools if you can get a

00:04:12,350 --> 00:04:16,070
reference to that scope that object that

00:04:14,390 --> 00:04:18,920
module you can kind of say just take

00:04:16,070 --> 00:04:22,280
that name and reassign it to this fake

00:04:18,920 --> 00:04:24,260
object I wrote but sometimes you can't

00:04:22,280 --> 00:04:26,930
even get at the scope and this is a

00:04:24,260 --> 00:04:28,730
fairly common pattern where you'll have

00:04:26,930 --> 00:04:30,770
a module that defined some classes and

00:04:28,730 --> 00:04:33,770
then the conventional way to use that

00:04:30,770 --> 00:04:37,070
module is the last thing the module will

00:04:33,770 --> 00:04:38,630
do is just create a single instance of

00:04:37,070 --> 00:04:40,070
the class and the conventional way to

00:04:38,630 --> 00:04:42,290
use the module is just to always use

00:04:40,070 --> 00:04:45,020
that instance but that's kind of hard to

00:04:42,290 --> 00:04:47,540
test because if you've written you're

00:04:45,020 --> 00:04:49,520
testing some code that uses that by the

00:04:47,540 --> 00:04:51,020
time by the time you want to replace

00:04:49,520 --> 00:04:53,810
that instance with something else it's

00:04:51,020 --> 00:04:56,210
by the time you can there might already

00:04:53,810 --> 00:04:58,010
be you know a bunch of other things

00:04:56,210 --> 00:05:01,580
referring to it they've all grabbed a

00:04:58,010 --> 00:05:03,620
reference to that at import time so by

00:05:01,580 --> 00:05:06,340
the time you want to mock things out

00:05:03,620 --> 00:05:06,340
it'll be too late

00:05:07,980 --> 00:05:12,490
the other problem is that sometimes you

00:05:10,360 --> 00:05:15,760
forget to mock something you write a

00:05:12,490 --> 00:05:18,610
library refers to some files on disk or

00:05:15,760 --> 00:05:21,010
does the network i/o you write some ox

00:05:18,610 --> 00:05:22,600
for it and then you upgrade the library

00:05:21,010 --> 00:05:24,010
it does a few more things and you forget

00:05:22,600 --> 00:05:26,830
to mock out one of the new things that

00:05:24,010 --> 00:05:28,720
it does and suddenly your unit test

00:05:26,830 --> 00:05:31,450
suite is performing real network.i or

00:05:28,720 --> 00:05:34,120
real disk i/o you might not even realize

00:05:31,450 --> 00:05:35,500
until suddenly you run your tests on

00:05:34,120 --> 00:05:37,060
your laptop when you don't internet and

00:05:35,500 --> 00:05:40,690
they fail even though they've always

00:05:37,060 --> 00:05:42,870
passed this can happen we we're human we

00:05:40,690 --> 00:05:42,870
make mistakes

00:05:42,940 --> 00:05:49,990
dependency injection can be a solution

00:05:45,070 --> 00:05:52,050
for this and sort of the strategy I have

00:05:49,990 --> 00:05:55,240
is looking at how things are done in

00:05:52,050 --> 00:05:58,270
languages other than Java and c-sharp so

00:05:55,240 --> 00:06:01,450
a good example is JavaScript people who

00:05:58,270 --> 00:06:04,530
have written any JavaScript particularly

00:06:01,450 --> 00:06:07,270
on nodejs or some of the more modern

00:06:04,530 --> 00:06:08,650
browser JavaScript libraries there's

00:06:07,270 --> 00:06:10,690
this fairly common pattern of

00:06:08,650 --> 00:06:13,480
in JavaScript all you really have a

00:06:10,690 --> 00:06:15,940
functions for doing scoping so this

00:06:13,480 --> 00:06:17,950
common pattern of basically defining a

00:06:15,940 --> 00:06:20,650
function scope just to wrap up all the

00:06:17,950 --> 00:06:22,480
different pieces of your module and the

00:06:20,650 --> 00:06:27,580
way you get your appendices is you just

00:06:22,480 --> 00:06:30,670
take them as arguments and so you do a

00:06:27,580 --> 00:06:33,130
bunch of stuff your dependencies or

00:06:30,670 --> 00:06:35,260
arguments here and then at the end you

00:06:33,130 --> 00:06:38,650
you build an object it is your module

00:06:35,260 --> 00:06:40,390
and then at the end you at the end of

00:06:38,650 --> 00:06:43,360
defining all the pieces of your module

00:06:40,390 --> 00:06:45,100
you return that and whatever is

00:06:43,360 --> 00:06:48,820
responsible for loading and module will

00:06:45,100 --> 00:06:50,500
pass in these dependencies or whatever

00:06:48,820 --> 00:06:55,630
it decides will meet those dependencies

00:06:50,500 --> 00:06:57,310
when your module is loaded so this is

00:06:55,630 --> 00:06:59,629
actually much closer to how we might do

00:06:57,310 --> 00:07:01,399
it in Python

00:06:59,629 --> 00:07:03,919
the idea of dependencies aren't

00:07:01,399 --> 00:07:06,080
described with strict interfaces or

00:07:03,919 --> 00:07:08,599
classes they're just values with names

00:07:06,080 --> 00:07:10,369
they get passed as parameters but the

00:07:08,599 --> 00:07:11,990
end of the day of function arguments

00:07:10,369 --> 00:07:15,139
just a name you can pass something else

00:07:11,990 --> 00:07:18,199
in and it's a lot like how we do things

00:07:15,139 --> 00:07:20,419
in Python with duck typing as long as

00:07:18,199 --> 00:07:23,270
something sort of meets the needs of as

00:07:20,419 --> 00:07:25,399
long as a dependency meets the needs of

00:07:23,270 --> 00:07:27,349
the code that uses it everything's fine

00:07:25,399 --> 00:07:29,779
we don't we don't strictly check

00:07:27,349 --> 00:07:33,439
interfaces although you could if you

00:07:29,779 --> 00:07:34,939
wanted to still we're probably not going

00:07:33,439 --> 00:07:36,860
to write Python like this where we have

00:07:34,939 --> 00:07:39,169
a function that takes dependencies and

00:07:36,860 --> 00:07:41,119
that returns your module and you know

00:07:39,169 --> 00:07:42,740
the way the way you don't actually

00:07:41,119 --> 00:07:46,449
import things anymore you just call

00:07:42,740 --> 00:07:48,680
functions that return modules and

00:07:46,449 --> 00:07:51,229
everything you write is in a giant

00:07:48,680 --> 00:07:53,330
function your entire module is just one

00:07:51,229 --> 00:07:55,809
big function definition I can't see that

00:07:53,330 --> 00:07:55,809
taking off

00:07:57,150 --> 00:08:04,570
yeah maybe someone might use it but I

00:08:01,300 --> 00:08:05,889
can't see catching on so we need some

00:08:04,570 --> 00:08:09,700
language in Python to talk about

00:08:05,889 --> 00:08:14,470
dependencies that matches the idioms of

00:08:09,700 --> 00:08:19,419
Python so from this I wrote family so

00:08:14,470 --> 00:08:22,560
Fang has three core principles resources

00:08:19,419 --> 00:08:25,000
or or things he depend on are just names

00:08:22,560 --> 00:08:28,690
they're not interfaces or factory

00:08:25,000 --> 00:08:31,690
classes or whatever providers are just

00:08:28,690 --> 00:08:32,979
functions sorry I misspoke providers are

00:08:31,690 --> 00:08:36,010
just functions they're the ones that

00:08:32,979 --> 00:08:37,450
aren't factory classes so a resource is

00:08:36,010 --> 00:08:42,070
just a name that you talk about it's

00:08:37,450 --> 00:08:44,020
just a string and then the things that

00:08:42,070 --> 00:08:46,930
actually provide those resources are

00:08:44,020 --> 00:08:49,270
just some sort of horrible and lastly

00:08:46,930 --> 00:08:54,010
configuration here's an XML it's just

00:08:49,270 --> 00:08:58,930
Python code so this is the syntax of

00:08:54,010 --> 00:09:02,740
thing so you just create this little di

00:08:58,930 --> 00:09:04,960
utility function and then when you write

00:09:02,740 --> 00:09:07,360
a function that has a dependency you

00:09:04,960 --> 00:09:09,220
just decorate it with di doc depends on

00:09:07,360 --> 00:09:13,150
and then multiplied here is just the

00:09:09,220 --> 00:09:15,730
name of the resource you need and then

00:09:13,150 --> 00:09:19,990
the important thing here is this is

00:09:15,730 --> 00:09:21,820
really just annotation di doesn't

00:09:19,990 --> 00:09:23,650
actually know what it's going to use to

00:09:21,820 --> 00:09:25,330
meet multiplier it's just a string that

00:09:23,650 --> 00:09:27,610
it talks about it's just a name for the

00:09:25,330 --> 00:09:29,740
thing that this function means it's not

00:09:27,610 --> 00:09:32,260
until here when we actually reach the

00:09:29,740 --> 00:09:33,790
entry point of our program this is if

00:09:32,260 --> 00:09:35,500
our programs running as a script if

00:09:33,790 --> 00:09:38,770
you've imported a module you might write

00:09:35,500 --> 00:09:41,170
some other code to set this up but when

00:09:38,770 --> 00:09:43,260
program the full program execution is

00:09:41,170 --> 00:09:46,900
going to start not just importing things

00:09:43,260 --> 00:09:49,480
you then actually register what will

00:09:46,900 --> 00:09:52,029
meet that what will provide that

00:09:49,480 --> 00:09:53,410
resource multiplier and in our case here

00:09:52,029 --> 00:09:58,770
it's just a function that returns the

00:09:53,410 --> 00:09:58,770
value two so until this line here

00:09:59,070 --> 00:10:06,660
thank doesn't really have any idea what

00:10:02,820 --> 00:10:09,760
what actual concrete implementations

00:10:06,660 --> 00:10:11,290
meet up what concrete implementations

00:10:09,760 --> 00:10:13,060
are used to provide a particular

00:10:11,290 --> 00:10:17,260
resource and that's really useful

00:10:13,060 --> 00:10:19,090
because you know then that some code

00:10:17,260 --> 00:10:20,830
that import time hasn't grabbed a

00:10:19,090 --> 00:10:22,270
reference to a real thing that you might

00:10:20,830 --> 00:10:26,410
want to replace later because you're

00:10:22,270 --> 00:10:28,840
doing testing so the DIA object is

00:10:26,410 --> 00:10:30,880
really simple it's really just a

00:10:28,840 --> 00:10:33,550
combination of these three different

00:10:30,880 --> 00:10:36,220
pieces so you have a register for

00:10:33,550 --> 00:10:38,680
dependencies a register for things that

00:10:36,220 --> 00:10:40,960
provide resources to meet those

00:10:38,680 --> 00:10:42,130
dependencies and you have a resolver

00:10:40,960 --> 00:10:45,460
they're just kind of combines the two

00:10:42,130 --> 00:10:48,970
together to do the lookups and then you

00:10:45,460 --> 00:10:50,830
ask a decorator down here which is just

00:10:48,970 --> 00:10:54,510
sort of convenience to provide a nice

00:10:50,830 --> 00:10:54,510
way of talking about dependencies

00:10:54,870 --> 00:10:59,640
registering dependencies is just a

00:10:56,980 --> 00:10:59,640
decorator here

00:11:02,500 --> 00:11:10,810
so as I said providers it just loaded in

00:11:05,050 --> 00:11:16,300
at your program entry point and the

00:11:10,810 --> 00:11:18,580
resolver matches up providers or the

00:11:16,300 --> 00:11:22,690
results of providers with actual

00:11:18,580 --> 00:11:26,200
dependencies multiple dependencies you

00:11:22,690 --> 00:11:27,450
just decorate your function more than

00:11:26,200 --> 00:11:31,270
once

00:11:27,450 --> 00:11:32,980
and the resolve is unpack function will

00:11:31,270 --> 00:11:35,290
just give you the things that you your

00:11:32,980 --> 00:11:37,930
function needs as a tuple so that you

00:11:35,290 --> 00:11:42,460
can easily just assign them using two

00:11:37,930 --> 00:11:45,190
packing if you want to do dependencies

00:11:42,460 --> 00:11:46,930
on classes the idea is that you you

00:11:45,190 --> 00:11:49,930
resolve your dependencies and unpack

00:11:46,930 --> 00:11:55,870
them in your instructor and then you

00:11:49,930 --> 00:12:00,850
just save them to self and this makes

00:11:55,870 --> 00:12:04,020
unit testing much much easier so here's

00:12:00,850 --> 00:12:09,820
our function with multiple dependencies

00:12:04,020 --> 00:12:12,280
what we do we first clear out the the

00:12:09,820 --> 00:12:13,840
list of registered providers and you'll

00:12:12,280 --> 00:12:16,720
you'll have to do this between each test

00:12:13,840 --> 00:12:18,850
which is a bit of a caveat but then you

00:12:16,720 --> 00:12:21,430
just register the values you want for

00:12:18,850 --> 00:12:25,270
multiplier and offset these can also be

00:12:21,430 --> 00:12:28,990
functions really a provider is just a

00:12:25,270 --> 00:12:30,220
callable that takes no arguments so in

00:12:28,990 --> 00:12:32,980
this case this is just a helper that

00:12:30,220 --> 00:12:35,490
will will create a little lambda that

00:12:32,980 --> 00:12:39,510
takes no arguments returns 3 and

00:12:35,490 --> 00:12:44,100
similarly this one will just return one

00:12:39,510 --> 00:12:46,630
so you set you set your providers up

00:12:44,100 --> 00:12:48,430
this is a another helper that will just

00:12:46,630 --> 00:12:49,690
check that you've actually registered

00:12:48,430 --> 00:12:52,600
all the appropriate providers for what

00:12:49,690 --> 00:12:56,740
you're testing I'm sorry that should be

00:12:52,600 --> 00:12:58,780
multiplying and act there and then you

00:12:56,740 --> 00:13:00,880
just run the code under test and check

00:12:58,780 --> 00:13:02,800
the output but this is all the setup you

00:13:00,880 --> 00:13:06,390
need to do there's no pulling to a

00:13:02,800 --> 00:13:06,390
mocking library to replace names

00:13:06,760 --> 00:13:14,589
yeah so Fang is usable at the moment but

00:13:12,820 --> 00:13:18,279
there are some more features I'd like to

00:13:14,589 --> 00:13:21,850
add or I have the syntax done but not

00:13:18,279 --> 00:13:23,320
the implementation yet there's also one

00:13:21,850 --> 00:13:26,350
important thing I need to actually put

00:13:23,320 --> 00:13:28,899
it on the PI package index I have a

00:13:26,350 --> 00:13:31,720
setup dot pi so there's not too much

00:13:28,899 --> 00:13:34,079
work left to do on that I'm hoping I'll

00:13:31,720 --> 00:13:38,010
get it done in the next couple days

00:13:34,079 --> 00:13:40,839
probably in the hallways between talks

00:13:38,010 --> 00:13:43,089
I'd like to add support for namespaces

00:13:40,839 --> 00:13:44,940
so that if more than one project is

00:13:43,089 --> 00:13:46,990
using Fang or you're grabbing

00:13:44,940 --> 00:13:50,579
dependencies from different projects you

00:13:46,990 --> 00:13:50,579
have a reasonable way to talk about them

00:13:50,820 --> 00:13:55,930
so the idea is that you you set up a

00:13:53,410 --> 00:13:57,790
default namespace and if you don't say

00:13:55,930 --> 00:13:59,470
you know it's assumed that it's on to

00:13:57,790 --> 00:14:01,570
the default namespace otherwise you give

00:13:59,470 --> 00:14:04,089
sort of an absolute path now I

00:14:01,570 --> 00:14:06,820
understand that's a bit verbose so the

00:14:04,089 --> 00:14:12,399
next thing would be providing a nice way

00:14:06,820 --> 00:14:14,470
to sort of define sort of just syntactic

00:14:12,399 --> 00:14:18,010
sugar just aliases so that you can talk

00:14:14,470 --> 00:14:19,690
about instead of talking about the

00:14:18,010 --> 00:14:21,519
Python standard web you just you just

00:14:19,690 --> 00:14:27,160
say Python

00:14:21,519 --> 00:14:29,920
I also want to write a bunch of adapters

00:14:27,160 --> 00:14:32,199
well not really one adapter that will

00:14:29,920 --> 00:14:35,550
just sort of handle passing it's the

00:14:32,199 --> 00:14:35,550
Python standard library into Fang

00:14:35,760 --> 00:14:40,690
similarly for third-party libraries I

00:14:38,380 --> 00:14:44,440
don't expect everything to have Fang

00:14:40,690 --> 00:14:47,649
wrapping suddenly and I also want to

00:14:44,440 --> 00:14:49,510
make the testing a little nicer so there

00:14:47,649 --> 00:14:52,019
are easy ways to passing fake objects

00:14:49,510 --> 00:14:52,019
and things like that

00:14:52,069 --> 00:15:15,089
so that's Fang any questions toning up I

00:15:09,359 --> 00:15:19,100
guess people just come up thanks you

00:15:15,089 --> 00:15:21,209
talk was really interesting my favorite

00:15:19,100 --> 00:15:26,970
example of dependency injection in

00:15:21,209 --> 00:15:28,709
Python is the PI test fixtures and just

00:15:26,970 --> 00:15:31,229
how that works for people who don't know

00:15:28,709 --> 00:15:33,059
is is you just define a whole bunch of

00:15:31,229 --> 00:15:34,679
functions and then PI test goes and

00:15:33,059 --> 00:15:36,689
collects them with a decorator and and

00:15:34,679 --> 00:15:39,329
then injects them into your tests using

00:15:36,689 --> 00:15:41,910
them now matching I'm just wished one

00:15:39,329 --> 00:15:44,789
during the design decision of using the

00:15:41,910 --> 00:15:47,009
unpack inside of the inside of the

00:15:44,789 --> 00:15:48,779
function over kind of injecting them via

00:15:47,009 --> 00:15:51,389
function function arguments a function

00:15:48,779 --> 00:15:55,439
arguments yes my concern with that is

00:15:51,389 --> 00:15:58,949
that I mean it might work okay in unit

00:15:55,439 --> 00:16:03,059
tests but in other code I don't really

00:15:58,949 --> 00:16:03,809
want to crowd up the calling signature

00:16:03,059 --> 00:16:06,539
of a function

00:16:03,809 --> 00:16:07,589
I think after you do that with a few

00:16:06,539 --> 00:16:09,419
dependencies

00:16:07,589 --> 00:16:11,909
instead of writing a function that just

00:16:09,419 --> 00:16:13,109
does something with a and B it does

00:16:11,909 --> 00:16:14,549
something with a and B and then takes

00:16:13,109 --> 00:16:19,109
you know three other libraries to do

00:16:14,549 --> 00:16:20,939
various things I I felt that I did

00:16:19,109 --> 00:16:22,769
consider doing that but I felt that it

00:16:20,939 --> 00:16:27,259
would make the calling see that

00:16:22,769 --> 00:16:27,259
signature the function too crowded and

00:16:27,289 --> 00:16:31,949
and in addition to the simple case of a

00:16:29,699 --> 00:16:33,269
function it gets confusing like what do

00:16:31,949 --> 00:16:36,149
you do when you have classes with

00:16:33,269 --> 00:16:37,350
multiple inheritance although amber who

00:16:36,149 --> 00:16:38,789
was just here would probably argue that

00:16:37,350 --> 00:16:41,609
you don't you don't have multiple

00:16:38,789 --> 00:16:44,249
inheritance that's a trap but still

00:16:41,609 --> 00:16:47,189
certainly things like constructors often

00:16:44,249 --> 00:16:49,079
get really crowded plus object

00:16:47,189 --> 00:16:50,789
constructors get really crowded very

00:16:49,079 --> 00:16:52,439
quickly if you have multiple if you have

00:16:50,789 --> 00:16:56,450
any level women inheritance really I

00:16:52,439 --> 00:17:04,160
just want to add to that yeah

00:16:56,450 --> 00:17:07,250
I was going to ask the same question I'm

00:17:04,160 --> 00:17:09,559
a strong believer in the concept of

00:17:07,250 --> 00:17:11,260
passing arguments around in function

00:17:09,559 --> 00:17:13,790
signatures I'll ask a different question

00:17:11,260 --> 00:17:16,010
have you measured the overhead of doing

00:17:13,790 --> 00:17:17,900
the DI this way and we're having to

00:17:16,010 --> 00:17:22,429
unpack the dependencies in the function

00:17:17,900 --> 00:17:26,170
whilst executing no I haven't under the

00:17:22,429 --> 00:17:29,300
hood so the DI object the dependency

00:17:26,170 --> 00:17:31,370
register the resource provider register

00:17:29,300 --> 00:17:32,660
under the hood they're both just using a

00:17:31,370 --> 00:17:35,559
couple dictionaries to keep track of

00:17:32,660 --> 00:17:39,230
everything one's a dictionary mapping

00:17:35,559 --> 00:17:41,330
functions or classes objects to names

00:17:39,230 --> 00:17:44,059
and the other one is the other way

00:17:41,330 --> 00:17:49,760
around mapping names to to call levels

00:17:44,059 --> 00:17:51,410
that provide those things so I expect

00:17:49,760 --> 00:17:53,780
that's fairly fast but I haven't done

00:17:51,410 --> 00:17:55,670
profiling and if it does prove to be too

00:17:53,780 --> 00:17:57,590
slow then I guess I would jump in there

00:17:55,670 --> 00:18:00,140
and figure out how to re-implement some

00:17:57,590 --> 00:18:02,030
of it in C although I I doubt I can do

00:18:00,140 --> 00:18:05,630
better than the dictionary

00:18:02,030 --> 00:18:07,880
implementation in Python I thank you

00:18:05,630 --> 00:18:12,580
yeah thanks that answered my question

00:18:07,880 --> 00:18:15,020
yes anybody else

00:18:12,580 --> 00:18:18,200
well I've got another unique gift for

00:18:15,020 --> 00:18:22,100
Nathan this one the committee got from

00:18:18,200 --> 00:18:25,300
the very rare and soils around central

00:18:22,100 --> 00:18:25,300
Queensland the red clays

00:18:41,299 --> 00:18:43,360

YouTube URL: https://www.youtube.com/watch?v=zqRd941NXlI


