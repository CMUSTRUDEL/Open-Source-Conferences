Title: Python's Transition to Multilingual Programming by Nick Coghlan
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	"Ugh, why does Unicode have to be so complicated? It's just text, why can't it be as simple as writing a note for myself?"

One of the more controversial changes in Python 3 is the decision to handle text data entirely as Unicode code points. In this presentation, CPython core developer Nick Coghlan will explore some of the background of that design decision, the capabilities it grants Python 3 over Python 2, and some of the related features of the upcoming Python 3.5 release.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,430 --> 00:00:16,170
good afternoon everybody we're running

00:00:13,230 --> 00:00:18,570
on time again so I just introduced here

00:00:16,170 --> 00:00:20,430
Nick Coughlin is a cpython core

00:00:18,570 --> 00:00:22,710
developer on the board of directors for

00:00:20,430 --> 00:00:23,580
Python Software Foundation and he's

00:00:22,710 --> 00:00:33,390
going to talk to you this afternoon

00:00:23,580 --> 00:00:36,480
about unicode hasten make all strings be

00:00:33,390 --> 00:00:38,610
Unicode five little words that have had

00:00:36,480 --> 00:00:42,269
a profound impact on the last seven

00:00:38,610 --> 00:00:45,809
years of my life so I'm going to see

00:00:42,269 --> 00:00:50,519
Python core developers since 2005 and

00:00:45,809 --> 00:00:55,739
those five words from the original pip

00:00:50,519 --> 00:00:57,870
3000 so now called pep 3100 and that's

00:00:55,739 --> 00:00:59,489
where the core developers started

00:00:57,870 --> 00:01:01,409
accumulating all of the non-country

00:00:59,489 --> 00:01:03,930
non-controversial Python 3 design

00:01:01,409 --> 00:01:05,670
changes so things that became obvious

00:01:03,930 --> 00:01:08,580
that in the course of maintaining Python

00:01:05,670 --> 00:01:10,190
2 they were just broken that that they

00:01:08,580 --> 00:01:13,890
caused lots of problems in lots of

00:01:10,190 --> 00:01:16,050
obscure ways that they ended up getting

00:01:13,890 --> 00:01:20,160
escalated to the core developers to say

00:01:16,050 --> 00:01:23,010
why is my code broken and yeah

00:01:20,160 --> 00:01:26,190
explaining why I was because the core

00:01:23,010 --> 00:01:28,650
data types had broken and so great I

00:01:26,190 --> 00:01:33,120
started the Python 3 project in earnest

00:01:28,650 --> 00:01:37,200
in 2006 and then - 3.0 was released in

00:01:33,120 --> 00:01:38,610
2008 seven years later we're still

00:01:37,200 --> 00:01:43,590
dealing with some of the consequences

00:01:38,610 --> 00:01:44,910
and we still have quite a ways to go so

00:01:43,590 --> 00:01:47,160
one of the interesting questions about

00:01:44,910 --> 00:01:48,840
Unicode was why did we change the

00:01:47,160 --> 00:01:51,300
default what was actually wrong with

00:01:48,840 --> 00:01:52,860
Python - and we hear that a lot from

00:01:51,300 --> 00:01:54,540
people who do a lot of network and

00:01:52,860 --> 00:01:56,460
socket programming because like going

00:01:54,540 --> 00:02:00,930
the 8 bit strings were awesome they

00:01:56,460 --> 00:02:05,220
worked really well so I'm gonna switch

00:02:00,930 --> 00:02:07,580
to a little demo and so you can see here

00:02:05,220 --> 00:02:09,920
we've got three data files to play with

00:02:07,580 --> 00:02:13,500
this is gonna be interesting

00:02:09,920 --> 00:02:17,450
so 3-day two parts so let's start up

00:02:13,500 --> 00:02:17,450
we'll have Python 2

00:02:18,090 --> 00:02:23,590
it's not up - - there we go

00:02:20,910 --> 00:02:27,100
so we're gonna import pandas to do some

00:02:23,590 --> 00:02:36,690
data analysis so we're gonna we have

00:02:27,100 --> 00:02:36,690
some CSV files it's read English data

00:02:39,860 --> 00:02:50,720
nope if they actually store the data

00:02:42,890 --> 00:02:54,380
somewhere data there we go okay so we've

00:02:50,720 --> 00:02:56,390
got a got a data file of student data

00:02:54,380 --> 00:03:00,380
results yeah I don't actually use pandas

00:02:56,390 --> 00:03:01,970
very much I know it should but yes if

00:03:00,380 --> 00:03:05,330
you're doing data analysis use pandas

00:03:01,970 --> 00:03:07,640
don't reinvent all their wheels so

00:03:05,330 --> 00:03:11,709
anyway so man this is pretty cool okay

00:03:07,640 --> 00:03:11,709
let's get the results out for Kelly

00:03:14,140 --> 00:03:19,910
okay so we have Kelly's test results and

00:03:18,080 --> 00:03:27,890
if we want to get the results out if

00:03:19,910 --> 00:03:32,709
we've got if we've got that as a 8-bit

00:03:27,890 --> 00:03:32,709
string we can get it out

00:03:36,270 --> 00:03:41,550
got a naked string we can get it out

00:03:38,310 --> 00:03:45,390
that way if you've got as a Unicode

00:03:41,550 --> 00:03:48,120
string we can get it out that way okay

00:03:45,390 --> 00:03:50,850
so now I'm no longer teaching in

00:03:48,120 --> 00:03:54,180
Australia I'm an Australian teaching in

00:03:50,850 --> 00:03:56,640
Japan so my Japanese isn't very good so

00:03:54,180 --> 00:03:57,950
I've transcribed all my students names

00:03:56,640 --> 00:04:01,260
into romaji

00:03:57,950 --> 00:04:05,280
and so now what I'm going to do instead

00:04:01,260 --> 00:04:12,870
of reading the English data I'll read it

00:04:05,280 --> 00:04:14,460
in religion so now a better instead of

00:04:12,870 --> 00:04:18,420
Perry Kelly and Naomi

00:04:14,460 --> 00:04:21,360
we have furuto Keiko and Nanami okay

00:04:18,420 --> 00:04:26,400
it's still pretty cool we can still get

00:04:21,360 --> 00:04:29,940
all that data out the way we used to so

00:04:26,400 --> 00:04:31,290
that all still works but okay I'm no

00:04:29,940 --> 00:04:33,780
longer an Australian teaching in Japan

00:04:31,290 --> 00:04:35,580
I'm an actual Japanese teacher and I

00:04:33,780 --> 00:04:38,730
want to use Python to animai analyze my

00:04:35,580 --> 00:04:40,260
students results so I'm actually get

00:04:38,730 --> 00:04:43,070
Bernie's and so I'm going to write their

00:04:40,260 --> 00:04:43,070
names properly

00:04:48,559 --> 00:04:54,000
so

00:04:50,610 --> 00:04:55,349
here we see Naruto k-code Nanami and one

00:04:54,000 --> 00:04:58,169
of the interesting things about Haruto

00:04:55,349 --> 00:05:01,889
is there's three different ways of

00:04:58,169 --> 00:05:05,129
writing haruto in kanji and they all

00:05:01,889 --> 00:05:08,189
transcribed to romaji as the string

00:05:05,129 --> 00:05:09,629
Haruto which would mean that if I had

00:05:08,189 --> 00:05:11,849
three Haru toys in my class and they all

00:05:09,629 --> 00:05:13,500
spilled their names differently even as

00:05:11,849 --> 00:05:15,900
an Australian my trick of translating

00:05:13,500 --> 00:05:21,240
taraji wouldn't have worked but it gets

00:05:15,900 --> 00:05:24,030
worse so now I don't actually have the

00:05:21,240 --> 00:05:27,060
ability to enter kanji on my keyboard so

00:05:24,030 --> 00:05:31,319
I'm gonna have to fight now yes yes I'm

00:05:27,060 --> 00:05:36,690
cheating I know but copy and paste works

00:05:31,319 --> 00:05:40,979
fine so we'll go with that so now we're

00:05:36,690 --> 00:05:43,279
gonna go and say hey that Cole Max's

00:05:40,979 --> 00:05:46,680
trick was pretty cool let's try that ah

00:05:43,279 --> 00:05:49,039
no that doesn't work what about 8-bit

00:05:46,680 --> 00:05:49,039
strengths

00:05:51,690 --> 00:06:01,320
that's cool but maybe we should be

00:05:56,550 --> 00:06:02,730
handling our data routine okay well so

00:06:01,320 --> 00:06:06,450
Japanese teachers not going to be pretty

00:06:02,730 --> 00:06:07,770
happy at this point so I think we can

00:06:06,450 --> 00:06:12,960
agree at this point there is something

00:06:07,770 --> 00:06:19,920
wrong with Python too so get back to my

00:06:12,960 --> 00:06:21,600
presentation so yeah - to defaults to

00:06:19,920 --> 00:06:24,350
only handling a zoo staff it really is

00:06:21,600 --> 00:06:26,490
an English native programming language

00:06:24,350 --> 00:06:27,930
sometimes it will get the non English

00:06:26,490 --> 00:06:29,670
handling right so we saw they have hand

00:06:27,930 --> 00:06:31,260
has dealt with the Japanese data quite

00:06:29,670 --> 00:06:34,590
happily we could actually get our

00:06:31,260 --> 00:06:37,920
Japanese data out using the 8 bit

00:06:34,590 --> 00:06:39,810
strings and the lookup sequence and if

00:06:37,920 --> 00:06:41,430
I'd continued on you can actually if you

00:06:39,810 --> 00:06:43,620
have a Unicode string and you explicitly

00:06:41,430 --> 00:06:49,890
encode it to utf-8 it'll do the right

00:06:43,620 --> 00:06:51,450
thing but it just gets messy like things

00:06:49,890 --> 00:06:53,550
things that you take to advantage when

00:06:51,450 --> 00:06:55,800
dealing with Python 2 in English just

00:06:53,550 --> 00:06:57,540
don't work right when you switch to

00:06:55,800 --> 00:07:05,340
another language especially Asian

00:06:57,540 --> 00:07:07,400
languages and so causes problems for

00:07:05,340 --> 00:07:09,660
data-driven analysis tools like pandas

00:07:07,400 --> 00:07:12,030
and it also causes problems when people

00:07:09,660 --> 00:07:13,770
are learning - so there's a wonderful

00:07:12,030 --> 00:07:16,110
post on Stack Overflow when they

00:07:13,770 --> 00:07:17,250
announced on the stack overflow blog

00:07:16,110 --> 00:07:19,020
when they announced the Portuguese

00:07:17,250 --> 00:07:25,310
language version of Stack Overflow and

00:07:19,020 --> 00:07:25,310
the point they were making was that the

00:07:26,240 --> 00:07:34,740
they had a lot of students in non-native

00:07:30,540 --> 00:07:37,440
in countries where English was not the

00:07:34,740 --> 00:07:39,150
native language and there was a huge

00:07:37,440 --> 00:07:40,860
barrier to entry where you had to learn

00:07:39,150 --> 00:07:43,410
English before you could start learning

00:07:40,860 --> 00:07:46,590
to program and that was a real problem

00:07:43,410 --> 00:07:51,120
and so what they wanted to change it to

00:07:46,590 --> 00:07:54,210
was in a language like Phaethon the

00:07:51,120 --> 00:07:55,890
keywords while some of them inspired by

00:07:54,210 --> 00:07:57,480
English words in practice you can learn

00:07:55,890 --> 00:07:59,070
a lot just by at reading of his magic

00:07:57,480 --> 00:08:02,669
incantations that tell the computer to

00:07:59,070 --> 00:08:04,380
do something and so quite learn when

00:08:02,669 --> 00:08:07,050
you're learning in another language

00:08:04,380 --> 00:08:09,960
now you can actually teach all of the

00:08:07,050 --> 00:08:12,590
concepts in the kids native language and

00:08:09,960 --> 00:08:17,790
just not worry about the fact that the

00:08:12,590 --> 00:08:19,980
key words are inspired by English and

00:08:17,790 --> 00:08:21,870
pythons who really doesn't do a great

00:08:19,980 --> 00:08:23,820
job of supporting that model because a

00:08:21,870 --> 00:08:26,310
lot of the times like the kids can't

00:08:23,820 --> 00:08:31,290
even use their own name as a variable

00:08:26,310 --> 00:08:35,130
and so and so if you if your demo

00:08:31,290 --> 00:08:37,289
variables are hairy Kelly and Naomi sure

00:08:35,130 --> 00:08:40,320
you're fine if you're wanting to get

00:08:37,289 --> 00:08:42,390
haruto Keiko and Nanami to use their own

00:08:40,320 --> 00:08:44,640
names you kind of have to tell them to

00:08:42,390 --> 00:08:49,440
use them in English which isn't what you

00:08:44,640 --> 00:08:53,360
want to be doing so that's not a Python

00:08:49,440 --> 00:08:56,850
problem that's a computing problem that

00:08:53,360 --> 00:09:02,970
it's one small part of a very of a much

00:08:56,850 --> 00:09:05,540
larger pattern where computers a lot of

00:09:02,970 --> 00:09:07,920
a lot of what is modern computing today

00:09:05,540 --> 00:09:12,030
was born in the english-speaking world

00:09:07,920 --> 00:09:13,170
and it reflects that heritage and one of

00:09:12,030 --> 00:09:15,270
the core principles guiding the

00:09:13,170 --> 00:09:17,310
evolution of computing has been making

00:09:15,270 --> 00:09:20,970
them better at communicating with and

00:09:17,310 --> 00:09:23,010
between humans rather than the original

00:09:20,970 --> 00:09:26,460
days where it was the humans that had to

00:09:23,010 --> 00:09:28,200
adapt to the computer however a lot of

00:09:26,460 --> 00:09:28,820
the legacy of that history is still with

00:09:28,200 --> 00:09:32,150
us today

00:09:28,820 --> 00:09:35,940
and it goes back as far as the Telegraph

00:09:32,150 --> 00:09:37,620
so some aspects of Unicode date back to

00:09:35,940 --> 00:09:41,130
the invention of Bordeaux code almost

00:09:37,620 --> 00:09:43,470
150 years ago and so Bordeaux code was a

00:09:41,130 --> 00:09:45,900
system used to send telegraph messages

00:09:43,470 --> 00:09:47,910
between teletypes and it's also the

00:09:45,900 --> 00:09:50,340
origin so teletypes are also the origin

00:09:47,910 --> 00:09:53,730
of the tty abbreviation you'll sometimes

00:09:50,340 --> 00:09:57,120
see in UNIX computers related to the

00:09:53,730 --> 00:09:59,190
screen and the keyboard and so

00:09:57,120 --> 00:10:01,980
Bordeaux's code was adopted by Western

00:09:59,190 --> 00:10:04,280
Union for the Telegraph in 1901 and

00:10:01,980 --> 00:10:06,620
standardised as the International

00:10:04,280 --> 00:10:11,040
Telecommunications alphabet number two

00:10:06,620 --> 00:10:14,130
in 1930 so that's a picture that there

00:10:11,040 --> 00:10:19,889
the entire code five bits

00:10:14,130 --> 00:10:23,310
32 32 32 characters so 32 characters

00:10:19,889 --> 00:10:25,980
wasn't enough and so ITA 2 is what's

00:10:23,310 --> 00:10:28,709
called the modal encoding where you can

00:10:25,980 --> 00:10:31,440
see the figs and the letters control

00:10:28,709 --> 00:10:33,269
characters actually shift the encoding

00:10:31,440 --> 00:10:34,800
to a different mode where you're either

00:10:33,269 --> 00:10:37,649
sending letters or you're sending

00:10:34,800 --> 00:10:39,449
figures and modal and coatings are

00:10:37,649 --> 00:10:41,040
actually problematic because if you're

00:10:39,449 --> 00:10:42,839
transmitting data in a modal encoding

00:10:41,040 --> 00:10:45,810
and the far end misses your Shift

00:10:42,839 --> 00:10:47,819
character then they're receiving

00:10:45,810 --> 00:10:53,149
nonsense until the next shift character

00:10:47,819 --> 00:10:56,130
you sent so what that ends up meaning is

00:10:53,149 --> 00:10:58,589
so this however what it does mean is you

00:10:56,130 --> 00:11:03,120
can actually transmit stuff very

00:10:58,589 --> 00:11:04,649
efficiently and so ITR 2 is actually

00:11:03,120 --> 00:11:07,170
still used today for high-frequency

00:11:04,649 --> 00:11:08,940
communications so hi Jeff radio and

00:11:07,170 --> 00:11:13,170
that's because your bandwidth is so low

00:11:08,940 --> 00:11:15,540
that the 60% overhead of going from 5

00:11:13,170 --> 00:11:18,149
bits to 8 bits per character isn't

00:11:15,540 --> 00:11:20,510
something you can afford you really do

00:11:18,149 --> 00:11:22,829
you really want to compress it that much

00:11:20,510 --> 00:11:25,199
but in terms of the history of the

00:11:22,829 --> 00:11:29,850
impact this has on unicode you can see

00:11:25,199 --> 00:11:34,019
that null line feed carriage return and

00:11:29,850 --> 00:11:36,319
the good old Bell character that makes a

00:11:34,019 --> 00:11:38,670
bell ring arrows are all already there

00:11:36,319 --> 00:11:41,160
spaced at this point was considered a

00:11:38,670 --> 00:11:44,490
control character it got turned into a

00:11:41,160 --> 00:11:46,529
letter later and there's actually

00:11:44,490 --> 00:11:48,720
another variant of this or a derivative

00:11:46,529 --> 00:11:51,540
of this that keeps the letters and

00:11:48,720 --> 00:11:55,110
figures page but it's the Russian and

00:11:51,540 --> 00:11:59,610
kl2 standard which adds a third page for

00:11:55,110 --> 00:12:01,680
Cyrillic characters however it's so very

00:11:59,610 --> 00:12:05,100
very limited character sent all

00:12:01,680 --> 00:12:06,870
uppercase no no lowercase letters so

00:12:05,100 --> 00:12:10,410
hence the telegram thing of only doing

00:12:06,870 --> 00:12:12,689
uppercase letters and we have this

00:12:10,410 --> 00:12:16,110
problem of it's a modal encoding so very

00:12:12,689 --> 00:12:20,579
very vulnerable to transmit errors so

00:12:16,110 --> 00:12:21,930
come to the early 1960s and people

00:12:20,579 --> 00:12:25,230
wanted room for more characters they

00:12:21,930 --> 00:12:28,350
wanted to do lowercase they wanted more

00:12:25,230 --> 00:12:31,200
punctuation symbols to play with and so

00:12:28,350 --> 00:12:31,950
in the 1960s we got the American

00:12:31,200 --> 00:12:35,040
Standard Code for information

00:12:31,950 --> 00:12:36,780
interchange one of the interesting

00:12:35,040 --> 00:12:39,120
things here is this was almost an 8-bit

00:12:36,780 --> 00:12:41,070
encoding because one of the neat things

00:12:39,120 --> 00:12:44,280
the 8-bit encoding would have given you

00:12:41,070 --> 00:12:48,620
is that you could fit two binary coded

00:12:44,280 --> 00:12:51,140
decimal characters in an 8-bit sequence

00:12:48,620 --> 00:12:54,180
they ended up going for seven bit

00:12:51,140 --> 00:12:55,560
because eight bits was too long and they

00:12:54,180 --> 00:12:58,410
couldn't afford the sixteen percent

00:12:55,560 --> 00:13:01,920
additional overhead of using 8 bits for

00:12:58,410 --> 00:13:03,750
every character and and again a lot of

00:13:01,920 --> 00:13:06,540
this was driven by how slow transmission

00:13:03,750 --> 00:13:08,100
channels were that it was just when your

00:13:06,540 --> 00:13:11,610
transmission channels are getting

00:13:08,100 --> 00:13:13,860
measured in tens maybe hundreds of bits

00:13:11,610 --> 00:13:18,750
per second if you're really lucky and

00:13:13,860 --> 00:13:21,450
have a really clean line bits matter and

00:13:18,750 --> 00:13:24,540
so it became seven bit and that's the

00:13:21,450 --> 00:13:29,580
full ASCII chart again 128 characters

00:13:24,540 --> 00:13:31,620
fits on the screen so you can again we

00:13:29,580 --> 00:13:33,750
can see so we can kind of see some of

00:13:31,620 --> 00:13:36,810
the ita2 control characters have carried

00:13:33,750 --> 00:13:40,170
through reflecting the geopolitics of

00:13:36,810 --> 00:13:41,970
the time the pound symbol from ita2 has

00:13:40,170 --> 00:13:46,110
been replaced by the dollar symbol in

00:13:41,970 --> 00:13:49,350
ASCII so power shift from the UK to the

00:13:46,110 --> 00:13:51,030
US there and some of the details of the

00:13:49,350 --> 00:13:53,460
layout again relate back to transmit

00:13:51,030 --> 00:13:55,080
channels so so they're related to what

00:13:53,460 --> 00:13:57,360
hyper what happens under high bit error

00:13:55,080 --> 00:14:00,480
rates and what gets confused with what

00:13:57,360 --> 00:14:01,980
when bits go wrong and then other things

00:14:00,480 --> 00:14:04,410
relate to certain kinds of

00:14:01,980 --> 00:14:06,330
categorization select shifting from

00:14:04,410 --> 00:14:08,910
uppercase to lowercase for example is a

00:14:06,330 --> 00:14:10,290
matter of flipping a single bit and that

00:14:08,910 --> 00:14:14,339
was done deliberately to make certain

00:14:10,290 --> 00:14:18,089
operations more efficient however

00:14:14,339 --> 00:14:19,470
very much English only and so we ended

00:14:18,089 --> 00:14:22,019
up with this notion of extended ASCII

00:14:19,470 --> 00:14:23,399
and people like going we're already to a

00:14:22,019 --> 00:14:26,490
point where computers are tending to use

00:14:23,399 --> 00:14:28,860
8 bits and so people have gone right

00:14:26,490 --> 00:14:30,779
what do we use that extract that extra

00:14:28,860 --> 00:14:32,970
bit for and say well we'll use it to

00:14:30,779 --> 00:14:35,790
indicate that we're using the other

00:14:32,970 --> 00:14:39,059
hundred and twenty eight characters and

00:14:35,790 --> 00:14:41,249
so what happened here was people went

00:14:39,059 --> 00:14:43,860
okay well we'll use it to teach the

00:14:41,249 --> 00:14:46,050
computer additional languages and so

00:14:43,860 --> 00:14:47,579
they used those action 128 characters to

00:14:46,050 --> 00:14:49,470
add in things like secret Cyrillic

00:14:47,579 --> 00:14:52,860
characters more of the letters from the

00:14:49,470 --> 00:14:54,829
Latin alphabet different currency

00:14:52,860 --> 00:14:57,509
symbols for different parts of the world

00:14:54,829 --> 00:15:00,540
and so this actually worked pretty well

00:14:57,509 --> 00:15:04,529
for European languages and Cyrillic

00:15:00,540 --> 00:15:06,420
languages didn't work at all full Asian

00:15:04,529 --> 00:15:08,220
Asian languages and

00:15:06,420 --> 00:15:10,860
Africa wasn't even on the computing

00:15:08,220 --> 00:15:12,120
world radar yeah there's dealing with

00:15:10,860 --> 00:15:15,509
African language it just wasn't a

00:15:12,120 --> 00:15:18,240
problem people were considering and so

00:15:15,509 --> 00:15:20,160
we end up with a whole lot of different

00:15:18,240 --> 00:15:23,120
codecs and if you want to look for a

00:15:20,160 --> 00:15:26,370
popular ascii incompatible codecs

00:15:23,120 --> 00:15:31,949
you can look to Asia and so things like

00:15:26,370 --> 00:15:35,579
shift-jis being 5 iso 20 22 so here

00:15:31,949 --> 00:15:38,370
shook Chang's CJK codec pack was

00:15:35,579 --> 00:15:42,300
actually added to Python 2 4 back in

00:15:38,370 --> 00:15:43,589
2005 and with the addition of that and

00:15:42,300 --> 00:15:45,899
various other codecs that have been

00:15:43,589 --> 00:15:48,290
added over the years the Python standard

00:15:45,899 --> 00:15:51,629
library now supports over a hundred

00:15:48,290 --> 00:15:54,240
different language codecs so problem

00:15:51,629 --> 00:15:54,990
solved right got codecs people can use

00:15:54,240 --> 00:15:58,860
all these different languages

00:15:54,990 --> 00:16:01,620
everything's fine know what codecs

00:15:58,860 --> 00:16:04,259
basically give us is they give us the

00:16:01,620 --> 00:16:05,899
ability to make computers bilingual and

00:16:04,259 --> 00:16:09,240
so the computers can speak English and

00:16:05,899 --> 00:16:12,480
they can speak whatever language the

00:16:09,240 --> 00:16:15,509
primary owners at that computer use and

00:16:12,480 --> 00:16:17,910
that's great if computers never talk to

00:16:15,509 --> 00:16:20,579
each other and if we never transfer

00:16:17,910 --> 00:16:23,179
files between computers why would

00:16:20,579 --> 00:16:25,529
anybody ever want to do either of those

00:16:23,179 --> 00:16:28,050
so yeah so networked computers

00:16:25,529 --> 00:16:29,790
completely mess up this model for

00:16:28,050 --> 00:16:32,730
portable media completely mess up this

00:16:29,790 --> 00:16:34,980
model and the other thing is even within

00:16:32,730 --> 00:16:37,260
a computer it causes serious problems

00:16:34,980 --> 00:16:40,860
for translating between languages so you

00:16:37,260 --> 00:16:42,720
and similar tasks so you can if your

00:16:40,860 --> 00:16:45,120
task is translate between English and

00:16:42,720 --> 00:16:47,279
language X or between language and

00:16:45,120 --> 00:16:49,500
English sure bilingual computer can

00:16:47,279 --> 00:16:53,420
handle that but if you want to go from

00:16:49,500 --> 00:17:01,250
say directly from German to Japanese

00:16:53,420 --> 00:17:04,709
Japanese to Chinese something written in

00:17:01,250 --> 00:17:07,050
one of one of the index scripts of

00:17:04,709 --> 00:17:09,270
Translate translation within India I

00:17:07,050 --> 00:17:12,449
don't know how many scripts there that I

00:17:09,270 --> 00:17:15,300
have but the the number of languages is

00:17:12,449 --> 00:17:19,470
have enough to count so yeah so

00:17:15,300 --> 00:17:23,220
bilingual computing was useful in terms

00:17:19,470 --> 00:17:26,520
of making computers useful to people but

00:17:23,220 --> 00:17:28,319
really wasn't good enough and so what we

00:17:26,520 --> 00:17:31,140
really wanted was multilingual computing

00:17:28,319 --> 00:17:33,419
where we could deal with any language at

00:17:31,140 --> 00:17:36,750
any time or more accurately all the

00:17:33,419 --> 00:17:38,460
languages all the time and so a way of

00:17:36,750 --> 00:17:41,130
representing any human language in the

00:17:38,460 --> 00:17:42,570
world but we also needed a transition

00:17:41,130 --> 00:17:48,650
plan from the existing ascii-based

00:17:42,570 --> 00:17:51,990
infrastructure and so we come to Unicode

00:17:48,650 --> 00:17:54,900
so Unicode was invented in the early 90s

00:17:51,990 --> 00:17:56,669
by engineers from Apple and Xerox so if

00:17:54,900 --> 00:17:59,220
you think the Python 3 transition is

00:17:56,669 --> 00:18:02,400
taking a long time try working on

00:17:59,220 --> 00:18:05,700
Unicode and the initial attempt at

00:18:02,400 --> 00:18:08,429
defining this was 16-bit only and the

00:18:05,700 --> 00:18:12,780
the trick they'd done to try and get

00:18:08,429 --> 00:18:17,179
things to fit into 16 bits was that they

00:18:12,780 --> 00:18:23,010
left out a lot of the old and unused

00:18:17,179 --> 00:18:25,730
kanji and Han characters problem things

00:18:23,010 --> 00:18:29,340
have had names for a very very long time

00:18:25,730 --> 00:18:32,880
so these old and unused kanji and Han

00:18:29,340 --> 00:18:36,179
characters were used a lot in proper

00:18:32,880 --> 00:18:40,980
nouns so people's names family names

00:18:36,179 --> 00:18:46,020
cities towns you name it those were used

00:18:40,980 --> 00:18:49,799
somewhere and so pretty pretty soon as

00:18:46,020 --> 00:18:53,250
as soon as the engineers put this idea

00:18:49,799 --> 00:18:54,929
forward it didn't take long for from

00:18:53,250 --> 00:18:56,640
from after the formation of the Unicode

00:18:54,929 --> 00:18:59,970
consortium to that for them to realize

00:18:56,640 --> 00:19:03,780
16 bits aren't enough for everybody and

00:18:59,970 --> 00:19:06,059
so current Unicode is expanded out to 21

00:19:03,780 --> 00:19:08,370
bits so currently it looks like 21 bits

00:19:06,059 --> 00:19:14,250
is enough for everybody including all of

00:19:08,370 --> 00:19:16,260
the Japanese telcos emoji systems so but

00:19:14,250 --> 00:19:22,049
yeah so problem solved now right like

00:19:16,260 --> 00:19:24,390
one codec to rule them all so so I'm

00:19:22,049 --> 00:19:26,730
gonna completely ignore the geopolitics

00:19:24,390 --> 00:19:30,000
of the fact that there are some

00:19:26,730 --> 00:19:33,809
additional the there are some additional

00:19:30,000 --> 00:19:36,090
codecs primarily used in China we'll

00:19:33,809 --> 00:19:40,020
just leave in our happy unicode only

00:19:36,090 --> 00:19:43,679
world for the moment but even even

00:19:40,020 --> 00:19:47,669
within the unicode world there's there's

00:19:43,679 --> 00:19:51,870
still three codecs of interest and it

00:19:47,669 --> 00:19:53,370
turns out that choosing between choosing

00:19:51,870 --> 00:19:54,809
your in memory your on disk and your

00:19:53,370 --> 00:19:58,260
wire protocol encodings has lots of

00:19:54,809 --> 00:20:00,419
interesting trade-offs and the three

00:19:58,260 --> 00:20:03,679
major codecs have emerged to deal with

00:20:00,419 --> 00:20:10,500
those different cases so utf-8 utf-16 la

00:20:03,679 --> 00:20:12,030
utf-32 the big selling point of utf-8 is

00:20:10,500 --> 00:20:14,580
it's the only one of the three which is

00:20:12,030 --> 00:20:16,710
asking compatible and so there's a whole

00:20:14,580 --> 00:20:19,340
bunch of you a whole bunch of interfaces

00:20:16,710 --> 00:20:21,840
we're asking compatibility is mandatory

00:20:19,340 --> 00:20:23,880
that you will just break too much stuff

00:20:21,840 --> 00:20:27,299
if you use an ASCII incompatible

00:20:23,880 --> 00:20:29,580
encoding and so asking compatibility

00:20:27,299 --> 00:20:33,530
basically means any code point that is

00:20:29,580 --> 00:20:36,480
shared with ASCII looks the same in

00:20:33,530 --> 00:20:40,590
utf-8 so those original 7-bit ascii

00:20:36,480 --> 00:20:43,440
encoding is identical in utf-8 and the

00:20:40,590 --> 00:20:45,419
key advantage and said is that it means

00:20:43,440 --> 00:20:47,400
that if you have protocols which are

00:20:45,419 --> 00:20:48,809
breaking on ascii characters and where

00:20:47,400 --> 00:20:51,659
the ascii characters are semantically

00:20:48,809 --> 00:20:54,279
significant you can often flip those to

00:20:51,659 --> 00:20:57,219
utf-8 and

00:20:54,279 --> 00:20:59,799
the the new utf-8 characters will just

00:20:57,219 --> 00:21:01,659
pass through just fine and so this is

00:20:59,799 --> 00:21:04,119
most obvious and things like POSIX file

00:21:01,659 --> 00:21:06,909
system and codings a lot of network

00:21:04,119 --> 00:21:09,129
protocols HTTP SMTP that kind of thing

00:21:06,909 --> 00:21:11,889
they can often switch to you switch to

00:21:09,129 --> 00:21:15,820
utf-8 from ASCII and things will just

00:21:11,889 --> 00:21:19,059
work and the other thing is that this is

00:21:15,820 --> 00:21:21,009
also a very efficient protocol for ASCII

00:21:19,059 --> 00:21:23,440
heavy protocols which is again a lot of

00:21:21,009 --> 00:21:25,090
those Network encodings and so this

00:21:23,440 --> 00:21:29,019
became the most popular encoding for

00:21:25,090 --> 00:21:30,460
public HTML sites in 2008 preferred

00:21:29,019 --> 00:21:33,429
local encoding on POSIX systems

00:21:30,460 --> 00:21:37,979
including OSX and in the mobile world we

00:21:33,429 --> 00:21:42,899
see it in iOS and native mode in android

00:21:37,979 --> 00:21:45,450
so utf-16 le its main feature is

00:21:42,899 --> 00:21:48,399
optimizing the basic multilingual plane

00:21:45,450 --> 00:21:51,399
so the original 16-bit o unicode is

00:21:48,399 --> 00:21:53,320
called that's that's its name now and

00:21:51,399 --> 00:21:54,999
includes almost all commonly used

00:21:53,320 --> 00:21:59,169
characters in modern languages place

00:21:54,999 --> 00:22:00,999
names aside emoji aside and so it uses

00:21:59,169 --> 00:22:03,969
two bytes for the basic multilingual

00:22:00,999 --> 00:22:06,429
plane for backs for everything else and

00:22:03,969 --> 00:22:08,739
so it can be more efficient than utf-8

00:22:06,429 --> 00:22:10,509
for non English text so if you're

00:22:08,739 --> 00:22:12,879
dealing with primarily Japanese text

00:22:10,509 --> 00:22:16,469
primarily Chinese text this will

00:22:12,879 --> 00:22:19,869
actually use less memory than utf-8 will

00:22:16,469 --> 00:22:21,639
depending on the details and so it's the

00:22:19,869 --> 00:22:27,519
preferred local encoding on Windows the

00:22:21,639 --> 00:22:30,820
net-net CLR and the JVM oddly enough so

00:22:27,519 --> 00:22:33,269
the wide windows API is oddly enough

00:22:30,820 --> 00:22:35,979
these are all API is invented after 1991

00:22:33,269 --> 00:22:39,279
and it's also seen in the dalvik cannot

00:22:35,979 --> 00:22:44,379
run times on Android and then the final

00:22:39,279 --> 00:22:46,719
one that's widely used is utf-32 and so

00:22:44,379 --> 00:22:48,969
the thing about utf-32 computers are

00:22:46,719 --> 00:22:50,769
still really really good at processing

00:22:48,969 --> 00:22:52,809
regular arrays where every unit of data

00:22:50,769 --> 00:22:55,599
is the same size

00:22:52,809 --> 00:22:57,339
both utf-8 and utf-16 le are

00:22:55,599 --> 00:22:59,919
variable-width encoding some of the code

00:22:57,339 --> 00:23:03,070
points take more space and so you don't

00:22:59,919 --> 00:23:04,930
get simple or a data route and so

00:23:03,070 --> 00:23:07,360
instead you have to work with those as

00:23:04,930 --> 00:23:09,310
if their file like streams and so you

00:23:07,360 --> 00:23:11,830
have curses and pointers into your data

00:23:09,310 --> 00:23:14,020
array you have mappings to figure out

00:23:11,830 --> 00:23:15,850
where your code point boundaries are and

00:23:14,020 --> 00:23:19,990
if you split in the middle of the code

00:23:15,850 --> 00:23:22,900
point weird things can happen as anybody

00:23:19,990 --> 00:23:26,710
who's ever stored a utf-8 encoded string

00:23:22,900 --> 00:23:28,600
in MySQL can likely attest to it so

00:23:26,710 --> 00:23:30,190
anyway and so the problem one of the

00:23:28,600 --> 00:23:32,710
problem with this is simple array

00:23:30,190 --> 00:23:34,990
oriented algorithms become error-prone

00:23:32,710 --> 00:23:38,500
and you can see this if you ever use

00:23:34,990 --> 00:23:41,020
Python to in narrow mode which we do by

00:23:38,500 --> 00:23:43,720
default on Windows in Python - there's

00:23:41,020 --> 00:23:46,270
certain strings if you try and work with

00:23:43,720 --> 00:23:49,510
unicode data that goes beyond the basic

00:23:46,270 --> 00:23:51,310
multilingual plane we will actually get

00:23:49,510 --> 00:23:54,490
it wrong and that's true for a lot of

00:23:51,310 --> 00:23:56,440
other windows and java code

00:23:54,490 --> 00:24:02,070
however the nice and so the nice thing

00:23:56,440 --> 00:24:04,630
about utf-32 is that it lets you use the

00:24:02,070 --> 00:24:06,310
simple array oriented processing

00:24:04,630 --> 00:24:08,380
algorithms that were designed for binary

00:24:06,310 --> 00:24:10,690
data and you can apply them to text as

00:24:08,380 --> 00:24:12,700
well and this is what we do in C Python

00:24:10,690 --> 00:24:15,610
the reference interpreter to share

00:24:12,700 --> 00:24:18,520
algorithms between binary 8-bit binary

00:24:15,610 --> 00:24:20,350
data and text data we make sure that we

00:24:18,520 --> 00:24:23,500
store the text data in a fixed width

00:24:20,350 --> 00:24:29,530
format which worst case goes out to

00:24:23,500 --> 00:24:32,770
utf-32 so after all that so all of that

00:24:29,530 --> 00:24:39,430
messy history where did Python 3 get us

00:24:32,770 --> 00:24:46,840
- so let's get back to our so let's get

00:24:39,430 --> 00:24:49,650
out of - to drop into Python 3 so grab

00:24:46,840 --> 00:24:49,650
pandas again

00:24:53,110 --> 00:25:03,360
so let's skip over the English and

00:24:57,880 --> 00:25:03,360
rubber GData go straight to the Japanese

00:25:20,050 --> 00:25:23,910
so are you getting away getting Japanese

00:25:32,170 --> 00:25:37,780
have our data and this time

00:25:40,260 --> 00:25:46,460
so we can read out column we can read

00:25:51,170 --> 00:25:58,250
we can read it at that and if we're

00:25:55,400 --> 00:25:58,910
still using au prefix we can read that

00:25:58,250 --> 00:26:02,780
out as well

00:25:58,910 --> 00:26:04,610
and so in Python 3 it just works we had

00:26:02,780 --> 00:26:19,960
to completely retool the text model of

00:26:04,610 --> 00:26:19,960
the language but it just works so yeah

00:26:24,410 --> 00:26:30,890
okay so yeah so we actually fixed the

00:26:27,740 --> 00:26:32,180
problem getting actually people through

00:26:30,890 --> 00:26:33,170
the new version of language with the

00:26:32,180 --> 00:26:36,680
problem fixed there's still an

00:26:33,170 --> 00:26:41,090
interesting challenge but that's not

00:26:36,680 --> 00:26:42,500
what today's talk about so yes so user

00:26:41,090 --> 00:26:44,420
space processing is actually a pretty

00:26:42,500 --> 00:26:46,400
good place one of the interesting

00:26:44,420 --> 00:26:49,160
challenges we had in designing Python 3

00:26:46,400 --> 00:26:50,840
was figuring out which of the 8-bit

00:26:49,160 --> 00:26:54,890
string operations were text-only

00:26:50,840 --> 00:26:58,430
and which only made sense for which also

00:26:54,890 --> 00:26:59,900
made sense for binary data one of the

00:26:58,430 --> 00:27:01,310
interesting decision one of the more

00:26:59,900 --> 00:27:03,230
controversial decisions we made there

00:27:01,310 --> 00:27:03,920
was deciding that all interpolation

00:27:03,230 --> 00:27:07,880
operations

00:27:03,920 --> 00:27:10,370
so both dot format and printf style mod

00:27:07,880 --> 00:27:13,280
formatting deciding both of those were

00:27:10,370 --> 00:27:15,170
text only after several years of

00:27:13,280 --> 00:27:17,390
experience we've basically come to we've

00:27:15,170 --> 00:27:21,140
come to the conclusion that while that

00:27:17,390 --> 00:27:23,240
was correct for dot format for the

00:27:21,140 --> 00:27:24,740
printf style mod formatting that's

00:27:23,240 --> 00:27:27,050
actually really really useful in the

00:27:24,740 --> 00:27:29,840
binary domain as well and so one of the

00:27:27,050 --> 00:27:33,380
features in Python 35 is bringing back

00:27:29,840 --> 00:27:35,600
binary interpolation so bytes objects in

00:27:33,380 --> 00:27:37,660
Python 3 have a mod operator that

00:27:35,600 --> 00:27:40,280
basically works very very similarly to

00:27:37,660 --> 00:27:43,970
8-bit string interpolation in Python 2

00:27:40,280 --> 00:27:45,680
and that was that was one of the keys

00:27:43,970 --> 00:27:47,150
for the twisted and mercurial folks who

00:27:45,680 --> 00:27:52,850
spent a lot of time with him in the last

00:27:47,150 --> 00:27:54,740
couple years so yeah so that's the

00:27:52,850 --> 00:27:56,720
bringing in binary interpolation back is

00:27:54,740 --> 00:27:58,750
a big thing for the code that's dealing

00:27:56,720 --> 00:28:07,090
with network protocols and file system

00:27:58,750 --> 00:28:07,090
file system formats so how much time oh

00:28:07,150 --> 00:28:11,660
okay

00:28:09,310 --> 00:28:13,880
are there any questions yeah we'll go

00:28:11,660 --> 00:28:17,290
with questions come up here the

00:28:13,880 --> 00:28:17,290
microphone and feed it in

00:28:19,290 --> 00:28:26,070
oh okay I'll do the system boundary

00:28:21,720 --> 00:28:27,390
stuff then so yeah so user space is in

00:28:26,070 --> 00:28:31,470
pretty good place we're bringing a

00:28:27,390 --> 00:28:33,000
binary interpolation back the most of

00:28:31,470 --> 00:28:35,040
the interesting challenges that remain

00:28:33,000 --> 00:28:39,210
is still around bound system boundaries

00:28:35,040 --> 00:28:41,990
and interfaces with other libraries so

00:28:39,210 --> 00:28:45,090
Mac OSX as you'd hope with Apple being

00:28:41,990 --> 00:28:47,030
co-inventors of Unicode and the only

00:28:45,090 --> 00:28:50,580
inventors still around

00:28:47,030 --> 00:28:52,620
they you Mac OSX is actually in a pretty

00:28:50,580 --> 00:28:54,270
good place and it's because they just

00:28:52,620 --> 00:28:56,970
made UTF mandatory several years ago

00:28:54,270 --> 00:29:00,180
they said look utf-8 is it don't use

00:28:56,970 --> 00:29:02,580
anything else and the nice thing this

00:29:00,180 --> 00:29:04,860
let us do is we just hard code in C

00:29:02,580 --> 00:29:08,580
Python that if we are on a Mac we assume

00:29:04,860 --> 00:29:10,110
the system encoding is utf-8 I think

00:29:08,580 --> 00:29:12,300
there are still some quirky issues

00:29:10,110 --> 00:29:15,420
around some of the graphics libraries

00:29:12,300 --> 00:29:17,580
especially TK into but aside from that

00:29:15,420 --> 00:29:20,970
this is max are in pretty much the best

00:29:17,580 --> 00:29:22,920
place of them all with Apple being being

00:29:20,970 --> 00:29:26,580
one of the big drivers of Unicode that's

00:29:22,920 --> 00:29:28,710
kind of as you'd hope it would be so

00:29:26,580 --> 00:29:31,440
Windows so Windows took an interesting

00:29:28,710 --> 00:29:32,940
path in there Unicode adoption which is

00:29:31,440 --> 00:29:35,760
they brought in a completely new

00:29:32,940 --> 00:29:39,540
parallel set of API s so if you are

00:29:35,760 --> 00:29:41,280
still using the old NB CSAP is your

00:29:39,540 --> 00:29:45,450
stuff does not handle unicode correctly

00:29:41,280 --> 00:29:49,050
end of story c python has mostly

00:29:45,450 --> 00:29:51,710
switched to the the unicode compatible

00:29:49,050 --> 00:29:53,820
api's and so most things work

00:29:51,710 --> 00:29:56,760
unfortunately one of the things that we

00:29:53,820 --> 00:29:59,190
haven't switched yet is our console

00:29:56,760 --> 00:30:01,560
handling so the interactive prompt and

00:29:59,190 --> 00:30:05,120
various aspects of that there's a pipe I

00:30:01,560 --> 00:30:08,160
project called win Unicode console which

00:30:05,120 --> 00:30:10,620
deals with a lot of that and their

00:30:08,160 --> 00:30:12,200
readme actually explains a bunch of the

00:30:10,620 --> 00:30:15,420
things that don't work under the hood

00:30:12,200 --> 00:30:16,830
and then we can also occasionally run

00:30:15,420 --> 00:30:19,710
into problems with bundled libraries

00:30:16,830 --> 00:30:21,360
like open SSL which which they're

00:30:19,710 --> 00:30:25,020
written for the POSIX world where they

00:30:21,360 --> 00:30:26,580
assume utf-8 for everything which isn't

00:30:25,020 --> 00:30:29,430
necessarily the way we're dealing with

00:30:26,580 --> 00:30:31,230
them so yeah windows in pretty good

00:30:29,430 --> 00:30:33,090
place but you'll still find some rough

00:30:31,230 --> 00:30:36,480
edges

00:30:33,090 --> 00:30:38,070
and then in on Linux and other POSIX

00:30:36,480 --> 00:30:40,200
platforms one of the interesting

00:30:38,070 --> 00:30:42,360
problems here is that they don't have a

00:30:40,200 --> 00:30:44,250
central entity like Apple that can say

00:30:42,360 --> 00:30:47,520
write utf-8 is it you're not allowed to

00:30:44,250 --> 00:30:50,460
use anything else anymore and so there

00:30:47,520 --> 00:30:55,260
we have to try and figure out from the

00:30:50,460 --> 00:30:57,840
OS what the system encoding is if the OS

00:30:55,260 --> 00:31:00,270
gives us correct data everything is

00:30:57,840 --> 00:31:01,919
pretty much fine and dandy if the OS

00:31:00,270 --> 00:31:06,480
tells us the wrong thing then we will

00:31:01,919 --> 00:31:11,059
believe it and this does not end well

00:31:06,480 --> 00:31:14,010
so system D sets it reliably upstart and

00:31:11,059 --> 00:31:16,440
others can sometimes get it wrong for

00:31:14,010 --> 00:31:18,570
cron jobs and service daemons and

00:31:16,440 --> 00:31:22,950
they'll tell us to use the default POSIX

00:31:18,570 --> 00:31:25,320
mode also known as Lang equals C this

00:31:22,950 --> 00:31:30,480
was designed in the 1960s and assumes

00:31:25,320 --> 00:31:33,840
you'd want to use ASCII so if you're yes

00:31:30,480 --> 00:31:35,280
so it just if we end up in a situation

00:31:33,840 --> 00:31:37,590
where we're falling back to the POSIX

00:31:35,280 --> 00:31:39,660
default we get it wrong so we've got

00:31:37,590 --> 00:31:41,940
some stuff in 3:5 where you try and

00:31:39,660 --> 00:31:43,620
mitigate that a bit better but it's

00:31:41,940 --> 00:31:45,990
still a fundamentally the OS is telling

00:31:43,620 --> 00:31:48,270
us the wrong thing and while we may be a

00:31:45,990 --> 00:31:51,840
bit more skeptical now we still

00:31:48,270 --> 00:31:54,919
fundamentally believe it and the reason

00:31:51,840 --> 00:31:58,290
for that is that G Lib C will believe it

00:31:54,919 --> 00:32:00,059
and us disagreeing with G Lib C about

00:31:58,290 --> 00:32:01,500
what the encoding is is actually an even

00:32:00,059 --> 00:32:06,120
bigger problem than us disagreeing with

00:32:01,500 --> 00:32:09,720
the OS so so yeah so earlier versions of

00:32:06,120 --> 00:32:11,220
Python 3 did try disagreeing we

00:32:09,720 --> 00:32:14,309
eventually went no no we just have to go

00:32:11,220 --> 00:32:17,820
with whatever G Lipsy thinks we're still

00:32:14,309 --> 00:32:21,179
working on getting C utf-8 locale into

00:32:17,820 --> 00:32:24,059
upstream G Lib C by default once that

00:32:21,179 --> 00:32:26,370
happens then there'll be a much easier

00:32:24,059 --> 00:32:29,210
option where we'll potentially fall back

00:32:26,370 --> 00:32:34,590
to see utf-8

00:32:29,210 --> 00:32:35,750
so yeah we're out of time thank you very

00:32:34,590 --> 00:32:37,810
much Nick

00:32:35,750 --> 00:32:37,810
you

00:32:45,980 --> 00:32:48,040

YouTube URL: https://www.youtube.com/watch?v=TeZZ9q8pqjQ


