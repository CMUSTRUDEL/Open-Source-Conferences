Title: Test-Driven Repair by Christopher Neugebauer
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	“it is impossible BY DEFINITION to do Test-Driven Development after the code is written.” — Tim Ottinger, author of ‘Clean Code’, on Twitter [1].

Automated testing is one of the most important tools in the modern programming toolbox: good tests help you find regressions early, and help you make sure your code is right before it ships. Test-driven development is a great way to make sure your software is up to specification before you start work. Even better, it makes sure your software’s architecture is amenable to writing tests from day 1.

So what happens when you find yourself working on code where automated testing took a back seat to being shipped? Chances are you’ll have a sea of bugs, strung together in a structure where writing simple unit tests just isn’t going to happen.

Broken code is a support burden, and if it’s in production, you’ve got no choice but to make things work. Luckily, automated testing isn’t a lost cause here!

In this talk, we’ll look at how to approach automated testing on late-stage, or even production code… or in any situation when you don’t have the luxury of starting with a test-driven structure. We’ll look at techniques that I’ve used to analyse faults in existing code, and how to translate those into tests, and how to use that to fix bugs.

In particular, we’ll look at:

- Tooling and metrics to help you decide what code to test, and how to measure progress when you’re writing tests
- Approaches to constructing test cases for old code, including using data-driven approaches, and approaches based on requirements specifications
- Granularity — making tests on old code granular enough is difficult, so we’ll look at the trade-offs between unit and integration tests on old code, and ways to make integration-level tests granular enough to make results reliable

We’ll see that testing old code is both achievable, and actually a worthwhile exercise. You’ll find bugs. You’ll increase quality. You’ll make your code more maintainable! Do try it!

[1] https://twitter.com/tottinge/status/544632253205475329


PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:11,440 --> 00:00:17,630
alright welcome back so next speaker is

00:00:14,930 --> 00:00:19,460
Chris Neugebauer he is an Android

00:00:17,630 --> 00:00:21,560
developer and board member of Linux

00:00:19,460 --> 00:00:27,050
Australia and talk is called test-driven

00:00:21,560 --> 00:00:29,689
repair please welcome him thank you

00:00:27,050 --> 00:00:31,279
thank you for the introduction yeah my

00:00:29,689 --> 00:00:33,829
name is Chris I've hidden my twitter

00:00:31,279 --> 00:00:35,990
handle on the slide there you may feel

00:00:33,829 --> 00:00:38,450
free to help on me or or tell me where

00:00:35,990 --> 00:00:42,620
I'm wrong online i will try not to

00:00:38,450 --> 00:00:46,010
respond to you during the talk so i'm

00:00:42,620 --> 00:00:49,610
here to talk to you today about what

00:00:46,010 --> 00:00:52,610
happens when you forget to write tests

00:00:49,610 --> 00:00:54,290
on your on your code and that's that's

00:00:52,610 --> 00:00:56,210
possibly putting it kind of politely

00:00:54,290 --> 00:00:58,280
it's when you completely do not write

00:00:56,210 --> 00:01:01,820
tests on your code and then you suddenly

00:00:58,280 --> 00:01:03,830
discover at some point later on during

00:01:01,820 --> 00:01:05,810
the the development of your project

00:01:03,830 --> 00:01:08,180
potentially when your code is hit prod

00:01:05,810 --> 00:01:13,970
that you actually needed to write tests

00:01:08,180 --> 00:01:15,740
at some point so for those of you who

00:01:13,970 --> 00:01:18,799
don't know my my professional background

00:01:15,740 --> 00:01:23,570
I end up hitting quite a lot of

00:01:18,799 --> 00:01:26,659
different types of technologies I was

00:01:23,570 --> 00:01:29,179
assigned to hit a three thousand line

00:01:26,659 --> 00:01:31,700
piece of enterprise Java code that I'd

00:01:29,179 --> 00:01:35,539
never read before last October or

00:01:31,700 --> 00:01:38,390
thereabouts-- and it was a bit lacking

00:01:35,539 --> 00:01:40,249
in the in the testing Department and

00:01:38,390 --> 00:01:43,009
that's when I wrote this abstract I was

00:01:40,249 --> 00:01:47,060
maybe six months ago at this point and I

00:01:43,009 --> 00:01:50,450
thought I had good ideas about about how

00:01:47,060 --> 00:01:55,039
to to get through solutions like solving

00:01:50,450 --> 00:01:56,600
problems like this basically when I

00:01:55,039 --> 00:01:58,670
write abstracts I do it because I'm

00:01:56,600 --> 00:02:00,259
confident that what I was doing when I

00:01:58,670 --> 00:02:01,880
wrote the abstract was right you know I

00:02:00,259 --> 00:02:05,959
had a bit of an ego i think i can tell

00:02:01,880 --> 00:02:09,350
you exactly what to do in the six months

00:02:05,959 --> 00:02:11,030
since then I've realized that everything

00:02:09,350 --> 00:02:12,650
I thought was generally useful knowledge

00:02:11,030 --> 00:02:14,780
when I wrote the abstract was actually

00:02:12,650 --> 00:02:16,400
kind of wrong so this talk is going to

00:02:14,780 --> 00:02:17,959
be a bit more philosophical than the

00:02:16,400 --> 00:02:20,450
abstract might have implied but

00:02:17,959 --> 00:02:22,500
hopefully this talk ends up still being

00:02:20,450 --> 00:02:25,480
useful

00:02:22,500 --> 00:02:28,720
so I ask this question incidentally

00:02:25,480 --> 00:02:32,440
during the the talk i did yesterday who

00:02:28,720 --> 00:02:34,420
here actually unit tests their code okay

00:02:32,440 --> 00:02:35,620
and most of us will pretend to unit test

00:02:34,420 --> 00:02:37,630
our code because it's kind of

00:02:35,620 --> 00:02:41,140
embarrassing when we're in a room full

00:02:37,630 --> 00:02:43,690
of people who love testing to say that

00:02:41,140 --> 00:02:46,600
you're not unit testing because there is

00:02:43,690 --> 00:02:50,310
this culture around testing that assumes

00:02:46,600 --> 00:02:52,239
that absolutely everybody writes tests

00:02:50,310 --> 00:02:54,250
there are there are well known

00:02:52,239 --> 00:02:56,830
techniques for making your code more

00:02:54,250 --> 00:03:00,010
testable for putting test your code

00:02:56,830 --> 00:03:02,080
under tests and people who love testing

00:03:00,010 --> 00:03:03,580
will spurt self-evident truths that they

00:03:02,080 --> 00:03:05,560
use to make themselves feel good about

00:03:03,580 --> 00:03:07,120
themselves when writing these tests I'm

00:03:05,560 --> 00:03:08,739
going to include some cat pictures in

00:03:07,120 --> 00:03:10,120
the next slide so you can feel the sort

00:03:08,739 --> 00:03:13,269
of things that testing people want you

00:03:10,120 --> 00:03:15,310
to feel when you see these statements so

00:03:13,269 --> 00:03:17,319
for example you should you should always

00:03:15,310 --> 00:03:19,180
make sure that your tests don't write to

00:03:17,319 --> 00:03:20,950
databases because that means you need to

00:03:19,180 --> 00:03:25,120
set up new databases with every single

00:03:20,950 --> 00:03:27,549
test run you do and that's slow I know

00:03:25,120 --> 00:03:30,820
your test should avoid IO at all costs

00:03:27,549 --> 00:03:32,620
because doing IO is terrible and it

00:03:30,820 --> 00:03:35,829
makes your test flaky and non-repeatable

00:03:32,620 --> 00:03:38,380
so don't do i oh and your test should be

00:03:35,829 --> 00:03:42,519
really fast so you can run them over and

00:03:38,380 --> 00:03:44,829
over and over again now each of these

00:03:42,519 --> 00:03:46,810
generalizations assumes that the way you

00:03:44,829 --> 00:03:48,519
have structure your code base will

00:03:46,810 --> 00:03:52,570
enable you to write tests that have

00:03:48,519 --> 00:03:54,459
those properties now if you don't write

00:03:52,570 --> 00:03:56,019
tests and you see all of these things

00:03:54,459 --> 00:03:58,150
and you realize you can't implement

00:03:56,019 --> 00:04:00,130
tests that have these properties most

00:03:58,150 --> 00:04:03,459
people don't go oh I'll write tests

00:04:00,130 --> 00:04:05,230
anyway people just don't write tests and

00:04:03,459 --> 00:04:08,769
they'll take it as an excuse to never go

00:04:05,230 --> 00:04:10,329
on write tests and you know people will

00:04:08,769 --> 00:04:14,819
say that you know things like this your

00:04:10,329 --> 00:04:14,819
code is untestable or your code is

00:04:16,870 --> 00:04:22,820
basically people get motivated to keep

00:04:19,820 --> 00:04:25,190
not writing tests rather than attempting

00:04:22,820 --> 00:04:27,200
to actually test things and the point I

00:04:25,190 --> 00:04:30,020
want to make today is that if you have

00:04:27,200 --> 00:04:32,600
any code that can be run at all there is

00:04:30,020 --> 00:04:34,460
a way to write tests for it the test

00:04:32,600 --> 00:04:36,470
that you're right might not be ideal at

00:04:34,460 --> 00:04:38,780
all but they are still tests they can

00:04:36,470 --> 00:04:43,220
help you verify and improve your code

00:04:38,780 --> 00:04:46,760
and that tests do not need to be perfect

00:04:43,220 --> 00:04:48,740
to be useful writing tests for code that

00:04:46,760 --> 00:04:50,540
wasn't designed to be testable will

00:04:48,740 --> 00:04:53,690
never resemble what people consider to

00:04:50,540 --> 00:04:56,570
be good tests but i hope that i can turn

00:04:53,690 --> 00:04:58,550
at least in part to you that you can

00:04:56,570 --> 00:05:00,790
write bad tests it will help you improve

00:04:58,550 --> 00:05:03,470
your code it will help you to fix bugs

00:05:00,790 --> 00:05:05,780
and if you're a testing enthusiast some

00:05:03,470 --> 00:05:10,040
of the things I talk about today I will

00:05:05,780 --> 00:05:12,050
make you feel very upset get over it so

00:05:10,040 --> 00:05:14,510
how do we make this code that people

00:05:12,050 --> 00:05:16,280
call testable well one popular way to do

00:05:14,510 --> 00:05:18,290
it is this test driven development thing

00:05:16,280 --> 00:05:20,300
it's kind of popular at the moment it

00:05:18,290 --> 00:05:22,250
normally results in pretty good quite

00:05:20,300 --> 00:05:25,400
testable code that has those properties

00:05:22,250 --> 00:05:27,590
i was discussing earlier and basically

00:05:25,400 --> 00:05:29,630
test-driven development it's it's all

00:05:27,590 --> 00:05:32,810
about doing the bare minimum amount of

00:05:29,630 --> 00:05:34,490
work to make your tests pass if your

00:05:32,810 --> 00:05:36,740
entire requirement set gets pecked by

00:05:34,490 --> 00:05:39,740
tests then when you have a passing test

00:05:36,740 --> 00:05:42,530
suite everything little means your code

00:05:39,740 --> 00:05:44,750
matches your requirements there are

00:05:42,530 --> 00:05:46,940
other ways to get testing done early you

00:05:44,750 --> 00:05:48,680
can make it a mandatory part of a code

00:05:46,940 --> 00:05:52,370
review process I all presume you have

00:05:48,680 --> 00:05:54,740
code review if you don't do testing or

00:05:52,370 --> 00:05:56,390
making it policy to add new test cases

00:05:54,740 --> 00:05:58,610
whenever you get bug reports to come in

00:05:56,390 --> 00:06:00,530
either of these are less prone to giving

00:05:58,610 --> 00:06:04,520
you good test coverage than doing proper

00:06:00,530 --> 00:06:05,650
test driven development and when you're

00:06:04,520 --> 00:06:08,690
thinking about test-driven development

00:06:05,650 --> 00:06:10,160
you generally produce testing in a

00:06:08,690 --> 00:06:12,830
structured fashion you start off with

00:06:10,160 --> 00:06:14,690
unit tests which are tests for small and

00:06:12,830 --> 00:06:17,090
isolated parts of the system that can be

00:06:14,690 --> 00:06:18,830
tested independently you have lots of

00:06:17,090 --> 00:06:21,169
them because they tend to be fast and

00:06:18,830 --> 00:06:22,700
then you have integration tests that

00:06:21,169 --> 00:06:24,680
test that all the parts that are under

00:06:22,700 --> 00:06:26,510
unit testing works together you

00:06:24,680 --> 00:06:29,009
generally have fewer of these and you

00:06:26,510 --> 00:06:31,540
have unit tests because they are slow

00:06:29,009 --> 00:06:33,070
and so structured testing and the test

00:06:31,540 --> 00:06:35,199
driven development looks like this you

00:06:33,070 --> 00:06:36,970
write your unit tests first then you

00:06:35,199 --> 00:06:38,740
write those units and then you write the

00:06:36,970 --> 00:06:43,449
integration tests to make sure they work

00:06:38,740 --> 00:06:47,139
together and there's good reasons to

00:06:43,449 --> 00:06:49,060
write tests early because you generally

00:06:47,139 --> 00:06:51,520
have well-thought-out interfaces that

00:06:49,060 --> 00:06:53,680
are easier to test you get interfaces

00:06:51,520 --> 00:06:57,130
that deal with specific concerns within

00:06:53,680 --> 00:07:00,070
your system and the concerns are

00:06:57,130 --> 00:07:02,860
separated so you can mock or write fakes

00:07:00,070 --> 00:07:06,310
for four parts of systems that you don't

00:07:02,860 --> 00:07:08,650
want to test and and considering tests

00:07:06,310 --> 00:07:10,750
early also generally means that you put

00:07:08,650 --> 00:07:12,970
IO away from your business logic and

00:07:10,750 --> 00:07:16,539
this is because state tends to lead to

00:07:12,970 --> 00:07:19,510
isolation issues and I oh makes tests

00:07:16,539 --> 00:07:22,300
low and people like this test driven

00:07:19,510 --> 00:07:23,380
development thing because it's a good

00:07:22,300 --> 00:07:25,660
way to make sure that you've actually

00:07:23,380 --> 00:07:27,160
planned out your test plans as soon as

00:07:25,660 --> 00:07:29,410
your actual code comes into existence

00:07:27,160 --> 00:07:33,639
because you write the tests first your

00:07:29,410 --> 00:07:36,449
code is tested when your code exists the

00:07:33,639 --> 00:07:38,800
problem with things like this is you get

00:07:36,449 --> 00:07:40,810
people holding very strongly held

00:07:38,800 --> 00:07:42,789
opinions you can tell this is a strongly

00:07:40,810 --> 00:07:46,330
held opinion because he's capitalized a

00:07:42,789 --> 00:07:47,860
few words you know it's impossible by

00:07:46,330 --> 00:07:53,500
definition to do test-driven development

00:07:47,860 --> 00:07:55,060
after the code is written statements

00:07:53,500 --> 00:07:57,250
like this really aren't all that useful

00:07:55,060 --> 00:08:01,320
firstly because it suggests that testing

00:07:57,250 --> 00:08:03,430
is a lost cause on old code bases I

00:08:01,320 --> 00:08:05,530
imagine most of you do not get a chance

00:08:03,430 --> 00:08:07,000
to go and start a new project every

00:08:05,530 --> 00:08:10,180
single week and most of you would not

00:08:07,000 --> 00:08:14,349
want to people have old code that should

00:08:10,180 --> 00:08:16,750
be tested Michael feathers wrote a paper

00:08:14,349 --> 00:08:19,060
back in 2002 and subsequently published

00:08:16,750 --> 00:08:22,360
a book called working effectively with

00:08:19,060 --> 00:08:24,699
legacy code and very close to the start

00:08:22,360 --> 00:08:26,530
of that he points out that most people

00:08:24,699 --> 00:08:30,280
do not actually ever get to start on

00:08:26,530 --> 00:08:32,020
green fields code and he notes that most

00:08:30,280 --> 00:08:34,719
people who are not working on green

00:08:32,020 --> 00:08:36,789
fields code leave their code untested

00:08:34,719 --> 00:08:40,870
and that becomes a maintenance burden

00:08:36,789 --> 00:08:42,310
into the future so once you realize that

00:08:40,870 --> 00:08:44,020
you have this lack of tests

00:08:42,310 --> 00:08:46,420
continuing with a lack of test seems

00:08:44,020 --> 00:08:49,020
like a pretty bad idea so the aim should

00:08:46,420 --> 00:08:52,210
be to transform your codebase into one

00:08:49,020 --> 00:08:54,850
where sometime in the future you have a

00:08:52,210 --> 00:08:56,950
shot at early stage testing and making

00:08:54,850 --> 00:09:02,500
it easy to do this early stage testing

00:08:56,950 --> 00:09:04,600
like test-driven development so adopting

00:09:02,500 --> 00:09:08,170
this this test room development approach

00:09:04,600 --> 00:09:09,940
isn't immediately possible which means

00:09:08,170 --> 00:09:11,500
you probably have some code that looks

00:09:09,940 --> 00:09:14,440
like this if it's untested you'd

00:09:11,500 --> 00:09:16,240
probably have poor interfaces so various

00:09:14,440 --> 00:09:19,060
bits of your codebase have to interact

00:09:16,240 --> 00:09:21,460
with other bits of your codebase you

00:09:19,060 --> 00:09:23,230
have dependencies tied together which

00:09:21,460 --> 00:09:27,070
makes it hard to test different bits in

00:09:23,230 --> 00:09:28,960
isolation if your interface is a poor it

00:09:27,070 --> 00:09:30,670
makes it really hard to test specific

00:09:28,960 --> 00:09:33,580
functions because you have to do lots of

00:09:30,670 --> 00:09:37,000
setup to get into a single function to

00:09:33,580 --> 00:09:39,339
actually test it if your interfaces are

00:09:37,000 --> 00:09:40,720
poor then it may mean that the function

00:09:39,339 --> 00:09:43,630
that actually has the business logic

00:09:40,720 --> 00:09:45,730
that you want to test might be four or

00:09:43,630 --> 00:09:48,310
five layers of function calls deep and

00:09:45,730 --> 00:09:50,620
each of those function calls does more

00:09:48,310 --> 00:09:53,080
set up to get into the function that you

00:09:50,620 --> 00:09:55,330
want to test and more often than not

00:09:53,080 --> 00:09:57,190
it's impossible to do these tests

00:09:55,330 --> 00:10:01,000
without performing io because you put

00:09:57,190 --> 00:10:03,070
web service calls or whatever at the out

00:10:01,000 --> 00:10:04,300
of the way of your business logic or in

00:10:03,070 --> 00:10:08,320
the way of your business logic rather

00:10:04,300 --> 00:10:11,860
and you may have dependencies that are

00:10:08,320 --> 00:10:13,600
tied together which makes it which means

00:10:11,860 --> 00:10:15,490
that you need to invoke coding bits you

00:10:13,600 --> 00:10:17,230
don't really care about testing in order

00:10:15,490 --> 00:10:21,580
to run the code in the subsystem that

00:10:17,230 --> 00:10:23,589
you actually want to test I note in my

00:10:21,580 --> 00:10:25,240
notes here that dependency injection is

00:10:23,589 --> 00:10:28,209
kind of the devil in this regard because

00:10:25,240 --> 00:10:30,430
it makes it very easy to apply

00:10:28,209 --> 00:10:32,080
dependencies that you might not need and

00:10:30,430 --> 00:10:33,250
you might not have considered in code

00:10:32,080 --> 00:10:35,770
rather than actually thinking about

00:10:33,250 --> 00:10:37,930
various interfaces between the bits of

00:10:35,770 --> 00:10:39,970
your code base tying dependencies

00:10:37,930 --> 00:10:42,070
together is bad for test isolation

00:10:39,970 --> 00:10:44,680
because you end up having coupled code

00:10:42,070 --> 00:10:46,330
and when your code is coupled this idea

00:10:44,680 --> 00:10:48,010
of units that arises when you are

00:10:46,330 --> 00:10:50,380
structured doing structured testing

00:10:48,010 --> 00:10:52,660
these units do not exist because you

00:10:50,380 --> 00:10:55,000
need well-defined interfaces to have

00:10:52,660 --> 00:10:56,170
test units and if you don't have this

00:10:55,000 --> 00:10:57,910
idea of

00:10:56,170 --> 00:11:01,959
units then you can't do integration

00:10:57,910 --> 00:11:04,420
tests so this this standard structured

00:11:01,959 --> 00:11:11,500
approach to testing it doesn't really

00:11:04,420 --> 00:11:13,540
apply and when people realize that it's

00:11:11,500 --> 00:11:15,690
hard to easily write these unit tests

00:11:13,540 --> 00:11:18,850
most people don't and this is terrible

00:11:15,690 --> 00:11:22,480
so what does this testing strategy look

00:11:18,850 --> 00:11:24,190
like if you can't adopt the unit or

00:11:22,480 --> 00:11:26,470
integration behavior that test driven

00:11:24,190 --> 00:11:28,389
development recommends if you're

00:11:26,470 --> 00:11:29,860
repairing old code that doesn't have

00:11:28,389 --> 00:11:34,480
test coverage you need to do something

00:11:29,860 --> 00:11:37,420
different and once again Michael

00:11:34,480 --> 00:11:40,209
feathers in his paper coin this idea of

00:11:37,420 --> 00:11:41,620
of test coverings which is a different

00:11:40,209 --> 00:11:44,410
way to think about structuring your

00:11:41,620 --> 00:11:46,389
tests rather than thinking about testing

00:11:44,410 --> 00:11:49,000
units and then testing that those units

00:11:46,389 --> 00:11:51,459
work well together he suggests that you

00:11:49,000 --> 00:11:53,290
just create tests of sweets that seek to

00:11:51,459 --> 00:11:55,769
cover all the code in the part of your

00:11:53,290 --> 00:12:00,220
system that you're trying to test

00:11:55,769 --> 00:12:03,040
there's not much more to it than that so

00:12:00,220 --> 00:12:04,839
the idea is that you you find some sort

00:12:03,040 --> 00:12:07,779
of interface that can get into the code

00:12:04,839 --> 00:12:10,630
that you care about fixing take whatever

00:12:07,779 --> 00:12:12,610
interface you can you can use put it in

00:12:10,630 --> 00:12:16,589
some sort of test harness and write some

00:12:12,610 --> 00:12:19,660
test cases that invoke that test harness

00:12:16,589 --> 00:12:22,209
such tests won't give particularly

00:12:19,660 --> 00:12:26,880
specific information about specific bugs

00:12:22,209 --> 00:12:29,440
but it will give you test coverage so

00:12:26,880 --> 00:12:31,260
when I talk about creating an interface

00:12:29,440 --> 00:12:33,790
into the code that you care about I'm

00:12:31,260 --> 00:12:36,010
talking about anything that gives you a

00:12:33,790 --> 00:12:38,230
reasonable amount of isolation into what

00:12:36,010 --> 00:12:41,290
you're trying to test and when I say

00:12:38,230 --> 00:12:43,300
okay isolation I don't mean something

00:12:41,290 --> 00:12:44,769
that completely does not invoke anything

00:12:43,300 --> 00:12:48,190
else under your system because you

00:12:44,769 --> 00:12:50,110
probably can't do that but if you can

00:12:48,190 --> 00:12:52,089
minimize the number of side effects you

00:12:50,110 --> 00:12:55,930
have in other parts of your system when

00:12:52,089 --> 00:12:58,810
you're in testing one section then

00:12:55,930 --> 00:13:00,959
that's probably okay if you cut if you

00:12:58,810 --> 00:13:03,490
can't avoid isolating systems don't

00:13:00,959 --> 00:13:05,290
don't bother trying to isolate them

00:13:03,490 --> 00:13:09,550
that's a waste of time when you can

00:13:05,290 --> 00:13:12,279
write tests so the ideal into

00:13:09,550 --> 00:13:14,709
bass for testing something is being able

00:13:12,279 --> 00:13:17,170
to extract just the code you want and

00:13:14,709 --> 00:13:19,209
then wrapping it in some sort of custom

00:13:17,170 --> 00:13:24,160
testing harness that it gets invoked by

00:13:19,209 --> 00:13:26,200
test runner back in 2002 when when

00:13:24,160 --> 00:13:28,839
working effectively with legacy code was

00:13:26,200 --> 00:13:30,640
written he basically implied that you

00:13:28,839 --> 00:13:34,000
needed to put your code into a custom

00:13:30,640 --> 00:13:37,149
test harness as opposed to running it in

00:13:34,000 --> 00:13:38,950
some other known environment if your

00:13:37,149 --> 00:13:41,050
code is easy to extract and put into

00:13:38,950 --> 00:13:45,399
some other interface and that might be

00:13:41,050 --> 00:13:48,010
an achievable thing if not it might not

00:13:45,399 --> 00:13:50,560
be pragmatic if you're exposing a web

00:13:48,010 --> 00:13:52,480
service put your web service calls

00:13:50,560 --> 00:13:55,450
inside a test runner and invoke your web

00:13:52,480 --> 00:13:58,269
service calls or your rest api if you

00:13:55,450 --> 00:14:00,190
have the the bits of a publicly exposed

00:13:58,269 --> 00:14:02,829
API that exercises the right bit of your

00:14:00,190 --> 00:14:04,899
code then just write test cases that

00:14:02,829 --> 00:14:08,589
exercise that interface this is a

00:14:04,899 --> 00:14:11,230
perfectly fine test harness and if you

00:14:08,589 --> 00:14:14,010
can't extract a Web API and you have you

00:14:11,230 --> 00:14:16,570
know HTML inputs and forms well

00:14:14,010 --> 00:14:19,079
webdriver is a thing you can use that

00:14:16,570 --> 00:14:22,510
you can drive it in Python and that can

00:14:19,079 --> 00:14:25,000
hit the hit the public interface your

00:14:22,510 --> 00:14:27,940
code which is a web page that may be

00:14:25,000 --> 00:14:29,380
fine if it isolates the right part of

00:14:27,940 --> 00:14:33,940
your system then that is a perfectly

00:14:29,380 --> 00:14:35,920
okay place to start testing you know

00:14:33,940 --> 00:14:37,750
find whatever technology that you can

00:14:35,920 --> 00:14:40,420
get that will actually let you write the

00:14:37,750 --> 00:14:45,339
tests that you want and let you write it

00:14:40,420 --> 00:14:47,500
early I was asked when I gave this talk

00:14:45,339 --> 00:14:49,180
last week what you do if you are in a

00:14:47,500 --> 00:14:53,800
language that's so old that you don't

00:14:49,180 --> 00:14:55,360
have a test environment it turns out

00:14:53,800 --> 00:14:58,630
that most of the time it is possible to

00:14:55,360 --> 00:15:00,790
still launch executables so why not test

00:14:58,630 --> 00:15:02,529
the executable that you produce as a

00:15:00,790 --> 00:15:04,600
subprocess from within your favorite

00:15:02,529 --> 00:15:06,120
testing framework there's bunches of

00:15:04,600 --> 00:15:08,740
testing frameworks that will produce

00:15:06,120 --> 00:15:11,019
reliable test output you can put into

00:15:08,740 --> 00:15:15,130
your continuous integration sweet you

00:15:11,019 --> 00:15:17,350
know any Python testing environments j

00:15:15,130 --> 00:15:19,990
unit if you are java fan tap if you're a

00:15:17,350 --> 00:15:23,820
pearl user wrap your executable in it

00:15:19,990 --> 00:15:23,820
that's a perfectly fine test

00:15:25,270 --> 00:15:29,780
so when we're talking about testing at

00:15:28,520 --> 00:15:31,310
an interface you may be wondering

00:15:29,780 --> 00:15:33,980
whether you're dealing with a unit test

00:15:31,310 --> 00:15:36,020
or an integration test well these don't

00:15:33,980 --> 00:15:37,850
give you the level of granularity that

00:15:36,020 --> 00:15:41,090
you would expect from in from a unit

00:15:37,850 --> 00:15:43,400
test unit tests can use it usually be

00:15:41,090 --> 00:15:46,400
run in complete isolation and give you

00:15:43,400 --> 00:15:48,710
specific hints as to where your code is

00:15:46,400 --> 00:15:51,370
broken when you're testing at an

00:15:48,710 --> 00:15:53,900
interface with general test cases

00:15:51,370 --> 00:15:55,760
looking at a single test case may not

00:15:53,900 --> 00:15:57,410
actually make sense as far as debugging

00:15:55,760 --> 00:16:01,160
is concerned you may need to look at a

00:15:57,410 --> 00:16:03,320
set of tests failing so what do you get

00:16:01,160 --> 00:16:07,370
when you're testing a bunch of stuff at

00:16:03,320 --> 00:16:09,970
the interface well from first principles

00:16:07,370 --> 00:16:12,170
you get invariance in your system

00:16:09,970 --> 00:16:13,850
invariance of these fixed observed

00:16:12,170 --> 00:16:17,420
properties that you get out of unit

00:16:13,850 --> 00:16:21,380
tests when your unit testing a single

00:16:17,420 --> 00:16:22,970
passing test case is an invariant you

00:16:21,380 --> 00:16:24,380
know that it's an observed property of

00:16:22,970 --> 00:16:26,920
your system because you've said that

00:16:24,380 --> 00:16:29,660
that's what your system is going to do

00:16:26,920 --> 00:16:32,270
now when you have these invariants you

00:16:29,660 --> 00:16:33,620
can refactor code around that because

00:16:32,270 --> 00:16:36,890
you can tell if the behavior has changed

00:16:33,620 --> 00:16:38,660
when you change the code establishing

00:16:36,890 --> 00:16:41,350
any invariance means that you can

00:16:38,660 --> 00:16:44,240
refactor with some level of impunity and

00:16:41,350 --> 00:16:47,930
these only exist in code that you've put

00:16:44,240 --> 00:16:49,670
under test so if you're writing unit

00:16:47,930 --> 00:16:51,710
tests in a structured fashion you can

00:16:49,670 --> 00:16:53,870
generally tell what sort of thing has

00:16:51,710 --> 00:16:55,700
failed and you can tell exactly how you

00:16:53,870 --> 00:16:57,560
made it fail because you're testing is

00:16:55,700 --> 00:17:01,640
small and isolated part of your system

00:16:57,560 --> 00:17:04,220
so you can make assertions like reverse

00:17:01,640 --> 00:17:06,320
string works with an empty string you're

00:17:04,220 --> 00:17:09,500
testing a single function under a single

00:17:06,320 --> 00:17:12,410
property and you can tell it with some

00:17:09,500 --> 00:17:16,699
level of precision make your tests at

00:17:12,410 --> 00:17:18,890
the interface if that fails you get

00:17:16,699 --> 00:17:21,650
useful information which is that a test

00:17:18,890 --> 00:17:24,500
is failed but if you've got several

00:17:21,650 --> 00:17:25,910
layers of interdependent code before you

00:17:24,500 --> 00:17:29,420
get to the part you're actually trying

00:17:25,910 --> 00:17:31,130
to test you can't tell where in the code

00:17:29,420 --> 00:17:32,930
in the code path your testers failed

00:17:31,130 --> 00:17:35,419
because there might be bits adding in

00:17:32,930 --> 00:17:38,370
useful irrelevant bits of information

00:17:35,419 --> 00:17:41,070
so generally analyzing multiple failing

00:17:38,370 --> 00:17:45,270
tests that touch similar code paths are

00:17:41,070 --> 00:17:46,950
likely to reveal causes of failure so

00:17:45,270 --> 00:17:49,890
this suggests that it's often a good

00:17:46,950 --> 00:17:53,100
idea to adopt an approach where you have

00:17:49,890 --> 00:17:56,400
lots of tests that where the lines that

00:17:53,100 --> 00:17:58,890
comprise your code don't change but your

00:17:56,400 --> 00:18:00,720
input data does so I'm using parametric

00:17:58,890 --> 00:18:03,299
type tests where you have lots and lots

00:18:00,720 --> 00:18:06,600
of test data as opposed to lots of test

00:18:03,299 --> 00:18:12,150
functions writing functions takes effort

00:18:06,600 --> 00:18:14,940
writing data tends not to so even if you

00:18:12,150 --> 00:18:18,659
don't get these tests that tell you sort

00:18:14,940 --> 00:18:21,510
of direct and fine-grained results about

00:18:18,659 --> 00:18:23,220
about where your code is failing you

00:18:21,510 --> 00:18:25,110
still get tests out of this and that's a

00:18:23,220 --> 00:18:26,460
good thing and you shouldn't be unhappy

00:18:25,110 --> 00:18:30,840
with the fact that your tests aren't

00:18:26,460 --> 00:18:32,789
quite what you want yet Oh getting tests

00:18:30,840 --> 00:18:37,080
is more important than than getting good

00:18:32,789 --> 00:18:40,200
tests to start off with so it's also

00:18:37,080 --> 00:18:41,880
vital to know what sort of code is

00:18:40,200 --> 00:18:43,650
actually being covered by these test

00:18:41,880 --> 00:18:45,960
cases that you create because this is

00:18:43,650 --> 00:18:47,970
how you can justifiably refactor knowing

00:18:45,960 --> 00:18:52,380
which parts of your code base is covered

00:18:47,970 --> 00:18:54,360
under testing super important so this is

00:18:52,380 --> 00:18:58,110
a function here it has basically a

00:18:54,360 --> 00:18:59,850
single path through it if you have

00:18:58,110 --> 00:19:02,460
simple line coverage when you're doing

00:18:59,850 --> 00:19:04,919
your your test analysis you can sort of

00:19:02,460 --> 00:19:07,730
broadly see which bits of code need to

00:19:04,919 --> 00:19:10,289
work need work when you're adding tests

00:19:07,730 --> 00:19:12,960
getting big gains on lines covered

00:19:10,289 --> 00:19:16,620
though it's quite easy this function has

00:19:12,960 --> 00:19:23,090
minimal branching so you can get all six

00:19:16,620 --> 00:19:24,960
lines by writing a single test case but

00:19:23,090 --> 00:19:27,059
instead what if you are looking at

00:19:24,960 --> 00:19:30,450
branches coverage we have 26 line

00:19:27,059 --> 00:19:32,429
functions here the top one it needs for

00:19:30,450 --> 00:19:34,559
test cases in order to get a hundred

00:19:32,429 --> 00:19:37,919
percent line coverage or branch coverage

00:19:34,559 --> 00:19:40,200
rather and this one only needs one test

00:19:37,919 --> 00:19:41,880
to get full line coverage you need to

00:19:40,200 --> 00:19:45,840
write five tests to get full branch

00:19:41,880 --> 00:19:47,820
coverage in this case so testing

00:19:45,840 --> 00:19:48,930
branches in this case or looking at

00:19:47,820 --> 00:19:50,730
branch coverage

00:19:48,930 --> 00:19:53,580
actually indicates the amount of effort

00:19:50,730 --> 00:19:55,710
towards getting full coverage whereas

00:19:53,580 --> 00:19:58,290
you can get easy gains if you're doing

00:19:55,710 --> 00:20:00,270
line coverage use a metric that tells

00:19:58,290 --> 00:20:02,370
you how much effort is required to fully

00:20:00,270 --> 00:20:05,970
cover your code base so you can measure

00:20:02,370 --> 00:20:15,780
your progress and testing lines of code

00:20:05,970 --> 00:20:17,520
coverage is probably not it so testing

00:20:15,780 --> 00:20:20,340
an entire system is kind of terrible

00:20:17,520 --> 00:20:23,010
because you need to do lots of setup

00:20:20,340 --> 00:20:26,370
code is complicated to write tests are

00:20:23,010 --> 00:20:28,320
in precise and slow so let's talk about

00:20:26,370 --> 00:20:32,070
how to make these actually barrier but

00:20:28,320 --> 00:20:33,990
bearable so if you have i oh and state

00:20:32,070 --> 00:20:36,720
fulness embedded in the interface that

00:20:33,990 --> 00:20:39,570
you're testing it's difficult to get rid

00:20:36,720 --> 00:20:42,840
of it usual techniques like mocking

00:20:39,570 --> 00:20:44,400
writing fakes stuff like that these only

00:20:42,840 --> 00:20:46,170
apply if you can pull out useful

00:20:44,400 --> 00:20:50,010
interfaces for the bits of the code that

00:20:46,170 --> 00:20:52,320
you want a mock or fake that will

00:20:50,010 --> 00:20:54,210
generally involve a refactor it makes a

00:20:52,320 --> 00:20:57,180
lot more sense to actually write tests

00:20:54,210 --> 00:21:00,150
before you go and refactor the problem

00:20:57,180 --> 00:21:01,650
is that this i/o tends to make your

00:21:00,150 --> 00:21:03,690
tests very slow and when you're working

00:21:01,650 --> 00:21:05,220
to refactor a system you want to make

00:21:03,690 --> 00:21:09,240
the tests you've written actually

00:21:05,220 --> 00:21:12,210
accessible if your tests require you to

00:21:09,240 --> 00:21:14,100
actually go out and do I oh then it's

00:21:12,210 --> 00:21:16,380
likely that a large amount of your test

00:21:14,100 --> 00:21:19,760
time is going to be doing set up tear

00:21:16,380 --> 00:21:22,170
downs of various bits of your system

00:21:19,760 --> 00:21:25,050
doing setup and teardown after every

00:21:22,170 --> 00:21:27,450
case is necessary to maintain complete

00:21:25,050 --> 00:21:31,650
isolation but this comes at the expense

00:21:27,450 --> 00:21:34,080
of making your test suite slow and slow

00:21:31,650 --> 00:21:36,120
test suites are a massive inconvenience

00:21:34,080 --> 00:21:38,490
to the people who are running the test

00:21:36,120 --> 00:21:43,410
Suites and if they're too slow they tend

00:21:38,490 --> 00:21:46,410
to get neglected if you try to speed

00:21:43,410 --> 00:21:48,570
them up at the others at the expense of

00:21:46,410 --> 00:21:50,340
correctness these are likely to create

00:21:48,570 --> 00:21:53,610
further issues down the track from

00:21:50,340 --> 00:21:56,780
chasing down non-existent bugs so how do

00:21:53,610 --> 00:22:00,390
you deal with this measure everything

00:21:56,780 --> 00:22:02,909
know exactly what time is being spent in

00:22:00,390 --> 00:22:05,489
your test suite know where time is

00:22:02,909 --> 00:22:07,379
wasted during set-up time and teardown

00:22:05,489 --> 00:22:09,659
time so you can figure out where you can

00:22:07,379 --> 00:22:13,279
save time in exchange for absolute

00:22:09,659 --> 00:22:15,509
correctness for every single test case

00:22:13,279 --> 00:22:17,549
once you've done that you can look for

00:22:15,509 --> 00:22:20,190
tests that don't impede each other

00:22:17,549 --> 00:22:22,169
within the same test environment so

00:22:20,190 --> 00:22:23,729
cluster tests that are unrelated in

00:22:22,169 --> 00:22:26,249
dealing with unrelated parts of your

00:22:23,729 --> 00:22:29,009
system and this will obviate the need

00:22:26,249 --> 00:22:31,169
for isolation and sanitization of your

00:22:29,009 --> 00:22:34,340
test environments so what you get is

00:22:31,169 --> 00:22:36,809
local isolation for each test case and

00:22:34,340 --> 00:22:39,090
that means you can run them in the same

00:22:36,809 --> 00:22:42,690
environment without hurting your overall

00:22:39,090 --> 00:22:46,619
correctness and to verify that you have

00:22:42,690 --> 00:22:49,529
clustered your test cases correctly run

00:22:46,619 --> 00:22:51,690
each test case in different random

00:22:49,529 --> 00:22:54,119
orders each time so you can check to see

00:22:51,690 --> 00:22:57,210
if there are any accidental dependencies

00:22:54,119 --> 00:22:59,190
between your test cases this will verify

00:22:57,210 --> 00:23:04,109
that the tests aren't actually dependent

00:22:59,190 --> 00:23:06,629
on each other you should also if you've

00:23:04,109 --> 00:23:08,700
got time to do nightly builds and you

00:23:06,629 --> 00:23:11,190
probably should people don't tend to be

00:23:08,700 --> 00:23:13,769
awake during the night run your test

00:23:11,190 --> 00:23:16,289
cases thoroughly with setups and tear

00:23:13,769 --> 00:23:18,269
downs on each test case with full

00:23:16,289 --> 00:23:21,389
sanitization to see whether or not they

00:23:18,269 --> 00:23:26,309
function in a completely st. sanitized

00:23:21,389 --> 00:23:30,419
environment the approach that I suggest

00:23:26,309 --> 00:23:33,389
though this this yields slow nonspecific

00:23:30,419 --> 00:23:35,159
and cumbersome tests to right so this

00:23:33,389 --> 00:23:38,399
should not be used as a long-term

00:23:35,159 --> 00:23:40,799
testing strategy if you get these tests

00:23:38,399 --> 00:23:42,509
and they break you know that overall

00:23:40,799 --> 00:23:44,309
behavior in your system has changed

00:23:42,509 --> 00:23:46,200
you've introduced a regression somewhere

00:23:44,309 --> 00:23:48,389
but it's very hard to tell where you've

00:23:46,200 --> 00:23:49,979
introduced your regressions so you can

00:23:48,389 --> 00:23:51,899
use these tests as a way to check if

00:23:49,979 --> 00:23:54,899
overall behaviour change as you change

00:23:51,899 --> 00:23:56,999
your structure but using this as an

00:23:54,899 --> 00:23:58,379
overall testing strategy is only going

00:23:56,999 --> 00:24:02,340
to be difficult for the people

00:23:58,379 --> 00:24:06,330
maintaining your code into the future so

00:24:02,340 --> 00:24:08,970
with that in mind let's talk about how

00:24:06,330 --> 00:24:10,139
to refactor and this is the one thing

00:24:08,970 --> 00:24:12,539
that I've learned that I think is

00:24:10,139 --> 00:24:14,940
actually concrete when dealing with with

00:24:12,539 --> 00:24:16,500
problems like this because refactoring

00:24:14,940 --> 00:24:18,480
your your code also

00:24:16,500 --> 00:24:22,320
having interface test means that you can

00:24:18,480 --> 00:24:24,300
reflect your code with impunity and this

00:24:22,320 --> 00:24:27,390
strategy i think tends to work quite

00:24:24,300 --> 00:24:30,120
well this is a terrible architecture

00:24:27,390 --> 00:24:32,100
diagram from a person called Uncle Bob

00:24:30,120 --> 00:24:34,410
he's apparently quite big in the

00:24:32,100 --> 00:24:36,030
software architecture community and he

00:24:34,410 --> 00:24:38,160
describes this thing called the clean

00:24:36,030 --> 00:24:41,160
architecture it has a nice name which

00:24:38,160 --> 00:24:44,010
must mean he really likes it this

00:24:41,160 --> 00:24:46,980
describes systems where you put external

00:24:44,010 --> 00:24:49,080
code frameworks IO stuff that you're

00:24:46,980 --> 00:24:53,370
likely to replace on a frequent basis

00:24:49,080 --> 00:24:55,380
and doesn't that doesn't relate to your

00:24:53,370 --> 00:24:57,330
business logic on the outside and

00:24:55,380 --> 00:24:59,700
putting your business logic on the

00:24:57,330 --> 00:25:02,400
inside and it defines this thing called

00:24:59,700 --> 00:25:04,440
the dependency rule which says that any

00:25:02,400 --> 00:25:07,110
of the layers towards the center of this

00:25:04,440 --> 00:25:13,080
core art allowed to know anything at all

00:25:07,110 --> 00:25:15,690
about the bits on the outside Brandon

00:25:13,080 --> 00:25:17,430
Rodes gave a talk at PI Ohio last year

00:25:15,690 --> 00:25:19,290
which I strongly recommend you look at

00:25:17,430 --> 00:25:22,500
it's called the clean architecture and

00:25:19,290 --> 00:25:25,590
Python it gives a nice simple example of

00:25:22,500 --> 00:25:28,980
how this works in practice this shows

00:25:25,590 --> 00:25:30,480
you the wrong way of refactoring a piece

00:25:28,980 --> 00:25:34,830
of functionality out of a broader

00:25:30,480 --> 00:25:37,020
function it's pulling a IO call out of a

00:25:34,830 --> 00:25:39,120
broader method and leaving the

00:25:37,020 --> 00:25:42,480
processing code the important business

00:25:39,120 --> 00:25:44,940
logic in the outer layer and if you're

00:25:42,480 --> 00:25:48,660
going to put this set of code under

00:25:44,940 --> 00:25:50,820
testing you need to do some level of

00:25:48,660 --> 00:25:53,910
dependency injection or mocking of this

00:25:50,820 --> 00:25:56,600
called JSON API function in order to be

00:25:53,910 --> 00:25:59,010
able to test the business logic at all

00:25:56,600 --> 00:26:00,720
so you need to write something that

00:25:59,010 --> 00:26:05,520
pretends to do this called JSON API

00:26:00,720 --> 00:26:09,390
thing in order to actually run under

00:26:05,520 --> 00:26:12,240
test without invoking io the alternative

00:26:09,390 --> 00:26:14,100
is to leave the i/o bound functions at

00:26:12,240 --> 00:26:16,770
the top and pull out the processing code

00:26:14,100 --> 00:26:18,920
into functions so this build URL thing

00:26:16,770 --> 00:26:21,960
was at the top of the previous slide and

00:26:18,920 --> 00:26:23,760
and the pluck definition was at the

00:26:21,960 --> 00:26:25,800
bottom of the function at the top these

00:26:23,760 --> 00:26:28,860
processing functions provided you can

00:26:25,800 --> 00:26:30,029
set up this data that is expected it's

00:26:28,860 --> 00:26:32,849
really really

00:26:30,029 --> 00:26:35,190
easy to test these in isolation you just

00:26:32,849 --> 00:26:39,479
you don't need to test the top one at

00:26:35,190 --> 00:26:42,330
all in a unit testing context Gary

00:26:39,479 --> 00:26:46,409
Bernard gave a talk at pycon 2013 in the

00:26:42,330 --> 00:26:48,869
US and in that talk called boundaries he

00:26:46,409 --> 00:26:51,029
firstly gave the clean architecture are

00:26:48,869 --> 00:26:53,489
much cooler name he called it functional

00:26:51,029 --> 00:26:55,259
core imperative shell and that's good

00:26:53,489 --> 00:26:58,919
because it actually describes what

00:26:55,259 --> 00:27:00,929
you're doing in it basically he talked

00:26:58,919 --> 00:27:03,839
about using this approach to think about

00:27:00,929 --> 00:27:06,239
how you construct your code to minimize

00:27:03,839 --> 00:27:08,210
the amount of mocking or faking you need

00:27:06,239 --> 00:27:10,799
to do when you're writing tests

00:27:08,210 --> 00:27:12,989
basically produce your processing

00:27:10,799 --> 00:27:16,559
function or your processing logic as

00:27:12,989 --> 00:27:21,299
pure functions and isolates the i/o as

00:27:16,559 --> 00:27:23,190
close to the top as you can and if your

00:27:21,299 --> 00:27:25,229
core processing logic is purely

00:27:23,190 --> 00:27:27,629
functional it has no io or anything like

00:27:25,229 --> 00:27:29,879
that then you can unit test these bits

00:27:27,629 --> 00:27:33,089
thoroughly and those tests will run

00:27:29,879 --> 00:27:34,979
quickly and the integration tests

00:27:33,089 --> 00:27:38,489
testing this so-called imperative shell

00:27:34,979 --> 00:27:40,649
these are just the tests that execute at

00:27:38,489 --> 00:27:42,899
the top level of your system where the

00:27:40,649 --> 00:27:45,779
i/o potentially happens you have

00:27:42,899 --> 00:27:47,940
relatively few of these tests and you

00:27:45,779 --> 00:27:50,159
only need to mock or fake or test under

00:27:47,940 --> 00:27:52,379
IO at a relatively centralized and

00:27:50,159 --> 00:27:56,059
isolated point of your system that is

00:27:52,379 --> 00:27:56,059
the bits that call your i/o functions

00:27:56,119 --> 00:28:01,710
now the core observation with this

00:27:58,710 --> 00:28:04,049
though is that this approach as well as

00:28:01,710 --> 00:28:06,450
being an overall initial architectural

00:28:04,049 --> 00:28:09,629
decision you could make actually works

00:28:06,450 --> 00:28:12,899
surprisingly well as a local refactoring

00:28:09,629 --> 00:28:15,809
strategy any function that calls i/o

00:28:12,899 --> 00:28:18,809
gets integration tested any function

00:28:15,809 --> 00:28:20,729
that doesn't gets unit tested so if you

00:28:18,809 --> 00:28:22,859
want to increase your unit test coverage

00:28:20,729 --> 00:28:25,070
it's just a matter of refactoring such

00:28:22,859 --> 00:28:27,509
you're pulling out the purely functional

00:28:25,070 --> 00:28:32,119
side-effect free bits of your functions

00:28:27,509 --> 00:28:34,609
and then you can get unit testable code

00:28:32,119 --> 00:28:37,289
so how do you do this at smaller scales

00:28:34,609 --> 00:28:39,899
you find the processing routines that

00:28:37,289 --> 00:28:42,029
are inside your bigger functions factor

00:28:39,899 --> 00:28:43,370
these out into bits where you can define

00:28:42,029 --> 00:28:46,100
the interfaces clearly

00:28:43,370 --> 00:28:48,170
and put tests around them and factor out

00:28:46,100 --> 00:28:50,620
inner loops so you can test these things

00:28:48,170 --> 00:28:53,480
but these behave correctly on mass and

00:28:50,620 --> 00:28:56,630
if you concentrate on keeping your i/o

00:28:53,480 --> 00:28:59,960
at towards the top in relatively few

00:28:56,630 --> 00:29:02,660
functions then you can test those in

00:28:59,960 --> 00:29:04,850
integration test fashion and factor the

00:29:02,660 --> 00:29:09,140
fast codes into their own functions for

00:29:04,850 --> 00:29:11,480
unit testing so go and write those tests

00:29:09,140 --> 00:29:13,850
the emergent functions are effectively

00:29:11,480 --> 00:29:16,600
the units that structured testing

00:29:13,850 --> 00:29:18,620
describes and once you have done that

00:29:16,600 --> 00:29:21,670
suddenly the tests that you wrote to

00:29:18,620 --> 00:29:25,820
start off with our to start off become

00:29:21,670 --> 00:29:28,580
integration tests sort of like magic if

00:29:25,820 --> 00:29:30,920
you take unstructured testing seriously

00:29:28,580 --> 00:29:34,400
you will eventually accidentally start

00:29:30,920 --> 00:29:38,570
doing structured testing and that will

00:29:34,400 --> 00:29:41,030
eventually lead to good code coverage so

00:29:38,570 --> 00:29:43,250
I end this talk with a short discussion

00:29:41,030 --> 00:29:48,050
of actually tracking down bugs in your

00:29:43,250 --> 00:29:50,990
code firstly consider how your code

00:29:48,050 --> 00:29:56,150
might be invoked in production by a user

00:29:50,990 --> 00:29:58,190
can you can you reproduce an invocation

00:29:56,150 --> 00:30:01,880
of your power your code exists in prod

00:29:58,190 --> 00:30:03,679
inside your test harnesses if so then it

00:30:01,880 --> 00:30:06,559
means you can capture every bug report

00:30:03,679 --> 00:30:08,330
at the interface as a test and then spot

00:30:06,559 --> 00:30:14,270
regressions in previous bug reports as

00:30:08,330 --> 00:30:17,890
they arise you should focus on creating

00:30:14,270 --> 00:30:20,690
test cases as data as opposed to as code

00:30:17,890 --> 00:30:24,770
because it's really hard to write to set

00:30:20,690 --> 00:30:27,230
up complex interfaces frequently whereas

00:30:24,770 --> 00:30:30,190
data is a lot easier to reproduce it's

00:30:27,230 --> 00:30:32,600
faster to write than extra code and

00:30:30,190 --> 00:30:34,400
whilst these tests can be slow and

00:30:32,600 --> 00:30:36,440
cumbersome and you don't nearly need as

00:30:34,400 --> 00:30:37,790
many of them as you might need to start

00:30:36,440 --> 00:30:40,309
off with later on once you start

00:30:37,790 --> 00:30:41,870
refactoring keeping them around and

00:30:40,309 --> 00:30:43,340
running them regularly is important

00:30:41,870 --> 00:30:49,610
maybe run them nightly instead of

00:30:43,340 --> 00:30:51,470
continuously so in conclusion i wrote

00:30:49,610 --> 00:30:53,450
the abstract for this talk six months

00:30:51,470 --> 00:30:56,660
ago whilst undertaking a massive

00:30:53,450 --> 00:30:57,170
refactor and what I've kind of learned

00:30:56,660 --> 00:31:00,470
from the

00:30:57,170 --> 00:31:03,590
is that nobody's specific advice ever

00:31:00,470 --> 00:31:05,570
applies to refactoring this refactoring

00:31:03,590 --> 00:31:07,160
your code not every technique I've

00:31:05,570 --> 00:31:10,010
described here might work in your

00:31:07,160 --> 00:31:12,020
situation that you might get lucky and

00:31:10,010 --> 00:31:13,700
so when people talk about doing

00:31:12,020 --> 00:31:16,310
test-driven development where you start

00:31:13,700 --> 00:31:17,840
by writing unit tests and then writing

00:31:16,310 --> 00:31:20,240
units and then testing you're entering

00:31:17,840 --> 00:31:22,690
functionality and telling you that's the

00:31:20,240 --> 00:31:24,770
only way to go about testing your code

00:31:22,690 --> 00:31:27,140
perhaps you can think about it in

00:31:24,770 --> 00:31:29,900
reverse right your integration tests

00:31:27,140 --> 00:31:35,000
first refactor those into units and then

00:31:29,900 --> 00:31:36,890
write your unit tests you get tests you

00:31:35,000 --> 00:31:38,740
end up with unit tests and something

00:31:36,890 --> 00:31:42,980
that looks like structured testing and

00:31:38,740 --> 00:31:45,740
it means you can fix your code so it's

00:31:42,980 --> 00:31:47,690
not impossible by definition to practice

00:31:45,740 --> 00:31:50,000
test driven development on existing code

00:31:47,690 --> 00:31:51,860
you just need to get to the point where

00:31:50,000 --> 00:31:55,550
you can start writing tests on your new

00:31:51,860 --> 00:31:57,770
code and that's the end I've run a bit

00:31:55,550 --> 00:32:00,490
under time so I think that means we have

00:31:57,770 --> 00:32:00,490
plenty of time for questions

00:32:04,620 --> 00:32:09,450
I will also take comments and war

00:32:07,890 --> 00:32:13,940
stories if you've done stuff like this

00:32:09,450 --> 00:32:13,940
yourself we have discussion time I guess

00:32:15,320 --> 00:32:22,500
yes thank you great talk thanks I

00:32:19,190 --> 00:32:24,030
watched the video from icons well the

00:32:22,500 --> 00:32:27,150
clean code stuff that looks very

00:32:24,030 --> 00:32:29,309
interesting to me a quick war story I've

00:32:27,150 --> 00:32:31,200
have a very similar approach to you on

00:32:29,309 --> 00:32:34,290
solving the sort of problem but I do

00:32:31,200 --> 00:32:36,480
only take the approach of if I can if

00:32:34,290 --> 00:32:40,559
it's not tested I will just write test

00:32:36,480 --> 00:32:42,390
when something breaks right that's

00:32:40,559 --> 00:32:44,070
normally when these sorts of things come

00:32:42,390 --> 00:32:45,840
into existence I mean most people don't

00:32:44,070 --> 00:32:48,240
realize there's a problem until a

00:32:45,840 --> 00:32:50,040
problem comes into existence then it's a

00:32:48,240 --> 00:32:51,840
matter of reproducing it you can either

00:32:50,040 --> 00:32:54,240
find somebody and pay them to reproduce

00:32:51,840 --> 00:32:57,030
the test every single time or the

00:32:54,240 --> 00:32:59,280
failure every single time you make

00:32:57,030 --> 00:33:01,950
changes to the code or you can spend a

00:32:59,280 --> 00:33:04,260
few days actually implementing tests on

00:33:01,950 --> 00:33:05,970
it and then it's reproducible every

00:33:04,260 --> 00:33:08,250
single time and that's really important

00:33:05,970 --> 00:33:10,350
means your aggressions Cape keep on

00:33:08,250 --> 00:33:16,820
getting spotted and that's the point of

00:33:10,350 --> 00:33:19,679
of writing tests you should do it yeah

00:33:16,820 --> 00:33:21,120
you've ruined me just asking asking a

00:33:19,679 --> 00:33:27,170
comment so I'll ask an actual question

00:33:21,120 --> 00:33:30,230
oh I'm good I reverse psychology worked

00:33:27,170 --> 00:33:33,000
we do a lot of embedded development and

00:33:30,230 --> 00:33:35,220
finding ways of doing test cases is

00:33:33,000 --> 00:33:37,890
quite difficult because it's very

00:33:35,220 --> 00:33:42,510
event-driven and sporadic and there's

00:33:37,890 --> 00:33:45,920
race conditions do you have any ideas on

00:33:42,510 --> 00:33:45,920
the best way to do that sort of thing

00:33:46,190 --> 00:33:52,730
running tests multiple times running

00:33:50,040 --> 00:33:56,760
entire suite multiple times to check for

00:33:52,730 --> 00:33:58,350
sort of flaky tests being flaky as

00:33:56,760 --> 00:34:00,830
opposed to being actual failures can

00:33:58,350 --> 00:34:00,830
often help

00:34:01,669 --> 00:34:06,539
also the the difficulty with being on a

00:34:05,279 --> 00:34:08,369
different platform and you can't

00:34:06,539 --> 00:34:11,730
necessarily run the tests on that

00:34:08,369 --> 00:34:14,849
platform right so if you have some sort

00:34:11,730 --> 00:34:18,089
of public interface to your thing be it

00:34:14,849 --> 00:34:19,679
a web api or beer talking via serial or

00:34:18,089 --> 00:34:21,960
something like that if you have an

00:34:19,679 --> 00:34:23,780
interface then you can invoke it from a

00:34:21,960 --> 00:34:26,669
language which has a testing framework

00:34:23,780 --> 00:34:28,530
if you are a fan of writing stuff in

00:34:26,669 --> 00:34:30,510
Python will use a Python testing

00:34:28,530 --> 00:34:33,659
framework and use that to talk to your

00:34:30,510 --> 00:34:35,730
devices if it's just a matter of having

00:34:33,659 --> 00:34:36,659
some sort of interface that can talk to

00:34:35,730 --> 00:34:41,639
the thing that you want to run under

00:34:36,659 --> 00:34:44,849
tests like there is no reason why you

00:34:41,639 --> 00:34:47,220
have to execute your tests or define

00:34:44,849 --> 00:34:48,899
your test cases on the same platform as

00:34:47,220 --> 00:34:50,849
you're running them especially if there

00:34:48,899 --> 00:34:53,760
isn't a test environment is if you think

00:34:50,849 --> 00:34:55,800
having no test environment in mice in my

00:34:53,760 --> 00:34:59,160
development environment means I can't

00:34:55,800 --> 00:35:01,859
write tests and you're then you're never

00:34:59,160 --> 00:35:06,180
going to get tests but if your code can

00:35:01,859 --> 00:35:08,369
run run your code I think Oh Katie you

00:35:06,180 --> 00:35:09,920
had a question or hi hi what is your

00:35:08,369 --> 00:35:16,560
opinion about one hundred percent

00:35:09,920 --> 00:35:18,780
complete test coverage on existing on

00:35:16,560 --> 00:35:22,619
existing code bases it's basically

00:35:18,780 --> 00:35:24,869
impossible and there are reasons for

00:35:22,619 --> 00:35:27,410
this and it generally involves people

00:35:24,869 --> 00:35:30,000
being overcautious with error handling

00:35:27,410 --> 00:35:31,830
why are people over cautious with error

00:35:30,000 --> 00:35:37,050
handling on code that hasn't been tested

00:35:31,830 --> 00:35:39,390
I wonder why you will generally find

00:35:37,050 --> 00:35:42,000
when you start writing tests on code

00:35:39,390 --> 00:35:43,920
that hasn't previously been tested there

00:35:42,000 --> 00:35:46,099
are unreasonable error handling cases

00:35:43,920 --> 00:35:48,570
and generally those error handling cases

00:35:46,099 --> 00:35:50,510
can be deleted once you realize they're

00:35:48,570 --> 00:35:52,619
not actually important to anything

00:35:50,510 --> 00:35:57,270
deleting code that will never actually

00:35:52,619 --> 00:36:00,530
get hit is a perfectly valid way to get

00:35:57,270 --> 00:36:00,530
a hundred percent test coverage

00:36:00,650 --> 00:36:05,459
Graham yeah good talk this is a

00:36:03,449 --> 00:36:07,829
follow-up to the previous question in

00:36:05,459 --> 00:36:09,059
terms of embedded unit testing where you

00:36:07,829 --> 00:36:11,039
don't have much control over the

00:36:09,059 --> 00:36:13,199
embedded device we've done things in the

00:36:11,039 --> 00:36:14,939
past where it's almost a black box that

00:36:13,199 --> 00:36:18,059
someone's given us and said tested and

00:36:14,939 --> 00:36:20,819
there is no public interface web cameras

00:36:18,059 --> 00:36:23,160
with OCR brute force like that or wire

00:36:20,819 --> 00:36:24,900
logic analyzers in and our logic

00:36:23,160 --> 00:36:27,269
analyzer you can actually hook into your

00:36:24,900 --> 00:36:29,910
unit tests two ways of cheating if that

00:36:27,269 --> 00:36:32,759
helps so the point to be made is that if

00:36:29,910 --> 00:36:37,529
your system is observable then you can

00:36:32,759 --> 00:36:40,380
test it bad interfaces can get in the

00:36:37,529 --> 00:36:42,509
way of making tests easy but if there is

00:36:40,380 --> 00:36:48,269
an interface at all you can put it under

00:36:42,509 --> 00:36:52,019
tests yes hey hey thanks thanks for the

00:36:48,269 --> 00:36:56,579
talk and two references to books yes on

00:36:52,019 --> 00:37:00,089
that topic Martin follows refactoring

00:36:56,579 --> 00:37:03,599
it's a good one and X unit test patterns

00:37:00,089 --> 00:37:09,199
is also a good one especially if you

00:37:03,599 --> 00:37:13,049
deal with with existing test

00:37:09,199 --> 00:37:18,539
infrastructure which really is coupled

00:37:13,049 --> 00:37:21,989
to data or runs for ages great way to ya

00:37:18,539 --> 00:37:24,599
dig your dig yourself out cool thanks

00:37:21,989 --> 00:37:26,759
for that i also want to plug michael

00:37:24,599 --> 00:37:30,689
feathers book working effectively with

00:37:26,759 --> 00:37:32,249
legacy code it talks about this even

00:37:30,689 --> 00:37:34,109
though the approaches are a bit dated

00:37:32,249 --> 00:37:36,119
these days are there's a question over

00:37:34,109 --> 00:37:38,130
here so that's oh wait there's one over

00:37:36,119 --> 00:37:40,289
there as well worth taking um yes I just

00:37:38,130 --> 00:37:42,269
have a quick comment so Oh excellent you

00:37:40,289 --> 00:37:44,729
mentioned that when you're talking about

00:37:42,269 --> 00:37:47,519
invariants and the fact that a test case

00:37:44,729 --> 00:37:50,039
isn't invariant often your test case

00:37:47,519 --> 00:37:52,979
will actually be a specialization of a

00:37:50,039 --> 00:37:55,170
more general invariant or law so you can

00:37:52,979 --> 00:37:57,989
have a look at some options for

00:37:55,170 --> 00:38:00,989
randomized testing or exhaustive testing

00:37:57,989 --> 00:38:04,019
of those functions yes and that's a

00:38:00,989 --> 00:38:06,599
perfectly good way to create extra test

00:38:04,019 --> 00:38:09,929
data like I said data is easy to

00:38:06,599 --> 00:38:11,880
generate code isn't random I creating

00:38:09,929 --> 00:38:14,160
random test cases a perfectly good way

00:38:11,880 --> 00:38:18,099
to create extra data

00:38:14,160 --> 00:38:20,640
yep um is there yep one of your slides

00:38:18,099 --> 00:38:22,990
was bad tests of better than no tests

00:38:20,640 --> 00:38:24,519
just wondering what what is your

00:38:22,990 --> 00:38:26,410
definition of bad because my destination

00:38:24,519 --> 00:38:30,400
to bed is something that doesn't state

00:38:26,410 --> 00:38:32,519
the intention of the code whereas you

00:38:30,400 --> 00:38:36,190
might have a different data definition i

00:38:32,519 --> 00:38:40,230
would say bad well that is actually a a

00:38:36,190 --> 00:38:42,579
really good example and of what i mean

00:38:40,230 --> 00:38:44,859
something which doesn't say what you are

00:38:42,579 --> 00:38:46,690
trying to test specifically is a is a

00:38:44,859 --> 00:38:47,859
bad test but you can still write and it

00:38:46,690 --> 00:38:51,069
will tell you something about your

00:38:47,859 --> 00:38:52,690
system and knowing something about your

00:38:51,069 --> 00:38:55,210
system that you can establish as

00:38:52,690 --> 00:38:58,029
something that doesn't change is better

00:38:55,210 --> 00:39:01,809
than having no thing that says anything

00:38:58,029 --> 00:39:05,279
about your system but yet bad tests are

00:39:01,809 --> 00:39:08,349
things that don't give you good

00:39:05,279 --> 00:39:12,579
information sice information about what

00:39:08,349 --> 00:39:21,579
is passing what is failing I think we

00:39:12,579 --> 00:39:23,319
have one over here well thank you for a

00:39:21,579 --> 00:39:25,359
doctor was quite interesting and I

00:39:23,319 --> 00:39:28,839
myself right up do test-driven

00:39:25,359 --> 00:39:30,880
development but so you made a

00:39:28,839 --> 00:39:33,190
recommendation that we should keep as

00:39:30,880 --> 00:39:34,990
many test cases as possible but at the

00:39:33,190 --> 00:39:38,339
same time like a test case yourself and

00:39:34,990 --> 00:39:41,910
go stale so what do you think right

00:39:38,339 --> 00:39:44,529
obviously as you refactor things

00:39:41,910 --> 00:39:47,799
interfaces that you previously had mice

00:39:44,529 --> 00:39:50,500
might cease to exist tests might start

00:39:47,799 --> 00:39:53,069
overlapping use your judgment to figure

00:39:50,500 --> 00:39:56,259
out what test cases are still relevant

00:39:53,069 --> 00:39:58,869
but you should aim to keep as many of

00:39:56,259 --> 00:40:01,359
them as you can because more tests are

00:39:58,869 --> 00:40:04,359
better than than fewer tests as long as

00:40:01,359 --> 00:40:05,440
they're still accurate but you know get

00:40:04,359 --> 00:40:08,740
rid of them if they're no longer

00:40:05,440 --> 00:40:10,990
relevant yeah yeah I guess the last year

00:40:08,740 --> 00:40:13,809
there was a kind of controversy that t

00:40:10,990 --> 00:40:15,519
dds dead now I guess you have mail with

00:40:13,809 --> 00:40:17,200
though what are you doing this all I

00:40:15,519 --> 00:40:18,759
know people who still do it and people

00:40:17,200 --> 00:40:21,940
who still love it and that means it's

00:40:18,759 --> 00:40:23,650
pretty much alive thank you not a

00:40:21,940 --> 00:40:25,180
problem I do we have any more questions

00:40:23,650 --> 00:40:26,190
I think we've probably got time for one

00:40:25,180 --> 00:40:29,010
more if there is

00:40:26,190 --> 00:40:33,330
anyone yeah there's one up the front

00:40:29,010 --> 00:40:34,830
here sorry I just wondered you could

00:40:33,330 --> 00:40:38,010
expand a little bit more on the data

00:40:34,830 --> 00:40:39,960
driven testing as opposed to the code

00:40:38,010 --> 00:40:42,660
Riven testing because I've come across

00:40:39,960 --> 00:40:46,470
situations where the tests contain a

00:40:42,660 --> 00:40:49,470
wall of lists of data or dicks or

00:40:46,470 --> 00:40:51,930
whatever and it becomes very difficult

00:40:49,470 --> 00:40:53,760
to read and deal with when something

00:40:51,930 --> 00:40:55,950
goes wrong often because you you know

00:40:53,760 --> 00:40:59,000
the data is somewhere in this big you

00:40:55,950 --> 00:41:01,800
know only how do you generate talk okay

00:40:59,000 --> 00:41:05,760
like I said this talk was inspired by

00:41:01,800 --> 00:41:09,000
work in Java so I will refer to j unit

00:41:05,760 --> 00:41:10,830
here there's a parameterization system

00:41:09,000 --> 00:41:14,610
within j unit which allows you to

00:41:10,830 --> 00:41:16,470
specify data that goes into each into

00:41:14,610 --> 00:41:20,160
each test case in a parameter I system

00:41:16,470 --> 00:41:22,650
and you can basically present a the

00:41:20,160 --> 00:41:26,040
title of your test as being the data you

00:41:22,650 --> 00:41:28,350
pass into it generating individual test

00:41:26,040 --> 00:41:30,600
cases for each piece of data is

00:41:28,350 --> 00:41:32,460
paramount because it means you can see

00:41:30,600 --> 00:41:35,190
each of them failing independently and

00:41:32,460 --> 00:41:38,040
make sure that your tests describe the

00:41:35,190 --> 00:41:39,900
data that is being pushed in jenner if

00:41:38,040 --> 00:41:42,780
your system can generate test cases on

00:41:39,900 --> 00:41:44,760
that in a way similar to that it makes

00:41:42,780 --> 00:41:48,620
it really easy to infer what sort of

00:41:44,760 --> 00:41:54,140
things are failing I think Robert so

00:41:48,620 --> 00:41:56,700
hypothesis does that in Python great

00:41:54,140 --> 00:41:58,800
Robert says hypothesis is a thing and

00:41:56,700 --> 00:42:01,880
I'm sorry my laptop just went to sleep

00:41:58,800 --> 00:42:04,380
hope that hasn't broken the AV stuff um

00:42:01,880 --> 00:42:06,780
yeah so I think that's I think that's

00:42:04,380 --> 00:42:10,100
all the time we have yes thank you very

00:42:06,780 --> 00:42:10,100
much Chris great thank you

00:42:18,860 --> 00:42:20,920

YouTube URL: https://www.youtube.com/watch?v=1i5leCslA4g


