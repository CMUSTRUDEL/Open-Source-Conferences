Title: Inviting Code by Capel Brunker
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Projects tend to grow, expand and reshape as they progress, this can lead to; high code maintenance, legacy code and feature addition fatigue. Implementing a well-documented and malleable software architecture is a major step in addressing these associated time sinks. This talk will discuss viable software architecture approaches – while demonstrating core python modules, concepts and design patterns from a big data perspective.

Many projects welcome code addition from third party developers, however a well thought out software architecture should not be modified without; review, testing, possible cascading code and documentation changes. To remove the additional complexity of reviewing and handling third party code, designing and offering secure plugin infrastructure can allow for outside additions without the overhead. 

A big data visualisation python project utilised by Oxford and Cambridge universities will be used in code demonstrations to show the direct use of a project built with architecture design in mind, and a multi-level dynamic plugin infrastructure. Attendees will be provided with a clear understanding of how function documentation techniques (PEP-3107 & PEP-0484) can be utilised for class clarity and how to (re)design a code base to allow for integration of third party code, while providing a concise framework for code inclusion. 

Areas covered in this talk include

• Python 3.4 focused
• Project architecture design
• Abstract classes
• Plugin frameworks
• Documentation frameworks
• Type hinting & Function annotations  
• Class method decorators
• Code validation
• Image manipulation


PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,490 --> 00:00:16,470
alright we might get started so this

00:00:14,460 --> 00:00:18,270
morning we have cable Bronco who has

00:00:16,470 --> 00:00:20,070
focused on core design concepts to

00:00:18,270 --> 00:00:22,050
provide scalable efficient and robust

00:00:20,070 --> 00:00:24,390
software solutions today he'll be

00:00:22,050 --> 00:00:33,930
talking to us about inviting Co get up

00:00:24,390 --> 00:00:37,320
for him hey everyone so yeah inviting

00:00:33,930 --> 00:00:39,180
code the idea for this talk is to turn

00:00:37,320 --> 00:00:40,380
your product or if your product is

00:00:39,180 --> 00:00:42,150
probably already like this in you don't

00:00:40,380 --> 00:00:43,920
worry but hopefully that you'll take

00:00:42,150 --> 00:00:48,600
something from this talk to turn your

00:00:43,920 --> 00:00:50,790
product into an easy piece of framework

00:00:48,600 --> 00:00:52,290
that other people can utilize that but

00:00:50,790 --> 00:00:53,850
that will allow other developers to

00:00:52,290 --> 00:00:55,770
quickly have a look at your product know

00:00:53,850 --> 00:00:58,590
exactly what they're going to be doing

00:00:55,770 --> 00:01:02,310
when writing a plug-in or a feature and

00:00:58,590 --> 00:01:06,600
then getting to it so we'll see how this

00:01:02,310 --> 00:01:09,329
develops there is a brief code example

00:01:06,600 --> 00:01:13,620
in this talk and that's some from sagami

00:01:09,329 --> 00:01:18,600
which is a metadata project funded by

00:01:13,620 --> 00:01:22,650
Oxford University so I'm sure we've all

00:01:18,600 --> 00:01:24,690
we've all had this problem in projects

00:01:22,650 --> 00:01:27,870
you run into complications when you have

00:01:24,690 --> 00:01:30,720
a slightly complex system and you're

00:01:27,870 --> 00:01:32,430
taking in code input from other areas

00:01:30,720 --> 00:01:34,409
from people that aren't a part of your

00:01:32,430 --> 00:01:36,240
core development team or perhaps are

00:01:34,409 --> 00:01:38,700
juniors in your core development team

00:01:36,240 --> 00:01:42,390
and that means code reviews merging

00:01:38,700 --> 00:01:44,880
possibly rejecting code and also

00:01:42,390 --> 00:01:46,920
ensuring that that the code is up to

00:01:44,880 --> 00:01:49,409
snuff basically whether it follows your

00:01:46,920 --> 00:01:51,810
formatting requirements or not the poll

00:01:49,409 --> 00:01:53,790
back-and-forth obviously code reviews

00:01:51,810 --> 00:01:56,369
can be used to mentor juniors but this

00:01:53,790 --> 00:02:01,320
is more about a code review on

00:01:56,369 --> 00:02:03,780
externally created code so and then also

00:02:01,320 --> 00:02:04,860
we run into the problem of feature

00:02:03,780 --> 00:02:06,960
additional requests whether they're

00:02:04,860 --> 00:02:09,269
coming from project managers or from

00:02:06,960 --> 00:02:11,909
clients in general wanting various

00:02:09,269 --> 00:02:13,470
features wanting them now or just people

00:02:11,909 --> 00:02:15,650
in general who are using your product

00:02:13,470 --> 00:02:18,659
wanting features ready and available

00:02:15,650 --> 00:02:20,279
when you don't have the time allocated

00:02:18,659 --> 00:02:23,340
or it's just not in your current

00:02:20,279 --> 00:02:25,769
timeline so with these was we were seen

00:02:23,340 --> 00:02:27,690
various open source examples where

00:02:25,769 --> 00:02:29,069
project porking starts to happen because

00:02:27,690 --> 00:02:33,030
people want those features they want

00:02:29,069 --> 00:02:34,860
them now but the core developers just

00:02:33,030 --> 00:02:36,569
don't have the time for it so the

00:02:34,860 --> 00:02:38,220
project gets forked then you get this

00:02:36,569 --> 00:02:41,040
fragmented structure where you have

00:02:38,220 --> 00:02:44,280
multiple projects with similar features

00:02:41,040 --> 00:02:45,690
and the user bases then spread across

00:02:44,280 --> 00:02:48,450
because they're trying to get all the

00:02:45,690 --> 00:02:50,849
different features when you're also

00:02:48,450 --> 00:02:52,590
incorporating code whether from third

00:02:50,849 --> 00:02:53,730
party or not into your core product

00:02:52,590 --> 00:02:56,310
because you need those additional

00:02:53,730 --> 00:02:59,940
features you're creating a more complex

00:02:56,310 --> 00:03:01,950
code base and that also leads to the

00:02:59,940 --> 00:03:03,720
problem of more features more

00:03:01,950 --> 00:03:05,400
documentation more features more unit

00:03:03,720 --> 00:03:07,079
testing and whether or not you have a

00:03:05,400 --> 00:03:08,640
fantastic work place that allows you to

00:03:07,079 --> 00:03:11,360
spend as much time is required on

00:03:08,640 --> 00:03:15,840
testing frameworks and documentation is

00:03:11,360 --> 00:03:17,129
really the relevant point so what if we

00:03:15,840 --> 00:03:19,560
could just remove all those obstacles

00:03:17,129 --> 00:03:21,870
what if we have code edition without

00:03:19,560 --> 00:03:23,730
review what if we could just add

00:03:21,870 --> 00:03:25,530
features willingly into the product and

00:03:23,730 --> 00:03:27,329
the core developers don't really need to

00:03:25,530 --> 00:03:29,250
know about it that don't need to care

00:03:27,329 --> 00:03:32,160
about it it's just the feature that gets

00:03:29,250 --> 00:03:34,079
added everyone's happy if all the

00:03:32,160 --> 00:03:36,389
features get added then your code

00:03:34,079 --> 00:03:38,459
forking only approach walking is not

00:03:36,389 --> 00:03:41,069
really an issue anymore because your

00:03:38,459 --> 00:03:42,900
project has the features it's not as

00:03:41,069 --> 00:03:44,910
though your project is lacking the

00:03:42,900 --> 00:03:47,280
features and somebody's then forking

00:03:44,910 --> 00:03:48,900
your project together features that's

00:03:47,280 --> 00:03:50,400
just done because you're not rejecting

00:03:48,900 --> 00:03:51,660
code anymore you're not worrying about

00:03:50,400 --> 00:03:54,480
the cobra view you don't have that

00:03:51,660 --> 00:03:55,889
overhead and the use cases and

00:03:54,480 --> 00:03:57,419
documentation well they'll just take

00:03:55,889 --> 00:04:04,530
care of themselves they don't need to

00:03:57,419 --> 00:04:06,840
worry about it will just be done so how

00:04:04,530 --> 00:04:08,760
do we create this solution that

00:04:06,840 --> 00:04:11,970
automatically take kids care of itself

00:04:08,760 --> 00:04:14,790
and the idea here is to segment your

00:04:11,970 --> 00:04:16,410
core product from your features so

00:04:14,790 --> 00:04:18,810
essentially you have your core

00:04:16,410 --> 00:04:22,349
application and in areas where you think

00:04:18,810 --> 00:04:27,840
there's going to be feature addition you

00:04:22,349 --> 00:04:31,200
start creating say a framework structure

00:04:27,840 --> 00:04:32,370
for it they can be modified and then

00:04:31,200 --> 00:04:34,169
you've got a nice will flow chart here

00:04:32,370 --> 00:04:36,819
obviously

00:04:34,169 --> 00:04:38,830
the great thing about this is that when

00:04:36,819 --> 00:04:41,229
a plug-in developer decides that they

00:04:38,830 --> 00:04:43,090
want a new feature for your product they

00:04:41,229 --> 00:04:44,889
go ahead and create it and it's now

00:04:43,090 --> 00:04:47,050
their problem to do the proper

00:04:44,889 --> 00:04:49,449
documentation to do the testing to do

00:04:47,050 --> 00:04:50,710
the stability to do to make sure that it

00:04:49,449 --> 00:04:53,259
works with everything else in your

00:04:50,710 --> 00:04:56,199
system hopefully through unit tests and

00:04:53,259 --> 00:04:58,780
if anybody has any questions they can

00:04:56,199 --> 00:05:00,729
ask that developer directly it's no

00:04:58,780 --> 00:05:03,250
longer the responsibility of your core

00:05:00,729 --> 00:05:05,319
development team for this feature that

00:05:03,250 --> 00:05:07,990
this person has created or that was

00:05:05,319 --> 00:05:09,699
perhaps on your timeline and now you

00:05:07,990 --> 00:05:11,680
just have a third party taking care of

00:05:09,699 --> 00:05:13,900
that problem for you yes that may create

00:05:11,680 --> 00:05:16,689
some additional problems if they don't

00:05:13,900 --> 00:05:18,849
have very good developers or they don't

00:05:16,689 --> 00:05:20,229
have very good documentation then their

00:05:18,849 --> 00:05:23,919
products not going to get used but if it

00:05:20,229 --> 00:05:26,740
is a product or a feature that is being

00:05:23,919 --> 00:05:28,960
used heavily that isn't written well or

00:05:26,740 --> 00:05:30,189
has bad documentation your core

00:05:28,960 --> 00:05:32,349
developers can then put that on their

00:05:30,189 --> 00:05:34,419
timeline and they can implement their

00:05:32,349 --> 00:05:37,029
own version that will be supported but

00:05:34,419 --> 00:05:38,830
it gives you the option to say new

00:05:37,029 --> 00:05:40,270
feature go for it creator is your

00:05:38,830 --> 00:05:44,020
responsibility if it works it works

00:05:40,270 --> 00:05:45,190
fantastic if it doesn't so be it so

00:05:44,020 --> 00:05:47,669
that's where we come into the plug-in

00:05:45,190 --> 00:05:47,669
framework

00:05:52,750 --> 00:05:58,000
so creating the plug-in infrastructure

00:05:54,490 --> 00:06:01,240
to allow the this segmentation is can be

00:05:58,000 --> 00:06:04,360
done with the inbuilt Python tools that

00:06:01,240 --> 00:06:06,400
are available to us with the simple

00:06:04,360 --> 00:06:07,720
solutions like using abstract classes to

00:06:06,400 --> 00:06:11,980
enforce the methods of your framework

00:06:07,720 --> 00:06:14,200
and to have an abstract class for each

00:06:11,980 --> 00:06:16,030
or abstract classes for each of the

00:06:14,200 --> 00:06:19,750
feature areas that you have segmented

00:06:16,030 --> 00:06:22,000
across and the idea here is to make

00:06:19,750 --> 00:06:23,890
things as self document itself

00:06:22,000 --> 00:06:25,330
documented as possible so that I have to

00:06:23,890 --> 00:06:26,919
go to X Dental Solutions they can look

00:06:25,330 --> 00:06:31,540
at the code themselves to work out

00:06:26,919 --> 00:06:34,330
exactly what the methods do what the use

00:06:31,540 --> 00:06:36,190
cases are as in what methods get

00:06:34,330 --> 00:06:38,800
executed where and in what order or if

00:06:36,190 --> 00:06:40,950
they're standalone and also you know

00:06:38,800 --> 00:06:43,000
providing decent examples of your own

00:06:40,950 --> 00:06:46,800
plug-in infrastructure is also going to

00:06:43,000 --> 00:06:48,880
be helpful when they're working examples

00:06:46,800 --> 00:06:52,480
so I've just got a little note here that

00:06:48,880 --> 00:06:54,610
says abstract classes in fourth methods

00:06:52,480 --> 00:06:55,990
for instantiated objects only so if

00:06:54,610 --> 00:06:57,490
you're actually utilizing a single

00:06:55,990 --> 00:06:59,410
turnin you're not creating an object of

00:06:57,490 --> 00:07:02,200
the class that you're not going to have

00:06:59,410 --> 00:07:05,310
that enforcement happen it's just you

00:07:02,200 --> 00:07:08,680
can use the the class methods directly

00:07:05,310 --> 00:07:09,940
so as I was talking about a segmentation

00:07:08,680 --> 00:07:11,770
of the core product from the core

00:07:09,940 --> 00:07:16,120
feature so this is an example of the

00:07:11,770 --> 00:07:20,169
Zerg army product where the areas were

00:07:16,120 --> 00:07:21,520
defined that would be dynamic or that

00:07:20,169 --> 00:07:24,190
could have additional features so

00:07:21,520 --> 00:07:27,610
authentication for example now has a

00:07:24,190 --> 00:07:29,410
ldap support so you can you can

00:07:27,610 --> 00:07:32,530
authenticate users against active

00:07:29,410 --> 00:07:34,450
directory and openldap or AAF which is

00:07:32,530 --> 00:07:37,660
utilized by universities across

00:07:34,450 --> 00:07:39,640
Australia and elsewhere and a standalone

00:07:37,660 --> 00:07:42,970
localized solution and you can basically

00:07:39,640 --> 00:07:46,080
just load these up as need be through a

00:07:42,970 --> 00:07:49,210
configuration file or or similar and

00:07:46,080 --> 00:07:51,070
some other areas also segmented for

00:07:49,210 --> 00:07:52,630
processing and metadata collection and

00:07:51,070 --> 00:07:54,520
things like that grabbing directly from

00:07:52,630 --> 00:07:58,240
a database or grabbing from file system

00:07:54,520 --> 00:08:00,040
or doing whatever needs to be done this

00:07:58,240 --> 00:08:03,789
example is just showing where those

00:08:00,040 --> 00:08:05,500
areas were singled out that would be

00:08:03,789 --> 00:08:06,400
dynamic that people would want to want

00:08:05,500 --> 00:08:08,169
to change

00:08:06,400 --> 00:08:10,270
and then creating it into a into a

00:08:08,169 --> 00:08:12,370
plugin structure and this has been done

00:08:10,270 --> 00:08:14,620
in other areas such as image libraries

00:08:12,370 --> 00:08:21,520
utilizing bits or utilizing peel

00:08:14,620 --> 00:08:22,870
directly so this leads me to function

00:08:21,520 --> 00:08:24,400
annotations because we're talking about

00:08:22,870 --> 00:08:25,750
class creation now we're talking about

00:08:24,400 --> 00:08:28,660
the creation of the framework that

00:08:25,750 --> 00:08:30,130
people are going to use so function

00:08:28,660 --> 00:08:33,279
invitations I think we're introduced in

00:08:30,130 --> 00:08:40,000
Python 3.0 they're not really heavily

00:08:33,279 --> 00:08:43,330
utilized however they do offer a lead-in

00:08:40,000 --> 00:08:46,089
to what is a big step forward in this

00:08:43,330 --> 00:08:48,070
type of area in part and 3.5 called type

00:08:46,089 --> 00:08:49,480
hints which we'll get to later so

00:08:48,070 --> 00:08:52,390
function annotations basically allow you

00:08:49,480 --> 00:08:53,800
to quickly express what a parameter is

00:08:52,390 --> 00:08:56,380
going to be and what a return type is

00:08:53,800 --> 00:08:58,930
going to be in the code so we'll just

00:08:56,380 --> 00:09:01,110
have a quick look at some code examples

00:08:58,930 --> 00:09:01,110
here

00:09:10,120 --> 00:09:15,170
so this is just a normal standard class

00:09:13,310 --> 00:09:20,600
that you could call a parent class for

00:09:15,170 --> 00:09:22,009
those classes going to be used as you

00:09:20,600 --> 00:09:27,379
can see it's got a normal constructor

00:09:22,009 --> 00:09:29,269
it's got a class method there's not much

00:09:27,379 --> 00:09:31,370
to say about it it's got two docstrings

00:09:29,269 --> 00:09:33,170
as any decent class should have it talks

00:09:31,370 --> 00:09:35,240
about the parameters the return types as

00:09:33,170 --> 00:09:36,860
well some places that talks about that

00:09:35,240 --> 00:09:37,910
it's going to be returning a dict some

00:09:36,860 --> 00:09:40,910
places just saying you know i'm

00:09:37,910 --> 00:09:43,160
returning an iterable container and it's

00:09:40,910 --> 00:09:45,139
fairly fast and loose with how it's

00:09:43,160 --> 00:09:47,180
actually operating you know it's more up

00:09:45,139 --> 00:09:48,980
to the developer to kind of work out

00:09:47,180 --> 00:09:51,410
exactly what's going to be returned

00:09:48,980 --> 00:09:56,899
unless there's a an exact example in the

00:09:51,410 --> 00:10:12,170
doc string so if we go from this example

00:09:56,899 --> 00:10:14,449
to to an annotated example we can see a

00:10:12,170 --> 00:10:16,970
few minor differences first of all this

00:10:14,449 --> 00:10:18,889
is inheriting them at a class of ABC

00:10:16,970 --> 00:10:21,980
metadata ABC being the abstract class

00:10:18,889 --> 00:10:25,009
module inheriting that it can use

00:10:21,980 --> 00:10:28,040
abstract class methods as you can see

00:10:25,009 --> 00:10:29,720
here as a decorator alexis means as i

00:10:28,040 --> 00:10:32,600
talked about previously when you create

00:10:29,720 --> 00:10:34,790
the class object it just checks to make

00:10:32,600 --> 00:10:36,470
sure that every single track class from

00:10:34,790 --> 00:10:43,850
the parent has actually been defined in

00:10:36,470 --> 00:10:46,459
the child so this is what I was leading

00:10:43,850 --> 00:10:52,670
to with the function annotations is the

00:10:46,459 --> 00:10:54,980
simple code addition of colon type you

00:10:52,670 --> 00:10:59,449
can easily just say this is going to be

00:10:54,980 --> 00:11:01,790
a string simple now people know directly

00:10:59,449 --> 00:11:03,050
that this parameter is a string or is

00:11:01,790 --> 00:11:08,930
expected to be a string it's not

00:11:03,050 --> 00:11:12,350
enforced and here in the validation in

00:11:08,930 --> 00:11:14,439
class method it's expected the fields

00:11:12,350 --> 00:11:17,540
parameter is expected to be a debt and

00:11:14,439 --> 00:11:20,310
it's also expected to return a dictum

00:11:17,540 --> 00:11:23,400
the syntax here is just so easy

00:11:20,310 --> 00:11:24,690
that it begs the question why not do it

00:11:23,400 --> 00:11:29,090
if unless you've got a completely

00:11:24,690 --> 00:11:32,370
dynamic object why not express in the in

00:11:29,090 --> 00:11:35,130
the method signature exactly what the

00:11:32,370 --> 00:11:42,240
parameter and the return type is makes

00:11:35,130 --> 00:11:47,760
sense now these are basic types that can

00:11:42,240 --> 00:11:49,529
be showin easily see here the parameter

00:11:47,760 --> 00:11:51,510
says just a niche borel of dictionaries

00:11:49,529 --> 00:11:52,890
containing that you can you can see here

00:11:51,510 --> 00:11:55,680
that actually needs to be a mutable

00:11:52,890 --> 00:12:00,029
iterable being a list not a couple or a

00:11:55,680 --> 00:12:02,310
set or frozen set so this is this is

00:12:00,029 --> 00:12:04,560
just the the comparative example against

00:12:02,310 --> 00:12:07,740
the base the base class that we showed

00:12:04,560 --> 00:12:09,390
and now the annotated class it's not

00:12:07,740 --> 00:12:12,330
that much extra information it doesn't

00:12:09,390 --> 00:12:14,310
take time to to write but its expressive

00:12:12,330 --> 00:12:16,500
you can allow people to quickly

00:12:14,310 --> 00:12:22,860
understand what you're expecting to be

00:12:16,500 --> 00:12:28,290
returned so if we actually go into a

00:12:22,860 --> 00:12:31,380
child class example you can even get

00:12:28,290 --> 00:12:36,920
further information from the function

00:12:31,380 --> 00:12:39,240
annotations because it creates a private

00:12:36,920 --> 00:12:43,100
attribute that can be obtained but

00:12:39,240 --> 00:12:46,140
anyways so this is the example of a

00:12:43,100 --> 00:12:49,470
child plug-in or a plug-in using the the

00:12:46,140 --> 00:12:55,050
engine itself it just implements the the

00:12:49,470 --> 00:12:58,230
abstract methods as required and this is

00:12:55,050 --> 00:12:59,850
just a quick example of of functional

00:12:58,230 --> 00:13:01,910
notation with also with the default

00:12:59,850 --> 00:13:01,910
value

00:13:05,720 --> 00:13:13,350
so when using a decent ide like for

00:13:10,559 --> 00:13:16,290
example PyCharm it will actually inspect

00:13:13,350 --> 00:13:19,290
the class for you so in the validation

00:13:16,290 --> 00:13:22,470
method the validation method itself is

00:13:19,290 --> 00:13:24,569
expecting let's have a quick look the

00:13:22,470 --> 00:13:27,359
validation method itself for the field

00:13:24,569 --> 00:13:29,220
value is expecting a deep so when

00:13:27,359 --> 00:13:30,299
somebody's writing code for it and they

00:13:29,220 --> 00:13:32,399
decide they're gonna put it in the list

00:13:30,299 --> 00:13:34,379
they'll at least be notified the

00:13:32,399 --> 00:13:37,160
expected type is addicting in the list

00:13:34,379 --> 00:13:40,189
you're probably gonna end up with issues

00:13:37,160 --> 00:13:42,720
the same with the constructor was

00:13:40,189 --> 00:13:44,609
expecting a string you're putting an int

00:13:42,720 --> 00:13:46,769
you're going to get a little warning no

00:13:44,609 --> 00:13:50,269
it's just helpful development tools

00:13:46,769 --> 00:13:52,799
integrated into the IDE that lead into a

00:13:50,269 --> 00:13:55,970
function notation and type hinting here

00:13:52,799 --> 00:13:59,389
for example obviously that's a valid

00:13:55,970 --> 00:14:03,239
object to be passed now the interesting

00:13:59,389 --> 00:14:04,949
side effect of this is for example here

00:14:03,239 --> 00:14:06,809
we're concatenate in a string with

00:14:04,949 --> 00:14:09,179
what's returned from delete now delete

00:14:06,809 --> 00:14:11,129
returns a in the functional notation

00:14:09,179 --> 00:14:14,519
returns a boolean value so it's saying

00:14:11,129 --> 00:14:16,470
look we you're expecting a string but

00:14:14,519 --> 00:14:18,539
you've got type all instead you're going

00:14:16,470 --> 00:14:23,579
to have a bit of a problem if we go up

00:14:18,539 --> 00:14:25,819
to the method itself we can see that the

00:14:23,579 --> 00:14:27,899
method is actually returning a string

00:14:25,819 --> 00:14:29,429
but that's not what the IDE is

00:14:27,899 --> 00:14:31,949
representing it's saying no well

00:14:29,429 --> 00:14:33,749
actually the framework itself is stating

00:14:31,949 --> 00:14:35,339
that you should be returning a ball so

00:14:33,749 --> 00:14:38,100
even though you're doing the wrong thing

00:14:35,339 --> 00:14:39,899
in your class it's going to show up when

00:14:38,100 --> 00:14:44,369
you're writing your code elsewhere in

00:14:39,899 --> 00:14:48,029
your unit tests or otherwise so the

00:14:44,369 --> 00:14:51,059
annotation syntax has a precedent over

00:14:48,029 --> 00:14:52,980
the actual return value itself allowing

00:14:51,059 --> 00:14:55,980
that cascading effect from your

00:14:52,980 --> 00:15:07,529
framework to their plug-in to their

00:14:55,980 --> 00:15:11,459
tests to their usage so now that we have

00:15:07,529 --> 00:15:13,739
a framework and we have plugins and we

00:15:11,459 --> 00:15:16,799
have potentially plugins that we don't

00:15:13,739 --> 00:15:18,989
know nothing about that could break

00:15:16,799 --> 00:15:20,129
onload they could have all sorts of

00:15:18,989 --> 00:15:22,169
problems then you have to have a little

00:15:20,129 --> 00:15:24,449
bit more structure than possibly just

00:15:22,169 --> 00:15:27,359
the class itself so you have a plugin

00:15:24,449 --> 00:15:32,189
manager and the plugin manager has quite

00:15:27,359 --> 00:15:34,409
an important job you can verify various

00:15:32,189 --> 00:15:36,480
module module attributes and I think in

00:15:34,409 --> 00:15:38,069
the example that I showed it had some

00:15:36,480 --> 00:15:40,439
attributes such as the version number

00:15:38,069 --> 00:15:43,859
the brief description which could feed

00:15:40,439 --> 00:15:46,019
into a web sweep list or something like

00:15:43,859 --> 00:15:49,079
that or for example the plugin manager

00:15:46,019 --> 00:15:51,029
could look at the module itself and say

00:15:49,079 --> 00:15:52,559
hey you've actually got a newer version

00:15:51,029 --> 00:15:54,209
available because that's what we're

00:15:52,559 --> 00:15:56,519
seeing would you like to load that in

00:15:54,209 --> 00:16:01,649
place in memory of what we've currently

00:15:56,519 --> 00:16:03,499
got and it can also ensure that the

00:16:01,649 --> 00:16:05,759
required abstract classes actually

00:16:03,499 --> 00:16:07,679
utilized by the plug-in because what's

00:16:05,759 --> 00:16:08,759
stopping somebody from saying I'm not

00:16:07,679 --> 00:16:10,679
really going to use your framework I'm

00:16:08,759 --> 00:16:13,859
not going to use your your abstract are

00:16:10,679 --> 00:16:15,480
so I'm just going to just Chuck in my

00:16:13,859 --> 00:16:17,399
own inheriting anything and you're going

00:16:15,480 --> 00:16:19,859
to load it well you could theoretically

00:16:17,399 --> 00:16:21,899
have a the manager inspect the parent

00:16:19,859 --> 00:16:24,809
class to ensure that it that you are

00:16:21,899 --> 00:16:27,929
loading say an image source plugin that

00:16:24,809 --> 00:16:29,939
it is inheriting from the abstract

00:16:27,929 --> 00:16:33,089
method in your framework for image

00:16:29,939 --> 00:16:35,789
plugins you can enforce all of these

00:16:33,089 --> 00:16:39,109
additional checks to make sure that your

00:16:35,789 --> 00:16:42,749
your plug-in is essentially a valid one

00:16:39,109 --> 00:16:45,509
and of course the plugin manager is

00:16:42,749 --> 00:16:46,889
there to ensure that when you load the

00:16:45,509 --> 00:16:50,730
plugin if there's something horrible

00:16:46,889 --> 00:16:53,339
like a syntax problem or something

00:16:50,730 --> 00:16:54,839
stopping it from loading at least it's

00:16:53,339 --> 00:16:56,129
going to basically catch it it's going

00:16:54,839 --> 00:16:58,619
to log it and it's not going to cause

00:16:56,129 --> 00:17:01,439
your problem to fail your your system to

00:16:58,619 --> 00:17:05,689
fail so safe plugin loading is a pretty

00:17:01,439 --> 00:17:05,689
important aspect of the plugin manager

00:17:07,310 --> 00:17:13,430
and this leads into plug-in security

00:17:10,760 --> 00:17:16,730
which i think is a interesting aspect

00:17:13,430 --> 00:17:18,800
because it's from what I've seen on the

00:17:16,730 --> 00:17:23,120
enterprise level for python that doesn't

00:17:18,800 --> 00:17:25,790
seem to be much focus on security for

00:17:23,120 --> 00:17:28,240
code then you have investors talking

00:17:25,790 --> 00:17:32,720
about our but people can see your code

00:17:28,240 --> 00:17:36,500
so what what you can actually offer here

00:17:32,720 --> 00:17:38,030
are things like um digital signatures

00:17:36,500 --> 00:17:42,050
for plugins and having a list of

00:17:38,030 --> 00:17:46,070
registered developers and checking the

00:17:42,050 --> 00:17:48,440
signature of the modules unload and not

00:17:46,070 --> 00:17:51,290
loading them based on whether they exist

00:17:48,440 --> 00:17:52,790
in your signature vault or just showing

00:17:51,290 --> 00:17:56,240
you know how you're loading a and

00:17:52,790 --> 00:17:59,090
unregistered or insecure a possibly

00:17:56,240 --> 00:18:00,650
insecure plug-in and you can do that

00:17:59,090 --> 00:18:07,180
utilizing whatever digital signature

00:18:00,650 --> 00:18:10,400
algorithm you one GP GP GP nacl library

00:18:07,180 --> 00:18:14,330
so in order to do this sort of

00:18:10,400 --> 00:18:15,560
additional security you can do something

00:18:14,330 --> 00:18:18,020
pretty cool with the newer versions of

00:18:15,560 --> 00:18:22,820
Python in Python 3 you can create your

00:18:18,020 --> 00:18:25,700
own importer essentially so when you

00:18:22,820 --> 00:18:29,110
type the statement import Bob's plug-in

00:18:25,700 --> 00:18:32,270
it utilizes the internal importer

00:18:29,110 --> 00:18:33,590
modules to handle all of that but you

00:18:32,270 --> 00:18:36,470
can actually override them or insert

00:18:33,590 --> 00:18:41,930
your own so you can you could have your

00:18:36,470 --> 00:18:45,770
own sauceless module loader load modules

00:18:41,930 --> 00:18:48,830
directly from a Redis database stored in

00:18:45,770 --> 00:18:51,020
there you could have your your

00:18:48,830 --> 00:18:53,030
customized loader verify signatures of

00:18:51,020 --> 00:18:56,180
the source code before actually loading

00:18:53,030 --> 00:19:00,020
it and handling it however you want and

00:18:56,180 --> 00:19:02,690
you can also goes far if you want to

00:19:00,020 --> 00:19:06,140
encrypt the modules and have your own

00:19:02,690 --> 00:19:09,020
customized format or have your own open

00:19:06,140 --> 00:19:11,180
format but just with a lot of say

00:19:09,020 --> 00:19:13,190
documentation at the start in built into

00:19:11,180 --> 00:19:15,590
the actual file itself although that's

00:19:13,190 --> 00:19:17,210
not going to pass any tests that you run

00:19:15,590 --> 00:19:19,340
directly just using Python itself you

00:19:17,210 --> 00:19:21,120
have to use your in build loader in

00:19:19,340 --> 00:19:30,330
order to load the module

00:19:21,120 --> 00:19:33,390
so that's pretty cool stuff I reckon so

00:19:30,330 --> 00:19:36,530
I briefly touched on type hints when I

00:19:33,390 --> 00:19:43,430
was talking about function annotations

00:19:36,530 --> 00:19:48,410
type hints are the whole new world of of

00:19:43,430 --> 00:19:52,530
statically laying out how your framework

00:19:48,410 --> 00:19:54,690
is supposed to be used now I know that a

00:19:52,530 --> 00:19:58,170
lot of Python developers aren't really

00:19:54,690 --> 00:20:01,140
too fond of static typing and you know I

00:19:58,170 --> 00:20:03,710
think every there's always a the right

00:20:01,140 --> 00:20:06,210
tool for the job and in some cases

00:20:03,710 --> 00:20:10,320
static typing is actually probably a

00:20:06,210 --> 00:20:11,910
good thing in a restrictive environment

00:20:10,320 --> 00:20:15,980
such as a framework that you want to

00:20:11,910 --> 00:20:20,520
want people to develop with then using

00:20:15,980 --> 00:20:24,090
static typing twin force parameter types

00:20:20,520 --> 00:20:28,020
or to enforce return types can actually

00:20:24,090 --> 00:20:31,260
make help maintain a nice plug-in

00:20:28,020 --> 00:20:33,480
environment make sure everything works

00:20:31,260 --> 00:20:35,010
whether it's supposed to work and that

00:20:33,480 --> 00:20:37,110
way you can you don't have to worry so

00:20:35,010 --> 00:20:39,300
much about people making plugin because

00:20:37,110 --> 00:20:41,910
it's their business they have to do it a

00:20:39,300 --> 00:20:45,140
particular way it's going to adhere to

00:20:41,910 --> 00:20:49,500
your standards just let it do its thing

00:20:45,140 --> 00:20:51,990
so the functional notation syntax

00:20:49,500 --> 00:20:52,950
basically lives directly onto how type

00:20:51,990 --> 00:20:54,920
in it's going to work so you can

00:20:52,950 --> 00:20:58,920
implement function annotations now

00:20:54,920 --> 00:21:01,620
utilizing times and then in Python 3.5

00:20:58,920 --> 00:21:05,340
when type goons come out you can roll

00:21:01,620 --> 00:21:08,160
over it's a tie pins quite easily and it

00:21:05,340 --> 00:21:10,530
is like i said it's it's whole you could

00:21:08,160 --> 00:21:12,840
have a two-hour tour kantai pins the way

00:21:10,530 --> 00:21:14,760
that they've actually designed it it's

00:21:12,840 --> 00:21:18,150
quite large so have a look at the pep if

00:21:14,760 --> 00:21:21,380
you have time the it allows you to

00:21:18,150 --> 00:21:23,640
instead of having a say multiple

00:21:21,380 --> 00:21:25,320
multiple class methods with different

00:21:23,640 --> 00:21:26,970
signatures because you want to have

00:21:25,320 --> 00:21:28,650
different return different parameter

00:21:26,970 --> 00:21:30,690
types you can actually just use the type

00:21:28,650 --> 00:21:34,260
of our class that allows you to say this

00:21:30,690 --> 00:21:35,140
parameter can be an int or a string but

00:21:34,260 --> 00:21:37,930
only those two three

00:21:35,140 --> 00:21:40,090
you know you can have some dynamic

00:21:37,930 --> 00:21:43,420
capabilities in there even though it is

00:21:40,090 --> 00:21:46,990
statically typed the typing module

00:21:43,420 --> 00:21:49,570
itself is very interesting it allows you

00:21:46,990 --> 00:21:53,820
to essentially create your own templates

00:21:49,570 --> 00:21:56,320
of objects and then we'll inspect the

00:21:53,820 --> 00:21:59,770
object part of the parameter based on

00:21:56,320 --> 00:22:03,280
the template that you create which is

00:21:59,770 --> 00:22:05,500
pretty cool so for everybody who didn't

00:22:03,280 --> 00:22:07,090
want to use Python because of static

00:22:05,500 --> 00:22:09,460
types well now they don't have that

00:22:07,090 --> 00:22:14,050
excuse because it is there if they want

00:22:09,460 --> 00:22:18,310
to use it so that's essentially the end

00:22:14,050 --> 00:22:22,000
of a talk my aim here was just to try

00:22:18,310 --> 00:22:25,390
and open up the possibility of allowing

00:22:22,000 --> 00:22:26,860
people to add to your projects without

00:22:25,390 --> 00:22:29,110
having to worry about them so much

00:22:26,860 --> 00:22:32,530
without having that overhead you know

00:22:29,110 --> 00:22:34,360
just having the the chance to say hey

00:22:32,530 --> 00:22:36,430
yeah sure if you want to write some

00:22:34,360 --> 00:22:37,990
weird bizarre thing go for it it's not

00:22:36,430 --> 00:22:39,790
going to affect your codebase it's just

00:22:37,990 --> 00:22:43,270
going to allow them to have this crazy

00:22:39,790 --> 00:22:44,950
feature so I don't I don't see why not

00:22:43,270 --> 00:22:46,150
allow them the flexibility to do what

00:22:44,950 --> 00:22:48,040
they want as long as it doesn't affect

00:22:46,150 --> 00:22:50,250
your core product as long as it doesn't

00:22:48,040 --> 00:22:52,150
increase the code complexity of your

00:22:50,250 --> 00:22:55,830
products as long as you don't have to

00:22:52,150 --> 00:22:59,620
write the bloody documentation for okay

00:22:55,830 --> 00:23:01,990
so that's that's what I wanted to put

00:22:59,620 --> 00:23:06,160
forward I hope i hope that came out as

00:23:01,990 --> 00:23:10,260
well as I intended and if you guys have

00:23:06,160 --> 00:23:10,260
any questions then please feel free

00:23:16,870 --> 00:23:31,370
do we have any questions yep I think for

00:23:27,440 --> 00:23:34,400
the talk um have you gone through with

00:23:31,370 --> 00:23:40,280
implementing and custom importer and was

00:23:34,400 --> 00:23:43,160
that as tricky as it sounds ah it's

00:23:40,280 --> 00:23:43,820
actually pretty straightforward I think

00:23:43,160 --> 00:23:47,800
they need a little bit more

00:23:43,820 --> 00:23:51,350
documentation it wasn't that hard what I

00:23:47,800 --> 00:23:53,930
did was actually what I talked about no

00:23:51,350 --> 00:23:57,230
implemented a encrypted module solution

00:23:53,930 --> 00:24:00,770
that so people can't easily view the

00:23:57,230 --> 00:24:03,560
source code essentially that decrypts

00:24:00,770 --> 00:24:05,810
the module on the fly and enforces that

00:24:03,560 --> 00:24:09,080
module that importer over every other

00:24:05,810 --> 00:24:12,500
importer and also validates the importer

00:24:09,080 --> 00:24:16,520
code in another area to ensure that my

00:24:12,500 --> 00:24:19,130
employer is what I think it is but the

00:24:16,520 --> 00:24:20,510
actual implementation itself it's once

00:24:19,130 --> 00:24:22,420
you once you just lay it out it's

00:24:20,510 --> 00:24:25,370
actually pretty simple and you can

00:24:22,420 --> 00:24:27,530
inherit from the multiple classes of is

00:24:25,370 --> 00:24:30,380
this going to be source code or is this

00:24:27,530 --> 00:24:32,270
going to be by a compiled code as well

00:24:30,380 --> 00:24:34,730
so you can choose whether you're only

00:24:32,270 --> 00:24:36,850
going to support source code based files

00:24:34,730 --> 00:24:41,600
or if you're going to also support

00:24:36,850 --> 00:24:42,560
binary bait base files as well so yeah I

00:24:41,600 --> 00:24:45,800
think it's easy enough i think you

00:24:42,560 --> 00:24:50,620
should go for it check it out anyone

00:24:45,800 --> 00:24:50,620
else yep

00:24:55,409 --> 00:25:02,919
okay quite a biker noob myself but I

00:24:59,529 --> 00:25:04,830
have looked at doing plug-in you've

00:25:02,919 --> 00:25:10,349
mentioned how you structure your

00:25:04,830 --> 00:25:13,089
interface with abstract base classes how

00:25:10,349 --> 00:25:15,070
it's maybe ask you a question but how do

00:25:13,089 --> 00:25:17,169
you get your program to detect what

00:25:15,070 --> 00:25:21,339
plugins are available or things like

00:25:17,169 --> 00:25:23,169
that you can do it through different

00:25:21,339 --> 00:25:25,059
ways I mean you can have a basic

00:25:23,169 --> 00:25:28,859
configuration file that's somebody that

00:25:25,059 --> 00:25:31,269
the sysadmin or your your web interface

00:25:28,859 --> 00:25:33,039
lists the plugins in you know using

00:25:31,269 --> 00:25:36,159
config parser it's a structured format

00:25:33,039 --> 00:25:38,049
you can say these are my my file system

00:25:36,159 --> 00:25:41,169
plugins or these are my image source

00:25:38,049 --> 00:25:42,729
plugins or authentication plugins or if

00:25:41,169 --> 00:25:45,219
you wanted to if you if you've got a

00:25:42,729 --> 00:25:47,049
structured a directory structure then

00:25:45,219 --> 00:25:49,149
you could just say you know plugins type

00:25:47,049 --> 00:25:52,239
and then to scan the directory to see

00:25:49,149 --> 00:25:53,139
what's in there yeah there's I think

00:25:52,239 --> 00:25:56,049
there's lots of ways just to

00:25:53,139 --> 00:25:57,460
automatically detect where the plugins

00:25:56,049 --> 00:25:59,950
are there it depends on how strict you

00:25:57,460 --> 00:26:01,479
want to be with with the plugins with

00:25:59,950 --> 00:26:03,099
versions like I talked about how you

00:26:01,479 --> 00:26:05,379
could have a look at the module and say

00:26:03,099 --> 00:26:06,729
this version number does it relate to

00:26:05,379 --> 00:26:09,009
the version number we're using in our

00:26:06,729 --> 00:26:10,599
configuration file we really want to

00:26:09,009 --> 00:26:19,210
load it if it's a newer one things could

00:26:10,599 --> 00:26:24,879
have changed yeah okay anyone else no

00:26:19,210 --> 00:26:28,450
all right well we've just got a token of

00:26:24,879 --> 00:26:30,940
thanks this is a pike on a you mug for

00:26:28,450 --> 00:26:33,539
2015 what we were right one more round

00:26:30,940 --> 00:26:33,539
of applause

00:26:41,850 --> 00:26:43,910

YouTube URL: https://www.youtube.com/watch?v=mByG_51ZWiQ


