Title: Is Python ready for the Enterprise? by Ryan Stuart
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	There seems to be an opinion among some developers that Python isn't suitable for Enterprise. To put it another way, Python is great for small tasks where a scripting language works well, but not so suitable for more complicated software stacks. This talk tries to address some of these concerns. Specifically, we will look at:

* Python Typing System for large code bases.
* Is the GIL a problem?
* The speed of Python execution.
* The speed of Python development.
* A case study: Caterpillar.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,690 --> 00:00:16,420
alright welcome so our last speaker for

00:00:13,839 --> 00:00:19,180
this block is ryan stewart his software

00:00:16,420 --> 00:00:21,130
engineer and CTO capiche and his talk is

00:00:19,180 --> 00:00:27,730
called his Python ready for the

00:00:21,130 --> 00:00:30,099
enterprise please welcome him thanks

00:00:27,730 --> 00:00:32,140
everybody hum as I just mentioned I'm a

00:00:30,099 --> 00:00:34,750
software engineer CTO of khepesh which

00:00:32,140 --> 00:00:36,370
is a Brisbane start-up doing text

00:00:34,750 --> 00:00:38,739
analytics more or less I've been running

00:00:36,370 --> 00:00:40,870
Python for seven years now before that I

00:00:38,739 --> 00:00:43,960
was writing Java thankfully not doing

00:00:40,870 --> 00:00:45,789
that anymore but because i'm going to

00:00:43,960 --> 00:00:47,980
start up i'm also writing JavaScript and

00:00:45,789 --> 00:00:50,260
other Webbie things which is great and

00:00:47,980 --> 00:00:51,640
some see as well but what I'm really

00:00:50,260 --> 00:00:54,039
interested in is kind of distributed

00:00:51,640 --> 00:00:56,469
computing and data based design and some

00:00:54,039 --> 00:00:57,850
other small things like rust and that's

00:00:56,469 --> 00:00:59,739
how you can contact me if you really

00:00:57,850 --> 00:01:02,889
want to what I want to talk about in

00:00:59,739 --> 00:01:04,720
this talk I want to have a crack it to

00:01:02,889 --> 00:01:06,729
find in what enterprise software is it's

00:01:04,720 --> 00:01:09,250
kind of a more conceptual thing than an

00:01:06,729 --> 00:01:10,659
absolute definition so bear with me talk

00:01:09,250 --> 00:01:13,210
a little bit about history of enterprise

00:01:10,659 --> 00:01:15,400
tools and some specific issues around

00:01:13,210 --> 00:01:17,080
using Python in the enterprise so at

00:01:15,400 --> 00:01:18,070
least what the perceived issues are and

00:01:17,080 --> 00:01:19,210
then I'm going to talk a little bit

00:01:18,070 --> 00:01:21,070
about something that I've written at

00:01:19,210 --> 00:01:25,510
Capisce which is basically a database in

00:01:21,070 --> 00:01:29,080
Python and now some questions so what is

00:01:25,510 --> 00:01:30,550
enterprise software well the simplest

00:01:29,080 --> 00:01:31,930
thing to say about it is it's usually

00:01:30,550 --> 00:01:33,490
written for an organization and not for

00:01:31,930 --> 00:01:36,040
an individual so might as well start

00:01:33,490 --> 00:01:37,660
there there's a good chance that it

00:01:36,040 --> 00:01:39,970
needs to interact with some old systems

00:01:37,660 --> 00:01:41,830
and probably some sort of enterprise

00:01:39,970 --> 00:01:43,230
authentication system like LDAP or

00:01:41,830 --> 00:01:45,730
Active Directory or something like that

00:01:43,230 --> 00:01:47,260
the design goals of the system and the

00:01:45,730 --> 00:01:49,840
requirements of the system will awfully

00:01:47,260 --> 00:01:51,070
often be extremely varied and I'll often

00:01:49,840 --> 00:01:53,170
come from a whole range of different

00:01:51,070 --> 00:01:57,460
places and some of those places won't be

00:01:53,170 --> 00:01:58,540
technical and there's other added

00:01:57,460 --> 00:02:01,030
complexities that you wouldn't usually

00:01:58,540 --> 00:02:02,920
get from standard projects like time

00:02:01,030 --> 00:02:05,080
complexities budgeting complexities

00:02:02,920 --> 00:02:06,550
usually the projects that projects are

00:02:05,080 --> 00:02:10,119
very long running and the scrutiny is

00:02:06,550 --> 00:02:12,010
very high because of Management and even

00:02:10,119 --> 00:02:13,510
in extreme cases some of the technology

00:02:12,010 --> 00:02:15,099
decisions especially around programming

00:02:13,510 --> 00:02:16,840
language and database are driven by

00:02:15,099 --> 00:02:18,010
non-technical people so that's something

00:02:16,840 --> 00:02:20,140
that you have to kind of contend with

00:02:18,010 --> 00:02:23,950
it's really her

00:02:20,140 --> 00:02:25,090
put in a mean something like that so

00:02:23,950 --> 00:02:28,270
what's the history of enterprise

00:02:25,090 --> 00:02:30,340
software so back in the 80s and 90s the

00:02:28,270 --> 00:02:32,350
usual suspects were pointing a term

00:02:30,340 --> 00:02:33,790
called enterprise grade and usually they

00:02:32,350 --> 00:02:37,560
are using that to refer to statically

00:02:33,790 --> 00:02:40,510
typed languages like Java C sharp etc

00:02:37,560 --> 00:02:42,459
other languages weren't consist one

00:02:40,510 --> 00:02:44,260
considered good enough or sophisticated

00:02:42,459 --> 00:02:46,360
enough to do these hard enterprise

00:02:44,260 --> 00:02:47,980
problems and to be fair back down that's

00:02:46,360 --> 00:02:50,580
probably a fair comment the ecosystems

00:02:47,980 --> 00:02:54,010
of Python Ruby etc weren't that great

00:02:50,580 --> 00:02:55,570
weren't that complete and the quality of

00:02:54,010 --> 00:03:00,790
the third party libraries also wasn't

00:02:55,570 --> 00:03:02,470
there but 2,000 came around the web got

00:03:00,790 --> 00:03:04,989
a lot bigger and more important and

00:03:02,470 --> 00:03:09,730
things in Python and Ruby etc changed

00:03:04,989 --> 00:03:11,800
significantly so today Python is really

00:03:09,730 --> 00:03:13,180
a batteries included language for a long

00:03:11,800 --> 00:03:14,650
time I don't think there's much argument

00:03:13,180 --> 00:03:16,360
that patents being considered one of the

00:03:14,650 --> 00:03:19,150
best clue languages available and by

00:03:16,360 --> 00:03:20,709
that I mean getting disparate services

00:03:19,150 --> 00:03:22,870
to talk to each other or getting stuff

00:03:20,709 --> 00:03:25,600
done on a server brilliant an A+

00:03:22,870 --> 00:03:27,519
scripting language but in recent times

00:03:25,600 --> 00:03:29,170
the standard library has increased the

00:03:27,519 --> 00:03:30,549
coverage and the quality of the standard

00:03:29,170 --> 00:03:31,930
libraries increased dramatically to the

00:03:30,549 --> 00:03:32,950
point now where you can probably say

00:03:31,930 --> 00:03:34,620
that it's one of the best standard

00:03:32,950 --> 00:03:37,750
libraries going around in any language

00:03:34,620 --> 00:03:40,360
when you add in third party tools on top

00:03:37,750 --> 00:03:43,019
of that for web frameworks science and

00:03:40,360 --> 00:03:46,930
data tools even distributed task tools

00:03:43,019 --> 00:03:51,430
then it's hard for enterprises to ignore

00:03:46,930 --> 00:03:52,959
platen these days so what barriers are

00:03:51,430 --> 00:03:55,959
there to using Python in the enterprise

00:03:52,959 --> 00:03:57,579
up like I said and just look at those

00:03:55,959 --> 00:03:59,530
logos gives you a general idea people

00:03:57,579 --> 00:04:01,030
are using Python for a range of tasks of

00:03:59,530 --> 00:04:02,739
what about enterprise tasks what about

00:04:01,030 --> 00:04:05,170
you know database tasks what about tasks

00:04:02,739 --> 00:04:06,579
that people traditionally say I need to

00:04:05,170 --> 00:04:09,370
use Java for this so i need to you see

00:04:06,579 --> 00:04:11,260
for this so one of the biggest barriers

00:04:09,370 --> 00:04:13,840
in a lot of people's minds is the fact

00:04:11,260 --> 00:04:15,280
that pythons dynamically typed and we

00:04:13,840 --> 00:04:17,500
could probably have a whole talk on

00:04:15,280 --> 00:04:18,970
dynamic vs static typing it's really a

00:04:17,500 --> 00:04:20,950
philosophical thing and probably the

00:04:18,970 --> 00:04:25,780
closest thing that computer science

00:04:20,950 --> 00:04:27,250
house or a religious war so just picked

00:04:25,780 --> 00:04:29,650
out some points here about each of the

00:04:27,250 --> 00:04:31,210
approaches with static typing you catch

00:04:29,650 --> 00:04:32,919
bugs earlier and they're easier to catch

00:04:31,210 --> 00:04:33,289
because when you compile your code you

00:04:32,919 --> 00:04:35,300
know

00:04:33,289 --> 00:04:38,419
goodings I powers they're not discovered

00:04:35,300 --> 00:04:40,249
at runtime the argument with static

00:04:38,419 --> 00:04:43,460
typing is that it's easier to read and

00:04:40,249 --> 00:04:45,979
understand code and that's because the

00:04:43,460 --> 00:04:47,629
types of your code I right there in the

00:04:45,979 --> 00:04:49,879
code you don't rely on documentation to

00:04:47,629 --> 00:04:52,610
go are this random variable X is

00:04:49,879 --> 00:04:54,409
actually a strength and that means that

00:04:52,610 --> 00:04:56,659
when you have a very large team or you

00:04:54,409 --> 00:04:58,099
have people a very long living system

00:04:56,659 --> 00:05:00,559
people should be able to come to that

00:04:58,099 --> 00:05:02,539
system later down the track and much

00:05:00,559 --> 00:05:06,139
more quickly get a grass for how things

00:05:02,539 --> 00:05:08,749
are working and and that's probably true

00:05:06,139 --> 00:05:10,399
true of the whole static typing movement

00:05:08,749 --> 00:05:11,930
I think you can probably make a

00:05:10,399 --> 00:05:16,369
different argument for languages like

00:05:11,930 --> 00:05:19,009
Java dynamic typing it is faster to

00:05:16,369 --> 00:05:20,180
write code obviously but on the downside

00:05:19,009 --> 00:05:21,949
of that you need to write more code

00:05:20,180 --> 00:05:23,059
because if you actually want to test for

00:05:21,949 --> 00:05:27,199
type errors you've got to write the

00:05:23,059 --> 00:05:28,819
tests if you don't write the tests you

00:05:27,199 --> 00:05:29,930
will get bugs and run time and then

00:05:28,819 --> 00:05:34,219
you'll have to go back and fix those

00:05:29,930 --> 00:05:36,229
bugs so it's your choice really the the

00:05:34,219 --> 00:05:37,999
inverse of the argument and static

00:05:36,229 --> 00:05:39,709
typing is that theoretically it should

00:05:37,999 --> 00:05:40,639
be harder to read dynamically type code

00:05:39,709 --> 00:05:42,409
because you don't know the types

00:05:40,639 --> 00:05:43,459
especially if people don't document it

00:05:42,409 --> 00:05:46,309
you don't know what type different

00:05:43,459 --> 00:05:47,419
variables are but on the plus side it's

00:05:46,309 --> 00:05:49,099
probably a little bit easier for

00:05:47,419 --> 00:05:51,399
beginners to grasp the language as

00:05:49,099 --> 00:05:55,370
opposed to statically typed languages

00:05:51,399 --> 00:05:57,889
but there's more good news as of pep 484

00:05:55,370 --> 00:06:00,589
and as a Python 3.5 and even before then

00:05:57,889 --> 00:06:03,499
actually our Python can do static typing

00:06:00,589 --> 00:06:05,449
via a mechanism called tie pins

00:06:03,499 --> 00:06:07,039
otherwise known as optional static

00:06:05,449 --> 00:06:10,249
typing and there's two snippets of code

00:06:07,039 --> 00:06:11,479
that do tie painting and Python they

00:06:10,249 --> 00:06:14,119
look identical because they are

00:06:11,479 --> 00:06:16,550
identical because pet 484 was pretty

00:06:14,119 --> 00:06:18,709
much inspired by my pie so the things to

00:06:16,550 --> 00:06:21,169
keep in mind Pep 484 is not a static

00:06:18,709 --> 00:06:22,909
type checker pep 484 as a specification

00:06:21,169 --> 00:06:24,709
how you can do tie painting and Python

00:06:22,909 --> 00:06:27,619
my apply on the other hand is a static

00:06:24,709 --> 00:06:29,269
type checker so you can put type int in

00:06:27,619 --> 00:06:31,399
your life encourage run a static type

00:06:29,269 --> 00:06:33,199
checker over it to see whether you have

00:06:31,399 --> 00:06:34,809
any type errors in your code rather than

00:06:33,199 --> 00:06:36,979
writing tests for that explicitly

00:06:34,809 --> 00:06:38,119
obviously the type ending is completely

00:06:36,979 --> 00:06:40,069
optional it's up to you whether you use

00:06:38,119 --> 00:06:41,569
it or whether you don't use it and it

00:06:40,069 --> 00:06:43,990
comes with all the standard things you'd

00:06:41,569 --> 00:06:46,190
expect in a type int or static typed

00:06:43,990 --> 00:06:48,230
environment

00:06:46,190 --> 00:06:50,030
but this being the Python world you can

00:06:48,230 --> 00:06:52,000
imagine the uproar that introducing

00:06:50,030 --> 00:06:53,900
Taipans has caused in the community

00:06:52,000 --> 00:06:56,570
particularly if you're someone like me

00:06:53,900 --> 00:06:58,250
that's come from Java or a language like

00:06:56,570 --> 00:07:01,670
that to Python because of how easy it is

00:06:58,250 --> 00:07:02,750
to write the mailing list blows up with

00:07:01,670 --> 00:07:03,830
a whole bunch of people saying you're

00:07:02,750 --> 00:07:06,040
ruining the language and it pretty much

00:07:03,830 --> 00:07:09,400
does every other time anyway so but

00:07:06,040 --> 00:07:11,810
here's a quote from the BD FL of the pep

00:07:09,400 --> 00:07:14,000
talking about how this is a very similar

00:07:11,810 --> 00:07:15,920
situation to and arguments being put

00:07:14,000 --> 00:07:18,200
forward to those that are put forward

00:07:15,920 --> 00:07:19,940
when operator overloading was brought in

00:07:18,200 --> 00:07:22,670
and operator overloading for those who

00:07:19,940 --> 00:07:24,620
don't know you can define special double

00:07:22,670 --> 00:07:26,360
underscore methods that implement all

00:07:24,620 --> 00:07:28,280
and end and all those other things so

00:07:26,360 --> 00:07:31,910
you can override what or an end to do

00:07:28,280 --> 00:07:33,200
for your custom types and essentially

00:07:31,910 --> 00:07:35,000
the argument there is the Python

00:07:33,200 --> 00:07:36,680
community is quite opinionated people

00:07:35,000 --> 00:07:38,600
come to part them for a specific set of

00:07:36,680 --> 00:07:40,610
reasons and their addition of a new

00:07:38,600 --> 00:07:44,260
feature won't change that and I think

00:07:40,610 --> 00:07:46,280
that's a pretty solid argument so here's

00:07:44,260 --> 00:07:47,870
dynamic toppings one here is probably

00:07:46,280 --> 00:07:50,360
the biggest reason for Python in the

00:07:47,870 --> 00:07:51,650
enterprise speed Python is an

00:07:50,360 --> 00:07:52,820
interpreted language and hence it's

00:07:51,650 --> 00:07:55,760
going to be slower than from than a

00:07:52,820 --> 00:07:57,800
statically typed compiled language it is

00:07:55,760 --> 00:07:59,570
what it is some of that is current it's

00:07:57,800 --> 00:08:01,070
compounded by the fact that the guild

00:07:59,570 --> 00:08:04,310
exists anyone not know what the killer's

00:08:01,070 --> 00:08:05,570
I say so the gill is a global

00:08:04,310 --> 00:08:07,010
interpreter lock and I'm going to touch

00:08:05,570 --> 00:08:09,500
on a little bit more but essentially you

00:08:07,010 --> 00:08:14,690
can't run more than one thread at a time

00:08:09,500 --> 00:08:17,030
using the cpu speed is a multi-faceted

00:08:14,690 --> 00:08:19,190
problem right there is the speed to

00:08:17,030 --> 00:08:21,380
write code and that is absolutely a

00:08:19,190 --> 00:08:23,690
consideration and enterprise there is

00:08:21,380 --> 00:08:25,130
the speed that it takes to execute code

00:08:23,690 --> 00:08:27,500
again another consideration for

00:08:25,130 --> 00:08:31,550
enterprise but as I'm about to present

00:08:27,500 --> 00:08:33,440
to you I believe that speed to run code

00:08:31,550 --> 00:08:35,419
in Python can be mitigated significantly

00:08:33,440 --> 00:08:37,849
and I think the time it takes the

00:08:35,419 --> 00:08:39,410
developed code is a consideration that

00:08:37,849 --> 00:08:42,950
people people really need to take into

00:08:39,410 --> 00:08:44,780
mind and this is the essential argument

00:08:42,950 --> 00:08:46,580
for that I guess what's cheaper a

00:08:44,780 --> 00:08:49,450
developer or a CPU cycle now obviously

00:08:46,580 --> 00:08:51,860
is extreme scalar CPU cycles much more

00:08:49,450 --> 00:08:54,020
cost effective than a developer but if

00:08:51,860 --> 00:08:56,690
you put it into something more real if

00:08:54,020 --> 00:09:00,250
this developer he is getting paid two

00:08:56,690 --> 00:09:00,250
thousand dollars a week for example

00:09:00,290 --> 00:09:02,930
and she works on a feature for four

00:09:01,639 --> 00:09:05,509
weeks to try and make something run

00:09:02,930 --> 00:09:07,339
faster was that money better spent just

00:09:05,509 --> 00:09:08,360
getting a better server or not now

00:09:07,339 --> 00:09:09,829
there's some cases where this is

00:09:08,360 --> 00:09:10,820
absolutely going to apply the some cases

00:09:09,829 --> 00:09:13,009
where this absolutely isn't going to

00:09:10,820 --> 00:09:14,329
apply but I think the thing that I that

00:09:13,009 --> 00:09:15,259
I'd like to take out of this is that

00:09:14,329 --> 00:09:17,360
this is something you should be

00:09:15,259 --> 00:09:21,380
considering when trying to rule in or

00:09:17,360 --> 00:09:22,699
rule out any particular technology for

00:09:21,380 --> 00:09:24,620
those that don't already know and I'm

00:09:22,699 --> 00:09:26,930
sure pretty much everyone does C Python

00:09:24,620 --> 00:09:28,639
which is the default way to run Python

00:09:26,930 --> 00:09:29,959
it's not your only choice there's a

00:09:28,639 --> 00:09:32,509
whole bunch of other interpreters there

00:09:29,959 --> 00:09:34,940
and then make various trade-offs you can

00:09:32,509 --> 00:09:37,130
run Python inside the JVM if you so

00:09:34,940 --> 00:09:39,860
desire you lose the ability to run c

00:09:37,130 --> 00:09:41,300
extensions and as well see certain the

00:09:39,860 --> 00:09:44,990
majority of the standard library is

00:09:41,300 --> 00:09:47,180
written as C so that's a trade-off but

00:09:44,990 --> 00:09:50,329
you will absolutely get faster code PI

00:09:47,180 --> 00:09:52,399
PI's a jetted version of python that get

00:09:50,329 --> 00:09:58,399
you in some cases amazingly speed

00:09:52,399 --> 00:10:00,230
amazing speed increases generally the

00:09:58,399 --> 00:10:01,910
way that people say that you need to

00:10:00,230 --> 00:10:03,829
attack a problem with Python being slow

00:10:01,910 --> 00:10:05,329
if it absolutely is a CPU bound task

00:10:03,829 --> 00:10:07,010
you've done all your you're profiling

00:10:05,329 --> 00:10:08,389
you know where your code where your

00:10:07,010 --> 00:10:11,839
speed problems are is to write a see

00:10:08,389 --> 00:10:13,279
extension and traditionally that's been

00:10:11,839 --> 00:10:16,069
a very daunting task if you've ever

00:10:13,279 --> 00:10:18,290
tried to do it yourself the first thing

00:10:16,069 --> 00:10:20,240
to keep in mind is that the chances are

00:10:18,290 --> 00:10:22,610
if you need a particular task to run

00:10:20,240 --> 00:10:24,709
fast whether it be maths or some sort of

00:10:22,610 --> 00:10:26,029
science task or whatever it is someone's

00:10:24,709 --> 00:10:27,680
already written that code and see for

00:10:26,029 --> 00:10:30,110
you and a see extension exists to do it

00:10:27,680 --> 00:10:34,850
so don't go and try and reinvent the

00:10:30,110 --> 00:10:36,139
wheel in those scenarios and you can

00:10:34,850 --> 00:10:38,000
even extend this out to the standard

00:10:36,139 --> 00:10:40,160
library large amounts of the standard

00:10:38,000 --> 00:10:41,930
library are already written in C and

00:10:40,160 --> 00:10:43,399
I've just listed a few things there it's

00:10:41,930 --> 00:10:44,689
quite easy if you go look at the Python

00:10:43,399 --> 00:10:45,889
source code to see which parts are in

00:10:44,689 --> 00:10:47,990
flint and see which plants aren't they

00:10:45,889 --> 00:10:52,100
live in different folders one called lib

00:10:47,990 --> 00:10:53,600
and one called module I think and as I

00:10:52,100 --> 00:10:55,040
said a large number of third-party

00:10:53,600 --> 00:10:57,050
libraries that are already written in C

00:10:55,040 --> 00:11:00,399
and that includes just a couple that

00:10:57,050 --> 00:11:03,100
I've listed there the good news is that

00:11:00,399 --> 00:11:05,899
writing C extensis is no longer hard and

00:11:03,100 --> 00:11:09,980
that's because of what i think is quite

00:11:05,899 --> 00:11:11,720
a revolutionary thing syphon we could

00:11:09,980 --> 00:11:12,800
have a big long philosophical talk about

00:11:11,720 --> 00:11:16,010
siphon and how it could

00:11:12,800 --> 00:11:17,570
possibly be the next C++ don't have the

00:11:16,010 --> 00:11:21,410
time for that but here's a demonstration

00:11:17,570 --> 00:11:22,430
of siphon it's missing some of the bits

00:11:21,410 --> 00:11:23,870
that you need to actually make it run

00:11:22,430 --> 00:11:26,149
which aren't difficult need to add a few

00:11:23,870 --> 00:11:27,560
lines to set up py but you can

00:11:26,149 --> 00:11:29,600
essentially see there that the function

00:11:27,560 --> 00:11:31,790
at the top has been implemented again

00:11:29,600 --> 00:11:34,100
down the bottom with the addition of ten

00:11:31,790 --> 00:11:36,860
extra characters and int and in turn a

00:11:34,100 --> 00:11:40,730
CDF and it runs 72 times faster than the

00:11:36,860 --> 00:11:42,470
code above if you were to implement the

00:11:40,730 --> 00:11:44,720
function above the pure Python function

00:11:42,470 --> 00:11:47,450
in a traditional see extension using C

00:11:44,720 --> 00:11:50,029
types you will get a seventy-three

00:11:47,450 --> 00:11:51,950
percent speed increase and that code

00:11:50,029 --> 00:11:53,149
will look you know you will be somewhere

00:11:51,950 --> 00:11:56,839
between fifty and a hundred lines long

00:11:53,149 --> 00:11:58,370
with C code so that is literally the

00:11:56,839 --> 00:12:00,620
barrier to writing a see extension in

00:11:58,370 --> 00:12:02,450
Python these days and I think it has

00:12:00,620 --> 00:12:05,680
massive implications for the language in

00:12:02,450 --> 00:12:07,700
terms of being useful in the enterprise

00:12:05,680 --> 00:12:09,200
one of the cool things you can do on

00:12:07,700 --> 00:12:10,490
site and if you're interested in ipython

00:12:09,200 --> 00:12:12,200
notebooks is it's got a really cool

00:12:10,490 --> 00:12:13,730
feature where you give it some code and

00:12:12,200 --> 00:12:15,980
say hey compile this for me and it'll go

00:12:13,730 --> 00:12:17,959
ahead and go hey the lines in white a

00:12:15,980 --> 00:12:20,089
pure see they're going to run as fast as

00:12:17,959 --> 00:12:22,399
you can get them the fast as fast you

00:12:20,089 --> 00:12:24,770
can get in to run the lines in yellow

00:12:22,399 --> 00:12:26,420
have a degree of pythons still being

00:12:24,770 --> 00:12:28,339
involved and maybe it's using a Python

00:12:26,420 --> 00:12:30,320
type or something the dark yellow is

00:12:28,339 --> 00:12:32,570
full path and so you can see with this

00:12:30,320 --> 00:12:34,010
dark yellow line at the top here that is

00:12:32,570 --> 00:12:35,390
just a straight pipe of mine to find a

00:12:34,010 --> 00:12:38,000
function right there's nothing it can do

00:12:35,390 --> 00:12:39,470
to make that any better so that is when

00:12:38,000 --> 00:12:41,839
you compile this code that will remain

00:12:39,470 --> 00:12:44,950
as a Python line but the line below it

00:12:41,839 --> 00:12:47,660
using a seed f in an int pure C code if

00:12:44,950 --> 00:12:50,420
you really want to optimize things and I

00:12:47,660 --> 00:12:52,160
know there's people around that do they

00:12:50,420 --> 00:12:54,440
sit in ipython notebook they write their

00:12:52,160 --> 00:12:57,190
code they use this magic and they keep

00:12:54,440 --> 00:12:59,660
going until the yellow is gone and

00:12:57,190 --> 00:13:00,709
siphon isn't the only option even though

00:12:59,660 --> 00:13:02,959
i think is probably one of the best

00:13:00,709 --> 00:13:05,600
options are if you're doing some sort of

00:13:02,959 --> 00:13:06,980
numerical stuff and numpy isn't enough

00:13:05,600 --> 00:13:08,779
for you then there's number which is a

00:13:06,980 --> 00:13:11,110
jetway you just have to add one

00:13:08,779 --> 00:13:13,610
decorator to a function and off it goes

00:13:11,110 --> 00:13:15,320
i'm not so sure how to pronounce the

00:13:13,610 --> 00:13:17,060
second one but look to cures have one on

00:13:15,320 --> 00:13:19,040
how i'm going to pronounce it it is a

00:13:17,060 --> 00:13:21,709
another Python compile up their claims

00:13:19,040 --> 00:13:24,850
that you can give it any python source

00:13:21,709 --> 00:13:26,420
file run a compiler over and get a and

00:13:24,850 --> 00:13:29,480
c++ compiler

00:13:26,420 --> 00:13:31,970
program and it says its baseline

00:13:29,480 --> 00:13:33,980
increase over Python in the PI stone

00:13:31,970 --> 00:13:35,510
benchmark is three hundred percent

00:13:33,980 --> 00:13:37,579
increase in speed without doing anything

00:13:35,510 --> 00:13:39,610
you just got to run the compiler and

00:13:37,579 --> 00:13:43,310
there's some other options down there

00:13:39,610 --> 00:13:45,260
pistons another jit interpreter from

00:13:43,310 --> 00:13:48,050
Dropbox that was announced a little

00:13:45,260 --> 00:13:51,380
while ago and with all these tools

00:13:48,050 --> 00:13:53,269
available to make python run fast the

00:13:51,380 --> 00:13:54,589
question really becomes is there a speed

00:13:53,269 --> 00:13:56,600
problem with Python and and

00:13:54,589 --> 00:13:57,980
interestingly from what I found at this

00:13:56,600 --> 00:14:00,139
conference when you talk to people and

00:13:57,980 --> 00:14:02,029
you talk to them about tools like siphon

00:14:00,139 --> 00:14:03,620
they say well number one speeds not a

00:14:02,029 --> 00:14:06,709
problem for me and that could be because

00:14:03,620 --> 00:14:08,060
they're not writing code that is speed

00:14:06,709 --> 00:14:09,740
reliant they've already decided to use a

00:14:08,060 --> 00:14:11,389
different tool for those tasks and okay

00:14:09,740 --> 00:14:13,810
fair enough the other thing is they seem

00:14:11,389 --> 00:14:17,810
to assume that all these tools are

00:14:13,810 --> 00:14:19,730
targeted at sign scientifical or data

00:14:17,810 --> 00:14:21,560
python rather as opposed to regular

00:14:19,730 --> 00:14:23,149
python and that's absolutely not the

00:14:21,560 --> 00:14:26,570
case cycling is definitely not a tool

00:14:23,149 --> 00:14:28,339
for numerical Python or math or science

00:14:26,570 --> 00:14:29,990
or data it's a tool that can be used

00:14:28,339 --> 00:14:34,490
anywhere anyway you need code to go fast

00:14:29,990 --> 00:14:37,070
so I thing can be used so scaling Python

00:14:34,490 --> 00:14:39,199
obviously today's scaling has a lot of

00:14:37,070 --> 00:14:41,420
meanings given you know cloud whatnot

00:14:39,199 --> 00:14:43,339
but there's also scaling on a local

00:14:41,420 --> 00:14:50,660
machine right and this is where I want

00:14:43,339 --> 00:14:52,310
to talk more about the gill because of

00:14:50,660 --> 00:14:53,720
the Gilder seems to be an argument going

00:14:52,310 --> 00:14:56,300
around with a lot of developers that are

00:14:53,720 --> 00:14:58,899
python is bad for concurrency and and to

00:14:56,300 --> 00:15:01,310
put it bluntly I just think that's wrong

00:14:58,899 --> 00:15:03,290
see python is probably one of the most

00:15:01,310 --> 00:15:05,269
consistent runtimes available have a

00:15:03,290 --> 00:15:06,769
saying that having come from Java you

00:15:05,269 --> 00:15:08,209
don't hear people complaining an awful

00:15:06,769 --> 00:15:10,069
lot about the time it takes for an

00:15:08,209 --> 00:15:11,829
application to start up all these random

00:15:10,069 --> 00:15:14,720
pauses when the garbage collector runs

00:15:11,829 --> 00:15:17,300
and part of that down the simplicity is

00:15:14,720 --> 00:15:19,190
the guilt because it can make guarantees

00:15:17,300 --> 00:15:21,920
about your code that other runtimes

00:15:19,190 --> 00:15:23,120
can't make that's also part of reason

00:15:21,920 --> 00:15:24,649
why it's so difficult to get rid of the

00:15:23,120 --> 00:15:27,410
guilt on the path of mailing list or

00:15:24,649 --> 00:15:28,970
starters discussion about it one thing

00:15:27,410 --> 00:15:31,579
to keep in mind is that the guild

00:15:28,970 --> 00:15:33,680
doesn't block on Io so here's a very

00:15:31,579 --> 00:15:35,149
simple example obviously time dot sleep

00:15:33,680 --> 00:15:37,880
is a blocking call that will put your

00:15:35,149 --> 00:15:40,160
thread to sleep for two seconds if the

00:15:37,880 --> 00:15:43,730
guild blocked on Io you'd expect this

00:15:40,160 --> 00:15:45,949
career to pride and thread be to print

00:15:43,730 --> 00:15:48,259
hi and bye and it doesn't work like that

00:15:45,949 --> 00:15:50,629
because when our threads blocked and

00:15:48,259 --> 00:15:53,240
other threads executed so it only blocks

00:15:50,629 --> 00:15:55,279
for CPU bound code now that time dot

00:15:53,240 --> 00:16:02,660
sleep could be you know fetching a URL

00:15:55,279 --> 00:16:04,430
or something else when a task is our CPU

00:16:02,660 --> 00:16:06,740
bound and you don't want to go to the

00:16:04,430 --> 00:16:08,779
effort of getting siphon out of the tool

00:16:06,740 --> 00:16:10,610
bag then it's important to remember that

00:16:08,779 --> 00:16:13,220
the gill only applies the threats are

00:16:10,610 --> 00:16:15,620
not processes so here is a piece of

00:16:13,220 --> 00:16:17,480
really naive code that calculates prime

00:16:15,620 --> 00:16:19,670
numbers and what it's doing is and take

00:16:17,480 --> 00:16:23,029
note how simple it is to do concurrency

00:16:19,670 --> 00:16:24,889
and profit by the way all it's doing is

00:16:23,029 --> 00:16:26,269
trying to calculate I trying to

00:16:24,889 --> 00:16:28,129
determine whether those six numbers at

00:16:26,269 --> 00:16:29,769
the tops are primes and it's doing it in

00:16:28,129 --> 00:16:33,620
a thread pool executor with six threads

00:16:29,769 --> 00:16:34,730
if you want to make that code run

00:16:33,620 --> 00:16:37,610
approximately seventy-five percent

00:16:34,730 --> 00:16:40,160
faster all you have to do is change that

00:16:37,610 --> 00:16:41,509
word thread there to process and all of

00:16:40,160 --> 00:16:43,639
a sudden the gill is no longer a problem

00:16:41,509 --> 00:16:45,560
you don't get the semantics of shared

00:16:43,639 --> 00:16:48,519
memory and I think you can make an

00:16:45,560 --> 00:16:50,630
argument that that's not a bad thing but

00:16:48,519 --> 00:16:52,759
it's definitely possible to make that

00:16:50,630 --> 00:16:54,529
code run faster without having to do too

00:16:52,759 --> 00:16:58,279
much and obviously the code there's

00:16:54,529 --> 00:16:59,689
definitely not ugly and if you do want

00:16:58,279 --> 00:17:01,250
to get softer now the play I could get

00:16:59,689 --> 00:17:03,980
into black magic then you absolutely

00:17:01,250 --> 00:17:05,630
can't can do multi-threaded code that

00:17:03,980 --> 00:17:07,760
shares memory that doesn't have the gill

00:17:05,630 --> 00:17:11,890
and so I thought allows you to do that

00:17:07,760 --> 00:17:15,110
with the node Gill the no Gil statement

00:17:11,890 --> 00:17:16,520
so I mean that code a little bit

00:17:15,110 --> 00:17:18,020
difficult to understand I guess but it's

00:17:16,520 --> 00:17:20,630
basically just trying to calculate a

00:17:18,020 --> 00:17:22,159
really large number and it's doing it in

00:17:20,630 --> 00:17:23,900
threads as you can see down here it's

00:17:22,159 --> 00:17:27,980
actually using Python threads externally

00:17:23,900 --> 00:17:30,020
and that code runs in parallel memory

00:17:27,980 --> 00:17:31,220
shared I could I could write memory to

00:17:30,020 --> 00:17:36,169
shared structures there if I wanted to

00:17:31,220 --> 00:17:37,820
and the gills gone so I guess the point

00:17:36,169 --> 00:17:39,559
I'm trying to make is concurrency is

00:17:37,820 --> 00:17:40,880
easy and what I mean by that is

00:17:39,559 --> 00:17:42,289
concurrency in python is easy

00:17:40,880 --> 00:17:43,880
concurrency itself is quite difficult

00:17:42,289 --> 00:17:45,799
but when you compare pipe into other

00:17:43,880 --> 00:17:48,950
languages and I feel like I'm picking on

00:17:45,799 --> 00:17:51,570
Java but I guess I am

00:17:48,950 --> 00:17:53,910
it's definitely simpler than than those

00:17:51,570 --> 00:17:55,500
languages the coding constructs are

00:17:53,910 --> 00:17:56,640
really simple and I think you can see

00:17:55,500 --> 00:17:58,260
that in the code that I've just done

00:17:56,640 --> 00:17:59,670
there there's no synchronized keywords

00:17:58,260 --> 00:18:01,380
or anything like that the guild

00:17:59,670 --> 00:18:03,420
definitely is the thing and and if you

00:18:01,380 --> 00:18:05,070
have cpu-bound tasks if you throw

00:18:03,420 --> 00:18:08,340
threads at it you will make your code go

00:18:05,070 --> 00:18:10,320
slower as it turns out you can go have a

00:18:08,340 --> 00:18:11,790
look at some PyCon talks about that to

00:18:10,320 --> 00:18:15,480
do with thread contention and all the

00:18:11,790 --> 00:18:17,220
rest of it but the flip side of that is

00:18:15,480 --> 00:18:19,620
for beginners the guild can almost be

00:18:17,220 --> 00:18:21,780
considered a feature it doesn't allow

00:18:19,620 --> 00:18:23,670
them to get into sticky situations where

00:18:21,780 --> 00:18:25,350
they've unknowingly shared memory

00:18:23,670 --> 00:18:27,390
between threads and end up with race

00:18:25,350 --> 00:18:29,700
conditions and deadlox if you want to do

00:18:27,390 --> 00:18:31,620
concurrency in Python you have to think

00:18:29,700 --> 00:18:32,910
about what it is you're trying to do and

00:18:31,620 --> 00:18:34,950
while you're trying to do it and I don't

00:18:32,910 --> 00:18:37,140
think that's a difficult that's a bad

00:18:34,950 --> 00:18:38,520
thing and when you do decide you want to

00:18:37,140 --> 00:18:43,560
do it the syntax and the way to do it

00:18:38,520 --> 00:18:45,840
isn't difficult so quick summary of

00:18:43,560 --> 00:18:48,180
Python and the enterprise it's an

00:18:45,840 --> 00:18:49,770
extremely flexible language the standard

00:18:48,180 --> 00:18:53,190
library and third-party libraries are

00:18:49,770 --> 00:18:56,970
really out of this world its syntax and

00:18:53,190 --> 00:19:00,870
strong opinions on style I think are a

00:18:56,970 --> 00:19:02,760
massive advantage in an enterprise when

00:19:00,870 --> 00:19:04,230
your code base grows large you have the

00:19:02,760 --> 00:19:05,550
option of switching over to static

00:19:04,230 --> 00:19:09,060
typing and you could even do it from the

00:19:05,550 --> 00:19:10,620
start if you were so desire if speed

00:19:09,060 --> 00:19:12,180
does become an issue for you then there

00:19:10,620 --> 00:19:13,800
is a lot of ways that you can attack

00:19:12,180 --> 00:19:17,100
that problem and the tools for

00:19:13,800 --> 00:19:18,780
identifying why speed is a problem where

00:19:17,100 --> 00:19:20,220
the hotspots are in your code are also

00:19:18,780 --> 00:19:24,360
excellent and touch on those in a little

00:19:20,220 --> 00:19:26,100
bit and obviously scaling Python both to

00:19:24,360 --> 00:19:28,110
multiple calls into many machines as

00:19:26,100 --> 00:19:30,480
demonstrated by people like YouTube is a

00:19:28,110 --> 00:19:32,370
very attainable thing so I want to have

00:19:30,480 --> 00:19:38,620
a quick look at the database that I've

00:19:32,370 --> 00:19:42,669
started to write call caterpillar sorry

00:19:38,620 --> 00:19:42,669
so caterpillar is a search engine

00:19:42,760 --> 00:19:48,169
Capisce is a company that does extracts

00:19:46,240 --> 00:19:50,090
insight from text in an automatic

00:19:48,169 --> 00:19:52,429
fashion and to do that we need to be

00:19:50,090 --> 00:19:54,140
able to get down into the text and

00:19:52,429 --> 00:19:55,400
generate statistics about that text and

00:19:54,140 --> 00:19:57,230
to do that I need to break textile

00:19:55,400 --> 00:19:59,690
that's traditionally what's done by a

00:19:57,230 --> 00:20:01,640
search engine like apache Lucene and an

00:19:59,690 --> 00:20:03,020
elastic search breaks the texts up to

00:20:01,640 --> 00:20:04,730
make it searchable and we just take it a

00:20:03,020 --> 00:20:06,980
step further in that we create a few

00:20:04,730 --> 00:20:10,100
more data structures like a term by term

00:20:06,980 --> 00:20:14,470
matrix to jet to get more insight tell

00:20:10,100 --> 00:20:16,789
the text we were faced early with the

00:20:14,470 --> 00:20:18,890
problem of do we try and adapt apache

00:20:16,789 --> 00:20:20,570
Lucene or do we try and write our own or

00:20:18,890 --> 00:20:25,700
do we use our whoosh whoosh in existing

00:20:20,570 --> 00:20:27,230
pythons text search solution modifying

00:20:25,700 --> 00:20:30,400
lucene to do something very simple

00:20:27,230 --> 00:20:34,100
involve changing 25 polls files of Java

00:20:30,400 --> 00:20:38,090
so that just yeah I didn't want to do

00:20:34,100 --> 00:20:39,440
that caterpillar itself supports plugins

00:20:38,090 --> 00:20:41,570
right now there's an open-source plugin

00:20:39,440 --> 00:20:45,110
that does latent semantic indexing on

00:20:41,570 --> 00:20:47,059
your index and we're Capisce you have

00:20:45,110 --> 00:20:48,919
some clothes source plugins our topic

00:20:47,059 --> 00:20:50,270
modeling algorithm is closed source and

00:20:48,919 --> 00:20:51,440
our sentiment analysis the stuff is

00:20:50,270 --> 00:20:53,659
closed source and there's some links

00:20:51,440 --> 00:20:56,150
there to get access to those projects

00:20:53,659 --> 00:20:57,830
why did we choose Python well first and

00:20:56,150 --> 00:20:59,330
foremost when we started this endeavor

00:20:57,830 --> 00:21:01,760
we had to do a lot of research in the

00:20:59,330 --> 00:21:03,860
academic world to get some idea of what

00:21:01,760 --> 00:21:06,590
the latest NLP research was and figure

00:21:03,860 --> 00:21:08,299
out we had a bit of a history at a

00:21:06,590 --> 00:21:10,220
previous company in this area we knew

00:21:08,299 --> 00:21:12,980
the automatic topic modeling without any

00:21:10,220 --> 00:21:16,250
linguistics as possible but we need to

00:21:12,980 --> 00:21:17,929
do that research using Python meant that

00:21:16,250 --> 00:21:19,909
we could prototype very quickly the

00:21:17,929 --> 00:21:22,970
solutions that we wanted to explore

00:21:19,909 --> 00:21:24,530
further and that's fine you can you can

00:21:22,970 --> 00:21:25,940
prototype with Python and that's good

00:21:24,530 --> 00:21:27,260
but there was a point where we had to

00:21:25,940 --> 00:21:30,169
say are we going to use Python in the

00:21:27,260 --> 00:21:32,299
long term or not and ultimately we said

00:21:30,169 --> 00:21:36,770
yes because the the programming language

00:21:32,299 --> 00:21:38,059
lets us iterate very quickly some might

00:21:36,770 --> 00:21:39,950
not consider the next point of feature

00:21:38,059 --> 00:21:41,450
but dynamic typing meant that we had to

00:21:39,950 --> 00:21:43,370
have a hundred percent code coverage of

00:21:41,450 --> 00:21:45,350
tests if we wanted to be sure that

00:21:43,370 --> 00:21:47,450
everything was going to go well and

00:21:45,350 --> 00:21:50,630
having a hundred sent test coverage is

00:21:47,450 --> 00:21:51,500
probably a good thing we knew that when

00:21:50,630 --> 00:21:53,000
thing

00:21:51,500 --> 00:21:54,260
time came that we need to extract some

00:21:53,000 --> 00:21:55,700
more speed that we'd have a lot of

00:21:54,260 --> 00:21:57,370
options at our fingertips and we haven't

00:21:55,700 --> 00:22:00,920
really started exploring that too much

00:21:57,370 --> 00:22:04,520
as I've said existing indexes the code

00:22:00,920 --> 00:22:05,810
was a little bit terrifying so yeah

00:22:04,520 --> 00:22:07,580
that's why I decided to go with Python

00:22:05,810 --> 00:22:09,350
right now it's still running in C Python

00:22:07,580 --> 00:22:11,210
we don't have any see extensions of our

00:22:09,350 --> 00:22:13,760
own we do have a dependency on numpy for

00:22:11,210 --> 00:22:16,010
certain part when we index the English

00:22:13,760 --> 00:22:18,200
version of Wikipedia or we run at 16 the

00:22:16,010 --> 00:22:22,010
speed of apache Lucene and this is there

00:22:18,200 --> 00:22:23,420
any real optimization we've used the

00:22:22,010 --> 00:22:26,720
technology to write a semantic search

00:22:23,420 --> 00:22:29,210
engine over top of Wikipedia and when we

00:22:26,720 --> 00:22:32,030
do eventually get time and money to do

00:22:29,210 --> 00:22:33,260
some optimization I'm pretty confident

00:22:32,030 --> 00:22:37,460
that we're going to get quite close to

00:22:33,260 --> 00:22:38,690
leucine in terms of performance so one

00:22:37,460 --> 00:22:40,970
thing that I mentioned earlier is that

00:22:38,690 --> 00:22:42,380
profiling in python is really good and I

00:22:40,970 --> 00:22:43,820
just wanted to put up a quick picture of

00:22:42,380 --> 00:22:45,200
what profiling and parts it looks like

00:22:43,820 --> 00:22:48,950
at least if you do it the way that we

00:22:45,200 --> 00:22:50,870
did it that's an output that's a

00:22:48,950 --> 00:22:53,360
visualization of an output from see

00:22:50,870 --> 00:22:55,100
profile and Python standard library and

00:22:53,360 --> 00:22:57,260
what you can see there is in the middle

00:22:55,100 --> 00:23:00,320
is the is the outer call to a function

00:22:57,260 --> 00:23:02,420
and each layer of the or each color of

00:23:00,320 --> 00:23:05,510
the of that circle visualization there

00:23:02,420 --> 00:23:07,370
is a step down in the stack so that part

00:23:05,510 --> 00:23:10,550
on the left there that first half is us

00:23:07,370 --> 00:23:12,260
tokenizing text the second part to the

00:23:10,550 --> 00:23:14,510
right there is asked generating data

00:23:12,260 --> 00:23:16,370
structures about text and the third part

00:23:14,510 --> 00:23:19,730
there that kind of spits out a bit

00:23:16,370 --> 00:23:21,050
further is us persisting test data

00:23:19,730 --> 00:23:23,540
structures to disk to make them

00:23:21,050 --> 00:23:25,580
searchable later so I mean that is a and

00:23:23,540 --> 00:23:26,930
its interactive visualization I can't

00:23:25,580 --> 00:23:29,000
show you the interactivity here but it's

00:23:26,930 --> 00:23:31,160
such an amazing tool and it's so easy to

00:23:29,000 --> 00:23:33,920
run and it really demonstrates the power

00:23:31,160 --> 00:23:35,120
that you get with Python and I think

00:23:33,920 --> 00:23:38,060
that's particularly applicable to the

00:23:35,120 --> 00:23:39,170
enterprise one of the reasons we went

00:23:38,060 --> 00:23:41,090
with python is because we could write it

00:23:39,170 --> 00:23:43,820
we could create a really neat API and I

00:23:41,090 --> 00:23:45,590
like a neat api's that's more or less

00:23:43,820 --> 00:23:49,400
what our API looks like adding a

00:23:45,590 --> 00:23:51,620
document is a is a case of using a with

00:23:49,400 --> 00:23:53,300
statement with a rider and saying for

00:23:51,620 --> 00:23:55,460
article and article at my document

00:23:53,300 --> 00:23:57,110
here's its title here is its text turns

00:23:55,460 --> 00:24:00,190
out you can use apache Lucene from

00:23:57,110 --> 00:24:02,420
python when you do that it kind of

00:24:00,190 --> 00:24:03,890
instantiates a JVM for you which is a

00:24:02,420 --> 00:24:06,500
little bit scary but

00:24:03,890 --> 00:24:07,820
this is what the code looks like and I

00:24:06,500 --> 00:24:12,650
think it's a pretty clear demonstration

00:24:07,820 --> 00:24:15,140
of why the Python code is a little bit

00:24:12,650 --> 00:24:16,970
neater and why you really do need to

00:24:15,140 --> 00:24:18,350
consider the amount of time to develop

00:24:16,970 --> 00:24:24,170
code when you're making these decisions

00:24:18,350 --> 00:24:26,240
in the enterprise so using Python means

00:24:24,170 --> 00:24:28,130
that our code base is nice and concise I

00:24:26,240 --> 00:24:29,720
think anyway and manageable that test

00:24:28,130 --> 00:24:31,370
coverage is a hundred percent which is

00:24:29,720 --> 00:24:32,960
great and kind of needs to be maybe

00:24:31,370 --> 00:24:36,050
static typing will change that in terms

00:24:32,960 --> 00:24:39,170
of will remove some tests although maybe

00:24:36,050 --> 00:24:40,640
not one of the important things for me

00:24:39,170 --> 00:24:42,890
is refractory code doesn't seem like a

00:24:40,640 --> 00:24:44,570
massive chore it's like ah here's this

00:24:42,890 --> 00:24:48,950
heavenly place I created earlier now i'm

00:24:44,570 --> 00:24:50,240
back here the profiling tools great as

00:24:48,950 --> 00:24:51,530
I've already mentioned and the

00:24:50,240 --> 00:24:56,150
operations for increasing performance

00:24:51,530 --> 00:24:57,710
really are massive so just before

00:24:56,150 --> 00:24:59,450
questions I wanted to make a few public

00:24:57,710 --> 00:25:00,830
service announcements Nick Coughlin told

00:24:59,450 --> 00:25:03,230
me I had to say that red hat enterprise

00:25:00,830 --> 00:25:05,570
linux refuses to run without Python so

00:25:03,230 --> 00:25:07,370
there's that for enterprise there's a

00:25:05,570 --> 00:25:09,950
really good talk tomorrow about siphon

00:25:07,370 --> 00:25:12,020
given by Caleb it's at eleven ten a.m.

00:25:09,950 --> 00:25:13,760
in the Roosevelt Room so if you want to

00:25:12,020 --> 00:25:15,950
learn some more about siphon his talks

00:25:13,760 --> 00:25:18,050
really good to go check it out that when

00:25:15,950 --> 00:25:19,580
you exit this room on the table on your

00:25:18,050 --> 00:25:21,320
right hand side there's some brochures

00:25:19,580 --> 00:25:22,970
that the psf have printed and given out

00:25:21,320 --> 00:25:24,410
for free and it contains a whole bunch

00:25:22,970 --> 00:25:26,660
of case studies about how people are

00:25:24,410 --> 00:25:27,950
using enterprise and Python so I Python

00:25:26,660 --> 00:25:29,750
II an enterprise so if you need to

00:25:27,950 --> 00:25:30,740
convince someone and maybe you don't

00:25:29,750 --> 00:25:32,030
because you're already here but if you

00:25:30,740 --> 00:25:33,920
do need to convince someone in your work

00:25:32,030 --> 00:25:38,690
life that that's a good idea take that

00:25:33,920 --> 00:25:40,220
as a as a tool in your kit and oh if I

00:25:38,690 --> 00:25:41,660
get a chance I'm hope I will be at the

00:25:40,220 --> 00:25:43,100
sprints and I'm hoping to run sprints on

00:25:41,660 --> 00:25:44,270
caterpillar on Monday Tuesday so if you

00:25:43,100 --> 00:25:46,610
see me and it's something you're instead

00:25:44,270 --> 00:25:49,630
of working in let me know otherwise

00:25:46,610 --> 00:25:49,630
that's it questions

00:25:59,460 --> 00:26:03,910
do you have any advice forum when you're

00:26:02,440 --> 00:26:05,950
trying to pitched it an enterprise

00:26:03,910 --> 00:26:07,450
customer hey we've done this thing in

00:26:05,950 --> 00:26:09,910
Python we'd like to deploy it and they

00:26:07,450 --> 00:26:11,770
got a ball we want to run on jboss or

00:26:09,910 --> 00:26:13,780
something some enterprise system that

00:26:11,770 --> 00:26:15,430
they've got other than the brochure

00:26:13,780 --> 00:26:19,440
which I will go pick up do you have any

00:26:15,430 --> 00:26:21,940
advice for trying to convince them um I

00:26:19,440 --> 00:26:26,770
guess it's kind of a you've got to take

00:26:21,940 --> 00:26:28,330
it on a per case basis I would and any

00:26:26,770 --> 00:26:30,340
argument like this I'd say but why do

00:26:28,330 --> 00:26:31,810
you want to use jboss white and then try

00:26:30,340 --> 00:26:34,900
and pick that argument a party as well

00:26:31,810 --> 00:26:36,280
it has way I approach it but if you

00:26:34,900 --> 00:26:39,700
that's not an option I'd harp on about

00:26:36,280 --> 00:26:41,470
the the pros of using Python it scales a

00:26:39,700 --> 00:26:43,990
lot easier than jboss the tooling around

00:26:41,470 --> 00:26:47,350
python is mostly free it's much easier

00:26:43,990 --> 00:26:49,600
to maintain codes much better to work on

00:26:47,350 --> 00:26:53,280
it costs us less to develop etc etc etc

00:26:49,600 --> 00:26:53,280
and see what they say thanks

00:26:54,850 --> 00:27:05,200
other questions hi I'm one of the Java

00:27:01,870 --> 00:27:09,910
program as you've been picking on and to

00:27:05,200 --> 00:27:12,610
me the big advantage of static typing is

00:27:09,910 --> 00:27:15,280
the amount of tool support it gives you

00:27:12,610 --> 00:27:17,020
for things like automated refactoring as

00:27:15,280 --> 00:27:20,680
well as the compiler being able to spot

00:27:17,020 --> 00:27:23,140
certain classes of errors and bonds so

00:27:20,680 --> 00:27:25,450
I'm curious what kind of tools there are

00:27:23,140 --> 00:27:28,150
to support the to work with the static

00:27:25,450 --> 00:27:32,410
typing that's now available in Python so

00:27:28,150 --> 00:27:35,020
I think you'll find that tools like

00:27:32,410 --> 00:27:39,100
pycharm and other ideas like that were

00:27:35,020 --> 00:27:40,870
already doing some sort of hidden tie

00:27:39,100 --> 00:27:42,220
pins of themselves so they were creating

00:27:40,870 --> 00:27:44,500
the tie pins and saving them in the

00:27:42,220 --> 00:27:46,180
background what pep 484 is going to mean

00:27:44,500 --> 00:27:47,770
is that instead of having to do that

00:27:46,180 --> 00:27:49,210
they'll be able to use the Taipings

00:27:47,770 --> 00:27:51,970
you're already putting into your code in

00:27:49,210 --> 00:27:54,400
to do the refactoring so tools like that

00:27:51,970 --> 00:27:56,830
like pycharm will benefit greatly in any

00:27:54,400 --> 00:27:59,230
sort of idea having said that I not

00:27:56,830 --> 00:28:00,880
personally found PyCharm too bad in

00:27:59,230 --> 00:28:03,790
terms of refactoring it you usually does

00:28:00,880 --> 00:28:05,500
a pretty good job so in terms of other

00:28:03,790 --> 00:28:08,350
tools if you haven't used my pi already

00:28:05,500 --> 00:28:09,700
then that coming to the fall be good for

00:28:08,350 --> 00:28:11,290
everyone that has existed for a while

00:28:09,700 --> 00:28:12,730
and I didn't really know till I looked

00:28:11,290 --> 00:28:14,280
at Pep 484 probably because I wasn't

00:28:12,730 --> 00:28:16,870
googling around for static type checkers

00:28:14,280 --> 00:28:18,220
but because of pep 484 I now know it

00:28:16,870 --> 00:28:23,050
exists in it and it's really a useful

00:28:18,220 --> 00:28:24,970
tool it means that people like big

00:28:23,050 --> 00:28:26,680
enterprise companies well modern

00:28:24,970 --> 00:28:28,240
enterprise companies like Dropbox etc

00:28:26,680 --> 00:28:29,950
will consider passing because they have

00:28:28,240 --> 00:28:33,900
the ability to do this time the static

00:28:29,950 --> 00:28:33,900
type checking the day say is necessary

00:28:34,020 --> 00:28:39,670
cool time for food yeah all right thank

00:28:38,260 --> 00:28:41,730
you very much Ryan

00:28:39,670 --> 00:28:41,730
you

00:28:50,080 --> 00:28:52,140

YouTube URL: https://www.youtube.com/watch?v=-Fqz_wanF1Y


