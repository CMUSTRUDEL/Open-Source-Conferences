Title: Monads, in my Python? by Xuanyi Chew
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Monads shouldn't be difficult to understand. This talk aims to show what monads are, and why you shouldn't be afraid of them. You most likely use them already (yes, really). 

In this talk, I'll touch briefly on category theory (don't worry, it's not scary), and a couple of practical implementation of monads. You don't have to be a functional programmer or a Haskeller to use monads.

Lastly I shall attempt to lay out a good rationale to use more monads when programming in Python

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,980 --> 00:00:16,980
our speaker now is swanee Chu and I

00:00:14,880 --> 00:00:18,510
nearly got it right he's expert bun but

00:00:16,980 --> 00:00:21,270
he lives in the Big Smoke down down in

00:00:18,510 --> 00:00:25,140
Sydney and and he's gonna give you a

00:00:21,270 --> 00:00:30,060
talk on it's got got monads in my Python

00:00:25,140 --> 00:00:32,730
okay right yeah so I'm basically going

00:00:30,060 --> 00:00:34,199
to talk about mo Nets and because this

00:00:32,730 --> 00:00:36,150
sessions before lunch and I know

00:00:34,199 --> 00:00:38,190
everyone's sort of hungry so I make I'll

00:00:36,150 --> 00:00:40,129
make this quite quick basically what I'm

00:00:38,190 --> 00:00:42,330
going to talk about is what monads are

00:00:40,129 --> 00:00:44,339
why you shouldn't be afraid of them and

00:00:42,330 --> 00:00:47,550
you problem some monads you probably

00:00:44,339 --> 00:00:50,489
already use so let's cut to the chase

00:00:47,550 --> 00:00:51,960
what are mo nets mo nets are just more

00:00:50,489 --> 00:00:56,519
nodes in the category of endor functors

00:00:51,960 --> 00:00:58,290
no problems right here is the here's an

00:00:56,519 --> 00:01:00,620
example monnet that you've been using so

00:00:58,290 --> 00:01:08,159
far you've probably been using this and

00:01:00,620 --> 00:01:09,869
that's it the end so anyway there was a

00:01:08,159 --> 00:01:13,140
joke and probably the last joke since

00:01:09,869 --> 00:01:14,820
I'm not very good comedian let's look at

00:01:13,140 --> 00:01:16,440
some real-life code this is a piece of

00:01:14,820 --> 00:01:18,750
code that I wrote basically it detects

00:01:16,440 --> 00:01:21,740
anomalies in time series and I spent two

00:01:18,750 --> 00:01:24,060
months trying to port arts STL over but

00:01:21,740 --> 00:01:26,160
that's a totally different separate

00:01:24,060 --> 00:01:27,810
story so anyway I like to I like you to

00:01:26,160 --> 00:01:30,510
observe some things about these code

00:01:27,810 --> 00:01:33,300
right the nature of code the first thing

00:01:30,510 --> 00:01:34,680
that I like you to note is that I'm not

00:01:33,300 --> 00:01:38,550
sure you can see oh you can actually see

00:01:34,680 --> 00:01:41,130
much excellent that I check for things

00:01:38,550 --> 00:01:42,840
whether the upper period parameter

00:01:41,130 --> 00:01:45,360
exists if it doesn't exist you raise an

00:01:42,840 --> 00:01:48,110
exception right a second thing I'd like

00:01:45,360 --> 00:01:51,540
you to note is that there is a somewhat

00:01:48,110 --> 00:01:52,830
flow nature of sequential flow nature of

00:01:51,540 --> 00:01:55,380
the code you first

00:01:52,830 --> 00:01:57,210
seasonally decompose it and then you

00:01:55,380 --> 00:01:59,040
take the data you - the decompose data

00:01:57,210 --> 00:02:02,540
and so on and so forth right

00:01:59,040 --> 00:02:05,520
and the third thing to observe is that

00:02:02,540 --> 00:02:07,380
each line of code has references to

00:02:05,520 --> 00:02:11,550
previous lines of code in terms of its

00:02:07,380 --> 00:02:14,670
variables now this is how I believe most

00:02:11,550 --> 00:02:15,870
real-life code looks like it's more so

00:02:14,670 --> 00:02:18,480
especially if you're trying to like

00:02:15,870 --> 00:02:21,749
expose the api's of your package or your

00:02:18,480 --> 00:02:23,340
modules so this is basically composition

00:02:21,749 --> 00:02:27,000
if we say that X

00:02:23,340 --> 00:02:29,040
is the result of calling foo and byes

00:02:27,000 --> 00:02:31,410
and why is the result of calling bar

00:02:29,040 --> 00:02:33,540
with passing in X and Zed is that it's

00:02:31,410 --> 00:02:36,530
called passing in Y we it's the

00:02:33,540 --> 00:02:40,440
compositions basically this yes follow

00:02:36,530 --> 00:02:42,629
okay same thing for same thing for

00:02:40,440 --> 00:02:44,280
operators if you say 1 plus 2 plus 3

00:02:42,629 --> 00:02:48,209
it's equivalent to having an add

00:02:44,280 --> 00:02:50,190
function that adds 1 plus 2 and then and

00:02:48,209 --> 00:02:53,610
then take the result and add it to 3 and

00:02:50,190 --> 00:02:55,230
if you follow if you follow the the math

00:02:53,610 --> 00:02:56,849
equation on the other end you realize

00:02:55,230 --> 00:02:58,349
that you've just divided by 0 and

00:02:56,849 --> 00:03:02,120
universe implodes

00:02:58,349 --> 00:03:03,599
so while the universe is actually

00:03:02,120 --> 00:03:06,299
recomposing itself

00:03:03,599 --> 00:03:08,760
let's get reacquainted with the notion

00:03:06,299 --> 00:03:11,970
of functions we all know what functions

00:03:08,760 --> 00:03:14,819
are you first define a function foo

00:03:11,970 --> 00:03:16,319
takes in maybe parameter maybe more

00:03:14,819 --> 00:03:17,819
parameters than 1 and then you do

00:03:16,319 --> 00:03:20,790
something with it you either use the

00:03:17,819 --> 00:03:23,250
parameter so you don't write and now

00:03:20,790 --> 00:03:26,569
we'll have a sort of site node into the

00:03:23,250 --> 00:03:29,160
annals of history well note that before

00:03:26,569 --> 00:03:31,489
c1 out and became the sort of dominant

00:03:29,160 --> 00:03:33,690
line paradigm Pascal had a

00:03:31,489 --> 00:03:36,299
differentiated notion of what functions

00:03:33,690 --> 00:03:38,220
are basically Pascal differentiated

00:03:36,299 --> 00:03:40,319
procedures and functions where

00:03:38,220 --> 00:03:42,480
procedures are sort of instructions that

00:03:40,319 --> 00:03:45,269
say you do this and then you do that and

00:03:42,480 --> 00:03:47,160
then you do that basically pascal

00:03:45,269 --> 00:03:48,930
procedures and even sequel procedures do

00:03:47,160 --> 00:03:49,470
not have return values it doesn't return

00:03:48,930 --> 00:03:54,329
anything

00:03:49,470 --> 00:03:56,160
whereas functions did ok now there's a

00:03:54,329 --> 00:03:57,690
second notion of function that I would

00:03:56,160 --> 00:03:59,700
like to explore and that's also the

00:03:57,690 --> 00:04:02,030
mathematicians definition of functions

00:03:59,700 --> 00:04:05,220
which we can call pure functions

00:04:02,030 --> 00:04:07,019
basically a pure function is mapping a

00:04:05,220 --> 00:04:09,709
direct mapping from one value to the

00:04:07,019 --> 00:04:12,090
next value it's a one-to-one mapping and

00:04:09,709 --> 00:04:14,220
it's always going to be constant so if

00:04:12,090 --> 00:04:16,200
you pass in let's say a number 1 into

00:04:14,220 --> 00:04:18,299
the function and it has to return

00:04:16,200 --> 00:04:20,489
something that is always the same let's

00:04:18,299 --> 00:04:23,520
say it's a function is plus 1 so if you

00:04:20,489 --> 00:04:25,349
pass in 1 it becomes 2 it if you have a

00:04:23,520 --> 00:04:27,090
function that says ok if you pass in 1

00:04:25,349 --> 00:04:30,599
and depend on whether the moon is blue

00:04:27,090 --> 00:04:33,000
like last night it may return 0 or

00:04:30,599 --> 00:04:35,039
something else and it returns some other

00:04:33,000 --> 00:04:36,520
value and in fact basically mapping from

00:04:35,039 --> 00:04:40,050
one value into

00:04:36,520 --> 00:04:43,569
values that's not a pure function okay

00:04:40,050 --> 00:04:45,819
so we can sort of graphically represent

00:04:43,569 --> 00:04:48,069
functions like this you may have seen

00:04:45,819 --> 00:04:50,289
these in your math textbooks and we can

00:04:48,069 --> 00:04:54,280
write the function like this and in

00:04:50,289 --> 00:04:58,000
that's valid Python 3.5 by the way like

00:04:54,280 --> 00:05:01,720
this okay this is this is contrary to

00:04:58,000 --> 00:05:04,000
what we know as functions we have

00:05:01,720 --> 00:05:05,830
functions that may return a value or not

00:05:04,000 --> 00:05:07,449
now in Python it's interesting because

00:05:05,830 --> 00:05:10,419
if you omit the return statement it

00:05:07,449 --> 00:05:12,639
actually returns a none all right and

00:05:10,419 --> 00:05:14,229
the return values are not met one-to-one

00:05:12,639 --> 00:05:17,680
so like I said the once in a blue moon

00:05:14,229 --> 00:05:19,599
kind of functions and most importantly

00:05:17,680 --> 00:05:22,630
our functions are also sort of

00:05:19,599 --> 00:05:25,889
combinations of procedures there's in in

00:05:22,630 --> 00:05:28,180
sequential instructions to do things so

00:05:25,889 --> 00:05:30,610
we have this and why are we interested

00:05:28,180 --> 00:05:31,930
in pure functions right am I am I trying

00:05:30,610 --> 00:05:35,139
to convert you guys into being high

00:05:31,930 --> 00:05:37,419
schoolers no actually you know the

00:05:35,139 --> 00:05:40,900
reason is because they're pure functions

00:05:37,419 --> 00:05:42,759
and what we call functions are have some

00:05:40,900 --> 00:05:44,289
sort of similarity and and this is a

00:05:42,759 --> 00:05:47,169
starting point of designing better

00:05:44,289 --> 00:05:48,789
programs so this is the comparison of

00:05:47,169 --> 00:05:51,280
what we know as functions and pure

00:05:48,789 --> 00:05:53,039
functions both take parameters and pure

00:05:51,280 --> 00:05:55,360
functions when we take one parameter

00:05:53,039 --> 00:05:57,130
both return values and the most

00:05:55,360 --> 00:06:00,120
important part is both types of

00:05:57,130 --> 00:06:02,289
functions are composable now

00:06:00,120 --> 00:06:04,539
mathematicians have noticed that from

00:06:02,289 --> 00:06:06,340
group Theory from ring theory from

00:06:04,539 --> 00:06:08,259
metric spaces from topological spaces

00:06:06,340 --> 00:06:09,639
that there are things that can be

00:06:08,259 --> 00:06:11,520
composed and they kind of look like

00:06:09,639 --> 00:06:14,680
functions but they don't necessarily

00:06:11,520 --> 00:06:16,389
conform to the idea of pure functions so

00:06:14,680 --> 00:06:18,610
they came up with a new category of

00:06:16,389 --> 00:06:23,469
mathematics and they call it category

00:06:18,610 --> 00:06:26,620
theory so what is a category it's quite

00:06:23,469 --> 00:06:29,830
simple really a category is basically a

00:06:26,620 --> 00:06:31,539
collection of things you can think of

00:06:29,830 --> 00:06:35,529
them as sets of values

00:06:31,539 --> 00:06:38,020
okay like all your variables or or olden

00:06:35,529 --> 00:06:42,520
all the possible permissible values of a

00:06:38,020 --> 00:06:45,339
type arrows it you should think of

00:06:42,520 --> 00:06:47,110
arrows as functions and arrows basically

00:06:45,339 --> 00:06:49,870
have domains the inputs and they have

00:06:47,110 --> 00:06:52,690
outputs they can be composed

00:06:49,870 --> 00:06:56,350
and they obey some form of associative

00:06:52,690 --> 00:06:58,150
nurse law now if this is a bit you

00:06:56,350 --> 00:06:59,800
spaced out a bit too much so far it's

00:06:58,150 --> 00:07:03,190
basically pretty pictures that we think

00:06:59,800 --> 00:07:07,810
about composing stuff and functions this

00:07:03,190 --> 00:07:11,920
is the typical diagram of how a category

00:07:07,810 --> 00:07:15,220
looks like it says F Maps X to Y G Maps

00:07:11,920 --> 00:07:18,460
Y to Z and if this happens there has to

00:07:15,220 --> 00:07:22,030
be a composition from X to Z which is G

00:07:18,460 --> 00:07:23,620
to F alright now this is quite abstract

00:07:22,030 --> 00:07:25,600
and it doesn't actually help us

00:07:23,620 --> 00:07:29,020
visualize what's happening so I've

00:07:25,600 --> 00:07:31,060
basically changed that a bit and do it

00:07:29,020 --> 00:07:34,660
in the old of the add form it's the same

00:07:31,060 --> 00:07:36,790
thing for me to the identity arrows

00:07:34,660 --> 00:07:41,950
because they're not helpful for this

00:07:36,790 --> 00:07:45,580
visualization so f is plus 1 G is plus 1

00:07:41,950 --> 00:07:49,680
if you map a value of 1 plus 1 it

00:07:45,580 --> 00:07:51,970
becomes 2 and plus 1 becomes 3 right so

00:07:49,680 --> 00:07:52,630
categories are kind of cool but what's

00:07:51,970 --> 00:07:55,150
the big deal

00:07:52,630 --> 00:07:58,300
why why do we bother with category

00:07:55,150 --> 00:08:00,070
theory well because category theory is

00:07:58,300 --> 00:08:02,230
the correct intuition to think about

00:08:00,070 --> 00:08:03,880
abstracting and composing things when

00:08:02,230 --> 00:08:06,760
when you want to abstract things out and

00:08:03,880 --> 00:08:08,470
compose things you generally need to

00:08:06,760 --> 00:08:10,210
think about inputs outputs and stuff

00:08:08,470 --> 00:08:13,720
like that and category theory helps us

00:08:10,210 --> 00:08:16,180
gives us the direction to go more

00:08:13,720 --> 00:08:18,760
importantly category theory also teaches

00:08:16,180 --> 00:08:21,370
us it gives us the tools to basically

00:08:18,760 --> 00:08:23,320
reason about the issues that you know we

00:08:21,370 --> 00:08:26,710
face all the time as programmers I'm

00:08:23,320 --> 00:08:28,840
going to introduce four issues known as

00:08:26,710 --> 00:08:32,310
the awkward squad sorry Simon pay

00:08:28,840 --> 00:08:35,170
attentions he he he noted that io

00:08:32,310 --> 00:08:37,180
concurrency exception and foreign

00:08:35,170 --> 00:08:38,050
function interface are basically issues

00:08:37,180 --> 00:08:41,530
with Haskell

00:08:38,050 --> 00:08:43,120
right but it's not only wrestlers who

00:08:41,530 --> 00:08:45,850
face this problem we to face this

00:08:43,120 --> 00:08:47,710
problem io it's a problem because

00:08:45,850 --> 00:08:48,970
there's permanent side effects and later

00:08:47,710 --> 00:08:52,240
I'm going to show you how to make a

00:08:48,970 --> 00:08:52,990
simple print hello world fail that's

00:08:52,240 --> 00:08:54,670
fine

00:08:52,990 --> 00:08:57,880
concurrency we all know about threads

00:08:54,670 --> 00:09:00,670
and locks and how messy can be and yeah

00:08:57,880 --> 00:09:02,830
so we in in Python we deal with

00:09:00,670 --> 00:09:03,640
exceptions quite easily we've got try

00:09:02,830 --> 00:09:07,000
accepts

00:09:03,640 --> 00:09:09,370
fair enough and dependence on external

00:09:07,000 --> 00:09:11,290
information earlier hawky basically

00:09:09,370 --> 00:09:15,480
covered a lot of my points and my talk

00:09:11,290 --> 00:09:18,670
so I'm just going to skip past them so

00:09:15,480 --> 00:09:21,540
the thing is due to all these external

00:09:18,670 --> 00:09:25,089
effects and side effects and you know

00:09:21,540 --> 00:09:27,100
non determinism errors or different

00:09:25,089 --> 00:09:28,329
types our programs fail constantly in

00:09:27,100 --> 00:09:30,339
fact as programmers we deal with

00:09:28,329 --> 00:09:33,940
failures all the time here's how you

00:09:30,339 --> 00:09:35,820
fail print so you have a program that

00:09:33,940 --> 00:09:39,370
says while true you print hello world

00:09:35,820 --> 00:09:42,519
that's not going to fail right unless

00:09:39,370 --> 00:09:46,300
you pipe it to head who knows who

00:09:42,519 --> 00:09:48,610
doesn't know what head does alright head

00:09:46,300 --> 00:09:51,070
is basically a program a UNIX program

00:09:48,610 --> 00:09:53,440
that takes an input and it takes a top

00:09:51,070 --> 00:09:55,000
end lines that you pass it in so in this

00:09:53,440 --> 00:09:56,740
case the input because we pipe it

00:09:55,000 --> 00:09:58,930
through its the input is basically

00:09:56,740 --> 00:10:00,910
standard out and the output from the

00:09:58,930 --> 00:10:03,640
program that Python program we have is

00:10:00,910 --> 00:10:04,930
basically it pipes it to set it out so

00:10:03,640 --> 00:10:07,540
it reads from standard out and then

00:10:04,930 --> 00:10:10,269
closes the pipe so when you close the

00:10:07,540 --> 00:10:11,890
pipe your Python program fails now I

00:10:10,269 --> 00:10:16,209
want you to think about how you would

00:10:11,890 --> 00:10:18,100
recover from this in a program failure

00:10:16,209 --> 00:10:20,050
scenarios are actually very very common

00:10:18,100 --> 00:10:21,730
and in fact a lot of programming

00:10:20,050 --> 00:10:24,790
languages provide an opinion on what to

00:10:21,730 --> 00:10:26,949
do with failures but so let's maybe we

00:10:24,790 --> 00:10:31,420
should delve in a bit deeper to see how

00:10:26,949 --> 00:10:34,120
we deal with failures right now here is

00:10:31,420 --> 00:10:35,949
a concrete example we have division

00:10:34,120 --> 00:10:39,190
you've got that takes a numerator and a

00:10:35,949 --> 00:10:40,930
denominator and then it divides and a

00:10:39,190 --> 00:10:43,959
square root basically calls an external

00:10:40,930 --> 00:10:47,140
library math and calls function square

00:10:43,959 --> 00:10:48,490
root this is this is a very simple

00:10:47,140 --> 00:10:50,579
example but I want you to think of this

00:10:48,490 --> 00:10:55,029
as some designing an API for your

00:10:50,579 --> 00:10:56,890
package of module so when you design a

00:10:55,029 --> 00:10:58,120
PS and you think of what are the

00:10:56,890 --> 00:11:01,149
possible inputs and what are the

00:10:58,120 --> 00:11:02,529
possible outputs from your methods so

00:11:01,149 --> 00:11:05,079
let's look at that

00:11:02,529 --> 00:11:08,440
the inputs for div and square root are

00:11:05,079 --> 00:11:10,339
basically any kind of numeric type for

00:11:08,440 --> 00:11:12,860
yes

00:11:10,339 --> 00:11:13,490
everyone can see that and what are the

00:11:12,860 --> 00:11:17,660
outputs

00:11:13,490 --> 00:11:18,949
they are generally floats because after

00:11:17,660 --> 00:11:20,540
you divide they always come to as a

00:11:18,949 --> 00:11:23,779
float after you square it always comes

00:11:20,540 --> 00:11:25,639
out as a float fair enough so let's

00:11:23,779 --> 00:11:27,230
let's try to make this put this in the

00:11:25,639 --> 00:11:30,800
context of category theory and see what

00:11:27,230 --> 00:11:34,519
happens so you have a set of values 2 4

00:11:30,800 --> 00:11:37,490
5 0 you pass it in and let's let's make

00:11:34,519 --> 00:11:40,670
the numerator 100 and you pass in div

00:11:37,490 --> 00:11:45,019
and you divide 100 by 2 you get 50 100

00:11:40,670 --> 00:11:47,980
by 4 you get 2500 5 divided by 5 you get

00:11:45,019 --> 00:11:51,050
20 and hundred divided by 0 you get 0

00:11:47,980 --> 00:11:54,470
division error what is the zero division

00:11:51,050 --> 00:11:56,329
error there is no defined it's not

00:11:54,470 --> 00:12:00,350
defined as an integer is not fun it's

00:11:56,329 --> 00:12:03,410
just an error then because of this the

00:12:00,350 --> 00:12:05,629
composition to to square becomes you

00:12:03,410 --> 00:12:10,220
know the next step in the pipeline

00:12:05,629 --> 00:12:12,110
basically fails as well so ok we'll say

00:12:10,220 --> 00:12:14,329
right we'll extend the range we'll

00:12:12,110 --> 00:12:17,120
extend it from an error into some some

00:12:14,329 --> 00:12:20,120
sort of known types so we extend the

00:12:17,120 --> 00:12:22,939
range and say clean Dave is now either

00:12:20,120 --> 00:12:24,949
returns a float or a none and we can do

00:12:22,939 --> 00:12:26,269
the same for square root because square

00:12:24,949 --> 00:12:27,860
roots of negative numbers are basically

00:12:26,269 --> 00:12:32,389
imaginary numbers and we're not going to

00:12:27,860 --> 00:12:35,029
deal with them now so here I listed both

00:12:32,389 --> 00:12:38,480
both ways that Python people always used

00:12:35,029 --> 00:12:41,720
to handle exceptions one is a try except

00:12:38,480 --> 00:12:45,470
once and if check the new ranges are

00:12:41,720 --> 00:12:47,959
basically this float or none type but

00:12:45,470 --> 00:12:51,529
the problem with this is once you once

00:12:47,959 --> 00:12:52,490
you extend your ranges you have issues

00:12:51,529 --> 00:12:54,139
with composability

00:12:52,490 --> 00:12:58,309
you cannot compose your functions nicely

00:12:54,139 --> 00:13:02,179
you have to do an external check right

00:12:58,309 --> 00:13:03,949
you guys follow so far cool so the other

00:13:02,179 --> 00:13:06,559
solution would be to extend both the

00:13:03,949 --> 00:13:08,660
domain and ranges so you have you have

00:13:06,559 --> 00:13:11,389
input checks to check for your inputs in

00:13:08,660 --> 00:13:15,829
your new functions and basically you

00:13:11,389 --> 00:13:17,720
check that you check that X is not X

00:13:15,829 --> 00:13:21,049
isn't definitely not X is bigger than 0

00:13:17,720 --> 00:13:22,790
or it's not none the check for square

00:13:21,049 --> 00:13:23,360
roots interesting because you cannot do

00:13:22,790 --> 00:13:26,149
if

00:13:23,360 --> 00:13:29,149
not X because square root of zero is

00:13:26,149 --> 00:13:31,519
zero and it is a valid value right so

00:13:29,149 --> 00:13:34,310
when we extend the ranges and the

00:13:31,519 --> 00:13:37,190
domains it looks something like this so

00:13:34,310 --> 00:13:41,110
you've got two kinds of two two types of

00:13:37,190 --> 00:13:44,720
valid input and it passes in right and

00:13:41,110 --> 00:13:46,130
this is clearly quite tedious to compose

00:13:44,720 --> 00:13:49,160
functions you basically need to create

00:13:46,130 --> 00:13:51,860
new function what's the point or you can

00:13:49,160 --> 00:13:55,519
do it like what we normally do and this

00:13:51,860 --> 00:13:57,529
we do we do try accepts all the time

00:13:55,519 --> 00:13:59,209
but the problem of this is it hampers on

00:13:57,529 --> 00:14:02,060
your readability and understand ability

00:13:59,209 --> 00:14:03,709
and how you reason about your program so

00:14:02,060 --> 00:14:06,560
the question is this is there a way to

00:14:03,709 --> 00:14:10,700
generalize and basically map from this

00:14:06,560 --> 00:14:13,339
category into this category well the

00:14:10,700 --> 00:14:15,079
answer's no nets which I would like you

00:14:13,339 --> 00:14:17,110
to recall that monads are just some

00:14:15,079 --> 00:14:19,310
monoid in the category of endo factors

00:14:17,110 --> 00:14:22,700
so let's have a look at what a

00:14:19,310 --> 00:14:23,870
definition of a function is a function

00:14:22,700 --> 00:14:26,510
is basically a mapping between

00:14:23,870 --> 00:14:30,290
categories tada you have just invented

00:14:26,510 --> 00:14:31,970
monads so let's ignore what a monoid is

00:14:30,290 --> 00:14:33,320
it's basically an algebraic structure

00:14:31,970 --> 00:14:37,160
with us blah blah blah

00:14:33,320 --> 00:14:39,560
so yeah a lot of theoretical stuff all

00:14:37,160 --> 00:14:43,160
right I'm not I'm not particularly

00:14:39,560 --> 00:14:44,750
looking at category theory so let's

00:14:43,160 --> 00:14:47,449
let's talk about real life let's see how

00:14:44,750 --> 00:14:49,490
we can implement monads in Python but

00:14:47,449 --> 00:14:52,399
before that let's have a recap on what

00:14:49,490 --> 00:14:54,320
interfaces are if you guys have been to

00:14:52,399 --> 00:14:57,680
jaquise talk earlier you probably

00:14:54,320 --> 00:14:59,149
already know what interfaces are so we

00:14:57,680 --> 00:15:03,589
say that we create a new class called

00:14:59,149 --> 00:15:06,140
value and value no tighter and one of

00:15:03,589 --> 00:15:09,589
them allows you to use the state use the

00:15:06,140 --> 00:15:11,180
for I envy statement the other one

00:15:09,589 --> 00:15:13,730
doesn't allow you the other one will

00:15:11,180 --> 00:15:16,190
basically say hey it's a type error it's

00:15:13,730 --> 00:15:19,490
not an iterable right Python doesn't

00:15:16,190 --> 00:15:21,709
have inter explicit interfaces like Java

00:15:19,490 --> 00:15:23,120
it's sort of an I understand you and

00:15:21,709 --> 00:15:25,160
it's then we'll just sort of implement

00:15:23,120 --> 00:15:28,850
it kind of thing and if we sure I guess

00:15:25,160 --> 00:15:32,380
so in order to in order to implement an

00:15:28,850 --> 00:15:35,870
iterable interface you basically

00:15:32,380 --> 00:15:37,190
implement it and under item method fair

00:15:35,870 --> 00:15:39,680
following so far

00:15:37,190 --> 00:15:41,839
so that's how you implement monads in

00:15:39,680 --> 00:15:43,759
Python now in any other languages

00:15:41,839 --> 00:15:47,920
actually monads are basically an

00:15:43,759 --> 00:15:50,449
interface with bind and units that's it

00:15:47,920 --> 00:15:52,910
that's what mu net binds are basically

00:15:50,449 --> 00:15:54,709
takes two parameters once a function and

00:15:52,910 --> 00:15:57,769
once the value points a monadic value

00:15:54,709 --> 00:16:00,319
and applies the function on the magnetic

00:15:57,769 --> 00:16:02,420
value unit basically creates a magnetic

00:16:00,319 --> 00:16:04,339
value okay

00:16:02,420 --> 00:16:05,899
and when I say bind and unit it doesn't

00:16:04,339 --> 00:16:08,600
mean they have to be methods of a class

00:16:05,899 --> 00:16:11,269
it can be functions outside or methods

00:16:08,600 --> 00:16:13,180
all right it can anything bind and unit

00:16:11,269 --> 00:16:15,110
works on is a monadic value and

00:16:13,180 --> 00:16:17,029
practically speaking there are as many

00:16:15,110 --> 00:16:18,949
monads as you can think about and this

00:16:17,029 --> 00:16:21,709
is something that a lot of people don't

00:16:18,949 --> 00:16:24,699
seem to get or get confused with is that

00:16:21,709 --> 00:16:28,220
monads are like a design pattern really

00:16:24,699 --> 00:16:31,009
okay they're really generalized

00:16:28,220 --> 00:16:33,350
descriptions of computation and and bind

00:16:31,009 --> 00:16:37,160
the binding function the bind method is

00:16:33,350 --> 00:16:38,839
basically you defining how your

00:16:37,160 --> 00:16:44,060
functions can compose with each other

00:16:38,839 --> 00:16:45,500
okay so you may be asking and obviously

00:16:44,060 --> 00:16:47,300
there's also the Monette laws that apply

00:16:45,500 --> 00:16:49,399
but i'm gonna skip through this unless

00:16:47,300 --> 00:16:52,220
we've got time so you may be asking what

00:16:49,399 --> 00:16:55,040
are monadic values you've seen them

00:16:52,220 --> 00:16:59,449
already actually this was the mapped out

00:16:55,040 --> 00:17:02,329
chart earlier let's box them up there

00:16:59,449 --> 00:17:04,100
you go when I take values basically

00:17:02,329 --> 00:17:06,880
values in a box in the earth with the

00:17:04,100 --> 00:17:11,780
context the bind method simply makes the

00:17:06,880 --> 00:17:14,030
makes the function f and G aware of the

00:17:11,780 --> 00:17:17,240
context that it is operating in that's

00:17:14,030 --> 00:17:19,010
all and what we've just this did was

00:17:17,240 --> 00:17:19,900
basically designed something called a

00:17:19,010 --> 00:17:22,939
maybe monad

00:17:19,900 --> 00:17:24,890
okay the maybe monad deals with failure

00:17:22,939 --> 00:17:27,020
conditions it applies a function if the

00:17:24,890 --> 00:17:30,409
input is none if if the input is not

00:17:27,020 --> 00:17:32,480
none if the input is none you inside the

00:17:30,409 --> 00:17:35,539
monette monadic value is none will just

00:17:32,480 --> 00:17:38,750
say okay fine it's none and unit returns

00:17:35,539 --> 00:17:41,480
the value no it's quite hard to talk

00:17:38,750 --> 00:17:43,370
about know nets with without talking

00:17:41,480 --> 00:17:45,799
about types but fortunately in python we

00:17:43,370 --> 00:17:49,250
can create our own types and their core

00:17:45,799 --> 00:17:50,990
classes it so we create a value class

00:17:49,250 --> 00:17:55,970
which we will see you later bye

00:17:50,990 --> 00:17:58,520
here's the bind and the unit so the bind

00:17:55,970 --> 00:18:00,230
basically says that if it's not none or

00:17:58,520 --> 00:18:03,640
if there's a none in the keyword we just

00:18:00,230 --> 00:18:07,250
return none and we apply the function to

00:18:03,640 --> 00:18:09,620
the value I have an I have a helper

00:18:07,250 --> 00:18:10,790
function that unboxers the value which

00:18:09,620 --> 00:18:13,809
takes out the value so that the

00:18:10,790 --> 00:18:16,130
functions can actually apply on them and

00:18:13,809 --> 00:18:18,020
another thing is that I wrote this in a

00:18:16,130 --> 00:18:19,510
sort of in the form of decorators

00:18:18,020 --> 00:18:21,920
because this is how I use them

00:18:19,510 --> 00:18:23,510
really the maybe monad is so simple that

00:18:21,920 --> 00:18:25,820
there is no need for an external library

00:18:23,510 --> 00:18:28,550
you just write your decorators and this

00:18:25,820 --> 00:18:30,380
is the class in fact you don't even have

00:18:28,550 --> 00:18:32,210
to write a class for the maybe monad I'm

00:18:30,380 --> 00:18:33,800
just wrapping it in a class to make sure

00:18:32,210 --> 00:18:39,350
that you are aware that what you need

00:18:33,800 --> 00:18:43,160
does so follow so far cool here's how

00:18:39,350 --> 00:18:45,140
you implement it you say look how nice

00:18:43,160 --> 00:18:47,540
the div and the square root functions

00:18:45,140 --> 00:18:50,300
are it's it's basic checks that's all

00:18:47,540 --> 00:18:53,750
there's nothing funny happening and when

00:18:50,300 --> 00:18:55,580
you when you when you apply div 102 for

00:18:53,750 --> 00:18:57,950
and then square root it comes out with

00:18:55,580 --> 00:19:01,280
five and the type is a value the class

00:18:57,950 --> 00:19:04,309
value right maybe we should try thanking

00:19:01,280 --> 00:19:07,400
the project and we say divide 100 by

00:19:04,309 --> 00:19:12,530
zero now because it's a monadic value it

00:19:07,400 --> 00:19:16,790
knows that it returns none it returns

00:19:12,530 --> 00:19:19,910
none here so when when when square root

00:19:16,790 --> 00:19:21,530
is applied to none it knows that it the

00:19:19,910 --> 00:19:22,940
bind knows that okay we're just going to

00:19:21,530 --> 00:19:27,920
short-circuit this and return and this

00:19:22,940 --> 00:19:29,929
role okay so bind basically applies the

00:19:27,920 --> 00:19:31,700
function on to the moon X and the unit

00:19:29,929 --> 00:19:35,480
basically makes sure that the return

00:19:31,700 --> 00:19:37,400
function is a magnetic value now I'm

00:19:35,480 --> 00:19:40,429
also going to talk about the next Monnet

00:19:37,400 --> 00:19:42,230
which is o also that you can nicely

00:19:40,429 --> 00:19:44,870
chain them up and nothing's going to

00:19:42,230 --> 00:19:46,820
sort of freak out on you the next moment

00:19:44,870 --> 00:19:50,660
we're going to talk about is the list

00:19:46,820 --> 00:19:52,940
monad the list monad basically applies a

00:19:50,660 --> 00:19:54,650
function inside a list and flattens the

00:19:52,940 --> 00:19:59,570
result if if the result comes out as a

00:19:54,650 --> 00:20:02,550
list the unit is very simple it puts the

00:19:59,570 --> 00:20:07,110
element in the list simple

00:20:02,550 --> 00:20:09,750
I didn't write it as AI decorates at

00:20:07,110 --> 00:20:11,910
this time this is just a push home the

00:20:09,750 --> 00:20:15,450
point that Mona's can exist in a variety

00:20:11,910 --> 00:20:17,070
of forms okay and you're gonna see a

00:20:15,450 --> 00:20:19,860
different form again later

00:20:17,070 --> 00:20:22,980
this list comprehensions been hard to

00:20:19,860 --> 00:20:26,970
understand so it's basically 4x4 I in

00:20:22,980 --> 00:20:29,880
acts we for INX we apply Fi and then you

00:20:26,970 --> 00:20:31,530
fi will return a list when then we'll

00:20:29,880 --> 00:20:34,140
just flatten it out go to each element

00:20:31,530 --> 00:20:35,700
of this and put it back into this unit

00:20:34,140 --> 00:20:38,430
is simple just returns it in the list

00:20:35,700 --> 00:20:41,580
and we'll define a new function called

00:20:38,430 --> 00:20:43,740
square root this time and if it's we all

00:20:41,580 --> 00:20:45,630
know that Square real numbers have two

00:20:43,740 --> 00:20:48,600
roots a positive and negative root yes

00:20:45,630 --> 00:20:50,340
so if it's if it's less than zero will

00:20:48,600 --> 00:20:53,790
return an empty list because there is

00:20:50,340 --> 00:20:55,890
nothing to be square rooting but if it's

00:20:53,790 --> 00:20:59,430
not we'll return two values the positive

00:20:55,890 --> 00:21:02,310
root and the negative root so this is

00:20:59,430 --> 00:21:04,740
how you apply it if you apply bind on

00:21:02,310 --> 00:21:07,080
square root apply square root to a union

00:21:04,740 --> 00:21:10,740
of hundred basically at least 100 it

00:21:07,080 --> 00:21:13,350
returns 10 and negative 10 now and then

00:21:10,740 --> 00:21:15,570
you can chain them up nicely and it only

00:21:13,350 --> 00:21:17,190
returns two because it doesn't do when

00:21:15,570 --> 00:21:19,080
it iterates through an empty list it

00:21:17,190 --> 00:21:22,620
doesn't return any values following so

00:21:19,080 --> 00:21:25,530
far cool or you can just you know pass

00:21:22,620 --> 00:21:28,280
in bind square root on a list of numbers

00:21:25,530 --> 00:21:31,410
and you'll return the numbers correct so

00:21:28,280 --> 00:21:33,660
now if this this if this seems a bit

00:21:31,410 --> 00:21:36,150
familiar it's because you've already

00:21:33,660 --> 00:21:40,320
been using it this comprehension is is a

00:21:36,150 --> 00:21:43,080
kind of monnet all right and you can

00:21:40,320 --> 00:21:46,830
again do it in this comprehension or you

00:21:43,080 --> 00:21:48,870
can map it apply map on a list obviously

00:21:46,830 --> 00:21:51,210
these will not return the same results

00:21:48,870 --> 00:21:54,950
these these two functions will return

00:21:51,210 --> 00:21:59,010
listening list yes what's that question

00:21:54,950 --> 00:22:00,810
so let's see what's the general idea the

00:21:59,010 --> 00:22:03,870
general idea is that mo nets help us

00:22:00,810 --> 00:22:06,780
with composition composing functions

00:22:03,870 --> 00:22:07,320
with different return types and how you

00:22:06,780 --> 00:22:09,210
do it

00:22:07,320 --> 00:22:12,180
is basically you wrap something in a

00:22:09,210 --> 00:22:13,710
mode attic value which you can define on

00:22:12,180 --> 00:22:15,879
your own you can be a list they can be a

00:22:13,710 --> 00:22:19,659
class can be well it can be

00:22:15,879 --> 00:22:22,719
two separate ideas right and then you

00:22:19,659 --> 00:22:25,839
define a bind which explains how to

00:22:22,719 --> 00:22:27,969
compose these functions that's it

00:22:25,839 --> 00:22:30,039
now before times up we'll look at one

00:22:27,969 --> 00:22:33,039
last minute and it doesn't have a name

00:22:30,039 --> 00:22:35,829
but we'll just look at it so we say we

00:22:33,039 --> 00:22:38,039
define Union as return the Open File and

00:22:35,829 --> 00:22:42,399
then called the dunder enter method and

00:22:38,039 --> 00:22:45,819
the bind is it's written as a decorator

00:22:42,399 --> 00:22:50,649
on a function that does that applies a

00:22:45,819 --> 00:22:53,889
function onto the magnetic value F okay

00:22:50,649 --> 00:22:56,199
muriatic value X and then after that it

00:22:53,889 --> 00:22:58,659
calls the danda exit and it returns the

00:22:56,199 --> 00:23:01,959
return value and will call will say do

00:22:58,659 --> 00:23:05,159
stuff is read lines and we'll call lines

00:23:01,959 --> 00:23:09,749
do stuff let's say sound familiar to you

00:23:05,159 --> 00:23:12,190
know this is basically a Monnet and

00:23:09,749 --> 00:23:15,549
remember that monads basically allow you

00:23:12,190 --> 00:23:17,649
to apply a function and within a context

00:23:15,549 --> 00:23:20,349
what is this called this is called a

00:23:17,649 --> 00:23:24,099
context manager hey pythons provided new

00:23:20,349 --> 00:23:25,809
monads now in reality though a lot of

00:23:24,099 --> 00:23:27,549
monads exist in high school and we don't

00:23:25,809 --> 00:23:29,349
need them because Python provides extra

00:23:27,549 --> 00:23:32,039
shortcuts for them and we can handle

00:23:29,349 --> 00:23:33,929
like short print print statements and

00:23:32,039 --> 00:23:37,690
side-effects without much of a problem

00:23:33,929 --> 00:23:41,289
so the idea is that we want to be aware

00:23:37,690 --> 00:23:43,179
of what monads are okay here are some

00:23:41,289 --> 00:23:45,279
other possible monads twist that's

00:23:43,179 --> 00:23:47,139
deferred is a monad and it was written

00:23:45,279 --> 00:23:47,879
ten years before promises just so you

00:23:47,139 --> 00:23:50,949
know

00:23:47,879 --> 00:23:53,259
Django's query and dot filter are also

00:23:50,949 --> 00:23:55,690
more net the results of those are also

00:23:53,259 --> 00:23:57,219
monette and I have to actually check

00:23:55,690 --> 00:24:01,299
those if those actually run it but

00:23:57,219 --> 00:24:03,789
anyway after all this why does this all

00:24:01,299 --> 00:24:06,339
matter okay

00:24:03,789 --> 00:24:09,369
because programming is all about

00:24:06,339 --> 00:24:13,529
composition composition is the heart of

00:24:09,369 --> 00:24:15,789
programming I started this talk with

00:24:13,529 --> 00:24:18,519
function that shows you that it's a

00:24:15,789 --> 00:24:20,440
sequential manner you use previous

00:24:18,519 --> 00:24:22,509
previously known variables and stuff

00:24:20,440 --> 00:24:25,269
like that it's basically come basically

00:24:22,509 --> 00:24:27,129
composition all right and I think that

00:24:25,269 --> 00:24:28,110
program should be easy for people to

00:24:27,129 --> 00:24:30,659
reason about

00:24:28,110 --> 00:24:32,700
instead of haphazardly recreating

00:24:30,659 --> 00:24:35,970
solutions why not have a general

00:24:32,700 --> 00:24:38,990
solution and apply it and apply it to

00:24:35,970 --> 00:24:41,730
you know the underlying problem okay

00:24:38,990 --> 00:24:44,429
nicely composed functions also allow us

00:24:41,730 --> 00:24:47,190
to think about programs in different

00:24:44,429 --> 00:24:51,210
paradigms basically if you like anyone

00:24:47,190 --> 00:24:54,000
here uses D No okay anyway there's this

00:24:51,210 --> 00:24:55,769
really cool thing where D has a thing

00:24:54,000 --> 00:24:58,350
called you FCS universal function

00:24:55,769 --> 00:25:00,510
declaration syntax something it syntax

00:24:58,350 --> 00:25:03,720
yes basically you can you can at any

00:25:00,510 --> 00:25:06,210
point in time you can chain a function

00:25:03,720 --> 00:25:08,340
in D if you like if you like the UFC s

00:25:06,210 --> 00:25:11,100
why not apply it in Python and if if you

00:25:08,340 --> 00:25:13,289
apply it if you create that paradigm in

00:25:11,100 --> 00:25:16,789
Python it's most likely going to be a

00:25:13,289 --> 00:25:22,980
monnet that's it really the end

00:25:16,789 --> 00:25:25,799
questions I know pretty funny questions

00:25:22,980 --> 00:25:36,529
come on off the mic and ask him did I

00:25:25,799 --> 00:25:38,340
lose you guys some way into this so

00:25:36,529 --> 00:25:39,720
looking at it so what you're talking

00:25:38,340 --> 00:25:41,610
about here I guess is really quite

00:25:39,720 --> 00:25:43,620
interesting out in your explanation of

00:25:41,610 --> 00:25:45,539
monads I am somebody that loves the

00:25:43,620 --> 00:25:48,179
theory of functional programming but

00:25:45,539 --> 00:25:49,710
it's not a functional programmer and

00:25:48,179 --> 00:25:51,149
moan out to that really hard thing that

00:25:49,710 --> 00:25:52,440
it kind of like assists growing in your

00:25:51,149 --> 00:25:54,720
head and you're waiting for it to

00:25:52,440 --> 00:25:56,100
explode so I enjoy what you've done

00:25:54,720 --> 00:25:57,450
because you've kind of drawn some

00:25:56,100 --> 00:26:01,340
patterns around that but I want to know

00:25:57,450 --> 00:26:04,019
as a engineer how is that helping you

00:26:01,340 --> 00:26:06,240
attack your problems because what you're

00:26:04,019 --> 00:26:08,909
saying on this last slide here is to me

00:26:06,240 --> 00:26:14,419
I'm reading it as you're finding that

00:26:08,909 --> 00:26:16,559
you're creating more abstractions well

00:26:14,419 --> 00:26:17,279
maybe that's what you tell me that if

00:26:16,559 --> 00:26:18,360
you think you're creating more

00:26:17,279 --> 00:26:19,380
abstractions what do you think you're

00:26:18,360 --> 00:26:22,110
doing with this like how does that

00:26:19,380 --> 00:26:24,240
actually I guess say oh that would have

00:26:22,110 --> 00:26:26,130
better how is this making you a better

00:26:24,240 --> 00:26:28,070
engineer and how do you think this is

00:26:26,130 --> 00:26:30,990
making you write more optimized code

00:26:28,070 --> 00:26:34,470
optimized I'm not so sure about tomatoes

00:26:30,990 --> 00:26:36,630
but it's I can write code that I can

00:26:34,470 --> 00:26:39,870
reason about better if you look back

00:26:36,630 --> 00:26:42,330
into into the first slide I had

00:26:39,870 --> 00:26:44,880
you see that the checks only in the top

00:26:42,330 --> 00:26:46,260
part of the function after that I don't

00:26:44,880 --> 00:26:48,809
check with anything because everything

00:26:46,260 --> 00:26:50,400
then if you look at the code like that I

00:26:48,809 --> 00:26:52,380
can reason hey I'm doing this and then

00:26:50,400 --> 00:26:54,540
this and then this and then this it

00:26:52,380 --> 00:26:57,000
makes it easier to reason about the code

00:26:54,540 --> 00:26:59,309
now clearly you can write some really

00:26:57,000 --> 00:27:00,990
optimize moment but I mean yeah I just

00:26:59,309 --> 00:27:03,360
use a simple maybe alright so what

00:27:00,990 --> 00:27:04,620
you're doing with it then is because you

00:27:03,360 --> 00:27:06,059
know obviously we're talking about you

00:27:04,620 --> 00:27:08,490
you're talking about this as applied to

00:27:06,059 --> 00:27:10,440
Python but then you also spoke about

00:27:08,490 --> 00:27:12,870
applying things other ways you can apply

00:27:10,440 --> 00:27:14,520
it in other languages etc so really what

00:27:12,870 --> 00:27:16,260
you're doing with this is using it as a

00:27:14,520 --> 00:27:18,179
design pattern for how you're

00:27:16,260 --> 00:27:21,179
approaching your problems correct and

00:27:18,179 --> 00:27:22,650
you find that that design pattern you

00:27:21,179 --> 00:27:23,910
can a Plex it seems to me the way you've

00:27:22,650 --> 00:27:25,890
done it there I could pretty much apply

00:27:23,910 --> 00:27:29,610
that across any language I wanted to yes

00:27:25,890 --> 00:27:33,900
yeah that's actually true if you're some

00:27:29,610 --> 00:27:35,130
languages it's it's actually it's more

00:27:33,900 --> 00:27:36,420
difficult to apply this in some

00:27:35,130 --> 00:27:38,820
languages like Java because they don't

00:27:36,420 --> 00:27:41,059
have first-class functions have you done

00:27:38,820 --> 00:27:43,500
it with JavaScript stuff as well I have

00:27:41,059 --> 00:27:46,320
basically it is easier to apply it to

00:27:43,500 --> 00:27:50,730
than Java right you can apply anything

00:27:46,320 --> 00:27:52,920
to JavaScript and Java Java is just

00:27:50,730 --> 00:27:55,080
classes all the way down you know so and

00:27:52,920 --> 00:27:57,900
one last really quick thing when you're

00:27:55,080 --> 00:27:59,910
mentoring junior developers an engineer

00:27:57,900 --> 00:28:01,559
is how do you find that this is a great

00:27:59,910 --> 00:28:02,820
way to get them because you're the

00:28:01,559 --> 00:28:04,380
hardest thing is to actually get them

00:28:02,820 --> 00:28:07,050
thinking in design patterns right and

00:28:04,380 --> 00:28:08,220
not just slapping up code so do you

00:28:07,050 --> 00:28:10,110
think that this is a good way to

00:28:08,220 --> 00:28:12,630
approach that problem I don't do a lot

00:28:10,110 --> 00:28:14,550
of mentoring but what I think of this is

00:28:12,630 --> 00:28:15,929
basically creating a language on top of

00:28:14,550 --> 00:28:17,550
language and then people just apply the

00:28:15,929 --> 00:28:24,240
language the new the new language to

00:28:17,550 --> 00:28:36,960
write code cool thank you sorry hey it

00:28:24,240 --> 00:28:39,750
was great Ben sorry Lachlan yes and

00:28:36,960 --> 00:28:40,980
pipelines yes I think like I really

00:28:39,750 --> 00:28:42,990
appreciate that and I found that it's

00:28:40,980 --> 00:28:45,059
actually like the functional methodology

00:28:42,990 --> 00:28:45,960
actually quite good for that my question

00:28:45,059 --> 00:28:48,750
is actually how you're fighting

00:28:45,960 --> 00:28:50,760
performance applying this on top of pie

00:28:48,750 --> 00:28:53,190
thing because as arguments like the

00:28:50,760 --> 00:28:56,010
Haskell performance issues and open

00:28:53,190 --> 00:28:58,560
question and I wonder if you sort of

00:28:56,010 --> 00:29:00,270
have you had any feeling on how this

00:28:58,560 --> 00:29:03,980
performs sitting on top of the language

00:29:00,270 --> 00:29:07,350
that isn't inherently functional well

00:29:03,980 --> 00:29:09,930
well performance wise I've not had any

00:29:07,350 --> 00:29:11,460
complaints I guess so I've not looked

00:29:09,930 --> 00:29:13,140
into optimizing it I mean there is a

00:29:11,460 --> 00:29:15,240
there is a library called PI monads

00:29:13,140 --> 00:29:17,970
that's probably more optimized than my

00:29:15,240 --> 00:29:23,730
not invented here syndrome things that I

00:29:17,970 --> 00:29:26,310
keep doing but yeah what I do is I don't

00:29:23,730 --> 00:29:28,140
I don't do a lot of recursion like

00:29:26,310 --> 00:29:29,820
functional programming you think a lot

00:29:28,140 --> 00:29:31,890
in recursion but I don't do a lot of

00:29:29,820 --> 00:29:33,530
recursion so I don't run a lot into

00:29:31,890 --> 00:29:35,850
Stack Overflow issues and some of that

00:29:33,530 --> 00:29:42,720
cool and you're gonna put the slides up

00:29:35,850 --> 00:29:44,400
somewhere online oh yeah yeah questions

00:29:42,720 --> 00:29:48,480
we can still take another question if

00:29:44,400 --> 00:29:49,430
you need it quick question did I lose

00:29:48,480 --> 00:29:56,850
you guys somewhere

00:29:49,430 --> 00:29:58,230
check thank you so um the problem that I

00:29:56,850 --> 00:30:01,530
occasionally have with functional

00:29:58,230 --> 00:30:03,300
programming is that when you get to the

00:30:01,530 --> 00:30:05,670
highly abstract level of functions to

00:30:03,300 --> 00:30:08,280
make it sort of efficient and clean you

00:30:05,670 --> 00:30:09,870
lose the narrative that somebody you're

00:30:08,280 --> 00:30:11,910
talking to you about their problem they

00:30:09,870 --> 00:30:13,410
go so I want it to do this and then when

00:30:11,910 --> 00:30:14,760
they make this decision I wanted to do

00:30:13,410 --> 00:30:16,680
that and then I wanted to do and they

00:30:14,760 --> 00:30:17,970
tell you a story and then when you go

00:30:16,680 --> 00:30:19,830
okay now I'm going to think about this

00:30:17,970 --> 00:30:21,720
in the functional way most efficient

00:30:19,830 --> 00:30:22,710
ways you go so I'm taking something and

00:30:21,720 --> 00:30:26,250
something and it doesn't match that

00:30:22,710 --> 00:30:29,280
story do you have any ways of making

00:30:26,250 --> 00:30:30,540
that map easier for yourself yeah I've

00:30:29,280 --> 00:30:33,530
not actually talked about this in a

00:30:30,540 --> 00:30:36,960
functional way if I know

00:30:33,530 --> 00:30:39,420
so generally is the the thing is you can

00:30:36,960 --> 00:30:41,010
you can the idea is that you wrap things

00:30:39,420 --> 00:30:42,330
in a context and you talk about them in

00:30:41,010 --> 00:30:45,270
that context yeah

00:30:42,330 --> 00:30:47,010
so if you can design a sort of meta

00:30:45,270 --> 00:30:50,040
language like a DSL or something like

00:30:47,010 --> 00:30:52,650
that to describe the problem like a lot

00:30:50,040 --> 00:30:55,620
of people actually use more nets to

00:30:52,650 --> 00:30:57,210
create chains of functions so it's easy

00:30:55,620 --> 00:30:58,830
to read so you apply this and they apply

00:30:57,210 --> 00:31:01,700
this and you apply this two to one value

00:30:58,830 --> 00:31:04,980
so that's how I would think about

00:31:01,700 --> 00:31:09,759
following the user story I guess okay

00:31:04,980 --> 00:31:13,480
does that make sense to you cool right

00:31:09,759 --> 00:31:15,549
oh well Shuang Yi this time the PyCon

00:31:13,480 --> 00:31:19,330
committee decided to give you an Aztec

00:31:15,549 --> 00:31:21,190
blood mug and you can only use this it's

00:31:19,330 --> 00:31:22,749
a unique piece of ceramics here you're

00:31:21,190 --> 00:31:25,029
going to use this to drink green tea

00:31:22,749 --> 00:31:27,159
from it will explode if you put coffee

00:31:25,029 --> 00:31:30,360
in it thank you very much put your hands

00:31:27,159 --> 00:31:30,360
together which one you choose

00:31:37,799 --> 00:31:39,860

YouTube URL: https://www.youtube.com/watch?v=WNwV3wR4JjA


