Title: Not Invented Here: Porting Scientific Software to Python by Andrew Walker
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	Are you a scientist who's can't get work done because you the tools you need aren't available?  Do your collaborators use a different computing platform to you?  Are you struggling to find anyone who can help you solve your software integration problems?

These challenges occur because scientists face some of the most difficult challenges in computing  - dealing new and diverse problems;  working with prototypes and legacy systems; collaborating with domain experts, rather than software experts; all while delivering on time with minimal resources. 

Python has a reputation for being a language that excels at "glueing" different systems together in a style that is both easy to understand, test and maintain. More importantly using Python is one way to make sure that you spend your time working on research, rather than coding and debugging.

This presentation will demonstrate some of the skills needed to integrate software from other languages into the Python Scientific computing ecosystem using subprocesses, ctypes, cython the Jupyter project - and what do do when none of these approaches are the right.


PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:09,670 --> 00:00:14,459
so next up we have

00:00:12,360 --> 00:00:16,090
he's a melbourne-based software

00:00:14,459 --> 00:00:20,140
development a Rico

00:00:16,090 --> 00:00:21,910
demak and he's going to solve hopefully

00:00:20,140 --> 00:00:24,070
forever a problem that we all have and

00:00:21,910 --> 00:00:25,630
that's finding those little snippets of

00:00:24,070 --> 00:00:30,330
academic code online and actually

00:00:25,630 --> 00:00:30,330
getting them working alright good luck

00:00:45,890 --> 00:00:50,210
all right etude evening to how do I

00:00:48,559 --> 00:00:52,579
actually go about doing something like

00:00:50,210 --> 00:00:54,470
that I think it's worth talking about

00:00:52,579 --> 00:00:57,190
what makes light shipping software

00:00:54,470 --> 00:00:57,190
different

00:00:57,990 --> 00:01:07,240
thank you scientific software is

00:01:03,940 --> 00:01:08,770
absolutely different often that the

00:01:07,240 --> 00:01:11,080
tools that we're actually using a

00:01:08,770 --> 00:01:13,660
scientists are commercial or they're

00:01:11,080 --> 00:01:15,040
quite expensive and so as scientists

00:01:13,660 --> 00:01:17,020
that means we have some quite

00:01:15,040 --> 00:01:19,420
challenging integration problems to deal

00:01:17,020 --> 00:01:21,910
with how do you get those complex

00:01:19,420 --> 00:01:24,910
systems where you need them and how do

00:01:21,910 --> 00:01:27,400
you make them scale over the range of

00:01:24,910 --> 00:01:31,120
tasks that you need to solve so we we

00:01:27,400 --> 00:01:34,380
solve problems from how do I solve this

00:01:31,120 --> 00:01:38,890
one thing in my interactive notebook to

00:01:34,380 --> 00:01:40,930
I have a processor for my group how do I

00:01:38,890 --> 00:01:43,240
actually solve problems on there all the

00:01:40,930 --> 00:01:46,420
way up to massive distributed computing

00:01:43,240 --> 00:01:49,650
problems so one of the other big

00:01:46,420 --> 00:01:52,060
problems that Robert alluded to is about

00:01:49,650 --> 00:01:55,390
scientific software is definitely

00:01:52,060 --> 00:01:58,780
written by scientists for scientists and

00:01:55,390 --> 00:02:00,729
so the expectation is that you have some

00:01:58,780 --> 00:02:02,289
understanding of the domain that you're

00:02:00,729 --> 00:02:05,050
actually working in whether that's

00:02:02,289 --> 00:02:09,640
science or mathematics but the final

00:02:05,050 --> 00:02:10,840
part of this is that it's just hard so I

00:02:09,640 --> 00:02:12,790
want to talk a little bit about my

00:02:10,840 --> 00:02:15,340
research and what what inspired this

00:02:12,790 --> 00:02:17,830
talk and the disaster that that meant

00:02:15,340 --> 00:02:19,330
that I needed to come and do this so I

00:02:17,830 --> 00:02:22,090
finished two papers with some

00:02:19,330 --> 00:02:27,430
collaborators talking about conformal

00:02:22,090 --> 00:02:29,440
mapping so a conformal map is a function

00:02:27,430 --> 00:02:32,310
in the complex plane and you end up with

00:02:29,440 --> 00:02:36,760
things like this so you transforming

00:02:32,310 --> 00:02:38,890
domains from one class to another and

00:02:36,760 --> 00:02:41,650
you can do all kinds of impressive

00:02:38,890 --> 00:02:44,170
things as far as I know there are only

00:02:41,650 --> 00:02:46,090
two really well known packages for doing

00:02:44,170 --> 00:02:48,400
that and they're both written in MATLAB

00:02:46,090 --> 00:02:53,110
one of them's re-implementation or a

00:02:48,400 --> 00:02:55,959
future re-implementation so I thought

00:02:53,110 --> 00:02:58,060
okay I can't be too hard I'm a Python

00:02:55,959 --> 00:03:00,459
programmer I understand most of the

00:02:58,060 --> 00:03:02,230
maths that underlies some of this so

00:03:00,459 --> 00:03:04,090
I'll just go and rewrite from scratch

00:03:02,230 --> 00:03:05,830
you know obviously some of the best

00:03:04,090 --> 00:03:10,000
success stories in the Python community

00:03:05,830 --> 00:03:11,350
numpy matlab matplotlib and site pi have

00:03:10,000 --> 00:03:13,930
been about re-implementing

00:03:11,350 --> 00:03:17,470
things that existed elsewhere so i

00:03:13,930 --> 00:03:19,420
started my port and then after the first

00:03:17,470 --> 00:03:22,600
week in my spare time I'd kind of

00:03:19,420 --> 00:03:24,520
completed the basic object model inside

00:03:22,600 --> 00:03:27,610
the library and I'd written all my

00:03:24,520 --> 00:03:30,100
lovely tests then the second week I kind

00:03:27,610 --> 00:03:32,500
of ground to a bit of a halt and managed

00:03:30,100 --> 00:03:35,460
to finish porting five files when I had

00:03:32,500 --> 00:03:38,530
to do a deep dive into some of the

00:03:35,460 --> 00:03:42,460
spline code and sparse matrices and

00:03:38,530 --> 00:03:43,900
complex numbers the next week I finished

00:03:42,460 --> 00:03:45,730
one light this is this is an

00:03:43,900 --> 00:03:48,940
overestimation it was actually one

00:03:45,730 --> 00:03:50,650
character on one line so I had a

00:03:48,940 --> 00:03:53,470
conjugate transpose that I didn't

00:03:50,650 --> 00:03:55,090
realize what it actually was but this is

00:03:53,470 --> 00:03:57,520
one of the reasons why you don't want to

00:03:55,090 --> 00:04:01,300
have to do this from you from scratch

00:03:57,520 --> 00:04:03,220
every time so most software engineers

00:04:01,300 --> 00:04:06,910
know about this idea of not invented

00:04:03,220 --> 00:04:10,360
here syndrome so python is a great

00:04:06,910 --> 00:04:12,760
language to do everything but science

00:04:10,360 --> 00:04:16,510
but in particular but sometimes is a bit

00:04:12,760 --> 00:04:19,120
too easy to just assume that everything

00:04:16,510 --> 00:04:25,870
else that's out there doesn't fit your

00:04:19,120 --> 00:04:27,940
needs so what choices do you actually

00:04:25,870 --> 00:04:30,030
have at the moment for interoperating

00:04:27,940 --> 00:04:34,120
with software written in other languages

00:04:30,030 --> 00:04:36,550
we have things for interoperating with

00:04:34,120 --> 00:04:41,200
many languages we have tools for

00:04:36,550 --> 00:04:43,620
interacting with things on the fly we

00:04:41,200 --> 00:04:46,300
have tools for interacting with fortran

00:04:43,620 --> 00:04:51,160
we have more tools for interacting with

00:04:46,300 --> 00:04:54,690
c++ but for me the most frightening

00:04:51,160 --> 00:04:59,140
thing is how do i know where to start

00:04:54,690 --> 00:05:01,330
and my advice to you is to understand

00:04:59,140 --> 00:05:04,390
the basic themes that exist in these

00:05:01,330 --> 00:05:07,240
sorts of tools and to keep calm and Ryu

00:05:04,390 --> 00:05:10,240
stuff one of the things that we're

00:05:07,240 --> 00:05:12,550
taught is to stand on the shoulders of

00:05:10,240 --> 00:05:15,550
giants make use of the software that's

00:05:12,550 --> 00:05:19,450
out there already and leverage off the

00:05:15,550 --> 00:05:21,700
work that other people do so at the

00:05:19,450 --> 00:05:24,040
moment I see two two main reasons to

00:05:21,700 --> 00:05:27,010
learn about interoperability

00:05:24,040 --> 00:05:30,550
the first one has been graham mentioned

00:05:27,010 --> 00:05:32,830
earlier from Ed slides is about

00:05:30,550 --> 00:05:34,660
performance now this is definitely not a

00:05:32,830 --> 00:05:37,390
performance talk if you want to learn

00:05:34,660 --> 00:05:40,540
more about performance have a look for

00:05:37,390 --> 00:05:42,610
in oz melds talks online he's

00:05:40,540 --> 00:05:45,130
co-authored a new book high-performance

00:05:42,610 --> 00:05:47,980
Python you should definitely check this

00:05:45,130 --> 00:05:51,840
out I'm more interested in this case of

00:05:47,980 --> 00:05:55,150
necessity how do i integrate with

00:05:51,840 --> 00:05:57,730
packages written in other languages to

00:05:55,150 --> 00:06:00,280
make sure that I'm not the one who has

00:05:57,730 --> 00:06:07,440
to expend the effort or the money on

00:06:00,280 --> 00:06:10,540
maintenance and and quality so this is a

00:06:07,440 --> 00:06:12,550
recent quote or a paraphrase of Travis

00:06:10,540 --> 00:06:16,120
oil effect from podcast and it one of

00:06:12,550 --> 00:06:17,920
the new Python podcasts pythons strength

00:06:16,120 --> 00:06:19,870
is that it's like software super glue

00:06:17,920 --> 00:06:22,180
that lets you build abstractions like

00:06:19,870 --> 00:06:24,370
they're Lego and that's certainly where

00:06:22,180 --> 00:06:27,160
most of the wings in the Python

00:06:24,370 --> 00:06:29,500
scientific ecosystem have come from so

00:06:27,160 --> 00:06:31,090
you're you're pulling bits of if you

00:06:29,500 --> 00:06:33,730
don't have to dig deep into something

00:06:31,090 --> 00:06:36,820
like sci-fi to see some Fortran to see

00:06:33,730 --> 00:06:39,070
some see and to see some C++ and to see

00:06:36,820 --> 00:06:41,530
those things come together in one place

00:06:39,070 --> 00:06:46,030
and that's and that's where Python

00:06:41,530 --> 00:06:49,210
really shines so the second part of my

00:06:46,030 --> 00:06:50,710
talk is a whirlwind tour of some of the

00:06:49,210 --> 00:06:52,870
interoperability tools that are out

00:06:50,710 --> 00:06:55,450
there at the moment so I'm going to

00:06:52,870 --> 00:06:57,010
start with the simplest possible thing

00:06:55,450 --> 00:06:59,830
that might work and we're going to start

00:06:57,010 --> 00:07:01,540
in the Python standard library and we're

00:06:59,830 --> 00:07:06,250
going to gradually build up to more and

00:07:01,540 --> 00:07:09,640
more complex examples so who's used

00:07:06,250 --> 00:07:12,400
sub-process just a show of hands pretty

00:07:09,640 --> 00:07:15,070
much everybody that's exciting so

00:07:12,400 --> 00:07:17,560
sub-process has been in python sense

00:07:15,070 --> 00:07:20,950
version 2.4 and it's about

00:07:17,560 --> 00:07:23,110
interoperability via subprocesses so

00:07:20,950 --> 00:07:26,800
it's very convenient that my next

00:07:23,110 --> 00:07:30,460
example has been introduced in the last

00:07:26,800 --> 00:07:34,870
talked so you saw some tree diagrams

00:07:30,460 --> 00:07:35,990
from classifiers so this is a format

00:07:34,870 --> 00:07:40,370
called

00:07:35,990 --> 00:07:43,180
phys.org still represent a shin so that

00:07:40,370 --> 00:07:46,250
the classifiers that were talked about

00:07:43,180 --> 00:07:49,460
that we're producing that the feature

00:07:46,250 --> 00:07:51,830
trees will output to some text

00:07:49,460 --> 00:07:54,910
representation like this and I can run

00:07:51,830 --> 00:07:57,890
some tool to actually get a picture out

00:07:54,910 --> 00:08:02,360
so definitely talking about graph

00:07:57,890 --> 00:08:04,790
theoretic graphs here and if I want to

00:08:02,360 --> 00:08:08,270
actually invoke dot it has a

00:08:04,790 --> 00:08:10,790
command-line API and Python really

00:08:08,270 --> 00:08:14,690
shines at doing things like stuffing

00:08:10,790 --> 00:08:17,360
strings into command lines so I can

00:08:14,690 --> 00:08:21,130
actually use some string formatting

00:08:17,360 --> 00:08:23,270
tricks to actually populate the the

00:08:21,130 --> 00:08:27,320
arguments to my command line application

00:08:23,270 --> 00:08:29,480
and I can use my local environment to

00:08:27,320 --> 00:08:31,190
actually fill those out so this starts

00:08:29,480 --> 00:08:32,900
looking very similar to what you might

00:08:31,190 --> 00:08:36,220
write in bash if you are writing an

00:08:32,900 --> 00:08:39,590
equivalent bash script but even nicer

00:08:36,220 --> 00:08:42,830
the new check call that's in subprocess

00:08:39,590 --> 00:08:45,500
will actually ensure that if your sub

00:08:42,830 --> 00:08:47,390
process returns an error code so if it

00:08:45,500 --> 00:08:50,000
doesn't return 0 it'll convert it to a

00:08:47,390 --> 00:08:54,170
Python exception so this becomes very

00:08:50,000 --> 00:08:55,820
convenient code this is probably not the

00:08:54,170 --> 00:08:57,800
type of thing that you would want to use

00:08:55,820 --> 00:09:00,110
in production there are better tools out

00:08:57,800 --> 00:09:01,790
there for interacting with graph is but

00:09:00,110 --> 00:09:03,530
it certainly demonstrates what it's

00:09:01,790 --> 00:09:10,280
possible to do with those tools aren't

00:09:03,530 --> 00:09:11,660
available so subprocess is definitely

00:09:10,280 --> 00:09:13,340
the thing that you want to use if you're

00:09:11,660 --> 00:09:16,670
interacting with a tool has a

00:09:13,340 --> 00:09:18,650
command-line interface and performance

00:09:16,670 --> 00:09:20,960
is in an issue so most of the time when

00:09:18,650 --> 00:09:22,880
scientists actually spin up external

00:09:20,960 --> 00:09:26,780
processes they're starting long-running

00:09:22,880 --> 00:09:28,850
jobs if you're starting lots of small

00:09:26,780 --> 00:09:31,300
jobs you may actually want to look at

00:09:28,850 --> 00:09:31,300
other options

00:09:34,119 --> 00:09:40,239
ctypes is another Python standard

00:09:37,129 --> 00:09:43,459
library module but this one instead of

00:09:40,239 --> 00:09:50,989
interacting with whole applications will

00:09:43,459 --> 00:09:53,169
let you interact with libraries so in

00:09:50,989 --> 00:09:56,359
the research that I showed at the start

00:09:53,169 --> 00:09:57,619
you saw some conformal maps one of the

00:09:56,359 --> 00:10:03,499
things that you might want to do with

00:09:57,619 --> 00:10:05,569
conformal maps that has been a core part

00:10:03,499 --> 00:10:08,359
of the the solution of partial

00:10:05,569 --> 00:10:09,739
differential equations and so normally

00:10:08,359 --> 00:10:11,959
if you need to do that you would just

00:10:09,739 --> 00:10:14,239
import something like sideways special

00:10:11,959 --> 00:10:17,599
and the reason that we have sci-fi

00:10:14,239 --> 00:10:20,329
special is because at the time CyHi was

00:10:17,599 --> 00:10:21,919
written Lib C didn't actually include

00:10:20,329 --> 00:10:24,109
any functionality to call special

00:10:21,919 --> 00:10:26,119
functions so that's all changed now

00:10:24,109 --> 00:10:28,819
though sees actually improved and gotten

00:10:26,119 --> 00:10:33,439
a little bit better so now I can do

00:10:28,819 --> 00:10:36,649
things like load a library on my local

00:10:33,439 --> 00:10:38,899
system and I can get a handle back to

00:10:36,649 --> 00:10:41,539
that library and then I can start

00:10:38,899 --> 00:10:43,549
actually importing individual functions

00:10:41,539 --> 00:10:45,699
now there's some really interesting

00:10:43,549 --> 00:10:49,309
Python magic going on here it's actually

00:10:45,699 --> 00:10:51,529
looking up the attributes on the library

00:10:49,309 --> 00:10:54,429
handle and converting them back to

00:10:51,529 --> 00:10:57,439
python functions you can see it also

00:10:54,429 --> 00:11:00,139
converting argument types and and the

00:10:57,439 --> 00:11:03,649
types return types of the function so

00:11:00,139 --> 00:11:05,449
you see types will actually make some

00:11:03,649 --> 00:11:07,729
pretty intelligent guesses for you about

00:11:05,449 --> 00:11:09,559
what you're trying to do so once I've

00:11:07,729 --> 00:11:11,989
got those functions and specified the

00:11:09,559 --> 00:11:15,379
return types I can just call them like I

00:11:11,989 --> 00:11:17,539
would any other Python function so this

00:11:15,379 --> 00:11:21,379
this is really convenient if what you've

00:11:17,539 --> 00:11:24,350
got is a c library that you want to call

00:11:21,379 --> 00:11:26,899
out to and you don't want to know how

00:11:24,350 --> 00:11:28,339
the c code works or you don't have a see

00:11:26,899 --> 00:11:30,470
compiler on the system that you're

00:11:28,339 --> 00:11:36,619
working on which is potentially a case

00:11:30,470 --> 00:11:39,889
if you're involved in super computing so

00:11:36,619 --> 00:11:41,929
my rule of thumb is you see types if you

00:11:39,889 --> 00:11:43,309
only want one or two functions out of

00:11:41,929 --> 00:11:45,089
the library and you don't want to have

00:11:43,309 --> 00:11:47,320
to build your own wrapper

00:11:45,089 --> 00:11:52,990
even more so if you don't want to have

00:11:47,320 --> 00:11:56,380
to write some C code ctypes has a really

00:11:52,990 --> 00:11:58,450
big Warlow so there's a point that

00:11:56,380 --> 00:12:01,600
you'll get to with it where you just

00:11:58,450 --> 00:12:03,790
can't go any further so you'll you'll

00:12:01,600 --> 00:12:06,070
try and call a function that takes a

00:12:03,790 --> 00:12:09,700
struct of some kind or you want to

00:12:06,070 --> 00:12:13,510
return a pointer to some strange

00:12:09,700 --> 00:12:15,459
allocated string at that point if it's

00:12:13,510 --> 00:12:17,950
non-trivial arguments or non-trivial

00:12:15,459 --> 00:12:22,630
return types from your functions look at

00:12:17,950 --> 00:12:25,899
using one of these other options so it

00:12:22,630 --> 00:12:27,820
used to be that scifi included a really

00:12:25,899 --> 00:12:30,279
great tool for interoperability side

00:12:27,820 --> 00:12:32,019
play we've it's since been refactored

00:12:30,279 --> 00:12:35,470
out and is now library of its owns

00:12:32,019 --> 00:12:38,079
available on github and it lets you take

00:12:35,470 --> 00:12:42,519
a string of C++ code and make it

00:12:38,079 --> 00:12:44,890
callable from Python so I'm going to do

00:12:42,519 --> 00:12:46,209
that the simplest kind of science ii

00:12:44,890 --> 00:12:49,060
example that i could think of that

00:12:46,209 --> 00:12:54,570
demonstrates some of these ideas so i've

00:12:49,060 --> 00:13:00,279
imported CyHi we've I've built up a

00:12:54,570 --> 00:13:03,420
string of C++ code and I'm I'm calling

00:13:00,279 --> 00:13:07,779
in line and it will actually take a

00:13:03,420 --> 00:13:11,050
template of C++ code insert the code in

00:13:07,779 --> 00:13:13,360
my string into that file and then it

00:13:11,050 --> 00:13:16,149
will compile it into an extension module

00:13:13,360 --> 00:13:19,480
and it will import it into the local

00:13:16,149 --> 00:13:21,430
namespace and call that function so that

00:13:19,480 --> 00:13:24,520
the interesting things here though are

00:13:21,430 --> 00:13:27,760
that my argument to my function is

00:13:24,520 --> 00:13:34,240
actually being pushed out to the C++

00:13:27,760 --> 00:13:38,589
code so if you look if you look at at

00:13:34,240 --> 00:13:42,130
the there's some interesting bits here

00:13:38,589 --> 00:13:44,829
so this a 2 is actually my parameter and

00:13:42,130 --> 00:13:46,810
the 2 refers to slicing in two

00:13:44,829 --> 00:13:50,260
dimensions so there are some interesting

00:13:46,810 --> 00:13:53,260
little conversion semantics between

00:13:50,260 --> 00:13:56,480
Python and C++ so it's actually using

00:13:53,260 --> 00:13:58,670
the SC x.x library and you

00:13:56,480 --> 00:14:00,440
you can actually go and read all the

00:13:58,670 --> 00:14:03,500
code for that library it ships as part

00:14:00,440 --> 00:14:07,820
of scifi weave so one of the one of the

00:14:03,500 --> 00:14:10,940
limitations of approaches like this are

00:14:07,820 --> 00:14:14,660
that you're relying on somebody else's

00:14:10,940 --> 00:14:21,139
interoperability layer written in C++ to

00:14:14,660 --> 00:14:23,449
behave correctly with Python so here's

00:14:21,139 --> 00:14:29,089
another more extensive example of using

00:14:23,449 --> 00:14:32,000
syfy we've historically on a robotics

00:14:29,089 --> 00:14:36,290
person a motion planning person one of

00:14:32,000 --> 00:14:38,149
the problems that we solve is that it's

00:14:36,290 --> 00:14:41,060
called the piano movers problem how do

00:14:38,149 --> 00:14:42,860
you move a piano through a room and the

00:14:41,060 --> 00:14:45,350
trick to solving that problem is that

00:14:42,860 --> 00:14:47,740
you stop referring to the piano as a

00:14:45,350 --> 00:14:50,800
piano and you treat it as a point and

00:14:47,740 --> 00:14:55,690
what you do is you make the walls bigger

00:14:50,800 --> 00:14:59,269
and so this is effectively a geometric

00:14:55,690 --> 00:15:02,209
convolution so you're you're moving one

00:14:59,269 --> 00:15:07,459
geometry around the boundary to enlarge

00:15:02,209 --> 00:15:08,899
the size of the obstacles again to the

00:15:07,459 --> 00:15:11,720
best of my knowledge there are no

00:15:08,899 --> 00:15:15,050
libraries in Python for calculating in

00:15:11,720 --> 00:15:18,019
kowski sums but there's a really great

00:15:15,050 --> 00:15:20,360
C++ library called Siegel that actually

00:15:18,019 --> 00:15:22,839
has this functionality and so here's

00:15:20,360 --> 00:15:26,389
some C++ code that solves this problem

00:15:22,839 --> 00:15:32,500
you can start to see some newer C++

00:15:26,389 --> 00:15:35,680
features if you read C++ so auto and

00:15:32,500 --> 00:15:38,899
again there's some of these interesting

00:15:35,680 --> 00:15:41,120
conversions that are provided by SC x.x

00:15:38,899 --> 00:15:45,910
to make sure that the types that are

00:15:41,120 --> 00:15:45,910
being returned are actually Python types

00:15:47,709 --> 00:15:52,639
so how does that look when I actually go

00:15:50,329 --> 00:15:54,709
and put the whole thing together this is

00:15:52,639 --> 00:15:56,860
this is a far more realistic example of

00:15:54,709 --> 00:15:59,870
what you might do with this blood away

00:15:56,860 --> 00:16:01,910
there's the code that I had on the last

00:15:59,870 --> 00:16:05,600
slide I've got another little slip

00:16:01,910 --> 00:16:07,760
string of support code so if I want to

00:16:05,600 --> 00:16:08,710
call multiple functions from Siegel I

00:16:07,760 --> 00:16:11,980
can like

00:16:08,710 --> 00:16:13,990
share that code again I've got my my

00:16:11,980 --> 00:16:16,930
arguments that I'm passing in and out

00:16:13,990 --> 00:16:20,500
I've got the headers that I need for

00:16:16,930 --> 00:16:24,370
this in my libraries and unlike the the

00:16:20,500 --> 00:16:27,520
last example with seagull with ctypes

00:16:24,370 --> 00:16:30,370
sorry I've actually reef acted out all

00:16:27,520 --> 00:16:33,580
my platform dependent content into a

00:16:30,370 --> 00:16:35,860
function so again if you're if you're

00:16:33,580 --> 00:16:38,890
going to do interoperability work think

00:16:35,860 --> 00:16:47,500
about how you're going to use that code

00:16:38,890 --> 00:16:49,930
and share it amongst your colleagues so

00:16:47,500 --> 00:16:53,760
for me so I weave is the right tool to

00:16:49,930 --> 00:16:57,190
use if you're integrating fragments of

00:16:53,760 --> 00:16:59,380
C++ code so it's ideal if you found a

00:16:57,190 --> 00:17:02,080
library on the internet and you want to

00:16:59,380 --> 00:17:04,330
just copy the examples out and paste

00:17:02,080 --> 00:17:06,190
them into your ipython notebook run to

00:17:04,330 --> 00:17:09,940
your Python code because they already

00:17:06,190 --> 00:17:11,680
solved the problem that you want it

00:17:09,940 --> 00:17:16,720
works best if you're comfortable with

00:17:11,680 --> 00:17:19,000
C++ and again there are probably better

00:17:16,720 --> 00:17:22,870
solutions to some types of integration

00:17:19,000 --> 00:17:26,110
problems than then just using syfy weave

00:17:22,870 --> 00:17:32,140
so I try and focus on this if I'm

00:17:26,110 --> 00:17:35,350
prototyping the output that you actually

00:17:32,140 --> 00:17:37,990
get from the from the tool is quite

00:17:35,350 --> 00:17:41,500
dense you're actually compiling C++

00:17:37,990 --> 00:17:44,350
extension modules on the fly and so

00:17:41,500 --> 00:17:45,490
you'll have pages and pages of output

00:17:44,350 --> 00:17:49,840
that you have to deal with in your

00:17:45,490 --> 00:17:51,850
terminal the other challenge is that you

00:17:49,840 --> 00:17:54,790
don't want to redistribute syfy we've

00:17:51,850 --> 00:17:57,430
code one because you need a C++ compiler

00:17:54,790 --> 00:17:59,890
and two because every time you run the

00:17:57,430 --> 00:18:04,810
code you actually need to rebuild a new

00:17:59,890 --> 00:18:07,690
version of that extension module and and

00:18:04,810 --> 00:18:10,420
I would also say that perhaps avoid it

00:18:07,690 --> 00:18:12,670
if you're dealing with a lot of Python

00:18:10,420 --> 00:18:16,090
data structures so if you're using a lot

00:18:12,670 --> 00:18:18,100
of numpy it's not too bad but lists and

00:18:16,090 --> 00:18:20,340
tuples are a bit more challenging to

00:18:18,100 --> 00:18:20,340
wrap

00:18:20,890 --> 00:18:30,280
okay has anybody used siphon okay so a

00:18:25,180 --> 00:18:34,960
handful of people siphon is a DSL for

00:18:30,280 --> 00:18:40,080
integrating C C++ and Python so it's

00:18:34,960 --> 00:18:44,230
it's not Python and it's not c++ it's

00:18:40,080 --> 00:18:46,240
some kind of hybrid so here's another

00:18:44,230 --> 00:18:50,040
little example problem I want the

00:18:46,240 --> 00:18:53,590
distance from a point to a line segment

00:18:50,040 --> 00:18:56,050
so this is actually come up in more of

00:18:53,590 --> 00:18:59,080
our research we were trying to do some

00:18:56,050 --> 00:19:01,180
conformal mapping on some domains and we

00:18:59,080 --> 00:19:03,490
can write the code in numpy but it ends

00:19:01,180 --> 00:19:05,500
up being so ugly and so difficult to

00:19:03,490 --> 00:19:07,680
maintain that you really just want to

00:19:05,500 --> 00:19:14,410
write it how you want to read the code

00:19:07,680 --> 00:19:20,380
so I stole some snippets of code off the

00:19:14,410 --> 00:19:24,130
internet that had that structure in the

00:19:20,380 --> 00:19:29,260
original see but when you look at them

00:19:24,130 --> 00:19:31,750
in siphon you can see some of the

00:19:29,260 --> 00:19:35,890
commonalities with Python so I've got

00:19:31,750 --> 00:19:39,430
function definitions but I've got CDF's

00:19:35,890 --> 00:19:43,960
as well so I can expose functions to

00:19:39,430 --> 00:19:46,330
just the sea side of the to the sea part

00:19:43,960 --> 00:19:50,710
of the extension module I've got some

00:19:46,330 --> 00:19:53,860
type annotations so I can force the

00:19:50,710 --> 00:19:58,030
siphon compiler to only allow numpy

00:19:53,860 --> 00:20:02,170
arrays to be passed in I can still throw

00:19:58,030 --> 00:20:04,360
exceptions so when I when I ported my my

00:20:02,170 --> 00:20:10,120
C code actually had to return error

00:20:04,360 --> 00:20:14,110
codes slightly more convenient I can

00:20:10,120 --> 00:20:17,550
also add type annotations in line now

00:20:14,110 --> 00:20:20,170
this is very much suboptimal siphon code

00:20:17,550 --> 00:20:23,050
you can keep adding and adding type

00:20:20,170 --> 00:20:25,990
annotations and sly thing has an inbuilt

00:20:23,050 --> 00:20:29,800
profiler as well which is excellent for

00:20:25,990 --> 00:20:32,620
improving performance but for this in

00:20:29,800 --> 00:20:34,020
this case it was just enough to get the

00:20:32,620 --> 00:20:36,760
code

00:20:34,020 --> 00:20:39,760
the code running like this as a first

00:20:36,760 --> 00:20:43,930
pass the next step is that I can

00:20:39,760 --> 00:20:45,700
actually write tiny pieces of siphoned

00:20:43,930 --> 00:20:48,010
code that will actually directly import

00:20:45,700 --> 00:20:51,760
see header files and it knows how to

00:20:48,010 --> 00:20:56,100
translate those things into functions

00:20:51,760 --> 00:20:56,100
that are callable callable from Python

00:20:56,730 --> 00:21:02,620
so my suggestions are you siphon if

00:21:00,460 --> 00:21:04,810
you're exploring a solution space it

00:21:02,620 --> 00:21:07,270
provides the most seamless transition

00:21:04,810 --> 00:21:12,360
from prototype to something that you

00:21:07,270 --> 00:21:12,360
might chip on pi PI or on bin star

00:21:13,710 --> 00:21:18,580
seriously consider using using Python if

00:21:16,510 --> 00:21:23,040
you want to solve interoperability

00:21:18,580 --> 00:21:25,960
problems and you need to share your code

00:21:23,040 --> 00:21:31,660
again the profiling tools are excellent

00:21:25,960 --> 00:21:35,710
and my only my only issue we siphon is

00:21:31,660 --> 00:21:38,050
that it's not c++ and it's not Python it

00:21:35,710 --> 00:21:44,800
is its own language and it has some

00:21:38,050 --> 00:21:46,150
interesting corner cases so make sure

00:21:44,800 --> 00:21:49,900
that you've got enough time to actually

00:21:46,150 --> 00:21:52,120
learn it so this is a different kind of

00:21:49,900 --> 00:21:55,120
approach to interacting with software

00:21:52,120 --> 00:21:58,060
written in other languages a lot of what

00:21:55,120 --> 00:22:00,070
I do involves calling MATLAB from Python

00:21:58,060 --> 00:22:01,690
and so if I had have actually been

00:22:00,070 --> 00:22:03,550
thinking this is what I would have done

00:22:01,690 --> 00:22:07,450
from the very start I would have

00:22:03,550 --> 00:22:09,910
actually just called out to the matlab

00:22:07,450 --> 00:22:16,720
code that I needed to solve my problems

00:22:09,910 --> 00:22:18,490
for my research papers the problems that

00:22:16,720 --> 00:22:20,650
we're solving look very much like this

00:22:18,490 --> 00:22:23,500
they're like solving the steady state

00:22:20,650 --> 00:22:27,640
heat equation with conformal maps you

00:22:23,500 --> 00:22:30,010
define some boundary and then you tell

00:22:27,640 --> 00:22:31,330
the boundary conditions you tell us

00:22:30,010 --> 00:22:34,960
solve or what the boundary conditions

00:22:31,330 --> 00:22:38,410
are and it knows how to solve the heat

00:22:34,960 --> 00:22:40,180
equation in those domains now because

00:22:38,410 --> 00:22:44,260
there are such great tools in matlab for

00:22:40,180 --> 00:22:46,470
solving problems exactly like this in

00:22:44,260 --> 00:22:49,530
the in the ipython note

00:22:46,470 --> 00:22:51,690
look I can load I can load a magic and I

00:22:49,530 --> 00:22:55,409
can set my boundary conditions and then

00:22:51,690 --> 00:22:57,539
I can actually run a cell and that the

00:22:55,409 --> 00:23:00,870
code in that cell actually gets exported

00:22:57,539 --> 00:23:04,260
directly to matlab and it will run as is

00:23:00,870 --> 00:23:07,020
and so that's this this image is

00:23:04,260 --> 00:23:10,559
actually a plot that's come from MATLAB

00:23:07,020 --> 00:23:13,500
back to python so this is a very

00:23:10,559 --> 00:23:15,809
convenient way to get get access to

00:23:13,500 --> 00:23:18,990
other languages from Python there are

00:23:15,809 --> 00:23:22,049
equivalent tools for interacting with

00:23:18,990 --> 00:23:25,220
our and a number of other languages from

00:23:22,049 --> 00:23:25,220
the ipython notebook

00:23:31,570 --> 00:23:36,370
ok

00:23:34,119 --> 00:23:41,809
so

00:23:36,370 --> 00:23:44,240
my suggestion is to consider what

00:23:41,809 --> 00:23:46,190
options you have available to you when

00:23:44,240 --> 00:23:48,380
you go to interoperate with with code

00:23:46,190 --> 00:23:51,110
written in other languages can you run

00:23:48,380 --> 00:23:53,750
an external process can you call an

00:23:51,110 --> 00:23:55,880
existing library or do you actually have

00:23:53,750 --> 00:23:59,120
to write a Python extension module and

00:23:55,880 --> 00:24:06,320
if you do which tool is the right tool

00:23:59,120 --> 00:24:09,830
to help you do that when you do that

00:24:06,320 --> 00:24:12,559
make sure that you're considering who

00:24:09,830 --> 00:24:14,990
you're actually writing that code for so

00:24:12,559 --> 00:24:16,789
a lot of the time if I'm writing code

00:24:14,990 --> 00:24:18,980
that I'm the only person who's ever

00:24:16,789 --> 00:24:21,380
going to need it I effectively just want

00:24:18,980 --> 00:24:24,019
an I pipe in notebook I probably want to

00:24:21,380 --> 00:24:27,019
do something interactively if I need to

00:24:24,019 --> 00:24:29,539
put something on a group server or on a

00:24:27,019 --> 00:24:31,130
distributed computer I'm going to want

00:24:29,539 --> 00:24:33,500
something that's a bit more reliably

00:24:31,130 --> 00:24:37,360
distributable so I probably want some

00:24:33,500 --> 00:24:37,360
kind of package I could put on pipe I

00:24:39,279 --> 00:24:46,190
think about what dependencies are

00:24:41,510 --> 00:24:47,630
required so if you prefer sub-process

00:24:46,190 --> 00:24:50,539
all I needed was the Python standard

00:24:47,630 --> 00:24:53,929
library for ctypes I've got dependencies

00:24:50,539 --> 00:24:56,750
on the system libraries for psych way

00:24:53,929 --> 00:24:58,669
we've and for siphon I've got even more

00:24:56,750 --> 00:25:00,679
dependencies so how are you actually

00:24:58,669 --> 00:25:04,399
going to manage getting those

00:25:00,679 --> 00:25:06,649
dependencies to where you're working and

00:25:04,399 --> 00:25:09,710
all always think about how much it's

00:25:06,649 --> 00:25:15,320
going to cost you to write and maintain

00:25:09,710 --> 00:25:20,200
your software and again keep calm and

00:25:15,320 --> 00:25:20,200
Ryu stuff okay thanks

00:25:26,990 --> 00:25:32,659
alright thank you and any questions

00:25:41,070 --> 00:25:46,390
hi so you didn't mention cff I have you

00:25:44,590 --> 00:25:47,740
had any experience with that I mean it

00:25:46,390 --> 00:25:49,330
kind of similar to see types in a way

00:25:47,740 --> 00:25:51,330
you didn't know second pilot but yeah

00:25:49,330 --> 00:25:55,540
yeah just like to who you do you think

00:25:51,330 --> 00:25:57,850
cff is is an important project at the

00:25:55,540 --> 00:26:01,929
moment and it's really the only choice

00:25:57,850 --> 00:26:05,140
if you're interacting with C code from

00:26:01,929 --> 00:26:07,330
pi PI it's likely to be the de facto

00:26:05,140 --> 00:26:10,240
standard way of doing interoperability

00:26:07,330 --> 00:26:12,640
in the future but for scientists at the

00:26:10,240 --> 00:26:15,040
moment I don't know whether it would be

00:26:12,640 --> 00:26:18,520
my first choice you only have to dig

00:26:15,040 --> 00:26:20,770
into the setup I of cryptography which

00:26:18,520 --> 00:26:24,340
is probably the best-known packages

00:26:20,770 --> 00:26:27,300
using CF 4 Phi at the moment it's not

00:26:24,340 --> 00:26:29,920
it's not a task for the faint-hearted

00:26:27,300 --> 00:26:32,440
this there's probably a few days work

00:26:29,920 --> 00:26:35,440
just to get something that's installable

00:26:32,440 --> 00:26:38,170
going yeah there are there are also

00:26:35,440 --> 00:26:44,160
alternatives so back on that very first

00:26:38,170 --> 00:26:44,160
slide with the big list of options

00:26:45,720 --> 00:26:53,590
reflex and cpp why are extra tools that

00:26:51,580 --> 00:26:58,470
will actually let pipelay interoperate

00:26:53,590 --> 00:27:01,840
with C++ code so they're they're the

00:26:58,470 --> 00:27:06,450
future of the C++ interoperability from

00:27:01,840 --> 00:27:09,450
that standpoint any further questions

00:27:06,450 --> 00:27:09,450
yep

00:27:12,679 --> 00:27:19,230
Thanks I'm just wondering how easy you

00:27:15,750 --> 00:27:24,059
found to a port code from MATLAB to

00:27:19,230 --> 00:27:27,620
python and the other way around porting

00:27:24,059 --> 00:27:30,799
directly very time-consuming and tedious

00:27:27,620 --> 00:27:33,750
there are some extra tools out there

00:27:30,799 --> 00:27:35,520
there are there's some packages like

00:27:33,750 --> 00:27:38,840
smoke that will actually translate

00:27:35,520 --> 00:27:41,610
matlab code to python perhaps not the

00:27:38,840 --> 00:27:46,140
not the cleanest python that comes out

00:27:41,610 --> 00:27:49,620
of a tool like that my suggestion is if

00:27:46,140 --> 00:27:51,230
you can call matlab directly do that but

00:27:49,620 --> 00:27:53,640
it's a challenge from a licensed

00:27:51,230 --> 00:27:57,840
licensing standpoint i understand that

00:27:53,640 --> 00:27:59,880
but you have you have some choices you

00:27:57,840 --> 00:28:04,260
can either translate or you can call out

00:27:59,880 --> 00:28:07,620
to matlab I've got a question are there

00:28:04,260 --> 00:28:10,140
any significant gaps you feel in

00:28:07,620 --> 00:28:12,000
interoperability and any sort of

00:28:10,140 --> 00:28:14,490
features or libraries you like to see I

00:28:12,000 --> 00:28:18,299
really do think that python is is

00:28:14,490 --> 00:28:20,130
blessed in the amount of effort that's

00:28:18,299 --> 00:28:24,770
been invested in in solving

00:28:20,130 --> 00:28:27,059
interoperability problems I think if

00:28:24,770 --> 00:28:28,320
there was one thing that I think that

00:28:27,059 --> 00:28:31,440
we're missing it's a good set of

00:28:28,320 --> 00:28:33,750
examples about how to go and do that in

00:28:31,440 --> 00:28:36,150
a slightly easier way so it would be

00:28:33,750 --> 00:28:38,760
nice to have some simple demo projects

00:28:36,150 --> 00:28:41,669
that took you all the way through

00:28:38,760 --> 00:28:45,450
setting up sighs and poke projects in

00:28:41,669 --> 00:28:47,490
particular it goes from being quite easy

00:28:45,450 --> 00:28:50,340
in the ipython notebook to get something

00:28:47,490 --> 00:28:51,720
going to a little bit more tedious to

00:28:50,340 --> 00:28:54,330
get something that you actually want to

00:28:51,720 --> 00:28:56,760
publish on pi PI that's something I

00:28:54,330 --> 00:28:58,470
found to like getting the basics work is

00:28:56,760 --> 00:29:02,039
fine but then it ramps up quite quickly

00:28:58,470 --> 00:29:04,140
yeah but I must say it's much smoother

00:29:02,039 --> 00:29:06,770
doing something like that than it is in

00:29:04,140 --> 00:29:10,710
C types where you do tend to hit a wall

00:29:06,770 --> 00:29:13,010
great just two more questions then we'll

00:29:10,710 --> 00:29:13,010
do lunch

00:29:15,030 --> 00:29:20,830
Thanks really good talk so for that pie

00:29:18,460 --> 00:29:23,110
Matt bridge what's the performance

00:29:20,830 --> 00:29:25,360
overhead of calling into MATLAB so if

00:29:23,110 --> 00:29:26,710
you've got like a tight loop in Python

00:29:25,360 --> 00:29:29,260
calling into matlab's not going to work

00:29:26,710 --> 00:29:31,780
not going to work so you would want to

00:29:29,260 --> 00:29:37,060
call your matlab api's at the very

00:29:31,780 --> 00:29:40,390
highest level so my a very simple

00:29:37,060 --> 00:29:42,580
example only really works because I've

00:29:40,390 --> 00:29:48,670
got one function that's actually doing

00:29:42,580 --> 00:29:51,640
any work the rest is just plotting yeah

00:29:48,670 --> 00:29:53,080
circus another thing might be to in the

00:29:51,640 --> 00:29:55,060
other language right like a little

00:29:53,080 --> 00:29:56,560
network server or something that you can

00:29:55,060 --> 00:29:59,350
you know sort of ping it over a protocol

00:29:56,560 --> 00:30:00,790
and like kind of not integrate them and

00:29:59,350 --> 00:30:02,770
just do network and that and that's

00:30:00,790 --> 00:30:05,290
exactly how this is actually working at

00:30:02,770 --> 00:30:07,450
the moment it's opening up a PI Z mq

00:30:05,290 --> 00:30:09,730
connection and actually communicating

00:30:07,450 --> 00:30:11,650
backwards and forth over that channel so

00:30:09,730 --> 00:30:15,790
that there are connections i believe

00:30:11,650 --> 00:30:17,650
work the same way we're a little bit

00:30:15,790 --> 00:30:21,610
better for time than i thought so we'll

00:30:17,650 --> 00:30:23,440
do one more question i used to boost

00:30:21,610 --> 00:30:25,390
python up there yeah have you only with

00:30:23,440 --> 00:30:26,920
that my experience of actually using

00:30:25,390 --> 00:30:29,380
things that have been wrapped with that

00:30:26,920 --> 00:30:31,480
was that they were very easy to debug my

00:30:29,380 --> 00:30:32,770
use of it compares compared to the

00:30:31,480 --> 00:30:34,540
others but I've never actually built

00:30:32,770 --> 00:30:38,800
something with it so I wonder why your

00:30:34,540 --> 00:30:41,710
experience with as been i've used boost

00:30:38,800 --> 00:30:44,560
python a little bit perhaps not

00:30:41,710 --> 00:30:50,710
debugging as much into the c++ end of

00:30:44,560 --> 00:30:54,100
things there i haven't seen a huge

00:30:50,710 --> 00:30:56,950
number of big projects that there are

00:30:54,100 --> 00:31:02,220
seagull wrappers that are boost python

00:30:56,950 --> 00:31:02,220
wrappers and and sweet wrappers as well

00:31:05,610 --> 00:31:16,920
yeah we have much more time so any

00:31:11,610 --> 00:31:20,790
further question no okay well in that

00:31:16,920 --> 00:31:23,600
case we'll go get some food so once

00:31:20,790 --> 00:31:23,600
again thanks Andrew

00:31:30,010 --> 00:31:32,070

YouTube URL: https://www.youtube.com/watch?v=evhku1Lz8GE


