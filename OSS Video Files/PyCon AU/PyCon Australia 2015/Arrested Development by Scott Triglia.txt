Title: Arrested Development by Scott Triglia
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	The potential upside of microservices is significant and exciting. So much so that Yelp's Transaction Platform committed from the start to an architecture of small, cooperative microservices. This talk explores the inevitable complications that arise in successful projects based on microservices as they grow larger and stretch both their own architecture and the developers responsible for them. Come hear tales of terror (tight coupling! low test coverage!), stories which will warm your heart (agility! strong interfaces!), and everything in between as we follow the adventures of our plucky team.

The talk will be focused on the functional, cultural, and reliability challenges which occur as a microservices-based project evolves and expands over time. Particular attention will be paid to where these diverge from the utopian way microservices are often described, and to the practical approaches your project can take to mitigate issues and avoid the traps inherent in scaling up this type of approach. My goal is to share with attendees some mistakes we've made, some successful methods for growing gracefully, and above all with useful (and maybe unexpected!) lessons from the trenches they can apply to their own work.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,349 --> 00:00:15,849
alright welcome everyone so next up we

00:00:13,509 --> 00:00:17,560
have Scott Trillia his tech lead at Yelp

00:00:15,849 --> 00:00:24,699
and the talk is called arrested

00:00:17,560 --> 00:00:27,520
development please welcome him all right

00:00:24,699 --> 00:00:30,489
thank you all for coming out so I'm

00:00:27,520 --> 00:00:32,800
gonna be talking today about my team the

00:00:30,489 --> 00:00:36,219
product we build and sort of how we

00:00:32,800 --> 00:00:38,020
bought into the you know the excitement

00:00:36,219 --> 00:00:40,989
the promise and maybe a little bit of

00:00:38,020 --> 00:00:42,730
hype surrounding microservices so we're

00:00:40,989 --> 00:00:44,260
going to talk about lessons we learned

00:00:42,730 --> 00:00:47,079
in the first couple years of working

00:00:44,260 --> 00:00:49,000
with that and you know after the shiny

00:00:47,079 --> 00:00:50,290
coat of new paint wears off an idea what

00:00:49,000 --> 00:00:51,730
are you left with and how can you make

00:00:50,290 --> 00:00:55,180
sure you're building a robust

00:00:51,730 --> 00:00:57,640
application so I want to start out with

00:00:55,180 --> 00:00:59,800
a brief background on the company make

00:00:57,640 --> 00:01:02,590
sure we're all on the same page Yelp if

00:00:59,800 --> 00:01:04,180
you don't know is essentially a a nap or

00:01:02,590 --> 00:01:06,729
if you're feeling old fashioned a

00:01:04,180 --> 00:01:08,590
website for discovering local businesses

00:01:06,729 --> 00:01:10,600
near you so we're looking to make sure

00:01:08,590 --> 00:01:12,009
that you can find that great place to

00:01:10,600 --> 00:01:13,929
have lunch or that place to go shopping

00:01:12,009 --> 00:01:17,590
or somewhere to get your shoes repaired

00:01:13,929 --> 00:01:18,909
wherever you're at and we have a fair

00:01:17,590 --> 00:01:21,159
amount of content as well so we have

00:01:18,909 --> 00:01:24,159
about 80 million reviews on the same

00:01:21,159 --> 00:01:25,630
order of monthly unique users and a lot

00:01:24,159 --> 00:01:27,819
of diversity and the businesses we

00:01:25,630 --> 00:01:29,619
support so often people will associate

00:01:27,819 --> 00:01:31,569
Yelp with restaurants in particular and

00:01:29,619 --> 00:01:34,029
that is a very popular use case but we

00:01:31,569 --> 00:01:35,859
actually have more shopping businesses

00:01:34,029 --> 00:01:38,609
than restaurants and a very long tail of

00:01:35,859 --> 00:01:42,159
a variety of different categories a

00:01:38,609 --> 00:01:44,619
little bit about me as I said I'm Scott

00:01:42,159 --> 00:01:46,299
if you are inclined towards Twitter you

00:01:44,619 --> 00:01:48,609
can find me at Scott Trillia on there

00:01:46,299 --> 00:01:50,709
and I've been with Yelp for about four

00:01:48,609 --> 00:01:53,229
years working primarily in back-end

00:01:50,709 --> 00:01:54,969
systems a lot of time on the search team

00:01:53,229 --> 00:01:58,299
there and a little bit of machine

00:01:54,969 --> 00:02:00,579
learning in my spare time so I've worked

00:01:58,299 --> 00:02:01,990
a lot with our service stack a little

00:02:00,579 --> 00:02:06,069
bit of contributing towards it in quite

00:02:01,990 --> 00:02:07,840
a bit as as a user as a developer and I

00:02:06,069 --> 00:02:09,849
want to describe my team as well the

00:02:07,840 --> 00:02:12,790
product we build which is called Yelp

00:02:09,849 --> 00:02:14,739
transaction platform you may catch me

00:02:12,790 --> 00:02:17,830
referring to it as just platform this is

00:02:14,739 --> 00:02:19,570
the same thing and in short our goal is

00:02:17,830 --> 00:02:21,340
to make sure that when you're using Yelp

00:02:19,570 --> 00:02:21,800
when you're searching for maybe dinner

00:02:21,340 --> 00:02:24,530
and birds

00:02:21,800 --> 00:02:26,390
and you want to find some awesome

00:02:24,530 --> 00:02:28,220
businesses as much as possible we want

00:02:26,390 --> 00:02:31,010
you to actually be able to transact with

00:02:28,220 --> 00:02:32,510
those businesses on Yelp so if you're in

00:02:31,010 --> 00:02:34,910
San Francisco for instance and you

00:02:32,510 --> 00:02:37,400
search for delivery around dinner time

00:02:34,910 --> 00:02:40,640
you might see a variety of start order

00:02:37,400 --> 00:02:41,960
options within your results and if you

00:02:40,640 --> 00:02:44,480
click on one of those we want to take

00:02:41,960 --> 00:02:46,280
you into a for food a menu experience so

00:02:44,480 --> 00:02:47,540
if you click on nick's crispy tacos in

00:02:46,280 --> 00:02:49,250
this example you're going to hopefully

00:02:47,540 --> 00:02:51,980
see some crispy tacos that you can go

00:02:49,250 --> 00:02:54,110
ahead and purchase as I mentioned though

00:02:51,980 --> 00:02:55,730
we're not just restaurants so we also

00:02:54,110 --> 00:02:58,210
make available a variety of other

00:02:55,730 --> 00:03:01,370
verticals other types of products

00:02:58,210 --> 00:03:02,750
shopping for clothing or maybe booking a

00:03:01,370 --> 00:03:04,340
hotel room and we do these through a

00:03:02,750 --> 00:03:07,220
variety of external partners that we

00:03:04,340 --> 00:03:08,510
partner with and regardless of what it

00:03:07,220 --> 00:03:10,460
is that you're purchasing we're looking

00:03:08,510 --> 00:03:12,920
to bring that whole shopping experience

00:03:10,460 --> 00:03:15,860
to a conclusion on the same the same app

00:03:12,920 --> 00:03:17,540
or the same website so that's a little

00:03:15,860 --> 00:03:19,010
bit about my team and what we build I

00:03:17,540 --> 00:03:20,390
want to make sure that we're all on the

00:03:19,010 --> 00:03:23,060
same page as well though about the

00:03:20,390 --> 00:03:24,920
concept of microservices a quick show of

00:03:23,060 --> 00:03:26,900
hands who in this room is feels familiar

00:03:24,920 --> 00:03:29,540
with what a micro services or what the

00:03:26,900 --> 00:03:30,940
concept means pretty good okay so we'll

00:03:29,540 --> 00:03:34,550
move through this relatively quickly

00:03:30,940 --> 00:03:35,630
it's obviously a very popular term came

00:03:34,550 --> 00:03:38,959
up maybe in the last couple years

00:03:35,630 --> 00:03:40,670
prominently and i'm partial to martin

00:03:38,959 --> 00:03:42,140
Fowler's description not just because

00:03:40,670 --> 00:03:45,080
he's sort of one of the people that came

00:03:42,140 --> 00:03:46,790
up with this idea he describes it as so

00:03:45,080 --> 00:03:48,050
and i won't read it out loud to you but

00:03:46,790 --> 00:03:50,030
I want to just pick out a couple parts

00:03:48,050 --> 00:03:51,890
of it a couple points he makes he talks

00:03:50,030 --> 00:03:53,510
about microservices being a suite of

00:03:51,890 --> 00:03:55,160
small services so we're talking about

00:03:53,510 --> 00:03:57,709
more than one service more than one

00:03:55,160 --> 00:04:00,200
server and hopefully not letting them

00:03:57,709 --> 00:04:02,660
get too large he also focuses on them

00:04:00,200 --> 00:04:04,340
being in their own processes and using

00:04:02,660 --> 00:04:06,080
lightweight mechanisms to communicate so

00:04:04,340 --> 00:04:09,880
we're talking about isolated services

00:04:06,080 --> 00:04:12,860
not writing within a single web app and

00:04:09,880 --> 00:04:14,300
by contrast you'll often hear the term

00:04:12,860 --> 00:04:16,910
monolith brought up in these discussions

00:04:14,300 --> 00:04:18,470
and a monolith in short is essentially

00:04:16,910 --> 00:04:20,209
just the opposite end of the spectrum if

00:04:18,470 --> 00:04:22,160
microservices are a lot of small

00:04:20,209 --> 00:04:24,440
independent pieces talking together a

00:04:22,160 --> 00:04:27,500
monolith is one big web app doing all of

00:04:24,440 --> 00:04:29,060
it inside of itself think Django if you

00:04:27,500 --> 00:04:31,970
want an example of this and this is sort

00:04:29,060 --> 00:04:34,820
of the default mode you'll often hear

00:04:31,970 --> 00:04:35,370
people disparaging monoliths are talking

00:04:34,820 --> 00:04:37,020
talking

00:04:35,370 --> 00:04:39,389
there you know outdated and a poor

00:04:37,020 --> 00:04:40,830
design choice I want to be really clear

00:04:39,389 --> 00:04:42,510
although this is not the focus of my

00:04:40,830 --> 00:04:44,490
talk that that doesn't always the case

00:04:42,510 --> 00:04:46,139
when somebody tells you about their

00:04:44,490 --> 00:04:48,060
monolith or describes among with their

00:04:46,139 --> 00:04:50,610
building just ask how large it is ask

00:04:48,060 --> 00:04:53,520
get a sense of what your what scale

00:04:50,610 --> 00:04:55,320
you're talking about in yelps case we're

00:04:53,520 --> 00:04:58,050
talking millions of lines of python code

00:04:55,320 --> 00:04:59,610
for our monolith so when we say big we

00:04:58,050 --> 00:05:02,130
mean big right this isn't a single

00:04:59,610 --> 00:05:04,020
django app that I can you know right

00:05:02,130 --> 00:05:07,020
down in in five or six modules this is

00:05:04,020 --> 00:05:08,090
an enormous block of code we're dealing

00:05:07,020 --> 00:05:10,430
with hundreds of developers

00:05:08,090 --> 00:05:12,570
simultaneously developing on it and

00:05:10,430 --> 00:05:14,370
there are very good reasons at that

00:05:12,570 --> 00:05:16,410
scale to move away from the monolith if

00:05:14,370 --> 00:05:18,030
you're interested in how to decide

00:05:16,410 --> 00:05:19,740
whether you should or shouldn't stick

00:05:18,030 --> 00:05:20,910
with your monolith Martin Fowler also

00:05:19,740 --> 00:05:23,070
has a really good article called

00:05:20,910 --> 00:05:26,610
monolith first that kind of gets at that

00:05:23,070 --> 00:05:28,229
design choice but for us we decided this

00:05:26,610 --> 00:05:30,120
was no good and I want to just briefly

00:05:28,229 --> 00:05:32,490
justify that decision so you get a sense

00:05:30,120 --> 00:05:34,380
of where we're coming from first off our

00:05:32,490 --> 00:05:36,750
monolithic Python code really resisted

00:05:34,380 --> 00:05:38,970
decoupling aggressively resisted

00:05:36,750 --> 00:05:41,039
decoupling and I think this is something

00:05:38,970 --> 00:05:43,349
that it's hard to hard to emphasize how

00:05:41,039 --> 00:05:45,060
hard it was I'm sure you're thinking to

00:05:43,349 --> 00:05:47,400
yourself oh and now Scott I can think of

00:05:45,060 --> 00:05:48,870
at least five ways to D couple Python

00:05:47,400 --> 00:05:50,760
code bases right there's their soap

00:05:48,870 --> 00:05:53,880
interfaces there's a lot of different

00:05:50,760 --> 00:05:56,520
tools you can employ here maybe a ABC

00:05:53,880 --> 00:05:58,410
abstract base classes and we thought all

00:05:56,520 --> 00:06:00,300
those same things and we spent probably

00:05:58,410 --> 00:06:02,340
easily six months a lot of developer

00:06:00,300 --> 00:06:04,440
time saying we can do this we can split

00:06:02,340 --> 00:06:05,849
up our monolith successfully and we

00:06:04,440 --> 00:06:07,289
basically found that while it might

00:06:05,849 --> 00:06:09,990
technically be possible it was a

00:06:07,289 --> 00:06:12,330
terrible ROI for our developers in

00:06:09,990 --> 00:06:14,639
general so again 1.2 million lines of

00:06:12,330 --> 00:06:18,180
code hundreds of developers decoupling

00:06:14,639 --> 00:06:20,070
was really impractical in addition it

00:06:18,180 --> 00:06:22,560
had a bad habit of catering to the

00:06:20,070 --> 00:06:24,479
lowest common denominator so when you

00:06:22,560 --> 00:06:26,639
get in a code base this large and this

00:06:24,479 --> 00:06:29,400
old yelp had our know roughly a decade

00:06:26,639 --> 00:06:31,139
of development behind it you find that

00:06:29,400 --> 00:06:32,490
there were some choices that made sense

00:06:31,139 --> 00:06:34,110
at some point in the past that don't

00:06:32,490 --> 00:06:36,570
make sense anymore and getting away from

00:06:34,110 --> 00:06:38,699
those choices no matter how obvious the

00:06:36,570 --> 00:06:41,880
migration need is can be really really

00:06:38,699 --> 00:06:43,950
challenging we started before Python had

00:06:41,880 --> 00:06:46,590
stable web frameworks and so we wrote

00:06:43,950 --> 00:06:48,150
our own right and 10 years down the line

00:06:46,590 --> 00:06:48,550
no matter how much you might want to

00:06:48,150 --> 00:06:50,650
migrate

00:06:48,550 --> 00:06:53,680
it's a very expensive proposition to do

00:06:50,650 --> 00:06:56,410
so and finally and this was kind of the

00:06:53,680 --> 00:06:58,420
kicker for us monolithic code was just

00:06:56,410 --> 00:07:00,940
really slow to deploy when you have to

00:06:58,420 --> 00:07:03,010
push all of 1.2 million lines of code

00:07:00,940 --> 00:07:04,660
together anytime you change any part of

00:07:03,010 --> 00:07:06,910
it when you have to test the entirety of

00:07:04,660 --> 00:07:09,880
your repo anytime you change part of it

00:07:06,910 --> 00:07:11,590
turns out it's really a pain and your

00:07:09,880 --> 00:07:13,930
deployment process starts to suffer and

00:07:11,590 --> 00:07:15,700
we weren't interested in deploying more

00:07:13,930 --> 00:07:19,660
slowly so that left us with breaking up

00:07:15,700 --> 00:07:22,300
the monolith so we did so this is a

00:07:19,660 --> 00:07:24,250
highly sanitized graph of the total

00:07:22,300 --> 00:07:26,470
cumulative number of services over time

00:07:24,250 --> 00:07:27,970
right and you can see that basically

00:07:26,470 --> 00:07:30,070
from when we started this roughly when i

00:07:27,970 --> 00:07:32,470
joined yelped four years ago this

00:07:30,070 --> 00:07:34,630
started off pretty strongly and hasn't

00:07:32,470 --> 00:07:36,520
looked back since so this graph kind of

00:07:34,630 --> 00:07:38,560
represents the glory days of the

00:07:36,520 --> 00:07:39,970
monolith to services transition it

00:07:38,560 --> 00:07:41,500
doesn't get better than this this is the

00:07:39,970 --> 00:07:43,810
point where you're going to see those

00:07:41,500 --> 00:07:46,300
first well-defined services get split

00:07:43,810 --> 00:07:47,800
out you're going to see deployment time

00:07:46,300 --> 00:07:49,510
speed up you're going to see testing

00:07:47,800 --> 00:07:51,730
become easier all of a sudden you

00:07:49,510 --> 00:07:53,560
actually have interfaces between code in

00:07:51,730 --> 00:07:55,750
the form of your ap is and this is

00:07:53,560 --> 00:07:59,680
really a glorious period of time kind of

00:07:55,750 --> 00:08:00,760
a honeymoon period but this is you know

00:07:59,680 --> 00:08:02,260
something that you're mostly going to

00:08:00,760 --> 00:08:04,180
hear about when you hear people

00:08:02,260 --> 00:08:05,590
discussing microservices this is the

00:08:04,180 --> 00:08:09,190
nice story right this is the ideal

00:08:05,590 --> 00:08:10,930
situation the happy path and you might

00:08:09,190 --> 00:08:12,490
know that this is not what my talk today

00:08:10,930 --> 00:08:14,530
is about right i'm not here to tell you

00:08:12,490 --> 00:08:15,760
how awesome micro services are i'm here

00:08:14,530 --> 00:08:17,500
to tell you what happens after you've

00:08:15,760 --> 00:08:19,840
bought into this and you do it for a

00:08:17,500 --> 00:08:22,390
couple years and a funny thing happened

00:08:19,840 --> 00:08:24,220
because when we started out initially we

00:08:22,390 --> 00:08:26,590
had this really idealized view of micro

00:08:24,220 --> 00:08:27,850
services and idealized view of what how

00:08:26,590 --> 00:08:29,590
good it was going to be as we got away

00:08:27,850 --> 00:08:31,330
from the monolith and for the most part

00:08:29,590 --> 00:08:33,580
we saw that borne out particularly in

00:08:31,330 --> 00:08:35,530
the first year it was awesome we got

00:08:33,580 --> 00:08:37,120
faster deploy as we got isolated systems

00:08:35,530 --> 00:08:38,950
and basically it was what we were told

00:08:37,120 --> 00:08:41,050
and we felt like we had a good picture

00:08:38,950 --> 00:08:43,570
in our heads and what we had created

00:08:41,050 --> 00:08:45,670
matched that exactly but a funny thing

00:08:43,570 --> 00:08:47,320
kind of happened maybe a couple years in

00:08:45,670 --> 00:08:48,700
is we look back we look back at that

00:08:47,320 --> 00:08:50,530
picture we had in our heads and what we

00:08:48,700 --> 00:08:52,720
thought we were getting out of it and we

00:08:50,530 --> 00:08:54,220
realized that what we'd actually built

00:08:52,720 --> 00:08:55,900
what came out and what we were looking

00:08:54,220 --> 00:08:58,330
at two years in after we had scaled up

00:08:55,900 --> 00:09:01,480
it wasn't wasn't quite what we had in

00:08:58,330 --> 00:09:02,320
mind right it had a lot of similarities

00:09:01,480 --> 00:09:04,240
you could in fact

00:09:02,320 --> 00:09:05,890
trace it back and see where in some

00:09:04,240 --> 00:09:07,870
parts we were still getting benefits but

00:09:05,890 --> 00:09:09,340
the architecture wasn't there wasn't

00:09:07,870 --> 00:09:11,530
feeling stable and we weren't feeling

00:09:09,340 --> 00:09:14,740
feeling like we could really get all the

00:09:11,530 --> 00:09:16,270
benefits we had been promised so what

00:09:14,740 --> 00:09:17,740
are a couple of reasons for that right

00:09:16,270 --> 00:09:20,620
what were we seeing that was hurting us

00:09:17,740 --> 00:09:23,590
so much first off our API complexity

00:09:20,620 --> 00:09:25,360
increased significantly due to organic

00:09:23,590 --> 00:09:27,850
growth due to things like needing to

00:09:25,360 --> 00:09:29,440
version our API when you start out you

00:09:27,850 --> 00:09:31,420
have a pretty good image in your head

00:09:29,440 --> 00:09:33,790
hopefully of what your service is going

00:09:31,420 --> 00:09:36,040
to do and what purpose it serves and as

00:09:33,790 --> 00:09:38,140
you grow over time that image kind of

00:09:36,040 --> 00:09:39,580
gets a little fuzzier may be right you

00:09:38,140 --> 00:09:41,650
end up patching in some last-minute

00:09:39,580 --> 00:09:44,140
fixes because a product has to go out or

00:09:41,650 --> 00:09:46,060
you end up changing maybe a year into

00:09:44,140 --> 00:09:48,370
your service what the purpose the core

00:09:46,060 --> 00:09:50,110
purpose of the service is and as a

00:09:48,370 --> 00:09:52,240
result the API complexity just gross

00:09:50,110 --> 00:09:53,380
it's it's sort of inescapable and that

00:09:52,240 --> 00:09:57,190
makes a lot of other things a lot more

00:09:53,380 --> 00:10:00,100
difficult we saw our interactions really

00:09:57,190 --> 00:10:01,810
get very murky knowing what happened

00:10:00,100 --> 00:10:03,280
when I called in to a service used to be

00:10:01,810 --> 00:10:05,230
really simple right the service did one

00:10:03,280 --> 00:10:06,910
thing and it did it well and we found

00:10:05,230 --> 00:10:08,680
that after a while as the services got

00:10:06,910 --> 00:10:10,510
more complicated knowing what was going

00:10:08,680 --> 00:10:12,490
to occur when I called a service when I

00:10:10,510 --> 00:10:14,440
posted to an end point became

00:10:12,490 --> 00:10:16,030
correspondingly more difficult and when

00:10:14,440 --> 00:10:18,220
you have your application as a network

00:10:16,030 --> 00:10:20,560
of the service calls all interacting

00:10:18,220 --> 00:10:22,240
together knowing what's actually going

00:10:20,560 --> 00:10:25,570
to happen is is really important and

00:10:22,240 --> 00:10:27,520
very difficult and finally the process

00:10:25,570 --> 00:10:29,440
just wasn't scaling we were hoping that

00:10:27,520 --> 00:10:31,000
we were going to find faster deployment

00:10:29,440 --> 00:10:32,530
that we were going to have new

00:10:31,000 --> 00:10:34,090
developers be able to ramp up very

00:10:32,530 --> 00:10:36,580
quickly on a project because it was all

00:10:34,090 --> 00:10:39,010
these well conceived services and we

00:10:36,580 --> 00:10:41,320
found that after we kept scaling up on

00:10:39,010 --> 00:10:42,760
this process for a couple years none of

00:10:41,320 --> 00:10:45,850
those things were holding true as much

00:10:42,760 --> 00:10:47,830
as we would like so what can we do about

00:10:45,850 --> 00:10:49,600
this right we're left in this spot we've

00:10:47,830 --> 00:10:51,310
bought into microservices a couple years

00:10:49,600 --> 00:10:52,840
ago and we're finding that a lot of the

00:10:51,310 --> 00:10:54,430
benefits have actually gone away this

00:10:52,840 --> 00:10:58,300
thing isn't scaling as well as we were

00:10:54,430 --> 00:11:00,400
told how can we attack these problems so

00:10:58,300 --> 00:11:02,590
today I'm going to just talk about two

00:11:00,400 --> 00:11:04,990
main areas mostly in the interest of

00:11:02,590 --> 00:11:07,180
time there's a whole suite of things

00:11:04,990 --> 00:11:09,490
that could be discussed here but I find

00:11:07,180 --> 00:11:10,510
these to be very important and so we're

00:11:09,490 --> 00:11:12,250
going to dive into them a little bit

00:11:10,510 --> 00:11:12,660
explain what we saw that was going wrong

00:11:12,250 --> 00:11:15,180
in

00:11:12,660 --> 00:11:16,139
we can fix it and the first one of those

00:11:15,180 --> 00:11:18,269
that I'd like to talk about is

00:11:16,139 --> 00:11:20,250
essentially defining these services

00:11:18,269 --> 00:11:22,560
keeping a consistent definition of what

00:11:20,250 --> 00:11:25,230
a service is and what it does and how we

00:11:22,560 --> 00:11:28,620
can continue doing that as we grow a

00:11:25,230 --> 00:11:29,759
larger and larger application and the

00:11:28,620 --> 00:11:31,800
first point that I'd like to make here

00:11:29,759 --> 00:11:35,069
is coming from our Python monolith

00:11:31,800 --> 00:11:38,730
strong interfaces were really rare right

00:11:35,069 --> 00:11:41,370
and this is sort of arguably a Python

00:11:38,730 --> 00:11:43,620
feature problem is that it's very

00:11:41,370 --> 00:11:45,509
difficult for us to maintain in a large

00:11:43,620 --> 00:11:47,610
code base interfaces that are well

00:11:45,509 --> 00:11:50,850
defined we actually know what they claim

00:11:47,610 --> 00:11:52,500
to do and that are our following that

00:11:50,850 --> 00:11:53,670
interface that not only do they claim to

00:11:52,500 --> 00:11:55,620
do something but they really do

00:11:53,670 --> 00:11:57,829
something both the definition of an

00:11:55,620 --> 00:12:00,360
interface and the validation of it and

00:11:57,829 --> 00:12:02,579
you might be familiar with code like

00:12:00,360 --> 00:12:04,050
this are arguably this is actually kind

00:12:02,579 --> 00:12:06,870
of nice code right it's a fairly major

00:12:04,050 --> 00:12:08,610
interface in our system we're going

00:12:06,870 --> 00:12:10,350
ahead and taking a user's order that

00:12:08,610 --> 00:12:11,910
they've created and we want to charge

00:12:10,350 --> 00:12:14,250
their credit card and maybe tell them

00:12:11,910 --> 00:12:16,589
about it after the fact so this is not

00:12:14,250 --> 00:12:18,149
something we want to get wrong and we

00:12:16,589 --> 00:12:20,040
often see code like this in a monolith

00:12:18,149 --> 00:12:22,350
right it's very nice it's pythonic you

00:12:20,040 --> 00:12:24,959
see a snake case you see a little usage

00:12:22,350 --> 00:12:26,579
of language features like kwargs but if

00:12:24,959 --> 00:12:28,290
we dig into a little bit we can discover

00:12:26,579 --> 00:12:29,730
that it's not actually an awesome

00:12:28,290 --> 00:12:32,189
interface for us to understand what's

00:12:29,730 --> 00:12:34,769
going on these arguments into the

00:12:32,189 --> 00:12:36,689
function have nice names I can guess

00:12:34,769 --> 00:12:38,730
what they do but as far as what they

00:12:36,689 --> 00:12:41,069
actually are Python doesn't really give

00:12:38,730 --> 00:12:43,800
me any any hints and in fact it allows

00:12:41,069 --> 00:12:45,209
me to be very lazy if I so desire so

00:12:43,800 --> 00:12:47,490
what is an order that's a fairly

00:12:45,209 --> 00:12:49,829
important concept I certainly can't tell

00:12:47,490 --> 00:12:51,689
it by reading this function what are

00:12:49,829 --> 00:12:53,699
those carbs well somebody decide to use

00:12:51,689 --> 00:12:55,410
a nice language feature to pack up a

00:12:53,699 --> 00:12:57,269
bunch of keyword arguments but again

00:12:55,410 --> 00:12:59,009
just looking at it I have no idea what

00:12:57,269 --> 00:13:02,550
those are do I need to send any are they

00:12:59,009 --> 00:13:03,720
entirely optional tough to say and this

00:13:02,550 --> 00:13:05,579
validation that we're doing down here

00:13:03,720 --> 00:13:08,220
what can we really say about what is or

00:13:05,579 --> 00:13:10,559
is not happening there hopefully it's

00:13:08,220 --> 00:13:12,209
doing what it claims what if it's put in

00:13:10,559 --> 00:13:13,529
there sort of optimistically by a

00:13:12,209 --> 00:13:16,379
developer and it actually just has a

00:13:13,529 --> 00:13:18,259
pass inside the function it's very very

00:13:16,379 --> 00:13:20,550
tough to make strong guarantees right

00:13:18,259 --> 00:13:21,809
and I won't say that we had anything

00:13:20,550 --> 00:13:23,490
quite that bad but i will say that

00:13:21,809 --> 00:13:25,270
partially validating things is a

00:13:23,490 --> 00:13:28,810
terrifying terrifying

00:13:25,270 --> 00:13:30,880
all so we tackle all these problems in

00:13:28,810 --> 00:13:33,730
the system in the context of micro

00:13:30,880 --> 00:13:34,990
services with a tool called swagger you

00:13:33,730 --> 00:13:36,910
might have heard earlier yesterday

00:13:34,990 --> 00:13:38,410
Andrew Stuart talking a little bit about

00:13:36,910 --> 00:13:41,560
using it with the Falcon web framework

00:13:38,410 --> 00:13:43,090
and for us we use it within our own

00:13:41,560 --> 00:13:45,670
system and we use it for three main

00:13:43,090 --> 00:13:47,920
purposes we want to first really

00:13:45,670 --> 00:13:49,870
document services this is for developers

00:13:47,920 --> 00:13:51,400
make sure we know what a service does

00:13:49,870 --> 00:13:53,440
make sure we know how you interface with

00:13:51,400 --> 00:13:55,960
it and why you would ever call that

00:13:53,440 --> 00:13:58,030
particular endpoint we also want to make

00:13:55,960 --> 00:14:00,370
clients smarter programmatically so

00:13:58,030 --> 00:14:02,380
we're looking to take as much of the

00:14:00,370 --> 00:14:05,670
busy work and the sort of mechanical

00:14:02,380 --> 00:14:08,320
nonsense of writing an HTTP call and

00:14:05,670 --> 00:14:09,880
automated a way where possible and we

00:14:08,320 --> 00:14:11,260
also want to make our servers smarter so

00:14:09,880 --> 00:14:13,360
anything that we can do on the server

00:14:11,260 --> 00:14:15,130
that will be benefited by having a

00:14:13,360 --> 00:14:17,860
strongly defined API we're looking to

00:14:15,130 --> 00:14:19,510
get better about that so let's look at

00:14:17,860 --> 00:14:21,430
what this actually means if I'm a

00:14:19,510 --> 00:14:23,710
developer and I want to use swagger what

00:14:21,430 --> 00:14:25,270
do I have to do well the good news and

00:14:23,710 --> 00:14:26,740
and maybe the bad news is you only have

00:14:25,270 --> 00:14:29,260
to do one thing but that one thing is

00:14:26,740 --> 00:14:31,300
fairly tricky surprisingly tricky in

00:14:29,260 --> 00:14:33,520
essence you have to write down a formal

00:14:31,300 --> 00:14:35,860
spec for your entire API for your

00:14:33,520 --> 00:14:36,940
service and when I say formals back I

00:14:35,860 --> 00:14:38,710
really mean it you're gonna have to go

00:14:36,940 --> 00:14:40,000
through and for every endpoint you're

00:14:38,710 --> 00:14:41,500
going to need to define all the

00:14:40,000 --> 00:14:42,880
different parameters that come in to

00:14:41,500 --> 00:14:44,230
that end point you're going to need to

00:14:42,880 --> 00:14:45,670
write down their types you're going to

00:14:44,230 --> 00:14:48,340
need to write down are they optional or

00:14:45,670 --> 00:14:51,400
not and you need to iterate this process

00:14:48,340 --> 00:14:53,380
through your entire service this might

00:14:51,400 --> 00:14:55,660
not sound awful you know theoretically

00:14:53,380 --> 00:14:57,550
we all know our services we know our API

00:14:55,660 --> 00:15:00,490
is but I can tell you in practice it's

00:14:57,550 --> 00:15:03,070
astonishingly painful you can take your

00:15:00,490 --> 00:15:04,390
best developer you can you know sit her

00:15:03,070 --> 00:15:06,250
down and say please write this entire

00:15:04,390 --> 00:15:07,750
spec and you kind of cross your fingers

00:15:06,250 --> 00:15:09,880
and hope it'll go quickly it doesn't

00:15:07,750 --> 00:15:12,580
it's painful and odds are you don't know

00:15:09,880 --> 00:15:14,380
your own API on the upside this is a

00:15:12,580 --> 00:15:16,000
very good kind of pain because you don't

00:15:14,380 --> 00:15:18,490
know the API you're working with and

00:15:16,000 --> 00:15:20,620
this should be setting off red flags in

00:15:18,490 --> 00:15:22,810
your head that if you don't know

00:15:20,620 --> 00:15:25,000
something so important you can't hope to

00:15:22,810 --> 00:15:27,340
make smart decisions to make automation

00:15:25,000 --> 00:15:30,400
based on it so the only thing developers

00:15:27,340 --> 00:15:32,320
have to do is write the spec as a result

00:15:30,400 --> 00:15:35,200
they get a few benefits I talked about

00:15:32,320 --> 00:15:37,000
documentation so swagger has a pretty

00:15:35,200 --> 00:15:38,410
rich ecosystem of tooling and one of the

00:15:37,000 --> 00:15:38,600
cool things that offers is something

00:15:38,410 --> 00:15:41,000
call

00:15:38,600 --> 00:15:43,279
swagger you I so this is essentially an

00:15:41,000 --> 00:15:44,870
interactive browser for your system you

00:15:43,279 --> 00:15:47,120
write that spec and it will be reflected

00:15:44,870 --> 00:15:49,550
here so you can see here an example from

00:15:47,120 --> 00:15:50,690
there sort of default example spec and

00:15:49,550 --> 00:15:52,639
you'll get to see all the different

00:15:50,690 --> 00:15:54,889
resources you'll get to see the gets and

00:15:52,639 --> 00:15:56,839
the posts maybe the deletes if you have

00:15:54,889 --> 00:15:58,880
any docstrings effectively summary

00:15:56,839 --> 00:16:00,589
information about the end point you can

00:15:58,880 --> 00:16:03,019
see it there and you can actually do

00:16:00,589 --> 00:16:05,149
some nice interactive queries of the

00:16:03,019 --> 00:16:06,769
backing service so this is sort of the I

00:16:05,149 --> 00:16:08,500
want to learn about a service I want to

00:16:06,769 --> 00:16:10,970
know what a particular endpoint does

00:16:08,500 --> 00:16:12,740
documentation solution and you get this

00:16:10,970 --> 00:16:16,220
for free once you write that speck on

00:16:12,740 --> 00:16:17,660
the client side we're interested in

00:16:16,220 --> 00:16:21,139
again automating as much of the

00:16:17,660 --> 00:16:22,790
mechanics as we can so yelp has an open

00:16:21,139 --> 00:16:25,519
source library called bravado on our

00:16:22,790 --> 00:16:28,250
github and bravados goal is to go ahead

00:16:25,519 --> 00:16:29,810
and basically take down that swagger

00:16:28,250 --> 00:16:32,029
spec from a service that is looking to

00:16:29,810 --> 00:16:35,509
talk to learn about the interface it's

00:16:32,029 --> 00:16:37,399
attempting to call into and do as much

00:16:35,509 --> 00:16:39,740
of the automation in the mechanics as we

00:16:37,399 --> 00:16:41,360
can for you so first it offers an

00:16:39,740 --> 00:16:43,550
auto-generated client you can do things

00:16:41,360 --> 00:16:45,050
like client dot pet for the pet resource

00:16:43,550 --> 00:16:46,779
and it learns about that when it pulls

00:16:45,050 --> 00:16:49,699
down that spec from the remote service

00:16:46,779 --> 00:16:53,000
it does local validation so you if you

00:16:49,699 --> 00:16:54,800
are horribly miss miss calling a

00:16:53,000 --> 00:16:57,110
particular function like maybe we send a

00:16:54,800 --> 00:16:58,850
pet ID of fubar then it will yell at you

00:16:57,110 --> 00:17:01,730
before it makes a network call kind of a

00:16:58,850 --> 00:17:03,709
nice feature and it also pulls in things

00:17:01,730 --> 00:17:05,750
like help from the swagger schema you

00:17:03,709 --> 00:17:07,850
basically get as much as you can from

00:17:05,750 --> 00:17:10,549
that spec and you automatically

00:17:07,850 --> 00:17:12,079
integrate it into the client one thing

00:17:10,549 --> 00:17:13,730
it doesn't do is it doesn't attempt to

00:17:12,079 --> 00:17:16,850
paper over the fact that you're doing an

00:17:13,730 --> 00:17:18,169
HTTP call we sort of made some early

00:17:16,850 --> 00:17:20,089
attempts in this direction and we

00:17:18,169 --> 00:17:21,470
discovered that all of the convenience

00:17:20,089 --> 00:17:23,600
of pretending you weren't going over a

00:17:21,470 --> 00:17:25,610
network was really a timebomb in

00:17:23,600 --> 00:17:27,169
practice and you're much better off just

00:17:25,610 --> 00:17:29,780
admitting to the fact that you're making

00:17:27,169 --> 00:17:31,070
an HTTP call and letting bravado do a

00:17:29,780 --> 00:17:35,210
lot of the mechanics for you like

00:17:31,070 --> 00:17:36,890
constructing the right you are I on the

00:17:35,210 --> 00:17:38,480
server side we also have a solution so I

00:17:36,890 --> 00:17:39,830
have a library called pyramid swagger

00:17:38,480 --> 00:17:41,539
that hooks into the pyramid web

00:17:39,830 --> 00:17:43,039
framework in particular there are other

00:17:41,539 --> 00:17:45,169
options if you prefer something like

00:17:43,039 --> 00:17:47,179
flask and essentially we're doing the

00:17:45,169 --> 00:17:49,820
same process we want to say I have a

00:17:47,179 --> 00:17:51,530
spec for my service please hook it in in

00:17:49,820 --> 00:17:52,790
this case it's very simple you just put

00:17:51,530 --> 00:17:55,130
it in a predefined place

00:17:52,790 --> 00:17:56,720
include the library and then what you're

00:17:55,130 --> 00:17:58,310
going to get out is all of the benefit

00:17:56,720 --> 00:18:00,080
of doing that so this is built in

00:17:58,310 --> 00:18:01,460
serving of the spec so clients can go

00:18:00,080 --> 00:18:03,770
ahead and ask you for your whole swagger

00:18:01,460 --> 00:18:05,540
spec this is going to be request and

00:18:03,770 --> 00:18:07,250
response validation so you can go ahead

00:18:05,540 --> 00:18:09,380
and automatically make sure your service

00:18:07,250 --> 00:18:11,660
is actually adhering to that spec that

00:18:09,380 --> 00:18:13,370
you set out and a variety of other

00:18:11,660 --> 00:18:15,500
goodies so essentially we're just trying

00:18:13,370 --> 00:18:17,630
to again reduce the opportunity for

00:18:15,500 --> 00:18:21,200
mistakes and lighten the load for making

00:18:17,630 --> 00:18:22,490
new services and new endpoints okay so

00:18:21,200 --> 00:18:24,590
what can we draw as lessons from all

00:18:22,490 --> 00:18:26,330
this discussion first off your

00:18:24,590 --> 00:18:29,030
interfaces in services really need to be

00:18:26,330 --> 00:18:31,280
intentional it's not enough to go ahead

00:18:29,030 --> 00:18:32,530
and write a service one time you have to

00:18:31,280 --> 00:18:35,630
keep making sure that it stays

00:18:32,530 --> 00:18:37,130
consistent and coherent and means

00:18:35,630 --> 00:18:38,990
something and this is something that's

00:18:37,130 --> 00:18:40,730
very easy when you first design these

00:18:38,990 --> 00:18:43,610
services and very hard to maintain over

00:18:40,730 --> 00:18:45,740
time and nothing nothing suffices except

00:18:43,610 --> 00:18:47,120
to just keep reading the system that you

00:18:45,740 --> 00:18:50,410
have and making sure that it's a

00:18:47,120 --> 00:18:53,000
coherent interface to the outside world

00:18:50,410 --> 00:18:54,440
in addition you have to be explicit so

00:18:53,000 --> 00:18:57,200
you really need to make sure that you're

00:18:54,440 --> 00:18:58,520
not being accidental about what your

00:18:57,200 --> 00:19:00,020
interfaces make sure you've written it

00:18:58,520 --> 00:19:02,360
down somewhere having an interface

00:19:00,020 --> 00:19:05,330
defined as essentially the sum total of

00:19:02,360 --> 00:19:06,860
your entire server is very confusing and

00:19:05,330 --> 00:19:09,020
offers you no ability to do anything

00:19:06,860 --> 00:19:11,240
intelligent based on that data so

00:19:09,020 --> 00:19:13,540
writing it down in swagger gives us hard

00:19:11,240 --> 00:19:16,370
data that we can use share elsewhere and

00:19:13,540 --> 00:19:18,260
ideally we can use it to automate a lot

00:19:16,370 --> 00:19:20,690
of the overhead this is the big downside

00:19:18,260 --> 00:19:22,250
of services essentially by breaking it

00:19:20,690 --> 00:19:23,840
out of the monolith you've created a ton

00:19:22,250 --> 00:19:26,360
of overhead for yourself anytime you

00:19:23,840 --> 00:19:28,070
want change something or make a brand

00:19:26,360 --> 00:19:29,620
new service so you really have to very

00:19:28,070 --> 00:19:31,460
aggressively make sure that you're

00:19:29,620 --> 00:19:33,050
keeping up-to-date that you're

00:19:31,460 --> 00:19:35,540
automating everything that's mechanical

00:19:33,050 --> 00:19:39,890
and that'll let you scale up to larger

00:19:35,540 --> 00:19:41,540
and larger systems okay so that's a lot

00:19:39,890 --> 00:19:43,370
of talk about how we basically

00:19:41,540 --> 00:19:44,750
understand the systems we're working

00:19:43,370 --> 00:19:46,160
with how we make sure we do that when we

00:19:44,750 --> 00:19:47,840
first write them and how we make sure we

00:19:46,160 --> 00:19:50,930
keep doing that as they grow larger and

00:19:47,840 --> 00:19:52,880
larger but just understanding the

00:19:50,930 --> 00:19:55,460
system's sort of as as they stand

00:19:52,880 --> 00:19:57,290
conceptually isn't really enough and one

00:19:55,460 --> 00:20:00,470
of the big pain points we discovered was

00:19:57,290 --> 00:20:02,360
that as we grew the system larger we

00:20:00,470 --> 00:20:03,320
used to be able to just understand what

00:20:02,360 --> 00:20:05,180
was going to happen from first

00:20:03,320 --> 00:20:06,230
principles but very quickly we realized

00:20:05,180 --> 00:20:07,160
that

00:20:06,230 --> 00:20:08,960
was going to happen from first

00:20:07,160 --> 00:20:10,910
principles and what happened in practice

00:20:08,960 --> 00:20:12,799
or maybe entirely different things and

00:20:10,910 --> 00:20:14,090
so this concept of understanding what's

00:20:12,799 --> 00:20:15,620
happening in production is actually

00:20:14,090 --> 00:20:19,309
quite separate from understanding your

00:20:15,620 --> 00:20:21,590
system in theory and that kind of leads

00:20:19,309 --> 00:20:23,210
us to something like this so we got a

00:20:21,590 --> 00:20:25,250
bug report from one of our customers one

00:20:23,210 --> 00:20:27,020
of our partners and they informed us

00:20:25,250 --> 00:20:28,669
that hey we're seeing some 50 fours

00:20:27,020 --> 00:20:32,480
talking to a particular API that we

00:20:28,669 --> 00:20:34,460
maintain user info API so how do we

00:20:32,480 --> 00:20:36,470
debunk some thing like this right it's a

00:20:34,460 --> 00:20:38,000
kind of vague bug report and it's

00:20:36,470 --> 00:20:41,330
happening in production and that's kind

00:20:38,000 --> 00:20:43,700
of all we're given in in ancient times

00:20:41,330 --> 00:20:45,169
kind of back in in the bad days we might

00:20:43,700 --> 00:20:47,200
have used an approach like this you

00:20:45,169 --> 00:20:49,760
might take your most senior developer

00:20:47,200 --> 00:20:51,880
stick them in a room you know covered

00:20:49,760 --> 00:20:54,350
floor to ceiling with white boards and

00:20:51,880 --> 00:20:55,880
hand them all the logs that you happen

00:20:54,350 --> 00:20:57,559
to have available right just whatever

00:20:55,880 --> 00:20:58,669
whatever's lying around because you kind

00:20:57,559 --> 00:21:00,410
of didn't think about this ahead of time

00:20:58,669 --> 00:21:04,450
and say please debug this obscure

00:21:00,410 --> 00:21:06,799
production issue and and my kind of

00:21:04,450 --> 00:21:08,000
strange analogy here is that it's kind

00:21:06,799 --> 00:21:10,340
of like being told to do a research

00:21:08,000 --> 00:21:13,460
project and all of your resources are

00:21:10,340 --> 00:21:15,080
just someone's random bookshelf right it

00:21:13,460 --> 00:21:17,030
might be relevant if you're really lucky

00:21:15,080 --> 00:21:18,710
it's exactly what you need but just

00:21:17,030 --> 00:21:20,570
picking up old logs that someone happen

00:21:18,710 --> 00:21:22,760
to leave lying around is is not a very

00:21:20,570 --> 00:21:27,020
professional way to debug what's

00:21:22,760 --> 00:21:28,580
happening in a complex system okay so we

00:21:27,020 --> 00:21:30,200
don't want to take any random logs lying

00:21:28,580 --> 00:21:31,700
around let's do a step better let's say

00:21:30,200 --> 00:21:33,260
we have a bunch of services we're gonna

00:21:31,700 --> 00:21:34,910
write logs for them right we like

00:21:33,260 --> 00:21:37,240
logging so we're gonna log all the

00:21:34,910 --> 00:21:39,950
incoming requests we're gonna log any

00:21:37,240 --> 00:21:42,230
data that we might need about those and

00:21:39,950 --> 00:21:43,460
we're going to go with that approach so

00:21:42,230 --> 00:21:46,419
that we don't have this random

00:21:43,460 --> 00:21:48,620
collection of logs as our source of data

00:21:46,419 --> 00:21:50,480
unfortunately this presents a new

00:21:48,620 --> 00:21:52,549
problem right we no longer have to worry

00:21:50,480 --> 00:21:54,710
about not having the data and we now

00:21:52,549 --> 00:21:57,559
have to worry about drowning in a sea of

00:21:54,710 --> 00:21:59,330
it and sending out your on-call engineer

00:21:57,559 --> 00:22:01,760
and saying please debug this problem in

00:21:59,330 --> 00:22:05,000
production here is like the Library of

00:22:01,760 --> 00:22:06,559
Congress good luck is again technically

00:22:05,000 --> 00:22:08,510
okay maybe they'll make do maybe they're

00:22:06,559 --> 00:22:11,270
really good with you know grep and awk

00:22:08,510 --> 00:22:13,940
and tools like this but we can do better

00:22:11,270 --> 00:22:15,080
than that and so what we've kind of

00:22:13,940 --> 00:22:17,380
settled on is essentially the

00:22:15,080 --> 00:22:19,970
combination of really detailed logs

00:22:17,380 --> 00:22:21,590
obnoxiously detailed logs you might say

00:22:19,970 --> 00:22:24,200
and some excellent tooling for looking

00:22:21,590 --> 00:22:27,200
into them in examining them and for us

00:22:24,200 --> 00:22:29,000
that's been elasticsearch and cabana and

00:22:27,200 --> 00:22:30,760
you might often hear about them in

00:22:29,000 --> 00:22:33,500
concert with this little guy logstash

00:22:30,760 --> 00:22:36,710
and collectively this is the e lk stack

00:22:33,500 --> 00:22:37,820
if the term tlk stack is kind of strange

00:22:36,710 --> 00:22:39,170
to you or you don't know what I'm

00:22:37,820 --> 00:22:42,740
talking about I'd really encourage you

00:22:39,170 --> 00:22:44,630
to see Holmes's talk later today on sort

00:22:42,740 --> 00:22:45,890
of best practices for logging and I

00:22:44,630 --> 00:22:48,320
believe he's going to be talking about

00:22:45,890 --> 00:22:50,600
this very subject but what I'm going to

00:22:48,320 --> 00:22:52,070
talk about is sort of how we use it so

00:22:50,600 --> 00:22:53,630
elastic search is just a data store

00:22:52,070 --> 00:22:55,340
we're going to take all the logs we have

00:22:53,630 --> 00:22:56,900
and stuff them in that data store and

00:22:55,340 --> 00:22:58,430
then we're going to be able to flexibly

00:22:56,900 --> 00:23:00,110
query it because elasticsearch is a

00:22:58,430 --> 00:23:01,880
really cool search engine and we're

00:23:00,110 --> 00:23:04,430
going to get a pretty Kabana dashboards

00:23:01,880 --> 00:23:07,040
because Kabana makes things pretty so

00:23:04,430 --> 00:23:08,690
the funny thing happens when you do this

00:23:07,040 --> 00:23:10,340
is that you immediately learn things

00:23:08,690 --> 00:23:12,710
that you never had a chance of knowing

00:23:10,340 --> 00:23:14,030
before you did this this is a very

00:23:12,710 --> 00:23:16,580
simple dashboard where we're just

00:23:14,030 --> 00:23:18,290
basically graphing every partner request

00:23:16,580 --> 00:23:19,520
we get and we're breaking it down by

00:23:18,290 --> 00:23:21,950
who's sending it right because we have a

00:23:19,520 --> 00:23:24,380
number of external partners and before

00:23:21,950 --> 00:23:25,820
we did this we sort of quite naively

00:23:24,380 --> 00:23:27,440
assumed that everyone had a pretty

00:23:25,820 --> 00:23:29,240
regular calling pattern there wasn't

00:23:27,440 --> 00:23:31,130
anybody doing anything too strange and

00:23:29,240 --> 00:23:33,740
of course we discovered the moment we

00:23:31,130 --> 00:23:35,060
graphed it here that wow there's crazy

00:23:33,740 --> 00:23:36,890
stuff happening here stuff we never knew

00:23:35,060 --> 00:23:40,460
was going to happen patterns we didn't

00:23:36,890 --> 00:23:42,260
know existed so how does this help us

00:23:40,460 --> 00:23:44,630
with that mystery 504 back to our

00:23:42,260 --> 00:23:46,910
original question well it turns out that

00:23:44,630 --> 00:23:49,180
we can build very very specific queries

00:23:46,910 --> 00:23:52,100
into elasticsearch into Qabbani rather

00:23:49,180 --> 00:23:53,750
so we can ask for very specific data in

00:23:52,100 --> 00:23:56,510
this case we can say just give me all

00:23:53,750 --> 00:23:58,100
the results with a particular pyramid

00:23:56,510 --> 00:24:00,080
method name so all the things that are

00:23:58,100 --> 00:24:02,510
coming from the user info API and just

00:24:00,080 --> 00:24:03,950
toss out anything that had a 200 status

00:24:02,510 --> 00:24:06,560
response right leaves me all the stuff

00:24:03,950 --> 00:24:08,600
that's left over and we can look at how

00:24:06,560 --> 00:24:10,460
often those occur over time and sure

00:24:08,600 --> 00:24:11,900
enough we see our single spike that

00:24:10,460 --> 00:24:14,450
corresponds that 50 for that was

00:24:11,900 --> 00:24:16,760
reported by the partner and we can dial

00:24:14,450 --> 00:24:18,350
you know dive straight into exactly what

00:24:16,760 --> 00:24:20,990
the problem is and discover more about

00:24:18,350 --> 00:24:23,480
the solution and the really nice thing

00:24:20,990 --> 00:24:24,920
once you stack up this much data in one

00:24:23,480 --> 00:24:27,100
place and make sure it's comprehensive

00:24:24,920 --> 00:24:30,260
and it's available in a rich tool is

00:24:27,100 --> 00:24:31,610
you'll learn really surprising things so

00:24:30,260 --> 00:24:34,020
actually what we ended up finding out

00:24:31,610 --> 00:24:37,050
under the hood was that this 504 was

00:24:34,020 --> 00:24:39,150
cause because timings were ten times

00:24:37,050 --> 00:24:40,440
worse in one of our data centers and we

00:24:39,150 --> 00:24:42,600
didn't know this we had no way to know

00:24:40,440 --> 00:24:44,430
this except to log all the data and then

00:24:42,600 --> 00:24:48,150
give ourself a tool for really diving in

00:24:44,430 --> 00:24:50,220
and examining it and realistically we'd

00:24:48,150 --> 00:24:51,540
love to not require customers to tell us

00:24:50,220 --> 00:24:53,310
the stuff in the first place it's a

00:24:51,540 --> 00:24:55,620
little inefficient it's a hard to

00:24:53,310 --> 00:24:57,600
guarantee that we'll get all the data so

00:24:55,620 --> 00:25:00,000
we use a tool called last alert also on

00:24:57,600 --> 00:25:02,490
our github but essentially does flexible

00:25:00,000 --> 00:25:04,140
alerting with an elastic search so you

00:25:02,490 --> 00:25:06,120
have to tell it three main things you

00:25:04,140 --> 00:25:07,800
have to tell it what you want to look at

00:25:06,120 --> 00:25:10,500
in our case a particular elasticsearch

00:25:07,800 --> 00:25:12,450
host and index you have to tell it what

00:25:10,500 --> 00:25:14,640
you're looking for so we might say we're

00:25:12,450 --> 00:25:16,710
looking for at least 20 events within

00:25:14,640 --> 00:25:19,500
two minutes a spike of events of some

00:25:16,710 --> 00:25:21,060
sort and you have to tell it what you

00:25:19,500 --> 00:25:22,890
want to do if you see that so in our

00:25:21,060 --> 00:25:24,600
case most of the alerting we do says

00:25:22,890 --> 00:25:26,760
look for something like a spike of

00:25:24,600 --> 00:25:28,530
errors and if that occurs please page

00:25:26,760 --> 00:25:30,090
somebody send an email do something

00:25:28,530 --> 00:25:32,160
alarming so that we're aware of this

00:25:30,090 --> 00:25:34,770
problem and this closes that loop that

00:25:32,160 --> 00:25:36,510
feedback loop between all that data that

00:25:34,770 --> 00:25:38,220
we now gather and being able to actually

00:25:36,510 --> 00:25:40,830
know about important things when they

00:25:38,220 --> 00:25:44,520
happen all right so let's draw some

00:25:40,830 --> 00:25:46,020
lessons first off logging is a super

00:25:44,520 --> 00:25:47,400
power I would tell you that you should

00:25:46,020 --> 00:25:48,600
use it wisely but I don't want to give

00:25:47,400 --> 00:25:50,970
the wrong impression you need to be

00:25:48,600 --> 00:25:52,440
using it constantly and this is true in

00:25:50,970 --> 00:25:55,050
a monolith but it becomes even more

00:25:52,440 --> 00:25:56,460
essential in this array of microservices

00:25:55,050 --> 00:25:58,490
because the complexity of the system

00:25:56,460 --> 00:26:01,140
that you're working in has increased and

00:25:58,490 --> 00:26:03,150
that raw data by itself is not enough

00:26:01,140 --> 00:26:04,700
you need to also visualize it and if

00:26:03,150 --> 00:26:06,990
you're doing anything even vaguely

00:26:04,700 --> 00:26:08,460
mission-critical or customer-facing you

00:26:06,990 --> 00:26:11,190
should probably be monitoring on it as

00:26:08,460 --> 00:26:13,920
well and these approaches together make

00:26:11,190 --> 00:26:16,080
a world of difference we took our system

00:26:13,920 --> 00:26:17,610
from an incident response that might

00:26:16,080 --> 00:26:19,020
take days to realize something went

00:26:17,610 --> 00:26:21,030
wrong you have to wait for an email from

00:26:19,020 --> 00:26:22,890
one of your customers down to minutes we

00:26:21,030 --> 00:26:24,390
were getting alerted immediately and the

00:26:22,890 --> 00:26:25,920
investigations into what went wrong

00:26:24,390 --> 00:26:27,570
might never have been solved before

00:26:25,920 --> 00:26:29,340
because we just simply didn't know what

00:26:27,570 --> 00:26:30,900
was going on and now we have a strong

00:26:29,340 --> 00:26:34,010
tool that we could go ahead and dive in

00:26:30,900 --> 00:26:37,140
and answer the questions that we have

00:26:34,010 --> 00:26:39,660
okay so let's kind of wrap up a little

00:26:37,140 --> 00:26:42,090
bit and draw some overall lessons the

00:26:39,660 --> 00:26:43,710
first one no surprise to a room full of

00:26:42,090 --> 00:26:46,680
people familiar with python is we need

00:26:43,710 --> 00:26:47,879
to be explicit okay the first step is

00:26:46,680 --> 00:26:49,829
getting away from sort

00:26:47,879 --> 00:26:51,329
an implicit world where you interact

00:26:49,829 --> 00:26:53,579
with the service that doesn't really

00:26:51,329 --> 00:26:55,349
know what it does you interact with an

00:26:53,579 --> 00:26:57,690
interface that doesn't clearly state it

00:26:55,349 --> 00:26:59,399
anywhere and start being very clear and

00:26:57,690 --> 00:27:01,349
very explicit about the systems we're

00:26:59,399 --> 00:27:02,909
working with and if you start out with

00:27:01,349 --> 00:27:05,819
this explicitness then you actually have

00:27:02,909 --> 00:27:07,769
somewhere to go forward from and make

00:27:05,819 --> 00:27:09,059
smart decisions on and the next step

00:27:07,769 --> 00:27:11,579
after doing that is you have to measure

00:27:09,059 --> 00:27:13,679
everything again if you don't know

00:27:11,579 --> 00:27:16,139
what's happening in production you can't

00:27:13,679 --> 00:27:17,639
as a human hope to make wise engineering

00:27:16,139 --> 00:27:20,309
decisions much less make automated

00:27:17,639 --> 00:27:21,690
decisions so things like logging things

00:27:20,309 --> 00:27:23,519
like knowing where your errors are

00:27:21,690 --> 00:27:25,499
happening making those available in

00:27:23,519 --> 00:27:28,049
machine-readable formats very important

00:27:25,499 --> 00:27:30,179
and lastly and this is kind of our

00:27:28,049 --> 00:27:31,949
solution overall to this microservices

00:27:30,179 --> 00:27:35,009
problem is you have to scale with

00:27:31,949 --> 00:27:36,389
automation microservices inherently are

00:27:35,009 --> 00:27:37,799
putting a lot of overhead into your

00:27:36,389 --> 00:27:39,269
system they're making things that used

00:27:37,799 --> 00:27:40,799
to be pretty easy much harder and

00:27:39,269 --> 00:27:42,619
hopefully you're getting some good

00:27:40,799 --> 00:27:44,609
organizational benefits out of that

00:27:42,619 --> 00:27:46,919
unfortunately you can't use the old

00:27:44,609 --> 00:27:48,989
approaches used to use you have to sort

00:27:46,919 --> 00:27:51,319
of change with the times spot the places

00:27:48,989 --> 00:27:54,299
where that overhead can be minimized and

00:27:51,319 --> 00:27:58,169
automate automate it all the way until

00:27:54,299 --> 00:27:59,279
it's essentially gone or close to it all

00:27:58,169 --> 00:28:01,559
right I want to leave you with a few

00:27:59,279 --> 00:28:03,869
resources I talked about some code

00:28:01,559 --> 00:28:06,179
repositories so bravado and pyramid

00:28:03,869 --> 00:28:08,309
swagger are both swagger oriented the

00:28:06,179 --> 00:28:09,989
client and the server and the last alert

00:28:08,309 --> 00:28:11,609
is that monitoring framework on top of

00:28:09,989 --> 00:28:14,549
elastic search these are all available

00:28:11,609 --> 00:28:16,349
on github if you're interested in this

00:28:14,549 --> 00:28:18,749
overall question of how you go from a

00:28:16,349 --> 00:28:21,119
monolith to services there's a very good

00:28:18,749 --> 00:28:23,159
long-form blog post by sort of our tech

00:28:21,119 --> 00:28:24,929
lead of the services team describing

00:28:23,159 --> 00:28:27,719
what we did how we did it in lessons

00:28:24,929 --> 00:28:28,589
that we learned there and if you're

00:28:27,719 --> 00:28:30,449
interested in something a little more

00:28:28,589 --> 00:28:32,459
bite-sized we have sort of some service

00:28:30,449 --> 00:28:34,109
principles for designing brand new

00:28:32,459 --> 00:28:36,149
services how you can do that in a way

00:28:34,109 --> 00:28:39,329
that you won't immediately regret a year

00:28:36,149 --> 00:28:41,879
later and with that happy to take any

00:28:39,329 --> 00:28:43,559
questions if you don't get a chance to

00:28:41,879 --> 00:28:45,179
ask me feel free to catch up with me on

00:28:43,559 --> 00:28:47,959
twitter or email or out in the halls

00:28:45,179 --> 00:28:47,959
thank you very much

00:28:58,910 --> 00:29:02,760
thanks a lot it's really good I liked

00:29:01,290 --> 00:29:07,410
how you kind of covered a bit of a dev

00:29:02,760 --> 00:29:09,630
and then an OP story just wanted if you

00:29:07,410 --> 00:29:11,550
could touch maybe on the software

00:29:09,630 --> 00:29:14,370
development lifecycle you've got where

00:29:11,550 --> 00:29:15,900
where you may have multiple services in

00:29:14,370 --> 00:29:18,870
development that you know either

00:29:15,900 --> 00:29:20,720
consumed will provide to each other and

00:29:18,870 --> 00:29:23,400
how you manage that between the teams

00:29:20,720 --> 00:29:26,070
sure yeah that definitely is a

00:29:23,400 --> 00:29:28,020
complexity I think we aim as much as

00:29:26,070 --> 00:29:30,390
possible for the development lifecycle

00:29:28,020 --> 00:29:33,450
to let them be completely independent of

00:29:30,390 --> 00:29:34,980
each other that has a lot of really good

00:29:33,450 --> 00:29:36,150
upsides in terms of being able to deploy

00:29:34,980 --> 00:29:37,470
your code without worrying about

00:29:36,150 --> 00:29:39,240
everyone else we talked earlier about

00:29:37,470 --> 00:29:40,710
what happens when you have hundreds of

00:29:39,240 --> 00:29:42,660
developers that I'll need to worry about

00:29:40,710 --> 00:29:44,760
everybody else deploying their code

00:29:42,660 --> 00:29:46,710
simultaneously but it also comes with

00:29:44,760 --> 00:29:48,720
challenges they're testing challenges

00:29:46,710 --> 00:29:50,160
they're they're sort of making sure that

00:29:48,720 --> 00:29:53,310
the deploys don't step on each other

00:29:50,160 --> 00:29:55,560
challenges it's very complicated if it's

00:29:53,310 --> 00:29:56,790
not a simple thing to describe but if

00:29:55,560 --> 00:30:01,410
you want to talk after I'd be happy to

00:29:56,790 --> 00:30:02,970
to get into more detail with you high

00:30:01,410 --> 00:30:04,890
school I was just wondering when you

00:30:02,970 --> 00:30:08,220
guys initially transition to using micro

00:30:04,890 --> 00:30:11,190
services if you noticed when you when

00:30:08,220 --> 00:30:12,570
you had the monolith if you were calling

00:30:11,190 --> 00:30:14,640
an API to be the cost of a function call

00:30:12,570 --> 00:30:16,950
when you go to a micro servers you're

00:30:14,640 --> 00:30:18,210
introducing the cost of either I PC or

00:30:16,950 --> 00:30:19,830
network traffic I was just wondering if

00:30:18,210 --> 00:30:21,540
you notice the performance cost and also

00:30:19,830 --> 00:30:23,940
particularly when you've got the network

00:30:21,540 --> 00:30:26,520
there if you noticed a reliability cost

00:30:23,940 --> 00:30:28,770
as well yeah no both great questions I

00:30:26,520 --> 00:30:30,270
will say we we use Python at Yelp

00:30:28,770 --> 00:30:32,490
ninety-five percent of our code is built

00:30:30,270 --> 00:30:34,290
in Python so performance costs or

00:30:32,490 --> 00:30:35,700
something that we are familiar with

00:30:34,290 --> 00:30:37,410
right we're not we're already not

00:30:35,700 --> 00:30:39,660
choosing the most performant language we

00:30:37,410 --> 00:30:41,010
could so when we switched over to

00:30:39,660 --> 00:30:42,750
services we definitely saw a bit of a

00:30:41,010 --> 00:30:44,460
hit I think the most extreme hidden

00:30:42,750 --> 00:30:47,010
performance is kind of what I alluded to

00:30:44,460 --> 00:30:49,560
earlier with doing stupid things cross

00:30:47,010 --> 00:30:52,110
data center accidentally that's a killer

00:30:49,560 --> 00:30:53,730
that will easily cost you seconds that

00:30:52,110 --> 00:30:55,410
you don't know about as far as

00:30:53,730 --> 00:30:57,570
reliability I think that's actually the

00:30:55,410 --> 00:30:59,700
more important of the two issues because

00:30:57,570 --> 00:31:00,720
it hits you everywhere hits you in

00:30:59,700 --> 00:31:03,840
production it hit

00:31:00,720 --> 00:31:05,370
to you maybe most nasty in testing when

00:31:03,840 --> 00:31:07,169
all of your tests that used to pass all

00:31:05,370 --> 00:31:08,760
the time because they're correct start

00:31:07,169 --> 00:31:10,350
failing ten percent of the time not

00:31:08,760 --> 00:31:12,480
because they're incorrect but because

00:31:10,350 --> 00:31:15,330
you have all these sources of failure

00:31:12,480 --> 00:31:16,530
involved yeah very challenging and

00:31:15,330 --> 00:31:21,630
something that we're still working

00:31:16,530 --> 00:31:23,429
through yep hi many of the sort of

00:31:21,630 --> 00:31:25,919
lessons you taught about the first half

00:31:23,429 --> 00:31:28,559
you talk have a lot of correlation to

00:31:25,919 --> 00:31:30,659
normal coding practices around making

00:31:28,559 --> 00:31:32,520
sure documentation is there and explicit

00:31:30,659 --> 00:31:34,710
and just wondering are there any

00:31:32,520 --> 00:31:37,890
specific differences between say

00:31:34,710 --> 00:31:41,580
document in a specific code base versus

00:31:37,890 --> 00:31:44,100
a micro services based project sure any

00:31:41,580 --> 00:31:46,650
differences in documentation um I think

00:31:44,100 --> 00:31:49,650
one thing that we definitely noticed was

00:31:46,650 --> 00:31:51,270
it's easy to be lazy in a single

00:31:49,650 --> 00:31:52,950
monolith because strictly speaking

00:31:51,270 --> 00:31:55,350
you'll be told immediately if you're

00:31:52,950 --> 00:31:56,940
wrong or at least you'll be told more

00:31:55,350 --> 00:31:58,950
immediately if you're wrong right if you

00:31:56,940 --> 00:32:00,120
do something truly awful you're going to

00:31:58,950 --> 00:32:03,780
get yelled at the moment you call a

00:32:00,120 --> 00:32:06,150
function in general just the space for

00:32:03,780 --> 00:32:08,730
mistakes is smaller when you're in a

00:32:06,150 --> 00:32:10,799
single code base and so while none of

00:32:08,730 --> 00:32:13,380
the fundamental issues went away in that

00:32:10,799 --> 00:32:14,789
scenario they were much less apparent

00:32:13,380 --> 00:32:17,610
and much less damaging when they went

00:32:14,789 --> 00:32:19,080
wrong so there's that and then I would

00:32:17,610 --> 00:32:21,450
also just say the nice thing about API

00:32:19,080 --> 00:32:23,340
is is you can actually conceive of

00:32:21,450 --> 00:32:26,220
something like swagger that exhaustively

00:32:23,340 --> 00:32:28,770
documents the entirety of the an HTTP

00:32:26,220 --> 00:32:32,150
API which is possible in something like

00:32:28,770 --> 00:32:35,610
Python but I think we do less often as

00:32:32,150 --> 00:32:36,840
programmers yeah all right I'm afraid

00:32:35,610 --> 00:32:39,500
that's all we have time for but thank

00:32:36,840 --> 00:32:39,500
you very much Scott

00:32:48,800 --> 00:32:50,860

YouTube URL: https://www.youtube.com/watch?v=H0KReHUawHI


