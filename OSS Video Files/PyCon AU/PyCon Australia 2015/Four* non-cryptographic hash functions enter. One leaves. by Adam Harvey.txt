Title: Four* non-cryptographic hash functions enter. One leaves. by Adam Harvey
Publication date: 2015-08-04
Playlist: PyCon Australia 2015
Description: 
	When you say “hash function” in a room full of Python developers, people tend to think of the classics you get in hashlib: MD5, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-OHGODPLEASESTOP, and the like — cryptographic hash functions intended for cryptographic uses.

There’s another world out there, though: non-cryptographic hashes. Sometimes you just need to figure out if you’ve already seen a string or structure. Sometimes you need a basic checksum. Sometimes you need a hash that’s just fast and can fit into a 32 bit integer.

I’ll run through the state of the art in the world of non-cryptographic hashing — what your best options are, how they compare in terms of CPU and memory usage, and how they work. Who takes it? Whose mixing function reigns supreme?

Let’s find out.

* I’m saying “four”, but realistically I’m going to cover as many modern options as I can fit into the time available. Let’s say “four plus two or minus one” in reality.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:10,240 --> 00:00:17,349
alright welcome to our last talk before

00:00:14,139 --> 00:00:19,960
the lightning talks this afternoon so

00:00:17,349 --> 00:00:22,480
here we've got Adam Harvey from New

00:00:19,960 --> 00:00:25,029
Relic and the talk is called four ish

00:00:22,480 --> 00:00:33,489
non cryptographic hash functions enter

00:00:25,029 --> 00:00:35,110
one leaves please welcome him thank you

00:00:33,489 --> 00:00:39,790
for the round of applause before that

00:00:35,110 --> 00:00:41,949
always helps I am indeed Adam Harvey I

00:00:39,790 --> 00:00:43,420
am from New Relic this talk has

00:00:41,949 --> 00:00:44,470
literally nothing to do with New Relic

00:00:43,420 --> 00:00:47,440
so that would be the last time I

00:00:44,470 --> 00:00:49,900
mentioned that so what I'm he's talked

00:00:47,440 --> 00:00:51,129
about is non cryptographic hashing so

00:00:49,900 --> 00:00:52,659
for those of you who are just in this

00:00:51,129 --> 00:00:54,970
room of course there was a wonderful

00:00:52,659 --> 00:00:56,379
talk about cryptography this is kind of

00:00:54,970 --> 00:00:57,400
the flip side this is for all the times

00:00:56,379 --> 00:01:01,839
where you don't really care about

00:00:57,400 --> 00:01:06,880
security or verifiability or protection

00:01:01,839 --> 00:01:09,520
from attacks so fundamentally let's

00:01:06,880 --> 00:01:10,990
start with a few definitions I'm sure

00:01:09,520 --> 00:01:12,220
most of you know what a hash function is

00:01:10,990 --> 00:01:15,119
but just to make sure we're on the same

00:01:12,220 --> 00:01:17,979
page and to these gently into the talk a

00:01:15,119 --> 00:01:29,710
hash function takes an arbitrary amount

00:01:17,979 --> 00:01:38,469
of data and breaks that's always good my

00:01:29,710 --> 00:01:41,130
apologies one moment please not that is

00:01:38,469 --> 00:01:41,130
interesting

00:01:51,610 --> 00:02:00,799
okay well let's see how we go the

00:01:59,570 --> 00:02:02,360
animation is going to be fairly

00:02:00,799 --> 00:02:06,470
uninspiring them because they're not

00:02:02,360 --> 00:02:08,179
working okay basically though a hash

00:02:06,470 --> 00:02:10,160
function is something that takes an

00:02:08,179 --> 00:02:13,819
arbitrary amount of data and turns it

00:02:10,160 --> 00:02:15,800
into a finite amount of data the finite

00:02:13,819 --> 00:02:19,250
amount of data is of course usually an

00:02:15,800 --> 00:02:20,959
integer and we are all generally fairly

00:02:19,250 --> 00:02:22,850
familiar with this concept courtesy of

00:02:20,959 --> 00:02:25,040
the various cryptographic hash functions

00:02:22,850 --> 00:02:29,030
that we use and take for granted for

00:02:25,040 --> 00:02:31,220
example we have md5 sha-1 sha-256 shard

00:02:29,030 --> 00:02:33,380
512 and of course these all work

00:02:31,220 --> 00:02:36,739
basically that way you give them a

00:02:33,380 --> 00:02:39,050
binary binary string stuff happens in

00:02:36,739 --> 00:02:41,150
hash lube and out the other end you get

00:02:39,050 --> 00:02:43,310
a number basically now that number might

00:02:41,150 --> 00:02:46,790
be encoded as a hex string but you get a

00:02:43,310 --> 00:02:48,680
number and of course we use these every

00:02:46,790 --> 00:02:52,840
day whether directly or not they

00:02:48,680 --> 00:02:56,540
underpin SSL encryption password storage

00:02:52,840 --> 00:03:00,350
check something and a lot of other

00:02:56,540 --> 00:03:02,209
things that we take for granted so those

00:03:00,350 --> 00:03:03,799
are cryptographic hash functions now

00:03:02,209 --> 00:03:06,500
cryptographic hash functions have

00:03:03,799 --> 00:03:08,030
specific qualities they're designed to

00:03:06,500 --> 00:03:11,180
be as difficult as possible to generate

00:03:08,030 --> 00:03:12,769
collisions and you shouldn't be able to

00:03:11,180 --> 00:03:15,980
easily work back to figure out what the

00:03:12,769 --> 00:03:18,079
input was you then also have another

00:03:15,980 --> 00:03:19,609
category of key derivation functions

00:03:18,079 --> 00:03:21,500
which usually built on top of these

00:03:19,609 --> 00:03:23,150
hashing functions and these are use for

00:03:21,500 --> 00:03:24,980
passwords you know you're trying to make

00:03:23,150 --> 00:03:28,070
it as hard as possible for somebody to

00:03:24,980 --> 00:03:30,260
be able to generate a rainbow table so

00:03:28,070 --> 00:03:33,049
if that's a cryptographic hash function

00:03:30,260 --> 00:03:34,340
I guess it stands to reason a non

00:03:33,049 --> 00:03:37,130
cryptographic hash function is

00:03:34,340 --> 00:03:38,870
everything else there's also a place for

00:03:37,130 --> 00:03:41,120
functions that basically just you give

00:03:38,870 --> 00:03:42,140
them some data and out the other end you

00:03:41,120 --> 00:03:44,000
get a number and it doesn't really

00:03:42,140 --> 00:03:46,190
matter whether it's easy to reverse back

00:03:44,000 --> 00:03:47,780
to the original data it doesn't really

00:03:46,190 --> 00:03:49,730
matter to some extent how well

00:03:47,780 --> 00:03:52,489
distribute it is and of course you want

00:03:49,730 --> 00:03:55,850
it to be fast this is the world of the

00:03:52,489 --> 00:03:57,590
non cryptographic hash now that all

00:03:55,850 --> 00:04:01,730
sounds great in theory but why would I

00:03:57,590 --> 00:04:03,680
want this why does it matter well there

00:04:01,730 --> 00:04:04,370
are a number of uses you might want to

00:04:03,680 --> 00:04:06,650
track things

00:04:04,370 --> 00:04:10,459
previously seen now of course in Python

00:04:06,650 --> 00:04:13,190
you have a set type so in theory this is

00:04:10,459 --> 00:04:15,650
unnecessary but if what you're tracking

00:04:13,190 --> 00:04:17,510
is large data sets maybe you know

00:04:15,650 --> 00:04:18,799
genetics data something like that and

00:04:17,510 --> 00:04:20,180
you just want to know if you've seen it

00:04:18,799 --> 00:04:21,620
before you don't want to keep the whole

00:04:20,180 --> 00:04:23,810
thing in a set because your memory usage

00:04:21,620 --> 00:04:25,639
is going to just skyrocket instead you

00:04:23,810 --> 00:04:28,010
just want to keep a number that

00:04:25,639 --> 00:04:30,229
represents that now you can alter it now

00:04:28,010 --> 00:04:31,580
you can use hash lube for this but you

00:04:30,229 --> 00:04:33,229
might want to minimize that I mean even

00:04:31,580 --> 00:04:36,020
the smallest hash function that hashley

00:04:33,229 --> 00:04:38,180
provides is I think 64 bits of output a

00:04:36,020 --> 00:04:39,560
lot of non cryptographic hash functions

00:04:38,180 --> 00:04:42,169
can give you 32 bits they can give you

00:04:39,560 --> 00:04:43,580
less if you really want to it's a very

00:04:42,169 --> 00:04:45,050
quick way particularly in scenarios

00:04:43,580 --> 00:04:46,940
where maybe you're not too concerned

00:04:45,050 --> 00:04:49,789
about a hundred percent accuracy but you

00:04:46,940 --> 00:04:54,470
want 99.99 percent accuracy of tracking

00:04:49,789 --> 00:04:55,460
what you've already seen another option

00:04:54,470 --> 00:04:56,840
is you might want to check if

00:04:55,460 --> 00:04:58,910
something's valid you can use these as

00:04:56,840 --> 00:05:00,350
check sums most of these two original

00:04:58,910 --> 00:05:02,240
echeck some functions in the first place

00:05:00,350 --> 00:05:05,090
I mean a checksum really is just a non

00:05:02,240 --> 00:05:07,210
cryptographic hash right so there are

00:05:05,090 --> 00:05:10,789
scenarios where you might just want the

00:05:07,210 --> 00:05:14,139
2015 version of the parity bit in those

00:05:10,789 --> 00:05:16,430
situations these will get you there

00:05:14,139 --> 00:05:17,660
interrupts a big one actually I said I

00:05:16,430 --> 00:05:19,639
wasn't going to mention you relic again

00:05:17,660 --> 00:05:22,570
and if anybody from New Relic sees the

00:05:19,639 --> 00:05:24,889
video skip the next 60 seconds or so we

00:05:22,570 --> 00:05:28,960
implemented a feature last year which

00:05:24,889 --> 00:05:32,770
required us to be able to track what

00:05:28,960 --> 00:05:36,229
urls people had basically visited in

00:05:32,770 --> 00:05:38,270
order to do this we needed some way of

00:05:36,229 --> 00:05:39,770
basically having a reference back and we

00:05:38,270 --> 00:05:41,389
ended up using a non cryptographic hash

00:05:39,770 --> 00:05:43,340
function because people spec weird

00:05:41,389 --> 00:05:44,660
things people get clever ideas and then

00:05:43,340 --> 00:05:46,729
they get written down in specs and

00:05:44,660 --> 00:05:49,310
whether they're a good idea or not it

00:05:46,729 --> 00:05:52,280
wasn't they do then have to implement

00:05:49,310 --> 00:05:53,570
and deal with them anyway so maybe

00:05:52,280 --> 00:05:58,400
you're just going to have to know how to

00:05:53,570 --> 00:06:00,139
implement fnv 1a finally maybe it's fun

00:05:58,400 --> 00:06:02,090
like you know there's some there's some

00:06:00,139 --> 00:06:03,889
mats here it's kind of nifty some of

00:06:02,090 --> 00:06:05,960
these are really simple you know it's a

00:06:03,889 --> 00:06:08,539
chance to do something a little bit

00:06:05,960 --> 00:06:10,310
different and maybe push Python in ways

00:06:08,539 --> 00:06:14,419
that you don't usually tend to push it

00:06:10,310 --> 00:06:15,930
all right how are we going to implement

00:06:14,419 --> 00:06:19,330
these functions

00:06:15,930 --> 00:06:21,940
well let's set some goals we probably

00:06:19,330 --> 00:06:23,380
want it to be fast and we probably want

00:06:21,940 --> 00:06:27,490
the output to be reasonably well

00:06:23,380 --> 00:06:29,320
distributed now the distribution one's

00:06:27,490 --> 00:06:31,720
an interesting thing because in a lot of

00:06:29,320 --> 00:06:34,360
cases the reason why you care about the

00:06:31,720 --> 00:06:35,680
distribution of the hash function is

00:06:34,360 --> 00:06:37,510
because a lot of the time you're

00:06:35,680 --> 00:06:38,920
implementing a hash table now this

00:06:37,510 --> 00:06:42,610
applies more to people who are working

00:06:38,920 --> 00:06:45,940
in C C++ not even really C++ I guess

00:06:42,610 --> 00:06:47,770
it's just see nowadays now in Python if

00:06:45,940 --> 00:06:48,910
you're implementing a hash table chances

00:06:47,770 --> 00:06:52,690
are something has gone horribly wrong

00:06:48,910 --> 00:06:55,150
with your life but on the off chance you

00:06:52,690 --> 00:06:57,220
actually need to this is another goal

00:06:55,150 --> 00:06:59,080
that you would have you also just don't

00:06:57,220 --> 00:07:00,520
want clumps in your output I mean you

00:06:59,080 --> 00:07:01,720
don't want things to be bucketed the

00:07:00,520 --> 00:07:03,880
same if you're going to do this because

00:07:01,720 --> 00:07:06,460
that leads to collisions and that leads

00:07:03,880 --> 00:07:09,270
to getting false positives or false

00:07:06,460 --> 00:07:14,080
negatives depending on what you're doing

00:07:09,270 --> 00:07:15,970
so one of the things you need to

00:07:14,080 --> 00:07:18,700
distribute the output is the Avalanche

00:07:15,970 --> 00:07:21,460
effect the Avalanche effect basically is

00:07:18,700 --> 00:07:22,750
just a fancy way of saying if I have

00:07:21,460 --> 00:07:25,450
these numbers and they only differ in

00:07:22,750 --> 00:07:26,860
these bits we don't really just want

00:07:25,450 --> 00:07:28,240
variants to be there because that

00:07:26,860 --> 00:07:30,010
basically means that there's not very

00:07:28,240 --> 00:07:32,080
many options for what can come out the

00:07:30,010 --> 00:07:33,580
other end you want exchange to your data

00:07:32,080 --> 00:07:36,430
to have a bigger effect on the output

00:07:33,580 --> 00:07:38,170
you want to affect all of these bits so

00:07:36,430 --> 00:07:40,030
probably the biggest thing that you will

00:07:38,170 --> 00:07:43,330
see in the implementation or the hash

00:07:40,030 --> 00:07:45,670
function is basically coming up with a

00:07:43,330 --> 00:07:47,020
way to distribute the output over the

00:07:45,670 --> 00:07:49,840
entire number that you're generating

00:07:47,020 --> 00:07:54,640
whether it's 8 bits or 32 bits or 128

00:07:49,840 --> 00:07:57,460
bits or whatever now hash functions in

00:07:54,640 --> 00:07:59,380
general work basically this way I mean

00:07:57,460 --> 00:08:01,120
this really is the gist of the talk you

00:07:59,380 --> 00:08:03,850
can just you notice the TLD higher you

00:08:01,120 --> 00:08:05,440
can pretty much leave after this Python

00:08:03,850 --> 00:08:06,880
of course being Python probably provides

00:08:05,440 --> 00:08:08,320
a cleverness function in the standard

00:08:06,880 --> 00:08:11,890
library if you figure out what to import

00:08:08,320 --> 00:08:14,110
from chunk sizes can vary some of the

00:08:11,890 --> 00:08:17,440
one by it some of the four bytes but

00:08:14,110 --> 00:08:19,330
that's pretty much how it happens this

00:08:17,440 --> 00:08:20,860
cleverness thing is actually what's

00:08:19,330 --> 00:08:22,210
called a mixing function so if you ever

00:08:20,860 --> 00:08:24,280
see the words mixing function on

00:08:22,210 --> 00:08:25,630
Wikipedia page this is what it refers to

00:08:24,280 --> 00:08:28,920
you can now drop it into conversation

00:08:25,630 --> 00:08:32,270
and it's awesome people will look at you

00:08:28,920 --> 00:08:35,070
very funny if you drop ins conversation

00:08:32,270 --> 00:08:38,220
basically all the hash function does

00:08:35,070 --> 00:08:40,110
fundamentally is you have a rolling hash

00:08:38,220 --> 00:08:41,730
value think of it as a context if you

00:08:40,110 --> 00:08:45,210
like but it's really just a number

00:08:41,730 --> 00:08:47,400
usually you have a block of input data a

00:08:45,210 --> 00:08:51,450
chunk of input data however you want to

00:08:47,400 --> 00:08:53,670
call it you will mix those hence the

00:08:51,450 --> 00:08:55,200
name and then you will generate another

00:08:53,670 --> 00:08:56,640
number out the other end now you might

00:08:55,200 --> 00:08:57,930
have some pre and post processing

00:08:56,640 --> 00:09:01,710
depending on the function but that's

00:08:57,930 --> 00:09:03,300
really all that matters how do you

00:09:01,710 --> 00:09:06,510
implement this clever less cleverness

00:09:03,300 --> 00:09:09,600
well in general you do it with unsigned

00:09:06,510 --> 00:09:12,120
fixed length integers you use bitwise

00:09:09,600 --> 00:09:14,130
operations heavily you do some

00:09:12,120 --> 00:09:15,870
multiplication and usually there is at

00:09:14,130 --> 00:09:19,230
least one magic number there's a prime

00:09:15,870 --> 00:09:22,680
number so let's just go into that a

00:09:19,230 --> 00:09:24,600
little bit more now integers now python

00:09:22,680 --> 00:09:27,150
has this wonderful quality where it will

00:09:24,600 --> 00:09:29,100
auto promote integers you know minsters

00:09:27,150 --> 00:09:31,260
arbitrary precision if you want to deal

00:09:29,100 --> 00:09:33,990
with a million bit digits you can deal

00:09:31,260 --> 00:09:35,880
with a million digits however almost

00:09:33,990 --> 00:09:38,580
every hash function existence at least

00:09:35,880 --> 00:09:40,620
all the ones I know of rely on in store

00:09:38,580 --> 00:09:43,410
over flow behavior if you have a 32-bit

00:09:40,620 --> 00:09:45,180
integer and it's 2 to the power 32 minus

00:09:43,410 --> 00:09:50,040
1 and you add 1 to it you need to get

00:09:45,180 --> 00:09:53,400
zero out the other end so how do you do

00:09:50,040 --> 00:09:55,530
this in Python well for the purposes of

00:09:53,400 --> 00:09:56,970
this talk i bet i've used numpy in all

00:09:55,530 --> 00:10:00,990
my example because it provides this

00:09:56,970 --> 00:10:05,070
convenient UN 32 object this supports

00:10:00,990 --> 00:10:06,870
the semantics we need kind of there is

00:10:05,070 --> 00:10:10,830
however another problem the moment you

00:10:06,870 --> 00:10:12,990
mix in a normal Python integer and do

00:10:10,830 --> 00:10:15,120
any operation on a you win 32 with it

00:10:12,990 --> 00:10:18,000
you still get a numpy type out the other

00:10:15,120 --> 00:10:19,560
end but it will also promote because

00:10:18,000 --> 00:10:22,770
it's trying to be helpful it's actually

00:10:19,560 --> 00:10:24,450
trying to do the right thing so you're

00:10:22,770 --> 00:10:26,310
going to see some really ugly code there

00:10:24,450 --> 00:10:30,480
is going to be an awful lot of you in

00:10:26,310 --> 00:10:32,100
thirty two constructors you may just

00:10:30,480 --> 00:10:32,910
have to serve to deal with it i would

00:10:32,100 --> 00:10:34,560
suggest actually you're going to

00:10:32,910 --> 00:10:36,990
implement a lot of these just alias it

00:10:34,560 --> 00:10:38,920
to you too I don't know I or something

00:10:36,990 --> 00:10:41,370
you probably feel better

00:10:38,920 --> 00:10:43,990
the only thing I touched on was Prime's

00:10:41,370 --> 00:10:46,630
most not grip mostly actually most

00:10:43,990 --> 00:10:48,670
hashing algorithms in general include at

00:10:46,630 --> 00:10:51,700
least one often more than one prime

00:10:48,670 --> 00:10:54,130
number is a constant so mostly so you

00:10:51,700 --> 00:10:57,310
distribute more evenly across buckets if

00:10:54,130 --> 00:10:58,750
you have buckets usually in hash table

00:10:57,310 --> 00:11:00,670
implementations buckets are usually a

00:10:58,750 --> 00:11:05,500
power of two you know you might have 128

00:11:00,670 --> 00:11:07,320
buckets you might have 256 if you

00:11:05,500 --> 00:11:09,940
accidentally have the same prime

00:11:07,320 --> 00:11:11,350
factorization of your buckets as you do

00:11:09,940 --> 00:11:13,779
for some of the constants that you're

00:11:11,350 --> 00:11:15,730
using to manipulate the state of the

00:11:13,779 --> 00:11:17,500
hash function you can end up

00:11:15,730 --> 00:11:18,730
inadvertently bucketing everything into

00:11:17,500 --> 00:11:19,930
the same thing and we're actually going

00:11:18,730 --> 00:11:22,990
to see an example of that a little bit

00:11:19,930 --> 00:11:26,829
later on so let's walk through an

00:11:22,990 --> 00:11:28,680
example FMV 1a is a venerable hash

00:11:26,829 --> 00:11:31,329
function at this point it's 24 years old

00:11:28,680 --> 00:11:34,449
it's created by Glenn Fowler Landon

00:11:31,329 --> 00:11:35,980
curtain all and phone though in 1991

00:11:34,449 --> 00:11:38,980
it's been improved a couple of times

00:11:35,980 --> 00:11:40,810
since it's still in wide use today and

00:11:38,980 --> 00:11:44,529
one of the reasons why it's in wide use

00:11:40,810 --> 00:11:48,399
today is that that's the entirety of the

00:11:44,529 --> 00:11:50,529
implementation it's a very very simple

00:11:48,399 --> 00:11:52,480
hash function you can implement it in

00:11:50,529 --> 00:11:55,480
any language you want to you can

00:11:52,480 --> 00:11:56,920
probably do this in Bray the language

00:11:55,480 --> 00:11:58,209
that I'm not going to name this code of

00:11:56,920 --> 00:12:01,089
conduct violation you can probably also

00:11:58,209 --> 00:12:03,250
do an N enter cow there are a lot of

00:12:01,089 --> 00:12:05,260
ugly u int32 tools as I previously

00:12:03,250 --> 00:12:07,930
threatened but conceptually it's very

00:12:05,260 --> 00:12:10,240
simple it's a bite wise algorithm most

00:12:07,930 --> 00:12:12,970
the older ones are and then you

00:12:10,240 --> 00:12:14,949
exclusive or it with the existing hash

00:12:12,970 --> 00:12:20,230
and then you multiply it by a magic

00:12:14,949 --> 00:12:24,550
number so we can actually walk through

00:12:20,230 --> 00:12:28,779
this that shouldn't have wrapped okay so

00:12:24,550 --> 00:12:31,060
first we set our hash value to a two and

00:12:28,779 --> 00:12:34,240
a number that's actually specified as

00:12:31,060 --> 00:12:36,459
part of FN v1a having just gone on about

00:12:34,240 --> 00:12:38,110
how primes are important this actually

00:12:36,459 --> 00:12:39,699
isn't a prime the in spite of the fact

00:12:38,110 --> 00:12:41,889
you probably would believe it was if i

00:12:39,699 --> 00:12:44,050
told you it was it's simply a nonzero

00:12:41,889 --> 00:12:47,199
value because the first version of FN v

00:12:44,050 --> 00:12:49,300
was called FN v 0 and its initial value

00:12:47,199 --> 00:12:51,160
was 0 and it turned out this did bad

00:12:49,300 --> 00:12:53,769
things

00:12:51,160 --> 00:12:55,269
the offset is actually the FN v 0 hash

00:12:53,769 --> 00:12:59,920
of the email signature of one of the

00:12:55,269 --> 00:13:02,050
creators cute so if we're going to call

00:12:59,920 --> 00:13:04,839
it with the binary string a B let's walk

00:13:02,050 --> 00:13:07,839
through what happens so this is what

00:13:04,839 --> 00:13:09,730
hashes been set to we now have the first

00:13:07,839 --> 00:13:11,769
bite which is a lowercase a we'll assume

00:13:09,730 --> 00:13:14,199
this is a ski or an ASCII like encoding

00:13:11,769 --> 00:13:18,009
so there's 97 that's the binary

00:13:14,199 --> 00:13:20,199
representation at the bottom then we do

00:13:18,009 --> 00:13:22,660
the exclusive war only three bits change

00:13:20,199 --> 00:13:24,639
so remember that Avalanche thing

00:13:22,660 --> 00:13:27,250
Avalanche affecting I just said earlier

00:13:24,639 --> 00:13:28,629
that didn't work but that's why the

00:13:27,250 --> 00:13:32,529
multiply is there because all of a

00:13:28,629 --> 00:13:36,310
sudden we change a lot of bits now those

00:13:32,529 --> 00:13:37,750
of you who have unfortunately also got

00:13:36,310 --> 00:13:39,550
computer science degrees will probably

00:13:37,750 --> 00:13:41,439
have noticed that is very close to 2 to

00:13:39,550 --> 00:13:44,589
the 24 it's actually the closest prime

00:13:41,439 --> 00:13:46,569
22 to the 24 I believe that is there

00:13:44,589 --> 00:13:49,689
because it gives you basically bit

00:13:46,569 --> 00:13:51,699
shifting behavior as well now fnv one a

00:13:49,689 --> 00:13:53,199
kind of hides the bit shift in here but

00:13:51,699 --> 00:13:55,480
every other hashing algorithm will look

00:13:53,199 --> 00:13:57,699
at uses bit shifts heavily to get this

00:13:55,480 --> 00:13:59,889
avalanche behavior so what this is doing

00:13:57,699 --> 00:14:01,180
is it's going to shift everything and

00:13:59,889 --> 00:14:03,220
then it's going to add some noise

00:14:01,180 --> 00:14:08,019
basically at the lower end of the of the

00:14:03,220 --> 00:14:10,149
number if we look at be so the next byte

00:14:08,019 --> 00:14:11,740
is only two bits different there's a

00:14:10,149 --> 00:14:15,819
zero that you can't quite see the other

00:14:11,740 --> 00:14:18,639
end so it's 98 now once again when we

00:14:15,819 --> 00:14:20,860
multiply only three bits get changed

00:14:18,639 --> 00:14:24,670
I'll sorry exclusive or only three bits

00:14:20,860 --> 00:14:25,689
change but again we do a multiplayer and

00:14:24,670 --> 00:14:27,550
this time you can see how well

00:14:25,689 --> 00:14:31,120
distribute it is even after only two

00:14:27,550 --> 00:14:33,250
very similar bites every nibble has one

00:14:31,120 --> 00:14:35,259
or two bits that have been changed so

00:14:33,250 --> 00:14:36,730
we're already seeing a real avalanche

00:14:35,259 --> 00:14:38,920
behavior here things are getting moved

00:14:36,730 --> 00:14:44,259
things are getting mutated it's all

00:14:38,920 --> 00:14:45,970
pretty cool so now we know what a non

00:14:44,259 --> 00:14:48,610
cryptographic hash function is what it

00:14:45,970 --> 00:14:50,980
looks like what it tends to do and what

00:14:48,610 --> 00:14:52,269
you can use them for let's look at a few

00:14:50,980 --> 00:14:54,279
functions I'm going to look at the

00:14:52,269 --> 00:14:56,889
32-bit versions of them a lot of these

00:14:54,279 --> 00:14:58,689
functions have 64 and 128 bit versions

00:14:56,889 --> 00:15:02,559
as well but the simplicity let's just

00:14:58,689 --> 00:15:03,910
keep it to 32 bits i've chosen functions

00:15:02,559 --> 00:15:04,960
that are considered to be reasonably

00:15:03,910 --> 00:15:06,760
state-of-the-art

00:15:04,960 --> 00:15:09,100
and also I think feasible to implement

00:15:06,760 --> 00:15:10,810
in Python there are some some hashing

00:15:09,100 --> 00:15:13,240
functions out there like City hash and

00:15:10,810 --> 00:15:15,640
farm hash that are extremely cool and

00:15:13,240 --> 00:15:20,230
complicated and basically rely very

00:15:15,640 --> 00:15:21,730
heavily on x86 64 assembly I I don't

00:15:20,230 --> 00:15:24,700
even want to know how you actually do

00:15:21,730 --> 00:15:26,500
that in Python so we need to figure out

00:15:24,700 --> 00:15:28,030
how we're going to compare them now if

00:15:26,500 --> 00:15:29,470
we remember the goals earlier we want to

00:15:28,030 --> 00:15:31,660
be fast and we want the output to be

00:15:29,470 --> 00:15:34,600
well distributed so how do we judge that

00:15:31,660 --> 00:15:35,950
fast is easy we just look at CPU time

00:15:34,600 --> 00:15:38,020
and that gives us a pretty good idea

00:15:35,950 --> 00:15:40,720
particularly if we and for the purpose

00:15:38,020 --> 00:15:42,400
of benchmarking I have load all the data

00:15:40,720 --> 00:15:46,180
into memory before we deal with it so it

00:15:42,400 --> 00:15:48,100
gets rid of any i/o overhead we also

00:15:46,180 --> 00:15:51,160
want to look at how well distributed the

00:15:48,100 --> 00:15:53,050
values are too now the easiest way to do

00:15:51,160 --> 00:15:55,000
this and the most numerical way is to

00:15:53,050 --> 00:15:58,000
look at a number of collisions so if you

00:15:55,000 --> 00:16:01,750
have 200,000 input values and you have

00:15:58,000 --> 00:16:04,120
190 9999 output values then you had a

00:16:01,750 --> 00:16:08,140
collision it's pretty basic subtraction

00:16:04,120 --> 00:16:10,150
so we can use that to quantify because i

00:16:08,140 --> 00:16:12,240
love quantifying things we can use that

00:16:10,150 --> 00:16:17,080
to quantify how good each function is

00:16:12,240 --> 00:16:19,180
I've used to input sets the words the

00:16:17,080 --> 00:16:21,760
user shared eked words list that comes

00:16:19,180 --> 00:16:24,490
with mac OS because i did the first

00:16:21,760 --> 00:16:26,170
testing of this up mac OS and a file

00:16:24,490 --> 00:16:31,030
which contains nothing but the numbers

00:16:26,170 --> 00:16:32,320
zeros to 230 5885 the reason why I chose

00:16:31,030 --> 00:16:33,730
that number is because that's the length

00:16:32,320 --> 00:16:35,200
of the words file so it means we have

00:16:33,730 --> 00:16:37,180
the same number of inputs to each of

00:16:35,200 --> 00:16:39,160
them now the words fire lies you'd

00:16:37,180 --> 00:16:40,960
expect is mostly letters some uppercase

00:16:39,160 --> 00:16:42,640
some lower case there's a little bit of

00:16:40,960 --> 00:16:43,750
punctuation in there just hyphens and

00:16:42,640 --> 00:16:46,600
stuff but it's pretty straightforward

00:16:43,750 --> 00:16:49,360
the numbers file is in many respects

00:16:46,600 --> 00:16:53,740
more interesting test because it's only

00:16:49,360 --> 00:16:55,750
ever going to have 10 values 0 to 9 so

00:16:53,740 --> 00:16:57,160
it's a very good way of testing whether

00:16:55,750 --> 00:17:00,060
the bucketing behavior is actually

00:16:57,160 --> 00:17:02,590
resilient in these in these functions

00:17:00,060 --> 00:17:04,570
since we've already looked at FNV 1a and

00:17:02,590 --> 00:17:08,290
we already know how it works let's look

00:17:04,570 --> 00:17:10,600
at the results so for the numbers you

00:17:08,290 --> 00:17:12,850
can see that ran in 1.6 three seconds I

00:17:10,600 --> 00:17:14,380
mean the actual absolute numbers don't

00:17:12,850 --> 00:17:16,720
really matter here it's really just the

00:17:14,380 --> 00:17:18,580
relative state the words has more data

00:17:16,720 --> 00:17:19,250
so it took longer there were no

00:17:18,580 --> 00:17:20,900
occlusions on

00:17:19,250 --> 00:17:24,740
numbers there were five collisions out

00:17:20,900 --> 00:17:27,110
of 235,000 whatever it was entries on

00:17:24,740 --> 00:17:29,690
the words that doesn't sound great but

00:17:27,110 --> 00:17:31,850
if you're aware of the birthday paradox

00:17:29,690 --> 00:17:33,950
which is basically that if you have a

00:17:31,850 --> 00:17:36,290
room for like 20 people there's a fifty

00:17:33,950 --> 00:17:38,150
percent chance roughly that two of them

00:17:36,290 --> 00:17:40,700
will have the same birthday the same

00:17:38,150 --> 00:17:42,920
principle works here for a naive hash

00:17:40,700 --> 00:17:45,380
function generating 32 bits of output

00:17:42,920 --> 00:17:46,760
with 200,000 inputs there is a greater

00:17:45,380 --> 00:17:49,100
than seventy-five percent chance that

00:17:46,760 --> 00:17:52,280
you'll have a collision so that's

00:17:49,100 --> 00:17:54,350
actually really about average another

00:17:52,280 --> 00:17:56,540
way to look at the distribution and this

00:17:54,350 --> 00:17:59,690
looks like noise and you will see better

00:17:56,540 --> 00:18:01,640
examples later and I shameless I need to

00:17:59,690 --> 00:18:03,950
credit someone i shamelessly stole this

00:18:01,640 --> 00:18:06,380
from a stack stack exchange answer by n

00:18:03,950 --> 00:18:10,400
Boyd so am Boyd if you ever see this I'm

00:18:06,380 --> 00:18:12,920
really sorry basically the colored bits

00:18:10,400 --> 00:18:16,430
of where values got put and then the

00:18:12,920 --> 00:18:19,460
white the white pixels are values that

00:18:16,430 --> 00:18:20,720
one used so in a perfect random hashing

00:18:19,460 --> 00:18:23,150
function you would expect to see

00:18:20,720 --> 00:18:25,850
complete noise basically we see

00:18:23,150 --> 00:18:26,900
basically noise I realize for those of

00:18:25,850 --> 00:18:30,490
you at the back this is probably very

00:18:26,900 --> 00:18:33,350
difficult but just take my word for it

00:18:30,490 --> 00:18:36,100
okay next up is murmur hash 3 what

00:18:33,350 --> 00:18:39,500
happened to my Styles this is very sad

00:18:36,100 --> 00:18:40,700
mameh hash 3 is a little bit bigger but

00:18:39,500 --> 00:18:42,650
let's break it down because it's not

00:18:40,700 --> 00:18:45,410
really that hard remember the principles

00:18:42,650 --> 00:18:46,880
you have a mixing function you might

00:18:45,410 --> 00:18:48,830
have an initial state and you have an AM

00:18:46,880 --> 00:18:50,690
state and the mixing function only takes

00:18:48,830 --> 00:18:54,590
two inputs a chunk of data and the

00:18:50,690 --> 00:18:57,290
existing hash so to start with we seed

00:18:54,590 --> 00:19:00,350
it there are some constants actually

00:18:57,290 --> 00:19:02,030
quite a few constants I am sure some of

00:19:00,350 --> 00:19:03,290
those are primes I actually don't off

00:19:02,030 --> 00:19:06,110
the top of my head know which ones are

00:19:03,290 --> 00:19:09,020
except that one definitely isn't see

00:19:06,110 --> 00:19:11,810
computer science degree and there's also

00:19:09,020 --> 00:19:13,640
a seed which maybe you'll set yourself

00:19:11,810 --> 00:19:15,050
maybe you're just hard coded value most

00:19:13,640 --> 00:19:17,600
of these a lot of these functions take

00:19:15,050 --> 00:19:19,400
seeds it's not terribly important to

00:19:17,600 --> 00:19:21,860
choose one very carefully it's just

00:19:19,400 --> 00:19:24,470
something it also means that if you need

00:19:21,860 --> 00:19:26,090
to generate different hash values for

00:19:24,470 --> 00:19:28,240
different users then you have a way to

00:19:26,090 --> 00:19:31,570
do it

00:19:28,240 --> 00:19:35,170
so then we start the mixing function we

00:19:31,570 --> 00:19:38,460
grab some data murmur hash operates four

00:19:35,170 --> 00:19:41,080
bytes at the time rather than one bite

00:19:38,460 --> 00:19:42,490
but of course we may have less than four

00:19:41,080 --> 00:19:45,790
bytes at the end so we still have to

00:19:42,490 --> 00:19:48,730
check that we use unpack funny story I

00:19:45,790 --> 00:19:51,880
am wet I became aware today that the int

00:19:48,730 --> 00:19:54,130
class in Python 3 now has a from bites

00:19:51,880 --> 00:19:56,140
method it is actually slower than unpack

00:19:54,130 --> 00:20:02,140
even though unpack has to scatter format

00:19:56,140 --> 00:20:03,460
string so don't know weird otherwise

00:20:02,140 --> 00:20:05,800
this looks pretty similar to what we

00:20:03,460 --> 00:20:08,380
expect we have some data coming in we

00:20:05,800 --> 00:20:10,600
multiply it we do some bit shifting just

00:20:08,380 --> 00:20:12,220
try and get some small randomness not

00:20:10,600 --> 00:20:14,530
randomness i'm using random thus the

00:20:12,220 --> 00:20:17,040
runway try and get some values more

00:20:14,530 --> 00:20:20,770
evenly distributed across the across the

00:20:17,040 --> 00:20:23,320
hash to another multiply exclusive or

00:20:20,770 --> 00:20:26,980
more stuff more stuff and it gets

00:20:23,320 --> 00:20:28,540
mutated if there are less than 4 bytes

00:20:26,980 --> 00:20:31,240
remaining then there's an alternative

00:20:28,540 --> 00:20:33,309
mixing function and this is important if

00:20:31,240 --> 00:20:35,140
you are writing a hash function that

00:20:33,309 --> 00:20:36,640
works on more than a bite at a time you

00:20:35,140 --> 00:20:38,080
have to have some way of actually mixing

00:20:36,640 --> 00:20:41,140
the remaining bytes otherwise you've

00:20:38,080 --> 00:20:44,440
just thrown away entropy pretty much the

00:20:41,140 --> 00:20:46,720
same thing mid shift mid shift bit

00:20:44,440 --> 00:20:49,500
shifts some multiplies some exclusive

00:20:46,720 --> 00:20:51,550
Wars and you end up with a hash value

00:20:49,500 --> 00:20:52,980
finally at the end and this is something

00:20:51,550 --> 00:20:55,900
that's very fashionable at the moment

00:20:52,980 --> 00:20:57,520
you have a series of post processing

00:20:55,900 --> 00:20:59,280
steps to try and introduce some more

00:20:57,520 --> 00:21:02,230
pseudo randomness into the whole thing

00:20:59,280 --> 00:21:03,760
so it's again the same sort of thing the

00:21:02,230 --> 00:21:05,320
difference is that the inputs instead of

00:21:03,760 --> 00:21:07,270
coming from the data a hard-coded

00:21:05,320 --> 00:21:10,059
constants which have presumably been

00:21:07,270 --> 00:21:12,929
chosen to maximize the distribution of

00:21:10,059 --> 00:21:17,940
the values that come out the other end

00:21:12,929 --> 00:21:20,770
so murmur hash 3 is quite a bit slower

00:21:17,940 --> 00:21:25,420
the reason it's quite a bit slower than

00:21:20,770 --> 00:21:28,480
FNV 1a is a mixture of reasons firstly

00:21:25,420 --> 00:21:30,940
we have to unpack before the four bytes

00:21:28,480 --> 00:21:33,280
of the time secondly it does a lot more

00:21:30,940 --> 00:21:37,430
I mean FMV 1a was basically an exclusive

00:21:33,280 --> 00:21:40,970
or a multiply that was it wasn't it

00:21:37,430 --> 00:21:43,190
so this obviously does a lot more C

00:21:40,970 --> 00:21:44,540
Python is an excellent piece of

00:21:43,190 --> 00:21:46,490
engineering but if you want share

00:21:44,540 --> 00:21:49,370
mathematical speed it's not necessarily

00:21:46,490 --> 00:21:51,530
your best friend it also generates five

00:21:49,370 --> 00:21:53,980
collisions each of them which as I said

00:21:51,530 --> 00:21:57,490
before it's kind of a doubt right and

00:21:53,980 --> 00:22:00,200
the distribution is again pretty noisy

00:21:57,490 --> 00:22:02,480
another relatively new hash function is

00:22:00,200 --> 00:22:04,490
exits hash which has been adopted by a

00:22:02,480 --> 00:22:06,020
number of projects including FP cents

00:22:04,490 --> 00:22:07,460
and teamviewer they're very keen to tell

00:22:06,020 --> 00:22:09,680
you that on the website but I don't know

00:22:07,460 --> 00:22:11,390
what they're actually used for has a

00:22:09,680 --> 00:22:13,850
similar construction to murmur hash but

00:22:11,390 --> 00:22:16,070
it reads 16 bytes at once and is i would

00:22:13,850 --> 00:22:17,750
say about as long as you would feasibly

00:22:16,070 --> 00:22:19,910
actually want to implement something in

00:22:17,750 --> 00:22:21,710
python i'm not going to go through all

00:22:19,910 --> 00:22:24,130
the boilerplate there is pre-processing

00:22:21,710 --> 00:22:26,480
at the start there are some constants

00:22:24,130 --> 00:22:28,100
the interesting thing is it reads 16

00:22:26,480 --> 00:22:31,130
bytes at the time so this is the mixing

00:22:28,100 --> 00:22:33,620
function for each 16-byte Chun and it

00:22:31,130 --> 00:22:36,050
keeps separate accumulators in the hash

00:22:33,620 --> 00:22:38,570
and only at the very end of the of the

00:22:36,050 --> 00:22:41,930
read after its read all 2 16 byte chunks

00:22:38,570 --> 00:22:43,220
does actually combine them again it's I

00:22:41,930 --> 00:22:44,780
should actually put roffle on there I'm

00:22:43,220 --> 00:22:49,130
sorry it's a left shift and a right

00:22:44,780 --> 00:22:52,070
shift again at the end it basically

00:22:49,130 --> 00:22:54,650
shifts exclusive ors multiplications

00:22:52,070 --> 00:22:56,630
same same parts just put together

00:22:54,650 --> 00:22:58,430
differently it's like cooking you really

00:22:56,630 --> 00:23:00,320
only have like ten techniques and 100

00:22:58,430 --> 00:23:04,190
ingredients but think about the variety

00:23:00,320 --> 00:23:06,410
of dishes out there again you have

00:23:04,190 --> 00:23:08,330
separate mixing functions for four bytes

00:23:06,410 --> 00:23:10,250
of the time and for one bite at a time

00:23:08,330 --> 00:23:12,640
so when you come to the end of your data

00:23:10,250 --> 00:23:18,200
everything still gets taken into account

00:23:12,640 --> 00:23:20,780
again lots of post-processing it's

00:23:18,200 --> 00:23:22,490
quicker than murmur hash in Python and

00:23:20,780 --> 00:23:25,160
the reason it's quicker I'm pretty sure

00:23:22,490 --> 00:23:27,320
is because it's just hitting the cache

00:23:25,160 --> 00:23:28,970
better it's reading 16 bytes at the time

00:23:27,320 --> 00:23:32,330
it's doing more stuff with stuff that's

00:23:28,970 --> 00:23:34,670
in the CPU cache you get basically

00:23:32,330 --> 00:23:36,710
better performance has a slightly

00:23:34,670 --> 00:23:38,810
worrying number of collisions on words

00:23:36,710 --> 00:23:41,990
but that's okay the distribution in

00:23:38,810 --> 00:23:44,150
general again looks pretty noisy so

00:23:41,990 --> 00:23:48,290
these are all good hash functions let's

00:23:44,150 --> 00:23:51,080
look at one that's less good this is

00:23:48,290 --> 00:23:54,679
superfast hash the name a lot in kind of

00:23:51,080 --> 00:23:57,590
kind of worries you I don't expect you

00:23:54,679 --> 00:23:59,059
to read this I will have a note because

00:23:57,590 --> 00:24:01,370
I don't think I put on the next slide

00:23:59,059 --> 00:24:02,870
there's no initial state besides the

00:24:01,370 --> 00:24:07,429
seed and the length of the data there

00:24:02,870 --> 00:24:09,950
are no magic constants here the mixing

00:24:07,429 --> 00:24:11,360
function actually it reads four bytes of

00:24:09,950 --> 00:24:12,950
the time that unpacks them into short

00:24:11,360 --> 00:24:15,980
integers and then mixes them in an

00:24:12,950 --> 00:24:17,720
interesting way there are some

00:24:15,980 --> 00:24:19,610
gymnastics around bit shifting but if

00:24:17,720 --> 00:24:22,480
you kind of pay attention the offsets

00:24:19,610 --> 00:24:24,919
are pretty much the same every time and

00:24:22,480 --> 00:24:26,929
then at the end there is a lot of

00:24:24,919 --> 00:24:30,169
post-processing and it's all bit shifts

00:24:26,929 --> 00:24:32,750
and exclusive Wars the reason for this

00:24:30,169 --> 00:24:34,940
I'm reasonably sure and smarter people

00:24:32,750 --> 00:24:36,950
are me also have also said this online

00:24:34,940 --> 00:24:40,220
so I assume it's probably actually true

00:24:36,950 --> 00:24:41,870
is that the mixing function doesn't do a

00:24:40,220 --> 00:24:44,419
very good job particularly with small

00:24:41,870 --> 00:24:46,700
inputs it can collapse into the same set

00:24:44,419 --> 00:24:50,929
of states based on the first 16 bytes on

00:24:46,700 --> 00:24:52,490
an overly overly common basis now

00:24:50,929 --> 00:24:54,350
remember how I said earlier numbers

00:24:52,490 --> 00:24:59,480
doesn't have a lot of entropy it's only

00:24:54,350 --> 00:25:01,100
got 10 digits well that's the net result

00:24:59,480 --> 00:25:03,919
a lot of them collapse into the same

00:25:01,100 --> 00:25:05,630
states so you end up with ten percent of

00:25:03,919 --> 00:25:07,730
your input basically ending up is the

00:25:05,630 --> 00:25:09,830
same thing words does a little bit

00:25:07,730 --> 00:25:11,210
better I don't know how obvious this

00:25:09,830 --> 00:25:13,010
will be those of you at the front might

00:25:11,210 --> 00:25:16,639
actually be able to spot this it looks

00:25:13,010 --> 00:25:18,500
pretty noisy but there's a big stripe up

00:25:16,639 --> 00:25:20,330
the right hand side here and what that

00:25:18,500 --> 00:25:22,399
means is this is where the values are

00:25:20,330 --> 00:25:25,549
collapsing into so this is for the

00:25:22,399 --> 00:25:26,809
numbers data set way too many of them

00:25:25,549 --> 00:25:28,159
are collapsing in here an extra fact it

00:25:26,809 --> 00:25:31,070
would be much more dramatic but I

00:25:28,159 --> 00:25:32,960
actually tweaked the script I wrote to

00:25:31,070 --> 00:25:36,019
generate this to actually still have

00:25:32,960 --> 00:25:39,309
some color in the rest of it that's not

00:25:36,019 --> 00:25:42,470
very good it could be worse to be fair

00:25:39,309 --> 00:25:44,809
this is the ungoogleable j/s hash I'm

00:25:42,470 --> 00:25:45,860
not going to show any implementation of

00:25:44,809 --> 00:25:48,019
this it was invented by a guy called

00:25:45,860 --> 00:25:49,760
Justin Sobel I'm only aware of it

00:25:48,019 --> 00:25:52,570
because we used a new relic in the

00:25:49,760 --> 00:25:55,580
product i work on until six months ago

00:25:52,570 --> 00:25:58,460
when we got some fairly interesting bug

00:25:55,580 --> 00:26:00,320
reports about very bad behavior related

00:25:58,460 --> 00:26:02,019
to hash tables and our in our app link

00:26:00,320 --> 00:26:06,879
in our library and

00:26:02,019 --> 00:26:09,229
that's why finally let's look at crc32

00:26:06,879 --> 00:26:11,389
crcs are a very old set of functions

00:26:09,229 --> 00:26:12,950
they rely on polynomial division to

00:26:11,389 --> 00:26:15,320
generate a checksum check sums and

00:26:12,950 --> 00:26:17,029
basically just hash values there are

00:26:15,320 --> 00:26:19,070
really serious maths here it's late in

00:26:17,029 --> 00:26:20,509
the afternoon and I think any of us are

00:26:19,070 --> 00:26:28,489
ready for this but here's the

00:26:20,509 --> 00:26:30,950
implementation so why wouldn't you use

00:26:28,489 --> 00:26:33,649
this all the time well actually you

00:26:30,950 --> 00:26:35,899
might it's not that bad there are eight

00:26:33,649 --> 00:26:37,700
collisions zero for the numbers it's

00:26:35,899 --> 00:26:39,679
obviously way faster than everything

00:26:37,700 --> 00:26:42,529
else is like a third of the time of fnv

00:26:39,679 --> 00:26:45,019
which is the previous best the word

00:26:42,529 --> 00:26:46,340
collisions are potentially an issue so

00:26:45,019 --> 00:26:48,559
it's something you have to be aware of

00:26:46,340 --> 00:26:51,019
depending on what type of input you give

00:26:48,559 --> 00:26:53,029
it you may get a few more collisions

00:26:51,019 --> 00:26:55,190
than the state of the art the other

00:26:53,029 --> 00:26:57,619
problem with crc32 is it uses a lookup

00:26:55,190 --> 00:27:01,429
table very heavily to actually do its

00:26:57,619 --> 00:27:03,499
division now on this laptop and this

00:27:01,429 --> 00:27:05,479
phone and pretty much everything in this

00:27:03,499 --> 00:27:07,429
room we're probably fine if any of you

00:27:05,479 --> 00:27:10,099
went to the seven dollar Python computer

00:27:07,429 --> 00:27:15,049
talk earlier though maybe not the thing

00:27:10,099 --> 00:27:17,720
to choose so in conclusion you need to

00:27:15,049 --> 00:27:20,330
know your environment if you're

00:27:17,720 --> 00:27:22,129
implementing things in not Python I mean

00:27:20,330 --> 00:27:23,960
I realize this is Pike on this is a very

00:27:22,129 --> 00:27:27,259
crazy statement but maybe you're doing

00:27:23,960 --> 00:27:29,090
something in c murmur hash and eggs hash

00:27:27,259 --> 00:27:30,739
suddenly become way faster and the

00:27:29,090 --> 00:27:32,899
reason they become way faster is because

00:27:30,739 --> 00:27:36,619
they exploit very specific features of

00:27:32,899 --> 00:27:39,409
modern CPUs when you write the code in C

00:27:36,619 --> 00:27:41,479
rather than aromatic Python they use

00:27:39,409 --> 00:27:42,649
cash locality they use read alignment

00:27:41,479 --> 00:27:44,929
they do a lot of things to their

00:27:42,649 --> 00:27:46,340
advantage now in Python the problem is

00:27:44,929 --> 00:27:48,109
that's all over head is all still has to

00:27:46,340 --> 00:27:50,179
go through C pythons so you pretty much

00:27:48,109 --> 00:27:51,440
lose every single advantage even if

00:27:50,179 --> 00:27:53,960
you're using the right assembly

00:27:51,440 --> 00:27:55,549
instructions so imply thumb the bite of

00:27:53,960 --> 00:27:57,109
the time approach is actually faster

00:27:55,549 --> 00:28:00,559
because of the way the bytes arrays are

00:27:57,109 --> 00:28:02,840
represented internally you need to know

00:28:00,559 --> 00:28:04,220
your requirements understand how many

00:28:02,840 --> 00:28:06,080
collisions you're willing to bear there

00:28:04,220 --> 00:28:08,690
are probably uses we're being right 90

00:28:06,080 --> 00:28:10,070
Apes and the time of fine there are

00:28:08,690 --> 00:28:11,599
probably places when ninety percent the

00:28:10,070 --> 00:28:13,220
time is fine and you can use superfast

00:28:11,599 --> 00:28:14,130
hash and paint little decals on your

00:28:13,220 --> 00:28:16,830
computer

00:28:14,130 --> 00:28:18,390
and if you can deal with a few more

00:28:16,830 --> 00:28:21,090
collisions and you're writing in Python

00:28:18,390 --> 00:28:22,760
then you can just use crc32 because you

00:28:21,090 --> 00:28:24,810
should also respect the standard library

00:28:22,760 --> 00:28:26,430
Python only provides two non

00:28:24,810 --> 00:28:29,160
cryptographic hashing functions and

00:28:26,430 --> 00:28:33,210
they're both out of z lib Adler 32 and

00:28:29,160 --> 00:28:34,500
crc32 if you don't need the closest

00:28:33,210 --> 00:28:37,610
thing to perfect hashing in the world

00:28:34,500 --> 00:28:40,440
you just need good enough hashing then

00:28:37,610 --> 00:28:41,880
crc32 is there for free you don't have

00:28:40,440 --> 00:28:45,150
to do a thing all you have to do is

00:28:41,880 --> 00:28:49,310
import deadly thank you very much I

00:28:45,150 --> 00:28:49,310
believe I have it up 10 seconds

00:28:54,880 --> 00:28:59,300
I'm having to take very rapid questions

00:28:57,740 --> 00:29:07,910
which will get very rapid answers most

00:28:59,300 --> 00:29:10,270
of which involving me not knowing yo how

00:29:07,910 --> 00:29:12,440
they come across Jenkins hash I'm sorry

00:29:10,270 --> 00:29:14,090
have I come across Jenkins hash I know

00:29:12,440 --> 00:29:17,120
the name I haven't looked into it in any

00:29:14,090 --> 00:29:18,530
detail I I have looked into a number of

00:29:17,120 --> 00:29:19,880
hashes beyond what was in this this

00:29:18,530 --> 00:29:29,140
presentation but not that one

00:29:19,880 --> 00:29:32,630
specifically I'm sorry yep sorry alia is

00:29:29,140 --> 00:29:34,430
no that one doesn't ring a bell there

00:29:32,630 --> 00:29:35,720
are I will just note actually there are

00:29:34,430 --> 00:29:37,130
a lot out there's like a cottage

00:29:35,720 --> 00:29:38,840
industry of people and for some reason

00:29:37,130 --> 00:29:40,910
saan google code instead of github

00:29:38,840 --> 00:29:42,230
there's like a cottage industry of

00:29:40,910 --> 00:29:43,370
people out there who just as a hobby

00:29:42,230 --> 00:29:44,750
come up with new written on

00:29:43,370 --> 00:29:45,770
cryptographic hashes which is great

00:29:44,750 --> 00:29:48,140
because you get some really good ones

00:29:45,770 --> 00:29:50,450
out of it you do also get some less good

00:29:48,140 --> 00:29:54,200
ones out of it sorry superfast hash yeah

00:29:50,450 --> 00:29:57,860
hi so when you don't put a hashes that

00:29:54,200 --> 00:30:00,170
are for set existence so I think were

00:29:57,860 --> 00:30:01,970
you referring to the bloom filter yeah

00:30:00,170 --> 00:30:03,380
yeah so that that's that's a really good

00:30:01,970 --> 00:30:05,720
example of somewhere with this is really

00:30:03,380 --> 00:30:08,210
useful so bloom filters for people who

00:30:05,720 --> 00:30:10,640
aren't aware of them basically are a

00:30:08,210 --> 00:30:12,170
very good way of compacting a set of

00:30:10,640 --> 00:30:13,670
data down to look for basically

00:30:12,170 --> 00:30:15,050
positives as long as you accept that

00:30:13,670 --> 00:30:17,300
there will be a certain false positive

00:30:15,050 --> 00:30:18,920
rate if I tie the false positives false

00:30:17,300 --> 00:30:22,160
negatives I'm hoping you can tell me

00:30:18,920 --> 00:30:23,450
which one so yes this is this is one

00:30:22,160 --> 00:30:24,680
area where they're very useful because

00:30:23,450 --> 00:30:26,360
this didn't crunch down the amount of

00:30:24,680 --> 00:30:27,710
data you actually have to put into your

00:30:26,360 --> 00:30:30,260
bloom filter and therefore carry around

00:30:27,710 --> 00:30:32,090
yeah so it doesn't give any false

00:30:30,260 --> 00:30:34,340
negatives it only gives for that yeah

00:30:32,090 --> 00:30:36,530
that's yeah yeah and the thing is sisted

00:30:34,340 --> 00:30:40,670
basically in your experience have you

00:30:36,530 --> 00:30:42,740
bit so bloom filters are fine because I

00:30:40,670 --> 00:30:45,230
think that from a collection containing

00:30:42,740 --> 00:30:48,440
millions of items 10 million items so

00:30:45,230 --> 00:30:51,170
your computer bloom filters around 120

00:30:48,440 --> 00:30:52,520
130 kb which is we have nothing because

00:30:51,170 --> 00:30:54,710
if you store all of the pointers that

00:30:52,520 --> 00:30:58,760
would still like go into the hundreds of

00:30:54,710 --> 00:31:03,020
MBS maybe so the thing is this that we

00:30:58,760 --> 00:31:04,900
have have you seen any because if if you

00:31:03,020 --> 00:31:06,830
were to implement this for a list of

00:31:04,900 --> 00:31:07,250
containers containing a lot of

00:31:06,830 --> 00:31:10,520
collection

00:31:07,250 --> 00:31:14,120
then other than suspending everything

00:31:10,520 --> 00:31:16,790
inside memory I'm I'm not really sure

00:31:14,120 --> 00:31:19,550
about how to do it is there any open

00:31:16,790 --> 00:31:22,220
cool solution that there probably is

00:31:19,550 --> 00:31:24,110
unaware of in quieten you can certainly

00:31:22,220 --> 00:31:26,480
the beauty of bloom filters is you can

00:31:24,110 --> 00:31:27,770
pre-compute your filter so I mean this

00:31:26,480 --> 00:31:30,470
is something that you would do before

00:31:27,770 --> 00:31:32,540
you ship your software basically like

00:31:30,470 --> 00:31:35,210
maybe I'm misunderstanding the question

00:31:32,540 --> 00:31:39,110
yeah so my question is is that I work at

00:31:35,210 --> 00:31:42,020
I have a start-up and we've got a lot of

00:31:39,110 --> 00:31:44,060
songs right yep so we've got a lot of

00:31:42,020 --> 00:31:45,920
songs and if we scale up to Spotify

00:31:44,060 --> 00:31:48,680
proportions or something like that we

00:31:45,920 --> 00:31:50,600
might have a million songs right then we

00:31:48,680 --> 00:31:52,520
have a lot of different users so if you

00:31:50,600 --> 00:31:54,950
have a million users in a million songs

00:31:52,520 --> 00:31:59,480
the bloom filter that would have to be

00:31:54,950 --> 00:32:02,840
attached to each song would be 130 kb

00:31:59,480 --> 00:32:05,230
jake and multiplying that by a hundred

00:32:02,840 --> 00:32:07,970
and suspending that in ram might be

00:32:05,230 --> 00:32:09,260
little expensive yeah i mean that might

00:32:07,970 --> 00:32:10,400
be one way you can use a completely

00:32:09,260 --> 00:32:11,720
different technique like audio

00:32:10,400 --> 00:32:13,730
fingerprinting or something like that

00:32:11,720 --> 00:32:15,350
and then use those to generate your

00:32:13,730 --> 00:32:19,730
bloom filter so have an additional

00:32:15,350 --> 00:32:21,410
processing step on the way in I think we

00:32:19,730 --> 00:32:22,730
are pretty solidly out of time because

00:32:21,410 --> 00:32:24,920
we've got lightning talks in like five

00:32:22,730 --> 00:32:27,130
minutes so thank you very much then

00:32:24,920 --> 00:32:27,130
great

00:32:36,150 --> 00:32:38,210

YouTube URL: https://www.youtube.com/watch?v=IdVX4qHJXEY


