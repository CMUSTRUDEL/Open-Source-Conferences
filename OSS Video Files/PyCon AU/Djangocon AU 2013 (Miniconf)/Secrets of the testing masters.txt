Title: Secrets of the testing masters
Publication date: 2013-07-12
Playlist: Djangocon AU 2013 (Miniconf)
Description: 
	Russell Keith-Magee
http://2013.pycon-au.org/schedule/30034/view_talk
Django ship with a wide range of tools to help you test your web application, but some of the best tools for testing Django don't come in the box.

In this talk, you'll get a brief introduction to two of those tools - Mock and Factory Boy - showing when they should be used, and some practical examples of their usage in a Django test suite.

PyCon Australia is the national conference for users of the Python Programming Langu
Captions: 
	00:00:03,080 --> 00:00:07,319
so Russell's probably no stranger to

00:00:05,310 --> 00:00:08,550
most people he's a seven year veteran of

00:00:07,319 --> 00:00:09,900
the Django core team and he's the

00:00:08,550 --> 00:00:11,940
president of the Django software

00:00:09,900 --> 00:00:13,980
foundation he's going to talk to us

00:00:11,940 --> 00:00:22,619
today about testing secrets of the

00:00:13,980 --> 00:00:25,949
testing masters give it up hi so yes

00:00:22,619 --> 00:00:30,240
thanks very much as introduced I'm a

00:00:25,949 --> 00:00:32,160
member of the core team and a prisoner

00:00:30,240 --> 00:00:34,559
the Django software foundation my day

00:00:32,160 --> 00:00:36,570
job is as a CTO and co-founder of trades

00:00:34,559 --> 00:00:39,149
cloud where a software-as-a-service

00:00:36,570 --> 00:00:40,649
cloud provider for services to trades

00:00:39,149 --> 00:00:43,290
people so plumbers electricians as those

00:00:40,649 --> 00:00:44,820
sort of people if you're interested in

00:00:43,290 --> 00:00:46,260
migrating to Perth we likely to be

00:00:44,820 --> 00:00:48,210
hiring soon or if you're already input

00:00:46,260 --> 00:00:51,120
so come and talk to me if you if you add

00:00:48,210 --> 00:00:52,469
a loose end and need something to do so

00:00:51,120 --> 00:00:53,850
like I said that's this my day job I'm

00:00:52,469 --> 00:00:56,460
here because of my involving with the

00:00:53,850 --> 00:00:58,770
Django project and in particular I'm

00:00:56,460 --> 00:00:59,969
here to talk about testing now hopefully

00:00:58,770 --> 00:01:02,010
by this point I don't need to convince

00:00:59,969 --> 00:01:03,480
anyone in the room that testing is good

00:01:02,010 --> 00:01:04,880
and we should all be doing it and we

00:01:03,480 --> 00:01:07,020
should all be doing it a lot more

00:01:04,880 --> 00:01:08,880
personally I got bitten by the testing

00:01:07,020 --> 00:01:10,979
testing bugged my first job out of uni

00:01:08,880 --> 00:01:12,659
interestingly my university degree

00:01:10,979 --> 00:01:16,830
taught me nothing about testing and then

00:01:12,659 --> 00:01:20,759
I got thrown headlong into a job where

00:01:16,830 --> 00:01:22,830
my first job was to write tests one of

00:01:20,759 --> 00:01:24,450
my first really big contributions to

00:01:22,830 --> 00:01:26,220
django was actually adding a user facing

00:01:24,450 --> 00:01:27,509
testing suite capability to django so

00:01:26,220 --> 00:01:29,369
the fact that you can write your own

00:01:27,509 --> 00:01:31,619
unit tests and have django run them is

00:01:29,369 --> 00:01:33,270
something that i added in like 2006

00:01:31,619 --> 00:01:34,770
probably previous to that jangar had a

00:01:33,270 --> 00:01:36,600
test to it and a really good test suite

00:01:34,770 --> 00:01:37,799
but it was only for internal used to

00:01:36,600 --> 00:01:40,590
make sure django was working not for

00:01:37,799 --> 00:01:42,420
other people since then lots of people

00:01:40,590 --> 00:01:43,740
have contributed pieces to the django

00:01:42,420 --> 00:01:45,420
test week new features have been added

00:01:43,740 --> 00:01:48,450
to the django test suite most notably

00:01:45,420 --> 00:01:50,520
1.6 the discover test runner but django

00:01:48,450 --> 00:01:52,680
doesn't contain everything out of the

00:01:50,520 --> 00:01:54,990
box there are lots of very interesting

00:01:52,680 --> 00:01:56,520
testing tools that aren't part of

00:01:54,990 --> 00:01:58,530
testing core and probably shouldn't be

00:01:56,520 --> 00:02:00,600
part of testing core but as a result of

00:01:58,530 --> 00:02:02,579
that they don't always get the attention

00:02:00,600 --> 00:02:03,810
that I think they deserve and that's

00:02:02,579 --> 00:02:06,060
true of many many things outside of

00:02:03,810 --> 00:02:08,069
django school so what I'm hoping to do

00:02:06,060 --> 00:02:10,080
today is to give you a lightning

00:02:08,069 --> 00:02:12,209
introduction to two testing tools that

00:02:10,080 --> 00:02:13,890
aren't in the box but that I've come

00:02:12,209 --> 00:02:15,960
across and found to be extraordinary

00:02:13,890 --> 00:02:19,530
useful when writing writing good system

00:02:15,960 --> 00:02:20,550
tests or good unit tests now solutions

00:02:19,530 --> 00:02:22,290
are only good when you actually have

00:02:20,550 --> 00:02:23,880
problems so I'm going to tackle this by

00:02:22,290 --> 00:02:25,020
looking at some actual to actual

00:02:23,880 --> 00:02:28,890
real-world problems that you'll likely

00:02:25,020 --> 00:02:30,420
to have when writing tests and and so

00:02:28,890 --> 00:02:33,030
reverse engineer the problem from there

00:02:30,420 --> 00:02:34,230
so first off really common problem you

00:02:33,030 --> 00:02:35,610
have a test that means you need test

00:02:34,230 --> 00:02:37,440
data you need to better populate your

00:02:35,610 --> 00:02:39,330
database with something meaningful so

00:02:37,440 --> 00:02:41,100
that you can check a complex filter

00:02:39,330 --> 00:02:42,390
condition or check that some method

00:02:41,100 --> 00:02:44,790
operates the expected way when

00:02:42,390 --> 00:02:46,770
particular sets of data are available to

00:02:44,790 --> 00:02:50,640
you and as great because django provides

00:02:46,770 --> 00:02:52,230
a fixtures framework problem solved so

00:02:50,640 --> 00:02:54,480
how does that work in practice well

00:02:52,230 --> 00:02:57,000
you've got yourself a test case which is

00:02:54,480 --> 00:02:59,910
your class you declare that you're going

00:02:57,000 --> 00:03:01,470
to use the test users fixture and then

00:02:59,910 --> 00:03:02,730
in your actual test you write a series

00:03:01,470 --> 00:03:04,350
of calls on your database to retrieve

00:03:02,730 --> 00:03:07,769
those particular objects from the

00:03:04,350 --> 00:03:09,300
database okay that's not too ugly the

00:03:07,769 --> 00:03:11,340
bit where it gets ugly is then you have

00:03:09,300 --> 00:03:13,019
your fixtures themselves now okay this

00:03:11,340 --> 00:03:16,709
is the single this is a fixture for a

00:03:13,019 --> 00:03:18,660
single user object the fixture for the

00:03:16,709 --> 00:03:19,860
previous example used to user objects so

00:03:18,660 --> 00:03:23,220
the actual fixture would need to be

00:03:19,860 --> 00:03:27,709
twice that length 18 lines of code 12 of

00:03:23,220 --> 00:03:30,630
which are relating to the required data

00:03:27,709 --> 00:03:32,010
they're very easy to create you can dump

00:03:30,630 --> 00:03:33,420
them out of a live database Django

00:03:32,010 --> 00:03:36,120
serialization framework will dump that

00:03:33,420 --> 00:03:38,280
Jason straight out but the signal gets

00:03:36,120 --> 00:03:39,690
lost in the noise in that user model

00:03:38,280 --> 00:03:42,180
like I said you've got Django's default

00:03:39,690 --> 00:03:43,860
user model has 12 required fields that

00:03:42,180 --> 00:03:47,130
you need to fill in just to create a

00:03:43,860 --> 00:03:48,570
user at all the fixture is then 18 lines

00:03:47,130 --> 00:03:49,470
of Jason because of the metadata is

00:03:48,570 --> 00:03:52,260
required to tell you that you're

00:03:49,470 --> 00:03:53,940
actually creating a user and from a

00:03:52,260 --> 00:03:57,420
readability point of view there's almost

00:03:53,940 --> 00:03:58,980
no data in there if for example you were

00:03:57,420 --> 00:04:00,450
setting up users for the purposes of a

00:03:58,980 --> 00:04:02,640
test it's likely that you just need to

00:04:00,450 --> 00:04:04,860
have our user so that you can test that

00:04:02,640 --> 00:04:06,269
my blog entry is owned by someone but

00:04:04,860 --> 00:04:08,850
blog entry has to have an owner I need a

00:04:06,269 --> 00:04:10,920
user make me a user so you've got 18

00:04:08,850 --> 00:04:12,980
lines of boilerplate to make sure that

00:04:10,920 --> 00:04:15,420
you've got a user of some property

00:04:12,980 --> 00:04:17,039
another likely use case let's say you've

00:04:15,420 --> 00:04:18,870
got you want to test that super users

00:04:17,039 --> 00:04:20,669
can do a particular thing in which case

00:04:18,870 --> 00:04:22,169
one line out of that 18 lines is

00:04:20,669 --> 00:04:26,010
actually significant from the point of

00:04:22,169 --> 00:04:27,180
view of your test okay so that's fine

00:04:26,010 --> 00:04:27,690
that means we've got a lot of extra

00:04:27,180 --> 00:04:30,360
noise in the

00:04:27,690 --> 00:04:32,400
yeah you then make a modification to

00:04:30,360 --> 00:04:34,620
your models you you migrate using a your

00:04:32,400 --> 00:04:36,330
own custom user model in Django 1.5 or

00:04:34,620 --> 00:04:38,460
you've got your blog model of a sudden

00:04:36,330 --> 00:04:39,900
requires a date stamp an extra day stand

00:04:38,460 --> 00:04:40,800
to say when it was edited that means

00:04:39,900 --> 00:04:42,840
you've got to go through and make

00:04:40,800 --> 00:04:45,360
modifications to all of your fixtures

00:04:42,840 --> 00:04:47,280
and essentially that means doing it

00:04:45,360 --> 00:04:49,620
manually you know you can there isn't a

00:04:47,280 --> 00:04:52,320
dash dash ignore non-existent option on

00:04:49,620 --> 00:04:53,970
load data so if you remove the field

00:04:52,320 --> 00:04:55,410
you're all you've got a little bit of

00:04:53,970 --> 00:04:57,570
help there but you can't use that in

00:04:55,410 --> 00:04:59,610
testing so you'd have to manually load

00:04:57,570 --> 00:05:02,160
your fixture with loaded with ignore

00:04:59,610 --> 00:05:03,750
non-existent and then dump it again or

00:05:02,160 --> 00:05:06,330
you've got to go write yourself an ad

00:05:03,750 --> 00:05:07,380
hoc you know regex script or something

00:05:06,330 --> 00:05:09,000
on a said script to go through and

00:05:07,380 --> 00:05:11,400
modify all of your fixtures and add the

00:05:09,000 --> 00:05:13,620
extra fuel that you want in there so

00:05:11,400 --> 00:05:16,230
yeah it's a little bit messy and there's

00:05:13,620 --> 00:05:18,720
also primary key issue your your fixture

00:05:16,230 --> 00:05:21,630
you can you reference other objects

00:05:18,720 --> 00:05:24,380
using primary key values so if you've

00:05:21,630 --> 00:05:28,890
got this whole fixture you need to know

00:05:24,380 --> 00:05:30,690
somehow that user 23 is your test staff

00:05:28,890 --> 00:05:34,260
user who hasn't created any additional

00:05:30,690 --> 00:05:35,970
content and that metadata can't be in

00:05:34,260 --> 00:05:37,110
your Jason fixture itself because Jason

00:05:35,970 --> 00:05:39,240
won't allow you to have comments in a

00:05:37,110 --> 00:05:40,800
fixture so you've got to have some

00:05:39,240 --> 00:05:42,270
external documentation that people can

00:05:40,800 --> 00:05:45,360
refer to to make sure that your fixtures

00:05:42,270 --> 00:05:46,950
or remain insync that's made a little

00:05:45,360 --> 00:05:48,330
bit better with natural keys but even

00:05:46,950 --> 00:05:49,860
still some data models don't lend

00:05:48,330 --> 00:05:52,500
themselves to having good natural keys

00:05:49,860 --> 00:05:53,820
and there's only so much useful in

00:05:52,500 --> 00:05:57,450
metadata you can embed it in a natural

00:05:53,820 --> 00:05:59,250
key so okay fixtures aren't great for

00:05:57,450 --> 00:06:01,560
testing what other options exist well

00:05:59,250 --> 00:06:02,640
I'd like to introduce you to was if you

00:06:01,560 --> 00:06:05,669
don't know about it introduced you to

00:06:02,640 --> 00:06:07,410
factory boy factory boy is a declarative

00:06:05,669 --> 00:06:09,890
language for describing the construction

00:06:07,410 --> 00:06:12,600
of test objects in your unit tests in

00:06:09,890 --> 00:06:15,570
practice what does it look like like

00:06:12,600 --> 00:06:16,950
that you say I've got my test case and

00:06:15,570 --> 00:06:19,169
the two lines that you need to say is

00:06:16,950 --> 00:06:21,390
creating a user and create new user who

00:06:19,169 --> 00:06:23,610
is a staff member so you're down to

00:06:21,390 --> 00:06:26,010
basically saying I just need a test

00:06:23,610 --> 00:06:27,810
object make it please and I need a test

00:06:26,010 --> 00:06:29,790
object that has this specific property

00:06:27,810 --> 00:06:32,910
make it please it's being done

00:06:29,790 --> 00:06:34,200
essentially programmatically so that

00:06:32,910 --> 00:06:36,479
when you call that user if it is

00:06:34,200 --> 00:06:37,680
actually going in creating a user object

00:06:36,479 --> 00:06:38,880
on your database live which is

00:06:37,680 --> 00:06:40,320
essentially all that fixtures are doing

00:06:38,880 --> 00:06:41,320
anyway they're just doing it from a data

00:06:40,320 --> 00:06:46,120
source

00:06:41,320 --> 00:06:48,250
state you do however need to set up that

00:06:46,120 --> 00:06:49,990
user f object that user f is a is a

00:06:48,250 --> 00:06:53,380
factory object for users and how do you

00:06:49,990 --> 00:06:56,500
define that well it's a user user f is a

00:06:53,380 --> 00:06:58,480
factory class instance and you say okay

00:06:56,500 --> 00:07:00,040
it's a factory for you'll use a model

00:06:58,480 --> 00:07:01,870
and you then going declare all the

00:07:00,040 --> 00:07:03,790
fields that you that user model has now

00:07:01,870 --> 00:07:05,590
okay yes there are you do need to list

00:07:03,790 --> 00:07:07,060
every single field in your user model

00:07:05,590 --> 00:07:08,710
I've trimmed this short here so you can

00:07:07,060 --> 00:07:10,420
read it but you do need to have first

00:07:08,710 --> 00:07:14,980
name last name his stuff is adding in

00:07:10,420 --> 00:07:16,690
last logged in etc etc so you do still

00:07:14,980 --> 00:07:18,070
have to list all 12 fields there the

00:07:16,690 --> 00:07:20,350
thing is you only need to list them once

00:07:18,070 --> 00:07:22,210
you don't need it for every fixture what

00:07:20,350 --> 00:07:24,730
youre declaring is when i create a user

00:07:22,210 --> 00:07:26,200
by default it fill in the first name is

00:07:24,730 --> 00:07:29,260
John the last name is doe there is stuff

00:07:26,200 --> 00:07:31,480
is false and when you then say okay I

00:07:29,260 --> 00:07:34,150
want to run this particular fixture you

00:07:31,480 --> 00:07:35,680
can override any of those fields for

00:07:34,150 --> 00:07:38,950
this particular fixture object that's

00:07:35,680 --> 00:07:40,270
been created okay so some of you are

00:07:38,950 --> 00:07:42,130
probably at this point saying so what

00:07:40,270 --> 00:07:45,100
you could achieve all this by just

00:07:42,130 --> 00:07:47,500
writing a user space method called

00:07:45,100 --> 00:07:49,360
create test user and okay pass in the

00:07:47,500 --> 00:07:50,860
arguments to say is stuff we need to be

00:07:49,360 --> 00:07:52,600
able to control his stuff so put that in

00:07:50,860 --> 00:07:55,000
as an argument of the function that's

00:07:52,600 --> 00:07:56,290
all true you could do that but there are

00:07:55,000 --> 00:07:59,650
some other interesting little tricks

00:07:56,290 --> 00:08:02,110
that factory boy can do factory boy has

00:07:59,650 --> 00:08:04,960
a collection of helper fields to make it

00:08:02,110 --> 00:08:06,490
easier to create dynamic data so for the

00:08:04,960 --> 00:08:09,760
first officer thing called a sequence

00:08:06,490 --> 00:08:12,100
field so here is the same user factory

00:08:09,760 --> 00:08:14,350
that we've we've defined here every

00:08:12,100 --> 00:08:17,290
object created with the factory will get

00:08:14,350 --> 00:08:19,930
you a unique value for n that's passed

00:08:17,290 --> 00:08:21,970
into the function in sequence so and

00:08:19,930 --> 00:08:23,260
then you can use that n to populate your

00:08:21,970 --> 00:08:24,850
data so in this case what we're saying

00:08:23,260 --> 00:08:26,590
is first name and last name of fixed is

00:08:24,850 --> 00:08:28,210
staff is always set to forward is by

00:08:26,590 --> 00:08:30,910
default set to false but the email

00:08:28,210 --> 00:08:33,969
address every user that you instantiate

00:08:30,910 --> 00:08:39,219
with user F will get a unique email

00:08:33,969 --> 00:08:42,219
address user number at example com so in

00:08:39,219 --> 00:08:44,770
code user 0 instantiate user F his first

00:08:42,219 --> 00:08:46,750
name is John user 0 dot email is user 0

00:08:44,770 --> 00:08:48,940
to example.com you run the same thing

00:08:46,750 --> 00:08:50,920
again the second user you create still

00:08:48,940 --> 00:08:53,320
has John as a user name but the email

00:08:50,920 --> 00:08:54,880
addresses user one at example com ok so

00:08:53,320 --> 00:08:55,089
this enables you to go and create you

00:08:54,880 --> 00:08:57,730
know

00:08:55,089 --> 00:09:01,720
unique data on a completely programmatic

00:08:57,730 --> 00:09:04,899
basis another little trick is lazy

00:09:01,720 --> 00:09:06,519
attribute values in lazy attributes are

00:09:04,899 --> 00:09:08,740
computed late in the process so

00:09:06,519 --> 00:09:10,540
instantiates all of your initial data

00:09:08,740 --> 00:09:12,939
that's been preset first name last name

00:09:10,540 --> 00:09:15,069
is staff but then it will evaluate lazy

00:09:12,939 --> 00:09:16,569
attribute to fill it in a fill in that

00:09:15,069 --> 00:09:18,730
attribute with data that's come from

00:09:16,569 --> 00:09:20,230
other fields so in this case our email

00:09:18,730 --> 00:09:22,480
address is going to be composed out of

00:09:20,230 --> 00:09:24,999
first name dot last name at example.com

00:09:22,480 --> 00:09:27,129
so you can say that way you reliably

00:09:24,999 --> 00:09:28,540
know my user is always going to have an

00:09:27,129 --> 00:09:32,139
email address that relates to the user

00:09:28,540 --> 00:09:34,540
that you've created in code we say okay

00:09:32,139 --> 00:09:36,189
user first user gets created first name

00:09:34,540 --> 00:09:38,379
is John the default email address is

00:09:36,189 --> 00:09:40,149
created is John Doe at example.com

00:09:38,379 --> 00:09:43,300
coming straight from the definition of

00:09:40,149 --> 00:09:44,920
user F but we create user one what we're

00:09:43,300 --> 00:09:46,180
going to say is this user oui oui for

00:09:44,920 --> 00:09:47,589
testing reasons we need to check a

00:09:46,180 --> 00:09:50,230
different name so we're going to pass in

00:09:47,589 --> 00:09:51,939
a first name of Frank and as a result of

00:09:50,230 --> 00:09:54,189
that user one got first name is Frank

00:09:51,939 --> 00:09:59,230
and his email address is Frank dough at

00:09:54,189 --> 00:10:01,600
example.com another party trick you can

00:09:59,230 --> 00:10:03,579
define scaffolding as part of your data

00:10:01,600 --> 00:10:05,259
requirements so let's move away from our

00:10:03,579 --> 00:10:07,240
user model here and start talking about

00:10:05,259 --> 00:10:11,589
a block we want to test blog entries

00:10:07,240 --> 00:10:14,220
every blog needs to have an author so is

00:10:11,589 --> 00:10:16,629
going to be an instance of user the

00:10:14,220 --> 00:10:18,490
title of the blog is going to be set by

00:10:16,629 --> 00:10:19,660
default to my blog entry the body of the

00:10:18,490 --> 00:10:21,879
blog is going to be set to this is the

00:10:19,660 --> 00:10:23,769
content every time and the author is a

00:10:21,879 --> 00:10:27,850
sub factory instantiate it as an

00:10:23,769 --> 00:10:30,309
instance of user so every time you

00:10:27,850 --> 00:10:33,100
instantiate blog entry factory you're

00:10:30,309 --> 00:10:35,709
going to get a title which is taken from

00:10:33,100 --> 00:10:37,509
the default value and an author which is

00:10:35,709 --> 00:10:38,949
instantiated every time you create a

00:10:37,509 --> 00:10:41,230
blog entry and every blog will end up

00:10:38,949 --> 00:10:44,410
with its own unique author so out we

00:10:41,230 --> 00:10:47,110
create our second the entry zeros author

00:10:44,410 --> 00:10:48,850
has a primary key of one entry one has a

00:10:47,110 --> 00:10:50,679
prime as a primary key of two so that

00:10:48,850 --> 00:10:52,089
you see the primary you author objects

00:10:50,679 --> 00:11:00,160
have been created automatically behind

00:10:52,089 --> 00:11:01,839
the scenes ooh how it's ok so if you

00:11:00,160 --> 00:11:04,179
don't want to create an author every

00:11:01,839 --> 00:11:05,679
single time you can override the author

00:11:04,179 --> 00:11:07,209
object that's being used in a particular

00:11:05,679 --> 00:11:08,470
instance so ok let's go and instantiate

00:11:07,209 --> 00:11:11,050
ourselves a new you

00:11:08,470 --> 00:11:12,550
object and provide that user as the

00:11:11,050 --> 00:11:14,650
argument to blog factory so you can then

00:11:12,550 --> 00:11:16,390
say okay no I don't want a different

00:11:14,650 --> 00:11:18,400
user for every blog entry I create I

00:11:16,390 --> 00:11:20,130
want to have one user and then create a

00:11:18,400 --> 00:11:22,360
series of blog entries with that user

00:11:20,130 --> 00:11:23,380
just pass it in as author equals user

00:11:22,360 --> 00:11:25,750
one the user that we've created

00:11:23,380 --> 00:11:29,170
previously and all the rest cascades

00:11:25,750 --> 00:11:30,850
through and you can also do sort of

00:11:29,170 --> 00:11:33,190
traverse joins in your factory process

00:11:30,850 --> 00:11:35,830
as well so here blog entry has an author

00:11:33,190 --> 00:11:38,590
I do want to create a unique author but

00:11:35,830 --> 00:11:40,630
I just want to say that create a blog

00:11:38,590 --> 00:11:43,690
with an author whose first name is Frank

00:11:40,630 --> 00:11:45,850
used Django style double under syntax

00:11:43,690 --> 00:11:47,620
you can instantiate and pass that I want

00:11:45,850 --> 00:11:52,180
this thing to be frank in as part of

00:11:47,620 --> 00:11:53,680
your instantiation there some other

00:11:52,180 --> 00:11:56,320
nifty features that exist there the

00:11:53,680 --> 00:11:57,760
default behavior in factory boy is to

00:11:56,320 --> 00:12:00,640
create a new instance that actually

00:11:57,760 --> 00:12:02,950
writes to the database if you just want

00:12:00,640 --> 00:12:06,040
to check values however or if you want

00:12:02,950 --> 00:12:07,480
to speed up the process so you're you

00:12:06,040 --> 00:12:09,280
don't want to hit the database to make

00:12:07,480 --> 00:12:11,590
your testing process a little bit faster

00:12:09,280 --> 00:12:14,320
you can just instantiate the object so

00:12:11,590 --> 00:12:16,420
if you say user f dot build it will

00:12:14,320 --> 00:12:17,770
fully instantiate an object with all the

00:12:16,420 --> 00:12:20,020
default values that have come from the

00:12:17,770 --> 00:12:21,790
factory but once save it to the database

00:12:20,020 --> 00:12:23,770
and then you can use that as a fully

00:12:21,790 --> 00:12:25,900
fledged user objects that you can test

00:12:23,770 --> 00:12:27,340
test functions test at repair test

00:12:25,900 --> 00:12:30,040
methods on the on the user object or

00:12:27,340 --> 00:12:32,380
anything that users user object you can

00:12:30,040 --> 00:12:34,300
also say attributes a set of user

00:12:32,380 --> 00:12:36,990
function or factory dot attributes that

00:12:34,300 --> 00:12:39,430
will give you back a dictionary of the

00:12:36,990 --> 00:12:41,740
default values that would be used to

00:12:39,430 --> 00:12:43,900
instantiate the next object which you

00:12:41,740 --> 00:12:45,700
can then mutate and modify as necessary

00:12:43,900 --> 00:12:47,530
and pass into an actual factory to

00:12:45,700 --> 00:12:49,570
instantiate one so that's you know if

00:12:47,530 --> 00:12:51,370
you want to tweak around with or do

00:12:49,570 --> 00:12:53,740
slightly more complex manipulations of

00:12:51,370 --> 00:12:57,460
the values in your in your factory you

00:12:53,740 --> 00:13:00,070
can do that and lastly you can override

00:12:57,460 --> 00:13:02,440
the internal create method so user f

00:13:00,070 --> 00:13:04,690
just instantiate in user f brackets will

00:13:02,440 --> 00:13:05,950
create an instance of user it does that

00:13:04,690 --> 00:13:08,440
actually by calling a method called

00:13:05,950 --> 00:13:11,680
create so if you want to do some fancy

00:13:08,440 --> 00:13:13,300
pre pre pre modification or post

00:13:11,680 --> 00:13:17,260
modification of the user objects that

00:13:13,300 --> 00:13:18,610
are going on you can do that so the good

00:13:17,260 --> 00:13:21,070
example here if you were setting up a

00:13:18,610 --> 00:13:22,329
your user object the value of the

00:13:21,070 --> 00:13:24,989
password field

00:13:22,329 --> 00:13:27,699
needs to be your shower hash or whatever

00:13:24,989 --> 00:13:31,629
you want to be ought to say pass in user

00:13:27,699 --> 00:13:32,769
F password equals my password but you

00:13:31,629 --> 00:13:35,139
want the database to actually reflect

00:13:32,769 --> 00:13:37,329
that as char one dollar what you know

00:13:35,139 --> 00:13:39,699
salt dollar whatever the internal

00:13:37,329 --> 00:13:42,519
structure so you can override the create

00:13:39,699 --> 00:13:43,989
method to take the keyword arguments to

00:13:42,519 --> 00:13:48,429
find the password that's been passed in

00:13:43,989 --> 00:13:50,199
convert it and then call super or create

00:13:48,429 --> 00:13:51,879
to actually push that into the object so

00:13:50,199 --> 00:13:53,980
you're mutating the the value that

00:13:51,879 --> 00:13:55,629
you're providing to the to the factory

00:13:53,980 --> 00:13:59,679
function gets mutated before it actually

00:13:55,629 --> 00:14:02,350
gets used another example every say you

00:13:59,679 --> 00:14:04,989
want to your testing your sections for

00:14:02,350 --> 00:14:06,519
your blog every every every blog entry

00:14:04,989 --> 00:14:08,019
is inside a section but if you're

00:14:06,519 --> 00:14:09,489
testing sections you want every section

00:14:08,019 --> 00:14:10,809
to have multiple blog entries just so

00:14:09,489 --> 00:14:12,220
you don't have no you don't end up with

00:14:10,809 --> 00:14:13,660
a whole stack of empty sections or have

00:14:12,220 --> 00:14:15,850
to go through the the boilerplate

00:14:13,660 --> 00:14:17,619
process of setting up those blogs so you

00:14:15,850 --> 00:14:20,019
can override the create process the OPA

00:14:17,619 --> 00:14:22,059
create method on section to say ok call

00:14:20,019 --> 00:14:24,040
super create the section and then create

00:14:22,059 --> 00:14:25,629
three blog entries so that every time

00:14:24,040 --> 00:14:27,879
you instantiate in your test set up a

00:14:25,629 --> 00:14:30,959
section you're going to get three blog

00:14:27,879 --> 00:14:30,959
entries that belong to that section

00:14:32,999 --> 00:14:37,119
factory boy is actually not just for

00:14:34,929 --> 00:14:40,110
Django it also supports sequel alchemy

00:14:37,119 --> 00:14:42,879
and mogo which is a MongoDB ORM wrapper

00:14:40,110 --> 00:14:44,230
so if you if you're using other other

00:14:42,879 --> 00:14:48,309
tools other frameworks you actually can

00:14:44,230 --> 00:14:49,389
continue to use factory boy getting it

00:14:48,309 --> 00:14:51,069
is essentially just a matter of pip

00:14:49,389 --> 00:14:52,720
install factory boy there is actually

00:14:51,069 --> 00:14:54,730
also a sort of a companion package

00:14:52,720 --> 00:14:57,519
called Jango factory boy which is the

00:14:54,730 --> 00:15:01,419
extensions to factory boy defining the

00:14:57,519 --> 00:15:02,679
user f exact is essentially for for

00:15:01,419 --> 00:15:04,329
Django model so the user model

00:15:02,679 --> 00:15:06,160
permissions model content type models

00:15:04,329 --> 00:15:07,419
mocked up already for you because they

00:15:06,160 --> 00:15:09,069
are known quantities and you don't have

00:15:07,419 --> 00:15:12,549
to define them again yourself so there

00:15:09,069 --> 00:15:16,749
there there and usable as a as libraries

00:15:12,549 --> 00:15:17,949
that you can bring into your own apps ok

00:15:16,749 --> 00:15:19,929
so that's factory boy let's have a look

00:15:17,949 --> 00:15:22,660
at another common testing problem you're

00:15:19,929 --> 00:15:25,329
dependent upon an external service it

00:15:22,660 --> 00:15:27,850
might be an API that's providing some

00:15:25,329 --> 00:15:29,470
data or authentication or credit card

00:15:27,850 --> 00:15:31,360
processing or whatever it doesn't really

00:15:29,470 --> 00:15:33,009
matter if you have to call an outside

00:15:31,360 --> 00:15:35,059
service that's going to affect your

00:15:33,009 --> 00:15:36,469
ability to test

00:15:35,059 --> 00:15:38,479
to actually directly run your test suite

00:15:36,469 --> 00:15:40,369
it could affect your repeatability if

00:15:38,479 --> 00:15:42,559
the external service your external

00:15:40,369 --> 00:15:44,689
service has an API that goes down or

00:15:42,559 --> 00:15:46,009
it's goes into maintenance mode you all

00:15:44,689 --> 00:15:48,709
of a sudden can't run your test suite

00:15:46,009 --> 00:15:50,479
okay that may not be a huge problem but

00:15:48,709 --> 00:15:51,679
at murphy's law dictates that that that

00:15:50,479 --> 00:15:55,459
service will go down at the worst

00:15:51,679 --> 00:15:57,289
possible moment you also don't want your

00:15:55,459 --> 00:15:59,959
test suite failures to be dependent upon

00:15:57,289 --> 00:16:01,549
somebody else's service so you might for

00:15:59,959 --> 00:16:03,829
example want to be able to reliably test

00:16:01,549 --> 00:16:08,089
what happens if this service goes down

00:16:03,829 --> 00:16:10,309
you can't manufacture a API failure at

00:16:08,089 --> 00:16:12,769
the Twitter level so you need to be able

00:16:10,309 --> 00:16:14,389
to manufacture a Twitter failure so that

00:16:12,769 --> 00:16:15,769
you know how your API or yours your

00:16:14,389 --> 00:16:18,619
service will respond when Twitter goes

00:16:15,769 --> 00:16:19,939
down on top of that many commercial

00:16:18,619 --> 00:16:21,349
api's will have a rate limit of some

00:16:19,939 --> 00:16:22,849
kind and that puts a constraint either

00:16:21,349 --> 00:16:24,889
on how often you can run your test suite

00:16:22,849 --> 00:16:26,749
or how fast your tests can actually run

00:16:24,889 --> 00:16:27,949
these are those been good things because

00:16:26,749 --> 00:16:32,239
you need to be running your test suite

00:16:27,949 --> 00:16:33,439
as often as humanly possible alternative

00:16:32,239 --> 00:16:35,059
and unrelated problems if you have a

00:16:33,439 --> 00:16:37,789
slow unreliable or difficult to

00:16:35,059 --> 00:16:38,929
configure internal service the slow is

00:16:37,789 --> 00:16:40,759
something they could definitely apply to

00:16:38,929 --> 00:16:43,309
it to a third-party external service you

00:16:40,759 --> 00:16:44,299
know we have Americans in the room so

00:16:43,309 --> 00:16:45,319
it's worth pointing out with them that

00:16:44,299 --> 00:16:46,849
when we're sitting here in Australia

00:16:45,319 --> 00:16:48,529
point 3 of a second round trip is really

00:16:46,849 --> 00:16:50,659
really good not everybody is sitting in

00:16:48,529 --> 00:16:52,369
California so calling out to an external

00:16:50,659 --> 00:16:53,599
service slows down your test suite by

00:16:52,369 --> 00:16:55,999
virtue of the fact it's an external

00:16:53,599 --> 00:16:56,899
service but you can have slow internal

00:16:55,999 --> 00:17:00,559
services because they're going to do

00:16:56,899 --> 00:17:02,119
complex computation or there are certain

00:17:00,559 --> 00:17:04,159
you know api's that are actually slowed

00:17:02,119 --> 00:17:05,839
by the foot by design you know Django's

00:17:04,159 --> 00:17:09,139
default password hashing algorithm for

00:17:05,839 --> 00:17:11,360
example is slow by design and this kind

00:17:09,139 --> 00:17:13,220
of a you know a note in the 1.4 docs to

00:17:11,360 --> 00:17:14,480
say in your test environment in your

00:17:13,220 --> 00:17:16,519
test suite you probably want to redefine

00:17:14,480 --> 00:17:17,839
your password hashes to make your test

00:17:16,519 --> 00:17:19,850
suite run faster because you don't care

00:17:17,839 --> 00:17:21,379
about security during your you don't

00:17:19,850 --> 00:17:25,329
care about the password security in your

00:17:21,379 --> 00:17:27,350
testing environment another example

00:17:25,329 --> 00:17:29,509
testing things like database failures

00:17:27,350 --> 00:17:31,159
under Django it can be very very hard to

00:17:29,509 --> 00:17:33,110
manipulate the set of conditions that

00:17:31,159 --> 00:17:37,070
actually that would cause your database

00:17:33,110 --> 00:17:38,990
to drop out in a test test case so what

00:17:37,070 --> 00:17:40,039
you want to be doing is that those sort

00:17:38,990 --> 00:17:41,149
of dropouts are interesting from a

00:17:40,039 --> 00:17:43,220
testing purpose because they're a mode

00:17:41,149 --> 00:17:45,799
of failure of your product but they're

00:17:43,220 --> 00:17:47,029
difficult to test because you can't make

00:17:45,799 --> 00:17:47,840
your database file or its least

00:17:47,029 --> 00:17:52,210
difficult to make it

00:17:47,840 --> 00:17:54,409
most fail so option one grin and Barrett

00:17:52,210 --> 00:17:56,960
ya know a lot of people used to kind of

00:17:54,409 --> 00:17:58,460
you live with that because you have to

00:17:56,960 --> 00:17:59,659
but it's not really a good solution

00:17:58,460 --> 00:18:01,610
because it means you're essentially not

00:17:59,659 --> 00:18:04,940
testing or not testing well parts of

00:18:01,610 --> 00:18:09,260
your system so the second library like

00:18:04,940 --> 00:18:10,580
to introduce you to is mock mock is for

00:18:09,260 --> 00:18:14,450
one of a better description organized

00:18:10,580 --> 00:18:17,330
monkey patching it is a part of the

00:18:14,450 --> 00:18:19,340
Python standard library in Python 3.3

00:18:17,330 --> 00:18:22,549
but it is available as a library you can

00:18:19,340 --> 00:18:24,230
install in Python 2.7 and previously

00:18:22,549 --> 00:18:25,640
written by michael ford the same guy who

00:18:24,230 --> 00:18:28,250
actually brought the unit test two

00:18:25,640 --> 00:18:30,230
extensions and it provides a set of

00:18:28,250 --> 00:18:33,470
methods to help you replace calls in

00:18:30,230 --> 00:18:35,779
your in your test suite that your your

00:18:33,470 --> 00:18:38,169
code is using with reliable alternatives

00:18:35,779 --> 00:18:40,880
it essentially allows you to program in

00:18:38,169 --> 00:18:43,130
expected results of certain API points

00:18:40,880 --> 00:18:46,070
and then assert that the API is being

00:18:43,130 --> 00:18:47,779
used the way you expect there are a

00:18:46,070 --> 00:18:49,220
couple of a couple more more to it than

00:18:47,779 --> 00:18:52,039
this but the core parts you need to care

00:18:49,220 --> 00:18:55,010
about is the mock object and the patch

00:18:52,039 --> 00:18:56,270
decorator there are some additional

00:18:55,010 --> 00:18:57,890
parts like I say but I've got limited

00:18:56,270 --> 00:18:59,510
time so I'll focus on these ones the

00:18:57,890 --> 00:19:01,789
first is a mock object the mock object

00:18:59,510 --> 00:19:04,309
is a Python object that uses a whole

00:19:01,789 --> 00:19:07,279
bunch of get outro trickery to make sure

00:19:04,309 --> 00:19:10,010
that any requests or an attribute can be

00:19:07,279 --> 00:19:11,659
given back the value that you want the

00:19:10,010 --> 00:19:13,789
and essentially all the attributes and

00:19:11,659 --> 00:19:16,340
functions that are on mark can be

00:19:13,789 --> 00:19:18,500
pre-programmed to assert that they're

00:19:16,340 --> 00:19:20,029
doing what you need them to do the

00:19:18,500 --> 00:19:21,799
second is the patch decorator it

00:19:20,029 --> 00:19:26,600
provides a way to introduce your mock

00:19:21,799 --> 00:19:27,830
object into a live module space so given

00:19:26,600 --> 00:19:30,200
that you've got this mock object that

00:19:27,830 --> 00:19:31,610
has been programmed to have the behavior

00:19:30,200 --> 00:19:37,480
you want you can put it somewhere and

00:19:31,610 --> 00:19:40,100
actually use it reliably the mock is a

00:19:37,480 --> 00:19:41,659
it's a dummy objects habits accessed it

00:19:40,100 --> 00:19:43,730
tracks how its methods are being invoked

00:19:41,659 --> 00:19:46,130
and how men those methods are being

00:19:43,730 --> 00:19:47,870
invoked and it has no side effects it's

00:19:46,130 --> 00:19:49,760
just there and essentially it's every

00:19:47,870 --> 00:19:51,950
call on it every axle Butte accesses are

00:19:49,760 --> 00:19:56,450
no up unless you specifically program it

00:19:51,950 --> 00:19:58,520
to have side effects so for example we

00:19:56,450 --> 00:20:01,149
can say we import more can we say create

00:19:58,520 --> 00:20:03,070
some object which is some

00:20:01,149 --> 00:20:05,349
object that is in our actual live system

00:20:03,070 --> 00:20:07,509
it's a live Django object it's alive API

00:20:05,349 --> 00:20:10,509
instantiation something that's somewhere

00:20:07,509 --> 00:20:14,440
and we can say okay make object method a

00:20:10,509 --> 00:20:16,989
mock okay and it's return value if you

00:20:14,440 --> 00:20:19,299
ever invoke on it is 3 whenever you call

00:20:16,989 --> 00:20:21,219
object method subsequently it will

00:20:19,299 --> 00:20:23,289
return three it won't do anything that

00:20:21,219 --> 00:20:25,330
object method previously did it will

00:20:23,289 --> 00:20:28,089
just return three under any conditions

00:20:25,330 --> 00:20:29,830
but it will also track how often was

00:20:28,089 --> 00:20:32,200
object on method called so we can say

00:20:29,830 --> 00:20:34,779
object up method assert that you called

00:20:32,200 --> 00:20:36,609
it with the values 3 4 5 k equals value

00:20:34,779 --> 00:20:39,070
and it will return true or false in this

00:20:36,609 --> 00:20:41,889
case true because object up method was

00:20:39,070 --> 00:20:44,320
invoked with 3 4 5 and you can do other

00:20:41,889 --> 00:20:46,450
things like track object up method was

00:20:44,320 --> 00:20:48,789
called three times so you can say that

00:20:46,450 --> 00:20:50,589
the call chain it was called three times

00:20:48,789 --> 00:20:51,789
the first time with these arguments the

00:20:50,589 --> 00:20:55,659
second time of these arguments the third

00:20:51,789 --> 00:20:57,700
time in these arguments so mark is how

00:20:55,659 --> 00:21:00,999
you set up your expected return values

00:20:57,700 --> 00:21:02,440
and then the object itself is then so

00:21:00,999 --> 00:21:04,509
that the mock object is then used using

00:21:02,440 --> 00:21:06,609
a patch decorator and that is a

00:21:04,509 --> 00:21:08,320
decorator you can apply to a function to

00:21:06,609 --> 00:21:10,419
introduce the market a specific API

00:21:08,320 --> 00:21:13,359
point and then once it returns it

00:21:10,419 --> 00:21:16,229
restores the original value so the

00:21:13,359 --> 00:21:19,419
obvious very very easy use case here is

00:21:16,229 --> 00:21:21,219
calling on requests so you know your

00:21:19,419 --> 00:21:23,859
Python library for calling an external

00:21:21,219 --> 00:21:26,440
service we're going to call we want to

00:21:23,859 --> 00:21:29,499
patch here requests get so every time

00:21:26,440 --> 00:21:32,320
requests dot guess is invoked we want to

00:21:29,499 --> 00:21:35,139
test that this login fails so the return

00:21:32,320 --> 00:21:36,849
value of request dog yet will be a 401

00:21:35,139 --> 00:21:39,219
with a chat with our body text says bad

00:21:36,849 --> 00:21:40,210
login okay so that those return values

00:21:39,219 --> 00:21:42,249
will be based upon what the

00:21:40,210 --> 00:21:44,830
documentation for our login service says

00:21:42,249 --> 00:21:48,999
will happen when the login fails

00:21:44,830 --> 00:21:51,940
whatever you pass into whatever your

00:21:48,999 --> 00:21:54,849
code says request get passing URL

00:21:51,940 --> 00:21:56,349
passing data arguments the test and that

00:21:54,849 --> 00:21:58,989
these testing conditions it will return

00:21:56,349 --> 00:22:00,940
a 401 with with the text of bad login

00:21:58,989 --> 00:22:03,249
and then you can say okay let's say

00:22:00,940 --> 00:22:05,320
we're expecting our internal API when we

00:22:03,249 --> 00:22:07,719
say my service login will return a login

00:22:05,320 --> 00:22:10,329
fail exception fine ok we can assert

00:22:07,719 --> 00:22:12,549
that actually does that based upon the

00:22:10,329 --> 00:22:14,770
simulator the mopped value that we've

00:22:12,549 --> 00:22:16,600
told request doc yet to return

00:22:14,770 --> 00:22:18,130
and we can then say I could check that

00:22:16,600 --> 00:22:22,210
request or get was actually called with

00:22:18,130 --> 00:22:25,420
login for example there's a lot more to

00:22:22,210 --> 00:22:26,500
to what Mach can do you can tell it to

00:22:25,420 --> 00:22:28,780
raise exceptions under particular

00:22:26,500 --> 00:22:29,890
circumstances you can assert all sorts

00:22:28,780 --> 00:22:32,080
of interesting things about the way

00:22:29,890 --> 00:22:33,820
these objects are being generated you

00:22:32,080 --> 00:22:36,310
can mark generators you can mock

00:22:33,820 --> 00:22:37,750
iterators documentation for Bach is

00:22:36,310 --> 00:22:38,890
actually pretty good so the best sources

00:22:37,750 --> 00:22:40,180
to actually go to this this is really

00:22:38,890 --> 00:22:42,160
just a taster to let you know that it's

00:22:40,180 --> 00:22:43,570
there and in my opinion is well worth

00:22:42,160 --> 00:22:46,360
getting very familiar with because it's

00:22:43,570 --> 00:22:48,460
a fantastic way of abstracting away what

00:22:46,360 --> 00:22:50,710
you're trying to test from the actual

00:22:48,460 --> 00:22:53,560
test code and it doesn't require you to

00:22:50,710 --> 00:22:55,330
modify your library code to have these

00:22:53,560 --> 00:22:58,630
preconditions to let you know testing

00:22:55,330 --> 00:23:00,280
libraries be injected into them how do

00:22:58,630 --> 00:23:03,130
you get it ok again it's a built-in in

00:23:00,280 --> 00:23:04,840
Python 3.3 as unit test mock but if

00:23:03,130 --> 00:23:06,190
you're not using Python 3.3 you can say

00:23:04,840 --> 00:23:09,010
Kip install mock and it's the air and

00:23:06,190 --> 00:23:11,260
ready to use void spaces documentation

00:23:09,010 --> 00:23:12,850
and goes through all the details there

00:23:11,260 --> 00:23:15,310
are just as full disclosure there are

00:23:12,850 --> 00:23:16,540
alternatives to mock but one I'm a

00:23:15,310 --> 00:23:17,650
believer in using what the standard

00:23:16,540 --> 00:23:21,100
library gives you unless there's a

00:23:17,650 --> 00:23:22,330
really good reason not to and I've had

00:23:21,100 --> 00:23:24,160
some good reports from people have used

00:23:22,330 --> 00:23:25,540
other mocking libraries but I've never

00:23:24,160 --> 00:23:28,990
had come across enough of a problem with

00:23:25,540 --> 00:23:31,660
mark to warrant looking into them one

00:23:28,990 --> 00:23:33,790
last thing before I before I leave the

00:23:31,660 --> 00:23:36,400
stage or open up for questions I'm

00:23:33,790 --> 00:23:38,920
giving a talk at PyCon on Sunday called

00:23:36,400 --> 00:23:40,720
tinkering with TK inter now although

00:23:38,920 --> 00:23:42,910
that title may not seem like it it will

00:23:40,720 --> 00:23:45,690
actually be testing touching on Jango

00:23:42,910 --> 00:23:48,850
testing again but for tangential reasons

00:23:45,690 --> 00:23:53,230
and it will involve an announcement so

00:23:48,850 --> 00:23:56,860
be there I'll be there maybe you 220 in

00:23:53,230 --> 00:23:58,210
the plenary hall on Sunday and following

00:23:56,860 --> 00:24:02,100
that I would like to open the floor for

00:23:58,210 --> 00:24:02,100
questions any questions

00:24:05,890 --> 00:24:09,770
hi I was wondering if you had any

00:24:08,150 --> 00:24:12,440
opinions on the behavior driven

00:24:09,770 --> 00:24:16,520
development things for example letters

00:24:12,440 --> 00:24:19,730
okay I am aware of them and I think the

00:24:16,520 --> 00:24:23,030
best example or in short i'm not a fan

00:24:19,730 --> 00:24:25,550
of them but for a reason it's aight i

00:24:23,030 --> 00:24:28,460
have always been highly skeptical of

00:24:25,550 --> 00:24:30,190
anyone who says we're going to build a

00:24:28,460 --> 00:24:32,390
human readable programming language

00:24:30,190 --> 00:24:34,220
applescript is an example of someone who

00:24:32,390 --> 00:24:35,900
did that and it's failed spectacularly

00:24:34,220 --> 00:24:38,200
and being both a good programming

00:24:35,900 --> 00:24:40,460
language and in being human readable

00:24:38,200 --> 00:24:42,830
it's a matter of audience of testing I

00:24:40,460 --> 00:24:44,390
benevento rice actually gave us answer

00:24:42,830 --> 00:24:46,280
last year so props to him is actually

00:24:44,390 --> 00:24:49,250
giving me a reason to possibly like

00:24:46,280 --> 00:24:51,050
behavior at testing the reason I think

00:24:49,250 --> 00:24:53,480
behavior during testing is useful is if

00:24:51,050 --> 00:24:55,460
the audience for your test is not a

00:24:53,480 --> 00:24:57,830
programmer if the audience of your test

00:24:55,460 --> 00:24:59,480
is a business analyst who knows no code

00:24:57,830 --> 00:25:01,670
but needs to be able to read something

00:24:59,480 --> 00:25:04,790
that makes sense to them then a behavior

00:25:01,670 --> 00:25:06,410
during tests makes sense if your

00:25:04,790 --> 00:25:08,420
audience for your test suite is a

00:25:06,410 --> 00:25:09,880
programmer they can read Python well

00:25:08,420 --> 00:25:12,320
they should be able to read Python so

00:25:09,880 --> 00:25:13,820
making it in a human readable language

00:25:12,320 --> 00:25:16,460
for an audience that can read the code

00:25:13,820 --> 00:25:17,750
in the first place is kind of a defeats

00:25:16,460 --> 00:25:21,020
the purpose of doing it right right at

00:25:17,750 --> 00:25:22,190
natively user natively that said I am I

00:25:21,020 --> 00:25:23,360
know some people do like behavior driven

00:25:22,190 --> 00:25:25,010
driven testing or behavior driven

00:25:23,360 --> 00:25:26,900
development libraries like lettuce and

00:25:25,010 --> 00:25:29,600
what-have-you so I certainly wouldn't

00:25:26,900 --> 00:25:31,280
you know call for their execution or

00:25:29,600 --> 00:25:32,630
anything it's a they are but they are

00:25:31,280 --> 00:25:35,630
perfectly useful libraries I just don't

00:25:32,630 --> 00:25:37,760
particularly happen to like them so any

00:25:35,630 --> 00:25:41,020
other questions as one of the back the

00:25:37,760 --> 00:25:41,020
back neck sorry

00:25:46,350 --> 00:25:51,360
I just wanted to get your thoughts on

00:25:48,000 --> 00:25:54,960
what level to patch things so for

00:25:51,360 --> 00:25:57,090
example if I've got I'm using s 3 i've

00:25:54,960 --> 00:25:59,250
got a django storage back-end that uses

00:25:57,090 --> 00:26:02,370
s3 that's using boto billion of the day

00:25:59,250 --> 00:26:05,309
it's making a requester to to s3 and

00:26:02,370 --> 00:26:07,559
what what level would you patch that or

00:26:05,309 --> 00:26:09,720
earn for what reasons I would say as

00:26:07,559 --> 00:26:11,160
high as humanly possible you know if

00:26:09,720 --> 00:26:12,929
you're if you're tested botos i get an

00:26:11,160 --> 00:26:15,000
example there you've got a HTTP call

00:26:12,929 --> 00:26:17,610
that is being made but you've also got a

00:26:15,000 --> 00:26:19,230
higher level API you are engaging your

00:26:17,610 --> 00:26:21,720
in your engagement with that library is

00:26:19,230 --> 00:26:23,100
at the boat i level the higher you can

00:26:21,720 --> 00:26:25,950
make that level of abstraction the

00:26:23,100 --> 00:26:29,309
tighter the scope for what you're

00:26:25,950 --> 00:26:31,799
testing is but that boat the agreement

00:26:29,309 --> 00:26:33,720
that botos library returns the right

00:26:31,799 --> 00:26:35,940
exception when the underlying HTTP

00:26:33,720 --> 00:26:38,190
returns a 401 or whatever it's whatever

00:26:35,940 --> 00:26:39,510
it's doing is part of botos testings to

00:26:38,190 --> 00:26:41,220
a test suite to make sure it's behaving

00:26:39,510 --> 00:26:43,320
properly it's not your responsibility to

00:26:41,220 --> 00:26:46,710
make sure that boto is using HTTP

00:26:43,320 --> 00:26:49,650
correctly so my advice would be patch

00:26:46,710 --> 00:26:51,690
boto and make sure that your code is

00:26:49,650 --> 00:26:53,520
using boto correctly assuming boat I was

00:26:51,690 --> 00:26:54,990
doing the right thing and if that then

00:26:53,520 --> 00:26:56,100
turns out to be a problem work out why

00:26:54,990 --> 00:26:58,440
boto isn't doing the right thing and

00:26:56,100 --> 00:26:59,460
make that make botos test patch requests

00:26:58,440 --> 00:27:02,730
or whatever it's wherever it is calling

00:26:59,460 --> 00:27:05,120
out on is that that's really useful

00:27:02,730 --> 00:27:05,120
things

00:27:07,730 --> 00:27:16,730
I was curious if you had if there were

00:27:14,990 --> 00:27:19,570
any cases where you found it justifiable

00:27:16,730 --> 00:27:21,950
to use traditional Django fixtures in

00:27:19,570 --> 00:27:23,960
test code that you write nowadays or do

00:27:21,950 --> 00:27:26,000
you have you split entirely replaced it

00:27:23,960 --> 00:27:27,740
with i have not entirely replaced it and

00:27:26,000 --> 00:27:32,170
the answer for that for me is basically

00:27:27,740 --> 00:27:35,810
legacy at this point I I discovered my

00:27:32,170 --> 00:27:38,810
code for the pros like that I run as my

00:27:35,810 --> 00:27:41,000
day job is at this point two and a half

00:27:38,810 --> 00:27:44,000
years old and i discovered factory boy a

00:27:41,000 --> 00:27:46,220
year and a cheering change ago so there

00:27:44,000 --> 00:27:48,830
is a lot of legacy tests and you can

00:27:46,220 --> 00:27:52,760
actually mean I have a fixture and a

00:27:48,830 --> 00:27:53,900
factory boy object coexisting but it's

00:27:52,760 --> 00:27:55,400
kind of you know you then go to have a

00:27:53,900 --> 00:27:57,230
clear picture of where your environment

00:27:55,400 --> 00:27:59,060
is new tests that are completely new

00:27:57,230 --> 00:28:01,250
features completely new database stuff

00:27:59,060 --> 00:28:03,410
I'm tending to write more with with

00:28:01,250 --> 00:28:05,000
factory boy but if it's an existing

00:28:03,410 --> 00:28:06,230
based on a fixture I'm kind of sticking

00:28:05,000 --> 00:28:08,150
with a fixture because it's a known

00:28:06,230 --> 00:28:09,590
quantity I would like to be able to

00:28:08,150 --> 00:28:10,940
refactor and replace them all with with

00:28:09,590 --> 00:28:12,860
factory boy but it's just a matter of

00:28:10,940 --> 00:28:16,670
you know is the time time worth it so

00:28:12,860 --> 00:28:17,990
thanks okay i'm guessing everyone's a

00:28:16,670 --> 00:28:21,410
bit hungry so we might wrap it up oh

00:28:17,990 --> 00:28:25,880
yeah let me get a more but yeah you're

00:28:21,410 --> 00:28:27,470
between them and lunch I'll make it

00:28:25,880 --> 00:28:29,540
quick or you can make it quick I got

00:28:27,470 --> 00:28:31,310
short answer so okay factory boy appears

00:28:29,540 --> 00:28:35,000
to me to be a best practice so why don't

00:28:31,310 --> 00:28:36,260
we just build it into Django the only

00:28:35,000 --> 00:28:38,870
reason would be the historical no

00:28:36,260 --> 00:28:41,600
dependencies thing however we are also

00:28:38,870 --> 00:28:42,920
getting to the point where you know pip

00:28:41,600 --> 00:28:44,120
install pip dependencies are actually

00:28:42,920 --> 00:28:45,920
working properly i think it's certainly

00:28:44,120 --> 00:28:47,330
something we should look at so i agree

00:28:45,920 --> 00:28:49,250
we should look at it it's it's more

00:28:47,330 --> 00:28:51,170
packaging issue than 0 then 0 she is it

00:28:49,250 --> 00:28:58,930
worth doing so yeah everything's a

00:28:51,170 --> 00:29:02,050
packaging is she nope

00:28:58,930 --> 00:29:02,050

YouTube URL: https://www.youtube.com/watch?v=a713rcagoYU


