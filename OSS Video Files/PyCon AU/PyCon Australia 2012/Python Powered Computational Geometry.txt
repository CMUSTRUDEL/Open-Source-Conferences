Title: Python Powered Computational Geometry
Publication date: 2012-08-23
Playlist: PyCon Australia 2012
Description: 
	Andrew Walker
Computational Geometry is the study of geometry with the support of appropriate algorithms, and influences a broad range of fields of science, engineering and mathematics including: Computation Fluid Dynamics (CFD), Finite Element Model
Captions: 
	00:00:00,110 --> 00:00:05,759
next speaker is a research scientist who

00:00:03,570 --> 00:00:07,740
specializes in modeling and simulation

00:00:05,759 --> 00:00:09,540
of physical systems and works on the

00:00:07,740 --> 00:00:12,330
number of projects with a focus on

00:00:09,540 --> 00:00:13,860
computational geometry in today's talk

00:00:12,330 --> 00:00:16,080
will be showing us how to use Python for

00:00:13,860 --> 00:00:19,130
computational geometry please welcome

00:00:16,080 --> 00:00:19,130
Andrew Walker

00:00:32,910 --> 00:00:39,660
Benna yeah good afternoon everybody I've

00:00:37,930 --> 00:00:42,280
been introduced but this is my colleague

00:00:39,660 --> 00:00:44,230
Daniel cousins Daniel is actually a

00:00:42,280 --> 00:00:46,510
Swinburne University industry based

00:00:44,230 --> 00:00:48,460
learning student who's on attachment to

00:00:46,510 --> 00:00:51,489
DST Oh for 12 months DST o is the

00:00:48,460 --> 00:00:54,129
organization I work for this talk itself

00:00:51,489 --> 00:00:56,710
actually came out of some of the things

00:00:54,129 --> 00:00:59,260
that happened at this year's u.s. PyCon

00:00:56,710 --> 00:01:02,350
actually attended the science sprints

00:00:59,260 --> 00:01:05,830
with the ipython team and the pandas

00:01:02,350 --> 00:01:07,560
team and some of it came out of my

00:01:05,830 --> 00:01:09,340
frustration with with the lack of

00:01:07,560 --> 00:01:12,100
availability of really good

00:01:09,340 --> 00:01:15,460
computational geometry tools in in

00:01:12,100 --> 00:01:17,770
Python at the moment so so what is this

00:01:15,460 --> 00:01:20,380
computational geometry thing so this is

00:01:17,770 --> 00:01:22,180
the Wikipedia definition it's a branch

00:01:20,380 --> 00:01:24,160
of computer science devoted to the study

00:01:22,180 --> 00:01:26,380
of algorithms which can be stated in

00:01:24,160 --> 00:01:28,570
terms of geometry which is kind of a bit

00:01:26,380 --> 00:01:32,740
vague but it's things like shapes and

00:01:28,570 --> 00:01:34,570
intersections triangulations meshing so

00:01:32,740 --> 00:01:36,490
but what does that actually mean in

00:01:34,570 --> 00:01:38,880
practice so there's a ton of

00:01:36,490 --> 00:01:41,049
applications for computational geometry

00:01:38,880 --> 00:01:44,080
Tennessee came up and spoke yesterday

00:01:41,049 --> 00:01:45,400
about virtual robotic car racing I know

00:01:44,080 --> 00:01:47,530
there's other people in the room who

00:01:45,400 --> 00:01:49,330
have a significant interest in game

00:01:47,530 --> 00:01:51,880
development doing collision detections

00:01:49,330 --> 00:01:54,670
in games there are other people here who

00:01:51,880 --> 00:01:57,400
who are GIS people there's already great

00:01:54,670 --> 00:01:59,409
tools for things like shape like shapely

00:01:57,400 --> 00:02:02,229
to do unions and intersections of

00:01:59,409 --> 00:02:03,759
geometric regions in 2d but where it

00:02:02,229 --> 00:02:05,470
starts getting hard is when you've got

00:02:03,759 --> 00:02:07,479
the science problems and that's and

00:02:05,470 --> 00:02:08,860
that's what our interest really is so

00:02:07,479 --> 00:02:12,040
when you're trying to do computer aided

00:02:08,860 --> 00:02:14,500
design and manufacture computational

00:02:12,040 --> 00:02:16,930
fluid dynamics have how fluid moves and

00:02:14,500 --> 00:02:18,700
find our element analysis now I'm not

00:02:16,930 --> 00:02:20,680
saying I'm an expert on any of those

00:02:18,700 --> 00:02:22,269
things but but they're an interest and

00:02:20,680 --> 00:02:24,489
we do use some of these tools in the

00:02:22,269 --> 00:02:27,160
same way that the professionals in the

00:02:24,489 --> 00:02:29,500
industry use them so why would you use

00:02:27,160 --> 00:02:31,000
Python everybody who's here knows you

00:02:29,500 --> 00:02:33,820
use Python because it's awesome

00:02:31,000 --> 00:02:36,280
but but really it's about rapid

00:02:33,820 --> 00:02:38,019
prototyping fast so it's how do you

00:02:36,280 --> 00:02:42,010
actually turn something around from a

00:02:38,019 --> 00:02:43,930
concept to code to a visualization to an

00:02:42,010 --> 00:02:45,060
explanation to somebody at one of your

00:02:43,930 --> 00:02:47,489
clients

00:02:45,060 --> 00:02:51,150
for us another big thing is that it's

00:02:47,489 --> 00:02:53,160
free so a lot of the commercial

00:02:51,150 --> 00:02:56,160
scientific software that's out there at

00:02:53,160 --> 00:02:58,200
the moment it's paid per seat or pay per

00:02:56,160 --> 00:03:00,810
site and when you have to actually

00:02:58,200 --> 00:03:03,120
distribute this across clusters and

00:03:00,810 --> 00:03:06,630
large computers it can become

00:03:03,120 --> 00:03:08,910
challenging so so additionally you've

00:03:06,630 --> 00:03:10,860
already got really fantastic support

00:03:08,910 --> 00:03:14,250
from the scientific community working in

00:03:10,860 --> 00:03:15,720
Python things like numpy and Syfy really

00:03:14,250 --> 00:03:17,340
make addressing some of these problems

00:03:15,720 --> 00:03:20,459
much easier especially with the

00:03:17,340 --> 00:03:22,950
post-processing of results I've got a

00:03:20,459 --> 00:03:24,900
list of some of the interactivity and

00:03:22,950 --> 00:03:28,110
visualization support packages as well

00:03:24,900 --> 00:03:30,390
so we use I - to actually drive a lot of

00:03:28,110 --> 00:03:32,450
our simulations and to control and

00:03:30,390 --> 00:03:36,780
manipulate them we're using matplotlib

00:03:32,450 --> 00:03:38,549
2d plotting n thoughts mayor VI for 3d

00:03:36,780 --> 00:03:41,069
plotting and we're starting to look at

00:03:38,549 --> 00:03:43,560
using things like charco for real

00:03:41,069 --> 00:03:45,150
interact really really interactive plots

00:03:43,560 --> 00:03:46,620
where you can drag sliders and actually

00:03:45,150 --> 00:03:50,600
give those things directly to your

00:03:46,620 --> 00:03:53,549
clients so what are the challenges

00:03:50,600 --> 00:03:55,680
computational geometry is hard has who's

00:03:53,549 --> 00:03:58,320
written computational geometry code

00:03:55,680 --> 00:04:00,359
intersections or triangulations and had

00:03:58,320 --> 00:04:04,500
them blow up because of some crazy edge

00:04:00,359 --> 00:04:07,890
case it really is hard to write robust

00:04:04,500 --> 00:04:10,170
code so one of the simplest examples is

00:04:07,890 --> 00:04:11,519
if you have two lines that are

00:04:10,170 --> 00:04:13,410
intersecting you can have an obvious

00:04:11,519 --> 00:04:15,030
intersection you may have no

00:04:13,410 --> 00:04:16,470
intersection or you may have the

00:04:15,030 --> 00:04:19,650
horrible case where the two line

00:04:16,470 --> 00:04:21,600
segments actually overlap so you've got

00:04:19,650 --> 00:04:23,550
to be able to tech in particular that

00:04:21,600 --> 00:04:26,190
third case and be able to differentiate

00:04:23,550 --> 00:04:27,780
it from the first two and so once you've

00:04:26,190 --> 00:04:29,789
actually got the robustness side of

00:04:27,780 --> 00:04:32,520
things going how do you actually convert

00:04:29,789 --> 00:04:35,430
that code to being robust and to being

00:04:32,520 --> 00:04:39,930
reusable so a lot of the tools that

00:04:35,430 --> 00:04:41,990
we'll look at our C++ codes that you

00:04:39,930 --> 00:04:44,789
face a combinatorial explosion of

00:04:41,990 --> 00:04:46,740
possibilities for combining different

00:04:44,789 --> 00:04:48,990
components together so we're not just

00:04:46,740 --> 00:04:50,820
looking at Euclidean geometry in two and

00:04:48,990 --> 00:04:52,350
three dimensions but spherical

00:04:50,820 --> 00:04:55,680
geometries as well where things will

00:04:52,350 --> 00:04:57,580
wrap around surfaces it's also

00:04:55,680 --> 00:05:00,039
exceptionally hard to write over

00:04:57,580 --> 00:05:06,340
that are provably correct and that means

00:05:00,039 --> 00:05:09,310
it's hard to test so yep yep so another

00:05:06,340 --> 00:05:11,409
another issue is a lot of the resources

00:05:09,310 --> 00:05:13,180
that are available pretty C++ centric

00:05:11,409 --> 00:05:15,330
this is a really great book if you're

00:05:13,180 --> 00:05:18,310
getting started writing your own code

00:05:15,330 --> 00:05:19,569
the other book is that a rock book but

00:05:18,310 --> 00:05:21,159
you're starting to get a bit older but

00:05:19,569 --> 00:05:25,030
it's still a great book if you if you're

00:05:21,159 --> 00:05:26,199
trying to do that most of the time you

00:05:25,030 --> 00:05:28,000
aren't going to want to try and write

00:05:26,199 --> 00:05:29,889
this code yourself you want to going to

00:05:28,000 --> 00:05:31,750
want to use somebody else's so Python is

00:05:29,889 --> 00:05:33,879
great because it's a fantastic glue

00:05:31,750 --> 00:05:35,199
language for doing these things so we're

00:05:33,879 --> 00:05:40,120
going to talk a little bit about sci-fi

00:05:35,199 --> 00:05:42,699
weave and boost Python so what's

00:05:40,120 --> 00:05:44,680
available at the moment on pi PI if all

00:05:42,699 --> 00:05:46,539
you need to do is basic geometric

00:05:44,680 --> 00:05:48,819
intersections say for some game

00:05:46,539 --> 00:05:50,229
programming stuff you can use Euclid if

00:05:48,819 --> 00:05:52,150
what you're really interested in is

00:05:50,229 --> 00:05:55,569
meshing and being compatible with

00:05:52,150 --> 00:05:58,300
something like Mathematica or MATLAB you

00:05:55,569 --> 00:06:01,389
might want to try mesh pi now I'm hoping

00:05:58,300 --> 00:06:03,009
that Sai PI is going to end up with a

00:06:01,389 --> 00:06:05,289
geometry module I think that would be

00:06:03,009 --> 00:06:07,479
the ideal direction for this stuff to go

00:06:05,289 --> 00:06:09,729
in it doesn't at the moment but it does

00:06:07,479 --> 00:06:12,190
have Sai high spatial for the last few

00:06:09,729 --> 00:06:15,430
releases and we'll demo that in a little

00:06:12,190 --> 00:06:18,250
while the the last link there is GTS the

00:06:15,430 --> 00:06:19,479
new triangulated surface library we're

00:06:18,250 --> 00:06:20,949
going to we're going to ignore those

00:06:19,479 --> 00:06:23,289
packages though for today and we're

00:06:20,949 --> 00:06:27,009
going to focus on one one other library

00:06:23,289 --> 00:06:28,479
yep the this focus this presentation is

00:06:27,009 --> 00:06:30,339
going to talk about the computational

00:06:28,479 --> 00:06:34,990
geometry and algorithms library which is

00:06:30,339 --> 00:06:36,580
a research project run out of a few

00:06:34,990 --> 00:06:38,560
companies in France and and some of

00:06:36,580 --> 00:06:39,909
their universities as well and more

00:06:38,560 --> 00:06:42,969
specifically we're going to talk about

00:06:39,909 --> 00:06:45,430
Seigle bindings which is a sweet package

00:06:42,969 --> 00:06:48,819
that that wraps those bindings up and

00:06:45,430 --> 00:06:51,969
makes them available in Java and Python

00:06:48,819 --> 00:06:56,110
at the moment and potentially Ruby in

00:06:51,969 --> 00:06:58,120
the in the near future so the rest of

00:06:56,110 --> 00:07:00,219
the talk is structured a bit differently

00:06:58,120 --> 00:07:01,419
we're going to have a question and then

00:07:00,219 --> 00:07:03,009
some diagrams and we're going to

00:07:01,419 --> 00:07:05,080
actually show you some of the code that

00:07:03,009 --> 00:07:06,819
you would use to actually solve some of

00:07:05,080 --> 00:07:08,259
the problems that are interesting when

00:07:06,819 --> 00:07:10,380
you get started in computational

00:07:08,259 --> 00:07:12,090
geometry so this is the

00:07:10,380 --> 00:07:14,940
case that I was speaking about before we

00:07:12,090 --> 00:07:17,880
you've got your line segments so

00:07:14,940 --> 00:07:20,520
segments are actually a specialization

00:07:17,880 --> 00:07:22,350
of a line and lines in geometry actually

00:07:20,520 --> 00:07:25,530
infinite so we've actually got two

00:07:22,350 --> 00:07:28,560
points that define a short interval on a

00:07:25,530 --> 00:07:30,210
line we've got the intersecting case the

00:07:28,560 --> 00:07:32,130
non intersecting case in the overlapping

00:07:30,210 --> 00:07:35,130
case so if you if you're going to

00:07:32,130 --> 00:07:37,080
implement that with CL bindings it might

00:07:35,130 --> 00:07:39,780
look something like this we're pulling

00:07:37,080 --> 00:07:41,910
in the kernel and we're using the the

00:07:39,780 --> 00:07:43,800
points and the segment objects that come

00:07:41,910 --> 00:07:46,130
from that kernel and then we can

00:07:43,800 --> 00:07:48,540
actually start testing intersections and

00:07:46,130 --> 00:07:50,220
once we've got out our actual

00:07:48,540 --> 00:07:52,530
intersection object we can start to pull

00:07:50,220 --> 00:07:55,050
more and more information out of it so I

00:07:52,530 --> 00:07:57,030
the message from this is if what you

00:07:55,050 --> 00:08:00,750
want to do is simple intersection tests

00:07:57,030 --> 00:08:03,600
planes spheres triangles triangle meshes

00:08:00,750 --> 00:08:05,400
line segments and rays pretty much

00:08:03,600 --> 00:08:08,640
everything that you'd need to do a basic

00:08:05,400 --> 00:08:11,940
ray caster or most types of scientific

00:08:08,640 --> 00:08:15,210
simulations that stuff is here already

00:08:11,940 --> 00:08:17,700
and it's easy to get access to so the

00:08:15,210 --> 00:08:20,100
next thing that normally comes up is all

00:08:17,700 --> 00:08:23,250
right I have this problem I have some

00:08:20,100 --> 00:08:26,190
points or I have a polygon except this

00:08:23,250 --> 00:08:28,500
algorithm over here only once a set of

00:08:26,190 --> 00:08:31,320
triangles so how do I actually convert

00:08:28,500 --> 00:08:33,210
my convex polygon back to a set of

00:08:31,320 --> 00:08:35,990
triangles so let me show you some

00:08:33,210 --> 00:08:38,940
pictures so there's my set of points and

00:08:35,990 --> 00:08:40,620
what I'm really gonna do is I'm if you

00:08:38,940 --> 00:08:43,080
can imagine I had a nail board and I

00:08:40,620 --> 00:08:44,460
banged nails into the board for each of

00:08:43,080 --> 00:08:46,260
those points and then I've got a big

00:08:44,460 --> 00:08:48,450
elastic band and stretched it around the

00:08:46,260 --> 00:08:51,260
points that would actually be the convex

00:08:48,450 --> 00:08:53,730
hull of those points I can then actually

00:08:51,260 --> 00:08:56,430
start trying to link some of these

00:08:53,730 --> 00:08:59,250
points up and form all the triangles

00:08:56,430 --> 00:09:02,310
that enclose the equivalent area inside

00:08:59,250 --> 00:09:08,510
that convex hull so moving on to the

00:09:02,310 --> 00:09:08,510
code ya

00:09:09,230 --> 00:09:12,780
you're probably noticing that this looks

00:09:11,460 --> 00:09:15,090
pretty similar to like an ear clipping

00:09:12,780 --> 00:09:16,260
algorithm at the moment and that's just

00:09:15,090 --> 00:09:17,940
one of the simple things that we can

00:09:16,260 --> 00:09:18,780
overcome by using a constrained and

00:09:17,940 --> 00:09:24,450
Allah name which is what we're going to

00:09:18,780 --> 00:09:26,700
go into next okay so here again we're

00:09:24,450 --> 00:09:28,950
pulling in the Segoe kernel and grabbing

00:09:26,700 --> 00:09:30,660
the triangulations package as well we've

00:09:28,950 --> 00:09:32,790
got a little bit of numpy glue code to

00:09:30,660 --> 00:09:34,020
actually set up our points and then we

00:09:32,790 --> 00:09:36,570
can just insert those into the

00:09:34,020 --> 00:09:38,910
triangulation what I'm not showing is

00:09:36,570 --> 00:09:40,260
the actual reasonably boring that plot

00:09:38,910 --> 00:09:42,270
Lib code to actually generate the

00:09:40,260 --> 00:09:44,070
diagrams but once you've got that

00:09:42,270 --> 00:09:47,160
triangulation object you can enumerate

00:09:44,070 --> 00:09:49,500
the vertices the edges and the faces and

00:09:47,160 --> 00:09:52,920
and information that's associated with

00:09:49,500 --> 00:09:54,810
them okay so so that's good for the

00:09:52,920 --> 00:09:56,370
simplest case right but for the

00:09:54,810 --> 00:09:58,560
scientists out there they look at that

00:09:56,370 --> 00:10:00,480
triangulation gap that that's not

00:09:58,560 --> 00:10:01,680
helpful it doesn't actually solve the

00:10:00,480 --> 00:10:05,430
problems that I want to solve

00:10:01,680 --> 00:10:07,110
I need coarse meshes in the areas that I

00:10:05,430 --> 00:10:10,830
don't care about and I want finally

00:10:07,110 --> 00:10:13,710
resolve meshes on boundaries so here's

00:10:10,830 --> 00:10:15,500
my here's my geometry I've got a span si

00:10:13,710 --> 00:10:17,670
and I actually want to solve for the

00:10:15,500 --> 00:10:20,660
stresses and strains in the head of the

00:10:17,670 --> 00:10:22,890
spanner when I'm pulling on a bolt so

00:10:20,660 --> 00:10:24,930
what's going to happen is each of the

00:10:22,890 --> 00:10:28,170
points in the geometry are going to be

00:10:24,930 --> 00:10:28,920
end up being added as points and then

00:10:28,170 --> 00:10:31,200
we're going to actually add

00:10:28,920 --> 00:10:34,950
interconnecting segments between each of

00:10:31,200 --> 00:10:36,840
those points so once we once we run a

00:10:34,950 --> 00:10:38,430
triangulation on something like that and

00:10:36,840 --> 00:10:40,590
we're going to need us to use a slightly

00:10:38,430 --> 00:10:43,050
different triangulation to make sure

00:10:40,590 --> 00:10:45,840
those edges definitely show up so that's

00:10:43,050 --> 00:10:47,130
a constrained alone a triangulation we

00:10:45,840 --> 00:10:49,380
end up with something like this

00:10:47,130 --> 00:10:50,970
so you can still see that there's a few

00:10:49,380 --> 00:10:52,410
triangles there that we probably don't

00:10:50,970 --> 00:10:54,750
want so we're going to have to get rid

00:10:52,410 --> 00:10:56,850
of them at some stage but before we do

00:10:54,750 --> 00:10:58,350
that we're gonna we're gonna actually

00:10:56,850 --> 00:11:02,580
jump in and we're going to refine the

00:10:58,350 --> 00:11:04,230
mesh so here this is something that's a

00:11:02,580 --> 00:11:06,390
bit more like what you might want to

00:11:04,230 --> 00:11:09,240
convert to same matrix form so you can

00:11:06,390 --> 00:11:11,250
actually feed it to a solver there's

00:11:09,240 --> 00:11:12,660
still a whole heap of artifacts and in

00:11:11,250 --> 00:11:14,460
fact the artifacts have gotten a little

00:11:12,660 --> 00:11:15,960
bit worse but we're going to we're going

00:11:14,460 --> 00:11:19,050
to add a bit more information we're

00:11:15,960 --> 00:11:21,790
going to actually say outside this is

00:11:19,050 --> 00:11:25,000
outside the polygon and this is outside

00:11:21,790 --> 00:11:26,680
the polygon of interest as well and so

00:11:25,000 --> 00:11:29,110
once we do that we can actually run a

00:11:26,680 --> 00:11:34,180
test and and we can filter it everything

00:11:29,110 --> 00:11:36,520
back to our actual spanner so again I

00:11:34,180 --> 00:11:38,800
think the the big thing here is that

00:11:36,520 --> 00:11:40,810
this is not a lot of code and that that

00:11:38,800 --> 00:11:44,110
was a really complicated geometric

00:11:40,810 --> 00:11:46,240
problem to solve there's a little bit of

00:11:44,110 --> 00:11:49,330
code to actually go through and insert

00:11:46,240 --> 00:11:52,690
each of the points and segments in that

00:11:49,330 --> 00:11:55,450
polygon has constraints and handle the

00:11:52,690 --> 00:11:57,460
wraparound case as well we've got just a

00:11:55,450 --> 00:11:59,830
little bit of code that's not shown to

00:11:57,460 --> 00:12:02,640
go and find the polygons from disk which

00:11:59,830 --> 00:12:04,930
are kind of pre calculated earlier and

00:12:02,640 --> 00:12:07,630
then the the stuff at the bottom is

00:12:04,930 --> 00:12:09,790
actually the refinement process so again

00:12:07,630 --> 00:12:11,740
the triangulations that you get back

00:12:09,790 --> 00:12:13,990
from this process work the same way as

00:12:11,740 --> 00:12:15,940
they did for the the last step you can

00:12:13,990 --> 00:12:18,400
still enumerate the vertices the edges

00:12:15,940 --> 00:12:22,300
and the faces and any information is

00:12:18,400 --> 00:12:24,220
associated with them okay so we're going

00:12:22,300 --> 00:12:25,990
to take a little bit of a detour here

00:12:24,220 --> 00:12:29,530
and we're gonna we're going to show some

00:12:25,990 --> 00:12:31,210
side PI spatial stuff so say I have a

00:12:29,530 --> 00:12:33,700
cloud of points and I've got a

00:12:31,210 --> 00:12:36,790
particular query point in the center of

00:12:33,700 --> 00:12:39,550
my domain it's not not particularly

00:12:36,790 --> 00:12:43,480
visible so what I'm actually looking for

00:12:39,550 --> 00:12:46,680
is the K closest neighbors or points to

00:12:43,480 --> 00:12:48,940
that query point or I might want the

00:12:46,680 --> 00:12:51,010
points that are within some fixed radius

00:12:48,940 --> 00:12:54,730
at that point so that might look

00:12:51,010 --> 00:12:56,260
something like this so it's easy to

00:12:54,730 --> 00:12:58,300
actually write this code it's probably a

00:12:56,260 --> 00:13:00,940
one-line list comprehension to actually

00:12:58,300 --> 00:13:02,410
do it naively what you might want to do

00:13:00,940 --> 00:13:04,030
though is say all right that's not

00:13:02,410 --> 00:13:06,190
performant enough for what I'm trying to

00:13:04,030 --> 00:13:08,320
do I actually want some kind of spatial

00:13:06,190 --> 00:13:10,210
partitioning routine to actually speed

00:13:08,320 --> 00:13:14,050
this query up because I'm going to do it

00:13:10,210 --> 00:13:16,660
hundreds of thousands of times so that

00:13:14,050 --> 00:13:19,060
and here you can see that we're

00:13:16,660 --> 00:13:22,330
generating some random points we're

00:13:19,060 --> 00:13:24,280
adding them to the KD tree which is a

00:13:22,330 --> 00:13:27,040
spatial partitioning tree which

00:13:24,280 --> 00:13:30,970
progressively refines the environment by

00:13:27,040 --> 00:13:32,710
it by cutting each domain in half we're

00:13:30,970 --> 00:13:34,620
adding our query point and then looking

00:13:32,710 --> 00:13:37,710
for the points that are within some sum

00:13:34,620 --> 00:13:39,990
radius of that so this is actually a

00:13:37,710 --> 00:13:41,640
three-dimensional example and Dan's

00:13:39,990 --> 00:13:43,950
actually going to show an example of

00:13:41,640 --> 00:13:50,100
what that might look like if you render

00:13:43,950 --> 00:13:52,440
it using Maher VI yep so you can see

00:13:50,100 --> 00:13:53,940
that the points moving kind of helps you

00:13:52,440 --> 00:13:56,550
see that the unit box that they're

00:13:53,940 --> 00:13:59,430
distributed in and that the actual red

00:13:56,550 --> 00:14:04,080
points that are the closest neighbors to

00:13:59,430 --> 00:14:06,510
the center of that box I think one of

00:14:04,080 --> 00:14:08,100
the things for me about that is that is

00:14:06,510 --> 00:14:10,050
not a lot of code to actually have

00:14:08,100 --> 00:14:16,320
something up and visualized in three

00:14:10,050 --> 00:14:18,690
dimensions okay so this is kind of a bit

00:14:16,320 --> 00:14:20,730
of a pet project of mine I've been

00:14:18,690 --> 00:14:23,220
working on it for a while but I'd like

00:14:20,730 --> 00:14:26,310
to know how to actually generate a mesh

00:14:23,220 --> 00:14:28,470
a surface mesh of a function in three

00:14:26,310 --> 00:14:30,810
dimensions so that helps you do all

00:14:28,470 --> 00:14:34,830
kinds of constructive solid geometry

00:14:30,810 --> 00:14:37,440
tricks eventually so here's the function

00:14:34,830 --> 00:14:39,300
for a sphere and say I take that a bit

00:14:37,440 --> 00:14:41,340
further and I've got the function for

00:14:39,300 --> 00:14:44,660
two spheres you don't have to actually

00:14:41,340 --> 00:14:50,460
understand the maths for any of this but

00:14:44,660 --> 00:14:52,110
alright so the important thing is that

00:14:50,460 --> 00:14:53,880
you can actually understand the code so

00:14:52,110 --> 00:14:56,400
here's the code to generate a sphere and

00:14:53,880 --> 00:14:59,250
here's the code to generate multiple

00:14:56,400 --> 00:15:02,640
spheres this this example itself is

00:14:59,250 --> 00:15:04,200
actually using Syfy wave so we've hit

00:15:02,640 --> 00:15:06,120
the limits of what it's possible to do

00:15:04,200 --> 00:15:07,740
with Sego bindings at the moment and

00:15:06,120 --> 00:15:09,300
there's there's a little bit of hand

00:15:07,740 --> 00:15:11,940
waving going on will show some of the

00:15:09,300 --> 00:15:15,390
extra code that that's in C++ in a

00:15:11,940 --> 00:15:18,480
minute but the the SyFy we've called the

00:15:15,390 --> 00:15:19,500
code and the support arguments are on

00:15:18,480 --> 00:15:21,570
the next two slides

00:15:19,500 --> 00:15:23,310
we're basically bundling up a whole heap

00:15:21,570 --> 00:15:25,260
of arguments to that create mesh

00:15:23,310 --> 00:15:27,300
function and that gets passed through

00:15:25,260 --> 00:15:29,760
with the correct type annotations to the

00:15:27,300 --> 00:15:32,940
c++ we need to link in a few extra

00:15:29,760 --> 00:15:34,830
libraries so let me let me give you a

00:15:32,940 --> 00:15:38,130
taste of what it would be like to do

00:15:34,830 --> 00:15:40,590
this kind of stuff in c++ so this is

00:15:38,130 --> 00:15:42,270
this is the support code so at the top

00:15:40,590 --> 00:15:44,819
there's a whole bunch of hash includes

00:15:42,270 --> 00:15:48,089
there's a whole bunch of type deaths

00:15:44,819 --> 00:15:51,419
that are all chained and interdependent

00:15:48,089 --> 00:15:55,129
and there's a huge a huge variety of

00:15:51,419 --> 00:15:58,649
possible combinations of those things

00:15:55,129 --> 00:16:00,869
all right the the PI object implicit

00:15:58,649 --> 00:16:02,789
surface function in that third block

00:16:00,869 --> 00:16:03,689
there is probably where things start

00:16:02,789 --> 00:16:06,239
getting interesting

00:16:03,689 --> 00:16:11,189
so I po we've actually includes wrappers

00:16:06,239 --> 00:16:13,919
that you can pass you can pass Python

00:16:11,189 --> 00:16:17,699
objects into C++ code and interact with

00:16:13,919 --> 00:16:19,439
them so this the generic surface surface

00:16:17,699 --> 00:16:23,519
function at the bottom is actually

00:16:19,439 --> 00:16:25,319
unpacking C++ parameters re packing them

00:16:23,519 --> 00:16:27,899
up into something that Python can

00:16:25,319 --> 00:16:31,410
understand triggering triggering that

00:16:27,899 --> 00:16:36,149
that global function and then unpacking

00:16:31,410 --> 00:16:38,069
the result and returning it yeah so you

00:16:36,149 --> 00:16:40,999
can see it's just basically in the Segoe

00:16:38,069 --> 00:16:43,799
code that we just showed you it's going

00:16:40,999 --> 00:16:45,239
it's calling the function sphere and

00:16:43,799 --> 00:16:46,949
then space it generating all points on

00:16:45,239 --> 00:16:50,220
that sphere yeah through that callback

00:16:46,949 --> 00:16:53,519
yep yep yep

00:16:50,220 --> 00:16:55,379
and so there this is where we actually

00:16:53,519 --> 00:16:57,209
start to see the arguments that we had

00:16:55,379 --> 00:17:00,089
in that in the first of the three slides

00:16:57,209 --> 00:17:02,429
so the surface function is our a sphere

00:17:00,089 --> 00:17:04,559
function and then angular bound the

00:17:02,429 --> 00:17:06,120
radius bound and the distance bound are

00:17:04,559 --> 00:17:09,240
all the pieces of information that we

00:17:06,120 --> 00:17:11,610
had to pass in we do actual surface

00:17:09,240 --> 00:17:15,929
meshing and then we can dump all of that

00:17:11,610 --> 00:17:19,069
geometry to disk so what might that look

00:17:15,929 --> 00:17:27,240
like if you actually try to run run or

00:17:19,069 --> 00:17:29,940
visualize those results yep so like you

00:17:27,240 --> 00:17:32,279
might expect it's actually use that

00:17:29,940 --> 00:17:34,559
function to actually populate points on

00:17:32,279 --> 00:17:36,509
the boundary of the sphere and then it's

00:17:34,559 --> 00:17:41,720
actually run the triangulation on that

00:17:36,509 --> 00:17:45,059
surface for you all right

00:17:41,720 --> 00:17:48,870
what one thing to be important to know

00:17:45,059 --> 00:17:50,909
is this is a surface mesh not a internal

00:17:48,870 --> 00:17:52,139
so if we just sort of go in there think

00:17:50,909 --> 00:17:55,340
we should be other eventually getting

00:17:52,139 --> 00:17:55,340
that yep

00:18:05,400 --> 00:18:10,330
so that's actually inside the sphere so

00:18:08,740 --> 00:18:12,220
I think that's going to be more

00:18:10,330 --> 00:18:15,280
important and clearer when you actually

00:18:12,220 --> 00:18:17,620
see the next example so this is this is

00:18:15,280 --> 00:18:19,450
useful and very interesting if you're

00:18:17,620 --> 00:18:21,730
doing things like game programming and

00:18:19,450 --> 00:18:23,770
and trying to actually generate boundary

00:18:21,730 --> 00:18:26,920
meshes but in the sciences as perhaps

00:18:23,770 --> 00:18:30,250
perhaps a little less interesting so

00:18:26,920 --> 00:18:32,650
what we're really looking for is imagine

00:18:30,250 --> 00:18:34,240
that the spanner example okay it's not

00:18:32,650 --> 00:18:36,040
enough just to have a two-dimensional

00:18:34,240 --> 00:18:40,179
mesh you really want a three dimensional

00:18:36,040 --> 00:18:42,130
mesh so if you if you consider what that

00:18:40,179 --> 00:18:47,260
actually means we're looking for a

00:18:42,130 --> 00:18:48,730
tetrahedral mesh in yep we're looking

00:18:47,260 --> 00:18:52,420
for a tetrahedral mesh in three

00:18:48,730 --> 00:18:54,670
dimensions so each of the you have four

00:18:52,420 --> 00:18:56,890
points that that make up four different

00:18:54,670 --> 00:19:05,500
triangles four for each element in the

00:18:56,890 --> 00:19:09,460
mesh just go back to the slides for a

00:19:05,500 --> 00:19:13,480
minute then yeah perfect

00:19:09,460 --> 00:19:14,890
yep next next slide so this is this is

00:19:13,480 --> 00:19:16,960
the actual problem that we're trying to

00:19:14,890 --> 00:19:18,880
solve that I was talking about and so

00:19:16,960 --> 00:19:23,500
the code to do something like that looks

00:19:18,880 --> 00:19:25,870
like this okay so again very similar to

00:19:23,500 --> 00:19:27,370
the two-dimensional example except this

00:19:25,870 --> 00:19:29,890
time we have to provide a bit more

00:19:27,370 --> 00:19:31,630
information we're really looking at how

00:19:29,890 --> 00:19:33,790
bigger the facets going to be on the

00:19:31,630 --> 00:19:35,590
surface and how big are each of the

00:19:33,790 --> 00:19:37,330
cells going to be and then we can

00:19:35,590 --> 00:19:40,900
actually do our refinement process and

00:19:37,330 --> 00:19:43,720
dump the geometry out to disk yep and so

00:19:40,900 --> 00:19:45,190
the that's that's a quick picture of

00:19:43,720 --> 00:19:48,780
what they might look like and I think

00:19:45,190 --> 00:19:51,429
Dan I'll try and yeah there we go so

00:19:48,780 --> 00:19:53,170
that's the actual geometry itself but

00:19:51,429 --> 00:19:55,390
it's still we've actually cut it in half

00:19:53,170 --> 00:19:57,910
to make visualizing the results just a

00:19:55,390 --> 00:20:00,010
little bit easier but if you actually

00:19:57,910 --> 00:20:05,320
open the pipeline up and actually turn

00:20:00,010 --> 00:20:07,620
it into a wireframe mesh say surface

00:20:05,320 --> 00:20:07,620
yeah

00:20:08,450 --> 00:20:11,450
yes

00:20:12,480 --> 00:20:17,160
yep so now you can see that there's a

00:20:14,790 --> 00:20:20,690
huge number of interconnecting edges for

00:20:17,160 --> 00:20:25,350
each of the tetrahedra inside that mesh

00:20:20,690 --> 00:20:26,790
so we'll show you a second demo in the

00:20:25,350 --> 00:20:28,740
minute but it's probably important just

00:20:26,790 --> 00:20:31,470
to see and get a bit of an idea about

00:20:28,740 --> 00:20:33,540
how coarse that mesh is because the next

00:20:31,470 --> 00:20:35,310
one we show you is a bit finer so you

00:20:33,540 --> 00:20:38,130
actually have some scope to actually

00:20:35,310 --> 00:20:39,660
change change the parameters and and get

00:20:38,130 --> 00:20:43,320
the mesh refined in the way that you

00:20:39,660 --> 00:20:45,810
want yep so again you can see that the

00:20:43,320 --> 00:20:49,970
triangles on on each of their facets and

00:20:45,810 --> 00:20:49,970
cells are actually significantly smaller

00:20:50,330 --> 00:20:54,390
yeah could show you the inside but it's

00:20:53,100 --> 00:21:04,620
pretty much gonna be a y frame mess

00:20:54,390 --> 00:21:07,100
right so yeah so we've talked about an

00:21:04,620 --> 00:21:12,270
awful lot of different packages inside

00:21:07,100 --> 00:21:13,860
Seigle and inside Sify so I just wanted

00:21:12,270 --> 00:21:16,290
to actually present just a little bit of

00:21:13,860 --> 00:21:18,720
a summary slide just to remind people of

00:21:16,290 --> 00:21:20,940
where we've been if you're looking for

00:21:18,720 --> 00:21:23,220
basic intersection tests you're looking

00:21:20,940 --> 00:21:24,780
for CL kernel if you're looking to do

00:21:23,220 --> 00:21:26,520
triangulations in two and three

00:21:24,780 --> 00:21:28,590
dimensions there's triangulation

00:21:26,520 --> 00:21:30,840
packages there's mesh refinement

00:21:28,590 --> 00:21:32,070
packages one of the things that we

00:21:30,840 --> 00:21:34,440
didn't think we were going to have time

00:21:32,070 --> 00:21:37,020
to do but I think we might have is is

00:21:34,440 --> 00:21:39,750
the Alpha shapes examples that that you

00:21:37,020 --> 00:21:43,980
can use to refine point clouds back to

00:21:39,750 --> 00:21:45,570
boundary meshes and of course we talked

00:21:43,980 --> 00:21:48,420
about cyclo spatial for doing the

00:21:45,570 --> 00:21:51,420
nearest neighbors problem and so I we've

00:21:48,420 --> 00:21:54,960
force doing some native code integration

00:21:51,420 --> 00:21:56,760
as well so thank you very much for

00:21:54,960 --> 00:21:59,210
taking the time to come along and listen

00:21:56,760 --> 00:21:59,210
to us today

00:22:04,549 --> 00:22:15,929
thanks guys if anybody's got questions

00:22:09,379 --> 00:22:18,419
questions right Frank Sainsbury you were

00:22:15,929 --> 00:22:20,489
talking about animating the changing of

00:22:18,419 --> 00:22:23,070
the positions of nodes I thought at one

00:22:20,489 --> 00:22:24,019
stage in your talk so an example of that

00:22:23,070 --> 00:22:27,330
sort of thing

00:22:24,019 --> 00:22:28,169
animating the 3d visualizations oh yeah

00:22:27,330 --> 00:22:29,999
I thought you were talking about

00:22:28,169 --> 00:22:31,649
interacting with the nodes in some way

00:22:29,999 --> 00:22:34,950
but actually I missed that or

00:22:31,649 --> 00:22:37,139
misunderstood I'm there are some

00:22:34,950 --> 00:22:40,259
libraries charco in particular that will

00:22:37,139 --> 00:22:42,570
let you do some interaction we're still

00:22:40,259 --> 00:22:45,210
really just starting to get started with

00:22:42,570 --> 00:22:47,549
that stuff right and you know it's it's

00:22:45,210 --> 00:22:49,679
very early days I think I think we'll

00:22:47,549 --> 00:22:50,700
continue to look at it though for some

00:22:49,679 --> 00:22:58,889
types of problems

00:22:50,700 --> 00:23:00,450
yeah so what sort of limits did you come

00:22:58,889 --> 00:23:04,019
up with the amount of points that you

00:23:00,450 --> 00:23:07,529
can put into your UK dimensional map

00:23:04,019 --> 00:23:09,029
well it's n dimensional so I mean that's

00:23:07,529 --> 00:23:12,899
that's probably the first thing for the

00:23:09,029 --> 00:23:14,549
scientists in the room to know we

00:23:12,899 --> 00:23:16,259
haven't pushed it as far as we probably

00:23:14,549 --> 00:23:18,090
need to to actually give you an answer

00:23:16,259 --> 00:23:24,239
to that but yeah it would it would be an

00:23:18,090 --> 00:23:28,519
interesting thing to look at today

00:23:24,239 --> 00:23:30,119
the the actual C Galco nor with the

00:23:28,519 --> 00:23:32,399
intersections and things there's a

00:23:30,119 --> 00:23:34,470
handle other spatial relationships like

00:23:32,399 --> 00:23:35,159
points contained within shapes things

00:23:34,470 --> 00:23:39,710
like that

00:23:35,159 --> 00:23:42,599
they're the triangulations definitely do

00:23:39,710 --> 00:23:45,470
there's a there's a point contains test

00:23:42,599 --> 00:23:49,970
a location test I believe it's called

00:23:45,470 --> 00:23:52,799
for some of the others yes it does but

00:23:49,970 --> 00:23:55,049
I'm not sure whether that's exposed in

00:23:52,799 --> 00:23:56,759
the Python bindings at the moment so

00:23:55,049 --> 00:23:58,979
they're very much prioritize the things

00:23:56,759 --> 00:24:01,379
that they need to get done to address

00:23:58,979 --> 00:24:03,119
their particular research concerns but

00:24:01,379 --> 00:24:05,070
there's a very active developer

00:24:03,119 --> 00:24:07,940
community and and I can see those things

00:24:05,070 --> 00:24:07,940
coming in the near future

00:24:13,980 --> 00:24:20,309
I'm so you said you could do point cloud

00:24:17,730 --> 00:24:21,570
and turn that into a mesh ya can use a

00:24:20,309 --> 00:24:23,730
lab right on that is that does that mean

00:24:21,570 --> 00:24:26,280
you can like scan a 3d object and turn

00:24:23,730 --> 00:24:31,559
it into polygon mesh there there is some

00:24:26,280 --> 00:24:33,090
code in C go for doing that so there's

00:24:31,559 --> 00:24:36,330
some there's some surface reconstruction

00:24:33,090 --> 00:24:38,490
code but that isn't that is definitely

00:24:36,330 --> 00:24:41,220
not in the bindings at the moment so if

00:24:38,490 --> 00:24:43,140
you want to get involved you can go and

00:24:41,220 --> 00:24:45,059
have a look at the google code project I

00:24:43,140 --> 00:24:47,100
mean we're certainly not involved we're

00:24:45,059 --> 00:24:48,750
not we don't own the project we're just

00:24:47,100 --> 00:24:50,910
starting to make some contributions but

00:24:48,750 --> 00:24:57,090
yeah they're looking for as much help as

00:24:50,910 --> 00:24:58,350
they can get you talked you talked about

00:24:57,090 --> 00:25:00,120
writing outer disk

00:24:58,350 --> 00:25:02,700
yeah the libraries have their own file

00:25:00,120 --> 00:25:04,620
formats or or most of the formats that

00:25:02,700 --> 00:25:09,270
they're writing to actually standard

00:25:04,620 --> 00:25:11,549
formats the Oh F F and the met it so met

00:25:09,270 --> 00:25:13,980
it is actually a French geometry format

00:25:11,549 --> 00:25:17,400
for writing tetrahedral meshes which is

00:25:13,980 --> 00:25:20,220
standard in scientific communities the

00:25:17,400 --> 00:25:22,260
off format you can actually access that

00:25:20,220 --> 00:25:25,110
from something like mesh lab and convert

00:25:22,260 --> 00:25:30,630
it to a more standard format like an obj

00:25:25,110 --> 00:25:33,140
away from an obj or STL format if you if

00:25:30,630 --> 00:25:33,140
you need to

00:25:40,520 --> 00:25:48,110
what's that format they use for 3d

00:25:43,669 --> 00:25:49,970
printers STL I believe okay in many

00:25:48,110 --> 00:25:52,010
cases so you can export to that can you

00:25:49,970 --> 00:25:53,690
I don't know whether you can export to

00:25:52,010 --> 00:25:55,700
it directly at the moment but it's

00:25:53,690 --> 00:25:58,070
certainly trivial to actually use a

00:25:55,700 --> 00:26:02,450
conversion tool to get tests here right

00:25:58,070 --> 00:26:03,830
interesting mesh labs probably gonna be

00:26:02,450 --> 00:26:10,419
the best like one of the easiest ones on

00:26:03,830 --> 00:26:10,419
linux for that just about anybody else

00:26:15,030 --> 00:26:19,860
oh yeah how so along the lines at the

00:26:17,100 --> 00:26:23,120
open STL format thing there's a program

00:26:19,860 --> 00:26:25,230
called open s code which is like suggest

00:26:23,120 --> 00:26:27,290
to something that's possibly going to be

00:26:25,230 --> 00:26:30,060
possible to do that easily in Pisan

00:26:27,290 --> 00:26:31,830
these this is actually something that I

00:26:30,060 --> 00:26:33,540
actually forgot to talk about open s

00:26:31,830 --> 00:26:35,010
code is probably one of the most

00:26:33,540 --> 00:26:38,130
important computational geometry

00:26:35,010 --> 00:26:39,600
projects out there at the moment if you

00:26:38,130 --> 00:26:41,730
haven't looked at it go and have a look

00:26:39,600 --> 00:26:44,550
at it it's a programmers CAD package

00:26:41,730 --> 00:26:46,890
that will let you construct things and

00:26:44,550 --> 00:26:49,920
join them together merge and do

00:26:46,890 --> 00:26:52,140
different operations it's it's also

00:26:49,920 --> 00:26:55,230
implemented using Siegel strangely

00:26:52,140 --> 00:26:57,630
enough the important part of the Siegel

00:26:55,230 --> 00:27:00,120
library that's missing from the bindings

00:26:57,630 --> 00:27:02,460
at the moment Neph polyhedra is actually

00:27:00,120 --> 00:27:05,010
coming there's actually been an awful

00:27:02,460 --> 00:27:07,280
lot of active chat in the in the

00:27:05,010 --> 00:27:10,980
discussion groups on doing exactly that

00:27:07,280 --> 00:27:13,980
if you if you can't wait there's already

00:27:10,980 --> 00:27:16,140
bindings in Python to actually grab open

00:27:13,980 --> 00:27:20,510
s CAD so there's a github project for

00:27:16,140 --> 00:27:20,510
that so I can show you later if you want

00:27:20,750 --> 00:27:26,660
any other questions

00:27:22,640 --> 00:27:26,660
we've got time so

00:27:28,960 --> 00:27:37,600
okay well thanks very much guys there's

00:27:32,870 --> 00:27:40,390
a mug and some coffee

00:27:37,600 --> 00:27:43,390
thank you enjoy please share with each

00:27:40,390 --> 00:27:43,390

YouTube URL: https://www.youtube.com/watch?v=zWhMc3am7ao


