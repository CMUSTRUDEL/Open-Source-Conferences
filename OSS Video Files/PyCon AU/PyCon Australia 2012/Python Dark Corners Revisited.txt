Title: Python Dark Corners Revisited
Publication date: 2012-08-23
Playlist: PyCon Australia 2012
Description: 
	Peter Lovett
Python can be deceptive - it looks so simple. Surely it will take only 5 to 10 minutes to learn.
Self taught programmers often miss important fundamentals in Python - including:
* Everything is an Object. Yes everything. Integers, 'rea
Captions: 
	00:00:03,620 --> 00:00:08,400
good afternoon everyone I hope you had a

00:00:06,390 --> 00:00:11,519
good lunch everyone's ready and settled

00:00:08,400 --> 00:00:12,630
in for a good talk just the public

00:00:11,519 --> 00:00:14,969
service announcements that we've been

00:00:12,630 --> 00:00:16,619
making today please if you're not using

00:00:14,969 --> 00:00:17,940
the wireless if you can just disconnect

00:00:16,619 --> 00:00:19,260
from the network to give it a bit of a

00:00:17,940 --> 00:00:22,140
breather so that everyone who does need

00:00:19,260 --> 00:00:24,600
it can actually get an internet

00:00:22,140 --> 00:00:27,320
connection also obviously your usual

00:00:24,600 --> 00:00:31,230
housekeeping mobile phones on silent etc

00:00:27,320 --> 00:00:34,160
our speaker this afternoon has over 30

00:00:31,230 --> 00:00:36,690
years experience working as a programmer

00:00:34,160 --> 00:00:38,579
and also conducts Python training

00:00:36,690 --> 00:00:41,309
throughout Australia New Zealand through

00:00:38,579 --> 00:00:43,200
his company plus plus and this afternoon

00:00:41,309 --> 00:00:45,539
he's going to talk to us about the dark

00:00:43,200 --> 00:00:47,879
corners of Python which is not a fanfic

00:00:45,539 --> 00:00:56,699
conference I'll hand it over to Peter

00:00:47,879 --> 00:01:00,660
love it please give him a welcome thank

00:00:56,699 --> 00:01:02,699
you yes where to start

00:01:00,660 --> 00:01:06,030
pythons dark corners this is the talk

00:01:02,699 --> 00:01:08,850
that I'd rather not give the horror of

00:01:06,030 --> 00:01:11,700
the moment I shall never never forget so

00:01:08,850 --> 00:01:14,640
let's make a Memorandum of what can go

00:01:11,700 --> 00:01:15,930
wrong I just a tiny bit about me my

00:01:14,640 --> 00:01:18,720
name's Peter love it I have three

00:01:15,930 --> 00:01:26,939
decades of paid programming anyone here

00:01:18,720 --> 00:01:29,250
under 30 yes I'm just just in June

00:01:26,939 --> 00:01:30,360
clicked clicked 30 years of paid

00:01:29,250 --> 00:01:32,400
programming I've been running

00:01:30,360 --> 00:01:37,549
programming courses since 85 pythons

00:01:32,400 --> 00:01:39,659
since 2007 that's my company there we go

00:01:37,549 --> 00:01:41,340
that's a bit about me what else wanted

00:01:39,659 --> 00:01:47,579
to I like long walks on the beach

00:01:41,340 --> 00:01:48,899
meeting people faith hope and love so

00:01:47,579 --> 00:01:51,990
and over you what we're going to be

00:01:48,899 --> 00:01:53,790
covering this afternoon is what I'm

00:01:51,990 --> 00:01:55,200
covering is two point X although I will

00:01:53,790 --> 00:01:56,759
be giving you some three-point tips

00:01:55,200 --> 00:01:58,850
there's actually a couple of these dark

00:01:56,759 --> 00:02:00,840
corners that are solved in version three

00:01:58,850 --> 00:02:03,119
the are beginning of the aims and

00:02:00,840 --> 00:02:05,040
objectives of each of the the points

00:02:03,119 --> 00:02:07,950
that we look at how to avoid them that's

00:02:05,040 --> 00:02:11,190
the point and at the end I'll be taking

00:02:07,950 --> 00:02:13,910
quite whatever questions you have so let

00:02:11,190 --> 00:02:17,010
me start up by saying I love Python

00:02:13,910 --> 00:02:18,780
i-i've actually worked and been paid in

00:02:17,010 --> 00:02:23,900
languages of every letter of the

00:02:18,780 --> 00:02:26,459
alphabet from APL to z8 he assembler and

00:02:23,900 --> 00:02:28,709
I love Python I still work in other

00:02:26,459 --> 00:02:31,110
languages predominantly C++ and Python

00:02:28,709 --> 00:02:32,340
Python is the language to know if you

00:02:31,110 --> 00:02:35,190
only need to know one language learn

00:02:32,340 --> 00:02:38,250
paithan c++ complements that really well

00:02:35,190 --> 00:02:41,790
so do quite a work bit of working in C++

00:02:38,250 --> 00:02:43,739
Perl Java etc but I love Python pythons

00:02:41,790 --> 00:02:45,989
my language of choice it's fantastic

00:02:43,739 --> 00:02:47,970
language however it's not perfect and

00:02:45,989 --> 00:02:50,430
I'm often coming into companies that

00:02:47,970 --> 00:02:53,670
have lots of self-taught Python

00:02:50,430 --> 00:02:55,380
programmers possibly like you and I find

00:02:53,670 --> 00:02:56,700
that people like when their self port

00:02:55,380 --> 00:02:58,380
they learn the things they think they

00:02:56,700 --> 00:03:00,299
need to know really well and there might

00:02:58,380 --> 00:03:02,160
be a few gaps in your knowledge so my

00:03:00,299 --> 00:03:04,049
aim for this afternoon is to fill in

00:03:02,160 --> 00:03:05,910
some of those gaps help you avoid some

00:03:04,049 --> 00:03:09,930
of the traps that I've fallen into and

00:03:05,910 --> 00:03:12,600
I've seen other people fall into Python

00:03:09,930 --> 00:03:14,069
I find is a deceptive language people

00:03:12,600 --> 00:03:18,090
that are self-taught look at Python they

00:03:14,069 --> 00:03:20,609
go oh yeah I get that if else easy I can

00:03:18,090 --> 00:03:22,590
do this this is quite straightforward C

00:03:20,609 --> 00:03:24,870
programmers stumble over for loop go

00:03:22,590 --> 00:03:26,730
well that's a bit weird but generally I

00:03:24,870 --> 00:03:28,650
can get a while to work and it looks

00:03:26,730 --> 00:03:29,850
it's but it's a deceptive language

00:03:28,650 --> 00:03:33,120
because there's actually a lot of

00:03:29,850 --> 00:03:37,200
trickiness and a lot of cleverness in

00:03:33,120 --> 00:03:38,870
behind the scenes so there is and the

00:03:37,200 --> 00:03:42,120
thing that no one wants to talk about

00:03:38,870 --> 00:03:43,829
the elephant in the corner so what is

00:03:42,120 --> 00:03:50,579
the elephant in the corner not that

00:03:43,829 --> 00:03:53,519
elephant that's Python sucks 3.8 million

00:03:50,579 --> 00:03:56,220
results however don't feel bad I gave

00:03:53,519 --> 00:03:58,829
this talk this similar talk to this last

00:03:56,220 --> 00:04:01,680
year and last year we were at 4.4

00:03:58,829 --> 00:04:03,930
million so we're really significantly

00:04:01,680 --> 00:04:07,850
improving and certainly python

00:04:03,930 --> 00:04:07,850
programmers shouldn't feel bad because

00:04:07,900 --> 00:04:14,140
Java sucks has over ten named and really

00:04:12,519 --> 00:04:15,549
I've gotta tell you on that 3.8 million

00:04:14,140 --> 00:04:17,739
you know like three point eight

00:04:15,549 --> 00:04:20,049
something of million of them Iran

00:04:17,739 --> 00:04:23,290
some people say Python sucks but really

00:04:20,049 --> 00:04:25,030
it doesn't it's a great language let me

00:04:23,290 --> 00:04:28,410
show you something else about the dark

00:04:25,030 --> 00:04:32,470
corners now anyone know what this is

00:04:28,410 --> 00:04:37,270
it's a graphic who said that yes

00:04:32,470 --> 00:04:40,479
the man wins a t-shirt well done an

00:04:37,270 --> 00:04:41,320
exclusive it is a graph can add a little

00:04:40,479 --> 00:04:43,479
bit more detail

00:04:41,320 --> 00:04:47,350
it is a trading graph anyone know what

00:04:43,479 --> 00:04:49,660
it solve no it's a it's the share price

00:04:47,350 --> 00:04:50,860
in blue and the volume traded in red of

00:04:49,660 --> 00:04:53,050
an American company called Knight

00:04:50,860 --> 00:04:54,460
capital this happened at the first I

00:04:53,050 --> 00:04:56,080
think or the first or second of August

00:04:54,460 --> 00:04:58,780
some of you might have heard about this

00:04:56,080 --> 00:05:01,120
as programmers we need to know about

00:04:58,780 --> 00:05:03,430
stuff like this this company like

00:05:01,120 --> 00:05:05,710
capital trade something like ten percent

00:05:03,430 --> 00:05:07,270
of the volume of shares traded in the

00:05:05,710 --> 00:05:10,660
exchange that they work in in America

00:05:07,270 --> 00:05:13,900
really big share trading company high

00:05:10,660 --> 00:05:16,650
frequency trades equals software-driven

00:05:13,900 --> 00:05:21,280
equals algorithm driven they had a

00:05:16,650 --> 00:05:24,430
technical issue and their program went

00:05:21,280 --> 00:05:27,130
wrong hasn't come out yet exactly what

00:05:24,430 --> 00:05:29,889
went wrong and I don't know whether it

00:05:27,130 --> 00:05:31,539
was Python specifically to blame because

00:05:29,889 --> 00:05:35,169
it's high frequency trading I'm guessing

00:05:31,539 --> 00:05:36,729
C++ actually but this is what happened

00:05:35,169 --> 00:05:39,430
to the sheriff share price when they

00:05:36,729 --> 00:05:41,770
announced that they lost for four

00:05:39,430 --> 00:05:47,470
hundred and forty million dollars in

00:05:41,770 --> 00:05:49,449
half an hour so I need to put that into

00:05:47,470 --> 00:05:51,039
US you might not be doing a high

00:05:49,449 --> 00:05:53,680
frequency trading but all of us have

00:05:51,039 --> 00:05:55,449
jobs that use Python and you might think

00:05:53,680 --> 00:05:57,970
that it's not that important but it may

00:05:55,449 --> 00:05:59,380
well be very important the the phrase

00:05:57,970 --> 00:06:00,699
that needs to jump into our minds is

00:05:59,380 --> 00:06:03,430
what's the worst thing that could

00:06:00,699 --> 00:06:04,990
possibly happen this is very

00:06:03,430 --> 00:06:06,460
instructional because there was they

00:06:04,990 --> 00:06:08,620
discovered the problem within about two

00:06:06,460 --> 00:06:11,080
or three minutes and there was no kill

00:06:08,620 --> 00:06:12,610
switch there was no pull the plug that

00:06:11,080 --> 00:06:15,789
it just kept on trading and getting them

00:06:12,610 --> 00:06:18,580
into more trouble for half an hour so

00:06:15,789 --> 00:06:21,260
let me put the the fear of fear of God

00:06:18,580 --> 00:06:24,150
fear of programming into

00:06:21,260 --> 00:06:25,920
so like I said I know they use Python

00:06:24,150 --> 00:06:28,560
but I don't know if I can specifically

00:06:25,920 --> 00:06:30,270
was implicated in that issue so what

00:06:28,560 --> 00:06:33,000
we're going to look at is some aspects

00:06:30,270 --> 00:06:34,350
of Python everything is an object it's

00:06:33,000 --> 00:06:36,240
only a name types have a change in

00:06:34,350 --> 00:06:38,100
objects type important types what's a

00:06:36,240 --> 00:06:40,560
constant accidental name creation

00:06:38,100 --> 00:06:43,350
surprising namespace rules arguments and

00:06:40,560 --> 00:06:52,140
then questions so firstly everything is

00:06:43,350 --> 00:06:58,920
an object even built-in types so I is an

00:06:52,140 --> 00:07:01,650
object I has methods and attributes it's

00:06:58,920 --> 00:07:04,650
not a little for my seat programmers

00:07:01,650 --> 00:07:06,390
it's not a 2-byte or a four byte these

00:07:04,650 --> 00:07:10,470
several piece of memory it's an object

00:07:06,390 --> 00:07:12,960
with methods and data attributes let me

00:07:10,470 --> 00:07:17,040
just check actually who on the Python

00:07:12,960 --> 00:07:19,320
scale who regularly uses Python yep good

00:07:17,040 --> 00:07:23,100
who uses Python as your primary

00:07:19,320 --> 00:07:24,690
programming language lovely and of those

00:07:23,100 --> 00:07:32,990
that don't use Python as a primary

00:07:24,690 --> 00:07:37,100
language who uses a c c++ good Java VB

00:07:32,990 --> 00:07:40,890
assembler yay

00:07:37,100 --> 00:07:43,230
okay good eye is nothing like a C

00:07:40,890 --> 00:07:46,260
integer note that I could do things like

00:07:43,230 --> 00:07:48,120
get a directory list of it the dir

00:07:46,260 --> 00:07:49,980
function is your friend you need to know

00:07:48,120 --> 00:07:51,390
the dir function tells you all the

00:07:49,980 --> 00:07:53,610
attributes and the methods in there

00:07:51,390 --> 00:07:58,230
gives you a nice list of them as strings

00:07:53,610 --> 00:08:03,960
so if I've got a string like ABC then

00:07:58,230 --> 00:08:05,610
ABC has a whole raft of methods the dir

00:08:03,960 --> 00:08:08,120
on Mobius thing actually what I wanted

00:08:05,610 --> 00:08:10,920
to do was make that into an object

00:08:08,120 --> 00:08:13,500
everything in an object everything in

00:08:10,920 --> 00:08:16,500
Python is an object doesn't get a dir of

00:08:13,500 --> 00:08:19,140
that there's a lot there you can even

00:08:16,500 --> 00:08:22,260
get the type of an object I looks like

00:08:19,140 --> 00:08:25,640
that it's an object of type int and the

00:08:22,260 --> 00:08:29,460
type of s is that it's a string

00:08:25,640 --> 00:08:32,310
everything is an object even functions

00:08:29,460 --> 00:08:33,539
are going to define myself a function PS

00:08:32,310 --> 00:08:35,430
if you're not used to using the

00:08:33,539 --> 00:08:38,310
interactive shell in Python get used to

00:08:35,430 --> 00:08:38,969
it I live here this is like I wonder

00:08:38,310 --> 00:08:41,729
what that does

00:08:38,969 --> 00:08:45,240
ah that's what that does define a

00:08:41,729 --> 00:08:47,279
function what does it dude not much so

00:08:45,240 --> 00:08:50,330
let me get a directory list I didn't

00:08:47,279 --> 00:08:54,390
really do much on that function but oh

00:08:50,330 --> 00:08:59,760
sorry I did missed one extra inter I

00:08:54,390 --> 00:09:00,270
hope my function is still good no that's

00:08:59,760 --> 00:09:05,010
all right

00:09:00,270 --> 00:09:07,440
luckily I can do that so a dir on

00:09:05,010 --> 00:09:10,790
function is look at all the goodies that

00:09:07,440 --> 00:09:14,520
I got even a function is a object

00:09:10,790 --> 00:09:19,470
modules are objects import math get a

00:09:14,520 --> 00:09:25,680
dir on math whoops and run it as a

00:09:19,470 --> 00:09:29,510
function there's a whole lot of stuff

00:09:25,680 --> 00:09:32,640
there so everything's an object so but

00:09:29,510 --> 00:09:34,800
let me even jump forwards of tiny bit

00:09:32,640 --> 00:09:36,810
even functions or objects modules or

00:09:34,800 --> 00:09:39,089
objects I'm gonna skip forward for a

00:09:36,810 --> 00:09:40,770
tick and come back to those other ones

00:09:39,089 --> 00:09:44,610
because I want to look at it's only a

00:09:40,770 --> 00:09:49,320
name so if everything is an object let

00:09:44,610 --> 00:09:51,180
me go and set a to be a list and let me

00:09:49,320 --> 00:09:56,520
go and print a that's what a looks like

00:09:51,180 --> 00:10:03,020
let me set B to a if I go in a pinned

00:09:56,520 --> 00:10:06,860
onto the end of a it looks like whoops

00:10:03,020 --> 00:10:07,980
that's not actually what I wanted to do

00:10:06,860 --> 00:10:14,580
sorry

00:10:07,980 --> 00:10:16,530
a is a list let me go an append the

00:10:14,580 --> 00:10:21,770
number 4 onto the end of a Oh looks like

00:10:16,530 --> 00:10:28,950
that if I've set B to a previously what

00:10:21,770 --> 00:10:37,140
what is B what is be the same as a we've

00:10:28,950 --> 00:10:39,810
got a 1 2 3 or a 1 2 3 4 1 2 3 1 2 3 4

00:10:37,140 --> 00:10:42,180
it's a crucial thing to know this is not

00:10:39,810 --> 00:10:43,950
something to get mistakes on I could

00:10:42,180 --> 00:10:44,680
actually find out if I do

00:10:43,950 --> 00:10:49,360
Oh

00:10:44,680 --> 00:10:56,700
that doesn't even sorry let me let me

00:10:49,360 --> 00:11:02,230
start let me go and yes it was sorry

00:10:56,700 --> 00:11:02,890
they get say it gets appended hey looks

00:11:02,230 --> 00:11:05,950
like that

00:11:02,890 --> 00:11:07,180
and B looks like that and the reason

00:11:05,950 --> 00:11:12,130
that it looks like that or the way to

00:11:07,180 --> 00:11:13,990
tell is not with the equals equals won't

00:11:12,130 --> 00:11:15,970
tell you whether that's actually really

00:11:13,990 --> 00:11:18,100
the problem that will tell you that they

00:11:15,970 --> 00:11:20,080
have the same value but what would

00:11:18,100 --> 00:11:24,339
really tell you that they are the same

00:11:20,080 --> 00:11:27,190
is is - programmers have to know about

00:11:24,339 --> 00:11:30,250
is is is used for do these references

00:11:27,190 --> 00:11:31,000
both point to the same object and yes

00:11:30,250 --> 00:11:32,620
they do

00:11:31,000 --> 00:11:35,290
as a side note you could play around

00:11:32,620 --> 00:11:37,540
maybe with the ID of those things what's

00:11:35,290 --> 00:11:43,300
the ID of that thing that we are

00:11:37,540 --> 00:11:46,990
pointing at and that tells me that they

00:11:43,300 --> 00:11:51,640
are objects so let me go and set X to 1

00:11:46,990 --> 00:11:55,390
Y to X actually even before I do that X

00:11:51,640 --> 00:12:05,320
is 1 let me go and say what's the value

00:11:55,390 --> 00:12:09,540
of plus plus X 2 who said that I'm going

00:12:05,320 --> 00:12:11,560
to give you a t-shirt you're wrong

00:12:09,540 --> 00:12:21,430
but you know I got to encourage

00:12:11,560 --> 00:12:24,160
participation by the way this is Python

00:12:21,430 --> 00:12:28,300
this is not C there is no plus +

00:12:24,160 --> 00:12:30,130
operator there is some people going on

00:12:28,300 --> 00:12:32,020
ok so there's no plus + operator what's

00:12:30,130 --> 00:12:37,870
that doing what's really giving me the

00:12:32,020 --> 00:12:43,300
positive of the positive of X which

00:12:37,870 --> 00:12:45,399
means that the minus - of X would be the

00:12:43,300 --> 00:12:46,690
negative of the negative let me get ask

00:12:45,399 --> 00:12:52,170
you what's the negative of the negative

00:12:46,690 --> 00:12:52,170
of the negative of any one - one

00:12:52,270 --> 00:12:56,080
look I had a 50% chance of getting that

00:12:54,490 --> 00:12:58,750
one right so I just had a stair bet at

00:12:56,080 --> 00:13:02,680
okay can't so the reason I plus plus of

00:12:58,750 --> 00:13:04,959
course X plus plus is a syntax error

00:13:02,680 --> 00:13:07,360
invalid syntax there's no plus plus I'm

00:13:04,959 --> 00:13:09,870
jumping ahead of myself though but this

00:13:07,360 --> 00:13:17,740
is the Python course not the C++ course

00:13:09,870 --> 00:13:19,420
well if X is 1 and I set Y to X now let

00:13:17,740 --> 00:13:22,270
me go an increment X I know I can't do

00:13:19,420 --> 00:13:24,490
it with plus plus so I'll do it X gets X

00:13:22,270 --> 00:13:33,180
plus 1 or for the enlightened amongst

00:13:24,490 --> 00:13:33,180
you X plus equals 1 X is now 2 what is y

00:13:33,839 --> 00:13:39,070
this is I hate to break it to you this

00:13:36,640 --> 00:13:40,630
really simple stuff like you got to get

00:13:39,070 --> 00:13:43,230
this right if you get this wrong you had

00:13:40,630 --> 00:13:45,640
just sunk

00:13:43,230 --> 00:13:49,089
maybe I'll break it down and say what

00:13:45,640 --> 00:13:53,350
does that do X plus equals 1 is really X

00:13:49,089 --> 00:13:56,920
gets X plus 1 which really is X gets me

00:13:53,350 --> 00:14:00,040
a brand new integer with the old value

00:13:56,920 --> 00:14:06,370
of x and commented with one that's valid

00:14:00,040 --> 00:14:07,089
syntax X is now 3 but when did Y get

00:14:06,370 --> 00:14:13,570
changed

00:14:07,089 --> 00:14:17,649
well didn't why not because that is not

00:14:13,570 --> 00:14:20,050
changing X it's in Python are immutable

00:14:17,649 --> 00:14:23,190
unchangeable cannot be changed you can't

00:14:20,050 --> 00:14:27,430
change an int or a float or a tuple or

00:14:23,190 --> 00:14:30,399
lots of things complex number in sorry

00:14:27,430 --> 00:14:33,160
mutable so that doesn't change X it

00:14:30,399 --> 00:14:36,130
makes the X pointer for my C programmers

00:14:33,160 --> 00:14:39,070
point at a new object with a different

00:14:36,130 --> 00:14:43,600
value I could define this too and say is

00:14:39,070 --> 00:14:46,959
X is y know the ID of X is that it's

00:14:43,600 --> 00:14:49,839
there but the ID of Y is that it's a

00:14:46,959 --> 00:14:54,640
completely different object so you need

00:14:49,839 --> 00:14:55,570
to understand that every name is really

00:14:54,640 --> 00:14:57,250
just a pointer

00:14:55,570 --> 00:15:00,190
it's an automatically dereferenced

00:14:57,250 --> 00:15:01,930
pointer it's a reference well if every

00:15:00,190 --> 00:15:04,510
object everything is an object I can do

00:15:01,930 --> 00:15:05,350
the same with functions the absolute

00:15:04,510 --> 00:15:09,009
value

00:15:05,350 --> 00:15:13,740
- for using the built-in is for function

00:15:09,009 --> 00:15:15,399
points - abs so I can now get the F of

00:15:13,740 --> 00:15:18,730
minus four

00:15:15,399 --> 00:15:31,060
I could have myself a list of functions

00:15:18,730 --> 00:15:38,259
O of F and abs and dearth sweet for each

00:15:31,060 --> 00:15:41,050
function in the list of functions print

00:15:38,259 --> 00:15:48,220
me out the function print me out the

00:15:41,050 --> 00:15:50,380
function of whatever for for and there's

00:15:48,220 --> 00:15:53,350
the dir of four so for my sleep

00:15:50,380 --> 00:15:54,699
programmers that are after a array of

00:15:53,350 --> 00:15:58,480
pointers to functions

00:15:54,699 --> 00:16:01,660
I love Python just remember that

00:15:58,480 --> 00:16:03,600
everything is a object and it's um every

00:16:01,660 --> 00:16:06,970
name is just a name it's just a name

00:16:03,600 --> 00:16:10,269
therefore if I've imported math impotant

00:16:06,970 --> 00:16:11,860
it if I have imported math then that's

00:16:10,269 --> 00:16:20,519
just a name so I could have a different

00:16:11,860 --> 00:16:23,519
name and do the n dot square root of -1

00:16:20,519 --> 00:16:23,519
anyone

00:16:28,380 --> 00:16:33,150
yeah it's domain era however if I'd used

00:16:31,350 --> 00:16:34,590
see math for the complex number of

00:16:33,150 --> 00:16:36,690
mathematics then it would be a different

00:16:34,590 --> 00:16:40,890
answer would have got I or J really is

00:16:36,690 --> 00:16:46,500
the actual syntax cool it's just a name

00:16:40,890 --> 00:16:49,110
it's just a name so everything is an

00:16:46,500 --> 00:16:50,730
object built-in types are objects

00:16:49,110 --> 00:16:55,110
functions or objects modules are from

00:16:50,730 --> 00:16:59,370
objects user-defined types are objects

00:16:55,110 --> 00:17:03,810
so I can go and create oops me my own

00:16:59,370 --> 00:17:06,750
class call it I don't know whatever and

00:17:03,810 --> 00:17:09,390
it will have a contents of doesn't

00:17:06,750 --> 00:17:14,610
matter but I can build objects of that

00:17:09,390 --> 00:17:16,770
class see gets a new C object no this is

00:17:14,610 --> 00:17:18,330
not the nicest way to do it this is

00:17:16,770 --> 00:17:20,130
module that version two I should

00:17:18,330 --> 00:17:25,350
probably really be inheriting from

00:17:20,130 --> 00:17:30,150
object but I can still do that in Python

00:17:25,350 --> 00:17:31,530
three all objects object and it's still

00:17:30,150 --> 00:17:33,300
got stuff in it even though I didn't

00:17:31,530 --> 00:17:35,820
actually really put anything in it if

00:17:33,300 --> 00:17:40,680
that is an object even a class

00:17:35,820 --> 00:17:44,400
definition is an object for my Java

00:17:40,680 --> 00:17:46,680
friends that want a factory let me

00:17:44,400 --> 00:17:51,750
create a factory that takes a class

00:17:46,680 --> 00:17:55,230
definition as its argument and go and

00:17:51,750 --> 00:17:59,430
return a build me a new object of that

00:17:55,230 --> 00:18:03,750
class so I can now build a go and call

00:17:59,430 --> 00:18:06,330
factory building me an object of this

00:18:03,750 --> 00:18:16,100
type everything's an object even a class

00:18:06,330 --> 00:18:19,950
definition hmm it's a C class object

00:18:16,100 --> 00:18:22,260
everything's an object we even have

00:18:19,950 --> 00:18:23,940
metaclasses it's worthwhile me just

00:18:22,260 --> 00:18:27,270
mentioning that everything is derived

00:18:23,940 --> 00:18:29,490
from object with a curious little switch

00:18:27,270 --> 00:18:31,350
that we can't have meta classes which

00:18:29,490 --> 00:18:35,760
are actually derived not from object but

00:18:31,350 --> 00:18:37,950
from type so it's only a name every

00:18:35,760 --> 00:18:40,200
names a reference we've had a look at

00:18:37,950 --> 00:18:41,520
those the importance of is don't get

00:18:40,200 --> 00:18:45,890
confused with equal

00:18:41,520 --> 00:18:48,930
cool it's only a name it's only a name

00:18:45,890 --> 00:18:50,700
but it's important name let me go and

00:18:48,930 --> 00:18:53,250
create a string called this is the

00:18:50,700 --> 00:18:55,640
Python of course I will call that mr.

00:18:53,250 --> 00:18:55,640
Gumby

00:18:56,690 --> 00:19:02,220
and on seeing my mistake well I haven't

00:18:59,610 --> 00:19:09,090
made a mistake yet I can go and print

00:19:02,220 --> 00:19:10,490
that string I've seen this a thousand

00:19:09,090 --> 00:19:13,260
times right

00:19:10,490 --> 00:19:16,890
no no warnings this is just normal it's

00:19:13,260 --> 00:19:19,770
just a name so let me now go and print

00:19:16,890 --> 00:19:21,750
the string and on the end of that I'll

00:19:19,770 --> 00:19:24,270
print a number that's fine actually I

00:19:21,750 --> 00:19:27,300
want to concatenate those the string and

00:19:24,270 --> 00:19:31,170
the int together and as you know you

00:19:27,300 --> 00:19:33,600
can't concatenate string and int objects

00:19:31,170 --> 00:19:40,290
in that case it's quite easy I'll just

00:19:33,600 --> 00:19:44,130
go and call the string function now I

00:19:40,290 --> 00:19:47,130
used to have a string function but I

00:19:44,130 --> 00:19:49,800
don't know more because I rebound that

00:19:47,130 --> 00:19:51,900
name that name that used to be bound to

00:19:49,800 --> 00:19:54,630
the function is now pointing to my

00:19:51,900 --> 00:19:55,050
string hard-coded string is that a

00:19:54,630 --> 00:19:58,130
problem

00:19:55,050 --> 00:20:03,510
I don't know it's a dark corner though

00:19:58,130 --> 00:20:06,900
coming up the big question what do I do

00:20:03,510 --> 00:20:10,470
about that there's there's one easy way

00:20:06,900 --> 00:20:14,430
into file restart the interpreter

00:20:10,470 --> 00:20:18,360
problem fixed if you didn't have that

00:20:14,430 --> 00:20:21,780
option then if that was bound to mr.

00:20:18,360 --> 00:20:25,320
Gandhi then I could actually go and

00:20:21,780 --> 00:20:28,160
rebind that back to well you could go

00:20:25,320 --> 00:20:30,740
and rebind it back into the the

00:20:28,160 --> 00:20:34,230
built-ins

00:20:30,740 --> 00:20:34,740
so built-ins is a handle to the

00:20:34,230 --> 00:20:36,920
built-ins

00:20:34,740 --> 00:20:39,300
however built-ins is actually not

00:20:36,920 --> 00:20:41,490
standard so that's working fine with the

00:20:39,300 --> 00:20:44,370
active state windows built it may not

00:20:41,490 --> 00:20:46,860
work on your build of Python instead you

00:20:44,370 --> 00:20:48,990
would use built-in except the cutest

00:20:46,860 --> 00:20:53,540
thing about built-in the built-in module

00:20:48,990 --> 00:20:53,540
is it's not built-in

00:20:53,920 --> 00:21:01,850
so what you have to do is go and import

00:20:58,870 --> 00:21:04,160
built-in and then you've got access to

00:21:01,850 --> 00:21:11,560
the built-in module and now I've reef

00:21:04,160 --> 00:21:13,760
ixed I've I'm not sure because ster

00:21:11,560 --> 00:21:14,900
sister is actually not a function I'm

00:21:13,760 --> 00:21:16,520
calling it a function but still is

00:21:14,900 --> 00:21:18,170
actually the constructor for objects of

00:21:16,520 --> 00:21:22,340
the class store so I think I would find

00:21:18,170 --> 00:21:26,690
it over there it's just a name

00:21:22,340 --> 00:21:29,810
so built-ins floral is not standard so

00:21:26,690 --> 00:21:34,730
you have to import built-in which gets

00:21:29,810 --> 00:21:38,290
me to the lovely joy of going and

00:21:34,730 --> 00:21:38,290
setting true to false

00:21:38,500 --> 00:21:51,730
sure okay so while true print yay ah

00:21:52,870 --> 00:22:01,130
what's the value of false false what's

00:21:56,300 --> 00:22:04,780
the value of true false true usable why

00:22:01,130 --> 00:22:07,250
yes now I would like to take a listen

00:22:04,780 --> 00:22:08,960
don't quote me on this right I've

00:22:07,250 --> 00:22:13,430
deceived myself getting into huge amount

00:22:08,960 --> 00:22:15,350
of trouble here true is false no I will

00:22:13,430 --> 00:22:22,280
I would love to take that offline and

00:22:15,350 --> 00:22:26,900
discuss truth with you what is truth you

00:22:22,280 --> 00:22:27,620
can even assign to none hmm I thought it

00:22:26,900 --> 00:22:29,300
was funny

00:22:27,620 --> 00:22:31,250
you could even assigned to none that was

00:22:29,300 --> 00:22:33,170
actually fixed in 2.7 so I can't show

00:22:31,250 --> 00:22:35,450
you that I'm running to 72 true and

00:22:33,170 --> 00:22:37,640
false become parts of the language in

00:22:35,450 --> 00:22:46,400
three and you can't assign to them in

00:22:37,640 --> 00:22:48,020
three yeah it's only a name so then the

00:22:46,400 --> 00:22:52,400
question becomes what how do I pass

00:22:48,020 --> 00:22:54,050
things to a function by ref well it's

00:22:52,400 --> 00:22:56,180
easy to pass things by reference they're

00:22:54,050 --> 00:22:58,370
always passed by reference everything's

00:22:56,180 --> 00:22:59,870
by reference and I get one of you I

00:22:58,370 --> 00:23:02,060
contract you out and say ah can you

00:22:59,870 --> 00:23:05,299
write me a function that does Leila and

00:23:02,060 --> 00:23:07,820
I pass you my list

00:23:05,299 --> 00:23:10,909
and I'll cross my fingers and hope that

00:23:07,820 --> 00:23:13,879
you don't corrupt my list how do I pass

00:23:10,909 --> 00:23:15,289
by copy in Python everything's by

00:23:13,879 --> 00:23:16,850
reference and there's a good reason for

00:23:15,289 --> 00:23:19,190
that that just improves performance out

00:23:16,850 --> 00:23:20,929
of sight if everything was by copy we'd

00:23:19,190 --> 00:23:25,999
be in trouble but how do we pass things

00:23:20,929 --> 00:23:27,739
by value I'm glad you asked well if you

00:23:25,999 --> 00:23:31,850
want to pass something by value you're

00:23:27,739 --> 00:23:34,039
gonna have to where you can't you could

00:23:31,850 --> 00:23:37,460
always though go and make a copy of an

00:23:34,039 --> 00:23:41,330
object so if I've got myself an object

00:23:37,460 --> 00:23:44,359
like a and I've shown you that it can be

00:23:41,330 --> 00:23:47,720
a list and if I do B gets a that's not a

00:23:44,359 --> 00:23:50,239
copy that is the same object so how do I

00:23:47,720 --> 00:23:52,609
make a copy of it well one way would be

00:23:50,239 --> 00:23:57,169
that I could build myself a new object a

00:23:52,609 --> 00:24:00,019
new list initialized from the same

00:23:57,169 --> 00:24:05,389
values as the and just for the fun of it

00:24:00,019 --> 00:24:12,230
- one that's fine C looks like a in fact

00:24:05,389 --> 00:24:14,629
C equals a value wise but C is a no

00:24:12,230 --> 00:24:17,239
they're different objects so going

00:24:14,629 --> 00:24:19,850
append a four on the end of it C changed

00:24:17,239 --> 00:24:21,580
but I never changed that's one way

00:24:19,850 --> 00:24:23,539
that's wouldn't be my recommended way

00:24:21,580 --> 00:24:26,450
well it depends what you're doing I

00:24:23,539 --> 00:24:26,929
suppose I could build myself a new

00:24:26,450 --> 00:24:29,179
object

00:24:26,929 --> 00:24:31,249
I could I could because I know how to do

00:24:29,179 --> 00:24:34,159
a loop I could do a loop

00:24:31,249 --> 00:24:38,149
I could have myself now this is for my C

00:24:34,159 --> 00:24:40,429
programmers I have a counter I keep on

00:24:38,149 --> 00:24:46,340
looping while the counter is less than

00:24:40,429 --> 00:24:48,710
the length of the list and I go and

00:24:46,340 --> 00:24:52,249
remember that I forgot to create an

00:24:48,710 --> 00:24:57,200
empty one to go and append the ice

00:24:52,249 --> 00:25:00,129
element of a on to the end of so I'll go

00:24:57,200 --> 00:25:07,909
and create an empty one to start with

00:25:00,129 --> 00:25:11,739
and then I will go and loop and are you

00:25:07,909 --> 00:25:15,529
going append am I missing anything

00:25:11,739 --> 00:25:17,460
increment I PS this is not the way to do

00:25:15,529 --> 00:25:19,780
it

00:25:17,460 --> 00:25:21,100
but even that's not the way to do it

00:25:19,780 --> 00:25:23,830
you're thinking like if you're writing

00:25:21,100 --> 00:25:25,450
Python code like this you know get out

00:25:23,830 --> 00:25:28,240
you know go to a Python conference

00:25:25,450 --> 00:25:32,110
something because that's just that's

00:25:28,240 --> 00:25:33,910
that's not Python sure it worked but

00:25:32,110 --> 00:25:37,000
that's not Python that's you're thinking

00:25:33,910 --> 00:25:39,400
like a C programmer I mean at least if

00:25:37,000 --> 00:25:42,370
you did a you know for each remember if

00:25:39,400 --> 00:25:46,330
R is really for each it's not a for loop

00:25:42,370 --> 00:25:49,690
it's a for each item for each thing for

00:25:46,330 --> 00:25:55,060
each X in the container the iterable

00:25:49,690 --> 00:25:57,460
actually go and append X onto the end of

00:25:55,060 --> 00:25:59,950
that that way I don't have to remember

00:25:57,460 --> 00:26:02,200
to not forget to do my incrementing if

00:25:59,950 --> 00:26:04,120
you're using incrementing square

00:26:02,200 --> 00:26:06,520
brackets gee I mean that's that's not

00:26:04,120 --> 00:26:09,070
Python this is more pythonic certainly

00:26:06,520 --> 00:26:10,680
but I wouldn't be doing like that if you

00:26:09,070 --> 00:26:14,260
really wanted to do it a bit more easily

00:26:10,680 --> 00:26:16,810
use the list constructor maybe if you

00:26:14,260 --> 00:26:18,850
wanted to create a list that would be an

00:26:16,810 --> 00:26:20,830
easier way well though that does give me

00:26:18,850 --> 00:26:22,390
a list assuming that I had a list I'll

00:26:20,830 --> 00:26:25,960
get a list if it was a tupple I now

00:26:22,390 --> 00:26:27,670
don't have a couple funny little one I'm

00:26:25,960 --> 00:26:31,090
actually not a real huge fan of the

00:26:27,670 --> 00:26:35,410
syntax but of course that works slicing

00:26:31,090 --> 00:26:37,510
creates a copy in Python so I'm not a

00:26:35,410 --> 00:26:39,460
huge fan of the syntax but it actually

00:26:37,510 --> 00:26:40,600
creates a copy of the same type which

00:26:39,460 --> 00:26:42,550
was nice

00:26:40,600 --> 00:26:47,080
some other alternatives are you could go

00:26:42,550 --> 00:26:48,520
and grab the funky syntax thing you

00:26:47,080 --> 00:26:50,470
could use the copy module that's always

00:26:48,520 --> 00:26:52,840
another option but watch out for how

00:26:50,470 --> 00:26:54,790
deep it's going because it's only

00:26:52,840 --> 00:26:57,370
copying the top level if you've got a

00:26:54,790 --> 00:26:59,170
list of lists then maybe you want to do

00:26:57,370 --> 00:27:06,550
a bit more thinking or maybe you want to

00:26:59,170 --> 00:27:07,900
use a deep sorry group deep copy deep

00:27:06,550 --> 00:27:10,650
and shallow

00:27:07,900 --> 00:27:13,500
how we going anyone weren't anything

00:27:10,650 --> 00:27:15,970
awesome let's have a look at types

00:27:13,500 --> 00:27:18,070
objects can change that type well by now

00:27:15,970 --> 00:27:20,740
that should be pretty obvious that the

00:27:18,070 --> 00:27:23,860
answer to that is no they can't I can

00:27:20,740 --> 00:27:26,200
make the STR name down to something

00:27:23,860 --> 00:27:28,390
different I can make I bound to

00:27:26,200 --> 00:27:31,510
something different I can make I equal

00:27:28,390 --> 00:27:32,800
to something else I'm not changing I I'm

00:27:31,510 --> 00:27:35,350
just making it pointed a different

00:27:32,800 --> 00:27:39,130
object that's normal that's Python

00:27:35,350 --> 00:27:40,570
that's the way Python works they can't

00:27:39,130 --> 00:27:42,580
change their time but you can make the

00:27:40,570 --> 00:27:45,730
name point to an object of a different

00:27:42,580 --> 00:27:47,760
type objects can't change their time and

00:27:45,730 --> 00:27:51,100
can do some funky stuff with matters but

00:27:47,760 --> 00:27:52,990
last point there is checking the type of

00:27:51,100 --> 00:27:55,420
an argument is probably wrong

00:27:52,990 --> 00:27:56,800
I see people writing their functions

00:27:55,420 --> 00:27:59,080
going oh I've got to have a list here

00:27:56,800 --> 00:28:02,890
man so how do I test to see whether the

00:27:59,080 --> 00:28:04,570
argument is a list oh how do I tell

00:28:02,890 --> 00:28:06,760
whether an argument is of type list you

00:28:04,570 --> 00:28:09,100
don't want to you want to see whether

00:28:06,760 --> 00:28:11,560
you can subscript it you don't care

00:28:09,100 --> 00:28:14,170
whether it's a list a set of tuples or

00:28:11,560 --> 00:28:16,480
as something inherited from tupple so

00:28:14,170 --> 00:28:19,210
checking to see oh what is the type of

00:28:16,480 --> 00:28:22,120
that argument is probably wrong you

00:28:19,210 --> 00:28:25,600
should be avoiding RTT i runtime type

00:28:22,120 --> 00:28:27,190
information maybe using has attribute

00:28:25,600 --> 00:28:30,850
might be relevant if you wanted to see

00:28:27,190 --> 00:28:33,670
whether can this duck quack but really

00:28:30,850 --> 00:28:35,920
another way is just to try it in other

00:28:33,670 --> 00:28:37,810
words have a go at it if it fails then

00:28:35,920 --> 00:28:39,640
an exception gets thrown are that object

00:28:37,810 --> 00:28:42,970
couldn't quack and you would have heard

00:28:39,640 --> 00:28:45,400
of pythons type mechanism known as duck

00:28:42,970 --> 00:28:47,410
typing if it looks like a duck walks

00:28:45,400 --> 00:28:49,720
like a duck quacks like a duck it's a

00:28:47,410 --> 00:28:51,790
duck well it exhibits duck like

00:28:49,720 --> 00:28:53,100
qualities I don't really care whether

00:28:51,790 --> 00:28:55,960
it's a duck

00:28:53,100 --> 00:29:01,510
types part two in sand not the same as

00:28:55,960 --> 00:29:07,560
they are in sea so what is form I see

00:29:01,510 --> 00:29:12,160
friends let me make i equal to 1 to 3 ^

00:29:07,560 --> 00:29:16,950
100 now let me make it harder for 5 6 7

00:29:12,160 --> 00:29:21,840
8 9 10 to the power of 100 anyone

00:29:16,950 --> 00:29:24,179
I is and if you weren't if you weren't

00:29:21,840 --> 00:29:29,639
sure it's got an L on the end it's a

00:29:24,179 --> 00:29:36,179
long number it's not the same as C but

00:29:29,639 --> 00:29:43,409
what's 7/2 I've got to know this it's

00:29:36,179 --> 00:29:48,870
important it's exactly three seven point

00:29:43,409 --> 00:29:51,389
divided by two is approximately three

00:29:48,870 --> 00:29:54,389
and a half and but this is not C so

00:29:51,389 --> 00:29:59,250
watch out for things like that what's

00:29:54,389 --> 00:30:01,980
minus 7 divided by 2 minus 3 is a sweet

00:29:59,250 --> 00:30:03,659
programming's answer or Java or lots of

00:30:01,980 --> 00:30:05,070
other languages but this isn't C Java

00:30:03,659 --> 00:30:06,720
this is Python

00:30:05,070 --> 00:30:09,260
I think Python does it right but it's

00:30:06,720 --> 00:30:11,669
doing it differently to other languages

00:30:09,260 --> 00:30:13,230
watch out for that while I'm talking

00:30:11,669 --> 00:30:16,649
about types watch out for floating point

00:30:13,230 --> 00:30:22,380
numbers anyone know what 1.1 plus 1.1 is

00:30:16,649 --> 00:30:24,450
oh come on approximately 2.2 good

00:30:22,380 --> 00:30:28,429
excellent you're still with me plus one

00:30:24,450 --> 00:30:32,940
point one minus three point three hmm

00:30:28,429 --> 00:30:37,169
does it equal plus one point one minus

00:30:32,940 --> 00:30:39,029
three point three if you think it's zero

00:30:37,169 --> 00:30:46,950
you're going to be sadly mistaken

00:30:39,029 --> 00:30:48,690
because it's not zero you win that could

00:30:46,950 --> 00:30:50,159
be a problem in some of your code if

00:30:48,690 --> 00:30:52,440
you're expecting these to come out

00:30:50,159 --> 00:30:54,419
perfectly this is not pythons fault by

00:30:52,440 --> 00:30:58,799
the way exactly the same problem occurs

00:30:54,419 --> 00:31:01,049
in C C++ Perl Java Visual Basic they all

00:30:58,799 --> 00:31:04,169
suffer this will blame them blame the

00:31:01,049 --> 00:31:06,690
hardware guys I Triple E they decided

00:31:04,169 --> 00:31:08,880
how base to binary computers would store

00:31:06,690 --> 00:31:11,220
floating-point base 10 numbers and

00:31:08,880 --> 00:31:12,990
there's a good reason to do it they do

00:31:11,220 --> 00:31:14,730
it very efficiently but you need to

00:31:12,990 --> 00:31:16,049
watch out for floating-point numbers if

00:31:14,730 --> 00:31:18,419
you don't know what's going on there you

00:31:16,049 --> 00:31:20,460
need to check how floating-point numbers

00:31:18,419 --> 00:31:24,179
work if you want to get a bit more

00:31:20,460 --> 00:31:26,340
accuracy then you could use the decimal

00:31:24,179 --> 00:31:29,010
class which interestingly are noticed in

00:31:26,340 --> 00:31:30,060
3.3 has been substantially improved in

00:31:29,010 --> 00:31:31,680
performance

00:31:30,060 --> 00:31:33,600
that gives you arbitrary length

00:31:31,680 --> 00:31:39,180
floating-point numbers watch out for

00:31:33,600 --> 00:31:46,130
single element tuples as well if 2 is 4

00:31:39,180 --> 00:31:57,710
what's the type of T it's an int if t

00:31:46,130 --> 00:32:02,160
oops if t is 1 2 3 what's the type of t

00:31:57,710 --> 00:32:06,390
tupple let me make it a short one what's

00:32:02,160 --> 00:32:11,010
the type of T you're too good

00:32:06,390 --> 00:32:13,140
that's an int correct if I wanted to

00:32:11,010 --> 00:32:14,910
make it a single element tuple you get

00:32:13,140 --> 00:32:18,300
this curious syntax although it makes

00:32:14,910 --> 00:32:20,190
sense when you see it of that which

00:32:18,300 --> 00:32:22,050
changes its type you could also use the

00:32:20,190 --> 00:32:28,350
tupple constructor if you were in the

00:32:22,050 --> 00:32:32,310
mood for that what is a constant I'll

00:32:28,350 --> 00:32:35,100
tell you what a constant is is an

00:32:32,310 --> 00:32:37,350
immutable object it's are immutable

00:32:35,100 --> 00:32:40,260
there are no methods in an int to change

00:32:37,350 --> 00:32:43,530
the int what part of a tuple is a

00:32:40,260 --> 00:32:47,250
constant the tupple is a constant so T

00:32:43,530 --> 00:32:49,830
is a tuple so if I go and append a 4

00:32:47,250 --> 00:32:52,170
onto the end there is no attribute

00:32:49,830 --> 00:32:53,940
append if I try to make the if I have a

00:32:52,170 --> 00:32:57,030
look at the first element that's okay

00:32:53,940 --> 00:32:58,980
but if I try to change it you're in

00:32:57,030 --> 00:33:01,800
trouble it doesn't a support item

00:32:58,980 --> 00:33:06,540
assignment but watch out for tuples like

00:33:01,800 --> 00:33:18,200
this this is a couple made up of a list

00:33:06,540 --> 00:33:22,280
and an int so I can't change t0 but t0 I

00:33:18,200 --> 00:33:27,750
can go and append a 4 onto the end of it

00:33:22,280 --> 00:33:30,330
even though T is a tuple so watch out

00:33:27,750 --> 00:33:31,830
for tuples what part of a tuple is a

00:33:30,330 --> 00:33:33,240
constant if you want to create your own

00:33:31,830 --> 00:33:35,130
immutable type the easiest way as

00:33:33,240 --> 00:33:38,090
inherit from tuples you are creating an

00:33:35,130 --> 00:33:41,130
object because tuples are objects

00:33:38,090 --> 00:33:43,110
accidental name creation the quick

00:33:41,130 --> 00:33:46,140
answer about this is this a problem

00:33:43,110 --> 00:33:47,670
probably you've got a you've got a

00:33:46,140 --> 00:33:50,190
program doesn't matter what the program

00:33:47,670 --> 00:33:53,960
is your variable and if you're anything

00:33:50,190 --> 00:33:58,140
like me and if you if you type like me

00:33:53,960 --> 00:34:02,460
you go and you know accidentally what

00:33:58,140 --> 00:34:06,030
are you doing you go and have a you know

00:34:02,460 --> 00:34:10,470
function which is equal to whatever but

00:34:06,030 --> 00:34:13,470
you go and miss type something then it

00:34:10,470 --> 00:34:16,409
goes and creates a variable I gets five

00:34:13,470 --> 00:34:19,379
let me go and increment I but I

00:34:16,409 --> 00:34:20,790
accidentally now that's okay because

00:34:19,379 --> 00:34:22,980
you've actually got yourself an error

00:34:20,790 --> 00:34:27,240
there because there is no original value

00:34:22,980 --> 00:34:31,050
of the variable IO so how do you solve

00:34:27,240 --> 00:34:31,980
miss type mistakes as in typing mistakes

00:34:31,050 --> 00:34:33,600
in Python

00:34:31,980 --> 00:34:36,030
depends what tool you're using I'm using

00:34:33,600 --> 00:34:38,730
a tool here which I'm a big fan of

00:34:36,030 --> 00:34:40,139
called pycharm from JetBrains the same

00:34:38,730 --> 00:34:42,540
people that brought you IntelliJ and

00:34:40,139 --> 00:34:44,399
it's got some gorgeous things like an

00:34:42,540 --> 00:34:47,040
inspector I ran this over my whole

00:34:44,399 --> 00:34:49,350
project we came up with a raft of sorts

00:34:47,040 --> 00:34:51,450
of problems of mistakes little minor

00:34:49,350 --> 00:34:53,850
other options those to use things like

00:34:51,450 --> 00:34:57,720
pi checkup I linked there's lots of

00:34:53,850 --> 00:34:59,790
tools to check for very minor mistakes

00:34:57,720 --> 00:35:04,010
but they're definitely mistakes in your

00:34:59,790 --> 00:35:06,990
Python program not that one

00:35:04,010 --> 00:35:09,350
what are you doing sorry my mistake just

00:35:06,990 --> 00:35:09,350
lost it

00:35:10,580 --> 00:35:13,420
come back

00:35:16,950 --> 00:35:26,220
there was I I think doesn't suck sorry

00:35:24,460 --> 00:35:32,500
my mistake

00:35:26,220 --> 00:35:33,910
that's my this is my recap accidental

00:35:32,500 --> 00:35:37,240
name creation there's no easy solution

00:35:33,910 --> 00:35:44,440
if you can't spell the takin solvers my

00:35:37,240 --> 00:35:45,880
nearly last topic is arguments this is a

00:35:44,440 --> 00:35:48,760
nice little program I've got here with

00:35:45,880 --> 00:35:50,680
default arguments I love default

00:35:48,760 --> 00:35:52,450
arguments in Python pythons argument

00:35:50,680 --> 00:35:55,420
passing is the best of any language I've

00:35:52,450 --> 00:35:58,750
used so we can pass arguments ordinal II

00:35:55,420 --> 00:36:02,260
by position we can pass arguments by

00:35:58,750 --> 00:36:08,859
name even the wrong name the wrong order

00:36:02,260 --> 00:36:11,020
I mean to say I can even have by leave

00:36:08,859 --> 00:36:15,910
them all out take all of the defaults of

00:36:11,020 --> 00:36:19,180
course this would be wrong because if

00:36:15,910 --> 00:36:22,480
I'm setting 11 into expositionally

00:36:19,180 --> 00:36:24,970
ordinal E and trying to override it then

00:36:22,480 --> 00:36:28,799
I'll get myself a type error duplicate

00:36:24,970 --> 00:36:28,799
arguments for that particular one

00:36:29,549 --> 00:36:35,920
arguments here's a nice little function

00:36:32,920 --> 00:36:37,750
using default arguments using default

00:36:35,920 --> 00:36:41,559
arguments I've got the default argument

00:36:37,750 --> 00:36:45,160
of I'll just have an empty list this is

00:36:41,559 --> 00:36:47,349
a classic mistake in Python the mutable

00:36:45,160 --> 00:36:50,799
default argument the big question is

00:36:47,349 --> 00:36:53,290
when does it create that empty list well

00:36:50,799 --> 00:36:55,859
a def statement is a executable

00:36:53,290 --> 00:37:01,109
statement so when that gets evaluated

00:36:55,859 --> 00:37:04,660
that's when the single only mutable

00:37:01,109 --> 00:37:07,540
default argument the list gets made it

00:37:04,660 --> 00:37:09,280
gets made once and therefore that

00:37:07,540 --> 00:37:13,690
actually preserves the value of that

00:37:09,280 --> 00:37:19,000
list between multiple calls to f2 dark

00:37:13,690 --> 00:37:20,470
corner chance of mistakes I think so it

00:37:19,000 --> 00:37:22,329
makes sense that when you considered F

00:37:20,470 --> 00:37:26,140
is a function is an executable statement

00:37:22,329 --> 00:37:27,530
but just a it can can give trouble the

00:37:26,140 --> 00:37:31,130
easy solution to

00:37:27,530 --> 00:37:33,560
is to use a non mutable argument the non

00:37:31,130 --> 00:37:35,120
mutable argument of none is often used

00:37:33,560 --> 00:37:37,310
because if somebody was explicitly

00:37:35,120 --> 00:37:38,090
passing none to your function they know

00:37:37,310 --> 00:37:39,860
what they're doing

00:37:38,090 --> 00:37:43,220
don't worry too much about them they're

00:37:39,860 --> 00:37:46,510
okay and I'm then binding that to a

00:37:43,220 --> 00:37:53,450
local argument ill so I'll get a new

00:37:46,510 --> 00:37:56,060
individual single argument there so for

00:37:53,450 --> 00:37:59,140
that see the docs they have a actually

00:37:56,060 --> 00:38:03,140
is a very nice some explanation of

00:37:59,140 --> 00:38:11,080
functions a function definition is an

00:38:03,140 --> 00:38:15,890
executable statement which brings me to

00:38:11,080 --> 00:38:19,100
surprising namespace rules let's go and

00:38:15,890 --> 00:38:22,960
grab a program let's go and create a

00:38:19,100 --> 00:38:26,510
program let's go and create a function

00:38:22,960 --> 00:38:30,650
define a function takes no arguments and

00:38:26,510 --> 00:38:34,430
it goes and prints out I I get set

00:38:30,650 --> 00:38:37,930
globally two five and I will go and call

00:38:34,430 --> 00:38:37,930
function what is this program print

00:38:44,670 --> 00:38:53,730
oh how come he's getting claps and it

00:38:49,769 --> 00:38:56,130
prints out five yay good so global

00:38:53,730 --> 00:39:00,000
variables are accessible inside a

00:38:56,130 --> 00:39:03,390
function let me go and change that to a

00:39:00,000 --> 00:39:07,650
six what does this print all right guys

00:39:03,390 --> 00:39:12,470
you are a genius let me go and after the

00:39:07,650 --> 00:39:12,470
function go and print out I this prints

00:39:13,010 --> 00:39:22,980
six and then five good was still with me

00:39:16,769 --> 00:39:26,010
six then five let me then print I sent I

00:39:22,980 --> 00:39:28,410
to six print I know actually what I do

00:39:26,010 --> 00:39:31,440
I'll do before I set that I'll print I

00:39:28,410 --> 00:39:32,010
I'll print I I'll change it and I'll

00:39:31,440 --> 00:39:37,400
print it

00:39:32,010 --> 00:39:37,400
what is this print for a t-shirt you

00:39:38,299 --> 00:39:44,160
already know

00:39:40,789 --> 00:39:48,210
undefined I'll give you another one

00:39:44,160 --> 00:39:51,960
later it's an error it's actually called

00:39:48,210 --> 00:39:54,720
an unbound local error nasty little

00:39:51,960 --> 00:39:56,309
corner of Python I think it's actually

00:39:54,720 --> 00:39:59,099
the right decision this should be a

00:39:56,309 --> 00:40:01,980
mistake and it is it gives me an unbound

00:39:59,099 --> 00:40:05,039
local error because what should this be

00:40:01,980 --> 00:40:08,309
should this be the global I or the local

00:40:05,039 --> 00:40:11,339
I what would happen if that was in fact

00:40:08,309 --> 00:40:14,700
not a standard declaration but a

00:40:11,339 --> 00:40:16,170
conditional assignment if you know then

00:40:14,700 --> 00:40:17,579
sometimes would be the global sometimes

00:40:16,170 --> 00:40:19,289
they'd be the local you'll actually

00:40:17,579 --> 00:40:22,650
notice from this that Python actually

00:40:19,289 --> 00:40:24,089
does forward scan through a function so

00:40:22,650 --> 00:40:26,130
it actually has to know back then that

00:40:24,089 --> 00:40:28,289
it's doing something later on to that

00:40:26,130 --> 00:40:31,920
variable pythons doing the right thing

00:40:28,289 --> 00:40:34,980
but it's a cute little surprising

00:40:31,920 --> 00:40:36,480
namespace error if you've if you've come

00:40:34,980 --> 00:40:39,750
across it you would have spent three

00:40:36,480 --> 00:40:41,940
hours searching Stack Overflow trying to

00:40:39,750 --> 00:40:46,430
find out what happened that's what's

00:40:41,940 --> 00:40:51,240
happening the thing that people often

00:40:46,430 --> 00:40:53,309
don't like was in fact that part a lot

00:40:51,240 --> 00:40:56,069
of people don't like that how come I can

00:40:53,309 --> 00:40:57,660
see a global variable well look I'll say

00:40:56,069 --> 00:40:58,109
what you should probably do is actually

00:40:57,660 --> 00:41:00,029
not

00:40:58,109 --> 00:41:03,329
have global variables if you define

00:41:00,029 --> 00:41:07,230
everything into a function called for my

00:41:03,329 --> 00:41:09,210
C programmers let's call it main you

00:41:07,230 --> 00:41:11,579
don't have to call it main and then your

00:41:09,210 --> 00:41:14,460
main line will then would become go and

00:41:11,579 --> 00:41:18,150
run the main oops that should be over

00:41:14,460 --> 00:41:20,279
there then that solves my problems I

00:41:18,150 --> 00:41:23,640
don't have any global variables and that

00:41:20,279 --> 00:41:30,319
now gives me a proper global name I not

00:41:23,640 --> 00:41:33,930
declared so that is what I would suggest

00:41:30,319 --> 00:41:37,200
for the unbound local error and avoid

00:41:33,930 --> 00:41:40,499
problems by using a main line you could

00:41:37,200 --> 00:41:43,339
use the global keyword I'm not even

00:41:40,499 --> 00:41:46,769
going to show you how to do that and

00:41:43,339 --> 00:41:52,619
checking tools and care which brings me

00:41:46,769 --> 00:42:02,039
to the end of the talk applaud now give

00:41:52,619 --> 00:42:04,589
me some more than a head thank you thank

00:42:02,039 --> 00:42:06,059
you very much at this point I feel like

00:42:04,589 --> 00:42:08,130
I haven't done it justice but some

00:42:06,059 --> 00:42:16,410
questions question time this one up the

00:42:08,130 --> 00:42:20,670
back I'm 42 I'm not on 30 in hex that is

00:42:16,410 --> 00:42:25,589
can you explain how negative 7 divided

00:42:20,670 --> 00:42:29,160
by 2 is negative 4 yes and also the 1.1

00:42:25,589 --> 00:42:32,789
plus 1.1 yeah that was cool well minus 3

00:42:29,160 --> 00:42:34,380
point yes 3 equals blah yeah yeah that

00:42:32,789 --> 00:42:35,940
was that was lovely let me start with

00:42:34,380 --> 00:42:39,239
the floating point one because that some

00:42:35,940 --> 00:42:43,710
that well that that's actually the same

00:42:39,239 --> 00:42:46,499
as saying what is 1 point 0 divided by 3

00:42:43,710 --> 00:42:48,749
and the answer to that is well I can't

00:42:46,499 --> 00:42:51,180
really tell you I can only tell you an

00:42:48,749 --> 00:42:54,380
approximation of what that is and that's

00:42:51,180 --> 00:42:57,779
approximately 0.33 3 3333

00:42:54,380 --> 00:43:01,230
likewise in Python 0 or not in Python

00:42:57,779 --> 00:43:04,049
but in base 2 binary computers 0.1 1/10

00:43:01,230 --> 00:43:07,739
is actually not representable in a

00:43:04,049 --> 00:43:11,330
binary form there's no base to form for

00:43:07,739 --> 00:43:15,600
1/10 so it's actually 0.1

00:43:11,330 --> 00:43:18,300
0:01 no 0:01 though it's not quite

00:43:15,600 --> 00:43:21,360
exactly 1/10 they can't actually

00:43:18,300 --> 00:43:23,580
represent a tense some decimal place

00:43:21,360 --> 00:43:25,290
ones we can represent some ones we can't

00:43:23,580 --> 00:43:28,740
represent that's one of the ones we

00:43:25,290 --> 00:43:30,720
can't represent in a base two so pythons

00:43:28,740 --> 00:43:32,670
floating-point numbers use the same as C

00:43:30,720 --> 00:43:34,850
which is doubles double precision

00:43:32,670 --> 00:43:37,500
floating point numbers which store

00:43:34,850 --> 00:43:38,370
fifteen significant digits up to ten to

00:43:37,500 --> 00:43:40,470
the power of three hundred and eight

00:43:38,370 --> 00:43:42,570
it's a big number and a lot of decimal

00:43:40,470 --> 00:43:46,650
places but not enough it's not infinite

00:43:42,570 --> 00:43:49,320
so we actually can't represent 0.1 now

00:43:46,650 --> 00:43:54,360
in old versions of Python if you did 0.1

00:43:49,320 --> 00:43:56,220
it would come up 0.1 one you're running

00:43:54,360 --> 00:43:58,610
like a 2.4 or something like that that's

00:43:56,220 --> 00:44:01,350
what you'll see they're putting up the

00:43:58,610 --> 00:44:03,870
representation now but the fact is that

00:44:01,350 --> 00:44:05,730
we can't represent floating-point some

00:44:03,870 --> 00:44:08,970
floating-point numbers so there's

00:44:05,730 --> 00:44:11,970
inaccuracies occurring at the fifteenth

00:44:08,970 --> 00:44:15,300
digits and that's what's creeping in how

00:44:11,970 --> 00:44:17,670
do you solve that well one way would be

00:44:15,300 --> 00:44:21,690
to round so if I just you know did some

00:44:17,670 --> 00:44:24,840
rounding of my numbers then that could

00:44:21,690 --> 00:44:26,730
solve it round my numbers to a certain

00:44:24,840 --> 00:44:29,280
number of decimal places I have two

00:44:26,730 --> 00:44:30,750
minutes left the decimal class will also

00:44:29,280 --> 00:44:34,290
solve that I can give you a nice example

00:44:30,750 --> 00:44:38,790
afterwards to the other the idea about

00:44:34,290 --> 00:44:41,610
the minus 7/2 is that account member the

00:44:38,790 --> 00:44:43,620
argument but the divisions always a

00:44:41,610 --> 00:44:46,380
floor so it's actually following

00:44:43,620 --> 00:44:47,910
mathematic rules rather than computer

00:44:46,380 --> 00:44:50,880
rules computer rules say the sign is

00:44:47,910 --> 00:44:53,760
different and we'll just have it but so

00:44:50,880 --> 00:44:57,090
that other operations are actually work

00:44:53,760 --> 00:45:00,060
as the flip it actually has to work like

00:44:57,090 --> 00:45:05,040
that so python is favored by scientists

00:45:00,060 --> 00:45:07,440
and mathematicians what's that that's

00:45:05,040 --> 00:45:13,410
right to make Dib the mod of it would

00:45:07,440 --> 00:45:18,120
add up and yes it's worth noting that

00:45:13,410 --> 00:45:21,540
ordinary division is returned to proper

00:45:18,120 --> 00:45:23,279
in version 3 and so if you really want a

00:45:21,540 --> 00:45:26,819
floor division you should

00:45:23,279 --> 00:45:32,369
probably be using floor division

00:45:26,819 --> 00:45:34,519
operator which gives me exactly 3.0 have

00:45:32,369 --> 00:45:37,439
a good time for one more question or

00:45:34,519 --> 00:45:38,519
that's the end of the show thanks for

00:45:37,439 --> 00:45:43,409
coming

00:45:38,519 --> 00:45:48,229
I'm happy to hang around and give you

00:45:43,409 --> 00:45:48,229

YouTube URL: https://www.youtube.com/watch?v=CD_Eh8GLCPA


