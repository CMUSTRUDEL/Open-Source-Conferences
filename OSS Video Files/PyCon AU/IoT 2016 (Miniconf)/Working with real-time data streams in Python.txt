Title: Working with real-time data streams in Python
Publication date: 2016-08-16
Playlist: IoT 2016 (Miniconf)
Description: 
	Lachlan Blackhall
https://2016.pycon-au.org/schedule/163/view_talk
An increasing number of devices and applications are producing vast amounts of data in real time. This can include measurements, sensor readings, and performance data.

Making this data useful often requires that we analyse and use the data in real time but this requires techniques to aggregate, filter, and smooth the data. Drawing on simple and well-tested techniques from mathematics and engineering allows us to solve these problems quickly and efficiently.

This talk will describe how Python can be used to develop powerful capabilities for working with real-time data streams and provide simple examples you can start using yourself.
Captions: 
	00:00:00,000 --> 00:00:05,130
all right good afternoon welcome to the

00:00:02,129 --> 00:00:08,189
next session so next session is about

00:00:05,130 --> 00:00:11,190
working with real-time data streams for

00:00:08,189 --> 00:00:11,700
LTE devices and is presented locked in

00:00:11,190 --> 00:00:20,070
black hole

00:00:11,700 --> 00:00:20,789
so please welcome Lachlan oh good

00:00:20,070 --> 00:00:24,359
afternoon everyone

00:00:20,789 --> 00:00:25,830
welcome to the session look I think I'm

00:00:24,359 --> 00:00:28,460
actually really pleased that I'm

00:00:25,830 --> 00:00:30,599
following the talk that Nick just gave

00:00:28,460 --> 00:00:32,009
so Nick for those of you who weren't he

00:00:30,599 --> 00:00:34,530
just have a really really insightful

00:00:32,009 --> 00:00:36,649
talk I thought on some of the problems

00:00:34,530 --> 00:00:38,910
we have with the Internet of Things and

00:00:36,649 --> 00:00:40,410
it's interesting for me to hear this

00:00:38,910 --> 00:00:43,110
because my background I'm actually

00:00:40,410 --> 00:00:44,789
originally an engineer and so my

00:00:43,110 --> 00:00:47,550
backgrounds actually as an aero engineer

00:00:44,789 --> 00:00:49,140
and as one of my professors once said

00:00:47,550 --> 00:00:50,520
this is like the reason you have to be

00:00:49,140 --> 00:00:51,629
really careful when you're designing and

00:00:50,520 --> 00:00:53,789
building planes is that when you're

00:00:51,629 --> 00:00:58,199
30,000 feet up your passengers get quite

00:00:53,789 --> 00:01:00,239
unhappy if things stop working and I

00:00:58,199 --> 00:01:01,680
think sometimes it's a really

00:01:00,239 --> 00:01:03,390
interesting mindset that I don't

00:01:01,680 --> 00:01:05,670
necessarily see when we just want to

00:01:03,390 --> 00:01:07,650
move across towards software it's sort

00:01:05,670 --> 00:01:09,799
of software gives us the ability to

00:01:07,650 --> 00:01:12,090
build things so quickly and so easily

00:01:09,799 --> 00:01:14,700
that sometimes we forget that there

00:01:12,090 --> 00:01:18,180
actually is a really useful engineering

00:01:14,700 --> 00:01:20,220
process to be done beforehand so I'm

00:01:18,180 --> 00:01:22,979
actually going to be talking about sort

00:01:20,220 --> 00:01:26,250
of one really specific problem that I

00:01:22,979 --> 00:01:30,090
see with with a lot of data handling in

00:01:26,250 --> 00:01:32,280
regards to IOT devices and I hope that

00:01:30,090 --> 00:01:33,930
that sort of motivates sort of a broader

00:01:32,280 --> 00:01:36,180
interest in people understanding the

00:01:33,930 --> 00:01:38,040
fact that oftentimes a lot of the

00:01:36,180 --> 00:01:40,229
problems that we see have already been

00:01:38,040 --> 00:01:42,810
solved in other disciplines you just

00:01:40,229 --> 00:01:45,119
have to go looking for them for those

00:01:42,810 --> 00:01:46,740
solutions to understand how we should

00:01:45,119 --> 00:01:48,780
actually apply them in the software

00:01:46,740 --> 00:01:49,950
world so for those standing at the back

00:01:48,780 --> 00:01:51,689
if you want to come forward there's

00:01:49,950 --> 00:01:53,280
still a bunch of seats in here and I'm

00:01:51,689 --> 00:01:55,280
sure people will squeeze in for you so

00:01:53,280 --> 00:01:58,799
that you can have a seat

00:01:55,280 --> 00:02:01,350
um so aside from being an aero engineer

00:01:58,799 --> 00:02:03,689
many years ago I'm currently the

00:02:01,350 --> 00:02:07,380
co-founder and CTO of a company called

00:02:03,689 --> 00:02:10,050
deposit power and repository and

00:02:07,380 --> 00:02:11,730
optimization software for batteries and

00:02:10,050 --> 00:02:13,470
we have a piece of hardware and some

00:02:11,730 --> 00:02:15,570
software that actually goes

00:02:13,470 --> 00:02:18,060
out into the field and so I've always

00:02:15,570 --> 00:02:20,160
hated the fact on some level that we've

00:02:18,060 --> 00:02:22,200
built sort of an IOT device because I

00:02:20,160 --> 00:02:25,080
really think it's I have many of the

00:02:22,200 --> 00:02:27,810
same problems with IOT as lots of lots

00:02:25,080 --> 00:02:30,540
of you do but it's really interesting

00:02:27,810 --> 00:02:32,100
these are IOT devices they're boxes that

00:02:30,540 --> 00:02:33,720
contain bits a little bit of hardware a

00:02:32,100 --> 00:02:36,000
little bit of software and they're

00:02:33,720 --> 00:02:39,660
connected often to the Internet at the

00:02:36,000 --> 00:02:41,310
end of very very skinny wires and one of

00:02:39,660 --> 00:02:43,350
the one of the first things that we did

00:02:41,310 --> 00:02:44,910
when we started the company was we

00:02:43,350 --> 00:02:46,800
thought of we wanted to design

00:02:44,910 --> 00:02:48,959
everything as though we were blasting it

00:02:46,800 --> 00:02:50,280
into space because if you're in space

00:02:48,959 --> 00:02:52,290
you don't get the chance to go and fix

00:02:50,280 --> 00:02:54,240
it you've got to make sure that it works

00:02:52,290 --> 00:02:55,980
not only that it works but that it's

00:02:54,240 --> 00:02:57,750
robust to communications failures that

00:02:55,980 --> 00:03:00,360
it's robust are there as its robust to

00:02:57,750 --> 00:03:02,040
software errors particularly when you

00:03:00,360 --> 00:03:03,540
have humans writing the software so

00:03:02,040 --> 00:03:06,510
that's kind of a background that I'm

00:03:03,540 --> 00:03:11,610
coming from in talking about what I'm

00:03:06,510 --> 00:03:13,830
talking about today so particularly in

00:03:11,610 --> 00:03:17,190
my world in terms of what we're doing

00:03:13,830 --> 00:03:19,350
and sort of the broader IOT world heaps

00:03:17,190 --> 00:03:21,870
of talk around the concept of smart

00:03:19,350 --> 00:03:24,000
homes at the moment and so you know

00:03:21,870 --> 00:03:26,130
we're starting to see things like you

00:03:24,000 --> 00:03:27,570
know residential batteries rolling out

00:03:26,130 --> 00:03:29,940
into people's houses we're staying to

00:03:27,570 --> 00:03:32,010
see smart cars increasingly there's

00:03:29,940 --> 00:03:33,330
going to be access to you know partially

00:03:32,010 --> 00:03:36,959
autonomous or fully autonomous vehicles

00:03:33,330 --> 00:03:39,000
we've got smart thermostats got smart

00:03:36,959 --> 00:03:43,080
toasters which I think's maybe a slight

00:03:39,000 --> 00:03:45,540
overreaction to the IOC problem we have

00:03:43,080 --> 00:03:46,500
smart lights again I wonder if people

00:03:45,540 --> 00:03:48,720
actually need to know whether I'm

00:03:46,500 --> 00:03:51,360
turning my lights on or not but but we

00:03:48,720 --> 00:03:54,930
have heaps of sensors and actuators

00:03:51,360 --> 00:03:56,820
rolling out throughout our homes and you

00:03:54,930 --> 00:03:59,220
know increasingly they're put there to

00:03:56,820 --> 00:04:02,940
try and improve our experience of living

00:03:59,220 --> 00:04:04,650
in our houses and that kind of gets

00:04:02,940 --> 00:04:06,810
thing gets magnified into this concept

00:04:04,650 --> 00:04:08,790
of smart cities and so you take all

00:04:06,810 --> 00:04:10,260
these sort of individual actuators and

00:04:08,790 --> 00:04:11,970
sensors that are in houses and then you

00:04:10,260 --> 00:04:13,650
think well you know I could actually put

00:04:11,970 --> 00:04:15,900
these in lots of other places too and so

00:04:13,650 --> 00:04:17,340
you start you know putting them in

00:04:15,900 --> 00:04:18,989
street lights so you can save energy

00:04:17,340 --> 00:04:22,080
sometimes and you put them in smart

00:04:18,989 --> 00:04:24,450
sidewalks and you know you you end up

00:04:22,080 --> 00:04:25,950
with smart buildings that are able to

00:04:24,450 --> 00:04:27,240
regulate that they're their own

00:04:25,950 --> 00:04:28,889
temperature and the Sun

00:04:27,240 --> 00:04:30,509
light and tinting and all of those kind

00:04:28,889 --> 00:04:33,150
of things and so we're really heading

00:04:30,509 --> 00:04:35,910
towards this world where we have we do

00:04:33,150 --> 00:04:37,259
have billions of devices that are little

00:04:35,910 --> 00:04:38,900
bits of hardware and that are a little

00:04:37,259 --> 00:04:41,669
bits of software and that are ultimately

00:04:38,900 --> 00:04:43,949
connected into the Internet and so I

00:04:41,669 --> 00:04:46,380
suppose we're all going to have to live

00:04:43,949 --> 00:04:48,300
with the fact that like it or not the

00:04:46,380 --> 00:04:50,639
Internet of Things is going to be here

00:04:48,300 --> 00:04:52,229
it's up to us to determine how well we

00:04:50,639 --> 00:04:55,410
build it and I suppose that ultimately

00:04:52,229 --> 00:04:59,580
the value that we get to to derive from

00:04:55,410 --> 00:05:02,639
it so smart homes smart cities Internet

00:04:59,580 --> 00:05:04,949
of Things ultimately you end up with a

00:05:02,639 --> 00:05:07,139
lot of this you end up with heaps and

00:05:04,949 --> 00:05:09,539
heaps of data and I think you know I've

00:05:07,139 --> 00:05:13,259
come out of the energy world and might

00:05:09,539 --> 00:05:14,729
be great with sort of you know smart

00:05:13,259 --> 00:05:17,130
grid as it was originally called was

00:05:14,729 --> 00:05:18,210
simply the fact that it's sort of we

00:05:17,130 --> 00:05:20,039
sort of got to the point where we were

00:05:18,210 --> 00:05:21,599
like cool we can collect data and so we

00:05:20,039 --> 00:05:24,060
collected it and then we're kind of like

00:05:21,599 --> 00:05:27,389
oh maybe we should do something with it

00:05:24,060 --> 00:05:28,979
we have really worked out what so it

00:05:27,389 --> 00:05:30,960
worked out smart grid worked out really

00:05:28,979 --> 00:05:32,849
really well if you are a telecom company

00:05:30,960 --> 00:05:34,919
that could shift data or if you're a

00:05:32,849 --> 00:05:37,349
data based company that could store data

00:05:34,919 --> 00:05:39,870
and I think this is something that I

00:05:37,349 --> 00:05:41,520
think sort of paralyzes our ability to

00:05:39,870 --> 00:05:44,280
actually do really clever things with

00:05:41,520 --> 00:05:47,639
little devices at the end of the at the

00:05:44,280 --> 00:05:49,560
end of the wires because more often than

00:05:47,639 --> 00:05:51,840
not the moment we start talking about

00:05:49,560 --> 00:05:54,060
this these are the kind of solutions

00:05:51,840 --> 00:05:56,460
that people talk about and with all due

00:05:54,060 --> 00:05:58,500
respect to these pieces of software they

00:05:56,460 --> 00:06:00,240
are absolutely fantastic pieces of

00:05:58,500 --> 00:06:02,840
software but they're the kind of

00:06:00,240 --> 00:06:06,960
software that you need to be running in

00:06:02,840 --> 00:06:10,080
large centralized data centers and they

00:06:06,960 --> 00:06:12,569
require vast amounts of resources to be

00:06:10,080 --> 00:06:14,960
able to work with these large data

00:06:12,569 --> 00:06:18,240
streams and in order to get your data

00:06:14,960 --> 00:06:19,889
from this tiny little device at the tiny

00:06:18,240 --> 00:06:20,490
end of the skinniest little wire in the

00:06:19,889 --> 00:06:22,650
middle of nowhere

00:06:20,490 --> 00:06:24,990
you've got to ship it all the way back

00:06:22,650 --> 00:06:27,960
to your servers so that you can use

00:06:24,990 --> 00:06:29,639
these kind of pieces of software then

00:06:27,960 --> 00:06:32,430
you turn it around and you send it all

00:06:29,639 --> 00:06:35,400
the way back to the device at the end of

00:06:32,430 --> 00:06:36,719
the wire so you know if you're trying to

00:06:35,400 --> 00:06:39,300
do something smart in somebody's house

00:06:36,719 --> 00:06:41,330
with their lights for example why on

00:06:39,300 --> 00:06:44,240
earth would you collect the data in the

00:06:41,330 --> 00:06:46,310
our ship it like tens of thousands of

00:06:44,240 --> 00:06:49,729
kilometers to a data center work on it

00:06:46,310 --> 00:06:51,409
and ship it back and so this is sort of

00:06:49,729 --> 00:06:55,240
the problem but I'd like to talk about

00:06:51,409 --> 00:06:57,770
today which is don't think about this

00:06:55,240 --> 00:06:59,180
don't think about the world or the data

00:06:57,770 --> 00:07:02,479
world in particular is this large

00:06:59,180 --> 00:07:05,389
centralized world where you can just

00:07:02,479 --> 00:07:06,830
always ship everything home start to

00:07:05,389 --> 00:07:09,620
think about what you can actually do

00:07:06,830 --> 00:07:12,710
with live data streams on devices like

00:07:09,620 --> 00:07:15,259
this tiny little devices super low-power

00:07:12,710 --> 00:07:18,680
in the middle of nowhere that are

00:07:15,259 --> 00:07:20,330
collecting data and I think you know to

00:07:18,680 --> 00:07:24,409
mix point here when you are talking

00:07:20,330 --> 00:07:27,650
about the the lifetime the longevity of

00:07:24,409 --> 00:07:29,560
batteries in these devices if you can

00:07:27,650 --> 00:07:32,030
avoid shipping the data over the wire

00:07:29,560 --> 00:07:34,940
you increase the battery life almost

00:07:32,030 --> 00:07:38,120
indefinitely and as we've could have

00:07:34,940 --> 00:07:41,210
moved from a world of very very sort of

00:07:38,120 --> 00:07:43,610
small computational power 4050 years ago

00:07:41,210 --> 00:07:45,169
into this modern world we sort of abused

00:07:43,610 --> 00:07:47,479
the fact that a lot of the methods that

00:07:45,169 --> 00:07:50,029
were developed 50 years ago for handling

00:07:47,479 --> 00:07:53,449
data particularly you can sit you have

00:07:50,029 --> 00:07:55,370
sort of stopped being used and so I'd

00:07:53,449 --> 00:08:00,110
like us to think about how we can do

00:07:55,370 --> 00:08:01,849
real-time data processing on reasonably

00:08:00,110 --> 00:08:04,339
frequent data streams so you know

00:08:01,849 --> 00:08:07,789
streams that could be multiple samples a

00:08:04,339 --> 00:08:09,319
second or faster on a tiny little device

00:08:07,789 --> 00:08:11,419
like this and I think you'll be

00:08:09,319 --> 00:08:14,810
surprised at how effectively you can

00:08:11,419 --> 00:08:17,300
actually do it it's quite amazing so

00:08:14,810 --> 00:08:20,719
when you are when you get to ship

00:08:17,300 --> 00:08:22,669
everything back to the data center you

00:08:20,719 --> 00:08:25,629
often then can hire a roomful of people

00:08:22,669 --> 00:08:27,860
to make your data look like this and so

00:08:25,629 --> 00:08:29,719
when you think about what most data

00:08:27,860 --> 00:08:31,909
scientists like to see this is how they

00:08:29,719 --> 00:08:33,919
start their careers they're like my data

00:08:31,909 --> 00:08:36,620
is going to look beautiful it's going to

00:08:33,919 --> 00:08:37,969
be clean it's going to appear every five

00:08:36,620 --> 00:08:39,709
seconds it's going to have nice

00:08:37,969 --> 00:08:42,769
timestamps attached to it

00:08:39,709 --> 00:08:44,449
and all the rest of it and it yeah I

00:08:42,769 --> 00:08:45,800
suppose I suppose that's true if you

00:08:44,449 --> 00:08:47,209
ship everything back home and you are a

00:08:45,800 --> 00:08:49,310
lot of really clever people you can make

00:08:47,209 --> 00:08:52,270
sure your data looks like this but when

00:08:49,310 --> 00:08:54,690
you collect data at the end of a wire

00:08:52,270 --> 00:08:58,230
your data looks like this

00:08:54,690 --> 00:09:02,010
it's terrible it's noisy it doesn't

00:08:58,230 --> 00:09:04,260
always turn up when you wanted to there

00:09:02,010 --> 00:09:07,290
were comments before around sensors in

00:09:04,260 --> 00:09:09,330
servers not returning data appropriately

00:09:07,290 --> 00:09:11,820
and that's totally true

00:09:09,330 --> 00:09:14,030
you know sense is often misread data

00:09:11,820 --> 00:09:16,950
sometimes the data doesn't come back

00:09:14,030 --> 00:09:18,600
sometimes the data is wrong senses are

00:09:16,950 --> 00:09:20,130
well known for giving Xperia starter

00:09:18,600 --> 00:09:21,480
back so you know they might be giving

00:09:20,130 --> 00:09:23,100
you pretty good readings most of the

00:09:21,480 --> 00:09:24,930
time but then all of a sudden they're

00:09:23,100 --> 00:09:26,610
not and you get readings that are so

00:09:24,930 --> 00:09:29,030
outrageously different from the others

00:09:26,610 --> 00:09:32,160
that you know they're obviously not true

00:09:29,030 --> 00:09:34,200
and I think worst of all when you have

00:09:32,160 --> 00:09:35,790
sensors sort of out in the wild you get

00:09:34,200 --> 00:09:36,990
lots of noise in a sensor and by noise

00:09:35,790 --> 00:09:39,360
you know it could be electrical noise it

00:09:36,990 --> 00:09:40,710
can be thermal noise there's lots of

00:09:39,360 --> 00:09:45,570
different things that lead to your data

00:09:40,710 --> 00:09:50,760
being really quite poor and so I'm here

00:09:45,570 --> 00:09:53,250
to convince you that filtering is the

00:09:50,760 --> 00:09:54,270
solution to all these problems so hands

00:09:53,250 --> 00:09:58,530
up if you know what I mean when I'm

00:09:54,270 --> 00:10:03,000
talking about filtering cool not coffee

00:09:58,530 --> 00:10:05,160
filtering if we in so filtering is a

00:10:03,000 --> 00:10:07,140
particular technique it's been really

00:10:05,160 --> 00:10:08,490
popularized by engineers and I know

00:10:07,140 --> 00:10:09,900
engineers a bit scary sometimes but

00:10:08,490 --> 00:10:12,360
we're reasonably friendly most of the

00:10:09,900 --> 00:10:14,310
time and so there's some methods that

00:10:12,360 --> 00:10:15,780
came out of research you know

00:10:14,310 --> 00:10:17,670
particularly one method I'm going to

00:10:15,780 --> 00:10:20,250
talk about the Kalman filter that came

00:10:17,670 --> 00:10:22,050
out of work in the 60s and if you take

00:10:20,250 --> 00:10:23,520
nothing away from this talk at all it's

00:10:22,050 --> 00:10:25,080
that if you are dealing with real time

00:10:23,520 --> 00:10:26,490
data streams and you are not using a

00:10:25,080 --> 00:10:34,980
Kalman filter then you're doing it wrong

00:10:26,490 --> 00:10:36,000
and that's not an opinion just wrong so

00:10:34,980 --> 00:10:38,640
I'm going to I'm going to motivate this

00:10:36,000 --> 00:10:41,100
with a really simple example let's say

00:10:38,640 --> 00:10:42,930
you wanted to make a smart thermostat so

00:10:41,100 --> 00:10:45,600
a smart thermostat does a couple of

00:10:42,930 --> 00:10:48,900
things number one it measures the

00:10:45,600 --> 00:10:51,270
temperature and number two it tells your

00:10:48,900 --> 00:10:53,940
heater or your furnace or your air

00:10:51,270 --> 00:10:56,550
conditioner whether to turn on and

00:10:53,940 --> 00:10:58,830
provide some heat to turn off and do

00:10:56,550 --> 00:11:00,960
nothing or maybe to provide some cooling

00:10:58,830 --> 00:11:02,250
in order to reach your setpoint so the

00:11:00,960 --> 00:11:03,000
first thing you actually have to do is

00:11:02,250 --> 00:11:06,120
you have to be able to accurately

00:11:03,000 --> 00:11:08,100
measure the temperature which seems like

00:11:06,120 --> 00:11:10,500
a really simple problem except

00:11:08,100 --> 00:11:12,209
when you start actually using sensors

00:11:10,500 --> 00:11:14,009
particularly low-cost sensors that fit

00:11:12,209 --> 00:11:15,750
onto low-cost computers at the end of a

00:11:14,009 --> 00:11:20,040
very very long wire in the middle of

00:11:15,750 --> 00:11:23,310
nowhere this is what your data might

00:11:20,040 --> 00:11:25,259
look like all right so you know in the

00:11:23,310 --> 00:11:27,630
in the energy world where you have these

00:11:25,259 --> 00:11:29,040
devices and we put them in the middle of

00:11:27,630 --> 00:11:32,009
nowhere and we're reading data off

00:11:29,040 --> 00:11:33,389
people's switchboards and it's not

00:11:32,009 --> 00:11:36,990
uncommon to see data that looks this

00:11:33,389 --> 00:11:38,970
noisy like it's not just its I think

00:11:36,990 --> 00:11:40,589
we've kind of we somehow may convince

00:11:38,970 --> 00:11:42,899
ourselves the data will always come off

00:11:40,589 --> 00:11:44,190
in a nice form and I want you to not

00:11:42,899 --> 00:11:46,050
think that because it's just never true

00:11:44,190 --> 00:11:48,630
data that comes from real sources in the

00:11:46,050 --> 00:11:52,110
wild always looks terrible and looks a

00:11:48,630 --> 00:11:54,089
bit like this and I would I would

00:11:52,110 --> 00:11:56,579
challenge anybody to be able to tell me

00:11:54,089 --> 00:12:03,649
what the actual underlying signal is in

00:11:56,579 --> 00:12:05,459
this data set so to talk about filtering

00:12:03,649 --> 00:12:07,949
what we're going to do is I'm going to

00:12:05,459 --> 00:12:10,170
talk about two particular type of

00:12:07,949 --> 00:12:13,439
filters and I'm going to show you all

00:12:10,170 --> 00:12:15,540
tomorrow at the Kalman filter and why

00:12:13,439 --> 00:12:17,670
the Kalman filters really useful and so

00:12:15,540 --> 00:12:20,069
if we go back to this problem of the

00:12:17,670 --> 00:12:22,439
thermostat and how we actually measure

00:12:20,069 --> 00:12:24,500
the temperature the goal of the third

00:12:22,439 --> 00:12:27,569
the thermostat to begin with is actually

00:12:24,500 --> 00:12:29,819
to be able to turn these measurements

00:12:27,569 --> 00:12:31,980
into something that you could use to

00:12:29,819 --> 00:12:34,380
actually then do control on a heater

00:12:31,980 --> 00:12:38,009
furnace air conditioner etc etc because

00:12:34,380 --> 00:12:41,009
if you use these samples here you would

00:12:38,009 --> 00:12:42,269
be sending control signals to turn down

00:12:41,009 --> 00:12:43,860
the heat and then turn up the heat and

00:12:42,269 --> 00:12:45,509
then turn it off and up and down all

00:12:43,860 --> 00:12:47,250
over the place and be just totally

00:12:45,509 --> 00:12:49,920
chaotic not only would you likely damage

00:12:47,250 --> 00:12:52,110
the heater or the air conditioner you're

00:12:49,920 --> 00:12:55,319
actually never going to end up with the

00:12:52,110 --> 00:12:56,519
temperature that you want and so I'm not

00:12:55,319 --> 00:12:58,620
going to get into it now but there's a

00:12:56,519 --> 00:13:00,750
really interesting branch of mathematics

00:12:58,620 --> 00:13:02,699
called optimal control and optimal

00:13:00,750 --> 00:13:05,490
controls about how you actually get a

00:13:02,699 --> 00:13:07,439
device to do something in the presence

00:13:05,490 --> 00:13:09,000
of lots of measurement noise and it

00:13:07,439 --> 00:13:10,500
turns out and the reason I said before

00:13:09,000 --> 00:13:12,000
it's an opinion that it's just wrong

00:13:10,500 --> 00:13:13,860
it's not using a Kalman filter is to do

00:13:12,000 --> 00:13:15,449
optimal control you always start with

00:13:13,860 --> 00:13:18,680
the Kalman filter there's really good

00:13:15,449 --> 00:13:20,269
reasons why and I'd like to show you

00:13:18,680 --> 00:13:21,769
so the first approach we might take to

00:13:20,269 --> 00:13:23,959
actually trying to extract this

00:13:21,769 --> 00:13:25,160
underlying signal that we're um that

00:13:23,959 --> 00:13:27,290
we're measuring here is a moving average

00:13:25,160 --> 00:13:29,389
filter so hands up if you've heard of a

00:13:27,290 --> 00:13:31,610
moving average filter before all right

00:13:29,389 --> 00:13:34,819
pretty good so moving average filter

00:13:31,610 --> 00:13:38,360
pretty simple you take a fixed number of

00:13:34,819 --> 00:13:41,480
samples from the current sample back you

00:13:38,360 --> 00:13:43,339
average them up and that's a measure of

00:13:41,480 --> 00:13:46,129
the underlying value there so you might

00:13:43,339 --> 00:13:48,350
have a moving average filter of window

00:13:46,129 --> 00:13:50,119
length five for example so you take the

00:13:48,350 --> 00:13:51,920
current sample and the four previous

00:13:50,119 --> 00:13:54,019
samples you Davidge them out and you

00:13:51,920 --> 00:13:55,879
would say that that is the output of

00:13:54,019 --> 00:13:56,809
your filter right now so if you were

00:13:55,879 --> 00:13:58,610
trying to work out what the temperature

00:13:56,809 --> 00:14:01,550
was it would be the output of that

00:13:58,610 --> 00:14:03,470
filter all right so you could also have

00:14:01,550 --> 00:14:05,809
a filter length that filter third for

00:14:03,470 --> 00:14:08,360
like thirty that filter length fifty you

00:14:05,809 --> 00:14:11,119
could have weird weighting of all the

00:14:08,360 --> 00:14:13,540
different samples and to do this but

00:14:11,119 --> 00:14:18,559
ultimately simple moving average filters

00:14:13,540 --> 00:14:19,999
reasonably good so in Python

00:14:18,559 --> 00:14:22,399
I saw all this code there's a link at

00:14:19,999 --> 00:14:26,029
the end of it all the codes up on github

00:14:22,399 --> 00:14:27,259
or 50 lines of it 60 lines of it I'd

00:14:26,029 --> 00:14:28,970
encourage you if you're interested in

00:14:27,259 --> 00:14:29,839
this to go and have a look because the

00:14:28,970 --> 00:14:31,069
thing that you'll interesting is the

00:14:29,839 --> 00:14:32,470
codes actually really simple like

00:14:31,069 --> 00:14:36,439
there's no there's nothing clever here

00:14:32,470 --> 00:14:38,179
and while I wrote this on my on my Mac I

00:14:36,439 --> 00:14:40,249
think the thing I'd like you to

00:14:38,179 --> 00:14:41,749
appreciate is there's actually there's

00:14:40,249 --> 00:14:43,939
not even any like there's nothing

00:14:41,749 --> 00:14:45,110
outside of the core library that's being

00:14:43,939 --> 00:14:46,670
used in this so if you're talking about

00:14:45,110 --> 00:14:48,290
doing implementations on tiny devices

00:14:46,670 --> 00:14:50,600
there's no barriers to using this stuff

00:14:48,290 --> 00:14:52,459
it's really really quick so the moving

00:14:50,600 --> 00:14:53,870
average filter you initialize it with

00:14:52,459 --> 00:14:57,350
this window length which there's how

00:14:53,870 --> 00:14:58,999
many samples you're going to keep every

00:14:57,350 --> 00:15:01,850
time you get a measurement you pop it

00:14:58,999 --> 00:15:03,620
into your your list and if the list gets

00:15:01,850 --> 00:15:05,240
to like you've got to begin with you

00:15:03,620 --> 00:15:06,139
don't have enough samples you just got

00:15:05,240 --> 00:15:07,399
to work with what you've got and

00:15:06,139 --> 00:15:09,589
eventually you reach a point where

00:15:07,399 --> 00:15:11,990
you're at your limit as you get a new

00:15:09,589 --> 00:15:14,449
sample you pop the first one off because

00:15:11,990 --> 00:15:16,600
you're appending at the back so you're

00:15:14,449 --> 00:15:18,649
throwing away the old samples as you go

00:15:16,600 --> 00:15:20,600
when you then want to actually get the

00:15:18,649 --> 00:15:23,660
current state of your filter which is

00:15:20,600 --> 00:15:24,199
that current temperature right now you

00:15:23,660 --> 00:15:25,790
summit

00:15:24,199 --> 00:15:26,899
divide it by the number of samples that

00:15:25,790 --> 00:15:30,009
are there's just a straight average

00:15:26,899 --> 00:15:30,009
really easy

00:15:30,440 --> 00:15:36,840
the second type of filter you might

00:15:33,510 --> 00:15:37,740
think about is the Kalman filter now the

00:15:36,840 --> 00:15:39,540
mathematics of the Kalman filter

00:15:37,740 --> 00:15:41,820
actually really clever for something

00:15:39,540 --> 00:15:44,520
that's actually really really simple and

00:15:41,820 --> 00:15:46,740
so I'm not going to deal with the

00:15:44,520 --> 00:15:49,230
mathematics behind it because I think we

00:15:46,740 --> 00:15:50,760
get we get bogged down in it but I've

00:15:49,230 --> 00:15:53,250
put some links at the end that you can

00:15:50,760 --> 00:15:55,380
go to and there was a great blog post

00:15:53,250 --> 00:15:57,600
recently that talked about the Kalman

00:15:55,380 --> 00:15:59,820
filter and the shape of the filter and

00:15:57,600 --> 00:16:01,560
what it means sort of mathematically as

00:15:59,820 --> 00:16:04,440
you're using it so I'd encourage you to

00:16:01,560 --> 00:16:06,930
go and read that but in simple terms

00:16:04,440 --> 00:16:09,150
what the Kalman filter says is it says

00:16:06,930 --> 00:16:11,670
when I want to update a measurement I

00:16:09,150 --> 00:16:14,070
probably should take into account how

00:16:11,670 --> 00:16:16,830
much noise there is in my measurement so

00:16:14,070 --> 00:16:17,640
if there's lots of noise every time I

00:16:16,830 --> 00:16:19,800
get a sample

00:16:17,640 --> 00:16:21,990
I only learn a little bit more about the

00:16:19,800 --> 00:16:23,970
underlying signal so if there was no

00:16:21,990 --> 00:16:26,040
noise at all I could trust the signal so

00:16:23,970 --> 00:16:28,530
if you had a flat you know if I if I

00:16:26,040 --> 00:16:30,330
could measure something perfectly my

00:16:28,530 --> 00:16:33,090
nose level would essentially be zero and

00:16:30,330 --> 00:16:34,710
so I can trust that that is the

00:16:33,090 --> 00:16:37,790
temperature that I'm trying to read or

00:16:34,710 --> 00:16:40,500
the value of the underlying data stream

00:16:37,790 --> 00:16:42,960
but if it's really noisy I can't trust

00:16:40,500 --> 00:16:44,580
it that would be silly and so what the

00:16:42,960 --> 00:16:47,760
Kalman filter does is it says every time

00:16:44,580 --> 00:16:49,170
I get a new sample I I know a little bit

00:16:47,760 --> 00:16:51,390
about the noise structure you have to

00:16:49,170 --> 00:16:53,430
sort of tell it that up front but it's

00:16:51,390 --> 00:16:55,830
very robust to that information you give

00:16:53,430 --> 00:16:57,390
it up front it says well I've only

00:16:55,830 --> 00:17:00,000
learned a little bit from this piece of

00:16:57,390 --> 00:17:01,380
data and so it's it then uses the next

00:17:00,000 --> 00:17:04,410
piece of data learnt a little bit more

00:17:01,380 --> 00:17:07,610
and so the rate at which the filter sort

00:17:04,410 --> 00:17:10,680
of converges to the solution depends on

00:17:07,610 --> 00:17:12,000
the the underlying noise level so if

00:17:10,680 --> 00:17:15,330
there's more noise it takes slightly

00:17:12,000 --> 00:17:17,220
longer to converge but it rejects the

00:17:15,330 --> 00:17:20,100
noise that's there in the values that it

00:17:17,220 --> 00:17:21,600
gives so does anyone have any questions

00:17:20,100 --> 00:17:23,990
on that that's probably the most complex

00:17:21,600 --> 00:17:27,870
thing I'm going to say today I just

00:17:23,990 --> 00:17:31,380
alright so the you know long story short

00:17:27,870 --> 00:17:32,970
the Kalman filter is mindful of how much

00:17:31,380 --> 00:17:35,520
information it's gathering each time it

00:17:32,970 --> 00:17:38,490
reads it and the really interesting

00:17:35,520 --> 00:17:41,940
thing from the Kalman filter is just

00:17:38,490 --> 00:17:43,530
that it only needs two values to store

00:17:41,940 --> 00:17:47,220
in memory to complete

00:17:43,530 --> 00:17:48,540
we characterize the datastream so with a

00:17:47,220 --> 00:17:50,130
moving average filter if I have window

00:17:48,540 --> 00:17:52,380
length 5 I have to store the last 5

00:17:50,130 --> 00:17:54,780
samples if I have window length 50 I

00:17:52,380 --> 00:17:55,710
have to store last 50 samples with a

00:17:54,780 --> 00:17:58,280
Kalman filter

00:17:55,710 --> 00:18:00,480
I only ever have to store two values

00:17:58,280 --> 00:18:02,690
that's that's amazing when you think

00:18:00,480 --> 00:18:05,070
about it but I can give you an accurate

00:18:02,690 --> 00:18:08,420
and accurate measurement of the

00:18:05,070 --> 00:18:08,420
underlying value that I'm reading

00:18:54,159 --> 00:19:02,169
sorry I'm I'm back and the thing I'd

00:19:00,590 --> 00:19:05,330
like you to take away from this is that

00:19:02,169 --> 00:19:06,770
Kalman filter slightly more complex to

00:19:05,330 --> 00:19:09,380
implement than a moving average filter

00:19:06,770 --> 00:19:13,419
but not super complex still only

00:19:09,380 --> 00:19:16,250
probably 30 lines of code tops and still

00:19:13,419 --> 00:19:19,450
you know ultimately you can implement it

00:19:16,250 --> 00:19:22,190
without without using things outside the

00:19:19,450 --> 00:19:26,809
core Python library and it runs

00:19:22,190 --> 00:19:28,429
blindingly fast so the beauty of the

00:19:26,809 --> 00:19:31,760
Kalman filter is actually that it can

00:19:28,429 --> 00:19:33,710
handle multiple data streams in parallel

00:19:31,760 --> 00:19:35,149
and so it's really really useful where

00:19:33,710 --> 00:19:37,640
you might be collecting lots of data

00:19:35,149 --> 00:19:40,580
simultaneously particularly where you

00:19:37,640 --> 00:19:43,010
have say correlation between them and so

00:19:40,580 --> 00:19:44,240
these are really challenging problem to

00:19:43,010 --> 00:19:45,710
solve and so we're only going to solve

00:19:44,240 --> 00:19:47,809
it in a single variable case we've just

00:19:45,710 --> 00:19:49,070
got one data stream but the power of the

00:19:47,809 --> 00:19:51,320
Kalman filter is that it actually

00:19:49,070 --> 00:19:53,029
extends into as many parallel data

00:19:51,320 --> 00:19:56,659
streams as you want still gives you

00:19:53,029 --> 00:20:00,649
really really good results so

00:19:56,659 --> 00:20:02,480
initializing the the two filters is is

00:20:00,649 --> 00:20:04,820
interesting you know if you see down the

00:20:02,480 --> 00:20:06,140
bottom implementing the instantiating

00:20:04,820 --> 00:20:07,520
the moving average filter you just need

00:20:06,140 --> 00:20:09,890
to give it a window length which is

00:20:07,520 --> 00:20:11,750
pretty simple when you instantiate a a

00:20:09,890 --> 00:20:13,429
Kalman filter you have to tell it a

00:20:11,750 --> 00:20:14,809
little bit about the system that you're

00:20:13,429 --> 00:20:17,409
kind of measuring but when it comes to

00:20:14,809 --> 00:20:20,630
just just I'm using it for measurements

00:20:17,409 --> 00:20:22,669
it's really quite simple the one thing

00:20:20,630 --> 00:20:24,260
that you have to say the two parameters

00:20:22,669 --> 00:20:26,090
that I think are just worth sort of

00:20:24,260 --> 00:20:27,860
touching on just so it doesn't look like

00:20:26,090 --> 00:20:30,289
as I'm doing any magic behind the scenes

00:20:27,860 --> 00:20:33,020
here you have to pick an initial

00:20:30,289 --> 00:20:34,250
estimate and now the found one filters

00:20:33,020 --> 00:20:35,390
are really robust to your initial

00:20:34,250 --> 00:20:36,590
estimate so you could actually pick it

00:20:35,390 --> 00:20:38,000
you know you could start it off with a

00:20:36,590 --> 00:20:40,159
million or a billion or zero or whatever

00:20:38,000 --> 00:20:41,510
and still going to work but in reality

00:20:40,159 --> 00:20:45,010
if you were doing something like

00:20:41,510 --> 00:20:47,149
temperature it's probably a pretty fair

00:20:45,010 --> 00:20:48,799
statement that you can probably pick an

00:20:47,149 --> 00:20:49,789
initial temperature reasonably

00:20:48,799 --> 00:20:51,620
accurately you don't have to pick it

00:20:49,789 --> 00:20:53,870
accurately you just just pick a number

00:20:51,620 --> 00:20:54,919
so Kalman filter pick something sensible

00:20:53,870 --> 00:20:57,529
doesn't actually matter what are these

00:20:54,919 --> 00:20:59,240
it'll work anyway but just to show you

00:20:57,529 --> 00:21:01,940
that you actually have to pick something

00:20:59,240 --> 00:21:03,500
the other thing you have to pick is the

00:21:01,940 --> 00:21:05,149
amount of noise so you have to kind of

00:21:03,500 --> 00:21:07,179
you have to set the covariance which

00:21:05,149 --> 00:21:10,279
sort of a statistical measure of noise I

00:21:07,179 --> 00:21:11,960
won't talk about how you do it here but

00:21:10,279 --> 00:21:14,809
suffice to say it's actually if you

00:21:11,960 --> 00:21:16,450
sample any set of data it's actually

00:21:14,809 --> 00:21:19,009
really really easy to work out what the

00:21:16,450 --> 00:21:20,629
statistical noise is there so we the

00:21:19,009 --> 00:21:22,159
Kalman filter you can it's pretty easy

00:21:20,629 --> 00:21:25,099
to work out how much noise you have in

00:21:22,159 --> 00:21:28,639
your system that you can then initialize

00:21:25,099 --> 00:21:31,609
the filter so I suppose again it don't

00:21:28,639 --> 00:21:32,779
worry too much about that it's still you

00:21:31,609 --> 00:21:34,700
don't need to actually know anything

00:21:32,779 --> 00:21:36,259
about a system before you start using a

00:21:34,700 --> 00:21:39,109
filter xx so using the Kalman filter and

00:21:36,259 --> 00:21:45,159
you still get good results so you

00:21:39,109 --> 00:21:49,940
implement these these filters and then

00:21:45,159 --> 00:21:53,059
this represents the entire processing

00:21:49,940 --> 00:21:56,259
you need to do on a data stream in order

00:21:53,059 --> 00:22:00,049
to use the filters so I created this

00:21:56,259 --> 00:22:03,080
vector of random data which we saw

00:22:00,049 --> 00:22:05,749
earlier which was plotted and then all

00:22:03,080 --> 00:22:08,179
these filters look like I'm just they're

00:22:05,749 --> 00:22:10,039
all set up to take data sequentially so

00:22:08,179 --> 00:22:12,259
you don't get all your data at once this

00:22:10,039 --> 00:22:13,999
is like if you were reading off you know

00:22:12,259 --> 00:22:15,499
reading off a temperature sensor you

00:22:13,999 --> 00:22:17,659
take your temperature reading you chuck

00:22:15,499 --> 00:22:19,700
it into the filter and then you can

00:22:17,659 --> 00:22:21,589
measure the predictor predicted

00:22:19,700 --> 00:22:22,789
temperature out then you get another

00:22:21,589 --> 00:22:24,139
sample we chuck it in another

00:22:22,789 --> 00:22:25,729
measurement so it's really simple you

00:22:24,139 --> 00:22:27,320
don't have to you have to keep all your

00:22:25,729 --> 00:22:29,179
data you have to store it you definitely

00:22:27,320 --> 00:22:30,889
don't need to ship it over the wire to a

00:22:29,179 --> 00:22:33,409
database to then process it you can do

00:22:30,889 --> 00:22:36,379
it all in situ in a tiny tiny tiny

00:22:33,409 --> 00:22:42,379
amount of cycles and in a tiny tiny tiny

00:22:36,379 --> 00:22:44,149
amount of memory so back to our data so

00:22:42,379 --> 00:22:47,659
I'm going to show you first the results

00:22:44,149 --> 00:22:49,339
of a filter that's got a some moving

00:22:47,659 --> 00:22:53,690
average filter with a window length of

00:22:49,339 --> 00:22:55,249
five so it's better than the raw data so

00:22:53,690 --> 00:22:57,200
we're starting starting to look a little

00:22:55,249 --> 00:22:59,379
bit better still pretty noisy though

00:22:57,200 --> 00:23:01,759
it's still sort of jumps around a lot

00:22:59,379 --> 00:23:03,379
probably the key thing you can see out

00:23:01,759 --> 00:23:05,419
of this is it starts to look like

00:23:03,379 --> 00:23:08,089
there's a pretty definite point at which

00:23:05,419 --> 00:23:12,440
we changed underlying temperatures here

00:23:08,089 --> 00:23:15,280
so that's useful it's good to know

00:23:12,440 --> 00:23:18,860
then we add then we try out what the

00:23:15,280 --> 00:23:21,410
moving average filter looks like with a

00:23:18,860 --> 00:23:22,220
window length of 50 and now you're kind

00:23:21,410 --> 00:23:24,290
of like well that's actually really

00:23:22,220 --> 00:23:28,250
quite impressive like it's it's pretty

00:23:24,290 --> 00:23:30,410
much picked up you know that the the

00:23:28,250 --> 00:23:32,210
underlying data signal there so for

00:23:30,410 --> 00:23:35,420
those playing along at home the it was

00:23:32,210 --> 00:23:37,670
the underlying signal was twenty degrees

00:23:35,420 --> 00:23:39,200
for the first hundred samples and then

00:23:37,670 --> 00:23:40,550
twenty two degrees for the second

00:23:39,200 --> 00:23:43,400
hundred samples and so you can look at

00:23:40,550 --> 00:23:45,980
that these some you can look at these

00:23:43,400 --> 00:23:47,750
filters you the you know the one with

00:23:45,980 --> 00:23:50,540
fifty year window length of 50 is pretty

00:23:47,750 --> 00:23:52,070
good I could actually pick that up one

00:23:50,540 --> 00:23:55,100
of the key issues though that it has is

00:23:52,070 --> 00:23:58,060
it takes a long time to recognize the

00:23:55,100 --> 00:24:00,140
change in the underlying temperature and

00:23:58,060 --> 00:24:01,490
if you were trying to control your

00:24:00,140 --> 00:24:03,200
thermostat that might not be great

00:24:01,490 --> 00:24:06,110
because it might take you a long time

00:24:03,200 --> 00:24:07,490
using this filter to work out you have

00:24:06,110 --> 00:24:09,020
to turn the heater up or you've got to

00:24:07,490 --> 00:24:12,680
turn it down or something like that and

00:24:09,020 --> 00:24:15,500
so this is the this is one of the key

00:24:12,680 --> 00:24:17,630
issues with the moving average filter is

00:24:15,500 --> 00:24:19,220
that it's heavily dependent on the

00:24:17,630 --> 00:24:20,660
window length that you choose and so you

00:24:19,220 --> 00:24:23,810
ultimately need to actually know

00:24:20,660 --> 00:24:25,580
something about your system in order to

00:24:23,810 --> 00:24:28,640
get it to work properly and to give you

00:24:25,580 --> 00:24:30,370
really good answers having said that if

00:24:28,640 --> 00:24:33,110
you were just going to use the raw data

00:24:30,370 --> 00:24:34,580
for your application then just implement

00:24:33,110 --> 00:24:36,140
a moving average instead because it's a

00:24:34,580 --> 00:24:37,280
lot better than what you would get if

00:24:36,140 --> 00:24:41,300
you were just implementing the raw data

00:24:37,280 --> 00:24:44,450
but you wouldn't do that because you

00:24:41,300 --> 00:24:46,220
would all use the Kalman filter and so

00:24:44,450 --> 00:24:50,000
the Kalman filters the black filter here

00:24:46,220 --> 00:24:53,840
and while I didn't hear the oohs and

00:24:50,000 --> 00:24:56,340
ahhs that I was sort of hoping for

00:24:53,840 --> 00:24:57,450
you should see that the the Kalman

00:24:56,340 --> 00:25:00,269
filter is actually really quite

00:24:57,450 --> 00:25:01,889
impressive given that it uses no memory

00:25:00,269 --> 00:25:02,909
only remembering two things remember so

00:25:01,889 --> 00:25:04,169
doesn't remember it doesn't have to

00:25:02,909 --> 00:25:07,259
remember any of your past data so it

00:25:04,169 --> 00:25:09,179
takes up no space in RAM it's not only

00:25:07,259 --> 00:25:11,879
really highly accurate of actually

00:25:09,179 --> 00:25:14,369
pulling out the underlying signal but it

00:25:11,879 --> 00:25:16,849
much more quickly realizes that the

00:25:14,369 --> 00:25:19,919
setpoint of temperature has changed and

00:25:16,849 --> 00:25:21,149
so it's really easy to configure because

00:25:19,919 --> 00:25:24,119
you only have to tell it about the noise

00:25:21,149 --> 00:25:27,419
not about the not about peaking

00:25:24,119 --> 00:25:29,340
arbitrary window lengths and so on so I

00:25:27,419 --> 00:25:32,639
know that when you go home tonight

00:25:29,340 --> 00:25:36,259
you're you're going to be doing an re in

00:25:32,639 --> 00:25:39,450
your heads but really impressive so I

00:25:36,259 --> 00:25:43,289
don't um I don't have much more to sort

00:25:39,450 --> 00:25:46,049
of end on but I really would like you to

00:25:43,289 --> 00:25:47,999
take away from this the fact that we

00:25:46,049 --> 00:25:49,710
live in a world where you can ship it

00:25:47,999 --> 00:25:52,799
over the wire and use a very very big

00:25:49,710 --> 00:25:54,960
data base to work out the to work out

00:25:52,799 --> 00:25:56,789
what's going on with your data but we've

00:25:54,960 --> 00:25:58,349
also got all of these amazing techniques

00:25:56,789 --> 00:26:00,210
and the Kalman filters just one of them

00:25:58,349 --> 00:26:03,239
to actually work with data Steen streams

00:26:00,210 --> 00:26:05,309
on device on tiny little devices that

00:26:03,239 --> 00:26:07,080
have very little memory very little

00:26:05,309 --> 00:26:09,690
computational horsepower and you can do

00:26:07,080 --> 00:26:12,090
pretty amazing things in the home or in

00:26:09,690 --> 00:26:13,950
the location where the or device is and

00:26:12,090 --> 00:26:15,840
if you do this you don't care if the

00:26:13,950 --> 00:26:18,629
internet works because if the Internet's

00:26:15,840 --> 00:26:19,739
only working 10 percent of the time it

00:26:18,629 --> 00:26:21,330
really doesn't bother you because you

00:26:19,739 --> 00:26:25,320
can continue to perform these

00:26:21,330 --> 00:26:27,179
calculations so if your thermostat were

00:26:25,320 --> 00:26:29,009
to use this kind of approach for

00:26:27,179 --> 00:26:30,539
measuring temperature you would be able

00:26:29,009 --> 00:26:32,669
to control the temperature locally and

00:26:30,539 --> 00:26:34,080
you would not need to phone home at all

00:26:32,669 --> 00:26:35,909
in order to provide a really awesome

00:26:34,080 --> 00:26:37,229
customer experience by ensuring that the

00:26:35,909 --> 00:26:39,419
house is always at the right temperature

00:26:37,229 --> 00:26:41,070
and that I think is is pretty amazing

00:26:39,419 --> 00:26:42,570
and that's why I think you should all

00:26:41,070 --> 00:26:45,320
make sure you use common filters in

00:26:42,570 --> 00:26:45,320
future projects

00:26:54,960 --> 00:27:05,379
questions thanks man

00:27:02,710 --> 00:27:07,840
I'm working on a project currently which

00:27:05,379 --> 00:27:09,940
is all about solar power and I'm using a

00:27:07,840 --> 00:27:12,220
little embedded system to measure

00:27:09,940 --> 00:27:14,409
current usage and whatnot one of the

00:27:12,220 --> 00:27:16,950
problems I faced is that measuring

00:27:14,409 --> 00:27:19,059
current usage uses current and that

00:27:16,950 --> 00:27:21,009
introduced noise in all my measuring

00:27:19,059 --> 00:27:23,230
have you come across a similar thing and

00:27:21,009 --> 00:27:25,179
is this sort of a filter for that data

00:27:23,230 --> 00:27:27,309
going to improve my chances like I've

00:27:25,179 --> 00:27:28,989
tried medians I've tried all sorts of

00:27:27,309 --> 00:27:34,720
low-pass filters to try get around that

00:27:28,989 --> 00:27:36,970
it's a tricky one for me this will sound

00:27:34,720 --> 00:27:39,549
really try it when I say it go home get

00:27:36,970 --> 00:27:41,649
the code off github implement it and it

00:27:39,549 --> 00:27:44,350
will work and it will emit and it will

00:27:41,649 --> 00:27:46,739
amaze you that it will work and the guy

00:27:44,350 --> 00:27:49,659
the guy who invented it's a genius so

00:27:46,739 --> 00:27:52,149
he's only recently passed away Rudolph

00:27:49,659 --> 00:27:54,460
common for filter he's amazing like it's

00:27:52,149 --> 00:27:57,220
mathematically optimal in a well

00:27:54,460 --> 00:28:00,009
described situation so it's mathematical

00:27:57,220 --> 00:28:02,259
up to where you have Gaussian noise but

00:28:00,009 --> 00:28:03,609
it just works in every case like there's

00:28:02,259 --> 00:28:04,359
just not a case it doesn't work and

00:28:03,609 --> 00:28:06,549
doesn't matter when you have uniform

00:28:04,359 --> 00:28:07,869
noise or really random noise or any

00:28:06,549 --> 00:28:10,090
other shape but just as long as the

00:28:07,869 --> 00:28:12,100
noise is symmetric Kalman filter always

00:28:10,090 --> 00:28:16,629
work and I'll be surprised if it doesn't

00:28:12,100 --> 00:28:26,200
fix your problem instantaneously you

00:28:16,629 --> 00:28:28,960
guys here any more questions let's say

00:28:26,200 --> 00:28:31,749
you're in a industrial application where

00:28:28,960 --> 00:28:35,169
the data fluctuates because it's real

00:28:31,749 --> 00:28:41,529
how do you separate noise from a signal

00:28:35,169 --> 00:28:42,249
that's supposed to fluctuate feel like

00:28:41,529 --> 00:28:46,590
we're going to have a lot of these

00:28:42,249 --> 00:28:46,590
answers and you just use a common filter

00:28:47,229 --> 00:28:52,039
and I know again I know it sounds really

00:28:50,330 --> 00:28:54,259
try it just it's always like that just

00:28:52,039 --> 00:28:55,999
just use it but it will blow you blow

00:28:54,259 --> 00:28:59,080
your mind like as long as you can get

00:28:55,999 --> 00:29:01,070
the as long as you have the underlying

00:28:59,080 --> 00:29:03,499
noise measurement which is really really

00:29:01,070 --> 00:29:05,479
easy to get the the Kalman filter I

00:29:03,499 --> 00:29:07,279
actually have sort of I've I haven't

00:29:05,479 --> 00:29:08,629
told you the whole truth about the

00:29:07,279 --> 00:29:10,879
Kalman filtering that a Kalman filter

00:29:08,629 --> 00:29:12,799
not only implements it's not only great

00:29:10,879 --> 00:29:14,960
for pulling out measurement noise but it

00:29:12,799 --> 00:29:18,049
actually allows you to have processes to

00:29:14,960 --> 00:29:20,539
input to on to get very sensible

00:29:18,049 --> 00:29:23,299
estimates for when you measure processes

00:29:20,539 --> 00:29:24,919
that have underlying dynamics so if you

00:29:23,299 --> 00:29:25,879
were just reading temperature there's

00:29:24,919 --> 00:29:27,379
you're not assuming there's anything

00:29:25,879 --> 00:29:29,179
that's changing our temperature but in

00:29:27,379 --> 00:29:31,190
an industrial standard say you're doing

00:29:29,179 --> 00:29:33,049
something chemist making the chemical

00:29:31,190 --> 00:29:34,489
processing or something like that you

00:29:33,049 --> 00:29:39,379
can actually model what the chemical

00:29:34,489 --> 00:29:41,299
processing does so that you that allows

00:29:39,379 --> 00:29:42,919
you to work out your prediction of what

00:29:41,299 --> 00:29:45,589
would happen given a particular state

00:29:42,919 --> 00:29:46,999
you feed in noisy measurements and you

00:29:45,589 --> 00:29:49,879
still get really excellent state

00:29:46,999 --> 00:29:51,289
estimates coming at the end so you know

00:29:49,879 --> 00:29:52,879
Kalman filters are sort of typically

00:29:51,289 --> 00:29:54,229
seen outside of the engineering world

00:29:52,879 --> 00:29:57,559
it's just a little bit too complex to

00:29:54,229 --> 00:29:59,330
work with but they're really not and you

00:29:57,559 --> 00:30:00,859
know you sometimes it takes a little bit

00:29:59,330 --> 00:30:02,989
of time just to understand the dynamics

00:30:00,859 --> 00:30:04,399
that's going on there and to write the

00:30:02,989 --> 00:30:06,289
filters from oxide more complex

00:30:04,399 --> 00:30:07,719
situations but I'd always encourage you

00:30:06,289 --> 00:30:09,559
to do it because once you've licked it

00:30:07,719 --> 00:30:16,279
you're never going to have the used

00:30:09,559 --> 00:30:19,249
measurement issues again do you have to

00:30:16,279 --> 00:30:20,960
keep updating your noise covariance over

00:30:19,249 --> 00:30:26,509
time because you're assuming the signal

00:30:20,960 --> 00:30:31,389
stationary basically if you're not yes

00:30:26,509 --> 00:30:33,440
so you can so the base sort of the

00:30:31,389 --> 00:30:35,989
Kalman field is a bit like buying any

00:30:33,440 --> 00:30:38,450
car you can get the base model which is

00:30:35,989 --> 00:30:42,349
sort of this model and you tend to have

00:30:38,450 --> 00:30:44,929
stationary noise yep there's like so

00:30:42,349 --> 00:30:46,669
many variations of Kalman filters to

00:30:44,929 --> 00:30:48,259
take into account where your car

00:30:46,669 --> 00:30:51,109
variants changes over time or where you

00:30:48,259 --> 00:30:54,169
have different types of noise or where

00:30:51,109 --> 00:30:55,609
you have you know there's unscented

00:30:54,169 --> 00:30:59,329
filters there's filters for when it's

00:30:55,609 --> 00:31:00,890
nonlinear so you just have to match the

00:30:59,329 --> 00:31:02,870
choice of you you know your fly

00:31:00,890 --> 00:31:08,240
favor of Kalman filter to the problem

00:31:02,870 --> 00:31:13,040
that you have and what do you you use a

00:31:08,240 --> 00:31:15,170
Kalman filter B no no and again I know

00:31:13,040 --> 00:31:17,480
it sounds it sounds really silly to keep

00:31:15,170 --> 00:31:19,190
saying it but it's mathematics the

00:31:17,480 --> 00:31:21,410
Kalman filter is mathematically optimal

00:31:19,190 --> 00:31:22,970
when it's Gaussian so you cannot do any

00:31:21,410 --> 00:31:24,860
better than Kalman but if it's not

00:31:22,970 --> 00:31:26,120
Gaussian as long as it's symmetric the

00:31:24,860 --> 00:31:28,850
Kalman filter still works flawlessly

00:31:26,120 --> 00:31:31,310
I've I've never seen a Kalman filter not

00:31:28,850 --> 00:31:31,730
work in a way just in any situation

00:31:31,310 --> 00:31:34,580
actually

00:31:31,730 --> 00:31:36,110
but like this I know it seems like magic

00:31:34,580 --> 00:31:37,460
I feel really silly I don't mean to it

00:31:36,110 --> 00:31:38,750
seems like magic it just it just kind of

00:31:37,460 --> 00:31:46,820
is it's just awesome it just works

00:31:38,750 --> 00:31:49,310
really really well I was just wondering

00:31:46,820 --> 00:31:51,530
if you'd come across the Udacity course

00:31:49,310 --> 00:31:54,230
on AI that's taught by sebastian run

00:31:51,530 --> 00:31:56,930
because it's basically a extended

00:31:54,230 --> 00:31:58,370
tutorial on Kalman filters and how

00:31:56,930 --> 00:32:01,040
they're basically the centerpiece of

00:31:58,370 --> 00:32:02,510
Google's self-driving car AI so if

00:32:01,040 --> 00:32:07,100
anyone's interested in Kalman filters I

00:32:02,510 --> 00:32:08,780
recommend it it's a good tip I'm not

00:32:07,100 --> 00:32:10,760
particularly familiar with that but

00:32:08,780 --> 00:32:12,140
there's a reason that Google and

00:32:10,760 --> 00:32:18,920
everybody else uses Kalman filters

00:32:12,140 --> 00:32:20,780
because it's the right thing to do yeah

00:32:18,920 --> 00:32:22,610
thank you uh if there's an array of

00:32:20,780 --> 00:32:25,460
sensors spread across geographical areas

00:32:22,610 --> 00:32:29,450
and you got to make decisions based on

00:32:25,460 --> 00:32:31,400
so if bullet network of filters be good

00:32:29,450 --> 00:32:33,140
is will you still recommend everything

00:32:31,400 --> 00:32:36,770
in that network become and filter as the

00:32:33,140 --> 00:32:39,670
other ones I feel like we all know the

00:32:36,770 --> 00:32:39,670
answer to this question

00:32:40,769 --> 00:32:48,340
yes so the the Kalman filters usually

00:32:46,389 --> 00:32:49,869
implemented as a matrix problem because

00:32:48,340 --> 00:32:53,019
it deals with multiple channels so if

00:32:49,869 --> 00:32:55,570
you have a network of a network of data

00:32:53,019 --> 00:32:57,489
so sorry a network of sensors that all

00:32:55,570 --> 00:33:00,610
have data streams coming from them you

00:32:57,489 --> 00:33:02,799
use the sort of matrix form of the the

00:33:00,610 --> 00:33:04,389
Kalman filter which is like basically

00:33:02,799 --> 00:33:07,179
the same except divisions replaced by

00:33:04,389 --> 00:33:09,700
the inversion of a matrix which is still

00:33:07,179 --> 00:33:11,220
relatively quick I mean realistically

00:33:09,700 --> 00:33:13,299
once you start moving into the matrix

00:33:11,220 --> 00:33:16,119
problems you have to then include say

00:33:13,299 --> 00:33:19,119
numpy if you wanted it to be easy

00:33:16,119 --> 00:33:21,820
although the nice thing is that all of

00:33:19,119 --> 00:33:25,119
the like all matrix problems are

00:33:21,820 --> 00:33:27,789
typically quite fast to run on most

00:33:25,119 --> 00:33:30,629
embedded devices because you can reduce

00:33:27,789 --> 00:33:33,519
them down to addition multiplication and

00:33:30,629 --> 00:33:34,899
division without needing the matrix

00:33:33,519 --> 00:33:36,609
implementation so you don't actually

00:33:34,899 --> 00:33:39,340
need numpy in order to do matrix

00:33:36,609 --> 00:33:41,679
calculations if you're dealing with them

00:33:39,340 --> 00:33:42,909
on very very small devices if you're

00:33:41,679 --> 00:33:44,470
dealing with one slightly larger devices

00:33:42,909 --> 00:33:47,679
so raspberry PI's and things like that

00:33:44,470 --> 00:33:51,359
you can start to use things like Atlas

00:33:47,679 --> 00:33:54,369
and LA Park and those kind of low-level

00:33:51,359 --> 00:33:59,320
C libraries that do matrix computations

00:33:54,369 --> 00:34:02,549
really really quick I'm being asked to

00:33:59,320 --> 00:34:02,549
stop so you want one more question

00:34:03,450 --> 00:34:09,490
um so you're saying that you shouldn't

00:34:06,820 --> 00:34:13,000
bother in general sending your raw data

00:34:09,490 --> 00:34:16,149
over the wire and storing it on a server

00:34:13,000 --> 00:34:19,419
somewhere but wouldn't there still be

00:34:16,149 --> 00:34:23,379
value in a lot of situations in doing

00:34:19,419 --> 00:34:26,139
that because the Kalman filter is yeah

00:34:23,379 --> 00:34:28,030
sure it's a it's the best way to to get

00:34:26,139 --> 00:34:30,819
a good signal but you might still want

00:34:28,030 --> 00:34:33,339
the raw data for doing other analysis

00:34:30,819 --> 00:34:37,270
later or as proof of what the raw data

00:34:33,339 --> 00:34:40,510
was yeah totally I mean I'm not I'm not

00:34:37,270 --> 00:34:42,639
I'm not suggesting that we that we never

00:34:40,510 --> 00:34:44,679
store raw data ever I suppose what I am

00:34:42,639 --> 00:34:46,119
suggesting is just that if you're going

00:34:44,679 --> 00:34:47,799
to use the raw if you're going to use

00:34:46,119 --> 00:34:49,510
the data locally to make other decisions

00:34:47,799 --> 00:34:51,159
or to make you know to close the control

00:34:49,510 --> 00:34:52,679
loop or anything like that it's

00:34:51,159 --> 00:34:55,809
worthwhile

00:34:52,679 --> 00:34:57,329
processing their it also means that you

00:34:55,809 --> 00:34:59,619
don't have the problem anymore of

00:34:57,329 --> 00:35:01,180
needing the internet to be up because

00:34:59,619 --> 00:35:03,369
you can still cash all that data and

00:35:01,180 --> 00:35:06,430
send it up when it's available but you

00:35:03,369 --> 00:35:08,740
actually have useful data available you

00:35:06,430 --> 00:35:10,210
know on device in real time without

00:35:08,740 --> 00:35:13,150
worrying about connectivity and things

00:35:10,210 --> 00:35:16,289
like that cool I've overstayed my

00:35:13,150 --> 00:35:16,289

YouTube URL: https://www.youtube.com/watch?v=gFeTkB8VHpw


