Title: GPS Tracking with Python
Publication date: 2016-08-16
Playlist: IoT 2016 (Miniconf)
Description: 
	Caleb Hattingh
https://2016.pycon-au.org/schedule/159/view_talk
Python is very well-suited to implement GPS tracking services.  Devices need to report position data to servers, and Python handles this role well, especially with the new support for asynchronous event loops in Python 3 which can handle tens of thousands of simultaneous connections.  In addition, the struct module in the Python standard library makes short work of processing binary data supplied by devices. In addition to basic interaction with tracking devices, this talk will also present methods of integration (server) testing using py.test, as well as considerations regarding support for both UDP and TCP protocols in the same stack, since different GPS tracking devices may prefer one or the other.
Captions: 
	00:00:00,030 --> 00:00:05,069
okay so GPS tracking with Python so my

00:00:03,840 --> 00:00:07,740
history is a bit complicated I've worked

00:00:05,069 --> 00:00:09,269
on a whole bunch of different odd things

00:00:07,740 --> 00:00:11,639
the most recent big project that I've

00:00:09,269 --> 00:00:14,880
done is I did an absurdly huge video

00:00:11,639 --> 00:00:17,869
course on siphon or O'Reilly which I'm

00:00:14,880 --> 00:00:20,039
speaking about again on Sunday and

00:00:17,869 --> 00:00:21,720
besides that I don't want to go into too

00:00:20,039 --> 00:00:24,449
much I've started an education platform

00:00:21,720 --> 00:00:27,060
called Cody mojo comp and my blog this

00:00:24,449 --> 00:00:29,369
path nomicon calm I spoke in last year's

00:00:27,060 --> 00:00:30,390
education Minicon and kerri-anne filburn

00:00:29,369 --> 00:00:32,250
the director of the Raspberry Pi

00:00:30,390 --> 00:00:33,480
foundation was in the audience and she

00:00:32,250 --> 00:00:36,239
blogged that I was a very nervous

00:00:33,480 --> 00:00:41,730
developer so if anyone blogs please

00:00:36,239 --> 00:00:44,550
don't say a minute okay

00:00:41,730 --> 00:00:48,329
so about this talk it's really about

00:00:44,550 --> 00:00:49,739
approaching GPS tracking from the

00:00:48,329 --> 00:00:51,300
perspective of an application developer

00:00:49,739 --> 00:00:54,270
so if you're not a hardware guy or

00:00:51,300 --> 00:00:55,379
you're not a someone who's building the

00:00:54,270 --> 00:01:05,010
devices or anything like that but you're

00:00:55,379 --> 00:01:16,320
really wanting to write a platform is it

00:01:05,010 --> 00:01:17,729
just testing bitter okay so the

00:01:16,320 --> 00:01:19,259
application lifecycle from the point of

00:01:17,729 --> 00:01:20,790
view of an application developer so

00:01:19,259 --> 00:01:22,560
you're receiving data that is that is

00:01:20,790 --> 00:01:27,000
coming from devices you have to receive

00:01:22,560 --> 00:01:28,799
it process it and store it so the menu

00:01:27,000 --> 00:01:30,630
for for the talk is pretty simple so

00:01:28,799 --> 00:01:32,009
we're going to look at the source of the

00:01:30,630 --> 00:01:33,930
data where it comes from and I'm going

00:01:32,009 --> 00:01:35,640
to focus just really on OBD vehicle

00:01:33,930 --> 00:01:36,810
devices these things that you plug into

00:01:35,640 --> 00:01:39,299
your car and I'll show you what that

00:01:36,810 --> 00:01:41,009
looks like shortly the destination where

00:01:39,299 --> 00:01:42,180
the data actually gets sent to which is

00:01:41,009 --> 00:01:44,670
the server that you're responsible for

00:01:42,180 --> 00:01:46,290
writing and then how you do a little bit

00:01:44,670 --> 00:01:47,729
of message handling there's not a lot of

00:01:46,290 --> 00:01:49,079
time to go into detail so I'm really

00:01:47,729 --> 00:01:52,710
going to give a high-level overview of

00:01:49,079 --> 00:01:54,000
each of these sections I'm moving

00:01:52,710 --> 00:01:55,890
quickly because I think I have too many

00:01:54,000 --> 00:01:58,710
slides so if I begin to accelerate at

00:01:55,890 --> 00:02:01,020
the end that that's what's going on so

00:01:58,710 --> 00:02:02,130
we'll start at the data source and this

00:02:01,020 --> 00:02:03,630
was a really hard picture to find

00:02:02,130 --> 00:02:06,360
because you don't find many pictures

00:02:03,630 --> 00:02:09,030
that can clearly communicate cars

00:02:06,360 --> 00:02:10,649
transmitting data but if we're talking

00:02:09,030 --> 00:02:12,200
about OBD devices that's really what

00:02:10,649 --> 00:02:14,810
happens

00:02:12,200 --> 00:02:17,090
the OBD device plugs into the car and it

00:02:14,810 --> 00:02:18,980
transmits a signal usually fired GPRS

00:02:17,090 --> 00:02:22,190
once you provision the device over the

00:02:18,980 --> 00:02:23,540
cellular network that's the kind of

00:02:22,190 --> 00:02:26,120
thing that I'm talking about so this is

00:02:23,540 --> 00:02:27,440
an a track model but there are others

00:02:26,120 --> 00:02:28,640
that look incredibly similar they're

00:02:27,440 --> 00:02:30,860
really nothing much to look at their

00:02:28,640 --> 00:02:35,840
little black boxes and they literally

00:02:30,860 --> 00:02:37,520
plug into your car so if your car is has

00:02:35,840 --> 00:02:39,620
been made within the last 10 to 15 years

00:02:37,520 --> 00:02:41,540
you almost definitely already have one

00:02:39,620 --> 00:02:44,600
of these waiting for something to plug

00:02:41,540 --> 00:02:45,830
into it there this is an American

00:02:44,600 --> 00:02:47,510
vehicle so the steering wheels on the

00:02:45,830 --> 00:02:49,280
wrong side but it would be in a similar

00:02:47,510 --> 00:02:50,720
place on the other side if you have

00:02:49,280 --> 00:02:56,600
never checked before check in your car

00:02:50,720 --> 00:02:58,640
and you'll see one of those ports so now

00:02:56,600 --> 00:03:01,340
it's time to get to more detail about

00:02:58,640 --> 00:03:03,860
these devices there are a huge number of

00:03:01,340 --> 00:03:06,470
vendors and they all observe the spec

00:03:03,860 --> 00:03:08,120
for the for the OBD port itself but what

00:03:06,470 --> 00:03:10,100
we'll get to is that everything

00:03:08,120 --> 00:03:10,910
everything else about the process they

00:03:10,100 --> 00:03:12,860
have come up with their own

00:03:10,910 --> 00:03:14,540
implementations of everything and when

00:03:12,860 --> 00:03:16,130
you're building a platform that has to

00:03:14,540 --> 00:03:18,470
abstract away the differences between

00:03:16,130 --> 00:03:20,840
different devices that's really quite a

00:03:18,470 --> 00:03:30,560
lot of work and you'll see you'll see

00:03:20,840 --> 00:03:32,570
what I mean in the next few slides okay

00:03:30,560 --> 00:03:34,310
so one thing you can do as well is you

00:03:32,570 --> 00:03:36,110
can receive data from mobile apps you

00:03:34,310 --> 00:03:37,670
don't have to write your own there are a

00:03:36,110 --> 00:03:39,709
couple of apps that will already

00:03:37,670 --> 00:03:42,020
transmit data to a server of your choice

00:03:39,709 --> 00:03:43,550
and they publish some protocol

00:03:42,020 --> 00:03:46,100
documentation about what the payload

00:03:43,550 --> 00:03:48,530
looks like and typically you'll write a

00:03:46,100 --> 00:03:52,100
TCP server because devices well so this

00:03:48,530 --> 00:03:53,690
device submits HTTP messages but for the

00:03:52,100 --> 00:03:56,720
OBD devices they usually make TCP

00:03:53,690 --> 00:03:58,610
connections this app in particular has

00:03:56,720 --> 00:03:59,930
it is quite well written and gives you a

00:03:58,610 --> 00:04:02,810
lot of information about your cell phone

00:03:59,930 --> 00:04:05,120
and it will cache data if it cannot

00:04:02,810 --> 00:04:06,470
transmit and then fetch it up later so

00:04:05,120 --> 00:04:08,570
if you want to play around with writing

00:04:06,470 --> 00:04:11,390
service to receive GPS data that that's

00:04:08,570 --> 00:04:15,850
a good app to get as a starting point

00:04:11,390 --> 00:04:15,850
and it runs on both Android and iOS

00:04:17,199 --> 00:04:21,919
so that's the hardware part finished the

00:04:20,239 --> 00:04:23,360
other talks were very hardware centric

00:04:21,919 --> 00:04:24,889
which is what I expected so I'm rather

00:04:23,360 --> 00:04:27,500
going to focus more on on what you do

00:04:24,889 --> 00:04:28,699
with the data and that's supposed to be

00:04:27,500 --> 00:04:30,310
a picture of a server I don't if that's

00:04:28,699 --> 00:04:34,520
obvious or not

00:04:30,310 --> 00:04:36,290
so as James explained earlier with

00:04:34,520 --> 00:04:37,729
Internet of Things type situations

00:04:36,290 --> 00:04:41,090
you're really dealing with a huge amount

00:04:37,729 --> 00:04:42,800
of clients different connections and so

00:04:41,090 --> 00:04:44,330
you you really have to do event loop

00:04:42,800 --> 00:04:46,460
type programming to manage all of these

00:04:44,330 --> 00:04:48,169
concurrent connections that's the

00:04:46,460 --> 00:04:52,070
metaphor here so the fish on the devices

00:04:48,169 --> 00:04:56,870
and you have to write the server so it's

00:04:52,070 --> 00:04:58,550
a high concurrency situation so with the

00:04:56,870 --> 00:05:01,190
Oh buddy devices the vast majority of

00:04:58,550 --> 00:05:03,919
them do TCP connections and really long

00:05:01,190 --> 00:05:05,810
love TCP connections the the keeper live

00:05:03,919 --> 00:05:08,620
period is around four hours to give you

00:05:05,810 --> 00:05:11,479
an idea of what we're talking about and

00:05:08,620 --> 00:05:13,820
many of the devices do that they're able

00:05:11,479 --> 00:05:15,410
to communicate in either TCP or UDP and

00:05:13,820 --> 00:05:16,789
you can determine how they do that by

00:05:15,410 --> 00:05:19,220
provisioning the device with a

00:05:16,789 --> 00:05:20,780
particular configuration very few

00:05:19,220 --> 00:05:23,180
devices but there are some of them they

00:05:20,780 --> 00:05:26,419
they do UDP only so that they will not

00:05:23,180 --> 00:05:28,340
do TCP connections and as I mentioned

00:05:26,419 --> 00:05:29,870
before they use event loops you have to

00:05:28,340 --> 00:05:31,250
use event loops because if you have tens

00:05:29,870 --> 00:05:33,590
of thousands of devices connected to you

00:05:31,250 --> 00:05:35,990
to your service you'll run into the 10k

00:05:33,590 --> 00:05:37,700
problem you you simply run out of enough

00:05:35,990 --> 00:05:42,530
memory to produce the threads necessary

00:05:37,700 --> 00:05:44,120
to serve the the clients so if you start

00:05:42,530 --> 00:05:46,099
doing this kind of work you'll see that

00:05:44,120 --> 00:05:48,680
there are there are already a bunch of

00:05:46,099 --> 00:05:52,039
pre-existing frameworks for doing event

00:05:48,680 --> 00:05:53,780
loop based servers in Python in my

00:05:52,039 --> 00:05:56,360
particular case before I started working

00:05:53,780 --> 00:05:58,430
on this project tornado had already been

00:05:56,360 --> 00:06:00,530
selected in the stack which is really

00:05:58,430 --> 00:06:03,410
good because tornado is awesome it has a

00:06:00,530 --> 00:06:06,110
an extremely simple API and you can get

00:06:03,410 --> 00:06:06,970
started very quickly this is just one

00:06:06,110 --> 00:06:10,400
problem

00:06:06,970 --> 00:06:12,979
tornado doesn't include Datagram support

00:06:10,400 --> 00:06:14,599
in the stack and there are some devices

00:06:12,979 --> 00:06:18,110
which you only realize after you've

00:06:14,599 --> 00:06:20,780
implemented 15 protocols that tornado

00:06:18,110 --> 00:06:22,660
doesn't do you DP'd up by default so

00:06:20,780 --> 00:06:25,219
what you do is you check out pi pi and

00:06:22,660 --> 00:06:27,289
there are not that many options and then

00:06:25,219 --> 00:06:29,510
you check github and there are a couple

00:06:27,289 --> 00:06:30,620
but the code looks shaky and there are

00:06:29,510 --> 00:06:31,039
comments towards the bond web page

00:06:30,620 --> 00:06:35,659
that's

00:06:31,039 --> 00:06:37,729
this is broken don't use it so what I

00:06:35,659 --> 00:06:39,740
did to get around that in in a very

00:06:37,729 --> 00:06:42,800
short turnaround time was I wrote a

00:06:39,740 --> 00:06:45,080
bridge that bridges UDP to TCP so that I

00:06:42,800 --> 00:06:46,759
could treat the implementation of the

00:06:45,080 --> 00:06:48,589
device protocol for this particular

00:06:46,759 --> 00:06:50,659
device in exactly the same way as the

00:06:48,589 --> 00:06:52,999
others so it's protocol implementation

00:06:50,659 --> 00:06:55,580
is also done with tornado but there's a

00:06:52,999 --> 00:06:57,110
UDP bridge sitting in front of it which

00:06:55,580 --> 00:06:59,360
is probably not the right thing to do

00:06:57,110 --> 00:07:01,039
but I could get it done in a day and the

00:06:59,360 --> 00:07:03,770
reason for that is because async i/o

00:07:01,039 --> 00:07:07,370
already provides UDP and TCP with with

00:07:03,770 --> 00:07:11,689
exactly the same API one thing to point

00:07:07,370 --> 00:07:14,419
out is that there is a new event loop

00:07:11,689 --> 00:07:16,819
really called UV loop which is a

00:07:14,419 --> 00:07:18,860
third-party library that matches the

00:07:16,819 --> 00:07:20,149
same API async i/o UV loop is

00:07:18,860 --> 00:07:22,490
implemented in scythe on and its

00:07:20,149 --> 00:07:24,979
performance in single threaded mode is

00:07:22,490 --> 00:07:27,620
exactly the same as go it's really

00:07:24,979 --> 00:07:29,389
really incredible so if I were to start

00:07:27,620 --> 00:07:31,159
such a platform type project again I

00:07:29,389 --> 00:07:36,949
definitely would begin with async i/o

00:07:31,159 --> 00:07:38,389
and use UV Lew yeah so this is a good

00:07:36,949 --> 00:07:40,129
point that this is what you will begin

00:07:38,389 --> 00:07:42,559
to see when you start benchmarking your

00:07:40,129 --> 00:07:43,729
service concurrency is actually a CPU

00:07:42,559 --> 00:07:44,809
bound process which is really

00:07:43,729 --> 00:07:47,899
interesting because what you're talking

00:07:44,809 --> 00:07:49,729
about all the times networking and we we

00:07:47,899 --> 00:07:51,199
could use the idea that anytime you're

00:07:49,729 --> 00:07:53,149
working with networking stuff CPU

00:07:51,199 --> 00:07:56,689
doesn't really matter if you're within

00:07:53,149 --> 00:07:58,490
10 20 times of a compiled language it

00:07:56,689 --> 00:07:59,959
doesn't really matter because your i/o

00:07:58,490 --> 00:08:02,330
bound and your waiting on an event

00:07:59,959 --> 00:08:04,279
processing the thing about concurrency

00:08:02,330 --> 00:08:05,899
is once you begin adding multiple

00:08:04,279 --> 00:08:07,459
clients you actually do need to shout

00:08:05,899 --> 00:08:09,169
out that CPU time to many different

00:08:07,459 --> 00:08:10,729
clients so it actually does begin to

00:08:09,169 --> 00:08:12,249
matter and you definitely see that when

00:08:10,729 --> 00:08:14,689
you start comparing the different tools

00:08:12,249 --> 00:08:15,949
that's why you via loop is so incredible

00:08:14,689 --> 00:08:18,349
because it actually gives you all this

00:08:15,949 --> 00:08:21,860
Headroom because all of the event

00:08:18,349 --> 00:08:23,839
processing is based on Looby so the

00:08:21,860 --> 00:08:25,459
amount of concurrency you can do with UV

00:08:23,839 --> 00:08:27,080
loop as opposed to just plain async i/o

00:08:25,459 --> 00:08:35,510
or tornado or twisted or any of the

00:08:27,080 --> 00:08:37,880
other frameworks is much much better ok

00:08:35,510 --> 00:08:39,800
so message handling as I mentioned

00:08:37,880 --> 00:08:42,140
before each of the different device

00:08:39,800 --> 00:08:45,020
vendors well almost to a man has

00:08:42,140 --> 00:08:46,880
implemented their the device protocol in

00:08:45,020 --> 00:08:48,050
a different way and in a different in a

00:08:46,880 --> 00:08:49,790
completely different way like they

00:08:48,050 --> 00:08:51,470
aren't even matching characteristics how

00:08:49,790 --> 00:08:54,500
they do by packing and all of those

00:08:51,470 --> 00:08:55,820
things so it almost feels like you have

00:08:54,500 --> 00:08:58,220
to start from scratch every single time

00:08:55,820 --> 00:09:00,110
a new event or vendor comes on you have

00:08:58,220 --> 00:09:01,460
to read their protocol documentation see

00:09:00,110 --> 00:09:03,620
how they differ from everyone else and

00:09:01,460 --> 00:09:05,480
see if you can try and abstract some

00:09:03,620 --> 00:09:07,010
commonality from what you've done before

00:09:05,480 --> 00:09:08,330
for previous protocols and they usually

00:09:07,010 --> 00:09:10,310
isn't match and that's really incredible

00:09:08,330 --> 00:09:12,140
to me because the data that they provide

00:09:10,310 --> 00:09:13,970
largely is almost exactly the same I

00:09:12,140 --> 00:09:15,860
just I find that's really incredible

00:09:13,970 --> 00:09:18,260
and it seems to come up quite frequently

00:09:15,860 --> 00:09:22,400
in Hardware in hardware and based

00:09:18,260 --> 00:09:24,470
systems so just give you a quick feel

00:09:22,400 --> 00:09:25,370
for what it looks like to do this kind

00:09:24,470 --> 00:09:28,160
of work

00:09:25,370 --> 00:09:31,010
and first we'll do ascii-based messages

00:09:28,160 --> 00:09:33,800
data that's encoded in in plain text SP

00:09:31,010 --> 00:09:36,530
and then later we'll do a little bit of

00:09:33,800 --> 00:09:39,080
binary unpacking so here are two

00:09:36,530 --> 00:09:40,880
examples of messages where that transmit

00:09:39,080 --> 00:09:42,410
GPS coordinates and timestamp and

00:09:40,880 --> 00:09:44,480
identifies and so on so we'll just step

00:09:42,410 --> 00:09:45,590
through this quickly just to see the

00:09:44,480 --> 00:09:47,090
kind of things that you would look for

00:09:45,590 --> 00:09:48,470
when processing these messages and how

00:09:47,090 --> 00:09:51,170
do you how you would extract the parts

00:09:48,470 --> 00:09:52,940
out with these they're pretty easy the

00:09:51,170 --> 00:09:55,610
delimiters are obvious and and the

00:09:52,940 --> 00:09:59,120
documentation will tell you what to do

00:09:55,610 --> 00:10:01,760
so let's step through it quickly so it's

00:09:59,120 --> 00:10:03,740
very common for messages to have a

00:10:01,760 --> 00:10:05,450
header to start and a terminator at the

00:10:03,740 --> 00:10:06,890
end to tell you what the start and end

00:10:05,450 --> 00:10:08,570
up messages is and that's quite

00:10:06,890 --> 00:10:10,430
important because data comes in on

00:10:08,570 --> 00:10:13,310
streams so you have to be able to buffer

00:10:10,430 --> 00:10:14,570
less or more and determine when the end

00:10:13,310 --> 00:10:21,370
is there so that you can chop it often

00:10:14,570 --> 00:10:24,470
and process it then the devices transmit

00:10:21,370 --> 00:10:26,660
identifier unique identifiers and this

00:10:24,470 --> 00:10:30,170
is a big reason why TCP is preferred

00:10:26,660 --> 00:10:32,090
with a lot of devices because TCP has a

00:10:30,170 --> 00:10:34,490
very well-defined behavior regarding how

00:10:32,090 --> 00:10:36,350
the connection works many devices will

00:10:34,490 --> 00:10:37,880
log on with their identifier but they

00:10:36,350 --> 00:10:39,290
won't transmit it in subsequent messages

00:10:37,880 --> 00:10:40,820
because they don't have to if a

00:10:39,290 --> 00:10:42,650
disconnection occurs they will they will

00:10:40,820 --> 00:10:44,270
connect again with the identifier and

00:10:42,650 --> 00:10:46,400
that saves some bytes on every

00:10:44,270 --> 00:10:48,940
subsequent message so so that's why TCP

00:10:46,400 --> 00:10:48,940
is very common

00:10:49,310 --> 00:10:54,180
the time stamps are usually UNIX

00:10:52,200 --> 00:10:57,990
timestamps and they're almost always

00:10:54,180 --> 00:10:59,610
transmitted in UTC which is which you

00:10:57,990 --> 00:11:01,620
you begin to realize once you get a

00:10:59,610 --> 00:11:03,030
device that doesn't transmit in UTC and

00:11:01,620 --> 00:11:04,860
it transmits in the local time zone and

00:11:03,030 --> 00:11:06,150
then you spend a great deal of time

00:11:04,860 --> 00:11:09,000
thinking about how do you convert that

00:11:06,150 --> 00:11:11,190
to UTC given that you only have the GPS

00:11:09,000 --> 00:11:13,110
coordinates that means you have to think

00:11:11,190 --> 00:11:15,090
where you are in the world and what time

00:11:13,110 --> 00:11:17,640
zone is it and is that day lie saved so

00:11:15,090 --> 00:11:19,980
we did not implement that device that

00:11:17,640 --> 00:11:22,740
was within local time because you have

00:11:19,980 --> 00:11:25,500
to set up a whole other server just to

00:11:22,740 --> 00:11:30,870
be able to convert local time plus GPS

00:11:25,500 --> 00:11:33,330
coordinates into UTC time and there you

00:11:30,870 --> 00:11:35,130
have the coordinates the the way of

00:11:33,330 --> 00:11:37,050
encoding these differs greatly from

00:11:35,130 --> 00:11:38,340
device to device it just so happens that

00:11:37,050 --> 00:11:39,570
for these two that I've chosen here

00:11:38,340 --> 00:11:41,100
they're similar but but they aren't

00:11:39,570 --> 00:11:43,880
always similar sometimes you have

00:11:41,100 --> 00:11:47,190
degrees minutes seconds separated and

00:11:43,880 --> 00:11:49,500
sometimes they include signs more often

00:11:47,190 --> 00:11:53,520
they include north and south east and

00:11:49,500 --> 00:11:55,800
west okay and I guess we're now getting

00:11:53,520 --> 00:11:58,440
to the point where they it's like the

00:11:55,800 --> 00:12:00,090
lessons learned section of the of the

00:11:58,440 --> 00:12:01,620
talk if you have to ever write this kind

00:12:00,090 --> 00:12:06,660
of code these are things to watch out

00:12:01,620 --> 00:12:10,800
for so time daytime who enjoys working

00:12:06,660 --> 00:12:12,180
with daytime so there's a trick there's

00:12:10,800 --> 00:12:14,850
a trick to make daytime's work much

00:12:12,180 --> 00:12:17,670
better and the trick is always specify

00:12:14,850 --> 00:12:18,930
time zone specify time zone every single

00:12:17,670 --> 00:12:21,030
time you create a daytime object

00:12:18,930 --> 00:12:23,850
wherever the source comes from specified

00:12:21,030 --> 00:12:26,250
in the constructor that particular call

00:12:23,850 --> 00:12:28,350
there is is really terrible because what

00:12:26,250 --> 00:12:32,010
it does is it gives it gives you the

00:12:28,350 --> 00:12:33,720
time in the UTC time zone as a daytime

00:12:32,010 --> 00:12:36,090
object but without the time zone

00:12:33,720 --> 00:12:37,680
information in the object so when you

00:12:36,090 --> 00:12:41,370
subtract that what you get from that

00:12:37,680 --> 00:12:43,650
from another time that is in the local

00:12:41,370 --> 00:12:45,720
time zone you get obviously the time

00:12:43,650 --> 00:12:47,370
zone difference it's not much you can do

00:12:45,720 --> 00:12:48,900
about that and these kinds of bugs are

00:12:47,370 --> 00:12:50,700
actually pretty hard to hard to figure

00:12:48,900 --> 00:12:51,990
out you write your tests your test pass

00:12:50,700 --> 00:12:53,340
you upload to your server which is

00:12:51,990 --> 00:12:53,550
running in US east or something like

00:12:53,340 --> 00:12:57,560
that

00:12:53,550 --> 00:12:57,560
and nothing works your times all wrong

00:12:58,700 --> 00:13:03,230
so always do that

00:13:00,770 --> 00:13:05,390
when you create day times always specify

00:13:03,230 --> 00:13:08,120
the time zone so Python by default has

00:13:05,390 --> 00:13:11,390
the UTC time zone included which you can

00:13:08,120 --> 00:13:14,360
get like that this is this is Python 3

00:13:11,390 --> 00:13:16,190
and if you need other time zones there's

00:13:14,360 --> 00:13:18,200
a package called PI TZ which offers all

00:13:16,190 --> 00:13:20,600
of them and it's well developed and

00:13:18,200 --> 00:13:22,459
heavily updated if there's one thing you

00:13:20,600 --> 00:13:26,930
take from this talk specify time zones

00:13:22,459 --> 00:13:29,930
and all audio times ok so now we get to

00:13:26,930 --> 00:13:33,580
raw messages the thing about your

00:13:29,930 --> 00:13:36,020
messages is yes they are efficient and I

00:13:33,580 --> 00:13:38,440
guess that's the best the main argument

00:13:36,020 --> 00:13:41,000
and all of the device vendors support

00:13:38,440 --> 00:13:42,649
raw messages but the problem is it's

00:13:41,000 --> 00:13:44,420
really difficult to debug these things

00:13:42,649 --> 00:13:46,990
because what you get in the payload is

00:13:44,420 --> 00:13:48,890
this representation and you can't easily

00:13:46,990 --> 00:13:50,990
determine what is in the message without

00:13:48,890 --> 00:13:53,690
actually writing the parser for the data

00:13:50,990 --> 00:13:55,910
so if your job is to write the parser

00:13:53,690 --> 00:13:57,890
you cut see what is first in the message

00:13:55,910 --> 00:14:00,290
in order to write the parser so you have

00:13:57,890 --> 00:14:01,910
to follow the documentation to see what

00:14:00,290 --> 00:14:07,490
the sequence of bytes bits and bytes is

00:14:01,910 --> 00:14:11,149
and many devices will can be configured

00:14:07,490 --> 00:14:13,339
to submit either binary data or SQ data

00:14:11,149 --> 00:14:14,660
and you have to do inspection if you

00:14:13,339 --> 00:14:16,010
don't control the provisioning of the

00:14:14,660 --> 00:14:17,630
device so you don't know ahead of time

00:14:16,010 --> 00:14:18,890
which one's going to be you can usually

00:14:17,630 --> 00:14:20,779
do some kind of inspection on the first

00:14:18,890 --> 00:14:23,060
few bytes determine whether that's

00:14:20,779 --> 00:14:26,890
likely to be ASCII or binary and then

00:14:23,060 --> 00:14:26,890
have a code path that deals were there

00:14:28,660 --> 00:14:34,730
documentation is quite spotty and it's

00:14:31,459 --> 00:14:36,709
putty in a frustrating way this is an

00:14:34,730 --> 00:14:38,690
example of a minor frustration that you

00:14:36,709 --> 00:14:40,220
can clear up just by just by

00:14:38,690 --> 00:14:41,899
communicating with the vendor so you can

00:14:40,220 --> 00:14:44,240
say well on this line where you said

00:14:41,899 --> 00:14:47,170
speed you know you said not but then the

00:14:44,240 --> 00:14:48,980
example you said km/h which one is it

00:14:47,170 --> 00:14:49,899
irritating but you but you can deal with

00:14:48,980 --> 00:14:53,870
that quite easily

00:14:49,899 --> 00:14:55,790
these are worse so here you have an

00:14:53,870 --> 00:14:57,950
example of some binary data that gets

00:14:55,790 --> 00:15:01,250
uploaded right so when I read the tests

00:14:57,950 --> 00:15:03,860
for this that message there at the top

00:15:01,250 --> 00:15:07,579
failed it failed because it's size was

00:15:03,860 --> 00:15:10,310
not the sized that the header two pieces

00:15:07,579 --> 00:15:14,400
up said I was going to be it said 60

00:15:10,310 --> 00:15:16,620
bytes but that was 59 bytes it

00:15:14,400 --> 00:15:19,290
so happened that in this specific case a

00:15:16,620 --> 00:15:21,300
very similar message who was transmitted

00:15:19,290 --> 00:15:23,040
later where it had zero one at the end

00:15:21,300 --> 00:15:26,340
and there was the missing byte and there

00:15:23,040 --> 00:15:28,020
were five more below this so you you

00:15:26,340 --> 00:15:29,930
have to be a little bit of a detective

00:15:28,020 --> 00:15:32,250
sometimes to deal with these

00:15:29,930 --> 00:15:34,770
documentation problems what you cannot

00:15:32,250 --> 00:15:36,210
do is just write the parser according to

00:15:34,770 --> 00:15:37,890
the documentation and assume that's

00:15:36,210 --> 00:15:39,300
going to work that's not going to work

00:15:37,890 --> 00:15:42,090
you have to write tests for everything

00:15:39,300 --> 00:15:44,250
to make sure that it works and sometimes

00:15:42,090 --> 00:15:45,510
I write tests against the documentation

00:15:44,250 --> 00:15:47,520
and the examples that they give in the

00:15:45,510 --> 00:15:49,740
documentation and the test pass and I

00:15:47,520 --> 00:15:51,240
set up the server and occasionally a

00:15:49,740 --> 00:15:54,120
device that says it matches that

00:15:51,240 --> 00:15:55,770
protocol will submit data that fails

00:15:54,120 --> 00:15:57,990
exceptions get thrown on the server and

00:15:55,770 --> 00:15:59,310
then I copy those payloads and I paste

00:15:57,990 --> 00:16:02,370
them into my tests and their tests and

00:15:59,310 --> 00:16:04,440
those tests fail so it's it is actually

00:16:02,370 --> 00:16:06,800
quite difficult to make robust parsers

00:16:04,440 --> 00:16:08,700
for these police device protocols in

00:16:06,800 --> 00:16:10,350
principle you can usually choose which

00:16:08,700 --> 00:16:11,400
vendors you want to work with but if

00:16:10,350 --> 00:16:13,380
you're building a platform that it's

00:16:11,400 --> 00:16:16,920
gonna take everyone on you don't really

00:16:13,380 --> 00:16:18,630
have that choice I've done 15 protocols

00:16:16,920 --> 00:16:19,920
now for different vendors devices and

00:16:18,630 --> 00:16:20,400
all of them have been completely

00:16:19,920 --> 00:16:22,650
different

00:16:20,400 --> 00:16:26,690
not even similarities between any two of

00:16:22,650 --> 00:16:26,690
them which is really quite interesting

00:16:28,010 --> 00:16:31,950
okay so a couple couple of tools that

00:16:30,210 --> 00:16:33,720
you're going to lean on very heavily the

00:16:31,950 --> 00:16:36,090
first destruct the struct module in

00:16:33,720 --> 00:16:37,440
Python is amazing you only realize that

00:16:36,090 --> 00:16:40,320
when you really have to do this kind of

00:16:37,440 --> 00:16:42,870
work and this work that I've been doing

00:16:40,320 --> 00:16:44,250
in management it's really the first time

00:16:42,870 --> 00:16:47,010
that I've had to use struct heavily and

00:16:44,250 --> 00:16:48,480
I've really begun to appreciate it just

00:16:47,010 --> 00:16:51,290
in case you haven't used it before

00:16:48,480 --> 00:16:54,240
what struck does is it lets you chop up

00:16:51,290 --> 00:16:56,670
white strings and assign them to

00:16:54,240 --> 00:16:58,070
different variables so I'll give you a

00:16:56,670 --> 00:17:00,720
quick example of a heartbeat message

00:16:58,070 --> 00:17:02,310
that an eight-track device might send

00:17:00,720 --> 00:17:04,589
this would be a heartbeat or keep a live

00:17:02,310 --> 00:17:07,200
message that we notify you to keep the

00:17:04,589 --> 00:17:10,050
connection open so first you have keep

00:17:07,200 --> 00:17:12,870
alive header and then you have eight

00:17:10,050 --> 00:17:15,600
bytes for the device ID and the other

00:17:12,870 --> 00:17:17,700
message counter and if the particular

00:17:15,600 --> 00:17:19,380
device supports acknowledgments you have

00:17:17,700 --> 00:17:20,760
to supply that same message counter back

00:17:19,380 --> 00:17:22,230
in the acknowledgment and that's the way

00:17:20,760 --> 00:17:24,570
the device knows that that message was

00:17:22,230 --> 00:17:25,560
transmitted if it does not receive that

00:17:24,570 --> 00:17:28,180
knowledge meant it will transmit the

00:17:25,560 --> 00:17:30,550
same message again

00:17:28,180 --> 00:17:32,830
so we struct comes in is it let's you

00:17:30,550 --> 00:17:34,990
unpack that sequence of bytes directly

00:17:32,830 --> 00:17:37,060
in one line so there is a table

00:17:34,990 --> 00:17:39,840
instructor documentation that gives you

00:17:37,060 --> 00:17:44,650
a code for every different size of bytes

00:17:39,840 --> 00:17:47,650
so H is short two bytes q is eight bytes

00:17:44,650 --> 00:17:48,970
and another two bytes and you can unpack

00:17:47,650 --> 00:17:51,670
the data and then you can get your three

00:17:48,970 --> 00:17:53,860
fields out on the back end so that's

00:17:51,670 --> 00:17:55,750
really good I use it a lot there you can

00:17:53,860 --> 00:17:57,280
see we've unpacked our IMEI number and

00:17:55,750 --> 00:18:00,610
the response counter that we need to

00:17:57,280 --> 00:18:04,990
send back to the device however we can

00:18:00,610 --> 00:18:07,120
do better what I found after using

00:18:04,990 --> 00:18:08,560
struct enough times is that there is a

00:18:07,120 --> 00:18:11,860
lot of boilerplate that has to go around

00:18:08,560 --> 00:18:13,750
how you use struct what what I've built

00:18:11,860 --> 00:18:15,100
is a tool for myself and instead of

00:18:13,750 --> 00:18:16,600
showing the implementation of the tool

00:18:15,100 --> 00:18:17,880
I'll show you how to use it because

00:18:16,600 --> 00:18:20,920
you'll be able to build it yourself

00:18:17,880 --> 00:18:22,930
definitely this is a much easier way of

00:18:20,920 --> 00:18:25,000
doing the loop divide unpacking you have

00:18:22,930 --> 00:18:28,150
one long string where you have name

00:18:25,000 --> 00:18:30,700
equals name equals value not value but

00:18:28,150 --> 00:18:32,020
you know the byte size so name equals

00:18:30,700 --> 00:18:33,780
format name equals format one long

00:18:32,020 --> 00:18:36,280
string and inside that function

00:18:33,780 --> 00:18:38,140
you basically just split that by comma

00:18:36,280 --> 00:18:41,710
and then you separate out the format

00:18:38,140 --> 00:18:43,390
strings from the headers then you do the

00:18:41,710 --> 00:18:44,890
actual unpack call that you would have

00:18:43,390 --> 00:18:46,180
done normally and then when you get the

00:18:44,890 --> 00:18:48,490
results out you assign them back to the

00:18:46,180 --> 00:18:50,590
others and return a dict it makes it

00:18:48,490 --> 00:18:52,900
much easier to access the values that

00:18:50,590 --> 00:18:54,010
you get out so you can put a lot of the

00:18:52,900 --> 00:18:56,410
boilerplate that you normally would have

00:18:54,010 --> 00:18:58,060
to do around the unpack call you can put

00:18:56,410 --> 00:18:59,380
inside that function I would be quite

00:18:58,060 --> 00:19:01,210
surprised if there were other people who

00:18:59,380 --> 00:19:06,700
are heavily using struct who didn't have

00:19:01,210 --> 00:19:07,120
similar features like this so yeah there

00:19:06,700 --> 00:19:08,320
at the bottom

00:19:07,120 --> 00:19:10,680
tools like this make make a huge

00:19:08,320 --> 00:19:12,880
difference when you start doing

00:19:10,680 --> 00:19:15,580
repetitive kind of work like this

00:19:12,880 --> 00:19:16,720
you have to build some extra tooling

00:19:15,580 --> 00:19:21,160
around what the standard library offers

00:19:16,720 --> 00:19:23,020
to make to make that easier okay and

00:19:21,160 --> 00:19:24,610
this is the last slide so python has

00:19:23,020 --> 00:19:27,690
awesome support for number

00:19:24,610 --> 00:19:30,730
representation it is really really good

00:19:27,690 --> 00:19:33,640
you can do bitwise you can use bit wise

00:19:30,730 --> 00:19:35,170
operators to toggle bits and shift bits

00:19:33,640 --> 00:19:36,580
around and and that kind of thing but

00:19:35,170 --> 00:19:39,040
you can get a lot of mileage just out of

00:19:36,580 --> 00:19:41,950
the formatting support in Python itself

00:19:39,040 --> 00:19:44,590
so here I've got a number 21

00:19:41,950 --> 00:19:46,330
and you can format it into hex so that

00:19:44,590 --> 00:19:49,180
we get 15 out and you can also specify

00:19:46,330 --> 00:19:52,870
the the number directly just beginning

00:19:49,180 --> 00:19:57,310
with 0 X 15 and that is actually a value

00:19:52,870 --> 00:19:59,820
of 21 octal is supported there although

00:19:57,310 --> 00:20:02,950
I haven't really used that very much and

00:19:59,820 --> 00:20:04,720
you have binary support so native

00:20:02,950 --> 00:20:06,460
built-in binary support you can specify

00:20:04,720 --> 00:20:10,470
integers with the binary representation

00:20:06,460 --> 00:20:12,640
and you can format integers as binary

00:20:10,470 --> 00:20:14,680
doesn't take too long to realize that

00:20:12,640 --> 00:20:16,270
you can start getting the exact width of

00:20:14,680 --> 00:20:18,880
bits that you want for a particular

00:20:16,270 --> 00:20:20,860
field because struct gets you down to

00:20:18,880 --> 00:20:23,500
the byte level but if you need to toggle

00:20:20,860 --> 00:20:25,840
bits inside a particular byte which is

00:20:23,500 --> 00:20:28,240
which is quite common in the binary

00:20:25,840 --> 00:20:29,530
formats for the OBD devices you really

00:20:28,240 --> 00:20:34,480
need to be able to toggle the bits

00:20:29,530 --> 00:20:37,120
directly or inspect them so the binary

00:20:34,480 --> 00:20:39,160
formatting lets you easily log out what

00:20:37,120 --> 00:20:40,780
which bits are set so in your debug

00:20:39,160 --> 00:20:43,000
level logging you can get very clear

00:20:40,780 --> 00:20:45,670
idea of which bits are set and then

00:20:43,000 --> 00:20:47,440
whether that matches up to your later

00:20:45,670 --> 00:20:52,090
data structures that you have set up to

00:20:47,440 --> 00:20:53,470
hold that information so once you get

00:20:52,090 --> 00:20:54,700
into a string and you make sure the

00:20:53,470 --> 00:20:56,290
order is right you can actually index

00:20:54,700 --> 00:21:00,460
into the string and check whether the

00:20:56,290 --> 00:21:02,320
thing is 0 or 1 so this is absolutely

00:21:00,460 --> 00:21:03,880
not as efficient as if you were to use

00:21:02,320 --> 00:21:06,160
bitwise operators which is the normal

00:21:03,880 --> 00:21:07,540
way of doing this but it reads very very

00:21:06,160 --> 00:21:07,960
easily and especially for testing and

00:21:07,540 --> 00:21:10,060
debugging

00:21:07,960 --> 00:21:16,500
I found B's these tricks to be

00:21:10,060 --> 00:21:16,500
enormously beneficial that's

00:21:24,669 --> 00:21:29,090
questions got quite a bit of thought for

00:21:27,259 --> 00:21:30,529
questions but can you please make sure

00:21:29,090 --> 00:21:31,279
that all the questions are on the

00:21:30,529 --> 00:21:34,100
microphone

00:21:31,279 --> 00:21:48,500
I think I'll hand it to people over to

00:21:34,100 --> 00:21:50,600
ask questions yes I'm gonna run there so

00:21:48,500 --> 00:21:52,399
do you deal a lot with the projections

00:21:50,600 --> 00:21:53,840
of data when you're working with this

00:21:52,399 --> 00:21:56,269
GPS data or what are you actually doing

00:21:53,840 --> 00:21:58,990
with this in the end right that's a good

00:21:56,269 --> 00:22:02,269
question I had intended to say that so

00:21:58,990 --> 00:22:06,379
we're building a platform to let you

00:22:02,269 --> 00:22:08,330
register your vehicles obd device and

00:22:06,379 --> 00:22:09,830
have the data transmitted to us and then

00:22:08,330 --> 00:22:11,389
we pass it process it and stored in a

00:22:09,830 --> 00:22:17,000
database and give you a user interface

00:22:11,389 --> 00:22:18,500
to see your travel time for for people

00:22:17,000 --> 00:22:20,179
who just want to see the travel time

00:22:18,500 --> 00:22:22,129
that's fine but for large companies who

00:22:20,179 --> 00:22:24,289
have significant fleets like Avis and

00:22:22,129 --> 00:22:26,299
other rental companies and long-haul

00:22:24,289 --> 00:22:27,440
tracking companies they need to keep

00:22:26,299 --> 00:22:31,029
track of where the vehicles are moving

00:22:27,440 --> 00:22:34,669
24/7 so we provide that service as well

00:22:31,029 --> 00:22:36,350
so it's really we're handling the all of

00:22:34,669 --> 00:22:38,000
the processing of the information so

00:22:36,350 --> 00:22:39,110
that the end user doesn't have to do any

00:22:38,000 --> 00:22:40,250
of that stuff they don't have to do

00:22:39,110 --> 00:22:42,200
hardware hacking when they don't you

00:22:40,250 --> 00:22:45,590
interpret the GPS stuff they can get

00:22:42,200 --> 00:22:50,269
maps and PDF reports about travel times

00:22:45,590 --> 00:22:52,460
and distances and so on question sir

00:22:50,269 --> 00:22:54,470
what are you a zombie I've got a

00:22:52,460 --> 00:22:56,870
question as well we also be able to from

00:22:54,470 --> 00:22:58,129
the data like if you see that white cars

00:22:56,870 --> 00:23:00,799
go here and you would see if there is a

00:22:58,129 --> 00:23:02,539
congestion like so every day yes

00:23:00,799 --> 00:23:05,389
absolutely but you don't be able to make

00:23:02,539 --> 00:23:07,970
recommendations to the driver like drive

00:23:05,389 --> 00:23:10,340
through here because pass cars pass

00:23:07,970 --> 00:23:12,019
faster here that is a good point so that

00:23:10,340 --> 00:23:13,370
is something that one could do but we

00:23:12,019 --> 00:23:16,750
don't do that it's really just

00:23:13,370 --> 00:23:22,669
processing of the data my employer has

00:23:16,750 --> 00:23:24,350
sold data before to the local municipal

00:23:22,669 --> 00:23:24,740
government in Auckland for exactly that

00:23:24,350 --> 00:23:26,869
reason

00:23:24,740 --> 00:23:29,929
historical data to see where congestion

00:23:26,869 --> 00:23:31,430
points have have occurred and then that

00:23:29,929 --> 00:23:33,590
data has been used to

00:23:31,430 --> 00:23:36,230
inform decisions about where new roads

00:23:33,590 --> 00:23:37,490
should be built and so on so the

00:23:36,230 --> 00:23:39,290
real-time information is interesting but

00:23:37,490 --> 00:23:40,550
I find actually the data science is also

00:23:39,290 --> 00:23:44,210
interesting to look at historical

00:23:40,550 --> 00:23:46,960
congestion give them that cute well

00:23:44,210 --> 00:23:49,040
given that you're dealing with obd2

00:23:46,960 --> 00:23:50,240
devices are you actually pulling out any

00:23:49,040 --> 00:23:53,000
of the other information that they can

00:23:50,240 --> 00:23:54,260
supply like the fuel levels the you know

00:23:53,000 --> 00:23:55,640
acceleration braking these

00:23:54,260 --> 00:23:57,800
characteristics are yet pulling any of

00:23:55,640 --> 00:23:59,630
those out as well or are you just

00:23:57,800 --> 00:24:05,090
focusing on the GPS at this point we

00:23:59,630 --> 00:24:07,040
take everything we can get and that's

00:24:05,090 --> 00:24:08,840
frustrating actually so if you're

00:24:07,040 --> 00:24:11,540
building a common API that sits over

00:24:08,840 --> 00:24:13,640
everything sometimes data doesn't always

00:24:11,540 --> 00:24:15,890
fit in the in the label that you that

00:24:13,640 --> 00:24:17,780
you give to it sometimes you have

00:24:15,890 --> 00:24:20,570
multiple fuel tanks in large vehicles

00:24:17,780 --> 00:24:22,010
and if you only have one variable called

00:24:20,570 --> 00:24:24,230
fuel level you know what do you do with

00:24:22,010 --> 00:24:26,990
the other so it is kind of an arms race

00:24:24,230 --> 00:24:29,060
to figure out how to keep your API small

00:24:26,990 --> 00:24:30,710
and simple that still gather all the

00:24:29,060 --> 00:24:38,330
information that is present in all the

00:24:30,710 --> 00:24:39,770
messages yeah I just wanted to ask what

00:24:38,330 --> 00:24:44,780
data base are you feeding all this stuff

00:24:39,770 --> 00:24:48,770
into at the backend Redis working well

00:24:44,780 --> 00:24:51,800
so far it's good I'm curious to see what

00:24:48,770 --> 00:24:54,770
happens with scale but it's pretty

00:24:51,800 --> 00:24:58,160
simple so far no no Redis is just for

00:24:54,770 --> 00:25:00,260
the device messages yeah we're using a I

00:24:58,160 --> 00:25:02,540
think we're using Google datastore for

00:25:00,260 --> 00:25:05,030
all of the other stuff but Redis is for

00:25:02,540 --> 00:25:06,830
the high the high throughput as there's

00:25:05,030 --> 00:25:09,020
a semi related question are you planning

00:25:06,830 --> 00:25:17,300
on exposing that sort of stuff as an API

00:25:09,020 --> 00:25:19,400
to your customers yes cool so beyond

00:25:17,300 --> 00:25:22,610
your own data center oh dear unlike

00:25:19,400 --> 00:25:26,930
summer in Amazon yeah good okay the

00:25:22,610 --> 00:25:34,880
Google's path platform any more

00:25:26,930 --> 00:25:36,530
questions good question here if you

00:25:34,880 --> 00:25:38,780
wanted to do this yourself do you have a

00:25:36,530 --> 00:25:42,910
device recommendation for which one

00:25:38,780 --> 00:25:42,910
would be the easiest to get started with

00:25:43,629 --> 00:25:49,759
that's not fair because Ryan has worked

00:25:46,909 --> 00:25:57,649
with me before on this so he's trying to

00:25:49,759 --> 00:25:58,999
catch me out for OBD devices the I think

00:25:57,649 --> 00:26:02,090
that the buffin protocol that I

00:25:58,999 --> 00:26:05,779
implemented was probably one of the not

00:26:02,090 --> 00:26:07,549
easiest but the most clear I think it

00:26:05,779 --> 00:26:09,490
was it was fairly easy to see how they

00:26:07,549 --> 00:26:11,570
had structured their their messaging and

00:26:09,490 --> 00:26:13,940
processing that and they they weren't

00:26:11,570 --> 00:26:16,659
weird and strange glitches in processing

00:26:13,940 --> 00:26:20,570
the messages so that's a good choice a

00:26:16,659 --> 00:26:22,190
track is also kind of okay but I my

00:26:20,570 --> 00:26:24,950
understanding is that the firm work the

00:26:22,190 --> 00:26:26,210
firmware is very variable in quality the

00:26:24,950 --> 00:26:28,309
more expensive devices have good

00:26:26,210 --> 00:26:29,480
firmware and the cheaper devices have

00:26:28,309 --> 00:26:31,879
really dodgy firmware

00:26:29,480 --> 00:26:33,559
like you'll get like crash notifications

00:26:31,879 --> 00:26:38,389
that aren't real that kind of thing you

00:26:33,559 --> 00:26:39,919
know high g-force events but I didn't

00:26:38,389 --> 00:26:41,720
talk about the hardware side of this but

00:26:39,919 --> 00:26:43,100
the thing is the hardware and and the

00:26:41,720 --> 00:26:44,210
server-side software are not the only

00:26:43,100 --> 00:26:45,740
two things you have to care about the

00:26:44,210 --> 00:26:49,369
firmware is actually where most of the

00:26:45,740 --> 00:26:50,809
problems happen so yeah and if you're

00:26:49,369 --> 00:26:52,369
not doing that yourself you really have

00:26:50,809 --> 00:26:54,080
to rest on whatever the vendor is giving

00:26:52,369 --> 00:26:56,269
you and that's that's pretty hard

00:26:54,080 --> 00:26:57,919
because the firmware my impression is

00:26:56,269 --> 00:27:00,320
that the firmware is really variable in

00:26:57,919 --> 00:27:01,249
quality that that's really if you're

00:27:00,320 --> 00:27:02,629
going to be buying in many of these

00:27:01,249 --> 00:27:04,549
devices that's what you should focus on

00:27:02,629 --> 00:27:06,320
is the quality of the firm where does

00:27:04,549 --> 00:27:08,480
the vendor do testing how do they test

00:27:06,320 --> 00:27:11,320
different way how rigorous is it that

00:27:08,480 --> 00:27:11,320
kind of those kinds of questions

00:27:12,220 --> 00:27:17,600
so you said you could these fifteen

00:27:14,779 --> 00:27:20,899
protocols I imagine many receive a

00:27:17,600 --> 00:27:22,429
passage do you know at all which when

00:27:20,899 --> 00:27:24,259
they're or which former it's coming from

00:27:22,429 --> 00:27:26,269
or they sort of have to guess depending

00:27:24,259 --> 00:27:28,700
on the base that you get that's a very

00:27:26,269 --> 00:27:30,320
small question so we don't do that order

00:27:28,700 --> 00:27:33,139
detection we put each of the different

00:27:30,320 --> 00:27:34,369
protocols on a different port so when

00:27:33,139 --> 00:27:36,649
you add your device to the system you

00:27:34,369 --> 00:27:39,379
have to say which vendor it is and then

00:27:36,649 --> 00:27:40,970
the URL that you are given back has the

00:27:39,379 --> 00:27:43,669
port that is associated with that vendor

00:27:40,970 --> 00:27:46,570
so we separate out each of our serving

00:27:43,669 --> 00:27:46,570
instances by protocol

00:27:51,649 --> 00:27:59,190
have you guys given any feedback to any

00:27:55,440 --> 00:28:02,279
of the manufacturers about the total

00:27:59,190 --> 00:28:04,850
inconsistency of the device messages

00:28:02,279 --> 00:28:08,970
okay

00:28:04,850 --> 00:28:11,820
at all anyone working on any sort of

00:28:08,970 --> 00:28:13,860
open standard for that no not that I'm

00:28:11,820 --> 00:28:15,269
aware of it may well be and that's a

00:28:13,860 --> 00:28:19,470
good question actually so there is a

00:28:15,269 --> 00:28:23,789
project called track org TR AC CA r org

00:28:19,470 --> 00:28:26,639
it's a Java server that is an open

00:28:23,789 --> 00:28:30,509
source protocol implementation library

00:28:26,639 --> 00:28:33,299
really I think they have support for 800

00:28:30,509 --> 00:28:35,879
different protocols but the support is

00:28:33,299 --> 00:28:37,080
fairly shallow so from from Apple many

00:28:35,879 --> 00:28:39,419
of those protocols they're just extract

00:28:37,080 --> 00:28:41,129
out the dead time and the lat/long but

00:28:39,419 --> 00:28:43,169
that's that's a good sonic point to look

00:28:41,129 --> 00:28:44,759
at if you want to just jump in quickly

00:28:43,169 --> 00:28:49,590
it is Java though so you may want to put

00:28:44,759 --> 00:28:52,919
on gloves yeah that project is quite

00:28:49,590 --> 00:28:55,830
active it has many contributors my

00:28:52,919 --> 00:28:58,289
question was similar so obviously an

00:28:55,830 --> 00:29:01,499
open canonical standard for messaging

00:28:58,289 --> 00:29:03,450
for those 15 different vendors since you

00:29:01,499 --> 00:29:06,269
don't have one d do you implement some

00:29:03,450 --> 00:29:08,039
sort of SOA like service-oriented

00:29:06,269 --> 00:29:10,230
architecture after you receive all the

00:29:08,039 --> 00:29:12,389
messaging into a common canonical and

00:29:10,230 --> 00:29:13,889
urine before protect but that's exactly

00:29:12,389 --> 00:29:15,749
what so the Redis database that I was

00:29:13,889 --> 00:29:17,369
talking about what we save in there is a

00:29:15,749 --> 00:29:22,049
standard format that we have ourselves

00:29:17,369 --> 00:29:24,360
so another one yeah so have you thought

00:29:22,049 --> 00:29:26,999
about open sourcing that standard that

00:29:24,360 --> 00:29:29,340
canonical standard you have it's tricky

00:29:26,999 --> 00:29:32,009
to do the preventers themselves weren't

00:29:29,340 --> 00:29:33,840
adopted but what what we offer is a

00:29:32,009 --> 00:29:36,059
service that does the abstraction for

00:29:33,840 --> 00:29:37,619
you so that that's basically what the

00:29:36,059 --> 00:29:39,149
business is really offering you know it

00:29:37,619 --> 00:29:40,919
doesn't matter what device you have you

00:29:39,149 --> 00:29:42,809
come to us you just pointed to our

00:29:40,919 --> 00:29:44,429
service and we will give you back data

00:29:42,809 --> 00:29:46,649
that's clear and consistent even if you

00:29:44,429 --> 00:29:49,230
have a heterogeneous mixture of devices

00:29:46,649 --> 00:29:51,360
we can do that too to really push us an

00:29:49,230 --> 00:29:52,529
open standard is just a it's a thing

00:29:51,360 --> 00:29:55,649
that I don't think is going to be

00:29:52,529 --> 00:29:56,999
attractive for anyone to do unless the

00:29:55,649 --> 00:29:58,499
vendors themselves like the hardware

00:29:56,999 --> 00:29:59,850
vendors themselves come together and

00:29:58,499 --> 00:30:01,650
decide that they won't do that which

00:29:59,850 --> 00:30:02,820
they won't do the

00:30:01,650 --> 00:30:04,320
people who are leading in the field just

00:30:02,820 --> 00:30:06,870
they have to get there with no interest

00:30:04,320 --> 00:30:10,230
in trying to share message protocols

00:30:06,870 --> 00:30:10,530
with other people so that's that's quite

00:30:10,230 --> 00:30:12,330
tough

00:30:10,530 --> 00:30:13,590
tell tonica's protocol was actually

00:30:12,330 --> 00:30:17,160
quite tricky to implement they've got a

00:30:13,590 --> 00:30:18,630
recursive structure a loose recursive

00:30:17,160 --> 00:30:19,950
structure where you know there are

00:30:18,630 --> 00:30:21,270
packets embedded in other packets that

00:30:19,950 --> 00:30:22,920
you have to look at the byte header

00:30:21,270 --> 00:30:24,510
first and extract the rest and then

00:30:22,920 --> 00:30:25,830
figure out what that is and then inside

00:30:24,510 --> 00:30:29,040
that there are more so that was quite

00:30:25,830 --> 00:30:31,200
interesting to write so there would be a

00:30:29,040 --> 00:30:33,750
good example tell tonica's is huge they

00:30:31,200 --> 00:30:36,630
especially in Europe they're massive and

00:30:33,750 --> 00:30:38,070
their protocol is probably one of them

00:30:36,630 --> 00:30:39,180
but one of the more arcane ones and I

00:30:38,070 --> 00:30:45,210
think they've got zero interest to

00:30:39,180 --> 00:30:47,490
change because they're established we

00:30:45,210 --> 00:30:52,500
good any more questions I think we can

00:30:47,490 --> 00:30:57,480
have one more okay one last time okay

00:30:52,500 --> 00:30:57,750
the best for last just on the same topic

00:30:57,480 --> 00:30:59,310
again

00:30:57,750 --> 00:31:01,410
is there any regulator interest in

00:30:59,310 --> 00:31:03,690
forcing a standard protocol in terms of

00:31:01,410 --> 00:31:11,750
Issachar devices as safety perhaps

00:31:03,690 --> 00:31:14,250
involved I don't know all I know is that

00:31:11,750 --> 00:31:17,010
many of the protocol documents are full

00:31:14,250 --> 00:31:20,130
of spelling mistakes you know the

00:31:17,010 --> 00:31:21,480
examples don't work if they were and if

00:31:20,130 --> 00:31:23,010
it wasn't open protocol I think it would

00:31:21,480 --> 00:31:25,940
be good but the amount of effort that is

00:31:23,010 --> 00:31:30,810
putting in now for vendors own devices

00:31:25,940 --> 00:31:32,670
makes me here I want to be proven wrong

00:31:30,810 --> 00:31:34,260
but I don't hold out a lot of hope that

00:31:32,670 --> 00:31:35,910
they're all gonna decide to come

00:31:34,260 --> 00:31:37,230
together and meet and you know nailed

00:31:35,910 --> 00:31:39,570
down that one protocol that they're all

00:31:37,230 --> 00:31:41,310
going to do it's just it's not that kind

00:31:39,570 --> 00:31:42,780
of world the software world is like that

00:31:41,310 --> 00:31:45,890
but the hardware world is just not like

00:31:42,780 --> 00:31:48,900
that yeah that's the equation I've got

00:31:45,890 --> 00:31:51,530
all right I think you go out can can I

00:31:48,900 --> 00:31:51,530

YouTube URL: https://www.youtube.com/watch?v=y6U0yUbpp-Q


