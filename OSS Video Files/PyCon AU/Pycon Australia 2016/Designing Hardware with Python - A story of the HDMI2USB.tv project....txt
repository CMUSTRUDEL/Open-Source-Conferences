Title: Designing Hardware with Python - A story of the HDMI2USB.tv project...
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Timothy Ansell
https://2016.pycon-au.org/schedule/25/view_talk
Python is generally considered a high level language a long way from hardware, this very fact actually makes it an awesome tool for helping out with the design and creation of hardware!

This talk will hopefully cover;
  * Python hardware description languages (HDLs) for creating "gateware" for FPGA chips or even real IC design.
  * Python scripting for hardware schematic layout and design rule checking.
  * Python tools for deploying, programming and debugging embedded systems.
  * Some cool projects like the HDMI2USB.tv (open source hardware for video capture) which use many of the above parts.

This talk will focus on open source tools.
Captions: 
	00:00:02,570 --> 00:00:07,170
hello everyone

00:00:04,500 --> 00:00:10,500
firstly just a quick announcement I'm

00:00:07,170 --> 00:00:12,960
not Tom if you asked that Tom this is

00:00:10,500 --> 00:00:14,040
Tom he's in the other room he's talking

00:00:12,960 --> 00:00:22,550
about web stuff

00:00:14,040 --> 00:00:25,380
I'm Tim that's Tom okay so I love Python

00:00:22,550 --> 00:00:27,980
so much so that I may have started a

00:00:25,380 --> 00:00:31,679
conference about it but I'm also

00:00:27,980 --> 00:00:36,300
practical I like to use the right tool

00:00:31,679 --> 00:00:38,640
for the right job and everything is a

00:00:36,300 --> 00:00:41,940
nail which is what I'm saying here is

00:00:38,640 --> 00:00:44,280
that Python isn't the solution to

00:00:41,940 --> 00:00:47,300
everything it's like the solution to

00:00:44,280 --> 00:00:50,910
almost everything but not everything and

00:00:47,300 --> 00:00:54,690
so when a problem comes along that

00:00:50,910 --> 00:00:58,579
Python is not suited for I tend to not

00:00:54,690 --> 00:01:02,430
use Python for it that's pretty simple

00:00:58,579 --> 00:01:05,250
so the question I guess this talk is try

00:01:02,430 --> 00:01:10,380
to answer is should you use Python for

00:01:05,250 --> 00:01:13,619
hardware and it's kind of an interesting

00:01:10,380 --> 00:01:17,250
question python is a very long way away

00:01:13,619 --> 00:01:19,200
from hardware in many senses as the

00:01:17,250 --> 00:01:21,990
keynote this morning demonstrated C

00:01:19,200 --> 00:01:26,580
Python is not designed to run on small

00:01:21,990 --> 00:01:33,119
devices it's definitely not designed in

00:01:26,580 --> 00:01:36,659
a strict right once baked into a chip

00:01:33,119 --> 00:01:39,150
and then leave for 20 years type design

00:01:36,659 --> 00:01:43,560
I'm pythons not actually that older

00:01:39,150 --> 00:01:45,060
language so this leaves a lot of

00:01:43,560 --> 00:01:47,280
questions about whether Python is the

00:01:45,060 --> 00:01:49,619
right tool for hardware um it's

00:01:47,280 --> 00:01:53,670
definitely not the most popular tool for

00:01:49,619 --> 00:01:57,479
doing hardware in either and generally I

00:01:53,670 --> 00:02:01,799
found while it's not strictly true

00:01:57,479 --> 00:02:03,840
always most popular tool is the best

00:02:01,799 --> 00:02:06,360
tool to use for something because

00:02:03,840 --> 00:02:08,160
somebody else has already run into the

00:02:06,360 --> 00:02:10,379
problem that you're trying to solve and

00:02:08,160 --> 00:02:12,030
post it on Stack Overflow about how

00:02:10,379 --> 00:02:13,240
they're having this problem and you've

00:02:12,030 --> 00:02:16,140
got a solution that

00:02:13,240 --> 00:02:19,450
I tend to try and use the more popular

00:02:16,140 --> 00:02:20,860
tools because it makes it very easy I

00:02:19,450 --> 00:02:21,520
don't have to think I can just go on

00:02:20,860 --> 00:02:25,480
Stack Overflow

00:02:21,520 --> 00:02:30,100
and place them and hardware not a huge

00:02:25,480 --> 00:02:33,010
amount on Stack Overflow so for those

00:02:30,100 --> 00:02:37,300
reasons I would have said no about 12

00:02:33,010 --> 00:02:40,900
months ago I think but today I say yes

00:02:37,300 --> 00:02:44,680
and the intro it's an interesting story

00:02:40,900 --> 00:02:44,890
to find about how I went from a no to a

00:02:44,680 --> 00:02:49,120
yes

00:02:44,890 --> 00:02:51,220
and that story is the story of a project

00:02:49,120 --> 00:02:56,710
that I've been developing called the

00:02:51,220 --> 00:02:59,320
HDMI to USB so Tait remaining USB is

00:02:56,710 --> 00:03:03,220
part of a bigger project that I'm

00:02:59,320 --> 00:03:06,340
running cartoons videos the URL is Tim

00:03:03,220 --> 00:03:09,130
videos uh I got tired of naming things

00:03:06,340 --> 00:03:13,060
so I just call it what it is and the aim

00:03:09,130 --> 00:03:16,510
is to make streaming and recording of

00:03:13,060 --> 00:03:19,420
events like this and user groups and

00:03:16,510 --> 00:03:22,360
stuff like that extremely easy can be

00:03:19,420 --> 00:03:25,570
done with no IV curve we're not there

00:03:22,360 --> 00:03:30,990
yet but that's kind of our long term

00:03:25,570 --> 00:03:30,990
horizon goal make AV people obsolete

00:03:32,670 --> 00:03:37,900
what they can go and do some more

00:03:34,630 --> 00:03:42,940
interesting things so this is how you

00:03:37,900 --> 00:03:46,540
stream a conference turns out there's

00:03:42,940 --> 00:03:48,340
lots and lots of Python in streaming a

00:03:46,540 --> 00:03:51,100
conference with the stuff I've developed

00:03:48,340 --> 00:03:53,740
as I said I like Python and Python is a

00:03:51,100 --> 00:03:56,410
good tool but lots of things we have a

00:03:53,740 --> 00:03:59,530
hardware mixing solution which is mostly

00:03:56,410 --> 00:04:02,470
Python we have capture stuff which is

00:03:59,530 --> 00:04:03,880
Python streaming systems Python the

00:04:02,470 --> 00:04:07,150
website the streaming system goes into

00:04:03,880 --> 00:04:09,520
as Django we're at a Python conference I

00:04:07,150 --> 00:04:12,209
guess even the contents Python and I'm a

00:04:09,520 --> 00:04:15,040
little bit Python in the head sometimes

00:04:12,209 --> 00:04:18,549
but there are two things that I didn't

00:04:15,040 --> 00:04:20,890
point to in that very quick thing and

00:04:18,549 --> 00:04:24,970
that these two things here which are the

00:04:20,890 --> 00:04:27,370
HDMI to USB devices that an actual piece

00:04:24,970 --> 00:04:31,990
of physical hardware

00:04:27,370 --> 00:04:34,659
they look like this out of a box if you

00:04:31,990 --> 00:04:36,009
have been a speaker or your steamed

00:04:34,659 --> 00:04:37,629
clothes you can kind of see there's

00:04:36,009 --> 00:04:39,340
another one in the Box down the front

00:04:37,629 --> 00:04:43,259
and there's one up the back connected to

00:04:39,340 --> 00:04:46,270
the camera as well their job is to take

00:04:43,259 --> 00:04:49,240
HDMI signals and convert it to something

00:04:46,270 --> 00:04:50,669
a computer can use some ways it's kind

00:04:49,240 --> 00:04:54,060
of weird that a computer can produce

00:04:50,669 --> 00:04:58,270
HDMI signals but not really accept them

00:04:54,060 --> 00:05:00,340
but that is the problem that we need to

00:04:58,270 --> 00:05:06,939
solve because the HDMI signal is how

00:05:00,340 --> 00:05:11,770
people project so this is the hardware

00:05:06,939 --> 00:05:16,139
that makes up the HDMI USB we currently

00:05:11,770 --> 00:05:19,990
support two different development boards

00:05:16,139 --> 00:05:23,729
they sent it around a thing called FPGA

00:05:19,990 --> 00:05:26,050
which is a field programmable gate array

00:05:23,729 --> 00:05:28,389
the really cool thing about a field

00:05:26,050 --> 00:05:30,669
programmable gate array is it makes

00:05:28,389 --> 00:05:33,430
hardware problems software problems and

00:05:30,669 --> 00:05:34,930
I'm a software developer not really a

00:05:33,430 --> 00:05:39,759
hardware developer though I pretend

00:05:34,930 --> 00:05:42,399
sometimes and I like being able to make

00:05:39,759 --> 00:05:46,210
a mistake and not cost a hundred million

00:05:42,399 --> 00:05:49,029
dollars of failed chips so software

00:05:46,210 --> 00:05:53,550
makes it much easier to do that I can

00:05:49,029 --> 00:05:56,680
update that's the awesomeness of an FPGA

00:05:53,550 --> 00:05:59,680
problem with FPGA is is that programmed

00:05:56,680 --> 00:06:01,719
with two major languages one of them's

00:05:59,680 --> 00:06:05,259
called Vera log and one of them's called

00:06:01,719 --> 00:06:10,149
VHDL you might notice neither of these

00:06:05,259 --> 00:06:13,979
are Python I'm sadly just a background

00:06:10,149 --> 00:06:16,240
of Bariloche syntactic is C is C based

00:06:13,979 --> 00:06:19,389
you can kind of see it's been around for

00:06:16,240 --> 00:06:21,729
a while 1984 was a key date for it it's

00:06:19,389 --> 00:06:23,589
a kind of weakly typed in the same way C

00:06:21,729 --> 00:06:26,139
is it lets you do all types of nasty

00:06:23,589 --> 00:06:28,569
things like castings through the

00:06:26,139 --> 00:06:31,479
equivalent of boy pointers um has really

00:06:28,569 --> 00:06:34,569
good open-source support which is kind

00:06:31,479 --> 00:06:37,029
of interesting there are a lot of

00:06:34,569 --> 00:06:39,639
university projects which have released

00:06:37,029 --> 00:06:40,360
open source interpreters for Vera log so

00:06:39,639 --> 00:06:42,729
you

00:06:40,360 --> 00:06:45,879
make your computer interpret a language

00:06:42,729 --> 00:06:48,610
for describing hardware so that you can

00:06:45,879 --> 00:06:52,000
see what hardware is going to do on your

00:06:48,610 --> 00:06:54,729
computer that's pretty cool yeah but

00:06:52,000 --> 00:06:57,879
it's still not Python or even Python

00:06:54,729 --> 00:07:01,000
syntax based I'm the other one is VHDL

00:06:57,879 --> 00:07:06,280
it's based on ADA who knows what ADA is

00:07:01,000 --> 00:07:08,889
a bunch of you ADA is an interesting

00:07:06,280 --> 00:07:13,060
language it's not very popular

00:07:08,889 --> 00:07:16,599
except into a Defense VHDL is also newer

00:07:13,060 --> 00:07:19,090
than very log as you can see 1987 is a

00:07:16,599 --> 00:07:21,969
key date for it it's a much more

00:07:19,090 --> 00:07:25,300
strongly typed language but kind of like

00:07:21,969 --> 00:07:28,500
ADA it's extremely verbose you kind of

00:07:25,300 --> 00:07:31,270
think of like the Java side of things

00:07:28,500 --> 00:07:32,310
it's good in lots of ways but also not

00:07:31,270 --> 00:07:38,319
good

00:07:32,310 --> 00:07:40,060
the has extremely banned for support but

00:07:38,319 --> 00:07:44,050
has one really cool thing which is

00:07:40,060 --> 00:07:47,199
determinism that is really awesome for

00:07:44,050 --> 00:07:48,759
making hardware be a very log there's

00:07:47,199 --> 00:07:53,199
kind of a little bit suspect in that

00:07:48,759 --> 00:07:55,919
area again ADA is not Python or even

00:07:53,199 --> 00:07:59,289
looking like Python at all

00:07:55,919 --> 00:08:03,400
so because of the reason that I stared

00:07:59,289 --> 00:08:06,129
at the style of talk I went with

00:08:03,400 --> 00:08:10,180
designing the firmware for FPGA to do

00:08:06,129 --> 00:08:13,120
HTML capture using basically a bunch of

00:08:10,180 --> 00:08:17,099
pre-built stuff written in VHDL and

00:08:13,120 --> 00:08:21,099
Verilog it supported this board here and

00:08:17,099 --> 00:08:26,740
it kind of works if you squinted at it

00:08:21,099 --> 00:08:32,500
sideways and we're very kind to it it

00:08:26,740 --> 00:08:33,510
worked it took about three years to do

00:08:32,500 --> 00:08:35,919
that

00:08:33,510 --> 00:08:38,409
there are lots of features on this board

00:08:35,919 --> 00:08:40,360
that you can kind of see it's like an

00:08:38,409 --> 00:08:41,320
Ethernet and some audio and all this

00:08:40,360 --> 00:08:42,940
type of thing

00:08:41,320 --> 00:08:46,500
none of them are supported by the

00:08:42,940 --> 00:08:51,370
firmware yet it just did very basic HDMI

00:08:46,500 --> 00:08:54,990
to USB translation it also had a problem

00:08:51,370 --> 00:08:54,990
around licensing

00:08:55,980 --> 00:09:03,370
lots of the FPGA manufacturers will

00:09:00,010 --> 00:09:05,890
release designs that work on their

00:09:03,370 --> 00:09:09,460
hardware you can use them in your own

00:09:05,890 --> 00:09:11,170
designs but they require you to use it

00:09:09,460 --> 00:09:13,660
on their hardware so if you want to use

00:09:11,170 --> 00:09:17,890
one of their competitors FPGAs you can't

00:09:13,660 --> 00:09:20,649
use that design so it's not really open

00:09:17,890 --> 00:09:22,860
source in whatsoever source but it's not

00:09:20,649 --> 00:09:30,100
really free software type thing and

00:09:22,860 --> 00:09:33,339
that's kind of sad it also was not very

00:09:30,100 --> 00:09:36,690
well tested very log and VHDL people

00:09:33,339 --> 00:09:39,130
have interesting ideas about testing

00:09:36,690 --> 00:09:41,620
they're not software developers the idea

00:09:39,130 --> 00:09:45,339
of continuous integration is a new

00:09:41,620 --> 00:09:48,520
exciting field for developers in this

00:09:45,339 --> 00:09:50,140
area I guess for them you verify it

00:09:48,520 --> 00:09:52,529
works once and then you never change it

00:09:50,140 --> 00:09:55,720
again that tends to be a pretty common

00:09:52,529 --> 00:09:58,000
occurrence for us we wanted something

00:09:55,720 --> 00:10:00,520
that was evolving and continually

00:09:58,000 --> 00:10:03,940
improved so that every time somebody has

00:10:00,520 --> 00:10:08,050
a problem with a presentation or like us

00:10:03,940 --> 00:10:10,060
capturing something next time we get the

00:10:08,050 --> 00:10:14,050
capture it doesn't fail the same way

00:10:10,060 --> 00:10:16,180
twice we want to improve it and like

00:10:14,050 --> 00:10:18,010
that's what we need to be able to make

00:10:16,180 --> 00:10:20,740
AV people obsolete

00:10:18,010 --> 00:10:23,890
the reason AV people exist is because in

00:10:20,740 --> 00:10:28,089
their head they have all those random

00:10:23,890 --> 00:10:29,920
tricks that make this little box working

00:10:28,089 --> 00:10:33,430
the way that it's actually supposed to

00:10:29,920 --> 00:10:37,060
but never quite dumb if you connect

00:10:33,430 --> 00:10:43,200
things slightly wrong or it's kind of

00:10:37,060 --> 00:10:46,209
like the windows reboot type thing then

00:10:43,200 --> 00:10:48,339
we as I said we're kind of developing on

00:10:46,209 --> 00:10:52,149
this Atlas board but this Atlas board

00:10:48,339 --> 00:10:55,500
isn't open-source it's a proprietary

00:10:52,149 --> 00:10:59,399
development boards that you can buy and

00:10:55,500 --> 00:10:59,399
I'm mobile source person

00:11:01,000 --> 00:11:05,260
and I wasn't content with just making

00:11:02,980 --> 00:11:08,320
firmware I wanted my home system to be

00:11:05,260 --> 00:11:09,610
open source as well there are whole

00:11:08,320 --> 00:11:11,260
bunch of downsides of using and

00:11:09,610 --> 00:11:13,720
development board development board is

00:11:11,260 --> 00:11:16,960
designed for development not for

00:11:13,720 --> 00:11:20,500
deploying in production and so we made

00:11:16,960 --> 00:11:23,770
our own hardware

00:11:20,500 --> 00:11:25,180
it's called ops Asst this was our

00:11:23,770 --> 00:11:27,220
crowdfunding campaign which is now

00:11:25,180 --> 00:11:32,650
finished this is a kind of way you can

00:11:27,220 --> 00:11:34,900
get it thing the interesting thing about

00:11:32,650 --> 00:11:40,120
this board and the atlas is they're very

00:11:34,900 --> 00:11:44,290
very similar but not identical they're

00:11:40,120 --> 00:11:47,650
very very similar FPGAs they have very

00:11:44,290 --> 00:11:49,300
similar USB interface very similar HDMI

00:11:47,650 --> 00:11:52,450
interface all these type of things but

00:11:49,300 --> 00:11:54,280
they're not identical and we couldn't

00:11:52,450 --> 00:11:56,260
make them identical and still achieve

00:11:54,280 --> 00:12:02,560
our goal which was making something

00:11:56,260 --> 00:12:04,300
that's better for production so the

00:12:02,560 --> 00:12:08,160
boards were different which means the

00:12:04,300 --> 00:12:13,000
code runs on them needs to be different

00:12:08,160 --> 00:12:16,570
both very log and VHDL make it very hard

00:12:13,000 --> 00:12:22,089
to do well I think of simple things like

00:12:16,570 --> 00:12:25,690
making modules that say ok I want three

00:12:22,089 --> 00:12:28,210
of these instead of five of these and I

00:12:25,690 --> 00:12:31,990
actually only want it to use three times

00:12:28,210 --> 00:12:35,320
the resource on the other board and four

00:12:31,990 --> 00:12:37,060
times the resource on this board you can

00:12:35,320 --> 00:12:40,870
turn on and off features but they

00:12:37,060 --> 00:12:44,730
generally use the resources that you

00:12:40,870 --> 00:12:47,650
want to get back and just generally

00:12:44,730 --> 00:12:49,300
they're not very good at building

00:12:47,650 --> 00:12:54,040
modular software or doing continuous

00:12:49,300 --> 00:12:57,460
integration and again still not Python

00:12:54,040 --> 00:12:59,410
and so while I was despairing about how

00:12:57,460 --> 00:13:01,720
long this project was taking and how

00:12:59,410 --> 00:13:04,180
it's going to take me another 20 years

00:13:01,720 --> 00:13:07,150
to do this I came across this piece of

00:13:04,180 --> 00:13:07,890
hardware this piece of hardware is

00:13:07,150 --> 00:13:11,920
called

00:13:07,890 --> 00:13:15,070
the mick CEO has a very similar design

00:13:11,920 --> 00:13:16,600
to our elbow

00:13:15,070 --> 00:13:20,709
would never seen each other's boards

00:13:16,600 --> 00:13:22,990
before but this kind of a you know when

00:13:20,709 --> 00:13:26,320
there's this idea that at a certain time

00:13:22,990 --> 00:13:29,589
period ideas become fruitful and

00:13:26,320 --> 00:13:31,660
everybody comes up with ideas at the

00:13:29,589 --> 00:13:33,579
same time this was kind of that they had

00:13:31,660 --> 00:13:36,279
come up with a similar type of design

00:13:33,579 --> 00:13:38,829
for totally different use case this was

00:13:36,279 --> 00:13:41,079
for video DJing rather than video

00:13:38,829 --> 00:13:47,470
capture at conferences but very similar

00:13:41,079 --> 00:13:54,180
design and they had done something that

00:13:47,470 --> 00:13:54,180
I didn't think made sense and that was

00:13:54,600 --> 00:14:02,050
do a lot of things they developed on DDR

00:13:59,980 --> 00:14:04,690
Ram controller I had used the one

00:14:02,050 --> 00:14:08,160
supplied by my FPGA manufacturer you

00:14:04,690 --> 00:14:10,660
know they probably know the best way to

00:14:08,160 --> 00:14:12,839
configure their own Hardware they're

00:14:10,660 --> 00:14:15,009
done things like ray make their own

00:14:12,839 --> 00:14:17,009
Ethernet controller all these type of

00:14:15,009 --> 00:14:19,810
things they support for twenty boards

00:14:17,009 --> 00:14:24,519
but the one thing you're probably all

00:14:19,810 --> 00:14:30,690
looking at is this thing that is Python

00:14:24,519 --> 00:14:35,709
there so since these guys had tried it I

00:14:30,690 --> 00:14:38,709
was less skeptical I had kind of a

00:14:35,709 --> 00:14:45,310
tinkling of hope that maybe I could do

00:14:38,709 --> 00:14:47,079
Python this was kind of before things

00:14:45,310 --> 00:14:52,769
like micro Python and in a very

00:14:47,079 --> 00:14:58,089
different domain so still very skeptical

00:14:52,769 --> 00:15:00,220
but the very log and VHDL were terrible

00:14:58,089 --> 00:15:03,220
enough that I was willing to entertain

00:15:00,220 --> 00:15:05,439
that skepticism my hypothesis was this

00:15:03,220 --> 00:15:11,139
was going to be a pipe dream it was

00:15:05,439 --> 00:15:15,180
never going to work so the first thing

00:15:11,139 --> 00:15:20,050
that makes me even more skeptical is

00:15:15,180 --> 00:15:22,800
that to run on FPGA you need to be

00:15:20,050 --> 00:15:26,160
compiled onto an FPGA

00:15:22,800 --> 00:15:29,410
the tool chains that take code and

00:15:26,160 --> 00:15:31,929
compile it and I let you load it onto

00:15:29,410 --> 00:15:34,089
none of them understand Python and the

00:15:31,929 --> 00:15:35,919
old proprietary and you can't get access

00:15:34,089 --> 00:15:40,629
to how they work or any of those type of

00:15:35,919 --> 00:15:43,389
things and so how do you develop Python

00:15:40,629 --> 00:15:45,239
that fits into this thing

00:15:43,389 --> 00:15:49,449
what you're actually doing is generating

00:15:45,239 --> 00:15:52,089
very log using your Python and then

00:15:49,449 --> 00:15:55,899
their system takes the very log which

00:15:52,089 --> 00:15:58,049
you don't need to deal with because

00:15:55,899 --> 00:16:00,339
you're dealing in Nice Python world and

00:15:58,049 --> 00:16:03,129
converts into stuff another thing so you

00:16:00,339 --> 00:16:05,949
kind of still dealing with very log but

00:16:03,129 --> 00:16:07,629
you get to deal with Python and the

00:16:05,949 --> 00:16:10,629
Verilog is kind of just a translation

00:16:07,629 --> 00:16:16,299
layer that you don't really need to

00:16:10,629 --> 00:16:21,339
worry about so what I did was I didn't

00:16:16,299 --> 00:16:24,569
have time to do it myself I decided that

00:16:21,339 --> 00:16:28,059
I would throw money at the problem

00:16:24,569 --> 00:16:32,319
basically instead of buying a new laptop

00:16:28,059 --> 00:16:34,509
I would fund a guy in Europe to rewrite

00:16:32,319 --> 00:16:37,629
the functionality of our firmware I'm

00:16:34,509 --> 00:16:43,679
using me gen and the me sock

00:16:37,629 --> 00:16:43,679
technologies and it took him four weeks

00:16:44,189 --> 00:16:51,429
it had more features it had buffering so

00:16:48,369 --> 00:16:52,899
that when the video is written in it's

00:16:51,429 --> 00:16:55,419
written into a buffer and then read from

00:16:52,899 --> 00:16:57,939
a buffer which means that if I

00:16:55,419 --> 00:17:00,459
disconnect my laptop now the projector

00:16:57,939 --> 00:17:01,569
still continues to get signal so if

00:17:00,459 --> 00:17:03,579
you've ever had that problem where you

00:17:01,569 --> 00:17:05,199
disconnect from a thing and then the

00:17:03,579 --> 00:17:06,759
whole system decides are you've

00:17:05,199 --> 00:17:09,730
disconnected I'm shutting down the room

00:17:06,759 --> 00:17:10,839
and shares go up that doesn't happen

00:17:09,730 --> 00:17:12,279
because as far as the projector is

00:17:10,839 --> 00:17:13,839
concerned it's still getting a signal I

00:17:12,279 --> 00:17:15,850
mean it's a black square but there's

00:17:13,839 --> 00:17:20,919
still signal it's supported both our

00:17:15,850 --> 00:17:27,189
boards it has a CPU inside it basically

00:17:20,919 --> 00:17:30,419
a soft core it has Ethernet the thing I

00:17:27,189 --> 00:17:32,799
hadn't realized at the time was how

00:17:30,419 --> 00:17:36,850
awesome having a soft core in the

00:17:32,799 --> 00:17:38,619
firmware was it meant that we could

00:17:36,850 --> 00:17:41,169
write C code for a lot of our

00:17:38,619 --> 00:17:43,330
functionality that we used to have to

00:17:41,169 --> 00:17:47,500
write hardware

00:17:43,330 --> 00:17:50,529
four and right here C code is much

00:17:47,500 --> 00:17:52,480
easier than writing hardware you can

00:17:50,529 --> 00:17:53,740
compile it with GCC and you can update

00:17:52,480 --> 00:17:58,149
it really easily it's a much faster

00:17:53,740 --> 00:17:59,620
development cycle I don't know if

00:17:58,149 --> 00:18:05,049
somebody could probably port it to the

00:17:59,620 --> 00:18:07,919
soft core best Joel he's just

00:18:05,049 --> 00:18:10,539
volunteered to port micro Python to it

00:18:07,919 --> 00:18:13,090
we also can support two different types

00:18:10,539 --> 00:18:16,320
of soft cores and I'm running out of

00:18:13,090 --> 00:18:21,610
time um it does have some downsides

00:18:16,320 --> 00:18:25,779
those soft cores aren't part of the

00:18:21,610 --> 00:18:28,659
standard to train you get on a Linux

00:18:25,779 --> 00:18:33,059
system so you need to compile them

00:18:28,659 --> 00:18:35,740
yourselves they the LM theta is upstream

00:18:33,059 --> 00:18:37,960
but again not something you cannot get

00:18:35,740 --> 00:18:40,000
install on Ubuntu and the community is a

00:18:37,960 --> 00:18:41,980
lot smaller like it's not like x86 or

00:18:40,000 --> 00:18:46,299
arm which have a huge number of

00:18:41,980 --> 00:18:50,380
developers form but you can kind of see

00:18:46,299 --> 00:18:53,980
that our original firmware which was VHD

00:18:50,380 --> 00:18:55,960
on very log based was hard talks and had

00:18:53,980 --> 00:18:59,440
question on licensing had all these

00:18:55,960 --> 00:19:02,649
problems our new firmware the mess up

00:18:59,440 --> 00:19:05,529
firmware is python-based has a lot more

00:19:02,649 --> 00:19:08,620
functionality we really use pythons

00:19:05,529 --> 00:19:11,350
ability to express the differences

00:19:08,620 --> 00:19:13,840
between the boards so that it generates

00:19:11,350 --> 00:19:16,870
totally different verilock output which

00:19:13,840 --> 00:19:19,510
means that it's custom for that board

00:19:16,870 --> 00:19:22,570
we're not wasting the resources because

00:19:19,510 --> 00:19:24,850
the boards are different if a board

00:19:22,570 --> 00:19:26,919
doesn't have an ethernet controller the

00:19:24,850 --> 00:19:28,750
code for the ethernet controller never

00:19:26,919 --> 00:19:32,080
gets generated in the vera log and so

00:19:28,750 --> 00:19:33,760
you can never take up resources the

00:19:32,080 --> 00:19:37,659
other great thing about it is everything

00:19:33,760 --> 00:19:40,929
they did is released under a BSD slash

00:19:37,659 --> 00:19:45,120
MIT license so and it's under clear

00:19:40,929 --> 00:19:51,659
licence it's not under this kind of

00:19:45,120 --> 00:19:51,659
license so yeah it's been really awesome

00:19:52,409 --> 00:19:57,310
there's a lot more awesome that we could

00:19:55,029 --> 00:20:01,300
do we're slowly making pro

00:19:57,310 --> 00:20:04,270
and doing this has finally been what's

00:20:01,300 --> 00:20:06,760
allowed us to deploy this device and

00:20:04,270 --> 00:20:08,890
production we're using it right here now

00:20:06,760 --> 00:20:12,100
and PyCon are you to do the recording

00:20:08,890 --> 00:20:13,660
and we use that LCA links continue at

00:20:12,100 --> 00:20:17,860
the beginning of the year it's been used

00:20:13,660 --> 00:20:20,590
at Def Con I don't think would be at

00:20:17,860 --> 00:20:23,710
this stage without having gone down the

00:20:20,590 --> 00:20:26,490
route of using Python to develop

00:20:23,710 --> 00:20:35,350
hardware so that's pretty awesome

00:20:26,490 --> 00:20:37,540
yay Python but this is 30 min talk not a

00:20:35,350 --> 00:20:40,930
20 min talk so I've got a little bit

00:20:37,540 --> 00:20:43,630
more to say turns out that again using

00:20:40,930 --> 00:20:47,520
Python to develop hardware here's one of

00:20:43,630 --> 00:20:54,250
these simultaneous ideas there are two

00:20:47,520 --> 00:20:58,330
systems you can use to generate hardware

00:20:54,250 --> 00:21:00,970
the median one were you that we're using

00:20:58,330 --> 00:21:03,970
was selected because a lot of the

00:21:00,970 --> 00:21:07,270
infrastructure we needed like the HDMI

00:21:03,970 --> 00:21:09,190
and the DDR and stuff were all already

00:21:07,270 --> 00:21:17,670
available and there's also this thing

00:21:09,190 --> 00:21:22,080
called my HDL in many ways my HDL is a

00:21:17,670 --> 00:21:26,560
better more pure way of doing things

00:21:22,080 --> 00:21:29,890
it's also been well tested by other

00:21:26,560 --> 00:21:32,590
people people have used it to actually

00:21:29,890 --> 00:21:35,800
generate stuff that's been made into

00:21:32,590 --> 00:21:40,720
production on real ICS not just FPGAs

00:21:35,800 --> 00:21:47,080
and but real isyes so but these are

00:21:40,720 --> 00:21:50,530
pretty cool but there's still more the

00:21:47,080 --> 00:21:52,390
thing is to make hardware it's also

00:21:50,530 --> 00:21:55,330
really seeing reasonably complicated

00:21:52,390 --> 00:21:59,050
process and to do that you need things

00:21:55,330 --> 00:22:00,610
like schematics and the PCB like the

00:21:59,050 --> 00:22:03,810
printed circuit board that needs to be

00:22:00,610 --> 00:22:06,520
drawn and all that type of thing and so

00:22:03,810 --> 00:22:08,530
me again being an open source person I

00:22:06,520 --> 00:22:11,170
use a tool called Chi CAD which is an

00:22:08,530 --> 00:22:15,070
open source tool for doing

00:22:11,170 --> 00:22:18,160
schematic and PCB design a lobster sport

00:22:15,070 --> 00:22:22,240
was designed in KY can and you can go

00:22:18,160 --> 00:22:24,610
and check out the hardware design and if

00:22:22,240 --> 00:22:26,680
you have the ability you can actually

00:22:24,610 --> 00:22:30,880
make your own if you wanted it's all CC

00:22:26,680 --> 00:22:34,810
by-sa licensed icater scriptable and

00:22:30,880 --> 00:22:37,240
python and the Kai CAD files are plain

00:22:34,810 --> 00:22:42,670
text and everybody knows that pythons

00:22:37,240 --> 00:22:48,190
really awesome at generating and passing

00:22:42,670 --> 00:22:50,170
plain text so FPGAs need this thing

00:22:48,190 --> 00:22:53,980
called a UCF file which basically says

00:22:50,170 --> 00:22:56,500
this pin is connected to this other

00:22:53,980 --> 00:22:58,210
device and these are the voltage levels

00:22:56,500 --> 00:23:00,640
that they talk to each other and that

00:22:58,210 --> 00:23:02,740
type of configuration um normally the

00:23:00,640 --> 00:23:05,860
way you do this is you get somebody to

00:23:02,740 --> 00:23:08,950
sit down and write this file looking at

00:23:05,860 --> 00:23:11,380
your schematic if your schematic changes

00:23:08,950 --> 00:23:14,320
then your UCF file is out of date and

00:23:11,380 --> 00:23:17,170
then you spend weeks going why can't I

00:23:14,320 --> 00:23:19,360
talk to the ethernet controller it's

00:23:17,170 --> 00:23:22,960
because you're using the wrong pins and

00:23:19,360 --> 00:23:26,410
so the way we do it is I have a piece of

00:23:22,960 --> 00:23:29,380
Python code that passes the schematic

00:23:26,410 --> 00:23:31,930
looks for the FPGA component and then

00:23:29,380 --> 00:23:33,970
traces all where the pins go and all

00:23:31,930 --> 00:23:36,850
look this one ends up over the Ethernet

00:23:33,970 --> 00:23:40,600
controller so let's generate a bit of

00:23:36,850 --> 00:23:43,840
UCF that does the correct things for the

00:23:40,600 --> 00:23:48,700
Ethernet controller so in this way

00:23:43,840 --> 00:23:51,310
python is helping me do hardware i have

00:23:48,700 --> 00:23:54,550
this kind of dreamy goal to eventually

00:23:51,310 --> 00:23:57,700
bring continuous integration and unit

00:23:54,550 --> 00:23:59,980
testing to circuits they have some type

00:23:57,700 --> 00:24:01,840
of basic thing could design rule checks

00:23:59,980 --> 00:24:04,540
they generally just check that you

00:24:01,840 --> 00:24:07,900
haven't connected a power input and a

00:24:04,540 --> 00:24:11,790
power input together I'd like to do much

00:24:07,900 --> 00:24:15,820
more advanced things like if you connect

00:24:11,790 --> 00:24:17,830
the wrong pins in the HDMI connector two

00:24:15,820 --> 00:24:20,590
pins on FPGA that don't support this

00:24:17,830 --> 00:24:24,400
rather than going yes you're good it

00:24:20,590 --> 00:24:25,120
goes this doesn't work and that allows

00:24:24,400 --> 00:24:27,160
you to quick

00:24:25,120 --> 00:24:29,350
we iterate on your designs more so I've

00:24:27,160 --> 00:24:33,430
kind of started this circuit unit test

00:24:29,350 --> 00:24:35,380
it's not particularly well done yet but

00:24:33,430 --> 00:24:39,160
there's that kind of another idea of

00:24:35,380 --> 00:24:41,830
using Python for hardware so that's

00:24:39,160 --> 00:24:44,410
actually at the very low level of making

00:24:41,830 --> 00:24:47,050
real physical objects and making them

00:24:44,410 --> 00:24:49,750
work and do it faster like developing

00:24:47,050 --> 00:24:51,630
hardware has this lead time that when

00:24:49,750 --> 00:24:54,880
you get it wrong you send off to

00:24:51,630 --> 00:24:56,830
manufacturer maybe if you paid a bit of

00:24:54,880 --> 00:24:59,260
money get it back a week later if you

00:24:56,830 --> 00:25:02,350
didn't and probably a couple of months

00:24:59,260 --> 00:25:04,720
later and when you get back and it

00:25:02,350 --> 00:25:06,850
doesn't work well not only did you lose

00:25:04,720 --> 00:25:09,429
money to make it happen

00:25:06,850 --> 00:25:11,230
it's another period imagine if what

00:25:09,429 --> 00:25:16,000
you'll be like developing software if

00:25:11,230 --> 00:25:18,160
your compile times were a week long so I

00:25:16,000 --> 00:25:21,490
think a really helped but it's even more

00:25:18,160 --> 00:25:23,440
um hardware generally works better when

00:25:21,490 --> 00:25:26,710
it's talking to other things like your

00:25:23,440 --> 00:25:29,980
computer and the two most common

00:25:26,710 --> 00:25:31,890
interfaces these days like physical

00:25:29,980 --> 00:25:36,300
interfaces I guess there's Wi-Fi as well

00:25:31,890 --> 00:25:41,250
USB in serial and Python is awesome both

00:25:36,300 --> 00:25:46,120
pi USB is the really good solution for

00:25:41,250 --> 00:25:50,890
talking USB it supports a whole bunch of

00:25:46,120 --> 00:25:54,940
the lib USBC stacks it's really good in

00:25:50,890 --> 00:25:57,640
that it supports back to Python 2.3 for

00:25:54,940 --> 00:25:59,260
some reason at 2.4 you're using your

00:25:57,640 --> 00:26:01,990
really ancient versions of Python also

00:25:59,260 --> 00:26:03,820
supports Python 3 Mac Windows Linux and

00:26:01,990 --> 00:26:06,790
I'm pretty sure BSD but I don't know

00:26:03,820 --> 00:26:09,429
anybody who's using BSD so I can't tell

00:26:06,790 --> 00:26:11,350
you whether it works that's kind of what

00:26:09,429 --> 00:26:13,870
it looks like it's very low level you

00:26:11,350 --> 00:26:16,200
have to understand the USB protocol to

00:26:13,870 --> 00:26:19,330
write this but lets you do things like

00:26:16,200 --> 00:26:21,790
develop a prototype driver for talking

00:26:19,330 --> 00:26:26,740
to your USB in exactly the same way you

00:26:21,790 --> 00:26:31,780
might do see so yeah there's some

00:26:26,740 --> 00:26:34,900
downsides but yeah pretty good um we use

00:26:31,780 --> 00:26:37,240
it on again our board because our board

00:26:34,900 --> 00:26:38,950
has a programmable USB controller this

00:26:37,240 --> 00:26:42,940
programmer will USB controller

00:26:38,950 --> 00:26:45,159
pretend to be lots of different things

00:26:42,940 --> 00:26:48,850
comprehend to be a serial port or a JTAG

00:26:45,159 --> 00:26:53,139
program our webcam this makes it kind of

00:26:48,850 --> 00:26:55,179
hard in that well I want it to be a

00:26:53,139 --> 00:26:59,620
webcam but it's currently a serial port

00:26:55,179 --> 00:27:01,779
I need to change that or what is in now

00:26:59,620 --> 00:27:06,909
it could be one of these ten things so

00:27:01,779 --> 00:27:09,039
we use Lib USB to provide a tool for

00:27:06,909 --> 00:27:10,630
detecting the board's connected like

00:27:09,039 --> 00:27:12,669
this is pretending to be a serial port

00:27:10,630 --> 00:27:14,950
but it's really our board and for

00:27:12,669 --> 00:27:17,950
switching the modes so that's all Python

00:27:14,950 --> 00:27:21,070
scripting as well most of time when

00:27:17,950 --> 00:27:23,380
you're doing USB you're not really care

00:27:21,070 --> 00:27:27,909
it's USB it's pretending to be serial

00:27:23,380 --> 00:27:32,830
and so PI serial is also a great way to

00:27:27,909 --> 00:27:35,019
talk to hardware it has even better

00:27:32,830 --> 00:27:39,399
support than Lib USB supports random

00:27:35,019 --> 00:27:40,960
things like jython and I am Python it's

00:27:39,399 --> 00:27:43,570
pretty easy it's just like reading and

00:27:40,960 --> 00:27:45,669
writing your file in many ways except

00:27:43,570 --> 00:27:47,409
there's a few extra complications around

00:27:45,669 --> 00:27:53,919
like the speed your writing and that

00:27:47,409 --> 00:27:56,200
type of stuff so our device appears as a

00:27:53,919 --> 00:27:58,059
webcam and a serial port and the reason

00:27:56,200 --> 00:28:00,580
it appears as a serial port is that it

00:27:58,059 --> 00:28:03,309
lets you control the device and get

00:28:00,580 --> 00:28:05,860
debugging information you might have

00:28:03,309 --> 00:28:08,980
seen some of the issues that we'll be

00:28:05,860 --> 00:28:11,980
having at the conference I'm able to see

00:28:08,980 --> 00:28:13,480
what's going on by using the laptop

00:28:11,980 --> 00:28:16,179
that's connected to the device and

00:28:13,480 --> 00:28:17,889
looking at the HDMI stream and going on

00:28:16,179 --> 00:28:20,200
reason it's broken it's because of this

00:28:17,889 --> 00:28:22,179
or they're sending the wrong resolution

00:28:20,200 --> 00:28:24,340
or all these type of things

00:28:22,179 --> 00:28:25,480
it gives me an insight into what's

00:28:24,340 --> 00:28:29,200
happening in the box

00:28:25,480 --> 00:28:32,110
um which could be in future programming

00:28:29,200 --> 00:28:34,029
lis controlled by PI serial we could

00:28:32,110 --> 00:28:36,299
have a little GUI that lets you see

00:28:34,029 --> 00:28:39,220
what's going on

00:28:36,299 --> 00:28:42,779
so yeah we really want to make

00:28:39,220 --> 00:28:45,250
presenting recording and live streaming

00:28:42,779 --> 00:28:48,070
reliable and easy and the only way we're

00:28:45,250 --> 00:28:51,309
going to do that is by having tools

00:28:48,070 --> 00:28:52,390
which give us the ability to iterate

00:28:51,309 --> 00:28:55,870
quick

00:28:52,390 --> 00:28:58,600
develop new hardware and to understand

00:28:55,870 --> 00:29:01,690
what's going on in them it's very hard

00:28:58,600 --> 00:29:06,279
to I can't buy a commercial device under

00:29:01,690 --> 00:29:07,450
the you know ten thousand USD dollars

00:29:06,279 --> 00:29:11,140
that will give me any type of

00:29:07,450 --> 00:29:15,159
Diagnostics about why it's not doing the

00:29:11,140 --> 00:29:16,539
thing that I paid $10,000 for and I

00:29:15,159 --> 00:29:20,950
can't give a ten thousand dollar device

00:29:16,539 --> 00:29:23,890
to a user group to record their one hour

00:29:20,950 --> 00:29:26,169
a month and so yet

00:29:23,890 --> 00:29:29,590
Python is essential in to making this

00:29:26,169 --> 00:29:32,860
Hardware happen and of course we're in a

00:29:29,590 --> 00:29:34,389
Python conference we need your help to

00:29:32,860 --> 00:29:36,549
make this better

00:29:34,389 --> 00:29:38,260
there are a lot of things we can do um

00:29:36,549 --> 00:29:41,889
you don't need to know hardware for

00:29:38,260 --> 00:29:44,649
example if you know how to make Python

00:29:41,889 --> 00:29:47,860
gooeys we would really love help making

00:29:44,649 --> 00:29:50,169
that Python GUI work and the serial

00:29:47,860 --> 00:29:54,130
protocol is really easy if you can do

00:29:50,169 --> 00:29:56,049
that that would really help us and I

00:29:54,130 --> 00:30:00,700
have a tendency to send hardware to

00:29:56,049 --> 00:30:03,909
people who do stuff so if getting shiny

00:30:00,700 --> 00:30:06,460
hardware in the mail tickles your fancy

00:30:03,909 --> 00:30:10,649
come and help us out and we'll be at the

00:30:06,460 --> 00:30:13,950
sprints and so that's my talk

00:30:10,649 --> 00:30:13,950
thank you Tim

00:30:18,280 --> 00:30:23,300
we'll open it up for questions actually

00:30:20,870 --> 00:30:27,530
I have a question what does the hardware

00:30:23,300 --> 00:30:35,240
cost so this iteration of the hardware

00:30:27,530 --> 00:30:36,920
is about currently four hundred US

00:30:35,240 --> 00:30:39,710
dollars which is a lot higher than we

00:30:36,920 --> 00:30:43,610
want like I want a device like the

00:30:39,710 --> 00:30:48,020
Raspberry Pi level cost eventually but

00:30:43,610 --> 00:30:49,250
you know that's a lot cheaper than a lot

00:30:48,020 --> 00:30:53,120
of other devices with similar

00:30:49,250 --> 00:30:55,490
capabilities and it's all open source so

00:30:53,120 --> 00:30:59,290
if the Chinese manufacturer wants to

00:30:55,490 --> 00:31:02,000
make a version of this device for like a

00:30:59,290 --> 00:31:05,300
teeny amount of the cost that it costs

00:31:02,000 --> 00:31:08,480
us to make it that would be really

00:31:05,300 --> 00:31:10,100
awesome please do that if you want to

00:31:08,480 --> 00:31:16,130
make a cheap Chinese clone please do

00:31:10,100 --> 00:31:27,580
I want the hardware how do you handle

00:31:16,130 --> 00:31:31,130
timing closure in the fpga um that is a

00:31:27,580 --> 00:31:35,060
complicated thing to answer and not what

00:31:31,130 --> 00:31:38,570
i have time to answer right now

00:31:35,060 --> 00:31:43,640
same way we do it in IP you do it in

00:31:38,570 --> 00:31:47,570
Verilog or VHDL the median doesn't

00:31:43,640 --> 00:31:49,610
abstract away the fact that it's still

00:31:47,570 --> 00:31:52,960
hardware so you still have to worry

00:31:49,610 --> 00:31:55,760
about things like clock domains and

00:31:52,960 --> 00:31:58,910
getting from one clock domain and that

00:31:55,760 --> 00:32:02,060
type of thing and then how fast you can

00:31:58,910 --> 00:32:04,750
run that stuff at and getting it fast

00:32:02,060 --> 00:32:06,830
enough to meet your timing requirements

00:32:04,750 --> 00:32:09,170
you still have to do all that but

00:32:06,830 --> 00:32:13,220
because you're doing it in Python it's

00:32:09,170 --> 00:32:16,490
just much nicer to be able to change

00:32:13,220 --> 00:32:19,850
things quickly like if you change the

00:32:16,490 --> 00:32:21,980
size of a bus in one part the other side

00:32:19,850 --> 00:32:24,980
doesn't all of a sudden fail to compile

00:32:21,980 --> 00:32:28,490
because your bus is now 32 bits wide

00:32:24,980 --> 00:32:30,770
instead of 31 bits wide and you only

00:32:28,490 --> 00:32:31,290
have to change one place rather than two

00:32:30,770 --> 00:32:33,420
places

00:32:31,290 --> 00:32:34,590
and things like that like that to Python

00:32:33,420 --> 00:32:36,840
modules when you can connect them

00:32:34,590 --> 00:32:41,010
together they can negotiate with each

00:32:36,840 --> 00:32:45,960
other and go well I talked RGB and you

00:32:41,010 --> 00:32:48,810
talk Yub maybe we need to translate in

00:32:45,960 --> 00:32:51,840
between us we can do things like that in

00:32:48,810 --> 00:32:53,700
Python you can't do that in Verilog to

00:32:51,840 --> 00:32:57,990
my knowledge so people end up writing

00:32:53,700 --> 00:33:01,440
Perl to generate their very log which is

00:32:57,990 --> 00:33:04,560
going down a deep hole I think we're out

00:33:01,440 --> 00:33:05,400
of time and I have to go and help run

00:33:04,560 --> 00:33:09,740
lightning talks

00:33:05,400 --> 00:33:09,740

YouTube URL: https://www.youtube.com/watch?v=wNantzHGxIs


