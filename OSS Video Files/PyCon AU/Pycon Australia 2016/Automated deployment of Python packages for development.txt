Title: Automated deployment of Python packages for development
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Andrew MacDonald
https://2016.pycon-au.org/schedule/109/view_talk
The ability to automatically deploy development and test versions of software supports a rapid development/release cycle.

Within our section of the Bureau of Meteorology we have a number of internal Python packages, ranging from small simple packages to large applications that are dependent on the smaller packages. We manage the development cycle to ease deployment of these packages and applications into development, test, and production environments.

Elements of our process are:
    * Source code management (git)
    * Code review (Gerrit)
    * Continuous integration (Jenkins)
    * Internal PyPi servers (Apache)
    * A development environment for automatic deployment of every Gerrit approved commit (Anaconda environment via Jenkins)
    * Versioning (git tags + versioneer)
    * Test environment for every tagged version (Anaconda environment via Jenkins)
    * Production environment for specified releases (Anaconda environment via Ansible)
 
A key benefit of this process is that we have a deployed Python environment for the latest development version of all packages, a pinned collection of packages for testing, and an approved stable collection for production. The development and test environments are rapidly updated when commits are approved in Gerrit or tagged. The production environment is then readily updated with specific versions after a period of testing in the test environment.
This presentation will discuss our development process, how it works for us and how we leverage Python packaging to do it.
Captions: 
	00:03:59,340 --> 00:04:05,640
hello everybody welcome back so first up

00:04:02,610 --> 00:04:07,950
we have Andrew McDonald Andrew McDonald

00:04:05,640 --> 00:04:09,209
is a Python developer who has been who

00:04:07,950 --> 00:04:10,980
has spent the last seven and a half

00:04:09,209 --> 00:04:13,530
years working at the Bureau of

00:04:10,980 --> 00:04:15,510
Meteorology the last five years of which

00:04:13,530 --> 00:04:17,250
has been in the extended hydrological

00:04:15,510 --> 00:04:19,500
prediction section working on a variety

00:04:17,250 --> 00:04:22,049
of water information products please

00:04:19,500 --> 00:04:23,699
welcome Andrew and his talk automated

00:04:22,049 --> 00:04:30,930
deployment of Python packages for

00:04:23,699 --> 00:04:33,210
development hi

00:04:30,930 --> 00:04:35,340
so as you've just heard my name is

00:04:33,210 --> 00:04:37,919
Andrew MacDonald work at the Bureau of

00:04:35,340 --> 00:04:40,320
Meteorology can I get a show of hands

00:04:37,919 --> 00:04:42,000
who knows what the Bureau of Meteorology

00:04:40,320 --> 00:04:45,539
is who's heard of the Bureau of

00:04:42,000 --> 00:04:47,160
Meteorology good it's kind of expecting

00:04:45,539 --> 00:04:49,830
everyone's hands go up there just in

00:04:47,160 --> 00:04:52,560
case is there anyone who hasn't heard of

00:04:49,830 --> 00:04:55,740
the Bureau of Meteorology excellent

00:04:52,560 --> 00:04:57,690
that's what I was expecting so I'm here

00:04:55,740 --> 00:04:59,280
today to talk about the processes that

00:04:57,690 --> 00:05:00,750
the extended hydrological prediction

00:04:59,280 --> 00:05:03,270
section of the Bureau of Meteorology

00:05:00,750 --> 00:05:06,180
used for the automated deployment of

00:05:03,270 --> 00:05:08,220
Python packages this includes our

00:05:06,180 --> 00:05:10,860
development processes that lead up to

00:05:08,220 --> 00:05:15,300
the deployment of the packages how we

00:05:10,860 --> 00:05:17,130
get them gilt and out for use just about

00:05:15,300 --> 00:05:20,669
my colleagues that are listed up there

00:05:17,130 --> 00:05:23,000
Kevin presented yesterday on CF Fi and

00:05:20,669 --> 00:05:26,400
geocode hub if you caught that session

00:05:23,000 --> 00:05:30,840
de hawk is presenting next session on

00:05:26,400 --> 00:05:32,070
Python for water forecasting and that's

00:05:30,840 --> 00:05:35,700
in a different room if you want to catch

00:05:32,070 --> 00:05:37,050
that talk and David Kent is around at

00:05:35,700 --> 00:05:41,760
the conference but he's not presenting

00:05:37,050 --> 00:05:44,340
anything this year so as you just heard

00:05:41,760 --> 00:05:46,770
I'm a member of the extended

00:05:44,340 --> 00:05:49,760
hydrological prediction section it was

00:05:46,770 --> 00:05:52,289
seven and a half years when I wrote that

00:05:49,760 --> 00:05:54,330
profile there will actually be eight

00:05:52,289 --> 00:05:57,680
years in October

00:05:54,330 --> 00:06:01,800
which like October two months from today

00:05:57,680 --> 00:06:03,440
so it's been a long time but it's not

00:06:01,800 --> 00:06:06,000
about me

00:06:03,440 --> 00:06:07,289
extended hydrological prediction we

00:06:06,000 --> 00:06:10,440
developed a few water information

00:06:07,289 --> 00:06:11,820
products and I've included the acronym

00:06:10,440 --> 00:06:13,320
ehb up there

00:06:11,820 --> 00:06:15,660
not because it's important for you to

00:06:13,320 --> 00:06:17,130
know but because it does show up in a

00:06:15,660 --> 00:06:18,150
few snippets later so if you're

00:06:17,130 --> 00:06:22,440
wondering what it stands for

00:06:18,150 --> 00:06:25,170
that's PHP few products in particular

00:06:22,440 --> 00:06:27,480
that we produce the seasonal streamflow

00:06:25,170 --> 00:06:29,010
forecasts for predictions on how much

00:06:27,480 --> 00:06:31,380
water will flow past a point in a river

00:06:29,010 --> 00:06:33,300
over the next three months the seven-day

00:06:31,380 --> 00:06:34,650
streamflow forecasts for predictions on

00:06:33,300 --> 00:06:37,400
how much water will flow past a point in

00:06:34,650 --> 00:06:39,660
the river over the next seven days and

00:06:37,400 --> 00:06:41,580
the hydrologic reference stations

00:06:39,660 --> 00:06:43,230
quality check data set of daily

00:06:41,580 --> 00:06:45,590
streamflow data with various data

00:06:43,230 --> 00:06:47,910
visualizations and some trend analysis

00:06:45,590 --> 00:06:49,680
all these products can be found on the

00:06:47,910 --> 00:06:52,980
bureau's website linked from the bomb

00:06:49,680 --> 00:06:56,070
Cove today you slash water page the

00:06:52,980 --> 00:06:57,410
diagram on fire riders how is lifted

00:06:56,070 --> 00:06:59,160
straight from our documentation and

00:06:57,410 --> 00:07:01,560
process I'm going to be talking about

00:06:59,160 --> 00:07:03,540
today but don't worry about reading it

00:07:01,560 --> 00:07:06,330
up there I've got some large versions

00:07:03,540 --> 00:07:08,340
later so the interesting thing for this

00:07:06,330 --> 00:07:11,040
crowd is that all these products are

00:07:08,340 --> 00:07:13,650
backed by Python software those charts

00:07:11,040 --> 00:07:16,680
you can see for example built using that

00:07:13,650 --> 00:07:18,330
plot lid so how do we go from Python

00:07:16,680 --> 00:07:23,250
code to products on the bureau's

00:07:18,330 --> 00:07:25,140
production website at its simplest the

00:07:23,250 --> 00:07:28,230
development life cycle is Reisen code

00:07:25,140 --> 00:07:30,480
push it into production repeat that

00:07:28,230 --> 00:07:32,270
isn't really best practice though it can

00:07:30,480 --> 00:07:34,170
work for a while but it's not

00:07:32,270 --> 00:07:38,940
necessarily the best way to get robust

00:07:34,170 --> 00:07:40,320
and useful code for example first

00:07:38,940 --> 00:07:42,150
service produced by the extender

00:07:40,320 --> 00:07:43,760
hydrological predictions section was the

00:07:42,150 --> 00:07:46,080
seasonal streamflow forecasting service

00:07:43,760 --> 00:07:47,910
during initial development of the

00:07:46,080 --> 00:07:50,010
seasonal streamflow service the steps

00:07:47,910 --> 00:07:51,840
between writing code and deploying to

00:07:50,010 --> 00:07:54,600
production weren't particularly well

00:07:51,840 --> 00:07:56,610
defined which worked well for a rapid

00:07:54,600 --> 00:07:59,670
iteration and getting experimental

00:07:56,610 --> 00:08:02,940
forecasts out to a select few registered

00:07:59,670 --> 00:08:04,830
users over time however our development

00:08:02,940 --> 00:08:06,810
practices have evolved adopting more

00:08:04,830 --> 00:08:10,230
standards to help us get results quickly

00:08:06,810 --> 00:08:13,320
and reliably doing this was an absolute

00:08:10,230 --> 00:08:14,880
must as the scope of our services grew

00:08:13,320 --> 00:08:17,430
and the number of services we offered

00:08:14,880 --> 00:08:19,350
increased so today I'm going to be

00:08:17,430 --> 00:08:22,020
talking about our version of step 1

00:08:19,350 --> 00:08:24,600
write code step 2 question mark question

00:08:22,020 --> 00:08:25,589
mark question mark step 3 profit or in

00:08:24,600 --> 00:08:28,589
this case production

00:08:25,589 --> 00:08:30,479
and how automating the build and

00:08:28,589 --> 00:08:35,579
deployment of fife and packages eases

00:08:30,479 --> 00:08:37,259
that process since the early days of a

00:08:35,579 --> 00:08:40,589
single experimental service we've

00:08:37,259 --> 00:08:43,649
introduced code review introducing this

00:08:40,589 --> 00:08:45,470
into our process allowed for code to be

00:08:43,649 --> 00:08:48,120
reviewed and iterated on before release

00:08:45,470 --> 00:08:50,069
we first introduced code review when

00:08:48,120 --> 00:08:52,350
we're working on the hydrological

00:08:50,069 --> 00:08:54,120
reference stations project at the time

00:08:52,350 --> 00:08:55,800
we had a contractor working with us so

00:08:54,120 --> 00:08:57,329
putting a code review system in place

00:08:55,800 --> 00:08:59,279
helped with setting direction of their

00:08:57,329 --> 00:09:02,009
development and monitoring changes that

00:08:59,279 --> 00:09:03,480
were made to the code base it also meant

00:09:02,009 --> 00:09:05,249
seeing the contractors commit messages

00:09:03,480 --> 00:09:08,269
that included Velociraptor ASCII art

00:09:05,249 --> 00:09:10,889
before they went into production

00:09:08,269 --> 00:09:11,970
having code reviews allows us to keep an

00:09:10,889 --> 00:09:14,249
eye on things like making sure

00:09:11,970 --> 00:09:16,499
docstrings are included and that there

00:09:14,249 --> 00:09:18,420
are unit tests covering the change now

00:09:16,499 --> 00:09:20,279
if we're ensuring that unit tests are

00:09:18,420 --> 00:09:21,930
included full of the code the obvious

00:09:20,279 --> 00:09:26,610
thing to do is automatically run them

00:09:21,930 --> 00:09:28,920
before reviewing the change so we set

00:09:26,610 --> 00:09:31,110
things up to automatically run the test

00:09:28,920 --> 00:09:33,029
suite for the code being reviewed so as

00:09:31,110 --> 00:09:33,629
to provide feedback during the approval

00:09:33,029 --> 00:09:36,149
process

00:09:33,629 --> 00:09:37,920
now just because codes been reviewed by

00:09:36,149 --> 00:09:41,639
developers doesn't mean it's ready to go

00:09:37,920 --> 00:09:43,410
into production yet it really needs to

00:09:41,639 --> 00:09:45,600
go through user acceptance testing and

00:09:43,410 --> 00:09:48,930
possibly be revised before going into

00:09:45,600 --> 00:09:50,699
production which means readily putting

00:09:48,930 --> 00:09:53,189
the software into the hands of users as

00:09:50,699 --> 00:09:54,480
quickly as possible so that they can try

00:09:53,189 --> 00:09:57,180
it out and check it producers the

00:09:54,480 --> 00:09:58,860
required results so now we have a

00:09:57,180 --> 00:10:00,689
process which can be broken down to two

00:09:58,860 --> 00:10:02,519
parts software development and review

00:10:00,689 --> 00:10:05,309
and deployment for testing and

00:10:02,519 --> 00:10:09,589
production use let's talk about this

00:10:05,309 --> 00:10:13,079
first part first how development process

00:10:09,589 --> 00:10:15,540
all our code organized into Python

00:10:13,079 --> 00:10:17,339
packages some of our packages has shared

00:10:15,540 --> 00:10:18,839
across projects while other packages

00:10:17,339 --> 00:10:21,059
represent an application used for

00:10:18,839 --> 00:10:23,490
specific tasks like generating seasonal

00:10:21,059 --> 00:10:26,429
streamflow forecasts each bison package

00:10:23,490 --> 00:10:28,170
has its own git repository so mentioned

00:10:26,429 --> 00:10:30,529
before the flow chart on the right it's

00:10:28,170 --> 00:10:32,999
lifted straight from our documentation

00:10:30,529 --> 00:10:35,279
starting with developing code a bug fix

00:10:32,999 --> 00:10:36,689
or features implemented this includes

00:10:35,279 --> 00:10:38,929
writing or updating unit tests where

00:10:36,689 --> 00:10:38,929
appropriate

00:10:39,199 --> 00:10:44,399
once the change is made it is committed

00:10:41,999 --> 00:10:46,319
and pushed to the code review system

00:10:44,399 --> 00:10:49,799
where you're using which is Garrett I'll

00:10:46,319 --> 00:10:52,019
talk more about Garrett shortly from

00:10:49,799 --> 00:10:53,850
there the changes review because we're a

00:10:52,019 --> 00:10:55,679
small team sometimes we'll do self

00:10:53,850 --> 00:10:57,089
reviews because of the practicality of

00:10:55,679 --> 00:11:00,059
others not having time to do code

00:10:57,089 --> 00:11:01,979
reviews reviewing your own code still

00:11:00,059 --> 00:11:03,539
better than no code review because you

00:11:01,979 --> 00:11:05,399
look at it later in a different context

00:11:03,539 --> 00:11:08,100
pick things up that you didn't notice

00:11:05,399 --> 00:11:09,089
while writing it initially I personally

00:11:08,100 --> 00:11:10,859
have looked over code that I've written

00:11:09,089 --> 00:11:12,600
and realize that I've made a mistake or

00:11:10,859 --> 00:11:14,879
miss something like a missing or

00:11:12,600 --> 00:11:18,600
incomplete doc string something I do far

00:11:14,879 --> 00:11:21,089
more often than I should Garrett gives

00:11:18,600 --> 00:11:24,179
us the opportunity to amend those

00:11:21,089 --> 00:11:25,739
commits before approval of course for

00:11:24,179 --> 00:11:27,389
bigger or more controversial changes

00:11:25,739 --> 00:11:28,889
we'll make sure that someone else has a

00:11:27,389 --> 00:11:31,289
look over the changes before approving

00:11:28,889 --> 00:11:36,149
because with great power comes great

00:11:31,289 --> 00:11:38,009
responsibility we also have Jenkins

00:11:36,149 --> 00:11:39,569
continuous integration tools set up to

00:11:38,009 --> 00:11:42,329
automatically run unit tests when

00:11:39,569 --> 00:11:43,709
changes submitted to Gerrit Jenkins will

00:11:42,329 --> 00:11:45,299
then give a plus one or minus one

00:11:43,709 --> 00:11:48,720
verified vote for passing or failing

00:11:45,299 --> 00:11:51,419
tests if the tests pass and the reviewer

00:11:48,720 --> 00:11:53,389
is happy the commit is then approved and

00:11:51,419 --> 00:11:55,799
appears in the git repository proper

00:11:53,389 --> 00:11:59,159
otherwise development can continue

00:11:55,799 --> 00:12:06,659
revising and amending the commits or

00:11:59,159 --> 00:12:13,459
extending with further commits so what

00:12:06,659 --> 00:12:16,199
is Garrett Garrett is an Apache two

00:12:13,459 --> 00:12:19,499
licensed code review system it's based

00:12:16,199 --> 00:12:20,789
around git and written in Java not that

00:12:19,499 --> 00:12:23,429
their choice of language matters once

00:12:20,789 --> 00:12:25,169
it's deployed it was initially developed

00:12:23,429 --> 00:12:28,379
by Google for use with Android open

00:12:25,169 --> 00:12:30,869
source project fun fact Garrett will

00:12:28,379 --> 00:12:32,399
begin life as a fork of rebuild which is

00:12:30,869 --> 00:12:34,350
a Python based code review system for

00:12:32,399 --> 00:12:39,239
use for subversion and rebuild was

00:12:34,350 --> 00:12:41,939
written by guido van rossum we have an

00:12:39,239 --> 00:12:43,739
internal deployment which is configured

00:12:41,939 --> 00:12:45,869
to replicate approve changes to a few

00:12:43,739 --> 00:12:47,220
different internal get servers Garrett

00:12:45,869 --> 00:12:49,169
has a variety of plugins that can be

00:12:47,220 --> 00:12:51,749
configured in many ways replication

00:12:49,169 --> 00:12:52,740
being just one we also have it

00:12:51,749 --> 00:12:54,360
configured to turn

00:12:52,740 --> 00:12:55,860
references to issue numbers and commit

00:12:54,360 --> 00:12:58,230
messages into links to our issue

00:12:55,860 --> 00:13:00,870
tracking system or if the issues

00:12:58,230 --> 00:13:04,530
reference in a different format it links

00:13:00,870 --> 00:13:06,300
to CSIRO s issue tracking system to use

00:13:04,530 --> 00:13:08,070
Gerrit effectively you do need to be

00:13:06,300 --> 00:13:12,810
comfortable with get there's lots and

00:13:08,070 --> 00:13:14,580
lots of rewriting history Gerrit uses a

00:13:12,810 --> 00:13:16,650
change ID and commit messages to track

00:13:14,580 --> 00:13:18,330
logical changes since the commit house

00:13:16,650 --> 00:13:20,610
changes whenever the commit is amended

00:13:18,330 --> 00:13:22,380
while the change ID can be generated

00:13:20,610 --> 00:13:25,230
from Gerrit and manually pasted into

00:13:22,380 --> 00:13:30,270
each commit that would very quickly get

00:13:25,230 --> 00:13:31,770
tedious so a commit hook is provided by

00:13:30,270 --> 00:13:34,110
a Gerrit which can be added to your

00:13:31,770 --> 00:13:36,720
repository to give each new commit to

00:13:34,110 --> 00:13:38,670
change ID automatically while keeping

00:13:36,720 --> 00:13:43,740
any existing change ID in the commit

00:13:38,670 --> 00:13:45,780
when it's amended by default code view

00:13:43,740 --> 00:13:48,720
system is managed with two labels code

00:13:45,780 --> 00:13:51,300
review and verified wear code review is

00:13:48,720 --> 00:13:54,450
looks good to me or I prefer not to

00:13:51,300 --> 00:13:55,830
include this type responses and verified

00:13:54,450 --> 00:13:57,570
on the other hand can be used for

00:13:55,830 --> 00:14:02,310
stating if the code works or doesn't

00:13:57,570 --> 00:14:03,680
work - - code review or a -1 verified

00:14:02,310 --> 00:14:06,780
will block commits from being approved

00:14:03,680 --> 00:14:09,480
while approval requires a +2 code review

00:14:06,780 --> 00:14:12,180
and a +1 verified anything less and a

00:14:09,480 --> 00:14:14,670
change can't be merged multiple people

00:14:12,180 --> 00:14:17,910
can review a change the +1 code reviews

00:14:14,670 --> 00:14:20,310
don't stack if multiple people voted +1

00:14:17,910 --> 00:14:23,040
code review it would still require a +2

00:14:20,310 --> 00:14:25,230
from one person to enable approval the

00:14:23,040 --> 00:14:26,850
missions can be managed for each project

00:14:25,230 --> 00:14:29,730
so that only members of specific groups

00:14:26,850 --> 00:14:31,860
can give plus or minus 2 while others

00:14:29,730 --> 00:14:35,460
can generally only vote plus or minus

00:14:31,860 --> 00:14:38,430
one as mentioned previously we're using

00:14:35,460 --> 00:14:42,690
Jenkins for automatically running the

00:14:38,430 --> 00:14:44,850
tests and it's set up to run for various

00:14:42,690 --> 00:14:46,860
Gerrit projects that we have Jenkins

00:14:44,850 --> 00:14:51,170
will then give a minus 1 or a plus 1

00:14:46,860 --> 00:14:51,170
verified based on the success of the job

00:14:51,200 --> 00:14:55,440
not that I expected you to be able to

00:14:53,790 --> 00:15:00,120
read the screenshot on the write that as

00:14:55,440 --> 00:15:02,090
an example it was taken of a change that

00:15:00,120 --> 00:15:04,230
was submitted to Gerrit for

00:15:02,090 --> 00:15:06,209
documentation which also goes through

00:15:04,230 --> 00:15:07,679
the code review process

00:15:06,209 --> 00:15:09,660
our documentation is written in Sphinx

00:15:07,679 --> 00:15:11,910
and built by Jenkins and upon completion

00:15:09,660 --> 00:15:14,429
Jenkins includes a link in the comment

00:15:11,910 --> 00:15:16,230
it leaves when voting on the change so

00:15:14,429 --> 00:15:18,839
that you can link straight to the

00:15:16,230 --> 00:15:21,629
documentation from Garrett and have a

00:15:18,839 --> 00:15:25,410
review of the Jenkins build before

00:15:21,629 --> 00:15:27,059
approving using the same process for our

00:15:25,410 --> 00:15:29,550
documentation as writing software means

00:15:27,059 --> 00:15:33,720
that new team members can learn about a

00:15:29,550 --> 00:15:38,309
documentation process by contributing

00:15:33,720 --> 00:15:41,220
and just kind of helps embed the idea of

00:15:38,309 --> 00:15:44,249
code review now for some more about

00:15:41,220 --> 00:15:46,410
Jenkins as I mentioned Jenkins is a

00:15:44,249 --> 00:15:49,110
continuous integration server like

00:15:46,410 --> 00:15:50,730
Gerrit it's also written in Java it's

00:15:49,110 --> 00:15:55,529
open source licensed under the MIT

00:15:50,730 --> 00:15:57,029
license it has a plugin for connecting

00:15:55,529 --> 00:15:58,949
to Gerrit which makes things easy for

00:15:57,029 --> 00:16:01,259
integrating the automatic running of

00:15:58,949 --> 00:16:02,939
tests with code reviews we have a

00:16:01,259 --> 00:16:04,199
Jenkins Garrett job for most of the

00:16:02,939 --> 00:16:06,629
Python packages that we run through

00:16:04,199 --> 00:16:08,369
Garrett the individual jobs allow

00:16:06,629 --> 00:16:12,269
Jenkins to track the test coverage and

00:16:08,369 --> 00:16:14,970
success over time most of these jobs

00:16:12,269 --> 00:16:16,799
however call the same shell script which

00:16:14,970 --> 00:16:18,660
first checks if the get check out it's

00:16:16,799 --> 00:16:21,119
been being run has to set up top high

00:16:18,660 --> 00:16:23,249
file and if it does it loads Python

00:16:21,119 --> 00:16:25,920
anaconda environment before running

00:16:23,249 --> 00:16:28,970
Python set up the PI knows tests node

00:16:25,920 --> 00:16:32,069
batchelder's coverage tool and pilant

00:16:28,970 --> 00:16:34,499
screenshot there is of our Jenkins

00:16:32,069 --> 00:16:37,889
instance showing our Python build

00:16:34,499 --> 00:16:41,220
project this Python build project is

00:16:37,889 --> 00:16:43,679
parameterised build it's triggered by a

00:16:41,220 --> 00:16:46,199
repository watch job the repository

00:16:43,679 --> 00:16:48,329
watch job watches the Gerrit for any

00:16:46,199 --> 00:16:50,040
approved or tagged commits and triggers

00:16:48,329 --> 00:16:52,379
the Python build project with the name

00:16:50,040 --> 00:16:55,230
of the repository and the branch or tag

00:16:52,379 --> 00:16:56,610
that was approved now we're getting to

00:16:55,230 --> 00:16:58,889
the core of what this presentation is

00:16:56,610 --> 00:17:00,689
about we've discussed the top half of

00:16:58,889 --> 00:17:03,329
this process which is developing code

00:17:00,689 --> 00:17:05,370
and approving changes but their second

00:17:03,329 --> 00:17:08,279
part is the important bit because if the

00:17:05,370 --> 00:17:10,439
code isn't deployed it can't get used so

00:17:08,279 --> 00:17:12,419
how do we get the changes into the hands

00:17:10,439 --> 00:17:14,250
of users for testing or production use

00:17:12,419 --> 00:17:18,649
as quickly and as easily as possible

00:17:14,250 --> 00:17:18,649
this is where the Jenkins build comes in

00:17:19,220 --> 00:17:24,910
the Python build job we've triggered is

00:17:20,930 --> 00:17:28,940
on every Garrett approve commit and

00:17:24,910 --> 00:17:30,860
every push tag Jenkins checks out the

00:17:28,940 --> 00:17:32,480
branch or tag for a git repository based

00:17:30,860 --> 00:17:35,000
on the parameters to build build

00:17:32,480 --> 00:17:37,730
parameters being a commit reference so a

00:17:35,000 --> 00:17:41,090
branch for a tag and the git repository

00:17:37,730 --> 00:17:44,270
named job runs the shell script which in

00:17:41,090 --> 00:17:45,890
turns calls to other shell scripts the

00:17:44,270 --> 00:17:47,780
first child shell script is for standard

00:17:45,890 --> 00:17:51,920
pipe pie style packages the second is

00:17:47,780 --> 00:17:54,500
for Condor packages parent shell script

00:17:51,920 --> 00:17:56,210
covers common steps for both child

00:17:54,500 --> 00:17:57,890
scripts and exports environment

00:17:56,210 --> 00:18:00,440
variables for the children to use before

00:17:57,890 --> 00:18:02,210
calling them the first step in the

00:18:00,440 --> 00:18:04,130
parent script is checking for setup the

00:18:02,210 --> 00:18:06,560
PI file as I mentioned before and

00:18:04,130 --> 00:18:08,060
stopping if one isn't found this is

00:18:06,560 --> 00:18:10,010
because the job triggers for all of our

00:18:08,060 --> 00:18:12,470
gate repositories some of which are

00:18:10,010 --> 00:18:13,730
Python packages for example a shared

00:18:12,470 --> 00:18:17,930
documentation which I mentioned earlier

00:18:13,730 --> 00:18:19,790
being sphinx and not a Python package if

00:18:17,930 --> 00:18:22,640
it is a Python package the name is

00:18:19,790 --> 00:18:25,400
determined using Python setup the PI - -

00:18:22,640 --> 00:18:26,870
name this is because the name of the

00:18:25,400 --> 00:18:29,270
package may not match the name of the

00:18:26,870 --> 00:18:31,310
git repository which does happen usually

00:18:29,270 --> 00:18:33,400
for historical reasons like a package

00:18:31,310 --> 00:18:36,110
name change to make them hold pythonic

00:18:33,400 --> 00:18:38,780
we then get the safe package name which

00:18:36,110 --> 00:18:41,810
is the package file name as would be

00:18:38,780 --> 00:18:43,850
understood by pi PI or pip we also get

00:18:41,810 --> 00:18:46,970
the version of the package using path

00:18:43,850 --> 00:18:48,710
and setup - pi - - version which is

00:18:46,970 --> 00:18:54,500
using version air behind the scenes to

00:18:48,710 --> 00:18:57,470
get the version from a gift tag within

00:18:54,500 --> 00:19:00,560
the pi PI build script we call Python

00:18:57,470 --> 00:19:05,170
setup the PI s dist and Python setup the

00:19:00,560 --> 00:19:08,540
PI B disc wheel to get source and we all

00:19:05,170 --> 00:19:11,150
packages which we can then copy to our

00:19:08,540 --> 00:19:13,160
internal pi PI repository our internal

00:19:11,150 --> 00:19:14,990
pi PI repository consists of basic

00:19:13,160 --> 00:19:17,960
directory structure that pip understands

00:19:14,990 --> 00:19:21,860
exposed exposed by our Apache so nothing

00:19:17,960 --> 00:19:23,810
too fancy there are a few extra steps in

00:19:21,860 --> 00:19:26,720
the script that pi PI packages takes

00:19:23,810 --> 00:19:29,930
based on the gift tag but I'll discuss

00:19:26,720 --> 00:19:31,640
that a little later also recently begun

00:19:29,930 --> 00:19:32,570
building Condor packages for some of our

00:19:31,640 --> 00:19:35,240
Python project

00:19:32,570 --> 00:19:38,150
in addition to requiring the setup the

00:19:35,240 --> 00:19:40,370
pie the script checks for a condo recipe

00:19:38,150 --> 00:19:43,090
directory and if it finds one it runs

00:19:40,370 --> 00:19:45,920
the condo build command listed up there

00:19:43,090 --> 00:19:48,260
dollar channels is variable defining our

00:19:45,920 --> 00:19:52,520
internal mirror of the condo channel and

00:19:48,260 --> 00:19:55,280
our internal Condit channel of internal

00:19:52,520 --> 00:19:56,960
packages the remaining three steps are

00:19:55,280 --> 00:20:00,080
about copying the condo package to the

00:19:56,960 --> 00:20:01,580
repo and building the Condor index again

00:20:00,080 --> 00:20:03,260
there are additional decisions made

00:20:01,580 --> 00:20:12,440
around get tags which I'll discuss a

00:20:03,260 --> 00:20:14,390
little later so over time our

00:20:12,440 --> 00:20:15,710
development of Python packages has kind

00:20:14,390 --> 00:20:18,200
of converged on a similar pattern

00:20:15,710 --> 00:20:21,140
so if extra abstracted that into a

00:20:18,200 --> 00:20:22,730
template package since these Jenkins

00:20:21,140 --> 00:20:24,650
jobs are hooked to Garrett makes it

00:20:22,730 --> 00:20:26,660
simpler if all of our packages follow

00:20:24,650 --> 00:20:28,190
the same pattern so we have a

00:20:26,660 --> 00:20:30,800
command-line tool that creates a set up

00:20:28,190 --> 00:20:33,500
a PI file that has the key details

00:20:30,800 --> 00:20:37,190
filled out along with other common files

00:20:33,500 --> 00:20:39,080
for our style a Python package the

00:20:37,190 --> 00:20:40,760
template setup the PI file includes

00:20:39,080 --> 00:20:43,490
version here and the appropriate set up

00:20:40,760 --> 00:20:45,200
dot CFG file to manage the versions

00:20:43,490 --> 00:20:49,850
based on gift tags straight out of the

00:20:45,200 --> 00:20:51,680
gate in addition it includes dot dot get

00:20:49,850 --> 00:20:54,230
ignore file to include nor common

00:20:51,680 --> 00:20:57,650
patterns like py C files and in swap

00:20:54,230 --> 00:20:59,960
files we also include a dot coverage RC

00:20:57,650 --> 00:21:01,670
file so that the package is configured

00:20:59,960 --> 00:21:05,510
for generating code coverage information

00:21:01,670 --> 00:21:07,160
right away and finally a readme rst with

00:21:05,510 --> 00:21:09,890
basic setup the PI install instructions

00:21:07,160 --> 00:21:11,090
and it's just sitting there all ready to

00:21:09,890 --> 00:21:14,540
be filled out with further details about

00:21:11,090 --> 00:21:16,550
the package we don't have a template

00:21:14,540 --> 00:21:19,330
Condor dot recipe directory yet because

00:21:16,550 --> 00:21:22,040
only started doing the Condor stuff

00:21:19,330 --> 00:21:24,740
packaging recently but it will likely

00:21:22,040 --> 00:21:28,430
become a part of a future version of our

00:21:24,740 --> 00:21:30,170
template so we've discussed the first

00:21:28,430 --> 00:21:32,000
part of this process which is largely

00:21:30,170 --> 00:21:33,710
about the development of code and tools

00:21:32,000 --> 00:21:35,060
we have supporting that but what about

00:21:33,710 --> 00:21:37,610
those Jenkins jobs that I mentioned

00:21:35,060 --> 00:21:41,870
regarding get tags and what happens once

00:21:37,610 --> 00:21:43,700
the change is deployed or approved well

00:21:41,870 --> 00:21:45,350
after the change is approved the process

00:21:43,700 --> 00:21:46,640
follows the flow chart on the right any

00:21:45,350 --> 00:21:49,160
approved change

00:21:46,640 --> 00:21:52,100
be built by Jenkins and deployed to our

00:21:49,160 --> 00:21:54,110
internal development pi PI server so it

00:21:52,100 --> 00:21:57,830
is available immediately for pip

00:21:54,110 --> 00:21:59,690
installing in addition to deployment to

00:21:57,830 --> 00:22:02,300
the Delphi PI server the packages

00:21:59,690 --> 00:22:04,040
automatically pip installed into our dev

00:22:02,300 --> 00:22:06,560
Condor environment on our development

00:22:04,040 --> 00:22:08,810
server this gives our developers and

00:22:06,560 --> 00:22:10,460
really keen users virtually instant

00:22:08,810 --> 00:22:13,490
access to the latest development version

00:22:10,460 --> 00:22:15,080
of any package we are working on there

00:22:13,490 --> 00:22:16,400
is also a manual deployment of our dev

00:22:15,080 --> 00:22:18,170
test and production environments to

00:22:16,400 --> 00:22:22,670
other servers using ansible which we

00:22:18,170 --> 00:22:25,430
just run as needed now for the lease

00:22:22,670 --> 00:22:27,290
versions we tag the git repository for

00:22:25,430 --> 00:22:30,260
the appropriate commits with a pet for

00:22:27,290 --> 00:22:31,940
40 compliant oh if you haven't read PAP

00:22:30,260 --> 00:22:34,640
440 it describes a scheme for

00:22:31,940 --> 00:22:36,950
identifying versions of Python software

00:22:34,640 --> 00:22:39,620
distributions declaring dependencies on

00:22:36,950 --> 00:22:40,850
particular versions and I highly

00:22:39,620 --> 00:22:42,050
recommend reading it if you have

00:22:40,850 --> 00:22:46,370
anything to do with versioning

00:22:42,050 --> 00:22:48,200
whatsoever once a tag is pushed to

00:22:46,370 --> 00:22:51,080
Gerrit Jenkins will automatically build

00:22:48,200 --> 00:22:53,090
and deploy to our test pi PI server as

00:22:51,080 --> 00:22:54,320
well as automatically installing into

00:22:53,090 --> 00:22:56,750
the test condor environment on our

00:22:54,320 --> 00:22:58,910
development server release candidates

00:22:56,750 --> 00:23:00,350
are tagged with our C tags so that they

00:22:58,910 --> 00:23:02,060
can be automatically deployed but

00:23:00,350 --> 00:23:05,690
identifiable is not necessarily

00:23:02,060 --> 00:23:08,480
production ready yet after user

00:23:05,690 --> 00:23:10,790
acceptance testing a final non RC tag

00:23:08,480 --> 00:23:12,350
can be applied to the same commit which

00:23:10,790 --> 00:23:13,850
will result in test environment being

00:23:12,350 --> 00:23:17,900
updated again with the same version

00:23:13,850 --> 00:23:19,940
that's going to go into production as I

00:23:17,900 --> 00:23:23,360
mentioned earlier we're using version

00:23:19,940 --> 00:23:25,640
here to handle the version numbers

00:23:23,360 --> 00:23:27,980
version ear extracts the latest tag from

00:23:25,640 --> 00:23:29,990
git and uses that in setup the PI and

00:23:27,980 --> 00:23:32,660
exposes the done diversion in the

00:23:29,990 --> 00:23:34,550
package if there have been commits since

00:23:32,660 --> 00:23:36,170
the last tag version air will build a

00:23:34,550 --> 00:23:38,690
version string that includes the number

00:23:36,170 --> 00:23:41,150
of commits since the last tag version

00:23:38,690 --> 00:23:43,670
and a snippet of that commit hash for

00:23:41,150 --> 00:23:45,380
the current commit it does all that in

00:23:43,670 --> 00:23:49,820
the pep for 40 compliant manner since

00:23:45,380 --> 00:23:52,220
version 0.14 of version air finally

00:23:49,820 --> 00:23:54,500
after tagging for production the package

00:23:52,220 --> 00:23:56,840
built with the production version can

00:23:54,500 --> 00:23:59,090
with the production version tag can be

00:23:56,840 --> 00:24:00,440
manually copied from the test pipe I

00:23:59,090 --> 00:24:02,510
instance to the production

00:24:00,440 --> 00:24:03,890
we do this because we don't want to

00:24:02,510 --> 00:24:07,130
accidentally push changes into

00:24:03,890 --> 00:24:09,070
production so if we're mentioning

00:24:07,130 --> 00:24:12,170
throughout that we've been using

00:24:09,070 --> 00:24:14,510
anaconda environments earlier this year

00:24:12,170 --> 00:24:17,710
we switch from doing deployments using

00:24:14,510 --> 00:24:20,960
virtual environments so virtual land and

00:24:17,710 --> 00:24:26,720
having a virtual environment per system

00:24:20,960 --> 00:24:28,340
or application having a unified virtual

00:24:26,720 --> 00:24:31,790
environment with all of Extender

00:24:28,340 --> 00:24:35,810
hydrological prediction systems packages

00:24:31,790 --> 00:24:39,590
in it is great they're all available at

00:24:35,810 --> 00:24:40,730
once so any of our hydrologist can sort

00:24:39,590 --> 00:24:44,810
of mix and match stuff that we have

00:24:40,730 --> 00:24:46,880
going on the result of this unified

00:24:44,810 --> 00:24:48,920
environment does mean that updating

00:24:46,880 --> 00:24:51,590
dependencies whether they be external or

00:24:48,920 --> 00:24:54,680
internal is more easily managed by first

00:24:51,590 --> 00:24:56,810
making them available in dev to work out

00:24:54,680 --> 00:24:59,600
any kinks and then promoting the entire

00:24:56,810 --> 00:25:02,570
dev environment to test before a final

00:24:59,600 --> 00:25:04,700
promotion from test production anaconda

00:25:02,570 --> 00:25:05,690
makes this process easier through the

00:25:04,700 --> 00:25:08,270
use of environment general

00:25:05,690 --> 00:25:11,840
configurations to define a collection of

00:25:08,270 --> 00:25:13,520
packages and their versions the dev

00:25:11,840 --> 00:25:15,380
environment is mostly just a list of

00:25:13,520 --> 00:25:17,570
packages with the latest version being

00:25:15,380 --> 00:25:21,500
picked up from our dev pi PI instance or

00:25:17,570 --> 00:25:22,730
mirror while the tests production while

00:25:21,500 --> 00:25:24,590
our tests in production environments

00:25:22,730 --> 00:25:26,840
have specific versions specified for

00:25:24,590 --> 00:25:30,350
every package to ensure a working

00:25:26,840 --> 00:25:32,570
combination the other key benefit of

00:25:30,350 --> 00:25:34,220
anaconda is pre-built packages which

00:25:32,570 --> 00:25:37,760
means no more waiting on the umpire or

00:25:34,220 --> 00:25:39,410
Syfy to build and it just makes setting

00:25:37,760 --> 00:25:42,620
up multiple virtual environments for

00:25:39,410 --> 00:25:44,570
development a whole lot easier pre-built

00:25:42,620 --> 00:25:47,720
binaries also helps with deployment of

00:25:44,570 --> 00:25:51,230
packages that include Fortran code so we

00:25:47,720 --> 00:25:53,780
have some research stuff where the core

00:25:51,230 --> 00:25:56,150
is Fortran needs to be compiled with the

00:25:53,780 --> 00:25:58,520
Intel Fortran compiler our builds

00:25:56,150 --> 00:26:00,680
process runs on the server where the

00:25:58,520 --> 00:26:02,090
compiler is available and then we can

00:26:00,680 --> 00:26:03,980
install the other servers without issue

00:26:02,090 --> 00:26:06,320
and without needing additional compiler

00:26:03,980 --> 00:26:09,980
licenses so it's much better than Pippin

00:26:06,320 --> 00:26:12,140
installing from source we also use mini

00:26:09,980 --> 00:26:14,290
Condor rather than the full anaconda

00:26:12,140 --> 00:26:17,750
installer to simplify the deploy

00:26:14,290 --> 00:26:20,270
it's not a big difference either way but

00:26:17,750 --> 00:26:25,670
it does minimize the number of default

00:26:20,270 --> 00:26:28,100
install packages now while we have used

00:26:25,670 --> 00:26:30,770
Garrett and Jenkins and an internal

00:26:28,100 --> 00:26:32,030
Apache based pi PI server there isn't

00:26:30,770 --> 00:26:34,790
any reason these concepts couldn't be

00:26:32,030 --> 00:26:36,860
applied to other tools in fact as of

00:26:34,790 --> 00:26:39,770
last night one of my personal github

00:26:36,860 --> 00:26:42,110
projects now uses Travis CI to build and

00:26:39,770 --> 00:26:44,810
deploy a condor package to the anaconda

00:26:42,110 --> 00:26:46,370
cloud I haven't yet had the time to

00:26:44,810 --> 00:26:48,500
fully work out setting labels to

00:26:46,370 --> 00:26:51,500
marketers dev for dead builds and tests

00:26:48,500 --> 00:26:53,420
the test builds the fully I'll get there

00:26:51,500 --> 00:26:56,720
eventually it's all about finding time

00:26:53,420 --> 00:26:58,820
right and that's about it really

00:26:56,720 --> 00:27:00,650
that's our development lifecycle the

00:26:58,820 --> 00:27:03,290
integration of code review continuous

00:27:00,650 --> 00:27:05,840
integration development into condor

00:27:03,290 --> 00:27:18,500
environments for development testing and

00:27:05,840 --> 00:27:19,880
production thank you any questions ok

00:27:18,500 --> 00:27:27,880
thank you Andrew for your wonderful

00:27:19,880 --> 00:27:27,880
speech anybody have any questions anyone

00:27:30,010 --> 00:27:37,580
ok well then just one more thing Andrew

00:27:34,330 --> 00:27:40,580
on behalf of PyCon in Australia I would

00:27:37,580 --> 00:27:42,560
like to present you a small gift just

00:27:40,580 --> 00:27:45,370
this mug thank you so one more round of

00:27:42,560 --> 00:27:45,370
applause for Andrew

00:27:46,980 --> 00:27:55,270
okay we still have about 20 minutes left

00:27:51,400 --> 00:27:57,660
so if anybody has questions at all yeah

00:27:55,270 --> 00:28:00,430
cool

00:27:57,660 --> 00:28:02,350
so the deployment lifecycle that like

00:28:00,430 --> 00:28:04,540
sir sounds really good um how was it

00:28:02,350 --> 00:28:06,520
difficult to get it used a cross bomb or

00:28:04,540 --> 00:28:11,410
is it used across bomber just in an area

00:28:06,520 --> 00:28:13,660
it's purely within extended hydrological

00:28:11,410 --> 00:28:17,950
prediction and it's not something going

00:28:13,660 --> 00:28:21,220
on across the wider Bureau we are hoping

00:28:17,950 --> 00:28:24,100
to try and export these ideas and other

00:28:21,220 --> 00:28:25,530
areas and hopefully this pipeline

00:28:24,100 --> 00:28:27,490
presentation will help with

00:28:25,530 --> 00:28:30,970
disseminating that information and

00:28:27,490 --> 00:28:32,980
getting other people on board okay and

00:28:30,970 --> 00:28:35,860
so in bomb like what channels are there

00:28:32,980 --> 00:28:41,050
to to try and get things unified across

00:28:35,860 --> 00:28:47,500
board I'm wondering if that love to came

00:28:41,050 --> 00:28:52,510
from Bureau people I think it's a

00:28:47,500 --> 00:28:54,100
general problem yeah so we within an

00:28:52,510 --> 00:28:57,220
extender hydrological prediction we do

00:28:54,100 --> 00:29:01,470
find a little tricky because we are IT

00:28:57,220 --> 00:29:06,700
staff embedded within section doing

00:29:01,470 --> 00:29:09,460
science type work there is a central IT

00:29:06,700 --> 00:29:12,420
group communication with them can be a

00:29:09,460 --> 00:29:15,220
bit challenging at times just because

00:29:12,420 --> 00:29:17,820
the organizational structure makes it a

00:29:15,220 --> 00:29:20,170
bit difficult we do try and maintain

00:29:17,820 --> 00:29:22,240
relationships with them and we are

00:29:20,170 --> 00:29:23,620
hoping to try and improve on that in the

00:29:22,240 --> 00:29:26,820
future and it's definitely something

00:29:23,620 --> 00:29:31,600
that euro recognizes is a challenge and

00:29:26,820 --> 00:29:34,660
I'm aware that that IT division has

00:29:31,600 --> 00:29:42,210
undergone a lot of change and improve

00:29:34,660 --> 00:29:42,210
that situation yep anyone at the back

00:29:44,549 --> 00:29:52,849
I was just curious as to what you are

00:29:49,769 --> 00:30:01,559
using to do your IP I'm mirroring and

00:29:52,849 --> 00:30:04,950
internal package hosting so it's really

00:30:01,559 --> 00:30:06,899
just we download the file that we need

00:30:04,950 --> 00:30:08,580
for a particular version from pi PI and

00:30:06,899 --> 00:30:10,889
just stick it in a directory structure

00:30:08,580 --> 00:30:13,769
on the server that exposes it with

00:30:10,889 --> 00:30:19,529
Apache there's nothing too fancy in

00:30:13,769 --> 00:30:22,849
there it usually comes down to we decide

00:30:19,529 --> 00:30:25,379
we need a newer version of a package and

00:30:22,849 --> 00:30:28,049
the developers we can all just pip

00:30:25,379 --> 00:30:30,659
install from the internet so we can grab

00:30:28,049 --> 00:30:33,029
whatever version we need and then we

00:30:30,659 --> 00:30:34,799
once we've done some development

00:30:33,029 --> 00:30:37,049
certainly say oh yeah okay we we really

00:30:34,799 --> 00:30:39,239
want this package or this version of

00:30:37,049 --> 00:30:40,309
this package doing just copy it to the

00:30:39,239 --> 00:30:43,679
server

00:30:40,309 --> 00:30:49,519
so is there's nothing particularly magic

00:30:43,679 --> 00:30:51,139
in there and that it works okay any more

00:30:49,519 --> 00:31:00,119
questions

00:30:51,139 --> 00:31:03,539
yep I have two questions and the first

00:31:00,119 --> 00:31:06,209
one is how long did it take you to you

00:31:03,539 --> 00:31:11,579
and your team to implement or adopt all

00:31:06,209 --> 00:31:15,059
this cycle and the second question is if

00:31:11,579 --> 00:31:17,549
you think it scales down actually to

00:31:15,059 --> 00:31:20,909
have all these components like code

00:31:17,549 --> 00:31:23,279
review and continuous integration in

00:31:20,909 --> 00:31:26,159
particular is because in science when we

00:31:23,279 --> 00:31:28,529
write code well we have like one

00:31:26,159 --> 00:31:31,469
developer which is at the same time the

00:31:28,529 --> 00:31:35,309
user who the software so it's very nice

00:31:31,469 --> 00:31:38,700
we have all this cycle for reliability

00:31:35,309 --> 00:31:42,919
of your code but sometimes it's very

00:31:38,700 --> 00:31:47,369
time-consuming yeah but good questions

00:31:42,919 --> 00:31:51,389
so the evolution of the current state of

00:31:47,369 --> 00:31:53,399
things it's been a number of years so I

00:31:51,389 --> 00:31:55,109
said we first started using Garrett with

00:31:53,399 --> 00:31:58,060
the hydrologic reference stations

00:31:55,109 --> 00:32:01,920
project which further

00:31:58,060 --> 00:32:05,590
I went public in December of 2012 so

00:32:01,920 --> 00:32:07,210
we're probably using that mid mid 2012

00:32:05,590 --> 00:32:10,480
or something was when we first started

00:32:07,210 --> 00:32:12,220
using Garrett okay code reviews so it's

00:32:10,480 --> 00:32:17,050
been sort of four years now and that

00:32:12,220 --> 00:32:19,990
we've been using it and one like we

00:32:17,050 --> 00:32:21,700
started with Garrett and like I said he

00:32:19,990 --> 00:32:24,400
sort of went well got Garrett so that's

00:32:21,700 --> 00:32:28,020
Jenkins up to it I think we'd been using

00:32:24,400 --> 00:32:30,690
Jenkins prior to that we didn't have

00:32:28,020 --> 00:32:35,830
this sort of a ready connection between

00:32:30,690 --> 00:32:39,100
getting the two things running as for

00:32:35,830 --> 00:32:43,030
your second question of those smaller

00:32:39,100 --> 00:32:48,250
teams and things there are only really

00:32:43,030 --> 00:32:50,710
for developers in our section or three

00:32:48,250 --> 00:32:56,800
developers depending how you look at

00:32:50,710 --> 00:32:58,420
people's roles and we often end up just

00:32:56,800 --> 00:33:01,450
working on our own thing like I said we

00:32:58,420 --> 00:33:04,180
do self code reviews a lot of the time

00:33:01,450 --> 00:33:08,560
and we do try and cast an eye over other

00:33:04,180 --> 00:33:11,290
and each other's code that we have

00:33:08,560 --> 00:33:13,420
enough work going on that well we would

00:33:11,290 --> 00:33:15,340
like to be contributing to each other's

00:33:13,420 --> 00:33:17,050
projects and things we do end up

00:33:15,340 --> 00:33:22,360
spending a lot of time and just working

00:33:17,050 --> 00:33:29,020
on our own thing and reviewing our in

00:33:22,360 --> 00:33:34,560
code and it works for us okay anybody

00:33:29,020 --> 00:33:34,560
else go right to the back first

00:33:36,520 --> 00:33:42,110
hey I've got a couple of questions one I

00:33:39,590 --> 00:33:45,830
noticed in your project template you

00:33:42,110 --> 00:33:48,770
don't include a tox penny file so I'd

00:33:45,830 --> 00:33:51,410
like to ask understand why you didn't

00:33:48,770 --> 00:33:54,110
include that and the second question is

00:33:51,410 --> 00:33:56,870
how do you handle the situation where

00:33:54,110 --> 00:33:58,760
one of your applications sorry let's

00:33:56,870 --> 00:34:00,320
take a step back you're manually pulling

00:33:58,760 --> 00:34:01,640
stuff from pi pi as you think it's

00:34:00,320 --> 00:34:03,830
appropriate how do you handle situations

00:34:01,640 --> 00:34:04,790
where an application doesn't work well

00:34:03,830 --> 00:34:07,070
with the new version

00:34:04,790 --> 00:34:08,690
do you forcefully bring that application

00:34:07,070 --> 00:34:16,150
up to date or do you handle multiple

00:34:08,690 --> 00:34:19,480
versions of a requirement in terms of

00:34:16,150 --> 00:34:25,670
multiple versions or requirements

00:34:19,480 --> 00:34:29,210
we we are aiming towards just getting

00:34:25,670 --> 00:34:32,480
everything up to date the big one that

00:34:29,210 --> 00:34:34,520
we're finding is pandas I don't know how

00:34:32,480 --> 00:34:37,400
many people have been using pandas but

00:34:34,520 --> 00:34:43,960
you'll find that between versions

00:34:37,400 --> 00:34:46,130
there's often breaking changes and yeah

00:34:43,960 --> 00:34:48,740
the amount of packages we're supporting

00:34:46,130 --> 00:34:50,480
has increased in recent years but for

00:34:48,740 --> 00:34:56,240
the most part we just we have just aimed

00:34:50,480 --> 00:34:57,890
to push for including changes to all of

00:34:56,240 --> 00:35:01,070
our packages to work with the latest

00:34:57,890 --> 00:35:03,020
version of everything and said that

00:35:01,070 --> 00:35:05,240
we've only really been doing this style

00:35:03,020 --> 00:35:07,820
for a year we haven't had any major

00:35:05,240 --> 00:35:10,340
problems with it so far but we might

00:35:07,820 --> 00:35:14,180
find issues down the track as for talks

00:35:10,340 --> 00:35:16,730
I personally have looked into it a bit

00:35:14,180 --> 00:35:18,350
but didn't quite get my head around it

00:35:16,730 --> 00:35:21,140
well enough to make a decision about

00:35:18,350 --> 00:35:22,400
using it it's it's something that I look

00:35:21,140 --> 00:35:25,850
at every now and then think yeah I

00:35:22,400 --> 00:35:27,200
should get into that a bit more that is

00:35:25,850 --> 00:35:28,550
yeah just something we have been

00:35:27,200 --> 00:35:32,950
investigated fully and that's why it

00:35:28,550 --> 00:35:32,950
hasn't gone into how we're doing things

00:35:34,900 --> 00:35:40,010
hi Andrew I'm sorry if you've already

00:35:38,270 --> 00:35:42,470
answered this and I wasn't paying enough

00:35:40,010 --> 00:35:45,020
attention just wondering if there's any

00:35:42,470 --> 00:35:47,060
automated peb eight sort of check or

00:35:45,020 --> 00:35:48,740
code quality check that you could that

00:35:47,060 --> 00:35:49,310
you aren't if you aren't already using

00:35:48,740 --> 00:35:51,290
it

00:35:49,310 --> 00:35:53,150
could be plugged in so that you can say

00:35:51,290 --> 00:35:55,190
that as like a first step for a code

00:35:53,150 --> 00:35:58,100
review that you get some indication of

00:35:55,190 --> 00:36:00,020
this needs more documentation or yeah

00:35:58,100 --> 00:36:04,670
the you know functions aren't named

00:36:00,020 --> 00:36:06,980
according to us standard yeah so it was

00:36:04,670 --> 00:36:09,880
a very very brief section on one of the

00:36:06,980 --> 00:36:14,780
slides pilant is what we've been using

00:36:09,880 --> 00:36:18,050
we get PI link coverage so whenever the

00:36:14,780 --> 00:36:20,990
unit tests get run we run pilant as well

00:36:18,050 --> 00:36:25,100
that gives us an indication on whether

00:36:20,990 --> 00:36:28,910
we've got violations or not we have had

00:36:25,100 --> 00:36:31,550
Jenkins setup at times to vote minus 1

00:36:28,910 --> 00:36:34,790
if pilant violations get worse rather

00:36:31,550 --> 00:36:37,100
than better but we do have a lot of

00:36:34,790 --> 00:36:41,060
legacy code and that got a little bit

00:36:37,100 --> 00:36:43,040
onerous to deal with so we do have the

00:36:41,060 --> 00:36:44,660
PI linting there and but we've perhaps

00:36:43,040 --> 00:36:49,730
not adhering to it quite as well as we

00:36:44,660 --> 00:36:56,930
should just because of legacy code ok

00:36:49,730 --> 00:36:59,350
any more no okay thank you Andrew that's

00:36:56,930 --> 00:36:59,350

YouTube URL: https://www.youtube.com/watch?v=-I-xFCBL8n8


