Title: Pyrobuf and the Tyranny of Speed
Publication date: 2016-08-15
Playlist: Pycon Australia 2016
Description: 
	Gregory Saunders
https://2016.pycon-au.org/schedule/171/view_talk
The data structures used to represent information and program state in memory are rarely conducive to the storage and transmission of that information and state. The process of translating those data structures into a format better suited to storage is known as serialisation or marshalling.

Google’s Protobuf is a mechanism for serialising and deserialising structured data. Pyrobuf is a alternative, lightning-fast, implementation of Protobuf written in Cython that is 2-4 times faster than Protobuf when using its C++ backend and 20-40 times faster than its pure Python implementation.

In this talk we’ll briefly review Protobuf and compare it to other well known serialisation mechanisms such as XML and JSON. We’ll then take a look at Pyrobuf and the basic strategies it uses to achieve significantly better performance.

Pyrobuf’s main claim to fame is its speed. This makes fixing bugs and adding new features a real challenge as any degradation in performance will not be well-received by users who’ve come to expect and rely on its speed. Therefore, for the remainder of the talk we’ll discuss tricks and tips, some more legitimate than others, for maintaining speed as new features are added.
Captions: 
	00:00:00,230 --> 00:00:06,560
um I think it's time to start the second

00:00:03,149 --> 00:00:08,940
talk so next up we've got brewery

00:00:06,560 --> 00:00:14,000
Saunders who is going to be presenting

00:00:08,940 --> 00:00:17,490
on para off and the tyranny of speed and

00:00:14,000 --> 00:00:20,820
he's been programming in Python since

00:00:17,490 --> 00:00:22,980
1995 he has a PhD in computer science

00:00:20,820 --> 00:00:25,740
and has been working in a financial

00:00:22,980 --> 00:00:29,429
services industry for over 10 years he

00:00:25,740 --> 00:00:33,619
is currently a Python developer octavo

00:00:29,429 --> 00:00:33,619
can we please give a warm welcome to

00:00:37,520 --> 00:00:43,469
thank you good to see so many people

00:00:39,989 --> 00:00:46,739
obviously a the drawer of a impressive

00:00:43,469 --> 00:00:49,829
sounding speaked title pyro tyranny

00:00:46,739 --> 00:00:52,010
speed if you're going to do a hike on

00:00:49,829 --> 00:00:54,360
presentation next year remember that a

00:00:52,010 --> 00:00:57,960
little bit about me as already mentioned

00:00:54,360 --> 00:00:59,039
i started working in python in 1995 in

00:00:57,960 --> 00:01:03,170
case you couldn't guess that I'm really

00:00:59,039 --> 00:01:05,640
old that was version 1.2 back then well

00:01:03,170 --> 00:01:08,510
I've worked in financial services since

00:01:05,640 --> 00:01:11,790
2003 and i'm currently at optiv our plug

00:01:08,510 --> 00:01:13,710
plug there's some some optimum people in

00:01:11,790 --> 00:01:16,830
the back row there hopefully they went

00:01:13,710 --> 00:01:19,770
heckle me too much but yes octave our

00:01:16,830 --> 00:01:23,040
best places to work you know check it

00:01:19,770 --> 00:01:25,710
out all right so quick outline of my

00:01:23,040 --> 00:01:27,689
talk what's the problem we're trying to

00:01:25,710 --> 00:01:30,150
solve that's always a good thing to

00:01:27,689 --> 00:01:32,759
understand what's Prada buff and why

00:01:30,150 --> 00:01:34,860
would I use that what's pi rebuff and

00:01:32,759 --> 00:01:37,829
why would I use that then we'll talk

00:01:34,860 --> 00:01:39,180
about the tyranny of speed and finally

00:01:37,829 --> 00:01:42,030
some strategies for improving

00:01:39,180 --> 00:01:43,710
performance some of which are a little

00:01:42,030 --> 00:01:47,970
more legitimate than others I'll let you

00:01:43,710 --> 00:01:50,850
decide which is which so what's the

00:01:47,970 --> 00:01:53,549
problem so programs use data structures

00:01:50,850 --> 00:01:55,590
to represent information in memory but

00:01:53,549 --> 00:01:58,700
those data structures usually aren't

00:01:55,590 --> 00:02:00,960
conducive to storing that information or

00:01:58,700 --> 00:02:05,070
transmitting it over for example a

00:02:00,960 --> 00:02:07,079
network so we have a need for something

00:02:05,070 --> 00:02:10,890
called serialization it's also called

00:02:07,079 --> 00:02:11,950
marshalling to to convert our data from

00:02:10,890 --> 00:02:15,129
the in-memory

00:02:11,950 --> 00:02:16,540
a format the into a form it's more

00:02:15,129 --> 00:02:20,200
suitable for storing on desk or

00:02:16,540 --> 00:02:23,709
transmitting over network etc etc so

00:02:20,200 --> 00:02:26,349
ideally many serialization strategy we

00:02:23,709 --> 00:02:28,750
use it's going to be compact and fast

00:02:26,349 --> 00:02:30,370
obviously it's going to support

00:02:28,750 --> 00:02:33,489
validation we want to make sure that the

00:02:30,370 --> 00:02:36,550
data is actually correct and complete

00:02:33,489 --> 00:02:38,349
and of course and it will be backwards

00:02:36,550 --> 00:02:41,799
and forwards compatible what that means

00:02:38,349 --> 00:02:43,239
is that if I've got a message produced

00:02:41,799 --> 00:02:44,650
with an older version of my software I

00:02:43,239 --> 00:02:46,959
can still read it with a newer version

00:02:44,650 --> 00:02:49,840
and if I've got a version produced with

00:02:46,959 --> 00:02:53,019
a newer version of the software the

00:02:49,840 --> 00:02:55,810
older version can at least still use the

00:02:53,019 --> 00:03:00,880
bits are that were present in the older

00:02:55,810 --> 00:03:03,489
version of the message okay so how can

00:03:00,880 --> 00:03:06,069
we solve this problem well anyone who is

00:03:03,489 --> 00:03:12,099
at the iot mini conf on friday will know

00:03:06,069 --> 00:03:14,380
the answer use a Kalman filter if you

00:03:12,099 --> 00:03:15,730
don't understand check out Lachlan black

00:03:14,380 --> 00:03:17,650
holes excellent working with real-time

00:03:15,730 --> 00:03:20,590
data streams in Python presentation from

00:03:17,650 --> 00:03:22,000
Friday's IOT mini conf now if you can't

00:03:20,590 --> 00:03:26,730
use a Kalman filter to solve this

00:03:22,000 --> 00:03:29,079
problem what else can we do well to hit

00:03:26,730 --> 00:03:33,040
yes just keep adding Kalman filters

00:03:29,079 --> 00:03:34,239
until this problem is solved okay so you

00:03:33,040 --> 00:03:37,150
might think we've solved this problem

00:03:34,239 --> 00:03:39,880
already I mean we've got XML we've got

00:03:37,150 --> 00:03:43,540
JSON we've got pickle you know why can't

00:03:39,880 --> 00:03:45,579
we just use one of those so XML and

00:03:43,540 --> 00:03:47,260
Jason have some interesting advantages

00:03:45,579 --> 00:03:50,139
there human readable and editable you

00:03:47,260 --> 00:03:53,019
can fire it up in VI and and mess around

00:03:50,139 --> 00:03:55,690
with it it they support validation so

00:03:53,019 --> 00:03:57,790
XML dt DS or json schema you can use to

00:03:55,690 --> 00:04:00,690
validate your data but they're not

00:03:57,790 --> 00:04:03,940
terribly compact it's being text forms

00:04:00,690 --> 00:04:06,970
they're significantly slower than binary

00:04:03,940 --> 00:04:09,489
formats and the XML API is at least in

00:04:06,970 --> 00:04:14,109
my experience tend to be complicated and

00:04:09,489 --> 00:04:16,690
unwieldy what about pickle pickle is is

00:04:14,109 --> 00:04:18,760
a binary format not text at least for

00:04:16,690 --> 00:04:20,859
protocol version greater than zero but

00:04:18,760 --> 00:04:24,430
it's Python specific and you need to

00:04:20,859 --> 00:04:25,960
roll your own validation so what can we

00:04:24,430 --> 00:04:31,400
do

00:04:25,960 --> 00:04:33,050
enter protobuf what is protobuf so

00:04:31,400 --> 00:04:34,639
protobuf ashore for protocol buffers

00:04:33,050 --> 00:04:36,260
there are flexible efficient automated

00:04:34,639 --> 00:04:41,840
mechanism for serializing structured

00:04:36,260 --> 00:04:43,550
data written by google so basically the

00:04:41,840 --> 00:04:46,370
way that it works is you first define

00:04:43,550 --> 00:04:48,080
the structure of your data in a dot

00:04:46,370 --> 00:04:51,320
proto file or give you an example in a

00:04:48,080 --> 00:04:53,960
second you compile the dot proto file to

00:04:51,320 --> 00:04:57,560
generate a language specific data access

00:04:53,960 --> 00:04:59,419
us or classes Google's compiler supports

00:04:57,560 --> 00:05:01,940
all those languages and there's

00:04:59,419 --> 00:05:04,190
third-party support for other languages

00:05:01,940 --> 00:05:08,210
as well you can find out that by using

00:05:04,190 --> 00:05:11,360
google anyway so what does a profile

00:05:08,210 --> 00:05:13,700
look like here's here's an example from

00:05:11,360 --> 00:05:16,040
the protobuf documentation we have a

00:05:13,700 --> 00:05:18,260
person message you can see that the

00:05:16,040 --> 00:05:19,669
attributes of the the person some of

00:05:18,260 --> 00:05:22,810
them are required some of them are

00:05:19,669 --> 00:05:26,570
optional you could have enumerated types

00:05:22,810 --> 00:05:30,890
you can have sub messages and you can

00:05:26,570 --> 00:05:33,440
have repeated so elements which are

00:05:30,890 --> 00:05:34,780
obviously more than one this is a person

00:05:33,440 --> 00:05:37,880
can have more than one phone number

00:05:34,780 --> 00:05:41,510
you'll notice also that each element has

00:05:37,880 --> 00:05:44,810
a tag number those tag numbers identify

00:05:41,510 --> 00:05:46,250
that element in the serialized form and

00:05:44,810 --> 00:05:48,169
they're useful because they help with

00:05:46,250 --> 00:05:49,970
the other backwards and compatibility as

00:05:48,169 --> 00:05:51,460
well as we'll see in a moment you can

00:05:49,970 --> 00:05:57,020
also have default values for

00:05:51,460 --> 00:05:58,880
four-year-olds so pretty cool so if

00:05:57,020 --> 00:06:02,300
you're using Python when you compile

00:05:58,880 --> 00:06:05,000
your address book proto file what you

00:06:02,300 --> 00:06:08,510
get is an address book underscore PB 2

00:06:05,000 --> 00:06:10,400
pi file which again had import and then

00:06:08,510 --> 00:06:14,000
you can use code like you see on the

00:06:10,400 --> 00:06:18,820
screen to create a person object set the

00:06:14,000 --> 00:06:22,340
various fields to their values and then

00:06:18,820 --> 00:06:25,720
once you've done that the person object

00:06:22,340 --> 00:06:28,310
will have it's a message it will have

00:06:25,720 --> 00:06:30,680
methods like this so is initialized will

00:06:28,310 --> 00:06:32,210
tell you if it is in fact correctly

00:06:30,680 --> 00:06:35,419
initialized so if all the required

00:06:32,210 --> 00:06:37,220
fields are set serialize the string is

00:06:35,419 --> 00:06:38,700
going to return a binary string a

00:06:37,220 --> 00:06:40,650
serialized form

00:06:38,700 --> 00:06:42,210
hopefully compact and suitable for

00:06:40,650 --> 00:06:44,400
storage on disk or transmitting over

00:06:42,210 --> 00:06:50,100
network and path from string does the

00:06:44,400 --> 00:06:51,270
inverse okay all right so how does

00:06:50,100 --> 00:06:53,610
backwards and forwards compatibility

00:06:51,270 --> 00:06:55,440
work basically you can take an existing

00:06:53,610 --> 00:06:57,000
message you know in a dot proto file and

00:06:55,440 --> 00:07:00,480
you can update it and as long as you

00:06:57,000 --> 00:07:02,100
follow certain rules then that message

00:07:00,480 --> 00:07:04,500
will still be compatible with older

00:07:02,100 --> 00:07:06,780
versions of your software and with newer

00:07:04,500 --> 00:07:08,820
versions of your software and the basic

00:07:06,780 --> 00:07:12,770
rules are don't change the numeric tags

00:07:08,820 --> 00:07:15,930
once a field has a tag don't change it

00:07:12,770 --> 00:07:17,760
you can add optional and repeated fields

00:07:15,930 --> 00:07:19,740
but you can't add new required fields

00:07:17,760 --> 00:07:22,380
obviously that would break backward

00:07:19,740 --> 00:07:26,460
compatibility you can remove non

00:07:22,380 --> 00:07:29,160
required fields and if a message that

00:07:26,460 --> 00:07:30,810
you have has a value for a non required

00:07:29,160 --> 00:07:35,250
field the newer version of the software

00:07:30,810 --> 00:07:38,250
would just ignore it and as I said don't

00:07:35,250 --> 00:07:39,330
reuse tag numbers because otherwise the

00:07:38,250 --> 00:07:41,940
newer version of the software will get

00:07:39,330 --> 00:07:46,080
confused by an older version of your

00:07:41,940 --> 00:07:48,600
message okay so sounds pretty cool right

00:07:46,080 --> 00:07:50,910
what could possibly go wrong well the

00:07:48,600 --> 00:07:56,010
problem is that it's a little bit slow

00:07:50,910 --> 00:07:59,640
so what's horrible apart from being a

00:07:56,010 --> 00:08:01,620
pyromaniac sir dream pyro buff is an

00:07:59,640 --> 00:08:04,290
alternative to Google's Python protobuf

00:08:01,620 --> 00:08:06,900
library lightning-fast siphoned code two

00:08:04,290 --> 00:08:09,180
to four times faster home hang on we

00:08:06,900 --> 00:08:12,120
better check that 24 times faster than

00:08:09,180 --> 00:08:14,250
Google's using their C++ back and a 20

00:08:12,120 --> 00:08:18,800
to 40 times faster than Google's pure

00:08:14,250 --> 00:08:18,800
python implementation sounds impressive

00:08:18,920 --> 00:08:25,460
so power buff was actually originally

00:08:22,260 --> 00:08:28,800
written by the nice people at apt Nexus

00:08:25,460 --> 00:08:31,080
it's open source on github feel free to

00:08:28,800 --> 00:08:33,420
go there and check it out we especially

00:08:31,080 --> 00:08:36,750
appreciate pull requests ninja nudge

00:08:33,420 --> 00:08:39,450
nudge it works with Python 2.7 and

00:08:36,750 --> 00:08:42,479
Python 3.5 and it implements most of the

00:08:39,450 --> 00:08:43,830
proto buff message API so in case you're

00:08:42,479 --> 00:08:45,620
not familiar probe off actually pro both

00:08:43,830 --> 00:08:49,050
had some other stuff in it like our PC

00:08:45,620 --> 00:08:50,310
which horror buff does not implement but

00:08:49,050 --> 00:08:52,200
for the stuff we're talking about today

00:08:50,310 --> 00:08:57,210
it influenced most of that

00:08:52,200 --> 00:09:00,210
above message a PLA installation is easy

00:08:57,210 --> 00:09:02,910
pip install it does require that you

00:09:00,210 --> 00:09:05,220
have siphon and that means you need a C

00:09:02,910 --> 00:09:10,290
compiler that can be a little bit of a

00:09:05,220 --> 00:09:12,270
hassle especially on Windows but if

00:09:10,290 --> 00:09:15,720
you've got that then yeah just peep it

00:09:12,270 --> 00:09:20,330
though and away you go it comes with its

00:09:15,720 --> 00:09:24,510
own special compiler of profiles

00:09:20,330 --> 00:09:27,000
originally called parlor floor yeah so

00:09:24,510 --> 00:09:30,600
you just prob off your profile and it

00:09:27,000 --> 00:09:32,940
generates a module called file a minute

00:09:30,600 --> 00:09:35,310
scored a proto underscore proto so or

00:09:32,940 --> 00:09:37,800
book pido dll depending on your platform

00:09:35,310 --> 00:09:40,920
and you can just import that into python

00:09:37,800 --> 00:09:44,310
and start using it and it's faster we'll

00:09:40,920 --> 00:09:46,650
see how much faster in a minute okay so

00:09:44,310 --> 00:09:49,770
let's switch tack now I want to talk

00:09:46,650 --> 00:09:54,570
about the tyranny of speed what do I

00:09:49,770 --> 00:09:58,380
mean by that so Paribas big stick is

00:09:54,570 --> 00:10:01,140
that it is fast it'sit's reason for

00:09:58,380 --> 00:10:02,880
existing it doesn't in fact implement

00:10:01,140 --> 00:10:05,190
the full prototype message API as I said

00:10:02,880 --> 00:10:06,270
a minute ago it doesn't do RPC doesn't

00:10:05,190 --> 00:10:09,690
have some of the other features of

00:10:06,270 --> 00:10:13,110
protobuf so it's reason for being is

00:10:09,690 --> 00:10:15,930
that it's fast and so if you do what I

00:10:13,110 --> 00:10:18,510
did and try to make some bug fixes or

00:10:15,930 --> 00:10:21,660
add some features and your change is

00:10:18,510 --> 00:10:24,300
negatively impact performance people

00:10:21,660 --> 00:10:28,550
don't like that they get they get upset

00:10:24,300 --> 00:10:31,740
at you did anyone see Disney's Aladdin

00:10:28,550 --> 00:10:34,860
movably many of you seen that movie as a

00:10:31,740 --> 00:10:36,720
great quote from that movie yago the

00:10:34,860 --> 00:10:38,670
other bird says with all due respect

00:10:36,720 --> 00:10:41,610
your rottenness couldn't we just wait

00:10:38,670 --> 00:10:45,180
for a real storm Jafar the evil wizard

00:10:41,610 --> 00:10:49,620
says save your breath yah go faster and

00:10:45,180 --> 00:10:55,380
Iago says yes so mighty evil one that's

00:10:49,620 --> 00:10:58,380
how it feels sometimes ya just as an

00:10:55,380 --> 00:10:59,490
aside imposter syndrome that's the

00:10:58,380 --> 00:11:01,260
feeling you get when you're a developer

00:10:59,490 --> 00:11:02,970
in an interpreted language in a company

00:11:01,260 --> 00:11:05,160
which prides itself on its extremely

00:11:02,970 --> 00:11:10,740
high performance low latency c-class

00:11:05,160 --> 00:11:12,660
scope and if you want to know more about

00:11:10,740 --> 00:11:14,490
that see Bianca Gibson's enlightening

00:11:12,660 --> 00:11:18,360
impostor syndrome presentation from

00:11:14,490 --> 00:11:20,490
yesterday moving on okay so general

00:11:18,360 --> 00:11:22,139
advice on optimizing your code how can

00:11:20,490 --> 00:11:24,300
we make our code faster well hopefully

00:11:22,139 --> 00:11:25,860
you've all seen this before choose your

00:11:24,300 --> 00:11:27,689
algorithms and your destructors

00:11:25,860 --> 00:11:31,110
carefully that's the most important

00:11:27,689 --> 00:11:33,000
thing to make your code work well once

00:11:31,110 --> 00:11:35,069
you've done that you go through this

00:11:33,000 --> 00:11:37,620
loop write some code test it make sure

00:11:35,069 --> 00:11:40,800
it works profile it find the bits that

00:11:37,620 --> 00:11:42,660
are really important optimize those and

00:11:40,800 --> 00:11:48,149
go back to two don't go back two three

00:11:42,660 --> 00:11:50,970
go back to two okay now in most cases

00:11:48,149 --> 00:11:54,600
that's enough but sometimes it's not so

00:11:50,970 --> 00:11:57,600
enter scythe on anyone use scythe on I

00:11:54,600 --> 00:11:59,029
don't know awesome very nice so what's

00:11:57,600 --> 00:12:02,129
scythe on for those of you don't know

00:11:59,029 --> 00:12:05,370
basically it helps you improve the the

00:12:02,129 --> 00:12:08,189
speed of your code by basically taking

00:12:05,370 --> 00:12:10,319
the advice of the song code in C right

00:12:08,189 --> 00:12:13,529
syntax is quite similar to python but it

00:12:10,319 --> 00:12:16,500
gets translated into C and compile into

00:12:13,529 --> 00:12:18,149
object code and you can you can make a

00:12:16,500 --> 00:12:20,370
very small number of changes to your

00:12:18,149 --> 00:12:22,769
code sometimes none at all and just

00:12:20,370 --> 00:12:25,500
compile it with siphon and that can give

00:12:22,769 --> 00:12:28,259
you a performance boost just by itself

00:12:25,500 --> 00:12:34,250
but if you are if you move ahead and

00:12:28,259 --> 00:12:36,930
actually give your variables types then

00:12:34,250 --> 00:12:39,769
basically you can bypass all the type

00:12:36,930 --> 00:12:42,149
checking that Python does by default

00:12:39,769 --> 00:12:45,389
because it can just assume that the

00:12:42,149 --> 00:12:47,059
value has at a certain time right so so

00:12:45,389 --> 00:12:49,880
that can improve the performance again

00:12:47,059 --> 00:12:52,649
just by adding type information to your

00:12:49,880 --> 00:12:56,850
method declarations and your variable

00:12:52,649 --> 00:12:58,740
declarations now so what you would do of

00:12:56,850 --> 00:13:00,509
course is you would basically take the

00:12:58,740 --> 00:13:03,120
the common code the performance critical

00:13:00,509 --> 00:13:05,790
code of your your application you would

00:13:03,120 --> 00:13:08,189
put that into siphon perhaps rewrite a

00:13:05,790 --> 00:13:11,069
bit of it to make it even pasta and and

00:13:08,189 --> 00:13:13,589
distribute that well Piper buff actually

00:13:11,069 --> 00:13:17,100
goes one step further than that it

00:13:13,589 --> 00:13:18,170
actually generates a customized psyphon

00:13:17,100 --> 00:13:21,410
module

00:13:18,170 --> 00:13:23,029
each individual dot proto file so it's

00:13:21,410 --> 00:13:24,829
not just factoring out the common code

00:13:23,029 --> 00:13:26,750
and putting that inside then it's

00:13:24,829 --> 00:13:30,079
basically factoring out everything and

00:13:26,750 --> 00:13:34,040
putting that into siphon and so that's

00:13:30,079 --> 00:13:37,630
how it gets its impressive speed still

00:13:34,040 --> 00:13:41,110
if you're if you're making bug fixes or

00:13:37,630 --> 00:13:44,060
feature enhancements you might need to

00:13:41,110 --> 00:13:46,190
especially if you you know needing to

00:13:44,060 --> 00:13:48,019
keep the performance up to avoid the ire

00:13:46,190 --> 00:13:50,089
of your users you might need some

00:13:48,019 --> 00:13:51,889
strategies for improving performance

00:13:50,089 --> 00:13:54,019
that's what I'd like to talk about next

00:13:51,889 --> 00:13:55,279
as I said before some of these are going

00:13:54,019 --> 00:14:00,380
to be a little more legitimate than

00:13:55,279 --> 00:14:03,320
others so I'll let you decide what which

00:14:00,380 --> 00:14:06,440
ones are which so first things first oh

00:14:03,320 --> 00:14:07,730
you do need to measure you you can't

00:14:06,440 --> 00:14:10,820
know whether you're actually improving

00:14:07,730 --> 00:14:12,649
performance unless you measure it so

00:14:10,820 --> 00:14:14,750
prob of you uses pie test for its

00:14:12,649 --> 00:14:16,699
testing and pie test this is PI test

00:14:14,750 --> 00:14:18,860
dash benchmark modules anyone used it

00:14:16,699 --> 00:14:21,230
quite a spin CH mark no oh good one or

00:14:18,860 --> 00:14:22,820
two that basically allows you to

00:14:21,230 --> 00:14:26,029
benchmark your code in the tests and

00:14:22,820 --> 00:14:27,500
work out how fast it is and and then you

00:14:26,029 --> 00:14:30,050
can obviously tell whether your code is

00:14:27,500 --> 00:14:33,470
getting faster or slower um so how do

00:14:30,050 --> 00:14:36,050
you use part s benchmark here's a unit

00:14:33,470 --> 00:14:38,720
test we just decorated with this pi test

00:14:36,050 --> 00:14:40,130
mark todd benchmark think i don't know

00:14:38,720 --> 00:14:43,640
if that was implemented using wrapped I

00:14:40,130 --> 00:14:46,399
suspect not so hopefully we can fix that

00:14:43,640 --> 00:14:49,250
later veneer so you just wrap it in that

00:14:46,399 --> 00:14:50,690
benchmark decorator I've set the warm-up

00:14:49,250 --> 00:14:52,810
equal to true so what it means is it's

00:14:50,690 --> 00:14:55,100
going to run it a few times to make sure

00:14:52,810 --> 00:14:57,440
there's no issues with the

00:14:55,100 --> 00:14:59,630
initialization or whatever before it

00:14:57,440 --> 00:15:01,970
actually measures the performance and

00:14:59,630 --> 00:15:05,120
then you basically you give it something

00:15:01,970 --> 00:15:06,500
to benchmark so in this case we're

00:15:05,120 --> 00:15:09,140
creating a message we're getting the

00:15:06,500 --> 00:15:11,750
serialized form of that message and then

00:15:09,140 --> 00:15:14,899
we're what we're benchmarking is the

00:15:11,750 --> 00:15:17,269
path from string method okay we're just

00:15:14,899 --> 00:15:18,889
measuring how fast it is and what part s

00:15:17,269 --> 00:15:20,240
benchmark does is basically runs at a

00:15:18,889 --> 00:15:23,000
bunch of times it's got a time limit

00:15:20,240 --> 00:15:25,670
which from memory by default is one

00:15:23,000 --> 00:15:28,399
second but you can change that obviously

00:15:25,670 --> 00:15:31,490
and it runs it a bunch of times and it

00:15:28,399 --> 00:15:31,970
tells you how fast it was it gives you

00:15:31,490 --> 00:15:34,040
output

00:15:31,970 --> 00:15:35,689
that it's actually text output but so it

00:15:34,040 --> 00:15:38,209
doesn't look quite this nice but this is

00:15:35,689 --> 00:15:41,569
basically what it looks like and you can

00:15:38,209 --> 00:15:46,160
see here what it's saying is that the

00:15:41,569 --> 00:15:49,269
method in microseconds took a minimum of

00:15:46,160 --> 00:15:52,759
30 point 16 micro second point 17 sorry

00:15:49,269 --> 00:15:54,860
micros maximum of 287 which is quite a

00:15:52,759 --> 00:15:58,370
lot this was done on on windows so that

00:15:54,860 --> 00:16:01,490
can explain that a mean of three point

00:15:58,370 --> 00:16:03,350
six nine standard deviation 1.28 median

00:16:01,490 --> 00:16:05,180
3.62 and I need to call to our range of

00:16:03,350 --> 00:16:07,819
point 15 and Google's Prater buff is

00:16:05,180 --> 00:16:11,569
there as you can see Google's Prada buff

00:16:07,819 --> 00:16:13,430
is a lot slower that's the software

00:16:11,569 --> 00:16:20,360
implementation the Python implementation

00:16:13,430 --> 00:16:22,339
of groups protobuf there okay so we've

00:16:20,360 --> 00:16:24,410
got our benchmarking we can measure our

00:16:22,339 --> 00:16:26,660
performance we've written our code in

00:16:24,410 --> 00:16:29,300
size and how can we make it go a little

00:16:26,660 --> 00:16:32,029
bit faster so here's one thing that I

00:16:29,300 --> 00:16:33,649
did it's called scythe on fire fast

00:16:32,029 --> 00:16:37,059
instantiation buried in the

00:16:33,649 --> 00:16:40,279
documentation forsyth on basically when

00:16:37,059 --> 00:16:42,769
para buffin instantiated new messages or

00:16:40,279 --> 00:16:45,740
sub messages it used the traditional

00:16:42,769 --> 00:16:49,519
class constructor that looks like that

00:16:45,740 --> 00:16:52,069
clasp racket racket and if you know that

00:16:49,519 --> 00:16:56,420
you don't need what's in the init method

00:16:52,069 --> 00:16:59,449
right you can actually bypass that right

00:16:56,420 --> 00:17:02,779
and so you can use class time scholars

00:16:59,449 --> 00:17:04,459
cornu on the squad squad and that will

00:17:02,779 --> 00:17:07,220
create the object without calling it in

00:17:04,459 --> 00:17:08,360
it now of course if unit does anything

00:17:07,220 --> 00:17:10,760
useful you're gonna have to do that

00:17:08,360 --> 00:17:13,880
yourself but if you know it doesn't do

00:17:10,760 --> 00:17:16,189
anything useful that I did then you can

00:17:13,880 --> 00:17:18,589
just bypass that entirely and this

00:17:16,189 --> 00:17:21,799
actually improved the past performance

00:17:18,589 --> 00:17:25,760
by about eight percent so that's one

00:17:21,799 --> 00:17:28,059
strategy that you can use to improve

00:17:25,760 --> 00:17:32,000
your form tears what the code looks like

00:17:28,059 --> 00:17:34,370
so initially the top it looked like what

00:17:32,000 --> 00:17:37,429
we have at the top so the list field was

00:17:34,370 --> 00:17:39,740
implemented by constructing the n64 this

00:17:37,429 --> 00:17:42,770
class the substrate field was the test

00:17:39,740 --> 00:17:45,660
SS one class and you change that to

00:17:42,770 --> 00:17:47,040
underscore underscore new and call

00:17:45,660 --> 00:17:51,720
the reset method which gets called

00:17:47,040 --> 00:17:54,780
anyway so there's no performance benefit

00:17:51,720 --> 00:17:57,330
from not calling it and that improved

00:17:54,780 --> 00:18:00,140
the performance right there so that's

00:17:57,330 --> 00:18:02,750
one idea for improving performance

00:18:00,140 --> 00:18:07,320
another one that worked reasonably well

00:18:02,750 --> 00:18:10,440
avoid unnecessary slicing so prior buff

00:18:07,320 --> 00:18:13,640
when it DC realizes sub message it

00:18:10,440 --> 00:18:16,230
actually takes the the string of data

00:18:13,640 --> 00:18:18,470
gets a substring of it and passes that

00:18:16,230 --> 00:18:24,120
recursively into the DC realized method

00:18:18,470 --> 00:18:27,180
to deserialize the sub message now of

00:18:24,120 --> 00:18:32,310
course you don't need to do that right

00:18:27,180 --> 00:18:34,080
you don't need to create a slice of the

00:18:32,310 --> 00:18:38,610
string you can just pass in the string

00:18:34,080 --> 00:18:42,150
with an offset and just by doing that we

00:18:38,610 --> 00:18:46,590
saved about nine but I'm so that's

00:18:42,150 --> 00:18:51,210
something else you can try bypass

00:18:46,590 --> 00:18:52,890
unnecessary guard code so here this is

00:18:51,210 --> 00:18:54,540
the append method so if you've got a

00:18:52,890 --> 00:18:56,520
repeated field you can append a new

00:18:54,540 --> 00:18:58,260
value to the repeated field and the

00:18:56,520 --> 00:19:00,570
append method look like that firstly it

00:18:58,260 --> 00:19:01,650
checks to make sure that the value

00:19:00,570 --> 00:19:04,050
you're trying to upend is of the

00:19:01,650 --> 00:19:07,530
appropriate type and if it's not it

00:19:04,050 --> 00:19:09,360
raises an exception and then it calls

00:19:07,530 --> 00:19:12,390
the superclass as a pen method to append

00:19:09,360 --> 00:19:16,670
the value now the list is a subclass of

00:19:12,390 --> 00:19:19,980
pythons list class right so when I'm

00:19:16,670 --> 00:19:22,620
deserializing a string I've got a value

00:19:19,980 --> 00:19:25,200
I know it's the correct type already I

00:19:22,620 --> 00:19:27,900
don't need to check that so what I can

00:19:25,200 --> 00:19:30,120
do is I can just say all right call the

00:19:27,900 --> 00:19:33,720
list dot append method with my list and

00:19:30,120 --> 00:19:36,270
the value X and that bypasses the the

00:19:33,720 --> 00:19:38,160
type checking but it only improved

00:19:36,270 --> 00:19:41,220
performance by about one or two percent

00:19:38,160 --> 00:19:47,280
which I thought was some interesting

00:19:41,220 --> 00:19:50,160
given the slowness of pythons exceptions

00:19:47,280 --> 00:19:54,140
but anyway so that was a few a few

00:19:50,160 --> 00:19:56,039
methods there any other options so uh

00:19:54,140 --> 00:19:58,509
hmm

00:19:56,039 --> 00:20:01,330
so the results now I've been showing you

00:19:58,509 --> 00:20:04,029
so far were produced with Python zero

00:20:01,330 --> 00:20:05,950
with Bobo serrated 0.5 point for we're

00:20:04,029 --> 00:20:07,749
currently up to 0.5 point 9 and

00:20:05,950 --> 00:20:10,779
unfortunately terrified for had some

00:20:07,749 --> 00:20:15,639
some subtle bugs for example if you

00:20:10,779 --> 00:20:17,320
initialize the sub message basically

00:20:15,639 --> 00:20:18,879
paragraph could miss the fact that you'd

00:20:17,320 --> 00:20:21,639
initialize that sub message in certain

00:20:18,879 --> 00:20:25,899
cases and so it wouldn't see realize the

00:20:21,639 --> 00:20:26,889
full message so the latest parts from

00:20:25,899 --> 00:20:28,450
string is about thirty eight percent

00:20:26,889 --> 00:20:34,210
slower than the values that I've been

00:20:28,450 --> 00:20:36,639
showing you so so of course if you are

00:20:34,210 --> 00:20:38,440
if you're wanting speed above everything

00:20:36,639 --> 00:20:41,200
else then you don't fix these kinds of

00:20:38,440 --> 00:20:42,669
bugs right again I'll let you decide

00:20:41,200 --> 00:20:45,610
which of these are legitimate and which

00:20:42,669 --> 00:20:48,340
aren't so I initially gave this talk at

00:20:45,610 --> 00:20:50,889
at Syfy a few months ago and a few

00:20:48,340 --> 00:20:52,990
people suggested that I really needed to

00:20:50,889 --> 00:20:56,549
check out captain proto anyone heard of

00:20:52,990 --> 00:21:02,710
captain proto can bring a captain proto

00:20:56,549 --> 00:21:04,779
infinitely faster Wow funny story

00:21:02,710 --> 00:21:07,690
actually did anyone play the original

00:21:04,779 --> 00:21:10,330
Warcraft games back in the 1990's yeah

00:21:07,690 --> 00:21:11,499
yeah so what you had to do when you were

00:21:10,330 --> 00:21:13,450
setting up the game is you had to tell

00:21:11,499 --> 00:21:16,090
it where your soundcloud card was you

00:21:13,450 --> 00:21:17,409
give it the irq whatever and when you've

00:21:16,090 --> 00:21:19,509
done that you would click a button to

00:21:17,409 --> 00:21:24,070
test it and this booming voice would say

00:21:19,509 --> 00:21:25,330
your sound card works perfectly well my

00:21:24,070 --> 00:21:27,399
brother and I were doing this one day

00:21:25,330 --> 00:21:30,190
and we're having some problems with the

00:21:27,399 --> 00:21:31,600
volume and so we tweaked it around a bit

00:21:30,190 --> 00:21:34,210
click the button you're so on call it

00:21:31,600 --> 00:21:36,789
works weapons evidently we click the

00:21:34,210 --> 00:21:38,860
button one too many times because at

00:21:36,789 --> 00:21:40,480
some point the boy the booming voice

00:21:38,860 --> 00:21:43,659
changed what it was saying in a very

00:21:40,480 --> 00:21:47,009
irritated tone it said it doesn't get

00:21:43,659 --> 00:21:47,009
any better than this

00:21:48,690 --> 00:21:54,370
so if Captain proto is infinitely faster

00:21:52,630 --> 00:21:57,970
it surely doesn't get any better than

00:21:54,370 --> 00:22:02,010
that here's a screenshot from the the

00:21:57,970 --> 00:22:05,440
captain proto website infinitely faster

00:22:02,010 --> 00:22:09,820
okay so how does Captain pro to achieve

00:22:05,440 --> 00:22:11,860
this miracle okay so what it basically

00:22:09,820 --> 00:22:13,180
does is it shifts some of the burden to

00:22:11,860 --> 00:22:16,990
the parts of the coast you're not

00:22:13,180 --> 00:22:19,540
measuring right all right so if you can

00:22:16,990 --> 00:22:22,330
get you know some of the code out of the

00:22:19,540 --> 00:22:23,860
bit that's being measured then you can

00:22:22,330 --> 00:22:26,170
make the bit that is being measured a

00:22:23,860 --> 00:22:29,260
lot faster and you can make claims like

00:22:26,170 --> 00:22:31,990
it's infinitely faster okay so that's

00:22:29,260 --> 00:22:34,870
the way you do it so basically captain

00:22:31,990 --> 00:22:37,240
proto when I tested it captain proto was

00:22:34,870 --> 00:22:39,760
about six times faster to serialize the

00:22:37,240 --> 00:22:42,490
message than purvis about three times

00:22:39,760 --> 00:22:44,380
faster to deserialize it but the

00:22:42,490 --> 00:22:46,000
end-to-end time and what I mean by into

00:22:44,380 --> 00:22:48,250
end time is create a new message object

00:22:46,000 --> 00:22:50,440
and fill it with values serialize it

00:22:48,250 --> 00:22:53,050
deserialize it and then get those values

00:22:50,440 --> 00:22:57,300
out of the object at the end to end time

00:22:53,050 --> 00:22:59,980
was four times slower than pyro buff so

00:22:57,300 --> 00:23:04,360
depending on your use case captain proto

00:22:59,980 --> 00:23:06,780
may or may not be faster for you now

00:23:04,360 --> 00:23:10,480
you'll obviously you'll have to test it

00:23:06,780 --> 00:23:11,890
okay i'm almost out of time here but so

00:23:10,480 --> 00:23:14,020
one more thing about the tyranny of

00:23:11,890 --> 00:23:17,200
speed writers that speed when it comes

00:23:14,020 --> 00:23:21,430
down to it is a race and one genuinely

00:23:17,200 --> 00:23:24,400
bad idea is to be a loan developer you

00:23:21,430 --> 00:23:26,140
know tapping away at Python trying to

00:23:24,400 --> 00:23:30,100
release a faster version of a piece of

00:23:26,140 --> 00:23:32,710
software written by Google so two weeks

00:23:30,100 --> 00:23:34,630
ago Google released protobuf 3.0 now the

00:23:32,710 --> 00:23:37,210
pure python implementations about 13

00:23:34,630 --> 00:23:39,610
times slower than than far above but the

00:23:37,210 --> 00:23:41,920
c++ implementation is only about thirty

00:23:39,610 --> 00:23:43,750
percent slower than pie rebuff so not

00:23:41,920 --> 00:23:47,340
the two to four times that the the

00:23:43,750 --> 00:23:51,670
paragraph documentation claims however

00:23:47,340 --> 00:23:53,830
both captain proto and C++ protobuf so

00:23:51,670 --> 00:23:57,670
that not the pure python protiv off but

00:23:53,830 --> 00:24:00,160
the C++ version require you to basically

00:23:57,670 --> 00:24:02,830
download and install

00:24:00,160 --> 00:24:06,220
a separate package the c++ version of

00:24:02,830 --> 00:24:08,680
their of their library basically onto

00:24:06,220 --> 00:24:11,920
your system and then install the Python

00:24:08,680 --> 00:24:14,650
module right so if you can't do that for

00:24:11,920 --> 00:24:16,750
whatever reason then you can't take up

00:24:14,650 --> 00:24:20,130
the advantages of captain proto or C++

00:24:16,750 --> 00:24:24,160
protobuf to give an example we use

00:24:20,130 --> 00:24:28,150
protobuf at optima obviously and in our

00:24:24,160 --> 00:24:29,440
CI pipeline we can fire up a python

00:24:28,150 --> 00:24:31,750
virtual environment we can pip install

00:24:29,440 --> 00:24:33,400
anything we like but downloading and

00:24:31,750 --> 00:24:36,250
installing a c++ library is

00:24:33,400 --> 00:24:38,650
significantly more difficult so the the

00:24:36,250 --> 00:24:42,160
work to get the c++ implementation is

00:24:38,650 --> 00:24:44,620
it's harder but if you do get it then

00:24:42,160 --> 00:24:48,580
the performance gain of using paragraph

00:24:44,620 --> 00:24:55,500
isn't as great as as the documentation

00:24:48,580 --> 00:24:55,500
claims okay well that's it any questions

00:25:01,650 --> 00:25:10,780
this hi I'm curious about these

00:25:09,400 --> 00:25:12,490
protocols and what sort of

00:25:10,780 --> 00:25:14,920
considerations you have to take into

00:25:12,490 --> 00:25:17,760
account when dealing with untrusted or

00:25:14,920 --> 00:25:22,210
actual or act actively malicious input

00:25:17,760 --> 00:25:23,680
right yes security it's a big deal in

00:25:22,210 --> 00:25:25,030
fact one of the things I was going to

00:25:23,680 --> 00:25:27,190
say I meant to say actually I forgot

00:25:25,030 --> 00:25:28,390
when I talked about sacrificing

00:25:27,190 --> 00:25:31,180
correctness is the other thing you do is

00:25:28,390 --> 00:25:36,660
sacrifice security and that level make

00:25:31,180 --> 00:25:39,430
your code faster as well so obviously

00:25:36,660 --> 00:25:42,460
Google and Captain proto have taken

00:25:39,430 --> 00:25:44,320
security into account very seriously in

00:25:42,460 --> 00:25:45,820
their version to library para buff

00:25:44,320 --> 00:25:48,880
because it's a sort of a skunk works

00:25:45,820 --> 00:25:50,860
project I guess probably not so much so

00:25:48,880 --> 00:25:52,270
if the security is a real concern for

00:25:50,860 --> 00:25:55,390
you then I would have to honestly say

00:25:52,270 --> 00:25:57,250
probably use protobuf or cabin pro at

00:25:55,390 --> 00:25:59,350
this point hopefully will it will

00:25:57,250 --> 00:26:04,840
address some of the security stuff in in

00:25:59,350 --> 00:26:09,490
paragraph in forthcoming updates yeah

00:26:04,840 --> 00:26:12,640
what other types of Python library or

00:26:09,490 --> 00:26:13,779
you know application domain would the

00:26:12,640 --> 00:26:15,669
techniques

00:26:13,779 --> 00:26:17,169
specifically first of all using siphon

00:26:15,669 --> 00:26:19,419
and then secondly some of these other

00:26:17,169 --> 00:26:20,590
things that you've talked about what

00:26:19,419 --> 00:26:22,690
other things would that be applicable to

00:26:20,590 --> 00:26:26,679
lots of things well basically anywhere

00:26:22,690 --> 00:26:28,479
where your um siphon izing something you

00:26:26,679 --> 00:26:30,039
can do these kinds of optimizations so

00:26:28,479 --> 00:26:32,379
fast in San Shi ation for example

00:26:30,039 --> 00:26:35,469
applies anyway it's just that's just

00:26:32,379 --> 00:26:36,729
about creating an object so if you can

00:26:35,469 --> 00:26:39,070
create the object and you don't need to

00:26:36,729 --> 00:26:40,299
call it's in it then that that applies

00:26:39,070 --> 00:26:44,019
anywhere right it's not a part of our

00:26:40,299 --> 00:26:45,729
specific thing so yeah it applies

00:26:44,019 --> 00:26:47,589
anywhere um if you want to know more

00:26:45,729 --> 00:26:48,749
about that actually I try and have a

00:26:47,589 --> 00:26:52,839
look at some of the work that they did

00:26:48,749 --> 00:26:55,059
optimizing so I could learn I think

00:26:52,839 --> 00:26:57,399
someone did a talk in pike on a couple

00:26:55,059 --> 00:26:59,739
of years ago about site of the

00:26:57,399 --> 00:27:01,989
optimizations to scikit-learn they were

00:26:59,739 --> 00:27:03,429
using a number of different approaches

00:27:01,989 --> 00:27:06,309
to optimizing performance including for

00:27:03,429 --> 00:27:08,769
example I'm taking advantage of the case

00:27:06,309 --> 00:27:10,629
if you have large messages I suppose the

00:27:08,769 --> 00:27:11,649
case could become an issue but the

00:27:10,629 --> 00:27:19,809
messages i'm dealing with they're all

00:27:11,649 --> 00:27:28,599
too small for the case to be into Judea

00:27:19,809 --> 00:27:30,609
time desert someone lots of question um

00:27:28,599 --> 00:27:31,629
good talk and interesting to know some

00:27:30,609 --> 00:27:33,729
of the techniques to get better

00:27:31,629 --> 00:27:37,239
performance out of low-level path and

00:27:33,729 --> 00:27:39,700
stuff when you benchmark like message

00:27:37,239 --> 00:27:41,169
serialization sort of libraries often it

00:27:39,700 --> 00:27:44,289
varies quite a bit with different data

00:27:41,169 --> 00:27:46,299
types and sizes of messages um what sort

00:27:44,289 --> 00:27:50,799
of data types and message sizes were you

00:27:46,299 --> 00:27:54,279
benchmarks on yeah so I used an example

00:27:50,799 --> 00:27:57,249
message that was part of the parable

00:27:54,279 --> 00:28:01,539
test suite so it had a variety of field

00:27:57,249 --> 00:28:04,479
types in it including repeated optional

00:28:01,539 --> 00:28:07,269
string int float all kinds of things but

00:28:04,479 --> 00:28:09,580
it was yeah was just one message that I

00:28:07,269 --> 00:28:11,109
was testing with obviously a fixed

00:28:09,580 --> 00:28:12,609
number of fields I didn't test smaller

00:28:11,109 --> 00:28:14,950
or larger messages that sort of thing so

00:28:12,609 --> 00:28:18,009
obviously you would want to test that

00:28:14,950 --> 00:28:19,389
with your own messages but hopefully it

00:28:18,009 --> 00:28:22,289
gives you an idea at least of what the

00:28:19,389 --> 00:28:22,289
performance is like

00:28:25,200 --> 00:28:32,470
okay final final this quick one what's

00:28:31,270 --> 00:28:37,120
been your experience with bar above

00:28:32,470 --> 00:28:39,190
going to python 3.5 yeah so actually

00:28:37,120 --> 00:28:41,350
when I initially did this talk it didn't

00:28:39,190 --> 00:28:44,290
work with peopie 3.5 and i had to fix

00:28:41,350 --> 00:28:48,790
the problems so the main problem was

00:28:44,290 --> 00:28:51,640
with Unicode strings so by default in

00:28:48,790 --> 00:28:53,020
Python 2.7 you could just give it

00:28:51,640 --> 00:28:54,700
strings and that would be fine but in

00:28:53,020 --> 00:28:56,620
Python 3.5 have you throw it a string

00:28:54,700 --> 00:28:59,860
that's a unicode object in it and

00:28:56,620 --> 00:29:01,480
suddenly it becomes an issue so

00:28:59,860 --> 00:29:04,030
basically what you had to do was make

00:29:01,480 --> 00:29:05,230
sure at every point that that you

00:29:04,030 --> 00:29:09,400
actually had a byte string and not a

00:29:05,230 --> 00:29:11,320
Unicode string so it now works and it

00:29:09,400 --> 00:29:14,230
will throw exceptions if you don't give

00:29:11,320 --> 00:29:19,480
it the right kind of string so that was

00:29:14,230 --> 00:29:20,920
the biggest issue I had with I don't

00:29:19,480 --> 00:29:24,340
have any numbers on that that's a good

00:29:20,920 --> 00:29:25,960
question if you want numbers I can get

00:29:24,340 --> 00:29:33,010
them and send em to you so give me your

00:29:25,960 --> 00:29:36,210
contact details okay can we please give

00:29:33,010 --> 00:29:36,210
another round of applause

00:29:40,950 --> 00:29:43,010

YouTube URL: https://www.youtube.com/watch?v=4Q7hDdCYppw


