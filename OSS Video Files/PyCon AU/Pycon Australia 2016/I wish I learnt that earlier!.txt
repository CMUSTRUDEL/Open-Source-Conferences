Title: I wish I learnt that earlier!
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Rachel Bunder
https://2016.pycon-au.org/schedule/154/view_talk
Python is an easy language to learn. Many Python programmers just picked it up thinking “It can’t be too different from X, just with indents!”. By learning a language this way you don’t discover the features unique to that language. 


In this talk we’ll take a tour of Python features that are easily missed. This includes list comprehension,  generator functions and the PEP documents. Where appropriate time comparisons between different methods will be given.
Captions: 
	00:00:00,530 --> 00:00:07,140
okay good afternoon everybody

00:00:03,540 --> 00:00:08,880
ii talk we have rachel banda rachel

00:00:07,140 --> 00:00:11,010
banda has been programming for over 10

00:00:08,880 --> 00:00:11,460
years and has been using python for five

00:00:11,010 --> 00:00:13,769
years

00:00:11,460 --> 00:00:16,160
she's a data scientist and an organizer

00:00:13,769 --> 00:00:19,140
for sydney python and sydney pi ladies

00:00:16,160 --> 00:00:21,660
rachel enjoys making big booms with

00:00:19,140 --> 00:00:23,010
Napoleon artillery pieces creating

00:00:21,660 --> 00:00:26,550
things with their hands and playing with

00:00:23,010 --> 00:00:37,920
data please welcome Rachel and her talk

00:00:26,550 --> 00:00:40,079
I wish I learned that earlier so mean

00:00:37,920 --> 00:00:42,719
right now I'm a data scientist at a

00:00:40,079 --> 00:00:45,420
place called solar analytics I work out

00:00:42,719 --> 00:00:48,149
when solar panels aren't working I use

00:00:45,420 --> 00:00:50,309
Python every day for my work and I run a

00:00:48,149 --> 00:00:53,160
lot of side projects in Python as well

00:00:50,309 --> 00:00:55,530
and I organize Sydney Python and Sydney

00:00:53,160 --> 00:01:00,000
PI ladies so I'm fairly immersed in

00:00:55,530 --> 00:01:02,070
Python but me five years ago I just

00:01:00,000 --> 00:01:03,539
finished my bachelor's in mathematics

00:01:02,070 --> 00:01:06,720
and computer science I was about to

00:01:03,539 --> 00:01:08,520
start a PhD I had done lots of bits of

00:01:06,720 --> 00:01:12,570
programming like I've done a bit of C

00:01:08,520 --> 00:01:15,180
and Fortran and Pascal and literate D if

00:01:12,570 --> 00:01:16,710
you've ever heard of that and so I was

00:01:15,180 --> 00:01:18,360
going to start using Python for my PhD

00:01:16,710 --> 00:01:20,460
it can't be that hard

00:01:18,360 --> 00:01:25,830
it's part it's like the others but with

00:01:20,460 --> 00:01:27,150
more indents so I started coding pipe

00:01:25,830 --> 00:01:30,119
and I would just like start writing code

00:01:27,150 --> 00:01:32,700
that looked PI finished to me and if it

00:01:30,119 --> 00:01:33,990
didn't work I look up what to do and so

00:01:32,700 --> 00:01:36,450
I found Python really wasn't that hard

00:01:33,990 --> 00:01:39,630
it's in dense it's just remembering

00:01:36,450 --> 00:01:42,329
Indians everywhere but it has some

00:01:39,630 --> 00:01:44,159
differences like little that's a very

00:01:42,329 --> 00:01:47,850
language you have to be aware of the

00:01:44,159 --> 00:01:49,350
special features so that's what this

00:01:47,850 --> 00:01:51,000
talk is all these special features I

00:01:49,350 --> 00:01:55,079
never realized that if someone's like

00:01:51,000 --> 00:01:58,500
odd thing you know that really so let's

00:01:55,079 --> 00:02:04,979
get started okay be wary of a pinch so

00:01:58,500 --> 00:02:08,489
all this ok so say we have a list and we

00:02:04,979 --> 00:02:11,810
want to append of 10,000 random numbers

00:02:08,489 --> 00:02:11,810
to our list so

00:02:12,030 --> 00:02:16,800
classic way or not classic way but you

00:02:14,340 --> 00:02:19,590
can use a for-loop and append each item

00:02:16,800 --> 00:02:22,020
individually or you could use this

00:02:19,590 --> 00:02:23,940
comprehension where you use a for loop

00:02:22,020 --> 00:02:27,300
inside your list declaration so it makes

00:02:23,940 --> 00:02:29,640
the whole list or at once this is much

00:02:27,300 --> 00:02:33,209
nice list comprehension partly it just

00:02:29,640 --> 00:02:36,780
looks nicer it's also fair bit faster so

00:02:33,209 --> 00:02:39,810
it takes roughly 1.41 milliseconds

00:02:36,780 --> 00:02:44,640
compared to 2.0 eight milliseconds to do

00:02:39,810 --> 00:02:46,830
it it's also less memory intensive I

00:02:44,640 --> 00:02:49,440
have embarrassing stories about using up

00:02:46,830 --> 00:02:53,840
something like 96% of memory of a server

00:02:49,440 --> 00:02:57,030
that had 64 gigs of memory by doing that

00:02:53,840 --> 00:02:59,850
yeah but this comprehension uses less

00:02:57,030 --> 00:03:03,000
memory you have lots of tricks in this

00:02:59,850 --> 00:03:07,140
prom prehension you can put if

00:03:03,000 --> 00:03:08,670
statements in though so same kind of

00:03:07,140 --> 00:03:12,720
example before but we only want to

00:03:08,670 --> 00:03:15,690
include even random numbers so we can

00:03:12,720 --> 00:03:17,430
have an if statement our for loop or we

00:03:15,690 --> 00:03:20,940
can have an if statement in our list

00:03:17,430 --> 00:03:22,459
comprehension just here in this case

00:03:20,940 --> 00:03:27,120
that's not so much of a speed difference

00:03:22,459 --> 00:03:29,250
can't tell you about the memory usage it

00:03:27,120 --> 00:03:31,080
still looks nice so when you start doing

00:03:29,250 --> 00:03:33,870
multiple if statements with lots of ads

00:03:31,080 --> 00:03:35,610
and else's that's starting to get messy

00:03:33,870 --> 00:03:39,480
you probably should avoid that if you

00:03:35,610 --> 00:03:41,940
can you can also use comprehension on

00:03:39,480 --> 00:03:46,560
dictionaries yes and that's cut off oh

00:03:41,940 --> 00:03:51,840
well so same sort of deal so for

00:03:46,560 --> 00:03:53,400
dictionaries you can use the curly

00:03:51,840 --> 00:03:55,799
brackets like normal dictionaries and

00:03:53,400 --> 00:03:57,810
you put a for loop and the eye is the

00:03:55,799 --> 00:04:00,720
key the random block random is the value

00:03:57,810 --> 00:04:02,190
straightforward sets it's a similar

00:04:00,720 --> 00:04:06,090
thing you just have one number instead

00:04:02,190 --> 00:04:07,739
of a key value pair and in the timings

00:04:06,090 --> 00:04:09,480
in this case dictionaries you're much

00:04:07,739 --> 00:04:11,910
better off doing the normal way you're

00:04:09,480 --> 00:04:14,190
much better off going through the loop

00:04:11,910 --> 00:04:16,019
and putting one item in at a time or

00:04:14,190 --> 00:04:17,760
better off you really care about timing

00:04:16,019 --> 00:04:20,660
might be clearer to the daughter's

00:04:17,760 --> 00:04:24,270
comprehension readability is important

00:04:20,660 --> 00:04:25,360
but what sets sets much better to try

00:04:24,270 --> 00:04:27,270
and create a set or

00:04:25,360 --> 00:04:33,939
I suspect it would be about the same as

00:04:27,270 --> 00:04:36,819
setting a list in this case okay next

00:04:33,939 --> 00:04:37,870
finger so that is an underscore right at

00:04:36,819 --> 00:04:40,030
the top of the screen

00:04:37,870 --> 00:04:42,009
do you mind if you notice I was using

00:04:40,030 --> 00:04:43,689
the underscore and when I went to my

00:04:42,009 --> 00:04:45,580
first Python me topless I pups this

00:04:43,689 --> 00:04:48,009
underscore doing these peoples code I

00:04:45,580 --> 00:04:49,479
don't understand it underscore so I went

00:04:48,009 --> 00:04:50,710
home and looked it up and I actually

00:04:49,479 --> 00:04:53,259
looked it up on my phone in the middle

00:04:50,710 --> 00:04:54,819
of a presentation and why pop doesn't

00:04:53,259 --> 00:04:57,189
underscore doing Python so I found a

00:04:54,819 --> 00:04:58,569
stack overflow comment the first two

00:04:57,189 --> 00:05:01,779
points are saying are something to do

00:04:58,569 --> 00:05:03,909
with c and c type things i don't do that

00:05:01,779 --> 00:05:05,500
sort of stuff but number three is the

00:05:03,909 --> 00:05:08,889
important bit the general-purpose

00:05:05,500 --> 00:05:10,599
throwaway variable you use it when you

00:05:08,889 --> 00:05:11,919
say I don't care what this value is I

00:05:10,599 --> 00:05:18,099
just need to do things ten thousand

00:05:11,919 --> 00:05:23,409
times so for example this we have our

00:05:18,099 --> 00:05:26,580
underscore there okay l statements in

00:05:23,409 --> 00:05:29,440
Python so else

00:05:26,580 --> 00:05:31,839
it works like every other language more

00:05:29,440 --> 00:05:35,710
or less you can have if something do

00:05:31,839 --> 00:05:39,069
stuff LPF do some more stuff otherwise

00:05:35,710 --> 00:05:41,680
else do more stuff but that's fine

00:05:39,069 --> 00:05:42,940
that's normal but then python starts

00:05:41,680 --> 00:05:47,860
putting else statement to the end of for

00:05:42,940 --> 00:05:50,830
loops so how this works not too

00:05:47,860 --> 00:05:52,800
surprisingly prints out on the values

00:05:50,830 --> 00:05:55,740
from 0 to 4 and then it prints out else

00:05:52,800 --> 00:05:58,629
okay how is that useful

00:05:55,740 --> 00:06:01,479
so the useful bit is that if your loop

00:05:58,629 --> 00:06:02,139
breaks unnaturally like with a break

00:06:01,479 --> 00:06:04,569
statement

00:06:02,139 --> 00:06:07,029
it doesn't execute the else so you use

00:06:04,569 --> 00:06:08,620
the else when you want stuff that want

00:06:07,029 --> 00:06:12,909
to execute stuff but only when you

00:06:08,620 --> 00:06:18,849
finish the loop properly it also works

00:06:12,909 --> 00:06:21,069
with while loops to show same deal and

00:06:18,849 --> 00:06:24,460
you also have else statements with

00:06:21,069 --> 00:06:24,909
exceptions so if I'm trying to divide by

00:06:24,460 --> 00:06:30,009
00:06:24,909 --> 00:06:33,159
I try and tells me can't divide by 0 and

00:06:30,009 --> 00:06:36,520
since the exception got executed the

00:06:33,159 --> 00:06:38,590
else statement doesn't when we have

00:06:36,520 --> 00:06:43,570
something that you can do like 10 /

00:06:38,590 --> 00:06:49,720
- so no exception is treated it then

00:06:43,570 --> 00:06:54,580
executes stale statement right with with

00:06:49,720 --> 00:06:56,560
statements so when reading in the file

00:06:54,580 --> 00:07:00,970
you have to open the file do stuff with

00:06:56,560 --> 00:07:02,950
the file close the file everyone has to

00:07:00,970 --> 00:07:05,170
do that so why not make a whole

00:07:02,950 --> 00:07:09,610
structure to take care of it for you so

00:07:05,170 --> 00:07:12,760
we the with statement you open the file

00:07:09,610 --> 00:07:14,950
and save it as I found this case you do

00:07:12,760 --> 00:07:16,930
stuff with the file and then when it

00:07:14,950 --> 00:07:19,150
leaves the skirt when it indents stop

00:07:16,930 --> 00:07:24,340
the file automatically closes for you

00:07:19,150 --> 00:07:25,600
now open the file class type has an open

00:07:24,340 --> 00:07:28,000
and closed function which the word

00:07:25,600 --> 00:07:30,910
statement works out and execute it all

00:07:28,000 --> 00:07:33,250
for you so it's clear a way of showing

00:07:30,910 --> 00:07:37,900
when you're using the file it's it's

00:07:33,250 --> 00:07:40,620
nice hey sorry for this stuff cut off

00:07:37,900 --> 00:07:44,650
the top there is package for everything

00:07:40,620 --> 00:07:46,360
so say we're reading in the CSV file I

00:07:44,650 --> 00:07:48,070
was really in a lot of CSV file I was

00:07:46,360 --> 00:07:50,470
tab delimited files actually I was

00:07:48,070 --> 00:07:52,180
reading in and so yeah I would open the

00:07:50,470 --> 00:07:53,500
file I would use the web statement cuz

00:07:52,180 --> 00:07:56,080
I've learned how to wave statement now

00:07:53,500 --> 00:07:57,910
and so for each line in the file I'll

00:07:56,080 --> 00:08:01,030
split the line up based on their tabs

00:07:57,910 --> 00:08:06,550
and then append these tabs to an array

00:08:01,030 --> 00:08:09,820
and keep on doing that and then I learnt

00:08:06,550 --> 00:08:11,170
about the CSV Reader package and so this

00:08:09,820 --> 00:08:13,030
does this all for you and oughtn't we

00:08:11,170 --> 00:08:15,040
read in the file it automatically splits

00:08:13,030 --> 00:08:16,930
the door has nicely we can iterate over

00:08:15,040 --> 00:08:20,620
is it's just nice to you oh it's nice

00:08:16,930 --> 00:08:25,180
that you use and the special mention two

00:08:20,620 --> 00:08:28,120
pandas pan pandas is wonderful it you

00:08:25,180 --> 00:08:29,560
can see obviously reads in a CSV file it

00:08:28,120 --> 00:08:31,420
does a whole lot of other things if you

00:08:29,560 --> 00:08:33,430
do any factor analysis look at pandas

00:08:31,420 --> 00:08:35,380
I'm not gonna talk any more about pandas

00:08:33,430 --> 00:08:40,690
today because I could talk about it a

00:08:35,380 --> 00:08:42,730
lot and so for some timings really in

00:08:40,690 --> 00:08:44,170
the file manually like doing all the

00:08:42,730 --> 00:08:47,410
splits yourself is actually a fair bit

00:08:44,170 --> 00:08:50,590
faster I think this might be a Python

00:08:47,410 --> 00:08:52,360
free Python 2.7 changed because 2.7 they

00:08:50,590 --> 00:08:53,980
used to be faster on

00:08:52,360 --> 00:08:57,959
one hundred one hundred percent or

00:08:53,980 --> 00:09:00,999
ninety percent sure but at the moment

00:08:57,959 --> 00:09:02,949
CSV package is a fair bit slow art but

00:09:00,999 --> 00:09:04,779
pandas is faster so look at the

00:09:02,949 --> 00:09:08,379
applications look how important timing

00:09:04,779 --> 00:09:09,670
is practice packages for everything but

00:09:08,379 --> 00:09:15,129
they might not always be better as they

00:09:09,670 --> 00:09:19,480
ought to take home okay so everything is

00:09:15,129 --> 00:09:21,009
also an object in Python so say we have

00:09:19,480 --> 00:09:22,569
a function this function are starting

00:09:21,009 --> 00:09:25,239
with random numbers we don't care what

00:09:22,569 --> 00:09:26,799
it does with random numbers the problem

00:09:25,239 --> 00:09:28,360
is we don't know what type of random

00:09:26,799 --> 00:09:32,860
number we need in this function it

00:09:28,360 --> 00:09:37,839
changes so we can pass it around a

00:09:32,860 --> 00:09:39,579
number function to use so if I want to

00:09:37,839 --> 00:09:42,970
have just a random uniform number

00:09:39,579 --> 00:09:44,860
between 0 and 1 I can pass it the random

00:09:42,970 --> 00:09:46,959
dot random function note the lack of the

00:09:44,860 --> 00:09:50,259
brackets at the end but this just passes

00:09:46,959 --> 00:09:52,360
the function and now inside this does

00:09:50,259 --> 00:09:54,309
something referendum numbers function it

00:09:52,360 --> 00:09:56,669
executes that function and returns a

00:09:54,309 --> 00:09:59,589
random number

00:09:56,669 --> 00:10:01,869
you can also so if you have your own

00:09:59,589 --> 00:10:04,239
defined function to have my own random

00:10:01,869 --> 00:10:08,619
number which my random which just gives

00:10:04,239 --> 00:10:12,879
you either 0 1 rounds 2 number and I can

00:10:08,619 --> 00:10:14,079
do the same thing I can tell it to give

00:10:12,879 --> 00:10:17,970
me this number and if I keep on

00:10:14,079 --> 00:10:17,970
executing you can see it's either 0 or 1

00:10:19,589 --> 00:10:25,089
okay so rounding talking about rounding

00:10:23,619 --> 00:10:29,110
this is something I knew learnt about

00:10:25,089 --> 00:10:34,049
two months ago and it shocked me ok 5

00:10:29,110 --> 00:10:40,439
round 5 point 5 what what's the answer 6

00:10:34,049 --> 00:10:42,850
great - agrees with you round 3 point 5

00:10:40,439 --> 00:10:44,799
see it's okay so we've got people saying

00:10:42,850 --> 00:10:47,319
free and we've got people saying 4 and

00:10:44,799 --> 00:10:49,439
this that this is the problem Python

00:10:47,319 --> 00:10:49,439
will

00:10:49,730 --> 00:10:55,160
they're doing oh look

00:10:53,019 --> 00:10:56,689
okay I know what I did I was changing

00:10:55,160 --> 00:10:59,079
slides don't change slides immediately

00:10:56,689 --> 00:11:06,529
before cuz these have been swiftlift or

00:10:59,079 --> 00:11:11,509
lived around now what have I done let's

00:11:06,529 --> 00:11:14,660
do let's do a better example okay six

00:11:11,509 --> 00:11:16,339
point five so normally people in primary

00:11:14,660 --> 00:11:18,049
school mouths get taught six point five

00:11:16,339 --> 00:11:21,290
Bryant rounds up to seven we always

00:11:18,049 --> 00:11:26,239
round up in Python you round to the

00:11:21,290 --> 00:11:28,160
nearest even number okay this is

00:11:26,239 --> 00:11:34,069
apparently the I Triple E standard on

00:11:28,160 --> 00:11:35,809
floating-point stuff I gave this talk to

00:11:34,069 --> 00:11:41,779
a bunch of mathematicians last week that

00:11:35,809 --> 00:11:43,639
their production was fun so be careful I

00:11:41,779 --> 00:11:45,410
found this how could I have a whole lot

00:11:43,639 --> 00:11:46,730
of research that it's based on rounding

00:11:45,410 --> 00:11:49,309
numbers this is terrible but I

00:11:46,730 --> 00:11:52,480
apparently I define my own rounding

00:11:49,309 --> 00:11:52,480
functions are safe okay

00:11:52,720 --> 00:12:01,220
rounding okay so look up once save time

00:11:58,359 --> 00:12:04,879
I talked about timing and lockers a lot

00:12:01,220 --> 00:12:09,139
of micro take some days to run no fault

00:12:04,879 --> 00:12:10,429
of minor just does so they're in better

00:12:09,139 --> 00:12:11,809
this comprehension this is the same

00:12:10,429 --> 00:12:13,839
comprehension I was talking about

00:12:11,809 --> 00:12:17,209
earlier making random numbers in a list

00:12:13,839 --> 00:12:19,879
um but what we can do instead of going

00:12:17,209 --> 00:12:22,299
random random so that goes to the random

00:12:19,879 --> 00:12:25,850
library and looks up the random function

00:12:22,299 --> 00:12:28,339
we can save random dot random as a local

00:12:25,850 --> 00:12:29,989
variable and so that means rather than

00:12:28,339 --> 00:12:31,819
looking in a library and finding a

00:12:29,989 --> 00:12:34,279
function it just looks right there and

00:12:31,819 --> 00:12:36,379
it's there and it's much faster so you

00:12:34,279 --> 00:12:40,399
can see it's one point three one

00:12:36,379 --> 00:12:44,269
milliseconds compared to 888 nanosecond

00:12:40,399 --> 00:12:47,389
so depends on what you're doing if it's

00:12:44,269 --> 00:12:50,449
better or not but what's really the best

00:12:47,389 --> 00:12:52,730
way of doing it is using this from

00:12:50,449 --> 00:12:54,499
around an import random as random - so

00:12:52,730 --> 00:12:56,209
that's nearly exactly the same as saving

00:12:54,499 --> 00:12:57,860
it as a local variable it's much it's

00:12:56,209 --> 00:13:00,230
much more pythonic people understand

00:12:57,860 --> 00:13:03,159
what you're doing it's pretty much no

00:13:00,230 --> 00:13:03,159
difference in time either

00:13:04,330 --> 00:13:14,450
okay generator functions so generator

00:13:10,790 --> 00:13:16,340
functions what these things do so take a

00:13:14,450 --> 00:13:18,140
very simple example instead of we have a

00:13:16,340 --> 00:13:22,850
function and instead of returning a

00:13:18,140 --> 00:13:25,220
value we yield a value so yielding means

00:13:22,850 --> 00:13:26,570
that the generator functions that okay

00:13:25,220 --> 00:13:28,790
we've gilded a value I'm going to

00:13:26,570 --> 00:13:30,650
remember where I was at and what values

00:13:28,790 --> 00:13:32,150
everything was and next time this

00:13:30,650 --> 00:13:35,210
function is called I'm going to go to

00:13:32,150 --> 00:13:37,250
the next yield so to take this example

00:13:35,210 --> 00:13:40,010
so it's going to yield one two then

00:13:37,250 --> 00:13:41,750
three and here I've told her to give me

00:13:40,010 --> 00:13:45,470
the next of each of the Jen

00:13:41,750 --> 00:13:47,150
generator and so will give me one two

00:13:45,470 --> 00:13:48,410
and three and then will give me an error

00:13:47,150 --> 00:13:53,360
message because I haven't got anything

00:13:48,410 --> 00:13:56,120
else to yield and so you can also have a

00:13:53,360 --> 00:13:58,010
loop which will print out one two three

00:13:56,120 --> 00:14:00,730
because it accesses everything in a

00:13:58,010 --> 00:14:02,240
yield on - there's nothing less left I

00:14:00,730 --> 00:14:04,550
hope so

00:14:02,240 --> 00:14:06,530
it's finite generators are not entirely

00:14:04,550 --> 00:14:09,740
exciting but you do have infinite

00:14:06,530 --> 00:14:10,610
generators so we take this example it's

00:14:09,740 --> 00:14:13,730
get primes

00:14:10,610 --> 00:14:19,610
so this is our generator function so it

00:14:13,730 --> 00:14:22,250
says if Prime is a number muled that

00:14:19,610 --> 00:14:25,100
number is if number is a prime I should

00:14:22,250 --> 00:14:27,650
say increment the number and so if we

00:14:25,100 --> 00:14:30,140
run this will give us the first two

00:14:27,650 --> 00:14:31,550
primes two and three which is notice

00:14:30,140 --> 00:14:34,700
because we've only caught it twice and

00:14:31,550 --> 00:14:38,120
we can continue you can add as many as

00:14:34,700 --> 00:14:38,810
we want and it gives us more and more

00:14:38,120 --> 00:14:41,060
primes

00:14:38,810 --> 00:14:44,180
it's obviously not something you want to

00:14:41,060 --> 00:14:46,640
do is though 4-iron get prize because

00:14:44,180 --> 00:14:48,980
then you your computer would not stop

00:14:46,640 --> 00:14:50,540
running for a bit infinite Prime so if

00:14:48,980 --> 00:14:52,190
you know about more bad generator

00:14:50,540 --> 00:14:54,380
functions I found Jeff snupps

00:14:52,190 --> 00:14:59,390
blog extremely useful and lots of

00:14:54,380 --> 00:15:02,420
examples okay so collection classes when

00:14:59,390 --> 00:15:03,830
I was writing this talk I was going to

00:15:02,420 --> 00:15:05,930
people it's going to Sydney Python

00:15:03,830 --> 00:15:09,020
meetups and friends I have and saying

00:15:05,930 --> 00:15:10,280
got this idea for a talk and what things

00:15:09,020 --> 00:15:11,960
do you wish you learned early it's a

00:15:10,280 --> 00:15:14,090
really great conversation starter at a

00:15:11,960 --> 00:15:15,950
Python meetup and because everyone would

00:15:14,090 --> 00:15:16,610
like all my my life changed when I

00:15:15,950 --> 00:15:18,649
learned about

00:15:16,610 --> 00:15:21,370
action classes okay what a collection

00:15:18,649 --> 00:15:25,279
classes I've never heard of these things

00:15:21,370 --> 00:15:28,700
that this was year ago now when that

00:15:25,279 --> 00:15:32,089
happens so we can't reduction to order

00:15:28,700 --> 00:15:35,180
collection classes named tuples so this

00:15:32,089 --> 00:15:40,220
is like a triple but the elements and

00:15:35,180 --> 00:15:42,890
the tuples can have names so we have to

00:15:40,220 --> 00:15:47,149
import it from the collection class we

00:15:42,890 --> 00:15:49,430
can say well give me a name triple that

00:15:47,149 --> 00:15:52,279
we're going to call point and it's going

00:15:49,430 --> 00:15:54,019
to be of type X Y point and the values

00:15:52,279 --> 00:15:58,310
in it are going to be X and it's going

00:15:54,019 --> 00:16:02,420
to be Y so I can then say well p1 is

00:15:58,310 --> 00:16:06,380
point with one two so then if I print to

00:16:02,420 --> 00:16:09,680
type you can see it's type XY point if I

00:16:06,380 --> 00:16:11,839
print p1 x p1 y gives me 1 2 you can

00:16:09,680 --> 00:16:17,480
also access it like a normal tuple using

00:16:11,839 --> 00:16:21,079
the square brackets if we try to say p1

00:16:17,480 --> 00:16:23,120
x equals 5 it shouts us up shouts at us

00:16:21,079 --> 00:16:27,050
because tuples are immutable and so you

00:16:23,120 --> 00:16:29,899
can't change the values one more thing

00:16:27,050 --> 00:16:32,149
and one reason why you would use name

00:16:29,899 --> 00:16:35,779
true causes as if you're gonna inherit

00:16:32,149 --> 00:16:41,660
from it make your own class it makes

00:16:35,779 --> 00:16:44,360
means a bit nicer okay that says X at

00:16:41,660 --> 00:16:46,190
the top so decks all double-ended cues

00:16:44,360 --> 00:16:49,519
the documentation says it's pronounced

00:16:46,190 --> 00:16:50,529
decks so I'm going to believe what must

00:16:49,519 --> 00:16:53,779
be done

00:16:50,529 --> 00:16:56,089
so double-ended queues are white list

00:16:53,779 --> 00:16:58,070
but they made more efficient so you can

00:16:56,089 --> 00:17:02,540
append things or more fish and append

00:16:58,070 --> 00:17:05,809
things from either end so if we go back

00:17:02,540 --> 00:17:07,880
to my append list example if we do

00:17:05,809 --> 00:17:10,520
exactly the same thing through our deck

00:17:07,880 --> 00:17:14,720
and just the comprehension for example

00:17:10,520 --> 00:17:17,540
or for comparison you can see that's lit

00:17:14,720 --> 00:17:20,439
that's a list and that's a comprehension

00:17:17,540 --> 00:17:26,620
of a deck not too much in it and

00:17:20,439 --> 00:17:29,320
comprehension is still faster but if we

00:17:26,620 --> 00:17:34,330
nothing off okay nothing important at

00:17:29,320 --> 00:17:37,630
the top if we depends on the left we can

00:17:34,330 --> 00:17:39,850
see that the decks are much faster or

00:17:37,630 --> 00:17:47,070
not much but 1.3 compared to one point

00:17:39,850 --> 00:17:49,780
eight six no that's the time it function

00:17:47,070 --> 00:17:53,050
does magic stuff and sort it all out so

00:17:49,780 --> 00:17:55,660
it's there adjust the amount of loops to

00:17:53,050 --> 00:17:57,370
do depending on how fast it takes yes

00:17:55,660 --> 00:17:58,809
time it functions one of the things that

00:17:57,370 --> 00:18:03,010
you should know about to but I don't

00:17:58,809 --> 00:18:04,420
talk about it my talk I I have it

00:18:03,010 --> 00:18:08,140
everywhere so I hope you go and look it

00:18:04,420 --> 00:18:11,559
up yourself where Dex come in really

00:18:08,140 --> 00:18:13,390
nicely is that you can affiant defined a

00:18:11,559 --> 00:18:15,610
maximum amount of items to be in your

00:18:13,390 --> 00:18:18,790
deck so if I say I'm going to create a

00:18:15,610 --> 00:18:21,910
deck it's going to be the numbers from 1

00:18:18,790 --> 00:18:24,429
to 0 to 99 but it's gonna have a maximum

00:18:21,910 --> 00:18:26,800
length of 10 then my deck will end up

00:18:24,429 --> 00:18:32,080
being just the 10 last numbers added to

00:18:26,800 --> 00:18:34,510
its in this case 90 through 299 and if

00:18:32,080 --> 00:18:38,080
we continue adding things to the to this

00:18:34,510 --> 00:18:40,090
deck using a pinch you can see that the

00:18:38,080 --> 00:18:46,350
first one keeps on getting dropped off

00:18:40,090 --> 00:18:51,910
so it's like a limited queue I think yep

00:18:46,350 --> 00:18:56,320
okay counter class so the counter class

00:18:51,910 --> 00:18:59,200
counts surprisingly if we give it a list

00:18:56,320 --> 00:19:01,300
of values it essentially gives us a

00:18:59,200 --> 00:19:06,790
dictionary with the counselor of how

00:19:01,300 --> 00:19:08,950
often each thing occurred so we can

00:19:06,790 --> 00:19:10,540
update this counter so I can add if you

00:19:08,950 --> 00:19:13,510
put a string in or break it down by the

00:19:10,540 --> 00:19:16,380
characters you can give it another list

00:19:13,510 --> 00:19:16,380
it'll be fine

00:19:17,700 --> 00:19:21,670
and it can access the individual counts

00:19:20,230 --> 00:19:27,520
just using the square brackets like a

00:19:21,670 --> 00:19:29,559
dictionary all the dictionaries so

00:19:27,520 --> 00:19:31,000
dictionaries in Python if you put in a

00:19:29,559 --> 00:19:32,620
value when you put in values

00:19:31,000 --> 00:19:34,210
it doesn't remember the order it just it

00:19:32,620 --> 00:19:35,710
takes its hash function and gives you

00:19:34,210 --> 00:19:37,179
and when you tell me

00:19:35,710 --> 00:19:39,010
print the diction tailed pipe into

00:19:37,179 --> 00:19:40,440
printer dictionary or printing in

00:19:39,010 --> 00:19:42,820
whatever order it lies

00:19:40,440 --> 00:19:48,159
or the dictionary it actually remembers

00:19:42,820 --> 00:19:50,769
what order you input stuff in so for

00:19:48,159 --> 00:19:53,409
example ditz we first put in the key aid

00:19:50,769 --> 00:19:57,190
and a key B then the key five and when

00:19:53,409 --> 00:19:57,759
we print it out and get a B five it's

00:19:57,190 --> 00:20:00,279
nice

00:19:57,759 --> 00:20:02,109
so default dictionary this is what in

00:20:00,279 --> 00:20:05,950
particular changed my friends life

00:20:02,109 --> 00:20:07,840
apparently so do dictionary normally

00:20:05,950 --> 00:20:10,960
with a dictionary if you say give me

00:20:07,840 --> 00:20:12,399
what dictionary Rachel is and then going

00:20:10,960 --> 00:20:14,200
you haven't told me what Rachel is I'm

00:20:12,399 --> 00:20:16,149
going to throw an error because I don't

00:20:14,200 --> 00:20:18,399
know what it is default dictionary says

00:20:16,149 --> 00:20:19,989
oh well I have a default value so we say

00:20:18,399 --> 00:20:21,339
give me something I don't know about I'm

00:20:19,989 --> 00:20:25,809
just going to give you the default value

00:20:21,339 --> 00:20:27,909
so we define default dictionary here

00:20:25,809 --> 00:20:30,820
we're going to say the default thing is

00:20:27,909 --> 00:20:33,279
an int and so when we access something

00:20:30,820 --> 00:20:36,339
we don't know about say my default

00:20:33,279 --> 00:20:42,279
dictionary B it returns an int the read

00:20:36,339 --> 00:20:44,440
the default value for it in to zero we

00:20:42,279 --> 00:20:46,719
can define our own default so you have

00:20:44,440 --> 00:20:49,450
to pass it a function to for the default

00:20:46,719 --> 00:20:52,239
value so if I have a default value

00:20:49,450 --> 00:20:53,739
function that returns high when I access

00:20:52,239 --> 00:20:58,509
something doesn't know about it'll say

00:20:53,739 --> 00:21:04,690
hi okay so that's it for collection

00:20:58,509 --> 00:21:08,229
classes okay so python enhancement

00:21:04,690 --> 00:21:10,509
proposals so python is a community

00:21:08,229 --> 00:21:13,479
effort if people want to add things to

00:21:10,509 --> 00:21:14,889
python they write a proposal saying i

00:21:13,479 --> 00:21:16,989
think this is a great thing to add to

00:21:14,889 --> 00:21:20,019
python so you might have seen some talks

00:21:16,989 --> 00:21:21,580
about getting guilting can't remember

00:21:20,019 --> 00:21:24,059
what it is but that's a new prom new

00:21:21,580 --> 00:21:27,549
proposal that's gaining traction for

00:21:24,059 --> 00:21:30,059
making things better so these are all

00:21:27,549 --> 00:21:33,309
available online so you have the Python

00:21:30,059 --> 00:21:36,039
pep-pep eight is the Python style guide

00:21:33,309 --> 00:21:39,219
it tells you things like don't use tabs

00:21:36,039 --> 00:21:40,989
use spaces how naming conventions things

00:21:39,219 --> 00:21:42,729
like that it's worthwhile to look

00:21:40,989 --> 00:21:44,320
especially if you haven't done a huge

00:21:42,729 --> 00:21:47,889
amount of Python before you want to see

00:21:44,320 --> 00:21:49,299
what nice Python code looks like but

00:21:47,889 --> 00:21:52,450
things like common features like list

00:21:49,299 --> 00:21:53,370
comprehensions is petrol too I think

00:21:52,450 --> 00:21:57,660
they've got added in

00:21:53,370 --> 00:21:59,880
in 2.4 but I'm not 100% sure dictionary

00:21:57,660 --> 00:22:02,520
comprehensions was a later pet the weave

00:21:59,880 --> 00:22:04,140
statement was one simple generator home

00:22:02,520 --> 00:22:07,910
generator so you can also see pets that

00:22:04,140 --> 00:22:11,220
got rejected and why they were rejected

00:22:07,910 --> 00:22:12,840
so it's interesting reading if you're

00:22:11,220 --> 00:22:16,710
into that kind of thing

00:22:12,840 --> 00:22:21,450
docstrings so when you define a function

00:22:16,710 --> 00:22:28,010
or a class in Python you can add opening

00:22:21,450 --> 00:22:31,620
example directly below if you do in 3

00:22:28,010 --> 00:22:33,929
apostrophes you can add a doc string so

00:22:31,620 --> 00:22:35,910
this doc string tells you what this

00:22:33,929 --> 00:22:37,559
function is about so there's lots of

00:22:35,910 --> 00:22:39,090
Python packages they'll go through and

00:22:37,559 --> 00:22:40,800
look at low order docstrings and say

00:22:39,090 --> 00:22:42,480
well I'm going to automatically generate

00:22:40,800 --> 00:22:43,980
all your documentation because of course

00:22:42,480 --> 00:22:47,490
you've documented your code properly

00:22:43,980 --> 00:22:49,380
already you can access it through your

00:22:47,490 --> 00:22:55,650
function name dot underscore underscore

00:22:49,380 --> 00:22:58,650
doc underscore underscore okay Jupiter

00:22:55,650 --> 00:23:00,630
notebooks or ipython notebooks as they

00:22:58,650 --> 00:23:03,679
used to be caught they now support Ruby

00:23:00,630 --> 00:23:06,300
and are and maybe some other things so

00:23:03,679 --> 00:23:07,770
Jupiter notebooks are great this whole

00:23:06,300 --> 00:23:09,450
presentation was done in Jupiter

00:23:07,770 --> 00:23:13,260
notebooks that's why I can compile code

00:23:09,450 --> 00:23:15,080
as I'm talking it's also I'm a data

00:23:13,260 --> 00:23:18,240
scientist I do a lot of pictures and

00:23:15,080 --> 00:23:20,429
looking at big arrays of data so it's

00:23:18,240 --> 00:23:22,260
nice because I can have all my ideas

00:23:20,429 --> 00:23:28,260
written down I can see all my plots it's

00:23:22,260 --> 00:23:31,380
all it's a nice environment ok so to

00:23:28,260 --> 00:23:33,240
conclude nearly at the end I found out a

00:23:31,380 --> 00:23:34,890
lot of these things by getting involved

00:23:33,240 --> 00:23:36,870
in the Python community I had moved to

00:23:34,890 --> 00:23:38,220
Sydney I didn't know anyone really in

00:23:36,870 --> 00:23:42,090
Sydney so I started going to Python

00:23:38,220 --> 00:23:44,580
meetups as you do and at least for the

00:23:42,090 --> 00:23:46,110
first year nearly every night even if

00:23:44,580 --> 00:23:49,500
the talks are completely out of my

00:23:46,110 --> 00:23:53,280
interest or skill set I picked up on

00:23:49,500 --> 00:23:55,670
little things like this that I wouldn't

00:23:53,280 --> 00:23:58,110
I wouldn't not have known otherwise and

00:23:55,670 --> 00:23:59,429
as I said the beginning just growing up

00:23:58,110 --> 00:24:01,770
to me time so what do you wish you

00:23:59,429 --> 00:24:03,360
learnt earlier people often have really

00:24:01,770 --> 00:24:08,060
passionate eyes passionate about

00:24:03,360 --> 00:24:08,060
something and you learn a lot that way

00:24:08,720 --> 00:24:18,120
okay well thank you for listening um

00:24:12,330 --> 00:24:20,640
enjoy some crocheted pythons you can

00:24:18,120 --> 00:24:21,960
follow me on twitter at duck is my fiend

00:24:20,640 --> 00:24:25,080
I don't really post much but you can

00:24:21,960 --> 00:24:34,050
follow me on Twitter and thank you once

00:24:25,080 --> 00:24:36,270
again Thank You Rachel for that

00:24:34,050 --> 00:24:39,990
insightful talk we didn't have some time

00:24:36,270 --> 00:24:46,500
for questions anybody want to go first

00:24:39,990 --> 00:24:48,270
uh hi thanks for that I got a couple of

00:24:46,500 --> 00:24:51,480
quick ones firstly is there a round

00:24:48,270 --> 00:24:53,580
function that does the right thing or

00:24:51,480 --> 00:24:55,410
would you dis at 0.5 and calcitonin

00:24:53,580 --> 00:24:57,030
which will work that someone who just

00:24:55,410 --> 00:25:00,210
really put up their hand quickly like

00:24:57,030 --> 00:25:01,830
they have an answer I have heard in

00:25:00,210 --> 00:25:03,809
numpy I think there's a proper round

00:25:01,830 --> 00:25:07,110
functional on the sidekick package or

00:25:03,809 --> 00:25:29,610
he's shaking his head at me in the

00:25:07,110 --> 00:25:32,190
standard library okay all right Oh

00:25:29,610 --> 00:25:34,440
googly okay and the other the quick one

00:25:32,190 --> 00:25:36,450
the other one is is there a named topple

00:25:34,440 --> 00:25:38,100
equivalent that's mutable so like for a

00:25:36,450 --> 00:25:41,370
quick class where all you really want is

00:25:38,100 --> 00:25:48,630
getters and setters not that I know off

00:25:41,370 --> 00:25:50,580
the top my head dictionary also just to

00:25:48,630 --> 00:25:52,380
jump back to rounding very quickly I

00:25:50,580 --> 00:25:54,150
looked this up directly before the talk

00:25:52,380 --> 00:25:55,950
to make sure I got it right wikipedia

00:25:54,150 --> 00:25:57,900
has a page around it was about six

00:25:55,950 --> 00:25:59,340
different types listed it tells you all

00:25:57,900 --> 00:26:01,410
like what the good things and the bad

00:25:59,340 --> 00:26:06,000
things and if that I Triple E standards

00:26:01,410 --> 00:26:09,240
and things like that there's also I

00:26:06,000 --> 00:26:10,740
think of Python I've heard that in one

00:26:09,240 --> 00:26:12,929
of the earlier versions of Python around

00:26:10,740 --> 00:26:14,670
quickly by default but that probably

00:26:12,929 --> 00:26:17,070
means you have to use Python 2.1 or

00:26:14,670 --> 00:26:18,980
something which has its own set of

00:26:17,070 --> 00:26:21,409
problems

00:26:18,980 --> 00:26:24,620
in relation to the the mutable named

00:26:21,409 --> 00:26:28,279
supple you make a dict class that has an

00:26:24,620 --> 00:26:34,460
overwritten dunder get at ER to look up

00:26:28,279 --> 00:26:36,919
the dictum okay thanks for that I was

00:26:34,460 --> 00:26:38,269
glad to see name tuples and collections

00:26:36,919 --> 00:26:42,380
get shout out because they're two of my

00:26:38,269 --> 00:26:44,299
favorite things you didn't cover stuff

00:26:42,380 --> 00:26:46,940
like properties and I guess that's

00:26:44,299 --> 00:26:50,779
because the like that is well covered in

00:26:46,940 --> 00:26:51,980
terms of introduction like introductory

00:26:50,779 --> 00:26:54,379
material to Python

00:26:51,980 --> 00:26:59,929
so can't justify what you mean by

00:26:54,379 --> 00:27:01,700
properties not properties the things

00:26:59,929 --> 00:27:03,970
that you put above functions decorate

00:27:01,700 --> 00:27:07,940
the decorators I haven't included

00:27:03,970 --> 00:27:12,320
decorators partly time partly I haven't

00:27:07,940 --> 00:27:14,389
fully understood them myself yet I tried

00:27:12,320 --> 00:27:16,070
to understand decorators a few times I

00:27:14,389 --> 00:27:17,600
am preparing those slightly longer

00:27:16,070 --> 00:27:22,850
version of this talking which I'm going

00:27:17,600 --> 00:27:23,929
to get decorators sorted yes decorators

00:27:22,850 --> 00:27:29,450
are something you should all know about

00:27:23,929 --> 00:27:29,990
but don't ask me about them yet hi

00:27:29,450 --> 00:27:32,929
Rachel

00:27:29,990 --> 00:27:35,980
I wish to follow up with the rounding

00:27:32,929 --> 00:27:39,320
problem actually so you have in the math

00:27:35,980 --> 00:27:42,169
standard library two round alternative

00:27:39,320 --> 00:27:44,570
rounding functions 180 which is sealed

00:27:42,169 --> 00:27:47,750
and the I want to this floor and this

00:27:44,570 --> 00:27:50,659
also is available in nonpoint industry

00:27:47,750 --> 00:27:53,750
and what they do is basically they take

00:27:50,659 --> 00:27:56,600
the floor is their lowest integer value

00:27:53,750 --> 00:27:58,879
and seal the next grade your interview

00:27:56,600 --> 00:28:02,090
value and I think that the difference

00:27:58,879 --> 00:28:05,269
between Python 2 & 3 is that if I sense

00:28:02,090 --> 00:28:08,389
to it returned the float and now Python

00:28:05,269 --> 00:28:10,840
3 returns an integer directly so my

00:28:08,389 --> 00:28:14,269
question was how is that you had

00:28:10,840 --> 00:28:17,090
workaround that problems or fixing that

00:28:14,269 --> 00:28:19,490
problem in your code because you

00:28:17,090 --> 00:28:21,440
mentioned that most of you I assume that

00:28:19,490 --> 00:28:25,720
in my in my coder that I was using for

00:28:21,440 --> 00:28:31,750
researchers had publications based off

00:28:25,720 --> 00:28:35,890
I actually had to find rounding as the

00:28:31,750 --> 00:28:37,810
number plus 0.5 flawed the reason is

00:28:35,890 --> 00:28:40,570
because I didn't actually round properly

00:28:37,810 --> 00:28:43,900
all the time sometimes I did number plus

00:28:40,570 --> 00:28:45,760
random number floored which is why I was

00:28:43,900 --> 00:28:47,830
the stuff that's how actually discovered

00:28:45,760 --> 00:28:50,470
about everything is uh everything's

00:28:47,830 --> 00:28:52,120
object he could pass functions in so I

00:28:50,470 --> 00:28:55,540
was passing different random functions

00:28:52,120 --> 00:28:58,120
in so that that's how I avoided it

00:28:55,540 --> 00:29:02,530
because I had coded it from scratch

00:28:58,120 --> 00:29:04,980
myself for other reasons okay any more

00:29:02,530 --> 00:29:10,360
questions

00:29:04,980 --> 00:29:11,980
no ok well then to conclude Rachel I'd

00:29:10,360 --> 00:29:15,970
like to present you something on behalf

00:29:11,980 --> 00:29:19,020
of Mike on 2016 thank you for your talk

00:29:15,970 --> 00:29:19,020

YouTube URL: https://www.youtube.com/watch?v=cy5n6XAtA-w


