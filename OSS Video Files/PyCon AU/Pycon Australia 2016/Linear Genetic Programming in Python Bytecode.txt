Title: Linear Genetic Programming in Python Bytecode
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Mark Burgess
https://2016.pycon-au.org/schedule/99/view_talk
A quick tutorial on genetic programming and its implementation in Python.
Including the general process of evolution, the various representations of programs and particularly linear genetic programming.
Some really basic python libraries are introduced, including the DEAP and pyevolve frameworks.
It has been presented and prototyped by github user mgard (and documented http://multigrad.blogspot.com.au/2014/06/fun-with-python-bytecode.html) that python bytecode itself could be directly evolved in linear genetic programming to alleviate the overhead of compiling the permutations of trees generated by the evolutionary process.
Python bytecode itself is redly accessed and created by Cpython, though not compatible between versions and a subset of python bytecode instructions will be selected for the implementation of a basic example of symbolic regression.
A futher and more useful example will be provided.
Captions: 
	00:00:00,000 --> 00:00:05,670
like and now we will have my bootys and

00:00:03,629 --> 00:00:07,770
he's our last speaker in the morning

00:00:05,670 --> 00:00:10,889
session at room 104

00:00:07,770 --> 00:00:13,380
mark is a PhD student at the Australian

00:00:10,889 --> 00:00:16,199
National University she's studying

00:00:13,380 --> 00:00:19,050
distributed algorithms for the control

00:00:16,199 --> 00:00:21,060
of electricity micro grids and he has

00:00:19,050 --> 00:00:24,060
worked for several years programming in

00:00:21,060 --> 00:00:27,000
Python are reported power I think and

00:00:24,060 --> 00:00:31,109
he's also a member of a community who

00:00:27,000 --> 00:00:33,180
make hacker voice and we now will hear

00:00:31,109 --> 00:00:44,460
his talk on linear genetic programming

00:00:33,180 --> 00:00:47,129
in Python biker can everyone hear me all

00:00:44,460 --> 00:00:49,500
right hello everyone my name is Mark I'm

00:00:47,129 --> 00:00:51,300
a PhD student and I'm excited to talk

00:00:49,500 --> 00:00:54,270
today about linear genetic programming

00:00:51,300 --> 00:00:57,750
in Python byte code yeah

00:00:54,270 --> 00:01:00,180
all right it's a bit of a mouthful um so

00:00:57,750 --> 00:01:01,620
I don't know I'm a cool guy and this is

00:01:00,180 --> 00:01:03,840
something I feel like it's kind of

00:01:01,620 --> 00:01:08,159
pretty cool in a way so I thought I'd

00:01:03,840 --> 00:01:10,740
show up today and kind of imbue my like

00:01:08,159 --> 00:01:12,119
nuggets of wisdom you know the kind of

00:01:10,740 --> 00:01:14,189
like little ideas that you can kind of

00:01:12,119 --> 00:01:15,390
take away and maybe they kind of grow in

00:01:14,189 --> 00:01:16,650
your mind and he thought maybe I might

00:01:15,390 --> 00:01:19,080
try this like a little side project

00:01:16,650 --> 00:01:21,119
somewhere so I don't know what's that

00:01:19,080 --> 00:01:23,159
where we go so the first thing I want to

00:01:21,119 --> 00:01:24,900
know right I kind of I need this

00:01:23,159 --> 00:01:26,850
audience feedback I need to pitch it

00:01:24,900 --> 00:01:28,259
appropriate to you guys so what I want

00:01:26,850 --> 00:01:30,750
everyone to do is I want everyone to

00:01:28,259 --> 00:01:33,329
raise their hands everyone raised their

00:01:30,750 --> 00:01:36,060
hands all right okay just one just one

00:01:33,329 --> 00:01:38,549
hand will do all right now when I say

00:01:36,060 --> 00:01:41,520
the words genetic programming that

00:01:38,549 --> 00:01:43,619
phrase I want you to put your hand down

00:01:41,520 --> 00:01:45,240
if you barely know what that means if

00:01:43,619 --> 00:01:46,439
you've got some semblance of an idea

00:01:45,240 --> 00:01:49,409
what that means

00:01:46,439 --> 00:01:52,619
keep your hand up all right hands down

00:01:49,409 --> 00:01:54,840
or up okay we're pretty good we're

00:01:52,619 --> 00:01:57,469
pretty good all right okay now for those

00:01:54,840 --> 00:02:00,509
people that raise their hands right I

00:01:57,469 --> 00:02:03,810
want to know how many people have

00:02:00,509 --> 00:02:05,369
actually done genetic programming

00:02:03,810 --> 00:02:08,840
all right so raise your hand up if

00:02:05,369 --> 00:02:08,840
you've actually done this thing

00:02:10,440 --> 00:02:19,360
sorry uh anything yep if you've done

00:02:17,260 --> 00:02:19,930
anything that resembles it hand up all

00:02:19,360 --> 00:02:22,060
right cool

00:02:19,930 --> 00:02:24,160
all right next question and there's an

00:02:22,060 --> 00:02:27,750
important one who has ever done anything

00:02:24,160 --> 00:02:28,960
or fiddled around with Python ebike code

00:02:27,750 --> 00:02:31,210
okay

00:02:28,960 --> 00:02:33,010
yeah all right fair enough I like that

00:02:31,210 --> 00:02:34,000
all right so the first thing I'm going

00:02:33,010 --> 00:02:35,470
to do is I'm going to skip through the

00:02:34,000 --> 00:02:38,680
first little introductory bid because I

00:02:35,470 --> 00:02:41,020
did that and just I'll talk very briefly

00:02:38,680 --> 00:02:43,210
about it what it means for something to

00:02:41,020 --> 00:02:46,210
evolve because what genetic programming

00:02:43,210 --> 00:02:50,380
is is the evolution of computer programs

00:02:46,210 --> 00:02:52,120
themself right so the idea is that there

00:02:50,380 --> 00:02:53,800
are central components to what would

00:02:52,120 --> 00:02:56,320
something broadly be considered to be

00:02:53,800 --> 00:02:58,630
evolution there's an initial population

00:02:56,320 --> 00:03:02,320
of things right now this can be

00:02:58,630 --> 00:03:04,060
organisms bacteria spanners or in this

00:03:02,320 --> 00:03:05,970
case programming's right

00:03:04,060 --> 00:03:09,250
so we start with an initial population

00:03:05,970 --> 00:03:12,270
but there is some evaluative measure in

00:03:09,250 --> 00:03:16,210
effect or actual between organisms

00:03:12,270 --> 00:03:18,250
spanners or programs right so that

00:03:16,210 --> 00:03:20,260
evaluation to some agree to some degree

00:03:18,250 --> 00:03:21,970
in a vector otherwise actually assigns

00:03:20,260 --> 00:03:25,390
to each of them what is generally called

00:03:21,970 --> 00:03:27,430
a fitness right which more often than

00:03:25,390 --> 00:03:29,680
not is actually a function conceptually

00:03:27,430 --> 00:03:32,230
or otherwise then there is a selective

00:03:29,680 --> 00:03:34,150
step so you know like evolution by

00:03:32,230 --> 00:03:36,720
natural selection this is the analog we

00:03:34,150 --> 00:03:40,540
actually select the best programs

00:03:36,720 --> 00:03:41,620
spanners designs of websites to live to

00:03:40,540 --> 00:03:45,010
actually make it into the next

00:03:41,620 --> 00:03:48,040
generation thence forth from a selective

00:03:45,010 --> 00:03:49,840
step we have I would call variation so

00:03:48,040 --> 00:03:52,480
if we're talking in a biological sense

00:03:49,840 --> 00:03:54,670
this is mutation or crossover of genes

00:03:52,480 --> 00:03:56,020
or whatever have you right this is like

00:03:54,670 --> 00:03:58,330
that little extra degree of randomness

00:03:56,020 --> 00:04:01,840
and thence that forms the next

00:03:58,330 --> 00:04:05,650
generation where if we reevaluate select

00:04:01,840 --> 00:04:07,480
very reevaluate select very and this

00:04:05,650 --> 00:04:09,160
iterative procedure continues until such

00:04:07,480 --> 00:04:10,810
a point as we reach a terminating

00:04:09,160 --> 00:04:13,930
condition where we say okay we've got a

00:04:10,810 --> 00:04:15,940
thing a spanner that we're happy enough

00:04:13,930 --> 00:04:19,180
with to say that that is the result of

00:04:15,940 --> 00:04:21,729
the evolution so that is like in the

00:04:19,180 --> 00:04:23,530
broadest kind of sense like kind of

00:04:21,729 --> 00:04:27,270
central elements to what it means for

00:04:23,530 --> 00:04:29,290
thing to evolve right so in the case of

00:04:27,270 --> 00:04:32,350
genetic programming when we're evolving

00:04:29,290 --> 00:04:33,580
programs it's a little bit like a juggle

00:04:32,350 --> 00:04:35,139
kind of thing there's a lot of factors

00:04:33,580 --> 00:04:36,610
to consider and there's those stages

00:04:35,139 --> 00:04:39,400
broadly considered that we need to

00:04:36,610 --> 00:04:42,010
implement so the first thing we need to

00:04:39,400 --> 00:04:44,200
do is when we're programming programs

00:04:42,010 --> 00:04:46,389
and the evolution of programs in a

00:04:44,200 --> 00:04:47,950
computer to some extent we need to

00:04:46,389 --> 00:04:50,500
choose what is called representation of

00:04:47,950 --> 00:04:52,330
that program so like I think

00:04:50,500 --> 00:04:54,100
evolutionary programs genetic

00:04:52,330 --> 00:04:56,770
programming has been loosely around

00:04:54,100 --> 00:04:58,210
since like mid late 80s it's kind of

00:04:56,770 --> 00:05:00,010
developed particularly by a guy named

00:04:58,210 --> 00:05:01,840
cosa but this was kind of like the

00:05:00,010 --> 00:05:05,260
original representation of programs so

00:05:01,840 --> 00:05:07,360
as trees um so if anybody here is

00:05:05,260 --> 00:05:09,669
familiar with Lisp this is kind of more

00:05:07,360 --> 00:05:11,800
or less almost list styles syntax right

00:05:09,669 --> 00:05:15,160
so we've got like just generic tree that

00:05:11,800 --> 00:05:17,200
is a program now there are other

00:05:15,160 --> 00:05:19,690
representations as well so for instance

00:05:17,200 --> 00:05:21,150
this is a tree representation the other

00:05:19,690 --> 00:05:23,500
thing we can do is we can just go like

00:05:21,150 --> 00:05:25,450
choose just individual instructions

00:05:23,500 --> 00:05:29,229
which to some extent I'm sure we're all

00:05:25,450 --> 00:05:30,580
moderately familiar so opcode so for

00:05:29,229 --> 00:05:32,260
instance this is just Python op codes

00:05:30,580 --> 00:05:34,180
which we'll come back to later in the

00:05:32,260 --> 00:05:35,620
speech when I get down to it but there's

00:05:34,180 --> 00:05:37,750
other opto a can choose so we can just

00:05:35,620 --> 00:05:39,039
go straight to x86 if we want or we can

00:05:37,750 --> 00:05:42,130
choose our own instruction set that's

00:05:39,039 --> 00:05:44,260
just linear in execution and linear

00:05:42,130 --> 00:05:47,289
executed evolution of programs is called

00:05:44,260 --> 00:05:49,510
linear genetic programming funnily

00:05:47,289 --> 00:05:51,100
enough but there are other

00:05:49,510 --> 00:05:52,990
representations too and we need to keep

00:05:51,100 --> 00:05:54,490
these there open so the top one there if

00:05:52,990 --> 00:05:57,100
you're familiar with it is called

00:05:54,490 --> 00:05:59,380
brain-fuck right we can evolve

00:05:57,100 --> 00:06:00,940
brain-fuck if we want it's not a

00:05:59,380 --> 00:06:02,560
particularly good representation but we

00:06:00,940 --> 00:06:06,280
can do it and there are tutorials online

00:06:02,560 --> 00:06:08,530
on the evolution of brainfuck on the

00:06:06,280 --> 00:06:10,930
bottom left there we've got what is the

00:06:08,530 --> 00:06:12,880
definition of a grammar right so it's

00:06:10,930 --> 00:06:14,410
kind of familiar to e BMF notation or

00:06:12,880 --> 00:06:16,810
whatever and there's actually

00:06:14,410 --> 00:06:18,430
grammatical evolution is its own kind of

00:06:16,810 --> 00:06:18,880
thing it's definitively it's a real

00:06:18,430 --> 00:06:21,070
thing

00:06:18,880 --> 00:06:22,600
and if you're if you want to go down

00:06:21,070 --> 00:06:24,520
that thing there's research and papers

00:06:22,600 --> 00:06:26,050
and all kinds of stuff on that on the

00:06:24,520 --> 00:06:27,160
right there we've got an esoteric

00:06:26,050 --> 00:06:30,880
language that I pulled from the

00:06:27,160 --> 00:06:34,900
interwebs called our beeswax which has

00:06:30,880 --> 00:06:36,700
up here who has ever heard of a funds B

00:06:34,900 --> 00:06:39,610
funds

00:06:36,700 --> 00:06:41,410
that's terrible okay so it's like it's

00:06:39,610 --> 00:06:42,520
like brain farc except it's composed of

00:06:41,410 --> 00:06:43,780
more letters and it's kind of like you

00:06:42,520 --> 00:06:45,220
execute across and then it hits a

00:06:43,780 --> 00:06:47,470
character and then it executes downwards

00:06:45,220 --> 00:06:48,970
and then to the it's just it's an

00:06:47,470 --> 00:06:50,800
esoteric language that's what it's

00:06:48,970 --> 00:06:52,630
called but you can evolve whatever you

00:06:50,800 --> 00:06:55,150
like all right you need sniff just need

00:06:52,630 --> 00:06:58,990
to choose a representation and you can

00:06:55,150 --> 00:07:00,940
evolve word right now important part

00:06:58,990 --> 00:07:03,070
like this is the choosing of the

00:07:00,940 --> 00:07:04,390
representation of your programs insofar

00:07:03,070 --> 00:07:06,010
as you want to do the evolution of

00:07:04,390 --> 00:07:08,260
programs is really quite important

00:07:06,010 --> 00:07:12,310
because whatever representation you

00:07:08,260 --> 00:07:14,160
choose actually defines the space where

00:07:12,310 --> 00:07:16,330
the evolution can actually take place

00:07:14,160 --> 00:07:17,860
right now it's kind of important because

00:07:16,330 --> 00:07:20,650
there's this thing called the curse of

00:07:17,860 --> 00:07:22,870
dimensionality which means that if you

00:07:20,650 --> 00:07:24,910
fire too widely and if you choose a

00:07:22,870 --> 00:07:26,980
programming space that's too big it'll

00:07:24,910 --> 00:07:28,330
take just that much more longer for the

00:07:26,980 --> 00:07:30,550
computer to converge to something that

00:07:28,330 --> 00:07:32,710
you might like so if you can choose the

00:07:30,550 --> 00:07:34,060
very constrained language right you need

00:07:32,710 --> 00:07:35,440
to make sure that it satisfies the

00:07:34,060 --> 00:07:37,240
sufficiency condition that is that you

00:07:35,440 --> 00:07:39,220
can actually evolve something that looks

00:07:37,240 --> 00:07:41,320
like what you want using that language

00:07:39,220 --> 00:07:42,430
but if you could use more constrained

00:07:41,320 --> 00:07:46,990
you actually get generally better

00:07:42,430 --> 00:07:48,820
results so in kind of making these

00:07:46,990 --> 00:07:50,110
things that evolve right there's kind of

00:07:48,820 --> 00:07:52,030
broad conditions you need to make sure

00:07:50,110 --> 00:07:53,980
that they don't crash your computer

00:07:52,030 --> 00:07:56,740
right if they can crash your computer

00:07:53,980 --> 00:07:58,000
it's probably bad the other thing is you

00:07:56,740 --> 00:07:59,470
kind of need to make sure that they're

00:07:58,000 --> 00:08:01,780
relatively quite consistent so you're

00:07:59,470 --> 00:08:04,480
not multiplying floats by balls you know

00:08:01,780 --> 00:08:05,790
or you know in spite of X because what

00:08:04,480 --> 00:08:08,470
sense does that make

00:08:05,790 --> 00:08:09,130
but the idea is that once we've got in

00:08:08,470 --> 00:08:11,350
our heads

00:08:09,130 --> 00:08:13,360
this evolution there's programs and

00:08:11,350 --> 00:08:15,790
we've got a representation in which this

00:08:13,360 --> 00:08:21,060
space in which we can evolve programs

00:08:15,790 --> 00:08:24,430
right the next stage of the game is to

00:08:21,060 --> 00:08:28,540
make an initial population of these

00:08:24,430 --> 00:08:30,430
programs right now broadly speaking

00:08:28,540 --> 00:08:31,930
depending on how you represent it there

00:08:30,430 --> 00:08:33,729
are different algorithms to go about it

00:08:31,930 --> 00:08:36,160
so for instance the oldest method is to

00:08:33,729 --> 00:08:39,070
generate programs of trees and is

00:08:36,160 --> 00:08:40,300
actually definitive like there's Rampton

00:08:39,070 --> 00:08:42,250
half and half and then there's half

00:08:40,300 --> 00:08:44,020
ramped in half and like there's

00:08:42,250 --> 00:08:46,780
different actual algorithms used to

00:08:44,020 --> 00:08:48,340
design random trees that contain the

00:08:46,780 --> 00:08:50,420
most features they're the most random

00:08:48,340 --> 00:08:51,769
but depending on how you

00:08:50,420 --> 00:08:53,510
present your programs depends on the

00:08:51,769 --> 00:08:55,399
algorithms you might like to initialize

00:08:53,510 --> 00:08:56,839
your population with you can also see

00:08:55,399 --> 00:08:59,600
the population with something that you

00:08:56,839 --> 00:09:01,550
know is okay the central part of

00:08:59,600 --> 00:09:04,790
evolution is that you want to keep some

00:09:01,550 --> 00:09:07,010
degree of variety in your population

00:09:04,790 --> 00:09:09,800
right so if you just start with all one

00:09:07,010 --> 00:09:14,149
program it's probably not the best start

00:09:09,800 --> 00:09:16,699
that you could probably do the next

00:09:14,149 --> 00:09:18,320
stage is to define to some extent and

00:09:16,699 --> 00:09:19,670
evaluation over your programs in the

00:09:18,320 --> 00:09:22,040
population all right

00:09:19,670 --> 00:09:23,810
so traditionally this is kind of like

00:09:22,040 --> 00:09:25,550
being called a fitness function right

00:09:23,810 --> 00:09:27,440
where you more or less evaluate the

00:09:25,550 --> 00:09:29,089
output of your program to what you want

00:09:27,440 --> 00:09:31,310
and then you just assign it a number to

00:09:29,089 --> 00:09:32,839
some extent based upon that it's

00:09:31,310 --> 00:09:34,100
actually a lot you know there's a

00:09:32,839 --> 00:09:35,779
relative amount of finesse in choosing

00:09:34,100 --> 00:09:39,380
an appropriate fitness function so

00:09:35,779 --> 00:09:41,899
probably the most important of that is

00:09:39,380 --> 00:09:43,670
that your fitness function is smooth so

00:09:41,899 --> 00:09:46,010
that's some extent that means that as

00:09:43,670 --> 00:09:47,600
much as is possible you want the actual

00:09:46,010 --> 00:09:50,360
numeric value that is the output of your

00:09:47,600 --> 00:09:52,820
fitness function to change small with

00:09:50,360 --> 00:09:55,790
regards to a small variation in its

00:09:52,820 --> 00:09:57,949
input program it's an idealization and

00:09:55,790 --> 00:10:02,570
we'll come to why you might like that

00:09:57,949 --> 00:10:03,680
later the next part is the selection so

00:10:02,570 --> 00:10:07,310
we're modeling evolution there's the

00:10:03,680 --> 00:10:08,660
natural selection part and it's in the

00:10:07,310 --> 00:10:10,820
kind of programming you want it more or

00:10:08,660 --> 00:10:13,910
less to generally select the fitter

00:10:10,820 --> 00:10:15,260
individuals but not exactly if you only

00:10:13,910 --> 00:10:17,089
select the best individual of your

00:10:15,260 --> 00:10:18,560
population right then you only just end

00:10:17,089 --> 00:10:21,079
up with a population of one kind of

00:10:18,560 --> 00:10:23,600
individual which is kind of like you

00:10:21,079 --> 00:10:25,820
know a variety goes down to the sink so

00:10:23,600 --> 00:10:28,399
there's actually different techniques to

00:10:25,820 --> 00:10:30,380
select but generally what is the better

00:10:28,399 --> 00:10:32,360
kind of half of the population so

00:10:30,380 --> 00:10:33,890
there's tournament you know you just

00:10:32,360 --> 00:10:35,240
select three individuals and then you

00:10:33,890 --> 00:10:36,980
compete them to see which one's the best

00:10:35,240 --> 00:10:38,569
and then that one survives the next

00:10:36,980 --> 00:10:40,430
population there's another one called

00:10:38,569 --> 00:10:41,990
roulette which is basically you select a

00:10:40,430 --> 00:10:46,399
program in proportion to its assigned

00:10:41,990 --> 00:10:48,860
fitness value all these work so a lot of

00:10:46,399 --> 00:10:51,860
the selection kind of process need to

00:10:48,860 --> 00:10:53,630
evaluate your programs and you want it

00:10:51,860 --> 00:10:56,120
to some degree to keep the diversity so

00:10:53,630 --> 00:11:02,120
your selection can't be greedy as it

00:10:56,120 --> 00:11:03,410
were what the next stage because we're

00:11:02,120 --> 00:11:04,279
doing evolution here is you need to put

00:11:03,410 --> 00:11:06,589
in to some

00:11:04,279 --> 00:11:08,509
a little bit of that mutation factor so

00:11:06,589 --> 00:11:10,129
obviously depending on how your programs

00:11:08,509 --> 00:11:12,889
are represented depends upon how you can

00:11:10,129 --> 00:11:15,170
readily introduce that mutation so for

00:11:12,889 --> 00:11:15,980
linear programs you can do duplication

00:11:15,170 --> 00:11:18,470
inversion deletion insertion

00:11:15,980 --> 00:11:19,819
translocation anything you can do you

00:11:18,470 --> 00:11:23,209
can mix and match you can just randomize

00:11:19,819 --> 00:11:25,519
the whole string so you know it's kind

00:11:23,209 --> 00:11:27,079
of like up to creativity to some extent

00:11:25,519 --> 00:11:29,180
what kind of mutations and variations

00:11:27,079 --> 00:11:30,800
you want to put in this thing with the

00:11:29,180 --> 00:11:32,389
case of tree based genetic programs a

00:11:30,800 --> 00:11:35,139
lot of the operations just consisting of

00:11:32,389 --> 00:11:39,100
swapping changing and generating random

00:11:35,139 --> 00:11:42,470
sub trees is an example of variation and

00:11:39,100 --> 00:11:43,759
putting it all together what the idea is

00:11:42,470 --> 00:11:45,079
that we have this kind of like was

00:11:43,759 --> 00:11:46,550
initial population that's randomly

00:11:45,079 --> 00:11:48,379
generated with an assigned Fitness value

00:11:46,550 --> 00:11:50,089
and it's kind of like little variations

00:11:48,379 --> 00:11:51,559
selection and it's kind of like

00:11:50,089 --> 00:11:53,180
gradually over time we want to get this

00:11:51,559 --> 00:11:55,579
like individual with high fitness value

00:11:53,180 --> 00:11:56,839
to cross the finish line which is our

00:11:55,579 --> 00:11:59,720
terminating condition at which point we

00:11:56,839 --> 00:12:03,920
say we've just discovered a brand new

00:11:59,720 --> 00:12:09,259
algorithm for doing whatever we want but

00:12:03,920 --> 00:12:11,709
yeah now I suppose genetic programming

00:12:09,259 --> 00:12:14,959
is one of those things where like it is

00:12:11,709 --> 00:12:16,370
it's exciting in a way because what

00:12:14,959 --> 00:12:18,559
you're doing is you're almost it's

00:12:16,370 --> 00:12:20,839
you're throwing the problem to a

00:12:18,559 --> 00:12:24,620
computer to say do the programming for

00:12:20,839 --> 00:12:27,050
me in a sense now there's a lot of

00:12:24,620 --> 00:12:30,410
finesse to it and it's kind of I just

00:12:27,050 --> 00:12:32,149
maybe I've just like shotgun you write

00:12:30,410 --> 00:12:33,319
the concepts so what we're going to do

00:12:32,149 --> 00:12:35,689
is we're going to go slowly through an

00:12:33,319 --> 00:12:37,639
example of this thing right now this

00:12:35,689 --> 00:12:40,220
example is called symbolic regression

00:12:37,639 --> 00:12:41,839
and it's taken directly from a field

00:12:40,220 --> 00:12:44,120
guide to genetic programming which is a

00:12:41,839 --> 00:12:45,439
Creative Commons book one of my more

00:12:44,120 --> 00:12:47,629
favorites you can get a hard copy for

00:12:45,439 --> 00:12:49,429
about ten bucks so we're going to do

00:12:47,629 --> 00:12:51,079
this thing called symbolic regression is

00:12:49,429 --> 00:12:53,470
where basically you have a series of

00:12:51,079 --> 00:12:55,699
data points and you fit a function to it

00:12:53,470 --> 00:12:57,740
now the function is actually defined

00:12:55,699 --> 00:12:59,509
symbolically so any function that you

00:12:57,740 --> 00:13:02,660
can define by combination of symbols

00:12:59,509 --> 00:13:04,610
it'll fit to it all right so what we

00:13:02,660 --> 00:13:06,649
want to do in this example is we've got

00:13:04,610 --> 00:13:09,290
a series of data points over the range

00:13:06,649 --> 00:13:11,209
minus one to one that actually just

00:13:09,290 --> 00:13:12,970
coincidentally is a directly on the

00:13:11,209 --> 00:13:15,559
function x squared plus X plus one and

00:13:12,970 --> 00:13:17,300
we're going to actually evolve symbolic

00:13:15,559 --> 00:13:19,550
expressions that converge

00:13:17,300 --> 00:13:22,519
hopefully to the ideal value of x

00:13:19,550 --> 00:13:24,620
squared plus X plus 1 right so in

00:13:22,519 --> 00:13:26,000
principle if you've got like scientist

00:13:24,620 --> 00:13:27,320
and in nature and you're collecting data

00:13:26,000 --> 00:13:28,910
point you say oh I just want to get a

00:13:27,320 --> 00:13:31,000
symbolic expression to those data points

00:13:28,910 --> 00:13:34,339
it's like throw it to a computer done

00:13:31,000 --> 00:13:36,470
though it's awesome not so neat alright

00:13:34,339 --> 00:13:38,810
so we've got x squared plus X plus 1

00:13:36,470 --> 00:13:41,019
over the range minus 1 to 1 including

00:13:38,810 --> 00:13:43,370
the operations of plus minus

00:13:41,019 --> 00:13:45,500
multiplication then predict protected

00:13:43,370 --> 00:13:47,329
divide so if you divide by 0 and

00:13:45,500 --> 00:13:48,890
ordinarily throws a give you PI 0 error

00:13:47,329 --> 00:13:51,500
so protected dividers just where it

00:13:48,890 --> 00:13:54,110
returns a 0 if you divide by 0 just a

00:13:51,500 --> 00:13:55,220
safeguard and the measure of fitness is

00:13:54,110 --> 00:13:58,339
going to be the sum of the absolute

00:13:55,220 --> 00:14:01,100
errors of over the interval minus 1 to 1

00:13:58,339 --> 00:14:02,450
with point 1 increments we're going to

00:14:01,100 --> 00:14:05,149
generate an initial population by a

00:14:02,450 --> 00:14:06,740
technique rampant half and half we're

00:14:05,149 --> 00:14:09,890
going to have a population size of 4

00:14:06,740 --> 00:14:11,240
which generally speaking is tiny and

00:14:09,890 --> 00:14:13,510
we're going to terminate when we have an

00:14:11,240 --> 00:14:17,480
individual with a fitness less than 0.1

00:14:13,510 --> 00:14:21,670
all right so the first step is we if we

00:14:17,480 --> 00:14:24,200
have randomized an initial population so

00:14:21,670 --> 00:14:26,060
we've got a whole you go for programs

00:14:24,200 --> 00:14:28,040
just randomly generated trees that

00:14:26,060 --> 00:14:30,380
correspond to symbolic expressions so

00:14:28,040 --> 00:14:33,709
we've got X plus 1 at X plus 1 x squared

00:14:30,380 --> 00:14:36,190
plus 1/2 and X all right and those are

00:14:33,709 --> 00:14:38,000
our initial population of programs well

00:14:36,190 --> 00:14:40,100
mathematical expressions are programs

00:14:38,000 --> 00:14:41,420
some extent and then now we're going to

00:14:40,100 --> 00:14:42,950
do is we're going to the next step of

00:14:41,420 --> 00:14:46,190
the thing is to evaluate those programs

00:14:42,950 --> 00:14:48,770
so next slide is the evaluation of those

00:14:46,190 --> 00:14:51,380
programs with respect to our desired

00:14:48,770 --> 00:14:52,880
ideal fitness function so in the black

00:14:51,380 --> 00:14:56,060
there there's x squared plus X plus 1

00:14:52,880 --> 00:14:58,730
and the red dotted line is the actual

00:14:56,060 --> 00:15:04,579
graph of that of each expression over

00:14:58,730 --> 00:15:06,949
that same domain X minus 1 to 1 so in

00:15:04,579 --> 00:15:10,880
the case of we've got a B C and D with

00:15:06,949 --> 00:15:14,570
the fitness values a b c and d 7.7 11 17

00:15:10,880 --> 00:15:16,970
and 28 so a is closer to the VAT is

00:15:14,570 --> 00:15:19,730
closer to x squared plus X plus 1 then

00:15:16,970 --> 00:15:22,760
is d that's what that means it's got a

00:15:19,730 --> 00:15:26,680
smaller Fitness function in this case so

00:15:22,760 --> 00:15:30,560
those 4 correspond to those 4 all right

00:15:26,680 --> 00:15:31,100
everyone with thee all right now what

00:15:30,560 --> 00:15:33,260
happens is

00:15:31,100 --> 00:15:34,820
we have an initial population right of

00:15:33,260 --> 00:15:36,700
those programs and we've each designed

00:15:34,820 --> 00:15:39,650
to those programs a fitness function

00:15:36,700 --> 00:15:40,940
right values of those fitness and now

00:15:39,650 --> 00:15:44,510
what happens is we need to apply the

00:15:40,940 --> 00:15:47,300
selection so of those four programs it

00:15:44,510 --> 00:15:48,650
so happens that a is the best it's got

00:15:47,300 --> 00:15:52,040
the lowest fitness value which in this

00:15:48,650 --> 00:15:54,590
case is good and so by our randomness we

00:15:52,040 --> 00:15:56,000
just say okay our selection process just

00:15:54,590 --> 00:15:59,270
selects the best individual one carries

00:15:56,000 --> 00:16:02,330
that into the next generation so boom

00:15:59,270 --> 00:16:04,040
top generation second generation all

00:16:02,330 --> 00:16:05,570
right so a just go straight reproduction

00:16:04,040 --> 00:16:07,460
and we can set a parameter probability

00:16:05,570 --> 00:16:09,620
for that if we like alright the next

00:16:07,460 --> 00:16:12,380
thing that we want to do so you know

00:16:09,620 --> 00:16:16,070
this engine kicks in and selects

00:16:12,380 --> 00:16:17,600
randomly to some extent a individual C

00:16:16,070 --> 00:16:19,520
which is not the best it's not the worst

00:16:17,600 --> 00:16:20,570
at somewhere in between because we do

00:16:19,520 --> 00:16:23,810
want to keep a little bit of randomness

00:16:20,570 --> 00:16:25,520
about it and it introduces a mutation so

00:16:23,810 --> 00:16:28,460
it chooses a random node which just so

00:16:25,520 --> 00:16:31,790
happens to be two and generates a random

00:16:28,460 --> 00:16:33,590
subtree and just inserts right so we end

00:16:31,790 --> 00:16:35,060
up getting this function down here which

00:16:33,590 --> 00:16:37,660
just so happens to chorus ID with the

00:16:35,060 --> 00:16:37,660
value one

00:16:37,790 --> 00:16:42,340
so the next thing happens is all right

00:16:39,590 --> 00:16:44,870
well let's do another opting so

00:16:42,340 --> 00:16:48,890
introduce an operation called sub

00:16:44,870 --> 00:16:50,930
subtree crossover right so in this kind

00:16:48,890 --> 00:16:53,600
of machine thing that we're kind of

00:16:50,930 --> 00:16:55,250
imagining of selection and variation it

00:16:53,600 --> 00:16:56,840
randomly selects coincidentally the best

00:16:55,250 --> 00:16:59,570
to individuals because it selects based

00:16:56,840 --> 00:17:01,160
upon the fitness value and what it does

00:16:59,570 --> 00:17:04,790
is it chooses two branches and it

00:17:01,160 --> 00:17:07,580
crosses the motor all right so we've got

00:17:04,790 --> 00:17:10,120
the plus and the X and those sub trees

00:17:07,580 --> 00:17:13,280
literally cross over at that point so

00:17:10,120 --> 00:17:18,620
minus X minus zero gives you X and then

00:17:13,280 --> 00:17:22,450
that there corresponds to 1 plus X plus

00:17:18,620 --> 00:17:25,010
1 times X producing the last individual

00:17:22,450 --> 00:17:26,150
now this is goes from our first

00:17:25,010 --> 00:17:28,310
generation and apply all these

00:17:26,150 --> 00:17:30,530
operations with stochastic probabilities

00:17:28,310 --> 00:17:31,850
gives you our second generation and the

00:17:30,530 --> 00:17:32,960
idea being is that through this thing

00:17:31,850 --> 00:17:34,870
we're hoping that the second generation

00:17:32,960 --> 00:17:38,180
will be closer to our ideal outcome and

00:17:34,870 --> 00:17:40,040
coincidentally in this example we end up

00:17:38,180 --> 00:17:42,860
with the best possible individual x

00:17:40,040 --> 00:17:45,299
squared plus X plus 1 now this is just

00:17:42,860 --> 00:17:48,120
like a little sandbox example

00:17:45,299 --> 00:17:50,940
and ideal solutions rarely come about in

00:17:48,120 --> 00:17:54,299
nature but you know hey why not just

00:17:50,940 --> 00:17:55,289
illustrative point so in this kind of a

00:17:54,299 --> 00:17:56,970
way what we've done is we've started

00:17:55,289 --> 00:17:58,980
with the problem that we want to evolve

00:17:56,970 --> 00:18:00,870
a symbolic expression that's corresponds

00:17:58,980 --> 00:18:03,419
to a program that evaluates as close to

00:18:00,870 --> 00:18:05,549
x squared plus 1 x plus 1 as possible

00:18:03,419 --> 00:18:08,129
we're throwing it into the algorithm and

00:18:05,549 --> 00:18:15,149
outcomes what is the solution to our

00:18:08,129 --> 00:18:17,850
thing which is a program alright I want

00:18:15,149 --> 00:18:19,320
to introduce just like like rather than

00:18:17,850 --> 00:18:21,090
just hand wave you talk about these

00:18:19,320 --> 00:18:22,440
trees right there's a little Python

00:18:21,090 --> 00:18:24,450
package which I like called deep it's

00:18:22,440 --> 00:18:26,610
kind of a framework in which you can

00:18:24,450 --> 00:18:29,009
basically download this thing you can

00:18:26,610 --> 00:18:30,659
import deep and you can actually play

00:18:29,009 --> 00:18:32,309
with this and it has kind of more or

00:18:30,659 --> 00:18:33,720
less inside of it many of the operations

00:18:32,309 --> 00:18:35,940
that you would otherwise have to code by

00:18:33,720 --> 00:18:37,769
hand if you were to do it by hand so a

00:18:35,940 --> 00:18:41,549
lot of languages have packages to do

00:18:37,769 --> 00:18:44,190
this kind of genetic programming so you

00:18:41,549 --> 00:18:46,769
know Java and C and this is plot this is

00:18:44,190 --> 00:18:48,480
predominantly pythons one and it's

00:18:46,769 --> 00:18:51,240
actually a pretty nice little package so

00:18:48,480 --> 00:18:52,950
I just kind of want to introduce like a

00:18:51,240 --> 00:18:56,279
little example on how to use this thing

00:18:52,950 --> 00:19:00,029
before kind of going on to the Python

00:18:56,279 --> 00:19:03,960
bytecode stuff alright so this here is a

00:19:00,029 --> 00:19:07,309
really basic example on how we do well

00:19:03,960 --> 00:19:12,470
this is genetic algorithms but similar

00:19:07,309 --> 00:19:15,860
so it's kind of more or less composed of

00:19:12,470 --> 00:19:20,220
kind of more or less two different parts

00:19:15,860 --> 00:19:22,200
technically three so it's kind of a

00:19:20,220 --> 00:19:23,580
little using I always hate frameworks

00:19:22,200 --> 00:19:25,080
because to some extent there's that

00:19:23,580 --> 00:19:26,610
initial learning curve before you

00:19:25,080 --> 00:19:27,809
actually get good at it and it feels

00:19:26,610 --> 00:19:31,320
like you're doing the hard thing first

00:19:27,809 --> 00:19:32,970
which being lazy I don't like so there's

00:19:31,320 --> 00:19:36,450
two things there it's got creator in

00:19:32,970 --> 00:19:38,039
toolbox right so toolbox is relatively

00:19:36,450 --> 00:19:40,320
easy to just straightforward out now

00:19:38,039 --> 00:19:41,999
with it what it is it's kind of operates

00:19:40,320 --> 00:19:44,700
like the partial function you know so

00:19:41,999 --> 00:19:46,740
from func tools import partial so what

00:19:44,700 --> 00:19:50,070
happens is so for instance our toolbox

00:19:46,740 --> 00:19:53,220
register and we got a name attr ball and

00:19:50,070 --> 00:19:55,320
we say ok we're going to make a function

00:19:53,220 --> 00:19:57,899
that's called attr ball and it's going

00:19:55,320 --> 00:19:58,919
to be the function random dot R and int

00:19:57,899 --> 00:20:00,059
which I'm sure

00:19:58,919 --> 00:20:02,820
we're familiar with the parameters

00:20:00,059 --> 00:20:05,239
override it of zero and one and inside

00:20:02,820 --> 00:20:08,609
the deep toolbox it's just got literally

00:20:05,239 --> 00:20:11,629
self dot ATT up balled equals partial

00:20:08,609 --> 00:20:15,690
random dot R and end parameters zero one

00:20:11,629 --> 00:20:17,700
right no frills the other one is we've

00:20:15,690 --> 00:20:19,529
got the Creator in the deep toolbox

00:20:17,700 --> 00:20:21,659
which basically is kind of the same

00:20:19,529 --> 00:20:24,690
thing for classes so what happens is

00:20:21,659 --> 00:20:26,940
when we go so create or create

00:20:24,690 --> 00:20:29,039
individual and then you give it a class

00:20:26,940 --> 00:20:31,350
array dot array and then you give it

00:20:29,039 --> 00:20:33,749
keyword overrides so what it does is it

00:20:31,350 --> 00:20:35,669
literally goes so the namespace inside

00:20:33,749 --> 00:20:38,220
the Creator creates a class called

00:20:35,669 --> 00:20:40,830
individual which is an instance of the

00:20:38,220 --> 00:20:42,960
array class with an overrated

00:20:40,830 --> 00:20:44,700
constructor setting the values of type

00:20:42,960 --> 00:20:47,369
code to be and fitness equals blah blah

00:20:44,700 --> 00:20:49,980
blah so it's kind of a general purpose

00:20:47,369 --> 00:20:51,690
tool and so what you do in this

00:20:49,980 --> 00:20:53,929
framework is you literally create or

00:20:51,690 --> 00:20:56,549
create your classes so your individual

00:20:53,929 --> 00:20:59,159
and then create toolbox register

00:20:56,549 --> 00:21:02,369
functions so you register mutate select

00:20:59,159 --> 00:21:04,350
evaluate mate and then what happens is

00:21:02,369 --> 00:21:06,059
you basically pass it over to one of the

00:21:04,350 --> 00:21:09,149
algorithms inside the deep pool boxing

00:21:06,059 --> 00:21:10,980
you scope solve so in this case we've

00:21:09,149 --> 00:21:12,989
got a simple and we just supply the

00:21:10,980 --> 00:21:14,759
parameters that we want so the crossover

00:21:12,989 --> 00:21:16,529
probability the mutation probability the

00:21:14,759 --> 00:21:17,669
number of generations and we've got a

00:21:16,529 --> 00:21:20,460
Hall of Fame to collect the best

00:21:17,669 --> 00:21:22,049
individual over the ball and then we

00:21:20,460 --> 00:21:26,009
print the top individual Hall of Fame

00:21:22,049 --> 00:21:28,230
index zero alright so basically that one

00:21:26,009 --> 00:21:29,970
there just is a it's popular it's a

00:21:28,230 --> 00:21:33,029
population of arrays that consists of

00:21:29,970 --> 00:21:35,940
bytes zero and one the fitness evaluated

00:21:33,029 --> 00:21:37,259
to be the sum of those bytes so what

00:21:35,940 --> 00:21:38,970
will happen is over time and we can run

00:21:37,259 --> 00:21:40,409
this program if you want it'll just

00:21:38,970 --> 00:21:43,289
devolve one one one one one more month

00:21:40,409 --> 00:21:47,220
at the end of the generations so that's

00:21:43,289 --> 00:21:48,629
an example use of deep and we noticed

00:21:47,220 --> 00:21:50,730
that in this we're kind of using some of

00:21:48,629 --> 00:21:54,960
the inbuilt functions so about mutation

00:21:50,730 --> 00:21:56,549
flip bit with a probability of 0.5 0.05

00:21:54,960 --> 00:21:58,859
so what it does is it you know it just

00:21:56,549 --> 00:22:00,119
scans through the thing and based on

00:21:58,859 --> 00:22:01,649
that probability it just flips the bit

00:22:00,119 --> 00:22:03,629
between 0 and 1 and that's an inbuilt

00:22:01,649 --> 00:22:08,759
thing in the toolbox it you just plug

00:22:03,629 --> 00:22:12,269
and play so it's nice so like that's

00:22:08,759 --> 00:22:12,870
really quite nice but the tree kind of

00:22:12,269 --> 00:22:14,430
represent a

00:22:12,870 --> 00:22:16,290
with treat reversals and sub Creek

00:22:14,430 --> 00:22:18,210
crossovers and mutations generating

00:22:16,290 --> 00:22:19,380
random trees and the registration of all

00:22:18,210 --> 00:22:21,870
the different types of functions that

00:22:19,380 --> 00:22:23,850
you can put in your tree is a lot more

00:22:21,870 --> 00:22:26,309
work so deep has got kind of you've got

00:22:23,850 --> 00:22:28,080
covered and what it's done is its kind

00:22:26,309 --> 00:22:29,760
of more or less it's done the hard yards

00:22:28,080 --> 00:22:32,370
for you so you can just say all right I

00:22:29,760 --> 00:22:34,559
want a set of little nodes and the trees

00:22:32,370 --> 00:22:36,690
there so the set of nodes in the trees

00:22:34,559 --> 00:22:38,700
is called the primitive set and so I

00:22:36,690 --> 00:22:40,680
want in there I want the operator add as

00:22:38,700 --> 00:22:44,010
one of the nodes in my trees that

00:22:40,680 --> 00:22:46,080
program can evolve so we say it's

00:22:44,010 --> 00:22:47,610
primitive set dot add primitive and then

00:22:46,080 --> 00:22:50,700
we operated on ADD which is just the

00:22:47,610 --> 00:22:52,559
plus operation and we say it's got arity

00:22:50,700 --> 00:22:55,650
of two which means it just takes two

00:22:52,559 --> 00:22:57,929
things so it's not complicated so add

00:22:55,650 --> 00:23:02,420
primitive operator dot negative with the

00:22:57,929 --> 00:23:02,420
parameter of one input all right

00:23:02,540 --> 00:23:08,940
there's this thing called an ephemeral

00:23:04,740 --> 00:23:10,679
constraint which is basically it's so in

00:23:08,940 --> 00:23:12,540
that case it generates a random number

00:23:10,679 --> 00:23:16,130
between minus one and one created on the

00:23:12,540 --> 00:23:20,520
creation of a tree it's a bit bit of a

00:23:16,130 --> 00:23:22,230
yeah and we saw we create the

00:23:20,520 --> 00:23:25,580
individuals which are consisting of the

00:23:22,230 --> 00:23:28,830
trees we say all right we want

00:23:25,580 --> 00:23:34,250
population to be ramped half-and-half

00:23:28,830 --> 00:23:37,080
trees we just more plug-and-play we want

00:23:34,250 --> 00:23:38,010
now I suppose that thing that we want

00:23:37,080 --> 00:23:42,120
here is what we're doing is we're doing

00:23:38,010 --> 00:23:44,670
symbolic expression so evaluate our

00:23:42,120 --> 00:23:47,370
created function over the range minus

00:23:44,670 --> 00:23:49,320
ten to ten so much sorry minus one to

00:23:47,370 --> 00:23:51,300
one which is divided by ten and we have

00:23:49,320 --> 00:23:53,370
divined for ourself and evaluate

00:23:51,300 --> 00:23:54,840
expression so that's probably the most

00:23:53,370 --> 00:23:55,980
complicated part which is kind of more

00:23:54,840 --> 00:23:58,380
or less defining the fitness function

00:23:55,980 --> 00:24:01,200
for our trees so in this case it's just

00:23:58,380 --> 00:24:03,090
returning the sum squared errors in

00:24:01,200 --> 00:24:04,980
comparison with X to the power four

00:24:03,090 --> 00:24:07,320
minus X to the power 3 minus X power 1

00:24:04,980 --> 00:24:10,200
minus X so it's kind of what we did

00:24:07,320 --> 00:24:12,480
before in our conceptual example but

00:24:10,200 --> 00:24:15,450
this is actually in deep in using the

00:24:12,480 --> 00:24:21,140
framework and you know plugging and

00:24:15,450 --> 00:24:21,140
playing is nice so why not use it now

00:24:21,190 --> 00:24:28,169
I suppose one of the things that like I

00:24:24,479 --> 00:24:31,029
find trees a little bit ugly because

00:24:28,169 --> 00:24:33,099
traversing and using trees when I your

00:24:31,029 --> 00:24:36,639
program it out tends to involve a lot of

00:24:33,099 --> 00:24:38,440
recursive functions and I my mind kind

00:24:36,639 --> 00:24:39,759
of I just like how do I write a

00:24:38,440 --> 00:24:43,330
recursive function again right that's

00:24:39,759 --> 00:24:45,070
right but the thing is that when you're

00:24:43,330 --> 00:24:46,509
actually using these things and when it

00:24:45,070 --> 00:24:48,669
comes to an execution of the tree to

00:24:46,509 --> 00:24:50,470
evaluate it what happens is the Python

00:24:48,669 --> 00:24:52,029
algorithm actually has to go through you

00:24:50,470 --> 00:24:55,450
know maps and passes and all this kind

00:24:52,029 --> 00:24:59,649
of thing but this is kind of a little

00:24:55,450 --> 00:25:00,970
portion of the deep package code there's

00:24:59,649 --> 00:25:03,519
actually kind of inspired I think it's

00:25:00,970 --> 00:25:05,710
from simp I so if anybody's use symbolic

00:25:03,519 --> 00:25:07,539
Python here where what it does is

00:25:05,710 --> 00:25:08,919
actually when it compiles and evaluates

00:25:07,539 --> 00:25:11,070
one of these trees what it does is it

00:25:08,919 --> 00:25:12,399
actually converts the tree into a string

00:25:11,070 --> 00:25:14,889
all right

00:25:12,399 --> 00:25:18,039
actually formats that into a Python

00:25:14,889 --> 00:25:21,279
lambda code string and then calls eval

00:25:18,039 --> 00:25:23,349
on that so if you know anything it kind

00:25:21,279 --> 00:25:25,479
of you converts to that Python string

00:25:23,349 --> 00:25:27,580
and then it reek hydrates that into an

00:25:25,479 --> 00:25:29,049
abstract syntax tree thing and then it

00:25:27,580 --> 00:25:31,389
flattens that back again into bytecode

00:25:29,049 --> 00:25:35,830
and then it runs that which is a little

00:25:31,389 --> 00:25:37,989
bit ugly I was reading in motivation for

00:25:35,830 --> 00:25:39,279
this talk I was actually just browsing

00:25:37,989 --> 00:25:40,929
around the Internet's and thinking war

00:25:39,279 --> 00:25:43,029
let's let's come up with something

00:25:40,929 --> 00:25:44,649
interesting and there was an example of

00:25:43,029 --> 00:25:46,960
a guy that kind of fits alright this is

00:25:44,649 --> 00:25:49,499
crap maybe we can do better so it's like

00:25:46,960 --> 00:25:54,129
let's evolve Python bytecode directly

00:25:49,499 --> 00:25:57,570
right it's kinda like oh my god anyway

00:25:54,129 --> 00:25:57,570
we got five minutes left

00:25:58,979 --> 00:26:08,889
all right I was only just beginning to

00:26:01,149 --> 00:26:10,179
get to it um all right so python

00:26:08,889 --> 00:26:13,119
bytecode is one of those things that

00:26:10,179 --> 00:26:15,309
kind of like it's it's kind of scary in

00:26:13,119 --> 00:26:17,139
a way because to some extent some parts

00:26:15,309 --> 00:26:19,299
of it are just undocumented so you don't

00:26:17,139 --> 00:26:20,559
find nice big tutorials on this is what

00:26:19,299 --> 00:26:23,950
that means this is what the other means

00:26:20,559 --> 00:26:26,139
and let's put it all together nicely so

00:26:23,950 --> 00:26:27,460
there's really kind of I'm just I want

00:26:26,139 --> 00:26:30,369
to give you like the tools so that you

00:26:27,460 --> 00:26:31,530
can go and fiddle alright so I'm just

00:26:30,369 --> 00:26:35,970
gonna

00:26:31,530 --> 00:26:37,400
just minimize this thing here no we're

00:26:35,970 --> 00:26:43,980
going to load up a little Python shell

00:26:37,400 --> 00:26:46,020
so you can go Python 3 alright everybody

00:26:43,980 --> 00:26:50,790
reading alright so what we're gonna do

00:26:46,020 --> 00:26:52,140
is we're going to define a function just

00:26:50,790 --> 00:26:59,670
let's make something up that's bit

00:26:52,140 --> 00:27:01,860
garbage what I can spell alright so

00:26:59,670 --> 00:27:04,800
we've just defined a function a so now

00:27:01,860 --> 00:27:06,410
we can look inside a dir a we get a

00:27:04,800 --> 00:27:09,300
whole lot of stuff that's a bit scary

00:27:06,410 --> 00:27:11,970
but what we do is we can we like if we

00:27:09,300 --> 00:27:15,150
can actually type type a and we notice

00:27:11,970 --> 00:27:16,950
that we've got a class function now if

00:27:15,150 --> 00:27:22,170
we like we can actually our instantiate

00:27:16,950 --> 00:27:27,090
a farm class function so we go so we're

00:27:22,170 --> 00:27:30,300
creating we can actually create

00:27:27,090 --> 00:27:31,770
functions using constructors it's freaky

00:27:30,300 --> 00:27:33,270
right so we've got this thing called the

00:27:31,770 --> 00:27:36,750
code and we've got a dictionary of the

00:27:33,270 --> 00:27:38,550
Global's now it's kind of like what is

00:27:36,750 --> 00:27:39,930
like we understand that there's a global

00:27:38,550 --> 00:27:41,820
dick and the rest are optional but

00:27:39,930 --> 00:27:44,880
there's a thing called the code object

00:27:41,820 --> 00:27:49,590
so we can actually access the functions

00:27:44,880 --> 00:27:52,380
code object by going a dot code but it's

00:27:49,590 --> 00:27:58,800
a code object all right now we can look

00:27:52,380 --> 00:28:01,260
inside the code we know there's a lot

00:27:58,800 --> 00:28:10,430
stuff but none of that's important so

00:28:01,260 --> 00:28:13,560
what we can do is we can go type a dot

00:28:10,430 --> 00:28:15,990
we've got a code class which we can

00:28:13,560 --> 00:28:18,330
instantiate directly so in defining a

00:28:15,990 --> 00:28:20,520
function we've got we need to supply a

00:28:18,330 --> 00:28:24,660
code class which we can create also by

00:28:20,520 --> 00:28:29,400
instructors now all of this here we've

00:28:24,660 --> 00:28:31,380
got 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

00:28:29,400 --> 00:28:33,960
different little pieces of information

00:28:31,380 --> 00:28:35,880
that go into creating what is the code

00:28:33,960 --> 00:28:38,910
object that is essentially the

00:28:35,880 --> 00:28:41,400
encapsulation of the byte code that goes

00:28:38,910 --> 00:28:44,820
into the Python virtual machine and

00:28:41,400 --> 00:28:45,299
executes salts ludar now I think we're

00:28:44,820 --> 00:28:49,590
fairly

00:28:45,299 --> 00:28:50,610
up for time aren't we two minutes all

00:28:49,590 --> 00:29:03,570
right I'm just gonna hand it over to

00:28:50,610 --> 00:29:04,489
questions but um thank you at what's

00:29:03,570 --> 00:29:07,619
that

00:29:04,489 --> 00:29:12,480
for what oh yeah sure you can yeah okay

00:29:07,619 --> 00:29:15,049
so we can go a dot code dot dot and it's

00:29:12,480 --> 00:29:20,159
Co where is it

00:29:15,049 --> 00:29:22,109
Co code that's the code string it's

00:29:20,159 --> 00:29:24,210
pretty small so actually that

00:29:22,109 --> 00:29:27,659
corresponds to what is it it's like load

00:29:24,210 --> 00:29:31,489
argument one add in return like argument

00:29:27,659 --> 00:29:33,029
one load argument to an advert oh yeah

00:29:31,489 --> 00:29:36,539
thanks for the talk

00:29:33,029 --> 00:29:38,580
is this bottle of evolving functions

00:29:36,539 --> 00:29:41,789
actually useful so it does it give us

00:29:38,580 --> 00:29:43,769
expressions that otherwise are harder to

00:29:41,789 --> 00:29:46,190
get or like is there a legitimate

00:29:43,769 --> 00:29:50,340
benefit to this absolutely

00:29:46,190 --> 00:29:54,960
okay so genetic algorithms are at the

00:29:50,340 --> 00:29:56,159
process of evolving programs so it's

00:29:54,960 --> 00:29:57,590
pretty difficult to say that a computer

00:29:56,159 --> 00:30:00,710
can be better at what you do then you do

00:29:57,590 --> 00:30:03,269
like that's not on the horizon just yet

00:30:00,710 --> 00:30:04,559
but what it kind of can do is to some

00:30:03,269 --> 00:30:07,019
extent it can kind of come up with

00:30:04,559 --> 00:30:09,690
things that if they're small and concise

00:30:07,019 --> 00:30:11,149
can be difficult to achieve otherwise so

00:30:09,690 --> 00:30:14,159
one of the things that evolutionary

00:30:11,149 --> 00:30:15,690
genetic programming has been used very

00:30:14,159 --> 00:30:19,369
successfully to do for instance is to

00:30:15,690 --> 00:30:22,019
evolve electronic circuits as an example

00:30:19,369 --> 00:30:23,249
so like I think for there's a

00:30:22,019 --> 00:30:25,980
competition called the humans

00:30:23,249 --> 00:30:27,690
competition to use genetic program to

00:30:25,980 --> 00:30:30,029
come up with actual novel designs of

00:30:27,690 --> 00:30:32,399
circuits that either reinvent that it

00:30:30,029 --> 00:30:34,409
are completely novel and useful or are

00:30:32,399 --> 00:30:39,440
actually reinventions of human

00:30:34,409 --> 00:30:41,789
inventions of particular circuits so

00:30:39,440 --> 00:30:44,220
genetic programming can kind of come up

00:30:41,789 --> 00:30:45,299
with rather surprising results that you

00:30:44,220 --> 00:30:46,830
might not otherwise have yet and

00:30:45,299 --> 00:30:51,540
sometimes though it can be difficult to

00:30:46,830 --> 00:30:54,000
attain any other questions

00:30:51,540 --> 00:30:57,230
okay thank you great great talk like I'm

00:30:54,000 --> 00:31:00,590
just going back to when you were on

00:30:57,230 --> 00:31:04,040
looking at deep and you are adding the

00:31:00,590 --> 00:31:07,140
operators as as nodes in your

00:31:04,040 --> 00:31:09,180
evolutionary tree yep I was just

00:31:07,140 --> 00:31:12,870
wondering how do you how do you do loops

00:31:09,180 --> 00:31:14,340
do you does deep ever have a clean way

00:31:12,870 --> 00:31:17,970
of doing this or do you have to define

00:31:14,340 --> 00:31:20,340
functions that map or or act on arrays

00:31:17,970 --> 00:31:22,020
good good question

00:31:20,340 --> 00:31:23,640
so like when we're doing programs

00:31:22,020 --> 00:31:25,950
programming as humans one of the things

00:31:23,640 --> 00:31:27,030
that we do do a lot of is looping right

00:31:25,950 --> 00:31:30,060
it's just like one of those basic

00:31:27,030 --> 00:31:33,300
elements that we do and include so

00:31:30,060 --> 00:31:34,410
including looping in our evolution right

00:31:33,300 --> 00:31:36,930
there's kind of there's this really

00:31:34,410 --> 00:31:38,610
common pitfall of accidentally evolving

00:31:36,930 --> 00:31:39,900
an infinite loop and then hanging the

00:31:38,610 --> 00:31:41,790
computer right

00:31:39,900 --> 00:31:45,300
I mean hey if it can if it can evolve

00:31:41,790 --> 00:31:48,540
it'll happen is like Murphy's Law so

00:31:45,300 --> 00:31:51,560
with depending on how you represent it

00:31:48,540 --> 00:31:53,880
ah you can include loops quite readily

00:31:51,560 --> 00:31:56,820
but there's a little bit of a kind of

00:31:53,880 --> 00:31:59,310
like creativity of problem so you know

00:31:56,820 --> 00:32:00,600
you can obviously include looping but

00:31:59,310 --> 00:32:03,210
constrain it's such that there is

00:32:00,600 --> 00:32:05,130
literally a maximum iterations that the

00:32:03,210 --> 00:32:07,110
same loop can actually go through before

00:32:05,130 --> 00:32:11,130
it just falls out and goes to the next

00:32:07,110 --> 00:32:14,640
line um there's a there's other things

00:32:11,130 --> 00:32:16,740
so you can actually set like a read of

00:32:14,640 --> 00:32:18,720
people who do like they literally said

00:32:16,740 --> 00:32:22,230
that the maximum execution time of a

00:32:18,720 --> 00:32:23,610
given program is X and if it goes over X

00:32:22,230 --> 00:32:24,690
then we presume it's got an infinite

00:32:23,610 --> 00:32:26,910
loop in it and we assign it like

00:32:24,690 --> 00:32:28,500
negative ten Fitness is an example of

00:32:26,910 --> 00:32:31,920
getting around that and having total

00:32:28,500 --> 00:32:33,990
flexibility in the structure so you know

00:32:31,920 --> 00:32:36,000
if you're if your tree consists of

00:32:33,990 --> 00:32:37,860
operations on arrays right you can

00:32:36,000 --> 00:32:39,990
include an operation that is like a

00:32:37,860 --> 00:32:44,370
lease comprehension of that array and

00:32:39,990 --> 00:32:45,780
obviously that's closed and you know you

00:32:44,370 --> 00:32:48,750
know it's not going to fall in that

00:32:45,780 --> 00:32:50,850
infinite loop trap but yeah there's lots

00:32:48,750 --> 00:32:52,430
of creative freedoms with regards to

00:32:50,850 --> 00:32:56,310
genetic programming

00:32:52,430 --> 00:32:58,820
okay thank you for dr. mark we run up a

00:32:56,310 --> 00:32:58,820
sample question

00:33:00,290 --> 00:33:08,030
thank you you have your mark thank you

00:33:04,050 --> 00:33:08,030

YouTube URL: https://www.youtube.com/watch?v=Lo7k9-tP6Fc


