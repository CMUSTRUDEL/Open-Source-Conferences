Title: Python for Bioinformatics for learning Python
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Martin Schweitzer
https://2016.pycon-au.org/schedule/89/view_talk
In this talk I will explain why Python is an excellent language for learning about bioinformatics.  I intend to make a compelling case in favour of using Python as a first language for teaching bioinformatics. 

I will then explain how bioinformatics can be a useful vehicle for learning Python.

Finally, we will visit a site where users can learn both Python and bioinformatics in a stimulating, engaging and motivating environment.

The talk will assume familiarity with Python, but does not assume any knowledge of bioinformatics.
Captions: 
	00:00:01,129 --> 00:00:06,150
hi everyone so this morning what I

00:00:04,259 --> 00:00:09,269
wanted to do is try and convince people

00:00:06,150 --> 00:00:10,710
basically of two things the first one is

00:00:09,269 --> 00:00:13,290
that python is a great tool for

00:00:10,710 --> 00:00:15,750
bioinformatics and these and I've

00:00:13,290 --> 00:00:18,090
probably given this audience I shouldn't

00:00:15,750 --> 00:00:20,640
have to convince here and the second one

00:00:18,090 --> 00:00:23,160
is that learning about bioinformatics is

00:00:20,640 --> 00:00:25,080
a great way to learn Python and maybe

00:00:23,160 --> 00:00:27,570
have you by the end of the talk you'll

00:00:25,080 --> 00:00:29,939
be convinced of that so first a quick

00:00:27,570 --> 00:00:32,780
disclaimer I'm not a bioinformatician

00:00:29,939 --> 00:00:35,790
I've got computer science background

00:00:32,780 --> 00:00:39,600
idly by informatics is our hobby but if

00:00:35,790 --> 00:00:41,129
any real band for mutations in your your

00:00:39,600 --> 00:00:42,450
probably want to say hey that's wrong

00:00:41,129 --> 00:00:45,180
that's wrong cause that's an

00:00:42,450 --> 00:00:48,120
oversimplification so a little bit about

00:00:45,180 --> 00:00:50,000
me I elected for about seven years but

00:00:48,120 --> 00:00:52,680
have also run a lot of training courses

00:00:50,000 --> 00:00:54,270
training I've run training courses where

00:00:52,680 --> 00:00:56,699
I work at Bureau of Meteorology in

00:00:54,270 --> 00:00:58,320
Python so I've got some experience about

00:00:56,699 --> 00:01:02,070
teaching paths and I love doing it and

00:00:58,320 --> 00:01:05,280
I've also run training courses as I said

00:01:02,070 --> 00:01:08,250
the next point in buy-in from for group

00:01:05,280 --> 00:01:10,080
of mathematicians but these were C++

00:01:08,250 --> 00:01:13,530
courses I taught people doing

00:01:10,080 --> 00:01:16,500
bioinformatics C++ and when doing this

00:01:13,530 --> 00:01:18,900
course I was looking for problems that

00:01:16,500 --> 00:01:22,439
were in their domain so that i could

00:01:18,900 --> 00:01:24,479
teach c++ concepts and when doing that i

00:01:22,439 --> 00:01:27,810
came across this site on the internet

00:01:24,479 --> 00:01:30,119
called Rosalind and what Rosalind is is

00:01:27,810 --> 00:01:32,939
this act with about 300 bioinformatics

00:01:30,119 --> 00:01:34,920
problems you can solve them you submit

00:01:32,939 --> 00:01:37,560
your answer online it checks your answer

00:01:34,920 --> 00:01:40,170
and if you get it correct you get one

00:01:37,560 --> 00:01:42,180
point basically and as you solve more

00:01:40,170 --> 00:01:44,579
and more problems you move up the scale

00:01:42,180 --> 00:01:46,860
and you can rank yourself against other

00:01:44,579 --> 00:01:49,640
people doing it so if anybody's familiar

00:01:46,860 --> 00:01:52,500
with project Euler very similar concept

00:01:49,640 --> 00:01:54,420
but these are bioinformatics problems so

00:01:52,500 --> 00:01:57,240
the problems we're going to see today

00:01:54,420 --> 00:02:00,570
are all based on problems that came off

00:01:57,240 --> 00:02:03,119
Rosalind but I've tried to keep it close

00:02:00,570 --> 00:02:04,590
but not too close so just a quick

00:02:03,119 --> 00:02:06,360
introduction in case you've never heard

00:02:04,590 --> 00:02:08,940
of bioinformatics what is it

00:02:06,360 --> 00:02:11,129
bioinformatics is this multidisciplinary

00:02:08,940 --> 00:02:13,360
field covering computer science biology

00:02:11,129 --> 00:02:16,150
mathematics and statistics

00:02:13,360 --> 00:02:19,510
so what it comes down to is during the

00:02:16,150 --> 00:02:23,500
60s 70s 80s people started sequencing

00:02:19,510 --> 00:02:26,800
DNA from a computer science perspective

00:02:23,500 --> 00:02:29,980
DNA is just this long string of a C's GS

00:02:26,800 --> 00:02:31,570
and T's it's a lot more subtle if

00:02:29,980 --> 00:02:35,260
anybody went to Daria's talk yesterday

00:02:31,570 --> 00:02:37,090
about bioinformatics often you'll have

00:02:35,260 --> 00:02:40,660
missing things you'll have gaps you'll

00:02:37,090 --> 00:02:43,420
have transcription errors but if you're

00:02:40,660 --> 00:02:46,750
a programmer looking at DNA basically

00:02:43,420 --> 00:02:50,230
you say this is a string fantastic

00:02:46,750 --> 00:02:51,790
so I started typing in some random stuff

00:02:50,230 --> 00:02:53,650
there and I don't know if you've ever

00:02:51,790 --> 00:02:55,840
tried typing in for random characters

00:02:53,650 --> 00:02:58,000
it's actually quite hard so I got to the

00:02:55,840 --> 00:03:00,190
end of the first line and I thought are

00:02:58,000 --> 00:03:03,430
I probably much easier to write a quick

00:03:00,190 --> 00:03:05,560
Python program so I wrote two lines of

00:03:03,430 --> 00:03:10,330
Python and it was a lot quicker and that

00:03:05,560 --> 00:03:12,730
generated that previous slide so so

00:03:10,330 --> 00:03:15,370
that's not a real bioinformatics

00:03:12,730 --> 00:03:16,660
problem but it's good for generating

00:03:15,370 --> 00:03:19,840
test data and I have used it for

00:03:16,660 --> 00:03:21,850
generating test stages okay the first

00:03:19,840 --> 00:03:24,400
problem we're going to look at is to

00:03:21,850 --> 00:03:29,050
determine what we call the GC content of

00:03:24,400 --> 00:03:32,320
DNA and so we've got this string it's

00:03:29,050 --> 00:03:34,600
got AC G and T at an engine in cytosine

00:03:32,320 --> 00:03:38,260
and thymine and we won't find what

00:03:34,600 --> 00:03:41,410
percentage of a particular strand of DNA

00:03:38,260 --> 00:03:43,630
or sequence of DNA is c's and g's

00:03:41,410 --> 00:03:44,440
because for some reason by

00:03:43,630 --> 00:03:46,540
informaticians

00:03:44,440 --> 00:03:48,790
found that those areas that are rich in

00:03:46,540 --> 00:03:50,380
what they call the nitrogenous bases are

00:03:48,790 --> 00:03:54,250
actually far more interesting than the

00:03:50,380 --> 00:03:56,160
areas that aren't so when I run a Python

00:03:54,250 --> 00:03:58,420
course after the first morning most

00:03:56,160 --> 00:04:01,209
people would be able to write this

00:03:58,420 --> 00:04:03,010
program and I think everybody should be

00:04:01,209 --> 00:04:04,180
able to follow it basically we go

00:04:03,010 --> 00:04:07,300
through the string character by

00:04:04,180 --> 00:04:10,269
character and if it's a coj we add one

00:04:07,300 --> 00:04:13,299
to a counter so it works but it's not

00:04:10,269 --> 00:04:15,100
particularly pythonic so the next thing

00:04:13,299 --> 00:04:18,310
we do is we say well let's look at using

00:04:15,100 --> 00:04:21,370
a list comprehension so basically we say

00:04:18,310 --> 00:04:25,720
okay let's take each base in the string

00:04:21,370 --> 00:04:27,160
and if it's a co g will count it we'll

00:04:25,720 --> 00:04:29,320
add it to this list and

00:04:27,160 --> 00:04:31,930
at the end we return the percentage of

00:04:29,320 --> 00:04:34,810
season genes divided by the percentage

00:04:31,930 --> 00:04:36,630
or the length of the whole string so to

00:04:34,810 --> 00:04:40,770
me that's a little bit more elegant

00:04:36,630 --> 00:04:44,260
however we can go one step further and

00:04:40,770 --> 00:04:47,530
we use the count method of the string

00:04:44,260 --> 00:04:49,830
and we say can't the Gees canvases and

00:04:47,530 --> 00:04:52,660
divided by the length of the string and

00:04:49,830 --> 00:04:55,480
to me this is what's great about using

00:04:52,660 --> 00:04:56,920
pathan for bioinformatics that it just

00:04:55,480 --> 00:04:58,740
seems that Python was designed to

00:04:56,920 --> 00:05:01,750
yourself exactly this kind of problem

00:04:58,740 --> 00:05:03,400
it's clear it's simple somebody looking

00:05:01,750 --> 00:05:05,200
at their program should be able to know

00:05:03,400 --> 00:05:07,360
exactly what it does assuming you know

00:05:05,200 --> 00:05:11,140
count but the other side of the equation

00:05:07,360 --> 00:05:13,780
is that this is actually a real-world

00:05:11,140 --> 00:05:16,000
problem a lot of time when teaching

00:05:13,780 --> 00:05:17,830
programming we make up all sorts of

00:05:16,000 --> 00:05:20,080
problems like calculate how much paint

00:05:17,830 --> 00:05:22,720
you need to paint a room for meters by 5

00:05:20,080 --> 00:05:24,820
meters whatever nobody ever needs to do

00:05:22,720 --> 00:05:27,610
that but this is something people

00:05:24,820 --> 00:05:30,550
actually use so the next one we'll look

00:05:27,610 --> 00:05:33,460
at is what's called reverse complement

00:05:30,550 --> 00:05:35,830
so I think everybody is aware that DNA

00:05:33,460 --> 00:05:39,910
is a double helix somebody got a Nobel

00:05:35,830 --> 00:05:43,150
Prize for discovering that and G's

00:05:39,910 --> 00:05:46,360
always bind with CS and T's always bind

00:05:43,150 --> 00:05:48,430
with a z' so if we have a strand of DNA

00:05:46,360 --> 00:05:52,210
we can either look at it in one

00:05:48,430 --> 00:05:53,800
direction going GTCC G etc or we can

00:05:52,210 --> 00:05:57,160
look at it in the other direction going

00:05:53,800 --> 00:05:59,080
CCA G et cetera so for example if we're

00:05:57,160 --> 00:06:03,040
looking for the sequence GAC

00:05:59,080 --> 00:06:04,240
we may not see it in the top row but

00:06:03,040 --> 00:06:05,980
when we're looking at the bottom row

00:06:04,240 --> 00:06:08,650
from right to left we do see it and

00:06:05,980 --> 00:06:10,870
that's called the reverse complement so

00:06:08,650 --> 00:06:14,440
the second problem is given a sequence

00:06:10,870 --> 00:06:17,590
of DNA such as the top row find out what

00:06:14,440 --> 00:06:21,580
the bottom row is it's not particularly

00:06:17,590 --> 00:06:23,680
hard but once again in doing this we

00:06:21,580 --> 00:06:25,750
find it's a very natural mapping for

00:06:23,680 --> 00:06:29,320
dictionary a dictionary works perfect

00:06:25,750 --> 00:06:31,570
for this sort of problem and once again

00:06:29,320 --> 00:06:35,020
a very simple solution where we go

00:06:31,570 --> 00:06:38,770
through each base and we create a list

00:06:35,020 --> 00:06:40,570
and then at the end we return the

00:06:38,770 --> 00:06:44,560
reverse of the list after having met

00:06:40,570 --> 00:06:47,860
there's two the T's and the G's - the

00:06:44,560 --> 00:06:49,870
C's so once again somebody after a half

00:06:47,860 --> 00:06:51,430
a day of learning Python and in these

00:06:49,870 --> 00:06:55,570
courses should be able to do that

00:06:51,430 --> 00:06:57,490
however we can do better and so in this

00:06:55,570 --> 00:07:00,190
one we once again have our dictionary

00:06:57,490 --> 00:07:03,430
but in this time this time we use a list

00:07:00,190 --> 00:07:07,000
comprehension and I've used the erase

00:07:03,430 --> 00:07:09,840
last notation to reverse the list and I

00:07:07,000 --> 00:07:14,890
think a more elegant slightly more

00:07:09,840 --> 00:07:18,610
robust solution I've also used the join

00:07:14,890 --> 00:07:21,070
operator so hopefully people are

00:07:18,610 --> 00:07:22,750
starting to get convinced now if the

00:07:21,070 --> 00:07:24,460
next problem we'll look at it is one

00:07:22,750 --> 00:07:26,680
that actually we learned about in

00:07:24,460 --> 00:07:28,090
computer science long before we started

00:07:26,680 --> 00:07:31,030
looking at banned phonetics called

00:07:28,090 --> 00:07:32,770
Hamming distance so if anyone was at

00:07:31,030 --> 00:07:35,020
Darrius talk yesterday she spoke about

00:07:32,770 --> 00:07:37,960
single nucleotide polymorphisms or snips

00:07:35,020 --> 00:07:39,400
where you've got to sequence of DNA and

00:07:37,960 --> 00:07:42,760
I've got one difference between the two

00:07:39,400 --> 00:07:45,130
one of the bases is are different other

00:07:42,760 --> 00:07:48,450
reasons is when we sequencing DNA

00:07:45,130 --> 00:07:50,710
often they errors in the sequencing so

00:07:48,450 --> 00:07:53,500
instead of recording a see it may record

00:07:50,710 --> 00:07:56,710
a gene so we may say okay we'll consider

00:07:53,500 --> 00:07:59,050
two pieces of DNA to be the same if they

00:07:56,710 --> 00:08:01,210
differ by less than three in less than

00:07:59,050 --> 00:08:03,040
three positions and so that three

00:08:01,210 --> 00:08:04,840
positions were these tube things that is

00:08:03,040 --> 00:08:06,640
called the Hamming distance in other

00:08:04,840 --> 00:08:08,920
words in that example we have they're

00:08:06,640 --> 00:08:11,380
having distance of three so once again

00:08:08,920 --> 00:08:13,960
you know somebody's learnt a bit usually

00:08:11,380 --> 00:08:16,600
the courses are teach at the bureau the

00:08:13,960 --> 00:08:18,400
people come from C or C++ or Java

00:08:16,600 --> 00:08:21,060
background so they're used to this

00:08:18,400 --> 00:08:25,540
procedural way of looking at things and

00:08:21,060 --> 00:08:27,370
because we've got two sequences it's a

00:08:25,540 --> 00:08:31,210
little bit more tempting to say for iron

00:08:27,370 --> 00:08:33,250
range length of left hand side as RAM

00:08:31,210 --> 00:08:36,669
and Hettinger said if you need to say

00:08:33,250 --> 00:08:38,380
iron range learn something you there's

00:08:36,669 --> 00:08:40,300
probably a better way so I thought okay

00:08:38,380 --> 00:08:42,310
will it can I come up with a better way

00:08:40,300 --> 00:08:45,430
so I thought about it a bit and I came

00:08:42,310 --> 00:08:47,080
up with this idea create two sets the

00:08:45,430 --> 00:08:49,450
first set is the position and the base

00:08:47,080 --> 00:08:51,640
of the left hand string the second set

00:08:49,450 --> 00:08:53,250
is the set in our position and base of

00:08:51,640 --> 00:08:55,889
the right hand string

00:08:53,250 --> 00:08:57,750
and using set difference it will tell us

00:08:55,889 --> 00:08:59,040
how many difference but I didn't really

00:08:57,750 --> 00:09:01,439
like that because it's not really

00:08:59,040 --> 00:09:02,819
telling us what we're doing so I came up

00:09:01,439 --> 00:09:05,910
with what I think is a slightly better

00:09:02,819 --> 00:09:07,980
solution what I've done now is I've

00:09:05,910 --> 00:09:10,769
zipped the two left hand side and right

00:09:07,980 --> 00:09:12,949
hand side together I've said pick out

00:09:10,769 --> 00:09:15,720
all the tuples where they different and

00:09:12,949 --> 00:09:18,899
count how many you've got so once again

00:09:15,720 --> 00:09:21,149
it's down to one return statement but

00:09:18,899 --> 00:09:23,699
what I like about this and where we come

00:09:21,149 --> 00:09:26,610
back to learning Python is I think it's

00:09:23,699 --> 00:09:29,610
a really nice motivating example for the

00:09:26,610 --> 00:09:31,379
zip operation some people have

00:09:29,610 --> 00:09:33,990
difficulty getting their head around zip

00:09:31,379 --> 00:09:36,180
but if you look at that those two rows

00:09:33,990 --> 00:09:38,029
and you think okay what I'm doing is I'm

00:09:36,180 --> 00:09:40,949
zipping them together like a zip and

00:09:38,029 --> 00:09:44,490
where I'm counting wherever the two bits

00:09:40,949 --> 00:09:49,139
don't match so to me that that's very

00:09:44,490 --> 00:09:50,459
clean very concise and when I look at

00:09:49,139 --> 00:09:54,649
that I think yeah I'm pretty sure that

00:09:50,459 --> 00:09:56,519
that's doing exactly what I want okay

00:09:54,649 --> 00:10:00,600
get to slightly more interesting

00:09:56,519 --> 00:10:02,189
problems now finding motifs so the first

00:10:00,600 --> 00:10:04,230
thing I'll explain what a camera is and

00:10:02,189 --> 00:10:06,540
then we'll get onto my tears so motifs

00:10:04,230 --> 00:10:09,629
are short recurring sequences or

00:10:06,540 --> 00:10:12,689
patterns in a DNA that are presumed to

00:10:09,629 --> 00:10:16,439
have a biological function so if we see

00:10:12,689 --> 00:10:19,050
the same pattern repeating in DNA we say

00:10:16,439 --> 00:10:20,939
well maybe there's some reason why this

00:10:19,050 --> 00:10:23,550
pattern is repeating because nature

00:10:20,939 --> 00:10:26,009
generally is fairly pursue - it doesn't

00:10:23,550 --> 00:10:27,329
like to waste so when there is when

00:10:26,009 --> 00:10:29,910
there are repeats there's often a reason

00:10:27,329 --> 00:10:33,089
and so we look at some DNA we say we

00:10:29,910 --> 00:10:36,629
want to find out given this string of

00:10:33,089 --> 00:10:37,769
maybe a million bases look for the

00:10:36,629 --> 00:10:40,350
things that are the most commonly

00:10:37,769 --> 00:10:43,410
repeating and we may say I'm looking

00:10:40,350 --> 00:10:45,480
interested in sort of sequences of ten

00:10:43,410 --> 00:10:48,269
and this is where this idea of a k-mer

00:10:45,480 --> 00:10:51,899
comes in so if we're looking for seven

00:10:48,269 --> 00:10:54,660
long it's called a 7 7 - m ER i guess

00:10:51,899 --> 00:10:57,149
know from polymer and if we're looking

00:10:54,660 --> 00:11:00,899
for 12 it's a 12 month cetera so the

00:10:57,149 --> 00:11:03,809
first program is all just you know given

00:11:00,899 --> 00:11:07,110
some DNA print out all the in this case

00:11:03,809 --> 00:11:10,440
five Mo's as equal to five for so we use

00:11:07,110 --> 00:11:12,870
Yusuke for camera and so that's pretty

00:11:10,440 --> 00:11:15,269
straightforward we've introduced the

00:11:12,870 --> 00:11:17,310
slice operator once again nice

00:11:15,269 --> 00:11:18,870
motivating example but we're not

00:11:17,310 --> 00:11:20,279
interested in listing them we're

00:11:18,870 --> 00:11:24,029
interesting in interested in counting

00:11:20,279 --> 00:11:25,649
the most common ones so we'll just go to

00:11:24,029 --> 00:11:28,440
our next program and this is where we do

00:11:25,649 --> 00:11:33,209
count the most common ones and once

00:11:28,440 --> 00:11:35,250
again it's a very procedural program we

00:11:33,209 --> 00:11:38,279
start with an empty dictionary which is

00:11:35,250 --> 00:11:40,470
a common way of counting things we go

00:11:38,279 --> 00:11:41,640
through all the cameras and we if

00:11:40,470 --> 00:11:44,130
they're not in the dictionary we add

00:11:41,640 --> 00:11:48,450
them you'll notice have got an if

00:11:44,130 --> 00:11:50,070
statement in that program generally if

00:11:48,450 --> 00:11:52,680
you can get rid of an if statement your

00:11:50,070 --> 00:11:54,480
program gets simpler so what I've done

00:11:52,680 --> 00:11:57,060
in the next slide is I've used the

00:11:54,480 --> 00:12:00,899
default dick from the collections module

00:11:57,060 --> 00:12:02,700
and that just gets rid of the thing and

00:12:00,899 --> 00:12:04,950
then the last two lands all equals

00:12:02,700 --> 00:12:08,130
sorted so what that LAN is doing is

00:12:04,950 --> 00:12:10,529
we're sorting by the value not by the

00:12:08,130 --> 00:12:12,630
key because we want the most common so

00:12:10,529 --> 00:12:14,640
the ones that appear most frequently

00:12:12,630 --> 00:12:17,149
that we'll put the most common ones at

00:12:14,640 --> 00:12:24,120
the end and we're printing the last five

00:12:17,149 --> 00:12:27,000
items in that dictionary so but it's not

00:12:24,120 --> 00:12:29,130
a very elegant as far as I'm concerned

00:12:27,000 --> 00:12:33,839
program so let's see if we can do better

00:12:29,130 --> 00:12:35,670
I use the counter from collections I use

00:12:33,839 --> 00:12:38,610
a list comprehension to find all the

00:12:35,670 --> 00:12:41,820
comers very straightforward and I just

00:12:38,610 --> 00:12:43,740
say print the most common five to me

00:12:41,820 --> 00:12:45,510
that's just great it's like Python was

00:12:43,740 --> 00:12:47,880
written for bioinformatics when you do

00:12:45,510 --> 00:12:50,160
stuff like this and is so expressive

00:12:47,880 --> 00:12:51,890
nobody can read that and not knowing

00:12:50,160 --> 00:12:55,260
you're looking for the most five common

00:12:51,890 --> 00:12:57,120
k-mers okay we'll have they

00:12:55,260 --> 00:12:58,440
if people's brains have heard any better

00:12:57,120 --> 00:13:00,779
I should have mentioned at the beginning

00:12:58,440 --> 00:13:03,480
all these slides will be available so

00:13:00,779 --> 00:13:06,899
don't worry too much so we're going to

00:13:03,480 --> 00:13:09,089
look at rabbits over second Fibonacci

00:13:06,899 --> 00:13:10,920
numbers I think everybody's written a

00:13:09,089 --> 00:13:14,370
Fibonacci routine if you've ever written

00:13:10,920 --> 00:13:17,760
a computer program it's at this stage

00:13:14,370 --> 00:13:20,460
nothing special about it one thing we do

00:13:17,760 --> 00:13:23,760
have is I've used that top line pack

00:13:20,460 --> 00:13:25,710
in that land for Iron Range n child

00:13:23,760 --> 00:13:28,200
comma parent equals parent come a parent

00:13:25,710 --> 00:13:31,020
plus child in other words for each

00:13:28,200 --> 00:13:33,390
generation we each parent has one child

00:13:31,020 --> 00:13:34,770
and the number of parents is equal to

00:13:33,390 --> 00:13:37,920
the number of parents plus the number of

00:13:34,770 --> 00:13:39,120
children because the children grow up

00:13:37,920 --> 00:13:40,529
and become parents

00:13:39,120 --> 00:13:43,649
if you've ever written a Fibonacci

00:13:40,529 --> 00:13:45,240
function there was always that thing you

00:13:43,649 --> 00:13:46,980
know do I add the parents to the

00:13:45,240 --> 00:13:47,580
children first or do our first print the

00:13:46,980 --> 00:13:50,700
result

00:13:47,580 --> 00:13:51,750
etc using at Apple you don't have to

00:13:50,700 --> 00:13:54,209
think about it really

00:13:51,750 --> 00:13:56,100
it just works itself out and if we run

00:13:54,209 --> 00:14:00,899
this program it prints the first have

00:13:56,100 --> 00:14:03,990
ten Fibonacci numbers 1 1 2 3 5 8 etc ok

00:14:00,899 --> 00:14:07,500
so this would be very similar in any

00:14:03,990 --> 00:14:09,959
language why do I pick this example as a

00:14:07,500 --> 00:14:11,760
good motivating thing for Python because

00:14:09,959 --> 00:14:13,740
in Rosalind they ask for something like

00:14:11,760 --> 00:14:16,110
the one hundred and fiftieth at the

00:14:13,740 --> 00:14:19,920
Bonacci number which in fact turns out

00:14:16,110 --> 00:14:21,779
to be that number so that's not a series

00:14:19,920 --> 00:14:23,640
that's just one number one six one three

00:14:21,779 --> 00:14:25,680
zero five it's a really big number if

00:14:23,640 --> 00:14:27,630
you do C or Java they would have

00:14:25,680 --> 00:14:32,940
overflown and you would have got either

00:14:27,630 --> 00:14:34,830
67 or minus two three one five or you

00:14:32,940 --> 00:14:37,230
could have imported libraries install

00:14:34,830 --> 00:14:41,779
those libraries worked out how to use

00:14:37,230 --> 00:14:43,920
them etc Python it just works

00:14:41,779 --> 00:14:49,610
probably tired of mirroring but

00:14:43,920 --> 00:14:52,980
fantastic oK we've got two more examples

00:14:49,610 --> 00:14:56,459
this one is calculating what they call

00:14:52,980 --> 00:14:59,910
minimum skill so earlier we said areas

00:14:56,459 --> 00:15:04,050
rich in cg are interesting it turns out

00:14:59,910 --> 00:15:06,570
that if the ratio of C's to G's is high

00:15:04,050 --> 00:15:10,529
so we've got a lot of C's close together

00:15:06,570 --> 00:15:12,779
it's even more interesting so what the

00:15:10,529 --> 00:15:16,620
skew is defined as is we start off with

00:15:12,779 --> 00:15:20,010
0 every time we see a C we subtract one

00:15:16,620 --> 00:15:22,829
so the first two characters are CC so we

00:15:20,010 --> 00:15:27,149
go from 0 minus 1 minus 2 if we see an A

00:15:22,829 --> 00:15:29,610
or T we just keep going at G we add 1

00:15:27,149 --> 00:15:32,880
and what we're interested in the end is

00:15:29,610 --> 00:15:33,960
the index of all those positions

00:15:32,880 --> 00:15:39,330
where

00:15:33,960 --> 00:15:42,810
that running list was at its lowest so

00:15:39,330 --> 00:15:46,140
in this example we see we've got a minus

00:15:42,810 --> 00:15:48,270
3 in the 1 2 3 4 6 position so we

00:15:46,140 --> 00:15:50,730
assuming that we don't get it below

00:15:48,270 --> 00:15:52,290
monastery we would print out 6 if there

00:15:50,730 --> 00:15:54,960
were two monasteries we would print out

00:15:52,290 --> 00:15:59,280
6 and 12 and wherever else at minus 3

00:15:54,960 --> 00:16:01,250
occurred and so it started off with this

00:15:59,280 --> 00:16:05,190
program it's just you know

00:16:01,250 --> 00:16:09,200
simples once again you just quickly

00:16:05,190 --> 00:16:11,310
attack it and we say that

00:16:09,200 --> 00:16:14,070
we'll just keep running along that

00:16:11,310 --> 00:16:16,410
string and each time we will keep a list

00:16:14,070 --> 00:16:19,050
which is the running total and as you

00:16:16,410 --> 00:16:21,930
can guess we can probably find a better

00:16:19,050 --> 00:16:25,830
way of doing it so the first thing I did

00:16:21,930 --> 00:16:33,270
was I got rid of the I've gone back a

00:16:25,830 --> 00:16:35,730
slide so we had that if CH in CG well we

00:16:33,270 --> 00:16:37,500
don't have to check because our

00:16:35,730 --> 00:16:40,650
dictionary only has a CNG we're checking

00:16:37,500 --> 00:16:42,960
so in this example I just put all four

00:16:40,650 --> 00:16:46,830
characters into the dictionary and that

00:16:42,960 --> 00:16:48,480
means I so a and T are both 0 so I can

00:16:46,830 --> 00:16:50,910
just keep adding it makes it a little

00:16:48,480 --> 00:16:53,400
bit simpler so let's make it even

00:16:50,910 --> 00:16:56,670
simpler so in the next thing I wanted to

00:16:53,400 --> 00:16:59,090
use a list comprehension but that meant

00:16:56,670 --> 00:17:02,190
I had to write a function to do that and

00:16:59,090 --> 00:17:03,810
when I wrote this function because with

00:17:02,190 --> 00:17:05,490
a list comprehension it's really hard to

00:17:03,810 --> 00:17:09,390
get memory in other words this

00:17:05,490 --> 00:17:10,770
accumulation of what went before so I

00:17:09,390 --> 00:17:12,540
wrote this function and I needed a

00:17:10,770 --> 00:17:15,900
global variable which I didn't really

00:17:12,540 --> 00:17:18,270
like I don't like using Global's so in

00:17:15,900 --> 00:17:21,209
the next iteration I use that same

00:17:18,270 --> 00:17:22,709
function but in this one I used it's

00:17:21,209 --> 00:17:25,050
really a hack where you have an array

00:17:22,709 --> 00:17:26,339
which is a default parameter so it gets

00:17:25,050 --> 00:17:29,040
initialized the first time but then

00:17:26,339 --> 00:17:31,410
remembers its values so that was just as

00:17:29,040 --> 00:17:36,930
ugly as using a global variable from my

00:17:31,410 --> 00:17:40,230
perspective so the next thing I decided

00:17:36,930 --> 00:17:42,240
okay I'll use a generator and that way I

00:17:40,230 --> 00:17:45,660
got rid of the global variables I got

00:17:42,240 --> 00:17:47,370
rid of the ugly hack fantastic and it

00:17:45,660 --> 00:17:49,350
works but

00:17:47,370 --> 00:17:52,320
the generator actually knows about this

00:17:49,350 --> 00:17:54,630
dictionary and really all the generator

00:17:52,320 --> 00:17:56,640
is doing is accumulating so it shouldn't

00:17:54,630 --> 00:17:58,620
have to do so basically what I did is I

00:17:56,640 --> 00:17:59,370
renamed it accumulate because that's

00:17:58,620 --> 00:18:03,660
what it's doing

00:17:59,370 --> 00:18:05,940
I moved the mapping of the characters

00:18:03,660 --> 00:18:07,260
onto the dictionary into the main part

00:18:05,940 --> 00:18:08,970
of the code which is where it belongs

00:18:07,260 --> 00:18:12,720
and some are dictionary really just

00:18:08,970 --> 00:18:15,930
accumulated any list of numbers and each

00:18:12,720 --> 00:18:21,570
time it was called it would return that

00:18:15,930 --> 00:18:23,400
value so this worked but I looked it in

00:18:21,570 --> 00:18:25,710
I thought well in a way it's just as

00:18:23,400 --> 00:18:28,110
complex as the original code I've so got

00:18:25,710 --> 00:18:30,480
a four I'm now using a generator I'm

00:18:28,110 --> 00:18:34,530
using function calls etc so I thought

00:18:30,480 --> 00:18:41,010
okay this is where I pull out the begins

00:18:34,530 --> 00:18:45,360
so I used numpy import numpy is equal to

00:18:41,010 --> 00:18:48,750
NP doc cumulative sum of that list that

00:18:45,360 --> 00:18:51,960
a list comprehension print NP where a

00:18:48,750 --> 00:18:54,900
equals min of a and once again also this

00:18:51,960 --> 00:18:57,420
other part the last three lands we are

00:18:54,900 --> 00:19:00,900
calculated what the minimum was then ran

00:18:57,420 --> 00:19:03,270
through and then was also pretty ugly so

00:19:00,900 --> 00:19:06,690
I got rid of that in one line with the

00:19:03,270 --> 00:19:07,890
NP where I was showing these last to

00:19:06,690 --> 00:19:10,200
somebody in there laughed and I said

00:19:07,890 --> 00:19:12,720
what's wrong with him and they said like

00:19:10,200 --> 00:19:15,090
are all problems in Python reducible to

00:19:12,720 --> 00:19:17,700
one line and I said well actually these

00:19:15,090 --> 00:19:19,860
are pretty simple problems it is another

00:19:17,700 --> 00:19:22,740
things so the next one I'll just quickly

00:19:19,860 --> 00:19:27,030
show you a description of a problem it's

00:19:22,740 --> 00:19:32,490
called hidden Markov models I'll try and

00:19:27,030 --> 00:19:34,890
explain it quickly and so hidden Markov

00:19:32,490 --> 00:19:37,440
model assume we've got a machine and

00:19:34,890 --> 00:19:39,900
this machine is in in state a or b if

00:19:37,440 --> 00:19:43,020
it's in state a it emits an a if it's in

00:19:39,900 --> 00:19:45,000
state B it emits a B when it's in state

00:19:43,020 --> 00:19:47,850
a it will emit an A and then it will

00:19:45,000 --> 00:19:49,950
change state and it will go back to sate

00:19:47,850 --> 00:19:51,660
a with a probability of point two or it

00:19:49,950 --> 00:19:54,360
will go in set B with the probability of

00:19:51,660 --> 00:19:56,429
0.8 if it's inside B it will emit a B

00:19:54,360 --> 00:19:59,280
will go back to state B with a

00:19:56,429 --> 00:20:00,360
probability of 0.37 or beckoned state a

00:19:59,280 --> 00:20:04,740
with a probability

00:20:00,360 --> 00:20:08,490
163 roughly okay so the problem is if

00:20:04,740 --> 00:20:11,340
we've got a string be a baby did it did

00:20:08,490 --> 00:20:12,840
it how lucky is that what's the

00:20:11,340 --> 00:20:14,549
probability that it came out of a

00:20:12,840 --> 00:20:17,250
machine with those probabilities and

00:20:14,549 --> 00:20:19,080
that's hidden Markov models you can

00:20:17,250 --> 00:20:21,149
spend a semester journey studying that

00:20:19,080 --> 00:20:26,429
or you've just learnt it in one minute

00:20:21,149 --> 00:20:28,019
okay so when we look at this problem

00:20:26,429 --> 00:20:30,630
well when I looked at this problem I

00:20:28,019 --> 00:20:36,690
thought okay this to me looks very much

00:20:30,630 --> 00:20:39,990
like a broth okay we've got two vertices

00:20:36,690 --> 00:20:43,169
four edges and so we could model it as a

00:20:39,990 --> 00:20:44,580
graph using Python to me it seemed

00:20:43,169 --> 00:20:46,260
natural if we're modeling a graph we

00:20:44,580 --> 00:20:49,710
have a dictionary so I created a

00:20:46,260 --> 00:20:51,720
dictionary called transitions and the

00:20:49,710 --> 00:20:54,269
transition because in paths in the

00:20:51,720 --> 00:20:57,899
dictionary can be at Apple we can say a

00:20:54,269 --> 00:21:00,269
to a is 0.193 be a to b is point zero

00:20:57,899 --> 00:21:02,130
eight seven so we've modeled to that fun

00:21:00,269 --> 00:21:05,880
we'll find a state machine that Markov

00:21:02,130 --> 00:21:08,789
model there's our DNA it's not really

00:21:05,880 --> 00:21:11,269
DNA because it's B's anaise but all the

00:21:08,789 --> 00:21:14,039
other things with the NSF called it DNA

00:21:11,269 --> 00:21:15,960
we according to the problem we could

00:21:14,039 --> 00:21:18,750
start with equal probability in other

00:21:15,960 --> 00:21:21,419
states so we set our result 0.5 for the

00:21:18,750 --> 00:21:25,529
start condition and then what I did is

00:21:21,419 --> 00:21:30,120
zipped the string to the itself but

00:21:25,529 --> 00:21:33,269
shifted by one and that's the zip DNA

00:21:30,120 --> 00:21:37,470
comma DNA of 1 colon so that gave us B

00:21:33,269 --> 00:21:40,559
ay ay ay ay ay ay B etc as a list of

00:21:37,470 --> 00:21:44,820
tuples and so all that was left was to

00:21:40,559 --> 00:21:50,600
say for CH in that zip result x equals

00:21:44,820 --> 00:21:54,419
transitions we run it and so basically

00:21:50,600 --> 00:21:56,460
what happens with Rosalind is you run

00:21:54,419 --> 00:22:00,149
these programs it comes back to you and

00:21:56,460 --> 00:22:02,700
says like you'll give it a number I

00:22:00,149 --> 00:22:05,399
forget what the result was then it's a

00:22:02,700 --> 00:22:07,200
really small number and if either you

00:22:05,399 --> 00:22:10,049
correct or incorrect if you correct you

00:22:07,200 --> 00:22:12,750
get your mark and I left this comment in

00:22:10,049 --> 00:22:13,860
my code after I'd written it so it

00:22:12,750 --> 00:22:16,080
actually worked

00:22:13,860 --> 00:22:17,820
Strauch I I was quite surprised back

00:22:16,080 --> 00:22:23,490
because I didn't really understand

00:22:17,820 --> 00:22:27,330
hidden Markov models so what can we

00:22:23,490 --> 00:22:29,940
conclude from this will partners great

00:22:27,330 --> 00:22:31,559
language so I've solved almost 200 of

00:22:29,940 --> 00:22:34,679
these problems and I gave you a sample

00:22:31,559 --> 00:22:36,960
of really short quick easy ones

00:22:34,679 --> 00:22:39,780
these muscly took less than an hour to

00:22:36,960 --> 00:22:42,059
solve there's some that have taken half

00:22:39,780 --> 00:22:43,679
a day a day there's some that I'm still

00:22:42,059 --> 00:22:47,429
working on it after having worked on one

00:22:43,679 --> 00:22:47,790
problem for over day but each step of

00:22:47,429 --> 00:22:49,919
the way

00:22:47,790 --> 00:22:52,679
- seems have been guarding me helping me

00:22:49,919 --> 00:22:53,820
it's like it really feels like you've

00:22:52,679 --> 00:22:55,620
got a partner there

00:22:53,820 --> 00:22:57,480
where's often with some programming

00:22:55,620 --> 00:22:59,250
language you think this language is

00:22:57,480 --> 00:23:00,990
really getting in the way it's you know

00:22:59,250 --> 00:23:05,220
I wish I had something better so that's

00:23:00,990 --> 00:23:06,360
my first thing the second result is that

00:23:05,220 --> 00:23:08,790
I found Rosalind

00:23:06,360 --> 00:23:12,090
this Rosalind got info right a great

00:23:08,790 --> 00:23:13,919
source of small problems to solve so

00:23:12,090 --> 00:23:15,240
often on reddit or whatever you'll read

00:23:13,919 --> 00:23:17,880
somebody's saying look I want to learn

00:23:15,240 --> 00:23:21,720
Python what's the best way to go about

00:23:17,880 --> 00:23:23,220
it if you want to learn Python and you

00:23:21,720 --> 00:23:26,100
don't really have you know something

00:23:23,220 --> 00:23:27,990
applied fantastic way to learn Python

00:23:26,100 --> 00:23:30,059
and at the same time you'll be learning

00:23:27,990 --> 00:23:32,190
a lot about bioinformatics because for

00:23:30,059 --> 00:23:34,590
each problem they explain some of the

00:23:32,190 --> 00:23:38,250
bioinformatics principles behind that

00:23:34,590 --> 00:23:40,410
problem finally I just sort of added

00:23:38,250 --> 00:23:42,240
this to learn we need to solve problems

00:23:40,410 --> 00:23:45,210
and relentlessly improve our solutions

00:23:42,240 --> 00:23:47,520
so you know the first solution looks ok

00:23:45,210 --> 00:23:51,179
but you can always improve it and this

00:23:47,520 --> 00:23:54,600
morning I think one of the keynotes as

00:23:51,179 --> 00:23:56,730
Damian was saying that how with Python

00:23:54,600 --> 00:23:59,130
you just always continually learning it

00:23:56,730 --> 00:24:04,700
was this new stuff to learn so I think

00:23:59,130 --> 00:24:04,700
that's great and thanks very much

00:24:09,379 --> 00:24:17,100
say if you're interested the slides are

00:24:11,820 --> 00:24:19,139
there and maybe Thank You Martin

00:24:17,100 --> 00:24:23,570
and we have five minutes for questions

00:24:19,139 --> 00:24:26,879
like I want to see hands up in the air

00:24:23,570 --> 00:24:30,480
okay I have one question you mentioned

00:24:26,879 --> 00:24:32,279
that bioinformatics is all these

00:24:30,480 --> 00:24:34,739
problems in bioinformatics are a good

00:24:32,279 --> 00:24:37,019
way to learn Python so you learn more

00:24:34,739 --> 00:24:39,029
about Python how to solve problems have

00:24:37,019 --> 00:24:40,889
you apply any of these methods that you

00:24:39,029 --> 00:24:44,489
learned through bioinformatics just all

00:24:40,889 --> 00:24:46,529
other problems I've applied the things

00:24:44,489 --> 00:24:48,809
I've learned through learning this to

00:24:46,529 --> 00:24:52,080
solving other problems so these sort of

00:24:48,809 --> 00:24:54,570
as I do this I pick up little bits of

00:24:52,080 --> 00:24:57,690
Python and particularly things like the

00:24:54,570 --> 00:25:00,059
Hamming distance I find you know there's

00:24:57,690 --> 00:25:02,580
a lot of stuff where you think okay I've

00:25:00,059 --> 00:25:06,710
got this problem I did this for hamming

00:25:02,580 --> 00:25:06,710
distance I'll do it for something else

00:25:12,200 --> 00:25:17,549
hi so I'm you said that that she'd been

00:25:15,509 --> 00:25:20,850
teaching Python at the Bureau of

00:25:17,549 --> 00:25:23,190
Meteorology um have you ever introduced

00:25:20,850 --> 00:25:25,379
the rustling problems to those people

00:25:23,190 --> 00:25:28,619
and how did they can't handle the

00:25:25,379 --> 00:25:30,239
context which if he did write so I guess

00:25:28,619 --> 00:25:31,499
one of the things and why I used

00:25:30,239 --> 00:25:33,509
Roseland when I was teaching in Japan

00:25:31,499 --> 00:25:35,759
fermentations is always try to look for

00:25:33,509 --> 00:25:37,559
their main problems so when I'm teaching

00:25:35,759 --> 00:25:39,960
at the Bureau of him in a Bureau of

00:25:37,559 --> 00:25:42,899
Meteorology I look for problems to do

00:25:39,960 --> 00:25:47,179
with weather with climate with water etc

00:25:42,899 --> 00:25:47,179
so I guess simple answers now I haven't

00:25:47,749 --> 00:25:55,649
and hi that was a great talk and so when

00:25:52,980 --> 00:25:57,769
I was at uni and and when I was doing my

00:25:55,649 --> 00:26:01,019
PhD we were really encouraged to use our

00:25:57,769 --> 00:26:02,909
do you find that the culture push in

00:26:01,019 --> 00:26:05,760
using Python is quite difficult to get

00:26:02,909 --> 00:26:10,440
across for a long term our users

00:26:05,760 --> 00:26:13,500
I have met all users that have moved to

00:26:10,440 --> 00:26:18,330
Python I've met all users who sound

00:26:13,500 --> 00:26:21,480
perfectly happy with our my feeling is

00:26:18,330 --> 00:26:24,810
that as a lot of people when they move

00:26:21,480 --> 00:26:26,760
from simply solving let's say a problem

00:26:24,810 --> 00:26:29,790
like that to having to pull information

00:26:26,760 --> 00:26:32,520
down off the internet having to deal

00:26:29,790 --> 00:26:34,440
with files maybe on a network where we

00:26:32,520 --> 00:26:36,810
work we deal a lot with netcdf files in

00:26:34,440 --> 00:26:42,000
that start seeing some advantages to

00:26:36,810 --> 00:26:43,920
Python so I am NOT even though I want to

00:26:42,000 --> 00:26:44,940
evangelize Python I think everybody

00:26:43,920 --> 00:26:49,490
should be using it

00:26:44,940 --> 00:26:49,490
I'm not out there to convert all users

00:26:58,580 --> 00:27:05,330
thanks hi Martin I teach 15 16 17 and 18

00:27:03,180 --> 00:27:08,280
year olds who have never coded before

00:27:05,330 --> 00:27:10,110
and some of those problems are the kinds

00:27:08,280 --> 00:27:12,840
of things that we use and we find that

00:27:10,110 --> 00:27:16,170
that's fantastic but how do we direct

00:27:12,840 --> 00:27:19,800
them to resources that will help them

00:27:16,170 --> 00:27:21,750
identify the second and third and fourth

00:27:19,800 --> 00:27:23,760
and fifth iterations of your problems

00:27:21,750 --> 00:27:25,760
because when we're sort of teaching them

00:27:23,760 --> 00:27:29,100
the basics of loops and things early on

00:27:25,760 --> 00:27:31,620
the idea of using something like zip is

00:27:29,100 --> 00:27:33,420
not going to occur to them so I guess

00:27:31,620 --> 00:27:35,310
I'm really curious to find out how we

00:27:33,420 --> 00:27:37,380
would guide them to those kinds of

00:27:35,310 --> 00:27:39,660
things because the documentation is very

00:27:37,380 --> 00:27:41,160
very daunting for a student who is

00:27:39,660 --> 00:27:45,180
struggling with these things for the

00:27:41,160 --> 00:27:45,870
first time I don't really have an answer

00:27:45,180 --> 00:27:48,780
for that

00:27:45,870 --> 00:27:50,820
I'd love there to be an answer I think

00:27:48,780 --> 00:27:53,430
part of it comes from people's

00:27:50,820 --> 00:27:55,080
motivation that when people are

00:27:53,430 --> 00:27:57,960
motivated to learn they pick up the

00:27:55,080 --> 00:27:59,460
resources it actually just so happened

00:27:57,960 --> 00:28:02,220
that I got home last night and my

00:27:59,460 --> 00:28:04,140
daughter who's 13 had been given a

00:28:02,220 --> 00:28:08,040
problem at school which was to calculate

00:28:04,140 --> 00:28:10,260
pi using random numbers and I sort of

00:28:08,040 --> 00:28:12,000
showed her a quick solution in - and

00:28:10,260 --> 00:28:16,330
then she said oh we have to use scratch

00:28:12,000 --> 00:28:20,440
and there was a lot of pending having

00:28:16,330 --> 00:28:22,510
said that I think part of it has to be

00:28:20,440 --> 00:28:26,890
self directed people basically have to

00:28:22,510 --> 00:28:32,019
want to learn and I don't know how to do

00:28:26,890 --> 00:28:36,820
it I guess it's a simple answer okay

00:28:32,019 --> 00:28:37,210
before I forget we have a gift for you

00:28:36,820 --> 00:28:40,899
mom

00:28:37,210 --> 00:28:41,470
thanks very much there Mikey flying on

00:28:40,899 --> 00:28:43,990


00:28:41,470 --> 00:28:47,669
I think I'm not from another say I know

00:28:43,990 --> 00:28:47,669

YouTube URL: https://www.youtube.com/watch?v=uWWoRa8thN0


