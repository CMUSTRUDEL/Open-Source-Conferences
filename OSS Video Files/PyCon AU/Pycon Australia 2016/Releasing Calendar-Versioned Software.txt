Title: Releasing Calendar-Versioned Software
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Amber Brown
https://2016.pycon-au.org/schedule/144/view_talk
Calendar-versioned software (or “calver”), in contrast to semantically versioned software (or “semver”), is released on regular intervals, rather than on the occurrence of features, bug fixes, or backwards compatibility breaking changes. This method of releasing software, notably used by Twisted and various related projects, eschews the “major.minor.patchlevel” format and the guarantees of a semver regime and instead focuses on providing robust backwards compatibility, clear deprecation cycles, and frequent but smaller releases. This talk discusses some of the trials and tribulations of the release process of such a project, Twisted, and the ways that it makes it work, as well as what tools are available to make the process easier if you wish to implement it yourself.
Captions: 
	00:00:00,000 --> 00:00:06,480
I'm first up we have amber brown amber

00:00:03,899 --> 00:00:08,940
it pretends to be an owl on the internet

00:00:06,480 --> 00:00:10,679
when she's not doing that she does

00:00:08,940 --> 00:00:13,139
release management and is a core

00:00:10,679 --> 00:00:16,500
developer for the twisted project please

00:00:13,139 --> 00:00:23,910
welcome amber and her top releasing

00:00:16,500 --> 00:00:27,740
calendar versioned software hello

00:00:23,910 --> 00:00:30,869
everyone as your leader I am am brown

00:00:27,740 --> 00:00:34,520
this is my Twitter and website I make

00:00:30,869 --> 00:00:37,140
very quality posts I'm from Perth

00:00:34,520 --> 00:00:40,020
although I will be in Melbourne soon

00:00:37,140 --> 00:00:42,239
joining everyone here yay so as

00:00:40,020 --> 00:00:45,210
mentioned i work on the twisted project

00:00:42,239 --> 00:00:50,309
I've been the release manager for many

00:00:45,210 --> 00:00:53,070
many many many many versions over three

00:00:50,309 --> 00:00:55,710
years I've also done a lot of work just

00:00:53,070 --> 00:00:58,199
on the project porting it to python 3 so

00:00:55,710 --> 00:01:00,480
like 40,000 plus lines of code which has

00:00:58,199 --> 00:01:02,670
been very very fun and very intensive

00:01:00,480 --> 00:01:04,769
but when you're doing that much change

00:01:02,670 --> 00:01:06,570
you need to update pretty pretty often

00:01:04,769 --> 00:01:09,960
so that people can get the things they

00:01:06,570 --> 00:01:12,420
want you I also work on a couple of

00:01:09,960 --> 00:01:16,619
other projects track client I dr. our

00:01:12,420 --> 00:01:18,420
proxy so it's basically with all of

00:01:16,619 --> 00:01:20,460
these software although these bits of

00:01:18,420 --> 00:01:23,400
software that are sort of adjacent to

00:01:20,460 --> 00:01:24,930
the project use its approach to

00:01:23,400 --> 00:01:28,759
versioning which I'll get to in a minute

00:01:24,930 --> 00:01:31,500
so yeah twisted pretty great I love it

00:01:28,759 --> 00:01:35,040
let's talk about versioning so what is

00:01:31,500 --> 00:01:38,490
versioning it is consistency in your

00:01:35,040 --> 00:01:40,799
software's characteristics now if you do

00:01:38,490 --> 00:01:42,540
something like you deploy off trunk when

00:01:40,799 --> 00:01:45,720
you deploy trunk now it'll be different

00:01:42,540 --> 00:01:47,490
than trunk say in two years so if you're

00:01:45,720 --> 00:01:49,259
doing something that deploys on hundreds

00:01:47,490 --> 00:01:50,729
and hundreds of servers you don't want

00:01:49,259 --> 00:01:53,520
to deploy off trunk on all of them

00:01:50,729 --> 00:01:55,049
because in the mean time between your

00:01:53,520 --> 00:01:57,600
first server getting deployed annual

00:01:55,049 --> 00:01:58,799
last server getting deployed you may end

00:01:57,600 --> 00:02:02,369
up with a different version of the

00:01:58,799 --> 00:02:05,700
software but if you have specific

00:02:02,369 --> 00:02:08,129
versions there it will be the same now

00:02:05,700 --> 00:02:11,700
as it will be later so you have a little

00:02:08,129 --> 00:02:13,590
bit dependency there when your grade to

00:02:11,700 --> 00:02:16,530
say the next version which is version

00:02:13,590 --> 00:02:18,060
my it is explicit and repeatable you can

00:02:16,530 --> 00:02:21,629
do it locally and then you can put it

00:02:18,060 --> 00:02:23,040
down to production different kinds

00:02:21,629 --> 00:02:25,590
there's different kinds of versions

00:02:23,040 --> 00:02:28,800
depending on what you're releasing so if

00:02:25,590 --> 00:02:30,989
you're releasing features you will have

00:02:28,800 --> 00:02:34,200
a feature release or a bug-fix release

00:02:30,989 --> 00:02:37,470
or a repackaging if they filed and get

00:02:34,200 --> 00:02:39,390
in the distribution so overall

00:02:37,470 --> 00:02:41,760
versioning makes your software much

00:02:39,390 --> 00:02:44,250
easier to use because people can depend

00:02:41,760 --> 00:02:46,260
on certain features or so bugs being

00:02:44,250 --> 00:02:49,470
insert versions it's much easier to

00:02:46,260 --> 00:02:51,120
deploy we already own all this so what

00:02:49,470 --> 00:02:53,970
we have to choose from as far as

00:02:51,120 --> 00:02:56,519
versioning goats we have sin ver which

00:02:53,970 --> 00:02:58,860
is a short for semantic versioning which

00:02:56,519 --> 00:03:02,250
is quite commonly used by a lot of open

00:02:58,860 --> 00:03:04,200
source software we also have what I got

00:03:02,250 --> 00:03:06,120
what we call calvo which is like what

00:03:04,200 --> 00:03:10,319
twisted users in what a bunch of users

00:03:06,120 --> 00:03:12,720
where the it depends not on the features

00:03:10,319 --> 00:03:15,269
or the bug fixes neural ease but when it

00:03:12,720 --> 00:03:17,880
was released of course you could just

00:03:15,269 --> 00:03:20,430
give in to the chaos and just add random

00:03:17,880 --> 00:03:22,859
numbers and just not care about it I

00:03:20,430 --> 00:03:24,299
mean that's that's fine too I don't

00:03:22,859 --> 00:03:25,410
actually this doesn't actually tell me

00:03:24,299 --> 00:03:28,380
anything and that's what I hate about

00:03:25,410 --> 00:03:30,239
the driver updater it's like I'm sure

00:03:28,380 --> 00:03:32,519
there's useful stuff but you know

00:03:30,239 --> 00:03:35,040
there's no way of knowing whether that's

00:03:32,519 --> 00:03:36,269
most recent version or even if it fixes

00:03:35,040 --> 00:03:38,849
any bugs because it doesn't actually

00:03:36,269 --> 00:03:42,319
tell you and there's no real super easy

00:03:38,849 --> 00:03:46,590
way to find out just by looking at that

00:03:42,319 --> 00:03:49,230
so cember if if you haven't used it

00:03:46,590 --> 00:03:52,560
before you have a major a minor and a

00:03:49,230 --> 00:03:55,380
patch and you increase the major version

00:03:52,560 --> 00:03:57,660
when there is a be incompatible API

00:03:55,380 --> 00:03:59,690
changes for example you break your feet

00:03:57,660 --> 00:04:02,269
you change how a feature works and

00:03:59,690 --> 00:04:05,730
existing code will not work with it a

00:04:02,269 --> 00:04:07,470
minor version is when you do something

00:04:05,730 --> 00:04:08,730
backwards compatibility so you add a new

00:04:07,470 --> 00:04:11,160
feature that does not affect other

00:04:08,730 --> 00:04:14,340
things new patch version is mainly for

00:04:11,160 --> 00:04:16,470
fixing bug fixes that does not change

00:04:14,340 --> 00:04:18,000
how the software operates apart from

00:04:16,470 --> 00:04:21,239
fixing a bug so it is backwards

00:04:18,000 --> 00:04:23,550
compatible so it generally looks you

00:04:21,239 --> 00:04:25,919
know breaking feature bug fix you have

00:04:23,550 --> 00:04:27,270
version one which is you know your

00:04:25,919 --> 00:04:29,250
initial stable you

00:04:27,270 --> 00:04:31,440
point one is wait a backwards compatible

00:04:29,250 --> 00:04:33,169
feature on point one point one would be

00:04:31,440 --> 00:04:35,009
a backwards compatible bug fix an

00:04:33,169 --> 00:04:36,449
inversion two would be when you've

00:04:35,009 --> 00:04:38,759
changed some sort of functionality in a

00:04:36,449 --> 00:04:41,840
major way that existing software would

00:04:38,759 --> 00:04:46,190
stop working now why would you use

00:04:41,840 --> 00:04:49,860
cember if it's very well for a lot of

00:04:46,190 --> 00:04:51,330
for a lot of corporate reasons it works

00:04:49,860 --> 00:04:52,830
very well when you have roadmaps when

00:04:51,330 --> 00:04:54,330
you have feature roadmaps and when you

00:04:52,830 --> 00:04:56,340
have top-down planning and you can go

00:04:54,330 --> 00:04:58,880
this feature will be in this version and

00:04:56,340 --> 00:05:01,020
that was what it make it this version

00:04:58,880 --> 00:05:02,909
it's also kind of easy when you're

00:05:01,020 --> 00:05:05,460
upgrading to see whether it probably

00:05:02,909 --> 00:05:08,370
will work with your codebase so if you

00:05:05,460 --> 00:05:10,440
if you add this like your requirements

00:05:08,370 --> 00:05:12,000
file you can be like I'm fairly sure you

00:05:10,440 --> 00:05:14,099
can use any of these versions between

00:05:12,000 --> 00:05:15,900
one and two and because there won't be

00:05:14,099 --> 00:05:20,789
any backwards compat incompatible

00:05:15,900 --> 00:05:22,590
changes it should just work because you

00:05:20,789 --> 00:05:25,560
have to change the major version it does

00:05:22,590 --> 00:05:28,169
encourage developers to not break API

00:05:25,560 --> 00:05:30,360
and to do it a bit more sparingly so you

00:05:28,169 --> 00:05:32,069
end up with breaking changes that happen

00:05:30,360 --> 00:05:33,960
very much on purpose with a lot more

00:05:32,069 --> 00:05:37,349
thought put into it rather than just

00:05:33,960 --> 00:05:38,699
changing it because you want to it also

00:05:37,349 --> 00:05:41,400
makes it easier for developers to

00:05:38,699 --> 00:05:43,710
understand so as you're someone that's

00:05:41,400 --> 00:05:45,360
looking at a version and for people that

00:05:43,710 --> 00:05:47,789
are leasing the software to communicate

00:05:45,360 --> 00:05:50,900
their intent of the race release this

00:05:47,789 --> 00:05:54,500
will have a new bug fix or will have a

00:05:50,900 --> 00:05:56,789
new feature or it may change things

00:05:54,500 --> 00:06:01,199
unfortunately this doesn't really fit

00:05:56,789 --> 00:06:03,810
reality as much production software is

00:06:01,199 --> 00:06:06,449
far too complex to decide if any

00:06:03,810 --> 00:06:09,240
breaking any change is a breaking one

00:06:06,449 --> 00:06:11,940
you can be fix something and that you

00:06:09,240 --> 00:06:13,860
think is backwards compatible but it

00:06:11,940 --> 00:06:16,759
might not be especially in a language

00:06:13,860 --> 00:06:18,990
like Python there is no such thing

00:06:16,759 --> 00:06:21,360
especially in critical critical

00:06:18,990 --> 00:06:24,360
environments why there is a safe release

00:06:21,360 --> 00:06:25,889
you can upgrade to a patch version but

00:06:24,360 --> 00:06:27,509
for example if you have like HIPAA

00:06:25,889 --> 00:06:29,039
requirements or something you still need

00:06:27,509 --> 00:06:32,729
to order then you still need to be very

00:06:29,039 --> 00:06:37,080
very careful because a bugfix t to

00:06:32,729 --> 00:06:39,630
someone else might break you it also

00:06:37,080 --> 00:06:41,580
doesn't scale very well to software that

00:06:39,630 --> 00:06:44,250
is that has many moving

00:06:41,580 --> 00:06:46,979
arts for example my operating system you

00:06:44,250 --> 00:06:49,319
a lot of different things change in it

00:06:46,979 --> 00:06:52,439
and if you have a framework then if you

00:06:49,319 --> 00:06:54,629
have it all as one sort of breaking

00:06:52,439 --> 00:06:56,069
change thing if you release more often

00:06:54,629 --> 00:06:58,229
than every couple of months you're going

00:06:56,069 --> 00:07:00,030
to end up with basically chrome

00:06:58,229 --> 00:07:02,250
versioning syndrome where you're going

00:07:00,030 --> 00:07:07,050
to be like a version 100 within a couple

00:07:02,250 --> 00:07:09,930
of months also because you need to wait

00:07:07,050 --> 00:07:11,819
for the next major bump it forces your

00:07:09,930 --> 00:07:14,879
entire code base to work in lockstep

00:07:11,819 --> 00:07:17,699
with each other now this generally means

00:07:14,879 --> 00:07:19,500
that you have the big 2 point 0 or the

00:07:17,699 --> 00:07:22,020
big three-point oh that has so many

00:07:19,500 --> 00:07:24,030
changes in it that it ends up something

00:07:22,020 --> 00:07:26,219
like Perl 6 or pies and three we're

00:07:24,030 --> 00:07:30,569
adoption is hurt by it because it kills

00:07:26,219 --> 00:07:33,000
projects also if you need to make a

00:07:30,569 --> 00:07:35,490
breaking change some people just go it's

00:07:33,000 --> 00:07:37,139
fine we have cember this allows us to do

00:07:35,490 --> 00:07:39,120
this and we'll just update the major

00:07:37,139 --> 00:07:41,099
version that's why there's some versions

00:07:39,120 --> 00:07:46,440
of software that seem incredibly simple

00:07:41,099 --> 00:07:48,389
would have liked version 6.5 large user

00:07:46,440 --> 00:07:50,490
bases on the old major versions because

00:07:48,389 --> 00:07:52,139
as we know upgrading major versions of

00:07:50,490 --> 00:07:54,120
software is very hard as we know from

00:07:52,139 --> 00:07:55,620
packing two and three means that you end

00:07:54,120 --> 00:07:57,900
up having to back for lots and lots of

00:07:55,620 --> 00:07:59,819
security fixes to those earlier versions

00:07:57,900 --> 00:08:01,560
even if you don't want them to use it

00:07:59,819 --> 00:08:06,360
they still will be using it because they

00:08:01,560 --> 00:08:08,639
can't make the change agile develop

00:08:06,360 --> 00:08:12,259
software it doesn't really fit this sort

00:08:08,639 --> 00:08:14,400
of top-down model you end up with

00:08:12,259 --> 00:08:16,469
especially like open source you end up

00:08:14,400 --> 00:08:19,650
with features landing when they're sort

00:08:16,469 --> 00:08:22,020
of finished there's no sort of very much

00:08:19,650 --> 00:08:24,000
planning when people come by and give

00:08:22,020 --> 00:08:26,909
fixes or give features or maybe

00:08:24,000 --> 00:08:28,250
something stall for many many years and

00:08:26,909 --> 00:08:31,979
these are a better way to communicate

00:08:28,250 --> 00:08:36,659
this to our users that our software sort

00:08:31,979 --> 00:08:39,680
of works a bit difficult to say how do

00:08:36,659 --> 00:08:42,089
we serve our users without versioning

00:08:39,680 --> 00:08:45,000
now that seems a little bit weird but

00:08:42,089 --> 00:08:47,339
Calver sort of works with it now you

00:08:45,000 --> 00:08:49,350
release it not according to features but

00:08:47,339 --> 00:08:51,149
according to time that has been enough

00:08:49,350 --> 00:08:53,970
time since the past release to issue a

00:08:51,149 --> 00:08:55,380
new one now some things have firm

00:08:53,970 --> 00:08:57,720
schedule slightly Bunty

00:08:55,380 --> 00:08:59,490
Jengo mostly uses a semi sort of

00:08:57,720 --> 00:09:03,210
calendar version sort of thing they're

00:08:59,490 --> 00:09:04,710
like half doing it but not it's it's

00:09:03,210 --> 00:09:06,540
sort of a bit weird by amusing them as

00:09:04,710 --> 00:09:10,020
as as an example here because for my

00:09:06,540 --> 00:09:11,700
intensive purposes they work lots of

00:09:10,020 --> 00:09:14,940
projects like the twisted projects and

00:09:11,700 --> 00:09:16,830
youtube-dl and PTZ sort of release when

00:09:14,940 --> 00:09:18,750
you know when they're ready twisted

00:09:16,830 --> 00:09:19,890
releases when it's been enough time that

00:09:18,750 --> 00:09:21,560
there's enough stuff in the release

00:09:19,890 --> 00:09:24,810
there's nice to get it out to users

00:09:21,560 --> 00:09:27,030
youtube-dl updates when YouTube breaks

00:09:24,810 --> 00:09:28,950
everything in PI TZ updates when the

00:09:27,030 --> 00:09:31,950
time's Oh database has changed so those

00:09:28,950 --> 00:09:34,260
can't really be decided ahead of time

00:09:31,950 --> 00:09:36,660
because in twisted some some features

00:09:34,260 --> 00:09:38,100
set languished for like six years and

00:09:36,660 --> 00:09:40,950
then suddenly everything happens and

00:09:38,100 --> 00:09:43,140
they get merged so if we held on a major

00:09:40,950 --> 00:09:44,940
of a major release for that we wouldn't

00:09:43,140 --> 00:09:47,190
be able to really say anything and we'd

00:09:44,940 --> 00:09:48,900
still be on like twisted one because

00:09:47,190 --> 00:09:52,050
everything just sort of happens by

00:09:48,900 --> 00:09:53,280
itself generally you end up with

00:09:52,050 --> 00:09:55,710
something that looks like this so you

00:09:53,280 --> 00:09:58,410
have a year a month in a patch or a year

00:09:55,710 --> 00:10:01,290
month day panj for example quite easy or

00:09:58,410 --> 00:10:03,630
year release patch so here's three

00:10:01,290 --> 00:10:05,760
examples of these different versioning

00:10:03,630 --> 00:10:07,590
scripts now they used a bit differently

00:10:05,760 --> 00:10:09,920
on each project and they serve different

00:10:07,590 --> 00:10:12,630
purposes so youtube-dl has a lot more

00:10:09,920 --> 00:10:16,410
fine-grained nurse in it because it sort

00:10:12,630 --> 00:10:18,870
of depends on this is the fixing

00:10:16,410 --> 00:10:20,850
something that broke in a service on

00:10:18,870 --> 00:10:24,060
this day and they have several releases

00:10:20,850 --> 00:10:27,180
like a week twisted however we sort of

00:10:24,060 --> 00:10:30,390
have X releases per year where X ranges

00:10:27,180 --> 00:10:31,980
from one to six and sometimes we have

00:10:30,390 --> 00:10:34,050
them like in the same month or in

00:10:31,980 --> 00:10:36,540
subsequent months so the sort of a

00:10:34,050 --> 00:10:38,310
boo-boo stage thing where it is a the

00:10:36,540 --> 00:10:40,380
end of the year and then the month and

00:10:38,310 --> 00:10:44,850
then a patch version doesn't really work

00:10:40,380 --> 00:10:47,460
for us now if you sort of orient it in a

00:10:44,850 --> 00:10:49,380
calendar based way you sort of want them

00:10:47,460 --> 00:10:51,300
to keep updating so you need to reduce

00:10:49,380 --> 00:10:53,250
the friction for it used to constantly

00:10:51,300 --> 00:10:57,360
upgrade for them and always be using new

00:10:53,250 --> 00:11:00,690
version no matter what so your software

00:10:57,360 --> 00:11:03,120
kind of needs to be constantly stable in

00:11:00,690 --> 00:11:04,980
twisted we reverse anything that breaks

00:11:03,120 --> 00:11:07,260
trunk even if trunk is not actually

00:11:04,980 --> 00:11:08,980
released anything because we want to be

00:11:07,260 --> 00:11:12,730
able to do a release whenever we

00:11:08,980 --> 00:11:15,970
to you do need to promise that because

00:11:12,730 --> 00:11:18,430
you're doing lots of releases and it you

00:11:15,970 --> 00:11:20,589
don't have that major version to do to

00:11:18,430 --> 00:11:22,120
decide when things are breaking you've

00:11:20,589 --> 00:11:24,730
got to kind of promise that there will

00:11:22,120 --> 00:11:26,709
be no breaking changes without ample

00:11:24,730 --> 00:11:30,130
time for deprecation ever or at least

00:11:26,709 --> 00:11:31,389
without a good reason when you want to

00:11:30,130 --> 00:11:33,190
get rid of functionality though you've

00:11:31,389 --> 00:11:36,160
deprecated you do it after a certain

00:11:33,190 --> 00:11:40,899
amount of time so for example a year

00:11:36,160 --> 00:11:43,329
also are after X amount of X amount of

00:11:40,899 --> 00:11:45,399
time however beings that maybe you don't

00:11:43,329 --> 00:11:47,199
increment the major version to say that

00:11:45,399 --> 00:11:49,600
things are broken because it might be a

00:11:47,199 --> 00:11:51,670
tiny breaking change it might be

00:11:49,600 --> 00:11:54,100
something some API that no one uses and

00:11:51,670 --> 00:11:55,480
has been deprecated for many years you

00:11:54,100 --> 00:11:57,130
know when you have software that has

00:11:55,480 --> 00:12:00,760
that many moving parts you end up with

00:11:57,130 --> 00:12:03,490
that a lot generally you end up with one

00:12:00,760 --> 00:12:05,290
true release which is the current

00:12:03,490 --> 00:12:08,740
release Owen twisted you should always

00:12:05,290 --> 00:12:10,630
be using the latest release for a wooden

00:12:08,740 --> 00:12:13,569
to you should generally be using the

00:12:10,630 --> 00:12:15,670
latest release but for some software you

00:12:13,569 --> 00:12:17,290
do need ltf strategies and that sort of

00:12:15,670 --> 00:12:20,649
works of calendar version things as well

00:12:17,290 --> 00:12:23,410
that because it's sort of an API basis

00:12:20,649 --> 00:12:26,260
that because you deprecated API rather

00:12:23,410 --> 00:12:28,600
than functionality that is just used by

00:12:26,260 --> 00:12:31,240
the API you can end up with something

00:12:28,600 --> 00:12:33,010
that is the API at this date and then

00:12:31,240 --> 00:12:35,920
use fixed by the bugs in that and that's

00:12:33,010 --> 00:12:37,750
what I'm 12 ubuntu's LTS releases are

00:12:35,920 --> 00:12:40,630
and that's what jen goes LTS releases

00:12:37,750 --> 00:12:42,300
are and things like I think it's

00:12:40,630 --> 00:12:44,889
teramind have a similar thing like that

00:12:42,300 --> 00:12:47,709
because essentially you need to start

00:12:44,889 --> 00:12:50,589
training your API as something users can

00:12:47,709 --> 00:12:54,670
use and sort of everything else is the

00:12:50,589 --> 00:13:01,779
implementation detail it is however not

00:12:54,670 --> 00:13:04,360
a silver bullet so the realities of

00:13:01,779 --> 00:13:06,130
software is that bugs will happen bugs

00:13:04,360 --> 00:13:08,139
will always happen no matter how careful

00:13:06,130 --> 00:13:10,149
you are there are still bugs in things

00:13:08,139 --> 00:13:13,540
that NASA makes and that's a major

00:13:10,149 --> 00:13:15,220
software that has so rigorous software

00:13:13,540 --> 00:13:17,050
development practices that no one in

00:13:15,220 --> 00:13:19,089
this room could probably do that on a

00:13:17,050 --> 00:13:20,680
day-to-day basis they've hundreds and

00:13:19,089 --> 00:13:22,840
hundreds of people and hundreds and

00:13:20,680 --> 00:13:25,480
hundreds of engineers and QA testers

00:13:22,840 --> 00:13:27,580
because it's going to space and you

00:13:25,480 --> 00:13:31,540
can't fix it when it's going a thousand

00:13:27,580 --> 00:13:34,060
kaizen our uploads regressions however

00:13:31,540 --> 00:13:35,740
will happen you have some software and

00:13:34,060 --> 00:13:37,420
you think you didn't break anything but

00:13:35,740 --> 00:13:39,340
you accidentally changed the type of a

00:13:37,420 --> 00:13:41,470
variable and now on Python 3 you get a

00:13:39,340 --> 00:13:43,780
Unicode decode error because it's now

00:13:41,470 --> 00:13:46,300
you didn't buy prefix a string somewhere

00:13:43,780 --> 00:13:50,370
or something like that so regressions

00:13:46,300 --> 00:13:53,560
will happen because software is finicky

00:13:50,370 --> 00:13:56,590
so saying that these things will always

00:13:53,560 --> 00:13:59,140
happen the quality of your releases if

00:13:56,590 --> 00:14:02,470
this is dictated by how well you handle

00:13:59,140 --> 00:14:04,420
these now calendar versioning is the

00:14:02,470 --> 00:14:06,690
acceptance that software will constantly

00:14:04,420 --> 00:14:09,580
change is that no software is really

00:14:06,690 --> 00:14:11,680
sort of stuck in time and then changes a

00:14:09,580 --> 00:14:14,500
lot because of where is constantly

00:14:11,680 --> 00:14:16,420
changing internally and it just exposes

00:14:14,500 --> 00:14:19,030
that to everyone else that the software

00:14:16,420 --> 00:14:24,490
constantly improves in little bits and

00:14:19,030 --> 00:14:26,440
birds rather than going massively now

00:14:24,490 --> 00:14:28,450
effective calvert requires that you

00:14:26,440 --> 00:14:30,220
adopt these better processors to handle

00:14:28,450 --> 00:14:32,950
this you need to ensure that every

00:14:30,220 --> 00:14:34,420
change does not affect a public API you

00:14:32,950 --> 00:14:36,130
need to have processes in place for

00:14:34,420 --> 00:14:38,140
deprecation because you'll be doing them

00:14:36,130 --> 00:14:40,060
a lot because you always need to give

00:14:38,140 --> 00:14:43,150
users adequate warning that something

00:14:40,060 --> 00:14:45,550
may change when you're implementing

00:14:43,150 --> 00:14:47,590
cover you kind of need to decide a few

00:14:45,550 --> 00:14:49,510
things when you're starting out your

00:14:47,590 --> 00:14:52,360
goals dictate your release schedule if

00:14:49,510 --> 00:14:53,470
you want to have more dependable upgrade

00:14:52,360 --> 00:14:55,930
cycles for example if you have

00:14:53,470 --> 00:14:58,360
enterprise software release every six

00:14:55,930 --> 00:15:01,540
months that happens on a certain date is

00:14:58,360 --> 00:15:04,000
much better for sort of those enterprise

00:15:01,540 --> 00:15:05,920
people because II they will end up

00:15:04,000 --> 00:15:08,500
picking whatever version of software is

00:15:05,920 --> 00:15:10,330
currently released at that point anyway

00:15:08,500 --> 00:15:14,010
they won't upgrade to the next major

00:15:10,330 --> 00:15:16,360
version until that time has happened

00:15:14,010 --> 00:15:18,310
student Lee scheduled releases work well

00:15:16,360 --> 00:15:21,310
when they're not that often see one or

00:15:18,310 --> 00:15:23,020
two releases a year so for example your

00:15:21,310 --> 00:15:25,360
operating systems a bunch who has two

00:15:23,020 --> 00:15:27,130
releases a year enterprise software and

00:15:25,360 --> 00:15:29,620
the sort of things they're used by in

00:15:27,130 --> 00:15:33,580
big dependable basis for example Jengo

00:15:29,620 --> 00:15:35,860
have one every eight months now loser

00:15:33,580 --> 00:15:36,740
schedules meany can release as often as

00:15:35,860 --> 00:15:38,510
you want to get

00:15:36,740 --> 00:15:41,270
features or fixes into the users hands

00:15:38,510 --> 00:15:42,589
this works well if you have lots and

00:15:41,270 --> 00:15:44,360
lots of release of the year when you

00:15:42,589 --> 00:15:47,330
have software that changes a lot and

00:15:44,360 --> 00:15:49,880
involves a lot software that talks to

00:15:47,330 --> 00:15:51,980
external surfaces like YouTube or

00:15:49,880 --> 00:15:54,680
various other things things have

00:15:51,980 --> 00:15:57,230
security implementation a implications

00:15:54,680 --> 00:15:58,970
for example openssl need to release very

00:15:57,230 --> 00:16:01,310
often and you need to stay up to date

00:15:58,970 --> 00:16:02,899
with security in libraries and

00:16:01,310 --> 00:16:07,100
frameworks that maybe got undergoing

00:16:02,899 --> 00:16:09,200
constant small change now Django has a

00:16:07,100 --> 00:16:11,630
release every eight months or so twisted

00:16:09,200 --> 00:16:14,089
has about five every year youtube-dl has

00:16:11,630 --> 00:16:16,100
about one or two a week so it sort of

00:16:14,089 --> 00:16:17,690
makes sense that they all sort of have

00:16:16,100 --> 00:16:19,610
their different scheduling that

00:16:17,690 --> 00:16:21,170
youtube-dl may not change for two weeks

00:16:19,610 --> 00:16:23,240
because no one's broken anything and

00:16:21,170 --> 00:16:25,040
then it'll change because youtube has

00:16:23,240 --> 00:16:27,050
pushed a new fix what twisted we just

00:16:25,040 --> 00:16:29,330
sort of it doesn't really matter until

00:16:27,050 --> 00:16:31,760
like we see we think there's enough in a

00:16:29,330 --> 00:16:34,850
version to go p.m. you guys might want

00:16:31,760 --> 00:16:38,360
this so deprecation policies are

00:16:34,850 --> 00:16:42,320
important they must scale with your user

00:16:38,360 --> 00:16:44,480
base and with your releases so twisted

00:16:42,320 --> 00:16:45,709
has one year of deprivation as long as

00:16:44,480 --> 00:16:47,660
two releases have happened to the

00:16:45,709 --> 00:16:49,070
meantime so that you can't upgrade one

00:16:47,660 --> 00:16:51,890
release and instantly everything is

00:16:49,070 --> 00:16:53,660
broken in case there's no releases for

00:16:51,890 --> 00:16:57,649
certain certain amount of months like

00:16:53,660 --> 00:16:59,570
happened in 2014 Django however requires

00:16:57,649 --> 00:17:01,279
about eight to 16 months of deprecation

00:16:59,570 --> 00:17:04,220
so it might be one release if it's the

00:17:01,279 --> 00:17:07,010
one before an LTS so all the one right

00:17:04,220 --> 00:17:09,290
after an LTS so forget it's a little bit

00:17:07,010 --> 00:17:11,300
more complicated and they use a sort of

00:17:09,290 --> 00:17:13,880
assembler Calver sort of hybrid they're

00:17:11,300 --> 00:17:16,850
sort of doing half way arm but not quite

00:17:13,880 --> 00:17:18,589
all the way you do need to alter how you

00:17:16,850 --> 00:17:20,929
call it insurance works because

00:17:18,589 --> 00:17:22,699
constantly site changing software needs

00:17:20,929 --> 00:17:26,900
to sort of have different QA processes

00:17:22,699 --> 00:17:28,700
than you know going gold with for

00:17:26,900 --> 00:17:31,520
example a video game you have a product

00:17:28,700 --> 00:17:34,190
that you can then test and it will stay

00:17:31,520 --> 00:17:36,050
the same until some later update while

00:17:34,190 --> 00:17:38,720
constantly changing software you need to

00:17:36,050 --> 00:17:40,760
do it a lot more automated because you

00:17:38,720 --> 00:17:43,250
needed that as it changes it make sure

00:17:40,760 --> 00:17:45,919
things work because you won't have a

00:17:43,250 --> 00:17:47,840
person that sits down and QA is your

00:17:45,919 --> 00:17:50,530
entire release every single time you

00:17:47,840 --> 00:17:52,480
commit to master

00:17:50,530 --> 00:17:54,820
more tests does mean that you have less

00:17:52,480 --> 00:17:56,440
likelihood of regressions it doesn't

00:17:54,820 --> 00:17:58,360
completely eliminate them because you

00:17:56,440 --> 00:17:59,980
may not written test their covers that

00:17:58,360 --> 00:18:02,950
one specific case and you may have had

00:17:59,980 --> 00:18:04,990
one hundred percent line coverage and

00:18:02,950 --> 00:18:07,480
branch coverage but you might not have

00:18:04,990 --> 00:18:10,990
had something if you pass I've typed

00:18:07,480 --> 00:18:13,000
that you haven't expected you can issue

00:18:10,990 --> 00:18:14,920
release candidates and always have users

00:18:13,000 --> 00:18:16,480
that run their tests because you want

00:18:14,920 --> 00:18:18,730
them to have tests because you want them

00:18:16,480 --> 00:18:20,620
to also be calendar version run against

00:18:18,730 --> 00:18:22,420
your software so that you can make sure

00:18:20,620 --> 00:18:25,240
that your users won't be broken and if

00:18:22,420 --> 00:18:27,850
you can cultivate a culture of people

00:18:25,240 --> 00:18:29,440
testing on trunk every so often to make

00:18:27,850 --> 00:18:32,500
sure that things in flying haven't

00:18:29,440 --> 00:18:34,000
changed and things in releases that are

00:18:32,500 --> 00:18:37,180
about to happen haven't changed then you

00:18:34,000 --> 00:18:39,760
end up with much healthier software now

00:18:37,180 --> 00:18:42,010
regressions are the enemy of frequent

00:18:39,760 --> 00:18:44,440
releases because the more often you

00:18:42,010 --> 00:18:46,320
release the more often there is a chance

00:18:44,440 --> 00:18:49,630
that something like sneak into a release

00:18:46,320 --> 00:18:51,220
but what is a regression itself well

00:18:49,630 --> 00:18:52,930
regret a regression is when user

00:18:51,220 --> 00:18:57,040
software stops working through no fault

00:18:52,930 --> 00:18:59,440
of their own so so that means that

00:18:57,040 --> 00:19:03,160
they've done all due process so they've

00:18:59,440 --> 00:19:04,420
run their tests they've they've checked

00:19:03,160 --> 00:19:07,360
their warnings to see if there's a

00:19:04,420 --> 00:19:10,600
deprecation warnings and their software

00:19:07,360 --> 00:19:12,880
is tested enough that you know you can

00:19:10,600 --> 00:19:15,550
know that it's good and then you come in

00:19:12,880 --> 00:19:17,320
and you break everything so python

00:19:15,550 --> 00:19:20,140
import locations are given types of

00:19:17,320 --> 00:19:22,390
names return value types behavior all of

00:19:20,140 --> 00:19:23,980
these things are part of the public API

00:19:22,390 --> 00:19:26,770
that you need to protect from

00:19:23,980 --> 00:19:28,330
regressions however you do need to

00:19:26,770 --> 00:19:30,820
declare that no breaking changes only

00:19:28,330 --> 00:19:32,650
applies to the public API if you have

00:19:30,820 --> 00:19:34,690
internal implementation details they

00:19:32,650 --> 00:19:38,230
will need to change as long as the thing

00:19:34,690 --> 00:19:40,030
that user sees does not change and how

00:19:38,230 --> 00:19:42,160
can we introduce fewer of these

00:19:40,030 --> 00:19:46,060
regressions well if you have a clear

00:19:42,160 --> 00:19:47,530
public API you end up with having a line

00:19:46,060 --> 00:19:50,110
of what you can change and what you

00:19:47,530 --> 00:19:53,140
can't change if you have private api

00:19:50,110 --> 00:19:56,260
that you expose then that more need to

00:19:53,140 --> 00:19:59,830
be public even if it is in a underscored

00:19:56,260 --> 00:20:01,930
module you want to preference abstract

00:19:59,830 --> 00:20:04,330
interfaces over concrete implementations

00:20:01,930 --> 00:20:07,480
because something may not

00:20:04,330 --> 00:20:09,460
it could have the same type when it's

00:20:07,480 --> 00:20:11,320
when it's released and that might be for

00:20:09,460 --> 00:20:12,640
good reason for some things like bytes

00:20:11,320 --> 00:20:14,590
in you code you sort of do need to

00:20:12,640 --> 00:20:16,390
depend on types but for basically

00:20:14,590 --> 00:20:19,929
everything else you want to rely on duck

00:20:16,390 --> 00:20:24,399
typing and interfaces for example as

00:20:19,929 --> 00:20:26,289
open as open interfaces like interfaces

00:20:24,399 --> 00:20:28,269
versus abstract base classes all that

00:20:26,289 --> 00:20:30,159
sort of thing lets you say does this

00:20:28,269 --> 00:20:32,649
thing have these properties and that's

00:20:30,159 --> 00:20:34,090
all I care about and as long as that

00:20:32,649 --> 00:20:36,669
public API stays the same everything

00:20:34,090 --> 00:20:38,440
else can change and you want to test

00:20:36,669 --> 00:20:39,909
just using your public API what the

00:20:38,440 --> 00:20:42,730
users use you don't want to test

00:20:39,909 --> 00:20:44,289
internal implementation details you want

00:20:42,730 --> 00:20:46,120
to make sure that everything is passed

00:20:44,289 --> 00:20:48,279
in so that you can't accidentally mock

00:20:46,120 --> 00:20:50,889
out things that will cause regressions

00:20:48,279 --> 00:20:53,649
later because it does hide bugs in the

00:20:50,889 --> 00:20:55,899
underlying layers if you mock out time

00:20:53,649 --> 00:20:57,880
time and then time duct I'm suddenly

00:20:55,899 --> 00:20:59,620
returns a float or a long or something

00:20:57,880 --> 00:21:01,269
like that and your code doesn't work you

00:20:59,620 --> 00:21:03,159
want to know about it in your tests not

00:21:01,269 --> 00:21:04,659
because you mocked out time to time and

00:21:03,159 --> 00:21:07,299
I've seen that happened and it's

00:21:04,659 --> 00:21:10,210
terrible don't do it I talked about this

00:21:07,299 --> 00:21:13,539
in my talk last year so you I won't go

00:21:10,210 --> 00:21:15,100
into much more about rear exporting

00:21:13,539 --> 00:21:18,220
functionality also works rather well

00:21:15,100 --> 00:21:20,559
because you can you can sort of hint

00:21:18,220 --> 00:21:22,889
what your module actually provides with

00:21:20,559 --> 00:21:27,039
Dunder all but it doesn't work with

00:21:22,889 --> 00:21:29,320
importing things directly so to avoid

00:21:27,039 --> 00:21:30,970
having things that you've imported into

00:21:29,320 --> 00:21:33,639
your module that you use and then people

00:21:30,970 --> 00:21:35,500
rely on that being there you want to

00:21:33,639 --> 00:21:37,539
write private modules and then have one

00:21:35,500 --> 00:21:39,279
big module so you here's your private

00:21:37,539 --> 00:21:40,630
module so I've observer and formatting

00:21:39,279 --> 00:21:43,389
those are private modules and your

00:21:40,630 --> 00:21:44,620
public API inside of them now that's how

00:21:43,389 --> 00:21:46,899
you want to structure your code in your

00:21:44,620 --> 00:21:48,730
code base but you want to import them

00:21:46,899 --> 00:21:50,860
into logger so that your public API

00:21:48,730 --> 00:21:52,330
looks like this so you can't

00:21:50,860 --> 00:21:54,850
accidentally export any implementation

00:21:52,330 --> 00:21:57,490
detail so if you import JSON in there

00:21:54,850 --> 00:21:59,980
they can't accidentally import twisted

00:21:57,490 --> 00:22:02,110
logic JSON and in expect it to be there

00:21:59,980 --> 00:22:03,730
because you never say that it's there in

00:22:02,110 --> 00:22:05,289
the first place and users will depend on

00:22:03,730 --> 00:22:07,389
the dumbest things and even if you say

00:22:05,289 --> 00:22:08,740
that is not public API they will still

00:22:07,389 --> 00:22:11,620
rely on it and that will cause a

00:22:08,740 --> 00:22:13,330
regression so a regression is even when

00:22:11,620 --> 00:22:15,250
you've tried and you they're doing the

00:22:13,330 --> 00:22:17,889
wrong thing you want to keep software

00:22:15,250 --> 00:22:18,659
working you don't to track your

00:22:17,889 --> 00:22:20,849
performance

00:22:18,659 --> 00:22:23,159
because software with performance

00:22:20,849 --> 00:22:25,289
constraints performance degradation of

00:22:23,159 --> 00:22:27,720
even a couple of percent can make it a

00:22:25,289 --> 00:22:29,099
total non-starter for some things for

00:22:27,720 --> 00:22:31,529
example if you have embedded software

00:22:29,099 --> 00:22:34,049
you want to make sure that you stay the

00:22:31,529 --> 00:22:36,059
same speed or be faster because you

00:22:34,049 --> 00:22:38,489
don't want to have a user go yes it's

00:22:36,059 --> 00:22:39,749
grade this new version or my tests pass

00:22:38,489 --> 00:22:41,669
and they put in production and

00:22:39,749 --> 00:22:44,190
everything just falls apart because they

00:22:41,669 --> 00:22:45,929
can't service requests fast enough so

00:22:44,190 --> 00:22:47,340
you want both micro benchmarks which are

00:22:45,929 --> 00:22:49,830
the black box testing where you just

00:22:47,340 --> 00:22:51,869
have your code and then you give it some

00:22:49,830 --> 00:22:54,179
input and you record some output and

00:22:51,869 --> 00:22:55,950
it's very specific in unit testing so

00:22:54,179 --> 00:22:59,099
you end up with like you know these very

00:22:55,950 --> 00:23:01,049
fine sort of things because they don't

00:22:59,099 --> 00:23:03,919
do a lot but it's at the core of your

00:23:01,049 --> 00:23:07,200
code so you want to say that these

00:23:03,919 --> 00:23:08,789
specific primitives have the speed but

00:23:07,200 --> 00:23:10,799
you also want to have macro benchmarks

00:23:08,789 --> 00:23:12,299
which are all of your units together and

00:23:10,799 --> 00:23:14,460
then you can end up with some bigger

00:23:12,299 --> 00:23:17,009
picture things so for example that lat

00:23:14,460 --> 00:23:19,259
jump there that was when one of the pie

00:23:17,009 --> 00:23:21,389
pie developers realize that in denver in

00:23:19,259 --> 00:23:23,220
its of one of our modules that is only

00:23:21,389 --> 00:23:24,629
used when we've code that's actually

00:23:23,220 --> 00:23:26,489
running a web server and it's not the

00:23:24,629 --> 00:23:28,259
deep down internals actually

00:23:26,489 --> 00:23:30,269
instantiated something every single web

00:23:28,259 --> 00:23:32,460
request and we stop that and then pipe i

00:23:30,269 --> 00:23:34,379
jumped by like two hundred percent so

00:23:32,460 --> 00:23:36,570
it's good to have benchmarks at both

00:23:34,379 --> 00:23:38,519
those levels of the tiny old primitives

00:23:36,570 --> 00:23:41,369
that you may use a lot internally and

00:23:38,519 --> 00:23:44,749
then the outside api of what you know I

00:23:41,369 --> 00:23:47,159
user might use in in the real world

00:23:44,749 --> 00:23:48,960
you'd also want to implement code review

00:23:47,159 --> 00:23:51,659
because code review helps catch a lot of

00:23:48,960 --> 00:23:53,759
things we do have a lower defect per

00:23:51,659 --> 00:23:57,029
line of code than most other software

00:23:53,759 --> 00:23:59,039
because of our code review process and a

00:23:57,029 --> 00:24:00,659
lot of the bugs in twisted code that

00:23:59,039 --> 00:24:03,090
happened generally end up because that

00:24:00,659 --> 00:24:05,039
was before the code review process was

00:24:03,090 --> 00:24:06,779
implemented so there's all sorts of

00:24:05,039 --> 00:24:08,340
weird things in twisted web that if

00:24:06,779 --> 00:24:10,289
there was a code review process would

00:24:08,340 --> 00:24:11,820
have been spotted but only because it's

00:24:10,289 --> 00:24:16,009
broken somewhere down the line we've

00:24:11,820 --> 00:24:18,090
gone all how did they ever get committed

00:24:16,009 --> 00:24:20,519
much of these things can't be detected

00:24:18,090 --> 00:24:22,470
by tools but let's go into what aren't

00:24:20,519 --> 00:24:26,009
regressions security fixes are not

00:24:22,470 --> 00:24:27,960
regressions because a even if you can

00:24:26,009 --> 00:24:30,599
fix it in a compatible way you should

00:24:27,960 --> 00:24:32,130
but if you can't then it's better as we

00:24:30,599 --> 00:24:35,190
have secure code

00:24:32,130 --> 00:24:37,800
then not secure code that works because

00:24:35,190 --> 00:24:39,660
if you accidentally like leak all of

00:24:37,800 --> 00:24:42,330
Australia census information but hey

00:24:39,660 --> 00:24:44,090
they could upgrade and it was fine then

00:24:42,330 --> 00:24:46,590
you're going to run into some problems

00:24:44,090 --> 00:24:48,390
you do also want an escape hatch to

00:24:46,590 --> 00:24:50,400
remove outright broken code that has not

00:24:48,390 --> 00:24:51,960
compiled for years or doesn't work in

00:24:50,400 --> 00:24:54,030
reeling dangerous ways there is a

00:24:51,960 --> 00:24:56,700
massive foot gun that no one has been

00:24:54,030 --> 00:24:58,140
able to use correctly you want to have a

00:24:56,700 --> 00:25:00,720
process that breaking changes are

00:24:58,140 --> 00:25:02,760
unsurprising as possible so safely

00:25:00,720 --> 00:25:05,760
making breaking changes is deprecation

00:25:02,760 --> 00:25:12,000
you want to give more useful deprecation

00:25:05,760 --> 00:25:13,560
mornings and just like no stop twisted

00:25:12,000 --> 00:25:16,050
users something that tells you what

00:25:13,560 --> 00:25:18,120
version it was replicated in and where

00:25:16,050 --> 00:25:19,440
you can find a replacement which is very

00:25:18,120 --> 00:25:20,790
very useful for people that are

00:25:19,440 --> 00:25:22,830
upgrading they say oh there's this new

00:25:20,790 --> 00:25:24,840
warning here it is okay we can change

00:25:22,830 --> 00:25:27,900
this replacement you get a nice warning

00:25:24,840 --> 00:25:29,640
rather than just just like a big middle

00:25:27,900 --> 00:25:32,160
finger on your screen saying we've

00:25:29,640 --> 00:25:34,860
replaced something but we were going to

00:25:32,160 --> 00:25:37,770
tell you you should also try and make

00:25:34,860 --> 00:25:39,270
your old API shims over new AP is so

00:25:37,770 --> 00:25:41,130
then that you sort of don't end up with

00:25:39,270 --> 00:25:43,620
two implementations and if you fix a bug

00:25:41,130 --> 00:25:45,200
in one you fix the bug in both want to

00:25:43,620 --> 00:25:47,880
encourage your users for run Python with

00:25:45,200 --> 00:25:49,710
hwd that will turn on deprecation

00:25:47,880 --> 00:25:51,660
mornings so that when they upgrade you

00:25:49,710 --> 00:25:53,730
say run with deprecation warnings are

00:25:51,660 --> 00:25:55,890
there any are there anything saying that

00:25:53,730 --> 00:25:59,100
something will be deprecated if no you

00:25:55,890 --> 00:26:00,510
are completely safe to upgrade and then

00:25:59,100 --> 00:26:03,060
always remove it later don't leave

00:26:00,510 --> 00:26:05,190
things just lying around like you want

00:26:03,060 --> 00:26:06,690
to clean your house and clean your

00:26:05,190 --> 00:26:08,550
software as if it was your house and you

00:26:06,690 --> 00:26:10,530
wouldn't lawn bags of garbage so get rid

00:26:08,550 --> 00:26:12,600
of the bags of garbage but don't remove

00:26:10,530 --> 00:26:15,000
it all at once because then you're

00:26:12,600 --> 00:26:17,390
increasing the likelihood that someone

00:26:15,000 --> 00:26:19,500
was relying on something deprecated and

00:26:17,390 --> 00:26:21,570
relying on a lot of things being

00:26:19,500 --> 00:26:25,320
deprecated and then suddenly you know

00:26:21,570 --> 00:26:27,930
all of their stuff breaks so what does

00:26:25,320 --> 00:26:29,880
them tools to help so when you're doing

00:26:27,930 --> 00:26:31,170
a lot of changes a lot of small changes

00:26:29,880 --> 00:26:33,480
you want something that makes your news

00:26:31,170 --> 00:26:34,950
far better and when you have changes

00:26:33,480 --> 00:26:36,480
that may happen across many many

00:26:34,950 --> 00:26:37,830
releases you can't just put it in the

00:26:36,480 --> 00:26:39,480
news file because you're on double badge

00:26:37,830 --> 00:26:41,100
conflicts so if a little project that

00:26:39,480 --> 00:26:42,780
builds it that you make a little news

00:26:41,100 --> 00:26:45,240
fragments and it combines it into a

00:26:42,780 --> 00:26:45,960
bigger news file when you do your final

00:26:45,240 --> 00:26:48,299
release

00:26:45,960 --> 00:26:49,860
so it means that you sort of don't have

00:26:48,299 --> 00:26:53,070
to worry about people putting things in

00:26:49,860 --> 00:26:55,289
Long spots reach comparable versions

00:26:53,070 --> 00:26:57,659
this is pulled out from twisted pour

00:26:55,289 --> 00:27:00,750
that lets you actually compare versions

00:26:57,659 --> 00:27:02,429
so if you're checking for like is this

00:27:00,750 --> 00:27:05,789
available in this version I know that it

00:27:02,429 --> 00:27:07,590
is I can do which comparing rather than

00:27:05,789 --> 00:27:09,510
the weird to pool stuff that ceased

00:27:07,590 --> 00:27:11,370
operation info is there's a two ball but

00:27:09,510 --> 00:27:16,020
on Python 2.7 it's not a tuple is

00:27:11,370 --> 00:27:18,600
actually an object because why ko ko ko

00:27:16,020 --> 00:27:20,700
is great it's an online service and it

00:27:18,600 --> 00:27:24,059
can count to one that is why we use it

00:27:20,700 --> 00:27:25,649
because of code coverage services that

00:27:24,059 --> 00:27:27,809
you put all your Travis Cody and it's

00:27:25,649 --> 00:27:29,070
like all these lines were tested but you

00:27:27,809 --> 00:27:30,750
know we can't figure out that their

00:27:29,070 --> 00:27:32,640
combined so you can run your windows

00:27:30,750 --> 00:27:34,770
your links Mac os10 combine them and

00:27:32,640 --> 00:27:36,630
you'll figure out what he has covered on

00:27:34,770 --> 00:27:40,380
all of your services and get a much

00:27:36,630 --> 00:27:43,950
nicer number tox tox is great use it

00:27:40,380 --> 00:27:47,309
just use it more so T or they are you

00:27:43,950 --> 00:27:50,010
know six steps pick what properties you

00:27:47,309 --> 00:27:53,580
want in your calendar version have a

00:27:50,010 --> 00:27:55,409
clear public API ensure that your test

00:27:53,580 --> 00:27:58,770
suite covers all of the public API that

00:27:55,409 --> 00:28:00,360
can release early release often get

00:27:58,770 --> 00:28:02,669
those features into the hands of users

00:28:00,360 --> 00:28:04,320
so they can make things that are better

00:28:02,669 --> 00:28:08,070
because you've given them all these new

00:28:04,320 --> 00:28:09,779
happy tools to do things with and if you

00:28:08,070 --> 00:28:11,149
release too early and there's something

00:28:09,779 --> 00:28:13,409
that maybe wasn't a great idea

00:28:11,149 --> 00:28:16,169
deprecated but replace it with a better

00:28:13,409 --> 00:28:19,380
version of it and don't break the user

00:28:16,169 --> 00:28:23,419
software that is the most important

00:28:19,380 --> 00:28:23,419
thing questions

00:28:29,440 --> 00:28:35,960
does anyone have questions we've got

00:28:32,090 --> 00:28:37,370
about a minute yeah so you mentioned

00:28:35,960 --> 00:28:40,460
that Django has a bit of a hybrid

00:28:37,370 --> 00:28:43,130
between december and calvert yep do you

00:28:40,460 --> 00:28:45,500
think that Calver is proprietary project

00:28:43,130 --> 00:28:47,240
or there's a sort of a range of

00:28:45,500 --> 00:28:49,040
different options in that spectrum that

00:28:47,240 --> 00:28:51,260
project should choose based on their

00:28:49,040 --> 00:28:53,570
particular requirements or their size or

00:28:51,260 --> 00:28:55,340
any of those kind of things so I think

00:28:53,570 --> 00:28:57,050
the larger the project is the more

00:28:55,340 --> 00:28:59,210
appropriate calvaire is because it's

00:28:57,050 --> 00:29:01,580
more likely that several parts of it are

00:28:59,210 --> 00:29:05,000
going to be in flux so boiling it down

00:29:01,580 --> 00:29:06,950
into one number that says that yes this

00:29:05,000 --> 00:29:09,230
definitely has no breaking changes in it

00:29:06,950 --> 00:29:10,940
is not going to work especially if you

00:29:09,230 --> 00:29:12,620
have tiny little bits of code that you

00:29:10,940 --> 00:29:14,270
know you don't want to increment every

00:29:12,620 --> 00:29:16,040
single time you fix a little thing in

00:29:14,270 --> 00:29:18,530
the Django RM that know what used

00:29:16,040 --> 00:29:20,480
because you wind up with like Django 107

00:29:18,530 --> 00:29:22,640
and then that's just not useful to

00:29:20,480 --> 00:29:26,480
anyone because it's like why does 107

00:29:22,640 --> 00:29:28,520
versions for smaller software or

00:29:26,480 --> 00:29:30,980
software that has very very clear

00:29:28,520 --> 00:29:33,350
boundaries as to what it does then I

00:29:30,980 --> 00:29:35,990
think works a bit better but once

00:29:33,350 --> 00:29:38,780
you get larger than just like doing one

00:29:35,990 --> 00:29:40,280
exact thing for example frameworks frame

00:29:38,780 --> 00:29:41,510
which should use calibre because they

00:29:40,280 --> 00:29:42,950
are something that you constantly

00:29:41,510 --> 00:29:45,380
upgrade you want to be on the latest

00:29:42,950 --> 00:29:47,420
version of and when you have large

00:29:45,380 --> 00:29:49,610
breaking changes for example there's a

00:29:47,420 --> 00:29:52,490
lot of like companies that are on gender

00:29:49,610 --> 00:29:54,140
1.5 well if there was something that you

00:29:52,490 --> 00:29:56,870
promised that there was never any

00:29:54,140 --> 00:29:58,970
breaking changes and each release was

00:29:56,870 --> 00:30:00,830
more often and was much smaller so then

00:29:58,970 --> 00:30:02,120
there was less risk to upgrading and

00:30:00,830 --> 00:30:04,160
then getting culture of constantly

00:30:02,120 --> 00:30:06,309
upgrading your dependencies then you end

00:30:04,160 --> 00:30:09,290
up with like I'm much better you know

00:30:06,309 --> 00:30:11,300
uses you know having the latest software

00:30:09,290 --> 00:30:14,270
for that but if you have something that

00:30:11,300 --> 00:30:16,790
is like very specific like a algorithm

00:30:14,270 --> 00:30:18,860
that you can say this is version 1 of an

00:30:16,790 --> 00:30:21,830
algorithm and this is veteran to of an

00:30:18,860 --> 00:30:24,320
algorithm then that is sort of specific

00:30:21,830 --> 00:30:27,170
enough that you can say that yes this is

00:30:24,320 --> 00:30:29,300
a small enough API service surface that

00:30:27,170 --> 00:30:31,640
version one might just be the only

00:30:29,300 --> 00:30:33,920
version and it will never change and

00:30:31,640 --> 00:30:36,620
then you have a bug fix and the greatest

00:30:33,920 --> 00:30:39,560
example of this is um lay tech Soleil

00:30:36,620 --> 00:30:41,690
Tech is it now I think tech just just

00:30:39,560 --> 00:30:46,970
general tech it's

00:30:41,690 --> 00:30:49,820
is sort of perfect lightech is perfect

00:30:46,970 --> 00:30:52,009
and when they do a bug fix which happens

00:30:49,820 --> 00:30:54,860
very rarely it's amazing it's like NASA

00:30:52,009 --> 00:30:56,990
software these keep adding a version on

00:30:54,860 --> 00:30:59,299
the end and it gets closer and closer to

00:30:56,990 --> 00:31:01,460
whichever numerical constant that a bit

00:30:59,299 --> 00:31:02,990
of software User's so I think meta font

00:31:01,460 --> 00:31:06,200
has a different 1i think metaphors is

00:31:02,990 --> 00:31:10,100
like the e constant and I think Leigh

00:31:06,200 --> 00:31:12,320
tech is I think tech is pi so it just

00:31:10,100 --> 00:31:14,090
gets closer and closer and closer so I

00:31:12,320 --> 00:31:15,980
think for that you can say that yeah

00:31:14,090 --> 00:31:18,980
latex is perfect and it will never

00:31:15,980 --> 00:31:21,110
change because once the author dies then

00:31:18,980 --> 00:31:22,759
there will just be no more changes to

00:31:21,110 --> 00:31:24,350
ever and it would be perfect and will

00:31:22,759 --> 00:31:25,970
sit on your hard drive for eternity and

00:31:24,350 --> 00:31:28,129
everyone will love it and it will still

00:31:25,970 --> 00:31:31,279
overflow all the text and complain about

00:31:28,129 --> 00:31:36,340
overfill H boxes now will be as the

00:31:31,279 --> 00:31:36,340

YouTube URL: https://www.youtube.com/watch?v=m44brj9PwPA


