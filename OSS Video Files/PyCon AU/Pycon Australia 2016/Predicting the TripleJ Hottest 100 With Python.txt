Title: Predicting the TripleJ Hottest 100 With Python
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Justin Warren
https://2016.pycon-au.org/schedule/41/view_talk
For several years now, I've used Python to help me attempt to predict the results of TripleJ's Hottest 100.

LEARN! how to write scripts that use more than CPU0 on your fancy multi-core laptop!

SEE! the alarming amount of information you can get through social network APIs.

MARVEL! at the myriad ways Optical Character Recognition will mangle your text!
Captions: 
	00:00:00,620 --> 00:00:05,670
welcome back everyone I'll just make a

00:00:03,570 --> 00:00:08,580
note there lots of empty seats up front

00:00:05,670 --> 00:00:10,200
here that may mean that any late comers

00:00:08,580 --> 00:00:12,330
will find it easier to get a seat in the

00:00:10,200 --> 00:00:18,539
back if anybody feels like moving

00:00:12,330 --> 00:00:22,680
forward okay so the last speaker for

00:00:18,539 --> 00:00:25,289
this session is Justin Warren and he'll

00:00:22,680 --> 00:00:30,029
be talking about predicting the triple j

00:00:25,289 --> 00:00:32,640
hottest 100 with python justin is an

00:00:30,029 --> 00:00:34,710
analyst in a consultant specializing in

00:00:32,640 --> 00:00:37,079
enterprise technology particularly

00:00:34,710 --> 00:00:40,980
infrastructure open source software and

00:00:37,079 --> 00:00:44,040
information security and he works for

00:00:40,980 --> 00:00:52,890
well he runs pivot man based in

00:00:44,040 --> 00:00:55,020
Melbourne please welcome Justin says

00:00:52,890 --> 00:00:57,300
this is me I run a consulting company

00:00:55,020 --> 00:00:59,280
called pivot nine and we have benefited

00:00:57,300 --> 00:01:01,140
a lot from using Python which is one of

00:00:59,280 --> 00:01:02,820
the reasons that we I came here as a

00:01:01,140 --> 00:01:05,250
contributor so that I can help get some

00:01:02,820 --> 00:01:07,200
money back into the community and I run

00:01:05,250 --> 00:01:09,360
a blog at I can magic and do podcast

00:01:07,200 --> 00:01:11,790
things and I moonlight as a journalist

00:01:09,360 --> 00:01:13,170
as well as we will see in a moment if

00:01:11,790 --> 00:01:14,970
you want to find me i'm usually on

00:01:13,170 --> 00:01:17,130
twitter and that's my Twitter handle so

00:01:14,970 --> 00:01:19,439
this is about something that started

00:01:17,130 --> 00:01:21,570
probably that for years ago I'm not sure

00:01:19,439 --> 00:01:24,150
how familiar you are show of hands who

00:01:21,570 --> 00:01:26,580
knows about the hottest 100 okay good

00:01:24,150 --> 00:01:29,400
excellent I'm a big fan how many people

00:01:26,580 --> 00:01:31,740
know about the warmest 100 not so many

00:01:29,400 --> 00:01:34,350
okay so quick explanation the warmest

00:01:31,740 --> 00:01:36,479
100 was a bunch of guys based in

00:01:34,350 --> 00:01:38,490
Brisbane I think who figured out a way

00:01:36,479 --> 00:01:40,290
to use social media to predict the

00:01:38,490 --> 00:01:43,470
hottest 100 so they called it the

00:01:40,290 --> 00:01:46,140
warmest 100 and they got a bit of media

00:01:43,470 --> 00:01:49,500
some of it was from me so I wrote about

00:01:46,140 --> 00:01:52,079
it and how they had predicted what the

00:01:49,500 --> 00:01:54,869
hottest 100 was going to be and they did

00:01:52,079 --> 00:01:56,189
it not long after voting closed it was

00:01:54,869 --> 00:01:58,770
the first time anyone had done this and

00:01:56,189 --> 00:02:01,619
it has been done never since then by

00:01:58,770 --> 00:02:04,560
them and also by me now they did it

00:02:01,619 --> 00:02:07,250
first but in as part of researching the

00:02:04,560 --> 00:02:09,479
story to write all these things I

00:02:07,250 --> 00:02:11,370
decided that I would go and re-implement

00:02:09,479 --> 00:02:13,200
what they've done so it was basically a

00:02:11,370 --> 00:02:13,950
replication study if you like so I

00:02:13,200 --> 00:02:15,720
thought they

00:02:13,950 --> 00:02:18,480
interviewing them they told me how it

00:02:15,720 --> 00:02:20,160
worked and I said well okay I think I

00:02:18,480 --> 00:02:23,069
can do that and i'm going to use python

00:02:20,160 --> 00:02:25,200
mostly and so what I want to talk to you

00:02:23,069 --> 00:02:27,900
about is how we use the tool chain so

00:02:25,200 --> 00:02:30,870
that's the results that they got so you

00:02:27,900 --> 00:02:33,150
can see it's pretty rough when you're

00:02:30,870 --> 00:02:34,739
around all 80 90 100 and that's just

00:02:33,150 --> 00:02:36,209
because of the statistics method that we

00:02:34,739 --> 00:02:38,610
were using it was a sampling method

00:02:36,209 --> 00:02:41,099
there's not as many votes for number 90

00:02:38,610 --> 00:02:43,980
as there are four number one and two

00:02:41,099 --> 00:02:45,500
you'd expect that so the results got

00:02:43,980 --> 00:02:48,780
better and better and better the more

00:02:45,500 --> 00:02:51,030
votes we had so that's what they did I

00:02:48,780 --> 00:02:53,489
got involved a bit late so I didn't have

00:02:51,030 --> 00:02:55,980
as bigger data sample so my my results

00:02:53,489 --> 00:02:58,440
aren't quite as good but they still get

00:02:55,980 --> 00:03:02,069
better and better over time so this talk

00:02:58,440 --> 00:03:06,360
is about how how I did that and how you

00:03:02,069 --> 00:03:08,220
can do it too so the toolchain the tool

00:03:06,360 --> 00:03:09,510
chain has basically three major

00:03:08,220 --> 00:03:11,069
components the first one is data

00:03:09,510 --> 00:03:13,319
gathering so we want to go and get the

00:03:11,069 --> 00:03:15,690
data and to do that we use W get

00:03:13,319 --> 00:03:17,610
everyone knows about W get I assume who

00:03:15,690 --> 00:03:21,660
doesn't anyone show hands of who doesn't

00:03:17,610 --> 00:03:24,450
what unpleasant Google is your friend so

00:03:21,660 --> 00:03:26,850
there's also a Python library called

00:03:24,450 --> 00:03:28,290
beautiful soup particular version 4 is

00:03:26,850 --> 00:03:29,430
the one that we were using and I'll go

00:03:28,290 --> 00:03:32,250
into that in a little bit more detail

00:03:29,430 --> 00:03:34,799
and the other part of it was Twitter and

00:03:32,250 --> 00:03:37,560
Instagram so what happened was that in

00:03:34,799 --> 00:03:39,569
the first version Triple J had a thing

00:03:37,560 --> 00:03:41,970
where you go tweet your vote and they

00:03:39,569 --> 00:03:43,560
very helpfully put a link to it so that

00:03:41,970 --> 00:03:46,170
you could go and share your vote with

00:03:43,560 --> 00:03:48,060
everybody else and that went on to

00:03:46,170 --> 00:03:50,940
social media which is public which means

00:03:48,060 --> 00:03:52,470
anyone may warmest 100 folks could go

00:03:50,940 --> 00:03:54,569
along and find out what everyone voted

00:03:52,470 --> 00:03:56,849
for and we can use that as a statistical

00:03:54,569 --> 00:03:58,889
sample from the population which we can

00:03:56,849 --> 00:04:02,160
then use to make predictions which we

00:03:58,889 --> 00:04:04,290
did pretty simple really so the middle

00:04:02,160 --> 00:04:06,599
part is doing that data processing going

00:04:04,290 --> 00:04:08,549
and grabbing that information figuring

00:04:06,599 --> 00:04:10,500
out what the vote looks like and we used

00:04:08,549 --> 00:04:12,780
an OCR tool called tesseract again I'll

00:04:10,500 --> 00:04:14,220
go into that in a bit more and then we

00:04:12,780 --> 00:04:15,720
had to do a bunch of data cleansing now

00:04:14,220 --> 00:04:17,459
this is something that you always have

00:04:15,720 --> 00:04:19,139
to do with the data analysis thing as

00:04:17,459 --> 00:04:21,690
I'm sure many data scientists out there

00:04:19,139 --> 00:04:23,159
would no data is messy and horrible

00:04:21,690 --> 00:04:24,630
because the real world is messy and

00:04:23,159 --> 00:04:25,660
horrible so you have to clean it up to

00:04:24,630 --> 00:04:27,790
make it a little bit more sense

00:04:25,660 --> 00:04:30,070
and then you do the analysis which

00:04:27,790 --> 00:04:31,540
basically there's a particular technique

00:04:30,070 --> 00:04:33,910
that i called that i use called

00:04:31,540 --> 00:04:36,280
Levenstein analysis that was used in the

00:04:33,910 --> 00:04:38,740
later version and i'll explain why i

00:04:36,280 --> 00:04:40,780
chose that one compared to some other

00:04:38,740 --> 00:04:42,850
options and I thing called

00:04:40,780 --> 00:04:44,740
multiprocessing which I want to talk

00:04:42,850 --> 00:04:46,150
about as well which is a Python library

00:04:44,740 --> 00:04:49,720
again show of hands who's heard of

00:04:46,150 --> 00:04:51,580
multiprocessing excellent okay the first

00:04:49,720 --> 00:04:53,200
version of this used a method that's not

00:04:51,580 --> 00:04:54,880
quite as efficient and useful as a

00:04:53,200 --> 00:04:57,400
second method and I want to go into that

00:04:54,880 --> 00:05:01,840
will explain how that works so data

00:04:57,400 --> 00:05:04,210
gathering this is 2013 sight of what

00:05:01,840 --> 00:05:06,520
actually happened in the votes you can

00:05:04,210 --> 00:05:08,020
go on to the site and as people seem to

00:05:06,520 --> 00:05:10,660
be aware of it you go there and you

00:05:08,020 --> 00:05:12,760
select which songs you like and it's a

00:05:10,660 --> 00:05:14,680
we've picked 10 songs you don't rank

00:05:12,760 --> 00:05:17,080
them in order you just say here are 10

00:05:14,680 --> 00:05:19,930
votes for the songs that I want to be in

00:05:17,080 --> 00:05:21,460
the hottest 100 and so we need to know

00:05:19,930 --> 00:05:23,500
what are the songs that people could

00:05:21,460 --> 00:05:24,910
vote for because otherwise we don't know

00:05:23,500 --> 00:05:27,250
the difference between something which

00:05:24,910 --> 00:05:30,370
is a vote for songs and just some random

00:05:27,250 --> 00:05:33,250
text so we go to the website and we use

00:05:30,370 --> 00:05:36,370
W get and or Chrome or Firefox and we

00:05:33,250 --> 00:05:39,220
screen scrape it's pretty simple it's

00:05:36,370 --> 00:05:41,050
largely manual actually you can kind of

00:05:39,220 --> 00:05:42,490
script it but it ends up taking longer

00:05:41,050 --> 00:05:46,570
to write the script than it does to just

00:05:42,490 --> 00:05:49,000
go to the page and just download a b c d

00:05:46,570 --> 00:05:51,730
and just save the HTML which we then

00:05:49,000 --> 00:05:53,919
pars and the way that we do that is we

00:05:51,730 --> 00:05:56,560
use a thing called beautiful soup now

00:05:53,919 --> 00:05:57,910
it's a weird name I don't know why they

00:05:56,560 --> 00:06:01,180
call the beautiful soup but they did and

00:05:57,910 --> 00:06:05,260
it basically it's just an HTML parser it

00:06:01,180 --> 00:06:07,090
turns some HTML and this is the sort of

00:06:05,260 --> 00:06:10,810
function that I used this is I think

00:06:07,090 --> 00:06:12,700
2012-2013 this is the function all part

00:06:10,810 --> 00:06:15,580
of the the modular and pa's earth at

00:06:12,700 --> 00:06:17,440
just goes to the HTML grabs the bits

00:06:15,580 --> 00:06:19,390
that we need which is the song name the

00:06:17,440 --> 00:06:20,890
artist name and a couple of other bits

00:06:19,390 --> 00:06:23,380
of information that are useful in this

00:06:20,890 --> 00:06:26,050
case the the link in the track URL that

00:06:23,380 --> 00:06:28,390
it came from and we just chuck that into

00:06:26,050 --> 00:06:32,440
an CSV file which it then dumps out to

00:06:28,390 --> 00:06:33,850
disk that's basically it then we want to

00:06:32,440 --> 00:06:35,979
go and find the information on the votes

00:06:33,850 --> 00:06:37,780
now the first year was really handy

00:06:35,979 --> 00:06:39,160
because Triple J used a thing called

00:06:37,780 --> 00:06:41,350
triple j gadget

00:06:39,160 --> 00:06:43,930
and that would go into the URL when you

00:06:41,350 --> 00:06:45,520
went insert when you went chair and it

00:06:43,930 --> 00:06:46,900
was a lovely filter string because it

00:06:45,520 --> 00:06:48,700
was the only thing that was going to

00:06:46,900 --> 00:06:50,800
have that thing in it otherwise everyone

00:06:48,700 --> 00:06:52,360
is goin hashtag hottest 100 and that had

00:06:50,800 --> 00:06:54,810
all sorts of other nonsense and noise

00:06:52,360 --> 00:06:57,850
and craziness this was lovely and clean

00:06:54,810 --> 00:06:59,290
so that made it really easy and there

00:06:57,850 --> 00:07:03,040
was a there's a thing that you could

00:06:59,290 --> 00:07:04,740
just grab off pipe with pip called

00:07:03,040 --> 00:07:07,060
Twitter which just calls the Twitter API

00:07:04,740 --> 00:07:09,190
make gives it a lovely Python thing and

00:07:07,060 --> 00:07:11,050
login and password which we don't use

00:07:09,190 --> 00:07:13,120
anymore but when we did this in the

00:07:11,050 --> 00:07:16,600
first year it was that easy put in my

00:07:13,120 --> 00:07:18,850
log in my password and scrape no sleep

00:07:16,600 --> 00:07:21,640
one go and fetch another another vote

00:07:18,850 --> 00:07:24,190
put it into a file and voila we've got

00:07:21,640 --> 00:07:26,770
all the things instagram was bit

00:07:24,190 --> 00:07:29,620
trickier after the first year when they

00:07:26,770 --> 00:07:31,570
change this then they didn't have these

00:07:29,620 --> 00:07:33,520
lovely links back to people's exact

00:07:31,570 --> 00:07:35,080
votes so we had to figure out a

00:07:33,520 --> 00:07:36,910
different way of doing it turns out

00:07:35,080 --> 00:07:39,430
people really like the hottest 100 and

00:07:36,910 --> 00:07:41,650
they like to share so what they would do

00:07:39,430 --> 00:07:43,780
is that they would vote and then they

00:07:41,650 --> 00:07:45,580
would go and put it up on Instagram and

00:07:43,780 --> 00:07:48,280
it would look something like that I

00:07:45,580 --> 00:07:49,570
think this is 2015 it's a boat but this

00:07:48,280 --> 00:07:52,360
is this is basically what it would look

00:07:49,570 --> 00:07:53,920
like one frustration would be that

00:07:52,360 --> 00:07:56,290
Triple J would keep changing what this

00:07:53,920 --> 00:07:58,270
looks like so that made it you had to

00:07:56,290 --> 00:08:00,580
adapt things from here to here but

00:07:58,270 --> 00:08:02,110
that's what we would go and grab that's

00:08:00,580 --> 00:08:05,110
the image which would then need to go on

00:08:02,110 --> 00:08:07,390
process so we die together using

00:08:05,110 --> 00:08:09,160
instagram api in this case you go and

00:08:07,390 --> 00:08:10,600
use an access token which means you have

00:08:09,160 --> 00:08:12,610
to log into it you have to have an

00:08:10,600 --> 00:08:13,840
instagram account you set up this is an

00:08:12,610 --> 00:08:15,850
application you run through this

00:08:13,840 --> 00:08:18,010
standard thing there's documentation on

00:08:15,850 --> 00:08:19,630
their site for how to do that you put in

00:08:18,010 --> 00:08:21,430
an access token which are very cleverly

00:08:19,630 --> 00:08:24,310
not put in here so that you can't go and

00:08:21,430 --> 00:08:25,690
use my account and then you just go and

00:08:24,310 --> 00:08:27,520
say right find all the type of the

00:08:25,690 --> 00:08:29,950
recent tagged media with that hashtag

00:08:27,520 --> 00:08:31,720
hottest 100 and everyone who has tagged

00:08:29,950 --> 00:08:34,120
their Instagram photo with hottest 100

00:08:31,720 --> 00:08:35,979
and you get all of their photos not all

00:08:34,120 --> 00:08:37,900
of them are votes some of them are

00:08:35,979 --> 00:08:39,760
photos of people having a hottest 100

00:08:37,900 --> 00:08:42,219
party some of them have nothing to do

00:08:39,760 --> 00:08:45,610
with hottest 100 at all which is bizarre

00:08:42,219 --> 00:08:51,490
and weird again real life is messy data

00:08:45,610 --> 00:08:53,020
is messy w get 41 in whatever thousand

00:08:51,490 --> 00:08:55,630
URLs we have gone fetch DM

00:08:53,020 --> 00:08:58,270
save it to disk then we do the data

00:08:55,630 --> 00:09:00,040
processing now there's a great library

00:08:58,270 --> 00:09:01,420
called tesseract well it's not really a

00:09:00,040 --> 00:09:03,580
library it's actually an application

00:09:01,420 --> 00:09:06,610
it's written in C I believe but it is

00:09:03,580 --> 00:09:07,960
available in github ah octo cat doesn't

00:09:06,610 --> 00:09:12,910
show up well in black I'll have to

00:09:07,960 --> 00:09:15,340
remember that a sad face it's better

00:09:12,910 --> 00:09:17,790
over here he's weird shades of black or

00:09:15,340 --> 00:09:22,570
she did a head is Russia I don't know

00:09:17,790 --> 00:09:24,760
yes may not may not be either so we use

00:09:22,570 --> 00:09:26,650
tesseract it's an optical character

00:09:24,760 --> 00:09:28,990
recognition piece of software so it will

00:09:26,650 --> 00:09:30,760
go and look at that and like you and me

00:09:28,990 --> 00:09:32,560
it will figure out what what is a

00:09:30,760 --> 00:09:34,660
character and what isn't and then it

00:09:32,560 --> 00:09:37,240
will spit out something that looks a bit

00:09:34,660 --> 00:09:41,200
like this as you can see it's not

00:09:37,240 --> 00:09:43,570
perfect because that sort of thing is a

00:09:41,200 --> 00:09:46,060
bit weird and depending on what fonts

00:09:43,570 --> 00:09:47,800
used and how good the resolution is and

00:09:46,060 --> 00:09:50,080
whether they've added some fancy filter

00:09:47,800 --> 00:09:52,330
or not can mean it's a bit hard for

00:09:50,080 --> 00:09:55,360
tesseract to read it you can tweak some

00:09:52,330 --> 00:09:57,400
of the settings to say the this is the

00:09:55,360 --> 00:09:59,050
character set that you should use you

00:09:57,400 --> 00:10:01,270
know it's in English it's not in French

00:09:59,050 --> 00:10:04,540
so don't go putting ear cutes all over

00:10:01,270 --> 00:10:07,180
the place it's still not perfect so we

00:10:04,540 --> 00:10:08,740
have to go and clean it up and some of

00:10:07,180 --> 00:10:10,210
the time it was just easier to just

00:10:08,740 --> 00:10:11,800
fighting some regular expressions for

00:10:10,210 --> 00:10:13,060
common mistakes that it would make and

00:10:11,800 --> 00:10:16,210
just go and replace them with something

00:10:13,060 --> 00:10:17,950
else again we weren't trying for

00:10:16,210 --> 00:10:22,200
perfection we were just trying to get

00:10:17,950 --> 00:10:25,300
good enough and that was good enough

00:10:22,200 --> 00:10:26,980
then we do the data analysis so we had

00:10:25,300 --> 00:10:31,560
to go and figure out when we have a

00:10:26,980 --> 00:10:33,580
string like that does it match this

00:10:31,560 --> 00:10:36,490
probably we would look at that and go

00:10:33,580 --> 00:10:40,270
yes yes it does computers are really

00:10:36,490 --> 00:10:41,890
stupid and they have no idea whether

00:10:40,270 --> 00:10:43,870
that matches or not so we have to kind

00:10:41,890 --> 00:10:46,060
of figure out well how do you decide

00:10:43,870 --> 00:10:47,470
that that string is similar to this up

00:10:46,060 --> 00:10:49,960
the string is that that's actually

00:10:47,470 --> 00:10:51,100
pretty tricky to do and you don't really

00:10:49,960 --> 00:10:54,010
think about it until you try to write a

00:10:51,100 --> 00:10:57,130
program it says well how similar do they

00:10:54,010 --> 00:11:00,550
need to be for us to decide that yes

00:10:57,130 --> 00:11:02,890
that is the same so the first way I used

00:11:00,550 --> 00:11:04,600
which I don't understand but it's a

00:11:02,890 --> 00:11:06,340
library that does this which is called

00:11:04,600 --> 00:11:06,790
milsim so hash basically it was designed

00:11:06,340 --> 00:11:08,170
around

00:11:06,790 --> 00:11:10,960
male so that you could figure out is

00:11:08,170 --> 00:11:13,180
this email similar to this other email

00:11:10,960 --> 00:11:15,430
by running a hash function over over it

00:11:13,180 --> 00:11:19,000
and it sort of looks like this so you

00:11:15,430 --> 00:11:22,750
have right and left so comparison left

00:11:19,000 --> 00:11:25,150
comparison right do Neil sim sir on it

00:11:22,750 --> 00:11:26,710
so it does some magic statistics things

00:11:25,150 --> 00:11:28,060
and says okay we've got those two and

00:11:26,710 --> 00:11:29,710
then we do a hash of them and then we

00:11:28,060 --> 00:11:34,570
compare those two hash so it does a hash

00:11:29,710 --> 00:11:35,740
digest but it's not like char one or md5

00:11:34,570 --> 00:11:37,390
or other hashes that you're probably

00:11:35,740 --> 00:11:38,410
familiar with which are one-way hash is

00:11:37,390 --> 00:11:39,850
that you shouldn't be able to come back

00:11:38,410 --> 00:11:41,320
the other way how many people are

00:11:39,850 --> 00:11:44,770
familiar with that kind of crypto

00:11:41,320 --> 00:11:47,710
hashing things yes okay good this

00:11:44,770 --> 00:11:49,720
hashing is not designed to be one way

00:11:47,710 --> 00:11:51,250
it's designed to come out with if you

00:11:49,720 --> 00:11:54,430
have similar input you should have

00:11:51,250 --> 00:11:56,800
similar output and it's similar in a

00:11:54,430 --> 00:12:00,340
specific way so then you can say if the

00:11:56,800 --> 00:12:03,730
if that similar run-in if SCIM on this

00:12:00,340 --> 00:12:07,390
is similar enough which you set as a

00:12:03,730 --> 00:12:09,610
function then it will work it will say

00:12:07,390 --> 00:12:11,920
yes they're similar enough those that is

00:12:09,610 --> 00:12:14,050
the vote that they had levenshtein

00:12:11,920 --> 00:12:16,060
distance is different what this does is

00:12:14,050 --> 00:12:17,830
it tries to figure out whether or not

00:12:16,060 --> 00:12:19,540
the two strings are different it

00:12:17,830 --> 00:12:21,550
basically says how many characters in

00:12:19,540 --> 00:12:24,370
their string would need to change for it

00:12:21,550 --> 00:12:27,310
to match the other one so dog and cat

00:12:24,370 --> 00:12:28,780
are both three letters but you won't

00:12:27,310 --> 00:12:31,270
have to change many letters to make them

00:12:28,780 --> 00:12:33,280
be similar whereas cat and character

00:12:31,270 --> 00:12:34,030
based string difference are quite

00:12:33,280 --> 00:12:36,190
different because there's more

00:12:34,030 --> 00:12:38,470
characters in it so it actually works

00:12:36,190 --> 00:12:39,970
better than Neil seems to hash again I

00:12:38,470 --> 00:12:42,130
don't really understand the math behind

00:12:39,970 --> 00:12:44,680
it it's a library I just use it you know

00:12:42,130 --> 00:12:47,440
import teleportation it's great pythons

00:12:44,680 --> 00:12:49,090
awesome for that so what you do is you

00:12:47,440 --> 00:12:51,010
say well hit in this case it was a key

00:12:49,090 --> 00:12:53,230
in a new UK which is just the code that

00:12:51,010 --> 00:12:55,870
i was using basically it says here is

00:12:53,230 --> 00:12:57,580
the tesseract key here is the actual key

00:12:55,870 --> 00:12:59,740
that we think it should be because i'm

00:12:57,580 --> 00:13:02,440
doing a for in for each song in the

00:12:59,740 --> 00:13:04,270
entire corpus how similar are they if

00:13:02,440 --> 00:13:06,010
they're similar enough which is the

00:13:04,270 --> 00:13:07,600
threshold which is a dynamic parameter

00:13:06,010 --> 00:13:10,060
you tune and muck around with it a few

00:13:07,600 --> 00:13:14,140
times to test what worked and if it is

00:13:10,060 --> 00:13:16,900
then yeah a match one vote and then we

00:13:14,140 --> 00:13:18,850
do that for I think it was about five or

00:13:16,900 --> 00:13:20,320
six thousand different files and all of

00:13:18,850 --> 00:13:22,240
the different thousands of songs

00:13:20,320 --> 00:13:23,740
and it's great because my laptop has an

00:13:22,240 --> 00:13:28,930
i7 in it and it does this really really

00:13:23,740 --> 00:13:30,940
fast which is great how multiprocessing

00:13:28,930 --> 00:13:32,530
if you do it one at a time and you've

00:13:30,940 --> 00:13:33,940
got several thousand of them in all the

00:13:32,530 --> 00:13:36,580
different combinations that's really

00:13:33,940 --> 00:13:39,160
slow as it turns out multiprocessing is

00:13:36,580 --> 00:13:42,430
less slow that is not to say that it is

00:13:39,160 --> 00:13:45,670
fast but it is less lot there are also

00:13:42,430 --> 00:13:47,530
slower and less slower reason ways of

00:13:45,670 --> 00:13:50,590
using multiprocessing as it turns out

00:13:47,530 --> 00:13:53,200
now the kind of obvious way to use

00:13:50,590 --> 00:13:54,910
multiprocessing is to use chunking that

00:13:53,200 --> 00:13:57,580
was the way I did it at first so it's a

00:13:54,910 --> 00:13:59,140
bit like mapreduce we have this entire

00:13:57,580 --> 00:14:01,450
list of possible vote things we need to

00:13:59,140 --> 00:14:04,060
go on process so all of those files over

00:14:01,450 --> 00:14:06,070
there and all of these I have eight CPUs

00:14:04,060 --> 00:14:08,830
in my machine that I can use so let's

00:14:06,070 --> 00:14:12,580
divide up the work and say right the

00:14:08,830 --> 00:14:15,610
first person can use MapReduce the first

00:14:12,580 --> 00:14:17,800
one here's cpu you are su PR 0 you can

00:14:15,610 --> 00:14:20,890
have this many so let's say we've got

00:14:17,800 --> 00:14:23,050
10,000 CPU 0 10,000 let's do this easily

00:14:20,890 --> 00:14:25,540
will say there's five processes because

00:14:23,050 --> 00:14:28,510
I don't like math and then we can say

00:14:25,540 --> 00:14:30,670
right you get 2,000 cpu one you get

00:14:28,510 --> 00:14:32,110
2,000 cpu 2 gets two thousand and so on

00:14:30,670 --> 00:14:34,120
and so forth so everyone gets the same

00:14:32,110 --> 00:14:35,860
amount of work that should work really

00:14:34,120 --> 00:14:41,290
nicely and have nice even load balancing

00:14:35,860 --> 00:14:42,670
yes no no it doesn't so you could do a

00:14:41,290 --> 00:14:44,970
chunk size like this and that's

00:14:42,670 --> 00:14:46,750
basically what it was chunk list

00:14:44,970 --> 00:14:48,190
chunking function which doesn't exist

00:14:46,750 --> 00:14:50,860
you have to go on right one which is

00:14:48,190 --> 00:14:53,230
kind of frustrating but yeah for in

00:14:50,860 --> 00:14:54,730
enumerate create a process which is

00:14:53,230 --> 00:14:56,500
multiprocessing run on a separate

00:14:54,730 --> 00:14:59,410
process so it ends up on a different cpu

00:14:56,500 --> 00:15:00,700
and run them and then there's some other

00:14:59,410 --> 00:15:03,010
mechanics that you need to do at the end

00:15:00,700 --> 00:15:05,470
to join it all together but that's the

00:15:03,010 --> 00:15:07,300
theory what actually happens is that cpu

00:15:05,470 --> 00:15:09,580
0 does this kind of work so in that case

00:15:07,300 --> 00:15:11,170
the first set of processing of tesseract

00:15:09,580 --> 00:15:13,240
takes that long and then the second one

00:15:11,170 --> 00:15:15,040
takes this long and then that one and so

00:15:13,240 --> 00:15:18,640
forth so the total run time is that much

00:15:15,040 --> 00:15:20,050
and then CPU one does that so it spends

00:15:18,640 --> 00:15:21,790
a whole bunch of time not doing anything

00:15:20,050 --> 00:15:24,220
because it has no work to do and that's

00:15:21,790 --> 00:15:26,200
not very efficient and then CPU too does

00:15:24,220 --> 00:15:28,480
the same thing and cpu three does that

00:15:26,200 --> 00:15:30,250
it's no big deal if it's only a very

00:15:28,480 --> 00:15:32,350
short run time but if we're talking

00:15:30,250 --> 00:15:33,320
about 30 minutes worth of analysis

00:15:32,350 --> 00:15:35,330
that's kind of

00:15:33,320 --> 00:15:37,070
lame because you end up doing the last

00:15:35,330 --> 00:15:38,660
CPU ends up running for like two minutes

00:15:37,070 --> 00:15:40,430
because it's got all of this extra work

00:15:38,660 --> 00:15:43,880
that the everyone else is finished and

00:15:40,430 --> 00:15:47,180
sitting around waiting and who's seen

00:15:43,880 --> 00:15:49,070
that lovely anime animated GF where CPU

00:15:47,180 --> 00:15:50,570
0 is doing amazing breakbeat and

00:15:49,070 --> 00:15:54,470
breakdancing stuff while all the other

00:15:50,570 --> 00:15:56,000
cpus sit around going i should have

00:15:54,470 --> 00:15:57,620
found it for this talk minute mud it's

00:15:56,000 --> 00:15:59,840
very cool we should love it so what we

00:15:57,620 --> 00:16:01,640
do instead is we use worker pools this

00:15:59,840 --> 00:16:04,100
is much more efficient as it turns out

00:16:01,640 --> 00:16:06,290
so what you do is you say you earn it a

00:16:04,100 --> 00:16:07,580
pool of workers and you say well I'm

00:16:06,290 --> 00:16:09,080
going to have a pool of about eight

00:16:07,580 --> 00:16:10,700
workers because I expect that the

00:16:09,080 --> 00:16:13,610
maximum number I'll need is eight that's

00:16:10,700 --> 00:16:16,730
how many CPUs I have and you put them

00:16:13,610 --> 00:16:19,940
into a portal using multiprocessing fun

00:16:16,730 --> 00:16:22,280
fact when you in it worker you have to

00:16:19,940 --> 00:16:24,830
put a signal inside the worker to say I

00:16:22,280 --> 00:16:26,480
need to convey hit ctrl-c stopped

00:16:24,830 --> 00:16:28,340
because otherwise it would keep running

00:16:26,480 --> 00:16:30,110
and do stuff forever and that's bad

00:16:28,340 --> 00:16:31,910
because you'll realize after you've hit

00:16:30,110 --> 00:16:34,640
enter that it's actually that parameters

00:16:31,910 --> 00:16:36,980
wrong are dead now I have to wait 30

00:16:34,640 --> 00:16:38,360
minutes for it to finish all control Z

00:16:36,980 --> 00:16:41,660
and kill stuff and that's evil we

00:16:38,360 --> 00:16:44,030
shouldn't do that also fun fact could

00:16:41,660 --> 00:16:45,620
stack overflow is great I wouldn't be

00:16:44,030 --> 00:16:48,380
anywhere near the programmer I am

00:16:45,620 --> 00:16:50,740
without stack overflow how many other

00:16:48,380 --> 00:16:54,710
people are cut and paste programmers

00:16:50,740 --> 00:16:56,210
yeah it's way easy you have to do a

00:16:54,710 --> 00:16:57,920
weight all you have to do a get

00:16:56,210 --> 00:17:01,790
otherwise it won't let you control C

00:16:57,920 --> 00:17:04,610
because reasons so the way we use it is

00:17:01,790 --> 00:17:06,380
in our pool we apply a sink which is

00:17:04,610 --> 00:17:08,300
find a match which is the function that

00:17:06,380 --> 00:17:11,120
we define to say right go and find out

00:17:08,300 --> 00:17:12,680
with that levenshtein distance for X in

00:17:11,120 --> 00:17:14,060
void lines for all of the votes go and

00:17:12,680 --> 00:17:16,699
analyze that by trying to find a match

00:17:14,060 --> 00:17:18,920
and do it with a pool so what that does

00:17:16,699 --> 00:17:20,270
is it says I have work and I will

00:17:18,920 --> 00:17:22,820
allocate the next piece of work to

00:17:20,270 --> 00:17:24,800
whoever is it free so that way your

00:17:22,820 --> 00:17:26,000
workers are when they're not busy they

00:17:24,800 --> 00:17:27,650
sit there waiting for another piece of

00:17:26,000 --> 00:17:29,990
work if there's work to do they get

00:17:27,650 --> 00:17:31,370
given a task and then when everyone is

00:17:29,990 --> 00:17:33,770
idle means that there's no more work to

00:17:31,370 --> 00:17:35,660
do so you get nice easy performance and

00:17:33,770 --> 00:17:39,230
everyone stops working when all the work

00:17:35,660 --> 00:17:40,940
is done nice and easy then we do the

00:17:39,230 --> 00:17:43,430
last bit which is spreadsheets and

00:17:40,940 --> 00:17:45,200
graphs and statistics and it's loads of

00:17:43,430 --> 00:17:47,090
fun it's going this is the this is the

00:17:45,200 --> 00:17:49,010
cool piece so that's what happens

00:17:47,090 --> 00:17:50,179
we have the song and then we have this

00:17:49,010 --> 00:17:52,909
is the official rank that's what

00:17:50,179 --> 00:17:56,299
actually happened in when was this our

00:17:52,909 --> 00:17:59,450
2013 nothing last year the most the

00:17:56,299 --> 00:18:03,860
latest one there we go 2014-15 well year

00:17:59,450 --> 00:18:06,590
is it 25 it was the 2015 results which

00:18:03,860 --> 00:18:10,309
happens in 2016 because yay calendars

00:18:06,590 --> 00:18:11,419
and so that's what actually happened and

00:18:10,309 --> 00:18:13,549
then there's a couple of different

00:18:11,419 --> 00:18:15,590
models which is basically we change the

00:18:13,549 --> 00:18:18,350
levenshtein distance in okay how close a

00:18:15,590 --> 00:18:20,510
match do we think it should be and some

00:18:18,350 --> 00:18:23,120
other things around groupings and do we

00:18:20,510 --> 00:18:25,580
consider every single vote being a vote

00:18:23,120 --> 00:18:28,010
or do we have to have someone has voted

00:18:25,580 --> 00:18:30,080
for 10 songs these a vote and they give

00:18:28,010 --> 00:18:32,029
you slightly different answers and this

00:18:30,080 --> 00:18:34,220
tells us how wrong were we because all

00:18:32,029 --> 00:18:36,649
models are wrong but some are useful and

00:18:34,220 --> 00:18:39,230
that tells us okay that's roughly how

00:18:36,649 --> 00:18:41,419
wrong we were the average arrow is 98

00:18:39,230 --> 00:18:42,740
that's not so great the average error

00:18:41,419 --> 00:18:45,200
and the other one was much better all

00:18:42,740 --> 00:18:46,789
right better model and then you can draw

00:18:45,200 --> 00:18:49,090
a picture which shows you how wrong you

00:18:46,789 --> 00:18:52,340
are based on how far away you are from 0

00:18:49,090 --> 00:18:55,640
or 1 so number one ranked it's very

00:18:52,340 --> 00:18:59,059
small error this one here this is

00:18:55,640 --> 00:19:01,760
fascinating account of ever exactly

00:18:59,059 --> 00:19:03,919
which song it was it might have been

00:19:01,760 --> 00:19:06,320
Drake hotline bling or something it was

00:19:03,919 --> 00:19:08,630
what one of them was a bit strange there

00:19:06,320 --> 00:19:09,559
was a song here that the model said like

00:19:08,630 --> 00:19:11,809
we should be getting more and more

00:19:09,559 --> 00:19:16,669
accurate that's really really inaccurate

00:19:11,809 --> 00:19:20,179
for this far down in the count that's a

00:19:16,669 --> 00:19:23,390
bit sus who remembers when Taytay was

00:19:20,179 --> 00:19:25,820
not allowed in the hottest 100 I do yeah

00:19:23,390 --> 00:19:27,110
that was bad this is weird because that

00:19:25,820 --> 00:19:28,760
shouldn't have happened according to the

00:19:27,110 --> 00:19:30,919
model that tells us that there's a song

00:19:28,760 --> 00:19:32,779
in there that triple j says this was

00:19:30,919 --> 00:19:34,970
super popular and the model says in our

00:19:32,779 --> 00:19:36,529
no one was voting for that why is it so

00:19:34,970 --> 00:19:38,120
high so there's either something wrong

00:19:36,529 --> 00:19:39,529
with the model and the data collection

00:19:38,120 --> 00:19:41,710
which is bias and that could be

00:19:39,529 --> 00:19:44,899
happening or there could be shenanigans

00:19:41,710 --> 00:19:46,250
we don't know because triple j never

00:19:44,899 --> 00:19:49,419
tells you anything and it's not audited

00:19:46,250 --> 00:19:49,419
it's not a real competition

00:19:49,649 --> 00:19:54,789
it's all fun it's just fun um no one

00:19:53,289 --> 00:19:56,139
would take this seriously or you know it

00:19:54,789 --> 00:19:59,190
wouldn't affect anyone's ability to earn

00:19:56,139 --> 00:20:02,649
money or anything would it Oh hold on um

00:19:59,190 --> 00:20:04,809
yeah fun fact the very first time this

00:20:02,649 --> 00:20:07,179
was done but when the woman's 100 came

00:20:04,809 --> 00:20:10,830
out it was just after voting closed yes

00:20:07,179 --> 00:20:13,299
but it was before betting had closed it

00:20:10,830 --> 00:20:16,239
took sports back three or four hours to

00:20:13,299 --> 00:20:21,279
figure out that this had got out this is

00:20:16,239 --> 00:20:23,259
for next year so if you win flume to win

00:20:21,279 --> 00:20:24,999
there you go so you can bet you can make

00:20:23,259 --> 00:20:26,820
four hundred percent on your money if

00:20:24,999 --> 00:20:29,470
you're right we don't have any data yet

00:20:26,820 --> 00:20:31,229
but this shows you what you can do with

00:20:29,470 --> 00:20:33,279
social media and a few Python scripts

00:20:31,229 --> 00:20:35,399
and that's pretty much all i had to talk

00:20:33,279 --> 00:20:35,399
about

00:20:42,500 --> 00:20:46,760
thanks very much are there questions

00:20:47,000 --> 00:20:52,190
I've got a question okay did you

00:20:49,590 --> 00:20:54,570
consider looking at the betting odds and

00:20:52,190 --> 00:20:55,830
incorporating that into your predictions

00:20:54,570 --> 00:20:58,230
that would have been a different

00:20:55,830 --> 00:21:00,300
prediction model so that's a different

00:20:58,230 --> 00:21:03,120
kind of things that's what people do

00:21:00,300 --> 00:21:04,830
like 538 does that which is X kind of a

00:21:03,120 --> 00:21:06,720
metamodel yes so you're basing it on

00:21:04,830 --> 00:21:09,180
other people's things that would be an

00:21:06,720 --> 00:21:11,460
interesting exercise to do but it's

00:21:09,180 --> 00:21:14,160
we're trying to do direct sampling of

00:21:11,460 --> 00:21:16,500
the population rather than what a

00:21:14,160 --> 00:21:18,300
bedding is what other people think is

00:21:16,500 --> 00:21:20,310
going to win it's usually good if you

00:21:18,300 --> 00:21:23,010
have a pretty good thing but when it's

00:21:20,310 --> 00:21:29,970
wrong it's really wrong as we found out

00:21:23,010 --> 00:21:33,000
from the last election yeah thank you

00:21:29,970 --> 00:21:35,540
are you were you aware of the diff lib

00:21:33,000 --> 00:21:39,930
stuff and if so how that compared to the

00:21:35,540 --> 00:21:42,060
lavash teen distance I think so I from

00:21:39,930 --> 00:21:44,400
memory i did look at it but there was

00:21:42,060 --> 00:21:47,280
some reasons why it looked a bit more

00:21:44,400 --> 00:21:48,660
complex and parley it was just I didn't

00:21:47,280 --> 00:21:51,240
really understand it in enough detail

00:21:48,660 --> 00:21:53,040
and honestly last year was in real hurry

00:21:51,240 --> 00:21:54,990
and did this in about a week Chris

00:21:53,040 --> 00:21:56,310
helped me out quite a bit doing some

00:21:54,990 --> 00:21:58,980
checking of what we've done around the

00:21:56,310 --> 00:22:00,900
models and Chris actually did some way

00:21:58,980 --> 00:22:03,210
more complicated multi-cat Monte Carlo

00:22:00,900 --> 00:22:05,790
analysis which is very cool but beyond

00:22:03,210 --> 00:22:06,840
what I understand so don't you hear

00:22:05,790 --> 00:22:08,160
about that sort of stingers would be

00:22:06,840 --> 00:22:11,670
good I think I just don't you

00:22:08,160 --> 00:22:12,750
interviewed one I will have to check it

00:22:11,670 --> 00:22:17,370
out for next time though so thank you

00:22:12,750 --> 00:22:19,290
for reminding me was it just Twitter

00:22:17,370 --> 00:22:21,510
that you scraped for the data or were

00:22:19,290 --> 00:22:24,000
there other sources as well the first

00:22:21,510 --> 00:22:27,030
year was just Twitter the second year

00:22:24,000 --> 00:22:29,550
I've it was gel second and since then

00:22:27,030 --> 00:22:32,250
has just been Instagram I did have a

00:22:29,550 --> 00:22:34,170
quick look at facebook but again I ran

00:22:32,250 --> 00:22:36,810
out of time to actually figure out how

00:22:34,170 --> 00:22:38,100
to do the the interface and then make it

00:22:36,810 --> 00:22:40,410
in the same sort of format that it would

00:22:38,100 --> 00:22:42,090
fit the toolchain having more diverse

00:22:40,410 --> 00:22:43,920
sources of input and having a bigger

00:22:42,090 --> 00:22:47,880
sample set absolutely would should

00:22:43,920 --> 00:22:49,140
improve the results yeah snapchats

00:22:47,880 --> 00:22:50,670
probably not a bad place to go and get

00:22:49,140 --> 00:22:51,930
it although you know it you can't

00:22:50,670 --> 00:22:54,250
actually see them after they've gone

00:22:51,930 --> 00:22:57,850
because they've all been deleted

00:22:54,250 --> 00:23:01,840
your dad okay thanks very much for an

00:22:57,850 --> 00:23:06,280
excellent talk and like to present you

00:23:01,840 --> 00:23:08,640
with a Python mark so I can I just thank

00:23:06,280 --> 00:23:11,640
Chris once about Sophie's foreign

00:23:08,640 --> 00:23:11,640

YouTube URL: https://www.youtube.com/watch?v=qjTc5q7MsMg


