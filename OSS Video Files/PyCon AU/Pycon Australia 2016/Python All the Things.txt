Title: Python All the Things
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Russell Keith-Magee
https://2016.pycon-au.org/schedule/198/view_talk
We’re familiar with Python as a scripting language, as a web server language, as a teaching language, as a data analysis language, and as a teaching language. But is that the limit of where Python can be used? What is the future for Python on other platforms? Is the prospect of using Python on those platforms a novelty, or a viable way to fend off an existential threat to the language? And how does this threat intersect with other threats we have to our community, and to our industry?
Captions: 
	00:00:00,079 --> 00:00:06,299
so you might remember I showed you this

00:00:03,629 --> 00:00:08,639
yesterday but there was another thing

00:00:06,299 --> 00:00:10,710
missing from it which yesterday we

00:00:08,639 --> 00:00:12,360
talked about micro Python today we're

00:00:10,710 --> 00:00:17,369
going to talk about this stranger

00:00:12,360 --> 00:00:22,289
mission so this leads me to our morning

00:00:17,369 --> 00:00:25,109
talk about from Russell Keith McGee Russ

00:00:22,289 --> 00:00:27,269
is I think well on his way to cementing

00:00:25,109 --> 00:00:29,720
his place as one of the Python

00:00:27,269 --> 00:00:34,170
community's future elder statesmen

00:00:29,720 --> 00:00:36,590
sitting sitting in his comfy chair off

00:00:34,170 --> 00:00:39,000
to the side with a glass of whiskey

00:00:36,590 --> 00:00:42,140
muttering the occasional pearl of wisdom

00:00:39,000 --> 00:00:44,520
or something about the kids these days

00:00:42,140 --> 00:00:46,530
he's clearly not there yet though he's

00:00:44,520 --> 00:00:48,480
very active and he's a core member of

00:00:46,530 --> 00:00:51,300
the django community and he's got his

00:00:48,480 --> 00:00:53,309
own projects as well inside he's had a

00:00:51,300 --> 00:00:56,969
decade of contributions to the django

00:00:53,309 --> 00:00:58,410
core team and he's also been the past

00:00:56,969 --> 00:01:01,070
prisoner of the Django Software

00:00:58,410 --> 00:01:04,680
Foundation for I think it was five years

00:01:01,070 --> 00:01:07,619
and is the organizer of Django Caan a

00:01:04,680 --> 00:01:09,570
you so he's a busy guy he's here today

00:01:07,619 --> 00:01:12,450
to talk about pythons future on

00:01:09,570 --> 00:01:14,820
platforms other than webs and desktops

00:01:12,450 --> 00:01:17,040
and servers and what that could mean for

00:01:14,820 --> 00:01:20,810
Python and for the Python community

00:01:17,040 --> 00:01:20,810
so please welcome Russ to the stage

00:01:28,580 --> 00:01:32,180
I actually I checked with Richard

00:01:30,290 --> 00:01:34,340
yesterday after Damien George's talk

00:01:32,180 --> 00:01:36,290
apparently this wasn't intentional but

00:01:34,340 --> 00:01:39,770
there is an interesting synergy with

00:01:36,290 --> 00:01:41,240
yesterday's talk I'm also an expat of a

00:01:39,770 --> 00:01:42,590
physic physics department my

00:01:41,240 --> 00:01:45,380
undergraduate degree is also in physics

00:01:42,590 --> 00:01:47,510
just like Damien however unlike Damien I

00:01:45,380 --> 00:01:48,950
then formally migrated over to the

00:01:47,510 --> 00:01:52,190
computer science department where I got

00:01:48,950 --> 00:01:54,650
my PhD so while as a physicist I also

00:01:52,190 --> 00:01:56,720
write extremely bad hockey code as a

00:01:54,650 --> 00:02:01,520
computer scientist I've been formally

00:01:56,720 --> 00:02:03,380
trained know that it's bad code but it's

00:02:01,520 --> 00:02:07,940
a PhD so it's purely theoretical

00:02:03,380 --> 00:02:10,700
knowledge so yes for those who haven't

00:02:07,940 --> 00:02:12,290
met me before hi I'm Russell I've been a

00:02:10,700 --> 00:02:14,450
member of the Django core team for

00:02:12,290 --> 00:02:15,560
almost 11 years now and I was a

00:02:14,450 --> 00:02:18,430
president of the Django Software

00:02:15,560 --> 00:02:21,290
Foundation from 2010 to team to 2015

00:02:18,430 --> 00:02:23,480
Django is a big part of the broader

00:02:21,290 --> 00:02:26,270
Python ecosystem but it is by no means

00:02:23,480 --> 00:02:28,040
the only part there are other web

00:02:26,270 --> 00:02:30,530
frameworks there are great tools for

00:02:28,040 --> 00:02:32,209
data analysis there are projects for

00:02:30,530 --> 00:02:34,459
using Python in education and on

00:02:32,209 --> 00:02:36,860
embedded devices none of this has

00:02:34,459 --> 00:02:40,100
happened overnight Python as a language

00:02:36,860 --> 00:02:42,620
is 25 years old it took maybe ten years

00:02:40,100 --> 00:02:44,780
for Python to gain significant traction

00:02:42,620 --> 00:02:46,820
in our industry and another ten before

00:02:44,780 --> 00:02:50,630
it really started to gather a widespread

00:02:46,820 --> 00:02:52,760
support what we see today as the Python

00:02:50,630 --> 00:02:56,420
community is the result of thousands of

00:02:52,760 --> 00:02:57,980
hours of mostly volunteered effort but

00:02:56,420 --> 00:02:59,870
despite all this effort Python has

00:02:57,980 --> 00:03:01,519
really only been available on server and

00:02:59,870 --> 00:03:03,260
desktop platforms devices that fit a

00:03:01,519 --> 00:03:06,380
very traditional concept of what a

00:03:03,260 --> 00:03:08,239
computer is but over the last ten years

00:03:06,380 --> 00:03:10,580
we've seen the emergence of a whole new

00:03:08,239 --> 00:03:12,470
class of devices much smaller and

00:03:10,580 --> 00:03:17,570
usually portable things like phones

00:03:12,470 --> 00:03:19,400
tablets watches set-top boxes my reading

00:03:17,570 --> 00:03:20,930
of the tea leaves is what has led me to

00:03:19,400 --> 00:03:22,280
change the focus of my open source

00:03:20,930 --> 00:03:24,410
contributions over the last couple of

00:03:22,280 --> 00:03:26,360
years these days I'm spending most of my

00:03:24,410 --> 00:03:28,280
time not on Django I do still involve

00:03:26,360 --> 00:03:30,110
myself with Django but I've spent a lot

00:03:28,280 --> 00:03:31,160
more time on the be ware project for

00:03:30,110 --> 00:03:33,680
those who haven't come across it before

00:03:31,160 --> 00:03:36,110
beware is an open source collection of

00:03:33,680 --> 00:03:38,209
tools and libraries for creating native

00:03:36,110 --> 00:03:40,970
user interfaces in Python for desktop

00:03:38,209 --> 00:03:42,020
but also for iOS for Android single page

00:03:40,970 --> 00:03:45,020
web apps and

00:03:42,020 --> 00:03:46,400
other new hardware platforms now as

00:03:45,020 --> 00:03:48,350
Richard pointed out yesterday

00:03:46,400 --> 00:03:49,520
Guiteau drew attention to micro Python

00:03:48,350 --> 00:03:51,170
and the fact that you can run Python on

00:03:49,520 --> 00:03:53,330
embedded devices and Damien talked about

00:03:51,170 --> 00:03:54,800
this yesterday but what gido didn't

00:03:53,330 --> 00:03:56,480
point out is that we can also fill the

00:03:54,800 --> 00:03:58,670
other box too for mobile devices and

00:03:56,480 --> 00:04:00,410
that's what beware is all about you'll

00:03:58,670 --> 00:04:03,070
also notice that this makes python the

00:04:00,410 --> 00:04:05,330
first language to tick all four boxes

00:04:03,070 --> 00:04:10,910
which means that it is entirely possible

00:04:05,330 --> 00:04:13,430
to Python all the things if it isn't

00:04:10,910 --> 00:04:14,750
already clear I like Python I think it's

00:04:13,430 --> 00:04:16,610
an elegant it's gonna make elegant

00:04:14,750 --> 00:04:18,530
expressive most importantly readable

00:04:16,610 --> 00:04:20,420
language it's I've got a great standard

00:04:18,530 --> 00:04:22,460
library and a really rich ecosystem of

00:04:20,420 --> 00:04:24,140
tools around the outside of that I love

00:04:22,460 --> 00:04:26,150
the minimalist syntax and a significant

00:04:24,140 --> 00:04:27,890
whitespace to me that's just enforcing

00:04:26,150 --> 00:04:30,080
at a language level code starred guy

00:04:27,890 --> 00:04:32,660
lock code style guidelines that are just

00:04:30,080 --> 00:04:33,950
good engineering practice I'm not for a

00:04:32,660 --> 00:04:36,110
second going to claim that Python is

00:04:33,950 --> 00:04:37,610
perfect it's not but it's as close to

00:04:36,110 --> 00:04:39,140
perfect as I've ever come across and I'm

00:04:37,610 --> 00:04:42,320
very happy living my life as a Python

00:04:39,140 --> 00:04:44,390
Easter and because of that I want to be

00:04:42,320 --> 00:04:46,640
out of run Python on all my devices not

00:04:44,390 --> 00:04:48,950
just some token notion of running Python

00:04:46,640 --> 00:04:51,440
either I want to be able to use Python

00:04:48,950 --> 00:04:52,850
to deliver a full developer experience I

00:04:51,440 --> 00:04:55,340
want to be able to develop and deliver

00:04:52,850 --> 00:04:57,380
applications for these platforms not in

00:04:55,340 --> 00:04:59,450
some Python sandbox but as a fully

00:04:57,380 --> 00:05:02,630
fledged first-class citizen of their

00:04:59,450 --> 00:05:04,520
device ecosystems now if you're here

00:05:02,630 --> 00:05:05,990
today at PyCon I probably don't have to

00:05:04,520 --> 00:05:08,270
convince you of the benefits of Python

00:05:05,990 --> 00:05:10,310
as a language what I might need to

00:05:08,270 --> 00:05:12,830
convince you of is that it is indeed

00:05:10,310 --> 00:05:14,900
plausible or even desirable to run

00:05:12,830 --> 00:05:17,150
Python on non-traditional devices and

00:05:14,900 --> 00:05:19,430
assuming that it is possible that it's

00:05:17,150 --> 00:05:20,420
even worth the effort to try and that's

00:05:19,430 --> 00:05:23,120
what I'm going to talk about today the

00:05:20,420 --> 00:05:26,210
how and the why of Pi sending all the

00:05:23,120 --> 00:05:28,190
things okay so first off let's do with

00:05:26,210 --> 00:05:29,510
how there's absolutely no point in

00:05:28,190 --> 00:05:30,500
getting all philosophical about why you

00:05:29,510 --> 00:05:32,900
should do something if you can't

00:05:30,500 --> 00:05:35,600
actually do it so let's play a game

00:05:32,900 --> 00:05:36,919
you have been given some brand new fancy

00:05:35,600 --> 00:05:39,169
hardware device it's been dropped into

00:05:36,919 --> 00:05:42,140
your lap what options do you have for

00:05:39,169 --> 00:05:43,340
getting Python to run on it well to

00:05:42,140 --> 00:05:44,990
answer that question you actually need

00:05:43,340 --> 00:05:46,910
to start a little bit higher up and ask

00:05:44,990 --> 00:05:50,390
a slightly different question you have

00:05:46,910 --> 00:05:52,940
to start with what what is Python well

00:05:50,390 --> 00:05:54,660
it's a programming language right except

00:05:52,940 --> 00:05:57,120
that it isn't

00:05:54,660 --> 00:05:59,880
depending upon who's talking python

00:05:57,120 --> 00:06:02,340
could be one of two things Python the

00:05:59,880 --> 00:06:04,470
language is an abstract thing it's a

00:06:02,340 --> 00:06:06,360
specification of syntax and semantics

00:06:04,470 --> 00:06:07,770
that describes how a particular sequence

00:06:06,360 --> 00:06:09,150
of human readable bytes will be

00:06:07,770 --> 00:06:10,760
interpreted to make a computer do

00:06:09,150 --> 00:06:13,230
something interesting

00:06:10,760 --> 00:06:14,940
then there's the Python interpreter that

00:06:13,230 --> 00:06:16,590
you actually install and run when you

00:06:14,940 --> 00:06:18,180
tell someone to go to the Python web

00:06:16,590 --> 00:06:19,920
site and download the Installer you're

00:06:18,180 --> 00:06:23,160
not strictly talking about Python you're

00:06:19,920 --> 00:06:25,260
probably talking about C Python which is

00:06:23,160 --> 00:06:27,990
the de-facto reference implementation of

00:06:25,260 --> 00:06:30,210
the Python language standard this

00:06:27,990 --> 00:06:32,400
separation between implementation and

00:06:30,210 --> 00:06:34,770
specification is valuable because it

00:06:32,400 --> 00:06:36,900
means that C Python isn't the only way

00:06:34,770 --> 00:06:38,610
that Python can be interpreted there are

00:06:36,900 --> 00:06:41,100
features of Python that are experienced

00:06:38,610 --> 00:06:44,160
by end users that are features of C

00:06:41,100 --> 00:06:45,750
Python not the language itself the Gil

00:06:44,160 --> 00:06:48,900
for example the global interpreter lock

00:06:45,750 --> 00:06:50,820
the perpetual bane of of Python

00:06:48,900 --> 00:06:53,550
performers discussions is not an

00:06:50,820 --> 00:06:56,100
inherent feature of Python it's a

00:06:53,550 --> 00:06:57,660
feature of C Python a specific reference

00:06:56,100 --> 00:07:00,330
implementation of the Python language

00:06:57,660 --> 00:07:02,880
specification C Python because of the

00:07:00,330 --> 00:07:04,620
way it's implemented has a Gil other

00:07:02,880 --> 00:07:06,510
implementations of Python of the Python

00:07:04,620 --> 00:07:09,480
language specification Jason pipe is

00:07:06,510 --> 00:07:11,370
tacklers don't have a Gil this

00:07:09,480 --> 00:07:12,930
separation means that when we're talking

00:07:11,370 --> 00:07:14,760
about getting Python running on fancy

00:07:12,930 --> 00:07:16,200
new hardware devices there are a couple

00:07:14,760 --> 00:07:17,820
of different approaches depending upon

00:07:16,200 --> 00:07:21,090
the capabilities of the device that

00:07:17,820 --> 00:07:23,730
you're targeting the easiest approach of

00:07:21,090 --> 00:07:25,410
course is just UC PI thing when you

00:07:23,730 --> 00:07:27,420
start a Python shell or you run a Python

00:07:25,410 --> 00:07:28,950
script on your laptop or on your server

00:07:27,420 --> 00:07:31,890
chances are this is what you're doing

00:07:28,950 --> 00:07:33,990
you're running C Python effectively the

00:07:31,890 --> 00:07:37,020
reference implementation of the Python

00:07:33,990 --> 00:07:38,430
language standard written in C and one

00:07:37,020 --> 00:07:40,380
of the side effects of being written in

00:07:38,430 --> 00:07:44,520
C is that it's really easy to port to

00:07:40,380 --> 00:07:45,960
new platforms in this regard C Python

00:07:44,520 --> 00:07:48,270
follows the tradition that's laid down

00:07:45,960 --> 00:07:50,670
by Unix one of the major reasons for the

00:07:48,270 --> 00:07:52,290
proliferation of Unix as an operating

00:07:50,670 --> 00:07:54,270
system is that in the early days of

00:07:52,290 --> 00:07:56,940
computing dozens of manufacturers were

00:07:54,270 --> 00:07:58,470
producing computers IBM Dec univac NCR

00:07:56,940 --> 00:08:01,320
Honeywell General Electric Siemens

00:07:58,470 --> 00:08:03,330
Fujitsu Hitachi NEC and technology was

00:08:01,320 --> 00:08:05,100
advancing so quickly that there would be

00:08:03,330 --> 00:08:06,930
major shifts in architecture between

00:08:05,100 --> 00:08:08,420
versions of a device even between the

00:08:06,930 --> 00:08:10,640
same manufacturer

00:08:08,420 --> 00:08:12,200
then Ken Thompson Dennis Ritchie Brian

00:08:10,640 --> 00:08:13,850
Kernighan and a bunch of other people

00:08:12,200 --> 00:08:16,160
working at Bell Labs work something out

00:08:13,850 --> 00:08:17,710
if you could define a minimal kernel

00:08:16,160 --> 00:08:20,240
that could be ported to any machine

00:08:17,710 --> 00:08:22,010
providing a common API for basic

00:08:20,240 --> 00:08:24,770
operations like memory management

00:08:22,010 --> 00:08:27,500
process invocation IO then you could use

00:08:24,770 --> 00:08:29,960
that kernel to bootstrap the rest of an

00:08:27,500 --> 00:08:32,510
operating system they then developed an

00:08:29,960 --> 00:08:34,550
entire programming language C to make

00:08:32,510 --> 00:08:36,560
this even easier the original versions

00:08:34,550 --> 00:08:39,110
of C were developed to make it easy to

00:08:36,560 --> 00:08:40,850
port UNIX to other platforms the kernel

00:08:39,110 --> 00:08:42,380
the very very base of the kernel was

00:08:40,850 --> 00:08:44,090
written in assembly language for a

00:08:42,380 --> 00:08:45,950
specific machine and a specific

00:08:44,090 --> 00:08:48,230
architecture and that got even smaller

00:08:45,950 --> 00:08:49,850
and smaller as the operating parts of

00:08:48,230 --> 00:08:51,740
the operating system could be written in

00:08:49,850 --> 00:08:54,800
C and therefore easily ported to a new

00:08:51,740 --> 00:08:56,210
kernel and that's essentially what C

00:08:54,800 --> 00:08:57,710
Python looks like when you want to

00:08:56,210 --> 00:08:59,660
Porter it's just at a slightly higher

00:08:57,710 --> 00:09:02,030
level of abstraction it assumes the

00:08:59,660 --> 00:09:03,530
existence of a C compiler but as long as

00:09:02,030 --> 00:09:05,060
you've got a C compiler which is a

00:09:03,530 --> 00:09:08,150
pretty safe assumption for a lot of

00:09:05,060 --> 00:09:10,010
platforms the C Python core can be

00:09:08,150 --> 00:09:12,260
compiled and give you a Python

00:09:10,010 --> 00:09:14,060
interpreter you can run and a Lib Python

00:09:12,260 --> 00:09:17,360
that can be embedded into any process

00:09:14,060 --> 00:09:19,790
that runs on that machine and that is a

00:09:17,360 --> 00:09:21,260
basic threshold that most modern devices

00:09:19,790 --> 00:09:23,570
can support if you look in the Lib

00:09:21,260 --> 00:09:25,250
directory of the Python 2.7 source tree

00:09:23,570 --> 00:09:27,170
this is what you'll find a list of all

00:09:25,250 --> 00:09:30,170
the platforms that have explicit support

00:09:27,170 --> 00:09:31,610
in the Python source tree pison story

00:09:30,170 --> 00:09:34,100
has pruned a lot of these out

00:09:31,610 --> 00:09:37,010
os/2 emx for example any-any always to

00:09:34,100 --> 00:09:40,970
veterans here represents there we go

00:09:37,010 --> 00:09:42,650
what about B Oz any B Box owners yeah B

00:09:40,970 --> 00:09:44,180
Box owner here there we go all right

00:09:42,650 --> 00:09:47,510
unfortunately they're no longer

00:09:44,180 --> 00:09:49,460
supported but hopefully the point is

00:09:47,510 --> 00:09:50,900
clear as long as you can compile the

00:09:49,460 --> 00:09:53,210
kernel the core C Python implementation

00:09:50,900 --> 00:09:55,580
you get the rest of the Python standard

00:09:53,210 --> 00:09:59,300
library and the Python ecosystem for

00:09:55,580 --> 00:10:01,370
free but even this compilation process

00:09:59,300 --> 00:10:03,230
gives you some options if you're using a

00:10:01,370 --> 00:10:05,060
compiled language like C the usual

00:10:03,230 --> 00:10:06,470
approach is to write some code and use

00:10:05,060 --> 00:10:08,600
the compiler on the same machine that

00:10:06,470 --> 00:10:10,280
you intend to run that code if you're on

00:10:08,600 --> 00:10:11,810
a desktop or a server machine that works

00:10:10,280 --> 00:10:13,610
great because you almost certainly have

00:10:11,810 --> 00:10:16,880
a C compiler after all you had to have

00:10:13,610 --> 00:10:18,740
one to port UNIX but on some devices

00:10:16,880 --> 00:10:21,140
this isn't portable either because a

00:10:18,740 --> 00:10:22,100
compiler hasn't been ported to that

00:10:21,140 --> 00:10:24,589
platform or B

00:10:22,100 --> 00:10:27,139
compilation on device just isn't

00:10:24,589 --> 00:10:30,100
feasible consider do you really want to

00:10:27,139 --> 00:10:32,810
be running a compiler on your watch

00:10:30,100 --> 00:10:34,759
compilation is a CPU intensive process

00:10:32,810 --> 00:10:36,829
do you really want your watch to turn

00:10:34,759 --> 00:10:38,329
into a molten ball of slag burnin hole

00:10:36,829 --> 00:10:41,930
into the center of the earth while it's

00:10:38,329 --> 00:10:44,420
attached to your wrist I don't think so

00:10:41,930 --> 00:10:46,819
so you really do need to have a way to

00:10:44,420 --> 00:10:48,649
compile somewhere else and get the

00:10:46,819 --> 00:10:51,620
compiled product onto your watch

00:10:48,649 --> 00:10:53,329
and that's what cross compilation is a

00:10:51,620 --> 00:10:55,130
compiler remember the end of the day is

00:10:53,329 --> 00:10:56,810
just a magic box that takes human

00:10:55,130 --> 00:10:58,730
readable input and makes machine

00:10:56,810 --> 00:11:00,290
readable output but there's nothing that

00:10:58,730 --> 00:11:02,990
says that the machine readable output

00:11:00,290 --> 00:11:05,300
has to be read by the same machine that

00:11:02,990 --> 00:11:07,490
is doing the compilation it's just bytes

00:11:05,300 --> 00:11:09,170
at the end of the day and yeah okay it

00:11:07,490 --> 00:11:10,550
is more difficult to set up and there

00:11:09,170 --> 00:11:12,230
are plenty of opportunities for things

00:11:10,550 --> 00:11:15,259
to go wrong but these are resolvable

00:11:12,230 --> 00:11:17,449
problems and again python has this

00:11:15,259 --> 00:11:19,279
ability to cross compile built into its

00:11:17,449 --> 00:11:21,649
build system this is something you

00:11:19,279 --> 00:11:24,139
almost get for free when you use the gun

00:11:21,649 --> 00:11:27,050
ooh Otto calm toolchain I say almost

00:11:24,139 --> 00:11:29,990
because well you know Otto conf is a

00:11:27,050 --> 00:11:32,420
very special snowflake but at least in

00:11:29,990 --> 00:11:34,220
principle the gönül chain has been

00:11:32,420 --> 00:11:36,709
designed to support platform cost

00:11:34,220 --> 00:11:38,540
compilation remember this is the reason

00:11:36,709 --> 00:11:40,370
C compilers exist in the first place to

00:11:38,540 --> 00:11:44,360
make it easy to port a binary to a new

00:11:40,370 --> 00:11:46,130
machine okay so as long as you have a C

00:11:44,360 --> 00:11:47,899
compiler that runs on your new hardware

00:11:46,130 --> 00:11:50,420
device so you have a C compiler that can

00:11:47,899 --> 00:11:52,370
target that device you said you can

00:11:50,420 --> 00:11:54,139
compile the stock C Python sources and

00:11:52,370 --> 00:11:56,930
you get the same C Python that you use

00:11:54,139 --> 00:11:58,670
on a server that doesn't necessarily

00:11:56,930 --> 00:12:00,889
mean that you have the same Python

00:11:58,670 --> 00:12:03,350
experience though if you're running on a

00:12:00,889 --> 00:12:05,389
watch you can't just open a shell prompt

00:12:03,350 --> 00:12:07,519
and start typing in a new command so you

00:12:05,389 --> 00:12:09,829
have a problem how do you interact with

00:12:07,519 --> 00:12:13,189
Python when you don't have standard in

00:12:09,829 --> 00:12:15,230
and standard out are you stuck the good

00:12:13,189 --> 00:12:16,790
news is no you're not C Python is

00:12:15,230 --> 00:12:18,439
written in C and while it's certainly

00:12:16,790 --> 00:12:19,790
designed to be invoked from a command

00:12:18,439 --> 00:12:22,279
line and provide a prompt it doesn't

00:12:19,790 --> 00:12:24,259
require that the command line experience

00:12:22,279 --> 00:12:26,240
is essentially just a wrapper around a

00:12:24,259 --> 00:12:28,459
very specific set of test setup and

00:12:26,240 --> 00:12:31,040
teardown tooling the code for the Python

00:12:28,459 --> 00:12:33,260
executable itself Python exe is

00:12:31,040 --> 00:12:35,180
remarkably simple it really is just a

00:12:33,260 --> 00:12:35,720
pipeline for getting key put in keyboard

00:12:35,180 --> 00:12:37,459
input

00:12:35,720 --> 00:12:39,350
and file input and passing it to the

00:12:37,459 --> 00:12:39,740
real engine an embedded library that's

00:12:39,350 --> 00:12:41,930
called

00:12:39,740 --> 00:12:43,639
not surprisingly lead Python this

00:12:41,930 --> 00:12:45,319
library is what implements the actual

00:12:43,639 --> 00:12:48,110
let's run all the Python code part of

00:12:45,319 --> 00:12:50,899
the puzzle so as long as you can build a

00:12:48,110 --> 00:12:52,939
binary any binary that initializes and

00:12:50,899 --> 00:12:54,680
invokes some key methods in Lib Python

00:12:52,939 --> 00:12:56,389
you can have Python running on any

00:12:54,680 --> 00:12:58,459
device you want and then it's just up to

00:12:56,389 --> 00:13:00,589
the device to determine how you pipe the

00:12:58,459 --> 00:13:04,430
Python script into the Python

00:13:00,589 --> 00:13:05,870
interpreter running on that device once

00:13:04,430 --> 00:13:07,160
you've got a running interpreter you're

00:13:05,870 --> 00:13:08,509
going to want to access the system

00:13:07,160 --> 00:13:10,069
native library so you can actually

00:13:08,509 --> 00:13:12,199
interact with the capabilities of the

00:13:10,069 --> 00:13:13,879
device that you're running on now you've

00:13:12,199 --> 00:13:14,930
got this far it's because you've got

00:13:13,879 --> 00:13:16,160
this far it's because you have a C

00:13:14,930 --> 00:13:18,589
compiler which generally means you've

00:13:16,160 --> 00:13:20,389
got a C library under the hood providing

00:13:18,589 --> 00:13:21,740
those services this means you can use

00:13:20,389 --> 00:13:24,319
one of the features of the Python

00:13:21,740 --> 00:13:28,220
standard library c types to access those

00:13:24,319 --> 00:13:30,470
services c types is a library that

00:13:28,220 --> 00:13:32,300
exploits the fact that at the assembly

00:13:30,470 --> 00:13:33,740
language level the way you invoke a

00:13:32,300 --> 00:13:35,779
function what's alone is the calling

00:13:33,740 --> 00:13:38,569
convention the calling convention used

00:13:35,779 --> 00:13:39,920
by c compilers is well defined since

00:13:38,569 --> 00:13:42,709
it's well defined it means you don't

00:13:39,920 --> 00:13:44,959
actually have to use a c compiler to

00:13:42,709 --> 00:13:47,089
generate code that will be interpreted

00:13:44,959 --> 00:13:48,529
as a function call any tool that can

00:13:47,089 --> 00:13:50,089
generate a compatible sequence of

00:13:48,529 --> 00:13:53,180
assembly language commands can invoke

00:13:50,089 --> 00:13:55,579
any function in a library that claims to

00:13:53,180 --> 00:13:57,410
be c regardless of what language is

00:13:55,579 --> 00:13:59,089
doing the calling what language the

00:13:57,410 --> 00:14:01,250
library was actually written in and

00:13:59,089 --> 00:14:02,899
there's a helper library called FFI the

00:14:01,250 --> 00:14:05,089
foreign function interface that makes

00:14:02,899 --> 00:14:07,420
this easy to do and c types is then

00:14:05,089 --> 00:14:09,709
pythons built-in wrapper around FFI

00:14:07,420 --> 00:14:12,170
using c types all you have to do is

00:14:09,709 --> 00:14:13,699
reference to the c library then describe

00:14:12,170 --> 00:14:15,649
the prototype of a c method that you

00:14:13,699 --> 00:14:17,269
believe to be in that library and then

00:14:15,649 --> 00:14:18,829
you can invoke that method directly from

00:14:17,269 --> 00:14:22,370
raw python without the need to compile

00:14:18,829 --> 00:14:25,040
anything on the Python side for example

00:14:22,370 --> 00:14:27,740
we could use C types to load Lib C the

00:14:25,040 --> 00:14:29,629
standard c library on POSIX boxes the

00:14:27,740 --> 00:14:31,910
utility library and we can tell that

00:14:29,629 --> 00:14:34,610
library that there is a function called

00:14:31,910 --> 00:14:37,160
stitcher there is it takes a character

00:14:34,610 --> 00:14:39,529
pointer a C sharp E and a C character a

00:14:37,160 --> 00:14:42,019
C char and it returns a C character

00:14:39,529 --> 00:14:43,790
pointer C char P then you can invoke

00:14:42,019 --> 00:14:45,410
that method directly there's no need to

00:14:43,790 --> 00:14:46,929
compile anything you just have to open

00:14:45,410 --> 00:14:49,340
up a prompt and start running that code

00:14:46,929 --> 00:14:51,050
so whatever system

00:14:49,340 --> 00:14:53,840
libraries your platform performs you can

00:14:51,050 --> 00:14:55,310
access them from Python if you want you

00:14:53,840 --> 00:14:56,960
can then write a wrapper library to

00:14:55,310 --> 00:14:58,580
provide a nicer API and then it's just

00:14:56,960 --> 00:15:01,940
up to you to what interface you want to

00:14:58,580 --> 00:15:03,740
provide at that point you have a fully

00:15:01,940 --> 00:15:06,080
functioning Python on your new hardware

00:15:03,740 --> 00:15:10,250
device with full access to the entire

00:15:06,080 --> 00:15:12,020
system libraries now when this approach

00:15:10,250 --> 00:15:13,670
works it's pretty straightforward to get

00:15:12,020 --> 00:15:15,590
going it's the approach that makes

00:15:13,670 --> 00:15:17,060
Python available on pretty much every

00:15:15,590 --> 00:15:19,100
desktop and server machine that's ever

00:15:17,060 --> 00:15:21,200
been manufactured it's also the approach

00:15:19,100 --> 00:15:24,170
that I've used to get python working on

00:15:21,200 --> 00:15:25,700
iPhones iPads Apple TV set-top boxes and

00:15:24,170 --> 00:15:26,990
in principle Apple watches that I

00:15:25,700 --> 00:15:29,630
haven't actually had a chance to test it

00:15:26,990 --> 00:15:31,850
with an actual watch although Apple

00:15:29,630 --> 00:15:33,710
hides a lot of the details between Xcode

00:15:31,850 --> 00:15:36,020
and objective-c and more recently Swift

00:15:33,710 --> 00:15:38,900
the core of what Apple is doing on all

00:15:36,020 --> 00:15:43,280
its devices is plain old UNIX in C and

00:15:38,900 --> 00:15:46,040
so compiling C Python for iOS the TV OS

00:15:43,280 --> 00:15:48,230
for watch OS is relatively simple and

00:15:46,040 --> 00:15:50,210
you can access all the system native

00:15:48,230 --> 00:15:53,980
libraries even though iOS is advertising

00:15:50,210 --> 00:15:57,110
them as being objective-c using C types

00:15:53,980 --> 00:15:59,060
but what about what it doesn't work what

00:15:57,110 --> 00:16:00,950
happens when you don't have a C compiler

00:15:59,060 --> 00:16:04,280
or C isn't the native system language

00:16:00,950 --> 00:16:05,980
like for example on Android well then

00:16:04,280 --> 00:16:08,690
you have to take a different approach if

00:16:05,980 --> 00:16:11,420
you read the advertising copy for

00:16:08,690 --> 00:16:13,280
Android it sells itself as a Linux and

00:16:11,420 --> 00:16:15,350
then prompt row and then promotes Java

00:16:13,280 --> 00:16:18,050
as its user space programming language

00:16:15,350 --> 00:16:20,840
the catch is it's not really either of

00:16:18,050 --> 00:16:23,570
those things yes at a some level it is

00:16:20,840 --> 00:16:25,220
notionally a linux but not at any level

00:16:23,570 --> 00:16:27,590
that is actually interesting to end

00:16:25,220 --> 00:16:29,930
developers the kernel is written in C

00:16:27,590 --> 00:16:32,210
and you can use a C compiler that will

00:16:29,930 --> 00:16:34,550
target that kernel but the C level

00:16:32,210 --> 00:16:36,560
really only has access to bare level

00:16:34,550 --> 00:16:38,690
system services you can't actually do

00:16:36,560 --> 00:16:40,390
anything interesting from the android as

00:16:38,690 --> 00:16:43,370
a portable computing device perspective

00:16:40,390 --> 00:16:46,670
all of androids user space libraries are

00:16:43,370 --> 00:16:47,780
exposed using java api s-- and android

00:16:46,670 --> 00:16:50,270
isn't the only platform that does this

00:16:47,780 --> 00:16:52,310
sun now oracle has spent a lot of money

00:16:50,270 --> 00:16:54,140
developing the java ecosystem an entire

00:16:52,310 --> 00:16:55,910
ecosystem based around the java virtual

00:16:54,140 --> 00:16:58,630
machine as a runtime platform

00:16:55,910 --> 00:17:02,120
abstracting away Hardware differences

00:16:58,630 --> 00:17:03,290
both these platforms do a head feint to

00:17:02,120 --> 00:17:05,449
the significance of native

00:17:03,290 --> 00:17:07,790
burries Android provides NDK the native

00:17:05,449 --> 00:17:09,410
developer kit both Android and JVM

00:17:07,790 --> 00:17:11,780
provides something called J&I the Java

00:17:09,410 --> 00:17:13,730
native interface but the focus of all

00:17:11,780 --> 00:17:15,980
the tooling on both on these platforms

00:17:13,730 --> 00:17:20,750
is heavily directed at the use of Java

00:17:15,980 --> 00:17:24,020
for user space code so yes you can just

00:17:20,750 --> 00:17:26,059
port see Python to Android using C

00:17:24,020 --> 00:17:27,650
Python as a starting point but it's also

00:17:26,059 --> 00:17:29,929
not the natural interface to that

00:17:27,650 --> 00:17:32,090
platform your life will be a lot easier

00:17:29,929 --> 00:17:35,179
if you do what the platform actually

00:17:32,090 --> 00:17:36,980
wants you to do they're also platforms

00:17:35,179 --> 00:17:39,110
where it just isn't practical to use C

00:17:36,980 --> 00:17:40,610
Python micro Python here a bit yesterday

00:17:39,110 --> 00:17:42,590
is a really good example of this C

00:17:40,610 --> 00:17:44,960
Python is a fantastic implementation of

00:17:42,590 --> 00:17:46,429
Python as a language specification but

00:17:44,960 --> 00:17:48,770
in better devices as we heard yesterday

00:17:46,429 --> 00:17:51,110
have some really extreme constraints by

00:17:48,770 --> 00:17:53,570
comparison to servers and laptops and C

00:17:51,110 --> 00:17:54,890
Python is just too big to use in an

00:17:53,570 --> 00:17:57,080
unmodified state on an embedded

00:17:54,890 --> 00:17:58,429
microcontroller so you have to look at

00:17:57,080 --> 00:17:59,960
other ways of providing an

00:17:58,429 --> 00:18:04,400
implementation of the Python language

00:17:59,960 --> 00:18:05,870
spec if you want to use it so if you've

00:18:04,400 --> 00:18:07,610
got one of these platforms and you want

00:18:05,870 --> 00:18:09,440
to use Python on it you effectively need

00:18:07,610 --> 00:18:11,120
to provide a new implementation of

00:18:09,440 --> 00:18:14,450
Python one that is native to the

00:18:11,120 --> 00:18:15,950
capabilities of that platform so how do

00:18:14,450 --> 00:18:17,750
you do that well okay there are a couple

00:18:15,950 --> 00:18:19,730
of ways to tackle this problem one

00:18:17,750 --> 00:18:22,909
option is to use a different compiler

00:18:19,730 --> 00:18:25,429
see python is obviously inter designed

00:18:22,909 --> 00:18:27,650
to be compiled using AC compiler but

00:18:25,429 --> 00:18:29,510
there are c compilers out there that

00:18:27,650 --> 00:18:31,970
don't target traditional system

00:18:29,510 --> 00:18:34,070
executables one really notable example

00:18:31,970 --> 00:18:35,809
is in script in' it's a compiler

00:18:34,070 --> 00:18:37,460
strictly a compiler backend because it

00:18:35,809 --> 00:18:39,559
still uses the c Pazza

00:18:37,460 --> 00:18:41,990
part of the puzzle but rather than

00:18:39,559 --> 00:18:45,080
outputting a binary that can be executed

00:18:41,990 --> 00:18:48,770
as a exe file on some platform it

00:18:45,080 --> 00:18:51,169
outputs JavaScript specifically a subset

00:18:48,770 --> 00:18:53,299
of JavaScript called a SMGs that is

00:18:51,169 --> 00:18:55,820
known to run fast on certain JavaScript

00:18:53,299 --> 00:18:57,710
implementations now remember a compiler

00:18:55,820 --> 00:18:59,780
is just a black box for turning human

00:18:57,710 --> 00:19:01,909
readable bits into machine readable bits

00:18:59,780 --> 00:19:04,370
nothing said those machine readable bits

00:19:01,909 --> 00:19:05,620
had to be machine language so turn them

00:19:04,370 --> 00:19:08,240
into it so turn them into into

00:19:05,620 --> 00:19:10,520
JavaScript and if you take this approach

00:19:08,240 --> 00:19:12,620
what you get is pipe ijs a project by

00:19:10,520 --> 00:19:16,950
Ryan Kelly's Ryan here hiding somewhere

00:19:12,620 --> 00:19:19,560
there is that the back right ok and for

00:19:16,950 --> 00:19:21,180
what you get is Piper jeaious it takes

00:19:19,560 --> 00:19:22,890
the pipe I source code rather than see

00:19:21,180 --> 00:19:24,840
Python but what you get at the end of

00:19:22,890 --> 00:19:27,450
the day is a block of JavaScript that

00:19:24,840 --> 00:19:29,790
will run Python code and for suitably

00:19:27,450 --> 00:19:31,680
selected benchmarks it does so faster

00:19:29,790 --> 00:19:34,500
than C Python native on the same machine

00:19:31,680 --> 00:19:35,730
I'll let Ryan deal with the details of

00:19:34,500 --> 00:19:39,150
those potential in particular particular

00:19:35,730 --> 00:19:41,730
benchmarks but if you're not going to

00:19:39,150 --> 00:19:44,340
just recompile existing sources you will

00:19:41,730 --> 00:19:45,750
need to re-implement c python the good

00:19:44,340 --> 00:19:48,930
news is that you don't have to implement

00:19:45,750 --> 00:19:50,430
all of C Python what do I mean by that

00:19:48,930 --> 00:19:52,470
well if you pull apart a Python

00:19:50,430 --> 00:19:54,480
implementation there are a couple of

00:19:52,470 --> 00:19:57,030
different pieces the full stack of

00:19:54,480 --> 00:19:58,800
Python consists of a parser which takes

00:19:57,030 --> 00:20:00,740
human input and turns it into an

00:19:58,800 --> 00:20:02,940
in-memory representation of code a

00:20:00,740 --> 00:20:04,140
compiler which takes that in memory

00:20:02,940 --> 00:20:06,270
representation and turns it into

00:20:04,140 --> 00:20:09,150
something that can be executed in C

00:20:06,270 --> 00:20:10,920
Python that's byte code an eval loop

00:20:09,150 --> 00:20:12,360
which can be read to run the output of

00:20:10,920 --> 00:20:14,580
the compiler this is what you experience

00:20:12,360 --> 00:20:16,020
as the Python executable and then

00:20:14,580 --> 00:20:17,520
there's the standard library which can

00:20:16,020 --> 00:20:19,890
which is used by the code running

00:20:17,520 --> 00:20:21,210
through the eval loop the standard

00:20:19,890 --> 00:20:22,920
library comes in two pieces there are

00:20:21,210 --> 00:20:23,940
pieces that are written in native native

00:20:22,920 --> 00:20:25,500
language and bits that are written in

00:20:23,940 --> 00:20:27,090
Python the bits in native language

00:20:25,500 --> 00:20:29,580
driver system specific for example

00:20:27,090 --> 00:20:31,680
hitting raw POSIX system calls or

00:20:29,580 --> 00:20:35,150
they're done natively per for for

00:20:31,680 --> 00:20:37,350
performance reasons the simple approach

00:20:35,150 --> 00:20:39,330
re-implement the line rewrite the whole

00:20:37,350 --> 00:20:41,040
thing in Java or C sharp or whatever

00:20:39,330 --> 00:20:42,330
other language you want to target those

00:20:41,040 --> 00:20:43,380
parts of the standard library that are

00:20:42,330 --> 00:20:44,850
written in Python don't need to be

00:20:43,380 --> 00:20:46,860
re-implemented but the rest needs to be

00:20:44,850 --> 00:20:50,040
ported over to your new language or to a

00:20:46,860 --> 00:20:52,620
new platform and this is what micro

00:20:50,040 --> 00:20:54,180
Python Jason ironpython sculpt Brighton

00:20:52,620 --> 00:20:56,490
a bunch of others do wholesale

00:20:54,180 --> 00:20:58,020
reimplementation x' of all the c python

00:20:56,490 --> 00:20:59,100
except for the bits of the standard

00:20:58,020 --> 00:21:01,800
library that are already written in

00:20:59,100 --> 00:21:04,190
python and can be used as is but that's

00:21:01,800 --> 00:21:07,260
not the only approach you can take

00:21:04,190 --> 00:21:09,600
you don't have to throw out the entire c

00:21:07,260 --> 00:21:12,210
python stack and start from scratch

00:21:09,600 --> 00:21:14,670
C Python provides not surprisingly a

00:21:12,210 --> 00:21:16,500
really good part of a Python code that

00:21:14,670 --> 00:21:19,050
outputs a data structure that is a

00:21:16,500 --> 00:21:20,700
paused ready to manipulate version of

00:21:19,050 --> 00:21:23,130
the code that has been entered by a

00:21:20,700 --> 00:21:25,770
human this data structure is called the

00:21:23,130 --> 00:21:27,300
ast or the abstract syntax tree and it's

00:21:25,770 --> 00:21:29,190
represent it's a representation that has

00:21:27,300 --> 00:21:30,139
been designed to be manipulated and

00:21:29,190 --> 00:21:33,299
convert

00:21:30,139 --> 00:21:35,610
the normal sea Python compiler takes

00:21:33,299 --> 00:21:37,529
that ast and converts it into byte code

00:21:35,610 --> 00:21:40,289
that can then be executed by C patents

00:21:37,529 --> 00:21:42,269
either event loop however you can just

00:21:40,289 --> 00:21:44,490
as easily take that ast and turn it into

00:21:42,269 --> 00:21:47,700
any other representation that would be

00:21:44,490 --> 00:21:51,149
helpful for example Java byte code ought

00:21:47,700 --> 00:21:53,220
net CLR byte code that approach is what

00:21:51,149 --> 00:21:55,559
vaak does vaak is effectively a cross

00:21:53,220 --> 00:21:57,899
compiler for python code it's a compiler

00:21:55,559 --> 00:22:01,260
written in Python so it can be executed

00:21:57,899 --> 00:22:03,870
by C Python but it outputs Java byte

00:22:01,260 --> 00:22:06,299
code that can run on any JVM instance

00:22:03,870 --> 00:22:08,039
when the Java byte code runs it's

00:22:06,299 --> 00:22:10,409
indistinguishable from code that has

00:22:08,039 --> 00:22:12,539
come from Java source code compiled by

00:22:10,409 --> 00:22:14,730
the Java compiler it but it just refers

00:22:12,539 --> 00:22:18,269
to line numbers from the Python source

00:22:14,730 --> 00:22:20,460
code okay so we can reuse C pythons

00:22:18,269 --> 00:22:22,440
parser to make our life a little easier

00:22:20,460 --> 00:22:24,929
do we have to stop there is there any

00:22:22,440 --> 00:22:26,850
more of C Python that we can reuse in

00:22:24,929 --> 00:22:30,600
our quest to get Python on a different

00:22:26,850 --> 00:22:33,649
platform well yeah if you want to you

00:22:30,600 --> 00:22:36,809
can even reuse C pythons compiler to

00:22:33,649 --> 00:22:38,610
when you run some Python codes it's in a

00:22:36,809 --> 00:22:41,760
pig py file through the C Python

00:22:38,610 --> 00:22:44,610
compiler it outputs a dot py c file that

00:22:41,760 --> 00:22:46,679
py c file is the compiled version of the

00:22:44,610 --> 00:22:49,169
code it's a binary representation but

00:22:46,679 --> 00:22:52,710
not a system binary not an executable by

00:22:49,169 --> 00:22:54,539
itself it's a bytecode representation by

00:22:52,710 --> 00:22:56,789
code is a bit like us at a high level

00:22:54,539 --> 00:22:59,100
assembly language it's an encoded set of

00:22:56,789 --> 00:23:01,409
instructions for a stack based virtual

00:22:59,100 --> 00:23:03,029
machine that has basic primitives like

00:23:01,409 --> 00:23:04,889
pushing and popping on to a stack

00:23:03,029 --> 00:23:07,380
setting attributes at an object handling

00:23:04,889 --> 00:23:10,080
exceptions and so on there's nothing

00:23:07,380 --> 00:23:13,019
about Python the language that specifies

00:23:10,080 --> 00:23:15,929
bytecode it's entirely a runtime format

00:23:13,019 --> 00:23:17,580
used by the C Python interpreter the C

00:23:15,929 --> 00:23:18,720
Python interpreter is what provides the

00:23:17,580 --> 00:23:21,120
virtual machine that can actually

00:23:18,720 --> 00:23:22,500
execute that bytecode but there's

00:23:21,120 --> 00:23:25,169
nothing to say that we couldn't create

00:23:22,500 --> 00:23:27,480
an independent implementation of the C

00:23:25,169 --> 00:23:30,750
Python virtual machine capable of

00:23:27,480 --> 00:23:32,940
running C Python bytecode and that's

00:23:30,750 --> 00:23:35,039
what pettalia does batavia is an

00:23:32,940 --> 00:23:37,139
implementation of the C Python virtual

00:23:35,039 --> 00:23:39,179
machine written in JavaScript and

00:23:37,139 --> 00:23:42,480
because it's written in JavaScript it

00:23:39,179 --> 00:23:43,690
can run in the browser now while that

00:23:42,480 --> 00:23:45,820
might seem a little bit daunting

00:23:43,690 --> 00:23:48,460
it's actually not that hard after all

00:23:45,820 --> 00:23:49,810
cpython bytecode is only a hundred or so

00:23:48,460 --> 00:23:51,340
operations it's sort of a pseudo

00:23:49,810 --> 00:23:53,020
assembler at the end of the day and a

00:23:51,340 --> 00:23:54,790
good chunk of those operations of those

00:23:53,020 --> 00:23:56,620
hundred operations are basic

00:23:54,790 --> 00:23:57,910
mathematical primitives plus minus

00:23:56,620 --> 00:24:00,610
multiply and divide

00:23:57,910 --> 00:24:03,040
so reimplemented those doesn't take a

00:24:00,610 --> 00:24:04,780
whole lot of code the biggest

00:24:03,040 --> 00:24:06,880
complication in that process is that see

00:24:04,780 --> 00:24:08,800
Python because black code is not part of

00:24:06,880 --> 00:24:11,170
the specification C paithan makes no

00:24:08,800 --> 00:24:14,590
guarantees of compatibility in byte code

00:24:11,170 --> 00:24:16,930
versions and between Python 3.4 3.5 and

00:24:14,590 --> 00:24:18,430
3.6 there have been several major

00:24:16,930 --> 00:24:20,590
changes in byte code format in

00:24:18,430 --> 00:24:22,390
interpretation but you can stay on top

00:24:20,590 --> 00:24:24,010
of those if you want to it's not a major

00:24:22,390 --> 00:24:25,000
problem just kind of an annoyance from

00:24:24,010 --> 00:24:28,390
someone who's sitting there trying to

00:24:25,000 --> 00:24:30,820
re-implement a bytecode machine now

00:24:28,390 --> 00:24:32,620
whenever I tell anybody about Batavia

00:24:30,820 --> 00:24:34,660
the first reaction I hear is normally

00:24:32,620 --> 00:24:37,060
well why don't you just compile Python

00:24:34,660 --> 00:24:39,310
code into JavaScript and yeah okay that

00:24:37,060 --> 00:24:41,860
is actually an option on the surface it

00:24:39,310 --> 00:24:43,000
even seems relatively easy there sure

00:24:41,860 --> 00:24:44,860
there are sort of syntactic differences

00:24:43,000 --> 00:24:46,450
between Python and JavaScript but a lot

00:24:44,860 --> 00:24:48,850
of those are cosmetic now using braces

00:24:46,450 --> 00:24:50,290
and different looping constructs the

00:24:48,850 --> 00:24:52,630
catch is though if you dig a little bit

00:24:50,290 --> 00:24:54,760
deeper it's a lot more complex than that

00:24:52,630 --> 00:24:56,740
you don't just want a language that

00:24:54,760 --> 00:24:59,590
looks like Python you want it to run

00:24:56,740 --> 00:25:02,070
like Python as well and pythons scoping

00:24:59,590 --> 00:25:04,420
rules are very different to Java scripts

00:25:02,070 --> 00:25:06,490
it's like this really simple example

00:25:04,420 --> 00:25:08,560
these two code snippets are cosmetically

00:25:06,490 --> 00:25:10,270
the same modulo a language translation

00:25:08,560 --> 00:25:11,830
the only thing that's a little bit hairy

00:25:10,270 --> 00:25:13,450
is the change in the arguments to the

00:25:11,830 --> 00:25:15,100
print statement one takes a sequence of

00:25:13,450 --> 00:25:18,550
arguments the others using concatenation

00:25:15,100 --> 00:25:21,130
with a plus operator okay what gets

00:25:18,550 --> 00:25:22,540
output when you run them when you run

00:25:21,130 --> 00:25:24,040
the JavaScript code at the top you call

00:25:22,540 --> 00:25:29,620
scope test three then you output the

00:25:24,040 --> 00:25:33,360
value of X what you get prints 30 what

00:25:29,620 --> 00:25:35,920
about the Python unbound local error

00:25:33,360 --> 00:25:38,950
because X has been referenced before

00:25:35,920 --> 00:25:41,530
assignment Y because JavaScript scoping

00:25:38,950 --> 00:25:43,450
rules put X in global scope Python

00:25:41,530 --> 00:25:45,460
scoping rules mean that X can be

00:25:43,450 --> 00:25:47,890
accessed for reading but not for writing

00:25:45,460 --> 00:25:51,430
now okay for the pedant yes if you used

00:25:47,890 --> 00:25:52,840
es6 let's instead of var or use global

00:25:51,430 --> 00:25:54,520
in the Python version you'd get output

00:25:52,840 --> 00:25:55,720
that would be comparable here this is an

00:25:54,520 --> 00:25:57,100
intentionally simple example to

00:25:55,720 --> 00:25:58,900
illustrate the point the

00:25:57,100 --> 00:26:00,190
it's a whole lot more complex than this

00:25:58,900 --> 00:26:04,960
if you start talking about things like

00:26:00,190 --> 00:26:08,410
closures so if you want to preserve

00:26:04,960 --> 00:26:10,000
Python semantics in JavaScript you can't

00:26:08,410 --> 00:26:11,770
just do a syntax conversion or at least

00:26:10,000 --> 00:26:13,299
not a simple syntax conversion you

00:26:11,770 --> 00:26:15,100
actually have to parse the code and

00:26:13,299 --> 00:26:17,440
generate JavaScript constructs that

00:26:15,100 --> 00:26:19,539
expose the same lexical scoping that

00:26:17,440 --> 00:26:21,010
Python expects which means you're

00:26:19,539 --> 00:26:23,770
basically there for three choices you

00:26:21,010 --> 00:26:26,320
can either re implement pythons scoping

00:26:23,770 --> 00:26:28,240
rules in JavaScript you can treat your

00:26:26,320 --> 00:26:30,610
resulting compiler as a Python like

00:26:28,240 --> 00:26:33,190
language that looks like Python but has

00:26:30,610 --> 00:26:35,740
lots of subtle differences or something

00:26:33,190 --> 00:26:37,150
in between the two and it turns out it

00:26:35,740 --> 00:26:38,590
actually ends up being a lot employees

00:26:37,150 --> 00:26:40,690
e'er to implement the bytecode machine

00:26:38,590 --> 00:26:45,039
because all you have to deal with is the

00:26:40,690 --> 00:26:47,169
values that are in a single stack okay

00:26:45,039 --> 00:26:49,570
so what's the downside of reusing C

00:26:47,169 --> 00:26:51,400
pythons parser or compiler well it means

00:26:49,570 --> 00:26:53,679
that you've made a decision that parts

00:26:51,400 --> 00:26:56,530
of your stack won't be running on your

00:26:53,679 --> 00:26:58,570
new platform if you're you were using C

00:26:56,530 --> 00:27:00,460
pythons parser and compiler then that

00:26:58,570 --> 00:27:02,830
obviously means that part of the stack

00:27:00,460 --> 00:27:05,110
will only run where C Python will run

00:27:02,830 --> 00:27:07,390
you're effectively cross-compiling your

00:27:05,110 --> 00:27:09,700
Python code using one platform to

00:27:07,390 --> 00:27:13,870
produce a binary that will run somewhere

00:27:09,700 --> 00:27:15,970
else that means your Python platform or

00:27:13,870 --> 00:27:18,850
your target platform won't have the

00:27:15,970 --> 00:27:21,429
ability to parse and compile code on its

00:27:18,850 --> 00:27:23,559
own this means the one thing you don't

00:27:21,429 --> 00:27:25,900
get on your new platform is a wrapper a

00:27:23,559 --> 00:27:27,460
read eval print loop that is the Python

00:27:25,900 --> 00:27:29,530
prompt where you can interactively type

00:27:27,460 --> 00:27:32,140
an execute Python code having a ripple

00:27:29,530 --> 00:27:34,539
relies on the ability to compile code

00:27:32,140 --> 00:27:36,549
locally if you don't have a native

00:27:34,539 --> 00:27:39,250
compilation capability you can't have a

00:27:36,549 --> 00:27:40,630
ripple now that might seem like a really

00:27:39,250 --> 00:27:42,820
bigger mission but the platform's we're

00:27:40,630 --> 00:27:45,070
targeting here aren't natural matches

00:27:42,820 --> 00:27:46,900
for a ripple nobody really wants to be

00:27:45,070 --> 00:27:49,630
typing Python coding to their watch so

00:27:46,900 --> 00:27:51,520
on these devices pi thea is really about

00:27:49,630 --> 00:27:53,470
being a high productivity programming

00:27:51,520 --> 00:27:55,480
language not an interactive programming

00:27:53,470 --> 00:27:57,070
language and you also have to think

00:27:55,480 --> 00:27:58,510
about the entire development cycle

00:27:57,070 --> 00:27:59,919
remember one of the reasons that we're

00:27:58,510 --> 00:28:01,390
putting to Python is so that the same

00:27:59,919 --> 00:28:04,750
code can run on multiple multiple

00:28:01,390 --> 00:28:06,760
devices you could develop code on a

00:28:04,750 --> 00:28:08,820
desktop machine using C Python and a

00:28:06,760 --> 00:28:10,600
ripple use some mocking and stubbing

00:28:08,820 --> 00:28:11,980
native parts

00:28:10,600 --> 00:28:13,899
then once the call light we call logic

00:28:11,980 --> 00:28:18,429
of your app is working ship it to the

00:28:13,899 --> 00:28:20,110
device for final testing okay so at this

00:28:18,429 --> 00:28:21,759
point either by re-implementing or

00:28:20,110 --> 00:28:23,110
borrowing from cpython you've got a

00:28:21,759 --> 00:28:24,610
parser you've got a compiler and you've

00:28:23,110 --> 00:28:27,100
got some mechanism for executing that

00:28:24,610 --> 00:28:29,830
code so you can run Python code on that

00:28:27,100 --> 00:28:32,039
machine but only the code there's still

00:28:29,830 --> 00:28:34,480
a big piece missing the standard library

00:28:32,039 --> 00:28:36,039
the C Python standard library is made up

00:28:34,480 --> 00:28:38,259
of two parts there's a pure Python part

00:28:36,039 --> 00:28:39,519
and a part that's written in C the bit

00:28:38,259 --> 00:28:40,840
that's written in pure Python is easy

00:28:39,519 --> 00:28:42,820
you can just take it and compile it

00:28:40,840 --> 00:28:44,110
wholesales it's Python code it compiles

00:28:42,820 --> 00:28:46,720
this Python code the same as everything

00:28:44,110 --> 00:28:48,039
else we can compile it to bytecode run

00:28:46,720 --> 00:28:49,539
it through our new virtual machine or we

00:28:48,039 --> 00:28:51,669
can cross compile it to our new target

00:28:49,539 --> 00:28:52,960
platform or just rerun it on our

00:28:51,669 --> 00:28:55,840
reimplemented Python whatever you need

00:28:52,960 --> 00:28:58,480
to do but the bits written in C are a

00:28:55,840 --> 00:29:00,309
little bit more complicated there's a

00:28:58,480 --> 00:29:02,019
couple of reasons why our module might

00:29:00,309 --> 00:29:03,460
be written in C firstly there are

00:29:02,019 --> 00:29:05,590
occasions where what you're doing is

00:29:03,460 --> 00:29:07,870
talking directly to system services if

00:29:05,590 --> 00:29:09,909
you're going to make a POSIX exit call

00:29:07,870 --> 00:29:11,909
well you're gonna need to call the C

00:29:09,909 --> 00:29:13,750
method that implements a POSIX exag

00:29:11,909 --> 00:29:15,730
there are also modules that are

00:29:13,750 --> 00:29:17,110
implemented in C because they're just a

00:29:15,730 --> 00:29:19,629
wrapper around some library whose

00:29:17,110 --> 00:29:21,250
implementation is in C be zipped to for

00:29:19,629 --> 00:29:23,350
example as a compression library the

00:29:21,250 --> 00:29:26,259
reference implementation for B zip to is

00:29:23,350 --> 00:29:30,279
in C sure you could rewrite it but why

00:29:26,259 --> 00:29:31,389
would you you just use lit bz2 lastly

00:29:30,279 --> 00:29:32,470
there are parts of the standard library

00:29:31,389 --> 00:29:34,090
that are implemented in C for

00:29:32,470 --> 00:29:36,789
performance reasons for example the

00:29:34,090 --> 00:29:38,649
decimal module used to be implemented in

00:29:36,789 --> 00:29:42,309
pure Python for performance reasons it

00:29:38,649 --> 00:29:44,200
was ported to C in Python 3.5 and that's

00:29:42,309 --> 00:29:45,879
great for C Python there's a link as an

00:29:44,200 --> 00:29:47,740
implementation of Python nobody's going

00:29:45,879 --> 00:29:49,090
to complain about high performance but

00:29:47,740 --> 00:29:51,129
if you're looking at C Python as a

00:29:49,090 --> 00:29:52,509
reference implementation it's a bit more

00:29:51,129 --> 00:29:53,860
annoying because it means that that's

00:29:52,509 --> 00:29:56,710
now something you have to implement

00:29:53,860 --> 00:29:58,570
natively what we really need here is a

00:29:56,710 --> 00:29:59,950
reference standard library as well an

00:29:58,570 --> 00:30:02,350
implementation of the Python standard

00:29:59,950 --> 00:30:04,899
library that is written entirely in pure

00:30:02,350 --> 00:30:07,259
Python except for a clearly delineated

00:30:04,899 --> 00:30:09,730
minimal interface to system services and

00:30:07,259 --> 00:30:11,080
that's what a row Burress is for those

00:30:09,730 --> 00:30:13,059
that up in your Greek mythology that's

00:30:11,080 --> 00:30:16,360
the iris is the symbol of a snake eating

00:30:13,059 --> 00:30:17,740
its own tail tail a robe roast is very

00:30:16,360 --> 00:30:19,389
much a work in progress but it's an

00:30:17,740 --> 00:30:20,769
important part of the whole puzzle if

00:30:19,389 --> 00:30:24,330
we're going to make it easy to bring

00:30:20,769 --> 00:30:24,330
Python to as many platforms as possible

00:30:24,430 --> 00:30:27,220
the last piece of the puzzle is

00:30:25,600 --> 00:30:28,990
deployment now this is an area where

00:30:27,220 --> 00:30:31,150
Python historically has not had a very

00:30:28,990 --> 00:30:32,770
good story even in the web world which

00:30:31,150 --> 00:30:35,320
is considered one of pythons strengths

00:30:32,770 --> 00:30:37,840
pythons deployment story lags a long way

00:30:35,320 --> 00:30:39,490
behind other languages like PHP a PHP

00:30:37,840 --> 00:30:41,710
developer just needs a directory where

00:30:39,490 --> 00:30:42,940
they can FTP coding to maybe some

00:30:41,710 --> 00:30:43,960
details about the host where they're

00:30:42,940 --> 00:30:46,030
going to be where the database is going

00:30:43,960 --> 00:30:48,490
to be connected and they can deploy a

00:30:46,030 --> 00:30:50,560
site a Python web developer need to know

00:30:48,490 --> 00:30:52,060
about whiskey web server configuration

00:30:50,560 --> 00:30:54,130
mechanisms for activating virtual

00:30:52,060 --> 00:30:55,420
environments it's not too daunting once

00:30:54,130 --> 00:30:57,340
you know how all the pieces work but

00:30:55,420 --> 00:30:59,260
it's certainly a long way from one-click

00:30:57,340 --> 00:31:00,970
deployment and it's a lot more daunting

00:30:59,260 --> 00:31:03,220
than first-time developers are generally

00:31:00,970 --> 00:31:04,660
ready for and as hard as it is to

00:31:03,220 --> 00:31:06,490
believe the situation is worse for

00:31:04,660 --> 00:31:08,680
desktop you want someone with a Windows

00:31:06,490 --> 00:31:09,270
computer to run your Python script good

00:31:08,680 --> 00:31:11,650
luck with that

00:31:09,270 --> 00:31:13,330
better hope they've got admin access and

00:31:11,650 --> 00:31:14,830
know how to find the dialog hidden three

00:31:13,330 --> 00:31:16,030
levels deep in the control panel that

00:31:14,830 --> 00:31:19,000
lets them set their path environment

00:31:16,030 --> 00:31:21,370
variable the good news is that this

00:31:19,000 --> 00:31:22,780
problem can be solved and moving to

00:31:21,370 --> 00:31:25,030
platforms like phones and watches will

00:31:22,780 --> 00:31:27,370
force us as a community to address these

00:31:25,030 --> 00:31:28,870
problems these devices don't have a

00:31:27,370 --> 00:31:31,870
control panel if you want to distribute

00:31:28,870 --> 00:31:34,300
apps for a phone you need to package

00:31:31,870 --> 00:31:36,160
them as standalone tools with a simple

00:31:34,300 --> 00:31:38,680
entry point and we have to develop the

00:31:36,160 --> 00:31:39,670
tooling for these new platforms so why

00:31:38,680 --> 00:31:42,520
not take a look at our existing

00:31:39,670 --> 00:31:43,540
platforms while we're at it and this is

00:31:42,520 --> 00:31:45,400
what I've been trying to do with a tool

00:31:43,540 --> 00:31:46,930
called briefcase it's a dist utils

00:31:45,400 --> 00:31:49,060
extension that will convert any Python

00:31:46,930 --> 00:31:51,310
project with a setup dot PI file into a

00:31:49,060 --> 00:31:52,690
deployable unit now again it's also

00:31:51,310 --> 00:31:55,030
early days for a briefcase but it works

00:31:52,690 --> 00:31:56,770
on Mac OS it works on iOS it works on TV

00:31:55,030 --> 00:31:58,870
OS it has preliminary support for

00:31:56,770 --> 00:32:01,060
Android if anybody here has an interest

00:31:58,870 --> 00:32:02,440
in in Windows I've got some ideas about

00:32:01,060 --> 00:32:04,090
how this the approach that's used for

00:32:02,440 --> 00:32:05,980
Mac OS could be used to make the windows

00:32:04,090 --> 00:32:08,310
deployment story easy as well so come

00:32:05,980 --> 00:32:08,310
talk to me

00:32:13,440 --> 00:32:18,040
now a lot of those specific tools and

00:32:16,510 --> 00:32:19,750
libraries that I've spoken about so far

00:32:18,040 --> 00:32:21,610
have been you know are in very early

00:32:19,750 --> 00:32:22,990
stages of development the flip side of

00:32:21,610 --> 00:32:25,330
this is that there's a lot of very

00:32:22,990 --> 00:32:26,920
fertile ground for contributions if you

00:32:25,330 --> 00:32:27,730
want to get involved I'm here to the end

00:32:26,920 --> 00:32:29,590
of the sprints

00:32:27,730 --> 00:32:31,090
no matter your level of expertise and I

00:32:29,590 --> 00:32:32,950
do mean no matter your level of

00:32:31,090 --> 00:32:34,270
expertise come grab me during the

00:32:32,950 --> 00:32:36,400
sprints and we can find something for

00:32:34,270 --> 00:32:38,260
you to work on and if you do thanks to

00:32:36,400 --> 00:32:40,179
Maxie and I've actually got shiny

00:32:38,260 --> 00:32:45,040
beware contributors challenge coin that

00:32:40,179 --> 00:32:47,440
everyone will get so that's the how

00:32:45,040 --> 00:32:51,250
that's how you introduce Python to a new

00:32:47,440 --> 00:32:53,049
hardware platform but why why is this

00:32:51,250 --> 00:32:54,730
important why have I spent so much time

00:32:53,049 --> 00:32:57,419
and effort trying to get Python to run

00:32:54,730 --> 00:32:59,980
in places where it doesn't currently run

00:32:57,419 --> 00:33:01,840
for me it's about evaluating our

00:32:59,980 --> 00:33:03,880
existential threats as a programming

00:33:01,840 --> 00:33:05,290
community Python is on the bit of a

00:33:03,880 --> 00:33:07,510
crest of a bit of a wave at the moment

00:33:05,290 --> 00:33:09,760
over the last 25 years we have built up

00:33:07,510 --> 00:33:11,740
a significant community and resources

00:33:09,760 --> 00:33:13,210
and expertise and as a result most

00:33:11,740 --> 00:33:16,450
surveys including that one from O Triple

00:33:13,210 --> 00:33:17,830
E before put Python in the top 4 or 5

00:33:16,450 --> 00:33:21,130
programming languages you should know

00:33:17,830 --> 00:33:23,470
usually only behind Java and C C++ in

00:33:21,130 --> 00:33:26,679
some variation in order the growth of

00:33:23,470 --> 00:33:30,370
events like Python are a great

00:33:26,679 --> 00:33:32,260
indication of that success so in the

00:33:30,370 --> 00:33:33,910
midst of this success it behooves us to

00:33:32,260 --> 00:33:35,410
look to the future and consider whether

00:33:33,910 --> 00:33:37,210
the light at the end of the tunnel is

00:33:35,410 --> 00:33:40,000
the dawning of a bright tomorrow or a

00:33:37,210 --> 00:33:42,960
train coming straight for us we need to

00:33:40,000 --> 00:33:45,790
ask quaver Dimas where are we going

00:33:42,960 --> 00:33:47,290
Python has been around for 25 years it

00:33:45,790 --> 00:33:49,059
was originally found a foothold as a

00:33:47,290 --> 00:33:51,549
systems integration language on servers

00:33:49,059 --> 00:33:53,740
over time it found another niche as web

00:33:51,549 --> 00:33:56,260
server resulting in soap and Django and

00:33:53,740 --> 00:33:58,059
pyramid and plone and others the era of

00:33:56,260 --> 00:33:59,140
Python is a major web platform is maybe

00:33:58,059 --> 00:34:01,150
10 years old

00:33:59,140 --> 00:34:02,410
since that time Python has found

00:34:01,150 --> 00:34:04,360
footholds there's an educational

00:34:02,410 --> 00:34:05,770
language as a data analysis language

00:34:04,360 --> 00:34:07,630
it's found footholds because it's an

00:34:05,770 --> 00:34:09,490
easy and straightforward language to

00:34:07,630 --> 00:34:11,980
teach while retaining the power of a

00:34:09,490 --> 00:34:13,600
hardcore computer science language we've

00:34:11,980 --> 00:34:14,919
developed a reputation we've developed a

00:34:13,600 --> 00:34:16,720
community we've developed a rich

00:34:14,919 --> 00:34:20,200
ecosystem of tools and libraries around

00:34:16,720 --> 00:34:21,970
the core of the language so what changes

00:34:20,200 --> 00:34:25,629
are coming that pose a potential

00:34:21,970 --> 00:34:26,740
existential threat to all of this well

00:34:25,629 --> 00:34:27,879
the most obvious one

00:34:26,740 --> 00:34:29,679
is the one that I've been addressing

00:34:27,879 --> 00:34:31,510
directly so far the last ten years have

00:34:29,679 --> 00:34:33,639
seen an explosion in the platforms that

00:34:31,510 --> 00:34:35,139
people are using for computing and the

00:34:33,639 --> 00:34:37,840
types of people that are using those

00:34:35,139 --> 00:34:38,649
platforms computers aren't just for

00:34:37,840 --> 00:34:40,629
geeks anymore

00:34:38,649 --> 00:34:42,869
these devices have rapidly become an

00:34:40,629 --> 00:34:44,980
indispensable part of everyone's lives

00:34:42,869 --> 00:34:46,840
and this means that these new platforms

00:34:44,980 --> 00:34:48,550
are becoming an increasingly important

00:34:46,840 --> 00:34:51,100
part of the development landscape if

00:34:48,550 --> 00:34:53,169
Python doesn't have a good story for

00:34:51,100 --> 00:34:56,379
mobile we run the risk of being left

00:34:53,169 --> 00:34:58,330
behind servers aren't going anywhere but

00:34:56,379 --> 00:35:00,010
they've only ever been used by a very

00:34:58,330 --> 00:35:01,660
small portion of the community and the

00:35:00,010 --> 00:35:04,210
growth of services like serverless

00:35:01,660 --> 00:35:06,640
computing is part of a larger trend to

00:35:04,210 --> 00:35:09,790
hide even more server details as for

00:35:06,640 --> 00:35:11,230
desktop machines sales trends of desktop

00:35:09,790 --> 00:35:13,210
machines versus phones and tablets

00:35:11,230 --> 00:35:15,640
they're certainly pointing towards a

00:35:13,210 --> 00:35:16,750
time where desktop machines as we

00:35:15,640 --> 00:35:18,700
currently think of them at least either

00:35:16,750 --> 00:35:19,840
won't exist will exist in a radically

00:35:18,700 --> 00:35:22,930
different form than what with what we

00:35:19,840 --> 00:35:24,820
think of them today so if using a

00:35:22,930 --> 00:35:26,920
general-purpose language that can only

00:35:24,820 --> 00:35:28,780
be used in a tiny portion of computing

00:35:26,920 --> 00:35:30,940
devices what hope does that language

00:35:28,780 --> 00:35:35,109
community as a whole have I'd say not

00:35:30,940 --> 00:35:37,359
much but the threat is also a huge

00:35:35,109 --> 00:35:39,010
opportunity many of the areas where

00:35:37,359 --> 00:35:41,260
python has gained traction in it in

00:35:39,010 --> 00:35:42,730
science in education these are areas

00:35:41,260 --> 00:35:46,030
where the new wear new devices have the

00:35:42,730 --> 00:35:47,380
potential to make a huge impact imagine

00:35:46,030 --> 00:35:49,090
a world where a scientist can knock

00:35:47,380 --> 00:35:50,500
together a quick user interface to put

00:35:49,090 --> 00:35:52,510
in the hands of experimenters to gather

00:35:50,500 --> 00:35:54,670
information or provide an app so that

00:35:52,510 --> 00:35:57,310
citizen scientists could log local flora

00:35:54,670 --> 00:35:58,840
fauna environmental conditions imagine a

00:35:57,310 --> 00:36:00,430
world where you can get kids excited in

00:35:58,840 --> 00:36:02,200
programming because they can build

00:36:00,430 --> 00:36:04,840
something that runs on their phone that

00:36:02,200 --> 00:36:07,210
they can show to their friends imagine a

00:36:04,840 --> 00:36:09,430
django girl-style event where students

00:36:07,210 --> 00:36:11,230
leave the tutorial after a day having

00:36:09,430 --> 00:36:13,960
come in knowing very little about about

00:36:11,230 --> 00:36:16,119
programming but leave with a mobile

00:36:13,960 --> 00:36:18,940
phone app that they use to upload photos

00:36:16,119 --> 00:36:20,650
to their blog Python is a

00:36:18,940 --> 00:36:22,750
general-purpose programming language

00:36:20,650 --> 00:36:24,880
there's no reason it has to be tied to

00:36:22,750 --> 00:36:26,800
historical platforms we just have to pay

00:36:24,880 --> 00:36:30,310
attention to the new platforms that are

00:36:26,800 --> 00:36:32,080
emerging so what are we competing

00:36:30,310 --> 00:36:34,690
against here and what advantages does

00:36:32,080 --> 00:36:35,740
Python bring to that struggle well we're

00:36:34,690 --> 00:36:37,630
competing against a background

00:36:35,740 --> 00:36:39,700
environment where poly lingual ism is

00:36:37,630 --> 00:36:41,500
required at present

00:36:39,700 --> 00:36:43,780
there is not a single programming

00:36:41,500 --> 00:36:46,660
language that can be used on every

00:36:43,780 --> 00:36:48,430
platform as a native offering Apple

00:36:46,660 --> 00:36:50,440
pushes Objective C and Swift as their

00:36:48,430 --> 00:36:53,800
preferred languages Android pushes Java

00:36:50,440 --> 00:36:55,990
the web requires JavaScript so today if

00:36:53,800 --> 00:36:57,099
you're a scientist or a student and you

00:36:55,990 --> 00:36:58,690
wanted to write an app that was

00:36:57,099 --> 00:37:00,670
available on multiple platforms

00:36:58,690 --> 00:37:02,320
you would have to learn several

00:37:00,670 --> 00:37:06,640
different programming languages three

00:37:02,320 --> 00:37:08,440
maybe four poly legalism be it in

00:37:06,640 --> 00:37:09,490
computer languages or human languages is

00:37:08,440 --> 00:37:10,750
a good thing

00:37:09,490 --> 00:37:12,280
there are countless studies out there

00:37:10,750 --> 00:37:14,470
that reinforced the benefits of learning

00:37:12,280 --> 00:37:16,359
a second spoken language improvements in

00:37:14,470 --> 00:37:18,339
perception memory decision making

00:37:16,359 --> 00:37:20,079
problem solving this is also true of

00:37:18,339 --> 00:37:21,760
programming languages learning a second

00:37:20,079 --> 00:37:23,650
or third or fourth programming language

00:37:21,760 --> 00:37:25,390
especially when it's a completely

00:37:23,650 --> 00:37:27,099
different programming paradigm is a

00:37:25,390 --> 00:37:28,470
great way to encourage your brain to

00:37:27,099 --> 00:37:31,839
think about problems in a different

00:37:28,470 --> 00:37:33,490
creative way and if you're a

00:37:31,839 --> 00:37:34,690
compressional computer scientist or

00:37:33,490 --> 00:37:36,579
software engineer I'd absolutely

00:37:34,690 --> 00:37:38,890
encourage you to learn as many

00:37:36,579 --> 00:37:40,240
programming languages as you can but

00:37:38,890 --> 00:37:43,359
that's not the market we're talking

00:37:40,240 --> 00:37:44,470
about here unlike spoken languages there

00:37:43,359 --> 00:37:46,599
isn't an obvious

00:37:44,470 --> 00:37:48,790
first-contact programming language if

00:37:46,599 --> 00:37:50,680
you're born in Melbourne your first

00:37:48,790 --> 00:37:52,660
spoken language will almost certainly be

00:37:50,680 --> 00:37:54,520
English if you're born in iing

00:37:52,660 --> 00:37:57,730
it's almost certainly going to be

00:37:54,520 --> 00:38:00,420
Mandarin but in computer languages there

00:37:57,730 --> 00:38:02,589
isn't an obvious first-contact language

00:38:00,420 --> 00:38:04,630
there isn't a programming language that

00:38:02,589 --> 00:38:07,089
everyone in a community speaks by virtue

00:38:04,630 --> 00:38:12,250
of just existing in that community that

00:38:07,089 --> 00:38:14,349
means there is ground to be one it's

00:38:12,250 --> 00:38:17,170
this first contact status that is to my

00:38:14,349 --> 00:38:19,210
mind critical consider the world 20

00:38:17,170 --> 00:38:21,160
years ago Visual Basic was one of the

00:38:19,210 --> 00:38:22,930
most widespread programming languages in

00:38:21,160 --> 00:38:24,760
common usage not because it was an

00:38:22,930 --> 00:38:26,589
especially powerful programming language

00:38:24,760 --> 00:38:28,510
but because it was present on every

00:38:26,589 --> 00:38:30,730
Windows computer was accessible to

00:38:28,510 --> 00:38:32,260
non-expert users and enabled people to

00:38:30,730 --> 00:38:34,480
do really powerful things with the

00:38:32,260 --> 00:38:36,310
office suite of apps Visual Basic was

00:38:34,480 --> 00:38:39,369
their first contact programming language

00:38:36,310 --> 00:38:41,770
many users never moved beyond it neither

00:38:39,369 --> 00:38:44,079
should they have had to there is immense

00:38:41,770 --> 00:38:46,990
power in being the language that people

00:38:44,079 --> 00:38:48,790
use to discover programming and Python

00:38:46,990 --> 00:38:50,680
has repeatedly demonstrated that it's a

00:38:48,790 --> 00:38:52,630
great candidate to be the first contact

00:38:50,680 --> 00:38:53,440
programming language from django girls

00:38:52,630 --> 00:38:55,780
to university

00:38:53,440 --> 00:38:57,250
computer science courses Python has been

00:38:55,780 --> 00:38:59,589
used as an introductory programming

00:38:57,250 --> 00:39:01,720
language and yet unlike Visual Basic

00:38:59,589 --> 00:39:03,520
it's a programming language that is able

00:39:01,720 --> 00:39:05,260
to support very sophisticated computer

00:39:03,520 --> 00:39:08,920
science concepts like generators and

00:39:05,260 --> 00:39:10,720
asynchronous processing and so on when

00:39:08,920 --> 00:39:12,220
marketing people talk about selling a

00:39:10,720 --> 00:39:14,500
product they often talk about conversion

00:39:12,220 --> 00:39:16,089
funnels conversion funnels the idea that

00:39:14,500 --> 00:39:18,010
there is an entire world of people out

00:39:16,089 --> 00:39:20,349
there but they have to move through your

00:39:18,010 --> 00:39:22,030
sales process to buy your product and

00:39:20,349 --> 00:39:23,859
each step they have to go through that

00:39:22,030 --> 00:39:26,380
process some loss is probably inevitable

00:39:23,859 --> 00:39:27,310
and the funnel narrows but the goal is

00:39:26,380 --> 00:39:28,930
that at the end of the day they're going

00:39:27,310 --> 00:39:30,460
to end at the bottom of your funnel as a

00:39:28,930 --> 00:39:32,680
user of your product a consumer of your

00:39:30,460 --> 00:39:35,290
product or purchase of your product the

00:39:32,680 --> 00:39:37,300
the goal of marketing is to minimize the

00:39:35,290 --> 00:39:39,010
loss between each step and end up with a

00:39:37,300 --> 00:39:41,260
viable output of the funnel at the end

00:39:39,010 --> 00:39:42,880
of the day it can help to think about

00:39:41,260 --> 00:39:44,319
the adoption of software projects in a

00:39:42,880 --> 00:39:46,450
very similar set of terms there is our

00:39:44,319 --> 00:39:47,920
world of potential users out there some

00:39:46,450 --> 00:39:49,359
of them will actually use your product

00:39:47,920 --> 00:39:50,950
some of them will continue to use your

00:39:49,359 --> 00:39:52,180
product some of them will become members

00:39:50,950 --> 00:39:53,440
of your community some of them will

00:39:52,180 --> 00:39:54,670
become contributors to your community

00:39:53,440 --> 00:39:56,579
some of them become members of the core

00:39:54,670 --> 00:39:59,079
team and eventually lead the community

00:39:56,579 --> 00:40:01,119
now there are two ways to hack a

00:39:59,079 --> 00:40:02,920
conversion funnel you can work on the

00:40:01,119 --> 00:40:05,770
funnel itself and try to minimize losses

00:40:02,920 --> 00:40:07,300
as people move down the funnel or you

00:40:05,770 --> 00:40:11,490
can put more people into the funnel of

00:40:07,300 --> 00:40:13,510
start with ideally you do both and

00:40:11,490 --> 00:40:15,700
that's the opportunity opportunity

00:40:13,510 --> 00:40:17,109
that's on the table here we have a world

00:40:15,700 --> 00:40:18,609
of people out there that look at their

00:40:17,109 --> 00:40:20,530
computers and phones and tablets and

00:40:18,609 --> 00:40:22,089
watches and set-top boxes as devices

00:40:20,530 --> 00:40:24,160
they use to passively consume content

00:40:22,089 --> 00:40:25,660
through apps that are developed by some

00:40:24,160 --> 00:40:28,690
sweaty white male boffin in the dark

00:40:25,660 --> 00:40:31,390
room we have an opportunity to break

00:40:28,690 --> 00:40:34,180
that mold not only make it easier for

00:40:31,390 --> 00:40:36,130
experts to develop apps but introduce a

00:40:34,180 --> 00:40:37,990
whole new audience to the idea that

00:40:36,130 --> 00:40:39,730
computing devices can be transformed to

00:40:37,990 --> 00:40:42,160
do what they want them to do to meet

00:40:39,730 --> 00:40:44,530
their specific needs there will always

00:40:42,160 --> 00:40:46,720
be a place for experts but this new

00:40:44,530 --> 00:40:47,859
adduced new audience isn't looking to do

00:40:46,720 --> 00:40:49,270
a three year degree in software

00:40:47,859 --> 00:40:51,220
engineering before they get started they

00:40:49,270 --> 00:40:52,660
want to learn one language and have that

00:40:51,220 --> 00:40:55,420
language be useful wherever they need to

00:40:52,660 --> 00:40:57,250
use it but if we're putting more people

00:40:55,420 --> 00:40:58,810
into the top of pythons conversion

00:40:57,250 --> 00:41:00,730
funnel we're also gonna get more people

00:40:58,810 --> 00:41:03,160
filtering down to the bottom and that

00:41:00,730 --> 00:41:05,619
means more experts and if we play our

00:41:03,160 --> 00:41:07,210
cards right a more diverse audience of

00:41:05,619 --> 00:41:09,339
experts not just sweaty my

00:41:07,210 --> 00:41:11,290
often sitting in dark rooms people from

00:41:09,339 --> 00:41:13,089
a wide range of social racial economic

00:41:11,290 --> 00:41:14,589
backgrounds with rich diverse

00:41:13,089 --> 00:41:16,060
experiences to bring to the discussion

00:41:14,589 --> 00:41:20,200
and shape the evolution of the world

00:41:16,060 --> 00:41:21,490
around us so why do I think python has a

00:41:20,200 --> 00:41:24,160
compelling case to be this first contact

00:41:21,490 --> 00:41:25,660
language well it would be really easy

00:41:24,160 --> 00:41:27,190
for me to launch into a blistering

00:41:25,660 --> 00:41:29,560
technical critique of JavaScript or

00:41:27,190 --> 00:41:31,930
Swift or Java and a defense of pythons

00:41:29,560 --> 00:41:33,970
technological superiority but I'm not

00:41:31,930 --> 00:41:35,230
going to do that firstly I don't think

00:41:33,970 --> 00:41:35,800
it adds anything to the discussion like

00:41:35,230 --> 00:41:38,290
it or not

00:41:35,800 --> 00:41:40,180
javascript Swift Java they all exist

00:41:38,290 --> 00:41:42,220
they're all in widespread use and their

00:41:40,180 --> 00:41:44,349
implementations are battle tested no

00:41:42,220 --> 00:41:46,720
amount of wailing about waatz are going

00:41:44,349 --> 00:41:47,980
to make javascript go away it's here

00:41:46,720 --> 00:41:50,020
it's going to stay

00:41:47,980 --> 00:41:52,599
and it's also pointless to have those

00:41:50,020 --> 00:41:54,640
arguments history has repeatedly shown

00:41:52,599 --> 00:41:56,740
us that technical superiority of a

00:41:54,640 --> 00:42:00,490
technology is very rarely enough to

00:41:56,740 --> 00:42:03,760
guarantee victory Betamax of VHS Windows

00:42:00,490 --> 00:42:05,470
and os/2 AC and DC electricity as long

00:42:03,760 --> 00:42:07,599
as there are two options that meet basic

00:42:05,470 --> 00:42:09,820
requirements the social structures and

00:42:07,599 --> 00:42:11,800
power relationships around a technology

00:42:09,820 --> 00:42:16,140
are much more important than the

00:42:11,800 --> 00:42:16,140
technology itself for ensuring success

00:42:16,680 --> 00:42:19,770
thank you

00:42:21,200 --> 00:42:25,860
the good news here is that python has a

00:42:24,300 --> 00:42:28,500
compelling story when it comes to these

00:42:25,860 --> 00:42:29,910
network effects firstly there is a huge

00:42:28,500 --> 00:42:31,800
breadth of domain knowledge that's

00:42:29,910 --> 00:42:34,170
encoded in Python through projects like

00:42:31,800 --> 00:42:36,270
numpy site by Jupiter biopython

00:42:34,170 --> 00:42:38,340
Astro PI there is a wealth of scientific

00:42:36,270 --> 00:42:40,230
expertise in our community raspberry pi

00:42:38,340 --> 00:42:42,720
grok Learning are leaders in the world

00:42:40,230 --> 00:42:44,850
of computing education this isn't just a

00:42:42,720 --> 00:42:46,860
web community or a browser community the

00:42:44,850 --> 00:42:48,900
attendance of this this conference the

00:42:46,860 --> 00:42:50,970
mini conferences on Friday are clear

00:42:48,900 --> 00:42:52,680
demonstrations of that and it will take

00:42:50,970 --> 00:42:54,750
but it will take a long time for other

00:42:52,680 --> 00:42:57,840
language communities to develop and now

00:42:54,750 --> 00:42:59,820
are just stalling the Platinum community

00:42:57,840 --> 00:43:01,170
also has very strong social credentials

00:42:59,820 --> 00:43:02,520
the Python community has been an

00:43:01,170 --> 00:43:03,960
industry leader in improving the

00:43:02,520 --> 00:43:05,940
participation of women and people of

00:43:03,960 --> 00:43:08,130
color different ethnic backgrounds into

00:43:05,940 --> 00:43:09,720
our tech communities Python and Django

00:43:08,130 --> 00:43:11,460
were amongst the first communities to

00:43:09,720 --> 00:43:13,680
offer us programming communities to

00:43:11,460 --> 00:43:15,690
adopt codes of conduct as standard

00:43:13,680 --> 00:43:17,400
operating procedure initiatives like pi

00:43:15,690 --> 00:43:18,570
ladies and Generals has made have made

00:43:17,400 --> 00:43:20,040
amazing contributions to the

00:43:18,570 --> 00:43:23,400
participation of women in our industry

00:43:20,040 --> 00:43:24,600
in web design circles it's taken a very

00:43:23,400 --> 00:43:26,190
long time to convince people that

00:43:24,600 --> 00:43:28,260
accessibility is something that's worth

00:43:26,190 --> 00:43:30,660
paying attention to but it turned out

00:43:28,260 --> 00:43:32,490
that if you focus on accessibility not

00:43:30,660 --> 00:43:34,830
only can the deaf and blind a neuro

00:43:32,490 --> 00:43:36,810
atypical access your website it improves

00:43:34,830 --> 00:43:39,690
the experience for everybody else as

00:43:36,810 --> 00:43:41,340
well there's a direct analog here with a

00:43:39,690 --> 00:43:43,800
social leadership position that Python

00:43:41,340 --> 00:43:45,450
has taken yes we have adopted codes of

00:43:43,800 --> 00:43:47,040
conduct because there is a there's a

00:43:45,450 --> 00:43:48,330
clear signal to women and minorities

00:43:47,040 --> 00:43:50,670
that we want our communities to be

00:43:48,330 --> 00:43:51,120
welcoming and friendly but as a side

00:43:50,670 --> 00:43:53,100
effect

00:43:51,120 --> 00:43:56,130
it means the community is nicer for

00:43:53,100 --> 00:43:58,380
everyone a code of conduct isn't there

00:43:56,130 --> 00:44:00,690
so that women can punish men it's there

00:43:58,380 --> 00:44:02,790
to make sure that everyone including the

00:44:00,690 --> 00:44:06,530
men have a pleasant experience in a

00:44:02,790 --> 00:44:06,530
welcoming and friendly community

00:44:10,810 --> 00:44:14,720
but before I give myself a sprain from

00:44:13,670 --> 00:44:18,410
patting us on the back quite so

00:44:14,720 --> 00:44:20,330
vigorously don't get me wrong there is

00:44:18,410 --> 00:44:21,440
still a long way to go if you compare

00:44:20,330 --> 00:44:23,210
where we work where we are today to

00:44:21,440 --> 00:44:26,090
where we were 10 or 15 years ago we've

00:44:23,210 --> 00:44:27,830
made some great strides I'd like to draw

00:44:26,090 --> 00:44:29,270
some attention though to two closely

00:44:27,830 --> 00:44:32,420
related areas that I think we need to

00:44:29,270 --> 00:44:33,980
pay a lot cause for attention to the

00:44:32,420 --> 00:44:36,020
first is the specter of burnout in our

00:44:33,980 --> 00:44:37,610
community I started this talk Richard

00:44:36,020 --> 00:44:39,230
started this morning talking about the

00:44:37,610 --> 00:44:41,150
fact of the bog of work on Python and

00:44:39,230 --> 00:44:44,120
Django with a result of volunteer

00:44:41,150 --> 00:44:45,740
efforts I've almost lost count of the

00:44:44,120 --> 00:44:47,900
number of talented developers around me

00:44:45,740 --> 00:44:50,600
who have burned out or come dangerously

00:44:47,900 --> 00:44:53,750
close under the load that's been imposed

00:44:50,600 --> 00:44:55,550
by this volunteer effort I've made no

00:44:53,750 --> 00:44:57,290
secret that I myself went through a

00:44:55,550 --> 00:45:01,370
major depressive episode last year

00:44:57,290 --> 00:45:04,190
brought on in part by the load imposed

00:45:01,370 --> 00:45:06,620
by volunteering I'm a lot better now but

00:45:04,190 --> 00:45:08,780
I've still got a long way to go this

00:45:06,620 --> 00:45:10,610
isn't a problem with an easy solution it

00:45:08,780 --> 00:45:11,900
isn't as simple as just telling someone

00:45:10,610 --> 00:45:13,790
they don't have to volunteer anymore

00:45:11,900 --> 00:45:15,740
because if they're in the maintainer of

00:45:13,790 --> 00:45:17,960
an even moderately successful project I

00:45:15,740 --> 00:45:19,730
guarantee you their inbox is filled with

00:45:17,960 --> 00:45:21,470
why haven't you fixed my bug emails

00:45:19,730 --> 00:45:25,370
sometimes from people who should know a

00:45:21,470 --> 00:45:27,860
lot better the greatest shocks in

00:45:25,370 --> 00:45:30,460
society occur when something we assume

00:45:27,860 --> 00:45:34,280
is plentiful and ubiquitous disappear

00:45:30,460 --> 00:45:36,530
petrol electricity clean water if your

00:45:34,280 --> 00:45:38,060
open source project isn't planning for

00:45:36,530 --> 00:45:40,610
the day when your biggest contributor

00:45:38,060 --> 00:45:43,880
steps down or is unable to continue your

00:45:40,610 --> 00:45:45,980
project has a clock on it as a community

00:45:43,880 --> 00:45:48,170
we need to institutionalize the

00:45:45,980 --> 00:45:50,000
minimization of the expectation of free

00:45:48,170 --> 00:45:51,410
labor if you've got a project role that

00:45:50,000 --> 00:45:54,590
is going to take resources be it

00:45:51,410 --> 00:45:56,570
material labor emotional energy don't

00:45:54,590 --> 00:45:59,780
assume those resources will be available

00:45:56,570 --> 00:46:01,220
forever in boundless quantities and if

00:45:59,780 --> 00:46:03,260
you're a free consumer of those

00:46:01,220 --> 00:46:05,690
resources be aware of what you're

00:46:03,260 --> 00:46:07,280
consuming if you're a commercial

00:46:05,690 --> 00:46:09,020
organization that depends on a product

00:46:07,280 --> 00:46:10,760
then and you aren't taking steps to

00:46:09,020 --> 00:46:12,680
contribute to contribute to the projects

00:46:10,760 --> 00:46:15,040
you use I would argue you're being

00:46:12,680 --> 00:46:17,480
criminally negligent to your investors

00:46:15,040 --> 00:46:17,960
because you haven't secured your supply

00:46:17,480 --> 00:46:20,270
chain

00:46:17,960 --> 00:46:23,740
you haven't mitigated a key risk

00:46:20,270 --> 00:46:26,090
associated with your technology stack

00:46:23,740 --> 00:46:27,830
but it's not just about pointing

00:46:26,090 --> 00:46:30,440
pointing fingers at bad projects or bad

00:46:27,830 --> 00:46:32,030
users or bad companies as a community we

00:46:30,440 --> 00:46:33,920
have established their conditions where

00:46:32,030 --> 00:46:36,320
companies are readily able to mitigate

00:46:33,920 --> 00:46:37,910
those risks the free software community

00:46:36,320 --> 00:46:39,110
has spent a lot of time and effort

00:46:37,910 --> 00:46:39,770
discussing the importance of user

00:46:39,110 --> 00:46:42,110
freedoms

00:46:39,770 --> 00:46:44,180
however there's been almost silent on

00:46:42,110 --> 00:46:46,760
the unintended consequences of that

00:46:44,180 --> 00:46:48,890
position but when free software is free

00:46:46,760 --> 00:46:50,780
as in freedom it is almost certainly

00:46:48,890 --> 00:46:52,430
free as in beer as well which means the

00:46:50,780 --> 00:46:55,610
task of making an income off of that

00:46:52,430 --> 00:46:57,440
software is much higher I don't want to

00:46:55,610 --> 00:46:59,510
understate for a moment the importance

00:46:57,440 --> 00:47:01,580
of user freedom but to focus on user

00:46:59,510 --> 00:47:03,530
freedom to the detriment of the mental

00:47:01,580 --> 00:47:05,290
and physical health of the developers of

00:47:03,530 --> 00:47:13,940
that software is in my opinion

00:47:05,290 --> 00:47:15,530
incredibly negligent how to make money

00:47:13,940 --> 00:47:17,270
from free software is a question that

00:47:15,530 --> 00:47:19,460
unfortunately doesn't have any good

00:47:17,270 --> 00:47:21,170
answers at the moment as a community we

00:47:19,460 --> 00:47:23,270
need to have a very serious discussion

00:47:21,170 --> 00:47:25,220
about the economic consequences of our

00:47:23,270 --> 00:47:27,200
decisions and how to harness the not

00:47:25,220 --> 00:47:30,070
insignificant resources that the

00:47:27,200 --> 00:47:32,480
software community has at its disposal

00:47:30,070 --> 00:47:35,120
the good news is that there's a possibly

00:47:32,480 --> 00:47:37,670
unexpected benefit to facing this

00:47:35,120 --> 00:47:39,440
problem head-on finding a way to pay for

00:47:37,670 --> 00:47:41,720
the resources we consume we're consuming

00:47:39,440 --> 00:47:43,220
certainly helps to stave off burnout but

00:47:41,720 --> 00:47:45,110
it has the added benefit that it

00:47:43,220 --> 00:47:48,500
broadens the list of people who can do

00:47:45,110 --> 00:47:50,690
the work volunteers by definition are

00:47:48,500 --> 00:47:53,270
made up by those who have the time to

00:47:50,690 --> 00:47:54,770
volunteer if you've got a family or

00:47:53,270 --> 00:47:57,290
you've got children or you've got a

00:47:54,770 --> 00:47:59,420
loved one who needs care those

00:47:57,290 --> 00:48:01,670
commitments take priority as well they

00:47:59,420 --> 00:48:03,890
should and they limit your ability to

00:48:01,670 --> 00:48:06,020
volunteer you want to address diversity

00:48:03,890 --> 00:48:07,820
make sure that you're not just taking

00:48:06,020 --> 00:48:10,700
from the pool of people who have copious

00:48:07,820 --> 00:48:12,170
free time which broadly speaking means

00:48:10,700 --> 00:48:13,880
white middle doing middle to upper-class

00:48:12,170 --> 00:48:17,270
anglo-saxon men aged sixteen to thirty

00:48:13,880 --> 00:48:20,300
if you're someone who uses open-source

00:48:17,270 --> 00:48:21,710
don't just take give back in tangible

00:48:20,300 --> 00:48:23,750
ways either with hard commitments of

00:48:21,710 --> 00:48:25,220
time or with cash that organizations

00:48:23,750 --> 00:48:26,930
like the Python Software Foundation or

00:48:25,220 --> 00:48:29,390
the Django Software Foundation can use

00:48:26,930 --> 00:48:30,860
and this is incredibly important if you

00:48:29,390 --> 00:48:32,630
are a large organization with

00:48:30,860 --> 00:48:35,060
extraordinary resources at your disposal

00:48:32,630 --> 00:48:36,140
who derive immense benefit from open

00:48:35,060 --> 00:48:40,400
source and Valen

00:48:36,140 --> 00:48:41,990
projects now you'll notice that in this

00:48:40,400 --> 00:48:44,150
talk I've spent almost as much time

00:48:41,990 --> 00:48:46,280
talking about the soft for one of a much

00:48:44,150 --> 00:48:48,770
better word aspects of the problem we

00:48:46,280 --> 00:48:51,350
face rather versus the hard technical

00:48:48,770 --> 00:48:53,510
problems the technical aspects of a

00:48:51,350 --> 00:48:55,370
computing problem almost always get the

00:48:53,510 --> 00:48:57,140
most attention but they're also the

00:48:55,370 --> 00:48:59,960
easiest ones to solve they either have

00:48:57,140 --> 00:49:02,180
an answer or they don't but open source

00:48:59,960 --> 00:49:04,100
projects are ultimately about

00:49:02,180 --> 00:49:06,800
communities of people with aligned

00:49:04,100 --> 00:49:08,860
interests acting collectively this means

00:49:06,800 --> 00:49:11,480
issues of communication collaboration

00:49:08,860 --> 00:49:14,720
identity social justice inclusivity

00:49:11,480 --> 00:49:16,460
funding these are all intertwined with

00:49:14,720 --> 00:49:19,700
the technical aspects because without

00:49:16,460 --> 00:49:22,430
those soft aspects the technical aspects

00:49:19,700 --> 00:49:24,800
can't be solved and these challenges

00:49:22,430 --> 00:49:28,760
don't have simple answers who would have

00:49:24,800 --> 00:49:29,990
thought humans are difficult this is

00:49:28,760 --> 00:49:31,850
something that has taken the tech

00:49:29,990 --> 00:49:33,620
community a long time to learn we've

00:49:31,850 --> 00:49:34,790
still got 20 we have to learn and it's

00:49:33,620 --> 00:49:37,280
going to take a long time to

00:49:34,790 --> 00:49:38,660
institutionalize best practices the key

00:49:37,280 --> 00:49:40,490
though is to pay attention to it

00:49:38,660 --> 00:49:42,260
whatever software community or

00:49:40,490 --> 00:49:44,480
communities you have to participate in

00:49:42,260 --> 00:49:46,880
keep your ears open your mouth shut and

00:49:44,480 --> 00:49:50,000
look for ways to improve the social

00:49:46,880 --> 00:49:51,440
aspects of your project and part of that

00:49:50,000 --> 00:49:53,120
means acknowledging any kind of

00:49:51,440 --> 00:49:55,400
privilege you have when I say that I

00:49:53,120 --> 00:49:57,920
don't just mean white men either women

00:49:55,400 --> 00:50:00,410
can have privilege too so can people of

00:49:57,920 --> 00:50:02,000
color if you don't believe me go have a

00:50:00,410 --> 00:50:04,400
look on YouTube for saranya barracks

00:50:02,000 --> 00:50:06,230
keynote talk from django con u.s.a a

00:50:04,400 --> 00:50:07,880
black woman from the united states she

00:50:06,230 --> 00:50:09,530
gives a much better explanation than i

00:50:07,880 --> 00:50:13,400
could ever provide about what privilege

00:50:09,530 --> 00:50:15,110
truly is so what does the future hold

00:50:13,400 --> 00:50:17,090
for python well I don't know I've

00:50:15,110 --> 00:50:18,650
outlined what I see to be the threats

00:50:17,090 --> 00:50:21,980
and opportunities but I am only one

00:50:18,650 --> 00:50:23,750
voice but I do know that if we want

00:50:21,980 --> 00:50:25,460
Python to continue to be a force in the

00:50:23,750 --> 00:50:27,170
world of computing we can't stand still

00:50:25,460 --> 00:50:29,290
we need to prepare for the future

00:50:27,170 --> 00:50:31,400
whatever we perceive that future to be

00:50:29,290 --> 00:50:32,930
personally I'm intending to keep working

00:50:31,400 --> 00:50:35,090
on Beware the umbrella project that

00:50:32,930 --> 00:50:36,650
covers Vulcan Batavia robe you a robust

00:50:35,090 --> 00:50:38,480
briefcase and many other tools that are

00:50:36,650 --> 00:50:40,010
necessary to get Python working in the

00:50:38,480 --> 00:50:41,330
hands of end-users and to enable those

00:50:40,010 --> 00:50:43,250
users to get involved in writing their

00:50:41,330 --> 00:50:44,600
own apps any of those projects sound

00:50:43,250 --> 00:50:46,460
interesting you'd like to get involved I

00:50:44,600 --> 00:50:48,650
appreciate any help there's plenty to do

00:50:46,460 --> 00:50:49,930
and I've got an open offer to mentor

00:50:48,650 --> 00:50:51,039
anybody who wants to get in

00:50:49,930 --> 00:50:52,599
even if this is your first time

00:50:51,039 --> 00:50:55,180
contributing to open source projects and

00:50:52,599 --> 00:50:57,880
again the challenge coin for anybody who

00:50:55,180 --> 00:50:59,559
does get involved a call to action

00:50:57,880 --> 00:51:02,410
without funding this is going to

00:50:59,559 --> 00:51:03,970
continue to be a hobby project I'd like

00:51:02,410 --> 00:51:06,369
to see it to become a whole lot more I'd

00:51:03,970 --> 00:51:08,619
like to see beware become a model for a

00:51:06,369 --> 00:51:10,299
new style of financially viable but also

00:51:08,619 --> 00:51:12,490
socially responsible open source

00:51:10,299 --> 00:51:14,020
organization I am currently exploring

00:51:12,490 --> 00:51:16,450
options to make this happen one of those

00:51:14,020 --> 00:51:18,010
options is to crowdfund if you'd like to

00:51:16,450 --> 00:51:19,539
be notified as those plans evolve I'd

00:51:18,010 --> 00:51:21,670
encourage you to visit this URL sign up

00:51:19,539 --> 00:51:23,049
for the announcement list there if

00:51:21,670 --> 00:51:25,270
you're a company with an interest in

00:51:23,049 --> 00:51:27,069
cross-platform mobile sign up the

00:51:25,270 --> 00:51:28,869
mailing list or contact me directly I'm

00:51:27,069 --> 00:51:30,789
certainly open to the idea of commercial

00:51:28,869 --> 00:51:34,000
sponsorship and various arrangements so

00:51:30,789 --> 00:51:35,890
come talk to me all of this ultimately

00:51:34,000 --> 00:51:38,980
comes down to the old quote from Pascal

00:51:35,890 --> 00:51:40,960
fortune favors the prepared mind if you

00:51:38,980 --> 00:51:42,609
want any project to be successful or

00:51:40,960 --> 00:51:46,089
remain successful you need to plan for

00:51:42,609 --> 00:51:48,910
that success it took years for Python to

00:51:46,089 --> 00:51:50,529
become an overnight success django

00:51:48,910 --> 00:51:51,819
certainly benefited from some early

00:51:50,529 --> 00:51:54,270
momentum being in the right place at the

00:51:51,819 --> 00:51:56,500
right time but true success took years I

00:51:54,270 --> 00:51:58,930
have personally benefited from being

00:51:56,500 --> 00:52:01,029
part of a large successful project like

00:51:58,930 --> 00:52:02,349
Django I'm at the early stages of what I

00:52:01,029 --> 00:52:04,420
hope will be a similar journey with

00:52:02,349 --> 00:52:05,740
beware and both of those projects

00:52:04,420 --> 00:52:07,270
wouldn't have been possible or at least

00:52:05,740 --> 00:52:08,890
would have been significantly different

00:52:07,270 --> 00:52:10,329
if it wasn't for the groundwork that was

00:52:08,890 --> 00:52:12,760
laid out by Python and the Python

00:52:10,329 --> 00:52:14,740
community I'm very keen to make sure

00:52:12,760 --> 00:52:17,500
that groundwork doesn't go away it's

00:52:14,740 --> 00:52:18,910
taken 25 years to develop it and it

00:52:17,500 --> 00:52:21,010
would be a shame if we had to develop it

00:52:18,910 --> 00:52:22,359
all over again simply because we didn't

00:52:21,010 --> 00:52:25,839
pay attention to the way the world was

00:52:22,359 --> 00:52:29,730
changing around us and with that thank

00:52:25,839 --> 00:52:29,730
you very much I'd like to thank Richard

00:52:51,700 --> 00:52:53,760

YouTube URL: https://www.youtube.com/watch?v=1sDyVJm3Ht0


