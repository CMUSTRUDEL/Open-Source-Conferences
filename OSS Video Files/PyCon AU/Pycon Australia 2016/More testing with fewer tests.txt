Title: More testing with fewer tests
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Clinton Roy
https://2016.pycon-au.org/schedule/188/view_talk
We all wish we were were testing more, but tests are ugly, a pain to write and are brittle. Property based testing helps to solve all of these problems. Now, with Hypothesis, Python has an outstanding toolkit to write property based tests. 

With Hypothesis, instead of writing individual tests, you describe properties of your code and Hypothesis generates the test cases for you. This frees you from writing repetitive and error prone test cases. Hypothesis will generate many more test cases than you'll ever be able to bare writing, and will find more bugs.

Hypothesis has plugins for Django and numpy to help you generate test cases for these two frameworks.
Captions: 
	00:00:00,000 --> 00:00:03,899
all right welcome back everybody second

00:00:02,639 --> 00:00:06,029
talk for the afternoon session in here

00:00:03,899 --> 00:00:08,639
with Clinton Rory who is an open source

00:00:06,029 --> 00:00:10,800
engineer at netbox blue we organize Pike

00:00:08,639 --> 00:00:13,230
on a you in Brisbane in 2014 and 2015

00:00:10,800 --> 00:00:14,400
and loves people this is more testing

00:00:13,230 --> 00:00:25,080
with fewer tests he's make him feel

00:00:14,400 --> 00:00:27,570
welcome so good afternoon everyone I am

00:00:25,080 --> 00:00:30,480
probably most well known to you folks is

00:00:27,570 --> 00:00:32,669
the organizer of last year's PyCon and

00:00:30,480 --> 00:00:34,200
the year before that up in Brisbane

00:00:32,669 --> 00:00:36,030
it's very nice being able to give a talk

00:00:34,200 --> 00:00:40,100
and not also being the organizer of the

00:00:36,030 --> 00:00:43,410
conference ask us for us all about that

00:00:40,100 --> 00:00:45,719
so my talk today is on a lovely

00:00:43,410 --> 00:00:49,170
framework slash library called

00:00:45,719 --> 00:00:51,690
hypothesis it's not my work I'm probably

00:00:49,170 --> 00:00:53,370
the biggest fan of it but I just want to

00:00:51,690 --> 00:00:54,149
make it really clear it is someone

00:00:53,370 --> 00:00:57,420
else's work

00:00:54,149 --> 00:00:58,890
David McIver I do give him full credit

00:00:57,420 --> 00:01:01,590
at the end but I definitely wanted to

00:00:58,890 --> 00:01:03,690
make that clear up front it is a lovely

00:01:01,590 --> 00:01:07,229
library for helping you automate some

00:01:03,690 --> 00:01:10,770
parts of your testing we all know that

00:01:07,229 --> 00:01:14,990
we should do more testing but writing

00:01:10,770 --> 00:01:19,890
test cases is laborious its repetitive

00:01:14,990 --> 00:01:23,549
and it's because it's repetitive and

00:01:19,890 --> 00:01:27,299
boring it's very easy to miss corner

00:01:23,549 --> 00:01:29,670
cases and regular cases that you need to

00:01:27,299 --> 00:01:37,170
be testing hypotheses can help with some

00:01:29,670 --> 00:01:39,960
of this so we've got sort of three main

00:01:37,170 --> 00:01:42,750
parts of the talk I'll quickly go over

00:01:39,960 --> 00:01:45,509
basic unit testing I'll quickly go over

00:01:42,750 --> 00:01:48,270
property based testing so property based

00:01:45,509 --> 00:01:50,189
testing is a language agnostic term for

00:01:48,270 --> 00:01:53,310
the style of testing that hypothesis

00:01:50,189 --> 00:01:55,560
allows you to do a really interesting

00:01:53,310 --> 00:01:58,439
feature that hypothesis has is

00:01:55,560 --> 00:02:02,700
state-based testing so it's a step

00:01:58,439 --> 00:02:05,009
further than property based testing and

00:02:02,700 --> 00:02:07,740
then I'll go into if we probably won't

00:02:05,009 --> 00:02:09,259
have any time to go into details but

00:02:07,740 --> 00:02:11,700
there's some really interesting stuff

00:02:09,259 --> 00:02:15,440
coming up in the further readings that

00:02:11,700 --> 00:02:15,440
I'll touch on at the end

00:02:15,830 --> 00:02:22,319
so you've written a function you need to

00:02:19,080 --> 00:02:25,770
test it so you write a test case you run

00:02:22,319 --> 00:02:28,260
the test it passes or it fails and then

00:02:25,770 --> 00:02:33,930
you do it that again and again and again

00:02:28,260 --> 00:02:36,150
and again and again so you want to spend

00:02:33,930 --> 00:02:39,180
your time writing the code that solves

00:02:36,150 --> 00:02:40,260
the problem or adds the feature because

00:02:39,180 --> 00:02:42,840
that's the fun bit that's the

00:02:40,260 --> 00:02:44,970
interesting bit you don't want to spend

00:02:42,840 --> 00:02:51,959
time writing your test cases because

00:02:44,970 --> 00:02:54,200
that's the boring bit there are two sort

00:02:51,959 --> 00:02:57,120
of basic test cases that you're writing

00:02:54,200 --> 00:02:59,940
you're writing your corner cases so this

00:02:57,120 --> 00:03:02,880
is these are your people

00:02:59,940 --> 00:03:06,090
cases where your users put in weird

00:03:02,880 --> 00:03:08,340
wacky things into your code that you

00:03:06,090 --> 00:03:09,780
would never think that they would but

00:03:08,340 --> 00:03:13,440
they do because they're people and

00:03:09,780 --> 00:03:14,880
people are really good at peopling I've

00:03:13,440 --> 00:03:19,140
been at the registration desk all week

00:03:14,880 --> 00:03:20,989
so so there's the corner cases the

00:03:19,140 --> 00:03:24,450
special cases that you have to check and

00:03:20,989 --> 00:03:28,049
once you've done a fair bit of unit

00:03:24,450 --> 00:03:30,360
testing you know off by heart what a lot

00:03:28,049 --> 00:03:32,430
of these corner cases are so you're

00:03:30,360 --> 00:03:35,579
dealing with quantities so you test the

00:03:32,430 --> 00:03:37,110
zero case the one case the mini case and

00:03:35,579 --> 00:03:39,329
you might put in a minus one or

00:03:37,110 --> 00:03:41,430
something like that to test that if

00:03:39,329 --> 00:03:43,500
you're dealing with strings you've got a

00:03:41,430 --> 00:03:44,880
function that takes a string so you put

00:03:43,500 --> 00:03:46,290
in the empty string you'll put in a

00:03:44,880 --> 00:03:47,820
string with just whitespace you're

00:03:46,290 --> 00:03:50,180
putting in a regular string with like

00:03:47,820 --> 00:03:53,670
one or two unicode characters in it

00:03:50,180 --> 00:03:55,920
everyone knows these rules they're not

00:03:53,670 --> 00:03:57,690
codified so it means that when you're

00:03:55,920 --> 00:04:00,440
writing a test case to call these

00:03:57,690 --> 00:04:02,820
functions every programmer on the planet

00:04:00,440 --> 00:04:06,540
instead of automating something that

00:04:02,820 --> 00:04:08,959
could be automated is basically learning

00:04:06,540 --> 00:04:11,130
these things over and over again and

00:04:08,959 --> 00:04:13,530
manually doing the same work over and

00:04:11,130 --> 00:04:16,459
over again and I don't need to tell

00:04:13,530 --> 00:04:16,459
anyone but that's silly

00:04:19,549 --> 00:04:26,080
so just as a first example to get us

00:04:25,190 --> 00:04:30,949
started

00:04:26,080 --> 00:04:34,430
a simple little function to generate the

00:04:30,949 --> 00:04:36,770
average of a list of integers there is a

00:04:34,430 --> 00:04:39,919
fair bit of code in this talk I don't

00:04:36,770 --> 00:04:44,479
want to get too hung up on the code it's

00:04:39,919 --> 00:04:50,030
just that I need to give some example so

00:04:44,479 --> 00:04:52,789
that we have some place to work from so

00:04:50,030 --> 00:04:54,919
I've tried to make it as simple as

00:04:52,789 --> 00:04:58,159
possible I've tried to use nice long

00:04:54,919 --> 00:04:59,630
variable names that easy to read and

00:04:58,159 --> 00:05:03,710
understand that most of my workmates

00:04:59,630 --> 00:05:05,720
will probably shoot me for so who just

00:05:03,710 --> 00:05:08,990
just as a quick hands up who can spot a

00:05:05,720 --> 00:05:10,490
problem with that code and it might be

00:05:08,990 --> 00:05:15,219
something to do with like the length of

00:05:10,490 --> 00:05:15,219
the input string being 0 that's all good

00:05:15,530 --> 00:05:20,360
instead of met instead of us knowing

00:05:17,449 --> 00:05:22,370
about that in really complicated code

00:05:20,360 --> 00:05:24,409
like in this simple case that's a pretty

00:05:22,370 --> 00:05:26,990
clear thing that's wrong with it but in

00:05:24,409 --> 00:05:29,509
complicated code it's not always obvious

00:05:26,990 --> 00:05:31,039
where the corner cases are the corner

00:05:29,509 --> 00:05:34,069
case for some of your code if it's

00:05:31,039 --> 00:05:36,050
accepting multiple arguments it might be

00:05:34,069 --> 00:05:37,370
some weirdo combination of those

00:05:36,050 --> 00:05:45,050
arguments that you've never even thought

00:05:37,370 --> 00:05:48,979
of so a very rough test case for this

00:05:45,050 --> 00:05:51,729
that you might handwrite is you call

00:05:48,979 --> 00:05:55,009
your function you get the result back

00:05:51,729 --> 00:05:56,930
the important point here is that we've

00:05:55,009 --> 00:05:58,550
hand written the inputs to it so the

00:05:56,930 --> 00:06:01,159
list of integers 1 2 3

00:05:58,550 --> 00:06:03,800
we've hand worked out the output which

00:06:01,159 --> 00:06:06,500
is 2 and then because floating-point is

00:06:03,800 --> 00:06:08,389
fun we've had to make sure that the

00:06:06,500 --> 00:06:12,650
result is roughly close to what we

00:06:08,389 --> 00:06:15,440
expect and this is not a floating-point

00:06:12,650 --> 00:06:16,880
talk so I don't want any questions about

00:06:15,440 --> 00:06:19,610
the whole floating point absolute

00:06:16,880 --> 00:06:25,880
position thing just shutting that down

00:06:19,610 --> 00:06:30,889
right now so probably property based

00:06:25,880 --> 00:06:33,320
testing you run at the same test code a

00:06:30,889 --> 00:06:37,070
thousand times ten thousand times

00:06:33,320 --> 00:06:40,970
hundred thousand times hypothesis will

00:06:37,070 --> 00:06:45,080
generate a different test inputs for

00:06:40,970 --> 00:06:50,300
each run it will verify properties of

00:06:45,080 --> 00:06:54,370
the output against the input for you so

00:06:50,300 --> 00:06:54,370
to make that a little bit more concrete

00:06:54,490 --> 00:06:58,760
yeah obviously you write the code I

00:06:56,750 --> 00:07:00,500
didn't put that in the workflow here

00:06:58,760 --> 00:07:03,080
that's a little bit obvious you write

00:07:00,500 --> 00:07:07,760
your code you write your properties the

00:07:03,080 --> 00:07:11,480
properties map from your inputs to your

00:07:07,760 --> 00:07:14,120
outputs hypothesis generates the test

00:07:11,480 --> 00:07:17,870
data for you you run your tests as

00:07:14,120 --> 00:07:19,580
normal so hypothesis has all the plugins

00:07:17,870 --> 00:07:22,100
and hooks so that you can run it with

00:07:19,580 --> 00:07:26,300
unit tests with PI test with nose with

00:07:22,100 --> 00:07:28,250
whatever favorite Python unit test

00:07:26,300 --> 00:07:32,570
framework you're running at the moment

00:07:28,250 --> 00:07:36,170
it will work with all of those and of

00:07:32,570 --> 00:07:38,330
course the other part of testing with

00:07:36,170 --> 00:07:40,640
all of these sort of tests with unit

00:07:38,330 --> 00:07:42,170
tests or property tests is that you look

00:07:40,640 --> 00:07:44,750
at your code coverage after you've run

00:07:42,170 --> 00:07:46,820
your tests because it's going to show

00:07:44,750 --> 00:07:50,240
you those branches of code that you

00:07:46,820 --> 00:07:51,770
haven't tested I'm not going to go into

00:07:50,240 --> 00:07:56,090
code coverage here that's a whole

00:07:51,770 --> 00:07:58,430
separate talk hypothesis generates test

00:07:56,090 --> 00:08:00,410
cases for you you still have to write

00:07:58,430 --> 00:08:06,130
the properties so it's very possible

00:08:00,410 --> 00:08:11,090
that you you are not going to write

00:08:06,130 --> 00:08:13,130
strong enough properties for your strong

00:08:11,090 --> 00:08:16,130
enough properties for your inputs and

00:08:13,130 --> 00:08:18,140
outputs mappings you still need to think

00:08:16,130 --> 00:08:19,880
really carefully about your testing and

00:08:18,140 --> 00:08:23,600
the thing that I sort of like about

00:08:19,880 --> 00:08:25,970
hypothesis is that when you go into a

00:08:23,600 --> 00:08:29,120
unit test mode and you're just sitting

00:08:25,970 --> 00:08:32,260
there randomly generating inputs and

00:08:29,120 --> 00:08:35,030
outputs your brain sort of goes into

00:08:32,260 --> 00:08:37,849
automatic and you stop thinking about

00:08:35,030 --> 00:08:39,890
things hypotheses in a certain respect

00:08:37,849 --> 00:08:41,810
is actually harder to write tests for

00:08:39,890 --> 00:08:44,960
because you've got to think really

00:08:41,810 --> 00:08:46,250
carefully about the mapping between your

00:08:44,960 --> 00:08:50,029
inputs and your outputs

00:08:46,250 --> 00:08:53,990
the properties that define your code it

00:08:50,029 --> 00:08:56,629
takes away the drudgery and it's the

00:08:53,990 --> 00:08:59,720
actual problem of writing describing all

00:08:56,629 --> 00:09:02,449
of your test cases is much much harder

00:08:59,720 --> 00:09:05,870
than writing a hundreds you know

00:09:02,449 --> 00:09:08,480
individual unit tests this doesn't take

00:09:05,870 --> 00:09:11,060
away from thinking it doesn't make it

00:09:08,480 --> 00:09:12,800
doesn't make writing test cases easier

00:09:11,060 --> 00:09:20,569
in a certain respect it makes writing

00:09:12,800 --> 00:09:25,220
harder so this is our first introduction

00:09:20,569 --> 00:09:30,279
to a hypothesis test the import at the

00:09:25,220 --> 00:09:35,240
top for given given is the main API

00:09:30,279 --> 00:09:40,069
function to work with hypothesis you use

00:09:35,240 --> 00:09:44,420
it mostly here as a decorator and that's

00:09:40,069 --> 00:09:46,040
how it's mostly used the other part of

00:09:44,420 --> 00:09:50,209
hypothesis that you'll be using all the

00:09:46,040 --> 00:09:55,660
time are the strategies the strategies

00:09:50,209 --> 00:09:58,879
are the codified knowledge of all of the

00:09:55,660 --> 00:10:03,139
general cases and special cases for all

00:09:58,879 --> 00:10:05,839
the data types so for integers for

00:10:03,139 --> 00:10:08,389
example when you ask hypotheses to

00:10:05,839 --> 00:10:10,250
generate test cases of integers it will

00:10:08,389 --> 00:10:14,540
go through all of the usual corner cases

00:10:10,250 --> 00:10:18,050
it'll do the 0 the 1 the -1 the to the

00:10:14,540 --> 00:10:21,620
20 the 40,000 it's got all of the stuff

00:10:18,050 --> 00:10:24,139
that we know that we have to check and

00:10:21,620 --> 00:10:26,149
instead of manually going through the

00:10:24,139 --> 00:10:29,089
corner cases in the general cases it's

00:10:26,149 --> 00:10:33,589
got that codified and the same thing

00:10:29,089 --> 00:10:35,930
with lists it'll check it'll generate

00:10:33,589 --> 00:10:37,759
the test case with an empty list with

00:10:35,930 --> 00:10:44,509
one thing in it with a few things in it

00:10:37,759 --> 00:10:46,910
with a bucketload of things in it so so

00:10:44,509 --> 00:10:51,800
what we're asking hypotheses to do here

00:10:46,910 --> 00:10:54,819
is generate a list of integers and what

00:10:51,800 --> 00:10:57,589
will actually happen here is that that

00:10:54,819 --> 00:11:00,170
decorator there will run the test

00:10:57,589 --> 00:11:02,660
average function depending on

00:11:00,170 --> 00:11:06,350
configured hypothesis it could run it a

00:11:02,660 --> 00:11:08,510
hundred times or a thousand times I'll

00:11:06,350 --> 00:11:12,380
come back to this a little bit later but

00:11:08,510 --> 00:11:14,960
on your development laptop it'll maybe

00:11:12,380 --> 00:11:17,420
generate like a thousand test cases on

00:11:14,960 --> 00:11:20,180
your continuous integration service

00:11:17,420 --> 00:11:22,010
that's running overnight you can set a

00:11:20,180 --> 00:11:27,340
few flags on a hypothesis and it will

00:11:22,010 --> 00:11:30,680
generate a million test cases so it will

00:11:27,340 --> 00:11:33,560
work within whatever workflow you're

00:11:30,680 --> 00:11:38,720
using and it's very easy to set up those

00:11:33,560 --> 00:11:41,060
different modes so we are calling our

00:11:38,720 --> 00:11:44,660
function the property that I've chosen

00:11:41,060 --> 00:11:46,580
here to test is that the average sits

00:11:44,660 --> 00:11:51,200
between the minimum and maximum of our

00:11:46,580 --> 00:11:56,330
list so I asked if there was a problem

00:11:51,200 --> 00:12:00,680
with the average code before and

00:11:56,330 --> 00:12:03,380
hypothesis finds it so this so I've run

00:12:00,680 --> 00:12:05,240
a run protest and this is like the

00:12:03,380 --> 00:12:07,880
bottom 10 lines of that because there's

00:12:05,240 --> 00:12:11,480
a lot of stuff right at the bottom

00:12:07,880 --> 00:12:14,720
you'll see the actual example that have

00:12:11,480 --> 00:12:18,530
failed with so the lists strategy

00:12:14,720 --> 00:12:22,870
generated an empty list and the test

00:12:18,530 --> 00:12:26,210
function raised division by zero error

00:12:22,870 --> 00:12:28,340
so that is the style of output that

00:12:26,210 --> 00:12:30,170
you'll get with hypothesis it basically

00:12:28,340 --> 00:12:32,390
is sitting there generating all these

00:12:30,170 --> 00:12:37,070
test cases running them and if one of

00:12:32,390 --> 00:12:38,390
them fails it'll let you know and if

00:12:37,070 --> 00:12:42,290
anyone's got any questions at any point

00:12:38,390 --> 00:12:43,580
in time to shoot up the hints and I'll

00:12:42,290 --> 00:12:50,710
repeat because I don't like the

00:12:43,580 --> 00:12:55,640
microphone thing so when you're

00:12:50,710 --> 00:12:59,330
generating test cases for real code your

00:12:55,640 --> 00:13:02,870
code will have lots of limitations on

00:12:59,330 --> 00:13:06,050
the inputs that it can handle and in

00:13:02,870 --> 00:13:10,190
this case we wouldn't write a hypothesis

00:13:06,050 --> 00:13:12,920
test to check for the empty list case we

00:13:10,190 --> 00:13:16,850
would write a standard unit to test

00:13:12,920 --> 00:13:20,500
to say if you pass the empty list long

00:13:16,850 --> 00:13:23,120
it'll raise some sort of value exception

00:13:20,500 --> 00:13:26,480
so to get around this we have to tell

00:13:23,120 --> 00:13:30,290
hypothesis generate me a bunch of lists

00:13:26,480 --> 00:13:32,620
of integers but as you can see with them

00:13:30,290 --> 00:13:35,389
in size arguments on line six they're

00:13:32,620 --> 00:13:40,220
all of the lists that you generate have

00:13:35,389 --> 00:13:41,750
to have at least one element now I said

00:13:40,220 --> 00:13:44,690
this wasn't a floating point talk i

00:13:41,750 --> 00:13:47,440
mighta lied because as soon as you use

00:13:44,690 --> 00:13:53,720
floating points the corner cases

00:13:47,440 --> 00:13:55,459
infinite so this is the second run with

00:13:53,720 --> 00:13:58,339
hypothesis we've told it to generate

00:13:55,459 --> 00:14:04,360
lists of at least one element now and

00:13:58,339 --> 00:14:07,370
what's happened here is that python has

00:14:04,360 --> 00:14:08,959
cast our floating point number to an

00:14:07,370 --> 00:14:10,430
integer before it's done the assertions

00:14:08,959 --> 00:14:12,620
because we've got an integer and it's

00:14:10,430 --> 00:14:14,870
trying to compare that to a float it's

00:14:12,620 --> 00:14:16,430
done the cast and if you have a look at

00:14:14,870 --> 00:14:18,410
the very last digit you'll see that that

00:14:16,430 --> 00:14:24,740
cast hasn't quite gone the way we wanted

00:14:18,410 --> 00:14:26,930
to so the thing here is the reason that

00:14:24,740 --> 00:14:30,199
hypothesis has chosen that extraordinary

00:14:26,930 --> 00:14:32,899
large number is because it knows where

00:14:30,199 --> 00:14:35,680
the cast goes wrong so there's a whole

00:14:32,899 --> 00:14:39,560
bunch of floating-point cases where

00:14:35,680 --> 00:14:42,230
things get really funky and hypothesis

00:14:39,560 --> 00:14:48,019
even though we weren't asking for floats

00:14:42,230 --> 00:14:49,790
we were using int because anytime you do

00:14:48,019 --> 00:14:52,820
math code you could be generating it's

00:14:49,790 --> 00:14:55,730
one of the corner cases that hypothesis

00:14:52,820 --> 00:14:57,260
uses is all of the integer values for

00:14:55,730 --> 00:15:01,940
the floating point values that python

00:14:57,260 --> 00:15:04,790
has issues with so it's just another

00:15:01,940 --> 00:15:06,860
codified form of all of those weird

00:15:04,790 --> 00:15:10,579
special cases that we don't even know

00:15:06,860 --> 00:15:12,709
about like the the the the corner cases

00:15:10,579 --> 00:15:18,769
for floating-point is a talk all on its

00:15:12,709 --> 00:15:21,230
own so here we've just done the float

00:15:18,769 --> 00:15:24,649
call ourselves which means that it's

00:15:21,230 --> 00:15:26,870
going to map properly so the only change

00:15:24,649 --> 00:15:28,490
here is on our prop

00:15:26,870 --> 00:15:35,990
we've just done the float called

00:15:28,490 --> 00:15:39,920
ourselves and now we have no failures so

00:15:35,990 --> 00:15:42,620
what does that mean it means that for

00:15:39,920 --> 00:15:48,460
this run all of the test cases that

00:15:42,620 --> 00:15:52,400
hypothesis generated past our property

00:15:48,460 --> 00:15:54,200
so the problem here is that hypothesis

00:15:52,400 --> 00:15:57,230
because it's randomly generating some of

00:15:54,200 --> 00:15:59,150
these test cases every time you run it

00:15:57,230 --> 00:16:03,529
it will come up with different test

00:15:59,150 --> 00:16:05,390
cases now there are ways around that so

00:16:03,529 --> 00:16:06,710
if you've got a if you've got a bug

00:16:05,390 --> 00:16:08,300
report that comes in and there's a

00:16:06,710 --> 00:16:11,050
particular set of values that causes

00:16:08,300 --> 00:16:14,210
issues you can specifically say

00:16:11,050 --> 00:16:16,580
hypothesis this is an example and it's

00:16:14,210 --> 00:16:19,010
at example this is a test case that I

00:16:16,580 --> 00:16:20,630
know fails and I want to test this every

00:16:19,010 --> 00:16:22,900
time because we fixed a particular bug

00:16:20,630 --> 00:16:27,560
about that so you can do that easily and

00:16:22,900 --> 00:16:29,630
also on your CI machines you might want

00:16:27,560 --> 00:16:32,450
to generate tens of thousands of test

00:16:29,630 --> 00:16:34,400
cases you can generate them once save

00:16:32,450 --> 00:16:36,170
them and then every night instead of

00:16:34,400 --> 00:16:37,880
getting hypotheses to generate new test

00:16:36,170 --> 00:16:42,980
cases it'll you can just get it to run

00:16:37,880 --> 00:16:45,290
the old test cases so the other point

00:16:42,980 --> 00:16:47,690
here is that our property is pretty weak

00:16:45,290 --> 00:16:50,120
we're not actually testing that our

00:16:47,690 --> 00:16:54,020
average is near what the average should

00:16:50,120 --> 00:16:55,870
be we're just testing that our average

00:16:54,020 --> 00:16:58,250
is between the minimum and the maximum

00:16:55,870 --> 00:17:00,890
so the point that I wanted to try and

00:16:58,250 --> 00:17:03,860
get across there is that it can be hard

00:17:00,890 --> 00:17:10,459
to do to write properties you do have to

00:17:03,860 --> 00:17:12,620
have you thinking cap on so hypothesis

00:17:10,459 --> 00:17:15,199
generates tens of thousands of test

00:17:12,620 --> 00:17:19,100
cases if you let it and this is a subset

00:17:15,199 --> 00:17:23,959
of the test cases that it's generated so

00:17:19,100 --> 00:17:25,640
a minimum size of one it's got a couple

00:17:23,959 --> 00:17:27,050
of minus ones in there it's got some

00:17:25,640 --> 00:17:30,350
very big numbers in there it's got some

00:17:27,050 --> 00:17:32,720
very small numbers in there that's just

00:17:30,350 --> 00:17:34,610
as a flavor you can definitely run

00:17:32,720 --> 00:17:36,410
hypothesis in verbose mode and see all

00:17:34,610 --> 00:17:38,540
the test cases and it's very cool for

00:17:36,410 --> 00:17:39,980
about five minutes and then you turn the

00:17:38,540 --> 00:17:44,660
vote but the base mode

00:17:39,980 --> 00:17:49,160
of when you get a when you come across a

00:17:44,660 --> 00:17:53,270
failure a hypothesis will store that on

00:17:49,160 --> 00:17:55,250
disk so the very next time you run that

00:17:53,270 --> 00:17:59,960
failed test case will be the first one

00:17:55,250 --> 00:18:02,210
that it tries so if you hit a failing

00:17:59,960 --> 00:18:07,850
test case it will keep trying that one

00:18:02,210 --> 00:18:10,370
until it passes so some other properties

00:18:07,850 --> 00:18:15,440
that are interesting to think about if

00:18:10,370 --> 00:18:16,850
you sort a list of anything the property

00:18:15,440 --> 00:18:18,830
between your imports in your output is

00:18:16,850 --> 00:18:22,040
that the output is the sorted form of

00:18:18,830 --> 00:18:24,440
the input you can have weaker properties

00:18:22,040 --> 00:18:25,970
like the length of the input is the same

00:18:24,440 --> 00:18:28,040
as the length of the output but

00:18:25,970 --> 00:18:29,570
obviously that's a fairly weak property

00:18:28,040 --> 00:18:31,400
because you can replace all of your

00:18:29,570 --> 00:18:35,030
apples with oranges and that property

00:18:31,400 --> 00:18:37,970
would still paths and reverse is similar

00:18:35,030 --> 00:18:40,549
you could the the appropriate property

00:18:37,970 --> 00:18:42,860
is that you can take your string reverse

00:18:40,549 --> 00:18:45,770
it reverse it again and you get the same

00:18:42,860 --> 00:18:47,210
output strength and that's it's it's a

00:18:45,770 --> 00:18:50,240
really interesting way to think about

00:18:47,210 --> 00:18:52,370
these test cases where you're not saying

00:18:50,240 --> 00:18:54,500
the specific inputs and outputs you're

00:18:52,370 --> 00:19:04,160
just saying how the inputs and the

00:18:54,500 --> 00:19:09,260
outputs are linked so everyone likes fax

00:19:04,160 --> 00:19:12,370
machines so it's white and black so

00:19:09,260 --> 00:19:15,590
you've got one line on a fax machine

00:19:12,370 --> 00:19:17,090
with whites and blacks so you'll always

00:19:15,590 --> 00:19:20,390
have a lot of white and you'll have a

00:19:17,090 --> 00:19:21,980
couple of blacks one of the simple ways

00:19:20,390 --> 00:19:24,919
of compressing it that is still using

00:19:21,980 --> 00:19:27,590
JPEGs is run length compression so if we

00:19:24,919 --> 00:19:29,780
had a single scan line and we compressed

00:19:27,590 --> 00:19:35,030
it we would shrink the characters down

00:19:29,780 --> 00:19:37,910
like that so very easy to understand

00:19:35,030 --> 00:19:40,160
from a diagram perspective the code gets

00:19:37,910 --> 00:19:42,770
a little bit ugly especially when you're

00:19:40,160 --> 00:19:45,110
trying to write all of it in such a way

00:19:42,770 --> 00:19:49,159
that you fit it all on one slide I don't

00:19:45,110 --> 00:19:51,200
want you to get super into the code but

00:19:49,159 --> 00:19:52,790
you loop over the characters if the

00:19:51,200 --> 00:19:53,049
previous character is the same you just

00:19:52,790 --> 00:19:54,190
keep

00:19:53,049 --> 00:19:58,149
adding them up and printing out the

00:19:54,190 --> 00:20:00,009
number and the D code is kind of similar

00:19:58,149 --> 00:20:01,629
you just loop over the characters if the

00:20:00,009 --> 00:20:10,389
previous one was a number then you say

00:20:01,629 --> 00:20:12,820
the next one n times so when you've got

00:20:10,389 --> 00:20:14,980
these pairing functions so you've got an

00:20:12,820 --> 00:20:17,409
encode and a decode function or a

00:20:14,980 --> 00:20:19,840
compress and an uncompressed function

00:20:17,409 --> 00:20:21,399
you've got two functions that do

00:20:19,840 --> 00:20:24,929
something to data and then you've got

00:20:21,399 --> 00:20:27,820
another function that does the reverse

00:20:24,929 --> 00:20:29,739
these functions are really good to use

00:20:27,820 --> 00:20:31,450
with our offices because the

00:20:29,739 --> 00:20:34,509
relationship between the input and the

00:20:31,450 --> 00:20:37,269
output you can declare that with the

00:20:34,509 --> 00:20:38,799
code so you zipper file you're unzip it

00:20:37,269 --> 00:20:44,320
you should come back with exactly the

00:20:38,799 --> 00:20:48,639
same input and output so what we've got

00:20:44,320 --> 00:20:50,830
here with the given text strategy so

00:20:48,639 --> 00:20:52,950
there is a text strategy there are

00:20:50,830 --> 00:20:55,899
strategies for all the Python data types

00:20:52,950 --> 00:20:57,909
this one's a text strategy and we've

00:20:55,899 --> 00:21:02,220
said only generate test cases with the

00:20:57,909 --> 00:21:07,869
letters W and B so that it matches my

00:21:02,220 --> 00:21:10,179
fax machine example we take our input we

00:21:07,869 --> 00:21:13,899
compress it we decompress it and we get

00:21:10,179 --> 00:21:17,710
the same result back the other property

00:21:13,899 --> 00:21:20,169
I've got there is that the so4 can prep

00:21:17,710 --> 00:21:22,619
for a an encode decode function the

00:21:20,169 --> 00:21:24,850
input in the outputs should be the same

00:21:22,619 --> 00:21:26,139
for a compression function I've got a

00:21:24,850 --> 00:21:28,090
further property there that the

00:21:26,139 --> 00:21:31,840
compressed form should be shorter than

00:21:28,090 --> 00:21:33,309
the uncompressed form which as we know

00:21:31,840 --> 00:21:35,049
for some compression types that doesn't

00:21:33,309 --> 00:21:38,499
actually work but it is a property for

00:21:35,049 --> 00:21:40,629
run length encoding fortunately so there

00:21:38,499 --> 00:21:43,239
are many different ways you can think

00:21:40,629 --> 00:21:45,940
about properties so you can do

00:21:43,239 --> 00:21:51,700
properties for optimization examples for

00:21:45,940 --> 00:21:54,700
example so that you can say after I've

00:21:51,700 --> 00:21:57,309
run this optimization problem through n

00:21:54,700 --> 00:21:59,830
stages it should be closer to the final

00:21:57,309 --> 00:22:02,460
goal you don't have to say how close you

00:21:59,830 --> 00:22:02,460
just say closer

00:22:04,960 --> 00:22:11,030
so I run that it's all good there's no

00:22:07,940 --> 00:22:12,770
errors one of the issues here though is

00:22:11,030 --> 00:22:15,110
that the random inputs that I'm

00:22:12,770 --> 00:22:17,539
generating with hypothesis are only

00:22:15,110 --> 00:22:20,120
getting passed to my encode function

00:22:17,539 --> 00:22:22,820
they're not getting passed to my decode

00:22:20,120 --> 00:22:25,490
function so I'm taking a random string

00:22:22,820 --> 00:22:28,490
passing it to encode and then passing

00:22:25,490 --> 00:22:31,940
that through to passing that encoded

00:22:28,490 --> 00:22:34,280
string through to decode so from a

00:22:31,940 --> 00:22:37,400
security point of view this is not

00:22:34,280 --> 00:22:38,960
testing the decode side of things so you

00:22:37,400 --> 00:22:40,549
do have to think carefully about all of

00:22:38,960 --> 00:22:44,270
these things

00:22:40,549 --> 00:22:46,850
so these are some generated outputs so a

00:22:44,270 --> 00:22:49,789
string with one W assuming with one B

00:22:46,850 --> 00:22:55,059
there's an empty string there and then

00:22:49,789 --> 00:22:57,919
there's a whole series where it has been

00:22:55,059 --> 00:22:59,720
it has spit out multiple copies of W and

00:22:57,919 --> 00:23:06,770
B like we would expect to see on a

00:22:59,720 --> 00:23:10,070
scanner so the really interesting part

00:23:06,770 --> 00:23:14,299
of hypothesis for me is the state-based

00:23:10,070 --> 00:23:19,159
testing so instead of trying to generate

00:23:14,299 --> 00:23:22,250
test inputs and test two instead of

00:23:19,159 --> 00:23:23,840
trying to generate test inputs we are

00:23:22,250 --> 00:23:29,059
actually trying to generate a program

00:23:23,840 --> 00:23:31,909
that fails this is really good for

00:23:29,059 --> 00:23:33,320
testing data types so you've got some

00:23:31,909 --> 00:23:37,490
sort of collection that you're adding

00:23:33,320 --> 00:23:39,100
deleting sorting inserting - you've got

00:23:37,490 --> 00:23:41,090
a bunch of operations where you're

00:23:39,100 --> 00:23:42,710
initializing your collection you're

00:23:41,090 --> 00:23:45,470
adding a lot of results you're taking a

00:23:42,710 --> 00:23:48,950
lot of results away from it and those

00:23:45,470 --> 00:23:52,220
API calls could happen in all sorts of

00:23:48,950 --> 00:23:54,530
different interleaves ways hypothesis

00:23:52,220 --> 00:23:56,840
has really it has a couple of really

00:23:54,530 --> 00:24:01,159
nice ways of doing state-based testing

00:23:56,840 --> 00:24:03,559
on this there are a couple of spots

00:24:01,159 --> 00:24:05,120
where so this is fairly new there are a

00:24:03,559 --> 00:24:06,770
couple of spots of this API where it's a

00:24:05,120 --> 00:24:09,020
bit weak and I'm hoping to add a couple

00:24:06,770 --> 00:24:10,370
of features to it and I've sort of

00:24:09,020 --> 00:24:12,020
walked around those for this test

00:24:10,370 --> 00:24:15,440
because I didn't want to get into some

00:24:12,020 --> 00:24:20,930
of the uglier details

00:24:15,440 --> 00:24:23,300
so it's a basic binary tree all of the

00:24:20,930 --> 00:24:24,740
nodes on the Left have to be smaller and

00:24:23,300 --> 00:24:31,880
all of the nodes on the right have to be

00:24:24,740 --> 00:24:35,390
larger so for the empty trees at the

00:24:31,880 --> 00:24:38,330
bottom the squares if we iterate over

00:24:35,390 --> 00:24:40,940
those it's an empty list if we insert

00:24:38,330 --> 00:24:43,700
into them we turn the empty tree into a

00:24:40,940 --> 00:24:45,020
real tree if we try to delete a value

00:24:43,700 --> 00:24:46,580
from those empty trees we will raise a

00:24:45,020 --> 00:24:51,260
value error because there's can't be any

00:24:46,580 --> 00:24:55,430
values in the empty tree fairly easy for

00:24:51,260 --> 00:24:57,590
the nodes we initialize them and the

00:24:55,430 --> 00:25:01,310
left and the right there empty trees we

00:24:57,590 --> 00:25:02,900
have a value if we iterate over them we

00:25:01,310 --> 00:25:05,420
get all of the left items we get

00:25:02,900 --> 00:25:07,610
ourselves we get our right items fairly

00:25:05,420 --> 00:25:13,190
nice the yield from actually makes this

00:25:07,610 --> 00:25:15,530
really nice insertion is pretty easy we

00:25:13,190 --> 00:25:17,330
just have to see if it goes in the left

00:25:15,530 --> 00:25:20,930
and goes down the right and then recurse

00:25:17,330 --> 00:25:23,240
down and then we get the delete and all

00:25:20,930 --> 00:25:26,540
the sudden our simple binary tree gets a

00:25:23,240 --> 00:25:28,100
little bit ugly and that nesting means

00:25:26,540 --> 00:25:31,340
that the test cases that we're going to

00:25:28,100 --> 00:25:32,990
have to hand write to test all of the

00:25:31,340 --> 00:25:35,750
corner cases for this is going to get

00:25:32,990 --> 00:25:37,580
really ugly and this is a reasonably

00:25:35,750 --> 00:25:42,140
simple data structure and it's already

00:25:37,580 --> 00:25:45,160
gotten quite complicated code so I want

00:25:42,140 --> 00:25:47,480
to show some of the state-based stuff

00:25:45,160 --> 00:25:51,310
I've had to split this up a little bit

00:25:47,480 --> 00:25:53,810
but that will be fine so we're importing

00:25:51,310 --> 00:25:56,290
our tree which is the thing we're

00:25:53,810 --> 00:25:59,390
testing we're importing our strategies

00:25:56,290 --> 00:26:02,390
like always the new stuff is the

00:25:59,390 --> 00:26:07,940
stateful stuff so we're importing a few

00:26:02,390 --> 00:26:12,050
things from stateful so we're making a

00:26:07,940 --> 00:26:14,840
machine we're making a machine it is a

00:26:12,050 --> 00:26:16,610
rule-based state machine and we are sub

00:26:14,840 --> 00:26:21,680
classing that to make our particular

00:26:16,610 --> 00:26:25,490
test we have our state our state is a

00:26:21,680 --> 00:26:28,760
bundle and we're calling that trees we

00:26:25,490 --> 00:26:29,330
have rules the rules take an element of

00:26:28,760 --> 00:26:32,149
the state

00:26:29,330 --> 00:26:35,179
and do something to it sometimes they

00:26:32,149 --> 00:26:37,580
just do an assertion on that state so

00:26:35,179 --> 00:26:39,860
this tree that I've generated it's all

00:26:37,580 --> 00:26:42,379
in order other times they're actually

00:26:39,860 --> 00:26:45,950
generating new state so wherever we've

00:26:42,379 --> 00:26:48,169
got target equals trees it means that

00:26:45,950 --> 00:26:49,999
the result of that rule is going to get

00:26:48,169 --> 00:26:52,190
taken and put back into the state

00:26:49,999 --> 00:26:57,139
machine so it's a transition from one

00:26:52,190 --> 00:27:00,619
state to another state so we've got our

00:26:57,139 --> 00:27:03,440
check down the bottom it's a rule that

00:27:00,619 --> 00:27:06,379
will get run on all of the states and it

00:27:03,440 --> 00:27:09,379
just checks that when we traverse the

00:27:06,379 --> 00:27:13,609
tree we get back the sorted list and

00:27:09,379 --> 00:27:16,609
it's it's in order the top one we take

00:27:13,609 --> 00:27:18,950
our we basically make an empty node and

00:27:16,609 --> 00:27:22,100
we add that to the state the middle one

00:27:18,950 --> 00:27:25,009
we take one of our empty nodes we insert

00:27:22,100 --> 00:27:30,409
a random number and we make that into a

00:27:25,009 --> 00:27:33,499
real tree so just with that hypothesis

00:27:30,409 --> 00:27:35,960
is going to generate random sets of

00:27:33,499 --> 00:27:38,749
trees and because we're using the random

00:27:35,960 --> 00:27:41,299
numbers there sometimes that tree will

00:27:38,749 --> 00:27:43,759
float all the way to the left so all the

00:27:41,299 --> 00:27:46,129
numbers will be increasing other times

00:27:43,759 --> 00:27:49,580
they'll always be decreasing other times

00:27:46,129 --> 00:27:51,739
it will be nice and even and balanced

00:27:49,580 --> 00:27:54,619
other times it'll have like one little

00:27:51,739 --> 00:27:56,809
tree that's really long and it will over

00:27:54,619 --> 00:27:58,570
time generate all of the different use

00:27:56,809 --> 00:28:01,070
cases that you want to be testing for

00:27:58,570 --> 00:28:06,769
without having to write any of them by

00:28:01,070 --> 00:28:11,200
hand so this is the this is the rule to

00:28:06,769 --> 00:28:15,440
test deletion so it's it's another rule

00:28:11,200 --> 00:28:18,619
it takes it takes a tree it takes a

00:28:15,440 --> 00:28:21,649
number a random number we've added the

00:28:18,619 --> 00:28:23,929
assumed in there so that when we're

00:28:21,649 --> 00:28:25,609
generating random numbers this test only

00:28:23,929 --> 00:28:28,070
makes sense if that random number we've

00:28:25,609 --> 00:28:29,090
chosen is actually in the tree so that's

00:28:28,070 --> 00:28:31,789
what the issue is

00:28:29,090 --> 00:28:35,480
and basically if that assumption is

00:28:31,789 --> 00:28:40,100
incorrect it will forget that that test

00:28:35,480 --> 00:28:41,400
happened and it will delete that number

00:28:40,100 --> 00:28:48,360
from the tree and

00:28:41,400 --> 00:28:50,460
modify the state so in those in so we

00:28:48,360 --> 00:28:52,500
started off with with quite complicated

00:28:50,460 --> 00:28:55,020
code for actually doing the fairly

00:28:52,500 --> 00:29:01,440
simple thing the test case is for

00:28:55,020 --> 00:29:04,470
testing that no no branching no looping

00:29:01,440 --> 00:29:07,020
a simple state-based machine a no

00:29:04,470 --> 00:29:09,270
pollicis does all of the work for

00:29:07,020 --> 00:29:14,010
generating random trees for us and

00:29:09,270 --> 00:29:18,750
testing all of those weird use cases so

00:29:14,010 --> 00:29:21,300
in this case the code to do the testing

00:29:18,750 --> 00:29:24,390
is much much nicer than the code that

00:29:21,300 --> 00:29:25,950
we're actually testing regularly the

00:29:24,390 --> 00:29:27,420
test code that you're writing where

00:29:25,950 --> 00:29:30,270
you're mocking out things where you're

00:29:27,420 --> 00:29:35,280
working out weird input values and stuff

00:29:30,270 --> 00:29:37,760
is quite ugly in this case it's not one

00:29:35,280 --> 00:29:40,440
of the one of the interesting test cases

00:29:37,760 --> 00:29:42,800
where you can treat something as a

00:29:40,440 --> 00:29:44,970
stateful machine is a code repository

00:29:42,800 --> 00:29:48,150
hypothesis has found a few bugs in

00:29:44,970 --> 00:29:51,480
mercurial you can treat a repository as

00:29:48,150 --> 00:29:53,850
a state machine so you initialize your

00:29:51,480 --> 00:29:58,500
mercurial repository you make a branch

00:29:53,850 --> 00:30:00,480
name and it was a strategy of text and

00:29:58,500 --> 00:30:03,510
at some point in time it's made a branch

00:30:00,480 --> 00:30:06,960
name with a double slash in it you

00:30:03,510 --> 00:30:09,570
commit you will change you call a HD

00:30:06,960 --> 00:30:11,730
shelve and it turns out there was an

00:30:09,570 --> 00:30:14,280
internal bug in mercurial that if you

00:30:11,730 --> 00:30:17,640
did a shelf on a branch that had a

00:30:14,280 --> 00:30:19,920
double slash a slash in the name it

00:30:17,640 --> 00:30:21,870
would try to write that shelve

00:30:19,920 --> 00:30:23,490
information to a directory that didn't

00:30:21,870 --> 00:30:27,210
exist because it would treat your branch

00:30:23,490 --> 00:30:29,390
name like a a file path no one would

00:30:27,210 --> 00:30:33,120
have ever thought to have tested this

00:30:29,390 --> 00:30:35,510
mercurial hypothesis came across this by

00:30:33,120 --> 00:30:35,510
random chance

00:30:36,920 --> 00:30:45,960
so hypothesis dot works is the website

00:30:40,880 --> 00:30:48,960
that is a real top-level domain so so

00:30:45,960 --> 00:30:52,140
david's is a very interesting chap the

00:30:48,960 --> 00:30:54,240
story about hypothesis i i recommend you

00:30:52,140 --> 00:30:55,559
go and read up about that he's had some

00:30:54,240 --> 00:30:57,120
trials and tribulations i

00:30:55,559 --> 00:30:58,470
really feel it's my place to talk about

00:30:57,120 --> 00:31:00,149
that I think that's a fairly personal

00:30:58,470 --> 00:31:02,309
thing there's lots of great

00:31:00,149 --> 00:31:05,730
documentation that hypothesis dot works

00:31:02,309 --> 00:31:07,470
he offers for paid training I think he's

00:31:05,730 --> 00:31:09,470
being paid at the moment to try and port

00:31:07,470 --> 00:31:11,879
hypotheses back to other languages

00:31:09,470 --> 00:31:13,409
because he's sort of struggling to get

00:31:11,879 --> 00:31:15,059
money out of the Python form but

00:31:13,409 --> 00:31:16,679
enterprise people with Java will pay for

00:31:15,059 --> 00:31:22,679
tools like this because it means that

00:31:16,679 --> 00:31:25,289
they have to write less Java and yeah

00:31:22,679 --> 00:31:26,879
there's other integrations that I said

00:31:25,289 --> 00:31:29,669
we wouldn't get time and to go into

00:31:26,879 --> 00:31:32,279
there's a special looks for Django numpy

00:31:29,669 --> 00:31:34,499
and a few other things and I did mention

00:31:32,279 --> 00:31:37,110
the settings so thank you very much

00:31:34,499 --> 00:31:38,970
we've got some time for questions I

00:31:37,110 --> 00:31:45,269
think oh okay

00:31:38,970 --> 00:31:46,919
I thank you very much unfortunately

00:31:45,269 --> 00:31:49,289
don't have time for questions so I'm

00:31:46,919 --> 00:31:50,369
sure I'll be available in the hall and

00:31:49,289 --> 00:31:52,759
we'll see you back in ten minutes for

00:31:50,369 --> 00:31:52,759

YouTube URL: https://www.youtube.com/watch?v=vKxKUkX8EIU


