Title: Functional Programming for Pythonistas
Publication date: 2016-08-16
Playlist: Pycon Australia 2016
Description: 
	Bianca Gibson
https://2016.pycon-au.org/schedule/155/view_talk
Rampant side effects. 
The shifting sands of mutable state beneath your feet.
Enter Functional Programming.
Functional Programming helps you write more clear, maintainable and testable code.                   
This talk will cover the core principles of functional programming, how they relate to techniques you probably already use, how to apply them in python, the benefits they can offer and how to introduce them to other developers.
Captions: 
	00:00:00,030 --> 00:00:05,730
okay good afternoon everyone this

00:00:03,090 --> 00:00:07,610
afternoon we've got Bianca Gibson and

00:00:05,730 --> 00:00:11,450
she's going to be talking to us about

00:00:07,610 --> 00:00:13,950
functional programming for Python esters

00:00:11,450 --> 00:00:17,100
Bianca is a developer at realestate.com

00:00:13,950 --> 00:00:18,390
dot au and she became a functional

00:00:17,100 --> 00:00:20,220
programming enthusiast

00:00:18,390 --> 00:00:23,220
after getting a taste building

00:00:20,220 --> 00:00:25,529
functional web apps in Scala she was

00:00:23,220 --> 00:00:26,340
previously a council member of Linux

00:00:25,529 --> 00:00:39,899
Australia

00:00:26,340 --> 00:00:41,160
please welcome Bianca thank you so that

00:00:39,899 --> 00:00:43,649
this talk is about functional

00:00:41,160 --> 00:00:46,500
programming possibly Python esters and

00:00:43,649 --> 00:00:49,079
the bit of background a veneer since I

00:00:46,500 --> 00:00:51,570
used to work on some of our functional

00:00:49,079 --> 00:00:54,239
web apps and services at REI and I've

00:00:51,570 --> 00:00:55,800
also done some Ruby stuff so I got to

00:00:54,239 --> 00:00:57,660
taste them and then I've brought some of

00:00:55,800 --> 00:01:01,280
the stuff I learnt from that into Ruby

00:00:57,660 --> 00:01:03,270
and we can also bring it into Python and

00:01:01,280 --> 00:01:05,189
from this talk you should learn about

00:01:03,270 --> 00:01:08,040
what the core of functional programming

00:01:05,189 --> 00:01:10,680
is what it's really all about how it can

00:01:08,040 --> 00:01:12,780
help make your code clearer how you can

00:01:10,680 --> 00:01:14,340
use it in software that you're already

00:01:12,780 --> 00:01:15,960
working on you don't have to wait to a

00:01:14,340 --> 00:01:18,900
Greenfields project until you're using

00:01:15,960 --> 00:01:19,920
an explicitly functional language that

00:01:18,900 --> 00:01:21,450
it doesn't have to be hard and

00:01:19,920 --> 00:01:22,860
complicated and that although a

00:01:21,450 --> 00:01:24,869
neckbeards are welcome they're not

00:01:22,860 --> 00:01:30,119
compulsory I don't have one and I know

00:01:24,869 --> 00:01:32,250
I'm talking about it and to do this

00:01:30,119 --> 00:01:34,229
we're going to talk about what do we

00:01:32,250 --> 00:01:36,840
need in a language to make functional

00:01:34,229 --> 00:01:39,479
programming feasible but immutability

00:01:36,840 --> 00:01:41,970
what's putting off side effects what's

00:01:39,479 --> 00:01:44,820
referential transparency a little bit

00:01:41,970 --> 00:01:47,369
about me nuts and some common traps so

00:01:44,820 --> 00:01:51,750
in explaining it to others and how we

00:01:47,369 --> 00:01:53,130
can go and learn more and all of these

00:01:51,750 --> 00:01:59,189
to me really come back to stopping

00:01:53,130 --> 00:02:00,899
things from changing behind our backs so

00:01:59,189 --> 00:02:03,240
what do we need in a language to make

00:02:00,899 --> 00:02:05,070
functional programming feasible so

00:02:03,240 --> 00:02:07,409
having first class functions is

00:02:05,070 --> 00:02:10,289
extremely helpful so functions are

00:02:07,409 --> 00:02:11,560
objects we can pass them in to other

00:02:10,289 --> 00:02:13,480
functions

00:02:11,560 --> 00:02:16,090
can return them as a result so we can

00:02:13,480 --> 00:02:17,319
operate on these functions and there's a

00:02:16,090 --> 00:02:19,959
whole lot of other stuff that's really

00:02:17,319 --> 00:02:21,550
helpful and some of which Python has but

00:02:19,959 --> 00:02:24,640
you can kind of get away without it and

00:02:21,550 --> 00:02:26,380
it doesn't need to be a so-called

00:02:24,640 --> 00:02:28,780
functional language as a ruby developer

00:02:26,380 --> 00:02:30,220
I use mutations so really that the last

00:02:28,780 --> 00:02:32,290
time I did it one of my colleagues

00:02:30,220 --> 00:02:38,170
walked up to my desk know what why do

00:02:32,290 --> 00:02:40,480
you think mutation you don't do this so

00:02:38,170 --> 00:02:43,810
we'll start with immutability which is

00:02:40,480 --> 00:02:47,080
when instead of changing values we can

00:02:43,810 --> 00:02:48,370
use constants and the stack so when we

00:02:47,080 --> 00:02:50,110
want to change an object instead of

00:02:48,370 --> 00:02:51,900
modifying it we can create a new one

00:02:50,110 --> 00:02:54,730
that has the values that we want and we

00:02:51,900 --> 00:02:57,940
can use recursion and accumulators or

00:02:54,730 --> 00:02:59,500
even loops and mutation and if you've

00:02:57,940 --> 00:03:00,940
ever had confusion or you're passing low

00:02:59,500 --> 00:03:03,150
value by reference if you're not

00:03:00,940 --> 00:03:06,450
mutating it doesn't make a difference

00:03:03,150 --> 00:03:09,610
because it doesn't change anyway and

00:03:06,450 --> 00:03:11,170
when you're mutating state you can end

00:03:09,610 --> 00:03:14,019
up with some pretty confusing stuff so

00:03:11,170 --> 00:03:16,630
the wider the scope of the object you're

00:03:14,019 --> 00:03:19,630
mutating the worse it can get in one

00:03:16,630 --> 00:03:22,269
case I was working on adding a new build

00:03:19,630 --> 00:03:25,269
tasks this project that was using Gradle

00:03:22,269 --> 00:03:27,640
so the build was in groovy we had to add

00:03:25,269 --> 00:03:29,829
a new task in a new dependency so we

00:03:27,640 --> 00:03:32,140
added our new dependency we wrote our

00:03:29,829 --> 00:03:33,489
new task we filtered the list of

00:03:32,140 --> 00:03:35,769
dependencies down to the one that we

00:03:33,489 --> 00:03:38,620
wanted we did our thing on it our tasks

00:03:35,769 --> 00:03:42,880
worked the tests passed the tests our

00:03:38,620 --> 00:03:44,739
task was running past and you know it'll

00:03:42,880 --> 00:03:46,450
all be fine we only modified that little

00:03:44,739 --> 00:03:48,010
bit we just added something so we went

00:03:46,450 --> 00:03:48,910
to run the whole build of course it's

00:03:48,010 --> 00:03:51,760
going to work it's just to be sure

00:03:48,910 --> 00:03:56,019
before we check it in an hour really

00:03:51,760 --> 00:03:57,790
didn't all the dependencies were missing

00:03:56,019 --> 00:03:59,799
we got all these errors going companies

00:03:57,790 --> 00:04:03,250
can't find that and it turned out that

00:03:59,799 --> 00:04:07,150
when you filter a list in griffie it's

00:04:03,250 --> 00:04:08,410
as well as returning a list that is what

00:04:07,150 --> 00:04:11,109
you'd expect when you filter it it

00:04:08,410 --> 00:04:14,200
changes the original list so we've gone

00:04:11,109 --> 00:04:16,570
in without realizing it deleted every

00:04:14,200 --> 00:04:19,690
single other build dependency from the

00:04:16,570 --> 00:04:21,880
global list of build dependencies it's

00:04:19,690 --> 00:04:23,140
not necessarily going to be that severe

00:04:21,880 --> 00:04:25,660
because when it's global you're gonna

00:04:23,140 --> 00:04:26,980
have worse consequences

00:04:25,660 --> 00:04:29,350
as soon as you're sharing it you

00:04:26,980 --> 00:04:33,940
introduce a risk of having there's

00:04:29,350 --> 00:04:37,300
problems and got some examples to

00:04:33,940 --> 00:04:39,760
demonstrate that so if we have an item

00:04:37,300 --> 00:04:41,950
in a shopping cart which just has its

00:04:39,760 --> 00:04:44,260
only attribute is cost and it's just got

00:04:41,950 --> 00:04:49,570
some stuff to make it comparable which

00:04:44,260 --> 00:04:51,430
we don't really need to go into and we

00:04:49,570 --> 00:04:57,250
want to add GST to this in an immutable

00:04:51,430 --> 00:05:00,100
way so we can use have a multiplier to

00:04:57,250 --> 00:05:02,310
multiply our cost to we can use a list

00:05:00,100 --> 00:05:06,550
comprehension to go through every item

00:05:02,310 --> 00:05:10,090
and just call the with GST function on

00:05:06,550 --> 00:05:11,800
it and this is where the difference

00:05:10,090 --> 00:05:14,170
between the mutable and immutable

00:05:11,800 --> 00:05:16,240
solution would come in so if we're doing

00:05:14,170 --> 00:05:19,090
it immutably we could change will change

00:05:16,240 --> 00:05:21,220
the I could change the item cost but in

00:05:19,090 --> 00:05:24,370
this case we get the new cost that we

00:05:21,220 --> 00:05:26,200
want by multiplying it with the

00:05:24,370 --> 00:05:28,600
multiplier and instead of changing the

00:05:26,200 --> 00:05:33,130
cost we create a new object that has the

00:05:28,600 --> 00:05:35,680
value that we want so it can be pretty

00:05:33,130 --> 00:05:37,810
straightforward and we can make this a

00:05:35,680 --> 00:05:39,970
little more concise by using a

00:05:37,810 --> 00:05:41,830
higher-order function in this case map

00:05:39,970 --> 00:05:43,870
which does the same thing as the list

00:05:41,830 --> 00:05:47,560
comprehension we looked at on the

00:05:43,870 --> 00:05:50,730
previous page it just runs the function

00:05:47,560 --> 00:05:58,419
supplied the first argument with GST on

00:05:50,730 --> 00:06:00,760
all the elements in item but now that we

00:05:58,419 --> 00:06:04,630
compare a mutable and immutable solution

00:06:00,760 --> 00:06:07,350
to get a bit more of an idea so say we

00:06:04,630 --> 00:06:09,630
want to total up this shopping cart a

00:06:07,350 --> 00:06:12,190
simple mutable solution could be

00:06:09,630 --> 00:06:14,169
initializing a total and then iterating

00:06:12,190 --> 00:06:16,780
through each item and just adding them

00:06:14,169 --> 00:06:21,910
all onto total to accumulate it up and

00:06:16,780 --> 00:06:25,000
then returning the total we could do an

00:06:21,910 --> 00:06:30,190
immutable recursive sorry if you had

00:06:25,000 --> 00:06:32,800
time to read that cool we could do an

00:06:30,190 --> 00:06:36,130
immutable recursive solution explicitly

00:06:32,800 --> 00:06:38,340
recursive by separating the head and the

00:06:36,130 --> 00:06:39,870
tail of the list so the head would be

00:06:38,340 --> 00:06:42,090
first element on the list and the tail

00:06:39,870 --> 00:06:44,790
is the rest of the list

00:06:42,090 --> 00:06:46,680
and if it's a lot if we up to the last

00:06:44,790 --> 00:06:49,410
element in the list so if the length of

00:06:46,680 --> 00:06:51,419
the tail is zero we can return the cost

00:06:49,410 --> 00:06:53,610
just the cost of the head and this is

00:06:51,419 --> 00:06:57,139
the base case because it's where we

00:06:53,610 --> 00:06:59,430
start going back up the coltrane

00:06:57,139 --> 00:07:01,620
otherwise we add the cost of that

00:06:59,430 --> 00:07:04,310
current element and the result of

00:07:01,620 --> 00:07:08,669
recursive call on the rest of the list

00:07:04,310 --> 00:07:10,919
this is a bit more verbose and this will

00:07:08,669 --> 00:07:12,660
be quite inefficient in terms of the

00:07:10,919 --> 00:07:14,490
stack because each time we're doing a

00:07:12,660 --> 00:07:16,560
recursive call we're putting another

00:07:14,490 --> 00:07:20,900
stack frame on so there's another

00:07:16,560 --> 00:07:24,450
approach using tail call recursion which

00:07:20,900 --> 00:07:26,160
doesn't help in Python but in other

00:07:24,450 --> 00:07:27,660
languages at wood there's another

00:07:26,160 --> 00:07:32,030
approach we can take in Python I'll get

00:07:27,660 --> 00:07:34,620
to next where we use accumulators to

00:07:32,030 --> 00:07:37,050
allow us to have the last call in the

00:07:34,620 --> 00:07:38,970
function be the recursive call which in

00:07:37,050 --> 00:07:40,680
some languages can be optimized out so

00:07:38,970 --> 00:07:43,979
we don't use so much so many stack

00:07:40,680 --> 00:07:46,740
frames so it's pretty similar except

00:07:43,979 --> 00:07:51,889
instead of returning the heads cost we

00:07:46,740 --> 00:07:54,630
add in the total the accumulator and we

00:07:51,889 --> 00:08:01,710
pass in the accumulator into the

00:07:54,630 --> 00:08:03,300
recursive calls and a way that we can do

00:08:01,710 --> 00:08:05,490
a similar thing but more efficiently in

00:08:03,300 --> 00:08:07,080
python is if we use higher order

00:08:05,490 --> 00:08:09,210
functions which are implemented more

00:08:07,080 --> 00:08:11,970
efficiently so in this case we can use

00:08:09,210 --> 00:08:13,440
reduce from the funk funk tools and this

00:08:11,970 --> 00:08:15,870
does the same thing as the previous

00:08:13,440 --> 00:08:19,560
example you'll see that it adds the

00:08:15,870 --> 00:08:23,430
total sorry Mouse wasn't working the

00:08:19,560 --> 00:08:26,340
total and the cost of the head so and in

00:08:23,430 --> 00:08:28,200
this case but by using reduce we

00:08:26,340 --> 00:08:29,400
eliminate some of the verbosity so it's

00:08:28,200 --> 00:08:31,830
easy to see what it's actually doing

00:08:29,400 --> 00:08:32,669
because the real core of it is just this

00:08:31,830 --> 00:08:36,240
little bit here

00:08:32,669 --> 00:08:39,810
the total plus head cost so it runs this

00:08:36,240 --> 00:08:42,990
lambda worry about every item in items

00:08:39,810 --> 00:08:45,120
and the 0 at the end is what we're

00:08:42,990 --> 00:08:49,829
initializing the total to so that's

00:08:45,120 --> 00:08:53,780
equivalent to the default total zero in

00:08:49,829 --> 00:08:53,780
the explicitly recursive solution

00:08:56,959 --> 00:09:03,000
so moving on side-effects so what are

00:08:59,820 --> 00:09:04,200
they is whenever you your code affects

00:09:03,000 --> 00:09:05,899
the outside world so if you write

00:09:04,200 --> 00:09:09,149
something out to disk you do a network

00:09:05,899 --> 00:09:11,459
call that's all side effects it's really

00:09:09,149 --> 00:09:16,589
what what your software does how it

00:09:11,459 --> 00:09:18,810
interacts with the outside world and in

00:09:16,589 --> 00:09:21,180
functional programming we'd like to

00:09:18,810 --> 00:09:22,830
separate the functional core that

00:09:21,180 --> 00:09:24,779
generates a representation of side

00:09:22,830 --> 00:09:28,170
effects and the outside layer that

00:09:24,779 --> 00:09:32,250
actually executes the side effects so

00:09:28,170 --> 00:09:33,930
this allows so the middle would make a

00:09:32,250 --> 00:09:36,750
representation of what we're going to do

00:09:33,930 --> 00:09:38,970
and this makes the core easier to test

00:09:36,750 --> 00:09:40,560
and to reason about it becomes more just

00:09:38,970 --> 00:09:42,930
inputs and outputs and having all these

00:09:40,560 --> 00:09:44,279
other things going on and when you don't

00:09:42,930 --> 00:09:45,810
have side effects that can make your

00:09:44,279 --> 00:09:47,640
testing far simpler you push the

00:09:45,810 --> 00:09:50,660
complexity in the test to the outside of

00:09:47,640 --> 00:09:52,980
the system so it's in less places and

00:09:50,660 --> 00:09:55,080
contrary to popular belief it's not

00:09:52,980 --> 00:09:56,550
about getting rid of side effects it's

00:09:55,080 --> 00:09:58,260
about controlling them and making them

00:09:56,550 --> 00:10:03,240
more explicit so we know when they're

00:09:58,260 --> 00:10:05,940
happening so let's get to some examples

00:10:03,240 --> 00:10:10,610
a side effecting if we want to add

00:10:05,940 --> 00:10:13,230
printing to this a GST function a

00:10:10,610 --> 00:10:15,060
straightforward side effecting way to do

00:10:13,230 --> 00:10:17,850
it would be to just chuck the right call

00:10:15,060 --> 00:10:20,700
in to the existing function so we

00:10:17,850 --> 00:10:22,950
modified the existing function and put

00:10:20,700 --> 00:10:25,589
in the output which by default just goes

00:10:22,950 --> 00:10:30,690
to stand it out and we can call it that

00:10:25,589 --> 00:10:31,920
prints things out okay it works or if we

00:10:30,690 --> 00:10:34,110
wanted to take a functional approach

00:10:31,920 --> 00:10:36,810
where we separate the side effects we

00:10:34,110 --> 00:10:38,339
can create a new function that has the

00:10:36,810 --> 00:10:39,329
sole responsibility of printing so

00:10:38,339 --> 00:10:42,270
instead of combining the

00:10:39,329 --> 00:10:44,760
responsibilities of adding to the cost

00:10:42,270 --> 00:10:46,950
and printing it we make separate

00:10:44,760 --> 00:10:49,050
functions for each responsibility and we

00:10:46,950 --> 00:10:51,750
can just give print cost the result of

00:10:49,050 --> 00:10:55,770
the other function and then that allows

00:10:51,750 --> 00:11:01,640
us to test them in isolation so if we

00:10:55,770 --> 00:11:01,640
want to test sorry I need a drink

00:11:06,640 --> 00:11:11,810
so if we want to test just adding the

00:11:09,260 --> 00:11:14,330
GST to the items not testing the site

00:11:11,810 --> 00:11:17,120
the printing at this stage when we've

00:11:14,330 --> 00:11:19,910
combined our side effects and our

00:11:17,120 --> 00:11:21,770
calculation we have to mess around with

00:11:19,910 --> 00:11:24,320
all this additional stuff we have to

00:11:21,770 --> 00:11:26,180
feed industry my own we have to read the

00:11:24,320 --> 00:11:29,390
results from it and the test isn't

00:11:26,180 --> 00:11:33,740
really very clear the intention doesn't

00:11:29,390 --> 00:11:35,899
really jump out at you and there's all

00:11:33,740 --> 00:11:37,850
this extra stuff going on but if we

00:11:35,899 --> 00:11:40,339
implemented it functionally the tests

00:11:37,850 --> 00:11:42,380
are so much easier to understand it

00:11:40,339 --> 00:11:43,970
becomes just inputs and outputs and

00:11:42,380 --> 00:11:46,970
there's nothing else to it there's

00:11:43,970 --> 00:11:51,339
nothing else going on so we can quite

00:11:46,970 --> 00:11:51,339
easily see what we're expecting it to do

00:11:53,709 --> 00:12:01,430
and another characteristic of functional

00:11:57,709 --> 00:12:03,050
software is referential transparency so

00:12:01,430 --> 00:12:05,060
it's a combination of immutability and

00:12:03,050 --> 00:12:07,430
no side effects and it means that if you

00:12:05,060 --> 00:12:08,839
call the function again and again you'll

00:12:07,430 --> 00:12:11,450
always get the same result and there'll

00:12:08,839 --> 00:12:14,240
be no side effects so this means you can

00:12:11,450 --> 00:12:15,980
replace the saved result of a function

00:12:14,240 --> 00:12:16,850
call with the function call and

00:12:15,980 --> 00:12:18,620
vice-versa

00:12:16,850 --> 00:12:21,800
and there are no negative consequences

00:12:18,620 --> 00:12:23,900
to it and this means that everything the

00:12:21,800 --> 00:12:25,850
function does is encapsulated by the

00:12:23,900 --> 00:12:27,950
result so you can reason about what it's

00:12:25,850 --> 00:12:29,750
doing just by going what goes in what

00:12:27,950 --> 00:12:35,450
comes out there's nothing else going on

00:12:29,750 --> 00:12:38,290
behind your back so it's much clearer so

00:12:35,450 --> 00:12:42,020
when we have referentially transparent

00:12:38,290 --> 00:12:43,760
functions for example this one we can

00:12:42,020 --> 00:12:47,060
call the same function with the same

00:12:43,760 --> 00:12:50,140
inputs we get the same result in both

00:12:47,060 --> 00:12:52,520
cases which seems pretty reasonable so

00:12:50,140 --> 00:12:55,339
but when things are not referentially

00:12:52,520 --> 00:12:58,339
transferrin we can end up doing this

00:12:55,339 --> 00:13:01,459
exactly the same thing in almost exactly

00:12:58,339 --> 00:13:05,480
the same place and different things

00:13:01,459 --> 00:13:08,500
happen because in this case we're

00:13:05,480 --> 00:13:10,610
setting the items cost as well as

00:13:08,500 --> 00:13:13,070
returning it so we do the same thing

00:13:10,610 --> 00:13:16,680
again and then different things happen

00:13:13,070 --> 00:13:19,080
which doesn't make much sense and this

00:13:16,680 --> 00:13:31,410
would get more harder to reason about in

00:13:19,080 --> 00:13:34,410
larger systems so we can rear ones for

00:13:31,410 --> 00:13:36,300
my notes the the time to disrupt the

00:13:34,410 --> 00:13:39,630
closet industry of terrible monad

00:13:36,300 --> 00:13:44,220
tutorials most of them still don't make

00:13:39,630 --> 00:13:46,769
sense to me so it's it's a container

00:13:44,220 --> 00:13:48,810
that has you can put things in it how's

00:13:46,769 --> 00:13:51,390
it constructor where say you could put a

00:13:48,810 --> 00:13:54,440
number in it and you can also execute

00:13:51,390 --> 00:13:56,820
things on whatever's in the container

00:13:54,440 --> 00:14:00,540
using a function called flat map which

00:13:56,820 --> 00:14:02,790
is also called buying in Haskell which

00:14:00,540 --> 00:14:06,329
is what we use map before and flat map

00:14:02,790 --> 00:14:08,820
is really flatten map so as well as

00:14:06,329 --> 00:14:11,130
executing things on what's inside it

00:14:08,820 --> 00:14:13,200
pulls pulls whatever is inside the

00:14:11,130 --> 00:14:15,959
container out so a lot of collections

00:14:13,200 --> 00:14:19,010
are examples of monads we don't have

00:14:15,959 --> 00:14:22,560
flat map in Python but it's easy to add

00:14:19,010 --> 00:14:25,740
and to demonstrate the difference when

00:14:22,560 --> 00:14:28,529
we're using map if we start with a

00:14:25,740 --> 00:14:31,920
nested collection in this case a list of

00:14:28,529 --> 00:14:36,930
lists of fancy names and we want to

00:14:31,920 --> 00:14:40,470
capitalize all the names so we can use

00:14:36,930 --> 00:14:45,170
map to iterate through each of these

00:14:40,470 --> 00:14:48,630
lists that are inside the list and

00:14:45,170 --> 00:14:50,310
execute capitalize all on it and then

00:14:48,630 --> 00:14:53,430
within that function within capitalize

00:14:50,310 --> 00:14:56,850
all we're executing capitalize on each

00:14:53,430 --> 00:14:59,600
string in those lists and the result

00:14:56,850 --> 00:15:03,420
that we'll get out of this is a

00:14:59,600 --> 00:15:07,290
collection of maps which are a type of

00:15:03,420 --> 00:15:08,940
list so if we want to get the just

00:15:07,290 --> 00:15:11,910
trying to print that doesn't give us

00:15:08,940 --> 00:15:13,680
anything that's very useful but say we

00:15:11,910 --> 00:15:16,649
want to output the names afterwards we

00:15:13,680 --> 00:15:18,870
need to go through and do this nested

00:15:16,649 --> 00:15:20,550
list comprehension to get stuff out of

00:15:18,870 --> 00:15:23,250
it because we've ended up with nested

00:15:20,550 --> 00:15:26,510
collections but if we use flat map

00:15:23,250 --> 00:15:28,399
instead then we can just get

00:15:26,510 --> 00:15:34,040
the names because it eliminates one

00:15:28,399 --> 00:15:36,290
layer of the collections so there's a

00:15:34,040 --> 00:15:38,600
simple definition flatmap is pretty

00:15:36,290 --> 00:15:40,880
straightforward to define so we can just

00:15:38,600 --> 00:15:42,829
add it quite easily if we call flat map

00:15:40,880 --> 00:15:44,990
instead we just get the list and we can

00:15:42,829 --> 00:15:49,690
print it out much nicer without having

00:15:44,990 --> 00:15:54,230
to do nested list comprehensions and

00:15:49,690 --> 00:15:56,300
most marina will also have map which we

00:15:54,230 --> 00:16:01,010
talked about before map can be defined

00:15:56,300 --> 00:16:03,170
based on flat map and vice versa filter

00:16:01,010 --> 00:16:06,829
is also common which can be defined for

00:16:03,170 --> 00:16:10,160
a flat map and they tend to also have

00:16:06,829 --> 00:16:11,660
reduce which we use before and filter

00:16:10,160 --> 00:16:13,279
since we haven't used filter I might

00:16:11,660 --> 00:16:15,680
touch on that a bit more it's exactly

00:16:13,279 --> 00:16:18,199
what it sounds like check if it meets

00:16:15,680 --> 00:16:24,139
this logically an expression if it

00:16:18,199 --> 00:16:25,519
doesn't get rid of it but the elephant

00:16:24,139 --> 00:16:28,910
in the room talking about functional

00:16:25,519 --> 00:16:32,120
programming Python is like the tail call

00:16:28,910 --> 00:16:34,430
optimization so functional programming

00:16:32,120 --> 00:16:37,160
with explicit often uses recursion and

00:16:34,430 --> 00:16:39,199
when you're using recursion it can be

00:16:37,160 --> 00:16:40,579
very inefficient on the stack because

00:16:39,199 --> 00:16:41,990
whenever you're doing these recursive

00:16:40,579 --> 00:16:43,819
calls it makes a new stack frame and

00:16:41,990 --> 00:16:45,350
that can use a whole lot of memory if

00:16:43,819 --> 00:16:48,529
it's a substantial size collection

00:16:45,350 --> 00:16:50,600
you're recursing order and we don't have

00:16:48,529 --> 00:16:52,459
tail colonization in Python and it

00:16:50,600 --> 00:16:55,279
doesn't look like it's going to happen

00:16:52,459 --> 00:16:55,579
it's been pushed but it's not going to

00:16:55,279 --> 00:16:57,529
happen

00:16:55,579 --> 00:17:00,889
really it's not gonna happen it's been

00:16:57,529 --> 00:17:02,480
discussed to death and we can kind of

00:17:00,889 --> 00:17:04,910
get around this by using some

00:17:02,480 --> 00:17:07,339
higher-order functions and list

00:17:04,910 --> 00:17:08,780
comprehensions which do basically the

00:17:07,339 --> 00:17:11,799
same thing but they're far more

00:17:08,780 --> 00:17:14,780
efficient I think they implemented

00:17:11,799 --> 00:17:18,199
iteratively in Python but you can reason

00:17:14,780 --> 00:17:21,069
about them as if they were functional

00:17:18,199 --> 00:17:23,770
because they operate in that way and

00:17:21,069 --> 00:17:25,850
it's also quite a bit more concisely

00:17:23,770 --> 00:17:27,650
explicitly recursive solutions we looked

00:17:25,850 --> 00:17:30,169
at before were pretty verbose they were

00:17:27,650 --> 00:17:32,210
approximately as verbose as the

00:17:30,169 --> 00:17:33,350
iterative solutions but the ones using

00:17:32,210 --> 00:17:35,090
higher-order functions all this

00:17:33,350 --> 00:17:37,540
comprehensions were much easier to read

00:17:35,090 --> 00:17:40,310
and concise and a lot less boilerplate

00:17:37,540 --> 00:17:42,140
because there is higher-order functions

00:17:40,310 --> 00:17:46,610
do that boilerplate instead of you

00:17:42,140 --> 00:17:48,380
having to and there's also trampolines

00:17:46,610 --> 00:17:50,330
available which I haven't gone into

00:17:48,380 --> 00:17:52,130
because I don't think they look that

00:17:50,330 --> 00:17:54,430
nice but it's an option so that's just a

00:17:52,130 --> 00:17:57,440
thing that you can wrap around your

00:17:54,430 --> 00:17:59,090
recursive functions that translate into

00:17:57,440 --> 00:18:06,170
having some go to use so it's more

00:17:59,090 --> 00:18:08,210
efficient on the stack and there are a

00:18:06,170 --> 00:18:10,970
lot of common pitfalls when teaching it

00:18:08,210 --> 00:18:14,720
if any of your bread brownie tutorials

00:18:10,970 --> 00:18:16,910
you probably realize this and it's

00:18:14,720 --> 00:18:17,750
important not to get too far into and

00:18:16,910 --> 00:18:19,730
that's when you're teaching it

00:18:17,750 --> 00:18:21,290
particularly since people are really

00:18:19,730 --> 00:18:24,850
prone to that I've been guilty of that

00:18:21,290 --> 00:18:27,590
myself in the first version of the Ruby

00:18:24,850 --> 00:18:29,270
version of this talk I I had a note

00:18:27,590 --> 00:18:30,860
about not getting too mathematical but I

00:18:29,270 --> 00:18:33,970
was using a number sequence as an

00:18:30,860 --> 00:18:38,570
example which didn't make too much sense

00:18:33,970 --> 00:18:40,160
and it's important to relate the

00:18:38,570 --> 00:18:41,900
concepts of stuff they already know like

00:18:40,160 --> 00:18:44,360
if it's a C you get old you know say

00:18:41,900 --> 00:18:45,890
shop programmer this use link they be a

00:18:44,360 --> 00:18:50,930
whole lot of great ads they just haven't

00:18:45,890 --> 00:18:53,660
heard the name and sometimes we should

00:18:50,930 --> 00:18:56,000
avoid more intimidating words until they

00:18:53,660 --> 00:18:57,830
understand it and tell them what it is

00:18:56,000 --> 00:19:00,590
it's important to focus on the practical

00:18:57,830 --> 00:19:03,440
side because of that academic image and

00:19:00,590 --> 00:19:05,810
I accidentally press the bottom twice so

00:19:03,440 --> 00:19:08,000
just jump back of it some people claim

00:19:05,810 --> 00:19:09,620
that functional clashes with object

00:19:08,000 --> 00:19:12,220
orientation which I rather strongly

00:19:09,620 --> 00:19:14,720
disagree with so they'll claim that

00:19:12,220 --> 00:19:18,830
mutation of state is fundamental to

00:19:14,720 --> 00:19:21,320
object orientation but I I disagree I

00:19:18,830 --> 00:19:23,390
think that creating new objects instead

00:19:21,320 --> 00:19:26,030
of with attributes you want instead of

00:19:23,390 --> 00:19:28,070
changing an existing one doesn't clash

00:19:26,030 --> 00:19:32,120
with object orientation at all and I

00:19:28,070 --> 00:19:34,370
don't really see why it would you can

00:19:32,120 --> 00:19:39,830
still have your objects like you would

00:19:34,370 --> 00:19:41,420
you just create new ones and they're a

00:19:39,830 --> 00:19:42,860
whole since this is quite introductory

00:19:41,420 --> 00:19:45,620
to functional there's a whole lot of

00:19:42,860 --> 00:19:46,940
resources I'll point you to from where

00:19:45,620 --> 00:19:50,000
you can go if you interested in learning

00:19:46,940 --> 00:19:51,710
more so to start with and I'm gonna have

00:19:50,000 --> 00:19:53,330
a link to the slides at the end so you

00:19:51,710 --> 00:19:53,810
don't have to worry about drawing things

00:19:53,330 --> 00:19:55,130
down

00:19:53,810 --> 00:19:59,720
you can go and look at it on github

00:19:55,130 --> 00:20:02,090
there's a how-to document in the Python

00:19:59,720 --> 00:20:03,950
Docs which has some really good examples

00:20:02,090 --> 00:20:06,560
I did use some of their examples for

00:20:03,950 --> 00:20:09,950
some inspiration but they advocate for

00:20:06,560 --> 00:20:11,870
local mutation which I disagree with I

00:20:09,950 --> 00:20:13,490
don't think it's as problematic as when

00:20:11,870 --> 00:20:17,240
the state is shared but I prefer to

00:20:13,490 --> 00:20:19,010
avoid it and they say that oh woe and FP

00:20:17,240 --> 00:20:22,580
clash which I disagree with but the

00:20:19,010 --> 00:20:27,850
examples are really good there's a

00:20:22,580 --> 00:20:29,980
series of introductory articles here

00:20:27,850 --> 00:20:31,940
there is a tail call optimization

00:20:29,980 --> 00:20:33,920
implementation which translates it to

00:20:31,940 --> 00:20:36,020
have some go-to so it's more efficient

00:20:33,920 --> 00:20:39,290
which you can look at if you're after

00:20:36,020 --> 00:20:41,540
that there's a nice introduction to

00:20:39,290 --> 00:20:42,800
using map filter and reduce which is the

00:20:41,540 --> 00:20:46,610
approach that suggests for doing

00:20:42,800 --> 00:20:50,750
functional in Python dive into pythons

00:20:46,610 --> 00:20:52,430
got a chapter on the Python practice

00:20:50,750 --> 00:20:54,050
book has a whole lot of exercises which

00:20:52,430 --> 00:20:57,470
would be good for helping you learn how

00:20:54,050 --> 00:20:59,540
to apply it and I haven't had a chance

00:20:57,470 --> 00:21:02,360
to look at this book yet because I only

00:20:59,540 --> 00:21:03,560
found out about it on Friday but it's

00:21:02,360 --> 00:21:05,780
about functional programming in Python

00:21:03,560 --> 00:21:08,330
so you could take a look at it and see

00:21:05,780 --> 00:21:09,620
if you like it it sounds from my brief

00:21:08,330 --> 00:21:11,030
look it does sound like it's more about

00:21:09,620 --> 00:21:16,070
introducing the paradigm than Python

00:21:11,030 --> 00:21:17,330
which is good but since it's mainly a

00:21:16,070 --> 00:21:19,160
lot of functional is done in other

00:21:17,330 --> 00:21:23,600
languages there are resources in other

00:21:19,160 --> 00:21:25,070
languages I'd suggest I really liked the

00:21:23,600 --> 00:21:27,020
functional programming principles in

00:21:25,070 --> 00:21:28,400
scala course on Coursera that's one of

00:21:27,020 --> 00:21:29,960
the things I got started with when I

00:21:28,400 --> 00:21:32,030
moved to one of our Scala teams they

00:21:29,960 --> 00:21:35,360
gave me a week to go and do that so I'd

00:21:32,030 --> 00:21:37,640
have a clue what to do and if you prefer

00:21:35,360 --> 00:21:39,740
books there's a book on functional

00:21:37,640 --> 00:21:44,300
programming in Scala and all of these

00:21:39,740 --> 00:21:47,510
are more focused on the principles and

00:21:44,300 --> 00:21:49,130
the paradigm rather than on the language

00:21:47,510 --> 00:21:52,400
but you have to use a language to do it

00:21:49,130 --> 00:21:54,590
of course if you want to know more about

00:21:52,400 --> 00:21:56,720
monads since I could only give it a very

00:21:54,590 --> 00:21:59,360
brief flyby treatment since it wasn't

00:21:56,720 --> 00:22:00,440
the main topic refactoring review as

00:21:59,360 --> 00:22:01,610
Marie knows it's really good to talk

00:22:00,440 --> 00:22:04,520
about it gives you a whole lot of

00:22:01,610 --> 00:22:06,110
examples and you should be out even it

00:22:04,520 --> 00:22:07,549
is in Ruby but you should be able to

00:22:06,110 --> 00:22:09,289
follow up quite well

00:22:07,549 --> 00:22:10,940
it's my favorite marino tutorial because

00:22:09,289 --> 00:22:15,080
it's a lot easier to understand the most

00:22:10,940 --> 00:22:17,239
of them are and there's some cool

00:22:15,080 --> 00:22:18,679
functional training that I also helped

00:22:17,239 --> 00:22:22,789
me get started but one of my colleagues

00:22:18,679 --> 00:22:24,619
worked on and if you prefer to have a

00:22:22,789 --> 00:22:26,149
play with Haskell there's a course that

00:22:24,619 --> 00:22:31,629
mixto produced it is apparently very

00:22:26,149 --> 00:22:34,009
good but I haven't done it myself and

00:22:31,629 --> 00:22:35,480
what this all comes back to for me

00:22:34,009 --> 00:22:38,210
stopping things from changing behind my

00:22:35,480 --> 00:22:38,779
back stopping the state mutating behind

00:22:38,210 --> 00:22:40,879
my back

00:22:38,779 --> 00:22:42,590
stopping side effects that I don't know

00:22:40,879 --> 00:22:44,600
about happening behind my back to make

00:22:42,590 --> 00:22:51,159
everything more explicit and easier to

00:22:44,600 --> 00:22:51,159
reason about and do we have questions

00:22:58,130 --> 00:23:16,559
okay thanks Bianca we've got time for a

00:23:01,049 --> 00:23:19,860
few questions so I've seen a few

00:23:16,559 --> 00:23:22,260
libraries in Python and I think Robi try

00:23:19,860 --> 00:23:24,720
to force you into being immutable like

00:23:22,260 --> 00:23:26,549
for example classes that count that

00:23:24,720 --> 00:23:29,580
throw exceptions when you try to modify

00:23:26,549 --> 00:23:31,080
something and do other things that you

00:23:29,580 --> 00:23:32,159
shouldn't be like prevent you from doing

00:23:31,080 --> 00:23:34,710
other thing that shouldn't be doing

00:23:32,159 --> 00:23:36,659
however in my opinion that have been

00:23:34,710 --> 00:23:37,020
that nice to use so what's your take on

00:23:36,659 --> 00:23:39,929
that

00:23:37,020 --> 00:23:42,480
versus someone taking your personal code

00:23:39,929 --> 00:23:46,260
having no idea and just omit a Eddy

00:23:42,480 --> 00:23:48,720
mutation to the middle of it sir I'm not

00:23:46,260 --> 00:23:54,299
familiar with any of the tools in Python

00:23:48,720 --> 00:23:57,179
I do Ruby for my job but in Ruby good

00:23:54,299 --> 00:23:59,340
luck with libraries is what I'd say your

00:23:57,179 --> 00:24:00,840
libraries are probably gonna be mutating

00:23:59,340 --> 00:24:03,120
things you'd have a lot of trouble

00:24:00,840 --> 00:24:07,130
finding libraries that don't mutate

00:24:03,120 --> 00:24:09,779
things everywhere so I'd probably I

00:24:07,130 --> 00:24:12,649
prefer to just may like enforcement more

00:24:09,779 --> 00:24:17,159
through code review then through

00:24:12,649 --> 00:24:20,909
technical means and you may have a good

00:24:17,159 --> 00:24:23,669
reason for mutating for example there

00:24:20,909 --> 00:24:27,450
was the last time I mutated in something

00:24:23,669 --> 00:24:29,279
I wrote it halves the time it has the

00:24:27,450 --> 00:24:30,480
run time of the method and it was

00:24:29,279 --> 00:24:33,690
something we'd had performance problems

00:24:30,480 --> 00:24:35,270
with before so I probably enforce its

00:24:33,690 --> 00:24:41,279
record review rather than those means

00:24:35,270 --> 00:24:42,360
thanks thanks could you maybe touch on

00:24:41,279 --> 00:24:46,140
some of the performance implications

00:24:42,360 --> 00:24:48,000
we've - if you're producing new objects

00:24:46,140 --> 00:24:54,720
like I know map and filter are really

00:24:48,000 --> 00:24:56,490
highly optimized classes you know what

00:24:54,720 --> 00:25:00,500
potential performance implications there

00:24:56,490 --> 00:25:02,870
are for that um I expect it

00:25:00,500 --> 00:25:05,659
I haven't benchmarked it so I'm kind of

00:25:02,870 --> 00:25:07,700
guessing I expect from what I know of

00:25:05,659 --> 00:25:10,460
other languages and a bit of guessing I

00:25:07,700 --> 00:25:11,690
expect it would be a bit slower so maybe

00:25:10,460 --> 00:25:15,049
if you're trying to get every last bit

00:25:11,690 --> 00:25:16,309
of performance out of that maybe not the

00:25:15,049 --> 00:25:21,260
best approach

00:25:16,309 --> 00:25:22,610
but if you're not trying to get every

00:25:21,260 --> 00:25:23,650
last bit of performance I reckon it'd

00:25:22,610 --> 00:25:25,909
probably be okay

00:25:23,650 --> 00:25:29,590
maybe see if you have problems with it

00:25:25,909 --> 00:25:35,360
and deal with it then since it would be

00:25:29,590 --> 00:25:40,400
it would be you could just switch any

00:25:35,360 --> 00:25:42,110
more questions we'll be under I I had

00:25:40,400 --> 00:25:45,980
one right at the beginning of the talk

00:25:42,110 --> 00:25:49,070
you mentioned that first-class objects

00:25:45,980 --> 00:25:52,039
were useful but it sounded like not

00:25:49,070 --> 00:25:54,530
necessary for functional programming our

00:25:52,039 --> 00:25:57,770
first class function is class functions

00:25:54,530 --> 00:25:59,330
things I other languages that support

00:25:57,770 --> 00:26:01,760
functional programming that don't

00:25:59,330 --> 00:26:04,250
support first-class functions as

00:26:01,760 --> 00:26:09,919
first-class functions um I think it

00:26:04,250 --> 00:26:12,020
would be possible to avoid side effects

00:26:09,919 --> 00:26:13,730
in mutation without it but I think it

00:26:12,020 --> 00:26:16,159
would be a whole world of pain without

00:26:13,730 --> 00:26:17,570
hire without having access to

00:26:16,159 --> 00:26:22,400
first-class functions and higher-order

00:26:17,570 --> 00:26:26,350
functions if there no more questions

00:26:22,400 --> 00:26:26,350

YouTube URL: https://www.youtube.com/watch?v=LkpHQL863mw


