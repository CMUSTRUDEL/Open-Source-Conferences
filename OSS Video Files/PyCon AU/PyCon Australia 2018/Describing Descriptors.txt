Title: Describing Descriptors
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Matthew Egan

https://2018.pycon-au.org/talks/42582-describing-descriptors/

Descriptors are a little known feature of Python. They provide a way for a programmer to customize the storage and retrieval of different instance variables. In this talk, you will learn about the descriptor protocol, what it can be used for, and how to implement a descriptor.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:06,750
a welcome to the Saturday morning

00:00:02,639 --> 00:00:10,260
session and introduce our first speaker

00:00:06,750 --> 00:00:12,170
Matthew Egan is a full-stack dev and

00:00:10,260 --> 00:00:15,150
he's here to talk to you about

00:00:12,170 --> 00:00:16,920
describing descriptors we will have

00:00:15,150 --> 00:00:19,140
questions at the end of the talk so just

00:00:16,920 --> 00:00:27,900
hold anything from there Thank You

00:00:19,140 --> 00:00:29,670
Matthew hi all my name is Matt Egan and

00:00:27,900 --> 00:00:33,210
today I'm gonna be talking to you about

00:00:29,670 --> 00:00:35,610
descriptors so before we get started you

00:00:33,210 --> 00:00:37,230
already know my name I work at DB pay

00:00:35,610 --> 00:00:39,180
which is company here in Sydney and

00:00:37,230 --> 00:00:42,629
we're focusing on virtual cards and an

00:00:39,180 --> 00:00:44,489
expense management platform so if you

00:00:42,629 --> 00:00:47,219
want to find me online all my links are

00:00:44,489 --> 00:00:49,890
up on the slides and they will be up

00:00:47,219 --> 00:00:51,480
there at the end so before we get

00:00:49,890 --> 00:00:53,610
started I'd like to say thanks to a few

00:00:51,480 --> 00:00:55,620
people so I'd like to thank Adam and

00:00:53,610 --> 00:00:59,969
Chris for technical review and Daniel

00:00:55,620 --> 00:01:03,030
and Russell for speaker curation so

00:00:59,969 --> 00:01:04,559
who's this talk for so I'm aiming this

00:01:03,030 --> 00:01:07,470
talk today at anyone who's comfortable

00:01:04,559 --> 00:01:09,060
with classes in Python however I won't

00:01:07,470 --> 00:01:10,860
be going as deep as meta classes in this

00:01:09,060 --> 00:01:15,360
talk but there are some features that

00:01:10,860 --> 00:01:16,320
you could use meta classes with so why

00:01:15,360 --> 00:01:18,150
do I want to give a talk about

00:01:16,320 --> 00:01:19,799
descriptors well I believe that

00:01:18,150 --> 00:01:22,020
descriptors are quite a hidden feature

00:01:19,799 --> 00:01:24,060
of Python and while they are covered in

00:01:22,020 --> 00:01:26,070
the official documentation they tend not

00:01:24,060 --> 00:01:29,070
to be covered in other video resources

00:01:26,070 --> 00:01:30,240
and tutorials also as an application

00:01:29,070 --> 00:01:33,270
developer I didn't know about

00:01:30,240 --> 00:01:34,979
descriptors until recently and I have

00:01:33,270 --> 00:01:39,030
found that they are they tend to be used

00:01:34,979 --> 00:01:40,200
by a lot of library developers so

00:01:39,030 --> 00:01:43,579
throughout this talk I will be using

00:01:40,200 --> 00:01:46,049
Python 36 as Python 2 is now end-of-life

00:01:43,579 --> 00:01:47,759
if there's any backwards in patter

00:01:46,049 --> 00:01:51,659
bility issues I will try to raise them

00:01:47,759 --> 00:01:53,909
during the talk so to outline this talk

00:01:51,659 --> 00:01:56,189
today I'm going to be presenting to you

00:01:53,909 --> 00:01:58,229
a problem some solutions to this problem

00:01:56,189 --> 00:01:59,909
and a better solution which is going to

00:01:58,229 --> 00:02:04,890
use descriptors and why I think that's

00:01:59,909 --> 00:02:07,110
better so before we get started I'd like

00:02:04,890 --> 00:02:09,060
to cover a quick class so here we have a

00:02:07,110 --> 00:02:11,099
person class and you can see that it's

00:02:09,060 --> 00:02:13,650
got its initialization method with one

00:02:11,099 --> 00:02:15,510
attribute which is name

00:02:13,650 --> 00:02:17,189
below we can create a person which is

00:02:15,510 --> 00:02:19,560
going to be called Matt and we can

00:02:17,189 --> 00:02:21,989
access this name attribute using P dot

00:02:19,560 --> 00:02:24,360
name here this is just going to print

00:02:21,989 --> 00:02:27,689
Matt we can also reassign to these kind

00:02:24,360 --> 00:02:29,610
of attributes just by assigning to it so

00:02:27,689 --> 00:02:31,260
here we're going to assign Sam and again

00:02:29,610 --> 00:02:35,700
we can access it and see that the values

00:02:31,260 --> 00:02:37,590
change to Sam so now that will come

00:02:35,700 --> 00:02:39,180
forward with that class we'd like to

00:02:37,590 --> 00:02:41,310
look at it a bit more so this is a

00:02:39,180 --> 00:02:43,500
person and a person has a name and we'd

00:02:41,310 --> 00:02:45,450
like our names to be capitalized at the

00:02:43,500 --> 00:02:47,819
moment we can always we can pass in

00:02:45,450 --> 00:02:50,250
anything we want as the name and it's

00:02:47,819 --> 00:02:51,930
just going to stay as it is so as you

00:02:50,250 --> 00:02:53,940
saw in that last example we passed in

00:02:51,930 --> 00:02:57,859
Matt with location and it stayed

00:02:53,940 --> 00:02:57,859
lowercase and we wants to be capitalized

00:02:57,920 --> 00:03:03,389
so to demonstrate this on our left here

00:03:00,810 --> 00:03:05,790
we have our current person class which

00:03:03,389 --> 00:03:08,310
has Matt lowercase M and when we access

00:03:05,790 --> 00:03:11,280
it we get Matt with a lowercase but this

00:03:08,310 --> 00:03:13,859
is our ideal scenario we want to pass in

00:03:11,280 --> 00:03:16,500
Matt lowercase M get Matt with a capital

00:03:13,859 --> 00:03:21,329
then when we reassign the Sam we want to

00:03:16,500 --> 00:03:22,620
get Sam with a capital as well so the

00:03:21,329 --> 00:03:25,410
first solution that I'm going to present

00:03:22,620 --> 00:03:27,120
is the set at remitted so set etre is

00:03:25,410 --> 00:03:28,829
built into Python and allows us to

00:03:27,120 --> 00:03:32,040
customize the storage of different

00:03:28,829 --> 00:03:33,690
attributes on a class so this is going

00:03:32,040 --> 00:03:35,400
to get called whenever we try to set an

00:03:33,690 --> 00:03:38,220
instance variable and it's going to take

00:03:35,400 --> 00:03:39,989
the instance object itself the attribute

00:03:38,220 --> 00:03:41,549
name that we're trying to set and then

00:03:39,989 --> 00:03:46,049
the value we're trying to set for this

00:03:41,549 --> 00:03:47,849
attribute so to solve our problem using

00:03:46,049 --> 00:03:50,489
set otra you can see that we're

00:03:47,849 --> 00:03:51,720
declaring it on our person class then

00:03:50,489 --> 00:03:53,250
we're checking whether or not the

00:03:51,720 --> 00:03:55,409
attribute is indeed the name attribute

00:03:53,250 --> 00:03:56,959
and if it is we're going to capitalize

00:03:55,409 --> 00:03:59,280
the value and call the super method

00:03:56,959 --> 00:04:00,930
otherwise we're just going to call the

00:03:59,280 --> 00:04:06,359
regular super method and let the class

00:04:00,930 --> 00:04:08,220
do whatever it does so this solves our

00:04:06,359 --> 00:04:10,530
problem we can pass in Matt with

00:04:08,220 --> 00:04:13,139
lowercase M this is then going to call

00:04:10,530 --> 00:04:15,930
set etre with the attribute name being

00:04:13,139 --> 00:04:18,120
named itself and the value being Matt in

00:04:15,930 --> 00:04:19,500
lower case it's going to recognize that

00:04:18,120 --> 00:04:21,419
this is the name attribute and

00:04:19,500 --> 00:04:24,180
capitalized the value before setting it

00:04:21,419 --> 00:04:27,480
on the instance attribute itself so then

00:04:24,180 --> 00:04:30,300
when we access this variable with Peter

00:04:27,480 --> 00:04:32,190
we get Matt with a capital M the same

00:04:30,300 --> 00:04:34,440
process happens when we try to reassign

00:04:32,190 --> 00:04:36,330
to Sam it's going to try to call set a

00:04:34,440 --> 00:04:37,500
trial with the attribute being named and

00:04:36,330 --> 00:04:39,720
the value being lowercase Sam

00:04:37,500 --> 00:04:41,460
capitalized the value and store it so

00:04:39,720 --> 00:04:46,830
then when we access it we get Sam with

00:04:41,460 --> 00:04:49,410
the capital S so this solution works and

00:04:46,830 --> 00:04:51,240
it does the job however it is locked to

00:04:49,410 --> 00:05:07,410
this class if we want to take this

00:04:51,240 --> 00:05:09,030
functionality if we want to take this

00:05:07,410 --> 00:05:11,370
functionality to other classes that

00:05:09,030 --> 00:05:13,470
aren't subclasses of this person class

00:05:11,370 --> 00:05:18,240
we need to copy our code or somehow

00:05:13,470 --> 00:05:20,720
refactor it our next solution is using

00:05:18,240 --> 00:05:24,630
the app property and app name sedima

00:05:20,720 --> 00:05:27,330
decorators so here we're creating a

00:05:24,630 --> 00:05:29,070
property called name so this is going to

00:05:27,330 --> 00:05:30,840
be our getter method and you can see

00:05:29,070 --> 00:05:33,120
that it's returning self dot underscore

00:05:30,840 --> 00:05:36,060
name we also have a setter method here

00:05:33,120 --> 00:05:37,950
which is the same name and then it's

00:05:36,060 --> 00:05:40,800
gonna take in the value capitalize it

00:05:37,950 --> 00:05:42,420
and store it on underscore name do you

00:05:40,800 --> 00:05:44,430
know that we are actually storing this

00:05:42,420 --> 00:05:47,700
on underscore name not name because

00:05:44,430 --> 00:05:49,470
otherwise we'd have name clashing so it

00:05:47,700 --> 00:05:51,650
is important to note that property is

00:05:49,470 --> 00:05:56,010
actually implemented as a descriptor

00:05:51,650 --> 00:05:57,870
however is an abstraction that doesn't

00:05:56,010 --> 00:06:03,330
provide everything that a descriptor

00:05:57,870 --> 00:06:05,040
could so this is also a method that is

00:06:03,330 --> 00:06:07,050
going to solve our problem so we can

00:06:05,040 --> 00:06:09,090
pass in Matt this is then going to call

00:06:07,050 --> 00:06:10,890
our setter method when it tries to set

00:06:09,090 --> 00:06:12,450
self dot name this is going to

00:06:10,890 --> 00:06:14,430
capitalize the value and store it and

00:06:12,450 --> 00:06:16,050
then when we access it using p dot name

00:06:14,430 --> 00:06:17,880
it's just going to return that value

00:06:16,050 --> 00:06:19,320
that's stored in underscore name which

00:06:17,880 --> 00:06:21,570
in this case is Matt with a capital m

00:06:19,320 --> 00:06:26,190
and then the same process follows when

00:06:21,570 --> 00:06:28,500
we try to reassign to Sam so again this

00:06:26,190 --> 00:06:30,840
is a perfectly valid solution it does

00:06:28,500 --> 00:06:32,700
the job however it is still walked to

00:06:30,840 --> 00:06:34,680
this class and you can imagine that if

00:06:32,700 --> 00:06:36,540
we had a number of different attributes

00:06:34,680 --> 00:06:38,190
that we wanted to customize the class

00:06:36,540 --> 00:06:41,120
source code would get quite long and

00:06:38,190 --> 00:06:43,430
verbose so

00:06:41,120 --> 00:06:44,900
what if we could just do this so what if

00:06:43,430 --> 00:06:47,690
we could just declare that name is

00:06:44,900 --> 00:06:49,520
always a capitalized value furthermore

00:06:47,690 --> 00:06:51,860
what if we could declare that we have

00:06:49,520 --> 00:06:55,820
two capitalized values without having to

00:06:51,860 --> 00:06:57,380
make the source code quite long so this

00:06:55,820 --> 00:06:59,900
is all possible using the descriptor

00:06:57,380 --> 00:07:01,970
protocol in Python and it ultimately

00:06:59,900 --> 00:07:03,590
leads to simple class code and because

00:07:01,970 --> 00:07:05,449
the script is implemented as classes

00:07:03,590 --> 00:07:07,610
they were usable and this is going to

00:07:05,449 --> 00:07:12,500
basically wrap up all your logic and

00:07:07,610 --> 00:07:14,870
lead to greater maintainability so the

00:07:12,500 --> 00:07:16,880
descriptor protocol is exposed by Python

00:07:14,870 --> 00:07:19,699
as a way to customize the storage and

00:07:16,880 --> 00:07:21,289
retrieval of instance attributes as I

00:07:19,699 --> 00:07:22,580
said before they are implemented as

00:07:21,289 --> 00:07:26,750
classes which means that they're

00:07:22,580 --> 00:07:29,120
self-contained and reusable so the

00:07:26,750 --> 00:07:30,650
implementer descriptor there's four

00:07:29,120 --> 00:07:32,990
different methods that we can implement

00:07:30,650 --> 00:07:34,490
so we can implement the get method which

00:07:32,990 --> 00:07:37,070
is for customizing the retrieval of

00:07:34,490 --> 00:07:39,800
instance attributes set method for the

00:07:37,070 --> 00:07:40,910
storage delete for deletion and as a

00:07:39,800 --> 00:07:44,419
Python 3:6

00:07:40,910 --> 00:07:46,099
the setname method so set name is an

00:07:44,419 --> 00:07:48,020
interesting one because it's only called

00:07:46,099 --> 00:07:51,169
on class creation rather than instance

00:07:48,020 --> 00:07:53,120
creation all the others get called

00:07:51,169 --> 00:07:55,520
whenever you try to set delete or get

00:07:53,120 --> 00:07:56,870
from some instance attribute and if you

00:07:55,520 --> 00:07:59,660
wanted to replicate set names

00:07:56,870 --> 00:08:02,630
functionality in versions prior to 3.6

00:07:59,660 --> 00:08:04,550
you'd either need to use meta classes or

00:08:02,630 --> 00:08:06,440
passing the name when you initialize the

00:08:04,550 --> 00:08:11,240
descriptor although that could have some

00:08:06,440 --> 00:08:14,120
human error so if we look at all the

00:08:11,240 --> 00:08:15,650
public github repositories to see how

00:08:14,120 --> 00:08:17,870
often these kind of methods are

00:08:15,650 --> 00:08:19,910
implemented we can see that get is

00:08:17,870 --> 00:08:22,610
implemented at about 1.2 million times

00:08:19,910 --> 00:08:24,620
set is implemented about 600,000 times

00:08:22,610 --> 00:08:26,780
deletes about a hundred thousand times

00:08:24,620 --> 00:08:28,849
and set name although miniscule on this

00:08:26,780 --> 00:08:30,860
chart is actually implemented about two

00:08:28,849 --> 00:08:32,959
thousand times that's not surprising

00:08:30,860 --> 00:08:36,320
because as I said before it's only been

00:08:32,959 --> 00:08:38,300
available since 3.6 while these numbers

00:08:36,320 --> 00:08:39,979
don't really mean too much you can

00:08:38,300 --> 00:08:43,599
imagine that the proportions are quite

00:08:39,979 --> 00:08:43,599
similar in close source software

00:08:43,750 --> 00:08:49,940
so our first descriptive method is the

00:08:46,520 --> 00:08:52,220
get method so the get method takes in

00:08:49,940 --> 00:08:54,740
the descriptor object itself the

00:08:52,220 --> 00:08:56,810
instance that were operating on and

00:08:54,740 --> 00:08:58,610
the owning class so if we were

00:08:56,810 --> 00:09:00,589
implementing our capitalized value

00:08:58,610 --> 00:09:04,399
descriptor which I'll show you shortly

00:09:00,589 --> 00:09:06,890
for a person you can see that the self

00:09:04,399 --> 00:09:10,040
here this is going to be the capitalized

00:09:06,890 --> 00:09:12,020
value descriptor itself the instance is

00:09:10,040 --> 00:09:14,209
going to be our instance of the person

00:09:12,020 --> 00:09:19,100
class and the owner is going to be the

00:09:14,209 --> 00:09:21,050
person class itself our next method is

00:09:19,100 --> 00:09:22,490
the set method so this is going to get

00:09:21,050 --> 00:09:25,490
called whenever you try to set an

00:09:22,490 --> 00:09:27,589
instance attribute so it takes in the

00:09:25,490 --> 00:09:29,330
descriptor itself it takes in the

00:09:27,589 --> 00:09:30,980
instance that we're operating on and it

00:09:29,330 --> 00:09:33,320
also takes in the value that we're

00:09:30,980 --> 00:09:35,990
trying to set so do note that this

00:09:33,320 --> 00:09:37,370
doesn't actually require us to pass in

00:09:35,990 --> 00:09:38,899
the name of the attribute that we're

00:09:37,370 --> 00:09:42,130
trying to set it as the descriptor

00:09:38,899 --> 00:09:45,110
doesn't really care about that

00:09:42,130 --> 00:09:46,370
our third methods the delete method this

00:09:45,110 --> 00:09:48,860
is going to be called whenever we try to

00:09:46,370 --> 00:09:50,690
delete an instance attribute so it only

00:09:48,860 --> 00:09:54,860
takes in the descriptor object and the

00:09:50,690 --> 00:09:56,899
instance that we're operating on and our

00:09:54,860 --> 00:09:59,540
final method is set name and it's going

00:09:56,899 --> 00:10:01,339
to take in the description itself the

00:09:59,540 --> 00:10:03,290
owning class which in this case was

00:10:01,339 --> 00:10:04,550
going to be the person class and it's

00:10:03,290 --> 00:10:07,040
going to take in the name of the

00:10:04,550 --> 00:10:08,600
attribute that we're trying to set no

00:10:07,040 --> 00:10:10,339
this doesn't taking the instance

00:10:08,600 --> 00:10:13,399
argument because it's only called on

00:10:10,339 --> 00:10:14,720
class creation so if we had our person

00:10:13,399 --> 00:10:18,050
class and then we had a hundred

00:10:14,720 --> 00:10:22,790
instances of persons this would only get

00:10:18,050 --> 00:10:24,170
called once so there are two types of

00:10:22,790 --> 00:10:25,940
descriptors that are covered in the

00:10:24,170 --> 00:10:28,040
Python documentation and we have the

00:10:25,940 --> 00:10:31,070
data descriptor and non-data descriptive

00:10:28,040 --> 00:10:33,800
so data descriptors are any object in

00:10:31,070 --> 00:10:36,829
Python that implement the set method the

00:10:33,800 --> 00:10:39,560
delete method or either and non-data

00:10:36,829 --> 00:10:41,690
descriptor z' are any descriptor that

00:10:39,560 --> 00:10:46,430
doesn't implement set or delete so

00:10:41,690 --> 00:10:48,020
essentially they only implement get so

00:10:46,430 --> 00:10:50,149
descriptors aren't all created equal

00:10:48,020 --> 00:10:52,550
they do follow a descriptive precedence

00:10:50,149 --> 00:10:54,350
so when you try to access an attribute

00:10:52,550 --> 00:10:57,260
in Python it goes through and lookup

00:10:54,350 --> 00:10:59,180
process this lookup process is a little

00:10:57,260 --> 00:11:01,190
bit more detailed than this but this is

00:10:59,180 --> 00:11:02,870
the section that we care about today so

00:11:01,190 --> 00:11:05,120
you can see that the first thing that it

00:11:02,870 --> 00:11:07,579
looks at is is this attribute a data

00:11:05,120 --> 00:11:08,209
descriptor if it is a dollar descriptor

00:11:07,579 --> 00:11:09,709
then it's

00:11:08,209 --> 00:11:11,389
going to call the corresponding method

00:11:09,709 --> 00:11:14,209
for whatever you're trying to do be

00:11:11,389 --> 00:11:16,100
accessing retrieving deleting if it's

00:11:14,209 --> 00:11:18,259
not a data descriptor then it's gonna

00:11:16,100 --> 00:11:20,629
check is this in the instances

00:11:18,259 --> 00:11:22,579
dictionary if it is in the instance this

00:11:20,629 --> 00:11:24,290
dictionary it'll return it or change the

00:11:22,579 --> 00:11:27,050
value for whatever you're trying to do

00:11:24,290 --> 00:11:29,029
if it's not in the dictionary and it is

00:11:27,050 --> 00:11:30,679
a non-data descriptor then it'll call

00:11:29,029 --> 00:11:32,980
the non-data district and descript it

00:11:30,679 --> 00:11:32,980
for you

00:11:43,580 --> 00:11:47,910
so the rest of this talk is going to be

00:11:45,840 --> 00:11:50,190
about data descriptors however I do want

00:11:47,910 --> 00:11:54,120
to cover non data scripts is quite

00:11:50,190 --> 00:11:55,500
quickly so a lot of things that you do

00:11:54,120 --> 00:11:57,900
in Python with a lot of different

00:11:55,500 --> 00:12:02,780
libraries they occasionally seem to be

00:11:57,900 --> 00:12:05,760
magic descriptors are the magic right so

00:12:02,780 --> 00:12:07,920
you might be familiar with static method

00:12:05,760 --> 00:12:09,720
and class method and maybe ABC abstract

00:12:07,920 --> 00:12:13,230
method and the funk tools partial method

00:12:09,720 --> 00:12:16,140
these are all possibly sorry these can

00:12:13,230 --> 00:12:18,990
all be re-implemented in pure Python as

00:12:16,140 --> 00:12:21,030
non-data descriptor z' so that's

00:12:18,990 --> 00:12:22,770
implementing the get method and changing

00:12:21,030 --> 00:12:26,610
around the arguments to achieve whatever

00:12:22,770 --> 00:12:28,830
their purpose is so moving on from that

00:12:26,610 --> 00:12:30,180
this will all be about data descriptors

00:12:28,830 --> 00:12:31,980
now so the first thing that we're going

00:12:30,180 --> 00:12:34,830
to do is cover the weak key dictionary

00:12:31,980 --> 00:12:36,660
so when we implemented a script R it's

00:12:34,830 --> 00:12:39,360
going to look after all the values for

00:12:36,660 --> 00:12:42,030
some attribute for some class not for

00:12:39,360 --> 00:12:43,980
some instance so again if we had our

00:12:42,030 --> 00:12:46,320
person class and we had a hundred

00:12:43,980 --> 00:12:48,390
different person instances we would only

00:12:46,320 --> 00:12:50,850
have one descriptor instance which is

00:12:48,390 --> 00:12:53,160
going to look after all the values for

00:12:50,850 --> 00:12:54,810
one particular attribute on that person

00:12:53,160 --> 00:12:57,780
in our case it's going to be the name

00:12:54,810 --> 00:13:00,330
attribute so because of this we need

00:12:57,780 --> 00:13:02,730
somewhere to store these values this is

00:13:00,330 --> 00:13:04,880
usually stored on the instances

00:13:02,730 --> 00:13:07,290
dictionary itself or somewhere else

00:13:04,880 --> 00:13:08,760
however for the purpose of this talk I'm

00:13:07,290 --> 00:13:11,310
going to cover the weak key dictionary

00:13:08,760 --> 00:13:15,120
because it does lead to simpler code and

00:13:11,310 --> 00:13:16,920
it'll be easier to understand so the

00:13:15,120 --> 00:13:18,540
weak key dictionary is provided in the

00:13:16,920 --> 00:13:21,180
standard library from the weak ref

00:13:18,540 --> 00:13:23,130
module and it essentially behaves like a

00:13:21,180 --> 00:13:26,310
regular dictionary however when the

00:13:23,130 --> 00:13:29,220
reference to the key is gone it deletes

00:13:26,310 --> 00:13:30,510
the entire entry from the dictionary so

00:13:29,220 --> 00:13:32,580
you can see that we have our person

00:13:30,510 --> 00:13:34,560
class and then we're going to create a

00:13:32,580 --> 00:13:37,200
dictionary called data and then when we

00:13:34,560 --> 00:13:39,750
access data data you can see on the

00:13:37,200 --> 00:13:41,880
right hand side that we have an empty

00:13:39,750 --> 00:13:43,890
dictionary then we're going to add two

00:13:41,880 --> 00:13:45,600
person objects to this dictionary with

00:13:43,890 --> 00:13:47,370
the corresponding keys sorry the

00:13:45,600 --> 00:13:49,260
corresponding values one and two and

00:13:47,370 --> 00:13:50,430
then when we print the data we're going

00:13:49,260 --> 00:13:54,089
to have two entries in our dictionary

00:13:50,430 --> 00:13:55,320
one for each of the people and then when

00:13:54,089 --> 00:13:57,780
we delete person one

00:13:55,320 --> 00:13:59,370
without touching the dictionary you can

00:13:57,780 --> 00:14:05,790
see that the value in the dictionary has

00:13:59,370 --> 00:14:07,560
changed to only contain person 2 so when

00:14:05,790 --> 00:14:10,170
we're using descriptors we need to

00:14:07,560 --> 00:14:12,210
declare them on a class like so so note

00:14:10,170 --> 00:14:14,910
this isn't inside our net method it is

00:14:12,210 --> 00:14:16,320
declared as a class attribute so here

00:14:14,910 --> 00:14:18,330
we're saying that we have a class called

00:14:16,320 --> 00:14:20,310
my class and it hasn't attributed my

00:14:18,330 --> 00:14:21,960
attribute and we're using a descriptor

00:14:20,310 --> 00:14:24,960
called my descriptor which we're going

00:14:21,960 --> 00:14:27,090
to initialize here so at this point the

00:14:24,960 --> 00:14:29,520
setname method will be called and it

00:14:27,090 --> 00:14:31,710
will pass in my attribute as that name

00:14:29,520 --> 00:14:37,320
so if you need to use it for whatever

00:14:31,710 --> 00:14:38,730
reason this is where it happens so

00:14:37,320 --> 00:14:40,110
here's a basic descriptor it's

00:14:38,730 --> 00:14:42,060
essentially going to behave like a

00:14:40,110 --> 00:14:43,500
regular Python instance attribute you

00:14:42,060 --> 00:14:47,970
pretty much would never use this

00:14:43,500 --> 00:14:49,710
descriptor but it is a good example so

00:14:47,970 --> 00:14:51,780
it's just a regular class in our

00:14:49,710 --> 00:14:53,100
initialization method we're creating a

00:14:51,780 --> 00:14:55,050
week key dictionary we're just going to

00:14:53,100 --> 00:14:57,750
store all our values for this attribute

00:14:55,050 --> 00:14:58,980
and then in our get method here we're

00:14:57,750 --> 00:15:00,720
taking in the instance in the owner

00:14:58,980 --> 00:15:03,060
we're checking whether or not the

00:15:00,720 --> 00:15:05,070
instance is none so we do need to do

00:15:03,060 --> 00:15:07,140
this because we could potentially try to

00:15:05,070 --> 00:15:10,590
call this attribute as a class attribute

00:15:07,140 --> 00:15:12,870
so if we go back to the last slide it is

00:15:10,590 --> 00:15:15,060
possible for us to say my class dot my

00:15:12,870 --> 00:15:17,130
attribute and that would call our data

00:15:15,060 --> 00:15:19,320
descriptor so we need to do something

00:15:17,130 --> 00:15:21,090
here so what we're gonna do is just

00:15:19,320 --> 00:15:22,320
return the descriptor object itself

00:15:21,090 --> 00:15:25,980
because it's the only thing that makes

00:15:22,320 --> 00:15:27,810
sense if it is an instance we're just

00:15:25,980 --> 00:15:29,520
gonna return whatever we have stored in

00:15:27,810 --> 00:15:34,290
our dictionary for this particular

00:15:29,520 --> 00:15:36,090
instance then you know set method we're

00:15:34,290 --> 00:15:37,710
taking in the instance and the value

00:15:36,090 --> 00:15:39,720
that we're trying to set and we just can

00:15:37,710 --> 00:15:45,360
store the value in our dictionary at

00:15:39,720 --> 00:15:47,070
this instance is key so moving on to a

00:15:45,360 --> 00:15:49,290
more complex example here's your

00:15:47,070 --> 00:15:50,520
capitalized value descriptor so this is

00:15:49,290 --> 00:15:53,310
going to be how we're gonna solve our

00:15:50,520 --> 00:15:54,870
problem of capitalizing the name so

00:15:53,310 --> 00:15:56,580
again we're going to use a weak key

00:15:54,870 --> 00:15:59,400
dictionary to create a place to store

00:15:56,580 --> 00:16:01,530
all our values then in our get method

00:15:59,400 --> 00:16:04,260
it's gonna be exactly the same check for

00:16:01,530 --> 00:16:06,120
the class case if so return the

00:16:04,260 --> 00:16:07,470
descriptor itself otherwise we're just

00:16:06,120 --> 00:16:08,730
going to return whatever we have stored

00:16:07,470 --> 00:16:10,829
in our dictionary

00:16:08,730 --> 00:16:12,660
but in our set method we're going to

00:16:10,829 --> 00:16:15,360
capitalize the value and store it in the

00:16:12,660 --> 00:16:17,190
dictionary and then at the bottom here

00:16:15,360 --> 00:16:19,589
you can see that we're just declaring

00:16:17,190 --> 00:16:22,769
the capitalized value as our name

00:16:19,589 --> 00:16:26,579
attribute here and that's all we need to

00:16:22,769 --> 00:16:28,860
do for our person class so this is going

00:16:26,579 --> 00:16:31,350
to solve our problem so we can pass in

00:16:28,860 --> 00:16:33,600
Matt with a lowercase M that's going to

00:16:31,350 --> 00:16:36,720
try to assign self name to name in our

00:16:33,600 --> 00:16:38,760
initialization method Python is going to

00:16:36,720 --> 00:16:41,220
realize that name is a data descriptor

00:16:38,760 --> 00:16:42,510
because it implements the set method so

00:16:41,220 --> 00:16:45,899
it's going to call that set method

00:16:42,510 --> 00:16:48,209
passing in Matt as the value and P is

00:16:45,899 --> 00:16:50,010
the instance is then going to capitalize

00:16:48,209 --> 00:16:52,139
this value and store it in our week key

00:16:50,010 --> 00:16:54,420
dictionary for this particular instance

00:16:52,139 --> 00:16:56,130
then when we call P dot name it

00:16:54,420 --> 00:16:58,709
recognizes that name is a data

00:16:56,130 --> 00:17:01,320
dictionary or data descriptor and return

00:16:58,709 --> 00:17:04,589
Matt with a capital m by calling the get

00:17:01,320 --> 00:17:06,750
method then when we reassign P dot name

00:17:04,589 --> 00:17:08,549
equals Sam it's going to recognize it's

00:17:06,750 --> 00:17:10,410
a data descriptor call the set method

00:17:08,549 --> 00:17:12,689
capitalize the value and store it on the

00:17:10,410 --> 00:17:14,730
dictionary and then it's going to print

00:17:12,689 --> 00:17:17,549
P dot name which is going to call our

00:17:14,730 --> 00:17:21,990
get method which is going to be which is

00:17:17,549 --> 00:17:24,120
going to call Sam from the dictionary so

00:17:21,990 --> 00:17:26,220
descriptors have a few use cases so in

00:17:24,120 --> 00:17:30,179
this talk I've shown you how you can

00:17:26,220 --> 00:17:31,799
implement any customization for multiple

00:17:30,179 --> 00:17:34,380
attributes without caring about the name

00:17:31,799 --> 00:17:38,400
so if you know our set method sorry our

00:17:34,380 --> 00:17:40,080
set a try and property solutions you

00:17:38,400 --> 00:17:42,480
needed passing the name of whatever the

00:17:40,080 --> 00:17:43,549
attribute was whereas without a script R

00:17:42,480 --> 00:17:47,490
we don't really care

00:17:43,549 --> 00:17:49,919
Django or also uses descriptors to

00:17:47,490 --> 00:17:52,320
implement generic foreign keys and model

00:17:49,919 --> 00:17:54,390
managers we can use descriptors for

00:17:52,320 --> 00:17:55,980
implementing custom validations so if

00:17:54,390 --> 00:17:57,750
you were trying to create a phone number

00:17:55,980 --> 00:17:59,640
field or something like that you could

00:17:57,750 --> 00:18:01,290
use descriptors to do that and we can

00:17:59,640 --> 00:18:05,160
also use descriptors to provide better

00:18:01,290 --> 00:18:06,720
error messages for our customizations so

00:18:05,160 --> 00:18:08,880
here we have generic foreign keys in

00:18:06,720 --> 00:18:11,160
Django so this is just the set method

00:18:08,880 --> 00:18:14,070
and this is quite a novel way of storing

00:18:11,160 --> 00:18:15,690
two values on one instance attribute so

00:18:14,070 --> 00:18:17,790
it's going to take in the instance and

00:18:15,690 --> 00:18:19,260
the value it's going to grab the content

00:18:17,790 --> 00:18:20,400
type and the foreign key which is things

00:18:19,260 --> 00:18:21,760
that you don't really need to worry

00:18:20,400 --> 00:18:24,220
about right now

00:18:21,760 --> 00:18:27,010
and basically it's going to store two

00:18:24,220 --> 00:18:28,960
separate values on the instance here but

00:18:27,010 --> 00:18:30,880
it's only taking in one value which

00:18:28,960 --> 00:18:35,500
leads to a nicer user interface for the

00:18:30,880 --> 00:18:38,080
user of this particular library we also

00:18:35,500 --> 00:18:39,279
can do custom validation so here we're

00:18:38,080 --> 00:18:41,289
implementing a non-negative integer

00:18:39,279 --> 00:18:44,019
descriptor because we'd like to have an

00:18:41,289 --> 00:18:46,059
age attribute on a person so it's gonna

00:18:44,019 --> 00:18:48,250
have the regular initialization and get

00:18:46,059 --> 00:18:49,630
methods and then they are set we're

00:18:48,250 --> 00:18:52,000
gonna check whether or not it's an

00:18:49,630 --> 00:18:54,010
integer if it isn't an integer we're

00:18:52,000 --> 00:18:56,679
gonna raise tiger are saying that value

00:18:54,010 --> 00:18:59,139
is not of type int and if the value is

00:18:56,679 --> 00:19:01,539
less than zero we're gonna return a

00:18:59,139 --> 00:19:03,519
value error saying that it must be a

00:19:01,539 --> 00:19:05,919
non-negative integer otherwise we'll set

00:19:03,519 --> 00:19:07,840
the value fine so at the bottom here you

00:19:05,919 --> 00:19:10,299
can see that we're trying to assign P

00:19:07,840 --> 00:19:12,279
dot age to four this is fine we should

00:19:10,299 --> 00:19:14,470
try to assign Peter H to zero this is

00:19:12,279 --> 00:19:16,600
fine we try to assign Peter age to Matt

00:19:14,470 --> 00:19:19,990
this isn't fine at all because it's type

00:19:16,600 --> 00:19:21,909
error because Matt is a string and if we

00:19:19,990 --> 00:19:23,830
try to assign Peter age to negative one

00:19:21,909 --> 00:19:28,720
we get a value error because although

00:19:23,830 --> 00:19:31,210
it's an integer it's less than zero so

00:19:28,720 --> 00:19:32,740
our last descriptor had these top error

00:19:31,210 --> 00:19:34,120
messages where it would just say Matt is

00:19:32,740 --> 00:19:35,830
not of type in and must be a

00:19:34,120 --> 00:19:37,750
non-negative integer this isn't

00:19:35,830 --> 00:19:40,299
particularly useful for beginners so

00:19:37,750 --> 00:19:42,820
we'd like to prepend the error messages

00:19:40,299 --> 00:19:46,929
with the name of the attribute that

00:19:42,820 --> 00:19:49,750
we're trying to set so we can change our

00:19:46,929 --> 00:19:51,370
non negative integer descriptor to

00:19:49,750 --> 00:19:53,710
implement the set name field here a

00:19:51,370 --> 00:19:56,200
method here and all its gonna do is

00:19:53,710 --> 00:19:58,419
store the name on the descriptor itself

00:19:56,200 --> 00:20:02,399
and then in our set method we're going

00:19:58,419 --> 00:20:07,960
to use f strings and prepend the name

00:20:02,399 --> 00:20:10,269
before the error message so that's the

00:20:07,960 --> 00:20:14,919
end of the talk all the code is online

00:20:10,269 --> 00:20:16,360
at github above so before I finish up I

00:20:14,919 --> 00:20:19,000
just want to say that although although

00:20:16,360 --> 00:20:21,100
descriptors are quite powerful please

00:20:19,000 --> 00:20:22,510
don't go using them everywhere because

00:20:21,100 --> 00:20:25,360
when you have beginners come to your

00:20:22,510 --> 00:20:28,210
project you are in you are essentially

00:20:25,360 --> 00:20:29,409
adding more magic to your program so

00:20:28,210 --> 00:20:32,019
beginners are going to come in they're

00:20:29,409 --> 00:20:33,549
going to try to set things and they

00:20:32,019 --> 00:20:35,370
won't know all these side-effects that

00:20:33,549 --> 00:20:37,830
you've got going on under the hood

00:20:35,370 --> 00:20:39,840
so yeah be quiet

00:20:37,830 --> 00:20:50,550
think about descriptives before you

00:20:39,840 --> 00:20:52,230
implement them thank you thank you Matt

00:20:50,550 --> 00:20:54,540
for a great talk

00:20:52,230 --> 00:20:57,630
now unfortunately we're down to one mic

00:20:54,540 --> 00:20:59,970
so what we're going to do is we'll get

00:20:57,630 --> 00:21:01,920
questions by hand up I'll point someone

00:20:59,970 --> 00:21:04,350
out if you can yell out your question

00:21:01,920 --> 00:21:06,780
and then I'll get Matt to just repeat it

00:21:04,350 --> 00:21:08,520
for the video sorry for the technical

00:21:06,780 --> 00:21:21,660
glitches it wouldn't be a conference

00:21:08,520 --> 00:21:24,380
without them so the question was do they

00:21:21,660 --> 00:21:27,240
have any runtime performance penalty

00:21:24,380 --> 00:21:29,040
realistically that comes down to how you

00:21:27,240 --> 00:21:30,570
implement them if you're doing things

00:21:29,040 --> 00:21:33,440
inside your descriptors that are gonna

00:21:30,570 --> 00:21:36,480
be slow then yeah it's gonna add extra

00:21:33,440 --> 00:21:37,980
extra penalties on for you so if you're

00:21:36,480 --> 00:21:39,090
trying to like set cache values or

00:21:37,980 --> 00:21:42,180
something inside your descriptor or

00:21:39,090 --> 00:21:48,110
making external calls then yeah it's

00:21:42,180 --> 00:21:48,110
going to slow down your your program yes

00:21:59,090 --> 00:22:05,879
right so the question was can you chain

00:22:01,470 --> 00:22:07,440
descriptors so just to clarify do you

00:22:05,879 --> 00:22:12,179
want to add like multiple properties to

00:22:07,440 --> 00:22:15,840
one attribute I guess you could i

00:22:12,179 --> 00:22:17,429
haven't particularly done that but I

00:22:15,840 --> 00:22:19,350
imagine that way you could probably do

00:22:17,429 --> 00:22:21,210
is implement a descriptor and then

00:22:19,350 --> 00:22:23,730
implement another one which subclasses

00:22:21,210 --> 00:22:40,350
it and then add your extra validations

00:22:23,730 --> 00:22:44,879
there yes you would have to delete it

00:22:40,350 --> 00:22:46,200
off the class itself I think we can take

00:22:44,879 --> 00:22:50,299
that one offline if you want and we can

00:22:46,200 --> 00:22:50,299
play around with it yes

00:22:58,020 --> 00:23:11,280
I can't comment on that one again we can

00:23:03,090 --> 00:23:16,680
have a chat afterwards yes that's an

00:23:11,280 --> 00:23:18,210
interesting one you are sorry so the

00:23:16,680 --> 00:23:20,940
question was what happens when you try

00:23:18,210 --> 00:23:24,140
to pickle an object that has a

00:23:20,940 --> 00:23:28,410
descriptor on it I can't comment on that

00:23:24,140 --> 00:23:34,020
pickle is unsecure so please don't use

00:23:28,410 --> 00:23:40,880
it if you can avoid it sir any more

00:23:34,020 --> 00:23:40,880
questions yes up the back

00:23:42,560 --> 00:23:47,940
how do descriptors integrate with slots

00:23:45,770 --> 00:23:50,550
again I haven't played around with slots

00:23:47,940 --> 00:23:57,810
with descriptors yet but it is something

00:23:50,550 --> 00:23:58,950
that I will look into awesome well

00:23:57,810 --> 00:24:02,570
thanks for having me today

00:23:58,950 --> 00:24:02,570
and I hope you all will learn something

00:24:07,320 --> 00:24:11,590
I'd like to thank Matt again we're

00:24:09,790 --> 00:24:13,870
running a couple of minutes early so if

00:24:11,590 --> 00:24:16,210
anyone needs to do a room change you've

00:24:13,870 --> 00:24:19,290
got plenty of time and Matt please

00:24:16,210 --> 00:24:19,290

YouTube URL: https://www.youtube.com/watch?v=lmcgtUw5djw


