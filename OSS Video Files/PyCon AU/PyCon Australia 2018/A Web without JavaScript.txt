Title: A Web without JavaScript
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Russell Keith-Magee

https://2018.pycon-au.org/talks/43077-a-web-without-javascript/

In the browser, you can use any programming language you want... as long as it's JavaScript.

But what if you want to use a different language? In this talk, you'll learn how you can break out of the monolingual environment provided by the browser, and use Python (or any other language) instead.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,030 --> 00:00:04,410
alright let's kick this off welcome

00:00:02,220 --> 00:00:08,610
everyone to the second session of this

00:00:04,410 --> 00:00:12,599
trip this morning track this one we have

00:00:08,610 --> 00:00:15,000
Russ talking to us about writing things

00:00:12,599 --> 00:00:18,570
for the web using Inuit languages know

00:00:15,000 --> 00:00:21,180
languages that aren't JavaScript so are

00:00:18,570 --> 00:00:30,660
we all good

00:00:21,180 --> 00:00:32,759
please welcome Russ thank you very much

00:00:30,660 --> 00:00:34,620
Richard so yes as Richard said my name

00:00:32,759 --> 00:00:36,030
is Russell Keith McGee I come from logic

00:00:34,620 --> 00:00:38,790
knowing our country otherwise known as

00:00:36,030 --> 00:00:40,980
Perth Western Australia in my day job I

00:00:38,790 --> 00:00:43,350
am a senior data engineer at savato

00:00:40,980 --> 00:00:45,000
savanna is a market research company we

00:00:43,350 --> 00:00:46,500
use Python and data science to help

00:00:45,000 --> 00:00:48,510
brands to understand their customers

00:00:46,500 --> 00:00:50,100
they helped me get to conferences like

00:00:48,510 --> 00:00:53,100
Python and many others for which I'm

00:00:50,100 --> 00:00:54,750
extremely thankful if you have heard my

00:00:53,100 --> 00:00:55,980
name before though it's probably because

00:00:54,750 --> 00:00:59,070
I've been a member of the Django core

00:00:55,980 --> 00:01:00,420
team for a little over 12 years now now

00:00:59,070 --> 00:01:03,480
when I started with the Django project

00:01:00,420 --> 00:01:05,220
way back in 2006 the web was a very

00:01:03,480 --> 00:01:07,229
different beast to what we see today way

00:01:05,220 --> 00:01:09,840
back then the web was a very server

00:01:07,229 --> 00:01:11,010
oriented platform you wrote code there

00:01:09,840 --> 00:01:12,689
was going to run on your server which

00:01:11,010 --> 00:01:14,670
would then serve HTML documents to

00:01:12,689 --> 00:01:16,950
browsers if you wanted those HTML

00:01:14,670 --> 00:01:18,540
documents to be particularly fancy you

00:01:16,950 --> 00:01:22,680
might bust out some JavaScript to make

00:01:18,540 --> 00:01:24,659
them dynamic HTML or D HTML the idea of

00:01:22,680 --> 00:01:26,189
using Ajax to make pages not just

00:01:24,659 --> 00:01:27,990
dynamic in the menu responds to a

00:01:26,189 --> 00:01:30,210
mouse-click sense but in the content

00:01:27,990 --> 00:01:31,860
changes on the page over time sense was

00:01:30,210 --> 00:01:35,189
really only just starting to begin on

00:01:31,860 --> 00:01:36,689
the scene and in that world Python was

00:01:35,189 --> 00:01:38,700
right at home it didn't matter what

00:01:36,689 --> 00:01:40,710
libraries or runtimes the user had

00:01:38,700 --> 00:01:42,600
installed all code was running on the

00:01:40,710 --> 00:01:44,880
server in an environment that you as the

00:01:42,600 --> 00:01:46,320
developer controlled Python was a

00:01:44,880 --> 00:01:47,939
language that you develop your ideas

00:01:46,320 --> 00:01:49,740
quickly and had a rich ecosystem of

00:01:47,939 --> 00:01:52,799
libraries for business and system logic

00:01:49,740 --> 00:01:56,189
the end client never needed Python they

00:01:52,799 --> 00:01:58,110
just needed the browser but over the

00:01:56,189 --> 00:02:00,479
last 12 years the web has changed quite

00:01:58,110 --> 00:02:02,610
a bit what started as a little bit of

00:02:00,479 --> 00:02:04,649
JavaScript has now grown significantly

00:02:02,610 --> 00:02:06,960
and we're now in a situation whereby

00:02:04,649 --> 00:02:08,879
line of code count the amount of code

00:02:06,960 --> 00:02:10,349
needed by your front-end can quite often

00:02:08,879 --> 00:02:13,680
compete with the amount of code that is

00:02:10,349 --> 00:02:15,060
needed by your back-end but even though

00:02:13,680 --> 00:02:16,260
and because we're if they were seeing

00:02:15,060 --> 00:02:18,540
more logic on the front end we still

00:02:16,260 --> 00:02:20,430
need logic on the back end consider

00:02:18,540 --> 00:02:22,290
something like form validation logic if

00:02:20,430 --> 00:02:24,359
you want to make a user interface really

00:02:22,290 --> 00:02:26,939
responsive you need to do that on the

00:02:24,359 --> 00:02:28,829
client now nobody likes duplicating

00:02:26,939 --> 00:02:30,420
their logic we're going to avoid that

00:02:28,829 --> 00:02:32,909
duplication we have a problem the

00:02:30,420 --> 00:02:36,180
browser only supports one language and

00:02:32,909 --> 00:02:39,480
that language is JavaScript so what do

00:02:36,180 --> 00:02:40,950
we do well one option is to abandon any

00:02:39,480 --> 00:02:42,959
language other than JavaScript and just

00:02:40,950 --> 00:02:44,609
use JavaScript everywhere that line of

00:02:42,959 --> 00:02:46,409
thinking is basically what Boris nodejs

00:02:44,609 --> 00:02:48,689
and plenty of people have written plenty

00:02:46,409 --> 00:02:52,230
of great applications in node but this

00:02:48,689 --> 00:02:54,299
approach deeply concerns me poly lingual

00:02:52,230 --> 00:02:55,919
ISM speaking many languages be it human

00:02:54,299 --> 00:02:58,469
languages or computer languages is a

00:02:55,919 --> 00:03:00,120
good thing there are countless studies

00:02:58,469 --> 00:03:01,919
out there that reinforced the benefits

00:03:00,120 --> 00:03:03,590
of learning a second spoken language

00:03:01,919 --> 00:03:05,639
improvements in memory perception

00:03:03,590 --> 00:03:07,889
decision-making and problem solving in

00:03:05,639 --> 00:03:09,419
my 30 odd years of programming I have

00:03:07,889 --> 00:03:10,799
seen nothing to Bullards it leads me to

00:03:09,419 --> 00:03:12,900
believe that the same isn't true for

00:03:10,799 --> 00:03:14,849
programming languages learning a second

00:03:12,900 --> 00:03:16,980
or third or fourth programming language

00:03:14,849 --> 00:03:18,780
especially when it uses a completely

00:03:16,980 --> 00:03:20,729
different programming paradigm is a

00:03:18,780 --> 00:03:22,169
great way to encourage your brain to

00:03:20,729 --> 00:03:25,019
think about problems in different

00:03:22,169 --> 00:03:27,359
creative ways every programming language

00:03:25,019 --> 00:03:29,069
is very slightly different they each

00:03:27,359 --> 00:03:30,239
approach problems in different ways they

00:03:29,069 --> 00:03:32,579
have different assumptions and the

00:03:30,239 --> 00:03:36,060
ecosystems around those languages are

00:03:32,579 --> 00:03:38,159
all different the proposition that all

00:03:36,060 --> 00:03:40,470
programming should be done in JavaScript

00:03:38,159 --> 00:03:41,489
is to my mind the very definition of if

00:03:40,470 --> 00:03:42,659
all you have is a hammer everything

00:03:41,489 --> 00:03:45,120
looks like a nail

00:03:42,659 --> 00:03:47,099
the idea that JavaScript should be the

00:03:45,120 --> 00:03:48,900
single language that everyone uses

00:03:47,099 --> 00:03:50,579
simply because it had the good fortune

00:03:48,900 --> 00:03:52,759
to be the only language that Netscape

00:03:50,579 --> 00:03:54,799
supported in a browser 25 years ago

00:03:52,759 --> 00:03:57,810
that's absurd

00:03:54,799 --> 00:03:59,579
don't get me wrong there are plenty of

00:03:57,810 --> 00:04:01,650
very talented people in the JavaScript

00:03:59,579 --> 00:04:04,439
world and very good resources in that

00:04:01,650 --> 00:04:06,299
community as well this isn't a critique

00:04:04,439 --> 00:04:08,669
of the specific strengths and flaws of

00:04:06,299 --> 00:04:10,349
JavaScript as a language and any grand

00:04:08,669 --> 00:04:12,569
fair vision of the future that is based

00:04:10,349 --> 00:04:15,720
around a language monoculture is to my

00:04:12,569 --> 00:04:17,609
mind a folly at the core of all good

00:04:15,720 --> 00:04:18,479
engineering is picking the right tool

00:04:17,609 --> 00:04:20,759
for the job

00:04:18,479 --> 00:04:22,200
a language monoculture is an artificial

00:04:20,759 --> 00:04:26,099
constraint on the tools that are at your

00:04:22,200 --> 00:04:26,729
disposal interestingly it wasn't always

00:04:26,099 --> 00:04:27,490
this way

00:04:26,729 --> 00:04:28,870
when

00:04:27,490 --> 00:04:30,639
Netscape introduced the browser they

00:04:28,870 --> 00:04:33,310
introduced this entirely new language

00:04:30,639 --> 00:04:35,500
called JavaScript but Netscape was just

00:04:33,310 --> 00:04:37,470
one player in this new web space and

00:04:35,500 --> 00:04:40,270
other players had other ideas

00:04:37,470 --> 00:04:41,650
in the mid-90s Microsoft was everything

00:04:40,270 --> 00:04:44,319
and Microsoft's scripting language of

00:04:41,650 --> 00:04:45,940
choice was visual basic so in early

00:04:44,319 --> 00:04:48,819
versions of Internet Explorer you could

00:04:45,940 --> 00:04:51,280
script your web pages with VB script now

00:04:48,819 --> 00:04:53,349
I say early versions this was still

00:04:51,280 --> 00:04:56,530
valid until quite recently Microsoft

00:04:53,349 --> 00:04:59,229
didn't formally deprecated VB script on

00:04:56,530 --> 00:05:04,060
web pages until the release of IE 11 in

00:04:59,229 --> 00:05:06,550
late 2013 python also had a play in this

00:05:04,060 --> 00:05:08,979
space up until 1999 da van Rossum was

00:05:06,550 --> 00:05:10,360
working at CNRI on an academic project

00:05:08,979 --> 00:05:12,159
looking into electronic knowledge

00:05:10,360 --> 00:05:14,169
storage and retrieval and part of that

00:05:12,159 --> 00:05:17,620
project was a custom web browser called

00:05:14,169 --> 00:05:20,650
Grail a web browser written in Python

00:05:17,620 --> 00:05:22,539
and you could embed Python code in your

00:05:20,650 --> 00:05:24,699
web pages using the applets feature that

00:05:22,539 --> 00:05:27,460
existed in HTML 2 and was removed in

00:05:24,699 --> 00:05:29,020
HTML 5 the lifecycle of an applet is a

00:05:27,460 --> 00:05:30,370
little bit different the lifecycle of

00:05:29,020 --> 00:05:32,440
code and a script tag which it might be

00:05:30,370 --> 00:05:33,969
familiar with but an applet could

00:05:32,440 --> 00:05:36,250
interact with the document in which it

00:05:33,969 --> 00:05:39,370
was embedded and thus you had Python in

00:05:36,250 --> 00:05:41,080
the browser or passing in a browser

00:05:39,370 --> 00:05:44,650
because Grail is the only browser in

00:05:41,080 --> 00:05:46,030
which this ever worked but these were

00:05:44,650 --> 00:05:47,889
basically experiments they were

00:05:46,030 --> 00:05:49,690
short-lived experiments by the time the

00:05:47,889 --> 00:05:52,240
browser Wars came to a conclusion in the

00:05:49,690 --> 00:05:53,919
late 2000s javascript was the only

00:05:52,240 --> 00:05:56,500
language that any browser actually

00:05:53,919 --> 00:05:58,539
supported Google made an attempt to

00:05:56,500 --> 00:06:00,430
introduce dart as a new web web language

00:05:58,539 --> 00:06:02,550
but it despite even Google's influence

00:06:00,430 --> 00:06:05,139
on the web that didn't really take off

00:06:02,550 --> 00:06:07,210
there haven't really been any serious

00:06:05,139 --> 00:06:08,710
proposals to add that add to this list

00:06:07,210 --> 00:06:12,250
of supported languages in the browser

00:06:08,710 --> 00:06:13,960
that are both serious and successful so

00:06:12,250 --> 00:06:16,680
if we want to use a different language

00:06:13,960 --> 00:06:18,789
in the browser we have to get creative

00:06:16,680 --> 00:06:20,469
demonstrate let's try to do something

00:06:18,789 --> 00:06:22,270
practical let's validate some credit

00:06:20,469 --> 00:06:23,650
card numbers all the code for these

00:06:22,270 --> 00:06:25,569
examples can be found at this webpage

00:06:23,650 --> 00:06:27,400
which is a live demo of all the code

00:06:25,569 --> 00:06:28,810
that I'm going to run today for those

00:06:27,400 --> 00:06:30,580
who don't know credit card numbers are

00:06:28,810 --> 00:06:32,169
self validating they contain a checksum

00:06:30,580 --> 00:06:34,659
the last digit of your credit card

00:06:32,169 --> 00:06:36,339
number is computed from all the previous

00:06:34,659 --> 00:06:38,139
digits following a method known as the

00:06:36,339 --> 00:06:39,729
Loon algorithm by using the lunar

00:06:38,139 --> 00:06:41,439
algorithm it's possible to perform a

00:06:39,729 --> 00:06:42,819
preliminary check of credit card

00:06:41,439 --> 00:06:44,529
validity it won't tell you if the user

00:06:42,819 --> 00:06:46,179
has sufficient funds it won't protect

00:06:44,529 --> 00:06:48,459
against every typo but it will protect

00:06:46,179 --> 00:06:51,129
against most simple type of typographic

00:06:48,459 --> 00:06:52,689
errors and it's a great example the sort

00:06:51,129 --> 00:06:53,860
of logic that you want to run in the

00:06:52,689 --> 00:06:55,779
browser because you want to give the

00:06:53,860 --> 00:06:57,159
user immediate feedback if they're

00:06:55,779 --> 00:07:00,309
flubbed in typing in their credit card

00:06:57,159 --> 00:07:01,929
number into your payment form if we were

00:07:00,309 --> 00:07:03,550
to write a native JavaScript

00:07:01,929 --> 00:07:05,559
implementation of the Loon algorithm and

00:07:03,550 --> 00:07:08,349
connect it up to a form you'll end up

00:07:05,559 --> 00:07:11,050
with about 30 lines 0.6 kilobyte of

00:07:08,349 --> 00:07:13,059
native JavaScript code if you minify

00:07:11,050 --> 00:07:15,519
that it'll shrink down to about point 4

00:07:13,059 --> 00:07:18,209
of a kilobyte but we don't want to write

00:07:15,519 --> 00:07:21,759
in JavaScript so what options do we have

00:07:18,209 --> 00:07:24,249
first option write JavaScript but use

00:07:21,759 --> 00:07:26,579
different spelling and compile to

00:07:24,249 --> 00:07:29,019
JavaScript as a pre compilation step

00:07:26,579 --> 00:07:31,329
CoffeeScript is the simplest example of

00:07:29,019 --> 00:07:33,159
this in practice CoffeeScript is at its

00:07:31,329 --> 00:07:35,289
core JavaScript but with different

00:07:33,159 --> 00:07:37,629
spelling it's got a few nice pieces of

00:07:35,289 --> 00:07:40,389
syntactic sugar that map onto JavaScript

00:07:37,629 --> 00:07:41,949
concepts and of course it's got syntax

00:07:40,389 --> 00:07:45,550
significant why it's placed in in place

00:07:41,949 --> 00:07:46,899
of all the parentheses and if you run a

00:07:45,550 --> 00:07:48,639
rewrite your learning algorithm in

00:07:46,899 --> 00:07:50,559
CoffeeScript you then compile it to

00:07:48,639 --> 00:07:51,909
JavaScript there is a little bit of an

00:07:50,559 --> 00:07:54,069
overhead so if you look here like the

00:07:51,909 --> 00:07:55,059
for loop in this code three lines from

00:07:54,069 --> 00:07:58,209
the bottom and a little bit odd

00:07:55,059 --> 00:08:00,849
CoffeeScript syntax is more terse than

00:07:58,209 --> 00:08:02,879
JavaScript syntax but in compilation the

00:08:00,849 --> 00:08:05,829
output gets a little bit more verbose

00:08:02,879 --> 00:08:08,439
the compiled CoffeeScript increases our

00:08:05,829 --> 00:08:10,329
payload for our for a running code by

00:08:08,439 --> 00:08:12,759
about 30% to about point eight kilobyte

00:08:10,329 --> 00:08:15,429
but again you minify it's only about 10%

00:08:12,759 --> 00:08:18,039
so about 550 bytes okay but that's

00:08:15,429 --> 00:08:20,349
CoffeeScript can we use this technique

00:08:18,039 --> 00:08:22,689
for other languages say another language

00:08:20,349 --> 00:08:27,189
that has syntax significant whitespace

00:08:22,689 --> 00:08:28,659
like zero - well yeah sure you can and

00:08:27,189 --> 00:08:30,309
there's a bunch of projects that try to

00:08:28,659 --> 00:08:33,579
do this the best one I found is one

00:08:30,309 --> 00:08:35,709
called transcript so we can write our

00:08:33,579 --> 00:08:37,599
Luhn algorithm in Python because it's

00:08:35,709 --> 00:08:39,569
Python we can use list comprehensions at

00:08:37,599 --> 00:08:42,250
enumerate and actual integer arithmetic

00:08:39,569 --> 00:08:46,110
we're going to compile our Python source

00:08:42,250 --> 00:08:49,059
file and again we get JavaScript now

00:08:46,110 --> 00:08:51,009
this is just a small segment of the code

00:08:49,059 --> 00:08:52,779
that is generated and right away you can

00:08:51,009 --> 00:08:54,310
see this is definitely not JavaScript

00:08:52,779 --> 00:08:56,900
you would write by hand

00:08:54,310 --> 00:08:58,310
why is it weird well some of it is

00:08:56,900 --> 00:09:00,980
because of language idiom JavaScript

00:08:58,310 --> 00:09:02,360
style for loops RC style for loops they

00:09:00,980 --> 00:09:06,020
have a start and an end in an increment

00:09:02,360 --> 00:09:07,460
Python uses for item in iterable but

00:09:06,020 --> 00:09:09,860
beyond that it's because we don't just

00:09:07,460 --> 00:09:11,780
want a language that looks like Python

00:09:09,860 --> 00:09:14,450
we want it to run like Python as well

00:09:11,780 --> 00:09:16,640
and pythons scoping rules are very

00:09:14,450 --> 00:09:19,370
different to Java scripts if you want to

00:09:16,640 --> 00:09:21,440
preserve Python semantics in JavaScript

00:09:19,370 --> 00:09:23,240
you can't just do a naive syntax

00:09:21,440 --> 00:09:27,170
conversion like CoffeeScript does that

00:09:23,240 --> 00:09:28,790
part is easy but javascript has the same

00:09:27,170 --> 00:09:30,380
scoping rules as CoffeeScript Python

00:09:28,790 --> 00:09:32,210
doesn't for Python you actually have to

00:09:30,380 --> 00:09:34,340
parse the code and generate JavaScript

00:09:32,210 --> 00:09:36,650
that exposes the same lexical scoping

00:09:34,340 --> 00:09:38,510
that Python expects you also have to

00:09:36,650 --> 00:09:41,360
account for language built-ins like to

00:09:38,510 --> 00:09:42,980
enumerate and some Python has a lot of

00:09:41,360 --> 00:09:45,440
batteries included that JavaScript

00:09:42,980 --> 00:09:47,720
doesn't have so you have to provide them

00:09:45,440 --> 00:09:49,250
if you are really aggressive you could

00:09:47,720 --> 00:09:51,440
probably shake the source tree that of

00:09:49,250 --> 00:09:52,820
what transcript is produced and strip

00:09:51,440 --> 00:09:53,870
out the built-ins you're not using but

00:09:52,820 --> 00:09:55,100
to the best of my knowledge that's not

00:09:53,870 --> 00:09:57,740
something you can do with jar with with

00:09:55,100 --> 00:09:59,060
transcript at the moment and your final

00:09:57,740 --> 00:10:02,180
as a result your final transcript

00:09:59,060 --> 00:10:03,950
product is 74 kilobytes of code it comes

00:10:02,180 --> 00:10:06,230
down to about 32 kilobytes when it's

00:10:03,950 --> 00:10:08,150
minified most of that extra weight is

00:10:06,230 --> 00:10:10,100
actually the fixed cost associated with

00:10:08,150 --> 00:10:12,020
providing the built-ins the actual

00:10:10,100 --> 00:10:14,000
Python module is about one and a half

00:10:12,020 --> 00:10:16,490
kilobyte so about double the size of the

00:10:14,000 --> 00:10:20,030
JavaScript so yeah that's a lot more

00:10:16,490 --> 00:10:21,100
code but you are now running Python in

00:10:20,030 --> 00:10:23,630
the browser

00:10:21,100 --> 00:10:24,890
you're not running all of Python though

00:10:23,630 --> 00:10:26,900
you get the language you get the

00:10:24,890 --> 00:10:28,970
built-ins you can even access the Dom

00:10:26,900 --> 00:10:31,460
window document other Dom objects are

00:10:28,970 --> 00:10:33,140
exposed as global symbols in your Python

00:10:31,460 --> 00:10:35,920
namespace and you can manipulate your

00:10:33,140 --> 00:10:38,570
HTML page to your heart's content great

00:10:35,920 --> 00:10:40,850
transcript also produces source maps so

00:10:38,570 --> 00:10:42,920
you can debug you're running Python code

00:10:40,850 --> 00:10:45,710
in the JavaScript debugger of your

00:10:42,920 --> 00:10:47,600
browser but you don't get a ripple I

00:10:45,710 --> 00:10:50,090
read eval print loop otherwise known as

00:10:47,600 --> 00:10:51,620
the Python prompt or at least not a

00:10:50,090 --> 00:10:55,250
Python one because you're ultimately

00:10:51,620 --> 00:10:57,710
running JavaScript you can drop a prompt

00:10:55,250 --> 00:10:59,630
sure but it's the JavaScript console

00:10:57,710 --> 00:11:02,660
where you're running JavaScript not

00:10:59,630 --> 00:11:04,610
Python you also don't get the standard

00:11:02,660 --> 00:11:06,470
library you can't pip install requests

00:11:04,610 --> 00:11:08,120
and start doing client-side web requests

00:11:06,470 --> 00:11:10,160
transcript doesn

00:11:08,120 --> 00:11:11,300
some pieces and has partial support for

00:11:10,160 --> 00:11:14,020
an umpire but that's a very specific

00:11:11,300 --> 00:11:16,400
inclusion of numpy transcript itself

00:11:14,020 --> 00:11:18,080
that's where project like a robust comes

00:11:16,400 --> 00:11:19,790
in a robe Arras is part of the beware

00:11:18,080 --> 00:11:21,650
project it's an attempt to build a

00:11:19,790 --> 00:11:23,540
standalone implementation of the Python

00:11:21,650 --> 00:11:24,800
standard library written in Python to

00:11:23,540 --> 00:11:26,510
the extent possible with a clear

00:11:24,800 --> 00:11:28,550
interface to system libraries when a

00:11:26,510 --> 00:11:30,080
pure python implementation is impossible

00:11:28,550 --> 00:11:32,180
like for example when you start talking

00:11:30,080 --> 00:11:33,800
to networking arroyos is very much a

00:11:32,180 --> 00:11:35,270
work in progress but it's an important

00:11:33,800 --> 00:11:36,800
piece of the overall picture if we're

00:11:35,270 --> 00:11:40,610
planning on allowing Python to run

00:11:36,800 --> 00:11:42,020
everywhere okay so transpiration proves

00:11:40,610 --> 00:11:43,790
that it's possible to compile to

00:11:42,020 --> 00:11:46,580
JavaScript from a source language other

00:11:43,790 --> 00:11:48,650
than JavaScript so let's think outside

00:11:46,580 --> 00:11:52,490
the box a little bit a Python compiler

00:11:48,650 --> 00:11:55,400
is just code so can we write a Python

00:11:52,490 --> 00:11:57,380
compiler in JavaScript if we had that

00:11:55,400 --> 00:11:59,060
then we could actually ship Python

00:11:57,380 --> 00:12:01,550
source code to the browser

00:11:59,060 --> 00:12:03,350
much like vbscript used to but without

00:12:01,550 --> 00:12:05,420
needing any formal support in our

00:12:03,350 --> 00:12:08,000
language for the browser if for our

00:12:05,420 --> 00:12:09,740
language in the browser and so yes you

00:12:08,000 --> 00:12:11,780
can do that brighten and sculpt to both

00:12:09,740 --> 00:12:14,750
implementations of the Python compiler

00:12:11,780 --> 00:12:17,000
written in JavaScript and if you have a

00:12:14,750 --> 00:12:20,900
browser side compiler that means you can

00:12:17,000 --> 00:12:23,450
ship Python source code to the client so

00:12:20,900 --> 00:12:25,220
you include the code for the compiler as

00:12:23,450 --> 00:12:27,440
part of JavaScript source and then you

00:12:25,220 --> 00:12:30,560
include your Python source code in a

00:12:27,440 --> 00:12:32,510
script tag of type text Python that

00:12:30,560 --> 00:12:34,280
script tag can then import other code

00:12:32,510 --> 00:12:36,050
Bryson's import statement will look for

00:12:34,280 --> 00:12:37,610
and download a Python file at the same

00:12:36,050 --> 00:12:39,800
URL that's as part of its import

00:12:37,610 --> 00:12:41,300
strategy you can also reference the Dom

00:12:39,800 --> 00:12:42,680
broth and does this with the module

00:12:41,300 --> 00:12:44,780
import rather than putting the symbols

00:12:42,680 --> 00:12:46,940
in the global namespace when the page

00:12:44,780 --> 00:12:50,540
loads the Brighton source code looks for

00:12:46,940 --> 00:12:52,970
the script tags of type text Python and

00:12:50,540 --> 00:12:54,890
then runs them I am showing the

00:12:52,970 --> 00:12:56,960
procedure here for Brian it's but it's

00:12:54,890 --> 00:12:59,390
very similar for scoped as well okay

00:12:56,960 --> 00:13:02,570
awesome so we have Python running in the

00:12:59,390 --> 00:13:05,060
browser what's the catch well what's the

00:13:02,570 --> 00:13:06,440
code size like the Python code half a

00:13:05,060 --> 00:13:08,270
kilobyte it's smaller than the original

00:13:06,440 --> 00:13:09,590
javascript can't be minified though

00:13:08,270 --> 00:13:12,080
because it's Python you actually are you

00:13:09,590 --> 00:13:16,280
have to preserve the whitespace but you

00:13:12,080 --> 00:13:18,740
need a 646 kilobyte bootstrap and that

00:13:16,280 --> 00:13:21,930
bootstrap has to be fully downloaded

00:13:18,740 --> 00:13:23,790
parsed and executed before

00:13:21,930 --> 00:13:26,820
any of the Python source code on the

00:13:23,790 --> 00:13:28,950
page execute and that's noticeable I've

00:13:26,820 --> 00:13:30,480
got a 50 megabit NB an NBN connection at

00:13:28,950 --> 00:13:32,399
home if I visit the Bryson web page

00:13:30,480 --> 00:13:34,710
they've got an amazing clock demo on the

00:13:32,399 --> 00:13:37,950
front page written in Python but that

00:13:34,710 --> 00:13:39,570
demo isn't visible at all for two to

00:13:37,950 --> 00:13:41,940
three seconds after the page is finished

00:13:39,570 --> 00:13:44,160
loading because the demo code won't run

00:13:41,940 --> 00:13:46,740
until the bootstrap has finished loading

00:13:44,160 --> 00:13:49,860
running compiling pausing the Python

00:13:46,740 --> 00:13:51,510
code what else is missing well again you

00:13:49,860 --> 00:13:53,250
get all the Dom and the access to the

00:13:51,510 --> 00:13:54,839
Python built-ins you also get some of

00:13:53,250 --> 00:13:56,279
the standard library but it is missing

00:13:54,839 --> 00:13:58,560
parts as well for the same reasons that

00:13:56,279 --> 00:14:01,140
transcript is you don't get any

00:13:58,560 --> 00:14:03,570
debugging bryson doesn't provide source

00:14:01,140 --> 00:14:05,220
Maps and it probably isn't even able to

00:14:03,570 --> 00:14:07,290
because you're not mapping from one

00:14:05,220 --> 00:14:09,270
source file to a roughly equivalent

00:14:07,290 --> 00:14:11,640
source file you're mapping from the

00:14:09,270 --> 00:14:13,440
internal operation of an interpreter to

00:14:11,640 --> 00:14:16,230
source code that's running in that

00:14:13,440 --> 00:14:17,580
interpreter Brian does have a debugging

00:14:16,230 --> 00:14:19,110
mode but it's not connected to the

00:14:17,580 --> 00:14:21,630
JavaScript debugger that you're familiar

00:14:19,110 --> 00:14:23,910
with you do get a full ripple though

00:14:21,630 --> 00:14:26,010
you've got a full Python interpreter at

00:14:23,910 --> 00:14:27,540
your disposal you can't just open up a

00:14:26,010 --> 00:14:29,070
JavaScript console and start typing but

00:14:27,540 --> 00:14:31,589
you can without too much effort add a

00:14:29,070 --> 00:14:33,000
debugging console to your web page that

00:14:31,589 --> 00:14:34,860
accesses the running breath and

00:14:33,000 --> 00:14:38,130
interpreter compile your code runs your

00:14:34,860 --> 00:14:40,290
go get to get a ripple loop going but

00:14:38,130 --> 00:14:42,420
after that you've still got a 650

00:14:40,290 --> 00:14:44,160
kilobyte bootstrap how much of that can

00:14:42,420 --> 00:14:46,680
we strip away and still have a working

00:14:44,160 --> 00:14:48,600
interpreter well turns out quite a bit

00:14:46,680 --> 00:14:51,650
because what you're shipping to the

00:14:48,600 --> 00:14:54,089
browser is a full Python implementation

00:14:51,650 --> 00:14:55,740
what do I mean by that well a full

00:14:54,089 --> 00:14:58,050
Python implementation consists of a

00:14:55,740 --> 00:14:59,310
passer which takes human source code

00:14:58,050 --> 00:15:01,230
input and turns it into an in-memory

00:14:59,310 --> 00:15:02,730
representation of the code you've got a

00:15:01,230 --> 00:15:03,959
compiler which takes that in memory

00:15:02,730 --> 00:15:05,610
representation and turns it into

00:15:03,959 --> 00:15:09,000
something that can be executed in C

00:15:05,610 --> 00:15:10,709
Python that's byte code you haven't have

00:15:09,000 --> 00:15:12,209
an eval loop which can read and run the

00:15:10,709 --> 00:15:14,520
output of that compiler this is what you

00:15:12,209 --> 00:15:16,079
experience as the Python executable and

00:15:14,520 --> 00:15:17,190
then there's the standard library which

00:15:16,079 --> 00:15:19,649
is used by the code that's running

00:15:17,190 --> 00:15:21,240
through your eval loop the approach

00:15:19,649 --> 00:15:23,010
that's taken by Brian and sculpt is to

00:15:21,240 --> 00:15:26,970
re-implement the entire stack do the

00:15:23,010 --> 00:15:28,829
whole lot in JavaScript but all we need

00:15:26,970 --> 00:15:32,250
to be able to do on the client is run

00:15:28,829 --> 00:15:34,260
the code so if we can ship a runnable

00:15:32,250 --> 00:15:35,640
version of the code we don't need to

00:15:34,260 --> 00:15:38,220
ship the parser and the CIM

00:15:35,640 --> 00:15:39,480
Tyla and python has a runnable

00:15:38,220 --> 00:15:41,490
representation of the code

00:15:39,480 --> 00:15:44,160
it's called byte code it's what you find

00:15:41,490 --> 00:15:45,990
in your pyc files byte code is a little

00:15:44,160 --> 00:15:47,310
bit like sort of a high-level assembly

00:15:45,990 --> 00:15:48,870
language it's an encoded set of

00:15:47,310 --> 00:15:50,970
instructions for stack bait for a stack

00:15:48,870 --> 00:15:51,960
based virtual machine that has basic

00:15:50,970 --> 00:15:53,220
primitives like pushing and popping

00:15:51,960 --> 00:15:55,140
things onto a stack setting attributes

00:15:53,220 --> 00:15:57,690
of an object handling exceptions things

00:15:55,140 --> 00:15:59,400
like that bytecode is a runtime format

00:15:57,690 --> 00:16:01,440
used by the C Python interpreter not

00:15:59,400 --> 00:16:03,240
part of the Python standard so to say

00:16:01,440 --> 00:16:05,270
that so to speak but there is nothing to

00:16:03,240 --> 00:16:08,040
say you couldn't create an independent

00:16:05,270 --> 00:16:10,050
implementation of the C Python virtual

00:16:08,040 --> 00:16:12,780
machine capable of running C Python

00:16:10,050 --> 00:16:15,090
bytecode and that's what Batavia does

00:16:12,780 --> 00:16:16,980
Batavia is another beware project it's

00:16:15,090 --> 00:16:19,680
part of it's an implementation of just

00:16:16,980 --> 00:16:22,560
the C Python virtual machine written in

00:16:19,680 --> 00:16:24,480
JavaScript what does it look like as an

00:16:22,560 --> 00:16:27,690
end user well instead of shipping source

00:16:24,480 --> 00:16:28,950
code you ship the py C file by 64

00:16:27,690 --> 00:16:32,520
encoded so it can actually appear on a

00:16:28,950 --> 00:16:34,290
web page how much code are we talking

00:16:32,520 --> 00:16:35,970
about well the byte code of the Luhn

00:16:34,290 --> 00:16:38,430
algorithm is about 1.2 kilobyte of

00:16:35,970 --> 00:16:40,350
base64 if you were able to send a binary

00:16:38,430 --> 00:16:43,110
which you could do it would come down to

00:16:40,350 --> 00:16:44,880
about 800 800 bytes it's also mildly

00:16:43,110 --> 00:16:46,260
obfuscated which depending upon your

00:16:44,880 --> 00:16:48,930
perspective may or may not be a good

00:16:46,260 --> 00:16:51,090
thing like you can't tell from that 7gw

00:16:48,930 --> 00:16:55,560
NC j9 what code is actually running

00:16:51,090 --> 00:16:57,840
there so your secrets are protected but

00:16:55,560 --> 00:16:59,940
just as with Brighton there's a

00:16:57,840 --> 00:17:03,050
bootstrap now unfortunately the current

00:16:59,940 --> 00:17:05,370
state of Batavia doesn't look too good

00:17:03,050 --> 00:17:07,650
over time a lot of pieces have been

00:17:05,370 --> 00:17:08,880
added to Batavia timezones encoding

00:17:07,650 --> 00:17:10,800
tables handling for arbiter sized

00:17:08,880 --> 00:17:13,050
integers parts of the standard library

00:17:10,800 --> 00:17:15,930
have just accumulated and then webpack

00:17:13,050 --> 00:17:18,300
got involved which really didn't help so

00:17:15,930 --> 00:17:22,949
Batavia currently weighs in is a 5 mega

00:17:18,300 --> 00:17:24,839
byte bootstrap however once upon a time

00:17:22,949 --> 00:17:27,390
Batavia bootstrap was as little as 10

00:17:24,839 --> 00:17:28,830
kilobyte of minified javascript if you

00:17:27,390 --> 00:17:30,750
don't believe that's possible net

00:17:28,830 --> 00:17:34,470
batchelder's byte run project is a full

00:17:30,750 --> 00:17:36,840
Python byte code machine written in 1600

00:17:34,470 --> 00:17:39,720
lines of Python Alison captor did an

00:17:36,840 --> 00:17:40,950
amazing write up in of that code in a

00:17:39,720 --> 00:17:44,940
book called the architecture of open

00:17:40,950 --> 00:17:47,520
source so by leaving behind the need to

00:17:44,940 --> 00:17:47,900
compile code you can lose a lot of what

00:17:47,520 --> 00:17:50,000
may

00:17:47,900 --> 00:17:51,890
bricen heavy which is weight that bricen

00:17:50,000 --> 00:17:55,340
can't shed because client-side

00:17:51,890 --> 00:17:56,420
compilation is how it works now okay the

00:17:55,340 --> 00:17:57,950
current state of Batavia is not

00:17:56,420 --> 00:18:00,290
especially competitive but underlying

00:17:57,950 --> 00:18:01,910
idea I think is actually quite viable

00:18:00,290 --> 00:18:04,580
the implementation just needs a little

00:18:01,910 --> 00:18:05,900
bit of work there assuming we could

00:18:04,580 --> 00:18:08,000
solve that size problem what would we

00:18:05,900 --> 00:18:09,410
get well you get the Dom you get your

00:18:08,000 --> 00:18:11,240
built-ins and as much of the standard

00:18:09,410 --> 00:18:13,010
library as you care to ship but again no

00:18:11,240 --> 00:18:14,240
ripple or no debugging essentially it's

00:18:13,010 --> 00:18:15,500
the same story as breath in' but you

00:18:14,240 --> 00:18:17,180
don't have a ripple because you don't

00:18:15,500 --> 00:18:19,750
have access to a compiler at least not

00:18:17,180 --> 00:18:21,710
without doing a server a server-side hit

00:18:19,750 --> 00:18:23,810
but this is a line of thought that's

00:18:21,710 --> 00:18:25,790
worth exploring what behavior is doing

00:18:23,810 --> 00:18:28,340
is essentially shipping code targeting a

00:18:25,790 --> 00:18:30,380
runtime batavia then provides that

00:18:28,340 --> 00:18:33,320
runtime reproducing sea pythons runtime

00:18:30,380 --> 00:18:35,960
in JavaScript but javascript is a

00:18:33,320 --> 00:18:39,260
runtime can we target that runtime

00:18:35,960 --> 00:18:40,580
directly one of the interesting side

00:18:39,260 --> 00:18:42,620
effects of having multiple browser

00:18:40,580 --> 00:18:44,270
vendors competing with each other is

00:18:42,620 --> 00:18:46,010
that over the years they have competed

00:18:44,270 --> 00:18:47,750
with each other aggressively to make the

00:18:46,010 --> 00:18:50,330
fastest javascript interpreter on the

00:18:47,750 --> 00:18:52,160
planet thousands of person hours have

00:18:50,330 --> 00:18:54,050
been put into making javascript run fast

00:18:52,160 --> 00:18:55,130
and a lot of that effort was put into

00:18:54,050 --> 00:18:57,740
something called just-in-time

00:18:55,130 --> 00:18:59,390
compilation or jitan cheating is a

00:18:57,740 --> 00:19:00,890
compiler technique that identifies

00:18:59,390 --> 00:19:03,470
pieces of code that could potentially

00:19:00,890 --> 00:19:06,560
run fast and turn them directly into

00:19:03,470 --> 00:19:08,270
machine code at runtime few years back a

00:19:06,560 --> 00:19:10,580
team at Mozilla looked at the JavaScript

00:19:08,270 --> 00:19:12,260
language as a whole and worked out the

00:19:10,580 --> 00:19:15,560
subset of the language that jutted

00:19:12,260 --> 00:19:17,780
efficiently in theory if you only use

00:19:15,560 --> 00:19:20,450
that subset of JavaScript your end code

00:19:17,780 --> 00:19:23,000
will run really fast and they called

00:19:20,450 --> 00:19:25,160
this subset is MJS why because it's

00:19:23,000 --> 00:19:26,690
effectively assembly level JavaScript

00:19:25,160 --> 00:19:28,580
it's just a set of very low-level

00:19:26,690 --> 00:19:29,990
primitives dealing with integer and

00:19:28,580 --> 00:19:32,810
floating-point arithmetic function

00:19:29,990 --> 00:19:34,790
definitions and function pointers here

00:19:32,810 --> 00:19:37,250
is some asm.js code for adding two

00:19:34,790 --> 00:19:39,260
numbers we define a javascript function

00:19:37,250 --> 00:19:41,110
and the first thing we do is or the

00:19:39,260 --> 00:19:45,170
value of the first argument with zero

00:19:41,110 --> 00:19:48,310
logically that means nothing any value

00:19:45,170 --> 00:19:51,410
or with zero is that value but a

00:19:48,310 --> 00:19:54,110
compiler can then infer that the first

00:19:51,410 --> 00:19:55,550
argument must be an integer because the

00:19:54,110 --> 00:19:57,980
result of a binary operation with an

00:19:55,550 --> 00:19:59,540
integer is an integer and so any

00:19:57,980 --> 00:20:01,400
subsequent operation on that value must

00:19:59,540 --> 00:20:02,900
also be an integer operation

00:20:01,400 --> 00:20:04,760
it doesn't need to actually do the

00:20:02,900 --> 00:20:06,320
operation it can just in time

00:20:04,760 --> 00:20:07,850
decide that it doesn't need to be

00:20:06,320 --> 00:20:10,190
performed and I don't only do the

00:20:07,850 --> 00:20:11,780
optimized calculation there's a similar

00:20:10,190 --> 00:20:13,160
trick that operates with the unary plus

00:20:11,780 --> 00:20:13,910
operator and floating-point operations

00:20:13,160 --> 00:20:16,970
now

00:20:13,910 --> 00:20:19,700
nobody actually expects anyone to write

00:20:16,970 --> 00:20:21,830
manual JavaScript code like that but

00:20:19,700 --> 00:20:23,360
rigorous mechanical application of rules

00:20:21,830 --> 00:20:26,000
and logic is something that compilers

00:20:23,360 --> 00:20:28,670
are really really good at and so people

00:20:26,000 --> 00:20:31,730
have built compilers to do it clang is

00:20:28,670 --> 00:20:33,260
usually thought of as a C compiler but

00:20:31,730 --> 00:20:35,360
it's actually a toolkit for building

00:20:33,260 --> 00:20:36,590
compilers pausing human readable source

00:20:35,360 --> 00:20:37,910
code producing an intermediate

00:20:36,590 --> 00:20:39,560
representation that encompasses the

00:20:37,910 --> 00:20:40,910
underlying machine level instructions

00:20:39,560 --> 00:20:42,440
that need to be done and then having

00:20:40,910 --> 00:20:45,230
backends to turn that output the

00:20:42,440 --> 00:20:47,090
specific CPU pre architectures but is

00:20:45,230 --> 00:20:48,980
MJS is also just a way to perform those

00:20:47,090 --> 00:20:51,110
machine level instructions generically

00:20:48,980 --> 00:20:54,890
so you can write a compiler back-end

00:20:51,110 --> 00:20:56,540
that outputs a s MJS directly in script

00:20:54,890 --> 00:20:58,490
in' is that back-end if you've got a

00:20:56,540 --> 00:21:00,920
language that clang can compile and

00:20:58,490 --> 00:21:04,520
there's a lot of them it can output is

00:21:00,920 --> 00:21:06,440
MJ s output and so we rewrite our

00:21:04,520 --> 00:21:07,910
credit-card validation function in C and

00:21:06,440 --> 00:21:09,830
we compile it with in script and we get

00:21:07,910 --> 00:21:12,830
something like this a whole lot of

00:21:09,830 --> 00:21:16,130
completely alien but 100% legal

00:21:12,830 --> 00:21:18,680
JavaScript code that will at runtime be

00:21:16,130 --> 00:21:22,730
very very fast in a JavaScript virtual

00:21:18,680 --> 00:21:25,070
machine now it is not just a magical

00:21:22,730 --> 00:21:28,010
fountain of speed there is a price that

00:21:25,070 --> 00:21:30,160
is paid asm.js code runs fast but you

00:21:28,010 --> 00:21:33,110
don't get a transparent bridge between

00:21:30,160 --> 00:21:34,340
javascript and your native code integers

00:21:33,110 --> 00:21:36,740
and floats can be passed back and forth

00:21:34,340 --> 00:21:38,870
really easily but strings you need to

00:21:36,740 --> 00:21:42,080
marshal them because a smj s is

00:21:38,870 --> 00:21:45,310
assembler level code you have to manage

00:21:42,080 --> 00:21:48,020
memory yourself as an array of integers

00:21:45,310 --> 00:21:50,150
you have to allocate memory on a virtual

00:21:48,020 --> 00:21:52,190
memory heap and then point the asm.js

00:21:50,150 --> 00:21:54,380
code at that virtual memory address when

00:21:52,190 --> 00:21:55,820
you pass around a string and script in'

00:21:54,380 --> 00:21:57,770
provides a bootstrap to help with this

00:21:55,820 --> 00:21:59,540
but it's pretty low level you can see

00:21:57,770 --> 00:22:01,550
here with a module dot C core method

00:21:59,540 --> 00:22:02,960
which is used to call a C function from

00:22:01,550 --> 00:22:04,580
your inscription module you have to

00:22:02,960 --> 00:22:05,930
manually specify the types of all your

00:22:04,580 --> 00:22:07,640
arguments or the bootstrap can then

00:22:05,930 --> 00:22:10,490
allocate memory for the string argument

00:22:07,640 --> 00:22:12,170
when it's being invoked you also don't

00:22:10,490 --> 00:22:14,180
get access to the Dom now this is an

00:22:12,170 --> 00:22:15,049
area the the the language w3c working

00:22:14,180 --> 00:22:17,749
group is working on

00:22:15,049 --> 00:22:20,840
so watch this space you do who ever get

00:22:17,749 --> 00:22:23,149
access to raw canvas and OpenGL 3G 3d

00:22:20,840 --> 00:22:25,249
graphics api's so there are some really

00:22:23,149 --> 00:22:27,559
cool 3d game and graphics processing

00:22:25,249 --> 00:22:30,309
demos running entirely in a browser and

00:22:27,559 --> 00:22:33,200
see them at the web assembly home page

00:22:30,309 --> 00:22:34,429
but if you want to manage some logic and

00:22:33,200 --> 00:22:36,499
you're happy to write the Dom

00:22:34,429 --> 00:22:38,690
interactions yourself you can get any

00:22:36,499 --> 00:22:42,049
code that clang will compile and get it

00:22:38,690 --> 00:22:43,580
running in the browser but even a smj s

00:22:42,049 --> 00:22:46,700
can be improved upon what is delivered

00:22:43,580 --> 00:22:48,590
by is MJS is still JavaScript code it

00:22:46,700 --> 00:22:50,929
needs to be transmitted in a text format

00:22:48,590 --> 00:22:54,139
as javascript source and then paused

00:22:50,929 --> 00:22:56,299
interpreted and jetted now if we know

00:22:54,139 --> 00:22:57,619
ahead of time that our code will be

00:22:56,299 --> 00:22:59,869
compatible with this fast JavaScript

00:22:57,619 --> 00:23:03,619
subset can we send it to the browser in

00:22:59,869 --> 00:23:06,139
a ready-to-use format we can and that's

00:23:03,619 --> 00:23:08,600
what web assembly is or wasm web

00:23:06,139 --> 00:23:10,850
assembly is a binary format formalizing

00:23:08,600 --> 00:23:12,619
the ASM layer same J's language subset

00:23:10,850 --> 00:23:14,359
in a format that can be delivered to the

00:23:12,619 --> 00:23:16,580
browser in a format that is basically

00:23:14,359 --> 00:23:18,830
packaged to say I've already passed and

00:23:16,580 --> 00:23:22,489
you said this for you this makes it

00:23:18,830 --> 00:23:24,499
smaller and faster than a SMG is even

00:23:22,489 --> 00:23:27,379
though fundamentally it is the same code

00:23:24,499 --> 00:23:29,720
that's being executed now there is a

00:23:27,379 --> 00:23:35,119
source code format for web assembly

00:23:29,720 --> 00:23:36,859
called what web assembly text it is it's

00:23:35,119 --> 00:23:38,600
a sort of a hybrid between Lisp and

00:23:36,859 --> 00:23:40,340
assembly language this is really just

00:23:38,600 --> 00:23:42,049
giving formal names to the binary

00:23:40,340 --> 00:23:44,539
operations that are inside that are

00:23:42,049 --> 00:23:46,970
inside a MJS rather than relying upon

00:23:44,539 --> 00:23:48,559
compiler tricks the wack file can then

00:23:46,970 --> 00:23:51,019
be compiled to wasm which is a pure

00:23:48,559 --> 00:23:53,029
binary format this means it is plausible

00:23:51,019 --> 00:23:54,859
to write handwrite wet if you want to

00:23:53,029 --> 00:23:56,600
and then compile it the wisdom but what

00:23:54,859 --> 00:23:58,340
is also supported by in script and some

00:23:56,600 --> 00:23:59,509
other compilers so you can take C code

00:23:58,340 --> 00:24:00,919
run it through in script and with a

00:23:59,509 --> 00:24:03,350
different set of flags you get wha some

00:24:00,919 --> 00:24:06,799
output output that is smaller faster

00:24:03,350 --> 00:24:08,720
than the is MJS equivalent just as with

00:24:06,799 --> 00:24:10,850
ASM Jes there's no Dom access you need

00:24:08,720 --> 00:24:13,100
to do that bridging yourself this is not

00:24:10,850 --> 00:24:15,019
a theoretical future thing either wisdom

00:24:13,100 --> 00:24:18,200
is supported in all of the major

00:24:15,019 --> 00:24:20,059
browsers right now if you are if your

00:24:18,200 --> 00:24:21,739
problem suits Wesson's capabilities and

00:24:20,059 --> 00:24:23,749
you can set a minimum browser version

00:24:21,739 --> 00:24:24,350
that's about you know 12 months old or

00:24:23,749 --> 00:24:28,039
there abouts

00:24:24,350 --> 00:24:29,120
you can use it right now okay but we had

00:24:28,039 --> 00:24:31,190
to rewrite our Luna

00:24:29,120 --> 00:24:33,820
in situ use in scripting so that doesn't

00:24:31,190 --> 00:24:37,150
help us run Python so why do we care

00:24:33,820 --> 00:24:40,520
see pythons interpreter is written in C

00:24:37,150 --> 00:24:45,140
can we use in scripting to compile C

00:24:40,520 --> 00:24:45,890
code can we compile C Python y-yes of

00:24:45,140 --> 00:24:49,070
course we can

00:24:45,890 --> 00:24:50,690
that's what PI Iitate is now the bridge

00:24:49,070 --> 00:24:52,370
between Python and JavaScript provided

00:24:50,690 --> 00:24:54,830
by PI iodide is a little bit odd what

00:24:52,370 --> 00:24:56,990
you end up doing is running a script

00:24:54,830 --> 00:24:58,550
passing in JavaScript arguments as

00:24:56,990 --> 00:25:00,650
strings to the script that's going to be

00:24:58,550 --> 00:25:02,120
called and the last expression in the

00:25:00,650 --> 00:25:04,430
Python code is the return value of the

00:25:02,120 --> 00:25:05,690
PI iodide code quite a call now this is

00:25:04,430 --> 00:25:07,040
at least partially because of the

00:25:05,690 --> 00:25:08,900
developer's primary use case of Pi

00:25:07,040 --> 00:25:10,460
iodide is essentially to get sort of

00:25:08,900 --> 00:25:11,600
Jupiter style notebooks running

00:25:10,460 --> 00:25:14,120
completely in the browser with no

00:25:11,600 --> 00:25:15,590
server-side support in that context what

00:25:14,120 --> 00:25:17,450
you want is large chunks of text

00:25:15,590 --> 00:25:18,830
provided by the user do you execute the

00:25:17,450 --> 00:25:21,500
interaction between Java and Python is

00:25:18,830 --> 00:25:23,930
fairly minimal the downside it's not

00:25:21,500 --> 00:25:25,910
small at least at the moment there's a

00:25:23,930 --> 00:25:28,370
lot of caveats what you effectively get

00:25:25,910 --> 00:25:30,470
is embedded C Python in a browser that

00:25:28,370 --> 00:25:32,450
is great for Python shell in the browser

00:25:30,470 --> 00:25:36,080
demos Jupiter notebook sessions even

00:25:32,450 --> 00:25:38,060
like 3d games there's no Dom there's no

00:25:36,080 --> 00:25:39,110
browser debugging and while you do get

00:25:38,060 --> 00:25:40,640
the parts of the standard library that

00:25:39,110 --> 00:25:42,290
are written in C you don't did anything

00:25:40,640 --> 00:25:44,000
that depends on the interesting parts of

00:25:42,290 --> 00:25:47,720
the C standard library so sockets are

00:25:44,000 --> 00:25:49,310
out for example and it is big the wasm

00:25:47,720 --> 00:25:51,410
file for pi iodide is almost three

00:25:49,310 --> 00:25:53,090
megabytes plus 65 K of minified

00:25:51,410 --> 00:25:55,250
bootstrapping and that's before you've

00:25:53,090 --> 00:25:56,570
even given at the Python code to run two

00:25:55,250 --> 00:25:58,100
reasons it's large the first is because

00:25:56,570 --> 00:25:59,510
just like Brian needs a Python runtime

00:25:58,100 --> 00:26:00,710
not just the brighter bytecode

00:25:59,510 --> 00:26:03,020
interpreter the second is that it

00:26:00,710 --> 00:26:04,730
includes compiled in by default a whole

00:26:03,020 --> 00:26:06,650
lot of extras including lots of

00:26:04,730 --> 00:26:08,300
numerical processing tools again that's

00:26:06,650 --> 00:26:09,950
fine for a computational notebook you

00:26:08,300 --> 00:26:11,510
download the page once wait a couple of

00:26:09,950 --> 00:26:12,740
seconds keep the page open and keep

00:26:11,510 --> 00:26:14,150
running but when you're having to

00:26:12,740 --> 00:26:15,320
deliver all that excess client to a

00:26:14,150 --> 00:26:16,970
webpage it's doing credit card

00:26:15,320 --> 00:26:19,340
validation that's overhead you don't

00:26:16,970 --> 00:26:22,130
really need good news is there's plenty

00:26:19,340 --> 00:26:24,590
of room to optimize there C Python also

00:26:22,130 --> 00:26:27,260
isn't the only viable target pi PI is

00:26:24,590 --> 00:26:29,780
written in C the jittered Python

00:26:27,260 --> 00:26:31,160
compiler because it's written in C it

00:26:29,780 --> 00:26:32,900
can be compiled within scripting as well

00:26:31,160 --> 00:26:34,520
Ryan Kelley experimented this for a

00:26:32,900 --> 00:26:36,200
couple years ago he was even able to get

00:26:34,520 --> 00:26:41,060
the download down to a very spelts two

00:26:36,200 --> 00:26:42,650
megabyte and because wisdom can turn out

00:26:41,060 --> 00:26:42,990
a wesen could turn out to be the way to

00:26:42,650 --> 00:26:44,640
save

00:26:42,990 --> 00:26:47,280
batavia size problem stripping back the

00:26:44,640 --> 00:26:49,800
cpython to just the runtime and getting

00:26:47,280 --> 00:26:51,720
that into wesen format may end up being

00:26:49,800 --> 00:26:55,170
the best way to get a small and fast

00:26:51,720 --> 00:26:56,910
Python in the browser now I have been

00:26:55,170 --> 00:26:58,200
focusing on Python but none of those

00:26:56,910 --> 00:27:00,150
techniques are especially Python

00:26:58,200 --> 00:27:01,890
specific I like Python a lot but I don't

00:27:00,150 --> 00:27:03,540
want Python to be a monoculture any more

00:27:01,890 --> 00:27:05,340
than I want javascript to be one there

00:27:03,540 --> 00:27:06,660
are countless other languages that have

00:27:05,340 --> 00:27:07,410
analogues to the techniques that I've

00:27:06,660 --> 00:27:09,660
described here

00:27:07,410 --> 00:27:10,950
there are countless language x2

00:27:09,660 --> 00:27:12,420
JavaScript transpilers there are

00:27:10,950 --> 00:27:14,130
bytecode machines and their equivalents

00:27:12,420 --> 00:27:16,830
and there are ways and targeting

00:27:14,130 --> 00:27:19,020
compilers the rust compiler for example

00:27:16,830 --> 00:27:21,960
now ships with the ability to compile

00:27:19,020 --> 00:27:24,900
directly to web assembly and there are

00:27:21,960 --> 00:27:27,120
projects out there doing that for Python

00:27:24,900 --> 00:27:30,030
rust Python is an attempt to provide ace

00:27:27,120 --> 00:27:32,610
a Python interpreter in rust and another

00:27:30,030 --> 00:27:36,360
one Python VM rust that implements a C

00:27:32,610 --> 00:27:38,340
Python virtual machine in rushed if we

00:27:36,360 --> 00:27:41,270
can take that project source code and

00:27:38,340 --> 00:27:46,320
rusts ability to produce web assembly

00:27:41,270 --> 00:27:48,210
profit so the future of a web with other

00:27:46,320 --> 00:27:49,650
options other than javascript is looking

00:27:48,210 --> 00:27:51,240
really promising where to from here

00:27:49,650 --> 00:27:52,740
we're getting really close to breaking

00:27:51,240 --> 00:27:54,750
Java scripts monopoly on web development

00:27:52,740 --> 00:27:56,370
as being a web development language and

00:27:54,750 --> 00:27:58,110
making Python and other languages a

00:27:56,370 --> 00:28:00,720
viable option for web page development

00:27:58,110 --> 00:28:02,970
there are some pieces missing the one

00:28:00,720 --> 00:28:04,980
the big one that I've mentioned is wesen

00:28:02,970 --> 00:28:06,420
support for the Dom without Dom access

00:28:04,980 --> 00:28:08,190
the wesam approach really won't be

00:28:06,420 --> 00:28:09,990
useful unless the app is completely

00:28:08,190 --> 00:28:11,820
self-contained and that works great for

00:28:09,990 --> 00:28:13,500
games but if you want web browsers to

00:28:11,820 --> 00:28:15,210
remain as discoverable Internet content

00:28:13,500 --> 00:28:19,340
not just the second coming of Macromedia

00:28:15,210 --> 00:28:22,110
flash well we're gonna need Dom access

00:28:19,340 --> 00:28:24,120
tied in with that is wesen support for

00:28:22,110 --> 00:28:25,710
garbage collected memory models wisdom

00:28:24,120 --> 00:28:27,420
currently requires you to manually

00:28:25,710 --> 00:28:29,309
allocate and deallocate heap memory

00:28:27,420 --> 00:28:30,270
you're using which again is fine if

00:28:29,309 --> 00:28:32,640
you're managing everything yourself

00:28:30,270 --> 00:28:33,929
inside a game window or something but if

00:28:32,640 --> 00:28:35,490
you're interacting with the DOM and with

00:28:33,929 --> 00:28:37,110
JavaScript potentially other modules

00:28:35,490 --> 00:28:38,550
written in other languages we need to

00:28:37,110 --> 00:28:39,960
know what the garbage collection rules

00:28:38,550 --> 00:28:42,480
are for that memory when it gets when it

00:28:39,960 --> 00:28:44,160
gets gets dropped those two are needed

00:28:42,480 --> 00:28:46,050
for any language support for Python

00:28:44,160 --> 00:28:47,370
specifically we need a version of the

00:28:46,050 --> 00:28:49,200
Python standard library that isn't

00:28:47,370 --> 00:28:51,120
dependent on C or at least one where the

00:28:49,200 --> 00:28:53,730
interface to C is very well documented

00:28:51,120 --> 00:28:55,230
and we need better debugging integration

00:28:53,730 --> 00:28:56,190
if we can't debug code where it's

00:28:55,230 --> 00:28:59,009
running what's the

00:28:56,190 --> 00:29:00,389
point but these are solvable problems

00:28:59,009 --> 00:29:01,500
and in the case of the first two the

00:29:00,389 --> 00:29:03,600
Western working group is actually

00:29:01,500 --> 00:29:05,309
working on them as for the other two

00:29:03,600 --> 00:29:06,720
well the last couple of years the work

00:29:05,309 --> 00:29:08,610
I've been doing is being captured under

00:29:06,720 --> 00:29:10,230
the umbrella of the beware project be

00:29:08,610 --> 00:29:11,519
where is my attempt to enable us to use

00:29:10,230 --> 00:29:12,960
Python anywhere you might put your

00:29:11,519 --> 00:29:15,149
business logic or on your phone your

00:29:12,960 --> 00:29:17,639
tablet your set-top box and yes in the

00:29:15,149 --> 00:29:19,590
browser row Boston Bay and Batavia are

00:29:17,639 --> 00:29:21,120
both parts of the beware project another

00:29:19,590 --> 00:29:22,649
piece I didn't mention today is togo

00:29:21,120 --> 00:29:24,330
that's a cross-platform widget toolkit

00:29:22,649 --> 00:29:26,639
supports the browser as a deployment

00:29:24,330 --> 00:29:27,779
platform bug jar is another beware

00:29:26,639 --> 00:29:29,129
project it's a bugger that can

00:29:27,779 --> 00:29:31,500
potentially fill the gap for browser

00:29:29,129 --> 00:29:33,389
side debugging I will be here Monday and

00:29:31,500 --> 00:29:35,340
Tuesday sprinting on both of these days

00:29:33,389 --> 00:29:37,169
and I thought these aren't a lot on

00:29:35,340 --> 00:29:38,460
these and other parts of beware I've got

00:29:37,169 --> 00:29:39,570
stickers if that's your thing or if you

00:29:38,460 --> 00:29:41,519
just want to chat about a future where

00:29:39,570 --> 00:29:43,169
we can write bright browser apps in

00:29:41,519 --> 00:29:44,669
languages other than Java Script can say

00:29:43,169 --> 00:29:46,470
hi I'll be out there I'll be out and

00:29:44,669 --> 00:29:49,309
around for the rest of the conference so

00:29:46,470 --> 00:29:49,309
thank you very much

00:29:56,179 --> 00:30:00,799

YouTube URL: https://www.youtube.com/watch?v=2XSeNQyPlTY


