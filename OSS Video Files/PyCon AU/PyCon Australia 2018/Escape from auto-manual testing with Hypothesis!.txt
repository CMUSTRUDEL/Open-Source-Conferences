Title: Escape from auto-manual testing with Hypothesis!
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Zac Hatfield-Dodds

https://2018.pycon-au.org/talks/44889-escape-from-automanual-testing-with-hypothesis/

Have you ever wanted someone else to write your test cases? There’s a library for that!

You declare a strategy for inputs - from ‘an integer’ to ‘matching this regex’ to ‘Django model’; Hypothesis finds bugs and reports minimal failing examples. Too good to be true? Come see for yourself!

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,319 --> 00:00:07,890
Hey good afternoon everyone and welcome

00:00:03,149 --> 00:00:10,769
to the afternoon session today we have

00:00:07,890 --> 00:00:12,509
Zack Hatfield Dodds talking he's been

00:00:10,769 --> 00:00:14,670
writing Python for around five years

00:00:12,509 --> 00:00:17,100
with a focus on open source tools for

00:00:14,670 --> 00:00:19,070
fun and TB scale data analysis on

00:00:17,100 --> 00:00:24,890
Australia's national national computer

00:00:19,070 --> 00:00:27,390
supercomputer but today he'll be talking

00:00:24,890 --> 00:00:31,730
today he'll be talking about escape from

00:00:27,390 --> 00:00:31,730
auto manual testing with hypothesis

00:00:35,809 --> 00:00:41,309
thank you I guess the first question

00:00:39,300 --> 00:00:44,219
many of you have will what on earth is

00:00:41,309 --> 00:00:46,649
auto manual testing or possibly what is

00:00:44,219 --> 00:00:48,660
hypothesis the good news is this talk

00:00:46,649 --> 00:00:51,000
will explain both and if you're still

00:00:48,660 --> 00:00:54,420
confused you can find my slides at this

00:00:51,000 --> 00:00:56,070
link after the talk so I'm gonna start

00:00:54,420 --> 00:00:57,930
by talking about a couple of different

00:00:56,070 --> 00:00:59,879
kinds of tests that you might have

00:00:57,930 --> 00:01:03,570
encountered or maybe that you haven't

00:00:59,879 --> 00:01:06,229
heard of so the first one is what I mean

00:01:03,570 --> 00:01:09,060
when I say an auto manual test so a

00:01:06,229 --> 00:01:11,729
completely manual test is where a human

00:01:09,060 --> 00:01:13,170
does something so you have a web app you

00:01:11,729 --> 00:01:14,790
try to navigate to your home page and

00:01:13,170 --> 00:01:17,250
your website and confirm that it's there

00:01:14,790 --> 00:01:19,110
that's a manual test an automated test

00:01:17,250 --> 00:01:21,180
is where you've written a program that

00:01:19,110 --> 00:01:22,590
tests your program for you because this

00:01:21,180 --> 00:01:24,240
is kind of what we do as programs we

00:01:22,590 --> 00:01:26,040
write programs to do our jobs for us and

00:01:24,240 --> 00:01:30,000
then hopefully get a more interesting

00:01:26,040 --> 00:01:32,280
job so an auto manual test is a program

00:01:30,000 --> 00:01:33,530
to test a program that was hand written

00:01:32,280 --> 00:01:36,420
by a human

00:01:33,530 --> 00:01:38,909
this can include unit tests integration

00:01:36,420 --> 00:01:41,310
tests parameterised tests there's a lot

00:01:38,909 --> 00:01:43,229
of kinds of tests but fundamentally if

00:01:41,310 --> 00:01:46,250
you write it and then a computer runs it

00:01:43,229 --> 00:01:49,079
I call it an auto manual test a

00:01:46,250 --> 00:01:50,939
generative test is where the computer

00:01:49,079 --> 00:01:53,670
writes part of the test for you

00:01:50,939 --> 00:01:55,470
and with hypothesis this can be

00:01:53,670 --> 00:01:57,420
providing arguments to a test function

00:01:55,470 --> 00:02:00,540
in the same way that a parametrized

00:01:57,420 --> 00:02:02,520
decorator might do or I won't be talking

00:02:00,540 --> 00:02:05,399
about this in detail today hypothesis

00:02:02,520 --> 00:02:07,670
can generate entire test programs where

00:02:05,399 --> 00:02:09,569
you can describe how to use your API and

00:02:07,670 --> 00:02:12,280
hypotheses we'll try to generate

00:02:09,569 --> 00:02:14,620
programs that raise some exception

00:02:12,280 --> 00:02:16,570
the basic idea is that if you spend a

00:02:14,620 --> 00:02:18,280
lot of time writing tests you might as

00:02:16,570 --> 00:02:21,460
well write a program that automates

00:02:18,280 --> 00:02:23,020
writing tests and then profit for those

00:02:21,460 --> 00:02:24,610
who know the original comic it goes on

00:02:23,020 --> 00:02:26,200
about ongoing development time but the

00:02:24,610 --> 00:02:27,690
point of a library is that somebody else

00:02:26,200 --> 00:02:30,040
does that for you

00:02:27,690 --> 00:02:31,660
and there are a bunch of interesting

00:02:30,040 --> 00:02:33,280
tests that I'm not going to talk about

00:02:31,660 --> 00:02:35,620
like sir not appearing in this film

00:02:33,280 --> 00:02:38,380
there are dipped asts where you compare

00:02:35,620 --> 00:02:40,120
the output of your program to known good

00:02:38,380 --> 00:02:42,850
output and that's fundamentally what

00:02:40,120 --> 00:02:45,760
python doc tests do there are mutation

00:02:42,850 --> 00:02:47,590
tests which edit your codes to check

00:02:45,760 --> 00:02:49,780
that your original test suite can find

00:02:47,590 --> 00:02:52,180
the new bug there are coverage tests

00:02:49,780 --> 00:02:54,610
which let you find code that your tests

00:02:52,180 --> 00:02:56,590
didn't actually execute on the basis

00:02:54,610 --> 00:02:58,660
that code which wasn't executed by your

00:02:56,590 --> 00:03:00,520
test can't possibly have been tested by

00:02:58,660 --> 00:03:02,020
your test a lot of people measure

00:03:00,520 --> 00:03:04,239
coverage in a percentage but I actually

00:03:02,020 --> 00:03:05,590
think that's quite unhelpful because

00:03:04,239 --> 00:03:08,500
what you're really interested in is what

00:03:05,590 --> 00:03:10,780
part of my code is untested not how much

00:03:08,500 --> 00:03:12,310
has been executed by my tests and then

00:03:10,780 --> 00:03:14,590
there's a lot of static analysis tools

00:03:12,310 --> 00:03:15,880
like my pile Pyland which will try to

00:03:14,590 --> 00:03:20,560
determine something about your code

00:03:15,880 --> 00:03:22,450
without running it at all so property

00:03:20,560 --> 00:03:24,760
based testing there's a kind of

00:03:22,450 --> 00:03:26,350
generative test the idea being that you

00:03:24,760 --> 00:03:29,830
have a general property of your code

00:03:26,350 --> 00:03:31,750
which should hold for any range of input

00:03:29,830 --> 00:03:33,580
some there's some kind of valid input

00:03:31,750 --> 00:03:36,340
and if you can describe that you can

00:03:33,580 --> 00:03:37,360
have a property based test so we're

00:03:36,340 --> 00:03:40,720
going to start with a simple example

00:03:37,360 --> 00:03:42,730
let's imagine for the sake of the

00:03:40,720 --> 00:03:45,160
example that you want to test that the

00:03:42,730 --> 00:03:47,860
sum of a list of integers is greater

00:03:45,160 --> 00:03:50,230
than the maximum I know this is a stupid

00:03:47,860 --> 00:03:53,410
test the idea is how you write it

00:03:50,230 --> 00:03:55,360
not what you're testing so our original

00:03:53,410 --> 00:03:57,670
version we just have standard unit tests

00:03:55,360 --> 00:04:00,549
right right the test assert the thing we

00:03:57,670 --> 00:04:02,110
want to assert we can not repeat

00:04:00,549 --> 00:04:04,630
ourselves by using the PI test

00:04:02,110 --> 00:04:07,269
parameterize decorator so we can pass it

00:04:04,630 --> 00:04:08,950
a sequence of inputs to try with and PI

00:04:07,269 --> 00:04:11,980
tests will try to those in turn and tell

00:04:08,950 --> 00:04:15,670
us which ones failed or with hypothesis

00:04:11,980 --> 00:04:18,609
you can simply say given any list of any

00:04:15,670 --> 00:04:22,450
integers this property should hold and

00:04:18,609 --> 00:04:23,800
when we run this hypothesis tells us

00:04:22,450 --> 00:04:24,840
that we can't get the maximum of an

00:04:23,800 --> 00:04:27,340
empty list

00:04:24,840 --> 00:04:29,770
because there's no values in the list so

00:04:27,340 --> 00:04:32,110
there's no maximum okay okay

00:04:29,770 --> 00:04:33,880
list of integers but the minimum size of

00:04:32,110 --> 00:04:37,990
the list is one right so lists of at

00:04:33,880 --> 00:04:40,270
least one integers and then of course if

00:04:37,990 --> 00:04:44,080
there's one element in a list the sum is

00:04:40,270 --> 00:04:45,760
the same as the maximum but hypothesis

00:04:44,080 --> 00:04:47,650
doesn't just give us any list with one

00:04:45,760 --> 00:04:49,150
number it gives us the minimal list with

00:04:47,650 --> 00:04:53,110
one number which is a list just

00:04:49,150 --> 00:04:56,620
containing zero okay equal to or greater

00:04:53,110 --> 00:04:59,830
then let's try that anyone think of

00:04:56,620 --> 00:05:02,290
negative numbers if you add up a list

00:04:59,830 --> 00:05:06,100
with a negative number or more than one

00:05:02,290 --> 00:05:08,140
the sum can be less than the maximum but

00:05:06,100 --> 00:05:10,600
notice again hypothesis has given us the

00:05:08,140 --> 00:05:14,320
smallest possible example of a list like

00:05:10,600 --> 00:05:16,270
this so our final test goes for any list

00:05:14,320 --> 00:05:18,340
of integers where each integer is at

00:05:16,270 --> 00:05:21,610
least zero and there's at least one of

00:05:18,340 --> 00:05:24,310
those integers in the list the sum will

00:05:21,610 --> 00:05:27,250
be at least as large as the maximum and

00:05:24,310 --> 00:05:28,540
this test passes and hopefully like me

00:05:27,250 --> 00:05:30,670
at this point you're pretty confident

00:05:28,540 --> 00:05:32,380
that that assertion is right but you've

00:05:30,670 --> 00:05:34,120
also learned something about the code

00:05:32,380 --> 00:05:35,500
that you're testing which you might not

00:05:34,120 --> 00:05:39,340
have found just by looking at it and

00:05:35,500 --> 00:05:40,630
writing test cases by hand so I'm going

00:05:39,340 --> 00:05:42,400
to walk through a couple of the ways

00:05:40,630 --> 00:05:45,490
that you can describe inputs to your

00:05:42,400 --> 00:05:47,560
test with hypothesis the first one of

00:05:45,490 --> 00:05:49,360
course if if you want simple values you

00:05:47,560 --> 00:05:52,900
know none boolean x' integers floats

00:05:49,360 --> 00:05:55,060
strings x dates there are a lot of them

00:05:52,900 --> 00:05:57,610
and hypothesis has functions which can

00:05:55,060 --> 00:05:58,720
generate them tiny link down the bottom

00:05:57,610 --> 00:06:00,580
which you can see on the slides on

00:05:58,720 --> 00:06:03,430
github is a link to the documentation

00:06:00,580 --> 00:06:05,800
which describes this in detail for argue

00:06:03,430 --> 00:06:07,660
for types which have specific kinds of

00:06:05,800 --> 00:06:09,460
behaviors so for example floating-point

00:06:07,660 --> 00:06:11,410
numbers have a bunch of edge cases as

00:06:09,460 --> 00:06:13,660
well as providing the minimum and

00:06:11,410 --> 00:06:15,640
maximum value so that you can constrain

00:06:13,660 --> 00:06:18,280
them to a particular range you can also

00:06:15,640 --> 00:06:21,040
explicitly exclude or include infinity

00:06:18,280 --> 00:06:23,610
or not a number because let's be honest

00:06:21,040 --> 00:06:26,260
nobody wants to deal with not a number

00:06:23,610 --> 00:06:28,300
for collections you give it the

00:06:26,260 --> 00:06:31,180
collection type and then you also pass

00:06:28,300 --> 00:06:33,430
the elements of that collection so we've

00:06:31,180 --> 00:06:35,800
already seen this lists of integers not

00:06:33,430 --> 00:06:38,360
just lists

00:06:35,800 --> 00:06:40,370
once you've got the basic thing down you

00:06:38,360 --> 00:06:42,050
can change the things that you get from

00:06:40,370 --> 00:06:44,360
these strategies a little so the map

00:06:42,050 --> 00:06:46,250
method of a strategy applies a function

00:06:44,360 --> 00:06:49,040
to whatever you draw so if we take a

00:06:46,250 --> 00:06:50,720
strategy integers and we map string over

00:06:49,040 --> 00:06:54,440
it the strategy will now generate

00:06:50,720 --> 00:06:56,330
strings of digits except it may also

00:06:54,440 --> 00:06:57,860
generate strings of digits would start

00:06:56,330 --> 00:07:01,790
with a minus sign if it drew a negative

00:06:57,860 --> 00:07:03,500
number we can also map a multiplication

00:07:01,790 --> 00:07:08,630
by two if we only want to get even

00:07:03,500 --> 00:07:10,940
numbers or filter a modulo two to

00:07:08,630 --> 00:07:14,180
exclude any numbers where the remainder

00:07:10,940 --> 00:07:15,950
is zero this is an inefficient way to do

00:07:14,180 --> 00:07:17,810
it though filter is really designed for

00:07:15,950 --> 00:07:19,160
edge cases and if you want odd numbers

00:07:17,810 --> 00:07:23,960
you'd be better off multiplying by two

00:07:19,160 --> 00:07:25,790
and then adding one there are of course

00:07:23,960 --> 00:07:27,980
more advanced things if you need more

00:07:25,790 --> 00:07:30,560
complicated data structures there are

00:07:27,980 --> 00:07:31,970
ways to call custom functions or classes

00:07:30,560 --> 00:07:34,730
with inputs that you describe to

00:07:31,970 --> 00:07:38,450
generate recursive data such as JSON or

00:07:34,730 --> 00:07:40,880
other nested structures you can draw new

00:07:38,450 --> 00:07:43,100
data parts inside your test function if

00:07:40,880 --> 00:07:44,570
the data that you need to run your test

00:07:43,100 --> 00:07:46,910
depends in some way on what's already

00:07:44,570 --> 00:07:49,730
happened and finally you can define your

00:07:46,910 --> 00:07:51,470
own custom strategies which use any of

00:07:49,730 --> 00:07:53,390
the strategies provided by hypothesis

00:07:51,470 --> 00:07:57,710
mixed in with any passing code that you

00:07:53,390 --> 00:07:59,750
can write the final final way to get

00:07:57,710 --> 00:08:02,180
data for your test is to work out from

00:07:59,750 --> 00:08:04,040
looking at the code again this is in the

00:08:02,180 --> 00:08:06,950
vein of web programmers shouldn't the

00:08:04,040 --> 00:08:09,169
computer be doing this because if you

00:08:06,950 --> 00:08:12,020
have a schema a schema is a way of

00:08:09,169 --> 00:08:14,570
describing what valid data is to a

00:08:12,020 --> 00:08:16,280
computer and typically these are used

00:08:14,570 --> 00:08:18,440
for validating input whether you're

00:08:16,280 --> 00:08:20,780
about to save it to a database receive

00:08:18,440 --> 00:08:23,240
it from a user in some way clean data

00:08:20,780 --> 00:08:25,160
that you don't trust but in many cases

00:08:23,240 --> 00:08:27,200
we can actually inspect the Python

00:08:25,160 --> 00:08:30,229
objects at runtime and go for example

00:08:27,200 --> 00:08:31,910
this is a regular expression we know how

00:08:30,229 --> 00:08:33,650
those work and we can generate for you

00:08:31,910 --> 00:08:36,500
strings that will always match that

00:08:33,650 --> 00:08:38,839
regular expression or if you use numpy

00:08:36,500 --> 00:08:40,909
or pandas you can get the data type and

00:08:38,839 --> 00:08:43,039
generate any thing that could be an

00:08:40,909 --> 00:08:45,230
element in an array of that data type or

00:08:43,039 --> 00:08:47,630
if you have a function with type hints

00:08:45,230 --> 00:08:49,670
hypotheses can inspect that and work out

00:08:47,630 --> 00:08:51,140
what type of argument to call it

00:08:49,670 --> 00:08:53,600
construct the strategy that will

00:08:51,140 --> 00:08:56,630
generate instances of that type and then

00:08:53,600 --> 00:08:58,070
call it for you there's a lot of detail

00:08:56,630 --> 00:09:00,670
if you're interested talk to me

00:08:58,070 --> 00:09:02,839
afterwards or check out the docs but

00:09:00,670 --> 00:09:05,140
then there's the question right of okay

00:09:02,839 --> 00:09:07,250
we generate input what tests do we write

00:09:05,140 --> 00:09:08,950
there's any one written property based

00:09:07,250 --> 00:09:13,250
test before can I see a show of hands

00:09:08,950 --> 00:09:15,410
there's a few people awesome my favorite

00:09:13,250 --> 00:09:18,770
one is called fuzzing you don't assert

00:09:15,410 --> 00:09:21,830
anything you just call your function it

00:09:18,770 --> 00:09:25,610
is deeply embarrassing how helpful this

00:09:21,830 --> 00:09:27,770
is you don't have to have any assertions

00:09:25,610 --> 00:09:29,240
in the test because it's just looking

00:09:27,770 --> 00:09:31,070
for assertions that happen inside the

00:09:29,240 --> 00:09:33,020
code that you're testing or exceptions

00:09:31,070 --> 00:09:34,610
of any kind so remember in that first

00:09:33,020 --> 00:09:36,890
example where we discovered you can't

00:09:34,610 --> 00:09:38,990
take the maximum of an empty list if

00:09:36,890 --> 00:09:40,580
that was production code hopefully

00:09:38,990 --> 00:09:42,290
somewhere we would validate that the

00:09:40,580 --> 00:09:47,050
list was not empty before we tried to

00:09:42,290 --> 00:09:50,540
call max on it and this kind of

00:09:47,050 --> 00:09:52,970
combination of early validation and then

00:09:50,540 --> 00:09:56,000
checking later is why I love assertions

00:09:52,970 --> 00:09:57,110
so much the best definition of assertion

00:09:56,000 --> 00:09:59,089
that I've found is that it's an

00:09:57,110 --> 00:10:02,510
expression which should always be true

00:09:59,089 --> 00:10:04,100
unless there's a bug in the program so

00:10:02,510 --> 00:10:06,260
you don't use assertions to check that

00:10:04,100 --> 00:10:09,230
user input is correct you don't use

00:10:06,260 --> 00:10:10,520
assertions to test that somebody called

00:10:09,230 --> 00:10:12,200
your function with the right argument

00:10:10,520 --> 00:10:13,700
you use it where you think you might

00:10:12,200 --> 00:10:16,310
have made a mistake where there's some

00:10:13,700 --> 00:10:17,779
complicated invariant or something where

00:10:16,310 --> 00:10:18,440
you're just not quite certain how the

00:10:17,779 --> 00:10:20,420
thing should work

00:10:18,440 --> 00:10:22,190
you can put an assertion so that if

00:10:20,420 --> 00:10:24,500
something goes wrong or the if your

00:10:22,190 --> 00:10:26,900
mental model of the code is not quite

00:10:24,500 --> 00:10:29,120
right you find out as soon as it happens

00:10:26,900 --> 00:10:31,540
not 30 calls later when the incorrect

00:10:29,120 --> 00:10:34,279
value eventually turns up somewhere and

00:10:31,540 --> 00:10:36,500
this idea of putting the assertions

00:10:34,279 --> 00:10:38,360
inside the code is often called designed

00:10:36,500 --> 00:10:39,529
by contract and there are a couple of

00:10:38,360 --> 00:10:42,560
libraries that can make that a lot

00:10:39,529 --> 00:10:44,270
easier most importantly if you have

00:10:42,560 --> 00:10:46,310
these assertions embedded in your code

00:10:44,270 --> 00:10:48,740
it means that the simple fuzzing pattern

00:10:46,310 --> 00:10:51,620
gives you integration tests completely

00:10:48,740 --> 00:10:53,690
for free and so property based testing

00:10:51,620 --> 00:10:56,240
if you already do design by contract is

00:10:53,690 --> 00:10:59,480
where you can restrict the inputs to

00:10:56,240 --> 00:11:01,820
your tests even further for example the

00:10:59,480 --> 00:11:03,160
one with the sum and the maximum only

00:11:01,820 --> 00:11:05,649
works over a restrict

00:11:03,160 --> 00:11:07,779
good set of lists of integers and then

00:11:05,649 --> 00:11:09,430
you can make more specific assertions

00:11:07,779 --> 00:11:11,279
which further constrain the behavior of

00:11:09,430 --> 00:11:13,810
your program

00:11:11,279 --> 00:11:15,759
another great property to test is an

00:11:13,810 --> 00:11:18,399
invariant anything that doesn't change

00:11:15,759 --> 00:11:19,899
or should always be true so for example

00:11:18,399 --> 00:11:22,600
if you take a list and you add the last

00:11:19,899 --> 00:11:23,680
element on again taking the set should

00:11:22,600 --> 00:11:26,170
give you a different number of each

00:11:23,680 --> 00:11:29,889
element but taking the set of a set

00:11:26,170 --> 00:11:32,019
should always give you an equal set or

00:11:29,889 --> 00:11:33,910
if you sort a list you should always

00:11:32,019 --> 00:11:35,769
have the same elements as you started

00:11:33,910 --> 00:11:38,019
maybe in a different order that the

00:11:35,769 --> 00:11:40,480
elements should be the same so if your

00:11:38,019 --> 00:11:42,339
code should have invariants testing them

00:11:40,480 --> 00:11:45,639
with random data can often show up quite

00:11:42,339 --> 00:11:48,279
subtle bugs there's another category of

00:11:45,639 --> 00:11:50,079
problems which are difficult to find a

00:11:48,279 --> 00:11:52,449
solution to but easy to check whether or

00:11:50,079 --> 00:11:54,100
not a solution is correct so if you have

00:11:52,449 --> 00:11:55,920
a code which is meant to find a solution

00:11:54,100 --> 00:11:58,930
why not just check that it worked

00:11:55,920 --> 00:12:00,939
classic examples most cryptography rests

00:11:58,930 --> 00:12:03,180
on the idea that finding the prime

00:12:00,939 --> 00:12:05,589
factors of large numbers is very hard

00:12:03,180 --> 00:12:07,509
but the reason we can use this for

00:12:05,589 --> 00:12:09,220
cryptography is that calculating the

00:12:07,509 --> 00:12:11,620
multiplication of numbers is actually

00:12:09,220 --> 00:12:13,689
very easy or if you're writing a

00:12:11,620 --> 00:12:15,430
programming language tokenizing a string

00:12:13,689 --> 00:12:19,089
breaking it up into the specific parts

00:12:15,430 --> 00:12:20,709
of a program can be tricky but checking

00:12:19,089 --> 00:12:21,959
that each token is a valid token and

00:12:20,709 --> 00:12:25,209
then sticking them back together

00:12:21,959 --> 00:12:27,759
reasonably quick there are a bunch of

00:12:25,209 --> 00:12:30,130
functions or bits of code which should

00:12:27,759 --> 00:12:32,350
round-trip for the way actually started

00:12:30,130 --> 00:12:33,880
using hypothesis was they had a library

00:12:32,350 --> 00:12:35,949
for a file format that I didn't trust

00:12:33,880 --> 00:12:37,720
enough so that well what if I just

00:12:35,949 --> 00:12:39,880
generate random data save it to disk and

00:12:37,720 --> 00:12:41,620
read it back right if the library works

00:12:39,880 --> 00:12:43,630
I should always have the same data at

00:12:41,620 --> 00:12:44,949
the end of that and it turned out that I

00:12:43,630 --> 00:12:46,600
was right to be suspicious it was

00:12:44,949 --> 00:12:48,149
dropping some white space in headers and

00:12:46,600 --> 00:12:52,180
that was where my focus was coming from

00:12:48,149 --> 00:12:55,059
so dump to JSON load to JSON set an

00:12:52,180 --> 00:13:00,339
attribute get an attribute multiply

00:12:55,059 --> 00:13:02,410
divide accept with zero but the best

00:13:00,339 --> 00:13:04,750
pattern of all if you're lucky enough to

00:13:02,410 --> 00:13:06,370
take advantage of it is to compare your

00:13:04,750 --> 00:13:08,709
code to another bit of code which does

00:13:06,370 --> 00:13:10,120
the same thing that you trust so if

00:13:08,709 --> 00:13:12,610
you're rewriting or refactoring

00:13:10,120 --> 00:13:14,829
something you can feed both systems the

00:13:12,610 --> 00:13:16,750
same input and confirm that your new

00:13:14,829 --> 00:13:17,020
hotness is the same as the boring legacy

00:13:16,750 --> 00:13:19,270
thing

00:13:17,020 --> 00:13:20,709
or you can check that your fancy

00:13:19,270 --> 00:13:22,810
algorithm works the same way as the

00:13:20,709 --> 00:13:24,630
brute force thing and maybe the brute

00:13:22,810 --> 00:13:26,830
force one is too slow to run in prod

00:13:24,630 --> 00:13:28,810
particularly on large inputs or without

00:13:26,830 --> 00:13:31,149
vers aerial examples but I bet you can

00:13:28,810 --> 00:13:33,910
run it on tests at least on a subset of

00:13:31,149 --> 00:13:35,290
your inputs or of course if you're

00:13:33,910 --> 00:13:37,540
running multi-threaded parallel

00:13:35,290 --> 00:13:42,630
concurrent code has anyone ever had bugs

00:13:37,540 --> 00:13:44,830
from that I'm impressed not many of you

00:13:42,630 --> 00:13:48,910
you can check that it works the same way

00:13:44,830 --> 00:13:51,130
with one's rotors with 100 last part of

00:13:48,910 --> 00:13:55,600
my talk is on some of the advanced tips

00:13:51,130 --> 00:13:57,220
specific to hypothesis of course it's a

00:13:55,600 --> 00:13:59,020
library for testing it's designed for

00:13:57,220 --> 00:14:00,820
use by developers and so you can

00:13:59,020 --> 00:14:03,070
configure a lot of different things you

00:14:00,820 --> 00:14:04,570
can make it spit out for both you can

00:14:03,070 --> 00:14:06,760
change the verbosity level get debug

00:14:04,570 --> 00:14:09,459
information or make it run in quiet mode

00:14:06,760 --> 00:14:11,230
you can decide either globally or for

00:14:09,459 --> 00:14:13,480
each specific test how many test cases

00:14:11,230 --> 00:14:15,190
you want it to try we default to a

00:14:13,480 --> 00:14:16,839
hundred but maybe that's too slow for

00:14:15,190 --> 00:14:17,950
what if your tests or maybe there's

00:14:16,839 --> 00:14:21,070
something where you just want to run a

00:14:17,950 --> 00:14:23,050
million tests to be extra sure you can

00:14:21,070 --> 00:14:24,579
decide where it cases examples that it

00:14:23,050 --> 00:14:26,620
fails I'll get to that in a moment run

00:14:24,579 --> 00:14:29,200
it in deterministic mode a whole bunch

00:14:26,620 --> 00:14:31,660
of stuff again see the documentation and

00:14:29,200 --> 00:14:34,029
you can configure this either in your

00:14:31,660 --> 00:14:36,070
setup code for your tests or as PI test

00:14:34,029 --> 00:14:37,750
arguments if you're using PI tests you

00:14:36,070 --> 00:14:42,430
can pass arguments specific to

00:14:37,750 --> 00:14:44,740
hypothesis whenever we talk about

00:14:42,430 --> 00:14:49,149
randomized inputs people go oh no I hate

00:14:44,740 --> 00:14:50,860
flaky tests we hate flaky tests too so

00:14:49,149 --> 00:14:53,380
we have an invariant for hypothesis that

00:14:50,860 --> 00:14:56,050
if a test fails it is always possible to

00:14:53,380 --> 00:14:58,000
reproduce that failure if you run

00:14:56,050 --> 00:14:59,320
hypothesis again on the same machine and

00:14:58,000 --> 00:15:02,020
you haven't messed with the database

00:14:59,320 --> 00:15:04,060
setting really badly every failure will

00:15:02,020 --> 00:15:06,279
be stored in a database so when you run

00:15:04,060 --> 00:15:08,079
the test again it will pick up every

00:15:06,279 --> 00:15:09,940
example that it's all failing last time

00:15:08,079 --> 00:15:12,610
run it again and see if the bug is still

00:15:09,940 --> 00:15:14,550
there so you never lose a bug however

00:15:12,610 --> 00:15:18,550
hard it was to find in the first place

00:15:14,550 --> 00:15:20,470
or if it runs on CI and the database was

00:15:18,550 --> 00:15:22,750
on a worker which then got garbage

00:15:20,470 --> 00:15:24,730
collected and you can't get it we also

00:15:22,750 --> 00:15:26,920
make sure that we try to do a couple of

00:15:24,730 --> 00:15:28,510
things so the simple functions we just

00:15:26,920 --> 00:15:30,400
print an example call to the function

00:15:28,510 --> 00:15:31,840
which should reproduce the bug

00:15:30,400 --> 00:15:33,610
if it looks like there was randomness

00:15:31,840 --> 00:15:36,070
used we also print the seed that would

00:15:33,610 --> 00:15:38,920
reproduce that and if all else fails we

00:15:36,070 --> 00:15:40,570
dump the entire state of the internals

00:15:38,920 --> 00:15:42,390
in a serialized format that lets you run

00:15:40,570 --> 00:15:46,830
the same test again deterministically

00:15:42,390 --> 00:15:49,350
that one's less fun but it always works

00:15:46,830 --> 00:15:51,940
people also ask a lot about performance

00:15:49,350 --> 00:15:53,530
hypothesis is vast there's a statistics

00:15:51,940 --> 00:15:56,080
option which you can check how fast it

00:15:53,530 --> 00:15:58,060
is or otherwise and it will give you

00:15:56,080 --> 00:15:59,800
things like the mean time of execution

00:15:58,060 --> 00:16:01,360
for each test case that you ran the

00:15:59,800 --> 00:16:03,520
percent of time spent generating data

00:16:01,360 --> 00:16:06,310
and the reason I say hypothesis is fast

00:16:03,520 --> 00:16:08,350
is that's typically quite low and if you

00:16:06,310 --> 00:16:10,900
can even define custom events so you can

00:16:08,350 --> 00:16:12,370
go essentially have a print statement

00:16:10,900 --> 00:16:14,560
somewhere in your function and have

00:16:12,370 --> 00:16:17,980
hypotheses tell you how often did it

00:16:14,560 --> 00:16:20,170
explore that part of your code the other

00:16:17,980 --> 00:16:23,200
side of the performance story is running

00:16:20,170 --> 00:16:27,070
your code a hundred times will usually

00:16:23,200 --> 00:16:28,660
be a hundred times law sometimes a

00:16:27,070 --> 00:16:31,420
little faster than that because of

00:16:28,660 --> 00:16:33,370
just-in-time compiling but usually about

00:16:31,420 --> 00:16:35,080
a hundred times slower and because we

00:16:33,370 --> 00:16:37,780
also run the code under coverage so that

00:16:35,080 --> 00:16:39,040
we can profile what paths of execution

00:16:37,780 --> 00:16:40,480
we've already tested and try to

00:16:39,040 --> 00:16:42,520
prioritize the ones we haven't yet

00:16:40,480 --> 00:16:45,670
there's a bit of an extra slowdown from

00:16:42,520 --> 00:16:47,740
that it's still worth it it makes us

00:16:45,670 --> 00:16:49,660
more effective at finding bugs but you

00:16:47,740 --> 00:16:52,210
can disable the coverage check it if

00:16:49,660 --> 00:16:54,010
it's a pathological case if you disable

00:16:52,210 --> 00:16:55,480
it please tell us so that we can work

00:16:54,010 --> 00:16:58,570
out why that's going wrong and fix it

00:16:55,480 --> 00:17:00,160
for you and the final part of my talk

00:16:58,570 --> 00:17:04,530
here's a couple of people who are using

00:17:00,160 --> 00:17:07,839
hypothesis pandas who's heard of pandas

00:17:04,530 --> 00:17:09,970
lots of people pandas uses hypothesis to

00:17:07,839 --> 00:17:12,010
check their date/time handling that when

00:17:09,970 --> 00:17:14,500
for example you take an array of date x

00:17:12,010 --> 00:17:15,940
or x and add an hour to it and subtract

00:17:14,500 --> 00:17:21,490
an hour to it you get the same time back

00:17:15,940 --> 00:17:23,140
that sounds really simple right one of

00:17:21,490 --> 00:17:24,670
my favorite ones that i've seen recently

00:17:23,140 --> 00:17:27,220
is an essay from a high school teacher

00:17:24,670 --> 00:17:30,580
who uses hypothesis to mark his students

00:17:27,220 --> 00:17:32,770
assignments so there's a link there but

00:17:30,580 --> 00:17:34,990
the idea is it's a password checker you

00:17:32,770 --> 00:17:36,580
have password rules and it says at the

00:17:34,990 --> 00:17:39,010
top don't worry in big letters this is a

00:17:36,580 --> 00:17:40,600
bad password rule but you need at least

00:17:39,010 --> 00:17:42,250
eight characters at least a number a

00:17:40,600 --> 00:17:44,050
letter a symbol and you can't have your

00:17:42,250 --> 00:17:48,490
username in the password

00:17:44,050 --> 00:17:51,429
and all this one does is he defines text

00:17:48,490 --> 00:17:52,840
so one part random text mixed with a

00:17:51,429 --> 00:17:54,580
strategy that should always generate

00:17:52,840 --> 00:17:57,130
random passwords so the test will try

00:17:54,580 --> 00:17:59,050
both and then it simply runs the student

00:17:57,130 --> 00:18:01,420
code and the known good code and checks

00:17:59,050 --> 00:18:03,640
that they both give the same answer and

00:18:01,420 --> 00:18:06,160
if it doesn't it reports to the student

00:18:03,640 --> 00:18:09,850
the simplest example of an input that

00:18:06,160 --> 00:18:12,070
makes their code not work open API is a

00:18:09,850 --> 00:18:14,290
way of specifying what REST API is

00:18:12,070 --> 00:18:16,540
should do and someone's written a really

00:18:14,290 --> 00:18:19,660
cool tool which will check that a REST

00:18:16,540 --> 00:18:22,360
API matches the specification by calling

00:18:19,660 --> 00:18:24,400
the REST API so you can run this code

00:18:22,360 --> 00:18:26,020
which is based on hypothesis against a

00:18:24,400 --> 00:18:27,790
REST API which is implemented in any

00:18:26,020 --> 00:18:31,240
language because it speaks rest not

00:18:27,790 --> 00:18:33,160
Python stripe uses hypothesis quite

00:18:31,240 --> 00:18:36,070
intensively and it's even funded some

00:18:33,160 --> 00:18:38,380
features for us they use it to test

00:18:36,070 --> 00:18:39,670
machine learning feature development for

00:18:38,380 --> 00:18:42,850
their fraud detection pipeline and they

00:18:39,670 --> 00:18:45,370
don't give us details and finally it's

00:18:42,850 --> 00:18:48,220
2018 what talk would be complete without

00:18:45,370 --> 00:18:50,020
blockchain it turns out that aetherium

00:18:48,220 --> 00:18:51,700
also does something with hypothesis it

00:18:50,020 --> 00:18:53,650
looks like testing the Python virtual

00:18:51,700 --> 00:18:55,660
machine that they use to run in theory

00:18:53,650 --> 00:19:01,330
and virtual machine that they'd know

00:18:55,660 --> 00:19:02,820
block check blockchain at the last bit

00:19:01,330 --> 00:19:04,990
of this of course is the pitch

00:19:02,820 --> 00:19:07,270
hypothesis is an open source project

00:19:04,990 --> 00:19:09,280
it's under the Mozilla Public License

00:19:07,270 --> 00:19:10,840
which is quite a permissive license you

00:19:09,280 --> 00:19:12,850
can extend hypothesis under whatever

00:19:10,840 --> 00:19:14,200
license you like but if you modify the

00:19:12,850 --> 00:19:16,690
core files you have to share that with

00:19:14,200 --> 00:19:18,340
anyone you give them to we actually try

00:19:16,690 --> 00:19:19,780
to mentor contributors so if you come

00:19:18,340 --> 00:19:22,240
along to the sprints it's not just like

00:19:19,780 --> 00:19:24,220
patches welcome but I will actually help

00:19:22,240 --> 00:19:26,320
you write patches and if you're a

00:19:24,220 --> 00:19:28,870
company that's using hypothesis or wants

00:19:26,320 --> 00:19:30,100
to use hypothesis we offer both new

00:19:28,870 --> 00:19:32,350
feature development if you want to pay

00:19:30,100 --> 00:19:35,110
for that or training sessions for anyone

00:19:32,350 --> 00:19:36,600
who's still confused after a talk so

00:19:35,110 --> 00:19:38,650
that's pretty much the end of this

00:19:36,600 --> 00:19:42,179
pre-prepared section of the talk and I

00:19:38,650 --> 00:19:42,179
would love to take questions for people

00:19:47,349 --> 00:19:57,739
Thank You Zack oh great talk we're

00:19:50,299 --> 00:20:01,700
taking questions thank you I I would

00:19:57,739 --> 00:20:05,029
like to know if you hypothesis mix with

00:20:01,700 --> 00:20:07,399
another Auto manual type of tests and

00:20:05,029 --> 00:20:09,139
what type of tests how would you split

00:20:07,399 --> 00:20:11,059
between our tests this bit with

00:20:09,139 --> 00:20:13,369
hypothesis this bit of code or this type

00:20:11,059 --> 00:20:16,369
of features and test this bit with auto

00:20:13,369 --> 00:20:17,299
manual you know traditionally written

00:20:16,369 --> 00:20:20,299
tests thank you

00:20:17,299 --> 00:20:24,049
I mean the universal answer is it

00:20:20,299 --> 00:20:26,119
depends but what does it depend on for

00:20:24,049 --> 00:20:28,729
specific edge cases so if you're trying

00:20:26,119 --> 00:20:30,709
to test that a particular kind of input

00:20:28,729 --> 00:20:32,239
will raise a validation error I would

00:20:30,709 --> 00:20:34,759
usually do that with a traditional

00:20:32,239 --> 00:20:36,709
manual unit test simply because I don't

00:20:34,759 --> 00:20:38,059
think it's worth trying thousands of

00:20:36,709 --> 00:20:40,549
possible strings when the function

00:20:38,059 --> 00:20:42,679
should only accept integers on the other

00:20:40,549 --> 00:20:44,749
hand if it's something more complex so

00:20:42,679 --> 00:20:46,249
where there are many more possible kinds

00:20:44,749 --> 00:20:51,079
of input I would usually tend to use

00:20:46,249 --> 00:20:52,759
hypothesis you can also use hypothesis

00:20:51,079 --> 00:20:54,529
to supply some arguments and something

00:20:52,759 --> 00:20:57,469
like a PI test parameterize to supply

00:20:54,529 --> 00:20:59,599
others so if you want to try for example

00:20:57,469 --> 00:21:01,249
a specific couple of numbers plus other

00:20:59,599 --> 00:21:06,200
stuff you can mix hypothesis with other

00:21:01,249 --> 00:21:08,509
libraries for that thank you is a

00:21:06,200 --> 00:21:11,359
hypothesis sort of self-hosting is

00:21:08,509 --> 00:21:14,450
hypothesis used to test hypotheses you

00:21:11,359 --> 00:21:17,149
bet it is we test hypotheses with

00:21:14,450 --> 00:21:19,519
hypothesis on every supported version of

00:21:17,149 --> 00:21:22,399
Python every supported version of Jango

00:21:19,519 --> 00:21:26,200
the last five versions of pandas two

00:21:22,399 --> 00:21:29,119
versions of numpy two versions of faker

00:21:26,200 --> 00:21:31,639
only one version of Pi TSA because it's

00:21:29,119 --> 00:21:33,109
so stable the test suite takes quite a

00:21:31,639 --> 00:21:34,909
long time because we test against

00:21:33,109 --> 00:21:36,889
everything but it's a mixture of

00:21:34,909 --> 00:21:42,919
hypothesis tests and traditional unit

00:21:36,889 --> 00:21:45,079
tests hi it sounds like from your talk

00:21:42,919 --> 00:21:47,149
that you are a contributor to the

00:21:45,079 --> 00:21:48,739
hypothesis project so yeah I'm curious

00:21:47,149 --> 00:21:52,609
about what kind of stuff we've worked on

00:21:48,739 --> 00:21:54,169
within the project itself so for the

00:21:52,609 --> 00:21:55,549
last couple of months I've been quite

00:21:54,169 --> 00:21:57,139
busy at work and most of my

00:21:55,549 --> 00:21:57,920
contributions have been helping other

00:21:57,139 --> 00:22:00,470
contributors

00:21:57,920 --> 00:22:03,320
so reviewing fixing up documentation

00:22:00,470 --> 00:22:07,100
I've cleared more CI issues than I care

00:22:03,320 --> 00:22:08,930
to think of but features I've built I

00:22:07,100 --> 00:22:10,610
did the work which lets it infer from

00:22:08,930 --> 00:22:13,460
type ins what arguments it should use

00:22:10,610 --> 00:22:15,890
and there's a saying right that a pull

00:22:13,460 --> 00:22:18,260
request is like a puppy when they're

00:22:15,890 --> 00:22:19,730
young they're really cute and then you

00:22:18,260 --> 00:22:23,720
take it home you have to clean up after

00:22:19,730 --> 00:22:25,040
it turns out the typing runtime I'll

00:22:23,720 --> 00:22:27,080
almost change quite a bit over the last

00:22:25,040 --> 00:22:30,820
few versions of Python and that's been

00:22:27,080 --> 00:22:30,820
an exciting journey keeping it working

00:22:31,210 --> 00:22:38,930
hello hello your examples have been

00:22:36,700 --> 00:22:40,700
functions without side effects that just

00:22:38,930 --> 00:22:43,250
return something would you recommend

00:22:40,700 --> 00:22:46,190
hypotheses for testing some kind of

00:22:43,250 --> 00:22:47,870
interaction where the function doesn't

00:22:46,190 --> 00:22:51,650
return anything but it's expected to

00:22:47,870 --> 00:22:54,110
have some kind of side effect absolutely

00:22:51,650 --> 00:22:56,030
the caveat on this is that your side

00:22:54,110 --> 00:22:59,000
effects have to be isolated within each

00:22:56,030 --> 00:23:01,960
test case that hypothesis tries in order

00:22:59,000 --> 00:23:04,640
for it to minimize the example correctly

00:23:01,960 --> 00:23:06,290
also if it tries a number of tests and

00:23:04,640 --> 00:23:08,780
they have side effects between the test

00:23:06,290 --> 00:23:10,580
cases it's very hard to reproduce that

00:23:08,780 --> 00:23:13,460
failure because hypothesis assumes that

00:23:10,580 --> 00:23:15,440
each test case is independent but

00:23:13,460 --> 00:23:17,630
subject to that constraint absolutely

00:23:15,440 --> 00:23:19,610
works for side effects so for example

00:23:17,630 --> 00:23:21,890
the Django integration will actually

00:23:19,610 --> 00:23:23,480
generate a model instance and save it to

00:23:21,890 --> 00:23:25,370
the database for you before running your

00:23:23,480 --> 00:23:31,280
tests and then handle clearing out the

00:23:25,370 --> 00:23:34,600
database between each test case are

00:23:31,280 --> 00:23:34,600
there any more questions for Zack

00:23:48,180 --> 00:23:52,030
hey Zack thanks for the talk and thank

00:23:50,590 --> 00:23:54,100
you for the library

00:23:52,030 --> 00:23:56,020
you mentioned faker early in your list

00:23:54,100 --> 00:23:58,150
of things that you tests with hypothesis

00:23:56,020 --> 00:24:01,540
and that kind of crystallizes something

00:23:58,150 --> 00:24:03,040
I'm trying to think about so sometimes I

00:24:01,540 --> 00:24:04,870
use hypothesis when I've got like three

00:24:03,040 --> 00:24:06,370
or four well defined inputs that can

00:24:04,870 --> 00:24:08,590
define properties for their great

00:24:06,370 --> 00:24:10,360
there's a good application but sometimes

00:24:08,590 --> 00:24:11,800
I've got this big blob of crazy diet

00:24:10,360 --> 00:24:13,600
like a person's name in Russian or

00:24:11,800 --> 00:24:15,880
whatever it might be and then I go to a

00:24:13,600 --> 00:24:17,380
tool like faker I don't use that it

00:24:15,880 --> 00:24:18,850
feels like I've been lazy I should be

00:24:17,380 --> 00:24:20,140
using hypothesis for that as well give a

00:24:18,850 --> 00:24:23,680
comment on when you would use one or the

00:24:20,140 --> 00:24:25,630
other so personally I would always use

00:24:23,680 --> 00:24:29,440
hypothesis and it may be a little biased

00:24:25,630 --> 00:24:32,890
but I'll explain why the way faker works

00:24:29,440 --> 00:24:34,540
is it has essentially enormous lists and

00:24:32,890 --> 00:24:36,610
dictionaries of lists and tables of

00:24:34,540 --> 00:24:38,380
different kinds of inputs so you can ask

00:24:36,610 --> 00:24:41,200
faker for an email address for example

00:24:38,380 --> 00:24:43,920
and it will generate a random email

00:24:41,200 --> 00:24:47,610
address from the list of parts for you

00:24:43,920 --> 00:24:49,780
hypothesis on the other hand is both

00:24:47,610 --> 00:24:51,640
non-random in that sense so with faker

00:24:49,780 --> 00:24:53,680
tests if they fail they might pass again

00:24:51,640 --> 00:24:55,560
the next time and you never know why but

00:24:53,680 --> 00:24:57,730
hypothesis is also much better at

00:24:55,560 --> 00:24:59,950
exploring edge cases that no one thought

00:24:57,730 --> 00:25:02,380
of because if nobody's added it to

00:24:59,950 --> 00:25:04,690
fakers corpus of things to try it can

00:25:02,380 --> 00:25:06,400
never try that whereas hypothesis if

00:25:04,690 --> 00:25:09,970
it's describable could generate that

00:25:06,400 --> 00:25:11,830
input and faker inputs are not minimized

00:25:09,970 --> 00:25:17,200
where hypothesis does give you minimal

00:25:11,830 --> 00:25:21,520
counter examples there's one question

00:25:17,200 --> 00:25:23,910
over there wait for the microphone

00:25:21,520 --> 00:25:23,910
please

00:25:26,380 --> 00:25:31,640
what are their property based frameworks

00:25:29,710 --> 00:25:33,830
property based testing frameworks

00:25:31,640 --> 00:25:35,600
influenced its development and what are

00:25:33,830 --> 00:25:39,110
the significant differences between

00:25:35,600 --> 00:25:40,880
hypothesis and then so the most famous

00:25:39,110 --> 00:25:42,500
library for property based testing is

00:25:40,880 --> 00:25:45,760
quick check in Haskell which was the

00:25:42,500 --> 00:25:48,260
first one released around 1999

00:25:45,760 --> 00:25:50,960
hypothesis has taken inspiration from a

00:25:48,260 --> 00:25:52,910
number of other libraries in the way we

00:25:50,960 --> 00:25:54,380
designed the API and sometimes there's

00:25:52,910 --> 00:25:57,920
been things we imitated and at other

00:25:54,380 --> 00:26:00,710
times it's been things we've avoided the

00:25:57,920 --> 00:26:02,480
biggest architectural difference between

00:26:00,710 --> 00:26:05,090
hypothesis and any other fuzzing or

00:26:02,480 --> 00:26:09,410
shrinking tool than I know of is that a

00:26:05,090 --> 00:26:12,020
hypothesis input is generated from an

00:26:09,410 --> 00:26:13,220
underlying representation ask me about

00:26:12,020 --> 00:26:15,920
details later if you're really

00:26:13,220 --> 00:26:17,390
interested but when it shrinks it

00:26:15,920 --> 00:26:19,460
actually shrinks to the level of that

00:26:17,390 --> 00:26:21,140
underlying input which means whatever

00:26:19,460 --> 00:26:22,970
constraints you had on the inputs to

00:26:21,140 --> 00:26:26,060
your test function will always be

00:26:22,970 --> 00:26:29,930
respected so for example if you've

00:26:26,060 --> 00:26:31,730
generated even numbers every number that

00:26:29,930 --> 00:26:36,400
it tries to feed into your program will

00:26:31,730 --> 00:26:39,290
be even even will continue to be even

00:26:36,400 --> 00:26:41,510
while it is reducing that input to the

00:26:39,290 --> 00:26:46,250
minimal example for you other tools

00:26:41,510 --> 00:26:47,900
generally have test reduction at the

00:26:46,250 --> 00:26:50,770
level of values so they try to make less

00:26:47,900 --> 00:26:52,880
shorter or shrink numbers individually

00:26:50,770 --> 00:26:54,530
but then they have to have an extra

00:26:52,880 --> 00:27:02,330
layer of filtering which is relatively

00:26:54,530 --> 00:27:04,670
inefficient any more questions okay that

00:27:02,330 --> 00:27:08,590
looks like it Thank You Zack once again

00:27:04,670 --> 00:27:08,590
it's such a great talk

00:27:12,500 --> 00:27:18,200

YouTube URL: https://www.youtube.com/watch?v=U_KhEi2vRT8


