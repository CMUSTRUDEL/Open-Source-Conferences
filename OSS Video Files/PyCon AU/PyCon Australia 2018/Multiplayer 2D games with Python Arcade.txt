Title: Multiplayer 2D games with Python Arcade
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Caleb Hattingh

https://2018.pycon-au.org/talks/45332-multiplayer-2d-games-with-python-arcade/

The Python Arcade library makes it very easy to create 2D games--especially for beginners--and there are many examples provided with the package.  This talk will show how to make a multiplayer computer game using Python Arcade, both over a local network, and also on the internet.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,030 --> 00:00:03,990
good morning everyone it's that spot

00:00:01,860 --> 00:00:06,330
just before lunch isn't it and it's

00:00:03,990 --> 00:00:10,650
getting a little slow brain for me

00:00:06,330 --> 00:00:13,500
anyway usually so I'm excited to have a

00:00:10,650 --> 00:00:15,690
Caleb talking to us about something kind

00:00:13,500 --> 00:00:17,779
of a little more fun and exciting and

00:00:15,690 --> 00:00:20,160
light-hearted in terms of 2d gaming

00:00:17,779 --> 00:00:22,050
before we commence I just wanted to

00:00:20,160 --> 00:00:23,970
acknowledge the traditional custodians

00:00:22,050 --> 00:00:26,010
of the land in which we meet today the

00:00:23,970 --> 00:00:28,199
gadigal people of the eora nation and

00:00:26,010 --> 00:00:31,230
pay my respects to the elders past and

00:00:28,199 --> 00:00:33,030
present if you don't mind just me taking

00:00:31,230 --> 00:00:34,829
one minute I had the privilege of

00:00:33,030 --> 00:00:38,610
working in the NCAA and working with

00:00:34,829 --> 00:00:41,550
some young people using technology to

00:00:38,610 --> 00:00:43,020
build their own games for to as

00:00:41,550 --> 00:00:45,600
demonstration of their own culture and

00:00:43,020 --> 00:00:47,579
exploration of their own culture with

00:00:45,600 --> 00:00:50,100
the indigenous peoples here in Australia

00:00:47,579 --> 00:00:54,149
and it was absolutely wonderful to see

00:00:50,100 --> 00:00:56,340
that expression so it's for me this kind

00:00:54,149 --> 00:00:58,109
of topic even though we're looking at

00:00:56,340 --> 00:01:00,030
the technical aspects of it has a real

00:00:58,109 --> 00:01:02,670
life purpose

00:01:00,030 --> 00:01:04,260
the in meaning that is much greater so I

00:01:02,670 --> 00:01:06,090
just want to share that with you but

00:01:04,260 --> 00:01:09,060
without further ado I'll hand over to

00:01:06,090 --> 00:01:13,049
Caleb to talk to us about two 2d gaming

00:01:09,060 --> 00:01:13,799
using Python great thank you thank you

00:01:13,049 --> 00:01:15,330
everyone for coming

00:01:13,799 --> 00:01:17,430
are there any professional game

00:01:15,330 --> 00:01:22,170
developers in the room someone pays you

00:01:17,430 --> 00:01:22,590
to write games if so please leave I'm

00:01:22,170 --> 00:01:25,890
kidding

00:01:22,590 --> 00:01:27,240
so I'm not a professional developer I'm

00:01:25,890 --> 00:01:28,920
a software engineer I'm pretty much a

00:01:27,240 --> 00:01:31,409
generalist I jump from topic to topic

00:01:28,920 --> 00:01:32,610
every couple of years I tend to do a

00:01:31,409 --> 00:01:35,220
deep dive and then I'm going to

00:01:32,610 --> 00:01:38,490
something else I want to get into 2d

00:01:35,220 --> 00:01:39,840
gaming as a hobby and I thought

00:01:38,490 --> 00:01:41,130
submitting a tall proposal to do that

00:01:39,840 --> 00:01:42,390
would be a really great way to learn and

00:01:41,130 --> 00:01:44,130
indeed it was a great way to learn but

00:01:42,390 --> 00:01:47,579
also discovered it's actually quite hard

00:01:44,130 --> 00:01:49,530
it's quite a difficult domain I have way

00:01:47,579 --> 00:01:51,299
too many slides I think I have 49 slides

00:01:49,530 --> 00:01:53,130
and 30 minutes is probably not going to

00:01:51,299 --> 00:01:55,950
be long enough for that the cool stuff

00:01:53,130 --> 00:01:57,390
is all at the end right but I can't show

00:01:55,950 --> 00:01:59,250
you that until I build a platform with

00:01:57,390 --> 00:02:00,630
the stuff in the beginning so I'm going

00:01:59,250 --> 00:02:02,009
to move quickly through the stuff in the

00:02:00,630 --> 00:02:03,750
beginning but the slides will be

00:02:02,009 --> 00:02:04,979
viewable afterwards through the video

00:02:03,750 --> 00:02:07,560
and of course through my github link

00:02:04,979 --> 00:02:09,149
that I'm showing there so I hope you'll

00:02:07,560 --> 00:02:11,280
forgive me if I move a bit too quickly

00:02:09,149 --> 00:02:13,200
in certain places I've tried really

00:02:11,280 --> 00:02:14,280
really hard to make this as accessible

00:02:13,200 --> 00:02:16,800
as possible

00:02:14,280 --> 00:02:18,680
and if you don't understand anything at

00:02:16,800 --> 00:02:22,170
the end and that is my fault not yours

00:02:18,680 --> 00:02:23,640
so let's begin my goal was to show you

00:02:22,170 --> 00:02:24,810
how to build a simple multiplayer game

00:02:23,640 --> 00:02:26,280
and I thought that I'd be able to

00:02:24,810 --> 00:02:28,560
produce a finished thing at the end of

00:02:26,280 --> 00:02:31,170
30 minutes and I tried I really tried

00:02:28,560 --> 00:02:32,610
but that's just not possible what I can

00:02:31,170 --> 00:02:34,920
do the best I can do is to show you the

00:02:32,610 --> 00:02:36,930
building blocks the hard stuff the the

00:02:34,920 --> 00:02:39,390
bits and pieces that you need to get put

00:02:36,930 --> 00:02:41,370
into your game engine and then you will

00:02:39,390 --> 00:02:43,230
have to go the rest of the way or

00:02:41,370 --> 00:02:45,300
perhaps next year I'll try this submit a

00:02:43,230 --> 00:02:48,840
talk proposal to do to do this this next

00:02:45,300 --> 00:02:51,810
half about me I'm currently working at

00:02:48,840 --> 00:02:53,730
PCCW global and doing Network automation

00:02:51,810 --> 00:02:58,260
in the past I've done chemical reactor

00:02:53,730 --> 00:02:59,730
modeling hotel reservations software I

00:02:58,260 --> 00:03:01,340
wrote quite a bit of that for several

00:02:59,730 --> 00:03:03,330
years I did distillation column design

00:03:01,340 --> 00:03:05,700
so like I said lots of different things

00:03:03,330 --> 00:03:07,140
I've made a couple of videos and books

00:03:05,700 --> 00:03:09,720
for O'Reilly I did a video course on

00:03:07,140 --> 00:03:12,299
siphon all three people that watch that

00:03:09,720 --> 00:03:13,560
throw was really good so if you want to

00:03:12,299 --> 00:03:16,380
learn more about siphon you can do that

00:03:13,560 --> 00:03:19,620
I read books I have some books here I'll

00:03:16,380 --> 00:03:21,510
be giving some out during the course of

00:03:19,620 --> 00:03:23,700
the talk these are very difficult books

00:03:21,510 --> 00:03:25,799
to get I don't know of any other hard

00:03:23,700 --> 00:03:30,030
copies and they're only available on a

00:03:25,799 --> 00:03:32,640
Reilly subscription service so let's get

00:03:30,030 --> 00:03:36,359
to Python arcade probably most of you

00:03:32,640 --> 00:03:38,100
are aware of Pi game I've also doubled

00:03:36,359 --> 00:03:40,109
with PI game are up and on over the

00:03:38,100 --> 00:03:42,540
years nothing serious very amateurish

00:03:40,109 --> 00:03:44,310
but I discovered Python arcade recently

00:03:42,540 --> 00:03:46,739
and I really love the simplicity that

00:03:44,310 --> 00:03:49,140
this library brings to game development

00:03:46,739 --> 00:03:51,720
this is a screenshot from the Ramudu the

00:03:49,140 --> 00:03:53,970
Redux page for python arcade the author

00:03:51,720 --> 00:03:56,130
Paul Craven really tries hard to make it

00:03:53,970 --> 00:03:57,420
as accessible as possible he even has a

00:03:56,130 --> 00:03:59,670
section which you can see to the bottom

00:03:57,420 --> 00:04:04,200
right there on diversity diversity for

00:03:59,670 --> 00:04:05,340
the project so why Python arcade I don't

00:04:04,200 --> 00:04:06,569
really have time to go through all the

00:04:05,340 --> 00:04:08,430
bullet points but there are a couple of

00:04:06,569 --> 00:04:10,319
nice details that I really like Python 3

00:04:08,430 --> 00:04:12,569
is really great what I really like about

00:04:10,319 --> 00:04:14,880
Python arcade is the examples the

00:04:12,569 --> 00:04:17,639
examples are really excellent and there

00:04:14,880 --> 00:04:19,590
are many of them each example focuses on

00:04:17,639 --> 00:04:21,419
one particular kind of aspect of games

00:04:19,590 --> 00:04:24,210
programming so you can really do a deep

00:04:21,419 --> 00:04:26,430
dive into a specific kind of game there

00:04:24,210 --> 00:04:27,990
are RPG examples there are platformers

00:04:26,430 --> 00:04:29,340
there are gravity based example

00:04:27,990 --> 00:04:30,630
so if you want to incorporate one of

00:04:29,340 --> 00:04:32,040
these elements into a game that you're

00:04:30,630 --> 00:04:33,990
making you can pretty much just read

00:04:32,040 --> 00:04:35,040
from the title of the example and

00:04:33,990 --> 00:04:36,750
there'll be a short snippet of code

00:04:35,040 --> 00:04:38,930
maybe ten or twenty lines that'll show

00:04:36,750 --> 00:04:41,700
you how to do just that

00:04:38,930 --> 00:04:43,139
you can execute the games so once you

00:04:41,700 --> 00:04:45,060
put install pattern arcade into your

00:04:43,139 --> 00:04:47,280
purple arcade into your virtual

00:04:45,060 --> 00:04:48,810
environment if you know what the names

00:04:47,280 --> 00:04:49,980
of the examples are and you can read

00:04:48,810 --> 00:04:51,690
them off the previous slide that I gave

00:04:49,980 --> 00:04:55,110
you can you can run them so here are a

00:04:51,690 --> 00:04:57,600
couple of examples this is a bouncing

00:04:55,110 --> 00:04:58,860
ball example so inside the code for this

00:04:57,600 --> 00:05:01,620
you'll see how to incorporate gravity

00:04:58,860 --> 00:05:03,240
into your game and then you get more

00:05:01,620 --> 00:05:06,419
complex ones where you get like a sprite

00:05:03,240 --> 00:05:09,150
collection type algorithm the code for

00:05:06,419 --> 00:05:11,310
this is maybe 30 lines right so it's

00:05:09,150 --> 00:05:16,410
pretty accessible to get into and then

00:05:11,310 --> 00:05:17,880
the last one I have here is the the

00:05:16,410 --> 00:05:20,100
model that I'm going to be using for the

00:05:17,880 --> 00:05:21,450
rest of this talk I'll really not taking

00:05:20,100 --> 00:05:23,340
too much time to explain this but it's

00:05:21,450 --> 00:05:27,270
fun so I'm moving this around with the

00:05:23,340 --> 00:05:28,650
keyboard right so we're going to look at

00:05:27,270 --> 00:05:29,940
the building blocks for making a game

00:05:28,650 --> 00:05:31,500
where two players might move around with

00:05:29,940 --> 00:05:33,360
the keyboard on two separate screens and

00:05:31,500 --> 00:05:34,919
all of the communication goes to their

00:05:33,360 --> 00:05:41,220
server that's that's really the backdrop

00:05:34,919 --> 00:05:42,810
for for this talk so I'm not going to

00:05:41,220 --> 00:05:44,160
talk about all of this code I just

00:05:42,810 --> 00:05:46,919
wanted to point out that this is an

00:05:44,160 --> 00:05:50,100
entire example I can show you what the

00:05:46,919 --> 00:05:51,150
example does quickly okay so it's a

00:05:50,100 --> 00:05:53,039
yellow square and I'm moving it around

00:05:51,150 --> 00:05:55,140
with a keyboard right that's that's

00:05:53,039 --> 00:05:57,120
pretty much what it does but the code

00:05:55,140 --> 00:05:58,830
sample is complete for that and I want

00:05:57,120 --> 00:06:03,060
to draw your attention to the two

00:05:58,830 --> 00:06:04,440
methods update and undraw what happens

00:06:03,060 --> 00:06:07,770
is you create an instance of one of

00:06:04,440 --> 00:06:10,910
these my game objects and the Python

00:06:07,770 --> 00:06:13,770
arcade runtime calls in to your object

00:06:10,910 --> 00:06:17,820
with the update method and it provides

00:06:13,770 --> 00:06:19,229
you the Delta time since it last called

00:06:17,820 --> 00:06:22,039
the update object so this is what allows

00:06:19,229 --> 00:06:24,270
you to move things on the screen using

00:06:22,039 --> 00:06:25,500
using knowledge of the time elapsed so

00:06:24,270 --> 00:06:28,710
you can make things move with a certain

00:06:25,500 --> 00:06:30,180
speed the other one on draw is when it

00:06:28,710 --> 00:06:32,490
calls you to draw something on the

00:06:30,180 --> 00:06:34,710
screen and just keep that in mind for

00:06:32,490 --> 00:06:36,479
the rest of this talk is that changing

00:06:34,710 --> 00:06:38,490
the position of your of your game

00:06:36,479 --> 00:06:40,710
objects is separate to drawing them on

00:06:38,490 --> 00:06:41,460
the screen right those are not those are

00:06:40,710 --> 00:06:43,229
not coupled and that's

00:06:41,460 --> 00:06:44,280
very important because in the

00:06:43,229 --> 00:06:45,120
multiplayer system that we're going to

00:06:44,280 --> 00:06:47,789
be looking at we're going to do a

00:06:45,120 --> 00:06:49,110
client-server system where the server is

00:06:47,789 --> 00:06:51,389
going to calculate the position of the

00:06:49,110 --> 00:06:53,069
game objects but the drawing of those

00:06:51,389 --> 00:06:57,449
objects is going to happen in the client

00:06:53,069 --> 00:06:59,430
application okay so it's move along I've

00:06:57,449 --> 00:07:01,470
got some utilities here look at them

00:06:59,430 --> 00:07:03,630
after the talk it's a diversion from the

00:07:01,470 --> 00:07:06,660
from the core message but it's very

00:07:03,630 --> 00:07:08,490
handy the tip is a try as soon as

00:07:06,660 --> 00:07:10,919
possible to use a vector class don't

00:07:08,490 --> 00:07:14,490
work with X&Y manually in all of your

00:07:10,919 --> 00:07:15,750
events and event handlers it saves a

00:07:14,490 --> 00:07:17,220
huge amount of time to begin with

00:07:15,750 --> 00:07:18,960
Victor's early so you can look at the

00:07:17,220 --> 00:07:21,690
previous slide later when you watch this

00:07:18,960 --> 00:07:22,949
back for example there's a normalized

00:07:21,690 --> 00:07:26,250
function that you get with the victor

00:07:22,949 --> 00:07:27,810
class that comes out of pine monk and it

00:07:26,250 --> 00:07:30,539
makes it much easier to correct for

00:07:27,810 --> 00:07:33,000
diagonal movement here the Blue Square

00:07:30,539 --> 00:07:34,560
doesn't have the correction so if you

00:07:33,000 --> 00:07:38,009
calculate which keys are currently being

00:07:34,560 --> 00:07:39,900
pressed and you blindly add left and

00:07:38,009 --> 00:07:41,250
right together you get too much diagonal

00:07:39,900 --> 00:07:42,630
side movement this is a very common

00:07:41,250 --> 00:07:44,310
problem whenever you start on games

00:07:42,630 --> 00:07:45,780
programming to try to correct that is a

00:07:44,310 --> 00:07:47,820
pain but if you use a vector class you

00:07:45,780 --> 00:07:49,349
can just use handy methods like these

00:07:47,820 --> 00:07:52,949
the normalized function that our problem

00:07:49,349 --> 00:07:55,289
goes away but I digress I have a couple

00:07:52,949 --> 00:07:57,539
of copies of my book here and I thought

00:07:55,289 --> 00:07:59,909
it would be fun to try to identify

00:07:57,539 --> 00:08:02,639
certain games I have a screenshot from

00:07:59,909 --> 00:08:04,469
three games one for each and each uses a

00:08:02,639 --> 00:08:07,530
different network model behind the

00:08:04,469 --> 00:08:08,759
game's engine I'll start in that column

00:08:07,530 --> 00:08:11,430
and then I'll go to the middle column

00:08:08,759 --> 00:08:13,620
there the right column and I'll ask what

00:08:11,430 --> 00:08:15,090
games the screen shot off and the first

00:08:13,620 --> 00:08:17,250
person who guesses it right will get a

00:08:15,090 --> 00:08:21,120
book off the talk okay so we'll start on

00:08:17,250 --> 00:08:23,610
the left column over there go yes there

00:08:21,120 --> 00:08:27,419
we go you get a book now we'll do the

00:08:23,610 --> 00:08:32,159
middle column excellent you get to work

00:08:27,419 --> 00:08:36,419
see me off to its last column excellent

00:08:32,159 --> 00:08:37,950
you get a book well done so what's

00:08:36,419 --> 00:08:39,329
what's pretty interesting to me and when

00:08:37,950 --> 00:08:41,880
I got into this and started reading up

00:08:39,329 --> 00:08:44,190
about the the programming models behind

00:08:41,880 --> 00:08:45,570
how the network models work it's really

00:08:44,190 --> 00:08:47,610
fascinating that they're all completely

00:08:45,570 --> 00:08:49,170
different utterly different the first

00:08:47,610 --> 00:08:51,360
one for tonight uses a client-server

00:08:49,170 --> 00:08:53,400
model in this model the server

00:08:51,360 --> 00:08:55,230
calculates the entire game logic it

00:08:53,400 --> 00:08:57,900
determines everything

00:08:55,230 --> 00:09:00,090
the key presses that you enter in your

00:08:57,900 --> 00:09:01,770
in your game client gets sent to the

00:09:00,090 --> 00:09:03,840
server and the server calculates what

00:09:01,770 --> 00:09:05,490
that means and then it sends the game

00:09:03,840 --> 00:09:06,830
state back to the game clients and they

00:09:05,490 --> 00:09:10,140
draw them on the screen

00:09:06,830 --> 00:09:12,270
the luck step model is completely

00:09:10,140 --> 00:09:13,920
different to that game state is not

00:09:12,270 --> 00:09:16,860
shared between two soft-rock

00:09:13,920 --> 00:09:19,200
two Starcraft players client sessions

00:09:16,860 --> 00:09:22,080
the game state is entirely kept separate

00:09:19,200 --> 00:09:24,000
but a simulation is running in lockstep

00:09:22,080 --> 00:09:26,010
on each of the client machines all that

00:09:24,000 --> 00:09:28,740
they exchange is keyboard input but they

00:09:26,010 --> 00:09:31,620
never share the game state and the final

00:09:28,740 --> 00:09:34,020
one Awesomenauts uses a pure

00:09:31,620 --> 00:09:35,790
peer-to-peer model where your own

00:09:34,020 --> 00:09:38,460
player's actions are entirely determined

00:09:35,790 --> 00:09:38,970
on your own machine and then sent to all

00:09:38,460 --> 00:09:41,580
the other players

00:09:38,970 --> 00:09:43,860
Awesomenauts is quite fascinating and I

00:09:41,580 --> 00:09:47,550
have an article about that if you look

00:09:43,860 --> 00:09:48,900
at my slides afterwards BIOS van Dongen

00:09:47,550 --> 00:09:51,360
he goes into detail about what the

00:09:48,900 --> 00:09:53,250
ramifications of that are anyway we have

00:09:51,360 --> 00:09:54,570
to move along client server there's a

00:09:53,250 --> 00:09:57,510
server in the middle and we have client

00:09:54,570 --> 00:09:59,040
machines around people are playing games

00:09:57,510 --> 00:10:00,330
on the ones with the screens but the one

00:09:59,040 --> 00:10:02,400
in the middle which is calculating all

00:10:00,330 --> 00:10:05,660
the game logic there's no human player

00:10:02,400 --> 00:10:07,710
present we need to break this down into

00:10:05,660 --> 00:10:10,560
how we're going to communicate between

00:10:07,710 --> 00:10:12,690
these clients and the server right the

00:10:10,560 --> 00:10:15,150
first two items here concerned what gets

00:10:12,690 --> 00:10:18,450
sent we're going to capture player

00:10:15,150 --> 00:10:19,350
inputs literally keyboard state which

00:10:18,450 --> 00:10:21,630
keys are being pressed

00:10:19,350 --> 00:10:22,740
mouse mouse presses and so on those are

00:10:21,630 --> 00:10:24,840
going to get sent from the client

00:10:22,740 --> 00:10:26,820
machines across the network to the

00:10:24,840 --> 00:10:29,220
server and the second thing that we need

00:10:26,820 --> 00:10:30,600
to transmit is on the server after the

00:10:29,220 --> 00:10:32,040
game state has been updated we're going

00:10:30,600 --> 00:10:33,660
to send the game state back from the

00:10:32,040 --> 00:10:35,960
server to the clients so that the

00:10:33,660 --> 00:10:37,860
clients can draw that on the screen and

00:10:35,960 --> 00:10:42,410
third point we need to touch on these

00:10:37,860 --> 00:10:42,410
tcp versus UDP how am i doing for time

00:10:42,620 --> 00:10:52,590
to go eight minutes to go eight minutes

00:10:46,590 --> 00:10:54,960
elapsed okay okay so the first one I'm

00:10:52,590 --> 00:10:57,360
using a data class object here data

00:10:54,960 --> 00:10:59,100
classes is new in Python 3.7 you can get

00:10:57,360 --> 00:11:01,170
it in Python 3.6 if you put install

00:10:59,100 --> 00:11:03,900
daily classes it's pretty much just a

00:11:01,170 --> 00:11:06,900
way of making a very simple class with a

00:11:03,900 --> 00:11:08,529
couple of rich other tributes I'm not

00:11:06,900 --> 00:11:11,459
going to go into this here but

00:11:08,529 --> 00:11:13,930
all this really is it's a mapping of

00:11:11,459 --> 00:11:15,639
direction keys and whether they are true

00:11:13,930 --> 00:11:16,779
or false and this is what we're going to

00:11:15,639 --> 00:11:19,600
be sending from the client to the server

00:11:16,779 --> 00:11:21,189
the second one is what we need to send

00:11:19,600 --> 00:11:23,110
from the server back to the clients

00:11:21,189 --> 00:11:25,870
after the gamestate on this server has

00:11:23,110 --> 00:11:27,999
been updated same thing we're using data

00:11:25,870 --> 00:11:29,439
classes the one that we send is the game

00:11:27,999 --> 00:11:32,470
state the one at the bottom that I've

00:11:29,439 --> 00:11:34,839
highlighted there but internally it has

00:11:32,470 --> 00:11:35,889
a list of player States so all of the

00:11:34,839 --> 00:11:37,569
players are going to get all of the

00:11:35,889 --> 00:11:40,139
player States so that they can each draw

00:11:37,569 --> 00:11:44,379
and the other players on the screen and

00:11:40,139 --> 00:11:47,410
finally TCP versus UDP in games

00:11:44,379 --> 00:11:49,259
programming no one really uses TCP and

00:11:47,410 --> 00:11:51,399
and the reason why is quite interesting

00:11:49,259 --> 00:11:52,480
it's dangerous for me to get into now

00:11:51,399 --> 00:11:54,399
because it's going to cost me time but

00:11:52,480 --> 00:11:57,819
it's worth explaining TCP is too

00:11:54,399 --> 00:12:00,459
reliable you really want the lowest

00:11:57,819 --> 00:12:02,470
latency possible and it's okay to drop

00:12:00,459 --> 00:12:03,579
packets in certain situations it's easy

00:12:02,470 --> 00:12:05,410
for you to think about that in the

00:12:03,579 --> 00:12:07,059
context of what I just told you from the

00:12:05,410 --> 00:12:08,529
client we're going to be sending the

00:12:07,059 --> 00:12:10,569
current state of the keys that are

00:12:08,529 --> 00:12:11,980
currently pressed if we lose one of

00:12:10,569 --> 00:12:14,230
those packets and we're transmitting 30

00:12:11,980 --> 00:12:17,199
times a second does it really matter it

00:12:14,230 --> 00:12:19,569
doesn't right we're not sending a key

00:12:17,199 --> 00:12:21,339
pressed event that occurred we're

00:12:19,569 --> 00:12:23,379
sending the actual state of whether the

00:12:21,339 --> 00:12:25,209
keys are currently pressed or not so for

00:12:23,379 --> 00:12:28,540
a couple of seconds a key might be true

00:12:25,209 --> 00:12:30,399
and then the key pressed the key pressed

00:12:28,540 --> 00:12:31,629
state might be false and then it might

00:12:30,399 --> 00:12:32,920
be true for another couple of seconds

00:12:31,629 --> 00:12:36,009
and if we lose one of those doesn't

00:12:32,920 --> 00:12:38,290
really matter right so the cost of TCP

00:12:36,009 --> 00:12:40,629
reordering and retransmission of drop

00:12:38,290 --> 00:12:43,360
packets is a cost that we don't need to

00:12:40,629 --> 00:12:45,629
spend often in games programming so

00:12:43,360 --> 00:12:48,129
people always tend to use UDP

00:12:45,629 --> 00:12:50,620
unfortunately UDP is quite a lot of work

00:12:48,129 --> 00:12:52,509
because it's pretty complicated to set

00:12:50,620 --> 00:12:54,730
up it has some of its own corner cases

00:12:52,509 --> 00:12:57,160
that are pretty pretty different to TCP

00:12:54,730 --> 00:12:59,350
and you usually have to build some relax

00:12:57,160 --> 00:13:01,660
you have to build some reliability on

00:12:59,350 --> 00:13:03,959
top of UDP anyway because there are some

00:13:01,660 --> 00:13:06,550
things you do want retransmission for I

00:13:03,959 --> 00:13:07,779
don't have time to show UDP to you so

00:13:06,550 --> 00:13:10,120
instead we're going to stick with TCP

00:13:07,779 --> 00:13:13,029
just because it's much faster to to move

00:13:10,120 --> 00:13:15,490
and over and above that I'm also going

00:13:13,029 --> 00:13:17,069
to be using zero and cue sockets 0 and Q

00:13:15,490 --> 00:13:19,420
sockets

00:13:17,069 --> 00:13:20,510
they're a way of cheating with socket

00:13:19,420 --> 00:13:23,029
programming

00:13:20,510 --> 00:13:26,000
they're really really easy to use it's

00:13:23,029 --> 00:13:27,620
really difficult to get stuff wrong and

00:13:26,000 --> 00:13:28,490
they automatically handle reconnection

00:13:27,620 --> 00:13:31,040
and things like that

00:13:28,490 --> 00:13:33,350
they also handle distribution models so

00:13:31,040 --> 00:13:35,300
for sending from the clients to the

00:13:33,350 --> 00:13:38,209
single server we're going to use 0 mq

00:13:35,300 --> 00:13:39,860
push-and-pull socket pairs and then for

00:13:38,209 --> 00:13:41,120
updating each of the clients from the

00:13:39,860 --> 00:13:43,519
server we're going to use a pub sub

00:13:41,120 --> 00:13:46,070
model 0 and Q provides all this out of

00:13:43,519 --> 00:13:47,899
the box and here are two pretty complete

00:13:46,070 --> 00:13:51,079
examples of functions that you might

00:13:47,899 --> 00:13:53,089
have long-running / routines that you

00:13:51,079 --> 00:13:57,500
might start once on the client and one

00:13:53,089 --> 00:14:01,220
on the server that wraps all of the 0nq

00:13:57,500 --> 00:14:03,949
socket II stuff inside Q management the

00:14:01,220 --> 00:14:08,959
one the the zmq push for the client

00:14:03,949 --> 00:14:10,220
there's a Q object that is providing

00:14:08,959 --> 00:14:12,199
this is a long-running task and what

00:14:10,220 --> 00:14:16,459
what the call it does is it simply

00:14:12,199 --> 00:14:18,380
pushes data on to the queue and ilgaz

00:14:16,459 --> 00:14:19,940
Center is your in queue and likewise on

00:14:18,380 --> 00:14:22,220
the server you provided a queue socket

00:14:19,940 --> 00:14:23,510
and then your client function would

00:14:22,220 --> 00:14:25,310
listen to the queue and wait for things

00:14:23,510 --> 00:14:26,899
to come off this this is pretty much

00:14:25,310 --> 00:14:30,920
complete there isn't really much more to

00:14:26,899 --> 00:14:33,260
you doing during p sockets than this ok

00:14:30,920 --> 00:14:35,569
so this is the most important slide of

00:14:33,260 --> 00:14:37,130
the entire talk because if you can

00:14:35,569 --> 00:14:43,519
conceptualize this you could probably

00:14:37,130 --> 00:14:45,139
make it most of the way on your own so

00:14:43,519 --> 00:14:47,660
here's the thing to remember here's the

00:14:45,139 --> 00:14:49,970
thing to really understand the three

00:14:47,660 --> 00:14:52,970
tasks that I've listed here tasks a B

00:14:49,970 --> 00:14:55,220
and C on the one hand the client has to

00:14:52,970 --> 00:14:57,860
continually send to the server the state

00:14:55,220 --> 00:15:01,310
of the current input which keys are

00:14:57,860 --> 00:15:03,649
pressed write task B is that the client

00:15:01,310 --> 00:15:05,389
has to continually receive the game

00:15:03,649 --> 00:15:07,699
state from the server so that the game

00:15:05,389 --> 00:15:09,769
state can be drawn on the screen those

00:15:07,699 --> 00:15:11,720
two tasks can be run independently

00:15:09,769 --> 00:15:13,490
completely independently that don't

00:15:11,720 --> 00:15:13,790
really have anything to do with each

00:15:13,490 --> 00:15:16,760
other

00:15:13,790 --> 00:15:18,050
and finally the task sees draw the game

00:15:16,760 --> 00:15:19,990
state on the screen and the reason why I

00:15:18,050 --> 00:15:22,250
separate that from the other two is

00:15:19,990 --> 00:15:23,959
because of how the event loops are

00:15:22,250 --> 00:15:26,810
structured between the game engine and

00:15:23,959 --> 00:15:29,930
the i/o event loop that will be using

00:15:26,810 --> 00:15:31,519
async i/o form and that also can run

00:15:29,930 --> 00:15:34,010
independently just like I said right at

00:15:31,519 --> 00:15:36,620
the start that the update method

00:15:34,010 --> 00:15:39,320
the ondraw method are separated from

00:15:36,620 --> 00:15:42,980
each other on the server we have the

00:15:39,320 --> 00:15:44,540
same separation of concerns the first

00:15:42,980 --> 00:15:47,420
task of the server is to accept client

00:15:44,540 --> 00:15:49,130
connections and because we're using 0nq

00:15:47,420 --> 00:15:50,870
it's very really very little to say

00:15:49,130 --> 00:15:52,970
because that's all wrapped internally so

00:15:50,870 --> 00:15:56,110
we won't be talking too much about task

00:15:52,970 --> 00:15:59,450
a on the server side but tasks B and C

00:15:56,110 --> 00:16:01,190
task beyond the server is a Longworth

00:15:59,450 --> 00:16:04,670
task that has to receive player input

00:16:01,190 --> 00:16:07,130
and update the game state and task C

00:16:04,670 --> 00:16:10,280
then is to send that game state back to

00:16:07,130 --> 00:16:13,310
clients and the game task B and task C

00:16:10,280 --> 00:16:15,170
can run independently they we don't need

00:16:13,310 --> 00:16:16,970
to send the game state out only after

00:16:15,170 --> 00:16:21,670
it's been updated we can pretty much run

00:16:16,970 --> 00:16:21,670
them on a stream each each independently

00:16:22,900 --> 00:16:26,210
so let's begin with the server

00:16:24,680 --> 00:16:27,860
ironically you might think the server is

00:16:26,210 --> 00:16:29,890
more complicated it's actually easier

00:16:27,860 --> 00:16:32,990
and we'll get to why that is in a minute

00:16:29,890 --> 00:16:35,120
this is a main function I'm not going to

00:16:32,990 --> 00:16:37,280
go through every single line but I've

00:16:35,120 --> 00:16:38,810
just highlighted what I've said in the

00:16:37,280 --> 00:16:40,850
previous slide which is we have our task

00:16:38,810 --> 00:16:44,270
a accepting client connections

00:16:40,850 --> 00:16:46,580
completely handled by the socket library

00:16:44,270 --> 00:16:49,480
for us and then we have task B and task

00:16:46,580 --> 00:16:54,470
C which are literally created tasks

00:16:49,480 --> 00:16:57,830
using async IOT's create task function

00:16:54,470 --> 00:16:59,510
and then at the bottom we wait on all of

00:16:57,830 --> 00:17:00,950
those tasks for them to finish which

00:16:59,510 --> 00:17:05,420
hopefully is never because our game is

00:17:00,950 --> 00:17:07,520
so fun no one ever exits and then the

00:17:05,420 --> 00:17:09,200
second half of the server code write

00:17:07,520 --> 00:17:11,270
this this completes the picture pretty

00:17:09,200 --> 00:17:14,960
much I've got the implementations for

00:17:11,270 --> 00:17:16,130
those two tasks the code reads reads in

00:17:14,960 --> 00:17:17,630
a pretty straightforward way I don't

00:17:16,130 --> 00:17:20,570
think there's anything really subtle

00:17:17,630 --> 00:17:22,130
here so I'm going to skip it and move on

00:17:20,570 --> 00:17:23,960
if you if you can understand what I've

00:17:22,130 --> 00:17:25,340
said so far at a high level I think

00:17:23,960 --> 00:17:29,720
you'll be okay to read the code so I'm

00:17:25,340 --> 00:17:31,210
going to keep going the client code is a

00:17:29,720 --> 00:17:33,890
lot more complicated and this is why

00:17:31,210 --> 00:17:36,140
we're using async IO which has an event

00:17:33,890 --> 00:17:38,300
loop the event loop wants to control the

00:17:36,140 --> 00:17:40,910
main thread so it'll handle all of the

00:17:38,300 --> 00:17:42,530
socket connections and interleave all of

00:17:40,910 --> 00:17:44,720
your co-routines and provide time to

00:17:42,530 --> 00:17:46,640
them for computation unfortunately the

00:17:44,720 --> 00:17:47,480
game engine also has a loop it has its

00:17:46,640 --> 00:17:48,770
own game loop

00:17:47,480 --> 00:17:50,330
and most of the game engines work like

00:17:48,770 --> 00:17:52,400
this PI game works like this and Python

00:17:50,330 --> 00:17:54,320
arcade works like this and there's no

00:17:52,400 --> 00:17:57,830
real good way currently to share the

00:17:54,320 --> 00:17:59,720
game live between the two so I struggled

00:17:57,830 --> 00:18:01,700
hard with this what is the right thing

00:17:59,720 --> 00:18:03,380
for me to explain to you given that some

00:18:01,700 --> 00:18:05,120
of you may be beginners some of you may

00:18:03,380 --> 00:18:07,880
teach beginners and what are you going

00:18:05,120 --> 00:18:11,330
to explain to them I think my opinion

00:18:07,880 --> 00:18:12,799
that right now until Python arcade which

00:18:11,330 --> 00:18:15,110
is really piglet under the hood

00:18:12,799 --> 00:18:17,570
until piglet develops support for async

00:18:15,110 --> 00:18:19,580
IO probably the least effort solution is

00:18:17,570 --> 00:18:23,230
to run the async I'll loop in its own

00:18:19,580 --> 00:18:26,990
thread and let the game where library

00:18:23,230 --> 00:18:29,929
use the main thread so that looks like

00:18:26,990 --> 00:18:31,850
this I've just shown the main function

00:18:29,929 --> 00:18:33,410
in our client code this is analogous to

00:18:31,850 --> 00:18:35,120
them to the main function that we had on

00:18:33,410 --> 00:18:38,929
the server code we create the window

00:18:35,120 --> 00:18:40,490
which is the PI arcade thing and then

00:18:38,929 --> 00:18:42,559
the unusual but here is we're creating a

00:18:40,490 --> 00:18:44,179
separate thread and the thread worker

00:18:42,559 --> 00:18:46,730
there at the top is how we're creating

00:18:44,179 --> 00:18:48,320
an async IO event loop that is going to

00:18:46,730 --> 00:18:52,490
run in not the main thread it's gonna

00:18:48,320 --> 00:18:56,590
run in the side thread is everyone with

00:18:52,490 --> 00:18:59,929
me still but for you very good very good

00:18:56,590 --> 00:19:01,780
ok so this this is the i/o thread that

00:18:59,929 --> 00:19:04,429
is running separately to the main thread

00:19:01,780 --> 00:19:06,919
it looks very similar to the to the

00:19:04,429 --> 00:19:09,679
server code that I showed before we

00:19:06,919 --> 00:19:11,270
create our 2 0 mq sockets this time on

00:19:09,679 --> 00:19:12,830
the client we have a push socket because

00:19:11,270 --> 00:19:14,510
we're going to be pushing the keyboard

00:19:12,830 --> 00:19:16,429
state to the server and we'll also have

00:19:14,510 --> 00:19:17,750
a sub socket which is going to be which

00:19:16,429 --> 00:19:19,760
is subscribing and then going to be

00:19:17,750 --> 00:19:24,500
receiving the game state the updated

00:19:19,760 --> 00:19:25,910
game state from the server yeah you can

00:19:24,500 --> 00:19:27,679
see there at the bottom in receive game

00:19:25,910 --> 00:19:31,220
state the players position is being

00:19:27,679 --> 00:19:34,190
updated after receiving a message of the

00:19:31,220 --> 00:19:36,049
socket and this is the last and final

00:19:34,190 --> 00:19:39,440
piece of the client code so we're almost

00:19:36,049 --> 00:19:42,440
there what I want to really emphasize

00:19:39,440 --> 00:19:46,190
here is if you look at the update method

00:19:42,440 --> 00:19:49,520
now the update and on draw methods the

00:19:46,190 --> 00:19:50,750
ondraw method is unchanged towards the

00:19:49,520 --> 00:19:53,059
bottom third of the screen but the

00:19:50,750 --> 00:19:55,640
update method is empty it's completely

00:19:53,059 --> 00:19:57,530
empty why the reason is because the

00:19:55,640 --> 00:19:59,990
updates are being done on the server and

00:19:57,530 --> 00:20:01,370
in our other thread in our IR thread

00:19:59,990 --> 00:20:02,780
we're modifying the client

00:20:01,370 --> 00:20:05,870
decision there when we receive the

00:20:02,780 --> 00:20:07,520
updates from the from the server I hope

00:20:05,870 --> 00:20:09,830
that's clear if you can understand that

00:20:07,520 --> 00:20:12,020
you can probably reproduce all of this

00:20:09,830 --> 00:20:13,970
it took me a while to get to this point

00:20:12,020 --> 00:20:15,530
where I conceptually understood that

00:20:13,970 --> 00:20:18,140
those two things have to be separated in

00:20:15,530 --> 00:20:21,640
this way and from here on it's smooth

00:20:18,140 --> 00:20:23,720
sailing right so I can show a quick demo

00:20:21,640 --> 00:20:31,040
the server has to be a separate

00:20:23,720 --> 00:20:34,820
application which is a beautiful TK into

00:20:31,040 --> 00:20:37,970
window there and here's my client

00:20:34,820 --> 00:20:40,550
application so there we go what's

00:20:37,970 --> 00:20:44,630
happening here is my keyboard input is

00:20:40,550 --> 00:20:47,000
being sent to the other process which is

00:20:44,630 --> 00:20:48,770
calculating my updated position sending

00:20:47,000 --> 00:20:51,170
that position back to this application

00:20:48,770 --> 00:20:57,500
my game library and then it's getting

00:20:51,170 --> 00:21:00,830
drawn on screen yay how does it look but

00:20:57,500 --> 00:21:03,410
laggy right why is it laggy it's laggy

00:21:00,830 --> 00:21:07,160
because my server is sending me updates

00:21:03,410 --> 00:21:10,460
ten times a second right but we want to

00:21:07,160 --> 00:21:12,760
draw at 60 frames per second so we have

00:21:10,460 --> 00:21:16,690
a problem it's how much time do I have

00:21:12,760 --> 00:21:20,000
10 minutes left okay

00:21:16,690 --> 00:21:21,559
it should be enough this is where the

00:21:20,000 --> 00:21:24,559
fun stuff begins this is what I was

00:21:21,559 --> 00:21:28,400
referring to in the beginning so end but

00:21:24,559 --> 00:21:30,500
not the end it's pretty laggy right this

00:21:28,400 --> 00:21:32,990
is what we need to do when we draw the

00:21:30,500 --> 00:21:34,790
movement on the screen we have to make

00:21:32,990 --> 00:21:36,740
up stuff because we're only getting

00:21:34,790 --> 00:21:39,080
updates from the servant ten times a

00:21:36,740 --> 00:21:41,270
second you can make the previous demo

00:21:39,080 --> 00:21:44,360
smoother by receiving updates from the

00:21:41,270 --> 00:21:47,330
server faster twenty updates a second 30

00:21:44,360 --> 00:21:48,650
updates a second 60 updates a second but

00:21:47,330 --> 00:21:50,510
if you have a hundred players in your

00:21:48,650 --> 00:21:52,730
game and you're updating at sixty times

00:21:50,510 --> 00:21:54,650
a second all of the clients you very

00:21:52,730 --> 00:21:56,450
quickly run out of bandwidth so the

00:21:54,650 --> 00:21:58,790
solution is not to send updates from the

00:21:56,450 --> 00:22:00,320
server faster that that that is a path

00:21:58,790 --> 00:22:03,170
that goes no way what you have to do is

00:22:00,320 --> 00:22:06,130
you have to make up stuff directly there

00:22:03,170 --> 00:22:09,020
are two parts to this the first part is

00:22:06,130 --> 00:22:10,970
you need to predict in your client where

00:22:09,020 --> 00:22:13,550
you think the next update from the

00:22:10,970 --> 00:22:14,900
server is going to be coming in terms of

00:22:13,550 --> 00:22:16,610
position on the screen

00:22:14,900 --> 00:22:19,070
and at what time that's the first part

00:22:16,610 --> 00:22:21,470
and the second part is you have to

00:22:19,070 --> 00:22:24,440
interpolate and draw the animation of

00:22:21,470 --> 00:22:26,810
your game object from where it is now to

00:22:24,440 --> 00:22:29,390
where you think it is going to be then

00:22:26,810 --> 00:22:33,890
when the next update arrives in the

00:22:29,390 --> 00:22:35,300
future so I've got a couple equations

00:22:33,890 --> 00:22:38,450
here but the math is pretty simple

00:22:35,300 --> 00:22:40,430
really what you do is you say I have my

00:22:38,450 --> 00:22:42,230
current update and I very cleverly

00:22:40,430 --> 00:22:43,970
stored the previous update so I know

00:22:42,230 --> 00:22:45,710
what the change in position is and I

00:22:43,970 --> 00:22:47,570
know what the change in time is so

00:22:45,710 --> 00:22:48,680
therefore I can predict given that the

00:22:47,570 --> 00:22:50,360
velocities probably gonna be the same

00:22:48,680 --> 00:22:51,860
what the position is going to be like in

00:22:50,360 --> 00:22:53,840
the freeze in the future so I'm gonna

00:22:51,860 --> 00:22:55,670
step through that quickly so you get

00:22:53,840 --> 00:23:00,050
some explicit formulas for the predicted

00:22:55,670 --> 00:23:01,370
future X Y and X 2 so that's our plan

00:23:00,050 --> 00:23:03,680
we're going to store the last two server

00:23:01,370 --> 00:23:05,320
updates and we'll use a beak for that a

00:23:03,680 --> 00:23:07,280
double-ended queue so we can keep

00:23:05,320 --> 00:23:08,780
appending values to it and they'll keep

00:23:07,280 --> 00:23:11,510
getting popped off but will retain the

00:23:08,780 --> 00:23:13,370
last two and then we will calculate the

00:23:11,510 --> 00:23:15,290
future expected position based on the

00:23:13,370 --> 00:23:17,920
last two updates and then we will draw

00:23:15,290 --> 00:23:21,170
an interpolated position between the two

00:23:17,920 --> 00:23:24,110
so this is one of the long-lived

00:23:21,170 --> 00:23:25,550
proteins inside my client code where I'm

00:23:24,110 --> 00:23:27,950
receiving the gamestate from the server

00:23:25,550 --> 00:23:31,130
and the changes that I've made here is a

00:23:27,950 --> 00:23:35,150
couple of subtle things I append to my

00:23:31,130 --> 00:23:38,870
to two length long deke the new update I

00:23:35,150 --> 00:23:41,630
also reset a magical new time variable

00:23:38,870 --> 00:23:43,730
to zero and I save the snapshot of where

00:23:41,630 --> 00:23:47,330
my current player sprite is right now

00:23:43,730 --> 00:23:49,580
in the client and then in my update

00:23:47,330 --> 00:23:51,680
method which is now no longer empty and

00:23:49,580 --> 00:23:53,990
no longer says pass right that's what I

00:23:51,680 --> 00:23:56,000
did before now in my update method I

00:23:53,990 --> 00:23:57,950
have to draw I have to draw this

00:23:56,000 --> 00:23:59,600
extrapolated value between where my

00:23:57,950 --> 00:24:01,100
current sprite is and where I am

00:23:59,600 --> 00:24:03,560
expecting that it's going to be in the

00:24:01,100 --> 00:24:04,760
future and that's pretty much it if you

00:24:03,560 --> 00:24:06,620
go back to this code I'm sure you'll be

00:24:04,760 --> 00:24:10,940
able to figure it out I want to show you

00:24:06,620 --> 00:24:13,520
the demo so here I've changed the update

00:24:10,940 --> 00:24:15,200
speed from the server right down to two

00:24:13,520 --> 00:24:19,070
times a second it's really really slow

00:24:15,200 --> 00:24:21,200
right but it's easy to see I think I

00:24:19,070 --> 00:24:24,380
still may have the other one open so I'm

00:24:21,200 --> 00:24:27,800
just going to start this again it's very

00:24:24,380 --> 00:24:30,200
easy to see the prediction working right

00:24:27,800 --> 00:24:31,340
the black square is the value that I'm

00:24:30,200 --> 00:24:33,170
getting from the server which I'm

00:24:31,340 --> 00:24:35,390
drawing and the yellow square is my

00:24:33,170 --> 00:24:36,770
invented value so this is what the

00:24:35,390 --> 00:24:43,130
players going to see I won't show the

00:24:36,770 --> 00:24:46,280
black one in my real game right so you

00:24:43,130 --> 00:24:49,910
can see how the yellow square is leading

00:24:46,280 --> 00:24:51,050
the black square right and we're not

00:24:49,910 --> 00:24:52,370
moving in straight lines nice

00:24:51,050 --> 00:24:55,520
predictable straight lines

00:24:52,370 --> 00:24:57,230
I'm guessing correctly the code is is

00:24:55,520 --> 00:24:58,490
correctly predicting where the next

00:24:57,230 --> 00:25:00,740
update is going to come and when it's

00:24:58,490 --> 00:25:03,170
going to come because the black square

00:25:00,740 --> 00:25:08,450
appears perfectly in the yellow square

00:25:03,170 --> 00:25:09,860
where I thought it was going to be it

00:25:08,450 --> 00:25:12,020
looks much better than that

00:25:09,860 --> 00:25:14,809
if you increase the speed of the server

00:25:12,020 --> 00:25:23,990
updates so here I go back to ten times a

00:25:14,809 --> 00:25:25,670
second so I don't know how clear it is

00:25:23,990 --> 00:25:27,470
on the big screen but you'll see that

00:25:25,670 --> 00:25:28,850
the yellow one is pretty smooth and the

00:25:27,470 --> 00:25:32,030
black one is the one that's jittery

00:25:28,850 --> 00:25:33,620
around so the yellow one really is

00:25:32,030 --> 00:25:34,880
drawing at 60 frames per second and the

00:25:33,620 --> 00:25:42,600
black one is slight ten frames per

00:25:34,880 --> 00:25:45,770
second and that is the end of my talk

00:25:42,600 --> 00:25:45,770
[Music]

00:25:48,230 --> 00:25:52,289
Thank You Caleb we actually do have a

00:25:50,519 --> 00:25:55,019
little time for questions you wanna take

00:25:52,289 --> 00:25:57,450
one or two or oh we leave more than

00:25:55,019 --> 00:26:02,700
happy yeah so people who got their books

00:25:57,450 --> 00:26:04,200
come get your books yes yeah someone's

00:26:02,700 --> 00:26:09,630
in the middle there so I might take that

00:26:04,200 --> 00:26:16,620
one yeah go yep better bring the mic to

00:26:09,630 --> 00:26:19,320
you hang on one sec so would you

00:26:16,620 --> 00:26:24,240
recommend Python arcade as a framework

00:26:19,320 --> 00:26:27,360
to use for teaching beginners to

00:26:24,240 --> 00:26:34,529
programming as absolutely yes absolutely

00:26:27,360 --> 00:26:37,309
100% yeah yep sorry where was that one

00:26:34,529 --> 00:26:37,309
up the back yep

00:26:41,220 --> 00:26:46,750
we teach quite a number of novice

00:26:43,720 --> 00:26:49,450
computers computer learners how to do

00:26:46,750 --> 00:26:52,720
games but the good thing about my game

00:26:49,450 --> 00:26:54,970
is that although you want to guide them

00:26:52,720 --> 00:26:56,800
towards classes as they get more

00:26:54,970 --> 00:26:59,020
experienced you can start with just an

00:26:56,800 --> 00:27:01,480
event loop and deal with sprites and not

00:26:59,020 --> 00:27:03,400
have to worry about classes can you

00:27:01,480 --> 00:27:07,290
still do that in arcade or do we have to

00:27:03,400 --> 00:27:12,370
jump in with our Opie straightaway I

00:27:07,290 --> 00:27:15,850
don't know I think all over the examples

00:27:12,370 --> 00:27:23,220
you can there we go you can yes thank

00:27:15,850 --> 00:27:25,570
you yep here's a question it's Beckley

00:27:23,220 --> 00:27:28,900
so I actually I have it a couple more

00:27:25,570 --> 00:27:31,450
books if anyone else wants I want to

00:27:28,900 --> 00:27:34,300
give them all away so if you hang around

00:27:31,450 --> 00:27:36,760
after questions are done have you tried

00:27:34,300 --> 00:27:39,970
using physical models and Kalman filters

00:27:36,760 --> 00:27:44,700
to predict movement of the player in the

00:27:39,970 --> 00:27:48,190
client doing this was hard enough so no

00:27:44,700 --> 00:27:50,470
yeah it's worth on that point no III

00:27:48,190 --> 00:27:51,910
haven't done what you've suggested but

00:27:50,470 --> 00:27:53,200
most people don't do linear

00:27:51,910 --> 00:27:56,110
interpolation that's kind of interesting

00:27:53,200 --> 00:27:59,470
interesting they use second order

00:27:56,110 --> 00:28:01,870
interpolation models to handle curvature

00:27:59,470 --> 00:28:03,400
so if a sprite is moving in a curve

00:28:01,870 --> 00:28:07,690
linear interpolation does really badly

00:28:03,400 --> 00:28:08,590
then the error is quite visible and

00:28:07,690 --> 00:28:10,720
that's something that I would like to

00:28:08,590 --> 00:28:14,940
try as well but learning linear

00:28:10,720 --> 00:28:14,940
interpolation was easy for this talk I

00:28:15,870 --> 00:28:20,860
actually had one question when you threw

00:28:19,510 --> 00:28:23,020
up that equation you said oh this is

00:28:20,860 --> 00:28:24,520
fairly simple math and for somebody with

00:28:23,020 --> 00:28:26,800
my brain I'm an experienced programmer

00:28:24,520 --> 00:28:29,230
but terrible at math right um did you

00:28:26,800 --> 00:28:31,360
find any good resources to bridge that

00:28:29,230 --> 00:28:33,220
gap I suppose between you know okay I've

00:28:31,360 --> 00:28:35,020
got this I need to do some interpolation

00:28:33,220 --> 00:28:38,650
what should I use and and how do i

00:28:35,020 --> 00:28:40,300
implement that so I'm gonna go back to I

00:28:38,650 --> 00:28:42,160
do have these links are really good the

00:28:40,300 --> 00:28:47,710
ones that I had in this slide I wish I

00:28:42,160 --> 00:28:49,270
could have is it that one yeah these

00:28:47,710 --> 00:28:51,400
references are already quite good

00:28:49,270 --> 00:28:52,640
they're worth reading they're not really

00:28:51,400 --> 00:28:55,010
beginner material

00:28:52,640 --> 00:28:56,540
but they do go into some of the math and

00:28:55,010 --> 00:28:59,060
they especially talk about how

00:28:56,540 --> 00:29:01,670
programmers cheat to improve the user

00:28:59,060 --> 00:29:05,150
experience that's that is really

00:29:01,670 --> 00:29:06,830
interesting to me there is doing the

00:29:05,150 --> 00:29:08,300
calculations faithfully according to

00:29:06,830 --> 00:29:11,210
what math requires and then there is the

00:29:08,300 --> 00:29:12,560
user experience and they always do

00:29:11,210 --> 00:29:14,960
whatever they need to do for the user

00:29:12,560 --> 00:29:19,250
experience never there never under the

00:29:14,960 --> 00:29:27,620
physics of the situation we've got one

00:29:19,250 --> 00:29:30,140
more review hi what's interesting if you

00:29:27,620 --> 00:29:32,090
took that gravity example that you

00:29:30,140 --> 00:29:35,690
showed us first and you said that the

00:29:32,090 --> 00:29:37,610
game was instead of being looking down

00:29:35,690 --> 00:29:39,590
on the game you're looking sideways at

00:29:37,610 --> 00:29:44,090
it then wouldn't you be able interpolate

00:29:39,590 --> 00:29:47,600
using that gravity function so supposing

00:29:44,090 --> 00:29:50,270
that the sprite needs to be moved in

00:29:47,600 --> 00:29:53,330
that curvature that would be even better

00:29:50,270 --> 00:29:54,860
so you'd be using a real model to do

00:29:53,330 --> 00:29:57,320
your interpolation instead of just

00:29:54,860 --> 00:29:59,180
blindly tracking movement yeah I think

00:29:57,320 --> 00:30:00,500
that's that's a great suggestion if you

00:29:59,180 --> 00:30:01,760
have more knowledge about how your

00:30:00,500 --> 00:30:03,740
objects are going to be moving in the

00:30:01,760 --> 00:30:05,240
world then you can improve on the on the

00:30:03,740 --> 00:30:07,430
interpolation model it does that answer

00:30:05,240 --> 00:30:13,850
your question yeah I think that's really

00:30:07,430 --> 00:30:15,590
good good idea this would be a last

00:30:13,850 --> 00:30:19,970
question I would suggest we've got about

00:30:15,590 --> 00:30:23,270
a minute laughter there's Arcade have

00:30:19,970 --> 00:30:27,080
much support might provide much help for

00:30:23,270 --> 00:30:29,150
collision detection and also how do you

00:30:27,080 --> 00:30:31,520
go about teaching the basics of

00:30:29,150 --> 00:30:33,230
collision detection so it does have

00:30:31,520 --> 00:30:35,360
support for collision detection and it

00:30:33,230 --> 00:30:37,610
has support for integrating PI monk for

00:30:35,360 --> 00:30:39,560
a real physics engine that can also do

00:30:37,610 --> 00:30:42,410
collision detection and and those work

00:30:39,560 --> 00:30:44,750
fairly well but if you spoke to someone

00:30:42,410 --> 00:30:46,760
with more experience in arcade than I

00:30:44,750 --> 00:30:48,890
have they may have a different view but

00:30:46,760 --> 00:30:51,530
my impression as a as a newcomer to

00:30:48,890 --> 00:30:53,000
arcade is that you can do two collision

00:30:51,530 --> 00:30:56,630
detection they stay some support for it

00:30:53,000 --> 00:30:58,340
in the game and there are examples that

00:30:56,630 --> 00:31:00,470
are really nice for example if you have

00:30:58,340 --> 00:31:02,540
a large world that has two that you have

00:31:00,470 --> 00:31:04,190
to scroll through and your window has to

00:31:02,540 --> 00:31:06,500
move within the confines of the large

00:31:04,190 --> 00:31:09,800
world that's really easy to do in

00:31:06,500 --> 00:31:12,800
Python arcade it's I can well imagine

00:31:09,800 --> 00:31:14,510
that school kids would have a lot of fun

00:31:12,800 --> 00:31:16,640
making a huge world of things to collect

00:31:14,510 --> 00:31:19,070
and being able to just walk their sprite

00:31:16,640 --> 00:31:22,490
all over the place that's that kind of

00:31:19,070 --> 00:31:26,650
thing is really easy to do okay thank

00:31:22,490 --> 00:31:26,650
you for join me in thinking Colette okay

00:31:28,810 --> 00:31:32,330
and there's a small token of our

00:31:31,640 --> 00:31:34,910
appreciation

00:31:32,330 --> 00:31:39,070
you've got the Mike on Mike say thank

00:31:34,910 --> 00:31:39,070

YouTube URL: https://www.youtube.com/watch?v=2SMkk63k6Ik


