Title: Pact in Python
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Sylvia Yap

https://2018.pycon-au.org/talks/44811-pact-in-python/

Are you completely over those fragile and complicated integration test? There is another way!
Pact is a contract testing tool used to ensure services can communicate with each other. May be used between an API server and web frontend but really shines in an environment with many services.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:07,500
everyone welcome to the afternoon

00:00:03,300 --> 00:00:11,040
session here I've got a few talks coming

00:00:07,500 --> 00:00:13,740
up our first talk is by Silvia yep she's

00:00:11,040 --> 00:00:17,010
fellow rich tech Ian I'm from Rhys tech

00:00:13,740 --> 00:00:20,160
as well and she's going to be telling us

00:00:17,010 --> 00:00:22,890
about pact in Python now this is

00:00:20,160 --> 00:00:38,040
Sylvia's first presentation so give her

00:00:22,890 --> 00:00:41,430
a warm welcome please hi everyone my

00:00:38,040 --> 00:00:45,140
name is Silvia welcome to my talk today

00:00:41,430 --> 00:00:45,140
I'm going to talk about what pekus

00:00:45,320 --> 00:00:51,090
integration testing have you heard of it

00:00:48,000 --> 00:00:56,640
I had enough of it and perhaps worrying

00:00:51,090 --> 00:00:59,190
about how fragile it is this is just a

00:00:56,640 --> 00:01:01,020
very simple Network because the

00:00:59,190 --> 00:01:03,750
complexity is not even near to what

00:01:01,020 --> 00:01:05,460
we're normally dealing with and this is

00:01:03,750 --> 00:01:07,650
a session of our production that we're

00:01:05,460 --> 00:01:11,880
proud that diagram it looks pretty

00:01:07,650 --> 00:01:14,970
full-on sometimes we need to rely on our

00:01:11,880 --> 00:01:16,950
dependency to test a single service and

00:01:14,970 --> 00:01:19,350
when there's something not right with

00:01:16,950 --> 00:01:22,770
the service it could be our code that's

00:01:19,350 --> 00:01:25,409
buggy or sometimes it could be the

00:01:22,770 --> 00:01:27,540
network issue or even because someone

00:01:25,409 --> 00:01:30,810
changed the data in the database there's

00:01:27,540 --> 00:01:32,159
nothing to do with our code and we could

00:01:30,810 --> 00:01:36,060
have been spent a lot of time to

00:01:32,159 --> 00:01:38,520
investigate before knowing that well

00:01:36,060 --> 00:01:41,189
today I'm going to share with you're not

00:01:38,520 --> 00:01:43,130
a way of testing and hopefully that can

00:01:41,189 --> 00:01:45,479
help us get out of that mess

00:01:43,130 --> 00:01:48,060
this is the first time that are giving a

00:01:45,479 --> 00:01:51,240
talk to more than 10 people so please

00:01:48,060 --> 00:01:53,399
bear with me if there's any hiccups also

00:01:51,240 --> 00:01:55,740
a journalist that there are people in to

00:01:53,399 --> 00:01:58,170
understand and have explored deeper into

00:01:55,740 --> 00:01:59,310
this topic compared to me but what I

00:01:58,170 --> 00:02:01,140
would like to share here is the

00:01:59,310 --> 00:02:03,060
experience and the learning journey

00:02:01,140 --> 00:02:08,310
about pact testing within an

00:02:03,060 --> 00:02:11,160
organization so pact is a contract

00:02:08,310 --> 00:02:13,680
testing tool it also referred to as a

00:02:11,160 --> 00:02:17,549
testing framework the support mission

00:02:13,680 --> 00:02:19,769
driven testing it is used to ensure that

00:02:17,549 --> 00:02:24,239
the transaction between two API services

00:02:19,769 --> 00:02:25,769
is performing a mutually agreement I'll

00:02:24,239 --> 00:02:29,610
be referring to these services a

00:02:25,769 --> 00:02:33,150
consumer provided in this talk pack is

00:02:29,610 --> 00:02:35,220
used to verify both consumer and

00:02:33,150 --> 00:02:37,739
provider are having a commonly shared

00:02:35,220 --> 00:02:39,150
understanding about the request and the

00:02:37,739 --> 00:02:42,239
response that will be passing between

00:02:39,150 --> 00:02:43,909
them we're only testing the single

00:02:42,239 --> 00:02:48,120
transaction between these two services

00:02:43,909 --> 00:02:49,709
not the entire network once all the

00:02:48,120 --> 00:02:52,590
connection has been verified about PAC

00:02:49,709 --> 00:02:58,439
we can confident that end-to-end testing

00:02:52,590 --> 00:03:02,879
has been covered to complete a PAC there

00:02:58,439 --> 00:03:04,650
is a two-step process the consumer need

00:03:02,879 --> 00:03:06,689
to create a test that will declare the

00:03:04,650 --> 00:03:10,459
expected response from the provider and

00:03:06,689 --> 00:03:13,230
the result is registered into a PAC file

00:03:10,459 --> 00:03:16,620
the provider will then verify the PAC

00:03:13,230 --> 00:03:18,930
file were running the test packs include

00:03:16,620 --> 00:03:21,480
the request from the consumer consumer

00:03:18,930 --> 00:03:29,340
and the minimum expect the response from

00:03:21,480 --> 00:03:33,209
the provider so PAC is a consumer driven

00:03:29,340 --> 00:03:35,129
testing tool that means this is all

00:03:33,209 --> 00:03:37,709
started with the consumer running the

00:03:35,129 --> 00:03:39,569
unit tests then generating and

00:03:37,709 --> 00:03:43,049
registering the interaction of the

00:03:39,569 --> 00:03:45,180
transaction in the PAC file then the

00:03:43,049 --> 00:03:49,169
pack for Wilbur will publish to a place

00:03:45,180 --> 00:03:51,000
where we caught a PAC broker the

00:03:49,169 --> 00:03:54,150
provider will retrieve the pack for from

00:03:51,000 --> 00:04:00,060
a broker to verify day I'll comment to

00:03:54,150 --> 00:04:02,459
the PAPRICA later here is an example of

00:04:00,060 --> 00:04:05,569
the code to the user lookup service to

00:04:02,459 --> 00:04:07,979
retrieve the full name of a given user

00:04:05,569 --> 00:04:10,650
there is a function here to get the base

00:04:07,979 --> 00:04:12,060
URL for the user lookup service and

00:04:10,650 --> 00:04:16,680
we'll see the reason for this in the

00:04:12,060 --> 00:04:20,370
shop moment to test discourage the unit

00:04:16,680 --> 00:04:22,979
test will be something like this it is

00:04:20,370 --> 00:04:26,849
using monkey patch to mock the request

00:04:22,979 --> 00:04:29,060
for the return data but it could be

00:04:26,849 --> 00:04:29,060
better

00:04:29,750 --> 00:04:36,840
after we pin starter pack pattern we can

00:04:33,210 --> 00:04:40,080
mock it with the padlock and the paper

00:04:36,840 --> 00:04:42,060
will look like this it will record the

00:04:40,080 --> 00:04:44,850
interaction with the provider for

00:04:42,060 --> 00:04:47,010
verification purpose and it will also

00:04:44,850 --> 00:04:50,490
stay the expected response that the

00:04:47,010 --> 00:04:52,650
provider will be respond with so at

00:04:50,490 --> 00:04:56,250
first we need to declare a packet

00:04:52,650 --> 00:05:00,410
spiders picture and this is how we

00:04:56,250 --> 00:05:03,210
declare the consumer and the provider

00:05:00,410 --> 00:05:05,970
the pack part are executed Ruby server

00:05:03,210 --> 00:05:09,030
at the background and this is the lines

00:05:05,970 --> 00:05:11,040
that manage that the Ruby service

00:05:09,030 --> 00:05:15,810
handles and verify the request from the

00:05:11,040 --> 00:05:18,240
consumer unit tests remember to get URL

00:05:15,810 --> 00:05:21,000
function earlier we set it up that way

00:05:18,240 --> 00:05:25,860
so now so we can mock it for the Ruby's

00:05:21,000 --> 00:05:29,160
over here the interaction declared a

00:05:25,860 --> 00:05:32,340
request from the consumer and the

00:05:29,160 --> 00:05:36,090
response from the provider this mock is

00:05:32,340 --> 00:05:38,100
useful for single unit tests it could be

00:05:36,090 --> 00:05:41,040
more useful if we can use it for

00:05:38,100 --> 00:05:45,020
multiple unit tests we can make it more

00:05:41,040 --> 00:05:47,970
flexible with some tool in the pact okay

00:05:45,020 --> 00:05:50,820
here's the example that we use term

00:05:47,970 --> 00:05:52,710
mature so that the mock can be used in

00:05:50,820 --> 00:05:54,620
other unit tests with different user

00:05:52,710 --> 00:05:56,640
names

00:05:54,620 --> 00:05:59,940
this is how the PEPFAR has been

00:05:56,640 --> 00:06:01,320
generated as JSON file the font on these

00:05:59,940 --> 00:06:03,750
slides may be a bit too small for

00:06:01,320 --> 00:06:06,540
reading cousin to feed a whole pack file

00:06:03,750 --> 00:06:09,060
in there and I wasn't expecting you to

00:06:06,540 --> 00:06:13,320
reading from this now I'll explain next

00:06:09,060 --> 00:06:16,140
session as we go on because this part

00:06:13,320 --> 00:06:17,520
file is generated as a JSON file it

00:06:16,140 --> 00:06:20,730
means that this can support cross

00:06:17,520 --> 00:06:24,270
language testing like between Ruby Java

00:06:20,730 --> 00:06:25,860
JavaScript Python and nada it allows

00:06:24,270 --> 00:06:27,600
services that return in different

00:06:25,860 --> 00:06:31,590
program language to be tested in a

00:06:27,600 --> 00:06:32,970
common comment in our organization we

00:06:31,590 --> 00:06:34,530
have Joe our team and Python team

00:06:32,970 --> 00:06:38,070
testing each other pack for

00:06:34,530 --> 00:06:40,810
interactively so how could be even

00:06:38,070 --> 00:06:43,030
better if you're paying attention

00:06:40,810 --> 00:06:45,400
you can notice that I mentioned a ruby

00:06:43,030 --> 00:06:46,290
silver somewhere earlier here's not

00:06:45,400 --> 00:06:50,590
alternative

00:06:46,290 --> 00:06:54,580
Patman it is a pure Python version that

00:06:50,590 --> 00:06:57,820
power is tech it allows mocking directly

00:06:54,580 --> 00:06:59,830
rather than using a background server it

00:06:57,820 --> 00:07:02,169
also gives us it also have some better

00:06:59,830 --> 00:07:04,540
approach on the verification process as

00:07:02,169 --> 00:07:06,010
well as the better explanation on the

00:07:04,540 --> 00:07:12,460
error message when something not right

00:07:06,010 --> 00:07:15,490
I'll show you my example later on here's

00:07:12,460 --> 00:07:17,560
another example we are posting to user

00:07:15,490 --> 00:07:21,639
service to update the details for a

00:07:17,560 --> 00:07:25,990
given user this is how we unit tests

00:07:21,639 --> 00:07:28,660
occur it by using a generic mock but

00:07:25,990 --> 00:07:31,720
instead of generic mock we can use a pad

00:07:28,660 --> 00:07:33,790
mount the fixture of this pack is the

00:07:31,720 --> 00:07:37,840
same as the earlier sauce keeping that

00:07:33,790 --> 00:07:40,419
part sium to make this test more

00:07:37,840 --> 00:07:42,639
flexible for other tests we can mock the

00:07:40,419 --> 00:07:45,940
rules this time rather than specific

00:07:42,639 --> 00:07:47,470
values we can achieve the result by

00:07:45,940 --> 00:07:51,070
using the light metric class from the

00:07:47,470 --> 00:07:53,320
pack to key so now the mock is only pay

00:07:51,070 --> 00:07:55,450
attention to the data type and not the

00:07:53,320 --> 00:07:59,800
actual value that the consumer mentioned

00:07:55,450 --> 00:08:01,360
in the unit tests and again here's the

00:07:59,800 --> 00:08:05,680
pack file that has been generated in the

00:08:01,360 --> 00:08:08,650
JSON format it is important to keep in

00:08:05,680 --> 00:08:10,840
mind that now is not the same as none no

00:08:08,650 --> 00:08:12,130
empty string these are the times that

00:08:10,840 --> 00:08:16,479
different and need to be handled

00:08:12,130 --> 00:08:21,990
separately but life is more fun than

00:08:16,479 --> 00:08:26,110
that how about other data type like date

00:08:21,990 --> 00:08:28,510
or even future date how can we express a

00:08:26,110 --> 00:08:30,280
future date for the interaction if the

00:08:28,510 --> 00:08:33,070
future there is one of the fundamental

00:08:30,280 --> 00:08:36,400
requirements for particular service to

00:08:33,070 --> 00:08:39,190
fulfill the requests and our team will

00:08:36,400 --> 00:08:41,200
kindly request our consumer to publish a

00:08:39,190 --> 00:08:44,050
really really really feature the

00:08:41,200 --> 00:08:46,300
indo-pak so when the Peck files get to

00:08:44,050 --> 00:08:48,760
be verified in the near future or at

00:08:46,300 --> 00:08:51,580
least the time the owl's teams today the

00:08:48,760 --> 00:08:53,200
future that is the future enough the

00:08:51,580 --> 00:08:54,960
next specification of the pet is going

00:08:53,200 --> 00:08:59,170
to address this

00:08:54,960 --> 00:09:04,030
so what else does a consumer need to do

00:08:59,170 --> 00:09:05,530
here as a consumer we have to ensure

00:09:04,030 --> 00:09:09,160
that all the service cost to the

00:09:05,530 --> 00:09:11,140
provider has been tested in our team

00:09:09,160 --> 00:09:13,300
this has been achieved by setting the

00:09:11,140 --> 00:09:16,570
full testing coverage as one of the

00:09:13,300 --> 00:09:18,790
requirements for the code comment this

00:09:16,570 --> 00:09:21,100
is not only giving us the confidence the

00:09:18,790 --> 00:09:22,780
order code has been tested it's also

00:09:21,100 --> 00:09:24,700
giving us the assurance the other

00:09:22,780 --> 00:09:27,880
interaction to the provider has been

00:09:24,700 --> 00:09:42,460
registered and most importantly the

00:09:27,880 --> 00:09:44,200
provider is aware of this as well when

00:09:42,460 --> 00:09:46,450
the consumer is running the unit tests

00:09:44,200 --> 00:09:49,270
the PEPFAR would generate it as the

00:09:46,450 --> 00:09:52,180
artifact then the pair file is published

00:09:49,270 --> 00:09:54,580
to the pact broker and when the

00:09:52,180 --> 00:09:56,380
providers to run a verification this

00:09:54,580 --> 00:09:59,470
will retrieve the PAC file from a petrol

00:09:56,380 --> 00:10:04,570
car then run the pack where fire to

00:09:59,470 --> 00:10:08,560
verified it this is how we run the pet

00:10:04,570 --> 00:10:13,210
verify in the PAC passing away the pain

00:10:08,560 --> 00:10:15,700
URL provide a base URL and the provided

00:10:13,210 --> 00:10:17,290
state set up URLs are the arguments that

00:10:15,700 --> 00:10:23,020
need to be provided for the pet provider

00:10:17,290 --> 00:10:27,520
the verifier come up and this is how we

00:10:23,020 --> 00:10:30,100
run the pair if I in a Patman way the

00:10:27,520 --> 00:10:31,780
provider name provider base URL and

00:10:30,100 --> 00:10:34,540
provider setup is still the same

00:10:31,780 --> 00:10:37,900
mandatory as the previous pack water

00:10:34,540 --> 00:10:43,120
file but it also pulled a PAC file from

00:10:37,900 --> 00:10:45,160
the PAC broker for provider and also we

00:10:43,120 --> 00:10:47,230
can run this for a locally store pet

00:10:45,160 --> 00:10:50,950
fault if we want to run the testing

00:10:47,230 --> 00:10:53,530
locally or just run a verifier for

00:10:50,950 --> 00:10:56,230
single consumer from the burka because

00:10:53,530 --> 00:11:00,580
sometimes you can have multiple consumer

00:10:56,230 --> 00:11:02,950
to your service this is uploading work

00:11:00,580 --> 00:11:06,720
verification result for a given version

00:11:02,950 --> 00:11:06,720
of the provider back to the petrol car

00:11:07,430 --> 00:11:13,660
also has some other useful argument like

00:11:09,470 --> 00:11:16,220
help so feel free to poke around them

00:11:13,660 --> 00:11:18,649
here's the example of the result that

00:11:16,220 --> 00:11:21,649
petrify gives us and of course we're

00:11:18,649 --> 00:11:23,660
using the patent version yeah we can

00:11:21,649 --> 00:11:25,700
also set the pet broker you are out on

00:11:23,660 --> 00:11:30,140
the environment so we're not seeing the

00:11:25,700 --> 00:11:32,620
pet broker URL here as well it is

00:11:30,140 --> 00:11:36,830
running the pet verify on the version

00:11:32,620 --> 00:11:40,339
1.2.5 of the user service on the

00:11:36,830 --> 00:11:42,140
localhost port 8000 and this is the

00:11:40,339 --> 00:11:44,870
endpoint to setup the provider States

00:11:42,140 --> 00:11:49,070
I'll touch the providers that later on

00:11:44,870 --> 00:11:52,550
as well it's indicated interaction from

00:11:49,070 --> 00:11:56,300
auto consumers some request that has

00:11:52,550 --> 00:11:59,720
been passed and fulfill some of them

00:11:56,300 --> 00:12:07,130
that's failed and fell for different

00:11:59,720 --> 00:12:08,630
reasons again as a provider first we

00:12:07,130 --> 00:12:11,120
need to ensure that a consumer is

00:12:08,630 --> 00:12:13,970
calling the service correctly with the

00:12:11,120 --> 00:12:19,040
correct payload parameters or even the

00:12:13,970 --> 00:12:20,570
HTTP methods further than that provider

00:12:19,040 --> 00:12:22,190
also need to make sure that we are

00:12:20,570 --> 00:12:27,560
returning the agreed and expected

00:12:22,190 --> 00:12:29,089
response to the consumer here is the

00:12:27,560 --> 00:12:32,180
scenario that we've been trying to pass

00:12:29,089 --> 00:12:34,610
before pack the consumer is calling the

00:12:32,180 --> 00:12:38,240
user service to update a birthday for a

00:12:34,610 --> 00:12:41,060
given user the birthday was set as

00:12:38,240 --> 00:12:45,290
isotype format which you can see from

00:12:41,060 --> 00:12:48,560
the unit area but the user service has a

00:12:45,290 --> 00:12:51,010
birthday as a number yes because user

00:12:48,560 --> 00:12:54,770
services taking birthday as important

00:12:51,010 --> 00:12:57,770
and because the consumer is using a

00:12:54,770 --> 00:13:00,050
generic mock for the user service this

00:12:57,770 --> 00:13:02,810
error was not discovered until we're and

00:13:00,050 --> 00:13:04,940
occur in the production if we were using

00:13:02,810 --> 00:13:07,430
Pat mock we would have discovered this

00:13:04,940 --> 00:13:11,290
before girl life because the Pat

00:13:07,430 --> 00:13:11,290
verification result would alert us

00:13:15,300 --> 00:13:21,310
as a provider where we are where find a

00:13:19,209 --> 00:13:23,050
packed file from the consumer we

00:13:21,310 --> 00:13:26,199
sometimes need resources like database

00:13:23,050 --> 00:13:27,880
contents environment variables even

00:13:26,199 --> 00:13:29,800
maybe need to consume cell on the

00:13:27,880 --> 00:13:32,500
downstream services to able to complete

00:13:29,800 --> 00:13:34,389
the requests we need to mount these

00:13:32,500 --> 00:13:36,069
downstream service call because they are

00:13:34,389 --> 00:13:40,269
not part of this interaction that we're

00:13:36,069 --> 00:13:43,180
testing with well how do we know what to

00:13:40,269 --> 00:13:46,509
mock here comes the purpose of the

00:13:43,180 --> 00:13:48,819
provider state and because this is a

00:13:46,509 --> 00:13:51,910
consumer driven testing the providers

00:13:48,819 --> 00:13:54,519
that is coming from the consumer when

00:13:51,910 --> 00:13:56,380
the consumer is registering the pack it

00:13:54,519 --> 00:13:59,829
will also need to supply with a provider

00:13:56,380 --> 00:14:03,389
state so that the provider can set up

00:13:59,829 --> 00:14:03,389
the relevant data for the verification

00:14:03,660 --> 00:14:10,990
for example the consumers to send a

00:14:07,569 --> 00:14:15,610
request to delete a user account here's

00:14:10,990 --> 00:14:17,110
the code for the delete requests and the

00:14:15,610 --> 00:14:20,980
providers there will be something like

00:14:17,110 --> 00:14:22,810
given there is a user Alexis's and when

00:14:20,980 --> 00:14:25,779
the users lookup service is to verify

00:14:22,810 --> 00:14:28,630
this pack it will go ahead and set up

00:14:25,779 --> 00:14:30,040
the user Alex then run the pack to make

00:14:28,630 --> 00:14:36,010
sure that the interaction has been

00:14:30,040 --> 00:14:39,970
processed correctly as suspected pack

00:14:36,010 --> 00:14:42,040
verification is a stateless process this

00:14:39,970 --> 00:14:44,079
means that it is slightly different from

00:14:42,040 --> 00:14:46,529
the unit testing which is isolated to

00:14:44,079 --> 00:14:46,529
each other

00:14:46,649 --> 00:14:51,670
it is important to make sure that when

00:14:49,990 --> 00:14:53,889
the provider is setting up the data for

00:14:51,670 --> 00:14:56,370
the verification process this is

00:14:53,889 --> 00:14:58,449
happening in a non production endpoint

00:14:56,370 --> 00:15:02,439
this can be controlled by different

00:14:58,449 --> 00:15:04,600
project settings our team is taking

00:15:02,439 --> 00:15:07,449
another extra steps to provide even more

00:15:04,600 --> 00:15:09,790
protection which is a simple check at

00:15:07,449 --> 00:15:11,829
the object counts on the database before

00:15:09,790 --> 00:15:14,319
doing the manipulation of the data for

00:15:11,829 --> 00:15:15,910
the providers they set up and we are

00:15:14,319 --> 00:15:17,980
assuming that the product should

00:15:15,910 --> 00:15:20,130
database has more than two entries in

00:15:17,980 --> 00:15:20,130
there

00:15:21,780 --> 00:15:27,760
pet broker fabrica is a tools that

00:15:25,900 --> 00:15:31,570
provide the ability to gathering and

00:15:27,760 --> 00:15:35,170
sharing the pack file as well as the

00:15:31,570 --> 00:15:37,690
verification result it is a restful api

00:15:35,170 --> 00:15:40,780
that let us to navigate around the list

00:15:37,690 --> 00:15:44,650
of consumer and provider here is a

00:15:40,780 --> 00:15:47,260
section of a broker relationship the

00:15:44,650 --> 00:15:51,250
phone is not so great so just show some

00:15:47,260 --> 00:15:55,150
features here here is an example of a

00:15:51,250 --> 00:15:57,250
single pack file it's also

00:15:55,150 --> 00:16:02,650
auto-generated some documentation for

00:15:57,250 --> 00:16:04,660
each of them it is also storing the

00:16:02,650 --> 00:16:06,280
verification results that has been run

00:16:04,660 --> 00:16:09,880
for a different version of a consumer

00:16:06,280 --> 00:16:11,710
and provider it's helped us to visualize

00:16:09,880 --> 00:16:15,670
the relationship between the services

00:16:11,710 --> 00:16:17,920
the register gains in here's a glance of

00:16:15,670 --> 00:16:19,180
our car network diagram that all the

00:16:17,920 --> 00:16:23,280
services has been registered on our

00:16:19,180 --> 00:16:25,900
paprika please do not try to read this

00:16:23,280 --> 00:16:28,180
we can also put a data from the pet

00:16:25,900 --> 00:16:30,610
broker to consolidate some more useful

00:16:28,180 --> 00:16:32,710
information that we need this is a

00:16:30,610 --> 00:16:37,080
section of our team dashboard that's

00:16:32,710 --> 00:16:37,080
showing the pet verification results

00:16:38,100 --> 00:16:44,320
there's one of the future in the pet

00:16:40,750 --> 00:16:46,870
broker called can i deploy it can give

00:16:44,320 --> 00:16:48,250
us a hand of checking if the code is ok

00:16:46,870 --> 00:16:52,060
to be deployed to a particular

00:16:48,250 --> 00:16:57,430
environment and the command to run it's

00:16:52,060 --> 00:16:58,710
something like this so where do we go

00:16:57,430 --> 00:17:02,290
from here

00:16:58,710 --> 00:17:07,300
we just need to Pete in Sodom and go and

00:17:02,290 --> 00:17:09,790
have fun exploring the pet world today

00:17:07,300 --> 00:17:11,709
I'll show you a few things about pack as

00:17:09,790 --> 00:17:14,530
an alternative to the integration

00:17:11,709 --> 00:17:16,720
testing some responsibilities from the

00:17:14,530 --> 00:17:18,310
consumer side as well as the provider

00:17:16,720 --> 00:17:20,800
side of a single transaction

00:17:18,310 --> 00:17:22,540
I've also share with you some of the

00:17:20,800 --> 00:17:24,670
learning that we have been encountered

00:17:22,540 --> 00:17:28,000
during my exploration about packing

00:17:24,670 --> 00:17:30,100
pattern here is some reference link that

00:17:28,000 --> 00:17:34,050
I'm referring to along the way thank you

00:17:30,100 --> 00:17:34,050
for having me and hope you enjoy it

00:17:39,920 --> 00:17:44,820
Thank You Silvia now Silvia has asked

00:17:42,990 --> 00:17:47,309
that we don't take questions on Mike so

00:17:44,820 --> 00:17:48,990
if you'd like to talk to her Silvia

00:17:47,309 --> 00:17:50,940
after the talk that she's more than

00:17:48,990 --> 00:17:54,420
welcome to talk more than happy to talk

00:17:50,940 --> 00:17:55,710
to you after the talk but first a gift

00:17:54,420 --> 00:17:58,110
from the organizers of the conference

00:17:55,710 --> 00:18:00,650
your very first of many I hope

00:17:58,110 --> 00:18:06,909
Piko a you Mike thank you again sir

00:18:00,650 --> 00:18:06,909

YouTube URL: https://www.youtube.com/watch?v=S-IwNuMiqd4


