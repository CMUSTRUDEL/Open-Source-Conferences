Title: Running Python on your brain computer
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Ben Taylor

https://2018.pycon-au.org/talks/45039-running-python-on-your-brain-computer/

Reading and predicting what code will do is a fundamental coding skill. But when students read code are they executing it on their brain computer? Or do they only read the words?

This talk will explore learning to read and trace code, misconceptions and how to build a really good brain computer.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,030 --> 00:00:04,740
everybody thank you to everybody who

00:00:01,829 --> 00:00:08,610
stayed welcome to anybody who joined I

00:00:04,740 --> 00:00:10,230
get to introduce Ben Taylor he's working

00:00:08,610 --> 00:00:11,969
as an interface designer and software

00:00:10,230 --> 00:00:14,219
developer building educational

00:00:11,969 --> 00:00:15,839
technology at grok learning and his

00:00:14,219 --> 00:00:18,210
focus is on improving the learning

00:00:15,839 --> 00:00:21,779
experience and the user experience of

00:00:18,210 --> 00:00:23,250
the product in spare time he reads a lot

00:00:21,779 --> 00:00:24,930
of computer science education research

00:00:23,250 --> 00:00:27,090
he really does because he then gives it

00:00:24,930 --> 00:00:28,920
all to me which has been made more

00:00:27,090 --> 00:00:30,960
difficult after graduating from his

00:00:28,920 --> 00:00:33,300
master's and promptly losing any direct

00:00:30,960 --> 00:00:35,460
access to journal papers now instead of

00:00:33,300 --> 00:00:41,070
logging on he visits the library asked

00:00:35,460 --> 00:00:42,690
him for fun facts about ants his talk is

00:00:41,070 --> 00:00:47,820
called running Python on your brain

00:00:42,690 --> 00:00:50,610
computer and welcome Ben oh okay so

00:00:47,820 --> 00:00:53,280
before you clap he has got too many

00:00:50,610 --> 00:00:55,110
slides so that means that his questions

00:00:53,280 --> 00:01:04,199
today will be answered in the corridor

00:00:55,110 --> 00:01:05,790
or at lunch please welcome so this talk

00:01:04,199 --> 00:01:08,600
is called running Python on your brain

00:01:05,790 --> 00:01:11,280
computer it's a talk about tracing code

00:01:08,600 --> 00:01:13,979
so let's get into it

00:01:11,280 --> 00:01:16,860
I just wanted to say g'day I'm Ben I

00:01:13,979 --> 00:01:18,689
wanted to get a read of the audience how

00:01:16,860 --> 00:01:21,270
many people here are teachers put your

00:01:18,689 --> 00:01:23,580
hands up great how many people who are

00:01:21,270 --> 00:01:26,970
interested in education are better not

00:01:23,580 --> 00:01:29,390
teachers awesome and how many people are

00:01:26,970 --> 00:01:35,159
students especially high school students

00:01:29,390 --> 00:01:37,979
cool awesome great so I'm Ben I work at

00:01:35,159 --> 00:01:42,350
grok learning this is a photo

00:01:37,979 --> 00:01:45,810
sorry this is us being professional

00:01:42,350 --> 00:01:49,140
we mostly teach high school kids to code

00:01:45,810 --> 00:01:52,890
online we have a platform for that but

00:01:49,140 --> 00:01:54,720
we also help a few universities and we

00:01:52,890 --> 00:01:56,280
have some stuff for primary school

00:01:54,720 --> 00:02:00,000
students and we also collaborate with

00:01:56,280 --> 00:02:01,770
the ACA who are fantastic some of my

00:02:00,000 --> 00:02:05,009
role is about learning some of it is

00:02:01,770 --> 00:02:08,640
about technology so recently I built

00:02:05,009 --> 00:02:12,180
this thing which is our new interactive

00:02:08,640 --> 00:02:13,730
notes for the N CSS challenge 2018 what

00:02:12,180 --> 00:02:15,920
it allows is creates

00:02:13,730 --> 00:02:17,659
Raksha to reading for younger students

00:02:15,920 --> 00:02:21,379
especially but it also gives feedback

00:02:17,659 --> 00:02:23,900
and encourages interacting with our

00:02:21,379 --> 00:02:27,879
notes and all of our notes are

00:02:23,900 --> 00:02:30,860
interactive so something I built so

00:02:27,879 --> 00:02:33,890
let's get into the actual talk about

00:02:30,860 --> 00:02:36,920
tracing so just a bit of an introduction

00:02:33,890 --> 00:02:40,010
in this talk I'm gonna go through what

00:02:36,920 --> 00:02:42,489
tracing is why it's useful how we learn

00:02:40,010 --> 00:02:45,709
it and how we can teach it a bit better

00:02:42,489 --> 00:02:48,620
so tracing if you haven't heard the term

00:02:45,709 --> 00:02:51,349
before is simulating the execution of

00:02:48,620 --> 00:02:54,260
your code to see how it works and this

00:02:51,349 --> 00:02:57,290
is the more formal definition of reading

00:02:54,260 --> 00:03:02,090
code so simulating rather than reading

00:02:57,290 --> 00:03:04,220
and why should we trace why is tracing

00:03:02,090 --> 00:03:06,260
important so I'm going to give a little

00:03:04,220 --> 00:03:08,030
bit of an example from the N CSS

00:03:06,260 --> 00:03:09,489
challenge this year the N CSS challenge

00:03:08,030 --> 00:03:12,290
is an online programming competition

00:03:09,489 --> 00:03:14,750
that more than 20,000 people have done

00:03:12,290 --> 00:03:16,400
around Australia and the world and it's

00:03:14,750 --> 00:03:19,519
currently running this problem is called

00:03:16,400 --> 00:03:21,590
Pizza predicament and it's an

00:03:19,519 --> 00:03:24,620
intermediate problem so aimed at

00:03:21,590 --> 00:03:26,599
students in years 9 & 10 ish though we

00:03:24,620 --> 00:03:33,799
obviously have students in year 7

00:03:26,599 --> 00:03:36,500
yeah a year 12 year 3 doing this in this

00:03:33,799 --> 00:03:40,730
problem students are asked to read in a

00:03:36,500 --> 00:03:42,980
string of characters like HP cm and then

00:03:40,730 --> 00:03:45,709
print out the ingredients for that pizza

00:03:42,980 --> 00:03:49,849
so if the order was HP cm it would be

00:03:45,709 --> 00:03:54,109
ham pepperoni capsicum and mushroom if

00:03:49,849 --> 00:03:56,569
the order was OMP key OMP KHL it would

00:03:54,109 --> 00:03:59,150
be onion mushroom pepperoni and then if

00:03:56,569 --> 00:04:02,299
it doesn't know what that character is

00:03:59,150 --> 00:04:04,099
it should say more cheese so this

00:04:02,299 --> 00:04:06,500
particular pizza would be a little bit

00:04:04,099 --> 00:04:10,010
cheesy it would have a bit of extra

00:04:06,500 --> 00:04:12,169
cheese so I'd like to have a look at a

00:04:10,010 --> 00:04:14,780
imaginary students attempt at this

00:04:12,169 --> 00:04:16,729
problem and this is synthesized from me

00:04:14,780 --> 00:04:19,340
looking at a few different students and

00:04:16,729 --> 00:04:22,520
how they approach the problem so this is

00:04:19,340 --> 00:04:24,110
Patil does first attempt so batula has

00:04:22,520 --> 00:04:27,230
got a lot of four loops

00:04:24,110 --> 00:04:30,740
and each of those four loops check

00:04:27,230 --> 00:04:33,440
a single letter and they've marked it

00:04:30,740 --> 00:04:36,170
and testing the first example in the

00:04:33,440 --> 00:04:39,290
question they got it right so they feel

00:04:36,170 --> 00:04:41,240
we're proud about it but second example

00:04:39,290 --> 00:04:42,920
it did not produce the correct output

00:04:41,240 --> 00:04:45,050
and what their eyes are drawn to

00:04:42,920 --> 00:04:47,090
straight away is that they didn't hit

00:04:45,050 --> 00:04:49,310
the more cheese part so they're not

00:04:47,090 --> 00:04:53,720
printing out more cheese when they get

00:04:49,310 --> 00:04:57,320
to the the letters that are not that

00:04:53,720 --> 00:05:01,400
they don't know so but till the second

00:04:57,320 --> 00:05:04,030
attempt is cut off down the bottom a

00:05:01,400 --> 00:05:08,120
little bit but you can see it it says

00:05:04,030 --> 00:05:12,170
else print more cheese and when their

00:05:08,120 --> 00:05:14,930
program runs their program goes ham

00:05:12,170 --> 00:05:17,540
pepperoni capsicum more cheese more

00:05:14,930 --> 00:05:19,340
cheese more cheese mushroom and this is

00:05:17,540 --> 00:05:22,040
a very cheesy pizza and this is

00:05:19,340 --> 00:05:23,870
unexpected from FUBU tilde but tilde

00:05:22,040 --> 00:05:27,020
thought that their code was going to

00:05:23,870 --> 00:05:29,930
work but instead their solution doesn't

00:05:27,020 --> 00:05:32,390
even pass the first test which they were

00:05:29,930 --> 00:05:33,890
surprised about and part of it is

00:05:32,390 --> 00:05:37,940
because of the way they've used their

00:05:33,890 --> 00:05:40,610
else statement so why has bateau de done

00:05:37,940 --> 00:05:42,050
this why why have they why have they put

00:05:40,610 --> 00:05:44,980
their else statement in that particular

00:05:42,050 --> 00:05:48,500
spot and it's important to realize that

00:05:44,980 --> 00:05:51,440
novice learners are just using what they

00:05:48,500 --> 00:05:54,200
know if they don't comprehend their own

00:05:51,440 --> 00:05:57,170
code they do really strange things to

00:05:54,200 --> 00:05:59,710
try and fix it and that's confounded by

00:05:57,170 --> 00:06:03,770
the bugs that they introduce themselves

00:05:59,710 --> 00:06:06,890
so this is battlers code and the big

00:06:03,770 --> 00:06:08,750
problem really is all the four loops but

00:06:06,890 --> 00:06:11,030
the little problem is that extra else

00:06:08,750 --> 00:06:15,950
statement right at the end and all of

00:06:11,030 --> 00:06:18,290
this comes together because this student

00:06:15,950 --> 00:06:20,540
is a novice tracer they're not

00:06:18,290 --> 00:06:25,070
particularly good at reading their own

00:06:20,540 --> 00:06:28,010
code yet part of this is probably that

00:06:25,070 --> 00:06:30,770
they're interpreting their code like

00:06:28,010 --> 00:06:35,090
English so if you read this as English

00:06:30,770 --> 00:06:37,610
we might say look for H in here in the

00:06:35,090 --> 00:06:40,400
string if there's a H print ham look for

00:06:37,610 --> 00:06:43,669
P if there's a P print pepperoni

00:06:40,400 --> 00:06:46,370
for em if there's an EM print mushroom

00:06:43,669 --> 00:06:48,770
otherwise print more cheese and when you

00:06:46,370 --> 00:06:50,300
read it like that it does sound like it

00:06:48,770 --> 00:06:52,580
solves the problem but that's not how

00:06:50,300 --> 00:06:54,830
the computer reads it the other thing

00:06:52,580 --> 00:06:57,260
that students will do is apply their own

00:06:54,830 --> 00:07:00,380
preconceptions about how they think

00:06:57,260 --> 00:07:02,150
their code works on to the code that

00:07:00,380 --> 00:07:04,460
they've written so if they think that

00:07:02,150 --> 00:07:06,979
their code works then they're going to

00:07:04,460 --> 00:07:09,110
expect that it works in a particular way

00:07:06,979 --> 00:07:11,090
and this is going to frustrate them and

00:07:09,110 --> 00:07:15,830
this is the student that emails us and

00:07:11,090 --> 00:07:18,470
tells us that our tests are wrong oh and

00:07:15,830 --> 00:07:20,750
that's fine we'll help them out but but

00:07:18,470 --> 00:07:22,970
all of this comes together because this

00:07:20,750 --> 00:07:24,800
student isn't running Python on their

00:07:22,970 --> 00:07:27,020
brain computer they're not really

00:07:24,800 --> 00:07:28,729
simulating it in their head they're

00:07:27,020 --> 00:07:33,260
reading it out or they're making other

00:07:28,729 --> 00:07:36,560
mistakes so what would an expert tracer

00:07:33,260 --> 00:07:40,190
do an expert tracer would behave a

00:07:36,560 --> 00:07:42,260
little differently so I've set up how I

00:07:40,190 --> 00:07:43,940
would diagram tracing in front of

00:07:42,260 --> 00:07:45,310
students although I'd probably be using

00:07:43,940 --> 00:07:48,770
a whiteboard and not this presentation

00:07:45,310 --> 00:07:51,169
and what I've got on the right is the

00:07:48,770 --> 00:07:53,479
Tilda's code and what I've got on the

00:07:51,169 --> 00:07:56,180
left is a table for variables and an

00:07:53,479 --> 00:07:58,130
area for output so we're going to run

00:07:56,180 --> 00:08:01,370
through this code to have a look at

00:07:58,130 --> 00:08:06,110
where the bugs are so we read in order

00:08:01,370 --> 00:08:07,940
and it's HPC m then we go into the for

00:08:06,110 --> 00:08:10,970
loop and the first step of the for loop

00:08:07,940 --> 00:08:12,560
is setting the letter variable to be H

00:08:10,970 --> 00:08:16,190
which is the first character in the

00:08:12,560 --> 00:08:19,699
string then we go into the for loop we

00:08:16,190 --> 00:08:21,590
check if the letter is H it is H and so

00:08:19,699 --> 00:08:24,229
we do the if statement and we print ham

00:08:21,590 --> 00:08:25,699
out then we repeat this process and it's

00:08:24,229 --> 00:08:27,530
very important that we repeat this

00:08:25,699 --> 00:08:28,940
process because a lot of students will

00:08:27,530 --> 00:08:30,229
skip this part they'll just say well

00:08:28,940 --> 00:08:33,260
that's what the for loop does and

00:08:30,229 --> 00:08:37,159
they'll move on so we repeat and we go P

00:08:33,260 --> 00:08:40,190
and we go for the P if the letter is H

00:08:37,159 --> 00:08:43,250
it's not until we start again for letter

00:08:40,190 --> 00:08:46,220
in order see if the letter is H it's not

00:08:43,250 --> 00:08:49,339
we move on for letter in order if the

00:08:46,220 --> 00:08:51,079
letter is H it's not and so we move on

00:08:49,339 --> 00:08:52,339
to the next for loop now I'm not going

00:08:51,079 --> 00:08:54,020
to put you through the torture of going

00:08:52,339 --> 00:08:57,200
through the whole example

00:08:54,020 --> 00:09:00,020
so let's skip ahead a little so we've

00:08:57,200 --> 00:09:01,670
got this last for loop and this is what

00:09:00,020 --> 00:09:05,150
I think is the most interesting part of

00:09:01,670 --> 00:09:07,550
this solution this student has this

00:09:05,150 --> 00:09:10,360
final four loop which creates the more

00:09:07,550 --> 00:09:13,910
cheese problem the very cheesy pizza so

00:09:10,360 --> 00:09:18,320
first step was we set a letter in order

00:09:13,910 --> 00:09:20,390
if the letter is M it's not and so we go

00:09:18,320 --> 00:09:24,530
to the else statement and print more

00:09:20,390 --> 00:09:29,420
cheese we repeat if the letter is M it's

00:09:24,530 --> 00:09:33,350
not else print more cheese four letter

00:09:29,420 --> 00:09:36,380
in order if the letter is M it's not so

00:09:33,350 --> 00:09:38,300
we print more cheese and if we do this

00:09:36,380 --> 00:09:41,000
if we go through this very painful

00:09:38,300 --> 00:09:43,190
process of completely simulating the

00:09:41,000 --> 00:09:46,010
code the bug becomes so much more

00:09:43,190 --> 00:09:48,950
visible the bug is screaming at you that

00:09:46,010 --> 00:09:51,140
each time that loop happens the else

00:09:48,950 --> 00:09:55,580
statement executes and prints out more

00:09:51,140 --> 00:09:58,250
cheese finally of course we want to go

00:09:55,580 --> 00:10:01,670
to finish this program if the letter is

00:09:58,250 --> 00:10:05,030
M it is we print mushroom and so this is

00:10:01,670 --> 00:10:08,000
how we would trace through this program

00:10:05,030 --> 00:10:10,610
as an expert tracer and not as a novice

00:10:08,000 --> 00:10:13,340
tracer and this is the kind of exercise

00:10:10,610 --> 00:10:16,370
that you can do in a classroom or in a

00:10:13,340 --> 00:10:18,170
code club or at university tutoring to

00:10:16,370 --> 00:10:20,990
help students understand what's really

00:10:18,170 --> 00:10:22,550
going on with their code and the thing

00:10:20,990 --> 00:10:25,040
about tracing is that it's really

00:10:22,550 --> 00:10:26,840
difficult students struggling Scargill

00:10:25,040 --> 00:10:28,730
understanding code they struggle

00:10:26,840 --> 00:10:31,550
understanding code that they've written

00:10:28,730 --> 00:10:33,890
themselves and simulating the execution

00:10:31,550 --> 00:10:36,170
of code requires a lot of patience and

00:10:33,890 --> 00:10:38,600
attention to detail that particular

00:10:36,170 --> 00:10:40,420
example took quite a while and I'd

00:10:38,600 --> 00:10:43,940
structured and drawn it ahead of time

00:10:40,420 --> 00:10:46,100
but but encouraging students to do this

00:10:43,940 --> 00:10:49,670
process builds up their confidence with

00:10:46,100 --> 00:10:53,420
it and it'll allow them to code in debug

00:10:49,670 --> 00:10:55,520
more effectively a big difference with

00:10:53,420 --> 00:10:57,380
tracing to other skills is that it can

00:10:55,520 --> 00:10:59,180
be quite invisible it's hard for you to

00:10:57,380 --> 00:11:01,010
tell when you're talking to a student

00:10:59,180 --> 00:11:02,690
whether they're really simulating the

00:11:01,010 --> 00:11:04,430
code in their head or whether they're

00:11:02,690 --> 00:11:08,720
just kind of reading it whether they're

00:11:04,430 --> 00:11:12,040
doing the English way of of reading it

00:11:08,720 --> 00:11:14,480
and and tracing is important

00:11:12,040 --> 00:11:16,490
comprehension has a big impact on

00:11:14,480 --> 00:11:18,680
composition when a student doesn't

00:11:16,490 --> 00:11:21,380
understand their own code is very hard

00:11:18,680 --> 00:11:23,149
for them to add to it debugging code is

00:11:21,380 --> 00:11:25,310
much harder when you don't understand

00:11:23,149 --> 00:11:27,529
how your code works it's harder to spot

00:11:25,310 --> 00:11:29,839
the bug if you don't see where the bug

00:11:27,529 --> 00:11:31,910
really is finally it helps with

00:11:29,839 --> 00:11:33,380
computational thinking because being

00:11:31,910 --> 00:11:35,000
able to simulate a computer in your head

00:11:33,380 --> 00:11:40,430
is kind of the thing about computational

00:11:35,000 --> 00:11:43,100
thinking so how can we teach tracing to

00:11:40,430 --> 00:11:45,320
students well learning tracing happens

00:11:43,100 --> 00:11:47,120
as students learn to code if you're not

00:11:45,320 --> 00:11:49,790
teaching it students are learning it

00:11:47,120 --> 00:11:52,130
themselves just in perhaps not a ideal

00:11:49,790 --> 00:11:54,459
way the first steps of learning to trace

00:11:52,130 --> 00:11:57,740
happen when we start out with variables

00:11:54,459 --> 00:12:01,190
so here is an example of a problem on

00:11:57,740 --> 00:12:04,430
grok this is the hello name problem it

00:12:01,190 --> 00:12:06,320
says what is your name Brooke then it

00:12:04,430 --> 00:12:08,029
responds with hallo grok if you would

00:12:06,320 --> 00:12:09,950
input frodo it would respond with hello

00:12:08,029 --> 00:12:12,200
Frodo if you were to input nicky it

00:12:09,950 --> 00:12:15,350
would say hello Nicky

00:12:12,200 --> 00:12:18,290
so this is Bonifant first attempt he's

00:12:15,350 --> 00:12:20,600
written input what is your name and then

00:12:18,290 --> 00:12:23,300
print hello croc and this is a really

00:12:20,600 --> 00:12:26,930
common solution to this to this problem

00:12:23,300 --> 00:12:29,060
now this passes a lot of tests because

00:12:26,930 --> 00:12:31,430
it does get the hello grok example

00:12:29,060 --> 00:12:35,360
correct but when it comes to the next

00:12:31,430 --> 00:12:37,550
step and it's got the input of frodo it

00:12:35,360 --> 00:12:39,800
still says hallowed rock so this student

00:12:37,550 --> 00:12:42,620
reads the feedback oh I meant to say

00:12:39,800 --> 00:12:45,520
hello Frodo and of course they implement

00:12:42,620 --> 00:12:48,860
this program which says hello to Frodo

00:12:45,520 --> 00:12:51,050
then they don't pass as many tests and

00:12:48,860 --> 00:12:53,270
they're like what's going on I made it

00:12:51,050 --> 00:12:55,910
say hello Frodo and now it's saying

00:12:53,270 --> 00:13:00,920
hello grukk is the correct answer so

00:12:55,910 --> 00:13:03,380
they change it back to hollyrock and and

00:13:00,920 --> 00:13:05,690
the program gets through the same test

00:13:03,380 --> 00:13:07,880
but then fails again of course the

00:13:05,690 --> 00:13:11,149
student is now very frustrated they

00:13:07,880 --> 00:13:12,589
don't understand what's going wrong why

00:13:11,149 --> 00:13:14,899
don't they understand what's going wrong

00:13:12,589 --> 00:13:17,839
maybe we can explain variables better

00:13:14,899 --> 00:13:19,990
and yeah that's part of it but they have

00:13:17,839 --> 00:13:21,830
a fundamental misconception about

00:13:19,990 --> 00:13:25,280
computers and how they were

00:13:21,830 --> 00:13:28,610
they don't quite understand yet that one

00:13:25,280 --> 00:13:30,860
program can do more than one thing and

00:13:28,610 --> 00:13:33,080
they that means they don't have in their

00:13:30,860 --> 00:13:35,300
head a model of computation they're

00:13:33,080 --> 00:13:37,040
making hypotheses and testing them but

00:13:35,300 --> 00:13:39,080
without the right model they make

00:13:37,040 --> 00:13:42,260
strange hypotheses and came up come up

00:13:39,080 --> 00:13:45,290
with strange solutions so what's a

00:13:42,260 --> 00:13:52,310
computer a computer is a machine that

00:13:45,290 --> 00:13:54,890
can solve any problem we're done in this

00:13:52,310 --> 00:13:58,010
case really this is a machine that can

00:13:54,890 --> 00:13:59,890
say hello to anyone but this idea of a

00:13:58,010 --> 00:14:02,420
machine that can solve any problem is

00:13:59,890 --> 00:14:04,730
fundamentally weird there's no other

00:14:02,420 --> 00:14:09,410
machines that aren't computers that you

00:14:04,730 --> 00:14:11,000
interact with that can do this so often

00:14:09,410 --> 00:14:13,040
when we teach we like to teach with

00:14:11,000 --> 00:14:15,560
metaphors and the core idea behind

00:14:13,040 --> 00:14:17,720
tracing is to simulate the machine in

00:14:15,560 --> 00:14:19,580
our heads the computer machine the

00:14:17,720 --> 00:14:21,440
Python machine at the simplest level

00:14:19,580 --> 00:14:24,230
computers are machines that perform

00:14:21,440 --> 00:14:26,840
instructions one by one and so we often

00:14:24,230 --> 00:14:29,930
use a metaphor like this which is a

00:14:26,840 --> 00:14:32,000
recipe and a recipe if you mess up the

00:14:29,930 --> 00:14:34,100
letter the order of instructions then

00:14:32,000 --> 00:14:36,530
the recipe doesn't work if you whisk the

00:14:34,100 --> 00:14:38,180
jug before you put the eggs in the

00:14:36,530 --> 00:14:43,310
recipe is not going to come out the way

00:14:38,180 --> 00:14:45,080
you expected but so an instruction is a

00:14:43,310 --> 00:14:48,500
single operation performed by a computer

00:14:45,080 --> 00:14:52,040
but a computer is quite different to a

00:14:48,500 --> 00:14:53,750
recipe computers aren't pancakes and if

00:14:52,040 --> 00:14:56,600
you compare them there's a big

00:14:53,750 --> 00:14:59,120
difference at the end of a recipe you

00:14:56,600 --> 00:15:00,710
always get the same thing but at the end

00:14:59,120 --> 00:15:02,540
of a computer program you can get a

00:15:00,710 --> 00:15:05,300
different thing depending on what the

00:15:02,540 --> 00:15:08,300
input was and so here's a metaphor

00:15:05,300 --> 00:15:11,180
that's similar but uses variables the

00:15:08,300 --> 00:15:14,750
first step is to ask how many people are

00:15:11,180 --> 00:15:17,990
we serving pancakes too then we crack n

00:15:14,750 --> 00:15:20,360
serves of eggs into a jug then pour n

00:15:17,990 --> 00:15:23,930
serves of cups of milk into a jug and

00:15:20,360 --> 00:15:26,240
with this example suddenly we're making

00:15:23,930 --> 00:15:29,120
a recipe that can solve all of your

00:15:26,240 --> 00:15:32,360
pancake problems not just one pancake

00:15:29,120 --> 00:15:35,520
problem and this is much more like a

00:15:32,360 --> 00:15:39,090
computer it could make

00:15:35,520 --> 00:15:41,900
for one person or a hundred people the

00:15:39,090 --> 00:15:44,070
big difference is state and state is

00:15:41,900 --> 00:15:46,620
more formally the context that

00:15:44,070 --> 00:15:51,390
computation runs in usually state means

00:15:46,620 --> 00:15:54,240
variables so if we have instructions and

00:15:51,390 --> 00:15:57,630
state do we know all about computation

00:15:54,240 --> 00:15:59,280
is this the only model we need not quite

00:15:57,630 --> 00:16:01,500
but these two things they're quite

00:15:59,280 --> 00:16:04,890
important so let's look at a more

00:16:01,500 --> 00:16:07,140
complete model so this is how you might

00:16:04,890 --> 00:16:09,720
model computation as a student who is

00:16:07,140 --> 00:16:11,160
tracing this is an ideal model and

00:16:09,720 --> 00:16:14,100
probably not the model that your

00:16:11,160 --> 00:16:16,710
students have so we have code that the

00:16:14,100 --> 00:16:18,810
student has written and this part is

00:16:16,710 --> 00:16:20,640
separate to what is actually running

00:16:18,810 --> 00:16:23,130
this is the code they've written not the

00:16:20,640 --> 00:16:24,900
code that's running and it goes into the

00:16:23,130 --> 00:16:27,690
machine the machine is something like

00:16:24,900 --> 00:16:30,900
Python an interpreter that runs the code

00:16:27,690 --> 00:16:32,970
this part the machine is humongous and

00:16:30,900 --> 00:16:35,490
it represents everything that Python can

00:16:32,970 --> 00:16:38,640
do and if you imagine that machine that

00:16:35,490 --> 00:16:41,940
little block is huge it's like a TARDIS

00:16:38,640 --> 00:16:44,070
inside is all of Python and the Machine

00:16:41,940 --> 00:16:45,930
interacts with state this is the

00:16:44,070 --> 00:16:49,200
invisible stuff that's stored in memory

00:16:45,930 --> 00:16:52,170
and when the machine interacts with

00:16:49,200 --> 00:16:54,660
state then we get dynamic behavior the

00:16:52,170 --> 00:16:58,050
machine takes in input which the user

00:16:54,660 --> 00:17:01,290
has given it like our example with

00:16:58,050 --> 00:17:05,700
variables and it creates output like

00:17:01,290 --> 00:17:07,830
hello Nicky all of this together is in

00:17:05,700 --> 00:17:11,220
the literature called program dynamics

00:17:07,830 --> 00:17:13,560
this is how code input state and the

00:17:11,220 --> 00:17:17,220
Machine interact to create complex

00:17:13,560 --> 00:17:19,860
dynamic behavior program dynamics is a

00:17:17,220 --> 00:17:21,690
threshold concept which is a fancy way

00:17:19,860 --> 00:17:24,839
of saying that it changes the way you

00:17:21,690 --> 00:17:26,820
think once students understand program

00:17:24,839 --> 00:17:29,160
dynamics once they have this model in

00:17:26,820 --> 00:17:30,960
their head they can't imagine how they

00:17:29,160 --> 00:17:33,270
thought computers worked before that and

00:17:30,960 --> 00:17:35,250
if you have a good model of program

00:17:33,270 --> 00:17:39,600
dynamics in your head you may struggle

00:17:35,250 --> 00:17:45,090
to see how students misunderstand their

00:17:39,600 --> 00:17:47,940
own code when we're tracing students

00:17:45,090 --> 00:17:49,340
have to run this quite complex model in

00:17:47,940 --> 00:17:52,440
their head

00:17:49,340 --> 00:17:54,779
no wonder it's so hard if students have

00:17:52,440 --> 00:17:57,210
to model code going into a machine the

00:17:54,779 --> 00:17:59,340
machine executing that code the machine

00:17:57,210 --> 00:18:01,649
modifying state and variables it

00:17:59,340 --> 00:18:03,720
receiving input we're going to need a

00:18:01,649 --> 00:18:05,549
lot of help to get those students are

00:18:03,720 --> 00:18:09,960
able to do that and able to trace as

00:18:05,549 --> 00:18:12,869
experts and not just as novices so I've

00:18:09,960 --> 00:18:16,590
got some practical tips to help students

00:18:12,869 --> 00:18:19,379
develop their skills in tracing so first

00:18:16,590 --> 00:18:21,299
off we want to encourage doodling and

00:18:19,379 --> 00:18:23,850
sketching so this is the same kind of

00:18:21,299 --> 00:18:26,159
thing that I did in my diagram you want

00:18:23,850 --> 00:18:28,049
to get them to do on paper and this is a

00:18:26,159 --> 00:18:30,239
great way to get students out of their

00:18:28,049 --> 00:18:33,210
head and it's very easy to make mistakes

00:18:30,239 --> 00:18:34,230
in your head and and then not realize

00:18:33,210 --> 00:18:35,879
you've made a mistake

00:18:34,230 --> 00:18:38,340
people are quite confident about their

00:18:35,879 --> 00:18:41,129
mental capabilities but when they're

00:18:38,340 --> 00:18:43,590
exposed on paper suddenly they realize

00:18:41,129 --> 00:18:45,899
they were making mistakes and my other

00:18:43,590 --> 00:18:48,029
example is tracing diagrams and this is

00:18:45,899 --> 00:18:50,700
more just a formal version of sketching

00:18:48,029 --> 00:18:52,710
similar to how I did my diagram was much

00:18:50,700 --> 00:18:55,639
more structured but a student can just

00:18:52,710 --> 00:18:59,519
do it with a pen and paper

00:18:55,639 --> 00:19:01,799
another thing is doing tracing exercises

00:18:59,519 --> 00:19:03,659
so something I often do with students

00:19:01,799 --> 00:19:06,269
who are struggling with a program is I

00:19:03,659 --> 00:19:08,190
get them to say out loud to me every

00:19:06,269 --> 00:19:11,580
step that they think their program goes

00:19:08,190 --> 00:19:13,859
through so if they read it out like we

00:19:11,580 --> 00:19:15,929
did with our tracing I can see into

00:19:13,859 --> 00:19:17,940
their head and see what they think the

00:19:15,929 --> 00:19:19,230
computer is doing which is quite

00:19:17,940 --> 00:19:20,970
important because if they have a

00:19:19,230 --> 00:19:23,580
misconception I need to be able to

00:19:20,970 --> 00:19:25,830
identify that the other thing is having

00:19:23,580 --> 00:19:29,580
written tracing exercises these are

00:19:25,830 --> 00:19:31,039
common in exams at university but it

00:19:29,580 --> 00:19:34,649
doesn't have to necessarily be a

00:19:31,039 --> 00:19:37,320
university level difficult problem being

00:19:34,649 --> 00:19:40,379
able to read through some code and come

00:19:37,320 --> 00:19:44,429
up with what the output is is a really

00:19:40,379 --> 00:19:47,009
important skill debugging also typically

00:19:44,429 --> 00:19:49,739
involves tracing so debugging code is a

00:19:47,009 --> 00:19:51,720
great way to practice tracing it also

00:19:49,739 --> 00:19:53,909
means that you need to challenge the way

00:19:51,720 --> 00:19:56,450
you think a program runs if you give

00:19:53,909 --> 00:19:59,099
students some code with a subtle bug

00:19:56,450 --> 00:20:01,619
they then have to trace through it and

00:19:59,099 --> 00:20:02,909
find that subtle bug and challenge their

00:20:01,619 --> 00:20:06,779
own preconceptions

00:20:02,909 --> 00:20:09,840
about how the code works another tip is

00:20:06,779 --> 00:20:11,609
using explicit instruction and and this

00:20:09,840 --> 00:20:13,859
is kind of what I've been alluding to

00:20:11,609 --> 00:20:15,599
with these models of computation if we

00:20:13,859 --> 00:20:17,789
teach students a model of computation

00:20:15,599 --> 00:20:20,070
and it doesn't necessarily have to be a

00:20:17,789 --> 00:20:21,779
complete model of computation it can be

00:20:20,070 --> 00:20:24,869
something that we slowly build up over

00:20:21,779 --> 00:20:27,389
time they can use this model of

00:20:24,869 --> 00:20:30,539
computation when they're simulating how

00:20:27,389 --> 00:20:32,460
code works in their head um we can also

00:20:30,539 --> 00:20:35,970
teach them by doing tracing

00:20:32,460 --> 00:20:38,190
demonstrations like I did if you run

00:20:35,970 --> 00:20:43,489
through code on the board that will help

00:20:38,190 --> 00:20:46,440
to scaffold students own ways of tracing

00:20:43,489 --> 00:20:48,570
the final thing I've got here is common

00:20:46,440 --> 00:20:50,249
structures and this is a bit difficult

00:20:48,570 --> 00:20:53,159
we could probably have another whole

00:20:50,249 --> 00:20:56,609
talk about this but things like using a

00:20:53,159 --> 00:20:59,519
variable to accumulate or using indexing

00:20:56,609 --> 00:21:01,739
or having a minimum value that you

00:20:59,519 --> 00:21:05,039
retrieve from a list these are patterns

00:21:01,739 --> 00:21:06,779
that were using code often that students

00:21:05,039 --> 00:21:09,029
don't necessarily know about and by

00:21:06,779 --> 00:21:11,489
teaching them explicitly about these

00:21:09,029 --> 00:21:13,739
common structures they can then kind of

00:21:11,489 --> 00:21:16,200
abstract away a little bit and say ah

00:21:13,739 --> 00:21:18,509
this is a case where we're using a loop

00:21:16,200 --> 00:21:22,399
to accumulate this is a case where we're

00:21:18,509 --> 00:21:25,019
using a loop to find the maximum value

00:21:22,399 --> 00:21:27,929
so students are going to have a lot of

00:21:25,019 --> 00:21:29,940
issues when they go through and learn to

00:21:27,929 --> 00:21:32,479
trace and one of the biggest issues as

00:21:29,940 --> 00:21:36,690
I've kind of spoken about before is

00:21:32,479 --> 00:21:39,059
reading in English students are familiar

00:21:36,690 --> 00:21:41,789
with English and fortunately but

00:21:39,059 --> 00:21:44,879
unfortunately Python reads like English

00:21:41,789 --> 00:21:46,830
and if students read Python as English

00:21:44,879 --> 00:21:48,869
they're going to come up with some

00:21:46,830 --> 00:21:52,200
really strange ideas about how their

00:21:48,869 --> 00:21:55,200
code works and this can be a really big

00:21:52,200 --> 00:21:58,470
issue with students one of the most

00:21:55,200 --> 00:22:01,379
common scenarios I see is students using

00:21:58,470 --> 00:22:03,629
or and in in Python in ways that don't

00:22:01,379 --> 00:22:07,139
quite make sense because they're used to

00:22:03,629 --> 00:22:09,479
using those in English formally tracing

00:22:07,139 --> 00:22:12,739
can help break their habit of reading in

00:22:09,479 --> 00:22:16,120
English one of the other things that

00:22:12,739 --> 00:22:18,760
students do which we all do is

00:22:16,120 --> 00:22:21,820
coming up with a theory and then proving

00:22:18,760 --> 00:22:24,040
its correct rather than questioning the

00:22:21,820 --> 00:22:26,230
theory and this can be a big problem

00:22:24,040 --> 00:22:28,660
when tracing code you need to make sure

00:22:26,230 --> 00:22:31,180
that students are questioning themselves

00:22:28,660 --> 00:22:33,670
and their own interpretations of how the

00:22:31,180 --> 00:22:36,280
code works and part of this can be

00:22:33,670 --> 00:22:37,410
jumping into Python and running the line

00:22:36,280 --> 00:22:39,400
of code

00:22:37,410 --> 00:22:43,780
subbing in the values that they think

00:22:39,400 --> 00:22:45,520
and then running it the final thing that

00:22:43,780 --> 00:22:48,700
they'll do when misinterpreting is

00:22:45,520 --> 00:22:50,920
skipping steps and this is a thing that

00:22:48,700 --> 00:22:53,380
we all do we think oh I understand it

00:22:50,920 --> 00:22:55,000
and then skip straight over that bit and

00:22:53,380 --> 00:22:58,030
then inevitably the bug is in the bit

00:22:55,000 --> 00:23:02,260
you skipped so they need to trace every

00:22:58,030 --> 00:23:05,100
single bit cognitive load comes into

00:23:02,260 --> 00:23:08,110
tracing quite heavily and quite quickly

00:23:05,100 --> 00:23:10,660
really the reason that students are

00:23:08,110 --> 00:23:12,700
tracing poorly is that they're not able

00:23:10,660 --> 00:23:15,690
to keep all that stuff in their head and

00:23:12,700 --> 00:23:18,970
this is why I talked about sketching

00:23:15,690 --> 00:23:22,300
sketching is an external representation

00:23:18,970 --> 00:23:24,250
that hopes students get their work out

00:23:22,300 --> 00:23:26,410
of their head and onto paper so they're

00:23:24,250 --> 00:23:28,660
not using their working memory to go

00:23:26,410 --> 00:23:31,360
through and solve problems they're using

00:23:28,660 --> 00:23:34,150
the paper to do it hitting cognitive

00:23:31,360 --> 00:23:37,090
load limit it causes students to make

00:23:34,150 --> 00:23:40,210
really silly mistakes a really common

00:23:37,090 --> 00:23:43,360
one is to think that all the variables

00:23:40,210 --> 00:23:46,240
are the same value and this can result

00:23:43,360 --> 00:23:47,950
in some really strange behavior and this

00:23:46,240 --> 00:23:50,560
is because the students just don't quite

00:23:47,950 --> 00:23:52,900
have space in their working memory to

00:23:50,560 --> 00:23:57,280
store what the code is doing as well as

00:23:52,900 --> 00:23:59,500
all the variables the other thing is

00:23:57,280 --> 00:24:01,720
that students will become very focused

00:23:59,500 --> 00:24:05,020
and this is similar to skipping but it's

00:24:01,720 --> 00:24:07,240
a bit more about the fact that they

00:24:05,020 --> 00:24:09,700
can't keep all of the code in their head

00:24:07,240 --> 00:24:11,560
at once they'll focus on a certain area

00:24:09,700 --> 00:24:13,510
that they've hypothesized is the

00:24:11,560 --> 00:24:15,370
problematic area or the important area

00:24:13,510 --> 00:24:18,160
and they won't think about how the

00:24:15,370 --> 00:24:19,000
surrounding area of the code may change

00:24:18,160 --> 00:24:21,010
its behavior

00:24:19,000 --> 00:24:22,810
for example the state may not be what

00:24:21,010 --> 00:24:28,840
they think it is when it comes in to

00:24:22,810 --> 00:24:29,410
that area so let's review over what I've

00:24:28,840 --> 00:24:33,370
talked

00:24:29,410 --> 00:24:35,770
about so far tracing is simulating the

00:24:33,370 --> 00:24:40,630
execution of your code to see how it

00:24:35,770 --> 00:24:43,180
works when we're tracing students will

00:24:40,630 --> 00:24:45,070
have a model of computation in their

00:24:43,180 --> 00:24:48,280
head ideally we want them to have

00:24:45,070 --> 00:24:50,860
something like this but it's okay to

00:24:48,280 --> 00:24:52,960
scaffold it and build it up over time so

00:24:50,860 --> 00:24:55,900
that they start off with say just steps

00:24:52,960 --> 00:24:58,300
that happen in order then they add State

00:24:55,900 --> 00:25:02,670
and then they start to add more and more

00:24:58,300 --> 00:25:06,100
parts to this model we can help students

00:25:02,670 --> 00:25:09,610
in the classroom by using things like

00:25:06,100 --> 00:25:12,670
doodling and diagrams we can do tracing

00:25:09,610 --> 00:25:14,620
and debugging exercises and we can teach

00:25:12,670 --> 00:25:17,560
them explicitly models of computation

00:25:14,620 --> 00:25:20,260
and most importantly what we want our

00:25:17,560 --> 00:25:23,530
students to do is run Python on their

00:25:20,260 --> 00:25:26,770
brain computers it seems like I have

00:25:23,530 --> 00:25:31,090
time for questions so if anyone has any

00:25:26,770 --> 00:25:33,780
questions Nicki will be moving thank you

00:25:31,090 --> 00:25:33,780
very much

00:25:38,650 --> 00:25:44,750
questions surprise questions surprise

00:25:41,960 --> 00:25:56,870
questions for Ben surprise questions for

00:25:44,750 --> 00:25:58,400
all of us I'm not being 100% serious but

00:25:56,870 --> 00:26:00,140
now I'm tempted to ask is there one of

00:25:58,400 --> 00:26:02,090
those URLs I can just point students to

00:26:00,140 --> 00:26:03,590
when I'm tutoring say just go and read

00:26:02,090 --> 00:26:09,770
this computational model and then come

00:26:03,590 --> 00:26:12,080
back I would like to have some stuff in

00:26:09,770 --> 00:26:14,299
grok that supports students to build up

00:26:12,080 --> 00:26:16,370
their tracing we don't really have

00:26:14,299 --> 00:26:17,480
anything like that but if you have a

00:26:16,370 --> 00:26:21,830
look there's a website called Python

00:26:17,480 --> 00:26:23,600
shooter which has a you can paste in

00:26:21,830 --> 00:26:29,120
some code run it and it will output

00:26:23,600 --> 00:26:31,460
something like my tracing diagrams has

00:26:29,120 --> 00:26:33,770
there been any Studies on the best

00:26:31,460 --> 00:26:35,000
tracing techniques and which ones work

00:26:33,770 --> 00:26:38,230
well and which ones don't

00:26:35,000 --> 00:26:42,500
so there's a little bit of literature on

00:26:38,230 --> 00:26:44,809
sketching types so the one that I used

00:26:42,500 --> 00:26:47,049
where we cross out values and move on to

00:26:44,809 --> 00:26:49,220
the next value that's quite useful

00:26:47,049 --> 00:26:52,210
there's also a version which is kind of

00:26:49,220 --> 00:26:55,429
a bit more rotated where you have

00:26:52,210 --> 00:26:57,320
variables in columns and you put the new

00:26:55,429 --> 00:26:59,690
variable down but mostly it's about

00:26:57,320 --> 00:27:01,730
making sure that the old value is

00:26:59,690 --> 00:27:04,190
crossed out and the new value is written

00:27:01,730 --> 00:27:07,520
there and that's kind of the theme of

00:27:04,190 --> 00:27:09,260
what is more effective if you talk to me

00:27:07,520 --> 00:27:13,400
after I can point you at some some of

00:27:09,260 --> 00:27:15,530
the literature yeah similarly are there

00:27:13,400 --> 00:27:17,210
any websites that have tracing

00:27:15,530 --> 00:27:20,200
challenges that you can sort of direct

00:27:17,210 --> 00:27:22,539
people to or challenge yourself on I

00:27:20,200 --> 00:27:25,400
don't know any off the top of my head

00:27:22,539 --> 00:27:28,340
but maybe Python shooter is a good place

00:27:25,400 --> 00:27:32,900
to start the Python shooter has some

00:27:28,340 --> 00:27:35,240
stuff on tracing yeah have you

00:27:32,900 --> 00:27:37,400
encountered any sort of difficulties

00:27:35,240 --> 00:27:39,140
when people are thinking of things in a

00:27:37,400 --> 00:27:41,990
sort of more declarative rather than

00:27:39,140 --> 00:27:45,220
imperative matter or vice-versa when

00:27:41,990 --> 00:27:48,260
teaching so you mean that they're

00:27:45,220 --> 00:27:50,040
imagining the computer can kind of

00:27:48,260 --> 00:27:51,360
understand them a bit more or

00:27:50,040 --> 00:27:54,270
what do you mean specifically by

00:27:51,360 --> 00:27:55,650
declarative as in yes in people assuming

00:27:54,270 --> 00:27:57,420
that when they're coding something in

00:27:55,650 --> 00:27:58,230
Python that it's more declarative than

00:27:57,420 --> 00:28:01,170
it actually is

00:27:58,230 --> 00:28:03,120
so as in a when you declare the value of

00:28:01,170 --> 00:28:04,500
something it never changes or so I'm not

00:28:03,120 --> 00:28:07,110
quite sure can you give me an example

00:28:04,500 --> 00:28:09,380
well actually that's the sort of thing

00:28:07,110 --> 00:28:11,790
that yeah I'm super getting it yeah so

00:28:09,380 --> 00:28:15,060
assuming that a value cannot change over

00:28:11,790 --> 00:28:18,330
time is that what you mean yeah or that

00:28:15,060 --> 00:28:19,830
the structure of the computation itself

00:28:18,330 --> 00:28:22,410
is something that the computer comes up

00:28:19,830 --> 00:28:27,750
with for you right I say like SQL would

00:28:22,410 --> 00:28:29,780
yeah yeah okay yeah so this is this is

00:28:27,750 --> 00:28:33,030
kind of related there's a term often

00:28:29,780 --> 00:28:35,190
called the super bug which is the

00:28:33,030 --> 00:28:39,090
student imagining that the computer

00:28:35,190 --> 00:28:41,010
knows more than it does and really this

00:28:39,090 --> 00:28:44,670
is an issue with students not quite

00:28:41,010 --> 00:28:47,840
having a model of computation and and

00:28:44,670 --> 00:28:49,890
I've encountered it in various forms and

00:28:47,840 --> 00:28:52,200
specifically it's the imperative model

00:28:49,890 --> 00:28:54,480
of computation and we can bootstrap this

00:28:52,200 --> 00:28:57,380
by helping them to learn about how the

00:28:54,480 --> 00:29:00,120
program runs through each step and

00:28:57,380 --> 00:29:02,130
getting them to trace really is is the

00:29:00,120 --> 00:29:05,070
solution is helping them understand that

00:29:02,130 --> 00:29:07,230
the computer really is that dumb and it

00:29:05,070 --> 00:29:11,940
really only does exactly what you tell

00:29:07,230 --> 00:29:13,410
her to do yeah yep so do you think like

00:29:11,940 --> 00:29:15,690
obviously a debugger can do all this

00:29:13,410 --> 00:29:17,910
tracing thing yes so do you think

00:29:15,690 --> 00:29:19,860
showing students a debugger early would

00:29:17,910 --> 00:29:22,890
help them because they can see what's

00:29:19,860 --> 00:29:24,020
going on or harm them because they don't

00:29:22,890 --> 00:29:28,080
get the opportunity to do it themselves

00:29:24,020 --> 00:29:30,060
yeah that's a good question I think that

00:29:28,080 --> 00:29:32,610
you probably need to have at least some

00:29:30,060 --> 00:29:33,960
practice tracing code before you use it

00:29:32,610 --> 00:29:37,080
a bugger the other thing with the

00:29:33,960 --> 00:29:41,940
debugger is that they can be quite

00:29:37,080 --> 00:29:43,800
complex to use so I would say it's going

00:29:41,940 --> 00:29:45,810
to depend on the student and I don't

00:29:43,800 --> 00:29:49,050
really know off the top of my head what

00:29:45,810 --> 00:29:50,550
order is more important there along the

00:29:49,050 --> 00:29:53,130
same lines have you thought about

00:29:50,550 --> 00:29:56,340
putting that type of debugger instagrok

00:29:53,130 --> 00:29:58,680
learning so tracings yeah so what we do

00:29:56,340 --> 00:30:01,050
have is not many people use it and I've

00:29:58,680 --> 00:30:02,880
been meaning to write a blog post on

00:30:01,050 --> 00:30:03,760
this for ages is we have a terminal

00:30:02,880 --> 00:30:04,960
button and

00:30:03,760 --> 00:30:07,750
when you press the terminal button it

00:30:04,960 --> 00:30:09,700
will run your code and then right at the

00:30:07,750 --> 00:30:11,920
very end it will dump you into our

00:30:09,700 --> 00:30:13,330
Python interpreter so it doesn't quite

00:30:11,920 --> 00:30:15,250
do the same thing it doesn't allow you

00:30:13,330 --> 00:30:17,620
to trace so you can't step through each

00:30:15,250 --> 00:30:19,780
line of execution but it does get you to

00:30:17,620 --> 00:30:21,370
a point where you have the full state of

00:30:19,780 --> 00:30:23,500
the program and you can then go and

00:30:21,370 --> 00:30:25,240
inspect it so you can type in a variable

00:30:23,500 --> 00:30:28,060
and press ENTER and you see the variable

00:30:25,240 --> 00:30:30,520
the value of the variable but yeah I

00:30:28,060 --> 00:30:33,970
would love to have some more scaffolding

00:30:30,520 --> 00:30:36,670
for tracing is there any monarchy there

00:30:33,970 --> 00:30:40,330
is but we're out of time cool

00:30:36,670 --> 00:30:44,680
but Ben will be around in the various

00:30:40,330 --> 00:30:48,130
breaks for more questions yeah and thank

00:30:44,680 --> 00:30:50,440
you very much for speaking I keep

00:30:48,130 --> 00:30:53,850
forgetting I do like this this thing

00:30:50,440 --> 00:30:53,850
where I get to mug people yes

00:30:54,340 --> 00:31:00,330

YouTube URL: https://www.youtube.com/watch?v=3elWlN0MzGw


