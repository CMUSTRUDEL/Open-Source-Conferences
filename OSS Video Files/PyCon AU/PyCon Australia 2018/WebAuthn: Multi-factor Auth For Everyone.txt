Title: WebAuthn: Multi-factor Auth For Everyone
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Benno Rice

https://2018.pycon-au.org/talks/44258-webauthn-multifactor-auth-for-everyone/

Everybody knows that passwords suck. Implementing better things, like multi-factor authentication, can be really tricky and require a bunch of specialist bits though.

Or does it?

The new WebAuthn standard makes it dead simple to add multi-factor authentication to your web app. Let's find out how!

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,210 --> 00:00:05,970
welcome back everyone this is our last

00:00:03,540 --> 00:00:08,580
talk before the panel and then if you

00:00:05,970 --> 00:00:10,290
wanted to ask any more questions sorry

00:00:08,580 --> 00:00:14,630
too late we've already closed and taken

00:00:10,290 --> 00:00:14,630
all the ones we're gonna ask so too bad

00:00:15,080 --> 00:00:19,980
Bono has done a whole bunch of things

00:00:17,400 --> 00:00:22,529
but he's also one of the members of the

00:00:19,980 --> 00:00:25,800
FreeBSD core team and went through all

00:00:22,529 --> 00:00:27,210
the effort was oh sorry and went through

00:00:25,800 --> 00:00:29,539
the effort of transferring it to the

00:00:27,210 --> 00:00:32,420
power sorry porting it to the PowerPC

00:00:29,539 --> 00:00:35,040
now he's gonna give us a rundown on

00:00:32,420 --> 00:00:39,899
where both end which should be pretty

00:00:35,040 --> 00:00:41,730
interesting thank you hi yes so as you

00:00:39,899 --> 00:00:44,040
can tell porting FreeBSD the PowerPC has

00:00:41,730 --> 00:00:47,550
everything to do with authentication on

00:00:44,040 --> 00:00:49,680
the web before I get started I'd also

00:00:47,550 --> 00:00:51,120
like to thank the federal Liberal Party

00:00:49,680 --> 00:00:53,750
for getting all of their honest out of

00:00:51,120 --> 00:00:58,109
the way so I can actually focus on this

00:00:53,750 --> 00:01:00,660
so authentication is fun as everyone

00:00:58,109 --> 00:01:02,250
knows for most people you know for a

00:01:00,660 --> 00:01:06,030
long time passwords have been the way

00:01:02,250 --> 00:01:07,619
we've done authentication passwords are

00:01:06,030 --> 00:01:09,960
a type of authentication factor that

00:01:07,619 --> 00:01:11,909
people describe as a shared secret I

00:01:09,960 --> 00:01:13,770
know it you know it if I can prove to

00:01:11,909 --> 00:01:16,430
you that I know it then you let me do

00:01:13,770 --> 00:01:20,790
stuff and that's all well and good but

00:01:16,430 --> 00:01:22,650
passwords can have problems it's

00:01:20,790 --> 00:01:24,299
generally falls over when someone else

00:01:22,650 --> 00:01:25,890
gets ahold of the secret that's been

00:01:24,299 --> 00:01:30,390
shared and so then they can pretend to

00:01:25,890 --> 00:01:32,310
be you or some security research manages

00:01:30,390 --> 00:01:33,630
to get in and dump the auth database and

00:01:32,310 --> 00:01:35,250
then you find out they weren't hashing

00:01:33,630 --> 00:01:37,170
things or you find that they weren't

00:01:35,250 --> 00:01:40,759
doing it very well and suddenly you're a

00:01:37,170 --> 00:01:45,479
statistic on have I being pwned com

00:01:40,759 --> 00:01:47,820
so how do we do better than passwords so

00:01:45,479 --> 00:01:48,659
the obvious solution that people tend to

00:01:47,820 --> 00:01:50,280
come up with is multi-factor

00:01:48,659 --> 00:01:51,960
authentication which is where you

00:01:50,280 --> 00:01:53,549
combine multiple factors together so

00:01:51,960 --> 00:01:56,520
we've described one part one factor

00:01:53,549 --> 00:01:58,229
being a shared secret other factors that

00:01:56,520 --> 00:02:00,840
have been used in the past the things

00:01:58,229 --> 00:02:02,820
like hilarious a key fob you know six

00:02:00,840 --> 00:02:04,020
digits type it in then you lose it and

00:02:02,820 --> 00:02:05,759
have to get another one or the battery

00:02:04,020 --> 00:02:08,789
Brett whatever

00:02:05,759 --> 00:02:11,510
there's also biometrics fingerprints

00:02:08,789 --> 00:02:13,860
face facial scans all that kind of stuff

00:02:11,510 --> 00:02:16,620
a whole bunch of other form

00:02:13,860 --> 00:02:18,420
of one-time keys so the RSA key fob is a

00:02:16,620 --> 00:02:21,900
form of time-based one-time key you've

00:02:18,420 --> 00:02:26,070
also got the TOTP type keys that you use

00:02:21,900 --> 00:02:29,130
with Google Authenticator and you can

00:02:26,070 --> 00:02:34,950
use SMS two-factor authentication or you

00:02:29,130 --> 00:02:37,020
could not so but one other form that is

00:02:34,950 --> 00:02:40,290
kind of useful is forms like public key

00:02:37,020 --> 00:02:41,550
cryptography probably the most common

00:02:40,290 --> 00:02:46,110
ones that you do socio with these are

00:02:41,550 --> 00:02:47,550
things like SSH keys or some kinds of

00:02:46,110 --> 00:02:50,130
public key certificate certificate

00:02:47,550 --> 00:02:52,320
authentication like ssl certificates you

00:02:50,130 --> 00:02:53,970
create a public/private key pair you

00:02:52,320 --> 00:02:56,580
give the public part out to the public

00:02:53,970 --> 00:02:58,680
you keep the private key and that way

00:02:56,580 --> 00:03:00,000
you can prove that you have the thing

00:02:58,680 --> 00:03:02,280
that proves that you are who you say you

00:03:00,000 --> 00:03:06,720
are without having to let go of the

00:03:02,280 --> 00:03:08,310
secret part in theory and the nicest the

00:03:06,720 --> 00:03:10,200
nicest thing about public key ones is

00:03:08,310 --> 00:03:12,810
that in a lot of cases they can replace

00:03:10,200 --> 00:03:14,610
passwords you don't need to have you

00:03:12,810 --> 00:03:15,750
necessarily need to have a second factor

00:03:14,610 --> 00:03:18,080
in there unless you want to be well

00:03:15,750 --> 00:03:22,170
depending on how paranoid you want to be

00:03:18,080 --> 00:03:23,459
but how do you do this especially how do

00:03:22,170 --> 00:03:26,640
you do this in the context of something

00:03:23,459 --> 00:03:28,140
like a web application integrating extra

00:03:26,640 --> 00:03:31,530
factors into web applications has always

00:03:28,140 --> 00:03:33,660
been somewhat of a problem RSA tokens

00:03:31,530 --> 00:03:35,400
you need to go by RSA's validation gear

00:03:33,660 --> 00:03:36,840
you need to buy all the tokens need to

00:03:35,400 --> 00:03:39,540
ship them out you need one token per

00:03:36,840 --> 00:03:42,930
service which is a pain so on so forth

00:03:39,540 --> 00:03:47,010
you could use SMS second factor or you

00:03:42,930 --> 00:03:48,209
could not the problem with SMS to fact

00:03:47,010 --> 00:03:49,799
of this fight the fact that there are

00:03:48,209 --> 00:03:51,120
sort of underlying issues with you know

00:03:49,799 --> 00:03:52,230
people stealing your phone number if

00:03:51,120 --> 00:03:54,540
they decide that they want to break into

00:03:52,230 --> 00:03:56,250
your site is that you still have to send

00:03:54,540 --> 00:03:57,840
all the SMS is and all that that costs

00:03:56,250 --> 00:03:59,310
money you probably infrastructure work

00:03:57,840 --> 00:04:02,130
for that kind of thing

00:03:59,310 --> 00:04:03,540
time-based one-time passwords totp type

00:04:02,130 --> 00:04:05,250
ones are great except that the problem

00:04:03,540 --> 00:04:06,750
is that with you know if you're the

00:04:05,250 --> 00:04:09,360
sensible person use a password manager

00:04:06,750 --> 00:04:10,320
that password manager often also offers

00:04:09,360 --> 00:04:12,269
to store the time-based one-time

00:04:10,320 --> 00:04:14,489
password stuff for you which means that

00:04:12,269 --> 00:04:15,989
both your password and the hashes needed

00:04:14,489 --> 00:04:20,720
to generate the one-time password are in

00:04:15,989 --> 00:04:20,720
the same place that's not as good

00:04:20,750 --> 00:04:25,110
deploying hardware tokens as second

00:04:23,070 --> 00:04:27,270
factors would be really nice except that

00:04:25,110 --> 00:04:27,730
until now they're really the only way to

00:04:27,270 --> 00:04:29,440
do that

00:04:27,730 --> 00:04:30,610
been through things like u2f in crime

00:04:29,440 --> 00:04:36,220
which was the only browser that

00:04:30,610 --> 00:04:39,640
supported u2f speaking of you to F so

00:04:36,220 --> 00:04:41,230
the phyto Alliance came out of some work

00:04:39,640 --> 00:04:45,430
that started between yubico and Google

00:04:41,230 --> 00:04:48,700
in about 2011 and u2f is the universal

00:04:45,430 --> 00:04:50,170
second factor protocol it was designed

00:04:48,700 --> 00:04:51,640
to try and make it easier to integrate

00:04:50,170 --> 00:04:54,430
this kind of stuff the problem was that

00:04:51,640 --> 00:04:58,360
it just didn't really take off Fido owns

00:04:54,430 --> 00:04:59,920
this u 2f spec Fido also owns a bunch of

00:04:58,360 --> 00:05:01,690
other specifications which is why I

00:04:59,920 --> 00:05:07,240
wanted to talk about this stuff that I'm

00:05:01,690 --> 00:05:09,490
talking about today so Fido 2 is a

00:05:07,240 --> 00:05:12,400
combination of two of a couple of other

00:05:09,490 --> 00:05:14,590
protocols one of which is C tap or the

00:05:12,400 --> 00:05:16,570
client to authenticate a protocol this

00:05:14,590 --> 00:05:19,870
is the protocol that already exists that

00:05:16,570 --> 00:05:22,120
u2f uses to talk between a browser and a

00:05:19,870 --> 00:05:25,120
hardware authentication token the other

00:05:22,120 --> 00:05:27,490
one is w3c spec called web or thin and

00:05:25,120 --> 00:05:30,700
what web or thin does is define a common

00:05:27,490 --> 00:05:35,680
API for browsers to talk to auth

00:05:30,700 --> 00:05:37,780
indicators that web apps can leverage so

00:05:35,680 --> 00:05:45,510
a quick demo of what web or thin looks

00:05:37,780 --> 00:05:47,800
like wrong direction that one so this is

00:05:45,510 --> 00:05:50,260
this is a demo application you can

00:05:47,800 --> 00:05:53,560
actually get from the from you because

00:05:50,260 --> 00:05:54,970
Python Fido to library you'll notice

00:05:53,560 --> 00:05:56,680
that I have two available actions here

00:05:54,970 --> 00:05:58,870
registering and authenticating if I'd

00:05:56,680 --> 00:06:01,870
attempt to authenticate it will tell me

00:05:58,870 --> 00:06:03,010
that my connection is not safe it'll

00:06:01,870 --> 00:06:04,000
tell me that there is no credential

00:06:03,010 --> 00:06:05,140
available to authenticate because I

00:06:04,000 --> 00:06:08,860
haven't registered any yet

00:06:05,140 --> 00:06:10,600
I can register one my what you can't see

00:06:08,860 --> 00:06:12,300
is that my yubikey which is in the side

00:06:10,600 --> 00:06:14,500
of my laptop has started blinking

00:06:12,300 --> 00:06:16,720
because part of the important part here

00:06:14,500 --> 00:06:17,700
is that there is user interaction to

00:06:16,720 --> 00:06:21,910
make sure that you're not being

00:06:17,700 --> 00:06:23,140
automatically played with and you

00:06:21,910 --> 00:06:26,650
probably can't read that but it says the

00:06:23,140 --> 00:06:28,990
registration was successful and now I

00:06:26,650 --> 00:06:30,280
can try and authenticate again I have to

00:06:28,990 --> 00:06:33,400
physically interact with the device to

00:06:30,280 --> 00:06:36,880
do that and authentication is successful

00:06:33,400 --> 00:06:39,190
I can it's now done that was not

00:06:36,880 --> 00:06:41,210
particularly exciting but that's kind of

00:06:39,190 --> 00:06:44,810
the point we wanted to be

00:06:41,210 --> 00:06:46,960
easy to do so just to give you an idea

00:06:44,810 --> 00:06:49,849
of what was going under the hood there

00:06:46,960 --> 00:06:50,150
he said trying to get back to do here we

00:06:49,849 --> 00:06:53,960
go

00:06:50,150 --> 00:06:55,520
it was something like that and that's a

00:06:53,960 --> 00:07:00,800
lot of stuff so I'm going to go through

00:06:55,520 --> 00:07:02,590
it a little bit slower so as you can see

00:07:00,800 --> 00:07:05,810
here there are three parties involved

00:07:02,590 --> 00:07:08,569
the client is the one where the browser

00:07:05,810 --> 00:07:11,810
is they authenticators the hardware

00:07:08,569 --> 00:07:13,430
token and the notion of the server has

00:07:11,810 --> 00:07:15,289
been abstracted out to the notion of a

00:07:13,430 --> 00:07:18,259
relying party in the party that is

00:07:15,289 --> 00:07:19,610
relying on the authentication an

00:07:18,259 --> 00:07:21,620
important thing to note here is that the

00:07:19,610 --> 00:07:22,009
Authenticator does not have to be a UB

00:07:21,620 --> 00:07:24,020
key

00:07:22,009 --> 00:07:25,430
it can be anything that supports c tab

00:07:24,020 --> 00:07:28,639
it doesn't even have to be that though

00:07:25,430 --> 00:07:31,130
it can be anything that is a secure

00:07:28,639 --> 00:07:33,680
element the defining characteristic is

00:07:31,130 --> 00:07:35,300
that it can generate keys in such a way

00:07:33,680 --> 00:07:37,400
that the private key never leaves the

00:07:35,300 --> 00:07:41,120
device and it can ship the public here

00:07:37,400 --> 00:07:44,120
out so that other people can use it so

00:07:41,120 --> 00:07:46,669
what happens here the relying party the

00:07:44,120 --> 00:07:50,570
server generates a challenge and a user

00:07:46,669 --> 00:07:53,030
handle for the new account it sends that

00:07:50,570 --> 00:07:54,680
the user handle is like a user ID but it

00:07:53,030 --> 00:07:56,750
doesn't have to be human readable so it

00:07:54,680 --> 00:07:58,849
can be the you know the underlying

00:07:56,750 --> 00:08:03,289
primary key for the user or could be a

00:07:58,849 --> 00:08:05,479
whole bunch of other things we send a

00:08:03,289 --> 00:08:08,180
challenge and they use a handle along

00:08:05,479 --> 00:08:12,310
with the relying party ID which contains

00:08:08,180 --> 00:08:12,310
the primary domain of the relying party

00:08:12,370 --> 00:08:16,880
so in this case you know we could be

00:08:14,810 --> 00:08:18,949
yubico calm but like if we send

00:08:16,880 --> 00:08:20,810
example.org then internal dot

00:08:18,949 --> 00:08:25,960
example.org will be accepted as a valid

00:08:20,810 --> 00:08:29,509
origin for that relying party so the

00:08:25,960 --> 00:08:32,270
client will validate that against what

00:08:29,509 --> 00:08:37,190
it sees and reject it if it doesn't

00:08:32,270 --> 00:08:39,440
match and that present that prevents a

00:08:37,190 --> 00:08:42,919
fake site from registering credentials

00:08:39,440 --> 00:08:45,800
for your real site so if you are PyCon

00:08:42,919 --> 00:08:47,480
2018 org and someone tries to register a

00:08:45,800 --> 00:08:51,500
credential that isn't from that domain

00:08:47,480 --> 00:08:54,920
it won't work so once we've done that

00:08:51,500 --> 00:08:56,660
the client generates a client data

00:08:54,920 --> 00:08:58,459
object which contains a challenge from

00:08:56,660 --> 00:09:00,709
the relying Palin's that we just

00:08:58,459 --> 00:09:03,620
received and the origin as seen by the

00:09:00,709 --> 00:09:05,630
client and these get hashed and sent to

00:09:03,620 --> 00:09:08,860
the Authenticator along with the user

00:09:05,630 --> 00:09:11,240
handle and the relying party ID itself

00:09:08,860 --> 00:09:12,949
the Authenticator prompts the user for

00:09:11,240 --> 00:09:14,570
consent that's an important step to

00:09:12,949 --> 00:09:16,430
avoid automated attacks against the

00:09:14,570 --> 00:09:18,410
Authenticator itself and then it creates

00:09:16,430 --> 00:09:20,360
a new key pair for this relying party

00:09:18,410 --> 00:09:22,220
and signs the client data hash and the

00:09:20,360 --> 00:09:24,320
new public key with its attestation key

00:09:22,220 --> 00:09:29,029
which is a key that is specific to that

00:09:24,320 --> 00:09:30,709
device it sent it sends an attestation

00:09:29,029 --> 00:09:33,019
object back to the client and that

00:09:30,709 --> 00:09:34,610
contains a whole bunch of stuff but the

00:09:33,019 --> 00:09:37,699
important bits here is has got a hash of

00:09:34,610 --> 00:09:40,279
the relying party ID the credential ID

00:09:37,699 --> 00:09:42,680
the public key of the new credential and

00:09:40,279 --> 00:09:45,410
all of this is signed with the the

00:09:42,680 --> 00:09:46,820
authenticators attestation key and so it

00:09:45,410 --> 00:09:50,630
sends the certificate containing that

00:09:46,820 --> 00:09:52,220
public key with it the client then

00:09:50,630 --> 00:09:54,019
passes that attestation object back to

00:09:52,220 --> 00:09:55,940
the relying party along with the client

00:09:54,019 --> 00:09:59,480
data object whose hash it it's sent to

00:09:55,940 --> 00:10:01,250
the Authenticator and then finally the

00:09:59,480 --> 00:10:02,329
relying party receives that verifies

00:10:01,250 --> 00:10:04,160
that everything's fine

00:10:02,329 --> 00:10:05,870
we verifies it verifies that the origin

00:10:04,160 --> 00:10:07,339
of the client saw is in fact a domain

00:10:05,870 --> 00:10:08,930
that we think it should be which

00:10:07,339 --> 00:10:11,600
prevents person in the middle attackers

00:10:08,930 --> 00:10:14,480
from faking logins to the site and since

00:10:11,600 --> 00:10:17,180
it's signed it can't be it's can't be

00:10:14,480 --> 00:10:18,649
faked we revoke we verify that the

00:10:17,180 --> 00:10:20,510
challenge we got is the same as the one

00:10:18,649 --> 00:10:24,350
we sent which prevents the request from

00:10:20,510 --> 00:10:26,870
being replayed or monkeyed with and we

00:10:24,350 --> 00:10:28,579
also can check the certificate of the

00:10:26,870 --> 00:10:31,070
the Authenticator itself the attestation

00:10:28,579 --> 00:10:35,300
certificate because that can be signed

00:10:31,070 --> 00:10:36,980
by a a root certificate owned by the

00:10:35,300 --> 00:10:39,319
vendor so we can actually see whether

00:10:36,980 --> 00:10:42,170
for instance it is a genuine Yubikey and

00:10:39,319 --> 00:10:43,670
not something else and so finally if

00:10:42,170 --> 00:10:46,490
everything's fine then we store all that

00:10:43,670 --> 00:10:50,560
and we can use it for later

00:10:46,490 --> 00:10:53,120
authentication stuff so that was pretty

00:10:50,560 --> 00:10:55,550
long it involved so just the short

00:10:53,120 --> 00:10:57,760
version for things we generate a

00:10:55,550 --> 00:11:00,380
challenge which prevents replay attacks

00:10:57,760 --> 00:11:03,680
we validate the the client will validate

00:11:00,380 --> 00:11:05,449
the origin which prevents phishing the

00:11:03,680 --> 00:11:08,209
Authenticator checks for user presence

00:11:05,449 --> 00:11:08,600
and consent avoiding automated attacks

00:11:08,209 --> 00:11:10,700
against

00:11:08,600 --> 00:11:13,340
in Decatur itself and preventing silent

00:11:10,700 --> 00:11:16,820
tracking the Authenticator creates a key

00:11:13,340 --> 00:11:20,690
pair the the private key never leaves

00:11:16,820 --> 00:11:22,640
the Authenticator and then the relying

00:11:20,690 --> 00:11:23,960
party then it verifies the attestation

00:11:22,640 --> 00:11:24,440
signature to make sure everything's on

00:11:23,960 --> 00:11:28,460
the up-and-up

00:11:24,440 --> 00:11:30,320
which again prevents fishing and the

00:11:28,460 --> 00:11:35,690
proves that the private key is safe and

00:11:30,320 --> 00:11:38,780
not coming out so at this point I was

00:11:35,690 --> 00:11:40,730
going to do yes so assume that I just

00:11:38,780 --> 00:11:42,340
did the authentication bit there because

00:11:40,730 --> 00:11:45,050
I'm just gonna keep moving

00:11:42,340 --> 00:11:46,850
so the authentication sequence looks

00:11:45,050 --> 00:11:54,380
very similar to the registration

00:11:46,850 --> 00:11:55,760
sequence we we generate the same kind of

00:11:54,380 --> 00:11:58,190
challenge data that we did before

00:11:55,760 --> 00:12:00,800
although in this case we include IDs of

00:11:58,190 --> 00:12:03,080
the certificates sorry the credentials

00:12:00,800 --> 00:12:08,150
that we're willing to accept signatures

00:12:03,080 --> 00:12:10,850
from the client data again looks very

00:12:08,150 --> 00:12:13,280
similar it gets sent over to the

00:12:10,850 --> 00:12:14,840
Authenticator in this case the instead

00:12:13,280 --> 00:12:17,030
of signing it with the attestation key

00:12:14,840 --> 00:12:20,360
that is permanently within the device it

00:12:17,030 --> 00:12:22,310
will sign the whole blob with the

00:12:20,360 --> 00:12:23,570
private could the private key of the

00:12:22,310 --> 00:12:28,850
credential key pair that was made

00:12:23,570 --> 00:12:32,630
previously the signature and everything

00:12:28,850 --> 00:12:34,100
is sent back along to the client the

00:12:32,630 --> 00:12:36,380
client passes it on to the relying party

00:12:34,100 --> 00:12:38,900
and the relying party verifies

00:12:36,380 --> 00:12:41,510
everything so again this looks very

00:12:38,900 --> 00:12:44,810
similar to the registration process just

00:12:41,510 --> 00:12:46,280
using the underlying private the

00:12:44,810 --> 00:12:47,840
credential private key rather than the

00:12:46,280 --> 00:12:50,450
attestation key so again we generate a

00:12:47,840 --> 00:12:52,580
challenge preventing replay attacks the

00:12:50,450 --> 00:12:54,890
client validates the origin again which

00:12:52,580 --> 00:12:56,450
prevents phishing the Authenticator

00:12:54,890 --> 00:12:58,040
checks for user presence and consent

00:12:56,450 --> 00:13:00,610
which prevents sila tracking and

00:12:58,040 --> 00:13:02,900
automated attempts on the Authenticator

00:13:00,610 --> 00:13:06,140
the Authenticator checks and signs the

00:13:02,900 --> 00:13:08,000
relying party ID the credentials

00:13:06,140 --> 00:13:09,860
restricted to one relying party so you

00:13:08,000 --> 00:13:12,500
don't end up sending the same credential

00:13:09,860 --> 00:13:14,330
out to multiple places the relying party

00:13:12,500 --> 00:13:16,460
verifies the signature which prevents

00:13:14,330 --> 00:13:21,680
phishing attacks and a prevents person

00:13:16,460 --> 00:13:22,490
in the middle attacks so all of this if

00:13:21,680 --> 00:13:25,130
you want to have a

00:13:22,490 --> 00:13:27,020
play with it you can find a bunch of

00:13:25,130 --> 00:13:29,720
implementation for the server-side logic

00:13:27,020 --> 00:13:31,880
and also examples of various other bits

00:13:29,720 --> 00:13:34,279
in the yubico Python Fido 2 module

00:13:31,880 --> 00:13:37,940
that's on pi PI as well as available

00:13:34,279 --> 00:13:42,440
from github so looking at some of the

00:13:37,940 --> 00:13:44,089
code in the example this is what

00:13:42,440 --> 00:13:46,520
happened when I pressed the register

00:13:44,089 --> 00:13:48,290
button this bit of JavaScript gets

00:13:46,520 --> 00:13:50,300
kicked off you can see it's hitting an

00:13:48,290 --> 00:13:55,160
API call on the server to kick off the

00:13:50,300 --> 00:13:58,279
registration process it then decodes

00:13:55,160 --> 00:14:00,920
that and calls this navigator dot

00:13:58,279 --> 00:14:02,420
credentials create this is one of the

00:14:00,920 --> 00:14:05,870
two API calls the way both ends

00:14:02,420 --> 00:14:10,850
specifies so this is for creating a new

00:14:05,870 --> 00:14:12,589
credential once it gets that so what the

00:14:10,850 --> 00:14:14,570
options dictionary that come that goes

00:14:12,589 --> 00:14:19,149
into that looks like this and this is

00:14:14,570 --> 00:14:23,209
taken straight from the the w3 w3c spec

00:14:19,149 --> 00:14:26,060
what it gets is the RP field is the

00:14:23,209 --> 00:14:27,350
information about the relying party the

00:14:26,060 --> 00:14:28,910
user field is obviously information

00:14:27,350 --> 00:14:30,860
about the user things like user name

00:14:28,910 --> 00:14:33,860
they use a handle that I mentioned

00:14:30,860 --> 00:14:37,130
previously it can also contain things

00:14:33,860 --> 00:14:39,170
like the full real name of the user if

00:14:37,130 --> 00:14:41,260
you want to put that in there the

00:14:39,170 --> 00:14:44,450
challenge is just a sequence of bytes

00:14:41,260 --> 00:14:48,589
the public key credential parameters are

00:14:44,450 --> 00:14:50,329
a set of parameter groupings for what

00:14:48,589 --> 00:14:52,010
kind of public keys you accept you can

00:14:50,329 --> 00:14:54,770
define what algorithms you want to use

00:14:52,010 --> 00:14:56,959
and things like that the timeout is how

00:14:54,770 --> 00:14:59,920
long the Authenticator should wait for

00:14:56,959 --> 00:15:03,200
the user to validate that they're there

00:14:59,920 --> 00:15:05,329
exclude credentials allows you to say I

00:15:03,200 --> 00:15:07,399
already have these credentials for this

00:15:05,329 --> 00:15:11,959
user if you have any of those don't

00:15:07,399 --> 00:15:17,750
bother creating a new one Authenticator

00:15:11,959 --> 00:15:20,899
selection criteria no I have forgotten

00:15:17,750 --> 00:15:21,920
that bit I'm sorry sorry there's a lot

00:15:20,899 --> 00:15:25,010
of stuff here and I'm kind of new to

00:15:21,920 --> 00:15:27,290
this one so the selection criteria

00:15:25,010 --> 00:15:30,470
I believe allows you to specify whether

00:15:27,290 --> 00:15:32,779
the key must be resident in the device

00:15:30,470 --> 00:15:35,720
or whether there's another mode that I'm

00:15:32,779 --> 00:15:35,990
forgetting the conveyence preference in

00:15:35,720 --> 00:15:37,550
two

00:15:35,990 --> 00:15:39,589
it's whether you're allowing proxies to

00:15:37,550 --> 00:15:41,120
get in the way of things and the

00:15:39,589 --> 00:15:46,160
extensions is funnily enough for

00:15:41,120 --> 00:15:49,700
extensions once we have done all that

00:15:46,160 --> 00:15:51,589
then we hit another API endpoint which

00:15:49,700 --> 00:15:53,300
allows us to send back the information

00:15:51,589 --> 00:15:56,270
this is the sending back the attestation

00:15:53,300 --> 00:15:57,800
object part of the the transaction and

00:15:56,270 --> 00:15:59,000
then once we've got that then we deal

00:15:57,800 --> 00:16:03,010
with the results of that whether it

00:15:59,000 --> 00:16:05,899
failed or succeeded on the service side

00:16:03,010 --> 00:16:10,690
the the phyto to module gives you a

00:16:05,899 --> 00:16:13,550
photo to server object you give it your

00:16:10,690 --> 00:16:15,410
primary domain which in our case here is

00:16:13,550 --> 00:16:19,250
localhost you know you will not do that

00:16:15,410 --> 00:16:21,950
in outside of testing things I'm sure

00:16:19,250 --> 00:16:22,940
and we have our relying party ID that

00:16:21,950 --> 00:16:26,990
we're going to be sending through two

00:16:22,940 --> 00:16:28,850
things this was a this is a flask app so

00:16:26,990 --> 00:16:32,300
we've got a flask app decorator

00:16:28,850 --> 00:16:33,649
there we are doing pretend user names

00:16:32,300 --> 00:16:35,240
here we're not actually using user names

00:16:33,649 --> 00:16:39,830
in this example so we've just made them

00:16:35,240 --> 00:16:43,040
up the credentials item in the register

00:16:39,830 --> 00:16:44,899
begin call is just simply an array of

00:16:43,040 --> 00:16:46,490
credentials that we've created because

00:16:44,899 --> 00:16:48,920
this demo thing just keeps the

00:16:46,490 --> 00:16:50,510
credentials in memory and then we

00:16:48,920 --> 00:16:52,490
generate we pull the challenge out and

00:16:50,510 --> 00:16:56,560
remember that for later and then send

00:16:52,490 --> 00:16:59,690
the result back to the browser on the

00:16:56,560 --> 00:17:01,820
registration completing side we take the

00:16:59,690 --> 00:17:05,660
response that came back we register

00:17:01,820 --> 00:17:07,699
complete we'll we'll do all the

00:17:05,660 --> 00:17:10,640
validation aspects of it for us and

00:17:07,699 --> 00:17:12,770
throw an exception if any of them fail

00:17:10,640 --> 00:17:15,770
we then append the credentials to our

00:17:12,770 --> 00:17:19,429
data store and return that everything

00:17:15,770 --> 00:17:21,140
worked on the authentication side again

00:17:19,429 --> 00:17:24,800
it ends up looking very very similar

00:17:21,140 --> 00:17:27,319
you've got this is the JavaScript side

00:17:24,800 --> 00:17:29,030
again so the other call that we have

00:17:27,319 --> 00:17:30,890
here is navigated credentials get this

00:17:29,030 --> 00:17:32,870
is the authentication end of the web or

00:17:30,890 --> 00:17:35,980
thin a P I again we have one of these

00:17:32,870 --> 00:17:37,190
large complicated options dictionaries

00:17:35,980 --> 00:17:39,530
challenge

00:17:37,190 --> 00:17:41,780
timeout our PID all very similar to what

00:17:39,530 --> 00:17:43,280
we saw before though the challenges the

00:17:41,780 --> 00:17:45,200
byte sequence with our random challenge

00:17:43,280 --> 00:17:47,120
value in and time out is how long we

00:17:45,200 --> 00:17:50,360
want to wait for the Authenticator to

00:17:47,120 --> 00:17:53,600
receive user input our PID is the rely

00:17:50,360 --> 00:17:55,790
partyid allow credentials in this call

00:17:53,600 --> 00:17:58,820
says here are the credentials that we

00:17:55,790 --> 00:18:01,130
expect this user to have and so we can

00:17:58,820 --> 00:18:02,809
then make sure that the Authenticator

00:18:01,130 --> 00:18:04,670
can make sure that they've got one it's

00:18:02,809 --> 00:18:07,760
worth noting here that we you do support

00:18:04,670 --> 00:18:10,790
multiple authenticators so if you have

00:18:07,760 --> 00:18:14,510
multiple Hardware tokens connected to

00:18:10,790 --> 00:18:16,970
you're connected to your browser then

00:18:14,510 --> 00:18:18,440
the browser will go out and look for all

00:18:16,970 --> 00:18:19,670
of them and say do you have this

00:18:18,440 --> 00:18:20,990
credential ID do you have this

00:18:19,670 --> 00:18:26,660
credential ID and pick the one that's

00:18:20,990 --> 00:18:29,960
got it user verification you can require

00:18:26,660 --> 00:18:33,010
a more stringent level of user checking

00:18:29,960 --> 00:18:35,780
you can say the user must be present

00:18:33,010 --> 00:18:37,190
which is you know when I touch the

00:18:35,780 --> 00:18:38,780
Yubikey that indicated that I was there

00:18:37,190 --> 00:18:43,760
you can also ask that the user be

00:18:38,780 --> 00:18:45,890
verified which would be more like having

00:18:43,760 --> 00:18:49,130
a subsequent authentication step like a

00:18:45,890 --> 00:18:51,850
entering a pin into the device or a

00:18:49,130 --> 00:18:55,760
touch ID or something like that and

00:18:51,850 --> 00:18:58,970
extensions again are for extensions so

00:18:55,760 --> 00:19:02,120
when we receive that we decode it we

00:18:58,970 --> 00:19:04,160
check we send it and we send the results

00:19:02,120 --> 00:19:07,160
back to the server and then deal with

00:19:04,160 --> 00:19:10,910
whatever response we get back on the

00:19:07,160 --> 00:19:13,970
server side again we literally just call

00:19:10,910 --> 00:19:15,860
into the the library will create the

00:19:13,970 --> 00:19:17,990
auth data structure for us if we want to

00:19:15,860 --> 00:19:18,950
do that again credentials is just the

00:19:17,990 --> 00:19:22,730
list of credentials we've already

00:19:18,950 --> 00:19:24,169
created and then on the other side we

00:19:22,730 --> 00:19:28,100
just check everything and make sure it

00:19:24,169 --> 00:19:29,840
all works so I have a slightly more

00:19:28,100 --> 00:19:35,570
complicated version of this that I can

00:19:29,840 --> 00:19:40,070
show off what I have on this one here is

00:19:35,570 --> 00:19:41,960
an implementation of the the the Django

00:19:40,070 --> 00:19:44,929
example polls app that I've stuck some

00:19:41,960 --> 00:19:46,250
very loose authentication around so I

00:19:44,929 --> 00:19:47,780
can tell it I want to log in with

00:19:46,250 --> 00:19:50,600
Authenticator and it will say no

00:19:47,780 --> 00:19:52,520
credentials available strictly I should

00:19:50,600 --> 00:19:55,100
probably enter my username there to do

00:19:52,520 --> 00:19:56,600
that too but again I don't have any

00:19:55,100 --> 00:20:02,690
credentials there so we'll just have to

00:19:56,600 --> 00:20:05,500
log in the old-fashioned way so we have

00:20:02,690 --> 00:20:05,500
the polls here

00:20:05,980 --> 00:20:15,680
so you know we can see the result we can

00:20:08,900 --> 00:20:17,060
see the options that we have here and we

00:20:15,680 --> 00:20:19,160
have an option to register an

00:20:17,060 --> 00:20:20,240
Authenticator so we can hit that and it

00:20:19,160 --> 00:20:23,780
will tell me to touch the blinking

00:20:20,240 --> 00:20:25,340
Authenticator which I will now do and so

00:20:23,780 --> 00:20:30,350
we've now registered that so if I log

00:20:25,340 --> 00:20:32,240
out I can now do this and login with

00:20:30,350 --> 00:20:33,620
Authenticator and it will ask me to

00:20:32,240 --> 00:20:37,070
touch the blinking Authenticator and

00:20:33,620 --> 00:20:42,890
there we are and over here we can see

00:20:37,070 --> 00:20:47,420
that I now have in my user entry in the

00:20:42,890 --> 00:20:50,120
admins data thing here I have a user

00:20:47,420 --> 00:20:54,710
Authenticator that I have registered

00:20:50,120 --> 00:20:58,790
today what I can also do if I want to is

00:20:54,710 --> 00:21:03,350
I have another Yubikey here I can put

00:20:58,790 --> 00:21:09,290
that in there so I can register a second

00:21:03,350 --> 00:21:11,750
one so we've now registered to

00:21:09,290 --> 00:21:18,560
authenticators if I log out I can log in

00:21:11,750 --> 00:21:20,900
with my second Authenticator and that

00:21:18,560 --> 00:21:23,900
works and if I reload this page I will

00:21:20,900 --> 00:21:27,020
now see that I had two of them so if I

00:21:23,900 --> 00:21:33,950
for example lose one of them I can

00:21:27,020 --> 00:21:36,350
delete that wait

00:21:33,950 --> 00:21:37,610
look out and then when I try and log in

00:21:36,350 --> 00:21:41,270
with the one I just deleted it's the

00:21:37,610 --> 00:21:42,650
American or everyone I deleted there we

00:21:41,270 --> 00:21:44,030
go invalid state error the user

00:21:42,650 --> 00:21:45,110
attempted to use an Authenticator that

00:21:44,030 --> 00:21:49,880
recognized none of the provided

00:21:45,110 --> 00:21:57,040
credentials and so but I can still log

00:21:49,880 --> 00:22:07,660
in with the other one there we go

00:21:57,040 --> 00:22:11,450
so yeah so based on that when you get to

00:22:07,660 --> 00:22:12,380
so what best practices when you're

00:22:11,450 --> 00:22:16,940
implementing web or thin

00:22:12,380 --> 00:22:20,360
always allow multiple authenticators the

00:22:16,940 --> 00:22:23,150
the sad thing about Hardware physical

00:22:20,360 --> 00:22:27,050
devices is you lose them so allowing

00:22:23,150 --> 00:22:29,630
multiples does that at yubico when we

00:22:27,050 --> 00:22:31,670
when we first joined we're given to you

00:22:29,630 --> 00:22:32,900
by keys and like you you keep one with

00:22:31,670 --> 00:22:34,550
your laptop and you keep one somewhere

00:22:32,900 --> 00:22:37,570
else so that if you lose your laptop you

00:22:34,550 --> 00:22:37,570
can still get into all of your accounts

00:22:37,600 --> 00:22:40,970
allow users to label their

00:22:39,650 --> 00:22:42,590
authenticators I didn't have that in

00:22:40,970 --> 00:22:44,510
this app because this app was as you can

00:22:42,590 --> 00:22:46,370
see top-notch quality work done in a

00:22:44,510 --> 00:22:50,240
very long time frame with plenty of

00:22:46,370 --> 00:22:51,890
attention to detail but if you are

00:22:50,240 --> 00:22:53,330
implementing this allow users to label

00:22:51,890 --> 00:22:56,030
their Authenticator so that they know

00:22:53,330 --> 00:22:57,620
which ones they are so if they lose the

00:22:56,030 --> 00:23:01,250
if they lose one they know which one to

00:22:57,620 --> 00:23:02,780
to knock off store the credential data

00:23:01,250 --> 00:23:04,190
verbatim don't bother trying to process

00:23:02,780 --> 00:23:06,800
it or anything it's not meant to be

00:23:04,190 --> 00:23:09,710
introspected in a serious way so just I

00:23:06,800 --> 00:23:11,300
the underlying data type that I'm using

00:23:09,710 --> 00:23:17,390
in my Jango out there is literally just

00:23:11,300 --> 00:23:19,670
a bytes field of some kind you can if

00:23:17,390 --> 00:23:21,320
you want to check the attestation

00:23:19,670 --> 00:23:22,580
certificates that come back when you

00:23:21,320 --> 00:23:24,470
register credentials to make sure

00:23:22,580 --> 00:23:27,170
they're coming from devices that you

00:23:24,470 --> 00:23:28,550
trust this would be in the case this

00:23:27,170 --> 00:23:30,470
would be when you're sort of going up

00:23:28,550 --> 00:23:33,020
maybe one or two levels of paranoia but

00:23:30,470 --> 00:23:34,550
if you if you're if you are worried that

00:23:33,020 --> 00:23:36,350
there is someone out there using faked

00:23:34,550 --> 00:23:37,670
health indicators then you can try and

00:23:36,350 --> 00:23:39,710
make sure that your attestation

00:23:37,670 --> 00:23:41,930
certificates are coming from a root

00:23:39,710 --> 00:23:44,540
certificate that you trust so if you

00:23:41,930 --> 00:23:45,680
only wanted to use you bikies you can

00:23:44,540 --> 00:23:47,750
make sure that they're all signed by the

00:23:45,680 --> 00:23:49,070
yubico cert if you only want to use

00:23:47,750 --> 00:23:51,200
Google's tightened keys you can make

00:23:49,070 --> 00:23:56,620
sure this I'm baited by Google all of

00:23:51,200 --> 00:23:59,870
those are fine these links here are be

00:23:56,620 --> 00:24:02,630
the first one is the what w3c we're both

00:23:59,870 --> 00:24:03,680
in spec it's full of dry spec language

00:24:02,630 --> 00:24:05,420
you're probably not going to find it a

00:24:03,680 --> 00:24:06,260
fun read but it does have some useful

00:24:05,420 --> 00:24:08,000
information in it

00:24:06,260 --> 00:24:11,590
the second one is the Python Fido 2

00:24:08,000 --> 00:24:14,960
library that I showed you earlier

00:24:11,590 --> 00:24:18,830
browser support for web both in Google

00:24:14,960 --> 00:24:21,950
Chrome has it from version 67 Mozilla

00:24:18,830 --> 00:24:23,690
Firefox has it from version 61 Microsoft

00:24:21,950 --> 00:24:25,930
edge will have it from version 18 which

00:24:23,690 --> 00:24:33,320
is the next version that will come out

00:24:25,930 --> 00:24:35,960
Apple's Safari but there is hope this

00:24:33,320 --> 00:24:37,940
WebKit bug is their tracking bug for

00:24:35,960 --> 00:24:39,290
implementing web or thin they actually

00:24:37,940 --> 00:24:41,300
do appear to be working on it

00:24:39,290 --> 00:24:43,250
from what I understand which is

00:24:41,300 --> 00:24:44,690
absolutely nothing coming from Apple

00:24:43,250 --> 00:24:47,270
itself it's just what people have told

00:24:44,690 --> 00:24:48,770
me they're first going to be

00:24:47,270 --> 00:24:50,210
implementing and what they term local

00:24:48,770 --> 00:24:53,240
Authenticator which refers to their

00:24:50,210 --> 00:24:54,860
touch ID face ID based secure enclaves

00:24:53,240 --> 00:24:55,610
on things like phones and touch bar

00:24:54,860 --> 00:24:57,620
equipped Macs

00:24:55,610 --> 00:25:01,070
but they do have tracking bugs in there

00:24:57,620 --> 00:25:04,970
for implementing USB and NFC and

00:25:01,070 --> 00:25:07,370
Bluetooth authenticated protocols and

00:25:04,970 --> 00:25:08,930
yes even more information on all of this

00:25:07,370 --> 00:25:12,020
can be found at you because develop a

00:25:08,930 --> 00:25:14,350
program website and with that thank you

00:25:12,020 --> 00:25:14,350
very much

00:25:18,470 --> 00:25:25,980
thank you thank you very much and your

00:25:21,240 --> 00:25:27,600
amazing month a mug a free mug we do

00:25:25,980 --> 00:25:29,640
have a couple minutes so we can break

00:25:27,600 --> 00:25:31,200
out a question or two and I think we've

00:25:29,640 --> 00:25:34,260
got to start one already yeah that was

00:25:31,200 --> 00:25:35,250
quick so besides all the questions that

00:25:34,260 --> 00:25:40,110
I want to ask you because there's so

00:25:35,250 --> 00:25:42,120
many how many keys can you actually

00:25:40,110 --> 00:25:44,160
generate onto one of these devices for

00:25:42,120 --> 00:25:45,780
each individual site as even if I go and

00:25:44,160 --> 00:25:47,370
plug this in and register for like you

00:25:45,780 --> 00:25:49,470
know three different sites am I going to

00:25:47,370 --> 00:25:51,480
hit like a key limit or how is that

00:25:49,470 --> 00:25:53,340
actually I don't have an answer for you

00:25:51,480 --> 00:25:57,179
on that one I can find out you will vary

00:25:53,340 --> 00:25:58,679
depending on the the token itself so

00:25:57,179 --> 00:25:59,940
different tokens have different Hardware

00:25:58,679 --> 00:26:01,880
different hardware has different storage

00:25:59,940 --> 00:26:04,429
capacities and so forth

00:26:01,880 --> 00:26:06,240
hi Beto I'm hope I love the talk

00:26:04,429 --> 00:26:07,650
question about since you had that

00:26:06,240 --> 00:26:10,410
browser two-port list yes

00:26:07,650 --> 00:26:13,760
what does mobile look like with like the

00:26:10,410 --> 00:26:15,059
phaeton keys and that whole universe

00:26:13,760 --> 00:26:20,550
okay

00:26:15,059 --> 00:26:23,580
so mobile you are looking at NFC and

00:26:20,550 --> 00:26:26,309
Bluetooth le as your most common things

00:26:23,580 --> 00:26:29,929
the you bikini o supports NFC which will

00:26:26,309 --> 00:26:33,030
work on Android handsets I believe

00:26:29,929 --> 00:26:36,690
iPhones are an interesting issue in that

00:26:33,030 --> 00:26:38,660
regard at the moment if you wanted to do

00:26:36,690 --> 00:26:41,010
that you would need to use Bluetooth le

00:26:38,660 --> 00:26:42,840
which I believe is one of the reasons

00:26:41,010 --> 00:26:48,570
why the Google Titan one does have

00:26:42,840 --> 00:26:51,240
bluetooth LE yubico being a relatively

00:26:48,570 --> 00:26:54,030
paranoid organization does not like

00:26:51,240 --> 00:26:56,820
Bluetooth le as a carrier for security

00:26:54,030 --> 00:26:58,920
things like that but will the browser

00:26:56,820 --> 00:27:02,220
support it the browser's should support

00:26:58,920 --> 00:27:03,720
it and once and there that WebKit

00:27:02,220 --> 00:27:07,260
tracking bug that I mentioned does

00:27:03,720 --> 00:27:10,200
mention both iOS and Mac OS so once the

00:27:07,260 --> 00:27:12,630
iOS support for that shows up which I

00:27:10,200 --> 00:27:16,230
doubt we'll be iOS 12 but could be a

00:27:12,630 --> 00:27:18,210
point release on that or iOS 13 then you

00:27:16,230 --> 00:27:20,550
should get assuming that they go ahead

00:27:18,210 --> 00:27:26,070
with it you should get support for all

00:27:20,550 --> 00:27:27,360
of those you know yeah

00:27:26,070 --> 00:27:29,850
thank you very much it was a great talk

00:27:27,360 --> 00:27:31,170
thank you the hardware authenticators of

00:27:29,850 --> 00:27:34,740
course are in a different class to the

00:27:31,170 --> 00:27:37,200
software of indicators yes and we know

00:27:34,740 --> 00:27:39,000
that people like github for example are

00:27:37,200 --> 00:27:42,180
recommending to use authy which is

00:27:39,000 --> 00:27:43,680
essentially a software orth indicator we

00:27:42,180 --> 00:27:45,720
also know that in your talk you talked

00:27:43,680 --> 00:27:48,420
about labeling actual hardware devices

00:27:45,720 --> 00:27:51,420
in case you lose one yes what is there

00:27:48,420 --> 00:27:53,640
an API to essentially query number one

00:27:51,420 --> 00:27:55,350
the device label but number two the

00:27:53,640 --> 00:27:57,240
class of device so that you can say

00:27:55,350 --> 00:27:59,070
actually that's a software off indicator

00:27:57,240 --> 00:28:00,870
and this is a really secure thing for

00:27:59,070 --> 00:28:06,450
your bank details for example and we're

00:28:00,870 --> 00:28:09,720
not accepting it okay so the first part

00:28:06,450 --> 00:28:13,500
first is there a way to hang on so the

00:28:09,720 --> 00:28:16,110
first part was query the label there

00:28:13,500 --> 00:28:17,400
isn't you probably get a serial number

00:28:16,110 --> 00:28:19,290
out of them but I don't know if that

00:28:17,400 --> 00:28:19,770
gets exposed via C tap or anything like

00:28:19,290 --> 00:28:21,600
that

00:28:19,770 --> 00:28:23,730
I think the label you would put on it is

00:28:21,600 --> 00:28:27,000
really more like you stick a sticky

00:28:23,730 --> 00:28:29,070
label on your key and then put that

00:28:27,000 --> 00:28:31,500
label on the thing so in my case because

00:28:29,070 --> 00:28:33,210
I've got like a 4c Nano is my sort of

00:28:31,500 --> 00:28:34,410
main one that I'd just losing my laptop

00:28:33,210 --> 00:28:36,600
I would probably label that one laptop

00:28:34,410 --> 00:28:38,790
and then label the one that goes on my

00:28:36,600 --> 00:28:40,050
key ring keyring but you are free to

00:28:38,790 --> 00:28:42,900
call them whatever you like you can call

00:28:40,050 --> 00:28:44,310
them esmeralda or you know Fred or well

00:28:42,900 --> 00:28:46,160
you know I don't know if this goes into

00:28:44,310 --> 00:28:49,440
our naming your pet's kind of thing but

00:28:46,160 --> 00:28:51,990
on the other hand querying the

00:28:49,440 --> 00:28:53,940
capabilities of a device there you can

00:28:51,990 --> 00:28:55,590
you do get some information about the

00:28:53,940 --> 00:28:58,560
device back in the attestation object

00:28:55,590 --> 00:29:00,690
when you register again what you could

00:28:58,560 --> 00:29:04,110
do is make sure that it's signed by the

00:29:00,690 --> 00:29:06,210
right certificate like yubico will never

00:29:04,110 --> 00:29:11,640
put out a software Authenticator like

00:29:06,210 --> 00:29:13,290
that so but and yeah I don't know what

00:29:11,640 --> 00:29:14,430
of--they does in terms of what it's

00:29:13,290 --> 00:29:16,020
protocol is so I can't tell you whether

00:29:14,430 --> 00:29:17,160
it's using that under the hood like

00:29:16,020 --> 00:29:19,350
whether it would actually integrate with

00:29:17,160 --> 00:29:20,940
we're both in in that fashion or whether

00:29:19,350 --> 00:29:27,300
it's more a kind of time-based one-time

00:29:20,940 --> 00:29:30,410
password or those those varieties if

00:29:27,300 --> 00:29:32,790
there's one more we can fit it in yep

00:29:30,410 --> 00:29:34,500
you mentioned the verifying user

00:29:32,790 --> 00:29:36,000
presence is important like with the job

00:29:34,500 --> 00:29:38,100
do you have any concerns about the fact

00:29:36,000 --> 00:29:39,810
that the user can't tell which site then

00:29:38,100 --> 00:29:41,550
verifying like if I open a back

00:29:39,810 --> 00:29:43,620
Tabb can I trigger one of these requests

00:29:41,550 --> 00:29:45,210
and convince the user to tap from a

00:29:43,620 --> 00:29:49,290
malicious site without their realizing

00:29:45,210 --> 00:29:50,730
that's a very good question the answer

00:29:49,290 --> 00:29:52,650
is I don't have an answer for that

00:29:50,730 --> 00:29:54,950
but you have given me questions that I'm

00:29:52,650 --> 00:29:57,000
gonna go ask the relevant people about

00:29:54,950 --> 00:30:04,520
could you maybe notice afterwards I'd

00:29:57,000 --> 00:30:04,520

YouTube URL: https://www.youtube.com/watch?v=03sAfmCDjFg


