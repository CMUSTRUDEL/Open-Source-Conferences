Title: Why you should care about types: How Python typing helped my team scale
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Luka Sterbic

https://2018.pycon-au.org/talks/45224-why-you-should-care-about-types-how-python-typing-helped-my-team-scale/

By now you have probably all heard about Python static typing. But why should you care? Are types in Python even Pythonic? Is Python turning into Java? In this talk I’ll try to answer these questions and explain how type annotations helped my team scale 4x and make developers happier.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:12,440
Oh welcome to the last session of the

00:00:05,670 --> 00:00:15,809
morning and today we have a speaker from

00:00:12,440 --> 00:00:18,270
all the way from Facebook who's based in

00:00:15,809 --> 00:00:25,529
the London office at the moment he is

00:00:18,270 --> 00:00:27,810
Luca steer sorry he house

00:00:25,529 --> 00:00:30,510
originally from Croatia and he joined

00:00:27,810 --> 00:00:32,640
the London office of Facebook in 2016

00:00:30,510 --> 00:00:36,719
after completing his master's degree in

00:00:32,640 --> 00:00:38,879
computer science and in fact during his

00:00:36,719 --> 00:00:42,329
university time his focus was mainly on

00:00:38,879 --> 00:00:48,059
bioinformatics especially next-gen DNA

00:00:42,329 --> 00:00:50,820
sequence assemblers I so now he works on

00:00:48,059 --> 00:00:54,120
a variety of things including automated

00:00:50,820 --> 00:00:56,760
cross repo testing scenario verification

00:00:54,120 --> 00:00:58,800
and product monitoring he is also an

00:00:56,760 --> 00:01:03,500
open source contributor to various

00:00:58,800 --> 00:01:07,530
Python projects like type shed and black

00:01:03,500 --> 00:01:10,380
today Luca will be talking about why you

00:01:07,530 --> 00:01:13,860
should care about types how Python

00:01:10,380 --> 00:01:16,640
typing helped my team scale please

00:01:13,860 --> 00:01:16,640
welcome him

00:01:22,200 --> 00:01:30,550
okay hello everyone I guess

00:01:24,790 --> 00:01:32,130
sounds good so thanks for the packed

00:01:30,550 --> 00:01:35,800
room no pressure

00:01:32,130 --> 00:01:38,710
my talk today is why you should care

00:01:35,800 --> 00:01:41,229
about types and how they helped my team

00:01:38,710 --> 00:01:43,659
is killed from engineers to twelve in

00:01:41,229 --> 00:01:46,420
less than a year my name is Lucas tab

00:01:43,659 --> 00:01:48,070
which based in the London office of

00:01:46,420 --> 00:01:51,490
Facebook I've been there for the last

00:01:48,070 --> 00:01:53,680
two years and my main day-to-day job is

00:01:51,490 --> 00:01:56,289
coding in Python working on our

00:01:53,680 --> 00:01:59,500
automation for a testing and product

00:01:56,289 --> 00:02:01,149
monitoring so let's get start with the

00:01:59,500 --> 00:02:03,250
talk because I have a lot of content for

00:02:01,149 --> 00:02:07,300
today and just three demerits so the

00:02:03,250 --> 00:02:10,030
agenda is our first talk about why is

00:02:07,300 --> 00:02:13,570
typing important in modern Python code

00:02:10,030 --> 00:02:15,910
bases then I'll give a brief intro on

00:02:13,570 --> 00:02:18,010
what typing looks like these days this

00:02:15,910 --> 00:02:20,860
won't be a full overview of all the

00:02:18,010 --> 00:02:22,390
capabilities typing have but more like

00:02:20,860 --> 00:02:26,290
the core features you need to know to

00:02:22,390 --> 00:02:29,650
have 90% of the impact then I'll explain

00:02:26,290 --> 00:02:32,500
how to start using typing both for new

00:02:29,650 --> 00:02:34,209
projects the easy part and for a large

00:02:32,500 --> 00:02:36,489
existing code base is the hard part

00:02:34,209 --> 00:02:38,079
and last but not least I'll have a

00:02:36,489 --> 00:02:40,360
section on tips and tricks that I

00:02:38,079 --> 00:02:43,840
learned in the last two years of using

00:02:40,360 --> 00:02:46,720
when driving so let's start with a

00:02:43,840 --> 00:02:50,160
question from the title slide why should

00:02:46,720 --> 00:02:52,450
I even care about typed Python code like

00:02:50,160 --> 00:02:52,840
really some could ask like what's the

00:02:52,450 --> 00:02:54,700
point

00:02:52,840 --> 00:02:57,220
what has been running perfectly fine for

00:02:54,700 --> 00:03:00,070
years without any statically typed

00:02:57,220 --> 00:03:02,350
information and it still does the thing

00:03:00,070 --> 00:03:04,299
is though that the size of code videos

00:03:02,350 --> 00:03:06,940
also have been increasing the uphill

00:03:04,299 --> 00:03:09,940
over the last few years so the biggest

00:03:06,940 --> 00:03:12,220
win of any types to codebase these days

00:03:09,940 --> 00:03:15,030
it's not so much the extra safety of the

00:03:12,220 --> 00:03:17,350
type checker but more durability win and

00:03:15,030 --> 00:03:19,390
extra productivity that engineers get

00:03:17,350 --> 00:03:23,350
because of it let me try to illustrate

00:03:19,390 --> 00:03:26,170
that on an example so imagine you've

00:03:23,350 --> 00:03:28,690
started working at a big tech company

00:03:26,170 --> 00:03:31,180
you get assigned a ramped up task by

00:03:28,690 --> 00:03:32,750
another engineer on your team and your

00:03:31,180 --> 00:03:35,600
goal is to log

00:03:32,750 --> 00:03:38,720
more information about each job that

00:03:35,600 --> 00:03:41,030
it's submitted some scheduler so how do

00:03:38,720 --> 00:03:43,070
you get started on something like yes if

00:03:41,030 --> 00:03:45,530
you need to log more information for a

00:03:43,070 --> 00:03:47,690
job the first thing you need to figure

00:03:45,530 --> 00:03:49,700
out as what does each job really look

00:03:47,690 --> 00:03:51,770
like so how do we get started

00:03:49,700 --> 00:03:53,660
but just looking at the code you can see

00:03:51,770 --> 00:03:55,580
that the jobs input needs to be some

00:03:53,660 --> 00:03:58,130
kind of iterable since we have a for

00:03:55,580 --> 00:04:00,680
loop over it and then we can see that

00:03:58,130 --> 00:04:02,330
each job has a name attribute and the

00:04:00,680 --> 00:04:06,560
meta attribute that interns has the

00:04:02,330 --> 00:04:08,810
priority of each job going by intuition

00:04:06,560 --> 00:04:11,090
you could simulate this as a clause

00:04:08,810 --> 00:04:13,280
stored somewhere in your code base so

00:04:11,090 --> 00:04:16,340
you're good with in a UNIX tooling

00:04:13,280 --> 00:04:20,030
you're gonna grab for it and here's the

00:04:16,340 --> 00:04:23,530
result in large code bases grabbing for

00:04:20,030 --> 00:04:26,690
common names will not help you out and

00:04:23,530 --> 00:04:30,020
things like tasks job scheduler are

00:04:26,690 --> 00:04:33,560
super common so finding code with grab

00:04:30,020 --> 00:04:36,230
like does not scale over let's say 1,000

00:04:33,560 --> 00:04:39,080
files probably so what could you try

00:04:36,230 --> 00:04:41,210
next you could look at where submit is

00:04:39,080 --> 00:04:44,660
called and figure out from there how the

00:04:41,210 --> 00:04:47,030
the input is constructed one thing to

00:04:44,660 --> 00:04:48,890
note though that is you don't know a

00:04:47,030 --> 00:04:51,710
priori how the submit function is called

00:04:48,890 --> 00:04:54,830
it could be either module but submit or

00:04:51,710 --> 00:04:56,570
the more common usually from scheduler

00:04:54,830 --> 00:04:59,120
import submit and then just call submit

00:04:56,570 --> 00:05:03,280
without the module name and this again

00:04:59,120 --> 00:05:06,080
makes it quite hard to grab correctly

00:05:03,280 --> 00:05:07,580
also if you manage to pinpoint one of

00:05:06,080 --> 00:05:10,610
the usages of the function again

00:05:07,580 --> 00:05:12,800
creating the input may not be super

00:05:10,610 --> 00:05:16,100
trivial and readable form online it may

00:05:12,800 --> 00:05:18,530
be again be ten jumps away in a

00:05:16,100 --> 00:05:20,600
completely different module so you've

00:05:18,530 --> 00:05:22,430
got like ten jumps away from there from

00:05:20,600 --> 00:05:24,020
the submit function to where it's

00:05:22,430 --> 00:05:25,640
subject called when you still have like

00:05:24,020 --> 00:05:28,070
a long way to go to figure out how the

00:05:25,640 --> 00:05:32,330
arguments are constructed exactly so it

00:05:28,070 --> 00:05:34,190
could be try next we can print the

00:05:32,330 --> 00:05:36,890
information at run time obviously asking

00:05:34,190 --> 00:05:39,260
type over a Python object to a yield its

00:05:36,890 --> 00:05:40,820
class usually and with the built in

00:05:39,260 --> 00:05:43,100
their function we can actually expect

00:05:40,820 --> 00:05:45,320
what an object looks like and print

00:05:43,100 --> 00:05:46,460
elite attributes and this works fine

00:05:45,320 --> 00:05:48,530
like after this

00:05:46,460 --> 00:05:50,750
for sure gonna be I want to know like

00:05:48,530 --> 00:05:53,030
what each job looks like and we'll be

00:05:50,750 --> 00:05:55,099
able to do your job there is a problem

00:05:53,030 --> 00:05:57,949
with this though it's super slow and

00:05:55,099 --> 00:06:00,470
quite quite clunky to be honest for each

00:05:57,949 --> 00:06:02,900
part that you need information on you

00:06:00,470 --> 00:06:05,270
need to instrument prints or some kind

00:06:02,900 --> 00:06:07,340
of instrumentation logging around it run

00:06:05,270 --> 00:06:10,009
your code gather data and then like

00:06:07,340 --> 00:06:13,069
continue iterating if you're working on

00:06:10,009 --> 00:06:15,349
a large server like application for

00:06:13,069 --> 00:06:17,210
example also triggering a very specific

00:06:15,349 --> 00:06:19,580
code path from a top-level request may

00:06:17,210 --> 00:06:21,080
not be as trivial as you think so even

00:06:19,580 --> 00:06:22,910
just hitting the part of the code you're

00:06:21,080 --> 00:06:26,000
interested in may not be true may not be

00:06:22,910 --> 00:06:29,180
easy so there has to be a better way

00:06:26,000 --> 00:06:32,449
right and this is where typing comes

00:06:29,180 --> 00:06:35,360
into play basically with typed codes

00:06:32,449 --> 00:06:37,250
it's obvious by just glancing at the

00:06:35,360 --> 00:06:39,409
signature of the function what the input

00:06:37,250 --> 00:06:42,979
and output structures are in this case

00:06:39,409 --> 00:06:45,080
jobs is an iterable or the job type

00:06:42,979 --> 00:06:47,840
which is defined in this other module

00:06:45,080 --> 00:06:51,289
but now we actually can find exactly

00:06:47,840 --> 00:06:53,599
where this class is implemented if

00:06:51,289 --> 00:06:54,889
you're using modern white an ID like

00:06:53,599 --> 00:06:57,229
PyCharm this is only one click away

00:06:54,889 --> 00:06:59,330
basically and it won't have to do any

00:06:57,229 --> 00:07:03,770
manual dropping or searching for the

00:06:59,330 --> 00:07:06,050
code base for class jobs something so

00:07:03,770 --> 00:07:09,440
having more readable code actually helps

00:07:06,050 --> 00:07:11,270
grow a team as well when you have a new

00:07:09,440 --> 00:07:13,430
engineer that just started on your team

00:07:11,270 --> 00:07:16,719
being presented with typed code is much

00:07:13,430 --> 00:07:19,460
easier for them to start contributing

00:07:16,719 --> 00:07:21,229
because the iteration cycle is is much

00:07:19,460 --> 00:07:23,120
closer it's easier to get started

00:07:21,229 --> 00:07:24,590
because they have more context available

00:07:23,120 --> 00:07:26,930
at the snippet they're looking and

00:07:24,590 --> 00:07:29,509
another like added benefit as you're

00:07:26,930 --> 00:07:31,759
gonna get less pings from a new engineer

00:07:29,509 --> 00:07:33,680
and more meaningful because they won't

00:07:31,759 --> 00:07:34,940
be asking or like what's this thing

00:07:33,680 --> 00:07:36,560
where you I found it because it's

00:07:34,940 --> 00:07:38,449
obvious from the code the goal might be

00:07:36,560 --> 00:07:41,180
asking okay what's the kind of business

00:07:38,449 --> 00:07:43,009
reason for doing it or less so it helps

00:07:41,180 --> 00:07:47,599
growing a team a lot especially if you

00:07:43,009 --> 00:07:51,050
need to scale quickly next let's look

00:07:47,599 --> 00:07:53,389
into a Python type is incompatible with

00:07:51,050 --> 00:07:55,729
the spirit of Python when I talk to

00:07:53,389 --> 00:07:58,490
other engineers that don't work with

00:07:55,729 --> 00:07:59,990
Python daily basis and here I'm working

00:07:58,490 --> 00:08:01,819
on Python typing

00:07:59,990 --> 00:08:03,169
they're usually quite surprised and

00:08:01,819 --> 00:08:05,150
their reaction to something along the

00:08:03,169 --> 00:08:08,120
lines like it's by them turning into

00:08:05,150 --> 00:08:10,699
Java like no that's definitely not the

00:08:08,120 --> 00:08:12,050
case might indeed take the best

00:08:10,699 --> 00:08:14,960
learnings from other statically typed

00:08:12,050 --> 00:08:15,830
languages for sure but it's completely a

00:08:14,960 --> 00:08:18,259
different beast

00:08:15,830 --> 00:08:20,599
vitamist typing in Python is still very

00:08:18,259 --> 00:08:22,370
much optional and it has almost no

00:08:20,599 --> 00:08:24,020
impact at runtime so you get the

00:08:22,370 --> 00:08:26,810
benefits with static analysis but it

00:08:24,020 --> 00:08:28,580
does not impact runtime so never gonna

00:08:26,810 --> 00:08:31,360
get an exception because of typing at

00:08:28,580 --> 00:08:34,490
runtime if you're doing things right so

00:08:31,360 --> 00:08:37,039
our Python types pythonic and I think

00:08:34,490 --> 00:08:39,409
the answer is yes if we just look at the

00:08:37,039 --> 00:08:41,899
famous Zen of Python with which you get

00:08:39,409 --> 00:08:43,190
by importing this I think there are

00:08:41,899 --> 00:08:45,709
three points that actually sum it up

00:08:43,190 --> 00:08:48,680
pretty well exploit it is better than

00:08:45,709 --> 00:08:50,690
implicit readability counts and in the

00:08:48,680 --> 00:08:54,560
face one be guilty refuse the temptation

00:08:50,690 --> 00:08:57,680
to guess this all goes towards the goal

00:08:54,560 --> 00:09:00,410
of if the input of structure of a

00:08:57,680 --> 00:09:02,420
function was obvious when you wrote the

00:09:00,410 --> 00:09:04,700
code it should be again obvious when you

00:09:02,420 --> 00:09:07,040
go read the code one week later if you

00:09:04,700 --> 00:09:09,770
need to put in any work to figure out

00:09:07,040 --> 00:09:12,230
what the input our structure was like in

00:09:09,770 --> 00:09:13,910
code you wrote like a few weeks ago it's

00:09:12,230 --> 00:09:17,510
usually a bad sign that needs either

00:09:13,910 --> 00:09:19,360
more documentation or better typing and

00:09:17,510 --> 00:09:22,760
if that's not enough

00:09:19,360 --> 00:09:25,459
Gita said so before he retired from

00:09:22,760 --> 00:09:26,959
being the benevolent actor for life so

00:09:25,459 --> 00:09:31,579
you can take his word for it for it as

00:09:26,959 --> 00:09:33,230
well next is typing one on one I'm going

00:09:31,579 --> 00:09:34,430
to show you like what typing looks like

00:09:33,230 --> 00:09:37,130
in practice and kind of the minimum

00:09:34,430 --> 00:09:40,160
feature set you need to know to be

00:09:37,130 --> 00:09:43,550
productive so let's cover what needs to

00:09:40,160 --> 00:09:45,829
be on TV first here we have a custom

00:09:43,550 --> 00:09:48,410
print function that accepts a message

00:09:45,829 --> 00:09:50,779
seems like a string and returns nothing

00:09:48,410 --> 00:09:53,570
and we also have a square just accepts

00:09:50,779 --> 00:09:55,700
the length size in it since the

00:09:53,570 --> 00:09:57,110
annotated version of this code is

00:09:55,700 --> 00:09:59,510
actually quite straightforward it's

00:09:57,110 --> 00:10:02,110
pretty much what I just said we have a

00:09:59,510 --> 00:10:06,620
print function that accepts a string and

00:10:02,110 --> 00:10:11,660
returns none nothing and the square

00:10:06,620 --> 00:10:12,380
accepts nth for its sides and all you

00:10:11,660 --> 00:10:15,140
need

00:10:12,380 --> 00:10:20,420
methods of classes like contract always

00:10:15,140 --> 00:10:22,430
return none in some cases we also have

00:10:20,420 --> 00:10:24,530
to type variables if you come from a

00:10:22,430 --> 00:10:26,630
statically typed language like Java C++

00:10:24,530 --> 00:10:29,300
we have to type everything this may not

00:10:26,630 --> 00:10:31,010
be super straightforward but in general

00:10:29,300 --> 00:10:33,500
the type checker tries to do the things

00:10:31,010 --> 00:10:34,910
for you and if it can't figure out what

00:10:33,500 --> 00:10:36,580
the type of something is it will not

00:10:34,910 --> 00:10:39,530
bother you to actually write explicitly

00:10:36,580 --> 00:10:42,260
the problem usually comes when the type

00:10:39,530 --> 00:10:44,930
checker cannot infer from the context

00:10:42,260 --> 00:10:47,090
what the type of something is and this

00:10:44,930 --> 00:10:50,150
is very common with collections for

00:10:47,090 --> 00:10:55,100
example if you have a collection that's

00:10:50,150 --> 00:10:57,140
initialized inside the init block or a

00:10:55,100 --> 00:10:58,730
class but then it's used somewhere else

00:10:57,140 --> 00:11:00,620
in the class the type checker usually

00:10:58,730 --> 00:11:02,120
cannot figure out what the type is going

00:11:00,620 --> 00:11:04,010
to be at runtime when you use the

00:11:02,120 --> 00:11:07,910
collection so it's actually gonna ask

00:11:04,010 --> 00:11:10,070
you to annotate the the variable for it

00:11:07,910 --> 00:11:11,600
so it doesn't have to guess so in this

00:11:10,070 --> 00:11:13,610
case we can say this dictionary is

00:11:11,600 --> 00:11:18,140
actually hid with strings and have

00:11:13,610 --> 00:11:21,050
integers as values this syntax with dot

00:11:18,140 --> 00:11:24,140
and the type of notation works only in

00:11:21,050 --> 00:11:27,250
Python 5.6 and up so if you're still

00:11:24,140 --> 00:11:31,340
using pi 23.5 we need to use the older

00:11:27,250 --> 00:11:32,780
type comment annotation although as far

00:11:31,340 --> 00:11:37,220
as the type checker is concerned this is

00:11:32,780 --> 00:11:39,260
pretty much the same next let's look an

00:11:37,220 --> 00:11:41,870
example for for collections which you'll

00:11:39,260 --> 00:11:44,120
use a lot in your day to day job so here

00:11:41,870 --> 00:11:46,580
we have basically function that needs to

00:11:44,120 --> 00:11:49,520
return a list of countries where your

00:11:46,580 --> 00:11:52,340
app is currently running for example so

00:11:49,520 --> 00:11:55,550
the first argument is dictionary of

00:11:52,340 --> 00:11:57,860
countries where the key is a country

00:11:55,550 --> 00:12:02,930
code and the value is the name of the

00:11:57,860 --> 00:12:05,570
country then we have a list of active

00:12:02,930 --> 00:12:07,580
users and their location is expressed as

00:12:05,570 --> 00:12:11,150
a list of tuples containing two floats

00:12:07,580 --> 00:12:14,180
for lifestyle magnitude and the last one

00:12:11,150 --> 00:12:16,900
is just blacklist set of the countries

00:12:14,180 --> 00:12:19,100
where your option we aren't yet and

00:12:16,900 --> 00:12:21,860
pretty much these three examples give

00:12:19,100 --> 00:12:24,700
you 80 to 90 percent of the collections

00:12:21,860 --> 00:12:28,100
using on a day to day basis

00:12:24,700 --> 00:12:30,500
next we have unions unions are

00:12:28,100 --> 00:12:32,810
constructs that allow you to say that

00:12:30,500 --> 00:12:37,400
something at runtime is gonna be either

00:12:32,810 --> 00:12:40,520
type A or type B so here I have an

00:12:37,400 --> 00:12:43,670
example that this function get by ID

00:12:40,520 --> 00:12:45,770
given a facebook ID will return an

00:12:43,670 --> 00:12:48,170
object you can try this yourself if you

00:12:45,770 --> 00:12:50,180
go to facebook.com slash and you put an

00:12:48,170 --> 00:12:53,270
American hit enter you're gonna end up

00:12:50,180 --> 00:12:55,100
on either a user or a page or something

00:12:53,270 --> 00:12:58,490
else here for simply steel I've limited

00:12:55,100 --> 00:13:01,160
to user end page so basically if I ask

00:12:58,490 --> 00:13:03,620
get by ID with my own ID I'm gonna get

00:13:01,160 --> 00:13:06,170
my user object back but if I put the ID

00:13:03,620 --> 00:13:08,510
of the Python Australia page to money

00:13:06,170 --> 00:13:10,550
get back a page and this is what Union

00:13:08,510 --> 00:13:12,320
lets us define basically if you're not

00:13:10,550 --> 00:13:15,620
sure what's gonna be returned it's gonna

00:13:12,320 --> 00:13:17,720
be our other type A or type B but did I

00:13:15,620 --> 00:13:19,940
type this completely correctly not

00:13:17,720 --> 00:13:22,250
really what happens if I put there and I

00:13:19,940 --> 00:13:24,530
deal does not exist minus 1 for example

00:13:22,250 --> 00:13:26,300
in that case would probably return none

00:13:24,530 --> 00:13:28,970
because it won't be found in a database

00:13:26,300 --> 00:13:32,690
and we can express this with the Union

00:13:28,970 --> 00:13:34,760
of user pH and none there is slightly

00:13:32,690 --> 00:13:36,530
better way of writing this though since

00:13:34,760 --> 00:13:40,100
it's a fairly common idiom which is

00:13:36,530 --> 00:13:41,990
optional of Union user and page and this

00:13:40,100 --> 00:13:44,840
is actually preferred to a union with a

00:13:41,990 --> 00:13:47,180
none although its implementation wise if

00:13:44,840 --> 00:13:49,610
it's off the same why this preferred

00:13:47,180 --> 00:13:51,320
because it's closer to the semantics of

00:13:49,610 --> 00:13:53,810
what you're doing you are fetching

00:13:51,320 --> 00:13:58,280
either a user web page if you can find

00:13:53,810 --> 00:14:00,680
it otherwise you're turning on the last

00:13:58,280 --> 00:14:03,410
examples I want to cover and type in

00:14:00,680 --> 00:14:05,120
primitives as type voice it's not a

00:14:03,410 --> 00:14:07,730
concept that's easy to explain in under

00:14:05,120 --> 00:14:10,600
a minute so I'll start by trying to

00:14:07,730 --> 00:14:14,150
explain what problem does type 4 solve

00:14:10,600 --> 00:14:15,710
so here we have a base class and a

00:14:14,150 --> 00:14:17,930
derived class it extends the base class

00:14:15,710 --> 00:14:19,850
then we have a factory method that

00:14:17,930 --> 00:14:23,120
accepts a class and just returns an

00:14:19,850 --> 00:14:24,980
instance of the same class typed this

00:14:23,120 --> 00:14:27,770
way with the type construct we say to

00:14:24,980 --> 00:14:30,440
expect as argument instead of an

00:14:27,770 --> 00:14:34,130
instance the actual type or the class

00:14:30,440 --> 00:14:36,710
object or something so if we asked for

00:14:34,130 --> 00:14:37,889
the factory to create something from the

00:14:36,710 --> 00:14:39,359
base class

00:14:37,889 --> 00:14:41,309
the type checker would think it returns

00:14:39,359 --> 00:14:43,139
the base class but then again the same

00:14:41,309 --> 00:14:44,759
would be true for a derived class

00:14:43,139 --> 00:14:47,009
because the type annotation is

00:14:44,759 --> 00:14:49,139
statically set to base class and this

00:14:47,009 --> 00:14:53,809
does work like he doesn't have any

00:14:49,139 --> 00:14:55,589
problems but we can do better because if

00:14:53,809 --> 00:14:57,389
we passed

00:14:55,589 --> 00:14:59,939
derived class in what it actually want

00:14:57,389 --> 00:15:01,589
is to have the type check we know that

00:14:59,939 --> 00:15:03,779
the output is going to be an instance of

00:15:01,589 --> 00:15:05,939
their art class so we need to do is type

00:15:03,779 --> 00:15:08,639
voice for that type words are

00:15:05,939 --> 00:15:11,220
essentially placeholders to express

00:15:08,639 --> 00:15:14,129
input output dependent pairs in Python

00:15:11,220 --> 00:15:16,319
so it's kind of saying like if I know

00:15:14,129 --> 00:15:18,869
the input I'm sure that our physical is

00:15:16,319 --> 00:15:21,600
gonna be something else so in this case

00:15:18,869 --> 00:15:25,230
we say that the input is type T so like

00:15:21,600 --> 00:15:28,850
a class object and then the output is

00:15:25,230 --> 00:15:33,179
going to be an instance of that class

00:15:28,850 --> 00:15:35,609
same as for other typing helpers it's

00:15:33,179 --> 00:15:37,589
imported from a typing module and you

00:15:35,609 --> 00:15:39,689
define it as type for and then the first

00:15:37,589 --> 00:15:41,970
argument is the name of the type part

00:15:39,689 --> 00:15:44,220
which needs to match the variable name

00:15:41,970 --> 00:15:45,959
it has this in implementation detail but

00:15:44,220 --> 00:15:49,619
the type checker will complain if it

00:15:45,959 --> 00:15:52,470
does not match and the bound keyword

00:15:49,619 --> 00:15:54,449
argument basically expresses that this

00:15:52,470 --> 00:15:56,699
type where I can represent and I think

00:15:54,449 --> 00:15:58,139
that's at least kind of a base class so

00:15:56,699 --> 00:16:02,059
it can be anything

00:15:58,139 --> 00:16:04,049
base class and extended from base class

00:16:02,059 --> 00:16:05,309
I've mentioned the type checker is

00:16:04,049 --> 00:16:07,259
really quite a few time but I haven't

00:16:05,309 --> 00:16:09,179
shown you how to actually run it

00:16:07,259 --> 00:16:11,939
so let's look again at another example

00:16:09,179 --> 00:16:15,119
we have in tested py we import the math

00:16:11,939 --> 00:16:19,040
module and we ask the square root of

00:16:15,119 --> 00:16:22,169
hundred as an integer and as a string

00:16:19,040 --> 00:16:24,299
obviously the string before I end would

00:16:22,169 --> 00:16:25,589
throw an exception at runtime but even

00:16:24,299 --> 00:16:28,259
the type checker is able to catch this

00:16:25,589 --> 00:16:30,209
so doesn't even need to run the code for

00:16:28,259 --> 00:16:33,139
this example I'm using my PI which is

00:16:30,209 --> 00:16:36,419
the most common reused type checker

00:16:33,139 --> 00:16:38,339
currently in the community and just try

00:16:36,419 --> 00:16:40,319
it by calling my PI and path to the file

00:16:38,339 --> 00:16:43,470
you wanna type check and basically it's

00:16:40,319 --> 00:16:45,480
gonna throw an error saying that SPT

00:16:43,470 --> 00:16:48,660
cannot accept the string as argument but

00:16:45,480 --> 00:16:51,329
expected to float in this case this

00:16:48,660 --> 00:16:51,810
covers all the kind of core concepts I

00:16:51,329 --> 00:16:55,500
want to

00:16:51,810 --> 00:16:57,180
in typing 101 next I just wanna briefly

00:16:55,500 --> 00:16:59,820
mention some advanced topics that you

00:16:57,180 --> 00:17:03,690
can check out on your own in case you

00:16:59,820 --> 00:17:06,209
end up in in trouble with with typing so

00:17:03,690 --> 00:17:07,949
forward references is commonly used when

00:17:06,209 --> 00:17:10,530
you need to referencing clause from

00:17:07,949 --> 00:17:12,180
itself so think a static method on a

00:17:10,530 --> 00:17:14,640
class that returns an instance of that

00:17:12,180 --> 00:17:16,020
class you cannot directly reference in

00:17:14,640 --> 00:17:17,730
the type of annotation the class name

00:17:16,020 --> 00:17:21,150
but you need to stringify it with the

00:17:17,730 --> 00:17:23,339
forward reference then we have the type

00:17:21,150 --> 00:17:25,730
checking signal from the typing module

00:17:23,339 --> 00:17:28,470
that basically allows you to break

00:17:25,730 --> 00:17:32,010
import cycles that happen because of

00:17:28,470 --> 00:17:34,920
typing we have the overload decorator

00:17:32,010 --> 00:17:38,040
which works in similar fashion as type

00:17:34,920 --> 00:17:39,960
verse and lets you fix what the function

00:17:38,040 --> 00:17:42,330
signature looks like when you know a

00:17:39,960 --> 00:17:45,510
single argument for example if you know

00:17:42,330 --> 00:17:46,950
that an argument a is none then you're

00:17:45,510 --> 00:17:48,600
sure that the output is going to be none

00:17:46,950 --> 00:17:51,840
as well and that's what he was overload

00:17:48,600 --> 00:17:53,790
for and then this wire part is a new

00:17:51,840 --> 00:17:56,190
type checker developed at Facebook and

00:17:53,790 --> 00:18:00,630
open sourced a few months ago at Python

00:17:56,190 --> 00:18:02,460
us and its main advantage compared to my

00:18:00,630 --> 00:18:05,490
PI is that it's much much faster at

00:18:02,460 --> 00:18:07,590
scale for comparison running my PI on

00:18:05,490 --> 00:18:10,920
the Instagram codebase takes roughly

00:18:07,590 --> 00:18:15,170
five minutes for choir is 45 seconds so

00:18:10,920 --> 00:18:15,170
it's almost an order of magnitude faster

00:18:15,470 --> 00:18:20,520
the next section is about typing in the

00:18:18,540 --> 00:18:23,310
real world how do you actually get

00:18:20,520 --> 00:18:26,490
started using type in your projects

00:18:23,310 --> 00:18:28,560
let's cover the the easy bit first this

00:18:26,490 --> 00:18:30,900
is the new project like you start

00:18:28,560 --> 00:18:33,270
something new either personal or or for

00:18:30,900 --> 00:18:35,429
work and you want to use typing so how

00:18:33,270 --> 00:18:38,429
you get it done it's quite easy really

00:18:35,429 --> 00:18:40,830
you typed everything from day one all

00:18:38,429 --> 00:18:43,320
the colored lines needs to be 100% typed

00:18:40,830 --> 00:18:44,700
and you need to instrument the type

00:18:43,320 --> 00:18:47,310
checker in your continuous integration

00:18:44,700 --> 00:18:47,850
so all the good work you did doesn't go

00:18:47,310 --> 00:18:49,260
to waste

00:18:47,850 --> 00:18:51,360
you can have the type checker

00:18:49,260 --> 00:18:55,650
automatically track you pull requests

00:18:51,360 --> 00:18:58,440
break if they check if they break typing

00:18:55,650 --> 00:19:00,120
constraints and also comment on the pull

00:18:58,440 --> 00:19:03,179
request if the new code is not

00:19:00,120 --> 00:19:05,340
completely typed and that's pretty much

00:19:03,179 --> 00:19:08,130
it for new project is quite easy

00:19:05,340 --> 00:19:12,810
set us up and automation works for you

00:19:08,130 --> 00:19:16,230
and rips profit in the future now let's

00:19:12,810 --> 00:19:18,480
look at the hard part existing / large

00:19:16,230 --> 00:19:21,810
projects and this is honestly the more

00:19:18,480 --> 00:19:23,400
common case in the industry so how do

00:19:21,810 --> 00:19:25,140
you get started on a large code base

00:19:23,400 --> 00:19:26,430
that you don't own you didn't write you

00:19:25,140 --> 00:19:27,900
just join a new team and you have

00:19:26,430 --> 00:19:30,300
thousands of thousands of lines of code

00:19:27,900 --> 00:19:32,100
you don't understand it's a good time to

00:19:30,300 --> 00:19:34,050
introduce typing because you have to

00:19:32,100 --> 00:19:36,290
dive into the code understand it anyway

00:19:34,050 --> 00:19:39,180
so you might as well type it as you go

00:19:36,290 --> 00:19:41,940
so first we need to understand gradual

00:19:39,180 --> 00:19:43,530
typing and how it helps I cannot start

00:19:41,940 --> 00:19:47,660
from from an example to make it more

00:19:43,530 --> 00:19:52,200
visual we have a main dot py that

00:19:47,660 --> 00:19:55,620
depends on scheduler and job they both

00:19:52,200 --> 00:19:57,000
depend in turn on you tools dot py and

00:19:55,620 --> 00:19:58,980
then the scheduler also needs to know

00:19:57,000 --> 00:19:59,990
about the job to be able to work

00:19:58,980 --> 00:20:04,830
correctly

00:19:59,990 --> 00:20:07,620
now let's go in the code for the left

00:20:04,830 --> 00:20:10,260
part of the graph so utils and jobs in

00:20:07,620 --> 00:20:13,470
new tools we have pretty print function

00:20:10,260 --> 00:20:17,460
that we say here accepts a job whatever

00:20:13,470 --> 00:20:19,740
a job is and just dumps it to Jason with

00:20:17,460 --> 00:20:23,520
nice indent so it displays nicely in the

00:20:19,740 --> 00:20:25,740
terminal and then in job py we have a

00:20:23,520 --> 00:20:28,620
create job function visitor's case job

00:20:25,740 --> 00:20:32,730
pretty prints job created and then

00:20:28,620 --> 00:20:35,130
returns the job and you may see it like

00:20:32,730 --> 00:20:38,130
there's a quite obvious diaper here like

00:20:35,130 --> 00:20:41,190
we're passing an string where a job is

00:20:38,130 --> 00:20:43,500
expected but if you run the type checker

00:20:41,190 --> 00:20:46,550
over the code as it is now it will

00:20:43,500 --> 00:20:49,160
actually not complain and why is that

00:20:46,550 --> 00:20:51,570
visible gradual typing comes into play

00:20:49,160 --> 00:20:54,420
the concept of gradual typing basically

00:20:51,570 --> 00:20:57,810
says that if a function is not annotated

00:20:54,420 --> 00:21:00,630
which create job is not its body will be

00:20:57,810 --> 00:21:03,840
completely ignored so basically F create

00:21:00,630 --> 00:21:07,470
job does not have a return type all type

00:21:03,840 --> 00:21:09,210
errors how obvious they may be in the

00:21:07,470 --> 00:21:12,600
body are going to be complete escaped

00:21:09,210 --> 00:21:13,980
only type errors and pretty print here

00:21:12,600 --> 00:21:16,350
will actually have been flagged by the

00:21:13,980 --> 00:21:18,580
type checker and this is extremely

00:21:16,350 --> 00:21:20,950
valuable when you need to start typing

00:21:18,580 --> 00:21:23,620
large projects why because usually you

00:21:20,950 --> 00:21:25,149
start from the utilities the one don't

00:21:23,620 --> 00:21:27,640
have that many dependencies that don't

00:21:25,149 --> 00:21:29,740
understand easily and without gradual

00:21:27,640 --> 00:21:32,289
typing changing the single utility and

00:21:29,740 --> 00:21:34,480
typing it in a large code base could

00:21:32,289 --> 00:21:36,580
trigger errors across the whole code

00:21:34,480 --> 00:21:38,230
base but with gradual typing you

00:21:36,580 --> 00:21:40,620
actually don't do that you delay

00:21:38,230 --> 00:21:43,600
triggering the errors and fixing them

00:21:40,620 --> 00:21:46,269
until the actual file where the type

00:21:43,600 --> 00:21:49,929
error happens is typed and this lets you

00:21:46,269 --> 00:21:51,880
delay the cost availing types to a later

00:21:49,929 --> 00:21:53,740
point in time where your rape will have

00:21:51,880 --> 00:21:55,779
like a higher percentage of type

00:21:53,740 --> 00:21:59,049
coverage and in theory it should be much

00:21:55,779 --> 00:22:00,549
easier to resolve type errors so if you

00:21:59,049 --> 00:22:03,669
actually wanted to trigger a type error

00:22:00,549 --> 00:22:06,820
here all we needed to do is put the

00:22:03,669 --> 00:22:09,610
return type for create job and the type

00:22:06,820 --> 00:22:10,389
checker would correctly identify that

00:22:09,610 --> 00:22:13,630
prettyprint

00:22:10,389 --> 00:22:21,909
has what was signature gets a string and

00:22:13,630 --> 00:22:24,340
was expecting job instead so let's get

00:22:21,909 --> 00:22:27,730
back to the plan on how to tackle large

00:22:24,340 --> 00:22:29,529
projects so you start from the common

00:22:27,730 --> 00:22:31,570
libraries those that will not have like

00:22:29,529 --> 00:22:34,740
too much cognitive overhead usually

00:22:31,570 --> 00:22:37,929
depends only on standard library and

00:22:34,740 --> 00:22:40,570
depend on themselves usually so the

00:22:37,929 --> 00:22:43,720
utah's py of your projects you spend a

00:22:40,570 --> 00:22:45,460
few hours typing you thought quite

00:22:43,720 --> 00:22:48,610
correctly you run the type checker

00:22:45,460 --> 00:22:52,389
iterate until it is typed correctly you

00:22:48,610 --> 00:22:55,389
iron out all the errors and then same as

00:22:52,389 --> 00:22:57,700
for the easy bit you setup CI so you

00:22:55,389 --> 00:22:59,919
have your contingent integration system

00:22:57,700 --> 00:23:01,600
actually guard against regressions so

00:22:59,919 --> 00:23:04,330
that the work you did does not go to

00:23:01,600 --> 00:23:07,179
waste and say this brought you from 0%

00:23:04,330 --> 00:23:09,630
typed code to five percent type code how

00:23:07,179 --> 00:23:12,730
do you actually go from five to 100 and

00:23:09,630 --> 00:23:15,429
here it's important to ask people on

00:23:12,730 --> 00:23:18,070
your team to actually help you out there

00:23:15,429 --> 00:23:20,710
is no better time than for writing types

00:23:18,070 --> 00:23:22,990
then as you actually write the code it's

00:23:20,710 --> 00:23:25,299
the cheapest possible time in terms of

00:23:22,990 --> 00:23:27,730
engineering effort reading types because

00:23:25,299 --> 00:23:30,220
the code you just wrote is fresh in your

00:23:27,730 --> 00:23:32,640
mind so you can just dump basically what

00:23:30,220 --> 00:23:34,350
is your mind is type annotations and

00:23:32,640 --> 00:23:35,940
even from your own code if you need to

00:23:34,350 --> 00:23:37,890
revisit it in a week it will take you a

00:23:35,940 --> 00:23:41,130
few minutes to like figure out what you

00:23:37,890 --> 00:23:44,660
wanted to do it's not important to note

00:23:41,130 --> 00:23:47,850
on for this one that your organization

00:23:44,660 --> 00:23:49,500
team your manager need to actually be

00:23:47,850 --> 00:23:51,960
aware of this and they need to encourage

00:23:49,500 --> 00:23:54,750
this behavior so that you kind of feel

00:23:51,960 --> 00:23:56,130
empowered to invest your time into

00:23:54,750 --> 00:23:57,750
increasing the quality of the code and

00:23:56,130 --> 00:24:01,860
not just ship new features as quickly as

00:23:57,750 --> 00:24:04,890
possible the last point here is to use

00:24:01,860 --> 00:24:08,340
monkey type and I'll cover this next so

00:24:04,890 --> 00:24:10,770
monkey type is a system that Instagram

00:24:08,340 --> 00:24:14,430
created for collecting type information

00:24:10,770 --> 00:24:17,100
runtime Instagram has the largest jungle

00:24:14,430 --> 00:24:18,930
up quickly figured out that typing

00:24:17,100 --> 00:24:21,300
millions of lines of Python is like not

00:24:18,930 --> 00:24:23,610
an easy job and not an enjoyable one

00:24:21,300 --> 00:24:25,440
because it's mostly manual so they found

00:24:23,610 --> 00:24:27,720
a clever way of automating this and the

00:24:25,440 --> 00:24:28,980
open source did at the end of last year

00:24:27,720 --> 00:24:31,620
so that the community can benefit from

00:24:28,980 --> 00:24:34,440
it how monkey type works basically it

00:24:31,620 --> 00:24:36,090
collects type information runtimes and

00:24:34,440 --> 00:24:38,880
log them somewhere other file or

00:24:36,090 --> 00:24:41,940
database then runs an aggregation or

00:24:38,880 --> 00:24:44,220
these types to figure out what the type

00:24:41,940 --> 00:24:46,470
stubs should look for a module and then

00:24:44,220 --> 00:24:49,290
just applies them back to record all

00:24:46,470 --> 00:24:51,060
done automatically pretty much I've

00:24:49,290 --> 00:24:53,310
mentioned what stubs are but I haven't

00:24:51,060 --> 00:24:56,400
shown one yet so this is what a stub

00:24:53,310 --> 00:24:57,870
look like for the math module of the

00:24:56,400 --> 00:25:01,260
standard library this is just the first

00:24:57,870 --> 00:25:05,040
few lines a stub is essentially a file

00:25:01,260 --> 00:25:08,250
with dot pi why I extension that has

00:25:05,040 --> 00:25:09,720
just typing information in it so it has

00:25:08,250 --> 00:25:11,070
function signatures but no

00:25:09,720 --> 00:25:14,010
implementation no body of the function

00:25:11,070 --> 00:25:16,680
so here we can look at PI for example

00:25:14,010 --> 00:25:21,300
which is typed as a float which is

00:25:16,680 --> 00:25:23,700
expected 3.14 and so on so let's go back

00:25:21,300 --> 00:25:26,190
to monkey type how do you actually use

00:25:23,700 --> 00:25:28,740
it first you have to people install it

00:25:26,190 --> 00:25:31,320
same as all the Python packages then you

00:25:28,740 --> 00:25:34,530
use the monkey type run wrapper to run

00:25:31,320 --> 00:25:37,140
wrap this will collect by default types

00:25:34,530 --> 00:25:40,470
in a sequel I'd database in the Korean

00:25:37,140 --> 00:25:43,910
directory then you run Mike this table

00:25:40,470 --> 00:25:46,220
to generate the stub for your module

00:25:43,910 --> 00:25:50,090
here I'm using the utility

00:25:46,220 --> 00:25:51,500
module from a few slides back and this

00:25:50,090 --> 00:25:53,810
case is gonna think that the job is a

00:25:51,500 --> 00:25:58,090
string because that's the only type

00:25:53,810 --> 00:26:00,830
information that it's so at runtime and

00:25:58,090 --> 00:26:02,810
then you have monkey type apply and that

00:26:00,830 --> 00:26:04,310
again the module name to just take the

00:26:02,810 --> 00:26:08,120
generated type information and ply it

00:26:04,310 --> 00:26:09,770
back to your code last section

00:26:08,120 --> 00:26:11,930
tips and tricks I learned in the last

00:26:09,770 --> 00:26:14,810
two years and this will hopefully avoid

00:26:11,930 --> 00:26:17,150
you some common pitfalls and googling

00:26:14,810 --> 00:26:20,660
for answers the first one I want to

00:26:17,150 --> 00:26:23,480
cover is how does duck typing world work

00:26:20,660 --> 00:26:26,330
in the new statically typed world we all

00:26:23,480 --> 00:26:28,040
know the if it looks like a duck swims

00:26:26,330 --> 00:26:30,200
like a duck and quacks like a duck it's

00:26:28,040 --> 00:26:33,140
probably doc there's a duck typing that

00:26:30,200 --> 00:26:35,360
makes python so easy and and fast to

00:26:33,140 --> 00:26:39,590
write but how did this play out with

00:26:35,360 --> 00:26:42,320
with static types again example time so

00:26:39,590 --> 00:26:45,880
we have these dark things that accepts a

00:26:42,320 --> 00:26:50,140
duck and calls quack and swim over it

00:26:45,880 --> 00:26:55,040
then we have fair duck and a gecko duck

00:26:50,140 --> 00:26:56,720
both products of quack and both swim but

00:26:55,040 --> 00:26:59,120
they don't extend that actually from

00:26:56,720 --> 00:27:02,690
duck so this will work fine at run time

00:26:59,120 --> 00:27:07,400
type checker not so much and this is

00:27:02,690 --> 00:27:09,830
what it does look like by the way so if

00:27:07,400 --> 00:27:12,290
we call duck things passing an instance

00:27:09,830 --> 00:27:14,780
of failure duck although at run time it

00:27:12,290 --> 00:27:16,370
would work perfectly fine the type check

00:27:14,780 --> 00:27:19,010
we say like no this does not extend from

00:27:16,370 --> 00:27:21,020
duck you cannot use it so how do we

00:27:19,010 --> 00:27:24,650
address this this is where we can use

00:27:21,020 --> 00:27:26,240
protocols you need to install typing

00:27:24,650 --> 00:27:28,250
extensions to use protocol it's still

00:27:26,240 --> 00:27:29,630
fairly experimental but in my experience

00:27:28,250 --> 00:27:32,720
it it works fine it was in production

00:27:29,630 --> 00:27:35,450
code and protocols basically allowed to

00:27:32,720 --> 00:27:36,980
specify what kind of looks like an

00:27:35,450 --> 00:27:40,160
interface from other languages like Java

00:27:36,980 --> 00:27:43,550
and you say like my object is a dock

00:27:40,160 --> 00:27:47,230
that quacks and fly and then any object

00:27:43,550 --> 00:27:51,200
that has those two methods will be

00:27:47,230 --> 00:27:53,060
accepted by dock things this is also

00:27:51,200 --> 00:27:56,480
known as the actual versus nominal

00:27:53,060 --> 00:27:59,220
subtyping and it allows you to still

00:27:56,480 --> 00:28:01,289
keep using duck typing

00:27:59,220 --> 00:28:05,820
even in a statically typed word which is

00:28:01,289 --> 00:28:09,360
quite nice next we have the type shot

00:28:05,820 --> 00:28:11,100
and this is also one of the one of two

00:28:09,360 --> 00:28:14,309
key things of Pilon typing if you ever

00:28:11,100 --> 00:28:16,470
end up having a typing error against the

00:28:14,309 --> 00:28:18,390
standard library and you got shocked

00:28:16,470 --> 00:28:19,919
well the standard library looks like the

00:28:18,390 --> 00:28:21,720
typing information actually not there

00:28:19,919 --> 00:28:24,000
the typing information for the standard

00:28:21,720 --> 00:28:26,280
library is in a separate repo called the

00:28:24,000 --> 00:28:28,500
type shut and it's bundle your type

00:28:26,280 --> 00:28:31,440
checker so you also need to check what

00:28:28,500 --> 00:28:33,720
version the type checker has and see if

00:28:31,440 --> 00:28:37,049
it's correct it's still very far from

00:28:33,720 --> 00:28:38,610
perfect most notably multi processing

00:28:37,049 --> 00:28:40,500
and multi-threading are still like

00:28:38,610 --> 00:28:42,690
partially typed so if you find an issue

00:28:40,500 --> 00:28:44,010
send a pull request usually the core

00:28:42,690 --> 00:28:47,490
contributors are quite quick to merge

00:28:44,010 --> 00:28:50,010
them back and the last one is type

00:28:47,490 --> 00:28:51,750
ignoring if you come from a statically

00:28:50,010 --> 00:28:53,700
typed background like this may not be

00:28:51,750 --> 00:28:55,919
super trivial to understand but in

00:28:53,700 --> 00:28:58,770
Python like not necessarily all typing

00:28:55,919 --> 00:29:00,330
errors are evil like in some cases it

00:28:58,770 --> 00:29:02,850
might actually be totally okay to

00:29:00,330 --> 00:29:05,220
silence a type error rather than trying

00:29:02,850 --> 00:29:06,510
to fix it completely and this is a

00:29:05,220 --> 00:29:09,330
discussion I had with the pull request

00:29:06,510 --> 00:29:10,700
with with ghido a few months ago what I

00:29:09,330 --> 00:29:13,350
was trying to type-check

00:29:10,700 --> 00:29:16,020
against an internal attribute of the

00:29:13,350 --> 00:29:17,970
queue and he was basically against

00:29:16,020 --> 00:29:20,549
merging his back in the type shed

00:29:17,970 --> 00:29:22,679
because in his opinion it should also

00:29:20,549 --> 00:29:26,159
kind of the types enforce work as a

00:29:22,679 --> 00:29:29,700
public API rather than explain all

00:29:26,159 --> 00:29:31,950
possible internal details and that's why

00:29:29,700 --> 00:29:34,309
he was happy for me to put a type ignore

00:29:31,950 --> 00:29:37,970
in my code rather than typing it

00:29:34,309 --> 00:29:40,470
completely correctly in the type

00:29:37,970 --> 00:29:42,539
okay that's all the material wants to

00:29:40,470 --> 00:29:44,480
cover so just let's just recap what we

00:29:42,539 --> 00:29:48,059
learned today

00:29:44,480 --> 00:29:49,530
type annotations are quite annoying not

00:29:48,059 --> 00:29:52,620
because just because I say so but

00:29:49,530 --> 00:29:55,230
because gido says so start using them

00:29:52,620 --> 00:29:57,419
for the readability win which is the

00:29:55,230 --> 00:29:59,580
greatest thing ever in Pilon and get the

00:29:57,419 --> 00:30:02,549
extra safety of a type checker in your

00:29:59,580 --> 00:30:05,730
continued integration for free the is a

00:30:02,549 --> 00:30:07,770
bit for new projects of any complexity

00:30:05,730 --> 00:30:09,680
beside like above one file should

00:30:07,770 --> 00:30:12,620
probably hundred percent typed

00:30:09,680 --> 00:30:14,450
and for the harder part like the large

00:30:12,620 --> 00:30:17,030
existing code bases you can leverage

00:30:14,450 --> 00:30:19,160
gradual typing to start small and then

00:30:17,030 --> 00:30:21,080
build up with it and you can use monkey

00:30:19,160 --> 00:30:22,400
type to give you the initial push of the

00:30:21,080 --> 00:30:26,630
automation so you don't have to do

00:30:22,400 --> 00:30:29,360
everything manually so the slides are

00:30:26,630 --> 00:30:30,890
already on my github and the code

00:30:29,360 --> 00:30:33,860
samples are going to be at some point

00:30:30,890 --> 00:30:34,560
later today that's all I have thank you

00:30:33,860 --> 00:30:45,370
very much

00:30:34,560 --> 00:30:48,410
[Applause]

00:30:45,370 --> 00:30:50,720
thanks Luka and let's fake it did

00:30:48,410 --> 00:30:52,250
indicate that he'd be using the whole 30

00:30:50,720 --> 00:30:54,559
minutes so we don't have time for

00:30:52,250 --> 00:30:57,410
questions but if he can track him down

00:30:54,559 --> 00:31:00,260
yeah I'll be around great thanks a lot

00:30:57,410 --> 00:31:03,940
it's lunchtime now so I'm sure you've

00:31:00,260 --> 00:31:03,940

YouTube URL: https://www.youtube.com/watch?v=h1cD3a7ys8Q


