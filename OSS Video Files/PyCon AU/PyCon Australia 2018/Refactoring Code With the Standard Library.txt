Title: Refactoring Code With the Standard Library
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	John Reese

https://2018.pycon-au.org/talks/45063-refactoring-code-with-the-standard-library/

What if you could refactor your entire code base, safely and automatically? How much old code could you fix or replace if you didn't need to worry about updating every reference by hand? I'll show you how a concrete syntax tree (CST) can help you do just that using only the standard Python library.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:03,689
all right we're going to get started

00:00:01,560 --> 00:00:08,069
with house to talk for the afternoon

00:00:03,689 --> 00:00:11,460
session John Reese from Facebook it's

00:00:08,069 --> 00:00:21,480
going to talk to us about restructuring

00:00:11,460 --> 00:00:23,160
our code using the standard library so

00:00:21,480 --> 00:00:25,230
I'm a production engineer at Facebook

00:00:23,160 --> 00:00:28,320
and I work on our internal Python

00:00:25,230 --> 00:00:29,820
Foundation team for context Python is

00:00:28,320 --> 00:00:31,769
the third biggest language at Facebook

00:00:29,820 --> 00:00:34,530
and the number one language at Instagram

00:00:31,769 --> 00:00:36,719
and the Python foundation team helps to

00:00:34,530 --> 00:00:38,670
build tools and integrations that make

00:00:36,719 --> 00:00:41,010
Python better both inside and outside of

00:00:38,670 --> 00:00:42,899
the company so today talking about

00:00:41,010 --> 00:00:45,809
refactoring code using the standard

00:00:42,899 --> 00:00:48,300
library so the definition I'm using is

00:00:45,809 --> 00:00:51,300
just general improvements or

00:00:48,300 --> 00:00:54,030
modifications to source code either

00:00:51,300 --> 00:00:57,629
simple or complicated and either hand

00:00:54,030 --> 00:00:59,280
edited or automated but essentially is

00:00:57,629 --> 00:01:01,289
some sort of modification to the entire

00:00:59,280 --> 00:01:04,019
repository rather than just one

00:01:01,289 --> 00:01:05,900
individual file so some of the cases

00:01:04,019 --> 00:01:08,250
where you might want to do this would be

00:01:05,900 --> 00:01:10,170
enforcing some sort of consistent style

00:01:08,250 --> 00:01:12,900
or formatting across your codebase

00:01:10,170 --> 00:01:16,380
whether you're fighting the tabs or

00:01:12,900 --> 00:01:18,360
spaces war or instituting something like

00:01:16,380 --> 00:01:20,340
the black formatter it could also be

00:01:18,360 --> 00:01:23,250
cases removing some sort of like code

00:01:20,340 --> 00:01:26,159
smells like named lambdas and replacing

00:01:23,250 --> 00:01:28,770
them some sort of actual functions cord

00:01:26,159 --> 00:01:30,270
could just be removal of dead code and

00:01:28,770 --> 00:01:32,369
making sure that all the references to

00:01:30,270 --> 00:01:35,880
it are removed from the rest of the

00:01:32,369 --> 00:01:38,210
codebase the example that I'm probably

00:01:35,880 --> 00:01:40,290
going to come back to multiple times is

00:01:38,210 --> 00:01:42,479
essentially will have like some sort of

00:01:40,290 --> 00:01:44,159
string literal where you might want to

00:01:42,479 --> 00:01:46,049
actually have it translated when you're

00:01:44,159 --> 00:01:49,200
outputting it to the user rather than

00:01:46,049 --> 00:01:50,430
just giving it directly and maybe you

00:01:49,200 --> 00:01:51,329
have some comments saying that you

00:01:50,430 --> 00:01:54,869
should actually take care of that

00:01:51,329 --> 00:01:57,119
someday but ideally we want to you know

00:01:54,869 --> 00:01:59,969
wrap that sort of string literal in a

00:01:57,119 --> 00:02:02,700
function call and then for bonus points

00:01:59,969 --> 00:02:04,979
remove the comment in front of it sort

00:02:02,700 --> 00:02:06,570
of things is the kind of thing we tend

00:02:04,979 --> 00:02:10,250
to do at Facebook we call code mods

00:02:06,570 --> 00:02:12,870
where it's an automated refactoring and

00:02:10,250 --> 00:02:13,890
we have essentially a monolithic

00:02:12,870 --> 00:02:15,900
repository for

00:02:13,890 --> 00:02:17,400
most of our stuff at Facebook this

00:02:15,900 --> 00:02:20,760
essentially means all of our projects

00:02:17,400 --> 00:02:23,700
are in one repo this also means that if

00:02:20,760 --> 00:02:25,319
you were to change an API and somebody's

00:02:23,700 --> 00:02:27,270
depending on that you would immediately

00:02:25,319 --> 00:02:30,090
break their builds or their tests or

00:02:27,270 --> 00:02:31,140
something and so you have to make sure

00:02:30,090 --> 00:02:32,910
that you're updating all of these

00:02:31,140 --> 00:02:36,120
references and doing this in an

00:02:32,910 --> 00:02:38,940
automated way allows you to most easily

00:02:36,120 --> 00:02:44,730
do make these changes without breaking

00:02:38,940 --> 00:02:46,680
any tests or builds so more specifically

00:02:44,730 --> 00:02:49,320
today I'd like to talk about syntax tree

00:02:46,680 --> 00:02:51,000
refactoring as come as compared to

00:02:49,320 --> 00:02:55,320
something like using regular expressions

00:02:51,000 --> 00:02:58,290
or simple find/replace essentially it's

00:02:55,320 --> 00:03:00,720
modifying the code as these tree

00:02:58,290 --> 00:03:03,060
structures of nested objects and it's

00:03:00,720 --> 00:03:05,220
generally based somewhat on the actual

00:03:03,060 --> 00:03:07,620
Python grammar itself and this gives you

00:03:05,220 --> 00:03:09,660
semantic context for each of the objects

00:03:07,620 --> 00:03:11,519
that you're editing and if you do it

00:03:09,660 --> 00:03:12,780
right then you're essentially guaranteed

00:03:11,519 --> 00:03:14,459
that you're going to generate valid

00:03:12,780 --> 00:03:18,209
syntax out at the end as opposed to

00:03:14,459 --> 00:03:20,910
regular expressions so for the grammar

00:03:18,209 --> 00:03:22,950
itself most languages have this grammar

00:03:20,910 --> 00:03:25,950
that defines what tokens and syntax

00:03:22,950 --> 00:03:28,769
should be allowed the the most common

00:03:25,950 --> 00:03:31,079
form is backus-naur form and essentially

00:03:28,769 --> 00:03:32,519
it's a set of rules that expand to more

00:03:31,079 --> 00:03:36,000
rules or string literals or a

00:03:32,519 --> 00:03:38,610
combination of the form and let's just

00:03:36,000 --> 00:03:40,860
say we wanted to look at numbers you

00:03:38,610 --> 00:03:42,540
would define some rule that has all of

00:03:40,860 --> 00:03:44,310
the string literal digits that you would

00:03:42,540 --> 00:03:47,070
accept it might be different for binary

00:03:44,310 --> 00:03:48,750
or hexadecimal and then if you actually

00:03:47,070 --> 00:03:51,360
want to build a larger number out of

00:03:48,750 --> 00:03:53,610
that you would recursively use either a

00:03:51,360 --> 00:03:55,590
single digit or a combination of a digit

00:03:53,610 --> 00:03:56,700
and the recursive number rule if you

00:03:55,590 --> 00:03:58,320
wanted to add them together you could

00:03:56,700 --> 00:04:00,060
have another rule that defines the

00:03:58,320 --> 00:04:03,120
number at the string literal plus sign

00:04:00,060 --> 00:04:04,380
and another number and you don't

00:04:03,120 --> 00:04:05,790
generally have to worry about whitespace

00:04:04,380 --> 00:04:07,920
in these cases because the tokenizer

00:04:05,790 --> 00:04:09,870
will take care of that in the case of

00:04:07,920 --> 00:04:12,090
Python it actually uses a modified form

00:04:09,870 --> 00:04:14,040
of this the tokenizer

00:04:12,090 --> 00:04:16,609
deals with more than just whitespace it

00:04:14,040 --> 00:04:19,350
also gives you some helpful tokens for

00:04:16,609 --> 00:04:22,979
numbers string literals variable names

00:04:19,350 --> 00:04:25,110
and more the rules can also use more

00:04:22,979 --> 00:04:27,750
complicated structures like parentheses

00:04:25,110 --> 00:04:30,930
for optional pieces

00:04:27,750 --> 00:04:33,180
I'm sorry for alternative structures or

00:04:30,930 --> 00:04:36,300
you can use the square brackets a star

00:04:33,180 --> 00:04:39,030
for four optional elements and if we

00:04:36,300 --> 00:04:40,500
wanted to look at how the actual things

00:04:39,030 --> 00:04:42,960
like function calls would be defined in

00:04:40,500 --> 00:04:46,260
the grammar this is an excerpt excerpt

00:04:42,960 --> 00:04:47,790
from the actual grammar file kind of

00:04:46,260 --> 00:04:50,160
abridged so that it'll actually fit on

00:04:47,790 --> 00:04:52,260
the slide the way that Python combines

00:04:50,160 --> 00:04:54,390
things together you would actually use

00:04:52,260 --> 00:04:56,550
this power rule at the bottom or at the

00:04:54,390 --> 00:04:58,260
top expand it out towards the atom

00:04:56,550 --> 00:05:01,620
expression which would allow you to

00:04:58,260 --> 00:05:03,030
optionally a weight whatever whatever

00:05:01,620 --> 00:05:05,010
you're working with the atom would

00:05:03,030 --> 00:05:07,260
contain things like the actual variable

00:05:05,010 --> 00:05:09,780
or function name they're editing or

00:05:07,260 --> 00:05:12,360
working with or can also be a number or

00:05:09,780 --> 00:05:13,980
string and then there's some number of

00:05:12,360 --> 00:05:15,210
optional trailers at the end and these

00:05:13,980 --> 00:05:18,720
would represent things like either

00:05:15,210 --> 00:05:21,300
function calls list access or similar if

00:05:18,720 --> 00:05:23,669
you expand further through the trailer

00:05:21,300 --> 00:05:25,350
has the the string literals for the

00:05:23,669 --> 00:05:27,030
parentheses in case of a function call

00:05:25,350 --> 00:05:29,640
and then some optional argument lists

00:05:27,030 --> 00:05:31,560
which then continues expanding through

00:05:29,640 --> 00:05:34,440
and through and the arguments himself

00:05:31,560 --> 00:05:36,690
you know comma separated and would also

00:05:34,440 --> 00:05:39,660
include things like any type annotations

00:05:36,690 --> 00:05:42,450
or or default values or the star args

00:05:39,660 --> 00:05:45,390
things like that so the way this would

00:05:42,450 --> 00:05:48,120
actually look with the code example from

00:05:45,390 --> 00:05:49,860
before we're going to assume it's Python

00:05:48,120 --> 00:05:53,220
3 so we actually get a print function

00:05:49,860 --> 00:05:55,880
instead of a statement not sure if the

00:05:53,220 --> 00:05:58,410
rules are actually legible but

00:05:55,880 --> 00:06:00,180
essentially you expand that starting

00:05:58,410 --> 00:06:04,680
with the power where it encompasses the

00:06:00,180 --> 00:06:06,570
entire function call and as you expand

00:06:04,680 --> 00:06:08,580
through the atom expression again also

00:06:06,570 --> 00:06:11,250
encompasses both because we're not doing

00:06:08,580 --> 00:06:12,720
any factorials the atom expression would

00:06:11,250 --> 00:06:16,229
expand into the atom at the beginning

00:06:12,720 --> 00:06:18,150
for the the variable print which is just

00:06:16,229 --> 00:06:22,080
part of the regular namespace which

00:06:18,150 --> 00:06:24,150
again is itself a name token the

00:06:22,080 --> 00:06:25,919
following part would be the trailer

00:06:24,150 --> 00:06:29,460
which contains the parentheses and the

00:06:25,919 --> 00:06:31,229
arguments and then the arglist is just

00:06:29,460 --> 00:06:33,300
inside the parentheses which then

00:06:31,229 --> 00:06:36,990
contains the one argument which is the

00:06:33,300 --> 00:06:38,010
string literal so when you actually get

00:06:36,990 --> 00:06:41,220
to the point of working with syntax

00:06:38,010 --> 00:06:41,700
trees these are generally based off of

00:06:41,220 --> 00:06:43,770
the

00:06:41,700 --> 00:06:46,890
grammar elements the most common form is

00:06:43,770 --> 00:06:49,800
the abstract syntax tree and again in

00:06:46,890 --> 00:06:53,040
this tree structure leaves would be the

00:06:49,800 --> 00:06:55,470
the edge tokens and the nodes would be

00:06:53,040 --> 00:06:59,520
elements of the tree that either contain

00:06:55,470 --> 00:07:01,350
leaves or more nodes but in the case of

00:06:59,520 --> 00:07:04,410
abstract syntax trees this is generally

00:07:01,350 --> 00:07:06,960
a runtime focused view of the code so

00:07:04,410 --> 00:07:08,940
you lose a lot of metadata like comments

00:07:06,960 --> 00:07:12,720
or formatting and so if you were to

00:07:08,940 --> 00:07:14,400
actually try to put this back out into a

00:07:12,720 --> 00:07:16,230
source file you would end up losing a

00:07:14,400 --> 00:07:18,090
lot of that data but the way this would

00:07:16,230 --> 00:07:21,540
actually look and with the standard ast

00:07:18,090 --> 00:07:24,510
module you'd have the call object at the

00:07:21,540 --> 00:07:25,830
bottom the name element for the function

00:07:24,510 --> 00:07:29,040
that you're actually going to be calling

00:07:25,830 --> 00:07:31,290
and then the arguments for the string

00:07:29,040 --> 00:07:32,880
and if you look at this as actual

00:07:31,290 --> 00:07:36,030
objects that you would get back from the

00:07:32,880 --> 00:07:41,100
ast module then you have the call object

00:07:36,030 --> 00:07:42,480
and the name and string and so forth but

00:07:41,100 --> 00:07:44,820
again if you were to actually dump this

00:07:42,480 --> 00:07:46,320
out you would end up basically erasing

00:07:44,820 --> 00:07:48,870
all of your formatting and comments and

00:07:46,320 --> 00:07:52,590
so forth so this is where the concept of

00:07:48,870 --> 00:07:55,290
concrete syntax trees come in it follows

00:07:52,590 --> 00:07:58,740
the same sort of like you know tree

00:07:55,290 --> 00:08:00,270
structure with nodes and leaves but this

00:07:58,740 --> 00:08:02,550
actually contains everything we need in

00:08:00,270 --> 00:08:04,440
order to rebuild the original file its

00:08:02,550 --> 00:08:06,900
preserves whitespace indentation

00:08:04,440 --> 00:08:10,530
comments a choice of single or double

00:08:06,900 --> 00:08:12,210
quotations etc and the standard library

00:08:10,530 --> 00:08:14,400
actually contains an implementation of

00:08:12,210 --> 00:08:15,990
this called Lib two-to-three it was

00:08:14,400 --> 00:08:18,270
originally built for the two to three

00:08:15,990 --> 00:08:21,090
conversion code for moving the code from

00:08:18,270 --> 00:08:23,340
Python 2 to Python 3 but the benefit of

00:08:21,090 --> 00:08:27,540
this is that it it can parse all Python

00:08:23,340 --> 00:08:30,510
grammars from Python 2 or Python 3 so

00:08:27,540 --> 00:08:31,770
the reason to use this rather than some

00:08:30,510 --> 00:08:33,960
of the alternatives out there might be

00:08:31,770 --> 00:08:35,760
that it's because it's part of the

00:08:33,960 --> 00:08:38,160
standard library it's going to be well

00:08:35,760 --> 00:08:41,490
maintained and supported as new versions

00:08:38,160 --> 00:08:44,250
come out when new elements of the

00:08:41,490 --> 00:08:46,200
grammar get added to the language Lib 2

00:08:44,250 --> 00:08:48,810
to 3 is immediately updated to support

00:08:46,200 --> 00:08:50,550
this and that means you can if you're

00:08:48,810 --> 00:08:53,310
using Lib 2 2 3 you could be ready for

00:08:50,550 --> 00:08:55,410
new versions immediately rather than

00:08:53,310 --> 00:08:57,810
waiting for a library to actually

00:08:55,410 --> 00:08:59,550
make their own updates and hopefully for

00:08:57,810 --> 00:09:03,560
us this actually contains a refactoring

00:08:59,550 --> 00:09:05,819
framework that makes it even more useful

00:09:03,560 --> 00:09:07,709
so the tree structure that led to three

00:09:05,819 --> 00:09:10,199
uses again there's a leaf for each

00:09:07,709 --> 00:09:12,360
distinct token in the source file and

00:09:10,199 --> 00:09:14,670
the node is basically semantic groupings

00:09:12,360 --> 00:09:20,189
of those tokens based off the grammar

00:09:14,670 --> 00:09:22,560
rules rather than having special objects

00:09:20,189 --> 00:09:24,899
like the ast module does though it has

00:09:22,560 --> 00:09:27,209
just a note in leaf class and uses

00:09:24,899 --> 00:09:29,399
integer identifiers to decide or to

00:09:27,209 --> 00:09:31,800
determine what type each element in the

00:09:29,399 --> 00:09:33,240
tree is but the other benefit is that it

00:09:31,800 --> 00:09:35,579
actually provides a collapsed grammar

00:09:33,240 --> 00:09:38,220
and grammar tree so if we take the

00:09:35,579 --> 00:09:40,290
example from earlier where you expand

00:09:38,220 --> 00:09:41,639
out all these individual elements you

00:09:40,290 --> 00:09:44,250
can see there's a lot of redundancies in

00:09:41,639 --> 00:09:46,740
it it's like name and atom actually

00:09:44,250 --> 00:09:49,529
represent the same element in code as

00:09:46,740 --> 00:09:52,170
does the string argument an artist or

00:09:49,529 --> 00:09:53,790
atom expression in power and in Lib 2 to

00:09:52,170 --> 00:09:55,949
3 it actually pulls out those

00:09:53,790 --> 00:09:58,230
redundancies so you have a tree where

00:09:55,949 --> 00:10:01,259
the the base of the tree is the power

00:09:58,230 --> 00:10:05,069
node and that's that nodes children is

00:10:01,259 --> 00:10:07,920
the name token for print and the trailer

00:10:05,069 --> 00:10:09,839
node for the actual arguments and then

00:10:07,920 --> 00:10:14,250
inside the trailer is just the string

00:10:09,839 --> 00:10:16,410
literal rather than multiple layers so

00:10:14,250 --> 00:10:19,230
again the way this would look in code is

00:10:16,410 --> 00:10:23,160
the we have the leaf in the node class

00:10:19,230 --> 00:10:24,930
that both extend the the base class and

00:10:23,160 --> 00:10:26,730
they both use an integer type to

00:10:24,930 --> 00:10:28,470
determine what they are in the case of

00:10:26,730 --> 00:10:31,410
the leaf that's an integer representing

00:10:28,470 --> 00:10:33,269
the token type and the in the case of

00:10:31,410 --> 00:10:37,769
the node that's an integer representing

00:10:33,269 --> 00:10:39,870
the grammar rule that it's part of four

00:10:37,769 --> 00:10:43,860
leaves the value is the actual on disk

00:10:39,870 --> 00:10:45,480
representation of that element and in

00:10:43,860 --> 00:10:50,130
the case of node you have children which

00:10:45,480 --> 00:10:52,230
is a list of any any leaf or node

00:10:50,130 --> 00:10:55,370
objects contained within it and they

00:10:52,230 --> 00:10:59,029
both share this prefix string which is

00:10:55,370 --> 00:11:02,069
all of the whitespace code formatting

00:10:59,029 --> 00:11:05,430
excuse me new lines and and so forth

00:11:02,069 --> 00:11:07,980
that that proceeds that element in the

00:11:05,430 --> 00:11:08,910
tree this is what allows us to actually

00:11:07,980 --> 00:11:13,770
dump it back out and

00:11:08,910 --> 00:11:15,480
the same original content so if we look

00:11:13,770 --> 00:11:20,460
at how this maps to our example and

00:11:15,480 --> 00:11:22,140
focus on the string token here the the

00:11:20,460 --> 00:11:25,920
actual object we would get from lib 2 2

00:11:22,140 --> 00:11:28,320
3 is of the leaf class the the integer

00:11:25,920 --> 00:11:31,200
ID for it is is that of a string literal

00:11:28,320 --> 00:11:34,020
and the value again is exactly what's on

00:11:31,200 --> 00:11:35,610
disk if we had a chosen single quotes

00:11:34,020 --> 00:11:36,990
for it instead of double quotes it would

00:11:35,610 --> 00:11:39,420
have been represented in that string

00:11:36,990 --> 00:11:43,620
similarly if we had chosen to use triple

00:11:39,420 --> 00:11:45,090
quotes for dock strings or something and

00:11:43,620 --> 00:11:46,680
in this case the prefix is empty because

00:11:45,090 --> 00:11:50,220
there's nothing between the opening

00:11:46,680 --> 00:11:53,700
parenthesis and the string literal if we

00:11:50,220 --> 00:11:55,890
back out to the trailer element this

00:11:53,700 --> 00:11:59,130
actually contains the parenthesis and

00:11:55,890 --> 00:12:01,860
the the argument and but because this is

00:11:59,130 --> 00:12:05,550
part of the actual grammar rule this is

00:12:01,860 --> 00:12:07,620
now a node type and the integer is is

00:12:05,550 --> 00:12:09,360
defining that it's a trailer and the

00:12:07,620 --> 00:12:11,160
children is just a list of those three

00:12:09,360 --> 00:12:12,480
leaf elements the opening parenthesis

00:12:11,160 --> 00:12:14,880
the string literal and the closing

00:12:12,480 --> 00:12:16,740
parenthesis again the prefix here is

00:12:14,880 --> 00:12:19,470
empty but if we were looking instead of

00:12:16,740 --> 00:12:23,760
the the power node below it we would see

00:12:19,470 --> 00:12:27,750
the the to do comment and the newline as

00:12:23,760 --> 00:12:29,640
part of that prefix so ultimately we

00:12:27,750 --> 00:12:33,240
really just want to build code mods with

00:12:29,640 --> 00:12:36,650
this and Lib 2 to 3 provides a concept

00:12:33,240 --> 00:12:39,080
of fixers which these would represent

00:12:36,650 --> 00:12:42,450
individual pieces of the 2 to 3

00:12:39,080 --> 00:12:43,560
conversion tool things like moving from

00:12:42,450 --> 00:12:45,540
the print statement to the print

00:12:43,560 --> 00:12:47,600
function or changing the way and inter

00:12:45,540 --> 00:12:50,790
integer division works things like that

00:12:47,600 --> 00:12:53,310
so instead we actually want to build our

00:12:50,790 --> 00:12:58,050
own fixers to do this and this

00:12:53,310 --> 00:13:00,420
ultimately gives us a way to inspect the

00:12:58,050 --> 00:13:03,960
the syntax tree and make changes to it

00:13:00,420 --> 00:13:05,940
so fixers use the concept of a pattern

00:13:03,960 --> 00:13:08,160
matching which is a string to represent

00:13:05,940 --> 00:13:09,900
the grammar we're looking for and then

00:13:08,160 --> 00:13:12,150
it has a transform method to actually

00:13:09,900 --> 00:13:15,360
provide or actually perform the

00:13:12,150 --> 00:13:16,890
transform once the match is made so an

00:13:15,360 --> 00:13:20,310
individual fixer would look like this in

00:13:16,890 --> 00:13:21,880
code you have the pattern string which

00:13:20,310 --> 00:13:23,290
I'll get to in a moment and then the

00:13:21,880 --> 00:13:25,870
transform method they'll get to a little

00:13:23,290 --> 00:13:28,030
bit later so the way the pattern

00:13:25,870 --> 00:13:30,100
matching works is again it's a string

00:13:28,030 --> 00:13:32,110
but it's based off of the actual grammar

00:13:30,100 --> 00:13:33,820
elements we want to look for you can

00:13:32,110 --> 00:13:36,550
provide arbitrary nesting or

00:13:33,820 --> 00:13:39,040
alternatives if you wanted to look for

00:13:36,550 --> 00:13:42,550
any cases of multiple different types of

00:13:39,040 --> 00:13:46,410
elements and then you can capture sub

00:13:42,550 --> 00:13:48,520
subtree elements within that pattern and

00:13:46,410 --> 00:13:50,800
your pattern could also include things

00:13:48,520 --> 00:13:52,150
like string literals or individual

00:13:50,800 --> 00:13:54,430
tokens that you want to match rather

00:13:52,150 --> 00:13:56,050
than just the grammar rules the way this

00:13:54,430 --> 00:13:57,910
would look if we wanted to actually find

00:13:56,050 --> 00:14:00,100
all cases in our code where the print

00:13:57,910 --> 00:14:02,170
function is called a regardless of what

00:14:00,100 --> 00:14:04,330
the arguments were the pattern string

00:14:02,170 --> 00:14:07,090
could be something similar to this it

00:14:04,330 --> 00:14:09,370
says we want to look for at the at the

00:14:07,090 --> 00:14:11,230
base of it is the power node we're using

00:14:09,370 --> 00:14:12,940
the string literal print to say we only

00:14:11,230 --> 00:14:14,440
care about print functions it could also

00:14:12,940 --> 00:14:17,230
just be name if you wanted to capture

00:14:14,440 --> 00:14:20,590
any function call and then we're using

00:14:17,230 --> 00:14:21,880
the trailer node to just basically

00:14:20,590 --> 00:14:24,190
define that it's actually a function

00:14:21,880 --> 00:14:26,140
call rather than list access or

00:14:24,190 --> 00:14:29,020
something we have to put in the the

00:14:26,140 --> 00:14:30,820
literal parentheses and in this case we

00:14:29,020 --> 00:14:32,440
use any to represent we don't really

00:14:30,820 --> 00:14:35,080
care what the type is of the element

00:14:32,440 --> 00:14:37,870
inside and the star to say that it could

00:14:35,080 --> 00:14:41,230
be zero or more and in this case we're

00:14:37,870 --> 00:14:42,640
also capturing this using args equal to

00:14:41,230 --> 00:14:46,840
say that that's an element that we

00:14:42,640 --> 00:14:49,510
actually care about modifying later once

00:14:46,840 --> 00:14:52,330
the once lived it tooth Lib two to three

00:14:49,510 --> 00:14:55,360
finds a a match in the tree it can call

00:14:52,330 --> 00:14:56,620
the the transform on our class and that

00:14:55,360 --> 00:14:59,170
transform can do any sort of

00:14:56,620 --> 00:15:01,000
modification at once anything from like

00:14:59,170 --> 00:15:03,040
adding new elements to the tree removing

00:15:01,000 --> 00:15:05,410
them replacing them or doing in place

00:15:03,040 --> 00:15:06,880
modifications and it's not restricted to

00:15:05,410 --> 00:15:09,040
just the matched elements we can go

00:15:06,880 --> 00:15:11,620
anywhere up or down the tree to actually

00:15:09,040 --> 00:15:13,510
change things we want the the pattern

00:15:11,620 --> 00:15:14,680
match simply provides essentially the

00:15:13,510 --> 00:15:18,010
starting point for for each

00:15:14,680 --> 00:15:19,510
transformation so if we go back to the

00:15:18,010 --> 00:15:22,030
code mod we originally wanted where we

00:15:19,510 --> 00:15:26,020
take take this bit of code and wrap the

00:15:22,030 --> 00:15:27,850
string literal in the translate call we

00:15:26,020 --> 00:15:30,880
can build the fixture like this we you

00:15:27,850 --> 00:15:32,650
create the the class we provide the the

00:15:30,880 --> 00:15:35,560
pattern match in this case is very

00:15:32,650 --> 00:15:37,960
similar to before but now we are

00:15:35,560 --> 00:15:40,720
specifically looking for function calls

00:15:37,960 --> 00:15:42,970
where it takes just a single string

00:15:40,720 --> 00:15:46,600
literal and in this case we're capturing

00:15:42,970 --> 00:15:48,340
it to the keyword s and then we have a

00:15:46,600 --> 00:15:52,210
transform method that would actually do

00:15:48,340 --> 00:15:55,089
the work using type annotations

00:15:52,210 --> 00:15:57,790
basically this method would take the

00:15:55,089 --> 00:15:59,950
first node or leaf that was matched by

00:15:57,790 --> 00:16:01,240
the pattern and this could be again

00:15:59,950 --> 00:16:03,250
either a leaf or node which is

00:16:01,240 --> 00:16:05,490
represented by bass and there were

00:16:03,250 --> 00:16:08,110
results as all of the captured elements

00:16:05,490 --> 00:16:11,529
from our pattern this would be the

00:16:08,110 --> 00:16:13,240
string mapping from let's say the the s

00:16:11,529 --> 00:16:17,589
keyword to the actual string literal

00:16:13,240 --> 00:16:21,070
token so our actual transform method to

00:16:17,589 --> 00:16:23,050
provide the transform of what we we

00:16:21,070 --> 00:16:25,870
first grabbed the string literal out of

00:16:23,050 --> 00:16:27,160
that results dictionary and then we tell

00:16:25,870 --> 00:16:30,040
the two-to-three that we want to replace

00:16:27,160 --> 00:16:32,050
it in the syntax tree with a new element

00:16:30,040 --> 00:16:34,029
and we'll use some of the Lib two two

00:16:32,050 --> 00:16:35,770
three helpers to generate the actual

00:16:34,029 --> 00:16:38,890
leaf and note objects for a function

00:16:35,770 --> 00:16:41,230
call and in this case we use a clone of

00:16:38,890 --> 00:16:43,240
the string literal token because we're

00:16:41,230 --> 00:16:46,810
simultaneously replacing it and putting

00:16:43,240 --> 00:16:50,100
it back into the tree and then for the

00:16:46,810 --> 00:16:53,710
bonus points of removing the proceeding

00:16:50,100 --> 00:16:55,750
comment we simply take the prefix string

00:16:53,710 --> 00:16:58,510
off of the matched node which in this

00:16:55,750 --> 00:17:00,730
case would be the power element and we

00:16:58,510 --> 00:17:03,700
simply do a regex substitution on it to

00:17:00,730 --> 00:17:06,699
find any any line in that prefix that's

00:17:03,700 --> 00:17:08,890
the to do comment and simply replace it

00:17:06,699 --> 00:17:10,480
with an empty string and by putting that

00:17:08,890 --> 00:17:11,980
back onto the prefix then it'll

00:17:10,480 --> 00:17:14,949
automatically update the code

00:17:11,980 --> 00:17:19,000
appropriately so now we have our fixer

00:17:14,949 --> 00:17:20,560
class we actually need to use Lib two

00:17:19,000 --> 00:17:22,929
two threes refactoring tools to actually

00:17:20,560 --> 00:17:25,209
execute this and this will essentially

00:17:22,929 --> 00:17:26,949
take some number of fixers and run it on

00:17:25,209 --> 00:17:29,710
each of the files that we care about and

00:17:26,949 --> 00:17:31,960
it'll run the essentially it'll walk

00:17:29,710 --> 00:17:34,420
through the syntax tree looking for

00:17:31,960 --> 00:17:36,670
matching nodes and run the transform

00:17:34,420 --> 00:17:40,630
methods whenever there's a appropriate

00:17:36,670 --> 00:17:42,790
match and then once all of the matches

00:17:40,630 --> 00:17:44,170
and transforms have been executed it

00:17:42,790 --> 00:17:47,050
will collect the final version of the

00:17:44,170 --> 00:17:48,320
syntax tree and dump that back out disk

00:17:47,050 --> 00:17:52,070
or gender

00:17:48,320 --> 00:17:53,960
or something of that sort the caveat

00:17:52,070 --> 00:17:56,210
here is that it defaults to importing

00:17:53,960 --> 00:17:59,000
the two to three fixers and so we just

00:17:56,210 --> 00:18:02,270
need to do a simple subclass to actually

00:17:59,000 --> 00:18:03,830
change that behavior so we just override

00:18:02,270 --> 00:18:06,140
this to the rather than importing that's

00:18:03,830 --> 00:18:09,140
just instantiating the fixer classes and

00:18:06,140 --> 00:18:12,890
then we can actually run this by giving

00:18:09,140 --> 00:18:14,870
it the fixer class that we had and run

00:18:12,890 --> 00:18:18,260
it on our source file or directory' and

00:18:14,870 --> 00:18:19,730
then tell it to give us the results in

00:18:18,260 --> 00:18:21,970
this case it just could be a simple

00:18:19,730 --> 00:18:26,030
one-line diff where it's Reds out the

00:18:21,970 --> 00:18:29,090
that to do and changes the rhapsode and

00:18:26,030 --> 00:18:31,520
the TR function if you want any of the

00:18:29,090 --> 00:18:34,700
example code it's on my github Jerry

00:18:31,520 --> 00:18:37,700
slash PyCon but this actually provides

00:18:34,700 --> 00:18:38,870
I'm sorry doing this with Lib two to

00:18:37,700 --> 00:18:41,810
three they're actually ends up being a

00:18:38,870 --> 00:18:42,980
lot of boilerplate and so there's a lot

00:18:41,810 --> 00:18:44,750
of cases where you probably don't want

00:18:42,980 --> 00:18:47,120
to reinvent this every time you want to

00:18:44,750 --> 00:18:48,650
do these sorts of refactoring so I'm

00:18:47,120 --> 00:18:51,230
actually kind of excited excited to

00:18:48,650 --> 00:18:54,400
announce that Facebook has open sourced

00:18:51,230 --> 00:18:56,930
a tool to do this called bowler is

00:18:54,400 --> 00:19:01,340
provides safe refactoring for modern

00:18:56,930 --> 00:19:04,130
Python this builds on all the concepts

00:19:01,340 --> 00:19:06,440
that I covered earlier in the talk it

00:19:04,130 --> 00:19:08,870
provides a fluent API allows you to

00:19:06,440 --> 00:19:11,930
chain metal calls off of a single

00:19:08,870 --> 00:19:15,320
starting class and it's optimized for

00:19:11,930 --> 00:19:17,630
large code bases and we'll make sure to

00:19:15,320 --> 00:19:20,630
use full advantage of all the cores on

00:19:17,630 --> 00:19:25,580
your machine and it's again open sourced

00:19:20,630 --> 00:19:26,960
freely available in MIT license so the

00:19:25,580 --> 00:19:29,300
reason to use this over some of the

00:19:26,960 --> 00:19:30,560
other tools as again because it's built

00:19:29,300 --> 00:19:32,240
on Lib two to three there would be

00:19:30,560 --> 00:19:34,970
automatic support for new Python

00:19:32,240 --> 00:19:39,650
releases as they come out and it was

00:19:34,970 --> 00:19:42,260
designed to allow for composable pieces

00:19:39,650 --> 00:19:45,700
of refactoring that you can reuse in the

00:19:42,260 --> 00:19:48,020
future and this allowed us to really

00:19:45,700 --> 00:19:50,510
productionize some of our refactoring

00:19:48,020 --> 00:19:53,090
tools and get more long-term lasting

00:19:50,510 --> 00:19:55,610
value out of them so rather than needing

00:19:53,090 --> 00:19:58,280
to rebuild this every time you have a

00:19:55,610 --> 00:20:00,620
similar use case you can either just

00:19:58,280 --> 00:20:02,780
reuse one exactly or

00:20:00,620 --> 00:20:05,320
or take the pieces from what you have

00:20:02,780 --> 00:20:09,470
and put them back together into

00:20:05,320 --> 00:20:11,420
different arrangements and really it was

00:20:09,470 --> 00:20:13,700
designed to be useful as both a tool and

00:20:11,420 --> 00:20:16,280
a library so you can either use it as

00:20:13,700 --> 00:20:18,559
like a CLI command or you can integrate

00:20:16,280 --> 00:20:21,830
it with other pieces of software to

00:20:18,559 --> 00:20:24,620
automate a lot of this the way it works

00:20:21,830 --> 00:20:27,530
again with the the fluent API you build

00:20:24,620 --> 00:20:29,690
a query pipeline essentially where you

00:20:27,530 --> 00:20:32,570
you build multiple transforms each one

00:20:29,690 --> 00:20:35,540
consists of a selector which generates

00:20:32,570 --> 00:20:38,780
the the pattern matching some optional

00:20:35,540 --> 00:20:41,540
filter functions to actually reduce the

00:20:38,780 --> 00:20:43,700
set of matches and then modifier

00:20:41,540 --> 00:20:45,710
functions to actually do the transforms

00:20:43,700 --> 00:20:50,030
on the syntax tree whenever there's a

00:20:45,710 --> 00:20:52,100
filtered match and bowler will actually

00:20:50,030 --> 00:20:54,530
either generate diffs or provide

00:20:52,100 --> 00:20:58,700
interactive results so if you've used

00:20:54,530 --> 00:21:02,030
something like get at HP or whatever the

00:20:58,700 --> 00:21:04,460
mercurial equivalent is it will show you

00:21:02,030 --> 00:21:06,980
a different and you can say yes or no

00:21:04,460 --> 00:21:08,960
and make sure that every piece of it

00:21:06,980 --> 00:21:11,929
that you're working on is is actually a

00:21:08,960 --> 00:21:13,490
modification you want to make the way

00:21:11,929 --> 00:21:16,100
this would look with the the fluent API

00:21:13,490 --> 00:21:17,630
is something similar to this again it's

00:21:16,100 --> 00:21:21,590
it's method chaining off of a single

00:21:17,630 --> 00:21:23,600
object you would start the pipeline by

00:21:21,590 --> 00:21:26,960
creating the query object tell it the

00:21:23,600 --> 00:21:30,200
source file or directory' that you want

00:21:26,960 --> 00:21:31,400
to operate on you use the selector so

00:21:30,200 --> 00:21:34,040
you actually define what you're matching

00:21:31,400 --> 00:21:36,890
against in this case will match against

00:21:34,040 --> 00:21:38,450
any use of the print function and by

00:21:36,890 --> 00:21:40,970
default the selector will actually find

00:21:38,450 --> 00:21:42,470
if there was a case where we defined a

00:21:40,970 --> 00:21:45,350
print function or imported a print

00:21:42,470 --> 00:21:47,750
function it would find that as well and

00:21:45,350 --> 00:21:50,150
then we can filter those results to say

00:21:47,750 --> 00:21:51,620
we only care about cases where the

00:21:50,150 --> 00:21:53,660
functions actually being called rather

00:21:51,620 --> 00:21:56,090
than defined and we can add a custom

00:21:53,660 --> 00:21:58,340
filter to further restrict that to when

00:21:56,090 --> 00:22:00,950
it has just the one string literal as

00:21:58,340 --> 00:22:03,020
its argument and then we can mostly

00:22:00,950 --> 00:22:05,510
reuse the function we had earlier to

00:22:03,020 --> 00:22:08,870
actually do the modification and wrap it

00:22:05,510 --> 00:22:10,220
in the translation call and then

00:22:08,870 --> 00:22:12,410
ultimately we tell that we want to

00:22:10,220 --> 00:22:14,240
generate a diff there's all alternatives

00:22:12,410 --> 00:22:18,050
for actually generating the inner graph

00:22:14,240 --> 00:22:21,140
devout put the custom filter function I

00:22:18,050 --> 00:22:23,240
mentioned essentially returns true or

00:22:21,140 --> 00:22:25,550
false whether or not the the element

00:22:23,240 --> 00:22:28,100
should be modified it takes the Leifer

00:22:25,550 --> 00:22:29,570
node and the capture dictionary you

00:22:28,100 --> 00:22:31,970
basically treat it the same way you

00:22:29,570 --> 00:22:33,800
would with transforms you get the the

00:22:31,970 --> 00:22:36,320
captured element out of it and in this

00:22:33,800 --> 00:22:39,770
case we look to see if the first

00:22:36,320 --> 00:22:41,590
argument from that function is the

00:22:39,770 --> 00:22:44,120
string literal and return true or false

00:22:41,590 --> 00:22:46,280
the actual modification looks almost

00:22:44,120 --> 00:22:49,040
exactly like what we had before

00:22:46,280 --> 00:22:51,559
again a leaf the node takes the leaf or

00:22:49,040 --> 00:22:54,530
node and the capture dictionary and then

00:22:51,559 --> 00:22:57,320
does the appropriate change in the

00:22:54,530 --> 00:23:00,170
syntax tree and then when we actually

00:22:57,320 --> 00:23:03,020
want to run this we just basically put

00:23:00,170 --> 00:23:05,059
it in a file say bowler run and the

00:23:03,020 --> 00:23:07,700
decode mod file and it will actually

00:23:05,059 --> 00:23:10,250
generate the output right there as the

00:23:07,700 --> 00:23:11,990
diff again alternatives for like

00:23:10,250 --> 00:23:16,850
interactive modes and and things like

00:23:11,990 --> 00:23:20,929
that so that's basically bowler in a

00:23:16,850 --> 00:23:23,900
nutshell it's early access part of the

00:23:20,929 --> 00:23:25,910
Facebook incubator on github it was

00:23:23,900 --> 00:23:28,070
actually my first project as I joined

00:23:25,910 --> 00:23:30,860
the Python Foundation team at Facebook I

00:23:28,070 --> 00:23:34,850
was used to solve some of our real

00:23:30,860 --> 00:23:36,620
internal use cases but because of some

00:23:34,850 --> 00:23:38,900
of these caveats like the the API is

00:23:36,620 --> 00:23:40,640
still being fleshed out

00:23:38,900 --> 00:23:43,970
there's incomplete set of selectors and

00:23:40,640 --> 00:23:47,420
filters or transforms and as always can

00:23:43,970 --> 00:23:48,890
use more testing but we definitely want

00:23:47,420 --> 00:23:50,450
to continue supporting and improving it

00:23:48,890 --> 00:23:51,020
we want to reduce some of the

00:23:50,450 --> 00:23:53,809
boilerplate

00:23:51,020 --> 00:23:55,840
around creating new code mods and add

00:23:53,809 --> 00:23:58,520
some more helper functions and

00:23:55,840 --> 00:24:00,230
ultimately we want to move it to the

00:23:58,520 --> 00:24:03,620
point where it actually gains some more

00:24:00,230 --> 00:24:06,440
linter style features and similarly

00:24:03,620 --> 00:24:09,140
integration with tools like fabricator

00:24:06,440 --> 00:24:12,110
github the benefit in case of linor

00:24:09,140 --> 00:24:13,820
features would be that you're all you're

00:24:12,110 --> 00:24:15,679
able to check against the actual syntax

00:24:13,820 --> 00:24:18,130
tree instead of just regular expressions

00:24:15,679 --> 00:24:21,200
and simultaneously provide automatic

00:24:18,130 --> 00:24:24,950
fixes if if that's something that would

00:24:21,200 --> 00:24:28,070
be possible but more than anything else

00:24:24,950 --> 00:24:29,330
we want a diverse base of contributors

00:24:28,070 --> 00:24:32,090
want to be able to make sure that we're

00:24:29,330 --> 00:24:34,340
supporting multiple use cases both

00:24:32,090 --> 00:24:36,050
inside and outside of Facebook and we

00:24:34,340 --> 00:24:39,530
want to make this one of the best tools

00:24:36,050 --> 00:24:43,550
available so I urge you to check it out

00:24:39,530 --> 00:24:46,070
today it's at pi bowler do there's

00:24:43,550 --> 00:24:48,140
plenty of documentation there on some of

00:24:46,070 --> 00:24:50,840
these concepts how to get started using

00:24:48,140 --> 00:24:52,910
it or how to contribute to the project

00:24:50,840 --> 00:24:58,010
if you're interested as well as a link

00:24:52,910 --> 00:25:00,110
to link to our github for it so looks

00:24:58,010 --> 00:25:04,460
like I have about five minutes for

00:25:00,110 --> 00:25:06,470
questions if I don't if there's too many

00:25:04,460 --> 00:25:08,030
questions or whatever feel free to reach

00:25:06,470 --> 00:25:10,250
out to me in the halls for more

00:25:08,030 --> 00:25:12,340
questions or discussions later but thank

00:25:10,250 --> 00:25:12,340
you

00:25:18,350 --> 00:25:30,930
so do we have any questions thank you

00:25:28,640 --> 00:25:32,970
regarding what you can do with it what

00:25:30,930 --> 00:25:35,040
are some other examples than just a

00:25:32,970 --> 00:25:38,820
single function by grabbing a function

00:25:35,040 --> 00:25:41,460
so some of the common use cases that we

00:25:38,820 --> 00:25:43,620
built it for would be things like let's

00:25:41,460 --> 00:25:46,500
say you wanted to rename an object

00:25:43,620 --> 00:25:47,820
somewhere and you wanted to then update

00:25:46,500 --> 00:25:50,760
all of the references throughout the

00:25:47,820 --> 00:25:53,220
code base or if you wanted to change

00:25:50,760 --> 00:25:56,430
some of the arguments that a function or

00:25:53,220 --> 00:25:58,080
method took you could either add new

00:25:56,430 --> 00:26:00,630
arguments to it and update all of the

00:25:58,080 --> 00:26:02,700
callers or remove an argument and

00:26:00,630 --> 00:26:06,840
automatically update all the colors that

00:26:02,700 --> 00:26:08,870
sort of thing and I ideally like any

00:26:06,840 --> 00:26:11,250
sort of thing you would want to do with

00:26:08,870 --> 00:26:13,280
like this sort of automated refactoring

00:26:11,250 --> 00:26:15,360
should be possible it's just a matter of

00:26:13,280 --> 00:26:17,670
did we implement it in the in the

00:26:15,360 --> 00:26:26,790
baseline set of features or will it need

00:26:17,670 --> 00:26:29,790
more work more questions I think so yeah

00:26:26,790 --> 00:26:31,430
really interesting so I'm fairly

00:26:29,790 --> 00:26:33,690
comfortable with regex

00:26:31,430 --> 00:26:35,880
refactoring on a large scale like that I

00:26:33,690 --> 00:26:39,510
can see how this could make the far

00:26:35,880 --> 00:26:42,720
safer three factors as you've gotten

00:26:39,510 --> 00:26:45,390
used to it do find it's faster or slower

00:26:42,720 --> 00:26:46,350
to use then like to set up a big one

00:26:45,390 --> 00:26:50,730
than a regex

00:26:46,350 --> 00:26:52,380
system I mean I think it's always going

00:26:50,730 --> 00:26:55,380
to be a little bit slower because you

00:26:52,380 --> 00:26:57,180
first have to decompile it into the

00:26:55,380 --> 00:26:59,750
syntax tree and then walk that tree

00:26:57,180 --> 00:27:03,570
comparing it to all of these patterns

00:26:59,750 --> 00:27:06,630
but I mean we have a fairly large Python

00:27:03,570 --> 00:27:09,600
code base at Facebook and I was able to

00:27:06,630 --> 00:27:13,050
do like some of the example refactoring

00:27:09,600 --> 00:27:16,470
that I mentioned before on our entire

00:27:13,050 --> 00:27:19,560
code base in less than a minute so oh

00:27:16,470 --> 00:27:21,920
yeah but rather than the run Tommy and

00:27:19,560 --> 00:27:24,450
more the time it takes to put together

00:27:21,920 --> 00:27:25,980
yes exactly it's like in the case of

00:27:24,450 --> 00:27:27,750
actually building some of the code mods

00:27:25,980 --> 00:27:30,630
it might take a little bit more than

00:27:27,750 --> 00:27:35,640
than a regular expression but the Ben

00:27:30,630 --> 00:27:38,760
fit is that a safety it especially if

00:27:35,640 --> 00:27:40,380
you're using some of the larger formats

00:27:38,760 --> 00:27:43,890
with type annotation and so forth

00:27:40,380 --> 00:27:45,300
it means that much less complicated that

00:27:43,890 --> 00:27:47,580
your regular expression would need to be

00:27:45,300 --> 00:27:52,230
compared to what this can do fairly

00:27:47,580 --> 00:27:54,240
trivially so like imagine a world where

00:27:52,230 --> 00:27:55,710
you have so many arguments that you're

00:27:54,240 --> 00:27:56,850
breaking them onto multiple lines and

00:27:55,710 --> 00:27:58,200
you want to modify one of those

00:27:56,850 --> 00:28:00,660
arguments but you want to make sure that

00:27:58,200 --> 00:28:01,740
it's for a specific function now your

00:28:00,660 --> 00:28:04,470
regular expression has to be a

00:28:01,740 --> 00:28:06,900
multi-line regular expression whereas

00:28:04,470 --> 00:28:11,060
this can do that regardless of whether

00:28:06,900 --> 00:28:14,600
it's one line or multiple yeah thanks

00:28:11,060 --> 00:28:14,600
any more questions

00:28:19,690 --> 00:28:24,970
hi um do you think this would be a

00:28:21,880 --> 00:28:26,830
suitable or Lib to play would be a

00:28:24,970 --> 00:28:30,910
suitable tool for style checking

00:28:26,830 --> 00:28:34,770
students code I mean I think it should

00:28:30,910 --> 00:28:37,360
be like if your depends on how

00:28:34,770 --> 00:28:41,380
aggressive you want to be on various

00:28:37,360 --> 00:28:43,960
things it might be like if you're just

00:28:41,380 --> 00:28:45,700
specifically checking for style it might

00:28:43,960 --> 00:28:49,000
actually be better to just pick a

00:28:45,700 --> 00:28:51,820
formatting system that's already out

00:28:49,000 --> 00:28:54,010
there like black or something of that

00:28:51,820 --> 00:28:57,310
sort and simply say if it matches this

00:28:54,010 --> 00:28:59,790
then that's fine or I know there's also

00:28:57,310 --> 00:29:01,840
plenty of like pepete linters that will

00:28:59,790 --> 00:29:03,820
complain if you if you just want to be a

00:29:01,840 --> 00:29:06,340
little bit more lacs about what the

00:29:03,820 --> 00:29:07,750
style is I'm sure it'd be possible to

00:29:06,340 --> 00:29:12,850
build it in this case it's just maybe

00:29:07,750 --> 00:29:14,200
not what it's designed for like the more

00:29:12,850 --> 00:29:17,140
like the linting things I was talking

00:29:14,200 --> 00:29:18,850
about earlier is more like we've seen

00:29:17,140 --> 00:29:20,770
cases where people want to have like a

00:29:18,850 --> 00:29:23,140
lint rule if you're using let's say a

00:29:20,770 --> 00:29:24,490
deprecated function or a deprecated

00:29:23,140 --> 00:29:27,430
modular method or something like that

00:29:24,490 --> 00:29:29,740
it'd be useful to be able to say in this

00:29:27,430 --> 00:29:31,540
case that it's coming from that specific

00:29:29,740 --> 00:29:33,430
module or it's a function call of that

00:29:31,540 --> 00:29:39,970
name like let's let's say that's

00:29:33,430 --> 00:29:41,530
deprecated thank you all right we have

00:29:39,970 --> 00:29:44,070
time for one more quick question if

00:29:41,530 --> 00:29:44,070
anyone has one

00:29:47,930 --> 00:29:53,180

YouTube URL: https://www.youtube.com/watch?v=9USGh4Uy-xQ


