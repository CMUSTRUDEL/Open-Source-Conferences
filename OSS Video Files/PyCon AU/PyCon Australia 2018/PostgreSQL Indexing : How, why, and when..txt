Title: PostgreSQL Indexing : How, why, and when.
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Curtis Maloney

https://2018.pycon-au.org/talks/42913-postgresql-indexing-how-why-and-when/

So many of the things we build depend on a DBMS to keep our data safe, and retrieve it quickly.
We know indexes can make that faster, but... how do they work? When should you use them? What should I index?

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,589 --> 00:00:08,309
okay next up we're going to learn how

00:00:05,279 --> 00:00:10,380
database indexes work how we should use

00:00:08,309 --> 00:00:12,750
them why we should use them because they

00:00:10,380 --> 00:00:16,230
somehow apparently make accessing data

00:00:12,750 --> 00:00:18,119
in databases faster and Curtis is going

00:00:16,230 --> 00:00:24,930
to talk to us about how that actually

00:00:18,119 --> 00:00:27,300
works afternoon hope you've all been

00:00:24,930 --> 00:00:28,590
enjoying yourselves I'm going to have to

00:00:27,300 --> 00:00:30,119
run through this fairly quickly because

00:00:28,590 --> 00:00:32,070
the last time I ran through this it took

00:00:30,119 --> 00:00:35,100
me the full half-hour and it's grown

00:00:32,070 --> 00:00:36,840
since then so I am Curtis Miley I'm

00:00:35,100 --> 00:00:39,239
known as funky Bob to many people in the

00:00:36,840 --> 00:00:42,239
Django community and outside if you want

00:00:39,239 --> 00:00:46,050
to tweet me there's my address and

00:00:42,239 --> 00:00:48,539
github I'm funky Bob so as a quick

00:00:46,050 --> 00:00:50,340
overview we're going to be talking about

00:00:48,539 --> 00:00:52,800
Postgres in this indexes and Postgres

00:00:50,340 --> 00:00:54,770
when you make a query we'll try to

00:00:52,800 --> 00:00:57,690
optimize that query for the minimal cost

00:00:54,770 --> 00:00:59,940
our cost is based on an awfully large

00:00:57,690 --> 00:01:01,680
number of factors but a most significant

00:00:59,940 --> 00:01:05,760
one that you're likely to run into every

00:01:01,680 --> 00:01:07,500
day is the number of pages of data that

00:01:05,760 --> 00:01:10,049
are involved in the query the more pages

00:01:07,500 --> 00:01:11,670
the bigger the cost and then a lot of

00:01:10,049 --> 00:01:15,840
the costing is actually expressed in

00:01:11,670 --> 00:01:19,110
terms of numbers of pages by default in

00:01:15,840 --> 00:01:20,580
Postgres our page is 8k this is seems a

00:01:19,110 --> 00:01:22,530
little odd for anyone who's used to

00:01:20,580 --> 00:01:25,729
storage but it's there it's a Chosen

00:01:22,530 --> 00:01:30,659
think about it as iCade chunks of data

00:01:25,729 --> 00:01:33,659
indexes in general are a cost storage

00:01:30,659 --> 00:01:36,479
time trade-off so you are actually

00:01:33,659 --> 00:01:40,110
spending more on storage in order to get

00:01:36,479 --> 00:01:42,540
a faster query so we're gonna start with

00:01:40,110 --> 00:01:45,390
a very simple very simple schema here

00:01:42,540 --> 00:01:49,350
for a threaded forum post we're gonna

00:01:45,390 --> 00:01:50,790
have our account I use your account very

00:01:49,350 --> 00:01:54,899
simple account ID name date of birth

00:01:50,790 --> 00:01:58,829
we're gonna have a thread which has an

00:01:54,899 --> 00:02:02,070
account ID as to who created it and a

00:01:58,829 --> 00:02:04,259
title and then we're going to have our

00:02:02,070 --> 00:02:07,740
post table and a post title table is

00:02:04,259 --> 00:02:10,860
going to contain most of our data so

00:02:07,740 --> 00:02:13,590
it's got the post ID it's got the thread

00:02:10,860 --> 00:02:15,270
that it's a part of who created it

00:02:13,590 --> 00:02:17,069
when it was created whether or not it's

00:02:15,270 --> 00:02:20,270
visible has it been moderated out of

00:02:17,069 --> 00:02:22,410
existence and what the actual content is

00:02:20,270 --> 00:02:23,970
we're going to go through a number of

00:02:22,410 --> 00:02:25,920
queries and try and optimize them and

00:02:23,970 --> 00:02:28,260
keep them efficient so that our users

00:02:25,920 --> 00:02:30,239
don't get annoyed and go somewhere else

00:02:28,260 --> 00:02:33,360
so we've got a first query of what are

00:02:30,239 --> 00:02:34,950
all my posts second is how many posts

00:02:33,360 --> 00:02:37,739
have actually made because some people

00:02:34,950 --> 00:02:39,360
want to know how prolific they are what

00:02:37,739 --> 00:02:41,670
are all the posts of the current thread

00:02:39,360 --> 00:02:44,010
how many posts have I made on the

00:02:41,670 --> 00:02:47,040
current thread so am i involved in this

00:02:44,010 --> 00:02:49,410
discussion and also all the current

00:02:47,040 --> 00:02:51,180
posts for a thread for this month in

00:02:49,410 --> 00:02:54,620
order so when you were reviewing oppose

00:02:51,180 --> 00:02:57,269
a thread look at it in the current order

00:02:54,620 --> 00:02:58,800
I've seeded my database with some random

00:02:57,269 --> 00:03:02,400
data as we can all see it's nice and

00:02:58,800 --> 00:03:03,959
simple no not that simple okay I had a

00:03:02,400 --> 00:03:06,090
lot of help in generating this but

00:03:03,959 --> 00:03:07,380
basically I you don't have to understand

00:03:06,090 --> 00:03:10,440
what's going on here but the major

00:03:07,380 --> 00:03:13,590
points that I'm generating a hundred

00:03:10,440 --> 00:03:18,780
random users a thousand random threads

00:03:13,590 --> 00:03:21,030
and a hundred thousand random posts in

00:03:18,780 --> 00:03:23,850
those threads with twenty random words

00:03:21,030 --> 00:03:25,850
each associated with different users

00:03:23,850 --> 00:03:28,410
different threads whatever

00:03:25,850 --> 00:03:32,400
statistically well distributed but just

00:03:28,410 --> 00:03:35,549
still random this basically costs a

00:03:32,400 --> 00:03:38,700
space and we can see our thread table

00:03:35,549 --> 00:03:42,959
has cost us a total 160 k100 and 12k in

00:03:38,700 --> 00:03:44,459
actual data our accounts table is even

00:03:42,959 --> 00:03:46,500
smaller because there's very little

00:03:44,459 --> 00:03:51,390
actually in there and our post table is

00:03:46,500 --> 00:03:54,630
a massive 27 Meg total 24 mega and 2 Meg

00:03:51,390 --> 00:03:56,310
of index now I didn't declare any

00:03:54,630 --> 00:03:58,560
indexes but there's one there already

00:03:56,310 --> 00:04:01,410
because I declared the primary key

00:03:58,560 --> 00:04:03,359
unique and Postgres is actually going to

00:04:01,410 --> 00:04:04,980
create an index so that it can take

00:04:03,359 --> 00:04:09,600
track of that and make sure that it is

00:04:04,980 --> 00:04:13,049
unique I don't have a choice tables are

00:04:09,600 --> 00:04:16,109
really just stored as a file and a

00:04:13,049 --> 00:04:19,440
sequence of pages so our counts table

00:04:16,109 --> 00:04:21,599
just tiny a thread tables a little bit

00:04:19,440 --> 00:04:25,930
bigger our post table is just huge

00:04:21,599 --> 00:04:30,759
enormous 24 Meg long stream of pages

00:04:25,930 --> 00:04:33,880
each individual page has a small header

00:04:30,759 --> 00:04:36,729
at the front to let us know who is it

00:04:33,880 --> 00:04:38,860
live what's going on how old is it

00:04:36,729 --> 00:04:41,020
what transactions its involved in and so

00:04:38,860 --> 00:04:43,180
on then there's another section which is

00:04:41,020 --> 00:04:46,419
the item ID data and this is a list of

00:04:43,180 --> 00:04:50,830
pointers into the page of where every

00:04:46,419 --> 00:04:52,810
tuple actually starts so every topple in

00:04:50,830 --> 00:04:56,350
that table is referenced by page number

00:04:52,810 --> 00:04:59,229
and item ID so this together allows you

00:04:56,350 --> 00:05:01,479
to uniquely reference a record in your

00:04:59,229 --> 00:05:03,610
database so they can actually be shifted

00:05:01,479 --> 00:05:05,669
around within the page as new versions

00:05:03,610 --> 00:05:08,620
come along and older versions go away

00:05:05,669 --> 00:05:10,509
without the reference to them changing

00:05:08,620 --> 00:05:12,389
this makes life a little more efficient

00:05:10,509 --> 00:05:15,970
for everyone trying to deal with

00:05:12,389 --> 00:05:17,830
transactions and data updating so here's

00:05:15,970 --> 00:05:19,630
our first query pretty straightforward -

00:05:17,830 --> 00:05:21,520
anyone familiar with SQL we're going to

00:05:19,630 --> 00:05:24,030
get everything from the post table where

00:05:21,520 --> 00:05:27,599
the account ID is our account number and

00:05:24,030 --> 00:05:31,210
I'm going to analyze what Postgres does

00:05:27,599 --> 00:05:33,370
by using explain analyze and that's

00:05:31,210 --> 00:05:36,099
going to get Postgres to output its

00:05:33,370 --> 00:05:42,190
query plan what it plans to do to

00:05:36,099 --> 00:05:46,840
satisfy this query here it is and we see

00:05:42,190 --> 00:05:49,479
here what it plans to do is a sequential

00:05:46,840 --> 00:05:51,610
scan on the post table and it's going to

00:05:49,479 --> 00:05:53,110
cost about four thousand three hundred

00:05:51,610 --> 00:05:53,800
and seventy nine now that doesn't make

00:05:53,110 --> 00:05:55,389
any sense

00:05:53,800 --> 00:05:58,449
we don't know what that is on a scale

00:05:55,389 --> 00:06:00,340
but it's a useful number whilst it's

00:05:58,449 --> 00:06:02,110
doing this scan it's going to filter for

00:06:00,340 --> 00:06:05,139
where account ID equals one which is

00:06:02,110 --> 00:06:08,259
what we asked it to do and note that

00:06:05,139 --> 00:06:11,949
it's going to remove almost every single

00:06:08,259 --> 00:06:13,659
one of those hundred thousand records so

00:06:11,949 --> 00:06:16,419
it's kind of a waste of time for a lot

00:06:13,659 --> 00:06:23,130
of that and it takes 32 milliseconds to

00:06:16,419 --> 00:06:23,130
do this work next page

00:06:23,319 --> 00:06:28,610
so full table scan what does it mean

00:06:26,120 --> 00:06:30,830
start at the beginning work your way all

00:06:28,610 --> 00:06:32,300
the way to at the end I don't think

00:06:30,830 --> 00:06:33,620
there's a single person in this room who

00:06:32,300 --> 00:06:36,110
thinks that's the most efficient way to

00:06:33,620 --> 00:06:38,210
do this but it's the only option

00:06:36,110 --> 00:06:44,080
Postgres has because it doesn't know

00:06:38,210 --> 00:06:47,509
where everything is all 24 make of it

00:06:44,080 --> 00:06:51,590
so indexes to the rescue what is an

00:06:47,509 --> 00:06:54,770
index basically it's in this case a key

00:06:51,590 --> 00:06:56,990
value store where the keys are the list

00:06:54,770 --> 00:06:59,780
of values in the field that we've asked

00:06:56,990 --> 00:07:01,610
to index and the values are the page

00:06:59,780 --> 00:07:01,940
number and item ID that we mentioned

00:07:01,610 --> 00:07:04,280
before

00:07:01,940 --> 00:07:06,139
so this means that when Postgres wants

00:07:04,280 --> 00:07:10,610
to find something it knows what page to

00:07:06,139 --> 00:07:12,770
go to it's also a sorted list at least

00:07:10,610 --> 00:07:14,570
in the case of b-tree indexes which is

00:07:12,770 --> 00:07:16,449
the default indexes in Postgres we'll

00:07:14,570 --> 00:07:19,729
get onto this later on

00:07:16,449 --> 00:07:21,770
so it's sorts the values so it knows how

00:07:19,729 --> 00:07:24,800
to find them efficiently in this case

00:07:21,770 --> 00:07:26,780
what happens and why is as a win apart

00:07:24,800 --> 00:07:28,970
from being the sorted list is we store

00:07:26,780 --> 00:07:31,520
fewer bytes just the fields we're

00:07:28,970 --> 00:07:34,639
interested in and therefore access fewer

00:07:31,520 --> 00:07:39,020
pages in order to satisfy the query

00:07:34,639 --> 00:07:40,580
we're trying to execute what is a b-tree

00:07:39,020 --> 00:07:43,729
that i mentioned before it's a

00:07:40,580 --> 00:07:47,330
self-balancing search tree so you start

00:07:43,729 --> 00:07:49,639
with a bunch of nodes which divide up

00:07:47,330 --> 00:07:51,169
the records by a low and a high range

00:07:49,639 --> 00:07:53,479
and they'll say everything below this

00:07:51,169 --> 00:07:56,659
value go look over here and that'll grow

00:07:53,479 --> 00:07:58,280
the tree according to a balancing

00:07:56,659 --> 00:08:03,800
algorithm that makes sure that it's as

00:07:58,280 --> 00:08:06,110
flat as possible and the fan-out the

00:08:03,800 --> 00:08:08,000
number of steps between depends on how

00:08:06,110 --> 00:08:09,889
big a record is and how big it takes so

00:08:08,000 --> 00:08:13,880
in the case of here because we have an

00:08:09,889 --> 00:08:17,750
8k page and it only takes about 16 bytes

00:08:13,880 --> 00:08:20,750
to reference a page and item you're

00:08:17,750 --> 00:08:23,240
looking at a few hundred pages next

00:08:20,750 --> 00:08:25,639
level down so it fans out very very wide

00:08:23,240 --> 00:08:28,759
so you can actually get very flat trees

00:08:25,639 --> 00:08:30,770
for large number of Records then each

00:08:28,759 --> 00:08:33,409
one of them eventually somewhere down

00:08:30,770 --> 00:08:36,080
the tree refers to the leaf nodes which

00:08:33,409 --> 00:08:38,030
actually contain that sorted list of

00:08:36,080 --> 00:08:39,710
keys and values so that we can scan

00:08:38,030 --> 00:08:41,450
through them to find the values that

00:08:39,710 --> 00:08:43,760
actually matter to us so we've chopped

00:08:41,450 --> 00:08:45,140
down saying okay we want the values that

00:08:43,760 --> 00:08:47,510
are greater than this or less than this

00:08:45,140 --> 00:08:49,850
and follow the tree to say less than

00:08:47,510 --> 00:08:51,170
greater than down here we go and then

00:08:49,850 --> 00:08:53,300
you can look through that page and get

00:08:51,170 --> 00:08:55,820
the answers there's another variant

00:08:53,300 --> 00:08:57,470
called a B+ tree where each of the leaf

00:08:55,820 --> 00:08:59,300
nodes actually has a pointer unto the

00:08:57,470 --> 00:09:01,700
next one so that if you want to scan

00:08:59,300 --> 00:09:03,200
from one page to the next you don't have

00:09:01,700 --> 00:09:07,070
to climb back up the tree and back down

00:09:03,200 --> 00:09:08,480
again you can just keep going so we're

00:09:07,070 --> 00:09:10,130
going to add the index and it's as

00:09:08,480 --> 00:09:15,890
simple as saying create index on this

00:09:10,130 --> 00:09:20,180
table for account ID this has a cost of

00:09:15,890 --> 00:09:22,790
course now our page for the post has 4.4

00:09:20,180 --> 00:09:25,190
Meg of indexes so that's a doubled in

00:09:22,790 --> 00:09:28,160
size which is not surprising because

00:09:25,190 --> 00:09:29,600
it's an index across one field should be

00:09:28,160 --> 00:09:33,410
about the same size it's on the primary

00:09:29,600 --> 00:09:36,950
key but in comparison to the original

00:09:33,410 --> 00:09:40,880
table size it's tiny it's only 2 Meg

00:09:36,950 --> 00:09:42,740
compared to 24 so let's have a look at

00:09:40,880 --> 00:09:48,620
that query again what's our scan what's

00:09:42,740 --> 00:09:53,210
our query plan well now we have a bitmap

00:09:48,620 --> 00:09:55,490
index scan on that index which means

00:09:53,210 --> 00:09:58,820
Postgres is going to allocate a chunk of

00:09:55,490 --> 00:10:00,530
memory to build a bitmap to say this

00:09:58,820 --> 00:10:02,240
record is in this record is out this

00:10:00,530 --> 00:10:05,240
record is in does it record is out and

00:10:02,240 --> 00:10:07,190
use the index scan to determine which

00:10:05,240 --> 00:10:10,070
pages it should mark as being of

00:10:07,190 --> 00:10:12,650
interest and from that it can then

00:10:10,070 --> 00:10:15,050
decide I only need to read these pages

00:10:12,650 --> 00:10:18,950
and when I get to that page I only need

00:10:15,050 --> 00:10:20,570
to read these records and it can scan

00:10:18,950 --> 00:10:25,790
through the index and just check the

00:10:20,570 --> 00:10:29,660
account ID then it will do a bitmap heap

00:10:25,790 --> 00:10:31,760
scan which takes that index scan result

00:10:29,660 --> 00:10:34,100
and actually goes through the data and

00:10:31,760 --> 00:10:40,760
picks up the pages so we see here that

00:10:34,100 --> 00:10:45,650
now our costs have on the bitmap index

00:10:40,760 --> 00:10:47,690
can't look our cost in total now for our

00:10:45,650 --> 00:10:48,550
query is fourteen hundred and thirty

00:10:47,690 --> 00:10:52,390
nine

00:10:48,550 --> 00:10:54,399
where previously it was four thousand

00:10:52,390 --> 00:10:55,870
three hundred and seventy-nine I think

00:10:54,399 --> 00:10:59,620
it we can all see this a much lower

00:10:55,870 --> 00:11:01,899
number and the execution time is now six

00:10:59,620 --> 00:11:04,450
point seven milliseconds whereas before

00:11:01,899 --> 00:11:05,709
is 32 milliseconds now when we're

00:11:04,450 --> 00:11:06,820
talking milliseconds that's not going to

00:11:05,709 --> 00:11:08,470
make a big difference to your average

00:11:06,820 --> 00:11:12,250
user but when you've got a few thousand

00:11:08,470 --> 00:11:14,589
users that starts counting so let's move

00:11:12,250 --> 00:11:16,779
on to our next query we're going to

00:11:14,589 --> 00:11:20,290
select the count of posts where the

00:11:16,779 --> 00:11:23,829
account ID is my account ID and the

00:11:20,290 --> 00:11:25,899
query plan very similar to originally

00:11:23,829 --> 00:11:28,480
we're going to sequentially scan the

00:11:25,899 --> 00:11:30,399
post table which costs us the same

00:11:28,480 --> 00:11:32,019
amount but now we have to aggregate and

00:11:30,399 --> 00:11:33,940
count how many records actually matched

00:11:32,019 --> 00:11:37,269
which means we go from that original

00:11:33,940 --> 00:11:38,950
value up to just a little bit more not

00:11:37,269 --> 00:11:44,649
much more expensive but just a little

00:11:38,950 --> 00:11:47,339
bit more now when we add our index into

00:11:44,649 --> 00:11:50,910
the mix we get a very different answer

00:11:47,339 --> 00:11:53,529
now it's going to be an index only scan

00:11:50,910 --> 00:11:55,990
because all the information we need is

00:11:53,529 --> 00:11:58,209
the account ID we don't need any other

00:11:55,990 --> 00:12:00,010
information from the records we just

00:11:58,209 --> 00:12:03,700
want to count how many records match

00:12:00,010 --> 00:12:05,470
this ID we can actually get the answer

00:12:03,700 --> 00:12:09,370
from the index itself and leave the

00:12:05,470 --> 00:12:12,070
table data alone entirely so now our

00:12:09,370 --> 00:12:14,500
cost has gone down to well the initial

00:12:12,070 --> 00:12:16,540
scan is seventeen point nine seven and

00:12:14,500 --> 00:12:19,120
then when we aggregate the answers after

00:12:16,540 --> 00:12:22,120
that it's nineteen point three six so

00:12:19,120 --> 00:12:29,170
we've gone down from four thousand and

00:12:22,120 --> 00:12:33,040
something to 219 and our scan our actual

00:12:29,170 --> 00:12:43,250
query time has gone from thirty four

00:12:33,040 --> 00:12:45,620
milliseconds down to 0.8 milliseconds

00:12:43,250 --> 00:12:48,020
I haven't actually done what the order

00:12:45,620 --> 00:12:50,600
of magnetization of that is but when

00:12:48,020 --> 00:12:55,010
you're done down to better than 34 times

00:12:50,600 --> 00:12:59,510
the speed that's not a bad result so

00:12:55,010 --> 00:13:01,040
next we have query number three select

00:12:59,510 --> 00:13:03,320
everything from the post table whether

00:13:01,040 --> 00:13:05,240
we're on thread ID one and it's visible

00:13:03,320 --> 00:13:11,090
because we're only interested in the

00:13:05,240 --> 00:13:13,610
visible queries our initial query plan

00:13:11,090 --> 00:13:16,130
of course is sequential scan on the post

00:13:13,610 --> 00:13:18,020
table filter for visible and thread ID

00:13:16,130 --> 00:13:21,260
equals one so we've got two terms here

00:13:18,020 --> 00:13:23,120
and removes ninety-nine thousand nine

00:13:21,260 --> 00:13:27,880
hundred and sixty one out of a hundred

00:13:23,120 --> 00:13:30,830
thousand so we've wasted 99.9 percent of

00:13:27,880 --> 00:13:33,350
our effort reading rows that we weren't

00:13:30,830 --> 00:13:42,020
interested in but it only takes 14

00:13:33,350 --> 00:13:45,050
milliseconds thank you so let's create

00:13:42,020 --> 00:13:46,640
another index this time on the thread ID

00:13:45,050 --> 00:13:52,460
because that's what we're searching on

00:13:46,640 --> 00:13:56,890
this time so now our query goes from

00:13:52,460 --> 00:13:56,890
what it was in - oh that's a bit better

00:13:58,120 --> 00:14:03,110
so now we have our bitmap heat index

00:14:01,250 --> 00:14:08,839
scan and bitmap heat scan again where

00:14:03,110 --> 00:14:10,280
our cost has gone down to 339 and it was

00:14:08,839 --> 00:14:11,750
at four thousand three hundred and

00:14:10,280 --> 00:14:13,910
seventy-nine and previously we were

00:14:11,750 --> 00:14:18,770
taking 14 milliseconds and now we're

00:14:13,910 --> 00:14:20,620
down at four and a half not a bad

00:14:18,770 --> 00:14:23,830
improvement at all

00:14:20,620 --> 00:14:26,560
let's snack on to query number four

00:14:23,830 --> 00:14:30,050
what's the count of the number of posts

00:14:26,560 --> 00:14:36,740
in the thread that are visible that I

00:14:30,050 --> 00:14:39,530
posted again the initial query again

00:14:36,740 --> 00:14:44,030
sequential scan we filter on all these

00:14:39,530 --> 00:14:47,200
different terms and 99.99% of the rows

00:14:44,030 --> 00:14:52,529
don't match but we're still costing as

00:14:47,200 --> 00:14:55,259
4629 whoo this is getting repetitive

00:14:52,529 --> 00:14:56,879
so what's the query plan for this well

00:14:55,259 --> 00:14:59,219
actually it turns out to be quite a big

00:14:56,879 --> 00:15:01,289
one this is one of the things that

00:14:59,219 --> 00:15:04,259
Postgres does very well is it will

00:15:01,289 --> 00:15:06,419
combine indexes that it knows about so

00:15:04,259 --> 00:15:08,789
what's happened here is it's done a

00:15:06,419 --> 00:15:14,519
bitmap index scan on the thread index

00:15:08,789 --> 00:15:17,729
and the account index and then it's

00:15:14,519 --> 00:15:19,949
going to end them together and then use

00:15:17,729 --> 00:15:22,079
the result of that for the heap scan so

00:15:19,949 --> 00:15:24,059
it's actually on a bitmap both of the

00:15:22,079 --> 00:15:25,709
indexes and whatever matches both of

00:15:24,059 --> 00:15:28,559
them is obviously a record that it's

00:15:25,709 --> 00:15:29,819
interested in and then it can recheck

00:15:28,559 --> 00:15:31,649
its conditions and make everything's

00:15:29,819 --> 00:15:34,139
right recheck condition is there because

00:15:31,649 --> 00:15:35,639
of the multi versioning that Postgres

00:15:34,139 --> 00:15:37,469
does and it has to be sure they've got

00:15:35,639 --> 00:15:39,599
the right one but usually it's a very

00:15:37,469 --> 00:15:43,769
cheap check it has to read the rows

00:15:39,599 --> 00:15:46,129
anyway and then of course it has to

00:15:43,769 --> 00:15:52,739
filter unvisible

00:15:46,129 --> 00:15:54,809
now we were 4629 now we're at 21 that's

00:15:52,739 --> 00:15:57,599
a dramatic improvement we were at 13

00:15:54,809 --> 00:16:01,999
more 40 milliseconds now we're at 399

00:15:57,599 --> 00:16:06,119
milliseconds hmm

00:16:01,999 --> 00:16:09,989
sorry 0.39 9 milliseconds I was only out

00:16:06,119 --> 00:16:13,049
by a thousand times yeah thank you for

00:16:09,989 --> 00:16:15,569
reading my slides better than I do we

00:16:13,049 --> 00:16:17,549
can do better believe it or not because

00:16:15,569 --> 00:16:20,429
we can create an index on multiple

00:16:17,549 --> 00:16:23,069
fields so let's create an index on the

00:16:20,429 --> 00:16:26,309
thread ID and visible because that's

00:16:23,069 --> 00:16:30,629
what we're actually filtering on so for

00:16:26,309 --> 00:16:32,549
query number 3 this helps a lot because

00:16:30,629 --> 00:16:34,649
that's actually what our filters are on

00:16:32,549 --> 00:16:38,720
so this time we've gone from our

00:16:34,649 --> 00:16:41,879
original value though with the old index

00:16:38,720 --> 00:16:45,299
now it can actually scan down and do the

00:16:41,879 --> 00:16:49,799
bitmap index scan on both trait ID and

00:16:45,299 --> 00:16:54,379
visible get a better result and come

00:16:49,799 --> 00:16:58,799
back at us at 300 million of 300 and in

00:16:54,379 --> 00:17:01,559
2.77 milliseconds at point two seven

00:16:58,799 --> 00:17:03,029
seven milliseconds so it was at four

00:17:01,559 --> 00:17:04,870
point five eight so we've actually

00:17:03,029 --> 00:17:10,059
dropped an order of magnitude

00:17:04,870 --> 00:17:14,289
and it was at a cost of 339 now it's at

00:17:10,059 --> 00:17:16,230
a cost of 307 again slightly better not

00:17:14,289 --> 00:17:19,120
a huge improvement but an improvement

00:17:16,230 --> 00:17:21,309
does this index help with query for

00:17:19,120 --> 00:17:24,639
which also wanted to filter on the same

00:17:21,309 --> 00:17:27,459
- yes it does and in fact our app query

00:17:24,639 --> 00:17:29,610
becomes even smarter just a little bit

00:17:27,459 --> 00:17:32,590
cleaner

00:17:29,610 --> 00:17:36,130
so we have our bitmap index scan on the

00:17:32,590 --> 00:17:38,080
post thread ID and visible index and an

00:17:36,130 --> 00:17:40,620
index scan on the account ID and again

00:17:38,080 --> 00:17:43,149
we add them together then we felt a

00:17:40,620 --> 00:17:45,809
interesting that it already filters on

00:17:43,149 --> 00:17:51,460
visible again

00:17:45,809 --> 00:17:53,799
but our result is we're at 0.35 five

00:17:51,460 --> 00:17:55,840
milliseconds whereas previously zero

00:17:53,799 --> 00:17:59,259
point three nine nine as Tim hopefully

00:17:55,840 --> 00:18:05,470
pointed out so again a small improvement

00:17:59,259 --> 00:18:07,120
but an improvement on the less can we do

00:18:05,470 --> 00:18:08,710
it better index for query four because

00:18:07,120 --> 00:18:10,990
the query three one was good but query

00:18:08,710 --> 00:18:13,029
four uses three different fields so

00:18:10,990 --> 00:18:14,440
let's index all three fields and maybe

00:18:13,029 --> 00:18:17,710
we'll get something better again and

00:18:14,440 --> 00:18:19,539
remember query four is account which

00:18:17,710 --> 00:18:21,399
means if we have all the information we

00:18:19,539 --> 00:18:24,070
need in the index we might get an index

00:18:21,399 --> 00:18:27,519
only scan which is the most efficient we

00:18:24,070 --> 00:18:29,740
can hope for well sure enough we get an

00:18:27,519 --> 00:18:31,539
index only scan because all three times

00:18:29,740 --> 00:18:39,250
that we want to filter on are available

00:18:31,539 --> 00:18:45,220
in the index and now we're down to 0.097

00:18:39,250 --> 00:18:46,840
milliseconds it was 0.3 55 so we've

00:18:45,220 --> 00:18:49,259
stepped down an order of magnitude again

00:18:46,840 --> 00:18:56,379
so now we've gone from 13 milliseconds

00:18:49,259 --> 00:19:01,029
20.39 to 0.35 to 0.09 that's a couple of

00:18:56,379 --> 00:19:05,370
orders of magnitude improvement anyone

00:19:01,029 --> 00:19:05,370
know what this interesting word means

00:19:06,330 --> 00:19:11,060
yes

00:19:08,800 --> 00:19:13,790
there ain't no such thing as a free

00:19:11,060 --> 00:19:15,440
lunch so we've paid for this what did it

00:19:13,790 --> 00:19:18,500
cost us well

00:19:15,440 --> 00:19:20,270
storage storage Awards cost us and of

00:19:18,500 --> 00:19:22,250
course when we're talking databases

00:19:20,270 --> 00:19:24,350
storage isn't just the amount of disk

00:19:22,250 --> 00:19:26,330
space you use but the amount of RAM it's

00:19:24,350 --> 00:19:28,940
going to need when it needs to read that

00:19:26,330 --> 00:19:30,530
and a single user that's not such a big

00:19:28,940 --> 00:19:32,480
problem but when you're scaling to

00:19:30,530 --> 00:19:34,370
hundreds of users accessing this the

00:19:32,480 --> 00:19:36,800
more pages of data you can share the

00:19:34,370 --> 00:19:39,470
better you are so we got a situation

00:19:36,800 --> 00:19:41,810
where we now have four indexes on the

00:19:39,470 --> 00:19:44,870
one table and they're taking two to

00:19:41,810 --> 00:19:45,950
three makes each remember some of them

00:19:44,870 --> 00:19:48,680
are a bit bigger because they're

00:19:45,950 --> 00:19:49,880
indexing more fields so that's a cost

00:19:48,680 --> 00:19:52,580
that we have to consider there is

00:19:49,880 --> 00:19:56,270
another cost and that is that actually

00:19:52,580 --> 00:19:58,970
inserting or updating any rows mean we

00:19:56,270 --> 00:20:00,770
have to update the indexes as well each

00:19:58,970 --> 00:20:02,600
and every one of them so you get this

00:20:00,770 --> 00:20:05,060
thing called write amplification we're

00:20:02,600 --> 00:20:06,860
just writing one record you actually

00:20:05,060 --> 00:20:10,700
have to write three or four records for

00:20:06,860 --> 00:20:13,910
the indexes as well there is a nice

00:20:10,700 --> 00:20:18,010
solution for some of this partial

00:20:13,910 --> 00:20:21,020
indexes why are we storing in the index

00:20:18,010 --> 00:20:22,640
rows of references to rows we know we

00:20:21,020 --> 00:20:25,040
don't want we're not interested in the

00:20:22,640 --> 00:20:26,660
ones that are marked not visible so why

00:20:25,040 --> 00:20:28,310
don't why do we store them in the index

00:20:26,660 --> 00:20:31,190
can't we tell our index to ignore them

00:20:28,310 --> 00:20:33,800
of course we can so we do what we did

00:20:31,190 --> 00:20:36,290
before but this time we say we're

00:20:33,800 --> 00:20:39,350
visible it's true we leave visible out

00:20:36,290 --> 00:20:41,000
of the index and just say we only put

00:20:39,350 --> 00:20:45,140
things in the index we're visible is

00:20:41,000 --> 00:20:48,170
true this gives us an index that is now

00:20:45,140 --> 00:20:52,520
oh look it's only well yeah we've saved

00:20:48,170 --> 00:20:57,380
300k not a huge amount but it's an

00:20:52,520 --> 00:21:02,090
amount and it's a bonus so what does

00:20:57,380 --> 00:21:04,730
this do for query number four well we've

00:21:02,090 --> 00:21:08,960
now got our index only scan across our

00:21:04,730 --> 00:21:12,320
new index and our time is at zero point

00:21:08,960 --> 00:21:15,320
zero seven nine there's previously it

00:21:12,320 --> 00:21:17,390
was zero point zero nine seven so we

00:21:15,320 --> 00:21:21,590
actually shaved another almost twenty

00:21:17,390 --> 00:21:25,279
percent off and our number of pages hit

00:21:21,590 --> 00:21:27,409
cost has gone from 4.45 down to 4.33

00:21:25,279 --> 00:21:30,320
so that rude measure of how efficiently

00:21:27,409 --> 00:21:31,970
being is actually improved you will find

00:21:30,320 --> 00:21:34,789
and I found this when trying to produce

00:21:31,970 --> 00:21:36,590
these slides your actual execution time

00:21:34,789 --> 00:21:38,809
will vary due to a large number of

00:21:36,590 --> 00:21:42,710
factors like anything else you are doing

00:21:38,809 --> 00:21:44,450
on your system if I was playing a music

00:21:42,710 --> 00:21:46,039
that was encoded at a higher bitrate

00:21:44,450 --> 00:21:50,860
that would throw up my timing a little

00:21:46,039 --> 00:21:50,860
bit very hard to reproduce the numbers

00:21:52,029 --> 00:21:57,440
okay this index actually also helps

00:21:54,710 --> 00:21:59,270
query number three which doesn't use all

00:21:57,440 --> 00:22:04,460
those fields but it does use thread ID

00:21:59,270 --> 00:22:07,520
invisible so here's now what we get and

00:22:04,460 --> 00:22:11,270
we'll see could our bitmap index scan on

00:22:07,520 --> 00:22:13,490
the new index and our time is at 0.26

00:22:11,270 --> 00:22:16,820
three which has actually come down from

00:22:13,490 --> 00:22:18,919
zero point two seven seven and the

00:22:16,820 --> 00:22:21,649
number of pages hit is pretty much the

00:22:18,919 --> 00:22:23,390
same our cost is almost identical so we

00:22:21,649 --> 00:22:25,100
haven't really improved that much which

00:22:23,390 --> 00:22:27,230
is why the time is pretty close to what

00:22:25,100 --> 00:22:28,760
it was but it actually is using the same

00:22:27,230 --> 00:22:31,190
index which means we could paint but

00:22:28,760 --> 00:22:32,570
maybe get rid of any news but how can we

00:22:31,190 --> 00:22:37,490
use this index when we're not referring

00:22:32,570 --> 00:22:40,610
to all the fields in the index well

00:22:37,490 --> 00:22:48,020
that's because the index remember is a

00:22:40,610 --> 00:22:55,029
sorted list of keys to values and we're

00:22:48,020 --> 00:22:55,029
interested in filtering on the thread ID

00:22:56,680 --> 00:23:03,070
so in query number three we want this

00:22:59,800 --> 00:23:05,080
rate ID we can scan across the threat ID

00:23:03,070 --> 00:23:07,510
we've effectively got two indexes in one

00:23:05,080 --> 00:23:11,820
here we've got the thread index and the

00:23:07,510 --> 00:23:11,820
thread in account index in the one table

00:23:12,120 --> 00:23:16,780
let's move on to query number five where

00:23:15,700 --> 00:23:20,440
we're going to select everything from

00:23:16,780 --> 00:23:24,280
posts where thread is number one it's

00:23:20,440 --> 00:23:26,560
all visible and it was created sometime

00:23:24,280 --> 00:23:30,880
in the last month so we've got from now

00:23:26,560 --> 00:23:34,780
- one month and again with no indexes

00:23:30,880 --> 00:23:38,470
big linear scan big expensive query five

00:23:34,780 --> 00:23:43,930
thousand because it actually has to do a

00:23:38,470 --> 00:23:48,820
little more work in comparison now with

00:23:43,930 --> 00:23:52,270
the indexes in place we get our bitmap

00:23:48,820 --> 00:23:54,220
index scan on the post thread ID account

00:23:52,270 --> 00:24:00,340
ID index that we created with visible

00:23:54,220 --> 00:24:02,530
missing it can then do a heap scan it's

00:24:00,340 --> 00:24:04,990
removed the extra stuff it doesn't want

00:24:02,530 --> 00:24:07,630
and the created records it can now

00:24:04,990 --> 00:24:14,170
filter the extra 37 rows out but it's

00:24:07,630 --> 00:24:18,100
only going across 87 rows instead of a

00:24:14,170 --> 00:24:21,490
hundred thousand and our result is 33

00:24:18,100 --> 00:24:25,470
milliseconds comes down to 0.33

00:24:21,490 --> 00:24:25,470
milliseconds a hundred times improvement

00:24:25,920 --> 00:24:33,760
we've gone from a cost of 5100 down to a

00:24:29,410 --> 00:24:35,410
cost of 307 but maybe we can make an

00:24:33,760 --> 00:24:39,190
index specifically for this because

00:24:35,410 --> 00:24:43,020
we're querying across created we're

00:24:39,190 --> 00:24:47,590
interested in that in the index as well

00:24:43,020 --> 00:24:50,770
now our query plan becomes almost

00:24:47,590 --> 00:24:53,200
trivial so index condition is on thread

00:24:50,770 --> 00:24:58,900
ID and created being larger than this

00:24:53,200 --> 00:25:04,080
value so we know an index condition and

00:24:58,900 --> 00:25:04,080
an index scan and get our results

00:25:05,809 --> 00:25:16,140
so we've gone from 0.33 milliseconds to

00:25:11,990 --> 00:25:17,820
0.09 4 milliseconds from the original 33

00:25:16,140 --> 00:25:21,690
milliseconds that's a huge improvement

00:25:17,820 --> 00:25:25,590
an original cost has come down and is

00:25:21,690 --> 00:25:28,409
now down at zero about twelve point

00:25:25,590 --> 00:25:31,740
forty six from the 5700 that it was

00:25:28,409 --> 00:25:33,600
that's not a bad improvement so why did

00:25:31,740 --> 00:25:36,389
creating an index make such a big

00:25:33,600 --> 00:25:40,500
difference to our ordering query plan

00:25:36,389 --> 00:25:43,440
which had to spend a lot of time sorting

00:25:40,500 --> 00:25:45,990
it had to allocate okay only 25k a

00:25:43,440 --> 00:25:52,769
memory to implement the sort where that

00:25:45,990 --> 00:25:57,330
cost was quite significant why did we

00:25:52,769 --> 00:26:02,370
get to skip that because as you remember

00:25:57,330 --> 00:26:04,380
the index is a sorted list of values so

00:26:02,370 --> 00:26:07,260
it's already done the work of sorting

00:26:04,380 --> 00:26:12,990
the created values we've grouped by the

00:26:07,260 --> 00:26:15,470
straight ID save work by doing it once

00:26:12,990 --> 00:26:18,000
when you insert the insert the record

00:26:15,470 --> 00:26:19,620
figure out what order it would be save

00:26:18,000 --> 00:26:22,919
that in the index the index does this

00:26:19,620 --> 00:26:29,360
for us saving work by pre calculating

00:26:22,919 --> 00:26:31,980
our data we can do in other ways because

00:26:29,360 --> 00:26:36,690
the values that we put into our index

00:26:31,980 --> 00:26:38,159
can be calculated rather than just being

00:26:36,690 --> 00:26:40,769
the values the raw values from our

00:26:38,159 --> 00:26:43,080
fields so here's an example what if we

00:26:40,769 --> 00:26:46,230
wanted at times to tell people in order

00:26:43,080 --> 00:26:48,450
to have an idea of how many words people

00:26:46,230 --> 00:26:50,039
are putting into their post now to go

00:26:48,450 --> 00:26:51,570
around and count the number of words in

00:26:50,039 --> 00:26:54,269
your posts to run statistics on that

00:26:51,570 --> 00:26:57,179
could actually be quite expensive so we

00:26:54,269 --> 00:26:59,370
have this index here where we create we

00:26:57,179 --> 00:27:02,940
get the array length of doing a regex

00:26:59,370 --> 00:27:05,519
split on the comment by anything that is

00:27:02,940 --> 00:27:07,970
a space character many groups of

00:27:05,519 --> 00:27:07,970
spacings

00:27:08,269 --> 00:27:12,229
and that will create an index with that

00:27:10,279 --> 00:27:14,089
value already figured out so when you

00:27:12,229 --> 00:27:15,799
insert the record or update the record

00:27:14,089 --> 00:27:18,109
it calculates that and when you want to

00:27:15,799 --> 00:27:20,209
run statistics on it and you say in your

00:27:18,109 --> 00:27:20,690
query I want to know the answer to this

00:27:20,209 --> 00:27:23,269
value

00:27:20,690 --> 00:27:24,859
Postgres will just go oh that's in this

00:27:23,269 --> 00:27:26,779
index in yet I'll just look it up

00:27:24,859 --> 00:27:30,259
I've got your key here's your value off

00:27:26,779 --> 00:27:32,419
we go now we can save it by calculating

00:27:30,259 --> 00:27:34,190
these things once when it matters and

00:27:32,419 --> 00:27:38,719
leave it alone it's like having your

00:27:34,190 --> 00:27:41,779
cash but with a hardwired expiration

00:27:38,719 --> 00:27:43,700
policy that is updated correctly now as

00:27:41,779 --> 00:27:46,579
I said earlier Postgres supports more

00:27:43,700 --> 00:27:48,769
than just be trees the supports hash

00:27:46,579 --> 00:27:51,379
table indexes which are excellent for

00:27:48,769 --> 00:27:51,679
doing equals comparisons but nothing

00:27:51,379 --> 00:27:53,809
else

00:27:51,679 --> 00:27:57,349
you can't scan them linearly because

00:27:53,809 --> 00:27:58,789
they're not sorted you can't do greater

00:27:57,349 --> 00:28:00,289
than or smaller than comparisons because

00:27:58,789 --> 00:28:02,479
they just don't support that sort of

00:28:00,289 --> 00:28:05,419
lookup and they can only support one

00:28:02,479 --> 00:28:07,309
field in the value but if you need to do

00:28:05,419 --> 00:28:10,129
that they are very efficient for that

00:28:07,309 --> 00:28:13,070
then there's generalized inverse inverse

00:28:10,129 --> 00:28:14,419
indices or djinns which are really

00:28:13,070 --> 00:28:15,759
really powerful for when you don't want

00:28:14,419 --> 00:28:20,809
to do something like full-text search

00:28:15,759 --> 00:28:22,669
and you can use them to express lots of

00:28:20,809 --> 00:28:25,639
different functions on your queries that

00:28:22,669 --> 00:28:28,459
you just couldn't do but they're very

00:28:25,639 --> 00:28:31,339
good for working with field types that

00:28:28,459 --> 00:28:35,299
have multiple values such as text

00:28:31,339 --> 00:28:37,909
documents JSON blobs XML trees and so on

00:28:35,299 --> 00:28:40,429
or even date times then there's block

00:28:37,909 --> 00:28:43,909
range index the brin which for every

00:28:40,429 --> 00:28:46,429
block of data in your table every page

00:28:43,909 --> 00:28:50,269
will actually across that index store

00:28:46,429 --> 00:28:52,820
the minimum and maximum value and that's

00:28:50,269 --> 00:28:54,259
it so that when you're searching and you

00:28:52,820 --> 00:28:56,239
want to find things within a range of

00:28:54,259 --> 00:28:58,009
values you can't really discard pages

00:28:56,239 --> 00:29:01,459
that you know don't have values within

00:28:58,009 --> 00:29:04,789
those ranges they are absolutely tiny

00:29:01,459 --> 00:29:08,839
for comparison I did a Brin index on the

00:29:04,789 --> 00:29:12,049
creation field so for a b-tree it would

00:29:08,839 --> 00:29:16,190
be 2.2 megabytes for the Brin it was 24

00:29:12,049 --> 00:29:18,169
K and it can't get much smaller than

00:29:16,190 --> 00:29:20,730
that however they're not very useful

00:29:18,169 --> 00:29:22,290
they don't cover a lot of cases they

00:29:20,730 --> 00:29:23,900
do come in handy when your tables start

00:29:22,290 --> 00:29:27,660
getting very very large

00:29:23,900 --> 00:29:29,910
so to summarize index speed filtering

00:29:27,660 --> 00:29:33,150
and sorting in comparisons they can also

00:29:29,910 --> 00:29:34,830
help with other operations if you use

00:29:33,150 --> 00:29:36,780
the right index for the job you can see

00:29:34,830 --> 00:29:40,980
we can get thousandfold improvement in

00:29:36,780 --> 00:29:42,630
performance they add a cost on insert

00:29:40,980 --> 00:29:45,270
and update so don't just go add them to

00:29:42,630 --> 00:29:47,700
anything at all but they can also save

00:29:45,270 --> 00:29:50,669
you work by doing it once when the value

00:29:47,700 --> 00:29:52,590
changes or is set and not updating it

00:29:50,669 --> 00:29:56,250
again when it hasn't changed not

00:29:52,590 --> 00:29:58,410
calculating it again so I made it just

00:29:56,250 --> 00:30:00,299
didn't just in under 30 minutes thank

00:29:58,410 --> 00:30:01,620
you that's it any questions and I want

00:30:00,299 --> 00:30:03,630
to thank these people who I know from

00:30:01,620 --> 00:30:05,640
IRC rhodium toad on IRC on freenode

00:30:03,630 --> 00:30:07,620
knows absolutely everything about post

00:30:05,640 --> 00:30:12,960
careers it seems we have time for one

00:30:07,620 --> 00:30:19,380
question sorry one question anyone

00:30:12,960 --> 00:30:26,160
please yeah well you were first you're

00:30:19,380 --> 00:30:27,720
first wait up some of the queries you

00:30:26,160 --> 00:30:29,790
edited next to you sort of thousandfold

00:30:27,720 --> 00:30:32,100
improvements that cost you were saying

00:30:29,790 --> 00:30:33,960
with updating is that conversely is out

00:30:32,100 --> 00:30:36,030
a thousand times cost or is it much

00:30:33,960 --> 00:30:38,669
smaller no no the cost of updating is

00:30:36,030 --> 00:30:41,460
much much much smaller it does mean that

00:30:38,669 --> 00:30:43,710
that every time you insert a row it will

00:30:41,460 --> 00:30:49,290
have to insert a row in the index as

00:30:43,710 --> 00:30:51,000
well but that's not a very large cost in

00:30:49,290 --> 00:30:52,650
that respect it does have to rebalance

00:30:51,000 --> 00:30:54,150
the tree or update the table in the way

00:30:52,650 --> 00:30:55,380
or worse but these are algorithms that

00:30:54,150 --> 00:30:57,390
have worked out to be very very

00:30:55,380 --> 00:30:58,650
efficient for their for the needs and

00:30:57,390 --> 00:31:01,559
the operations are going to perform on

00:30:58,650 --> 00:31:04,710
them all right that's my one question

00:31:01,559 --> 00:31:06,750
I've overdone my time by a minute but if

00:31:04,710 --> 00:31:09,450
anyone wants to talk further about this

00:31:06,750 --> 00:31:12,840
you can hit me up on IRC or on Twitter

00:31:09,450 --> 00:31:17,210
or talk to me I'm here until all the

00:31:12,840 --> 00:31:17,210
slides all the sprints

00:31:17,330 --> 00:31:20,599

YouTube URL: https://www.youtube.com/watch?v=clrtT_4WBAw


