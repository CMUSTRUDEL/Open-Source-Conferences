Title: You Don't Need That!
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Christopher Neugebauer

https://2018.pycon-au.org/talks/45184-you-dont-need-that/

Not every design pattern makes sense in Python. This talk builds up design patterns commonly used in enterprise languages, and shows the features in Python that make these approaches unnecessary.

Python, PyCon, PyConAU, australia, programming, sydney

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,000 --> 00:00:04,620
afternoon welcome to see three point

00:00:02,310 --> 00:00:06,540
four and see three point five we have

00:00:04,620 --> 00:00:09,719
some awesome talks for you to enjoy this

00:00:06,540 --> 00:00:12,389
afternoon first up we have Christopher

00:00:09,719 --> 00:00:15,179
Nagar Bauer whom you may recognize as

00:00:12,389 --> 00:00:17,279
our lightning talk sir would you believe

00:00:15,179 --> 00:00:19,529
it in his spare time he actually write

00:00:17,279 --> 00:00:22,410
some Python and today he'll be

00:00:19,529 --> 00:00:24,119
presenting you don't need that which is

00:00:22,410 --> 00:00:33,300
a discussion of design patterns and

00:00:24,119 --> 00:00:35,610
Python hi everyone

00:00:33,300 --> 00:00:37,739
I wrote these slides in somewhat of a

00:00:35,610 --> 00:00:39,989
rush after I was stranded in Detroit a

00:00:37,739 --> 00:00:42,680
couple of months ago I think they're

00:00:39,989 --> 00:00:42,680
pretty good though

00:00:42,930 --> 00:00:49,230
yeah thanks Jacob my name is Christopher

00:00:47,280 --> 00:00:52,469
Navarre I'm going to be talking about

00:00:49,230 --> 00:00:57,800
design patterns and Python but not so

00:00:52,469 --> 00:00:59,969
much design patterns in Python so I am

00:00:57,800 --> 00:01:03,449
Australian but I currently live in

00:00:59,969 --> 00:01:08,070
Petaluma in in California somewhat north

00:01:03,449 --> 00:01:10,770
of the of San Francisco I also run a

00:01:08,070 --> 00:01:12,299
small boutique single track Python

00:01:10,770 --> 00:01:13,770
conference with Andrew Godwin and a

00:01:12,299 --> 00:01:16,320
couple other people called North Bay

00:01:13,770 --> 00:01:17,909
Python if you're interested in going

00:01:16,320 --> 00:01:19,470
over to the States at some point in the

00:01:17,909 --> 00:01:22,590
next few months come along for our think

00:01:19,470 --> 00:01:24,240
is a great excuse I'm a director at

00:01:22,590 --> 00:01:29,220
large of the Python Software Foundation

00:01:24,240 --> 00:01:32,640
as of like June this year and I am

00:01:29,220 --> 00:01:35,790
currently a senior software engineer at

00:01:32,640 --> 00:01:37,350
alpha sites we connect people who need

00:01:35,790 --> 00:01:42,290
to know stuff with people who might know

00:01:37,350 --> 00:01:45,930
that stuff and monetize that somehow and

00:01:42,290 --> 00:01:50,490
at alpha sites I'm working on a team

00:01:45,930 --> 00:01:54,299
that's transitioning out of being a Ruby

00:01:50,490 --> 00:01:57,899
on Rails shop and is moving to a mixture

00:01:54,299 --> 00:01:59,939
of JVM and Kotlin for infrastructure

00:01:57,899 --> 00:02:05,070
code and a bit of python on the side of

00:01:59,939 --> 00:02:07,170
that and situations where people are

00:02:05,070 --> 00:02:09,060
working in multiple languages are you

00:02:07,170 --> 00:02:10,920
know it's it's an extremely it's an

00:02:09,060 --> 00:02:12,360
increasingly common situation you know

00:02:10,920 --> 00:02:13,530
development teams are increasingly

00:02:12,360 --> 00:02:15,270
polyglot organ

00:02:13,530 --> 00:02:17,700
and especially you now that we're

00:02:15,270 --> 00:02:19,200
writing fully-fledged a UI UI

00:02:17,700 --> 00:02:20,760
applications for web browsers

00:02:19,200 --> 00:02:22,980
you know teens might be working on on

00:02:20,760 --> 00:02:25,110
JavaScript for the front-end and Python

00:02:22,980 --> 00:02:27,630
for the backend or you know Python for

00:02:25,110 --> 00:02:29,850
the backend and Java for orchestration

00:02:27,630 --> 00:02:31,080
stuff or something like that you know

00:02:29,850 --> 00:02:34,110
there's many different ways that people

00:02:31,080 --> 00:02:35,730
talk about different programming

00:02:34,110 --> 00:02:38,400
languages they might talk about you know

00:02:35,730 --> 00:02:40,770
the level of rigidity or flexibility

00:02:38,400 --> 00:02:42,810
that language gives you you know they

00:02:40,770 --> 00:02:45,270
might talk about the programming

00:02:42,810 --> 00:02:48,410
paradigm that they let developers

00:02:45,270 --> 00:02:51,480
express when they're using that language

00:02:48,410 --> 00:02:54,900
but but what about Python Python is is a

00:02:51,480 --> 00:02:56,940
more flexible language than say Java but

00:02:54,900 --> 00:03:01,020
is a considerably less flexible language

00:02:56,940 --> 00:03:03,270
than say JavaScript and these days it

00:03:01,020 --> 00:03:05,400
has features that make it as descriptive

00:03:03,270 --> 00:03:06,690
or as flexible as you want it to be

00:03:05,400 --> 00:03:08,880
unless you use object-oriented

00:03:06,690 --> 00:03:10,830
programming or functional programming

00:03:08,880 --> 00:03:13,080
features you know it can let you express

00:03:10,830 --> 00:03:15,540
things as as functions or let you

00:03:13,080 --> 00:03:17,549
express things as classes or as

00:03:15,540 --> 00:03:19,500
co-routines and and so python doesn't

00:03:17,549 --> 00:03:23,070
kind of fit this object-oriented

00:03:19,500 --> 00:03:26,010
functional sort of paradigm split and

00:03:23,070 --> 00:03:27,570
I've been wondering about how you you go

00:03:26,010 --> 00:03:30,120
about discussing how people write code

00:03:27,570 --> 00:03:33,930
in Python and I saw a talk by luciano

00:03:30,120 --> 00:03:35,820
Hamal yahoo who wrote fluent Python at

00:03:33,930 --> 00:03:37,739
PI Caribbean this year and and he

00:03:35,820 --> 00:03:41,130
explained a really great framework to

00:03:37,739 --> 00:03:42,720
think about how programming languages

00:03:41,130 --> 00:03:44,489
let you express things and he talks

00:03:42,720 --> 00:03:46,980
about languages having features that you

00:03:44,489 --> 00:03:48,630
can use and not paradigms and you can

00:03:46,980 --> 00:03:51,390
think in terms of the feature set that a

00:03:48,630 --> 00:03:52,950
a language gives you and if you think in

00:03:51,390 --> 00:03:56,730
terms of that feature set you can make

00:03:52,950 --> 00:03:58,019
your programs more expressive by using

00:03:56,730 --> 00:04:01,920
the feature set of that language to the

00:03:58,019 --> 00:04:03,810
best of your of your abilities and that

00:04:01,920 --> 00:04:05,640
brings us to the topic of design

00:04:03,810 --> 00:04:09,060
patterns which is what I said I'd be

00:04:05,640 --> 00:04:11,519
talking about today so let's start with

00:04:09,060 --> 00:04:14,820
some definitions because I did see I

00:04:11,519 --> 00:04:17,669
school debating the definition that I

00:04:14,820 --> 00:04:20,760
came up with is that design patterns are

00:04:17,669 --> 00:04:24,780
things that let you express ideas that

00:04:20,760 --> 00:04:26,590
are hard to express in your language but

00:04:24,780 --> 00:04:30,220
in a familiar way

00:04:26,590 --> 00:04:32,380
and the vast majority of common design

00:04:30,220 --> 00:04:34,600
patterns are object-oriented ones and

00:04:32,380 --> 00:04:37,540
the most common of those object-oriented

00:04:34,600 --> 00:04:39,070
design patterns came from the mid 90s

00:04:37,540 --> 00:04:40,960
they were sort of put forward by a group

00:04:39,070 --> 00:04:43,120
known as the Gang of Four because there

00:04:40,960 --> 00:04:45,400
were four of them and they were written

00:04:43,120 --> 00:04:48,220
if you you know your programming

00:04:45,400 --> 00:04:50,919
language history in the mid-90s rigid

00:04:48,220 --> 00:04:52,449
languages like Java and C++ were the

00:04:50,919 --> 00:04:54,639
state of the art that everybody was sort

00:04:52,449 --> 00:04:56,320
of moving towards and so these design

00:04:54,639 --> 00:04:59,310
patterns that were espoused by the Gang

00:04:56,320 --> 00:05:02,350
of Four they tend to fix issues with

00:04:59,310 --> 00:05:05,620
expressivity that occurs in languages

00:05:02,350 --> 00:05:10,000
that either are or look a lot like C++

00:05:05,620 --> 00:05:12,250
or Java and so today we are going to

00:05:10,000 --> 00:05:14,290
write some implementations of some

00:05:12,250 --> 00:05:16,690
common object-oriented design patterns

00:05:14,290 --> 00:05:18,280
as if we'd be implementing them in

00:05:16,690 --> 00:05:19,510
another language but we're getting use

00:05:18,280 --> 00:05:22,539
Python because there's a Python

00:05:19,510 --> 00:05:24,729
conference and then we're going to look

00:05:22,539 --> 00:05:26,620
at what features we can use in Python

00:05:24,729 --> 00:05:28,930
that lets us avoid using those design

00:05:26,620 --> 00:05:30,550
patterns and the end result is that

00:05:28,930 --> 00:05:33,639
we'll end up with some code that makes

00:05:30,550 --> 00:05:36,310
the best use of the features that Python

00:05:33,639 --> 00:05:37,930
gives you to write code and that's

00:05:36,310 --> 00:05:41,110
hopefully going to help you to come up

00:05:37,930 --> 00:05:43,210
with ideas on how to port code or ideas

00:05:41,110 --> 00:05:45,490
to Python without simply transliterating

00:05:43,210 --> 00:05:47,080
it but more importantly is the

00:05:45,490 --> 00:05:49,599
understanding why certain design

00:05:47,080 --> 00:05:51,310
patterns are unnecessary means that you

00:05:49,599 --> 00:05:53,200
can communicate with developers who use

00:05:51,310 --> 00:05:55,240
other languages much more effectively

00:05:53,200 --> 00:05:57,160
and that might be through writing better

00:05:55,240 --> 00:05:59,770
Python code and explaining your Python

00:05:57,160 --> 00:06:02,110
code better or being understand like or

00:05:59,770 --> 00:06:03,970
being able to understand why code that's

00:06:02,110 --> 00:06:07,120
not written in Python does things in a

00:06:03,970 --> 00:06:10,960
particular way that may seem clunky or

00:06:07,120 --> 00:06:13,090
unfamiliar to you and so to start off

00:06:10,960 --> 00:06:15,370
with this discussion I'm going to start

00:06:13,090 --> 00:06:17,139
with the single absolute most simple

00:06:15,370 --> 00:06:19,240
design pattern areas in object-oriented

00:06:17,139 --> 00:06:23,139
programming and that pattern is the

00:06:19,240 --> 00:06:25,690
singleton and before I get into this I

00:06:23,139 --> 00:06:27,820
need to warn you that the approach that

00:06:25,690 --> 00:06:29,800
I'm going to use is starting with a bad

00:06:27,820 --> 00:06:31,780
implementation of something then

00:06:29,800 --> 00:06:34,380
implementing it more or less well in

00:06:31,780 --> 00:06:36,159
Python and then implementing it or

00:06:34,380 --> 00:06:38,289
implementing something completely

00:06:36,159 --> 00:06:39,009
different and I've had people take

00:06:38,289 --> 00:06:40,539
photos on the

00:06:39,009 --> 00:06:42,369
second thing and post them to Twitter

00:06:40,539 --> 00:06:43,659
and then I've had arguments about how to

00:06:42,369 --> 00:06:45,699
implement something that I don't really

00:06:43,659 --> 00:06:47,110
care to implement so make sure if you're

00:06:45,699 --> 00:06:49,180
going to take photos of my slides take

00:06:47,110 --> 00:06:51,069
photos of the right slides I won't tell

00:06:49,180 --> 00:06:51,839
you which slides the right slide so use

00:06:51,069 --> 00:06:55,089
your judgment

00:06:51,839 --> 00:06:58,809
so Singleton's Singleton's are classes

00:06:55,089 --> 00:07:00,879
that can only be constructed once so

00:06:58,809 --> 00:07:03,789
let's have a look at an implementation

00:07:00,879 --> 00:07:06,189
of a singleton as you would probably

00:07:03,789 --> 00:07:08,110
implemented in a language like C++ or

00:07:06,189 --> 00:07:09,969
Java so if we were writing Java code in

00:07:08,110 --> 00:07:10,990
Python our singleton would look

00:07:09,969 --> 00:07:13,659
something like this

00:07:10,990 --> 00:07:16,240
there would be a definition of the class

00:07:13,659 --> 00:07:18,219
which has an attributes that you know

00:07:16,240 --> 00:07:20,589
you you want to store on that singleton

00:07:18,219 --> 00:07:23,199
and then there's an there's an accessor

00:07:20,589 --> 00:07:26,620
function down here that checks to see if

00:07:23,199 --> 00:07:28,569
we've got an instance in there and if it

00:07:26,620 --> 00:07:31,389
doesn't have that instance then we go

00:07:28,569 --> 00:07:32,830
and construct that instance so this is

00:07:31,389 --> 00:07:34,719
this is already really really

00:07:32,830 --> 00:07:36,159
complicated code and it doesn't look

00:07:34,719 --> 00:07:41,110
like something that somebody would

00:07:36,159 --> 00:07:42,520
naturally write in Python you know we're

00:07:41,110 --> 00:07:44,039
playing with global variables here

00:07:42,520 --> 00:07:46,839
global variables aren't very cool

00:07:44,039 --> 00:07:48,490
there's a value check in that accessor

00:07:46,839 --> 00:07:49,240
function and if you've read the Zen of

00:07:48,490 --> 00:07:50,740
Python

00:07:49,240 --> 00:07:52,360
you know that's easier to ask

00:07:50,740 --> 00:07:54,399
forgiveness than permission and then

00:07:52,360 --> 00:07:56,349
that breaks that pattern so let's see if

00:07:54,399 --> 00:07:58,870
we can implement this even more Python

00:07:56,349 --> 00:08:01,029
eclis so you can we've got the same

00:07:58,870 --> 00:08:03,939
class it's it's got the same data but

00:08:01,029 --> 00:08:06,490
instead of the accessor method we're

00:08:03,939 --> 00:08:09,519
explicitly constructing the instance at

00:08:06,490 --> 00:08:11,469
the module level so as the as the module

00:08:09,519 --> 00:08:13,839
gets executed we create our instance and

00:08:11,469 --> 00:08:15,729
and then we delete our constructor

00:08:13,839 --> 00:08:19,330
methods so that future callers can't see

00:08:15,729 --> 00:08:21,159
that constructor method uses features

00:08:19,330 --> 00:08:23,620
that are in Python to let you do this

00:08:21,159 --> 00:08:25,419
this singleton thing in languages like

00:08:23,620 --> 00:08:28,479
Java you'd use a private constructor

00:08:25,419 --> 00:08:29,709
that can only be called once yeah and

00:08:28,479 --> 00:08:32,289
then you access the data from the

00:08:29,709 --> 00:08:36,940
instance just as you would any other way

00:08:32,289 --> 00:08:38,800
so yeah and you also can't call that

00:08:36,940 --> 00:08:40,630
constructor so going del on the the

00:08:38,800 --> 00:08:42,039
class object does actually prevent other

00:08:40,630 --> 00:08:44,169
people from being a to call it so that's

00:08:42,039 --> 00:08:46,750
cool so you can implement Singleton's in

00:08:44,169 --> 00:08:49,420
Python just fine you can implement it as

00:08:46,750 --> 00:08:50,649
if it's Java code as if it's C++ code if

00:08:49,420 --> 00:08:51,770
you're not thinking about how to use

00:08:50,649 --> 00:08:53,330
Python

00:08:51,770 --> 00:08:55,279
or you can implement it in a way that

00:08:53,330 --> 00:08:59,149
looks pythonic without existence test

00:08:55,279 --> 00:09:00,830
without accessor methods but instead of

00:08:59,149 --> 00:09:02,810
doing that you might want to stop and

00:09:00,830 --> 00:09:06,770
ask yourself a question you know why

00:09:02,810 --> 00:09:08,240
would you do something like this and to

00:09:06,770 --> 00:09:08,990
answer that you need to answer a

00:09:08,240 --> 00:09:10,850
different question

00:09:08,990 --> 00:09:12,260
which is what exactly are you actually

00:09:10,850 --> 00:09:15,200
trying to achieve with the code that

00:09:12,260 --> 00:09:16,910
you're writing and so if you go look

00:09:15,200 --> 00:09:19,940
through the Gang of Four you want you'll

00:09:16,910 --> 00:09:22,220
see why people are using languages like

00:09:19,940 --> 00:09:24,680
C++ or Java needs Singleton's and the

00:09:22,220 --> 00:09:27,380
first reason is that in pure are

00:09:24,680 --> 00:09:29,390
languages like Java in particular where

00:09:27,380 --> 00:09:32,330
everything has to be inside class you

00:09:29,390 --> 00:09:34,459
get name spacing from Singleton's you

00:09:32,330 --> 00:09:36,290
can put all the related data and related

00:09:34,459 --> 00:09:39,350
functions into the same class and make

00:09:36,290 --> 00:09:40,940
that a singleton but Python already has

00:09:39,350 --> 00:09:42,920
pretty good name spacing functionality

00:09:40,940 --> 00:09:46,040
you don't need to create classes to get

00:09:42,920 --> 00:09:48,140
namespaces the other reason why

00:09:46,040 --> 00:09:50,120
Singleton's are useful is so that you

00:09:48,140 --> 00:09:54,080
can pass functionality around to other

00:09:50,120 --> 00:09:56,360
functions a singleton might be a derived

00:09:54,080 --> 00:09:59,120
class of a base class or an Oran

00:09:56,360 --> 00:10:01,579
interface so say you have two single

00:09:59,120 --> 00:10:03,709
nuns that have the same interface so you

00:10:01,579 --> 00:10:05,660
know we've got one singleton called spam

00:10:03,709 --> 00:10:07,790
which has some data on it and the other

00:10:05,660 --> 00:10:10,730
singleton is called called eggs which

00:10:07,790 --> 00:10:13,370
has some data on it and so got the same

00:10:10,730 --> 00:10:15,890
interface as far as far as your python

00:10:13,370 --> 00:10:18,410
is concerned you you can pass them into

00:10:15,890 --> 00:10:20,209
a function because they've got the same

00:10:18,410 --> 00:10:20,990
interface and you want to get errors and

00:10:20,209 --> 00:10:23,240
stuff like that

00:10:20,990 --> 00:10:25,490
so here are two things we need we need

00:10:23,240 --> 00:10:28,790
we need firstly to prevent multiple

00:10:25,490 --> 00:10:31,160
construction of our of our you name

00:10:28,790 --> 00:10:33,860
Spacey thingy and we also need to be

00:10:31,160 --> 00:10:36,829
able to pass our object as arguments to

00:10:33,860 --> 00:10:38,839
a function and it turns out that Python

00:10:36,829 --> 00:10:41,500
already has a feature that lets you pass

00:10:38,839 --> 00:10:44,060
these that lets you do these two things

00:10:41,500 --> 00:10:46,220
that features pythons built-in module

00:10:44,060 --> 00:10:49,910
system and and let's look at why this

00:10:46,220 --> 00:10:52,339
works first up in Python everything or

00:10:49,910 --> 00:10:54,620
almost everything is a variable and by

00:10:52,339 --> 00:10:56,779
almost I mean that anything that holds

00:10:54,620 --> 00:10:59,180
data or holds functionality is a

00:10:56,779 --> 00:11:00,980
variable and what this means for you is

00:10:59,180 --> 00:11:02,510
that class instances and modules look

00:11:00,980 --> 00:11:03,860
more or less like exactly the same sort

00:11:02,510 --> 00:11:04,529
of thing once you start passing them

00:11:03,860 --> 00:11:07,620
around

00:11:04,529 --> 00:11:09,240
to consumers so instead of defining

00:11:07,620 --> 00:11:11,459
classes to hold all your data you can

00:11:09,240 --> 00:11:13,709
define a series of modules that have the

00:11:11,459 --> 00:11:14,939
same attributes in them and you can pass

00:11:13,709 --> 00:11:18,120
them around as if they were the same

00:11:14,939 --> 00:11:19,949
instances as you had before and as you

00:11:18,120 --> 00:11:22,199
probably already know by now pythons

00:11:19,949 --> 00:11:23,999
import mechanism makes sure that you

00:11:22,199 --> 00:11:25,470
always end up with the same object when

00:11:23,999 --> 00:11:27,029
you import a module no matter how many

00:11:25,470 --> 00:11:29,220
times you import it and no matter where

00:11:27,029 --> 00:11:32,639
you import it from and so you get this

00:11:29,220 --> 00:11:35,339
interpreter level enforcement of single

00:11:32,639 --> 00:11:36,809
single construction regardless of what

00:11:35,339 --> 00:11:38,100
you do with that object which is which

00:11:36,809 --> 00:11:41,009
is cool so it does both of the things

00:11:38,100 --> 00:11:42,329
that we want and so in summary you don't

00:11:41,009 --> 00:11:43,920
need to go and implement things as

00:11:42,329 --> 00:11:45,509
Singleton's in pythons because the

00:11:43,920 --> 00:11:47,910
module infrastructure in Python does

00:11:45,509 --> 00:11:49,499
that for you and it does it for you in a

00:11:47,910 --> 00:11:51,779
way that's more expressible and more

00:11:49,499 --> 00:11:53,790
familiar to even beginner Python

00:11:51,779 --> 00:11:55,319
programmers you don't need to explain to

00:11:53,790 --> 00:11:57,720
them all these features that prevent you

00:11:55,319 --> 00:11:59,220
from constructing something more than

00:11:57,720 --> 00:12:02,399
once because you know they see modules

00:11:59,220 --> 00:12:04,050
when they start coding basically and so

00:12:02,399 --> 00:12:06,209
following on the same line we're going

00:12:04,050 --> 00:12:08,430
to look at a technique called dependency

00:12:06,209 --> 00:12:11,399
injection dependency injection is

00:12:08,430 --> 00:12:13,079
particularly popular in in java land to

00:12:11,399 --> 00:12:16,889
the point that there are giant

00:12:13,079 --> 00:12:22,889
frameworks that that do this thing for

00:12:16,889 --> 00:12:24,529
you it's exceedingly popular and the

00:12:22,889 --> 00:12:27,360
basic idea is that you provide

00:12:24,529 --> 00:12:30,029
dependencies to classes as you construct

00:12:27,360 --> 00:12:32,189
those classes rather than the classes

00:12:30,029 --> 00:12:35,790
going and finding the dependencies as

00:12:32,189 --> 00:12:37,139
they need to use them ironically these

00:12:35,790 --> 00:12:38,639
dependencies often turn out to be

00:12:37,139 --> 00:12:39,839
Singleton's in case you want a clue as

00:12:38,639 --> 00:12:44,430
to where this section of the talk is

00:12:39,839 --> 00:12:49,050
going ok so the best way to illustrate

00:12:44,430 --> 00:12:52,559
this is by working in Reverse say you

00:12:49,050 --> 00:12:55,019
want to create malar objects that retain

00:12:52,559 --> 00:12:56,519
a sender address and so you can send

00:12:55,019 --> 00:13:00,149
lots and lots of emails from that same

00:12:56,519 --> 00:13:03,329
address so here we construct our malar

00:13:00,149 --> 00:13:05,579
object and we have this send method down

00:13:03,329 --> 00:13:07,350
here which calls out this the send mail

00:13:05,579 --> 00:13:09,809
function that we've imported from

00:13:07,350 --> 00:13:11,610
somewhere like that this is a contrived

00:13:09,809 --> 00:13:14,420
thing that might look okay in Jango if

00:13:11,610 --> 00:13:16,319
you look squint really really hard so

00:13:14,420 --> 00:13:18,160
the version with dependency injection

00:13:16,319 --> 00:13:20,470
kind of looks different

00:13:18,160 --> 00:13:22,449
rather than importing sendmail we pass

00:13:20,470 --> 00:13:24,639
in an object at construction time which

00:13:22,449 --> 00:13:26,410
is this this mail sender thing that's

00:13:24,639 --> 00:13:29,739
the dependency that we are injecting

00:13:26,410 --> 00:13:32,049
and then we call the method on the on

00:13:29,739 --> 00:13:33,939
the object that we the dependency that

00:13:32,049 --> 00:13:36,249
we injected so this version is is

00:13:33,939 --> 00:13:38,709
strongly object-oriented it basically

00:13:36,249 --> 00:13:39,939
comes as a necessity based on how Java

00:13:38,709 --> 00:13:41,410
works historically if we're going to

00:13:39,939 --> 00:13:43,209
implement this in a way that looks good

00:13:41,410 --> 00:13:46,179
in Python it would probably look like

00:13:43,209 --> 00:13:48,189
this we pass in a a function at

00:13:46,179 --> 00:13:51,189
construction time and then call this

00:13:48,189 --> 00:13:53,829
stored function it's it's not nearly as

00:13:51,189 --> 00:13:56,309
pythonic as importing the function you

00:13:53,829 --> 00:13:58,779
want and then calling it directly though

00:13:56,309 --> 00:14:00,279
and and you know to remind you that's

00:13:58,779 --> 00:14:02,049
what importing the function looks like

00:14:00,279 --> 00:14:02,369
in case you don't know what that looks

00:14:02,049 --> 00:14:05,379
like

00:14:02,369 --> 00:14:07,989
okay so why would you write it the first

00:14:05,379 --> 00:14:10,660
way people who write Java code for a

00:14:07,989 --> 00:14:11,350
living could write their code exactly

00:14:10,660 --> 00:14:12,730
like this

00:14:11,350 --> 00:14:15,999
you know import the function that they

00:14:12,730 --> 00:14:18,129
want and call it directly but Java

00:14:15,999 --> 00:14:20,259
coders don't do this so let's talk about

00:14:18,129 --> 00:14:23,369
why you would want to write things with

00:14:20,259 --> 00:14:23,369
dependency injection

00:14:24,480 --> 00:14:30,879
testing testing and specifically unit

00:14:29,139 --> 00:14:32,919
testing that's that's testing where you

00:14:30,879 --> 00:14:33,999
separate out all the individual parts of

00:14:32,919 --> 00:14:36,699
your code and test them individually

00:14:33,999 --> 00:14:40,149
against known data and known dependency

00:14:36,699 --> 00:14:42,429
behaviors so unfortunately most people

00:14:40,149 --> 00:14:45,579
don't write code that is amenable to

00:14:42,429 --> 00:14:47,589
easy unit testing instead they write

00:14:45,579 --> 00:14:50,199
code that relies heavily upon

00:14:47,589 --> 00:14:51,489
dependencies and so when you have

00:14:50,199 --> 00:14:54,309
dependencies that are embedded within

00:14:51,489 --> 00:14:56,110
your code you need to use mocks to get

00:14:54,309 --> 00:14:57,939
rid of those dependencies mocks our

00:14:56,110 --> 00:15:00,160
pretend versions of functions or objects

00:14:57,939 --> 00:15:02,709
that provide known fixed behavior for

00:15:00,160 --> 00:15:04,869
you to reason about and test and most

00:15:02,709 --> 00:15:07,360
object-oriented languages have mocking

00:15:04,869 --> 00:15:09,100
frameworks the mocking framework in

00:15:07,360 --> 00:15:11,499
Python however is actually very very

00:15:09,100 --> 00:15:15,339
different to how mocking frameworks in

00:15:11,499 --> 00:15:17,559
say Java work and the reason for this is

00:15:15,339 --> 00:15:19,269
that in Python basically every variable

00:15:17,559 --> 00:15:20,439
everywhere including those variables

00:15:19,269 --> 00:15:22,619
that are in the standard library or

00:15:20,439 --> 00:15:25,629
space like that they're all writable and

00:15:22,619 --> 00:15:27,489
because every module function an object

00:15:25,629 --> 00:15:30,399
is a variable in Python that means that

00:15:27,489 --> 00:15:31,420
you can write to any module function or

00:15:30,399 --> 00:15:34,960
variable or

00:15:31,420 --> 00:15:37,420
object so instead of you know writing a

00:15:34,960 --> 00:15:40,030
mock like like this and passing it into

00:15:37,420 --> 00:15:42,220
our object at construction time instead

00:15:40,030 --> 00:15:44,550
we can override the dependency without

00:15:42,220 --> 00:15:49,600
our mock function like like this and

00:15:44,550 --> 00:15:51,760
test that behavior instead I've written

00:15:49,600 --> 00:15:54,940
code that does exactly this thing I

00:15:51,760 --> 00:15:56,530
don't particularly recommend it instead

00:15:54,940 --> 00:15:58,720
there are frameworks that can do that

00:15:56,530 --> 00:16:00,820
overriding for you and do it in a way

00:15:58,720 --> 00:16:02,290
that is that it's tractable and and

00:16:00,820 --> 00:16:04,530
understandable and it's right there in

00:16:02,290 --> 00:16:07,030
the standard library in unit tests mock

00:16:04,530 --> 00:16:09,040
and so unit test dot mark has a patch

00:16:07,030 --> 00:16:11,950
function it allows you to patch any

00:16:09,040 --> 00:16:13,990
namespace object with a mock object and

00:16:11,950 --> 00:16:16,360
you can ask questions that mock object

00:16:13,990 --> 00:16:18,820
at the end of your test and and patch

00:16:16,360 --> 00:16:22,450
will undo any changes that you might

00:16:18,820 --> 00:16:24,370
make once you leave that scope so in

00:16:22,450 --> 00:16:26,400
summary python doesn't need dependency

00:16:24,370 --> 00:16:29,950
injection because you can override any

00:16:26,400 --> 00:16:33,340
objects any objects or functions that

00:16:29,950 --> 00:16:35,110
you need to override at test time so I

00:16:33,340 --> 00:16:36,880
promise in the abstract that I talk

00:16:35,110 --> 00:16:40,900
about threads who came here to hear me

00:16:36,880 --> 00:16:43,300
talk about threads I'm sorry I'm not

00:16:40,900 --> 00:16:48,460
going to talk about threads go check out

00:16:43,300 --> 00:16:50,140
async i/o instead so the next thing that

00:16:48,460 --> 00:16:51,760
we are going to talk about is something

00:16:50,140 --> 00:16:56,140
in a slightly different direction I'm

00:16:51,760 --> 00:16:57,760
going to talk about iterators the

00:16:56,140 --> 00:16:59,980
iterator pattern is something that lets

00:16:57,760 --> 00:17:03,430
you iterate over custom collection types

00:16:59,980 --> 00:17:05,260
you may be familiar with them here's a

00:17:03,430 --> 00:17:07,720
really bad implementation of pythons

00:17:05,260 --> 00:17:10,540
range object it's got a constructor it

00:17:07,720 --> 00:17:14,050
takes up to three arguments and it has

00:17:10,540 --> 00:17:16,300
an utter function that returns a range

00:17:14,050 --> 00:17:17,980
iterator and then in range iterator

00:17:16,300 --> 00:17:20,410
looks something like this it has a

00:17:17,980 --> 00:17:22,990
constructor that sets the initial

00:17:20,410 --> 00:17:25,330
current value of the iterator and it has

00:17:22,990 --> 00:17:27,880
a next function that returns the next

00:17:25,330 --> 00:17:31,600
item in the range or raises stop

00:17:27,880 --> 00:17:33,640
iteration if there's no next item I've

00:17:31,600 --> 00:17:34,990
also added this this has next function

00:17:33,640 --> 00:17:37,840
down the bottom because this is what

00:17:34,990 --> 00:17:39,520
Java's iterator pattern expects it's

00:17:37,840 --> 00:17:42,520
also going to make the next slide a bit

00:17:39,520 --> 00:17:44,800
easier to read and so you can iterate

00:17:42,520 --> 00:17:45,220
over this iterator with a while loop

00:17:44,800 --> 00:17:48,880
if

00:17:45,220 --> 00:17:50,020
wanted to do so or you could write it

00:17:48,880 --> 00:17:52,059
like this if you're going to use the

00:17:50,020 --> 00:17:53,590
Python primitives and use the built in

00:17:52,059 --> 00:17:55,750
error function and look for stop

00:17:53,590 --> 00:17:57,159
iteration yourself and naturally this

00:17:55,750 --> 00:18:00,010
while loop doesn't look particularly

00:17:57,159 --> 00:18:01,539
pythonic and that's because this

00:18:00,010 --> 00:18:03,220
iterator pattern is actually one that's

00:18:01,539 --> 00:18:05,950
described by Python as being an

00:18:03,220 --> 00:18:07,900
officially supported thing Python

00:18:05,950 --> 00:18:09,880
provides you with a tool to consume

00:18:07,900 --> 00:18:14,440
iterator objects built into the language

00:18:09,880 --> 00:18:16,330
and that feature is the for loop the

00:18:14,440 --> 00:18:18,250
looping construct takes care of calling

00:18:16,330 --> 00:18:20,409
either for you it takes care of calling

00:18:18,250 --> 00:18:23,350
next and takes care of looking for stop

00:18:20,409 --> 00:18:26,470
iteration for you and so you might think

00:18:23,350 --> 00:18:28,179
to yourself but Chris is this not an

00:18:26,470 --> 00:18:32,110
officially supported Python pattern and

00:18:28,179 --> 00:18:34,120
I would say yes but once again I ask you

00:18:32,110 --> 00:18:36,130
this question what are you trying to

00:18:34,120 --> 00:18:41,049
achieve would you like to write an

00:18:36,130 --> 00:18:42,549
iterator like that yourself managing an

00:18:41,049 --> 00:18:44,169
iterator is actually not that easy

00:18:42,549 --> 00:18:46,780
because you have to think about what's

00:18:44,169 --> 00:18:49,419
happening inside a loop completely

00:18:46,780 --> 00:18:51,669
outside of the context of the loop

00:18:49,419 --> 00:18:55,270
itself so you know you have to think

00:18:51,669 --> 00:18:56,650
about what's happening here while your

00:18:55,270 --> 00:18:59,260
consumer is thinking about what's

00:18:56,650 --> 00:19:01,809
happening over here and so the solution

00:18:59,260 --> 00:19:04,030
to that is generators and generators are

00:19:01,809 --> 00:19:06,100
like functions but they handle packing

00:19:04,030 --> 00:19:12,730
this state away for when you aren't

00:19:06,100 --> 00:19:14,440
using them if you're going to talk ok

00:19:12,730 --> 00:19:16,750
generators are like functions that

00:19:14,440 --> 00:19:19,840
handle packing away State for you when

00:19:16,750 --> 00:19:22,570
you aren't using them so instead you can

00:19:19,840 --> 00:19:24,490
write an iterator in terms of loops it's

00:19:22,570 --> 00:19:26,140
it's much simple to write and you get to

00:19:24,490 --> 00:19:29,440
think about the same sort of programming

00:19:26,140 --> 00:19:30,789
construct in your iterator code as the

00:19:29,440 --> 00:19:34,059
place that's going to use your iterator

00:19:30,789 --> 00:19:36,549
code and in the case of in the case of

00:19:34,059 --> 00:19:38,980
Python I write my own iterators a lot

00:19:36,549 --> 00:19:41,890
more frequently than I do in languages

00:19:38,980 --> 00:19:43,720
like Java or C++ because it's much much

00:19:41,890 --> 00:19:45,100
easier to write my own iterators in

00:19:43,720 --> 00:19:47,650
Python now there's a language construct

00:19:45,100 --> 00:19:49,690
for it so you don't need these explicit

00:19:47,650 --> 00:19:52,179
iterators because generators actually

00:19:49,690 --> 00:19:55,330
make it easier and so we're going to run

00:19:52,179 --> 00:19:57,400
with that idea taking you know using

00:19:55,330 --> 00:20:01,900
generators in Python to

00:19:57,400 --> 00:20:04,450
to render other design patterns obsolete

00:20:01,900 --> 00:20:06,970
and the pattern I'm going to look at is

00:20:04,450 --> 00:20:08,890
the visitor pattern and the idea of the

00:20:06,970 --> 00:20:11,620
visitor pattern is that you easily

00:20:08,890 --> 00:20:13,930
perform common operations on all the

00:20:11,620 --> 00:20:18,100
elements of a collection and you do this

00:20:13,930 --> 00:20:20,220
by passing an operation object to that

00:20:18,100 --> 00:20:23,380
collection and the collection goes off

00:20:20,220 --> 00:20:26,560
to find all the elements of it and tells

00:20:23,380 --> 00:20:28,930
the operation which elements to perform

00:20:26,560 --> 00:20:31,140
the operation on basically it has a

00:20:28,930 --> 00:20:34,330
concept of acceptors and visitors

00:20:31,140 --> 00:20:37,090
acceptors are your are your collections

00:20:34,330 --> 00:20:38,380
and visitors are the operations that you

00:20:37,090 --> 00:20:41,920
want to perform on each of the items

00:20:38,380 --> 00:20:43,690
inside your collection so I've got a

00:20:41,920 --> 00:20:45,370
generic tree like data structure here

00:20:43,690 --> 00:20:47,740
I'm using a very generic sort of tree

00:20:45,370 --> 00:20:50,680
because I didn't want to write I didn't

00:20:47,740 --> 00:20:51,790
want to have too much complication here

00:20:50,680 --> 00:20:53,770
but this could be anything you want to

00:20:51,790 --> 00:20:56,830
traverse it could be like a directory

00:20:53,770 --> 00:20:58,540
structure in your file system or a JSON

00:20:56,830 --> 00:21:01,540
object or something like it has it has

00:20:58,540 --> 00:21:04,600
data at it at each point in the tree and

00:21:01,540 --> 00:21:07,060
it has some children and so if we're

00:21:04,600 --> 00:21:09,040
implementing the visitor pattern we have

00:21:07,060 --> 00:21:11,250
a method that accepts a visitor

00:21:09,040 --> 00:21:15,250
operation we've called it except here

00:21:11,250 --> 00:21:17,080
and that visitor operation makes sure

00:21:15,250 --> 00:21:18,760
that every element gets visited by the

00:21:17,080 --> 00:21:20,710
visitor sort of bite by going down the

00:21:18,760 --> 00:21:22,840
left side and then looking at the

00:21:20,710 --> 00:21:25,270
current item and then going on the right

00:21:22,840 --> 00:21:26,890
hand side of it and a visitor will look

00:21:25,270 --> 00:21:30,970
like this it has a method that accepts

00:21:26,890 --> 00:21:33,880
an item and it has a way to perform an

00:21:30,970 --> 00:21:36,610
operation on it and so we can look at

00:21:33,880 --> 00:21:38,830
this again and we can we can wonder what

00:21:36,610 --> 00:21:40,950
we're trying to achieve and and as with

00:21:38,830 --> 00:21:43,600
all design patterns it exists because

00:21:40,950 --> 00:21:46,030
something wasn't easy to do in another

00:21:43,600 --> 00:21:47,500
language so let's think about what it's

00:21:46,030 --> 00:21:49,090
actually trying to achieve and then

00:21:47,500 --> 00:21:51,490
write some code that doesn't in a way

00:21:49,090 --> 00:21:52,930
that actually looks good so in this case

00:21:51,490 --> 00:21:55,180
what we want to do is want to separate

00:21:52,930 --> 00:21:56,620
the structure of a collection from the

00:21:55,180 --> 00:22:00,070
operation that we're trying to perform

00:21:56,620 --> 00:22:02,680
and as I said before not every language

00:22:00,070 --> 00:22:05,290
makes iteration easy the visitor pattern

00:22:02,680 --> 00:22:07,960
came about before most object-oriented

00:22:05,290 --> 00:22:10,260
languages had built-in first-class

00:22:07,960 --> 00:22:12,450
support for iterators

00:22:10,260 --> 00:22:14,820
was much easier for classes themselves

00:22:12,450 --> 00:22:16,620
to know what their own structure look

00:22:14,820 --> 00:22:19,200
like and handle calling operations

00:22:16,620 --> 00:22:21,840
themselves rather than trusting and

00:22:19,200 --> 00:22:25,170
outside caller to know how to handle the

00:22:21,840 --> 00:22:28,200
the order of iteration correctly but as

00:22:25,170 --> 00:22:29,970
we discovered previously Python not only

00:22:28,200 --> 00:22:32,190
supports first class iterators it

00:22:29,970 --> 00:22:34,890
actually makes it easy to do that and so

00:22:32,190 --> 00:22:36,990
instead of writing a visitor acceptor

00:22:34,890 --> 00:22:38,930
pattern you just make it easy to get at

00:22:36,990 --> 00:22:42,420
each element of your collection in turn

00:22:38,930 --> 00:22:44,400
using an iterator and then you can

00:22:42,420 --> 00:22:46,890
perform your operation inside a for loop

00:22:44,400 --> 00:22:49,110
and this is kind of great because people

00:22:46,890 --> 00:22:50,790
who write Python know that for loops

00:22:49,110 --> 00:22:52,980
indicate you're going to do something on

00:22:50,790 --> 00:22:55,260
each element of a collection so this

00:22:52,980 --> 00:22:57,000
actually signals to people who know what

00:22:55,260 --> 00:22:58,830
Python looks like that we're doing

00:22:57,000 --> 00:23:00,330
something across multiple items of a

00:22:58,830 --> 00:23:03,300
collection which is not something that

00:23:00,330 --> 00:23:05,760
the visitor pattern does natively so in

00:23:03,300 --> 00:23:07,710
this case iterators separate the

00:23:05,760 --> 00:23:09,330
structure of the collection from the

00:23:07,710 --> 00:23:12,150
operation that you want to perform on

00:23:09,330 --> 00:23:15,180
the elements and it uses signals within

00:23:12,150 --> 00:23:17,580
the code to tell the the reader exactly

00:23:15,180 --> 00:23:20,520
what is going on and you don't have to

00:23:17,580 --> 00:23:23,040
worry about the whole encapsulation of

00:23:20,520 --> 00:23:25,590
classes which is actually something that

00:23:23,040 --> 00:23:28,800
Python makes quite difficult to do at

00:23:25,590 --> 00:23:30,000
least compared with with Java and so

00:23:28,800 --> 00:23:31,980
like if you need to have different

00:23:30,000 --> 00:23:33,330
multiple different iteration methods

00:23:31,980 --> 00:23:35,550
like depending on the order in which you

00:23:33,330 --> 00:23:36,960
traverse down things it's not hard to

00:23:35,550 --> 00:23:39,840
write multiple generators because

00:23:36,960 --> 00:23:42,060
writing generators is easy and so Python

00:23:39,840 --> 00:23:43,950
doesn't need visitors because generators

00:23:42,060 --> 00:23:46,080
separate the structure from operators

00:23:43,950 --> 00:23:48,750
from operations and that's what the

00:23:46,080 --> 00:23:51,510
visitor pattern does and so that's

00:23:48,750 --> 00:23:53,070
that's for design patterns that don't

00:23:51,510 --> 00:23:54,660
actually make all that much sense in

00:23:53,070 --> 00:23:57,470
Python because there are features in

00:23:54,660 --> 00:24:00,030
Python that let you do that

00:23:57,470 --> 00:24:01,650
here are some bonus slides for you that

00:24:00,030 --> 00:24:04,140
I wrote after the last time I gave this

00:24:01,650 --> 00:24:05,790
talk because I wanted to point out that

00:24:04,140 --> 00:24:08,070
there are some venerable design patterns

00:24:05,790 --> 00:24:10,680
even from the Gang of Four book that not

00:24:08,070 --> 00:24:14,100
only work in Python but are actually the

00:24:10,680 --> 00:24:15,750
right thing to do so let's look at the

00:24:14,100 --> 00:24:17,460
factory pattern factory pattern our

00:24:15,750 --> 00:24:19,200
factories are callable x' that can

00:24:17,460 --> 00:24:21,990
create instances of an object that

00:24:19,200 --> 00:24:23,670
fulfills a certain interface so here's a

00:24:21,990 --> 00:24:27,180
URL reader Factory it's

00:24:23,670 --> 00:24:30,060
it's a static method on a class it looks

00:24:27,180 --> 00:24:31,950
at some parameter and returns the right

00:24:30,060 --> 00:24:34,500
sort of thing that you can read from

00:24:31,950 --> 00:24:37,130
based on the sort of URL that you pass

00:24:34,500 --> 00:24:40,440
in this is a really flimsy

00:24:37,130 --> 00:24:44,790
implementation of of URL opener in URL

00:24:40,440 --> 00:24:47,600
Lib and so factories exist in Python

00:24:44,790 --> 00:24:49,980
because constructors in base classes

00:24:47,600 --> 00:24:51,960
have to return an instance of that

00:24:49,980 --> 00:24:55,170
particular base class they can't return

00:24:51,960 --> 00:24:57,030
instances of subclasses and this this is

00:24:55,170 --> 00:24:58,650
a limitation in Python it's a limitation

00:24:57,030 --> 00:25:01,110
in basically every object-oriented

00:24:58,650 --> 00:25:02,640
language there is but you might be

00:25:01,110 --> 00:25:04,320
wondering here why is there a static

00:25:02,640 --> 00:25:07,290
method here and whole object and all

00:25:04,320 --> 00:25:09,870
those sorts of things so let's look at

00:25:07,290 --> 00:25:12,000
how we construct things in Python when

00:25:09,870 --> 00:25:13,920
you construct things in in Java for

00:25:12,000 --> 00:25:16,740
example you have to go I like you want

00:25:13,920 --> 00:25:19,680
to construct an object you go new that

00:25:16,740 --> 00:25:23,010
object there in Python well we've got

00:25:19,680 --> 00:25:26,430
the the open built-in which opens a file

00:25:23,010 --> 00:25:31,080
and the second is is the string i/o

00:25:26,430 --> 00:25:32,760
object and looking at this as a consumer

00:25:31,080 --> 00:25:34,590
you can see that they look like exactly

00:25:32,760 --> 00:25:36,450
the same sort of thing you can't tell if

00:25:34,590 --> 00:25:37,920
you can't tell which is a function you

00:25:36,450 --> 00:25:40,350
can't tell which is a constructor of a

00:25:37,920 --> 00:25:41,940
class you know you don't have to say I

00:25:40,350 --> 00:25:45,410
want new string i/o

00:25:41,940 --> 00:25:47,700
I say just give me a string i/o so

00:25:45,410 --> 00:25:50,190
construction uses the same callable

00:25:47,700 --> 00:25:52,020
patterns as functions and so rather than

00:25:50,190 --> 00:25:54,570
creating a whole class to serve as your

00:25:52,020 --> 00:25:56,790
factory you just use functions instead

00:25:54,570 --> 00:25:58,260
of creating factory classes the logic is

00:25:56,790 --> 00:26:00,540
exactly the same you just call it in a

00:25:58,260 --> 00:26:02,400
different way and so it turns out the

00:26:00,540 --> 00:26:04,380
factories are used all through the

00:26:02,400 --> 00:26:06,360
Python standard library the socket

00:26:04,380 --> 00:26:09,090
constructor is a factory function URL

00:26:06,360 --> 00:26:11,940
openers tend to use factories the open

00:26:09,090 --> 00:26:13,440
function built-in is a factory they're

00:26:11,940 --> 00:26:16,470
used everywhere because they're still

00:26:13,440 --> 00:26:18,150
useful in Python and Brandon Rhodes is

00:26:16,470 --> 00:26:20,190
writing a book on pythonic design

00:26:18,150 --> 00:26:22,290
patterns that include a bunch of design

00:26:20,190 --> 00:26:23,580
patterns are actually useful in Python

00:26:22,290 --> 00:26:25,710
and make use of pass and pythons

00:26:23,580 --> 00:26:27,180
features the factory pattern is one of

00:26:25,710 --> 00:26:30,840
the patterns he introduces but there's

00:26:27,180 --> 00:26:32,460
there's many many more of them so that

00:26:30,840 --> 00:26:34,170
brings us to the end of our tour of

00:26:32,460 --> 00:26:35,640
Python features so you've probably

00:26:34,170 --> 00:26:37,200
realized by now the lot of

00:26:35,640 --> 00:26:39,330
object-oriented patterns look

00:26:37,200 --> 00:26:41,039
quite clumsy in Python and hopefully

00:26:39,330 --> 00:26:43,950
you've kind of got an idea of why this

00:26:41,039 --> 00:26:45,299
is the case so first up a lot of design

00:26:43,950 --> 00:26:47,970
patterns exist because there are

00:26:45,299 --> 00:26:50,279
features in Python that don't exist in

00:26:47,970 --> 00:26:52,169
other languages you should strive to use

00:26:50,279 --> 00:26:53,909
those features that you have access to

00:26:52,169 --> 00:26:57,690
rather than re implementing those

00:26:53,909 --> 00:26:59,639
patterns in Python secondly some

00:26:57,690 --> 00:27:01,769
patterns exist because more rigid

00:26:59,639 --> 00:27:03,870
languages have binding restrictions that

00:27:01,769 --> 00:27:07,049
prevent you from overriding names or

00:27:03,870 --> 00:27:08,639
passing around functions generators

00:27:07,049 --> 00:27:10,700
replace a lot of patterns that describe

00:27:08,639 --> 00:27:12,870
control flow and let you convert

00:27:10,700 --> 00:27:14,460
complicated ideas around state or

00:27:12,870 --> 00:27:17,700
iteration into much more familiar

00:27:14,460 --> 00:27:21,330
constructs and in summary basically when

00:27:17,700 --> 00:27:24,630
you are writing Python write code like

00:27:21,330 --> 00:27:26,840
you're writing Python thank you very

00:27:24,630 --> 00:27:26,840
much

00:27:32,220 --> 00:27:36,299
it looks like I have a couple of minutes

00:27:34,440 --> 00:27:40,970
of questions so if you've got one put

00:27:36,299 --> 00:27:40,970
your hand up and and Mike will find you

00:27:47,370 --> 00:27:53,250
Thanks I've inherited some code which

00:27:50,370 --> 00:27:54,929
was written by a Java programmer and not

00:27:53,250 --> 00:27:58,650
being familiar with Java design patterns

00:27:54,929 --> 00:28:01,020
I don't necessarily recognize what

00:27:58,650 --> 00:28:02,940
constructs there are have you got a hint

00:28:01,020 --> 00:28:04,919
for how I can look at that code and

00:28:02,940 --> 00:28:06,929
think okay right this is this particular

00:28:04,919 --> 00:28:08,940
design pattern and here's how to unpack

00:28:06,929 --> 00:28:11,070
it and make it more pythonic I've read

00:28:08,940 --> 00:28:13,080
the Gang of Four book but read the Gang

00:28:11,070 --> 00:28:15,780
of Four book in a critical way so you

00:28:13,080 --> 00:28:17,400
can think about what things they're

00:28:15,780 --> 00:28:20,750
talking about can be replaced with

00:28:17,400 --> 00:28:20,750
things that exist in Python

00:28:21,960 --> 00:28:26,240
there was someone over there when you're

00:28:23,669 --> 00:28:26,240
interested yeah

00:28:30,610 --> 00:28:37,640
hey Hagen thanks for Talk we use

00:28:35,170 --> 00:28:39,500
factories all the time in everything

00:28:37,640 --> 00:28:41,690
every produce I've ever worked on that

00:28:39,500 --> 00:28:43,790
she's a lot of place but you isolated

00:28:41,690 --> 00:28:46,010
the reason we do that and the reason you

00:28:43,790 --> 00:28:47,690
gave was that when you call the in it

00:28:46,010 --> 00:28:49,310
you wouldn't get back the class that you

00:28:47,690 --> 00:28:51,140
were constructing or not a subclass now

00:28:49,310 --> 00:28:53,480
but in Python we don't need it we've got

00:28:51,140 --> 00:28:56,120
in the dunder new which allows us to

00:28:53,480 --> 00:28:57,530
return a different class type than than

00:28:56,120 --> 00:29:01,430
the class either where you calling the

00:28:57,530 --> 00:29:02,840
constructor on is it maybe that I just

00:29:01,430 --> 00:29:08,780
started thinking maybe that's the way we

00:29:02,840 --> 00:29:11,570
should be implementing factories so I

00:29:08,780 --> 00:29:14,960
think people have an expectation when

00:29:11,570 --> 00:29:16,880
they're writing Python that things will

00:29:14,960 --> 00:29:20,720
behave in certain ways when they do

00:29:16,880 --> 00:29:23,480
certain familiar things and overriding

00:29:20,720 --> 00:29:25,940
news so that it has vastly different

00:29:23,480 --> 00:29:29,290
semantics to what people expect is a way

00:29:25,940 --> 00:29:33,320
to make your code very difficult to read

00:29:29,290 --> 00:29:36,650
creating a factory function is something

00:29:33,320 --> 00:29:37,010
that's understandable by most people I

00:29:36,650 --> 00:29:39,980
think

00:29:37,010 --> 00:29:41,540
whereas doing like overriding news so

00:29:39,980 --> 00:29:44,630
that the behavior of new is different to

00:29:41,540 --> 00:29:46,160
what people expect will you know you

00:29:44,630 --> 00:29:48,410
mean you have to explain how your code

00:29:46,160 --> 00:29:49,790
works to more people I'm always in favor

00:29:48,410 --> 00:29:52,190
of writing code that is that is

00:29:49,790 --> 00:29:55,430
understandable and and easy for other

00:29:52,190 --> 00:29:59,390
people to to read often because I will

00:29:55,430 --> 00:30:02,000
come back to it myself and you'll forget

00:29:59,390 --> 00:30:03,620
how I did things and the simpler code I

00:30:02,000 --> 00:30:05,630
can invariably understand the

00:30:03,620 --> 00:30:06,950
complicated code I can't thank because

00:30:05,630 --> 00:30:09,320
I'm not particularly good at remembering

00:30:06,950 --> 00:30:12,020
what I do you're coming might have been

00:30:09,320 --> 00:30:13,460
a throwaway comment but it's inspired me

00:30:12,020 --> 00:30:18,020
I'm gonna go away and write a decorator

00:30:13,460 --> 00:30:20,360
so that we can do it neatly mmm yeah any

00:30:18,020 --> 00:30:22,880
other questions I think that's all we

00:30:20,360 --> 00:30:24,140
have time for today great okay but thank

00:30:22,880 --> 00:30:26,620
you so much for your talk Christopher

00:30:24,140 --> 00:30:26,620
thank you

00:30:27,520 --> 00:30:29,580

YouTube URL: https://www.youtube.com/watch?v=imW-trt0i9I


