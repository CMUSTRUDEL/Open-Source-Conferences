Title: FP demystified
Publication date: 2018-08-26
Playlist: PyCon Australia 2018
Description: 
	Eugene Van den Bulke

https://2018.pycon-au.org/talks/45075-fp-demystified/

Have you ever eavesdropped on FP developers talking about programming and wondered which planet you landed on? I attended LambdaJam 2018 and felt your pain! Let's demystify Either, Semigroups, Monoids, Functors, Monads, Traversable, Natural transformations etc. by implementing them in Python.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU - https://creativecommons.org/licenses/by/3.0/au/

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,030 --> 00:00:06,290
Reuben welcome to the final track for

00:00:04,110 --> 00:00:10,559
Sunday before lunch

00:00:06,290 --> 00:00:12,719
this one's actually a really interesting

00:00:10,559 --> 00:00:14,460
one for me because I've been to a few

00:00:12,719 --> 00:00:17,699
functional programming talks and I'm

00:00:14,460 --> 00:00:20,119
still utterly mystified so I'm really

00:00:17,699 --> 00:00:25,650
hoping that Eugene can take care of that

00:00:20,119 --> 00:00:27,710
so please make Eugene feel welcome thank

00:00:25,650 --> 00:00:27,710
you

00:00:28,910 --> 00:00:36,260
all right so it's my first back on so I

00:00:32,189 --> 00:00:39,270
maybe turn in my first time talking so a

00:00:36,260 --> 00:00:42,570
few months ago I attempted a another

00:00:39,270 --> 00:00:45,480
conference called lambda jam which

00:00:42,570 --> 00:00:48,450
advertise himself had aimed at expanding

00:00:45,480 --> 00:00:50,430
the skills of functional programmers I'm

00:00:48,450 --> 00:00:52,500
not a functional programmer I would call

00:00:50,430 --> 00:00:55,649
myself FP curious but I decided to

00:00:52,500 --> 00:00:57,449
attend essentially because there's a

00:00:55,649 --> 00:00:59,520
welcome to FP there's a yes that's for

00:00:57,449 --> 00:01:00,930
me and there was a guy called Aaron

00:00:59,520 --> 00:01:03,660
Minsky running an introduction to oh

00:01:00,930 --> 00:01:04,830
camel which is the language I'm

00:01:03,660 --> 00:01:08,939
interested in because it comes from

00:01:04,830 --> 00:01:12,360
France and Oscar is from England so I

00:01:08,939 --> 00:01:15,420
just went and that's the story of my

00:01:12,360 --> 00:01:19,110
time at lambda jam in some ways the

00:01:15,420 --> 00:01:22,770
highlight of a film the jam for me was

00:01:19,110 --> 00:01:26,280
to discover meat using a Chang with the

00:01:22,770 --> 00:01:28,229
mathematicians whose core specialty is

00:01:26,280 --> 00:01:29,490
category theory if you hear functional

00:01:28,229 --> 00:01:30,600
programmers talk about programming they

00:01:29,490 --> 00:01:33,750
talked about category theory all the

00:01:30,600 --> 00:01:36,810
time I'm still struggling to make zoning

00:01:33,750 --> 00:01:38,490
between the two but we see and she was

00:01:36,810 --> 00:01:40,680
absolutely awesome she gave a keynote on

00:01:38,490 --> 00:01:42,299
using category theory so leaning on her

00:01:40,680 --> 00:01:43,890
on very abstract mathematics to

00:01:42,299 --> 00:01:46,350
understand the social justice issues

00:01:43,890 --> 00:01:48,990
which was a very interesting if you have

00:01:46,350 --> 00:01:51,329
a chance to watch it she wrote three

00:01:48,990 --> 00:01:52,890
books now I've read the first two how to

00:01:51,329 --> 00:01:54,149
make power on beyond infinity I'm

00:01:52,890 --> 00:01:56,579
looking forward to reading the last to

00:01:54,149 --> 00:01:58,380
the next one if you take anything from

00:01:56,579 --> 00:02:02,070
that talk is reading a Chang she's

00:01:58,380 --> 00:02:05,040
awesome the following two days where our

00:02:02,070 --> 00:02:06,750
renders for two days I just took and my

00:02:05,040 --> 00:02:08,879
head is my hands my head in my hand

00:02:06,750 --> 00:02:11,610
sorry thinking what am I doing here I

00:02:08,879 --> 00:02:13,830
must be completely stupid I opened up to

00:02:11,610 --> 00:02:15,630
one of one and fellow hng

00:02:13,830 --> 00:02:18,060
who attended the lambda jam for the

00:02:15,630 --> 00:02:20,760
first time a year prior sir prior year

00:02:18,060 --> 00:02:21,750
and II told me you need to watch

00:02:20,760 --> 00:02:24,690
professor frisbee

00:02:21,750 --> 00:02:26,640
what is professor frisbee professor

00:02:24,690 --> 00:02:28,680
frisbee introduces compressible

00:02:26,640 --> 00:02:30,660
functional JavaScript it's a course that

00:02:28,680 --> 00:02:32,060
teaches the abuse abstraction for

00:02:30,660 --> 00:02:34,260
modeling pure functional programs

00:02:32,060 --> 00:02:36,330
functional languages have adopted this

00:02:34,260 --> 00:02:37,920
algebraic construct across the board as

00:02:36,330 --> 00:02:41,100
a way to compose application in a

00:02:37,920 --> 00:02:49,920
principled way let's stop there the

00:02:41,100 --> 00:02:52,350
truth is it's a claymation Hedgehog - so

00:02:49,920 --> 00:02:53,940
alpha is through two hours of claymation

00:02:52,350 --> 00:02:55,530
Hedgehog you're supposed to be

00:02:53,940 --> 00:02:58,560
enlightened as to what functional

00:02:55,530 --> 00:03:01,410
programmers are all about and in some

00:02:58,560 --> 00:03:02,430
ways you get there you get there when

00:03:01,410 --> 00:03:04,530
you have a five-year-old in the house

00:03:02,430 --> 00:03:07,860
running around is it's a bit like you're

00:03:04,530 --> 00:03:09,209
a magnet what is that I'm worried I tell

00:03:07,860 --> 00:03:14,100
my father only to NASCAR developer

00:03:09,209 --> 00:03:16,080
hopefully not so we're going to in the

00:03:14,100 --> 00:03:17,940
remaining time we have cover as much as

00:03:16,080 --> 00:03:22,769
Professor frisbee but not in JavaScript

00:03:17,940 --> 00:03:27,120
in Python it's a very distilled version

00:03:22,769 --> 00:03:28,620
of of the course obviously and all the

00:03:27,120 --> 00:03:30,150
credit for what I'm going to present so

00:03:28,620 --> 00:03:31,350
all the good stuff really should be

00:03:30,150 --> 00:03:34,110
credited to brian lonsdorf

00:03:31,350 --> 00:03:35,790
the guy behind for the frisbee the

00:03:34,110 --> 00:03:41,070
misrepresentation and mistakes are all

00:03:35,790 --> 00:03:43,019
mine let's start with functors and you

00:03:41,070 --> 00:03:45,390
straight factors so here we are

00:03:43,019 --> 00:03:47,310
it's be enough we have a beautiful

00:03:45,390 --> 00:03:49,290
function called next star from strength

00:03:47,310 --> 00:03:52,860
which takes a string containing an

00:03:49,290 --> 00:03:53,910
integer and returns the next character

00:03:52,860 --> 00:03:57,540
when you're incrementing to join the

00:03:53,910 --> 00:03:59,370
string so that's one implementation you

00:03:57,540 --> 00:04:01,110
strip the string then you cast it to an

00:03:59,370 --> 00:04:03,390
integer you add one and you return the

00:04:01,110 --> 00:04:06,269
say chars in of the given integer and it

00:04:03,390 --> 00:04:07,500
just works which is awesome functional

00:04:06,269 --> 00:04:11,040
programmers will have issue with that

00:04:07,500 --> 00:04:13,200
strip cast Inc like they all temporary

00:04:11,040 --> 00:04:16,200
states in some ways we don't like them

00:04:13,200 --> 00:04:17,370
there's very many ways that functions

00:04:16,200 --> 00:04:19,530
are called so here we have a method call

00:04:17,370 --> 00:04:22,200
function call we have an operator use

00:04:19,530 --> 00:04:24,510
edge it's you know not that right for a

00:04:22,200 --> 00:04:26,400
functional programmer so okay that's

00:04:24,510 --> 00:04:28,130
right we can you straight function so we

00:04:26,400 --> 00:04:35,400
could use Hey

00:04:28,130 --> 00:04:37,080
good-o interface does strip and here we

00:04:35,400 --> 00:04:41,490
go it's just function there's no stage

00:04:37,080 --> 00:04:43,980
it's fantastic yeah but it's a nested

00:04:41,490 --> 00:04:46,110
mess so what would a functional programs

00:04:43,980 --> 00:04:48,030
you a fortunate program oh sorry

00:04:46,110 --> 00:04:51,930
and here we have to introduce the

00:04:48,030 --> 00:04:52,860
concept of a box and I'm not going to

00:04:51,930 --> 00:04:55,590
say too much about the box I'm going to

00:04:52,860 --> 00:04:57,630
illustrate what the box does and also we

00:04:55,590 --> 00:05:00,450
need to define one function the identity

00:04:57,630 --> 00:05:02,220
function which given X returns with an X

00:05:00,450 --> 00:05:05,970
returns X which is pretty

00:05:02,220 --> 00:05:06,960
straightforward and as a warning if you

00:05:05,970 --> 00:05:10,140
were in the talk yesterday about

00:05:06,960 --> 00:05:11,520
refactoring a Python code the code I'm

00:05:10,140 --> 00:05:13,050
going to show you is definitely not

00:05:11,520 --> 00:05:15,240
something you want to write at work if

00:05:13,050 --> 00:05:17,850
you are in the Python shop so I'm going

00:05:15,240 --> 00:05:20,850
to write a named anonymous function

00:05:17,850 --> 00:05:22,950
identity and why do I do this because

00:05:20,850 --> 00:05:27,330
functional programmers absolutely love

00:05:22,950 --> 00:05:31,050
their anonymous function what's the box

00:05:27,330 --> 00:05:32,970
so a box is something and I'm going to

00:05:31,050 --> 00:05:34,590
use a very loaded word here it's it's a

00:05:32,970 --> 00:05:37,260
type and you can put something in a box

00:05:34,590 --> 00:05:39,540
so if I put one in the box I've got a

00:05:37,260 --> 00:05:43,070
box containing one what do you do is

00:05:39,540 --> 00:05:45,840
that type well you can map over the type

00:05:43,070 --> 00:05:47,490
if you apply some developer and you know

00:05:45,840 --> 00:05:49,440
the mat keyword using using math using

00:05:47,490 --> 00:05:51,630
iteration or at least that's how I was

00:05:49,440 --> 00:05:53,100
thinking about it but really a

00:05:51,630 --> 00:05:55,530
functional programmer thinks about not

00:05:53,100 --> 00:05:57,000
as composition and all you want to do is

00:05:55,530 --> 00:06:00,000
when you call map you want to apply a

00:05:57,000 --> 00:06:06,360
function to something so the name is

00:06:00,000 --> 00:06:10,110
function anyway we get we get the box

00:06:06,360 --> 00:06:11,340
continue to which is fantastic but you

00:06:10,110 --> 00:06:12,450
know most of the time we don't really

00:06:11,340 --> 00:06:16,170
want to keep things in the box so we

00:06:12,450 --> 00:06:17,220
want to get them out of the box and what

00:06:16,170 --> 00:06:19,160
can obviously change the code so I'm

00:06:17,220 --> 00:06:29,190
going to change in another code for kick

00:06:19,160 --> 00:06:30,810
up get about to the fall so okay so with

00:06:29,190 --> 00:06:32,760
that starts we've chained operation with

00:06:30,810 --> 00:06:36,000
composed functions or composition is

00:06:32,760 --> 00:06:37,470
awesome and then we need to extract that

00:06:36,000 --> 00:06:39,510
single of the box so what we're going to

00:06:37,470 --> 00:06:40,710
do is we could call fold with the

00:06:39,510 --> 00:06:44,009
identity function

00:06:40,710 --> 00:06:46,889
and it returned the whatever was in the

00:06:44,009 --> 00:06:50,090
box off all these to extract the value

00:06:46,889 --> 00:06:52,800
from from the type that you were using

00:06:50,090 --> 00:06:55,410
calling for that identity at the end of

00:06:52,800 --> 00:06:57,509
every composition of function is a bit

00:06:55,410 --> 00:06:59,160
horrendous so you can also obviously

00:06:57,509 --> 00:07:02,130
call fold with a function that does

00:06:59,160 --> 00:07:03,840
something and you get what you want so

00:07:02,130 --> 00:07:05,460
that's what that's where box is so box

00:07:03,840 --> 00:07:08,160
is a type that you can use to compose

00:07:05,460 --> 00:07:10,590
functions and then to transform the

00:07:08,160 --> 00:07:11,880
value and then you you you get that you

00:07:10,590 --> 00:07:13,590
get the expected result so let's

00:07:11,880 --> 00:07:17,099
implement our next cut from the string

00:07:13,590 --> 00:07:18,449
using the box type so what do we do

00:07:17,099 --> 00:07:21,000
first what we're going to put box in the

00:07:18,449 --> 00:07:22,320
type up so we got a box containing a 64

00:07:21,000 --> 00:07:28,099
all right

00:07:22,320 --> 00:07:28,099
- we need to strip it Oh

00:07:32,180 --> 00:07:47,250
next we're going to cast it that 64 bit

00:07:45,360 --> 00:07:56,070
now it's an integer in there

00:07:47,250 --> 00:07:57,930
and then we're going to increment and 65

00:07:56,070 --> 00:07:59,490
and then we're going we know we want to

00:07:57,930 --> 00:08:00,930
extract so we're going to fold it's the

00:07:59,490 --> 00:08:03,120
last operation the last function we're

00:08:00,930 --> 00:08:04,080
going to compose and that's the CHR

00:08:03,120 --> 00:08:06,750
function Wow

00:08:04,080 --> 00:08:08,930
and now we feel so happy we've got a

00:08:06,750 --> 00:08:10,710
very linear data processing pipeline

00:08:08,930 --> 00:08:15,240
functional programmers would arrive

00:08:10,710 --> 00:08:16,830
about that it's it's awesome something

00:08:15,240 --> 00:08:18,449
to say about it like it's nicer than

00:08:16,830 --> 00:08:21,599
that one which was deliberately made

00:08:18,449 --> 00:08:23,070
quite ugly efficiency wise I'm not so

00:08:21,599 --> 00:08:24,900
sure but at least we understand

00:08:23,070 --> 00:08:26,789
something so we very functional

00:08:24,900 --> 00:08:28,409
programmer we want to lift values in two

00:08:26,789 --> 00:08:31,050
types and we want to compose functions

00:08:28,409 --> 00:08:35,520
and then extract the result of it I'm

00:08:31,050 --> 00:08:37,529
just putting it box is a functor so what

00:08:35,520 --> 00:08:38,969
is a functor so I implemented one

00:08:37,529 --> 00:08:41,190
versity but basically it's something

00:08:38,969 --> 00:08:42,719
that can be mapped over so all you need

00:08:41,190 --> 00:08:47,339
all you need is to have a map function

00:08:42,719 --> 00:08:48,930
and that method on it which obey to

00:08:47,339 --> 00:08:51,839
properties the identity though and the

00:08:48,930 --> 00:08:53,670
composition log which are which are

00:08:51,839 --> 00:08:54,430
present in here so you can compose

00:08:53,670 --> 00:08:56,020
several functions

00:08:54,430 --> 00:08:57,940
you can and if you call the identity on

00:08:56,020 --> 00:09:03,339
it nothing changes you get the same

00:08:57,940 --> 00:09:03,910
function awesome before I can keep on

00:09:03,339 --> 00:09:05,440
going

00:09:03,910 --> 00:09:07,750
talking about hunters I need to do a

00:09:05,440 --> 00:09:12,670
little detour through the concept of

00:09:07,750 --> 00:09:15,430
caring so let's say we have a function

00:09:12,670 --> 00:09:18,610
called ad which is very convoluted adds

00:09:15,430 --> 00:09:19,630
two numbers and we want to specialize

00:09:18,610 --> 00:09:21,730
that function and that's something

00:09:19,630 --> 00:09:23,140
that's quite commonly done by functional

00:09:21,730 --> 00:09:24,670
programmers so you have a very generic

00:09:23,140 --> 00:09:26,920
function that does lots of things and

00:09:24,670 --> 00:09:28,420
you you specialize it to use it in an in

00:09:26,920 --> 00:09:29,050
a nice place in the right we're giving

00:09:28,420 --> 00:09:31,000
it a proper name

00:09:29,050 --> 00:09:33,520
that's kind of neat so we define an

00:09:31,000 --> 00:09:36,279
increment function based on ad which

00:09:33,520 --> 00:09:38,320
basically adds one to a number so when

00:09:36,279 --> 00:09:40,930
we call we can call ad which is stupid

00:09:38,320 --> 00:09:42,520
two arguments and you can just use

00:09:40,930 --> 00:09:44,200
increment which is one argument and you

00:09:42,520 --> 00:09:47,220
get the expected result it's kind of

00:09:44,200 --> 00:09:49,180
neat that for a Python developer we do

00:09:47,220 --> 00:09:50,500
someone who has a little bit more

00:09:49,180 --> 00:09:51,700
experience about the standard library

00:09:50,500 --> 00:09:54,670
would say hey you know what it's like

00:09:51,700 --> 00:09:56,500
partial argument application so I can

00:09:54,670 --> 00:09:59,470
from functions import a partial and

00:09:56,500 --> 00:10:01,900
define Inc as a partial of ad to which

00:09:59,470 --> 00:10:04,089
we follow with the first argument having

00:10:01,900 --> 00:10:06,700
the value one and that's really like

00:10:04,089 --> 00:10:08,589
this something reading I think beautiful

00:10:06,700 --> 00:10:12,300
about defining Inc as a one-liner using

00:10:08,589 --> 00:10:13,870
partial like it makes me feels very snot

00:10:12,300 --> 00:10:15,400
can we do better

00:10:13,870 --> 00:10:16,750
we'll be even better if you could say

00:10:15,400 --> 00:10:19,660
you know what increment is just out of

00:10:16,750 --> 00:10:21,100
one that would be really neat and now

00:10:19,660 --> 00:10:25,420
that Python code you really don't want

00:10:21,100 --> 00:10:29,950
to write one way to do that is to use

00:10:25,420 --> 00:10:31,870
closures so we define add as another

00:10:29,950 --> 00:10:34,080
function of two or two arguments but a

00:10:31,870 --> 00:10:37,750
function with only one argument and

00:10:34,080 --> 00:10:39,670
which returns another function which

00:10:37,750 --> 00:10:42,220
also takes one argument which actually

00:10:39,670 --> 00:10:45,190
does actually does the work so when we

00:10:42,220 --> 00:10:47,650
do that we can define Inc as add code

00:10:45,190 --> 00:10:49,360
with one the only problem is that the

00:10:47,650 --> 00:10:51,850
encoding add becomes really a bit ugly

00:10:49,360 --> 00:10:54,640
like we have to say add of one and then

00:10:51,850 --> 00:10:57,760
add of three which yeah not not right

00:10:54,640 --> 00:11:01,209
but you know what why not we want to

00:10:57,760 --> 00:11:03,070
become fractional programmers so n

00:11:01,209 --> 00:11:05,079
because function primers love lambdas I

00:11:03,070 --> 00:11:07,270
can do everything in one line is really

00:11:05,079 --> 00:11:08,360
awesome so I've got a lambda of X which

00:11:07,270 --> 00:11:10,639
returns a lambda

00:11:08,360 --> 00:11:12,799
why which is the X plus y and increments

00:11:10,639 --> 00:11:16,819
you just add one and it's all absolutely

00:11:12,799 --> 00:11:17,809
beautiful let's let's illustrate that

00:11:16,819 --> 00:11:21,279
with something a little bit more

00:11:17,809 --> 00:11:24,589
realistic so let's say let's define a

00:11:21,279 --> 00:11:26,929
replaced function we takes a pattern and

00:11:24,589 --> 00:11:29,410
a replacement string an inner string

00:11:26,929 --> 00:11:31,549
we'll just replace all the values so

00:11:29,410 --> 00:11:35,689
what we what we want to use release

00:11:31,549 --> 00:11:38,449
resub which has exactly two signature we

00:11:35,689 --> 00:11:40,369
want our pattern wrap our string but

00:11:38,449 --> 00:11:42,559
it's not curable like that like it's not

00:11:40,369 --> 00:11:44,239
its own function we can we can carry but

00:11:42,559 --> 00:11:48,170
we can really find a function using it

00:11:44,239 --> 00:11:49,699
that will that we will be able to which

00:11:48,170 --> 00:11:58,309
we would have accurate form so replace

00:11:49,699 --> 00:12:02,239
is pattern lambda oops rape oh you

00:11:58,309 --> 00:12:05,389
really don't want like a code review die

00:12:02,239 --> 00:12:12,259
proof all right so we up what have I

00:12:05,389 --> 00:12:15,529
done wrong thank you

00:12:12,259 --> 00:12:17,419
so we've got we've got a replace and

00:12:15,529 --> 00:12:18,709
then let's let's specialize that replace

00:12:17,419 --> 00:12:21,049
because it's very generic replace like

00:12:18,709 --> 00:12:23,360
we want to specialize it and we want to

00:12:21,049 --> 00:12:25,489
try to censor and sensor like let's make

00:12:23,360 --> 00:12:32,809
a really smart sensor someone who really

00:12:25,489 --> 00:12:38,149
doesn't like Voyles oops and because

00:12:32,809 --> 00:12:39,679
it's a curried form so we know and when

00:12:38,149 --> 00:12:41,419
we do that we specialized replace its

00:12:39,679 --> 00:12:44,089
kind of neat like if only we didn't have

00:12:41,419 --> 00:12:47,480
to put these brackets everywhere and so

00:12:44,089 --> 00:12:53,989
we can use the sensor to censor any

00:12:47,480 --> 00:12:56,360
string we want so let's sensor back on

00:12:53,989 --> 00:12:58,040
this censored awesome upper case is okay

00:12:56,360 --> 00:13:00,439
it's just lower case that's good

00:12:58,040 --> 00:13:03,019
see you see share with them so really

00:13:00,439 --> 00:13:04,970
there's a lot of ways you can turn you

00:13:03,019 --> 00:13:07,639
can turn any function into very good

00:13:04,970 --> 00:13:09,259
basically any function into you into a

00:13:07,639 --> 00:13:10,489
curried form so let's let's do it from

00:13:09,259 --> 00:13:13,549
that and we talked about map a bit

00:13:10,489 --> 00:13:18,669
earlier and we know that map texture

00:13:13,549 --> 00:13:18,669
function oops an interval to

00:13:18,840 --> 00:13:24,060
I'm going to do that because I know that

00:13:21,150 --> 00:13:30,690
what we get is a map objecting young and

00:13:24,060 --> 00:13:33,750
then I can I can lumber things so we've

00:13:30,690 --> 00:13:35,730
defined a curried form of nap which is

00:13:33,750 --> 00:13:39,300
cool and we can define a sensor all

00:13:35,730 --> 00:13:41,820
which is a specialized form of so use

00:13:39,300 --> 00:13:44,100
the use nap plus or specialized the

00:13:41,820 --> 00:13:48,240
replace which is sensor to replace the

00:13:44,100 --> 00:14:02,089
list of a list of things so sensor all

00:13:48,240 --> 00:14:07,339
and we're going to say oops it's mapped

00:14:02,089 --> 00:14:07,339
of sensor that's cool

00:14:17,920 --> 00:14:27,820
whoops how are they doing wrong oops

00:14:43,060 --> 00:14:52,459
stress up here we go you know when I

00:14:50,600 --> 00:14:56,390
clash presentation and you can ask I was

00:14:52,459 --> 00:14:58,610
ready I can do it I can do it

00:14:56,390 --> 00:15:00,620
so why did we go through that little

00:14:58,610 --> 00:15:01,940
carrying date or is because there is

00:15:00,620 --> 00:15:03,649
another dimension to function so as a

00:15:01,940 --> 00:15:07,190
moment so far we've used functors as

00:15:03,649 --> 00:15:09,020
let's put a value in it and apply a

00:15:07,190 --> 00:15:10,670
function to it but functions can also be

00:15:09,020 --> 00:15:11,810
applicative functors which makes them

00:15:10,670 --> 00:15:13,640
even better so what is what's an

00:15:11,810 --> 00:15:16,279
applicative functor it's a function with

00:15:13,640 --> 00:15:19,089
a functor which has an applied method so

00:15:16,279 --> 00:15:22,730
here typically we we have a function f

00:15:19,089 --> 00:15:25,370
in which we lift the function f which we

00:15:22,730 --> 00:15:27,649
can apply to a functor of value X and

00:15:25,370 --> 00:15:30,560
it's exactly the same thing as if we

00:15:27,649 --> 00:15:32,600
done we have a function of X so in which

00:15:30,560 --> 00:15:35,899
we lived in the functor to which we

00:15:32,600 --> 00:15:38,029
apply is the little function test early

00:15:35,899 --> 00:15:41,870
example so let's define a square no

00:15:38,029 --> 00:15:43,250
longer here no no code smell so if we

00:15:41,870 --> 00:15:45,890
put two in a box and we not Square over

00:15:43,250 --> 00:15:48,020
it we get what we want and we can also

00:15:45,890 --> 00:15:50,720
lift the square function into the box

00:15:48,020 --> 00:15:52,880
type and apply to a box of two and we

00:15:50,720 --> 00:15:55,700
get exactly what we want which is really

00:15:52,880 --> 00:15:58,160
so one argument no big deal

00:15:55,700 --> 00:16:01,370
but it's it's it's it's only thing so

00:15:58,160 --> 00:16:03,050
the reason why we needed carrying so box

00:16:01,370 --> 00:16:04,370
is the replica defunct obviously the

00:16:03,050 --> 00:16:05,930
reason why we need carrying is what

00:16:04,370 --> 00:16:09,310
happens when we have more than one

00:16:05,930 --> 00:16:13,370
argument so here we have longer define

00:16:09,310 --> 00:16:16,550
which text which is our sorry add define

00:16:13,370 --> 00:16:17,810
which takes two arguments and if it was

00:16:16,550 --> 00:16:19,970
not in a curried form we wouldn't be

00:16:17,810 --> 00:16:22,399
able we wouldn't be able to apply it but

00:16:19,970 --> 00:16:24,920
in the image carried form we can so we

00:16:22,399 --> 00:16:28,190
can say we can lift add into the into

00:16:24,920 --> 00:16:28,970
box and we can apply to a box of one

00:16:28,190 --> 00:16:32,690
argument

00:16:28,970 --> 00:16:34,130
and it's valid like it's just we've job

00:16:32,690 --> 00:16:35,510
because it's carried it's that enjoy

00:16:34,130 --> 00:16:37,220
what we end up wind up with a box that

00:16:35,510 --> 00:16:39,230
contains a lambda which we can then

00:16:37,220 --> 00:16:42,260
apply again to another box which

00:16:39,230 --> 00:16:43,760
contains something else and we get a box

00:16:42,260 --> 00:16:45,530
of five so when we add two plus five is

00:16:43,760 --> 00:16:50,420
three we get we get five that's awesome

00:16:45,530 --> 00:16:51,680
so that's an applicative functor that's

00:16:50,420 --> 00:16:56,510
what that's all they are really like

00:16:51,680 --> 00:16:58,430
it's really neat a lot of a lot of

00:16:56,510 --> 00:17:00,770
people because it's a bit convoluted to

00:16:58,430 --> 00:17:03,740
do that the a lot of functional programs

00:17:00,770 --> 00:17:06,980
contain little little helpers which have

00:17:03,740 --> 00:17:09,260
which is very explicit name like lift a

00:17:06,980 --> 00:17:12,140
- and what lifted who does takes a

00:17:09,260 --> 00:17:14,569
function and to functors and we lift the

00:17:12,140 --> 00:17:16,550
function into an applicative functor and

00:17:14,569 --> 00:17:18,439
apply it to the tools that - given

00:17:16,550 --> 00:17:20,630
arguments so it's lift and apply which -

00:17:18,439 --> 00:17:23,930
to arguments so for example here let's

00:17:20,630 --> 00:17:25,550
write lift a - that we'll add when coal

00:17:23,930 --> 00:17:28,670
with AD in box of three in box of four

00:17:25,550 --> 00:17:30,110
will return box of seven we could do it

00:17:28,670 --> 00:17:32,840
by say hey you know what we know it's a

00:17:30,110 --> 00:17:45,350
box so we can put it in the box and then

00:17:32,840 --> 00:17:47,690
we apply box f of X we get box a seven

00:17:45,350 --> 00:17:51,710
but we made an assumption here like it

00:17:47,690 --> 00:17:54,140
works for my example but we do put F in

00:17:51,710 --> 00:17:55,490
box we need to know that the the

00:17:54,140 --> 00:17:58,280
functions that we're going to apply to

00:17:55,490 --> 00:17:59,840
of type box so it's not really that

00:17:58,280 --> 00:18:01,460
great we could do introspection we could

00:17:59,840 --> 00:18:03,050
do some some magic but there's another

00:18:01,460 --> 00:18:05,810
way because it's an applicative factor

00:18:03,050 --> 00:18:08,990
what we can do is we can say oh it's F

00:18:05,810 --> 00:18:11,900
x2 which we map F which we then apply to

00:18:08,990 --> 00:18:13,550
F of Y and that's magic and it's only

00:18:11,900 --> 00:18:15,800
because you have functors and you have

00:18:13,550 --> 00:18:16,760
application factors and you just they

00:18:15,800 --> 00:18:19,670
mean the same thing

00:18:16,760 --> 00:18:21,310
it's confident I was ready in case I

00:18:19,670 --> 00:18:23,600
couldn't master it mess that one up

00:18:21,310 --> 00:18:26,600
we've seen factors which in carrying

00:18:23,600 --> 00:18:28,730
we've seen a fricative functors next we

00:18:26,600 --> 00:18:32,870
need to talk about Isis and either is

00:18:28,730 --> 00:18:36,130
left or right what does that mean if you

00:18:32,870 --> 00:18:38,920
have a writer if you lift a value into a

00:18:36,130 --> 00:18:41,570
right type so let's say we lift we lift

00:18:38,920 --> 00:18:42,710
three in the right object and then we

00:18:41,570 --> 00:18:47,600
compose several function

00:18:42,710 --> 00:18:51,830
/ - we get a right of - what happens if

00:18:47,600 --> 00:18:53,149
you do that to the left you get a left

00:18:51,830 --> 00:18:57,110
of three oh why not

00:18:53,149 --> 00:19:00,409
why right is the right way left is the

00:18:57,110 --> 00:19:02,450
wrong way like easy either capture the

00:19:00,409 --> 00:19:03,860
concept of this Junction like when you

00:19:02,450 --> 00:19:05,419
know we have programs and wish follow

00:19:03,860 --> 00:19:06,710
different paths when you don't know

00:19:05,419 --> 00:19:09,169
which path you're gonna follow well you

00:19:06,710 --> 00:19:11,929
use an either I'm going to this right

00:19:09,169 --> 00:19:13,279
here I'm importing random and run them

00:19:11,929 --> 00:19:15,230
we'll choose either left or right and

00:19:13,279 --> 00:19:18,529
map the things so I'm going to run it a

00:19:15,230 --> 00:19:21,409
few times so okay we got right and left

00:19:18,529 --> 00:19:22,399
habla but as we know at some point when

00:19:21,409 --> 00:19:24,289
we have fractional programming we need

00:19:22,399 --> 00:19:26,059
to extract the actual values the thing

00:19:24,289 --> 00:19:29,120
we want to play with from the type and

00:19:26,059 --> 00:19:30,919
to do that we fold but here we fall but

00:19:29,120 --> 00:19:33,200
it could be a left all right should we

00:19:30,919 --> 00:19:35,330
do the same thing well we don't want to

00:19:33,200 --> 00:19:38,390
do the same thing so fold in the when

00:19:35,330 --> 00:19:40,880
you use an either text to function as

00:19:38,390 --> 00:19:43,669
its as its argument one that it will do

00:19:40,880 --> 00:19:45,470
one that will be executed if you end up

00:19:43,669 --> 00:19:47,059
with a left and another one which would

00:19:45,470 --> 00:19:53,720
be executed if you end up with the right

00:19:47,059 --> 00:20:06,470
so let's use the best Canadian square

00:19:53,720 --> 00:20:11,059
word and just so we get technically if

00:20:06,470 --> 00:20:13,850
if we get a left and and - if if we if

00:20:11,059 --> 00:20:16,070
we have a right when we want to use that

00:20:13,850 --> 00:20:17,899
type of thing but typically when you can

00:20:16,070 --> 00:20:20,929
have a null value so you can you can

00:20:17,899 --> 00:20:29,000
define little helpers that's from the

00:20:20,929 --> 00:20:30,710
label which takes which takes value and

00:20:29,000 --> 00:20:32,860
is known return the left of that value

00:20:30,710 --> 00:20:35,510
is right with on the right of that value

00:20:32,860 --> 00:20:38,679
a little illustration of that let's say

00:20:35,510 --> 00:20:41,750
we have a dictionary of non colors and

00:20:38,679 --> 00:20:43,820
we want a function that takes the upper

00:20:41,750 --> 00:20:47,470
case of the X of the single part of the

00:20:43,820 --> 00:20:49,520
color we can write that function so

00:20:47,470 --> 00:20:52,789
naively we could see how let's just put

00:20:49,520 --> 00:20:54,640
it in the box start our camera we can

00:20:52,789 --> 00:20:59,799
put the color in the box

00:20:54,640 --> 00:21:10,620
oops we once we won't known colors get

00:20:59,799 --> 00:21:13,420
color up Duke and then we map so we

00:21:10,620 --> 00:21:16,900
string you want to remove the first

00:21:13,420 --> 00:21:26,559
character took boom and then we want to

00:21:16,900 --> 00:21:29,500
operate composition is awesome we want

00:21:26,559 --> 00:21:31,169
you to really hear we're folding that's

00:21:29,500 --> 00:21:35,010
cool what happens when you have

00:21:31,169 --> 00:21:40,240
non-value ever makes no sense to

00:21:35,010 --> 00:21:42,760
subscript just a script just a script

00:21:40,240 --> 00:21:44,799
not so what you want to say hey we've

00:21:42,760 --> 00:21:47,770
got that from the label here let's just

00:21:44,799 --> 00:21:49,390
choose it and naively you run it and you

00:21:47,770 --> 00:21:52,270
get a type error why because fold the

00:21:49,390 --> 00:21:55,419
text two arguments so doc we just need

00:21:52,270 --> 00:22:02,440
to add one argument here we have an

00:21:55,419 --> 00:22:04,510
error and we can say it's unknown and

00:22:02,440 --> 00:22:06,669
now it just works so illustration

00:22:04,510 --> 00:22:09,130
illustrating the concept of either we've

00:22:06,669 --> 00:22:12,580
got it looks like you have one single

00:22:09,130 --> 00:22:15,400
flow of one single processing pipeline

00:22:12,580 --> 00:22:17,830
yet we use a disjunction in there and

00:22:15,400 --> 00:22:19,840
it's kind of like no function

00:22:17,830 --> 00:22:21,820
programmers will rave about it another

00:22:19,840 --> 00:22:24,370
use case where you'll want to do that

00:22:21,820 --> 00:22:27,070
and in Python is in everything but in in

00:22:24,370 --> 00:22:29,290
Python especially is using exceptions so

00:22:27,070 --> 00:22:32,650
we can define a try except helper which

00:22:29,290 --> 00:22:34,540
takes a function which when when it's

00:22:32,650 --> 00:22:36,010
called will try to run the function and

00:22:34,540 --> 00:22:37,270
if there is no exception we reach on the

00:22:36,010 --> 00:22:39,340
right of the value returned by the

00:22:37,270 --> 00:22:43,360
function otherwise the left of the

00:22:39,340 --> 00:22:45,130
exception so let's define a little

00:22:43,360 --> 00:22:46,780
helper read we should read the file and

00:22:45,130 --> 00:22:48,910
we're going to enough to import JSON and

00:22:46,780 --> 00:22:50,740
that's unsafe Python code but that's

00:22:48,910 --> 00:22:52,030
okay like it will be the configuration

00:22:50,740 --> 00:22:54,270
file get the port if it exists and

00:22:52,030 --> 00:22:57,730
returns what it is how will you do that

00:22:54,270 --> 00:23:01,500
in in in in functional style

00:22:57,730 --> 00:23:01,500
well you'll see the rocks

00:23:01,620 --> 00:23:07,110
I love that books look and then what do

00:23:05,400 --> 00:23:11,120
you do Wow okay

00:23:07,110 --> 00:23:11,120
it's JSON so we need to we have a string

00:23:14,960 --> 00:23:29,779
doc so and then we can fold again it's a

00:23:22,770 --> 00:23:34,020
configuration you see get port BAM

00:23:29,779 --> 00:23:37,980
fantastic what if we have a fighter

00:23:34,020 --> 00:23:39,840
doesn't exist so we want to put it in a

00:23:37,980 --> 00:23:40,950
box we don't want to put it in a box

00:23:39,840 --> 00:23:45,090
directly we want to use our little

00:23:40,950 --> 00:23:47,580
helper I'll try except helper which

00:23:45,090 --> 00:23:50,580
takes a function which when called we

00:23:47,580 --> 00:23:55,049
will do the work and then because we

00:23:50,580 --> 00:23:58,380
know we've learned from mistake up to we

00:23:55,049 --> 00:24:09,960
have the left case and now it works it's

00:23:58,380 --> 00:24:13,350
fantastic what if what if you have

00:24:09,960 --> 00:24:16,529
invalid JSON we have a problem here in

00:24:13,350 --> 00:24:19,350
the json dot load what do we do we have

00:24:16,529 --> 00:24:22,350
to accept let's just use it so we can

00:24:19,350 --> 00:24:27,980
say doc lambda is here and it's not just

00:24:22,350 --> 00:24:33,360
that it's a try except of a function

00:24:27,980 --> 00:24:36,990
which will do the work why doesn't it

00:24:33,360 --> 00:24:38,909
work oh we are the left why do we have

00:24:36,990 --> 00:24:40,679
left well because it doesn't work but

00:24:38,909 --> 00:24:42,899
what's going on here ah let's have a

00:24:40,679 --> 00:24:43,620
quick look so let's remove the fold and

00:24:42,899 --> 00:24:45,809
see what happens

00:24:43,620 --> 00:24:48,029
oh we have a right because the fight

00:24:45,809 --> 00:24:51,360
does exist but then which contains a

00:24:48,029 --> 00:24:55,440
left because it's not valid JSON what

00:24:51,360 --> 00:25:00,590
could we do we need to chain instead of

00:24:55,440 --> 00:25:03,360
mapping what what chain does is it will

00:25:00,590 --> 00:25:06,000
apply the function to the type but

00:25:03,360 --> 00:25:08,460
return another type which is really nice

00:25:06,000 --> 00:25:10,830
and in that case we can then fold

00:25:08,460 --> 00:25:15,149
properly and get exactly what you want

00:25:10,830 --> 00:25:19,139
so either as an extra method we

00:25:15,149 --> 00:25:24,499
is called chain which makes it a more

00:25:19,139 --> 00:25:24,499
nada I promise you it's perfect

00:25:28,759 --> 00:25:39,599
let me try anyway for something to be a

00:25:36,479 --> 00:25:41,219
for a type to be a monad you basically

00:25:39,599 --> 00:25:43,049
need to be able to lift into the type so

00:25:41,219 --> 00:25:45,210
you need to have that off thing that's a

00:25:43,049 --> 00:25:47,159
type dot often you leave the value in to

00:25:45,210 --> 00:25:49,979
the type and you need to be able to

00:25:47,159 --> 00:25:52,200
chain sometimes called flat mat or bind

00:25:49,979 --> 00:25:57,419
or that squiggly weakly singie that

00:25:52,200 --> 00:25:58,799
seems ASCO and if you have a type which

00:25:57,419 --> 00:26:00,359
allows you to do that so you can

00:25:58,799 --> 00:26:02,729
actually we're calling chain you can

00:26:00,359 --> 00:26:04,979
join a type to another type by calling a

00:26:02,729 --> 00:26:09,239
appropriate function then what your end

00:26:04,979 --> 00:26:12,059
up way is is no nada that's all you need

00:26:09,239 --> 00:26:14,369
to know it's pretty cool like when you

00:26:12,059 --> 00:26:16,049
think about it it's okay so we all we

00:26:14,369 --> 00:26:18,659
need is to lift things you put something

00:26:16,049 --> 00:26:20,460
in a type and then have a fold and a map

00:26:18,659 --> 00:26:22,619
and a chain and we end up with things

00:26:20,460 --> 00:26:23,729
that are pretty cool since I have a

00:26:22,619 --> 00:26:25,580
little bit more time which is awesome I

00:26:23,729 --> 00:26:27,359
thought maybe I would stop there in my

00:26:25,580 --> 00:26:31,320
so that's cool

00:26:27,359 --> 00:26:33,029
we can go a bit further see my group so

00:26:31,320 --> 00:26:35,099
yes functional programmers love abstract

00:26:33,029 --> 00:26:37,200
mathematics abstract algebra and they

00:26:35,099 --> 00:26:38,639
deliberately use vocabulary from that

00:26:37,200 --> 00:26:39,899
domain because they think it makes it a

00:26:38,639 --> 00:26:44,519
lot easier for people to talk about

00:26:39,899 --> 00:26:46,409
programming I'm not there yet I might

00:26:44,519 --> 00:26:48,809
get there but I'm not there yet what is

00:26:46,409 --> 00:26:50,700
a semi-group well again let's just it's

00:26:48,809 --> 00:26:52,679
quite simple it's just something that

00:26:50,700 --> 00:26:54,149
has a concatenated so they just add

00:26:52,679 --> 00:26:56,330
another one to this to the to the fray

00:26:54,149 --> 00:26:59,070
we've got Matt we've got four we've got

00:26:56,330 --> 00:27:00,690
chain and we've got we've got off and

00:26:59,070 --> 00:27:02,070
we've got Chrome cats that come cat

00:27:00,690 --> 00:27:03,599
needs to have one little property it

00:27:02,070 --> 00:27:06,149
needs to be associative so think about

00:27:03,599 --> 00:27:09,349
addition if you have a plus B plus C

00:27:06,149 --> 00:27:12,089
it's the same thing as a plus B plus C

00:27:09,349 --> 00:27:14,070
so what if you have a few creative types

00:27:12,089 --> 00:27:17,599
that other concatenated then you have a

00:27:14,070 --> 00:27:20,580
semi-group and they're awesome

00:27:17,599 --> 00:27:23,190
let's go one step further you can also

00:27:20,580 --> 00:27:27,960
have mono reads what is the motivator

00:27:23,190 --> 00:27:29,070
it's a semi-group well not which on top

00:27:27,960 --> 00:27:31,320
of that so it

00:27:29,070 --> 00:27:34,679
symma group which interprets that as an

00:27:31,320 --> 00:27:37,440
empty method which returns a neutral

00:27:34,679 --> 00:27:39,990
element for concat sync zero in the

00:27:37,440 --> 00:27:42,029
addition so if you have whatever a plus

00:27:39,990 --> 00:27:46,350
zero what you end up with is a zero is a

00:27:42,029 --> 00:27:50,130
neutral element for the addition so how

00:27:46,350 --> 00:27:55,769
would you use that let's define a some

00:27:50,130 --> 00:28:03,389
type which will be a mono Edom and so we

00:27:55,769 --> 00:28:09,539
know that we need concat self-other and

00:28:03,389 --> 00:28:11,850
that will return self x the value of the

00:28:09,539 --> 00:28:17,570
value my some type has been a plus the

00:28:11,850 --> 00:28:26,789
other X and that shouldn't be oops

00:28:17,570 --> 00:28:30,659
so then if I do some of one concat of

00:28:26,789 --> 00:28:34,879
two it doesn't work because we need the

00:28:30,659 --> 00:28:34,879
empty method so the neutral element

00:28:45,389 --> 00:28:51,309
so we can concat so we can we can we

00:28:48,850 --> 00:28:53,380
define a some type we can cut and we can

00:28:51,309 --> 00:29:04,240
call it I can keep on calling it and if

00:28:53,380 --> 00:29:10,529
we call it with a neutral type we my

00:29:04,240 --> 00:29:10,529
mistake we need to stay in the type

00:29:24,020 --> 00:29:32,540
here we go well I didn't think I would

00:29:28,070 --> 00:29:35,270
get to there so that's a very extensive

00:29:32,540 --> 00:29:37,760
vocabulary if it was a very simple

00:29:35,270 --> 00:29:41,050
definitions I'm actually not quite sure

00:29:37,760 --> 00:29:42,980
how it really helps you deliver you know

00:29:41,050 --> 00:29:45,350
artifice that produces value for

00:29:42,980 --> 00:29:47,270
whoever's using them but it's it's it's

00:29:45,350 --> 00:29:48,890
quite it's quite interesting and it's

00:29:47,270 --> 00:29:50,840
not that complicated you can hopefully

00:29:48,890 --> 00:29:53,920
have managed to demystify a little bit

00:29:50,840 --> 00:29:57,309
of what functional programmers are about

00:29:53,920 --> 00:29:57,309
thank you very much

00:30:03,559 --> 00:30:07,980
that was fascinating and enlightening I

00:30:06,330 --> 00:30:10,020
honestly don't know what I'll do with

00:30:07,980 --> 00:30:13,590
that knowledge but thank you so much

00:30:10,020 --> 00:30:15,179
Emily says you and a little gift from

00:30:13,590 --> 00:30:17,960
the organized thank you very much thank

00:30:15,179 --> 00:30:17,960

YouTube URL: https://www.youtube.com/watch?v=p9_r36fIrqc


