Title: Creating Solid APIs
Publication date: 2018-08-25
Playlist: PyCon Australia 2018
Description: 
	Rivo Laks

https://2018.pycon-au.org/talks/45289-creating-solid-apis/

Increasingly, our apps are used not by humans but by other apps - via their APIs. Thus your APIs need to be well-designed and easy to consume for other developers.
I will share tips and good practices on authentication, versioning, documentation, response structure, and why it all matters.

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,740 --> 00:00:05,069
so increasingly the apps we ride are

00:00:03,179 --> 00:00:07,140
being used not by humans but by other

00:00:05,069 --> 00:00:08,880
apps of higher their api's these other

00:00:07,140 --> 00:00:10,349
apps are written by humans though reroll

00:00:08,880 --> 00:00:11,580
acts as a software developer and systems

00:00:10,349 --> 00:00:13,799
architect and he's been working some

00:00:11,580 --> 00:00:15,599
with Django since 2011 he's going to

00:00:13,799 --> 00:00:17,400
tell us how we can make our API as well

00:00:15,599 --> 00:00:21,230
designed are easy to consume for other

00:00:17,400 --> 00:00:21,230
developers please make Revo feel welcome

00:00:26,390 --> 00:00:31,769
thank you and good morning so I am

00:00:30,119 --> 00:00:35,040
reborn this is my talk on how to create

00:00:31,769 --> 00:00:37,079
solid api's our applications are

00:00:35,040 --> 00:00:39,300
increasingly being used not by humans

00:00:37,079 --> 00:00:41,879
but by other applications why there're

00:00:39,300 --> 00:00:45,450
api's api's are eating the world they

00:00:41,879 --> 00:00:47,940
say but ironically api's themselves are

00:00:45,450 --> 00:00:49,530
first used by other people the

00:00:47,940 --> 00:00:52,170
developers integrating with your

00:00:49,530 --> 00:00:54,510
application and that means that your API

00:00:52,170 --> 00:00:57,829
is must target not just the machines but

00:00:54,510 --> 00:01:01,140
even more importantly humans as well I

00:00:57,829 --> 00:01:03,539
come from Estonia and up until a few

00:01:01,140 --> 00:01:05,280
months ago I was part of Thor gate an

00:01:03,539 --> 00:01:08,250
Estonian product development agency

00:01:05,280 --> 00:01:10,740
working on variety of products products

00:01:08,250 --> 00:01:13,500
and projects built with Python Django

00:01:10,740 --> 00:01:16,080
and other technologies and this talk was

00:01:13,500 --> 00:01:19,290
inspired by one of those where API had

00:01:16,080 --> 00:01:21,299
top priority from day one the focus was

00:01:19,290 --> 00:01:24,330
on creating a platform for managing

00:01:21,299 --> 00:01:26,400
forestry related data and other

00:01:24,330 --> 00:01:29,310
developers had to be able to interface

00:01:26,400 --> 00:01:32,909
with it fetch data do various operations

00:01:29,310 --> 00:01:35,850
and the official UI also had to be built

00:01:32,909 --> 00:01:38,250
on top of the publicly available API

00:01:35,850 --> 00:01:40,710
which meant that all all of the

00:01:38,250 --> 00:01:44,460
functionality had to be available over

00:01:40,710 --> 00:01:46,920
the API and as most developers I had

00:01:44,460 --> 00:01:49,649
used and even created api's before but

00:01:46,920 --> 00:01:51,540
this project had higher demands and so

00:01:49,649 --> 00:01:54,360
it got me thinking how should I approach

00:01:51,540 --> 00:01:56,490
this and what are the guidelines and the

00:01:54,360 --> 00:01:58,939
best practices to making api's that

00:01:56,490 --> 00:02:01,170
other developers would love to use and

00:01:58,939 --> 00:02:05,460
this talk aims to share what I found

00:02:01,170 --> 00:02:08,819
going down that rabbit hole let's begin

00:02:05,460 --> 00:02:10,649
with the definition of API usual API is

00:02:08,819 --> 00:02:13,590
defined as application programming

00:02:10,649 --> 00:02:14,849
interface but I think a better

00:02:13,590 --> 00:02:17,849
definition might be application

00:02:14,849 --> 00:02:20,400
programmer interface because when you

00:02:17,849 --> 00:02:24,629
think about it then API is a really user

00:02:20,400 --> 00:02:27,180
interface meant for other developers so

00:02:24,629 --> 00:02:29,720
keeping that in mind let's go back to

00:02:27,180 --> 00:02:32,700
our API project and look at the goals

00:02:29,720 --> 00:02:37,799
that we need to consider when creating

00:02:32,700 --> 00:02:40,500
those user interfaces we want our API to

00:02:37,799 --> 00:02:42,379
be feature complete and offer full

00:02:40,500 --> 00:02:45,260
access to various parts of the system

00:02:42,379 --> 00:02:48,030
this means that we need to cater to

00:02:45,260 --> 00:02:51,480
quite the variety of different use cases

00:02:48,030 --> 00:02:55,980
and support common features like access

00:02:51,480 --> 00:02:57,780
controls pagination and so on we also

00:02:55,980 --> 00:03:00,660
want it to be easy to get started with

00:02:57,780 --> 00:03:02,579
and this process should be fully

00:03:00,660 --> 00:03:05,430
automated meaning we don't really want

00:03:02,579 --> 00:03:09,720
any manual verification steps and

00:03:05,430 --> 00:03:12,049
whatnot and finally we also want to make

00:03:09,720 --> 00:03:14,489
the entire process as smooth as possible

00:03:12,049 --> 00:03:16,650
meaning we need to anticipate the

00:03:14,489 --> 00:03:18,450
potential stumbling stop stumbling

00:03:16,650 --> 00:03:20,730
stones that other developers will

00:03:18,450 --> 00:03:25,440
encounter and then try to remove them

00:03:20,730 --> 00:03:28,200
from their BOTS let's begin with

00:03:25,440 --> 00:03:30,019
versioning it's one of those topics that

00:03:28,200 --> 00:03:32,370
people don't often care about at first

00:03:30,019 --> 00:03:35,459
but it's also something that's really

00:03:32,370 --> 00:03:38,549
difficult to post on later there's a

00:03:35,459 --> 00:03:40,980
myriad of examples of api's that did not

00:03:38,549 --> 00:03:43,829
have versioning at first and then became

00:03:40,980 --> 00:03:46,669
popular and then struggled to introduce

00:03:43,829 --> 00:03:49,760
versioning without breaking everything

00:03:46,669 --> 00:03:51,870
so why do you even need versioning

00:03:49,760 --> 00:03:55,230
obviously so that we can break things

00:03:51,870 --> 00:03:58,769
right but in a way that we remain in

00:03:55,230 --> 00:04:01,109
control of those breakages what I mean

00:03:58,769 --> 00:04:05,099
by that is you will almost certainly

00:04:01,109 --> 00:04:07,980
need to make changes that's natural but

00:04:05,099 --> 00:04:09,720
with explicit and planned versioning you

00:04:07,980 --> 00:04:12,359
can do that while remaining in in

00:04:09,720 --> 00:04:16,709
control and not just pissing off all the

00:04:12,359 --> 00:04:18,989
developers using your API to do

00:04:16,709 --> 00:04:21,810
versioning successfully there are a few

00:04:18,989 --> 00:04:24,180
things you need to be providing to the

00:04:21,810 --> 00:04:26,880
users of your API they will definitely

00:04:24,180 --> 00:04:30,050
want to know how long one specific

00:04:26,880 --> 00:04:32,250
we'll be maintained and remain available

00:04:30,050 --> 00:04:34,590
this is really important in bigger

00:04:32,250 --> 00:04:37,170
projects and having well-known

00:04:34,590 --> 00:04:40,880
deprecation schedules is one of the

00:04:37,170 --> 00:04:42,720
reasons why Django itself is so popular

00:04:40,880 --> 00:04:45,480
you will also want to provide

00:04:42,720 --> 00:04:48,540
information on where the third-party

00:04:45,480 --> 00:04:50,850
developers need to do changes in their

00:04:48,540 --> 00:04:56,850
code as they move from one version to

00:04:50,850 --> 00:04:59,600
the next one the next question is how do

00:04:56,850 --> 00:05:01,830
you specify versions in the API requests

00:04:59,600 --> 00:05:05,240
there are different options here and

00:05:01,830 --> 00:05:07,830
I'll cover two of the more popular ones

00:05:05,240 --> 00:05:11,340
you can have clients specify version as

00:05:07,830 --> 00:05:12,930
part of the except HTTP header in this

00:05:11,340 --> 00:05:16,530
example you can see that the client

00:05:12,930 --> 00:05:18,120
requests list of projects and then says

00:05:16,530 --> 00:05:21,440
that they want the response to be in

00:05:18,120 --> 00:05:25,650
JSON format and use version 1 of

00:05:21,440 --> 00:05:28,560
whatever versioning schema you use this

00:05:25,650 --> 00:05:30,570
is the more idealistic approach because

00:05:28,560 --> 00:05:32,160
the version used is sort of meta

00:05:30,570 --> 00:05:35,670
information which is then kept out of

00:05:32,160 --> 00:05:38,220
the URL pots but headers are also a bit

00:05:35,670 --> 00:05:42,500
harder to use and test in the real world

00:05:38,220 --> 00:05:45,450
for example you can't just take the URL

00:05:42,500 --> 00:05:48,030
open it in browser and test different

00:05:45,450 --> 00:05:51,360
versions that way so in the real world

00:05:48,030 --> 00:05:55,230
perhaps both based versioning might be a

00:05:51,360 --> 00:05:57,630
more pragmatic choice in this case we

00:05:55,230 --> 00:06:00,500
see that the version is now part of part

00:05:57,630 --> 00:06:04,050
of the path in the URL and the client

00:06:00,500 --> 00:06:08,130
explicitly requests projects listing for

00:06:04,050 --> 00:06:10,260
one specific API version and this can

00:06:08,130 --> 00:06:13,800
make debugging a bit easier as well

00:06:10,260 --> 00:06:15,870
because if you locked pots in your

00:06:13,800 --> 00:06:19,790
server then you automatically include

00:06:15,870 --> 00:06:19,790
the versioning information there as well

00:06:21,170 --> 00:06:27,480
you might have noticed that I used

00:06:23,340 --> 00:06:30,500
integers as versions in my examples and

00:06:27,480 --> 00:06:33,360
other possibilities to use States and

00:06:30,500 --> 00:06:35,460
frankly I've started preferring tates

00:06:33,360 --> 00:06:38,400
myself because they're a bit less

00:06:35,460 --> 00:06:40,110
emotional meaning that you don't need to

00:06:38,400 --> 00:06:43,410
think about whether the next version

00:06:40,110 --> 00:06:46,890
we'll be 1.1 or 2.0 is it big enough to

00:06:43,410 --> 00:06:49,700
be 2.0 and also it might be easier to

00:06:46,890 --> 00:06:52,380
introduce internal or testing versions

00:06:49,700 --> 00:06:56,220
for example you can just create the new

00:06:52,380 --> 00:06:58,950
version based on today's state and open

00:06:56,220 --> 00:07:02,130
it up for some specific group of develop

00:06:58,950 --> 00:07:07,350
developers without changing anything

00:07:02,130 --> 00:07:09,060
else this was about client side of

00:07:07,350 --> 00:07:12,410
things but let's also look at how to

00:07:09,060 --> 00:07:15,630
handle versioning on the server side

00:07:12,410 --> 00:07:18,000
there are two broad categories here you

00:07:15,630 --> 00:07:21,180
can have smaller incremental changes or

00:07:18,000 --> 00:07:23,250
really big breaking ones and for

00:07:21,180 --> 00:07:26,370
incremental changes a nice approach is

00:07:23,250 --> 00:07:29,340
to use version transformers this is sort

00:07:26,370 --> 00:07:31,980
of similar to chango's middle wires so

00:07:29,340 --> 00:07:36,270
your core code would only support the

00:07:31,980 --> 00:07:37,950
latest version and then to handle the

00:07:36,270 --> 00:07:40,350
previous versions you would use the

00:07:37,950 --> 00:07:43,680
Transformers which know how to which

00:07:40,350 --> 00:07:45,240
know how to sort of translate the

00:07:43,680 --> 00:07:48,060
previous version of the request data

00:07:45,240 --> 00:07:51,810
into the next version and then do the

00:07:48,060 --> 00:07:55,380
opposite for the response data and you

00:07:51,810 --> 00:07:57,000
can also stack the Transformers so let's

00:07:55,380 --> 00:08:00,090
say that you have versions one two and

00:07:57,000 --> 00:08:02,790
three your core code would only handle

00:08:00,090 --> 00:08:06,060
version 3 and then the first request

00:08:02,790 --> 00:08:08,100
comes in for version number one then one

00:08:06,060 --> 00:08:10,710
of the Transformers would translate it

00:08:08,100 --> 00:08:13,260
to version 2 the second transformer

00:08:10,710 --> 00:08:14,760
would translate it to version 3 then

00:08:13,260 --> 00:08:17,100
your core code would do the processing

00:08:14,760 --> 00:08:20,910
and then the opposite process would take

00:08:17,100 --> 00:08:22,890
place for the response data and this

00:08:20,910 --> 00:08:25,140
makes it quite easy to change field

00:08:22,890 --> 00:08:26,730
names for example or add new fields

00:08:25,140 --> 00:08:29,880
without affecting any of the old

00:08:26,730 --> 00:08:32,070
versions and notably stripe is using

00:08:29,880 --> 00:08:36,210
that approach in their API and they've

00:08:32,070 --> 00:08:38,430
also clocked about it for massive and

00:08:36,210 --> 00:08:41,940
breaking changes though transformers

00:08:38,430 --> 00:08:43,590
might not work out and in that case you

00:08:41,940 --> 00:08:45,300
may just need to create the completely

00:08:43,590 --> 00:08:47,930
new implementation of the API and

00:08:45,300 --> 00:08:51,210
duplicate some of the code in process

00:08:47,930 --> 00:08:54,890
and now that we have the versioning in

00:08:51,210 --> 00:08:54,890
place let's move on to the next layer

00:08:57,440 --> 00:09:03,840
most api's don't really deal with just

00:09:00,390 --> 00:09:06,990
public data or even if they do you

00:09:03,840 --> 00:09:10,050
probably still want to track on who's

00:09:06,990 --> 00:09:13,050
using your API for various purposes like

00:09:10,050 --> 00:09:15,420
request limits so that means that you

00:09:13,050 --> 00:09:16,950
need to think about authentication who

00:09:15,420 --> 00:09:19,200
is the client that is making this

00:09:16,950 --> 00:09:21,090
request as well as authorization

00:09:19,200 --> 00:09:24,570
figuring out what that client is allowed

00:09:21,090 --> 00:09:26,610
to access and again the best practice

00:09:24,570 --> 00:09:31,590
here depends largely on the use case I

00:09:26,610 --> 00:09:34,710
will cover two of the major options the

00:09:31,590 --> 00:09:36,450
first one is token authentication this

00:09:34,710 --> 00:09:39,360
is the simple approach where clients

00:09:36,450 --> 00:09:42,470
basically send an HTTP header containing

00:09:39,360 --> 00:09:45,530
a simple token with each request and

00:09:42,470 --> 00:09:48,360
token authentication is useful for

00:09:45,530 --> 00:09:51,150
client-server situations where a client

00:09:48,360 --> 00:09:54,210
might be a native mobile application for

00:09:51,150 --> 00:09:57,750
example which the user directly logs

00:09:54,210 --> 00:09:59,190
into and in that case the mobile

00:09:57,750 --> 00:10:01,410
application would receive the

00:09:59,190 --> 00:10:03,780
authentication token after the user has

00:10:01,410 --> 00:10:06,870
logged in and would then send it along

00:10:03,780 --> 00:10:09,840
with all of the requests that it will

00:10:06,870 --> 00:10:11,880
make and if you think about the ten

00:10:09,840 --> 00:10:15,750
session cookies are also basically one

00:10:11,880 --> 00:10:17,700
sort of authentication token and perhaps

00:10:15,750 --> 00:10:21,590
if your API is used only from the

00:10:17,700 --> 00:10:24,390
browser then that's all you need for

00:10:21,590 --> 00:10:28,050
more complicated situations there's who

00:10:24,390 --> 00:10:30,810
of do ofd is meant meant for creating

00:10:28,050 --> 00:10:33,390
platforms think Facebook for example

00:10:30,810 --> 00:10:36,000
where a third party application can

00:10:33,390 --> 00:10:38,970
request access to users data the

00:10:36,000 --> 00:10:41,700
platform that verifies this request asks

00:10:38,970 --> 00:10:43,230
for users permissions and then grants

00:10:41,700 --> 00:10:45,900
the application a token which is both

00:10:43,230 --> 00:10:49,500
application specific as well as user

00:10:45,900 --> 00:10:53,190
specific so what too is quite

00:10:49,500 --> 00:10:55,380
complicated protocol it covers many

00:10:53,190 --> 00:10:58,920
different use cases and flows like

00:10:55,380 --> 00:11:00,390
mobile applications web applications as

00:10:58,920 --> 00:11:03,570
well as applications with very

00:11:00,390 --> 00:11:06,750
limited.you I like living room devices

00:11:03,570 --> 00:11:09,210
and this is good because you will be

00:11:06,750 --> 00:11:12,000
using proven standards that have evolved

00:11:09,210 --> 00:11:13,710
over the years and have already solved

00:11:12,000 --> 00:11:16,560
many problems that perhaps you're not

00:11:13,710 --> 00:11:18,960
even thinking about but the downside is

00:11:16,560 --> 00:11:20,580
that it also requires quite a bit of

00:11:18,960 --> 00:11:24,810
attention where when you're implementing

00:11:20,580 --> 00:11:26,850
it luckily there are various libraries

00:11:24,810 --> 00:11:29,370
available that they care most of this

00:11:26,850 --> 00:11:32,240
plumbing work if you're using Chango

00:11:29,370 --> 00:11:35,160
there's Chango wealth toolkit and

00:11:32,240 --> 00:11:37,770
there's also a wealth leap that the

00:11:35,160 --> 00:11:40,620
Chango toolkit is built upon and which

00:11:37,770 --> 00:11:44,670
provides even more lower level

00:11:40,620 --> 00:11:47,490
customization options basically and for

00:11:44,670 --> 00:11:49,230
our API project we ended up using Chango

00:11:47,490 --> 00:11:52,020
wealth toolkit and then adding some

00:11:49,230 --> 00:11:54,330
functionality on top of that some of

00:11:52,020 --> 00:11:57,720
this was due to missing features of the

00:11:54,330 --> 00:11:59,550
eaat toolkit but mostly it was just due

00:11:57,720 --> 00:12:03,000
to the requirements of our application

00:11:59,550 --> 00:12:05,280
itself for example we needed to keep

00:12:03,000 --> 00:12:08,720
track of some more information relating

00:12:05,280 --> 00:12:11,670
to the authentication tokens and we also

00:12:08,720 --> 00:12:13,980
implemented the pages where developers

00:12:11,670 --> 00:12:18,690
can register their their applications to

00:12:13,980 --> 00:12:21,030
make it more user-friendly with the

00:12:18,690 --> 00:12:23,010
bottom layers in place it's time to move

00:12:21,030 --> 00:12:25,740
on to the request response data

00:12:23,010 --> 00:12:27,990
structure of the API and the most

00:12:25,740 --> 00:12:31,950
important point here is to standardize

00:12:27,990 --> 00:12:34,040
them following standards is good because

00:12:31,950 --> 00:12:36,510
it gives your user sense of familiarity

00:12:34,040 --> 00:12:39,120
if you create something that's

00:12:36,510 --> 00:12:41,190
completely unique and handcrafted then

00:12:39,120 --> 00:12:44,370
your users will have to learn everything

00:12:41,190 --> 00:12:46,350
about it from scratch but if you instead

00:12:44,370 --> 00:12:48,300
follow widespread standards then it's

00:12:46,350 --> 00:12:50,089
likely that they already already have

00:12:48,300 --> 00:12:52,500
experience with something similar and

00:12:50,089 --> 00:12:57,030
they can then sort of transfer this

00:12:52,500 --> 00:12:59,940
knowledge to using your API just as

00:12:57,030 --> 00:13:03,180
importantly standards also have some

00:12:59,940 --> 00:13:06,450
thought put into them usually and they

00:13:03,180 --> 00:13:08,400
help you avoid common pitfalls this is

00:13:06,450 --> 00:13:10,650
quite similar to how Django for example

00:13:08,400 --> 00:13:12,630
implements password storage so that you

00:13:10,650 --> 00:13:18,240
don't end up implementing something

00:13:12,630 --> 00:13:20,230
quite insecure yourself and overall I

00:13:18,240 --> 00:13:22,840
think standards just increase your

00:13:20,230 --> 00:13:24,580
a chance of success because when you

00:13:22,840 --> 00:13:27,250
think about human history in general

00:13:24,580 --> 00:13:29,620
then you would you will find tons of

00:13:27,250 --> 00:13:32,680
examples on how standardized approach is

00:13:29,620 --> 00:13:35,740
we note money is something that is

00:13:32,680 --> 00:13:38,770
globally standardized to some extent we

00:13:35,740 --> 00:13:41,260
try to use utf-8 everywhere and even the

00:13:38,770 --> 00:13:45,180
fundamental laws are quite similar and

00:13:41,260 --> 00:13:47,560
standard across different nations and

00:13:45,180 --> 00:13:49,980
when it comes to API is my current

00:13:47,560 --> 00:13:53,650
standard of choice is chasing API

00:13:49,980 --> 00:13:56,860
chasing API is not just API that uses

00:13:53,650 --> 00:13:59,250
Chasen for its responses but it's an

00:13:56,860 --> 00:14:03,630
actual specification for building api's

00:13:59,250 --> 00:14:07,440
it was created by authors of amber and

00:14:03,630 --> 00:14:10,120
it offers a comprehensive solution to

00:14:07,440 --> 00:14:12,940
various features that you will need for

00:14:10,120 --> 00:14:15,550
an API and the should also stress that

00:14:12,940 --> 00:14:18,160
it's one option out of several and there

00:14:15,550 --> 00:14:21,670
are others that might make more sense

00:14:18,160 --> 00:14:25,260
for your use case for example crack QL

00:14:21,670 --> 00:14:25,260
is also a popular option

00:14:30,810 --> 00:14:36,490
one of the most important aspects of

00:14:33,760 --> 00:14:39,180
chasing API is that it finds a generic

00:14:36,490 --> 00:14:42,910
yet flexible structure for API responses

00:14:39,180 --> 00:14:45,700
so let's look at how API responses are

00:14:42,910 --> 00:14:48,160
structured with JSON API and I'll be

00:14:45,700 --> 00:14:50,770
using sort of project management tool as

00:14:48,160 --> 00:14:52,870
an example application here which lets

00:14:50,770 --> 00:14:55,560
users create projects and epics and

00:14:52,870 --> 00:14:57,670
stories in them as well as add comments

00:14:55,560 --> 00:15:01,300
sort of similar to Basecamp

00:14:57,670 --> 00:15:04,150
if you know that one so here we have an

00:15:01,300 --> 00:15:06,910
example of client making a request to

00:15:04,150 --> 00:15:08,470
get the list of projects and the

00:15:06,910 --> 00:15:11,500
response document here has three

00:15:08,470 --> 00:15:14,590
top-level members the links the data and

00:15:11,500 --> 00:15:17,200
include it and let's go over them one by

00:15:14,590 --> 00:15:19,210
one first we have the links which is

00:15:17,200 --> 00:15:21,700
important because they enable discovery

00:15:19,210 --> 00:15:25,150
of other related endpoints in this case

00:15:21,700 --> 00:15:27,220
we can see that to get the next page of

00:15:25,150 --> 00:15:31,260
results we had to just follow this one

00:15:27,220 --> 00:15:36,040
URL and in the same way your API root

00:15:31,260 --> 00:15:38,500
should offer links do that to the

00:15:36,040 --> 00:15:41,350
individual resource pages for example

00:15:38,500 --> 00:15:43,270
this projects page so that instead of

00:15:41,350 --> 00:15:47,740
hard-coding everything the clients can

00:15:43,270 --> 00:15:49,600
just go and discover those next up we

00:15:47,740 --> 00:15:52,210
have data which contains the so-called

00:15:49,600 --> 00:15:55,300
primary data which is the resource or

00:15:52,210 --> 00:15:58,150
resources that you asked for and in this

00:15:55,300 --> 00:16:00,490
case we have we asked for a list of

00:15:58,150 --> 00:16:03,700
project so the data is a list as well

00:16:00,490 --> 00:16:06,610
and each of those subjects here has

00:16:03,700 --> 00:16:10,900
first of all type and ID which uniquely

00:16:06,610 --> 00:16:14,020
identified then they can also include

00:16:10,900 --> 00:16:17,460
links in this case we specify the

00:16:14,020 --> 00:16:20,260
canonical link of this specific resource

00:16:17,460 --> 00:16:24,010
which you can use to for example modify

00:16:20,260 --> 00:16:29,740
the subject or perhaps ask for full data

00:16:24,010 --> 00:16:31,120
of one specific or specific object next

00:16:29,740 --> 00:16:34,060
up we have attributes which is quite

00:16:31,120 --> 00:16:35,800
self-explanatory we have the creation

00:16:34,060 --> 00:16:39,670
timestamp here as well as name and

00:16:35,800 --> 00:16:41,860
description and resources can also have

00:16:39,670 --> 00:16:43,690
related objects returned on the

00:16:41,860 --> 00:16:46,600
relationships object

00:16:43,690 --> 00:16:49,420
and this is what the relationships look

00:16:46,600 --> 00:16:52,780
like we can see that our project has

00:16:49,420 --> 00:16:55,450
created by relationship which points to

00:16:52,780 --> 00:17:00,130
a user as well as epics relationship

00:16:55,450 --> 00:17:04,300
which is list of epics and each of those

00:17:00,130 --> 00:17:07,150
again has the type and ID which uniquely

00:17:04,300 --> 00:17:09,550
identify this resource and we can use

00:17:07,150 --> 00:17:12,640
those to look it up in the included with

00:17:09,550 --> 00:17:15,910
resources or checked which is the third

00:17:12,640 --> 00:17:19,630
top-level one and this is quite similar

00:17:15,910 --> 00:17:22,960
to the primary datum in this case we

00:17:19,630 --> 00:17:26,110
have the eye pick and user that we

00:17:22,960 --> 00:17:29,530
already saw sort of referenced in the

00:17:26,110 --> 00:17:32,020
main resource and the included included

00:17:29,530 --> 00:17:33,760
resources are important because they can

00:17:32,020 --> 00:17:37,210
be used to optimize the number of API

00:17:33,760 --> 00:17:39,610
requests that you make for example if we

00:17:37,210 --> 00:17:42,520
wanted to display a list of the projects

00:17:39,610 --> 00:17:45,550
and display the author's name for each

00:17:42,520 --> 00:17:48,370
of them then in this case we only need a

00:17:45,550 --> 00:17:52,030
single request because the author's data

00:17:48,370 --> 00:17:53,560
is already included there this is

00:17:52,030 --> 00:17:56,020
especially important for mobile

00:17:53,560 --> 00:17:58,630
applications for example which might be

00:17:56,020 --> 00:18:00,460
operating over high latency networks and

00:17:58,630 --> 00:18:05,230
you really want to optimize the number

00:18:00,460 --> 00:18:08,170
of requests that you make there so how

00:18:05,230 --> 00:18:11,080
did that feel perhaps if you if you

00:18:08,170 --> 00:18:13,980
haven't used chasing api's before then

00:18:11,080 --> 00:18:17,350
it maybe looked a bit weird and bloated

00:18:13,980 --> 00:18:20,260
if you wanted to receive the name of the

00:18:17,350 --> 00:18:21,970
user who created a project then you'd

00:18:20,260 --> 00:18:25,510
have to go through several layers of

00:18:21,970 --> 00:18:27,340
indirection and yet if I now gave you a

00:18:25,510 --> 00:18:30,760
response for another object from that

00:18:27,340 --> 00:18:33,880
same API and told you that it has for

00:18:30,760 --> 00:18:36,250
example updated by field which is also a

00:18:33,880 --> 00:18:39,040
user and wanted to find out the name of

00:18:36,250 --> 00:18:41,200
that user then you'd know how to exactly

00:18:39,040 --> 00:18:43,830
how to do that because the response

00:18:41,200 --> 00:18:45,970
would be structured in the same way and

00:18:43,830 --> 00:18:48,990
furthermore if I gave you a completely

00:18:45,970 --> 00:18:51,520
different API which also uses JSON API

00:18:48,990 --> 00:18:54,880
then you would know how Jax is that one

00:18:51,520 --> 00:18:57,580
as well and that's in a nutshell the

00:18:54,880 --> 00:18:59,800
power of Standardization it brings from

00:18:57,580 --> 00:19:02,230
garetty and makes concepts that you

00:18:59,800 --> 00:19:08,140
already know applicable to something new

00:19:02,230 --> 00:19:11,500
as well let's look at few other features

00:19:08,140 --> 00:19:14,650
of JSON API for example they include the

00:19:11,500 --> 00:19:17,710
data and fields that you saw earlier are

00:19:14,650 --> 00:19:19,840
actually configurable by the client so

00:19:17,710 --> 00:19:23,470
the client might say that it wants the

00:19:19,840 --> 00:19:25,900
comments to be included as shown in the

00:19:23,470 --> 00:19:27,190
second example here and the third

00:19:25,900 --> 00:19:31,360
example shows that you can also

00:19:27,190 --> 00:19:35,110
customize the individual fields returned

00:19:31,360 --> 00:19:37,210
for each of the objects this is again

00:19:35,110 --> 00:19:39,460
important if you have for example a

00:19:37,210 --> 00:19:41,320
mobile application and you want to

00:19:39,460 --> 00:19:43,660
optimize the data that you send over the

00:19:41,320 --> 00:19:48,820
network in this case you can ask for

00:19:43,660 --> 00:19:52,360
just the data that you need you already

00:19:48,820 --> 00:19:55,540
saw the pagination basically it works by

00:19:52,360 --> 00:19:57,880
having next and previous URLs in the

00:19:55,540 --> 00:20:00,970
response and this is very nice for

00:19:57,880 --> 00:20:03,400
clients because they don't need to know

00:20:00,970 --> 00:20:05,590
about how you implement pagination

00:20:03,400 --> 00:20:07,480
internally they just have to be able to

00:20:05,590 --> 00:20:10,330
take this one URL out of the response

00:20:07,480 --> 00:20:14,470
and then follow it to get the next page

00:20:10,330 --> 00:20:17,350
of results in the example I used cursor

00:20:14,470 --> 00:20:19,480
based pagination which is nice but in

00:20:17,350 --> 00:20:22,300
some cases you might prefer a different

00:20:19,480 --> 00:20:24,460
style for example page number based and

00:20:22,300 --> 00:20:26,890
again you can actually change that

00:20:24,460 --> 00:20:29,020
within the server without clients

00:20:26,890 --> 00:20:34,240
noticing thanks to the pagination

00:20:29,020 --> 00:20:36,880
working wire you are ELLs let's also

00:20:34,240 --> 00:20:39,430
talk about there's errors happen and

00:20:36,880 --> 00:20:41,530
which what you should do is just making

00:20:39,430 --> 00:20:43,660
it easy for users to figure out why

00:20:41,530 --> 00:20:46,660
something went wrong and how they can

00:20:43,660 --> 00:20:49,390
fix it and once again the goal here is

00:20:46,660 --> 00:20:54,250
to reduce friction and make it faster

00:20:49,390 --> 00:20:56,440
and easier to solve the issues so here's

00:20:54,250 --> 00:20:58,630
an example of client trying to create

00:20:56,440 --> 00:21:02,040
the new project and something going

00:20:58,630 --> 00:21:04,690
wrong and we can see that that the API

00:21:02,040 --> 00:21:08,920
basically returns lists of errors in

00:21:04,690 --> 00:21:10,930
this case a single one and the response

00:21:08,920 --> 00:21:11,140
contains both human readable data that

00:21:10,930 --> 00:21:13,240
you

00:21:11,140 --> 00:21:16,330
showed that the user meaning the end

00:21:13,240 --> 00:21:19,480
user as well as machine readable data in

00:21:16,330 --> 00:21:22,030
this case pointing out that name is the

00:21:19,480 --> 00:21:29,260
field that had some problems and named

00:21:22,030 --> 00:21:32,500
you short is the error code there are

00:21:29,260 --> 00:21:35,110
also some special cases for example you

00:21:32,500 --> 00:21:38,200
might want to transmit a large amount of

00:21:35,110 --> 00:21:40,720
data and in that case perhaps a

00:21:38,200 --> 00:21:44,710
different more specialized format makes

00:21:40,720 --> 00:21:46,930
more sense than using JSON API but even

00:21:44,710 --> 00:21:48,940
better solution might be to include link

00:21:46,930 --> 00:21:53,230
to the download with downloadable data

00:21:48,940 --> 00:21:55,420
in your main API response and you might

00:21:53,230 --> 00:21:58,780
remember that JSON API already has this

00:21:55,420 --> 00:22:02,230
links object that could also contain

00:21:58,780 --> 00:22:05,560
links to various secondary data download

00:22:02,230 --> 00:22:07,810
points so here we have an example of

00:22:05,560 --> 00:22:10,330
client trying to access some data sets

00:22:07,810 --> 00:22:14,050
and that the result is basically

00:22:10,330 --> 00:22:17,950
metadata which then also includes in the

00:22:14,050 --> 00:22:21,310
link section URL of the raw data itself

00:22:17,950 --> 00:22:23,020
that you can download and additional

00:22:21,310 --> 00:22:25,330
benefit of this is that you can store

00:22:23,020 --> 00:22:27,430
your data outside of your application

00:22:25,330 --> 00:22:31,690
server for example you put it into s3

00:22:27,430 --> 00:22:34,620
and then just store the link in your

00:22:31,690 --> 00:22:34,620
main application

00:22:39,070 --> 00:22:47,260
so to reiterate standardization matters

00:22:42,850 --> 00:22:49,630
it's good to use things that your users

00:22:47,260 --> 00:22:52,780
might already be familiar with and what

00:22:49,630 --> 00:22:56,410
specific standard you use you use is a

00:22:52,780 --> 00:22:58,660
lot less important in my opinion I like

00:22:56,410 --> 00:22:59,950
chase an API if you like craft you out

00:22:58,660 --> 00:23:02,520
and that could be a perfectly good

00:22:59,950 --> 00:23:02,520
option as well

00:23:02,700 --> 00:23:06,730
finally let's get to perhaps the most

00:23:05,050 --> 00:23:10,540
important part of all which is

00:23:06,730 --> 00:23:12,940
documentation documentation is too often

00:23:10,540 --> 00:23:15,460
overlooked we don't really want to do

00:23:12,940 --> 00:23:18,010
this it's not the fun part right at

00:23:15,460 --> 00:23:19,660
least when you're developing but when

00:23:18,010 --> 00:23:21,820
you're trying to make sense of something

00:23:19,660 --> 00:23:23,350
that was created by others then

00:23:21,820 --> 00:23:26,320
documentation becomes much more

00:23:23,350 --> 00:23:28,150
important important and valuable and I

00:23:26,320 --> 00:23:30,580
think if you don't document your code or

00:23:28,150 --> 00:23:35,260
your API then you're just a crappy

00:23:30,580 --> 00:23:37,000
engineer Doc's are also often the first

00:23:35,260 --> 00:23:40,300
point of contact that people have with

00:23:37,000 --> 00:23:42,040
your API and thus they might decide

00:23:40,300 --> 00:23:46,030
whether they stick with what you're

00:23:42,040 --> 00:23:48,220
offering or keep looking I do the same

00:23:46,030 --> 00:23:50,350
myself when I'm looking for solution to

00:23:48,220 --> 00:23:53,020
some common problem there are often

00:23:50,350 --> 00:23:54,400
quite a few options available and then

00:23:53,020 --> 00:23:57,460
the impression that I get from the

00:23:54,400 --> 00:24:01,410
readme and documentation is quite

00:23:57,460 --> 00:24:04,360
important deciding factor and

00:24:01,410 --> 00:24:07,000
documentation does take effort and I

00:24:04,360 --> 00:24:08,830
admit I'm not that good myself at it but

00:24:07,000 --> 00:24:12,010
that does not mean that we shouldn't try

00:24:08,830 --> 00:24:14,620
and if you only take a single thing from

00:24:12,010 --> 00:24:18,510
my talk then let it be this just put

00:24:14,620 --> 00:24:18,510
some good effort into your documentation

00:24:18,630 --> 00:24:25,240
so how do you go about creating those

00:24:22,120 --> 00:24:28,990
awesome dogs documentation is a bit like

00:24:25,240 --> 00:24:30,850
selling back page for your API it needs

00:24:28,990 --> 00:24:33,490
to convince the potential users that

00:24:30,850 --> 00:24:35,500
this is the thing to use and the good

00:24:33,490 --> 00:24:36,970
news is your audience is other

00:24:35,500 --> 00:24:43,060
developers which makes things a bit

00:24:36,970 --> 00:24:45,660
easier so what should go in there first

00:24:43,060 --> 00:24:48,250
of all I want to know how to access it

00:24:45,660 --> 00:24:50,500
this means that I also need to figure

00:24:48,250 --> 00:24:51,320
out if I need some special developer

00:24:50,500 --> 00:24:54,950
account to sign up

00:24:51,320 --> 00:24:57,080
for if you do then it's always helpful

00:24:54,950 --> 00:24:59,150
to offer some sort of demo account or

00:24:57,080 --> 00:25:03,500
API key that I can just start using

00:24:59,150 --> 00:25:06,770
right away even for some testing or

00:25:03,500 --> 00:25:12,140
example purposes I also want to know

00:25:06,770 --> 00:25:14,600
what the URLs are the root URL and I

00:25:12,140 --> 00:25:16,640
want to know if I had to provide any

00:25:14,600 --> 00:25:21,680
sort of authentication for example or

00:25:16,640 --> 00:25:24,200
using go well there is also a lot of

00:25:21,680 --> 00:25:26,180
mundane stuff that totin goes overlooked

00:25:24,200 --> 00:25:28,100
but it's nonetheless important for

00:25:26,180 --> 00:25:30,530
example what character encoding you're

00:25:28,100 --> 00:25:33,710
using what format are using for

00:25:30,530 --> 00:25:35,420
timestamps and so on and so forth this

00:25:33,710 --> 00:25:39,110
is especially important when you're

00:25:35,420 --> 00:25:41,720
approaching either those with less

00:25:39,110 --> 00:25:43,400
experience or those that live outside

00:25:41,720 --> 00:25:45,830
the poitain world where some of the

00:25:43,400 --> 00:25:51,530
conventions that we that we are used to

00:25:45,830 --> 00:25:54,020
might not be as a print it also helps to

00:25:51,530 --> 00:25:57,170
give a quick quick overview of how

00:25:54,020 --> 00:26:00,770
versioning pagination and all other sort

00:25:57,170 --> 00:26:03,230
of common features work and I also want

00:26:00,770 --> 00:26:05,570
to see some common errors and solutions

00:26:03,230 --> 00:26:07,840
to those which make it easier for me to

00:26:05,570 --> 00:26:12,650
find out that I'm dealing with say

00:26:07,840 --> 00:26:14,900
authentication problem and it always

00:26:12,650 --> 00:26:17,180
helps to provide code that I can just

00:26:14,900 --> 00:26:22,130
copy and paste somewhere and have this

00:26:17,180 --> 00:26:23,750
first example working right away then

00:26:22,130 --> 00:26:26,630
you will probably also have a bunch of

00:26:23,750 --> 00:26:29,090
ten points for different resources for

00:26:26,630 --> 00:26:31,370
each of those it helps to point out the

00:26:29,090 --> 00:26:33,290
URL as well as operations that you can

00:26:31,370 --> 00:26:36,880
do with it for example creating time

00:26:33,290 --> 00:26:39,350
mode applying time just reading thumb I

00:26:36,880 --> 00:26:41,360
also want to know what the request and

00:26:39,350 --> 00:26:44,540
response data looks like especially

00:26:41,360 --> 00:26:47,290
important for modifying because I want

00:26:44,540 --> 00:26:50,090
to know how I have to send the new data

00:26:47,290 --> 00:26:52,370
if there are any optional parameters for

00:26:50,090 --> 00:26:55,750
example for filtering the list results

00:26:52,370 --> 00:26:59,240
then those are useful to point out and

00:26:55,750 --> 00:27:02,960
if permissions determine the result

00:26:59,240 --> 00:27:05,059
results or returned objects then it

00:27:02,960 --> 00:27:07,159
helps to point out that administrators

00:27:05,059 --> 00:27:15,559
for example have access to more objects

00:27:07,159 --> 00:27:17,779
than ordinary users and the only thing

00:27:15,559 --> 00:27:21,019
that's worse than no documentation is

00:27:17,779 --> 00:27:22,909
obsolete documentation inconsistencies

00:27:21,019 --> 00:27:25,970
for example between the documentation

00:27:22,909 --> 00:27:28,249
that and actual API they don't only make

00:27:25,970 --> 00:27:32,590
the documentation useless they basically

00:27:28,249 --> 00:27:35,120
undermine trust in your entire API and

00:27:32,590 --> 00:27:36,169
it helps you out to generate the

00:27:35,120 --> 00:27:39,200
documentation here

00:27:36,169 --> 00:27:42,549
so usually you create some sort of

00:27:39,200 --> 00:27:44,899
schema meaning machine readable

00:27:42,549 --> 00:27:47,330
description of your API from your code

00:27:44,899 --> 00:27:50,990
and then you generate the documentation

00:27:47,330 --> 00:27:53,779
based on that and there are different

00:27:50,990 --> 00:27:56,059
options available here open API also

00:27:53,779 --> 00:28:00,320
known known as swagger is perhaps the

00:27:56,059 --> 00:28:02,450
most well-known one and you should just

00:28:00,320 --> 00:28:04,129
try to figure out what your tooling uses

00:28:02,450 --> 00:28:06,559
if you're using Django rest framework

00:28:04,129 --> 00:28:08,659
then there are quite a few options

00:28:06,559 --> 00:28:10,820
available for sort of integrating with

00:28:08,659 --> 00:28:14,360
open API and then offering out to

00:28:10,820 --> 00:28:17,840
generate the documentation and again

00:28:14,360 --> 00:28:22,399
you'd want to combine toxin toxin code

00:28:17,840 --> 00:28:25,669
in the best case another interesting

00:28:22,399 --> 00:28:27,980
thing about machine readable schemas is

00:28:25,669 --> 00:28:30,889
that you can also use it do how to

00:28:27,980 --> 00:28:34,340
generate client libraries so for example

00:28:30,889 --> 00:28:36,289
generate Python package for your API but

00:28:34,340 --> 00:28:43,990
also generate the same thing in

00:28:36,289 --> 00:28:47,419
different languages so let's sum this up

00:28:43,990 --> 00:28:50,419
standard spring familiarity so you

00:28:47,419 --> 00:28:52,999
should pick one and stick to it instead

00:28:50,419 --> 00:28:56,029
of trying to invent something completely

00:28:52,999 --> 00:28:58,539
new documentation matters because it

00:28:56,029 --> 00:29:01,129
gives your users the first impression

00:28:58,539 --> 00:29:02,539
you should use automation as much as

00:29:01,129 --> 00:29:05,210
possible to ensure that your

00:29:02,539 --> 00:29:07,429
documentation is always up to date and

00:29:05,210 --> 00:29:10,789
you can use the same for creating client

00:29:07,429 --> 00:29:13,309
libraries and in general just reduce

00:29:10,789 --> 00:29:15,379
friction as much as possible meaning get

00:29:13,309 --> 00:29:18,020
rid of all the little bumps along the

00:29:15,379 --> 00:29:20,510
way and pieces that try to your

00:29:18,020 --> 00:29:24,140
and developers away so think of the

00:29:20,510 --> 00:29:27,340
humans I will not be taking questions

00:29:24,140 --> 00:29:30,740
but feel free to approach me anytime

00:29:27,340 --> 00:29:33,350
afterwards you can also find the slides

00:29:30,740 --> 00:29:35,680
at the given URL and thanks for

00:29:33,350 --> 00:29:35,680

YouTube URL: https://www.youtube.com/watch?v=MEba95kL0eo


