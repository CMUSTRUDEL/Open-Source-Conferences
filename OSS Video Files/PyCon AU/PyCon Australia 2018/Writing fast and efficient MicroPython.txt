Title: Writing fast and efficient MicroPython
Publication date: 2018-08-24
Playlist: PyCon Australia 2018
Description: 
	Damien George

https://2018.pycon-au.org/talks/45358-writing-fast-and-efficient-micropython/

MicroPython is an implementation of Python designed to run on microcontrollers and embedded systems. These devices don't have many resources (CPU, RAM) and so it's important to write efficient scripts. This talk shows how to make the most of your resources in MicroPython, and has some fun demos!

Python, PyCon, PyConAU, australia, programming, sydney

This video is licensed under CC BY 3.0 AU ‹https://creativecommons.org/licenses/by/3.0/au/›.

PyCon Australia (“PyCon AU”) is the national conference for the Python Programming Community, bringing together professional, student and enthusiast developers with a love for developing with Python.

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 24 - 28 2018.

Python, PyCon, PyConAU
Captions: 
	00:00:00,120 --> 00:00:05,460
hello all and welcome back to the IOT

00:00:02,820 --> 00:00:06,660
many conf I'm sure our next presenter

00:00:05,460 --> 00:00:08,639
needs no introduction but I'll do one

00:00:06,660 --> 00:00:10,559
anyway this is Damian Georgia creator of

00:00:08,639 --> 00:00:12,179
micro Python here to talk about how to

00:00:10,559 --> 00:00:13,950
write fast and efficient micro Python

00:00:12,179 --> 00:00:21,990
thank very much Damian please welcome to

00:00:13,950 --> 00:00:24,350
the stage okay thank you thanks everyone

00:00:21,990 --> 00:00:29,250
for coming to my talk it's great to be

00:00:24,350 --> 00:00:31,650
this year so yeah I'm Damian George

00:00:29,250 --> 00:00:34,980
about five years ago I started writing

00:00:31,650 --> 00:00:37,050
micro Python I think it was the 29th of

00:00:34,980 --> 00:00:38,280
April 2013 I wrote the first line of

00:00:37,050 --> 00:00:41,399
code and I actually wrote the date down

00:00:38,280 --> 00:00:43,140
when I wrote it so I don't know so I

00:00:41,399 --> 00:00:45,030
would remember I like to date things but

00:00:43,140 --> 00:00:47,250
so more than five years ago I started

00:00:45,030 --> 00:00:48,390
writing it and it's come a long way and

00:00:47,250 --> 00:00:52,050
probably a lot of you have heard me talk

00:00:48,390 --> 00:00:54,539
before but if not I'll just give a brief

00:00:52,050 --> 00:00:58,170
brief overview of what micro Python is

00:00:54,539 --> 00:01:00,359
for those people who are new to it so

00:00:58,170 --> 00:01:02,579
it's a complete re implementation of

00:01:00,359 --> 00:01:05,460
Python so from the ground up written in

00:01:02,579 --> 00:01:08,640
C and the idea when I was writing it was

00:01:05,460 --> 00:01:10,439
to not look at C Python and how it was

00:01:08,640 --> 00:01:13,140
written but just look at the language

00:01:10,439 --> 00:01:14,939
specification itself and try and copy

00:01:13,140 --> 00:01:17,280
the language specification implement

00:01:14,939 --> 00:01:19,320
that and so that way I could generate

00:01:17,280 --> 00:01:21,780
new ideas about how to solve the same

00:01:19,320 --> 00:01:25,560
problem in a different way as in to

00:01:21,780 --> 00:01:27,240
implement Python and the way micro path

00:01:25,560 --> 00:01:29,280
is written is so that it doesn't use

00:01:27,240 --> 00:01:31,409
resources it doesn't use Ram and it

00:01:29,280 --> 00:01:33,150
doesn't it tries to be efficient with

00:01:31,409 --> 00:01:36,360
the way it does think so it can run in

00:01:33,150 --> 00:01:41,400
really really tiny systems like with 16

00:01:36,360 --> 00:01:42,509
kilobytes of memory and so the key thing

00:01:41,400 --> 00:01:44,729
is that when you log in to your

00:01:42,509 --> 00:01:47,520
microcontroller you get a Python prompt

00:01:44,729 --> 00:01:49,710
and you can blink LEDs with one line of

00:01:47,520 --> 00:01:52,290
Python code in it's an immediate

00:01:49,710 --> 00:01:54,479
response there's no compilation and

00:01:52,290 --> 00:01:56,009
flashing of firmware like you're

00:01:54,479 --> 00:01:58,079
familiar with normal microcontroller

00:01:56,009 --> 00:02:01,290
programming so it's quite fun and

00:01:58,079 --> 00:02:03,180
immediate and easy to debug things but

00:02:01,290 --> 00:02:05,759
you can also write quite complicated app

00:02:03,180 --> 00:02:07,380
patience and there's lots of hardware

00:02:05,759 --> 00:02:09,509
that you could try it out on I mean you

00:02:07,380 --> 00:02:12,270
can also try it out online with the

00:02:09,509 --> 00:02:13,110
simulator and download the code and and

00:02:12,270 --> 00:02:17,340
have a

00:02:13,110 --> 00:02:20,610
fun with it so my talk today is going to

00:02:17,340 --> 00:02:24,720
be a little bit technical and a little

00:02:20,610 --> 00:02:26,910
bit fun and some few demos so I have a

00:02:24,720 --> 00:02:28,800
background in theoretical physics and in

00:02:26,910 --> 00:02:33,360
physics there are the concepts of time

00:02:28,800 --> 00:02:35,160
and space and energy and if you try and

00:02:33,360 --> 00:02:36,540
extend those to computing and stuff so

00:02:35,160 --> 00:02:39,570
time it's like you want to make things

00:02:36,540 --> 00:02:41,220
go fast space is like storage like hard

00:02:39,570 --> 00:02:43,440
drive storage and memory so you want to

00:02:41,220 --> 00:02:46,620
reduce that and the energy use where you

00:02:43,440 --> 00:02:49,260
all know about energy and how expensive

00:02:46,620 --> 00:02:50,880
it is and how you want to sort of reduce

00:02:49,260 --> 00:02:53,340
energy use because if we have a million

00:02:50,880 --> 00:02:55,200
or billion IOT devices and they use a

00:02:53,340 --> 00:02:56,940
nano amp that's really good but if they

00:02:55,200 --> 00:03:00,390
use an amp you know that's a lot of

00:02:56,940 --> 00:03:02,700
power so any optimization you can do is

00:03:00,390 --> 00:03:06,120
good for the environment

00:03:02,700 --> 00:03:07,320
that's my son would like to say so the

00:03:06,120 --> 00:03:09,000
aim of this talk is to just give a

00:03:07,320 --> 00:03:10,709
little bit of overview of some technical

00:03:09,000 --> 00:03:15,150
details of micro Python and how they

00:03:10,709 --> 00:03:17,340
relate to efficiency and give some taste

00:03:15,150 --> 00:03:19,049
on that that insight gives some tips and

00:03:17,340 --> 00:03:20,790
tricks on how to make things faster if

00:03:19,049 --> 00:03:22,799
you're writing code and some of these

00:03:20,790 --> 00:03:25,739
tricks will also be useful for normal

00:03:22,799 --> 00:03:28,920
Python and eight even programming in

00:03:25,739 --> 00:03:32,130
general and then there's a few examples

00:03:28,920 --> 00:03:34,290
just to sort of motivate this whole this

00:03:32,130 --> 00:03:38,820
whole thing and I'll start with those

00:03:34,290 --> 00:03:40,260
two examples so the first one the very

00:03:38,820 --> 00:03:41,880
simple thing the hello world of

00:03:40,260 --> 00:03:45,600
microcontrollers is to bring blinking

00:03:41,880 --> 00:03:47,910
LED on and off and in the top little

00:03:45,600 --> 00:03:49,410
black box there of demo code so this

00:03:47,910 --> 00:03:53,400
will actually work so it's creating an

00:03:49,410 --> 00:03:55,470
LED the blue LED and then it's doing a

00:03:53,400 --> 00:03:57,480
simple loop so end times so you have to

00:03:55,470 --> 00:03:59,220
feed in the parameter n and just turning

00:03:57,480 --> 00:04:01,320
the LED on and off so it's quite

00:03:59,220 --> 00:04:04,350
straightforward about what it's doing

00:04:01,320 --> 00:04:07,230
there and if you run this on a on a on a

00:04:04,350 --> 00:04:08,070
PI board you you can blink it about 50

00:04:07,230 --> 00:04:10,590
kilohertz

00:04:08,070 --> 00:04:14,750
so that's 50,000 times per second this

00:04:10,590 --> 00:04:17,280
loop can run so that as in it will go on

00:04:14,750 --> 00:04:20,280
50,000 times in or 50,000 times so the

00:04:17,280 --> 00:04:21,959
loop runs 50,000 times per second but we

00:04:20,280 --> 00:04:23,070
want to make that go faster and so by

00:04:21,959 --> 00:04:26,139
the end of this talk I'll show you how

00:04:23,070 --> 00:04:29,439
to make that go 500 times faster

00:04:26,139 --> 00:04:31,629
and the second example is to read a file

00:04:29,439 --> 00:04:33,430
so it's pretty silly it's just reading

00:04:31,629 --> 00:04:36,099
data from a file there so it's going

00:04:33,430 --> 00:04:39,159
through and reading a thousand bytes at

00:04:36,099 --> 00:04:40,800
a time n times and then sneaking back to

00:04:39,159 --> 00:04:44,139
the start of the file just a time itself

00:04:40,800 --> 00:04:45,939
and that currently just as it is runs at

00:04:44,139 --> 00:04:48,550
about 1 & a half megabytes per second

00:04:45,939 --> 00:04:50,289
and reading and we can get that up to

00:04:48,550 --> 00:04:53,620
about 20 megabytes per second with a

00:04:50,289 --> 00:04:55,150
very simple optimization so keep that in

00:04:53,620 --> 00:04:57,219
mind so the motivation this talk is to

00:04:55,150 --> 00:04:59,199
make these things run faster and I'll

00:04:57,219 --> 00:05:00,849
sort of go into some technical details

00:04:59,199 --> 00:05:06,490
and we'll come back to making those

00:05:00,849 --> 00:05:08,710
speed up at the end so this is a diagram

00:05:06,490 --> 00:05:11,050
of how micro Python works internally and

00:05:08,710 --> 00:05:15,870
don't try and absorb the whole thing

00:05:11,050 --> 00:05:18,849
just sort of understand that on the

00:05:15,870 --> 00:05:21,039
there's a compiler so on the left is

00:05:18,849 --> 00:05:23,740
sort of the compilation phase so it

00:05:21,039 --> 00:05:25,060
takes your script which can come from

00:05:23,740 --> 00:05:26,409
one of those red boxes you've either

00:05:25,060 --> 00:05:29,379
type it in it'll prompt or you have a

00:05:26,409 --> 00:05:31,389
script in a file and the lexer turns it

00:05:29,379 --> 00:05:34,000
into tokens which gets passed into a

00:05:31,389 --> 00:05:37,000
parse tree and then compiled and the

00:05:34,000 --> 00:05:39,940
compiler can can emit bytecode which is

00:05:37,000 --> 00:05:44,229
run on a virtual machine or it can even

00:05:39,940 --> 00:05:46,330
emit machine instructions so that's you

00:05:44,229 --> 00:05:48,759
know from JavaScript perhaps you've

00:05:46,330 --> 00:05:50,169
heard about just-in-time compilation and

00:05:48,759 --> 00:05:52,719
making JavaScript really fast

00:05:50,169 --> 00:05:53,949
they do that by making machine code so

00:05:52,719 --> 00:05:55,330
micro Python can do that as well

00:05:53,949 --> 00:05:57,580
although it's ahead of time compilation

00:05:55,330 --> 00:06:00,939
and I'll touch on that a little bit at

00:05:57,580 --> 00:06:02,740
the end and then the in the top right

00:06:00,939 --> 00:06:04,810
that orange box represents all the

00:06:02,740 --> 00:06:07,060
runtime support functionality like you

00:06:04,810 --> 00:06:08,919
know searching if a string ends with

00:06:07,060 --> 00:06:10,539
something or splitting a string up or

00:06:08,919 --> 00:06:12,580
look searching in a dictionary so all

00:06:10,539 --> 00:06:14,080
that sort of gory details it's all

00:06:12,580 --> 00:06:19,659
written in C it's pretty boring but it's

00:06:14,080 --> 00:06:22,689
the guts of everything so as I said we

00:06:19,659 --> 00:06:24,310
have a compiler and just reads account

00:06:22,689 --> 00:06:25,389
input string character by character so

00:06:24,310 --> 00:06:27,310
that means it doesn't actually load

00:06:25,389 --> 00:06:28,870
stuff into memory if there's a file on

00:06:27,310 --> 00:06:32,830
the disk it just reads it in one byte at

00:06:28,870 --> 00:06:35,529
a time so it doesn't waste memory

00:06:32,830 --> 00:06:37,209
loading at all at once but once you've

00:06:35,529 --> 00:06:38,589
run the compiler it can leave memory

00:06:37,209 --> 00:06:39,490
fragmented because there are some

00:06:38,589 --> 00:06:40,990
structures it has to

00:06:39,490 --> 00:06:45,310
memory so that's one thing to keep in

00:06:40,990 --> 00:06:47,350
mind and also any variable names that

00:06:45,310 --> 00:06:49,509
you use are left in RAM as well

00:06:47,350 --> 00:06:50,800
so the more variable names you have and

00:06:49,509 --> 00:06:53,050
the longer they are the more memory

00:06:50,800 --> 00:06:54,819
you'll be using at the end so one way to

00:06:53,050 --> 00:06:58,750
optimize that is to use shorter variable

00:06:54,819 --> 00:07:00,880
names and reuse them and when we

00:06:58,750 --> 00:07:02,979
generate bytecode we also use Ram

00:07:00,880 --> 00:07:05,800
obviously to generate that bytecode you

00:07:02,979 --> 00:07:08,229
can't really get around that and as I

00:07:05,800 --> 00:07:09,970
said we can generate machine code which

00:07:08,229 --> 00:07:11,440
will make things go faster and also I'll

00:07:09,970 --> 00:07:14,020
show you how to do that and also inline

00:07:11,440 --> 00:07:16,840
assembler is is something if you really

00:07:14,020 --> 00:07:20,639
want to go very fast and I'll show you

00:07:16,840 --> 00:07:23,320
how that will work with the LED example

00:07:20,639 --> 00:07:25,479
so these are all of the byte codes that

00:07:23,320 --> 00:07:27,160
micro pathid has when it compiles the

00:07:25,479 --> 00:07:29,259
script now you don't have to understand

00:07:27,160 --> 00:07:31,330
all these but this is a list of them all

00:07:29,259 --> 00:07:34,320
so you can see that you know there's a

00:07:31,330 --> 00:07:36,940
finite number and they're not that

00:07:34,320 --> 00:07:39,940
complicated a lot of them are to do with

00:07:36,940 --> 00:07:42,039
loading like objects false none true at

00:07:39,940 --> 00:07:43,960
the top left there so when you have

00:07:42,039 --> 00:07:47,080
false in your code that is corresponds

00:07:43,960 --> 00:07:49,479
to one byte code so one byte to load

00:07:47,080 --> 00:07:52,479
false and then do something with it in

00:07:49,479 --> 00:07:55,509
an expression down the bottom in the

00:07:52,479 --> 00:07:57,669
middle is like call function call method

00:07:55,509 --> 00:07:59,259
so there's a bytecode to actually do

00:07:57,669 --> 00:08:00,969
that and that's split up into one that

00:07:59,259 --> 00:08:02,560
calls simple functions and one that

00:08:00,969 --> 00:08:04,780
calls more complicated functions with

00:08:02,560 --> 00:08:07,440
key word variable keyword arguments like

00:08:04,780 --> 00:08:09,520
when you use star or star star operators

00:08:07,440 --> 00:08:10,780
and then you know there's a bunch of

00:08:09,520 --> 00:08:16,030
other things there but all these things

00:08:10,780 --> 00:08:17,110
here can implement all of Python and to

00:08:16,030 --> 00:08:19,539
show you a bit more of a concrete

00:08:17,110 --> 00:08:25,060
example so here's some script on the

00:08:19,539 --> 00:08:26,710
left and bytecode on the right and you

00:08:25,060 --> 00:08:29,949
can see this exactly what it's doing

00:08:26,710 --> 00:08:32,979
here so it's loading the print loading a

00:08:29,949 --> 00:08:35,860
string sleep now load fast zero means

00:08:32,979 --> 00:08:39,010
that it's loading the variable D because

00:08:35,860 --> 00:08:40,329
that's the zero local variable and then

00:08:39,010 --> 00:08:42,010
it calls the function so that calls

00:08:40,329 --> 00:08:44,680
print that first thing it loaded there

00:08:42,010 --> 00:08:46,240
and then the result doesn't care what

00:08:44,680 --> 00:08:48,910
the result is not using it so it pops

00:08:46,240 --> 00:08:51,459
out off the stack and then it does the

00:08:48,910 --> 00:08:53,380
next the next line which is gets time

00:08:51,459 --> 00:08:57,010
loads to sleep

00:08:53,380 --> 00:08:59,200
action loads d again calls the sleep

00:08:57,010 --> 00:09:01,480
function discards the value with the pop

00:08:59,200 --> 00:09:02,980
top and then the last two lines of

00:09:01,480 --> 00:09:05,020
returning none from this function so

00:09:02,980 --> 00:09:07,240
that you can see that takes two bytes to

00:09:05,020 --> 00:09:10,690
return none so this whole function is 22

00:09:07,240 --> 00:09:12,610
bytes in memory and this kind of shows

00:09:10,690 --> 00:09:14,770
the sort of the differences in speed

00:09:12,610 --> 00:09:17,170
that you can get from certain things so

00:09:14,770 --> 00:09:18,910
loading a global like print is slow

00:09:17,170 --> 00:09:22,750
because it has to go into the global

00:09:18,910 --> 00:09:24,960
dictionary and search for print but if

00:09:22,750 --> 00:09:27,640
you look at the third line low fast zero

00:09:24,960 --> 00:09:30,310
this is just a one byte instruction and

00:09:27,640 --> 00:09:32,710
it knows that D is the first local

00:09:30,310 --> 00:09:34,180
variable on the stack so it can get it

00:09:32,710 --> 00:09:37,060
straight away there's no searching

00:09:34,180 --> 00:09:38,590
through a dictionary so loading local

00:09:37,060 --> 00:09:40,690
variables and storing two local

00:09:38,590 --> 00:09:42,700
variables is a fast thing to do but

00:09:40,690 --> 00:09:44,650
global variables are slow so that's

00:09:42,700 --> 00:09:46,690
probably the most important thing when

00:09:44,650 --> 00:09:49,710
you want to optimize your code is to use

00:09:46,690 --> 00:09:52,600
local variables and not global variables

00:09:49,710 --> 00:09:55,630
and the other thing is that it's slow to

00:09:52,600 --> 00:09:58,450
load methods and functions so down the

00:09:55,630 --> 00:10:00,190
middle there load method sleep so you've

00:09:58,450 --> 00:10:01,960
got the time module I'm looking for

00:10:00,190 --> 00:10:03,340
sleep so I had that also has to be a

00:10:01,960 --> 00:10:05,380
dictionary search so it's got to go

00:10:03,340 --> 00:10:07,660
through a dictionary of the time module

00:10:05,380 --> 00:10:09,130
and look for the sleep function and even

00:10:07,660 --> 00:10:11,640
though it's using hashing and it's sort

00:10:09,130 --> 00:10:14,860
of order one it's still slow relatively

00:10:11,640 --> 00:10:17,260
and so these things here can be

00:10:14,860 --> 00:10:19,030
optimized by sort of pre loading any

00:10:17,260 --> 00:10:21,150
methods that you want to use over and

00:10:19,030 --> 00:10:24,520
over again if you want to make it faster

00:10:21,150 --> 00:10:26,920
so yeah this is kind of a good example

00:10:24,520 --> 00:10:28,780
of some real-life things that can help

00:10:26,920 --> 00:10:34,960
you make code make make your code go

00:10:28,780 --> 00:10:38,920
faster so the other thing so this is

00:10:34,960 --> 00:10:40,150
this is a long slide but try don't get

00:10:38,920 --> 00:10:41,740
overwhelmed it's just about memory

00:10:40,150 --> 00:10:44,530
allocation which is really important in

00:10:41,740 --> 00:10:46,540
in microcontrollers because when you

00:10:44,530 --> 00:10:49,240
allocate memory it's slow because you've

00:10:46,540 --> 00:10:50,560
got to go find some memory and if you

00:10:49,240 --> 00:10:52,180
can't find it you go to do a garbage

00:10:50,560 --> 00:10:54,610
collection so that can take you know

00:10:52,180 --> 00:10:56,020
five milliseconds or something which is

00:10:54,610 --> 00:11:00,550
a long time when you want to flash an

00:10:56,020 --> 00:11:02,080
LED millions of times per second so the

00:11:00,550 --> 00:11:05,080
best thing to do is to try not to

00:11:02,080 --> 00:11:06,430
allocate memory when you can and to know

00:11:05,080 --> 00:11:07,010
how to not allocate memory you've got to

00:11:06,430 --> 00:11:09,890
know what thing

00:11:07,010 --> 00:11:12,770
don't allocate memory so a little

00:11:09,890 --> 00:11:13,340
expression like one plus two times X and

00:11:12,770 --> 00:11:15,740
so on

00:11:13,340 --> 00:11:18,110
expressions don't need to allocate

00:11:15,740 --> 00:11:21,340
memory because they use the stack and

00:11:18,110 --> 00:11:23,900
all of the basic comments in Python as

00:11:21,340 --> 00:11:27,050
in when in micro Python implements them

00:11:23,900 --> 00:11:29,480
like if and while and for statements and

00:11:27,050 --> 00:11:31,310
try accept finally they don't need to

00:11:29,480 --> 00:11:33,710
allocate any memory on the heap so

00:11:31,310 --> 00:11:36,350
they're all relatively fast so you can

00:11:33,710 --> 00:11:40,130
do a lot of stuff without allocating

00:11:36,350 --> 00:11:41,690
memory there so this is heap memory it

00:11:40,130 --> 00:11:45,200
still used the stack but the stack has

00:11:41,690 --> 00:11:46,490
been pre allocated for the function as I

00:11:45,200 --> 00:11:47,720
said before local variables because you

00:11:46,490 --> 00:11:49,760
know a local variable where it lives

00:11:47,720 --> 00:11:52,550
it's easy to store and load local

00:11:49,760 --> 00:11:54,440
variables small integer arithmetic if

00:11:52,550 --> 00:11:56,860
you're using less than 31 bits that

00:11:54,440 --> 00:11:59,890
doesn't need to allocate on the heap and

00:11:56,860 --> 00:12:02,870
then for things like less than Dix and

00:11:59,890 --> 00:12:05,510
byte arrays if you do in-place

00:12:02,870 --> 00:12:07,310
operations like your sub scripting a

00:12:05,510 --> 00:12:09,110
dictionary or sub scripting a list or

00:12:07,310 --> 00:12:10,670
even sorting a list in place those

00:12:09,110 --> 00:12:14,120
things don't need to allocate heap

00:12:10,670 --> 00:12:15,350
memory so that's also good to know so

00:12:14,120 --> 00:12:17,510
you can do quite a lot of things if

00:12:15,350 --> 00:12:20,750
you've pre created things like lists and

00:12:17,510 --> 00:12:22,430
dictionaries if you call functions and

00:12:20,750 --> 00:12:24,110
methods and you don't use the star or

00:12:22,430 --> 00:12:26,330
star star operators then that also

00:12:24,110 --> 00:12:28,250
doesn't allocate memory so as soon as

00:12:26,330 --> 00:12:31,490
you go into the land of variable keyword

00:12:28,250 --> 00:12:34,160
and variable positional arguments then

00:12:31,490 --> 00:12:37,160
you start to you'll see slower code

00:12:34,160 --> 00:12:40,730
execution and a lot of built-ins don't

00:12:37,160 --> 00:12:42,620
need to use the heap memory but things

00:12:40,730 --> 00:12:44,300
you can probably imagine that do use

00:12:42,620 --> 00:12:45,950
heap memory is when you import a module

00:12:44,300 --> 00:12:47,300
this is a whole lot of compilation and

00:12:45,950 --> 00:12:49,700
importing and loading of dictionaries

00:12:47,300 --> 00:12:51,440
that goes on there when you define a

00:12:49,700 --> 00:12:54,050
function in a class again you've got to

00:12:51,440 --> 00:12:58,520
create the actual function in class so

00:12:54,050 --> 00:13:00,350
that takes memory and one thing that

00:12:58,520 --> 00:13:02,120
trick that trips me up even though I

00:13:00,350 --> 00:13:04,090
know is that assigning a global variable

00:13:02,120 --> 00:13:06,440
for the first time will allocate memory

00:13:04,090 --> 00:13:07,790
because when you write to a global

00:13:06,440 --> 00:13:09,500
variable you've got a story into the

00:13:07,790 --> 00:13:11,300
global dictionary and if the global

00:13:09,500 --> 00:13:13,070
dictionaries too small has to be resized

00:13:11,300 --> 00:13:16,880
and you've got to find a slot for it and

00:13:13,070 --> 00:13:18,230
so on so that's something global

00:13:16,880 --> 00:13:20,060
variables are things you should try not

00:13:18,230 --> 00:13:22,700
to use if you're concerned about a fish

00:13:20,060 --> 00:13:25,100
see and creating data structures is also

00:13:22,700 --> 00:13:29,150
obviously allocating a list is going to

00:13:25,100 --> 00:13:31,190
take memory so the next few light slides

00:13:29,150 --> 00:13:32,570
give some tips on based on this

00:13:31,190 --> 00:13:34,130
knowledge that I've just gone through of

00:13:32,570 --> 00:13:36,740
how to make things run a little bit

00:13:34,130 --> 00:13:39,290
faster so as I said use functions

00:13:36,740 --> 00:13:40,850
don't use global scope so put stuff in a

00:13:39,290 --> 00:13:42,920
function if you can cuz that we use

00:13:40,850 --> 00:13:45,110
local variables so immediately taking

00:13:42,920 --> 00:13:47,090
something that's in the global scope

00:13:45,110 --> 00:13:50,710
like in the module level and putting

00:13:47,090 --> 00:13:53,630
into a function that will make it faster

00:13:50,710 --> 00:13:56,650
preload or cache methods and functions

00:13:53,630 --> 00:13:59,210
that you know you want to use a lot and

00:13:56,650 --> 00:14:00,950
sort of going against maybe some good

00:13:59,210 --> 00:14:02,750
programming principles prefer long

00:14:00,950 --> 00:14:04,670
expressions rather than breaking them up

00:14:02,750 --> 00:14:07,070
because a long expression doesn't have

00:14:04,670 --> 00:14:08,480
to load and store to some variables into

00:14:07,070 --> 00:14:11,090
intermediate it just creates this

00:14:08,480 --> 00:14:12,290
expression on the stack so you know if

00:14:11,090 --> 00:14:13,940
you can write one in what something in

00:14:12,290 --> 00:14:17,930
one line write it in one line because it

00:14:13,940 --> 00:14:20,570
will be faster and you know don't write

00:14:17,930 --> 00:14:22,970
your own you know starts with function

00:14:20,570 --> 00:14:24,110
like if you wanna search for the

00:14:22,970 --> 00:14:25,940
beginning of this if you want to notice

00:14:24,110 --> 00:14:27,890
a big string start or something new

00:14:25,940 --> 00:14:29,390
starts with because starts with is

00:14:27,890 --> 00:14:31,400
written in a C it's going to be faster

00:14:29,390 --> 00:14:35,060
than the way if you try and write that

00:14:31,400 --> 00:14:37,790
in Python and macro Bethenny includes

00:14:35,060 --> 00:14:39,710
this way to make constants so if you use

00:14:37,790 --> 00:14:42,950
this construct here from my code path

00:14:39,710 --> 00:14:46,160
n'importe constant then x equals Const 1

00:14:42,950 --> 00:14:48,140
wherever the compiler sees X capital X

00:14:46,160 --> 00:14:50,120
again for this example it will replace

00:14:48,140 --> 00:14:54,740
it with 1 so it'll actually it's kind of

00:14:50,120 --> 00:14:56,450
like C hash defines or something so they

00:14:54,740 --> 00:15:00,110
actually do proper constants there and

00:14:56,450 --> 00:15:01,310
also it is okay to do things like 1 plus

00:15:00,110 --> 00:15:03,560
2 in your code you don't have to

00:15:01,310 --> 00:15:05,810
optimize that to 3 the compiler what

00:15:03,560 --> 00:15:08,270
demise that for you so don't be afraid

00:15:05,810 --> 00:15:15,010
to use constants and in in ways like

00:15:08,270 --> 00:15:18,290
that so to reduce RAM usage just try and

00:15:15,010 --> 00:15:21,770
basically use the constructs that don't

00:15:18,290 --> 00:15:23,510
use heap memory use shorter variable

00:15:21,770 --> 00:15:24,860
names and reuse them ok this is again

00:15:23,510 --> 00:15:27,620
against sort of some programming

00:15:24,860 --> 00:15:29,690
principles but you know it's ok to use X

00:15:27,620 --> 00:15:33,140
Y and I you know if you just got

00:15:29,690 --> 00:15:33,980
coordinates or indexes and if you're

00:15:33,140 --> 00:15:35,510
reusing a

00:15:33,980 --> 00:15:36,860
that already exists somewhere else you

00:15:35,510 --> 00:15:38,660
don't have to allocate more memory to

00:15:36,860 --> 00:15:42,650
sort of store to store that variable

00:15:38,660 --> 00:15:43,550
name so use short names and and make

00:15:42,650 --> 00:15:45,470
them you know you program a

00:15:43,550 --> 00:15:47,540
microcontroller so don't be like you

00:15:45,470 --> 00:15:49,730
know this variable is the x-coordinate

00:15:47,540 --> 00:15:55,130
off my window so it's like just call it

00:15:49,730 --> 00:15:57,110
X and temporary buffers so sometimes

00:15:55,130 --> 00:15:59,300
it's good if if you really don't want to

00:15:57,110 --> 00:16:01,220
allocate any memory on the fly you pre

00:15:59,300 --> 00:16:03,650
allocate it like a bite or if size one

00:16:01,220 --> 00:16:05,180
even and then use that again and again

00:16:03,650 --> 00:16:08,210
so you want to construct a command

00:16:05,180 --> 00:16:12,710
that's one bit long and you can do that

00:16:08,210 --> 00:16:14,090
by reusing a buffer and the into methods

00:16:12,710 --> 00:16:16,340
so I'll go through those with the file

00:16:14,090 --> 00:16:19,460
example but there are some in-place

00:16:16,340 --> 00:16:21,350
reading methods like read into where you

00:16:19,460 --> 00:16:24,130
read into a pre allocated array and you

00:16:21,350 --> 00:16:26,630
don't have to create one on the fly

00:16:24,130 --> 00:16:28,810
don't use star star star tags if you're

00:16:26,630 --> 00:16:31,810
concerned about speed and memory usage

00:16:28,810 --> 00:16:35,090
and you can one way to improve

00:16:31,810 --> 00:16:39,230
compilation time so you can pre compile

00:16:35,090 --> 00:16:42,200
your scripts to pre-compile mpy files

00:16:39,230 --> 00:16:45,260
they're like pyc files but for micro

00:16:42,200 --> 00:16:48,260
python so it that contains precompiled

00:16:45,260 --> 00:16:50,600
bytecode so when you load that or you

00:16:48,260 --> 00:16:52,910
import such a script in you don't need

00:16:50,600 --> 00:16:55,280
to do any compilation so you save a lot

00:16:52,910 --> 00:16:56,720
of memory and a lot of time doing that

00:16:55,280 --> 00:16:58,640
it's doing is to load the code into

00:16:56,720 --> 00:17:00,770
memory but it doesn't have to go through

00:16:58,640 --> 00:17:03,530
the whole process of compiling so that

00:17:00,770 --> 00:17:07,370
saves you memory so that that is a big a

00:17:03,530 --> 00:17:09,140
big way to improve your speed as well as

00:17:07,370 --> 00:17:11,770
memory usage is to pre-compiled scripts

00:17:09,140 --> 00:17:14,660
and then out finally you can actually

00:17:11,770 --> 00:17:16,340
give in a Python script you can freeze

00:17:14,660 --> 00:17:18,080
it into the firmware so you've got to do

00:17:16,340 --> 00:17:20,780
this at compile time with this when

00:17:18,080 --> 00:17:23,510
you're compiling in C but this way it

00:17:20,780 --> 00:17:27,350
uses almost zero memory because the

00:17:23,510 --> 00:17:30,860
bytecode will be stored in flash storage

00:17:27,350 --> 00:17:32,180
so it doesn't use any RAM at all but

00:17:30,860 --> 00:17:34,040
that's that's quite an advanced topic

00:17:32,180 --> 00:17:35,410
but it's be very useful if I'm you've

00:17:34,040 --> 00:17:37,640
got big scripts

00:17:35,410 --> 00:17:39,260
ok so I'll try and show you how to make

00:17:37,640 --> 00:17:42,260
this script faster now using this

00:17:39,260 --> 00:17:44,680
knowledge so the first thing we want to

00:17:42,260 --> 00:17:47,360
do like I said is to put it into a

00:17:44,680 --> 00:17:51,920
function so I'm just going to switch

00:17:47,360 --> 00:17:56,530
here so led1 alright so this is the

00:17:51,920 --> 00:17:59,150
simple loop here so all the other code

00:17:56,530 --> 00:18:00,679
so down here at the bottom it's just

00:17:59,150 --> 00:18:02,330
doing timing and printing out the timing

00:18:00,679 --> 00:18:04,420
of the loop but the actual code here

00:18:02,330 --> 00:18:07,400
we've got is just this simple loop to

00:18:04,420 --> 00:18:12,500
turn the LED on and off so if I run this

00:18:07,400 --> 00:18:17,080
code on my PI board here that I have

00:18:12,500 --> 00:18:20,809
connected so LED one so it will tell me

00:18:17,080 --> 00:18:26,120
I'll scroll the screen up in so it runs

00:18:20,809 --> 00:18:31,429
it about okay 57 kilohertz now if I have

00:18:26,120 --> 00:18:33,770
a look at LED - so what I've done here

00:18:31,429 --> 00:18:35,480
is simply put this in a function so I've

00:18:33,770 --> 00:18:37,429
done the same code taken the same code

00:18:35,480 --> 00:18:40,669
and I've just put in a function so I

00:18:37,429 --> 00:18:42,169
changed nothing else and I've got some

00:18:40,669 --> 00:18:44,530
other there just timing related code

00:18:42,169 --> 00:18:46,760
down here so you know that but the main

00:18:44,530 --> 00:18:50,110
the main code here is just this blink

00:18:46,760 --> 00:18:55,419
simple function so if we run this one

00:18:50,110 --> 00:18:55,419
run number two I'll just

00:18:58,059 --> 00:19:04,370
sorry

00:19:00,280 --> 00:19:06,860
okay so 66 kilohertz so we've gained you

00:19:04,370 --> 00:19:08,450
know from 55 to 66 who gained a little

00:19:06,860 --> 00:19:09,559
bit but sometimes that's all you need

00:19:08,450 --> 00:19:10,370
because you just needed to run that a

00:19:09,559 --> 00:19:13,520
little bit faster

00:19:10,370 --> 00:19:15,830
you know gaining 10% in speed is

00:19:13,520 --> 00:19:17,630
actually quite quite big just by putting

00:19:15,830 --> 00:19:18,890
something into a function so that's

00:19:17,630 --> 00:19:23,480
because it didn't need to use global

00:19:18,890 --> 00:19:27,410
variables okay now in the third case so

00:19:23,480 --> 00:19:29,419
we're going to it's still in a function

00:19:27,410 --> 00:19:33,140
and we're going to preload the methods

00:19:29,419 --> 00:19:34,640
that we want to use so on is LED on so

00:19:33,140 --> 00:19:37,000
what it's doing here it's taking that

00:19:34,640 --> 00:19:40,400
LED object which was a global variable

00:19:37,000 --> 00:19:42,770
pre-loading the method on and storing

00:19:40,400 --> 00:19:44,840
that into a local variable so as I said

00:19:42,770 --> 00:19:47,750
local variables are really quick so now

00:19:44,840 --> 00:19:49,390
down here when we call on it's loading a

00:19:47,750 --> 00:19:52,010
local variable which is one byte and

00:19:49,390 --> 00:19:53,540
very quick and then calling it straight

00:19:52,010 --> 00:19:56,030
away with no arguments so it's super

00:19:53,540 --> 00:19:57,950
quick and there's no dictionary lookup

00:19:56,030 --> 00:20:00,200
so global x' no dictionary little cups

00:19:57,950 --> 00:20:01,040
for methods so you can expect that this

00:20:00,200 --> 00:20:03,830
might actually run

00:20:01,040 --> 00:20:05,810
quite fast Oh when I've also optimized

00:20:03,830 --> 00:20:09,950
the range yeah that's another little

00:20:05,810 --> 00:20:11,690
trick that you can yeah it's a bit

00:20:09,950 --> 00:20:14,990
faster if you do the range this way but

00:20:11,690 --> 00:20:18,200
that's a that's I want you can ask me

00:20:14,990 --> 00:20:23,020
about that later if you want so oops

00:20:18,200 --> 00:20:26,480
oops give away too much thick led3

00:20:23,020 --> 00:20:29,150
alright so that went to 182 kilohertz so

00:20:26,480 --> 00:20:30,650
that's three times faster so you can see

00:20:29,150 --> 00:20:32,150
that there's a big difference there by

00:20:30,650 --> 00:20:33,860
pre-loading your methods and using local

00:20:32,150 --> 00:20:35,200
variables instead of Global's so the

00:20:33,860 --> 00:20:39,290
difference there between 60 and

00:20:35,200 --> 00:20:41,960
kilohertz and 180 is global very looking

00:20:39,290 --> 00:20:43,970
at things in dictionaries really okay so

00:20:41,960 --> 00:20:45,950
now we get so that's that's so I think

00:20:43,970 --> 00:20:47,810
LED 3 is probably like where you might

00:20:45,950 --> 00:20:49,880
stop in most cases you like you know

00:20:47,810 --> 00:20:51,170
it's still understandable and if you

00:20:49,880 --> 00:20:53,090
really want to optimize stuff this is

00:20:51,170 --> 00:20:54,710
how you go but if you want to go further

00:20:53,090 --> 00:20:57,530
so I mean you can use the standard

00:20:54,710 --> 00:20:59,210
technique of loop unrolling so we'll

00:20:57,530 --> 00:21:00,380
unroll the loop eight times but

00:20:59,210 --> 00:21:02,090
everything else is the same I've

00:21:00,380 --> 00:21:03,950
pre-loaded by methods in a function

00:21:02,090 --> 00:21:07,090
divided by eight here because I

00:21:03,950 --> 00:21:09,880
obviously I unrolled it eight times and

00:21:07,090 --> 00:21:16,840
yeah so I just unroll the date times so

00:21:09,880 --> 00:21:19,850
let's see how much faster that goes so

00:21:16,840 --> 00:21:21,410
what is that ten percent again yeah it's

00:21:19,850 --> 00:21:22,430
not too bad but what you can see here is

00:21:21,410 --> 00:21:24,580
you're really hitting the limit of the

00:21:22,430 --> 00:21:27,290
virtual machine interpreting byte codes

00:21:24,580 --> 00:21:30,470
so there we're sort of getting rid of

00:21:27,290 --> 00:21:34,270
the overhead of the loop so let's see

00:21:30,470 --> 00:21:37,670
how much further we can go led five

00:21:34,270 --> 00:21:40,970
sorry so okay so what we're using here

00:21:37,670 --> 00:21:44,450
is lewder - before we're using machine

00:21:40,970 --> 00:21:46,490
code and not byte code anymore so when

00:21:44,450 --> 00:21:47,750
this function executes sorkin first of

00:21:46,490 --> 00:21:49,940
all it's compiled it's compiled into

00:21:47,750 --> 00:21:54,590
machine code so instead of now running a

00:21:49,940 --> 00:21:56,180
virtual machine actual instructions on

00:21:54,590 --> 00:21:59,210
the hardware which is this is a little

00:21:56,180 --> 00:22:02,660
ARM chip are being executed each time so

00:21:59,210 --> 00:22:05,210
to do an on instead of executing the on

00:22:02,660 --> 00:22:06,590
bytecode X ray the instead of acting

00:22:05,210 --> 00:22:08,660
your feedback codes to load or the on

00:22:06,590 --> 00:22:11,480
method and call it it's executing actual

00:22:08,660 --> 00:22:13,990
machine instructions directly which

00:22:11,480 --> 00:22:15,850
makes things yeah

00:22:13,990 --> 00:22:19,480
little bit faster so we'll see how much

00:22:15,850 --> 00:22:22,480
faster le do five so this is the same as

00:22:19,480 --> 00:22:24,280
LED for exact same code but it's in

00:22:22,480 --> 00:22:27,640
machine code instead of using the

00:22:24,280 --> 00:22:30,550
virtual machine so that's about 220

00:22:27,640 --> 00:22:34,179
percent faster so it's pretty easy to

00:22:30,550 --> 00:22:37,179
just put this little decorator there's a

00:22:34,179 --> 00:22:40,290
one-line change this decorator here at

00:22:37,179 --> 00:22:42,820
the top of your function to make it

00:22:40,290 --> 00:22:44,350
imaging machine code not all things are

00:22:42,820 --> 00:22:47,200
supported but a lot of things are and

00:22:44,350 --> 00:22:50,190
I'm improving that so I think there's

00:22:47,200 --> 00:22:50,190
two more to go

00:22:50,440 --> 00:22:58,059
hang on so LED six so this one here is

00:22:54,700 --> 00:23:00,070
this is really a bit crazy so this uses

00:22:58,059 --> 00:23:03,340
another mode called Viper mode which is

00:23:00,070 --> 00:23:05,080
a bit undocumented and and not finished

00:23:03,340 --> 00:23:08,230
did you know but it still does work it

00:23:05,080 --> 00:23:11,740
allows you to basically directly do

00:23:08,230 --> 00:23:13,630
things in machine code but rioted in

00:23:11,740 --> 00:23:15,190
Python it's really kind of a weird

00:23:13,630 --> 00:23:18,190
hybrid of Python and see it's like

00:23:15,190 --> 00:23:19,960
python syntax we see semantics so what

00:23:18,190 --> 00:23:22,530
I've got here I've created a pointer the

00:23:19,960 --> 00:23:26,380
points to the register of the peripheral

00:23:22,530 --> 00:23:27,940
so we're on GPIO B for this LED you

00:23:26,380 --> 00:23:29,830
could actually see LED flashing 50 times

00:23:27,940 --> 00:23:32,470
to 50,000 times a second if you wanted

00:23:29,830 --> 00:23:34,870
to down here but it's a bit boring so

00:23:32,470 --> 00:23:40,179
this this is actually each line here

00:23:34,870 --> 00:23:42,220
it's going on and off and by writing to

00:23:40,179 --> 00:23:44,350
a register so this is going to turn into

00:23:42,220 --> 00:23:45,760
basically one machine instruction so

00:23:44,350 --> 00:23:48,760
it's going to do one instruction here

00:23:45,760 --> 00:23:51,340
put on and off as opposed to loading a

00:23:48,760 --> 00:23:52,450
method before and executing it I don't

00:23:51,340 --> 00:23:54,400
want to go to the details of this you

00:23:52,450 --> 00:23:56,800
can you can ask me about it later I just

00:23:54,400 --> 00:24:01,390
wanted to show you what is possible so

00:23:56,800 --> 00:24:03,250
if we execute this one it's a yeah I

00:24:01,390 --> 00:24:05,050
can't even multiple do that division in

00:24:03,250 --> 00:24:08,070
my head it's quite a lot faster there so

00:24:05,050 --> 00:24:11,650
it's more than even 10 times faster it's

00:24:08,070 --> 00:24:14,860
60 times faster or almost well 50 times

00:24:11,650 --> 00:24:16,780
faster so I'll just show you that code

00:24:14,860 --> 00:24:17,770
again it's you've got to know what

00:24:16,780 --> 00:24:19,390
you're doing and you've got to be able

00:24:17,770 --> 00:24:21,190
you know you can't read files this way

00:24:19,390 --> 00:24:23,260
you can only do things that require

00:24:21,190 --> 00:24:26,590
register access or really low-level

00:24:23,260 --> 00:24:27,980
stuff but yeah I'm just writing to the

00:24:26,590 --> 00:24:32,019
to the register here

00:24:27,980 --> 00:24:37,429
and that's it so then the final example

00:24:32,019 --> 00:24:43,220
led seven so so this is it written in

00:24:37,429 --> 00:24:45,110
inline assembler so so logical shift

00:24:43,220 --> 00:24:48,760
left so that's divided by three eight

00:24:45,110 --> 00:24:52,399
like before load the value of this

00:24:48,760 --> 00:24:56,179
register load the value the peripheral

00:24:52,399 --> 00:24:58,370
register into r1 once you've left for

00:24:56,179 --> 00:25:01,880
you saw that before that's the because

00:24:58,370 --> 00:25:03,980
we're GPIO be for loop is a label and

00:25:01,880 --> 00:25:06,679
then this store hi so that's actually

00:25:03,980 --> 00:25:09,500
turning it on and off on off on off so

00:25:06,679 --> 00:25:12,500
unroll the loop eight times here and at

00:25:09,500 --> 00:25:14,870
the bottom check subtract one from our

00:25:12,500 --> 00:25:16,549
counter and branch if it's not zero back

00:25:14,870 --> 00:25:18,080
to loop but if it is zero we've finished

00:25:16,549 --> 00:25:20,630
our loop and then that's the end of the

00:25:18,080 --> 00:25:23,570
function so here I've written inline

00:25:20,630 --> 00:25:26,720
assembler in Python syntax and let so

00:25:23,570 --> 00:25:32,059
this is sort of the punchline of the

00:25:26,720 --> 00:25:33,980
entire talk so 27 megahertz right so

00:25:32,059 --> 00:25:37,549
that's about 500 times faster than the

00:25:33,980 --> 00:25:39,529
initial code so and 27 megahertz

00:25:37,549 --> 00:25:41,179
blinking LED is almost a limit of the

00:25:39,529 --> 00:25:43,070
actual microcontroller itself because

00:25:41,179 --> 00:25:44,299
we're writing like it's just that's

00:25:43,070 --> 00:25:46,399
because it runs that fast

00:25:44,299 --> 00:25:48,470
so the microcontroller runs at 168

00:25:46,399 --> 00:25:49,909
megahertz here so you know you're only

00:25:48,470 --> 00:25:54,139
doing you're doing less than 10

00:25:49,909 --> 00:25:56,480
instructions per per blink so yeah

00:25:54,139 --> 00:25:58,909
that's that and then I've only got a

00:25:56,480 --> 00:26:02,360
minute left but doing this next example

00:25:58,909 --> 00:26:04,429
was pretty quick so this is just reading

00:26:02,360 --> 00:26:05,899
a thousand bytes over and over and over

00:26:04,429 --> 00:26:07,580
again and we're reading at one and a

00:26:05,899 --> 00:26:14,120
half megahertz or so a one and a half

00:26:07,580 --> 00:26:17,360
megabytes per second so file okay I've

00:26:14,120 --> 00:26:20,870
got everything here in one file so the

00:26:17,360 --> 00:26:22,399
naive the nave implementation is this

00:26:20,870 --> 00:26:24,860
file rate here which is just what you

00:26:22,399 --> 00:26:27,980
saw on the slide the optimized one I've

00:26:24,860 --> 00:26:30,409
unrolled the loop twice and I've

00:26:27,980 --> 00:26:35,000
pre-loaded the methods so they're just

00:26:30,409 --> 00:26:38,059
some techniques there and then the the

00:26:35,000 --> 00:26:39,320
final optimization the third one it's

00:26:38,059 --> 00:26:41,420
quite it's simpler but what I've used

00:26:39,320 --> 00:26:43,780
here is this read into

00:26:41,420 --> 00:26:46,790
method so basically this is not

00:26:43,780 --> 00:26:49,130
allocating memory each time so the other

00:26:46,790 --> 00:26:51,920
example was allocating a thousand bytes

00:26:49,130 --> 00:26:53,540
every time it read it but this example

00:26:51,920 --> 00:26:56,990
the one that's going to be the fastest

00:26:53,540 --> 00:26:59,860
here I've pre-allocated that array on

00:26:56,990 --> 00:27:02,900
that line and then in the actual loop

00:26:59,860 --> 00:27:04,460
which is just this bit I've used the

00:27:02,900 --> 00:27:06,230
same array and just read a thousand

00:27:04,460 --> 00:27:08,799
bytes into that same array so this thing

00:27:06,230 --> 00:27:10,880
doesn't use any memory when it's running

00:27:08,799 --> 00:27:16,400
it doesn't allocate any additional

00:27:10,880 --> 00:27:17,720
memory so if we run that you'll it'll

00:27:16,400 --> 00:27:21,080
run all three of them and show you the

00:27:17,720 --> 00:27:23,330
comparison between them so the simple

00:27:21,080 --> 00:27:26,210
example one and a half megabytes the

00:27:23,330 --> 00:27:27,320
slightly optimized one is almost not

00:27:26,210 --> 00:27:28,760
faster at all that's because you're

00:27:27,320 --> 00:27:31,100
really limited by the memory allocation

00:27:28,760 --> 00:27:33,080
here but then if we don't do memory

00:27:31,100 --> 00:27:35,540
allocation in the loop we get up to 20

00:27:33,080 --> 00:27:37,730
megabytes a second which is about 1213

00:27:35,540 --> 00:27:38,600
times faster and that's probably that's

00:27:37,730 --> 00:27:40,250
really as far as you can go that's

00:27:38,600 --> 00:27:43,940
almost the limit of actually reading the

00:27:40,250 --> 00:27:46,010
flash memory itself so but the key here

00:27:43,940 --> 00:27:50,260
is to is that showing you that Ram

00:27:46,010 --> 00:27:52,870
allocation is quite slow all right so

00:27:50,260 --> 00:27:54,620
I'm really at the end of my talk now and

00:27:52,870 --> 00:27:57,260
just to mention that the other

00:27:54,620 --> 00:27:59,299
optimizations so energy use if your code

00:27:57,260 --> 00:28:02,120
runs faster it can sleep for longer and

00:27:59,299 --> 00:28:04,010
sleeping is really low power consumption

00:28:02,120 --> 00:28:06,590
so therefore use less energy that's

00:28:04,010 --> 00:28:07,580
pretty simple rule of thumb but then

00:28:06,590 --> 00:28:09,080
you've got to think about other

00:28:07,580 --> 00:28:10,880
optimizations like how long did it take

00:28:09,080 --> 00:28:12,770
you to code it how long does it take you

00:28:10,880 --> 00:28:16,220
to debug it and how long does it take

00:28:12,770 --> 00:28:17,480
you to maintain this thing so you've got

00:28:16,220 --> 00:28:18,950
to make sure you're only optimize things

00:28:17,480 --> 00:28:20,900
that they really need to be optimized

00:28:18,950 --> 00:28:22,010
and I think that's sort of the key thing

00:28:20,900 --> 00:28:24,530
that you say that any programming

00:28:22,010 --> 00:28:26,690
language is that optimization should be

00:28:24,530 --> 00:28:30,500
at the end after you've worked out what

00:28:26,690 --> 00:28:32,030
the bottlenecks are the basic rule of

00:28:30,500 --> 00:28:33,530
thumb I use is that when you write

00:28:32,030 --> 00:28:35,270
something directly in Python it's about

00:28:33,530 --> 00:28:37,700
a hundred times slower than if writing

00:28:35,270 --> 00:28:39,440
the same thing in C but you can usually

00:28:37,700 --> 00:28:41,270
do a lot better than that because you

00:28:39,440 --> 00:28:43,070
know you don't read a file one byte at a

00:28:41,270 --> 00:28:45,169
time in Python you call file don't read

00:28:43,070 --> 00:28:47,600
and read a thousand at a time and that's

00:28:45,169 --> 00:28:49,190
all done in C under the hood and so you

00:28:47,600 --> 00:28:52,250
know reading a file is not a hundred

00:28:49,190 --> 00:28:54,830
times slower in Python than in C so try

00:28:52,250 --> 00:28:57,440
and use runtime methods

00:28:54,830 --> 00:28:59,210
like reading files or string those ends

00:28:57,440 --> 00:29:02,630
with or starts with on strings or

00:28:59,210 --> 00:29:04,280
regular expressions and in micro paithan

00:29:02,630 --> 00:29:07,430
the key thing is to use local variables

00:29:04,280 --> 00:29:08,720
and not global variables and that will

00:29:07,430 --> 00:29:12,200
get you a long way to making things

00:29:08,720 --> 00:29:14,720
faster so thanks for listening some

00:29:12,200 --> 00:29:23,270
links here and yeah I welcome any

00:29:14,720 --> 00:29:24,980
questions if I've got any time so I've

00:29:23,270 --> 00:29:26,300
got just about one minute left so you

00:29:24,980 --> 00:29:34,730
might have a chance for one or two quick

00:29:26,300 --> 00:29:36,560
questions anyone's got some just a

00:29:34,730 --> 00:29:40,460
question on when you pre-allocated the

00:29:36,560 --> 00:29:45,140
function into we pre allocated the

00:29:40,460 --> 00:29:52,730
function look like it was locally you

00:29:45,140 --> 00:29:55,700
mean like in this one or so it was where

00:29:52,730 --> 00:29:56,840
you had the function pre-allocated okay

00:29:55,700 --> 00:30:08,720
I see whoa

00:29:56,840 --> 00:30:11,470
so this one so pre I'm pre so LED itself

00:30:08,720 --> 00:30:13,460
is a global variable in this function

00:30:11,470 --> 00:30:16,610
because it's not you know it's it's

00:30:13,460 --> 00:30:18,860
defined in the global scope so when i

00:30:16,610 --> 00:30:22,100
when i just compile when this function

00:30:18,860 --> 00:30:24,140
is compiled it's it has to look up in

00:30:22,100 --> 00:30:26,840
the global dictionary of global

00:30:24,140 --> 00:30:28,280
variables to find led and it may not

00:30:26,840 --> 00:30:30,560
exist so it may have to raise an error

00:30:28,280 --> 00:30:33,350
and so on so it's got to go and search

00:30:30,560 --> 00:30:35,900
for a function by name but what I've

00:30:33,350 --> 00:30:38,480
done here is I've loaded that name once

00:30:35,900 --> 00:30:40,250
and then I've also loaded its method so

00:30:38,480 --> 00:30:42,230
I've done another dictionary lookup to

00:30:40,250 --> 00:30:46,340
load the method from within them object

00:30:42,230 --> 00:30:50,870
and that returns a bound method so you

00:30:46,340 --> 00:30:55,700
know in Python you have like you know if

00:30:50,870 --> 00:30:59,270
I have a string like and starts with so

00:30:55,700 --> 00:31:01,580
this is a that's a bound method of a

00:30:59,270 --> 00:31:05,030
instance of an object and then I can

00:31:01,580 --> 00:31:06,770
call that so yeah but I haven't done any

00:31:05,030 --> 00:31:10,440
arguments

00:31:06,770 --> 00:31:12,840
so this is actually low it's pre loading

00:31:10,440 --> 00:31:14,730
a method and storing it into the local

00:31:12,840 --> 00:31:17,430
variable and so on is a local variable

00:31:14,730 --> 00:31:19,110
so when I do this on here it's it's very

00:31:17,430 --> 00:31:21,960
quick and it's much quicker than doing

00:31:19,110 --> 00:31:28,530
led Don on even though it looks kind of

00:31:21,960 --> 00:31:29,550
very similar so yeah thank you so I

00:31:28,530 --> 00:31:30,870
think I'm fortunate all we've got time

00:31:29,550 --> 00:31:32,250
for for now but I'm sure Damon will

00:31:30,870 --> 00:31:33,540
answer questions in the in the

00:31:32,250 --> 00:31:35,250
short-term minute changeover break or

00:31:33,540 --> 00:31:36,850
you can find him out and around PyCon

00:31:35,250 --> 00:31:40,490
thank our much Damian okay

00:31:36,850 --> 00:31:40,490

YouTube URL: https://www.youtube.com/watch?v=hHec4qL00x0


