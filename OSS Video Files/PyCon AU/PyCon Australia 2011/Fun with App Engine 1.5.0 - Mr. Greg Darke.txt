Title: Fun with App Engine 1.5.0 - Mr. Greg Darke
Publication date: 2011-08-22
Playlist: PyCon Australia 2011
Description: 
	Using generators as coroutines in App Engine to get more done.
Captions: 
	00:00:00,000 --> 00:00:03,929
welcome back everyone I'd like to now

00:00:01,860 --> 00:00:06,180
introduce Greg dark from google here in

00:00:03,929 --> 00:00:15,089
Sydney here to talk about App Engine and

00:00:06,180 --> 00:00:17,940
generators as currently good morning

00:00:15,089 --> 00:00:18,960
everyone I think it still is so just

00:00:17,940 --> 00:00:20,670
quickly get through with the

00:00:18,960 --> 00:00:23,369
introduction so you know who i am i'm

00:00:20,670 --> 00:00:25,380
greg dark I a software engineer i work

00:00:23,369 --> 00:00:28,310
on the App Engine team in Sydney in

00:00:25,380 --> 00:00:32,550
particular I work on task you cron and

00:00:28,310 --> 00:00:34,290
the pork use API that's my main project

00:00:32,550 --> 00:00:36,210
I also like to work on just general

00:00:34,290 --> 00:00:37,950
parts of the Python SDK the admin

00:00:36,210 --> 00:00:40,230
console and I've done a bit of work on

00:00:37,950 --> 00:00:43,550
the new Python 2.7 runtime that we've

00:00:40,230 --> 00:00:46,500
announced on the platen mailing list

00:00:43,550 --> 00:00:47,910
quick thing about what app engine is app

00:00:46,500 --> 00:00:51,180
engines in the platform that allows

00:00:47,910 --> 00:00:52,800
developers so everyone in this room to

00:00:51,180 --> 00:00:54,930
run their web applications on Google

00:00:52,800 --> 00:00:56,489
Google infrastructure it's highly

00:00:54,930 --> 00:00:58,949
scalable so it scales out very well

00:00:56,489 --> 00:01:00,600
horizontally it supports running

00:00:58,949 --> 00:01:04,559
applications in Python so previously

00:01:00,600 --> 00:01:07,830
only 2.5 but now 2.7 java and go which

00:01:04,559 --> 00:01:10,340
was recently added at google i/o we have

00:01:07,830 --> 00:01:12,869
a key value data store so it's not SQL

00:01:10,340 --> 00:01:14,610
it's a lot becoming a lot more popular

00:01:12,869 --> 00:01:16,590
these days but back when we first

00:01:14,610 --> 00:01:19,350
launched it was something that was a bit

00:01:16,590 --> 00:01:21,030
different we have a large collection of

00:01:19,350 --> 00:01:23,000
api's and services that you can use so

00:01:21,030 --> 00:01:27,479
task queue which I actually work on

00:01:23,000 --> 00:01:30,509
allows you to defer task to work so

00:01:27,479 --> 00:01:32,490
that's not in the user serving path the

00:01:30,509 --> 00:01:33,930
channel API which allows you to do long

00:01:32,490 --> 00:01:35,869
push to users so they get instant

00:01:33,930 --> 00:01:40,110
notifications of events it uses the same

00:01:35,869 --> 00:01:43,290
structure as Google Talk xmpp which is a

00:01:40,110 --> 00:01:45,600
jabber it's with users as an actual

00:01:43,290 --> 00:01:47,250
application email memcache there are

00:01:45,600 --> 00:01:49,470
other AP is that I haven't gone into and

00:01:47,250 --> 00:01:52,200
another really important feature is that

00:01:49,470 --> 00:01:55,380
we actually have people who hold the

00:01:52,200 --> 00:01:57,390
pager 24-7 so there was actually talk

00:01:55,380 --> 00:01:59,310
about this at Google i/o life and after

00:01:57,390 --> 00:02:01,140
nation production the links therefore if

00:01:59,310 --> 00:02:04,700
you want to view the YouTube video later

00:02:01,140 --> 00:02:07,229
I recommend it as a really good talk so

00:02:04,700 --> 00:02:08,450
now enough about App Engine and me in

00:02:07,229 --> 00:02:09,979
particular what

00:02:08,450 --> 00:02:11,540
let's talk about it's going to Maine to

00:02:09,979 --> 00:02:12,620
be about asynchronous programming and

00:02:11,540 --> 00:02:15,800
how you can do asynchronous programming

00:02:12,620 --> 00:02:19,250
on App Engine and an integer quick

00:02:15,800 --> 00:02:21,680
introduction to pep 342 which is a new

00:02:19,250 --> 00:02:22,730
way to do things with actually using

00:02:21,680 --> 00:02:24,650
generator functions and how you can

00:02:22,730 --> 00:02:26,690
actually use that on App Engine to make

00:02:24,650 --> 00:02:30,769
things easier to write in a procedural

00:02:26,690 --> 00:02:32,510
way without having to use threads so

00:02:30,769 --> 00:02:34,580
what actually is asynchronous

00:02:32,510 --> 00:02:37,519
programming it's basically doing

00:02:34,580 --> 00:02:38,810
multiple things at the same time in the

00:02:37,519 --> 00:02:40,489
case of App Engine you may be fetching

00:02:38,810 --> 00:02:43,330
multiple records from data store you may

00:02:40,489 --> 00:02:45,709
be fetching data from wrote services etc

00:02:43,330 --> 00:02:48,019
the reason you actually want to do this

00:02:45,709 --> 00:02:49,400
is it makes things faster I'll actually

00:02:48,019 --> 00:02:51,709
have some examples later on where I'll

00:02:49,400 --> 00:02:53,959
show no it's a simple example of just

00:02:51,709 --> 00:02:55,370
fetching seven websites you can see how

00:02:53,959 --> 00:02:56,989
much faster it is to do this where you

00:02:55,370 --> 00:03:00,650
fetch all at the same time rather than

00:02:56,989 --> 00:03:02,750
do them synchronously so many different

00:03:00,650 --> 00:03:05,390
ways to do asynchronous programming we

00:03:02,750 --> 00:03:07,010
have threads as for frameworks for doing

00:03:05,390 --> 00:03:10,310
threads we now have the new futures

00:03:07,010 --> 00:03:11,599
pepper which is in Python 3.2 and I

00:03:10,310 --> 00:03:13,220
don't remember who it is but someone's

00:03:11,599 --> 00:03:17,180
back boarded it to the older versions of

00:03:13,220 --> 00:03:18,470
Python as well so 2.6 2.7 and generally

00:03:17,180 --> 00:03:19,700
with threads a lot of people just prefer

00:03:18,470 --> 00:03:22,489
to roll their own sort of framework

00:03:19,700 --> 00:03:25,190
around this you have the callback method

00:03:22,489 --> 00:03:28,340
of doing asynchronous program so twisted

00:03:25,190 --> 00:03:30,079
async call App Engine user RPC which I'm

00:03:28,340 --> 00:03:32,870
assuming most people probably haven't

00:03:30,079 --> 00:03:34,670
seen it's not a very well publicized API

00:03:32,870 --> 00:03:37,190
but it does allow you to do callback

00:03:34,670 --> 00:03:38,780
notifications on a pigeon green lens

00:03:37,190 --> 00:03:39,980
which is something that doesn't run on a

00:03:38,780 --> 00:03:42,139
pinch and I'll get into that a little

00:03:39,980 --> 00:03:44,000
bit later on and task alerts which is

00:03:42,139 --> 00:03:45,440
what I'll actually mainly be talking

00:03:44,000 --> 00:03:47,120
about so some of these frameworks that

00:03:45,440 --> 00:03:51,109
use that is G task alerts which is the

00:03:47,120 --> 00:03:55,000
gtk one and monocle and also NDP which

00:03:51,109 --> 00:04:00,550
I'll actually talking about so wow I

00:03:55,000 --> 00:04:03,650
broke that one good right

00:04:00,550 --> 00:04:11,710
see if I can if I should edit this slide

00:04:03,650 --> 00:04:15,230
live actually no I won so we're threads

00:04:11,710 --> 00:04:16,880
they're just here is a quick example of

00:04:15,230 --> 00:04:21,049
how you'd say fetch two different URLs

00:04:16,880 --> 00:04:23,600
with your with the futures library so

00:04:21,049 --> 00:04:26,480
you just all you need is some kind of

00:04:23,600 --> 00:04:28,760
function that you can map data into so

00:04:26,480 --> 00:04:30,800
in this particular example we have the

00:04:28,760 --> 00:04:32,540
executor here we pass up to the URL

00:04:30,800 --> 00:04:34,850
fetch method which just takes a URL

00:04:32,540 --> 00:04:36,500
because grabs the data synchronously and

00:04:34,850 --> 00:04:38,050
returns it to the user and you go

00:04:36,500 --> 00:04:40,580
through and you just print out that data

00:04:38,050 --> 00:04:43,640
the way that the this particular

00:04:40,580 --> 00:04:44,870
features library works is you specify

00:04:43,640 --> 00:04:46,670
how many workers you want to actually

00:04:44,870 --> 00:04:48,830
run simultaneously in this case I

00:04:46,670 --> 00:04:51,080
specified three so it would mean that

00:04:48,830 --> 00:04:53,510
both of these URL fetch calls are

00:04:51,080 --> 00:04:55,640
started at the beginning of the actual

00:04:53,510 --> 00:04:57,680
loop and then it waits and we'll return

00:04:55,640 --> 00:04:59,750
them the results back to you in the

00:04:57,680 --> 00:05:02,270
actual order so although some of the

00:04:59,750 --> 00:05:04,010
results the USA for example the second

00:05:02,270 --> 00:05:06,110
URL may be faster to return than the

00:05:04,010 --> 00:05:08,180
first you'll still get the back in the

00:05:06,110 --> 00:05:11,060
correct order but they will have

00:05:08,180 --> 00:05:15,460
executed at the same time unfortunately

00:05:11,060 --> 00:05:17,600
I've lost my callback example and

00:05:15,460 --> 00:05:20,680
actually I've lost the rest of the slide

00:05:17,600 --> 00:05:20,680
so I will have to edit it

00:05:29,760 --> 00:05:32,760
threads

00:05:37,810 --> 00:05:52,620
yep I broke that pretty good right sorry

00:05:50,350 --> 00:05:52,620
about this

00:06:01,400 --> 00:06:04,090
No

00:06:08,390 --> 00:06:13,610
right so with the callback method you

00:06:11,460 --> 00:06:16,650
generally actually go about it you

00:06:13,610 --> 00:06:18,570
define the what you actually want to

00:06:16,650 --> 00:06:20,430
happen when the resultant so you do the

00:06:18,570 --> 00:06:22,260
URL fetch you define what you want to

00:06:20,430 --> 00:06:26,040
happen when the URL fetch comes back and

00:06:22,260 --> 00:06:27,750
then you have to pass that into the RPC

00:06:26,040 --> 00:06:31,170
object when you actually create it and

00:06:27,750 --> 00:06:33,090
so what actually happens is you

00:06:31,170 --> 00:06:35,430
effectively have to define your code

00:06:33,090 --> 00:06:37,740
that deals with the return value of what

00:06:35,430 --> 00:06:38,910
you're writing before you actually do

00:06:37,740 --> 00:06:42,150
the call that makes the connection to

00:06:38,910 --> 00:06:46,920
the world my web server so that was

00:06:42,150 --> 00:06:51,840
callbacks the next one that we went onto

00:06:46,920 --> 00:06:54,000
is Greenland's Greenland's is works in

00:06:51,840 --> 00:06:56,190
the way how Ruby works is also based on

00:06:54,000 --> 00:06:58,410
the code that was in stakus python and

00:06:56,190 --> 00:07:02,220
says see extension module for python

00:06:58,410 --> 00:07:06,120
that maps multiple what they call green

00:07:02,220 --> 00:07:10,770
lights onto a single OS thread and that

00:07:06,120 --> 00:07:12,780
actually allows you to get this the same

00:07:10,770 --> 00:07:15,810
kind of code as using task alerts etc

00:07:12,780 --> 00:07:17,820
you right synchronous program and it

00:07:15,810 --> 00:07:20,790
will go through and actually execute

00:07:17,820 --> 00:07:24,480
that it won't work on a pinch because it

00:07:20,790 --> 00:07:25,890
requires a custom see module to do and

00:07:24,480 --> 00:07:28,830
task list which is actually what I

00:07:25,890 --> 00:07:31,280
wanted to get into is done using the

00:07:28,830 --> 00:07:31,280
yield statement

00:07:35,440 --> 00:07:48,409
yeah that's probably a good idea

00:07:37,849 --> 00:07:52,639
actually I just tried that no I broken

00:07:48,409 --> 00:07:57,729
the HTML worked every other time except

00:07:52,639 --> 00:08:01,940
for now alright so I'm not sure I bump

00:07:57,729 --> 00:08:07,190
this up so this is an example of what a

00:08:01,940 --> 00:08:10,219
green looks like on using a green light

00:08:07,190 --> 00:08:12,379
in Python so you import as custom URL

00:08:10,219 --> 00:08:14,750
into module which is actually has the

00:08:12,379 --> 00:08:17,180
URL it has the green LED functionality

00:08:14,750 --> 00:08:20,449
you construct a pool and you go through

00:08:17,180 --> 00:08:23,110
and actually just map over there the

00:08:20,449 --> 00:08:25,310
same way you do with the futures library

00:08:23,110 --> 00:08:31,520
Pascal it's is where things become

00:08:25,310 --> 00:08:33,279
interesting so I'm just going to there's

00:08:31,520 --> 00:08:35,690
a function here make fetch call it's

00:08:33,279 --> 00:08:38,690
unfortunately to work around a bug i

00:08:35,690 --> 00:08:42,770
found in the python asynchronous URL

00:08:38,690 --> 00:08:44,690
fetch library so yeah I'll just kind of

00:08:42,770 --> 00:08:46,790
treat that as if it's the URL fetch call

00:08:44,690 --> 00:08:53,620
function so the way how you actually

00:08:46,790 --> 00:08:55,970
work with task alerts is you define a

00:08:53,620 --> 00:08:57,920
you use this generator sorry this

00:08:55,970 --> 00:09:00,770
decorate function over the function and

00:08:57,920 --> 00:09:04,430
you go through and you use yield so you

00:09:00,770 --> 00:09:05,630
yield a call you yield a future and it

00:09:04,430 --> 00:09:07,339
will come back and actually call this

00:09:05,630 --> 00:09:09,920
code later on so as you can see this

00:09:07,339 --> 00:09:12,589
here actually does you asynchronous URL

00:09:09,920 --> 00:09:14,329
fetch it goes through it constructs

00:09:12,589 --> 00:09:20,930
multiple of these goes from waits for

00:09:14,329 --> 00:09:23,089
the event loop to finish and then it

00:09:20,930 --> 00:09:24,230
will print out the return code after

00:09:23,089 --> 00:09:26,449
it's actually finished so it has the

00:09:24,230 --> 00:09:28,970
nice property that unlike callbacks you

00:09:26,449 --> 00:09:30,529
don't have to define the code that you

00:09:28,970 --> 00:09:32,870
deal with you know after the operations

00:09:30,529 --> 00:09:36,380
finished before you've actually made the

00:09:32,870 --> 00:09:38,899
connection so I just quickly digress

00:09:36,380 --> 00:09:40,440
into that particular bit of syntax I

00:09:38,899 --> 00:09:42,870
showed you where you have the

00:09:40,440 --> 00:09:47,460
yield statement so you can actually see

00:09:42,870 --> 00:09:49,770
here most people don't know that you'll

00:09:47,460 --> 00:09:53,460
actually returns a value so as of python

00:09:49,770 --> 00:09:55,080
2.5 when they implemented this pen yield

00:09:53,460 --> 00:09:59,940
is no longer a statement it's now an

00:09:55,080 --> 00:10:02,070
expression and the actually has some

00:09:59,940 --> 00:10:08,070
nice properties so it means that you can

00:10:02,070 --> 00:10:10,110
now write generators that not just give

00:10:08,070 --> 00:10:12,150
output they actually also take input and

00:10:10,110 --> 00:10:13,950
so it allows you to write nice pipelines

00:10:12,150 --> 00:10:16,440
before this you actually had to write

00:10:13,950 --> 00:10:19,710
them in Reverse where effectively you

00:10:16,440 --> 00:10:21,870
build the chain of generators in Reverse

00:10:19,710 --> 00:10:23,130
where the output would go to so the

00:10:21,870 --> 00:10:29,390
input would go to the output of the

00:10:23,130 --> 00:10:32,160
previous one it's quite horrible hack so

00:10:29,390 --> 00:10:34,440
this particular piece of code goes

00:10:32,160 --> 00:10:36,900
through and it's fairly simple takes a

00:10:34,440 --> 00:10:39,000
start and just go through and decrements

00:10:36,900 --> 00:10:42,750
the number by whatever value is actually

00:10:39,000 --> 00:10:45,330
passed into the generator now how does

00:10:42,750 --> 00:10:48,750
that actually work generators now have

00:10:45,330 --> 00:10:51,210
two so I have three new functions added

00:10:48,750 --> 00:10:54,000
to them that is the send method the

00:10:51,210 --> 00:10:56,130
throw method and the close method the

00:10:54,000 --> 00:10:58,140
send method is equipped sorry the next

00:10:56,130 --> 00:10:59,970
method which already existed on them is

00:10:58,140 --> 00:11:01,950
equivalent to send with the value of

00:10:59,970 --> 00:11:05,130
none so the previous code continues to

00:11:01,950 --> 00:11:07,140
work through does what you expect you

00:11:05,130 --> 00:11:09,690
pass it in an exception object the trace

00:11:07,140 --> 00:11:11,460
back and it will actually throw at the

00:11:09,690 --> 00:11:12,330
point the raise that exception at the

00:11:11,460 --> 00:11:15,270
point that the yield statement

00:11:12,330 --> 00:11:16,920
previously yielded and then you also

00:11:15,270 --> 00:11:18,600
have clothes which allows you to clean

00:11:16,920 --> 00:11:20,580
up a generator before it's actually

00:11:18,600 --> 00:11:23,250
finished so it you can perfectly asked a

00:11:20,580 --> 00:11:31,380
generator to finish running so I'll grab

00:11:23,250 --> 00:11:38,610
this section of code and I will actually

00:11:31,380 --> 00:11:39,930
run it so I have just a copy of the

00:11:38,610 --> 00:11:43,740
development console running on App

00:11:39,930 --> 00:11:44,700
Engine and I'll actually make that great

00:11:43,740 --> 00:11:50,640
then

00:11:44,700 --> 00:11:54,180
and here is not a very pretty piece of

00:11:50,640 --> 00:11:56,880
code it goes through it starts the

00:11:54,180 --> 00:11:58,110
actual generator so you can't call send

00:11:56,880 --> 00:12:00,420
immediately on a generator you actually

00:11:58,110 --> 00:12:02,610
have to wait one iteration for it so you

00:12:00,420 --> 00:12:05,580
have to just call next to actually start

00:12:02,610 --> 00:12:07,860
the generator executing and then you can

00:12:05,580 --> 00:12:09,360
go through and you in this particular

00:12:07,860 --> 00:12:10,950
case i'm going to decrement a bite to

00:12:09,360 --> 00:12:12,900
every time you go through and you just

00:12:10,950 --> 00:12:21,930
print the output so i will show you what

00:12:12,900 --> 00:12:24,990
that looks like alright so as you expect

00:12:21,930 --> 00:12:27,000
a very small font but it just goes

00:12:24,990 --> 00:12:31,620
through it prints out eight six four and

00:12:27,000 --> 00:12:32,850
two so it works quite nicely so it's

00:12:31,620 --> 00:12:36,800
sort of enough of the actual

00:12:32,850 --> 00:12:36,800
nitty-gritty implementation details of

00:12:37,070 --> 00:12:43,530
how that new pep works what does it

00:12:39,780 --> 00:12:46,890
actually do for us so with I'm actually

00:12:43,530 --> 00:12:49,320
going to use the ndb's tasket library

00:12:46,890 --> 00:12:51,900
here and what it actually allows you to

00:12:49,320 --> 00:12:56,910
do is if you wrap your function with the

00:12:51,900 --> 00:13:00,630
this task task alert function it will

00:12:56,910 --> 00:13:02,460
allow you to write a generator you

00:13:00,630 --> 00:13:03,810
actually use this pep and it will

00:13:02,460 --> 00:13:05,580
automatically Prime your function by

00:13:03,810 --> 00:13:07,020
that I mean it will call it that first

00:13:05,580 --> 00:13:10,560
neck so that your code actually gets to

00:13:07,020 --> 00:13:12,330
Jen actually execute some code in

00:13:10,560 --> 00:13:13,890
particular this library is quite nice so

00:13:12,330 --> 00:13:16,530
you've seen it before where you can just

00:13:13,890 --> 00:13:18,660
yield a single function a return some

00:13:16,530 --> 00:13:20,850
kind of future and that will wait until

00:13:18,660 --> 00:13:23,760
that actually has finished return the

00:13:20,850 --> 00:13:25,440
result for you you can return you can

00:13:23,760 --> 00:13:27,780
actually yield two different

00:13:25,440 --> 00:13:30,210
asynchronous functions here and what

00:13:27,780 --> 00:13:31,620
that actually allows you to do is wait

00:13:30,210 --> 00:13:33,240
until both of these asynchronous

00:13:31,620 --> 00:13:35,040
functions of occurred so that if you see

00:13:33,240 --> 00:13:36,600
need three pieces of data from three

00:13:35,040 --> 00:13:37,740
different services you can wait for all

00:13:36,600 --> 00:13:39,570
of them to be ready before you actually

00:13:37,740 --> 00:13:40,500
start running your code on it while

00:13:39,570 --> 00:13:44,190
you're waiting for other things to

00:13:40,500 --> 00:13:46,710
execute and this also goes on to accept

00:13:44,190 --> 00:13:48,000
a list of asynchronous function so if

00:13:46,710 --> 00:13:49,110
you don't know how many things you're

00:13:48,000 --> 00:13:50,310
waiting for all you can actually just

00:13:49,110 --> 00:13:53,010
generate

00:13:50,310 --> 00:13:57,750
of the mountain at runtime and then wait

00:13:53,010 --> 00:14:00,450
for them all to finish so one

00:13:57,750 --> 00:14:04,500
interesting thing about having about

00:14:00,450 --> 00:14:08,130
this pet though is that generators can't

00:14:04,500 --> 00:14:10,260
use the return statement so how do you

00:14:08,130 --> 00:14:14,520
actually return a value from one of

00:14:10,260 --> 00:14:17,460
these task quads and at the moment the

00:14:14,520 --> 00:14:19,560
only way to actually do that just and

00:14:17,460 --> 00:14:22,470
done that again the only way to actually

00:14:19,560 --> 00:14:26,670
return to value from it is to raise this

00:14:22,470 --> 00:14:27,990
special error task what return actually

00:14:26,670 --> 00:14:30,060
in this particular case task forgot

00:14:27,990 --> 00:14:31,920
return is stop iteration it's just

00:14:30,060 --> 00:14:33,029
mapped to a nicer name so that it

00:14:31,920 --> 00:14:37,380
actually makes sense when you're reading

00:14:33,029 --> 00:14:40,040
the code Peppa 380 is about actually

00:14:37,380 --> 00:14:43,260
enhancing this generator support further

00:14:40,040 --> 00:14:46,320
it will adds new syntax to allow you to

00:14:43,260 --> 00:14:48,360
yield all the contents of a generator as

00:14:46,320 --> 00:14:51,570
if you were doing it it also adds the

00:14:48,360 --> 00:14:53,250
nice feature that this sort of horrible

00:14:51,570 --> 00:14:55,500
piece of syntax can go away and you can

00:14:53,250 --> 00:14:57,240
actually just return the length of the

00:14:55,500 --> 00:15:00,510
result as you would in any other North

00:14:57,240 --> 00:15:05,880
normal path and code so it makes code a

00:15:00,510 --> 00:15:08,730
lot cleaner so this has been a very

00:15:05,880 --> 00:15:10,800
brief overview of the NDB library in

00:15:08,730 --> 00:15:13,680
general but in the previous example I

00:15:10,800 --> 00:15:17,490
showed you it actually went through and

00:15:13,680 --> 00:15:19,050
used event loop dot run it's not very

00:15:17,490 --> 00:15:21,330
easy to use on App Engine winter when

00:15:19,050 --> 00:15:23,520
it's a web framework that comes in and

00:15:21,330 --> 00:15:26,400
actually calls your individual requests

00:15:23,520 --> 00:15:27,990
so how you actually go about using it on

00:15:26,400 --> 00:15:31,589
App Engine is something that's quite

00:15:27,990 --> 00:15:33,900
interesting this here is just a example

00:15:31,589 --> 00:15:37,980
of how you do a collection of URL

00:15:33,900 --> 00:15:39,120
fetches with the synchronous API in this

00:15:37,980 --> 00:15:40,980
particular case I want to go through on

00:15:39,120 --> 00:15:43,170
time how long each individual page takes

00:15:40,980 --> 00:15:45,750
to load so we go through it's your own

00:15:43,170 --> 00:15:47,640
we grab the time of the start make the

00:15:45,750 --> 00:15:49,589
synchronous fetch time at the end and

00:15:47,640 --> 00:15:51,630
just dump it into a dictionary so I can

00:15:49,589 --> 00:15:54,930
render it using the Django templating

00:15:51,630 --> 00:15:59,370
engine so that particular code is fairly

00:15:54,930 --> 00:16:01,230
easy and that one I already have a copy

00:15:59,370 --> 00:16:04,410
of it running so

00:16:01,230 --> 00:16:05,460
as you notice it's currently welding at

00:16:04,410 --> 00:16:07,260
the moment it takes a little bit of time

00:16:05,460 --> 00:16:09,330
to actually do so all of them finish

00:16:07,260 --> 00:16:10,620
successfully and some of them can

00:16:09,330 --> 00:16:12,960
actually take quite a while to load so

00:16:10,620 --> 00:16:14,460
in the case of ebay takes about a second

00:16:12,960 --> 00:16:16,890
Lynn to compare you also takes about a

00:16:14,460 --> 00:16:21,390
second so that's actually why it took so

00:16:16,890 --> 00:16:22,770
long if we actually look at so we

00:16:21,390 --> 00:16:26,040
actually look at what those are pieces

00:16:22,770 --> 00:16:28,410
look like in a nice graph we can

00:16:26,040 --> 00:16:29,550
actually see here that you know this is

00:16:28,410 --> 00:16:31,740
why it's actually taking to each

00:16:29,550 --> 00:16:34,770
individual requests we make we can't

00:16:31,740 --> 00:16:36,030
start the previous one before it

00:16:34,770 --> 00:16:37,230
actually suggests people who are

00:16:36,030 --> 00:16:40,650
developing on App Engine to look at this

00:16:37,230 --> 00:16:42,270
tool tha's appstats in this particular

00:16:40,650 --> 00:16:44,460
case is very obvious what's happening

00:16:42,270 --> 00:16:46,710
because you saw me do the URL fetch and

00:16:44,460 --> 00:16:48,330
loop this here can help you debug and

00:16:46,710 --> 00:16:53,160
find performance issues in your actual

00:16:48,330 --> 00:16:56,610
code so we'll go back and if we'd now

00:16:53,160 --> 00:16:58,200
try and do the the same code with nbb

00:16:56,610 --> 00:17:00,750
it's actually a little bit more

00:16:58,200 --> 00:17:03,630
complicated we have this new decorator

00:17:00,750 --> 00:17:05,700
that we're using context top-level you

00:17:03,630 --> 00:17:07,500
use that to actually wrap the the get

00:17:05,700 --> 00:17:10,020
method of the web framework that you're

00:17:07,500 --> 00:17:11,790
using in particular I'm using web app

00:17:10,020 --> 00:17:15,990
one here just because it comes to part

00:17:11,790 --> 00:17:17,040
of our pension i'm using the thing i was

00:17:15,990 --> 00:17:19,890
talking about before we can just

00:17:17,040 --> 00:17:21,990
generate a list of all the sort of

00:17:19,890 --> 00:17:24,120
features that you want to actually be to

00:17:21,990 --> 00:17:27,360
wait on and this here will wait for all

00:17:24,120 --> 00:17:28,590
of the fetches to actually finish but

00:17:27,360 --> 00:17:30,150
because i actually wanted to measure the

00:17:28,590 --> 00:17:32,040
start and end time before each of the

00:17:30,150 --> 00:17:33,420
individual requests I actually had to

00:17:32,040 --> 00:17:36,270
write a separate function up the top

00:17:33,420 --> 00:17:38,250
here where it goes through and it does

00:17:36,270 --> 00:17:41,310
the same thing that you saw before we

00:17:38,250 --> 00:17:44,010
grab the time the start we create the

00:17:41,310 --> 00:17:46,320
actual fetch a singer asar pc and then

00:17:44,010 --> 00:17:48,750
we use yield to actually cause this

00:17:46,320 --> 00:17:51,690
particular bit of code to be suspended

00:17:48,750 --> 00:17:54,120
until that URL data until the data from

00:17:51,690 --> 00:17:55,890
that fetch has actually been finished so

00:17:54,120 --> 00:17:59,640
we go through here and we start off all

00:17:55,890 --> 00:18:01,680
seven our pcs and we each one of these

00:17:59,640 --> 00:18:03,870
wait until that our pcs actually

00:18:01,680 --> 00:18:06,630
completed we can measure the time still

00:18:03,870 --> 00:18:09,380
accurately and then we still render the

00:18:06,630 --> 00:18:11,330
template as we did before so if

00:18:09,380 --> 00:18:17,660
look good if we actually run this one

00:18:11,330 --> 00:18:19,370
now you'll see that the page itself took

00:18:17,660 --> 00:18:21,440
much was much quicker to load and

00:18:19,370 --> 00:18:24,440
actually all of the times are roughly

00:18:21,440 --> 00:18:26,300
equivalent with the you know linux

00:18:24,440 --> 00:18:30,650
confit you only being at point 2 of a

00:18:26,300 --> 00:18:34,340
second faster so if we have a look at

00:18:30,650 --> 00:18:37,070
what that looks like now in the system

00:18:34,340 --> 00:18:39,500
you can actually see that although we

00:18:37,070 --> 00:18:42,410
still spent a total of three point two

00:18:39,500 --> 00:18:45,140
seconds waiting for our pcs in total the

00:18:42,410 --> 00:18:47,480
final request happened in just over a

00:18:45,140 --> 00:18:48,950
second because the longest requests that

00:18:47,480 --> 00:18:50,870
we're waiting for was also just over a

00:18:48,950 --> 00:18:57,530
second so you can get significance

00:18:50,870 --> 00:18:59,600
performance increases with this and

00:18:57,530 --> 00:19:02,780
that's actually the two examples that I

00:18:59,600 --> 00:19:05,510
gave them while all the examples I've

00:19:02,780 --> 00:19:09,590
actually given here a specific have been

00:19:05,510 --> 00:19:13,370
URL fetch NDB actually adds a nice new

00:19:09,590 --> 00:19:15,350
database abstraction layer but as I will

00:19:13,370 --> 00:19:17,630
show you when I give you the links it's

00:19:15,350 --> 00:19:19,700
considered an experimental API there are

00:19:17,630 --> 00:19:21,440
quite a few rough edges in it still but

00:19:19,700 --> 00:19:23,450
if you're developing a new Python App

00:19:21,440 --> 00:19:24,890
Engine application i really suggest you

00:19:23,450 --> 00:19:27,710
look at this as opposed to the current

00:19:24,890 --> 00:19:30,260
DB implementation we have its much nice

00:19:27,710 --> 00:19:31,400
of being a synchronous also doesn't have

00:19:30,260 --> 00:19:36,050
a lot of the pitfalls that the current

00:19:31,400 --> 00:19:39,340
AP others do and I suppose that's it

00:19:36,050 --> 00:19:39,340
unless I have questions

00:19:45,830 --> 00:19:51,830
okay do we have any question dude do we

00:19:49,230 --> 00:19:51,830
have any questions

00:19:56,540 --> 00:20:01,410
I'm firing off a bunch of tasks which

00:19:59,490 --> 00:20:03,540
take too long to wait in the request

00:20:01,410 --> 00:20:06,059
I've actually got hundreds of them yep

00:20:03,540 --> 00:20:08,670
and I want to do something when all of

00:20:06,059 --> 00:20:10,710
them have completed and see an API to

00:20:08,670 --> 00:20:14,610
tell me how many tasks I've got

00:20:10,710 --> 00:20:16,380
outstanding don't think there's a

00:20:14,610 --> 00:20:20,760
existing bug about that at the moment

00:20:16,380 --> 00:20:22,500
there we are looking into Brad a way to

00:20:20,760 --> 00:20:24,540
approximate that but not actually give

00:20:22,500 --> 00:20:26,160
it an exact answer on how many tasks are

00:20:24,540 --> 00:20:27,480
if you want more about that if you

00:20:26,160 --> 00:20:29,280
actually can't grab me afterwards I can

00:20:27,480 --> 00:20:33,960
go into why I have a follow-up question

00:20:29,280 --> 00:20:36,750
yet what happened on Friday read the

00:20:33,960 --> 00:20:38,400
downtime notification list that says

00:20:36,750 --> 00:20:43,500
that all I'm allowed to say at the

00:20:38,400 --> 00:20:48,150
moment and migrate to HR if you migrate

00:20:43,500 --> 00:20:49,350
to HR you won't see that HR is high

00:20:48,150 --> 00:20:51,780
replicate the high replication datastore

00:20:49,350 --> 00:20:53,580
for those of you who are not very

00:20:51,780 --> 00:20:57,450
familiar with that pension it's

00:20:53,580 --> 00:21:02,300
something we launched actually probably

00:20:57,450 --> 00:21:04,800
quite a bit ago now and it is based on

00:21:02,300 --> 00:21:08,460
yeah I'll keep talking while you're

00:21:04,800 --> 00:21:11,220
going up it's based on the mega store

00:21:08,460 --> 00:21:13,350
and pack those algorithms that's

00:21:11,220 --> 00:21:16,460
actually detailed in the white paper and

00:21:13,350 --> 00:21:18,450
it talks about how we use multiple

00:21:16,460 --> 00:21:26,280
geographically distinct places to

00:21:18,450 --> 00:21:29,940
actually protect the data so yes I my

00:21:26,280 --> 00:21:33,360
questions does this some does this help

00:21:29,940 --> 00:21:37,350
you in terms of maybe rights to the data

00:21:33,360 --> 00:21:38,940
store overcoming like a problem of if

00:21:37,350 --> 00:21:42,210
you're doing too many rights you get

00:21:38,940 --> 00:21:45,030
contention or you and know the

00:21:42,210 --> 00:21:47,160
particular issue with contention with

00:21:45,030 --> 00:21:49,650
data store rights is not actually in

00:21:47,160 --> 00:21:52,260
your application code it's actually down

00:21:49,650 --> 00:21:53,610
at the datastore layer if you have a

00:21:52,260 --> 00:21:56,490
look at that pack sauce white paper

00:21:53,610 --> 00:21:58,740
explains why that is the case okay so

00:21:56,490 --> 00:22:01,260
even just for example fanning out

00:21:58,740 --> 00:22:01,590
several rights in different sessions and

00:22:01,260 --> 00:22:04,350
kind

00:22:01,590 --> 00:22:07,169
that's necessarily overcome an issue

00:22:04,350 --> 00:22:08,850
upload yeah so the actual thing that you

00:22:07,169 --> 00:22:10,289
want to do to overcome this is not

00:22:08,850 --> 00:22:13,230
actually found out you want to fan in

00:22:10,289 --> 00:22:16,559
your rights so is so one commits for

00:22:13,230 --> 00:22:19,110
multiple yeah yeah you want to train you

00:22:16,559 --> 00:22:20,610
know this is actually a fairly good

00:22:19,110 --> 00:22:22,380
example for pool cues which all the kind

00:22:20,610 --> 00:22:25,409
of devote plug for you know you can

00:22:22,380 --> 00:22:26,549
write ten different bits of information

00:22:25,409 --> 00:22:27,960
there that you want to update in

00:22:26,549 --> 00:22:29,730
datastore and then you can go through

00:22:27,960 --> 00:22:31,890
and have some asynchronous process that

00:22:29,730 --> 00:22:34,470
grabs these 10 records merges them in

00:22:31,890 --> 00:22:36,630
you know whatever application logic it

00:22:34,470 --> 00:22:42,140
means and then do a single right rather

00:22:36,630 --> 00:22:42,140
than 10 rights I see right thank you

00:22:49,020 --> 00:22:57,970
any other questions if people are

00:22:55,030 --> 00:22:59,350
interested in this or App Engine things

00:22:57,970 --> 00:23:01,480
and particular App Engine things in

00:22:59,350 --> 00:23:04,450
general feel free to see me sort of for

00:23:01,480 --> 00:23:08,770
the rest of the conference and my email

00:23:04,450 --> 00:23:11,650
is all the way the side of the slide wit

00:23:08,770 --> 00:23:14,190
they actually work alright well thank

00:23:11,650 --> 00:23:14,190

YouTube URL: https://www.youtube.com/watch?v=BMiCnYR8YYc


