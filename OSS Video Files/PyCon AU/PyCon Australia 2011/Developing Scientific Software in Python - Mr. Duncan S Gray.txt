Title: Developing Scientific Software in Python - Mr. Duncan S Gray
Publication date: 2011-08-22
Playlist: PyCon Australia 2011
Description: 
	This presentation will outline key lessons learnt in developing scientific software in 
Python. Methods of maintaining and assuring code quality will be discussed, in particular:
 -     designing effective unit tests;
 -     visualising output data to discover defects; and
 -     designing characterisation tests to test the actual system behaviour and to 
       identify unintended system changes.
Captions: 
	00:00:00,000 --> 00:00:07,490
Thanks okay so i'll be talking about

00:00:02,540 --> 00:00:10,590
developing scientific software in python

00:00:07,490 --> 00:00:12,269
so what is Geoscience Australia it's a

00:00:10,590 --> 00:00:16,830
government agency and there's a

00:00:12,269 --> 00:00:19,109
photograph of it there and we do a lot

00:00:16,830 --> 00:00:21,449
of things such as producing maps and

00:00:19,109 --> 00:00:26,640
doing a pre-competitive mineral

00:00:21,449 --> 00:00:29,490
exploration the area that I work in is

00:00:26,640 --> 00:00:33,360
doing is its modeling risks from natural

00:00:29,490 --> 00:00:36,570
hazards so things like inundation or

00:00:33,360 --> 00:00:44,219
storm surges or looking at risk to

00:00:36,570 --> 00:00:47,780
Australia due to arm earthquakes so two

00:00:44,219 --> 00:00:51,600
of the models that I've worked on an

00:00:47,780 --> 00:00:55,739
inundation model called anuga and also

00:00:51,600 --> 00:00:57,840
an earthquake model called erm so these

00:00:55,739 --> 00:00:59,129
there's a lot of simulated like

00:00:57,840 --> 00:01:00,059
obviously they're modeling different

00:00:59,129 --> 00:01:02,780
hazards but there's a lot of

00:01:00,059 --> 00:01:06,750
similarities between the underlying arm

00:01:02,780 --> 00:01:09,299
code itself so both models are open

00:01:06,750 --> 00:01:11,070
source and both models are written in

00:01:09,299 --> 00:01:14,820
Python with sections of the models

00:01:11,070 --> 00:01:18,810
written in C both models have also been

00:01:14,820 --> 00:01:23,159
paralyzed so they run on arm linux

00:01:18,810 --> 00:01:26,520
clusters and the both models I don't

00:01:23,159 --> 00:01:29,430
have any graphical user interface so you

00:01:26,520 --> 00:01:36,229
write a Python Python script to run

00:01:29,430 --> 00:01:36,229
these models oops

00:01:36,640 --> 00:01:40,390
okay so might wonder why would a

00:01:38,590 --> 00:01:42,190
scientific organization been using be

00:01:40,390 --> 00:01:46,140
using Python especially for doing

00:01:42,190 --> 00:01:48,940
simulations for simulations their arm

00:01:46,140 --> 00:01:52,030
time-intensive and but pythons and

00:01:48,940 --> 00:01:56,729
interpreted language I've got a photo

00:01:52,030 --> 00:02:00,250
there of um a happy-looking scientist so

00:01:56,729 --> 00:02:03,190
what makes scientists happy so when they

00:02:00,250 --> 00:02:04,840
can come up with an idea and they can

00:02:03,190 --> 00:02:06,790
get that if they're working with

00:02:04,840 --> 00:02:08,890
simulation software with and can get

00:02:06,790 --> 00:02:11,770
that idea implemented and get the

00:02:08,890 --> 00:02:13,480
results quickly so even though the

00:02:11,770 --> 00:02:15,430
actual program might run a bit slower

00:02:13,480 --> 00:02:18,970
because it's not written in Fortran or

00:02:15,430 --> 00:02:22,209
see it's actually easy to code in and

00:02:18,970 --> 00:02:24,010
also isn't there are like a lot of

00:02:22,209 --> 00:02:25,780
software developers at Geoscience

00:02:24,010 --> 00:02:27,190
Australia but also there's a lot of

00:02:25,780 --> 00:02:30,940
those scientists to actually write

00:02:27,190 --> 00:02:32,440
writing code so because it's easy to

00:02:30,940 --> 00:02:34,709
code in and all the things that we love

00:02:32,440 --> 00:02:38,260
about Python the scientists love as well

00:02:34,709 --> 00:02:41,140
there's good documentation also there's

00:02:38,260 --> 00:02:43,000
a lot of packages that are scientific

00:02:41,140 --> 00:02:45,040
packages so it's got the building box

00:02:43,000 --> 00:02:48,850
that building blocks that they can use

00:02:45,040 --> 00:02:50,620
to get results quickly also there's no

00:02:48,850 --> 00:02:53,230
license management with Python as you

00:02:50,620 --> 00:02:57,579
know so another scientific software

00:02:53,230 --> 00:03:02,980
called matlab that does require licenses

00:02:57,579 --> 00:03:05,950
and that can be a bit of a hassle ok

00:03:02,980 --> 00:03:09,790
here's here's an example this is output

00:03:05,950 --> 00:03:12,630
that Geoscience Australia is produced so

00:03:09,790 --> 00:03:14,980
what this is showing is the annual loss

00:03:12,630 --> 00:03:18,160
due to earthquakes is a percentage of

00:03:14,980 --> 00:03:22,600
total suburban value for suburbs in the

00:03:18,160 --> 00:03:24,700
perth region so it's complex output and

00:03:22,600 --> 00:03:27,310
to get something like this there's a lot

00:03:24,700 --> 00:03:29,560
of complex steps like we have to develop

00:03:27,310 --> 00:03:31,720
a set of synthetic earthquakes

00:03:29,560 --> 00:03:34,570
representing like the earthquakes over a

00:03:31,720 --> 00:03:36,160
500 year period for example and we have

00:03:34,570 --> 00:03:38,049
to work out the ground shaking and all

00:03:36,160 --> 00:03:40,150
the houses do to those earthquakes then

00:03:38,049 --> 00:03:41,650
we have to work out the damage to the

00:03:40,150 --> 00:03:44,200
house and then how much each to that

00:03:41,650 --> 00:03:46,750
what that damage would cost and then

00:03:44,200 --> 00:03:49,880
aggregated all that information so we

00:03:46,750 --> 00:03:52,770
get and we produce something like this

00:03:49,880 --> 00:03:55,080
so say with this result if this area

00:03:52,770 --> 00:03:58,950
here was instead of being that yellow

00:03:55,080 --> 00:04:02,520
color was maybe that brown color okay

00:03:58,950 --> 00:04:04,080
the scientists that produced the who

00:04:02,520 --> 00:04:07,560
came up with the models that produces

00:04:04,080 --> 00:04:09,300
output if this area here is brown and

00:04:07,560 --> 00:04:10,650
they look at this output then I'm going

00:04:09,300 --> 00:04:12,000
to know oh I don't think there's anybody

00:04:10,650 --> 00:04:15,120
in the world would be able to look at

00:04:12,000 --> 00:04:17,370
this result and say this isn't right

00:04:15,120 --> 00:04:19,560
there's a bug in the code so as a

00:04:17,370 --> 00:04:21,510
software developer it's a bit of a

00:04:19,560 --> 00:04:23,810
problem if you can write something and

00:04:21,510 --> 00:04:26,640
then get output and you can't actually

00:04:23,810 --> 00:04:29,669
tell that the output is armed or that

00:04:26,640 --> 00:04:31,950
there's a problem in the output so the

00:04:29,669 --> 00:04:34,530
quality assurance at the end product is

00:04:31,950 --> 00:04:39,060
difficult to impossible depending on the

00:04:34,530 --> 00:04:40,950
complexity of the output so what what do

00:04:39,060 --> 00:04:44,460
we but obviously we want to produce

00:04:40,950 --> 00:04:47,310
output that we believe is correct so

00:04:44,460 --> 00:04:49,260
what can we what steps do we take to

00:04:47,310 --> 00:04:52,889
make sure the quality or the quality of

00:04:49,260 --> 00:04:56,400
the code is high and so i'll be talking

00:04:52,889 --> 00:04:59,190
a bit about that so I think the

00:04:56,400 --> 00:05:03,930
foundation for it is i'm having good

00:04:59,190 --> 00:05:05,370
unit tests so with i'm sort of english

00:05:03,930 --> 00:05:08,370
doing that you know about unit tests but

00:05:05,370 --> 00:05:10,140
i'll talk about what makes a good unit

00:05:08,370 --> 00:05:14,789
test so you want new tests that can

00:05:10,140 --> 00:05:15,930
isolate problems and so when your unit

00:05:14,789 --> 00:05:17,820
tests fail you want to be able to

00:05:15,930 --> 00:05:20,460
quickly understand why that unit test is

00:05:17,820 --> 00:05:24,330
failing so you want to discover a small

00:05:20,460 --> 00:05:29,130
section of code unit tests can also be

00:05:24,330 --> 00:05:30,990
good for arm sort of augmenting or

00:05:29,130 --> 00:05:34,770
explaining function so you've got the

00:05:30,990 --> 00:05:36,210
comments good unit tests can also help

00:05:34,770 --> 00:05:39,210
in understanding what codes should be

00:05:36,210 --> 00:05:41,789
doing by seeing what what the input can

00:05:39,210 --> 00:05:45,000
be and what the upward should be also

00:05:41,789 --> 00:05:48,620
unit tests should run fast so you want

00:05:45,000 --> 00:05:50,760
developers when they refactor code or

00:05:48,620 --> 00:05:52,080
when they when they're adding new

00:05:50,760 --> 00:05:54,720
sections of clothes you want them to be

00:05:52,080 --> 00:05:56,760
running your unit tests continuously so

00:05:54,720 --> 00:05:59,070
you want the unit tests to be able to

00:05:56,760 --> 00:06:01,530
run quickly so I run it more often so

00:05:59,070 --> 00:06:03,150
the able to find out if they've broken

00:06:01,530 --> 00:06:04,680
sections of the code quicker

00:06:03,150 --> 00:06:06,270
and also you want all your unit tests to

00:06:04,680 --> 00:06:09,510
be automated so you want to be able to

00:06:06,270 --> 00:06:15,320
just run one command and all your unit

00:06:09,510 --> 00:06:18,060
tests will run okay so this is a sort of

00:06:15,320 --> 00:06:21,590
it's a fake example but it's example of

00:06:18,060 --> 00:06:23,550
a good unit test so you've got some

00:06:21,590 --> 00:06:26,910
comments they're saying what you think

00:06:23,550 --> 00:06:31,470
you're testing and you've got input and

00:06:26,910 --> 00:06:34,800
output so if the function or if a unit

00:06:31,470 --> 00:06:36,120
test breaks like a lot of times you're

00:06:34,800 --> 00:06:39,330
wondering well is it the unit test or is

00:06:36,120 --> 00:06:41,100
it the code issue if things are basic

00:06:39,330 --> 00:06:43,110
and understandable in the unit test and

00:06:41,100 --> 00:06:48,900
at least you know okay this unit test

00:06:43,110 --> 00:06:51,510
seems correct so this is example of the

00:06:48,900 --> 00:06:53,490
same function being tested so the input

00:06:51,510 --> 00:06:55,560
and output like it's still correct but

00:06:53,490 --> 00:07:01,730
it's just harder to understand what's

00:06:55,560 --> 00:07:04,730
actually happening okay this is a

00:07:01,730 --> 00:07:10,620
example of an actual unit test that

00:07:04,730 --> 00:07:13,670
isn't so good so I knew there was an

00:07:10,620 --> 00:07:16,200
error in this code somewhere the error

00:07:13,670 --> 00:07:18,000
turned out to be in this module down the

00:07:16,200 --> 00:07:23,670
bottom this was the only unit tests

00:07:18,000 --> 00:07:28,080
which executed that module so this unit

00:07:23,670 --> 00:07:30,360
test is not isolating the problem this

00:07:28,080 --> 00:07:34,730
is the that's the input that went into

00:07:30,360 --> 00:07:37,320
the unit test and that's the output so

00:07:34,730 --> 00:07:40,850
you look at that and you don't really

00:07:37,320 --> 00:07:43,920
know like you cannot tell what be

00:07:40,850 --> 00:07:46,560
actually should be doing and also it

00:07:43,920 --> 00:07:49,680
doesn't give you some it doesn't give

00:07:46,560 --> 00:07:54,240
you faith either as well that that any

00:07:49,680 --> 00:07:56,550
of this code is correct so I'm okay so

00:07:54,240 --> 00:08:01,800
that's an example of a bad unit test now

00:07:56,550 --> 00:08:08,520
move on to other sort of areas so I said

00:08:01,800 --> 00:08:09,900
before the the code that we have it's it

00:08:08,520 --> 00:08:14,160
doesn't have a graphical user interface

00:08:09,900 --> 00:08:16,590
so the output is um is a file so it's

00:08:14,160 --> 00:08:18,630
what we found to be good in

00:08:16,590 --> 00:08:20,340
eating bugs or keeping the quality

00:08:18,630 --> 00:08:27,660
control up is being able to visualize

00:08:20,340 --> 00:08:30,030
the output so let's see okay so one of

00:08:27,660 --> 00:08:34,890
our one of the codes are we right it's

00:08:30,030 --> 00:08:40,560
an inundation modeling so this is output

00:08:34,890 --> 00:08:43,050
from the inundation modeling so it's it

00:08:40,560 --> 00:08:44,760
helps that it's simulating water and we

00:08:43,050 --> 00:08:48,000
sort of know what water should look like

00:08:44,760 --> 00:08:50,460
so if there's anything drastically wrong

00:08:48,000 --> 00:08:52,350
then you can tell it straight away I

00:08:50,460 --> 00:08:54,480
mean I've seen sort of water traveling

00:08:52,350 --> 00:08:56,730
up walls and water just sort of suddenly

00:08:54,480 --> 00:08:58,560
appearing and land and disappearing so

00:08:56,730 --> 00:09:00,360
the visualizing can be really

00:08:58,560 --> 00:09:08,070
visualizing the output can be really

00:09:00,360 --> 00:09:09,570
helpful in catching errors I also with

00:09:08,070 --> 00:09:12,960
this code itself it's in numerical

00:09:09,570 --> 00:09:14,700
methods clothes so the water is

00:09:12,960 --> 00:09:15,990
represented by triangles with each

00:09:14,700 --> 00:09:22,530
triangle sort of knowing the height of

00:09:15,990 --> 00:09:24,780
the water okay so for the earthquake

00:09:22,530 --> 00:09:26,490
model it's not quite as interesting you

00:09:24,780 --> 00:09:28,880
don't the output isn't movies but

00:09:26,490 --> 00:09:31,740
there's on package such as matplotlib

00:09:28,880 --> 00:09:39,510
which is really good for graphing the

00:09:31,740 --> 00:09:42,800
output and producing maps okay how else

00:09:39,510 --> 00:09:47,220
can we maintain the quality of the code

00:09:42,800 --> 00:09:50,280
for the inundation model we can actually

00:09:47,220 --> 00:09:52,650
validate it against real life real life

00:09:50,280 --> 00:09:55,950
water suppose like so this is a damn

00:09:52,650 --> 00:09:58,220
brake tank so there are sensors

00:09:55,950 --> 00:10:01,280
measuring the water height and the

00:09:58,220 --> 00:10:06,930
velocity of the water so we can then

00:10:01,280 --> 00:10:10,740
simulate this tank and we get results so

00:10:06,930 --> 00:10:12,900
the black line is armed the results from

00:10:10,740 --> 00:10:16,530
anuga and the colored lines are the

00:10:12,900 --> 00:10:19,500
actual results from the water tank so

00:10:16,530 --> 00:10:25,290
we've got several validation data sets

00:10:19,500 --> 00:10:27,780
that we that we are code up onto into a

00:10:25,290 --> 00:10:29,370
system test that it takes a while to run

00:10:27,780 --> 00:10:31,800
maybe 20 minutes

00:10:29,370 --> 00:10:34,830
but you can run that whenever you want

00:10:31,800 --> 00:10:37,080
to make sure that the quality of our

00:10:34,830 --> 00:10:39,300
more the results you're getting from the

00:10:37,080 --> 00:10:41,070
inundation model aren't changing and we

00:10:39,300 --> 00:10:44,130
did this sort of thing or we automate it

00:10:41,070 --> 00:10:45,960
at all because we had run tests like

00:10:44,130 --> 00:10:48,480
this and we'd say excellent we're

00:10:45,960 --> 00:10:51,089
getting really good results but then six

00:10:48,480 --> 00:10:53,250
months later when we would run the test

00:10:51,089 --> 00:10:55,680
again it was and it wasn't getting the

00:10:53,250 --> 00:10:59,220
same result so by having this automated

00:10:55,680 --> 00:11:01,200
so you can run it often it's really

00:10:59,220 --> 00:11:07,680
useful but maintaining the quality of

00:11:01,200 --> 00:11:09,570
the code for earthquakes though or for

00:11:07,680 --> 00:11:12,300
the earthquake code we don't have good

00:11:09,570 --> 00:11:17,190
earthquake validation data so what can

00:11:12,300 --> 00:11:24,570
you do in that sort of case what we do

00:11:17,190 --> 00:11:28,170
is armed with we create input okay we

00:11:24,570 --> 00:11:31,500
run it oh um overall given some input

00:11:28,170 --> 00:11:33,150
data that's going to give some output we

00:11:31,500 --> 00:11:34,830
don't know if that output is correct but

00:11:33,150 --> 00:11:36,750
the first time you run or create these

00:11:34,830 --> 00:11:39,089
tests we can assume the output is

00:11:36,750 --> 00:11:41,839
correct and more clots standard out then

00:11:39,089 --> 00:11:45,150
in the future when we refactor the code

00:11:41,839 --> 00:11:47,670
we can we can run these tests so it's

00:11:45,150 --> 00:11:50,400
checking current behavior against the

00:11:47,670 --> 00:11:51,720
behavior when the test is written and so

00:11:50,400 --> 00:11:54,060
this is this is useful when you're

00:11:51,720 --> 00:11:55,320
refactoring what you see are doing

00:11:54,060 --> 00:11:59,279
changes to make sure that it's still

00:11:55,320 --> 00:12:00,990
okay so for example when eco Ram

00:11:59,279 --> 00:12:04,230
initially we're just running on Windows

00:12:00,990 --> 00:12:05,670
then we moved it over to Linux the unit

00:12:04,230 --> 00:12:08,850
that I got to appoint with all the unit

00:12:05,670 --> 00:12:10,650
tests were passing but these tests were

00:12:08,850 --> 00:12:13,170
failing so then it's working out okay

00:12:10,650 --> 00:12:14,400
why and so that that's what error

00:12:13,170 --> 00:12:16,170
wouldn't have been caught and let's add

00:12:14,400 --> 00:12:19,130
these overall system test because a lot

00:12:16,170 --> 00:12:21,240
of things aren't caught by unit tests

00:12:19,130 --> 00:12:28,910
obviously all the integration between

00:12:21,240 --> 00:12:31,850
all the code so for ekm we've got 53

00:12:28,910 --> 00:12:33,779
characterization tests oh yeah

00:12:31,850 --> 00:12:36,900
characterization tests they can also be

00:12:33,779 --> 00:12:38,940
good with legacy code so say you get

00:12:36,900 --> 00:12:40,290
some legacy code people are so people

00:12:38,940 --> 00:12:42,140
say we're happy with what it's doing but

00:12:40,290 --> 00:12:43,550
we want to add new functionality

00:12:42,140 --> 00:12:45,410
so you want to add that new

00:12:43,550 --> 00:12:47,930
functionality without breaking it so you

00:12:45,410 --> 00:12:50,150
do use characterization tests to make

00:12:47,930 --> 00:12:51,620
sure the that you're keeping the current

00:12:50,150 --> 00:12:53,360
functionality you don't really have to

00:12:51,620 --> 00:12:59,720
know what the specifications of the code

00:12:53,360 --> 00:13:02,000
are okay yeah so we're doing all this so

00:12:59,720 --> 00:13:06,410
these tests mean that it's easy to

00:13:02,000 --> 00:13:07,790
refactor the code so what sort of like I

00:13:06,410 --> 00:13:11,560
give a sort of examples on the

00:13:07,790 --> 00:13:16,790
refactoring that we did for the

00:13:11,560 --> 00:13:19,280
inundation model we developed it

00:13:16,790 --> 00:13:22,910
iteratively initially it was written all

00:13:19,280 --> 00:13:25,730
in Python and it had a lot of instances

00:13:22,910 --> 00:13:27,350
so you saw before how the sort of the

00:13:25,730 --> 00:13:30,200
building blocks for the inundation code

00:13:27,350 --> 00:13:34,130
are triangles in a mesh so initially

00:13:30,200 --> 00:13:36,740
that there was a triangle object and

00:13:34,130 --> 00:13:41,350
there'll be a triangle instances to

00:13:36,740 --> 00:13:44,390
represent what's shown up there once the

00:13:41,350 --> 00:13:48,370
overall architecture of the code was

00:13:44,390 --> 00:13:53,630
stable and we focused on optimization

00:13:48,370 --> 00:13:57,560
and so one of the things that we did was

00:13:53,630 --> 00:14:00,140
reduce a number of instances so we have

00:13:57,560 --> 00:14:03,020
we've got a mesh object and so there's

00:14:00,140 --> 00:14:07,340
one instance of that and that represents

00:14:03,020 --> 00:14:09,790
many triangles the information so so

00:14:07,340 --> 00:14:12,980
with a triangle such as water height and

00:14:09,790 --> 00:14:14,950
momentum in the X and Y direction that

00:14:12,980 --> 00:14:20,420
information is put into an umpire arrays

00:14:14,950 --> 00:14:24,560
and we also did profiling and the

00:14:20,420 --> 00:14:26,540
bottleneck sections we write in C and so

00:14:24,560 --> 00:14:29,270
by doing things like that you made the

00:14:26,540 --> 00:14:31,790
cloak that code become a lot faster and

00:14:29,270 --> 00:14:34,400
a lot memory intensive which meant we

00:14:31,790 --> 00:14:37,270
could run bigger simulations which is

00:14:34,400 --> 00:14:37,270
what the scientists want

00:14:39,230 --> 00:14:43,470
okay so if you're going to do so now

00:14:41,519 --> 00:14:46,920
I'll talk a bit more about speeding up

00:14:43,470 --> 00:14:53,610
the code so if you want to do any sort

00:14:46,920 --> 00:14:57,420
of um optimization of your code then use

00:14:53,610 --> 00:15:00,170
profiling often where you think your

00:14:57,420 --> 00:15:01,980
code is going to be slow it isn't slow

00:15:00,170 --> 00:15:05,309
profiling can tell you where it is

00:15:01,980 --> 00:15:08,579
actually slow once you find the slow

00:15:05,309 --> 00:15:12,540
bits often it can be sped up by using

00:15:08,579 --> 00:15:16,350
better algorithms so it might actually

00:15:12,540 --> 00:15:17,819
be your code might have bugs in the

00:15:16,350 --> 00:15:21,389
sense that you're just using algorithms

00:15:17,819 --> 00:15:23,069
that are really slow also by using numpy

00:15:21,389 --> 00:15:25,800
you can speed up your code so i'll be

00:15:23,069 --> 00:15:30,959
talking more about that in the next few

00:15:25,800 --> 00:15:34,680
slides you can also often with our

00:15:30,959 --> 00:15:36,809
numerical models there's sections that

00:15:34,680 --> 00:15:38,970
spends a lot of time in these sections

00:15:36,809 --> 00:15:42,709
can be recoded into other languages or

00:15:38,970 --> 00:15:45,449
like c or so i think feed things up and

00:15:42,709 --> 00:15:50,009
so I've listed a few modules that can be

00:15:45,449 --> 00:15:52,019
used for profiling it's also handy to do

00:15:50,009 --> 00:15:54,420
on memory profiling there's a package

00:15:52,019 --> 00:15:56,189
called Gumpy one of the things with

00:15:54,420 --> 00:15:58,500
Gumpy though if you've got all your

00:15:56,189 --> 00:16:02,930
information in our numpy raise Gumpy

00:15:58,500 --> 00:16:02,930
doesn't actually sort of see that memory

00:16:03,949 --> 00:16:10,800
okay so what's an umpire it's a package

00:16:08,819 --> 00:16:13,800
that's used extensively I'm in the

00:16:10,800 --> 00:16:16,350
scientific area and it's a way first

00:16:13,800 --> 00:16:19,740
it's for storing and manipulating

00:16:16,350 --> 00:16:24,990
n-dimensional imagine imagine asst array

00:16:19,740 --> 00:16:27,569
objects so so I'm just like it because

00:16:24,990 --> 00:16:28,740
it can really speed things up and also

00:16:27,569 --> 00:16:32,129
reduce the memory for storing

00:16:28,740 --> 00:16:35,339
information obviously to get the speed

00:16:32,129 --> 00:16:38,999
benefits you have to use a numpy data

00:16:35,339 --> 00:16:42,389
types and also the numpy functions so if

00:16:38,999 --> 00:16:44,009
you have a an array you want to find the

00:16:42,389 --> 00:16:47,399
minimum number in that array you don't

00:16:44,009 --> 00:16:51,560
use a python men call user numpy main

00:16:47,399 --> 00:16:53,060
core also you are

00:16:51,560 --> 00:16:56,810
vectorized operations and I'll talk

00:16:53,060 --> 00:16:59,420
about that in my next slide can also

00:16:56,810 --> 00:17:04,850
compile to get maximum speed you want to

00:16:59,420 --> 00:17:06,439
compile numpy to your CPU so there is

00:17:04,850 --> 00:17:11,780
another package as well that's used a

00:17:06,439 --> 00:17:13,100
lot that's called side pi and that that

00:17:11,780 --> 00:17:15,650
sort of that extends the functionality

00:17:13,100 --> 00:17:17,449
of numpy it's got a lot of tools

00:17:15,650 --> 00:17:21,140
scientific tools and engineering tools

00:17:17,449 --> 00:17:27,620
associated with it that use numpy as a

00:17:21,140 --> 00:17:29,420
basis okay so here we have a example so

00:17:27,620 --> 00:17:32,030
these these two codes they both do

00:17:29,420 --> 00:17:36,920
exactly the same thing and that's some

00:17:32,030 --> 00:17:42,080
estimating value of pi the the top

00:17:36,920 --> 00:17:43,850
yellow code that's standard Python so

00:17:42,080 --> 00:17:47,860
that X the value of x there it's just

00:17:43,850 --> 00:17:54,470
one number what we've got down here arm

00:17:47,860 --> 00:17:57,500
MP is numpy so when we run this code

00:17:54,470 --> 00:18:00,740
that value of x there is not one value

00:17:57,500 --> 00:18:03,980
but it's an a one-dimensional array or

00:18:00,740 --> 00:18:06,350
vector of values so this doesn't

00:18:03,980 --> 00:18:11,240
actually have a loop in it when this

00:18:06,350 --> 00:18:14,990
code is ran the the vast majority the

00:18:11,240 --> 00:18:18,170
time is spent inside these arm numpy

00:18:14,990 --> 00:18:22,330
functions random random square where

00:18:18,170 --> 00:18:24,710
some so these functions their arm

00:18:22,330 --> 00:18:27,890
they're written in C and they've been

00:18:24,710 --> 00:18:29,929
optimized for speed and so that's why

00:18:27,890 --> 00:18:32,240
when do the the time comparison this is

00:18:29,929 --> 00:18:35,420
when n is a million this takes about a

00:18:32,240 --> 00:18:38,380
second this takes about seven seconds so

00:18:35,420 --> 00:18:38,380
you can get a good speed up

00:18:43,899 --> 00:18:49,309
okay what are other ways of getting

00:18:46,279 --> 00:18:54,340
things faster so you can paralyze the

00:18:49,309 --> 00:18:58,029
code so in Python you can start threads

00:18:54,340 --> 00:19:00,230
due to the global interpreter like that

00:18:58,029 --> 00:19:03,110
sometimes that's not so good if you've

00:19:00,230 --> 00:19:04,820
got if you pearl if you use threads and

00:19:03,110 --> 00:19:07,159
it's doing a lot of i/o then you will

00:19:04,820 --> 00:19:10,000
get a speed up but if it's like those

00:19:07,159 --> 00:19:12,710
codes you saw before then you won't

00:19:10,000 --> 00:19:15,710
Python has a morir processing package

00:19:12,710 --> 00:19:18,529
and so that's useful for taking

00:19:15,710 --> 00:19:22,809
advantage of armed the cores on your if

00:19:18,529 --> 00:19:25,640
you've got a like a box or computer to

00:19:22,809 --> 00:19:27,500
run and that will execute Python on the

00:19:25,640 --> 00:19:31,309
like start up multiple processes of

00:19:27,500 --> 00:19:32,929
Python if you're using a cluster so a

00:19:31,309 --> 00:19:36,440
bunch of computers that are connected by

00:19:32,929 --> 00:19:38,870
a fast Network mpi is the standard way

00:19:36,440 --> 00:19:42,380
of pearl or send a way of paralyzing

00:19:38,870 --> 00:19:45,559
things so MPI isn't part of Python it's

00:19:42,380 --> 00:19:48,320
a sort of it's another package you know

00:19:45,559 --> 00:19:50,630
it sort of was not part of Python and it

00:19:48,320 --> 00:19:52,570
allows processes to communicate with one

00:19:50,630 --> 00:19:55,549
another by sending and receiving

00:19:52,570 --> 00:20:03,830
receiving messengers so their wrappers

00:19:55,549 --> 00:20:04,760
around MPI for Python so when you're

00:20:03,830 --> 00:20:09,110
going to when you're going to do this

00:20:04,760 --> 00:20:12,880
though you have to you have to modify

00:20:09,110 --> 00:20:17,559
the code to take advantage of MPI and

00:20:12,880 --> 00:20:21,679
this can be armed be quite a lot of work

00:20:17,559 --> 00:20:25,909
and so this is how its this is how you

00:20:21,679 --> 00:20:30,250
use it you do a command MPI run and this

00:20:25,909 --> 00:20:37,490
would run the code called parallel py on

00:20:30,250 --> 00:20:39,640
four cores or processes okay so here's

00:20:37,490 --> 00:20:43,309
an example of doing that sort of thing

00:20:39,640 --> 00:20:45,980
so for the inundation model it's made up

00:20:43,309 --> 00:20:50,860
of triangles triangles of different

00:20:45,980 --> 00:20:54,470
sizes when we ran this job on four

00:20:50,860 --> 00:21:01,580
processes the area is part

00:20:54,470 --> 00:21:03,820
turned into four areas and so the okay

00:21:01,580 --> 00:21:07,460
the size of the area has been chosen so

00:21:03,820 --> 00:21:08,900
for it to be load balanced this area

00:21:07,460 --> 00:21:10,880
that's got a little large triangle well

00:21:08,900 --> 00:21:13,630
this so that had the same number of

00:21:10,880 --> 00:21:18,230
triangles not necessarily the same area

00:21:13,630 --> 00:21:22,400
and so when this runs MPI is more the

00:21:18,230 --> 00:21:25,610
commands in MPI at doing the sub

00:21:22,400 --> 00:21:27,890
partitioning and they're also sort of

00:21:25,610 --> 00:21:31,309
ghost triangles around this edge and

00:21:27,890 --> 00:21:33,350
around this edge and MPI is handling the

00:21:31,309 --> 00:21:37,130
communication between all these

00:21:33,350 --> 00:21:41,120
triangles and so it's so it's quite

00:21:37,130 --> 00:21:45,740
complex to parallelize code like this or

00:21:41,120 --> 00:21:49,730
model like this i should say some some

00:21:45,740 --> 00:21:50,870
models are easier to parallel lies so in

00:21:49,730 --> 00:21:53,870
what i showed you before there was

00:21:50,870 --> 00:21:55,850
communication between the processes for

00:21:53,870 --> 00:21:59,570
the earthquake model it's what you're

00:21:55,850 --> 00:22:01,640
calling embarrassingly parallel so with

00:21:59,570 --> 00:22:04,520
your earthquake model you're looking at

00:22:01,640 --> 00:22:06,380
the ground shaking for a set of

00:22:04,520 --> 00:22:08,480
locations but the amount of ground

00:22:06,380 --> 00:22:10,010
shaking that happens over here isn't

00:22:08,480 --> 00:22:14,030
affected by the ground shaking that it

00:22:10,010 --> 00:22:16,490
happens over here so you can just cut

00:22:14,030 --> 00:22:18,230
the simulation up across four processes

00:22:16,490 --> 00:22:23,770
by giving subsets of the number of

00:22:18,230 --> 00:22:27,169
subsets of the houses and so that's easy

00:22:23,770 --> 00:22:31,850
okay so what sort of timings also speed

00:22:27,169 --> 00:22:34,820
up can we get so here's arm some results

00:22:31,850 --> 00:22:37,070
for the earthquake model so when we're

00:22:34,820 --> 00:22:41,090
running on one process it takes about an

00:22:37,070 --> 00:22:43,120
hour and a half when we go down to 32

00:22:41,090 --> 00:22:45,260
processes is taking about three minutes

00:22:43,120 --> 00:22:47,630
but you can sort of see that this isn't

00:22:45,260 --> 00:22:49,809
such a good way of graphing up the speed

00:22:47,630 --> 00:22:49,809
up

00:22:51,350 --> 00:22:54,530
another way of looking at it with a

00:22:52,850 --> 00:22:56,780
speed up that you can achieve is looking

00:22:54,530 --> 00:23:01,160
at the parallel efficiency efficiency so

00:22:56,780 --> 00:23:03,230
with parallel efficiency if your arm if

00:23:01,160 --> 00:23:06,020
when you double the number of processes

00:23:03,230 --> 00:23:07,820
the time it takes to execute is haft

00:23:06,020 --> 00:23:10,700
then that's the parallel efficiency of

00:23:07,820 --> 00:23:12,470
one and that's that's really good so you

00:23:10,700 --> 00:23:15,799
can see here how the parallel efficiency

00:23:12,470 --> 00:23:17,780
decreases and that's that's pretty

00:23:15,799 --> 00:23:19,520
common and that's due to the

00:23:17,780 --> 00:23:22,669
communication Judith such things as a

00:23:19,520 --> 00:23:25,820
communication between the nodes and not

00:23:22,669 --> 00:23:29,270
all of the code being parallelizable or

00:23:25,820 --> 00:23:32,480
paralyzed okay so from this you can sort

00:23:29,270 --> 00:23:35,299
of tell that this thing or the

00:23:32,480 --> 00:23:37,130
earthquake model it's good for running

00:23:35,299 --> 00:23:39,260
like 40 processes but it's not the sort

00:23:37,130 --> 00:23:43,820
of thing you'd run on a supercomputer

00:23:39,260 --> 00:23:47,210
with a thousand nodes okay um that's

00:23:43,820 --> 00:23:48,890
that's the end of the talk if you're one

00:23:47,210 --> 00:23:51,320
more want to hear more about Python for

00:23:48,890 --> 00:23:54,980
science then it would show field is

00:23:51,320 --> 00:23:56,600
doing some talks tomorrow about Python

00:23:54,980 --> 00:23:58,970
for science and engineering and I'm sure

00:23:56,600 --> 00:24:04,450
we'll go into like numpy inside pie and

00:23:58,970 --> 00:24:04,450
more depth so yeah there any questions I

00:24:05,470 --> 00:24:15,289
and they show we've got a microphone as

00:24:07,520 --> 00:24:16,640
well so um so it gets on oh hi I'm my

00:24:15,289 --> 00:24:19,010
name is probably a party of four mayen

00:24:16,640 --> 00:24:20,929
you um you said that the person was good

00:24:19,010 --> 00:24:26,929
because scientists like to write in it

00:24:20,929 --> 00:24:29,720
so the question is okay yet so the

00:24:26,929 --> 00:24:33,320
question is um how do you get scientists

00:24:29,720 --> 00:24:38,000
to do things like documentation and unit

00:24:33,320 --> 00:24:39,650
testing and all that sort of stuff is is

00:24:38,000 --> 00:24:41,929
there some sort of team structure

00:24:39,650 --> 00:24:43,970
between the scientists and the IT people

00:24:41,929 --> 00:24:46,010
to make sure that all of that happens

00:24:43,970 --> 00:24:49,400
and that you have something that can be

00:24:46,010 --> 00:24:57,799
properly packaged that is an excellent

00:24:49,400 --> 00:25:00,710
question um I suppose we don't we don't

00:24:57,799 --> 00:25:03,169
have a good way of doing that like often

00:25:00,710 --> 00:25:05,090
what happens is that I mean I think it

00:25:03,169 --> 00:25:07,370
depends how the project started by

00:25:05,090 --> 00:25:11,600
clay if they're there are some

00:25:07,370 --> 00:25:13,040
scientists who have also also are good

00:25:11,600 --> 00:25:16,610
software developers that are already

00:25:13,040 --> 00:25:20,960
doing that and so often if the system

00:25:16,610 --> 00:25:22,730
starts off like that when more when you

00:25:20,960 --> 00:25:24,470
have other scientists that join the team

00:25:22,730 --> 00:25:26,870
then they're told how to do the

00:25:24,470 --> 00:25:29,660
development but often when this its

00:25:26,870 --> 00:25:31,040
scientists starting up they yeah well

00:25:29,660 --> 00:25:33,470
you have the problem of them not doing

00:25:31,040 --> 00:25:37,310
unit tests not document ating not doing

00:25:33,470 --> 00:25:40,460
documentation version control what's

00:25:37,310 --> 00:25:44,240
that subversion yeah I don't know what

00:25:40,460 --> 00:25:47,780
it is so we face that problem as well

00:25:44,240 --> 00:25:50,270
like ideally you'd I think it'd be a

00:25:47,780 --> 00:25:52,460
it's good if you have a software

00:25:50,270 --> 00:25:54,650
developers in the project in the team

00:25:52,460 --> 00:25:57,170
but off in the scientific environment as

00:25:54,650 --> 00:25:59,360
well it's quite sort of silo-based you

00:25:57,170 --> 00:26:00,740
have a scientist and so like every

00:25:59,360 --> 00:26:03,740
scientist is going to have a software

00:26:00,740 --> 00:26:07,570
developer associated with it so yeah

00:26:03,740 --> 00:26:07,570
it's a problem and I have no solution

00:26:11,770 --> 00:26:16,640
thanks Duncan for an interesting talk

00:26:14,000 --> 00:26:19,340
and a good overview thanks i'm

00:26:16,640 --> 00:26:22,460
interested in um what problems you've

00:26:19,340 --> 00:26:31,540
encountered at GA using a python for

00:26:22,460 --> 00:26:34,130
your signs work okay um what problems I

00:26:31,540 --> 00:26:37,520
think overall pythons a great language

00:26:34,130 --> 00:26:39,800
to use I'd say some of the problems can

00:26:37,520 --> 00:26:44,000
be actually getting it installed and

00:26:39,800 --> 00:26:48,290
like getting just the packages up there

00:26:44,000 --> 00:26:50,990
so it's yeah it's more the system

00:26:48,290 --> 00:26:55,700
administration sort of problems that we

00:26:50,990 --> 00:26:58,670
face I mean there can be a bit of a like

00:26:55,700 --> 00:27:02,240
people MATLAB is a prominent scientific

00:26:58,670 --> 00:27:05,120
language that a lot of people use in

00:27:02,240 --> 00:27:08,660
universities may be so that they'd want

00:27:05,120 --> 00:27:11,960
to stick with matlab that's another bit

00:27:08,660 --> 00:27:14,600
of a bit of a problem we want them to

00:27:11,960 --> 00:27:16,940
have a better understanding of armed

00:27:14,600 --> 00:27:17,970
running unix as well i suppose and some

00:27:16,940 --> 00:27:21,240
people do

00:27:17,970 --> 00:27:23,550
but overall I mean python is a language

00:27:21,240 --> 00:27:27,060
I think it's a really simple language to

00:27:23,550 --> 00:27:29,990
learn so the problems are things not to

00:27:27,060 --> 00:27:29,990
do with Python really

00:27:36,909 --> 00:27:42,970
Oh actually at a couple of questions no

00:27:39,580 --> 00:27:46,659
one was I noticed you when you mentioned

00:27:42,970 --> 00:27:50,379
NPI you mentioned three different MPI

00:27:46,659 --> 00:27:53,049
libraries yep and one of the problems I

00:27:50,379 --> 00:27:54,369
think newbies have in python is there's

00:27:53,049 --> 00:27:56,139
so many packages and you don't know

00:27:54,369 --> 00:27:58,929
which one is the most standard so is one

00:27:56,139 --> 00:28:04,749
of those the you know more standard than

00:27:58,929 --> 00:28:06,909
the others yeah well I think MPI for pie

00:28:04,749 --> 00:28:11,080
seems to be the more standard the one

00:28:06,909 --> 00:28:13,210
must enter one used we use pipe are like

00:28:11,080 --> 00:28:16,210
one of the people I'm that sort of part

00:28:13,210 --> 00:28:18,129
of GA he wrote that so yeah and that is

00:28:16,210 --> 00:28:19,929
a problem I suppose as a generalization

00:28:18,129 --> 00:28:22,330
google and see which one seems more

00:28:19,929 --> 00:28:24,639
prominent but yeah it is an issue and

00:28:22,330 --> 00:28:27,399
these things change as well like you

00:28:24,639 --> 00:28:30,249
know you go back on 07 year or five

00:28:27,399 --> 00:28:32,409
years and there was armed numeric which

00:28:30,249 --> 00:28:34,570
was used to do raise now it's numpy so

00:28:32,409 --> 00:28:36,789
you might find this out using a package

00:28:34,570 --> 00:28:38,529
and then sort of realize that seems to

00:28:36,789 --> 00:28:43,179
be dying what are people using these

00:28:38,529 --> 00:28:46,450
days oh thank you yes I also wanted to

00:28:43,179 --> 00:28:48,159
ask a lot of the time cluster

00:28:46,450 --> 00:28:52,299
architectures nowadays are you have a

00:28:48,159 --> 00:28:55,019
cluster of multi-core notes yep so you

00:28:52,299 --> 00:28:58,179
have shared memory mixed with

00:28:55,019 --> 00:29:00,220
distributed non shared memory yup do you

00:28:58,179 --> 00:29:02,799
try to do anything in particular to take

00:29:00,220 --> 00:29:05,249
take advantage of that architecture no

00:29:02,799 --> 00:29:05,249
we don't

00:29:09,970 --> 00:29:12,870
then I'll come back

00:29:16,700 --> 00:29:22,880
hi thanks for the talk I was just

00:29:19,130 --> 00:29:25,610
wondering what sort of architectural

00:29:22,880 --> 00:29:27,680
decisions would you have to make if you

00:29:25,610 --> 00:29:31,030
want to design your code so that it can

00:29:27,680 --> 00:29:37,670
be parallelized later but are without

00:29:31,030 --> 00:29:40,100
parallelizing it to begin with okay I

00:29:37,670 --> 00:29:42,020
mean both of the codes both with dinner

00:29:40,100 --> 00:29:47,660
datamodel and the earthquake model they

00:29:42,020 --> 00:29:49,070
weren't paralyzed initially for I mean

00:29:47,660 --> 00:29:52,550
I've mainly got experienced with the

00:29:49,070 --> 00:29:54,710
scientific code and a lot of a lot of

00:29:52,550 --> 00:29:58,010
that it's there's big chunking arrays of

00:29:54,710 --> 00:30:00,890
data in the code and so when you go to

00:29:58,010 --> 00:30:05,720
parallel lies it's sort of how am I

00:30:00,890 --> 00:30:08,510
going to cut this up and so there isn't

00:30:05,720 --> 00:30:11,000
any architectural there's also much any

00:30:08,510 --> 00:30:14,900
architectural changes that you do when

00:30:11,000 --> 00:30:18,560
you that that we could have done at the

00:30:14,900 --> 00:30:20,150
beginning yeah I mean it but there are

00:30:18,560 --> 00:30:22,700
changes that you do once you paralyze it

00:30:20,150 --> 00:30:25,760
you can sort of you realize i can i can

00:30:22,700 --> 00:30:28,930
save in memory by sort of taking

00:30:25,760 --> 00:30:34,000
subsections of this array as well and

00:30:28,930 --> 00:30:36,140
like forearm the inundation code like we

00:30:34,000 --> 00:30:38,360
because that was a 1 there was a lot

00:30:36,140 --> 00:30:43,300
more complex to paralyze we sort of

00:30:38,360 --> 00:30:43,300
contracted people from Anu to do that

00:30:52,570 --> 00:31:04,990
and if you've got questions yep I have

00:31:00,820 --> 00:31:08,679
never used mpi before yes just out of

00:31:04,990 --> 00:31:10,779
curiosity I guess you can run mpi on a

00:31:08,679 --> 00:31:14,019
single machine yes you certainly can

00:31:10,779 --> 00:31:16,659
yeah so have you ever compared the the

00:31:14,019 --> 00:31:19,899
performance of multi multi process

00:31:16,659 --> 00:31:22,179
module and the NPI and does it have a

00:31:19,899 --> 00:31:23,830
gain over the multi-process module I

00:31:22,179 --> 00:31:26,470
have to make a confession as well

00:31:23,830 --> 00:31:28,870
i'venever run multiprocessing we've I've

00:31:26,470 --> 00:31:32,830
just used mpi so now I haven't done that

00:31:28,870 --> 00:31:34,389
comparison but I mean if you're just

00:31:32,830 --> 00:31:36,879
running on a single box I think the

00:31:34,389 --> 00:31:40,029
beauty of em of multiprocessing is you

00:31:36,879 --> 00:31:43,809
can just in like import that package and

00:31:40,029 --> 00:31:46,120
start using it with arm the with mpi

00:31:43,809 --> 00:31:48,250
like those python packages are really

00:31:46,120 --> 00:31:55,960
rap is so you have to install NPI as

00:31:48,250 --> 00:31:58,299
well so i have a spectacular pycon cup

00:31:55,960 --> 00:32:01,889
or mug i should say thank you I'm for

00:31:58,299 --> 00:32:01,889

YouTube URL: https://www.youtube.com/watch?v=qIVEkecxVqo


