Title: Bytecode: What, Why, and How to Hack it - Dr. Ryan F Kelly
Publication date: 2011-08-22
Playlist: PyCon Australia 2011
Description: 
	What's python really doing when it runs your scripts, and what's with all these .pyc files?  Get inside the head of python.exe, learn how it sees your code, and then twist it to your own evil ends.

This talk will discuss the basics of python's bytecode format, why and how it is used, and how you can dive into the bytecode of your running program - either to better understand its behaviour, or to make it do things to was never supposed to do....
Captions: 
	00:00:00,000 --> 00:00:06,690
going to show us what why and how to

00:00:04,020 --> 00:00:11,730
heck we have core developer here to keep

00:00:06,690 --> 00:00:13,620
him honest or upset and Richard behave

00:00:11,730 --> 00:00:19,699
himself you know the code of conduct

00:00:13,620 --> 00:00:19,699
anyway let's give a warm welcome daddy

00:00:20,570 --> 00:00:29,070
so yeah this is me in real life I'm

00:00:25,320 --> 00:00:31,050
quite a serious software engineer but in

00:00:29,070 --> 00:00:33,750
my spare time and on stage I like to

00:00:31,050 --> 00:00:36,780
muck around with fun stuff and make

00:00:33,750 --> 00:00:39,809
Python do fun things so this is a little

00:00:36,780 --> 00:00:41,219
bit of a rambling talk about Python and

00:00:39,809 --> 00:00:44,160
some of the stuff that it does

00:00:41,219 --> 00:00:47,730
internally so it's not all just about

00:00:44,160 --> 00:00:49,260
how to do wacky stuff I hope to show you

00:00:47,730 --> 00:00:51,270
a little bit about some of the internal

00:00:49,260 --> 00:00:53,670
details of Python that you never really

00:00:51,270 --> 00:00:55,469
see during your day to day interactions

00:00:53,670 --> 00:00:57,989
with the language but that are quite

00:00:55,469 --> 00:01:00,059
interesting and the details of which do

00:00:57,989 --> 00:01:04,229
have an effect on you and on your

00:01:00,059 --> 00:01:06,270
programs so at the end of this talk I'm

00:01:04,229 --> 00:01:07,830
about to advise you to not do a variety

00:01:06,270 --> 00:01:10,409
of things that I show you in this talk

00:01:07,830 --> 00:01:13,530
but I have my hope is that having seen

00:01:10,409 --> 00:01:15,330
some stuff under the covers and how it

00:01:13,530 --> 00:01:17,430
works it will make you a better Python

00:01:15,330 --> 00:01:18,930
programmer just because of your you know

00:01:17,430 --> 00:01:22,170
because of having a different

00:01:18,930 --> 00:01:24,750
perspective on things so python is known

00:01:22,170 --> 00:01:26,400
as as an interpreted language like they

00:01:24,750 --> 00:01:26,759
say it's a scripting language and so

00:01:26,400 --> 00:01:30,869
forth

00:01:26,759 --> 00:01:32,220
and but really it is both a compiled

00:01:30,869 --> 00:01:35,430
language and an interpreted language

00:01:32,220 --> 00:01:37,979
right you've all seen these hi-c files

00:01:35,430 --> 00:01:41,729
you start out with your source in hello

00:01:37,979 --> 00:01:45,840
dot PI that gets compiled by Python and

00:01:41,729 --> 00:01:49,560
pasted as this hello dot PI C file and

00:01:45,840 --> 00:01:51,149
then that compiled code gets interpreted

00:01:49,560 --> 00:01:52,770
by the Python executable and it prints

00:01:51,149 --> 00:01:55,229
out hello world so we have both an

00:01:52,770 --> 00:01:57,329
interpreter and a compiler and in the

00:01:55,229 --> 00:01:59,460
source they actually living in quite

00:01:57,329 --> 00:02:01,770
distinct places they're quite distinct

00:01:59,460 --> 00:02:04,350
bits of code and I'm interested in the

00:02:01,770 --> 00:02:06,719
stuff that exists in the middle so the

00:02:04,350 --> 00:02:11,819
the bytecode format that lets these two

00:02:06,719 --> 00:02:12,720
halves of Python talk to each other it's

00:02:11,819 --> 00:02:15,480
worth

00:02:12,720 --> 00:02:16,650
a brief mention about why - is

00:02:15,480 --> 00:02:19,110
structured this way I mean you'll

00:02:16,650 --> 00:02:20,820
certainly find interpreted languages

00:02:19,110 --> 00:02:23,190
that don't have a bytecode format they

00:02:20,820 --> 00:02:25,760
just pass their source directly into an

00:02:23,190 --> 00:02:28,860
ast and then the interpreter walks that

00:02:25,760 --> 00:02:30,660
directly and executes the code but

00:02:28,860 --> 00:02:32,310
having that split allows you to do some

00:02:30,660 --> 00:02:34,410
interesting things towards both

00:02:32,310 --> 00:02:36,180
efficiency so you can have the core of

00:02:34,410 --> 00:02:38,670
your interpreter not deal with a lot of

00:02:36,180 --> 00:02:39,930
silly cases in your syntax and deal with

00:02:38,670 --> 00:02:42,390
a more uniform and a simpler

00:02:39,930 --> 00:02:44,280
representation and also in terms of

00:02:42,390 --> 00:02:46,709
simplicity of implementation to keep

00:02:44,280 --> 00:02:48,420
those concerns separate and importantly

00:02:46,709 --> 00:02:50,610
of course all the cool kids are doing it

00:02:48,420 --> 00:02:53,610
right the JVM has a bytecode format

00:02:50,610 --> 00:02:57,180
Annette has a bytecode format it's quite

00:02:53,610 --> 00:03:01,170
a well understood way of structuring an

00:02:57,180 --> 00:03:02,910
interpreter we're going so if I were to

00:03:01,170 --> 00:03:05,300
say to you look what what is the most

00:03:02,910 --> 00:03:08,700
basic unit of code in Python

00:03:05,300 --> 00:03:09,870
and you'll you know a fair enough answer

00:03:08,700 --> 00:03:11,640
would be well it's a function right our

00:03:09,870 --> 00:03:14,930
definite function it's got some code in

00:03:11,640 --> 00:03:17,190
it and I can execute that code not quite

00:03:14,930 --> 00:03:20,070
- actually has these things called code

00:03:17,190 --> 00:03:21,209
objects and they live under the covers

00:03:20,070 --> 00:03:22,620
of all of the things that you do in

00:03:21,209 --> 00:03:24,660
Python and when you define a function

00:03:22,620 --> 00:03:26,700
you're actually declaring two things

00:03:24,660 --> 00:03:28,650
you're creating a code object and you're

00:03:26,700 --> 00:03:31,730
giving it a context in which it's

00:03:28,650 --> 00:03:34,470
supposed to execute and so yep I'm gonna

00:03:31,730 --> 00:03:36,420
pop over here and have a little bit of a

00:03:34,470 --> 00:03:39,180
chat about that and say this is my

00:03:36,420 --> 00:03:43,830
delightful not at all scripted Python

00:03:39,180 --> 00:03:46,380
shell and if I define the

00:03:43,830 --> 00:03:48,810
if I define a function like this right

00:03:46,380 --> 00:03:50,490
but I can call it and it says says the

00:03:48,810 --> 00:03:52,860
message and so forth but if we have a

00:03:50,490 --> 00:03:55,130
look at the attributes of this function

00:03:52,860 --> 00:03:57,180
object you see it's got lots of

00:03:55,130 --> 00:03:59,010
interesting and enticing things with

00:03:57,180 --> 00:04:01,680
double underscore is such as closure and

00:03:59,010 --> 00:04:03,480
code and defaults the one that I'm

00:04:01,680 --> 00:04:06,000
interested in is this double underscore

00:04:03,480 --> 00:04:09,090
code object which as it says is a code

00:04:06,000 --> 00:04:12,330
object and and it has this double

00:04:09,090 --> 00:04:13,530
underscore Global's right which if you

00:04:12,330 --> 00:04:15,660
have a look at the keys in this

00:04:13,530 --> 00:04:17,130
dictionary and actually corresponds to

00:04:15,660 --> 00:04:20,400
the context that I'm currently executing

00:04:17,130 --> 00:04:22,070
right now and in fact to a first

00:04:20,400 --> 00:04:24,720
approximation calling this function

00:04:22,070 --> 00:04:27,960
basically entails executing that code

00:04:24,720 --> 00:04:29,520
object in the Associated context of that

00:04:27,960 --> 00:04:32,070
function right if there's the same thing

00:04:29,520 --> 00:04:34,200
if I take that code object in isolation

00:04:32,070 --> 00:04:36,750
and executed in some other unrelated

00:04:34,200 --> 00:04:38,460
context bad things can happen because

00:04:36,750 --> 00:04:40,200
that code object is expecting to find a

00:04:38,460 --> 00:04:43,290
global variable named message which is

00:04:40,200 --> 00:04:44,970
gone missing you know I'm executing it

00:04:43,290 --> 00:04:46,680
in a different way where that function

00:04:44,970 --> 00:04:50,580
wasn't defined so it's not finding the

00:04:46,680 --> 00:04:52,800
things that it expects what have I got

00:04:50,580 --> 00:04:55,290
here yep so code objects they have a lot

00:04:52,800 --> 00:04:58,590
of interesting attributes on them this

00:04:55,290 --> 00:05:00,510
binary looking string here is the black

00:04:58,590 --> 00:05:05,150
code that the Python interpreter looks

00:05:00,510 --> 00:05:05,150
at and interprets and decides what to do

00:05:05,660 --> 00:05:10,500
this for example is a list of all of the

00:05:09,090 --> 00:05:13,830
names that are referenced in this in

00:05:10,500 --> 00:05:16,020
this bytecode and part of the reason why

00:05:13,830 --> 00:05:17,520
that's such an unintelligible string is

00:05:16,020 --> 00:05:19,740
that it contains various in directions

00:05:17,520 --> 00:05:20,910
and pointers out to say although you

00:05:19,740 --> 00:05:23,100
know the thing that's got the name

00:05:20,910 --> 00:05:25,560
that's the first name in Co names and

00:05:23,100 --> 00:05:27,000
various levels of indirection here's all

00:05:25,560 --> 00:05:28,890
lot of constants that the code object

00:05:27,000 --> 00:05:32,550
uses and now I need to go back to the

00:05:28,890 --> 00:05:34,890
slides so these objects they represent

00:05:32,550 --> 00:05:36,150
compiled Python code you know they're

00:05:34,890 --> 00:05:37,950
they're raw instructions for the

00:05:36,150 --> 00:05:39,720
interpreter their names constants

00:05:37,950 --> 00:05:42,360
metadata about that code that you

00:05:39,720 --> 00:05:45,110
defined and they're actually one of the

00:05:42,360 --> 00:05:47,490
really core primitive types in Python

00:05:45,110 --> 00:05:49,800
right and they're immutable which we'll

00:05:47,490 --> 00:05:51,180
get back to in a minute you never really

00:05:49,800 --> 00:05:52,500
see them and they should go looking for

00:05:51,180 --> 00:05:54,060
them but they're quite essential to

00:05:52,500 --> 00:05:56,410
everything that python does and they

00:05:54,060 --> 00:05:58,780
show up in a lot of different places

00:05:56,410 --> 00:06:01,060
here's an example doc PI C files you all

00:05:58,780 --> 00:06:05,980
seen them you know kind of vaguely what

00:06:01,060 --> 00:06:08,590
they're for okay so these are basically

00:06:05,980 --> 00:06:10,780
caches of your compiled bytecode that

00:06:08,590 --> 00:06:12,070
Python generates so that it doesn't have

00:06:10,780 --> 00:06:14,440
to pass your code over and over again

00:06:12,070 --> 00:06:17,320
what you may not know is that they're a

00:06:14,440 --> 00:06:19,510
really very simple file on the inside

00:06:17,320 --> 00:06:21,580
and there's three things right the first

00:06:19,510 --> 00:06:24,190
four bytes are a magic number which

00:06:21,580 --> 00:06:26,080
basically stops you from running PI C

00:06:24,190 --> 00:06:27,850
file from Python 2 on python 3 or

00:06:26,080 --> 00:06:29,890
something like that the next four bytes

00:06:27,850 --> 00:06:31,870
are a timestamp so that you can tell if

00:06:29,890 --> 00:06:33,760
your cache is out of date and the rest

00:06:31,870 --> 00:06:36,850
of the file is just a code object that I

00:06:33,760 --> 00:06:46,240
showed you before dumped out in a binary

00:06:36,850 --> 00:06:56,730
format where did my presentation go yeah

00:06:46,240 --> 00:06:56,730
thanks OpenOffice let's try that again

00:06:57,780 --> 00:07:11,050
where's though here we go yeah yeah have

00:07:06,490 --> 00:07:14,200
you ever used that one ok so anyway you

00:07:11,050 --> 00:07:16,360
can see that country if I grab the OS

00:07:14,200 --> 00:07:17,680
module for example and I have a look at

00:07:16,360 --> 00:07:19,620
the file that's been loaded from

00:07:17,680 --> 00:07:23,170
obviously that's loading from a cached

00:07:19,620 --> 00:07:25,180
bite go far right if I read the contents

00:07:23,170 --> 00:07:27,670
of that file in I can check here the

00:07:25,180 --> 00:07:29,920
first four bytes that's a magic number

00:07:27,670 --> 00:07:33,940
that Python knows about internally this

00:07:29,920 --> 00:07:35,440
is a 32-bit timestamp encoded in some

00:07:33,940 --> 00:07:38,770
Indian Miss that I don't recall off the

00:07:35,440 --> 00:07:42,070
top of my head and the remaining twenty

00:07:38,770 --> 00:07:45,280
six thousand bytes of this file I can do

00:07:42,070 --> 00:07:46,810
this to do you know about Marshall yes

00:07:45,280 --> 00:07:50,290
if you don't know about Marshall do you

00:07:46,810 --> 00:07:53,290
know about pickle yes so Marshall is

00:07:50,290 --> 00:07:55,120
basically a really fast pickle that only

00:07:53,290 --> 00:07:59,200
works with core Python data types like

00:07:55,120 --> 00:08:02,590
integers tuples and funnily enough code

00:07:59,200 --> 00:08:04,750
objects so the you know the entire body

00:08:02,590 --> 00:08:06,250
of that file is just you know imagine

00:08:04,750 --> 00:08:08,290
taking code object and dumping it out as

00:08:06,250 --> 00:08:09,409
Jason it's a similar sort of sort of

00:08:08,290 --> 00:08:11,749
idea

00:08:09,409 --> 00:08:20,419
and in fact if I create some new

00:08:11,749 --> 00:08:22,129
namespace and and I just load that

00:08:20,419 --> 00:08:24,559
straight out of the file and execute it

00:08:22,129 --> 00:08:25,939
in this empty namespace I will in fact

00:08:24,559 --> 00:08:28,639
get something that looks an awful lot

00:08:25,939 --> 00:08:30,499
like the built-in OS module and I could

00:08:28,639 --> 00:08:31,789
I could you know grab functions out of

00:08:30,499 --> 00:08:34,149
there and use them as if I just grabbed

00:08:31,789 --> 00:08:35,649
them off OS itself so code objects are

00:08:34,149 --> 00:08:37,879
everywhere

00:08:35,649 --> 00:08:40,610
there's this nifty little module called

00:08:37,879 --> 00:08:42,019
dis which stands for disassembler and it

00:08:40,610 --> 00:08:44,600
lets you have a peek at what's inside

00:08:42,019 --> 00:08:46,189
your code objects so here's a silly

00:08:44,600 --> 00:08:50,930
little very quickly typed the art

00:08:46,189 --> 00:08:53,600
function this is a very friendly I'm

00:08:50,930 --> 00:08:54,949
well a friendlier version of that little

00:08:53,600 --> 00:08:58,189
binary string that I showed you before

00:08:54,949 --> 00:08:59,329
and I'm gonna about to do a couple of

00:08:58,189 --> 00:09:00,980
slides that explain what all of this is

00:08:59,329 --> 00:09:02,720
but basically this is a series of

00:09:00,980 --> 00:09:04,910
instructions corresponding to the code

00:09:02,720 --> 00:09:07,610
for that function we load hello world as

00:09:04,910 --> 00:09:09,439
a constant we print it and then all

00:09:07,610 --> 00:09:10,579
functions return something right and if

00:09:09,439 --> 00:09:13,339
you don't return something you return

00:09:10,579 --> 00:09:15,529
none so we load none and return none and

00:09:13,339 --> 00:09:20,240
I think on it here's a more complicated

00:09:15,529 --> 00:09:27,170
example good oh my god did I get that

00:09:20,240 --> 00:09:29,329
right so this is a little loop and you

00:09:27,170 --> 00:09:30,589
know if you've done any assembly

00:09:29,329 --> 00:09:32,509
programming or something like this the

00:09:30,589 --> 00:09:32,870
ideas here will look pretty familiar all

00:09:32,509 --> 00:09:36,920
right

00:09:32,870 --> 00:09:40,220
we set up our variable X and then you

00:09:36,920 --> 00:09:42,259
know there's a bunch of stuff here about

00:09:40,220 --> 00:09:44,329
get either Florida and so forth and at

00:09:42,259 --> 00:09:46,459
the end of the loop there's a jump back

00:09:44,329 --> 00:09:48,949
to position 19 so you know these high

00:09:46,459 --> 00:09:50,959
levels control flow constructs compiled

00:09:48,949 --> 00:09:55,250
down to very low-level things like jumps

00:09:50,959 --> 00:09:56,630
and tests and this sort of thing so I've

00:09:55,250 --> 00:10:02,360
got a little bit more pull over about

00:09:56,630 --> 00:10:04,100
that on the actual slides good so the

00:10:02,360 --> 00:10:06,709
Python interpreter is quite a classic

00:10:04,100 --> 00:10:08,809
stack machine based VM right you've got

00:10:06,709 --> 00:10:10,279
this array of instructions which I just

00:10:08,809 --> 00:10:12,319
showed you a printout on you've got a

00:10:10,279 --> 00:10:14,420
pointer to where the next instruction is

00:10:12,319 --> 00:10:19,339
and you've got a big stack of objects

00:10:14,420 --> 00:10:20,779
that you push and pop things off of it's

00:10:19,339 --> 00:10:22,069
got a variety of different off codes

00:10:20,779 --> 00:10:23,180
some of which you saw there for

00:10:22,069 --> 00:10:24,830
manipulating the stack right

00:10:23,180 --> 00:10:26,660
you've got instructions they load some

00:10:24,830 --> 00:10:28,160
value onto the stack and it could be a

00:10:26,660 --> 00:10:29,930
constant you could be loading it from

00:10:28,160 --> 00:10:32,690
your global namespace you could be

00:10:29,930 --> 00:10:34,970
loading an attribute off off an item you

00:10:32,690 --> 00:10:37,100
can manipulate the stack in various ways

00:10:34,970 --> 00:10:39,020
you've got various ways to jump to

00:10:37,100 --> 00:10:41,180
different parts of the byte code and you

00:10:39,020 --> 00:10:42,590
know this basically what you use for an

00:10:41,180 --> 00:10:45,350
if statement or something like that you

00:10:42,590 --> 00:10:48,100
know jump to jump to another instruction

00:10:45,350 --> 00:10:51,190
if a certain if the top of stack is true

00:10:48,100 --> 00:10:53,390
and then there's this whole host of

00:10:51,190 --> 00:10:55,100
individual op codes dedicated to the

00:10:53,390 --> 00:10:57,290
primitive operations in Python so you

00:10:55,100 --> 00:10:59,210
say you know X plus y that gets the

00:10:57,290 --> 00:11:00,620
combines with binary add you say call

00:10:59,210 --> 00:11:02,780
this function that gets compiled to a

00:11:00,620 --> 00:11:06,050
call function so they're very high-level

00:11:02,780 --> 00:11:08,000
op codes that correspond quite directly

00:11:06,050 --> 00:11:12,770
to the things that you do in the Python

00:11:08,000 --> 00:11:15,140
program a lot of them so this is hello

00:11:12,770 --> 00:11:16,850
world then step-by-step from the point

00:11:15,140 --> 00:11:19,820
of view of the Python interpreter you've

00:11:16,850 --> 00:11:22,010
got that string of op codes printed out

00:11:19,820 --> 00:11:23,510
very friendly like and they reference

00:11:22,010 --> 00:11:25,130
various objects that live in the

00:11:23,510 --> 00:11:28,520
interpreters namespace and just says

00:11:25,130 --> 00:11:29,750
look you like load load the constant

00:11:28,520 --> 00:11:31,760
hello world that gets pushed onto the

00:11:29,750 --> 00:11:34,040
stack print that out cell gets popped

00:11:31,760 --> 00:11:36,260
off again it prints out a new line it

00:11:34,040 --> 00:11:38,210
loads the return value pops it back off

00:11:36,260 --> 00:11:39,620
again and you know more complicated

00:11:38,210 --> 00:11:44,390
functions get a lot more complicated but

00:11:39,620 --> 00:11:45,710
that's the basic idea so the source so

00:11:44,390 --> 00:11:47,420
you can imagine that that's sort of

00:11:45,710 --> 00:11:49,190
seriously this is a check out of C

00:11:47,420 --> 00:11:51,680
Python drunk you can imagine that that's

00:11:49,190 --> 00:11:53,030
sort of a structure it would be quite

00:11:51,680 --> 00:11:54,350
easy to write a little dumb little

00:11:53,030 --> 00:11:56,450
interpreter for that right you need a

00:11:54,350 --> 00:11:58,220
pointer to the current opcode you need a

00:11:56,450 --> 00:12:00,200
pointer to the top of stack and you need

00:11:58,220 --> 00:12:02,300
a big switch statement around all of the

00:12:00,200 --> 00:12:04,840
op codes to say it yeah if I hit pop top

00:12:02,300 --> 00:12:07,820
I do this what you know so this is

00:12:04,840 --> 00:12:12,100
execute compiled code I love that to do

00:12:07,820 --> 00:12:12,100
speed up this and that and and whatnot

00:12:13,750 --> 00:12:18,740
and remember where to jump through for

00:12:15,890 --> 00:12:20,060
this this is the function deep down in

00:12:18,740 --> 00:12:23,270
the middle of Python that executes your

00:12:20,060 --> 00:12:24,830
code right and you can see it's got it

00:12:23,270 --> 00:12:27,410
it's got a variable for the current

00:12:24,830 --> 00:12:29,220
opcode you know it's got a variable for

00:12:27,410 --> 00:12:30,899
the top of the stack and it's got

00:12:29,220 --> 00:12:34,069
various temporary variables it can use

00:12:30,899 --> 00:12:36,870
it's got a whole lot of stuff about

00:12:34,069 --> 00:12:38,430
making things go fast which are really

00:12:36,870 --> 00:12:43,079
interesting but I'm not going to do it

00:12:38,430 --> 00:12:44,819
here but down here in the guts of this

00:12:43,079 --> 00:12:48,060
function there really is just a big

00:12:44,819 --> 00:12:49,290
switch on the up code which by virtue of

00:12:48,060 --> 00:12:51,060
these macros gets compiled into

00:12:49,290 --> 00:12:52,379
something a lot fancy huh but it is you

00:12:51,060 --> 00:12:54,079
know if the next top code is this

00:12:52,379 --> 00:12:57,300
through this if it's a load fast to this

00:12:54,079 --> 00:12:58,560
so the core of that very simple

00:12:57,300 --> 00:12:59,910
interpreter structure is still very much

00:12:58,560 --> 00:13:02,490
there in the source and I think that's a

00:12:59,910 --> 00:13:04,199
great feature of C path and that the

00:13:02,490 --> 00:13:08,310
ideas inside that interpreter are very

00:13:04,199 --> 00:13:09,139
approachable now do you need to know

00:13:08,310 --> 00:13:12,420
this stuff

00:13:09,139 --> 00:13:13,889
probably not you will quite happily be a

00:13:12,420 --> 00:13:15,240
very productive Python program and

00:13:13,889 --> 00:13:17,759
without ever seeing the words code

00:13:15,240 --> 00:13:19,500
object printed into your screen but I

00:13:17,759 --> 00:13:20,910
believe that understanding it will make

00:13:19,500 --> 00:13:22,470
you a better programmer because it helps

00:13:20,910 --> 00:13:24,540
you to understand why various things

00:13:22,470 --> 00:13:26,610
happen and I'm going back over here to

00:13:24,540 --> 00:13:29,009
do a little timing demo I'm going to

00:13:26,610 --> 00:13:32,430
define two really stupid functions that

00:13:29,009 --> 00:13:34,319
don't do anything but spin for a while

00:13:32,430 --> 00:13:36,120
one of them uses this while one

00:13:34,319 --> 00:13:38,610
constructor aren't and the other one is

00:13:36,120 --> 00:13:43,079
exactly the same except that has wild

00:13:38,610 --> 00:13:45,180
truth now question which one of you yeah

00:13:43,079 --> 00:13:47,129
I know I'm about to bring that up which

00:13:45,180 --> 00:13:48,660
this is Python - which of these

00:13:47,129 --> 00:13:51,269
functions do you think will run faster

00:13:48,660 --> 00:13:55,439
the top line correct so if I grab timer

00:13:51,269 --> 00:13:58,350
and stop there we go that runs pretty

00:13:55,439 --> 00:14:00,689
quick if I run while true that is

00:13:58,350 --> 00:14:03,600
appreciable slower well that's not just

00:14:00,689 --> 00:14:05,639
noise that is appreciable slower the key

00:14:03,600 --> 00:14:07,319
to what's going on here is in the black

00:14:05,639 --> 00:14:10,740
code so if I have a look at what's going

00:14:07,319 --> 00:14:12,420
on inside while true have a look at line

00:14:10,740 --> 00:14:14,519
three where we're setting up our loop

00:14:12,420 --> 00:14:17,459
the very first thing we do is load the

00:14:14,519 --> 00:14:19,860
global variable named true and if that

00:14:17,459 --> 00:14:24,389
happens to be false we jump out of the

00:14:19,860 --> 00:14:26,399
loop okay which seems silly and Python

00:14:24,389 --> 00:14:28,740
isn't really that silly if I have a look

00:14:26,399 --> 00:14:31,050
inside while one at set up loop that's

00:14:28,740 --> 00:14:32,670
gone it doesn't say load one and if one

00:14:31,050 --> 00:14:35,490
is false jumps at the end of the loop

00:14:32,670 --> 00:14:37,139
right the reason that while true is

00:14:35,490 --> 00:14:38,939
slower than while one is in case some

00:14:37,139 --> 00:14:39,560
idiot like me comes along and does of

00:14:38,939 --> 00:14:41,390
this in the

00:14:39,560 --> 00:14:44,750
of your code and that will terminate

00:14:41,390 --> 00:14:47,410
straightaway in Python 3 they made the

00:14:44,750 --> 00:14:49,610
very good step of making true and false

00:14:47,410 --> 00:14:51,440
keywords so you can't do this anymore

00:14:49,610 --> 00:14:55,820
and both of those will run equivalently

00:14:51,440 --> 00:15:03,650
fast in Titan 2 - 3 good how am I going

00:14:55,820 --> 00:15:05,360
for time man good ok this is yeah now

00:15:03,650 --> 00:15:08,690
that we know about all of this let's

00:15:05,360 --> 00:15:11,720
have some fun if you want to play around

00:15:08,690 --> 00:15:16,220
with pythons bytecode format here is a

00:15:11,720 --> 00:15:17,870
piece of advice install by play and if

00:15:16,220 --> 00:15:20,180
this is the very first thing that you

00:15:17,870 --> 00:15:21,680
want to do because code objects in and

00:15:20,180 --> 00:15:23,779
of themselves they're designed to be

00:15:21,680 --> 00:15:25,640
executed they're designed to be executed

00:15:23,779 --> 00:15:26,990
efficiently they are not designed to be

00:15:25,640 --> 00:15:29,630
tampered around with and poked around

00:15:26,990 --> 00:15:31,700
with if you go into your raffle and type

00:15:29,630 --> 00:15:33,950
help types code type you will be greeted

00:15:31,700 --> 00:15:35,779
with the following message create a code

00:15:33,950 --> 00:15:38,150
object not for the faint of heart

00:15:35,779 --> 00:15:40,040
which should be a pretty good warning

00:15:38,150 --> 00:15:42,170
sign that you know you're not meant to

00:15:40,040 --> 00:15:43,700
tread here and in fact look at all of

00:15:42,170 --> 00:15:45,380
these crazy things that you have to

00:15:43,700 --> 00:15:50,210
supply to the constructor of the code

00:15:45,380 --> 00:15:51,710
object line number table exactly some of

00:15:50,210 --> 00:15:53,870
these things include account of the

00:15:51,710 --> 00:15:55,760
positional arguments including arguments

00:15:53,870 --> 00:15:57,500
that have default values at super

00:15:55,760 --> 00:16:00,080
containing the names of local variables

00:15:57,500 --> 00:16:02,210
referenced by nested functions the

00:16:00,080 --> 00:16:04,490
required stack size including local

00:16:02,210 --> 00:16:06,170
variables which requires you to know the

00:16:04,490 --> 00:16:09,860
stack effects of all of the opcodes in

00:16:06,170 --> 00:16:11,390
your bytecode and yeah a string encoding

00:16:09,860 --> 00:16:13,190
their mapping from byte code objects to

00:16:11,390 --> 00:16:18,020
line numbers for details see the source

00:16:13,190 --> 00:16:20,150
of the interpreter by play hides all of

00:16:18,020 --> 00:16:21,710
these details it gets them right well

00:16:20,150 --> 00:16:24,190
right enough that you can you know be

00:16:21,710 --> 00:16:26,060
productive with it so yeah you want it

00:16:24,190 --> 00:16:29,720
let's pop back over here and have some

00:16:26,060 --> 00:16:32,660
fun so here we go from by play input

00:16:29,720 --> 00:16:35,450
star and here is a simple little hello

00:16:32,660 --> 00:16:38,330
world right it does its thing it prints

00:16:35,450 --> 00:16:42,800
out hello let's make it do something

00:16:38,330 --> 00:16:44,839
else let me just move that well I play

00:16:42,800 --> 00:16:47,660
has this object called code alright and

00:16:44,839 --> 00:16:50,330
you can instantiate a byte play code

00:16:47,660 --> 00:16:52,340
object from a Python level code

00:16:50,330 --> 00:16:54,560
right we get see is now a code object

00:16:52,340 --> 00:16:56,990
that we can play around with and here it

00:16:54,560 --> 00:17:00,680
is by play doc code and here is the

00:16:56,990 --> 00:17:02,090
corresponding set of byte codes so this

00:17:00,680 --> 00:17:05,030
is what you saw before for hello world

00:17:02,090 --> 00:17:07,040
right load cons hello world it's a list

00:17:05,030 --> 00:17:09,320
of tuples or lob codes in their

00:17:07,040 --> 00:17:11,390
arguments so for example print doesn't

00:17:09,320 --> 00:17:12,860
have an argument so it gets none load

00:17:11,390 --> 00:17:16,040
const has an argument so we give it

00:17:12,860 --> 00:17:17,930
hello world if i go in here and just say

00:17:16,040 --> 00:17:21,340
look instead of that load cons hello

00:17:17,930 --> 00:17:23,990
world let's load a different constant

00:17:21,340 --> 00:17:25,820
will turn this white play level code

00:17:23,990 --> 00:17:27,320
object back into a python level code

00:17:25,820 --> 00:17:28,430
object and this is a fun thing about

00:17:27,320 --> 00:17:30,620
functions is that they're quite happy

00:17:28,430 --> 00:17:32,960
for you to just replace their code

00:17:30,620 --> 00:17:34,730
object out from under them and then yeah

00:17:32,960 --> 00:17:36,500
when we run that function it's going to

00:17:34,730 --> 00:17:39,200
run our new byte code and and print out

00:17:36,500 --> 00:17:42,320
something totally different and so what

00:17:39,200 --> 00:17:43,880
I want to do and I believe yep good what

00:17:42,320 --> 00:17:46,280
I want to do is fix up while true for

00:17:43,880 --> 00:17:49,460
you at the moment okay so we're going to

00:17:46,280 --> 00:17:51,320
define a little decorator which gifts

00:17:49,460 --> 00:17:52,970
you know which basically says let's not

00:17:51,320 --> 00:17:55,130
be stupid people aren't going to change

00:17:52,970 --> 00:17:58,520
the values of our built-ins out from

00:17:55,130 --> 00:17:59,960
under us and if I get a function I can

00:17:58,520 --> 00:18:01,610
apply this decorator to it I'm going to

00:17:59,960 --> 00:18:03,470
rip it to byte code out into something I

00:18:01,610 --> 00:18:05,300
can play with and I am going to walk

00:18:03,470 --> 00:18:06,740
over all of the byte codes in that

00:18:05,300 --> 00:18:09,380
function so I just go through that list

00:18:06,740 --> 00:18:11,780
one at a time if I come across something

00:18:09,380 --> 00:18:13,520
that is a load global statement and that

00:18:11,780 --> 00:18:15,830
happens to be something that is in the

00:18:13,520 --> 00:18:17,990
set of Python built-ins then I'm going

00:18:15,830 --> 00:18:19,910
to replace that with a direct load of

00:18:17,990 --> 00:18:22,030
that value and I just load it straight

00:18:19,910 --> 00:18:22,030
away

00:18:22,120 --> 00:18:27,560
yep put that code back on there and that

00:18:26,060 --> 00:18:29,510
works there's a nice little decorator so

00:18:27,560 --> 00:18:34,550
this is what well tree used to look like

00:18:29,510 --> 00:18:35,300
I can apply this little trick and we

00:18:34,550 --> 00:18:37,280
have an improvement

00:18:35,300 --> 00:18:39,080
all right we've eliminated this constant

00:18:37,280 --> 00:18:40,550
looking up of the name true in the in

00:18:39,080 --> 00:18:42,230
the global context and that's still

00:18:40,550 --> 00:18:43,280
slower than while one used to be and if

00:18:42,230 --> 00:18:45,620
you have a look at the bytecode

00:18:43,280 --> 00:18:46,790
we are doing something a little bit

00:18:45,620 --> 00:18:48,740
stupider because we're loading a

00:18:46,790 --> 00:18:50,090
constant true and checking to see if

00:18:48,740 --> 00:18:51,530
it's false and jumping out if it's not

00:18:50,090 --> 00:18:53,960
so what we really need to do is get rid

00:18:51,530 --> 00:18:56,720
of this dead jump okay the move dead

00:18:53,960 --> 00:18:58,610
jumps same thing again we're going to

00:18:56,720 --> 00:18:59,750
grab that code up to that code and have

00:18:58,610 --> 00:19:01,190
a look at it and this time we're going

00:18:59,750 --> 00:19:04,580
to iterate over pairs

00:19:01,190 --> 00:19:07,880
of consecutive up codes so if the opcode

00:19:04,580 --> 00:19:10,580
position I is a load Const of something

00:19:07,880 --> 00:19:12,290
true and the opcode at position I plus

00:19:10,580 --> 00:19:14,030
one happens to be pop jump if false

00:19:12,290 --> 00:19:16,400
we're just going to delete them because

00:19:14,030 --> 00:19:17,900
that will never get executed okay and

00:19:16,400 --> 00:19:20,630
obviously in the real world you could

00:19:17,900 --> 00:19:24,010
have a lot more cases here you know pop

00:19:20,630 --> 00:19:27,740
jump if true springs to mind

00:19:24,010 --> 00:19:29,060
that's it return the function how many

00:19:27,740 --> 00:19:32,480
people write decorators and forget to

00:19:29,060 --> 00:19:37,340
return the function yeah took me few

00:19:32,480 --> 00:19:39,770
tries to get this right yep and if we

00:19:37,340 --> 00:19:41,300
apply time and again we're now getting

00:19:39,770 --> 00:19:43,160
essentially the same result that we

00:19:41,300 --> 00:19:44,930
would got if Python could apply these

00:19:43,160 --> 00:19:46,430
optimizations natively so that's the

00:19:44,930 --> 00:19:47,600
sort of fun you can have with this sort

00:19:46,430 --> 00:19:48,860
of thing and you can see that we've now

00:19:47,600 --> 00:19:50,690
got rid of all of that unnecessary

00:19:48,860 --> 00:19:54,440
testing and loading at the start of the

00:19:50,690 --> 00:19:56,660
function okay back to the slides yeah so

00:19:54,440 --> 00:19:58,910
that's a you know that's a taste of some

00:19:56,660 --> 00:20:04,220
of the fun stuff you can do don't do

00:19:58,910 --> 00:20:06,080
this to me good excellent so I have a

00:20:04,220 --> 00:20:08,750
bunch of projects that kind of try and

00:20:06,080 --> 00:20:09,830
take this and do fun things with it one

00:20:08,750 --> 00:20:11,510
of them is called promise which is

00:20:09,830 --> 00:20:14,990
basically those optimizations I showed

00:20:11,510 --> 00:20:16,760
you writ large so this is basically that

00:20:14,990 --> 00:20:18,380
you say this this name keeps getting

00:20:16,760 --> 00:20:20,870
looked up look I promise you that the

00:20:18,380 --> 00:20:23,330
built-ins are constant fine you know

00:20:20,870 --> 00:20:24,620
make the necessary adjustments to to my

00:20:23,330 --> 00:20:26,960
code to make it run faster in the

00:20:24,620 --> 00:20:28,520
context of this promise and that will

00:20:26,960 --> 00:20:31,880
make the replacements that I just showed

00:20:28,520 --> 00:20:34,760
you and optimize that code to be only

00:20:31,880 --> 00:20:36,380
looked at once with ax I did at PyCon

00:20:34,760 --> 00:20:37,970
last year and it's still one of my

00:20:36,380 --> 00:20:40,190
favorites because you can do all sorts

00:20:37,970 --> 00:20:41,840
of wacky stuff that makes people you

00:20:40,190 --> 00:20:44,750
know things worse about what they know

00:20:41,840 --> 00:20:47,300
about Python so this is a namespace hack

00:20:44,750 --> 00:20:48,980
and if I have an object right I can do

00:20:47,300 --> 00:20:50,900
this little declaration I can say with

00:20:48,980 --> 00:20:53,030
you know using this object as a

00:20:50,900 --> 00:20:55,010
namespace execute the following code and

00:20:53,030 --> 00:20:56,450
that x and y won't actually appear in

00:20:55,010 --> 00:20:58,760
your local variables that will then

00:20:56,450 --> 00:21:00,530
appear as attributes on this object so

00:20:58,760 --> 00:21:02,870
it's intercepted the bytecode and

00:21:00,530 --> 00:21:04,400
rewritten it to set the attributes

00:21:02,870 --> 00:21:05,990
instead of set local variables and

00:21:04,400 --> 00:21:08,060
there's a whole nother level of evil

00:21:05,990 --> 00:21:09,200
behind that which I can get into if we

00:21:08,060 --> 00:21:12,200
have time

00:21:09,200 --> 00:21:13,700
I did add in line last year as well and

00:21:12,200 --> 00:21:16,789
this is basically the idea that look

00:21:13,700 --> 00:21:18,139
function calls are expensive so this

00:21:16,789 --> 00:21:19,159
function was going to be called a bunch

00:21:18,139 --> 00:21:21,409
of times in a loop

00:21:19,159 --> 00:21:23,149
wouldn't it be great if I could like and

00:21:21,409 --> 00:21:24,950
see like you know mark your functions as

00:21:23,149 --> 00:21:26,690
in line when you just say this function

00:21:24,950 --> 00:21:28,789
that gets called a lot it's probably

00:21:26,690 --> 00:21:31,010
worth putting the code directly inside

00:21:28,789 --> 00:21:32,840
you know where it's going to be executed

00:21:31,010 --> 00:21:35,000
and you can construct this little

00:21:32,840 --> 00:21:37,100
decorator that does the necessary magic

00:21:35,000 --> 00:21:38,510
to pull out the function call by a code

00:21:37,100 --> 00:21:41,090
and replace it with the blank code of

00:21:38,510 --> 00:21:44,510
the function itself there's lots of fun

00:21:41,090 --> 00:21:46,340
corner cases to be had in there what I

00:21:44,510 --> 00:21:50,330
really came here to say is actually no

00:21:46,340 --> 00:21:52,429
that's probably not the best idea I I

00:21:50,330 --> 00:21:54,769
love to muck around with this stuff and

00:21:52,429 --> 00:21:56,690
I think it really helps understanding

00:21:54,769 --> 00:21:58,820
your tools you know it will make you a

00:21:56,690 --> 00:22:00,409
better Python programmer bus I've never

00:21:58,820 --> 00:22:02,990
deployed a bytecode hacking to

00:22:00,409 --> 00:22:06,049
production code ever I've deployed a few

00:22:02,990 --> 00:22:09,380
frame hacks into production code but so

00:22:06,049 --> 00:22:12,519
has the Python interpreter look at look

00:22:09,380 --> 00:22:14,929
at the source for names Drupal sometime

00:22:12,519 --> 00:22:16,250
so yeah seriously this is fun to play

00:22:14,929 --> 00:22:18,019
with but probably not the best study

00:22:16,250 --> 00:22:19,070
it'll work in production but you're

00:22:18,019 --> 00:22:22,210
setting yourself up for a maintenance

00:22:19,070 --> 00:22:24,649
nightmare so for learning purposes only

00:22:22,210 --> 00:22:26,179
yeah thank you very much I love to talk

00:22:24,649 --> 00:22:27,649
about this stuff and if you're

00:22:26,179 --> 00:22:31,460
interested in some of the projects using

00:22:27,649 --> 00:22:33,289
this they're on my github this is the

00:22:31,460 --> 00:22:34,789
module for looking at byte code and it's

00:22:33,289 --> 00:22:37,580
got you know documentation of what all

00:22:34,789 --> 00:22:40,250
the votes are and yeah if you're

00:22:37,580 --> 00:22:42,260
interested in having as friendly a live

00:22:40,250 --> 00:22:43,789
coding experience as I had in this tool

00:22:42,260 --> 00:22:45,679
get play a piano and use it for all of

00:22:43,789 --> 00:22:47,059
your presentations there's basically a

00:22:45,679 --> 00:22:49,250
little fake Python shell that you can

00:22:47,059 --> 00:22:52,000
type into and play stuff out so yeah

00:22:49,250 --> 00:22:52,000
thank you very kindly

00:22:57,780 --> 00:23:03,910
now someone else I'll be nice

00:23:01,690 --> 00:23:07,000
well nice to you but probably not nice

00:23:03,910 --> 00:23:09,490
to Nick so given that we have super yep

00:23:07,000 --> 00:23:12,520
in Python which is you know its own kind

00:23:09,490 --> 00:23:18,430
of evil why can't we have namespace in

00:23:12,520 --> 00:23:20,680
pytho I can't we yeah what we can you

00:23:18,430 --> 00:23:22,630
can help me with the pep how much time

00:23:20,680 --> 00:23:25,540
have we gotten up five minutes that's

00:23:22,630 --> 00:23:27,370
long enough to write a pic no I was

00:23:25,540 --> 00:23:28,900
going to show you this other thing but

00:23:27,370 --> 00:23:38,560
maybe I'll just prep that well people

00:23:28,900 --> 00:23:41,260
have asked questions I'm just wondering

00:23:38,560 --> 00:23:44,050
um the the bike code in Python that's

00:23:41,260 --> 00:23:45,580
not part of the official specification

00:23:44,050 --> 00:23:48,160
of French is that correct correct yes

00:23:45,580 --> 00:23:51,370
obviously I believe that Piper uses a

00:23:48,160 --> 00:23:52,960
similar format but they have some of

00:23:51,370 --> 00:23:54,760
their own op codes and stuff and it's

00:23:52,960 --> 00:23:56,830
it's not even guaranteed not to change

00:23:54,760 --> 00:23:58,480
in backwards incompatible ways between

00:23:56,830 --> 00:24:00,760
different versions of the interpreter

00:23:58,480 --> 00:24:02,790
which is why your PI C files have that

00:24:00,760 --> 00:24:07,030
magic number sorry

00:24:02,790 --> 00:24:08,590
exactly so yeah as Nick says there's new

00:24:07,030 --> 00:24:09,910
stuff with the ist that you can muck

00:24:08,590 --> 00:24:11,680
around that at a slightly higher level

00:24:09,910 --> 00:24:13,570
as well but then again that's not

00:24:11,680 --> 00:24:15,670
guaranteed as a part of that does that

00:24:13,570 --> 00:24:17,770
mean that the disk module essentially

00:24:15,670 --> 00:24:19,090
can print anything because when the byte

00:24:17,770 --> 00:24:23,820
code changes its out what could be

00:24:19,090 --> 00:24:27,940
completely different is that I mean it's

00:24:23,820 --> 00:24:29,140
usually not yeah but yeah you probably

00:24:27,940 --> 00:24:30,280
don't want to we were just having a

00:24:29,140 --> 00:24:31,330
conversation about this with me you

00:24:30,280 --> 00:24:32,530
probably don't want to depend on the

00:24:31,330 --> 00:24:35,350
output of the disk module for anything

00:24:32,530 --> 00:24:39,570
except learning purposes yeah don't

00:24:35,350 --> 00:24:39,570
don't do that don't do that okay

00:24:42,810 --> 00:24:50,770
so this how I'm the psychic module works

00:24:45,930 --> 00:24:53,080
lord I hope not no no

00:24:50,770 --> 00:24:55,300
so ICO is a very different beast I mean

00:24:53,080 --> 00:24:57,100
that generates assembly right and x86

00:24:55,300 --> 00:24:59,530
assembly all the way down but I imagine

00:24:57,100 --> 00:25:01,780
that it starts from where I've got to

00:24:59,530 --> 00:25:02,860
here with the bio codes and then you

00:25:01,780 --> 00:25:05,350
know it does a whole nother level to

00:25:02,860 --> 00:25:07,630
turn that into assembly deep down that

00:25:05,350 --> 00:25:12,750
yeah I've never I've never Peaks beneath

00:25:07,630 --> 00:25:12,750
the covers of of psycho might be one day

00:25:13,860 --> 00:25:23,980
anybody else since you brought up super

00:25:19,060 --> 00:25:26,110
Richard yeah you can actually get the

00:25:23,980 --> 00:25:28,350
awesome zero argument super from part

00:25:26,110 --> 00:25:30,970
and three instead of this awful

00:25:28,350 --> 00:25:32,920
redundant repeating yourself toughen in

00:25:30,970 --> 00:25:35,140
Python to a lot of people think that you

00:25:32,920 --> 00:25:36,760
can get away with doing this well just

00:25:35,140 --> 00:25:38,470
look up the class object on on the

00:25:36,760 --> 00:25:40,720
object itself that's very very wrong

00:25:38,470 --> 00:25:42,730
self doesn't have enough information to

00:25:40,720 --> 00:25:45,610
figure out how it should call super

00:25:42,730 --> 00:25:47,230
properly and by it doesn't you know I

00:25:45,610 --> 00:25:48,190
doesn't have enough information what I

00:25:47,230 --> 00:25:51,750
mean is doesn't provide enough

00:25:48,190 --> 00:25:54,490
information in the friendly public API

00:25:51,750 --> 00:25:56,350
what you can do is reach back into the

00:25:54,490 --> 00:25:58,120
calling frame figure out what the name

00:25:56,350 --> 00:25:59,710
of the first variable is and then read

00:25:58,120 --> 00:26:02,320
it from the frames local variables to

00:25:59,710 --> 00:26:04,270
get self and then walk the mro of the

00:26:02,320 --> 00:26:06,310
object that you just found to see which

00:26:04,270 --> 00:26:07,630
of the classes along that mro contains

00:26:06,310 --> 00:26:09,550
the code object that you're currently

00:26:07,630 --> 00:26:11,140
executing which is the fact which is the

00:26:09,550 --> 00:26:13,600
class that that function was defined in

00:26:11,140 --> 00:26:16,930
and then you just call super normally or

00:26:13,600 --> 00:26:19,090
yeah panic and raise a runtime error so

00:26:16,930 --> 00:26:21,040
there's that much code will get you 0

00:26:19,090 --> 00:26:23,710
arguments super important too if you

00:26:21,040 --> 00:26:25,120
dare and while you in there you might as

00:26:23,710 --> 00:26:27,100
well grab the name of the method that

00:26:25,120 --> 00:26:28,840
you're executing and then you don't even

00:26:27,100 --> 00:26:30,580
have to write super at all you just say

00:26:28,840 --> 00:26:33,010
call my super method with the following

00:26:30,580 --> 00:26:35,250
arguments but yeah you probably don't to

00:26:33,010 --> 00:26:35,250
go there

00:26:37,100 --> 00:26:42,720
thank you that was going to be a

00:26:41,430 --> 00:27:08,580
lightning talk but the slots filled out

00:26:42,720 --> 00:27:12,660
too quickly sir okay we don't need more

00:27:08,580 --> 00:27:14,720
questions let's give Ryan show our

00:27:12,660 --> 00:27:14,720

YouTube URL: https://www.youtube.com/watch?v=ve7lLHtJ9l8


