Title: Pants - Network Programming Made Easy - Mr. Christopher Davis
Publication date: 2011-08-22
Playlist: PyCon Australia 2011
Description: 
	Pants (pantsweb.org) is an open source library that aims to make network programming in Python a breeze. This talk will outline challenges in network programming and how Pants approaches them. The audience will be briefly introduced to Pants' API through example code, and to its capabilities through benchmarks and comparisons with alternate frameworks..
Captions: 
	00:00:04,069 --> 00:00:10,440
alright thanks everyone yes this talk is

00:00:08,370 --> 00:00:13,820
pants networking program network

00:00:10,440 --> 00:00:16,080
programming made easy and pants is a

00:00:13,820 --> 00:00:18,480
framework / library that I've been

00:00:16,080 --> 00:00:21,630
working on for a little while which

00:00:18,480 --> 00:00:23,789
basically aims give give developers a

00:00:21,630 --> 00:00:26,430
really simple solution to network

00:00:23,789 --> 00:00:29,730
programming particularly servers that

00:00:26,430 --> 00:00:32,099
can also be used for clients so network

00:00:29,730 --> 00:00:34,980
programming in a sort of general sense

00:00:32,099 --> 00:00:37,440
consists of getting your application to

00:00:34,980 --> 00:00:40,230
talk to another application over a

00:00:37,440 --> 00:00:43,020
network such as the internet and in

00:00:40,230 --> 00:00:45,480
Python this is done using the pretty

00:00:43,020 --> 00:00:47,100
ubiquitous sockets API which is a sea

00:00:45,480 --> 00:00:50,160
library and it's part of the standard

00:00:47,100 --> 00:00:52,920
library as well in Python the thing

00:00:50,160 --> 00:00:54,960
about sockets is that the very low level

00:00:52,920 --> 00:00:56,250
and for someone that's not particularly

00:00:54,960 --> 00:00:59,910
familiar with them they can be quite

00:00:56,250 --> 00:01:01,949
difficult to use correctly so in much

00:00:59,910 --> 00:01:04,170
the same way that you would use a GUI

00:01:01,949 --> 00:01:06,270
framework rather than say a 2d graphics

00:01:04,170 --> 00:01:08,159
API to write a graphical application

00:01:06,270 --> 00:01:09,810
you'll often choose to use a networking

00:01:08,159 --> 00:01:13,170
framework rather than deal with sockets

00:01:09,810 --> 00:01:15,990
directly pants is such a networking

00:01:13,170 --> 00:01:17,330
framework there's a few buzzwords up

00:01:15,990 --> 00:01:21,000
there I'm going to go through them and

00:01:17,330 --> 00:01:23,189
explain what they mean so pants is a

00:01:21,000 --> 00:01:25,890
single-threaded which is fairly obvious

00:01:23,189 --> 00:01:29,130
all the work happens in a single thread

00:01:25,890 --> 00:01:32,880
of execution in a single process this

00:01:29,130 --> 00:01:35,250
has pros and cons but in many situations

00:01:32,880 --> 00:01:38,930
it's beneficial because multithreading

00:01:35,250 --> 00:01:42,630
can be particularly challenging at times

00:01:38,930 --> 00:01:44,220
it's asynchronous so what that means is

00:01:42,630 --> 00:01:46,049
that everything in parts happens

00:01:44,220 --> 00:01:49,229
sequentially there's no concurrency

00:01:46,049 --> 00:01:50,820
going on behind the scenes and in Python

00:01:49,229 --> 00:01:53,130
this is particularly useful because it

00:01:50,820 --> 00:01:55,799
helps helps you to build scalable

00:01:53,130 --> 00:02:01,409
applications with thousands of sockets

00:01:55,799 --> 00:02:03,390
going on at once it's event-driven that

00:02:01,409 --> 00:02:05,729
means every patent application has a

00:02:03,390 --> 00:02:07,890
main event loop and on eatin of the

00:02:05,729 --> 00:02:10,649
event loop all the sockets are checked

00:02:07,890 --> 00:02:12,520
for events such as reading writing new

00:02:10,649 --> 00:02:14,020
connections that sort of thing

00:02:12,520 --> 00:02:17,950
then parts handles them appropriately

00:02:14,020 --> 00:02:20,230
and finally it's callback oriented and

00:02:17,950 --> 00:02:21,550
this is probably the most important

00:02:20,230 --> 00:02:22,780
point for someone that's actually going

00:02:21,550 --> 00:02:24,330
to use the framework because it

00:02:22,780 --> 00:02:27,910
describes the way that your code

00:02:24,330 --> 00:02:30,250
interacts with it you define callbacks

00:02:27,910 --> 00:02:32,500
and then you link those callbacks to

00:02:30,250 --> 00:02:34,900
events so when a new connection is made

00:02:32,500 --> 00:02:38,290
you'll want to execute some segments of

00:02:34,900 --> 00:02:41,020
code when data is read from a socket you

00:02:38,290 --> 00:02:43,120
want to execute some block of code as

00:02:41,020 --> 00:02:44,530
well and this should be pretty this is a

00:02:43,120 --> 00:02:46,900
pretty familiar pattern to anyone that's

00:02:44,530 --> 00:02:49,930
ever done for instance any web

00:02:46,900 --> 00:02:51,940
programming it's its present in in the

00:02:49,930 --> 00:02:54,810
browser and in most GUI frameworks as

00:02:51,940 --> 00:02:58,270
well this isn't the only way to do

00:02:54,810 --> 00:03:01,840
network programming but I find it's

00:02:58,270 --> 00:03:03,340
pretty natural way to do it so just

00:03:01,840 --> 00:03:07,000
before I go on I'm just going to run

00:03:03,340 --> 00:03:09,430
through a very simple example that of an

00:03:07,000 --> 00:03:12,670
echo server for those unfamiliar with

00:03:09,430 --> 00:03:14,650
the concept and air kosova basically a

00:03:12,670 --> 00:03:16,270
client connects and any data they send

00:03:14,650 --> 00:03:24,900
to it just get sent straight back to

00:03:16,270 --> 00:03:29,800
them so the first thing I'm going to do

00:03:24,900 --> 00:03:32,500
is just import the API and then I'm

00:03:29,800 --> 00:03:35,220
going to define my class echo which is

00:03:32,500 --> 00:03:38,020
going to subclass this connection class

00:03:35,220 --> 00:03:40,570
has defines a number of classes

00:03:38,020 --> 00:03:42,400
connection being one of them that rap

00:03:40,570 --> 00:03:45,610
sockets and give you a sort of far more

00:03:42,400 --> 00:03:49,630
pleasant and suitable API for this

00:03:45,610 --> 00:03:52,930
particular type of design I'm then going

00:03:49,630 --> 00:03:54,970
to override the on read call back this

00:03:52,930 --> 00:03:59,740
is a method that gets called whenever

00:03:54,970 --> 00:04:01,120
data is read from this connection and as

00:03:59,740 --> 00:04:03,550
you can see it gets passed that single

00:04:01,120 --> 00:04:05,830
argument data which is the data that was

00:04:03,550 --> 00:04:08,500
read and i'm just going to write it

00:04:05,830 --> 00:04:11,739
straight back and that's all the

00:04:08,500 --> 00:04:13,420
application logic that I need so then

00:04:11,739 --> 00:04:15,100
I'm going to create a server and I just

00:04:13,420 --> 00:04:17,440
pass it in this class and I'm just

00:04:15,100 --> 00:04:20,590
telling server which is another one of

00:04:17,440 --> 00:04:23,710
Panthers built-in classes to use this

00:04:20,590 --> 00:04:26,050
echo class to wrap new connections and

00:04:23,710 --> 00:04:28,620
I'm going to tell it to listen for

00:04:26,050 --> 00:04:34,990
you can actions on a particular port and

00:04:28,620 --> 00:04:46,470
start the application and that's it now

00:04:34,990 --> 00:04:51,449
I should be able to run this connect to

00:04:46,470 --> 00:04:55,379
local host on the port I specified and

00:04:51,449 --> 00:05:04,360
anything I type gets echoed back to me

00:04:55,379 --> 00:05:07,150
OOP that's so that's a pretty simple

00:05:04,360 --> 00:05:09,129
example and pretty contrived but it

00:05:07,150 --> 00:05:10,780
demonstrates this the basic idea behind

00:05:09,129 --> 00:05:13,629
developing with parents which is that

00:05:10,780 --> 00:05:16,479
you define all your logic you then have

00:05:13,629 --> 00:05:17,860
some amount of initialization and then

00:05:16,479 --> 00:05:25,020
you start the event loop and the event

00:05:17,860 --> 00:05:27,909
loop runs until you stop it somehow so

00:05:25,020 --> 00:05:29,050
why use pants in particular for this

00:05:27,909 --> 00:05:31,029
sort of thing because there are many

00:05:29,050 --> 00:05:32,560
great alternatives I put three up there

00:05:31,029 --> 00:05:36,969
but there are countless numbers of

00:05:32,560 --> 00:05:38,440
networking frameworks for Python async

00:05:36,969 --> 00:05:41,590
law is obviously part of the standard

00:05:38,440 --> 00:05:44,860
library twisted massive library that I

00:05:41,590 --> 00:05:48,940
think most people would be aware of and

00:05:44,860 --> 00:05:52,690
event 'let somewhat less well-known

00:05:48,940 --> 00:05:54,729
library but pretty neat as well a sinker

00:05:52,690 --> 00:05:57,310
and twisted use the same callback

00:05:54,729 --> 00:05:58,870
oriented design that pants does event

00:05:57,310 --> 00:06:01,240
'let uses something that's more green

00:05:58,870 --> 00:06:03,580
lit oriented but under the hood it's

00:06:01,240 --> 00:06:08,529
still the same asynchronous event driven

00:06:03,580 --> 00:06:11,050
design when i wrote pants i was aiming

00:06:08,529 --> 00:06:14,430
to build something that i personally

00:06:11,050 --> 00:06:18,699
would want to use so i tried to make it

00:06:14,430 --> 00:06:20,529
simple safe and fast i wanted something

00:06:18,699 --> 00:06:22,620
that I could use to throw together

00:06:20,529 --> 00:06:27,210
applications really quickly without

00:06:22,620 --> 00:06:31,029
sacrificing performance or flexibility

00:06:27,210 --> 00:06:33,069
so it's simple not just in the way you

00:06:31,029 --> 00:06:35,440
use it but in the way it's written the

00:06:33,069 --> 00:06:40,060
core is very small it's under a thousand

00:06:35,440 --> 00:06:44,030
lines of code and it aims to just

00:06:40,060 --> 00:06:47,720
really cater to the most general use

00:06:44,030 --> 00:06:49,940
case in by default you can typically

00:06:47,720 --> 00:06:53,569
customize it to do more unusual things

00:06:49,940 --> 00:06:56,060
but I wanted something that would let me

00:06:53,569 --> 00:06:59,539
do that without having to specify all

00:06:56,060 --> 00:07:01,759
sorts of extra stuff like what host I

00:06:59,539 --> 00:07:04,789
want to listen on whether i want to TCP

00:07:01,759 --> 00:07:07,729
or UDP socket that sort of thing and I

00:07:04,789 --> 00:07:12,080
think I've achieved that what i mean by

00:07:07,729 --> 00:07:14,509
safety is that it completely in most

00:07:12,080 --> 00:07:17,780
cases covers the socket API so if you're

00:07:14,509 --> 00:07:18,979
not deeply familiar with sockets you

00:07:17,780 --> 00:07:20,810
don't have to worry about doing

00:07:18,979 --> 00:07:23,000
something that's going to cause problems

00:07:20,810 --> 00:07:24,500
at scale or that's going to you know

00:07:23,000 --> 00:07:26,960
bring down your application just because

00:07:24,500 --> 00:07:31,039
you weren't really aware of of what you

00:07:26,960 --> 00:07:33,740
had to do and I've managed to do that I

00:07:31,039 --> 00:07:36,080
feel without sacrificing too much

00:07:33,740 --> 00:07:43,460
performance although there is a bit of

00:07:36,080 --> 00:07:47,740
overhead involved so I'm just going to

00:07:43,460 --> 00:07:47,740
run through some further examples now

00:07:49,030 --> 00:08:00,639
the first one being what I'm going to

00:07:54,949 --> 00:08:00,639
call a message radar protocol

00:08:03,550 --> 00:08:08,479
so something that you'll very commonly

00:08:06,770 --> 00:08:12,560
want to do with a networking framework

00:08:08,479 --> 00:08:14,930
is write a server that sort of buffers

00:08:12,560 --> 00:08:17,300
data that it receives until it gets

00:08:14,930 --> 00:08:20,300
enough of a meaningful chunk to process

00:08:17,300 --> 00:08:28,669
it and pants makes it easy through the

00:08:20,300 --> 00:08:33,020
use of a sort of magical thing which can

00:08:28,669 --> 00:08:36,080
sometimes be dangerous but it's called a

00:08:33,020 --> 00:08:47,120
reed delimiter so you can basically tell

00:08:36,080 --> 00:08:53,209
pants I want to read two bytes or until

00:08:47,120 --> 00:08:55,610
I reach the next line break or whatever

00:08:53,209 --> 00:08:58,250
comes up and that will determine how

00:08:55,610 --> 00:09:00,560
data gets passed to that on Reed method

00:08:58,250 --> 00:09:02,779
that I demonstrated earlier so in this

00:09:00,560 --> 00:09:05,360
case I'm going to write a protocol that

00:09:02,779 --> 00:09:08,779
understands a very simple message format

00:09:05,360 --> 00:09:11,240
a variable length string preceded by two

00:09:08,779 --> 00:09:14,000
bytes which will interpret as an

00:09:11,240 --> 00:09:16,899
unsigned short describing the length of

00:09:14,000 --> 00:09:16,899
the message

00:09:21,779 --> 00:09:27,660
and what i'm doing here is sort of

00:09:23,310 --> 00:09:32,160
unusual but basically i'm replacing that

00:09:27,660 --> 00:09:34,129
on read call back at runtime with

00:09:32,160 --> 00:09:36,120
something else that I've defined here

00:09:34,129 --> 00:09:38,899
and for the moment I'm not going to put

00:09:36,120 --> 00:09:38,899
any logic in there

00:09:55,200 --> 00:10:02,790
so these two are basically doing the

00:09:58,250 --> 00:10:04,350
same thing just this is using a constant

00:10:02,790 --> 00:10:07,980
and this is getting the length of the

00:10:04,350 --> 00:10:13,200
message passed into it now when a new

00:10:07,980 --> 00:10:16,260
user connects I'm going to read the

00:10:13,200 --> 00:10:20,610
length of the first packet or message

00:10:16,260 --> 00:10:22,440
and so now when a chunk of two bytes

00:10:20,610 --> 00:10:29,750
comes in is going to get passed to this

00:10:22,440 --> 00:10:29,750
method on read length and I'll just

00:10:29,780 --> 00:10:45,000
interpret that or unpack that data to be

00:10:39,870 --> 00:10:48,680
an unsigned short and this struct is

00:10:45,000 --> 00:10:48,680
just part of the standard library

00:10:53,470 --> 00:11:02,750
and then when i get a message in this

00:11:01,460 --> 00:11:06,230
data is going to be whatever was

00:11:02,750 --> 00:11:10,370
specified in that two bites of length

00:11:06,230 --> 00:11:14,290
and we'll just print that out and then

00:11:10,370 --> 00:11:20,150
read the length of the next packet and

00:11:14,290 --> 00:11:23,740
then i'll just use the same the same

00:11:20,150 --> 00:11:23,740
initialization that i had there before

00:11:25,960 --> 00:11:37,540
start up the engine startup the event

00:11:29,630 --> 00:11:37,540
loop now that looks correct

00:11:43,510 --> 00:11:48,630
okay and I wrote something earlier

00:11:49,020 --> 00:11:54,550
that's going to send messages in this

00:11:52,330 --> 00:11:58,930
format that I've specified and this is

00:11:54,550 --> 00:12:00,790
an example of a client using pads and as

00:11:58,930 --> 00:12:03,820
you can see it's pretty much the same

00:12:00,790 --> 00:12:06,460
structure there's logic and there's

00:12:03,820 --> 00:12:17,220
initialization and then the event would

00:12:06,460 --> 00:12:17,220
get started up so if i run that

00:12:19,640 --> 00:12:25,010
you'll see our server has received the

00:12:22,400 --> 00:12:29,690
message and printed it out to the

00:12:25,010 --> 00:12:31,280
terminal now you can't really call

00:12:29,690 --> 00:12:33,350
yourself a networking library these days

00:12:31,280 --> 00:12:37,880
if you don't have an HTTP implementation

00:12:33,350 --> 00:12:43,000
so pants comes with one it's really

00:12:37,880 --> 00:12:43,000
straightforward and pretty awesome

00:12:50,829 --> 00:12:57,939
I'm just going to write a HelloWorld

00:12:54,939 --> 00:12:57,939
server

00:13:07,960 --> 00:13:17,400
so I'm just going to send the status 200

00:13:13,890 --> 00:13:17,400
send some headers

00:13:25,180 --> 00:13:30,660
and then send my response

00:13:35,030 --> 00:13:43,220
and then finish the request yes the HTTP

00:13:41,300 --> 00:13:44,810
server is a bit different to the regular

00:13:43,220 --> 00:13:46,790
server and that you pass it a function

00:13:44,810 --> 00:13:49,970
rather than a class you can pass it a

00:13:46,790 --> 00:13:55,900
callable class if you want it doesn't

00:13:49,970 --> 00:13:59,470
really make much difference but again

00:13:55,900 --> 00:14:06,610
same basic application structure logic

00:13:59,470 --> 00:14:06,610
initialization now

00:14:14,080 --> 00:14:20,380
there we go very straightforward and of

00:14:17,590 --> 00:14:23,050
course no Python networking library

00:14:20,380 --> 00:14:27,580
would be complete without a wsgi

00:14:23,050 --> 00:14:29,350
implementation so there's a wsj example

00:14:27,580 --> 00:14:32,170
it's not too different from the HTTP

00:14:29,350 --> 00:14:41,140
example there's just a little bit more

00:14:32,170 --> 00:14:43,180
overhead there so parents can do a lot

00:14:41,140 --> 00:14:46,030
and there's a lot sort of in the library

00:14:43,180 --> 00:14:50,260
already but at its core it's really a

00:14:46,030 --> 00:14:54,040
generic networking solution so you'll

00:14:50,260 --> 00:14:56,200
see I imported stuff from a contrib

00:14:54,040 --> 00:14:57,940
package here everything that's in the

00:14:56,200 --> 00:15:02,010
sort of root package is just really

00:14:57,940 --> 00:15:12,340
basic stuff for TCP and UDP networking

00:15:02,010 --> 00:15:16,150
using internet and unix sockets part of

00:15:12,340 --> 00:15:18,490
the sort of coincidentally impressive

00:15:16,150 --> 00:15:21,850
part of paths is its performance

00:15:18,490 --> 00:15:24,010
compared to other frameworks we use

00:15:21,850 --> 00:15:28,420
benchmarking is tool not only to gauge

00:15:24,010 --> 00:15:30,490
performance but also to test the test

00:15:28,420 --> 00:15:33,520
the capability of the of the framework

00:15:30,490 --> 00:15:35,710
under strain and here's a comparison of

00:15:33,520 --> 00:15:38,110
pants to some other networking

00:15:35,710 --> 00:15:42,400
frameworks in Python up at the top we've

00:15:38,110 --> 00:15:45,310
got a sink or which is amazingly fast

00:15:42,400 --> 00:15:47,740
really but it's sort of getting a bit

00:15:45,310 --> 00:15:49,330
old it's using some not so modern

00:15:47,740 --> 00:15:51,400
technologies and it falls over under

00:15:49,330 --> 00:15:53,500
particularly heavy strain when there's

00:15:51,400 --> 00:15:55,600
many thousands of sockets connected to

00:15:53,500 --> 00:15:57,220
it whereas these other four they use

00:15:55,600 --> 00:16:00,190
modern technologies that can handle many

00:15:57,220 --> 00:16:03,430
thousands of connections so as you can

00:16:00,190 --> 00:16:06,130
see this is what we call the UM the fake

00:16:03,430 --> 00:16:08,320
HTTP benchmark where we've just written

00:16:06,130 --> 00:16:10,210
a little server that returns a

00:16:08,320 --> 00:16:11,830
prefabricated HTTP response without

00:16:10,210 --> 00:16:15,100
actually processing anything that it

00:16:11,830 --> 00:16:17,230
gets and in under this scenario pat's is

00:16:15,100 --> 00:16:18,880
delivering a little over twenty thousand

00:16:17,230 --> 00:16:21,790
requests a second power response as a

00:16:18,880 --> 00:16:23,920
second and other frameworks are doing

00:16:21,790 --> 00:16:26,649
really well as well there's event lit

00:16:23,920 --> 00:16:29,160
twisted and tornado there

00:16:26,649 --> 00:16:33,189
the HTTP implementation is also

00:16:29,160 --> 00:16:35,670
extremely fast that's it compared to

00:16:33,189 --> 00:16:38,980
tornado and twisted using keeper life as

00:16:35,670 --> 00:16:40,749
you can see it's processing requests at

00:16:38,980 --> 00:16:44,259
extreme and an extremely fast rate

00:16:40,749 --> 00:16:46,089
that's it taking a request pausing and

00:16:44,259 --> 00:16:48,459
processing it and then returning a

00:16:46,089 --> 00:16:50,079
prefabricated response again so it's not

00:16:48,459 --> 00:16:52,449
really doing much work but it's nearing

00:16:50,079 --> 00:16:58,689
10,000 requests a second there compared

00:16:52,449 --> 00:17:04,390
to 20 doze 5,000 and twisted 3,000 or

00:16:58,689 --> 00:17:07,679
thereabouts and the wsgi part displays

00:17:04,390 --> 00:17:07,679
similar characteristics

00:17:13,939 --> 00:17:18,889
now I seem to have run a little fast

00:17:16,720 --> 00:17:22,339
that's all i really had planned to say

00:17:18,889 --> 00:17:24,559
unfortunately thanks for coming and

00:17:22,339 --> 00:17:26,480
listening pants hasn't had much exposure

00:17:24,559 --> 00:17:28,220
really because it's just been something

00:17:26,480 --> 00:17:29,629
I've sort of messed around with in my

00:17:28,220 --> 00:17:31,759
spare time but it's been really awesome

00:17:29,629 --> 00:17:33,230
to come talk about here at PyCon so

00:17:31,759 --> 00:17:35,990
thanks a lot and if there's any

00:17:33,230 --> 00:17:43,909
questions i'll happily talk it to a

00:17:35,990 --> 00:17:47,029
great length yeah d support term

00:17:43,909 --> 00:17:48,620
multicast EDP I'll sorry to questions

00:17:47,029 --> 00:17:50,860
that's the first one and the second one

00:17:48,620 --> 00:17:53,899
is what other platforms do you support

00:17:50,860 --> 00:17:56,659
what other platforms just have to have a

00:17:53,899 --> 00:18:00,860
UNIX base or does it also windows for

00:17:56,659 --> 00:18:05,509
example it'll run on Windows bsd and

00:18:00,860 --> 00:18:07,549
linux and anything really that supports

00:18:05,509 --> 00:18:10,070
select which is pretty much everything

00:18:07,549 --> 00:18:12,590
it runs best on systems that support

00:18:10,070 --> 00:18:16,220
modern polling techniques such as a poll

00:18:12,590 --> 00:18:18,620
and take you which is sort of that's

00:18:16,220 --> 00:18:21,409
getting into more sort of complex areas

00:18:18,620 --> 00:18:23,029
but I'm but that's where it has the best

00:18:21,409 --> 00:18:25,789
support because those are those are the

00:18:23,029 --> 00:18:27,559
systems that have system calls that can

00:18:25,789 --> 00:18:32,860
really support sort of thousands of

00:18:27,559 --> 00:18:36,019
connections without falling over and a

00:18:32,860 --> 00:18:38,120
sink or doesn't support those modern

00:18:36,019 --> 00:18:39,740
polling techniques which is why it will

00:18:38,120 --> 00:18:41,029
fall over when there's you know several

00:18:39,740 --> 00:18:44,350
thousand connections even if there's

00:18:41,029 --> 00:18:49,429
only one or two actually doing any work

00:18:44,350 --> 00:18:51,679
the UDP question multicast I'm not

00:18:49,429 --> 00:18:54,860
familiar with what multicast is there is

00:18:51,679 --> 00:18:56,779
a UDP implementation but we've mainly

00:18:54,860 --> 00:18:59,710
been focusing on TCP for the time being

00:18:56,779 --> 00:18:59,710
yeah

00:19:04,669 --> 00:19:11,119
I saw your echo example skip over the

00:19:08,029 --> 00:19:24,759
ipv6 localhost do you have ipv6 sport in

00:19:11,119 --> 00:19:24,759
pants not yet no first

00:19:25,050 --> 00:19:30,070
with your HTTP implementation for the

00:19:28,060 --> 00:19:33,850
client side doesn't support proxies and

00:19:30,070 --> 00:19:35,850
in proxies also that use passwords I

00:19:33,850 --> 00:19:38,620
didn't write the HTTP m from the

00:19:35,850 --> 00:19:40,480
implementation that's my co-author I

00:19:38,620 --> 00:19:41,910
suspect that it doesn't is fairly basic

00:19:40,480 --> 00:19:44,710
particularly the client at the moment

00:19:41,910 --> 00:19:50,800
the servers were really being where the

00:19:44,710 --> 00:19:54,580
main focus has been does it have SSL

00:19:50,800 --> 00:19:59,290
support in the client annual server it

00:19:54,580 --> 00:20:02,320
did and then I broke it and then we chat

00:19:59,290 --> 00:20:04,300
it out and it's going back in soon in

00:20:02,320 --> 00:20:08,160
fact I was discussing with the co-author

00:20:04,300 --> 00:20:08,160
this morning about putting it back in

00:20:08,190 --> 00:20:15,160
it's a bit tricky to sort of get correct

00:20:12,550 --> 00:20:17,680
ssl support in something that's also

00:20:15,160 --> 00:20:19,660
meant to be generic you have to do a

00:20:17,680 --> 00:20:22,930
sort all sorts of unpleasant monkey

00:20:19,660 --> 00:20:26,610
patching and stuff so no not at the

00:20:22,930 --> 00:20:26,610
moment but it will it will

00:20:33,260 --> 00:20:41,220
so is the project as two people are

00:20:38,100 --> 00:20:43,710
there any other contributors or the main

00:20:41,220 --> 00:20:48,030
two contributors are two people yep but

00:20:43,710 --> 00:20:51,660
there's a few people i know of that use

00:20:48,030 --> 00:20:54,650
it and quite a few people hang out in

00:20:51,660 --> 00:20:54,650
the IRC room

00:21:06,169 --> 00:21:10,759
hey how do you choose which point

00:21:08,899 --> 00:21:14,499
technology to you they're using live

00:21:10,759 --> 00:21:14,499
event or you just choose it yourself

00:21:17,080 --> 00:21:23,590
I'll show you cool it's pretty basic

00:21:31,020 --> 00:21:37,760
this is pure python there's no reliance

00:21:34,050 --> 00:21:41,490
on any C libraries or anything like that

00:21:37,760 --> 00:21:45,570
so that's how we choose which poem

00:21:41,490 --> 00:21:47,430
technology to use check for what's there

00:21:45,570 --> 00:21:50,390
and use the best thing that's available

00:21:47,430 --> 00:21:50,390
okay

00:22:11,130 --> 00:22:16,420
so do I understand correctly this on

00:22:14,080 --> 00:22:19,630
Windows would use this select yeah a

00:22:16,420 --> 00:22:21,309
mechanism is there any interest in doing

00:22:19,630 --> 00:22:25,570
it using a more efficient asynchronous

00:22:21,309 --> 00:22:27,160
i/o like I organization ports yes yeah

00:22:25,570 --> 00:22:29,440
i'd be interested in in doing that but i

00:22:27,160 --> 00:22:31,860
haven't really made it my focus the time

00:22:29,440 --> 00:22:34,690
being a lot of the recent work has been

00:22:31,860 --> 00:22:38,200
getting the underlying design working

00:22:34,690 --> 00:22:40,510
really nicely and finalizing the api and

00:22:38,200 --> 00:22:42,670
once that's all done then we'll probably

00:22:40,510 --> 00:22:45,190
start looking at at getting more support

00:22:42,670 --> 00:22:47,830
for things like that and also things

00:22:45,190 --> 00:22:51,450
like ipv6 and ssl and and all that sort

00:22:47,830 --> 00:22:51,450
of extra stuff that goes on top

00:22:56,570 --> 00:23:01,039
alright thanks very much for having me

00:22:59,029 --> 00:23:03,399
it's been a an awesome opportunity to

00:23:01,039 --> 00:23:03,399

YouTube URL: https://www.youtube.com/watch?v=ZCW41URyqAQ


