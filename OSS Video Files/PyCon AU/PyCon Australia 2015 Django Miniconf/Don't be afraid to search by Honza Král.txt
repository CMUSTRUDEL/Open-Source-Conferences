Title: Don't be afraid to search by Honza KrÃ¡l
Publication date: 2015-08-06
Playlist: PyCon Australia 2015 Django Miniconf
Description: 
	Creating a good search experience for your website is perceived as hard when it doesn't have to be so.

Starting with what is a search engine and how it works we will introduce the tools and techniques to help you design a search functionality that will make your users happy.

From tips on how to structure your data and tune your settings and queries to improve relevancy to features like faceted navigation and search-as-you-type autocomplete.

All examples will be shown using Elasticsearch and Django, though it should be applicable to other technologies as well.

PyCon Australia is the national conference for users of the Python Programming Language. In 2015, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

July 31-August 4, Brisbane, Queensland, Australia
Captions: 
	00:00:23,730 --> 00:00:31,470
hello this is much better okay so I've

00:00:30,029 --> 00:00:34,050
been giving this talk for a while and

00:00:31,470 --> 00:00:36,090
that is essentially because I got a

00:00:34,050 --> 00:00:38,879
little tired of hearing that search is

00:00:36,090 --> 00:00:42,269
hard and that we need to we need to make

00:00:38,879 --> 00:00:45,210
it easier and I I'm always baffled by

00:00:42,269 --> 00:00:48,420
that because i think it is actually

00:00:45,210 --> 00:00:52,260
fairly easy and it is my goal today to

00:00:48,420 --> 00:00:55,230
actually convince you of that so first

00:00:52,260 --> 00:00:56,879
we need to as any good scientist or

00:00:55,230 --> 00:01:00,719
engineer we need to first define the

00:00:56,879 --> 00:01:02,670
problem what is actually search well

00:01:00,719 --> 00:01:04,739
searches whenever you have a pile of

00:01:02,670 --> 00:01:08,160
data and you're looking for something in

00:01:04,739 --> 00:01:10,860
our case we're looking for text we're

00:01:08,160 --> 00:01:13,590
looking for full text so how would you

00:01:10,860 --> 00:01:16,550
how would you do go about it if you want

00:01:13,590 --> 00:01:20,100
to find the book that mentioned Django

00:01:16,550 --> 00:01:23,759
so when you find a book that that's easy

00:01:20,100 --> 00:01:26,640
you just go to your library and you read

00:01:23,759 --> 00:01:30,240
all the books that are there and set

00:01:26,640 --> 00:01:33,660
aside all those that mention Django when

00:01:30,240 --> 00:01:36,390
you want to search for Jengo in a bunch

00:01:33,660 --> 00:01:40,770
of files that's again super easy just

00:01:36,390 --> 00:01:43,950
just grip it and grep will do the work

00:01:40,770 --> 00:01:45,599
for you it will go to all the files on

00:01:43,950 --> 00:01:48,289
your disk and it will search them for

00:01:45,599 --> 00:01:52,259
the word Django and put them aside if

00:01:48,289 --> 00:01:54,959
you want to search for the jenga models

00:01:52,259 --> 00:01:58,259
in your database forward Django again

00:01:54,959 --> 00:02:01,170
super simple just do a query set with I

00:01:58,259 --> 00:02:03,030
contains and Django will do that for you

00:02:01,170 --> 00:02:06,629
it will go to the database it will read

00:02:03,030 --> 00:02:09,920
every single model in that table read

00:02:06,629 --> 00:02:13,620
all the data and look for Jengo in there

00:02:09,920 --> 00:02:16,080
so obviously this is not a way to go it

00:02:13,620 --> 00:02:19,770
doesn't scale and more importantly it

00:02:16,080 --> 00:02:21,930
doesn't really work because imagine that

00:02:19,770 --> 00:02:25,950
you have the words likely misspelled or

00:02:21,930 --> 00:02:28,230
you have it in different form so instead

00:02:25,950 --> 00:02:31,769
of instead of junk or not you have

00:02:28,230 --> 00:02:35,930
Django or something like that and it

00:02:31,769 --> 00:02:39,530
just really isn't isn't working

00:02:35,930 --> 00:02:41,810
and search is trying to solve this and

00:02:39,530 --> 00:02:46,730
it's not a new problem and it has been

00:02:41,810 --> 00:02:49,579
solved for quite some time now and the

00:02:46,730 --> 00:02:53,139
solution you're all very familiar with I

00:02:49,579 --> 00:02:55,459
hope because if you've ever read a book

00:02:53,139 --> 00:03:00,040
usually there's an index at the end

00:02:55,459 --> 00:03:02,840
which points you to all the important

00:03:00,040 --> 00:03:05,840
concepts or places or names in the book

00:03:02,840 --> 00:03:08,989
and the list of pages and that is what

00:03:05,840 --> 00:03:11,599
we call an inverted index that is a data

00:03:08,989 --> 00:03:14,959
structure that we use today it was first

00:03:11,599 --> 00:03:18,950
created in 1230 and we are still using

00:03:14,959 --> 00:03:21,560
it to this day to power search except

00:03:18,950 --> 00:03:24,319
now instead of instead of paper and

00:03:21,560 --> 00:03:27,169
things we use computers but theory is

00:03:24,319 --> 00:03:29,959
the same and the theory is this you have

00:03:27,169 --> 00:03:33,650
a list of words on the left side that

00:03:29,959 --> 00:03:37,819
are sorted and for each of those words

00:03:33,650 --> 00:03:41,000
you have a list of documents files pages

00:03:37,819 --> 00:03:43,729
that actually contain this word which

00:03:41,000 --> 00:03:47,000
are also sorted the sorting part is

00:03:43,729 --> 00:03:50,379
important because what then when you do

00:03:47,000 --> 00:03:54,379
a search so you're looking for python

00:03:50,379 --> 00:03:56,989
django and python so all you have to do

00:03:54,379 --> 00:04:00,260
is locate those two words in the sordid

00:03:56,989 --> 00:04:03,169
dictionary and you get back two lists

00:04:00,260 --> 00:04:06,919
that are sorted and your task is to

00:04:03,169 --> 00:04:10,329
actually go through those two lists and

00:04:06,919 --> 00:04:15,169
output anything that appears in both

00:04:10,329 --> 00:04:16,820
this could actually solve as an serve as

00:04:15,169 --> 00:04:19,669
an interview question code this on white

00:04:16,820 --> 00:04:22,400
board it's actually not hard and it is

00:04:19,669 --> 00:04:25,099
actually not that expensive and it has

00:04:22,400 --> 00:04:27,500
other nice qualities for example those

00:04:25,099 --> 00:04:30,199
lists they don't have to come from the

00:04:27,500 --> 00:04:32,930
same index you can use multiple indices

00:04:30,199 --> 00:04:35,930
at the same time if you have more than

00:04:32,930 --> 00:04:38,659
one field in your document you can very

00:04:35,930 --> 00:04:42,229
easily use all the indices for all the

00:04:38,659 --> 00:04:44,779
fields you get these lists it's called a

00:04:42,229 --> 00:04:46,490
posting list you get these posting lists

00:04:44,779 --> 00:04:48,889
from all the different indices and you

00:04:46,490 --> 00:04:49,320
just merge them together if you want to

00:04:48,889 --> 00:04:52,650
do an

00:04:49,320 --> 00:04:55,650
or query Python or Django then you just

00:04:52,650 --> 00:04:58,440
output everything no just the documents

00:04:55,650 --> 00:05:04,110
that are in all of the lists but all the

00:04:58,440 --> 00:05:05,850
documents that you find and that makes

00:05:04,110 --> 00:05:07,980
it very very efficient you're just

00:05:05,850 --> 00:05:10,830
walking through sorted lists and merging

00:05:07,980 --> 00:05:14,460
them together so the only problem

00:05:10,830 --> 00:05:16,550
remains how do you build this and that

00:05:14,460 --> 00:05:19,950
is actually where all the magic happens

00:05:16,550 --> 00:05:21,900
where when you're building the inverted

00:05:19,950 --> 00:05:25,200
index this process is called text

00:05:21,900 --> 00:05:27,630
analysis and this is an example of how

00:05:25,200 --> 00:05:30,150
it could look so you have a you have a

00:05:27,630 --> 00:05:34,170
sentence which I which I took four from

00:05:30,150 --> 00:05:36,000
from an unnamed website and you have you

00:05:34,170 --> 00:05:38,070
have the output the words that I

00:05:36,000 --> 00:05:40,950
consider important in the form that

00:05:38,070 --> 00:05:42,410
there are more most useful to me and you

00:05:40,950 --> 00:05:45,050
can immediately notice several things

00:05:42,410 --> 00:05:47,250
first of all everything is lower case

00:05:45,050 --> 00:05:51,540
that makes sense if I want to search for

00:05:47,250 --> 00:05:52,980
a web and I input in a lowercase or

00:05:51,540 --> 00:05:54,270
uppercase I should still find this

00:05:52,980 --> 00:05:58,520
sentence I should still find this

00:05:54,270 --> 00:06:03,080
document also i skipped some words I

00:05:58,520 --> 00:06:05,160
don't care to find the word is or a

00:06:03,080 --> 00:06:08,400
assuming that we are working with

00:06:05,160 --> 00:06:11,000
English those words will be pretty much

00:06:08,400 --> 00:06:13,230
in every single document that we have

00:06:11,000 --> 00:06:14,790
that's not interesting like that will

00:06:13,230 --> 00:06:17,070
not help us at all and it will just take

00:06:14,790 --> 00:06:19,980
up space in the index those are called

00:06:17,070 --> 00:06:23,040
stop words and we just ignore them all

00:06:19,980 --> 00:06:26,490
so what I did was in some cases like

00:06:23,040 --> 00:06:28,470
here wrap it and fast those are synonyms

00:06:26,490 --> 00:06:31,350
those are the same word so if somebody

00:06:28,470 --> 00:06:34,260
is looking for a framework that allows

00:06:31,350 --> 00:06:37,980
them to develop fast they should also

00:06:34,260 --> 00:06:41,820
find this document it's not their fault

00:06:37,980 --> 00:06:43,890
that the creators of Django have larger

00:06:41,820 --> 00:06:47,010
vocabulary so you actually have to use

00:06:43,890 --> 00:06:49,190
rapid instead of fast you should not be

00:06:47,010 --> 00:06:55,020
penalized for for Adrienne's

00:06:49,190 --> 00:06:57,030
journalistic education so and also one

00:06:55,020 --> 00:06:59,930
last thing you notice that some of the

00:06:57,030 --> 00:07:02,380
words are mangled we don't have

00:06:59,930 --> 00:07:06,010
encourages or

00:07:02,380 --> 00:07:09,610
or development we just find the root of

00:07:06,010 --> 00:07:11,380
the word the stem so all this process is

00:07:09,610 --> 00:07:15,100
designed to do one thing to essentially

00:07:11,380 --> 00:07:18,040
normalize the input and when we when we

00:07:15,100 --> 00:07:21,280
apply this process to both the text and

00:07:18,040 --> 00:07:26,790
then the query we can then do the

00:07:21,280 --> 00:07:31,000
matching so this is the core idea behind

00:07:26,790 --> 00:07:33,640
a full text search the text analysis and

00:07:31,000 --> 00:07:37,150
it all happens at index time that that

00:07:33,640 --> 00:07:39,310
is we have prepaid all this cost so once

00:07:37,150 --> 00:07:41,770
it is in the index it's already there

00:07:39,310 --> 00:07:45,490
already done and we can we can do

00:07:41,770 --> 00:07:48,060
searches very efficiently and there's

00:07:45,490 --> 00:07:51,100
one last thing that actually is

00:07:48,060 --> 00:07:52,930
different for full text search compared

00:07:51,100 --> 00:07:56,290
to normal querying in Europe in your

00:07:52,930 --> 00:07:58,930
regular database and that is we can tell

00:07:56,290 --> 00:08:02,470
you not only if a document matched the

00:07:58,930 --> 00:08:04,380
query but how well did it match for

00:08:02,470 --> 00:08:07,510
example if you're looking for book

00:08:04,380 --> 00:08:10,120
mentioning Django if you use the the

00:08:07,510 --> 00:08:13,240
model approach the query set you will

00:08:10,120 --> 00:08:15,640
get all the books that have Jengo

00:08:13,240 --> 00:08:17,920
anywhere in them for example you have a

00:08:15,640 --> 00:08:21,250
book on flask that mentions in one

00:08:17,920 --> 00:08:23,970
chapter hey this is not Django and it

00:08:21,250 --> 00:08:26,650
will be in the output with the

00:08:23,970 --> 00:08:28,690
indistinguishable from from the two

00:08:26,650 --> 00:08:33,580
scoops of Django book which is actually

00:08:28,690 --> 00:08:35,950
much more relevant so that is one last

00:08:33,580 --> 00:08:40,719
reason why you should never ever use

00:08:35,950 --> 00:08:43,419
query sets to actually power search so

00:08:40,719 --> 00:08:47,380
I've told you what not to do let's move

00:08:43,419 --> 00:08:48,790
on to what what you can do so I work for

00:08:47,380 --> 00:08:52,840
elastic so I'm biased i'll be talking

00:08:48,790 --> 00:08:56,830
about elasticsearch and what a search is

00:08:52,840 --> 00:08:58,630
it is a database it is a data store that

00:08:56,830 --> 00:09:01,480
you can use to put your data into it

00:08:58,630 --> 00:09:04,630
it's distributed and most importantly

00:09:01,480 --> 00:09:07,570
it's document-oriented and by documents

00:09:04,630 --> 00:09:11,920
I mean literally anything that you can

00:09:07,570 --> 00:09:14,170
express as JSON so no matter how complex

00:09:11,920 --> 00:09:16,030
the structure if you can express it as

00:09:14,170 --> 00:09:18,670
JSON you can index it into

00:09:16,030 --> 00:09:22,030
elasticsearch an elastic search can can

00:09:18,670 --> 00:09:24,160
use it we are not schema-less as some

00:09:22,030 --> 00:09:26,770
people claim but what we do is we have

00:09:24,160 --> 00:09:29,920
dynamic schema so you don't have to

00:09:26,770 --> 00:09:31,420
define the schema beforehand if we find

00:09:29,920 --> 00:09:34,150
a field in your document that you

00:09:31,420 --> 00:09:36,340
haven't told us about we will just will

00:09:34,150 --> 00:09:38,020
just make up the scheming will look at

00:09:36,340 --> 00:09:41,140
the value and we'll see hey this is a

00:09:38,020 --> 00:09:44,170
string from henceforth it should be

00:09:41,140 --> 00:09:46,000
known as string there's only one

00:09:44,170 --> 00:09:48,730
exception to this if the string looks

00:09:46,000 --> 00:09:51,070
like it could be a date we will say that

00:09:48,730 --> 00:09:54,730
it is a date that is of course because

00:09:51,070 --> 00:09:58,120
jason has no first class support for

00:09:54,730 --> 00:09:59,830
date times we also actually support some

00:09:58,120 --> 00:10:03,580
relationships between between documents

00:09:59,830 --> 00:10:06,640
a one-to-many relationships but will not

00:10:03,580 --> 00:10:08,680
go into those today so how do you

00:10:06,640 --> 00:10:12,330
actually use it this is how this is a

00:10:08,680 --> 00:10:16,990
very simple example from from Python and

00:10:12,330 --> 00:10:18,910
you can just create a connection index a

00:10:16,990 --> 00:10:22,660
document into it and then run a search

00:10:18,910 --> 00:10:24,280
and you get the results and this words

00:10:22,660 --> 00:10:26,110
there's nothing wrong with it but it's

00:10:24,280 --> 00:10:28,540
not very not very convenient especially

00:10:26,110 --> 00:10:31,360
writing the queries which you can which

00:10:28,540 --> 00:10:34,060
you can see are also JSON or Python

00:10:31,360 --> 00:10:36,450
dictionaries in this case can get really

00:10:34,060 --> 00:10:40,770
hard and really messy really quickly so

00:10:36,450 --> 00:10:44,620
what we what we did instead we created a

00:10:40,770 --> 00:10:46,750
nicer looking dsl for this so in this

00:10:44,620 --> 00:10:48,250
example we are creating a doctype which

00:10:46,750 --> 00:10:51,100
is essentially something like a model

00:10:48,250 --> 00:10:53,230
which allows us to create the schema so

00:10:51,100 --> 00:10:55,420
we have a book that has a one field

00:10:53,230 --> 00:10:57,880
called title which has the which uses

00:10:55,420 --> 00:11:00,040
the English analyzer then we index a

00:10:57,880 --> 00:11:04,750
document and then we can actually search

00:11:00,040 --> 00:11:08,460
and what we get back is is the result so

00:11:04,750 --> 00:11:12,580
that is all that you have to do well

00:11:08,460 --> 00:11:15,090
this is a very basic search because if

00:11:12,580 --> 00:11:17,770
you actually look at look at some search

00:11:15,090 --> 00:11:20,590
that year that you can find out there

00:11:17,770 --> 00:11:22,830
there's more to it than just than just

00:11:20,590 --> 00:11:26,340
the middle because what we just did is

00:11:22,830 --> 00:11:30,880
we implemented just the middle part of

00:11:26,340 --> 00:11:34,910
the search just to get get me the

00:11:30,880 --> 00:11:36,710
get me the links but there are other

00:11:34,910 --> 00:11:40,310
things that actually come into the

00:11:36,710 --> 00:11:42,560
search because this part is super useful

00:11:40,310 --> 00:11:44,510
and super good if you know what you're

00:11:42,560 --> 00:11:47,330
looking for if you know that you're

00:11:44,510 --> 00:11:49,970
looking for Jengo but if you don't know

00:11:47,330 --> 00:11:52,160
what you're looking for it's not really

00:11:49,970 --> 00:11:54,680
useful at all you would have to try all

00:11:52,160 --> 00:11:56,930
the possible combinations and that's why

00:11:54,680 --> 00:11:59,180
we have facets those are the things on

00:11:56,930 --> 00:12:02,600
the left which gives you sort of an

00:11:59,180 --> 00:12:05,840
overview of your data so when we search

00:12:02,600 --> 00:12:08,150
for the letters DJ we can immediately

00:12:05,840 --> 00:12:09,980
see that ninety percent of the results

00:12:08,150 --> 00:12:12,560
I'll are actually written in Python and

00:12:09,980 --> 00:12:14,480
we can see the number of results for

00:12:12,560 --> 00:12:16,910
Python and for JavaScript and for all

00:12:14,480 --> 00:12:19,880
the other languages so immediately we

00:12:16,910 --> 00:12:22,430
see we just take one look at this and we

00:12:19,880 --> 00:12:27,170
see that it has a connection to python

00:12:22,430 --> 00:12:30,350
and most of it is in Python you can also

00:12:27,170 --> 00:12:33,200
see that it found several thousand

00:12:30,350 --> 00:12:37,250
repositories some results in code some

00:12:33,200 --> 00:12:40,460
results in issues at cetera so again you

00:12:37,250 --> 00:12:43,340
can see sort of the distribution of the

00:12:40,460 --> 00:12:46,940
results across your data so that is very

00:12:43,340 --> 00:12:49,240
good for exploration so how does this

00:12:46,940 --> 00:12:51,280
how does this actually work in

00:12:49,240 --> 00:12:55,970
elasticsearch case it's powered by

00:12:51,280 --> 00:12:58,460
aggregations and aggregations when you

00:12:55,970 --> 00:13:03,200
think about it in a general case it's

00:12:58,460 --> 00:13:05,180
just separating your data into groups we

00:13:03,200 --> 00:13:08,240
just call them buckets and then

00:13:05,180 --> 00:13:12,440
performing some calculation in for each

00:13:08,240 --> 00:13:14,000
group in sequel that's group x and then

00:13:12,440 --> 00:13:20,960
you have the aggregate functions like

00:13:14,000 --> 00:13:24,050
max some count etc in a elastic search

00:13:20,960 --> 00:13:27,410
it's buckets and metrics there is

00:13:24,050 --> 00:13:29,540
however one important difference in how

00:13:27,410 --> 00:13:31,490
we do aggregations or what we allow you

00:13:29,540 --> 00:13:33,740
to do with education is compared to for

00:13:31,490 --> 00:13:37,820
example sequel we allow you to nest

00:13:33,740 --> 00:13:42,530
those aggregations so you can separate

00:13:37,820 --> 00:13:43,010
your documents by by type you'd put all

00:13:42,530 --> 00:13:44,630
books

00:13:43,010 --> 00:13:47,150
together all the magazine's together all

00:13:44,630 --> 00:13:49,730
the blog articles together and then

00:13:47,150 --> 00:13:51,830
within that you can further this review

00:13:49,730 --> 00:13:56,300
them for example by month so you can

00:13:51,830 --> 00:13:57,320
have a bucket per month per type and you

00:13:56,300 --> 00:13:59,450
can Nestle so you can do

00:13:57,320 --> 00:14:01,960
multi-dimensional aggregations and all

00:13:59,450 --> 00:14:04,310
into one pass all in a single query

00:14:01,960 --> 00:14:06,620
you're also not limited to a single

00:14:04,310 --> 00:14:09,380
aggregation in your query so you can in

00:14:06,620 --> 00:14:13,460
the same query you can ask to for

00:14:09,380 --> 00:14:15,830
distribution / type / tag and per month

00:14:13,460 --> 00:14:20,300
and get all of these all of these

00:14:15,830 --> 00:14:23,420
results together so we have different

00:14:20,300 --> 00:14:26,390
types of aggregations the most commonly

00:14:23,420 --> 00:14:29,090
used one is our is terms aggregation

00:14:26,390 --> 00:14:33,920
which puts all the documents that have

00:14:29,090 --> 00:14:37,040
the same value of a field together so if

00:14:33,920 --> 00:14:39,070
you have a category field or tags or

00:14:37,040 --> 00:14:42,020
something like that that's what you want

00:14:39,070 --> 00:14:44,390
know that all the fields in

00:14:42,020 --> 00:14:47,240
elasticsearch can actually have multiple

00:14:44,390 --> 00:14:49,670
values you're not limited to a single

00:14:47,240 --> 00:14:50,960
value you can just as well assign a

00:14:49,670 --> 00:14:53,300
string or a list of strings

00:14:50,960 --> 00:14:55,040
elasticsearch doesn't care so if you

00:14:53,300 --> 00:14:57,080
have tags or category you can have

00:14:55,040 --> 00:14:59,680
multiple tags which means that the

00:14:57,080 --> 00:15:01,970
document will end up in multiple buckets

00:14:59,680 --> 00:15:04,700
there is an interesting aggregation

00:15:01,970 --> 00:15:06,890
called significant terms which uses the

00:15:04,700 --> 00:15:09,050
fact that we know about the data we are

00:15:06,890 --> 00:15:11,570
we're the search guys we know what words

00:15:09,050 --> 00:15:13,400
are common which are rare and what is

00:15:11,570 --> 00:15:16,430
the distribution of the words across

00:15:13,400 --> 00:15:19,160
your data set so if you give us a bucket

00:15:16,430 --> 00:15:21,920
we can tell you what's specific for this

00:15:19,160 --> 00:15:24,440
bucket what is significant compared to

00:15:21,920 --> 00:15:27,020
the background compared to the compared

00:15:24,440 --> 00:15:29,510
to your other data so for example if you

00:15:27,020 --> 00:15:31,880
do an aggregation per month a date

00:15:29,510 --> 00:15:35,470
histogram and then within that you ask

00:15:31,880 --> 00:15:39,200
for the significant terms on on hashtags

00:15:35,470 --> 00:15:41,300
you get trending you get the hashtags

00:15:39,200 --> 00:15:43,910
that are more significant for this time

00:15:41,300 --> 00:15:45,590
period compared to all the others those

00:15:43,910 --> 00:15:48,890
are not the most popular but the most

00:15:45,590 --> 00:15:50,420
significant and for metrics there are

00:15:48,890 --> 00:15:52,940
some there are some boring things like

00:15:50,420 --> 00:15:55,070
stats which will give you for numeric

00:15:52,940 --> 00:15:56,180
fields all the averages and sum of all

00:15:55,070 --> 00:15:59,330
squares and everything

00:15:56,180 --> 00:16:02,870
two to make even the scientific people

00:15:59,330 --> 00:16:04,580
next door happy so this these are these

00:16:02,870 --> 00:16:06,500
are aggregations this is the theory and

00:16:04,580 --> 00:16:09,140
this is how it actually looks in the

00:16:06,500 --> 00:16:10,790
choir DSL so we already saw how to

00:16:09,140 --> 00:16:13,730
create the search request and now we

00:16:10,790 --> 00:16:15,890
just add an aggregation so we add a date

00:16:13,730 --> 00:16:17,420
histogram aggregation and then we add

00:16:15,890 --> 00:16:22,160
another aggregation which is a terms

00:16:17,420 --> 00:16:25,880
histogram sorry terms aggregation over

00:16:22,160 --> 00:16:29,440
the field tags and within that we also

00:16:25,880 --> 00:16:32,540
look for for the stats on the read count

00:16:29,440 --> 00:16:35,480
so very simple way to actually specify

00:16:32,540 --> 00:16:39,890
those aggregations and you get back the

00:16:35,480 --> 00:16:43,880
results in a single account so when we

00:16:39,890 --> 00:16:47,029
look at our our search interface where

00:16:43,880 --> 00:16:49,250
we want to get to that's that's the

00:16:47,029 --> 00:16:55,250
faceting part that's the part on the

00:16:49,250 --> 00:16:56,810
left and it is very useful interface to

00:16:55,250 --> 00:16:58,580
navigate if you've ever searched for a

00:16:56,810 --> 00:17:00,860
hotel or if you ever searched for a

00:16:58,580 --> 00:17:02,360
product on Amazon you should be you

00:17:00,860 --> 00:17:04,850
should be familiar with how useful this

00:17:02,360 --> 00:17:07,699
is if you look for a hotel in Brisbane

00:17:04,850 --> 00:17:10,850
and on the left side you can immediately

00:17:07,699 --> 00:17:13,220
see how many five-star hotels there are

00:17:10,850 --> 00:17:15,290
how many four star hotels what is what

00:17:13,220 --> 00:17:17,600
are the price ranges and you can

00:17:15,290 --> 00:17:20,240
immediately see and go there and just

00:17:17,600 --> 00:17:22,880
click on it and in the background

00:17:20,240 --> 00:17:25,970
someone will do a query to elasticsearch

00:17:22,880 --> 00:17:29,059
and just add a filter to it to reflect

00:17:25,970 --> 00:17:31,010
the the choice that you've clicked on by

00:17:29,059 --> 00:17:32,720
the way there is no coincidence that i'm

00:17:31,010 --> 00:17:34,280
using github as an example they actually

00:17:32,720 --> 00:17:36,620
do use elastic search for all their

00:17:34,280 --> 00:17:40,790
searches unfortunately not Python but

00:17:36,620 --> 00:17:43,160
hey nobody's perfect so that's that's

00:17:40,790 --> 00:17:45,830
sort of the the search part and then the

00:17:43,160 --> 00:17:48,350
exploration part but as we can see there

00:17:45,830 --> 00:17:50,540
are more things going on here and the

00:17:48,350 --> 00:17:52,970
important thing that we also see here is

00:17:50,540 --> 00:17:55,190
the highlighting we can see which parts

00:17:52,970 --> 00:17:58,040
of the repository name or something

00:17:55,190 --> 00:18:00,500
actually matches our query so we can do

00:17:58,040 --> 00:18:03,080
highlighting and some people don't

00:18:00,500 --> 00:18:05,059
really understand why that's actually

00:18:03,080 --> 00:18:07,490
such a good feature or why I cannot just

00:18:05,059 --> 00:18:08,429
do it in in JavaScript when everything

00:18:07,490 --> 00:18:10,590
is rendered

00:18:08,429 --> 00:18:14,249
but it is actually fairly complex

00:18:10,590 --> 00:18:16,710
problem because of the text analysis for

00:18:14,249 --> 00:18:19,799
example if you search for a framework

00:18:16,710 --> 00:18:21,570
for fast web development we will

00:18:19,799 --> 00:18:24,330
actually highlight the word wrap it for

00:18:21,570 --> 00:18:25,710
you we will actually know that yes you

00:18:24,330 --> 00:18:29,730
search for fast but that actually

00:18:25,710 --> 00:18:31,230
matched the word that is seventh in that

00:18:29,730 --> 00:18:35,970
sentence and we will highlight it for

00:18:31,230 --> 00:18:38,129
you so that is that is why you sort of

00:18:35,970 --> 00:18:40,619
need to delegate this to elasticsearch

00:18:38,129 --> 00:18:42,659
and it would be non-trivial to do it on

00:18:40,619 --> 00:18:46,799
your own you would essentially have to

00:18:42,659 --> 00:18:48,929
replicate all the logic that elastic

00:18:46,799 --> 00:18:54,090
search has regarding text analysis and

00:18:48,929 --> 00:18:57,360
the actual full text search so it is

00:18:54,090 --> 00:19:00,450
very useful also if you have a long text

00:18:57,360 --> 00:19:04,919
if you actually allow people to search

00:19:00,450 --> 00:19:06,659
in the body of a book and then you just

00:19:04,919 --> 00:19:10,139
want to show them the fragments the

00:19:06,659 --> 00:19:14,279
individual passages from from the book

00:19:10,139 --> 00:19:17,610
that actually matched so that is why you

00:19:14,279 --> 00:19:20,519
would also use highlighting to not to

00:19:17,610 --> 00:19:23,659
have to transfer all of the all of the

00:19:20,519 --> 00:19:27,299
book but only the relevant parts and

00:19:23,659 --> 00:19:29,100
also to display it so again how do you

00:19:27,299 --> 00:19:30,779
how do you use this it's super simple

00:19:29,100 --> 00:19:32,700
once you have the search you just call

00:19:30,779 --> 00:19:34,110
the highlight method on it and you give

00:19:32,700 --> 00:19:36,659
it a list of fields that you actually

00:19:34,110 --> 00:19:41,399
want to highlight on and maybe some

00:19:36,659 --> 00:19:44,100
options those are optional so again

00:19:41,399 --> 00:19:48,929
super super simple things and we're

00:19:44,100 --> 00:19:52,200
pretty much done with with our search so

00:19:48,929 --> 00:19:55,919
we know how to how to run the search how

00:19:52,200 --> 00:19:59,669
to do the do the facets how to do

00:19:55,919 --> 00:20:01,529
highlighting so now to the more

00:19:59,669 --> 00:20:04,470
practical part let's let's pull this all

00:20:01,529 --> 00:20:06,059
together we are here at Jenga Khan so

00:20:04,470 --> 00:20:08,879
let's assume that you have a Django

00:20:06,059 --> 00:20:13,200
application that you want to add search

00:20:08,879 --> 00:20:17,429
to so the first thing that you do is you

00:20:13,200 --> 00:20:20,100
define your document types in this case

00:20:17,429 --> 00:20:22,290
we have we have a book that has three

00:20:20,100 --> 00:20:24,420
fields it can have many

00:20:22,290 --> 00:20:26,160
other fields I am just defining the

00:20:24,420 --> 00:20:29,610
fields that I care about that I care

00:20:26,160 --> 00:20:31,610
about defining but it is still if I

00:20:29,610 --> 00:20:34,410
index something that is more fields

00:20:31,610 --> 00:20:36,840
elasticsearch will just take a look at

00:20:34,410 --> 00:20:40,710
it create a schema a mapping for it and

00:20:36,840 --> 00:20:43,680
and index it so you don't have to map

00:20:40,710 --> 00:20:45,780
all the fields here I'm mapping the the

00:20:43,680 --> 00:20:48,810
field title I'm saying that it's in

00:20:45,780 --> 00:20:51,930
English but because I want to search I

00:20:48,810 --> 00:20:55,080
want to sort on it I also instruct

00:20:51,930 --> 00:20:58,290
tastic search to keep the not analyzed

00:20:55,080 --> 00:21:00,810
version sort of the raw version because

00:20:58,290 --> 00:21:04,860
once we mangle it with the text analysis

00:21:00,810 --> 00:21:07,310
it's very useless for sorting because

00:21:04,860 --> 00:21:09,900
we've we've dropped a bunch of words

00:21:07,310 --> 00:21:13,160
words that usually actually occur at the

00:21:09,900 --> 00:21:15,870
beginning of the title like that so

00:21:13,160 --> 00:21:17,640
we've also lower cased everything and we

00:21:15,870 --> 00:21:18,990
might have chopped something from the

00:21:17,640 --> 00:21:21,600
beginning of the word and also we've

00:21:18,990 --> 00:21:23,250
split things into words and you don't

00:21:21,600 --> 00:21:25,050
want to sort on individual words that

00:21:23,250 --> 00:21:27,240
makes no sense you need to sort on the

00:21:25,050 --> 00:21:33,030
whole thing so that's why we're keeping

00:21:27,240 --> 00:21:36,770
the raw version of of the title then we

00:21:33,030 --> 00:21:39,750
have a simple date and we have nested

00:21:36,770 --> 00:21:41,280
documents called editions so a book has

00:21:39,750 --> 00:21:44,820
editions from different publishers

00:21:41,280 --> 00:21:47,190
publish a different date and in this

00:21:44,820 --> 00:21:48,750
line we're essentially telling a sixer

00:21:47,190 --> 00:21:52,830
CH that there will be a list of

00:21:48,750 --> 00:21:55,280
documents that do belong to the book but

00:21:52,830 --> 00:21:59,190
they can be searched on their own and

00:21:55,280 --> 00:22:02,550
they are actually their own separate

00:21:59,190 --> 00:22:04,890
time documents that are an integral part

00:22:02,550 --> 00:22:07,440
of the book but we can for example

00:22:04,890 --> 00:22:09,120
aggregate over just the editions so we

00:22:07,440 --> 00:22:14,520
can search for books and then aggregate

00:22:09,120 --> 00:22:18,660
on their editions so very useful a very

00:22:14,520 --> 00:22:21,390
useful thing so this is what we do for

00:22:18,660 --> 00:22:24,390
the doctype then when you have when you

00:22:21,390 --> 00:22:26,190
have models you want to synchronize them

00:22:24,390 --> 00:22:27,900
of course nobody is forcing you to you

00:22:26,190 --> 00:22:31,020
can just use the document types and and

00:22:27,900 --> 00:22:32,880
just use just use elastic search many

00:22:31,020 --> 00:22:34,020
people do though we don't officially

00:22:32,880 --> 00:22:38,160
recommend that

00:22:34,020 --> 00:22:40,860
actually use elasticsearch as a primary

00:22:38,160 --> 00:22:44,130
data store so in this case we have we

00:22:40,860 --> 00:22:47,340
have a book model and what I found works

00:22:44,130 --> 00:22:49,740
the best is to just define a method I

00:22:47,340 --> 00:22:52,350
typically call it to search that will

00:22:49,740 --> 00:22:55,290
actually return the the doctype the

00:22:52,350 --> 00:22:58,140
instance of the doctype so you can see

00:22:55,290 --> 00:23:00,390
that to instantiate it I just import

00:22:58,140 --> 00:23:02,550
search to search the book pass it the

00:23:00,390 --> 00:23:05,160
title passes the additions you can see

00:23:02,550 --> 00:23:08,220
that I also use the to search to sort of

00:23:05,160 --> 00:23:10,710
serialize all the related models and

00:23:08,220 --> 00:23:13,830
that is very important because you

00:23:10,710 --> 00:23:17,930
represent data differently in your

00:23:13,830 --> 00:23:20,850
relational database and in elasticsearch

00:23:17,930 --> 00:23:24,500
relational database is our relation

00:23:20,850 --> 00:23:27,540
oriented they store Rose relations

00:23:24,500 --> 00:23:30,390
whereas elasticsearch stores document

00:23:27,540 --> 00:23:34,770
and there is different way how to look

00:23:30,390 --> 00:23:38,970
at data there is however one trick that

00:23:34,770 --> 00:23:42,240
I can highly recommend make sure that

00:23:38,970 --> 00:23:45,330
the document and the model has the same

00:23:42,240 --> 00:23:48,810
shape what I mean by shaped is that it

00:23:45,330 --> 00:23:50,310
has a similar interface for example you

00:23:48,810 --> 00:23:53,610
see here that I have created the

00:23:50,310 --> 00:23:56,730
property editions and actually when you

00:23:53,610 --> 00:23:58,650
iterate over book editions you will get

00:23:56,730 --> 00:24:01,410
back the individual editions and you

00:23:58,650 --> 00:24:05,040
will get the same behavior from the

00:24:01,410 --> 00:24:06,900
model and from the doctype the only

00:24:05,040 --> 00:24:08,660
difference is the doctype would be much

00:24:06,900 --> 00:24:12,110
more efficient because it already has

00:24:08,660 --> 00:24:17,580
the documents contained within it

00:24:12,110 --> 00:24:19,680
whereas if you were to iterate over over

00:24:17,580 --> 00:24:21,930
this property of the model it will

00:24:19,680 --> 00:24:24,990
actually trigger a sequel query so it's

00:24:21,930 --> 00:24:27,600
much more expensive so this is how you

00:24:24,990 --> 00:24:30,060
do how you sort of create doc types from

00:24:27,600 --> 00:24:31,590
the models and then you only need a way

00:24:30,060 --> 00:24:33,840
to actually index those into

00:24:31,590 --> 00:24:36,960
elasticsearch you typically need two

00:24:33,840 --> 00:24:38,430
ways to do it a bad job so management

00:24:36,960 --> 00:24:40,650
command is the perfect place to do it

00:24:38,430 --> 00:24:44,340
and you literally only need these four

00:24:40,650 --> 00:24:46,410
lines you see the book dog in it which

00:24:44,340 --> 00:24:47,730
will actually send the mapping in to

00:24:46,410 --> 00:24:51,210
elasticsearch and create

00:24:47,730 --> 00:24:54,390
there and then there is a simple there

00:24:51,210 --> 00:24:56,400
is a simple function called bulk from in

00:24:54,390 --> 00:24:58,850
the elastic search client that just

00:24:56,400 --> 00:25:02,040
takes an iterator and it will actually

00:24:58,850 --> 00:25:03,330
put this all into into elasticsearch so

00:25:02,040 --> 00:25:05,940
you just iterate over all your models

00:25:03,330 --> 00:25:09,690
and put it in there you need to have a

00:25:05,940 --> 00:25:12,150
bad job like this because you might need

00:25:09,690 --> 00:25:13,980
to reindex your data remember what I

00:25:12,150 --> 00:25:17,010
told you about the text analysis it

00:25:13,980 --> 00:25:19,800
happens at index time so if you change

00:25:17,010 --> 00:25:22,320
anything about your text analysis you

00:25:19,800 --> 00:25:25,560
found out that the analyzer that you

00:25:22,320 --> 00:25:27,840
chose doesn't work as well as you as you

00:25:25,560 --> 00:25:31,350
thought or you realize that you need it

00:25:27,840 --> 00:25:33,510
to keep the raw version too late and you

00:25:31,350 --> 00:25:35,790
already have data in there you need to

00:25:33,510 --> 00:25:37,710
reindex your data so that is why it is

00:25:35,790 --> 00:25:41,100
important to have a very convenient way

00:25:37,710 --> 00:25:43,440
to do this and then the second part of

00:25:41,100 --> 00:25:45,750
it is just listen to signals and

00:25:43,440 --> 00:25:48,570
whenever a model changes just replicate

00:25:45,750 --> 00:25:51,480
the change into elasticsearch and again

00:25:48,570 --> 00:25:53,130
as you can see it's five lines including

00:25:51,480 --> 00:25:56,100
the imports you can do very similar

00:25:53,130 --> 00:26:00,240
things for deletes just do instance to

00:25:56,100 --> 00:26:03,210
search don't delete and bind it to a

00:26:00,240 --> 00:26:06,930
post or pre delete signals based on what

00:26:03,210 --> 00:26:09,060
your application requires so again this

00:26:06,930 --> 00:26:13,590
part is super simple some people

00:26:09,060 --> 00:26:16,350
actually prefer to do the update search

00:26:13,590 --> 00:26:18,720
in the background somewhere for example

00:26:16,350 --> 00:26:20,430
using celery or or RQ or something

00:26:18,720 --> 00:26:23,040
because it can be a potentially

00:26:20,430 --> 00:26:26,190
expensive process not because

00:26:23,040 --> 00:26:27,960
elasticsearch is slow but because the to

00:26:26,190 --> 00:26:30,840
search method actually does a lot of

00:26:27,960 --> 00:26:33,900
things it fetches a lot of data from

00:26:30,840 --> 00:26:35,820
your from your primary database and puts

00:26:33,900 --> 00:26:38,550
them together into a single document and

00:26:35,820 --> 00:26:41,100
that can potentially be fairly expensive

00:26:38,550 --> 00:26:45,750
and you might not want to pay that price

00:26:41,100 --> 00:26:47,370
whenever you hit model not save so again

00:26:45,750 --> 00:26:49,440
depends on your application and what are

00:26:47,370 --> 00:26:53,550
your requirements do you need adult safe

00:26:49,440 --> 00:26:55,860
to be quick or do you need do you always

00:26:53,550 --> 00:26:59,340
require the elastic sure to be

00:26:55,860 --> 00:27:00,750
absolutely up to date that's really what

00:26:59,340 --> 00:27:02,870
you have to answer for yourself and for

00:27:00,750 --> 00:27:06,570
your applique

00:27:02,870 --> 00:27:10,470
so the next part is how do you actually

00:27:06,570 --> 00:27:12,870
define a search note that the little

00:27:10,470 --> 00:27:14,580
friendly warning star this is this is a

00:27:12,870 --> 00:27:18,750
fairly new feature that we're working on

00:27:14,580 --> 00:27:20,370
and that is a solution for people who

00:27:18,750 --> 00:27:22,530
actually don't want to type in the

00:27:20,370 --> 00:27:24,600
search that though they don't want to

00:27:22,530 --> 00:27:26,520
learn all the different types to query

00:27:24,600 --> 00:27:28,950
and they just want to throw something up

00:27:26,520 --> 00:27:32,580
there quickly yet still retained the

00:27:28,950 --> 00:27:36,080
option to move on in the in the future

00:27:32,580 --> 00:27:40,110
so this is a this is a faceted search

00:27:36,080 --> 00:27:45,210
subclass and it's exactly that it's just

00:27:40,110 --> 00:27:47,400
a sort of a declarative version of what

00:27:45,210 --> 00:27:50,190
we've been building throughout the talk

00:27:47,400 --> 00:27:53,010
so I just say that I want to search over

00:27:50,190 --> 00:27:55,440
books and magazines they live in the in

00:27:53,010 --> 00:27:57,750
the index called library and I want to

00:27:55,440 --> 00:28:00,240
search through these fields notice that

00:27:57,750 --> 00:28:04,080
i can i can give multiple versions i can

00:28:00,240 --> 00:28:06,810
even use wildcards here and i want to

00:28:04,080 --> 00:28:09,290
use these facets and i give it an

00:28:06,810 --> 00:28:14,640
instance of of the aggregation and

00:28:09,290 --> 00:28:18,060
that's all i need to do then i just used

00:28:14,640 --> 00:28:19,770
it from from the views so i get the data

00:28:18,060 --> 00:28:21,840
together and know that this is a very

00:28:19,770 --> 00:28:23,610
very bad idea to do it like this you

00:28:21,840 --> 00:28:26,490
probably want to wrap it in a form or

00:28:23,610 --> 00:28:29,430
something because this would blow up if

00:28:26,490 --> 00:28:31,350
you give it an incorrect date so it's

00:28:29,430 --> 00:28:35,940
purely for demonstration purposes just a

00:28:31,350 --> 00:28:37,860
big disclaimer but it actually works all

00:28:35,940 --> 00:28:40,470
you need to do is instantiate instantly

00:28:37,860 --> 00:28:43,680
the surge executed and pass it on to the

00:28:40,470 --> 00:28:46,260
template and note the name of the

00:28:43,680 --> 00:28:49,170
template that's no accident it's

00:28:46,260 --> 00:28:53,640
actually the same template that you use

00:28:49,170 --> 00:28:56,820
to render your default list so if you

00:28:53,640 --> 00:29:01,110
used of I took this from an application

00:28:56,820 --> 00:29:03,360
where I use the Django generic views and

00:29:01,110 --> 00:29:07,710
I just use the list view so I had to

00:29:03,360 --> 00:29:11,250
create a template called library / book

00:29:07,710 --> 00:29:13,230
underscore list and then when I

00:29:11,250 --> 00:29:15,419
implemented the search

00:29:13,230 --> 00:29:17,700
I didn't really want to write another

00:29:15,419 --> 00:29:20,700
template I really don't know anything

00:29:17,700 --> 00:29:22,820
about HTML so writing one template was

00:29:20,700 --> 00:29:25,950
this was a superhero thing for me I

00:29:22,820 --> 00:29:30,600
didn't want to repeat that so I just

00:29:25,950 --> 00:29:33,240
reuse that and because I maintained the

00:29:30,600 --> 00:29:35,970
shape of the document interface the

00:29:33,240 --> 00:29:37,710
template just worked I didn't have to

00:29:35,970 --> 00:29:40,380
create a different template for the

00:29:37,710 --> 00:29:42,990
models and for the documents there was

00:29:40,380 --> 00:29:45,720
only one different this view actually

00:29:42,990 --> 00:29:48,809
renders much much faster because when I

00:29:45,720 --> 00:29:50,910
want to render the comments they're

00:29:48,809 --> 00:29:53,100
already there if I want to render the

00:29:50,910 --> 00:29:55,530
author he's already there i don't need

00:29:53,100 --> 00:30:00,510
to do i don't need to remember that i

00:29:55,530 --> 00:30:03,750
should do fetch the related models or I

00:30:00,510 --> 00:30:05,460
don't need to make sure that the person

00:30:03,750 --> 00:30:08,340
who is doing the template in cases that

00:30:05,460 --> 00:30:10,169
me doesn't do anything crazy like try to

00:30:08,340 --> 00:30:12,799
render every single comment or anything

00:30:10,169 --> 00:30:15,990
like that all the data is already there

00:30:12,799 --> 00:30:20,580
so you don't need to fetch the comment

00:30:15,990 --> 00:30:22,770
fetch the individual models you just

00:30:20,580 --> 00:30:26,400
render what you get back from the search

00:30:22,770 --> 00:30:29,190
and if you if you're smart about it and

00:30:26,400 --> 00:30:31,049
you maintain the same shape there's

00:30:29,190 --> 00:30:33,000
there is no additional work you just

00:30:31,049 --> 00:30:35,580
this is all you need to implement and

00:30:33,000 --> 00:30:36,870
you have a working search the only thing

00:30:35,580 --> 00:30:39,150
that you actually have to implement is

00:30:36,870 --> 00:30:42,570
some form or something to actually get

00:30:39,150 --> 00:30:46,860
the data but that's that's pretty much

00:30:42,570 --> 00:30:48,419
it and in the future versions of this of

00:30:46,860 --> 00:30:51,750
this object I hope to actually be able

00:30:48,419 --> 00:30:53,640
to give you a general form to use so

00:30:51,750 --> 00:31:01,980
this is how you actually implement

00:30:53,640 --> 00:31:05,240
search it's not that much and so just to

00:31:01,980 --> 00:31:08,760
just to sort of wrap it up and and

00:31:05,240 --> 00:31:11,429
mention everything so you have to think

00:31:08,760 --> 00:31:13,770
in documents not models you have to

00:31:11,429 --> 00:31:15,870
collect all the related all the related

00:31:13,770 --> 00:31:17,970
models done them all together into one

00:31:15,870 --> 00:31:19,559
big documents don't be afraid the

00:31:17,970 --> 00:31:21,750
document can be large it can be

00:31:19,559 --> 00:31:23,520
complicated and have lists of objects

00:31:21,750 --> 00:31:26,220
and everything it will still it will

00:31:23,520 --> 00:31:27,030
still work just fine you want to

00:31:26,220 --> 00:31:28,770
maintain this

00:31:27,030 --> 00:31:32,100
shape for the models and for the

00:31:28,770 --> 00:31:34,650
document in order to save yourself work

00:31:32,100 --> 00:31:38,520
in order to avoid duplication of efforts

00:31:34,650 --> 00:31:40,650
for templates and for for other parts if

00:31:38,520 --> 00:31:43,500
you if you do it correctly you can even

00:31:40,650 --> 00:31:50,190
reuse a lot of the forms so you can

00:31:43,500 --> 00:31:53,460
actually manipulate directly the the doc

00:31:50,190 --> 00:32:00,240
types and you don't have to go through

00:31:53,460 --> 00:32:01,770
the models and finally always have the

00:32:00,240 --> 00:32:05,870
two ways to put the data into

00:32:01,770 --> 00:32:09,090
elasticsearch you always need the batch

00:32:05,870 --> 00:32:12,690
command management commands our perfect

00:32:09,090 --> 00:32:15,390
place for this and then have the signal

00:32:12,690 --> 00:32:19,230
handlers to actually keep things in sync

00:32:15,390 --> 00:32:21,060
once you have them indexed and for that

00:32:19,230 --> 00:32:23,670
you might want to consider using in a

00:32:21,060 --> 00:32:30,930
synchronous solution something like

00:32:23,670 --> 00:32:34,890
celery or RQ so that's the that's the

00:32:30,930 --> 00:32:37,800
core of it so I've the control question

00:32:34,890 --> 00:32:39,240
are you still afraid to search or have I

00:32:37,800 --> 00:32:40,560
managed to who have I managed to

00:32:39,240 --> 00:32:43,860
convince that it's actually not that

00:32:40,560 --> 00:32:47,100
hard okay a few people I can be happy

00:32:43,860 --> 00:32:48,660
with that okay so we still have a few

00:32:47,100 --> 00:32:51,330
minutes left so I'll just run through

00:32:48,660 --> 00:32:55,340
the bonus chapter what else you can get

00:32:51,330 --> 00:33:00,390
from elasticsearch if you've if you've

00:32:55,340 --> 00:33:03,330
done so far as we've we've discussed so

00:33:00,390 --> 00:33:05,910
the first things that you can use on top

00:33:03,330 --> 00:33:07,470
of it is some features that we call

00:33:05,910 --> 00:33:10,440
suggester 'he's and there are two types

00:33:07,470 --> 00:33:12,990
of suggester xin elastic search for

00:33:10,440 --> 00:33:15,680
versus a terms or a phrase suggester

00:33:12,990 --> 00:33:17,670
which is the did you mean functionality

00:33:15,680 --> 00:33:20,130
remember we are the search guys we

00:33:17,670 --> 00:33:23,670
understand the text we have all this all

00:33:20,130 --> 00:33:26,550
the statistics on all the words how

00:33:23,670 --> 00:33:29,310
common it is in how many documents it is

00:33:26,550 --> 00:33:31,560
how many times in each document and all

00:33:29,310 --> 00:33:35,030
that so if you give us a word and we

00:33:31,560 --> 00:33:39,570
don't find it we can we can find you a

00:33:35,030 --> 00:33:40,440
one that's very close to it and we can

00:33:39,570 --> 00:33:42,660
use the

00:33:40,440 --> 00:33:45,660
statistics that we keep on those words

00:33:42,660 --> 00:33:48,360
to tell you how likely it is that you've

00:33:45,660 --> 00:33:49,820
just mistyped that it is fairly close to

00:33:48,360 --> 00:33:52,470
some word that we actually know about

00:33:49,820 --> 00:33:55,020
this is not based on a dictionary we

00:33:52,470 --> 00:33:57,000
don't actually have all the words for

00:33:55,020 --> 00:34:00,180
English we only have the words in your

00:33:57,000 --> 00:34:01,830
document so that's the terms suggester

00:34:00,180 --> 00:34:04,440
if you use the phrase one it will even

00:34:01,830 --> 00:34:07,080
be context-aware so if you actually

00:34:04,440 --> 00:34:10,830
search for Ruby on rail which is

00:34:07,080 --> 00:34:11,940
completely correct phrase we will

00:34:10,830 --> 00:34:14,700
actually tell you that you probably

00:34:11,940 --> 00:34:18,690
actually meant ruby on rails because

00:34:14,700 --> 00:34:21,840
that's actually much more common so do

00:34:18,690 --> 00:34:24,890
you mean Ruby on Rails well you probably

00:34:21,840 --> 00:34:27,990
my django but hey miss types happen and

00:34:24,890 --> 00:34:29,670
then the the next type of suggestions

00:34:27,990 --> 00:34:32,940
that we have is the completion suggester

00:34:29,670 --> 00:34:36,030
and that is the super fast suggest as

00:34:32,940 --> 00:34:38,070
you type 1 it is literally as you type

00:34:36,030 --> 00:34:40,170
because we actually can keep the

00:34:38,070 --> 00:34:42,120
response time under a millisecond so you

00:34:40,170 --> 00:34:44,820
can literally fire it up after every

00:34:42,120 --> 00:34:46,970
keystroke but there are some there are

00:34:44,820 --> 00:34:49,470
some trade-offs for example you need to

00:34:46,970 --> 00:34:51,930
manually tell us what are all the

00:34:49,470 --> 00:34:55,050
different variants of the input that we

00:34:51,930 --> 00:34:58,590
should autocomplete on for example if

00:34:55,050 --> 00:35:00,570
you're looking for hike on Australia you

00:34:58,590 --> 00:35:03,660
might also want to autocomplete this

00:35:00,570 --> 00:35:06,390
when somebody starts typing Australia

00:35:03,660 --> 00:35:08,520
first and then Python or pike on

00:35:06,390 --> 00:35:11,280
brisbane or something so you give

00:35:08,520 --> 00:35:14,490
multiple different inputs and one

00:35:11,280 --> 00:35:16,800
canonical output and you also want to

00:35:14,490 --> 00:35:19,170
give it a custom score because if you

00:35:16,800 --> 00:35:22,950
type a single letter we will provide you

00:35:19,170 --> 00:35:25,560
with with the completion suggestion but

00:35:22,950 --> 00:35:27,510
there is really no way we can do any

00:35:25,560 --> 00:35:30,210
sort of relevancy or anything like that

00:35:27,510 --> 00:35:34,020
based on the single letter so we rely on

00:35:30,210 --> 00:35:37,250
you to rank the results give importance

00:35:34,020 --> 00:35:40,740
to the individual document based on

00:35:37,250 --> 00:35:45,120
popularity based on how much they pay

00:35:40,740 --> 00:35:48,450
you whatever that against depends on

00:35:45,120 --> 00:35:50,070
your on your application so that's one

00:35:48,450 --> 00:35:53,610
additional feature that you can very

00:35:50,070 --> 00:35:54,180
easily add on top of on top of the

00:35:53,610 --> 00:35:56,370
search

00:35:54,180 --> 00:36:00,180
there is a suggest method just throw

00:35:56,370 --> 00:36:01,770
some data in there and it will work the

00:36:00,180 --> 00:36:03,840
next one is my favorite because it

00:36:01,770 --> 00:36:06,360
doesn't require any coding whatsoever

00:36:03,840 --> 00:36:07,980
you just install a tool called cabana

00:36:06,360 --> 00:36:10,380
which is essentially an interface to

00:36:07,980 --> 00:36:12,210
elasticsearch it's a JavaScript

00:36:10,380 --> 00:36:14,400
application that runs primarily in the

00:36:12,210 --> 00:36:17,100
browser and it gives you nice graphs

00:36:14,400 --> 00:36:19,530
like these so once you have index all

00:36:17,100 --> 00:36:21,360
your data into elasticsearch using your

00:36:19,530 --> 00:36:24,570
badge job and then keeping it in sync

00:36:21,360 --> 00:36:27,450
using the signal handlers you can get a

00:36:24,570 --> 00:36:30,000
nice overview of your data very easily

00:36:27,450 --> 00:36:31,800
very fast it again uses the aggregations

00:36:30,000 --> 00:36:34,470
framework so you can see that you have

00:36:31,800 --> 00:36:37,110
multidimensional aggregations here these

00:36:34,470 --> 00:36:39,990
this is an example with logs from a web

00:36:37,110 --> 00:36:41,730
server so here we have we're we have

00:36:39,990 --> 00:36:45,000
split the visitors by country that they

00:36:41,730 --> 00:36:47,210
came from for each country we split them

00:36:45,000 --> 00:36:50,550
first whether they were logged in or not

00:36:47,210 --> 00:36:52,560
and then for each of those subgroups we

00:36:50,550 --> 00:36:55,140
we present you what browser they used

00:36:52,560 --> 00:36:57,270
all in a single picture and you can

00:36:55,140 --> 00:36:58,590
immediately see that there are different

00:36:57,270 --> 00:37:00,770
countries that have dramatically

00:36:58,590 --> 00:37:03,930
different behavior from their users and

00:37:00,770 --> 00:37:05,880
you can see that immediately because you

00:37:03,930 --> 00:37:09,000
as humans are essentially a pattern

00:37:05,880 --> 00:37:09,990
recognition machines also when you look

00:37:09,000 --> 00:37:13,080
at the time line graph you can

00:37:09,990 --> 00:37:15,930
immediately notice the dick there you

00:37:13,080 --> 00:37:17,400
can see it but for to make a computer

00:37:15,930 --> 00:37:19,110
see it that would be fairly expensive

00:37:17,400 --> 00:37:21,840
and you would actually have to tell them

00:37:19,110 --> 00:37:25,020
what to look for with humans it's easy

00:37:21,840 --> 00:37:28,320
you just look and you see so that is why

00:37:25,020 --> 00:37:30,870
data visualizations are super useful and

00:37:28,320 --> 00:37:32,370
that is why i really love love cabana

00:37:30,870 --> 00:37:34,110
for this because once you have the data

00:37:32,370 --> 00:37:37,080
in elastic search you can do all sorts

00:37:34,110 --> 00:37:40,290
of analytics on your data for example in

00:37:37,080 --> 00:37:43,350
the library like what is the most

00:37:40,290 --> 00:37:45,960
borrowed book what is the book that

00:37:43,350 --> 00:37:49,050
people never returned it's probably in

00:37:45,960 --> 00:37:54,680
the how to commit suicide department and

00:37:49,050 --> 00:37:58,800
other different analytical run so

00:37:54,680 --> 00:38:00,120
gabbana just throw it in there just you

00:37:58,800 --> 00:38:01,680
don't have to install anything you can

00:38:00,120 --> 00:38:03,180
even run it locally on your machine you

00:38:01,680 --> 00:38:05,370
just tell you how to connect to your

00:38:03,180 --> 00:38:07,410
elasticsearch buster and this is what

00:38:05,370 --> 00:38:08,110
you get essentially for free you need to

00:38:07,410 --> 00:38:09,640
click a little bit

00:38:08,110 --> 00:38:13,650
to actually create those visualizations

00:38:09,640 --> 00:38:16,720
but that's all that is required and the

00:38:13,650 --> 00:38:19,270
last feature that I'll mention because

00:38:16,720 --> 00:38:21,310
it's fairly fairly interesting is the

00:38:19,270 --> 00:38:24,760
percolator so far we've been running

00:38:21,310 --> 00:38:26,080
queries on documents percolator puts it

00:38:24,760 --> 00:38:27,520
a little bit upside down and because

00:38:26,080 --> 00:38:31,750
we're in stray Lea we need to make that

00:38:27,520 --> 00:38:34,240
happen so previously we were indexing

00:38:31,750 --> 00:38:37,180
documents and running queries percolator

00:38:34,240 --> 00:38:40,420
we index queries and then run documents

00:38:37,180 --> 00:38:42,730
it answers the age-old question which

00:38:40,420 --> 00:38:46,330
queries would have matched on this

00:38:42,730 --> 00:38:47,830
document so it is very useful if you

00:38:46,330 --> 00:38:50,860
want if you want to have the stored

00:38:47,830 --> 00:38:52,780
search functionality a user does it does

00:38:50,860 --> 00:38:55,710
a search on your website and then they

00:38:52,780 --> 00:38:57,940
want to say hey save this search and

00:38:55,710 --> 00:39:00,550
alert me when there are new new

00:38:57,940 --> 00:39:02,290
documents that actually match you get

00:39:00,550 --> 00:39:04,870
that for free you can use it for

00:39:02,290 --> 00:39:07,480
classification for example it's fairly

00:39:04,870 --> 00:39:10,030
easy to craft a query that will only

00:39:07,480 --> 00:39:11,830
match documents in English because there

00:39:10,030 --> 00:39:14,950
are some words that only exists in

00:39:11,830 --> 00:39:17,830
English and if the document contains

00:39:14,950 --> 00:39:19,900
enough of those you can say with a good

00:39:17,830 --> 00:39:22,300
confidence that that document is in

00:39:19,900 --> 00:39:26,410
English and you can do the same for many

00:39:22,300 --> 00:39:28,840
other languages so then when you show

00:39:26,410 --> 00:39:31,540
show a document to a set of index

00:39:28,840 --> 00:39:34,090
queries like that you will get back the

00:39:31,540 --> 00:39:36,250
list of course that match in other words

00:39:34,090 --> 00:39:38,320
you'll get back the information and

00:39:36,250 --> 00:39:40,840
which language this document is actually

00:39:38,320 --> 00:39:43,360
written it so super simple you can also

00:39:40,840 --> 00:39:45,610
do the same for geolocation if you have

00:39:43,360 --> 00:39:47,770
if you have a geo coordinates in your

00:39:45,610 --> 00:39:50,680
document but you don't know where it is

00:39:47,770 --> 00:39:52,930
you can very simply construct a query

00:39:50,680 --> 00:39:56,980
that will match all the points in

00:39:52,930 --> 00:39:58,780
Australia so if you use that as a

00:39:56,980 --> 00:40:00,310
percolator you show it a point and

00:39:58,780 --> 00:40:02,860
you'll get back the information yeah

00:40:00,310 --> 00:40:05,230
it's in Australia in Queensland it's in

00:40:02,860 --> 00:40:08,800
Brisbane and you can sort of get back

00:40:05,230 --> 00:40:11,620
all of that based on a Geo point and

00:40:08,800 --> 00:40:15,870
that's it for me so if you have any

00:40:11,620 --> 00:40:15,870
questions of course Ross does

00:40:21,480 --> 00:40:30,240
just for that I won't ask the question

00:40:25,260 --> 00:40:33,190
thanks Santa you shouted slide where you

00:40:30,240 --> 00:40:35,800
updated order in or Institute the

00:40:33,190 --> 00:40:37,810
document into elasticsearch how do you

00:40:35,800 --> 00:40:40,510
keep track of documents about already in

00:40:37,810 --> 00:40:44,050
there when you update them why would I

00:40:40,510 --> 00:40:46,840
do Testament it's the same API you just

00:40:44,050 --> 00:40:48,520
call dot save and just like with Django

00:40:46,840 --> 00:40:50,200
models if it's there it would get

00:40:48,520 --> 00:40:54,790
updated if it's not there it will get

00:40:50,200 --> 00:40:58,660
inserted okay thanks sure thanks Sansa

00:40:54,790 --> 00:41:00,850
um a big a big project that's been

00:40:58,660 --> 00:41:03,940
around genco for a long time is hastag

00:41:00,850 --> 00:41:05,530
and what browser was the second question

00:41:03,940 --> 00:41:06,940
in the first one I know I thought I'd

00:41:05,530 --> 00:41:08,830
give it to you I've already come up with

00:41:06,940 --> 00:41:10,960
a reason I do the same thing search

00:41:08,830 --> 00:41:14,530
directly but can you answer from the

00:41:10,960 --> 00:41:18,040
stage why you didn't suggest haystack as

00:41:14,530 --> 00:41:19,840
part of that solution he stick his was

00:41:18,040 --> 00:41:22,720
very good when it when it came out and

00:41:19,840 --> 00:41:24,430
it made search a lot easier and the

00:41:22,720 --> 00:41:27,460
problem i have with haystack or why i

00:41:24,430 --> 00:41:30,280
don't recommend or talk about it is it

00:41:27,460 --> 00:41:34,390
has a very low ceiling it allows you to

00:41:30,280 --> 00:41:36,250
get from 0 to 10 super quickly and then

00:41:34,390 --> 00:41:39,360
you will never get past 10 or it will

00:41:36,250 --> 00:41:43,060
cost you an enormous amount of pain it

00:41:39,360 --> 00:41:45,610
was it was defined to get you a design

00:41:43,060 --> 00:41:47,590
to get you up and running and deliver a

00:41:45,610 --> 00:41:51,160
simple search but if you want to move

00:41:47,590 --> 00:41:53,680
past that it really has no way also it's

00:41:51,160 --> 00:41:55,900
a very generic tool that tries to cater

00:41:53,680 --> 00:41:58,690
to different search engines it supports

00:41:55,900 --> 00:42:01,840
whoosh and solar and zapien and elastic

00:41:58,690 --> 00:42:05,020
search and and others and they are very

00:42:01,840 --> 00:42:08,740
different so because haystack wants to

00:42:05,020 --> 00:42:10,720
support them all it had to make a

00:42:08,740 --> 00:42:13,150
conscious decision to only support the

00:42:10,720 --> 00:42:14,380
common denominator so actually ninety

00:42:13,150 --> 00:42:17,670
percent of the features that i presented

00:42:14,380 --> 00:42:21,880
here won't be available through haystack

00:42:17,670 --> 00:42:24,490
aggregations jesters percolators yeah

00:42:21,880 --> 00:42:27,460
and even the queries that that that are

00:42:24,490 --> 00:42:29,200
run with hastag are not as optimal it

00:42:27,460 --> 00:42:31,750
also forces you into the

00:42:29,200 --> 00:42:33,970
idea that documents are flat that you

00:42:31,750 --> 00:42:36,760
have Alyssa fields with values nothing

00:42:33,970 --> 00:42:40,930
else it's very difficult to have a list

00:42:36,760 --> 00:42:45,280
of nested objects with haystack so that

00:42:40,930 --> 00:42:47,670
is why i don't i don't recommend it and

00:42:45,280 --> 00:42:49,900
I tell a lie I will ask a question a

00:42:47,670 --> 00:42:51,430
variation on the theme of things that

00:42:49,900 --> 00:42:54,190
you may not recommend obviously I

00:42:51,430 --> 00:42:56,619
contains is doesn't do the job but

00:42:54,190 --> 00:42:59,859
postgres does have a text search index

00:42:56,619 --> 00:43:02,380
so how far down that path does does that

00:42:59,859 --> 00:43:04,780
compare with with elastic so it can do

00:43:02,380 --> 00:43:07,390
actually it performs fairly well with

00:43:04,780 --> 00:43:10,089
with the full text part it can do the

00:43:07,390 --> 00:43:13,000
analysis and you can do the queries the

00:43:10,089 --> 00:43:16,560
problem is that it's still within within

00:43:13,000 --> 00:43:20,589
the database so it's hard to actually

00:43:16,560 --> 00:43:23,349
have different shape of the of the

00:43:20,589 --> 00:43:25,599
document to perform all the all the

00:43:23,349 --> 00:43:28,780
joints and everything like there it is a

00:43:25,599 --> 00:43:30,790
it is a fairly good solution if you have

00:43:28,780 --> 00:43:33,849
a very small website and you just want

00:43:30,790 --> 00:43:37,540
to have this one one thing there but it

00:43:33,849 --> 00:43:38,980
gets super super expensive once you want

00:43:37,540 --> 00:43:41,109
to add something like facets which are

00:43:38,980 --> 00:43:42,849
not simply possible you would have to

00:43:41,109 --> 00:43:44,710
have a single query for each of the

00:43:42,849 --> 00:43:49,960
facet that you want to that you want to

00:43:44,710 --> 00:43:52,260
display etc so it is if you just want to

00:43:49,960 --> 00:43:54,250
if you just want a super simple search

00:43:52,260 --> 00:43:55,780
it's it's definitely an option

00:43:54,250 --> 00:43:58,780
especially if you don't want to invest

00:43:55,780 --> 00:44:01,510
into into running elasticsearch figuring

00:43:58,780 --> 00:44:03,579
out how to actually run Java or how to

00:44:01,510 --> 00:44:08,589
actually type elasticsearch enter on the

00:44:03,579 --> 00:44:11,170
command line and then it's it's an

00:44:08,589 --> 00:44:14,260
option it's sort of it's sort of the

00:44:11,170 --> 00:44:15,880
similar situation where like sequel

00:44:14,260 --> 00:44:17,680
light versus Paul squares sequel light

00:44:15,880 --> 00:44:20,140
is fine it works great it's a great

00:44:17,680 --> 00:44:22,810
database and if you can get away with

00:44:20,140 --> 00:44:25,180
using it sure go for it but postgres

00:44:22,810 --> 00:44:30,460
will give you so much more so it's sort

00:44:25,180 --> 00:44:32,349
of the similar answer um you just said

00:44:30,460 --> 00:44:34,119
the high stack only supports the thing

00:44:32,349 --> 00:44:36,550
that's common for all the search engines

00:44:34,119 --> 00:44:38,800
and instant you were with elastic

00:44:36,550 --> 00:44:41,589
specifically but we do have any input on

00:44:38,800 --> 00:44:42,830
what other engines exists and that may

00:44:41,589 --> 00:44:46,940
still be good

00:44:42,830 --> 00:44:53,360
just in the Sun trying to get me fired

00:44:46,940 --> 00:44:56,120
or as there are other search engines the

00:44:53,360 --> 00:44:58,760
most common common one that people use a

00:44:56,120 --> 00:45:01,280
solar it's also built on leucine same as

00:44:58,760 --> 00:45:05,660
elasticsearch so it uses the same sort

00:45:01,280 --> 00:45:07,910
of engine that actually does that's like

00:45:05,660 --> 00:45:10,550
the inverted index and the text analysis

00:45:07,910 --> 00:45:12,470
stuff and everything but it's it's a

00:45:10,550 --> 00:45:15,170
little it's a little older than a sixer

00:45:12,470 --> 00:45:17,420
JH you actually have to write some some

00:45:15,170 --> 00:45:20,480
XML for configuration and stuff like

00:45:17,420 --> 00:45:25,280
that it's more Java esque than a sixer

00:45:20,480 --> 00:45:26,990
JH and then there are others I consider

00:45:25,280 --> 00:45:29,600
the others to be slightly inferior

00:45:26,990 --> 00:45:32,450
because of leucine is just an amazing

00:45:29,600 --> 00:45:39,890
library that is that as the state of the

00:45:32,450 --> 00:45:42,080
art in in I forgot how this field is

00:45:39,890 --> 00:45:44,180
called I'm sorry information retrieval

00:45:42,080 --> 00:45:46,220
it's a state-of-the-art information

00:45:44,180 --> 00:45:48,170
retrieval library that's used by all of

00:45:46,220 --> 00:45:50,260
the all of the products including like

00:45:48,170 --> 00:45:53,180
IBM Watson the robot that won jeopardy

00:45:50,260 --> 00:45:54,710
it all uses leucine under the covers

00:45:53,180 --> 00:45:56,810
solo scene is definitely where it's at

00:45:54,710 --> 00:45:58,190
and then it's a choice between solar and

00:45:56,810 --> 00:46:01,400
elasticsearch I typically recommend

00:45:58,190 --> 00:46:02,720
people spend five minutes with each see

00:46:01,400 --> 00:46:07,250
how far you can get with elastic search

00:46:02,720 --> 00:46:10,370
and see if you can get solar running I'm

00:46:07,250 --> 00:46:13,880
sorry that was a little low blow but so

00:46:10,370 --> 00:46:15,950
I'm elasticsearch if I were to search

00:46:13,880 --> 00:46:18,380
for without the name what is it is it

00:46:15,950 --> 00:46:20,900
it's not a search engine what is it it's

00:46:18,380 --> 00:46:22,400
a datastore it is a data store it's a

00:46:20,900 --> 00:46:23,840
fully clustered solution so just start

00:46:22,400 --> 00:46:26,300
two of them on your machine they'll find

00:46:23,840 --> 00:46:29,380
each other they have a former cluster it

00:46:26,300 --> 00:46:31,820
can scale up really high we've seen

00:46:29,380 --> 00:46:34,610
clusters with data approaching a

00:46:31,820 --> 00:46:36,080
petabyte so it can scale really far

00:46:34,610 --> 00:46:38,630
we've seen it running on the Raspberry

00:46:36,080 --> 00:46:43,190
Pi so it scales really low never ever do

00:46:38,630 --> 00:46:44,390
that but it is possible so that's the

00:46:43,190 --> 00:46:45,680
short answer and I'm afraid we are

00:46:44,390 --> 00:46:48,020
running out of time thank you i will

00:46:45,680 --> 00:46:50,270
also have a talk on sunday how you can

00:46:48,020 --> 00:46:52,910
use elasticsearch to store logs into it

00:46:50,270 --> 00:46:54,920
and in the meantime if you ever see me

00:46:52,910 --> 00:46:56,420
around and you have a question about

00:46:54,920 --> 00:46:58,760
asking search you can ask me

00:46:56,420 --> 00:47:01,610
and also there's Joshua also from from

00:46:58,760 --> 00:47:04,520
astok and you can ask ask him some

00:47:01,610 --> 00:47:06,380
questions too he is one of our support

00:47:04,520 --> 00:47:10,190
engineer so he has all the answers and

00:47:06,380 --> 00:47:13,090
all the patients so thank you very much

00:47:10,190 --> 00:47:13,090
thank you again honza

00:47:21,730 --> 00:47:23,790

YouTube URL: https://www.youtube.com/watch?v=1KHM7WvNeL4


