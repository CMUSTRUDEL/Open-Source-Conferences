Title: Pythonic iterators and generators
Publication date: 2013-07-11
Playlist: Pycon Australia 2013
Description: 
	Lakshman  Prasad
http://2013.pycon-au.org/schedule/30086/view_talk
One of the first things you learn in programming is to apply a series of instructions to a set of elements.

Given it's ubiquitous nature and given the culture of python to simplify such tasks, decades of development and thought has gone into making this as convenient as possible for all possible use cases. While the functional ways of iterating like map, reduce and filter exist, list-comprehensions and the functions in itertoo
Captions: 
	00:00:00,500 --> 00:00:06,450
can you hear me thank you for the

00:00:04,140 --> 00:00:10,500
introduction my name is Lakshman Prasad

00:00:06,450 --> 00:00:12,719
I work for McKinsey & Company McKinsey

00:00:10,500 --> 00:00:15,089
does management consulting I work for a

00:00:12,719 --> 00:00:17,340
division that works the consultants in

00:00:15,089 --> 00:00:19,730
order Dell our deliver technology

00:00:17,340 --> 00:00:22,080
solutions to the end clients

00:00:19,730 --> 00:00:24,590
my primary expertise has been in the

00:00:22,080 --> 00:00:27,029
Python ecosystem and a set of tools

00:00:24,590 --> 00:00:30,330
although in the last year I have had to

00:00:27,029 --> 00:00:32,329
significantly work on JavaScript I have

00:00:30,330 --> 00:00:34,980
never done an intro-level talk

00:00:32,329 --> 00:00:36,420
particularly on Python particularly

00:00:34,980 --> 00:00:39,750
coming after a good session with Peter

00:00:36,420 --> 00:00:42,210
and it can be hard but when I write such

00:00:39,750 --> 00:00:45,149
answers about detailed explanations on

00:00:42,210 --> 00:00:46,860
Stack Overflow I get a lot of very

00:00:45,149 --> 00:00:54,059
positive feedback so that's what I'm

00:00:46,860 --> 00:00:56,129
trying to do today yeah and by answering

00:00:54,059 --> 00:00:59,010
many of those questions I happen to be

00:00:56,129 --> 00:01:01,430
among the 1.00 5% of the stack overflow

00:00:59,010 --> 00:01:04,710
users we're answering all questions

00:01:01,430 --> 00:01:06,390
explained particularly with regards to

00:01:04,710 --> 00:01:08,729
the basic Python so I'll try and see

00:01:06,390 --> 00:01:10,229
what I can do I had a great time of the

00:01:08,729 --> 00:01:13,320
conference by the way such a nicety

00:01:10,229 --> 00:01:14,970
well-organized such nice fun since all

00:01:13,320 --> 00:01:18,210
of you just had lunch maybe it's a good

00:01:14,970 --> 00:01:19,950
idea we start with our a little bit of

00:01:18,210 --> 00:01:21,930
warm-up exercise for those of you that

00:01:19,950 --> 00:01:23,430
know but don't worry if you don't if you

00:01:21,930 --> 00:01:24,600
don't get though if you don't know the

00:01:23,430 --> 00:01:26,640
solutions to what we're discussing right

00:01:24,600 --> 00:01:28,049
now the objective is at the end of the

00:01:26,640 --> 00:01:31,590
session you will be in a position to be

00:01:28,049 --> 00:01:33,060
able to so let's say we have a

00:01:31,590 --> 00:01:34,829
dictionary of states map to their

00:01:33,060 --> 00:01:37,560
capitals we need a dictionary of states

00:01:34,829 --> 00:01:40,350
map to their capitals first we have

00:01:37,560 --> 00:01:46,680
states and then we also have capitals

00:01:40,350 --> 00:01:48,570
now here so if I want a dictionary that

00:01:46,680 --> 00:01:50,100
map's States to the capitals how would

00:01:48,570 --> 00:01:53,180
you get it you have a list of states and

00:01:50,100 --> 00:01:53,180
you have a list of capitals

00:01:56,510 --> 00:02:03,260
all right so here's a hint zip of states

00:01:59,480 --> 00:02:06,410
and capitals gives you a couple of both

00:02:03,260 --> 00:02:08,300
state as well as capital so zip is a

00:02:06,410 --> 00:02:11,060
constructor in Python that takes a

00:02:08,300 --> 00:02:14,270
stream of pairs sorry a pair of streams

00:02:11,060 --> 00:02:16,160
and gives you a stream of pairs so if

00:02:14,270 --> 00:02:18,050
anybody knows I'm sure you learnt a

00:02:16,160 --> 00:02:20,780
constructor of a dict earlier in Peter

00:02:18,050 --> 00:02:23,360
session so if you pass a dict

00:02:20,780 --> 00:02:27,500
constructor our pair of streams

00:02:23,360 --> 00:02:28,910
essentially what you get is a dictum

00:02:27,500 --> 00:02:31,550
that gives us the it's map to the

00:02:28,910 --> 00:02:34,400
corresponding capitals so similarly

00:02:31,550 --> 00:02:35,840
let's go to the next question we have a

00:02:34,400 --> 00:02:37,760
list this is one of the most popular

00:02:35,840 --> 00:02:40,370
courses Exede coming up we were so very

00:02:37,760 --> 00:02:42,320
so often of being asked by a lot of

00:02:40,370 --> 00:02:43,850
people on various different channels

00:02:42,320 --> 00:02:46,040
particularly Stack Overflow I have a

00:02:43,850 --> 00:02:49,010
list of lists I want to do something on

00:02:46,040 --> 00:02:51,200
all of these how do I go about it what

00:02:49,010 --> 00:02:54,440
would you do what are the ways in which

00:02:51,200 --> 00:02:56,480
you can flatten a list or you want to

00:02:54,440 --> 00:02:58,310
execute something on every element in

00:02:56,480 --> 00:03:04,750
multiple lists rather than one of them

00:02:58,310 --> 00:03:08,840
what would you do there's any solutions

00:03:04,750 --> 00:03:11,510
well you might have learnt it already

00:03:08,840 --> 00:03:14,480
but if you don't know Python supports

00:03:11,510 --> 00:03:16,880
operator overloading therefore some in

00:03:14,480 --> 00:03:20,330
the case of a list is moppet to

00:03:16,880 --> 00:03:22,100
extending a list what you do is you take

00:03:20,330 --> 00:03:24,290
an empty list and then you sum all of

00:03:22,100 --> 00:03:26,000
the lists that will give you a list of

00:03:24,290 --> 00:03:29,300
all the list that you're talking about

00:03:26,000 --> 00:03:31,850
so those of those of you that are

00:03:29,300 --> 00:03:34,040
inclined functionally thinking who can

00:03:31,850 --> 00:03:36,370
think about map and radios you can of

00:03:34,040 --> 00:03:38,750
course also use map and ideas also

00:03:36,370 --> 00:03:40,370
there's really no reason you would have

00:03:38,750 --> 00:03:41,570
to do such a kind of thing because I

00:03:40,370 --> 00:03:44,060
think there are several Python

00:03:41,570 --> 00:03:45,500
alternatives which are imperative so

00:03:44,060 --> 00:03:47,630
what if you want to do it in map hundred

00:03:45,500 --> 00:03:50,510
years there are MapReduce solutions you

00:03:47,630 --> 00:03:53,270
take a map you pass each and every list

00:03:50,510 --> 00:03:57,230
to make it a list and operate a lot add

00:03:53,270 --> 00:03:59,570
is the same as doing plus explicitly so

00:03:57,230 --> 00:04:02,030
you have five plus four but you want to

00:03:59,570 --> 00:04:03,709
do it functionally without explicitly

00:04:02,030 --> 00:04:05,450
mentioning plus what would you do you

00:04:03,709 --> 00:04:07,609
import the operator module and you say

00:04:05,450 --> 00:04:09,500
operator that sum and you apply that in

00:04:07,609 --> 00:04:10,310
five and four that's exactly what this

00:04:09,500 --> 00:04:12,410
is doing you

00:04:10,310 --> 00:04:13,849
mopping and you're doing a MapReduce on

00:04:12,410 --> 00:04:15,590
all of these lists in order to give you

00:04:13,849 --> 00:04:18,709
a list of lists this is one of the way

00:04:15,590 --> 00:04:22,160
and then we will go through a lot of the

00:04:18,709 --> 00:04:23,930
details about data tools module but it's

00:04:22,160 --> 00:04:25,850
a tools module supports one important

00:04:23,930 --> 00:04:27,800
thing called chain you have a list of

00:04:25,850 --> 00:04:30,830
iterables you take a chain and to it you

00:04:27,800 --> 00:04:33,110
pass with all the different lists that

00:04:30,830 --> 00:04:35,810
you have individually the star supports

00:04:33,110 --> 00:04:38,540
the star argument essentially you know

00:04:35,810 --> 00:04:40,400
gives individual s the four of them as

00:04:38,540 --> 00:04:42,620
argument scintillator to the chain and

00:04:40,400 --> 00:04:45,430
then that gives you a list of all of the

00:04:42,620 --> 00:04:48,260
elements in the in the list of lists

00:04:45,430 --> 00:04:51,169
similarly this is a new feature

00:04:48,260 --> 00:04:52,760
introduced in python 2.6 essentially of

00:04:51,169 --> 00:04:55,220
what you're doing earlier you are

00:04:52,760 --> 00:04:56,870
expanding you they reduce the chain

00:04:55,220 --> 00:04:59,030
you're passing four different lists as

00:04:56,870 --> 00:05:02,030
arguments but that may not be possible

00:04:59,030 --> 00:05:04,370
your list of lists may be continuous it

00:05:02,030 --> 00:05:06,470
may be keep going on so you don't want

00:05:04,370 --> 00:05:09,260
to expand it individually into so many

00:05:06,470 --> 00:05:11,240
different things so python 2.6 in later

00:05:09,260 --> 00:05:13,729
to smart you'll added a new thing called

00:05:11,240 --> 00:05:15,350
as it at will change or from iterable so

00:05:13,729 --> 00:05:18,260
you can pass it on a table so you don't

00:05:15,350 --> 00:05:20,060
even have to separate all of these four

00:05:18,260 --> 00:05:22,370
lists into four lists like you read

00:05:20,060 --> 00:05:24,590
elsewhere but the most obvious the most

00:05:22,370 --> 00:05:26,750
pythonic way of doing it as long as the

00:05:24,590 --> 00:05:29,240
list is only two levels deep would be to

00:05:26,750 --> 00:05:31,430
use a multiple for loop nested for loop

00:05:29,240 --> 00:05:33,620
in the form fill is comprehension so you

00:05:31,430 --> 00:05:35,979
do for each list and list of lists for H

00:05:33,620 --> 00:05:38,060
X in each list give it to me in a list

00:05:35,979 --> 00:05:40,570
so that's about in fact it can go

00:05:38,060 --> 00:05:42,530
multiple levels you even using this

00:05:40,570 --> 00:05:44,060
don't worry about it by the end of the

00:05:42,530 --> 00:05:45,350
session my hope is all of you will be in

00:05:44,060 --> 00:05:49,729
a position to be able to write things

00:05:45,350 --> 00:05:52,250
like that so another question we want to

00:05:49,729 --> 00:05:54,530
have a product of things so you have a B

00:05:52,250 --> 00:05:57,590
C and you have one too I want to have a

00:05:54,530 --> 00:06:02,300
one a to it and then b1 b2 c1 c2 how

00:05:57,590 --> 00:06:04,100
would you do it it's easy I mean you

00:06:02,300 --> 00:06:05,840
already know iterate it a tools module

00:06:04,100 --> 00:06:08,930
they've come across that some some

00:06:05,840 --> 00:06:11,479
places it's very simple you just do it

00:06:08,930 --> 00:06:14,180
at was a product the point is it a toast

00:06:11,479 --> 00:06:16,250
module has some of these things that you

00:06:14,180 --> 00:06:16,789
might want to do if you have ever want

00:06:16,250 --> 00:06:19,280
to do

00:06:16,789 --> 00:06:21,210
ABC you have a B and one two and if you

00:06:19,280 --> 00:06:22,800
ever want a 1 B 2

00:06:21,210 --> 00:06:24,630
then things like that expanding you

00:06:22,800 --> 00:06:27,180
don't necessarily have to write multiple

00:06:24,630 --> 00:06:28,380
loops you can import the things from it

00:06:27,180 --> 00:06:30,330
too towards the product and then just

00:06:28,380 --> 00:06:33,509
pass to listen to it and then you have

00:06:30,330 --> 00:06:35,639
all of those expander similarly let's

00:06:33,509 --> 00:06:40,410
say now you want a power set of range of

00:06:35,639 --> 00:06:44,910
values what is the power set you have so

00:06:40,410 --> 00:06:47,789
you have 0 1 2 3 are my elements I want

00:06:44,910 --> 00:06:51,539
to have everything from null element to

00:06:47,789 --> 00:06:53,460
0 1 2 3 including 1 2 which is a single

00:06:51,539 --> 00:06:54,810
element 2 element 3 element how do you

00:06:53,460 --> 00:06:59,270
do if I go about doing it

00:06:54,810 --> 00:07:02,370
so again hitter Tools has another

00:06:59,270 --> 00:07:06,060
function Carla's combination so you pass

00:07:02,370 --> 00:07:07,680
the combination for NCR so for one to

00:07:06,060 --> 00:07:12,210
give me all possible combinations like

00:07:07,680 --> 00:07:15,930
you see can give you 0 1 0 2 1 2 4 0 1 2

00:07:12,210 --> 00:07:18,120
4 2 C 3 C 2 these are the various

00:07:15,930 --> 00:07:21,030
different operations possible you just

00:07:18,120 --> 00:07:23,220
loop on the same thing for each and

00:07:21,030 --> 00:07:28,080
every possible are you get the entire

00:07:23,220 --> 00:07:30,570
power set so that's about the quick

00:07:28,080 --> 00:07:32,460
warm-up exercise hopefully it will be in

00:07:30,570 --> 00:07:34,110
a question to that like I said so let's

00:07:32,460 --> 00:07:35,669
go to the basics of iterations the

00:07:34,110 --> 00:07:38,370
reason all of this is possible is

00:07:35,669 --> 00:07:40,289
because python has certain abstractions

00:07:38,370 --> 00:07:42,210
defined for iteration itself at the most

00:07:40,289 --> 00:07:45,539
basic level which if you understand and

00:07:42,210 --> 00:07:47,280
implement in your own programs well you

00:07:45,539 --> 00:07:48,990
can do similar kind of things implement

00:07:47,280 --> 00:07:51,330
similar things in your code which is the

00:07:48,990 --> 00:07:53,669
most important thing and you also need

00:07:51,330 --> 00:07:55,380
to leverage what is presented in the

00:07:53,669 --> 00:07:57,900
what is available in the standard

00:07:55,380 --> 00:07:59,520
library as iterators so what is the

00:07:57,900 --> 00:08:00,930
standard follow-up this is a standard

00:07:59,520 --> 00:08:02,940
for loop right everybody that learns

00:08:00,930 --> 00:08:05,340
programming this is the first thing to

00:08:02,940 --> 00:08:09,690
learn so you have a you keep an integer

00:08:05,340 --> 00:08:11,729
and then you loop until the length of an

00:08:09,690 --> 00:08:13,710
array until the length of an array until

00:08:11,729 --> 00:08:15,300
you get a particular element you do

00:08:13,710 --> 00:08:16,710
something about it in this case print

00:08:15,300 --> 00:08:19,770
and then you increment to the element

00:08:16,710 --> 00:08:21,330
this is a standard for a standard

00:08:19,770 --> 00:08:22,860
looping at the start the first thing

00:08:21,330 --> 00:08:24,419
everyone learns the primary reason this

00:08:22,860 --> 00:08:27,539
is taught first is because this is the

00:08:24,419 --> 00:08:28,919
thing that works on all languages but

00:08:27,539 --> 00:08:30,630
Python programmers know better than to

00:08:28,919 --> 00:08:33,750
do that you don't have to explicitly

00:08:30,630 --> 00:08:34,740
keep incrementing and an integer all the

00:08:33,750 --> 00:08:37,200
time

00:08:34,740 --> 00:08:39,840
why use an integer so you could always

00:08:37,200 --> 00:08:41,550
use something like range even range of

00:08:39,840 --> 00:08:45,000
flan is something that is not necessary

00:08:41,550 --> 00:08:49,550
you know that we can do for element in a

00:08:45,000 --> 00:08:52,710
less print element so so this is what

00:08:49,550 --> 00:08:55,400
creates this this is what an iterator

00:08:52,710 --> 00:08:58,400
can do for you all sequences are in

00:08:55,400 --> 00:08:58,400
iterators

00:09:10,450 --> 00:09:17,800
so let's talk about iterables so all the

00:09:14,470 --> 00:09:20,079
sequences be it characters or a list or

00:09:17,800 --> 00:09:22,930
at Apple all of these are iterables what

00:09:20,079 --> 00:09:24,820
is an iterator iterator technically is

00:09:22,930 --> 00:09:26,889
something that implements two things

00:09:24,820 --> 00:09:29,350
those two things are eater method as

00:09:26,889 --> 00:09:31,690
well as the next method here instead of

00:09:29,350 --> 00:09:33,880
creating similar to a list way similar

00:09:31,690 --> 00:09:37,240
to an inbuilt list that can loop I have

00:09:33,880 --> 00:09:39,820
a class called as fib which essentially

00:09:37,240 --> 00:09:42,100
generates Fibonacci series so in order

00:09:39,820 --> 00:09:44,829
to make it implementable so if you using

00:09:42,100 --> 00:09:47,079
Fibonacci Fibonacci class essentially

00:09:44,829 --> 00:09:50,290
what you would do in your code is for

00:09:47,079 --> 00:09:53,470
element in fib then loop over it so

00:09:50,290 --> 00:09:55,209
every time of if the fib is called it

00:09:53,470 --> 00:09:58,649
the first time it is called it takes the

00:09:55,209 --> 00:10:01,540
eater and gives you the zero and one or

00:09:58,649 --> 00:10:04,000
whatever the corresponding of Fibonacci

00:10:01,540 --> 00:10:06,160
value is in this case it happens to give

00:10:04,000 --> 00:10:09,339
it give you the same class but you can

00:10:06,160 --> 00:10:11,769
also return some other class but so the

00:10:09,339 --> 00:10:13,990
next time of Fibonacci whenever you want

00:10:11,769 --> 00:10:17,110
the next element the for loop next is

00:10:13,990 --> 00:10:19,839
called and then you get the next element

00:10:17,110 --> 00:10:22,300
and the same thing goes on until the

00:10:19,839 --> 00:10:24,220
stop iteration exception is raised so

00:10:22,300 --> 00:10:26,709
this is a fundamental for loop

00:10:24,220 --> 00:10:28,810
essentially in Python a for loop is

00:10:26,709 --> 00:10:31,449
something which has two methods which is

00:10:28,810 --> 00:10:33,940
eater and next it'll gives out the

00:10:31,449 --> 00:10:36,339
element which has it it had use out to

00:10:33,940 --> 00:10:41,130
you a particular object which has next

00:10:36,339 --> 00:10:45,010
which on which next can be run upon so

00:10:41,130 --> 00:10:46,630
all I said that Python iterators or

00:10:45,010 --> 00:10:49,390
something that has eater as well as next

00:10:46,630 --> 00:10:51,070
we can assume that while that in the

00:10:49,390 --> 00:10:54,670
case of string it is an exception

00:10:51,070 --> 00:10:57,100
strings don't necessarily eat our method

00:10:54,670 --> 00:11:00,279
but still you can loop on because it has

00:10:57,100 --> 00:11:02,500
get item but that's technical you know

00:11:00,279 --> 00:11:04,390
exception before our purpose you could

00:11:02,500 --> 00:11:06,730
assume anything that has eater as well

00:11:04,390 --> 00:11:09,850
as next is considered an iterator in

00:11:06,730 --> 00:11:12,010
Python and when you call an eater on net

00:11:09,850 --> 00:11:15,250
you need to get provide an element on

00:11:12,010 --> 00:11:17,769
which next can be run upon and each time

00:11:15,250 --> 00:11:19,870
you run a for loop for element in this

00:11:17,769 --> 00:11:24,630
and next will be called upon the same

00:11:19,870 --> 00:11:24,630
iterator and so

00:11:27,920 --> 00:11:32,700
so it is important to differentiate in

00:11:31,020 --> 00:11:35,040
this case between an iterable and an

00:11:32,700 --> 00:11:37,260
iterator and iterable is something that

00:11:35,040 --> 00:11:39,720
has this method and iterator is a

00:11:37,260 --> 00:11:43,830
specific point in that iterator in that

00:11:39,720 --> 00:11:46,080
iterable so you same iterable for

00:11:43,830 --> 00:11:48,270
example can have multiple iterators one

00:11:46,080 --> 00:11:51,450
of the ways is itertools library has a

00:11:48,270 --> 00:11:53,250
method called as T which takes a single

00:11:51,450 --> 00:11:54,690
iterator and provides you multiple

00:11:53,250 --> 00:11:56,370
iterators what you would want to use it

00:11:54,690 --> 00:11:59,010
for may be if you want to chain a

00:11:56,370 --> 00:12:00,810
certain things for example ABC if I want

00:11:59,010 --> 00:12:02,940
to get the first element of this and the

00:12:00,810 --> 00:12:05,279
second element of this then if I T it I

00:12:02,940 --> 00:12:07,890
am able to since I have two iterators

00:12:05,279 --> 00:12:09,480
right now I can get her element from a

00:12:07,890 --> 00:12:15,930
particular position in this and from a

00:12:09,480 --> 00:12:19,589
different position in this standard

00:12:15,930 --> 00:12:22,170
library provides many iterators you see

00:12:19,589 --> 00:12:25,290
that we saw the state capitals earlier

00:12:22,170 --> 00:12:27,180
if I happen to print all of the element

00:12:25,290 --> 00:12:31,470
in the state capitals it prints all of

00:12:27,180 --> 00:12:33,209
them in a particular order and then you

00:12:31,470 --> 00:12:35,550
it is important to note that dictionary

00:12:33,209 --> 00:12:37,080
is not necessarily a list kind of data

00:12:35,550 --> 00:12:39,540
structure there is no order in a

00:12:37,080 --> 00:12:41,910
dictionary a dictionary is a hash table

00:12:39,540 --> 00:12:46,170
and it is represented by different keys

00:12:41,910 --> 00:12:47,580
but when I try to find out when I try to

00:12:46,170 --> 00:12:49,680
print all the elements within the

00:12:47,580 --> 00:12:51,480
dictionary I get printed all of the keys

00:12:49,680 --> 00:12:52,830
in a particular order this is because

00:12:51,480 --> 00:12:55,290
the dictionary follows the iterator

00:12:52,830 --> 00:12:57,630
protocol and they terator protocol the

00:12:55,290 --> 00:12:59,220
only thing it has to add is to be able

00:12:57,630 --> 00:13:01,410
to give you a next element

00:12:59,220 --> 00:13:02,910
you can't ask it what is the what is the

00:13:01,410 --> 00:13:05,100
zeroth element what is the twentieth

00:13:02,910 --> 00:13:06,240
element how am i doing in between these

00:13:05,100 --> 00:13:07,829
elements you can't really ask that

00:13:06,240 --> 00:13:10,680
although you can using some other things

00:13:07,829 --> 00:13:12,570
which we'll get into but the essential

00:13:10,680 --> 00:13:16,170
quality for an iterator object is just

00:13:12,570 --> 00:13:18,870
being able to run next on it and since

00:13:16,170 --> 00:13:21,630
the expectation is so limited all you

00:13:18,870 --> 00:13:23,070
can have iterators implemented on so

00:13:21,630 --> 00:13:25,110
many different and related kinds of

00:13:23,070 --> 00:13:28,050
things on everything that can have

00:13:25,110 --> 00:13:29,730
something of a sequence and some

00:13:28,050 --> 00:13:31,170
everything that you can have a next

00:13:29,730 --> 00:13:33,029
element that you want to provide

00:13:31,170 --> 00:13:37,440
including dictionaries and your own

00:13:33,029 --> 00:13:39,510
classes similarly if you don't want

00:13:37,440 --> 00:13:41,970
the keys if you want to happen to get

00:13:39,510 --> 00:13:44,460
values you can also get values and if

00:13:41,970 --> 00:13:46,290
you want to get both lists keys and

00:13:44,460 --> 00:13:48,420
values and a dictionary has something

00:13:46,290 --> 00:13:56,580
called as either items this gives you a

00:13:48,420 --> 00:13:59,970
couple of keys and values so it's not

00:13:56,580 --> 00:14:00,660
all about if the standard library has OS

00:13:59,970 --> 00:14:02,970
that walk

00:14:00,660 --> 00:14:05,220
who is that walk takes all of the

00:14:02,970 --> 00:14:07,920
different files that you have in a

00:14:05,220 --> 00:14:09,030
particular folder and gives you each and

00:14:07,920 --> 00:14:11,250
everything you can't you have to

00:14:09,030 --> 00:14:12,900
recognize in this case the operating

00:14:11,250 --> 00:14:14,580
system file system is the 2-dimensional

00:14:12,900 --> 00:14:16,880
data structure with folders and files

00:14:14,580 --> 00:14:19,860
but that doesn't stop us from getting

00:14:16,880 --> 00:14:21,840
each and every file in a single list and

00:14:19,860 --> 00:14:23,430
OS dot work happens to be one such

00:14:21,840 --> 00:14:26,910
function that takes a file system path

00:14:23,430 --> 00:14:29,010
and gives you all of the files in that

00:14:26,910 --> 00:14:30,540
folder in a nested structure although it

00:14:29,010 --> 00:14:32,100
is in a nester stuff structure and

00:14:30,540 --> 00:14:33,660
because it is in an extra nested

00:14:32,100 --> 00:14:35,630
structure it gives you a three element

00:14:33,660 --> 00:14:39,090
tuple which is I think the first one is

00:14:35,630 --> 00:14:40,530
the individual folder the top folder the

00:14:39,090 --> 00:14:41,580
second one is the sub folder and then

00:14:40,530 --> 00:14:47,580
the name of the file is something of

00:14:41,580 --> 00:14:49,890
that so also you can do do a standard

00:14:47,580 --> 00:14:52,260
iteration process even on the files you

00:14:49,890 --> 00:14:54,000
have to notice again in this case you

00:14:52,260 --> 00:14:56,580
can't get to a hundred line of a file

00:14:54,000 --> 00:15:00,690
you have to read the first 99 in order

00:14:56,580 --> 00:15:02,820
to get to the hundred but because we

00:15:00,690 --> 00:15:04,740
have an iterator we don't have to do

00:15:02,820 --> 00:15:06,660
read line each and every time you can

00:15:04,740 --> 00:15:11,580
just say four line in these lines give

00:15:06,660 --> 00:15:14,070
me each and every line not just that

00:15:11,580 --> 00:15:15,930
because you have these iterables sign

00:15:14,070 --> 00:15:17,790
iterator protocol implemented in all of

00:15:15,930 --> 00:15:19,830
these places this can be consumed in so

00:15:17,790 --> 00:15:21,720
many interesting ways one of the

00:15:19,830 --> 00:15:23,850
important example happens to be a list a

00:15:21,720 --> 00:15:27,690
list is a struct a list is a method in

00:15:23,850 --> 00:15:29,610
Python which takes any iterator and then

00:15:27,690 --> 00:15:32,790
expands it to you you might have noticed

00:15:29,610 --> 00:15:34,170
that I have been using lists earlier in

00:15:32,790 --> 00:15:37,350
order to print things that is because

00:15:34,170 --> 00:15:39,000
otherwise what little print is just here

00:15:37,350 --> 00:15:41,670
you have a generator with a class of

00:15:39,000 --> 00:15:43,860
class representation so if you just cast

00:15:41,670 --> 00:15:45,720
it into your list what the list does is

00:15:43,860 --> 00:15:47,100
goes through each and every element by

00:15:45,720 --> 00:15:50,560
calling the next on each of them and

00:15:47,100 --> 00:15:53,990
then gives you what it will be finally

00:15:50,560 --> 00:15:59,080
and then not just lists you can give

00:15:53,990 --> 00:15:59,080
similarly maximum-minimum i sure

00:16:00,820 --> 00:16:12,560
increase the font of it I'll try so

00:16:08,270 --> 00:16:13,820
turns out that I'm using revealed ojs

00:16:12,560 --> 00:16:14,990
and you know to increase the font of

00:16:13,820 --> 00:16:16,910
this one I will have to mess with

00:16:14,990 --> 00:16:20,570
internals right now otherwise it only

00:16:16,910 --> 00:16:26,000
increases the other things so all right

00:16:20,570 --> 00:16:27,650
sorry about that so a standard library

00:16:26,000 --> 00:16:29,900
also consumes iterators in many places

00:16:27,650 --> 00:16:31,970
like you can do a maximum of any

00:16:29,900 --> 00:16:34,370
iterator that has numeral values you can

00:16:31,970 --> 00:16:36,020
also do a minimum you can do a sum it

00:16:34,370 --> 00:16:37,880
does not have to be a list it can be any

00:16:36,020 --> 00:16:41,029
iterator anything that can give you a

00:16:37,880 --> 00:16:42,830
next item upon similarly you have a list

00:16:41,029 --> 00:16:47,810
of iterators you want to print them then

00:16:42,830 --> 00:16:50,600
you can just join them and then you will

00:16:47,810 --> 00:16:52,339
have all of those I would join them as a

00:16:50,600 --> 00:16:53,870
string with a particular string in

00:16:52,339 --> 00:16:55,820
between and then you can print that like

00:16:53,870 --> 00:16:57,860
I have done here in order to print all

00:16:55,820 --> 00:17:02,060
the different letters in a particular

00:16:57,860 --> 00:17:07,550
word one line by line by adding a /n at

00:17:02,060 --> 00:17:09,679
after each one of them so that's about

00:17:07,550 --> 00:17:12,110
the iterators in the standard library we

00:17:09,679 --> 00:17:13,850
also have so should you have to write a

00:17:12,110 --> 00:17:15,459
custom iterator how would you write one

00:17:13,850 --> 00:17:17,689
we already briefly went through that

00:17:15,459 --> 00:17:19,850
iterator for writing a Fibonacci

00:17:17,689 --> 00:17:22,250
iterator all it takes is writing a

00:17:19,850 --> 00:17:25,880
knitter as well as implementing a next

00:17:22,250 --> 00:17:27,260
method on the corresponding class so if

00:17:25,880 --> 00:17:29,090
you want to write a custom iterator

00:17:27,260 --> 00:17:30,620
let's take for example a real world

00:17:29,090 --> 00:17:33,800
example where you have a car and you

00:17:30,620 --> 00:17:38,870
have a deck a deck has 52 cards of

00:17:33,800 --> 00:17:43,520
spades and then you know diamonds Hart

00:17:38,870 --> 00:17:46,309
and clubs so if when you instantiate a

00:17:43,520 --> 00:17:50,110
deck it instantiates itself with all of

00:17:46,309 --> 00:17:54,470
the cards that you will need and then

00:17:50,110 --> 00:17:57,140
the objective is to be able to do 4 card

00:17:54,470 --> 00:17:59,020
in a deck and then print everything you

00:17:57,140 --> 00:18:03,620
are able to do it in this case because

00:17:59,020 --> 00:18:05,390
on the deck in the ether method I return

00:18:03,620 --> 00:18:06,950
not the like I said earlier you can

00:18:05,390 --> 00:18:09,140
return something that needs to have a

00:18:06,950 --> 00:18:13,100
next item upon and the next has been

00:18:09,140 --> 00:18:15,110
implemented for a list and since the

00:18:13,100 --> 00:18:17,000
deck is only storing all the cards

00:18:15,110 --> 00:18:20,690
during its initialization in the init

00:18:17,000 --> 00:18:23,510
when you try to return you return the

00:18:20,690 --> 00:18:25,010
iterate you know you returned the

00:18:23,510 --> 00:18:27,230
eternal method on the self-taught cards

00:18:25,010 --> 00:18:29,540
that gives you a lists iterable in the

00:18:27,230 --> 00:18:33,970
third therefore I am able to eat her

00:18:29,540 --> 00:18:36,679
through all of these cards one by one so

00:18:33,970 --> 00:18:38,540
that's about it raters there is one

00:18:36,679 --> 00:18:40,250
specific form of iterators that are of

00:18:38,540 --> 00:18:43,490
particular interest which are called as

00:18:40,250 --> 00:18:46,760
generators and basically because they

00:18:43,490 --> 00:18:48,440
are lazy evaluators list one of the

00:18:46,760 --> 00:18:50,150
whole point of an iterator protocol is

00:18:48,440 --> 00:18:52,309
it you don't really need to have

00:18:50,150 --> 00:18:54,260
everything that you want to operate on

00:18:52,309 --> 00:18:55,820
at once I need to manipulate it on a

00:18:54,260 --> 00:18:58,010
hundred thousand things but I don't need

00:18:55,820 --> 00:18:59,900
to manipulate it on a hundred thousand

00:18:58,010 --> 00:19:01,190
things at once I need to manipulate on

00:18:59,900 --> 00:19:03,530
one of those things hundred different

00:19:01,190 --> 00:19:05,120
times right so if you want to do that

00:19:03,530 --> 00:19:06,860
there is no reason you want to keep all

00:19:05,120 --> 00:19:10,309
of these elements in memory at the same

00:19:06,860 --> 00:19:12,500
given time since the iterator protocol

00:19:10,309 --> 00:19:14,630
is so flexible you since you need to

00:19:12,500 --> 00:19:16,130
give only the next element you can

00:19:14,630 --> 00:19:17,840
implement something called as in a

00:19:16,130 --> 00:19:20,150
generator generator in its most

00:19:17,840 --> 00:19:22,340
essential form is something that gives

00:19:20,150 --> 00:19:24,670
you what is the value that needs to be

00:19:22,340 --> 00:19:27,080
given out during each execution

00:19:24,670 --> 00:19:28,880
generator you would write a generator

00:19:27,080 --> 00:19:31,490
like you would write a function except

00:19:28,880 --> 00:19:33,920
instead of writing a return you include

00:19:31,490 --> 00:19:35,420
a yield so what happens the simplest

00:19:33,920 --> 00:19:38,600
generator is the one that I have written

00:19:35,420 --> 00:19:41,929
there so it is a function it gives yield

00:19:38,600 --> 00:19:43,490
one when I instantiate it and then when

00:19:41,929 --> 00:19:45,350
I execute the next it gives me the first

00:19:43,490 --> 00:19:47,750
element and then when I execute the next

00:19:45,350 --> 00:19:49,490
again it gives a stop iteration so

00:19:47,750 --> 00:19:52,010
essentially it follows the Lisp order it

00:19:49,490 --> 00:19:54,230
follows the iterator protocol except it

00:19:52,010 --> 00:19:56,750
is being lazy similarly I can add it

00:19:54,230 --> 00:19:58,760
yield one L to yield three in order to

00:19:56,750 --> 00:20:03,050
give me these values incrementally one

00:19:58,760 --> 00:20:05,900
by one and stop the iteration there eat

00:20:03,050 --> 00:20:08,600
reduce has a method called as count and

00:20:05,900 --> 00:20:11,480
this when you use count he can probably

00:20:08,600 --> 00:20:14,060
provides you an infinite endless stream

00:20:11,480 --> 00:20:15,950
of numbers until the value that you have

00:20:14,060 --> 00:20:17,480
provided if you provide it was a count

00:20:15,950 --> 00:20:18,919
of 20 it gives you zero to nine

00:20:17,480 --> 00:20:20,690
clean if you probably to toast a count

00:20:18,919 --> 00:20:23,240
of zero then it provides to you and

00:20:20,690 --> 00:20:25,250
infinite stream of values which you can

00:20:23,240 --> 00:20:26,600
use if although if you're using that in

00:20:25,250 --> 00:20:27,799
a particular method you have to ensure

00:20:26,600 --> 00:20:29,660
that there is some way to break out of

00:20:27,799 --> 00:20:34,640
the loop otherwise you will run out of

00:20:29,660 --> 00:20:36,740
time so let's we created something

00:20:34,640 --> 00:20:38,330
called as Kyle we just created a card

00:20:36,740 --> 00:20:40,940
classroom at that class let's try to do

00:20:38,330 --> 00:20:42,620
something it spades so you want to do

00:20:40,940 --> 00:20:46,190
something with spades well how what is

00:20:42,620 --> 00:20:47,990
one of the ways you would do it you you

00:20:46,190 --> 00:20:50,510
have you create something called spades

00:20:47,990 --> 00:20:53,120
and you loop through each and every card

00:20:50,510 --> 00:20:54,799
in the deck and then you find if it is

00:20:53,120 --> 00:20:55,700
the Spade and if it is a spirit do

00:20:54,799 --> 00:20:58,250
something about it

00:20:55,700 --> 00:21:00,080
but this loop here is doing two

00:20:58,250 --> 00:21:02,059
different things one it is trying to get

00:21:00,080 --> 00:21:04,010
something that I need to work upon which

00:21:02,059 --> 00:21:05,480
happens to be a spade the second doing

00:21:04,010 --> 00:21:07,250
something that I want to do about it

00:21:05,480 --> 00:21:09,110
these are two different things and we

00:21:07,250 --> 00:21:10,120
can do this separation of concerns it

00:21:09,110 --> 00:21:13,490
will be better

00:21:10,120 --> 00:21:16,669
testable as well so instead of doing it

00:21:13,490 --> 00:21:20,480
the way fo we could do it like I have

00:21:16,669 --> 00:21:23,059
done it below which is the first the top

00:21:20,480 --> 00:21:25,700
which is it does only the filter of the

00:21:23,059 --> 00:21:27,830
spade cards you have created a generator

00:21:25,700 --> 00:21:29,750
which will loop through each and every

00:21:27,830 --> 00:21:32,780
card in the deck and provides it to you

00:21:29,750 --> 00:21:35,270
only if it is a spade and in the second

00:21:32,780 --> 00:21:37,100
function I don't have to bother about

00:21:35,270 --> 00:21:39,110
whether it is a spade I can assume that

00:21:37,100 --> 00:21:42,320
everything that I got is a spade and

00:21:39,110 --> 00:21:44,660
then you can do whatever you would want

00:21:42,320 --> 00:21:48,470
to do this provides separation of

00:21:44,660 --> 00:21:49,910
concerns and then this by doing this in

00:21:48,470 --> 00:21:51,260
case you have something really large you

00:21:49,910 --> 00:21:52,190
will never run out of memory because it

00:21:51,260 --> 00:21:54,650
does it one by one

00:21:52,190 --> 00:21:57,080
this is by a programming approach so

00:21:54,650 --> 00:21:59,720
generators while might seem complicated

00:21:57,080 --> 00:22:00,980
are not in fact can help you making your

00:21:59,720 --> 00:22:05,480
programs better in so many different

00:22:00,980 --> 00:22:08,000
places so generators can be implemented

00:22:05,480 --> 00:22:09,410
in multiple ways one of the simplest

00:22:08,000 --> 00:22:11,360
ways is instead of writing a list

00:22:09,410 --> 00:22:13,970
comprehension you put round brackets

00:22:11,360 --> 00:22:15,559
instead of the square ones there instead

00:22:13,970 --> 00:22:17,179
of executing all of them at once and

00:22:15,559 --> 00:22:19,190
pointing you a list it will probably

00:22:17,179 --> 00:22:20,570
with a generator object which you can

00:22:19,190 --> 00:22:23,870
call next in order to get the next value

00:22:20,570 --> 00:22:25,820
and then you can also like we went

00:22:23,870 --> 00:22:28,010
through we can also put it in a function

00:22:25,820 --> 00:22:31,190
with a yield keyword somewhere at the

00:22:28,010 --> 00:22:31,549
end or wherever you want in between so a

00:22:31,190 --> 00:22:33,919
sense

00:22:31,549 --> 00:22:35,749
what this does is for anybody that has

00:22:33,919 --> 00:22:36,799
written a tree traversing algorithm

00:22:35,749 --> 00:22:38,299
anybody that has written three

00:22:36,799 --> 00:22:40,759
traversing algorithms knows it's really

00:22:38,299 --> 00:22:42,739
complicated in order to comprehend the

00:22:40,759 --> 00:22:44,360
recursions and there's so many different

00:22:42,739 --> 00:22:45,799
levels that it has to go through but if

00:22:44,360 --> 00:22:47,509
you use a generator it is so much

00:22:45,799 --> 00:22:49,009
simpler not to understand you clear

00:22:47,509 --> 00:22:50,450
everything that is to my left you give

00:22:49,009 --> 00:22:52,159
myself and then you key everything that

00:22:50,450 --> 00:22:53,899
is too right and the way you would do it

00:22:52,159 --> 00:22:55,669
is you either that after that you yield

00:22:53,899 --> 00:22:57,710
myself and after that yield everything

00:22:55,669 --> 00:22:59,330
to my right so this is the simplest and

00:22:57,710 --> 00:23:00,980
the best possible iteration algorithm we

00:22:59,330 --> 00:23:02,749
can probably write and it's so easily

00:23:00,980 --> 00:23:05,570
comprehend this is so much better than

00:23:02,749 --> 00:23:07,100
any other form of impurity recursive

00:23:05,570 --> 00:23:12,679
algorithms that most people have in the

00:23:07,100 --> 00:23:14,149
image so if it is a three you would not

00:23:12,679 --> 00:23:16,249
have it as a method you would instead

00:23:14,149 --> 00:23:18,080
have it as a method on a particular

00:23:16,249 --> 00:23:19,999
class so that's what you have done here

00:23:18,080 --> 00:23:21,230
is instead of having as a function you

00:23:19,999 --> 00:23:23,600
have it as a method on a particular

00:23:21,230 --> 00:23:25,309
class so that's how you it are obviously

00:23:23,600 --> 00:23:26,359
there will be in the tree in the real

00:23:25,309 --> 00:23:28,399
world tree there will be an

00:23:26,359 --> 00:23:30,919
initialization function which will take

00:23:28,399 --> 00:23:33,980
the different left's rights and the

00:23:30,919 --> 00:23:35,690
positions of each and every node so

00:23:33,980 --> 00:23:38,539
similarly if you have to read a large

00:23:35,690 --> 00:23:41,929
CSV files you don't have to stop at a

00:23:38,539 --> 00:23:43,129
political you don't have to I so for

00:23:41,929 --> 00:23:44,929
example is doing we're doing it from

00:23:43,129 --> 00:23:46,850
NASA NASA wants to find all the people

00:23:44,929 --> 00:23:48,049
above six feet living in DC that half is

00:23:46,850 --> 00:23:50,629
work account for whatever the reason

00:23:48,049 --> 00:23:52,249
that they want you they don't have to if

00:23:50,629 --> 00:23:55,039
you include the logic within what you're

00:23:52,249 --> 00:23:57,109
trying to do it's not really like we saw

00:23:55,039 --> 00:23:59,450
earlier not really compelling so instead

00:23:57,109 --> 00:24:01,129
you can have filter the data that I need

00:23:59,450 --> 00:24:04,519
as one method which essentially provides

00:24:01,129 --> 00:24:05,480
a yield at the end in cases things that

00:24:04,519 --> 00:24:08,809
you don't not interested in just

00:24:05,480 --> 00:24:10,879
continue or just discard them in I am

00:24:08,809 --> 00:24:12,379
only interested in so what to do upon

00:24:10,879 --> 00:24:15,109
this you write is a different function

00:24:12,379 --> 00:24:16,820
and then this takes the input values of

00:24:15,109 --> 00:24:20,840
everything that has been filtered by my

00:24:16,820 --> 00:24:22,489
earlier decorator function so similarly

00:24:20,840 --> 00:24:25,489
with other problems you have seen many

00:24:22,489 --> 00:24:26,960
of these code Jam problems they give you

00:24:25,489 --> 00:24:28,970
a first line has a number of test cases

00:24:26,960 --> 00:24:30,889
next line has the number of people and

00:24:28,970 --> 00:24:33,320
all of that stuff using an iterator in

00:24:30,889 --> 00:24:39,109
order to get those those values how to

00:24:33,320 --> 00:24:40,399
is going to be the simplest way and it's

00:24:39,109 --> 00:24:41,629
like we have already discussed about

00:24:40,399 --> 00:24:43,519
some of the tools representing later

00:24:41,629 --> 00:24:45,320
tools every time you have an iteration

00:24:43,519 --> 00:24:47,299
problem there is a solutions in

00:24:45,320 --> 00:24:48,470
that someone else wrote out that nobody

00:24:47,299 --> 00:24:50,480
knows everything that is there and it

00:24:48,470 --> 00:24:52,759
atolls please feel free to refer to them

00:24:50,480 --> 00:24:54,950
one particular point of interest in

00:24:52,759 --> 00:24:57,110
these itself will be some of these that

00:24:54,950 --> 00:24:58,669
I consider generator tools if you have a

00:24:57,110 --> 00:25:00,259
range of two to five then you can always

00:24:58,669 --> 00:25:02,059
do a slice between two to four because

00:25:00,259 --> 00:25:04,279
all of these elements already exist in a

00:25:02,059 --> 00:25:06,200
list but if you happen to have an

00:25:04,279 --> 00:25:08,210
exchange which is a generator you cannot

00:25:06,200 --> 00:25:09,980
do that because you really don't know

00:25:08,210 --> 00:25:11,779
what is this because the second to the

00:25:09,980 --> 00:25:14,240
fifth element don't really there in the

00:25:11,779 --> 00:25:15,919
memory at this point in time but it

00:25:14,240 --> 00:25:17,389
reduced prior to your method but it's

00:25:15,919 --> 00:25:19,159
technically possible in order to get the

00:25:17,389 --> 00:25:20,509
second to the fifth element by running

00:25:19,159 --> 00:25:22,190
next two times getting the second

00:25:20,509 --> 00:25:23,210
element and then running the next three

00:25:22,190 --> 00:25:24,440
more times in or to get the fifth

00:25:23,210 --> 00:25:28,220
element and then discarding everything

00:25:24,440 --> 00:25:30,559
away right so it reduced or ice slides

00:25:28,220 --> 00:25:33,289
does exactly that it gives you it

00:25:30,559 --> 00:25:36,019
implements the slicing four iterator

00:25:33,289 --> 00:25:40,009
that is available for an iterator that

00:25:36,019 --> 00:25:42,679
is available to a generator similarly it

00:25:40,009 --> 00:25:45,559
has all forms of IMAP and I reduce etc

00:25:42,679 --> 00:25:47,029
yeah I encourage you to look it up this

00:25:45,559 --> 00:25:48,440
is a very small talk the summary of this

00:25:47,029 --> 00:25:51,080
has iterators are very powerful

00:25:48,440 --> 00:25:52,580
abstractions you always do iterations

00:25:51,080 --> 00:25:53,659
always do iteration that's another

00:25:52,580 --> 00:25:55,970
fundamental thing that you do in a

00:25:53,659 --> 00:25:58,850
programming you set all day and then you

00:25:55,970 --> 00:26:02,120
look things over and over again you so

00:25:58,850 --> 00:26:05,269
why not do it better because if you this

00:26:02,120 --> 00:26:06,919
one thing by writing iterators better

00:26:05,269 --> 00:26:07,669
all the time of programs can become so

00:26:06,919 --> 00:26:10,039
much better

00:26:07,669 --> 00:26:12,049
iterator module has powerful functions

00:26:10,039 --> 00:26:14,419
to deal with iterators and in particular

00:26:12,049 --> 00:26:17,240
generators iterators like all good

00:26:14,419 --> 00:26:20,409
programs make programs better and most

00:26:17,240 --> 00:26:20,409
of all program was happy

00:26:28,040 --> 00:26:35,190
Thank You Laxman I'd like to present you

00:26:32,010 --> 00:26:38,700
with our PyCon coffee or virtual coffee

00:26:35,190 --> 00:26:40,800
in Launceston and also a PyCon mark okay

00:26:38,700 --> 00:26:44,240
as we're running a little short on time

00:26:40,800 --> 00:26:44,240
do we have one or two quick questions

00:26:48,650 --> 00:26:53,070
sorry just being new to Python I wasn't

00:26:51,300 --> 00:26:54,540
quite sure I think with slide three

00:26:53,070 --> 00:26:57,300
where you had differences between

00:26:54,540 --> 00:27:00,090
heights of values and values as methods

00:26:57,300 --> 00:27:02,520
to your object sorry you had either

00:27:00,090 --> 00:27:05,370
values and values as two different

00:27:02,520 --> 00:27:07,350
method calls on a list what's the

00:27:05,370 --> 00:27:11,280
difference so there's not unless those

00:27:07,350 --> 00:27:12,870
are on a dictionary okay the inter

00:27:11,280 --> 00:27:14,970
values is a generator thing which does

00:27:12,870 --> 00:27:18,180
not necessarily call all of these and

00:27:14,970 --> 00:27:19,710
then provide you at once on values is

00:27:18,180 --> 00:27:21,150
something that protects all of these

00:27:19,710 --> 00:27:23,600
values put certain a list and gives it

00:27:21,150 --> 00:27:23,600
you in a list

00:27:31,910 --> 00:27:36,980
I was wondering if it could comment a

00:27:34,430 --> 00:27:42,440
bit more on whether you think it's

00:27:36,980 --> 00:27:45,140
pythonic to use more functional methods

00:27:42,440 --> 00:27:48,320
like the map and reduce functions and if

00:27:45,140 --> 00:27:49,940
not why you think say using more

00:27:48,320 --> 00:27:55,130
generators and list comprehensions is

00:27:49,940 --> 00:27:57,130
more pythonic so it's funny so if you

00:27:55,130 --> 00:28:00,920
see how it is going most of the time

00:27:57,130 --> 00:28:02,330
python pythonic people don't aren't

00:28:00,920 --> 00:28:04,790
really interested to use something like

00:28:02,330 --> 00:28:06,710
my opera tears but they have built a

00:28:04,790 --> 00:28:09,020
module ecology turtles which essentially

00:28:06,710 --> 00:28:10,360
all of the functional aspects within the

00:28:09,020 --> 00:28:16,370
same thing and they happen to allow that

00:28:10,360 --> 00:28:17,720
so it's just a matter of whether it is

00:28:16,370 --> 00:28:20,300
appropriate at that particular location

00:28:17,720 --> 00:28:21,980
if you find it easier using MapReduce

00:28:20,300 --> 00:28:23,870
just go ahead and use it but most of the

00:28:21,980 --> 00:28:25,160
time list compliance and seems natural

00:28:23,870 --> 00:28:27,020
because that's what we have been used to

00:28:25,160 --> 00:28:28,520
I mean you read a lot of Python code you

00:28:27,020 --> 00:28:30,530
get used to doing everything in little

00:28:28,520 --> 00:28:32,330
eat less comprehension that's also

00:28:30,530 --> 00:28:34,250
better because it's faster pythonic

00:28:32,330 --> 00:28:36,140
interpret the implementation of list

00:28:34,250 --> 00:28:37,730
comprehension is often much faster than

00:28:36,140 --> 00:28:41,570
their corresponding MapReduce

00:28:37,730 --> 00:28:42,980
counterparts so it's a balance you just

00:28:41,570 --> 00:28:44,720
use it to doing it and if you just use

00:28:42,980 --> 00:28:46,670
it to doing something the pythonic way

00:28:44,720 --> 00:28:48,500
with list comprehensions go ahead and do

00:28:46,670 --> 00:28:50,870
it but if you see a natural alternative

00:28:48,500 --> 00:28:52,190
if it comes to you to do MapReduce

00:28:50,870 --> 00:28:55,970
there's nothing stopping you from doing

00:28:52,190 --> 00:28:58,400
it but you will get to gradually more

00:28:55,970 --> 00:29:04,030
towards doing much more pythonic way the

00:28:58,400 --> 00:29:04,030
more Python you do so we have one more

00:29:04,630 --> 00:29:13,150
on behalf of the team I'd like to think

00:29:08,360 --> 00:29:13,150

YouTube URL: https://www.youtube.com/watch?v=ODkRRup0a8w


