Title: Using Python to design, configure, and measure large-scale networks
Publication date: 2013-07-11
Playlist: Pycon Australia 2013
Description: 
	Simon Knight
http://2013.pycon-au.org/schedule/30057/view_talk
AutoNetkit is an open-source project to automatically build network configuration files for routers including Quagga, Cisco and Juniper, with complicated protocol configurations, all from a simple input graph --- which could even be drawn in a program such as yEd. 

AutoNetkit was started at the University of Adelaide, and developed further at Cisco, with collaborators from both research and industry.
It is being used at major rou
Captions: 
	00:00:00,380 --> 00:00:05,609
our next presenter is a software

00:00:03,210 --> 00:00:08,160
engineer in the chief architects office

00:00:05,609 --> 00:00:10,469
at Cisco Systems where he is working on

00:00:08,160 --> 00:00:12,780
network virtualization and orchestration

00:00:10,469 --> 00:00:14,150
technologies his technical interests

00:00:12,780 --> 00:00:16,619
include network engineering

00:00:14,150 --> 00:00:20,490
configuration automation system

00:00:16,619 --> 00:00:21,900
architecture and data visualization -

00:00:20,490 --> 00:00:23,850
tell us about working with large scale

00:00:21,900 --> 00:00:29,310
networks in Python please welcome Simon

00:00:23,850 --> 00:00:31,349
Knight thank you um so this is

00:00:29,310 --> 00:00:33,149
continuing some work that I started as a

00:00:31,349 --> 00:00:35,489
PhD student at the University of

00:00:33,149 --> 00:00:37,829
Adelaide and yetzer Python open source

00:00:35,489 --> 00:00:40,140
project and continuing on at Cisco

00:00:37,829 --> 00:00:41,640
continuing the open source side of it so

00:00:40,140 --> 00:00:45,780
what we've been looking at is basically

00:00:41,640 --> 00:00:46,969
router configuration so routers are most

00:00:45,780 --> 00:00:49,020
people probably seen them before

00:00:46,969 --> 00:00:51,390
essentially just a computer with lots of

00:00:49,020 --> 00:00:54,539
network cards in and we can be

00:00:51,390 --> 00:00:55,890
represented by this symbol plug them

00:00:54,539 --> 00:00:58,199
into each other and then they run

00:00:55,890 --> 00:01:00,270
routing protocols that then talk to each

00:00:58,199 --> 00:01:02,100
other and find the path and then you

00:01:00,270 --> 00:01:05,580
build them into a big network and you

00:01:02,100 --> 00:01:06,869
essentially have the internet and by

00:01:05,580 --> 00:01:08,400
grouping these routers with different

00:01:06,869 --> 00:01:11,490
properties such as an autonomous system

00:01:08,400 --> 00:01:13,350
we can form yet different configurations

00:01:11,490 --> 00:01:15,900
so here we could have three networks

00:01:13,350 --> 00:01:17,729
talking to each other the essential

00:01:15,900 --> 00:01:19,560
thing is that the protocols in

00:01:17,729 --> 00:01:21,180
configuration running inside one network

00:01:19,560 --> 00:01:24,060
is slightly different to inside a

00:01:21,180 --> 00:01:25,350
different companies network and then the

00:01:24,060 --> 00:01:27,030
protocols between them need to

00:01:25,350 --> 00:01:28,860
incorporate all the configuration the

00:01:27,030 --> 00:01:30,180
protocols between them needs to include

00:01:28,860 --> 00:01:32,100
information such as business

00:01:30,180 --> 00:01:33,840
relationships so it's just a lot of

00:01:32,100 --> 00:01:37,259
complexity once we start building them

00:01:33,840 --> 00:01:40,140
into bigger networks so this is slightly

00:01:37,259 --> 00:01:41,939
bigger network but still extremely small

00:01:40,140 --> 00:01:44,579
in terms of the scale of the incident

00:01:41,939 --> 00:01:47,759
which is like 40 50 thousand router kind

00:01:44,579 --> 00:01:50,159
of deal with plenty of networks so what

00:01:47,759 --> 00:01:54,390
we're looking at is the configuration of

00:01:50,159 --> 00:01:56,579
these devices and basically each of

00:01:54,390 --> 00:01:59,040
these is configured if they configure

00:01:56,579 --> 00:02:02,060
directly is in a low-level vendor

00:01:59,040 --> 00:02:04,920
specific syntax which is essentially

00:02:02,060 --> 00:02:08,129
fairly similar between each device but

00:02:04,920 --> 00:02:10,270
slightly different and that gets really

00:02:08,129 --> 00:02:13,310
tedious and error-prone and

00:02:10,270 --> 00:02:15,050
yeah and just takes time consuming to do

00:02:13,310 --> 00:02:15,950
and to repeat that across lots of

00:02:15,050 --> 00:02:17,840
networks with slightly different

00:02:15,950 --> 00:02:19,700
properties so if a router is only

00:02:17,840 --> 00:02:21,260
talking to other routers inside the same

00:02:19,700 --> 00:02:23,330
network that's slightly different to if

00:02:21,260 --> 00:02:24,769
it's talking to routers in a different

00:02:23,330 --> 00:02:26,630
network and getting all those properties

00:02:24,769 --> 00:02:29,349
right is important for the performance

00:02:26,630 --> 00:02:31,790
or for the network to actually work so

00:02:29,349 --> 00:02:34,030
each of these yet is very similar but

00:02:31,790 --> 00:02:36,560
just slightly different which is

00:02:34,030 --> 00:02:39,290
essentially really time-consuming and

00:02:36,560 --> 00:02:42,860
tedious and boring and really doesn't

00:02:39,290 --> 00:02:44,360
scale when we get to big networks so in

00:02:42,860 --> 00:02:46,190
terms of trying to do the configuration

00:02:44,360 --> 00:02:48,829
one approach is to have like a data base

00:02:46,190 --> 00:02:50,390
and push that into templates and the

00:02:48,829 --> 00:02:51,799
problem then becomes how do we specify

00:02:50,390 --> 00:02:53,870
these properties in the data base

00:02:51,799 --> 00:02:56,120
because we've raised the abstraction

00:02:53,870 --> 00:02:57,920
then from typing it into each device

00:02:56,120 --> 00:02:59,360
individually we can put the properties

00:02:57,920 --> 00:03:01,670
and data base push them into templates

00:02:59,360 --> 00:03:03,500
push them out to the network but we

00:03:01,670 --> 00:03:04,790
still have that the problem of making

00:03:03,500 --> 00:03:06,440
sure the properties talking about this

00:03:04,790 --> 00:03:09,290
router is the correct ones and this one

00:03:06,440 --> 00:03:11,090
here and getting them the device level

00:03:09,290 --> 00:03:13,579
properties correct across the network

00:03:11,090 --> 00:03:16,100
wide context is the challenging bit and

00:03:13,579 --> 00:03:17,690
that's what we've been looking at so we

00:03:16,100 --> 00:03:19,910
took a step back and trying to look at

00:03:17,690 --> 00:03:22,910
how someone would ideally design a

00:03:19,910 --> 00:03:24,560
network so in extremely simple Network

00:03:22,910 --> 00:03:26,959
here for instance you'd start on a

00:03:24,560 --> 00:03:29,569
whiteboard and draw up your routers

00:03:26,959 --> 00:03:31,579
which are the circles here and then draw

00:03:29,569 --> 00:03:33,410
something like the the circles around

00:03:31,579 --> 00:03:34,910
them to have some sort of attribute like

00:03:33,410 --> 00:03:36,290
the a s and then you might use different

00:03:34,910 --> 00:03:39,950
colors of different tags to start

00:03:36,290 --> 00:03:41,900
describing how it goes from there it's

00:03:39,950 --> 00:03:42,829
pretty hard to capture from a whiteboard

00:03:41,900 --> 00:03:45,200
I guess you could do some image

00:03:42,829 --> 00:03:47,170
processing but we didn't so the next

00:03:45,200 --> 00:03:50,480
thing that's slightly more computable is

00:03:47,170 --> 00:03:53,120
drawing something like Visio so we use

00:03:50,480 --> 00:03:54,859
yet which is a freeware such a Java

00:03:53,120 --> 00:03:57,230
program but I'm free we're a

00:03:54,859 --> 00:03:59,239
multi-platform program that you can draw

00:03:57,230 --> 00:04:01,239
diagrams in we've sort of used it to

00:03:59,239 --> 00:04:05,000
draw networks which were essentially a

00:04:01,239 --> 00:04:11,060
graph and one of the key things here is

00:04:05,000 --> 00:04:12,560
that we have the attributes up here so

00:04:11,060 --> 00:04:13,639
what we can do is instead of drawing

00:04:12,560 --> 00:04:15,620
with a different color or different

00:04:13,639 --> 00:04:18,019
label on the whiteboard drawing the

00:04:15,620 --> 00:04:19,849
attributes so where I had the squiggle

00:04:18,019 --> 00:04:22,340
cloud around a group of routers to

00:04:19,849 --> 00:04:23,419
represent autonomous system such as

00:04:22,340 --> 00:04:26,270
belonging to Telstra

00:04:23,419 --> 00:04:28,610
Net Orion - no - a different company we

00:04:26,270 --> 00:04:31,099
can actually put these attributes on the

00:04:28,610 --> 00:04:33,439
nodes here so for instance we have this

00:04:31,099 --> 00:04:35,389
route this one set as a router and the

00:04:33,439 --> 00:04:37,069
ASN is - so for a different group it

00:04:35,389 --> 00:04:39,169
might be a nascent of one and I'll show

00:04:37,069 --> 00:04:40,460
you those in a few slides and then we

00:04:39,169 --> 00:04:42,680
can add some other properties like a

00:04:40,460 --> 00:04:43,999
route reflected to designate its role in

00:04:42,680 --> 00:04:46,400
a network and some other things which

00:04:43,999 --> 00:04:48,529
I'll get to the problem is though that

00:04:46,400 --> 00:04:51,110
we could capture and draw it at a higher

00:04:48,529 --> 00:04:53,689
level but if that's just a GUI that we

00:04:51,110 --> 00:04:55,550
present to the end-user every network is

00:04:53,689 --> 00:04:57,560
slightly different in terms of how they

00:04:55,550 --> 00:04:59,060
want to configure their protocols or the

00:04:57,560 --> 00:05:02,000
links are using where they're optimizing

00:04:59,060 --> 00:05:03,650
to be low latency or low cost so try to

00:05:02,000 --> 00:05:06,379
capture all these different requirements

00:05:03,650 --> 00:05:08,330
we can't just do draw your network add

00:05:06,379 --> 00:05:10,580
some attributes and then we'll build it

00:05:08,330 --> 00:05:14,689
for you because it's not really going to

00:05:10,580 --> 00:05:17,120
work so this is where the Python comes

00:05:14,689 --> 00:05:19,759
in so one of the nice things that we've

00:05:17,120 --> 00:05:21,499
yet is that Visio and OmniGraffle don't

00:05:19,759 --> 00:05:23,689
do is that it connects port natively to

00:05:21,499 --> 00:05:25,789
a graph interchange format so it

00:05:23,689 --> 00:05:27,919
describes this network here that we draw

00:05:25,789 --> 00:05:29,659
up as a list of nodes and edges in the

00:05:27,919 --> 00:05:31,909
classic computer science graph sense and

00:05:29,659 --> 00:05:34,879
the attributes on them which means that

00:05:31,909 --> 00:05:37,719
we can use something and network X is

00:05:34,879 --> 00:05:40,580
really nice a Python package for graph

00:05:37,719 --> 00:05:43,310
manipulation and analysis which can read

00:05:40,580 --> 00:05:48,589
natively graph ml so we can draw up our

00:05:43,310 --> 00:05:51,589
network in yet and that wasn't meant to

00:05:48,589 --> 00:05:54,500
use it again and import it directly into

00:05:51,589 --> 00:05:58,430
Network X and start to do some things so

00:05:54,500 --> 00:06:01,759
we can then iterate over the nodes just

00:05:58,430 --> 00:06:03,229
native standard Python iteration and get

00:06:01,759 --> 00:06:05,000
the attributes there so we can see the

00:06:03,229 --> 00:06:07,729
nodes and then these attributes that

00:06:05,000 --> 00:06:10,009
were set so the x and y the ASN value

00:06:07,729 --> 00:06:11,180
which are set before and then the upload

00:06:10,009 --> 00:06:12,589
things like the route reflected which

00:06:11,180 --> 00:06:16,099
might be a boolean that we can do some

00:06:12,589 --> 00:06:17,870
stuff with and yeah so that's the the

00:06:16,099 --> 00:06:20,120
attributes which suggests it we could

00:06:17,870 --> 00:06:22,129
draw it up and then do some Python type

00:06:20,120 --> 00:06:24,169
operations to start building up these

00:06:22,129 --> 00:06:26,629
configs we also can do similar things

00:06:24,169 --> 00:06:29,330
for the edges so for instance the edge

00:06:26,629 --> 00:06:30,770
between n 12 and then 11 could have

00:06:29,330 --> 00:06:32,360
something like a speed property that we

00:06:30,770 --> 00:06:35,029
could then use to do some analysis or

00:06:32,360 --> 00:06:36,860
run shortest paths and do some standard

00:06:35,029 --> 00:06:38,960
graph operations so the gray

00:06:36,860 --> 00:06:40,370
operations themself are particularly

00:06:38,960 --> 00:06:41,780
groundbreaking but being able to draw

00:06:40,370 --> 00:06:44,270
the network and then do these operations

00:06:41,780 --> 00:06:47,419
in a network context becomes quite

00:06:44,270 --> 00:06:49,009
powerful and and then we can start using

00:06:47,419 --> 00:06:50,810
other Python things like the list

00:06:49,009 --> 00:06:52,460
comprehensions really work quite well

00:06:50,810 --> 00:06:55,129
when we're talking about lists of nodes

00:06:52,460 --> 00:06:56,960
and edges so here we could just grab the

00:06:55,129 --> 00:07:02,270
nodes that we've tagged in in the graph

00:06:56,960 --> 00:07:04,250
with a SN attribute set to one or doing

00:07:02,270 --> 00:07:05,689
things like the edges between two AAS

00:07:04,250 --> 00:07:07,340
ends so that might be the link between

00:07:05,689 --> 00:07:09,469
Telstra and our net that we want to

00:07:07,340 --> 00:07:11,599
treat differently we can easily get them

00:07:09,469 --> 00:07:14,870
in the list comprehension just looking

00:07:11,599 --> 00:07:17,029
where the all the edges where the source

00:07:14,870 --> 00:07:18,650
the ASN of the source node is not the

00:07:17,029 --> 00:07:20,180
same as the end of the destination node

00:07:18,650 --> 00:07:22,090
and we could of course with list

00:07:20,180 --> 00:07:25,039
comprehensions build these up to quite

00:07:22,090 --> 00:07:29,020
powerful and quite complicated queries

00:07:25,039 --> 00:07:31,580
in a way or apply like a function to the

00:07:29,020 --> 00:07:35,509
edges to filtering that becomes really

00:07:31,580 --> 00:07:37,099
quite powerful so the extensions and

00:07:35,509 --> 00:07:39,409
this is really where our project comes

00:07:37,099 --> 00:07:43,310
in is auto net kit which has been

00:07:39,409 --> 00:07:45,199
building on top of the network x graphs

00:07:43,310 --> 00:07:47,089
that I just showed but the thing with

00:07:45,199 --> 00:07:49,310
networks is that we don't just have one

00:07:47,089 --> 00:07:51,139
protocol there might be one that we run

00:07:49,310 --> 00:07:52,610
with inside the network and then there

00:07:51,139 --> 00:07:55,580
might be different ones between the

00:07:52,610 --> 00:07:58,909
network different networks and then a

00:07:55,580 --> 00:08:00,500
whole heap of network engineering terms

00:07:58,909 --> 00:08:04,639
here but whether we want to run you

00:08:00,500 --> 00:08:05,960
within or with or between ipv4 ipv6 and

00:08:04,639 --> 00:08:06,560
different variants of all the different

00:08:05,960 --> 00:08:10,520
protocols

00:08:06,560 --> 00:08:13,460
so essentially networks are the way that

00:08:10,520 --> 00:08:15,379
we've been representing them here is as

00:08:13,460 --> 00:08:17,240
multi-layer graph so Network X is really

00:08:15,379 --> 00:08:18,949
nice to be able to represent a network

00:08:17,240 --> 00:08:20,750
as a graph but we want to be

00:08:18,949 --> 00:08:23,330
representing each of the protocol

00:08:20,750 --> 00:08:25,939
configurations so what we've essentially

00:08:23,330 --> 00:08:28,490
done is built basically dictionary and

00:08:25,939 --> 00:08:30,740
wrapped it around in a our abstract

00:08:28,490 --> 00:08:32,060
network model class which has a series

00:08:30,740 --> 00:08:35,419
of dictionaries that the user can define

00:08:32,060 --> 00:08:39,709
and then a heap of operations to make it

00:08:35,419 --> 00:08:42,019
fairly easy to work with so we've done a

00:08:39,709 --> 00:08:45,440
bit of stuff with the magic methods to

00:08:42,019 --> 00:08:50,240
make this easy to use externally so we

00:08:45,440 --> 00:08:52,339
can get things like the ANM we can then

00:08:50,240 --> 00:08:53,720
access the different graphs in there so

00:08:52,339 --> 00:08:55,579
for instance the physical graph which

00:08:53,720 --> 00:08:58,070
were just referring to as a fire here we

00:08:55,579 --> 00:09:00,019
can then access node one I was going to

00:08:58,070 --> 00:09:03,740
quickly skip through all the details of

00:09:00,019 --> 00:09:05,959
this but what we've done is by using the

00:09:03,740 --> 00:09:07,579
set attribute and get attribute magic

00:09:05,959 --> 00:09:09,470
methods you can then instead of having

00:09:07,579 --> 00:09:11,060
to access the node back through the

00:09:09,470 --> 00:09:12,920
graph like in the previous syntax we

00:09:11,060 --> 00:09:14,779
just wrap around it and you can then

00:09:12,920 --> 00:09:17,089
just set an attribute directly like the

00:09:14,779 --> 00:09:19,759
test attribute and then print it out and

00:09:17,089 --> 00:09:21,560
then that's all set on the underlying

00:09:19,759 --> 00:09:23,509
network X graph so if I look back at the

00:09:21,560 --> 00:09:25,550
graph like before on the bottom line

00:09:23,509 --> 00:09:28,100
here that's showing that the dictionary

00:09:25,550 --> 00:09:31,040
and we can see that attributes been set

00:09:28,100 --> 00:09:34,100
and then using gate items so what we can

00:09:31,040 --> 00:09:35,329
do is by looking up that node in a

00:09:34,100 --> 00:09:38,839
different graph because they're all

00:09:35,329 --> 00:09:41,449
referenced by ID we can use get item to

00:09:38,839 --> 00:09:43,100
then go for this node in in the input

00:09:41,449 --> 00:09:44,959
graph and then get that corresponding

00:09:43,100 --> 00:09:46,459
property so this makes it quite powerful

00:09:44,959 --> 00:09:48,199
when we're trying to configure lots of

00:09:46,459 --> 00:09:51,709
protocols and lots of different graphs

00:09:48,199 --> 00:09:53,449
and then iteration of course is really

00:09:51,709 --> 00:09:55,010
quite handy to have with this

00:09:53,449 --> 00:09:56,389
comprehension so we can then iterate

00:09:55,010 --> 00:10:00,290
over the graphs and print out their

00:09:56,389 --> 00:10:03,740
labels so in terms of using Auto Net kit

00:10:00,290 --> 00:10:05,839
very briefly importing it is fairly

00:10:03,740 --> 00:10:07,940
similar to with Network X you load up

00:10:05,839 --> 00:10:09,769
the graph as graph from our we do a bit

00:10:07,940 --> 00:10:12,709
of initialization to set some default

00:10:09,769 --> 00:10:14,449
values and then the basic API usage is

00:10:12,709 --> 00:10:16,220
essentially list comprehensions with

00:10:14,449 --> 00:10:18,199
just the set attribute get attribute

00:10:16,220 --> 00:10:19,699
wrappers around them so we can do things

00:10:18,199 --> 00:10:20,389
like printing the nodes again like we

00:10:19,699 --> 00:10:23,000
had before

00:10:20,389 --> 00:10:24,709
if the ASN is one and printing the edges

00:10:23,000 --> 00:10:27,050
if the sources did not the same as the

00:10:24,709 --> 00:10:28,699
destination ASN so fairly similar to

00:10:27,050 --> 00:10:30,920
before but a little bit more succinct

00:10:28,699 --> 00:10:32,120
and a little bit more readable perhaps

00:10:30,920 --> 00:10:34,730
at a loss of a little bit of performance

00:10:32,120 --> 00:10:38,329
but when we're building large network

00:10:34,730 --> 00:10:40,819
design descriptions the the clarity

00:10:38,329 --> 00:10:42,500
becomes quite nice the thing though is

00:10:40,819 --> 00:10:45,259
that once we start dealing with lots of

00:10:42,500 --> 00:10:49,220
sequences of nodes and edges it becomes

00:10:45,259 --> 00:10:50,930
quite difficult to see the context so

00:10:49,220 --> 00:10:53,269
for instance with the physical graph

00:10:50,930 --> 00:10:56,060
here if we're taking that topology I

00:10:53,269 --> 00:10:57,529
drew before and we're creating a new

00:10:56,060 --> 00:10:59,810
graph

00:10:57,529 --> 00:11:01,430
the physical graph and we're adding the

00:10:59,810 --> 00:11:03,920
nodes and edges from before if we then

00:11:01,430 --> 00:11:05,709
print out a list we can do the Python

00:11:03,920 --> 00:11:08,269
list comprehensions is quite nice but

00:11:05,709 --> 00:11:10,939
even for a fairly small graph like I

00:11:08,269 --> 00:11:12,620
drew before these starts to get really

00:11:10,939 --> 00:11:14,360
hard to see is this actually what I

00:11:12,620 --> 00:11:16,129
intended so we can get the node list

00:11:14,360 --> 00:11:17,569
which is a whole heap of nodes we get

00:11:16,129 --> 00:11:19,370
the edge list which is even bigger list

00:11:17,569 --> 00:11:21,589
of edges and trying to see is that

00:11:19,370 --> 00:11:23,269
actually what I wanted to look like it's

00:11:21,589 --> 00:11:25,069
quite hard to get the context here it's

00:11:23,269 --> 00:11:27,860
quite easy to miss one and when you're

00:11:25,069 --> 00:11:30,050
building up multi queries with different

00:11:27,860 --> 00:11:32,689
attributes it becomes quite difficult so

00:11:30,050 --> 00:11:34,579
what we did is built a visualization

00:11:32,689 --> 00:11:36,800
system which actually is an empath in

00:11:34,579 --> 00:11:40,279
here we built that on top of d3 which

00:11:36,800 --> 00:11:43,309
makes it quite easy to Palm off the GUI

00:11:40,279 --> 00:11:46,819
work to a web browser and d3 works

00:11:43,309 --> 00:11:49,850
really nicely in tandem with Python so

00:11:46,819 --> 00:11:51,949
for the visualization we have the auto

00:11:49,850 --> 00:11:55,999
net kit main script and that just posts

00:11:51,949 --> 00:11:58,399
as a JSON to a tornado web server so we

00:11:55,999 --> 00:12:00,980
just use 2080 that works quite cleanly

00:11:58,399 --> 00:12:04,699
with our WebSockets for dynamic updating

00:12:00,980 --> 00:12:05,990
so we get the script and just like

00:12:04,699 --> 00:12:07,490
before if we created it with the

00:12:05,990 --> 00:12:09,110
important physical graphs added some

00:12:07,490 --> 00:12:11,660
nodes change the attribute like tests

00:12:09,110 --> 00:12:13,189
and things like that we can just call

00:12:11,660 --> 00:12:14,569
Auto net get update and that will just

00:12:13,189 --> 00:12:17,959
look for tornado running on the

00:12:14,569 --> 00:12:19,639
localhost and send it the ANM so just

00:12:17,959 --> 00:12:23,870
that network model wrapping the network

00:12:19,639 --> 00:12:26,209
x graphs as a just JSON format which is

00:12:23,870 --> 00:12:28,519
again quite nice and readable sends it

00:12:26,209 --> 00:12:30,589
across to the web server that will then

00:12:28,519 --> 00:12:33,319
receive it and then send that across to

00:12:30,589 --> 00:12:34,639
the listening web browsers and that's in

00:12:33,319 --> 00:12:36,709
multi-platform and works quite nicely

00:12:34,639 --> 00:12:39,019
and there's a lot of really nice things

00:12:36,709 --> 00:12:41,179
you can do with d3 that I'm not going to

00:12:39,019 --> 00:12:43,250
get into here where it's awesome

00:12:41,179 --> 00:12:45,069
so in terms of doing some basic network

00:12:43,250 --> 00:12:48,019
graph creation using the API

00:12:45,069 --> 00:12:50,480
I was PS one protocol that runs within

00:12:48,019 --> 00:12:54,339
an autonomous system so basically what

00:12:50,480 --> 00:12:56,779
we've done here is just taken then the

00:12:54,339 --> 00:12:58,670
nodes from the input graph so just all

00:12:56,779 --> 00:13:00,769
the routers in the network and then

00:12:58,670 --> 00:13:03,050
adding the edges from the input graph if

00:13:00,769 --> 00:13:05,209
the sources but the same as the HC just

00:13:03,050 --> 00:13:06,470
like the examples I had before so we've

00:13:05,209 --> 00:13:09,649
really done is just drop the links

00:13:06,470 --> 00:13:11,570
between the network's ebgp is a protocol

00:13:09,649 --> 00:13:13,460
that runs between autonomous

00:13:11,570 --> 00:13:15,410
so it's pretty much the inverse of what

00:13:13,460 --> 00:13:16,640
I just showed we're just adding edges if

00:13:15,410 --> 00:13:20,900
the source is not the same as the

00:13:16,640 --> 00:13:23,180
destination and ibgp is what's use

00:13:20,900 --> 00:13:24,800
within a network to talk about the

00:13:23,180 --> 00:13:26,600
external networks that you can see so

00:13:24,800 --> 00:13:28,880
the very simple example is just creating

00:13:26,600 --> 00:13:31,250
a full mesh which becomes quite nice as

00:13:28,880 --> 00:13:33,860
a rest comprehension or generator

00:13:31,250 --> 00:13:36,290
expression here and just iterating over

00:13:33,860 --> 00:13:37,760
all the nodes and edges in the network

00:13:36,290 --> 00:13:39,230
if the source is the same as a

00:13:37,760 --> 00:13:40,880
destination pulley right that more

00:13:39,230 --> 00:13:43,130
efficiently but it shows that you can

00:13:40,880 --> 00:13:45,350
quite quickly create graphs based on

00:13:43,130 --> 00:13:48,200
these attributes the thing

00:13:45,350 --> 00:13:51,020
these are ibgp running as a full mesh is

00:13:48,200 --> 00:13:52,250
going to be order N squared so it

00:13:51,020 --> 00:13:53,900
doesn't work so nicely if you have

00:13:52,250 --> 00:13:56,030
really big networks so what's common is

00:13:53,900 --> 00:13:57,830
people might specify something like a

00:13:56,030 --> 00:13:59,570
route reflector which basically says

00:13:57,830 --> 00:14:01,130
rather than everyone connecting to

00:13:59,570 --> 00:14:03,530
everyone connect to one central router

00:14:01,130 --> 00:14:03,800
or two central routers and build from

00:14:03,530 --> 00:14:06,080
there

00:14:03,800 --> 00:14:08,300
and so in terms of expressing that with

00:14:06,080 --> 00:14:11,150
the syntax here becomes quite simple and

00:14:08,300 --> 00:14:12,530
graph operations so to remember why

00:14:11,150 --> 00:14:14,210
right back when I was showing yet we

00:14:12,530 --> 00:14:16,700
could set that boolean attribute to say

00:14:14,210 --> 00:14:20,270
is this a route reflector or not if we

00:14:16,700 --> 00:14:23,570
go back to wrapping around Network X we

00:14:20,270 --> 00:14:26,720
can just look at the nodes in the graph

00:14:23,570 --> 00:14:28,850
that we added before group them by ASN

00:14:26,720 --> 00:14:32,780
so that will just give us a list of all

00:14:28,850 --> 00:14:34,940
the dictionary keyed by the ASN property

00:14:32,780 --> 00:14:36,860
and then the nodes that have that asns

00:14:34,940 --> 00:14:38,690
that will get one and get a few routers

00:14:36,860 --> 00:14:40,430
to get another set of routers in a sense

00:14:38,690 --> 00:14:43,310
three get the other set of routers and

00:14:40,430 --> 00:14:45,980
then we can do some looking at that so

00:14:43,310 --> 00:14:49,010
if I just grab the routers with a this

00:14:45,980 --> 00:14:52,670
comprehension looking if that just the

00:14:49,010 --> 00:14:55,640
list of all the nodes in that ASN

00:14:52,670 --> 00:14:56,840
dictionary if they have route reflector

00:14:55,640 --> 00:14:59,120
set and then we can just do a basic

00:14:56,840 --> 00:15:01,400
check if there's a length so if there's

00:14:59,120 --> 00:15:03,890
anything in there and then we can do set

00:15:01,400 --> 00:15:05,420
operations on the sequences to see which

00:15:03,890 --> 00:15:08,600
ones have actually got it set which ones

00:15:05,420 --> 00:15:11,180
don't and then just basically create

00:15:08,600 --> 00:15:12,650
needs between those that other out

00:15:11,180 --> 00:15:14,120
reflectors and those that aren't and add

00:15:12,650 --> 00:15:17,960
those edges so we've just gone from

00:15:14,120 --> 00:15:19,550
having the full mesh there to doing this

00:15:17,960 --> 00:15:21,110
here so the technical details aren't as

00:15:19,550 --> 00:15:22,610
important by trying to show you that we

00:15:21,110 --> 00:15:24,889
can quite quickly create these

00:15:22,610 --> 00:15:27,980
high-level design rules by

00:15:24,889 --> 00:15:29,540
just a few lines of Python code and then

00:15:27,980 --> 00:15:31,339
we can just do the other case so if they

00:15:29,540 --> 00:15:34,220
don't have that attribute set just

00:15:31,339 --> 00:15:37,249
create the full meshes before and that's

00:15:34,220 --> 00:15:38,989
that so in terms of how that works we

00:15:37,249 --> 00:15:41,209
just take yet that was the input from

00:15:38,989 --> 00:15:43,549
yet as graph ml the loader which sets

00:15:41,209 --> 00:15:45,079
the defaults into an input graph and

00:15:43,549 --> 00:15:46,970
then building up these overlay graphs

00:15:45,079 --> 00:15:48,679
and they're the whole purpose of this

00:15:46,970 --> 00:15:50,779
isn't just to create the overlays is to

00:15:48,679 --> 00:15:52,220
create the device configurations so

00:15:50,779 --> 00:15:54,619
we've got another module of the compiler

00:15:52,220 --> 00:15:56,480
which is looks at each of those overlay

00:15:54,619 --> 00:15:59,089
graphs and then concatenates them down

00:15:56,480 --> 00:16:02,239
or condenses them down to a device level

00:15:59,089 --> 00:16:05,230
model because the network is configured

00:16:02,239 --> 00:16:07,879
device by device but working at the

00:16:05,230 --> 00:16:10,100
abstract network model level lets you

00:16:07,879 --> 00:16:11,600
design it as a network but of course we

00:16:10,100 --> 00:16:13,779
still need to push these things out to

00:16:11,600 --> 00:16:16,689
devices so that's what the compiler does

00:16:13,779 --> 00:16:19,879
which is really just iterating over with

00:16:16,689 --> 00:16:21,919
just objects iterating inheriting from

00:16:19,879 --> 00:16:24,919
like a device or router and and using

00:16:21,919 --> 00:16:26,959
functions based on their and building up

00:16:24,919 --> 00:16:30,110
basically this is what it looks like the

00:16:26,959 --> 00:16:32,149
end product so this is just rendered as

00:16:30,110 --> 00:16:34,910
JSON was dictionaries and we can see

00:16:32,149 --> 00:16:37,519
that we've got things here that might be

00:16:34,910 --> 00:16:40,759
coming from ibgp graphs or the ebgp

00:16:37,519 --> 00:16:45,049
graphs and OSPF down the bottom so we've

00:16:40,759 --> 00:16:47,869
we've got a vendor specific format here

00:16:45,049 --> 00:16:49,850
it's not obviously in the the Cisco IOS

00:16:47,869 --> 00:16:51,980
or quagga formats that I showed in the

00:16:49,850 --> 00:16:53,899
earlier configs but it's one level up

00:16:51,980 --> 00:16:55,489
from there so what we can do with these

00:16:53,899 --> 00:16:58,040
attributes is push them out through

00:16:55,489 --> 00:17:01,459
something like SNMP or Netcom for some

00:16:58,040 --> 00:17:03,980
of the programming ap is possibly

00:17:01,459 --> 00:17:07,939
through to some of the the more DevOps

00:17:03,980 --> 00:17:10,039
configuration for server systems so a

00:17:07,939 --> 00:17:11,779
lot of the time that these networks

00:17:10,039 --> 00:17:13,399
aren't just routers in isolation we

00:17:11,779 --> 00:17:15,709
might have a DNS server connected in

00:17:13,399 --> 00:17:16,880
which needs to know about the other DNS

00:17:15,709 --> 00:17:20,990
servers or there's an interrelationship

00:17:16,880 --> 00:17:22,519
between the the routers and the devices

00:17:20,990 --> 00:17:24,169
connected to in the servers and they

00:17:22,519 --> 00:17:26,569
need to know about the IP addresses or

00:17:24,169 --> 00:17:28,459
there might be a DNS hierarchy that

00:17:26,569 --> 00:17:30,710
those representations where it's not

00:17:28,459 --> 00:17:32,570
just a device in isolation works quite

00:17:30,710 --> 00:17:34,429
well with this approach and I'm

00:17:32,570 --> 00:17:36,649
particularly interested in the salt

00:17:34,429 --> 00:17:38,490
stack side of things because seeing the

00:17:36,649 --> 00:17:40,440
earlier talk on salt stack

00:17:38,490 --> 00:17:43,520
that these level of attributes could

00:17:40,440 --> 00:17:45,690
push quite nicely into some of the llamo

00:17:43,520 --> 00:17:47,520
config for salt stack and then to go

00:17:45,690 --> 00:17:49,620
from there provisioning it but our work

00:17:47,520 --> 00:17:51,660
to date has been in configuring the

00:17:49,620 --> 00:17:53,670
device templates while configuring the

00:17:51,660 --> 00:17:56,540
devices based on templates so outputting

00:17:53,670 --> 00:17:59,340
those text files so we've been using

00:17:56,540 --> 00:18:01,050
Mako templates and as part of the

00:17:59,340 --> 00:18:03,330
compilation step which is buried right

00:18:01,050 --> 00:18:04,950
down the bottom there you can specify in

00:18:03,330 --> 00:18:06,780
the compiler which template you want to

00:18:04,950 --> 00:18:08,940
use so this approach means that you can

00:18:06,780 --> 00:18:10,710
quickly configure for one type of device

00:18:08,940 --> 00:18:12,630
whether it's a Cisco one or whether it's

00:18:10,710 --> 00:18:14,370
for quagga or a different routing vendor

00:18:12,630 --> 00:18:16,290
you can easily use the same design

00:18:14,370 --> 00:18:17,760
approach and then push them out rather

00:18:16,290 --> 00:18:20,750
than having to rewrite all of your

00:18:17,760 --> 00:18:23,400
configuration for each different um

00:18:20,750 --> 00:18:25,080
device that you're configuring so we use

00:18:23,400 --> 00:18:27,690
Mako which is similar to a lot of the

00:18:25,080 --> 00:18:29,820
other templating languages and basically

00:18:27,690 --> 00:18:31,590
to define your template all we've really

00:18:29,820 --> 00:18:34,530
got in the template is iteration

00:18:31,590 --> 00:18:36,630
conditionals and variable substitution

00:18:34,530 --> 00:18:38,820
because I've seen a lot of other

00:18:36,630 --> 00:18:40,650
configuration systems that vary a lot of

00:18:38,820 --> 00:18:42,330
deep network logic into the templates

00:18:40,650 --> 00:18:44,340
and they become both hard to use and

00:18:42,330 --> 00:18:45,720
maintain but also less portable if you

00:18:44,340 --> 00:18:47,880
want to change the syntax to a different

00:18:45,720 --> 00:18:50,280
vendor it's very tightly coupled between

00:18:47,880 --> 00:18:53,429
the device configuration syntax and your

00:18:50,280 --> 00:18:55,710
network level design so Mako works quite

00:18:53,429 --> 00:18:59,370
nicely and you just define your template

00:18:55,710 --> 00:19:02,790
and then calling Mako with the node here

00:18:59,370 --> 00:19:04,950
and you can then using the get attribute

00:19:02,790 --> 00:19:06,570
and set attribute magic methods it

00:19:04,950 --> 00:19:07,980
becomes quite succinct then to do things

00:19:06,570 --> 00:19:08,940
like the hostname is just no dot

00:19:07,980 --> 00:19:11,400
hostname and that will grab that

00:19:08,940 --> 00:19:13,410
property so trying to keep the templates

00:19:11,400 --> 00:19:15,030
as readable as possible and you'll get

00:19:13,410 --> 00:19:17,370
the output such as down the bottom or

00:19:15,030 --> 00:19:19,170
for something like BGP you might have a

00:19:17,370 --> 00:19:21,030
slightly different template again

00:19:19,170 --> 00:19:22,530
applying just the node to it and you'll

00:19:21,030 --> 00:19:24,780
get the output there and then that

00:19:22,530 --> 00:19:27,059
scales across as many devices as you

00:19:24,780 --> 00:19:29,490
need so that's generating device

00:19:27,059 --> 00:19:31,410
configurations we've been playing around

00:19:29,490 --> 00:19:33,150
with emulated networks to test them out

00:19:31,410 --> 00:19:35,190
because just to generating the

00:19:33,150 --> 00:19:38,040
configurations isn't necessarily enough

00:19:35,190 --> 00:19:41,160
to to verify they work and to learn how

00:19:38,040 --> 00:19:43,860
to design these configuration systems so

00:19:41,160 --> 00:19:46,740
the idea of emulated networks is just to

00:19:43,860 --> 00:19:48,660
instead of buying Hardware routers which

00:19:46,740 --> 00:19:51,740
especially when we're at university gets

00:19:48,660 --> 00:19:53,570
quite prohibitive in expenses

00:19:51,740 --> 00:19:55,760
you take the operating system that we

00:19:53,570 --> 00:19:57,860
running on a router and running them

00:19:55,760 --> 00:20:00,110
inside a virtual machine so we're in

00:19:57,860 --> 00:20:02,600
vision aliy using that kit which was

00:20:00,110 --> 00:20:04,429
running user mode Linux and you just run

00:20:02,600 --> 00:20:06,110
the quagga routing daemon inside that

00:20:04,429 --> 00:20:08,540
which was really efficient you could

00:20:06,110 --> 00:20:10,460
with quagga inside UML you could run a

00:20:08,540 --> 00:20:12,230
router that would perform all the

00:20:10,460 --> 00:20:14,450
general routing functions in about 32

00:20:12,230 --> 00:20:16,910
megabytes of RAM which was very

00:20:14,450 --> 00:20:20,390
efficient on them any sort of commodity

00:20:16,910 --> 00:20:23,510
device to build big networks and then my

00:20:20,390 --> 00:20:25,190
work at Cisco has been on viral which is

00:20:23,510 --> 00:20:26,840
a virtual internet routing lab which is

00:20:25,190 --> 00:20:29,059
a similar kind of idea except it's

00:20:26,840 --> 00:20:30,500
running of course Cisco's iOS and we're

00:20:29,059 --> 00:20:32,210
doing the inside open stacks that's

00:20:30,500 --> 00:20:34,580
something that's coming soon but the

00:20:32,210 --> 00:20:36,530
same general idea is that once we

00:20:34,580 --> 00:20:38,240
generated these configurations we can

00:20:36,530 --> 00:20:39,920
then push them out to these ins to these

00:20:38,240 --> 00:20:41,870
emulated networks we could also push

00:20:39,920 --> 00:20:43,880
them to a hardware networks a lot easier

00:20:41,870 --> 00:20:46,790
with an emulated Network and then do

00:20:43,880 --> 00:20:49,040
some experimentation with that so Auto

00:20:46,790 --> 00:20:50,660
Net kit we extended it on to push the

00:20:49,040 --> 00:20:53,750
configurations out so we've been using

00:20:50,660 --> 00:20:56,720
either P expect or expect X script which

00:20:53,750 --> 00:20:59,540
is some nice expectable as nice as

00:20:56,720 --> 00:21:01,250
expect can be scripting libraries to

00:20:59,540 --> 00:21:04,790
basically just running the standard net

00:21:01,250 --> 00:21:06,620
kit commands to archive the folder to

00:21:04,790 --> 00:21:09,650
transfer it over to the Linux host and

00:21:06,620 --> 00:21:11,150
archive it shot down previous labs and

00:21:09,650 --> 00:21:13,010
then start up the new one and verify

00:21:11,150 --> 00:21:15,260
that's working so that comes through

00:21:13,010 --> 00:21:17,690
like that and the end result is we end

00:21:15,260 --> 00:21:19,670
up with yeah just a normal routing

00:21:17,690 --> 00:21:21,440
terminal so we can see for instance here

00:21:19,670 --> 00:21:23,260
show IP routers showing all the

00:21:21,440 --> 00:21:27,230
connected routers and this has come from

00:21:23,260 --> 00:21:29,420
OSPF configuration from that diagram bgp

00:21:27,230 --> 00:21:31,400
configuration from the BGP diagram and

00:21:29,420 --> 00:21:32,840
then see for the directly connected

00:21:31,400 --> 00:21:37,429
networks which would then all come from

00:21:32,840 --> 00:21:38,720
the for the physical diagram and one of

00:21:37,429 --> 00:21:40,130
the other nice things is that when we're

00:21:38,720 --> 00:21:41,720
doing with overlay graphs we could

00:21:40,130 --> 00:21:43,100
easily iterate over the nodes in it just

00:21:41,720 --> 00:21:45,380
to do things that are pretty mundane

00:21:43,100 --> 00:21:47,990
such as IP addressing if you're doing

00:21:45,380 --> 00:21:50,240
that with Python iteration just iterate

00:21:47,990 --> 00:21:52,040
over the the subnets and then chuck and

00:21:50,240 --> 00:21:54,559
IP address on each end which becomes

00:21:52,040 --> 00:21:55,760
quite quite easy to do IP addressing the

00:21:54,559 --> 00:21:58,370
problem is though that if we can

00:21:55,760 --> 00:22:00,890
configure big networks emulate big

00:21:58,370 --> 00:22:02,990
networks running this command is the

00:22:00,890 --> 00:22:04,450
next thing that we should automate gets

00:22:02,990 --> 00:22:07,300
quite tedious to

00:22:04,450 --> 00:22:10,240
type that in on every device so we've

00:22:07,300 --> 00:22:12,190
built a extending the X script expect

00:22:10,240 --> 00:22:14,410
scripting or during that kit can send it

00:22:12,190 --> 00:22:16,960
off to the collection client we're using

00:22:14,410 --> 00:22:19,000
rabbitmq we use HTTP POST is to say

00:22:16,960 --> 00:22:21,250
these are the devices I want to measure

00:22:19,000 --> 00:22:23,350
this is a client I want to run such as

00:22:21,250 --> 00:22:25,240
trace throughout or show IP route to a

00:22:23,350 --> 00:22:26,830
collection client it will run that on

00:22:25,240 --> 00:22:28,690
each of the hosts and send the results

00:22:26,830 --> 00:22:31,540
back the problem is though if we just

00:22:28,690 --> 00:22:33,100
get the result back from expect it's

00:22:31,540 --> 00:22:35,920
just going to be a whole heap of text

00:22:33,100 --> 00:22:38,170
which is okay to look at but again not

00:22:35,920 --> 00:22:40,350
particularly nice to work with in a

00:22:38,170 --> 00:22:44,140
programming sense so there's a nice

00:22:40,350 --> 00:22:45,940
library text FSM which is working with

00:22:44,140 --> 00:22:48,820
semi structured text this came from

00:22:45,940 --> 00:22:50,680
Google Sydney network operations team

00:22:48,820 --> 00:22:53,500
this is a yeah Python open source

00:22:50,680 --> 00:22:55,870
library and the idea is that a lot of

00:22:53,500 --> 00:22:58,120
the network data that you get back is

00:22:55,870 --> 00:23:00,040
generally got structure but it can vary

00:22:58,120 --> 00:23:01,780
a bit so traceroute is fairly simple

00:23:00,040 --> 00:23:04,780
you're just going to have the hot number

00:23:01,780 --> 00:23:08,020
the IP address and the delay here when

00:23:04,780 --> 00:23:10,300
you get to things like show interface or

00:23:08,020 --> 00:23:11,860
the equivalents I have config and Linux

00:23:10,300 --> 00:23:13,720
you're going to get things that could

00:23:11,860 --> 00:23:16,000
vary depending on whether it's running

00:23:13,720 --> 00:23:20,050
ipv4 ipv6 so handling all these

00:23:16,000 --> 00:23:22,360
different type of conditionals text FSM

00:23:20,050 --> 00:23:23,620
was really nice to deal with any sort of

00:23:22,360 --> 00:23:26,470
structure texture that could come with

00:23:23,620 --> 00:23:28,780
if you're working with a hardware device

00:23:26,470 --> 00:23:30,130
and getting results back from there it's

00:23:28,780 --> 00:23:32,500
not necessarily just Network and that

00:23:30,130 --> 00:23:34,600
can then process it back so the idea is

00:23:32,500 --> 00:23:36,820
that you've got your input the template

00:23:34,600 --> 00:23:38,620
looks something like this where it can

00:23:36,820 --> 00:23:40,930
handle the different cases and then

00:23:38,620 --> 00:23:42,520
running that through text FSM you're

00:23:40,930 --> 00:23:44,430
going to get the output as you see a

00:23:42,520 --> 00:23:46,990
series of lists so here we've got the

00:23:44,430 --> 00:23:51,040
destination the hop there's no MPLS

00:23:46,990 --> 00:23:53,380
thing set and then the delay and so what

00:23:51,040 --> 00:23:55,240
we can do is that allows us to do some

00:23:53,380 --> 00:23:57,430
really powerful test driven network

00:23:55,240 --> 00:23:59,200
programming so if we go right back to

00:23:57,430 --> 00:24:00,610
network X as well as letting us deal

00:23:59,200 --> 00:24:03,370
with graphs it's got a really powerful

00:24:00,610 --> 00:24:05,200
set of algorithms built into it such as

00:24:03,370 --> 00:24:08,440
the classic Dijkstra's shortest path so

00:24:05,200 --> 00:24:10,600
we could give Network X to nodes in our

00:24:08,440 --> 00:24:11,710
network run it across with the standard

00:24:10,600 --> 00:24:14,980
shortest path and it will tell us the

00:24:11,710 --> 00:24:16,900
shortest path and we could then take the

00:24:14,980 --> 00:24:17,890
output from text FSM if we ran trace

00:24:16,900 --> 00:24:19,450
through out

00:24:17,890 --> 00:24:21,010
and because we know the IP addresses

00:24:19,450 --> 00:24:23,410
that we've allocated in the network we

00:24:21,010 --> 00:24:27,940
could easily build a reverse DNS kind of

00:24:23,410 --> 00:24:29,500
mapping to take this output back back

00:24:27,940 --> 00:24:31,600
here down the bottom of the heap of IP

00:24:29,500 --> 00:24:32,860
addresses and convert that into a list

00:24:31,600 --> 00:24:35,110
just with a few more list comprehensions

00:24:32,860 --> 00:24:36,820
just doing a reverse mapping and then we

00:24:35,110 --> 00:24:39,130
can do some quite powerful things so for

00:24:36,820 --> 00:24:40,450
instance this is showing we could do

00:24:39,130 --> 00:24:42,700
trace route which I'll get to in a

00:24:40,450 --> 00:24:44,679
second and also for instance showing

00:24:42,700 --> 00:24:46,450
show IP route so we could run this as a

00:24:44,679 --> 00:24:47,920
network starts up and to see the routes

00:24:46,450 --> 00:24:49,750
change and I've got some videos on the

00:24:47,920 --> 00:24:51,970
auto knit kit website so there's a lot

00:24:49,750 --> 00:24:53,440
of really powerful things we can do by

00:24:51,970 --> 00:24:56,950
stringing all these bits together and

00:24:53,440 --> 00:24:58,809
just very quickly this is a sped-up

00:24:56,950 --> 00:25:01,690
video of showing the whole process so

00:24:58,809 --> 00:25:03,460
drawing the network in yet and then we

00:25:01,690 --> 00:25:06,250
can see the real-time visualization for

00:25:03,460 --> 00:25:07,900
each of the ibgp and ispf diagrams

00:25:06,250 --> 00:25:09,820
setting some attributes such as the

00:25:07,900 --> 00:25:11,980
autonomous system number now we have

00:25:09,820 --> 00:25:13,179
three AAS as rather than just one so all

00:25:11,980 --> 00:25:16,570
those design rules are applied

00:25:13,179 --> 00:25:18,340
differently we can use the API to set

00:25:16,570 --> 00:25:20,860
properties and then this is just the

00:25:18,340 --> 00:25:23,290
compilation down to generate the that

00:25:20,860 --> 00:25:24,910
resource database the output

00:25:23,290 --> 00:25:26,710
configurations which are generated from

00:25:24,910 --> 00:25:28,660
there for the each of those devices in

00:25:26,710 --> 00:25:31,330
the network including the OSPF and BGP

00:25:28,660 --> 00:25:32,770
router configs and then doing some

00:25:31,330 --> 00:25:36,669
analysis so running shortest path

00:25:32,770 --> 00:25:38,590
directly starting up the laboratory you

00:25:36,669 --> 00:25:41,470
should just expect scripting to launch

00:25:38,590 --> 00:25:43,510
it and this over here is of course d3

00:25:41,470 --> 00:25:45,900
running which makes all this fancy

00:25:43,510 --> 00:25:48,190
animation really quite easy to do and

00:25:45,900 --> 00:25:49,990
grabbing the commands back and then

00:25:48,190 --> 00:25:52,120
doing the passing of that with Texas at

00:25:49,990 --> 00:25:54,960
FSM sending that to the web browsers a

00:25:52,120 --> 00:25:57,100
path in JSON and viewing the result and

00:25:54,960 --> 00:25:59,549
that's pretty much it and those are the

00:25:57,100 --> 00:26:02,700
packages that are really good

00:25:59,549 --> 00:26:02,700
thank you

00:26:06,530 --> 00:26:11,700
Thanks so um we still have a couple of

00:26:09,120 --> 00:26:15,120
minutes for questions if anyone a couple

00:26:11,700 --> 00:26:16,410
of hands went straight up there hi so

00:26:15,120 --> 00:26:21,030
first of all mind blown

00:26:16,410 --> 00:26:23,370
awesome and so if I understood correctly

00:26:21,030 --> 00:26:26,130
you basically go from drawing a diagram

00:26:23,370 --> 00:26:29,730
to all the way to configuring routers

00:26:26,130 --> 00:26:31,560
yeah and to me this sounds like I could

00:26:29,730 --> 00:26:34,680
draw a diagram and configure a

00:26:31,560 --> 00:26:37,080
software-defined network yet that if

00:26:34,680 --> 00:26:39,210
this were extended to you know work with

00:26:37,080 --> 00:26:42,660
open flow or something yeah are there

00:26:39,210 --> 00:26:46,350
any plans to do that or yeah I think in

00:26:42,660 --> 00:26:47,850
some way so basically I think we would

00:26:46,350 --> 00:26:49,920
stop at this point here so rather than

00:26:47,850 --> 00:26:52,230
doing all the horrible xpect scripting a

00:26:49,920 --> 00:26:53,880
lot of the motivation from

00:26:52,230 --> 00:26:56,160
software-defined networking as better

00:26:53,880 --> 00:26:58,470
abstractions which i think there's two

00:26:56,160 --> 00:26:59,280
parts in it bit philosophical one of

00:26:58,470 --> 00:27:00,990
those is better at programming

00:26:59,280 --> 00:27:03,300
abstractions which we don't really have

00:27:00,990 --> 00:27:04,980
in networks and the other thing is the

00:27:03,300 --> 00:27:07,590
mechanisms is to push those out and

00:27:04,980 --> 00:27:09,630
expect is pretty horrible so the API is

00:27:07,590 --> 00:27:11,790
to push stuff onto a device whether it's

00:27:09,630 --> 00:27:15,120
open flow or Cisco's 1pk or whichever

00:27:11,790 --> 00:27:17,670
variant we have I think that's important

00:27:15,120 --> 00:27:19,320
but I think the other key thing which I

00:27:17,670 --> 00:27:21,840
haven't seen a whole lot of in a lot of

00:27:19,320 --> 00:27:23,040
the controllers is being able to

00:27:21,840 --> 00:27:25,800
describe your network at a high level

00:27:23,040 --> 00:27:27,090
and do operations to to build what you

00:27:25,800 --> 00:27:29,100
want it to look like and I think that's

00:27:27,090 --> 00:27:30,660
where something along the lines of what

00:27:29,100 --> 00:27:33,480
we've got with Auto Net kick could could

00:27:30,660 --> 00:27:34,860
do that role and getting from drawing

00:27:33,480 --> 00:27:36,690
saying I want this to connect to this

00:27:34,860 --> 00:27:38,100
based on this and seeing the output and

00:27:36,690 --> 00:27:39,690
then being able to compress that down

00:27:38,100 --> 00:27:41,880
will condense it down to having this

00:27:39,690 --> 00:27:44,010
kind of attribute so I think we would go

00:27:41,880 --> 00:27:45,750
in an SDN sense we could use some that

00:27:44,010 --> 00:27:47,430
the early stages of Auto net kit and

00:27:45,750 --> 00:27:48,990
then have something like these

00:27:47,430 --> 00:27:50,970
attributes here and then this could be

00:27:48,990 --> 00:27:53,190
instead of bgp config could be those

00:27:50,970 --> 00:27:54,870
open flow parameters and doing design

00:27:53,190 --> 00:27:58,110
rules from there and using that sort of

00:27:54,870 --> 00:28:00,240
design api and this bit and then pushing

00:27:58,110 --> 00:28:03,210
that out to a different package so I

00:28:00,240 --> 00:28:06,170
think that's how to tie in yeah thanks

00:28:03,210 --> 00:28:06,170
other questions

00:28:08,770 --> 00:28:14,000
have you looked at automated problem

00:28:12,049 --> 00:28:16,340
analysis you know detecting potential

00:28:14,000 --> 00:28:19,330
errors in the configuration detecting

00:28:16,340 --> 00:28:21,440
potential errors in the config yeah

00:28:19,330 --> 00:28:23,360
again it comes back to having the higher

00:28:21,440 --> 00:28:26,299
level of abstraction and doing some of

00:28:23,360 --> 00:28:28,880
those things so one thing I did do basic

00:28:26,299 --> 00:28:30,440
was there's this whole thing about

00:28:28,880 --> 00:28:31,910
correct by design so if you write your

00:28:30,440 --> 00:28:33,440
design rules right it should be good

00:28:31,910 --> 00:28:35,330
which is a bit of a cop-out I think that

00:28:33,440 --> 00:28:37,309
you could write independently again it's

00:28:35,330 --> 00:28:39,049
just basic graph stuff you could then

00:28:37,309 --> 00:28:41,000
start to apply some design rule so

00:28:39,049 --> 00:28:42,710
there'd be some on the low-level config

00:28:41,000 --> 00:28:44,299
gen I think there's also some design

00:28:42,710 --> 00:28:46,040
rules we could start to build in this

00:28:44,299 --> 00:28:48,620
saying we have been looking at at this

00:28:46,040 --> 00:28:50,179
sort of level here so for instance if

00:28:48,620 --> 00:28:51,860
you've got no SPF graph you shouldn't be

00:28:50,179 --> 00:28:53,990
connecting things in different areas to

00:28:51,860 --> 00:28:55,280
each other or different ASNs or that you

00:28:53,990 --> 00:28:56,510
shouldn't be able to have disconnected

00:28:55,280 --> 00:28:58,190
things so it's quite easy to apply a

00:28:56,510 --> 00:29:00,260
graph algorithm to look for disconnected

00:28:58,190 --> 00:29:02,929
components you could do that or you

00:29:00,260 --> 00:29:04,460
could check the attribute if so in OSPF

00:29:02,929 --> 00:29:05,870
everything should go through area 0 if

00:29:04,460 --> 00:29:07,400
it becomes from different areas that

00:29:05,870 --> 00:29:09,260
kind of thing you could easily do as a

00:29:07,400 --> 00:29:11,510
graph looking at the components looking

00:29:09,260 --> 00:29:13,700
the connectivity between them and so

00:29:11,510 --> 00:29:15,290
that way you could automatically someone

00:29:13,700 --> 00:29:17,419
with you know deep network expertise

00:29:15,290 --> 00:29:19,130
could write those rules and then anyone

00:29:17,419 --> 00:29:21,200
can come along and concoct these kind of

00:29:19,130 --> 00:29:23,870
design rules verify them against that

00:29:21,200 --> 00:29:26,090
and then get you know sign errors back

00:29:23,870 --> 00:29:27,740
at that level as well as then being able

00:29:26,090 --> 00:29:30,080
to do some of the you know automated

00:29:27,740 --> 00:29:31,460
measurement right at the end as well to

00:29:30,080 --> 00:29:32,960
do something there's a few parts where

00:29:31,460 --> 00:29:36,110
some of that testing could come into it

00:29:32,960 --> 00:29:37,610
and again the DevOps people have a lot

00:29:36,110 --> 00:29:39,350
of that solved to be nice to be able do

00:29:37,610 --> 00:29:41,270
some of that in the networking sense or

00:29:39,350 --> 00:29:44,120
even the the software engineering type

00:29:41,270 --> 00:29:45,919
of philosophy and methodology for

00:29:44,120 --> 00:29:48,110
testing and unit testing and things like

00:29:45,919 --> 00:29:49,250
that you can start to get towards which

00:29:48,110 --> 00:29:51,470
again I think is some of the appeal of

00:29:49,250 --> 00:29:53,270
software-defined networking but I don't

00:29:51,470 --> 00:29:54,559
think we need to have open flow to be

00:29:53,270 --> 00:29:55,790
able to get some of the benefits of

00:29:54,559 --> 00:29:57,559
working at better abstraction and

00:29:55,790 --> 00:29:58,610
there's also a whole heap of stuff on

00:29:57,559 --> 00:30:00,049
the internet now that people aren't

00:29:58,610 --> 00:30:01,460
going to replace overnight that we can

00:30:00,049 --> 00:30:03,020
we can do a better job with what we've

00:30:01,460 --> 00:30:08,200
got now and then perhaps replace it in

00:30:03,020 --> 00:30:10,929
the future any other questions

00:30:08,200 --> 00:30:13,610
thanks heaps for that Simon we have

00:30:10,929 --> 00:30:16,010
coffee beans and a coffee mug

00:30:13,610 --> 00:30:18,230
thanks to ritual coffee and the PyCon

00:30:16,010 --> 00:30:21,950
organizers for you

00:30:18,230 --> 00:30:21,950

YouTube URL: https://www.youtube.com/watch?v=EGK5jjyUBCQ


