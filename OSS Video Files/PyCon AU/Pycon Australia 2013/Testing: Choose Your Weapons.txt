Title: Testing: Choose Your Weapons
Publication date: 2013-07-11
Playlist: Pycon Australia 2013
Description: 
	Todd Owen
http://2013.pycon-au.org/schedule/30043/view_talk
A good suite of tests is a programmer's best friend. But a poorly designed testing strategy can result in tests that are unwieldy, fragile, and above all no fun to write or maintain.

This talk will offer a smorgasbord of testing ideas, ranging from simple tips and tricks to fully-fledged testing frameworks for Python. We will touch on automation, table-based testing, round-trip testing, UI testing, property checking, testing Twisted
Captions: 
	00:00:00,000 --> 00:00:04,650
is Todd Owen he is employed by the WA

00:00:02,970 --> 00:00:06,420
Health Department where he helps develop

00:00:04,650 --> 00:00:08,610
systems to link data for public health

00:00:06,420 --> 00:00:10,080
research he is engineered most of the

00:00:08,610 --> 00:00:11,639
testing and continuing to continuous

00:00:10,080 --> 00:00:13,290
integration practices currently used by

00:00:11,639 --> 00:00:15,059
his team and can't imagine life without

00:00:13,290 --> 00:00:22,980
automated testing please make Todd

00:00:15,059 --> 00:00:24,210
welcome good afternoon now I know

00:00:22,980 --> 00:00:25,890
everyone is probably feeling like a

00:00:24,210 --> 00:00:28,140
short nap after that lovely big lunch

00:00:25,890 --> 00:00:30,539
but remember why you're here you're

00:00:28,140 --> 00:00:33,329
excited about PyCon you're excited about

00:00:30,539 --> 00:00:38,160
Hobart and most of all you're excited

00:00:33,329 --> 00:00:40,710
about testing just like these three

00:00:38,160 --> 00:00:44,610
girls chasing down bugs I am excited

00:00:40,710 --> 00:00:46,860
about testing ok so who am i or Russell

00:00:44,610 --> 00:00:52,949
went into that anyone else here from

00:00:46,860 --> 00:00:55,590
perth by the way lots so i work on such

00:00:52,949 --> 00:00:57,930
we're at the wi health department for

00:00:55,590 --> 00:01:00,359
standardizing and matching data about

00:00:57,930 --> 00:01:02,850
people from disparate collection systems

00:01:00,359 --> 00:01:06,450
so i can tell you it's a dirty job we

00:01:02,850 --> 00:01:09,090
see a lot of dirty data why am I excited

00:01:06,450 --> 00:01:10,439
about testing honestly it's the same

00:01:09,090 --> 00:01:13,549
thing that got me into programming in

00:01:10,439 --> 00:01:16,080
the first place I love solving problems

00:01:13,549 --> 00:01:18,689
what I don't like is spending half a day

00:01:16,080 --> 00:01:20,790
writing a long ugly test method that

00:01:18,689 --> 00:01:22,680
cause half a dozen supposedly private

00:01:20,790 --> 00:01:24,540
member functions and then a week later

00:01:22,680 --> 00:01:27,720
it breaks because some dependency

00:01:24,540 --> 00:01:32,030
somewhere has changed is that problem

00:01:27,720 --> 00:01:34,280
solving I call that creating a problem

00:01:32,030 --> 00:01:37,409
so for the purpose of this presentation

00:01:34,280 --> 00:01:39,420
when I talk about problem solving I'm

00:01:37,409 --> 00:01:40,799
not talking about the business problems

00:01:39,420 --> 00:01:43,380
and there are other talks at this

00:01:40,799 --> 00:01:46,640
conference about that I mean that test

00:01:43,380 --> 00:01:49,380
design is a problem worth solving and

00:01:46,640 --> 00:01:51,299
the best way of writing and organizing

00:01:49,380 --> 00:01:54,390
tests is going to be different for every

00:01:51,299 --> 00:01:56,759
project so choose your weapons carefully

00:01:54,390 --> 00:01:59,159
just because someone has built a better

00:01:56,759 --> 00:02:02,880
mousetrap doesn't mean it's the best way

00:01:59,159 --> 00:02:05,969
to catch butterflies let's start with a

00:02:02,880 --> 00:02:08,520
quick example you've got a function you

00:02:05,969 --> 00:02:11,099
want to test called get latest tweet it

00:02:08,520 --> 00:02:13,010
takes a Twitter user name and returns

00:02:11,099 --> 00:02:15,660
that person's most recent tweet

00:02:13,010 --> 00:02:25,980
please just take 10 seconds to think

00:02:15,660 --> 00:02:27,480
about how you might test that there are

00:02:25,980 --> 00:02:30,300
actually lots of ways you might approach

00:02:27,480 --> 00:02:32,660
it if you know the other objects that it

00:02:30,300 --> 00:02:34,800
collaborates with you could use mocks if

00:02:32,660 --> 00:02:36,690
you want to test all the way down to the

00:02:34,800 --> 00:02:39,239
network layer or you could write a fake

00:02:36,690 --> 00:02:42,390
Twitter server that gives some canned

00:02:39,239 --> 00:02:44,069
responses or alternatively you could

00:02:42,390 --> 00:02:46,230
record a session connecting with the

00:02:44,069 --> 00:02:49,140
real twitter com and then replay it

00:02:46,230 --> 00:02:50,370
during your tests or if you haven't have

00:02:49,140 --> 00:02:52,680
a full implementation of a Twitter

00:02:50,370 --> 00:02:55,890
server you can spin up a private to test

00:02:52,680 --> 00:02:58,200
instance and connect to that or even

00:02:55,890 --> 00:03:02,069
connect to it in memory so that you

00:02:58,200 --> 00:03:05,040
don't even rely on the network or you

00:03:02,069 --> 00:03:07,680
could create a real twitter account then

00:03:05,040 --> 00:03:09,989
login and post one tweet and then don't

00:03:07,680 --> 00:03:11,880
touch it again later when you run your

00:03:09,989 --> 00:03:15,150
tests you'll always be able to get the

00:03:11,880 --> 00:03:18,269
same result now all of these have pros

00:03:15,150 --> 00:03:21,000
and cons they don't necessarily serve

00:03:18,269 --> 00:03:24,360
the same purpose even so connecting to a

00:03:21,000 --> 00:03:27,540
real twitter account is not a unit test

00:03:24,360 --> 00:03:30,420
by most people's definition but unlike

00:03:27,540 --> 00:03:32,400
these other suggestions one advantage it

00:03:30,420 --> 00:03:34,620
has is that you are actually testing the

00:03:32,400 --> 00:03:40,049
integration between your code and the

00:03:34,620 --> 00:03:41,760
real external service so don't fall into

00:03:40,049 --> 00:03:44,010
the trap of thinking that one testing

00:03:41,760 --> 00:03:48,690
philosophy or one testing tool can solve

00:03:44,010 --> 00:03:50,730
all of your problems and just to

00:03:48,690 --> 00:03:53,310
emphasize that let me quote from a piece

00:03:50,730 --> 00:03:56,340
of writing by Alberto Savoia called the

00:03:53,310 --> 00:03:58,140
way of test of us this purports to be a

00:03:56,340 --> 00:04:02,280
translation of ancient Eastern wisdom

00:03:58,140 --> 00:04:05,600
about programming it says dogma is

00:04:02,280 --> 00:04:09,150
inflexible testing needs flexibility

00:04:05,600 --> 00:04:12,329
dogma kills creativity testing needs

00:04:09,150 --> 00:04:14,430
creativity so today I don't plan to

00:04:12,329 --> 00:04:17,130
lecture you on how you should test your

00:04:14,430 --> 00:04:19,289
programs but I'm going to show you a few

00:04:17,130 --> 00:04:23,159
maybe surprising ways that you could

00:04:19,289 --> 00:04:25,800
test your programs but that's enough

00:04:23,159 --> 00:04:27,389
wisdom let's get back to some code

00:04:25,800 --> 00:04:29,490
we'll assume that we've already chosen

00:04:27,389 --> 00:04:31,289
one of those earlier methods for testing

00:04:29,490 --> 00:04:33,599
our function and we've written a setup

00:04:31,289 --> 00:04:35,159
and teardown method accordingly what

00:04:33,599 --> 00:04:38,190
then might the body of our test look

00:04:35,159 --> 00:04:40,229
like right here we're using the unit

00:04:38,190 --> 00:04:43,590
test module that comes standard with

00:04:40,229 --> 00:04:47,039
Python so we inherit from test case and

00:04:43,590 --> 00:04:49,409
we write a test method what it will do

00:04:47,039 --> 00:04:52,740
is call the get latest tweet function

00:04:49,409 --> 00:04:57,300
and then check that the result is what

00:04:52,740 --> 00:04:59,639
we expected now that's really easy so

00:04:57,300 --> 00:05:01,289
let's change the problem imagine that we

00:04:59,639 --> 00:05:06,509
want to rewrite our function to be an

00:05:01,289 --> 00:05:10,500
asynchronous call instead how many

00:05:06,509 --> 00:05:13,080
people here have used twisted lot of

00:05:10,500 --> 00:05:15,090
hands if you haven't then don't worry

00:05:13,080 --> 00:05:17,490
the next few slides are a bit foreign

00:05:15,090 --> 00:05:19,530
just briefly twisted python is a

00:05:17,490 --> 00:05:21,949
networking library that uses an

00:05:19,530 --> 00:05:25,319
adventure of an approach to concurrency

00:05:21,949 --> 00:05:27,750
the event loop controls the execution of

00:05:25,319 --> 00:05:29,880
the program so let's say at some point

00:05:27,750 --> 00:05:33,930
it calls a chunk of application code

00:05:29,880 --> 00:05:37,169
that uses our function at this point our

00:05:33,930 --> 00:05:38,759
function would initiate some work but it

00:05:37,169 --> 00:05:40,889
wouldn't wait for that word to complete

00:05:38,759 --> 00:05:43,680
instead it would return a special object

00:05:40,889 --> 00:05:46,860
called a deferred now this represents

00:05:43,680 --> 00:05:48,840
the final outcome the outcome isn't

00:05:46,860 --> 00:05:51,300
available yet but it will be at some

00:05:48,840 --> 00:05:53,789
point in the future so if the caller

00:05:51,300 --> 00:05:55,500
wants to know that final result what

00:05:53,789 --> 00:05:58,080
they do is they add a call back and

00:05:55,500 --> 00:06:02,279
that's just an ordinary function here

00:05:58,080 --> 00:06:04,740
i've called it CB but later on when that

00:06:02,279 --> 00:06:06,779
deferred has completed then the twisted

00:06:04,740 --> 00:06:09,210
framework will ensure that CB is called

00:06:06,779 --> 00:06:12,389
with the final result in this case the

00:06:09,210 --> 00:06:15,990
tweet so there are no blocking i/o calls

00:06:12,389 --> 00:06:19,279
and everyone is happy everyone except me

00:06:15,990 --> 00:06:21,690
because I have to write the tests and

00:06:19,279 --> 00:06:25,979
the problem is that if I use the same

00:06:21,690 --> 00:06:27,690
approach as before then when i call this

00:06:25,979 --> 00:06:30,090
new function all i get back is a

00:06:27,690 --> 00:06:32,430
deferred and what can i test at this

00:06:30,090 --> 00:06:34,949
point what do I know about this deferred

00:06:32,430 --> 00:06:37,919
I I know nothing except it hasn't even

00:06:34,949 --> 00:06:39,689
been called yet so i could to assert

00:06:37,919 --> 00:06:41,009
false on dr called

00:06:39,689 --> 00:06:44,489
but that's obviously pretty meaningless

00:06:41,009 --> 00:06:46,799
and in fact this deferred won't ever be

00:06:44,489 --> 00:06:49,769
called because the event loop isn't

00:06:46,799 --> 00:06:51,269
running and we could start the event

00:06:49,769 --> 00:06:53,219
loop running in our test but then we'd

00:06:51,269 --> 00:06:56,219
have to worry about how do we stop it

00:06:53,219 --> 00:07:00,209
how do we handle errors and so on there

00:06:56,219 --> 00:07:02,129
must be a better way unfortunately the

00:07:00,209 --> 00:07:04,110
clever folk who wrote twisted have

00:07:02,129 --> 00:07:07,619
provided some testing tools in a package

00:07:04,110 --> 00:07:09,929
called trial this includes a test case

00:07:07,619 --> 00:07:13,289
class that inherits from the standard

00:07:09,929 --> 00:07:16,679
one but also manages our event loop for

00:07:13,289 --> 00:07:19,309
us if we inherit from this class then

00:07:16,679 --> 00:07:23,249
what our test method can now do is

00:07:19,309 --> 00:07:27,179
return a deferred optionally so we could

00:07:23,249 --> 00:07:28,889
return this.d and now the test runner

00:07:27,179 --> 00:07:31,199
will wait until that deferred has

00:07:28,889 --> 00:07:35,129
completed before it marks the test as a

00:07:31,199 --> 00:07:38,239
pass or fail so if we do this at least

00:07:35,129 --> 00:07:41,159
our deferred now will eventually fire

00:07:38,239 --> 00:07:43,909
but what about testing that the result

00:07:41,159 --> 00:07:47,129
is correct we can't put an assertion

00:07:43,909 --> 00:07:51,629
directly in this method but we can add a

00:07:47,129 --> 00:07:54,479
call back so the callback is just a

00:07:51,629 --> 00:07:57,739
function again of called it CB it's just

00:07:54,479 --> 00:08:00,589
got that one assert equal inside it and

00:07:57,739 --> 00:08:02,759
we can make this syntax look even nicer

00:08:00,589 --> 00:08:06,659
by using something called inline

00:08:02,759 --> 00:08:08,610
callbacks to do so we import this helper

00:08:06,659 --> 00:08:12,779
function which we can also use as a

00:08:08,610 --> 00:08:15,389
decorator on our method then we use our

00:08:12,779 --> 00:08:17,279
mat then we write our method using the

00:08:15,389 --> 00:08:23,189
yield call back oh sorry the yield

00:08:17,279 --> 00:08:25,919
keyword and what that does is when we

00:08:23,189 --> 00:08:29,729
yield the result of get latest tweet

00:08:25,919 --> 00:08:33,059
acing which is a deferred control leaves

00:08:29,729 --> 00:08:34,889
this method and it doesn't return again

00:08:33,059 --> 00:08:36,990
until that deferred has completed and

00:08:34,889 --> 00:08:40,709
the actual result will then be assigned

00:08:36,990 --> 00:08:43,620
to the variable tweet that means all we

00:08:40,709 --> 00:08:49,050
have to do is use assert equal as before

00:08:43,620 --> 00:08:51,809
and so although under the covers this

00:08:49,050 --> 00:08:53,370
the way this method runs is really quite

00:08:51,809 --> 00:08:55,920
different to that for

00:08:53,370 --> 00:08:57,930
method that first test we wrote for the

00:08:55,920 --> 00:09:00,320
non twisted version to you and I reading

00:08:57,930 --> 00:09:03,450
it it looks very similar in structure

00:09:00,320 --> 00:09:06,390
it's short and it's simple and it's easy

00:09:03,450 --> 00:09:09,240
to understand so in this case we've been

00:09:06,390 --> 00:09:12,180
very lucky the tools to make testing

00:09:09,240 --> 00:09:14,490
easier were right under our noses but

00:09:12,180 --> 00:09:16,950
it's not always that easy sometimes you

00:09:14,490 --> 00:09:20,420
have to look further afield sometimes

00:09:16,950 --> 00:09:20,420
you may have to write the tools yourself

00:09:28,170 --> 00:09:32,620
at this point we're finished with

00:09:30,370 --> 00:09:34,360
twisted but not quite finished with

00:09:32,620 --> 00:09:38,680
event loops because I'm going to talk a

00:09:34,360 --> 00:09:41,830
bit about UI testing UI tests

00:09:38,680 --> 00:09:43,630
particularly for desktop applications

00:09:41,830 --> 00:09:45,490
with a graphical interface have always

00:09:43,630 --> 00:09:49,450
been the scariest kind of test to

00:09:45,490 --> 00:09:52,150
automate this point and click is so easy

00:09:49,450 --> 00:09:54,550
for a human operator but it's difficult

00:09:52,150 --> 00:09:57,550
to automate it's typically done by

00:09:54,550 --> 00:10:00,430
fabricating your GUI events sending them

00:09:57,550 --> 00:10:02,530
to the application and well you can do

00:10:00,430 --> 00:10:04,030
that using code there are also some

00:10:02,530 --> 00:10:05,500
tools around particularly some

00:10:04,030 --> 00:10:09,880
commercial products I've noticed that

00:10:05,500 --> 00:10:11,260
take a record replay approach but once

00:10:09,880 --> 00:10:13,420
you get over this hurdle of actually

00:10:11,260 --> 00:10:15,880
automating your mouse clicks you soon

00:10:13,420 --> 00:10:20,710
discover the real problem with GUI tests

00:10:15,880 --> 00:10:23,080
they can be very brittle robotoid if

00:10:20,710 --> 00:10:25,720
your tests rely on some specific pixel

00:10:23,080 --> 00:10:28,450
coordinates because GUI layouts change

00:10:25,720 --> 00:10:30,760
with surprising frequency hardly a build

00:10:28,450 --> 00:10:34,270
goes by without some widget being added

00:10:30,760 --> 00:10:36,100
or moved or resized and so you may find

00:10:34,270 --> 00:10:38,440
yourself spending a lot of time updating

00:10:36,100 --> 00:10:41,530
your GUI test suite fixing those tests

00:10:38,440 --> 00:10:45,520
when they break maybe recording your

00:10:41,530 --> 00:10:47,290
tests every time they break one option

00:10:45,520 --> 00:10:49,780
that is tempting and can perhaps be

00:10:47,290 --> 00:10:52,930
justified on a smaller project is not to

00:10:49,780 --> 00:10:54,490
automate it all and believe it or not we

00:10:52,930 --> 00:10:56,680
actually found some ways to do

00:10:54,490 --> 00:11:00,730
test-driven development without full

00:10:56,680 --> 00:11:03,100
automation now what you see here is a

00:11:00,730 --> 00:11:06,280
window from an in-house application it's

00:11:03,100 --> 00:11:09,040
asking the operator for intervention in

00:11:06,280 --> 00:11:12,370
the process of standardizing the format

00:11:09,040 --> 00:11:15,670
of name so the user will mainly interact

00:11:12,370 --> 00:11:17,710
with this form or this frame here it's

00:11:15,670 --> 00:11:19,420
basically a specialized name editor and

00:11:17,710 --> 00:11:22,180
it has some quite complicated behavior

00:11:19,420 --> 00:11:24,940
attached to it fortunately it's

00:11:22,180 --> 00:11:27,760
implemented as a separate class and we

00:11:24,940 --> 00:11:31,570
would like to test this GUI component in

00:11:27,760 --> 00:11:33,880
isolation now here you see that

00:11:31,570 --> 00:11:37,480
component being used in a test this is a

00:11:33,880 --> 00:11:38,780
scripted manual test instructions appear

00:11:37,480 --> 00:11:41,780
at the top and

00:11:38,780 --> 00:11:44,420
testa clicks yes or no in response to

00:11:41,780 --> 00:11:46,790
the question so here the instruction at

00:11:44,420 --> 00:11:49,580
the top says can you move Mohammed to

00:11:46,790 --> 00:11:53,180
the end of the name this is actually a

00:11:49,580 --> 00:11:56,300
real use case because Muhammad is a very

00:11:53,180 --> 00:11:57,740
common given name and in some of the

00:11:56,300 --> 00:12:01,070
records that we've received it may even

00:11:57,740 --> 00:12:03,650
be omitted and so strictly for our

00:12:01,070 --> 00:12:06,050
internal use in data matching we prefer

00:12:03,650 --> 00:12:08,750
to make the other part of the name has

00:12:06,050 --> 00:12:12,170
only in this case more prominent by

00:12:08,750 --> 00:12:15,110
moving it to the start so the tester

00:12:12,170 --> 00:12:17,630
would do this manually they would change

00:12:15,110 --> 00:12:20,890
over the names and they would click yes

00:12:17,630 --> 00:12:24,320
and then another instruction appears

00:12:20,890 --> 00:12:28,340
this asks us to abbreviate Mohammed to

00:12:24,320 --> 00:12:31,310
mohd now again this is because the name

00:12:28,340 --> 00:12:33,380
may be abbreviated in some records or it

00:12:31,310 --> 00:12:35,590
may be given a variant spelling and so

00:12:33,380 --> 00:12:38,900
for our internal purposes only we

00:12:35,590 --> 00:12:41,330
standardize it so the tester would have

00:12:38,900 --> 00:12:46,670
edit that field and they would click use

00:12:41,330 --> 00:12:48,560
again and the test passes alright let's

00:12:46,670 --> 00:12:52,160
have a look at what the code for that

00:12:48,560 --> 00:12:56,450
looks like again I'm going to omit the

00:12:52,160 --> 00:12:58,220
setup and teardown methods but stealing

00:12:56,450 --> 00:13:00,410
an idea from the twisted test that we

00:12:58,220 --> 00:13:04,070
looked at earlier this test also uses

00:13:00,410 --> 00:13:06,860
the yield keyword and we've written a

00:13:04,070 --> 00:13:09,260
test runner for this that will display

00:13:06,860 --> 00:13:13,100
this string and prompt and wait for the

00:13:09,260 --> 00:13:15,410
user to click yes or no and control will

00:13:13,100 --> 00:13:17,680
only return to the method the test

00:13:15,410 --> 00:13:20,060
method after the user has clicked yes

00:13:17,680 --> 00:13:23,620
after that we immediately display that

00:13:20,060 --> 00:13:26,540
second instruction but then at the end

00:13:23,620 --> 00:13:28,970
we check the state of the component

00:13:26,540 --> 00:13:31,130
under test and this is vitally important

00:13:28,970 --> 00:13:32,600
because the program might look like it's

00:13:31,130 --> 00:13:35,900
doing the right thing but actually be

00:13:32,600 --> 00:13:38,870
saving the wrong data so I call this a

00:13:35,900 --> 00:13:40,520
semi automated test because there's no

00:13:38,870 --> 00:13:42,950
automation at the graphical interface

00:13:40,520 --> 00:13:46,940
but there is verification at the

00:13:42,950 --> 00:13:50,150
programmatic interface so the advantage

00:13:46,940 --> 00:13:52,769
of that is you can do test-driven design

00:13:50,150 --> 00:13:55,559
writing your tests before the code

00:13:52,769 --> 00:13:57,629
but once the code is complete there's no

00:13:55,559 --> 00:14:00,989
way to run the test again on every build

00:13:57,629 --> 00:14:03,089
so you lose automatic regression testing

00:14:00,989 --> 00:14:06,689
and that means that we weren't able to

00:14:03,089 --> 00:14:09,869
get the maximum value from our tests but

00:14:06,689 --> 00:14:11,339
then we discovered an opportunity one of

00:14:09,869 --> 00:14:12,689
the long-standing requirements for this

00:14:11,339 --> 00:14:17,910
system was that at the keyboard

00:14:12,689 --> 00:14:20,399
accessible in fact some of the the

00:14:17,910 --> 00:14:24,540
components support quite complicated

00:14:20,399 --> 00:14:26,399
keyboard commands and so if anything

00:14:24,540 --> 00:14:28,230
testing those commands was more

00:14:26,399 --> 00:14:31,290
important than testing interaction via

00:14:28,230 --> 00:14:35,730
the mouse so we seized upon this as an

00:14:31,290 --> 00:14:37,470
opportunity to automate the UI we

00:14:35,730 --> 00:14:41,009
converted those semi-automatic tests

00:14:37,470 --> 00:14:44,129
into keyboard driven UI tests we had to

00:14:41,009 --> 00:14:46,619
run a new we had to write a new test

00:14:44,129 --> 00:14:49,439
runner but the test for themselves only

00:14:46,619 --> 00:14:51,299
required a small modification so

00:14:49,439 --> 00:14:56,540
comparing to that earlier piece of code

00:14:51,299 --> 00:14:59,610
the only change here is the to yield

00:14:56,540 --> 00:15:02,279
statements and we've just added one

00:14:59,610 --> 00:15:04,350
extra string to each one that encodes a

00:15:02,279 --> 00:15:07,470
sequence of keystrokes so the first one

00:15:04,350 --> 00:15:10,499
there the mg 1 G 2 just means send these

00:15:07,470 --> 00:15:13,499
five key strokes to the component and

00:15:10,499 --> 00:15:16,259
that's actually a single command that

00:15:13,499 --> 00:15:22,860
means move given name one to give a name

00:15:16,259 --> 00:15:28,829
to so let's run that see what it looks

00:15:22,860 --> 00:15:30,600
like ok that is running out the normal

00:15:28,829 --> 00:15:32,220
speed with a 200 millisecond pause

00:15:30,600 --> 00:15:36,449
between keystrokes I'll just play it

00:15:32,220 --> 00:15:42,119
again a bit slower so first switch over

00:15:36,449 --> 00:15:44,570
the names then edit to add the

00:15:42,119 --> 00:15:46,580
abbreviation

00:15:44,570 --> 00:15:49,160
of course you'll usually want to run

00:15:46,580 --> 00:15:50,450
these methods headless so that they

00:15:49,160 --> 00:15:53,030
don't keep popping up windows on your

00:15:50,450 --> 00:15:55,700
monitor all the time but I'm not going

00:15:53,030 --> 00:15:57,410
to get into that right now but the nice

00:15:55,700 --> 00:15:58,970
thing i will say about using keyboard

00:15:57,410 --> 00:16:02,090
events is that it's actually a very

00:15:58,970 --> 00:16:04,400
stable interface unlike GUI layouts

00:16:02,090 --> 00:16:08,090
keyboard shortcuts don't often change

00:16:04,400 --> 00:16:09,680
between builds now this approach is not

00:16:08,090 --> 00:16:11,630
going to catch every kind of gooey

00:16:09,680 --> 00:16:16,430
defect it's not going to catch any

00:16:11,630 --> 00:16:18,740
cosmetic faults but in our experience it

00:16:16,430 --> 00:16:22,760
can catch a large proportion of the more

00:16:18,740 --> 00:16:24,590
serious gooey bugs now remember i'm not

00:16:22,760 --> 00:16:28,100
claiming that keyboard driven UI tests

00:16:24,590 --> 00:16:30,800
are the the best approach for your

00:16:28,100 --> 00:16:32,480
project what fun would programming be

00:16:30,800 --> 00:16:35,780
after all if there was no room for

00:16:32,480 --> 00:16:38,420
creativity this is a specific solution

00:16:35,780 --> 00:16:41,240
to our specific problem and it's very

00:16:38,420 --> 00:16:43,430
satisfying to find a lightweight design

00:16:41,240 --> 00:16:45,770
that gives you 20 / so that gives you

00:16:43,430 --> 00:16:48,520
eighty percent of the value for twenty

00:16:45,770 --> 00:16:48,520
percent of the effort

00:16:55,449 --> 00:17:00,829
okay what we've seen so far are tools

00:16:58,459 --> 00:17:02,689
that extend the capabilities the

00:17:00,829 --> 00:17:05,780
capabilities of the basic unit test

00:17:02,689 --> 00:17:10,089
module now let's look at one alternative

00:17:05,780 --> 00:17:12,919
to that style of test it's called fit

00:17:10,089 --> 00:17:16,400
this is a test framework invented by

00:17:12,919 --> 00:17:18,589
Ward Cunningham about a decade ago he

00:17:16,400 --> 00:17:21,020
wrote it for Java but it's been ported

00:17:18,589 --> 00:17:24,709
to a few other languages and the Python

00:17:21,020 --> 00:17:27,140
implementation is called PI Fett using

00:17:24,709 --> 00:17:30,409
this framework the test cases are not

00:17:27,140 --> 00:17:33,559
written as code but rather as text in a

00:17:30,409 --> 00:17:36,730
tabular format this has some limitations

00:17:33,559 --> 00:17:39,350
but it also has some compelling benefits

00:17:36,730 --> 00:17:42,470
for one it means that the tests are

00:17:39,350 --> 00:17:45,890
accessible to non-programmers so it's

00:17:42,470 --> 00:17:48,530
particularly suitable for writing tests

00:17:45,890 --> 00:17:50,690
of your business logic the things that

00:17:48,530 --> 00:17:54,429
your customer really really cares about

00:17:50,690 --> 00:17:57,200
and understands better than you do

00:17:54,429 --> 00:17:59,840
another benefit is that these tests can

00:17:57,200 --> 00:18:01,429
be very concise and that's great when

00:17:59,840 --> 00:18:05,270
you have a large number of tests that

00:18:01,429 --> 00:18:10,039
share a very similar structure now let's

00:18:05,270 --> 00:18:14,210
look at one this is simply an HTML

00:18:10,039 --> 00:18:15,559
document fit only cares about tables so

00:18:14,210 --> 00:18:17,630
between the tables you can add whatever

00:18:15,559 --> 00:18:21,140
headers and explanatory text you like

00:18:17,630 --> 00:18:24,649
and please forgive the gratuitous

00:18:21,140 --> 00:18:26,149
skeuomorph of the torn paper but do

00:18:24,649 --> 00:18:28,399
notice that this is something you could

00:18:26,149 --> 00:18:30,530
print out and show to your customer and

00:18:28,399 --> 00:18:32,330
have a conversation about that's not

00:18:30,530 --> 00:18:36,110
something you can easily do with a unit

00:18:32,330 --> 00:18:39,799
test written in Python the first column

00:18:36,110 --> 00:18:41,539
is the input the raw genome column and

00:18:39,799 --> 00:18:44,539
the other two columns notice they have a

00:18:41,539 --> 00:18:47,539
question mark in the header that means

00:18:44,539 --> 00:18:50,169
that their their output columns and each

00:18:47,539 --> 00:18:52,490
row of the table is a separate test case

00:18:50,169 --> 00:18:54,530
so I'll just step through the second row

00:18:52,490 --> 00:18:58,820
here it's saying when the input is

00:18:54,530 --> 00:19:01,850
Muhammad Moussa the result the in the

00:18:58,820 --> 00:19:04,159
genome should be those two words but as

00:19:01,850 --> 00:19:06,919
separate items in a list and in addition

00:19:04,159 --> 00:19:11,330
it should set a warning message

00:19:06,919 --> 00:19:12,739
and that is what causes the the program

00:19:11,330 --> 00:19:14,929
to ask the operator for manual

00:19:12,739 --> 00:19:19,759
intervention just like we saw in that

00:19:14,929 --> 00:19:23,659
example with the the GUI but how does

00:19:19,759 --> 00:19:29,029
fit know what test or what code to use

00:19:23,659 --> 00:19:31,179
to verify these test cases well the

00:19:29,029 --> 00:19:33,499
first cell here provides a class name

00:19:31,179 --> 00:19:35,029
and that's called the test fixture and

00:19:33,499 --> 00:19:39,289
we'll have a look now at how that class

00:19:35,029 --> 00:19:40,759
might be defined the fixture inherits

00:19:39,289 --> 00:19:43,580
from one of several available based

00:19:40,759 --> 00:19:46,580
classes with column fixture being the

00:19:43,580 --> 00:19:48,529
simplest one and this class must contain

00:19:46,580 --> 00:19:52,100
member variables matching the names of

00:19:48,529 --> 00:19:54,470
each column in the table for each of the

00:19:52,100 --> 00:19:57,080
test cases so for each of the rows in

00:19:54,470 --> 00:20:00,470
other in other words fit we'll first set

00:19:57,080 --> 00:20:03,320
any input values so just raw genome for

00:20:00,470 --> 00:20:06,919
this and that it will call a method

00:20:03,320 --> 00:20:10,879
called execute here is how we might

00:20:06,919 --> 00:20:12,529
write the execute method so you can see

00:20:10,879 --> 00:20:14,840
here that the part of our system that's

00:20:12,529 --> 00:20:17,059
actually being exercised by these tests

00:20:14,840 --> 00:20:19,190
is this function name underscore clean

00:20:17,059 --> 00:20:24,919
that's what we're actually trying to

00:20:19,190 --> 00:20:28,009
test here now after this has been called

00:20:24,919 --> 00:20:30,739
fit will then compare the outputs the

00:20:28,009 --> 00:20:35,169
genome and the warning message to the

00:20:30,739 --> 00:20:37,850
expected values that are in the table so

00:20:35,169 --> 00:20:40,639
returning to this test now if we run fit

00:20:37,850 --> 00:20:43,309
on this document then the output will

00:20:40,639 --> 00:20:45,799
look like this the correct results are

00:20:43,309 --> 00:20:48,889
shown in green and at the moment

00:20:45,799 --> 00:20:51,429
everything passes but what if we decide

00:20:48,889 --> 00:20:53,960
we want to change these business rules

00:20:51,429 --> 00:20:56,299
remember when we were testing in the GUI

00:20:53,960 --> 00:20:58,730
we had to move the Mahama to the end of

00:20:56,299 --> 00:21:00,230
the name and abbreviate it well instead

00:20:58,730 --> 00:21:02,389
of requiring the user to do that

00:21:00,230 --> 00:21:05,929
manually every time how about we make

00:21:02,389 --> 00:21:09,940
that an automatic business rule let's

00:21:05,929 --> 00:21:09,940
start by changing our tests

00:21:10,970 --> 00:21:15,659
we'll have another look at the second

00:21:13,110 --> 00:21:17,100
row here so now we're saying when the

00:21:15,659 --> 00:21:22,289
inputs mohammed must say it should be

00:21:17,100 --> 00:21:24,299
changed to musa and mohd and there

00:21:22,289 --> 00:21:26,370
should be no warning message here we

00:21:24,299 --> 00:21:30,210
have to use the explicit word blank to

00:21:26,370 --> 00:21:33,120
show an empty value and if we run these

00:21:30,210 --> 00:21:34,830
tests this is what we get the

00:21:33,120 --> 00:21:37,950
disagreements between the expected and

00:21:34,830 --> 00:21:40,679
actual outcomes are colored red and only

00:21:37,950 --> 00:21:43,380
one cell is green and that was more an

00:21:40,679 --> 00:21:44,700
accident than anything else the next

00:21:43,380 --> 00:21:46,799
step of course would be to start

00:21:44,700 --> 00:21:54,990
changing your code so that your tests go

00:21:46,799 --> 00:21:56,880
green now all the examples I've talked

00:21:54,990 --> 00:21:59,760
about so far have involved writing one

00:21:56,880 --> 00:22:01,890
or more test cases and specifying the

00:21:59,760 --> 00:22:04,770
expected outcome in each of these test

00:22:01,890 --> 00:22:07,020
scenarios well this paradigm has a long

00:22:04,770 --> 00:22:11,850
history and software engineering but

00:22:07,020 --> 00:22:14,100
it's not the only approach consider the

00:22:11,850 --> 00:22:17,010
difference between the search the

00:22:14,100 --> 00:22:19,320
assertions in those test cases versus

00:22:17,010 --> 00:22:21,600
the humble assert statement that you

00:22:19,320 --> 00:22:24,659
might put in ordinary code hopefully as

00:22:21,600 --> 00:22:27,270
often as possible rather than describing

00:22:24,659 --> 00:22:30,480
what's expected in a particular scenario

00:22:27,270 --> 00:22:32,309
the assert statement is expressing a

00:22:30,480 --> 00:22:34,470
condition that should always be true at

00:22:32,309 --> 00:22:37,380
runtime no matter what the input values

00:22:34,470 --> 00:22:40,380
are and there are some approaches that

00:22:37,380 --> 00:22:43,679
take this this approach to design and

00:22:40,380 --> 00:22:46,350
testing even further there is designed

00:22:43,679 --> 00:22:49,169
by contract popularized by the Eiffel

00:22:46,350 --> 00:22:51,419
programming language there's also

00:22:49,169 --> 00:22:52,950
property based testing which has really

00:22:51,419 --> 00:22:56,610
taken off in the functional programming

00:22:52,950 --> 00:23:01,620
community quick check is an example of

00:22:56,610 --> 00:23:03,510
that approach and you could even include

00:23:01,620 --> 00:23:06,000
something like load testing in this

00:23:03,510 --> 00:23:07,770
category because under high load you're

00:23:06,000 --> 00:23:11,220
not expecting some deterministic

00:23:07,770 --> 00:23:13,020
response from your system you just care

00:23:11,220 --> 00:23:16,350
that it satisfies some sort of general

00:23:13,020 --> 00:23:18,270
property like a maximum latency or

00:23:16,350 --> 00:23:22,560
average throughput or just that it

00:23:18,270 --> 00:23:24,880
doesn't fall over and burst into flames

00:23:22,560 --> 00:23:26,800
I'm not going to go into any of these in

00:23:24,880 --> 00:23:29,380
depth although there are certainly tools

00:23:26,800 --> 00:23:32,380
are in Python to support all of these

00:23:29,380 --> 00:23:35,680
approaches but more important I think is

00:23:32,380 --> 00:23:38,380
just this seed of an idea that rather

00:23:35,680 --> 00:23:42,960
than expressing your test as specific

00:23:38,380 --> 00:23:45,580
test cases hard coded examples you can

00:23:42,960 --> 00:23:48,280
express them as general properties which

00:23:45,580 --> 00:23:49,810
the computer can evaluate now that's

00:23:48,280 --> 00:23:52,480
just another weapon to add to your

00:23:49,810 --> 00:23:56,860
testing arsenal and to make that a bit

00:23:52,480 --> 00:23:58,690
more concrete I do have an example in

00:23:56,860 --> 00:24:02,590
our system we have something we call a

00:23:58,690 --> 00:24:05,620
round-trip test our system which is the

00:24:02,590 --> 00:24:09,330
new system needs the ability to

00:24:05,620 --> 00:24:11,710
replicate data to a second legacy system

00:24:09,330 --> 00:24:13,750
unfortunately the data schemas are very

00:24:11,710 --> 00:24:17,770
different they are very different indeed

00:24:13,750 --> 00:24:22,300
in particular if we were to test just a

00:24:17,770 --> 00:24:24,430
single field then in tested in isolation

00:24:22,300 --> 00:24:27,010
then it wouldn't give us confidence that

00:24:24,430 --> 00:24:30,010
composite data was also translated

00:24:27,010 --> 00:24:32,470
correctly so instead of using a small

00:24:30,010 --> 00:24:34,840
number of fictional test cases we want

00:24:32,470 --> 00:24:42,280
to test that we could drive using real

00:24:34,840 --> 00:24:44,500
data now rather than inspecting the

00:24:42,280 --> 00:24:47,140
legacy system directly and trying to

00:24:44,500 --> 00:24:50,020
compare these different schemas we found

00:24:47,140 --> 00:24:51,370
it easier to implement the translation

00:24:50,020 --> 00:24:55,090
in such a way that we could run it

00:24:51,370 --> 00:24:57,420
forward or in reverse so during

00:24:55,090 --> 00:25:02,170
development we can take some sample data

00:24:57,420 --> 00:25:05,470
we can translate it into a test instance

00:25:02,170 --> 00:25:08,620
of the legacy system and then we can

00:25:05,470 --> 00:25:10,980
translate it back again into a new fresh

00:25:08,620 --> 00:25:14,650
test instance of the new system and

00:25:10,980 --> 00:25:16,480
finally we can compare the original data

00:25:14,650 --> 00:25:17,890
to the round trip to data and that's

00:25:16,480 --> 00:25:20,580
very straightforward because they share

00:25:17,890 --> 00:25:20,580
the same format

00:25:20,870 --> 00:25:27,050
now in in case all those arrows obscure

00:25:25,490 --> 00:25:29,600
the actual property that we're testing

00:25:27,050 --> 00:25:33,650
let me write it here in a more equation

00:25:29,600 --> 00:25:40,190
or form if this translate function which

00:25:33,650 --> 00:25:43,960
we can call tea has an inverse which

00:25:40,190 --> 00:25:48,680
will call you that's the untranslated

00:25:43,960 --> 00:25:51,380
then if we take any data and apply tea

00:25:48,680 --> 00:25:56,420
and then apply you then it should yield

00:25:51,380 --> 00:25:58,670
exactly the original data so a

00:25:56,420 --> 00:26:01,850
successful round-trip test is showing us

00:25:58,670 --> 00:26:03,670
that this translation is reversible but

00:26:01,850 --> 00:26:05,990
how does that property actually help us

00:26:03,670 --> 00:26:08,360
well the most important thing it shows

00:26:05,990 --> 00:26:11,090
is that no information is lost or

00:26:08,360 --> 00:26:13,970
becomes ambiguous in this process of

00:26:11,090 --> 00:26:16,220
translation because if so how could you

00:26:13,970 --> 00:26:20,000
possibly recover it no matter how clever

00:26:16,220 --> 00:26:22,580
your an translate function is now this

00:26:20,000 --> 00:26:25,760
property does not necessarily or doesn't

00:26:22,580 --> 00:26:29,960
prove at all that the translation is the

00:26:25,760 --> 00:26:33,620
correct one for the domain but we have

00:26:29,960 --> 00:26:35,030
other tests to address that what the

00:26:33,620 --> 00:26:37,309
round-trip test does do in our

00:26:35,030 --> 00:26:39,290
experience is it catches some things

00:26:37,309 --> 00:26:42,200
some common defects that the other tests

00:26:39,290 --> 00:26:46,040
don't things like a meeting of field

00:26:42,200 --> 00:26:49,340
from the original spec so we've

00:26:46,040 --> 00:26:50,990
certainly found these useful and even

00:26:49,340 --> 00:26:55,100
after deployment we still run these

00:26:50,990 --> 00:26:57,530
tests once a week after hours using the

00:26:55,100 --> 00:26:59,780
latest production data to verify that

00:26:57,530 --> 00:27:02,270
there are no anomalies in the new data

00:26:59,780 --> 00:27:05,200
that might affect the translation into

00:27:02,270 --> 00:27:05,200
the legacy system

00:27:07,680 --> 00:27:11,700
now I'm afraid I haven't left much time

00:27:09,870 --> 00:27:14,220
for I have a left a couple of minutes

00:27:11,700 --> 00:27:16,740
for questions if you want to try any of

00:27:14,220 --> 00:27:19,470
these ideas in your own project then do

00:27:16,740 --> 00:27:21,210
feel free to contact me if I can help

00:27:19,470 --> 00:27:24,450
out with some sample code of us would be

00:27:21,210 --> 00:27:26,780
more than happy so may the weapons you

00:27:24,450 --> 00:27:32,630
choose for testing be sharp and shiny

00:27:26,780 --> 00:27:32,630
and thank you for choosing my talk today

00:27:37,090 --> 00:27:41,150
if you would like to ask a question

00:27:39,020 --> 00:27:43,190
there are two microphones at the base of

00:27:41,150 --> 00:27:53,630
the stairs here please cue and we'll try

00:27:43,190 --> 00:27:57,070
to alternate between hello Lou and

00:27:53,630 --> 00:27:59,690
thanks for you talk it's really great

00:27:57,070 --> 00:28:01,730
what I wanted to going back to the

00:27:59,690 --> 00:28:04,790
twisted stuff I haven't done a lot of

00:28:01,730 --> 00:28:07,390
twisted but in the one-liner that you

00:28:04,790 --> 00:28:10,910
had there with the the yield function

00:28:07,390 --> 00:28:13,100
given from what I understood it would

00:28:10,910 --> 00:28:15,410
run the test get to the yield function

00:28:13,100 --> 00:28:17,799
go off run a bunch of other tests and

00:28:15,410 --> 00:28:21,919
then once the yield function came I

00:28:17,799 --> 00:28:26,330
guess I'll interrupt um no it the one

00:28:21,919 --> 00:28:28,940
test case will wait until all the

00:28:26,330 --> 00:28:30,380
deferred have fired right and then it

00:28:28,940 --> 00:28:33,049
will decide whether it's a pass or fail

00:28:30,380 --> 00:28:36,740
right ok cool as I was thinking if

00:28:33,049 --> 00:28:37,970
you've got like stuff going into a

00:28:36,740 --> 00:28:39,740
database or something there's all these

00:28:37,970 --> 00:28:41,660
tests running all over the place then it

00:28:39,740 --> 00:28:43,669
but it just stops in that tests and

00:28:41,660 --> 00:28:46,790
waits waits for the deferred to come

00:28:43,669 --> 00:28:49,669
back again and then does this it yeah

00:28:46,790 --> 00:28:51,679
and ordinarily I mean if generally your

00:28:49,669 --> 00:28:53,120
test should be quite fast it's just more

00:28:51,679 --> 00:28:55,160
a matter of how do you why are these two

00:28:53,120 --> 00:28:58,340
phones together and so on which then the

00:28:55,160 --> 00:28:59,900
test framework can handle but you can

00:28:58,340 --> 00:29:02,390
also set a time out and there is a

00:28:59,900 --> 00:29:04,940
default time out so one way your test

00:29:02,390 --> 00:29:06,830
could fail is that the framework is

00:29:04,940 --> 00:29:13,450
waiting for 30 seconds and and it

00:29:06,830 --> 00:29:16,250
doesn't finish right cool thanks hi um

00:29:13,450 --> 00:29:17,840
you had a one-liner there on load test

00:29:16,250 --> 00:29:20,230
and you didn't otherwise mention them

00:29:17,840 --> 00:29:23,059
I'm particularly interested in them

00:29:20,230 --> 00:29:25,309
methodologies about doing load test what

00:29:23,059 --> 00:29:26,630
counts as past what councils fail how

00:29:25,309 --> 00:29:28,669
you know how much loads and generate

00:29:26,630 --> 00:29:30,860
things like that do you have any kind of

00:29:28,669 --> 00:29:33,169
thoughts on that I my suggestion is that

00:29:30,860 --> 00:29:35,059
you wait in this room for about five

00:29:33,169 --> 00:29:39,890
more minutes because I think that it the

00:29:35,059 --> 00:29:43,940
next person is talking about I think the

00:29:39,890 --> 00:29:47,110
next talk is on that sort of topic next

00:29:43,940 --> 00:29:50,510
one after oh ok I'm as a matter of fact

00:29:47,110 --> 00:29:50,759
I don't work in the web development

00:29:50,510 --> 00:29:54,299
space

00:29:50,759 --> 00:29:59,789
and so I don't really have any opinions

00:29:54,299 --> 00:30:02,909
on that load testing actually have a

00:29:59,789 --> 00:30:04,409
question outside of the web space back

00:30:02,909 --> 00:30:06,389
in the day I used to the GUI GUI testing

00:30:04,409 --> 00:30:08,099
and I'm intrigued that you've you've got

00:30:06,389 --> 00:30:10,889
your testing system has got this human

00:30:08,099 --> 00:30:12,299
in the loop aspect you said that you

00:30:10,889 --> 00:30:14,669
know capturing events and generating

00:30:12,299 --> 00:30:17,309
events is one way of simulating what's

00:30:14,669 --> 00:30:19,769
going on but then that doesn't test that

00:30:17,309 --> 00:30:20,909
the widget has been churning in red and

00:30:19,769 --> 00:30:21,690
that it is on the left hand side of the

00:30:20,909 --> 00:30:23,519
screen which is the thing that

00:30:21,690 --> 00:30:24,690
ultimately is the hardest thing to check

00:30:23,519 --> 00:30:26,279
without doing image difference or

00:30:24,690 --> 00:30:27,599
something like that and then you've got

00:30:26,279 --> 00:30:28,909
to put a human in the loop with with a

00:30:27,599 --> 00:30:31,109
pressing a button and then the human

00:30:28,909 --> 00:30:32,909
again more often than not like i have

00:30:31,109 --> 00:30:34,979
member having a an application at a

00:30:32,909 --> 00:30:36,690
hundred page manual test suite and by

00:30:34,979 --> 00:30:39,629
the time you've got to page 75 isn't yes

00:30:36,690 --> 00:30:41,399
yes yes you end up getting false

00:30:39,629 --> 00:30:43,829
positives because the human is a bad

00:30:41,399 --> 00:30:47,009
tester right so how do you factor that

00:30:43,829 --> 00:30:49,379
into your testing regimen right and see

00:30:47,009 --> 00:30:53,459
that's why i mentioned that we use those

00:30:49,379 --> 00:30:55,349
tests for doing development so we would

00:30:53,459 --> 00:30:58,739
write those tests first and then the

00:30:55,349 --> 00:31:01,499
when I say tester I just I want to

00:30:58,739 --> 00:31:03,509
emphasize that it's a human operator but

00:31:01,499 --> 00:31:05,819
in this case the tester was always the

00:31:03,509 --> 00:31:09,479
developer just writing the code they

00:31:05,819 --> 00:31:17,759
would run the test if it passes or not I

00:31:09,479 --> 00:31:21,299
I certainly agree with you that using

00:31:17,759 --> 00:31:26,759
that as some kind of deployment or

00:31:21,299 --> 00:31:29,489
customer acceptance kind of test what we

00:31:26,759 --> 00:31:31,979
don't do that basically and we just we

00:31:29,489 --> 00:31:35,309
stopped at just automating via the

00:31:31,979 --> 00:31:37,529
keyboard because that's good enough to

00:31:35,309 --> 00:31:40,589
capture the serious kinds of bugs like

00:31:37,529 --> 00:31:44,940
when when some widget just stops working

00:31:40,589 --> 00:31:47,999
then we'd like to know about that and we

00:31:44,940 --> 00:31:50,429
don't have have a lot of users we're

00:31:47,999 --> 00:31:52,739
just doing in-house applications so when

00:31:50,429 --> 00:31:55,589
something is supposed to be red and it's

00:31:52,739 --> 00:31:58,139
not red then unfortunately it comes back

00:31:55,589 --> 00:32:02,450
to what I think was mentioned in the

00:31:58,139 --> 00:32:07,970
keynote someone complains and so

00:32:02,450 --> 00:32:09,650
effective actually I was intending to

00:32:07,970 --> 00:32:10,940
ask a very similar question it seems

00:32:09,650 --> 00:32:13,190
you've actually answered my question

00:32:10,940 --> 00:32:15,980
butter so you have never really

00:32:13,190 --> 00:32:18,670
seriously considered the the the cost of

00:32:15,980 --> 00:32:21,590
actually putting non developer people

00:32:18,670 --> 00:32:25,090
too I guess be the human box just sort

00:32:21,590 --> 00:32:29,560
of automate that level of testing then I

00:32:25,090 --> 00:32:33,740
know we don't I kind of feel that i

00:32:29,560 --> 00:32:35,270
would like to experience that style just

00:32:33,740 --> 00:32:39,140
just to see how dysfunctional it is

00:32:35,270 --> 00:32:43,010
because you you know the agile people

00:32:39,140 --> 00:32:45,920
call it waterfall and yeah we've never

00:32:43,010 --> 00:32:51,080
had manual testers you know have you any

00:32:45,920 --> 00:32:57,020
experience with that how many people

00:32:51,080 --> 00:33:01,400
here work with a tester or I do consider

00:32:57,020 --> 00:33:03,760
themselves a tester all right so there

00:33:01,400 --> 00:33:03,760
are quite a few

00:33:05,320 --> 00:33:08,860
I'm just a quick question on that have

00:33:07,450 --> 00:33:12,279
you come across this product called

00:33:08,860 --> 00:33:16,659
sikuli I know no I wait like the day um

00:33:12,279 --> 00:33:19,470
it's a Python scripted image tool for

00:33:16,659 --> 00:33:23,320
testing buoys so instead of clicking

00:33:19,470 --> 00:33:24,880
that point on the screen you define this

00:33:23,320 --> 00:33:27,220
this is what the thing looks like that

00:33:24,880 --> 00:33:29,799
you should click on and it clicks on the

00:33:27,220 --> 00:33:32,470
button that says okay regardless where

00:33:29,799 --> 00:33:35,169
that is so it's part unscripted tool

00:33:32,470 --> 00:33:37,870
that um I think I saw a commercial

00:33:35,169 --> 00:33:41,399
product that was similar as well it's

00:33:37,870 --> 00:33:44,409
not commercial and I think that that is

00:33:41,399 --> 00:33:47,860
from a technical sort of mindset that

00:33:44,409 --> 00:33:49,659
sounds really clever yeah and it will it

00:33:47,860 --> 00:33:53,049
should reduce the number of things that

00:33:49,659 --> 00:33:55,419
you have to redo or fix but the problem

00:33:53,049 --> 00:33:57,940
with this record replay approach is what

00:33:55,419 --> 00:34:01,570
you tend to end up with our tests that

00:33:57,940 --> 00:34:04,990
are just you know they are not well

00:34:01,570 --> 00:34:09,159
factored because you have you know 20

00:34:04,990 --> 00:34:12,159
different tests for this particular page

00:34:09,159 --> 00:34:13,629
maybe and they all involve first doing

00:34:12,159 --> 00:34:15,639
one thing and then testing something

00:34:13,629 --> 00:34:18,490
else so they all have the same sort of

00:34:15,639 --> 00:34:22,300
setup that becomes part of that that

00:34:18,490 --> 00:34:24,990
script and when that original bit of

00:34:22,300 --> 00:34:27,909
setup changes somehow you know there are

00:34:24,990 --> 00:34:30,940
different drop-down options or something

00:34:27,909 --> 00:34:32,829
then all your 20 tests break and so I

00:34:30,940 --> 00:34:36,250
mean that can also happen with coded

00:34:32,829 --> 00:34:38,050
tests for sure and the solution to that

00:34:36,250 --> 00:34:42,990
is better facturing and to factor out

00:34:38,050 --> 00:34:46,510
there the the shed part of that code and

00:34:42,990 --> 00:34:52,619
not sure if the record replay tools have

00:34:46,510 --> 00:34:52,619
you no equivalent sort of functionality

00:34:52,980 --> 00:34:56,579

YouTube URL: https://www.youtube.com/watch?v=RLlEi6-8YBI


