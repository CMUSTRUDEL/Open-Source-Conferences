Title: Learning Parseltongue: Wizardry in Python
Publication date: 2013-07-10
Playlist: Pycon Australia 2013
Description: 
	Gaurav Dadhania
http://2013.pycon-au.org/schedule/30038/view_talk
A guide to metaprogramming & magic methods -- we will look at practical examples from open source software, understand common patterns and learn to yield such powerful constructs to our advantage, instead of fearing them. 
PyCon Australia is the national conference for users of the Python Programming Language. In July 2013, we're returning to Hobart, bringing together students, enthusiasts, and professionals with a love of Python
Captions: 
	00:00:00,030 --> 00:00:06,000
so our next presenter is one of my

00:00:02,850 --> 00:00:08,849
colleagues Grove Dania whose name I

00:00:06,000 --> 00:00:11,610
always mispronounce he works at common

00:00:08,849 --> 00:00:13,790
code in Melbourne and he thinks he

00:00:11,610 --> 00:00:16,020
speaks fluent Python and JavaScript

00:00:13,790 --> 00:00:18,660
today he's going to be teaching us about

00:00:16,020 --> 00:00:26,670
parcel time please wait please welcome

00:00:18,660 --> 00:00:27,689
Griff thank you hi everyone

00:00:26,670 --> 00:00:30,840
today we're going to be learning

00:00:27,689 --> 00:00:35,700
Parseltongue and we're gonna try and be

00:00:30,840 --> 00:00:38,100
wizards as any of you or Harry Potter

00:00:35,700 --> 00:00:40,050
fans would know Parseltongue is the

00:00:38,100 --> 00:00:43,800
language of serpents it goes something

00:00:40,050 --> 00:00:46,350
like something like that but

00:00:43,800 --> 00:00:49,260
unfortunately Wizards don't exist in our

00:00:46,350 --> 00:00:51,660
world and the language of serpents is

00:00:49,260 --> 00:00:54,180
kind of useless the considering Python

00:00:51,660 --> 00:00:57,180
is sort of a serpent will do cool stuff

00:00:54,180 --> 00:01:00,239
in Python so what we're gonna do today

00:00:57,180 --> 00:01:02,070
is learn about magic methods and a bit

00:01:00,239 --> 00:01:05,939
of introduction on meta programming in

00:01:02,070 --> 00:01:07,890
Python so what are magic methods they're

00:01:05,939 --> 00:01:10,320
usually surrounded by double underscores

00:01:07,890 --> 00:01:13,590
on both sides they're supposed to add a

00:01:10,320 --> 00:01:15,450
bit of magic into your classes they're

00:01:13,590 --> 00:01:17,549
not really really magical but there are

00:01:15,450 --> 00:01:19,110
still quite cool they're also sometimes

00:01:17,549 --> 00:01:21,630
called special methods because they

00:01:19,110 --> 00:01:25,290
allow you the programmer to add your own

00:01:21,630 --> 00:01:28,320
logic to how things work we definitely

00:01:25,290 --> 00:01:31,979
need to cover all of this so let's start

00:01:28,320 --> 00:01:36,360
with the basic magic methods new which

00:01:31,979 --> 00:01:38,299
is used for creating a new instance it's

00:01:36,360 --> 00:01:40,890
it's useful for when you're in a

00:01:38,299 --> 00:01:42,540
subclass immutable types and we'll see

00:01:40,890 --> 00:01:44,610
an example you know just a second and

00:01:42,540 --> 00:01:45,840
this is the first thing that Cole gets

00:01:44,610 --> 00:01:47,970
called when you create in like a new

00:01:45,840 --> 00:01:50,759
instance of a class the next thing that

00:01:47,970 --> 00:01:54,229
gets called typically is in it which is

00:01:50,759 --> 00:01:56,729
supposed to initialize your instance and

00:01:54,229 --> 00:01:58,590
it's similar to have new and init deal

00:01:56,729 --> 00:02:01,860
with constructing of your instances

00:01:58,590 --> 00:02:04,049
they'll bills with destruction and so

00:02:01,860 --> 00:02:06,869
you can clean things out usually using

00:02:04,049 --> 00:02:09,479
del so this is a simple example of using

00:02:06,869 --> 00:02:10,670
in it and L so are you just using a file

00:02:09,479 --> 00:02:13,520
object and you're wrapping

00:02:10,670 --> 00:02:15,560
your file keeping like a personal

00:02:13,520 --> 00:02:19,760
instance of the file and closing it when

00:02:15,560 --> 00:02:22,430
you get deleted now delete as you might

00:02:19,760 --> 00:02:25,160
seem good you might think that delete

00:02:22,430 --> 00:02:27,800
gets called when dehl of the instance is

00:02:25,160 --> 00:02:29,720
called but delay underscores Cordell is

00:02:27,800 --> 00:02:31,310
called when the instance is actually

00:02:29,720 --> 00:02:35,360
garbage collected so you need to be

00:02:31,310 --> 00:02:38,660
careful there you can also overload

00:02:35,360 --> 00:02:41,330
operators so make your custom objects

00:02:38,660 --> 00:02:43,880
behave like their native built-in types

00:02:41,330 --> 00:02:46,400
in Python so something like instance 1

00:02:43,880 --> 00:02:49,700
equals equals instance ooh instead of

00:02:46,400 --> 00:02:51,350
instance 1 dot equals instance 2 which

00:02:49,700 --> 00:02:54,799
allows you got to be more readable and

00:02:51,350 --> 00:02:58,790
beautiful so how do you overload

00:02:54,799 --> 00:03:02,060
operators there's pom which which deals

00:02:58,790 --> 00:03:03,920
with comparison of instances it's a

00:03:02,060 --> 00:03:06,290
method that you can define that returns

00:03:03,920 --> 00:03:08,630
a positive integer if the current

00:03:06,290 --> 00:03:10,610
instance is greater than if you want the

00:03:08,630 --> 00:03:11,959
current instance to be greater than the

00:03:10,610 --> 00:03:14,269
cup instance you're comparing it with

00:03:11,959 --> 00:03:16,310
return zero if you think it's gonna be

00:03:14,269 --> 00:03:18,560
equal and return a negative integer if

00:03:16,310 --> 00:03:20,989
you think it's less than this has been

00:03:18,560 --> 00:03:23,680
removed in Python 3 because it sounds

00:03:20,989 --> 00:03:26,390
confusing and so you can use the other

00:03:23,680 --> 00:03:29,150
I'm sorry this resolutions kind of

00:03:26,390 --> 00:03:33,200
curved but you can use the other magic

00:03:29,150 --> 00:03:35,150
methods to actually compare stuff as you

00:03:33,200 --> 00:03:36,680
can see equals not equals less than

00:03:35,150 --> 00:03:38,709
greater than less than or equal to or

00:03:36,680 --> 00:03:43,970
greater than equal to and they all

00:03:38,709 --> 00:03:45,680
overload corresponding operators now you

00:03:43,970 --> 00:03:47,390
don't actually need to define all of

00:03:45,680 --> 00:03:48,769
them you can just define underscore

00:03:47,390 --> 00:03:50,510
underscore equal and underscore

00:03:48,769 --> 00:03:54,410
underscore less than or greater than and

00:03:50,510 --> 00:03:56,329
then Python can figure out how things

00:03:54,410 --> 00:03:58,069
are working so you can use the total

00:03:56,329 --> 00:04:01,100
ordering decorator from func tools

00:03:58,069 --> 00:04:03,530
module to achieve the exact result in

00:04:01,100 --> 00:04:06,109
this example we're using word but we're

00:04:03,530 --> 00:04:07,790
changing its comparison operators so

00:04:06,109 --> 00:04:09,980
that we're actually comparing the length

00:04:07,790 --> 00:04:15,980
of words instead of the actual ASCII

00:04:09,980 --> 00:04:19,280
values you can also overload unary

00:04:15,980 --> 00:04:21,080
operators so you can overload all of

00:04:19,280 --> 00:04:22,900
these objects when the object is

00:04:21,080 --> 00:04:24,820
supposed to be positive negative

00:04:22,900 --> 00:04:28,330
absolute value the inverse of some

00:04:24,820 --> 00:04:30,190
objects so this is binary inversion you

00:04:28,330 --> 00:04:32,949
want a rounded floor it seal it or

00:04:30,190 --> 00:04:35,190
truncate the decimal values all of this

00:04:32,949 --> 00:04:38,669
you can define and you can have custom

00:04:35,190 --> 00:04:41,380
logic for any of these function calls

00:04:38,669 --> 00:04:43,960
then you can overload the arithmetic

00:04:41,380 --> 00:04:47,860
operators although all of them can be

00:04:43,960 --> 00:04:50,139
overloaded to your custom logic and it's

00:04:47,860 --> 00:04:52,840
just the list of these things that you

00:04:50,139 --> 00:04:56,590
can actually use to define your custom

00:04:52,840 --> 00:04:59,949
logic now reflected arithmetic operators

00:04:56,590 --> 00:05:02,260
let's say you use a custom arithmetic

00:04:59,949 --> 00:05:05,320
operator but the first object doesn't

00:05:02,260 --> 00:05:08,949
actually define the magic method for

00:05:05,320 --> 00:05:11,199
compare for that operator or it raises

00:05:08,949 --> 00:05:13,660
or not implemented exception then the

00:05:11,199 --> 00:05:17,289
other objects reflected arithmetic magic

00:05:13,660 --> 00:05:19,060
method gets called so our ad would get

00:05:17,289 --> 00:05:20,620
called if my object doesn't have an

00:05:19,060 --> 00:05:22,660
underscore underscore ad or its

00:05:20,620 --> 00:05:28,210
underscore underscore ad raises or non

00:05:22,660 --> 00:05:30,789
implemented method augmented assignment

00:05:28,210 --> 00:05:33,070
is just the operators that use the

00:05:30,789 --> 00:05:36,370
instance itself and you can use the list

00:05:33,070 --> 00:05:40,830
of these methods to actually provide

00:05:36,370 --> 00:05:43,210
custom logic for augmented assignment

00:05:40,830 --> 00:05:46,930
similarly there are methods for type

00:05:43,210 --> 00:05:49,240
conversion as well coerce is it's

00:05:46,930 --> 00:05:52,000
removed in Python 3 because it's kind of

00:05:49,240 --> 00:05:54,250
confusing it's used for when you are

00:05:52,000 --> 00:05:55,449
dealing with different instances and

00:05:54,250 --> 00:05:57,010
you're trying to coerce them while

00:05:55,449 --> 00:05:59,080
you're doing arithmetic operations on

00:05:57,010 --> 00:06:01,479
those instances everything else is

00:05:59,080 --> 00:06:05,770
pretty much self-explanatory so I'm

00:06:01,479 --> 00:06:09,580
gonna whiz through them representation

00:06:05,770 --> 00:06:12,130
is another thing where you can define

00:06:09,580 --> 00:06:15,460
how the representation of your instance

00:06:12,130 --> 00:06:17,260
is gonna be bit of a difference between

00:06:15,460 --> 00:06:20,639
underscore underscore STR and underscore

00:06:17,260 --> 00:06:24,250
underscore re PR e our representation is

00:06:20,639 --> 00:06:27,620
re PR is intended for machines whereas

00:06:24,250 --> 00:06:31,880
STR is intended for Unicode

00:06:27,620 --> 00:06:33,380
sighs off and there that there you

00:06:31,880 --> 00:06:38,840
should only be concerned with dementia

00:06:33,380 --> 00:06:41,800
writing C extensions attribute access

00:06:38,840 --> 00:06:45,740
this is where things get really good

00:06:41,800 --> 00:06:47,990
this get adder get attribute it's called

00:06:45,740 --> 00:06:49,220
when the attribute doesn't exist and so

00:06:47,990 --> 00:06:51,229
you can do fun stuff with it

00:06:49,220 --> 00:06:53,780
attribute is called whenever you want to

00:06:51,229 --> 00:06:55,639
set an attribute on the instance delete

00:06:53,780 --> 00:06:58,910
attribute similarly is called when dehl

00:06:55,639 --> 00:07:01,070
is called on the attribute get attribute

00:06:58,910 --> 00:07:03,169
is for knows new style classes where

00:07:01,070 --> 00:07:04,340
it's called regardless of whether the

00:07:03,169 --> 00:07:06,500
attribute exists or not

00:07:04,340 --> 00:07:09,199
so if you want to handle any attribute

00:07:06,500 --> 00:07:11,750
access then you can override the get

00:07:09,199 --> 00:07:13,760
attribute method now you have to be

00:07:11,750 --> 00:07:17,389
careful when using get attribute because

00:07:13,760 --> 00:07:19,490
things can get tricky it can cause

00:07:17,389 --> 00:07:21,770
infinite recursion like this self dot

00:07:19,490 --> 00:07:24,410
name equals value but that self dot name

00:07:21,770 --> 00:07:28,840
will again called set attribute so it's

00:07:24,410 --> 00:07:28,840
just gonna keep on recursing infinitely

00:07:29,500 --> 00:07:34,940
and we can call we can negate that by

00:07:32,840 --> 00:07:36,500
just not setting the attribute on the

00:07:34,940 --> 00:07:39,130
instance itself which is changing a

00:07:36,500 --> 00:07:44,870
value of one of its in one of its

00:07:39,130 --> 00:07:46,720
attributes to make custom sequences you

00:07:44,870 --> 00:07:50,570
need to follow a certain protocol

00:07:46,720 --> 00:07:52,789
protocol in Python it seems a bit like

00:07:50,570 --> 00:07:54,919
an interface so to make an immutable

00:07:52,789 --> 00:07:57,289
container you need to define length and

00:07:54,919 --> 00:07:59,270
get item to make a mutable container you

00:07:57,289 --> 00:08:02,599
need to define set item and delete item

00:07:59,270 --> 00:08:04,190
in in addition to length and get item to

00:08:02,599 --> 00:08:07,849
make the container iterable you need to

00:08:04,190 --> 00:08:10,130
define underscore underscore ITER which

00:08:07,849 --> 00:08:11,660
which and the iterator itself you can

00:08:10,130 --> 00:08:13,520
define a custom iterator which should

00:08:11,660 --> 00:08:17,380
return itself when underscore underscore

00:08:13,520 --> 00:08:19,880
ITER is called and defined a next method

00:08:17,380 --> 00:08:22,310
python protocols are quite informal and

00:08:19,880 --> 00:08:23,810
there's no explicit declarations for

00:08:22,310 --> 00:08:28,280
something to be a protocol it's just a

00:08:23,810 --> 00:08:29,900
convention so these are the magic

00:08:28,280 --> 00:08:34,690
methods that you can use to create

00:08:29,900 --> 00:08:37,550
custom containers like strings or types

00:08:34,690 --> 00:08:38,959
here you should take proper care that

00:08:37,550 --> 00:08:40,030
you're raising the proper exceptions

00:08:38,959 --> 00:08:41,860
like

00:08:40,030 --> 00:08:43,960
kierra should be used when the key is

00:08:41,860 --> 00:08:45,970
missing and needed and type error should

00:08:43,960 --> 00:08:50,200
be used when the key is not compatible

00:08:45,970 --> 00:08:52,360
with your instance type you can also use

00:08:50,200 --> 00:08:54,670
magic magic methods to override the

00:08:52,360 --> 00:08:57,040
default method for reflection so you can

00:08:54,670 --> 00:09:00,670
write instance check and subclass check

00:08:57,040 --> 00:09:02,170
to override the however your instances

00:09:00,670 --> 00:09:06,760
are checked and however your subclasses

00:09:02,170 --> 00:09:08,950
are check gullible objects functions are

00:09:06,760 --> 00:09:10,810
our first class objects in Python so

00:09:08,950 --> 00:09:12,610
your classes can also be called and

00:09:10,810 --> 00:09:15,400
passed in arguments so you can override

00:09:12,610 --> 00:09:17,530
underscore underscore call and whenever

00:09:15,400 --> 00:09:19,540
the instance is called with any

00:09:17,530 --> 00:09:22,360
arguments it will go to call and you can

00:09:19,540 --> 00:09:27,460
provide your any any statefulness

00:09:22,360 --> 00:09:29,920
or any logic in their context managers

00:09:27,460 --> 00:09:32,740
allow they're used for a pattern where

00:09:29,920 --> 00:09:36,160
you need definite steps or for setup and

00:09:32,740 --> 00:09:38,890
definite steps for cleaning up they're

00:09:36,160 --> 00:09:41,560
usually used in which statement in

00:09:38,890 --> 00:09:43,930
Python so you can define enter and exit

00:09:41,560 --> 00:09:45,340
magic methods for when the block the

00:09:43,930 --> 00:09:49,390
width block starts and when the weak

00:09:45,340 --> 00:09:50,860
which block exists in exit you need to

00:09:49,390 --> 00:09:52,480
take care of that if you're handling any

00:09:50,860 --> 00:09:54,850
exceptions you need to return true

00:09:52,480 --> 00:10:01,330
otherwise we could just do general

00:09:54,850 --> 00:10:03,160
cleanup so this is a example of context

00:10:01,330 --> 00:10:04,900
manager where we're just closing

00:10:03,160 --> 00:10:07,750
connections so while when we're entering

00:10:04,900 --> 00:10:09,990
the context we're just returning the

00:10:07,750 --> 00:10:12,970
object but if it's more specific you can

00:10:09,990 --> 00:10:14,860
actually create a new instance of the

00:10:12,970 --> 00:10:16,450
connection and enter and in on exit

00:10:14,860 --> 00:10:19,150
we're trying to close the objects

00:10:16,450 --> 00:10:22,720
connection and if if we're handling and

00:10:19,150 --> 00:10:25,390
exceptionally if it arises you can see

00:10:22,720 --> 00:10:28,530
that if the if we're handling the

00:10:25,390 --> 00:10:31,930
exception we're returning true

00:10:28,530 --> 00:10:33,760
you can also override magic methods for

00:10:31,930 --> 00:10:37,090
descriptor objects so here we're using

00:10:33,760 --> 00:10:39,070
two descriptors for mirror and foot and

00:10:37,090 --> 00:10:44,890
we're using get and set methods to set

00:10:39,070 --> 00:10:47,760
and get the values Python also provides

00:10:44,890 --> 00:10:50,290
copy and deep copy to provide your own

00:10:47,760 --> 00:10:51,640
custom logic for copying objects and

00:10:50,290 --> 00:10:53,380
deep copy

00:10:51,640 --> 00:10:55,810
copying objects the difference being

00:10:53,380 --> 00:10:58,000
copy and deep copies and copy it's just

00:10:55,810 --> 00:10:59,680
a shallow copy so your data might just

00:10:58,000 --> 00:11:01,360
be references whereas in deep copy it

00:10:59,680 --> 00:11:03,100
actually goes through your entire data

00:11:01,360 --> 00:11:05,709
structure and actually copies values

00:11:03,100 --> 00:11:10,060
around instead of just references deep

00:11:05,709 --> 00:11:12,459
copy only quite memory and CPU intensive

00:11:10,060 --> 00:11:14,890
so it has a memo deck that you need to

00:11:12,459 --> 00:11:16,149
use to see what nodes of your data

00:11:14,890 --> 00:11:17,700
structure you've actually visited

00:11:16,149 --> 00:11:20,680
previously so you're not actually

00:11:17,700 --> 00:11:25,000
recursing infinitely while you're

00:11:20,680 --> 00:11:26,709
copying your data structure pickling is

00:11:25,000 --> 00:11:29,440
serialization for the Python data

00:11:26,709 --> 00:11:31,990
structures so they can be stored and

00:11:29,440 --> 00:11:35,079
retrieved later the data you can also

00:11:31,990 --> 00:11:37,269
use these magic methods to actually see

00:11:35,079 --> 00:11:41,620
how your object is pickled and how it

00:11:37,269 --> 00:11:44,320
gets stored this is an example where

00:11:41,620 --> 00:11:48,940
we're actually customizing how the

00:11:44,320 --> 00:11:51,160
object gets pickle so we're just storing

00:11:48,940 --> 00:11:54,339
the value and the last change and then

00:11:51,160 --> 00:11:56,769
the history dick just keeps a record of

00:11:54,339 --> 00:11:59,380
when the value has changed and what it

00:11:56,769 --> 00:12:01,449
was changed to but so whenever we're

00:11:59,380 --> 00:12:03,820
getting state we're just returning that

00:12:01,449 --> 00:12:05,380
history dictionary and whenever is

00:12:03,820 --> 00:12:07,570
setting stage so whenever it's on

00:12:05,380 --> 00:12:09,370
pickled we're saying keep the history

00:12:07,570 --> 00:12:11,680
but the value in the last change are set

00:12:09,370 --> 00:12:14,050
to none so after it gets pickled and

00:12:11,680 --> 00:12:15,399
then on pickled the slate is clean the

00:12:14,050 --> 00:12:17,019
current value will be none but you'll

00:12:15,399 --> 00:12:21,490
still have the history of what the

00:12:17,019 --> 00:12:23,500
values were abstract base classes also

00:12:21,490 --> 00:12:25,870
use the underscore underscore subclass

00:12:23,500 --> 00:12:28,779
hook magic method that you can use to

00:12:25,870 --> 00:12:31,240
see if the current an instance of the

00:12:28,779 --> 00:12:36,010
class is actually a subclass of that

00:12:31,240 --> 00:12:38,050
abstract base class but wait there's

00:12:36,010 --> 00:12:41,320
more we're gonna go into many

00:12:38,050 --> 00:12:43,480
programming many programming is quite a

00:12:41,320 --> 00:12:46,089
general term but what we're gonna do

00:12:43,480 --> 00:12:48,610
right now is understand meta programming

00:12:46,089 --> 00:12:52,750
as programs that manipulate other

00:12:48,610 --> 00:12:54,699
programs so think of it as if a person

00:12:52,750 --> 00:12:57,100
is building a car he's actually doing

00:12:54,699 --> 00:12:57,550
manual work but if he's building of he's

00:12:57,100 --> 00:12:59,529
writing

00:12:57,550 --> 00:13:00,560
he's building a factory to build cars

00:12:59,529 --> 00:13:02,540
then he's sort of

00:13:00,560 --> 00:13:04,490
programming and if he's building a

00:13:02,540 --> 00:13:08,660
factory that builds factories to build

00:13:04,490 --> 00:13:11,269
cars he's made our programming classes

00:13:08,660 --> 00:13:14,990
invitin are just objects so you can add

00:13:11,269 --> 00:13:18,160
a field and add methods and it will be

00:13:14,990 --> 00:13:20,990
passed on to any instance of that class

00:13:18,160 --> 00:13:25,189
you can modify them however however you

00:13:20,990 --> 00:13:27,110
can modify objects in Python you can add

00:13:25,189 --> 00:13:29,899
fields you can subtract fields the

00:13:27,110 --> 00:13:32,209
difference is all of the objects of that

00:13:29,899 --> 00:13:34,550
class will even even the ones that have

00:13:32,209 --> 00:13:38,029
been instantiated we'll be getting those

00:13:34,550 --> 00:13:40,790
values what creates these special class

00:13:38,029 --> 00:13:43,309
objects like classes create instances

00:13:40,790 --> 00:13:46,069
but what creates classes these are some

00:13:43,309 --> 00:13:47,899
special objects called meta classes the

00:13:46,069 --> 00:13:53,209
default meta class is something called

00:13:47,899 --> 00:13:55,610
type classes create instances so class

00:13:53,209 --> 00:13:59,540
seabass is similar to calling type on

00:13:55,610 --> 00:14:01,730
sea with no no classes that it actually

00:13:59,540 --> 00:14:04,610
inherits from and an empty dictionary of

00:14:01,730 --> 00:14:06,980
attributes so you can dynamically create

00:14:04,610 --> 00:14:09,199
classes by calling type and the name of

00:14:06,980 --> 00:14:12,230
the class give it a base class of list

00:14:09,199 --> 00:14:15,709
and a dictionary of an attribute 42 and

00:14:12,230 --> 00:14:17,449
a function howdy this class can then

00:14:15,709 --> 00:14:20,269
create we can create an instance of this

00:14:17,449 --> 00:14:22,240
class and you can see how every

00:14:20,269 --> 00:14:25,490
attribute is still there it's still

00:14:22,240 --> 00:14:30,079
inheriting from list and we just created

00:14:25,490 --> 00:14:34,850
a class dynamically meta classes can be

00:14:30,079 --> 00:14:37,670
used to create classes so meta class is

00:14:34,850 --> 00:14:39,410
just another callable on the class but

00:14:37,670 --> 00:14:41,089
it should and it should accept the same

00:14:39,410 --> 00:14:43,579
arguments as type but it's used to

00:14:41,089 --> 00:14:46,759
create classes by by convention

00:14:43,579 --> 00:14:50,300
metaclasses the first argument is always

00:14:46,759 --> 00:14:53,509
the class value however like you can see

00:14:50,300 --> 00:14:56,540
in in classes our methods usually get

00:14:53,509 --> 00:14:58,610
the first argument of the instance main

00:14:56,540 --> 00:15:01,939
metaclasses our first argument is the

00:14:58,610 --> 00:15:04,220
class the actual class except underscore

00:15:01,939 --> 00:15:09,230
underscore you knew whose first first

00:15:04,220 --> 00:15:10,910
argument is the meta class so because

00:15:09,230 --> 00:15:13,220
meta class is just a callable you can

00:15:10,910 --> 00:15:13,880
define it as a class or or as a function

00:15:13,220 --> 00:15:17,390
within

00:15:13,880 --> 00:15:20,900
within your class this is an example of

00:15:17,390 --> 00:15:22,910
where we're using a middle class what

00:15:20,900 --> 00:15:25,130
it's doing is when when it's

00:15:22,910 --> 00:15:27,950
initializing the class it's seeing if

00:15:25,130 --> 00:15:30,440
the class is in if the class has an

00:15:27,950 --> 00:15:32,660
attribute registry if it doesn't then it

00:15:30,440 --> 00:15:36,920
adds the class to the class's registry

00:15:32,660 --> 00:15:38,930
and then when when Str of that class

00:15:36,920 --> 00:15:41,210
would be called it will return the class

00:15:38,930 --> 00:15:46,970
name followed by all of the all of the

00:15:41,210 --> 00:15:48,770
sub classes that are in its registry you

00:15:46,970 --> 00:15:50,990
can also create classes that are final

00:15:48,770 --> 00:15:55,130
so in this case when the class gets

00:15:50,990 --> 00:15:57,410
initialized you're seeing that if if the

00:15:55,130 --> 00:16:01,670
class that's getting initialized is an

00:15:57,410 --> 00:16:04,730
instance of the class in its basis then

00:16:01,670 --> 00:16:08,060
we're not allowing it so if you define

00:16:04,730 --> 00:16:10,070
one class with this meta class no other

00:16:08,060 --> 00:16:14,690
class will be able to inherit from that

00:16:10,070 --> 00:16:17,660
class so when we're dealing with meta

00:16:14,690 --> 00:16:19,520
classes it's quite confusing when to use

00:16:17,660 --> 00:16:22,520
underscore underscore new and when to

00:16:19,520 --> 00:16:24,380
use underscore underscore in it while

00:16:22,520 --> 00:16:28,070
when you're using underscore underscore

00:16:24,380 --> 00:16:30,530
new you can change the names the basis

00:16:28,070 --> 00:16:32,510
the namespace of the class that's going

00:16:30,530 --> 00:16:35,060
to be initialized but when you're using

00:16:32,510 --> 00:16:36,530
our discordance in it you can't a new

00:16:35,060 --> 00:16:38,780
you have an instance of the metaclass

00:16:36,530 --> 00:16:39,530
that you get the class isn't actually

00:16:38,780 --> 00:16:41,330
initialized

00:16:39,530 --> 00:16:42,950
whereas an init the class has already

00:16:41,330 --> 00:16:47,600
been initialized and you're doing all of

00:16:42,950 --> 00:16:49,100
the initialization work so a meta method

00:16:47,600 --> 00:16:51,200
can be called from either the meta class

00:16:49,100 --> 00:16:54,250
or from the class and an instance method

00:16:51,200 --> 00:16:57,920
can be called from class or an instance

00:16:54,250 --> 00:17:00,800
this is an example of a singleton so

00:16:57,920 --> 00:17:03,320
we're writing a meta method call and

00:17:00,800 --> 00:17:07,550
it's just saying that if instance is

00:17:03,320 --> 00:17:08,900
defined we call it we create if instance

00:17:07,550 --> 00:17:11,000
is not defined we're creating an

00:17:08,900 --> 00:17:12,980
instance otherwise we're just returning

00:17:11,000 --> 00:17:18,650
that instance so only one instance of

00:17:12,980 --> 00:17:20,420
that class will ever get created there's

00:17:18,650 --> 00:17:22,730
also the underscore underscore prepare

00:17:20,420 --> 00:17:24,750
meta meta method that you can use to

00:17:22,730 --> 00:17:28,710
override the dictionary the

00:17:24,750 --> 00:17:31,440
the underscore underscore date attribute

00:17:28,710 --> 00:17:33,960
of a class to something custom so you

00:17:31,440 --> 00:17:35,760
can use for example this where we're

00:17:33,960 --> 00:17:38,370
using an ordered dictionary instead of a

00:17:35,760 --> 00:17:42,200
dictionary so you can define any object

00:17:38,370 --> 00:17:44,760
there that has a set method magic method

00:17:42,200 --> 00:17:46,860
so you're probably thinking this is

00:17:44,760 --> 00:17:49,620
quite cool and Python provides all of

00:17:46,860 --> 00:17:51,960
these things for me but what should I

00:17:49,620 --> 00:17:54,030
actually do with them and so I advise

00:17:51,960 --> 00:17:55,559
you to use the magic like Python

00:17:54,030 --> 00:17:57,510
actually provides all of these things

00:17:55,559 --> 00:17:59,429
and they're actually quite helpful

00:17:57,510 --> 00:18:00,990
it'll make sure that your code is more

00:17:59,429 --> 00:18:04,440
readable it'll make sure that your code

00:18:00,990 --> 00:18:07,679
is actually quite clean but then there's

00:18:04,440 --> 00:18:09,419
the downside of it'll actually be quite

00:18:07,679 --> 00:18:10,919
confusing to someone who's looking at

00:18:09,419 --> 00:18:12,419
your code for the first time to figure

00:18:10,919 --> 00:18:15,090
out how it's working if you're using a

00:18:12,419 --> 00:18:17,429
lot of these features so I suggest you

00:18:15,090 --> 00:18:20,880
have a nice balance of when you're using

00:18:17,429 --> 00:18:23,179
these techniques and whatnot and that's

00:18:20,880 --> 00:18:23,179
about it

00:18:31,170 --> 00:18:44,310
thanks keV did anyone have any questions

00:18:34,720 --> 00:18:48,130
about metaprogramming of the back yeah

00:18:44,310 --> 00:18:51,430
sweet I'll probably do eat out a link to

00:18:48,130 --> 00:19:00,730
my slides so that should we that's the

00:18:51,430 --> 00:19:03,730
URL I so it's sli d es / GV RV where

00:19:00,730 --> 00:19:06,270
everyone can probably read that any

00:19:03,730 --> 00:19:06,270
other questions

00:19:11,060 --> 00:19:16,760
why so with the metaclass programming is

00:19:14,990 --> 00:19:21,080
it I mean one example where that's used

00:19:16,760 --> 00:19:22,370
in is Django with them setting up models

00:19:21,080 --> 00:19:26,390
and I just thought it'd be interesting

00:19:22,370 --> 00:19:28,460
to see if there's any guidelines or

00:19:26,390 --> 00:19:30,680
examples of where meta programs being

00:19:28,460 --> 00:19:34,010
useful for you or you know existing

00:19:30,680 --> 00:19:36,410
projects where that's been used there's

00:19:34,010 --> 00:19:38,330
one library that I've personally read

00:19:36,410 --> 00:19:42,940
the source loft that actually uses it

00:19:38,330 --> 00:19:45,500
it's called django SEO where it uses

00:19:42,940 --> 00:19:49,250
metaclasses to actually create glass

00:19:45,500 --> 00:19:50,900
instances for the different data items

00:19:49,250 --> 00:19:52,990
whose meta information you want to

00:19:50,900 --> 00:19:57,230
generate so let's say you've got

00:19:52,990 --> 00:19:59,150
products and stores and people it

00:19:57,230 --> 00:20:02,030
actually dynamically generates classes

00:19:59,150 --> 00:20:05,210
for like product meta store meta people

00:20:02,030 --> 00:20:06,860
meta to track the meta information for

00:20:05,210 --> 00:20:09,500
it so if you look at the source for

00:20:06,860 --> 00:20:14,120
django SEO that would be a good good way

00:20:09,500 --> 00:20:18,050
to find out we've got another question

00:20:14,120 --> 00:20:19,310
up the back here hi i'm i was first

00:20:18,050 --> 00:20:21,620
introduced i guess to meta programming

00:20:19,310 --> 00:20:24,440
at PyCon last year where someone

00:20:21,620 --> 00:20:26,900
demonstrated to me how to create a meta

00:20:24,440 --> 00:20:29,900
class to create an abstract base class

00:20:26,900 --> 00:20:32,210
the behave the way I expected from C++ I

00:20:29,900 --> 00:20:34,340
was intrigued if is there anything that

00:20:32,210 --> 00:20:36,020
leaps to mind is particularly like

00:20:34,340 --> 00:20:37,880
useful or made a class that you wrote

00:20:36,020 --> 00:20:39,140
that your I guess really pleased with or

00:20:37,880 --> 00:20:41,630
fan would find really useful for

00:20:39,140 --> 00:20:43,850
yourself personally I'm sorry is that

00:20:41,630 --> 00:20:45,140
you're looking at like practical

00:20:43,850 --> 00:20:48,260
applications of metaclasses

00:20:45,140 --> 00:20:50,120
oh yeah a practical example you how you

00:20:48,260 --> 00:20:54,140
used I guess the power of metaclass

00:20:50,120 --> 00:20:57,350
programming figure are in benefit so I I

00:20:54,140 --> 00:20:59,450
think there's some things that you can

00:20:57,350 --> 00:21:02,000
do with better classes that you can't

00:20:59,450 --> 00:21:04,880
natively do so like we looked at

00:21:02,000 --> 00:21:07,280
examples of creating a singleton and

00:21:04,880 --> 00:21:09,770
creating final classes which is not

00:21:07,280 --> 00:21:14,030
something that's built-in but you can

00:21:09,770 --> 00:21:16,520
still do that using this so I I just say

00:21:14,030 --> 00:21:19,340
experiment I guess if you're getting

00:21:16,520 --> 00:21:21,650
stuck somewhere and just try it this is

00:21:19,340 --> 00:21:23,389
more about Python providing that useful

00:21:21,650 --> 00:21:25,969
functionality so if you need

00:21:23,389 --> 00:21:28,190
you can do it but most of us in our day

00:21:25,969 --> 00:21:34,009
jobs we're just concatenate in strings

00:21:28,190 --> 00:21:38,719
so thanks Karev was there any other

00:21:34,009 --> 00:21:40,669
questions looks like that's it guys just

00:21:38,719 --> 00:21:43,399
remember that you need to pick up your

00:21:40,669 --> 00:21:44,539
dinner ticket if you're going to the

00:21:43,399 --> 00:21:45,919
dinner tonight otherwise you won't be

00:21:44,539 --> 00:21:48,529
able to get in so you have to do that at

00:21:45,919 --> 00:21:50,389
the swag desk and that's the last tour

00:21:48,529 --> 00:21:52,729
in here so afternoon tea is gonna be

00:21:50,389 --> 00:21:55,039
served out in the foyer here if you

00:21:52,729 --> 00:21:57,440
could just leave fairly quietly oh we

00:21:55,039 --> 00:21:58,190
forgot again we have some coffee beans

00:21:57,440 --> 00:22:01,579
in a coffee mug

00:21:58,190 --> 00:22:04,159
thanks to ritual coffee and the pie that

00:22:01,579 --> 00:22:06,399
parkland organizes for Grove and thanks

00:22:04,159 --> 00:22:06,399

YouTube URL: https://www.youtube.com/watch?v=7cuQEOP7BsA


