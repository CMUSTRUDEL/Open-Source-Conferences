Title: Limiting Execution Time Through Interrupt Driven Programming
Publication date: 2013-07-10
Playlist: Pycon Australia 2013
Description: 
	Erik van Zijst
http://2013.pycon-au.org/schedule/30061/view_talk
This talk explores the challenges of ensuring responsiveness of applications under varying conditions like suddenly increased load, code regressions and problematic user data that reveal code paths with unusually high time complexity.

I'll be looking at interrupt-driven techniques to help bring the 95 percentile of the response times of your application closer to the (usually much lower) mean.

In this talk, we'll go beyond tr
Captions: 
	00:00:00,000 --> 00:00:05,520
senior developer on the bit bucket team

00:00:02,399 --> 00:00:08,099
atlassian focusing mostly on the server

00:00:05,520 --> 00:00:09,960
side stack he has a special interest for

00:00:08,099 --> 00:00:12,630
performance elegant algorithms and

00:00:09,960 --> 00:00:14,610
operating systems to explain interrupt

00:00:12,630 --> 00:00:22,800
driven development to us please welcome

00:00:14,610 --> 00:00:26,279
Erik van zest thank you alright so yeah

00:00:22,800 --> 00:00:28,109
I'm Eric I worked out less en work on

00:00:26,279 --> 00:00:31,740
bitbucket and for those who don't know a

00:00:28,109 --> 00:00:34,170
bit bucket is a free code hosting site

00:00:31,740 --> 00:00:37,170
for guinea mercurial private and public

00:00:34,170 --> 00:00:40,410
repos and today I want to talk about the

00:00:37,170 --> 00:00:41,700
importance of responsive web apps not

00:00:40,410 --> 00:00:43,170
specifically web apps but I'm going to

00:00:41,700 --> 00:00:44,850
talk about the from that from the

00:00:43,170 --> 00:00:48,149
background in context of my work which

00:00:44,850 --> 00:00:49,879
still web apps but the so the examples

00:00:48,149 --> 00:00:52,230
i'm going to use will be from bitbucket

00:00:49,879 --> 00:00:55,110
but um like the techniques are going to

00:00:52,230 --> 00:00:58,320
talk about apply equally well to tune on

00:00:55,110 --> 00:01:01,199
web apps I want to start off with this

00:00:58,320 --> 00:01:04,049
tweet which showed up on my timeline

00:01:01,199 --> 00:01:06,060
recently which seems to suggest that we

00:01:04,049 --> 00:01:10,350
are significantly slower than the

00:01:06,060 --> 00:01:12,600
competition which took me by surprise in

00:01:10,350 --> 00:01:13,979
this is a tweet so obviously there's no

00:01:12,600 --> 00:01:16,350
contacts there's no detail there's

00:01:13,979 --> 00:01:18,960
nothing at all to substantiate what this

00:01:16,350 --> 00:01:20,490
this appears to claim but at the same

00:01:18,960 --> 00:01:21,630
time I'm sure that Stephen wasn't making

00:01:20,490 --> 00:01:26,610
this up and he was actually measuring

00:01:21,630 --> 00:01:28,860
something so I quickly went over to our

00:01:26,610 --> 00:01:30,299
our performance dashboard you can see

00:01:28,860 --> 00:01:32,939
that the top there it's that's that's

00:01:30,299 --> 00:01:34,200
bitbucket and for that entire week I

00:01:32,939 --> 00:01:36,119
looked at our average response times

00:01:34,200 --> 00:01:38,790
yeah as you can see for that week or

00:01:36,119 --> 00:01:42,240
every response time was 123 milliseconds

00:01:38,790 --> 00:01:44,570
on the server then I opted over to the

00:01:42,240 --> 00:01:46,950
to github looked at their publicly

00:01:44,570 --> 00:01:50,250
published numbers and for that same week

00:01:46,950 --> 00:01:51,720
they claimed 139 milliseconds and so you

00:01:50,250 --> 00:01:54,420
know that's nearest makes no difference

00:01:51,720 --> 00:01:56,640
equal so there's nothing in here either

00:01:54,420 --> 00:01:59,790
to suggest that you know we are so much

00:01:56,640 --> 00:02:00,990
slower so had a closer look and I

00:01:59,790 --> 00:02:02,640
discovered it Stephen works for a

00:02:00,990 --> 00:02:04,759
company that writes a product that

00:02:02,640 --> 00:02:08,459
integrates with both these services in

00:02:04,759 --> 00:02:10,830
on our end they rely on a small number

00:02:08,459 --> 00:02:13,489
of AP is one of which admittedly is

00:02:10,830 --> 00:02:17,010
indeed very slow

00:02:13,489 --> 00:02:19,290
now luckily the that API endpoint

00:02:17,010 --> 00:02:21,569
doesn't get a lot of traffic and maybe

00:02:19,290 --> 00:02:23,879
that's that's that's not actually not so

00:02:21,569 --> 00:02:24,959
lucky but as a result the the poor

00:02:23,879 --> 00:02:26,599
performance doesn't really have much of

00:02:24,959 --> 00:02:29,879
an effect on our average response time

00:02:26,599 --> 00:02:31,409
so what he was seeing was real but it

00:02:29,879 --> 00:02:36,480
wasn't really representative for our

00:02:31,409 --> 00:02:39,060
service but unfortunately it is those

00:02:36,480 --> 00:02:40,829
like that small number of like that

00:02:39,060 --> 00:02:43,049
small portion of really slow requests

00:02:40,829 --> 00:02:45,780
that make in some ways have the biggest

00:02:43,049 --> 00:02:47,489
effect on the usability of your site you

00:02:45,780 --> 00:02:51,359
know your average may say that you know

00:02:47,489 --> 00:02:53,639
you're doing well but um you know let's

00:02:51,359 --> 00:02:55,290
it's it's a slow request that get people

00:02:53,639 --> 00:02:56,549
in trouble like those are the ones that

00:02:55,290 --> 00:02:57,900
break pages those are the ones that

00:02:56,549 --> 00:03:00,599
break integrations with external

00:02:57,900 --> 00:03:05,099
applications and public evidently get

00:03:00,599 --> 00:03:07,680
people to rent about it on Twitter so it

00:03:05,099 --> 00:03:09,689
goes to show that average numbers when

00:03:07,680 --> 00:03:13,530
it comes to response times are a really

00:03:09,689 --> 00:03:15,180
misleading it's a it's not the fast

00:03:13,530 --> 00:03:16,590
request that people complain about but

00:03:15,180 --> 00:03:18,510
for every couple of fast requests you've

00:03:16,590 --> 00:03:21,209
got a really slow request those are the

00:03:18,510 --> 00:03:22,650
ones that break things so it's a it

00:03:21,209 --> 00:03:24,510
gives you a full sense of accomplishment

00:03:22,650 --> 00:03:26,760
I guess looking at those average numbers

00:03:24,510 --> 00:03:28,829
it's a little bit like you know looking

00:03:26,760 --> 00:03:30,599
at the rainbow and saying well the

00:03:28,829 --> 00:03:34,260
average color of the rainbow is is

00:03:30,599 --> 00:03:35,400
whitish which may be true but it's a

00:03:34,260 --> 00:03:39,180
pretty pointless way of looking at a

00:03:35,400 --> 00:03:40,709
rainbow in it's similar with with slow

00:03:39,180 --> 00:03:41,849
requests they have the biggest effect on

00:03:40,709 --> 00:03:43,979
your site so you should be looking at

00:03:41,849 --> 00:03:48,540
those forget the average look at 98

00:03:43,979 --> 00:03:50,220
percentile maybe even 99 percentile in

00:03:48,540 --> 00:03:52,829
fact it's even worse like some requests

00:03:50,220 --> 00:03:54,629
literally run forever like if they're

00:03:52,829 --> 00:03:56,430
stuck in a infinite loop or in a

00:03:54,629 --> 00:03:57,510
deadlock then they're never going to

00:03:56,430 --> 00:03:58,620
break out of that where maybe they're

00:03:57,510 --> 00:04:00,510
doing is to bend this number of

00:03:58,620 --> 00:04:02,099
redundant database queries which by the

00:04:00,510 --> 00:04:05,010
way is a very common problem on database

00:04:02,099 --> 00:04:06,870
driven applications every time you hit

00:04:05,010 --> 00:04:09,239
one of those they take out one of your

00:04:06,870 --> 00:04:11,129
threads on your web server or your

00:04:09,239 --> 00:04:13,229
worker processes on your web server in

00:04:11,129 --> 00:04:15,239
after a while you will have nothing left

00:04:13,229 --> 00:04:16,919
to serve as other requests and you've

00:04:15,239 --> 00:04:20,880
basically you know you got a dose on

00:04:16,919 --> 00:04:22,800
your site but to prevent this scenario

00:04:20,880 --> 00:04:24,659
of do many web servers or some web

00:04:22,800 --> 00:04:25,860
service has a built-in failsafe like a

00:04:24,659 --> 00:04:27,689
watchdog

00:04:25,860 --> 00:04:29,759
that monitor long runner requests

00:04:27,689 --> 00:04:31,469
whenever they exceed in certain time out

00:04:29,759 --> 00:04:34,289
they kill those requests to prevent you

00:04:31,469 --> 00:04:36,240
know dose now we run Gunny corn get the

00:04:34,289 --> 00:04:38,729
Gunny corn sink worker which comes with

00:04:36,240 --> 00:04:40,789
it like a default 30-second timeout

00:04:38,729 --> 00:04:43,860
after 30 seconds if a request hasn't

00:04:40,789 --> 00:04:46,770
returned yet it heart kills that worker

00:04:43,860 --> 00:04:48,330
process in it does it by sending a kill

00:04:46,770 --> 00:04:51,360
signal which is equivalent to type and

00:04:48,330 --> 00:04:52,740
killed at nine it's a signal that you

00:04:51,360 --> 00:04:54,719
can't catch your ignore in your

00:04:52,740 --> 00:04:56,819
application can even detect it and so it

00:04:54,719 --> 00:04:58,830
always works which is very good of

00:04:56,819 --> 00:05:01,379
course if you use it for a fail-safe but

00:04:58,830 --> 00:05:04,860
it has a consequence that the program

00:05:01,379 --> 00:05:07,349
being killed has no no no ability to log

00:05:04,860 --> 00:05:09,180
any useful information in so in our case

00:05:07,349 --> 00:05:11,460
you know we don't even know these things

00:05:09,180 --> 00:05:12,689
happen because we don't log the the time

00:05:11,460 --> 00:05:14,789
it takes to run these things we don't

00:05:12,689 --> 00:05:16,189
know what they were stuck on so we have

00:05:14,789 --> 00:05:19,289
very little to go on to fix these things

00:05:16,189 --> 00:05:23,340
but they are the most important queries

00:05:19,289 --> 00:05:25,740
or requests on our site so we needed a

00:05:23,340 --> 00:05:27,960
way to make these things visible the

00:05:25,740 --> 00:05:28,979
very least so we know that they occur we

00:05:27,960 --> 00:05:30,300
know what they were doing what they're

00:05:28,979 --> 00:05:33,690
stuck on and then we can do something

00:05:30,300 --> 00:05:37,710
about him so we did was we we experiment

00:05:33,690 --> 00:05:40,080
with a an alarm signal handler we did

00:05:37,710 --> 00:05:42,839
was a at the start of every request we

00:05:40,080 --> 00:05:45,060
started an alarm signal for 28 seconds

00:05:42,839 --> 00:05:47,729
and then on the on the way out we

00:05:45,060 --> 00:05:49,860
cancelled the signal again now what that

00:05:47,729 --> 00:05:52,319
means is that if we're stuck in a very

00:05:49,860 --> 00:05:55,080
expensive request then after 28 seconds

00:05:52,319 --> 00:05:56,939
we basically tell the operating system

00:05:55,080 --> 00:05:59,039
kernel because this goes beyond Python

00:05:56,939 --> 00:06:01,500
to interrupt our program and when that

00:05:59,039 --> 00:06:02,789
happens the colonel will invoke our

00:06:01,500 --> 00:06:05,610
signal handler which you see at the top

00:06:02,789 --> 00:06:06,930
of that code snippet and so we regain

00:06:05,610 --> 00:06:08,789
control no matter what it was doing what

00:06:06,930 --> 00:06:10,199
it was stuck in a deadlock or you're

00:06:08,789 --> 00:06:13,339
doing database I oh it is really matter

00:06:10,199 --> 00:06:15,930
after 28 seconds that code gets invoked

00:06:13,339 --> 00:06:17,339
now what we do there is we just raise an

00:06:15,930 --> 00:06:19,229
exception and we raise an exception that

00:06:17,339 --> 00:06:21,569
we know isn't isn't caught anywhere and

00:06:19,229 --> 00:06:23,099
the the consequence of that is that the

00:06:21,569 --> 00:06:25,979
request blows up with an uncaught

00:06:23,099 --> 00:06:27,750
exception so to the the user is not much

00:06:25,979 --> 00:06:31,319
difference right he still gets a 500

00:06:27,750 --> 00:06:32,729
error just the page still fails just as

00:06:31,319 --> 00:06:34,080
he otherwise would have two seconds

00:06:32,729 --> 00:06:35,699
later when you know Gunny corn would've

00:06:34,080 --> 00:06:36,779
killed it but to us there's a big

00:06:35,699 --> 00:06:39,000
difference because now it blows up

00:06:36,779 --> 00:06:41,850
instead of a controlled way with

00:06:39,000 --> 00:06:43,950
a normal Python exception and those

00:06:41,850 --> 00:06:46,350
things get logged right so we've got our

00:06:43,950 --> 00:06:48,120
web server hooked up to century and

00:06:46,350 --> 00:06:51,840
every uncaught exception immediately

00:06:48,120 --> 00:06:53,850
ends up in on our century dashboard so

00:06:51,840 --> 00:06:55,830
now we had a real-time log of all these

00:06:53,850 --> 00:06:57,300
time out that occurred so we gotta like

00:06:55,830 --> 00:06:59,490
a feel for how big the problem even is

00:06:57,300 --> 00:07:02,520
and what's more because they're complete

00:06:59,490 --> 00:07:06,630
stack traces we can even tell what they

00:07:02,520 --> 00:07:08,100
were stuck on so when we turn this on

00:07:06,630 --> 00:07:09,720
it's been running for quite a while but

00:07:08,100 --> 00:07:11,640
when we turn this on this is one of the

00:07:09,720 --> 00:07:14,850
things that turn up so this is a

00:07:11,640 --> 00:07:16,980
fragment of a stack trace of a

00:07:14,850 --> 00:07:19,680
long-running request on our change that

00:07:16,980 --> 00:07:22,620
API our change that API gives you a

00:07:19,680 --> 00:07:25,830
paginate it view over all the commits in

00:07:22,620 --> 00:07:28,169
a repository in the pagination works by

00:07:25,830 --> 00:07:30,540
offset so the client provides an offset

00:07:28,169 --> 00:07:33,720
and a page size and then the client

00:07:30,540 --> 00:07:35,370
controls the navigation now to help the

00:07:33,720 --> 00:07:37,350
client determine when they have reached

00:07:35,370 --> 00:07:39,030
the end of the set every response

00:07:37,350 --> 00:07:42,270
returns the total number of commits in

00:07:39,030 --> 00:07:44,310
the repository in and that's where it

00:07:42,270 --> 00:07:47,430
goes wrong because you can see there at

00:07:44,310 --> 00:07:48,900
the top of that back trace what we do to

00:07:47,430 --> 00:07:51,870
compute the total number of commits in

00:07:48,900 --> 00:07:54,450
the repo we basically call list on repo

00:07:51,870 --> 00:07:56,550
history now what that does in bitbucket

00:07:54,450 --> 00:07:58,710
is it it loads up every single commit in

00:07:56,550 --> 00:08:00,419
the repo inside of a big list in Python

00:07:58,710 --> 00:08:02,280
and then eventually the length of that

00:08:00,419 --> 00:08:04,080
thing now you can imagine that's not

00:08:02,280 --> 00:08:05,910
going to scale very well even though

00:08:04,080 --> 00:08:08,280
loading a commit doesn't include loading

00:08:05,910 --> 00:08:10,290
up any diff sore contents from the from

00:08:08,280 --> 00:08:11,729
the repository it loads just the

00:08:10,290 --> 00:08:13,320
metadata we still have to load that

00:08:11,729 --> 00:08:14,970
stuff from this so if you have twice the

00:08:13,320 --> 00:08:17,430
number of commits that you need load it

00:08:14,970 --> 00:08:19,490
takes twice as long until eventually if

00:08:17,430 --> 00:08:22,800
only you have a repository big enough

00:08:19,490 --> 00:08:24,270
you get in this trouble so if we insist

00:08:22,800 --> 00:08:26,190
on returning the total number of commits

00:08:24,270 --> 00:08:29,190
we must find a cheaper way of getting to

00:08:26,190 --> 00:08:30,870
that number ironically enough so you can

00:08:29,190 --> 00:08:32,909
see here this is material in this

00:08:30,870 --> 00:08:34,919
particular repo and ironically enough a

00:08:32,909 --> 00:08:36,060
mercurial is very trivial to find the

00:08:34,919 --> 00:08:38,130
total number of commits in a repo

00:08:36,060 --> 00:08:39,510
because I material all the commits are

00:08:38,130 --> 00:08:40,740
sequentially numbered so all you need to

00:08:39,510 --> 00:08:43,349
do is look at the highest number you're

00:08:40,740 --> 00:08:45,270
done so in other words there's no excuse

00:08:43,349 --> 00:08:47,190
really for this thing to blow up the way

00:08:45,270 --> 00:08:50,010
it does this is just bad coding on our

00:08:47,190 --> 00:08:51,959
part fortunately solution isn't a simple

00:08:50,010 --> 00:08:52,720
because we also support get and then get

00:08:51,959 --> 00:08:55,000
there is no such

00:08:52,720 --> 00:08:56,829
a shortcut to get to that number and the

00:08:55,000 --> 00:08:58,240
only way to count the number of commits

00:08:56,829 --> 00:09:00,730
in a repo is to actually count them one

00:08:58,240 --> 00:09:04,629
by one so we're back to square one we

00:09:00,730 --> 00:09:06,699
still time out now eventually we had to

00:09:04,629 --> 00:09:08,560
conclude that we were just committing to

00:09:06,699 --> 00:09:10,029
too much information we couldn't be we

00:09:08,560 --> 00:09:12,220
couldn't commit this we could return

00:09:10,029 --> 00:09:13,600
this number reliably in most cases it

00:09:12,220 --> 00:09:16,209
will work fine sometimes it just doesn't

00:09:13,600 --> 00:09:17,649
and so we had to take it out that it was

00:09:16,209 --> 00:09:19,089
more wrong with this API and we have

00:09:17,649 --> 00:09:21,509
scenes rewritten this thing this is

00:09:19,089 --> 00:09:23,439
deprecated there is a new API in the

00:09:21,509 --> 00:09:25,509
pagination in that works differently

00:09:23,439 --> 00:09:27,129
it's no longer offset based every

00:09:25,509 --> 00:09:29,019
response contains an embedded link to

00:09:27,129 --> 00:09:30,879
the next page and the last page

00:09:29,019 --> 00:09:32,860
obviously doesn't so we sidestep the

00:09:30,879 --> 00:09:36,399
whole problem and it now runs in

00:09:32,860 --> 00:09:39,399
constant time and that's an important

00:09:36,399 --> 00:09:40,930
observation so basically if you can if

00:09:39,399 --> 00:09:42,579
you just look at that dashboard with

00:09:40,930 --> 00:09:45,370
with the the time that's coming in if

00:09:42,579 --> 00:09:46,990
for every problem that you see you just

00:09:45,370 --> 00:09:49,269
read just rewrite the code to run in

00:09:46,990 --> 00:09:51,160
constant time then you basically solve

00:09:49,269 --> 00:09:53,560
the problem if you did it for every time

00:09:51,160 --> 00:09:55,449
out DC eventually end up with every

00:09:53,560 --> 00:09:57,040
culpa thoroughly in constant time which

00:09:55,449 --> 00:09:58,779
is pretty good because now you've got a

00:09:57,040 --> 00:10:00,370
predictable upper bounds in execution

00:09:58,779 --> 00:10:02,170
time and by definition that sort of

00:10:00,370 --> 00:10:03,819
leads that becomes your new 100

00:10:02,170 --> 00:10:05,829
percentile so you sold all your problems

00:10:03,819 --> 00:10:06,970
you'll never have on any outliers again

00:10:05,829 --> 00:10:10,350
you'll never any performance problems

00:10:06,970 --> 00:10:14,379
again obviously it's not that simple

00:10:10,350 --> 00:10:16,689
right oftentimes or sometimes when you

00:10:14,379 --> 00:10:19,360
end up and you sit down and try to fix a

00:10:16,689 --> 00:10:20,860
bad piece of code it turns out that it's

00:10:19,360 --> 00:10:23,649
it's really hard to affect their

00:10:20,860 --> 00:10:25,180
properly like maybe you know you've

00:10:23,649 --> 00:10:27,790
worked on sort of legacy code bases

00:10:25,180 --> 00:10:30,730
you've come across code that really hard

00:10:27,790 --> 00:10:32,589
resists being reflected properly and as

00:10:30,730 --> 00:10:34,300
you sit down he try to fix it your

00:10:32,589 --> 00:10:36,759
changes ripples out through your code

00:10:34,300 --> 00:10:38,589
base and as it as that happens it takes

00:10:36,759 --> 00:10:40,029
more and more time and it becomes more

00:10:38,589 --> 00:10:43,000
risky too because you know with every

00:10:40,029 --> 00:10:44,350
change it might break something new it's

00:10:43,000 --> 00:10:45,550
also possible that you know maybe the

00:10:44,350 --> 00:10:47,339
problem isn't so much in your own code

00:10:45,550 --> 00:10:49,540
but it's in a dependency that you use

00:10:47,339 --> 00:10:51,610
the word you know external program that

00:10:49,540 --> 00:10:53,019
you spawn or something in or maybe it's

00:10:51,610 --> 00:10:54,759
written in something in the language

00:10:53,019 --> 00:10:56,620
that you don't really master that well

00:10:54,759 --> 00:10:58,389
you know these are also factors that can

00:10:56,620 --> 00:11:01,540
make it really hard to address these

00:10:58,389 --> 00:11:02,800
problems properly not a set of things

00:11:01,540 --> 00:11:05,889
that can influence these are our

00:11:02,800 --> 00:11:06,370
environmental issues so in bitbucket to

00:11:05,889 --> 00:11:10,779
keep things

00:11:06,370 --> 00:11:12,580
we use a lot of cashing in on various

00:11:10,779 --> 00:11:15,310
levels in we use memcache for that so we

00:11:12,580 --> 00:11:16,750
rely quite heavily Oh memcached we're

00:11:15,310 --> 00:11:18,880
not very smart and when we use memcache

00:11:16,750 --> 00:11:20,620
we we don't actually version our cache

00:11:18,880 --> 00:11:21,970
keys what that means is that whenever we

00:11:20,620 --> 00:11:24,550
deploy a new version of our production

00:11:21,970 --> 00:11:26,050
code which we do several times a week we

00:11:24,550 --> 00:11:28,810
are forced to flush all of our caches

00:11:26,050 --> 00:11:30,820
and you can imagine what happens on a

00:11:28,810 --> 00:11:33,460
very busy site we need flush the cache

00:11:30,820 --> 00:11:37,150
is it leads to a short but very heavy

00:11:33,460 --> 00:11:38,560
spike in load and also timeouts and we

00:11:37,150 --> 00:11:40,839
can fix this by not being stupid and

00:11:38,560 --> 00:11:42,279
properly version our cache keys but I'm

00:11:40,839 --> 00:11:44,380
mentioning it because it's sort of

00:11:42,279 --> 00:11:47,200
representative for a whole class of sort

00:11:44,380 --> 00:11:49,270
of environmental issues or influences

00:11:47,200 --> 00:11:51,390
that that can influence load for

00:11:49,270 --> 00:11:53,380
instance like maybe you got expensive

00:11:51,390 --> 00:11:54,940
housekeeping jobs running occasionally

00:11:53,380 --> 00:11:57,070
under your servers maybe you do you know

00:11:54,940 --> 00:11:59,110
backups of some sort or pre-compute

00:11:57,070 --> 00:12:01,990
indexes or all kinds of things that you

00:11:59,110 --> 00:12:03,250
know can cause a load to go up maybe got

00:12:01,990 --> 00:12:05,080
maintenance with people logging into

00:12:03,250 --> 00:12:07,570
servers and running all kinds of things

00:12:05,080 --> 00:12:08,950
that you can have an influence on the on

00:12:07,570 --> 00:12:11,589
the load and all these things are sort

00:12:08,950 --> 00:12:14,290
of hard to anticipate and predict in in

00:12:11,589 --> 00:12:18,339
and and do something about in the code

00:12:14,290 --> 00:12:19,450
as a developer and then there is a maybe

00:12:18,339 --> 00:12:21,490
the biggest problem of all there is

00:12:19,450 --> 00:12:23,020
there's input unpredictable input that

00:12:21,490 --> 00:12:25,089
comes from user that you uses it you

00:12:23,020 --> 00:12:26,380
need a process so in our case for

00:12:25,089 --> 00:12:28,839
instance that is people that think it's

00:12:26,380 --> 00:12:31,570
a good idea to push 50 gigs of binary

00:12:28,839 --> 00:12:33,190
Photoshop files into a git repo in and

00:12:31,570 --> 00:12:34,959
then we get in trouble if you try to you

00:12:33,190 --> 00:12:38,080
know render a diff or or even access any

00:12:34,959 --> 00:12:41,800
of those files it's also us trying to

00:12:38,080 --> 00:12:44,410
link a Phi any Content that is provided

00:12:41,800 --> 00:12:46,540
like typed on the on the UI by users so

00:12:44,410 --> 00:12:48,640
for instance if you if you type a an

00:12:46,540 --> 00:12:50,560
issue description or a commit

00:12:48,640 --> 00:12:52,330
description or like a comment on on a

00:12:50,560 --> 00:12:54,339
pull request all that stuff when we

00:12:52,330 --> 00:12:56,820
render it we scan it and we look for

00:12:54,339 --> 00:12:59,980
patterns that look like commit hashes

00:12:56,820 --> 00:13:01,480
usernames other repository names and we

00:12:59,980 --> 00:13:06,130
find them we turn them into hyperlinks

00:13:01,480 --> 00:13:07,750
to you know ease navigation the way that

00:13:06,130 --> 00:13:09,190
we do that is we simply use regular

00:13:07,750 --> 00:13:10,750
expressions so we run a whole bunch of

00:13:09,190 --> 00:13:13,510
regular expressions against any piece of

00:13:10,750 --> 00:13:15,730
user typed input on the side and regular

00:13:13,510 --> 00:13:18,380
expressions have a very unpredictable

00:13:15,730 --> 00:13:21,320
sort of runtime behavior

00:13:18,380 --> 00:13:23,060
the time it takes to map to run a

00:13:21,320 --> 00:13:24,980
pattern against something depends on the

00:13:23,060 --> 00:13:26,630
complexity a pattern it depends on the

00:13:24,980 --> 00:13:28,750
on the input and the combination of the

00:13:26,630 --> 00:13:31,310
two so this example for instance

00:13:28,750 --> 00:13:34,700
seemingly innocuous will run longer than

00:13:31,310 --> 00:13:36,890
this talk so while you know it sounds

00:13:34,700 --> 00:13:38,450
very very easy very nice to just rewrite

00:13:36,890 --> 00:13:40,400
everything to run in constant time there

00:13:38,450 --> 00:13:43,910
are many factors that sometimes make

00:13:40,400 --> 00:13:45,410
that impossible to do but it's important

00:13:43,910 --> 00:13:46,730
we focus on that small number of really

00:13:45,410 --> 00:13:49,550
slow requests because again they have

00:13:46,730 --> 00:13:50,660
the biggest impact and so we really want

00:13:49,550 --> 00:13:53,090
to do is we want to look for civ a

00:13:50,660 --> 00:13:55,400
pragmatic way to regain some control

00:13:53,090 --> 00:13:57,080
over those cases and what we've seen

00:13:55,400 --> 00:13:59,420
looking at many of the many of these

00:13:57,080 --> 00:14:00,500
timeouts is that we saw that in many

00:13:59,420 --> 00:14:02,780
cases it would have been okay to

00:14:00,500 --> 00:14:04,790
interrupt a long-running request skip

00:14:02,780 --> 00:14:06,590
over the heavy bit and continue with the

00:14:04,790 --> 00:14:08,630
rest and then eventually serve a page

00:14:06,590 --> 00:14:10,250
that just lacks some of the data it's

00:14:08,630 --> 00:14:12,770
often better than not doing anything at

00:14:10,250 --> 00:14:15,580
all and blowing up so we did was we sort

00:14:12,770 --> 00:14:17,930
of ran with the idea and we took our

00:14:15,580 --> 00:14:20,060
alarm signal handler from earlier and we

00:14:17,930 --> 00:14:22,460
turn it into a generic library that can

00:14:20,060 --> 00:14:24,590
that lets you time box any chunk of code

00:14:22,460 --> 00:14:26,540
so easy here is we call it interrupting

00:14:24,590 --> 00:14:29,060
cow and here you see it on a on a

00:14:26,540 --> 00:14:31,070
program that has a busy loop we read the

00:14:29,060 --> 00:14:32,870
busy loop in a two second timeout and

00:14:31,070 --> 00:14:34,760
went after two seconds we raise

00:14:32,870 --> 00:14:36,590
runtimeerror if the busy loop doesn't

00:14:34,760 --> 00:14:41,030
exit it doesn't exit and so we blow up

00:14:36,590 --> 00:14:43,880
as expected now timeouts are reentrant

00:14:41,030 --> 00:14:45,470
so you can nest timeouts here you see 20

00:14:43,880 --> 00:14:48,230
second outer timeout raises one type of

00:14:45,470 --> 00:14:50,330
exception which wraps an inner time out

00:14:48,230 --> 00:14:52,340
which has a smaller timeout which raises

00:14:50,330 --> 00:14:54,080
a different kind of exception inside of

00:14:52,340 --> 00:14:55,850
there we do an operation that is

00:14:54,080 --> 00:14:57,680
potentially very expensive maybe it runs

00:14:55,850 --> 00:15:00,110
in time maybe it doesn't if it doesn't

00:14:57,680 --> 00:15:01,220
we catch that exception yearly and we do

00:15:00,110 --> 00:15:04,220
something else instead which hopefully

00:15:01,220 --> 00:15:06,800
is cheaper you can also see that you can

00:15:04,220 --> 00:15:09,290
use float literals for timeouts you can

00:15:06,800 --> 00:15:13,820
also use quota objects and a quota but

00:15:09,290 --> 00:15:15,970
it allows you to express a like a like a

00:15:13,820 --> 00:15:19,190
time interval that you can then reuse

00:15:15,970 --> 00:15:21,260
and share among multiple invocations of

00:15:19,190 --> 00:15:23,000
time out and so every invocation of

00:15:21,260 --> 00:15:25,160
timeout can only use as much time as is

00:15:23,000 --> 00:15:26,720
left in the quota it's very useful if

00:15:25,160 --> 00:15:29,420
you use it in loops as we'll see later

00:15:26,720 --> 00:15:31,960
on so let's see how this actually works

00:15:29,420 --> 00:15:36,040
so remember our link effect

00:15:31,960 --> 00:15:37,180
your problem that's even even becomes

00:15:36,040 --> 00:15:39,670
even more difficult because we allow

00:15:37,180 --> 00:15:41,380
users to supply their own custom regular

00:15:39,670 --> 00:15:43,270
expressions on bitbucket so they can

00:15:41,380 --> 00:15:44,800
link anything to any external system

00:15:43,270 --> 00:15:46,300
that they they run themselves maybe

00:15:44,800 --> 00:15:48,610
they've got their issues in fogbugz or

00:15:46,300 --> 00:15:49,690
something they can link that so what

00:15:48,610 --> 00:15:51,820
we've done we all want to ditch this

00:15:49,690 --> 00:15:54,670
this functionality so what we've done is

00:15:51,820 --> 00:15:57,310
we've written our LinkedIn vacation in

00:15:54,670 --> 00:15:59,890
such a way that we process every

00:15:57,310 --> 00:16:01,930
document progressively so we we replace

00:15:59,890 --> 00:16:03,790
one instance of the pattern that we find

00:16:01,930 --> 00:16:05,770
then we replace the next hunt etc etc

00:16:03,790 --> 00:16:08,170
and if at any given point we get

00:16:05,770 --> 00:16:09,520
interrupted it's fine we just use

00:16:08,170 --> 00:16:11,740
whatever we've gotten up until that

00:16:09,520 --> 00:16:13,390
point so sometimes you'll have you know

00:16:11,740 --> 00:16:16,030
commit description is partially length

00:16:13,390 --> 00:16:17,890
but not completely and here's how that

00:16:16,030 --> 00:16:19,960
work so the bottom here you see we've

00:16:17,890 --> 00:16:21,940
got a timeout of 100 milliseconds and in

00:16:19,960 --> 00:16:25,300
there we call replace we pass in a

00:16:21,940 --> 00:16:28,570
document a regular expression and action

00:16:25,300 --> 00:16:31,990
in in this case we turn it into a

00:16:28,570 --> 00:16:33,760
hyperlink now inside replay so you can

00:16:31,990 --> 00:16:37,330
see is we only replace a single instance

00:16:33,760 --> 00:16:39,160
we cut the the document in half so the

00:16:37,330 --> 00:16:41,410
first bit and secondly the first thing

00:16:39,160 --> 00:16:43,990
the first bit we applied a pattern and

00:16:41,410 --> 00:16:46,750
the remaining document is basically

00:16:43,990 --> 00:16:49,450
recursively fed into ourselves in until

00:16:46,750 --> 00:16:50,530
the entire thing has been processed now

00:16:49,450 --> 00:16:52,480
on every level of the stack we

00:16:50,530 --> 00:16:54,190
anticipate the exception that the

00:16:52,480 --> 00:16:56,500
timeout so you can see that we eagerly

00:16:54,190 --> 00:16:58,720
catch timeout exception and when it

00:16:56,500 --> 00:17:01,750
occurs it's fine we just swallow it but

00:16:58,720 --> 00:17:03,700
we seize any further recursion we return

00:17:01,750 --> 00:17:06,400
we end up with something that you know

00:17:03,700 --> 00:17:09,459
is always usable and we'll have some or

00:17:06,400 --> 00:17:10,690
all of it linka fight properly good

00:17:09,459 --> 00:17:13,000
thing is that will never spend more than

00:17:10,690 --> 00:17:14,740
100 milliseconds on the problem no

00:17:13,000 --> 00:17:18,370
matter what kind of regular expression

00:17:14,740 --> 00:17:23,350
people use now big bucket is all written

00:17:18,370 --> 00:17:25,120
in um Django most of it and so we spend

00:17:23,350 --> 00:17:27,160
a lot of time in tangos templating

00:17:25,120 --> 00:17:29,260
engine and so we wanted to be able to

00:17:27,160 --> 00:17:32,020
use time boxing in directly in templates

00:17:29,260 --> 00:17:33,400
so we've written a time limit tag that

00:17:32,020 --> 00:17:36,520
basically lets you do that so a time

00:17:33,400 --> 00:17:38,020
limit tag takes two sup fragments and it

00:17:36,520 --> 00:17:39,550
will render the first one if there's

00:17:38,020 --> 00:17:41,650
enough time if there isn't it'll render

00:17:39,550 --> 00:17:43,150
the other one and here you can see how

00:17:41,650 --> 00:17:45,270
we use it inside of a list so this

00:17:43,150 --> 00:17:47,100
fragment basically renders a

00:17:45,270 --> 00:17:49,080
of commits for every commit it renders a

00:17:47,100 --> 00:17:51,030
bunch of properties one of the

00:17:49,080 --> 00:17:53,040
properties that renders is the diff stat

00:17:51,030 --> 00:17:54,900
and the diff set of a commit is the

00:17:53,040 --> 00:17:56,700
total number of lines that are affected

00:17:54,900 --> 00:17:58,110
by that commit three expensive

00:17:56,700 --> 00:17:59,850
potentially very expensive to compute

00:17:58,110 --> 00:18:01,380
because you essentially have to build a

00:17:59,850 --> 00:18:04,290
whole diff and count the lines in the

00:18:01,380 --> 00:18:05,760
diff in it's very hard to predict the

00:18:04,290 --> 00:18:07,560
runtime of that because it's really no

00:18:05,760 --> 00:18:10,020
upper bound like a larger commit will

00:18:07,560 --> 00:18:12,980
take much longer to compute a diff step

00:18:10,020 --> 00:18:15,660
4 so what we do here is we allocate a

00:18:12,980 --> 00:18:19,110
quota at one second quote in this case

00:18:15,660 --> 00:18:21,900
in and we use that inside of the loop so

00:18:19,110 --> 00:18:23,880
we just wrap the dipset part in in a

00:18:21,900 --> 00:18:25,280
time limit and so no matter how long the

00:18:23,880 --> 00:18:27,960
committee list is no matter how

00:18:25,280 --> 00:18:30,260
complicated commits are we are only ever

00:18:27,960 --> 00:18:32,550
going to spend one second processing

00:18:30,260 --> 00:18:34,740
distance and for the remaining commits

00:18:32,550 --> 00:18:36,660
if we run at a time we'll just you know

00:18:34,740 --> 00:18:41,190
rendered is that not available we think

00:18:36,660 --> 00:18:42,390
is better than blowing up now I'm not

00:18:41,190 --> 00:18:43,710
advocating should start wrapping

00:18:42,390 --> 00:18:45,210
everything in time outs now that it's

00:18:43,710 --> 00:18:47,880
sort of a silver bullet because it's not

00:18:45,210 --> 00:18:50,100
in many cases or in some cases you know

00:18:47,880 --> 00:18:52,320
there's really no sort of viable lower

00:18:50,100 --> 00:18:55,050
quality of the of your data that you can

00:18:52,320 --> 00:18:57,780
use as a substitute however if you do

00:18:55,050 --> 00:19:00,600
you get some really unique aspects so

00:18:57,780 --> 00:19:02,730
this kind of programming works well with

00:19:00,600 --> 00:19:06,900
legacy code or you know Cody you can't

00:19:02,730 --> 00:19:09,120
really change effectively may not even

00:19:06,900 --> 00:19:11,310
be your own code it also it gives you

00:19:09,120 --> 00:19:13,890
sort of a generic approach to dealing

00:19:11,310 --> 00:19:17,160
with these issues right so whether the

00:19:13,890 --> 00:19:19,350
the the core of the problem is a busy

00:19:17,160 --> 00:19:21,510
loop like CPU bound stuff or i/o bound

00:19:19,350 --> 00:19:22,860
stuff or whatever it is it gives you a

00:19:21,510 --> 00:19:25,140
generic way of dealing with that because

00:19:22,860 --> 00:19:28,410
the time the time boxes work just the

00:19:25,140 --> 00:19:31,020
same and it sort of maps nicely to

00:19:28,410 --> 00:19:32,880
pythons optimistic approach to

00:19:31,020 --> 00:19:34,890
programming like in one of pythons

00:19:32,880 --> 00:19:36,870
philosophy sort of is it's easy to ask

00:19:34,890 --> 00:19:38,760
for forgiveness than permission so you

00:19:36,870 --> 00:19:40,920
know just go ahead and try to do what

00:19:38,760 --> 00:19:41,700
you think you want to do and assume that

00:19:40,920 --> 00:19:43,950
it's going to work and if it doesn't

00:19:41,700 --> 00:19:45,900
well then deal with it by catching the

00:19:43,950 --> 00:19:48,600
appropriate exceptions it's sort of in

00:19:45,900 --> 00:19:49,950
contrast to the more pessimistic look

00:19:48,600 --> 00:19:52,320
before you leap philosophy that

00:19:49,950 --> 00:19:54,570
characterizes some other languages now

00:19:52,320 --> 00:19:56,370
likewise time boxing sort of allows you

00:19:54,570 --> 00:19:58,200
to continue to use really powerful

00:19:56,370 --> 00:19:58,919
functionality that works fine most of

00:19:58,200 --> 00:20:01,559
the time but not

00:19:58,919 --> 00:20:03,509
always in in the remaining cases you

00:20:01,559 --> 00:20:07,080
know you've got your five boxes to keep

00:20:03,509 --> 00:20:09,480
things under control and another

00:20:07,080 --> 00:20:11,609
interesting characteristic is that these

00:20:09,480 --> 00:20:14,700
things play very well under server load

00:20:11,609 --> 00:20:17,039
so typically if you have a server with

00:20:14,700 --> 00:20:18,899
very high load everything slows down and

00:20:17,039 --> 00:20:23,549
when that happens you tend to get a

00:20:18,899 --> 00:20:25,859
buildup of pending requests in and jobs

00:20:23,549 --> 00:20:28,799
in as it happens it usually compounds

00:20:25,859 --> 00:20:31,169
the problem even further so time box

00:20:28,799 --> 00:20:33,809
saying basically make sure that you know

00:20:31,169 --> 00:20:35,129
you you cap your execution times so

00:20:33,809 --> 00:20:36,869
therefore the throughput on your site

00:20:35,129 --> 00:20:41,460
remains its same and so you avoid a

00:20:36,869 --> 00:20:44,309
whole problem so sort of summarize page

00:20:41,460 --> 00:20:47,190
render times are very unpredictable

00:20:44,309 --> 00:20:50,129
there's usually lots of external factors

00:20:47,190 --> 00:20:51,359
that contribute to it some of them will

00:20:50,129 --> 00:20:52,799
be very fast some of them will be very

00:20:51,359 --> 00:20:54,269
slow and even though the number of slow

00:20:52,799 --> 00:20:56,129
requests is just a tiny fraction on your

00:20:54,269 --> 00:20:58,739
side they have the biggest impact so you

00:20:56,129 --> 00:21:01,019
have to you know look at those

00:20:58,739 --> 00:21:02,970
specifically and you know do everything

00:21:01,019 --> 00:21:04,710
you've you're used to doing so reflect a

00:21:02,970 --> 00:21:06,509
bad code whenever you can you know

00:21:04,710 --> 00:21:08,129
precompute expensive stuff and even

00:21:06,509 --> 00:21:09,690
remove functionality or push back on

00:21:08,129 --> 00:21:11,489
functionality that you you know you just

00:21:09,690 --> 00:21:13,230
can't do in a scalable way for instant

00:21:11,489 --> 00:21:16,919
ridiculous list that we didn't let

00:21:13,230 --> 00:21:19,499
change list page but then on top of all

00:21:16,919 --> 00:21:20,759
that whenever that isn't feasible and

00:21:19,499 --> 00:21:23,429
you really want to offer this front this

00:21:20,759 --> 00:21:27,840
this powerful functionality you can

00:21:23,429 --> 00:21:29,309
consider time boxing that's all I

00:21:27,840 --> 00:21:32,059
haven't thanks a lot for listening there

00:21:29,309 --> 00:21:32,059
are any questions

00:21:37,039 --> 00:21:40,409
thanks Eric that was great time for

00:21:39,179 --> 00:21:42,529
questions i guess but yeah we have a

00:21:40,409 --> 00:21:47,509
couple of minutes left for questions Oh

00:21:42,529 --> 00:21:52,039
start do you want it you can go first

00:21:47,509 --> 00:21:56,129
hi-yah um so you spoke a lot about

00:21:52,039 --> 00:22:00,059
obviously timeouts in code and I'm just

00:21:56,129 --> 00:22:03,659
wondering if there's any scope I suppose

00:22:00,059 --> 00:22:05,190
for adding other types of interrupt as

00:22:03,659 --> 00:22:08,489
you see in other areas of computer

00:22:05,190 --> 00:22:10,700
science perhaps interrupting it from

00:22:08,489 --> 00:22:13,440
another thread or another process

00:22:10,700 --> 00:22:17,190
whether the scope for that within

00:22:13,440 --> 00:22:19,409
interrupting cow ah yes I think there is

00:22:17,190 --> 00:22:21,269
and it's because they're quite a bit of

00:22:19,409 --> 00:22:23,039
I didn't have time to to cover all the

00:22:21,269 --> 00:22:25,590
caveats because using signals it has

00:22:23,039 --> 00:22:27,179
quite quite a quite a few catches yeah

00:22:25,590 --> 00:22:29,129
for one thing it doesn't play nice with

00:22:27,179 --> 00:22:31,109
threats so you know if you have a threat

00:22:29,129 --> 00:22:33,149
at web server then this thing doesn't

00:22:31,109 --> 00:22:35,549
really work very well so in other words

00:22:33,149 --> 00:22:37,049
the question is is there scope to you

00:22:35,549 --> 00:22:38,999
know using a referee between threats yes

00:22:37,049 --> 00:22:40,499
I guess there is you know doesn't do it

00:22:38,999 --> 00:22:42,419
right now but yes I guess you know if

00:22:40,499 --> 00:22:44,220
you have sort of a background threat

00:22:42,419 --> 00:22:45,690
that keeps track of runs on execution

00:22:44,220 --> 00:22:48,779
and then interrupts or proper threats

00:22:45,690 --> 00:22:51,690
were basically the same is that you do

00:22:48,779 --> 00:22:53,399
with with with signals but on the threat

00:22:51,690 --> 00:22:55,109
level it can be very interesting another

00:22:53,399 --> 00:22:57,330
thing would be very interesting which I

00:22:55,109 --> 00:22:59,460
thought about but never realized is to

00:22:57,330 --> 00:23:01,769
sort of have resource constraints around

00:22:59,460 --> 00:23:03,480
memory right so you say run this piece

00:23:01,769 --> 00:23:05,009
of code but never use more than you know

00:23:03,480 --> 00:23:06,059
hundred mags a memory for instance but

00:23:05,009 --> 00:23:08,730
we have a lot of these problems with

00:23:06,059 --> 00:23:09,809
ridiculously large repos haven't gotten

00:23:08,730 --> 00:23:17,460
to that point but yeah there's

00:23:09,809 --> 00:23:18,929
definitely scope for them let's see I

00:23:17,460 --> 00:23:21,359
don't to show my questions relevant

00:23:18,929 --> 00:23:23,700
anymore but can you sort of detect the

00:23:21,359 --> 00:23:25,619
server low then selectively run

00:23:23,700 --> 00:23:27,529
different algorithms based upon the

00:23:25,619 --> 00:23:29,999
quality of the data you want to return

00:23:27,529 --> 00:23:32,399
so really well what was that one more

00:23:29,999 --> 00:23:34,499
time well you could detect what the

00:23:32,399 --> 00:23:36,899
response rate is from the servers and

00:23:34,499 --> 00:23:39,179
then if everything's really going super

00:23:36,899 --> 00:23:42,179
super quick you can use the more

00:23:39,179 --> 00:23:43,950
complete program response or if you

00:23:42,179 --> 00:23:46,320
round a lug you can use the cheapo one

00:23:43,950 --> 00:23:48,400
you mean sort of turn it around if you

00:23:46,320 --> 00:23:51,010
got more time do a more expensive

00:23:48,400 --> 00:23:54,370
thing I guess yeah I can never really

00:23:51,010 --> 00:23:56,800
consider that it it with in our context

00:23:54,370 --> 00:23:58,570
because we always run out of time but

00:23:56,800 --> 00:24:00,310
yeah I mean yeah of course it would

00:23:58,570 --> 00:24:03,430
apply equally well I guess if you could

00:24:00,310 --> 00:24:05,770
program that a couple of more questions

00:24:03,430 --> 00:24:10,240
over this side oh I'll go over here

00:24:05,770 --> 00:24:11,740
first sorry guys I'm just a quick

00:24:10,240 --> 00:24:14,680
question what's the overhead like for

00:24:11,740 --> 00:24:18,700
interrupting cow I i I'm going to say

00:24:14,680 --> 00:24:20,170
it's it's properly negligible these

00:24:18,700 --> 00:24:23,080
things are their system calls but they

00:24:20,170 --> 00:24:24,880
are they're very quick and sometimes

00:24:23,080 --> 00:24:26,980
they're even used as a sort of a profile

00:24:24,880 --> 00:24:29,710
a profiler so you do it a lot of times

00:24:26,980 --> 00:24:31,930
you build up a statistical like

00:24:29,710 --> 00:24:34,270
breakdown of where your execution takes

00:24:31,930 --> 00:24:35,320
place and so it's very very quick and in

00:24:34,270 --> 00:24:38,230
this particular case you know like

00:24:35,320 --> 00:24:40,450
depends on how many time box you using

00:24:38,230 --> 00:24:42,310
your coat i guess but i don't think

00:24:40,450 --> 00:24:47,860
you'll ever see it show up in i am in a

00:24:42,310 --> 00:24:49,720
profiler we still had a couple more

00:24:47,860 --> 00:24:55,420
questions over here and we do have a

00:24:49,720 --> 00:24:57,130
couple of minutes so in the case of a

00:24:55,420 --> 00:24:59,740
time out the client i guess with the

00:24:57,130 --> 00:25:03,040
client the clients having to deal with I

00:24:59,740 --> 00:25:06,370
guess two types of responses and I just

00:25:03,040 --> 00:25:07,990
wanted how you document that or how you

00:25:06,370 --> 00:25:09,790
communicate to the client that hey

00:25:07,990 --> 00:25:11,710
there's a bit more complexity for you

00:25:09,790 --> 00:25:13,030
potentially involved and and I guess

00:25:11,710 --> 00:25:15,010
there's a bit of tension there as well

00:25:13,030 --> 00:25:17,440
because you're putting some work on the

00:25:15,010 --> 00:25:19,420
client in order to deal with these two

00:25:17,440 --> 00:25:22,930
types of response I just wanted your

00:25:19,420 --> 00:25:24,760
comments on that yeah for sure you know

00:25:22,930 --> 00:25:28,030
we sort of make it easy on ourselves but

00:25:24,760 --> 00:25:30,190
obviously yes we we know basically we

00:25:28,030 --> 00:25:31,270
give a like an incomplete result and how

00:25:30,190 --> 00:25:33,430
is that the client going to deal with

00:25:31,270 --> 00:25:34,570
that and it's hard to give sort of a

00:25:33,430 --> 00:25:36,360
generic answer to that because it really

00:25:34,570 --> 00:25:38,740
depends on the thing that you're you're

00:25:36,360 --> 00:25:41,380
you're rendering but to give an example

00:25:38,740 --> 00:25:44,620
we use this we started out using this

00:25:41,380 --> 00:25:46,510
for most on bitbucket wisdom our diff

00:25:44,620 --> 00:25:47,890
page like whenever you look at a commit

00:25:46,510 --> 00:25:49,780
on bitbucket you get a single page that

00:25:47,890 --> 00:25:51,790
has all the all the files and all the

00:25:49,780 --> 00:25:53,080
disks on a single page and so again

00:25:51,790 --> 00:25:54,940
there's not really any upper bound so

00:25:53,080 --> 00:25:58,240
the page can get infinitely long pretty

00:25:54,940 --> 00:26:01,090
much and so we scoped all that stuff in

00:25:58,240 --> 00:26:02,140
and then in that particular case what we

00:26:01,090 --> 00:26:04,330
do is we render a page

00:26:02,140 --> 00:26:06,910
you'll have some of the file devs which

00:26:04,330 --> 00:26:08,890
most usually is enough for for st. ifs

00:26:06,910 --> 00:26:10,780
but for some insane day citizens and

00:26:08,890 --> 00:26:12,310
then the remaining files are basically

00:26:10,780 --> 00:26:14,410
used their sort of buttons that you can

00:26:12,310 --> 00:26:15,970
click and then load that one thing right

00:26:14,410 --> 00:26:17,500
so it's in that particular case it's

00:26:15,970 --> 00:26:19,840
fine because it's you know you serve it

00:26:17,500 --> 00:26:21,070
as a page not as an API endpoint and it

00:26:19,840 --> 00:26:24,580
you know there are buttons to basically

00:26:21,070 --> 00:26:25,960
complete the missing data in in API

00:26:24,580 --> 00:26:27,820
endpoints it's sort of sometimes we

00:26:25,960 --> 00:26:30,250
documented like the diff thing also

00:26:27,820 --> 00:26:34,060
applies to the API in you know you can

00:26:30,250 --> 00:26:35,350
get a specific error status code

00:26:34,060 --> 00:26:36,910
basically if you couldn't compute a

00:26:35,350 --> 00:26:38,500
computer in time and you're basically

00:26:36,910 --> 00:26:41,200
you know in that particular case we saw

00:26:38,500 --> 00:26:44,710
we basically you know we're sorry but we

00:26:41,200 --> 00:26:46,180
can't do this sorry guys we don't really

00:26:44,710 --> 00:26:47,410
have much more time for questions so if

00:26:46,180 --> 00:26:49,920
you do have anything you'd like to ask

00:26:47,410 --> 00:26:55,840
feel free to come up and speak to eric

00:26:49,920 --> 00:26:57,520
we have a coffee mug and some coffee

00:26:55,840 --> 00:26:58,990
beans from ritual coffee here for Eric

00:26:57,520 --> 00:27:01,860
and thank you very much for that that

00:26:58,990 --> 00:27:01,860
was thanks

00:27:04,480 --> 00:27:06,540

YouTube URL: https://www.youtube.com/watch?v=Hv2pl7B1pZw


