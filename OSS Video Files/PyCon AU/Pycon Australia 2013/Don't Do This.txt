Title: Don't Do This
Publication date: 2013-07-10
Playlist: Pycon Australia 2013
Description: 
	Richard Jones
http://2013.pycon-au.org/schedule/30047/view_talk
In which Richard will tell you about some things you should never (probably ever) do to or in Python. Warranties may be voided.
PyCon Australia is the national conference for users of the Python Programming Language. In July 2013, we're returning to Hobart, bringing together students, enthusiasts, and professionals with a love of Python from around Australia, and from all over the World. 

July 5--7 2013, Hobart, Tasmania
Captions: 
	00:00:01,560 --> 00:00:06,720
welcome to the plenary Hall for this

00:00:04,069 --> 00:00:08,340
early afternoon session

00:00:06,720 --> 00:00:11,790
our first presenter for this block is

00:00:08,340 --> 00:00:13,230
Richard Jones he's a Python program with

00:00:11,790 --> 00:00:14,910
nearly 15 years experience

00:00:13,230 --> 00:00:16,230
he's an occasional core developer of

00:00:14,910 --> 00:00:17,789
Python itself he's a member of the

00:00:16,230 --> 00:00:19,529
Python Software Foundation as a

00:00:17,789 --> 00:00:21,300
co-founder and chair of a program

00:00:19,529 --> 00:00:26,160
committee of Python Australia which

00:00:21,300 --> 00:00:27,960
means he picked his own talk this time

00:00:26,160 --> 00:00:30,330
he's learned a few things about what you

00:00:27,960 --> 00:00:33,899
should not ever you should absolutely

00:00:30,330 --> 00:00:44,760
not ever ever ever do please welcome

00:00:33,899 --> 00:00:45,860
Richard Jones thanks Benno ok so this is

00:00:44,760 --> 00:00:47,789
just going to be the fun little talk

00:00:45,860 --> 00:00:50,670
well at least I thought it'd be fun I

00:00:47,789 --> 00:00:52,500
hope you get a bit of fun a bit too and

00:00:50,670 --> 00:00:54,930
basically what I'm gonna do in this talk

00:00:52,500 --> 00:00:57,570
is is poke around some some strange

00:00:54,930 --> 00:00:59,640
corners of Python and perhaps show you

00:00:57,570 --> 00:01:02,850
some things you can do with Python that

00:00:59,640 --> 00:01:06,750
you it probably shouldn't do but maybe

00:01:02,850 --> 00:01:08,640
start something sorry yeah well we'll

00:01:06,750 --> 00:01:10,380
get to that you might learn something

00:01:08,640 --> 00:01:11,939
new which will be cool we'll see how we

00:01:10,380 --> 00:01:14,220
go

00:01:11,939 --> 00:01:16,470
the first thing I'm gonna look at is a

00:01:14,220 --> 00:01:18,270
couple of corner cases of the Python

00:01:16,470 --> 00:01:20,670
grammar that kind of surprised me I

00:01:18,270 --> 00:01:24,049
thought they were kind of neat we'll see

00:01:20,670 --> 00:01:26,400
how we go so let's say we have

00:01:24,049 --> 00:01:29,960
serialization right turning data into

00:01:26,400 --> 00:01:32,460
text for storage or transfer or whatever

00:01:29,960 --> 00:01:35,189
we have some mixing classes that perform

00:01:32,460 --> 00:01:36,630
serialization we have our preferred

00:01:35,189 --> 00:01:38,880
mixing class which might not be

00:01:36,630 --> 00:01:40,380
available so serializing to JSON is

00:01:38,880 --> 00:01:42,420
preferred over serializing using

00:01:40,380 --> 00:01:44,430
Marshall but we want things to keep on

00:01:42,420 --> 00:01:48,000
going and Rocking regardless of whether

00:01:44,430 --> 00:01:49,619
you know a preferred one is available so

00:01:48,000 --> 00:01:52,020
did you know that the class is in the

00:01:49,619 --> 00:01:55,159
basis clause of a class definition can

00:01:52,020 --> 00:01:55,159
actually be an expression

00:01:55,299 --> 00:01:59,740
because in inheritance doesn't really

00:01:57,850 --> 00:02:01,719
cut it in this modern world of rapidly

00:01:59,740 --> 00:02:08,530
changing serialization protocols we need

00:02:01,719 --> 00:02:11,170
fallback atones okay who knew that it

00:02:08,530 --> 00:02:14,069
the accept clauses of exam can be

00:02:11,170 --> 00:02:16,750
expressions as well whatever the

00:02:14,069 --> 00:02:19,599
expression evaluates to had better be an

00:02:16,750 --> 00:02:21,640
exception class or you know it won't

00:02:19,599 --> 00:02:23,709
work but as long as it is the exception

00:02:21,640 --> 00:02:26,319
type that you end up with will be the

00:02:23,709 --> 00:02:26,890
thing that's caught okay so keep that in

00:02:26,319 --> 00:02:30,459
mind

00:02:26,890 --> 00:02:33,060
generators are cool right when you pluck

00:02:30,459 --> 00:02:36,069
the double-under next out of a generator

00:02:33,060 --> 00:02:37,209
you can just keep calling it and it just

00:02:36,069 --> 00:02:39,970
keeps generating stuff

00:02:37,209 --> 00:02:42,280
they're like little happy spewing

00:02:39,970 --> 00:02:43,780
machines that make your program awesomer

00:02:42,280 --> 00:02:46,239
just keep generating they're awesome

00:02:43,780 --> 00:02:51,069
let's modify our generator to generate

00:02:46,239 --> 00:02:53,620
exception classes instead of strings so

00:02:51,069 --> 00:02:55,299
now we have some stupid code that

00:02:53,620 --> 00:02:58,090
generates some stupid assertion errors

00:02:55,299 --> 00:02:59,620
but about half the time and we can

00:02:58,090 --> 00:03:03,670
restrict our program so that it just

00:02:59,620 --> 00:03:07,980
captures some of them and after five we

00:03:03,670 --> 00:03:10,510
stop squashing them so that's we've done

00:03:07,980 --> 00:03:14,980
this is an actual line of code from

00:03:10,510 --> 00:03:17,590
MongoDB it isn't exactly the same thing

00:03:14,980 --> 00:03:19,870
but it's kind of similar which is

00:03:17,590 --> 00:03:23,440
basically squashing the logging of an

00:03:19,870 --> 00:03:30,209
exception certain a roughly 90% of cases

00:03:23,440 --> 00:03:30,209
randomly so that's fun

00:03:32,680 --> 00:03:37,850
okay so that's just a couple of bizarro

00:03:36,200 --> 00:03:38,710
things in in the grammar which I thought

00:03:37,850 --> 00:03:42,650
pretty cool

00:03:38,710 --> 00:03:44,600
pythons also quite famously mutable so

00:03:42,650 --> 00:03:46,550
let's look at some things in pythons

00:03:44,600 --> 00:03:47,930
runtime that are perhaps a little bit

00:03:46,550 --> 00:03:51,140
more mutable than you might have

00:03:47,930 --> 00:03:52,910
previously thought let's start off with

00:03:51,140 --> 00:03:57,260
a little function okay we'll call it F

00:03:52,910 --> 00:04:00,680
and it does a thing the thing it does is

00:03:57,260 --> 00:04:02,390
in its code object and the code object

00:04:00,680 --> 00:04:06,680
is attached to the function object as

00:04:02,390 --> 00:04:07,790
the dunder code attribute you can exact

00:04:06,680 --> 00:04:11,150
code objects that's fun

00:04:07,790 --> 00:04:12,860
we'll come back to that so we'll make

00:04:11,150 --> 00:04:16,430
another function now let's call that G

00:04:12,860 --> 00:04:17,930
it does a thing as well so how many of

00:04:16,430 --> 00:04:20,570
you knew that the dunder code attribute

00:04:17,930 --> 00:04:22,670
was mutable you can take the code object

00:04:20,570 --> 00:04:31,160
from one function and assign it to

00:04:22,670 --> 00:04:33,380
another function so that's fun the code

00:04:31,160 --> 00:04:35,900
objects is not unique to functions the

00:04:33,380 --> 00:04:38,510
code in modules is also encapsulated in

00:04:35,900 --> 00:04:43,010
a code object module objects have a

00:04:38,510 --> 00:04:45,980
dunder code object the pyc files they're

00:04:43,010 --> 00:04:48,800
written by Python to cache module code

00:04:45,980 --> 00:04:53,120
is actually that code object marshaled

00:04:48,800 --> 00:04:55,970
using the built-in marshal module and we

00:04:53,120 --> 00:04:57,200
can unmarshal that object and I think

00:04:55,970 --> 00:05:02,480
you probably know where I'm heading with

00:04:57,200 --> 00:05:05,780
this so that's you know that's that's

00:05:02,480 --> 00:05:10,610
fun too that's some mutability that you

00:05:05,780 --> 00:05:13,370
might not have known about you can also

00:05:10,610 --> 00:05:14,510
create code objects by hand

00:05:13,370 --> 00:05:17,000
this is actually an unrelated

00:05:14,510 --> 00:05:20,840
conversation but it's similar this is

00:05:17,000 --> 00:05:23,690
where we start going off the rails and

00:05:20,840 --> 00:05:25,820
of course you can start with you know

00:05:23,690 --> 00:05:27,560
Python code to create code objects by

00:05:25,820 --> 00:05:28,730
hand but that's the obvious way right

00:05:27,560 --> 00:05:30,320
we're not talking about the obvious way

00:05:28,730 --> 00:05:33,980
of doing things

00:05:30,320 --> 00:05:38,810
we're talking about XML the beautiful

00:05:33,980 --> 00:05:40,940
elegance of XML Python XML we all short

00:05:38,810 --> 00:05:41,610
will call this file adder

00:05:40,940 --> 00:05:47,030
dot

00:05:41,610 --> 00:05:47,030
pi XML isn't it beautiful and elegant I

00:05:47,479 --> 00:05:52,590
mean I've got a whole bunch of XML stuff

00:05:49,830 --> 00:05:54,840
here I'm looking to enjoy so what we're

00:05:52,590 --> 00:05:57,659
going to do is we're going to parse this

00:05:54,840 --> 00:05:59,789
XML using Elementary which is nice and

00:05:57,659 --> 00:06:01,949
we're going to construct a thing called

00:05:59,789 --> 00:06:04,349
an abstract syntax tree which is a

00:06:01,949 --> 00:06:06,689
built-in thing in Python and we can take

00:06:04,349 --> 00:06:08,729
that syntax tree that we build and we

00:06:06,689 --> 00:06:12,509
can turn that into code using compile

00:06:08,729 --> 00:06:15,240
and it basically consists of a bunch of

00:06:12,509 --> 00:06:18,750
this I have it on good authority from

00:06:15,240 --> 00:06:23,699
someone close to the ast code that this

00:06:18,750 --> 00:06:25,650
really isn't done very often I I even

00:06:23,699 --> 00:06:28,889
managed to provoke a seg fault from deep

00:06:25,650 --> 00:06:30,810
inside AST which kind of worried him but

00:06:28,889 --> 00:06:32,610
I'll get back to you know I'll try and

00:06:30,810 --> 00:06:34,409
figure out exactly how I did that it's

00:06:32,610 --> 00:06:37,099
pretty straightforward really we're just

00:06:34,409 --> 00:06:39,360
visiting elements in our element tree

00:06:37,099 --> 00:06:43,680
and constrain constructing the

00:06:39,360 --> 00:06:45,719
appropriate ast object or node for the

00:06:43,680 --> 00:06:49,080
thing that we find in the XML it's

00:06:45,719 --> 00:06:50,550
fairly straightforward there's some some

00:06:49,080 --> 00:06:52,229
things I kind of fudge here like the

00:06:50,550 --> 00:06:54,389
line number and the column offset which

00:06:52,229 --> 00:06:55,440
I probably could have said if I spend a

00:06:54,389 --> 00:06:56,490
bit more time poking around llaman

00:06:55,440 --> 00:06:59,849
elementary but that's not the

00:06:56,490 --> 00:07:04,740
interesting part of this okay so that's

00:06:59,849 --> 00:07:07,860
fun so let's make this glorious new

00:07:04,740 --> 00:07:10,710
possibility of Python in XML a reality

00:07:07,860 --> 00:07:16,259
and install the PI XML loader so now we

00:07:10,710 --> 00:07:18,569
can import added PI XML and it's

00:07:16,259 --> 00:07:21,360
actually pretty easy to do that too so

00:07:18,569 --> 00:07:24,029
to do all that we create a custom

00:07:21,360 --> 00:07:26,580
importer file loader for the import

00:07:24,029 --> 00:07:28,979
machinery the import stuff needs me to

00:07:26,580 --> 00:07:31,440
register a finder which will locate the

00:07:28,979 --> 00:07:33,599
PI XML file matching the module name

00:07:31,440 --> 00:07:35,819
that's being imported and it returns a

00:07:33,599 --> 00:07:39,539
loader which can load the module and

00:07:35,819 --> 00:07:42,839
give back a code object Gene's is pretty

00:07:39,539 --> 00:07:45,000
straightforward you can and and we just

00:07:42,839 --> 00:07:48,240
use the ast from XML thing I just showed

00:07:45,000 --> 00:07:51,479
you to turn that txt file into a code

00:07:48,240 --> 00:07:53,069
object you can also abused this I have

00:07:51,479 --> 00:07:53,680
it on good authority the very clever man

00:07:53,069 --> 00:07:56,290
has

00:07:53,680 --> 00:07:59,080
use this too or this sort of approach to

00:07:56,290 --> 00:08:01,990
actually allow loading of SQL files into

00:07:59,080 --> 00:08:06,070
Python using import and making them

00:08:01,990 --> 00:08:08,680
executable inside Python SQL files so

00:08:06,070 --> 00:08:10,360
that's kind of neat you can even fight

00:08:08,680 --> 00:08:13,289
right sorry you can write funny little

00:08:10,360 --> 00:08:16,630
dear cells that meld Python and this

00:08:13,289 --> 00:08:19,000
which has been done you can write

00:08:16,630 --> 00:08:21,449
something to implement macros using this

00:08:19,000 --> 00:08:27,400
sort of thing which again has been done

00:08:21,449 --> 00:08:36,880
yeah okay but I think that we can throw

00:08:27,400 --> 00:08:38,560
in we can do worse we can throw in some

00:08:36,880 --> 00:08:40,900
of pythons slightly more powerful

00:08:38,560 --> 00:08:42,760
introspection capabilities as well and

00:08:40,900 --> 00:08:46,600
we can see what sort of damage we can do

00:08:42,760 --> 00:08:47,950
with those so we'll start off simple so

00:08:46,600 --> 00:08:49,510
you know about locals and Global's

00:08:47,950 --> 00:08:51,490
couple of built-in functions that give

00:08:49,510 --> 00:08:53,320
you access to the local namespace in the

00:08:51,490 --> 00:08:56,470
global namespace of where they've been

00:08:53,320 --> 00:08:58,330
called they give you a handle on a

00:08:56,470 --> 00:09:01,180
dictionary which has got those

00:08:58,330 --> 00:09:03,130
namespaces in it or as I like to call

00:09:01,180 --> 00:09:06,850
them by their full name inspect current

00:09:03,130 --> 00:09:08,320
frame dot F under locals there's another

00:09:06,850 --> 00:09:11,529
one which is F under Global's which is

00:09:08,320 --> 00:09:13,510
the global namespace anyway you can poke

00:09:11,529 --> 00:09:15,190
at that dictionary just as like it was a

00:09:13,510 --> 00:09:18,790
dictionary and here's a hint it's a

00:09:15,190 --> 00:09:20,560
dictionary so you can modify the

00:09:18,790 --> 00:09:23,380
dictionary to create new local variables

00:09:20,560 --> 00:09:26,260
just fine all right

00:09:23,380 --> 00:09:29,950
so let's say that we had some Jason

00:09:26,260 --> 00:09:32,709
called config jason you might know where

00:09:29,950 --> 00:09:36,430
I'm heading with this so now we can

00:09:32,709 --> 00:09:38,980
define an import jason thing that loads

00:09:36,430 --> 00:09:41,050
those values from the json file

00:09:38,980 --> 00:09:45,700
no imports them into the current

00:09:41,050 --> 00:09:47,529
namespace so that's handy and it's

00:09:45,700 --> 00:09:49,930
actually pretty simple to I mean why

00:09:47,529 --> 00:09:53,230
should import star hog all the namespace

00:09:49,930 --> 00:09:56,980
pollution fun we

00:09:53,230 --> 00:09:59,710
which we can look at the call stack to

00:09:56,980 --> 00:10:01,890
find the local namespace of interest the

00:09:59,710 --> 00:10:05,530
inspect module provides all this stuff

00:10:01,890 --> 00:10:07,450
we get the current frame we go back one

00:10:05,530 --> 00:10:09,790
step to the caller of the current frame

00:10:07,450 --> 00:10:11,680
using F back and we let get its locals

00:10:09,790 --> 00:10:13,300
using s locals and then we just update

00:10:11,680 --> 00:10:14,350
that dictionary with all this this is

00:10:13,300 --> 00:10:17,440
not the worst thing I'm going to show

00:10:14,350 --> 00:10:21,030
you today but it's probably worth saying

00:10:17,440 --> 00:10:24,550
you probably shouldn't do it though okay

00:10:21,030 --> 00:10:26,200
so another type of mutability that may

00:10:24,550 --> 00:10:28,120
be unexpected let's go back to the

00:10:26,200 --> 00:10:31,390
serialization idea right we've got the

00:10:28,120 --> 00:10:32,800
serialization classes we've got this set

00:10:31,390 --> 00:10:34,510
up where we've got do stuff and it's

00:10:32,800 --> 00:10:36,310
doing stuff and it inherits from the

00:10:34,510 --> 00:10:39,550
mixing class to serialize using the

00:10:36,310 --> 00:10:40,960
marshal module and that's all good let's

00:10:39,550 --> 00:10:42,750
say we don't decide a little bit later

00:10:40,960 --> 00:10:45,160
in our code that we want to stop using

00:10:42,750 --> 00:10:46,750
Marshall to serialize the data data and

00:10:45,160 --> 00:10:48,490
we want to use JSON instead because it's

00:10:46,750 --> 00:10:50,500
easier to read that's nice we can just

00:10:48,490 --> 00:10:52,600
you know switch over to it we can do

00:10:50,500 --> 00:10:55,570
that we just swap out the old mixing

00:10:52,600 --> 00:10:57,940
class and swap in the JSON class and so

00:10:55,570 --> 00:10:59,590
do stuff just start using the the new

00:10:57,940 --> 00:11:08,560
mixing class because that's its base

00:10:59,590 --> 00:11:11,530
class now okay groans excellent so

00:11:08,560 --> 00:11:13,510
context managers right there pretty neat

00:11:11,530 --> 00:11:14,950
so who else when they first saw context

00:11:13,510 --> 00:11:18,580
managers thought hey I could do

00:11:14,950 --> 00:11:23,710
namespace stuff with this just the two

00:11:18,580 --> 00:11:25,900
of us then okay I certainly did okay so

00:11:23,710 --> 00:11:28,540
here's a context manager that it'll

00:11:25,900 --> 00:11:30,810
snarf all the local variable assignments

00:11:28,540 --> 00:11:33,340
and copy them into a dictionary called D

00:11:30,810 --> 00:11:36,670
think of it as kind of a backup

00:11:33,340 --> 00:11:37,690
namespace or something I have no idea

00:11:36,670 --> 00:11:39,040
why you'd want to do this I'm not going

00:11:37,690 --> 00:11:41,770
to justify it it's just a thing you can

00:11:39,040 --> 00:11:43,840
do it's pretty easy to modify that code

00:11:41,770 --> 00:11:44,590
to capture the locals onto another

00:11:43,840 --> 00:11:49,410
object

00:11:44,590 --> 00:11:49,410
so no more typing self all the time

00:11:52,550 --> 00:11:58,110
and who else is sick and tired of typing

00:11:55,589 --> 00:12:00,269
global all the time right well we can do

00:11:58,110 --> 00:12:03,360
away with all those pesky global

00:12:00,269 --> 00:12:07,589
variable declarations promote everything

00:12:03,360 --> 00:12:09,480
up to global and again this code is

00:12:07,589 --> 00:12:11,160
pretty simple that it's it's pretty

00:12:09,480 --> 00:12:13,529
straight well relatively straightforward

00:12:11,160 --> 00:12:16,350
so if you recall our context managers

00:12:13,529 --> 00:12:19,320
are invoked twice the enter is invoked

00:12:16,350 --> 00:12:21,029
at the start of the West block so when

00:12:19,320 --> 00:12:23,220
that happens we snapshot the local

00:12:21,029 --> 00:12:25,350
variables the name of names of the local

00:12:23,220 --> 00:12:28,560
variables belonging to the callers frame

00:12:25,350 --> 00:12:30,120
as in the thing that called enter using

00:12:28,560 --> 00:12:32,519
F back in F locals just like we did

00:12:30,120 --> 00:12:34,320
before and then when the wis block exits

00:12:32,519 --> 00:12:36,690
we figure out what are the new local

00:12:34,320 --> 00:12:40,970
variables and we capture them straight

00:12:36,690 --> 00:12:43,139
forward okey dokey

00:12:40,970 --> 00:12:47,459
so I'm gonna take a bit of a diversion

00:12:43,139 --> 00:12:49,170
here a common problem we have as

00:12:47,459 --> 00:12:51,750
software developers is that we're often

00:12:49,170 --> 00:12:54,389
asked to find out why some live code has

00:12:51,750 --> 00:12:56,010
gone awry sometimes we're not the author

00:12:54,389 --> 00:12:58,110
of the code and sometimes are not even

00:12:56,010 --> 00:12:59,940
familiar with the develop the deployment

00:12:58,110 --> 00:13:01,829
scenario and sometimes it's late at

00:12:59,940 --> 00:13:03,360
night and we're just not happy at all

00:13:01,829 --> 00:13:07,350
about having been called up to fix

00:13:03,360 --> 00:13:09,480
somebody else's mess a clever lad called

00:13:07,350 --> 00:13:13,769
cap ping Yi has created a module to help

00:13:09,480 --> 00:13:14,910
us out so we go into our this code that

00:13:13,769 --> 00:13:16,410
we're trying to figure out what's going

00:13:14,910 --> 00:13:18,360
on and we put in a print statement right

00:13:16,410 --> 00:13:20,639
we've got the print out the web query

00:13:18,360 --> 00:13:22,670
thing or whatever but the problem is we

00:13:20,639 --> 00:13:25,139
have no idea where standardout is going

00:13:22,670 --> 00:13:26,370
so then we maybe we try standard error

00:13:25,139 --> 00:13:28,050
because that'll go to the log file right

00:13:26,370 --> 00:13:29,220
except it doesn't end up in another

00:13:28,050 --> 00:13:31,139
server we can't figure out where the

00:13:29,220 --> 00:13:32,399
server logs are or it's just not

00:13:31,139 --> 00:13:36,569
appearing as being squashed or it

00:13:32,399 --> 00:13:39,389
crashes the server that's fun too so we

00:13:36,569 --> 00:13:41,430
try logging but serious there is so many

00:13:39,389 --> 00:13:42,839
ways that this can fail I mean you don't

00:13:41,430 --> 00:13:44,310
know where the logs gonna go you don't

00:13:42,839 --> 00:13:46,889
know what the logging level is set to

00:13:44,310 --> 00:13:50,730
it's you know it's just complete joke so

00:13:46,889 --> 00:13:53,519
ping invented cue you pip install cue

00:13:50,730 --> 00:13:55,470
and then at where you want to inspect

00:13:53,519 --> 00:13:58,740
something in the code you say import cue

00:13:55,470 --> 00:14:02,189
khufu and that will dump out to a file

00:13:58,740 --> 00:14:04,970
in slash temp called cue a thing saying

00:14:02,189 --> 00:14:09,810
foo equals and its value

00:14:04,970 --> 00:14:11,400
so some code like this when run you know

00:14:09,810 --> 00:14:14,160
we call spam twice with a couple of

00:14:11,400 --> 00:14:15,600
different values the Q module will tell

00:14:14,160 --> 00:14:18,150
us what the expression was that we

00:14:15,600 --> 00:14:19,500
inspected with Q could by calling Q and

00:14:18,150 --> 00:14:21,170
it'll tell us the value and it'll tell

00:14:19,500 --> 00:14:25,110
us the function that always called in

00:14:21,170 --> 00:14:26,430
that's really handy it also has another

00:14:25,110 --> 00:14:28,620
behavior where if you use this as a

00:14:26,430 --> 00:14:31,500
decorator and decorate a function with Q

00:14:28,620 --> 00:14:33,360
it'll trace some information about how

00:14:31,500 --> 00:14:40,380
that function was called and what its

00:14:33,360 --> 00:14:42,150
return value was so again same example

00:14:40,380 --> 00:14:44,100
but decorating the spam functioned at

00:14:42,150 --> 00:14:45,330
this time we see it's called with

00:14:44,100 --> 00:14:49,860
different arguments return different

00:14:45,330 --> 00:14:51,630
values and the inspections inside the

00:14:49,860 --> 00:14:54,150
function are indented nicely as well

00:14:51,630 --> 00:14:56,279
it's clever if the return value is huge

00:14:54,150 --> 00:14:58,290
so if you're doing this on an actual web

00:14:56,279 --> 00:15:01,230
application you're returning a chunk of

00:14:58,290 --> 00:15:03,270
HTML which is huge it will just say okay

00:15:01,230 --> 00:15:05,640
that's a big amount of content it's in

00:15:03,270 --> 00:15:09,870
this file here so it stalls it away in

00:15:05,640 --> 00:15:11,370
slash temp in a different file but you

00:15:09,870 --> 00:15:14,970
may have noticed there's probably some

00:15:11,370 --> 00:15:18,240
funky stuff going on here with Q one of

00:15:14,970 --> 00:15:21,510
the things that it's doing is that okay

00:15:18,240 --> 00:15:23,310
who's familiar with decorators right in

00:15:21,510 --> 00:15:24,000
the basic idea as decorators or things

00:15:23,310 --> 00:15:27,450
that are called

00:15:24,000 --> 00:15:29,940
on functions okay so how do we know when

00:15:27,450 --> 00:15:31,770
it's been called as a thing to dump out

00:15:29,940 --> 00:15:34,200
a value or when it's being called as a

00:15:31,770 --> 00:15:39,540
decorator well that's what this code

00:15:34,200 --> 00:15:41,220
does this determines whether we're being

00:15:39,540 --> 00:15:43,170
invoked as a decorator or just as some

00:15:41,220 --> 00:15:47,430
value dumping function with a callable

00:15:43,170 --> 00:15:49,560
argument it walks up the call stack to

00:15:47,430 --> 00:15:51,990
see where by loop and looks at the

00:15:49,560 --> 00:15:55,440
actual source code of the call site and

00:15:51,990 --> 00:15:57,950
if the source code says at Q then we're

00:15:55,440 --> 00:15:57,950
a decorator

00:15:58,090 --> 00:16:04,640
it's perfectly reasonable okay Q does a

00:16:03,650 --> 00:16:07,430
bunch of other stuff that we'll come

00:16:04,640 --> 00:16:16,460
back to oh let's take another version

00:16:07,430 --> 00:16:18,110
this is Java don't do this okay so back

00:16:16,460 --> 00:16:20,150
when I was teaching Python at university

00:16:18,110 --> 00:16:22,640
I had a student who asked me how to do

00:16:20,150 --> 00:16:25,040
overloading of methods like Java does so

00:16:22,640 --> 00:16:27,380
for those not familiar with Java it

00:16:25,040 --> 00:16:29,510
allows you to have multiple methods with

00:16:27,380 --> 00:16:33,320
the same name and different signatures

00:16:29,510 --> 00:16:35,660
and when you invoke the method Java

00:16:33,320 --> 00:16:38,270
figures out which implementation to use

00:16:35,660 --> 00:16:41,510
based on the arguments you pass to the

00:16:38,270 --> 00:16:43,160
function or them to method so he asked

00:16:41,510 --> 00:16:44,720
me how you do this and I said we Python

00:16:43,160 --> 00:16:46,610
doesn't do it that you know it doesn't

00:16:44,720 --> 00:16:48,860
work that way we do mutability of

00:16:46,610 --> 00:16:51,470
arguments a different way and I have a

00:16:48,860 --> 00:16:58,310
thing I said I'll get back to you next

00:16:51,470 --> 00:17:00,920
week so then I wrote overload which

00:16:58,310 --> 00:17:03,050
allows you to overload methods so you

00:17:00,920 --> 00:17:04,790
decorate the first method of that name

00:17:03,050 --> 00:17:06,579
say this is you know this is the first

00:17:04,790 --> 00:17:09,110
implementation then you add other

00:17:06,579 --> 00:17:12,110
implementations of the method to the

00:17:09,110 --> 00:17:14,600
overloading and then when the method is

00:17:12,110 --> 00:17:17,300
invoked we figure out which arguments

00:17:14,600 --> 00:17:20,089
match which particular signature and the

00:17:17,300 --> 00:17:22,339
correct one is called you can overload

00:17:20,089 --> 00:17:25,180
functions as well and you can use

00:17:22,339 --> 00:17:27,650
function nu to annotations in Python 3

00:17:25,180 --> 00:17:30,320
and it'll make sure that the types match

00:17:27,650 --> 00:17:34,070
you can even overload class methods and

00:17:30,320 --> 00:17:37,250
static methods and classes if you really

00:17:34,070 --> 00:17:40,280
want to and it uses a bunch of really

00:17:37,250 --> 00:17:42,740
neat introspection that Python offers so

00:17:40,280 --> 00:17:44,570
functions for example they have add

00:17:42,740 --> 00:17:46,310
under defaults attribute which tell you

00:17:44,570 --> 00:17:50,060
the default values that were defined

00:17:46,310 --> 00:17:52,520
when the function was defined when the

00:17:50,060 --> 00:17:55,190
function was created the functions code

00:17:52,520 --> 00:17:56,960
object tells you how many arguments that

00:17:55,190 --> 00:18:00,740
code object is expecting to be passed

00:17:56,960 --> 00:18:02,930
and what their names are we match

00:18:00,740 --> 00:18:04,910
arguments passed into the function to

00:18:02,930 --> 00:18:07,070
the function signature using basically

00:18:04,910 --> 00:18:08,930
the same method as just a regular

00:18:07,070 --> 00:18:10,610
function call but trying to find the

00:18:08,930 --> 00:18:12,049
first function signature

00:18:10,610 --> 00:18:14,360
that accepts the arguments are actually

00:18:12,049 --> 00:18:18,020
being passed in so for each element in

00:18:14,360 --> 00:18:19,520
the arc account we pop an element off of

00:18:18,020 --> 00:18:21,530
the arguments that have been passed in

00:18:19,520 --> 00:18:23,480
and if there's none of those left then

00:18:21,530 --> 00:18:24,350
we can walk up keyword arguments based

00:18:23,480 --> 00:18:28,490
on the Arg

00:18:24,350 --> 00:18:30,080
the VAR names we can also look at the

00:18:28,490 --> 00:18:33,799
functions annotations which is a

00:18:30,080 --> 00:18:36,110
dictionary that gives us I think it's no

00:18:33,799 --> 00:18:38,870
sorry we can look up the named arguments

00:18:36,110 --> 00:18:41,960
using the in the annotations dictionary

00:18:38,870 --> 00:18:44,240
to see whether whether there is an

00:18:41,960 --> 00:18:46,010
annotation and if the annotation is a

00:18:44,240 --> 00:18:47,960
type object then we make sure that the

00:18:46,010 --> 00:18:52,460
type matches the argument that's been

00:18:47,960 --> 00:18:54,710
passed in the code object has some flags

00:18:52,460 --> 00:18:57,380
this one says that the code object

00:18:54,710 --> 00:19:01,669
accepts variable arguments so star args

00:18:57,380 --> 00:19:05,200
and this one says that it accepts

00:19:01,669 --> 00:19:07,790
variable keywords so star star keywords

00:19:05,200 --> 00:19:10,940
and once we've matched the instance

00:19:07,790 --> 00:19:12,440
sorry match the the implementation hap

00:19:10,940 --> 00:19:14,690
that have will happily accept all the

00:19:12,440 --> 00:19:17,360
arguments that have been passed in we

00:19:14,690 --> 00:19:18,650
can call it we do have to throw in

00:19:17,360 --> 00:19:20,090
another additional hack in there because

00:19:18,650 --> 00:19:22,070
static methods and class methods

00:19:20,090 --> 00:19:23,870
actually have a kind of a proxy sort of

00:19:22,070 --> 00:19:25,790
a thing that means they're not actually

00:19:23,870 --> 00:19:31,520
the thing that you want to call but it's

00:19:25,790 --> 00:19:34,010
it's pretty straightforward okay so back

00:19:31,520 --> 00:19:35,059
to the cue module it's really neat but

00:19:34,010 --> 00:19:41,110
there's something not quite right about

00:19:35,059 --> 00:19:41,110
it who can see what's wrong with this

00:19:42,309 --> 00:19:49,910
modules aren't callable okay to make

00:19:47,900 --> 00:19:52,419
this work the cue module results to a

00:19:49,910 --> 00:19:52,419
bit of a hack

00:19:54,030 --> 00:19:58,710
the implementation of what the queue

00:19:56,670 --> 00:20:01,260
module does is encapsulated in the queue

00:19:58,710 --> 00:20:02,820
class so what we're doing here is we're

00:20:01,260 --> 00:20:05,640
taking an instance of that class and

00:20:02,820 --> 00:20:07,440
replacing the module in system modules

00:20:05,640 --> 00:20:11,940
with an instance of that class

00:20:07,440 --> 00:20:14,130
this has some side-effects most notably

00:20:11,940 --> 00:20:17,570
as soon as you replace the module insist

00:20:14,130 --> 00:20:19,620
modules the module is garbage collected

00:20:17,570 --> 00:20:21,510
because there's no references to it

00:20:19,620 --> 00:20:23,160
anymore the queue class does not keep a

00:20:21,510 --> 00:20:25,410
reference to its module the import

00:20:23,160 --> 00:20:28,140
hasn't completed so the thing that did

00:20:25,410 --> 00:20:28,830
the import hasn't got a handle yet so it

00:20:28,140 --> 00:20:31,140
goes away

00:20:28,830 --> 00:20:33,600
so therefore the queue class has a bunch

00:20:31,140 --> 00:20:35,280
of really yucky hacks in it so all of

00:20:33,600 --> 00:20:38,100
the imports are done in the class

00:20:35,280 --> 00:20:39,960
statement itself the class definition so

00:20:38,100 --> 00:20:43,140
all the modules are imported that it

00:20:39,960 --> 00:20:45,150
uses are all class attributes it has to

00:20:43,140 --> 00:20:47,970
define a dunder name attribute so it can

00:20:45,150 --> 00:20:49,860
pretend to be a module so that Google

00:20:47,970 --> 00:20:52,320
App Engine is happy and there's a bunch

00:20:49,860 --> 00:20:54,870
of other stuff in there as well so I

00:20:52,320 --> 00:20:58,860
propose there's an alternative we just

00:20:54,870 --> 00:21:00,960
need to make modules callable so given a

00:20:58,860 --> 00:21:03,840
thing that we can call hello world py

00:21:00,960 --> 00:21:05,760
let's import callable modules enable

00:21:03,840 --> 00:21:09,510
callable modules and then we can define

00:21:05,760 --> 00:21:11,610
a dunder call mirror function and when

00:21:09,510 --> 00:21:15,980
we import hello world we can invoke

00:21:11,610 --> 00:21:15,980
hello world and it's callable hey presto

00:21:16,970 --> 00:21:22,020
I'd actually argue that this is

00:21:19,200 --> 00:21:24,810
something that is actually not that bad

00:21:22,020 --> 00:21:29,600
an idea the idea that is of having

00:21:24,810 --> 00:21:32,430
special these dunder methods as class

00:21:29,600 --> 00:21:34,970
function as sorry as module functions

00:21:32,430 --> 00:21:37,500
it's actually kind of handy and useful

00:21:34,970 --> 00:21:41,250
it'll never fly but I think it's a good

00:21:37,500 --> 00:21:45,240
idea so how does callable modules enable

00:21:41,250 --> 00:21:47,430
work that's kind of weird okay so the

00:21:45,240 --> 00:21:51,690
handling of call ability is done at the

00:21:47,430 --> 00:21:54,000
type's level as in c-types level every

00:21:51,690 --> 00:21:57,960
built-in type like int sand modules have

00:21:54,000 --> 00:22:00,000
a PI type object see structure call

00:21:57,960 --> 00:22:02,850
ability is implemented through a slot in

00:22:00,000 --> 00:22:04,620
that structure called TP underscore call

00:22:02,850 --> 00:22:06,370
which you can see just down the bottom

00:22:04,620 --> 00:22:09,690
here it's a ternary func

00:22:06,370 --> 00:22:12,250
it's appointed to a tee see function

00:22:09,690 --> 00:22:14,980
that is invoked when objects of that

00:22:12,250 --> 00:22:17,919
type are called if it's not set that is

00:22:14,980 --> 00:22:21,520
if it's null then objects of that type

00:22:17,919 --> 00:22:23,679
are not callable so we need to provide a

00:22:21,520 --> 00:22:25,570
callable for the TP call slot that

00:22:23,679 --> 00:22:28,059
implements ternary func that that

00:22:25,570 --> 00:22:33,330
signature ternary func and a way to

00:22:28,059 --> 00:22:36,700
assign it to that slot using c types so

00:22:33,330 --> 00:22:40,210
first up we have to define the callback

00:22:36,700 --> 00:22:42,580
so we define the ternary func thing the

00:22:40,210 --> 00:22:45,220
C like we have to define the C level API

00:22:42,580 --> 00:22:47,020
for C types for the ternary func

00:22:45,220 --> 00:22:50,110
callback and then we define a very

00:22:47,020 --> 00:22:51,760
simple callback Python function which

00:22:50,110 --> 00:22:54,370
will be called which we'll use as that

00:22:51,760 --> 00:22:56,529
callback and that just implements

00:22:54,370 --> 00:22:59,200
calling dunder call on the object that

00:22:56,529 --> 00:23:01,830
the callback is being invoked on which

00:22:59,200 --> 00:23:03,970
in this case the object will be a module

00:23:01,830 --> 00:23:06,520
the C type Slayer does some interesting

00:23:03,970 --> 00:23:08,409
things with Python callbacks for C

00:23:06,520 --> 00:23:09,700
functions that I won't go into the

00:23:08,409 --> 00:23:12,909
nitty-gritty details right now but

00:23:09,700 --> 00:23:15,250
suffice to say that the see the the

00:23:12,909 --> 00:23:18,250
ternary func takes one two three four

00:23:15,250 --> 00:23:20,620
yeah one two three four Python objects

00:23:18,250 --> 00:23:23,649
except the last one is optional so it

00:23:20,620 --> 00:23:25,990
might be null so it can't declare it as

00:23:23,649 --> 00:23:28,360
PI object I have to declare it as C void

00:23:25,990 --> 00:23:31,960
P and then do some casting stuff down

00:23:28,360 --> 00:23:32,919
here anyway it's just a bit pretty it

00:23:31,960 --> 00:23:35,289
took me a little while to figure that

00:23:32,919 --> 00:23:36,850
out but I got there okay so once we've

00:23:35,289 --> 00:23:39,820
got that then we need to define the

00:23:36,850 --> 00:23:41,380
structure for the type object or at

00:23:39,820 --> 00:23:43,179
least enough of it so we can get down to

00:23:41,380 --> 00:23:45,610
the TP call bit we don't really care

00:23:43,179 --> 00:23:47,140
about the rest we just need to know what

00:23:45,610 --> 00:23:49,210
the offset is so hence everything else

00:23:47,140 --> 00:23:51,039
is a void P is just a pointer that we

00:23:49,210 --> 00:23:55,000
don't care about we just need to be able

00:23:51,039 --> 00:23:57,460
to assign to the TP call slot we also

00:23:55,000 --> 00:24:01,870
need PI object defined so that we can

00:23:57,460 --> 00:24:03,130
actually get to the type object PI

00:24:01,870 --> 00:24:07,419
object is actually really interesting it

00:24:03,130 --> 00:24:09,710
only has to two slots it's kind of neat

00:24:07,419 --> 00:24:12,980
so once we have all those parts in place

00:24:09,710 --> 00:24:15,500
we can modify the module type to make

00:24:12,980 --> 00:24:17,090
its instances callable and we get to the

00:24:15,500 --> 00:24:18,980
module type through set well we've

00:24:17,090 --> 00:24:22,690
already imported c types so we mars use

00:24:18,980 --> 00:24:26,059
that as our module of choice the ID

00:24:22,690 --> 00:24:30,470
function tells us the memory location of

00:24:26,059 --> 00:24:32,450
the pi object in c and so we can grab

00:24:30,470 --> 00:24:34,190
the pi object using that address and

00:24:32,450 --> 00:24:37,130
then we do a few modifications hey

00:24:34,190 --> 00:24:40,669
presto we can assign our module call and

00:24:37,130 --> 00:24:42,260
so we can import callable modules we can

00:24:40,669 --> 00:24:44,809
do all of our seams we can import string

00:24:42,260 --> 00:24:49,780
attach a call to it and then we can

00:24:44,809 --> 00:24:51,890
invoke the string module so that's neat

00:24:49,780 --> 00:24:55,210
it's a little bit wrong but it's neat

00:24:51,890 --> 00:24:55,210
okay we're not done yet

00:24:58,539 --> 00:25:05,210
so using similar c types hackery we can

00:25:02,090 --> 00:25:06,980
modify built-in types to add new

00:25:05,210 --> 00:25:09,830
attributes and this is actually been

00:25:06,980 --> 00:25:11,659
done by somebody else and it's in called

00:25:09,830 --> 00:25:14,720
forbidden fruit and it's on github if

00:25:11,659 --> 00:25:17,270
you really want to look it up it defines

00:25:14,720 --> 00:25:19,429
a function called curse and we can use

00:25:17,270 --> 00:25:20,960
curse to add new attributes to things

00:25:19,429 --> 00:25:23,210
like the in table jekt so here for

00:25:20,960 --> 00:25:25,610
example we're adding days to the in

00:25:23,210 --> 00:25:28,970
table jekt returns a time delta of that

00:25:25,610 --> 00:25:31,760
in value of days and we can curse time

00:25:28,970 --> 00:25:34,789
Delta which is also a built-in object to

00:25:31,760 --> 00:25:37,880
return a go so that's kind of neat we

00:25:34,789 --> 00:25:40,730
can say 12 days ago this is inspired

00:25:37,880 --> 00:25:45,679
directly from Ruby land of course and

00:25:40,730 --> 00:25:48,409
it's a little bit wrong that's all I

00:25:45,679 --> 00:25:50,570
have prepared for you today I would like

00:25:48,409 --> 00:25:52,730
to say thank you to Ryan Kelly and Nick

00:25:50,570 --> 00:25:56,000
Coughlin for their assistance in

00:25:52,730 --> 00:25:58,640
developing this talk and I do have some

00:25:56,000 --> 00:26:00,669
time for questions although I have no

00:25:58,640 --> 00:26:05,049
idea what your questions might be and

00:26:00,669 --> 00:26:05,049
horeca danced them but please feel free

00:26:12,429 --> 00:26:15,980
I'm not sure whether to phrase this is a

00:26:14,539 --> 00:26:18,770
question or a statement I'm gonna go

00:26:15,980 --> 00:26:21,409
with statement please tell me you have

00:26:18,770 --> 00:26:31,100
not used these in production oh hell no

00:26:21,409 --> 00:26:33,470
although cue yes why because it's taken

00:26:31,100 --> 00:26:42,320
a lot of fun I had so much fun making

00:26:33,470 --> 00:26:44,510
this okay so moderately seriously the

00:26:42,320 --> 00:26:45,980
reason why all this stuff is possible is

00:26:44,510 --> 00:26:47,809
because Python he's an incredibly

00:26:45,980 --> 00:26:49,130
reflective language and has all these

00:26:47,809 --> 00:26:50,659
internal hooks which are useful for

00:26:49,130 --> 00:26:51,919
things like debuggers to get into it can

00:26:50,659 --> 00:26:53,390
be useful for various reasons now you've

00:26:51,919 --> 00:26:55,159
obviously shown the worst possible

00:26:53,390 --> 00:26:58,399
examples of okay god what the hell are

00:26:55,159 --> 00:26:59,690
you doing but I've tried yeah I mean

00:26:58,399 --> 00:27:00,500
some of this is just a case of with

00:26:59,690 --> 00:27:02,929
great power comes great responsibility

00:27:00,500 --> 00:27:05,090
so there's not really a reason to take

00:27:02,929 --> 00:27:08,480
any B's out of the language it's it's

00:27:05,090 --> 00:27:09,830
just actually well and and a lot of

00:27:08,480 --> 00:27:12,590
these things have been added to Python

00:27:09,830 --> 00:27:14,570
over time things that like things like

00:27:12,590 --> 00:27:16,100
the the mutable local and global

00:27:14,570 --> 00:27:18,470
namespaces they weren't originally

00:27:16,100 --> 00:27:21,590
that's been added and it's incredibly

00:27:18,470 --> 00:27:23,149
useful the ast stuff is a recent thing

00:27:21,590 --> 00:27:25,190
as well you know that's been added and

00:27:23,149 --> 00:27:26,690
that's incredibly useful and you can do

00:27:25,190 --> 00:27:28,220
good things with it you can do you know

00:27:26,690 --> 00:27:31,580
stupid things with the - and that's what

00:27:28,220 --> 00:27:33,409
I focused on that's fine actually do

00:27:31,580 --> 00:27:34,760
have a use case by the way for callable

00:27:33,409 --> 00:27:36,049
modules and I'll walk you through

00:27:34,760 --> 00:27:40,490
because I've got a couple of minutes so

00:27:36,049 --> 00:27:43,220
I have this I have this module I wrote

00:27:40,490 --> 00:27:47,929
called HTML and it's pretty basic it

00:27:43,220 --> 00:27:50,390
just allows you to create HTML text from

00:27:47,929 --> 00:27:53,059
Python code using a relatively nice

00:27:50,390 --> 00:27:58,909
syntax you grab a hatch GML object you

00:27:53,059 --> 00:28:00,590
say HTML body dot p with some text

00:27:58,909 --> 00:28:02,899
passed in when you call it with some

00:28:00,590 --> 00:28:05,419
text and that'll create a HTML document

00:28:02,899 --> 00:28:07,850
which has a HTML tag a body tag and a P

00:28:05,419 --> 00:28:09,289
tag with some text inside it it has

00:28:07,850 --> 00:28:13,880
attributes and has other stuff it's

00:28:09,289 --> 00:28:15,529
really nice and I wrote it to be Python

00:28:13,880 --> 00:28:18,409
too and pythons free compatible so it

00:28:15,529 --> 00:28:22,549
can actually run under both the problem

00:28:18,409 --> 00:28:24,360
is Python 3 decided to co-opt the HTML

00:28:22,549 --> 00:28:28,799
namespace for itself

00:28:24,360 --> 00:28:34,049
so in the Python 3 standard library HTML

00:28:28,799 --> 00:28:36,360
dot quote I think is the module no sorry

00:28:34,049 --> 00:28:39,270
the HTML is the module and it has things

00:28:36,360 --> 00:28:40,530
like quote and unquote I think are the

00:28:39,270 --> 00:28:43,950
names of the functions that are defined

00:28:40,530 --> 00:28:47,400
inside it and because HTML has been

00:28:43,950 --> 00:28:50,010
defined as a module nobody else can use

00:28:47,400 --> 00:28:52,200
the HTML namespace to implement a

00:28:50,010 --> 00:28:56,250
package which i think is a bit of a

00:28:52,200 --> 00:28:59,130
shame now if we talk those two functions

00:28:56,250 --> 00:29:04,110
out of the h2 module HTML module we made

00:28:59,130 --> 00:29:06,299
HTML a package and quote and unquote

00:29:04,110 --> 00:29:09,419
were just modules that were callable

00:29:06,299 --> 00:29:12,120
then I could create a you know write

00:29:09,419 --> 00:29:14,280
module HTML write module that could be

00:29:12,120 --> 00:29:17,760
installed in the namespace alongside

00:29:14,280 --> 00:29:19,350
them and that would be neat and also Q

00:29:17,760 --> 00:29:21,540
you know ping wouldn't have to resort to

00:29:19,350 --> 00:29:23,630
these ugly ugly hacks to make Q callable

00:29:21,540 --> 00:29:25,890
so I think there's a valid you know

00:29:23,630 --> 00:29:40,440
justification for it but I really don't

00:29:25,890 --> 00:29:43,020
think I'm gonna win the argument are

00:29:40,440 --> 00:29:48,179
there any other questions oh wait a

00:29:43,020 --> 00:29:49,470
second oh sorry if you've ever

00:29:48,179 --> 00:29:51,450
programmed

00:29:49,470 --> 00:29:54,570
programmed in Java before you might have

00:29:51,450 --> 00:29:57,419
this strange idea that a file should

00:29:54,570 --> 00:29:59,340
correlate to a class and then if you try

00:29:57,419 --> 00:30:03,030
and translate this idea into Java you

00:29:59,340 --> 00:30:06,270
always have in your imports say from

00:30:03,030 --> 00:30:08,910
site import capital site so I'm

00:30:06,270 --> 00:30:11,280
wondering if if it would be a good or

00:30:08,910 --> 00:30:13,530
bad idea depending on your what there's

00:30:11,280 --> 00:30:15,000
an awful lot of overload is another

00:30:13,530 --> 00:30:16,740
example there's an awful lot of modules

00:30:15,000 --> 00:30:18,480
out there Python modules they do one

00:30:16,740 --> 00:30:19,950
thing and they have one thing that's

00:30:18,480 --> 00:30:22,380
callable inside them so there's always

00:30:19,950 --> 00:30:24,270
from overload import overload from queue

00:30:22,380 --> 00:30:26,040
import cute all these things all do this

00:30:24,270 --> 00:30:29,309
from something import the thing that

00:30:26,040 --> 00:30:30,350
does something so shortly be a good idea

00:30:29,309 --> 00:30:32,899
to

00:30:30,350 --> 00:30:35,649
make that a little more convenience yeah

00:30:32,899 --> 00:30:38,750
I still don't think it's gonna happen

00:30:35,649 --> 00:30:41,470
another anyway yeah I'm not gonna go

00:30:38,750 --> 00:30:44,990
into the curly quotes as valid Python

00:30:41,470 --> 00:30:47,139
yes let's not thank you again Richard

00:30:44,990 --> 00:30:47,139

YouTube URL: https://www.youtube.com/watch?v=H2yfXnUb1S4


