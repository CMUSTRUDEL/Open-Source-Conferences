Title: Python for bridging between researchers and service operators: from CFFI to Jupyterhub
Publication date: 2016-08-16
Playlist: Science & Data 2016 (Miniconf)
Description: 
	Kevin Plastow
https://2016.pycon-au.org/schedule/108/view_talk
This talk will give an overview of a water forecasting system, which exposes via Python a suite of tools developed in C++ for hydrologists to use. 

PySWIFT is a Python software system that allows the use of SWIFT (Short-term Water Information and Forecasting Tools), a hydrologic suite of tools for flood and short-term streamflow forecasting.

When integrating the SWIFT C++ system with Python, we aimed to achieve two main goals: 
1. Provide a productive and interactive environment for hydrological modelling.
2. Take advantage of a complex multi-threaded C++ suite of tools that enables rapid execution.

To achieve the first goal, we created a modelling environment using JupyterHub. In this environment, modellers can set up, run, inspect and modify models, which is ideal to conduct exploratory experiments with the models. 
To achieve the second goal, we used CFFI to create a Python wrapper for SWIFT’s API. CFFI allows us to interact with SWIFT’s C interface. 

In this presentation, we will highlight the challenges and learnings that came about whilst building this system.
Captions: 
	00:00:00,410 --> 00:00:04,799
okay we'll get started my name is Alan

00:00:03,210 --> 00:00:07,230
Rubin I'm the chair for this second

00:00:04,799 --> 00:00:08,730
session here at the science and data

00:00:07,230 --> 00:00:11,490
mini conference our first speaker today

00:00:08,730 --> 00:00:12,960
is Kevin pasta Kevin's a Python

00:00:11,490 --> 00:00:15,179
developer at the Bureau of Meteorology

00:00:12,960 --> 00:00:17,880
working in the extended hydrological

00:00:15,179 --> 00:00:20,189
prediction unit so please welcome Kevin

00:00:17,880 --> 00:00:21,510
and his talk is Python for bridging

00:00:20,189 --> 00:00:34,649
between researchers and service

00:00:21,510 --> 00:00:38,190
operators Thank You max working ok so

00:00:34,649 --> 00:00:42,120
this stuff will be about using Python in

00:00:38,190 --> 00:00:45,329
the context of hydrology and for

00:00:42,120 --> 00:00:48,329
streamflow forecasting so the goal here

00:00:45,329 --> 00:00:52,949
is to focus how much water will flow

00:00:48,329 --> 00:00:55,530
through Australian rivers I just want to

00:00:52,949 --> 00:01:00,719
acknowledge my co-authors here David

00:00:55,530 --> 00:01:05,519
Kent Andrew McDonald and the auction so

00:01:00,719 --> 00:01:11,460
the introduction so this talk

00:01:05,519 --> 00:01:14,360
technically is about software system C++

00:01:11,460 --> 00:01:17,130
software system called Swift and

00:01:14,360 --> 00:01:21,689
wrapping that software system in Python

00:01:17,130 --> 00:01:24,360
through a sea interface first I'll touch

00:01:21,689 --> 00:01:27,900
on what Swift is about what features in

00:01:24,360 --> 00:01:29,460
implements and then i'll go through pi

00:01:27,900 --> 00:01:33,299
Swift you know what we are bringing in

00:01:29,460 --> 00:01:37,290
with python and by swift and then i'll

00:01:33,299 --> 00:01:42,000
go through a specific example on a

00:01:37,290 --> 00:01:43,979
feature that we implement in Swift from

00:01:42,000 --> 00:01:46,290
front by Swift so i'll start with

00:01:43,979 --> 00:01:51,409
notebooks and go through more of the

00:01:46,290 --> 00:01:53,610
implementation details cff I and Python

00:01:51,409 --> 00:01:57,240
this is the Bureau of Meteorology

00:01:53,610 --> 00:02:00,719
website are mostly used for weather

00:01:57,240 --> 00:02:04,530
information but she go down here you'll

00:02:00,719 --> 00:02:08,610
see a water information link just click

00:02:04,530 --> 00:02:11,489
there you get to this page I'm order

00:02:08,610 --> 00:02:12,420
information a page let's go down here

00:02:11,489 --> 00:02:14,640
again

00:02:12,420 --> 00:02:16,860
and you'll see here in the water

00:02:14,640 --> 00:02:19,500
forecast section the seven-day

00:02:16,860 --> 00:02:21,140
streamflow forecasts so that seven-day

00:02:19,500 --> 00:02:24,230
streamflow forecast is a service that

00:02:21,140 --> 00:02:27,840
provides streamflow forecasts up to

00:02:24,230 --> 00:02:31,319
seven days lead time to assist river

00:02:27,840 --> 00:02:36,120
users in decision making just click on

00:02:31,319 --> 00:02:38,610
here they are more than 100 forecast

00:02:36,120 --> 00:02:41,340
locations across Australia for this

00:02:38,610 --> 00:02:44,459
service if you go down here you'll see

00:02:41,340 --> 00:02:48,209
here this is the streamflow forecasts

00:02:44,459 --> 00:02:51,540
and this streamflow forecasts is the

00:02:48,209 --> 00:02:55,410
output of swift so just the data is the

00:02:51,540 --> 00:02:58,590
output of Swift this is from Swift

00:02:55,410 --> 00:03:00,959
version 1 which was written in Fortran

00:02:58,590 --> 00:03:04,350
but there's a new version of Swift which

00:03:00,959 --> 00:03:06,989
is Swift version 2 and it's written in

00:03:04,350 --> 00:03:10,380
C++ and this will be the focus of my

00:03:06,989 --> 00:03:14,180
talk so Swift stands for short-term

00:03:10,380 --> 00:03:19,950
water information and forecasting tools

00:03:14,180 --> 00:03:24,359
this is the basic way it is used this is

00:03:19,950 --> 00:03:29,070
rainfall so just a time series and other

00:03:24,359 --> 00:03:31,380
inputs as well goes into Swift so c++

00:03:29,070 --> 00:03:33,959
Swift is developed Swift is developed by

00:03:31,380 --> 00:03:36,720
csr oh and is used by the bureau through

00:03:33,959 --> 00:03:40,739
a agreement between the two

00:03:36,720 --> 00:03:45,209
organizations so Swift does it thing and

00:03:40,739 --> 00:03:47,070
you get streamflow as an output so this

00:03:45,209 --> 00:03:50,070
is a bit you know it's more complex than

00:03:47,070 --> 00:03:58,769
that actually but i'll skip on the

00:03:50,070 --> 00:04:01,290
details um swift features so sweet has

00:03:58,769 --> 00:04:03,540
many different models that it uses

00:04:01,290 --> 00:04:07,560
rainfall runoff models channel routing

00:04:03,540 --> 00:04:10,739
models error correction models and all

00:04:07,560 --> 00:04:12,840
these models have parameters and two

00:04:10,739 --> 00:04:14,190
main modes so simulation forecast is

00:04:12,840 --> 00:04:16,979
what I showed you in the previous slide

00:04:14,190 --> 00:04:21,959
and calibration is basically a loop loop

00:04:16,979 --> 00:04:25,770
around the simulation so in calibration

00:04:21,959 --> 00:04:28,889
the point is to get the some correct

00:04:25,770 --> 00:04:32,400
it is the best parameters for the models

00:04:28,889 --> 00:04:34,650
in order to deliver a good forecast so

00:04:32,400 --> 00:04:38,699
to do calibration what we do is we pick

00:04:34,650 --> 00:04:41,879
some parameters we set those parameters

00:04:38,699 --> 00:04:45,509
on the models run the models and then

00:04:41,879 --> 00:04:49,110
check the output and then start again so

00:04:45,509 --> 00:04:51,389
the quality of the forecast improves and

00:04:49,110 --> 00:04:53,190
then once the parameters stop changing

00:04:51,389 --> 00:04:56,970
we stop the calibration so that

00:04:53,190 --> 00:05:00,030
calibration is a computationally

00:04:56,970 --> 00:05:04,259
intensive process so we need we really

00:05:00,030 --> 00:05:08,069
need it to to be optimized and to do

00:05:04,259 --> 00:05:12,090
that the system is multi-threaded and it

00:05:08,069 --> 00:05:15,750
you know makes makes use of a memory

00:05:12,090 --> 00:05:17,400
management in an efficient way so it

00:05:15,750 --> 00:05:19,469
also has a complex representation of

00:05:17,400 --> 00:05:21,810
catchments for this talk I'll just you

00:05:19,469 --> 00:05:26,280
know say catchment is just a single area

00:05:21,810 --> 00:05:28,259
but actually has a lot of sub elements

00:05:26,280 --> 00:05:30,509
so it's basically a shame chain of

00:05:28,259 --> 00:05:36,120
models like a tree and at the end you

00:05:30,509 --> 00:05:37,979
have the streamflow forecast now we we

00:05:36,120 --> 00:05:41,880
are bringing Python here because that

00:05:37,979 --> 00:05:46,409
some challenges with Swift so a typical

00:05:41,880 --> 00:05:49,349
use case for user is to load data change

00:05:46,409 --> 00:05:53,729
some model parameters run the simulation

00:05:49,349 --> 00:05:57,990
and then plot the results but to do that

00:05:53,729 --> 00:06:01,139
using Swift because it's in C++ you know

00:05:57,990 --> 00:06:05,419
the users the model is so hydrologists

00:06:01,139 --> 00:06:08,069
would need to do some memory management

00:06:05,419 --> 00:06:14,069
deal with some complex data types and so

00:06:08,069 --> 00:06:16,199
on they also the model is want to have

00:06:14,069 --> 00:06:17,969
you know some quick development so they

00:06:16,199 --> 00:06:20,340
don't want to you know do some

00:06:17,969 --> 00:06:23,250
compilation and also want to do some

00:06:20,340 --> 00:06:25,620
flooding in an efficient way so this is

00:06:23,250 --> 00:06:28,830
where pi swift comes in right abstracts

00:06:25,620 --> 00:06:32,159
all the low level data types and memory

00:06:28,830 --> 00:06:35,569
management and it has a nice interface

00:06:32,159 --> 00:06:35,569
that we can use

00:06:36,230 --> 00:06:44,040
so this diagram shows you how swifties

00:06:39,750 --> 00:06:46,230
use in a offline mode Swift is on the

00:06:44,040 --> 00:06:49,710
left by Swift so Swift is used through

00:06:46,230 --> 00:06:53,220
by Swift two main modes we can use by

00:06:49,710 --> 00:06:55,620
Swift in in an interactive way and

00:06:53,220 --> 00:06:59,220
through workflows so workflows just

00:06:55,620 --> 00:07:02,820
automate some of the use cases that are

00:06:59,220 --> 00:07:04,200
comment too many catchments but what

00:07:02,820 --> 00:07:06,930
I'll focus on is more on the interactive

00:07:04,200 --> 00:07:10,190
views so for the interactive views we

00:07:06,930 --> 00:07:12,630
use Jupiter notebooks and through them

00:07:10,190 --> 00:07:19,080
models can set up at we can test

00:07:12,630 --> 00:07:22,800
simulations this is a more detailed

00:07:19,080 --> 00:07:25,800
diagram for the interactive views on the

00:07:22,800 --> 00:07:27,630
left here you see the box is swift swift

00:07:25,800 --> 00:07:30,360
has AC interface so this interface is

00:07:27,630 --> 00:07:34,860
basically you know some types and a list

00:07:30,360 --> 00:07:37,770
of functions and so what happens is we

00:07:34,860 --> 00:07:41,400
compile this we get a shared object file

00:07:37,770 --> 00:07:46,920
leave Swift RSL and this can now be

00:07:41,400 --> 00:07:48,840
loaded in by Swift using cff I so see if

00:07:46,920 --> 00:07:54,150
if I stands for seafaring function

00:07:48,840 --> 00:07:55,830
interface I it's a Python package so

00:07:54,150 --> 00:07:58,140
through this we can call the sea

00:07:55,830 --> 00:08:00,900
functions and then PI Swift you know

00:07:58,140 --> 00:08:03,090
adds a nice interface adds a bit more

00:08:00,900 --> 00:08:06,480
functionality as well and then on the

00:08:03,090 --> 00:08:09,750
right finally is their notebooks so this

00:08:06,480 --> 00:08:12,000
is what users use so this specific

00:08:09,750 --> 00:08:14,340
example I'm going to go through now is

00:08:12,000 --> 00:08:16,320
ensemble forecasts so I showed you the

00:08:14,340 --> 00:08:18,050
first diagram I showed you what about

00:08:16,320 --> 00:08:22,740
rainfall in simulation streamflow out

00:08:18,050 --> 00:08:26,940
but now we can have more than one time

00:08:22,740 --> 00:08:28,890
series of rainfall as an input and so

00:08:26,940 --> 00:08:33,469
say in practice you might have a

00:08:28,890 --> 00:08:40,020
thousand ensemble time series and then

00:08:33,469 --> 00:08:41,969
100,000 ensemble type series output so

00:08:40,020 --> 00:08:46,040
for this example is first go through

00:08:41,969 --> 00:08:49,950
notebooks just before I showed you the

00:08:46,040 --> 00:08:53,490
the notebook so Jupiter notebook is

00:08:49,950 --> 00:08:55,020
way to execute Python code from the web

00:08:53,490 --> 00:08:58,340
browser so you can execute Python code

00:08:55,020 --> 00:09:03,150
and see some plots interactively and

00:08:58,340 --> 00:09:05,820
Jupiter hub is the multi-user version of

00:09:03,150 --> 00:09:08,580
Jupiter notebook server so this is what

00:09:05,820 --> 00:09:11,340
models models just connect to a virtual

00:09:08,580 --> 00:09:13,170
machine and see this page they just

00:09:11,340 --> 00:09:19,410
enter their credentials and then get

00:09:13,170 --> 00:09:22,410
drop into their directories so I cannot

00:09:19,410 --> 00:09:24,480
show you I cannot connect directly to

00:09:22,410 --> 00:09:26,280
that virtual machine you know the Bureau

00:09:24,480 --> 00:09:28,380
of Meteorology head office is just a few

00:09:26,280 --> 00:09:32,850
hundred meters away but I cannot get the

00:09:28,380 --> 00:09:35,430
Wi-Fi here so cannot show you this so

00:09:32,850 --> 00:09:37,620
this is what they see more or less when

00:09:35,430 --> 00:09:40,320
they log in at least a files you can

00:09:37,620 --> 00:09:43,560
browse directories here as well so I'm

00:09:40,320 --> 00:09:46,310
going to open my notebook and this is

00:09:43,560 --> 00:09:51,410
show you showing you my example above

00:09:46,310 --> 00:09:54,150
ensemble forecasts in that first sale I

00:09:51,410 --> 00:09:55,890
import pandas for you know time series

00:09:54,150 --> 00:10:02,120
representation and then some by Swift

00:09:55,890 --> 00:10:05,940
components second one I'm loading some

00:10:02,120 --> 00:10:11,520
synthetic rainfall forecast data so I'm

00:10:05,940 --> 00:10:15,240
plotting it here on the exes you can in

00:10:11,520 --> 00:10:18,630
days on y-axis is the rainfall forecast

00:10:15,240 --> 00:10:21,690
millimeter so it I've reached over over

00:10:18,630 --> 00:10:24,990
the area and you see three lines here so

00:10:21,690 --> 00:10:26,430
those are the ensemble members in

00:10:24,990 --> 00:10:28,350
practice you know you might have a

00:10:26,430 --> 00:10:31,830
thousand but just for the purpose of

00:10:28,350 --> 00:10:39,110
this presentation I only showed three

00:10:31,830 --> 00:10:43,670
here to keep things simple and down here

00:10:39,110 --> 00:10:48,480
can execute that so that first line here

00:10:43,670 --> 00:10:50,910
creates a a Python object from json file

00:10:48,480 --> 00:10:53,070
so basically what this does is when you

00:10:50,910 --> 00:10:56,370
call this function in Python it will

00:10:53,070 --> 00:11:00,690
actually call a c function with that

00:10:56,370 --> 00:11:03,779
with that argument and then what we'll

00:11:00,690 --> 00:11:07,259
get back is a pointer so cff I point

00:11:03,779 --> 00:11:12,569
that is maintained within that model

00:11:07,259 --> 00:11:15,170
simulation object I'm creating an object

00:11:12,569 --> 00:11:18,050
to do the ensemble focus simulation here

00:11:15,170 --> 00:11:21,569
setting the variable to output and

00:11:18,050 --> 00:11:25,100
running the simulation this is the

00:11:21,569 --> 00:11:30,059
output so similarly to the previous

00:11:25,100 --> 00:11:33,620
diagram x-axis is the time in days y

00:11:30,059 --> 00:11:37,199
axis is now the streamflow forecasts and

00:11:33,620 --> 00:11:42,720
you can still see those three ensemble

00:11:37,199 --> 00:11:46,410
members so this is what the data looks

00:11:42,720 --> 00:11:50,870
like underneath and what I'm going to

00:11:46,410 --> 00:11:55,019
focus on is the function c function that

00:11:50,870 --> 00:12:00,959
populates that array here so i'll go

00:11:55,019 --> 00:12:04,259
back to the presentation so I just kept

00:12:00,959 --> 00:12:06,389
that in case it didn't work and now

00:12:04,259 --> 00:12:08,699
let's go to PI Swift so in pie sweet

00:12:06,389 --> 00:12:10,610
ford we do is create an array so

00:12:08,699 --> 00:12:14,009
actually create an umpire in fight then

00:12:10,610 --> 00:12:18,569
but when we call the c function we just

00:12:14,009 --> 00:12:21,540
pass in the memory location of the

00:12:18,569 --> 00:12:24,540
contents and then we can just reuse that

00:12:21,540 --> 00:12:30,480
array so actually we're sharing the

00:12:24,540 --> 00:12:32,189
memory between Python and see let's go

00:12:30,480 --> 00:12:36,149
to the scene interface i'll come back to

00:12:32,189 --> 00:12:38,910
see ffi later on so c interface as i

00:12:36,149 --> 00:12:41,279
showed you in that example Python object

00:12:38,910 --> 00:12:45,300
maintain a reference to the c pointer

00:12:41,279 --> 00:12:48,480
and in the destructor of the python

00:12:45,300 --> 00:12:54,110
class it then calls a another function

00:12:48,480 --> 00:12:57,089
to free that memory so in that in our

00:12:54,110 --> 00:13:01,379
example function here that first

00:12:57,089 --> 00:13:05,339
argument EF simulation is a pointer to

00:13:01,379 --> 00:13:10,199
that object that we keep in the python

00:13:05,339 --> 00:13:13,410
class the next two arguments are

00:13:10,199 --> 00:13:17,190
actually not very important here I

00:13:13,410 --> 00:13:21,540
there's actually four dimensions but we

00:13:17,190 --> 00:13:24,930
index that to get to two dimensions so

00:13:21,540 --> 00:13:26,580
basically those those two are just

00:13:24,930 --> 00:13:32,070
indexing and reducing the number of

00:13:26,580 --> 00:13:36,270
dimensions so finally let's go to see if

00:13:32,070 --> 00:13:41,360
you find by Swift so this is showing you

00:13:36,270 --> 00:13:43,920
the use of cff I in a bi in line mode

00:13:41,360 --> 00:13:47,280
this is not the preferred way of doing

00:13:43,920 --> 00:13:50,400
things in CF fi there's an API mode but

00:13:47,280 --> 00:13:54,390
the advantage with this is that you

00:13:50,400 --> 00:13:57,210
don't need a compile engine step so i'm

00:13:54,390 --> 00:14:00,090
importing CF if I and on line 3 i'm

00:13:57,210 --> 00:14:02,010
declaring a header and that's what's

00:14:00,090 --> 00:14:05,100
powerful about cff I is that you can

00:14:02,010 --> 00:14:10,140
just provide your type declarations and

00:14:05,100 --> 00:14:12,630
function declarations to see if fi and

00:14:10,140 --> 00:14:14,700
it will just pass this and provide a

00:14:12,630 --> 00:14:17,670
foreign function interface interface for

00:14:14,700 --> 00:14:20,190
that online a time registering that

00:14:17,670 --> 00:14:23,280
function so in this example I'm just

00:14:20,190 --> 00:14:27,410
showing this function but in PI Swift is

00:14:23,280 --> 00:14:31,140
actually around 150 functions wrapped

00:14:27,410 --> 00:14:35,910
line 9 i'm loading that shared object

00:14:31,140 --> 00:14:38,490
file and line 11 is just a regular

00:14:35,910 --> 00:14:41,730
Python function so you can see that if

00:14:38,490 --> 00:14:44,870
cff i actually deals with our most of

00:14:41,730 --> 00:14:48,720
the simple types so variable identifier

00:14:44,870 --> 00:14:51,000
is a string lead time index the other

00:14:48,720 --> 00:14:54,090
ones are integers so you can just pass

00:14:51,000 --> 00:14:56,850
those directly to the c function but for

00:14:54,090 --> 00:14:59,400
the non pi ray to share that memory we

00:14:56,850 --> 00:15:07,920
need to do a bit more work and this is

00:14:59,400 --> 00:15:11,490
what's going on on line 15 app so this

00:15:07,920 --> 00:15:16,940
function what it does is it creates a

00:15:11,490 --> 00:15:20,160
numpy array and then it creates some

00:15:16,940 --> 00:15:25,230
some view of the underlying data that we

00:15:20,160 --> 00:15:28,370
can pass then to see so in our example

00:15:25,230 --> 00:15:30,960
then why is the number of ensembles and

00:15:28,370 --> 00:15:34,650
len x is

00:15:30,960 --> 00:15:39,930
just a number of time steps on line 9

00:15:34,650 --> 00:15:44,580
i'm creating an umpire raise so the data

00:15:39,930 --> 00:15:49,610
type dot 64 in numpy takes up eight

00:15:44,580 --> 00:15:53,040
bytes and that's the same as in c c++

00:15:49,610 --> 00:16:01,440
usually on most platform that implement

00:15:53,040 --> 00:16:08,460
the I Triple E 754 so this numpy does

00:16:01,440 --> 00:16:11,430
zero returns an array and this array I'm

00:16:08,460 --> 00:16:14,130
passing it to as contiguous array in

00:16:11,430 --> 00:16:17,760
fact as precise contiguous array here is

00:16:14,130 --> 00:16:20,670
not useful because the numpy area will

00:16:17,760 --> 00:16:24,270
be already contiguous in memory when you

00:16:20,670 --> 00:16:27,960
create it by default a SI contiguous but

00:16:24,270 --> 00:16:31,530
you can create fortran contiguous so as

00:16:27,960 --> 00:16:36,480
come to use array if the the array is

00:16:31,530 --> 00:16:40,950
already contiguous it will just you will

00:16:36,480 --> 00:16:43,110
not create a new object but we have to

00:16:40,950 --> 00:16:47,790
make sure that it's contiguous in memory

00:16:43,110 --> 00:16:52,490
before we pass it to see online 10 i'm

00:16:47,790 --> 00:16:55,020
creating a double star star in CF fi and

00:16:52,490 --> 00:17:00,500
so this will be our view to the

00:16:55,020 --> 00:17:03,300
underlying data of the number array and

00:17:00,500 --> 00:17:05,490
the good thing about values underscore

00:17:03,300 --> 00:17:08,220
see is that we don't have to worry about

00:17:05,490 --> 00:17:11,100
memory management so one once values

00:17:08,220 --> 00:17:14,040
underscore see goes out of scope the

00:17:11,100 --> 00:17:21,209
double star star pointer will just be

00:17:14,040 --> 00:17:24,089
free on line 11 and 12 I'm instantiating

00:17:21,209 --> 00:17:26,640
that double star tom so I'm just

00:17:24,089 --> 00:17:31,200
pointing I'm just getting the memory

00:17:26,640 --> 00:17:35,700
address of the underlying data of the

00:17:31,200 --> 00:17:38,809
number Ray this is what the numpy array

00:17:35,700 --> 00:17:42,399
looks like in memory

00:17:38,809 --> 00:17:49,429
and this is what values underscore see

00:17:42,399 --> 00:17:53,929
looks like now we can just pass in

00:17:49,429 --> 00:17:57,139
values on this course see to that c

00:17:53,929 --> 00:17:59,899
function but when the function returns

00:17:57,139 --> 00:18:04,370
we can just reuse NP underscore values

00:17:59,899 --> 00:18:15,049
and the its values will be modified in

00:18:04,370 --> 00:18:20,269
place by the c function okay now for the

00:18:15,049 --> 00:18:24,980
summary so by swift is a python rapper

00:18:20,269 --> 00:18:26,299
to c++ software system it has a pythonic

00:18:24,980 --> 00:18:31,399
interface and deals with low-level

00:18:26,299 --> 00:18:35,389
details in order to use by Swift we use

00:18:31,399 --> 00:18:37,460
Jupiter hub and notebooks so they have a

00:18:35,389 --> 00:18:41,360
easy-to-use interface through the

00:18:37,460 --> 00:18:46,220
browser and we can get the results from

00:18:41,360 --> 00:18:51,289
PI Swift and plot them easily cff I is

00:18:46,220 --> 00:18:56,690
used to wrap the sea interface to

00:18:51,289 --> 00:18:58,669
leverage that C++ code through C and we

00:18:56,690 --> 00:19:02,600
can then share the memory between C and

00:18:58,669 --> 00:19:05,179
Python just before I end this

00:19:02,600 --> 00:19:07,700
presentation some interesting

00:19:05,179 --> 00:19:10,429
presentations I'm not the only one in HP

00:19:07,700 --> 00:19:14,509
extended hydraulic or a prediction to do

00:19:10,429 --> 00:19:18,230
a presentation at PyCon this year so on

00:19:14,509 --> 00:19:21,139
Saturday you can see my colleagues

00:19:18,230 --> 00:19:23,659
Andrew McDonald and day auction doing

00:19:21,139 --> 00:19:27,470
presentations as well so if you you're

00:19:23,659 --> 00:19:28,369
interested in what I talk today you

00:19:27,470 --> 00:19:34,899
might be interested in those

00:19:28,369 --> 00:19:34,899
presentations as well and that's it

00:19:40,000 --> 00:19:46,160
okay thank you for a great song and

00:19:43,180 --> 00:19:48,560
here's your mug and we have certainly

00:19:46,160 --> 00:19:49,640
some time for questions so please raise

00:19:48,560 --> 00:20:01,160
your hand and I'll come around with the

00:19:49,640 --> 00:20:04,730
microphone hi thanks so have you tried

00:20:01,160 --> 00:20:06,740
using Saipan and if so have you done any

00:20:04,730 --> 00:20:08,960
performance testing with scythe on

00:20:06,740 --> 00:20:11,680
versus CF if I'm because my experience

00:20:08,960 --> 00:20:16,540
was the f of x is that it's very slow I

00:20:11,680 --> 00:20:21,290
was a I was expecting this question okay

00:20:16,540 --> 00:20:23,570
so site then there are I haven't tested

00:20:21,290 --> 00:20:26,630
it in a performance point of view but

00:20:23,570 --> 00:20:28,880
I've tested it more on a you know how

00:20:26,630 --> 00:20:34,970
easy would it be to implement what I'm

00:20:28,880 --> 00:20:36,560
doing so there's probably two two

00:20:34,970 --> 00:20:38,690
drawbacks that I find inside then

00:20:36,560 --> 00:20:41,030
compared to see ffi so I'm just talking

00:20:38,690 --> 00:20:43,370
about southie incitement here in the

00:20:41,030 --> 00:20:45,430
purpose of wrapping some secret okay so

00:20:43,370 --> 00:20:50,870
I don't want to offend any you know

00:20:45,430 --> 00:20:53,690
cycling fanatics here and those are so

00:20:50,870 --> 00:20:56,180
inside then you have to create a pyx

00:20:53,690 --> 00:20:57,890
file you have to do some compliation so

00:20:56,180 --> 00:21:02,110
you basically you write your binding

00:20:57,890 --> 00:21:05,120
code in the pyx file and that makes your

00:21:02,110 --> 00:21:10,120
architecture and more complex have to

00:21:05,120 --> 00:21:12,380
modify the build process as well and

00:21:10,120 --> 00:21:15,410
from the point of view of writing the

00:21:12,380 --> 00:21:18,050
binding code it's a bit more complex as

00:21:15,410 --> 00:21:20,930
well because if you remember my example

00:21:18,050 --> 00:21:23,180
of a double star star inside then you're

00:21:20,930 --> 00:21:25,730
actually have to deal with memory

00:21:23,180 --> 00:21:28,610
management yourself so have to allocate

00:21:25,730 --> 00:21:30,740
you know that double star star check if

00:21:28,610 --> 00:21:32,840
its allocated probably and you will try

00:21:30,740 --> 00:21:37,430
finally and then free the memory at the

00:21:32,840 --> 00:21:40,250
end so froh you know from the I didn't

00:21:37,430 --> 00:21:44,300
you know wrap the whole 150 function

00:21:40,250 --> 00:21:46,970
inside then but from my small tests that

00:21:44,300 --> 00:21:47,960
I did I it seemed like it would be

00:21:46,970 --> 00:21:51,740
faster to

00:21:47,960 --> 00:21:54,920
write code in c FF i but cff I is used

00:21:51,740 --> 00:22:03,680
in pi PI quite a lot so you can expect

00:21:54,920 --> 00:22:07,030
it to be quite fast more questions ok

00:22:03,680 --> 00:22:07,030

YouTube URL: https://www.youtube.com/watch?v=_7tV8KJCrBE


