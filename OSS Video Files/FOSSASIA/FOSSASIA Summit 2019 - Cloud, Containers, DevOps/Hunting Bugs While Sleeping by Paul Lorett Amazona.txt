Title: Hunting Bugs While Sleeping by Paul Lorett Amazona
Publication date: 2019-03-31
Playlist: FOSSASIA Summit 2019 - Cloud, Containers, DevOps
Description: 
	16 March 2019 10:00, Lecture Theatre

The key idea of property based testing is that rather than writing a test that tests just a single scenario, you write tests that describe a range of scenarios and then let the computer explore the possibilities for you rather than having to hand-write every one yourself.Think of a normal unit test (example-based) as being something like the following:
1. Set up some data.
2. Perform some operations on the data.
3. Assert something about the result.

Using property-based tests, your approach will look like this:
1. For all data matching some specification.
2. Perform some operations on the data.
3. Assert something about the result.

In this talk, I'll share on the following:

Short intro to property-based testing (PBT)
Few examples/approaches in using it
Adding PBTs to a Continuous Integration Build (so it can hunt bugs while you're sleeping :-) )
Captions: 
	00:00:00,089 --> 00:00:06,660
oh good mari everyone as how do I

00:00:04,380 --> 00:00:10,650
pronounce his name again Diana I

00:00:06,660 --> 00:00:14,910
mentioned I'm Paul and I'm a developer I

00:00:10,650 --> 00:00:18,060
develop and to end up net solutions at

00:00:14,910 --> 00:00:21,410
work outside work I'm involved in

00:00:18,060 --> 00:00:24,689
volunteer in two awesome organizations

00:00:21,410 --> 00:00:26,400
big data acts and they the kind in data

00:00:24,689 --> 00:00:28,230
convinced data science to help

00:00:26,400 --> 00:00:31,260
nonprofits get insights from their data

00:00:28,230 --> 00:00:36,059
to help the communities better and that

00:00:31,260 --> 00:00:37,950
Big Data acts we aim to improve the data

00:00:36,059 --> 00:00:39,899
engineering literacy here in Singapore

00:00:37,950 --> 00:00:43,170
and surrounding regions hence we tried

00:00:39,899 --> 00:00:48,000
to organize free workshops and advanced

00:00:43,170 --> 00:00:50,280
for this goal and last year I went to

00:00:48,000 --> 00:00:51,690
Australia I usually attend conferences

00:00:50,280 --> 00:00:54,329
because those are the things that makes

00:00:51,690 --> 00:00:58,500
me happy I learned about property based

00:00:54,329 --> 00:01:02,250
testing from Zack I was speaking right

00:00:58,500 --> 00:01:04,729
here talking about hypothesis which is a

00:01:02,250 --> 00:01:07,439
library on property based testing and

00:01:04,729 --> 00:01:11,100
when I came back to Singapore of course

00:01:07,439 --> 00:01:13,470
I delighted about the library so I shred

00:01:11,100 --> 00:01:15,330
it with the community here I talk about

00:01:13,470 --> 00:01:19,170
property based testing with hypothesis

00:01:15,330 --> 00:01:21,869
but today I'd like to focus more on the

00:01:19,170 --> 00:01:24,299
essentials like what really is property

00:01:21,869 --> 00:01:27,390
based testing if you want to dissect it

00:01:24,299 --> 00:01:29,340
a bit so I try to define it like it it's

00:01:27,390 --> 00:01:30,960
a type of testing that asserts based on

00:01:29,340 --> 00:01:34,200
properties let's write the relationship

00:01:30,960 --> 00:01:36,600
between the input and the output of the

00:01:34,200 --> 00:01:39,390
function that is being tested is this

00:01:36,600 --> 00:01:42,360
clear enough yep exactly

00:01:39,390 --> 00:01:46,079
that's why I like examples better so

00:01:42,360 --> 00:01:50,009
let's take a testing example let's try

00:01:46,079 --> 00:01:52,500
to test a simple multiply function for

00:01:50,009 --> 00:01:58,439
this test function that we have do you

00:01:52,500 --> 00:02:02,240
have any comments on the test yeah

00:01:58,439 --> 00:02:02,240
don't do this don't ever do anything

00:02:02,600 --> 00:02:09,300
that the functionality as far as your

00:02:07,079 --> 00:02:13,110
test right so if this is not the right

00:02:09,300 --> 00:02:13,830
way what other possibly approaches in

00:02:13,110 --> 00:02:17,520
testing that

00:02:13,830 --> 00:02:21,390
can possibly do so one of the basic ones

00:02:17,520 --> 00:02:25,410
is giving examples so we give an example

00:02:21,390 --> 00:02:28,620
of the inputs like 2 & 3 and then we try

00:02:25,410 --> 00:02:30,950
to put or provide the example output so

00:02:28,620 --> 00:02:34,500
here we have two of those examples

00:02:30,950 --> 00:02:36,720
example 1 we have this group and then

00:02:34,500 --> 00:02:39,000
example 2 we have a bunch of inputs and

00:02:36,720 --> 00:02:42,690
then the corresponding output 4 times 5

00:02:39,000 --> 00:02:44,700
equals 20 and we can choose to refactor

00:02:42,690 --> 00:02:47,790
it make it look beautiful

00:02:44,700 --> 00:02:49,710
and so we have the common logic here

00:02:47,790 --> 00:02:53,310
we're still comparing actual output and

00:02:49,710 --> 00:02:57,540
expected output but it's nice to have

00:02:53,310 --> 00:02:59,520
all of our parameters for factors and

00:02:57,540 --> 00:03:03,600
expected output in one place so we can

00:02:59,520 --> 00:03:07,530
easily add so that's still okay but what

00:03:03,600 --> 00:03:15,390
we want to do is is there a way that we

00:03:07,530 --> 00:03:17,790
can I we can have a way not to depend on

00:03:15,390 --> 00:03:21,720
the expected output can we do a test

00:03:17,790 --> 00:03:25,860
just by depending on the inputs alone so

00:03:21,720 --> 00:03:27,930
I use the multiply function just not

00:03:25,860 --> 00:03:30,060
just because it's a simple function but

00:03:27,930 --> 00:03:32,610
it's also something that reminds me when

00:03:30,060 --> 00:03:36,510
I was in primary school so in primary

00:03:32,610 --> 00:03:38,040
school we learned about properties let's

00:03:36,510 --> 00:03:41,489
say are symmetric property right you

00:03:38,040 --> 00:03:43,920
have like addition properties of the

00:03:41,489 --> 00:03:46,050
multiplication properties and when we

00:03:43,920 --> 00:03:47,850
talk about property based testing it's

00:03:46,050 --> 00:03:51,300
only this kind of properties that were

00:03:47,850 --> 00:03:53,220
referring to is the the attributes and

00:03:51,300 --> 00:03:55,590
then the artistics of the function that

00:03:53,220 --> 00:03:57,180
we're trying to test right not the

00:03:55,590 --> 00:03:59,970
properties that is like a syntactic

00:03:57,180 --> 00:04:02,220
sugar for c-sharp or properties that you

00:03:59,970 --> 00:04:04,200
own of course you have the main maybe

00:04:02,220 --> 00:04:05,550
like bungalows and stuff but the

00:04:04,200 --> 00:04:08,100
properties we're talking about there is

00:04:05,550 --> 00:04:10,890
something like this so in multiplication

00:04:08,100 --> 00:04:13,260
properties you have commutative property

00:04:10,890 --> 00:04:15,330
which you can reorder it's still going

00:04:13,260 --> 00:04:17,760
to be having the same result you have a

00:04:15,330 --> 00:04:20,489
certain property multiplicative property

00:04:17,760 --> 00:04:23,850
and distributive property so how do we

00:04:20,489 --> 00:04:27,050
apply this to testing so if you notice

00:04:23,850 --> 00:04:29,060
here we got rid of the output now

00:04:27,050 --> 00:04:31,460
going to depend on the input data that

00:04:29,060 --> 00:04:34,069
we have but using this input data and

00:04:31,460 --> 00:04:36,590
our knowledge about properties that's

00:04:34,069 --> 00:04:39,379
how we're going to improve our approach

00:04:36,590 --> 00:04:42,590
to testing so we can do the cumulative

00:04:39,379 --> 00:04:45,259
part property in this fashion so we just

00:04:42,590 --> 00:04:47,379
rearranged and then using the same

00:04:45,259 --> 00:04:50,090
function that we're testing it should

00:04:47,379 --> 00:04:51,620
give the same result so that's the

00:04:50,090 --> 00:04:54,800
property and we're trying to test the

00:04:51,620 --> 00:04:58,159
cumulative property and so on with the

00:04:54,800 --> 00:05:01,180
other properties you can do also on in

00:04:58,159 --> 00:05:04,669
the same approach but here if you notice

00:05:01,180 --> 00:05:06,800
what we're trying to do is we're now

00:05:04,669 --> 00:05:08,990
using poverty based testing but if you

00:05:06,800 --> 00:05:09,530
notice I didn't use any framework yet

00:05:08,990 --> 00:05:12,289
right

00:05:09,530 --> 00:05:15,409
why would use our framework for such an

00:05:12,289 --> 00:05:17,629
example we're still using predetermined

00:05:15,409 --> 00:05:19,490
inputs so pretty don't mean inputs that

00:05:17,629 --> 00:05:23,810
means I have to set these inputs

00:05:19,490 --> 00:05:29,840
manually by myself the thing is here for

00:05:23,810 --> 00:05:34,370
the multiply multiply function what is

00:05:29,840 --> 00:05:36,650
our the population of our inputs then I

00:05:34,370 --> 00:05:41,240
do the testing in such a way that I can

00:05:36,650 --> 00:05:43,699
exhaustively pass the function this is

00:05:41,240 --> 00:05:47,289
impossible right because you have like

00:05:43,699 --> 00:05:49,490
factors which can have like millions and

00:05:47,289 --> 00:05:51,710
multiply millions and alamos is

00:05:49,490 --> 00:05:54,860
impossible to me to manually write it

00:05:51,710 --> 00:05:57,620
down so is there another way that we can

00:05:54,860 --> 00:06:00,080
deal with this sort of fashion if it's

00:05:57,620 --> 00:06:01,969
only if your input is only a to Z I can

00:06:00,080 --> 00:06:07,129
just for look at right and then that's

00:06:01,969 --> 00:06:10,940
all the data but if your sample inputs

00:06:07,129 --> 00:06:16,129
is too big to for you to do exhaustive

00:06:10,940 --> 00:06:18,469
testing we still want to test but what

00:06:16,129 --> 00:06:22,279
you might be able to do is instead of

00:06:18,469 --> 00:06:25,009
testing using the whole population why

00:06:22,279 --> 00:06:27,139
not like test like sample at a time like

00:06:25,009 --> 00:06:28,460
maybe hundred sample test with that if

00:06:27,139 --> 00:06:30,440
it's okay then child with another

00:06:28,460 --> 00:06:32,719
randomized sample so at least we might

00:06:30,440 --> 00:06:35,240
not test all the population but at least

00:06:32,719 --> 00:06:37,789
we're moving there and hopefully it's

00:06:35,240 --> 00:06:39,410
somewhere down the road maybe some

00:06:37,789 --> 00:06:42,200
combination will

00:06:39,410 --> 00:06:45,590
spawn a bug or something that we'll be

00:06:42,200 --> 00:06:48,560
able to learn from right so that is

00:06:45,590 --> 00:06:51,920
using randomized inputs so in this

00:06:48,560 --> 00:06:54,350
example I'm using now the hypothesis for

00:06:51,920 --> 00:06:58,010
me to be able to generate our random set

00:06:54,350 --> 00:07:02,260
of integers and another integers for for

00:06:58,010 --> 00:07:04,160
the factors right and for this it's

00:07:02,260 --> 00:07:06,500
hypothesis is just giving us like

00:07:04,160 --> 00:07:09,560
hundred samples at the time 100 some

00:07:06,500 --> 00:07:12,470
hundred samples is a default number size

00:07:09,560 --> 00:07:15,800
of the sample that hypothesis is giving

00:07:12,470 --> 00:07:20,420
so you may ask why use a library I can

00:07:15,800 --> 00:07:23,900
code the random ones in first by myself

00:07:20,420 --> 00:07:26,030
right why should I use a library well

00:07:23,900 --> 00:07:28,040
there's no not nothing stopping you from

00:07:26,030 --> 00:07:28,970
creating your own library or function

00:07:28,040 --> 00:07:31,310
right if you want

00:07:28,970 --> 00:07:34,510
it's just that why do you need to

00:07:31,310 --> 00:07:37,190
reinvent the wheel if there are lots of

00:07:34,510 --> 00:07:39,710
libraries that are doing this already

00:07:37,190 --> 00:07:42,620
even if you're using it for another

00:07:39,710 --> 00:07:48,830
language like Java or C sharp or F sharp

00:07:42,620 --> 00:07:51,410
why would you recreate the same library

00:07:48,830 --> 00:07:53,930
right so perhaps before you create your

00:07:51,410 --> 00:07:56,450
own library maybe you can look into the

00:07:53,930 --> 00:07:58,450
open source ecosystem and community

00:07:56,450 --> 00:08:01,040
maybe there is a library that's already

00:07:58,450 --> 00:08:03,710
built for poverty based testing for your

00:08:01,040 --> 00:08:06,080
language and maybe maybe it's not

00:08:03,710 --> 00:08:08,450
perfect but you know we're in a

00:08:06,080 --> 00:08:10,220
community we're here to help each other

00:08:08,450 --> 00:08:12,200
if there's something that you're not is

00:08:10,220 --> 00:08:14,540
to improve maybe you can set up pull

00:08:12,200 --> 00:08:16,610
request and make the library better and

00:08:14,540 --> 00:08:17,630
then it will help the rest of the

00:08:16,610 --> 00:08:21,230
community as well

00:08:17,630 --> 00:08:24,260
so apart from randomizing what else can

00:08:21,230 --> 00:08:26,660
live really do so at least for let's say

00:08:24,260 --> 00:08:30,080
for hypothesis it doesn't give you just

00:08:26,660 --> 00:08:32,810
randomized samples alone but it also

00:08:30,080 --> 00:08:34,760
allows you to have more elaborate input

00:08:32,810 --> 00:08:37,520
criteria so here apart from integers

00:08:34,760 --> 00:08:39,710
that say you want to only include those

00:08:37,520 --> 00:08:42,260
that are greater than zero all positive

00:08:39,710 --> 00:08:44,960
integers you can do that or you can do

00:08:42,260 --> 00:08:47,110
arbitrary conditions think of formal

00:08:44,960 --> 00:08:50,650
methods right you can define your

00:08:47,110 --> 00:08:52,910
criteria in such way and apart from that

00:08:50,650 --> 00:08:55,460
remember a while ago we were doing

00:08:52,910 --> 00:08:59,090
example based testing let's say you have

00:08:55,460 --> 00:09:02,720
a situation or a set of inputs that you

00:08:59,090 --> 00:09:04,880
really want to test but in what you're

00:09:02,720 --> 00:09:05,870
already doing randomized testing you can

00:09:04,880 --> 00:09:08,060
do that also

00:09:05,870 --> 00:09:10,880
using this property based testing

00:09:08,060 --> 00:09:13,190
library you can have an example so what

00:09:10,880 --> 00:09:16,670
it will do it will run with your example

00:09:13,190 --> 00:09:18,530
plus the randomized samples as well so

00:09:16,670 --> 00:09:22,250
you have like the best of both friends

00:09:18,530 --> 00:09:24,740
right from here you don't have to depend

00:09:22,250 --> 00:09:27,740
on the default value or default size

00:09:24,740 --> 00:09:30,470
which is 100 you can increase it to a

00:09:27,740 --> 00:09:32,480
few hundreds more and in fact if you

00:09:30,470 --> 00:09:34,400
want to do it with continuous

00:09:32,480 --> 00:09:36,560
integration you might want to increase

00:09:34,400 --> 00:09:39,020
it to a lot more because you want the

00:09:36,560 --> 00:09:41,120
more sample set to you test the more

00:09:39,020 --> 00:09:43,010
probability probability that you will be

00:09:41,120 --> 00:09:48,440
able to catch the bug that you're you're

00:09:43,010 --> 00:09:50,720
hunting for so you may ask like property

00:09:48,440 --> 00:09:51,730
based testing is really good can I use

00:09:50,720 --> 00:09:55,610
it for everything

00:09:51,730 --> 00:09:58,460
so this is my thought process I'm always

00:09:55,610 --> 00:10:00,530
open to new ideas in case some things

00:09:58,460 --> 00:10:00,830
change but currently this is how I see

00:10:00,530 --> 00:10:04,370
it

00:10:00,830 --> 00:10:07,430
so I usually ask myself when doing

00:10:04,370 --> 00:10:11,030
testing is the function that I am

00:10:07,430 --> 00:10:14,330
testing does it have testable properties

00:10:11,030 --> 00:10:16,970
from the inputs that I'm providing it if

00:10:14,330 --> 00:10:20,510
there's none then I just continue with

00:10:16,970 --> 00:10:22,730
the usual example based testing but if I

00:10:20,510 --> 00:10:26,000
can derive a generic poverty that I can

00:10:22,730 --> 00:10:30,830
sort of use as a high-level way of

00:10:26,000 --> 00:10:32,690
testing then I try to approach it in a

00:10:30,830 --> 00:10:37,550
property based testing kind of approach

00:10:32,690 --> 00:10:40,580
and then after that I ask myself can I

00:10:37,550 --> 00:10:44,000
afford to test all possible inputs to

00:10:40,580 --> 00:10:46,730
this function if I can if the input is

00:10:44,000 --> 00:10:49,550
maybe just a to Z then I can just for

00:10:46,730 --> 00:10:52,190
look it and then use predetermined

00:10:49,550 --> 00:10:55,580
inputs for that manner however if the

00:10:52,190 --> 00:10:57,670
input is a combination of inputs are so

00:10:55,580 --> 00:11:02,420
large that I cannot really test manually

00:10:57,670 --> 00:11:03,490
then I'll try to leverage and randomize

00:11:02,420 --> 00:11:06,970
input

00:11:03,490 --> 00:11:11,380
and then just like sample at a time now

00:11:06,970 --> 00:11:13,240
that we have a randomized testing I

00:11:11,380 --> 00:11:14,740
don't want to be manually triggering

00:11:13,240 --> 00:11:17,560
this right you don't want to be manually

00:11:14,740 --> 00:11:20,740
checking for bugs you want it in such a

00:11:17,560 --> 00:11:24,430
way that you might be sleeping at night

00:11:20,740 --> 00:11:25,839
but something is working for you hunting

00:11:24,430 --> 00:11:27,490
the bugs for you so that when you wake

00:11:25,839 --> 00:11:30,070
up in the morning a first problem or

00:11:27,490 --> 00:11:31,839
some bugs you'll be able to like just

00:11:30,070 --> 00:11:33,220
get a report that hey there's something

00:11:31,839 --> 00:11:36,430
wrong with your function you should fix

00:11:33,220 --> 00:11:39,279
this right so some you can hire some

00:11:36,430 --> 00:11:41,589
sort of assistant that you don't have to

00:11:39,279 --> 00:11:44,800
pay for it it will do the work for you

00:11:41,589 --> 00:11:47,230
so why not so the hence we have this

00:11:44,800 --> 00:11:50,500
hunting bugs with CI they have this

00:11:47,230 --> 00:11:52,300
normal CI you can keep it there it will

00:11:50,500 --> 00:11:55,450
do its job the purpose of that is so

00:11:52,300 --> 00:11:58,089
that we have early detection of problems

00:11:55,450 --> 00:11:59,620
that is there that that's okay but what

00:11:58,089 --> 00:12:02,860
we want to add is we want to have

00:11:59,620 --> 00:12:05,430
another CI pipeline dedicated for our

00:12:02,860 --> 00:12:07,959
bug hunting so I call it the bug hunting

00:12:05,430 --> 00:12:09,790
continuous integration so the difference

00:12:07,959 --> 00:12:12,459
here is instead of being triggered by

00:12:09,790 --> 00:12:15,339
merge and for request and so on I want

00:12:12,459 --> 00:12:18,100
this to be scheduled and if the CI

00:12:15,339 --> 00:12:19,720
platform that I'm using allows me I want

00:12:18,100 --> 00:12:22,839
to schedule it as often as possible

00:12:19,720 --> 00:12:25,899
maybe every R or every day if it doesn't

00:12:22,839 --> 00:12:27,579
allow me the purpose is this for this is

00:12:25,899 --> 00:12:30,820
for me to hunt bugs

00:12:27,579 --> 00:12:33,100
even if I'm away I'm sleeping it will

00:12:30,820 --> 00:12:34,839
hunt bugs for me it will try to do those

00:12:33,100 --> 00:12:37,720
around the mice inputs and then probably

00:12:34,839 --> 00:12:40,510
give me a result to bid certain

00:12:37,720 --> 00:12:44,290
combinations maybe it fails that system

00:12:40,510 --> 00:12:46,000
so let me do some demo so I have some

00:12:44,290 --> 00:12:48,700
screenshots but I'm not going to use

00:12:46,000 --> 00:12:51,010
this this is only for backup in case the

00:12:48,700 --> 00:12:53,140
internet goes off or the electricity has

00:12:51,010 --> 00:12:56,589
some problems or the world as we know

00:12:53,140 --> 00:12:59,350
ends I can't do much on the other two

00:12:56,589 --> 00:13:03,670
but yeah you know what I mean so what

00:12:59,350 --> 00:13:06,520
you have here is a sample for arithmetic

00:13:03,670 --> 00:13:11,020
the one that we discussed so we have the

00:13:06,520 --> 00:13:13,720
multiply function and you also have a

00:13:11,020 --> 00:13:14,949
set of property based tests with

00:13:13,720 --> 00:13:17,949
randomized

00:13:14,949 --> 00:13:19,660
inputs right so I've random integers and

00:13:17,949 --> 00:13:22,899
then this so what I'm going to do now

00:13:19,660 --> 00:13:28,170
I'm going to integrate this using who

00:13:22,899 --> 00:13:38,559
uses github here anyone using gitlab

00:13:28,170 --> 00:13:40,839
which one do you like most because it

00:13:38,559 --> 00:13:42,339
has in nice integration with agile

00:13:40,839 --> 00:13:45,790
devops I'm sure DevOps by the way is

00:13:42,339 --> 00:13:47,139
free yeah I don't know why they put her

00:13:45,790 --> 00:13:49,209
there because usually even people think

00:13:47,139 --> 00:13:53,739
of either is the paid version right but

00:13:49,209 --> 00:13:59,709
yeah all of my setups are free so I try

00:13:53,739 --> 00:14:02,410
to let me add a simple CI for this so in

00:13:59,709 --> 00:14:07,839
inside agile devops I can just build a

00:14:02,410 --> 00:14:11,499
new pipeline if that clicks and then

00:14:07,839 --> 00:14:16,679
I'll just go to github and then select

00:14:11,499 --> 00:14:20,919
my this one multiply multiply patient

00:14:16,679 --> 00:14:24,459
because it's done in Python vacation g.h

00:14:20,919 --> 00:14:30,879
demo and then once I have that selected

00:14:24,459 --> 00:14:36,129
I just need to configure and then this

00:14:30,879 --> 00:14:41,879
one I'll need to cheat a bit I have

00:14:36,129 --> 00:14:41,879
something configured already let me just

00:14:44,790 --> 00:14:49,550
so what it does once you have this

00:14:46,860 --> 00:14:53,459
configured it's Auto checking into your

00:14:49,550 --> 00:14:56,029
github repository it's all just going to

00:14:53,459 --> 00:14:56,029
copy this

00:14:58,130 --> 00:15:01,090
it's

00:15:01,370 --> 00:15:04,990
and then copy it here

00:15:06,740 --> 00:15:12,590
so I included that test step here where

00:15:10,400 --> 00:15:15,020
you Speight that's the test using

00:15:12,590 --> 00:15:17,330
property based testing using hypothesis

00:15:15,020 --> 00:15:19,090
so that's part of the step and then I'm

00:15:17,330 --> 00:15:23,560
just going to save and run

00:15:19,090 --> 00:15:26,870
I'll just commit it to master branch and

00:15:23,560 --> 00:15:31,040
then once that is done I should be able

00:15:26,870 --> 00:15:32,750
to see it check into the repository and

00:15:31,040 --> 00:15:36,400
then once it's checked into the

00:15:32,750 --> 00:15:41,020
repository I should be able to see the

00:15:36,400 --> 00:15:45,170
the steps in the CI so it will try to

00:15:41,020 --> 00:15:49,150
pull the necessary files and information

00:15:45,170 --> 00:15:53,570
the normal CI steps that you usually see

00:15:49,150 --> 00:15:57,620
including the building of artifacts and

00:15:53,570 --> 00:16:00,170
then also the the testing so it's

00:15:57,620 --> 00:16:02,930
currently preparing for the job to be

00:16:00,170 --> 00:16:05,510
cute so while waiting why not I can take

00:16:02,930 --> 00:16:06,860
some questions if there's any questions

00:16:05,510 --> 00:16:12,290
in the audience for now while we're

00:16:06,860 --> 00:16:18,530
waiting so it's doing the normal CI CI

00:16:12,290 --> 00:16:21,010
what I need to do CIA needs to do it's

00:16:18,530 --> 00:16:21,010
quite fast

00:16:24,120 --> 00:16:30,300
installing the assemblies so I did set

00:16:27,300 --> 00:16:33,270
up both in Azure data box I also did it

00:16:30,300 --> 00:16:35,460
in get lab so they get my get labs set

00:16:33,270 --> 00:16:37,110
up I'll show you also later so what

00:16:35,460 --> 00:16:40,560
we're trying to do now is we'll set up

00:16:37,110 --> 00:16:42,090
the CI first and once the C is done you

00:16:40,560 --> 00:16:43,770
don't want to be manually kicking off

00:16:42,090 --> 00:16:47,190
the CI right so you need to explore

00:16:43,770 --> 00:16:48,120
whether your CI platform has ability to

00:16:47,190 --> 00:16:50,490
schedule

00:16:48,120 --> 00:16:54,180
thus the trigger so I'll show that to

00:16:50,490 --> 00:16:57,660
you also so it's done what I want to

00:16:54,180 --> 00:16:59,760
show here is it has a step on testing so

00:16:57,660 --> 00:17:02,870
in the test you should be able to see

00:16:59,760 --> 00:17:02,870
it's so small

00:17:03,710 --> 00:17:12,630
so if I scroll down I should be able to

00:17:07,770 --> 00:17:15,210
see the hypothesis hypothesis statistics

00:17:12,630 --> 00:17:18,810
where the first test that we have I'm

00:17:15,210 --> 00:17:22,020
using two hundred examples there are

00:17:18,810 --> 00:17:24,480
just d4c out like hundred passing

00:17:22,020 --> 00:17:27,000
examples so this is this is fine it's

00:17:24,480 --> 00:17:29,970
good so once we have this the next thing

00:17:27,000 --> 00:17:32,490
that you want to do is to be able to set

00:17:29,970 --> 00:17:34,730
the schedule so that it will trigger on

00:17:32,490 --> 00:17:38,340
its own every day or every our

00:17:34,730 --> 00:17:42,360
unfortunately I think for our DevOps the

00:17:38,340 --> 00:17:45,180
granularity where it allows me to do

00:17:42,360 --> 00:17:47,820
this scheduling is only I think once per

00:17:45,180 --> 00:17:49,260
day so it's okay once per day is better

00:17:47,820 --> 00:17:50,970
than nothing I can just increase the

00:17:49,260 --> 00:17:53,330
sample to a thousand right so I can test

00:17:50,970 --> 00:17:57,740
more so I'll just go to the releases

00:17:53,330 --> 00:17:57,740
sorry should be builds

00:17:59,600 --> 00:18:05,200
so in the multiplication I'll just edit

00:18:02,750 --> 00:18:05,200
this

00:18:08,790 --> 00:18:14,400
and then in the settings you are

00:18:11,220 --> 00:18:18,350
understandings you have triggers and in

00:18:14,400 --> 00:18:21,660
the triggers you should be able to see

00:18:18,350 --> 00:18:24,810
setting for schedule here scheduled so

00:18:21,660 --> 00:18:27,090
I'll just add a schedule it allows you

00:18:24,810 --> 00:18:28,860
to do scheduling everyday and then the

00:18:27,090 --> 00:18:30,450
thing that I want to uncheck here is

00:18:28,860 --> 00:18:32,610
only scheduled bills if their source or

00:18:30,450 --> 00:18:34,620
pipeline is change we don't care if

00:18:32,610 --> 00:18:36,780
there's a change to the source code for

00:18:34,620 --> 00:18:38,820
this approach for or hunting for bug

00:18:36,780 --> 00:18:42,240
hunting CI so I wasn't going to uncheck

00:18:38,820 --> 00:18:44,910
that and then let's say every 2 a.m. in

00:18:42,240 --> 00:18:47,430
the morning while I'm sleeping someone

00:18:44,910 --> 00:18:50,190
or something is doing the job for me in

00:18:47,430 --> 00:18:55,160
hunting bugs so I'm just going to save

00:18:50,190 --> 00:18:55,160
this save and queue

00:19:05,350 --> 00:19:13,570
so it will save it on its own for a good

00:19:09,460 --> 00:19:16,330
club it has the similar functionality if

00:19:13,570 --> 00:19:19,750
and setup here see I also but the the

00:19:16,330 --> 00:19:22,990
thing with gitlab is instead of allowing

00:19:19,750 --> 00:19:27,130
you to just do it like once per day it

00:19:22,990 --> 00:19:28,840
allows you to do every hour so if you

00:19:27,130 --> 00:19:31,389
notice here once I set it up this is

00:19:28,840 --> 00:19:33,429
good luck by the way it's building and

00:19:31,389 --> 00:19:35,710
hunting bugs for me every like every R

00:19:33,429 --> 00:19:37,570
so you can set it up so I mean it's its

00:19:35,710 --> 00:19:40,600
choice but there is your your hosting

00:19:37,570 --> 00:19:44,320
currently in github or it lab and these

00:19:40,600 --> 00:19:48,879
are free public people so I fun if I

00:19:44,320 --> 00:19:52,629
want to go to my builds this is where I

00:19:48,879 --> 00:19:55,559
can monitor the results of the builds as

00:19:52,629 --> 00:19:58,870
well so in this multiplication gh demo

00:19:55,559 --> 00:20:01,230
every build result you can see from here

00:19:58,870 --> 00:20:04,269
the ones that I saw showed to you about

00:20:01,230 --> 00:20:06,730
how does the test result right so if if

00:20:04,269 --> 00:20:08,769
something fails you should be able to

00:20:06,730 --> 00:20:12,370
see it here failing as well and then

00:20:08,769 --> 00:20:15,309
let's say hypothesis found that for this

00:20:12,370 --> 00:20:21,750
combination your function failed and

00:20:15,309 --> 00:20:24,850
then you go and fix so with that let me

00:20:21,750 --> 00:20:28,750
bring it in the summary so what we've

00:20:24,850 --> 00:20:31,720
done so far is we've got to explore on

00:20:28,750 --> 00:20:34,090
various ways of testing a function we

00:20:31,720 --> 00:20:35,769
tried with the basic example by

00:20:34,090 --> 00:20:38,350
providing example outputs

00:20:35,769 --> 00:20:41,620
after that we refactored and then tried

00:20:38,350 --> 00:20:45,309
to do it in a parameterised way and then

00:20:41,620 --> 00:20:47,700
it stalled like at least two approaches

00:20:45,309 --> 00:20:50,679
and property based testing using

00:20:47,700 --> 00:20:53,549
predetermined inputs and then the

00:20:50,679 --> 00:20:58,740
randomized inputs if we're not able to

00:20:53,549 --> 00:21:01,509
exhaustively test using all of the

00:20:58,740 --> 00:21:05,049
possible inputs to the earth function

00:21:01,509 --> 00:21:07,600
and then we also explored the bug

00:21:05,049 --> 00:21:09,250
hunting zi pipeline where it's a

00:21:07,600 --> 00:21:11,559
pipeline that is separate to your normal

00:21:09,250 --> 00:21:13,990
Python that your normal pipeline to its

00:21:11,559 --> 00:21:16,900
thing but we use this pipeline to help

00:21:13,990 --> 00:21:19,679
us hunt bugs if there is any

00:21:16,900 --> 00:21:22,900
with those certain combination of inputs

00:21:19,679 --> 00:21:26,529
you can reach me here that's my twitter

00:21:22,900 --> 00:21:28,600
and github handle and i've shared the

00:21:26,529 --> 00:21:30,340
links here for the previous hypothesis

00:21:28,600 --> 00:21:32,110
demo if you want to dig more into the

00:21:30,340 --> 00:21:35,260
hypothesis property based testing

00:21:32,110 --> 00:21:41,250
framework as well as the the demos that

00:21:35,260 --> 00:21:44,250
I used a while ago and that's it for me

00:21:41,250 --> 00:21:44,250
thanks

00:21:46,489 --> 00:21:51,440
okay I think we have time for one

00:21:49,200 --> 00:21:51,440
question

00:21:54,510 --> 00:22:00,560
yes and give the mic

00:22:02,280 --> 00:22:17,690
oh yes multiplication yeah doesn't

00:22:14,430 --> 00:22:17,690
really catch the back where

00:22:20,750 --> 00:22:26,909
yes Rousso apart from randomized they're

00:22:24,539 --> 00:22:28,740
singers also this approach is called

00:22:26,909 --> 00:22:30,419
fast testing usually fast testing is

00:22:28,740 --> 00:22:32,700
usually you have liked randomize inputs

00:22:30,419 --> 00:22:34,919
and then your goal there is try to do as

00:22:32,700 --> 00:22:36,960
much input so that it breaks the system

00:22:34,919 --> 00:22:38,580
that is another type of testing but for

00:22:36,960 --> 00:22:41,909
property based testing you're thinking

00:22:38,580 --> 00:22:44,490
of a predetermined or deterministic are

00:22:41,909 --> 00:22:47,370
result where you want to test that once

00:22:44,490 --> 00:22:50,190
you have this result it coincides with

00:22:47,370 --> 00:22:53,039
the property of the function later I'd

00:22:50,190 --> 00:22:55,649
like to test for so what I'm sharing

00:22:53,039 --> 00:22:57,419
here is property based testing is it

00:22:55,649 --> 00:22:58,380
won't replace all the testing that

00:22:57,419 --> 00:23:00,179
you've done so far

00:22:58,380 --> 00:23:01,740
so you still have your example base you

00:23:00,179 --> 00:23:04,860
still have your first testing for that

00:23:01,740 --> 00:23:06,659
purpose plus now we have another

00:23:04,860 --> 00:23:09,630
approach called property based testing

00:23:06,659 --> 00:23:11,429
which we can add in our suite of kind of

00:23:09,630 --> 00:23:14,730
tests that we apply to the functions

00:23:11,429 --> 00:23:16,529
that we do so other examples are

00:23:14,730 --> 00:23:19,260
probably for this is just like

00:23:16,529 --> 00:23:21,059
multiplication right but other popular

00:23:19,260 --> 00:23:26,940
examples for property based testing is

00:23:21,059 --> 00:23:30,120
let's say if you have let's say a list

00:23:26,940 --> 00:23:32,820
right you want to reverse a list so one

00:23:30,120 --> 00:23:36,240
property there is if you reverse the

00:23:32,820 --> 00:23:39,269
list twice it should be the same list

00:23:36,240 --> 00:23:41,549
that you input from the previous so if

00:23:39,269 --> 00:23:44,029
you if you order like one two three I

00:23:41,549 --> 00:23:46,289
reverse it this is three to one I

00:23:44,029 --> 00:23:48,090
reverse it again it should come out as

00:23:46,289 --> 00:23:49,830
one two three so the input and then the

00:23:48,090 --> 00:23:51,690
if I reverse twice it should be equal

00:23:49,830 --> 00:23:54,510
and then of course there are like few

00:23:51,690 --> 00:23:57,809
other approaches like if you notice

00:23:54,510 --> 00:24:00,570
there's this diamond kata where it also

00:23:57,809 --> 00:24:02,730
teaches you on like how to like spot

00:24:00,570 --> 00:24:05,730
properties from the inputs and outputs

00:24:02,730 --> 00:24:08,460
usually you try to look the input to the

00:24:05,730 --> 00:24:10,440
system and then out and try to check

00:24:08,460 --> 00:24:13,320
whether there are properties the one

00:24:10,440 --> 00:24:15,299
that you've shared because people are

00:24:13,320 --> 00:24:18,029
also sharing that hey

00:24:15,299 --> 00:24:21,990
overflow is also a perfect for something

00:24:18,029 --> 00:24:23,970
but it it might be a case the case I

00:24:21,990 --> 00:24:26,220
would categorize that may be more

00:24:23,970 --> 00:24:27,960
appropriate for fast testing if that's

00:24:26,220 --> 00:24:30,029
the goal for that but for property I

00:24:27,960 --> 00:24:33,499
want to have that

00:24:30,029 --> 00:24:37,200
deterministic expectation

00:24:33,499 --> 00:24:38,009
thank you okay thank you for the

00:24:37,200 --> 00:24:41,249
question

00:24:38,009 --> 00:24:44,020
thank you very much Paul please give him

00:24:41,249 --> 00:24:47,460
a round of applause thank you everyone

00:24:44,020 --> 00:24:47,460

YouTube URL: https://www.youtube.com/watch?v=zQ8UNddT7Ms


