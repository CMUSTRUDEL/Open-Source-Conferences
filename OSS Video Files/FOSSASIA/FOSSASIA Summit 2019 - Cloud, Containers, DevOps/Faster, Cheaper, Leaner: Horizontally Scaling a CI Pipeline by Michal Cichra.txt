Title: Faster, Cheaper, Leaner: Horizontally Scaling a CI Pipeline by Michal Cichra
Publication date: 2019-03-31
Playlist: FOSSASIA Summit 2019 - Cloud, Containers, DevOps
Description: 
	16 March 2019 10:30, Lecture Theatre

If your Continuous Integration pipeline is slow, you are basically wasting money! A CI pipeline is an essential tool for any modern development team, as the necessary quality assurance mechanism that ensures they can deliver working software. Slow, (or, worse, broken) pipelines cause serious impediment to development teams, and this impediment directly translates into wasted $$$. 

Instead, CI should be very much treated like any other production system the company maintains. Whereas the customer-facing systems bring revenue into the company, the CI pipeline ensures the development teams remain productive and efficient in serving the former. 

From this talk, you can expect to pick up some tips on how to speed up your CI pipelines -  leveraging cloud capabilities, such as horizontal scaling of its workloads to cater for more / heavier /longer builds. This leads to short feedback loops in the development cycle, and - therefore - a more efficient use of your dev teamâ€™s (expensive) time.  And for the cherry on top,  you will probably be reducing your CI costs while doing all this!
Captions: 
	00:00:00,030 --> 00:00:06,540
hi everyone good morning so I would like

00:00:03,840 --> 00:00:09,300
to tell you a story about how we open

00:00:06,540 --> 00:00:11,580
sourced our product and fixed our CI in

00:00:09,300 --> 00:00:15,719
the process by its really story about

00:00:11,580 --> 00:00:20,910
how we moved from VMs to containers and

00:00:15,719 --> 00:00:22,260
how we improved developer experience so

00:00:20,910 --> 00:00:24,539
something about me

00:00:22,260 --> 00:00:25,740
I mean how I work with open-source for

00:00:24,539 --> 00:00:28,710
my entire career

00:00:25,740 --> 00:00:32,759
and I'm full time working on open source

00:00:28,710 --> 00:00:35,010
for about five years that also means I

00:00:32,759 --> 00:00:36,540
contributed projects when I need to just

00:00:35,010 --> 00:00:39,989
do anything that that I need to touch

00:00:36,540 --> 00:00:42,570
I'm feel free to contribute and I also

00:00:39,989 --> 00:00:44,430
have my and everyone's development

00:00:42,570 --> 00:00:45,660
productivity on my mind it means I

00:00:44,430 --> 00:00:47,700
cannot touch a project if it doesn't

00:00:45,660 --> 00:00:50,670
have a CI I will have to build one first

00:00:47,700 --> 00:00:52,610
and I work on three scale for about

00:00:50,670 --> 00:00:57,030
seven years

00:00:52,610 --> 00:00:59,670
so what three scale is it is an open

00:00:57,030 --> 00:01:02,160
source API management product so almost

00:00:59,670 --> 00:01:04,320
every one of you probably used some kind

00:01:02,160 --> 00:01:07,260
of API management you probably used some

00:01:04,320 --> 00:01:09,119
API keys to access some service but if

00:01:07,260 --> 00:01:11,640
your management is not just about API

00:01:09,119 --> 00:01:15,150
keys it's a lot about customer

00:01:11,640 --> 00:01:18,320
relationship management so you are doing

00:01:15,150 --> 00:01:20,939
things like billing developer portal

00:01:18,320 --> 00:01:23,790
workflows application approvals email

00:01:20,939 --> 00:01:27,390
notifications analytics there is a lot

00:01:23,790 --> 00:01:29,130
of UI it's adding human to the mix it's

00:01:27,390 --> 00:01:31,500
not just about between computers and API

00:01:29,130 --> 00:01:34,680
keys what it means is that we have

00:01:31,500 --> 00:01:39,780
really big end to end UI test suit and

00:01:34,680 --> 00:01:43,049
it's really slow so three scale used to

00:01:39,780 --> 00:01:44,820
be closer software for about ten years

00:01:43,049 --> 00:01:47,820
before it was acquired by Red Hat three

00:01:44,820 --> 00:01:49,799
years ago so that means we got a lot of

00:01:47,820 --> 00:01:54,149
skeletons in our closet and lots of

00:01:49,799 --> 00:01:56,219
things that we are cutting corners open

00:01:54,149 --> 00:02:00,180
sourcing took time it took about two

00:01:56,219 --> 00:02:02,630
years to get everything ready and one of

00:02:00,180 --> 00:02:06,810
the things we had to do was to actually

00:02:02,630 --> 00:02:10,009
fix our CI pipeline but last and then

00:02:06,810 --> 00:02:10,009
the last year we finally did it

00:02:10,409 --> 00:02:17,950
so any project needs a CI but open

00:02:15,220 --> 00:02:20,200
source more importantly so because it

00:02:17,950 --> 00:02:22,450
needs to scale like like if you have a

00:02:20,200 --> 00:02:23,890
small team of developers in-house it's

00:02:22,450 --> 00:02:26,160
probably a few people but if you're

00:02:23,890 --> 00:02:29,140
opening to public it's way more and

00:02:26,160 --> 00:02:31,569
there can be dozens hundreds of people

00:02:29,140 --> 00:02:33,340
contributing to your project and they

00:02:31,569 --> 00:02:35,290
need a CI and they cannot be waiting

00:02:33,340 --> 00:02:38,260
half a day before you're gonna see I

00:02:35,290 --> 00:02:39,909
built q will will finish right so it

00:02:38,260 --> 00:02:42,819
needs and it's also a great place to

00:02:39,909 --> 00:02:45,129
actually enforce some kind of rules like

00:02:42,819 --> 00:02:47,349
the test should be passing or there

00:02:45,129 --> 00:02:51,099
should be some kind of style guide

00:02:47,349 --> 00:02:54,280
enforced so RC I wasn't definitely good

00:02:51,099 --> 00:02:56,769
for external contributors because it was

00:02:54,280 --> 00:03:02,519
very local oriented on us it was pretty

00:02:56,769 --> 00:03:05,769
slow so something about our old set up

00:03:02,519 --> 00:03:08,950
we were running on Amazon we were using

00:03:05,769 --> 00:03:10,920
Jenkins and we were out to scaling ec2

00:03:08,950 --> 00:03:13,750
instances by the Jenkins plugin

00:03:10,920 --> 00:03:15,790
everything was configured and get all

00:03:13,750 --> 00:03:18,220
the Jenkins configuration we use

00:03:15,790 --> 00:03:19,840
terraform for provisioning it we were

00:03:18,220 --> 00:03:20,440
able to spin up staging environment

00:03:19,840 --> 00:03:23,620
pretty quickly

00:03:20,440 --> 00:03:25,389
but still it wasn't really scaling to

00:03:23,620 --> 00:03:30,489
external contributors because it was our

00:03:25,389 --> 00:03:32,230
internal infrastructure so we got a team

00:03:30,489 --> 00:03:35,200
about five people working at a time on

00:03:32,230 --> 00:03:39,250
the project we were doing 10 20 builds a

00:03:35,200 --> 00:03:41,290
day to pull requests and no automation

00:03:39,250 --> 00:03:45,099
around opening full requests like no

00:03:41,290 --> 00:03:46,870
automatic dependency upgrades and still

00:03:45,099 --> 00:03:49,319
sometimes developers had to wait for

00:03:46,870 --> 00:03:53,379
their bills because they were queued up

00:03:49,319 --> 00:03:56,019
so our build time are the optimistic

00:03:53,379 --> 00:03:58,329
version the warm build was about 15

00:03:56,019 --> 00:04:01,209
minutes worm built is something that is

00:03:58,329 --> 00:04:04,060
using the same machine same branch same

00:04:01,209 --> 00:04:06,579
dependencies and basically uses the

00:04:04,060 --> 00:04:09,160
cache that is already on the machine so

00:04:06,579 --> 00:04:11,799
if we add more machines the build can

00:04:09,160 --> 00:04:14,199
end up on a different machine that was

00:04:11,799 --> 00:04:16,359
causing kind of cache issues and the

00:04:14,199 --> 00:04:18,190
cache locality wasn't wasn't as good as

00:04:16,359 --> 00:04:23,020
we would as we would want

00:04:18,190 --> 00:04:26,620
the bill took about 15 minutes but over

00:04:23,020 --> 00:04:28,120
like seven or eight eight machines which

00:04:26,620 --> 00:04:31,180
was pretty pretty hard it was using

00:04:28,120 --> 00:04:34,930
about 11 CPU blocking about 11 CPU CPU

00:04:31,180 --> 00:04:39,100
hours using about 45 cores and 90

00:04:34,930 --> 00:04:40,750
gigabytes of RAM you might already see

00:04:39,100 --> 00:04:43,270
some red flags with that that's not

00:04:40,750 --> 00:04:45,010
ideal see I pipeline right but let me

00:04:43,270 --> 00:04:47,170
tell you what was our motivation to fix

00:04:45,010 --> 00:04:50,200
this maybe you will recognize some of

00:04:47,170 --> 00:04:53,560
the problems - so we got random test

00:04:50,200 --> 00:04:56,680
failures tests were executed in the

00:04:53,560 --> 00:04:59,110
alphabetical order and adding new test

00:04:56,680 --> 00:05:00,460
file would change the order so just

00:04:59,110 --> 00:05:03,700
adding new times would actually make

00:05:00,460 --> 00:05:05,620
some hundred the test cycle because they

00:05:03,700 --> 00:05:08,680
were executed differently and they had

00:05:05,620 --> 00:05:11,710
appendices between them or they were

00:05:08,680 --> 00:05:15,760
failing because of some state was not

00:05:11,710 --> 00:05:17,620
cleaned up or something it was hard to

00:05:15,760 --> 00:05:19,360
know if the failure that you were

00:05:17,620 --> 00:05:20,920
experiencing is a real failure or a

00:05:19,360 --> 00:05:23,550
random one because it was happening

00:05:20,920 --> 00:05:25,990
several times developers were just

00:05:23,550 --> 00:05:27,850
rebuilding rebuilding rebuilding without

00:05:25,990 --> 00:05:30,910
actually checking if the failure is

00:05:27,850 --> 00:05:34,330
there there caused by them or if it's

00:05:30,910 --> 00:05:36,820
just random one and rerunning the whole

00:05:34,330 --> 00:05:39,910
pipeline took time and money if you are

00:05:36,820 --> 00:05:42,220
using 45 course for one build and you

00:05:39,910 --> 00:05:46,630
have to rebuild it five times a day it

00:05:42,220 --> 00:05:49,600
costs money and that was causing another

00:05:46,630 --> 00:05:53,230
issue so our build teams one build was

00:05:49,600 --> 00:05:55,330
using several ec2 machines and if all

00:05:53,230 --> 00:05:57,760
the variables like our team is based in

00:05:55,330 --> 00:06:00,760
Barcelona and they like to go for lunch

00:05:57,760 --> 00:06:02,980
together so they go for lunch together

00:06:00,760 --> 00:06:03,460
they go back and they want to get their

00:06:02,980 --> 00:06:05,890
work done

00:06:03,460 --> 00:06:09,820
so they they just push their comments

00:06:05,890 --> 00:06:12,100
and it queues up all the builds and so

00:06:09,820 --> 00:06:15,070
it will take time to spin the new

00:06:12,100 --> 00:06:17,350
machines and spinning new machine it's

00:06:15,070 --> 00:06:19,180
not for free and it takes time and then

00:06:17,350 --> 00:06:20,800
the machine has no cash so it needs to

00:06:19,180 --> 00:06:23,440
pull all the dependencies and the builds

00:06:20,800 --> 00:06:24,850
would be able to take 45 minutes and if

00:06:23,440 --> 00:06:27,390
there was a random failure they would

00:06:24,850 --> 00:06:27,390
have to Riku

00:06:27,939 --> 00:06:36,619
so developers had to wait and wait and

00:06:31,009 --> 00:06:39,739
wait another thing was maintenance of

00:06:36,619 --> 00:06:43,909
Jenkins it's just another production

00:06:39,739 --> 00:06:46,459
system so your CI is critical part of

00:06:43,909 --> 00:06:50,149
infrastructure if you have github checks

00:06:46,459 --> 00:06:52,699
required or any other gitlab or anywhere

00:06:50,149 --> 00:06:55,399
else that are requiring your CI to pass

00:06:52,699 --> 00:06:57,679
the test - you are not going to able to

00:06:55,399 --> 00:07:00,139
multiple requests or a hot fix or

00:06:57,679 --> 00:07:02,599
whatever if your CI is not working if

00:07:00,139 --> 00:07:04,459
your tests are failing randomly you are

00:07:02,599 --> 00:07:06,139
not able to merge your hot fix that

00:07:04,459 --> 00:07:07,969
happened in production five minutes ago

00:07:06,139 --> 00:07:10,879
and you are going to have to rebuild or

00:07:07,969 --> 00:07:13,489
trust that it's safe and skip the checks

00:07:10,879 --> 00:07:15,559
right and can prevent you from deploying

00:07:13,489 --> 00:07:18,709
like we have checks that we cannot

00:07:15,559 --> 00:07:21,409
deploy get revision that wasn't passing

00:07:18,709 --> 00:07:25,279
the CI and so you have to wait for the

00:07:21,409 --> 00:07:26,839
CI it needs staging environment if

00:07:25,279 --> 00:07:29,749
you're upgrading you are you cannot

00:07:26,839 --> 00:07:31,459
afford to actually break it right for

00:07:29,749 --> 00:07:33,110
your developers or anyone so you need a

00:07:31,459 --> 00:07:35,360
staging to verify all the changes you're

00:07:33,110 --> 00:07:38,419
making actually are going to work you

00:07:35,360 --> 00:07:40,669
need security updates you need to I mean

00:07:38,419 --> 00:07:43,159
it's a lot of work it needs monitoring

00:07:40,669 --> 00:07:45,199
if it's down right like your team

00:07:43,159 --> 00:07:47,360
actually need to be on call if something

00:07:45,199 --> 00:07:49,550
happens and one of the things with

00:07:47,360 --> 00:07:51,529
Jenkins like there is LTS revision so

00:07:49,550 --> 00:07:54,019
you can actually have more stable

00:07:51,529 --> 00:07:56,419
version but the plugins don't have it so

00:07:54,019 --> 00:07:58,099
even though you are on the long-term

00:07:56,419 --> 00:08:00,110
support Jenkins that you don't have to

00:07:58,099 --> 00:08:02,089
operate it often the plugins are not

00:08:00,110 --> 00:08:04,099
following the same strategy so if you

00:08:02,089 --> 00:08:06,039
are using any of any of the plugins

00:08:04,099 --> 00:08:09,050
talking all bets are off

00:08:06,039 --> 00:08:11,029
we were running on masturbation that was

00:08:09,050 --> 00:08:15,589
fixing some weird issues with Amazon and

00:08:11,029 --> 00:08:18,289
get a crazy stuff last but not least

00:08:15,589 --> 00:08:19,699
were the costs so we were paying about

00:08:18,289 --> 00:08:23,629
two and a half thousand euros a month

00:08:19,699 --> 00:08:26,929
for our infrastructure of Jenkins just

00:08:23,629 --> 00:08:28,639
just in Amazon this is not counting the

00:08:26,929 --> 00:08:32,300
maintenance cost and developer team's

00:08:28,639 --> 00:08:34,519
top down so the total cost of our CI

00:08:32,300 --> 00:08:36,019
pipeline are not just the amazon cost

00:08:34,519 --> 00:08:37,550
it's also the maintenance to do stuff

00:08:36,019 --> 00:08:40,340
about for

00:08:37,550 --> 00:08:43,670
four days per per month of one person

00:08:40,340 --> 00:08:46,190
having to spin upstaging verify verify

00:08:43,670 --> 00:08:49,790
everything works check all the plugins

00:08:46,190 --> 00:08:51,860
are okay and all that and we have to

00:08:49,790 --> 00:08:54,950
count the developer team slow down if

00:08:51,860 --> 00:08:56,390
developers are waiting for CI they are

00:08:54,950 --> 00:08:57,980
going to juggle things right they are

00:08:56,390 --> 00:08:59,840
going to go to different pull requests

00:08:57,980 --> 00:09:01,280
they are going to start something else

00:08:59,840 --> 00:09:02,870
they're maybe going to enqueue more

00:09:01,280 --> 00:09:06,500
built so actually making the situation

00:09:02,870 --> 00:09:08,540
worse but humans are not great in the

00:09:06,500 --> 00:09:10,490
tasking so they are going to forget

00:09:08,540 --> 00:09:12,980
whatever doing before and if you ask

00:09:10,490 --> 00:09:15,650
them one hour later where is this optics

00:09:12,980 --> 00:09:17,060
done oh oh I forgot I was running a CI

00:09:15,650 --> 00:09:21,230
and then I was talking to something else

00:09:17,060 --> 00:09:25,100
and I forgot so those costs are probably

00:09:21,230 --> 00:09:27,830
the worse than the actual Amazon cost so

00:09:25,100 --> 00:09:29,960
we can embark on adventure choosing a

00:09:27,830 --> 00:09:32,780
different CI they started to take a look

00:09:29,960 --> 00:09:34,970
at their alternatives and some choose

00:09:32,780 --> 00:09:38,030
something they would scale for the team

00:09:34,970 --> 00:09:40,490
of not only our internal team but also

00:09:38,030 --> 00:09:44,900
externally to have more developers and

00:09:40,490 --> 00:09:48,710
more contributors our concerns were

00:09:44,900 --> 00:09:52,450
mostly that everyone needs access to the

00:09:48,710 --> 00:09:56,210
build status build locks artifacts and

00:09:52,450 --> 00:09:57,920
equally we cannot run it on our internal

00:09:56,210 --> 00:10:00,200
infrastructure where external

00:09:57,920 --> 00:10:02,210
contributors wouldn't have access we got

00:10:00,200 --> 00:10:05,210
options in Red Hat where we could run it

00:10:02,210 --> 00:10:07,520
locally on different internal clusters

00:10:05,210 --> 00:10:11,540
but no one externally could actually get

00:10:07,520 --> 00:10:13,730
access to it and we wouldn't want to

00:10:11,540 --> 00:10:15,800
make people white if you are going to

00:10:13,730 --> 00:10:17,690
run a CI it should run immediately it

00:10:15,800 --> 00:10:19,810
shouldn't wait for the 20 people that

00:10:17,690 --> 00:10:22,580
actually open the protocols before you

00:10:19,810 --> 00:10:26,330
because we want to scale horizontal for

00:10:22,580 --> 00:10:28,700
the people so we got a winner because

00:10:26,330 --> 00:10:30,800
we're already using circle CI for other

00:10:28,700 --> 00:10:34,130
open-source projects it was quite easy

00:10:30,800 --> 00:10:36,380
choice I would like to say we are in no

00:10:34,130 --> 00:10:38,660
way affiliated with circle CI we're just

00:10:36,380 --> 00:10:41,120
happy customers

00:10:38,660 --> 00:10:44,810
it worked for us great for open source

00:10:41,120 --> 00:10:46,579
so decided this is a good path to so

00:10:44,810 --> 00:10:48,740
Circle CI provides a free plan for open

00:10:46,579 --> 00:10:52,279
source already they also get some plans

00:10:48,740 --> 00:10:55,009
for bigger open source projects and that

00:10:52,279 --> 00:10:57,079
are something like this it's kind of

00:10:55,009 --> 00:10:59,149
infinitely scaling plans so there they

00:10:57,079 --> 00:11:01,399
have a button on the open source pricing

00:10:59,149 --> 00:11:05,959
where you can contact them and get in

00:11:01,399 --> 00:11:07,459
touch with them other than what I

00:11:05,959 --> 00:11:09,319
already mentioned the problems we were

00:11:07,459 --> 00:11:12,490
solving like providing public built

00:11:09,319 --> 00:11:14,630
information artifacts and all that and

00:11:12,490 --> 00:11:17,120
not having to maintain a production

00:11:14,630 --> 00:11:19,670
system or staging system or having

00:11:17,120 --> 00:11:21,199
someone on call for that there are some

00:11:19,670 --> 00:11:25,639
cool features that convinced us this was

00:11:21,199 --> 00:11:28,670
the right choice so we were running

00:11:25,639 --> 00:11:29,750
before kind of Natan naively splitting

00:11:28,670 --> 00:11:32,209
the test suite and just running

00:11:29,750 --> 00:11:34,880
everything by name splitting it in

00:11:32,209 --> 00:11:37,190
chunks this allows us to split by

00:11:34,880 --> 00:11:39,380
timings not all the time stay at the

00:11:37,190 --> 00:11:42,100
same time some of some orders take few

00:11:39,380 --> 00:11:45,259
minutes more tests take few seconds and

00:11:42,100 --> 00:11:48,230
this allow us to balance time balance

00:11:45,259 --> 00:11:49,939
tests across several machines but to do

00:11:48,230 --> 00:11:52,939
that you need to know how long they take

00:11:49,939 --> 00:11:56,420
from a previous runs so how it is

00:11:52,939 --> 00:12:00,800
achieved is by recording the test runs

00:11:56,420 --> 00:12:03,680
by saving the j-unit XML report which is

00:12:00,800 --> 00:12:06,560
pretty much standard nowadays so

00:12:03,680 --> 00:12:09,139
Circosta you records those those results

00:12:06,560 --> 00:12:11,449
it that gives you historical test

00:12:09,139 --> 00:12:13,550
performance that gives you ability to

00:12:11,449 --> 00:12:16,189
split them actually into chunks by by

00:12:13,550 --> 00:12:18,319
their time from previous runs it gives

00:12:16,189 --> 00:12:19,939
you the most failing tests it also gives

00:12:18,319 --> 00:12:22,399
you the ability to see which test

00:12:19,939 --> 00:12:23,810
exactly failed in your in your CI so you

00:12:22,399 --> 00:12:25,220
don't have to scroll through rocks and

00:12:23,810 --> 00:12:27,620
figure out what was wrong you will just

00:12:25,220 --> 00:12:30,519
see this fail with this line this was

00:12:27,620 --> 00:12:30,519
expected it was wrong

00:12:30,730 --> 00:12:37,780
also what it gives us is this workflow

00:12:34,210 --> 00:12:40,960
can be resumed from any point so if we

00:12:37,780 --> 00:12:43,090
got really complicated workflow and only

00:12:40,960 --> 00:12:45,160
the last step fails we can rerun from

00:12:43,090 --> 00:12:46,720
failed because some work clothes are

00:12:45,160 --> 00:12:49,030
more time-consuming than others we are

00:12:46,720 --> 00:12:50,560
running for my sequel Oracle Postgres

00:12:49,030 --> 00:12:53,400
because our products of course all of

00:12:50,560 --> 00:12:56,290
them and some of their are taking longer

00:12:53,400 --> 00:12:58,300
so each of those points can be

00:12:56,290 --> 00:13:00,070
individually run like if we have a

00:12:58,300 --> 00:13:02,950
pipeline that takes one hour and only

00:13:00,070 --> 00:13:04,000
the last 15 minutes well we can rerun

00:13:02,950 --> 00:13:06,640
the last 15 minutes

00:13:04,000 --> 00:13:08,470
I actually increases focus almost

00:13:06,640 --> 00:13:10,360
actually finally you don't have to rerun

00:13:08,470 --> 00:13:12,430
the test so it the whole test tree so if

00:13:10,360 --> 00:13:15,460
you are debugging the failure just rerun

00:13:12,430 --> 00:13:16,810
the last step don't have to wait for 45

00:13:15,460 --> 00:13:20,410
minutes before you can actually take a

00:13:16,810 --> 00:13:22,960
look into what is final and how to take

00:13:20,410 --> 00:13:26,590
a look what is failing so if you are

00:13:22,960 --> 00:13:28,930
having a CI it's really important to

00:13:26,590 --> 00:13:30,850
kind of get access to the CI if if it's

00:13:28,930 --> 00:13:33,880
a black box for you you cannot really

00:13:30,850 --> 00:13:35,260
figure out what's wrong so SSH is pretty

00:13:33,880 --> 00:13:37,780
much the holy grail of getting access

00:13:35,260 --> 00:13:40,960
anywhere right it can run shell and

00:13:37,780 --> 00:13:43,480
commands remotely it can forward local

00:13:40,960 --> 00:13:45,850
polls local ports to your remote machine

00:13:43,480 --> 00:13:47,380
like you're running some service locally

00:13:45,850 --> 00:13:50,020
and expose it and the test and access it

00:13:47,380 --> 00:13:50,380
from there our you can do the other way

00:13:50,020 --> 00:13:52,120
around

00:13:50,380 --> 00:13:54,040
you can actually forward the remote

00:13:52,120 --> 00:13:56,500
service from the from the CI to your

00:13:54,040 --> 00:13:59,200
local machine and access it locally that

00:13:56,500 --> 00:14:01,510
includes for example its server so if

00:13:59,200 --> 00:14:04,780
you are running a browser test suite on

00:14:01,510 --> 00:14:07,000
your CI you can forward the X server to

00:14:04,780 --> 00:14:09,520
your local machine and locally see the

00:14:07,000 --> 00:14:11,530
actual browser and see what that CI is

00:14:09,520 --> 00:14:14,530
clicking on in the actual browser

00:14:11,530 --> 00:14:16,690
without running it locally so no more

00:14:14,530 --> 00:14:19,300
guessing what is happening there you

00:14:16,690 --> 00:14:21,550
just Association and see what is

00:14:19,300 --> 00:14:24,580
happening actually or after it actually

00:14:21,550 --> 00:14:27,740
happened like after failure you can SSH

00:14:24,580 --> 00:14:31,580
in and rerun the tests

00:14:27,740 --> 00:14:34,640
so how're you see I see ipython it looks

00:14:31,580 --> 00:14:38,810
like it is a workflow that has several

00:14:34,640 --> 00:14:41,270
smaller jobs some jobs need more

00:14:38,810 --> 00:14:43,760
dependencies and can start earlier like

00:14:41,270 --> 00:14:46,400
unit X or R Spec they are they don't

00:14:43,760 --> 00:14:49,250
need for example JavaScript assets so

00:14:46,400 --> 00:14:50,990
they can be executed earlier we can

00:14:49,250 --> 00:14:55,190
install dependencies for all of them

00:14:50,990 --> 00:14:57,410
just once so we are installing our Ruby

00:14:55,190 --> 00:14:59,230
and JavaScript dependencies early and

00:14:57,410 --> 00:15:02,330
then just sharing them with other jobs

00:14:59,230 --> 00:15:04,250
it is blocking less resources because

00:15:02,330 --> 00:15:07,400
there are more granular we don't need to

00:15:04,250 --> 00:15:10,820
have 40 containers for instant

00:15:07,400 --> 00:15:12,920
dependencies we just need one so each

00:15:10,820 --> 00:15:16,940
job can have different concurrency level

00:15:12,920 --> 00:15:19,820
those those multipliers are the

00:15:16,940 --> 00:15:22,700
concurrence letter of each tasks so

00:15:19,820 --> 00:15:24,740
because we got really big and fat tests

00:15:22,700 --> 00:15:27,110
to it there is those cucumber tests are

00:15:24,740 --> 00:15:29,210
the UI UI tests we are running with a 40

00:15:27,110 --> 00:15:31,250
times concurrency and of course we don't

00:15:29,210 --> 00:15:33,350
want to be paying 40 times concurrency

00:15:31,250 --> 00:15:34,820
for pre compiling something or

00:15:33,350 --> 00:15:36,580
installing dependencies because it

00:15:34,820 --> 00:15:40,370
doesn't doesn't doesn't make sense

00:15:36,580 --> 00:15:44,870
and that allow us to actually get pretty

00:15:40,370 --> 00:15:48,590
good savings so we got we got to about a

00:15:44,870 --> 00:15:50,180
half cost how far all set up but that's

00:15:48,590 --> 00:15:53,150
not they was caused by several things so

00:15:50,180 --> 00:15:55,010
first it's priced per minute so we don't

00:15:53,150 --> 00:15:57,920
have idle machines running for the whole

00:15:55,010 --> 00:15:59,630
hour the workflow allows different

00:15:57,920 --> 00:16:01,940
levels of parallelism so we don't have

00:15:59,630 --> 00:16:03,620
to have 16 core machine to run

00:16:01,940 --> 00:16:06,200
everything but we can kind of have

00:16:03,620 --> 00:16:08,630
smaller machines for smaller containers

00:16:06,200 --> 00:16:10,430
for smaller workloads it has way better

00:16:08,630 --> 00:16:11,900
caching because it can share cache

00:16:10,430 --> 00:16:14,510
between different machines and

00:16:11,900 --> 00:16:18,140
containers and it can rerun those

00:16:14,510 --> 00:16:21,110
failures pretty pretty nicely and this

00:16:18,140 --> 00:16:23,540
is half of the costs after we doubled

00:16:21,110 --> 00:16:24,460
the team and added automatic dependency

00:16:23,540 --> 00:16:27,300
upgrades

00:16:24,460 --> 00:16:30,310
and those are taking another half of the

00:16:27,300 --> 00:16:33,400
resources so for for example if there is

00:16:30,310 --> 00:16:35,620
new no js' depend kind of dependence a

00:16:33,400 --> 00:16:37,630
security issue it will automatically

00:16:35,620 --> 00:16:39,670
open full request and merge it if it's

00:16:37,630 --> 00:16:42,430
passing all the tests and those happens

00:16:39,670 --> 00:16:43,960
several times a day because there is

00:16:42,430 --> 00:16:51,070
like we've got hundreds of dependencies

00:16:43,960 --> 00:16:53,140
so actually our most most used or like

00:16:51,070 --> 00:16:54,940
the biggest user of our CI is these

00:16:53,140 --> 00:16:59,410
automatic dependency upgrades it uses

00:16:54,940 --> 00:16:59,770
about 50% of our pipeline how we got

00:16:59,410 --> 00:17:02,020
there

00:16:59,770 --> 00:17:05,170
getting there was quite straightforward

00:17:02,020 --> 00:17:06,670
it was not easy but straightforward we

00:17:05,170 --> 00:17:09,550
just have to run our test two thousand

00:17:06,670 --> 00:17:11,980
times as we heard before this was kind

00:17:09,550 --> 00:17:13,480
of the bug hunt so just right thousand

00:17:11,980 --> 00:17:15,250
times and see what is actually

00:17:13,480 --> 00:17:19,030
strangling and then we had to fix

00:17:15,250 --> 00:17:22,930
everything we found the major issue is

00:17:19,030 --> 00:17:25,180
flaky tests so flaky tests are does that

00:17:22,930 --> 00:17:28,240
good fail or pass for the same

00:17:25,180 --> 00:17:30,340
configuration and they could fail or

00:17:28,240 --> 00:17:32,500
pass for various reasons and they could

00:17:30,340 --> 00:17:35,590
be because it's of some shark state

00:17:32,500 --> 00:17:37,510
either in a database or a file or

00:17:35,590 --> 00:17:40,270
something or some concurrency in the

00:17:37,510 --> 00:17:43,270
test or they could be network or timing

00:17:40,270 --> 00:17:44,920
issues and those are probably ones that

00:17:43,270 --> 00:17:51,820
are affecting the horizontal is scaling

00:17:44,920 --> 00:17:54,010
the post so one of the kinds of flaky

00:17:51,820 --> 00:17:56,830
tests are than ones that have their

00:17:54,010 --> 00:17:59,770
distinct so some tests require external

00:17:56,830 --> 00:18:02,920
state like records in database or files

00:17:59,770 --> 00:18:05,530
and they fail to clean up after so if

00:18:02,920 --> 00:18:07,420
the next text executes it can cause

00:18:05,530 --> 00:18:10,900
failures because they are not not

00:18:07,420 --> 00:18:12,430
expecting that and it is happening when

00:18:10,900 --> 00:18:13,930
they are executed together not in

00:18:12,430 --> 00:18:16,210
standalone so if you get this test

00:18:13,930 --> 00:18:18,160
failing on your CI alright locally and

00:18:16,210 --> 00:18:19,660
it's going to work because running just

00:18:18,160 --> 00:18:21,370
this one if you'll be running with this

00:18:19,660 --> 00:18:23,740
other test that was costing the actually

00:18:21,370 --> 00:18:27,430
the leakage in the database they would

00:18:23,740 --> 00:18:29,140
fail sometimes it's not necessary to

00:18:27,430 --> 00:18:31,120
clean up you can like if you are having

00:18:29,140 --> 00:18:33,310
a database for every test or creating a

00:18:31,120 --> 00:18:33,960
new workspace that the base transaction

00:18:33,310 --> 00:18:36,090
or something

00:18:33,960 --> 00:18:42,119
you can just kind of garbage collect it

00:18:36,090 --> 00:18:44,879
later another failure is reliance in

00:18:42,119 --> 00:18:48,559
some other tests that if you have some

00:18:44,879 --> 00:18:51,210
test that is making a global variable or

00:18:48,559 --> 00:18:53,429
studying some methods or doing something

00:18:51,210 --> 00:18:55,350
globally to the runtime of the language

00:18:53,429 --> 00:18:59,009
you are you are doing it's preparing

00:18:55,350 --> 00:19:00,450
something for the other tests and if

00:18:59,009 --> 00:19:02,639
they are sorted for example

00:19:00,450 --> 00:19:04,200
alphabetically they are kind of

00:19:02,639 --> 00:19:05,940
expecting that something is doing the

00:19:04,200 --> 00:19:08,700
setup for them right and if you execute

00:19:05,940 --> 00:19:13,549
them in isolation they might fail

00:19:08,700 --> 00:19:16,049
because they are not being prepared so

00:19:13,549 --> 00:19:18,690
what can happen is like if you are

00:19:16,049 --> 00:19:21,690
paralyzing and those new tests are being

00:19:18,690 --> 00:19:23,309
added those that are actually depending

00:19:21,690 --> 00:19:26,789
on something else can be pushed

00:19:23,309 --> 00:19:28,639
different different container and don't

00:19:26,789 --> 00:19:30,929
have this set up so they will fail or

00:19:28,639 --> 00:19:32,399
they will actually fail because they're

00:19:30,929 --> 00:19:37,350
executed with some other and they are

00:19:32,399 --> 00:19:40,619
doing the same thing so how to ensure

00:19:37,350 --> 00:19:42,869
your test fit is healthy so definitely

00:19:40,619 --> 00:19:46,950
start with randomizing the order of your

00:19:42,869 --> 00:19:49,470
test to it executed in random order and

00:19:46,950 --> 00:19:51,330
running it a lot of times like hundred

00:19:49,470 --> 00:19:55,559
times overnight you're going to figure

00:19:51,330 --> 00:19:57,600
out that actually there are issues but

00:19:55,559 --> 00:19:59,249
before just blindly setting random order

00:19:57,600 --> 00:20:00,720
you cannot need to know that you can

00:19:59,249 --> 00:20:02,369
actually reproduce the random order

00:20:00,720 --> 00:20:04,950
because random still has to be the

00:20:02,369 --> 00:20:07,440
deterministic so usually it is done by

00:20:04,950 --> 00:20:10,169
setting the random seed of the of the

00:20:07,440 --> 00:20:13,080
random number generator so that usually

00:20:10,169 --> 00:20:15,570
if you run the test suite with a random

00:20:13,080 --> 00:20:17,549
order it prints the random seed so make

00:20:15,570 --> 00:20:19,259
sure that actually you can get that

00:20:17,549 --> 00:20:21,360
number from your test suite and verify

00:20:19,259 --> 00:20:23,610
it's actually working and you can rerun

00:20:21,360 --> 00:20:26,730
in the same order again if you see the

00:20:23,610 --> 00:20:28,799
failure it's usually done with some like

00:20:26,730 --> 00:20:30,869
plain text format or from your test

00:20:28,799 --> 00:20:32,879
suite and to show you the order the

00:20:30,869 --> 00:20:37,169
tests are executed in and then verify

00:20:32,879 --> 00:20:39,730
you can exit them in exactly same order

00:20:37,169 --> 00:20:42,370
right and you need to record test

00:20:39,730 --> 00:20:46,090
failures by for example using the

00:20:42,370 --> 00:20:49,059
generate test test test recorder you can

00:20:46,090 --> 00:20:50,799
know what tests were executed in what

00:20:49,059 --> 00:20:54,159
order what containers and you can then

00:20:50,799 --> 00:20:56,289
try to reproduce it so how do you

00:20:54,159 --> 00:20:58,330
actually reproduce it right so when you

00:20:56,289 --> 00:21:01,090
get a test suite how do you figure out

00:20:58,330 --> 00:21:05,049
what kind of tests were executed

00:21:01,090 --> 00:21:07,330
together so this approach works only for

00:21:05,049 --> 00:21:10,690
deterministic feathers like if those

00:21:07,330 --> 00:21:12,549
tests are going to fail every time they

00:21:10,690 --> 00:21:15,010
are executed together in the same order

00:21:12,549 --> 00:21:17,710
then you can figure it out if it's

00:21:15,010 --> 00:21:22,830
caused because of concurrency timing

00:21:17,710 --> 00:21:25,269
issues or network it's way harder so

00:21:22,830 --> 00:21:27,399
usually just start with taking the seed

00:21:25,269 --> 00:21:28,960
from the sea from the CI and rerun them

00:21:27,399 --> 00:21:30,940
locally the whole batch of tests that

00:21:28,960 --> 00:21:34,720
that was happening in that one container

00:21:30,940 --> 00:21:37,059
and you can start by using SSH to SSH to

00:21:34,720 --> 00:21:38,440
the container in the CI and rerun it

00:21:37,059 --> 00:21:40,809
there on the same machine the same

00:21:38,440 --> 00:21:42,190
environment and if it fails bingo right

00:21:40,809 --> 00:21:45,460
that's the good thing if you actually

00:21:42,190 --> 00:21:49,210
can find it fail then try it locally and

00:21:45,460 --> 00:21:50,919
see if it fails if it doesn't okay you

00:21:49,210 --> 00:21:53,559
still have to see a environment to

00:21:50,919 --> 00:21:56,169
Association and try it there and then

00:21:53,559 --> 00:21:58,269
usually just remove the half of the test

00:21:56,169 --> 00:22:00,100
the test you are executing and see if

00:21:58,269 --> 00:22:02,590
it's actually failing right like

00:22:00,100 --> 00:22:04,899
bisecting by hand and then if it's not

00:22:02,590 --> 00:22:06,429
failing just try the other half and try

00:22:04,899 --> 00:22:09,279
with different chunks and just try to

00:22:06,429 --> 00:22:12,010
minimize what is actually failing until

00:22:09,279 --> 00:22:17,049
you find those two or three that are

00:22:12,010 --> 00:22:19,360
actually failing together this applies

00:22:17,049 --> 00:22:20,799
to the tests that are actually depending

00:22:19,360 --> 00:22:23,789
on each other or not cleaning up the

00:22:20,799 --> 00:22:26,769
stain and then it's useful if you have

00:22:23,789 --> 00:22:28,840
for example a sage access to the

00:22:26,769 --> 00:22:30,580
database you can kind of see the log of

00:22:28,840 --> 00:22:32,769
the database you can see like if you're

00:22:30,580 --> 00:22:34,779
reading some things like Redis that

00:22:32,769 --> 00:22:37,090
don't have read transactions you can get

00:22:34,779 --> 00:22:38,899
a few small later to see what the tastic

00:22:37,090 --> 00:22:41,340
is doing

00:22:38,899 --> 00:22:44,429
what are the things that actually helped

00:22:41,340 --> 00:22:46,679
us to save costs was dependency caching

00:22:44,429 --> 00:22:50,009
so install dependencies takes time our

00:22:46,679 --> 00:22:52,320
project depend on on Ruby on ojs and

00:22:50,009 --> 00:22:55,590
just installing the Ruby dependencies

00:22:52,320 --> 00:22:57,870
would take about 30 minutes and doing it

00:22:55,590 --> 00:23:04,919
on every build is definitely not not not

00:22:57,870 --> 00:23:07,590
a good thing so there are several kinds

00:23:04,919 --> 00:23:10,019
of dependencies the most common case are

00:23:07,590 --> 00:23:13,110
packages right like your your language

00:23:10,019 --> 00:23:15,659
dependencies like ruby gems in Python

00:23:13,110 --> 00:23:20,490
will be AG I think of something no js'

00:23:15,659 --> 00:23:23,460
it's just packages you definitely need

00:23:20,490 --> 00:23:25,909
to use transitive dependency locking

00:23:23,460 --> 00:23:29,759
that means all your dependencies that

00:23:25,909 --> 00:23:31,529
are you using even your dependencies of

00:23:29,759 --> 00:23:34,769
your dependencies and your dependencies

00:23:31,529 --> 00:23:37,860
are locked in a file to a specific

00:23:34,769 --> 00:23:40,470
version and you are going to take that

00:23:37,860 --> 00:23:42,899
file and that's your kinda canonical

00:23:40,470 --> 00:23:45,450
representation of your dependencies then

00:23:42,899 --> 00:23:48,029
you can you can easily cash it because

00:23:45,450 --> 00:23:50,639
if you digest that file like md5 you get

00:23:48,029 --> 00:23:52,889
a nice cache key and you can see that

00:23:50,639 --> 00:23:56,519
all those dependencies are in this cache

00:23:52,889 --> 00:23:58,980
file and you know that if any of those

00:23:56,519 --> 00:24:01,259
dependencies or dependencies of your

00:23:58,980 --> 00:24:04,320
dependencies change you are going to

00:24:01,259 --> 00:24:08,009
install the new one that allows you to

00:24:04,320 --> 00:24:09,629
kind of use layers for example you can

00:24:08,009 --> 00:24:11,100
have a cache for a master branch and

00:24:09,629 --> 00:24:13,470
then for your branch and then for some

00:24:11,100 --> 00:24:15,539
for something else and if you change

00:24:13,470 --> 00:24:17,070
just one dependency you can kind of take

00:24:15,539 --> 00:24:19,080
the cache of the master branch and

00:24:17,070 --> 00:24:21,360
install just one missing dependency

00:24:19,080 --> 00:24:23,700
instead of installing all the old old

00:24:21,360 --> 00:24:27,210
ones and spending just one minute

00:24:23,700 --> 00:24:30,870
instead of 30 and these cached can be

00:24:27,210 --> 00:24:32,370
shared between between builds and also

00:24:30,870 --> 00:24:34,500
there is one thing that like if you are

00:24:32,370 --> 00:24:37,830
installing dependencies for example Ruby

00:24:34,500 --> 00:24:40,049
allows you to paralyze the installation

00:24:37,830 --> 00:24:43,169
so you are kind of compiling all of them

00:24:40,049 --> 00:24:45,480
on all cores and not just serially it's

00:24:43,169 --> 00:24:47,490
pretty helpful

00:24:45,480 --> 00:24:50,220
there are other kinds of dependencies

00:24:47,490 --> 00:24:52,560
and that's internal ones so for example

00:24:50,220 --> 00:24:54,750
if you are pre compiling assets

00:24:52,560 --> 00:24:57,660
magnifying images and doing all that

00:24:54,750 --> 00:24:59,310
there is no need to do it in every part

00:24:57,660 --> 00:25:00,810
of your pipeline you can do it only in

00:24:59,310 --> 00:25:04,740
one and then share it with the other

00:25:00,810 --> 00:25:08,190
parts if you are like you have seen we

00:25:04,740 --> 00:25:11,480
are running with 40 levels of

00:25:08,190 --> 00:25:13,680
parallelization if that step would be

00:25:11,480 --> 00:25:16,260
adding one minute of pre compiling

00:25:13,680 --> 00:25:19,290
images we would be paying for 40 minutes

00:25:16,260 --> 00:25:22,170
of pre compiling images if we are moving

00:25:19,290 --> 00:25:24,990
that one step to a one level

00:25:22,170 --> 00:25:29,340
paralyzation in before it it will still

00:25:24,990 --> 00:25:30,720
take the same time like from start to

00:25:29,340 --> 00:25:32,180
finish right it will take one minute and

00:25:30,720 --> 00:25:34,440
then seven minutes to run the test

00:25:32,180 --> 00:25:37,440
otherwise it would take 8 meter on the

00:25:34,440 --> 00:25:40,740
test but we would be paying only for one

00:25:37,440 --> 00:25:43,830
one time one minute not 40 times one

00:25:40,740 --> 00:25:49,170
minute so that allows to save a lot of

00:25:43,830 --> 00:25:52,890
money so what it take away is love your

00:25:49,170 --> 00:25:55,140
tests run them a lot and treat them as a

00:25:52,890 --> 00:25:56,370
production code base and if you love

00:25:55,140 --> 00:26:00,420
them they will love you back and give

00:25:56,370 --> 00:26:05,070
you good feedback and everyone will be

00:26:00,420 --> 00:26:07,470
happy so that's it

00:26:05,070 --> 00:26:09,660
it's my yeah that's everything is open

00:26:07,470 --> 00:26:11,490
source so we are actually making some

00:26:09,660 --> 00:26:14,130
improvements and you can kind of check

00:26:11,490 --> 00:26:16,500
to pull requests how to optimize and

00:26:14,130 --> 00:26:18,120
make your test fit faster regarding

00:26:16,500 --> 00:26:20,330
installing notice dependencies and all

00:26:18,120 --> 00:26:20,330
that

00:26:22,100 --> 00:26:28,459
that's thank you

00:26:24,660 --> 00:26:28,459

YouTube URL: https://www.youtube.com/watch?v=Ws9SqPSIOkw


