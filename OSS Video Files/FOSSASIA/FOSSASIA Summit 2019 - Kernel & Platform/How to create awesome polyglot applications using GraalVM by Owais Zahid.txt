Title: How to create awesome polyglot applications using GraalVM by Owais Zahid
Publication date: 2019-03-29
Playlist: FOSSASIA Summit 2019 - Kernel & Platform
Description: 
	15 March 2019 16:10, Theatre Lounge

It is a common sight to see teams struggling to collaborate because of varying preference of programming languages. GraalVM is a universal virtual machine created to address this issue. 

In this session, we will look at how you can use GraalVM to create polyglot applications with ease. It is a hands-on live coding session where we will look at Ruby, NodeJS & Java interoperability.
Captions: 
	00:00:00,030 --> 00:00:08,490
we have a ways he's software development

00:00:04,380 --> 00:00:09,960
manager our to Autodesk here and he has

00:00:08,490 --> 00:00:12,450
12 years of software development

00:00:09,960 --> 00:00:14,759
experience in web mobile development

00:00:12,450 --> 00:00:19,109
server-side programming my child scrum

00:00:14,759 --> 00:00:21,060
and project management and has degrees

00:00:19,109 --> 00:00:24,689
in computer science and project

00:00:21,060 --> 00:00:27,060
management so he'll be talking about how

00:00:24,689 --> 00:00:32,070
to create awesome polyglot applications

00:00:27,060 --> 00:00:47,070
using growl VM very good so let's let's

00:00:32,070 --> 00:00:48,840
welcome aways okay hello yeah okay hello

00:00:47,070 --> 00:00:53,309
everyone thank you for joining this

00:00:48,840 --> 00:00:56,550
session I really admire your resolve

00:00:53,309 --> 00:00:58,559
like coming in a freezing room to

00:00:56,550 --> 00:01:00,059
listening to this talk yeah we

00:00:58,559 --> 00:01:03,840
Singaporeans have like a very low

00:01:00,059 --> 00:01:05,700
tolerance of cold anyways so just bear

00:01:03,840 --> 00:01:09,119
with me all right

00:01:05,700 --> 00:01:11,490
so today we will talk about how to

00:01:09,119 --> 00:01:15,960
create polyglot applications using growl

00:01:11,490 --> 00:01:17,909
um quick introduction before I before we

00:01:15,960 --> 00:01:20,580
go further

00:01:17,909 --> 00:01:23,250
my name is os ahead I have over 14 years

00:01:20,580 --> 00:01:26,909
of experience working around the globe

00:01:23,250 --> 00:01:29,159
my main focus area is on cloud platforms

00:01:26,909 --> 00:01:31,710
creating cloud products and services

00:01:29,159 --> 00:01:35,729
with an emphasis on resiliency and

00:01:31,710 --> 00:01:38,549
scalability javascript is my main forte

00:01:35,729 --> 00:01:40,320
I love football and follow AS Roma they

00:01:38,549 --> 00:01:44,790
are not doing really good this season

00:01:40,320 --> 00:01:47,579
again but I still love them so you can

00:01:44,790 --> 00:01:49,649
follow me on Twitter and LinkedIn as

00:01:47,579 --> 00:01:54,110
well the handles are a bit sort of

00:01:49,649 --> 00:02:00,259
chopped but you can ask me later

00:01:54,110 --> 00:02:03,240
so interoperability when we talk about

00:02:00,259 --> 00:02:05,759
polyglot applications or language

00:02:03,240 --> 00:02:07,590
interoperability in general there are a

00:02:05,759 --> 00:02:11,310
lot of frameworks out there that can do

00:02:07,590 --> 00:02:13,120
that so I started looking at growl um

00:02:11,310 --> 00:02:16,459
few months ago

00:02:13,120 --> 00:02:19,220
when I was trying to evaluate a

00:02:16,459 --> 00:02:23,900
messaging SDK written by another team

00:02:19,220 --> 00:02:28,730
and Autodesk in Java and my team works

00:02:23,900 --> 00:02:31,519
in Ruby so this is not a very unique

00:02:28,730 --> 00:02:34,459
scenario that people will say oh geez

00:02:31,519 --> 00:02:38,269
what are the odds in fact in the

00:02:34,459 --> 00:02:41,569
enterprise setting it is all it is the

00:02:38,269 --> 00:02:44,540
development work is done by various

00:02:41,569 --> 00:02:47,480
teams or agile teams and more often than

00:02:44,540 --> 00:02:50,470
not they choose different tools and

00:02:47,480 --> 00:02:53,450
technologies for their respective work

00:02:50,470 --> 00:02:55,459
sometimes based on their preference or

00:02:53,450 --> 00:02:58,970
sometimes based on the problem they are

00:02:55,459 --> 00:03:01,519
trying to solve for example people

00:02:58,970 --> 00:03:04,069
usually go for Python when they are

00:03:01,519 --> 00:03:07,010
working on machine learning solutions or

00:03:04,069 --> 00:03:09,739
go for R for data science so it is

00:03:07,010 --> 00:03:13,430
common to come across scenarios like

00:03:09,739 --> 00:03:17,359
this where you want to use something and

00:03:13,430 --> 00:03:22,190
that particular piece of code is not

00:03:17,359 --> 00:03:25,100
written in your language so I started

00:03:22,190 --> 00:03:27,489
evaluating the options so there are a

00:03:25,100 --> 00:03:31,940
lot of things out there for

00:03:27,489 --> 00:03:35,359
interoperability some of them are using

00:03:31,940 --> 00:03:38,410
a language neutral mechanism or

00:03:35,359 --> 00:03:40,220
interfaces to allow interaction like

00:03:38,410 --> 00:03:43,160
thrift swig

00:03:40,220 --> 00:03:45,549
I can throw protocol buffer into it as

00:03:43,160 --> 00:03:48,310
well but it has a different use case

00:03:45,549 --> 00:03:52,790
then you have some libraries which are

00:03:48,310 --> 00:03:54,859
specific to either a platform or a

00:03:52,790 --> 00:03:59,690
language or they focuses mainly on

00:03:54,859 --> 00:04:05,720
bridging the native to manage code code

00:03:59,690 --> 00:04:07,819
bases like GN GN I J and if you look at

00:04:05,720 --> 00:04:10,180
cloud platforms they are also trying a

00:04:07,819 --> 00:04:14,260
few things recently

00:04:10,180 --> 00:04:17,269
AWS they introduced layers with AWS

00:04:14,260 --> 00:04:20,389
lambda so that you can have you can

00:04:17,269 --> 00:04:23,000
create a common code base for use across

00:04:20,389 --> 00:04:27,270
multiple cloud functions so you can

00:04:23,000 --> 00:04:31,229
always use their custom runtime API

00:04:27,270 --> 00:04:37,560
a lair in a different language and then

00:04:31,229 --> 00:04:40,500
I came across crawl so growl has a a

00:04:37,560 --> 00:04:47,190
very kind of a unique way of solving

00:04:40,500 --> 00:04:50,430
this problem no interface files sort of

00:04:47,190 --> 00:04:52,740
a that support for languages they have a

00:04:50,430 --> 00:04:56,479
good set of languages to support and

00:04:52,740 --> 00:05:00,360
then it is not specific to any platform

00:04:56,479 --> 00:05:04,620
so today's focus is on growl VM so let's

00:05:00,360 --> 00:05:07,550
look at what chromium is so growl VM is

00:05:04,620 --> 00:05:10,050
a polyglot multilingual virtual machine

00:05:07,550 --> 00:05:12,870
it creates a common stack for

00:05:10,050 --> 00:05:17,340
applications running in Java JavaScript

00:05:12,870 --> 00:05:19,550
Python are C++ and many more and this

00:05:17,340 --> 00:05:27,740
common stack actually allows

00:05:19,550 --> 00:05:30,599
interoperability in a shared runtime so

00:05:27,740 --> 00:05:34,620
just to look at like the holistic view

00:05:30,599 --> 00:05:38,759
of growl um this is a holistic view of

00:05:34,620 --> 00:05:44,039
growl VM there are different layers of

00:05:38,759 --> 00:05:47,190
growl VM starts with Java VM then there

00:05:44,039 --> 00:05:50,070
is a compiler growl compiler and then a

00:05:47,190 --> 00:05:52,590
truffle framework on top of it so

00:05:50,070 --> 00:05:53,520
there's a lot going on here so let's

00:05:52,590 --> 00:05:59,880
take a stab at it

00:05:53,520 --> 00:06:03,030
one component at a time ok so growl

00:05:59,880 --> 00:06:08,699
compiler growl compiler is the most

00:06:03,030 --> 00:06:11,039
important aspect of the growl VM the

00:06:08,699 --> 00:06:13,139
only difference between the VM which is

00:06:11,039 --> 00:06:17,060
the hot spot VM and the growl VM is the

00:06:13,139 --> 00:06:21,960
fact that growl VM uses growl compiler

00:06:17,060 --> 00:06:25,650
in the as a c2 compilation mode so as

00:06:21,960 --> 00:06:28,349
you know that in a you know in JVM we

00:06:25,650 --> 00:06:34,860
have two JIT compilers other than Java C

00:06:28,349 --> 00:06:36,810
C 1 and C 2 so these two compilers have

00:06:34,860 --> 00:06:38,460
different techniques for JIT compilation

00:06:36,810 --> 00:06:41,460
and

00:06:38,460 --> 00:06:43,910
can generate a different machine code

00:06:41,460 --> 00:06:48,000
for the same Java method

00:06:43,910 --> 00:06:50,370
so usually Java applications make use of

00:06:48,000 --> 00:06:52,380
both of them and which is called tiered

00:06:50,370 --> 00:06:58,620
compilation which is a default since

00:06:52,380 --> 00:07:03,840
Java 8 so in the tiered compilation in

00:06:58,620 --> 00:07:07,080
the tier compilation is is start by

00:07:03,840 --> 00:07:09,210
using c1 at the start at the start of

00:07:07,080 --> 00:07:11,220
the application for a better startup

00:07:09,210 --> 00:07:13,290
performance and then once the

00:07:11,220 --> 00:07:16,470
application is properly warmed up then

00:07:13,290 --> 00:07:21,650
c2 compiler kicks in for more aggressive

00:07:16,470 --> 00:07:25,320
optimization and better performance so

00:07:21,650 --> 00:07:27,680
having like a new compiler that can take

00:07:25,320 --> 00:07:31,050
okay so by the way c1 c2 is also called

00:07:27,680 --> 00:07:35,760
Klein compiler and sour compiler as well

00:07:31,050 --> 00:07:37,560
so both are fine so replacing a c2

00:07:35,760 --> 00:07:42,539
compiler or server compiler with crawl

00:07:37,560 --> 00:07:47,430
compiler is not something unique if you

00:07:42,539 --> 00:07:49,800
have seen different SDKs like adop SDK

00:07:47,430 --> 00:07:57,539
or Azul SDK they have their own

00:07:49,800 --> 00:08:02,010
customized compilers in the JVM so so

00:07:57,539 --> 00:08:04,410
what crawl is sort of giving us what c1

00:08:02,010 --> 00:08:08,700
and c2 was not giving us so to start

00:08:04,410 --> 00:08:10,940
with growl compiler is written from

00:08:08,700 --> 00:08:13,590
scratch in Java

00:08:10,940 --> 00:08:17,310
unlike c1 and c2 compilers which are

00:08:13,590 --> 00:08:19,860
written in C C++ I know you guys will be

00:08:17,310 --> 00:08:25,680
asking like how can this be a good thing

00:08:19,860 --> 00:08:29,330
so but it is known that the the C 1 C 2

00:08:25,680 --> 00:08:31,740
compilers have had known issues and

00:08:29,330 --> 00:08:34,349
optimization in the context of strongly

00:08:31,740 --> 00:08:39,510
typed managed languages can be done

00:08:34,349 --> 00:08:42,180
better so it makes sense to have to have

00:08:39,510 --> 00:08:46,050
a compiler written in Java or some

00:08:42,180 --> 00:08:48,180
high-level language there is a there is

00:08:46,050 --> 00:08:49,950
a good link that i will share later it

00:08:48,180 --> 00:08:53,340
was supposed to be there at the bottom

00:08:49,950 --> 00:08:55,610
right corner it's kind of chopped

00:08:53,340 --> 00:08:58,800
which is actually talking about this

00:08:55,610 --> 00:09:01,980
topic specifically like why it makes

00:08:58,800 --> 00:09:06,510
sense to have a compiler written in Java

00:09:01,980 --> 00:09:08,610
in the VM were in the VM ecosystem but I

00:09:06,510 --> 00:09:11,850
will share that references at the end as

00:09:08,610 --> 00:09:13,800
well so I will not go into the detail of

00:09:11,850 --> 00:09:20,730
it because that will sort of become a

00:09:13,800 --> 00:09:24,690
totally different topic so alright so

00:09:20,730 --> 00:09:29,520
yeah I need to catch up where I was yeah

00:09:24,690 --> 00:09:31,920
so it's written in Java and the reason

00:09:29,520 --> 00:09:35,670
it is possible for the drol VM to be

00:09:31,920 --> 00:09:38,760
integrated in the JVM world is based on

00:09:35,670 --> 00:09:41,280
the thing called JVM ci Java Virtual

00:09:38,760 --> 00:09:44,160
Machine compiler interface which is

00:09:41,280 --> 00:09:46,350
which was added in JDK 9 and since

00:09:44,160 --> 00:09:51,270
things then back ported to Java 8 as

00:09:46,350 --> 00:09:55,970
well so that allows any compiler to be

00:09:51,270 --> 00:09:58,320
sort of act as CC to compiler and

00:09:55,970 --> 00:10:00,770
interface and then sort of get all the

00:09:58,320 --> 00:10:03,570
events and then process and give it back

00:10:00,770 --> 00:10:05,460
so the good the benefits that we will

00:10:03,570 --> 00:10:08,970
get withdrawal there are three main

00:10:05,460 --> 00:10:12,390
benefits first it is more maintainable

00:10:08,970 --> 00:10:14,730
as compared to c1 c2 compilers it is

00:10:12,390 --> 00:10:18,330
open source available good community

00:10:14,730 --> 00:10:22,350
around it it is not tightly coupled with

00:10:18,330 --> 00:10:26,250
JVM so you can use drawl compiler in

00:10:22,350 --> 00:10:28,410
different contexts as well and the third

00:10:26,250 --> 00:10:32,960
thing it has a good support for truffle

00:10:28,410 --> 00:10:34,710
based languages talking about truffle

00:10:32,960 --> 00:10:37,680
that's the second thing

00:10:34,710 --> 00:10:40,260
so truffle is a language implementation

00:10:37,680 --> 00:10:45,330
framework that runs on top of draw as

00:10:40,260 --> 00:10:48,620
you can see it here so the runtimes

00:10:45,330 --> 00:10:51,390
created by this truffle framework

00:10:48,620 --> 00:10:55,850
interprets languages as abstract syntax

00:10:51,390 --> 00:11:02,340
tree and it currently supports our

00:10:55,850 --> 00:11:05,220
Python Ruby and it it has a good

00:11:02,340 --> 00:11:06,030
documentation the fourth provisioning of

00:11:05,220 --> 00:11:09,090
new

00:11:06,030 --> 00:11:11,760
programming languages as well so if you

00:11:09,090 --> 00:11:15,870
are developing your your language using

00:11:11,760 --> 00:11:17,310
this framework then in the JVM we'll

00:11:15,870 --> 00:11:19,410
look at your programming language

00:11:17,310 --> 00:11:25,770
implementation as as any other Java

00:11:19,410 --> 00:11:28,140
program so the advantage of having a

00:11:25,770 --> 00:11:32,670
common framework to create different

00:11:28,140 --> 00:11:36,420
languages actually helps you in the

00:11:32,670 --> 00:11:38,600
interoperability between them and you

00:11:36,420 --> 00:11:40,320
can have a language agnostic

00:11:38,600 --> 00:11:41,820
instrumentation around it as well

00:11:40,320 --> 00:11:44,610
because if all of them are running on

00:11:41,820 --> 00:11:47,760
JVM so you can use profilers samplers

00:11:44,610 --> 00:11:51,300
tracers all the things that you we do

00:11:47,760 --> 00:11:58,740
for any other Java app program running

00:11:51,300 --> 00:12:03,290
in JVM so so long is one of the

00:11:58,740 --> 00:12:07,280
implementations of truffle it is LLVM

00:12:03,290 --> 00:12:09,060
interpreter low-level virtual machine

00:12:07,280 --> 00:12:11,850
it's support

00:12:09,060 --> 00:12:15,500
it supports c++ Fortran and all the

00:12:11,850 --> 00:12:18,690
languages that can be translated into

00:12:15,500 --> 00:12:23,220
LLVM bit code using any front ends like

00:12:18,690 --> 00:12:25,860
clang or mic Ruby so if anyone of you

00:12:23,220 --> 00:12:27,930
are interested in looking at like how to

00:12:25,860 --> 00:12:31,950
bridge the gap between native and

00:12:27,930 --> 00:12:34,230
managed code and you want to try growl

00:12:31,950 --> 00:12:40,440
VM so this is the place you should be

00:12:34,230 --> 00:12:44,400
looking at all right ahead of time

00:12:40,440 --> 00:12:45,990
compilation ahead of time compile it

00:12:44,400 --> 00:12:49,890
growl also supports ahead of time

00:12:45,990 --> 00:12:53,339
compilation it comes with a tool called

00:12:49,890 --> 00:12:59,040
native image that actually compile your

00:12:53,339 --> 00:13:02,540
code into negative executable so the the

00:12:59,040 --> 00:13:07,110
native executable will not run on JVM or

00:13:02,540 --> 00:13:11,390
growl VM it runs on a different virtual

00:13:07,110 --> 00:13:15,930
machine which is called substrate VM so

00:13:11,390 --> 00:13:18,030
when the native image tool is used it

00:13:15,930 --> 00:13:22,710
actually sort of bakes in

00:13:18,030 --> 00:13:24,600
that substrate VM into your executable

00:13:22,710 --> 00:13:27,180
as well so that you can have all the

00:13:24,600 --> 00:13:35,010
memory management thread management at

00:13:27,180 --> 00:13:37,710
at that level as well so here I sort of

00:13:35,010 --> 00:13:42,210
one thing to know about crawl that growl

00:13:37,710 --> 00:13:46,380
has to execution modes one is JVM and

00:13:42,210 --> 00:13:48,900
the other one is native if you run if

00:13:46,380 --> 00:13:53,490
you execute your application in JVM more

00:13:48,900 --> 00:13:55,830
then your program will run on JVM and if

00:13:53,490 --> 00:14:00,510
it is if you choose the native mode then

00:13:55,830 --> 00:14:03,690
it will run on the native images the

00:14:00,510 --> 00:14:07,980
which was which are created

00:14:03,690 --> 00:14:10,980
so usually native or ahead of time

00:14:07,980 --> 00:14:14,250
compiled of applications they run they

00:14:10,980 --> 00:14:17,940
have a better startup time and a lower

00:14:14,250 --> 00:14:21,300
memory footprint but the applications

00:14:17,940 --> 00:14:23,250
running on JVM they have a better peak

00:14:21,300 --> 00:14:27,720
performance and usually recommended for

00:14:23,250 --> 00:14:33,380
long running processes so this support

00:14:27,720 --> 00:14:44,130
was also added in JDK 9 in gp2 to 95 and

00:14:33,380 --> 00:14:47,070
so now it's it's available right so ok

00:14:44,130 --> 00:14:50,100
so so far we have sort of looked at all

00:14:47,070 --> 00:14:52,800
the major components of drol what are

00:14:50,100 --> 00:14:57,000
the components and what are the

00:14:52,800 --> 00:14:59,790
languages its support and how it is

00:14:57,000 --> 00:15:04,320
actually set up but the question is

00:14:59,790 --> 00:15:07,230
should you be using DRA like what are

00:15:04,320 --> 00:15:09,840
the benefits you will get moving into a

00:15:07,230 --> 00:15:12,810
growl camp because if you have any

00:15:09,840 --> 00:15:15,810
application running on JVM you want to

00:15:12,810 --> 00:15:17,820
move it to crawl vm of course this would

00:15:15,810 --> 00:15:22,020
be the first question you will ask

00:15:17,820 --> 00:15:24,450
yourself and second is should I be using

00:15:22,020 --> 00:15:27,420
truffle based implementations of the

00:15:24,450 --> 00:15:29,490
same languages that I'm already using

00:15:27,420 --> 00:15:35,520
like rubies and the

00:15:29,490 --> 00:15:38,630
nor GS and the pythons and arts so to

00:15:35,520 --> 00:15:42,390
find this answer I I ran some benchmarks

00:15:38,630 --> 00:15:45,180
both which I'll sort of stated in the

00:15:42,390 --> 00:15:47,370
ground website and others based on my

00:15:45,180 --> 00:15:50,880
experience I don't trust the benchmarks

00:15:47,370 --> 00:15:54,839
usually sort of showcase on the on the

00:15:50,880 --> 00:15:56,670
side of a particular framework so I did

00:15:54,839 --> 00:15:58,440
some digging as well so I found some

00:15:56,670 --> 00:15:58,950
interesting results that I will share

00:15:58,440 --> 00:16:03,000
with you

00:15:58,950 --> 00:16:09,750
so the first benchmark that iran is the

00:16:03,000 --> 00:16:12,390
embedded templating in ruby so the blue

00:16:09,750 --> 00:16:14,190
bar is JRuby and the yellow bar is

00:16:12,390 --> 00:16:16,230
truffle Ruby they cook the truffle

00:16:14,190 --> 00:16:18,690
implementation of Ruby they call a

00:16:16,230 --> 00:16:20,670
truffle Ruby and the truffle

00:16:18,690 --> 00:16:24,779
implementation of our they call it fast

00:16:20,670 --> 00:16:28,529
R so there is a you can see that truffle

00:16:24,779 --> 00:16:32,070
Ruby is like beating jaar jaar JRuby

00:16:28,529 --> 00:16:34,170
hands down like boom so which is really

00:16:32,070 --> 00:16:37,110
good and this is this is the benchmark

00:16:34,170 --> 00:16:42,450
defined in the growl vm side so it

00:16:37,110 --> 00:16:44,610
better perform well right so then I so

00:16:42,450 --> 00:16:48,180
the metric is IPS instructions per

00:16:44,610 --> 00:16:51,209
second yeah but even if I if you do just

00:16:48,180 --> 00:16:52,250
a time-based thing it was you can see

00:16:51,209 --> 00:16:55,800
the difference

00:16:52,250 --> 00:17:00,270
so I ran another benchmark which is

00:16:55,800 --> 00:17:02,730
basics t4 I took like a ginormous string

00:17:00,270 --> 00:17:07,920
and then just do the encode and decode

00:17:02,730 --> 00:17:11,670
of it and then I found that JRuby was

00:17:07,920 --> 00:17:16,500
actually really good and truffle Ruby

00:17:11,670 --> 00:17:19,260
didn't work a world was not even near so

00:17:16,500 --> 00:17:25,470
truffle was like not trading well with

00:17:19,260 --> 00:17:27,980
JRuby in this benchmark so yeah I will

00:17:25,470 --> 00:17:30,900
share some details later so I have

00:17:27,980 --> 00:17:33,840
created an issue and we are following up

00:17:30,900 --> 00:17:35,200
on the truffle Ruby github repo there

00:17:33,840 --> 00:17:37,299
are some

00:17:35,200 --> 00:17:38,740
things that they need to sort of

00:17:37,299 --> 00:17:39,340
implement it's sort of a work in

00:17:38,740 --> 00:17:43,590
progress

00:17:39,340 --> 00:17:48,520
to sort of bump up those numbers and

00:17:43,590 --> 00:17:52,480
then I ran another benchmark within

00:17:48,520 --> 00:17:56,020
which is like take a huge file and just

00:17:52,480 --> 00:17:57,820
do a JSON parsing of it and then just

00:17:56,020 --> 00:18:01,630
aggregate the numbers I will share I

00:17:57,820 --> 00:18:04,660
will show the code later on so Ruby

00:18:01,630 --> 00:18:07,419
what's really really fast and this is

00:18:04,660 --> 00:18:11,110
the the matrix I'm using is the just the

00:18:07,419 --> 00:18:14,860
plain execution time it completed the

00:18:11,110 --> 00:18:20,559
whole thing in like half a second on the

00:18:14,860 --> 00:18:25,059
other hand truffle took a lot of time 7

00:18:20,559 --> 00:18:27,490
minutes 7 seconds which is a lot so I

00:18:25,059 --> 00:18:30,820
took a step further

00:18:27,490 --> 00:18:33,880
and just sort of try to see that if can

00:18:30,820 --> 00:18:36,700
I make this thing a polyglot can I use

00:18:33,880 --> 00:18:39,040
instead of using a parse functionality

00:18:36,700 --> 00:18:42,700
that truffle or JRuby is providing can I

00:18:39,040 --> 00:18:47,380
use node.js parse parse function and see

00:18:42,700 --> 00:18:50,500
how it works so when I did that the

00:18:47,380 --> 00:18:54,340
result I get is 4 seconds which is

00:18:50,500 --> 00:18:59,230
better than 7 but nowhere near the

00:18:54,340 --> 00:19:02,679
actual JRuby implementation so this one

00:18:59,230 --> 00:19:04,809
the last the gray bar that you see the

00:19:02,679 --> 00:19:08,370
truffle node polyglot I was running in

00:19:04,809 --> 00:19:14,020
JVM so applications running on JVM has a

00:19:08,370 --> 00:19:16,720
it is sort of start slow so ice I want

00:19:14,020 --> 00:19:19,650
to check like what would be the result

00:19:16,720 --> 00:19:25,690
if I run the same thing in native mode

00:19:19,650 --> 00:19:29,110
so I ran the same thing in native mode

00:19:25,690 --> 00:19:37,059
and this is the result I got

00:19:29,110 --> 00:19:42,700
ok drum rolls ok boom so it is sort of

00:19:37,059 --> 00:19:44,230
half of what the JRuby is doing so this

00:19:42,700 --> 00:19:47,919
is again I was just playing around

00:19:44,230 --> 00:19:48,730
looking at the profiling and looking at

00:19:47,919 --> 00:19:56,320
all the

00:19:48,730 --> 00:19:59,260
Marie tracing yes yes yes

00:19:56,320 --> 00:20:01,480
so the benchmarks that either the

00:19:59,260 --> 00:20:05,130
benchmark gem that you use in Ruby or

00:20:01,480 --> 00:20:08,710
the gem IPS benchmark which is based on

00:20:05,130 --> 00:20:10,780
the benchmark gem they actually do some

00:20:08,710 --> 00:20:12,010
warm-ups as well so you can define some

00:20:10,780 --> 00:20:14,500
cycles of warmups

00:20:12,010 --> 00:20:20,730
and the eye trations so it gives you

00:20:14,500 --> 00:20:24,760
kind of a closer picture yes yes so I

00:20:20,730 --> 00:20:27,549
mean this was encouraging so and I will

00:20:24,760 --> 00:20:29,320
show this code later on and this all of

00:20:27,549 --> 00:20:32,020
this code all of the benchmarks that

00:20:29,320 --> 00:20:35,549
I've seen so far it's available on

00:20:32,020 --> 00:20:39,040
github and I have created a kind of

00:20:35,549 --> 00:20:41,530
container based on the growl image so

00:20:39,040 --> 00:20:44,770
all you need to do is to just clone it

00:20:41,530 --> 00:20:50,919
and then run it so you don't need to

00:20:44,770 --> 00:20:53,080
setup growl VM okay so let's look the

00:20:50,919 --> 00:20:57,970
look at this thing in bit more detail

00:20:53,080 --> 00:21:01,980
and that is my first demo for today the

00:20:57,970 --> 00:21:07,440
interoperability between Ruby and nodejs

00:21:01,980 --> 00:21:10,630
all right so I need to see how I can

00:21:07,440 --> 00:21:15,360
have this thing here okay bear with me

00:21:10,630 --> 00:21:15,360
sorry I need to probably end my

00:21:18,340 --> 00:21:30,770
okay how can I show this thing there

00:21:22,880 --> 00:21:34,820
really oh damn

00:21:30,770 --> 00:21:37,120
okay okay let me see if I can do that

00:21:34,820 --> 00:21:37,120
okay

00:21:45,799 --> 00:22:02,360
okay it's okay this will make things bit

00:21:53,880 --> 00:22:02,360
tricky for me okay it's not working

00:22:08,700 --> 00:22:11,700
okay

00:22:14,309 --> 00:22:22,860
all right so let's let's look at this

00:22:17,140 --> 00:22:28,240
one so this is the before the polyglot

00:22:22,860 --> 00:22:30,460
code I use the benchmark required JSON

00:22:28,240 --> 00:22:33,460
or very simple you I'm reading a really

00:22:30,460 --> 00:22:36,640
large file and then just doing a parsing

00:22:33,460 --> 00:22:41,799
and then doing an aggregation of all the

00:22:36,640 --> 00:22:49,270
coordinates a very simple benchmark now

00:22:41,799 --> 00:22:52,809
I want to show you guys alright so this

00:22:49,270 --> 00:22:55,720
one is the polyglot version of the same

00:22:52,809 --> 00:22:59,799
thing so there are two first the first

00:22:55,720 --> 00:23:01,360
thing that you notice is this weird

00:22:59,799 --> 00:23:06,669
object called polyglot

00:23:01,360 --> 00:23:10,289
so this polyglot is actually the

00:23:06,669 --> 00:23:13,659
interrupt framework that the truffle use

00:23:10,289 --> 00:23:20,289
and all the languages they implement

00:23:13,659 --> 00:23:22,480
this this polyglot so polyglot a well

00:23:20,289 --> 00:23:23,799
what it is doing right now it is taking

00:23:22,480 --> 00:23:26,169
the first parameter which is the

00:23:23,799 --> 00:23:28,299
language and the other one is what you

00:23:26,169 --> 00:23:31,510
want to do in that language that foreign

00:23:28,299 --> 00:23:34,090
language I mean you can have you can

00:23:31,510 --> 00:23:36,789
write a long code in it as well but

00:23:34,090 --> 00:23:40,390
right now all I want is just a the

00:23:36,789 --> 00:23:43,750
JavaScript parser that's all so I'm just

00:23:40,390 --> 00:23:45,940
feeding him that parser the JSON I'm

00:23:43,750 --> 00:23:48,190
reading from the file and then the

00:23:45,940 --> 00:23:51,850
result I'm getting is the J object which

00:23:48,190 --> 00:23:54,820
is a foreign object in Ruby space so to

00:23:51,850 --> 00:23:56,860
make it enumerable I am using as

00:23:54,820 --> 00:24:00,279
enumerable so that I can sort of loop

00:23:56,860 --> 00:24:02,679
through it so this is the only two lines

00:24:00,279 --> 00:24:08,620
I change and then I just ran the same

00:24:02,679 --> 00:24:13,480
thing and the results you have seen I

00:24:08,620 --> 00:24:16,840
think let's let's execute this thing I I

00:24:13,480 --> 00:24:20,140
hope I can show you guys it's hard to

00:24:16,840 --> 00:24:23,640
sort of do something here just looking

00:24:20,140 --> 00:24:26,179
at there anyways

00:24:23,640 --> 00:24:26,179
okay

00:24:32,970 --> 00:24:35,570
okay

00:24:45,840 --> 00:24:48,840
okay

00:24:49,920 --> 00:24:53,630
it's not working

00:25:04,230 --> 00:25:13,080
sorry guys okay I can just mirror I

00:25:08,549 --> 00:25:21,659
think that that will help cool okay

00:25:13,080 --> 00:25:22,820
sorry about that okay Toulouse where are

00:25:21,659 --> 00:25:33,899
you

00:25:22,820 --> 00:25:36,210
okay so I'm in my truffle codebase so if

00:25:33,899 --> 00:25:39,419
I want to run this thing let's run this

00:25:36,210 --> 00:25:44,279
thing in the JVM world first I'll say

00:25:39,419 --> 00:25:48,840
JVM and I will say it's a polyglot just

00:25:44,279 --> 00:25:51,990
to tell the runtime that I am intending

00:25:48,840 --> 00:25:55,139
to use foreign languages in my Ruby code

00:25:51,990 --> 00:25:59,870
and I also need to tell the compiler

00:25:55,139 --> 00:26:06,630
that hey so this is important which is

00:25:59,870 --> 00:26:07,980
only needed for node.js if you're using

00:26:06,630 --> 00:26:09,690
node.js as a foreign language because

00:26:07,980 --> 00:26:11,490
node.js or JavaScript is a

00:26:09,690 --> 00:26:14,340
single-threaded it's based on single

00:26:11,490 --> 00:26:17,010
threaded model so you need to tell the

00:26:14,340 --> 00:26:20,880
runtime that hey the foreign language is

00:26:17,010 --> 00:26:24,570
single threaded so that it can raise an

00:26:20,880 --> 00:26:26,490
errors if you are trying to access those

00:26:24,570 --> 00:26:29,880
federal foreign language objects in a

00:26:26,490 --> 00:26:32,789
concurrent manner so this is kind of a

00:26:29,880 --> 00:26:35,600
safety net that drol created around it

00:26:32,789 --> 00:26:39,260
so right now I am running it in JVM

00:26:35,600 --> 00:26:39,260
let's see the results

00:26:39,470 --> 00:26:48,929
alright so pretty much the same 6.5

00:26:42,809 --> 00:26:53,000
seconds as shown in the benchmark and so

00:26:48,929 --> 00:26:53,000
let's try the same thing with native

00:27:01,690 --> 00:27:08,870
all right so the only difference between

00:27:05,900 --> 00:27:12,049
these two executions is the fact that

00:27:08,870 --> 00:27:16,100
the second one is actually running the

00:27:12,049 --> 00:27:20,390
native image of Ruby runtime in in the

00:27:16,100 --> 00:27:23,570
first one that what actually the VM do

00:27:20,390 --> 00:27:26,809
is like when you say Ruby VM then it

00:27:23,570 --> 00:27:30,049
actually sort of load the Ruby runtime

00:27:26,809 --> 00:27:31,429
in jail in JVM as well so that slows

00:27:30,049 --> 00:27:33,919
things down a bit

00:27:31,429 --> 00:27:36,950
so if you are sort of fighting for the

00:27:33,919 --> 00:27:42,020
benchmark just sort of so that you can

00:27:36,950 --> 00:27:47,600
sort of have a bragging rights so do use

00:27:42,020 --> 00:27:51,650
native for it all right so I have

00:27:47,600 --> 00:27:54,049
another example for you guys this one is

00:27:51,650 --> 00:27:56,659
much more not from the space of

00:27:54,049 --> 00:28:00,049
benchmark but more kind of mimic

00:27:56,659 --> 00:28:02,270
mimicking the real-world use cases so I

00:28:00,049 --> 00:28:08,840
have so it's more about the Interop

00:28:02,270 --> 00:28:11,179
between node.js and java so I have

00:28:08,840 --> 00:28:14,620
created a very simplified notification

00:28:11,179 --> 00:28:17,450
server in which the notification

00:28:14,620 --> 00:28:20,330
notification service sorry and then in

00:28:17,450 --> 00:28:22,669
the notification service I have the

00:28:20,330 --> 00:28:26,419
notification server written in Java

00:28:22,669 --> 00:28:31,010
which is not doing a very kind of a

00:28:26,419 --> 00:28:34,429
super awesome thing is just sort of just

00:28:31,010 --> 00:28:36,340
putting random numbers in a queue I mean

00:28:34,429 --> 00:28:39,020
you can replace this thing with actual

00:28:36,340 --> 00:28:44,720
notifications or anything whatever the

00:28:39,020 --> 00:28:47,090
use case is so this is the this is the

00:28:44,720 --> 00:28:49,940
Java code it starts and do some

00:28:47,090 --> 00:28:53,750
computations and then just put something

00:28:49,940 --> 00:28:58,640
in the queue and on the other hand I

00:28:53,750 --> 00:29:02,179
have a receiver which is a node.js

00:28:58,640 --> 00:29:06,650
receiver it is using the worker threads

00:29:02,179 --> 00:29:09,580
and so the idea what I'm trying to do is

00:29:06,650 --> 00:29:09,580
to create

00:29:10,320 --> 00:29:14,370
a solution in which you have a

00:29:12,750 --> 00:29:16,050
notification so we're putting something

00:29:14,370 --> 00:29:19,710
in the queue and then you have n number

00:29:16,050 --> 00:29:27,120
of worker threads sort of pulling the

00:29:19,710 --> 00:29:30,000
data from the same queue so for that so

00:29:27,120 --> 00:29:34,410
I the first thing that I'm doing after

00:29:30,000 --> 00:29:36,300
like defining the worker thread is using

00:29:34,410 --> 00:29:38,640
the link block cube because I want to

00:29:36,300 --> 00:29:42,120
make sure that the access to the to the

00:29:38,640 --> 00:29:45,900
queue is concurrent so I'm just using

00:29:42,120 --> 00:29:47,820
the Java queues one of the in from the

00:29:45,900 --> 00:29:50,400
from the collection you can use any of

00:29:47,820 --> 00:29:54,930
the queues you want and then defining

00:29:50,400 --> 00:29:58,080
the threads and then I am actually

00:29:54,930 --> 00:30:02,100
initializing and calling a method of a

00:29:58,080 --> 00:30:04,680
Java function so this is new you haven't

00:30:02,100 --> 00:30:06,630
seen this thing happening in in node.js

00:30:04,680 --> 00:30:09,930
world before right trust me

00:30:06,630 --> 00:30:12,720
so the reason you can do this thing is

00:30:09,930 --> 00:30:16,610
because both of these code is actually

00:30:12,720 --> 00:30:20,160
using a running in the same runtime and

00:30:16,610 --> 00:30:22,380
so if you want to talk from one truffle

00:30:20,160 --> 00:30:24,810
implementation to another you will use

00:30:22,380 --> 00:30:27,810
the polyglot framework but if the

00:30:24,810 --> 00:30:32,370
truffle languages want to talk to any

00:30:27,810 --> 00:30:35,790
JVM based languages like Scala or Java

00:30:32,370 --> 00:30:37,980
they will use the Java type so I will

00:30:35,790 --> 00:30:40,860
get that notification server and I will

00:30:37,980 --> 00:30:49,200
just call the start method by giving it

00:30:40,860 --> 00:30:52,700
a cue that I created at the top so let's

00:30:49,200 --> 00:30:52,700
see how it works

00:30:52,850 --> 00:31:02,400
let me check yeah that's the same one so

00:30:56,220 --> 00:31:05,000
what I will do is I will compile my Java

00:31:02,400 --> 00:31:05,000
class first

00:31:06,080 --> 00:31:19,270
all right and then I will run node yeah

00:31:13,880 --> 00:31:20,710
since I'm using worker thread until

00:31:19,270 --> 00:31:26,710
[Music]

00:31:20,710 --> 00:31:31,430
worker I need to check that notification

00:31:26,710 --> 00:31:33,020
the see were brought yes I don't know

00:31:31,430 --> 00:31:35,510
whether it works or not

00:31:33,020 --> 00:31:40,810
oh yeah it works so yeah it's just sort

00:31:35,510 --> 00:31:46,340
of console out so it is showing that the

00:31:40,810 --> 00:31:48,560
the items Java server is pushing into

00:31:46,340 --> 00:31:56,060
the queue at a regular period of time

00:31:48,560 --> 00:32:04,390
all my workers is like picking it up so

00:31:56,060 --> 00:32:08,270
another thing is right all right so

00:32:04,390 --> 00:32:12,710
these are the two main demos I have for

00:32:08,270 --> 00:32:14,240
you guys today but remember when I at

00:32:12,710 --> 00:32:16,580
the start when I mentioned that I

00:32:14,240 --> 00:32:18,500
started this crawl journey I'm not an

00:32:16,580 --> 00:32:20,420
expert in crawl by the way and not like

00:32:18,500 --> 00:32:26,000
Oracle is not paying me to sort of do

00:32:20,420 --> 00:32:28,460
this talk so the whole reason I started

00:32:26,000 --> 00:32:34,000
looking into brawl is because I wanted

00:32:28,460 --> 00:32:36,350
to use the Java SDK in my Ruby code so

00:32:34,000 --> 00:32:38,990
let me just show you the code because I

00:32:36,350 --> 00:32:45,760
cannot execute that code here because it

00:32:38,990 --> 00:32:50,330
uses all the server's in in in order des

00:32:45,760 --> 00:32:57,560
but I can just show you the code so it

00:32:50,330 --> 00:33:00,830
is a SDK based on Genesis so I just took

00:32:57,560 --> 00:33:03,290
the SDK by just running the maven and

00:33:00,830 --> 00:33:08,060
then just create a SDK with all the

00:33:03,290 --> 00:33:14,190
dependencies and then just okay let me

00:33:08,060 --> 00:33:16,379
just make it more smaller of it so

00:33:14,190 --> 00:33:19,919
and this is the Ruby code that actually

00:33:16,379 --> 00:33:22,490
uses the whole SDK and it works and I

00:33:19,919 --> 00:33:24,750
can do the same thing with with nodejs

00:33:22,490 --> 00:33:26,009
because people will argue like the

00:33:24,750 --> 00:33:26,909
people who have already worked with

00:33:26,009 --> 00:33:29,190
JRuby

00:33:26,909 --> 00:33:31,769
like hey you can or you can or you can

00:33:29,190 --> 00:33:35,100
already talk to Java I mean that's not a

00:33:31,769 --> 00:33:37,110
new thing you can have like Java start

00:33:35,100 --> 00:33:40,379
script or your you have been--

00:33:37,110 --> 00:33:44,850
frameworks that can allow you your job

00:33:40,379 --> 00:33:48,360
JRuby code to talk to Java but just if

00:33:44,850 --> 00:33:50,460
think about the situation where you have

00:33:48,360 --> 00:33:53,730
to use more than one language you are

00:33:50,460 --> 00:33:58,139
maybe you are coding in in your create

00:33:53,730 --> 00:34:02,460
an express node.js server and then you

00:33:58,139 --> 00:34:06,750
need to use our or pipe in or maybe some

00:34:02,460 --> 00:34:09,480
of the Ruby and others stuff in it so

00:34:06,750 --> 00:34:15,929
then having a consistent framework

00:34:09,480 --> 00:34:22,109
around it makes it very simple alright

00:34:15,929 --> 00:34:28,889
so is there any time check how much time

00:34:22,109 --> 00:34:31,109
I have okay let's go back to the let's

00:34:28,889 --> 00:34:33,659
go back to our slides so based on my

00:34:31,109 --> 00:34:37,470
journey in the like last two months or

00:34:33,659 --> 00:34:43,579
so there are some lesson learned based

00:34:37,470 --> 00:34:48,240
on my sort of adventures with crawl VM

00:34:43,579 --> 00:34:50,639
first is this kind of solution like a VM

00:34:48,240 --> 00:34:53,460
based solution is better suited for a

00:34:50,639 --> 00:34:56,609
situation where you have you want to use

00:34:53,460 --> 00:34:59,040
some library or some SDK written in some

00:34:56,609 --> 00:35:02,280
other language I mean there is a scope

00:34:59,040 --> 00:35:04,290
of this there is a scope of this

00:35:02,280 --> 00:35:06,510
interoperability this should not be

00:35:04,290 --> 00:35:08,819
taken as one solution that can fix all

00:35:06,510 --> 00:35:12,030
of your interoperability problems maybe

00:35:08,819 --> 00:35:14,220
in the in the if you are if you are

00:35:12,030 --> 00:35:16,770
designing your overall solution more in

00:35:14,220 --> 00:35:20,069
the micro services based architecture

00:35:16,770 --> 00:35:23,780
then the advantages of doing something

00:35:20,069 --> 00:35:27,660
like this will be very very minimal so

00:35:23,780 --> 00:35:32,369
you can choose when to use it and when

00:35:27,660 --> 00:35:34,309
or to user it it helps if you have liked

00:35:32,369 --> 00:35:38,549
working in a big organization where

00:35:34,309 --> 00:35:39,869
sometimes it happens that you create

00:35:38,549 --> 00:35:42,809
something and then you create two

00:35:39,869 --> 00:35:45,059
variations of it so these type of

00:35:42,809 --> 00:35:46,740
activities will help you create a single

00:35:45,059 --> 00:35:48,390
source of truth so that everyone is

00:35:46,740 --> 00:35:50,609
actually sort of improving it and then

00:35:48,390 --> 00:35:53,309
you are key you are not creating like a

00:35:50,609 --> 00:35:55,859
Java SDK and then Ruby SDK and then

00:35:53,309 --> 00:35:58,559
seedless Rose SDK and all that so this

00:35:55,859 --> 00:36:01,700
is an advantage so you can choose when

00:35:58,559 --> 00:36:04,740
to use LVM and when not to use chromium

00:36:01,700 --> 00:36:07,200
the second thing is there are still some

00:36:04,740 --> 00:36:13,559
performance gaps in truffle

00:36:07,200 --> 00:36:15,630
implementations but it's it's an active

00:36:13,559 --> 00:36:17,849
community I can see like a lot of

00:36:15,630 --> 00:36:19,619
improvement improvements happening but

00:36:17,849 --> 00:36:23,819
the problem with the truffle

00:36:19,619 --> 00:36:27,690
implementation will always be that it

00:36:23,819 --> 00:36:30,000
will always play kind of a second fiddle

00:36:27,690 --> 00:36:34,589
to all the advancements happening on the

00:36:30,000 --> 00:36:36,869
respective languages so let's say if

00:36:34,589 --> 00:36:38,579
node.js come up with a new thing they

00:36:36,869 --> 00:36:40,650
need to sort of come up and then do the

00:36:38,579 --> 00:36:43,140
implementation again if Java come up

00:36:40,650 --> 00:36:44,490
with Java 12 or 13 with some totally

00:36:43,140 --> 00:36:48,420
different thing they need to come back

00:36:44,490 --> 00:36:50,279
and do something about it so so this is

00:36:48,420 --> 00:36:53,069
something that we need to sort of take

00:36:50,279 --> 00:36:56,849
into consideration while working maybe

00:36:53,069 --> 00:36:59,279
run some benchmarks do some profiling do

00:36:56,849 --> 00:37:02,510
it do some comparisons regularly tested

00:36:59,279 --> 00:37:04,950
before sort of deciding what what to do

00:37:02,510 --> 00:37:07,559
the third thing which is not related to

00:37:04,950 --> 00:37:12,470
crawl at all but is like just my pain of

00:37:07,559 --> 00:37:15,750
like using JDK in docker container

00:37:12,470 --> 00:37:19,770
doesn't fit well it's not kind of a

00:37:15,750 --> 00:37:22,440
hidden factor anymore so Java 8 if

00:37:19,770 --> 00:37:24,839
you're running and then so it doesn't

00:37:22,440 --> 00:37:26,670
follow the the memory and the CPU

00:37:24,839 --> 00:37:29,400
restrictions that you put on your docker

00:37:26,670 --> 00:37:32,700
container so sometimes you say ok killed

00:37:29,400 --> 00:37:36,270
it we'll just say it's killed it so it

00:37:32,700 --> 00:37:38,339
will not say heap out of memory so if

00:37:36,270 --> 00:37:41,369
you are experimenting and if you can

00:37:38,339 --> 00:37:43,710
better to use JDK 10 plus the

00:37:41,369 --> 00:37:47,640
it has a better support for docker

00:37:43,710 --> 00:37:50,749
containers the last thing is that growl

00:37:47,640 --> 00:37:55,979
is not widely used in production

00:37:50,749 --> 00:37:58,650
environment as of now so far I I know

00:37:55,979 --> 00:38:01,410
from all the all the material and all

00:37:58,650 --> 00:38:03,900
that that twitter is using it but I

00:38:01,410 --> 00:38:06,029
haven't seen any other kind of a success

00:38:03,900 --> 00:38:08,369
story coming out of it saying that ok

00:38:06,029 --> 00:38:15,599
they are using raw land it's like making

00:38:08,369 --> 00:38:19,680
a difference alright so these are all

00:38:15,599 --> 00:38:22,349
the references that I mainly use this is

00:38:19,680 --> 00:38:24,029
the github repo of mine the growl

00:38:22,349 --> 00:38:25,769
benchmarks that will contain all the

00:38:24,029 --> 00:38:27,719
code and all the containerized code so

00:38:25,769 --> 00:38:29,219
you can just run it I mean you can run

00:38:27,719 --> 00:38:31,519
it right now and show me what are the

00:38:29,219 --> 00:38:31,519
numbers

00:38:31,829 --> 00:38:38,249
draal vm github they have very good

00:38:36,119 --> 00:38:40,650
documentation if you want to know about

00:38:38,249 --> 00:38:42,869
in the JDK world what are the changes

00:38:40,650 --> 00:38:45,900
they did that actually enable a solution

00:38:42,869 --> 00:38:51,420
like crawl vm to come is you can look at

00:38:45,900 --> 00:38:55,019
these 243 which actually implemented the

00:38:51,420 --> 00:38:58,319
JVM CI and then there are some research

00:38:55,019 --> 00:39:06,660
papers on truffle Ruby and overall on on

00:38:58,319 --> 00:39:11,249
LLVM based languages alright

00:39:06,660 --> 00:39:14,599
that's all I have so if anyone has any

00:39:11,249 --> 00:39:14,599
questions feel free

00:39:16,810 --> 00:39:19,380
yep

00:39:23,850 --> 00:39:28,500
so I mean just I let me ask you you guys

00:39:26,910 --> 00:39:31,560
a question I mean what do you think

00:39:28,500 --> 00:39:34,500
about crawl VM because I am NOT an

00:39:31,560 --> 00:39:37,140
expert in it as well but I'm sort of

00:39:34,500 --> 00:39:39,030
just trying it out I'm finding it cool

00:39:37,140 --> 00:39:41,190
right now but I mean what do you guys

00:39:39,030 --> 00:39:43,260
think on all the things I have shown

00:39:41,190 --> 00:39:45,800
here so far

00:39:43,260 --> 00:39:48,900
is this something that you think like ah

00:39:45,800 --> 00:39:52,560
it's interesting or you say nah I'm good

00:39:48,900 --> 00:39:54,420
with whatever I am doing just whoo okay

00:39:52,560 --> 00:39:56,880
this just raise your hands I like how

00:39:54,420 --> 00:40:01,200
many of you think like okay this is like

00:39:56,880 --> 00:40:05,070
this is interesting okay all right

00:40:01,200 --> 00:40:15,210
that's not bad but how many of you think

00:40:05,070 --> 00:40:16,890
like okay this is Anna I'm okay I mean

00:40:15,210 --> 00:40:19,070
because I want to learn from you guys

00:40:16,890 --> 00:40:21,690
and I did let's have like this two-way

00:40:19,070 --> 00:40:23,790
communication so what do you what what

00:40:21,690 --> 00:40:36,150
do you think like what is your

00:40:23,790 --> 00:40:38,550
reservation or why you think like I mean

00:40:36,150 --> 00:40:40,890
it's JVM it goes wrong all the time

00:40:38,550 --> 00:40:45,750
even though even the hots for je viens

00:40:40,890 --> 00:40:47,640
do that right so but it is it is a JVM I

00:40:45,750 --> 00:40:52,500
mean you can just take that growl VM and

00:40:47,640 --> 00:40:57,390
you can use your any JVM that you have

00:40:52,500 --> 00:41:00,810
like maybe jail based on your Java ten

00:40:57,390 --> 00:41:02,700
or eleven maybe a Zul or adopt anything

00:41:00,810 --> 00:41:05,730
and you can just sort of configure your

00:41:02,700 --> 00:41:10,590
JVM to just use it I can comment on that

00:41:05,730 --> 00:41:13,320
yeah so Twitter is using ground because

00:41:10,590 --> 00:41:16,740
there are a scholar shop they are using

00:41:13,320 --> 00:41:20,550
scholar very heavily and they benefit a

00:41:16,740 --> 00:41:26,180
lot from using brow like I have things

00:41:20,550 --> 00:41:26,180
like 20 to 30% speed improvements

00:41:26,450 --> 00:41:37,800
but they have a dedicated team that is

00:41:31,050 --> 00:41:40,290
actually yeah movin into the OpenJDK

00:41:37,800 --> 00:41:42,990
development and they they have some guys

00:41:40,290 --> 00:41:46,650
doing memory in garbage collecting and

00:41:42,990 --> 00:41:50,390
they have some guys like doing yam stuff

00:41:46,650 --> 00:41:54,450
and they have their own internal openjdk

00:41:50,390 --> 00:41:56,880
no JDK version which diverts from the

00:41:54,450 --> 00:42:01,010
open JDK so there are in another

00:41:56,880 --> 00:42:03,540
position then like just like a normal

00:42:01,010 --> 00:42:06,480
what is there's nothing like normal but

00:42:03,540 --> 00:42:11,010
like just an outsider just want to use

00:42:06,480 --> 00:42:16,290
Java or Ruby or whatever just want to

00:42:11,010 --> 00:42:18,330
run their programs so whenever something

00:42:16,290 --> 00:42:23,040
goes wrong you are pretty much on your

00:42:18,330 --> 00:42:25,110
own all you need to know how like who is

00:42:23,040 --> 00:42:27,480
actually the developer in charge and how

00:42:25,110 --> 00:42:30,660
to address the develop yeah so you you

00:42:27,480 --> 00:42:34,860
you so and that's the basic thing about

00:42:30,660 --> 00:42:38,130
any work with open source software

00:42:34,860 --> 00:42:40,770
either you need to get engaged within

00:42:38,130 --> 00:42:42,570
the community and know how to address

00:42:40,770 --> 00:42:49,260
people work with mailing lists whatever

00:42:42,570 --> 00:42:51,720
and file back reports or don't and buy

00:42:49,260 --> 00:42:56,760
some commercial support yeah but there

00:42:51,720 --> 00:42:58,440
is no yeah okay tell you that so growl

00:42:56,760 --> 00:43:00,090
VM they have a Enterprise Edition as

00:42:58,440 --> 00:43:02,640
well that they say that they will

00:43:00,090 --> 00:43:05,490
support like I I just use community

00:43:02,640 --> 00:43:07,680
version but one thing that I I can

00:43:05,490 --> 00:43:10,520
recommend everyone even let's say if you

00:43:07,680 --> 00:43:14,640
are not a very like a technical

00:43:10,520 --> 00:43:17,520
compilers heavy techy if you just want

00:43:14,640 --> 00:43:21,390
to see the compiler impact on especially

00:43:17,520 --> 00:43:26,730
on the on the GC on the garbage

00:43:21,390 --> 00:43:29,490
collection so since Java since JDK 10

00:43:26,730 --> 00:43:32,490
they introduced the option where you can

00:43:29,490 --> 00:43:34,980
run your JVM by disabling the garbage

00:43:32,490 --> 00:43:38,190
collection or just not doing it at all

00:43:34,980 --> 00:43:39,960
so I mean the easiest way if I

00:43:38,190 --> 00:43:42,110
if I want to do it with a limited

00:43:39,960 --> 00:43:46,680
knowledge what I will do is I will just

00:43:42,110 --> 00:43:49,920
give it a very high memory and then just

00:43:46,680 --> 00:43:52,080
run it without the garbage collector and

00:43:49,920 --> 00:43:53,460
see how it works and then use it with

00:43:52,080 --> 00:43:55,740
one compiler and then use it with

00:43:53,460 --> 00:43:57,840
another compiler so you can at least get

00:43:55,740 --> 00:44:02,670
like a some rough estimate a ballpark

00:43:57,840 --> 00:44:05,430
like how things are sort of working but

00:44:02,670 --> 00:44:07,440
again having a dedicated team I agree

00:44:05,430 --> 00:44:09,840
with you Twitter they have like people

00:44:07,440 --> 00:44:14,310
dedicated working on optimizing all

00:44:09,840 --> 00:44:17,760
their job JVM base compilers and making

00:44:14,310 --> 00:44:18,720
it sort of make sure that remain remain

00:44:17,760 --> 00:44:23,070
there

00:44:18,720 --> 00:44:24,930
I mean experimenting it with that is ok

00:44:23,070 --> 00:44:26,760
like if your plan like to go in

00:44:24,930 --> 00:44:29,430
production like within a year and like

00:44:26,760 --> 00:44:31,980
your have a little bit time to get in

00:44:29,430 --> 00:44:33,990
contact with the people then and then

00:44:31,980 --> 00:44:37,860
it's fine if you want to yeah run

00:44:33,990 --> 00:44:41,700
something in production today it's it's

00:44:37,860 --> 00:44:45,150
still a bit waiting yes I agree because

00:44:41,700 --> 00:44:47,520
I I haven't seen any other kind of a big

00:44:45,150 --> 00:44:51,800
success story coming out of crawl other

00:44:47,520 --> 00:44:55,200
than Twitter but let's see in future

00:44:51,800 --> 00:44:58,010
yeah any other questions I'm just making

00:44:55,200 --> 00:44:58,010
questions right now

00:44:59,360 --> 00:45:06,360
anyone who has experiences positive or

00:45:03,300 --> 00:45:08,310
negative with the JVM stack that they

00:45:06,360 --> 00:45:09,690
might be interested in sharing we have

00:45:08,310 --> 00:45:13,380
five minutes left

00:45:09,690 --> 00:45:16,170
yeah I mean you can ask me like I'll be

00:45:13,380 --> 00:45:18,630
here today tomorrow just another comment

00:45:16,170 --> 00:45:22,940
on the which is another topic actually

00:45:18,630 --> 00:45:27,480
about the the cloud thing yes you said

00:45:22,940 --> 00:45:30,530
there are a lot of improvements in in 10

00:45:27,480 --> 00:45:33,570
and 11 which makes it better suited for

00:45:30,530 --> 00:45:35,790
docker containers they did this which to

00:45:33,570 --> 00:45:38,100
the new garbage collector jg1 garbage

00:45:35,790 --> 00:45:41,250
collector is one example which gives

00:45:38,100 --> 00:45:46,380
back more aggressively the memory back

00:45:41,250 --> 00:45:48,350
to the operating system the problem is

00:45:46,380 --> 00:45:52,730
at the moment then

00:45:48,350 --> 00:45:55,730
Java 11 is actually the long-term

00:45:52,730 --> 00:45:58,940
service release yeah but it still has

00:45:55,730 --> 00:46:02,150
some serious bugs and there is some

00:45:58,940 --> 00:46:08,360
security updates maintenance release in

00:46:02,150 --> 00:46:12,170
the works so and people are hesitating

00:46:08,360 --> 00:46:15,230
now to actually switch to eleven and so

00:46:12,170 --> 00:46:16,910
at the moment if you have like critical

00:46:15,230 --> 00:46:19,640
production we are closed you should stay

00:46:16,910 --> 00:46:23,330
with eight wait for the next maintenance

00:46:19,640 --> 00:46:30,410
release of eleven so ya know there's a

00:46:23,330 --> 00:46:32,800
lot of flow in these are all open JDK

00:46:30,410 --> 00:46:38,110
development there is a switch that

00:46:32,800 --> 00:46:40,670
actually Oracle steps down with their

00:46:38,110 --> 00:46:43,040
leadership in in the open JDK

00:46:40,670 --> 00:46:44,900
development and red head does the

00:46:43,040 --> 00:46:50,330
maintenance releases so this is all like

00:46:44,900 --> 00:46:54,170
stuff then yeah this is in the flow at

00:46:50,330 --> 00:46:57,770
the moment yeah I I totally agree with

00:46:54,170 --> 00:46:59,660
you this is the case I because most of

00:46:57,770 --> 00:47:01,880
the applications which is based on Java

00:46:59,660 --> 00:47:03,980
right now they are mainly running on

00:47:01,880 --> 00:47:07,760
Java 8 I haven't seen any like

00:47:03,980 --> 00:47:10,070
production Java Java applications on any

00:47:07,760 --> 00:47:13,550
financial Institute's or like anywhere

00:47:10,070 --> 00:47:15,710
running on Java 10 or 11 but I think

00:47:13,550 --> 00:47:18,980
probably sooner or later people will

00:47:15,710 --> 00:47:21,200
make the move because recently Oracle

00:47:18,980 --> 00:47:23,300
sort of changed their arrangement with

00:47:21,200 --> 00:47:25,250
how they will do the back porting and

00:47:23,300 --> 00:47:28,100
you need to sort of engage with them in

00:47:25,250 --> 00:47:31,280
the licensing form so either you go to

00:47:28,100 --> 00:47:32,840
some other if you want the back port

00:47:31,280 --> 00:47:34,790
let's say if they added a new feature in

00:47:32,840 --> 00:47:38,360
Java 11 and you want it in Java 8

00:47:34,790 --> 00:47:43,010
because usually right now it happens if

00:47:38,360 --> 00:47:45,170
you use yes yeah so that's the

00:47:43,010 --> 00:47:50,990
interesting topic we can discuss about

00:47:45,170 --> 00:47:52,070
it and so are we good any other thank

00:47:50,990 --> 00:47:56,320
you so much thank you

00:47:52,070 --> 00:47:56,320

YouTube URL: https://www.youtube.com/watch?v=mJcMM3wZA20


