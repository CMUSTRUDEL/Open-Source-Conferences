Title: Building a Compiler for Quantum Computers - Matthew Treinish
Publication date: 2021-03-15
Playlist: FOSSASIA Summit 2021
Description: 
	Slides: https://eventyay.com/e/fa96ae2c/session/6744

Just as with classical computers we need tools to convert the programs we write into something that can actually be run on computers. For classical computers this normally involves converting a higher level language into machine code, but with quantum computing the programs are written at a much lower level, the equivalent of assembly code. However, because of limitations with the current quantum computers available today even programs written at this low a level have to be adapted and optimized for each specific backend to be able to run successfully. Making this compilation processes effective and efficient directly impacts how a program will perform, and whether you're able to get a meaningful result or not. This talk will explain what is involved in compiling software to run on a quantum computer and why it is necessary. It will cover how it works, different optimization techniques that are available, and how it can effect the results from running your program. It will also cover how you can customize the compiler optimizations used to try and better optimize your program to get better results, and how a bad compiler output can result in getting a noisy result, or even lead to you getting no meaningful result at all.
Captions: 
	00:00:00,880 --> 00:00:04,720
hi i'm matthew trinich i'm a software

00:00:03,120 --> 00:00:06,080
engineer at ibm research

00:00:04,720 --> 00:00:08,240
that works on the quantum computing

00:00:06,080 --> 00:00:09,920
project there i'm here today to talk

00:00:08,240 --> 00:00:10,960
about building a compiler for quantum

00:00:09,920 --> 00:00:12,400
computers

00:00:10,960 --> 00:00:14,000
before we get into this though i wanted

00:00:12,400 --> 00:00:15,920
to preface this won't be

00:00:14,000 --> 00:00:17,039
a general talk about quantum computers

00:00:15,920 --> 00:00:18,800
or quantum information

00:00:17,039 --> 00:00:20,480
i actually gave a talk on that two years

00:00:18,800 --> 00:00:21,760
ago at foss asia

00:00:20,480 --> 00:00:24,080
you can look up the recording for that

00:00:21,760 --> 00:00:26,080
if you'd like to go into more details on

00:00:24,080 --> 00:00:27,279
how quantum computers can be used and

00:00:26,080 --> 00:00:28,960
how they work

00:00:27,279 --> 00:00:30,320
this talk will be concentrating

00:00:28,960 --> 00:00:32,559
primarily on just

00:00:30,320 --> 00:00:33,520
how we can build compilers and looking

00:00:32,559 --> 00:00:35,760
specifically

00:00:33,520 --> 00:00:38,239
at an open source package that is a

00:00:35,760 --> 00:00:40,320
compiler for quantum computers

00:00:38,239 --> 00:00:41,680
so before we can talk about compilers

00:00:40,320 --> 00:00:43,440
though we need to talk about how people

00:00:41,680 --> 00:00:44,719
program quantum computers

00:00:43,440 --> 00:00:46,800
and that brings us to the quantum

00:00:44,719 --> 00:00:48,399
circuit quantum circuit

00:00:46,800 --> 00:00:50,239
is a visual representation that's used

00:00:48,399 --> 00:00:52,079
to describe a series of operations that

00:00:50,239 --> 00:00:54,239
are run on a quantum computer

00:00:52,079 --> 00:00:55,680
each row in the circuit represents

00:00:54,239 --> 00:00:58,000
either a classical bit

00:00:55,680 --> 00:00:58,960
these two on the bottom or a quantum bit

00:00:58,000 --> 00:01:01,840
or qubit

00:00:58,960 --> 00:01:02,960
on the these two on the top and you read

00:01:01,840 --> 00:01:04,879
them from left to right

00:01:02,960 --> 00:01:07,600
and they show operations that operate

00:01:04,879 --> 00:01:08,960
either on one or two qubits

00:01:07,600 --> 00:01:11,360
they're used to show dependency of

00:01:08,960 --> 00:01:12,000
operation and there's no implicit timing

00:01:11,360 --> 00:01:14,640
information

00:01:12,000 --> 00:01:16,240
although they can be annotated to add

00:01:14,640 --> 00:01:18,240
timing information

00:01:16,240 --> 00:01:19,520
one thing that's worth pointing out here

00:01:18,240 --> 00:01:22,400
is a measurement gate

00:01:19,520 --> 00:01:23,920
when you measure a qubit you are going

00:01:22,400 --> 00:01:26,560
to collapse its state

00:01:23,920 --> 00:01:27,840
and either read out a binary zero or one

00:01:26,560 --> 00:01:28,880
which is what the classical bit

00:01:27,840 --> 00:01:31,520
represents

00:01:28,880 --> 00:01:32,479
so in this circuit example when we read

00:01:31,520 --> 00:01:36,320
qubit zero

00:01:32,479 --> 00:01:38,079
we measure it to classical bit zero

00:01:36,320 --> 00:01:39,520
and we'll either get a zero or one out

00:01:38,079 --> 00:01:43,920
and once we measure it whatever

00:01:39,520 --> 00:01:43,920
quantum state we had before we lose

00:01:44,240 --> 00:01:49,360
quantum gates are the fundamental

00:01:47,759 --> 00:01:50,960
operations that we run on quantum

00:01:49,360 --> 00:01:54,000
computers

00:01:50,960 --> 00:01:58,640
they're unlike

00:01:54,000 --> 00:01:59,759
classical operations they are reversible

00:01:58,640 --> 00:02:02,719
which means they can go in either

00:01:59,759 --> 00:02:04,079
direction here we see a block sphere

00:02:02,719 --> 00:02:06,560
blocksphere is a geometric

00:02:04,079 --> 00:02:07,920
representation of a single qubit

00:02:06,560 --> 00:02:09,440
the model doesn't really work so well

00:02:07,920 --> 00:02:11,440
when you start talking about multi-qubit

00:02:09,440 --> 00:02:13,280
operations but for this example

00:02:11,440 --> 00:02:15,200
it works pretty well in this case we're

00:02:13,280 --> 00:02:16,080
going to run a hadamard gate or an h

00:02:15,200 --> 00:02:18,480
gate

00:02:16,080 --> 00:02:20,400
we start at the zero position which

00:02:18,480 --> 00:02:22,720
represents a zero state

00:02:20,400 --> 00:02:25,280
and we rotate that along the block

00:02:22,720 --> 00:02:26,959
sphere to get the plus x direction

00:02:25,280 --> 00:02:29,040
all the one qubit gates you can think of

00:02:26,959 --> 00:02:30,800
as rotations along the sphere

00:02:29,040 --> 00:02:32,959
one thing to note though is that when we

00:02:30,800 --> 00:02:33,200
measure a qubit it's measured along the

00:02:32,959 --> 00:02:35,760
z

00:02:33,200 --> 00:02:36,400
axis here which is called computational

00:02:35,760 --> 00:02:39,599
basis

00:02:36,400 --> 00:02:42,400
we can either measure a zero or a one

00:02:39,599 --> 00:02:43,599
so when the hadamard is here at the plus

00:02:42,400 --> 00:02:45,280
x direction

00:02:43,599 --> 00:02:47,360
when we measure it we have about a

00:02:45,280 --> 00:02:47,760
fifty-fifty chance of going to zero or

00:02:47,360 --> 00:02:50,560
one

00:02:47,760 --> 00:02:52,160
when it's measured that's important to

00:02:50,560 --> 00:02:54,080
keep in mind because

00:02:52,160 --> 00:02:55,840
while quantum computers can be

00:02:54,080 --> 00:02:57,840
deterministically programmed they can

00:02:55,840 --> 00:02:59,680
still behave randomly in the result

00:02:57,840 --> 00:03:02,720
which is a fundamental difference from

00:02:59,680 --> 00:03:02,720
classical computers

00:03:02,879 --> 00:03:08,720
here i just put on a bunch of uh

00:03:06,159 --> 00:03:09,760
quantum gates some will be dealing with

00:03:08,720 --> 00:03:11,120
in this presentation

00:03:09,760 --> 00:03:14,239
others are just some common ones you

00:03:11,120 --> 00:03:15,840
might see just to get a feel for

00:03:14,239 --> 00:03:17,440
some of them the other thing that's

00:03:15,840 --> 00:03:18,319
important here is i put the unitary

00:03:17,440 --> 00:03:20,640
matrix

00:03:18,319 --> 00:03:23,040
each quantum gate can be represented as

00:03:20,640 --> 00:03:25,840
a unitary matrix

00:03:23,040 --> 00:03:27,440
which is then you can then multiply

00:03:25,840 --> 00:03:29,519
against

00:03:27,440 --> 00:03:31,280
the state vector for the quantum state

00:03:29,519 --> 00:03:34,560
i'm not going to go into the math here

00:03:31,280 --> 00:03:35,920
but it's important to realize that it's

00:03:34,560 --> 00:03:36,959
basically just doing matrix

00:03:35,920 --> 00:03:38,959
multiplication and all the

00:03:36,959 --> 00:03:42,640
visualizations before are just

00:03:38,959 --> 00:03:42,640
a geometric representation of that

00:03:43,360 --> 00:03:46,400
so how are people actually programming

00:03:45,040 --> 00:03:48,799
quantum circuits in practice

00:03:46,400 --> 00:03:50,080
it's all great when we can draw pictures

00:03:48,799 --> 00:03:53,120
but

00:03:50,080 --> 00:03:55,599
we're programmers we like code um

00:03:53,120 --> 00:03:56,959
so one way so we need languages one way

00:03:55,599 --> 00:03:58,959
that people program that

00:03:56,959 --> 00:04:00,319
is the open chasm language open chasm

00:03:58,959 --> 00:04:01,120
stands for open quantum assembly

00:04:00,319 --> 00:04:02,480
language

00:04:01,120 --> 00:04:04,080
and it can be used to write circuits so

00:04:02,480 --> 00:04:05,280
that circuit i was showing on the first

00:04:04,080 --> 00:04:07,120
slide

00:04:05,280 --> 00:04:09,200
is represented here in chasm where we

00:04:07,120 --> 00:04:10,640
define some registers a quantum register

00:04:09,200 --> 00:04:13,920
and a classical register

00:04:10,640 --> 00:04:15,599
apply our gates and measure although in

00:04:13,920 --> 00:04:17,919
practice most people don't seem to write

00:04:15,599 --> 00:04:20,160
openchasm in my experience

00:04:17,919 --> 00:04:21,919
they tend to use other frameworks like

00:04:20,160 --> 00:04:22,720
the kiskit project which i'll be talking

00:04:21,919 --> 00:04:25,680
about later

00:04:22,720 --> 00:04:28,639
that offers uh python apis or more

00:04:25,680 --> 00:04:30,320
convenient ways to program them

00:04:28,639 --> 00:04:32,080
from a compiler standpoint this also

00:04:30,320 --> 00:04:33,120
isn't super interesting it just ends up

00:04:32,080 --> 00:04:35,440
being a parser

00:04:33,120 --> 00:04:37,280
and parsers while there's work that can

00:04:35,440 --> 00:04:39,040
go into them they're not

00:04:37,280 --> 00:04:41,600
they're not as interesting as some of

00:04:39,040 --> 00:04:43,040
the other things i'll be talking about

00:04:41,600 --> 00:04:44,639
the other level that people program

00:04:43,040 --> 00:04:45,520
quantum computers at is at the pulse

00:04:44,639 --> 00:04:47,120
level

00:04:45,520 --> 00:04:48,960
so all of those gates that i showed

00:04:47,120 --> 00:04:52,800
before can be represented

00:04:48,960 --> 00:04:54,400
as microwave pulses

00:04:52,800 --> 00:04:56,400
that are applied to the qubits and

00:04:54,400 --> 00:04:56,800
that's that's how you uh transform the

00:04:56,400 --> 00:05:00,400
state

00:04:56,800 --> 00:05:00,400
the the quantum state on the qubit

00:05:00,639 --> 00:05:04,240
so if you're working at a really low

00:05:02,240 --> 00:05:06,160
level you can

00:05:04,240 --> 00:05:07,440
define your own pulses apply them to the

00:05:06,160 --> 00:05:09,199
qubits and measure them

00:05:07,440 --> 00:05:10,479
you can start tweaking things to try to

00:05:09,199 --> 00:05:11,759
get better performance out of your

00:05:10,479 --> 00:05:13,199
circuit

00:05:11,759 --> 00:05:14,720
this is mostly used for people that are

00:05:13,199 --> 00:05:16,080
doing physics research hardware

00:05:14,720 --> 00:05:17,360
characterization

00:05:16,080 --> 00:05:19,680
that kind of thing trying to get the

00:05:17,360 --> 00:05:22,240
most out of the limited devices that are

00:05:19,680 --> 00:05:23,759
available today

00:05:22,240 --> 00:05:25,120
we will not be talking about this

00:05:23,759 --> 00:05:26,479
although there are some interesting

00:05:25,120 --> 00:05:29,919
scheduling problems

00:05:26,479 --> 00:05:32,080
around how you go from a

00:05:29,919 --> 00:05:34,880
circuit representation to a pulse level

00:05:32,080 --> 00:05:34,880
representation

00:05:35,360 --> 00:05:38,960
so if we're programming things at a

00:05:37,840 --> 00:05:41,520
really low level either

00:05:38,960 --> 00:05:42,400
at basically the equivalent of assembly

00:05:41,520 --> 00:05:45,280
or

00:05:42,400 --> 00:05:46,160
even lower um why do we need compilers

00:05:45,280 --> 00:05:48,240
when you think about

00:05:46,160 --> 00:05:51,199
classical computers and how compilers

00:05:48,240 --> 00:05:54,160
work they're basically going from

00:05:51,199 --> 00:05:55,680
a higher level language down to assembly

00:05:54,160 --> 00:05:56,960
which is a one-to-one mapping with

00:05:55,680 --> 00:05:59,039
instructions

00:05:56,960 --> 00:06:01,520
and the reason we need compilers for

00:05:59,039 --> 00:06:04,840
current uh quantum computers

00:06:01,520 --> 00:06:06,000
are that current devices have a lot of

00:06:04,840 --> 00:06:07,759
limitations

00:06:06,000 --> 00:06:10,240
and that when we're doing this circuit

00:06:07,759 --> 00:06:11,600
we're actually abstracting away a lot of

00:06:10,240 --> 00:06:13,199
details

00:06:11,600 --> 00:06:16,400
that we have to keep in mind when

00:06:13,199 --> 00:06:16,400
actually running on hardware

00:06:16,639 --> 00:06:21,360
so in this example this is a circuit i

00:06:19,039 --> 00:06:24,080
actually used my presentation two

00:06:21,360 --> 00:06:25,120
two years ago we have a bunch of

00:06:24,080 --> 00:06:28,160
hadamard gates an

00:06:25,120 --> 00:06:30,639
x-gate and some cnoc gates

00:06:28,160 --> 00:06:33,680
and if we run these through a compiler

00:06:30,639 --> 00:06:35,600
to target an existing quantum chip

00:06:33,680 --> 00:06:37,440
we can get two different answers if we

00:06:35,600 --> 00:06:38,160
have bad compiler settings or a bad

00:06:37,440 --> 00:06:40,080
compiler

00:06:38,160 --> 00:06:41,759
we get the circuit on the top if we have

00:06:40,080 --> 00:06:42,400
a better compiler we get the circuit on

00:06:41,759 --> 00:06:44,000
the bottom

00:06:42,400 --> 00:06:45,919
and some things you'll notice is that

00:06:44,000 --> 00:06:48,400
all of those h's and x's they change to

00:06:45,919 --> 00:06:52,160
u2s and u3s and

00:06:48,400 --> 00:06:54,240
all of those cx gates they

00:06:52,160 --> 00:06:55,599
they have changed a lot so some of them

00:06:54,240 --> 00:06:56,720
there are a lot more on the bad

00:06:55,599 --> 00:06:59,919
compilation case

00:06:56,720 --> 00:07:02,080
and here they're about the same

00:06:59,919 --> 00:07:03,840
so what does this mean in practice

00:07:02,080 --> 00:07:05,520
though well when we run these two

00:07:03,840 --> 00:07:07,120
circuits either after a bad compilation

00:07:05,520 --> 00:07:09,599
or a good compilation

00:07:07,120 --> 00:07:11,039
we get very different results so that

00:07:09,599 --> 00:07:12,880
circuit had a known answer

00:07:11,039 --> 00:07:14,160
and that known answer was all once so

00:07:12,880 --> 00:07:16,319
basically

00:07:14,160 --> 00:07:17,840
this at the end we run this circuit with

00:07:16,319 --> 00:07:22,319
bad compilation

00:07:17,840 --> 00:07:23,680
we get all ones 2.8 percent of the time

00:07:22,319 --> 00:07:26,240
but when we run it with the good

00:07:23,680 --> 00:07:30,560
compilation we get all ones

00:07:26,240 --> 00:07:31,680
57 or 56 percent of the time

00:07:30,560 --> 00:07:33,440
so you can see that the difference

00:07:31,680 --> 00:07:35,120
between a bad compiler and a good

00:07:33,440 --> 00:07:35,680
compiler could be the difference between

00:07:35,120 --> 00:07:38,080
getting

00:07:35,680 --> 00:07:41,280
the right answer or just random noise

00:07:38,080 --> 00:07:41,280
which is what happened here

00:07:42,720 --> 00:07:48,080
so what are these limitations of the

00:07:45,680 --> 00:07:50,319
current quantum computers

00:07:48,080 --> 00:07:51,120
the first one to keep in mind is basis

00:07:50,319 --> 00:07:53,039
gates

00:07:51,120 --> 00:07:54,240
so each quantum computer out there only

00:07:53,039 --> 00:07:57,680
supports a subset

00:07:54,240 --> 00:07:59,840
of all of the quantum gates out there

00:07:57,680 --> 00:08:01,280
this is how this has to do with a lot of

00:07:59,840 --> 00:08:02,560
different um

00:08:01,280 --> 00:08:04,400
reasons on how the devices are

00:08:02,560 --> 00:08:07,440
constructed and

00:08:04,400 --> 00:08:08,479
how how much effort is put into tuning

00:08:07,440 --> 00:08:11,759
some of the gates

00:08:08,479 --> 00:08:14,240
remember when i said that the gates are

00:08:11,759 --> 00:08:16,080
mapped to pulse sequences those pulse

00:08:14,240 --> 00:08:18,560
sequences have to be

00:08:16,080 --> 00:08:19,199
mapped by hand at some point to define

00:08:18,560 --> 00:08:20,879
them

00:08:19,199 --> 00:08:22,400
so you're not going to do that for every

00:08:20,879 --> 00:08:23,680
single gate out there you're going to do

00:08:22,400 --> 00:08:26,560
them for a subset where you know you can

00:08:23,680 --> 00:08:26,560
get good results

00:08:27,120 --> 00:08:30,319
and you can use the subset of gates to

00:08:29,599 --> 00:08:32,479
implement

00:08:30,319 --> 00:08:35,360
all the other gates out there it's just

00:08:32,479 --> 00:08:39,120
a little bit of linear algebra

00:08:35,360 --> 00:08:40,000
so i on the right here i put some

00:08:39,120 --> 00:08:41,839
examples so

00:08:40,000 --> 00:08:43,519
a superconducting qubit is what ibm

00:08:41,839 --> 00:08:43,919
quantums devices are used and these are

00:08:43,519 --> 00:08:46,000
the base

00:08:43,919 --> 00:08:48,080
sets though the ibm quantum computers

00:08:46,000 --> 00:08:50,560
use trapped ion qubits is another

00:08:48,080 --> 00:08:53,279
technology for developing qubits

00:08:50,560 --> 00:08:55,200
and they use some different gates and

00:08:53,279 --> 00:08:56,959
then also a simulator they can use

00:08:55,200 --> 00:08:59,200
you can pretty much simulate any basis

00:08:56,959 --> 00:08:59,200
skate

00:09:00,480 --> 00:09:04,240
the other another limitation to keep in

00:09:02,160 --> 00:09:05,600
mind is cubic connectivity

00:09:04,240 --> 00:09:07,279
some quantum computers have limited

00:09:05,600 --> 00:09:09,120
connectivity between the qubits which

00:09:07,279 --> 00:09:12,800
means you can only run

00:09:09,120 --> 00:09:16,080
multi-qubit gates between some qubits

00:09:12,800 --> 00:09:16,560
on a quantum computer here i have a dye

00:09:16,080 --> 00:09:18,480
photo

00:09:16,560 --> 00:09:20,720
of one of ibm quantum's five qubit

00:09:18,480 --> 00:09:22,959
devices

00:09:20,720 --> 00:09:23,839
and you can see these wires that run

00:09:22,959 --> 00:09:27,040
between

00:09:23,839 --> 00:09:28,320
some of the qubits um this is

00:09:27,040 --> 00:09:30,320
what what i'm talking about with

00:09:28,320 --> 00:09:31,279
connectivity you can only run a two

00:09:30,320 --> 00:09:36,800
qubit

00:09:31,279 --> 00:09:39,760
gate between q2 and q0 between q4 and q3

00:09:36,800 --> 00:09:41,279
et cetera you can't if you for example

00:09:39,760 --> 00:09:44,080
you wanted to run

00:09:41,279 --> 00:09:45,279
a two-qubit gate between q0 and q3 you

00:09:44,080 --> 00:09:46,800
couldn't because there isn't a wire

00:09:45,279 --> 00:09:48,480
between them

00:09:46,800 --> 00:09:50,560
and this is easy to reason about when

00:09:48,480 --> 00:09:52,399
we're looking at a simple five qubit

00:09:50,560 --> 00:09:54,080
device but let's say we look at a 53

00:09:52,399 --> 00:09:56,560
qubit device

00:09:54,080 --> 00:09:57,279
this is a coupling map for all of the

00:09:56,560 --> 00:10:00,399
qubits on

00:09:57,279 --> 00:10:02,000
ibm quantum's 53 qubit processor

00:10:00,399 --> 00:10:04,480
and it's a lot harder to deal with when

00:10:02,000 --> 00:10:05,519
you have limited connectivity and so

00:10:04,480 --> 00:10:07,120
many qubits

00:10:05,519 --> 00:10:08,800
it's also worth pointing out that some

00:10:07,120 --> 00:10:10,399
other types of quantum computers

00:10:08,800 --> 00:10:12,000
trapped ions in particular that i

00:10:10,399 --> 00:10:14,320
mentioned earlier

00:10:12,000 --> 00:10:15,279
don't have this connectivity limitation

00:10:14,320 --> 00:10:17,360
all qubits

00:10:15,279 --> 00:10:19,519
can run gates on all against all other

00:10:17,360 --> 00:10:20,640
qubits

00:10:19,519 --> 00:10:24,079
but there are other additional

00:10:20,640 --> 00:10:24,079
trade-offs with that technology

00:10:24,560 --> 00:10:28,240
so what happens if you don't have enough

00:10:26,079 --> 00:10:30,240
connectivity so on both of those

00:10:28,240 --> 00:10:33,839
examples there is no

00:10:30,240 --> 00:10:35,680
path from certain qubits to other qubits

00:10:33,839 --> 00:10:37,760
and if the connectivity isn't sufficient

00:10:35,680 --> 00:10:38,480
to fully map your logical circuit that

00:10:37,760 --> 00:10:41,440
you

00:10:38,480 --> 00:10:43,519
outline um you can use swap gates to

00:10:41,440 --> 00:10:46,240
move it around so in this example

00:10:43,519 --> 00:10:47,680
there are two qubits qubit zero and

00:10:46,240 --> 00:10:49,120
qubit one that are connected to all

00:10:47,680 --> 00:10:50,399
other ones and on none of the coupling

00:10:49,120 --> 00:10:52,160
maps i showed before

00:10:50,399 --> 00:10:53,920
you would able you would be able to run

00:10:52,160 --> 00:10:56,000
this um

00:10:53,920 --> 00:10:58,240
so you use a swap gate which is uh

00:10:56,000 --> 00:11:00,320
represented by this symbol

00:10:58,240 --> 00:11:01,279
to move the state around between qubits

00:11:00,320 --> 00:11:03,600
it basically

00:11:01,279 --> 00:11:05,200
if you have a quantum state on one qubit

00:11:03,600 --> 00:11:06,640
and on another one you can use a swap

00:11:05,200 --> 00:11:09,120
gate and it will switch the states

00:11:06,640 --> 00:11:09,120
between them

00:11:09,600 --> 00:11:13,120
but this can be potentially expensive

00:11:11,680 --> 00:11:15,120
because when you run

00:11:13,120 --> 00:11:16,320
a swap gate on a computer that uses c

00:11:15,120 --> 00:11:18,560
naught gates

00:11:16,320 --> 00:11:20,079
you end up with three c not gates to

00:11:18,560 --> 00:11:21,600
represent one swap gate so if you have

00:11:20,079 --> 00:11:24,720
to swap the state a lot

00:11:21,600 --> 00:11:26,959
to fit the circuit on your device

00:11:24,720 --> 00:11:28,720
you're going to end up adding a lot of

00:11:26,959 --> 00:11:31,680
extra operations

00:11:28,720 --> 00:11:32,720
which comes to the next limitation which

00:11:31,680 --> 00:11:36,000
is noise

00:11:32,720 --> 00:11:37,760
everything in a quantum computer has

00:11:36,000 --> 00:11:39,760
noise associated with it and certain

00:11:37,760 --> 00:11:41,360
errors

00:11:39,760 --> 00:11:43,279
so you have individual gate errors you

00:11:41,360 --> 00:11:44,560
can have single qubit errors multi-qubit

00:11:43,279 --> 00:11:46,079
errors

00:11:44,560 --> 00:11:48,000
and also readout errors which is when

00:11:46,079 --> 00:11:50,240
you measure so you can see here that we

00:11:48,000 --> 00:11:51,920
have

00:11:50,240 --> 00:11:54,000
a coupling map for that same yorktown

00:11:51,920 --> 00:11:56,880
device i showed the die photo of earlier

00:11:54,000 --> 00:11:57,600
and this is showing that the error rates

00:11:56,880 --> 00:12:01,440
for

00:11:57,600 --> 00:12:05,120
each um which are one qubit gates

00:12:01,440 --> 00:12:07,279
are represented on the nodes um

00:12:05,120 --> 00:12:09,600
here with the color map and you also

00:12:07,279 --> 00:12:12,880
have error rates which are a bit higher

00:12:09,600 --> 00:12:14,560
you know around one percent um

00:12:12,880 --> 00:12:16,959
i believe that's what it says uh between

00:12:14,560 --> 00:12:19,200
one one and like two percent between

00:12:16,959 --> 00:12:20,079
different gates um for when you run c

00:12:19,200 --> 00:12:21,519
not gates

00:12:20,079 --> 00:12:23,440
between those qubits and then there's

00:12:21,519 --> 00:12:25,680
also a readout error rate

00:12:23,440 --> 00:12:27,120
like around two percent so basically

00:12:25,680 --> 00:12:28,560
every time you do something on a quantum

00:12:27,120 --> 00:12:30,000
computer you're introducing

00:12:28,560 --> 00:12:31,680
potential source of error where you'll

00:12:30,000 --> 00:12:32,639
get the wrong answer that's why when i

00:12:31,680 --> 00:12:35,600
showed

00:12:32,639 --> 00:12:37,200
the graph before with the results we

00:12:35,600 --> 00:12:39,120
didn't get the right answer 100

00:12:37,200 --> 00:12:40,560
of the time we got a 50-something

00:12:39,120 --> 00:12:41,839
percent of the time because even when we

00:12:40,560 --> 00:12:43,360
did everything correctly

00:12:41,839 --> 00:12:46,000
we still had errors and unexpected

00:12:43,360 --> 00:12:46,320
results the other thing to keep in mind

00:12:46,000 --> 00:12:49,440
though

00:12:46,320 --> 00:12:49,440
is there's de-coherence

00:12:50,240 --> 00:12:54,720
decoherence is the amount of time that

00:12:52,800 --> 00:12:57,519
we're able to preserve

00:12:54,720 --> 00:12:58,560
the quantum state and the qubits um

00:12:57,519 --> 00:13:00,639
they're

00:12:58,560 --> 00:13:01,600
in their measure d coherence is measured

00:13:00,639 --> 00:13:04,880
in two times

00:13:01,600 --> 00:13:05,360
typically there's t1 and t2 t1 is the

00:13:04,880 --> 00:13:07,440
energy

00:13:05,360 --> 00:13:09,200
energy relaxation time it's the time it

00:13:07,440 --> 00:13:10,320
takes if you had a qubit at the excited

00:13:09,200 --> 00:13:12,399
state or at the one

00:13:10,320 --> 00:13:13,839
pointing down on the block sphere and

00:13:12,399 --> 00:13:16,000
that earlier slide

00:13:13,839 --> 00:13:17,440
how long it will take for that one to

00:13:16,000 --> 00:13:19,760
decay to the ground state and just go

00:13:17,440 --> 00:13:23,200
back to zero

00:13:19,760 --> 00:13:25,279
and the other time is t2 which is

00:13:23,200 --> 00:13:26,639
a little bit more confusing but it's

00:13:25,279 --> 00:13:28,720
dephasing time

00:13:26,639 --> 00:13:30,480
if you have a qubit that's in

00:13:28,720 --> 00:13:32,560
superposition so somewhere between that

00:13:30,480 --> 00:13:35,040
zero and one

00:13:32,560 --> 00:13:36,240
how long it takes for that position to

00:13:35,040 --> 00:13:40,800
dephase or

00:13:36,240 --> 00:13:40,800
change direction um

00:13:41,519 --> 00:13:44,720
so this basically puts a limit on how

00:13:43,760 --> 00:13:47,519
much time

00:13:44,720 --> 00:13:49,199
we have to run our operations if we hit

00:13:47,519 --> 00:13:51,040
d coherence time whatever data we have

00:13:49,199 --> 00:13:54,079
we've basically lost our quantum state

00:13:51,040 --> 00:13:56,079
and you can you can't rely on it so the

00:13:54,079 --> 00:13:58,720
more operations we add to a

00:13:56,079 --> 00:13:59,920
to a circuit to make it run on a device

00:13:58,720 --> 00:14:02,639
the closer we'll be getting to that

00:13:59,920 --> 00:14:04,639
decoherence time

00:14:02,639 --> 00:14:07,839
which is not good if you're trying to

00:14:04,639 --> 00:14:07,839
run computation

00:14:08,160 --> 00:14:11,279
so those are the primary constraints

00:14:10,160 --> 00:14:12,800
with

00:14:11,279 --> 00:14:15,279
quantum computers today and why we need

00:14:12,800 --> 00:14:17,680
compilers so that's where the project i

00:14:15,279 --> 00:14:20,560
primarily work on

00:14:17,680 --> 00:14:21,680
comes in which is kiskit terra kiskitera

00:14:20,560 --> 00:14:24,000
is the

00:14:21,680 --> 00:14:25,440
base layer of the kisket project for

00:14:24,000 --> 00:14:27,279
working with quantum computers that

00:14:25,440 --> 00:14:29,279
provides an interface for hardware and

00:14:27,279 --> 00:14:31,839
software

00:14:29,279 --> 00:14:33,839
uh between hardware and software it

00:14:31,839 --> 00:14:35,760
provides an sdk for people to build

00:14:33,839 --> 00:14:37,199
quantum circuits that was the python api

00:14:35,760 --> 00:14:39,279
i alluded to earlier

00:14:37,199 --> 00:14:41,839
so you can write python code that will

00:14:39,279 --> 00:14:44,000
generate quantum circuits for you

00:14:41,839 --> 00:14:46,160
but it also includes a compiler to take

00:14:44,000 --> 00:14:48,480
those

00:14:46,160 --> 00:14:50,399
higher level circuits and map them to

00:14:48,480 --> 00:14:53,279
specific hardware backends

00:14:50,399 --> 00:14:54,639
it's designed to be backend agnostic so

00:14:53,279 --> 00:14:56,639
it can work with any hardware or

00:14:54,639 --> 00:14:59,600
simulator out there

00:14:56,639 --> 00:15:00,959
out of the box we ship extensions that

00:14:59,600 --> 00:15:04,079
let you run

00:15:00,959 --> 00:15:08,320
um circuits from kiskit tara

00:15:04,079 --> 00:15:11,920
on ibm q devices honeywell devices

00:15:08,320 --> 00:15:14,160
some startups like um aqt which is a

00:15:11,920 --> 00:15:16,399
trapped ion startup out of europe

00:15:14,160 --> 00:15:17,680
um and i believe some other people have

00:15:16,399 --> 00:15:20,160
written um

00:15:17,680 --> 00:15:22,079
some for like google and brighetti which

00:15:20,160 --> 00:15:26,639
are some competitors

00:15:22,079 --> 00:15:28,880
um tara's written primarily in python

00:15:26,639 --> 00:15:29,839
and it's apache licensed and you can

00:15:28,880 --> 00:15:32,320
find it on github

00:15:29,839 --> 00:15:33,839
at the link there so how does the

00:15:32,320 --> 00:15:36,720
compiler

00:15:33,839 --> 00:15:36,720
intera work

00:15:37,040 --> 00:15:42,079
the compiler in terra represents the

00:15:39,839 --> 00:15:42,959
quantum circuit as a directed acyclic

00:15:42,079 --> 00:15:45,839
graph

00:15:42,959 --> 00:15:48,720
here from that here we can see a quantum

00:15:45,839 --> 00:15:52,160
circuit represented as a dag

00:15:48,720 --> 00:15:54,079
in kisketerra we have nodes

00:15:52,160 --> 00:15:55,920
that are either input nodes which are

00:15:54,079 --> 00:15:58,240
represented in green

00:15:55,920 --> 00:15:59,920
um operation nodes which are represented

00:15:58,240 --> 00:16:02,959
in blue so you can see an h k

00:15:59,920 --> 00:16:05,600
a c naught gate and

00:16:02,959 --> 00:16:08,880
measurements and then output nodes which

00:16:05,600 --> 00:16:12,240
are represented in red

00:16:08,880 --> 00:16:13,120
and we can you we use this directed

00:16:12,240 --> 00:16:15,519
acyclic graph

00:16:13,120 --> 00:16:17,920
because it makes it much more explicit

00:16:15,519 --> 00:16:20,480
and easier to track the flow of data

00:16:17,920 --> 00:16:22,160
between the quantum circuit so you can

00:16:20,480 --> 00:16:24,959
see here that

00:16:22,160 --> 00:16:26,240
we we track which bits each operation

00:16:24,959 --> 00:16:29,120
are

00:16:26,240 --> 00:16:30,560
our which qubit each operation is

00:16:29,120 --> 00:16:33,040
touching and we track that

00:16:30,560 --> 00:16:34,399
through the dag which makes it easier

00:16:33,040 --> 00:16:37,440
when we start looking

00:16:34,399 --> 00:16:41,279
um at more complicated examples and how

00:16:37,440 --> 00:16:41,279
we start optimizing circuits later

00:16:41,360 --> 00:16:46,959
so here's an example that shows

00:16:44,560 --> 00:16:48,959
how this makes it more explicit you can

00:16:46,959 --> 00:16:50,800
see here we have a circuit here

00:16:48,959 --> 00:16:53,040
which is basically the same one before

00:16:50,800 --> 00:16:56,079
but it adds this

00:16:53,040 --> 00:16:59,279
rz gate which has

00:16:56,079 --> 00:17:01,440
a classical condition on it basically

00:16:59,279 --> 00:17:04,799
this means that when we have this rz

00:17:01,440 --> 00:17:09,520
gate we only run it if the bit string

00:17:04,799 --> 00:17:10,880
on the classical bits is 0 1 0.

00:17:09,520 --> 00:17:12,880
and if you look at this it's hard to

00:17:10,880 --> 00:17:15,199
tell that there's any relationship

00:17:12,880 --> 00:17:16,720
between this h gate and this r z gate

00:17:15,199 --> 00:17:19,679
but when you look at the dag

00:17:16,720 --> 00:17:21,520
that relationship is pretty obvious

00:17:19,679 --> 00:17:25,679
because you see we have this

00:17:21,520 --> 00:17:28,000
h gate here if we just follow the q 0

00:17:25,679 --> 00:17:29,200
we end up having an arrow between this

00:17:28,000 --> 00:17:33,120
path

00:17:29,200 --> 00:17:34,400
and here same with the c1 with qubit 1.

00:17:33,120 --> 00:17:36,960
although that one is more obvious

00:17:34,400 --> 00:17:39,440
because that two operations back to back

00:17:36,960 --> 00:17:40,960
so the dag lets us see this data flow

00:17:39,440 --> 00:17:44,160
much more easily

00:17:40,960 --> 00:17:44,160
than we could on the circuit

00:17:44,880 --> 00:17:51,840
so what do we do with this dag in tara

00:17:48,320 --> 00:17:55,760
we have um what we call a transpiler

00:17:51,840 --> 00:17:56,880
which i um i don't think is personally

00:17:55,760 --> 00:17:57,760
the best name i just call it the

00:17:56,880 --> 00:18:01,520
compiler but

00:17:57,760 --> 00:18:04,799
i'll use them interchangeably

00:18:01,520 --> 00:18:06,880
which so we have the transpiler which is

00:18:04,799 --> 00:18:09,360
built around a pass manager

00:18:06,880 --> 00:18:10,480
that is used to execute passes on the

00:18:09,360 --> 00:18:13,760
dag

00:18:10,480 --> 00:18:16,000
to basically convert it from that

00:18:13,760 --> 00:18:17,600
virtual form or the generic form to

00:18:16,000 --> 00:18:20,080
something that's specifically designed

00:18:17,600 --> 00:18:22,320
to run on a specific computer

00:18:20,080 --> 00:18:24,080
in this run these passes are defined as

00:18:22,320 --> 00:18:25,280
small well-defined tasks that either do

00:18:24,080 --> 00:18:28,559
a transform

00:18:25,280 --> 00:18:30,799
or do some analysis we keep

00:18:28,559 --> 00:18:31,600
the pass we keep the passes simple and

00:18:30,799 --> 00:18:33,120
we can then

00:18:31,600 --> 00:18:35,280
use the pass manager to handle

00:18:33,120 --> 00:18:35,760
scheduling managing dependencies between

00:18:35,280 --> 00:18:37,360
them

00:18:35,760 --> 00:18:39,679
and basically build a pipeline for

00:18:37,360 --> 00:18:43,840
transforming that input circuit or

00:18:39,679 --> 00:18:43,840
something we can run on a device

00:18:44,720 --> 00:18:50,480
the passes are built

00:18:48,000 --> 00:18:52,480
of two types basically there we have a

00:18:50,480 --> 00:18:53,919
transformation pass which is designed to

00:18:52,480 --> 00:18:55,840
transform that dac

00:18:53,919 --> 00:18:57,600
so we have a dag input you run the

00:18:55,840 --> 00:18:59,840
transformation pass on it and you'll get

00:18:57,600 --> 00:19:01,520
a separate dag output

00:18:59,840 --> 00:19:03,039
then we also have analysis passes which

00:19:01,520 --> 00:19:04,160
will read the stag and pull some

00:19:03,039 --> 00:19:05,760
information off of it

00:19:04,160 --> 00:19:08,160
and put it in a property set which is

00:19:05,760 --> 00:19:11,360
basically just a python dictionary

00:19:08,160 --> 00:19:13,200
that keeps track of certain attributes

00:19:11,360 --> 00:19:15,280
of the circuit as we go through it

00:19:13,200 --> 00:19:18,480
so one example is if we have a pass that

00:19:15,280 --> 00:19:20,240
analyzes it for some property

00:19:18,480 --> 00:19:22,640
on the slide i used commutation

00:19:20,240 --> 00:19:24,640
relationships

00:19:22,640 --> 00:19:28,240
and then a later pass we'll use that

00:19:24,640 --> 00:19:28,240
information to do a transform

00:19:28,960 --> 00:19:33,679
the pass manager is broken up into a

00:19:31,200 --> 00:19:35,440
series of stages

00:19:33,679 --> 00:19:37,840
we basically start with the user circuit

00:19:35,440 --> 00:19:39,679
which can be arbitrary numbers

00:19:37,840 --> 00:19:41,120
arbitrary gates and arbitrary

00:19:39,679 --> 00:19:42,320
connectivity and we start with doing

00:19:41,120 --> 00:19:44,720
logical reductions

00:19:42,320 --> 00:19:46,400
so we look at the circuit and we see are

00:19:44,720 --> 00:19:48,000
there simple

00:19:46,400 --> 00:19:49,440
logical reductions we can do to just

00:19:48,000 --> 00:19:52,480
simplify the

00:19:49,440 --> 00:19:55,440
complexity from there we go to

00:19:52,480 --> 00:19:56,000
embedding which is we map the virtual

00:19:55,440 --> 00:20:00,000
circuit

00:19:56,000 --> 00:20:01,840
to the physical device constraints so

00:20:00,000 --> 00:20:04,559
that'll include picking

00:20:01,840 --> 00:20:06,000
um mapping between virtual qubits

00:20:04,559 --> 00:20:08,240
physical qubits

00:20:06,000 --> 00:20:10,080
as well as unrolling to the basis set

00:20:08,240 --> 00:20:11,360
for the specific device

00:20:10,080 --> 00:20:13,360
from there we go to physical

00:20:11,360 --> 00:20:14,240
optimizations which are an additional

00:20:13,360 --> 00:20:16,320
optimization

00:20:14,240 --> 00:20:19,520
any additional optimizations we can run

00:20:16,320 --> 00:20:22,080
after we've embedded the circuit

00:20:19,520 --> 00:20:23,919
and then after that's all done we have

00:20:22,080 --> 00:20:26,559
an output circuit that can be run

00:20:23,919 --> 00:20:27,600
on a device and the thing to remember is

00:20:26,559 --> 00:20:30,159
that this

00:20:27,600 --> 00:20:30,960
entire while we have these basic stages

00:20:30,159 --> 00:20:32,799
the entire

00:20:30,960 --> 00:20:35,039
pass manager is designed to be pluggable

00:20:32,799 --> 00:20:36,240
and extensible so we ship some preset

00:20:35,039 --> 00:20:38,000
pass managers

00:20:36,240 --> 00:20:40,320
that come with it but you can customize

00:20:38,000 --> 00:20:42,080
it to do any kind of optimizations or

00:20:40,320 --> 00:20:43,200
transforms or analysis that you'd like

00:20:42,080 --> 00:20:44,480
to do

00:20:43,200 --> 00:20:46,720
and this is an area that there's a lot

00:20:44,480 --> 00:20:48,000
of research in is looking at how we can

00:20:46,720 --> 00:20:50,640
come up with better

00:20:48,000 --> 00:20:52,080
uh compilation steps so having this

00:20:50,640 --> 00:20:55,360
plugability is very

00:20:52,080 --> 00:20:57,600
useful so

00:20:55,360 --> 00:21:00,640
out of the box kiskaterra ships for

00:20:57,600 --> 00:21:04,159
optimization levels which is just like

00:21:00,640 --> 00:21:05,600
gcc or or clang basically where you

00:21:04,159 --> 00:21:07,360
you have different optimization levels

00:21:05,600 --> 00:21:08,400
that go to different levels of effort to

00:21:07,360 --> 00:21:12,320
try to

00:21:08,400 --> 00:21:14,400
optimize a circuit better um

00:21:12,320 --> 00:21:15,840
the trade-off so we started optimization

00:21:14,400 --> 00:21:17,360
level zero where there's basically no

00:21:15,840 --> 00:21:18,240
optimization it'll just do that

00:21:17,360 --> 00:21:19,919
embedding step

00:21:18,240 --> 00:21:21,440
so make it so that your input circuit

00:21:19,919 --> 00:21:23,760
will run on the

00:21:21,440 --> 00:21:25,440
specified device and do nothing else and

00:21:23,760 --> 00:21:25,760
then on the other end of the spectrum we

00:21:25,440 --> 00:21:27,280
have

00:21:25,760 --> 00:21:29,280
optimization level three which will go

00:21:27,280 --> 00:21:31,360
to all available effort to try to

00:21:29,280 --> 00:21:33,520
optimize the circuit

00:21:31,360 --> 00:21:33,520
so

00:21:34,720 --> 00:21:39,840
so if we look at each optimization level

00:21:37,200 --> 00:21:42,720
we have optimalization level 0

00:21:39,840 --> 00:21:44,720
which will run no optimization just

00:21:42,720 --> 00:21:46,720
unroll the circuit apply a layout and do

00:21:44,720 --> 00:21:48,320
some swap mapping which is the

00:21:46,720 --> 00:21:50,000
if there's limited connectivity it'll

00:21:48,320 --> 00:21:51,919
insert swap gates where it needs to be

00:21:50,000 --> 00:21:54,080
and i apologize this drawing is so small

00:21:51,919 --> 00:21:55,840
i could not come up with a

00:21:54,080 --> 00:21:58,000
simpler visualization to show all of the

00:21:55,840 --> 00:21:59,760
steps but it's just showing the flow

00:21:58,000 --> 00:22:02,159
chart of each of the passes in the past

00:21:59,760 --> 00:22:02,159
manager

00:22:02,320 --> 00:22:06,720
optimization level two is basically the

00:22:04,720 --> 00:22:07,600
same as optimization level zero except

00:22:06,720 --> 00:22:10,000
we have

00:22:07,600 --> 00:22:11,520
optimization path uh passes at the end

00:22:10,000 --> 00:22:14,640
we have one that'll do

00:22:11,520 --> 00:22:16,799
one qubit gate optimization and another

00:22:14,640 --> 00:22:19,120
that will do

00:22:16,799 --> 00:22:19,919
c not gate cancellation and you can see

00:22:19,120 --> 00:22:21,280
here i don't

00:22:19,919 --> 00:22:23,520
think anyone will be able to read this

00:22:21,280 --> 00:22:25,679
but it says do while

00:22:23,520 --> 00:22:27,919
right there so we actually run this in a

00:22:25,679 --> 00:22:30,000
loop until we get a fixed

00:22:27,919 --> 00:22:31,919
depth output so when the size of the

00:22:30,000 --> 00:22:32,720
circuit doesn't change after two runs we

00:22:31,919 --> 00:22:34,480
say okay

00:22:32,720 --> 00:22:36,640
we've optimized it as much as we can and

00:22:34,480 --> 00:22:40,320
we stop there

00:22:36,640 --> 00:22:42,640
optimization level two it just adds um

00:22:40,320 --> 00:22:44,960
an additional optimization pass on level

00:22:42,640 --> 00:22:46,480
one for commutative cancellation

00:22:44,960 --> 00:22:48,640
and it changes some of the passes it

00:22:46,480 --> 00:22:52,480
runs um for

00:22:48,640 --> 00:22:55,120
embedding um to try to do a better job

00:22:52,480 --> 00:22:57,840
even though it's a little bit slower an

00:22:55,120 --> 00:23:00,480
optimization level three

00:22:57,840 --> 00:23:01,120
just takes it up another notch so it's

00:23:00,480 --> 00:23:04,559
we run

00:23:01,120 --> 00:23:08,080
a lot more optimization passes

00:23:04,559 --> 00:23:11,440
which you can see here and then we

00:23:08,080 --> 00:23:11,440
also um

00:23:11,919 --> 00:23:18,080
run some dif uh yet another different

00:23:15,280 --> 00:23:18,080
layout pass

00:23:19,280 --> 00:23:22,400
so now let's talk about some individual

00:23:20,960 --> 00:23:23,679
passes the first one i'm going to talk

00:23:22,400 --> 00:23:27,280
about is the unroller

00:23:23,679 --> 00:23:28,559
so when we have to map from one basis

00:23:27,280 --> 00:23:30,640
set to another we need a way to

00:23:28,559 --> 00:23:32,320
translate that

00:23:30,640 --> 00:23:34,240
the unroller is the simplest method to

00:23:32,320 --> 00:23:37,039
do this it basically looks at

00:23:34,240 --> 00:23:38,799
every single gates definition and

00:23:37,039 --> 00:23:40,000
descends through those definitions until

00:23:38,799 --> 00:23:42,159
it reaches a gate in the base

00:23:40,000 --> 00:23:43,360
set so in this example i just put it on

00:23:42,159 --> 00:23:46,720
a graph

00:23:43,360 --> 00:23:48,320
and said okay our basis is going to be c

00:23:46,720 --> 00:23:51,279
naught and u3

00:23:48,320 --> 00:23:52,080
let's and we started with a swap gate

00:23:51,279 --> 00:23:54,320
and a cz

00:23:52,080 --> 00:23:55,600
gate and we just descend through the

00:23:54,320 --> 00:23:57,600
definitions

00:23:55,600 --> 00:23:59,440
until we get to something that matches

00:23:57,600 --> 00:24:02,480
our basis

00:23:59,440 --> 00:24:05,520
um in kisket this only really works with

00:24:02,480 --> 00:24:08,000
superconducting qubits and uh

00:24:05,520 --> 00:24:09,039
honestly super conducting qubit devices

00:24:08,000 --> 00:24:11,200
from

00:24:09,039 --> 00:24:13,279
six months ago because ibm actually

00:24:11,200 --> 00:24:16,559
changed the basis gates they used

00:24:13,279 --> 00:24:17,279
not that long ago the limitation with

00:24:16,559 --> 00:24:19,039
this is that

00:24:17,279 --> 00:24:20,400
you only can have one definition per

00:24:19,039 --> 00:24:23,039
gate so

00:24:20,400 --> 00:24:24,559
if you if you don't have a path from one

00:24:23,039 --> 00:24:28,159
gate to another

00:24:24,559 --> 00:24:31,520
um you you won't be able to

00:24:28,159 --> 00:24:33,039
to unroll it we have an additional pass

00:24:31,520 --> 00:24:33,760
and kiss kit which is called the basis

00:24:33,039 --> 00:24:36,080
translator

00:24:33,760 --> 00:24:37,679
which takes this graph but also adds

00:24:36,080 --> 00:24:39,039
additional definitions to it and then

00:24:37,679 --> 00:24:41,360
does an a-star search

00:24:39,039 --> 00:24:42,320
to traverse the graph to try to find the

00:24:41,360 --> 00:24:45,039
fastest path

00:24:42,320 --> 00:24:46,480
from one gate to something in the basis

00:24:45,039 --> 00:24:47,679
that was a lot more complicated to put

00:24:46,480 --> 00:24:50,159
on a slide

00:24:47,679 --> 00:24:51,919
so i just stuck with this example we

00:24:50,159 --> 00:24:53,919
still use the unroller

00:24:51,919 --> 00:24:55,440
though for complicated custom gates

00:24:53,919 --> 00:24:57,440
because we can use this

00:24:55,440 --> 00:25:01,840
to unroll one level into something the

00:24:57,440 --> 00:25:01,840
basis translator can then use

00:25:02,880 --> 00:25:07,360
moving on let's talk about layout so

00:25:06,080 --> 00:25:10,480
layout is actually

00:25:07,360 --> 00:25:11,840
deceptively important so when we have a

00:25:10,480 --> 00:25:15,840
virtual circuit

00:25:11,840 --> 00:25:17,200
with our qubits q1 q2 q3 q4

00:25:15,840 --> 00:25:20,799
we have to figure out how we're going to

00:25:17,200 --> 00:25:20,799
map those onto the physical device

00:25:22,000 --> 00:25:27,520
and that initial qubit selection from

00:25:26,080 --> 00:25:29,919
what what's in our circuit to what's on

00:25:27,520 --> 00:25:30,799
the device can be really important

00:25:29,919 --> 00:25:32,640
because if we pick

00:25:30,799 --> 00:25:34,080
poorly then we have to start adding a

00:25:32,640 --> 00:25:39,840
lot of swap gates

00:25:34,080 --> 00:25:39,840
to um make the circuit runnable

00:25:40,000 --> 00:25:44,320
out of the box we have three passes in

00:25:42,559 --> 00:25:45,840
kisket that do layout there's actually a

00:25:44,320 --> 00:25:46,640
fourth one that i forgot to update on

00:25:45,840 --> 00:25:50,720
the slide

00:25:46,640 --> 00:25:52,640
sabre layout um but that's not important

00:25:50,720 --> 00:25:54,320
um because we're only going to be

00:25:52,640 --> 00:25:57,200
looking at these three

00:25:54,320 --> 00:25:59,039
um so let's look at an example of how

00:25:57,200 --> 00:26:02,240
layout can be important here i have a

00:25:59,039 --> 00:26:03,520
example circuit um you can see

00:26:02,240 --> 00:26:04,960
you don't have to worry too much about

00:26:03,520 --> 00:26:05,600
what the circuit does this is actually

00:26:04,960 --> 00:26:07,039
from

00:26:05,600 --> 00:26:09,279
something called grover's algorithm

00:26:07,039 --> 00:26:13,440
which is used for

00:26:09,279 --> 00:26:15,520
basically doing database searches um

00:26:13,440 --> 00:26:17,360
but we have some two qubit gates these

00:26:15,520 --> 00:26:20,720
are cz gates

00:26:17,360 --> 00:26:22,480
um between qubit zero and

00:26:20,720 --> 00:26:24,559
all of the other qubits and we have some

00:26:22,480 --> 00:26:25,279
more gates and then again some cz gates

00:26:24,559 --> 00:26:29,039
between

00:26:25,279 --> 00:26:30,880
qubit zero and all of the other qubits

00:26:29,039 --> 00:26:33,039
and we want to run it on this device

00:26:30,880 --> 00:26:34,480
with this coupling map

00:26:33,039 --> 00:26:36,960
and if we look at this if we think about

00:26:34,480 --> 00:26:37,760
it for a second the obvious answer is oh

00:26:36,960 --> 00:26:41,440
we just pick

00:26:37,760 --> 00:26:44,000
qubit zero is qubit one because that has

00:26:41,440 --> 00:26:46,240
connectivity to three other qubits just

00:26:44,000 --> 00:26:48,880
like we have in the circuit

00:26:46,240 --> 00:26:51,039
and then the other ones we just pick

00:26:48,880 --> 00:26:52,080
either zero two or three for one two and

00:26:51,039 --> 00:26:53,919
00:26:52,080 --> 00:26:56,960
in the circuit and then we don't have to

00:26:53,919 --> 00:26:56,960
use any swap gates

00:26:57,039 --> 00:27:00,559
but if we use some of the other passes

00:26:59,120 --> 00:27:01,520
so we can specifically tell the

00:27:00,559 --> 00:27:04,799
transpiler

00:27:01,520 --> 00:27:07,520
to okay let's use that as our layout

00:27:04,799 --> 00:27:09,440
but then we have we can also use the

00:27:07,520 --> 00:27:12,480
passes and see how they do

00:27:09,440 --> 00:27:14,000
so i apologize how small this is but

00:27:12,480 --> 00:27:15,520
when you

00:27:14,000 --> 00:27:17,679
compile the circuit it gets a little bit

00:27:15,520 --> 00:27:20,799
lengthy

00:27:17,679 --> 00:27:22,559
but so i ran the three layout passes we

00:27:20,799 --> 00:27:24,159
have trivial layout dense layout noise

00:27:22,559 --> 00:27:25,360
adaptive layout and then custom layout

00:27:24,159 --> 00:27:27,039
is the one

00:27:25,360 --> 00:27:28,399
that's perfect that we know about where

00:27:27,039 --> 00:27:30,320
we don't need any swap gates

00:27:28,399 --> 00:27:31,840
and you can see trivial layout just goes

00:27:30,320 --> 00:27:35,039
from

00:27:31,840 --> 00:27:37,840
qubit 0 to physical bit qubit zero

00:27:35,039 --> 00:27:38,880
and it results in we need two swaps if

00:27:37,840 --> 00:27:40,880
you remember the three

00:27:38,880 --> 00:27:42,720
c not gate pattern i showed before we

00:27:40,880 --> 00:27:45,919
have one swap gate there

00:27:42,720 --> 00:27:48,080
and one swap gate there and

00:27:45,919 --> 00:27:49,279
that's actually pretty good i was kind

00:27:48,080 --> 00:27:51,520
of surprised just

00:27:49,279 --> 00:27:52,880
going zero to zero one to one to that

00:27:51,520 --> 00:27:55,679
good of a job

00:27:52,880 --> 00:27:57,760
dense layout which is a little bit more

00:27:55,679 --> 00:28:01,039
complicated

00:27:57,760 --> 00:28:02,880
of a pass it goes from it ended up

00:28:01,039 --> 00:28:04,000
inserting a lot more swap gates you see

00:28:02,880 --> 00:28:07,600
one two three

00:28:04,000 --> 00:28:10,720
four five swap gates are inserted there

00:28:07,600 --> 00:28:13,919
um so that one

00:28:10,720 --> 00:28:15,279
is probably going to be pretty noisy um

00:28:13,919 --> 00:28:17,120
the noise adaptive layout which is

00:28:15,279 --> 00:28:20,159
similar to dense layout but it also

00:28:17,120 --> 00:28:22,399
factors in it's trying to

00:28:20,159 --> 00:28:23,440
pick qubits with the lowest noise so it

00:28:22,399 --> 00:28:27,919
sometimes does

00:28:23,440 --> 00:28:27,919
a worse job than dense layout but

00:28:28,720 --> 00:28:31,760
in this case it actually didn't seem to

00:28:30,880 --> 00:28:34,559
um

00:28:31,760 --> 00:28:37,279
and you see this ended up with three

00:28:34,559 --> 00:28:40,559
swap gates but it did

00:28:37,279 --> 00:28:43,279
um different qubits than

00:28:40,559 --> 00:28:45,200
the other two and then our custom layout

00:28:43,279 --> 00:28:47,120
we have no swaps we just

00:28:45,200 --> 00:28:48,559
mapped it perfectly and then when we

00:28:47,120 --> 00:28:51,919
look at the results

00:28:48,559 --> 00:28:54,000
this is where things get interesting so

00:28:51,919 --> 00:28:55,679
there is um four correct answers to that

00:28:54,000 --> 00:28:56,559
circuit the four expected answers i

00:28:55,679 --> 00:28:59,760
should say

00:28:56,559 --> 00:29:03,520
we'll be getting either 0 0 1

00:28:59,760 --> 00:29:06,720
1 0 1 0 1

00:29:03,520 --> 00:29:09,440
or 1 0 0 1

00:29:06,720 --> 00:29:10,640
and or all ones those are the four

00:29:09,440 --> 00:29:14,399
answers that

00:29:10,640 --> 00:29:16,480
are expected from that circuit um

00:29:14,399 --> 00:29:18,480
and if you see trivial layout it's kind

00:29:16,480 --> 00:29:19,919
of hard to tell which ones are

00:29:18,480 --> 00:29:21,200
which that's actually why i got tripped

00:29:19,919 --> 00:29:21,679
up a second i should have looked one of

00:29:21,200 --> 00:29:24,799
the

00:29:21,679 --> 00:29:26,799
other ones um but

00:29:24,799 --> 00:29:28,799
so you can see that's like we we got a

00:29:26,799 --> 00:29:30,159
pretty even distribution between those

00:29:28,799 --> 00:29:33,520
four answers you know ideally

00:29:30,159 --> 00:29:35,360
we'd want 25 on all all four of them or

00:29:33,520 --> 00:29:36,880
close to it

00:29:35,360 --> 00:29:40,240
dense layout despite having all of those

00:29:36,880 --> 00:29:42,159
swaps did a better job

00:29:40,240 --> 00:29:44,240
i think that's because dense layout

00:29:42,159 --> 00:29:46,000
factors in noise to its selection

00:29:44,240 --> 00:29:49,600
just like noise adaptive layout does but

00:29:46,000 --> 00:29:49,600
you can see we still had a pretty high

00:29:49,840 --> 00:29:54,720
error rate for the other ones when we

00:29:53,039 --> 00:29:56,399
look at noise adaptive layout it's

00:29:54,720 --> 00:29:58,240
honestly pretty similar to dense layout

00:29:56,399 --> 00:30:00,000
and performance and then custom layout

00:29:58,240 --> 00:30:02,640
because we had no swaps did an excellent

00:30:00,000 --> 00:30:04,559
job like everything is below

00:30:02,640 --> 00:30:06,399
five percent um that we weren't

00:30:04,559 --> 00:30:09,279
expecting

00:30:06,399 --> 00:30:10,320
with the exception of zero zero zero one

00:30:09,279 --> 00:30:12,880
um

00:30:10,320 --> 00:30:14,559
but you can see that like layout ends up

00:30:12,880 --> 00:30:15,840
having a surprising effect

00:30:14,559 --> 00:30:17,440
you wouldn't think that like that

00:30:15,840 --> 00:30:18,000
initial mapping would be as important as

00:30:17,440 --> 00:30:19,919
it is

00:30:18,000 --> 00:30:22,320
but when you factor in that swap gates

00:30:19,919 --> 00:30:25,200
end up being kind of expensive it makes

00:30:22,320 --> 00:30:25,200
a pretty big difference

00:30:27,120 --> 00:30:34,039
after layout we also have swap mappers

00:30:32,640 --> 00:30:37,039
these algorithms are a little bit more

00:30:34,039 --> 00:30:39,760
complicated

00:30:37,039 --> 00:30:42,080
they so i'm not going to go into too

00:30:39,760 --> 00:30:45,120
much detail on how they work

00:30:42,080 --> 00:30:47,760
but in kiskit we have actually now

00:30:45,120 --> 00:30:49,360
four four algorithms for doing swap

00:30:47,760 --> 00:30:51,520
mapping or routing

00:30:49,360 --> 00:30:53,200
basic swap lookahead swap stochastic

00:30:51,520 --> 00:30:56,640
swap

00:30:53,200 --> 00:30:59,919
and um the the fourth one is now

00:30:56,640 --> 00:31:02,720
saber swap but we actually

00:30:59,919 --> 00:31:04,320
use stochastic swap in by default in all

00:31:02,720 --> 00:31:05,919
of the preset pass managers

00:31:04,320 --> 00:31:07,440
that's primarily a function of speed

00:31:05,919 --> 00:31:11,039
stochastic swap was

00:31:07,440 --> 00:31:13,360
uh rewritten in cython about a year ago

00:31:11,039 --> 00:31:14,480
and uh because it ends up being compiled

00:31:13,360 --> 00:31:16,480
from c plus plus

00:31:14,480 --> 00:31:18,480
through cython it ends up being a lot

00:31:16,480 --> 00:31:20,000
faster than the other passes so we just

00:31:18,480 --> 00:31:22,000
use it for pass it's performance is very

00:31:20,000 --> 00:31:24,480
good it's based on

00:31:22,000 --> 00:31:25,360
some heuristic uh some heuristic

00:31:24,480 --> 00:31:27,760
algorithms so it

00:31:25,360 --> 00:31:29,600
basically does a bunch of random trials

00:31:27,760 --> 00:31:32,720
of different ways to swap the circuit

00:31:29,600 --> 00:31:33,600
and picks the best one based on that but

00:31:32,720 --> 00:31:37,679
it

00:31:33,600 --> 00:31:38,799
um yeah so

00:31:37,679 --> 00:31:40,080
there are a lot of different ways

00:31:38,799 --> 00:31:41,600
there's this is actually an area of a

00:31:40,080 --> 00:31:42,880
lot of active research to try to come up

00:31:41,600 --> 00:31:44,480
with better algorithms because some of

00:31:42,880 --> 00:31:46,640
these don't scale very well for large

00:31:44,480 --> 00:31:48,000
qubit numbers um or have different

00:31:46,640 --> 00:31:50,799
performance trade-offs

00:31:48,000 --> 00:31:52,320
so routing is actually a very

00:31:50,799 --> 00:31:54,640
interesting problem and one to think

00:31:52,320 --> 00:31:54,640
about

00:31:55,120 --> 00:32:00,799
so those are the two the three main like

00:31:58,399 --> 00:32:01,840
embedding passes the embedding steps of

00:32:00,799 --> 00:32:05,039
the embedding

00:32:01,840 --> 00:32:06,480
phase of transpile so let's look at some

00:32:05,039 --> 00:32:07,360
optimization passes and this is where

00:32:06,480 --> 00:32:09,919
things can get

00:32:07,360 --> 00:32:11,440
kind of fun and interesting so the first

00:32:09,919 --> 00:32:12,880
thing we're going to talk about is two

00:32:11,440 --> 00:32:16,240
qubit block collection

00:32:12,880 --> 00:32:17,200
which is an analysis pass so what this

00:32:16,240 --> 00:32:20,960
pass does is

00:32:17,200 --> 00:32:22,960
we want to collect all blocks of

00:32:20,960 --> 00:32:25,120
operation that operate solely on two

00:32:22,960 --> 00:32:26,559
qubits so we want to look at the circuit

00:32:25,120 --> 00:32:29,279
and figure out okay

00:32:26,559 --> 00:32:30,720
which which operations are isolated to

00:32:29,279 --> 00:32:33,120
just two qubits and

00:32:30,720 --> 00:32:34,720
collect that in a block if you look at

00:32:33,120 --> 00:32:36,880
the circuit this is actually pretty hard

00:32:34,720 --> 00:32:39,919
to do

00:32:36,880 --> 00:32:42,799
because of this tnh gate over here

00:32:39,919 --> 00:32:44,559
so i map this circuit directly onto it a

00:32:42,799 --> 00:32:46,320
dag

00:32:44,559 --> 00:32:47,919
and you can see here it's a lot easier

00:32:46,320 --> 00:32:49,279
to actually find this block collection

00:32:47,919 --> 00:32:51,120
we just

00:32:49,279 --> 00:32:52,720
follow the data flow and when it goes

00:32:51,120 --> 00:32:56,399
off those qubits

00:32:52,720 --> 00:33:00,640
it's it's no longer isolated

00:32:56,399 --> 00:33:01,840
um and that's pretty simple but what do

00:33:00,640 --> 00:33:03,440
we do with these blocks that's where

00:33:01,840 --> 00:33:05,120
things get interesting

00:33:03,440 --> 00:33:07,200
so that's where the consolidate blocks

00:33:05,120 --> 00:33:08,480
pass comes in so after we take those

00:33:07,200 --> 00:33:09,279
blocks we collected in the previous

00:33:08,480 --> 00:33:11,279
slide

00:33:09,279 --> 00:33:12,480
we run a simulation of those two qubit

00:33:11,279 --> 00:33:15,600
blocks to

00:33:12,480 --> 00:33:17,360
find what the unitary matrix the

00:33:15,600 --> 00:33:19,600
matrix representation of that block

00:33:17,360 --> 00:33:21,200
would be

00:33:19,600 --> 00:33:24,240
and insert that on the circuit instead

00:33:21,200 --> 00:33:25,840
of the block um

00:33:24,240 --> 00:33:27,600
and what we can do then is once we have

00:33:25,840 --> 00:33:31,279
that unitary matrix we can do

00:33:27,600 --> 00:33:35,919
some more math um

00:33:31,279 --> 00:33:37,760
and sorry and convert that into

00:33:35,919 --> 00:33:39,440
a circuit and you can see here that this

00:33:37,760 --> 00:33:41,039
circuit is a lot simpler

00:33:39,440 --> 00:33:43,760
than the original one we started with

00:33:41,039 --> 00:33:45,360
there's a lot less operations

00:33:43,760 --> 00:33:47,440
because when you go through the

00:33:45,360 --> 00:33:51,519
simulation to the unitary

00:33:47,440 --> 00:33:53,679
and then um just the ideal

00:33:51,519 --> 00:33:54,799
synthesis of a circuit that represents

00:33:53,679 --> 00:33:57,519
that unitary

00:33:54,799 --> 00:33:59,600
it ends up often being less operations

00:33:57,519 --> 00:34:01,120
um

00:33:59,600 --> 00:34:03,760
especially if you imagine you had a very

00:34:01,120 --> 00:34:06,080
large two-qubit block in fact

00:34:03,760 --> 00:34:08,079
i was doing some benchmarking of a

00:34:06,080 --> 00:34:09,040
circuit once that operated on solely two

00:34:08,079 --> 00:34:10,960
qubits

00:34:09,040 --> 00:34:12,879
and i ran it through and i was testing

00:34:10,960 --> 00:34:15,440
things and i saw that um

00:34:12,879 --> 00:34:16,320
you know optimization level zero through

00:34:15,440 --> 00:34:19,359
two

00:34:16,320 --> 00:34:21,440
you know several thousand gates that the

00:34:19,359 --> 00:34:22,879
compiler was outputting and when i ran

00:34:21,440 --> 00:34:25,440
level three

00:34:22,879 --> 00:34:26,720
it ended up with seven and i was um lost

00:34:25,440 --> 00:34:28,240
for a while until i remembered that

00:34:26,720 --> 00:34:31,760
optimization level three

00:34:28,240 --> 00:34:33,599
uses consolidate blocks um as part of it

00:34:31,760 --> 00:34:34,879
but it was i thought for a while we had

00:34:33,599 --> 00:34:36,720
a like a really

00:34:34,879 --> 00:34:39,040
terrible bug in the compiler because it

00:34:36,720 --> 00:34:41,440
was i didn't think you could optimize it

00:34:39,040 --> 00:34:41,440
that much

00:34:41,679 --> 00:34:44,879
another interesting optimization pass to

00:34:43,839 --> 00:34:47,599
look at is

00:34:44,879 --> 00:34:48,000
the optimize one qubit operations pass

00:34:47,599 --> 00:34:51,760
this is

00:34:48,000 --> 00:34:52,320
similar to the um the consolidate blocks

00:34:51,760 --> 00:34:54,879
pass but

00:34:52,320 --> 00:34:55,760
all it does is it basically looks for

00:34:54,879 --> 00:34:57,680
runs of

00:34:55,760 --> 00:34:59,599
solely one qubit operations on a single

00:34:57,680 --> 00:35:02,160
qubit in the dag so it just traverses

00:34:59,599 --> 00:35:03,920
the dag and tries to find all series of

00:35:02,160 --> 00:35:05,920
operations that are isolated to a single

00:35:03,920 --> 00:35:07,440
qubit and then it pulls out that run so

00:35:05,920 --> 00:35:11,760
here's an example of one that's

00:35:07,440 --> 00:35:11,760
just four one qubit operations in a row

00:35:12,320 --> 00:35:17,520
and then it looks at the

00:35:15,680 --> 00:35:19,119
it assumes we started a zero state and

00:35:17,520 --> 00:35:21,040
it just looks at what the end state is

00:35:19,119 --> 00:35:23,599
going to be

00:35:21,040 --> 00:35:24,640
and it replaces that with a single gate

00:35:23,599 --> 00:35:27,119
that goes from the start

00:35:24,640 --> 00:35:28,320
to the end um whatever that is in this

00:35:27,119 --> 00:35:30,480
case it would be

00:35:28,320 --> 00:35:32,000
just a u rotation like that along each

00:35:30,480 --> 00:35:35,200
each of the axes

00:35:32,000 --> 00:35:37,760
um but

00:35:35,200 --> 00:35:39,440
you can calculate this doing uh two

00:35:37,760 --> 00:35:40,800
different methods you can either if you

00:35:39,440 --> 00:35:42,880
if you're doing it with angles you can

00:35:40,800 --> 00:35:44,640
use quaternions just like um

00:35:42,880 --> 00:35:46,720
video games actually to like track

00:35:44,640 --> 00:35:48,400
rotations in three-dimensional space

00:35:46,720 --> 00:35:50,000
or you can do the linear algebra and do

00:35:48,400 --> 00:35:53,119
the matrix multiplication

00:35:50,000 --> 00:35:53,520
and then do a circuit synthesis like we

00:35:53,119 --> 00:35:56,640
do

00:35:53,520 --> 00:35:56,640
for collect blocks

00:35:57,599 --> 00:36:01,599
in in kiskit we used to use the

00:35:59,839 --> 00:36:02,720
quaternion approach but we moved to the

00:36:01,599 --> 00:36:06,160
more general

00:36:02,720 --> 00:36:08,000
uh linear algebra approach um as we

00:36:06,160 --> 00:36:10,000
actually as ibm change their base escape

00:36:08,000 --> 00:36:11,680
because it um

00:36:10,000 --> 00:36:14,560
as ibm employees we get kind of

00:36:11,680 --> 00:36:18,560
incentivized to make things perform best

00:36:14,560 --> 00:36:18,560
as best as we can on the ibm devices

00:36:20,640 --> 00:36:26,160
so that was all i had on passes i wanted

00:36:24,400 --> 00:36:27,359
to talk about it i'm just giving a feel

00:36:26,160 --> 00:36:28,640
for

00:36:27,359 --> 00:36:30,560
some of the passes that are out there

00:36:28,640 --> 00:36:33,599
but one thing i wanted to end

00:36:30,560 --> 00:36:37,119
the conversation talking about is

00:36:33,599 --> 00:36:39,359
um why is this important

00:36:37,119 --> 00:36:40,880
so here i wanted to talk about something

00:36:39,359 --> 00:36:44,320
called quantum volume

00:36:40,880 --> 00:36:46,560
which is the metric with which ibm and

00:36:44,320 --> 00:36:48,000
most other companies out there use to

00:36:46,560 --> 00:36:51,200
measure the performance

00:36:48,000 --> 00:36:54,480
of various quantum computers

00:36:51,200 --> 00:36:58,640
um all quantum volume does it uh

00:36:54,480 --> 00:37:00,880
says you generate a series of random

00:36:58,640 --> 00:37:01,760
two-qubit unitary matrices and you apply

00:37:00,880 --> 00:37:04,960
them

00:37:01,760 --> 00:37:08,000
like across every qubit multiple times

00:37:04,960 --> 00:37:10,880
um and it's designed to be

00:37:08,000 --> 00:37:12,240
very difficult for a quantum computer um

00:37:10,880 --> 00:37:14,160
especially modern ones with all of the

00:37:12,240 --> 00:37:17,359
limitations we talked about

00:37:14,160 --> 00:37:18,960
um especially with limited connectivity

00:37:17,359 --> 00:37:20,320
and things like that

00:37:18,960 --> 00:37:22,480
and that's where a compiler comes in

00:37:20,320 --> 00:37:24,640
because you run the same circuit

00:37:22,480 --> 00:37:26,960
um and you have a better compiler you

00:37:24,640 --> 00:37:30,400
can get way better results

00:37:26,960 --> 00:37:32,400
um and it's it's actually really

00:37:30,400 --> 00:37:34,320
rewarding for me personally to

00:37:32,400 --> 00:37:36,960
to look at something like this and see

00:37:34,320 --> 00:37:38,800
that the you know i'm working on

00:37:36,960 --> 00:37:40,720
dags and other computer science concepts

00:37:38,800 --> 00:37:41,920
i'm not a an expert in quantum

00:37:40,720 --> 00:37:45,280
information theory

00:37:41,920 --> 00:37:47,599
but i can see that like the work i do

00:37:45,280 --> 00:37:49,200
on like the compiler optimization has a

00:37:47,599 --> 00:37:52,800
direct impact on

00:37:49,200 --> 00:37:54,480
how how the how

00:37:52,800 --> 00:37:56,640
how the circuits we can run on these

00:37:54,480 --> 00:37:59,200
devices uh

00:37:56,640 --> 00:38:01,520
perform and how we if you know we make a

00:37:59,200 --> 00:38:04,079
good improvement to the compiler

00:38:01,520 --> 00:38:05,280
we can use the devices that exist today

00:38:04,079 --> 00:38:09,839
for more

00:38:05,280 --> 00:38:13,280
um so with that that is all of the

00:38:09,839 --> 00:38:14,800
prepared material i had um i'm open to

00:38:13,280 --> 00:38:15,839
taking questions now

00:38:14,800 --> 00:38:18,079
although i'm not sure how that's going

00:38:15,839 --> 00:38:20,640
to work with pre-recorded talk

00:38:18,079 --> 00:38:22,240
hopefully i'm awake for answering

00:38:20,640 --> 00:38:24,480
questions at least 1am is a bit

00:38:22,240 --> 00:38:26,480
difficult for me with my normal schedule

00:38:24,480 --> 00:38:28,160
i have some links here for more

00:38:26,480 --> 00:38:29,599
information including the link to the

00:38:28,160 --> 00:38:31,760
slides

00:38:29,599 --> 00:38:33,200
as well as the github for kitera the

00:38:31,760 --> 00:38:34,560
kiskit website

00:38:33,200 --> 00:38:37,119
one thing you might be interested in

00:38:34,560 --> 00:38:39,920
doing is signing up for

00:38:37,119 --> 00:38:41,839
access to the quantum computers forget

00:38:39,920 --> 00:38:42,480
the exact number it's like five to ten

00:38:41,839 --> 00:38:44,720
but

00:38:42,480 --> 00:38:47,119
a large subset of the quantum computers

00:38:44,720 --> 00:38:48,560
that ibm has available

00:38:47,119 --> 00:38:49,920
are available to the general public if

00:38:48,560 --> 00:38:51,200
you sign up for an account so you can

00:38:49,920 --> 00:38:54,320
submit jobs

00:38:51,200 --> 00:38:56,640
um to the quantum computers and then

00:38:54,320 --> 00:38:59,680
some more information on the transpiler

00:38:56,640 --> 00:39:00,320
and if you're interested in uh quantum

00:38:59,680 --> 00:39:03,040
information

00:39:00,320 --> 00:39:04,640
i have a link to um a talk i gave on

00:39:03,040 --> 00:39:05,760
open source quantum computing a couple

00:39:04,640 --> 00:39:07,520
years ago

00:39:05,760 --> 00:39:09,119
and then also the kiz kit textbook which

00:39:07,520 --> 00:39:12,079
is an open source textbook

00:39:09,119 --> 00:39:14,079
for um learning about quantum computing

00:39:12,079 --> 00:39:15,599
it starts assuming no knowledge it'll

00:39:14,079 --> 00:39:17,200
start with the linear algebra that you

00:39:15,599 --> 00:39:18,480
need to understand and

00:39:17,200 --> 00:39:20,240
work its way through some very

00:39:18,480 --> 00:39:24,400
complicated examples

00:39:20,240 --> 00:39:29,359
um so thank you for listening to me

00:39:24,400 --> 00:39:29,359

YouTube URL: https://www.youtube.com/watch?v=tviemvEWhps


