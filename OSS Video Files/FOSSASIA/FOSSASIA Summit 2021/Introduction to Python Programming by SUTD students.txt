Title: Introduction to Python Programming by SUTD students
Publication date: 2021-03-25
Playlist: FOSSASIA Summit 2021
Description: 
	In this session we will cover
- Programming using Python  
- Use of Command Line Interface
- Use of Git & GitHub Web Scraping
- Build your first API
- Build your first Web App
- Deploy your Web App
Captions: 
	00:00:00,000 --> 00:00:04,159
talking about python and

00:00:05,600 --> 00:00:11,759
so firstly to

00:00:08,720 --> 00:00:12,320
write code in python right you need to

00:00:11,759 --> 00:00:15,040
have an

00:00:12,320 --> 00:00:15,839
ide or a text editor to write python

00:00:15,040 --> 00:00:19,039
code

00:00:15,839 --> 00:00:20,160
so there are two requirements that you

00:00:19,039 --> 00:00:23,760
need to download

00:00:20,160 --> 00:00:26,880
so you can click on these links and

00:00:23,760 --> 00:00:29,119
you can sign the download so the first

00:00:26,880 --> 00:00:30,880
thing is python itself if you

00:00:29,119 --> 00:00:32,480
click on the link you will be taken to

00:00:30,880 --> 00:00:35,600
the python website

00:00:32,480 --> 00:00:38,559
where you can download and install

00:00:35,600 --> 00:00:38,559
uh python

00:00:40,160 --> 00:00:44,719
so you go to this website you click

00:00:42,000 --> 00:00:48,800
download python 3.9.2

00:00:44,719 --> 00:00:50,879
then you save

00:00:48,800 --> 00:00:52,000
save it to any place on your computer

00:00:50,879 --> 00:00:53,920
and then you run

00:00:52,000 --> 00:00:55,039
and you follow through the steps that it

00:00:53,920 --> 00:00:58,800
shows you

00:00:55,039 --> 00:01:02,800
so you can install python

00:00:58,800 --> 00:01:05,280
and then after installing python uh

00:01:02,800 --> 00:01:06,159
yeah actually let's take a minute to

00:01:05,280 --> 00:01:10,240
have everyone

00:01:06,159 --> 00:01:10,240
install python if you don't already have

00:01:10,840 --> 00:01:13,840
it

00:01:24,840 --> 00:01:27,840
yes

00:01:52,840 --> 00:01:55,840
um

00:02:34,840 --> 00:02:37,840
okay

00:02:48,879 --> 00:02:53,440
so uh what you have to do is once you've

00:02:52,160 --> 00:02:56,560
installed python

00:02:53,440 --> 00:02:58,879
you can also install uh vs code

00:02:56,560 --> 00:03:00,640
so since you already have yes you don't

00:02:58,879 --> 00:03:04,800
need to do that but the others

00:03:00,640 --> 00:03:08,000
will so you go to this second page

00:03:04,800 --> 00:03:09,920
and you can download vs code and you can

00:03:08,000 --> 00:03:13,680
pick

00:03:09,920 --> 00:03:16,560
whichever version of windows you have

00:03:13,680 --> 00:03:16,560
or linux

00:03:16,800 --> 00:03:20,080
if you don't know which version of

00:03:18,400 --> 00:03:23,519
windows you have

00:03:20,080 --> 00:03:25,760
um you can i mean

00:03:23,519 --> 00:03:27,440
uh which version of the news you just

00:03:25,760 --> 00:03:30,319
click this one and i

00:03:27,440 --> 00:03:31,840
i think the website will figure it out

00:03:30,319 --> 00:03:33,599
for you so

00:03:31,840 --> 00:03:35,200
if you know which one it is then yeah

00:03:33,599 --> 00:03:47,840
you can go with a specific one

00:03:35,200 --> 00:03:47,840
so either it's fine

00:04:26,840 --> 00:04:29,840
okay

00:04:54,639 --> 00:04:59,840
once you have a vs code installed you

00:04:57,199 --> 00:04:59,840
can proceed

00:05:01,039 --> 00:05:11,840
oh okay that's also okay that's okay you

00:05:03,199 --> 00:05:11,840
can use any id of your choice

00:05:36,000 --> 00:05:42,560
okay so i'll proceed uh once you have

00:05:39,280 --> 00:05:46,400
your id setup and python installed

00:05:42,560 --> 00:05:50,000
uh he'll actually start with the

00:05:46,400 --> 00:05:52,880
uh session and so

00:05:50,000 --> 00:05:53,280
the first thing that i'm going to talk

00:05:52,880 --> 00:05:55,440
about

00:05:53,280 --> 00:05:57,440
is like the very basic thing that you

00:05:55,440 --> 00:06:00,800
need to know about python

00:05:57,440 --> 00:06:01,680
is constants so to do anything in a

00:06:00,800 --> 00:06:05,120
program right

00:06:01,680 --> 00:06:07,600
you need constants and any value

00:06:05,120 --> 00:06:08,880
that remains the same throughout the

00:06:07,600 --> 00:06:11,199
execution of the program

00:06:08,880 --> 00:06:13,039
is known as a constant it literally is a

00:06:11,199 --> 00:06:17,600
constant it doesn't change

00:06:13,039 --> 00:06:18,240
okay and for for example like 10 is a

00:06:17,600 --> 00:06:20,560
constant

00:06:18,240 --> 00:06:22,080
every number would be a constant because

00:06:20,560 --> 00:06:25,600
numbers don't change

00:06:22,080 --> 00:06:28,720
uh then we have variables

00:06:25,600 --> 00:06:31,120
and variables are like

00:06:28,720 --> 00:06:31,919
boxes that you use to store constants

00:06:31,120 --> 00:06:34,080
inside

00:06:31,919 --> 00:06:35,199
so it's it's a container that you can

00:06:34,080 --> 00:06:37,199
put one constant

00:06:35,199 --> 00:06:39,199
into and then you can take it out and

00:06:37,199 --> 00:06:42,000
put another one in if you wanted to

00:06:39,199 --> 00:06:43,120
change it so a variable is is the value

00:06:42,000 --> 00:06:44,639
that can change

00:06:43,120 --> 00:06:46,160
during the execution of the program

00:06:44,639 --> 00:06:47,840
because remember it's like a box you can

00:06:46,160 --> 00:06:48,720
put something in you can take something

00:06:47,840 --> 00:06:51,520
out

00:06:48,720 --> 00:06:53,440
and you can change it as many times as

00:06:51,520 --> 00:06:56,560
you like

00:06:53,440 --> 00:07:01,039
and here is an example of

00:06:56,560 --> 00:07:04,160
using variables so i have

00:07:01,039 --> 00:07:07,360
a equals to 10 so a is my

00:07:04,160 --> 00:07:08,560
uh variable name and like abc are my

00:07:07,360 --> 00:07:13,520
three variables

00:07:08,560 --> 00:07:16,560
and a is 10 b is 20.5 and then i

00:07:13,520 --> 00:07:17,919
add a and b together and i assign them

00:07:16,560 --> 00:07:21,520
to c

00:07:17,919 --> 00:07:24,479
okay so to be able to see

00:07:21,520 --> 00:07:25,759
what these variables actually are the

00:07:24,479 --> 00:07:28,880
value of the variables

00:07:25,759 --> 00:07:31,599
we need to print them to the screen so

00:07:28,880 --> 00:07:32,000
you use this function called the print

00:07:31,599 --> 00:07:34,000
and

00:07:32,000 --> 00:07:35,199
you write the name of the variable

00:07:34,000 --> 00:07:38,800
inside and it'll

00:07:35,199 --> 00:07:41,599
show you the value variable so you can

00:07:38,800 --> 00:07:42,720
use the button to copy the code if you

00:07:41,599 --> 00:07:44,960
want to

00:07:42,720 --> 00:07:46,080
test it and you can place it into your

00:07:44,960 --> 00:07:49,199
ide

00:07:46,080 --> 00:07:52,800
and if you're using vs code

00:07:49,199 --> 00:07:56,400
then after you paste

00:07:52,800 --> 00:07:58,879
the code into your ide i see

00:07:56,400 --> 00:07:59,440
you will need to write the code in a

00:07:58,879 --> 00:08:02,800
file

00:07:59,440 --> 00:08:05,039
called a python file so basically

00:08:02,800 --> 00:08:05,919
you can make a python file by making a

00:08:05,039 --> 00:08:09,280
new file

00:08:05,919 --> 00:08:10,400
and then you can write any name that you

00:08:09,280 --> 00:08:14,400
want here

00:08:10,400 --> 00:08:16,479
and the extension should be a dot py so

00:08:14,400 --> 00:08:17,440
when you create a text file it will have

00:08:16,479 --> 00:08:19,199
dot txt

00:08:17,440 --> 00:08:20,479
but you will need to change it to pi for

00:08:19,199 --> 00:08:24,720
it to work

00:08:20,479 --> 00:08:27,919
uh in case you don't see your extensions

00:08:24,720 --> 00:08:28,400
then you will have to click view at the

00:08:27,919 --> 00:08:31,919
top

00:08:28,400 --> 00:08:33,120
there and then click on this checkbox

00:08:31,919 --> 00:08:36,080
which says

00:08:33,120 --> 00:08:38,320
file name extensions so if i remove that

00:08:36,080 --> 00:08:40,000
then you see the extensions disappear

00:08:38,320 --> 00:08:42,560
so if you don't see your extensions you

00:08:40,000 --> 00:08:55,839
need to click that for them to appear

00:08:42,560 --> 00:08:55,839
okay yes

00:09:06,839 --> 00:09:09,839
okay

00:09:34,839 --> 00:09:37,839
okay

00:10:02,839 --> 00:10:05,839
hello

00:10:16,839 --> 00:10:19,839
okay

00:10:44,839 --> 00:10:47,839
okay

00:11:12,839 --> 00:11:15,839
hmm

00:11:26,839 --> 00:11:29,839
so

00:11:39,680 --> 00:11:46,240
okay so once you have your code

00:11:43,120 --> 00:11:49,279
pasted into the code

00:11:46,240 --> 00:11:53,120
you can type in the folder that

00:11:49,279 --> 00:11:53,680
the code is in and once you're inside a

00:11:53,120 --> 00:11:57,920
folder

00:11:53,680 --> 00:12:01,600
you can go to

00:11:57,920 --> 00:12:04,639
the you you click on the on the

00:12:01,600 --> 00:12:05,920
path of the folder and you type cmd and

00:12:04,639 --> 00:12:08,480
that will bring up

00:12:05,920 --> 00:12:09,680
command prompt and this is what we'll

00:12:08,480 --> 00:12:14,560
use to run the

00:12:09,680 --> 00:12:14,560
code for python okay so

00:12:16,240 --> 00:12:20,560
if you have any questions uh regarding

00:12:19,040 --> 00:12:24,639
how to open the command prompt

00:12:20,560 --> 00:12:28,560
please let me know

00:12:24,639 --> 00:12:31,279
so you can open uh your folder in which

00:12:28,560 --> 00:12:39,839
the python file is located and then

00:12:31,279 --> 00:12:39,839
use cmd

00:12:50,839 --> 00:12:53,839
okay

00:13:04,839 --> 00:13:07,839
um

00:13:41,839 --> 00:13:46,959
uh yes so you

00:13:45,120 --> 00:13:48,240
you go to the folder in which your

00:13:46,959 --> 00:13:51,440
python file is

00:13:48,240 --> 00:13:53,760
located in so for me that's

00:13:51,440 --> 00:13:54,880
this folder so once you have your folder

00:13:53,760 --> 00:13:58,160
open

00:13:54,880 --> 00:13:58,800
you click the path of the folder at the

00:13:58,160 --> 00:14:02,160
top

00:13:58,800 --> 00:14:04,160
this space it says this pc desktop

00:14:02,160 --> 00:14:07,360
python or it can be different for you

00:14:04,160 --> 00:14:07,839
but you click here and type cmd and then

00:14:07,360 --> 00:14:11,920
you press

00:14:07,839 --> 00:14:11,920
enter and it will bring up the command

00:14:14,839 --> 00:14:17,839
prompt

00:14:34,160 --> 00:14:39,440
okay so once you have the command prompt

00:14:36,720 --> 00:14:42,880
you can paste the code into vsc

00:14:39,440 --> 00:14:45,839
save the file and then to run the code

00:14:42,880 --> 00:14:46,399
you type python and then a name of the

00:14:45,839 --> 00:14:49,760
file

00:14:46,399 --> 00:14:52,240
so for me is test dot py

00:14:49,760 --> 00:14:53,120
so i'll type that and when i type that

00:14:52,240 --> 00:14:57,120
it'll

00:14:53,120 --> 00:15:00,320
run whatever code i had in this file

00:14:57,120 --> 00:15:03,680
so in this particular

00:15:00,320 --> 00:15:06,320
program i just went over it it's i'm

00:15:03,680 --> 00:15:07,760
taking two variables that are assigned

00:15:06,320 --> 00:15:10,320
to 10 and 20

00:15:07,760 --> 00:15:12,399
and then i add them and assign them to a

00:15:10,320 --> 00:15:15,920
variable called c and then i print

00:15:12,399 --> 00:15:18,800
the value to the screen then i reassign

00:15:15,920 --> 00:15:21,920
i subtract a from me and then i reassign

00:15:18,800 --> 00:15:23,760
it to c and then i print it again

00:15:21,920 --> 00:15:25,040
so first i add them together i print

00:15:23,760 --> 00:15:27,839
them and then i subtract them

00:15:25,040 --> 00:15:27,839
and then print them

00:15:28,959 --> 00:15:32,320
okay so uh

00:15:35,040 --> 00:15:40,560
you can also so these are storing

00:15:38,079 --> 00:15:41,680
numbers right you can also if you want

00:15:40,560 --> 00:15:44,160
to store

00:15:41,680 --> 00:15:45,360
a word or a sentence you can also do

00:15:44,160 --> 00:15:49,440
that

00:15:45,360 --> 00:15:52,720
and you use uh

00:15:49,440 --> 00:15:53,440
double quotes to write a word so when

00:15:52,720 --> 00:15:55,600
you

00:15:53,440 --> 00:15:57,519
when you want to write a word or phrase

00:15:55,600 --> 00:16:00,959
or a sentence then

00:15:57,519 --> 00:16:03,199
you uh you use your variable and you

00:16:00,959 --> 00:16:05,120
assign

00:16:03,199 --> 00:16:06,639
the value and you whatever word or

00:16:05,120 --> 00:16:08,800
phrase that you want the variable to

00:16:06,639 --> 00:16:12,639
have you put double quotes around it

00:16:08,800 --> 00:16:15,680
okay so

00:16:12,639 --> 00:16:19,040
if i now run this program

00:16:15,680 --> 00:16:23,279
it'll print out the value that i typed

00:16:19,040 --> 00:16:24,560
in here and these sentences or phrases

00:16:23,279 --> 00:16:27,920
or words that i type

00:16:24,560 --> 00:16:33,519
in a program they're known as strings so

00:16:27,920 --> 00:16:33,519
this variable a is known as a string

00:16:34,839 --> 00:16:37,839
okay

00:16:39,759 --> 00:16:44,000
you can also make lists with python so

00:16:42,240 --> 00:16:47,519
if you

00:16:44,000 --> 00:16:49,199
want to store multiple variables

00:16:47,519 --> 00:16:51,040
or multiple constants in the same

00:16:49,199 --> 00:16:54,480
variable then

00:16:51,040 --> 00:16:57,839
you use this kind of a notation and you

00:16:54,480 --> 00:16:59,759
write square brackets and then you

00:16:57,839 --> 00:17:01,680
type your values in and you separate

00:16:59,759 --> 00:17:05,839
them with a comma and that makes a list

00:17:01,680 --> 00:17:05,839
in python

00:17:14,720 --> 00:17:20,079
so every variable

00:17:18,000 --> 00:17:21,360
right remember they like boxes that

00:17:20,079 --> 00:17:24,959
store values

00:17:21,360 --> 00:17:27,520
so uh every different

00:17:24,959 --> 00:17:29,120
type of value that you want to store

00:17:27,520 --> 00:17:33,200
requires a different

00:17:29,120 --> 00:17:47,679
type of container to be stored in

00:17:33,200 --> 00:17:50,880
so if you yes

00:17:47,679 --> 00:17:52,480
no in python you don't they don't have

00:17:50,880 --> 00:17:53,120
to be the same data type so if i

00:17:52,480 --> 00:17:55,360
actually

00:17:53,120 --> 00:17:56,160
run this one it doesn't give me any

00:17:55,360 --> 00:17:59,520
errors

00:17:56,160 --> 00:18:03,760
look python you can have lists that have

00:17:59,520 --> 00:18:03,760
multiple data types in them

00:18:05,120 --> 00:18:08,559
so usually in any other programming

00:18:06,799 --> 00:18:11,440
language like java

00:18:08,559 --> 00:18:15,840
you not allowed to do this but in python

00:18:11,440 --> 00:18:15,840
you can

00:18:20,240 --> 00:18:27,919
so yeah so now you have variables

00:18:24,640 --> 00:18:29,840
like variables they they can store they

00:18:27,919 --> 00:18:30,720
store different types of values in them

00:18:29,840 --> 00:18:33,600
so you can store

00:18:30,720 --> 00:18:35,120
integers and you can store uh words and

00:18:33,600 --> 00:18:37,200
sentences and strings

00:18:35,120 --> 00:18:38,960
so each type of value that you want to

00:18:37,200 --> 00:18:40,960
store in a variable it requires

00:18:38,960 --> 00:18:42,640
a different type of variable it's just

00:18:40,960 --> 00:18:44,480
like if you want to store water right

00:18:42,640 --> 00:18:46,160
you can't store water in a plastic bag

00:18:44,480 --> 00:18:47,200
you need a water bottle to store water

00:18:46,160 --> 00:18:50,320
inside

00:18:47,200 --> 00:18:52,080
so every different type of value that

00:18:50,320 --> 00:18:53,520
you want to store requires a different

00:18:52,080 --> 00:18:57,360
type of variables

00:18:53,520 --> 00:18:58,480
and this formerly in python is known as

00:18:57,360 --> 00:19:01,919
a data type

00:18:58,480 --> 00:19:05,120
so uh your

00:19:01,919 --> 00:19:07,760
each of your variables has a data type

00:19:05,120 --> 00:19:08,320
associated with it which describes what

00:19:07,760 --> 00:19:11,679
kind of

00:19:08,320 --> 00:19:15,039
value it stores

00:19:11,679 --> 00:19:18,240
so there are uh

00:19:15,039 --> 00:19:20,720
there are uh about i think nine

00:19:18,240 --> 00:19:21,440
different data types in python seven of

00:19:20,720 --> 00:19:25,440
which

00:19:21,440 --> 00:19:27,840
uh uh covering uh for today

00:19:25,440 --> 00:19:29,600
because the uh remaining two are kind of

00:19:27,840 --> 00:19:31,440
out of the scope but

00:19:29,600 --> 00:19:32,880
uh these are the most commonly used data

00:19:31,440 --> 00:19:37,600
types anyway so it's

00:19:32,880 --> 00:19:40,799
uh okay so the first one is an integer

00:19:37,600 --> 00:19:43,440
so an integer quantity is

00:19:40,799 --> 00:19:44,320
any value that can be negative positive

00:19:43,440 --> 00:19:47,120
or zero

00:19:44,320 --> 00:19:47,840
so it doesn't have any fractions or

00:19:47,120 --> 00:19:51,360
decimal

00:19:47,840 --> 00:19:52,000
parts so it'll never have a 0.5 or a 0.4

00:19:51,360 --> 00:19:54,240
or something like

00:19:52,000 --> 00:19:54,240
that

00:19:56,240 --> 00:20:01,280
then you have floating point values so

00:19:59,840 --> 00:20:04,240
floating point values

00:20:01,280 --> 00:20:05,200
are values that can store fractional

00:20:04,240 --> 00:20:08,960
parts as well

00:20:05,200 --> 00:20:12,720
so you can have 1.5 or 2.5

00:20:08,960 --> 00:20:12,720
and those are all floating point values

00:20:16,080 --> 00:20:20,880
if you have any questions then please

00:20:18,840 --> 00:20:24,960
ask

00:20:20,880 --> 00:20:28,799
if not then i'll move on and you have

00:20:24,960 --> 00:20:33,440
boolean values so a boolean value

00:20:28,799 --> 00:20:36,880
is a data type that can store only two

00:20:33,440 --> 00:20:40,960
values either a true or a false

00:20:36,880 --> 00:20:43,200
so basically it's used for

00:20:40,960 --> 00:20:44,640
when a computer needs to answer a yes or

00:20:43,200 --> 00:20:47,760
no question so

00:20:44,640 --> 00:20:49,280
let's say i ask do you have a pen then

00:20:47,760 --> 00:20:51,120
you either have a pen or you don't have

00:20:49,280 --> 00:20:51,760
a pen so you either say yes or you say

00:20:51,120 --> 00:20:53,919
no

00:20:51,760 --> 00:20:55,440
so when a computer needs to answer yes

00:20:53,919 --> 00:20:58,559
or no question it uses

00:20:55,440 --> 00:21:00,840
a boolean data type so it can be either

00:20:58,559 --> 00:21:03,840
true or it can be either false

00:21:00,840 --> 00:21:06,320
so and boolean data types are

00:21:03,840 --> 00:21:07,360
quite important for com conditions and

00:21:06,320 --> 00:21:09,760
like all of

00:21:07,360 --> 00:21:12,799
programming so we'll be taking a look at

00:21:09,760 --> 00:21:12,799
conditions later on

00:21:14,240 --> 00:21:17,919
if you have any uh questions please uh

00:21:16,960 --> 00:21:20,960
ask

00:21:17,919 --> 00:21:24,640
and i'll move on and

00:21:20,960 --> 00:21:27,520
we just saw a string is also a data type

00:21:24,640 --> 00:21:29,520
in then it's any word or phrase and a

00:21:27,520 --> 00:21:30,799
string is always enclosed by double

00:21:29,520 --> 00:21:34,400
quotes

00:21:30,799 --> 00:21:37,280
you can also assign a string

00:21:34,400 --> 00:21:38,240
by enclosing it in single quotes in

00:21:37,280 --> 00:21:41,200
pattern

00:21:38,240 --> 00:21:42,559
and if you want to use a string that has

00:21:41,200 --> 00:21:45,679
multiple lines

00:21:42,559 --> 00:21:48,640
then you use triple ports to do that so

00:21:45,679 --> 00:21:50,480
you have triple ports you can either use

00:21:48,640 --> 00:21:53,200
double quotes or you can use single puts

00:21:50,480 --> 00:21:53,200
both of them

00:21:56,840 --> 00:21:59,840
work

00:22:03,039 --> 00:22:09,280
so uh when you have a string like you

00:22:06,240 --> 00:22:11,360
can if you let's say if you have a

00:22:09,280 --> 00:22:14,400
string and you want

00:22:11,360 --> 00:22:15,919
the fifth character of the string or the

00:22:14,400 --> 00:22:18,640
third character of the string

00:22:15,919 --> 00:22:19,760
you can do that by using what's called a

00:22:18,640 --> 00:22:22,880
subscript

00:22:19,760 --> 00:22:26,240
so if i have a string

00:22:22,880 --> 00:22:28,799
that's a and i see

00:22:26,240 --> 00:22:30,080
i want the first character of the string

00:22:28,799 --> 00:22:33,120
i write

00:22:30,080 --> 00:22:35,039
a with a subscript of 0

00:22:33,120 --> 00:22:36,400
and that gives me the first character

00:22:35,039 --> 00:22:40,080
why 0 and why not

00:22:36,400 --> 00:22:42,320
1 is because in programming in general

00:22:40,080 --> 00:22:46,159
in any programming languages right

00:22:42,320 --> 00:22:49,360
a list or any numbered uh

00:22:46,159 --> 00:22:52,720
or any ordered uh lists

00:22:49,360 --> 00:22:55,919
in programming it starts with zero it

00:22:52,720 --> 00:22:57,120
we never start with one so in a list or

00:22:55,919 --> 00:22:59,360
in a string

00:22:57,120 --> 00:23:01,600
or in any other data type you will

00:22:59,360 --> 00:23:05,520
always see that it starts with zero

00:23:01,600 --> 00:23:07,919
okay so zero is the first

00:23:05,520 --> 00:23:10,159
one is then the second character three

00:23:07,919 --> 00:23:12,159
or two is the third character three is

00:23:10,159 --> 00:23:15,039
the fourth character and so on

00:23:12,159 --> 00:23:15,039
does that make sense

00:23:17,039 --> 00:23:23,679
and in python right you can also have

00:23:20,159 --> 00:23:26,559
negative indexes so if you want to

00:23:23,679 --> 00:23:27,280
get let's say the last character of the

00:23:26,559 --> 00:23:30,400
string

00:23:27,280 --> 00:23:32,480
then you use an index of -1 so

00:23:30,400 --> 00:23:33,440
that tells python that i want the last

00:23:32,480 --> 00:23:36,559
index of this

00:23:33,440 --> 00:23:38,159
last character of the string and

00:23:36,559 --> 00:23:40,000
you can use minus 2 and that would be

00:23:38,159 --> 00:23:42,720
the second last character minus 3 would

00:23:40,000 --> 00:23:51,840
be the third last character and so on

00:23:42,720 --> 00:23:51,840
does that make sense

00:23:53,120 --> 00:23:58,000
well if you want to obtain

00:23:56,320 --> 00:23:59,600
a particular part of the string let's

00:23:58,000 --> 00:24:02,799
say if you want

00:23:59,600 --> 00:24:05,440
to obtain characters for

00:24:02,799 --> 00:24:06,640
two characters it then you can do that

00:24:05,440 --> 00:24:09,520
using

00:24:06,640 --> 00:24:10,400
what's called string slicing so this is

00:24:09,520 --> 00:24:12,640
the same

00:24:10,400 --> 00:24:16,000
as using substring in any other

00:24:12,640 --> 00:24:19,039
programming languages if you're familiar

00:24:16,000 --> 00:24:21,120
so you use uh

00:24:19,039 --> 00:24:23,200
slicing and use the same kind of

00:24:21,120 --> 00:24:26,640
notation that you do with indices

00:24:23,200 --> 00:24:31,360
and you say that

00:24:26,640 --> 00:24:35,200
if i have a string then writing this

00:24:31,360 --> 00:24:38,080
kind of a notation gives you

00:24:35,200 --> 00:24:38,559
uh it starts the string from the fourth

00:24:38,080 --> 00:24:40,799
uh

00:24:38,559 --> 00:24:42,400
or sorry the fifth character of the

00:24:40,799 --> 00:24:45,360
string and it ends at the

00:24:42,400 --> 00:24:46,000
ninth character of the string so you

00:24:45,360 --> 00:24:49,039
need to remember

00:24:46,000 --> 00:24:51,360
that it starts at zero and not one and

00:24:49,039 --> 00:24:52,159
the last character the string is not

00:24:51,360 --> 00:24:55,120
included

00:24:52,159 --> 00:24:57,520
in the result so if you do this with the

00:24:55,120 --> 00:24:57,520
string

00:24:58,840 --> 00:25:01,840
then

00:25:09,200 --> 00:25:15,679
this one will always start from this

00:25:12,480 --> 00:25:29,840
and end at this but it's not in the end

00:25:15,679 --> 00:25:29,840
is not included so does that make sense

00:25:30,400 --> 00:25:35,200
and if you wanted to uh take a part of a

00:25:32,960 --> 00:25:36,960
string that starts at some point but

00:25:35,200 --> 00:25:39,279
ends at the end of the original string

00:25:36,960 --> 00:25:42,480
then you can just omit the last number

00:25:39,279 --> 00:25:44,240
the second number and it'll start at the

00:25:42,480 --> 00:25:46,159
fourth character of the string and it'll

00:25:44,240 --> 00:25:48,159
end you just don't say

00:25:46,159 --> 00:25:49,600
you you don't specify where it has to

00:25:48,159 --> 00:25:50,880
end and you'll take the rest of the

00:25:49,600 --> 00:25:55,760
entire string

00:25:50,880 --> 00:26:00,000
so uh this one would

00:25:55,760 --> 00:26:03,039
um start from the

00:26:00,000 --> 00:26:04,240
it starts from the starts from the

00:26:03,039 --> 00:26:07,440
fourth character and

00:26:04,240 --> 00:26:09,679
goes all the way to the end so

00:26:07,440 --> 00:26:10,799
the fourth character for this string is

00:26:09,679 --> 00:26:14,640
s and so it

00:26:10,799 --> 00:26:14,640
you get this part of the string

00:26:20,000 --> 00:26:25,520
and if you want to take a part of the

00:26:23,200 --> 00:26:27,679
string that starts at the

00:26:25,520 --> 00:26:28,559
uh that starts at the beginning and ends

00:26:27,679 --> 00:26:30,320
at a point

00:26:28,559 --> 00:26:32,080
before the end of the string then you

00:26:30,320 --> 00:26:35,760
can omit the initial value

00:26:32,080 --> 00:26:37,600
of the substrip and you'll get

00:26:35,760 --> 00:26:38,960
you'll get a string that starts at the

00:26:37,600 --> 00:26:43,840
beginning and ends

00:26:38,960 --> 00:26:47,520
at whichever position you specify so

00:26:43,840 --> 00:26:49,679
this one starts at

00:26:47,520 --> 00:26:50,720
zero and then it ends at the sixth

00:26:49,679 --> 00:26:54,960
character

00:26:50,720 --> 00:27:07,840
so it takes this much of the string

00:26:54,960 --> 00:27:07,840
that makes sense

00:27:12,559 --> 00:27:19,520
okay so uh you in python you can also

00:27:17,120 --> 00:27:21,279
if you want to pick particular

00:27:19,520 --> 00:27:23,760
characters from the string

00:27:21,279 --> 00:27:25,360
in a particular interval so let's say

00:27:23,760 --> 00:27:27,200
you want to pick the first character

00:27:25,360 --> 00:27:28,960
then skip two characters pick the third

00:27:27,200 --> 00:27:30,000
one skip another two characters pick the

00:27:28,960 --> 00:27:33,679
sixth one

00:27:30,000 --> 00:27:37,039
then you can do that by uh

00:27:33,679 --> 00:27:40,480
by specifying a third number in your

00:27:37,039 --> 00:27:43,679
uh string slicing and this one

00:27:40,480 --> 00:27:45,279
it'll start at the it'll start at the

00:27:43,679 --> 00:27:48,000
third character of the string

00:27:45,279 --> 00:27:48,960
and it'll go till the 10th character of

00:27:48,000 --> 00:27:51,440
the string and it will

00:27:48,960 --> 00:27:52,640
skip every two characters so when you do

00:27:51,440 --> 00:27:55,919
this

00:27:52,640 --> 00:28:00,640
you will get the

00:27:55,919 --> 00:28:03,440
third character then the sixth character

00:28:00,640 --> 00:28:04,000
then you will get the ninth character

00:28:03,440 --> 00:28:06,000
and

00:28:04,000 --> 00:28:07,200
then it will end because you specify the

00:28:06,000 --> 00:28:11,120
end has to be at the

00:28:07,200 --> 00:28:11,120
tenth character does that make sense

00:28:13,440 --> 00:28:18,960
and you can actually this is quite

00:28:16,720 --> 00:28:20,640
uh powerful because you can use negative

00:28:18,960 --> 00:28:23,840
uh values

00:28:20,640 --> 00:28:24,720
here as well and if you use uh if you

00:28:23,840 --> 00:28:27,039
don't specify

00:28:24,720 --> 00:28:29,840
any values for the start and the end and

00:28:27,039 --> 00:28:32,240
you use minus one for the third value

00:28:29,840 --> 00:28:34,799
the entire string will get reversed

00:28:32,240 --> 00:28:35,520
so it's the same string but it starts at

00:28:34,799 --> 00:28:39,440
the end

00:28:35,520 --> 00:28:45,840
and goes all the way back so you you get

00:28:39,440 --> 00:28:45,840
the string but it's actually reversed

00:28:51,520 --> 00:28:55,200
and lastly with things if you want to

00:28:54,080 --> 00:28:57,200
know how long

00:28:55,200 --> 00:28:59,039
a particular string is is how many

00:28:57,200 --> 00:29:01,440
characters the string has

00:28:59,039 --> 00:29:02,559
and you can use the line function in

00:29:01,440 --> 00:29:04,880
python

00:29:02,559 --> 00:29:06,960
and it gives you the length of the

00:29:04,880 --> 00:29:13,840
string so for this one

00:29:06,960 --> 00:29:13,840
it has a length of 24 characters

00:29:17,120 --> 00:29:20,640
okay and if you ever have any questions

00:29:19,600 --> 00:29:24,000
please ask

00:29:20,640 --> 00:29:27,360
and um yeah

00:29:24,000 --> 00:29:30,159
if you uh the the best way

00:29:27,360 --> 00:29:31,279
to you know learn these things is to try

00:29:30,159 --> 00:29:33,120
it yourself so

00:29:31,279 --> 00:29:34,320
if you ever find that you don't

00:29:33,120 --> 00:29:36,880
understand something

00:29:34,320 --> 00:29:38,000
you should always copy the code that is

00:29:36,880 --> 00:29:40,000
provided here

00:29:38,000 --> 00:29:41,679
and then try it out for yourself like

00:29:40,000 --> 00:29:43,360
write and play around with the code a

00:29:41,679 --> 00:29:45,760
little bit change the values

00:29:43,360 --> 00:29:47,039
see how the code behaves and if you

00:29:45,760 --> 00:29:52,000
still can't figure it out you

00:29:47,039 --> 00:29:54,960
always ask questions so we'll move on

00:29:52,000 --> 00:29:55,760
uh you can join multiple strings

00:29:54,960 --> 00:29:59,200
together

00:29:55,760 --> 00:30:01,120
to form one string and

00:29:59,200 --> 00:30:03,120
uh this is known as a string

00:30:01,120 --> 00:30:06,840
concatenation so you just

00:30:03,120 --> 00:30:09,840
use a plus sign and it joins the strings

00:30:06,840 --> 00:30:09,840
together

00:30:10,080 --> 00:30:16,159
so i have uh my

00:30:13,520 --> 00:30:18,880
sentences in three different parts and i

00:30:16,159 --> 00:30:22,399
use the plus sign to join them together

00:30:18,880 --> 00:30:26,240
and i get the full sentence which is

00:30:22,399 --> 00:30:26,240
this is known as string concatenation

00:30:31,039 --> 00:30:36,960
okay so what would happen if you try to

00:30:34,559 --> 00:30:38,159
access a position of a string that is

00:30:36,960 --> 00:30:41,440
larger than its length

00:30:38,159 --> 00:30:44,720
so let's say here

00:30:41,440 --> 00:30:44,720
you um

00:30:45,360 --> 00:30:48,799
you try to access the 20th character of

00:30:48,080 --> 00:30:50,720
the string

00:30:48,799 --> 00:30:52,240
or the pretty first character the string

00:30:50,720 --> 00:30:53,679
but the string is not that long what

00:30:52,240 --> 00:30:55,919
would happen

00:30:53,679 --> 00:30:57,760
uh python would give you an error if you

00:30:55,919 --> 00:31:00,320
try to do this

00:30:57,760 --> 00:31:02,159
it will say that the string index is out

00:31:00,320 --> 00:31:04,480
of range

00:31:02,159 --> 00:31:04,480
sorry

00:31:19,919 --> 00:31:27,120
then we'll move on to lists

00:31:24,000 --> 00:31:29,840
and lists is basically a list is an

00:31:27,120 --> 00:31:32,799
ordered collection of different

00:31:29,840 --> 00:31:33,760
constants or variables and each member

00:31:32,799 --> 00:31:35,840
of a list

00:31:33,760 --> 00:31:37,120
is formerly known as an element of that

00:31:35,840 --> 00:31:41,039
list so

00:31:37,120 --> 00:31:44,240
for example this is a list and

00:31:41,039 --> 00:31:46,960
it it has numbers it has

00:31:44,240 --> 00:31:48,399
floating point values has strings it has

00:31:46,960 --> 00:31:51,279
it even has another list

00:31:48,399 --> 00:31:53,360
inside so a list can have other lists

00:31:51,279 --> 00:31:56,480
inside of it as well

00:31:53,360 --> 00:32:00,960
and each

00:31:56,480 --> 00:32:03,279
value of a list gets assigned an index

00:32:00,960 --> 00:32:04,320
like just like a string so the first

00:32:03,279 --> 00:32:07,200
value which is 2

00:32:04,320 --> 00:32:09,600
is in index 0 the second value which is

00:32:07,200 --> 00:32:12,320
3.4 is index 1

00:32:09,600 --> 00:32:13,039
the third value which is this is a list

00:32:12,320 --> 00:32:16,880
the string

00:32:13,039 --> 00:32:17,519
is index 2 and so on so every value in a

00:32:16,880 --> 00:32:20,320
list

00:32:17,519 --> 00:32:20,320
has an index

00:32:20,640 --> 00:32:24,480
and in general when you initialize a

00:32:23,440 --> 00:32:28,559
list right

00:32:24,480 --> 00:32:30,960
if the list is too long to fit in

00:32:28,559 --> 00:32:32,240
in one line like this it's not easy to

00:32:30,960 --> 00:32:35,279
read the list right

00:32:32,240 --> 00:32:37,679
so a good practice is to write

00:32:35,279 --> 00:32:38,320
out the list with the elements separated

00:32:37,679 --> 00:32:41,279
out

00:32:38,320 --> 00:32:42,640
in multiple lines so you do this only

00:32:41,279 --> 00:32:44,240
when the original list

00:32:42,640 --> 00:32:45,760
is too long to read you don't need to do

00:32:44,240 --> 00:32:48,240
it all the time

00:32:45,760 --> 00:32:50,960
but it's good thing to do when is too

00:32:48,240 --> 00:32:54,799
long to read in one line

00:32:50,960 --> 00:32:56,240
so lists work similarly to how strings

00:32:54,799 --> 00:32:59,519
work in python so

00:32:56,240 --> 00:33:03,279
you can use indexes here to

00:32:59,519 --> 00:33:05,519
get the values of a string exactly this

00:33:03,279 --> 00:33:06,320
sorry get the values of a list exactly

00:33:05,519 --> 00:33:11,840
the same

00:33:06,320 --> 00:33:11,840
way that you use them on a string

00:33:12,960 --> 00:33:19,279
so you can yeah you use

00:33:16,799 --> 00:33:20,240
subscripts so 0 will give you the first

00:33:19,279 --> 00:33:22,880
element

00:33:20,240 --> 00:33:23,679
a minus 1 will get you the last element

00:33:22,880 --> 00:33:25,919
and

00:33:23,679 --> 00:33:27,279
the slicing also works exactly the same

00:33:25,919 --> 00:33:30,880
way so

00:33:27,279 --> 00:33:34,080
four colonnade will start at the

00:33:30,880 --> 00:33:37,679
fifth element of the list and it will

00:33:34,080 --> 00:33:41,519
end at the eighth element of the list

00:33:37,679 --> 00:33:44,960
okay so it works exactly

00:33:41,519 --> 00:33:44,960
like how a string works

00:33:49,279 --> 00:33:53,200
so if you want to combine two lists

00:33:52,559 --> 00:33:55,200
together

00:33:53,200 --> 00:33:57,600
you can two or more lists together you

00:33:55,200 --> 00:34:00,960
can use the plus

00:33:57,600 --> 00:34:04,159
operation and that gives you

00:34:00,960 --> 00:34:05,440
one big list it combines uh the smaller

00:34:04,159 --> 00:34:07,360
ones together and is

00:34:05,440 --> 00:34:10,480
it's exactly like how string strings

00:34:07,360 --> 00:34:13,919
work so if i

00:34:10,480 --> 00:34:13,919
copy this and run

00:34:15,040 --> 00:34:21,839
and i just get one list with all the six

00:34:18,839 --> 00:34:21,839
values

00:34:26,079 --> 00:34:31,200
hey if you want to add an element to a

00:34:28,480 --> 00:34:35,040
list you can do that using the append

00:34:31,200 --> 00:34:38,320
function of the list so uh

00:34:35,040 --> 00:34:41,359
when you use this it adds an element

00:34:38,320 --> 00:34:41,359
to the end of the list

00:34:42,320 --> 00:34:45,919
so now if i run this you see that c gets

00:34:45,040 --> 00:34:49,679
added to the

00:34:45,919 --> 00:34:52,480
original list so uh usually in

00:34:49,679 --> 00:34:52,960
java or other many programming languages

00:34:52,480 --> 00:34:55,359
you

00:34:52,960 --> 00:34:56,480
list they can't you can't change the

00:34:55,359 --> 00:34:58,800
size of a list

00:34:56,480 --> 00:34:59,520
so in python that's not the case in

00:34:58,800 --> 00:35:02,560
python

00:34:59,520 --> 00:35:05,119
you your list they can be of any like

00:35:02,560 --> 00:35:06,800
you can change the size of the list so

00:35:05,119 --> 00:35:09,359
they're not restricted

00:35:06,800 --> 00:35:10,079
to a particular size you can keep on

00:35:09,359 --> 00:35:12,800
adding

00:35:10,079 --> 00:35:17,839
more uh elements to the list if you

00:35:12,800 --> 00:35:17,839
wanted to so i can add

00:35:19,200 --> 00:35:24,480
and it'll work so

00:35:22,560 --> 00:35:25,599
yeah you can add as many elements to a

00:35:24,480 --> 00:35:28,839
list as you want

00:35:25,599 --> 00:35:30,640
it doesn't have to be off of fixed

00:35:28,839 --> 00:35:33,920
length

00:35:30,640 --> 00:35:37,440
and if you have two lists and um

00:35:33,920 --> 00:35:40,640
using the plus operation on the list

00:35:37,440 --> 00:35:42,240
you get a new list

00:35:40,640 --> 00:35:44,079
when you use the plus operation on the

00:35:42,240 --> 00:35:46,880
list you get a new list

00:35:44,079 --> 00:35:47,920
that's the that's combining all of the

00:35:46,880 --> 00:35:50,880
lists together but

00:35:47,920 --> 00:35:51,760
if you want to modify an existing list

00:35:50,880 --> 00:35:54,000
to

00:35:51,760 --> 00:35:55,040
have the additional values then you can

00:35:54,000 --> 00:35:57,359
use the append

00:35:55,040 --> 00:35:58,160
or sorry you can use the extend function

00:35:57,359 --> 00:36:02,079
of the list

00:35:58,160 --> 00:36:03,920
so you type a dot extend

00:36:02,079 --> 00:36:06,720
and then you type the name of the second

00:36:03,920 --> 00:36:10,320
list that you want to add to this so

00:36:06,720 --> 00:36:14,240
if i type b and then i write

00:36:10,320 --> 00:36:17,280
and then i print the value of a it'll be

00:36:14,240 --> 00:36:20,400
a and then it'll have

00:36:17,280 --> 00:36:24,839
the second list added to it as well

00:36:20,400 --> 00:36:27,839
so i get the four values

00:36:24,839 --> 00:36:27,839
okay

00:36:30,880 --> 00:36:36,000
and it works the same way when you try

00:36:34,000 --> 00:36:39,440
to access

00:36:36,000 --> 00:36:39,440
an element of a list that

00:36:39,599 --> 00:36:43,040
is out of the it's more than the length

00:36:42,320 --> 00:36:46,240
of the

00:36:43,040 --> 00:36:49,920
list so if you have a list

00:36:46,240 --> 00:36:53,599
uh of length four and you try to

00:36:49,920 --> 00:36:55,520
access an element that's

00:36:53,599 --> 00:36:56,960
not like it's it's longer than the

00:36:55,520 --> 00:36:58,640
length of the list and you get an error

00:36:56,960 --> 00:37:00,720
in python so

00:36:58,640 --> 00:37:03,440
it gives you index errors list in my

00:37:00,720 --> 00:37:03,440
sort of range

00:37:06,960 --> 00:37:14,560
yes exactly

00:37:10,800 --> 00:37:15,839
so append you can only give it one value

00:37:14,560 --> 00:37:18,240
and it'll add

00:37:15,839 --> 00:37:19,760
that as a single element to the list so

00:37:18,240 --> 00:37:23,200
if you give

00:37:19,760 --> 00:37:25,440
a pen a list right it'll work but

00:37:23,200 --> 00:37:27,280
it'll become another list inside the

00:37:25,440 --> 00:37:30,560
list so if i do

00:37:27,280 --> 00:37:34,800
append and i give it a list

00:37:30,560 --> 00:37:38,000
let's say um 10

00:37:34,800 --> 00:37:42,560
19 or 20 something like that and

00:37:38,000 --> 00:37:45,599
i i run this

00:37:42,560 --> 00:37:47,119
i didn't print the values right here and

00:37:45,599 --> 00:37:49,440
now if i run this

00:37:47,119 --> 00:37:51,440
then you see it does get added to the

00:37:49,440 --> 00:37:55,119
list but it's a single element

00:37:51,440 --> 00:37:58,160
it's not a continuation of the list so

00:37:55,119 --> 00:38:00,960
when you use append that whatever you

00:37:58,160 --> 00:38:02,640
give a pen to add to the list it'll get

00:38:00,960 --> 00:38:05,839
added a single element

00:38:02,640 --> 00:38:10,240
if you use extend

00:38:05,839 --> 00:38:14,079
then it'll extend like it'll continue

00:38:10,240 --> 00:38:15,839
the same list so it won't be nested yeah

00:38:14,079 --> 00:38:19,839
so it'll become three independent

00:38:15,839 --> 00:38:19,839
elements of this

00:38:23,119 --> 00:38:27,040
so then we have tuples in python so

00:38:26,079 --> 00:38:30,079
tuples are

00:38:27,040 --> 00:38:31,920
exactly like exactly like a list the

00:38:30,079 --> 00:38:32,960
only difference between a tuple and a

00:38:31,920 --> 00:38:36,160
list

00:38:32,960 --> 00:38:38,400
is that tuples you can't change their

00:38:36,160 --> 00:38:41,040
values once you initialize them

00:38:38,400 --> 00:38:41,839
so in programming we say that a tuple is

00:38:41,040 --> 00:38:45,040
immutable

00:38:41,839 --> 00:38:47,119
which means once you declare it once you

00:38:45,040 --> 00:38:48,079
have assigned it a value you cannot

00:38:47,119 --> 00:38:51,839
change it again

00:38:48,079 --> 00:38:51,839
so if

00:38:52,320 --> 00:38:57,119
and once again it's the same thing with

00:38:54,000 --> 00:38:59,520
the list if you have a long

00:38:57,119 --> 00:39:01,440
tuple then it's a good idea to spread

00:38:59,520 --> 00:39:03,760
the code out on multiple lines

00:39:01,440 --> 00:39:06,000
so it's more readable and easier for

00:39:03,760 --> 00:39:09,200
people to read your code

00:39:06,000 --> 00:39:09,200
so i can

00:39:11,040 --> 00:39:17,920
use this in and

00:39:14,160 --> 00:39:20,160
uh yeah accessing elements from a tuple

00:39:17,920 --> 00:39:21,599
is exactly like how it works with lists

00:39:20,160 --> 00:39:25,119
so every element

00:39:21,599 --> 00:39:26,880
in uh tuple has an index the first one

00:39:25,119 --> 00:39:28,160
is zero the second one is one the third

00:39:26,880 --> 00:39:31,200
one is

00:39:28,160 --> 00:39:34,079
two and so on and you can have

00:39:31,200 --> 00:39:36,320
a list inside a tuple as well you can

00:39:34,079 --> 00:39:40,079
have tuples inside a tuple as well

00:39:36,320 --> 00:39:43,200
so um and

00:39:40,079 --> 00:39:46,640
when you want to obtain a single element

00:39:43,200 --> 00:39:48,560
from the list you you can you do that

00:39:46,640 --> 00:39:52,560
exactly the same way that it works

00:39:48,560 --> 00:39:53,599
with lists so slicing works exactly the

00:39:52,560 --> 00:39:55,440
same way

00:39:53,599 --> 00:39:56,880
and like everything else is just the

00:39:55,440 --> 00:39:57,839
same the only difference is that you

00:39:56,880 --> 00:40:01,200
can't change

00:39:57,839 --> 00:40:01,200
the values of a tuple

00:40:03,440 --> 00:40:13,359
yes yes

00:40:10,319 --> 00:40:16,880
um one interesting thing to

00:40:13,359 --> 00:40:19,920
note here is that while you can't change

00:40:16,880 --> 00:40:22,000
the inject values inside a tuple

00:40:19,920 --> 00:40:23,520
if there's a list inside the tuple you

00:40:22,000 --> 00:40:26,160
actually can

00:40:23,520 --> 00:40:28,880
modify the values so if i if you see the

00:40:26,160 --> 00:40:31,760
last element of my tuple here is a list

00:40:28,880 --> 00:40:34,000
and i if i wanted to i could change the

00:40:31,760 --> 00:40:36,960
value of that list and

00:40:34,000 --> 00:40:36,960
it would actually work

00:40:37,680 --> 00:40:42,720
yeah this is not something that comes up

00:40:39,839 --> 00:40:45,760
too often in python so

00:40:42,720 --> 00:40:47,440
uh this is like the only exception to

00:40:45,760 --> 00:40:50,240
the rule that you can't change values

00:40:47,440 --> 00:40:50,240
inside a people

00:40:50,839 --> 00:40:53,839
okay

00:40:59,040 --> 00:41:05,440
so lastly we have dictionaries so

00:41:02,319 --> 00:41:07,119
dictionaries in python basically store a

00:41:05,440 --> 00:41:10,160
key value pair

00:41:07,119 --> 00:41:14,079
so they create a map between

00:41:10,160 --> 00:41:18,480
specified values so

00:41:14,079 --> 00:41:20,000
um basically if it's unclear right now

00:41:18,480 --> 00:41:22,000
it will become more clear

00:41:20,000 --> 00:41:24,560
as you go through the example so

00:41:22,000 --> 00:41:27,599
basically to define a dictionary you

00:41:24,560 --> 00:41:29,839
write it like this and similar to list

00:41:27,599 --> 00:41:32,720
you can also write this in one line but

00:41:29,839 --> 00:41:34,960
usually with dictionaries it's always

00:41:32,720 --> 00:41:35,760
you write different elements out on

00:41:34,960 --> 00:41:39,680
different lines you

00:41:35,760 --> 00:41:42,960
don't write them on the same line so

00:41:39,680 --> 00:41:45,760
uh the value on the left is is known as

00:41:42,960 --> 00:41:48,400
the key and a value to the right is

00:41:45,760 --> 00:41:52,319
known as the value

00:41:48,400 --> 00:41:55,040
and basically what this does is it

00:41:52,319 --> 00:41:55,760
if you now give this value to the

00:41:55,040 --> 00:41:58,880
dictionary

00:41:55,760 --> 00:41:59,839
it will give you back the value on the

00:41:58,880 --> 00:42:01,760
right

00:41:59,839 --> 00:42:04,960
so if you give it the key it'll give you

00:42:01,760 --> 00:42:04,960
the corresponding value

00:42:05,920 --> 00:42:13,040
yes you have a question so

00:42:09,359 --> 00:42:16,160
for keys in a dictionary you can use

00:42:13,040 --> 00:42:17,839
strings you can use integers you can use

00:42:16,160 --> 00:42:20,960
floating point values and you can use

00:42:17,839 --> 00:42:22,960
tuples as well you can use lists

00:42:20,960 --> 00:42:24,640
inside the dictionary though that

00:42:22,960 --> 00:42:28,640
wouldn't work

00:42:24,640 --> 00:42:30,560
as a key you can't use lists as a key in

00:42:28,640 --> 00:42:32,800
a dictionary you can still

00:42:30,560 --> 00:42:34,400
use a list in the value of a dictionary

00:42:32,800 --> 00:42:37,760
that would work

00:42:34,400 --> 00:42:41,200
so when you

00:42:37,760 --> 00:42:43,520
declare a dictionary like this

00:42:41,200 --> 00:42:46,079
you can access the values of the

00:42:43,520 --> 00:42:49,520
dictionary by specifying the keys

00:42:46,079 --> 00:42:50,240
as indexes so it works similar to how a

00:42:49,520 --> 00:42:52,800
list

00:42:50,240 --> 00:42:53,359
or a tool works just that instead of

00:42:52,800 --> 00:42:56,480
having

00:42:53,359 --> 00:42:59,200
an index that starts with 0 1 2 3

00:42:56,480 --> 00:43:00,400
you use whatever key or whatever index

00:42:59,200 --> 00:43:02,560
that you specify

00:43:00,400 --> 00:43:02,560
so

00:43:08,720 --> 00:43:12,720
if i run this what it'll print out all

00:43:12,079 --> 00:43:15,599
of the

00:43:12,720 --> 00:43:17,119
values of the dictionary and with

00:43:15,599 --> 00:43:20,480
dictionaries

00:43:17,119 --> 00:43:24,319
you you can't you can use almost

00:43:20,480 --> 00:43:25,359
every kind of value inside a dictionary

00:43:24,319 --> 00:43:27,599
as a key

00:43:25,359 --> 00:43:28,400
you can't however use a list if i try to

00:43:27,599 --> 00:43:30,960
use a list

00:43:28,400 --> 00:43:32,560
in a dictionary as a key that will not

00:43:30,960 --> 00:43:34,720
work

00:43:32,560 --> 00:43:34,720
so

00:43:35,839 --> 00:43:41,760
if i try to do that then it says that

00:43:39,280 --> 00:43:43,119
unhashable type list this just means

00:43:41,760 --> 00:43:47,280
that you can't use

00:43:43,119 --> 00:43:49,280
list inside a dictionary as a key

00:43:47,280 --> 00:43:55,839
you could use the list as a value if you

00:43:49,280 --> 00:43:55,839
wanted to say i say um

00:44:06,839 --> 00:44:09,839
okay

00:44:13,520 --> 00:44:16,800
so that this would work because you can

00:44:15,760 --> 00:44:20,079
use lists as

00:44:16,800 --> 00:44:23,359
values and

00:44:20,079 --> 00:44:27,119
you see the list appears in the output

00:44:23,359 --> 00:44:29,280
so uh to use a dictionary

00:44:27,119 --> 00:44:31,200
you you have it's basically to summarize

00:44:29,280 --> 00:44:33,280
it's a key value pair

00:44:31,200 --> 00:44:34,880
you have a key and you have a it's

00:44:33,280 --> 00:44:36,640
associated value and when you give the

00:44:34,880 --> 00:44:38,960
dictionary the key you get back the

00:44:36,640 --> 00:44:38,960
value

00:44:39,040 --> 00:44:46,000
and let's say you try to

00:44:42,240 --> 00:44:47,839
access an element in the dictionary that

00:44:46,000 --> 00:44:49,520
doesn't have any key associated with it

00:44:47,839 --> 00:44:51,680
so let's say i use

00:44:49,520 --> 00:44:53,760
one but there's no one in my dictionary

00:44:51,680 --> 00:44:56,000
what's going to happen

00:44:53,760 --> 00:44:57,119
it's going to give me an error if i try

00:44:56,000 --> 00:45:01,440
to use a one

00:44:57,119 --> 00:45:03,599
so it says key error one this means that

00:45:01,440 --> 00:45:06,160
there's no key related to one in my

00:45:03,599 --> 00:45:09,920
dictionary so i can't do this

00:45:06,160 --> 00:45:10,640
um another way to obtain values from a

00:45:09,920 --> 00:45:13,680
dictionary

00:45:10,640 --> 00:45:16,400
is to use uh the get function

00:45:13,680 --> 00:45:18,400
so you can do a dot get and then specify

00:45:16,400 --> 00:45:21,680
the value of the key and you'll get back

00:45:18,400 --> 00:45:22,800
the associated value and advantage of

00:45:21,680 --> 00:45:25,520
using the get

00:45:22,800 --> 00:45:26,079
function over the subscript notation is

00:45:25,520 --> 00:45:28,079
that

00:45:26,079 --> 00:45:30,160
you can specify something that's known

00:45:28,079 --> 00:45:33,200
as a default value as well

00:45:30,160 --> 00:45:35,520
so if you specify a key and it's not

00:45:33,200 --> 00:45:37,359
found in the dictionary then your

00:45:35,520 --> 00:45:47,839
default value is used in set

00:45:37,359 --> 00:45:47,839
instead does that make sense

00:45:58,839 --> 00:46:01,839
so

00:46:06,000 --> 00:46:10,880
so now that we've talked about the most

00:46:08,960 --> 00:46:12,640
common data types in python if you have

00:46:10,880 --> 00:46:15,280
a variable and you want to

00:46:12,640 --> 00:46:17,359
know which data type it belongs to you

00:46:15,280 --> 00:46:21,280
can do that using the type

00:46:17,359 --> 00:46:24,480
function so you write

00:46:21,280 --> 00:46:25,280
type and you give it a variable and it

00:46:24,480 --> 00:46:28,800
tells you

00:46:25,280 --> 00:46:29,200
which data type it is so uh the first

00:46:28,800 --> 00:46:31,760
one

00:46:29,200 --> 00:46:33,119
is a string so it prints str the second

00:46:31,760 --> 00:46:35,680
one is a float

00:46:33,119 --> 00:46:37,440
so it prints float the third one is a

00:46:35,680 --> 00:46:40,720
list so it prints list

00:46:37,440 --> 00:46:42,000
the fourth one is an integer so it

00:46:40,720 --> 00:46:47,040
prints in

00:46:42,000 --> 00:46:49,920
the um fifth one is a tuple segment

00:46:47,040 --> 00:46:52,000
and uh it prints boolean for the last

00:46:49,920 --> 00:46:57,839
one that's not dictionary in here

00:46:52,000 --> 00:46:57,839
quickly so if you have a dictionary

00:46:58,720 --> 00:47:00,960
and

00:47:08,000 --> 00:47:11,839
an elephant uh

00:47:12,240 --> 00:47:16,880
and for now uh you don't have to worry

00:47:15,440 --> 00:47:21,920
about what the class part

00:47:16,880 --> 00:47:21,920
means we'll come to that later on so

00:47:22,079 --> 00:47:27,680
yeah this tells you which data type the

00:47:25,599 --> 00:47:30,160
element that you gave it belongs to does

00:47:27,680 --> 00:47:33,200
that make sense

00:47:30,160 --> 00:47:33,200
okay let's move on now

00:47:34,880 --> 00:47:38,000
so when you write a program right there

00:47:37,520 --> 00:47:40,240
are some

00:47:38,000 --> 00:47:42,079
variable naming rules and conventions

00:47:40,240 --> 00:47:45,280
that you must follow

00:47:42,079 --> 00:47:47,680
and these are

00:47:45,280 --> 00:47:48,720
rules that are set by the programming

00:47:47,680 --> 00:47:51,119
language

00:47:48,720 --> 00:47:52,000
that you absolutely have to follow when

00:47:51,119 --> 00:47:53,599
you write

00:47:52,000 --> 00:47:55,440
variable names and there are some

00:47:53,599 --> 00:47:58,240
conventions as well that are

00:47:55,440 --> 00:47:59,920
kind of unwritten rules they are like

00:47:58,240 --> 00:48:01,359
they're not set in stone you don't

00:47:59,920 --> 00:48:04,079
exactly have to follow the

00:48:01,359 --> 00:48:05,359
conventions but it's good practice to

00:48:04,079 --> 00:48:08,319
follow the conventions

00:48:05,359 --> 00:48:08,800
so the rules that you absolutely must

00:48:08,319 --> 00:48:11,839
follow

00:48:08,800 --> 00:48:14,800
they are the first four these four rules

00:48:11,839 --> 00:48:15,440
so in variable names right you can only

00:48:14,800 --> 00:48:19,040
use

00:48:15,440 --> 00:48:22,000
letters numbers and undisposed so

00:48:19,040 --> 00:48:22,559
you can use a letter in a variable name

00:48:22,000 --> 00:48:24,559
you can use

00:48:22,559 --> 00:48:26,960
underscores and you can use one two

00:48:24,559 --> 00:48:30,319
three or any numbers that you wanna

00:48:26,960 --> 00:48:35,839
that works so this is a valid variable

00:48:30,319 --> 00:48:35,839
name so to say

00:48:51,760 --> 00:48:56,319
so uh something like this would work

00:48:54,000 --> 00:48:59,760
without any issues

00:48:56,319 --> 00:49:00,839
then uh your even names can't start with

00:48:59,760 --> 00:49:04,400
a number

00:49:00,839 --> 00:49:05,680
so if you write a variable name that

00:49:04,400 --> 00:49:09,359
starts with a number

00:49:05,680 --> 00:49:09,920
then it it ps code already gives me an

00:49:09,359 --> 00:49:12,960
error

00:49:09,920 --> 00:49:15,839
it doesn't like when you do that so

00:49:12,960 --> 00:49:16,640
um oh i didn't save now you give me an

00:49:15,839 --> 00:49:18,800
app so yeah

00:49:16,640 --> 00:49:19,760
in fact python gives you an error when

00:49:18,800 --> 00:49:23,440
you try to do that

00:49:19,760 --> 00:49:26,000
it's invalid syntax you

00:49:23,440 --> 00:49:27,119
uh when you write variable names in

00:49:26,000 --> 00:49:28,839
python then

00:49:27,119 --> 00:49:30,319
the variable names they are case

00:49:28,839 --> 00:49:32,400
sensitive and

00:49:30,319 --> 00:49:34,000
basically what case sensitive means is

00:49:32,400 --> 00:49:38,240
that a

00:49:34,000 --> 00:49:38,240
is a different variable than capital a

00:49:42,839 --> 00:49:45,839
so

00:49:46,800 --> 00:49:50,960
so the both of these variables they are

00:49:48,720 --> 00:49:52,800
different they refer to different values

00:49:50,960 --> 00:49:55,920
so

00:49:52,800 --> 00:49:59,040
um variable names are case sensitive

00:49:55,920 --> 00:49:59,440
and lastly your variable names they must

00:49:59,040 --> 00:50:03,359
not

00:49:59,440 --> 00:50:06,319
be keywords in particular so

00:50:03,359 --> 00:50:07,680
keywords are basically reserved words in

00:50:06,319 --> 00:50:10,240
any programming language

00:50:07,680 --> 00:50:11,359
which have a specific meaning or a

00:50:10,240 --> 00:50:13,440
special purpose

00:50:11,359 --> 00:50:15,760
in the programming language for example

00:50:13,440 --> 00:50:17,599
in it's a keyword in python because it's

00:50:15,760 --> 00:50:20,000
the name of a data type

00:50:17,599 --> 00:50:20,800
you can't use int as a variable name

00:50:20,000 --> 00:50:24,079
that

00:50:20,800 --> 00:50:26,000
that would not be correct uh

00:50:24,079 --> 00:50:28,160
well these are the these four are the

00:50:26,000 --> 00:50:29,680
only like laws or rules that you

00:50:28,160 --> 00:50:31,920
absolutely must follow

00:50:29,680 --> 00:50:33,680
there are some conventions that it's

00:50:31,920 --> 00:50:35,440
nice to follow them but you don't

00:50:33,680 --> 00:50:37,680
have to follow them but you should

00:50:35,440 --> 00:50:40,640
because it's good practice to do so

00:50:37,680 --> 00:50:41,520
so let's say if you're writing a

00:50:40,640 --> 00:50:43,839
variable name

00:50:41,520 --> 00:50:44,800
that's just one word it's conventional

00:50:43,839 --> 00:50:48,800
to just

00:50:44,800 --> 00:50:51,760
uh use a small uh all small letters

00:50:48,800 --> 00:50:52,800
so radius one name or something like

00:50:51,760 --> 00:50:55,680
that

00:50:52,800 --> 00:50:57,520
if you are writing a variable name that

00:50:55,680 --> 00:51:01,359
consists of more than one word

00:50:57,520 --> 00:51:04,079
then you it's conventional to use

00:51:01,359 --> 00:51:05,119
uh underscores to separate the words so

00:51:04,079 --> 00:51:08,160
this is known as

00:51:05,119 --> 00:51:09,920
a snake case in

00:51:08,160 --> 00:51:11,200
java or some other language you'd use

00:51:09,920 --> 00:51:13,280
camel case but

00:51:11,200 --> 00:51:14,400
in python it's conventional to use snake

00:51:13,280 --> 00:51:17,599
please

00:51:14,400 --> 00:51:18,720
so you write all of your different words

00:51:17,599 --> 00:51:22,160
in small letters

00:51:18,720 --> 00:51:24,240
separated by underscores and

00:51:22,160 --> 00:51:25,680
uh when you're writing a variable name

00:51:24,240 --> 00:51:28,160
that's supposed to be

00:51:25,680 --> 00:51:29,440
a constant or a value that you don't

00:51:28,160 --> 00:51:31,520
intend to change

00:51:29,440 --> 00:51:33,119
throughout your program then you use all

00:51:31,520 --> 00:51:35,920
capital letters so let's say

00:51:33,119 --> 00:51:36,880
pi or golden ratio you have they are all

00:51:35,920 --> 00:51:38,720
capital letters

00:51:36,880 --> 00:51:40,240
you don't use small letters to write

00:51:38,720 --> 00:51:42,079
those

00:51:40,240 --> 00:51:44,000
of course if you wanted to you could use

00:51:42,079 --> 00:51:47,280
small letters as well but

00:51:44,000 --> 00:51:50,000
it's nice to follow these conventions

00:51:47,280 --> 00:51:51,680
and lastly it's good practice to type

00:51:50,000 --> 00:51:53,920
variable names that are

00:51:51,680 --> 00:51:54,880
mnemonic which means that they should

00:51:53,920 --> 00:51:57,839
indicate to a

00:51:54,880 --> 00:51:59,520
casual programmer their purpose so using

00:51:57,839 --> 00:52:01,520
single letter variable names is

00:51:59,520 --> 00:52:03,119
discouraged and usually you should only

00:52:01,520 --> 00:52:06,400
use single at a name when it's a

00:52:03,119 --> 00:52:09,599
throwaway or a temporary variable

00:52:06,400 --> 00:52:10,640
so if i if you want to write uh code

00:52:09,599 --> 00:52:13,920
then

00:52:10,640 --> 00:52:16,319
sorry yeah exactly

00:52:13,920 --> 00:52:19,760
you should use proper names that tell

00:52:16,319 --> 00:52:22,079
you what the purpose of the variable

00:52:19,760 --> 00:52:23,680
yeah your variable name should be

00:52:22,079 --> 00:52:25,200
descriptive and it should be

00:52:23,680 --> 00:52:27,280
like people should be able to read your

00:52:25,200 --> 00:52:29,680
code and see at a glance

00:52:27,280 --> 00:52:33,839
what your variables or what your code

00:52:29,680 --> 00:52:33,839
tends to do

00:52:35,359 --> 00:52:39,040
okay let's move on to operators in

00:52:38,160 --> 00:52:42,640
python

00:52:39,040 --> 00:52:45,280
so python offers uh

00:52:42,640 --> 00:52:46,160
seven different types of operators we'll

00:52:45,280 --> 00:52:48,160
be going over

00:52:46,160 --> 00:52:49,359
six of them today one of them is a bit

00:52:48,160 --> 00:52:50,960
out of the scope

00:52:49,359 --> 00:52:52,640
for today's session but if you're

00:52:50,960 --> 00:52:55,760
interested you can always

00:52:52,640 --> 00:52:58,839
look it up and uh read it a

00:52:55,760 --> 00:53:01,040
read about it on your own so the first

00:52:58,839 --> 00:53:02,160
operators or the operations that we can

00:53:01,040 --> 00:53:04,400
perform is

00:53:02,160 --> 00:53:06,000
arithmetic obviously we have numbers we

00:53:04,400 --> 00:53:07,280
should be able to do calculations with

00:53:06,000 --> 00:53:09,200
them right

00:53:07,280 --> 00:53:12,559
so you can do addition subtraction

00:53:09,200 --> 00:53:12,559
multiplication division

00:53:12,839 --> 00:53:18,800
um you can

00:53:15,520 --> 00:53:21,839
do integer division

00:53:18,800 --> 00:53:25,359
and something known as a modulo in

00:53:21,839 --> 00:53:28,800
python in most programming languages so

00:53:25,359 --> 00:53:32,000
let's go over all of these uh one by one

00:53:28,800 --> 00:53:34,400
um addition is

00:53:32,000 --> 00:53:35,359
pretty simple it adds two values

00:53:34,400 --> 00:53:38,079
together

00:53:35,359 --> 00:53:39,200
so this would give me 15. then

00:53:38,079 --> 00:53:41,520
subtraction

00:53:39,200 --> 00:53:42,880
is also pretty simple it subtracts two

00:53:41,520 --> 00:53:45,920
values

00:53:42,880 --> 00:53:46,880
uh multiplication would multiply two

00:53:45,920 --> 00:53:50,400
values

00:53:46,880 --> 00:53:54,079
and division would divide two values

00:53:50,400 --> 00:53:57,280
and the integer division is the

00:53:54,079 --> 00:54:00,480
and it gives you the quotient

00:53:57,280 --> 00:54:03,200
of a division so if i do 17 by 6

00:54:00,480 --> 00:54:05,440
this would give me 2 because that's the

00:54:03,200 --> 00:54:09,359
quotient of the division

00:54:05,440 --> 00:54:11,760
so uh basically

00:54:09,359 --> 00:54:13,040
yeah uh it'll become clear as i walk

00:54:11,760 --> 00:54:16,319
through the

00:54:13,040 --> 00:54:17,359
case yeah exactly it it gets rid of the

00:54:16,319 --> 00:54:19,440
floating point

00:54:17,359 --> 00:54:21,680
part so it gives you an integer value

00:54:19,440 --> 00:54:22,559
because normal division in python will

00:54:21,680 --> 00:54:25,119
give you

00:54:22,559 --> 00:54:27,040
a floating point value so that will give

00:54:25,119 --> 00:54:28,640
you 2.5

00:54:27,040 --> 00:54:30,640
in any other programming language

00:54:28,640 --> 00:54:31,280
usually this is you don't have integer

00:54:30,640 --> 00:54:34,559
division

00:54:31,280 --> 00:54:37,760
the normal division works like that and

00:54:34,559 --> 00:54:39,599
you have to specify when it has to be

00:54:37,760 --> 00:54:41,119
either one of the two but python

00:54:39,599 --> 00:54:43,040
simplifies that and it just has two

00:54:41,119 --> 00:54:45,520
different operations for it

00:54:43,040 --> 00:54:46,559
so if you become clear when i run the

00:54:45,520 --> 00:54:49,599
program and

00:54:46,559 --> 00:54:49,599
uh you'll be able to

00:54:50,960 --> 00:54:54,240
you it'll be more clear when i go

00:54:52,799 --> 00:54:57,200
through the example

00:54:54,240 --> 00:55:00,640
so then you can do uh you have the

00:54:57,200 --> 00:55:02,720
modulo operation which gives you

00:55:00,640 --> 00:55:04,079
it gives you the remainder of the

00:55:02,720 --> 00:55:07,040
division

00:55:04,079 --> 00:55:09,119
and uh the last one is exponentiation so

00:55:07,040 --> 00:55:12,160
you can

00:55:09,119 --> 00:55:14,640
yeah it's basically the first number

00:55:12,160 --> 00:55:16,799
raised to the power of the second number

00:55:14,640 --> 00:55:16,799
so

00:55:18,160 --> 00:55:21,280
if i run this program and i get the

00:55:20,400 --> 00:55:22,960
first one is

00:55:21,280 --> 00:55:24,880
addition is 15 the second one

00:55:22,960 --> 00:55:27,520
subtraction is 5

00:55:24,880 --> 00:55:28,240
then multiplication and then division so

00:55:27,520 --> 00:55:31,359
and you see

00:55:28,240 --> 00:55:33,040
uh the division here it gives me this

00:55:31,359 --> 00:55:35,520
one

00:55:33,040 --> 00:55:36,400
uh gives me 2.5 so it gives me the

00:55:35,520 --> 00:55:38,559
precise

00:55:36,400 --> 00:55:40,160
answer of the division the second one

00:55:38,559 --> 00:55:43,760
however 16

00:55:40,160 --> 00:55:48,720
uh by sorry 17 by 6

00:55:43,760 --> 00:55:48,720
it it it would uh if i did normal

00:55:49,920 --> 00:55:53,359
if i did normal division on that it

00:55:52,319 --> 00:55:56,799
would give me

00:55:53,359 --> 00:55:59,119
the precise value which is 2.8333

00:55:56,799 --> 00:55:59,920
but when i do integer division it gets

00:55:59,119 --> 00:56:02,960
rid of the

00:55:59,920 --> 00:56:05,599
floating point part and it just

00:56:02,960 --> 00:56:06,160
yeah it gives me just the integer part

00:56:05,599 --> 00:56:08,640
so

00:56:06,160 --> 00:56:10,480
it doesn't round off so it it just gets

00:56:08,640 --> 00:56:13,040
rid of the floating part

00:56:10,480 --> 00:56:13,040
completely

00:56:13,599 --> 00:56:18,960
the modular operation

00:56:17,359 --> 00:56:20,720
it gives you the remainder of the

00:56:18,960 --> 00:56:24,400
division so when you do

00:56:20,720 --> 00:56:26,160
10 percent six it divides ten by six and

00:56:24,400 --> 00:56:28,960
then whatever the remainder is that's

00:56:26,160 --> 00:56:29,440
the value of the modulus operation and

00:56:28,960 --> 00:56:33,760
then

00:56:29,440 --> 00:56:38,559
lastly there's exponentiation so 5

00:56:33,760 --> 00:56:40,799
5 to the power of 2 which is 25 okay

00:56:38,559 --> 00:56:44,559
if you have any questions then please

00:56:40,799 --> 00:56:49,359
ask i think it should be clear right

00:56:44,559 --> 00:56:49,359
no sorry

00:56:51,040 --> 00:56:55,119
what's your question

00:56:56,839 --> 00:56:59,839
sorry

00:57:02,160 --> 00:57:12,000
so if you have no questions then i'll

00:57:04,000 --> 00:57:14,720
move forward

00:57:12,000 --> 00:57:15,440
then you have relational operators in

00:57:14,720 --> 00:57:19,119
python

00:57:15,440 --> 00:57:21,440
so relational operators are basically uh

00:57:19,119 --> 00:57:24,839
they allow you to compare the values of

00:57:21,440 --> 00:57:27,839
two different variables together

00:57:24,839 --> 00:57:27,839
so

00:57:29,680 --> 00:57:32,799
let's see i have two variables and i

00:57:31,440 --> 00:57:36,000
want to find out

00:57:32,799 --> 00:57:39,200
uh if a variable is larger or theta

00:57:36,000 --> 00:57:40,000
then you can use relational operators so

00:57:39,200 --> 00:57:43,359
questions like

00:57:40,000 --> 00:57:45,359
is a greater than b is a equal to b

00:57:43,359 --> 00:57:47,359
they're all answered using relational

00:57:45,359 --> 00:57:49,680
operators so

00:57:47,359 --> 00:57:50,640
there are six different relational

00:57:49,680 --> 00:57:53,119
operators in

00:57:50,640 --> 00:57:54,319
python so let's walk through them one by

00:57:53,119 --> 00:57:57,280
one

00:57:54,319 --> 00:57:59,359
so you can test if uh variable is

00:57:57,280 --> 00:58:00,319
greater or smaller so if i write 5 is

00:57:59,359 --> 00:58:02,240
greater than 6

00:58:00,319 --> 00:58:04,000
this is is going to give me false

00:58:02,240 --> 00:58:06,880
because that's not true right

00:58:04,000 --> 00:58:08,160
5 is not greater than 6 if i run this i

00:58:06,880 --> 00:58:10,640
get false

00:58:08,160 --> 00:58:12,799
because it's not true so these are the

00:58:10,640 --> 00:58:16,000
types of

00:58:12,799 --> 00:58:19,040
these are the types of uh questions or

00:58:16,000 --> 00:58:21,760
operations that uh use boolean

00:58:19,040 --> 00:58:23,839
data type basically that this is the

00:58:21,760 --> 00:58:27,040
purpose for boolean data types

00:58:23,839 --> 00:58:29,599
and uh i could also

00:58:27,040 --> 00:58:30,880
say is five less than six and yes that's

00:58:29,599 --> 00:58:34,079
true so it'll give me

00:58:30,880 --> 00:58:37,280
an answer of true so

00:58:34,079 --> 00:58:39,200
there are uh five uh four other data

00:58:37,280 --> 00:58:39,839
types as for not data type sorry there

00:58:39,200 --> 00:58:43,760
are five

00:58:39,839 --> 00:58:47,440
other relational operators as well so

00:58:43,760 --> 00:58:51,040
you can do uh greater than you can do

00:58:47,440 --> 00:58:54,640
uh less than you can do

00:58:51,040 --> 00:58:57,280
greater than or equal to which

00:58:54,640 --> 00:59:05,839
you can do less than or equal to you

00:58:57,280 --> 00:59:05,839
could use

00:59:07,520 --> 00:59:10,559
you can use uh

00:59:11,040 --> 00:59:14,960
equal to with double equals to which

00:59:13,359 --> 00:59:15,680
basically checks if two numbers are

00:59:14,960 --> 00:59:18,880
equal

00:59:15,680 --> 00:59:20,640
and you can use uh not equal to which

00:59:18,880 --> 00:59:21,839
checks if two numbers are not equal to

00:59:20,640 --> 00:59:25,359
each other

00:59:21,839 --> 00:59:28,160
so uh to

00:59:25,359 --> 00:59:28,559
recap the data operation tells you if a

00:59:28,160 --> 00:59:30,960
number

00:59:28,559 --> 00:59:32,799
is greater than another one or not the

00:59:30,960 --> 00:59:33,280
less than operation tells you if another

00:59:32,799 --> 00:59:36,480
number

00:59:33,280 --> 00:59:38,559
is less than another number or not the

00:59:36,480 --> 00:59:39,839
greater than or equal to operation tells

00:59:38,559 --> 00:59:42,400
you if one number

00:59:39,839 --> 00:59:43,280
is either greater or equal to another

00:59:42,400 --> 00:59:45,119
number

00:59:43,280 --> 00:59:46,400
the less than or equal to operation

00:59:45,119 --> 00:59:49,599
tells you if a number

00:59:46,400 --> 00:59:52,799
is less than or equal to another one

00:59:49,599 --> 00:59:55,359
and the double equal operation just

00:59:52,799 --> 00:59:57,280
it just compares two values and checks

00:59:55,359 --> 01:00:01,200
if they're equal or not

00:59:57,280 --> 01:00:03,040
and the last one um does the opposite

01:00:01,200 --> 01:00:05,520
of the equal to it just checks if two

01:00:03,040 --> 01:00:08,000
values are not equal to each other so i

01:00:05,520 --> 01:00:08,000
run this

01:00:08,160 --> 01:00:12,480
uh i get false because 5 is not greater

01:00:11,599 --> 01:00:15,440
than 6

01:00:12,480 --> 01:00:16,079
10 is less than 11 so yeah i get true

01:00:15,440 --> 01:00:18,799
then

01:00:16,079 --> 01:00:20,240
10 it's greater than or equal to so it's

01:00:18,799 --> 01:00:23,280
equal to 10 so i get

01:00:20,240 --> 01:00:23,680
true then 2 is less than equal to 11 so

01:00:23,280 --> 01:00:26,640
i get

01:00:23,680 --> 01:00:27,280
true 10 is obviously is equal to 10 so i

01:00:26,640 --> 01:00:29,680
get true

01:00:27,280 --> 01:00:33,839
and then 10 and then 11 it's not equal

01:00:29,680 --> 01:00:33,839
to 10 so i also get true does that make

01:00:40,839 --> 01:00:43,839
sense

01:00:45,040 --> 01:00:48,079
yes the relational operators work for

01:00:46,960 --> 01:00:50,240
strings as well

01:00:48,079 --> 01:00:52,319
so if you use a string with the

01:00:50,240 --> 01:00:56,079
relational operators

01:00:52,319 --> 01:00:59,680
then you uh it basically tells

01:00:56,079 --> 01:01:00,480
you if the strings are in alphabetical

01:00:59,680 --> 01:01:03,839
order or not

01:01:00,480 --> 01:01:06,000
so this would give you true because a

01:01:03,839 --> 01:01:08,160
alphabetically comes before b so if i

01:01:06,000 --> 01:01:10,160
run this i will get true

01:01:08,160 --> 01:01:11,280
because a is alphabetically comes before

01:01:10,160 --> 01:01:14,160
b

01:01:11,280 --> 01:01:15,280
um this will also work with longer

01:01:14,160 --> 01:01:19,359
strings if i use

01:01:15,280 --> 01:01:22,559
a and then aap

01:01:19,359 --> 01:01:24,480
the first one still it alphabetically

01:01:22,559 --> 01:01:39,599
comes before

01:01:24,480 --> 01:01:43,599
the second one so it will give me true

01:01:39,599 --> 01:01:44,000
yeah you can use relational operators

01:01:43,599 --> 01:01:47,280
for

01:01:44,000 --> 01:01:49,119
sorting values in a list or they

01:01:47,280 --> 01:01:52,160
use everywhere basically in programming

01:01:49,119 --> 01:01:55,359
it's quite useful

01:01:52,160 --> 01:01:58,960
then we have boolean operations so

01:01:55,359 --> 01:02:02,799
boolean operations uh in python

01:01:58,960 --> 01:02:06,480
is basically is asking uh two questions

01:02:02,799 --> 01:02:10,000
and seeing if both have

01:02:06,480 --> 01:02:13,920
some uh if it's basically to see like

01:02:10,000 --> 01:02:16,079
you can say to

01:02:13,920 --> 01:02:17,200
to write an email to someone like you

01:02:16,079 --> 01:02:19,200
need to have

01:02:17,200 --> 01:02:21,039
you need to have a computer and you need

01:02:19,200 --> 01:02:24,880
to have an active internet connection

01:02:21,039 --> 01:02:25,760
right so to write an email you must have

01:02:24,880 --> 01:02:29,039
a computer

01:02:25,760 --> 01:02:32,079
and active internet so the and here

01:02:29,039 --> 01:02:35,599
is is the boolean operator basically

01:02:32,079 --> 01:02:37,760
if you have uh if you want to

01:02:35,599 --> 01:02:39,039
paint a picture or draw a picture then

01:02:37,760 --> 01:02:41,440
you must have paper

01:02:39,039 --> 01:02:43,760
and you must have paint and you should

01:02:41,440 --> 01:02:46,799
have a paint brush right

01:02:43,760 --> 01:02:49,440
so whenever there are

01:02:46,799 --> 01:02:50,000
things or whenever there are conditions

01:02:49,440 --> 01:02:52,799
that

01:02:50,000 --> 01:02:54,079
must all be true together then we use

01:02:52,799 --> 01:02:57,760
and

01:02:54,079 --> 01:02:59,359
so to play a video game you will need to

01:02:57,760 --> 01:03:02,960
own a computer

01:02:59,359 --> 01:03:06,000
or own a gaming console so basically

01:03:02,960 --> 01:03:07,520
that means that if you have either one

01:03:06,000 --> 01:03:09,280
you can play a game right you can play a

01:03:07,520 --> 01:03:09,680
game on a gaming console or you can play

01:03:09,280 --> 01:03:14,160
like

01:03:09,680 --> 01:03:17,200
a game on a computer so you can use or

01:03:14,160 --> 01:03:18,079
and you can combine fans and odds

01:03:17,200 --> 01:03:21,520
together so

01:03:18,079 --> 01:03:21,839
to draw something you must have a pencil

01:03:21,520 --> 01:03:26,319
or

01:03:21,839 --> 01:03:28,960
a pen and you should have paper right so

01:03:26,319 --> 01:03:30,559
these pants and paws that we use in

01:03:28,960 --> 01:03:32,640
english language basically

01:03:30,559 --> 01:03:36,079
they they what relation that's what

01:03:32,640 --> 01:03:38,559
boolean operations divide their parts so

01:03:36,079 --> 01:03:39,280
in python if you have two different

01:03:38,559 --> 01:03:42,000
conditions

01:03:39,280 --> 01:03:44,480
then you can use boolean operations so

01:03:42,000 --> 01:03:49,039
if i say

01:03:44,480 --> 01:03:52,559
5 less than 6 and

01:03:49,039 --> 01:03:53,680
4 greater than 2 then this would give me

01:03:52,559 --> 01:03:57,039
2 because

01:03:53,680 --> 01:04:00,079
5 is less than 6 and 4 is also

01:03:57,039 --> 01:04:04,160
less than 2. so i run it i get

01:04:00,079 --> 01:04:07,599
2. so um

01:04:04,160 --> 01:04:08,880
if i say all right then only one of them

01:04:07,599 --> 01:04:11,760
needs to be true for

01:04:08,880 --> 01:04:12,079
i for me to get a result so now if i say

01:04:11,760 --> 01:04:14,240
01:04:12,079 --> 01:04:15,599
is less than 6 or 2 is greater than 4

01:04:14,240 --> 01:04:17,839
then we see 2

01:04:15,599 --> 01:04:19,039
is not greater than 4 but still it will

01:04:17,839 --> 01:04:21,520
work because

01:04:19,039 --> 01:04:22,559
5 is less than 6 so either one of the

01:04:21,520 --> 01:04:26,319
conditions can be

01:04:22,559 --> 01:04:29,760
true and the or would give me a true so

01:04:26,319 --> 01:04:31,280
it still gives me a true if both of my

01:04:29,760 --> 01:04:34,240
conditions were false though

01:04:31,280 --> 01:04:35,119
like 6 is not less than 5 neither is 2

01:04:34,240 --> 01:04:37,599
greater than 4

01:04:35,119 --> 01:04:41,839
then it would give me a false okay does

01:04:37,599 --> 01:04:41,839
that make sense

01:04:45,359 --> 01:04:50,720
uh there's no boolean operation for xor

01:04:49,359 --> 01:04:52,839
but there's a bitwise

01:04:50,720 --> 01:04:54,480
operation for xor if you want to use

01:04:52,839 --> 01:04:58,000
that

01:04:54,480 --> 01:05:02,960
so in python there's no uh xor

01:04:58,000 --> 01:05:06,160
for boolean operations yes

01:05:02,960 --> 01:05:09,280
so the boolean and

01:05:06,160 --> 01:05:09,920
is used to check if two or more boolean

01:05:09,280 --> 01:05:13,119
values

01:05:09,920 --> 01:05:15,839
are simultaneously true and

01:05:13,119 --> 01:05:16,319
uh you use it like that you just say a

01:05:15,839 --> 01:05:19,359
and b

01:05:16,319 --> 01:05:20,640
like you just saw and this basically

01:05:19,359 --> 01:05:23,280
checks if both a

01:05:20,640 --> 01:05:25,839
and b are true like it makes sense right

01:05:23,280 --> 01:05:28,960
yes it's basically english

01:05:25,839 --> 01:05:32,640
so uh this

01:05:28,960 --> 01:05:35,760
is a is known as a truth table basically

01:05:32,640 --> 01:05:40,000
is a combination of all the input and

01:05:35,760 --> 01:05:42,000
output values so here it shows you

01:05:40,000 --> 01:05:43,680
all of the different values that a can

01:05:42,000 --> 01:05:45,200
be and then

01:05:43,680 --> 01:05:46,880
it shows you all the different values

01:05:45,200 --> 01:05:49,119
that b can have

01:05:46,880 --> 01:05:50,880
and then it shows you the result when

01:05:49,119 --> 01:05:53,039
you do a and b

01:05:50,880 --> 01:05:54,720
right so if both of my values are false

01:05:53,039 --> 01:05:57,119
then a and b is false

01:05:54,720 --> 01:05:59,359
if both of my values if one of my values

01:05:57,119 --> 01:06:02,960
is true and one of my values is false

01:05:59,359 --> 01:06:06,160
then the result is still false and if

01:06:02,960 --> 01:06:08,960
i have both of my values are true then

01:06:06,160 --> 01:06:11,760
only then my result is true with n okay

01:06:08,960 --> 01:06:11,760
does that make sense

01:06:12,000 --> 01:06:16,480
note that and it's not limited to just

01:06:14,960 --> 01:06:18,480
two variables you could have three

01:06:16,480 --> 01:06:20,000
four or however many variables and as

01:06:18,480 --> 01:06:23,359
you like and you can just do and

01:06:20,000 --> 01:06:23,920
and and for an expression like this to

01:06:23,359 --> 01:06:26,960
be true

01:06:23,920 --> 01:06:30,839
that a and b and c and d right

01:06:26,960 --> 01:06:34,000
all of abcd must be true

01:06:30,839 --> 01:06:37,119
so with this you can try writing

01:06:34,000 --> 01:06:40,160
and writing a truth table for

01:06:37,119 --> 01:06:44,240
four um inputs

01:06:40,160 --> 01:06:46,319
and see what kind of a table you have

01:06:44,240 --> 01:06:47,599
if you want to try writing it then the

01:06:46,319 --> 01:06:53,200
hint is that you'll have

01:06:47,599 --> 01:06:56,319
16 different uh 16 different

01:06:53,200 --> 01:07:01,839
um 16 different combinations of

01:06:56,319 --> 01:07:01,839
input and output pairs

01:07:06,000 --> 01:07:09,920
okay then we have the boolean or

01:07:08,160 --> 01:07:10,880
operation and this is used to check if

01:07:09,920 --> 01:07:15,280
two uh if

01:07:10,880 --> 01:07:18,799
one or more of the given boolean values

01:07:15,280 --> 01:07:22,880
are true so you can use it like a

01:07:18,799 --> 01:07:25,920
or b and a and b are boolean values

01:07:22,880 --> 01:07:28,160
and mistakes if either a or b is true

01:07:25,920 --> 01:07:30,960
if if any one of them is then the

01:07:28,160 --> 01:07:33,920
expression evaluates to true

01:07:30,960 --> 01:07:34,559
so if you write down every combination

01:07:33,920 --> 01:07:38,000
of the

01:07:34,559 --> 01:07:41,359
inputs and outputs for a or b you can

01:07:38,000 --> 01:07:42,799
write it like this you have once again

01:07:41,359 --> 01:07:45,920
it's the same table basically

01:07:42,799 --> 01:07:49,760
that we had up above so

01:07:45,920 --> 01:07:52,880
um you use uh a

01:07:49,760 --> 01:07:53,520
and oh yeah they should say or not like

01:07:52,880 --> 01:07:56,799
that that's

01:07:53,520 --> 01:08:00,480
incorrect but um

01:07:56,799 --> 01:08:02,640
use a or b and if you have both of your

01:08:00,480 --> 01:08:05,440
values are false then it's false if

01:08:02,640 --> 01:08:06,480
any one of the values is true then the

01:08:05,440 --> 01:08:08,319
result is true

01:08:06,480 --> 01:08:10,240
and obviously if both of the values are

01:08:08,319 --> 01:08:14,079
true then it's also true

01:08:10,240 --> 01:08:15,359
so all is only one of the values needs

01:08:14,079 --> 01:08:18,319
to be true

01:08:15,359 --> 01:08:19,920
and again or like that it's not limited

01:08:18,319 --> 01:08:23,040
to just two variables you can use

01:08:19,920 --> 01:08:25,920
a or b or c or b for that

01:08:23,040 --> 01:08:26,239
expression to evaluate the true just one

01:08:25,920 --> 01:08:29,279
of

01:08:26,239 --> 01:08:30,960
abcd needs to be true and it works so i

01:08:29,279 --> 01:08:33,199
could have

01:08:30,960 --> 01:08:34,719
five less than or sorry six less than

01:08:33,199 --> 01:08:38,239
five or two less than four

01:08:34,719 --> 01:08:40,000
or four greater than two and

01:08:38,239 --> 01:08:41,839
yeah that would give me a two because

01:08:40,000 --> 01:08:52,400
just one of them needs to be true

01:08:41,839 --> 01:08:55,679
does that make sense

01:08:52,400 --> 01:08:59,199
and yeah these are just examples so

01:08:55,679 --> 01:09:01,120
you can type them out and copy them into

01:08:59,199 --> 01:09:02,960
code and run the program if you want to

01:09:01,120 --> 01:09:03,520
and can play around with the values and

01:09:02,960 --> 01:09:07,839
see

01:09:03,520 --> 01:09:07,839
how they work so

01:09:09,199 --> 01:09:12,799
it's this basically the same thing now

01:09:11,120 --> 01:09:14,560
but now instead of using

01:09:12,799 --> 01:09:16,880
values in the condition i'm using

01:09:14,560 --> 01:09:20,400
variables it's the same thing

01:09:16,880 --> 01:09:24,239
so here for the first one

01:09:20,400 --> 01:09:27,199
is a less than b so 10

01:09:24,239 --> 01:09:27,759
is 10 and b is 20 and 10 is less than 20

01:09:27,199 --> 01:09:31,279
so

01:09:27,759 --> 01:09:33,120
if that's true and c is 30 and b is 20

01:09:31,279 --> 01:09:35,920
so c is greater than

01:09:33,120 --> 01:09:37,839
20 right so that is also true and since

01:09:35,920 --> 01:09:40,080
both are true i get a true

01:09:37,839 --> 01:09:40,880
and it's the same way you figure out for

01:09:40,080 --> 01:09:44,159
the rest of them

01:09:40,880 --> 01:09:46,960
right and that's

01:09:44,159 --> 01:09:47,759
boolean operations then there's

01:09:46,960 --> 01:09:49,920
membership

01:09:47,759 --> 01:09:51,520
operators so basically membership

01:09:49,920 --> 01:09:54,000
operators

01:09:51,520 --> 01:09:55,679
are used to test if a certain sequence

01:09:54,000 --> 01:09:58,560
is present in an object

01:09:55,679 --> 01:10:00,480
for example if let's say you have a

01:09:58,560 --> 01:10:02,880
character

01:10:00,480 --> 01:10:03,920
or a string and you want to find out if

01:10:02,880 --> 01:10:06,560
they occur

01:10:03,920 --> 01:10:07,280
in another string then you can use these

01:10:06,560 --> 01:10:09,920
membership

01:10:07,280 --> 01:10:09,920
operations

01:10:12,320 --> 01:10:17,920
so uh water it occurs

01:10:15,760 --> 01:10:19,120
in water bottles so the first condition

01:10:17,920 --> 01:10:22,400
is true

01:10:19,120 --> 01:10:24,640
the second one is water not in water

01:10:22,400 --> 01:10:27,280
bottle that's false because water is in

01:10:24,640 --> 01:10:28,000
water bottle right so that will work

01:10:27,280 --> 01:10:31,360
that will say

01:10:28,000 --> 01:10:34,400
that that will evaluate to false and the

01:10:31,360 --> 01:10:34,800
next one uh spongebob in square bands

01:10:34,400 --> 01:10:36,960
that

01:10:34,800 --> 01:10:38,800
would give you false because the the

01:10:36,960 --> 01:10:39,360
first string doesn't occur in the second

01:10:38,800 --> 01:10:42,080
one

01:10:39,360 --> 01:10:44,880
and this last one would give you two

01:10:42,080 --> 01:10:45,520
because spongebob is not in squarepants

01:10:44,880 --> 01:10:48,880
right

01:10:45,520 --> 01:10:51,040
so um if

01:10:48,880 --> 01:10:51,040
i

01:10:52,159 --> 01:10:56,719
if i comment these values out then

01:10:56,960 --> 01:11:00,560
uh and i print these four then you see

01:10:58,960 --> 01:11:02,320
the first one is true the second

01:11:00,560 --> 01:11:04,000
one is false the third one is false and

01:11:02,320 --> 01:11:08,000
the last one is true

01:11:04,000 --> 01:11:08,000
okay and um

01:11:09,600 --> 01:11:14,719
the rest these operations they also work

01:11:12,560 --> 01:11:17,760
with lists tuples and dictionaries so

01:11:14,719 --> 01:11:21,199
if you want to find out if a specified

01:11:17,760 --> 01:11:23,120
value is in a in a list or in a tuple

01:11:21,199 --> 01:11:26,000
or in a dictionary you use them the same

01:11:23,120 --> 01:11:29,600
way and when you use them with a

01:11:26,000 --> 01:11:33,120
dictionary right they they check if

01:11:29,600 --> 01:11:36,320
the value that you give to them is

01:11:33,120 --> 01:11:39,040
it's uh it's a key or not so

01:11:36,320 --> 01:11:39,760
when you use it with a dictionary so it

01:11:39,040 --> 01:11:42,000
checks if

01:11:39,760 --> 01:11:43,280
the value that you gave it is a key or

01:11:42,000 --> 01:11:46,159
not so

01:11:43,280 --> 01:11:46,640
uh if i run the program then you see

01:11:46,159 --> 01:11:49,040
that the

01:11:46,640 --> 01:11:50,480
last two they are the first one is two

01:11:49,040 --> 01:11:52,640
because three point one four

01:11:50,480 --> 01:11:53,679
it's a key in the first dictionary but

01:11:52,640 --> 01:11:56,159
in the second one

01:11:53,679 --> 01:11:57,760
pi is not a key of the second it's a

01:11:56,159 --> 01:12:01,120
value but it's not a key

01:11:57,760 --> 01:12:01,679
so for this to give you true it has to

01:12:01,120 --> 01:12:06,000
be

01:12:01,679 --> 01:12:06,000
a key not a value does that make sense

01:12:06,719 --> 01:12:12,560
so if i wrote not in here instead then

01:12:10,480 --> 01:12:14,560
it will give me two the last one gives

01:12:12,560 --> 01:12:16,719
me true because

01:12:14,560 --> 01:12:19,840
it's not it's not a key in the

01:12:16,719 --> 01:12:24,239
dictionary does that make sense

01:12:19,840 --> 01:12:24,239
that makes sense right okay

01:12:24,719 --> 01:12:31,199
so that's

01:12:28,239 --> 01:12:32,080
uh membership operations and you have

01:12:31,199 --> 01:12:34,400
assignment

01:12:32,080 --> 01:12:35,280
and shorthand assignment operations

01:12:34,400 --> 01:12:38,400
basically

01:12:35,280 --> 01:12:40,080
uh what these are is when you use the

01:12:38,400 --> 01:12:43,120
equal to sign in programming right

01:12:40,080 --> 01:12:45,679
is equal to 10 or

01:12:43,120 --> 01:12:46,320
b equal to 20 or something like this

01:12:45,679 --> 01:12:49,199
it's

01:12:46,320 --> 01:12:50,880
uh you are assigning the value 10 to the

01:12:49,199 --> 01:12:53,280
variable a and you are assigning the

01:12:50,880 --> 01:12:56,719
value 20 to the variable b

01:12:53,280 --> 01:13:00,480
it's not the mathematical equality

01:12:56,719 --> 01:13:00,480
statement it's not saying that

01:13:00,640 --> 01:13:04,000
that's not a mathematical equality

01:13:02,480 --> 01:13:07,040
statement so if i say something

01:13:04,000 --> 01:13:09,600
like a is equal to a plus 10

01:13:07,040 --> 01:13:11,199
that does not mean that 0 is equal to 10

01:13:09,600 --> 01:13:12,880
if that were a mathematical statement

01:13:11,199 --> 01:13:14,800
that would not make sense right

01:13:12,880 --> 01:13:16,000
that's actually an assignment what this

01:13:14,800 --> 01:13:18,719
means is that

01:13:16,000 --> 01:13:19,280
you add 10 to a and then you assign the

01:13:18,719 --> 01:13:23,199
value

01:13:19,280 --> 01:13:26,560
to a so if i print the value of a

01:13:23,199 --> 01:13:30,320
both before and after my

01:13:26,560 --> 01:13:31,760
uh assignment then you would give me

01:13:30,320 --> 01:13:34,320
10 first because obviously it's

01:13:31,760 --> 01:13:35,360
unchanged then i add to it 10 so i get

01:13:34,320 --> 01:13:38,480
20.

01:13:35,360 --> 01:13:40,800
that makes sense so this is an

01:13:38,480 --> 01:13:42,480
assignment this is not a mathematical

01:13:40,800 --> 01:13:46,239
statement

01:13:42,480 --> 01:13:49,840
uh so in python you have uh

01:13:46,239 --> 01:13:52,080
seven uh different types of uh

01:13:49,840 --> 01:13:53,360
shorthand assignment operations

01:13:52,080 --> 01:13:57,040
basically they

01:13:53,360 --> 01:13:57,040
allow you to um

01:13:57,199 --> 01:14:03,760
type the same thing that i write here

01:14:00,640 --> 01:14:04,159
but it's more compact and it's faster to

01:14:03,760 --> 01:14:07,440
write

01:14:04,159 --> 01:14:10,320
so it's known as shorthand operation so

01:14:07,440 --> 01:14:10,960
the same thing i can write a plus equals

01:14:10,320 --> 01:14:12,480
to 10

01:14:10,960 --> 01:14:15,520
and it's the same thing that i just

01:14:12,480 --> 01:14:18,560
wrote so

01:14:15,520 --> 01:14:21,600
uh this this is also going to add

01:14:18,560 --> 01:14:23,520
10 to a so if i

01:14:21,600 --> 01:14:25,840
print again then you see i get the same

01:14:23,520 --> 01:14:29,840
result it's 10 and then 20.

01:14:25,840 --> 01:14:32,880
and the same pattern i can subtract

01:14:29,840 --> 01:14:34,320
a value so i can subtract 5 from a that

01:14:32,880 --> 01:14:37,760
gives me 5

01:14:34,320 --> 01:14:39,199
i can multiply a by another value let's

01:14:37,760 --> 01:14:42,960
say 4.9

01:14:39,199 --> 01:14:46,159
that will give me 49 so i get

01:14:42,960 --> 01:14:49,760
that multiplies you can divide so

01:14:46,159 --> 01:14:53,840
i can divide a by two that will give me

01:14:49,760 --> 01:14:57,360
five i can use integer division as well

01:14:53,840 --> 01:15:00,400
and if i had a value let's say seven

01:14:57,360 --> 01:15:04,320
now i would get three

01:15:00,400 --> 01:15:06,719
and you can use modulus

01:15:04,320 --> 01:15:07,600
okay as well and that will give you one

01:15:06,719 --> 01:15:10,880
because

01:15:07,600 --> 01:15:12,480
this is seven modulus two so you have

01:15:10,880 --> 01:15:15,840
one

01:15:12,480 --> 01:15:19,120
that makes sense so basically

01:15:15,840 --> 01:15:22,320
for every uh shorthand operation

01:15:19,120 --> 01:15:24,159
this is the equivalent uh way to do it

01:15:22,320 --> 01:15:26,640
without using the shorthand so

01:15:24,159 --> 01:15:28,239
a plus equal to b is the same as doing a

01:15:26,640 --> 01:15:30,560
is equal to a plus b

01:15:28,239 --> 01:15:32,480
a minus equal to b is the same as doing

01:15:30,560 --> 01:15:39,840
a is equal to a minus b

01:15:32,480 --> 01:15:39,840
so it works like that that makes sense

01:15:44,400 --> 01:15:47,760
so there are two more types of operators

01:15:46,960 --> 01:15:49,600
in python

01:15:47,760 --> 01:15:50,960
identity operators and bitwise

01:15:49,600 --> 01:15:53,199
operations and

01:15:50,960 --> 01:15:55,280
bitwise operations are a bit out of the

01:15:53,199 --> 01:15:57,360
scope of today's session so

01:15:55,280 --> 01:15:59,760
i'm not keep going over them but if

01:15:57,360 --> 01:16:02,480
you're interested you can look them up

01:15:59,760 --> 01:16:04,239
and the other type is the identity

01:16:02,480 --> 01:16:07,840
operators which we'll be taking a look

01:16:04,239 --> 01:16:07,840
at later on

01:16:10,159 --> 01:16:15,440
okay now that we have variables and

01:16:13,120 --> 01:16:18,560
operations

01:16:15,440 --> 01:16:21,280
the third most important part

01:16:18,560 --> 01:16:22,159
of python space is conditionals and

01:16:21,280 --> 01:16:24,960
loops

01:16:22,159 --> 01:16:27,440
and basically this is grouped under uh

01:16:24,960 --> 01:16:31,040
something that is known as flow control

01:16:27,440 --> 01:16:34,239
so there are times uh in

01:16:31,040 --> 01:16:35,360
in life and in any

01:16:34,239 --> 01:16:36,719
activity that you're doing there are

01:16:35,360 --> 01:16:37,840
times when you would need to make

01:16:36,719 --> 01:16:40,480
decisions right

01:16:37,840 --> 01:16:41,199
let's say you go to a class and in the

01:16:40,480 --> 01:16:43,280
class

01:16:41,199 --> 01:16:44,400
if you have a pen then you can write on

01:16:43,280 --> 01:16:46,560
a piece of paper

01:16:44,400 --> 01:16:48,159
right if you don't have a pen then

01:16:46,560 --> 01:16:50,480
you'll borrow from a classmate

01:16:48,159 --> 01:16:51,440
right so if you forget to bring your

01:16:50,480 --> 01:16:53,600
sale box or

01:16:51,440 --> 01:16:54,719
you don't have a pen then you'll borrow

01:16:53,600 --> 01:16:58,800
from someone

01:16:54,719 --> 01:17:01,040
so these conditions you need

01:16:58,800 --> 01:17:02,800
so the condition is you need to have a

01:17:01,040 --> 01:17:04,960
pen and if you have a pen

01:17:02,800 --> 01:17:06,640
then you do one thing if you don't have

01:17:04,960 --> 01:17:09,120
a pen you do another thing

01:17:06,640 --> 01:17:09,920
right so it's a condition of having the

01:17:09,120 --> 01:17:12,320
pen

01:17:09,920 --> 01:17:14,000
and based on the result of the condition

01:17:12,320 --> 01:17:16,480
you do two different things

01:17:14,000 --> 01:17:17,280
and there are times when you need to do

01:17:16,480 --> 01:17:20,880
the same

01:17:17,280 --> 01:17:22,640
in a program and we use if else if

01:17:20,880 --> 01:17:24,159
uh something known as an effective

01:17:22,640 --> 01:17:28,400
statement in python

01:17:24,159 --> 01:17:31,040
to uh accomplish this so

01:17:28,400 --> 01:17:32,320
let's say i have uh two variables here

01:17:31,040 --> 01:17:35,360
uh 10

01:17:32,320 --> 01:17:38,800
a equals to 10 and b is equal to 20 and

01:17:35,360 --> 01:17:42,719
i want to see if b is greater than

01:17:38,800 --> 01:17:46,880
a or not if it is i do something

01:17:42,719 --> 01:17:50,320
if it's not then i do something else

01:17:46,880 --> 01:17:52,560
okay so this kind of uh

01:17:50,320 --> 01:17:53,520
these effects they're used everywhere in

01:17:52,560 --> 01:17:55,280
programming basically

01:17:53,520 --> 01:17:56,880
anytime that you need to make a decision

01:17:55,280 --> 01:18:00,480
you'd use these

01:17:56,880 --> 01:18:04,080
so for example

01:18:00,480 --> 01:18:07,120
let's say i wanted to find the

01:18:04,080 --> 01:18:07,679
maximum of two given numbers then i can

01:18:07,120 --> 01:18:11,120
do that

01:18:07,679 --> 01:18:14,960
using um using

01:18:11,120 --> 01:18:19,040
uh these conditions so i say

01:18:14,960 --> 01:18:20,480
my maximum is uh i just say zero for now

01:18:19,040 --> 01:18:21,520
because i don't know what's going to be

01:18:20,480 --> 01:18:24,840
the maximum

01:18:21,520 --> 01:18:26,320
and i say if a is greater than b then my

01:18:24,840 --> 01:18:29,679
maximum

01:18:26,320 --> 01:18:32,480
is going to be a otherwise

01:18:29,679 --> 01:18:32,480
is going to be b

01:18:34,640 --> 01:18:41,600
does this make sense so

01:18:38,400 --> 01:18:44,640
if i now print the value

01:18:41,600 --> 01:18:48,560
it will tell me which variable has the

01:18:44,640 --> 01:18:51,840
maximum value so it it shows me 20

01:18:48,560 --> 01:18:55,280
and if i change this around and i make a

01:18:51,840 --> 01:18:58,719
equal to 200 then

01:18:55,280 --> 01:19:00,640
i get 200 so basically now

01:18:58,719 --> 01:19:02,800
just by changing the values my program

01:19:00,640 --> 01:19:06,800
is is doing a different thing

01:19:02,800 --> 01:19:09,440
so these these conditional operators

01:19:06,800 --> 01:19:09,840
and like conditions and if statements

01:19:09,440 --> 01:19:12,400
these

01:19:09,840 --> 01:19:13,520
are like a really important part of any

01:19:12,400 --> 01:19:17,440
program

01:19:13,520 --> 01:19:20,239
so uh is is

01:19:17,440 --> 01:19:23,840
important that you understand them

01:19:20,239 --> 01:19:23,840
properly and

01:19:30,400 --> 01:19:36,159
so usually when you write if statements

01:19:33,440 --> 01:19:37,040
and else statements you you need to

01:19:36,159 --> 01:19:40,320
provide

01:19:37,040 --> 01:19:43,760
an indentation of usually four spaces

01:19:40,320 --> 01:19:44,159
to in your code there's this indentation

01:19:43,760 --> 01:19:47,199
of

01:19:44,159 --> 01:19:50,159
four spaces it tells python what

01:19:47,199 --> 01:19:50,560
uh what part of your code comes under

01:19:50,159 --> 01:19:53,760
that

01:19:50,560 --> 01:19:56,239
else or that if so let's say i have

01:19:53,760 --> 01:19:57,280
more uh statements that are underneath

01:19:56,239 --> 01:19:59,679
that if then

01:19:57,280 --> 01:20:01,520
i don't uh give proper indentation right

01:19:59,679 --> 01:20:04,640
then how does python know

01:20:01,520 --> 01:20:06,560
which ones from under the else and which

01:20:04,640 --> 01:20:07,520
ones are outside the else it doesn't

01:20:06,560 --> 01:20:10,880
know right

01:20:07,520 --> 01:20:13,840
so the way that you tell python that

01:20:10,880 --> 01:20:14,159
my maximum is under the else is you give

01:20:13,840 --> 01:20:16,960
and

01:20:14,159 --> 01:20:18,639
gives four spaces and the print it

01:20:16,960 --> 01:20:19,679
doesn't have any indentation so it's

01:20:18,639 --> 01:20:22,800
outside

01:20:19,679 --> 01:20:24,719
the help okay does that make sense so

01:20:22,800 --> 01:20:25,760
indentations are really important in

01:20:24,719 --> 01:20:29,120
python

01:20:25,760 --> 01:20:32,400
they tell you uh like which

01:20:29,120 --> 01:20:34,639
part of the code some thing might

01:20:32,400 --> 01:20:37,199
belong to so the maximum is under the

01:20:34,639 --> 01:20:40,320
else the prince is not

01:20:37,199 --> 01:20:42,560
and sometimes you can also use

01:20:40,320 --> 01:20:43,600
two spaces to give indentations but

01:20:42,560 --> 01:20:48,320
usually four

01:20:43,600 --> 01:20:48,320
is more popular for python

01:20:48,960 --> 01:20:54,560
then uh you can have an if that

01:20:52,080 --> 01:20:55,440
doesn't have any else statement attached

01:20:54,560 --> 01:20:58,960
to it

01:20:55,440 --> 01:21:00,560
so you can have and if that's just

01:20:58,960 --> 01:21:03,199
like there's no else here that's just

01:21:00,560 --> 01:21:06,320
and one so

01:21:03,199 --> 01:21:06,960
uh you can check if a value is greater

01:21:06,320 --> 01:21:09,280
than

01:21:06,960 --> 01:21:10,800
another one and then you do something

01:21:09,280 --> 01:21:12,960
but if if it's not then

01:21:10,800 --> 01:21:14,239
you don't do anything so if i've done

01:21:12,960 --> 01:21:17,440
this

01:21:14,239 --> 01:21:18,080
then it prints the value because p right

01:21:17,440 --> 01:21:20,320
now is

01:21:18,080 --> 01:21:21,360
greater than a but if i change the

01:21:20,320 --> 01:21:23,360
values so that

01:21:21,360 --> 01:21:24,719
now it's the other way around it doesn't

01:21:23,360 --> 01:21:29,840
give me anything

01:21:24,719 --> 01:21:29,840
nothing happens right

01:21:30,800 --> 01:21:37,040
so um

01:21:33,920 --> 01:21:40,400
that's uh

01:21:37,040 --> 01:21:41,280
if uh as if statements and what if you

01:21:40,400 --> 01:21:43,199
have

01:21:41,280 --> 01:21:44,639
uh multiple conditions that you need to

01:21:43,199 --> 01:21:45,520
check so let's say you have one

01:21:44,639 --> 01:21:47,280
condition

01:21:45,520 --> 01:21:49,440
and you if that's true you need to do

01:21:47,280 --> 01:21:50,960
one thing if you have another condition

01:21:49,440 --> 01:21:53,199
that's true then you need to do another

01:21:50,960 --> 01:21:55,360
thing so you have multiple conditions

01:21:53,199 --> 01:21:57,760
and you want to do multiple things if

01:21:55,360 --> 01:21:59,920
if one of them is true and you use

01:21:57,760 --> 01:22:01,280
something that's known as an if else if

01:21:59,920 --> 01:22:04,639
statement so

01:22:01,280 --> 01:22:08,159
you say if b is greater than

01:22:04,639 --> 01:22:12,000
a then you print b than a

01:22:08,159 --> 01:22:13,920
else uh you you also want to check if b

01:22:12,000 --> 01:22:17,360
is equal to

01:22:13,920 --> 01:22:20,719
uh 20 so lf

01:22:17,360 --> 01:22:24,719
in python basically is short for elsif

01:22:20,719 --> 01:22:27,760
so this tells you uh this is basically

01:22:24,719 --> 01:22:29,199
another another condition and then the

01:22:27,760 --> 01:22:32,880
last one

01:22:29,199 --> 01:22:36,719
is if neither of these are true then

01:22:32,880 --> 01:22:36,719
you do this so

01:22:37,040 --> 01:22:41,199
to uh summarize you can use uh elsif's

01:22:40,400 --> 01:22:43,840
to

01:22:41,199 --> 01:22:45,199
compare a lot of different conditions

01:22:43,840 --> 01:22:48,639
and

01:22:45,199 --> 01:22:51,360
make make the make whichever

01:22:48,639 --> 01:22:52,000
choice you want to make in your program

01:22:51,360 --> 01:22:55,199
using

01:22:52,000 --> 01:22:58,320
uh these conditions so basically

01:22:55,199 --> 01:23:00,880
if elsif is used to uh if

01:22:58,320 --> 01:23:02,239
it's used to select a branch of

01:23:00,880 --> 01:23:05,199
instructions that you want

01:23:02,239 --> 01:23:07,199
your computer to follow based on

01:23:05,199 --> 01:23:09,040
whichever conditions that you give to it

01:23:07,199 --> 01:23:11,199
are true or not

01:23:09,040 --> 01:23:12,480
so and it doesn't need to be just three

01:23:11,199 --> 01:23:14,719
you can have as many

01:23:12,480 --> 01:23:15,679
alif as you want here you can add

01:23:14,719 --> 01:23:17,600
another one

01:23:15,679 --> 01:23:21,840
you can add as many as you want

01:23:17,600 --> 01:23:21,840
different conditions

01:23:22,800 --> 01:23:28,800
so now that you know about

01:23:25,920 --> 01:23:29,679
if i say can you write a program that

01:23:28,800 --> 01:23:32,800
would print

01:23:29,679 --> 01:23:34,400
the maximum of three given variables

01:23:32,800 --> 01:23:35,920
when you're ready you can click the

01:23:34,400 --> 01:23:39,120
answer to either solution

01:23:35,920 --> 01:23:41,360
but i really recommend you try this out

01:23:39,120 --> 01:23:42,320
first you don't look at the answer you

01:23:41,360 --> 01:23:44,480
try this out

01:23:42,320 --> 01:23:45,920
and see if you can write a program that

01:23:44,480 --> 01:23:47,199
would print the maximum of three

01:23:45,920 --> 01:23:50,880
variables

01:23:47,199 --> 01:23:53,360
so if i have

01:23:50,880 --> 01:23:56,080
a equal to something b equals to another

01:23:53,360 --> 01:23:57,760
variable and c is equal to 30 then

01:23:56,080 --> 01:24:00,840
you should be able to write a program

01:23:57,760 --> 01:24:03,840
that can find the maximum of the three

01:24:00,840 --> 01:24:03,840
variables

01:24:18,320 --> 01:24:22,880
also another thing to note is in python

01:24:21,120 --> 01:24:26,880
if you want

01:24:22,880 --> 01:24:28,639
to take a number uh as an input from

01:24:26,880 --> 01:24:31,040
the person that's running your code then

01:24:28,639 --> 01:24:34,480
you use this function that's called

01:24:31,040 --> 01:24:38,159
input you say input and

01:24:34,480 --> 01:24:38,159
enter the first number

01:24:39,199 --> 01:24:42,960
and then the second one

01:24:43,520 --> 01:24:45,840
use

01:24:59,520 --> 01:25:05,679
and when you do this you you'll get

01:25:02,800 --> 01:25:06,960
whatever value that the user enters so

01:25:05,679 --> 01:25:09,840
you can

01:25:06,960 --> 01:25:11,520
take input from the user using this

01:25:09,840 --> 01:25:14,719
thing so i can enter

01:25:11,520 --> 01:25:18,000
say 15 and enter 20

01:25:14,719 --> 01:25:21,920
4 and i can enter 78 and then

01:25:18,000 --> 01:25:23,679
those numbers they they're taken from

01:25:21,920 --> 01:25:26,880
the command prompt itself

01:25:23,679 --> 01:25:27,440
so they you can you can write programs

01:25:26,880 --> 01:25:29,760
that

01:25:27,440 --> 01:25:31,679
have variables that take values from the

01:25:29,760 --> 01:25:35,920
user so it doesn't have to be

01:25:31,679 --> 01:25:35,920
written in the program from the start

01:25:36,159 --> 01:25:39,520
when you take this input right it is

01:25:38,800 --> 01:25:42,239
given

01:25:39,520 --> 01:25:42,960
the variables as string so when you take

01:25:42,239 --> 01:25:44,880
this input

01:25:42,960 --> 01:25:46,000
a would be a string b would be a string

01:25:44,880 --> 01:25:49,520
and c would be a string

01:25:46,000 --> 01:25:54,159
so when you do uh if you try to do

01:25:49,520 --> 01:25:57,280
a operation on them you first have to

01:25:54,159 --> 01:26:00,880
uh you first have to

01:25:57,280 --> 01:26:01,280
convert them to in two integers so to do

01:26:00,880 --> 01:26:04,320
that

01:26:01,280 --> 01:26:06,320
you can use ink and you can uh

01:26:04,320 --> 01:26:08,320
you can use uh the ink function it

01:26:06,320 --> 01:26:11,440
basically takes in a string and it

01:26:08,320 --> 01:26:12,239
uh converts it to this uh the integer

01:26:11,440 --> 01:26:14,480
value

01:26:12,239 --> 01:26:16,480
and uh instead of using an interaction

01:26:14,480 --> 01:26:19,440
float would be more appropriate

01:26:16,480 --> 01:26:20,719
because you can have a tractional input

01:26:19,440 --> 01:26:25,040
as well so

01:26:20,719 --> 01:26:28,239
if you use the float function then

01:26:25,040 --> 01:26:30,560
it it converts the string to

01:26:28,239 --> 01:26:33,280
a float or any data type that you

01:26:30,560 --> 01:26:33,280
specify there

01:26:34,639 --> 01:26:37,679
so now if i run the program again and i

01:26:36,880 --> 01:26:41,040
type in

01:26:37,679 --> 01:26:43,280
my values they're going to be

01:26:41,040 --> 01:26:45,840
displayed as flow now you can see they

01:26:43,280 --> 01:26:48,960
have a 0.0

01:26:45,840 --> 01:26:52,000
so yeah now it's

01:26:48,960 --> 01:26:54,320
yeah you can try this problem and

01:26:52,000 --> 01:27:05,840
when you're ready with the solution you

01:26:54,320 --> 01:27:05,840
can move on

01:27:56,080 --> 01:28:01,840
thank you

01:28:12,840 --> 01:28:15,840


01:28:26,840 --> 01:28:29,840
okay

01:29:08,840 --> 01:29:11,840
okay

01:29:22,840 --> 01:29:25,840
okay

01:29:36,840 --> 01:29:39,840
okay

01:29:50,840 --> 01:29:53,840
questions

01:30:04,840 --> 01:30:07,840
okay

01:30:32,840 --> 01:30:35,840
oh

01:31:10,320 --> 01:31:15,360
okay if you've managed to write the

01:31:13,600 --> 01:31:16,719
solution and let's take a look at the

01:31:15,360 --> 01:31:20,560
answer

01:31:16,719 --> 01:31:23,120
so it's basically using

01:31:20,560 --> 01:31:24,159
uh an else if o and that should say alif

01:31:23,120 --> 01:31:31,199
not else if

01:31:24,159 --> 01:31:34,480
that's wrong yeah

01:31:31,199 --> 01:31:38,639
um so you

01:31:34,480 --> 01:31:41,760
you write if you first see if a

01:31:38,639 --> 01:31:44,159
is greater than b and c so

01:31:41,760 --> 01:31:45,120
you check if a is bigger than b and a is

01:31:44,159 --> 01:31:47,840
equal to c

01:31:45,120 --> 01:31:48,239
and if that's true then the maximum is a

01:31:47,840 --> 01:31:49,920
right

01:31:48,239 --> 01:31:52,239
if it's greater than both of the other

01:31:49,920 --> 01:31:54,639
numbers it's the maximum right

01:31:52,239 --> 01:31:55,679
if this is the second one is the same

01:31:54,639 --> 01:31:58,159
with the b

01:31:55,679 --> 01:31:58,960
so b is greater than c and b is higher

01:31:58,159 --> 01:32:00,480
than a

01:31:58,960 --> 01:32:02,639
if three is greater than both of the

01:32:00,480 --> 01:32:05,760
other numbers then is the maximum

01:32:02,639 --> 01:32:07,280
right so that's the case and if neither

01:32:05,760 --> 01:32:09,280
of these are true right then

01:32:07,280 --> 01:32:11,280
the only other possible case is that the

01:32:09,280 --> 01:32:14,400
c is the maximum number

01:32:11,280 --> 01:32:16,480
so if a and b are not the maximum then

01:32:14,400 --> 01:32:18,560
only c can be the maximum right because

01:32:16,480 --> 01:32:19,440
one of them has to be the maximum number

01:32:18,560 --> 01:32:23,040
so

01:32:19,440 --> 01:32:23,440
this is how you use if else if to find

01:32:23,040 --> 01:32:27,840
out

01:32:23,440 --> 01:32:27,840
the maximum of three numbers today

01:32:32,800 --> 01:32:39,360
okay then we come to loops and

01:32:36,239 --> 01:32:41,679
loops basically they allow you to

01:32:39,360 --> 01:32:42,719
repeat an instruction again and again

01:32:41,679 --> 01:32:46,159
and again

01:32:42,719 --> 01:32:49,360
and like so

01:32:46,159 --> 01:32:52,080
loops is quite something that you you

01:32:49,360 --> 01:32:53,360
you do in everyday life as well so there

01:32:52,080 --> 01:32:55,760
are times when you

01:32:53,360 --> 01:32:57,040
want to repeat a certain action and you

01:32:55,760 --> 01:32:58,880
kind of use a loop

01:32:57,040 --> 01:33:01,120
for example let's say you're playing a

01:32:58,880 --> 01:33:01,840
game and you're in a boss fight or

01:33:01,120 --> 01:33:04,400
something and

01:33:01,840 --> 01:33:05,199
you're not managing to pass the level

01:33:04,400 --> 01:33:07,520
that

01:33:05,199 --> 01:33:08,400
you'd say while you have not defeated

01:33:07,520 --> 01:33:11,120
the boss then

01:33:08,400 --> 01:33:13,280
you try again right so while you're

01:33:11,120 --> 01:33:15,600
stuck at the level you keep trying again

01:33:13,280 --> 01:33:16,480
trying again until you uh make it

01:33:15,600 --> 01:33:18,480
through

01:33:16,480 --> 01:33:21,280
and let's say you want to write the two

01:33:18,480 --> 01:33:23,920
times table and say two

01:33:21,280 --> 01:33:26,239
the two times table then you would say

01:33:23,920 --> 01:33:27,280
something like for every number between

01:33:26,239 --> 01:33:28,960
one and ten

01:33:27,280 --> 01:33:31,040
like two times the number so that would

01:33:28,960 --> 01:33:33,679
give you the two times table right

01:33:31,040 --> 01:33:35,040
so it's something that you do again and

01:33:33,679 --> 01:33:37,520
again and again and again

01:33:35,040 --> 01:33:38,400
and only some things change so you use a

01:33:37,520 --> 01:33:41,760
loop

01:33:38,400 --> 01:33:42,800
and the same idea is like it comes over

01:33:41,760 --> 01:33:45,840
to programming

01:33:42,800 --> 01:33:48,840
and in python we have these two things

01:33:45,840 --> 01:33:51,440
known as a while loop and a for loop

01:33:48,840 --> 01:33:54,639
and the while loop basically

01:33:51,440 --> 01:33:56,000
repeatedly executes a block of code as

01:33:54,639 --> 01:33:59,199
long as a condition

01:33:56,000 --> 01:34:02,159
is true so it's literally while

01:33:59,199 --> 01:34:03,679
something is true then it'll execute the

01:34:02,159 --> 01:34:08,159
instructions inside

01:34:03,679 --> 01:34:08,159
so for this one

01:34:10,400 --> 01:34:16,080
while a is less than 10 it will

01:34:13,760 --> 01:34:17,280
keep running the code so what will

01:34:16,080 --> 01:34:20,320
happen is it will print

01:34:17,280 --> 01:34:23,280
the value of a then add 1 to a

01:34:20,320 --> 01:34:26,239
and it will do that until a becomes 10.

01:34:23,280 --> 01:34:26,239
so if i run this

01:34:28,800 --> 01:34:33,840
oh there's a mistake here it should be

01:34:34,320 --> 01:34:40,639
so we do this

01:34:38,159 --> 01:34:41,760
and it gives you all the numbers from 0

01:34:40,639 --> 01:34:44,000
all the way to 9

01:34:41,760 --> 01:34:45,360
and know that since i used a is less

01:34:44,000 --> 01:34:48,000
than 10

01:34:45,360 --> 01:34:49,520
10 is not included in the final result

01:34:48,000 --> 01:34:51,760
because

01:34:49,520 --> 01:34:53,040
10 is it's not less than 10 is equal to

01:34:51,760 --> 01:34:57,440
10 so

01:34:53,040 --> 01:34:59,760
on that case the condition fails and

01:34:57,440 --> 01:35:00,560
if i print the value of a outside the

01:34:59,760 --> 01:35:04,400
loop

01:35:00,560 --> 01:35:07,520
you'll see that it's 10. so if i print a

01:35:04,400 --> 01:35:10,800
then it gives me 10. so

01:35:07,520 --> 01:35:14,320
when this condition becomes false then

01:35:10,800 --> 01:35:17,040
your it stops looping whatever you have

01:35:14,320 --> 01:35:17,040
inside the block

01:35:23,199 --> 01:35:26,560
so now that you know about the while

01:35:25,920 --> 01:35:29,280
loop

01:35:26,560 --> 01:35:32,159
can you print the following pattern up

01:35:29,280 --> 01:35:32,159
to fifteen terms

01:35:38,159 --> 01:35:43,840
sorry trying to figure out

01:35:49,440 --> 01:35:53,520
so if you if you don't want to see the

01:35:51,440 --> 01:35:55,119
full solution but you want the end for a

01:35:53,520 --> 01:35:56,880
pattern you can click him and it will

01:35:55,119 --> 01:35:58,320
tell you what the pattern is

01:35:56,880 --> 01:35:59,840
but it will not show you the complete

01:35:58,320 --> 01:36:02,320
answer so if you want to do that you can

01:35:59,840 --> 01:36:02,320
kick him

01:36:03,760 --> 01:36:08,400
but i recommend trying to figure it out

01:36:06,639 --> 01:36:11,840
on your own first if you really can't

01:36:08,400 --> 01:36:11,840
then you look at the hint

01:37:20,000 --> 01:37:35,360
and wait for two more minutes while you

01:37:21,760 --> 01:37:49,840
try and then move on

01:37:35,360 --> 01:37:49,840
you can look at the hint

01:38:42,840 --> 01:38:45,840
okay

01:39:03,199 --> 01:39:09,840
okay if uh i think it should

01:39:06,400 --> 01:39:12,239
uh move on if you manage to solve the

01:39:09,840 --> 01:39:13,760
problem then that's good if not then

01:39:12,239 --> 01:39:17,040
we'll go over the solution

01:39:13,760 --> 01:39:20,320
now so basically

01:39:17,040 --> 01:39:21,280
the way to do this is you need to notice

01:39:20,320 --> 01:39:24,800
that a pattern

01:39:21,280 --> 01:39:27,199
to the numbers is that each time the

01:39:24,800 --> 01:39:28,960
increment of the numbers or the amount

01:39:27,199 --> 01:39:32,400
by which they increase it also

01:39:28,960 --> 01:39:35,199
increases by one so the first time

01:39:32,400 --> 01:39:35,760
you add one you get two the second time

01:39:35,199 --> 01:39:38,000
you add

01:39:35,760 --> 01:39:38,880
two to two you get four the third time

01:39:38,000 --> 01:39:41,520
you add three

01:39:38,880 --> 01:39:42,400
you get seven then you add four you get

01:39:41,520 --> 01:39:44,880
eleven you get

01:39:42,400 --> 01:39:45,840
add five you get sixteen so each time

01:39:44,880 --> 01:39:48,880
you're adding

01:39:45,840 --> 01:39:52,840
a bigger number than before

01:39:48,880 --> 01:39:55,119
and the way that you would write this

01:39:52,840 --> 01:39:58,719
is basically you

01:39:55,119 --> 01:40:01,920
also keep track of the increase and then

01:39:58,719 --> 01:40:04,960
you start at one and each time you

01:40:01,920 --> 01:40:08,560
increase the number by the increase

01:40:04,960 --> 01:40:12,400
and you increase the that value itself

01:40:08,560 --> 01:40:16,159
as well so now if i i run this

01:40:12,400 --> 01:40:16,159
it'll print the

01:40:16,320 --> 01:40:24,080
pattern that oh oh well this

01:40:19,600 --> 01:40:27,040
should be string not so

01:40:24,080 --> 01:40:28,080
an important thing to know is in python

01:40:27,040 --> 01:40:30,480
you can't

01:40:28,080 --> 01:40:31,600
concatenate a string and an integer so

01:40:30,480 --> 01:40:34,480
if you have

01:40:31,600 --> 01:40:36,000
an integer and a string you can't

01:40:34,480 --> 01:40:38,000
combine them using the plus

01:40:36,000 --> 01:40:39,600
operation that will give you an error

01:40:38,000 --> 01:40:42,400
and that's what happened here

01:40:39,600 --> 01:40:43,119
so to fix this you would need to convert

01:40:42,400 --> 01:40:46,159
the

01:40:43,119 --> 01:40:51,840
in to a string and you do that

01:40:46,159 --> 01:40:51,840
using the str function

01:40:55,119 --> 01:40:58,560
look now that

01:41:02,840 --> 01:41:05,840
yes

01:41:45,360 --> 01:41:52,880
okay let's move on to the for loop

01:41:48,639 --> 01:41:55,119
so uh for statement is specifically used

01:41:52,880 --> 01:41:58,560
to loop over a range of values

01:41:55,119 --> 01:42:02,080
in python so

01:41:58,560 --> 01:42:04,560
let's say you want to print numbers

01:42:02,080 --> 01:42:07,520
in a particular range then you use a for

01:42:04,560 --> 01:42:07,520
statement to do that

01:42:09,119 --> 01:42:15,760
so uh i can type for a in

01:42:12,400 --> 01:42:18,960
range 2 23 and then print

01:42:15,760 --> 01:42:22,719
and once again this should be

01:42:18,960 --> 01:42:26,400
it should say str

01:42:22,719 --> 01:42:29,760
um to say str

01:42:26,400 --> 01:42:32,800
not just it so that doesn't work so

01:42:29,760 --> 01:42:36,480
uh yeah so this one it

01:42:32,800 --> 01:42:38,719
it starts at 2 and it ends at 22. so

01:42:36,480 --> 01:42:39,840
then the number the ending point that

01:42:38,719 --> 01:42:42,800
you specify is not

01:42:39,840 --> 01:42:43,440
included in the range so it will go from

01:42:42,800 --> 01:42:46,719
01:42:43,440 --> 01:42:50,080
3 all the way to 22 so

01:42:46,719 --> 01:42:52,880
if i comment out the others and just

01:42:50,080 --> 01:42:57,840
print this one you see it goes from 2

01:42:52,880 --> 01:42:57,840
all the way to 22.

01:42:58,159 --> 01:43:02,159
then the next one is you can also go

01:43:00,639 --> 01:43:05,760
backwards so if you want to go

01:43:02,159 --> 01:43:08,239
from 10 9876

01:43:05,760 --> 01:43:09,360
all the way to zero then you can also do

01:43:08,239 --> 01:43:11,280
that

01:43:09,360 --> 01:43:13,760
note that the 0 here is also not

01:43:11,280 --> 01:43:17,280
included so it would end at 1

01:43:13,760 --> 01:43:17,280
yes if i print

01:43:21,119 --> 01:43:27,920
oh i i also yeah no i saved but

01:43:24,639 --> 01:43:29,520
i forgot to specify the i also need to

01:43:27,920 --> 01:43:31,119
specify that it has to go in the

01:43:29,520 --> 01:43:32,159
opposite direction i forgot to write

01:43:31,119 --> 01:43:33,920
minus one

01:43:32,159 --> 01:43:35,520
so when you want to go in the opposite

01:43:33,920 --> 01:43:37,280
direction or in

01:43:35,520 --> 01:43:39,280
the opposite direction you need to say

01:43:37,280 --> 01:43:42,400
minus one in the

01:43:39,280 --> 01:43:45,520
step so basically the range

01:43:42,400 --> 01:43:48,080
it takes three values it takes

01:43:45,520 --> 01:43:50,159
a starting point it takes an ending

01:43:48,080 --> 01:43:52,560
point and it takes a step

01:43:50,159 --> 01:43:54,320
and basically the step tells you how

01:43:52,560 --> 01:43:57,440
much to add to the stack

01:43:54,320 --> 01:44:00,320
until you get to the end and uh

01:43:57,440 --> 01:44:02,800
if you don't specify the step then it's

01:44:00,320 --> 01:44:06,400
automatically chosen as plus one

01:44:02,800 --> 01:44:09,119
so if i did ten comma zero then

01:44:06,400 --> 01:44:09,760
it wouldn't work because it's like 10 is

01:44:09,119 --> 01:44:12,239
already

01:44:09,760 --> 01:44:13,520
greater than 0 so it would it would not

01:44:12,239 --> 01:44:17,199
increase

01:44:13,520 --> 01:44:20,400
so you need to specify minus 1 there

01:44:17,199 --> 01:44:23,280
and this should give me values all the

01:44:20,400 --> 01:44:25,520
way from 10 to 1.

01:44:23,280 --> 01:44:25,520
so

01:44:27,679 --> 01:44:34,480
sorry but

01:44:36,800 --> 01:44:41,679
so by default it would be just plus one

01:44:43,440 --> 01:44:48,159
so you can have any number as the step

01:44:45,920 --> 01:44:49,760
size here so it works similar to how

01:44:48,159 --> 01:44:54,800
slicing works but

01:44:49,760 --> 01:44:54,800
it's with numbers so you could have uh

01:44:55,520 --> 01:44:59,199
10 0 minus 3 and it will start at 10 and

01:44:58,000 --> 01:45:02,400
it subtract 3

01:44:59,199 --> 01:45:05,440
and so it skips every two numbers so

01:45:02,400 --> 01:45:09,440
oh wait what so i've

01:45:05,440 --> 01:45:12,560
uncommented the comment by mistake

01:45:09,440 --> 01:45:13,280
so uh you get when you do when you run

01:45:12,560 --> 01:45:15,920
this

01:45:13,280 --> 01:45:17,520
you you get 10 then you subtract three

01:45:15,920 --> 01:45:19,440
get seven subtract three get four

01:45:17,520 --> 01:45:22,480
subtract so you get one

01:45:19,440 --> 01:45:24,800
so the values decrease in a decrement of

01:45:22,480 --> 01:45:24,800
three

01:45:26,080 --> 01:45:30,280
you can use any any kind of step size

01:45:28,960 --> 01:45:33,840
that you would want you can use

01:45:30,280 --> 01:45:37,119
005 and go all the way from 0 5

01:45:33,840 --> 01:45:40,400
15 all the way to 90

01:45:37,119 --> 01:45:41,040
4 can be all you can also use for loops

01:45:40,400 --> 01:45:43,600
to

01:45:41,040 --> 01:45:45,280
go through all the elements of a list a

01:45:43,600 --> 01:45:47,600
tuple or a dictionary

01:45:45,280 --> 01:45:49,440
so if you have a list if you have a

01:45:47,600 --> 01:45:51,679
tuple or if you have a dictionary

01:45:49,440 --> 01:45:53,520
using the for loop it will go through

01:45:51,679 --> 01:45:59,840
each of the values one by one

01:45:53,520 --> 01:45:59,840
so this one

01:45:59,920 --> 01:46:06,320
if i print it goes it like it takes

01:46:03,760 --> 01:46:08,159
five it gets assigned a number and then

01:46:06,320 --> 01:46:10,080
you print the numbers with five

01:46:08,159 --> 01:46:12,000
then it takes the second one which is

01:46:10,080 --> 01:46:14,880
three gets assigned to number and

01:46:12,000 --> 01:46:16,880
prints the numbers 3 just with it and

01:46:14,880 --> 01:46:18,880
all the way to the end of the list

01:46:16,880 --> 01:46:20,159
is the same with a tuple if i have a

01:46:18,880 --> 01:46:23,440
tuple and

01:46:20,159 --> 01:46:26,480
you can print

01:46:23,440 --> 01:46:28,480
all the values in a tuple using for loop

01:46:26,480 --> 01:46:30,239
and it's the same thing with a

01:46:28,480 --> 01:46:32,880
dictionary

01:46:30,239 --> 01:46:33,920
if you have a dictionary then looping

01:46:32,880 --> 01:46:36,000
with for

01:46:33,920 --> 01:46:37,440
it'll go through all the keys of the

01:46:36,000 --> 01:46:39,199
dictionary it doesn't go through the

01:46:37,440 --> 01:46:40,480
values it goes through the keys of the

01:46:39,199 --> 01:46:42,639
dictionary

01:46:40,480 --> 01:46:42,639
so

01:46:43,600 --> 01:46:48,800
here if you want to print the values of

01:46:45,840 --> 01:46:50,800
the dictionary you would have to

01:46:48,800 --> 01:46:51,840
actually give the key to the dictionary

01:46:50,800 --> 01:46:55,520
to be able to

01:46:51,840 --> 01:46:59,440
get both the value as well as the key

01:46:55,520 --> 01:47:01,920
if i just use k then

01:46:59,440 --> 01:47:03,280
i don't get the values of dictionary i

01:47:01,920 --> 01:47:09,840
just get

01:47:03,280 --> 01:47:09,840
i just get the keys which is

01:47:10,960 --> 01:47:16,880
3.14 high

01:47:14,080 --> 01:47:23,840
and spongebob so i don't get the values

01:47:16,880 --> 01:47:23,840
associated with them

01:47:28,159 --> 01:47:32,560
so to get the value as well you need to

01:47:30,719 --> 01:47:36,560
specify

01:47:32,560 --> 01:47:38,239
both of them so if you want to

01:47:36,560 --> 01:47:40,400
get the values there's actually another

01:47:38,239 --> 01:47:43,840
way to do it so you can say

01:47:40,400 --> 01:47:46,560
dictionary dot for values and this

01:47:43,840 --> 01:47:48,159
would give you the values now so if i

01:47:46,560 --> 01:47:50,159
print

01:47:48,159 --> 01:47:52,639
this would give me all the values in the

01:47:50,159 --> 01:47:52,639
dictionary

01:47:52,880 --> 01:47:56,000
and using the same way you can do

01:47:55,199 --> 01:47:58,080
dictionary dot

01:47:56,000 --> 01:47:59,280
keys i will give you all the keys of the

01:47:58,080 --> 01:48:01,119
dictionary but

01:47:59,280 --> 01:48:03,040
it's just kind of redundant because even

01:48:01,119 --> 01:48:04,480
without the keys you get the key so you

01:48:03,040 --> 01:48:08,239
don't need to do this

01:48:04,480 --> 01:48:12,800
and if you want to get both the

01:48:08,239 --> 01:48:12,800
key and the value you use

01:48:13,520 --> 01:48:19,119
dot items which gives you

01:48:16,639 --> 01:48:21,440
every key value pair and it gives you

01:48:19,119 --> 01:48:22,719
the key value pair as a tuple so if i

01:48:21,440 --> 01:48:25,679
print key

01:48:22,719 --> 01:48:28,000
it'll print each of the p value pair in

01:48:25,679 --> 01:48:31,760
the dictionary as a tuple

01:48:28,000 --> 01:48:35,280
so i could say here

01:48:31,760 --> 01:48:38,639
key comma value and that would give me

01:48:35,280 --> 01:48:38,639
and i didn't print the value

01:48:39,920 --> 01:48:44,239
this would give me the key and the value

01:48:42,320 --> 01:48:47,440
pairs as well

01:48:44,239 --> 01:48:49,920
does this make sense so

01:48:47,440 --> 01:48:51,760
with tuples you can do this thing in

01:48:49,920 --> 01:48:54,159
python that's known as tuple

01:48:51,760 --> 01:48:55,199
unpacking if i just comment this out for

01:48:54,159 --> 01:48:59,119
a second

01:48:55,199 --> 01:48:59,119
if you have a tuple that has

01:48:59,600 --> 01:49:03,440
multiple uh values inside you can assign

01:49:02,639 --> 01:49:05,679
them to

01:49:03,440 --> 01:49:06,480
variables using this thing known as

01:49:05,679 --> 01:49:10,560
tuple

01:49:06,480 --> 01:49:10,560
unpacking so you can say

01:49:13,040 --> 01:49:18,000
uh b comma c comma d is equal to a and

01:49:16,159 --> 01:49:18,320
then the first element gets assigned to

01:49:18,000 --> 01:49:20,000
b

01:49:18,320 --> 01:49:21,840
the second one gets assigned to c the

01:49:20,000 --> 01:49:26,840
third one gets assigned to b

01:49:21,840 --> 01:49:29,840
that makes sense so now if

01:49:26,840 --> 01:49:32,080
we c and

01:49:29,840 --> 01:49:32,080
k

01:49:33,199 --> 01:49:36,239
i get one two three

01:49:36,560 --> 01:49:41,679
so when you do uh the same thing in the

01:49:39,599 --> 01:49:44,080
for loop

01:49:41,679 --> 01:49:44,719
with the dictionary the degree of items

01:49:44,080 --> 01:49:46,719
is

01:49:44,719 --> 01:49:49,280
it's the three value pair inside of

01:49:46,719 --> 01:49:52,320
people and you use this thing called

01:49:49,280 --> 01:49:53,679
typing to give the key to it assigns the

01:49:52,320 --> 01:49:55,440
key to the first one

01:49:53,679 --> 01:49:58,080
and a value to the second one and then

01:49:55,440 --> 01:49:58,080
you print them

01:50:03,040 --> 01:50:08,239
okay so that's all about loops and

01:50:06,000 --> 01:50:11,840
conditions and flow control in python

01:50:08,239 --> 01:50:11,840
then we move on to functions

01:50:12,400 --> 01:50:17,280
so basically functions are also a really

01:50:16,159 --> 01:50:19,199
important part

01:50:17,280 --> 01:50:20,719
of any programming language it's not

01:50:19,199 --> 01:50:23,679
just python

01:50:20,719 --> 01:50:25,199
so let's say you're watching tv and you

01:50:23,679 --> 01:50:27,920
want to change the channel

01:50:25,199 --> 01:50:29,440
on the tv you every time you want to

01:50:27,920 --> 01:50:30,000
change the channel you'll use the same

01:50:29,440 --> 01:50:32,960
remote

01:50:30,000 --> 01:50:33,840
right if you can it doesn't make sense

01:50:32,960 --> 01:50:35,760
for you to get

01:50:33,840 --> 01:50:36,960
a new remote every time you want to

01:50:35,760 --> 01:50:40,719
change the channel that

01:50:36,960 --> 01:50:42,239
would be quite wasteful so similarly in

01:50:40,719 --> 01:50:45,040
programming right when you want

01:50:42,239 --> 01:50:46,800
to write a piece of code that you know

01:50:45,040 --> 01:50:49,760
you want to use many times

01:50:46,800 --> 01:50:51,199
then instead of writing it out many

01:50:49,760 --> 01:50:53,840
times

01:50:51,199 --> 01:50:54,639
in all the different places you write

01:50:53,840 --> 01:50:57,679
what

01:50:54,639 --> 01:50:58,560
is known as a function and basically the

01:50:57,679 --> 01:51:01,040
function

01:50:58,560 --> 01:51:03,040
you can reuse the same piece of code

01:51:01,040 --> 01:51:07,119
anywhere that you want

01:51:03,040 --> 01:51:07,599
so for example i have a program here

01:51:07,119 --> 01:51:12,000
that

01:51:07,599 --> 01:51:13,840
finds the maximum number in a list and

01:51:12,000 --> 01:51:15,360
this is okay if you want to find the

01:51:13,840 --> 01:51:17,440
maximum of one

01:51:15,360 --> 01:51:19,920
list but let's say i have 100 different

01:51:17,440 --> 01:51:21,040
lists and i want to find out the maximum

01:51:19,920 --> 01:51:23,360
in every list

01:51:21,040 --> 01:51:24,880
is it feasible to write the same code

01:51:23,360 --> 01:51:27,360
100 different times

01:51:24,880 --> 01:51:28,320
no right you you you don't want to do

01:51:27,360 --> 01:51:31,520
that

01:51:28,320 --> 01:51:34,560
so the way

01:51:31,520 --> 01:51:36,080
you you you do that more effectively is

01:51:34,560 --> 01:51:39,599
using functions

01:51:36,080 --> 01:51:41,679
so instead

01:51:39,599 --> 01:51:42,719
now you write the same code inside the

01:51:41,679 --> 01:51:45,280
function

01:51:42,719 --> 01:51:47,119
and now you can reuse it as many times

01:51:45,280 --> 01:51:50,639
as you like so

01:51:47,119 --> 01:51:53,599
uh basically this line uh

01:51:50,639 --> 01:51:54,800
at here is is known as a function

01:51:53,599 --> 01:51:57,760
prototype

01:51:54,800 --> 01:51:58,239
and it's what defines a function so the

01:51:57,760 --> 01:52:01,440
depth

01:51:58,239 --> 01:52:04,560
right here like this def it

01:52:01,440 --> 01:52:08,159
um it's it's short for define

01:52:04,560 --> 01:52:10,159
so you're defining a function here and

01:52:08,159 --> 01:52:12,320
max value this is the name of the

01:52:10,159 --> 01:52:14,480
function so you're saying

01:52:12,320 --> 01:52:16,159
uh i'm defining a function that is

01:52:14,480 --> 01:52:19,520
called max value

01:52:16,159 --> 01:52:20,239
and this takes in a list of numbers so

01:52:19,520 --> 01:52:22,639
you take in

01:52:20,239 --> 01:52:24,000
a list of numbers which now you're now

01:52:22,639 --> 01:52:28,480
going to find the maximum

01:52:24,000 --> 01:52:28,480
of okay does make sense

01:52:28,840 --> 01:52:34,560
so now you can

01:52:31,520 --> 01:52:37,599
find the maximum value in this list and

01:52:34,560 --> 01:52:40,400
once you find the maximum value you use

01:52:37,599 --> 01:52:42,560
this thing known as a return and you

01:52:40,400 --> 01:52:45,360
return the maximum value

01:52:42,560 --> 01:52:46,719
to wherever the function is called so

01:52:45,360 --> 01:52:51,440
let's say

01:52:46,719 --> 01:52:54,880
i copy this code in here

01:52:51,440 --> 01:52:55,760
and now i have three different lists

01:52:54,880 --> 01:52:58,480
here

01:52:55,760 --> 01:53:00,480
and i'll find the maximum to find a

01:52:58,480 --> 01:53:02,000
maximum in each different list

01:53:00,480 --> 01:53:03,679
all i need to do is just call the

01:53:02,000 --> 01:53:07,520
function using that list

01:53:03,679 --> 01:53:09,440
so the first one i call the function

01:53:07,520 --> 01:53:11,199
using the function's name and then i

01:53:09,440 --> 01:53:12,480
give it the list that i want to find the

01:53:11,199 --> 01:53:15,520
maximum off

01:53:12,480 --> 01:53:16,400
and it'll it'll find the maximum for me

01:53:15,520 --> 01:53:18,320
basically and

01:53:16,400 --> 01:53:20,000
this you can see like i don't have to

01:53:18,320 --> 01:53:22,080
rewrite the same code three different

01:53:20,000 --> 01:53:24,159
times you just use the function

01:53:22,080 --> 01:53:25,440
it's more convenient to do it this way

01:53:24,159 --> 01:53:28,480
it also makes

01:53:25,440 --> 01:53:29,679
your code more modular and it more it's

01:53:28,480 --> 01:53:33,199
more readable

01:53:29,679 --> 01:53:36,080
so let's say i have

01:53:33,199 --> 01:53:36,880
this list here right and i want to sort

01:53:36,080 --> 01:53:41,760
the list

01:53:36,880 --> 01:53:44,719
if i write code to sort the list then

01:53:41,760 --> 01:53:45,440
is not uh as effective because if

01:53:44,719 --> 01:53:48,960
somebody

01:53:45,440 --> 01:53:50,239
is reading your code at a glance then

01:53:48,960 --> 01:53:51,920
they'll have to first read and

01:53:50,239 --> 01:53:53,440
understand and then they'll know that

01:53:51,920 --> 01:53:55,920
okay this is this code is

01:53:53,440 --> 01:53:57,280
sorting the list but if you just write

01:53:55,920 --> 01:53:59,599
list dot sort

01:53:57,280 --> 01:54:00,800
it's immediately obvious that the list

01:53:59,599 --> 01:54:03,840
is going to get sorted

01:54:00,800 --> 01:54:06,960
so uh functions are

01:54:03,840 --> 01:54:09,760
really really useful and

01:54:06,960 --> 01:54:12,639
you should use them as much as you can

01:54:09,760 --> 01:54:12,639
when you write code

01:54:13,199 --> 01:54:17,920
so if i run this it'll find the three

01:54:16,560 --> 01:54:21,760
maximum values

01:54:17,920 --> 01:54:24,960
in the list which is 88 in this one

01:54:21,760 --> 01:54:28,960
it's 90 in this one and 96 in this one

01:54:24,960 --> 01:54:28,960
so 88 1996

01:54:29,760 --> 01:54:34,719
then a function doesn't have to

01:54:32,880 --> 01:54:36,880
necessarily return a value

01:54:34,719 --> 01:54:38,719
it it it doesn't need to have this

01:54:36,880 --> 01:54:41,840
return statement

01:54:38,719 --> 01:54:44,320
so you can have an element

01:54:41,840 --> 01:54:46,480
you can have a function that just just

01:54:44,320 --> 01:54:47,520
does stuff but doesn't actually return a

01:54:46,480 --> 01:54:49,599
value

01:54:47,520 --> 01:54:52,560
so this is just going to print out all

01:54:49,599 --> 01:54:52,560
the different lists

01:54:55,599 --> 01:55:00,800
and i didn't save the file

01:54:58,960 --> 01:55:02,239
now it prints out all of the different

01:55:00,800 --> 01:55:05,040
lists

01:55:02,239 --> 01:55:07,360
what's this none why do i get a none

01:55:05,040 --> 01:55:10,000
value here

01:55:07,360 --> 01:55:10,960
i'm printing out all the lists but none

01:55:10,000 --> 01:55:13,599
doesn't make sense

01:55:10,960 --> 01:55:16,000
there's no none in my list why is there

01:55:13,599 --> 01:55:16,000
a none

01:55:16,840 --> 01:55:20,239
here

01:55:18,480 --> 01:55:22,480
this is because remember that the

01:55:20,239 --> 01:55:24,159
function is not returning anything

01:55:22,480 --> 01:55:26,719
and i'm printing the value of the

01:55:24,159 --> 01:55:28,800
function and when i do that

01:55:26,719 --> 01:55:30,719
it it doesn't actually have anything to

01:55:28,800 --> 01:55:31,199
print because my function didn't return

01:55:30,719 --> 01:55:34,639
anything

01:55:31,199 --> 01:55:36,000
so it just prints none

01:55:34,639 --> 01:55:37,679
because it doesn't have anything to

01:55:36,000 --> 01:55:40,159
print so

01:55:37,679 --> 01:55:41,679
you should remember that if a function

01:55:40,159 --> 01:55:46,239
doesn't have a return type

01:55:41,679 --> 01:55:49,760
or any returning statements then

01:55:46,239 --> 01:55:49,760
it doesn't give you any values

01:55:56,719 --> 01:56:01,199
also note that if you encounter a return

01:56:00,400 --> 01:56:03,599
statement

01:56:01,199 --> 01:56:04,639
anywhere in the function then the rest

01:56:03,599 --> 01:56:07,520
of its code

01:56:04,639 --> 01:56:08,480
does not get executed so as soon as you

01:56:07,520 --> 01:56:11,760
reach the

01:56:08,480 --> 01:56:14,320
return line it just skips

01:56:11,760 --> 01:56:15,840
everything that comes after so if i have

01:56:14,320 --> 01:56:18,239
this code

01:56:15,840 --> 01:56:18,239
then

01:56:19,199 --> 01:56:22,639
if i write this then it would just give

01:56:21,920 --> 01:56:25,679
me 10

01:56:22,639 --> 01:56:28,400
which is it it skips everything that

01:56:25,679 --> 01:56:32,239
comes after the return statement

01:56:28,400 --> 01:56:35,360
so that's

01:56:32,239 --> 01:56:36,639
functions and now that we know about

01:56:35,360 --> 01:56:39,040
functions

01:56:36,639 --> 01:56:40,960
can you write a function to calculate

01:56:39,040 --> 01:56:43,119
the factorial of a number

01:56:40,960 --> 01:56:45,520
use the function that you derive to then

01:56:43,119 --> 01:56:49,440
find the factorial of the first

01:56:45,520 --> 01:56:52,719
20 numbers okay let's take five minutes

01:56:49,440 --> 01:56:52,719
to try and do this problem

01:56:53,520 --> 01:56:57,520
and if you don't know what a factorial

01:56:55,280 --> 01:56:58,800
of a number is factorial of a number is

01:56:57,520 --> 01:57:01,679
given by

01:56:58,800 --> 01:57:02,320
the product of all of the numbers that

01:57:01,679 --> 01:57:05,119
are

01:57:02,320 --> 01:57:05,920
less than it until one so 5 factorial

01:57:05,119 --> 01:57:10,159
would be 5

01:57:05,920 --> 01:57:13,520
4 5 times 4 times 3 times 2 times 1.

01:57:10,159 --> 01:57:16,000
3 factorial would be 3 times 2 times 1

01:57:13,520 --> 01:57:16,719
so we can find the factorial of a number

01:57:16,000 --> 01:57:25,840
that's

01:57:16,719 --> 01:57:25,840
given by this formula

01:57:30,800 --> 01:57:35,280
so factorial of 20 would be 20 times 19

01:57:33,920 --> 01:57:53,840
times 18 times

01:57:35,280 --> 01:57:53,840
17 times 16 all let me do one

01:58:04,840 --> 01:58:07,840
wow

01:58:18,840 --> 01:58:21,840
see

01:59:04,880 --> 01:59:09,119
okay uh if you manage to solve the

01:59:07,840 --> 01:59:11,040
problem then that's

01:59:09,119 --> 01:59:13,760
nice if not then we'll go over the

01:59:11,040 --> 01:59:13,760
solution now

01:59:14,840 --> 01:59:17,840
so

01:59:32,880 --> 01:59:39,840
so basically we write a function

01:59:36,480 --> 01:59:43,280
that's called factorial and it takes in

01:59:39,840 --> 01:59:46,239
a variable called k and then

01:59:43,280 --> 01:59:46,560
we also define another variable called

01:59:46,239 --> 01:59:50,080
uh

01:59:46,560 --> 01:59:51,199
factor that's used to calculate the

01:59:50,080 --> 01:59:54,719
factorial

01:59:51,199 --> 01:59:58,719
so next you say for

01:59:54,719 --> 02:00:01,840
i in range of one to a plus one

01:59:58,719 --> 02:00:04,080
so basically from one to whatever number

02:00:01,840 --> 02:00:06,880
that you've been given so instead of

02:00:04,080 --> 02:00:12,239
writing ax you should use

02:00:06,880 --> 02:00:14,880
number to be more clear

02:00:12,239 --> 02:00:15,679
so now uh it's going from one all the

02:00:14,880 --> 02:00:18,400
way to

02:00:15,679 --> 02:00:19,119
the number so it's going to multiply

02:00:18,400 --> 02:00:22,400
every

02:00:19,119 --> 02:00:24,000
number to factor and it's going to

02:00:22,400 --> 02:00:27,040
return that so

02:00:24,000 --> 02:00:30,560
is when you do this let's say if number

02:00:27,040 --> 02:00:34,159
was uh equal to five

02:00:30,560 --> 02:00:35,440
then um your for loop would look

02:00:34,159 --> 02:00:38,880
something like

02:00:35,440 --> 02:00:42,719
for i in range one two

02:00:38,880 --> 02:00:44,400
six and then this would be so

02:00:42,719 --> 02:00:46,000
initially your i would be one so it

02:00:44,400 --> 02:00:49,360
would multiply one that's

02:00:46,000 --> 02:00:52,080
just one then it would be that i

02:00:49,360 --> 02:00:54,800
would become two and it would multiply

02:00:52,080 --> 02:00:58,159
two to factor which should make it 2

02:00:54,800 --> 02:01:00,400
then i would become 3

02:00:58,159 --> 02:01:01,840
and then 3 is multiplied to factor which

02:01:00,400 --> 02:01:04,560
becomes 6

02:01:01,840 --> 02:01:05,199
so if that goes on and on until 5 and

02:01:04,560 --> 02:01:09,840
you get

02:01:05,199 --> 02:01:09,840
120 so

02:01:19,840 --> 02:01:23,840
i have

02:01:24,400 --> 02:01:29,599
so what happens first is i have

02:01:30,719 --> 02:01:36,800
i have one for factor for finding range

02:01:33,920 --> 02:01:37,760
one to the number so it goes from one

02:01:36,800 --> 02:01:41,440
whatever the number

02:01:37,760 --> 02:01:44,560
the same the number in our case is five

02:01:41,440 --> 02:01:47,040
and five is

02:01:44,560 --> 02:01:47,840
has been start from one and goes to six

02:01:47,040 --> 02:01:50,960
so

02:01:47,840 --> 02:01:54,239
one you get one

02:01:50,960 --> 02:01:57,440
that you multiply one you can

02:01:54,239 --> 02:02:01,760
get one single one then

02:01:57,440 --> 02:02:01,760
you have two for life

02:02:02,159 --> 02:02:04,400
then

02:02:36,880 --> 02:02:40,320
and yeah now you see that since you

02:02:39,040 --> 02:02:43,040
wrote we wrote a function

02:02:40,320 --> 02:02:45,119
for doing this i can now reuse the

02:02:43,040 --> 02:02:47,280
function as many times as i like and

02:02:45,119 --> 02:02:48,239
using the function i can find the

02:02:47,280 --> 02:02:52,239
factorial of

02:02:48,239 --> 02:02:55,760
all the numbers going from 1 to 20

02:02:52,239 --> 02:02:57,920
and they're all printed here

02:02:55,760 --> 02:02:59,360
so functions are really really useful

02:02:57,920 --> 02:03:01,679
when you want to do

02:02:59,360 --> 02:03:04,159
the same task over and over again on

02:03:01,679 --> 02:03:04,159
multiple

02:03:12,840 --> 02:03:15,840
inputs

02:03:19,840 --> 02:03:23,360
okay then we have type ins with

02:03:22,080 --> 02:03:29,840
functions

02:03:23,360 --> 02:03:29,840
so basically what type ins uh

02:03:33,520 --> 02:03:36,560
what type ins do is when you write a

02:03:35,599 --> 02:03:39,360
function

02:03:36,560 --> 02:03:41,679
you can specify the data type the

02:03:39,360 --> 02:03:42,719
expected data type of each variable in

02:03:41,679 --> 02:03:45,840
your function

02:03:42,719 --> 02:03:47,840
so when you write the function now you

02:03:45,840 --> 02:03:49,440
say

02:03:47,840 --> 02:03:52,079
you define a function that's called

02:03:49,440 --> 02:03:55,440
calculate bmi so it's going to find out

02:03:52,079 --> 02:03:56,880
the bmi and to find bmi you need the

02:03:55,440 --> 02:03:58,960
height of a person and you need the

02:03:56,880 --> 02:04:02,159
weight of a person

02:03:58,960 --> 02:04:04,239
right so the height is going to be a

02:04:02,159 --> 02:04:06,000
float and it will let's say it's going

02:04:04,239 --> 02:04:09,119
to be an integer value

02:04:06,000 --> 02:04:10,400
so you can tell the function that i

02:04:09,119 --> 02:04:13,679
expect a float

02:04:10,400 --> 02:04:17,199
for height and i expect i expect an

02:04:13,679 --> 02:04:20,719
integer for weight so

02:04:17,199 --> 02:04:21,599
and uh by doing this arrow float here

02:04:20,719 --> 02:04:24,320
right

02:04:21,599 --> 02:04:26,639
it tells the function that it's going to

02:04:24,320 --> 02:04:29,440
be returning a float value

02:04:26,639 --> 02:04:30,320
so the value that you return it will be

02:04:29,440 --> 02:04:33,920
of a float

02:04:30,320 --> 02:04:36,079
data type so it is

02:04:33,920 --> 02:04:37,280
important to give type ins for your

02:04:36,079 --> 02:04:40,480
functions

02:04:37,280 --> 02:04:42,480
because when other people use

02:04:40,480 --> 02:04:45,280
the functions that you write they should

02:04:42,480 --> 02:04:47,440
be able to know which kind of data types

02:04:45,280 --> 02:04:48,320
they need to provide to your function

02:04:47,440 --> 02:04:50,639
right

02:04:48,320 --> 02:04:53,840
so it's important to use type-ins when

02:04:50,639 --> 02:04:53,840
writing functions

02:04:59,360 --> 02:05:03,040
and lastly with functions we get to

02:05:01,679 --> 02:05:07,599
recursion

02:05:03,040 --> 02:05:10,719
so recursion is

02:05:07,599 --> 02:05:13,599
uh basically is it's

02:05:10,719 --> 02:05:14,719
if you have a function and you call the

02:05:13,599 --> 02:05:17,760
same function

02:05:14,719 --> 02:05:19,040
inside of that function then it's known

02:05:17,760 --> 02:05:22,320
as recursion

02:05:19,040 --> 02:05:24,639
then let's understand recursion by using

02:05:22,320 --> 02:05:29,040
the example of the factorial once

02:05:24,639 --> 02:05:31,760
so we previously we learned that

02:05:29,040 --> 02:05:32,079
n factorial is given by n times n minus

02:05:31,760 --> 02:05:35,760
02:05:32,079 --> 02:05:38,639
times n minus 2 all the way to 1 right

02:05:35,760 --> 02:05:39,599
similarly you can if i write n minus 1

02:05:38,639 --> 02:05:41,920
factorial out

02:05:39,599 --> 02:05:43,520
n minus 1 factorial would be n minus 1

02:05:41,920 --> 02:05:46,480
times n minus 2

02:05:43,520 --> 02:05:46,960
times 1 minus 3 all the way to 1 right

02:05:46,480 --> 02:05:50,480
but

02:05:46,960 --> 02:05:51,360
if you notice this and this is exactly

02:05:50,480 --> 02:05:54,400
the same

02:05:51,360 --> 02:05:54,719
right so what you could do here is say

02:05:54,400 --> 02:05:57,360
that

02:05:54,719 --> 02:05:58,400
n factorial is equal to 10 times n minus

02:05:57,360 --> 02:06:03,840
1 factorial

02:05:58,400 --> 02:06:03,840
right you can write it out like this and

02:06:04,400 --> 02:06:08,960
using this right you can actually if you

02:06:07,679 --> 02:06:12,239
know

02:06:08,960 --> 02:06:13,520
if you know uh this is quite useful

02:06:12,239 --> 02:06:15,199
because if you know what

02:06:13,520 --> 02:06:17,199
four factorial is right you can

02:06:15,199 --> 02:06:18,000
immediately calculate 5 factorial

02:06:17,199 --> 02:06:22,480
because

02:06:18,000 --> 02:06:25,760
if i tell you that 4 factorial is 24

02:06:22,480 --> 02:06:27,040
then you can find 5 factorial just as 5

02:06:25,760 --> 02:06:30,159
times 24

02:06:27,040 --> 02:06:32,880
1 which is 120 right so

02:06:30,159 --> 02:06:33,920
this is uh when you have something

02:06:32,880 --> 02:06:36,239
that's defined

02:06:33,920 --> 02:06:38,960
in terms of itself so if you say that n

02:06:36,239 --> 02:06:41,119
factorial is equal to n times n minus 1

02:06:38,960 --> 02:06:42,400
is known as a recursive definition which

02:06:41,119 --> 02:06:44,719
means it's defined

02:06:42,400 --> 02:06:46,639
in terms of itself so you have a

02:06:44,719 --> 02:06:48,880
factorial here you have a factor in here

02:06:46,639 --> 02:06:52,320
as well

02:06:48,880 --> 02:06:55,040
so if you were being introduced to the

02:06:52,320 --> 02:06:56,239
factorial for the first time right and

02:06:55,040 --> 02:06:58,480
somebody told you that

02:06:56,239 --> 02:06:59,360
n factorial is equal to n times n minus

02:06:58,480 --> 02:07:01,199
1 factorial

02:06:59,360 --> 02:07:03,199
is that actually enough information for

02:07:01,199 --> 02:07:05,520
you to calculate the factorial of any

02:07:03,199 --> 02:07:05,520
number

02:07:08,480 --> 02:07:11,920
yeah it doesn't tell you where to stop

02:07:10,000 --> 02:07:14,000
right so you don't know

02:07:11,920 --> 02:07:16,079
when to stop with this so you can go in

02:07:14,000 --> 02:07:18,079
n minus 1 and minus 2 and minus 3

02:07:16,079 --> 02:07:19,520
all the way to where you stop you don't

02:07:18,079 --> 02:07:22,719
know right

02:07:19,520 --> 02:07:23,440
so that's not all the information that

02:07:22,719 --> 02:07:25,040
you need

02:07:23,440 --> 02:07:27,360
to complete the definition of a

02:07:25,040 --> 02:07:29,599
factorial you need a stopping point

02:07:27,360 --> 02:07:32,000
and the stopping point is actually zero

02:07:29,599 --> 02:07:33,920
factorial is defined as one so zero

02:07:32,000 --> 02:07:36,639
factorial is one

02:07:33,920 --> 02:07:38,079
so now when you know that zero factorial

02:07:36,639 --> 02:07:40,079
is equal to one

02:07:38,079 --> 02:07:41,119
you can say that for all numbers that

02:07:40,079 --> 02:07:43,520
are not 0

02:07:41,119 --> 02:07:44,639
you can use this and when n factorial

02:07:43,520 --> 02:07:48,960
you have 0

02:07:44,639 --> 02:07:48,960
you use 1 right so then

02:07:49,040 --> 02:07:54,000
you will have that

02:07:52,239 --> 02:07:56,560
if you would try to calculate a three

02:07:54,000 --> 02:07:58,000
factorial without a stopping point you

02:07:56,560 --> 02:07:59,360
could just keep going and going and

02:07:58,000 --> 02:08:01,760
going and you don't know where to stop

02:07:59,360 --> 02:08:04,960
but once you know the stopping point

02:08:01,760 --> 02:08:06,560
you go all the way down

02:08:04,960 --> 02:08:08,400
so you find you want to find three

02:08:06,560 --> 02:08:10,480
factorial is three times two factorial

02:08:08,400 --> 02:08:12,880
then you want to find two factorial

02:08:10,480 --> 02:08:14,880
is two times one factorial and when you

02:08:12,880 --> 02:08:16,079
want to find one factorial is one times

02:08:14,880 --> 02:08:18,079
zero factorial

02:08:16,079 --> 02:08:19,679
and now you know that zero factorial is

02:08:18,079 --> 02:08:23,440
one so we use

02:08:19,679 --> 02:08:25,440
you use one here and then you just

02:08:23,440 --> 02:08:27,119
when you find this you use it here when

02:08:25,440 --> 02:08:29,440
you find this you use it here and you

02:08:27,119 --> 02:08:32,000
get the value for three factorial

02:08:29,440 --> 02:08:32,000
right so

02:08:35,440 --> 02:08:39,679
uh that's this thing where you need a

02:08:38,719 --> 02:08:42,480
stopping point

02:08:39,679 --> 02:08:42,960
for recursion this is known as the base

02:08:42,480 --> 02:08:46,480
case

02:08:42,960 --> 02:08:48,880
of your recursion so if you say n

02:08:46,480 --> 02:08:50,400
my n factorial is equal to n times n

02:08:48,880 --> 02:08:52,800
minus 1 factorial

02:08:50,400 --> 02:08:54,960
for any number that's not zero then

02:08:52,800 --> 02:08:57,199
that's known as the recursive

02:08:54,960 --> 02:08:58,159
case and the zero factorial equal to one

02:08:57,199 --> 02:09:05,840
is known as the base

02:08:58,159 --> 02:09:05,840
space so

02:09:06,000 --> 02:09:10,719
using this you can find out uh if if you

02:09:08,960 --> 02:09:11,840
if you know the factorial of a smaller

02:09:10,719 --> 02:09:15,760
number or if you

02:09:11,840 --> 02:09:18,400
have uh the factorial of a

02:09:15,760 --> 02:09:19,520
bigger number you can work out the

02:09:18,400 --> 02:09:21,280
factorials of

02:09:19,520 --> 02:09:24,000
any number that you like using this

02:09:21,280 --> 02:09:26,639
definition and

02:09:24,000 --> 02:09:28,719
this process of defining something in

02:09:26,639 --> 02:09:30,800
terms of itself is known as recursion

02:09:28,719 --> 02:09:32,960
and it's important in programming

02:09:30,800 --> 02:09:32,960
and

02:09:58,840 --> 02:10:01,840
uh

02:10:12,840 --> 02:10:15,840
yes

02:10:40,840 --> 02:10:43,840
so

02:10:54,880 --> 02:11:01,040
here then i can move the

02:10:57,920 --> 02:11:02,639
one the third biggest stream and then i

02:11:01,040 --> 02:11:06,400
can move

02:11:02,639 --> 02:11:10,880
two rings again

02:11:06,400 --> 02:11:10,880
does that make sense so i say if i

02:11:22,840 --> 02:11:27,440
result um so

02:11:25,679 --> 02:11:28,719
this is this is actually an interesting

02:11:27,440 --> 02:11:31,280
application

02:11:28,719 --> 02:11:32,480
because you see you started off with the

02:11:31,280 --> 02:11:34,880
problem that's

02:11:32,480 --> 02:11:36,639
the three things and now we're now in

02:11:34,880 --> 02:11:38,079
your problem with two things

02:11:36,639 --> 02:11:40,000
and now you want to figure out can i

02:11:38,079 --> 02:11:43,360
solve this for two things

02:11:40,000 --> 02:11:47,040
let's see so

02:11:43,360 --> 02:11:49,199
if you now have a set up in two ways

02:11:47,040 --> 02:11:51,679
can you solve this obedience despite

02:11:49,199 --> 02:11:54,960
simple matter just move the first one

02:11:51,679 --> 02:11:57,679
then you move the second one

02:11:54,960 --> 02:11:58,239
and you move the first one and you just

02:11:57,679 --> 02:12:02,000
move

02:11:58,239 --> 02:12:02,239
the the gold stand forward so you figure

02:12:02,000 --> 02:12:07,840
out

02:12:02,239 --> 02:12:07,840
a way to solve

02:12:13,040 --> 02:12:16,719
you do the same thing you say that you

02:12:15,520 --> 02:12:21,840
move this

02:12:16,719 --> 02:12:21,840
on three rings

02:12:32,840 --> 02:12:35,840
oh

02:12:46,719 --> 02:12:48,960
this

02:13:00,560 --> 02:13:02,960
remove

02:13:28,480 --> 02:13:30,800
here

02:13:37,520 --> 02:13:41,440
i can show you a really nice

02:13:42,159 --> 02:13:48,639
animation for towers of hanoi let me see

02:13:45,920 --> 02:13:59,840
if i can find

02:13:48,639 --> 02:13:59,840
the animation that i have

02:14:17,599 --> 02:14:20,960
wait it's not in here

02:14:25,520 --> 02:14:30,159
yes here so believe this is the

02:14:28,400 --> 02:14:32,639
animation

02:14:30,159 --> 02:14:35,760
yes it's the animation of the thing that

02:14:32,639 --> 02:14:35,760
you're just talking about

02:14:37,520 --> 02:14:41,679
so you solve the problem for two discs

02:14:39,760 --> 02:14:45,040
now you move the third one

02:14:41,679 --> 02:14:47,119
and now you solve the problem once again

02:14:45,040 --> 02:14:48,159
for this one so now you move the two

02:14:47,119 --> 02:14:50,560
discs back

02:14:48,159 --> 02:14:51,920
and now you move the third one and now

02:14:50,560 --> 02:14:55,119
you're going to do

02:14:51,920 --> 02:14:58,079
the same process again

02:14:55,119 --> 02:14:59,199
so now you again move two and you move

02:14:58,079 --> 02:15:02,960
the third one

02:14:59,199 --> 02:15:05,840
then you move these uh back

02:15:02,960 --> 02:15:06,800
and yeah now you've moved all the four

02:15:05,840 --> 02:15:10,560
disks

02:15:06,800 --> 02:15:13,119
does that make sense and

02:15:10,560 --> 02:15:14,639
there's actually a really really nice

02:15:13,119 --> 02:15:17,040
relation to

02:15:14,639 --> 02:15:18,079
binary numbers if you notice this is

02:15:17,040 --> 02:15:21,520
actually counting

02:15:18,079 --> 02:15:24,079
up in binary so if you if you follow the

02:15:21,520 --> 02:15:25,520
colors of the digits then whenever the

02:15:24,079 --> 02:15:27,360
digit changes that's when

02:15:25,520 --> 02:15:28,800
this moves this is a really interesting

02:15:27,360 --> 02:15:32,639
relation between powers of

02:15:28,800 --> 02:15:32,639
noise and counting environment which is

02:15:34,840 --> 02:15:37,840
interesting

02:15:44,480 --> 02:15:52,800
so the factorial in terms of

02:15:48,800 --> 02:15:55,599
as a recursive function is uh shown here

02:15:52,800 --> 02:15:56,719
so you know that whenever the number is

02:15:55,599 --> 02:15:59,280
not zero

02:15:56,719 --> 02:16:00,000
it's the number times the factorial of n

02:15:59,280 --> 02:16:03,119
minus one

02:16:00,000 --> 02:16:05,599
right so you use uh

02:16:03,119 --> 02:16:07,599
definition of the factorial and when you

02:16:05,599 --> 02:16:10,159
have 0 you return 1

02:16:07,599 --> 02:16:12,079
so now this function can calculate

02:16:10,159 --> 02:16:18,960
factorials recursively

02:16:12,079 --> 02:16:21,679
that makes sense

02:16:18,960 --> 02:16:22,800
so let's maybe walk through an example

02:16:21,679 --> 02:16:25,520
so this can be more

02:16:22,800 --> 02:16:25,520
uh clear

02:16:26,079 --> 02:16:32,719
here i think i have an example yes

02:16:29,360 --> 02:16:33,359
so yeah there's an example a problem

02:16:32,719 --> 02:16:36,479
that

02:16:33,359 --> 02:16:37,280
i would like you to attempt so you could

02:16:36,479 --> 02:16:39,760
try

02:16:37,280 --> 02:16:40,800
figuring out what this piece of code

02:16:39,760 --> 02:16:42,479
should output

02:16:40,800 --> 02:16:44,399
and you're not allowed to type this into

02:16:42,479 --> 02:16:45,280
your ide and run the code because that

02:16:44,399 --> 02:16:49,040
will be cheating

02:16:45,280 --> 02:16:51,439
you have to work this out by hand so

02:16:49,040 --> 02:16:53,519
try to figure out what this would this

02:16:51,439 --> 02:16:56,160
recursive function would print

02:16:53,519 --> 02:16:58,880
and keep in mind that every time you

02:16:56,160 --> 02:17:01,599
have a function called inside a function

02:16:58,880 --> 02:17:02,559
it stops everything that it's doing and

02:17:01,599 --> 02:17:06,399
it

02:17:02,559 --> 02:17:09,280
it goes into the it it first

02:17:06,399 --> 02:17:10,000
does the task of the function call that

02:17:09,280 --> 02:17:14,160
you

02:17:10,000 --> 02:17:16,240
made and then it basically

02:17:14,160 --> 02:17:17,280
if you have a function called inside a

02:17:16,240 --> 02:17:18,960
function it

02:17:17,280 --> 02:17:20,880
stops everything that it's currently

02:17:18,960 --> 02:17:22,719
doing it will first complete the task of

02:17:20,880 --> 02:17:24,880
the function

02:17:22,719 --> 02:17:29,760
and then it will resume its own

02:17:24,880 --> 02:17:32,080
operation after that

02:17:29,760 --> 02:17:33,040
okay let's take uh maybe three minutes

02:17:32,080 --> 02:17:36,880
to

02:17:33,040 --> 02:17:39,519
figure out a solution if not then

02:17:36,880 --> 02:17:39,519
i'll move on

02:17:41,599 --> 02:17:45,359
no this is not the factorial this is the

02:17:44,160 --> 02:17:47,519
factorial is

02:17:45,359 --> 02:17:50,240
used as an example but this one is does

02:17:47,519 --> 02:17:50,240
something different

02:17:54,840 --> 02:18:11,840
sorry comes down

02:18:12,719 --> 02:18:18,960
also remember that when

02:18:16,160 --> 02:18:20,080
uh when you make the recursive calls to

02:18:18,960 --> 02:18:22,479
a function right

02:18:20,080 --> 02:18:23,120
it stops the rest of the thing that it's

02:18:22,479 --> 02:18:25,920
doing but

02:18:23,120 --> 02:18:26,719
it doesn't completely forget about it

02:18:25,920 --> 02:18:28,880
once

02:18:26,719 --> 02:18:30,880
it's done with the function called we

02:18:28,880 --> 02:18:31,280
will still continue with the code that

02:18:30,880 --> 02:18:34,719
is

02:18:31,280 --> 02:18:38,160
left earlier so when

02:18:34,719 --> 02:18:39,200
uh you you do this right when it does

02:18:38,160 --> 02:18:41,679
just function called

02:18:39,200 --> 02:18:43,599
it'll hold the print but it'll still

02:18:41,679 --> 02:18:45,679
execute the print statement once it's

02:18:43,599 --> 02:18:48,559
done with whatever is doing here

02:18:45,679 --> 02:18:49,599
so make sure that when you're thinking

02:18:48,559 --> 02:18:51,280
about this

02:18:49,599 --> 02:18:54,399
you don't forget about what's coming

02:18:51,280 --> 02:18:54,399
after the function call

02:19:03,439 --> 02:19:07,840
sorry yes

02:19:17,679 --> 02:19:21,040
yeah there's a zero in here as

02:19:30,719 --> 02:19:35,280
it doesn't execute this part but it

02:19:33,439 --> 02:19:37,519
still goes through the print number so

02:19:35,280 --> 02:19:39,679
it still gives you a zero here

02:19:37,519 --> 02:19:39,679
so

02:19:42,960 --> 02:19:47,280
uh that's how uh like if uh yeah that's

02:19:46,240 --> 02:19:50,800
that's

02:19:47,280 --> 02:19:54,560
a classic example for brick version

02:19:50,800 --> 02:19:58,080
and with that you come to the end of

02:19:54,560 --> 02:20:01,600
functions and we're going to go

02:19:58,080 --> 02:20:02,720
over classes and objects which is also

02:20:01,600 --> 02:20:06,000
like one of the

02:20:02,720 --> 02:20:07,280
really important concepts for

02:20:06,000 --> 02:20:12,080
programming

02:20:07,280 --> 02:20:14,399
and basically

02:20:12,080 --> 02:20:15,280
we when we talk about classes and

02:20:14,399 --> 02:20:18,640
objects right

02:20:15,280 --> 02:20:20,880
yes let's say you come across

02:20:18,640 --> 02:20:21,840
like a lot of different objects in your

02:20:20,880 --> 02:20:24,640
daily life if

02:20:21,840 --> 02:20:25,600
each object that you come across has a

02:20:24,640 --> 02:20:27,840
different

02:20:25,600 --> 02:20:29,359
uh like it has different properties it

02:20:27,840 --> 02:20:32,000
has different

02:20:29,359 --> 02:20:33,439
things that it can do so let's say i

02:20:32,000 --> 02:20:37,600
have the marker here

02:20:33,439 --> 02:20:40,720
the marker it has it has red ink in it

02:20:37,600 --> 02:20:42,720
it has a size it has some weight

02:20:40,720 --> 02:20:44,319
so it has some properties and it has a

02:20:42,720 --> 02:20:47,920
function you can write with it

02:20:44,319 --> 02:20:50,160
so the marker can be used to write with

02:20:47,920 --> 02:20:50,160
so

02:20:51,200 --> 02:20:57,680
uh with every object that you see

02:20:55,280 --> 02:20:59,680
in real life it has some properties it

02:20:57,680 --> 02:21:02,000
has some functions that it can perform

02:20:59,680 --> 02:21:02,800
a chair it has some weight it has some

02:21:02,000 --> 02:21:05,280
height

02:21:02,800 --> 02:21:06,160
it is it has a material that is made of

02:21:05,280 --> 02:21:09,760
and

02:21:06,160 --> 02:21:12,240
so like all objects are like that

02:21:09,760 --> 02:21:14,800
and what would you do if you wanted to

02:21:12,240 --> 02:21:14,800
represent

02:21:14,960 --> 02:21:18,240
an object like that in a program how

02:21:17,600 --> 02:21:19,840
would you

02:21:18,240 --> 02:21:22,479
define its properties how would you

02:21:19,840 --> 02:21:25,600
define what kind of

02:21:22,479 --> 02:21:28,960
functions the object can execute

02:21:25,600 --> 02:21:31,120
so you might try writing something like

02:21:28,960 --> 02:21:34,240
this let's say i wanted to write

02:21:31,120 --> 02:21:35,920
an object that's a pen in code

02:21:34,240 --> 02:21:37,760
you might try writing something like

02:21:35,920 --> 02:21:39,120
this so the pen has a color the pen has

02:21:37,760 --> 02:21:41,359
a size if

02:21:39,120 --> 02:21:44,000
there's either a ball pen or it's a gel

02:21:41,359 --> 02:21:46,720
pen or it's a fountain pen

02:21:44,000 --> 02:21:47,359
and the pen might have an owner so yeah

02:21:46,720 --> 02:21:49,760
there's

02:21:47,359 --> 02:21:51,760
that and then you write a function that

02:21:49,760 --> 02:21:52,640
can display all of the information about

02:21:51,760 --> 02:21:55,200
the pen

02:21:52,640 --> 02:21:56,560
so in a space color size kind of owner

02:21:55,200 --> 02:21:59,680
right

02:21:56,560 --> 02:22:02,000
but this

02:21:59,680 --> 02:22:04,479
it works for one pen right what if i

02:22:02,000 --> 02:22:07,040
wanted to make 100 different pens

02:22:04,479 --> 02:22:08,240
can you write the same piece of code 100

02:22:07,040 --> 02:22:11,439
different times

02:22:08,240 --> 02:22:13,359
that's not feasible is it that doesn't

02:22:11,439 --> 02:22:16,560
make sense

02:22:13,359 --> 02:22:18,319
so and you can't like

02:22:16,560 --> 02:22:20,000
you can't scale this up to a large

02:22:18,319 --> 02:22:22,080
number of objects and

02:22:20,000 --> 02:22:23,040
if you if you had an unknown number of

02:22:22,080 --> 02:22:25,439
pens

02:22:23,040 --> 02:22:27,040
like if you wanted to make some amount

02:22:25,439 --> 02:22:29,040
of pens that are determined

02:22:27,040 --> 02:22:30,640
when the code is actually being run then

02:22:29,040 --> 02:22:32,960
you can't use this because you don't

02:22:30,640 --> 02:22:36,479
know how many variables to make

02:22:32,960 --> 02:22:38,000
but this is where like classes and

02:22:36,479 --> 02:22:41,520
objects come into the picture

02:22:38,000 --> 02:22:43,920
so classes and objects uh

02:22:41,520 --> 02:22:45,520
they're basically what we call as user

02:22:43,920 --> 02:22:48,880
defined data types

02:22:45,520 --> 02:22:51,840
so in python

02:22:48,880 --> 02:22:53,439
integers floats lists all of these data

02:22:51,840 --> 02:22:55,200
types that we learnt about

02:22:53,439 --> 02:22:56,960
they are primitive data types they are

02:22:55,200 --> 02:23:00,000
built into python

02:22:56,960 --> 02:23:01,760
so they're like we

02:23:00,000 --> 02:23:04,240
you can use them without having to

02:23:01,760 --> 02:23:05,359
define any classes for them or any

02:23:04,240 --> 02:23:08,240
object for them

02:23:05,359 --> 02:23:08,880
but if you wanted to make your own data

02:23:08,240 --> 02:23:11,040
type

02:23:08,880 --> 02:23:12,720
then you'd use a class you'd use an

02:23:11,040 --> 02:23:16,560
object to do that

02:23:12,720 --> 02:23:20,479
so basically a class

02:23:16,560 --> 02:23:22,640
is a custom data type and

02:23:20,479 --> 02:23:24,479
yeah with with that we move on to what

02:23:22,640 --> 02:23:28,479
classes are and how

02:23:24,479 --> 02:23:30,640
we use them so now we want to create our

02:23:28,479 --> 02:23:33,439
own data type right we want to make

02:23:30,640 --> 02:23:34,960
maybe a pen or we want to make something

02:23:33,439 --> 02:23:37,840
more complicated

02:23:34,960 --> 02:23:38,720
then that's what classes allow us to do

02:23:37,840 --> 02:23:41,760
so a class

02:23:38,720 --> 02:23:42,640
is basically a blueprint for creating an

02:23:41,760 --> 02:23:44,960
object

02:23:42,640 --> 02:23:46,080
it tells us the defining properties of

02:23:44,960 --> 02:23:48,479
the object and

02:23:46,080 --> 02:23:50,080
it also tells us what functions the

02:23:48,479 --> 02:23:54,000
object can perform

02:23:50,080 --> 02:23:56,720
so a class it's a blueprint to make the

02:23:54,000 --> 02:23:59,920
object it's not the object itself

02:23:56,720 --> 02:24:01,680
so a class for a pen object would look

02:23:59,920 --> 02:24:04,800
something like this

02:24:01,680 --> 02:24:07,680
so this tells me that the

02:24:04,800 --> 02:24:10,000
pen it has a color it has a size it has

02:24:07,680 --> 02:24:14,479
a kind and it has an owner

02:24:10,000 --> 02:24:16,160
and um the class also has a function

02:24:14,479 --> 02:24:19,600
called display information

02:24:16,160 --> 02:24:21,520
which shows the information of the pen

02:24:19,600 --> 02:24:24,560
so it will show me the color the size

02:24:21,520 --> 02:24:24,560
the kind and the owner

02:24:24,880 --> 02:24:30,160
and note that this

02:24:28,160 --> 02:24:32,080
this funny funny function that i have

02:24:30,160 --> 02:24:34,160
here i underscore underscore init

02:24:32,080 --> 02:24:38,160
underscore underscore this thing

02:24:34,160 --> 02:24:41,200
is known as a constructor in general so

02:24:38,160 --> 02:24:43,760
this constructor is essential for

02:24:41,200 --> 02:24:44,800
every blueprint to have a constructor

02:24:43,760 --> 02:24:47,439
because

02:24:44,800 --> 02:24:48,399
this literally the constructor is the

02:24:47,439 --> 02:24:51,280
function that

02:24:48,399 --> 02:24:52,399
actually constructs your object without

02:24:51,280 --> 02:24:54,399
this

02:24:52,399 --> 02:24:55,439
you won't be able to make objects in

02:24:54,399 --> 02:24:57,680
your class

02:24:55,439 --> 02:24:58,479
so let's say you have a blueprint to

02:24:57,680 --> 02:25:01,200
make a

02:24:58,479 --> 02:25:03,439
bicycle like you could have the weight

02:25:01,200 --> 02:25:05,120
of the bicycle you could have the height

02:25:03,439 --> 02:25:06,640
you could have the material that is made

02:25:05,120 --> 02:25:08,399
out of you could have

02:25:06,640 --> 02:25:11,040
certain properties like does the bike

02:25:08,399 --> 02:25:13,359
have a belt does it have a basket

02:25:11,040 --> 02:25:15,200
but you have all of the properties

02:25:13,359 --> 02:25:16,880
written down on a blueprint but you

02:25:15,200 --> 02:25:19,920
don't have the tools to make it you

02:25:16,880 --> 02:25:21,359
don't have a wrench you don't have a

02:25:19,920 --> 02:25:22,960
hammer or something that you would need

02:25:21,359 --> 02:25:25,120
to make a bicycle

02:25:22,960 --> 02:25:26,640
then you would not be able to make it so

02:25:25,120 --> 02:25:29,040
basically the constructor

02:25:26,640 --> 02:25:32,160
is is the tool that you need to make an

02:25:29,040 --> 02:25:36,319
object and is required in every class

02:25:32,160 --> 02:25:40,560
so with the constructor you

02:25:36,319 --> 02:25:42,399
also in a class you also define

02:25:40,560 --> 02:25:44,000
other functions that the object can

02:25:42,399 --> 02:25:46,319
perform so this

02:25:44,000 --> 02:25:47,680
class also has a display information

02:25:46,319 --> 02:25:50,720
function that

02:25:47,680 --> 02:25:51,280
shows you uh all of the details that

02:25:50,720 --> 02:25:54,319
append

02:25:51,280 --> 02:25:58,240
all the information that a pen has

02:25:54,319 --> 02:26:00,560
so remember that the class is just a

02:25:58,240 --> 02:26:01,040
blueprint for creating a pen it tells us

02:26:00,560 --> 02:26:02,800
what

02:26:01,040 --> 02:26:04,080
what properties and what functions it

02:26:02,800 --> 02:26:07,200
has it's not

02:26:04,080 --> 02:26:10,080
the pen itself to actually create a pen

02:26:07,200 --> 02:26:11,040
you would use uh the blueprint and you

02:26:10,080 --> 02:26:12,560
would specify

02:26:11,040 --> 02:26:14,640
all of the properties something like

02:26:12,560 --> 02:26:17,840
this so you say that

02:26:14,640 --> 02:26:19,600
a is equal to a pen and you specify that

02:26:17,840 --> 02:26:22,960
its color is red

02:26:19,600 --> 02:26:25,439
is size is 0.5 the kind

02:26:22,960 --> 02:26:26,160
is it's a marker and the owner's name is

02:26:25,439 --> 02:26:29,760
john

02:26:26,160 --> 02:26:32,800
so now you make a pen

02:26:29,760 --> 02:26:35,359
object like this so

02:26:32,800 --> 02:26:36,960
when you do this the python calls python

02:26:35,359 --> 02:26:40,240
calls the constructor

02:26:36,960 --> 02:26:41,520
and says that construct me a pen with

02:26:40,240 --> 02:26:43,600
the following properties

02:26:41,520 --> 02:26:44,640
it has to be read it has to be of size

02:26:43,600 --> 02:26:48,080
0.5

02:26:44,640 --> 02:26:50,640
it has to have the kind of the of marker

02:26:48,080 --> 02:26:51,840
so owner's name is john does that make

02:26:50,640 --> 02:26:55,200
sense

02:26:51,840 --> 02:26:57,439
so this is use this syntax is used to

02:26:55,200 --> 02:27:01,359
construct a pen

02:26:57,439 --> 02:27:02,800
and then if you want to see the

02:27:01,359 --> 02:27:04,319
information about the pen

02:27:02,800 --> 02:27:07,200
you can use the display information

02:27:04,319 --> 02:27:08,000
function like this you say a dot display

02:27:07,200 --> 02:27:10,319
information

02:27:08,000 --> 02:27:12,720
and show you all of the properties of

02:27:10,319 --> 02:27:12,720
the pen

02:27:12,800 --> 02:27:19,840
so i can copy the

02:27:16,000 --> 02:27:19,840
code and

02:27:21,920 --> 02:27:25,200
just for the first pen

02:27:25,680 --> 02:27:31,920
see that when i run this it shows me the

02:27:28,479 --> 02:27:35,120
color the size the kind and the owner

02:27:31,920 --> 02:27:37,120
so and now with

02:27:35,120 --> 02:27:39,520
when i have the class now if i want to

02:27:37,120 --> 02:27:40,800
make multiple objects right if i want to

02:27:39,520 --> 02:27:43,120
make

02:27:40,800 --> 02:27:44,319
four different objects then all i need

02:27:43,120 --> 02:27:46,880
to do is just

02:27:44,319 --> 02:27:47,600
use the same syntax with the constructor

02:27:46,880 --> 02:27:49,280
and

02:27:47,600 --> 02:27:51,040
i will have four different pens i don't

02:27:49,280 --> 02:27:54,000
need to

02:27:51,040 --> 02:27:54,319
make four different variables for every

02:27:54,000 --> 02:27:58,560
pen

02:27:54,319 --> 02:28:01,200
which is it's quite tedious to do um

02:27:58,560 --> 02:28:04,720
if you wanted to make 100 different pens

02:28:01,200 --> 02:28:07,600
it's much more efficient to do this

02:28:04,720 --> 02:28:08,319
so now if i run the program then it'll

02:28:07,600 --> 02:28:10,240
give me

02:28:08,319 --> 02:28:12,880
like it gives me all the information

02:28:10,240 --> 02:28:12,880
about all

02:28:13,200 --> 02:28:17,359
and wouldn't you say that this code

02:28:14,880 --> 02:28:19,359
looks really neat and nice because

02:28:17,359 --> 02:28:20,880
you you can immediately tell at a glance

02:28:19,359 --> 02:28:22,319
what's happening here you're making four

02:28:20,880 --> 02:28:23,840
different patterns you're displaying

02:28:22,319 --> 02:28:25,280
information about them it's

02:28:23,840 --> 02:28:27,840
like quite obvious as to what's

02:28:25,280 --> 02:28:28,399
happening what's happening with the code

02:28:27,840 --> 02:28:31,200
if you

02:28:28,399 --> 02:28:32,800
were to read somebody else's code so

02:28:31,200 --> 02:28:36,720
classes and objects

02:28:32,800 --> 02:28:40,000
they are really really powerful for

02:28:36,720 --> 02:28:43,040
you to be able to like

02:28:40,000 --> 02:28:43,920
it's it feels really modular it is

02:28:43,040 --> 02:28:45,840
really

02:28:43,920 --> 02:28:46,960
highly readable code so you should use

02:28:45,840 --> 02:28:51,840
classes and objects

02:28:46,960 --> 02:28:51,840
as much as you can okay does this make

02:28:52,840 --> 02:28:55,840
sense

02:29:02,319 --> 02:29:09,840
do you have any questions

02:29:20,840 --> 02:29:23,840
okay

02:29:31,840 --> 02:29:35,280
yes you can do that i mean

02:29:49,520 --> 02:29:55,439
yeah in practice it definitely makes

02:29:53,439 --> 02:29:56,800
sense to use more mnemonic variable

02:29:55,439 --> 02:29:59,200
names that are descriptive

02:29:56,800 --> 02:30:01,120
and like they should tell the user what

02:29:59,200 --> 02:30:01,439
they're supposed to do and not just abcd

02:30:01,120 --> 02:30:03,040
that

02:30:01,439 --> 02:30:05,280
obviously in practice this doesn't make

02:30:03,040 --> 02:30:09,280
sense since this is just an example

02:30:05,280 --> 02:30:09,280
so and uh work with it

02:30:11,359 --> 02:30:18,160
okay so right now the class that we saw

02:30:14,880 --> 02:30:20,720
was it it uses some it breaks some

02:30:18,160 --> 02:30:22,960
conventions for the sake of an example

02:30:20,720 --> 02:30:24,960
but more conventionally right but class

02:30:22,960 --> 02:30:27,359
it will look something like this

02:30:24,960 --> 02:30:29,439
when you define a constructor if you

02:30:27,359 --> 02:30:32,640
notice in the original class

02:30:29,439 --> 02:30:34,399
i in a constructor i use different

02:30:32,640 --> 02:30:38,080
variable names from

02:30:34,399 --> 02:30:38,479
the properties right and i call that the

02:30:38,080 --> 02:30:41,200
first

02:30:38,479 --> 02:30:43,920
variable in my constructor and a

02:30:41,200 --> 02:30:45,920
variable in my

02:30:43,920 --> 02:30:47,200
display information function i call it

02:30:45,920 --> 02:30:51,120
pen right

02:30:47,200 --> 02:30:55,680
but conventionally in python you

02:30:51,120 --> 02:30:57,200
call the call the first the the object

02:30:55,680 --> 02:31:00,000
that's passed to the function you call

02:30:57,200 --> 02:31:04,080
it self and all of the properties that

02:31:00,000 --> 02:31:07,439
the object has you use the same name

02:31:04,080 --> 02:31:08,640
for the property as the one that the

02:31:07,439 --> 02:31:12,880
object has

02:31:08,640 --> 02:31:15,200
so this this the color over here the

02:31:12,880 --> 02:31:15,200
stripes

02:31:24,720 --> 02:31:28,000
so if you don't have a cell then it just

02:31:27,040 --> 02:31:31,200
refers to these

02:31:28,000 --> 02:31:33,680
values and

02:31:31,200 --> 02:31:34,319
conventionally you you use the same name

02:31:33,680 --> 02:31:36,399
for the both

02:31:34,319 --> 02:31:38,800
both but you don't have to as you see

02:31:36,399 --> 02:31:42,479
you can you can use different names

02:31:38,800 --> 02:31:44,240
and it's conventional to use self as the

02:31:42,479 --> 02:31:45,439
name of the object when writing the

02:31:44,240 --> 02:31:48,880
functions

02:31:45,439 --> 02:31:52,399
so you don't have to use self but

02:31:48,880 --> 02:31:54,560
again you can see that it's so so

02:31:52,399 --> 02:31:56,000
important to follow this one that it

02:31:54,560 --> 02:31:58,319
actually has its own color

02:31:56,000 --> 02:31:59,439
like python colors it differently from

02:31:58,319 --> 02:32:02,399
other variables

02:31:59,439 --> 02:32:04,640
show how important this valley value is

02:32:02,399 --> 02:32:04,640
so

02:32:06,160 --> 02:32:10,000
yeah you should you should really follow

02:32:08,319 --> 02:32:14,000
these two conventions are

02:32:10,000 --> 02:32:17,760
quite important writing classes so

02:32:14,000 --> 02:32:21,120
with that uh

02:32:17,760 --> 02:32:24,319
we have a practice

02:32:21,120 --> 02:32:27,359
question so you want to write a class

02:32:24,319 --> 02:32:30,880
that describes a bicycle object which

02:32:27,359 --> 02:32:33,200
uh which has these mentioned properties

02:32:30,880 --> 02:32:34,160
so we can think about how you go about

02:32:33,200 --> 02:32:37,520
writing these

02:32:34,160 --> 02:32:40,960
and make a class out of these

02:32:37,520 --> 02:32:43,520
so let's take maybe

02:32:40,960 --> 02:32:53,840
three minutes to do this question let me

02:32:43,520 --> 02:32:53,840
move on

02:33:04,840 --> 02:33:07,840
okay

02:33:46,840 --> 02:33:49,840
oh

02:35:46,880 --> 02:35:50,560
okay if you've managed to do the

02:35:49,680 --> 02:35:52,640
question and

02:35:50,560 --> 02:35:54,640
that's good if not then we'll go over

02:35:52,640 --> 02:35:56,880
the solution now

02:35:54,640 --> 02:35:56,880
so

02:36:00,000 --> 02:36:05,439
the goal is to write a class with the

02:36:02,880 --> 02:36:07,439
following properties so the

02:36:05,439 --> 02:36:08,800
bicycle object should have a color it

02:36:07,439 --> 02:36:11,359
should have a material

02:36:08,800 --> 02:36:12,880
if you have a size it should have a

02:36:11,359 --> 02:36:15,359
height of the seat

02:36:12,880 --> 02:36:16,160
it should have a gear ratio the diameter

02:36:15,359 --> 02:36:19,359
of the wheels

02:36:16,160 --> 02:36:21,600
and it should

02:36:19,359 --> 02:36:24,000
and you also have properties for does it

02:36:21,600 --> 02:36:26,160
have a basket or does it have a pen

02:36:24,000 --> 02:36:26,160
so

02:36:30,160 --> 02:36:34,160
and the bicycle also has two functions

02:36:32,960 --> 02:36:36,560
you can change the gear

02:36:34,160 --> 02:36:38,640
of the bicycle and you can adjust the

02:36:36,560 --> 02:36:41,840
height of the seat of the bicycle

02:36:38,640 --> 02:36:44,720
so you write it out something like this

02:36:41,840 --> 02:36:46,319
so you say you're making a class that's

02:36:44,720 --> 02:36:49,200
called bicycle

02:36:46,319 --> 02:36:50,319
and when you define the constructor for

02:36:49,200 --> 02:36:53,040
the class

02:36:50,319 --> 02:36:53,840
and the constructor has these properties

02:36:53,040 --> 02:36:56,319
it's

02:36:53,840 --> 02:36:58,880
it has a color it has a material it has

02:36:56,319 --> 02:36:58,880
a size

02:36:59,040 --> 02:37:02,399
it has a size it has a height it has a

02:37:01,280 --> 02:37:05,520
gear ratio

02:37:02,399 --> 02:37:07,040
there's a diameter it has a and then the

02:37:05,520 --> 02:37:09,920
two properties for

02:37:07,040 --> 02:37:10,960
does it have a basket and does it have a

02:37:09,920 --> 02:37:12,399
bell or not

02:37:10,960 --> 02:37:14,560
so these are going to be probably

02:37:12,399 --> 02:37:16,000
boolean variables that can be true or

02:37:14,560 --> 02:37:19,439
also

02:37:16,000 --> 02:37:23,200
if it has a basket then you

02:37:19,439 --> 02:37:25,120
make that true so

02:37:23,200 --> 02:37:27,520
and then the class also has two

02:37:25,120 --> 02:37:29,600
functions for changing the gear ratio

02:37:27,520 --> 02:37:32,720
and adjusting the height of the scene

02:37:29,600 --> 02:37:35,280
so to use this class

02:37:32,720 --> 02:37:35,280
i could

02:37:36,160 --> 02:37:47,840
copy the code and then you would make

02:37:39,600 --> 02:37:47,840
an object say bicycle

02:37:50,319 --> 02:37:53,840
and then you can give it a color let's

02:37:52,399 --> 02:37:58,160
say it's red

02:37:53,840 --> 02:37:58,160
and let's say it's made of

02:37:58,960 --> 02:38:06,479
it's made of aluminium and it has

02:38:03,359 --> 02:38:10,800
it's maybe it is a small bicycle

02:38:06,479 --> 02:38:15,840
then it has a height of

02:38:10,800 --> 02:38:15,840
one meter maybe then you have a

02:38:16,080 --> 02:38:20,800
uh you have a gear ratio let's say

02:38:18,800 --> 02:38:24,080
telegram issue of two

02:38:20,800 --> 02:38:27,439
the diameter of the wheel could be

02:38:24,080 --> 02:38:31,040
10 or maybe

02:38:27,439 --> 02:38:34,080
0.5 actually 10 is not too realistic but

02:38:31,040 --> 02:38:36,560
the the last two properties it could be

02:38:34,080 --> 02:38:38,960
it could uh let's say it doesn't have a

02:38:36,560 --> 02:38:42,080
basket and it does have a bell

02:38:38,960 --> 02:38:42,080
so say

02:38:49,439 --> 02:38:53,520
the material is aluminium the size is

02:38:52,800 --> 02:38:56,640
small

02:38:53,520 --> 02:38:57,359
and its height is one the garage here is

02:38:56,640 --> 02:39:00,560
two

02:38:57,359 --> 02:39:02,960
the diameter of the wheel is 0.5

02:39:00,560 --> 02:39:04,560
and it doesn't have a basket and it has

02:39:02,960 --> 02:39:08,000
a belt

02:39:04,560 --> 02:39:11,600
and now if i

02:39:08,000 --> 02:39:16,160
do cycle dot change

02:39:11,600 --> 02:39:16,160
gear and i set the value to let's say

02:39:16,399 --> 02:39:23,040
4.5 so if i print cycle

02:39:19,439 --> 02:39:26,319
dot pair ratio before and after this

02:39:23,040 --> 02:39:26,319
function is going to be

02:39:26,640 --> 02:39:30,479
it's going to change to 4.5

02:39:34,399 --> 02:39:53,840
so now that i print the values we have

02:39:38,000 --> 02:39:53,840
first s2 and then it changes to 4.5

02:39:57,160 --> 02:40:00,270
[Music]

02:40:02,700 --> 02:40:05,909
[Music]

02:40:18,840 --> 02:40:21,840
okay

02:40:26,479 --> 02:40:33,200
okay so and now he uh move on

02:40:29,920 --> 02:40:36,640
so what makes classes so good

02:40:33,200 --> 02:40:40,240
with code so classes are

02:40:36,640 --> 02:40:41,520
incredibly reusable so you saw earlier

02:40:40,240 --> 02:40:44,080
that you can make

02:40:41,520 --> 02:40:46,399
as many objects with a class as you like

02:40:44,080 --> 02:40:49,520
it's incredibly modular as well

02:40:46,399 --> 02:40:50,720
so you can reuse a class as many times

02:40:49,520 --> 02:40:52,800
as you want and

02:40:50,720 --> 02:40:54,560
if the code is incredibly more modular

02:40:52,800 --> 02:40:57,200
and it's easy for

02:40:54,560 --> 02:40:58,319
a programmer to keep up the code whether

02:40:57,200 --> 02:41:00,840
it works

02:40:58,319 --> 02:41:02,080
in in a proper class than an

02:41:00,840 --> 02:41:06,720
object-oriented

02:41:02,080 --> 02:41:10,240
program it's the code is also more clear

02:41:06,720 --> 02:41:12,640
as to when

02:41:10,240 --> 02:41:13,840
like it's easier for others to read your

02:41:12,640 --> 02:41:17,120
code and understand it

02:41:13,840 --> 02:41:18,640
because of the high modularity and using

02:41:17,120 --> 02:41:22,080
functions

02:41:18,640 --> 02:41:23,840
uh it's also better organization

02:41:22,080 --> 02:41:25,359
for the class because your data can be

02:41:23,840 --> 02:41:27,840
clearly and neatly

02:41:25,359 --> 02:41:28,560
organized for more complex objects let's

02:41:27,840 --> 02:41:30,560
say you have an

02:41:28,560 --> 02:41:31,680
object that has like 100 different

02:41:30,560 --> 02:41:34,720
properties

02:41:31,680 --> 02:41:36,880
then it's so much more nicer to

02:41:34,720 --> 02:41:38,160
have it as an object than 100 different

02:41:36,880 --> 02:41:42,479
variables

02:41:38,160 --> 02:41:45,600
so it's better with organization

02:41:42,479 --> 02:41:47,279
and also allows for something known as

02:41:45,600 --> 02:41:50,479
data abstraction

02:41:47,279 --> 02:41:53,200
so data abstraction is basically the

02:41:50,479 --> 02:41:54,000
process of hiding the implementation

02:41:53,200 --> 02:41:56,160
details of

02:41:54,000 --> 02:41:57,840
something from the user and allowing

02:41:56,160 --> 02:41:58,880
them to focus on the functionality

02:41:57,840 --> 02:42:02,399
instead

02:41:58,880 --> 02:42:05,600
so for example if i have a list

02:42:02,399 --> 02:42:09,040
of numbers right i have 4

02:42:05,600 --> 02:42:11,680
2 1 55

02:42:09,040 --> 02:42:12,560
2 3 something like this and i want to

02:42:11,680 --> 02:42:14,640
sort the list

02:42:12,560 --> 02:42:16,000
i can sort the list just by saying

02:42:14,640 --> 02:42:19,200
list.sort

02:42:16,000 --> 02:42:22,000
and now when i print the list my

02:42:19,200 --> 02:42:23,279
list will the the values are in

02:42:22,000 --> 02:42:26,800
increasing order

02:42:23,279 --> 02:42:29,040
so i don't need to know how that sort

02:42:26,800 --> 02:42:29,840
method is implemented i just know that

02:42:29,040 --> 02:42:31,680
it works

02:42:29,840 --> 02:42:33,439
and i can use it if i want to use it in

02:42:31,680 --> 02:42:36,479
my program so that's

02:42:33,439 --> 02:42:39,359
basically abstraction because i'm hiding

02:42:36,479 --> 02:42:40,080
python has hidden how slot is working

02:42:39,359 --> 02:42:42,479
internally

02:42:40,080 --> 02:42:43,760
this just provides us the functionality

02:42:42,479 --> 02:42:47,120
of the

02:42:43,760 --> 02:42:50,240
feature so it's also incredibly useful

02:42:47,120 --> 02:42:53,520
for that and is also

02:42:50,240 --> 02:42:54,479
the same thing is it applies to objects

02:42:53,520 --> 02:42:56,560
in your

02:42:54,479 --> 02:42:58,000
life like daily life as well like your

02:42:56,560 --> 02:42:59,760
smartphones

02:42:58,000 --> 02:43:01,439
you don't need to know how the

02:42:59,760 --> 02:43:02,800
smartphone is wired

02:43:01,439 --> 02:43:04,399
internally like you don't need to know

02:43:02,800 --> 02:43:05,920
how the circuits are connected to be

02:43:04,399 --> 02:43:07,680
able to use a smartphone

02:43:05,920 --> 02:43:09,600
you can still use a smartphone even if

02:43:07,680 --> 02:43:12,800
you don't know that stuff

02:43:09,600 --> 02:43:16,160
so it's a incredibly

02:43:12,800 --> 02:43:18,800
useful concept and lastly

02:43:16,160 --> 02:43:21,359
an object it can also have other objects

02:43:18,800 --> 02:43:23,840
as its properties if you have

02:43:21,359 --> 02:43:24,960
a class i have a class pen here and a

02:43:23,840 --> 02:43:27,680
class pencil

02:43:24,960 --> 02:43:28,640
and then there's a glass stationary so

02:43:27,680 --> 02:43:32,319
the stationery

02:43:28,640 --> 02:43:35,600
has a pen and a pencil as its properties

02:43:32,319 --> 02:43:36,720
so an object can have other objects as

02:43:35,600 --> 02:43:39,760
its properties

02:43:36,720 --> 02:43:43,439
as well okay so

02:43:39,760 --> 02:43:46,800
and with with that we come to the

02:43:43,439 --> 02:43:50,240
end of the session there is

02:43:46,800 --> 02:43:51,920
still uh one part that uh

02:43:50,240 --> 02:43:54,640
it seems like he won't be able to cover

02:43:51,920 --> 02:43:57,840
because he ran out of time

02:43:54,640 --> 02:44:00,800
but um you can go back

02:43:57,840 --> 02:44:02,560
and like read the next part on your own

02:44:00,800 --> 02:44:05,600
and try to understand it

02:44:02,560 --> 02:44:09,120
because it's but he did cover

02:44:05,600 --> 02:44:12,479
most of the important concepts for

02:44:09,120 --> 02:44:16,080
uh python and programming in general

02:44:12,479 --> 02:44:19,359
so i hope that after today's session

02:44:16,080 --> 02:44:20,880
you go back and try more of these kinds

02:44:19,359 --> 02:44:33,840
of problems and

02:44:20,880 --> 02:44:33,840
and learn more about programming

02:44:37,040 --> 02:44:40,880
if you have any uh questions you can ask

02:44:40,000 --> 02:44:44,800
and

02:44:40,880 --> 02:44:44,800
with that we come to the end of the

02:44:44,840 --> 02:44:47,840
session

02:44:51,840 --> 02:44:57,760
i wouldn't recommend any uh textbooks

02:44:55,120 --> 02:45:00,399
a person i'll say there's a website

02:44:57,760 --> 02:45:03,279
called w3schools.com

02:45:00,399 --> 02:45:04,160
for any programming language in general

02:45:03,279 --> 02:45:06,120
it has

02:45:04,160 --> 02:45:08,880
a reference for python

02:45:06,120 --> 02:45:14,479
[Music]

02:45:08,880 --> 02:45:17,680
and find it here

02:45:14,479 --> 02:45:17,920
so i recommend this website for python

02:45:17,680 --> 02:45:19,840
and

02:45:17,920 --> 02:45:21,600
it has other programming languages as

02:45:19,840 --> 02:45:22,479
well if you're interested in learning

02:45:21,600 --> 02:45:25,920
tools

02:45:22,479 --> 02:45:28,000
so you can you can uh go to the website

02:45:25,920 --> 02:45:29,760
and it has uh

02:45:28,000 --> 02:45:31,600
quite a like it has a lot of different

02:45:29,760 --> 02:45:33,920
topics and it goes into

02:45:31,600 --> 02:45:35,040
much more detail than i had time to

02:45:33,920 --> 02:45:37,359
cover today

02:45:35,040 --> 02:45:38,080
so if you're interested to learn more

02:45:37,359 --> 02:45:40,840
you can

02:45:38,080 --> 02:45:42,319
go to the website and learn more about

02:45:40,840 --> 02:45:44,960
python

02:45:42,319 --> 02:45:45,359
and for any programming language it's

02:45:44,960 --> 02:45:48,319
much

02:45:45,359 --> 02:45:48,880
much much more efficient to learn by

02:45:48,319 --> 02:45:51,120
doing

02:45:48,880 --> 02:45:53,520
problems and trying to write code on

02:45:51,120 --> 02:45:56,880
your own than reading from a textbook

02:45:53,520 --> 02:45:57,200
so i highly recommend you you you try to

02:45:56,880 --> 02:45:59,760
do

02:45:57,200 --> 02:45:59,760
problems

02:46:00,240 --> 02:46:04,319
you can look at different questions

02:46:03,439 --> 02:46:08,399
online

02:46:04,319 --> 02:46:09,040
and try to try to get as much practice

02:46:08,399 --> 02:46:12,080
as you can

02:46:09,040 --> 02:46:12,080
that's the key to

02:46:12,560 --> 02:46:25,840
having an effective knowledge of any

02:46:14,880 --> 02:46:25,840
programming language

02:46:29,520 --> 02:46:33,120
okay with that we come to the end of the

02:46:32,319 --> 02:46:36,160
session

02:46:33,120 --> 02:46:38,800
and there's uh

02:46:36,160 --> 02:46:39,439
there's this uh qr code that you guys

02:46:38,800 --> 02:46:42,560
can

02:46:39,439 --> 02:46:46,160
scan for uh

02:46:42,560 --> 02:46:48,960
for uh sharing some feedback and

02:46:46,160 --> 02:46:49,520
there's you can find more information

02:46:48,960 --> 02:46:51,600
about

02:46:49,520 --> 02:46:53,040
a wide range of training courses and

02:46:51,600 --> 02:46:56,399
resources at

02:46:53,040 --> 02:46:58,240
the my skills future website so

02:46:56,399 --> 02:46:59,920
if you're looking to upgrade your skills

02:46:58,240 --> 02:47:03,040
for a career or progression

02:46:59,920 --> 02:47:06,319
or transition but you're not sure

02:47:03,040 --> 02:47:10,160
on where to start then you can

02:47:06,319 --> 02:47:13,760
speak with skill futures singapore's

02:47:10,160 --> 02:47:14,640
skills ambassadors and to identify your

02:47:13,760 --> 02:47:17,200
skill

02:47:14,640 --> 02:47:19,040
needs and gaps and gain useful tips and

02:47:17,200 --> 02:47:22,319
advice on how to kick start your

02:47:19,040 --> 02:47:22,800
skills search you can scan the qr code

02:47:22,319 --> 02:47:35,840
to

02:47:22,800 --> 02:47:35,840
find out more about this

02:47:46,840 --> 02:47:49,840
oh

02:48:00,840 --> 02:48:03,840
okay

02:48:29,520 --> 02:48:31,600

YouTube URL: https://www.youtube.com/watch?v=PavxOv3k2aE


