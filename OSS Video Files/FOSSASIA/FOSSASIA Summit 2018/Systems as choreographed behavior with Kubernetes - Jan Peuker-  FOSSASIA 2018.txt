Title: Systems as choreographed behavior with Kubernetes - Jan Peuker-  FOSSASIA 2018
Publication date: 2018-03-23
Playlist: FOSSASIA Summit 2018
Description: 
	Speaker: Jan Peuker, Product Technology Manager Google
Info: https://2018.fossasia.org/event/speakers.html#jan-peuker3355

Why should you use Kubernetes, an Istio Service Mesh or any choreographed Microservice architecture? There is the efficiency argument, scaling, time to market. There is the isolation argument, resilience. But in this talk, we share a different perspective: Our systems are becoming polyglot, intelligent, and rapidly moving towards an evolutionary mode where machine learning is a natural collaborator in the design thinking and coding process. Let’s play with that idea.

Room: Lecture Theatre
Track: Cloud, Container, DevOps
Date: Friday, 23rd March, 2018

Event Page: http://2018.fossasia.org
Follow FOSSASIA on Twitter: https://twitter.com/fossasia/
Like FOSSASIA on Facebook: https://www.facebook.com/fossasia/

Produced by Engineers.SG
Captions: 
	00:00:00,030 --> 00:00:13,080
no please spell means hello everyone is

00:00:11,040 --> 00:00:15,750
yarn from Google he's gonna be part of

00:00:13,080 --> 00:00:18,029
kubernetes Asia conference is apparently

00:00:15,750 --> 00:00:19,650
about half this conference is that and

00:00:18,029 --> 00:00:21,300
you wanna talk about the future

00:00:19,650 --> 00:00:23,490
involving AI coven it is or something

00:00:21,300 --> 00:00:24,720
else quite vague you you go do you yeah

00:00:23,490 --> 00:00:28,890
is that everyone say hi

00:00:24,720 --> 00:00:31,740
it's enjoy yeah it's it's very weak and

00:00:28,890 --> 00:00:33,000
that's actually on purpose because yeah

00:00:31,740 --> 00:00:34,469
I had the feeling that's already pretty

00:00:33,000 --> 00:00:38,370
cool kubernetes walks around on this

00:00:34,469 --> 00:00:39,840
conference but I was missing a certain

00:00:38,370 --> 00:00:41,370
type of talk that is a little bit more

00:00:39,840 --> 00:00:43,050
maybe architectural and maybe I'm

00:00:41,370 --> 00:00:44,850
talking a little bit more about the

00:00:43,050 --> 00:00:46,230
ideas so this is not gonna be as fancy

00:00:44,850 --> 00:00:48,710
as Felipa stuff I'm not going to be so

00:00:46,230 --> 00:00:51,079
humorous but maybe gives you a few ideas

00:00:48,710 --> 00:00:52,829
around kubernetes

00:00:51,079 --> 00:00:55,379
okay so let's dive right in because

00:00:52,829 --> 00:00:57,840
we're a little bit behind time has any

00:00:55,379 --> 00:01:00,329
been to my has anyone had been to my big

00:00:57,840 --> 00:01:01,949
ferry workshop this morning awesome cool

00:01:00,329 --> 00:01:03,180
thank you very much so for the ones who

00:01:01,949 --> 00:01:05,040
haven't been there just very a quick

00:01:03,180 --> 00:01:07,170
intro but be curious bigquery is

00:01:05,040 --> 00:01:10,380
Google's data warehouse you've just seen

00:01:07,170 --> 00:01:12,330
Felipe working with stat okay so what I

00:01:10,380 --> 00:01:13,950
like about bigquery is that it actually

00:01:12,330 --> 00:01:16,080
brings you back to the original spirit

00:01:13,950 --> 00:01:18,900
of SQL of having this unified language

00:01:16,080 --> 00:01:20,970
with which you can access any type of

00:01:18,900 --> 00:01:22,110
data and really define an insight if you

00:01:20,970 --> 00:01:26,610
want to have that's actually really

00:01:22,110 --> 00:01:27,810
really nice so that's that's really

00:01:26,610 --> 00:01:29,009
beautiful if you're coming from like a

00:01:27,810 --> 00:01:30,560
world where you have to you know manage

00:01:29,009 --> 00:01:33,780
database connection strings and stuff

00:01:30,560 --> 00:01:35,759
and I was wondering so what would we

00:01:33,780 --> 00:01:39,780
have to do to have the same kind of like

00:01:35,759 --> 00:01:42,479
expressiveness of SQL and a a magic

00:01:39,780 --> 00:01:44,070
engine like bigquery for code for our

00:01:42,479 --> 00:01:45,960
applications right how would we have to

00:01:44,070 --> 00:01:48,390
write applications that it becomes as

00:01:45,960 --> 00:01:50,220
easy as writing an SQL and bigquery and

00:01:48,390 --> 00:01:51,720
that's going to be basically the the

00:01:50,220 --> 00:01:53,490
premise of this talk and see okay so how

00:01:51,720 --> 00:01:55,040
could we use communities to arrive at

00:01:53,490 --> 00:01:58,100
something like that

00:01:55,040 --> 00:02:00,180
spoiler alert we're not there yet but

00:01:58,100 --> 00:02:02,909
but maybe they can give you a few ideas

00:02:00,180 --> 00:02:05,430
also to contribute to communities in the

00:02:02,909 --> 00:02:09,300
future okay so what's the problem why

00:02:05,430 --> 00:02:12,319
why can't we make that so easily well a

00:02:09,300 --> 00:02:15,290
few of you I'm a little bit old

00:02:12,319 --> 00:02:17,930
I've seen data and logic be coupled it

00:02:15,290 --> 00:02:19,700
wasn't good idea didn't work Lotus Notes

00:02:17,930 --> 00:02:21,799
and so on great systems I actually like

00:02:19,700 --> 00:02:24,859
them but didn't scale very well so this

00:02:21,799 --> 00:02:26,840
is the wrong route to go bias is wrong

00:02:24,859 --> 00:02:28,760
there for me the biggest difference is

00:02:26,840 --> 00:02:31,310
and there's a nice research done by

00:02:28,760 --> 00:02:32,689
Nicole Faust grand on that that the

00:02:31,310 --> 00:02:34,069
development teams are actually most

00:02:32,689 --> 00:02:36,230
efficient than they're running into a

00:02:34,069 --> 00:02:39,620
DevOps modes with one common problem and

00:02:36,230 --> 00:02:41,629
I really like domain-driven so you want

00:02:39,620 --> 00:02:44,180
to have one small core team and really

00:02:41,629 --> 00:02:45,709
working and iterating and prototyping on

00:02:44,180 --> 00:02:48,049
on code so that's very different from

00:02:45,709 --> 00:02:50,180
the way we and we work with data data is

00:02:48,049 --> 00:02:51,799
way more we write a query run it against

00:02:50,180 --> 00:02:53,989
the query so it's way more braking force

00:02:51,799 --> 00:02:56,299
like a conversation and code works more

00:02:53,989 --> 00:02:58,519
collaboratively so we need to solve that

00:02:56,299 --> 00:02:58,970
we need to solve that problem how do we

00:02:58,519 --> 00:03:01,760
solve that

00:02:58,970 --> 00:03:03,980
always ask to the rescue we've seen

00:03:01,760 --> 00:03:05,930
really great developments in the in the

00:03:03,980 --> 00:03:08,629
open-source community that I think guide

00:03:05,930 --> 00:03:11,900
us a little bit in the right way I guess

00:03:08,629 --> 00:03:13,879
most of you have used it up kids up but

00:03:11,900 --> 00:03:16,129
when github introduced a fork it looked

00:03:13,879 --> 00:03:17,299
a little bit normal but over the years

00:03:16,129 --> 00:03:18,859
we learned that actually solves

00:03:17,299 --> 00:03:21,199
recording is a pretty great idea and

00:03:18,859 --> 00:03:23,629
that even influenced the whole culture

00:03:21,199 --> 00:03:25,220
of communities when forks were spawned

00:03:23,629 --> 00:03:28,129
off and merged back like the node.js

00:03:25,220 --> 00:03:29,269
story for instance I really enjoy to to

00:03:28,129 --> 00:03:31,280
follow that and that's actually a nice

00:03:29,269 --> 00:03:33,260
way of building of building applications

00:03:31,280 --> 00:03:35,150
if you go one step further you can even

00:03:33,260 --> 00:03:38,690
come to systems like glitchy mature if

00:03:35,150 --> 00:03:40,159
anyone knows glitch here for them the

00:03:38,690 --> 00:03:42,889
fork is the root of everything and

00:03:40,159 --> 00:03:44,750
everything just bases ups based itself

00:03:42,889 --> 00:03:46,729
up on a fork again and they call it

00:03:44,750 --> 00:03:48,079
remixes really great for beginner coders

00:03:46,729 --> 00:03:50,359
because you just start was code in the

00:03:48,079 --> 00:03:51,949
browser and you build up someone else's

00:03:50,359 --> 00:03:54,109
work and just combine it again in a

00:03:51,949 --> 00:03:57,349
really fluid way so that's really really

00:03:54,109 --> 00:03:58,909
nice unfortunately we can't code that

00:03:57,349 --> 00:04:00,620
way because we need to also be

00:03:58,909 --> 00:04:03,109
production ready and we can't break for

00:04:00,620 --> 00:04:04,939
users all the time in production I work

00:04:03,109 --> 00:04:05,689
for Google I worked in a little bit like

00:04:04,939 --> 00:04:08,030
an SRE

00:04:05,689 --> 00:04:09,199
kind of like role I can tell you on call

00:04:08,030 --> 00:04:12,049
it's not funny if you're being paged

00:04:09,199 --> 00:04:14,989
five times a night so which luckily she

00:04:12,049 --> 00:04:17,630
at Google never happened to me but but I

00:04:14,989 --> 00:04:18,979
got paged a few times and that's so we

00:04:17,630 --> 00:04:20,840
want to be production ready so we need

00:04:18,979 --> 00:04:22,909
to take this kind of like idea of

00:04:20,840 --> 00:04:24,469
talking code and actually make it

00:04:22,909 --> 00:04:24,770
resilient and make a scalable and make

00:04:24,469 --> 00:04:26,960
it

00:04:24,770 --> 00:04:28,419
unified and what does that actually mean

00:04:26,960 --> 00:04:31,340
well that very simply means

00:04:28,419 --> 00:04:33,080
infrastructure as code says it's going

00:04:31,340 --> 00:04:35,360
to talk about that tomorrow

00:04:33,080 --> 00:04:37,009
but basically what that means is if we

00:04:35,360 --> 00:04:39,590
only have everything in code then our

00:04:37,009 --> 00:04:41,300
systems are predictable but everything

00:04:39,590 --> 00:04:43,129
is really hard right because everything

00:04:41,300 --> 00:04:45,020
means not only the definition of our

00:04:43,129 --> 00:04:46,759
infrastructure but that means our

00:04:45,020 --> 00:04:48,500
database should be version as well and

00:04:46,759 --> 00:04:49,909
that even means our monitoring or

00:04:48,500 --> 00:04:51,620
documentation everything has to be

00:04:49,909 --> 00:04:53,479
versioned alongside in the same tree

00:04:51,620 --> 00:04:54,860
that's actually what we're doing in

00:04:53,479 --> 00:04:56,300
Google there's a nice talk on that by

00:04:54,860 --> 00:04:58,069
Rachel Portman if you haven't seen that

00:04:56,300 --> 00:04:59,810
and we only have one code repository

00:04:58,069 --> 00:05:02,300
that stores all of that what I just

00:04:59,810 --> 00:05:04,099
mentioned alongside in one het version

00:05:02,300 --> 00:05:07,400
number I'm not saying this is the

00:05:04,099 --> 00:05:10,940
perfect idea for everyone but it allows

00:05:07,400 --> 00:05:13,370
some of those message said I just have

00:05:10,940 --> 00:05:17,389
mentioned really working with code and

00:05:13,370 --> 00:05:19,520
much more fluids organic kind of way if

00:05:17,389 --> 00:05:21,469
you do that and then you're also

00:05:19,520 --> 00:05:23,120
automatically kind of like cloud native

00:05:21,469 --> 00:05:25,090
because you're actually independent from

00:05:23,120 --> 00:05:28,479
your underlying infrastructure and

00:05:25,090 --> 00:05:30,289
you're working on those kind of premises

00:05:28,479 --> 00:05:32,090
and not anymore

00:05:30,289 --> 00:05:33,530
I'm assuming things about your

00:05:32,090 --> 00:05:34,880
production system that is not defined

00:05:33,530 --> 00:05:37,159
somewhere else adjust in the heads of

00:05:34,880 --> 00:05:39,919
like one person somewhere that's what

00:05:37,159 --> 00:05:43,219
Chris was talking about this morning so

00:05:39,919 --> 00:05:45,560
that's great so what can we do what how

00:05:43,219 --> 00:05:48,020
can we arrive there so if you look at

00:05:45,560 --> 00:05:50,840
how systems were integrated a long time

00:05:48,020 --> 00:05:52,490
ago this was usually direct write to

00:05:50,840 --> 00:05:54,680
systems talking to each other remote

00:05:52,490 --> 00:05:55,940
procedure call lookup tables if you use

00:05:54,680 --> 00:05:59,630
messaging then you use something like

00:05:55,940 --> 00:06:02,750
pipes then we got a little bit looser

00:05:59,630 --> 00:06:09,259
cupping coupling we did things like

00:06:02,750 --> 00:06:12,169
static routing jndi java 1.3 cues have

00:06:09,259 --> 00:06:13,669
been around for quite some time and then

00:06:12,169 --> 00:06:15,740
at some point we arrived at like a

00:06:13,669 --> 00:06:17,300
dynamic routing model and for some times

00:06:15,740 --> 00:06:19,400
this was basically state of that so you

00:06:17,300 --> 00:06:21,800
would have an ESB we still have API

00:06:19,400 --> 00:06:23,719
management in that direction and we have

00:06:21,800 --> 00:06:25,219
all kind of routers and that's typically

00:06:23,719 --> 00:06:27,139
what you still see in most kind of

00:06:25,219 --> 00:06:30,770
enterprises because that's it brings you

00:06:27,139 --> 00:06:32,509
this predictability okay the problem

00:06:30,770 --> 00:06:35,089
with this kind of model though is that

00:06:32,509 --> 00:06:37,610
this respectability and this behavior in

00:06:35,089 --> 00:06:38,540
the end of your overall system is now

00:06:37,610 --> 00:06:40,880
defined

00:06:38,540 --> 00:06:42,980
outside of your system in something else

00:06:40,880 --> 00:06:45,680
that you don't really control and that

00:06:42,980 --> 00:06:47,750
always brings a new problem some could

00:06:45,680 --> 00:06:50,150
tell you countless stories where you

00:06:47,750 --> 00:06:51,410
deploy to production and all suddenly a

00:06:50,150 --> 00:06:53,060
message bus is differently configured

00:06:51,410 --> 00:06:55,550
from the one who was on you 80 who did

00:06:53,060 --> 00:06:57,230
that oh I don't know some other random

00:06:55,550 --> 00:06:58,730
persons so and those kind of problems

00:06:57,230 --> 00:07:01,100
occur all the time that makes the

00:06:58,730 --> 00:07:03,470
systems less predictable and with that

00:07:01,100 --> 00:07:04,670
decreases your iteration speed and your

00:07:03,470 --> 00:07:07,100
product development speed and you were

00:07:04,670 --> 00:07:09,200
and you're mixing flexibility if you

00:07:07,100 --> 00:07:11,900
want to call it that way so in parallel

00:07:09,200 --> 00:07:15,290
to that and we had we saw development of

00:07:11,900 --> 00:07:18,200
like pops up patterns Kafka pops up

00:07:15,290 --> 00:07:19,850
generally became a lot more popular and

00:07:18,200 --> 00:07:22,000
the over Hollywood principle s and

00:07:19,850 --> 00:07:24,950
criminals api's and so on and so forth

00:07:22,000 --> 00:07:26,930
and in parallel I'm a big airline fan so

00:07:24,950 --> 00:07:29,360
I have to mention here agent and stream

00:07:26,930 --> 00:07:31,670
systems for this also developed and is

00:07:29,360 --> 00:07:33,350
maybe the most informal of all of those

00:07:31,670 --> 00:07:35,150
models of integration right if I have a

00:07:33,350 --> 00:07:36,710
stream based system everything is agent

00:07:35,150 --> 00:07:40,130
everything is flu wouldn't and that's

00:07:36,710 --> 00:07:42,800
great the only problem with this these

00:07:40,130 --> 00:07:44,780
more informal approaches there is that

00:07:42,800 --> 00:07:47,090
the more informal they get the more

00:07:44,780 --> 00:07:49,100
complex middleware they need right so

00:07:47,090 --> 00:07:51,890
Allen is great but it's really only

00:07:49,100 --> 00:07:53,720
running on the LLVM right as streams is

00:07:51,890 --> 00:07:55,880
great but you need a really really rigid

00:07:53,720 --> 00:07:57,500
platform for that and while this is

00:07:55,880 --> 00:08:00,020
perfect if you can completely rely on

00:07:57,500 --> 00:08:03,050
the platform that will usually or very

00:08:00,020 --> 00:08:04,490
often cause you to need to integrate the

00:08:03,050 --> 00:08:06,170
system's out of your platform and then

00:08:04,490 --> 00:08:07,970
again you're in this loop of like well

00:08:06,170 --> 00:08:09,200
it's not actually predictable so let's

00:08:07,970 --> 00:08:10,910
say for instance you have a stream based

00:08:09,200 --> 00:08:12,770
system there's really cool work done by

00:08:10,910 --> 00:08:15,080
by light been for instance two whole

00:08:12,770 --> 00:08:17,030
reactive manifesto stuff it's really

00:08:15,080 --> 00:08:18,560
cool but then you need a database that

00:08:17,030 --> 00:08:20,030
runs on that and you don't have that so

00:08:18,560 --> 00:08:21,650
suddenly you have something outside of

00:08:20,030 --> 00:08:24,530
your system that you need to handle and

00:08:21,650 --> 00:08:27,020
was there to bring entropy and so how

00:08:24,530 --> 00:08:30,020
can we solve this how how can we

00:08:27,020 --> 00:08:30,530
reconcile these these approaches in in a

00:08:30,020 --> 00:08:32,720
better way

00:08:30,530 --> 00:08:35,479
well Google has been doing a little bit

00:08:32,720 --> 00:08:36,890
of that for some time and I can explain

00:08:35,479 --> 00:08:40,760
a little bit about our approach and how

00:08:36,890 --> 00:08:42,890
that feeds into communities so not sure

00:08:40,760 --> 00:08:46,070
if you've ever seen that picture this

00:08:42,890 --> 00:08:47,540
was Google's first and Rec server it's

00:08:46,070 --> 00:08:48,740
actually in the National Museum of

00:08:47,540 --> 00:08:50,600
American history it's called the

00:08:48,740 --> 00:08:51,410
corkboard server because those bots are

00:08:50,600 --> 00:08:54,620
stacked

00:08:51,410 --> 00:08:56,420
Kwak so why is that interesting and

00:08:54,620 --> 00:08:58,940
relevant if anyone of you has seen Rex

00:08:56,420 --> 00:09:01,069
in the 90s they look very different if

00:08:58,940 --> 00:09:02,750
you looked at a wreck in the 90s when I

00:09:01,069 --> 00:09:04,610
was still taping the kind of stuff

00:09:02,750 --> 00:09:06,860
myself and you would have somewhere like

00:09:04,610 --> 00:09:09,350
a son down there and then you would have

00:09:06,860 --> 00:09:11,689
a few pizza boxes too in compute and

00:09:09,350 --> 00:09:14,000
then bigger ones that maybe had some

00:09:11,689 --> 00:09:15,470
backup or disks in there so you would

00:09:14,000 --> 00:09:18,829
have all of those what we sometimes call

00:09:15,470 --> 00:09:22,160
snowflake servers in there if you think

00:09:18,829 --> 00:09:26,029
this is 1999 or I think it was built

00:09:22,160 --> 00:09:27,829
1997 the basic idea behind that is that

00:09:26,029 --> 00:09:29,959
from the very very beginning who for

00:09:27,829 --> 00:09:33,079
Google everything was a software problem

00:09:29,959 --> 00:09:34,459
right so we didn't have different

00:09:33,079 --> 00:09:35,839
servers for different types of stuff and

00:09:34,459 --> 00:09:37,490
we actually only have two types of

00:09:35,839 --> 00:09:38,930
servers compute heavy machines or

00:09:37,490 --> 00:09:43,250
storage heavy machines into this day

00:09:38,930 --> 00:09:45,500
half and and all the rest was was

00:09:43,250 --> 00:09:47,360
organized by software so basically was

00:09:45,500 --> 00:09:49,040
just the role of a motherboard and

00:09:47,360 --> 00:09:50,569
that's why everything here looks the

00:09:49,040 --> 00:09:53,240
same which is actually pretty cool and

00:09:50,569 --> 00:09:57,350
as industry standard components nothing

00:09:53,240 --> 00:10:01,069
special in there so this inspired em how

00:09:57,350 --> 00:10:03,410
we build our architecture and then

00:10:01,069 --> 00:10:05,839
there's two main concepts here one is

00:10:03,410 --> 00:10:07,160
containers in this talk I kind of assume

00:10:05,839 --> 00:10:09,560
you a little bit know other containers

00:10:07,160 --> 00:10:11,870
but if you want to one-liner it's a very

00:10:09,560 --> 00:10:13,579
light to the em like immutable process

00:10:11,870 --> 00:10:15,560
isolation so you can take something

00:10:13,579 --> 00:10:17,420
textile in a container and then the

00:10:15,560 --> 00:10:18,949
container can run anywhere but you can

00:10:17,420 --> 00:10:21,079
do that in a very light way as opposed

00:10:18,949 --> 00:10:23,120
to the other not saying that VMs are bad

00:10:21,079 --> 00:10:24,439
but I'm sometimes really great but

00:10:23,120 --> 00:10:26,930
containers are a little bit more fluids

00:10:24,439 --> 00:10:28,310
in this whole idea of agility now

00:10:26,930 --> 00:10:31,339
unfortunately if you have all of those

00:10:28,310 --> 00:10:33,170
little lemmings running around those

00:10:31,339 --> 00:10:36,019
containers that by constantly somewhere

00:10:33,170 --> 00:10:38,750
and and spread around to need something

00:10:36,019 --> 00:10:39,800
to manage that Google's approach to

00:10:38,750 --> 00:10:42,139
manage type of spork

00:10:39,800 --> 00:10:44,569
so Bacchus the cluster management system

00:10:42,139 --> 00:10:46,309
the biggest difference from work to

00:10:44,569 --> 00:10:48,829
other systems is that it's declarative

00:10:46,309 --> 00:10:50,809
so and you used to in a cluster

00:10:48,829 --> 00:10:53,000
management systems say very precisely

00:10:50,809 --> 00:10:55,730
these are the servers that's where it

00:10:53,000 --> 00:10:58,339
runs and you basically would script

00:10:55,730 --> 00:11:00,019
something like I like interval for

00:10:58,339 --> 00:11:01,399
instance and so you would have a very

00:11:00,019 --> 00:11:03,740
clear script of how the product works

00:11:01,399 --> 00:11:04,220
right and Bacchus tea actually the other

00:11:03,740 --> 00:11:05,730
way around

00:11:04,220 --> 00:11:09,749
so bork sec

00:11:05,730 --> 00:11:11,999
more of a configuration store box s-view

00:11:09,749 --> 00:11:14,189
cluster we have a new application

00:11:11,999 --> 00:11:16,949
say hi application and this application

00:11:14,189 --> 00:11:19,919
would like to run on 70 servers and it

00:11:16,949 --> 00:11:23,069
needs a quarter CPU on each server and

00:11:19,919 --> 00:11:24,839
one gigabyte of RAM dear service please

00:11:23,069 --> 00:11:26,879
then we practically decide between you

00:11:24,839 --> 00:11:28,199
who takes up this load that's a very

00:11:26,879 --> 00:11:30,419
very different approach right so it's

00:11:28,199 --> 00:11:32,399
not like a service call but the server's

00:11:30,419 --> 00:11:34,079
constantly go back to the central

00:11:32,399 --> 00:11:35,850
configuration system and say hey okay I

00:11:34,079 --> 00:11:36,269
have spare resources now what can I do

00:11:35,850 --> 00:11:40,259
next

00:11:36,269 --> 00:11:42,540
and this allows a very very very very

00:11:40,259 --> 00:11:44,189
horizontal scale because in the end it's

00:11:42,540 --> 00:11:45,839
actually what we just spoke about agent

00:11:44,189 --> 00:11:47,850
systems a stream system in the editor

00:11:45,839 --> 00:11:50,819
and it's agent based system bak in

00:11:47,850 --> 00:11:53,429
itself so that inspired kubernetes when

00:11:50,819 --> 00:11:56,970
Etta's if you want the open source third

00:11:53,429 --> 00:11:59,689
iteration of pork and there's also

00:11:56,970 --> 00:12:02,399
what's running on the on the GAE so the

00:11:59,689 --> 00:12:05,009
kinetise engine and that's why we're

00:12:02,399 --> 00:12:06,689
coming back and to our to the title of

00:12:05,009 --> 00:12:07,949
my talk I skipped it a little bit in the

00:12:06,689 --> 00:12:10,799
beginning but maybe a few of you were

00:12:07,949 --> 00:12:12,419
wondering and what does choreography

00:12:10,799 --> 00:12:14,100
actually mean such a complicated word

00:12:12,419 --> 00:12:16,559
English is not my native language I

00:12:14,100 --> 00:12:18,269
can't even pronounce it so the

00:12:16,559 --> 00:12:20,549
difference to choreography is if you

00:12:18,269 --> 00:12:23,039
think about the ears piece they always

00:12:20,549 --> 00:12:25,949
talk about orchestration orchestration

00:12:23,039 --> 00:12:27,269
means a conductor stand in front of an

00:12:25,949 --> 00:12:28,410
orchestra and telling everyone what to

00:12:27,269 --> 00:12:31,439
do right

00:12:28,410 --> 00:12:33,439
that's scales well up to a point but at

00:12:31,439 --> 00:12:36,359
some point it doesn't scale anymore and

00:12:33,439 --> 00:12:38,999
as I just said Bach is to opposite walk

00:12:36,359 --> 00:12:40,139
defines roots and then everyone picks up

00:12:38,999 --> 00:12:42,299
what they think according to the rules

00:12:40,139 --> 00:12:44,100
is the best stuff to do now and that's

00:12:42,299 --> 00:12:46,410
what you call choreography that's like a

00:12:44,100 --> 00:12:48,239
big dance of everyone and everyone knows

00:12:46,410 --> 00:12:49,829
what kind of dance there is and there's

00:12:48,239 --> 00:12:51,989
the rhythm of the music around it and

00:12:49,829 --> 00:12:54,749
that's how the system acts so what

00:12:51,989 --> 00:12:59,069
you're getting is a and I really love

00:12:54,749 --> 00:13:00,989
this quote by this paper from from burns

00:12:59,069 --> 00:13:04,259
bak Omega and kubernetes which which

00:13:00,989 --> 00:13:06,869
traces this history you get a desired

00:13:04,259 --> 00:13:09,509
emergent behavior so you have to imagine

00:13:06,869 --> 00:13:11,220
that emergence means something like you

00:13:09,509 --> 00:13:13,289
know like ants like all the ends

00:13:11,220 --> 00:13:16,829
together in itself form an organism and

00:13:13,289 --> 00:13:18,320
it's actually more than the the whole

00:13:16,829 --> 00:13:19,279
system is a lot more than its parts

00:13:18,320 --> 00:13:22,759
if you want and that's the whole idea

00:13:19,279 --> 00:13:24,529
behind communities so there's actually

00:13:22,759 --> 00:13:25,610
the most important message I wanted to

00:13:24,529 --> 00:13:27,829
bring across today that you think of

00:13:25,610 --> 00:13:30,820
kubernetes in that way not to do not as

00:13:27,829 --> 00:13:33,130
a process isolation tool or not as a

00:13:30,820 --> 00:13:35,420
cluster management system that you just

00:13:33,130 --> 00:13:37,910
drop into your whatever you have

00:13:35,420 --> 00:13:40,220
currently but you have to see it as a

00:13:37,910 --> 00:13:44,860
way to bring your applications toward

00:13:40,220 --> 00:13:47,690
this fluid way of of building systems I

00:13:44,860 --> 00:13:49,250
personally I come from a mobile

00:13:47,690 --> 00:13:51,560
application background so I use to

00:13:49,250 --> 00:13:53,750
always work on like more cross-platform

00:13:51,560 --> 00:13:55,940
mobile applications so very earlier I

00:13:53,750 --> 00:13:57,860
did cross-platform stuff and that's when

00:13:55,940 --> 00:13:59,410
you saw this whole stream idea really

00:13:57,860 --> 00:14:02,029
coming in right because you can't just

00:13:59,410 --> 00:14:03,110
use sessions anymore that are cookie

00:14:02,029 --> 00:14:05,360
based and you have different

00:14:03,110 --> 00:14:08,240
applications where you need to pass on a

00:14:05,360 --> 00:14:10,279
session or credential information and at

00:14:08,240 --> 00:14:12,800
that point you very early realized or I

00:14:10,279 --> 00:14:15,380
wrecked and realized that it can only

00:14:12,800 --> 00:14:17,389
work in a in a distributed agent-based

00:14:15,380 --> 00:14:20,269
system where this kind of information is

00:14:17,389 --> 00:14:21,440
just part of the system and not a sticky

00:14:20,269 --> 00:14:23,209
session that's on some like load

00:14:21,440 --> 00:14:26,870
balancer if you're lucky you always get

00:14:23,209 --> 00:14:30,440
the same request okay so let's go a

00:14:26,870 --> 00:14:32,149
little bit deeper and see what we what

00:14:30,440 --> 00:14:34,910
we can do is that I do a very quick mini

00:14:32,149 --> 00:14:36,620
demo and it's all but really goes fast I

00:14:34,910 --> 00:14:38,050
thought in the middle of the talk it's

00:14:36,620 --> 00:14:41,209
nice to give you a little bit of a

00:14:38,050 --> 00:14:43,310
relaxing eye from the white background

00:14:41,209 --> 00:14:44,690
of the slides and just show you very

00:14:43,310 --> 00:14:45,709
quickly how communities looks in case

00:14:44,690 --> 00:14:47,120
you've never seen it before

00:14:45,709 --> 00:14:48,230
again I don't want to do a carbonate

00:14:47,120 --> 00:14:55,990
discourse that other people who are much

00:14:48,230 --> 00:15:03,579
better on that and then I am so this is

00:14:55,990 --> 00:15:08,029
okay yeah I like a little bigger this is

00:15:03,579 --> 00:15:11,449
gke Google compute engine kubernetes

00:15:08,029 --> 00:15:13,069
engine and you see here this is a

00:15:11,449 --> 00:15:16,009
communities cluster the communities

00:15:13,069 --> 00:15:19,819
cluster is just and machines in this

00:15:16,009 --> 00:15:22,250
case is called Foss Asia sto and you see

00:15:19,819 --> 00:15:24,860
this have a cluster size of five what's

00:15:22,250 --> 00:15:26,839
interesting here is kubernetes as you

00:15:24,860 --> 00:15:28,459
might now run some runs on all

00:15:26,839 --> 00:15:30,260
infrastructures right so this is not a

00:15:28,459 --> 00:15:31,580
Google feature you can have the same

00:15:30,260 --> 00:15:33,290
cluster defined

00:15:31,580 --> 00:15:35,390
on your local machine on a set of

00:15:33,290 --> 00:15:36,710
raspberry pies if you've ever seen that

00:15:35,390 --> 00:15:38,660
Kelsey Hightower's book I can only

00:15:36,710 --> 00:15:40,340
recommend that he has an appendix in

00:15:38,660 --> 00:15:44,270
that how to build it in raspberry pies

00:15:40,340 --> 00:15:45,800
or inside your CI CD system and it's all

00:15:44,270 --> 00:15:47,330
the same the cluster is always the same

00:15:45,800 --> 00:15:49,970
you just change the configuration a

00:15:47,330 --> 00:15:52,910
little bit so if I go onto this cluster

00:15:49,970 --> 00:15:56,090
I I see the I see the machines running

00:15:52,910 --> 00:15:58,220
in there and I see the notes okay so

00:15:56,090 --> 00:16:00,200
what I want to do now is this cluster

00:15:58,220 --> 00:16:02,060
has capacity so I'd like to run an

00:16:00,200 --> 00:16:05,780
application the application is very

00:16:02,060 --> 00:16:08,990
simple it's a small it's just a small

00:16:05,780 --> 00:16:10,880
web server I have to host it on a

00:16:08,990 --> 00:16:13,520
container registry here container

00:16:10,880 --> 00:16:16,010
registry comes with cloud and all the

00:16:13,520 --> 00:16:16,310
dust is a web server that says hello for

00:16:16,010 --> 00:16:18,860
seizure

00:16:16,310 --> 00:16:25,190
okay so listed okay great that thing

00:16:18,860 --> 00:16:27,680
exists great so let me run that server I

00:16:25,190 --> 00:16:30,290
type this command here and what this

00:16:27,680 --> 00:16:31,490
command does I could just as well also

00:16:30,290 --> 00:16:33,530
create the deployment in the UI

00:16:31,490 --> 00:16:35,030
kubernetes is API driven so I'm just

00:16:33,530 --> 00:16:37,910
showing you a command line way but

00:16:35,030 --> 00:16:41,270
there's other ways to do that and what

00:16:37,910 --> 00:16:44,810
i'm doing here is do kubernetes run this

00:16:41,270 --> 00:16:47,750
application from this image and I wanted

00:16:44,810 --> 00:16:50,210
explore some port 8080 and I want to

00:16:47,750 --> 00:16:52,970
replicas of it this is a very simple

00:16:50,210 --> 00:16:54,800
command and run beans deploy and start

00:16:52,970 --> 00:16:57,800
I could also first deploy and then start

00:16:54,800 --> 00:17:00,410
to like a rolling update for instance I

00:16:57,800 --> 00:17:02,270
can also do auto scaling there's like

00:17:00,410 --> 00:17:04,010
all of those kind of concepts are built

00:17:02,270 --> 00:17:05,510
into communities and then kubernetes

00:17:04,010 --> 00:17:08,030
figures out how that works on your

00:17:05,510 --> 00:17:12,280
platform but let's take the most simple

00:17:08,030 --> 00:17:14,780
example now so I just type that in and

00:17:12,280 --> 00:17:20,209
in parallel I go to workloads in the UI

00:17:14,780 --> 00:17:23,420
and see what's happening okay so awesome

00:17:20,209 --> 00:17:27,380
it has created and this this deployment

00:17:23,420 --> 00:17:29,570
and so let me quickly refresh the

00:17:27,380 --> 00:17:31,880
workloads here and perfect so here we

00:17:29,570 --> 00:17:33,140
have it and it's been deployed you see

00:17:31,880 --> 00:17:36,290
that other workloads on the cluster

00:17:33,140 --> 00:17:38,450
running happily on on other nodes and

00:17:36,290 --> 00:17:40,850
actually already this is already ready

00:17:38,450 --> 00:17:43,130
and normally when I do this presentation

00:17:40,850 --> 00:17:43,620
I show that it's pending but this time

00:17:43,130 --> 00:17:44,970
was a little

00:17:43,620 --> 00:17:47,790
too fast so this application actually

00:17:44,970 --> 00:17:49,320
running now cool unfortunately I can't

00:17:47,790 --> 00:17:52,740
access it yet because it's not like the

00:17:49,320 --> 00:17:57,750
internet doesn't have an IP so let's go

00:17:52,740 --> 00:17:59,850
back and expose this application and I

00:17:57,750 --> 00:18:02,970
want to expose it and if I expose to the

00:17:59,850 --> 00:18:05,940
Internet and I want it behind a load

00:18:02,970 --> 00:18:08,670
balancer and again it was this what this

00:18:05,940 --> 00:18:10,620
is doing here is it basically tells the

00:18:08,670 --> 00:18:13,080
Google cloud platform please create a

00:18:10,620 --> 00:18:14,850
lot bernessa get a public IP from your

00:18:13,080 --> 00:18:17,520
pool of public IP addresses a texture to

00:18:14,850 --> 00:18:20,670
the load balancer and call me back once

00:18:17,520 --> 00:18:23,700
you have that so let's refresh our

00:18:20,670 --> 00:18:25,920
deployment here and let's see that ok

00:18:23,700 --> 00:18:27,720
cool so we have a service created that's

00:18:25,920 --> 00:18:29,670
already good as services to kubernetes

00:18:27,720 --> 00:18:33,600
name of something that is exposed and

00:18:29,670 --> 00:18:40,170
and has a fixed API and now let's see if

00:18:33,600 --> 00:18:42,510
we already have an IP and we have

00:18:40,170 --> 00:18:45,990
external IP pending so I have a few more

00:18:42,510 --> 00:18:48,360
seconds to to talk about it so what is

00:18:45,990 --> 00:18:49,980
again what I like here is that you would

00:18:48,360 --> 00:18:51,929
type the exact same commands on your

00:18:49,980 --> 00:18:56,550
local machine right doesn't doesn't

00:18:51,929 --> 00:18:58,710
doesn't matter where you get your where

00:18:56,550 --> 00:19:00,300
you'll get your container from or how

00:18:58,710 --> 00:19:02,190
big your clusters all of that would be

00:19:00,300 --> 00:19:04,350
the same not only commands this would be

00:19:02,190 --> 00:19:06,030
the same API calls to cube CTL is just a

00:19:04,350 --> 00:19:07,290
very small red power on the REST API and

00:19:06,030 --> 00:19:09,240
you can just use that and build your own

00:19:07,290 --> 00:19:11,340
UI and there's lots of you eyes for that

00:19:09,240 --> 00:19:14,130
and what's really nice about the

00:19:11,340 --> 00:19:16,140
communities open source project is that

00:19:14,130 --> 00:19:17,550
right now and Google in Norway is the

00:19:16,140 --> 00:19:19,500
main contributor anymore right you see

00:19:17,550 --> 00:19:20,910
lots of other companies really super

00:19:19,500 --> 00:19:22,230
actively investor and building super

00:19:20,910 --> 00:19:25,230
interesting stuff it's a real big

00:19:22,230 --> 00:19:27,360
ecosystem and that's also why why it's

00:19:25,230 --> 00:19:29,670
so so nice to follow that in many areas

00:19:27,360 --> 00:19:31,110
and who doesn't even contributes because

00:19:29,670 --> 00:19:32,550
they say hey does Allah who do this a

00:19:31,110 --> 00:19:35,760
lot better and it's really nice to see

00:19:32,550 --> 00:19:37,830
how that how that develops ok so let's

00:19:35,760 --> 00:19:42,480
try that again perfect we do have an

00:19:37,830 --> 00:19:47,240
external IP so hoping that the network

00:19:42,480 --> 00:19:49,140
lets me through I'll just go to that

00:19:47,240 --> 00:19:54,620
open this

00:19:49,140 --> 00:19:59,010
and if we are lucky so I'm hitting a

00:19:54,620 --> 00:20:05,430
goal so over here it seems that the

00:19:59,010 --> 00:20:08,460
network is not letting me through yeah I

00:20:05,430 --> 00:20:13,190
think fire I'll show you so I can very

00:20:08,460 --> 00:20:13,190
quickly check out that on my phone

00:20:13,310 --> 00:20:19,890
message the point 88 is usually not open

00:20:17,850 --> 00:20:23,010
I could have exposed actually just a

00:20:19,890 --> 00:20:24,930
regular SSL as well thinking about it

00:20:23,010 --> 00:20:28,070
but those are the things that you

00:20:24,930 --> 00:20:28,070
usually discover nature

00:20:43,129 --> 00:20:47,249
perfect

00:20:44,340 --> 00:20:48,749
India so as I said it's a very simple HP

00:20:47,249 --> 00:20:51,719
server it's not doing much but it's

00:20:48,749 --> 00:20:54,119
saying hello for Asia and so that you

00:20:51,719 --> 00:20:57,269
trust me that this is actually this is

00:20:54,119 --> 00:20:59,609
actually deployed to communities I I'll

00:20:57,269 --> 00:21:00,869
put the hostname here and there should

00:20:59,609 --> 00:21:03,090
be one of the pots that I'm actually

00:21:00,869 --> 00:21:07,499
running on yeah so that's the second pot

00:21:03,090 --> 00:21:10,259
that I just hit so you see that's very

00:21:07,499 --> 00:21:12,149
very simple and that's that's basically

00:21:10,259 --> 00:21:14,789
all about communities and yeah you have

00:21:12,149 --> 00:21:16,769
lots of options in there so let's go

00:21:14,789 --> 00:21:22,739
back to our presentation and see how

00:21:16,769 --> 00:21:24,479
that can help us okay so we've seen this

00:21:22,739 --> 00:21:27,719
is all very easy it goes very very fast

00:21:24,479 --> 00:21:30,149
it's really nice now we have one problem

00:21:27,719 --> 00:21:31,739
and the smaller and more heterogeneous

00:21:30,149 --> 00:21:33,779
lis interconnected services you built

00:21:31,739 --> 00:21:35,820
the harder they actually become to

00:21:33,779 --> 00:21:37,320
discover and observe right there's

00:21:35,820 --> 00:21:38,460
something that happened to super

00:21:37,320 --> 00:21:39,659
interesting it happened in the micro

00:21:38,460 --> 00:21:41,460
service community in the beginning

00:21:39,659 --> 00:21:42,839
everyone was like yay let's build more

00:21:41,460 --> 00:21:45,330
services and suddenly everyone's like

00:21:42,839 --> 00:21:48,029
whoa whoa whoa we're what our service is

00:21:45,330 --> 00:21:49,649
doing so it came back a little bit to a

00:21:48,029 --> 00:21:52,979
classical architecture problem and as I

00:21:49,649 --> 00:21:55,619
used to be also more in like tech lead

00:21:52,979 --> 00:21:59,759
architecture kind of roads I find that a

00:21:55,619 --> 00:22:01,589
very interesting problem so let's start

00:21:59,759 --> 00:22:03,989
a little bit first and see what

00:22:01,589 --> 00:22:08,549
communities does so communities already

00:22:03,989 --> 00:22:10,200
has some of best practices baked in most

00:22:08,549 --> 00:22:12,179
of them for instance on Google's site

00:22:10,200 --> 00:22:14,399
reliability engineers stuff like rolling

00:22:12,179 --> 00:22:16,529
rollouts and auto scaling asan is

00:22:14,399 --> 00:22:18,989
already in there and as I said before

00:22:16,529 --> 00:22:20,339
there's already many many plugins so

00:22:18,989 --> 00:22:22,169
what we can do is we can build something

00:22:20,339 --> 00:22:23,909
on top of communities but on the same

00:22:22,169 --> 00:22:27,389
layer right so we're operating here an

00:22:23,909 --> 00:22:29,339
infrastructure layer so why do why don't

00:22:27,389 --> 00:22:31,349
we build something that takes more of

00:22:29,339 --> 00:22:36,450
those architectural concerns into

00:22:31,349 --> 00:22:38,339
communities and we can do that with so

00:22:36,450 --> 00:22:40,469
called service mesh and you see here I

00:22:38,339 --> 00:22:41,879
put the micro service mesh in in

00:22:40,469 --> 00:22:43,289
brackets because it's actually not so

00:22:41,879 --> 00:22:45,599
much what micro but it's about

00:22:43,289 --> 00:22:47,940
connecting all the all the services

00:22:45,599 --> 00:22:50,309
service meshes are not so new and

00:22:47,940 --> 00:22:52,919
there's a few around I've mentioned

00:22:50,309 --> 00:22:55,409
pivotal the Netflix stack already phones

00:22:52,919 --> 00:22:57,450
since it's a very mature one the

00:22:55,409 --> 00:22:59,400
difference to is to your to service

00:22:57,450 --> 00:23:01,650
measures and kubernetes is again they

00:22:59,400 --> 00:23:03,360
operate one layer lower so you can have

00:23:01,650 --> 00:23:04,620
polyglot applications you can have

00:23:03,360 --> 00:23:06,570
everything running like that everything

00:23:04,620 --> 00:23:09,299
from your from a database to your go

00:23:06,570 --> 00:23:10,710
application to your java application and

00:23:09,299 --> 00:23:12,299
none of them really has to know anything

00:23:10,710 --> 00:23:14,490
about the service mission that Boris

00:23:12,299 --> 00:23:16,470
makes them so interesting so what kind

00:23:14,490 --> 00:23:20,580
of service mesh to then it basically

00:23:16,470 --> 00:23:23,340
wraps your services into a sidecar into

00:23:20,580 --> 00:23:24,330
a proxy and that proxy can do all kinds

00:23:23,340 --> 00:23:27,480
of things everything from an

00:23:24,330 --> 00:23:29,220
instrumentation suddenly you gets very

00:23:27,480 --> 00:23:32,340
very detailed data about your service

00:23:29,220 --> 00:23:35,159
interactions that can do security it can

00:23:32,340 --> 00:23:37,350
do rollouts and it can for instance only

00:23:35,159 --> 00:23:38,970
show features to certain users all those

00:23:37,350 --> 00:23:40,530
kind of things that otherwise you would

00:23:38,970 --> 00:23:44,700
have to code in the application and that

00:23:40,530 --> 00:23:46,559
now and again becomes part of your part

00:23:44,700 --> 00:23:48,179
of your infrastructure and part of your

00:23:46,559 --> 00:23:49,530
coded infrastructure right so this is

00:23:48,179 --> 00:23:51,690
something that you can suddenly define

00:23:49,530 --> 00:23:53,159
now and have an aversion system and say

00:23:51,690 --> 00:23:55,890
this next release is going to be rolled

00:23:53,159 --> 00:23:58,049
out and in this rolling update way for

00:23:55,890 --> 00:24:00,630
those kind of users in your code and

00:23:58,049 --> 00:24:04,500
that's something you can just start and

00:24:00,630 --> 00:24:06,090
that's that's really really nice what

00:24:04,500 --> 00:24:10,110
service measures also allow is much

00:24:06,090 --> 00:24:13,470
deeper testability so Cindy Frieda Ron

00:24:10,110 --> 00:24:16,140
is the guru here and she calls that real

00:24:13,470 --> 00:24:17,460
integration testing and real because you

00:24:16,140 --> 00:24:19,650
can actually do integration testing in

00:24:17,460 --> 00:24:22,710
production so you can do fancy stuff

00:24:19,650 --> 00:24:23,940
like for instance take live traffic you

00:24:22,710 --> 00:24:25,289
don't want to interrupt your users but

00:24:23,940 --> 00:24:27,030
you can actually branch the traffic you

00:24:25,289 --> 00:24:29,039
can take the same traffic and direct

00:24:27,030 --> 00:24:30,840
that through integration tests and even

00:24:29,039 --> 00:24:32,070
do that in a in a secure way you don't

00:24:30,840 --> 00:24:34,740
need a stall at all you don't need to

00:24:32,070 --> 00:24:38,940
you need to access that data because it

00:24:34,740 --> 00:24:41,070
just exists you can also rerun events

00:24:38,940 --> 00:24:43,650
that happen in the past you can also do

00:24:41,070 --> 00:24:45,600
what she calls step up testing so

00:24:43,650 --> 00:24:47,549
instead of just running order in CI CD

00:24:45,600 --> 00:24:50,580
you can make that part of your CI CD

00:24:47,549 --> 00:24:52,440
chain so you don't just do a D a

00:24:50,580 --> 00:24:54,809
continuous deploy but you say do a

00:24:52,440 --> 00:24:57,270
continuous deploy to 1% to a cannery and

00:24:54,809 --> 00:24:59,610
then to 10% and and during those

00:24:57,270 --> 00:25:01,169
rollouts you actually measure the impact

00:24:59,610 --> 00:25:03,420
it has on your infrastructure not only

00:25:01,169 --> 00:25:06,450
on your load for instance if you

00:25:03,420 --> 00:25:08,850
CPUs go up or your RAM goes up and but

00:25:06,450 --> 00:25:10,800
also on the user and to the users

00:25:08,850 --> 00:25:13,200
experience higher latency and those kind

00:25:10,800 --> 00:25:17,400
of metrics actually become part of your

00:25:13,200 --> 00:25:18,870
CD process again because this it's all

00:25:17,400 --> 00:25:20,850
in code right and it's all in your

00:25:18,870 --> 00:25:25,950
infrastructure so there's no no magic

00:25:20,850 --> 00:25:28,680
there what this what it allows you to do

00:25:25,950 --> 00:25:31,050
and Julia Evans is writing a lot about

00:25:28,680 --> 00:25:35,910
that and it's it actually forces you to

00:25:31,050 --> 00:25:40,110
think about SL O's and SL O's here mean

00:25:35,910 --> 00:25:41,760
real SL O's in my past and I said always

00:25:40,110 --> 00:25:43,380
typically something like somewhere

00:25:41,760 --> 00:25:45,570
somewhere in an architecture documented

00:25:43,380 --> 00:25:47,760
would say by the way we need 99.9%

00:25:45,570 --> 00:25:49,560
uptime and that was there was more or

00:25:47,760 --> 00:25:51,480
less there so if you're lucky the

00:25:49,560 --> 00:25:55,440
customer would define something like and

00:25:51,480 --> 00:25:58,980
we can only have the 91st percentile of

00:25:55,440 --> 00:26:00,740
requests needs to need to be at the user

00:25:58,980 --> 00:26:04,070
in like one second something like this

00:26:00,740 --> 00:26:06,780
well now with this deep level of

00:26:04,070 --> 00:26:09,690
observability you can actually have way

00:26:06,780 --> 00:26:13,470
way deeper metrics you can say I want my

00:26:09,690 --> 00:26:15,330
power users to see the requests in the

00:26:13,470 --> 00:26:17,430
transaction screen faster than the

00:26:15,330 --> 00:26:19,740
requests in the report screen and you

00:26:17,430 --> 00:26:24,210
can actually measure that and again put

00:26:19,740 --> 00:26:25,560
that into your pipeline what that does

00:26:24,210 --> 00:26:28,320
and that's a nice effect

00:26:25,560 --> 00:26:30,060
Bridgette Chrome which wrote a pretty

00:26:28,320 --> 00:26:31,800
cool paper about that complex

00:26:30,060 --> 00:26:33,330
socio-technical systems are heart or

00:26:31,800 --> 00:26:37,290
containers will not fix your broken

00:26:33,330 --> 00:26:38,190
culture I love that title and that means

00:26:37,290 --> 00:26:41,430
it's just because you're using

00:26:38,190 --> 00:26:42,780
containers or kubernetes again that

00:26:41,430 --> 00:26:44,160
doesn't really solve your application

00:26:42,780 --> 00:26:45,390
problem what you want as you want to go

00:26:44,160 --> 00:26:47,070
in this direction and build an

00:26:45,390 --> 00:26:48,570
application that has defined metrics as

00:26:47,070 --> 00:26:50,040
has a defined infrastructure that

00:26:48,570 --> 00:26:51,960
actually solves a user problem and

00:26:50,040 --> 00:26:54,030
suddenly you can start arguing about

00:26:51,960 --> 00:26:55,230
that because you do have the metrics you

00:26:54,030 --> 00:26:56,580
have the numbers to go to your

00:26:55,230 --> 00:26:58,500
stakeholders to go to your business and

00:26:56,580 --> 00:26:59,790
say well I actually know what that costs

00:26:58,500 --> 00:27:01,770
yeah you want that feature that's cool

00:26:59,790 --> 00:27:04,260
but do you know that costs us 100 CPUs

00:27:01,770 --> 00:27:06,870
every month those kind of arguments

00:27:04,260 --> 00:27:09,810
become a lot more interesting that's for

00:27:06,870 --> 00:27:10,210
instance something we we also do and

00:27:09,810 --> 00:27:13,990
turn

00:27:10,210 --> 00:27:18,280
Google so that's that's really really

00:27:13,990 --> 00:27:20,440
nice so what are the benefits I found

00:27:18,280 --> 00:27:22,210
this really nice quote in a book by

00:27:20,440 --> 00:27:24,760
Molly right Stevenson from Ken Beck who

00:27:22,210 --> 00:27:27,400
won set patterns are rearrangements of

00:27:24,760 --> 00:27:29,170
power in the design process what that

00:27:27,400 --> 00:27:31,210
means is if you own the patterns if you

00:27:29,170 --> 00:27:34,360
define how we code if you define the

00:27:31,210 --> 00:27:36,610
building blocks of our application then

00:27:34,360 --> 00:27:37,930
you define the product and in the end

00:27:36,610 --> 00:27:39,640
that's all we want to do I'm not sure

00:27:37,930 --> 00:27:42,940
about you but I'm a software engineer

00:27:39,640 --> 00:27:44,290
and I I really like to be on the same

00:27:42,940 --> 00:27:46,180
level with my stakeholders and with my

00:27:44,290 --> 00:27:48,430
product manager for instance right I I

00:27:46,180 --> 00:27:50,140
really want to have a real argument

00:27:48,430 --> 00:27:51,580
about the about the business value and

00:27:50,140 --> 00:27:54,310
that's what those patterns that are

00:27:51,580 --> 00:27:56,310
baked into something like sto into the

00:27:54,310 --> 00:27:58,690
architecture abilities allow you to do

00:27:56,310 --> 00:28:01,360
you can start growing evolutionary

00:27:58,690 --> 00:28:02,980
that's the reason why I just removed the

00:28:01,360 --> 00:28:04,690
brackets from the word micro because

00:28:02,980 --> 00:28:06,040
that's something I never liked about the

00:28:04,690 --> 00:28:08,830
word micro service that is somehow

00:28:06,040 --> 00:28:10,330
prescribe the size I've seen very big

00:28:08,830 --> 00:28:12,190
services that were just a really really

00:28:10,330 --> 00:28:15,730
close business problem but super complex

00:28:12,190 --> 00:28:17,800
so let them be super complex and start

00:28:15,730 --> 00:28:19,570
refactoring them and splitting them over

00:28:17,800 --> 00:28:21,130
time you can do all of those kind of

00:28:19,570 --> 00:28:22,960
things because you can define now the

00:28:21,130 --> 00:28:25,330
API and you can define which services

00:28:22,960 --> 00:28:26,620
are behind those into those API your

00:28:25,330 --> 00:28:28,180
consumer might not even realize that

00:28:26,620 --> 00:28:29,950
suddenly they are served by three or

00:28:28,180 --> 00:28:32,230
four micro services now because it's

00:28:29,950 --> 00:28:35,530
still going through the same through the

00:28:32,230 --> 00:28:37,270
same API you can start playing the

00:28:35,530 --> 00:28:39,850
semantics whether you want to use events

00:28:37,270 --> 00:28:41,740
or calls right right now you always have

00:28:39,850 --> 00:28:43,960
to choose if you either have RPC models

00:28:41,740 --> 00:28:45,760
like you're calling something or whether

00:28:43,960 --> 00:28:47,020
you want to send an event to a bus well

00:28:45,760 --> 00:28:49,450
maybe you can try those and see what

00:28:47,020 --> 00:28:51,610
what works better or you can integrate

00:28:49,450 --> 00:28:56,290
Service Catalog service brokers external

00:28:51,610 --> 00:28:58,990
integrations if you do that you can also

00:28:56,290 --> 00:29:00,130
bridge the boundary and two functions so

00:28:58,990 --> 00:29:02,650
you might have realized that I haven't

00:29:00,130 --> 00:29:04,690
mentioned functions yet in this talk why

00:29:02,650 --> 00:29:06,010
is it the case in case you haven't

00:29:04,690 --> 00:29:10,420
thought about functions or sometimes

00:29:06,010 --> 00:29:11,680
called 7s and functions are a like

00:29:10,420 --> 00:29:13,480
almost like a pass or almost like a

00:29:11,680 --> 00:29:14,800
higher level than a than a pass it's

00:29:13,480 --> 00:29:17,890
something you call and you don't care

00:29:14,800 --> 00:29:21,240
about the deployment at all that's great

00:29:17,890 --> 00:29:24,780
for instance for IOT use cases

00:29:21,240 --> 00:29:26,160
functions are really nice but in larger

00:29:24,780 --> 00:29:27,630
product developments you would typically

00:29:26,160 --> 00:29:29,250
see that you need some kind of control

00:29:27,630 --> 00:29:30,930
over your architecture but you still

00:29:29,250 --> 00:29:32,340
want the advantage of functions well now

00:29:30,930 --> 00:29:35,100
you can combine that there is actually

00:29:32,340 --> 00:29:37,830
function frameworks based on top of

00:29:35,100 --> 00:29:39,300
kubernetes and on top of it co that can

00:29:37,830 --> 00:29:40,920
give you that flexibility but you can

00:29:39,300 --> 00:29:42,690
combine it now in one architecture we

00:29:40,920 --> 00:29:44,370
actually know which part is doing what

00:29:42,690 --> 00:29:46,770
you only need two separate worlds and

00:29:44,370 --> 00:29:48,300
change the team and suddenly have a red

00:29:46,770 --> 00:29:50,430
flag or a blue flag on your on your

00:29:48,300 --> 00:29:54,990
table and whether you're for functions

00:29:50,430 --> 00:29:57,030
or against functions right now not all

00:29:54,990 --> 00:29:58,650
service measures supported in a really

00:29:57,030 --> 00:30:00,690
nice way and but there is a super

00:29:58,650 --> 00:30:01,740
interesting work to be done you might

00:30:00,690 --> 00:30:03,120
have realized I'm using a lot of

00:30:01,740 --> 00:30:04,890
references in this application that's

00:30:03,120 --> 00:30:06,210
really because so much is happening that

00:30:04,890 --> 00:30:09,810
sometimes it's just better to follow the

00:30:06,210 --> 00:30:11,850
people on Twitter or in blocks but

00:30:09,810 --> 00:30:15,890
there's definitely some interesting

00:30:11,850 --> 00:30:17,790
things happening cublas DCOs riff

00:30:15,890 --> 00:30:19,980
projects which are playing with this

00:30:17,790 --> 00:30:22,200
breaking up those kind of like semantics

00:30:19,980 --> 00:30:24,990
and yeah if you won't have a look at

00:30:22,200 --> 00:30:26,250
that dude as I just said in the slide

00:30:24,990 --> 00:30:30,660
before you can also start merely

00:30:26,250 --> 00:30:34,320
observing behavior and jvd for instance

00:30:30,660 --> 00:30:35,940
she mentions a lot about that in in a

00:30:34,320 --> 00:30:38,640
blog post about observability and

00:30:35,940 --> 00:30:39,930
because you can really start looking at

00:30:38,640 --> 00:30:41,340
service on a trace level

00:30:39,930 --> 00:30:44,610
I remember when like maybe five years

00:30:41,340 --> 00:30:47,370
ago we started including trace IDs and

00:30:44,610 --> 00:30:49,650
our requests and it was such a simple

00:30:47,370 --> 00:30:51,480
heck but suddenly you had such an

00:30:49,650 --> 00:30:54,540
insight into your system how your users

00:30:51,480 --> 00:30:57,450
are actually using it this was something

00:30:54,540 --> 00:30:59,880
we never had before and that's something

00:30:57,450 --> 00:31:03,150
that really drives product decisions and

00:30:59,880 --> 00:31:04,950
drives and reasoning about products and

00:31:03,150 --> 00:31:09,030
a lot better than reasoning about some

00:31:04,950 --> 00:31:10,890
extracts as a base right and if you have

00:31:09,030 --> 00:31:12,240
all of that last but not least and

00:31:10,890 --> 00:31:14,010
that's where I come back to my

00:31:12,240 --> 00:31:16,260
experience also in troubleshooting and

00:31:14,010 --> 00:31:17,490
you also can now reconcile your

00:31:16,260 --> 00:31:19,250
application metrics with your

00:31:17,490 --> 00:31:22,650
infrastructure metrics like loads and

00:31:19,250 --> 00:31:24,030
CPU and and memory yeah because in the

00:31:22,650 --> 00:31:26,700
end someone is responsible for that

00:31:24,030 --> 00:31:28,860
right there will always be some form of

00:31:26,700 --> 00:31:31,500
more obstacles people but they can now

00:31:28,860 --> 00:31:33,390
go to the application say hey excuse me

00:31:31,500 --> 00:31:34,730
you're using a lot of ramp you're using

00:31:33,390 --> 00:31:36,679
up a lot of CPU and I know

00:31:34,730 --> 00:31:38,270
exactly you and I can even show you the

00:31:36,679 --> 00:31:39,650
piece in your code where that happens

00:31:38,270 --> 00:31:41,929
and by the way I know how to make it

00:31:39,650 --> 00:31:43,910
better and that's that's ideally what

00:31:41,929 --> 00:31:45,350
you what you actually want and I can

00:31:43,910 --> 00:31:50,780
already say again this actually happens

00:31:45,350 --> 00:31:52,070
a lot internally if you want to know

00:31:50,780 --> 00:31:54,049
more about that there's some really

00:31:52,070 --> 00:31:56,390
really cool talks by Liz Lange Jones I

00:31:54,049 --> 00:31:58,570
can only I can only recommend you to

00:31:56,390 --> 00:32:01,160
listening whatever she said in her life

00:31:58,570 --> 00:32:04,040
because there's really cool insights

00:32:01,160 --> 00:32:07,250
also how ish how she shows internal

00:32:04,040 --> 00:32:09,020
tools in Google to do those kind of like

00:32:07,250 --> 00:32:10,760
drill downs and find misbehaving codes

00:32:09,020 --> 00:32:13,400
that maybe only misbehaves in a certain

00:32:10,760 --> 00:32:15,799
condition in a certain data center and

00:32:13,400 --> 00:32:21,500
there a certain type of load and that's

00:32:15,799 --> 00:32:24,169
Venus good that's actually my my main

00:32:21,500 --> 00:32:26,210
slide so let's wrap up here a little bit

00:32:24,169 --> 00:32:29,299
so what can we what can we do beyond

00:32:26,210 --> 00:32:30,620
that if we have other information we can

00:32:29,299 --> 00:32:32,660
start reasoning on an architectural

00:32:30,620 --> 00:32:35,059
level this is for instance a service

00:32:32,660 --> 00:32:36,799
graph that is produced inside sto and

00:32:35,059 --> 00:32:38,990
which is a service mesh based on

00:32:36,799 --> 00:32:41,330
kubernetes that's really interesting

00:32:38,990 --> 00:32:42,740
that generates you the relationships of

00:32:41,330 --> 00:32:44,299
your services based on the traffic

00:32:42,740 --> 00:32:47,210
between them so not what you define

00:32:44,299 --> 00:32:49,040
somewhere or what someone says and this

00:32:47,210 --> 00:32:51,710
process is sometimes called process

00:32:49,040 --> 00:32:53,780
mining and that actually shows you how

00:32:51,710 --> 00:32:55,010
your system is used and that can be

00:32:53,780 --> 00:32:57,230
pretty surprising all of us know that

00:32:55,010 --> 00:32:58,370
you wonder like wow so many people are

00:32:57,230 --> 00:32:59,630
using the app what are they doing with

00:32:58,370 --> 00:33:01,400
it and then you actually look at the

00:32:59,630 --> 00:33:02,990
locks and they're using it for something

00:33:01,400 --> 00:33:05,179
completely different from what you have

00:33:02,990 --> 00:33:06,799
thought and those systems can not just

00:33:05,179 --> 00:33:08,240
give that to you for free and you even

00:33:06,799 --> 00:33:10,160
see that life you can even break that

00:33:08,240 --> 00:33:12,160
down by users and say what type of users

00:33:10,160 --> 00:33:16,040
are using which kind of interactions and

00:33:12,160 --> 00:33:18,169
with that your apps role or your we call

00:33:16,040 --> 00:33:20,390
it the answer is they become way more

00:33:18,169 --> 00:33:22,280
architects and ops and better really

00:33:20,390 --> 00:33:24,530
like I used to be an architect and I had

00:33:22,280 --> 00:33:27,830
the problem that I always felt like I

00:33:24,530 --> 00:33:29,960
have no grip on the court because in in

00:33:27,830 --> 00:33:32,720
all the companies the architect is a guy

00:33:29,960 --> 00:33:35,480
on the PowerPoint and then a girl on the

00:33:32,720 --> 00:33:38,600
PowerPoint and then yeah you

00:33:35,480 --> 00:33:40,160
unfortunately want to somehow you have

00:33:38,600 --> 00:33:41,270
to ask the coders and they just say oh I

00:33:40,160 --> 00:33:43,190
don't want to use that library and I

00:33:41,270 --> 00:33:47,809
don't want to do those connections sorry

00:33:43,190 --> 00:33:48,480
yeah sorry em and now you actually have

00:33:47,809 --> 00:33:49,440
that handle

00:33:48,480 --> 00:33:50,700
now you're coming from this ops

00:33:49,440 --> 00:33:53,220
perspective from the architecture

00:33:50,700 --> 00:33:54,990
perspective and suddenly you can

00:33:53,220 --> 00:33:56,730
actually argue with the developers and

00:33:54,990 --> 00:33:57,990
really change it and really say this is

00:33:56,730 --> 00:33:59,520
how you want to change and this goes a

00:33:57,990 --> 00:34:02,280
little bit back to what Philippa showed

00:33:59,520 --> 00:34:04,049
before in github if you have access to

00:34:02,280 --> 00:34:05,760
all of that code you can actually change

00:34:04,049 --> 00:34:08,940
it so I'm going a little bit faster now

00:34:05,760 --> 00:34:12,389
and here you see some some more

00:34:08,940 --> 00:34:14,100
references charity majors is the it's

00:34:12,389 --> 00:34:15,780
the one you want to look up for this

00:34:14,100 --> 00:34:18,300
kind of like observing events and

00:34:15,780 --> 00:34:19,859
mapping them to domain logic she has

00:34:18,300 --> 00:34:21,270
some awesome talks in there as well and

00:34:19,859 --> 00:34:24,450
just one last statement because you

00:34:21,270 --> 00:34:25,830
mentioned in the beginning AI becomes of

00:34:24,450 --> 00:34:28,379
course in a geo collaborator now you

00:34:25,830 --> 00:34:30,419
have all of this data now obviously you

00:34:28,379 --> 00:34:32,669
can just route that into a statistical

00:34:30,419 --> 00:34:35,429
model there's always the example that

00:34:32,669 --> 00:34:37,889
Google save 40% of its energy and that's

00:34:35,429 --> 00:34:41,250
a lot of energy and by having all the

00:34:37,889 --> 00:34:42,690
data center usage data fed into machine

00:34:41,250 --> 00:34:44,210
learning model that came back and

00:34:42,690 --> 00:34:46,740
suggested how to change the power

00:34:44,210 --> 00:34:48,840
configurations right so why not do that

00:34:46,740 --> 00:34:50,190
to your software why not see okay which

00:34:48,840 --> 00:34:52,260
services according each other and

00:34:50,190 --> 00:34:54,300
actually isn't the iStent maybe users

00:34:52,260 --> 00:34:55,919
which always end up in this note why not

00:34:54,300 --> 00:34:57,869
expose that directly to the user instead

00:34:55,919 --> 00:35:01,770
of going why are five steps that's just

00:34:57,869 --> 00:35:05,040
let's just churn so that's really really

00:35:01,770 --> 00:35:06,840
interesting so to summarize and what you

00:35:05,040 --> 00:35:08,820
want to do is you want to do two main

00:35:06,840 --> 00:35:11,280
driven polyglots and multiple languages

00:35:08,820 --> 00:35:13,380
evolutionary mix semantics development

00:35:11,280 --> 00:35:15,359
with also senders that's proven to be

00:35:13,380 --> 00:35:16,710
the most productive way that developers

00:35:15,359 --> 00:35:18,900
work and by the way also the happiest

00:35:16,710 --> 00:35:20,010
way I find it great when I build

00:35:18,900 --> 00:35:22,070
something that actually has a product

00:35:20,010 --> 00:35:24,800
impact and I see how you just like it

00:35:22,070 --> 00:35:27,150
you can't suddenly have a real quality

00:35:24,800 --> 00:35:28,440
telemetry room on your system

00:35:27,150 --> 00:35:30,330
Michael feathers is doing a lot of that

00:35:28,440 --> 00:35:32,490
work for instance and they have some

00:35:30,330 --> 00:35:34,290
awesome analysis on tech depth and so

00:35:32,490 --> 00:35:35,460
they can basically say which code is so

00:35:34,290 --> 00:35:38,340
old that it makes a whole application

00:35:35,460 --> 00:35:40,530
slow and awesome talks really really

00:35:38,340 --> 00:35:42,510
funny how they drill down into and who

00:35:40,530 --> 00:35:45,359
caused the tech tap and how that's fixed

00:35:42,510 --> 00:35:46,890
in in service meshes you can focus on

00:35:45,359 --> 00:35:48,390
risk and user experience rather than

00:35:46,890 --> 00:35:50,760
infrastructure approach these boundaries

00:35:48,390 --> 00:35:53,340
you don't have to just say I need 99.5%

00:35:50,760 --> 00:35:55,050
availability you can actually say like

00:35:53,340 --> 00:35:57,510
and then you know eventually consistent

00:35:55,050 --> 00:35:59,400
database you can just say oh well in

00:35:57,510 --> 00:36:00,840
this screen that's how I want the

00:35:59,400 --> 00:36:01,859
application to behave and maybe in this

00:36:00,840 --> 00:36:03,539
one it's

00:36:01,859 --> 00:36:06,869
should rather behave consistently and

00:36:03,539 --> 00:36:08,969
fast and in the other one not and us

00:36:06,869 --> 00:36:10,890
developers you can cool stuff like

00:36:08,969 --> 00:36:12,420
automated refactorings because of

00:36:10,890 --> 00:36:14,099
everything if your whole application is

00:36:12,420 --> 00:36:15,390
there what everyone can fork it and it

00:36:14,099 --> 00:36:16,680
can happen that the other team comes to

00:36:15,390 --> 00:36:18,329
say hey you didn't do a good job I take

00:36:16,680 --> 00:36:19,619
your whole application including the

00:36:18,329 --> 00:36:21,479
infrastructure including database

00:36:19,619 --> 00:36:23,219
everything and just deploy it on my own

00:36:21,479 --> 00:36:25,049
and then I fix the code for you then I

00:36:23,219 --> 00:36:26,450
show you it is bad and that's actually

00:36:25,049 --> 00:36:28,589
something that's really cool and fun and

00:36:26,450 --> 00:36:32,249
yeah it's in the end the true spirit

00:36:28,589 --> 00:36:39,599
open source and does that thank you very

00:36:32,249 --> 00:36:42,059
much sorry I don't think we have time

00:36:39,599 --> 00:36:44,339
for questions sorry I was looking at the

00:36:42,059 --> 00:36:51,380
little sorry but there's actually five

00:36:44,339 --> 00:36:51,380

YouTube URL: https://www.youtube.com/watch?v=zZ2JeeODN08


