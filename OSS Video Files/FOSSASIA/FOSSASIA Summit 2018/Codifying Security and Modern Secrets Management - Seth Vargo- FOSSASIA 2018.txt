Title: Codifying Security and Modern Secrets Management - Seth Vargo- FOSSASIA 2018
Publication date: 2018-03-24
Playlist: FOSSASIA Summit 2018
Description: 
	Speaker: Seth Vargo, Developer Advocate Google
Info: https://2018.fossasia.org/event/speakers.html#seth-vargo3199

As the security landscape changes, especially in a cloud-based world, the biggest security threats shift away from physical machine access or VPN compromise toward emerging threats like improper software practices, social engineering attacks, or vulnerabilities in underlying libraries. This emerging threat model forces us to re-think traditional security practices in more modern and innovative approaches to intrusion detection and response.

This talk discusses the principles of modern security and how a free and open source tool - HashiCorp Vault - embodies and enforces the principles of modern security.

Track: Cybersecurity
Room: Training room 4-1
Date: Saturday, 24th March, 2018

Event Page: http://2018.fossasia.org
Follow FOSSASIA on Twitter: https://twitter.com/fossasia/
Like FOSSASIA on Facebook: https://www.facebook.com/fossasia/ 

Produced by Engineers.SG
Captions: 
	00:00:01,460 --> 00:00:08,849
all right am I good to start all right

00:00:04,920 --> 00:00:13,139
hi everyone so it's such an enthusiastic

00:00:08,849 --> 00:00:16,949
crowd how's everyone doing I like you

00:00:13,139 --> 00:00:18,840
you're participating so today I'm here

00:00:16,949 --> 00:00:20,430
to talk to you about kind of modern

00:00:18,840 --> 00:00:22,859
security practices and codifying

00:00:20,430 --> 00:00:25,170
security so my name is Seth I'm a

00:00:22,859 --> 00:00:26,880
developer advocate at Google cloud you

00:00:25,170 --> 00:00:28,529
might recognize me from the Hashi crop

00:00:26,880 --> 00:00:32,610
community or the chef community where I

00:00:28,529 --> 00:00:33,690
worked previously and to start today

00:00:32,610 --> 00:00:35,190
there's like some slides in the

00:00:33,690 --> 00:00:38,370
beginning and then most of it's like

00:00:35,190 --> 00:00:39,890
live demo so that's exciting but first I

00:00:38,370 --> 00:00:42,390
want to talk about traditional security

00:00:39,890 --> 00:00:42,899
so this is how I describe traditional

00:00:42,390 --> 00:00:46,500
security

00:00:42,899 --> 00:00:49,469
it's a padlock around a keyboard and and

00:00:46,500 --> 00:00:51,449
let's think about this in terms of like

00:00:49,469 --> 00:00:54,510
an application architecture so if we

00:00:51,449 --> 00:00:56,550
look back maybe 10 or 15 years ago our

00:00:54,510 --> 00:00:58,680
applications tend to tended to be

00:00:56,550 --> 00:01:01,440
structured something like this you had

00:00:58,680 --> 00:01:03,359
some load balancer that would do the

00:01:01,440 --> 00:01:04,830
networking dress that would hit some

00:01:03,359 --> 00:01:07,680
firewall those might have been the same

00:01:04,830 --> 00:01:13,049
thing and then you would hit your secure

00:01:07,680 --> 00:01:15,090
domain did the application was likely

00:01:13,049 --> 00:01:16,860
monolithic so you didn't have micro

00:01:15,090 --> 00:01:19,259
services all communication happened with

00:01:16,860 --> 00:01:20,670
inside the application and your your

00:01:19,259 --> 00:01:22,049
database in your application lived on

00:01:20,670 --> 00:01:23,610
the same network they might have been

00:01:22,049 --> 00:01:25,229
connected by the same physical like

00:01:23,610 --> 00:01:28,530
serial cable connecting these two

00:01:25,229 --> 00:01:30,360
machines the load balancer and the

00:01:28,530 --> 00:01:33,810
firewall were likely Hardware appliances

00:01:30,360 --> 00:01:35,460
like an f5 and all of this was

00:01:33,810 --> 00:01:38,159
controlled by like one or two people who

00:01:35,460 --> 00:01:40,020
had a lot of skills in the industry so

00:01:38,159 --> 00:01:42,299
the important part to note here is that

00:01:40,020 --> 00:01:46,350
once we're inside the secure zone

00:01:42,299 --> 00:01:48,299
everything was trusted when we moved to

00:01:46,350 --> 00:01:50,579
like a modern architecture of an

00:01:48,299 --> 00:01:52,380
application applications have gotten

00:01:50,579 --> 00:01:54,119
increasingly more complex this is due to

00:01:52,380 --> 00:01:56,430
new programming languages new

00:01:54,119 --> 00:01:58,549
requirements proliferations of things

00:01:56,430 --> 00:02:01,799
like microservices so we can break apart

00:01:58,549 --> 00:02:02,880
different things so that different teams

00:02:01,799 --> 00:02:05,009
can work on different things in

00:02:02,880 --> 00:02:07,920
accelerate application delivery but that

00:02:05,009 --> 00:02:09,989
introduced some complexity so now we

00:02:07,920 --> 00:02:11,370
have cloud adoption where we have some

00:02:09,989 --> 00:02:13,530
things running on a public cloud

00:02:11,370 --> 00:02:15,480
something is running on a private cloud

00:02:13,530 --> 00:02:16,890
something's running in both at the same

00:02:15,480 --> 00:02:19,170
time and they need to talk to each other

00:02:16,890 --> 00:02:21,150
so our modern architectures tend to look

00:02:19,170 --> 00:02:22,590
something like this we still have a load

00:02:21,150 --> 00:02:24,240
balancer but that load balancer is

00:02:22,590 --> 00:02:26,280
likely a software-defined load balancer

00:02:24,240 --> 00:02:28,050
so not only are we eating some

00:02:26,280 --> 00:02:29,400
performance but we're now subject to any

00:02:28,050 --> 00:02:31,230
vulnerabilities that exist in that

00:02:29,400 --> 00:02:33,000
language so if that load balancer is

00:02:31,230 --> 00:02:36,390
written in C and there's a memory leak

00:02:33,000 --> 00:02:38,160
like oops as opposed to something like

00:02:36,390 --> 00:02:40,530
an FPGA which is a hardware based load

00:02:38,160 --> 00:02:44,660
balancer we no longer have a firewall

00:02:40,530 --> 00:02:44,660
instead we have firewall rules again

00:10:35,779 --> 00:10:39,120
this is that's like TLS right we're

00:10:38,040 --> 00:10:40,350
decrypting the connection we're

00:10:39,120 --> 00:10:42,569
encrypting the data over that connection

00:10:40,350 --> 00:10:45,720
but we need to encrypt our data at rest

00:10:42,569 --> 00:10:46,889
as well so in transit and at rest on

00:10:45,720 --> 00:10:49,139
this at the same time we need to

00:10:46,889 --> 00:10:51,749
understand the trade-offs of encrypting

00:10:49,139 --> 00:10:53,189
that data there are certain data that

00:10:51,749 --> 00:10:54,629
should be encrypted and there's certain

00:10:53,189 --> 00:10:56,370
data that can live in plain text

00:10:54,629 --> 00:10:58,620
if you imagine we have a database of

00:10:56,370 --> 00:10:59,759
things like email addresses you might

00:10:58,620 --> 00:11:00,990
think oh I'm going to encrypt those

00:10:59,759 --> 00:11:03,300
email addresses because if I get

00:11:00,990 --> 00:11:04,589
attacked you know I'm going to be on the

00:11:03,300 --> 00:11:07,410
front page of hacker news I'm going to

00:11:04,589 --> 00:11:09,149
be on my humps have I been phone and

00:11:07,410 --> 00:11:11,339
that's a very valid way of thinking and

00:11:09,149 --> 00:11:13,019
this is where there is no one answer if

00:11:11,339 --> 00:11:15,870
I'm a company like MailChimp where my

00:11:13,019 --> 00:11:17,699
core business is sending email email

00:11:15,870 --> 00:11:19,170
addresses are very important if I get

00:11:17,699 --> 00:11:20,699
hacked and I see that there's been a

00:11:19,170 --> 00:11:23,370
data leak that's basically the end of my

00:11:20,699 --> 00:11:27,569
business on the flip side if my primary

00:11:23,370 --> 00:11:29,939
business is cat meetings and I run the

00:11:27,569 --> 00:11:31,139
top site for cat memes and I collect

00:11:29,939 --> 00:11:33,629
email addresses so I can send out a

00:11:31,139 --> 00:11:35,069
newsletter if I'm attacked it's bad I

00:11:33,629 --> 00:11:36,449
shouldn't have done that I should have

00:11:35,069 --> 00:11:38,879
followed better security practices but

00:11:36,449 --> 00:11:40,500
it's not the end of my business and at

00:11:38,879 --> 00:11:42,269
the same time if I encrypt all of my

00:11:40,500 --> 00:11:44,670
email addresses in my database I lose

00:11:42,269 --> 00:11:46,829
the ability to do analytics I can't

00:11:44,670 --> 00:11:48,959
search for all email addresses that end

00:11:46,829 --> 00:11:50,759
in say at gmail.com anymore because

00:11:48,959 --> 00:11:53,040
they're all encrypted so I have to make

00:11:50,759 --> 00:11:54,209
a business decision should I encrypt

00:11:53,040 --> 00:11:56,939
this data should I not encrypt the data

00:11:54,209 --> 00:11:59,910
so encryption everywhere isn't the

00:11:56,939 --> 00:12:01,649
answer instead having a cognitive

00:11:59,910 --> 00:12:03,600
conversation about whether we should

00:12:01,649 --> 00:12:05,129
encrypt data everywhere is the answer

00:12:03,600 --> 00:12:06,990
and making a business decision and

00:12:05,129 --> 00:12:08,670
analyzing that risk of whether we

00:12:06,990 --> 00:12:09,870
shouldn't encrypt shooting crimped or

00:12:08,670 --> 00:12:11,660
not encrypted what the business

00:12:09,870 --> 00:12:15,000
trade-offs are for that

00:12:11,660 --> 00:12:19,050
the second pillar are these dynamic

00:12:15,000 --> 00:12:22,050
time-based revocable credentials so in a

00:12:19,050 --> 00:12:24,060
traditional application development you

00:12:22,050 --> 00:12:26,340
might have an app that has to talk to a

00:12:24,060 --> 00:12:30,060
database and the way you generally get

00:12:26,340 --> 00:12:32,160
the credential is you email your tv18

00:12:30,060 --> 00:12:34,470
when you file a ticket they manually

00:12:32,160 --> 00:12:36,060
provision an account for you they give

00:12:34,470 --> 00:12:38,130
it back to you you put it in the config

00:12:36,060 --> 00:12:40,050
file for the application and all of your

00:12:38,130 --> 00:12:43,440
applications share that same credential

00:12:40,050 --> 00:12:45,690
seemingly for the end of time if you're

00:12:43,440 --> 00:12:47,640
in a large enterprise you might rotate

00:12:45,690 --> 00:12:49,440
them every six months if you're a

00:12:47,640 --> 00:12:52,350
startup you keep them there until you

00:12:49,440 --> 00:12:54,960
get acquired this is a challenge the

00:12:52,350 --> 00:12:57,420
longer credential lives the more likely

00:12:54,960 --> 00:13:00,240
it will be hacked so instead of trying

00:12:57,420 --> 00:13:01,380
to do this whole no one's ever going to

00:13:00,240 --> 00:13:03,870
infiltrate our systems we're going to

00:13:01,380 --> 00:13:05,490
have the best security perimeters we can

00:13:03,870 --> 00:13:06,810
instead invert the conversation and

00:13:05,490 --> 00:13:08,910
saying you know what if someone makes it

00:13:06,810 --> 00:13:11,340
into our systems that sucks we should do

00:13:08,910 --> 00:13:13,980
better but our credentials only live for

00:13:11,340 --> 00:13:16,140
an hour so at most an attacker would

00:13:13,980 --> 00:13:17,730
have to penetrate these three levels but

00:13:16,140 --> 00:13:19,380
then hit in a credential and use it

00:13:17,730 --> 00:13:21,600
within an hour and we can revoke it

00:13:19,380 --> 00:13:25,080
early and this is why time-based

00:13:21,600 --> 00:13:26,430
credentials are very important I'll say

00:13:25,080 --> 00:13:28,500
this I said this on the encryption side

00:13:26,430 --> 00:13:31,230
and I'll say it here again unified api's

00:13:28,500 --> 00:13:34,180
and codified best practices this is

00:13:31,230 --> 00:13:35,440
arguably the most important concept and

00:13:34,180 --> 00:13:38,320
what I'm going to show you in a bit with

00:13:35,440 --> 00:13:40,839
fault which is an open source toll is we

00:13:38,320 --> 00:13:42,730
need a central source for secrets many

00:13:40,839 --> 00:13:44,950
organizations out there are writing code

00:13:42,730 --> 00:13:46,570
in five different programming languages

00:13:44,950 --> 00:13:48,700
with hundreds of Engineers all with

00:13:46,570 --> 00:13:50,649
different levels of expertise we can't

00:13:48,700 --> 00:13:52,270
expect ever groovy developer every Java

00:13:50,649 --> 00:13:55,660
developer every NGO developer every seed

00:13:52,270 --> 00:13:57,459
developer to reinvent encryption instead

00:13:55,660 --> 00:13:59,290
we should treat encryption the same way

00:13:57,459 --> 00:14:01,240
we treat things like databases they're

00:13:59,290 --> 00:14:02,890
just a service that is offered so just

00:14:01,240 --> 00:14:05,350
like a database as a service that is

00:14:02,890 --> 00:14:07,300
offered to store data and retrieve data

00:14:05,350 --> 00:14:08,830
and search data we should we should

00:14:07,300 --> 00:14:11,410
think of security is the same way there

00:14:08,830 --> 00:14:13,899
needs to be a service that does security

00:14:11,410 --> 00:14:15,820
for us so things like encryption as a

00:14:13,899 --> 00:14:17,470
service password generation enter B

00:14:15,820 --> 00:14:19,630
generation right I shouldn't have to

00:14:17,470 --> 00:14:21,130
write that in my own language it would

00:14:19,630 --> 00:14:24,430
be great if I could just make an API

00:14:21,130 --> 00:14:27,250
call over saying you know SSL with a

00:14:24,430 --> 00:14:29,860
JSON payload and say hey give me 150

00:14:27,250 --> 00:14:31,089
bits of random entropy and I don't want

00:14:29,860 --> 00:14:33,010
to have to write that in five languages

00:14:31,089 --> 00:14:34,870
I would love to just make anything I

00:14:33,010 --> 00:14:37,029
call and that's kind of the direction

00:14:34,870 --> 00:14:39,459
that I think security should be going is

00:14:37,029 --> 00:14:41,140
security as a service if I want to

00:14:39,459 --> 00:14:42,940
encrypt something I don't want to have

00:14:41,140 --> 00:14:44,170
to pick a cipher suite I don't want to

00:14:42,940 --> 00:14:46,300
have to know if it should be symmetric

00:14:44,170 --> 00:14:48,670
or asymmetric encryption I just want to

00:14:46,300 --> 00:14:50,380
I have this blob of text and I want

00:14:48,670 --> 00:14:51,730
someone else to encrypt it for me with

00:14:50,380 --> 00:14:53,440
the latest and greatest standards and

00:14:51,730 --> 00:14:54,610
give me back the encrypted text and I

00:14:53,440 --> 00:14:56,560
don't want to have to think about it I

00:14:54,610 --> 00:14:57,850
want to I don't want to have to know you

00:14:56,560 --> 00:14:59,800
know all the vulnerabilities that exist

00:14:57,850 --> 00:15:02,020
and again this is the direction that I

00:14:59,800 --> 00:15:03,910
think the security industry is going and

00:15:02,020 --> 00:15:06,220
to do that we need a consistent

00:15:03,910 --> 00:15:07,450
experience so it doesn't matter what

00:15:06,220 --> 00:15:09,250
language you're writing in it doesn't

00:15:07,450 --> 00:15:11,470
matter if you're a human or a computer

00:15:09,250 --> 00:15:13,270
or a service it doesn't matter if you're

00:15:11,470 --> 00:15:13,710
an enterprise or a start-up it doesn't

00:15:13,270 --> 00:15:16,560
matter

00:15:13,710 --> 00:15:17,130
running on kubernetes or mesas or

00:15:16,560 --> 00:15:19,200
bare-metal

00:15:17,130 --> 00:15:22,980
we need a consistent experience and

00:15:19,200 --> 00:15:24,990
that's really what vault tries to be so

00:15:22,980 --> 00:15:27,780
fall is an open-source tool or an in go

00:15:24,990 --> 00:15:30,840
it runs as a service and it's designed

00:15:27,780 --> 00:15:32,610
to be the central repository and central

00:15:30,840 --> 00:15:35,250
egress and ingress for all credentials

00:15:32,610 --> 00:15:38,100
within a system so I'm gonna demo it

00:15:35,250 --> 00:15:39,930
while continuing to talk about it I have

00:15:38,100 --> 00:15:43,140
this live demo side so I couldn't get my

00:15:39,930 --> 00:15:44,340
way out of it so let me just show you

00:15:43,140 --> 00:15:47,880
kind of how this works

00:15:44,340 --> 00:15:49,910
so vall operates in a client-server

00:15:47,880 --> 00:15:49,910
architecture

00:15:56,200 --> 00:15:59,190
do I go

00:16:02,290 --> 00:16:07,379
okay everyone see this

00:16:05,100 --> 00:16:09,080
you're also cloud

00:16:07,379 --> 00:16:12,709
there we go

00:16:09,080 --> 00:16:15,350
all right so all it operates in a

00:16:12,709 --> 00:16:17,570
client-server architecture what I have

00:16:15,350 --> 00:16:22,610
done here is I'm going to start a whole

00:16:17,570 --> 00:16:25,070
server and I created scripts because I

00:16:22,610 --> 00:16:27,740
suck at typing so I'm starting a both

00:16:25,070 --> 00:16:30,019
server that's exciting it's running as a

00:16:27,740 --> 00:16:33,279
service in the background I'm going to

00:16:30,019 --> 00:16:33,279
go ahead and open a new tab over here

00:16:39,440 --> 00:16:44,430
okay so I have one it's running as a

00:16:43,050 --> 00:16:46,320
service if I was in production it would

00:16:44,430 --> 00:16:48,720
run in high availability mode but for

00:16:46,320 --> 00:16:51,120
locally I just have one instance and I

00:16:48,720 --> 00:16:52,770
just make requests again small yeah it

00:16:51,120 --> 00:16:54,720
acts just like a database where it has

00:16:52,770 --> 00:16:56,280
data but we'll see in a little bit that

00:16:54,720 --> 00:16:57,180
it's a little bit more than that so just

00:16:56,280 --> 00:16:59,070
to prove to you that I have a mult

00:16:57,180 --> 00:17:01,130
server up and running there's a wealth

00:16:59,070 --> 00:17:03,420
server I just queried for its status

00:17:01,130 --> 00:17:06,540
both is conceptually similar to a

00:17:03,420 --> 00:17:08,370
website you have to login to home or

00:17:06,540 --> 00:17:09,780
authenticate to vault there's a number

00:17:08,370 --> 00:17:11,190
of ways you can authenticate you can

00:17:09,780 --> 00:17:13,770
authenticate via a username and password

00:17:11,190 --> 00:17:16,410
you can authenticate via github token

00:17:13,770 --> 00:17:18,900
you can authenticate via LDAP service

00:17:16,410 --> 00:17:20,250
accounts etc the easiest way to think

00:17:18,900 --> 00:17:22,650
about it is when you log into a website

00:17:20,250 --> 00:17:24,120
you put in a username and a password the

00:17:22,650 --> 00:17:26,250
username and password is validated

00:17:24,120 --> 00:17:27,810
against a back-end database and then you

00:17:26,250 --> 00:17:28,980
get a session token or a session acting

00:17:27,810 --> 00:17:31,620
me and that's stored in a cookie in your

00:17:28,980 --> 00:17:34,440
browser involved the concept of a

00:17:31,620 --> 00:17:36,380
session ID is called a vault token so

00:17:34,440 --> 00:17:38,790
I'm just going to log into vault here

00:17:36,380 --> 00:17:40,410
and I'm now authenticate is involved and

00:17:38,790 --> 00:17:42,060
I've logged in as the root account which

00:17:40,410 --> 00:17:44,880
is a really bad practice but this is a

00:17:42,060 --> 00:17:46,440
demo so I'm doing it anyway and this is

00:17:44,880 --> 00:17:48,400
just going to kind of showcase it gives

00:17:46,440 --> 00:17:52,400
me super permissions and the system

00:17:48,400 --> 00:17:54,260
so the first kind of component of vault

00:17:52,400 --> 00:17:56,360
and the easiest one to think about with

00:17:54,260 --> 00:17:58,580
encryption is this what we call the

00:17:56,360 --> 00:18:00,020
static key value store the easiest way

00:17:58,580 --> 00:18:01,940
to think about this is like encrypted

00:18:00,020 --> 00:18:03,650
redness or an encrypted memcache I'm

00:18:01,940 --> 00:18:05,660
going to give Balt some plaintext data

00:18:03,650 --> 00:18:07,970
vault I'm going to encrypt that data in

00:18:05,660 --> 00:18:11,030
transit with TLS and a crystal a aqua

00:18:07,970 --> 00:18:13,010
rest with AES 256-bit encryption and

00:18:11,030 --> 00:18:13,520
it's going to store it when I want it

00:18:13,010 --> 00:18:15,559
back

00:18:13,520 --> 00:18:17,360
I asked vault for the native back full

00:18:15,559 --> 00:18:19,220
decrypt it gives me back to plaintext

00:18:17,360 --> 00:18:20,660
data so it's going to behave similar to

00:18:19,220 --> 00:18:23,120
like red ass or memcache but it's

00:18:20,660 --> 00:18:25,610
encrypted in transit and at rest so I do

00:18:23,120 --> 00:18:28,550
that by writing to anything under secret

00:18:25,610 --> 00:18:32,809
so I'm gonna create a secret named Wi-Fi

00:18:28,550 --> 00:18:35,720
Wow I can't say and I'm gonna say that

00:18:32,809 --> 00:18:37,820
the password is and what is the Wi-Fi

00:18:35,720 --> 00:18:40,690
password I'm not typing that out the

00:18:37,820 --> 00:18:40,690
password is bananas

00:18:41,370 --> 00:18:48,820
so I've created this credential and I

00:18:44,799 --> 00:18:50,980
can read that credential back out and I

00:18:48,820 --> 00:18:53,799
get that my password is bananas and I

00:18:50,980 --> 00:18:56,950
can create any number of these secrets

00:18:53,799 --> 00:19:01,290
so I might have the the bathroom door

00:18:56,950 --> 00:19:01,290
code it might be

00:19:01,740 --> 00:19:06,510
one two three four and I can actually

00:19:03,960 --> 00:19:08,280
list these now and I can see I have two

00:19:06,510 --> 00:19:10,650
credentials the bathroom credential and

00:19:08,280 --> 00:19:12,930
the Wi-Fi credential and this is nothing

00:19:10,650 --> 00:19:15,120
for this it's just I gave hall some data

00:19:12,930 --> 00:19:16,590
and encrypted it it's stored in I want

00:19:15,120 --> 00:19:18,510
it back I get it back

00:19:16,590 --> 00:19:20,250
that whole process is authenticated them

00:19:18,510 --> 00:19:21,570
so I'm cheating a little bit here I'm

00:19:20,250 --> 00:19:24,060
the Rubik count which is kind of like

00:19:21,570 --> 00:19:26,340
pseudo in Linux so I can do anything on

00:19:24,060 --> 00:19:28,530
the system but everything in vote is

00:19:26,340 --> 00:19:30,630
actually policy based and if you don't

00:19:28,530 --> 00:19:32,610
have permission even you can't do it so

00:19:30,630 --> 00:19:34,020
I could create a policy which lets me

00:19:32,610 --> 00:19:36,810
read the Wi-Fi password but not the

00:19:34,020 --> 00:19:42,890
bathroom code so work all you want no

00:19:36,810 --> 00:19:45,690
breaks for you someone can fetch it so

00:19:42,890 --> 00:19:47,910
this is a basic crud operation so the

00:19:45,690 --> 00:19:49,320
last thing you can do obviously is to

00:19:47,910 --> 00:19:51,810
delete things so I'll go ahead and

00:19:49,320 --> 00:19:53,400
delete the bathroom code and I've now

00:19:51,810 --> 00:19:55,560
deleted that credential so basic crud

00:19:53,400 --> 00:19:57,390
operations on a key value store it

00:19:55,560 --> 00:19:59,310
doesn't feel encrypted right how many

00:19:57,390 --> 00:20:01,620
people feel extra secure using this over

00:19:59,310 --> 00:20:03,870
something like Redis yeah it doesn't

00:20:01,620 --> 00:20:06,540
actually feel secure and I want to talk

00:20:03,870 --> 00:20:08,250
about that for a second so the reason

00:20:06,540 --> 00:20:10,440
for this is that the security industry

00:20:08,250 --> 00:20:14,310
has kind of pre conditioned us to

00:20:10,440 --> 00:20:16,380
believe that security has to be hard and

00:20:14,310 --> 00:20:18,480
part of this as vendors trying to sell

00:20:16,380 --> 00:20:20,370
their appliances and and part of this is

00:20:18,480 --> 00:20:21,510
just security was hard for a very long

00:20:20,370 --> 00:20:24,240
time

00:20:21,510 --> 00:20:27,240
vault is open source it's been audited I

00:20:24,240 --> 00:20:28,950
think six times now by three different

00:20:27,240 --> 00:20:30,300
groups including the NCC curve which is

00:20:28,950 --> 00:20:33,450
like a leading auditing firm in the

00:20:30,300 --> 00:20:36,240
security compliance area it's FIPS 140 -

00:20:33,450 --> 00:20:37,350
2 compliant it can be PCI compliant if

00:20:36,240 --> 00:20:39,960
you follow the correct steps for

00:20:37,350 --> 00:20:41,940
implementation so it checks all of the

00:20:39,960 --> 00:20:43,200
boxes all of the multi letter acronyms

00:20:41,940 --> 00:20:46,020
that you're used to with security and

00:20:43,200 --> 00:20:47,910
compliance yet we don't feel secure and

00:20:46,020 --> 00:20:49,710
that's that's part of the industry's

00:20:47,910 --> 00:20:51,000
thing and part of the thing I'm setting

00:20:49,710 --> 00:20:52,360
out to change is that security doesn't

00:20:51,000 --> 00:20:55,180
have to be hard

00:20:52,360 --> 00:20:56,910
this is a tool that is validated it is

00:20:55,180 --> 00:21:00,760
used by government agencies in the world

00:20:56,910 --> 00:21:02,950
so it passes all the checks but this

00:21:00,760 --> 00:21:05,620
doesn't revolt is cool I could build

00:21:02,950 --> 00:21:07,390
this backed by something like Redis or

00:21:05,620 --> 00:21:09,430
been cashed in an afternoon so this is

00:21:07,390 --> 00:21:11,170
just one feature alone another feature

00:21:09,430 --> 00:21:15,250
of all and where it really shines this

00:21:11,170 --> 00:21:17,080
notion of dynamic credentials so here

00:21:15,250 --> 00:21:19,210
when we're using the key value store I

00:21:17,080 --> 00:21:20,950
give both data vault encryption and

00:21:19,210 --> 00:21:23,350
stores it but what if I have a really

00:21:20,950 --> 00:21:25,480
large data set maybe I have a database

00:21:23,350 --> 00:21:27,010
with 100 million users in it and I want

00:21:25,480 --> 00:21:28,780
to encrypt their passwords or their

00:21:27,010 --> 00:21:31,630
social security or or credit card

00:21:28,780 --> 00:21:34,450
numbers I don't want to store that

00:21:31,630 --> 00:21:36,730
involved without a lot of data and vote

00:21:34,450 --> 00:21:38,950
isn't a database right it shouldn't be

00:21:36,730 --> 00:21:40,360
used for things you know replication and

00:21:38,950 --> 00:21:41,980
charting right that's a databases

00:21:40,360 --> 00:21:44,200
responsibility but I still want to

00:21:41,980 --> 00:21:45,670
encrypt the data so what we can use is

00:21:44,200 --> 00:21:48,070
we can use what's called a transit back

00:21:45,670 --> 00:21:50,290
so instead of vault encrypting and

00:21:48,070 --> 00:21:53,230
storing the data the vault will encrypt

00:21:50,290 --> 00:21:55,150
and return the data to me then it's my

00:21:53,230 --> 00:21:56,920
responsibility to persist that in my

00:21:55,150 --> 00:22:00,130
application so I'll go ahead and show

00:21:56,920 --> 00:22:02,530
you how that works everything involved

00:22:00,130 --> 00:22:05,890
is like a file system so I'm going to go

00:22:02,530 --> 00:22:07,450
ahead and enable the transit back-end as

00:22:05,890 --> 00:22:09,460
we call it and then I'm going to create

00:22:07,450 --> 00:22:13,660
an encryption so I'm going to go ahead

00:22:09,460 --> 00:22:16,310
and run this setup transit

00:22:13,660 --> 00:22:19,130
and now I have this transit back-end and

00:22:16,310 --> 00:22:23,000
I have an encryption key named Maya so

00:22:19,130 --> 00:22:26,870
what I can do is I can encrypt transit

00:22:23,000 --> 00:22:31,550
encrypt my app I can encrypt some plain

00:22:26,870 --> 00:22:33,560
text data and that data has to be basic

00:22:31,550 --> 00:22:37,460
ste 4 encoded which I'll explain in a

00:22:33,560 --> 00:22:40,070
second and I will say Asia

00:22:37,460 --> 00:22:41,630
so I've encrypted this what happened was

00:22:40,070 --> 00:22:43,910
I sent some plain text data dove all

00:22:41,630 --> 00:22:48,200
vote encrypted it using a cipher suite

00:22:43,910 --> 00:22:50,000
and returned me this encrypted text this

00:22:48,200 --> 00:22:52,400
is also available via the API actually

00:22:50,000 --> 00:22:54,830
everything I do via the CLI is available

00:22:52,400 --> 00:22:57,110
via the API the CLI is just a very thin

00:22:54,830 --> 00:22:59,300
wrapper around the API so you could do

00:22:57,110 --> 00:23:02,000
this in Ruby or Python or Java or with

00:22:59,300 --> 00:23:03,830
curl if you would like I take this

00:23:02,000 --> 00:23:06,140
ciphertext this whole block of text

00:23:03,830 --> 00:23:08,630
including the vault b1 and I spread out

00:23:06,140 --> 00:23:13,910
my database when I want the plaintext

00:23:08,630 --> 00:23:16,730
back I take this entire ciphertext and I

00:23:13,910 --> 00:23:19,550
give it back to ball but I use the

00:23:16,730 --> 00:23:25,630
decrypt endpoint

00:23:19,550 --> 00:23:29,650
my hat and I give it the ciphertext and

00:23:25,630 --> 00:23:34,190
volt gives me back the plaintext and

00:23:29,650 --> 00:23:36,460
this is basic c4 encoded so if we echo

00:23:34,190 --> 00:23:36,460
this

00:23:38,900 --> 00:23:44,300
[Music]

00:23:40,120 --> 00:23:46,070
we'll get sausage so the reason that we

00:23:44,300 --> 00:23:49,100
use basic ste for encoding is that

00:23:46,070 --> 00:23:51,559
there's actually no requirement that the

00:23:49,100 --> 00:23:55,190
data that you're persisting to Paul is

00:23:51,559 --> 00:23:57,200
representable as ASCII characters pedia

00:23:55,190 --> 00:23:58,370
work document rate all of those are

00:23:57,200 --> 00:24:01,100
things that I should be able to encrypt

00:23:58,370 --> 00:24:04,220
but under the hood this is a JSON

00:24:01,100 --> 00:24:06,590
payload over HTTP over TLS and in order

00:24:04,220 --> 00:24:08,870
to safely transmit those binary bits I

00:24:06,590 --> 00:24:10,790
need a transport mechanism in base64 is

00:24:08,870 --> 00:24:12,679
one of the most common so if you are

00:24:10,790 --> 00:24:14,480
encrypting kind of large blobs of data

00:24:12,679 --> 00:24:16,520
you've a 64 encode them they get sent

00:24:14,480 --> 00:24:19,520
along with the payload they come back as

00:24:16,520 --> 00:24:20,750
a binary safe string so you can store

00:24:19,520 --> 00:24:23,090
them in a database and then retrieve

00:24:20,750 --> 00:24:25,690
them later so this is a great way to

00:24:23,090 --> 00:24:27,530
provide encryption as a service and

00:24:25,690 --> 00:24:30,890
what's nice is there's a number of

00:24:27,530 --> 00:24:32,570
different features of this so it's not

00:24:30,890 --> 00:24:34,400
just an encryption key it's actually an

00:24:32,570 --> 00:24:36,440
encryption key ring so I can maintain

00:24:34,400 --> 00:24:38,540
multiple versions I can upgrade and

00:24:36,440 --> 00:24:39,679
downgrade my encryption keys to make

00:24:38,540 --> 00:24:41,000
sure that I'm always using the latest

00:24:39,679 --> 00:24:43,400
data and my data is always encrypted

00:24:41,000 --> 00:24:44,660
with a fresh key I have you know

00:24:43,400 --> 00:24:46,670
third-party processes that can

00:24:44,660 --> 00:24:49,100
re-encrypt data I can have my front end

00:24:46,670 --> 00:24:50,929
servers with the permission to encrypt

00:24:49,100 --> 00:24:52,580
data but not decrypted not kind of my

00:24:50,929 --> 00:24:54,440
back-end servers the ability to decrypt

00:24:52,580 --> 00:24:55,850
data but not be encrypted this will let

00:24:54,440 --> 00:24:57,770
me have a front-end application that

00:24:55,850 --> 00:24:59,630
could accept credit card applications it

00:24:57,770 --> 00:25:00,860
would in current encrypt the you know

00:24:59,630 --> 00:25:03,170
social security number of the credit

00:25:00,860 --> 00:25:04,700
card number put it in the database but

00:25:03,170 --> 00:25:06,380
it could never decrypt it so even if an

00:25:04,700 --> 00:25:08,210
attacker gain access to my front-end

00:25:06,380 --> 00:25:09,770
server they had a root access on my

00:25:08,210 --> 00:25:11,780
front end server that servers not

00:25:09,770 --> 00:25:12,980
authorized to decrypt data so they

00:25:11,780 --> 00:25:14,660
couldn't actually decrypt it because

00:25:12,980 --> 00:25:16,340
they have to also a compromised vault in

00:25:14,660 --> 00:25:19,070
that scenario so it's a multi faceted

00:25:16,340 --> 00:25:21,080
attack similarly my back-end servers can

00:25:19,070 --> 00:25:22,790
only decrypt data if an attacker is able

00:25:21,080 --> 00:25:24,020
to compromise that service they can get

00:25:22,790 --> 00:25:26,270
their credit-card numbers but they can't

00:25:24,020 --> 00:25:27,720
persist any bad data or any fraudulent

00:25:26,270 --> 00:25:30,140
data into my system because

00:25:27,720 --> 00:25:33,030
can't perform the encryption operation

00:25:30,140 --> 00:25:35,750
so this is kind of leading into what

00:25:33,030 --> 00:25:37,950
involved we call dynamic credentials

00:25:35,750 --> 00:25:40,860
dynamic credentials are things that

00:25:37,950 --> 00:25:42,390
could created on the fly so one of the

00:25:40,860 --> 00:25:43,740
easiest ways to think about dynamic

00:25:42,390 --> 00:25:45,929
credentials is in terms of databases

00:25:43,740 --> 00:25:48,090
right now in order to create a database

00:25:45,929 --> 00:25:50,309
password you have to like run some SQL

00:25:48,090 --> 00:25:51,720
commands or clicking agree you get back

00:25:50,309 --> 00:25:53,309
a username a password and you put it in

00:25:51,720 --> 00:25:55,409
a text file and you share it across all

00:25:53,309 --> 00:25:57,630
your applications there's a number of

00:25:55,409 --> 00:25:59,190
problems with this namely you have one

00:25:57,630 --> 00:26:00,600
shared credentials so if it's hacked you

00:25:59,190 --> 00:26:02,580
have to take the curve down time to

00:26:00,600 --> 00:26:04,140
rotate those credentials you don't have

00:26:02,580 --> 00:26:06,570
provenance which is a one-to-one mapping

00:26:04,140 --> 00:26:07,980
of an application to its credentials and

00:26:06,570 --> 00:26:10,350
it's not good for auditing and logging

00:26:07,980 --> 00:26:13,080
right you can't do this dissection or

00:26:10,350 --> 00:26:16,320
diagnosis of a problem so what we can do

00:26:13,080 --> 00:26:19,200
involve Iran that before I actually

00:26:16,320 --> 00:26:21,510
showed you what it was is vault can

00:26:19,200 --> 00:26:23,809
actually connect to a database like

00:26:21,510 --> 00:26:26,039
Postgres or my sequel or hana or oracle

00:26:23,809 --> 00:26:27,929
and it can actually dynamically create

00:26:26,039 --> 00:26:31,230
these credentials so I'm running a

00:26:27,929 --> 00:26:33,179
localhost here because I didn't want to

00:26:31,230 --> 00:26:34,679
rely on the internet but last night at

00:26:33,179 --> 00:26:36,780
the meetup my demo using this on-call

00:26:34,679 --> 00:26:39,720
sequel so third party database service

00:26:36,780 --> 00:26:41,429
what I do is I give vault root or

00:26:39,720 --> 00:26:46,110
privilege credentials to my database and

00:26:41,429 --> 00:26:48,570
I give it a series of SQL commands to

00:26:46,110 --> 00:26:51,240
run to create a user so here I say

00:26:48,570 --> 00:26:53,340
create role with login password validate

00:26:51,240 --> 00:26:55,470
ill and these curly brace things get

00:26:53,340 --> 00:26:57,840
filled in by bolts so what will happen

00:26:55,470 --> 00:26:59,820
is when I make an API request a vault

00:26:57,840 --> 00:27:02,940
vault will establish a connection to

00:26:59,820 --> 00:27:04,289
post to us it will run this SQL filling

00:27:02,940 --> 00:27:06,120
in the things between the curly braces

00:27:04,289 --> 00:27:08,730
and give me back my user

00:27:06,120 --> 00:27:12,150
so what we've done and what vault does

00:27:08,730 --> 00:27:14,279
is it actually provides an HTTP API for

00:27:12,150 --> 00:27:15,929
programmatically generating sequel users

00:27:14,279 --> 00:27:18,390
and this works with Microsoft sequel

00:27:15,929 --> 00:27:21,900
Oracle a lot of mainstream databases out

00:27:18,390 --> 00:27:23,340
there you can run any SQL statement so

00:27:21,900 --> 00:27:24,900
if you have a stored procedure or if you

00:27:23,340 --> 00:27:26,820
want to grant privileges on a number of

00:27:24,900 --> 00:27:31,230
different things it's just an SQL

00:27:26,820 --> 00:27:33,150
statement so I already set that up and

00:27:31,230 --> 00:27:36,779
you'll notice here that I've created a

00:27:33,150 --> 00:27:39,210
role a role name to read-only is like a

00:27:36,779 --> 00:27:42,000
symlink so when I want credentials I

00:27:39,210 --> 00:27:44,010
asked vault hey give me the credentials

00:27:42,000 --> 00:27:45,570
that correspond to the sequel that the

00:27:44,010 --> 00:27:47,640
sequel statement and the way I do that

00:27:45,570 --> 00:27:51,120
is by referencing the role so I would

00:27:47,640 --> 00:27:52,110
run something like vault read actually

00:27:51,120 --> 00:27:55,080
before you do that let me prove

00:27:52,110 --> 00:27:58,950
something to you so this is my local

00:27:55,080 --> 00:28:01,200
sequel instance you can see there's one

00:27:58,950 --> 00:28:02,440
user in there that's me and the rig

00:28:01,200 --> 00:28:05,350
music

00:28:02,440 --> 00:28:08,800
now what I'm going to do is I'm going to

00:28:05,350 --> 00:28:10,420
read from database creds read only this

00:28:08,800 --> 00:28:12,640
is going to generate credentials so when

00:28:10,420 --> 00:28:14,050
I hit enter bullet actually establishes

00:28:12,640 --> 00:28:16,300
a connection to my local Postgres

00:28:14,050 --> 00:28:17,590
cluster generates a username and

00:28:16,300 --> 00:28:19,900
password and fills it in between those

00:28:17,590 --> 00:28:22,390
curly braces executes that sequel and

00:28:19,900 --> 00:28:23,470
returns the results me so here you'll

00:28:22,390 --> 00:28:25,900
see we got a username and a password

00:28:23,470 --> 00:28:28,840
back this was a real Postgres username

00:28:25,900 --> 00:28:30,760
and a real Postgres password and every

00:28:28,840 --> 00:28:32,800
time I run this command I'll get a new

00:28:30,760 --> 00:28:35,620
username and password so you can see

00:28:32,800 --> 00:28:38,470
here that they're they're different this

00:28:35,620 --> 00:28:41,350
is useful because all my app has to do

00:28:38,470 --> 00:28:43,090
is at boot time make a request of all if

00:28:41,350 --> 00:28:45,010
it's authorized and authenticated to do

00:28:43,090 --> 00:28:47,770
that you don't get back its own unique

00:28:45,010 --> 00:28:49,450
credential so that one application has a

00:28:47,770 --> 00:28:51,490
unique credential to talk to my database

00:28:49,450 --> 00:28:54,040
you'll notice that the database

00:28:51,490 --> 00:28:57,190
credential has a lease duration of 768

00:28:54,040 --> 00:29:01,740
hours it's about a day there sorry about

00:28:57,190 --> 00:29:01,740
a month it's a long day

00:29:02,100 --> 00:29:06,820
Jupiter yeah it's about a day on Jupiter

00:29:04,600 --> 00:29:08,740
that's about 30 days so what will happen

00:29:06,820 --> 00:29:10,720
is after 30 days this courage won't get

00:29:08,740 --> 00:29:12,220
revoked automatically so we don't have

00:29:10,720 --> 00:29:13,660
to worry about rotation and stuff

00:29:12,220 --> 00:29:16,150
because we can tell our auditors and our

00:29:13,660 --> 00:29:17,980
compliance teams hey this no credential

00:29:16,150 --> 00:29:19,600
lives are in the 30 days I could set

00:29:17,980 --> 00:29:21,250
that to as little as 5 minutes if I

00:29:19,600 --> 00:29:23,920
really wanted to and the no credential

00:29:21,250 --> 00:29:26,170
and live longer than 5 minutes

00:29:23,920 --> 00:29:30,070
so to prove this to you I'll go back

00:29:26,170 --> 00:29:31,660
here psql I'll list the users and you'll

00:29:30,070 --> 00:29:34,990
see we have two users in here now

00:29:31,660 --> 00:29:36,520
so we programmatically and again under

00:29:34,990 --> 00:29:38,680
the hood this is just an API call

00:29:36,520 --> 00:29:41,260
we now have an HTTP API that can

00:29:38,680 --> 00:29:43,660
generate databases this is incredibly

00:29:41,260 --> 00:29:46,390
powerful and those users have a limited

00:29:43,660 --> 00:29:48,100
time that they live they can live for a

00:29:46,390 --> 00:29:49,870
configurable amount of time anywhere

00:29:48,100 --> 00:29:51,730
from one second all the way up to five

00:29:49,870 --> 00:29:53,260
or ten years but we're able to time

00:29:51,730 --> 00:29:55,570
scope these we wrought if we can revoke

00:29:53,260 --> 00:29:57,070
them in advance as well so right now I

00:29:55,570 --> 00:29:58,660
just showed you all my username and

00:29:57,070 --> 00:30:00,550
password to my database that probably

00:29:58,660 --> 00:30:02,350
wasn't a good idea so what I'm going to

00:30:00,550 --> 00:30:05,680
do is I'm just going to go ahead and run

00:30:02,350 --> 00:30:07,870
fall provoke and I'm going to revoke all

00:30:05,680 --> 00:30:13,980
the database credentials and just like

00:30:07,870 --> 00:30:16,450
that when I go in here they're all gone

00:30:13,980 --> 00:30:19,330
so that's what we call a great class

00:30:16,450 --> 00:30:22,090
procedure which is Oh No I've been act I

00:30:19,330 --> 00:30:23,950
need to like stop the cleaning I'm going

00:30:22,090 --> 00:30:26,019
to incur downtime but that's better than

00:30:23,950 --> 00:30:27,460
losing customer data I'm gonna delete

00:30:26,019 --> 00:30:28,840
all of my gradual and I'm going to start

00:30:27,460 --> 00:30:30,929
from scratch and rediagnosis this

00:30:28,840 --> 00:30:32,950
problem so we can find where the

00:30:30,929 --> 00:30:35,499
vulnerability or the infiltration happen

00:30:32,950 --> 00:30:36,999
that's how easy it is to revoke these

00:30:35,499 --> 00:30:38,889
credentials and you can do it on a

00:30:36,999 --> 00:30:40,869
subset you can do it on a full set you

00:30:38,889 --> 00:30:42,399
can revoke everything in phones now that

00:30:40,869 --> 00:30:44,200
requires a lot of privilege not every

00:30:42,399 --> 00:30:46,419
user can do that again I'm the root user

00:30:44,200 --> 00:30:50,249
so I have kind of exponential privilege

00:30:46,419 --> 00:30:50,249
in the system but if you do that

00:30:53,429 --> 00:30:58,260
if you do this you don't miss tracing

00:30:55,110 --> 00:31:00,510
because the the username and the lease

00:30:58,260 --> 00:31:02,039
ID are available in an audit log which

00:31:00,510 --> 00:31:03,990
is stored separately typically you put

00:31:02,039 --> 00:31:05,399
that into something like spunk or some

00:31:03,990 --> 00:31:09,149
third party system so you can still

00:31:05,399 --> 00:31:12,020
correlate with the logs how many people

00:31:09,149 --> 00:31:14,960
here run their own certificate authority

00:31:12,020 --> 00:31:17,700
know you don't like to self deprecating

00:31:14,960 --> 00:31:19,679
so one of the cool features about fault

00:31:17,700 --> 00:31:21,720
with these dynamic secrets and one of

00:31:19,679 --> 00:31:23,460
the challenges with micro services

00:31:21,720 --> 00:31:24,659
especially a lot of them is you might

00:31:23,460 --> 00:31:26,640
really need some kind of service mesh

00:31:24,659 --> 00:31:27,990
with something like sto an envoy to

00:31:26,640 --> 00:31:30,240
manage meet authentication and

00:31:27,990 --> 00:31:31,830
authorization in the cluster or you have

00:31:30,240 --> 00:31:34,649
to manage your own PKI infrastructure

00:31:31,830 --> 00:31:37,169
and all actually makes that second one

00:31:34,649 --> 00:31:39,120
easier so for customers that can't adopt

00:31:37,169 --> 00:31:40,980
tools like that or aren't ready to make

00:31:39,120 --> 00:31:42,539
the step to a service mash your own

00:31:40,980 --> 00:31:47,510
internal PKI infrastructure is very

00:31:42,539 --> 00:31:50,190
helpful so here what I'm doing is I'm

00:31:47,510 --> 00:31:52,500
generating a root certificate I could

00:31:50,190 --> 00:31:56,399
give all my own certificate if I wanted

00:31:52,500 --> 00:31:59,990
and then I'm generating a roll called my

00:31:56,399 --> 00:32:02,100
website where I can actually generate

00:31:59,990 --> 00:32:03,630
TLS certificates on the fly

00:32:02,100 --> 00:32:04,890
so if you're not familiar with PK

00:32:03,630 --> 00:32:06,210
infrastructure don't worry about like

00:32:04,890 --> 00:32:07,860
the curl distribution points and stuff

00:32:06,210 --> 00:32:09,390
all you need to know is this is really

00:32:07,860 --> 00:32:12,000
hard and often involves lots of stack

00:32:09,390 --> 00:32:13,470
overflow copying and pasting and then

00:32:12,000 --> 00:32:16,890
eventually someone figures it out and

00:32:13,470 --> 00:32:19,590
puts it in a text file so what I'm going

00:32:16,890 --> 00:32:23,990
to do here is I will configure this so

00:32:19,590 --> 00:32:25,400
setup PKI and now what I can do is

00:32:23,990 --> 00:32:29,000
I can just generate our certificate on

00:32:25,400 --> 00:32:32,179
the fly so what I did here is I wrote I

00:32:29,000 --> 00:32:34,880
asked will to issue me a certificate for

00:32:32,179 --> 00:32:36,170
example comm and that was authorized

00:32:34,880 --> 00:32:37,790
authenticated so I got back the

00:32:36,170 --> 00:32:39,500
certificate I get back to public see a

00:32:37,790 --> 00:32:42,590
chain and the private certificate as

00:32:39,500 --> 00:32:45,020
well so there's the issuing CA and

00:32:42,590 --> 00:32:47,210
here's my private key and again all of

00:32:45,020 --> 00:32:49,100
this is happening the end API so there

00:32:47,210 --> 00:32:51,830
are tools out there that actually do

00:32:49,100 --> 00:32:53,660
this entirely in memory so web servers

00:32:51,830 --> 00:32:55,850
that query vault trailer TLS certificate

00:32:53,660 --> 00:32:58,610
and only storing and memory so even if

00:32:55,850 --> 00:33:00,230
the system is compromised someone would

00:32:58,610 --> 00:33:03,020
have to trigger a core dump to get the

00:33:00,230 --> 00:33:04,640
private key out of these web servers and

00:33:03,020 --> 00:33:05,870
again this is an API under the hood so

00:33:04,640 --> 00:33:09,530
you can automate this in any language

00:33:05,870 --> 00:33:11,570
you like again every time I run this

00:33:09,530 --> 00:33:13,190
command I'll get a new certificate and I

00:33:11,570 --> 00:33:14,780
can revoke the certificates early so

00:33:13,190 --> 00:33:16,940
this certificate I think is valid for 30

00:33:14,780 --> 00:33:18,530
days but if all of a sudden I detect an

00:33:16,940 --> 00:33:20,540
intrusion I don't trust my application

00:33:18,530 --> 00:33:22,340
anymore I can revoke it early and it can

00:33:20,540 --> 00:33:26,990
no longer talk within my systems because

00:33:22,340 --> 00:33:29,620
a music mutual TLS for example this next

00:33:26,990 --> 00:33:29,620
one is kind of fun

00:33:29,640 --> 00:33:38,220
but it has a real use case so how many

00:33:34,860 --> 00:33:39,630
people know what TOTP is yeah so TTP is

00:33:38,220 --> 00:33:43,290
the generic algorithm for one-time

00:33:39,630 --> 00:33:44,880
passwords or passphrases multi-factor

00:33:43,290 --> 00:33:45,809
authentication those six are eight digit

00:33:44,880 --> 00:33:49,500
codes you get with like Google

00:33:45,809 --> 00:33:53,220
Authenticator or offi it's a spec bull I

00:33:49,500 --> 00:33:56,610
can actually act as a totp provider an

00:33:53,220 --> 00:33:59,610
NC OTP reader so what's a good use case

00:33:56,610 --> 00:34:00,900
for this remember everything in Bolton

00:33:59,610 --> 00:34:02,549
is authenticated in log and the

00:34:00,900 --> 00:34:04,530
challenge with multi-factor

00:34:02,549 --> 00:34:06,540
authentication on something like an AWS

00:34:04,530 --> 00:34:09,030
root account is that it belongs to a

00:34:06,540 --> 00:34:11,250
phone or a device so if you run an

00:34:09,030 --> 00:34:13,740
Operations team how do you get multiple

00:34:11,250 --> 00:34:15,659
people access to that MFA code do you

00:34:13,740 --> 00:34:18,210
pass around an RSA SecurID token to

00:34:15,659 --> 00:34:19,320
people who are on call both is actually

00:34:18,210 --> 00:34:21,810
a really good solution for that so you

00:34:19,320 --> 00:34:23,340
actually store the generation involved

00:34:21,810 --> 00:34:25,320
and then you authorize and authenticate

00:34:23,340 --> 00:34:27,179
that and you can write what policies

00:34:25,320 --> 00:34:28,710
against third party systems so you can

00:34:27,179 --> 00:34:30,960
actually say people can only generate

00:34:28,710 --> 00:34:32,070
the TOTP code if they're on call and

00:34:30,960 --> 00:34:33,960
link that into something like page

00:34:32,070 --> 00:34:35,940
immunity this means that even if you're

00:34:33,960 --> 00:34:37,409
in the Operations Group you can't

00:34:35,940 --> 00:34:39,139
actually log into the interview s root

00:34:37,409 --> 00:34:41,909
account unless you're currently the ena

00:34:39,139 --> 00:34:45,530
so I'll go ahead and show you this I

00:34:41,909 --> 00:34:50,450
just have a sample one here

00:34:45,530 --> 00:34:54,389
and now what I can do is I can pull read

00:34:50,450 --> 00:34:57,450
TOTP code demo and I get back my six

00:34:54,389 --> 00:34:59,070
digit code so you know you're used to

00:34:57,450 --> 00:35:00,560
like scanning the barcodes those

00:34:59,070 --> 00:35:03,270
barcodes actually correspond to a URL

00:35:00,560 --> 00:35:05,010
and you can do that here after about

00:35:03,270 --> 00:35:06,780
thirty seconds this code will rotate and

00:35:05,010 --> 00:35:08,820
I'll get a new codes this is the same as

00:35:06,780 --> 00:35:10,920
like Google Authenticator or avi or you

00:35:08,820 --> 00:35:12,750
know one password doing the cycling but

00:35:10,920 --> 00:35:15,150
it's often a came in an auditive if I

00:35:12,750 --> 00:35:18,720
don't have permission to read this totp

00:35:15,150 --> 00:35:21,900
code I get permission denied vault can

00:35:18,720 --> 00:35:23,190
also act as a TTP provider so if you

00:35:21,900 --> 00:35:24,570
have an application and you want to add

00:35:23,190 --> 00:35:26,850
two factor authentication to your

00:35:24,570 --> 00:35:28,890
application you can either implement the

00:35:26,850 --> 00:35:30,480
entire TTP spec yourself and hope you

00:35:28,890 --> 00:35:32,520
get it right including recovery codes

00:35:30,480 --> 00:35:34,920
and you know backups and following over

00:35:32,520 --> 00:35:37,320
an SMS or you can use something like

00:35:34,920 --> 00:35:39,510
totp as a service this goes back to kind

00:35:37,320 --> 00:35:40,800
of vaults core mantra of security

00:35:39,510 --> 00:35:42,300
shouldn't be this hard we're going to

00:35:40,800 --> 00:35:45,390
give it to you as an api and do the best

00:35:42,300 --> 00:35:47,580
practices for you so instead of acting

00:35:45,390 --> 00:35:48,900
as the thing that generates codes vault

00:35:47,580 --> 00:35:51,270
can actually act as the thing that

00:35:48,900 --> 00:35:55,290
validates codes which is a TOTP provider

00:35:51,270 --> 00:35:58,760
so I'll show you how that works instead

00:35:55,290 --> 00:35:58,760
of to be provider

00:36:00,210 --> 00:36:05,290
so here I'm generating I use the

00:36:03,130 --> 00:36:07,390
generate equals true keyword but it's

00:36:05,290 --> 00:36:10,570
the same what we call it back end or the

00:36:07,390 --> 00:36:12,770
same generator so I will run setup

00:36:10,570 --> 00:36:17,520
teepee

00:36:12,770 --> 00:36:21,630
writer and I get back a bunch of text

00:36:17,520 --> 00:36:23,070
here this is kind of fun this first box

00:36:21,630 --> 00:36:24,600
of text is a barcode

00:36:23,070 --> 00:36:26,520
this is a basic ste four encoded image

00:36:24,600 --> 00:36:30,270
of a barcode that you can have your user

00:36:26,520 --> 00:36:33,780
scan with their mobile application the

00:36:30,270 --> 00:36:36,750
second one is the actual OTP off URL

00:36:33,780 --> 00:36:39,900
which is encoded in this barcode so I

00:36:36,750 --> 00:36:43,920
will I will attempt to remember the

00:36:39,900 --> 00:36:45,060
command to do this so I'm gonna copy

00:36:43,920 --> 00:36:48,710
this to my clipboard

00:36:45,060 --> 00:36:51,990
I think it's basic ste for - - to coup

00:36:48,710 --> 00:36:55,730
that long string of things and we'll

00:36:51,990 --> 00:36:55,730
save that as a peeler g5

00:36:56,680 --> 00:36:59,490
wildlife

00:36:59,580 --> 00:37:04,400
all right then open the sky

00:37:05,920 --> 00:37:09,780
popped up on the other screen but I

00:37:07,030 --> 00:37:09,780
promise it's real

00:37:11,250 --> 00:37:14,450
I'm fullscreen

00:37:16,160 --> 00:37:21,150
there you go so you could scan this with

00:37:19,470 --> 00:37:22,650
your app and it'll generate codes and

00:37:21,150 --> 00:37:26,640
you can submit those codes to wall and

00:37:22,650 --> 00:37:28,470
vote will validate them so again it's

00:37:26,640 --> 00:37:31,170
not hard if you follow the Tott

00:37:28,470 --> 00:37:33,270
spectabilis yourself but the idea is an

00:37:31,170 --> 00:37:35,250
involved kind of mantra is if we want

00:37:33,270 --> 00:37:37,020
teams to do secured if we want teams to

00:37:35,250 --> 00:37:39,300
do security well we have to make it easy

00:37:37,020 --> 00:37:42,870
and there's nothing easier than an API

00:37:39,300 --> 00:37:44,040
that does the best practices for you so

00:37:42,870 --> 00:37:46,920
the last thing I want to show how about

00:37:44,040 --> 00:37:49,770
ball is it's pluggable nature so in

00:37:46,920 --> 00:37:51,960
addition to all of the built-in things

00:37:49,770 --> 00:37:54,120
there might be something involved that I

00:37:51,960 --> 00:37:56,250
need to customize I might run some

00:37:54,120 --> 00:37:58,320
custom fork of my seat ball that doesn't

00:37:56,250 --> 00:37:59,820
integrate or I might have some crazy

00:37:58,320 --> 00:38:02,700
engine that I want to integrate with

00:37:59,820 --> 00:38:04,440
myself and I can do that with plugins

00:38:02,700 --> 00:38:06,300
and bulb has this really verbose plugin

00:38:04,440 --> 00:38:08,790
interface with a way to trust

00:38:06,300 --> 00:38:10,770
cryptographically secure plugins so I'm

00:38:08,790 --> 00:38:15,330
going to go ahead and install a plug-in

00:38:10,770 --> 00:38:18,480
here that I wrote what this plug-in does

00:38:15,330 --> 00:38:21,690
is it allows me to generate random

00:38:18,480 --> 00:38:22,770
passwords or pass phrases this is really

00:38:21,690 --> 00:38:24,810
useful if you've ever used something

00:38:22,770 --> 00:38:27,300
like one password or LastPass where you

00:38:24,810 --> 00:38:28,530
can generate logins for websites but I

00:38:27,300 --> 00:38:31,380
want something that's cryptographically

00:38:28,530 --> 00:38:32,580
secure truly random and I might want to

00:38:31,380 --> 00:38:33,780
be able to use like the die smart

00:38:32,580 --> 00:38:36,030
algorithm so that I can generate a

00:38:33,780 --> 00:38:37,410
dictionary or human readable things and

00:38:36,030 --> 00:38:39,650
I want to do things like include symbols

00:38:37,410 --> 00:38:41,660
or include letters and numbers

00:38:39,650 --> 00:38:42,890
this isn't something that's included

00:38:41,660 --> 00:38:44,450
revolt by default those of the

00:38:42,890 --> 00:38:46,940
third-party plugin but I just imported

00:38:44,450 --> 00:38:50,780
it so let's say I want a password

00:38:46,940 --> 00:38:54,380
I can ask fault to generate me a

00:38:50,780 --> 00:38:57,800
password Jen in this case actually maps

00:38:54,380 --> 00:38:59,660
to a plug-in which I just installed so

00:38:57,800 --> 00:39:01,640
bulk generated me a password and then

00:38:59,660 --> 00:39:03,830
gets 64 characters in length it includes

00:39:01,640 --> 00:39:05,420
letters numbers and symbols this is

00:39:03,830 --> 00:39:08,210
great I could use that on a website that

00:39:05,420 --> 00:39:09,620
doesn't suck and it would work great but

00:39:08,210 --> 00:39:10,880
there are websites out there that suck

00:39:09,620 --> 00:39:12,650
right how many people have ever put a

00:39:10,880 --> 00:39:14,030
password in and it's like no you can't

00:39:12,650 --> 00:39:15,610
be more than 12 characters and all the

00:39:14,030 --> 00:39:18,710
letters must be fine

00:39:15,610 --> 00:39:23,750
right it happens and for those cases you

00:39:18,710 --> 00:39:29,330
can customize that so I might want to

00:39:23,750 --> 00:39:30,680
say the length is I don't know 36

00:39:29,330 --> 00:39:33,770
characters because that's an arbitrary

00:39:30,680 --> 00:39:36,980
limit that someone impose and there can

00:39:33,770 --> 00:39:40,850
be you know up to 10 digits but we can't

00:39:36,980 --> 00:39:43,520
do symbols so this will give me a 36

00:39:40,850 --> 00:39:45,590
character string which is you know

00:39:43,520 --> 00:39:47,150
compliant with the specification and

00:39:45,590 --> 00:39:49,370
just like the other connections we saw

00:39:47,150 --> 00:39:54,050
every time I run this command I'll get a

00:39:49,370 --> 00:39:55,220
new password this is cool again this

00:39:54,050 --> 00:39:56,510
isn't something that's bundled with full

00:39:55,220 --> 00:39:59,700
this is something that I have built in

00:39:56,510 --> 00:40:02,339
an afternoon to show as a demo

00:39:59,700 --> 00:40:07,369
but I also use it for generating

00:40:02,339 --> 00:40:12,930
passwords it also generates pass phrases

00:40:07,369 --> 00:40:14,339
that's great so you might have seen

00:40:12,930 --> 00:40:17,130
these before this is a part of an

00:40:14,339 --> 00:40:20,760
algorithm called I swear short entrench

00:40:17,130 --> 00:40:25,109
monogamy expert polygraph rebel so this

00:40:20,760 --> 00:40:27,599
will generate six random words and put

00:40:25,109 --> 00:40:29,730
them together this was actually the what

00:40:27,599 --> 00:40:31,349
is a horse staple battery something of

00:40:29,730 --> 00:40:32,940
an xkcd right it's actually

00:40:31,349 --> 00:40:35,069
cryptographically more secure than the

00:40:32,940 --> 00:40:37,770
other passwords I showed you but this is

00:40:35,069 --> 00:40:39,359
way easier to type especially when it's

00:40:37,770 --> 00:40:41,010
like Netflix on your Apple TV and you're

00:40:39,359 --> 00:40:43,890
like scrolling to try to type in all

00:40:41,010 --> 00:40:46,500
these weird characters again just like

00:40:43,890 --> 00:40:51,079
the other one we can you know customize

00:40:46,500 --> 00:40:54,089
the number of words so I can say words

00:40:51,079 --> 00:40:55,680
goals 3 now I've got 3 words and I can

00:40:54,089 --> 00:40:58,319
customize the separator that exists

00:40:55,680 --> 00:41:00,980
between them this one's actually just

00:40:58,319 --> 00:41:03,380
really fun to play with

00:41:00,980 --> 00:41:07,880
like sometimes you get some really weird

00:41:03,380 --> 00:41:09,770
things like the treadmill greediest news

00:41:07,880 --> 00:41:13,430
sandstorm show men pregnant I like to

00:41:09,770 --> 00:41:15,650
make no stories about them if you are in

00:41:13,430 --> 00:41:17,270
your crypto that totally unrelated to

00:41:15,650 --> 00:41:19,910
this talk I would encourage you to look

00:41:17,270 --> 00:41:20,599
at the die square algorithm it's really

00:41:19,910 --> 00:41:22,760
cool

00:41:20,599 --> 00:41:24,020
dictionary based attack the problems the

00:41:22,760 --> 00:41:26,119
computers are really bad at random

00:41:24,020 --> 00:41:28,339
number generation so what the Dijkstra

00:41:26,119 --> 00:41:30,140
algorithm does is you roll a dice so you

00:41:28,339 --> 00:41:33,470
generate a number between 0 and or

00:41:30,140 --> 00:41:36,079
between 1 and 6 and you do that five or

00:41:33,470 --> 00:41:38,210
six times and then that corresponds

00:41:36,079 --> 00:41:41,300
thank you you truncate those digits

00:41:38,210 --> 00:41:44,660
together it's like 1 3 4 to 6 that

00:41:41,300 --> 00:41:46,460
corresponds to the 12,000 476 entry in a

00:41:44,660 --> 00:41:49,640
dictionary which becomes one of those

00:41:46,460 --> 00:41:51,760
words it's really cool there's a white

00:41:49,640 --> 00:41:54,320
paper on it you should look at it

00:41:51,760 --> 00:41:58,070
that's that I'm going to go back to like

00:41:54,320 --> 00:42:00,530
my last few slides so if you're curious

00:41:58,070 --> 00:42:02,660
about any of this but you're like I need

00:42:00,530 --> 00:42:05,210
a place to do this google cloud is

00:42:02,660 --> 00:42:07,720
giving you $3,000 in this check on a

00:42:05,210 --> 00:42:09,530
slide that you should take a picture of

00:42:07,720 --> 00:42:11,869
content you should take a picture of

00:42:09,530 --> 00:42:13,760
this slide so if you work for a start-up

00:42:11,869 --> 00:42:15,200
that's qualified you can visit this URL

00:42:13,760 --> 00:42:18,829
down here or just you know common

00:42:15,200 --> 00:42:20,869
startups at Google calm and credit you

00:42:18,829 --> 00:42:22,819
can play with vault all you want as well

00:42:20,869 --> 00:42:26,960
as a ton of other features of Google

00:42:22,819 --> 00:42:28,069
cloud there's no reason you shouldn't do

00:42:26,960 --> 00:42:31,219
it

00:42:28,069 --> 00:42:34,579
I will leave for more pictures to be

00:42:31,219 --> 00:42:37,759
taken you can also just write down this

00:42:34,579 --> 00:42:39,019
thing that's the the important part but

00:42:37,759 --> 00:42:41,030
this is a pretty slide so you should

00:42:39,019 --> 00:42:43,410
take a picture of it

00:42:41,030 --> 00:42:44,970
all right cool that's all I have for you

00:42:43,410 --> 00:42:47,120
thank you very much again my name is

00:42:44,970 --> 00:42:51,050
Seth you can follow me on Twitter and

00:42:47,120 --> 00:42:51,050
I'll be here the rest of the conference

00:42:59,880 --> 00:43:03,740
any questions syllable Seth

00:43:04,099 --> 00:43:06,640
how's that

00:43:06,730 --> 00:43:10,620
you're trying all the time

00:43:11,790 --> 00:43:17,590
do you know of anybody using bulk for

00:43:14,230 --> 00:43:19,090
managing ssh secrets yes so there's a

00:43:17,590 --> 00:43:20,440
there's a number what we call secret

00:43:19,090 --> 00:43:22,960
engines which I didn't discuss there's

00:43:20,440 --> 00:43:26,770
about 12 of them SSH is one of them so

00:43:22,960 --> 00:43:28,930
vault can actually act as the thing that

00:43:26,770 --> 00:43:31,780
sits in the middle so you install of all

00:43:28,930 --> 00:43:33,280
a general helper on the system and

00:43:31,780 --> 00:43:34,570
whenever you try to authenticate your

00:43:33,280 --> 00:43:36,220
authentication actually goes to fall

00:43:34,570 --> 00:43:38,560
vault generates a dynamic credential

00:43:36,220 --> 00:43:40,060
dynamic SSH key and locks you in it's

00:43:38,560 --> 00:43:42,850
also possible to do that be like trusted

00:43:40,060 --> 00:43:45,700
C is the biggest where you have open SS

00:43:42,850 --> 00:43:49,270
OpenSSH trust vault CA and then vault

00:43:45,700 --> 00:43:50,980
will sign that CA chain I have a chart

00:43:49,270 --> 00:43:55,810
that shows how that works B there are a

00:43:50,980 --> 00:43:57,610
number of people doing it the my problem

00:43:55,810 --> 00:43:59,740
with that is that if you're truly trying

00:43:57,610 --> 00:44:02,170
to do security well no one should access

00:43:59,740 --> 00:44:04,720
the system after it's online especially

00:44:02,170 --> 00:44:06,100
via SSH so if there's a reason that an

00:44:04,720 --> 00:44:08,530
operator needs to touch a system like

00:44:06,100 --> 00:44:11,350
that that's in my opinion a fault

00:44:08,530 --> 00:44:12,640
logging monitoring like we should be

00:44:11,350 --> 00:44:14,110
able to egress that data through

00:44:12,640 --> 00:44:15,100
third-party systems there's no reason an

00:44:14,110 --> 00:44:16,840
operator should have to touch that

00:44:15,100 --> 00:44:18,280
system if in fact that does happen

00:44:16,840 --> 00:44:20,650
though that system should immediately be

00:44:18,280 --> 00:44:21,820
taken offline so if I'm an operator and

00:44:20,650 --> 00:44:23,950
I need to debug an issue and I do

00:44:21,820 --> 00:44:26,230
something like well SSH to access that

00:44:23,950 --> 00:44:28,330
system that's associated be removed for

00:44:26,230 --> 00:44:29,800
production immediately upon debugging so

00:44:28,330 --> 00:44:32,370
that it wasn't tainted because we can no

00:44:29,800 --> 00:44:32,370
longer trust it

00:44:37,750 --> 00:44:43,510
you're just a simple question about the

00:44:40,680 --> 00:44:45,580
concept you shed around using bulk to

00:44:43,510 --> 00:44:47,970
issue passports that application to

00:44:45,580 --> 00:44:51,099
connect to the database and shop with

00:44:47,970 --> 00:44:54,550
username and passwords how do you handle

00:44:51,099 --> 00:44:56,650
that expiry and invitation yeah so the

00:44:54,550 --> 00:44:57,880
question is if I have these dynamic

00:44:56,650 --> 00:45:00,160
credentials what happens when the

00:44:57,880 --> 00:45:01,540
expired is that's application dependent

00:45:00,160 --> 00:45:02,980
and there's a few strategies so if

00:45:01,540 --> 00:45:05,020
you're building a cloud native

00:45:02,980 --> 00:45:06,280
application it likely responds to some

00:45:05,020 --> 00:45:08,349
type of signal to reload

00:45:06,280 --> 00:45:09,550
right stick hub or a graceful restart

00:45:08,349 --> 00:45:11,740
we're kind of hot reload its

00:45:09,550 --> 00:45:13,270
configuration in those situations you

00:45:11,740 --> 00:45:15,580
can use what we call sidecar

00:45:13,270 --> 00:45:17,380
applications that like end console and

00:45:15,580 --> 00:45:18,990
console template that will present the

00:45:17,380 --> 00:45:21,670
credentials that vault has as

00:45:18,990 --> 00:45:23,830
environment variables or a file on disk

00:45:21,670 --> 00:45:25,660
and when those pink credentials change

00:45:23,830 --> 00:45:27,880
or are about to change you signal the

00:45:25,660 --> 00:45:29,770
application to reload its configuration

00:45:27,880 --> 00:45:31,420
in the case of an on cloud native

00:45:29,770 --> 00:45:36,000
application like a java app that takes

00:45:31,420 --> 00:45:37,960
four years to boot typically its Harmon

00:45:36,000 --> 00:45:40,240
typically what we see in those scenarios

00:45:37,960 --> 00:45:42,130
is we adopt fall for the greenfield

00:45:40,240 --> 00:45:44,470
applications that can be cognitive and

00:45:42,130 --> 00:45:46,869
can adapt to these highly elastic

00:45:44,470 --> 00:45:48,250
environments and then for the Java app

00:45:46,869 --> 00:45:50,380
we just create a credential it's valid

00:45:48,250 --> 00:45:52,930
for a year we still do it in vault so we

00:45:50,380 --> 00:45:54,490
can revoke it early but it's still a

00:45:52,930 --> 00:45:56,349
manual process until someone can update

00:45:54,490 --> 00:45:59,099
that application or we can deprecated it

00:45:56,349 --> 00:45:59,099
Thanks

00:46:03,390 --> 00:46:07,890
I previously used these ruby cases Walt

00:46:06,000 --> 00:46:12,089
ebony needed support or plugin support

00:46:07,890 --> 00:46:15,510
for you mean he's so kind of so I used

00:46:12,089 --> 00:46:16,859
for ganache apart oh there was I was

00:46:15,510 --> 00:46:19,799
employed number four hash corpse I was

00:46:16,859 --> 00:46:21,240
there quite a while yes and no so the

00:46:19,799 --> 00:46:22,890
open source version of all does not have

00:46:21,240 --> 00:46:24,029
support for things like HSN's which is a

00:46:22,890 --> 00:46:25,980
derivative what you're talking about

00:46:24,029 --> 00:46:28,789
that'd be the key that's part of that

00:46:25,980 --> 00:46:31,410
enterprise play so customers that want

00:46:28,789 --> 00:46:32,970
hardware generated entropy can actually

00:46:31,410 --> 00:46:34,740
connect well to an HSN which could be a

00:46:32,970 --> 00:46:37,079
gimmicky or it could be some kind of

00:46:34,740 --> 00:46:38,760
appliance that generates entropy and

00:46:37,079 --> 00:46:40,079
that's a paint product so it's not

00:46:38,760 --> 00:46:42,859
available in open source but it is a

00:46:40,079 --> 00:46:42,859
feature that exists

00:46:46,150 --> 00:46:55,359
Cole does that thanks so much so great

00:46:54,240 --> 00:46:56,619
here

00:46:55,359 --> 00:47:00,059
quick announcement that we're gonna have

00:46:56,619 --> 00:47:03,160
a group photo this is a photo today

00:47:00,059 --> 00:47:06,400
12:15 and so fast already slowed

00:47:03,160 --> 00:47:08,859
down to level one and to the exhibition

00:47:06,400 --> 00:47:13,200
area we're just running up outside there

00:47:08,859 --> 00:47:13,200

YouTube URL: https://www.youtube.com/watch?v=67kUVazyoWA


