Title: Modern network servers - Philip Paeps- FOSSASIA 2018
Publication date: 2018-03-24
Playlist: FOSSASIA Summit 2018
Description: 
	Speaker: Philip Paeps, Director The FreeBSD Foundation
Info: https://2018.fossasia.org/event/speakers.html#philip-paeps3201

While the Intel x86-64 architecture is undisputedly market leader in the server space, several vendors have started introducing ARM64 boards. This presentation examines the suitability of ARM64 server boards for network servers. In particular, we look at the workload of a moderate-size ccTLD DNS zone (.dk) and how it would perform on ARM64 running FreeBSD.

We consider the viability of the ARM64 platform from performance and performance/power perspectives. While ARM64 is definitely slower than Intel on many workloads, it performs at least as well or better than Intel on workloads that are interesting to the internet community. Notably DNS is a very appropriate workload for ARM64.

Room: Training room 4-3
Track: Kernel & Platform
Date: Friday, 23rd March, 2018

Event Page: http://2018.fossasia.org
Follow FOSSASIA on Twitter: https://twitter.com/fossasia/
Like FOSSASIA on Facebook: https://www.facebook.com/fossasia/

Produced by Engineers.SG
Captions: 
	00:00:00,000 --> 00:00:05,130
I'll introduce myself as well I'm

00:00:02,970 --> 00:00:06,600
Phillip app so I'm a FreeBSD developer

00:00:05,130 --> 00:00:09,929
I'm also a director of the FreeBSD

00:00:06,600 --> 00:00:11,790
Foundation the FreeBSD Foundation has a

00:00:09,929 --> 00:00:14,820
booth downstairs if you are interested

00:00:11,790 --> 00:00:16,470
in FreeBSD stickers or FreeBSD journal

00:00:14,820 --> 00:00:19,140
you should definitely turn up and ask

00:00:16,470 --> 00:00:21,920
ask for one more take one if I'm not

00:00:19,140 --> 00:00:25,260
there so this presentation is about

00:00:21,920 --> 00:00:27,269
modern network servers and with network

00:00:25,260 --> 00:00:30,900
servers I mean things that you would run

00:00:27,269 --> 00:00:32,669
inside your network providing network

00:00:30,900 --> 00:00:34,620
services as opposed to application

00:00:32,669 --> 00:00:37,140
services so I'm not necessarily talking

00:00:34,620 --> 00:00:39,870
about web servers but things like

00:00:37,140 --> 00:00:41,610
authentication services or this

00:00:39,870 --> 00:00:46,170
particular presentation goes into DNS

00:00:41,610 --> 00:00:49,260
services and how you would run those on

00:00:46,170 --> 00:00:51,570
arm 64 rather than running them on AMD

00:00:49,260 --> 00:00:52,770
64 and you know why you would want to do

00:00:51,570 --> 00:00:55,680
this

00:00:52,770 --> 00:00:58,260
so I originally wrote this presentation

00:00:55,680 --> 00:01:01,289
for network operator groups so I picked

00:00:58,260 --> 00:01:04,860
DNS as an example and I got some numbers

00:01:01,289 --> 00:01:06,119
from the DK host master when I say I of

00:01:04,860 --> 00:01:08,640
course I stole these numbers from

00:01:06,119 --> 00:01:13,460
someone else who got the numbers from DK

00:01:08,640 --> 00:01:17,520
host master DK host master runs the DK

00:01:13,460 --> 00:01:22,740
ccTLD and Denmark is a smallish European

00:01:17,520 --> 00:01:24,689
country they have the ccTLD zone gets a

00:01:22,740 --> 00:01:27,509
reasonable amount of traffic and I think

00:01:24,689 --> 00:01:33,990
it's a representative example top-level

00:01:27,509 --> 00:01:36,780
domain DNS sort of set up so as of

00:01:33,990 --> 00:01:39,630
December 2016 so about a year and a bit

00:01:36,780 --> 00:01:43,920
ago nearly a year and a half ago the

00:01:39,630 --> 00:01:45,630
traffic on the dot DK DNS servers was

00:01:43,920 --> 00:01:48,479
about a thousand queries per second so

00:01:45,630 --> 00:01:52,380
compared to say the roots or comb or

00:01:48,479 --> 00:01:54,720
other larger DNS domains this is pretty

00:01:52,380 --> 00:01:57,810
much a rounding error

00:01:54,720 --> 00:02:02,040
there's about 1.3 million dot DK domains

00:01:57,810 --> 00:02:06,000
in the DK zone 11,000 of them are signs

00:02:02,040 --> 00:02:08,910
which is actually you know we wouldn't

00:02:06,000 --> 00:02:11,310
be sad state of the NSTIC deployment in

00:02:08,910 --> 00:02:13,300
the world and the main effects all these

00:02:11,310 --> 00:02:15,370
presentations are show later is the

00:02:13,300 --> 00:02:19,300
the DNS SEC signatures do increase the

00:02:15,370 --> 00:02:21,190
zone file quite a bit which I'll talk a

00:02:19,300 --> 00:02:23,020
bit later about what that effects the

00:02:21,190 --> 00:02:25,810
zone file size is about a hundred and

00:02:23,020 --> 00:02:28,840
ninety megabytes in total which you know

00:02:25,810 --> 00:02:31,420
1.3 million domain names most domain

00:02:28,840 --> 00:02:34,150
names will just have one or two NS

00:02:31,420 --> 00:02:36,910
records and maybe igloo records but

00:02:34,150 --> 00:02:38,920
filled was owned by 190 megabytes text

00:02:36,910 --> 00:02:42,070
that's because all of these eleven

00:02:38,920 --> 00:02:43,930
thousand students have have D s records

00:02:42,070 --> 00:02:46,390
as well and that sort of blows up their

00:02:43,930 --> 00:02:49,570
own file size but not a big problem

00:02:46,390 --> 00:02:52,350
so depending on the name server they do

00:02:49,570 --> 00:02:56,770
zone files at 190 megabytes of text

00:02:52,350 --> 00:02:59,280
expands to about a gigabyte of space in

00:02:56,770 --> 00:02:59,280
memory yes

00:03:00,480 --> 00:03:06,569
sighs 15 seconds

00:03:04,290 --> 00:03:12,780
yes but do I have it on the slides

00:03:06,569 --> 00:03:16,620
no but I would guess off the top of my

00:03:12,780 --> 00:03:19,290
head I would say about 30% of their 190

00:03:16,620 --> 00:03:21,269
megabytes is probably did the hashes

00:03:19,290 --> 00:03:24,450
because you have two hashes and they're

00:03:21,269 --> 00:03:26,879
fairly large lengths so I'd say about

00:03:24,450 --> 00:03:28,739
30% but don't shoot me if that's wrong I

00:03:26,879 --> 00:03:31,859
can I can calculate the numbers later on

00:03:28,739 --> 00:03:33,269
I would say 30% but depending on the

00:03:31,859 --> 00:03:35,340
name server it expands to about a

00:03:33,269 --> 00:03:37,739
gigabytes and rams when you load the

00:03:35,340 --> 00:03:39,900
zone file the DNS server is going to you

00:03:37,739 --> 00:03:42,150
know put it in a format that makes sense

00:03:39,900 --> 00:03:43,620
to the DNS server rather than to the

00:03:42,150 --> 00:03:45,299
author of the zone file so about a

00:03:43,620 --> 00:03:47,099
gigabyte in RAM which again is not a

00:03:45,299 --> 00:03:50,010
very large number but it's something to

00:03:47,099 --> 00:03:52,379
take into account the CPU loads of these

00:03:50,010 --> 00:03:55,440
DNS servers is approximately zero so

00:03:52,379 --> 00:03:57,299
when the zone is loaded to load the 190

00:03:55,440 --> 00:03:58,409
megabytes expand it and do all the funny

00:03:57,299 --> 00:04:00,930
things with it

00:03:58,409 --> 00:04:03,629
it gets a little bit of loads but after

00:04:00,930 --> 00:04:07,160
run time the CPU load is approximately 0

00:04:03,629 --> 00:04:09,389
the CPUs are not doing much work and

00:04:07,160 --> 00:04:10,739
these the other servers have about 10

00:04:09,389 --> 00:04:13,260
megabits per second of continuous

00:04:10,739 --> 00:04:16,639
traffic so not a huge amount of traffic

00:04:13,260 --> 00:04:19,949
right if you have a web server or any

00:04:16,639 --> 00:04:22,440
any application service 10 megabits of

00:04:19,949 --> 00:04:26,400
traffic is not is not a lot it's just

00:04:22,440 --> 00:04:30,360
it's a rounding error so what do the DK

00:04:26,400 --> 00:04:32,550
people run they have for unicast servers

00:04:30,360 --> 00:04:35,760
I think three of them are inside Denmark

00:04:32,550 --> 00:04:38,460
and one of them is somewhere else they

00:04:35,760 --> 00:04:40,710
have seven anycast clouds but don't talk

00:04:38,460 --> 00:04:43,710
about any cost too much but DNS is a UDP

00:04:40,710 --> 00:04:46,409
services very easy to anycast that they

00:04:43,710 --> 00:04:48,380
have seven clouds and in total about 120

00:04:46,409 --> 00:04:50,720
nodes so across this entire

00:04:48,380 --> 00:04:53,789
infrastructure which runs completely

00:04:50,720 --> 00:04:56,400
off-the-shelf Intel servers with FreeBSD

00:04:53,789 --> 00:04:58,650
they see a resource utilization of about

00:04:56,400 --> 00:05:01,380
two to five percents so that's all

00:04:58,650 --> 00:05:03,210
resources like memory and CPUs over this

00:05:01,380 --> 00:05:05,130
entire infrastructure is about two to

00:05:03,210 --> 00:05:07,110
five percents so what these machines are

00:05:05,130 --> 00:05:09,150
doing is mostly heating up the buildings

00:05:07,110 --> 00:05:12,990
they're standing in they're not they're

00:05:09,150 --> 00:05:14,610
not really doing a lot of work so let's

00:05:12,990 --> 00:05:18,320
talk about you know network servers what

00:05:14,610 --> 00:05:18,320
what do they need to do yeah

00:05:19,150 --> 00:05:25,100
they are using a mix they're using a mix

00:05:22,759 --> 00:05:26,930
of bind and sv and I think also knots

00:05:25,100 --> 00:05:27,740
actually I know for a fact that they

00:05:26,930 --> 00:05:30,199
also use knots

00:05:27,740 --> 00:05:32,600
so it's only the decay zone is only

00:05:30,199 --> 00:05:35,240
authoritative so they don't run any

00:05:32,600 --> 00:05:38,509
unbound and I don't think they run power

00:05:35,240 --> 00:05:44,810
DNS I don't know I could ask but I do it

00:05:38,509 --> 00:05:46,669
now but NSD so when it comes to network

00:05:44,810 --> 00:05:50,270
servers the resources they care about in

00:05:46,669 --> 00:05:51,860
order is CPU so especially in the case

00:05:50,270 --> 00:05:53,300
of DNS you have a lot of really trivial

00:05:51,860 --> 00:05:55,970
operations running in parallel

00:05:53,300 --> 00:05:57,199
there's no long-running compute tasks

00:05:55,970 --> 00:05:59,210
there's nothing to encrypt there's

00:05:57,199 --> 00:06:01,430
nothing to decrypt nothing to calculate

00:05:59,210 --> 00:06:02,930
it's just here's a record just said

00:06:01,430 --> 00:06:05,720
stick it in a buffer send it out on the

00:06:02,930 --> 00:06:07,190
wire done this TPU just needs to do all

00:06:05,720 --> 00:06:10,220
the lots of things and do it all at the

00:06:07,190 --> 00:06:11,690
same time memory and bus bandwidth is

00:06:10,220 --> 00:06:13,220
important you want you don't want to

00:06:11,690 --> 00:06:16,130
fetch these things from the disk because

00:06:13,220 --> 00:06:18,020
that takes time and these all of this

00:06:16,130 --> 00:06:19,610
information somehow needs to gets into

00:06:18,020 --> 00:06:21,289
the network as quickly as possible so

00:06:19,610 --> 00:06:23,630
the bus bandwidth and the memory

00:06:21,289 --> 00:06:25,430
bandwidth are important the network is

00:06:23,630 --> 00:06:27,080
obviously important but you know again

00:06:25,430 --> 00:06:28,880
at the NS server 10 megabits traffic in

00:06:27,080 --> 00:06:30,770
the network is not hugely important and

00:06:28,880 --> 00:06:32,949
then finally the least important of

00:06:30,770 --> 00:06:35,570
everything at all as disk i/o in the

00:06:32,949 --> 00:06:38,000
under ideal circumstances a DNS server

00:06:35,570 --> 00:06:39,949
will hit the disk exactly once when it

00:06:38,000 --> 00:06:42,080
boots and then it just doesn't hit the

00:06:39,949 --> 00:06:45,139
disk again disk i/o is just not

00:06:42,080 --> 00:06:46,849
interesting for network servers CPUs are

00:06:45,139 --> 00:06:48,830
important bus bandwidth and memory is

00:06:46,849 --> 00:06:51,889
importance network is important and the

00:06:48,830 --> 00:06:54,349
disk is just very unimportant so

00:06:51,889 --> 00:06:57,530
historically they've been a cup full of

00:06:54,349 --> 00:07:02,570
power and high bandwidth CPUs Sun tried

00:06:57,530 --> 00:07:04,940
the t1 processor which died in a fire it

00:07:02,570 --> 00:07:07,039
just never got off the ground caveum has

00:07:04,940 --> 00:07:09,560
a moderately successful mips

00:07:07,039 --> 00:07:13,240
implementation the acciÃ³n it's used by

00:07:09,560 --> 00:07:16,340
companies like ubiquity on routers

00:07:13,240 --> 00:07:18,820
mostly residential sort of setups but

00:07:16,340 --> 00:07:21,500
they have some larger machines as well

00:07:18,820 --> 00:07:24,320
then there have been things like Solera

00:07:21,500 --> 00:07:25,909
quanta they've now eventually ended up

00:07:24,320 --> 00:07:28,810
with Mellanox who make 10 gigabits

00:07:25,909 --> 00:07:30,590
easier adapters but their CPU just

00:07:28,810 --> 00:07:32,960
descended into

00:07:30,590 --> 00:07:37,820
lovins after a while in felt right the

00:07:32,960 --> 00:07:41,630
atom CPU yeah that was a nice try

00:07:37,820 --> 00:07:43,910
finally the arm 32-bit ARM arm v7 is

00:07:41,630 --> 00:07:46,120
very popular it's in every phone or well

00:07:43,910 --> 00:07:48,080
every phone as of a couple of years ago

00:07:46,120 --> 00:07:51,290
but the architecture I want to talk

00:07:48,080 --> 00:07:53,510
about is our 64 which is a new or newish

00:07:51,290 --> 00:07:56,060
attempt at a server grade architecture

00:07:53,510 --> 00:07:57,560
so arm 64 is widely known as the

00:07:56,060 --> 00:08:02,090
embedded architecture which lives in

00:07:57,560 --> 00:08:04,070
your own in your tablets it's just you

00:08:02,090 --> 00:08:05,360
know it's the CPU in your pockets but it

00:08:04,070 --> 00:08:08,330
doesn't have to live in your pocket it

00:08:05,360 --> 00:08:10,280
can also live on servers and there are a

00:08:08,330 --> 00:08:12,980
couple of nice things about arm 64 on

00:08:10,280 --> 00:08:15,110
servers which is it's the same

00:08:12,980 --> 00:08:18,080
instruction set architecture as the arm

00:08:15,110 --> 00:08:20,950
64 in your phone but the way it's laid

00:08:18,080 --> 00:08:25,640
out on a boards and it's companionships

00:08:20,950 --> 00:08:27,080
is a bit different on servers so the rv8

00:08:25,640 --> 00:08:29,140
is the same as your phone it's 64 bit

00:08:27,080 --> 00:08:32,570
instruction sets that that's the same

00:08:29,140 --> 00:08:33,850
it's also the server implementations

00:08:32,570 --> 00:08:37,940
that are 64

00:08:33,850 --> 00:08:40,490
gen which are very similar to intel's

00:08:37,940 --> 00:08:42,590
aes native instructions which you find

00:08:40,490 --> 00:08:44,330
on your Intel CPUs and on FreeBSD you

00:08:42,590 --> 00:08:48,920
get pretty similar performance on them

00:08:44,330 --> 00:08:51,620
as well um arm 64 servers you find the

00:08:48,920 --> 00:08:53,900
same standardized on core peripherals

00:08:51,620 --> 00:08:56,810
like you would find on an Intel CPU so

00:08:53,900 --> 00:08:57,920
you'll have things like msi message fast

00:08:56,810 --> 00:09:00,020
interrupts you'll have a timer

00:08:57,920 --> 00:09:01,580
interrupts will have an iommu so all

00:09:00,020 --> 00:09:04,640
those things which are familiar from the

00:09:01,580 --> 00:09:10,370
Intel world also exists on the AMC 64

00:09:04,640 --> 00:09:12,950
world and for one reason or another the

00:09:10,370 --> 00:09:16,100
arm 64 server world also went for a CPI

00:09:12,950 --> 00:09:18,470
and UEFI on the firmware level so that

00:09:16,100 --> 00:09:20,510
all of this is familiar to platform

00:09:18,470 --> 00:09:23,210
builders on Intel all of this knowledge

00:09:20,510 --> 00:09:25,400
can be reused on arm 64 so if you have

00:09:23,210 --> 00:09:27,800
an arm 64 server boards it will also

00:09:25,400 --> 00:09:30,380
have a CPI which can tell you about the

00:09:27,800 --> 00:09:32,270
hardware configuration and bus

00:09:30,380 --> 00:09:34,430
topologies and things and you'll have

00:09:32,270 --> 00:09:36,530
the UEFI firmware which allows you to

00:09:34,430 --> 00:09:39,550
bring up your operating system and

00:09:36,530 --> 00:09:43,930
fermer blocks into various peripherals

00:09:39,550 --> 00:09:46,130
and finally all of the standards

00:09:43,930 --> 00:09:49,130
peripheral buses which are familiar from

00:09:46,130 --> 00:09:51,290
Intel also just work on arm 64 so you if

00:09:49,130 --> 00:09:53,270
you have a PCI Express Network heart

00:09:51,290 --> 00:09:55,730
that works on your Intel server you plug

00:09:53,270 --> 00:09:58,370
it into an PCI Express slots on your arm

00:09:55,730 --> 00:10:01,120
64 server it will work the same so all

00:09:58,370 --> 00:10:05,030
of the all of these buses are just there

00:10:01,120 --> 00:10:08,210
I found a couple of commercial

00:10:05,030 --> 00:10:10,340
off-the-shelf arm 64 server boards

00:10:08,210 --> 00:10:13,070
there's a cafe on thunder X the

00:10:10,340 --> 00:10:14,630
previously testing cluster has a couple

00:10:13,070 --> 00:10:17,390
of these sitting there the basic

00:10:14,630 --> 00:10:19,550
implementation has 48 cores and you can

00:10:17,390 --> 00:10:21,470
have 96 course that's a little bit more

00:10:19,550 --> 00:10:25,460
cores than you would find in a

00:10:21,470 --> 00:10:27,470
traditional Intel server it's got 16 PCI

00:10:25,460 --> 00:10:29,900
Express with three lanes so it's got

00:10:27,470 --> 00:10:33,410
pretty pretty good sort of bandwidth to

00:10:29,900 --> 00:10:35,450
to the the external world and you can

00:10:33,410 --> 00:10:38,060
get it with 40 gig or 10 gig Ethernet

00:10:35,450 --> 00:10:39,500
cards and a board like this will set you

00:10:38,060 --> 00:10:42,560
back by $3,000

00:10:39,500 --> 00:10:44,750
so if you are running ccTLD or you're

00:10:42,560 --> 00:10:46,700
running any sort of other network

00:10:44,750 --> 00:10:48,770
service about $3,000 for a server is

00:10:46,700 --> 00:10:51,410
pretty much what you expect to pay you

00:10:48,770 --> 00:10:53,060
know depending on how many servers you

00:10:51,410 --> 00:10:55,370
have or how big you are domain is

00:10:53,060 --> 00:10:56,810
anywhere between 3,000 and 10,000 is

00:10:55,370 --> 00:10:58,630
what you would expect to pay for a

00:10:56,810 --> 00:11:01,490
server so this you know if I were

00:10:58,630 --> 00:11:05,540
operating a ccTLD I would go out and buy

00:11:01,490 --> 00:11:10,430
one of these no problem a competing

00:11:05,540 --> 00:11:14,420
product is a an AMD design which has the

00:11:10,430 --> 00:11:16,730
cortex 857 it's also an arm 64 CPU it's

00:11:14,420 --> 00:11:21,110
a lot cheaper so for $600 you can get a

00:11:16,730 --> 00:11:23,570
4 core device with you know 8 gigabytes

00:11:21,110 --> 00:11:26,330
of memory so the Internet's you know

00:11:23,570 --> 00:11:28,670
some USB stuff so the price goes a lot

00:11:26,330 --> 00:11:29,930
lower and between these two there's a

00:11:28,670 --> 00:11:32,180
whole spectrum earthing so on the high

00:11:29,930 --> 00:11:34,130
end you have the 96 core monsters with

00:11:32,180 --> 00:11:35,960
all the memory in the world and on the

00:11:34,130 --> 00:11:39,260
lower and you've got you know 4 cores

00:11:35,960 --> 00:11:41,420
with a little little bit of memory so

00:11:39,260 --> 00:11:44,060
let's look at operating system support

00:11:41,420 --> 00:11:46,390
for a moment on previously armed 64 is

00:11:44,060 --> 00:11:50,329
fully supported platform so you have

00:11:46,390 --> 00:11:52,220
binary updates like FreeBSD update

00:11:50,329 --> 00:11:55,790
and package are completely supported

00:11:52,220 --> 00:11:58,009
just as they are on Intel they're also

00:11:55,790 --> 00:11:59,629
fully supported by the security officer

00:11:58,009 --> 00:12:02,269
and the release engineering team so

00:11:59,629 --> 00:12:05,989
whenever bugs happen they get fixed

00:12:02,269 --> 00:12:07,939
pretty quickly and you know all these

00:12:05,989 --> 00:12:10,249
have some third party packages that work

00:12:07,939 --> 00:12:13,999
on Intel will usually just work on AMD

00:12:10,249 --> 00:12:16,879
64 in the arm 64 I keep saying up I'm 64

00:12:13,999 --> 00:12:18,920
as well so you can just replace your AMD

00:12:16,879 --> 00:12:21,679
64 machine with an arm 64 machine

00:12:18,920 --> 00:12:23,689
without any problem and in particular so

00:12:21,679 --> 00:12:27,110
for this presentation I looked at DNS so

00:12:23,689 --> 00:12:29,779
the are 64 platform packages are

00:12:27,110 --> 00:12:31,759
completely supported by binds and is the

00:12:29,779 --> 00:12:34,819
North Power DNS so you can just go and

00:12:31,759 --> 00:12:37,489
package install NSD on an arm 64 server

00:12:34,819 --> 00:12:42,410
and it will just work out of box without

00:12:37,489 --> 00:12:45,379
any any sort of difficulty so run some

00:12:42,410 --> 00:12:48,709
performance comparisons on a completely

00:12:45,379 --> 00:12:52,009
fictional workload so I took at Intel

00:12:48,709 --> 00:12:54,259
Xeon I think that for Generation it was

00:12:52,009 --> 00:12:59,660
but I have 10 cores with hyper-threading

00:12:54,259 --> 00:13:00,699
so 20 cores in turtle 128 gigabytes of

00:12:59,660 --> 00:13:04,459
RAM

00:13:00,699 --> 00:13:09,139
you know an SSD which was what we fast

00:13:04,459 --> 00:13:12,290
this board cost him right and I ran it

00:13:09,139 --> 00:13:14,419
against the Thunder X with one socket to

00:13:12,290 --> 00:13:17,029
forty eight cores same amount of memory

00:13:14,419 --> 00:13:20,209
and spinning rust so similar sort of

00:13:17,029 --> 00:13:21,589
priced hardware and run MLV implying

00:13:20,209 --> 00:13:23,899
build so clang is a terrible terrible

00:13:21,589 --> 00:13:26,480
workload to throw at something and the

00:13:23,899 --> 00:13:29,419
thunder x spent forever on it

00:13:26,480 --> 00:13:33,230
so it's under X 32 minutes of wall time

00:13:29,419 --> 00:13:35,119
or 20 hours of CPU time building LLVM so

00:13:33,230 --> 00:13:38,119
the arm 64 you have lots of lots of

00:13:35,119 --> 00:13:40,999
cores but they're not very fast the

00:13:38,119 --> 00:13:42,799
Intel CPU managed to get the same

00:13:40,999 --> 00:13:45,110
workload done in 10 minutes and 1 hour

00:13:42,799 --> 00:13:49,790
of CPU time so it's went 20 times faster

00:13:45,110 --> 00:13:51,230
you say workload right so this is the

00:13:49,790 --> 00:13:52,069
error server spent very little of their

00:13:51,230 --> 00:13:54,199
time compiling

00:13:52,069 --> 00:13:56,360
so the LLVM workload is lots of

00:13:54,199 --> 00:13:58,939
continuous disk IO as I said at the

00:13:56,360 --> 00:14:00,649
beginning of my presentation under ideal

00:13:58,939 --> 00:14:01,340
circumstances at the NS server is just

00:14:00,649 --> 00:14:03,110
never

00:14:01,340 --> 00:14:05,000
hit the desk it's going to boot from the

00:14:03,110 --> 00:14:06,860
disk it's going to load the zone file

00:14:05,000 --> 00:14:09,500
and then it will never touch the disk

00:14:06,860 --> 00:14:11,990
again even as the zone updates you know

00:14:09,500 --> 00:14:13,850
new records will come in but under ideal

00:14:11,990 --> 00:14:16,220
circumstances in the steady state the

00:14:13,850 --> 00:14:18,320
disk is just never going to be hit most

00:14:16,220 --> 00:14:20,690
of the yellow VM time is just loading

00:14:18,320 --> 00:14:22,460
the millions of C++ files from the disk

00:14:20,690 --> 00:14:23,900
and compiling them and writing them back

00:14:22,460 --> 00:14:27,680
to the disk and then loading the back

00:14:23,900 --> 00:14:30,260
again the LLVM build has a gigantic

00:14:27,680 --> 00:14:32,090
memory footprint and a lot of churn so

00:14:30,260 --> 00:14:34,490
things coming in and out of memory all

00:14:32,090 --> 00:14:37,400
the time in different shapes and forms

00:14:34,490 --> 00:14:39,770
especially the linker and the CPU load

00:14:37,400 --> 00:14:41,900
only will slightly parallelized so the

00:14:39,770 --> 00:14:45,020
compiler you're compiling lots and lots

00:14:41,900 --> 00:14:46,970
of little CP C++ files but you're not

00:14:45,020 --> 00:14:48,710
really exercising a lot of parallelism

00:14:46,970 --> 00:14:50,960
because you're always going to be

00:14:48,710 --> 00:14:52,970
hitting the disk so your your your

00:14:50,960 --> 00:14:55,520
opportunities for paralyzing your loads

00:14:52,970 --> 00:14:56,840
are going to be very much limited by how

00:14:55,520 --> 00:14:58,730
quickly you can fetch things from the

00:14:56,840 --> 00:15:01,100
disk yet if the disk is slow you're just

00:14:58,730 --> 00:15:03,440
going nowhere the NS on the other hand

00:15:01,100 --> 00:15:05,060
has a tiny bit of disk i/o when loading

00:15:03,440 --> 00:15:05,990
the zone file and after that nothing at

00:15:05,060 --> 00:15:08,360
all

00:15:05,990 --> 00:15:10,550
your entire were working data set will

00:15:08,360 --> 00:15:12,440
fit comfortably in memory so this

00:15:10,550 --> 00:15:14,780
machine has a hundred and twenty eight

00:15:12,440 --> 00:15:17,030
gigabytes of memory the zone file is one

00:15:14,780 --> 00:15:18,860
gigabyte of memory I can fit 128

00:15:17,030 --> 00:15:20,390
denmark's into memory

00:15:18,860 --> 00:15:23,840
you know : hundred and twenty seven

00:15:20,390 --> 00:15:25,430
gigabytes of Denmark in or 127 Denmark's

00:15:23,840 --> 00:15:27,230
with you know overheads of operating

00:15:25,430 --> 00:15:30,920
system but still it fits very

00:15:27,230 --> 00:15:33,320
comfortably in memory and most

00:15:30,920 --> 00:15:35,700
importantly it is very easy to paralyze

00:15:33,320 --> 00:15:38,730
DNS queries yes

00:15:35,700 --> 00:15:41,580
I noticed that the artist post-award has

00:15:38,730 --> 00:15:49,450
a testimony by the fans

00:15:41,580 --> 00:15:52,360
right yes sure but it would not it would

00:15:49,450 --> 00:15:54,600
not change a lot the it would probably

00:15:52,360 --> 00:15:58,330
turn it from 20 hours into 18 hours

00:15:54,600 --> 00:16:02,680
because the contention is mostly on not

00:15:58,330 --> 00:16:05,260
using all the course because the the way

00:16:02,680 --> 00:16:07,450
Lang is constructed is it's lots of

00:16:05,260 --> 00:16:09,520
little C++ files that are linked into

00:16:07,450 --> 00:16:11,230
smaller object files and then all of

00:16:09,520 --> 00:16:13,180
these are linked together and then

00:16:11,230 --> 00:16:14,680
finally you get the last stage the

00:16:13,180 --> 00:16:17,529
linking stage which is where it spends

00:16:14,680 --> 00:16:19,990
most of its time the linker runs most

00:16:17,529 --> 00:16:23,290
well it runs on a couple of course but

00:16:19,990 --> 00:16:25,240
the linker runs on very few cores

00:16:23,290 --> 00:16:27,339
because there's very little for the

00:16:25,240 --> 00:16:29,110
course to do it needs to resolve some

00:16:27,339 --> 00:16:31,060
symbols but then it gets stuck waiting

00:16:29,110 --> 00:16:33,370
for something else so you can't really

00:16:31,060 --> 00:16:35,380
you you can't you can paralyze the

00:16:33,370 --> 00:16:38,560
compilation but the linking it'll just

00:16:35,380 --> 00:16:41,200
stop there so in that benchmark I did

00:16:38,560 --> 00:16:42,910
which was very unscientific the spinning

00:16:41,200 --> 00:16:46,000
rusts definitely contributed to the

00:16:42,910 --> 00:16:47,829
slowness but the the major portion of

00:16:46,000 --> 00:16:49,420
the slowness was just not being able to

00:16:47,829 --> 00:16:51,220
paralyze the workload because you're

00:16:49,420 --> 00:16:54,209
just sitting there and not have things

00:16:51,220 --> 00:16:57,010
to do in parallel whereas a DNS server

00:16:54,209 --> 00:16:59,020
all of us to do is fetch the records

00:16:57,010 --> 00:17:00,820
stick it in a network buffer and send it

00:16:59,020 --> 00:17:03,010
out and not even that so it just has to

00:17:00,820 --> 00:17:04,839
copy the answer into a record that's

00:17:03,010 --> 00:17:07,270
already there so all of this can be

00:17:04,839 --> 00:17:11,170
trivially done on many many CPUs at the

00:17:07,270 --> 00:17:15,520
same time so that's yeah that's on the

00:17:11,170 --> 00:17:18,069
load side of things but look at so Intel

00:17:15,520 --> 00:17:19,870
servers run very very warm so the AHA's

00:17:18,069 --> 00:17:23,290
well which is the last one I looked at

00:17:19,870 --> 00:17:26,709
in any sort of detail specifies 135

00:17:23,290 --> 00:17:28,360
watts thermal dissipation idle so just

00:17:26,709 --> 00:17:30,309
sitting in your you just put it in your

00:17:28,360 --> 00:17:33,880
rack and it's warming up the room

00:17:30,309 --> 00:17:37,480
with 135 watts doing nothing under loads

00:17:33,880 --> 00:17:40,300
there's 250 watts being produced by the

00:17:37,480 --> 00:17:43,059
CPU that's a lot of power and that's one

00:17:40,300 --> 00:17:44,770
CPU at the same time you've also got the

00:17:43,059 --> 00:17:46,000
the platform you've got the spinning

00:17:44,770 --> 00:17:48,510
rust you've got everything else sitting

00:17:46,000 --> 00:17:49,929
there but 250 watts just for your CPU

00:17:48,510 --> 00:17:52,929
warming up the room

00:17:49,929 --> 00:17:53,900
in some countries cooling a data center

00:17:52,929 --> 00:17:56,390
is a matter of opening to

00:17:53,900 --> 00:18:00,080
no in summer and opening two windows in

00:17:56,390 --> 00:18:01,490
winter in places like Singapore cooling

00:18:00,080 --> 00:18:03,890
your data center is a little bit more

00:18:01,490 --> 00:18:05,450
involved than that so if you've got a

00:18:03,890 --> 00:18:08,150
few hundred fifty what's just sitting or

00:18:05,450 --> 00:18:08,690
130 watts just sitting there doing

00:18:08,150 --> 00:18:10,640
nothing

00:18:08,690 --> 00:18:13,280
that's quite a lot of power to dissipate

00:18:10,640 --> 00:18:15,020
if you look at the arm 64 on the other

00:18:13,280 --> 00:18:18,110
hand so this is the Thunder the Thunder

00:18:15,020 --> 00:18:21,920
X it's 120 watts so that's already quite

00:18:18,110 --> 00:18:23,960
a bit less and under loads it's it's 50

00:18:21,920 --> 00:18:26,330
watts less dissipation and this is a

00:18:23,960 --> 00:18:29,960
huge this is a massively over spec

00:18:26,330 --> 00:18:33,560
machine for DNS you can run probably on

00:18:29,960 --> 00:18:36,440
a machine with 20 cores you can run the

00:18:33,560 --> 00:18:38,060
DNS as effectively so this is just a

00:18:36,440 --> 00:18:39,590
machine I had available it's 200 watts

00:18:38,060 --> 00:18:42,650
on there loads it's already 50 Watts

00:18:39,590 --> 00:18:44,810
less with 4 cores that's you know that's

00:18:42,650 --> 00:18:47,020
not even opening a window in that's not

00:18:44,810 --> 00:18:49,370
even opening the extra window in winter

00:18:47,020 --> 00:18:53,360
so several vendors have much lower power

00:18:49,370 --> 00:18:57,710
CPUs you also need cooling then you do

00:18:53,360 --> 00:18:59,660
with Intel servers so so that's worth

00:18:57,710 --> 00:19:02,210
considering so on one hand you've got

00:18:59,660 --> 00:19:04,010
your server you're spending money on

00:19:02,210 --> 00:19:06,110
hardware that's actually doing something

00:19:04,010 --> 00:19:10,010
on the other hand you're saving money on

00:19:06,110 --> 00:19:11,330
cooling and then well I had a slight

00:19:10,010 --> 00:19:13,940
digression on security which I'm not

00:19:11,330 --> 00:19:16,160
going to go into in this talk I added

00:19:13,940 --> 00:19:17,600
that for another conference so the

00:19:16,160 --> 00:19:21,740
conclusions to take away from this talk

00:19:17,600 --> 00:19:23,750
is that arm 64 is a very viable platform

00:19:21,740 --> 00:19:26,330
for cert 4 network server workloads so I

00:19:23,750 --> 00:19:28,520
die depending on what your web server is

00:19:26,330 --> 00:19:30,740
doing it is probably not going to be

00:19:28,520 --> 00:19:32,360
very useful for a web server because web

00:19:30,740 --> 00:19:35,330
servers do quite a bit of non-trivial

00:19:32,360 --> 00:19:39,200
calculations building pages and sending

00:19:35,330 --> 00:19:41,270
them out but if your network service has

00:19:39,200 --> 00:19:43,850
a fairly trivial workload which is easy

00:19:41,270 --> 00:19:46,760
to parallelize arm 64 is definitely a

00:19:43,850 --> 00:19:48,080
better architecture than Intel so you'll

00:19:46,760 --> 00:19:50,540
have a machine which is still going to

00:19:48,080 --> 00:19:53,150
be expensive but it's actually going to

00:19:50,540 --> 00:19:55,460
work for its money and you're going to

00:19:53,150 --> 00:19:57,620
save a bit of money on cooling it so

00:19:55,460 --> 00:20:00,860
definitely consider arm 64 for your next

00:19:57,620 --> 00:20:03,470
DNS server also FreeBSD is very well

00:20:00,860 --> 00:20:06,380
supported on arm 64 so you get all the

00:20:03,470 --> 00:20:07,260
goodness of pre BSD on an architecture

00:20:06,380 --> 00:20:09,810
which works

00:20:07,260 --> 00:20:11,430
really well for you and that is the end

00:20:09,810 --> 00:20:14,880
of this presentation does anyone have

00:20:11,430 --> 00:20:16,820
any questions I could show it yes so

00:20:14,880 --> 00:20:22,230
when I gave this presentation at

00:20:16,820 --> 00:20:26,640
apricots earlier this year about you

00:20:22,230 --> 00:20:28,860
know is is armed 64 easier to secure of

00:20:26,640 --> 00:20:30,990
an Intel and we have you know 10 minutes

00:20:28,860 --> 00:20:33,810
of a lightning talk disguised as a

00:20:30,990 --> 00:20:36,750
question as these things are known in in

00:20:33,810 --> 00:20:39,630
that community about what this meltdown

00:20:36,750 --> 00:20:41,910
inspector vulnerability are so it's

00:20:39,630 --> 00:20:44,490
probably the other huge concern on DNS

00:20:41,910 --> 00:20:47,280
server so yes arm 64 is also vulnerable

00:20:44,490 --> 00:20:49,310
to speculative execution vulnerabilities

00:20:47,280 --> 00:20:52,110
so arm 64 is also an out-of-order

00:20:49,310 --> 00:20:55,380
architecture arm 64 is equally

00:20:52,110 --> 00:20:56,760
vulnerable as Intel to this stuff ending

00:20:55,380 --> 00:20:59,630
up in the cache for reasons nobody

00:20:56,760 --> 00:21:03,180
understands from privileged instructions

00:20:59,630 --> 00:21:05,640
run being speculatively executed in

00:21:03,180 --> 00:21:06,120
underprivileged modes yes they're

00:21:05,640 --> 00:21:07,680
vulnerable

00:21:06,120 --> 00:21:11,820
also they've been mitigated in the same

00:21:07,680 --> 00:21:13,410
way but all of the NS server it's really

00:21:11,820 --> 00:21:14,880
at least concerned so this is a concern

00:21:13,410 --> 00:21:18,080
if you've got something like a web

00:21:14,880 --> 00:21:21,360
server with mutually untrusting tenants

00:21:18,080 --> 00:21:23,130
running running on the same machine with

00:21:21,360 --> 00:21:26,160
the DNS server you're usually going to

00:21:23,130 --> 00:21:27,600
have one process running and that

00:21:26,160 --> 00:21:30,870
process is just serving public

00:21:27,600 --> 00:21:32,520
information so I didn't want that by

00:21:30,870 --> 00:21:33,710
aggression here but you know we've had

00:21:32,520 --> 00:21:38,360
it anyway

00:21:33,710 --> 00:21:38,360
any other questions yes

00:21:42,010 --> 00:21:46,090
I think the other way around DNS over

00:21:45,070 --> 00:21:48,670
HTTP

00:21:46,090 --> 00:21:52,120
so DNS over HTTP has been a thing for a

00:21:48,670 --> 00:21:53,680
little bit longer than recently I've not

00:21:52,120 --> 00:21:57,700
looked at it too closely well I've

00:21:53,680 --> 00:22:00,280
looked at I'm I'm on the DNS op IDF list

00:21:57,700 --> 00:22:02,260
I've not looked very closely at what it

00:22:00,280 --> 00:22:04,120
is they do but it should not be a huge

00:22:02,260 --> 00:22:05,860
problem because as far as I understand

00:22:04,120 --> 00:22:09,580
that they are just putting DNS packets

00:22:05,860 --> 00:22:12,130
into HTTP packets so they're probably

00:22:09,580 --> 00:22:15,880
almost as easy if not as easy to

00:22:12,130 --> 00:22:19,570
parallelize as DNS packets in their

00:22:15,880 --> 00:22:22,330
native formats either UDP or TCP the one

00:22:19,570 --> 00:22:26,290
thing which is probably different in DNS

00:22:22,330 --> 00:22:30,430
over HTTP versus DNS over over UDP or

00:22:26,290 --> 00:22:33,550
DNS over DNS let's say is that DNS over

00:22:30,430 --> 00:22:35,320
DNS can be very easily optimized because

00:22:33,550 --> 00:22:38,470
the response format is exactly the same

00:22:35,320 --> 00:22:41,440
as the query format so the DNS server

00:22:38,470 --> 00:22:43,780
can just keep the buffer in the last

00:22:41,440 --> 00:22:45,640
level cache and just adds the response

00:22:43,780 --> 00:22:48,970
and send that right back out whereas

00:22:45,640 --> 00:22:51,670
with HTTP even if I think they run HTTP

00:22:48,970 --> 00:22:53,530
over UDP as well but on TCP at least you

00:22:51,670 --> 00:22:55,480
have a lot more buffers in the way so

00:22:53,530 --> 00:22:57,520
you can't just go to this offsets write

00:22:55,480 --> 00:22:58,990
your reply and then send it out again

00:22:57,520 --> 00:23:02,820
because you have a lot more housekeeping

00:22:58,990 --> 00:23:02,820

YouTube URL: https://www.youtube.com/watch?v=HeKBZy2Je2o


