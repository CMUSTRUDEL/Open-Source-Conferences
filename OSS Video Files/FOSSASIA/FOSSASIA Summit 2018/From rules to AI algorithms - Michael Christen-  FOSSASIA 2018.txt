Title: From rules to AI algorithms - Michael Christen-  FOSSASIA 2018
Publication date: 2018-03-23
Playlist: FOSSASIA Summit 2018
Description: 
	Speaker: Michael Christen, Founder SUSI AI
Info: https://2018.fossasia.org/event/speakers.html#michael-christen3325

Artificial Intelligence in intelligent digital personal assistants are not simple chatbots. They are driven by the deduction rules of expert systems and the principle of machine learning. In this talk we learn how this technology is used in detail using the SUSI personal assistant framework. Rules - in the context of the conversational web now called ‚skills‘ - are implemented with the combination of a backtracking system combined with cloud access to external knowledge. We will learn how a expert system-based personal assistant works and why it can be very easy to write skills for such a system.

Room: Lecture Theatre
Track: Artificial Intelligence
Date: Friday, 23rd March, 2018

Event Page: http://2018.fossasia.org
Follow FOSSASIA on Twitter: https://twitter.com/fossasia/
Like FOSSASIA on Facebook: https://www.facebook.com/fossasia/

Produced by Engineers.SG
Captions: 
	00:00:00,000 --> 00:00:05,759
everyone um next is micaiah he's gonna

00:00:03,000 --> 00:00:07,290
talk about Susi and I'm gonna let him

00:00:05,759 --> 00:00:09,660
start I'm not gonna take any time we're

00:00:07,290 --> 00:00:17,130
kind of running a bit behind so everyone

00:00:09,660 --> 00:00:22,470
welcome me can hello the microphone work

00:00:17,130 --> 00:00:24,570
yes very good from roots to artificial

00:00:22,470 --> 00:00:28,380
intelligence algorithms this is of

00:00:24,570 --> 00:00:30,240
course about Judy and yesterday I

00:00:28,380 --> 00:00:34,079
introduced why we are doing this project

00:00:30,240 --> 00:00:38,910
and today I will get into details and

00:00:34,079 --> 00:00:45,090
explain how it works in in a very

00:00:38,910 --> 00:00:48,719
detailed way so some time ago 1986

00:00:45,090 --> 00:00:50,670
already people thought that computer in

00:00:48,719 --> 00:00:53,579
the future are something where you can

00:00:50,670 --> 00:00:57,539
talk to like Scotty in this Star Trek

00:00:53,579 --> 00:01:00,390
movie and this is a bit coming true now

00:00:57,539 --> 00:01:03,570
as we have seen yesterday in my

00:01:00,390 --> 00:01:06,930
presentation also Google starts to

00:01:03,570 --> 00:01:09,390
respond to complete sentences with

00:01:06,930 --> 00:01:11,520
complete answers directly without

00:01:09,390 --> 00:01:14,729
providing a link or they have links for

00:01:11,520 --> 00:01:18,000
the author of the answer like here also

00:01:14,729 --> 00:01:23,670
and my idea about search engines in the

00:01:18,000 --> 00:01:27,299
future is that what what should they do

00:01:23,670 --> 00:01:29,939
in the future and maybe an answer is

00:01:27,299 --> 00:01:32,909
that there simply uncertain - all kinds

00:01:29,939 --> 00:01:35,250
of questions so what's in what's inside

00:01:32,909 --> 00:01:37,650
the web is not that important anymore

00:01:35,250 --> 00:01:39,450
people are simply searching for answers

00:01:37,650 --> 00:01:45,540
and search engines of the future will

00:01:39,450 --> 00:01:47,729
just return these answers we created the

00:01:45,540 --> 00:01:50,040
lock lock project where we collected

00:01:47,729 --> 00:01:53,490
billions of tweets and we started to ask

00:01:50,040 --> 00:01:57,780
questions against this database like who

00:01:53,490 --> 00:02:00,659
tweeted most about for Asia yesterday so

00:01:57,780 --> 00:02:03,090
this is also kind of natural language

00:02:00,659 --> 00:02:06,180
question against a large database about

00:02:03,090 --> 00:02:10,110
social media and this is also something

00:02:06,180 --> 00:02:14,790
which should be answered in a in a

00:02:10,110 --> 00:02:19,530
natural language way and all the big

00:02:14,790 --> 00:02:22,290
companies Google Amazon Apple Microsoft

00:02:19,530 --> 00:02:24,630
are now inventing these machines which

00:02:22,290 --> 00:02:27,120
are doing exactly that these are the

00:02:24,630 --> 00:02:28,860
answers on detection what is the search

00:02:27,120 --> 00:02:30,720
engine of the future it's something

00:02:28,860 --> 00:02:33,510
where can simply talk to and it will

00:02:30,720 --> 00:02:36,270
give you any kind of answer so what we

00:02:33,510 --> 00:02:37,970
are doing the SUSE project is that we

00:02:36,270 --> 00:02:40,590
are creating a field open source

00:02:37,970 --> 00:02:43,800
personal assistant they call it

00:02:40,590 --> 00:02:46,800
sometimes it's not speaker but this is a

00:02:43,800 --> 00:02:50,840
very similar thing so this is the source

00:02:46,800 --> 00:02:54,120
version of it it's considered to be

00:02:50,840 --> 00:02:56,010
artificial intelligence object so if we

00:02:54,120 --> 00:02:58,140
want to do something like this then we

00:02:56,010 --> 00:02:59,850
need to explain or we need to understand

00:02:58,140 --> 00:03:04,760
what artificial intelligence actually

00:02:59,850 --> 00:03:08,670
means so people have opinions like you

00:03:04,760 --> 00:03:11,310
devices like that you can be smart they

00:03:08,670 --> 00:03:16,050
think work for you and maybe do

00:03:11,310 --> 00:03:19,200
unexpected things but we want to know it

00:03:16,050 --> 00:03:22,380
in detail so artificial intelligence has

00:03:19,200 --> 00:03:25,860
a definition and that it's that systems

00:03:22,380 --> 00:03:28,440
which think like humans or that think

00:03:25,860 --> 00:03:30,180
rationally are artificial intelligent

00:03:28,440 --> 00:03:35,489
systems maybe they act like humans or

00:03:30,180 --> 00:03:37,680
act rationally there is also the

00:03:35,489 --> 00:03:39,660
distinction between weak artificial

00:03:37,680 --> 00:03:42,680
intelligence and strong artificial

00:03:39,660 --> 00:03:45,630
intelligence there's a there's a big

00:03:42,680 --> 00:03:47,670
mixture of things so people think things

00:03:45,630 --> 00:03:50,730
are intelligent if they just act like

00:03:47,670 --> 00:03:54,120
humans but what it's actually built are

00:03:50,730 --> 00:03:56,190
very simple tools so they can do

00:03:54,120 --> 00:03:59,060
something which a human can do in a very

00:03:56,190 --> 00:04:03,150
special to specific specific field like

00:03:59,060 --> 00:04:04,920
recognizing objects or playing chess and

00:04:03,150 --> 00:04:07,320
so on it they're not general

00:04:04,920 --> 00:04:10,800
intelligence and this is the distinction

00:04:07,320 --> 00:04:12,900
as the strong AI says it's like like a

00:04:10,800 --> 00:04:15,870
human can think and act like a human and

00:04:12,900 --> 00:04:19,350
in the past it was also make such it was

00:04:15,870 --> 00:04:21,479
a mixture of the meaning that real

00:04:19,350 --> 00:04:23,250
intelligence only comes if you have a

00:04:21,479 --> 00:04:26,520
mind so this is a

00:04:23,250 --> 00:04:28,980
this it's it's not that a big discussion

00:04:26,520 --> 00:04:34,500
anymore about this and we can a I am

00:04:28,980 --> 00:04:39,120
means you have a specific tool so these

00:04:34,500 --> 00:04:41,510
are this is the toolbox of the things

00:04:39,120 --> 00:04:44,100
you can have in artificial intelligence

00:04:41,510 --> 00:04:46,860
heuristics and constraints search is

00:04:44,100 --> 00:04:50,280
something you know from your navigation

00:04:46,860 --> 00:04:52,860
system mystic search is something which

00:04:50,280 --> 00:04:56,970
is done to find the best connection to

00:04:52,860 --> 00:04:58,530
the between two points and this is a

00:04:56,970 --> 00:05:00,720
very normal thing it's artificial

00:04:58,530 --> 00:05:03,890
intelligence from the algorithm but it's

00:05:00,720 --> 00:05:06,600
a normal thing learning with

00:05:03,890 --> 00:05:11,720
reinforcement is something which is now

00:05:06,600 --> 00:05:16,860
done the neuron networks and it's very

00:05:11,720 --> 00:05:19,080
new field because it had be done already

00:05:16,860 --> 00:05:21,030
thirty and forty years ago but it wasn't

00:05:19,080 --> 00:05:23,150
very good and because of the computation

00:05:21,030 --> 00:05:26,970
power and Newcomb computation models

00:05:23,150 --> 00:05:29,120
they are no very strong then they are

00:05:26,970 --> 00:05:33,690
reasoning the knowledge and Lolich null

00:05:29,120 --> 00:05:35,150
knowledge and logic and uncertain

00:05:33,690 --> 00:05:37,620
knowledge with game playing and

00:05:35,150 --> 00:05:43,350
reasoning that knowledge and logic is

00:05:37,620 --> 00:05:46,380
where you have automatic proof systems

00:05:43,350 --> 00:05:48,960
which create something like expert

00:05:46,380 --> 00:05:51,870
systems they have a knowledge base and

00:05:48,960 --> 00:05:53,790
they have deduction routes and you can

00:05:51,870 --> 00:05:55,860
apply these things if you have a

00:05:53,790 --> 00:05:58,770
specific knowledge and you know you

00:05:55,860 --> 00:06:01,320
don't have uncertain things and certain

00:05:58,770 --> 00:06:04,169
knowledge is where you do game playing

00:06:01,320 --> 00:06:05,729
and twenty years ago this just here's

00:06:04,169 --> 00:06:07,860
the reasoning this was the strongest

00:06:05,729 --> 00:06:10,380
strongest fields in artificial

00:06:07,860 --> 00:06:14,250
intelligence from my perspective and

00:06:10,380 --> 00:06:18,740
this is a very interesting thing where

00:06:14,250 --> 00:06:21,690
we can also have a model for an an

00:06:18,740 --> 00:06:25,500
expert system which creates a personal

00:06:21,690 --> 00:06:27,960
assistant so other things you expect

00:06:25,500 --> 00:06:30,510
from artificial intelligent system is

00:06:27,960 --> 00:06:31,689
that it can do natural language

00:06:30,510 --> 00:06:35,169
processing the

00:06:31,689 --> 00:06:40,779
speech and speech-to-text then being

00:06:35,169 --> 00:06:43,149
able to compute a large number of data

00:06:40,779 --> 00:06:45,610
objects like with it in the lock lock

00:06:43,149 --> 00:06:49,089
project where we have billions of tweets

00:06:45,610 --> 00:06:52,409
with reasoning chains that's what expert

00:06:49,089 --> 00:06:58,149
systems do machine learning like

00:06:52,409 --> 00:07:00,369
sentiment analyzers for Texas then unit

00:06:58,149 --> 00:07:02,559
need something where you compute that's

00:07:00,369 --> 00:07:05,769
what we do in this movie server and they

00:07:02,559 --> 00:07:08,439
are get into a detail then you need

00:07:05,769 --> 00:07:10,689
something to handle account so many

00:07:08,439 --> 00:07:12,339
people can access the same server and

00:07:10,689 --> 00:07:15,129
it's computed for each of them

00:07:12,339 --> 00:07:18,429
individually and you need this ecosystem

00:07:15,129 --> 00:07:21,999
of different clients which access server

00:07:18,429 --> 00:07:24,249
and of course you need user defined

00:07:21,999 --> 00:07:28,479
skills so people can contribute and

00:07:24,249 --> 00:07:30,879
create skills themselves so it's it's a

00:07:28,479 --> 00:07:33,069
complicated thing and it's something

00:07:30,879 --> 00:07:37,179
which we created already we have created

00:07:33,069 --> 00:07:39,809
this ecosystem of different applications

00:07:37,179 --> 00:07:42,179
clients and the ability to create skills

00:07:39,809 --> 00:07:48,279
in an easy way

00:07:42,179 --> 00:07:51,399
so the beginning of this idea was not to

00:07:48,279 --> 00:07:54,189
create artificial intelligence but what

00:07:51,399 --> 00:07:56,259
I did with the Yesi peer-to-peer search

00:07:54,189 --> 00:07:59,610
engine project was creating a search

00:07:56,259 --> 00:08:03,099
engine and the lock lock social media

00:07:59,610 --> 00:08:06,939
harvesting engine it's also a search

00:08:03,099 --> 00:08:09,369
engine at a set at a certain point we

00:08:06,939 --> 00:08:11,349
thought that we must bring these things

00:08:09,369 --> 00:08:16,689
together so we have an aggregation level

00:08:11,349 --> 00:08:19,389
and have done and a search for all these

00:08:16,689 --> 00:08:21,279
things together but after we found out

00:08:19,389 --> 00:08:23,589
that we can ask questions against this

00:08:21,279 --> 00:08:26,739
database like who treated most about for

00:08:23,589 --> 00:08:30,309
Asia and other questions against the

00:08:26,739 --> 00:08:32,800
database before let's let's get more

00:08:30,309 --> 00:08:35,139
elements inside like conversation route

00:08:32,800 --> 00:08:38,519
so that we can formulate what kind of

00:08:35,139 --> 00:08:40,719
question can be asked and what kind of

00:08:38,519 --> 00:08:43,209
results should be computed should the

00:08:40,719 --> 00:08:45,410
result be just a phrase or should it be

00:08:43,209 --> 00:08:49,209
a picture or a mapper and for

00:08:45,410 --> 00:08:52,069
and then other sources came inside like

00:08:49,209 --> 00:08:55,100
results from what from alpha and from

00:08:52,069 --> 00:08:58,370
open data sources and so on so this is

00:08:55,100 --> 00:09:01,759
this is the idea how Suzy was created it

00:08:58,370 --> 00:09:04,250
was not like let's create a chat bot

00:09:01,759 --> 00:09:06,589
because check bots are cool it involves

00:09:04,250 --> 00:09:08,689
the necessity to have an aggregation

00:09:06,589 --> 00:09:10,759
engine for a different kind of sources

00:09:08,689 --> 00:09:14,959
of search engines and that's a specific

00:09:10,759 --> 00:09:19,449
strong element in Suzy to be able to

00:09:14,959 --> 00:09:23,120
integrate data elements from outside and

00:09:19,449 --> 00:09:25,310
once you create new information out of

00:09:23,120 --> 00:09:27,439
this you can feed it back into something

00:09:25,310 --> 00:09:30,439
like a reflection memory and then it's

00:09:27,439 --> 00:09:32,600
something which should be rib

00:09:30,439 --> 00:09:34,430
represented in a common base so all

00:09:32,600 --> 00:09:36,410
these these data sources should be

00:09:34,430 --> 00:09:38,449
represented in a specific way that's

00:09:36,410 --> 00:09:41,410
similar to each other and it should

00:09:38,449 --> 00:09:45,649
track the state so you know that one

00:09:41,410 --> 00:09:48,560
information came from a cost and this

00:09:45,649 --> 00:09:53,300
this data structure is called the zoo

00:09:48,560 --> 00:09:57,829
support so this is like Susie thinks it

00:09:53,300 --> 00:10:00,370
goes from thought to thought so how can

00:09:57,829 --> 00:10:00,370
you do this

00:10:03,560 --> 00:10:10,980
we have this back-end server it's

00:10:07,080 --> 00:10:15,120
available at API dot to the AI and if

00:10:10,980 --> 00:10:17,370
you do not a search you put something in

00:10:15,120 --> 00:10:19,920
a phrase into this field then you get a

00:10:17,370 --> 00:10:23,910
JSON back and that's what the that's

00:10:19,920 --> 00:10:27,209
what every client sees if it's computing

00:10:23,910 --> 00:10:29,279
a result like a spoken access or written

00:10:27,209 --> 00:10:32,519
access to the client so it always gets

00:10:29,279 --> 00:10:35,269
this J's impact and that's what you see

00:10:32,519 --> 00:10:40,440
here that's as Susy thought it's an

00:10:35,269 --> 00:10:43,860
computation step to answer a question

00:10:40,440 --> 00:10:47,300
and the question here is how is the

00:10:43,860 --> 00:10:50,550
weather in Singapore and it returns an

00:10:47,300 --> 00:10:53,880
answer object containing an action

00:10:50,550 --> 00:10:57,450
element and the action element says it's

00:10:53,880 --> 00:11:00,630
an answer and it has an expression so

00:10:57,450 --> 00:11:03,180
actions could be also not answers it

00:11:00,630 --> 00:11:05,790
could be other things like switching on

00:11:03,180 --> 00:11:09,930
the lights or playing music and so on so

00:11:05,790 --> 00:11:13,589
the result of the of the query is a set

00:11:09,930 --> 00:11:15,570
of actions which are executed after each

00:11:13,589 --> 00:11:17,430
other so this is these are the elements

00:11:15,570 --> 00:11:20,399
you can compose if you if you create

00:11:17,430 --> 00:11:23,010
your own square so this is the back end

00:11:20,399 --> 00:11:25,950
thing and it's it's really easy to to

00:11:23,010 --> 00:11:28,110
test new skills and see what's what has

00:11:25,950 --> 00:11:29,700
exactly happened then there's the data

00:11:28,110 --> 00:11:32,250
object and the data object collects

00:11:29,700 --> 00:11:35,339
everything which you have accessed from

00:11:32,250 --> 00:11:39,120
external sources but it also represents

00:11:35,339 --> 00:11:42,360
the internal very route space so if you

00:11:39,120 --> 00:11:43,680
set temporary variables they are

00:11:42,360 --> 00:11:45,180
represented here and you can do a

00:11:43,680 --> 00:11:51,149
debugging and seeing what's happing did

00:11:45,180 --> 00:11:52,890
happening there to go to compute the

00:11:51,149 --> 00:11:57,360
result from a skill we need a

00:11:52,890 --> 00:11:59,850
computation model it's not it's not a

00:11:57,360 --> 00:12:02,760
chatbot we're going to say this is the

00:11:59,850 --> 00:12:05,880
input and then please give me that

00:12:02,760 --> 00:12:08,399
output this check box usually are very

00:12:05,880 --> 00:12:10,440
simple there you just put something in

00:12:08,399 --> 00:12:13,050
and then you have a national language

00:12:10,440 --> 00:12:14,320
processing we have a new pattern that

00:12:13,050 --> 00:12:16,600
pattern is represented

00:12:14,320 --> 00:12:19,270
the intent and the intent means you have

00:12:16,600 --> 00:12:22,750
to put something outside the idea is

00:12:19,270 --> 00:12:25,260
that Suzy is able to act like an expert

00:12:22,750 --> 00:12:28,980
system it can think about things it can

00:12:25,260 --> 00:12:32,320
have think about an option and then

00:12:28,980 --> 00:12:34,390
during that thinking finds out that this

00:12:32,320 --> 00:12:38,290
option is not a good option and that it

00:12:34,390 --> 00:12:40,240
should have an alternative this kind of

00:12:38,290 --> 00:12:45,340
computation is shown by Prolog the

00:12:40,240 --> 00:12:52,630
product computer language there's an

00:12:45,340 --> 00:12:56,890
example for this language and this is

00:12:52,630 --> 00:13:00,990
the inspiration you have this condition

00:12:56,890 --> 00:13:03,700
part and the predicate part and if every

00:13:00,990 --> 00:13:07,300
predicate inside the condition holds

00:13:03,700 --> 00:13:09,490
then that predicate is true and this

00:13:07,300 --> 00:13:17,830
this program that quicksort in Prolog

00:13:09,490 --> 00:13:20,230
and in zhudi the condition is the new

00:13:17,830 --> 00:13:22,960
process so what is the root process that

00:13:20,230 --> 00:13:26,710
that are all the things which mutt must

00:13:22,960 --> 00:13:30,070
hold true to produce an answer and the

00:13:26,710 --> 00:13:32,800
predicate is something that the answer

00:13:30,070 --> 00:13:36,880
itself so you turn this thing around

00:13:32,800 --> 00:13:41,590
so everything which is an intent in in a

00:13:36,880 --> 00:13:46,180
bot is what here is a condition in the

00:13:41,590 --> 00:13:49,690
rule it's it's not so easy to understand

00:13:46,180 --> 00:13:53,700
you need to know some predicate first

00:13:49,690 --> 00:13:57,460
order logic predicate knowledge so

00:13:53,700 --> 00:13:59,830
here's an example the Suzy skill

00:13:57,460 --> 00:14:02,140
language has a very simple form break

00:13:59,830 --> 00:14:06,610
and forget all these complex things and

00:14:02,140 --> 00:14:08,950
just write some simple phrases like this

00:14:06,610 --> 00:14:12,610
one shall I start this is the simple

00:14:08,950 --> 00:14:14,770
pattern and if a variable called boot is

00:14:12,610 --> 00:14:18,790
set to excited then the answer is you

00:14:14,770 --> 00:14:20,260
will be happy and these are the

00:14:18,790 --> 00:14:22,240
conditions you have two conditions one

00:14:20,260 --> 00:14:24,100
is that the pattern holds and the second

00:14:22,240 --> 00:14:26,080
condition is that the variable set and

00:14:24,100 --> 00:14:33,530
the answer predicate is this for

00:14:26,080 --> 00:14:36,530
so this very simple kind of language can

00:14:33,530 --> 00:14:38,750
be used to create an expert system which

00:14:36,530 --> 00:14:40,790
creates the answer so it's maybe

00:14:38,750 --> 00:14:43,700
completely different but from what

00:14:40,790 --> 00:14:47,030
you've seen from other kind of chat BOTS

00:14:43,700 --> 00:14:49,790
or the personal assistants it's not that

00:14:47,030 --> 00:14:52,280
difficult in the end so the whole

00:14:49,790 --> 00:14:56,960
ecosystem what's running in the server

00:14:52,280 --> 00:15:02,450
is that this deduction can only can take

00:14:56,960 --> 00:15:04,940
place if a specific skill is found to be

00:15:02,450 --> 00:15:09,260
computed and because we are computing

00:15:04,940 --> 00:15:11,330
those patterns some patterns can fire at

00:15:09,260 --> 00:15:15,110
the same time and so we need a ranking

00:15:11,330 --> 00:15:19,090
some skills must be computed first and

00:15:15,110 --> 00:15:22,760
then other in a as a second option and

00:15:19,090 --> 00:15:25,220
followed the order of a computation is

00:15:22,760 --> 00:15:27,470
not defied it's it's it's open and here

00:15:25,220 --> 00:15:34,070
we have a ranking of skills which is

00:15:27,470 --> 00:15:36,440
necessary for a communication so we have

00:15:34,070 --> 00:15:38,960
a learning component we have a data

00:15:36,440 --> 00:15:44,630
memory where we can recall what was in a

00:15:38,960 --> 00:15:48,440
fault before we can fit this back to the

00:15:44,630 --> 00:15:52,100
next query and we have these data

00:15:48,440 --> 00:15:54,290
sources which are presented and so we

00:15:52,100 --> 00:15:57,680
can access resources from the data from

00:15:54,290 --> 00:15:59,540
the web and we have a skill resource and

00:15:57,680 --> 00:16:01,580
you have also special skill results

00:15:59,540 --> 00:16:06,700
which is which are called dreams this is

00:16:01,580 --> 00:16:12,650
the test bed for not for new skills and

00:16:06,700 --> 00:16:15,020
plugins is that maybe in the future this

00:16:12,650 --> 00:16:17,600
is this is not implemented other all

00:16:15,020 --> 00:16:21,470
other things are implemented that zeusie

00:16:17,600 --> 00:16:24,950
is able to create its own scale so you

00:16:21,470 --> 00:16:27,530
could have a teach-in method so to the

00:16:24,950 --> 00:16:30,260
learn skills this is the this was the

00:16:27,530 --> 00:16:32,960
first representation of the the roots

00:16:30,260 --> 00:16:35,510
inside of zhudi it's a JSON structure

00:16:32,960 --> 00:16:36,300
it's off this is this is what internally

00:16:35,510 --> 00:16:38,990
run

00:16:36,300 --> 00:16:43,860
we have a type there has a lot of

00:16:38,990 --> 00:16:46,620
patents which cause that we start a

00:16:43,860 --> 00:16:48,450
process this process can access data

00:16:46,620 --> 00:16:52,980
from external source

00:16:48,450 --> 00:16:57,149
this is like a SQL statement and then we

00:16:52,980 --> 00:16:58,589
have an action which is returned and the

00:16:57,149 --> 00:17:01,020
variables which have been computed

00:16:58,589 --> 00:17:06,959
inside the process is then replaced in

00:17:01,020 --> 00:17:08,850
here and to make this kind of access to

00:17:06,959 --> 00:17:10,890
an outside we need a consult service

00:17:08,850 --> 00:17:16,110
which is described here this is the

00:17:10,890 --> 00:17:19,110
exception or external resource so it's

00:17:16,110 --> 00:17:21,800
not that complex in the end because the

00:17:19,110 --> 00:17:24,329
rules are very simple

00:17:21,800 --> 00:17:27,620
with which you describe and this is

00:17:24,329 --> 00:17:31,350
compiled into this internal format

00:17:27,620 --> 00:17:33,270
because of time I will jump to the scale

00:17:31,350 --> 00:17:35,250
description this is a picture I took

00:17:33,270 --> 00:17:37,500
outside from the building because it it

00:17:35,250 --> 00:17:39,660
says it takes ten thousand dollars to

00:17:37,500 --> 00:17:44,610
master is good but this is wrong

00:17:39,660 --> 00:17:48,450
in this would be very long I think it's

00:17:44,610 --> 00:17:51,780
ten seconds it's what I show you you you

00:17:48,450 --> 00:17:55,650
will understand it instantly so here is

00:17:51,780 --> 00:17:58,230
the example the idea is that the scale

00:17:55,650 --> 00:18:00,720
data set can only grow as if it is as

00:17:58,230 --> 00:18:03,150
simple as writing a wiki article if it's

00:18:00,720 --> 00:18:06,210
more complex people won't do it but it's

00:18:03,150 --> 00:18:10,010
it's at that simple so this is the most

00:18:06,210 --> 00:18:13,290
simple skill it's actually a text file a

00:18:10,010 --> 00:18:16,590
simple text file where the input is the

00:18:13,290 --> 00:18:20,010
first line if it matches then the second

00:18:16,590 --> 00:18:22,740
line is the output and many many of the

00:18:20,010 --> 00:18:24,870
impressing features of a lecture for

00:18:22,740 --> 00:18:27,210
example I think they are all scripted in

00:18:24,870 --> 00:18:29,309
this way it's not there's no intelligent

00:18:27,210 --> 00:18:31,920
thing around it and having a lot of

00:18:29,309 --> 00:18:34,320
these phrases makes a funny thing and

00:18:31,920 --> 00:18:38,850
that's an important thing that if you

00:18:34,320 --> 00:18:40,650
create a tool like that that it's fine

00:18:38,850 --> 00:18:42,390
as well so it should be easy to put in

00:18:40,650 --> 00:18:46,650
all these things which could which could

00:18:42,390 --> 00:18:48,600
be funny and next example is that you

00:18:46,650 --> 00:18:49,830
can have alternatives in the answers of

00:18:48,600 --> 00:18:53,460
the random and

00:18:49,830 --> 00:18:56,850
so one of these next example is that you

00:18:53,460 --> 00:18:59,759
have several inputs which cost to the

00:18:56,850 --> 00:19:03,989
same output so you can say bonjour or

00:18:59,759 --> 00:19:06,119
Chow and output is hello

00:19:03,989 --> 00:19:08,429
then a simple pattern this is a

00:19:06,119 --> 00:19:11,549
placement for anything so if if you have

00:19:08,429 --> 00:19:16,769
anything inside then you get the output

00:19:11,549 --> 00:19:19,590
and if you put something inside here

00:19:16,769 --> 00:19:21,989
this is the same as here the previous

00:19:19,590 --> 00:19:25,139
example but this is stored in a variable

00:19:21,989 --> 00:19:28,289
which is called 1 so you can just output

00:19:25,139 --> 00:19:30,840
something called 1 this is at this time

00:19:28,289 --> 00:19:33,929
not more than you know from Eliza a very

00:19:30,840 --> 00:19:38,369
classic example but this is just the

00:19:33,929 --> 00:19:41,700
simple things so having more patterns

00:19:38,369 --> 00:19:44,549
means you have more variables then you

00:19:41,700 --> 00:19:47,879
can store one variable into a permanent

00:19:44,549 --> 00:19:49,919
memory so this is memorized permanently

00:19:47,879 --> 00:19:52,169
and can you access it afterwards

00:19:49,919 --> 00:19:54,690
it's not only part of an expression

00:19:52,169 --> 00:19:58,289
which is output but it's also stored

00:19:54,690 --> 00:20:06,950
into this be a brand variable then you

00:19:58,289 --> 00:20:09,659
can give this out again and you can have

00:20:06,950 --> 00:20:12,239
hidden assignments these are visible

00:20:09,659 --> 00:20:15,119
assignments where something you can see

00:20:12,239 --> 00:20:17,220
in the expression is stored into a

00:20:15,119 --> 00:20:19,559
verbal but here you have a hidden

00:20:17,220 --> 00:20:22,139
assignment where the broad excited it's

00:20:19,559 --> 00:20:26,369
not shown but just stored in the mood

00:20:22,139 --> 00:20:30,230
variable and then you can put this out

00:20:26,369 --> 00:20:33,389
again now this would variable is

00:20:30,230 --> 00:20:35,669
something we can have conditions on so

00:20:33,389 --> 00:20:40,519
you can have rules which fire on

00:20:35,669 --> 00:20:40,519
specific conditions and

00:20:41,700 --> 00:20:48,580
so this is a condition where it only met

00:20:46,840 --> 00:20:51,610
us that something is set into this

00:20:48,580 --> 00:20:56,080
variable and here is it's required that

00:20:51,610 --> 00:20:59,500
it's set to a specific value and here's

00:20:56,080 --> 00:21:02,470
an example where can have called back to

00:20:59,500 --> 00:21:04,300
itself so function Cara is not that this

00:21:02,470 --> 00:21:07,360
is not a special word it's just like a

00:21:04,300 --> 00:21:12,460
phrase and you can access this phrase

00:21:07,360 --> 00:21:15,990
again in this example where function

00:21:12,460 --> 00:21:19,270
color is called inside of a result so

00:21:15,990 --> 00:21:22,660
Susy is calling itself at this moment

00:21:19,270 --> 00:21:24,730
it's taking its answer from another

00:21:22,660 --> 00:21:28,720
answer which is computed inside this is

00:21:24,730 --> 00:21:31,150
the reflection element so phrases can be

00:21:28,720 --> 00:21:34,870
like Gita phrases which are inside

00:21:31,150 --> 00:21:40,240
somewhere else and you can of course put

00:21:34,870 --> 00:21:43,330
in some JavaScript so if you start a

00:21:40,240 --> 00:21:51,160
line of this bang then you can compute

00:21:43,330 --> 00:21:56,050
until URL in JavaScript this can be more

00:21:51,160 --> 00:22:00,880
complex by using a variable and that's

00:21:56,050 --> 00:22:03,790
the final example I hope which takes the

00:22:00,880 --> 00:22:05,830
result from an outside API and that's

00:22:03,790 --> 00:22:07,570
the death that was the beginning of the

00:22:05,830 --> 00:22:10,480
idea to have the scripted metadata

00:22:07,570 --> 00:22:14,650
search engine which is taking data from

00:22:10,480 --> 00:22:17,580
adjacent component and then a specific

00:22:14,650 --> 00:22:21,030
element in that Jason is accessed and to

00:22:17,580 --> 00:22:24,490
say which kind of element is accessed is

00:22:21,030 --> 00:22:29,530
given in the Jason path and that's the

00:22:24,490 --> 00:22:31,000
object statuses so now there are the

00:22:29,530 --> 00:22:32,740
things which are not implemented

00:22:31,000 --> 00:22:35,410
thinking with backtracking expert

00:22:32,740 --> 00:22:38,800
systems with first order logic skill

00:22:35,410 --> 00:22:42,330
reflection skill read skills so you

00:22:38,800 --> 00:22:46,670
don't call it skill but you read a skill

00:22:42,330 --> 00:22:50,300
and skills which create skills and

00:22:46,670 --> 00:22:52,340
zhuzi talks to itself so this is this

00:22:50,300 --> 00:22:57,410
can be done by going into the interface

00:22:52,340 --> 00:22:59,270
go to Suzy I click on the burger make an

00:22:57,410 --> 00:23:02,180
account click on skid then you see all

00:22:59,270 --> 00:23:05,000
the skills click on the skills click on

00:23:02,180 --> 00:23:08,240
edit and they are this that's a skill

00:23:05,000 --> 00:23:11,120
which takes information what happened on

00:23:08,240 --> 00:23:15,560
and it takes it from this API and the

00:23:11,120 --> 00:23:18,770
JSON path is data events and very easy

00:23:15,560 --> 00:23:22,640
thing to test this you can go to dream

00:23:18,770 --> 00:23:25,550
Zhu CAI and it has this is an ephah pet

00:23:22,640 --> 00:23:28,490
and you can make an ephah pet an instant

00:23:25,550 --> 00:23:32,690
input for a skirt so it can put in

00:23:28,490 --> 00:23:41,900
anything there I don't have time left I

00:23:32,690 --> 00:23:43,970
think ok so come to my my table at the

00:23:41,900 --> 00:23:46,420
basement I will show this to you so

00:23:43,970 --> 00:23:46,420

YouTube URL: https://www.youtube.com/watch?v=mjMbuzFzAzY


