Title: GraphQL for Web Applications - A Viable Replacement for REST? by Manuel Riel
Publication date: 2019-03-24
Playlist: FOSSASIA Summit 2019 - Web Technologies
Description: 
	15 March 2019 15:40, Training Room 2-2

GraphQL is an open source query language for APIs that solves some of the problems REST runs into when using it for complex web applications. While it was only published in 2015, there is now a large number of libraries available for it, including Java Script and Django.

This talk will present an introduction to GraphQL and my own experience of building a mid-sized web application using Django as backend and Vue.js as frontend with GraphQL. Sections:

Intro to GraphQL - Schemas, queries and mutations
Implementations server-side (Django)
Implementations client-side (Apollo, graphql.js)
Patterns for common web application tasks compared: REST vs. GraphQL
  a, user registration
  b, account details
  c, insert new item
Resources to get started
Q&A

Video colour was distorted while recording. Sorry and thank you for the understanding.
Captions: 
	00:00:00,000 --> 00:00:05,460
to my longer talk about craft well this

00:00:03,510 --> 00:00:07,740
was initially a 25-minute talk but now

00:00:05,460 --> 00:00:10,019
it's a 45 minutes talk which gives me

00:00:07,740 --> 00:00:13,380
the chance to add some more examples and

00:00:10,019 --> 00:00:16,020
I added some more concepts of graph coil

00:00:13,380 --> 00:00:17,699
as well and what if you guys have web

00:00:16,020 --> 00:00:21,060
developers so here's a who is a web

00:00:17,699 --> 00:00:21,900
developer here everyone I guess okay

00:00:21,060 --> 00:00:24,510
great

00:00:21,900 --> 00:00:27,180
so if you guys have later like ideas for

00:00:24,510 --> 00:00:28,859
use cases or questions or could want to

00:00:27,180 --> 00:00:31,590
know how you can use graft curl in your

00:00:28,859 --> 00:00:33,450
own project or when you should use it we

00:00:31,590 --> 00:00:36,180
can later have some like there will be

00:00:33,450 --> 00:00:40,110
some time for questions I guess it's

00:00:36,180 --> 00:00:41,969
just very short about myself so I I

00:00:40,110 --> 00:00:44,789
started business initially but I was

00:00:41,969 --> 00:00:46,710
like pushed into into programming when I

00:00:44,789 --> 00:00:49,020
started selling tailor-made shirts from

00:00:46,710 --> 00:00:51,210
China about 10 years ago and my partner

00:00:49,020 --> 00:00:53,010
was even less tacky than I was so I had

00:00:51,210 --> 00:00:55,800
to do some programming for our website

00:00:53,010 --> 00:01:02,190
to sell our shirts so that's how it

00:00:55,800 --> 00:01:04,559
started then last year I started a new

00:01:02,190 --> 00:01:07,110
company for back up for hosting backup

00:01:04,559 --> 00:01:10,530
services called work base this is where

00:01:07,110 --> 00:01:12,750
I used graph coil on a larger scale for

00:01:10,530 --> 00:01:17,549
all the communication between the front

00:01:12,750 --> 00:01:18,810
end and the back end and I I'm mostly

00:01:17,549 --> 00:01:22,110
here today to share what I've learned

00:01:18,810 --> 00:01:24,270
during this project because graph coil

00:01:22,110 --> 00:01:25,950
is like an emerging technology many

00:01:24,270 --> 00:01:28,650
people hear about it but it didn't use

00:01:25,950 --> 00:01:34,259
it it's not really hard to get into it

00:01:28,650 --> 00:01:36,150
and actually some people will will have

00:01:34,259 --> 00:01:38,579
built something similar to graph coil

00:01:36,150 --> 00:01:41,460
themselves in the past I know I did I

00:01:38,579 --> 00:01:44,939
had a project about four or five years

00:01:41,460 --> 00:01:47,340
ago where we were doing like hearing

00:01:44,939 --> 00:01:49,500
some data and then building some charts

00:01:47,340 --> 00:01:51,390
and I I was reading about the rest

00:01:49,500 --> 00:01:53,430
specification and I couldn't really fit

00:01:51,390 --> 00:01:55,619
my stuff into it because I had so many

00:01:53,430 --> 00:01:59,520
parameters to send to the backend every

00:01:55,619 --> 00:02:02,250
time so we just posted a JSON string

00:01:59,520 --> 00:02:04,799
every time for every request and this

00:02:02,250 --> 00:02:08,869
kind of very similar to what graph coil

00:02:04,799 --> 00:02:13,349
does then what other things do i do I

00:02:08,869 --> 00:02:16,230
maintain accounting library for Python

00:02:13,349 --> 00:02:19,230
then more recently I built an

00:02:16,230 --> 00:02:20,939
open-source desktop backup client in

00:02:19,230 --> 00:02:23,670
Python there will be lightning talk

00:02:20,939 --> 00:02:26,249
about this on Sunday and also if some of

00:02:23,670 --> 00:02:28,439
you are thinking about doing a startup I

00:02:26,249 --> 00:02:30,480
have like a support group for startups

00:02:28,439 --> 00:02:33,629
on whatsapp where it's like 10 or 15

00:02:30,480 --> 00:02:35,700
people of us and like mostly solo

00:02:33,629 --> 00:02:38,010
founders and we share like marketing

00:02:35,700 --> 00:02:43,769
ideas and if you want to join that and

00:02:38,010 --> 00:02:46,379
just just talk to me later ok so the

00:02:43,769 --> 00:02:47,819
target audience for this talk is web

00:02:46,379 --> 00:02:49,769
developers so this is not a beginner

00:02:47,819 --> 00:02:51,930
talk it's a beginner talk for graphic

00:02:49,769 --> 00:02:54,810
well but not a beginner talk for web

00:02:51,930 --> 00:02:57,799
design so you will profit the most when

00:02:54,810 --> 00:03:01,019
you're already a web designer when you

00:02:57,799 --> 00:03:02,489
know some JavaScript for sure when you

00:03:01,019 --> 00:03:06,480
are probably doing some stuff in the

00:03:02,489 --> 00:03:08,879
back end as well so and maybe currently

00:03:06,480 --> 00:03:12,000
you using rest or some other technology

00:03:08,879 --> 00:03:14,099
to talk to your back-end and after this

00:03:12,000 --> 00:03:17,310
talk you should be able to like sit down

00:03:14,099 --> 00:03:18,180
and and use graphic well instead for

00:03:17,310 --> 00:03:20,400
your next project

00:03:18,180 --> 00:03:22,049
so this is my goal for the for the talk

00:03:20,400 --> 00:03:23,939
and if you have any questions or if

00:03:22,049 --> 00:03:28,019
something is unclear then just interrupt

00:03:23,939 --> 00:03:30,989
me and we'll discuss it further so very

00:03:28,019 --> 00:03:33,599
shortly the contents so first I will I

00:03:30,989 --> 00:03:36,750
will compare craft coil with rest which

00:03:33,599 --> 00:03:38,879
is like a classic and we'll see what's

00:03:36,750 --> 00:03:42,299
the issue with rest once your back-end

00:03:38,879 --> 00:03:44,939
and your data gets more complicated then

00:03:42,299 --> 00:03:47,310
you will learn how to write a graph coil

00:03:44,939 --> 00:03:50,189
scheme and how to write queries there's

00:03:47,310 --> 00:03:52,769
also a web interface that you can use

00:03:50,189 --> 00:03:55,259
like by default with most graphical

00:03:52,769 --> 00:03:57,769
servers so this very easy to debug it's

00:03:55,259 --> 00:04:00,449
almost like a built in documentation

00:03:57,769 --> 00:04:03,569
then I build two sample apps for this

00:04:00,449 --> 00:04:05,489
talk very quickly so you see how this

00:04:03,569 --> 00:04:07,979
stuff looks in code so there's one

00:04:05,489 --> 00:04:10,609
back-end in Python and Django which I'm

00:04:07,979 --> 00:04:15,120
sure many are using anyone using Django

00:04:10,609 --> 00:04:17,130
here here okay so Chango and then

00:04:15,120 --> 00:04:19,859
there's a very simple like one file

00:04:17,130 --> 00:04:22,380
front-end in guchi s which will talk to

00:04:19,859 --> 00:04:24,570
our back-end and we'll be doing some

00:04:22,380 --> 00:04:26,820
stuff there and then I have some bonus

00:04:24,570 --> 00:04:27,120
content if we have time about security

00:04:26,820 --> 00:04:29,400
and

00:04:27,120 --> 00:04:31,800
to do authentication with graphical

00:04:29,400 --> 00:04:34,350
because this is not built into the

00:04:31,800 --> 00:04:35,820
specification and everyone has to define

00:04:34,350 --> 00:04:37,740
it themselves so I'm giving you some

00:04:35,820 --> 00:04:39,470
options there and then a summary and

00:04:37,740 --> 00:04:42,870
then time for questions

00:04:39,470 --> 00:04:44,570
ok so rest I don't know how long it has

00:04:42,870 --> 00:04:48,330
been around maybe quite a long time

00:04:44,570 --> 00:04:52,650
problem with rest is it gives you like

00:04:48,330 --> 00:04:56,070
it basically Maps the HTTP methods like

00:04:52,650 --> 00:04:58,470
get put post delete it maps those to

00:04:56,070 --> 00:05:01,919
your data instances and to your data

00:04:58,470 --> 00:05:04,080
models but it's not always clear which

00:05:01,919 --> 00:05:06,479
operation to use right get this usually

00:05:04,080 --> 00:05:10,350
clear post is somewhat clear but then

00:05:06,479 --> 00:05:12,479
put and patch is not so clear then as I

00:05:10,350 --> 00:05:15,810
said my first REST API was always

00:05:12,479 --> 00:05:17,940
posting JSON which is when you have

00:05:15,810 --> 00:05:22,350
complex data structures this is what you

00:05:17,940 --> 00:05:25,160
end up doing probably then in the rest

00:05:22,350 --> 00:05:29,220
model I'm sure you guys are familiar

00:05:25,160 --> 00:05:32,010
usually every every data class that you

00:05:29,220 --> 00:05:34,440
have every data model has its own ul

00:05:32,010 --> 00:05:35,820
endpoint so for example you have you

00:05:34,440 --> 00:05:39,330
will see it in the next slide you have

00:05:35,820 --> 00:05:41,280
like slash posts slash persons and then

00:05:39,330 --> 00:05:43,169
when you talk to this endpoint you can

00:05:41,280 --> 00:05:46,650
do stuff with it like delete it or get a

00:05:43,169 --> 00:05:47,820
list or something later and I mean for

00:05:46,650 --> 00:05:51,470
example block-based

00:05:47,820 --> 00:05:54,630
is about twenty or thirty data classes

00:05:51,470 --> 00:05:57,000
about like 15 of those are used in the

00:05:54,630 --> 00:06:01,380
web interface it's not a big app I guess

00:05:57,000 --> 00:06:04,289
an applic Facebook or complex CRM app

00:06:01,380 --> 00:06:06,210
would have like 50 of those data classes

00:06:04,289 --> 00:06:09,770
so in theory they would need 50

00:06:06,210 --> 00:06:14,940
endpoints and this can be get very

00:06:09,770 --> 00:06:17,430
complex then also graph KL in the name

00:06:14,940 --> 00:06:19,590
graph means like you focus on

00:06:17,430 --> 00:06:22,080
relationships you have like the social

00:06:19,590 --> 00:06:24,900
graph if the knowledge graph so it's

00:06:22,080 --> 00:06:26,970
always stuff that you have some things

00:06:24,900 --> 00:06:29,160
like some some entities that are

00:06:26,970 --> 00:06:33,570
connected to other stuff and most data

00:06:29,160 --> 00:06:36,330
models are modeled very well as a graph

00:06:33,570 --> 00:06:39,060
because for example you have a user like

00:06:36,330 --> 00:06:41,100
a user class the user class is connected

00:06:39,060 --> 00:06:46,830
to for example posts

00:06:41,100 --> 00:06:51,840
or to log in log or to do an images

00:06:46,830 --> 00:06:56,250
right so a user owns multiple images or

00:06:51,840 --> 00:06:58,740
something like this and this is pretty

00:06:56,250 --> 00:07:02,010
much impossible to model with with rest

00:06:58,740 --> 00:07:04,980
if you use it as its intended but graph

00:07:02,010 --> 00:07:09,120
QL gives you like a much nice and nested

00:07:04,980 --> 00:07:12,240
structure as you will see and then the

00:07:09,120 --> 00:07:16,110
last class of issues is over and under

00:07:12,240 --> 00:07:21,150
fetching just think of your average data

00:07:16,110 --> 00:07:23,760
class and test maybe 10 15 20 columns

00:07:21,150 --> 00:07:26,220
and in many cases when you use the data

00:07:23,760 --> 00:07:29,400
in the web front-end you only need a few

00:07:26,220 --> 00:07:31,890
of those columns but how do you tell the

00:07:29,400 --> 00:07:34,290
the API which columns do you want so

00:07:31,890 --> 00:07:37,530
often you will be getting more data than

00:07:34,290 --> 00:07:39,540
you actually need and this is also an

00:07:37,530 --> 00:07:42,720
issue this was one of the one of the

00:07:39,540 --> 00:07:45,120
main motivations by Facebook developed

00:07:42,720 --> 00:07:48,090
graph coil in the first place to avoid

00:07:45,120 --> 00:07:51,390
to avoid this stuff ok so here's some

00:07:48,090 --> 00:07:53,700
pictures that are stole from the from

00:07:51,390 --> 00:07:55,920
one of the official tutorials they're

00:07:53,700 --> 00:07:58,080
like there's like the official tutorial

00:07:55,920 --> 00:08:00,030
by Facebook which is a little bit more

00:07:58,080 --> 00:08:02,400
complicated they have Star Wars examples

00:08:00,030 --> 00:08:04,170
and there's a a newer one which is

00:08:02,400 --> 00:08:05,820
called how to craft koel which is a

00:08:04,170 --> 00:08:09,060
little bit simpler so the pictures are

00:08:05,820 --> 00:08:11,360
from there so here again we see the we

00:08:09,060 --> 00:08:14,670
see the rest model so here we have like

00:08:11,360 --> 00:08:17,550
like the different URLs right so we have

00:08:14,670 --> 00:08:20,250
users and then we have the ID and we do

00:08:17,550 --> 00:08:22,740
a get request and then we get we get

00:08:20,250 --> 00:08:25,620
like a data model of this user in JSON

00:08:22,740 --> 00:08:28,230
format for example so for example if you

00:08:25,620 --> 00:08:31,040
want to build a a user interface that

00:08:28,230 --> 00:08:33,690
displays some details about the user

00:08:31,040 --> 00:08:36,210
about the blog posts that he has done

00:08:33,690 --> 00:08:38,550
and about the followers he has could be

00:08:36,210 --> 00:08:40,710
Twitter for example then we have to do

00:08:38,550 --> 00:08:44,640
three requests its act act back and

00:08:40,710 --> 00:08:46,980
forth forget all this data so this is

00:08:44,640 --> 00:08:49,530
the rest model like it's one after the

00:08:46,980 --> 00:08:52,560
other and I have to fetch every single

00:08:49,530 --> 00:08:54,700
endpoint to get all my data which also

00:08:52,560 --> 00:08:57,430
introduces some complexity in the

00:08:54,700 --> 00:08:59,620
in the front end in the back end it's

00:08:57,430 --> 00:09:01,960
mostly automatic so you can just wrap

00:08:59,620 --> 00:09:04,950
your data class you're done so this is

00:09:01,960 --> 00:09:07,750
in comparison to this graphical L so su

00:09:04,950 --> 00:09:10,900
this is a graph QL query we'll be

00:09:07,750 --> 00:09:14,490
talking about this much more in like ten

00:09:10,900 --> 00:09:16,990
minutes so basically you make a query

00:09:14,490 --> 00:09:20,410
then you have an argument for the query

00:09:16,990 --> 00:09:23,620
which is you want to have the user with

00:09:20,410 --> 00:09:25,660
a specific ID and then you tell it which

00:09:23,620 --> 00:09:28,240
fields you want to retrieve from this

00:09:25,660 --> 00:09:31,480
user so in this case you want only the

00:09:28,240 --> 00:09:36,310
name and then you have this concept of

00:09:31,480 --> 00:09:38,830
graph so you can retrieve the data

00:09:36,310 --> 00:09:41,800
instances that are connected to this

00:09:38,830 --> 00:09:44,380
user in this case we are also retrieving

00:09:41,800 --> 00:09:46,900
posts but we don't want for example we

00:09:44,380 --> 00:09:49,000
don't want to post content the text or

00:09:46,900 --> 00:09:50,860
the creation date or whatever but we

00:09:49,000 --> 00:09:53,530
only want the title because this could

00:09:50,860 --> 00:09:55,660
be maybe a list or some kind of preview

00:09:53,530 --> 00:10:00,580
right so we only fetch the title here

00:09:55,660 --> 00:10:02,590
and then follow us we only want the the

00:10:00,580 --> 00:10:04,240
most recent followers to join and we

00:10:02,590 --> 00:10:06,100
only want a name right we're not

00:10:04,240 --> 00:10:07,720
interested in their posts we're not

00:10:06,100 --> 00:10:10,360
interested in the date of birth or

00:10:07,720 --> 00:10:12,820
anything so this very precise we tell it

00:10:10,360 --> 00:10:15,100
exactly which data we want and which

00:10:12,820 --> 00:10:17,050
related data we want so you see this is

00:10:15,100 --> 00:10:19,840
very powerful and it's much when you

00:10:17,050 --> 00:10:21,880
compare to rest so here we get a lot

00:10:19,840 --> 00:10:24,490
more stuff than we actually need so here

00:10:21,880 --> 00:10:26,080
you see we also get the content we get

00:10:24,490 --> 00:10:28,180
the comments that we don't really want

00:10:26,080 --> 00:10:30,370
right so here we get the birthday as

00:10:28,180 --> 00:10:32,650
well we don't need any of this right in

00:10:30,370 --> 00:10:35,620
this case and craftwell

00:10:32,650 --> 00:10:38,140
allows us to like very precisely get

00:10:35,620 --> 00:10:42,150
exactly the data that we want and also

00:10:38,140 --> 00:10:45,070
model the connections okay

00:10:42,150 --> 00:10:49,600
now let's go to the like the main

00:10:45,070 --> 00:10:52,360
concepts of traffic well how it's built

00:10:49,600 --> 00:10:54,390
it's actually quite easy usually you can

00:10:52,360 --> 00:10:57,400
run it in probably one or two hours and

00:10:54,390 --> 00:11:02,950
then start writing and the tutorials

00:10:57,400 --> 00:11:04,600
have very nice playground like like

00:11:02,950 --> 00:11:06,760
interactive features where you can write

00:11:04,600 --> 00:11:08,560
your own queries and you can test it and

00:11:06,760 --> 00:11:12,160
there's some sample data

00:11:08,560 --> 00:11:14,560
be showing that later as well so the

00:11:12,160 --> 00:11:18,069
first thing you will need is a is a type

00:11:14,560 --> 00:11:20,560
this is usually defined automatically by

00:11:18,069 --> 00:11:24,569
your by your back end at least that's

00:11:20,560 --> 00:11:28,050
how it works in in Django and Python so

00:11:24,569 --> 00:11:32,350
here we have two types which is post and

00:11:28,050 --> 00:11:36,069
person every type has some fields which

00:11:32,350 --> 00:11:38,499
can be another type so you can nest the

00:11:36,069 --> 00:11:39,459
types this is usually done when you

00:11:38,499 --> 00:11:42,519
think of Chango

00:11:39,459 --> 00:11:44,649
you can have two like the set you could

00:11:42,519 --> 00:11:46,870
connect it to a set and then this links

00:11:44,649 --> 00:11:50,740
to like a foreign key so we have this

00:11:46,870 --> 00:11:52,990
concept you can see it here then there

00:11:50,740 --> 00:11:57,370
are some primitives like integer string

00:11:52,990 --> 00:11:59,139
bowling float that you can use in your

00:11:57,370 --> 00:12:01,240
type definitions but usually you won't

00:11:59,139 --> 00:12:04,959
be writing this it's very unusual it

00:12:01,240 --> 00:12:06,790
that you will be writing this but the

00:12:04,959 --> 00:12:11,410
graphical client will still have some

00:12:06,790 --> 00:12:13,509
knowledge about this type so you can

00:12:11,410 --> 00:12:15,550
have some error correction so if you

00:12:13,509 --> 00:12:17,410
send an invalid query then the client

00:12:15,550 --> 00:12:19,420
will already know it because the client

00:12:17,410 --> 00:12:22,180
will know the schema the backend will

00:12:19,420 --> 00:12:25,269
know the schema so it's much easier to

00:12:22,180 --> 00:12:28,410
write code then this is where it gets

00:12:25,269 --> 00:12:32,920
interesting a query this is basically

00:12:28,410 --> 00:12:35,439
similar to a select so a query it

00:12:32,920 --> 00:12:39,279
retrieves data but it doesn't change any

00:12:35,439 --> 00:12:42,759
data so you can do multiple queries in

00:12:39,279 --> 00:12:46,480
in one in one graph coil requests for

00:12:42,759 --> 00:12:49,750
example so you could for example if you

00:12:46,480 --> 00:12:52,179
have two different craft coil functions

00:12:49,750 --> 00:12:55,410
you can run them after another and you

00:12:52,179 --> 00:12:58,540
can get back all the data in one request

00:12:55,410 --> 00:13:00,670
the query keyword is the default keyword

00:12:58,540 --> 00:13:03,009
so you don't have to write it it's

00:13:00,670 --> 00:13:06,279
enough to just put the curly brackets

00:13:03,009 --> 00:13:08,649
and then we are running the query all

00:13:06,279 --> 00:13:11,170
persons so these are these queries are

00:13:08,649 --> 00:13:13,779
also taken from the from the how to

00:13:11,170 --> 00:13:16,509
graph coil example and also the code the

00:13:13,779 --> 00:13:19,750
coded it is also like so we'll be seeing

00:13:16,509 --> 00:13:22,370
this more often and then as a result you

00:13:19,750 --> 00:13:24,620
just get if you don't do any limiting

00:13:22,370 --> 00:13:26,689
you will just get all the all the

00:13:24,620 --> 00:13:30,829
available persons that the server knows

00:13:26,689 --> 00:13:34,100
about it's a query then a mutation is

00:13:30,829 --> 00:13:36,620
like update request but it could also be

00:13:34,100 --> 00:13:38,809
the need to request if you want to map

00:13:36,620 --> 00:13:41,689
it to a database but graph coil only

00:13:38,809 --> 00:13:44,629
knows two different operations which is

00:13:41,689 --> 00:13:48,259
query and mutation mutation changes

00:13:44,629 --> 00:13:52,730
stuff and query only only retrieve stuff

00:13:48,259 --> 00:13:55,790
and you should be able to do a query as

00:13:52,730 --> 00:13:59,449
often as you like because it doesn't it

00:13:55,790 --> 00:14:01,970
shouldn't change any data so in this

00:13:59,449 --> 00:14:05,209
case we have a mutation that's called

00:14:01,970 --> 00:14:08,899
create create a person and we pass it

00:14:05,209 --> 00:14:11,749
two arguments like the name and the age

00:14:08,899 --> 00:14:13,790
and then we are asking it to give it the

00:14:11,749 --> 00:14:15,559
ID back which is very common when you

00:14:13,790 --> 00:14:17,899
are tracking like when you have a list

00:14:15,559 --> 00:14:20,360
in your front-end and you're tracking an

00:14:17,899 --> 00:14:22,910
ID and the name then the front end will

00:14:20,360 --> 00:14:24,980
already node the name and the edge

00:14:22,910 --> 00:14:27,319
because we pass it but it won't know the

00:14:24,980 --> 00:14:31,100
ID right and to keep the data in sync

00:14:27,319 --> 00:14:38,749
with the remote server you you also get

00:14:31,100 --> 00:14:40,370
the ID back then arguments this is this

00:14:38,749 --> 00:14:42,769
is not necessary when you're learning it

00:14:40,370 --> 00:14:45,800
but it's necessary when you're using it

00:14:42,769 --> 00:14:48,199
because in practice you will you will

00:14:45,800 --> 00:14:50,689
hard code the graph koel query or you

00:14:48,199 --> 00:14:54,079
put the heart the graph Koel query in a

00:14:50,689 --> 00:14:56,629
file somewhere in your your front-end

00:14:54,079 --> 00:14:59,209
application and then you reuse the same

00:14:56,629 --> 00:15:04,550
graph koel query over and over but with

00:14:59,209 --> 00:15:07,399
different arguments and these arguments

00:15:04,550 --> 00:15:10,910
are way to to make it easier to reuse it

00:15:07,399 --> 00:15:12,829
so let's just go through it so here we

00:15:10,910 --> 00:15:15,350
have a mutation so we have to use the

00:15:12,829 --> 00:15:18,139
mutation keyword as opposed to the query

00:15:15,350 --> 00:15:22,160
right query we use the query keyword or

00:15:18,139 --> 00:15:24,050
nothing because it's default then we

00:15:22,160 --> 00:15:28,670
have the new person and then we define

00:15:24,050 --> 00:15:32,179
the arguments that our that our our

00:15:28,670 --> 00:15:35,670
query supports so we have to give it the

00:15:32,179 --> 00:15:38,370
data type that the argument is came

00:15:35,670 --> 00:15:43,320
string integer or it could even be a

00:15:38,370 --> 00:15:45,210
different graphical type then here so

00:15:43,320 --> 00:15:48,420
basically this new person here this is a

00:15:45,210 --> 00:15:52,070
name I can pick and choose so I give to

00:15:48,420 --> 00:15:54,690
mutation and name and then inside I put

00:15:52,070 --> 00:15:57,060
the mutation that I want to run on the

00:15:54,690 --> 00:15:59,570
server so this new person I could I

00:15:57,060 --> 00:16:02,550
could make up any name that I want to

00:15:59,570 --> 00:16:04,650
but create person has to match a

00:16:02,550 --> 00:16:08,700
mutation that's available on the server

00:16:04,650 --> 00:16:11,670
and then here I'm mapping the variables

00:16:08,700 --> 00:16:14,040
to the to the input variables of the

00:16:11,670 --> 00:16:18,090
function so here because it's a simple

00:16:14,040 --> 00:16:21,390
example they are named the same which

00:16:18,090 --> 00:16:24,060
makes life easier but it there's no need

00:16:21,390 --> 00:16:26,790
to to name them the same you could also

00:16:24,060 --> 00:16:29,220
for example if your your if your

00:16:26,790 --> 00:16:30,930
application uses some different names in

00:16:29,220 --> 00:16:33,030
the front end in the back end and you

00:16:30,930 --> 00:16:35,280
don't want to change it you could easily

00:16:33,030 --> 00:16:38,430
map different names to different

00:16:35,280 --> 00:16:42,000
variables here and then when we run it

00:16:38,430 --> 00:16:44,430
we get we get back a response the

00:16:42,000 --> 00:16:46,860
response will be the name of the of the

00:16:44,430 --> 00:16:51,990
mutation that we ran and again we want

00:16:46,860 --> 00:16:53,910
to get back the ID okay then nesting

00:16:51,990 --> 00:17:00,000
we have we have already seen this at the

00:16:53,910 --> 00:17:03,450
very beginning so when I when I do

00:17:00,000 --> 00:17:06,630
queries I can always choose to retrieve

00:17:03,450 --> 00:17:09,030
some some related fields so for example

00:17:06,630 --> 00:17:12,710
a user has multiple posts and when I'm

00:17:09,030 --> 00:17:15,360
nesting stuff I can I can retrieve those

00:17:12,710 --> 00:17:19,130
nested fields as well and I can go down

00:17:15,360 --> 00:17:21,780
any any level that I want to pretty much

00:17:19,130 --> 00:17:25,080
which also causes some security concerns

00:17:21,780 --> 00:17:27,630
so it's usually limited so here we have

00:17:25,080 --> 00:17:32,160
an example it's a mutation so we are

00:17:27,630 --> 00:17:34,440
creating a new blog post so basically we

00:17:32,160 --> 00:17:38,010
have a title we just give it a title and

00:17:34,440 --> 00:17:43,190
an author ID and then as a response we

00:17:38,010 --> 00:17:43,190
want to have the idea of the new post

00:17:45,350 --> 00:17:50,760
we want to have the idea of the new post

00:17:47,970 --> 00:17:52,620
then we want to have the title so we can

00:17:50,760 --> 00:17:54,930
use it in the front and and then in

00:17:52,620 --> 00:17:57,360
addition we are also asking it for some

00:17:54,930 --> 00:18:00,510
details about the author so here we put

00:17:57,360 --> 00:18:02,730
the idea of the author and then we ask

00:18:00,510 --> 00:18:04,440
it for the response to also give us the

00:18:02,730 --> 00:18:06,930
ID the name and the age of the author

00:18:04,440 --> 00:18:07,640
that wrote this article that we just

00:18:06,930 --> 00:18:11,670
created

00:18:07,640 --> 00:18:14,520
and here's the response again so every

00:18:11,670 --> 00:18:17,190
response is just a JSON format which is

00:18:14,520 --> 00:18:20,130
nested in exactly the way that you

00:18:17,190 --> 00:18:22,110
defined in your query which is very nice

00:18:20,130 --> 00:18:24,720
because it's always very predictable and

00:18:22,110 --> 00:18:30,440
you can also you can rename stuff if you

00:18:24,720 --> 00:18:33,630
want to or you can you can rearrange it

00:18:30,440 --> 00:18:37,080
this is more an experimental feature but

00:18:33,630 --> 00:18:39,690
it just shows us that there's still the

00:18:37,080 --> 00:18:42,240
graphical is still in its early days so

00:18:39,690 --> 00:18:45,480
there's still a lot of tooling that's

00:18:42,240 --> 00:18:47,070
being developed and the tooling for many

00:18:45,480 --> 00:18:49,110
libraries is by no means

00:18:47,070 --> 00:18:51,270
I mean it's usable but it's not very

00:18:49,110 --> 00:18:54,000
mature and it's not totally complete in

00:18:51,270 --> 00:18:56,850
some cases so this will be nice feature

00:18:54,000 --> 00:18:59,940
it's already available in in the nodejs

00:18:56,850 --> 00:19:02,850
apollo graphical server but it's not

00:18:59,940 --> 00:19:07,560
really available for for python for

00:19:02,850 --> 00:19:10,590
example so what it does it's called a

00:19:07,560 --> 00:19:12,780
subscription subscription query so

00:19:10,590 --> 00:19:16,230
basically the server take the client

00:19:12,780 --> 00:19:20,160
asks the server to get updates about the

00:19:16,230 --> 00:19:23,790
specific data class so for example in

00:19:20,160 --> 00:19:26,250
this case the client would get all all

00:19:23,790 --> 00:19:28,260
new persons when a new person is created

00:19:26,250 --> 00:19:32,130
on the server the client would get it

00:19:28,260 --> 00:19:35,490
which is used which is used quite often

00:19:32,130 --> 00:19:37,590
for example when you are having a chat a

00:19:35,490 --> 00:19:40,560
chat application you will want to

00:19:37,590 --> 00:19:43,800
subscribe to new chat messages or if you

00:19:40,560 --> 00:19:47,400
have issue if you have a Twitter like

00:19:43,800 --> 00:19:50,700
application you will want to subscribe

00:19:47,400 --> 00:19:53,670
to new tweets for example and and this

00:19:50,700 --> 00:19:56,670
this will be a very powerful simple way

00:19:53,670 --> 00:19:58,059
to build these applications in a very

00:19:56,670 --> 00:20:01,389
easy way

00:19:58,059 --> 00:20:04,360
as I said the graphical specification

00:20:01,389 --> 00:20:06,580
doesn't tell us anything about how to

00:20:04,360 --> 00:20:09,779
implement it so most people implement

00:20:06,580 --> 00:20:12,129
this with WebSockets at the moment so

00:20:09,779 --> 00:20:14,470
basically combines craftwell with

00:20:12,129 --> 00:20:17,049
WebSockets at the moment people just use

00:20:14,470 --> 00:20:19,419
WebSockets directly but eventually when

00:20:17,049 --> 00:20:22,600
the tooling is more mature we will be

00:20:19,419 --> 00:20:24,730
able to use WebSockets we'll just run in

00:20:22,600 --> 00:20:27,519
the background and we will be able to

00:20:24,730 --> 00:20:34,029
use just use the subscription query type

00:20:27,519 --> 00:20:35,440
of traffic ol2 to get those updates okay

00:20:34,029 --> 00:20:37,450
and then the last thing I want to

00:20:35,440 --> 00:20:39,820
mention is because I learned it very

00:20:37,450 --> 00:20:42,970
late and but it's very useful its

00:20:39,820 --> 00:20:44,889
fragments for example when you have a

00:20:42,970 --> 00:20:47,230
larger app you will have like a folder

00:20:44,889 --> 00:20:50,710
of 20 different queries that you want to

00:20:47,230 --> 00:20:53,080
make and in many cases you you will want

00:20:50,710 --> 00:20:55,000
to retrieve the same set of fields and

00:20:53,080 --> 00:20:58,720
this is where fragments come in so you

00:20:55,000 --> 00:21:02,549
define a fragment this case I called it

00:20:58,720 --> 00:21:05,409
at rest detail and you define on which

00:21:02,549 --> 00:21:07,990
type you want to define this fragment

00:21:05,409 --> 00:21:10,870
and then you define the fields that you

00:21:07,990 --> 00:21:14,529
want and then you can just reuse the

00:21:10,870 --> 00:21:19,629
fragment in in all your in all your

00:21:14,529 --> 00:21:22,330
queries you just import it and then so

00:21:19,629 --> 00:21:25,000
this part here boot requests those

00:21:22,330 --> 00:21:26,830
fields here which is very useful because

00:21:25,000 --> 00:21:28,840
for example they are always changes to

00:21:26,830 --> 00:21:31,960
the backend there are always new columns

00:21:28,840 --> 00:21:33,970
being added and for example if you have

00:21:31,960 --> 00:21:36,639
this address field and you want to add

00:21:33,970 --> 00:21:39,190
the country or you want to add a second

00:21:36,639 --> 00:21:41,139
second Street second line for the street

00:21:39,190 --> 00:21:44,500
for example then you just change the

00:21:41,139 --> 00:21:47,289
fragment one time and it will be changed

00:21:44,500 --> 00:21:49,779
in all your queries so just like the DRI

00:21:47,289 --> 00:21:51,250
principle you only you only change one

00:21:49,779 --> 00:21:55,720
thing and then it will be available

00:21:51,250 --> 00:21:58,990
everywhere okay then let's talk about

00:21:55,720 --> 00:22:01,809
some code I will just quickly explain

00:21:58,990 --> 00:22:03,519
the code at a high level and then we see

00:22:01,809 --> 00:22:07,510
how it looks like and how it works like

00:22:03,519 --> 00:22:10,840
like in when it runs

00:22:07,510 --> 00:22:13,660
so I'm using caffeine here which is the

00:22:10,840 --> 00:22:16,840
most popular Python implementation of

00:22:13,660 --> 00:22:20,560
graph coil at the moment it's not moving

00:22:16,840 --> 00:22:23,500
particularly fast but they cover the

00:22:20,560 --> 00:22:25,540
basic features and people are writing

00:22:23,500 --> 00:22:29,680
some plug-ins for it that will be merged

00:22:25,540 --> 00:22:34,270
eventually and and yeah as I said the

00:22:29,680 --> 00:22:35,860
tooling is kind of a work in progress so

00:22:34,270 --> 00:22:37,750
since some of you already know Chango

00:22:35,860 --> 00:22:39,490
you will be familiar

00:22:37,750 --> 00:22:42,100
you will know you will already know

00:22:39,490 --> 00:22:45,850
about this so this is just like a

00:22:42,100 --> 00:22:48,460
standard Chango model definition that

00:22:45,850 --> 00:22:50,260
maps to some kind of database later so

00:22:48,460 --> 00:22:52,870
I'm still using the same example so

00:22:50,260 --> 00:22:55,120
there's a person it has a name and it

00:22:52,870 --> 00:22:58,660
has an it has an age that's all

00:22:55,120 --> 00:23:03,130
and then so I define this because I need

00:22:58,660 --> 00:23:06,490
it anyway right and then I define a

00:23:03,130 --> 00:23:09,910
graph Koel query on this on this data

00:23:06,490 --> 00:23:12,520
model in this case it's all persons and

00:23:09,910 --> 00:23:16,030
it's very simple to to do because I just

00:23:12,520 --> 00:23:20,340
reused the data type from from Django

00:23:16,030 --> 00:23:24,370
and then I map it to a to a graph QL

00:23:20,340 --> 00:23:26,700
query called all persons and as you have

00:23:24,370 --> 00:23:30,490
seen before

00:23:26,700 --> 00:23:33,100
all persons so all persons so it's doing

00:23:30,490 --> 00:23:36,340
some some changing to the to the writing

00:23:33,100 --> 00:23:40,090
it's it's it's changing a snake case to

00:23:36,340 --> 00:23:43,240
the Carib case and so this happens

00:23:40,090 --> 00:23:45,490
transparently so you can keep the code

00:23:43,240 --> 00:23:47,080
style of either language because it's

00:23:45,490 --> 00:23:53,250
slightly different between JavaScript

00:23:47,080 --> 00:23:53,250
and and Python so this is the back end

00:23:55,080 --> 00:24:03,190
then this is how it looks in in future s

00:23:58,120 --> 00:24:07,150
the JavaScript part so as I said usually

00:24:03,190 --> 00:24:08,890
you would you will hard code your your

00:24:07,150 --> 00:24:10,900
graph coil query and then you put some

00:24:08,890 --> 00:24:12,670
arguments in it this case we don't have

00:24:10,900 --> 00:24:16,630
arguments but we will see arguments a

00:24:12,670 --> 00:24:18,760
little bit later and and this piece of

00:24:16,630 --> 00:24:21,279
JavaScript will talk to Django and

00:24:18,760 --> 00:24:36,710
retrieve our persons

00:24:21,279 --> 00:24:37,480
okay now demo time so oh so this is good

00:24:36,710 --> 00:24:40,159
to see ya

00:24:37,480 --> 00:24:43,820
okay so here I have a very simple Chango

00:24:40,159 --> 00:24:48,110
project took like 20 minutes to make so

00:24:43,820 --> 00:24:49,759
here we have the data model again so we

00:24:48,110 --> 00:24:51,700
have two person and we have to post

00:24:49,759 --> 00:24:55,429
which we've seen before

00:24:51,700 --> 00:24:57,919
then that this is like then you have

00:24:55,429 --> 00:25:00,379
this a file called schema and mutations

00:24:57,919 --> 00:25:02,869
in this case we don't have mutations I

00:25:00,379 --> 00:25:04,789
put it all in one file in this case but

00:25:02,869 --> 00:25:07,429
you could split it off if you have a lot

00:25:04,789 --> 00:25:12,460
of queries and mutations you just use

00:25:07,429 --> 00:25:16,850
two of them so here we define we map our

00:25:12,460 --> 00:25:19,309
person model to a to a data type to it

00:25:16,850 --> 00:25:23,659
to a graph coil data type called person

00:25:19,309 --> 00:25:26,720
type it's just convention you just you

00:25:23,659 --> 00:25:30,830
just add the word type at the end and

00:25:26,720 --> 00:25:33,889
that's a post type person type post type

00:25:30,830 --> 00:25:39,850
so this here defines the this defines

00:25:33,889 --> 00:25:42,499
the types we can we can quickly go back

00:25:39,850 --> 00:25:44,720
so this is this here the type this is

00:25:42,499 --> 00:25:48,909
the first thing so this defines this

00:25:44,720 --> 00:25:51,529
stuff here then here we have a query

00:25:48,909 --> 00:25:54,889
these are all the queries so this is

00:25:51,529 --> 00:25:56,659
read only and we can execute this as

00:25:54,889 --> 00:25:59,059
often as we want because it doesn't

00:25:56,659 --> 00:26:01,730
change any data so I have two queries

00:25:59,059 --> 00:26:04,789
here all persons and all posts very

00:26:01,730 --> 00:26:07,850
boring so every time they just return

00:26:04,789 --> 00:26:10,820
all the objects that we have four

00:26:07,850 --> 00:26:13,489
persons of a post and then here we have

00:26:10,820 --> 00:26:14,809
our mutations mutations are a little bit

00:26:13,489 --> 00:26:17,749
more complex because you're changing

00:26:14,809 --> 00:26:20,359
data and usually you want to handle some

00:26:17,749 --> 00:26:22,879
kind of authentication and some kind of

00:26:20,359 --> 00:26:26,389
validation so this is this is the place

00:26:22,879 --> 00:26:30,139
where you would do it so I put some I

00:26:26,389 --> 00:26:33,559
put I put the required arguments for the

00:26:30,139 --> 00:26:34,700
mutation I give it a type again which

00:26:33,559 --> 00:26:39,470
Maps

00:26:34,700 --> 00:26:41,929
back to here furious mutations so here

00:26:39,470 --> 00:26:45,080
we have like a string and in the integer

00:26:41,929 --> 00:26:47,029
again which is the same as here and then

00:26:45,080 --> 00:26:49,369
here is the actual function that it gets

00:26:47,029 --> 00:26:52,009
called when I call this mutation I'm

00:26:49,369 --> 00:26:55,210
just creating a new person and I'm just

00:26:52,009 --> 00:26:57,889
passing it the arguments that come and

00:26:55,210 --> 00:26:59,659
then I'm saving it in practice I would

00:26:57,889 --> 00:27:02,090
do some more validation here maybe I

00:26:59,659 --> 00:27:04,309
would check for the for the length of

00:27:02,090 --> 00:27:06,679
the name I would maybe check if the H

00:27:04,309 --> 00:27:08,450
makes sense if it's more than hundred

00:27:06,679 --> 00:27:10,190
years for example maybe you want to

00:27:08,450 --> 00:27:12,769
reject it with a meaningful error

00:27:10,190 --> 00:27:15,139
message and then post type is roughly

00:27:12,769 --> 00:27:19,609
the same with a string of the title we

00:27:15,139 --> 00:27:22,220
have at the off ID and here we create a

00:27:19,609 --> 00:27:25,460
new post we give it a title here I'm

00:27:22,220 --> 00:27:29,450
using the the input arguments directly

00:27:25,460 --> 00:27:32,090
and here I'm finding the relevant person

00:27:29,450 --> 00:27:34,460
object from the database using the ID

00:27:32,090 --> 00:27:36,230
that I'm getting and then I save to new

00:27:34,460 --> 00:27:39,200
post type so that's pretty much

00:27:36,230 --> 00:27:42,529
everything there's nothing else to this

00:27:39,200 --> 00:27:43,999
application it's just the default when

00:27:42,529 --> 00:27:46,549
you just start in you Cheng approach

00:27:43,999 --> 00:27:48,549
like this what you get and that's all

00:27:46,549 --> 00:27:51,109
there is

00:27:48,549 --> 00:27:53,389
yeah so there's a github repository

00:27:51,109 --> 00:27:55,639
where you can clone this and play with

00:27:53,389 --> 00:27:59,259
it make some small changes decide how

00:27:55,639 --> 00:28:07,519
this how I I like to start very often

00:27:59,259 --> 00:28:11,210
you then let's see how it looks like so

00:28:07,519 --> 00:28:17,299
I'm running this Chango server I'm

00:28:11,210 --> 00:28:20,379
running it on port 8000 now and by

00:28:17,299 --> 00:28:23,629
default graphine will provide you with

00:28:20,379 --> 00:28:27,169
with a kind of browser with a kind of

00:28:23,629 --> 00:28:30,080
explorer that allows you to to play with

00:28:27,169 --> 00:28:32,450
your graph QL schema and this is what I

00:28:30,080 --> 00:28:36,249
did here I'm cheating a little bit

00:28:32,450 --> 00:28:36,249
because I've saved some stuff here

00:28:36,489 --> 00:28:41,690
let's with Oh

00:28:39,609 --> 00:28:44,110
actually I've only seasoned more stuff

00:28:41,690 --> 00:28:46,820
here

00:28:44,110 --> 00:28:50,030
so for internal projects this can

00:28:46,820 --> 00:28:53,570
totally replace documentation to a

00:28:50,030 --> 00:28:56,570
degree what I would like to see in the

00:28:53,570 --> 00:28:59,630
future is maybe the ability to to add

00:28:56,570 --> 00:29:02,090
some comments to your graph coil classes

00:28:59,630 --> 00:29:03,800
and then they show up here in the in the

00:29:02,090 --> 00:29:06,860
browser so basically this is a

00:29:03,800 --> 00:29:10,100
JavaScript interface that's running on

00:29:06,860 --> 00:29:13,280
the on the Django server it's built in

00:29:10,100 --> 00:29:15,440
already I recommend you disable it for

00:29:13,280 --> 00:29:19,100
production deployments except if you

00:29:15,440 --> 00:29:22,400
want to expose the API some services

00:29:19,100 --> 00:29:25,340
will want to expose the API and with

00:29:22,400 --> 00:29:27,980
this it's very quick and easy to provide

00:29:25,340 --> 00:29:31,460
people with an API so let's see what we

00:29:27,980 --> 00:29:35,270
can do with it so here's a simple query

00:29:31,460 --> 00:29:38,150
as I said I can commit the query keyword

00:29:35,270 --> 00:29:40,550
or I can I can write it I can give it a

00:29:38,150 --> 00:29:45,320
different name for example get my

00:29:40,550 --> 00:29:47,480
persons and then here's the here's the

00:29:45,320 --> 00:29:51,290
actual graph Koel query and I'm running

00:29:47,480 --> 00:29:53,450
I could also browse tit here so for

00:29:51,290 --> 00:29:56,270
example if I click it query it tells me

00:29:53,450 --> 00:29:59,360
all the queries the server can do again

00:29:56,270 --> 00:30:01,160
this maps back to the simple maps back

00:29:59,360 --> 00:30:03,670
to this stuff here so this is all the

00:30:01,160 --> 00:30:07,670
code I've written this is all the code I

00:30:03,670 --> 00:30:10,070
only need those five lines and then I

00:30:07,670 --> 00:30:12,380
can browse this stuff here then here I

00:30:10,070 --> 00:30:14,720
can look at the mutations that the

00:30:12,380 --> 00:30:17,030
server supports again it will it will

00:30:14,720 --> 00:30:20,360
use my datatypes it will tell me which

00:30:17,030 --> 00:30:22,190
return type I can expect same here for

00:30:20,360 --> 00:30:24,470
example if I get all persons I get a

00:30:22,190 --> 00:30:27,260
person type and I can browse the person

00:30:24,470 --> 00:30:31,490
type which is very nice so now let's run

00:30:27,260 --> 00:30:34,130
this and we get back a list of all the

00:30:31,490 --> 00:30:35,990
persons I already put some test data in

00:30:34,130 --> 00:30:37,810
the database but we will add some more

00:30:35,990 --> 00:30:43,790
in a bit

00:30:37,810 --> 00:30:46,820
yeah typos here so let's look at the

00:30:43,790 --> 00:30:49,040
database content so I'm just using a

00:30:46,820 --> 00:30:53,030
SQLite database here to keep stuff

00:30:49,040 --> 00:30:55,580
simple so this is like the this is the

00:30:53,030 --> 00:30:57,190
content of the database at the moment so

00:30:55,580 --> 00:31:01,730
I'm running this graph query

00:30:57,190 --> 00:31:03,649
then the graph query runs my my Python

00:31:01,730 --> 00:31:07,279
code which is trust

00:31:03,649 --> 00:31:11,059
which is just this year and as a end

00:31:07,279 --> 00:31:14,679
result I get a chastened list of all my

00:31:11,059 --> 00:31:16,880
all my persons right it is very simple

00:31:14,679 --> 00:31:20,149
let's see what else we can do with it we

00:31:16,880 --> 00:31:24,529
can do some or we can get our posts so

00:31:20,149 --> 00:31:31,270
here's a nice example for for for a

00:31:24,529 --> 00:31:31,270
nested query same thing we do a query

00:31:31,809 --> 00:31:38,929
the query is called all posts as we've

00:31:34,789 --> 00:31:41,210
seen and that in the Python thing then I

00:31:38,929 --> 00:31:44,240
tell it I want the ID I want the title

00:31:41,210 --> 00:31:47,419
if I forget stuff that my post type has

00:31:44,240 --> 00:31:50,840
I can look it up here so these are all

00:31:47,419 --> 00:31:53,470
the fields we have anyway but I could

00:31:50,840 --> 00:31:56,350
get more fields from the from the offer

00:31:53,470 --> 00:31:59,510
for example I could also get the ID and

00:31:56,350 --> 00:32:00,919
I ran it this is what I get so at the

00:31:59,510 --> 00:32:03,409
moment there's one post

00:32:00,919 --> 00:32:07,309
it's called McGruff musings it's done by

00:32:03,409 --> 00:32:09,289
Lisa and for example if now if my

00:32:07,309 --> 00:32:11,720
front-end changes and also want to

00:32:09,289 --> 00:32:14,360
display the age of Lisa I just add H

00:32:11,720 --> 00:32:17,090
here then I run it again and it will add

00:32:14,360 --> 00:32:19,549
it will add the age field as well so the

00:32:17,090 --> 00:32:22,419
client has full control which data he

00:32:19,549 --> 00:32:26,059
wants which connected data he wants and

00:32:22,419 --> 00:32:29,419
in which fields he wants to retrieve so

00:32:26,059 --> 00:32:33,110
it is very flexible then let's do a

00:32:29,419 --> 00:32:35,059
mutation and change some stuff so here

00:32:33,110 --> 00:32:37,220
we have a mutation I didn't give it a

00:32:35,059 --> 00:32:39,830
name but I could give it a name then i'm

00:32:37,220 --> 00:32:43,549
using the they create person mutation

00:32:39,830 --> 00:32:46,880
again this simply maps to to this code

00:32:43,549 --> 00:32:50,480
here and specifically it runs this

00:32:46,880 --> 00:32:52,970
python code here that's all we're just

00:32:50,480 --> 00:32:54,830
adding a new person object and we're

00:32:52,970 --> 00:32:58,700
saving it and then we're returning this

00:32:54,830 --> 00:33:03,190
person object so let's see how we can

00:32:58,700 --> 00:33:03,190
run it anyone wants to put a name

00:33:03,940 --> 00:33:10,240
huh test okay very creative test and

00:33:08,140 --> 00:33:13,420
let's make it a little bit older let's

00:33:10,240 --> 00:33:16,960
make it 35 right and then we want to get

00:33:13,420 --> 00:33:18,820
the idea and in in addition we want to

00:33:16,960 --> 00:33:22,390
check that the age was saved correctly

00:33:18,820 --> 00:33:24,640
so let's also put the age then we run it

00:33:22,390 --> 00:33:27,520
and then we get as a result we get a

00:33:24,640 --> 00:33:29,770
create person which maps to the name of

00:33:27,520 --> 00:33:32,650
our mutation so if you have multiple

00:33:29,770 --> 00:33:34,120
mutations which you could all do for

00:33:32,650 --> 00:33:40,870
example I could just copy this and

00:33:34,120 --> 00:33:47,010
create two persons at the same time test

00:33:40,870 --> 00:33:47,010
- let's say test 3 test - OH

00:33:52,430 --> 00:33:56,210
yeah I think I have to give it I have to

00:33:54,590 --> 00:33:58,100
give it a I have to give it a different

00:33:56,210 --> 00:34:02,090
name if I want to do this so you have to

00:33:58,100 --> 00:34:04,100
use aliases so you know which which

00:34:02,090 --> 00:34:07,340
mutation returned which result we can

00:34:04,100 --> 00:34:12,110
look into this if there's time so we run

00:34:07,340 --> 00:34:13,730
it and a new person is being created ten

00:34:12,110 --> 00:34:19,340
minutes left so I will now switch to the

00:34:13,730 --> 00:34:21,200
JavaScript part so this is my JavaScript

00:34:19,340 --> 00:34:24,679
front-end this is written in Gucci s

00:34:21,200 --> 00:34:27,470
just a few lines of code let's see how

00:34:24,679 --> 00:34:31,250
it looks like so again I only have a

00:34:27,470 --> 00:34:35,090
single file here this is my app view so

00:34:31,250 --> 00:34:37,940
I have here the list of so I have two

00:34:35,090 --> 00:34:41,030
lists of the list of persons and I have

00:34:37,940 --> 00:34:44,210
a form that can that can help me to add

00:34:41,030 --> 00:34:46,700
some more persons and here I have a

00:34:44,210 --> 00:34:49,429
future s loop that just displays all the

00:34:46,700 --> 00:34:52,970
persons so it is quite readable even I'm

00:34:49,429 --> 00:34:56,650
not sure who knows future s here here ok

00:34:52,970 --> 00:34:58,880
quite a few ok so this very simple stuff

00:34:56,650 --> 00:35:01,700
so this is just my template that

00:34:58,880 --> 00:35:06,290
displays the data here is a form that

00:35:01,700 --> 00:35:08,780
helps me to to input the data then I'm

00:35:06,290 --> 00:35:12,470
using a library called graph coil

00:35:08,780 --> 00:35:16,490
request which is not which is not the

00:35:12,470 --> 00:35:18,470
main library it's a smaller library for

00:35:16,490 --> 00:35:23,480
simple use cases which is perfect for

00:35:18,470 --> 00:35:26,270
this year then I'm giving it the end

00:35:23,480 --> 00:35:31,010
point so it's important to note as

00:35:26,270 --> 00:35:33,260
opposed to to rest every every graph QL

00:35:31,010 --> 00:35:37,790
query is sent to the same URL the same

00:35:33,260 --> 00:35:39,830
endpoint and just a jason is different

00:35:37,790 --> 00:35:43,280
that you send it to as opposed to rest

00:35:39,830 --> 00:35:45,950
rest has many different URLs so in a

00:35:43,280 --> 00:35:49,450
kind of in a kind it's simpler to to

00:35:45,950 --> 00:35:52,610
manage and to restrict access to one URL

00:35:49,450 --> 00:35:56,110
then here you can see the query this is

00:35:52,610 --> 00:35:58,430
the same as we as we had before here

00:35:56,110 --> 00:36:00,859
when we look at all persons I just

00:35:58,430 --> 00:36:02,660
copied this from over here this is the

00:36:00,859 --> 00:36:06,260
same a hard-coded it in a bigger project

00:36:02,660 --> 00:36:09,290
you would put this in an extra file

00:36:06,260 --> 00:36:14,020
file per query to keep a good overview

00:36:09,290 --> 00:36:16,250
and then here I have a Chava script

00:36:14,020 --> 00:36:19,400
statement that actually runs the query

00:36:16,250 --> 00:36:22,760
so I'm having the graphical end point

00:36:19,400 --> 00:36:26,540
which is just a property of the future S

00:36:22,760 --> 00:36:30,500
component and then when it's succeeding

00:36:26,540 --> 00:36:32,930
I'm resolving the promise and I'm just

00:36:30,500 --> 00:36:37,160
setting the person's to the data that I

00:36:32,930 --> 00:36:40,760
got let's see if it works I tried it

00:36:37,160 --> 00:36:44,690
before so it works for this easy we can

00:36:40,760 --> 00:36:48,170
look at at the inspector to see how I

00:36:44,690 --> 00:36:50,540
request looks like so I do the old

00:36:48,170 --> 00:36:52,280
person's so it has two requests so

00:36:50,540 --> 00:36:54,740
graphic well the first is just the

00:36:52,280 --> 00:36:57,320
options to make sure I'm not doing some

00:36:54,740 --> 00:37:02,690
some shady things and then the second

00:36:57,320 --> 00:37:06,530
request is the actual request you can

00:37:02,690 --> 00:37:08,540
see the JSON format of the of the graph

00:37:06,530 --> 00:37:12,410
coil here this is pretty much the same

00:37:08,540 --> 00:37:14,300
as you saw up here I think it even

00:37:12,410 --> 00:37:17,660
copies the line breaks to a degree

00:37:14,300 --> 00:37:20,180
yeah it does then you can see the

00:37:17,660 --> 00:37:23,480
response this is the same as we saw in

00:37:20,180 --> 00:37:24,410
the index floral over there so it is

00:37:23,480 --> 00:37:27,110
very nice to be back

00:37:24,410 --> 00:37:29,450
in this way all person so here we get a

00:37:27,110 --> 00:37:33,110
list of all the persons again it's in

00:37:29,450 --> 00:37:38,690
JSON format and a finger also asked it

00:37:33,110 --> 00:37:41,240
for the I also ask it for the for the

00:37:38,690 --> 00:37:43,460
post title so I also ask it for the

00:37:41,240 --> 00:37:45,380
persons and if the person has a post it

00:37:43,460 --> 00:37:48,950
will also give me the title of the post

00:37:45,380 --> 00:37:51,170
so here we see it did that for most

00:37:48,950 --> 00:37:55,580
office it's empty because we didn't give

00:37:51,170 --> 00:37:58,310
them any posts yet but for this one for

00:37:55,580 --> 00:38:01,340
Lisa she has one post which is like

00:37:58,310 --> 00:38:05,840
about graph well then let's see how

00:38:01,340 --> 00:38:11,630
mutation looks like anybody wants to

00:38:05,840 --> 00:38:16,450
give a different name tango tango John

00:38:11,630 --> 00:38:16,450
okay John any any particular age

00:38:16,990 --> 00:38:25,390
9 ok good 9 very young very young Koda

00:38:20,359 --> 00:38:28,640
very young offer so we click at person

00:38:25,390 --> 00:38:32,270
let's look at at the JavaScript code

00:38:28,640 --> 00:38:35,420
first where do we have it

00:38:32,270 --> 00:38:38,330
so at person I made this is a function

00:38:35,420 --> 00:38:41,300
of the future s component here's again

00:38:38,330 --> 00:38:45,170
the mutation which is almost the same as

00:38:41,300 --> 00:38:49,490
as we saw before but I'm using the

00:38:45,170 --> 00:38:52,430
parameters here so I can easily pass the

00:38:49,490 --> 00:38:55,280
arguments by VJ s and then Here I am

00:38:52,430 --> 00:38:57,680
running it here I'm building the

00:38:55,280 --> 00:39:00,619
arguments so I'm giving it a name and an

00:38:57,680 --> 00:39:04,820
age which is currently used in the form

00:39:00,619 --> 00:39:06,920
the same name is the model here so if

00:39:04,820 --> 00:39:09,349
you chase mix it's very simple and then

00:39:06,920 --> 00:39:13,060
when it's done I'm doing the alert that

00:39:09,349 --> 00:39:17,150
we saw here edit person bla bla bla and

00:39:13,060 --> 00:39:19,790
let's see okay and now we can run this

00:39:17,150 --> 00:39:25,310
again now let's let's look at this here

00:39:19,790 --> 00:39:27,950
first so once again we see our our graph

00:39:25,310 --> 00:39:30,140
QL query here and also our variables

00:39:27,950 --> 00:39:33,170
this is in addition now so it gives a

00:39:30,140 --> 00:39:35,359
dictionary of variables and it gives the

00:39:33,170 --> 00:39:37,609
the query that we want to run and it

00:39:35,359 --> 00:39:40,580
will do some replacing for that on the

00:39:37,609 --> 00:39:43,070
server and then as a result we get back

00:39:40,580 --> 00:39:46,369
our data the name of the mutation the

00:39:43,070 --> 00:39:49,010
person at the age and also the ID that

00:39:46,369 --> 00:39:51,680
the instance of the model got in the

00:39:49,010 --> 00:39:54,290
server and then we can run our get

00:39:51,680 --> 00:39:56,690
persons again and we see Shawn was added

00:39:54,290 --> 00:39:59,630
to the database and when we look into

00:39:56,690 --> 00:40:05,619
our database we see John was also added

00:39:59,630 --> 00:40:05,619
here yeah so that's the sample code

00:40:09,090 --> 00:40:18,310
five minutes okay um okay so that couple

00:40:16,330 --> 00:40:20,740
of popular JavaScript libraries you can

00:40:18,310 --> 00:40:22,960
use I mean there some back-end libraries

00:40:20,740 --> 00:40:25,420
some front-end libraries for front-end

00:40:22,960 --> 00:40:27,220
relay was the first client that was

00:40:25,420 --> 00:40:28,570
released by Facebook but I don't think

00:40:27,220 --> 00:40:30,550
it's very widely used today

00:40:28,570 --> 00:40:32,440
Apollo is probably the most widely used

00:40:30,550 --> 00:40:34,600
for big projects but it needs a little

00:40:32,440 --> 00:40:36,700
bit more work to set it up and for this

00:40:34,600 --> 00:40:39,100
small example I used a smaller project

00:40:36,700 --> 00:40:41,200
called draft coil request where you just

00:40:39,100 --> 00:40:45,850
you where you just put the string like

00:40:41,200 --> 00:40:47,830
this I think we I will just talk about

00:40:45,850 --> 00:40:50,350
this very briefly because as you've seen

00:40:47,830 --> 00:40:54,100
there was no authentication everyone can

00:40:50,350 --> 00:40:56,890
can add an offer by person everyone can

00:40:54,100 --> 00:41:01,600
add a post so you as a developer you

00:40:56,890 --> 00:41:03,520
need to handle the authentication the

00:41:01,600 --> 00:41:05,440
two major options for this are you can

00:41:03,520 --> 00:41:08,530
use a cookie a session cookie which

00:41:05,440 --> 00:41:11,320
Cheng already does by default or you can

00:41:08,530 --> 00:41:13,030
use something fancier like a JWT token

00:41:11,320 --> 00:41:16,780
that you save into local storage and

00:41:13,030 --> 00:41:19,450
then usually you would use in in Jango

00:41:16,780 --> 00:41:22,300
you would use a decorator so only an

00:41:19,450 --> 00:41:25,330
authenticated user can run this mutation

00:41:22,300 --> 00:41:27,880
so the access control happens at the

00:41:25,330 --> 00:41:31,390
like atom mutation and query level and

00:41:27,880 --> 00:41:34,270
not at the UN level and a few other

00:41:31,390 --> 00:41:36,700
security considerations are in practice

00:41:34,270 --> 00:41:39,310
usually want to limit the query depth

00:41:36,700 --> 00:41:42,100
because otherwise I can make like I

00:41:39,310 --> 00:41:44,680
could attack your server by just doing

00:41:42,100 --> 00:41:47,290
like a loop and always requesting other

00:41:44,680 --> 00:41:52,210
stuff from a nested from a nested object

00:41:47,290 --> 00:41:56,200
which can get very big so very short a

00:41:52,210 --> 00:41:59,470
summary so graph KL solves some problems

00:41:56,200 --> 00:42:02,020
that rest has particularly for web

00:41:59,470 --> 00:42:04,180
applications and for mobile applications

00:42:02,020 --> 00:42:07,990
as well you can also use this stuff in a

00:42:04,180 --> 00:42:09,790
android app or in an iOS app and you

00:42:07,990 --> 00:42:13,800
will get faster results because you can

00:42:09,790 --> 00:42:15,940
instead of three instead of three

00:42:13,800 --> 00:42:18,040
requests to the server you only need to

00:42:15,940 --> 00:42:19,569
do one and you get exactly the data you

00:42:18,040 --> 00:42:22,239
need so you don't you need to

00:42:19,569 --> 00:42:25,779
download less if you have a lot of like

00:42:22,239 --> 00:42:27,219
if you have a very big data model you

00:42:25,779 --> 00:42:30,369
only download the fields that you need

00:42:27,219 --> 00:42:32,499
so this can make a big difference then

00:42:30,369 --> 00:42:35,170
graph koel has its own schema definition

00:42:32,499 --> 00:42:38,289
you have queries you have mutations you

00:42:35,170 --> 00:42:41,819
have post types and then you define

00:42:38,289 --> 00:42:44,469
operations for it

00:42:41,819 --> 00:42:47,529
so for Chango I'm not aware of any other

00:42:44,469 --> 00:42:49,890
implementation that's used that can be

00:42:47,529 --> 00:42:54,519
used in production apart for graphene

00:42:49,890 --> 00:42:55,989
and yeah Apollo is for a bigger project

00:42:54,519 --> 00:43:01,140
you will probably want to use a polo

00:42:55,989 --> 00:43:01,140
okay so any questions or any yeah

00:43:13,369 --> 00:43:21,680
yeah yeah you can so the Facebook the

00:43:18,289 --> 00:43:24,109
Facebook implementation they're really

00:43:21,680 --> 00:43:28,609
the the Facebook implementation of graph

00:43:24,109 --> 00:43:31,190
coil has some default arguments that you

00:43:28,609 --> 00:43:35,359
can pass it that takes care of filtering

00:43:31,190 --> 00:43:38,660
of ordering and this kind of stuff if

00:43:35,359 --> 00:43:40,579
you use this particular library you get

00:43:38,660 --> 00:43:43,579
it for free and for example a Apollo

00:43:40,579 --> 00:43:46,670
client still expects this kind of

00:43:43,579 --> 00:43:48,950
structure by default you can also use it

00:43:46,670 --> 00:43:51,140
in graphene or you can do it yourself

00:43:48,950 --> 00:43:53,930
for example you pass an extra argument

00:43:51,140 --> 00:43:55,999
which is called ordering and then you

00:43:53,930 --> 00:43:57,859
put it to a string for example and then

00:43:55,999 --> 00:44:02,359
you order it in your application so you

00:43:57,859 --> 00:44:06,109
would do this in your Python code so

00:44:02,359 --> 00:44:08,660
here for example here instead of just

00:44:06,109 --> 00:44:11,630
passing the posts and ordered you could

00:44:08,660 --> 00:44:13,609
just take in one additional argument to

00:44:11,630 --> 00:44:17,900
the query and then you use this argument

00:44:13,609 --> 00:44:20,900
to to do some filtering or to do a to do

00:44:17,900 --> 00:44:24,950
a ordering on your on your Chango or m

00:44:20,900 --> 00:44:27,289
object so this can be added and it's all

00:44:24,950 --> 00:44:29,589
it already exists in some some libraries

00:44:27,289 --> 00:44:29,589
as well

00:44:45,990 --> 00:44:48,710
yeah

00:44:51,080 --> 00:44:54,940
I think it's probably not a good use

00:44:53,150 --> 00:44:58,400
case because you would have to implement

00:44:54,940 --> 00:45:00,800
the back end in your client so probably

00:44:58,400 --> 00:45:03,530
it's easier to to have some JavaScript

00:45:00,800 --> 00:45:07,370
functions to load the Chasen and to do

00:45:03,530 --> 00:45:08,870
the ordering and the filtering there no

00:45:07,370 --> 00:45:10,640
I don't think it's a good use case I

00:45:08,870 --> 00:45:12,470
wouldn't do it for that because you

00:45:10,640 --> 00:45:14,240
would have to implement the filter

00:45:12,470 --> 00:45:18,260
function and the ordering function in

00:45:14,240 --> 00:45:20,000
JavaScript in your client anyway make

00:45:18,260 --> 00:45:22,040
sense and if you do that

00:45:20,000 --> 00:45:26,540
it's easier to just use something like

00:45:22,040 --> 00:45:29,600
lodash to do the ordering directly so

00:45:26,540 --> 00:45:31,730
graft well really shines when you talk

00:45:29,600 --> 00:45:34,960
to a back-end which has a nested

00:45:31,730 --> 00:45:34,960
structure just the main use case

00:45:48,769 --> 00:45:55,049
I'm not aware of such a tool under

00:45:52,349 --> 00:45:57,659
standard ways to to hard-code to query

00:45:55,049 --> 00:46:02,509
and then you use variables to replace

00:45:57,659 --> 00:46:07,649
stuff which is probably good practice

00:46:02,509 --> 00:46:10,109
because then the client cannot I mean

00:46:07,649 --> 00:46:12,509
this is a secure way to to keep control

00:46:10,109 --> 00:46:16,919
of your queries because only certain

00:46:12,509 --> 00:46:18,419
variables can be replaced and it's the

00:46:16,919 --> 00:46:23,039
client is not in control of the whole

00:46:18,419 --> 00:46:24,389
graph query and usually I mean usually

00:46:23,039 --> 00:46:27,029
there's no need for this so I haven't

00:46:24,389 --> 00:46:28,529
haven't haven't seen a use case for it

00:46:27,029 --> 00:46:30,619
but what would be the use case for

00:46:28,529 --> 00:46:30,619
example

00:46:38,740 --> 00:46:44,560
the query is defined in in JavaScript so

00:46:42,670 --> 00:46:49,390
I hard-coded it here but you could also

00:46:44,560 --> 00:46:55,810
put it in a separate file yeah everyone

00:46:49,390 --> 00:47:13,950
can change it it's true it's true that's

00:46:55,810 --> 00:47:13,950
true that's true yeah yeah yeah yeah

00:47:18,060 --> 00:47:27,720
yeah yeah yeah no I understand the

00:47:24,990 --> 00:47:30,390
concern but I'm not aware of a tool and

00:47:27,720 --> 00:47:32,250
the ways I've seen it usually it's put

00:47:30,390 --> 00:47:36,150
in a separate file which has like a dot

00:47:32,250 --> 00:47:37,950
graph QL and then your build system web

00:47:36,150 --> 00:47:40,170
pack or whatever we'll we'll pull it

00:47:37,950 --> 00:47:42,350
from those files and add it to the

00:47:40,170 --> 00:47:44,430
JavaScript files in the right place and

00:47:42,350 --> 00:47:46,410
the cleanest solution is to have

00:47:44,430 --> 00:47:49,200
variables and then you replace them as

00:47:46,410 --> 00:47:52,200
you need them like here you just pass

00:47:49,200 --> 00:47:54,720
pass an object and this will this will

00:47:52,200 --> 00:47:57,140
be inserted here into the into the

00:47:54,720 --> 00:47:57,140
various

00:48:18,220 --> 00:48:22,670

YouTube URL: https://www.youtube.com/watch?v=WKPgXdfuyvc


