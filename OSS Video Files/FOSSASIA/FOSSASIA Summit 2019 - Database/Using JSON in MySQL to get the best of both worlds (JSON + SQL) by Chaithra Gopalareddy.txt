Title: Using JSON in MySQL to get the best of both worlds (JSON + SQL) by Chaithra Gopalareddy
Publication date: 2019-03-22
Playlist: FOSSASIA Summit 2019 - Database
Description: 
	16 March 2019 16:15, Training Room 2-1

JSON functionality in MySQL was introduced in version 5.7. With the latest 8.0 release, a lot of new functionality is added like the JSON_TABLE function, JSON aggregation functions etc which will enable developers to get the best of both worlds; one can store data in JSON but at the same time leverage the power of SQL. In this presentation, we will see how that can be done.
Captions: 
	00:00:02,449 --> 00:00:10,320
thanks for staying I know it's been a

00:00:04,950 --> 00:00:12,450
long day so I'm chakra developer with my

00:00:10,320 --> 00:00:15,030
skill of diversity and today we're

00:00:12,450 --> 00:00:17,299
talking about how one can uses too early

00:00:15,030 --> 00:00:17,299
JC

00:00:19,370 --> 00:00:21,940
statement

00:00:22,610 --> 00:00:26,840
okay so that's that's enough for today

00:00:24,170 --> 00:00:30,710
so I'll be briefly talking about Jason

00:00:26,840 --> 00:00:32,900
format they want to how Jason the

00:00:30,710 --> 00:00:35,600
supportive MySQL that's followed by

00:00:32,900 --> 00:00:37,220
their new Jason functions which can be

00:00:35,600 --> 00:00:43,610
used to convert Jason theta to

00:00:37,220 --> 00:00:45,739
relational and back to Jason so I guess

00:00:43,610 --> 00:00:48,879
most of us know what Jason stands for

00:00:45,739 --> 00:00:52,160
it's the JavaScript or computation and

00:00:48,879 --> 00:00:56,449
the primary structural unit of a Jason

00:00:52,160 --> 00:00:58,970
is an object I have an example here so

00:00:56,449 --> 00:01:01,580
the object taste object has a list of

00:00:58,970 --> 00:01:04,699
key value pairs and the keys and the

00:01:01,580 --> 00:01:07,310
values are separated by a colon and the

00:01:04,699 --> 00:01:09,470
key is usually a string and then the

00:01:07,310 --> 00:01:13,100
value circuit evaluation be a string or

00:01:09,470 --> 00:01:15,470
a number or another JSON object or JSON

00:01:13,100 --> 00:01:18,710
array so the second structure is the

00:01:15,470 --> 00:01:22,400
disk array so jason array has a list of

00:01:18,710 --> 00:01:24,680
values separated by commas so as I said

00:01:22,400 --> 00:01:27,560
each of this value can be internally as

00:01:24,680 --> 00:01:29,870
an object or a Jason hi so this this is

00:01:27,560 --> 00:01:32,270
called nested values so I have an

00:01:29,870 --> 00:01:34,610
example here the first one is the Jason

00:01:32,270 --> 00:01:37,190
array having the Jason object as value

00:01:34,610 --> 00:01:39,710
and the second one is a Jason object how

00:01:37,190 --> 00:01:41,930
we Jason arrangement so these are all

00:01:39,710 --> 00:01:42,990
listed values we look into how we can

00:01:41,930 --> 00:01:49,049
use is

00:01:42,990 --> 00:01:50,729
these data so we look into how what what

00:01:49,049 --> 00:01:54,390
kind of support we have in my sphere for

00:01:50,729 --> 00:01:56,340
handling Jason theta so we interview

00:01:54,390 --> 00:01:58,560
station featuring my screen five seven

00:01:56,340 --> 00:02:00,930
there were three parts to it the first

00:01:58,560 --> 00:02:02,789
is the Jason data type and the second is

00:02:00,930 --> 00:02:05,750
a set of Jason functions which can be

00:02:02,789 --> 00:02:08,280
used to create modify and query the data

00:02:05,750 --> 00:02:10,440
and the third is a generated column

00:02:08,280 --> 00:02:15,299
feature so the generated bottom helps

00:02:10,440 --> 00:02:18,019
you to index Kentucky images so first I

00:02:15,299 --> 00:02:21,269
will briefly look at the trees data type

00:02:18,019 --> 00:02:23,910
so why has separate data done you can

00:02:21,269 --> 00:02:28,200
ask them store these data in a text

00:02:23,910 --> 00:02:30,780
column but my skewer the has its own

00:02:28,200 --> 00:02:33,360
datatype Jason and this is the story

00:02:30,780 --> 00:02:35,040
internally as a block so what advantage

00:02:33,360 --> 00:02:38,010
do we get having to separate the data

00:02:35,040 --> 00:02:39,660
the first is the automatic validation of

00:02:38,010 --> 00:02:42,090
your Jason theta so when you insert a

00:02:39,660 --> 00:02:44,190
data if the jason theta is invalid it

00:02:42,090 --> 00:02:45,540
raises an error so our insertion itself

00:02:44,190 --> 00:02:49,980
you will get to know whether imitation

00:02:45,540 --> 00:02:51,560
is a valid JSON object or a gs-9 then

00:02:49,980 --> 00:02:54,920
the second advantage is

00:02:51,560 --> 00:02:56,630
internally stored as broth we have we

00:02:54,920 --> 00:02:58,580
have easy access to the keys and the

00:02:56,630 --> 00:03:00,530
binding members so you will see the

00:02:58,580 --> 00:03:03,950
difference between storing it as a txt

00:03:00,530 --> 00:03:06,709
and storing it as oh geez so I have two

00:03:03,950 --> 00:03:09,020
examples here we are creating two tables

00:03:06,709 --> 00:03:11,510
one Byzantine object we have inserted a

00:03:09,020 --> 00:03:13,640
g-spot change another one and so Jason

00:03:11,510 --> 00:03:15,590
Eric so the first one is the information

00:03:13,640 --> 00:03:19,340
about people which has ID and the name

00:03:15,590 --> 00:03:21,739
so I insert it like this I mean any SQL

00:03:19,340 --> 00:03:24,019
statement and then you do our extra

00:03:21,739 --> 00:03:27,410
people you get a discount change then

00:03:24,019 --> 00:03:31,660
you have a table or jobs which has job

00:03:27,410 --> 00:03:34,190
in for jason bottom and it has a Jason I

00:03:31,660 --> 00:03:37,340
so universally spoken charts and then

00:03:34,190 --> 00:04:19,489
you get this line so that's about Jason

00:03:37,340 --> 00:04:21,530
either time so the data is changing so

00:04:19,489 --> 00:04:25,310
what happens if I have okay the over

00:04:21,530 --> 00:04:28,040
data has only ideally the div data also

00:04:25,310 --> 00:04:30,680
has an address so we have been

00:04:28,040 --> 00:04:34,160
the New Haven has additional member or

00:04:30,680 --> 00:04:36,380
address now we want to insert this

00:04:34,160 --> 00:04:38,270
member into the more data so the

00:04:36,380 --> 00:04:41,510
existing old Jason data doesn't have

00:04:38,270 --> 00:04:43,340
this address paper so what do you you

00:04:41,510 --> 00:04:45,890
have a function to help you do that so

00:04:43,340 --> 00:04:48,500
you are playing your table which is

00:04:45,890 --> 00:04:50,870
insert function takes three arguments

00:04:48,500 --> 00:04:53,270
basically the first one being the Jason

00:04:50,870 --> 00:04:55,100
document which needs to be updated and

00:04:53,270 --> 00:04:58,730
the second one is the part which needs

00:04:55,100 --> 00:05:00,230
to be inserted so it what this consent

00:04:58,730 --> 00:05:02,540
does is it searches for all the

00:05:00,230 --> 00:05:05,330
documents if the path that we specify

00:05:02,540 --> 00:05:06,620
here is not found and it is going to

00:05:05,330 --> 00:05:08,450
insert that part for you

00:05:06,620 --> 00:05:11,350
and then it will initialize the value

00:05:08,450 --> 00:05:11,350
with whatever is given

00:05:14,770 --> 00:05:23,740
so that that's what you see inside us so

00:05:18,310 --> 00:05:27,130
now if we want to update this address to

00:05:23,740 --> 00:05:29,050
something that is not none basically so

00:05:27,130 --> 00:05:29,740
you want to you might want to use days

00:05:29,050 --> 00:05:31,569
movies

00:05:29,740 --> 00:05:34,449
so what a city police does is if the

00:05:31,569 --> 00:05:37,539
path exists so with if this path inside

00:05:34,449 --> 00:05:39,880
your document exists then it is going to

00:05:37,539 --> 00:05:43,419
update with the new one so you see that

00:05:39,880 --> 00:05:47,590
the both documents have addressed with

00:05:43,419 --> 00:05:49,720
you the next one is so once you have

00:05:47,590 --> 00:05:52,000
added the data updated the data and you

00:05:49,720 --> 00:05:54,130
want to delete the data as well so you

00:05:52,000 --> 00:05:57,159
can use this with remove which actually

00:05:54,130 --> 00:05:59,710
removes this path from this document so

00:05:57,159 --> 00:06:02,560
you have now gone back to the border

00:05:59,710 --> 00:06:04,780
format where the idea name you do not

00:06:02,560 --> 00:06:06,310
have addressed anymore so this can be

00:06:04,780 --> 00:06:08,620
used and we have couple of more

00:06:06,310 --> 00:06:10,690
functions like Jason set which does

00:06:08,620 --> 00:06:13,900
Jason insert and Jason Terry please

00:06:10,690 --> 00:06:15,819
together Solaris I mean plenty of more

00:06:13,900 --> 00:06:17,890
functions are there so you can use based

00:06:15,819 --> 00:06:22,930
on whatever is the needful

00:06:17,890 --> 00:06:22,930
so I talked about the button

00:06:23,490 --> 00:06:28,139
okay so once you have created the data

00:06:26,460 --> 00:06:30,750
are modifying the data and now if you

00:06:28,139 --> 00:06:34,110
want to query the data so there are

00:06:30,750 --> 00:06:36,180
again not many number of functions to do

00:06:34,110 --> 00:06:38,009
the same constituted on three of them

00:06:36,180 --> 00:06:40,080
you are so the first one is a jason

00:06:38,009 --> 00:06:42,660
extract function what what does it do

00:06:40,080 --> 00:06:47,039
it extracts the value for a particular

00:06:42,660 --> 00:06:49,800
path inside your documents so here I try

00:06:47,039 --> 00:06:52,289
to extract this path in the RJ's

00:06:49,800 --> 00:06:56,669
documenting for I want to look into a

00:06:52,289 --> 00:06:58,620
vapor named name and then you get back

00:06:56,669 --> 00:07:01,229
the value so in this query I'm trying to

00:06:58,620 --> 00:07:03,900
move a brother but you would chain if it

00:07:01,229 --> 00:07:06,259
is J if it matches then I'll get upon if

00:07:03,900 --> 00:07:09,120
it does match because the second the

00:07:06,259 --> 00:07:12,060
document did not have G so you can see

00:07:09,120 --> 00:07:14,340
so this is extract can also be used

00:07:12,060 --> 00:07:16,740
there was a shorthand for the C for your

00:07:14,340 --> 00:07:18,930
readability purpose you can use this as

00:07:16,740 --> 00:07:20,639
well there are AMA so now the left side

00:07:18,930 --> 00:07:22,500
is a column which is bottom on the right

00:07:20,639 --> 00:07:24,659
hand side is the path and then you can

00:07:22,500 --> 00:07:26,940
just do select info on this can be used

00:07:24,659 --> 00:07:30,229
in your where process to filter out you

00:07:26,940 --> 00:07:33,330
know get the data that is required below

00:07:30,229 --> 00:07:35,280
the next one is Jason countries so this

00:07:33,330 --> 00:07:37,850
is contains actually tells whether a

00:07:35,280 --> 00:07:40,550
particular value is found inside

00:07:37,850 --> 00:07:42,410
government so you have this array here

00:07:40,550 --> 00:07:45,350
developer on supporting jr. which was

00:07:42,410 --> 00:07:47,660
there enough job info string get a one

00:07:45,350 --> 00:07:49,280
for that so this returns a true or false

00:07:47,660 --> 00:07:52,130
whether a particular body was found in a

00:07:49,280 --> 00:07:54,350
time which is you document or not so the

00:07:52,130 --> 00:07:56,120
nice this Jason search jason search

00:07:54,350 --> 00:07:58,040
helps you to find a path for a

00:07:56,120 --> 00:08:00,500
particular value so you are searching

00:07:58,040 --> 00:08:02,690
for a value a person name changing above

00:08:00,500 --> 00:08:04,880
in adjacent document it is going to

00:08:02,690 --> 00:08:07,480
return the path for you so you you see

00:08:04,880 --> 00:08:09,830
that the first row first document had

00:08:07,480 --> 00:08:11,810
attained so you create the path to that

00:08:09,830 --> 00:08:18,670
and the next door which is not have it

00:08:11,810 --> 00:08:22,370
so you get yes so I get that so you have

00:08:18,670 --> 00:08:25,610
the second document which is one or all

00:08:22,370 --> 00:08:28,400
so one means return immediately after

00:08:25,610 --> 00:08:31,490
you find the first part to it so the all

00:08:28,400 --> 00:08:33,169
means it is going to search every single

00:08:31,490 --> 00:08:37,370
path and then give you all the paths

00:08:33,169 --> 00:08:40,070
together okay so with these functions we

00:08:37,370 --> 00:08:42,200
have plenty more I have listed down so

00:08:40,070 --> 00:08:44,210
there are all these functions that you

00:08:42,200 --> 00:08:47,180
can take advantage of so along with

00:08:44,210 --> 00:08:48,710
varying modifying creation and

00:08:47,180 --> 00:08:50,540
everything you also have utility

00:08:48,710 --> 00:08:53,540
functions like Jason pretty which will

00:08:50,540 --> 00:08:55,520
pretty print your JSON documents then it

00:08:53,540 --> 00:08:56,870
is this Jason palette which is going to

00:08:55,520 --> 00:08:59,220
tell you whether it is a very J's

00:08:56,870 --> 00:09:01,500
document or not so on and so forth

00:08:59,220 --> 00:09:03,570
I mean there's it's pretty extensive for

00:09:01,500 --> 00:09:04,380
you to play around and see what suits

00:09:03,570 --> 00:09:07,860
you best

00:09:04,380 --> 00:09:10,290
so that's about the 5-7 support so now

00:09:07,860 --> 00:09:13,110
we want to watch the you need auto the

00:09:10,290 --> 00:09:14,790
most powerful Jason function which will

00:09:13,110 --> 00:09:16,500
help you to convert geez they try to

00:09:14,790 --> 00:09:19,100
relational and then you know they might

00:09:16,500 --> 00:09:22,590
take advantage of all the SQL operations

00:09:19,100 --> 00:09:24,600
so that's the recent table function so

00:09:22,590 --> 00:09:26,910
Jason Taylor function is the first table

00:09:24,600 --> 00:09:28,980
function it's not says it doesn't return

00:09:26,910 --> 00:09:31,020
a scalar set it actually disappear

00:09:28,980 --> 00:09:33,720
answer is all set which can be used as a

00:09:31,020 --> 00:09:38,130
table so okay let's see let's go through

00:09:33,720 --> 00:09:40,500
this example so I have this data about

00:09:38,130 --> 00:09:42,900
people which has names and addresses and

00:09:40,500 --> 00:09:45,300
everything now I want to visualize this

00:09:42,900 --> 00:09:47,790
into a relational table like this which

00:09:45,300 --> 00:09:50,490
has two columns leave an address and

00:09:47,790 --> 00:09:53,100
then I have the names and then each row

00:09:50,490 --> 00:09:56,190
being created for every year name that

00:09:53,100 --> 00:09:58,560
is found okay so now what what do you

00:09:56,190 --> 00:10:00,660
get by doing this you can start doing

00:09:58,560 --> 00:10:03,390
all the Malaysian operations on having

00:10:00,660 --> 00:10:04,110
their SQL operations on this so how do

00:10:03,390 --> 00:10:07,149
you do this

00:10:04,110 --> 00:10:07,149
[Music]

00:10:07,150 --> 00:10:11,440
hang of it so you just do a select star

00:10:09,370 --> 00:10:14,040
from g1 the table where the Jason

00:10:11,440 --> 00:10:16,990
documents are present and then write the

00:10:14,040 --> 00:10:18,220
Evoque adjacent table function so Jason

00:10:16,990 --> 00:10:20,920
save a function first you need to

00:10:18,220 --> 00:10:21,520
mention from where the data is coming

00:10:20,920 --> 00:10:23,590
from

00:10:21,520 --> 00:10:25,840
so that's your Jason column so Jason

00:10:23,590 --> 00:10:27,610
column then you say that if you know the

00:10:25,840 --> 00:10:29,230
power of already see in this case I know

00:10:27,610 --> 00:10:31,810
that it is there I want to extract

00:10:29,230 --> 00:10:33,730
information from people data so I will

00:10:31,810 --> 00:10:36,910
give the path so I'll just talk a bit

00:10:33,730 --> 00:10:38,920
more about the path the dollar symbol or

00:10:36,910 --> 00:10:41,230
the census and say said that's the route

00:10:38,920 --> 00:10:43,480
that's where I'm starting to look for I

00:10:41,230 --> 00:10:46,150
think a dot means that it is an object

00:10:43,480 --> 00:10:50,800
so it will be followed by a healing so

00:10:46,150 --> 00:10:52,960
that is your finger inside your Jason

00:10:50,800 --> 00:10:55,650
column I'm looking for member name

00:10:52,960 --> 00:10:58,030
people and then inside this array

00:10:55,650 --> 00:10:59,860
everything I want you to search for all

00:10:58,030 --> 00:11:01,270
the data inside this so you can mention

00:10:59,860 --> 00:11:03,640
the path though if you do not know the

00:11:01,270 --> 00:11:06,700
path you can just say start here itself

00:11:03,640 --> 00:11:09,450
so then that is followed by as I said as

00:11:06,700 --> 00:11:11,950
you see here we have two dimensions here

00:11:09,450 --> 00:11:14,430
created from this particular data one is

00:11:11,950 --> 00:11:17,470
the columns and the second is the rows

00:11:14,430 --> 00:11:19,270
so how do you tell Jason table to create

00:11:17,470 --> 00:11:20,830
that so you mention the columns and

00:11:19,270 --> 00:11:23,830
their paths from where to extract from

00:11:20,830 --> 00:11:26,500
so I'm going to make a column name name

00:11:23,830 --> 00:11:28,720
and then what's the type of it and then

00:11:26,500 --> 00:11:30,370
you will keep the path inside this

00:11:28,720 --> 00:11:31,990
document this is the path I'm looking

00:11:30,370 --> 00:11:34,360
for this is where you want to get the

00:11:31,990 --> 00:11:37,300
from so then you have the address and

00:11:34,360 --> 00:11:39,700
then you get the path for that that is

00:11:37,300 --> 00:11:41,649
followed by your table so now once you

00:11:39,700 --> 00:11:43,810
give the table in that yes you can use

00:11:41,649 --> 00:11:47,010
that and then start using all the skill

00:11:43,810 --> 00:11:47,010
operations yes

00:11:49,600 --> 00:11:55,180
this one yeah so you have particular set

00:11:53,050 --> 00:11:58,120
up data types that are being supported I

00:11:55,180 --> 00:12:00,280
think it is going to error out if at all

00:11:58,120 --> 00:12:02,620
there is no supported data that say for

00:12:00,280 --> 00:12:04,720
example our along with the standard data

00:12:02,620 --> 00:12:06,670
types we also support eight-time and

00:12:04,720 --> 00:12:08,410
things like that so anything that is

00:12:06,670 --> 00:12:12,940
supported it is going to be taken as

00:12:08,410 --> 00:12:15,850
voices so that's about it so what

00:12:12,940 --> 00:12:18,310
happens now so you can start doing all

00:12:15,850 --> 00:12:20,950
the relational operations that you can

00:12:18,310 --> 00:12:23,920
leverage so here you see that we can

00:12:20,950 --> 00:12:25,690
start using this data and then say where

00:12:23,920 --> 00:12:28,510
people don't mean like John so you will

00:12:25,690 --> 00:12:31,630
get all the rows with starting name John

00:12:28,510 --> 00:12:35,530
so what we had previously was three rows

00:12:31,630 --> 00:12:36,880
now it's filtered and you get this so

00:12:35,530 --> 00:12:40,440
this is what you can do once you can

00:12:36,880 --> 00:12:40,440
whatever jacent a time to creation

00:12:40,520 --> 00:12:46,310
okay so not all the time your JSON data

00:12:44,089 --> 00:12:48,380
is simple and straightforward you will

00:12:46,310 --> 00:12:51,890
have all this disdain areas listed paths

00:12:48,380 --> 00:12:56,779
and you want to extract this listed data

00:12:51,890 --> 00:12:59,600
as well into a relationship even so I

00:12:56,779 --> 00:13:01,399
have this data of father mother and then

00:12:59,600 --> 00:13:04,450
the marriage traitor there is another

00:13:01,399 --> 00:13:09,140
set of data regarding the children and

00:13:04,450 --> 00:13:14,209
so what I want to visualize is this each

00:13:09,140 --> 00:13:30,920
child inside this has a broken spoon so

00:13:14,209 --> 00:13:34,130
what you do there because you have this

00:13:30,920 --> 00:13:37,630
ability will you also see the additional

00:13:34,130 --> 00:13:40,630
information just pop in this document so

00:13:37,630 --> 00:13:40,630
he's

00:14:07,930 --> 00:14:12,770
followed by the part inside this family

00:14:11,210 --> 00:14:15,470
so you rock you want to look into

00:14:12,770 --> 00:14:18,020
everything then you specify the columns

00:14:15,470 --> 00:14:19,790
so the first one is ie for out an

00:14:18,020 --> 00:14:21,440
ordinary T so once you've mentioned this

00:14:19,790 --> 00:14:23,270
there is a 90 that is being generated

00:14:21,440 --> 00:14:25,250
for every row that is extracted from

00:14:23,270 --> 00:14:27,680
here then you mention the path for the

00:14:25,250 --> 00:14:30,440
father so you get this information then

00:14:27,680 --> 00:14:32,360
you also say ok whether the my mind

00:14:30,440 --> 00:14:34,459
status so if there is a my hd8

00:14:32,360 --> 00:14:37,070
date then that means that the person is

00:14:34,459 --> 00:14:40,730
married so you indicate it by one so for

00:14:37,070 --> 00:14:42,770
the second name you do not have a valid

00:14:40,730 --> 00:14:45,760
marriage date so you get a zero here so

00:14:42,770 --> 00:14:48,830
you can exist even use the sexist car

00:14:45,760 --> 00:14:51,950
then you have mentioned the nested path

00:14:48,830 --> 00:14:54,050
so which is they go into inside this you

00:14:51,950 --> 00:14:56,240
want to get into the children's data and

00:14:54,050 --> 00:14:58,399
then create columns for each of those so

00:14:56,240 --> 00:15:00,860
the child ID which is a four or analogy

00:14:58,399 --> 00:15:03,770
then you have the child's name then you

00:15:00,860 --> 00:15:06,830
have the age so what can you do now with

00:15:03,770 --> 00:15:09,950
this data you again can leverage it you

00:15:06,830 --> 00:15:12,620
use or the SQL operation so here I am

00:15:09,950 --> 00:15:15,080
trying to aggregate the age of the

00:15:12,620 --> 00:15:16,790
children so you can do that so you are

00:15:15,080 --> 00:15:17,470
doing the number of children pounds and

00:15:16,790 --> 00:15:20,080
then you

00:15:17,470 --> 00:15:25,300
average so that's what Jason to break

00:15:20,080 --> 00:15:28,120
into frame okay so now you have the data

00:15:25,300 --> 00:15:30,040
into like a traditional home at how do

00:15:28,120 --> 00:15:33,280
you get back to the Jason so you want to

00:15:30,040 --> 00:15:34,900
store the data back so you have

00:15:33,280 --> 00:15:36,550
something called Jason aggregations

00:15:34,900 --> 00:15:38,590
that's you in age and it does I think

00:15:36,550 --> 00:15:41,500
forty two five seven as well

00:15:38,590 --> 00:15:43,510
so we have two functions to aggregation

00:15:41,500 --> 00:15:45,130
functions Molly situation I react and

00:15:43,510 --> 00:15:47,680
the other is a JSON object

00:15:45,130 --> 00:15:52,180
so the Aria actually creates an array

00:15:47,680 --> 00:15:54,010
for you against although JSON objects

00:15:52,180 --> 00:15:56,590
then creates an array for you and then

00:15:54,010 --> 00:15:59,560
the object a creates of objects

00:15:56,590 --> 00:16:03,340
ivanishin so you can use goodbye and

00:15:59,560 --> 00:16:05,260
then you know use the abbreviations so

00:16:03,340 --> 00:16:07,420
using this aggregation function you can

00:16:05,260 --> 00:16:09,160
put back the jason theta

00:16:07,420 --> 00:16:12,820
having done the relational data back to

00:16:09,160 --> 00:16:15,280
the reason for that so i have your query

00:16:12,820 --> 00:16:17,920
which does the same so you see that the

00:16:15,280 --> 00:16:19,810
third name that we had originally is

00:16:17,920 --> 00:16:22,420
missing here so you have only the john

00:16:19,810 --> 00:16:25,380
smith and john johnson so how do you do

00:16:22,420 --> 00:16:28,180
that you have you have your jason segel

00:16:25,380 --> 00:16:30,639
function here and then you you say that

00:16:28,180 --> 00:16:33,489
okay i want to create an array of this

00:16:30,639 --> 00:16:35,920
using the name and address and then I

00:16:33,489 --> 00:16:39,220
want to know if we stayed up so it's a

00:16:35,920 --> 00:16:41,049
similar stuff so I will show you how we

00:16:39,220 --> 00:16:44,499
can't be done with the nested arrays as

00:16:41,049 --> 00:16:46,329
well so see here so what we have here is

00:16:44,499 --> 00:16:48,160
along with the original data you also

00:16:46,329 --> 00:16:50,110
have the average age that we just

00:16:48,160 --> 00:16:52,179
calculated and then the number of

00:16:50,110 --> 00:16:54,999
children as well so how do you do that

00:16:52,179 --> 00:16:56,679
you you have your JCT will function to

00:16:54,999 --> 00:16:59,410
extract the data in relational format

00:16:56,679 --> 00:17:02,019
and now you use average and bound and

00:16:59,410 --> 00:17:04,630
then you got the ages advance and then

00:17:02,019 --> 00:17:06,699
you merge it to the family data so you

00:17:04,630 --> 00:17:09,250
use this much match which will merge

00:17:06,699 --> 00:17:11,860
into the old existing family data and

00:17:09,250 --> 00:17:13,839
then to get this family of change which

00:17:11,860 --> 00:17:15,399
now has along with the children being

00:17:13,839 --> 00:17:19,209
father mother and manager

00:17:15,399 --> 00:17:23,850
it also has aggregated data like the

00:17:19,209 --> 00:17:27,399
average age and in children so on so

00:17:23,850 --> 00:17:31,649
that's about my presentation that's all

00:17:27,399 --> 00:17:31,649
I had so if you have any questions

00:17:39,990 --> 00:17:44,670
can you tell to the face time

00:17:51,480 --> 00:17:59,789
so from you about the party yes sure

00:17:55,919 --> 00:18:03,539
that the first one has a dress now

00:17:59,789 --> 00:18:07,289
yes the second one has a dress is it

00:18:03,539 --> 00:18:13,860
possible to have the first row because I

00:18:07,289 --> 00:18:15,870
have and not to have a dress you you you

00:18:13,860 --> 00:18:18,090
did not have a dress before I'm trying

00:18:15,870 --> 00:18:19,769
to update it to have a dress here so

00:18:18,090 --> 00:18:28,100
what do you want to do now you want to

00:18:19,769 --> 00:18:30,389
date it yes you do yes you can specify

00:18:28,100 --> 00:18:33,480
Jason Terry oh and then you have a wear

00:18:30,389 --> 00:18:38,159
drawers you have a pair and then specify

00:18:33,480 --> 00:18:41,039
which document - so where you can query

00:18:38,159 --> 00:18:47,220
right you can use this so we're in for

00:18:41,039 --> 00:18:49,799
dot name equal to say Jane you don't

00:18:47,220 --> 00:18:52,380
want you don't want it only for Jane

00:18:49,799 --> 00:18:57,269
isn't it the first document so you can

00:18:52,380 --> 00:19:00,289
use Jason remove and then specify a way

00:18:57,269 --> 00:19:03,289
across here by March is only the first

00:19:00,289 --> 00:19:03,289
document

00:19:10,100 --> 00:19:18,279
yeah

00:19:12,700 --> 00:19:21,369
okay so okay no actually I think okay so

00:19:18,279 --> 00:19:23,440
Jason at extract is not written in 1 & 0

00:19:21,369 --> 00:19:26,259
Jason extract is actually returning a

00:19:23,440 --> 00:19:29,559
value found in that path and I have a

00:19:26,259 --> 00:19:32,470
new hat across here with Jane so if this

00:19:29,559 --> 00:19:35,409
one returns Jane Jane for the first row

00:19:32,470 --> 00:19:37,149
and then it reaches and this one just

00:19:35,409 --> 00:19:39,899
returns true or false based on the

00:19:37,149 --> 00:19:39,899
wiring as well

00:19:50,200 --> 00:19:52,770
yes

00:20:01,420 --> 00:20:08,500
if you want to avoid it say for example

00:20:03,700 --> 00:20:09,520
then I can use Jason search which can

00:20:08,500 --> 00:20:12,790
give you the paths

00:20:09,520 --> 00:20:14,530
if the path doesn't return now if the

00:20:12,790 --> 00:20:18,030
path returns null that means that the

00:20:14,530 --> 00:20:18,030
part of that part was not there

00:20:21,280 --> 00:20:26,370
and I'll be available I guess till 6:00

00:20:27,900 --> 00:20:33,200
[Music]

00:20:30,540 --> 00:20:33,200

YouTube URL: https://www.youtube.com/watch?v=PlYlYERtTWc


