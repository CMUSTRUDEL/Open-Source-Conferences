Title: Utilize and take advantage of Optimizer features in MySQL 8 0 by Amit Bhattachar
Publication date: 2019-03-22
Playlist: FOSSASIA Summit 2019 - Database
Description: 
	16 March 2019 15:00, Training Room 2-1

To run your application efficiently on cloud, you would need to make your queries faster. MySQL optimizer over the years have brought in a lot of improvements to handle big queries efficiently and in a faster way. This talk presents you a specific set of features added in MySQL 8.0 that would reduce the execution time of your queries. This session will help you understand tips and tricks that you can use to tune your application. This session would present the following

Cost Model Improvements

Newly added hints

Index Skip-Scan

Internal TempTable Storage Engine
Captions: 
	00:00:03,529 --> 00:00:10,860
yeah so you have heard a lot of

00:00:07,250 --> 00:00:12,929
discussions presentations about other

00:00:10,860 --> 00:00:13,910
components in my skill now let's talk

00:00:12,929 --> 00:00:19,890
about theories

00:00:13,910 --> 00:00:21,660
so I uncovered the new features that

00:00:19,890 --> 00:00:25,590
give implemented in the mice curated

00:00:21,660 --> 00:00:28,289
optimizer obviously it's not us I mean

00:00:25,590 --> 00:00:29,789
we don't have time 20 minutes it's time

00:00:28,289 --> 00:00:32,700
to cover all the features so I have

00:00:29,789 --> 00:00:36,570
selected a few of them so let's let's

00:00:32,700 --> 00:00:39,120
start with that this is the same our

00:00:36,570 --> 00:00:41,370
statement it says that whatever I say

00:00:39,120 --> 00:00:46,170
you cannot show Auto based on that so Oh

00:00:41,370 --> 00:00:48,600
so this PCC is that so let's just pick

00:00:46,170 --> 00:00:51,960
some time to do it Eclipse effect and

00:00:48,600 --> 00:00:55,050
move on to the next time so support from

00:00:51,960 --> 00:00:58,379
my colleagues my colleagues and whoever

00:00:55,050 --> 00:01:00,690
has worked with optimizer so rest of the

00:00:58,379 --> 00:01:03,539
folks have you heard about the optimizer

00:01:00,690 --> 00:01:06,180
in my scale and walked off and you

00:01:03,539 --> 00:01:08,479
optimized the features in my scale as

00:01:06,180 --> 00:01:08,479
such

00:01:13,180 --> 00:01:17,990
okay so yet so I was expecting this

00:01:15,740 --> 00:01:19,520
based on my previous experiences in

00:01:17,990 --> 00:01:22,810
Portia's here so I thought I'd just

00:01:19,520 --> 00:01:26,600
through a small recap of the basic step

00:01:22,810 --> 00:01:29,450
you can cover in the other so I took

00:01:26,600 --> 00:01:35,540
this example from one of the lots of

00:01:29,450 --> 00:01:37,850
Morgentaler so as a navigation system so

00:01:35,540 --> 00:01:40,369
what is it it's it's similar to

00:01:37,850 --> 00:01:42,110
something like this so you have source

00:01:40,369 --> 00:01:43,610
you have a destination and you want to

00:01:42,110 --> 00:01:47,840
reach your destination in the best

00:01:43,610 --> 00:01:53,810
possible way so this is similar to what

00:01:47,840 --> 00:01:57,910
optimizer does my skill so he finds out

00:01:53,810 --> 00:02:00,890
the best possible way to execute it and

00:01:57,910 --> 00:02:03,380
so it's similar to this map navigation

00:02:00,890 --> 00:02:05,270
system that we use in our day to day

00:02:03,380 --> 00:02:07,729
activities wherever you go wherever you

00:02:05,270 --> 00:02:11,660
have to find something else it's exactly

00:02:07,729 --> 00:02:15,620
similar to that so here is a small

00:02:11,660 --> 00:02:19,549
example like I have a crane which joins

00:02:15,620 --> 00:02:26,480
two tables and in fans of the city count

00:02:19,549 --> 00:02:30,140
of the number of cities in India so here

00:02:26,480 --> 00:02:32,600
it is not equating optimizer does so for

00:02:30,140 --> 00:02:35,060
each of the twenties or the tables that

00:02:32,600 --> 00:02:37,370
are involved in the queries the optimize

00:02:35,060 --> 00:02:40,130
are tries to collect these tactics and

00:02:37,370 --> 00:02:44,959
the metadata of those tables so now that

00:02:40,130 --> 00:02:46,720
it cannot find out the exact way the

00:02:44,959 --> 00:02:49,090
best possibility

00:02:46,720 --> 00:02:53,530
now what it does after getting those

00:02:49,090 --> 00:02:55,270
statistics is it generates a very

00:02:53,530 --> 00:02:58,060
execution time I mean it might generate

00:02:55,270 --> 00:03:00,970
a lot of query execution plans based on

00:02:58,060 --> 00:03:03,130
the statistics that it gets but the one

00:03:00,970 --> 00:03:05,830
that it chooses is the best possible

00:03:03,130 --> 00:03:08,680
plan to execute the claim so that's

00:03:05,830 --> 00:03:10,690
that's so that's how the optimizer works

00:03:08,680 --> 00:03:12,730
oh that's so we mean because the

00:03:10,690 --> 00:03:17,440
optimizer is the heart of a database so

00:03:12,730 --> 00:03:19,000
it's basically what helps us so at the

00:03:17,440 --> 00:03:21,580
end of the day thought 3 DB is the

00:03:19,000 --> 00:03:23,260
application developers on here modicum

00:03:21,580 --> 00:03:25,810
of the speed is how fast is really

00:03:23,260 --> 00:03:27,730
performing what are features that I can

00:03:25,810 --> 00:03:30,370
use inside the query and stuff like that

00:03:27,730 --> 00:03:33,730
so this is what the optimizer Cancer

00:03:30,370 --> 00:03:37,960
Center attack and at the end it gives

00:03:33,730 --> 00:03:41,500
you the results so it shows the count of

00:03:37,960 --> 00:03:43,780
cities in India so so so this is this is

00:03:41,500 --> 00:03:47,710
basically the job of the optimizer

00:03:43,780 --> 00:03:50,470
looks easy but it is not it's it's it's

00:03:47,710 --> 00:03:52,870
a very very complicated module in my

00:03:50,470 --> 00:03:55,840
sphere which takes care of all the

00:03:52,870 --> 00:03:59,520
things that we see and we never believe

00:03:55,840 --> 00:03:59,520
that okay this can be done so

00:04:00,040 --> 00:04:06,099
so yeah so when you cook with my skill

00:04:03,400 --> 00:04:09,819
organizer you have to know about a few

00:04:06,099 --> 00:04:13,420
of the terms that we use so the first is

00:04:09,819 --> 00:04:16,209
the cost so every grade has a cost

00:04:13,420 --> 00:04:18,760
involved in it and what the optimizer

00:04:16,209 --> 00:04:26,919
does is it calculates the costs of

00:04:18,760 --> 00:04:28,120
executing that pay so so 20 the gospel

00:04:26,919 --> 00:04:32,820
article you need that represents the

00:04:28,120 --> 00:04:36,600
resource usage for executing that way

00:04:32,820 --> 00:04:40,500
next comes the sprinkle so the explain

00:04:36,600 --> 00:04:42,120
that shows you the different ways that

00:04:40,500 --> 00:04:44,580
the optimizer is going to execute the

00:04:42,120 --> 00:04:46,980
breaks what is it what you do which

00:04:44,580 --> 00:04:49,530
tables it is going to join what is the

00:04:46,980 --> 00:04:52,770
joint order what the indexes that it's

00:04:49,530 --> 00:04:56,370
going to use so almost all those data

00:04:52,770 --> 00:04:59,190
can be found out from explain them now

00:04:56,370 --> 00:05:01,350
to get those data you need to have some

00:04:59,190 --> 00:05:03,720
information about the tables the columns

00:05:01,350 --> 00:05:06,240
that are part of the way so that

00:05:03,720 --> 00:05:09,540
information is retrieved from the meta

00:05:06,240 --> 00:05:11,370
greatest authority so the metadata

00:05:09,540 --> 00:05:13,260
should say see the information about the

00:05:11,370 --> 00:05:15,570
table like what the number of indexes

00:05:13,260 --> 00:05:17,490
that are there what is the nominal

00:05:15,570 --> 00:05:19,890
ability of the column stuff like that

00:05:17,490 --> 00:05:21,960
and the statistics says we have or the

00:05:19,890 --> 00:05:26,700
size of the table the cardinality of

00:05:21,960 --> 00:05:31,290
columns so these two are the very very

00:05:26,700 --> 00:05:35,460
important things that you need to

00:05:31,290 --> 00:05:38,370
generate the best possible now that

00:05:35,460 --> 00:05:40,740
happen the reason the basic reason is

00:05:38,370 --> 00:05:42,900
because you may not have the exact or

00:05:40,740 --> 00:05:46,140
for the updated statistics of the table

00:05:42,900 --> 00:05:47,630
so you might have come across many of

00:05:46,140 --> 00:05:50,390
the blogs or many of these

00:05:47,630 --> 00:05:52,610
the dpsing is that okay I Perry's not

00:05:50,390 --> 00:05:53,150
performing well my Aquarius people slow

00:05:52,610 --> 00:05:55,580
down

00:05:53,150 --> 00:05:57,590
and this basically basically most of the

00:05:55,580 --> 00:05:59,510
time the reason is because you may not

00:05:57,590 --> 00:06:01,700
have the first thing that we say is

00:05:59,510 --> 00:06:03,620
maybe they're not have the updated

00:06:01,700 --> 00:06:08,710
statistics about the table in function

00:06:03,620 --> 00:06:11,150
in orders so so these four things are

00:06:08,710 --> 00:06:15,490
the ones that are going to help you

00:06:11,150 --> 00:06:15,490
generate the solution

00:06:16,740 --> 00:06:24,010
yeah so so I've covered the optimization

00:06:20,470 --> 00:06:26,440
basics and so I also cover like three

00:06:24,010 --> 00:06:28,840
things and I've decided to speak what is

00:06:26,440 --> 00:06:29,410
index improvements you okay master hit

00:06:28,840 --> 00:06:31,030
in progress

00:06:29,410 --> 00:06:34,990
and something called us being dinner

00:06:31,030 --> 00:06:38,140
table story so global looking at the

00:06:34,990 --> 00:06:41,620
index improvements so I picked up the

00:06:38,140 --> 00:06:44,770
schema this is a vertex database schema

00:06:41,620 --> 00:06:47,320
which has the Jason columns in this this

00:06:44,770 --> 00:06:49,420
is feel available you can use it you can

00:06:47,320 --> 00:06:53,820
download it and you can use it in your I

00:06:49,420 --> 00:06:53,820
mean your projects or whatever you

00:06:58,050 --> 00:07:02,320
discuss and the solution that we have as

00:07:00,790 --> 00:07:08,350
to how we have implemented the solution

00:07:02,320 --> 00:07:11,280
in the occupied so let's talk about our

00:07:08,350 --> 00:07:14,140
genetics so what is the functional index

00:07:11,280 --> 00:07:16,450
has anyone worked in modular again the

00:07:14,140 --> 00:07:20,140
Hardy gave us so you must must be about

00:07:16,450 --> 00:07:24,230
constraints so and who are those about

00:07:20,140 --> 00:07:27,570
indexes in such not you guess

00:07:24,230 --> 00:07:27,960
it exists yeah you know what the Nexus

00:07:27,570 --> 00:07:30,060
right

00:07:27,960 --> 00:07:33,210
so created minutes on account but here

00:07:30,060 --> 00:07:35,820
what we're doing is creating an index

00:07:33,210 --> 00:07:38,430
where at least one of the index part is

00:07:35,820 --> 00:07:45,240
a function instead of a cop so you can

00:07:38,430 --> 00:07:51,120
have function defined on the index this

00:07:45,240 --> 00:07:54,000
is created on a function and the way to

00:07:51,120 --> 00:07:57,300
do it is just like any other syntax just

00:07:54,000 --> 00:08:01,860
that you have created X or the table and

00:07:57,300 --> 00:08:03,750
then so I think an example where I'm

00:08:01,860 --> 00:08:05,940
then going to find out the population of

00:08:03,750 --> 00:08:08,070
the city table based on certain range

00:08:05,940 --> 00:08:11,630
condition so this is my problem

00:08:08,070 --> 00:08:18,510
statement I have this schema which is

00:08:11,630 --> 00:08:20,900
this and I am going to find out certain

00:08:18,510 --> 00:08:20,900
ranges

00:08:24,469 --> 00:08:32,539
so I do is I create index of the city

00:08:28,659 --> 00:08:35,620
the track using our system option photo

00:08:32,539 --> 00:08:39,159
jeez next step with strength cognition

00:08:35,620 --> 00:08:39,159
data of

00:08:39,510 --> 00:08:45,000
because I mean that give me now the

00:08:42,060 --> 00:08:47,730
details of Jason functions and the Jason

00:08:45,000 --> 00:08:50,520
skier did data type is going to be

00:08:47,730 --> 00:08:52,530
covered by Chara in the next sessions so

00:08:50,520 --> 00:08:55,440
I'm just not going to that but this is a

00:08:52,530 --> 00:08:59,070
function which can extract the

00:08:55,440 --> 00:09:03,930
information out of Jason common and what

00:08:59,070 --> 00:09:06,030
I do next is I cleave this in response

00:09:03,930 --> 00:09:08,510
cable so you see this kind on if this is

00:09:06,030 --> 00:09:08,510
created

00:09:10,319 --> 00:09:15,689
and I do this so my query select came

00:09:13,199 --> 00:09:18,959
for from city and you see that I am

00:09:15,689 --> 00:09:21,329
using the same function and then what

00:09:18,959 --> 00:09:24,389
I'm doing is I'm giving a range of 300

00:09:21,329 --> 00:09:27,779
to 500 so this is just a small example

00:09:24,389 --> 00:09:30,149
to show you as to how this works and

00:09:27,779 --> 00:09:34,529
this is how you will use this function

00:09:30,149 --> 00:09:36,919
in your in Ukraine so similarly you can

00:09:34,529 --> 00:09:40,019
you can have a lot of complicated stuff

00:09:36,919 --> 00:09:43,049
define inside a function and then you

00:09:40,019 --> 00:09:47,239
can excuse that as a query and it'll it

00:09:43,049 --> 00:09:51,989
will show you the population of

00:09:47,239 --> 00:09:54,989
information of within that certain range

00:09:51,989 --> 00:09:58,679
of children to find it so so this is

00:09:54,989 --> 00:10:01,459
this is what is a functional relatives

00:09:58,679 --> 00:10:01,459
in adoption

00:10:02,920 --> 00:10:07,630
now yeah so if you look at the explain

00:10:05,950 --> 00:10:09,640
that I was talking about they stretch so

00:10:07,630 --> 00:10:12,900
if you can't explain time you clearly

00:10:09,640 --> 00:10:12,900
says that it is using that

00:10:32,070 --> 00:10:38,250
if you look at no one's once purchased

00:10:34,440 --> 00:10:40,020
creatively index now you have to but you

00:10:38,250 --> 00:10:43,170
can see what are all the indexes created

00:10:40,020 --> 00:10:44,850
in your table so show indexes shows you

00:10:43,170 --> 00:10:47,610
all the indexes that I created and the

00:10:44,850 --> 00:10:49,170
people I have just removed the other

00:10:47,610 --> 00:10:51,570
index pattern and just showing you the

00:10:49,170 --> 00:10:53,370
next part from me so what the context is

00:10:51,570 --> 00:10:55,560
created for the perspective shifted

00:10:53,370 --> 00:10:58,830
between this and this is the expression

00:10:55,560 --> 00:11:01,560
that so whenever you creating a

00:10:58,830 --> 00:11:03,570
functionally mix if you do a show index

00:11:01,560 --> 00:11:05,670
from city and you go to the that

00:11:03,570 --> 00:11:07,080
particular index definition will show

00:11:05,670 --> 00:11:13,110
you the exact expression that is being

00:11:07,080 --> 00:11:15,960
used as for for creating activities so

00:11:13,110 --> 00:11:17,550
this is this is one and this is how you

00:11:15,960 --> 00:11:19,580
can figure out what are all the in cases

00:11:17,550 --> 00:11:19,580
that

00:11:25,850 --> 00:11:31,250
okay so that was that was all about

00:11:29,330 --> 00:11:33,200
functional index that I wanted to cover

00:11:31,250 --> 00:11:35,690
you can you can find more information

00:11:33,200 --> 00:11:39,050
about this nice little toss so that we

00:11:35,690 --> 00:11:45,020
move to the next index improvements that

00:11:39,050 --> 00:11:48,500
has been implemented into this is yeah

00:11:45,020 --> 00:11:50,480
this is this is this is a this I picked

00:11:48,500 --> 00:11:51,830
up this because this was contributed by

00:11:50,480 --> 00:11:54,320
Bonaparte

00:11:51,830 --> 00:11:57,340
I mean this is contributed by Facebook

00:11:54,320 --> 00:12:00,440
and we have we have picked up this

00:11:57,340 --> 00:12:03,350
implementation and we so this is this is

00:12:00,440 --> 00:12:06,380
a way of skipping index camp so it's

00:12:03,350 --> 00:12:09,230
taking the skipper yeah index scripts

00:12:06,380 --> 00:12:11,330
can so whenever you have a multi-column

00:12:09,230 --> 00:12:14,510
and it's like if you have a common index

00:12:11,330 --> 00:12:17,150
defined on what it becomes and you have

00:12:14,510 --> 00:12:20,990
something like the index is defined on a

00:12:17,150 --> 00:12:23,060
PC but your query is like fruity or

00:12:20,990 --> 00:12:26,450
where B is less than C so what

00:12:23,060 --> 00:12:43,970
previously used to have the most that it

00:12:26,450 --> 00:12:47,000
used to scan the whole index and this is

00:12:43,970 --> 00:12:49,430
useful only when the condition is not on

00:12:47,000 --> 00:12:51,380
the first part of things so if you have

00:12:49,430 --> 00:12:56,290
select star from people where C is less

00:12:51,380 --> 00:12:56,290
than 3 let's finish this this feature

00:13:05,070 --> 00:13:07,100
Oh

00:13:07,130 --> 00:13:13,790
so this was used by a business of the

00:13:11,510 --> 00:13:18,550
patch we're peacefull and we have

00:13:13,790 --> 00:13:18,550
implemented this patch from them

00:13:20,170 --> 00:13:28,990
okay now the next about is regarding the

00:13:25,690 --> 00:13:31,720
optimizer it's so there were a lot of

00:13:28,990 --> 00:13:34,570
hints where basically there and

00:13:31,720 --> 00:13:36,399
optimizer from long and back but he ate

00:13:34,570 --> 00:13:39,130
or do we have started implementing a lot

00:13:36,399 --> 00:13:42,100
of other hints in the optimizer so these

00:13:39,130 --> 00:13:45,760
are the set of fits that we have

00:13:42,100 --> 00:13:47,920
implemented in a taco like there are

00:13:45,760 --> 00:13:51,519
giant otter hence then there since for

00:13:47,920 --> 00:13:53,950
setting the system variables means for

00:13:51,519 --> 00:13:56,860
views and derived tables for margin

00:13:53,950 --> 00:13:59,230
emerge and then we have in store index

00:13:56,860 --> 00:14:01,470
much as also so I just go through each

00:13:59,230 --> 00:14:06,880
of them

00:14:01,470 --> 00:14:08,920
okay so the joint order is basically so

00:14:06,880 --> 00:14:11,860
if you if let's say that you have a

00:14:08,920 --> 00:14:15,910
query which was performing well and

00:14:11,860 --> 00:14:17,920
after certain let's say let's say after

00:14:15,910 --> 00:14:22,180
certain something has happened because

00:14:17,920 --> 00:14:24,279
of which your query is not not not

00:14:22,180 --> 00:14:27,730
performing well and you see that the job

00:14:24,279 --> 00:14:29,890
has changed so the way you can force to

00:14:27,730 --> 00:14:32,070
you say who joined out of these by using

00:14:29,890 --> 00:14:35,470
distance so you can just mention that

00:14:32,070 --> 00:14:38,230
join out which table you want to join

00:14:35,470 --> 00:14:39,550
first and then you can mention this and

00:14:38,230 --> 00:14:42,190
you can see that the explain of the

00:14:39,550 --> 00:14:44,970
statement shows that it's turning on

00:14:42,190 --> 00:14:44,970
that on that

00:14:50,990 --> 00:14:59,750
similarly we can use this index Hodgkin

00:14:54,410 --> 00:15:04,520
for merging indexes on on tables and you

00:14:59,750 --> 00:15:06,470
can use it using this this kind of

00:15:04,520 --> 00:15:09,920
length think Nexus you can specify that

00:15:06,470 --> 00:15:11,750
you want to merge and so can you can

00:15:09,920 --> 00:15:34,660
borrow somewhere to brain scans on

00:15:11,750 --> 00:15:36,050
facility ok so that was like a

00:15:34,660 --> 00:15:38,660
particular session

00:15:36,050 --> 00:15:41,360
it used to persist for that session now

00:15:38,660 --> 00:15:44,270
it may not happen it may happen that the

00:15:41,360 --> 00:15:47,540
nest vary that comes does not require

00:15:44,270 --> 00:15:50,360
that variable to be said so what you can

00:15:47,540 --> 00:15:53,899
do is you can basically set the variable

00:15:50,360 --> 00:15:56,420
sort that exact way and this is how you

00:15:53,899 --> 00:15:58,880
do it so you set the foreign key checks

00:15:56,420 --> 00:16:02,390
for inserts because insert might take a

00:15:58,880 --> 00:16:04,220
lot of time you can specify a sort

00:16:02,390 --> 00:16:06,860
buffer size for a particular query so

00:16:04,220 --> 00:16:09,560
this this helps you this helps you to

00:16:06,860 --> 00:16:11,330
have that session set for that

00:16:09,560 --> 00:16:14,029
particular query not for the possession

00:16:11,330 --> 00:16:19,220
or for the whole global session so this

00:16:14,029 --> 00:16:21,400
is the same power optimizer that we have

00:16:19,220 --> 00:16:21,400
provided

00:16:26,589 --> 00:16:32,379
okay so now moving on to the internal

00:16:29,649 --> 00:16:34,209
technical I I thought Colin was talking

00:16:32,379 --> 00:16:39,490
about they undertake the storage engine

00:16:34,209 --> 00:16:42,160
in the coordinates oh so previously for

00:16:39,490 --> 00:16:45,699
certain optimizer queries are bicycle

00:16:42,160 --> 00:16:50,199
queries we need to use this internet

00:16:45,699 --> 00:16:53,649
temporary tables for sorting is one of

00:16:50,199 --> 00:16:57,610
the examples now we used to use the

00:16:53,649 --> 00:16:58,959
memory engine previously and so now what

00:16:57,610 --> 00:17:00,459
we have come up with this is the

00:16:58,959 --> 00:17:07,510
internet thing that will store a kitchen

00:17:00,459 --> 00:17:10,329
now this and this is not something that

00:17:07,510 --> 00:17:15,069
the user can create this is being

00:17:10,329 --> 00:17:18,039
created I mean you use a user don't need

00:17:15,069 --> 00:17:20,530
but you do need user interaction for

00:17:18,039 --> 00:17:22,620
using this feature this is a this is

00:17:20,530 --> 00:17:27,250
something that is used by optimizer and

00:17:22,620 --> 00:17:30,669
it's created all the time now it's for

00:17:27,250 --> 00:17:32,470
the memories that you have so if the the

00:17:30,669 --> 00:17:35,020
internet cable storage engine memory

00:17:32,470 --> 00:17:38,830
exceeds it can overflow into the disk

00:17:35,020 --> 00:17:42,039
and and that's also people so it's used

00:17:38,830 --> 00:17:45,669
basically for complex queries like CDs

00:17:42,039 --> 00:17:48,760
comfortable exhibitions then there are a

00:17:45,669 --> 00:17:51,039
bunch of other query types that could

00:17:48,760 --> 00:17:53,409
use this feature it's there a master

00:17:51,039 --> 00:17:55,659
documentation but this was this is the

00:17:53,409 --> 00:17:58,809
this is the internet came in which was

00:17:55,659 --> 00:18:01,419
introduced now the improvements that we

00:17:58,809 --> 00:18:02,160
have in the latest features of the

00:18:01,419 --> 00:18:06,360
latest version

00:18:02,160 --> 00:18:09,360
is that it now suppose Jason Texas dog

00:18:06,360 --> 00:18:12,840
and Joey tea relatives so this is these

00:18:09,360 --> 00:18:16,050
are the improvements that it has and it

00:18:12,840 --> 00:18:19,850
supports over from this and there's

00:18:16,050 --> 00:18:23,670
basically no overhead when it comes to

00:18:19,850 --> 00:18:31,710
converting from you know D - and when

00:18:23,670 --> 00:18:34,520
the becomes this movement in that so

00:18:31,710 --> 00:18:41,510
this is this is the improvements for

00:18:34,520 --> 00:18:44,760
internet cables and so there are certain

00:18:41,510 --> 00:18:45,990
limitations so so basically there are

00:18:44,760 --> 00:18:49,680
certain variables by which you can

00:18:45,990 --> 00:18:53,070
control via the size of the empty book

00:18:49,680 --> 00:18:55,560
and as Mike mentioned in his performance

00:18:53,070 --> 00:18:58,770
key my improvement so you can you can

00:18:55,560 --> 00:19:01,070
monitor the usage of memory and disk

00:18:58,770 --> 00:19:01,070
usage

00:19:11,019 --> 00:19:31,580
so we so so six which is one of the

00:19:28,759 --> 00:19:34,909
internal performance tests let me have

00:19:31,580 --> 00:19:37,669
and whenever we have to benchmark

00:19:34,909 --> 00:19:41,989
anything that's basically the thing that

00:19:37,669 --> 00:19:44,059
we we do it from our side so so what we

00:19:41,989 --> 00:19:49,220
have that is we have done the suspension

00:19:44,059 --> 00:19:53,649
test and then we have found out that the

00:19:49,220 --> 00:19:53,649
internet ink table is faster than

00:19:57,860 --> 00:20:02,779
so and this is there in the my skills

00:20:00,799 --> 00:20:06,970
over being blog so you can read about

00:20:02,779 --> 00:20:06,970
this page that

00:20:13,710 --> 00:20:23,100
okay so yet so I'm done with the last

00:20:19,410 --> 00:20:25,550
slide so if you have any questions I can

00:20:23,100 --> 00:20:25,550
take it off

00:20:28,440 --> 00:20:31,040
yep

00:20:38,840 --> 00:20:44,130
so basically these are internal

00:20:40,830 --> 00:20:47,760
tentacles which kind of slacker it's

00:20:44,130 --> 00:20:52,860
like a stage II do that's that holds the

00:20:47,760 --> 00:20:55,640
the temporary data between some complex

00:20:52,860 --> 00:20:59,970
place like exactly

00:20:55,640 --> 00:21:02,240
but tablespaces is your normal table

00:20:59,970 --> 00:21:02,240
spaces

00:21:06,670 --> 00:21:08,700
Oh

00:21:11,510 --> 00:21:15,970
we never specified thinking

00:21:19,950 --> 00:21:23,150
any other questions

00:21:23,640 --> 00:21:29,170
okay thank you so much end of the next

00:21:27,330 --> 00:21:32,259
session

00:21:29,170 --> 00:21:32,259

YouTube URL: https://www.youtube.com/watch?v=ZEO6I-gCi7U


