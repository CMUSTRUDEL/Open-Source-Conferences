Title: PolarDB Architecture by Oystein Grovlen
Publication date: 2019-03-22
Playlist: FOSSASIA Summit 2019 - Database
Description: 
	17 March 2019 11:55, Training Room 2-1

In this session, we will give a introduction of PolarDB, which is a  a cloud native database available on Alicloud. PolarDB separates the computing layer from a shared storage layer. This design allows the storage space to automatically scale according to usage. The computing layer adopts a a single master - multiple read only replica architecture, and scaling up a compute node or adding a replica only takes a few minutes.  The computing nodes and storage nodes  are connected with a high-speed network and use the RDMA protocol to execute data transmissions, resulting into I/O performance never being a bottleneck again.
Captions: 
	00:00:00,000 --> 00:00:05,100
to talk about photo DB in general for

00:00:02,100 --> 00:00:17,310
DVDs our database reputation for pro fog

00:00:05,100 --> 00:00:22,859
for the cloud I'm used to my squat now

00:00:17,310 --> 00:00:26,730
for the balaclava we provide different

00:00:22,859 --> 00:00:30,179
databases for for users in the cloud you

00:00:26,730 --> 00:00:33,059
can use my scale you can use my enemy

00:00:30,179 --> 00:00:40,620
use can use posters you can use sequel

00:00:33,059 --> 00:00:44,219
server and so on and also no SQL so but

00:00:40,620 --> 00:00:49,590
we want to build a database architecture

00:00:44,219 --> 00:00:54,920
that take advantage of the cloud when

00:00:49,590 --> 00:00:58,109
you're on the cloud you can use special

00:00:54,920 --> 00:01:01,289
however because we are controlling the

00:00:58,109 --> 00:01:02,670
machines for example we can use all the

00:01:01,289 --> 00:01:08,340
infrastructure in the cloud to take

00:01:02,670 --> 00:01:10,740
advantage of that and support users

00:01:08,340 --> 00:01:15,540
different ways with the auto scaling and

00:01:10,740 --> 00:01:19,619
other complications the basic principle

00:01:15,540 --> 00:01:21,990
of the many of these cloud base

00:01:19,619 --> 00:01:26,090
databases you have also we have Amazon

00:01:21,990 --> 00:01:29,070
has evolved over Microsoft Azure has

00:01:26,090 --> 00:01:34,250
hyper scale and so on is that they make

00:01:29,070 --> 00:01:55,799
they split the compute from this torch

00:01:34,250 --> 00:01:58,369
because when you have this you need more

00:01:55,799 --> 00:02:07,100
process English you do necessary had a

00:01:58,369 --> 00:02:11,860
even more storage and so on so this is

00:02:07,100 --> 00:02:18,260
the basic components of this probability

00:02:11,860 --> 00:02:20,690
so we have a function no balancing

00:02:18,260 --> 00:02:24,319
handles fado and stuff like that the

00:02:20,690 --> 00:02:27,790
database the database has a special PI

00:02:24,319 --> 00:02:32,030
system that hides me disturb you today

00:02:27,790 --> 00:02:34,700
storage system and so the databases

00:02:32,030 --> 00:02:36,829
looks like it it's using a local storage

00:02:34,700 --> 00:02:39,920
but actually is using a special

00:02:36,829 --> 00:02:42,459
optimized for database storage that

00:02:39,920 --> 00:02:42,459
which is called

00:02:50,819 --> 00:02:56,819
and poorest arose from the bottom for

00:02:53,670 --> 00:03:02,250
the stories as I said it's a distributed

00:02:56,819 --> 00:03:07,049
storage and it has multiple trunks with

00:03:02,250 --> 00:03:08,459
there with where the data is stored all

00:03:07,049 --> 00:03:15,209
these chunks are synchronized using

00:03:08,459 --> 00:03:17,849
power path which is a special variant of

00:03:15,209 --> 00:03:22,040
the raft the protocol that this has been

00:03:17,849 --> 00:03:24,629
developed as part of this project and

00:03:22,040 --> 00:03:30,510
all the databases as I said they talks

00:03:24,629 --> 00:03:33,540
to uses a special guide wire that uses

00:03:30,510 --> 00:03:38,819
this underlying storage and this torch

00:03:33,540 --> 00:03:44,450
has to be efficient especially the audio

00:03:38,819 --> 00:03:48,590
main Network which is a way to actually

00:03:44,450 --> 00:03:51,890
remote memory looks like local memory

00:03:48,590 --> 00:03:57,040
into the computer so it's these special

00:03:51,890 --> 00:04:02,030
hardware to get both and low latency and

00:03:57,040 --> 00:04:05,810
either you have both obtained this and

00:04:02,030 --> 00:04:09,410
access these in these chat service

00:04:05,810 --> 00:04:12,349
so the obtainment gives you very low

00:04:09,410 --> 00:04:14,090
latency at the same time you can store I

00:04:12,349 --> 00:04:17,060
get a high throughput from the edges

00:04:14,090 --> 00:04:23,060
piece and there's some old logic to call

00:04:17,060 --> 00:04:25,820
this so that we need that is special

00:04:23,060 --> 00:04:30,010
harbor's is used means that you need to

00:04:25,820 --> 00:04:32,990
have supported our data centers for this

00:04:30,010 --> 00:04:34,910
architecture in the beginning it was

00:04:32,990 --> 00:04:37,220
only some data center in China that

00:04:34,910 --> 00:04:39,650
supported s now Hong Kong also supports

00:04:37,220 --> 00:04:41,960
Asia in supergirls with the Davison and

00:04:39,650 --> 00:04:48,550
Singapore would actually be able to one

00:04:41,960 --> 00:04:48,550
is to have this for a living

00:04:50,310 --> 00:04:55,770
as I said there is a special library in

00:04:52,440 --> 00:04:59,180
the on the database side that this used

00:04:55,770 --> 00:05:01,980
to communicate in the Forrestal and it's

00:04:59,180 --> 00:05:06,389
it went to the purusa space so it has

00:05:01,980 --> 00:05:10,620
less overhead and then traditionally

00:05:06,389 --> 00:05:13,560
sufficient resistance I know but it also

00:05:10,620 --> 00:05:24,810
has positive side and isn't easy to port

00:05:13,560 --> 00:05:27,360
your database to this architecture as I

00:05:24,810 --> 00:05:32,280
say one of the goals has to be able to

00:05:27,360 --> 00:05:34,860
scale storage and compute independently

00:05:32,280 --> 00:05:41,040
if you have a traditional MySQL system

00:05:34,860 --> 00:05:44,520
then you for enough to get better to get

00:05:41,040 --> 00:05:47,400
to scale up or to support high

00:05:44,520 --> 00:05:50,220
availability you have multiple replicas

00:05:47,400 --> 00:05:53,990
in addition to the master and for each

00:05:50,220 --> 00:05:53,990
practical you will add local storage

00:05:55,340 --> 00:06:01,470
here you have the shared storage so that

00:05:59,430 --> 00:06:04,440
when you are APNIC are your only and

00:06:01,470 --> 00:06:08,419
compute resources when the store she

00:06:04,440 --> 00:06:11,490
still stays the same so you can see that

00:06:08,419 --> 00:06:15,210
the cost savings and if you need many

00:06:11,490 --> 00:06:21,200
replicas because yes I compared to using

00:06:15,210 --> 00:06:21,200
a ton of servers with local storage

00:06:27,870 --> 00:06:37,770
if you look at them the notification is

00:06:32,730 --> 00:06:39,270
also in Porto baby is physical compared

00:06:37,770 --> 00:06:43,860
to the logical application that you're

00:06:39,270 --> 00:06:45,139
used to for my school so in my scale if

00:06:43,860 --> 00:06:49,470
you have granted parole application

00:06:45,139 --> 00:06:51,690
manual you can have the big dog which is

00:06:49,470 --> 00:06:56,610
the one that it's actually sent to the

00:06:51,690 --> 00:06:58,680
face and you will but you will also

00:06:56,610 --> 00:07:00,630
write the mean dog which is the physical

00:06:58,680 --> 00:07:04,979
rod that it's used to keep the data

00:07:00,630 --> 00:07:06,840
consistent so if if this computer cache

00:07:04,979 --> 00:07:12,300
per sample you will need a mean the dog

00:07:06,840 --> 00:07:17,040
to recover into consistent state so but

00:07:12,300 --> 00:07:20,820
in the in the products for example just

00:07:17,040 --> 00:07:23,100
have to take a turn in drawing and this

00:07:20,820 --> 00:07:30,539
may get the wiener dog data you need

00:07:23,100 --> 00:07:34,080
from the pet store so you get you get a

00:07:30,539 --> 00:07:35,639
much less writing to this then you get

00:07:34,080 --> 00:07:38,610
into the traditional my scale

00:07:35,639 --> 00:07:42,320
application case where you have to force

00:07:38,610 --> 00:07:42,320
both remain together in a row

00:07:44,150 --> 00:07:51,580
this is also advantage special advantage

00:07:47,510 --> 00:07:55,060
for dictionary operations if you have

00:07:51,580 --> 00:07:58,580
international logical application if you

00:07:55,060 --> 00:08:00,650
for example either you want to add a

00:07:58,580 --> 00:08:03,889
coin or some other or table operations

00:08:00,650 --> 00:08:06,860
do if the first one on the hand on the

00:08:03,889 --> 00:08:09,260
master and then operation is completed

00:08:06,860 --> 00:08:12,830
in this log to the window so that's the

00:08:09,260 --> 00:08:15,580
time and it will be replicated to the do

00:08:12,830 --> 00:08:20,750
the same and then the same has to

00:08:15,580 --> 00:08:24,919
execute this operation and my this

00:08:20,750 --> 00:08:27,800
execute dictionary changes executing on

00:08:24,919 --> 00:08:29,900
the same verse they log behind it will

00:08:27,800 --> 00:08:35,719
be blocked you will not do anything over

00:08:29,900 --> 00:08:38,599
on this table until it completes but

00:08:35,719 --> 00:08:40,159
since we are using shares no chair it's

00:08:38,599 --> 00:08:42,860
the money of the master that actually

00:08:40,159 --> 00:08:48,290
updates the later parts and then their

00:08:42,860 --> 00:08:50,000
data files are the operation is

00:08:48,290 --> 00:08:52,370
completed and you just update some

00:08:50,000 --> 00:08:54,970
metadata and then the shape is ready to

00:08:52,370 --> 00:08:54,970
use the same

00:08:58,040 --> 00:09:07,170
so that by using physical application

00:09:02,010 --> 00:09:10,230
you you avoid the latency issues we have

00:09:07,170 --> 00:09:12,480
a traditional application that is the

00:09:10,230 --> 00:09:15,000
same product is this right the example

00:09:12,480 --> 00:09:18,620
use add column and column is instant in

00:09:15,000 --> 00:09:21,600
mice related so so but there are the

00:09:18,620 --> 00:09:25,830
table operations that have this still

00:09:21,600 --> 00:09:28,290
have this characteristic also because we

00:09:25,830 --> 00:09:30,690
imported a billion is five six pastes

00:09:28,290 --> 00:09:33,110
but we are working on pouring at eight

00:09:30,690 --> 00:09:33,110
or so

00:09:38,559 --> 00:09:55,579
somewhere because here with the

00:09:47,319 --> 00:09:58,790
traditional in a DP institution OMI you

00:09:55,579 --> 00:10:01,220
have set of transactions and this

00:09:58,790 --> 00:10:03,499
section needs to be fresh to the little

00:10:01,220 --> 00:10:07,490
dog before you can commit the proper to

00:10:03,499 --> 00:10:09,800
the client that this to do this

00:10:07,490 --> 00:10:11,360
efficiently you used to commit so you

00:10:09,800 --> 00:10:12,829
group transaction together and you do

00:10:11,360 --> 00:10:15,050
one write that then you can report

00:10:12,829 --> 00:10:16,490
multiple transaction has completed at

00:10:15,050 --> 00:10:19,300
the same time instead of applying for

00:10:16,490 --> 00:10:19,300
transactions

00:10:22,390 --> 00:10:33,579
and in the party as its let me share the

00:10:30,459 --> 00:10:39,850
lead at all and this table has to wind

00:10:33,579 --> 00:10:42,459
it up and then it will hash on the page

00:10:39,850 --> 00:10:44,769
ID and put it divided between different

00:10:42,459 --> 00:10:46,600
workers so that there are multiple

00:10:44,769 --> 00:10:48,820
workers that our pride is in you know

00:10:46,600 --> 00:10:50,709
and that is very necessary because on

00:10:48,820 --> 00:10:52,870
the server side there is multiple the

00:10:50,709 --> 00:10:54,310
feds actually updating the database so

00:10:52,870 --> 00:10:57,850
if you use the single thread on this

00:10:54,310 --> 00:10:59,100
half time you will have problems keeping

00:10:57,850 --> 00:11:02,140
up

00:10:59,100 --> 00:11:06,810
we know from my skill application that

00:11:02,140 --> 00:11:08,890
was the situation and today and some

00:11:06,810 --> 00:11:13,750
politician and what they can do today is

00:11:08,890 --> 00:11:16,269
that you can as long as a transaction

00:11:13,750 --> 00:11:17,470
was in the same group commit you know

00:11:16,269 --> 00:11:18,880
that they are not dependent on each

00:11:17,470 --> 00:11:24,820
other so you can actually be done in

00:11:18,880 --> 00:11:27,250
parallel but once you get to transaction

00:11:24,820 --> 00:11:29,410
from the last next GU commit cannot be

00:11:27,250 --> 00:11:31,089
executed before all the others before

00:11:29,410 --> 00:11:37,779
has completed in order to ensure that

00:11:31,089 --> 00:11:40,839
they are executed but here we can have a

00:11:37,779 --> 00:11:43,269
much lower higher gravity or vandalism

00:11:40,839 --> 00:11:46,800
because as long as it's not on the same

00:11:43,269 --> 00:11:46,800
page and execute in the power

00:11:50,980 --> 00:11:58,870
another and the only leader dog that is

00:11:55,270 --> 00:12:01,060
actually lead on here is the one four

00:11:58,870 --> 00:12:03,940
pages that are in the buffer pool or are

00:12:01,060 --> 00:12:06,250
cached because we don't want to redo

00:12:03,940 --> 00:12:10,690
other we don't want to wind in pages

00:12:06,250 --> 00:12:13,060
just to redo the log because the time

00:12:10,690 --> 00:12:15,730
people need actually me this page if I

00:12:13,060 --> 00:12:18,640
already have a flush to this master so

00:12:15,730 --> 00:12:22,590
you don't you can save the work of both

00:12:18,640 --> 00:12:22,590
of them applying the dog on the

00:12:30,090 --> 00:12:35,970
so but what happens if you leave there

00:12:33,210 --> 00:12:40,250
what we call a page from the past we say

00:12:35,970 --> 00:12:50,820
that the state dog of this replica is

00:12:40,250 --> 00:12:53,820
the last local applied to this page so

00:12:50,820 --> 00:12:57,810
if you family the page in four discs

00:12:53,820 --> 00:13:00,360
which has an order order state we

00:12:57,810 --> 00:13:03,630
actually have to be time to read you

00:13:00,360 --> 00:13:07,380
know that has been applied that before

00:13:03,630 --> 00:13:19,710
you actually allow the application to be

00:13:07,380 --> 00:13:22,170
in this page we also need the replica of

00:13:19,710 --> 00:13:25,890
not applied because the page is not the

00:13:22,170 --> 00:13:31,680
cash so he needs a way to browse collect

00:13:25,890 --> 00:13:34,020
this so that the primary wish and the

00:13:31,680 --> 00:13:36,210
checkpoint LS and that is the no

00:13:34,020 --> 00:13:39,840
sequence number for the little dog that

00:13:36,210 --> 00:13:42,660
it has before that all happy fresh today

00:13:39,840 --> 00:13:46,350
Stella goes checkpointing do it flash to

00:13:42,660 --> 00:13:50,520
disk every page that is after a certain

00:13:46,350 --> 00:13:52,830
time point of time so when I cook so the

00:13:50,520 --> 00:13:55,800
primary community to communicate s the

00:13:52,830 --> 00:13:56,790
horn a replica so it can garbage collect

00:13:55,800 --> 00:14:02,520
the old

00:13:56,790 --> 00:14:03,480
you know my SQL is the user or even if

00:14:02,520 --> 00:14:06,990
it's using multi-version concurrency

00:14:03,480 --> 00:14:10,050
control so there will be cases where

00:14:06,990 --> 00:14:12,810
like if you need to read an old version

00:14:10,050 --> 00:14:15,330
of a page to leave the old version our

00:14:12,810 --> 00:14:17,640
case you use the undo log which is a

00:14:15,330 --> 00:14:19,890
logical dog that you read and then you

00:14:17,640 --> 00:14:26,100
leave your changes till you get back to

00:14:19,890 --> 00:14:28,860
the old board being able to do that on

00:14:26,100 --> 00:14:31,560
the replica you must make sure that the

00:14:28,860 --> 00:14:33,630
master does not touch the lirik lagu

00:14:31,560 --> 00:14:35,400
know that you might need so all that

00:14:33,630 --> 00:14:37,260
because we tell them ask them what is

00:14:35,400 --> 00:14:40,890
the oldest leave you that I have in

00:14:37,260 --> 00:14:45,900
support make sure not to delete can do

00:14:40,890 --> 00:14:47,580
no record on you rather this this

00:14:45,900 --> 00:14:50,150
communication is not easy simply

00:14:47,580 --> 00:14:53,760
starting this is not shared

00:14:50,150 --> 00:14:56,400
communication it's not something that is

00:14:53,760 --> 00:15:00,330
in Hampton physical application it is

00:14:56,400 --> 00:15:02,730
the shared storage that makes it simple

00:15:00,330 --> 00:15:07,700
to do this because the work the time I

00:15:02,730 --> 00:15:07,700
knew within storage affects the replicas

00:15:08,660 --> 00:15:15,630
so what happens if you read a page from

00:15:11,460 --> 00:15:17,670
the future I mean you have a 94 and then

00:15:15,630 --> 00:15:21,960
you read something from disk where t5

00:15:17,670 --> 00:15:25,200
has already been a part and that's is

00:15:21,960 --> 00:15:27,930
that we you never will do that we will

00:15:25,200 --> 00:15:30,750
prevent that because the little dog and

00:15:27,930 --> 00:15:33,480
the physically you know there's no way

00:15:30,750 --> 00:15:35,370
of going back to an old physical version

00:15:33,480 --> 00:15:37,740
of a page we have to distinguish to the

00:15:35,370 --> 00:15:39,210
logical version of the page that you use

00:15:37,740 --> 00:15:40,780
for multi version who comes in the door

00:15:39,210 --> 00:15:44,280
could actually be too

00:15:40,780 --> 00:15:50,080
structures that this video is reflecting

00:15:44,280 --> 00:15:53,470
so we make sure what telling me finally

00:15:50,080 --> 00:15:55,990
what is the snapshot that we are

00:15:53,470 --> 00:15:58,390
currently on that it does not fly any

00:15:55,990 --> 00:16:00,580
pages that are new other than this twist

00:15:58,390 --> 00:16:02,620
so that's actually a change we had to do

00:16:00,580 --> 00:16:09,000
you know Nene to hold back flushing

00:16:02,620 --> 00:16:12,160
until the lead to the replicas has

00:16:09,000 --> 00:16:14,410
applied within long but no the

00:16:12,160 --> 00:16:16,360
protecting applicants are applying the

00:16:14,410 --> 00:16:20,170
you know all the time so there is

00:16:16,360 --> 00:16:22,470
usually not any issues with the delaying

00:16:20,170 --> 00:16:22,470
this

00:16:28,700 --> 00:16:31,870
I ain't giving out

00:16:32,720 --> 00:16:38,660
so there's only one I see Canasta

00:16:35,060 --> 00:16:41,500
supported ulti so the approximate on

00:16:38,660 --> 00:16:44,570
scripts and the links to the master and

00:16:41,500 --> 00:16:46,010
watch the master it's the replica and we

00:16:44,570 --> 00:16:49,370
know balancing between the wheel

00:16:46,010 --> 00:16:53,960
applicator and shoot the master go down

00:16:49,370 --> 00:16:56,180
it will make sure to remove request to

00:16:53,960 --> 00:17:01,250
the new master which will be chosen from

00:16:56,180 --> 00:17:04,310
one of these replicas and the other and

00:17:01,250 --> 00:17:06,829
support that if you have an application

00:17:04,310 --> 00:17:08,689
which first have take something commit

00:17:06,829 --> 00:17:13,760
and then select that it actually sees

00:17:08,689 --> 00:17:16,640
its own updates because when you did

00:17:13,760 --> 00:17:21,170
update you return to the proxy the no

00:17:16,640 --> 00:17:24,199
secrets number at that time on this and

00:17:21,170 --> 00:17:26,630
then when the innocent the very

00:17:24,199 --> 00:17:29,090
practical is informed about this log

00:17:26,630 --> 00:17:31,520
sequence number so that it makes sure to

00:17:29,090 --> 00:17:35,690
apply enough we long to be able to

00:17:31,520 --> 00:17:39,920
return a version of this work that is

00:17:35,690 --> 00:17:42,220
consistent with of the update we nearly

00:17:39,920 --> 00:17:42,220
did

00:17:46,790 --> 00:17:51,200
but in a free-to-use what the awakened

00:17:49,160 --> 00:17:53,930
how is the sports multiple master so you

00:17:51,200 --> 00:17:59,630
can actually scale your updates beyond

00:17:53,930 --> 00:18:04,220
what one master is able to support he

00:17:59,630 --> 00:18:10,270
also will be able to use multiple

00:18:04,220 --> 00:18:13,270
availability zones for for your database

00:18:10,270 --> 00:18:13,270
service

00:18:16,080 --> 00:18:18,920
that's on

00:18:21,220 --> 00:18:24,510
the questions

00:18:27,470 --> 00:18:35,130
how computation happens former he was to

00:18:30,840 --> 00:18:39,060
her okay so I don't have an answer to

00:18:35,130 --> 00:18:41,550
that I I do not I I know not come to

00:18:39,060 --> 00:18:43,800
work on that part I'm this was actually

00:18:41,550 --> 00:18:46,860
from me I was going to present this but

00:18:43,800 --> 00:18:55,040
they're so sorry I don't really know

00:18:46,860 --> 00:18:55,040

YouTube URL: https://www.youtube.com/watch?v=9yFPr3Gk6J8


