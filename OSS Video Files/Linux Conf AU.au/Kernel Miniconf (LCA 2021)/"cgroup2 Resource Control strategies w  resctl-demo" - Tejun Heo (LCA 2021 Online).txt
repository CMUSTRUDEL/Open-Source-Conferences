Title: "cgroup2 Resource Control strategies w  resctl-demo" - Tejun Heo (LCA 2021 Online)
Publication date: 2021-02-18
Playlist: Kernel Miniconf (LCA 2021)
Description: 
	Tejun Heo

https://lca2021.linux.org.au/schedule/presentation/102/

The idea behind resource control is to distribute resources between workloads so that machines can be shared among different tasks without them interfering with each other - be that service and management tasks on a server, or a web browser and a build job on a laptop. While developing and deploying resource control strategies at facebook to improve reliability and utilization, we've encountered many surprises and had to relearn what we thought we already knew.

Resource Control Demo (https://github.com/facebookexperimental/resctl-demo) is an interactive tool which documents various aspects of cgroup2 resource control using live resource contention scenarios. This presentation gives a tour of various cgroup2 resource control mechanisms and strategies using resctl-demo.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sat Jan 23 14:25:00 2021 at Tux Theatre
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:16,080 --> 00:00:21,119
welcome back everyone

00:00:17,840 --> 00:00:23,119
um for our next talk uh we've got tj

00:00:21,119 --> 00:00:24,960
who's a kernel hacker who has been

00:00:23,119 --> 00:00:26,960
working on various sub-systems of the

00:00:24,960 --> 00:00:28,800
kernel for the past two decades

00:00:26,960 --> 00:00:30,800
um and in the past few years he's been

00:00:28,800 --> 00:00:32,399
focused on developing c group 2 resource

00:00:30,800 --> 00:00:34,719
control mechanisms which is what he's

00:00:32,399 --> 00:00:38,160
going to be talking about

00:00:34,719 --> 00:00:41,440
please welcome tj hello

00:00:38,160 --> 00:00:42,160
hey i'm tj i work at a facebook corner

00:00:41,440 --> 00:00:44,480
team

00:00:42,160 --> 00:00:45,440
and um yeah i've been working on result

00:00:44,480 --> 00:00:47,760
control a lot so

00:00:45,440 --> 00:00:49,200
today's presentation is about uh signal

00:00:47,760 --> 00:00:50,879
to resource control

00:00:49,200 --> 00:00:53,360
um using something called resource

00:00:50,879 --> 00:00:56,640
control demo

00:00:53,360 --> 00:01:00,079
so um so what is resource control so uh

00:00:56,640 --> 00:01:01,680
this is the um uh one phrase which

00:01:00,079 --> 00:01:04,080
which kind of captures the mission

00:01:01,680 --> 00:01:05,920
statement um of our team

00:01:04,080 --> 00:01:07,360
and it's world conserving full os

00:01:05,920 --> 00:01:10,560
resource isolation

00:01:07,360 --> 00:01:11,680
resource isolation um part is relatively

00:01:10,560 --> 00:01:14,240
intuitive right i mean

00:01:11,680 --> 00:01:15,680
you have multiple competing users of the

00:01:14,240 --> 00:01:17,280
resources on the system

00:01:15,680 --> 00:01:19,280
and you wanna you know distribute them

00:01:17,280 --> 00:01:20,320
in a controlled manner but you know the

00:01:19,280 --> 00:01:22,640
first two part

00:01:20,320 --> 00:01:25,040
um let's unpack them a little bit so

00:01:22,640 --> 00:01:27,840
work conserving means that um

00:01:25,040 --> 00:01:29,200
we don't want to waste resources cpu

00:01:27,840 --> 00:01:32,880
memory and io

00:01:29,200 --> 00:01:34,560
just to be able to control them right um

00:01:32,880 --> 00:01:36,159
so we want to be able to control them

00:01:34,560 --> 00:01:38,079
and we don't want to lose the total

00:01:36,159 --> 00:01:39,119
amount of work that the system can do as

00:01:38,079 --> 00:01:41,439
much as possible

00:01:39,119 --> 00:01:43,680
so that part is worth conserving for os

00:01:41,439 --> 00:01:45,520
means that we want to be transparent

00:01:43,680 --> 00:01:47,119
uh in other words we don't want

00:01:45,520 --> 00:01:49,360
applications to

00:01:47,119 --> 00:01:51,200
to have to do you know things that you

00:01:49,360 --> 00:01:53,840
know it usually doesn't do

00:01:51,200 --> 00:01:54,880
um like you know using only direct ios

00:01:53,840 --> 00:01:57,280
or you know not

00:01:54,880 --> 00:01:58,240
not being able to use depend on buffer

00:01:57,280 --> 00:02:00,479
diodes or

00:01:58,240 --> 00:02:02,479
swap or anything like that so we want

00:02:00,479 --> 00:02:03,119
applications to do exactly the same

00:02:02,479 --> 00:02:04,960
thing

00:02:03,119 --> 00:02:06,479
that they've been doing and we just want

00:02:04,960 --> 00:02:09,679
to layer

00:02:06,479 --> 00:02:13,120
right or enforce resource control on top

00:02:09,679 --> 00:02:16,239
in a transparent transparent manner

00:02:13,120 --> 00:02:18,959
so this is a slide or rather

00:02:16,239 --> 00:02:19,599
screen that that i've been using in in

00:02:18,959 --> 00:02:21,920
talks

00:02:19,599 --> 00:02:23,120
for the past couple years and it's from

00:02:21,920 --> 00:02:25,840
um uh

00:02:23,120 --> 00:02:27,440
pro the first deployment of um wide

00:02:25,840 --> 00:02:30,879
scale deployment of um

00:02:27,440 --> 00:02:33,120
resource control uh at facebook

00:02:30,879 --> 00:02:34,160
and um there's you know a lot going on

00:02:33,120 --> 00:02:36,720
in the graph but like

00:02:34,160 --> 00:02:38,319
uh for for this purpose we only need to

00:02:36,720 --> 00:02:40,800
pay attention to the purple

00:02:38,319 --> 00:02:41,519
and the green line um you know which is

00:02:40,800 --> 00:02:44,080
going up

00:02:41,519 --> 00:02:45,519
and you know staying top standing close

00:02:44,080 --> 00:02:46,640
the top and in the middle the purple

00:02:45,519 --> 00:02:49,680
lines drops

00:02:46,640 --> 00:02:51,120
so this line both lines uh represent rps

00:02:49,680 --> 00:02:53,680
the quest per second

00:02:51,120 --> 00:02:55,599
and and these are from live web server

00:02:53,680 --> 00:02:59,040
uh serving facebook traffic

00:02:55,599 --> 00:03:01,280
with you know live traffic um and um

00:02:59,040 --> 00:03:02,319
and and when is you know the the when

00:03:01,280 --> 00:03:05,440
the ips line is

00:03:02,319 --> 00:03:06,959
closed the top is the machine is fairly

00:03:05,440 --> 00:03:07,680
saturated so these are two separate

00:03:06,959 --> 00:03:10,239
machines

00:03:07,680 --> 00:03:10,720
uh doing similar things uh serving live

00:03:10,239 --> 00:03:14,480
traffic

00:03:10,720 --> 00:03:17,760
at at almost completely saturated uh

00:03:14,480 --> 00:03:19,120
you know capacity and in the middle uh

00:03:17,760 --> 00:03:22,239
what happens is that

00:03:19,120 --> 00:03:23,840
um in a part of system in a management

00:03:22,239 --> 00:03:26,239
part of the system right um

00:03:23,840 --> 00:03:27,519
like where things like chrome and shaft

00:03:26,239 --> 00:03:30,080
and other management

00:03:27,519 --> 00:03:31,040
um operations happen a memory leak

00:03:30,080 --> 00:03:32,879
happens

00:03:31,040 --> 00:03:34,480
and and that memory leak is you know

00:03:32,879 --> 00:03:35,519
something we introduced intentionally

00:03:34,480 --> 00:03:38,400
for testing

00:03:35,519 --> 00:03:38,879
but memory leak happens and on purple

00:03:38,400 --> 00:03:41,120
right

00:03:38,879 --> 00:03:42,000
the memory leak kind of eats up the

00:03:41,120 --> 00:03:44,799
system

00:03:42,000 --> 00:03:46,799
eventually the web server uh you know

00:03:44,799 --> 00:03:49,120
doesn't get enough resources

00:03:46,799 --> 00:03:50,080
um and it it you know just the ips just

00:03:49,120 --> 00:03:51,760
drops

00:03:50,080 --> 00:03:53,920
and it just cannot serve traffic in an

00:03:51,760 --> 00:03:54,640
effective way and if you look at the

00:03:53,920 --> 00:03:57,760
timeline

00:03:54,640 --> 00:03:58,400
um um it comes back after like 40

00:03:57,760 --> 00:04:01,200
minutes

00:03:58,400 --> 00:04:02,080
right this is not good um if you imagine

00:04:01,200 --> 00:04:04,640
right i mean this

00:04:02,080 --> 00:04:05,840
happening across i don't know a lot of

00:04:04,640 --> 00:04:07,360
machines

00:04:05,840 --> 00:04:09,519
around the same time let's say you know

00:04:07,360 --> 00:04:11,519
this is a a bug

00:04:09,519 --> 00:04:12,720
um which could be triggered at certain

00:04:11,519 --> 00:04:14,799
timing in in

00:04:12,720 --> 00:04:16,720
a future date um there are those types

00:04:14,799 --> 00:04:19,199
of bugs and if that happens across

00:04:16,720 --> 00:04:20,000
you know large part of the fleet then it

00:04:19,199 --> 00:04:23,120
will have

00:04:20,000 --> 00:04:25,840
side outage so that's not good um

00:04:23,120 --> 00:04:27,360
and the green line uh is the one with

00:04:25,840 --> 00:04:28,320
resource protection enabled resource

00:04:27,360 --> 00:04:31,120
control

00:04:28,320 --> 00:04:32,639
enabled and and it's happening the same

00:04:31,120 --> 00:04:34,800
memory leak is happening

00:04:32,639 --> 00:04:36,639
uh actually three times not just one

00:04:34,800 --> 00:04:38,560
time three times on that machine

00:04:36,639 --> 00:04:40,000
and you can see that while ips

00:04:38,560 --> 00:04:42,080
fluctuates a little bit

00:04:40,000 --> 00:04:43,520
it generally stays up and and you know

00:04:42,080 --> 00:04:46,960
we can weather that

00:04:43,520 --> 00:04:49,040
um so um that's

00:04:46,960 --> 00:04:50,880
that's you know that's what uh

00:04:49,040 --> 00:04:52,800
protection uh does

00:04:50,880 --> 00:04:54,400
how when resource control protection

00:04:52,800 --> 00:04:56,000
works that's how it works

00:04:54,400 --> 00:04:57,600
but you know this is really light

00:04:56,000 --> 00:04:59,440
traffic right and and it's kind of

00:04:57,600 --> 00:05:02,479
cumbersome and awkward

00:04:59,440 --> 00:05:04,560
to set it up uh the test and and verify

00:05:02,479 --> 00:05:07,280
it especially in automated way

00:05:04,560 --> 00:05:08,880
um and we you know we don't always wanna

00:05:07,280 --> 00:05:11,919
experimenting a lot with

00:05:08,880 --> 00:05:13,919
live traffic that much and and and it's

00:05:11,919 --> 00:05:15,600
also you know difficult to

00:05:13,919 --> 00:05:17,360
move it anywhere right i mean you have

00:05:15,600 --> 00:05:20,400
to be in private environment

00:05:17,360 --> 00:05:23,360
um and it's just difficult to to use

00:05:20,400 --> 00:05:24,880
um so that's where uh resource control

00:05:23,360 --> 00:05:27,840
demo comes in

00:05:24,880 --> 00:05:29,600
and and this is the screen capture of

00:05:27,840 --> 00:05:32,639
resource control demo running

00:05:29,600 --> 00:05:33,919
and what it does is that it's obviously

00:05:32,639 --> 00:05:36,320
a

00:05:33,919 --> 00:05:37,440
terminal program but behind it there are

00:05:36,320 --> 00:05:39,680
multiple components

00:05:37,440 --> 00:05:40,639
and what it tries to do is that trying

00:05:39,680 --> 00:05:43,840
to capture

00:05:40,639 --> 00:05:46,479
like a situation or a condition

00:05:43,840 --> 00:05:47,600
like as as in before right in the

00:05:46,479 --> 00:05:50,240
previous slide

00:05:47,600 --> 00:05:50,639
a product environment like in a single

00:05:50,240 --> 00:05:54,240
uh

00:05:50,639 --> 00:05:55,120
suit of applications um so there's a lot

00:05:54,240 --> 00:05:58,160
going on there

00:05:55,120 --> 00:06:00,080
but uh uh but we will go through them

00:05:58,160 --> 00:06:01,680
and so what are the components of the

00:06:00,080 --> 00:06:05,520
resource control demo

00:06:01,680 --> 00:06:08,960
um so the first one is called rdhd

00:06:05,520 --> 00:06:09,919
this approximates something like a web

00:06:08,960 --> 00:06:12,880
server right

00:06:09,919 --> 00:06:14,240
it's a latency sensitive request serving

00:06:12,880 --> 00:06:17,680
application

00:06:14,240 --> 00:06:20,960
so it can modulate its load

00:06:17,680 --> 00:06:24,400
its target rps to the set level

00:06:20,960 --> 00:06:27,440
but it's also bound by um

00:06:24,400 --> 00:06:30,880
latency target so if you say you know

00:06:27,440 --> 00:06:32,560
run at i don't know 600 rps per second

00:06:30,880 --> 00:06:34,319
then then it will you know rode up to

00:06:32,560 --> 00:06:36,880
that load level

00:06:34,319 --> 00:06:37,600
as long as its latency the response

00:06:36,880 --> 00:06:40,479
latency

00:06:37,600 --> 00:06:41,840
for this request requests stay within

00:06:40,479 --> 00:06:46,080
certain level um

00:06:41,840 --> 00:06:46,080
is currently set at 100 milliseconds

00:06:46,400 --> 00:06:50,560
so you can see that you know this kind

00:06:48,800 --> 00:06:53,759
of is similar to how a

00:06:50,560 --> 00:06:55,919
load balanced uh web server would behave

00:06:53,759 --> 00:06:57,360
and and there are uh things called

00:06:55,919 --> 00:06:59,680
assist loads and side loads

00:06:57,360 --> 00:07:01,360
these are basically um just the name

00:06:59,680 --> 00:07:02,240
used for secondary workloads running on

00:07:01,360 --> 00:07:03,599
the system

00:07:02,240 --> 00:07:06,240
whether there's you know management

00:07:03,599 --> 00:07:09,440
workloads like you know updating rpms

00:07:06,240 --> 00:07:10,080
um you know the chef uh which is a

00:07:09,440 --> 00:07:13,120
management

00:07:10,080 --> 00:07:14,880
thing that that a lot of people use um

00:07:13,120 --> 00:07:16,800
all those things right the monitoring

00:07:14,880 --> 00:07:19,520
you know security what not

00:07:16,800 --> 00:07:21,039
or it can be something else entirely an

00:07:19,520 --> 00:07:23,360
opportunistic workload

00:07:21,039 --> 00:07:25,120
which tries to use um capacity which is

00:07:23,360 --> 00:07:27,440
not being used at the moment

00:07:25,120 --> 00:07:29,440
so um those are so those are the

00:07:27,440 --> 00:07:30,240
workloads that that list control demo

00:07:29,440 --> 00:07:32,720
uses

00:07:30,240 --> 00:07:34,240
and there's something called id agent

00:07:32,720 --> 00:07:37,039
and the agent is just that

00:07:34,240 --> 00:07:37,440
it configures the entire system monitors

00:07:37,039 --> 00:07:40,479
that

00:07:37,440 --> 00:07:43,360
um or the configurations are

00:07:40,479 --> 00:07:45,120
are right uh are set up correctly there

00:07:43,360 --> 00:07:46,319
are a lot of requirements and we will go

00:07:45,120 --> 00:07:49,599
through them

00:07:46,319 --> 00:07:52,639
um and and it just manages the entire um

00:07:49,599 --> 00:07:55,199
all the experiments which is run run

00:07:52,639 --> 00:07:55,680
on the system and resource control demo

00:07:55,199 --> 00:07:57,039
is the

00:07:55,680 --> 00:07:59,360
application which presents the whole

00:07:57,039 --> 00:08:03,039
thing in the in that um in the

00:07:59,360 --> 00:08:06,400
terminal application and um

00:08:03,039 --> 00:08:08,960
here's the uh thing so one one

00:08:06,400 --> 00:08:10,240
focus the resource control demo the the

00:08:08,960 --> 00:08:13,520
demo app has is that

00:08:10,240 --> 00:08:14,879
on documentation so because um in the

00:08:13,520 --> 00:08:17,599
process of developing

00:08:14,879 --> 00:08:19,280
uh resource control and applying them uh

00:08:17,599 --> 00:08:21,360
in in facebook fleet

00:08:19,280 --> 00:08:23,280
we just encountered a lot of surprises

00:08:21,360 --> 00:08:27,039
we had to develop a lot of things

00:08:23,280 --> 00:08:29,919
and um you know this is uh there are

00:08:27,039 --> 00:08:31,039
a fairly uh unintuitive interactions

00:08:29,919 --> 00:08:34,560
between components

00:08:31,039 --> 00:08:37,120
and and and resources so um

00:08:34,560 --> 00:08:38,080
to to to configure and and to

00:08:37,120 --> 00:08:41,440
successfully

00:08:38,080 --> 00:08:42,479
uh uh implement comprehensive resource

00:08:41,440 --> 00:08:44,320
control

00:08:42,479 --> 00:08:45,760
you just have to you know meet a lot of

00:08:44,320 --> 00:08:47,279
requirements in terms of you know what

00:08:45,760 --> 00:08:49,120
file system you use

00:08:47,279 --> 00:08:51,360
what uh controller use how they are

00:08:49,120 --> 00:08:54,320
configured and all those things

00:08:51,360 --> 00:08:55,279
um so for example one thing that a

00:08:54,320 --> 00:08:57,920
resource controller

00:08:55,279 --> 00:08:58,959
rd agent does is um configuring the

00:08:57,920 --> 00:09:01,040
whole system

00:08:58,959 --> 00:09:02,560
uh for comprehensive resource control

00:09:01,040 --> 00:09:04,800
and then reporting anything

00:09:02,560 --> 00:09:06,160
uh which is missing and and this is

00:09:04,800 --> 00:09:09,600
resource control demo the

00:09:06,160 --> 00:09:11,760
the ty uh the the interface application

00:09:09,600 --> 00:09:12,880
reporting you know all the requirements

00:09:11,760 --> 00:09:15,040
which are met

00:09:12,880 --> 00:09:17,440
here or the uh here's the part of the

00:09:15,040 --> 00:09:19,200
list um and if any requirement is

00:09:17,440 --> 00:09:20,959
missing it will be highlighted in red

00:09:19,200 --> 00:09:23,839
and you can read it and then you know

00:09:20,959 --> 00:09:23,839
resolve it

00:09:24,000 --> 00:09:29,120
so um so with that um

00:09:27,200 --> 00:09:30,240
we let's look at you know what resource

00:09:29,120 --> 00:09:33,360
control demo can

00:09:30,240 --> 00:09:34,000
can show um in in practice right i mean

00:09:33,360 --> 00:09:36,240
so let's

00:09:34,000 --> 00:09:38,160
first look at the protection scenario so

00:09:36,240 --> 00:09:40,080
this is basically gonna be a similar

00:09:38,160 --> 00:09:43,440
scenario the same scenario

00:09:40,080 --> 00:09:45,519
um as that as the the first graph

00:09:43,440 --> 00:09:47,279
where we were uh demonstrating

00:09:45,519 --> 00:09:49,279
protection with live traffic

00:09:47,279 --> 00:09:50,800
and improved environment and then we're

00:09:49,279 --> 00:09:54,320
going to show the same thing

00:09:50,800 --> 00:09:54,320
using a resource control demo

00:09:56,160 --> 00:10:00,160
and so this is the scenario so web

00:09:58,959 --> 00:10:05,360
server is

00:10:00,160 --> 00:10:05,360
running at full capacity and

00:10:05,760 --> 00:10:11,200
i lost my terminal okay um and the

00:10:09,120 --> 00:10:12,800
something in management section which is

00:10:11,200 --> 00:10:15,120
running in systemd speak

00:10:12,800 --> 00:10:16,560
system.slice right workload is running

00:10:15,120 --> 00:10:19,120
in workload.slice

00:10:16,560 --> 00:10:20,720
in separate c groups and the system

00:10:19,120 --> 00:10:22,079
portion the management part is running

00:10:20,720 --> 00:10:24,000
in system the slice

00:10:22,079 --> 00:10:26,079
and then it has a new bug leaking memory

00:10:24,000 --> 00:10:27,760
it's the same scenario as before

00:10:26,079 --> 00:10:30,560
and the question is whether we can

00:10:27,760 --> 00:10:31,839
survive if this happens across a lot of

00:10:30,560 --> 00:10:32,959
machines so we're just going to be

00:10:31,839 --> 00:10:34,560
looking at one machine

00:10:32,959 --> 00:10:35,839
but you know that's what's at stake you

00:10:34,560 --> 00:10:38,399
know are we going to be losing a lot of

00:10:35,839 --> 00:10:41,360
machines all over this

00:10:38,399 --> 00:10:42,079
and um let me restore the terminal

00:10:41,360 --> 00:10:46,320
because i

00:10:42,079 --> 00:10:49,760
lost it for some reason

00:10:46,320 --> 00:10:52,480
all right give me

00:10:49,760 --> 00:10:52,480
five seconds

00:10:56,560 --> 00:11:03,920
all right

00:11:01,519 --> 00:11:05,040
okay so this is screenshot but um let's

00:11:03,920 --> 00:11:15,839
um let's go to

00:11:05,040 --> 00:11:15,839
uh live live demo

00:11:16,560 --> 00:11:22,480
all right so um this is a live demo

00:11:19,920 --> 00:11:23,519
um so here resource control demo is

00:11:22,480 --> 00:11:26,000
running on a desktop

00:11:23,519 --> 00:11:27,680
sitting right next to me right now and

00:11:26,000 --> 00:11:28,000
we are gonna navigate to don't worry

00:11:27,680 --> 00:11:31,360
about

00:11:28,000 --> 00:11:33,760
you know reading the text um is fine

00:11:31,360 --> 00:11:35,680
you don't need to um i'm gonna be uh i'm

00:11:33,760 --> 00:11:37,440
gonna be explaining what i'm doing

00:11:35,680 --> 00:11:39,279
and and later there's gonna be screen

00:11:37,440 --> 00:11:42,720
captures and then i'm gonna explain

00:11:39,279 --> 00:11:44,800
you know uh how it all works out so i

00:11:42,720 --> 00:11:46,480
navigated to a page which is called

00:11:44,800 --> 00:11:48,560
sigrup and resource protection

00:11:46,480 --> 00:11:50,000
and then it it basically explains you

00:11:48,560 --> 00:11:51,519
know what what i've been saying right i

00:11:50,000 --> 00:11:52,639
mean what the scenario is you know

00:11:51,519 --> 00:11:55,680
what's at stake

00:11:52,639 --> 00:11:56,639
and all those things um and here if you

00:11:55,680 --> 00:11:59,040
look at the

00:11:56,639 --> 00:12:00,560
left section like there's there there's

00:11:59,040 --> 00:12:02,000
graph right there's a

00:12:00,560 --> 00:12:03,760
blue line and there's green lines the

00:12:02,000 --> 00:12:07,600
green line which is going up

00:12:03,760 --> 00:12:11,200
is the rps and the blue line is latency

00:12:07,600 --> 00:12:12,959
um and right now it's just ramping up

00:12:11,200 --> 00:12:15,279
and it just reached 100 percent load

00:12:12,959 --> 00:12:18,000
level so green line is now at the max

00:12:15,279 --> 00:12:19,440
that's the best the machine can do and

00:12:18,000 --> 00:12:22,240
um

00:12:19,440 --> 00:12:23,920
latency hasn't um stabilized yet but you

00:12:22,240 --> 00:12:27,279
know it's going to stabilize around you

00:12:23,920 --> 00:12:29,920
know 900 milliseconds

00:12:27,279 --> 00:12:30,880
okay um normally i would wait a little

00:12:29,920 --> 00:12:33,920
bit more to

00:12:30,880 --> 00:12:34,480
to to for the workload to stabilize but

00:12:33,920 --> 00:12:37,200
here

00:12:34,480 --> 00:12:37,839
um let's just go ahead um so what i'm

00:12:37,200 --> 00:12:40,480
gonna do

00:12:37,839 --> 00:12:42,079
is that like here like the button says

00:12:40,480 --> 00:12:43,920
disable all resource control features

00:12:42,079 --> 00:12:46,240
and start memory hawk so

00:12:43,920 --> 00:12:47,360
i'm gonna turn off all the resource

00:12:46,240 --> 00:12:49,040
control features

00:12:47,360 --> 00:12:50,800
or the you know c group features and

00:12:49,040 --> 00:12:53,040
then um d and then

00:12:50,800 --> 00:12:55,440
start the memory held as you know as

00:12:53,040 --> 00:12:58,639
before in in the production

00:12:55,440 --> 00:13:00,480
experiment um so

00:12:58,639 --> 00:13:02,560
on on the left lower side there are

00:13:00,480 --> 00:13:05,360
these logs going on and it's showing

00:13:02,560 --> 00:13:06,079
um that that memory hook started and it

00:13:05,360 --> 00:13:09,440
is consuming

00:13:06,079 --> 00:13:12,800
memory you know as certain rate

00:13:09,440 --> 00:13:14,000
and if we wait just like five to ten

00:13:12,800 --> 00:13:17,200
seconds

00:13:14,000 --> 00:13:18,079
there we now already start seeing rps

00:13:17,200 --> 00:13:20,320
dropping

00:13:18,079 --> 00:13:21,279
right and latency spiking and rps is

00:13:20,320 --> 00:13:23,760
dropping and

00:13:21,279 --> 00:13:25,680
it's basically the same thing as we we

00:13:23,760 --> 00:13:29,440
saw with the production workload

00:13:25,680 --> 00:13:32,560
and if we go to the graph view um

00:13:29,440 --> 00:13:35,680
we can see so this is showing um

00:13:32,560 --> 00:13:38,240
the the same lps graph and

00:13:35,680 --> 00:13:38,959
and the the top left is the same rps

00:13:38,240 --> 00:13:41,519
graph

00:13:38,959 --> 00:13:42,000
and and the other three are pressure

00:13:41,519 --> 00:13:44,320
graphs

00:13:42,000 --> 00:13:45,120
so it's something called psi it's

00:13:44,320 --> 00:13:48,240
another uh

00:13:45,120 --> 00:13:50,639
important uh component uh for resource

00:13:48,240 --> 00:13:51,600
resource control and it measures uh

00:13:50,639 --> 00:13:54,079
which resource

00:13:51,600 --> 00:13:55,360
is uh being contended for and which

00:13:54,079 --> 00:13:58,560
resource is slowing down

00:13:55,360 --> 00:14:01,279
um operation by how much and and

00:13:58,560 --> 00:14:02,079
if you look at the right side um the two

00:14:01,279 --> 00:14:05,600
graphs

00:14:02,079 --> 00:14:08,240
are kind of moving in sync in green

00:14:05,600 --> 00:14:10,160
and it's showing that uh the green is

00:14:08,240 --> 00:14:13,519
the workload so the main workload is

00:14:10,160 --> 00:14:16,079
is experiencing fairly high level of um

00:14:13,519 --> 00:14:18,480
memory and io contention and that's why

00:14:16,079 --> 00:14:20,880
you know we lost all the rps

00:14:18,480 --> 00:14:21,839
and then you can navigate to other parts

00:14:20,880 --> 00:14:24,160
of the graph

00:14:21,839 --> 00:14:26,000
and i'm gonna go through over them but

00:14:24,160 --> 00:14:28,399
yeah that's how basically it works

00:14:26,000 --> 00:14:30,000
but here um what you can see is that um

00:14:28,399 --> 00:14:31,920
you know we completely lost this server

00:14:30,000 --> 00:14:33,279
right i mean if it had been our web

00:14:31,920 --> 00:14:35,360
server is not serving

00:14:33,279 --> 00:14:37,199
any traffic anymore and hold the machine

00:14:35,360 --> 00:14:40,399
the whole machine is occupied by

00:14:37,199 --> 00:14:42,000
running this um this memory hawk which

00:14:40,399 --> 00:14:46,079
is not what you want

00:14:42,000 --> 00:14:46,079
um so let's go back to our slides

00:14:53,680 --> 00:14:58,000
all right so now this is a screen

00:14:55,839 --> 00:15:00,240
capture so i just wanna you know because

00:14:58,000 --> 00:15:01,760
that happens in in like you know a

00:15:00,240 --> 00:15:04,000
minute time frame i just wanna

00:15:01,760 --> 00:15:05,760
um break it down a little bit so this is

00:15:04,000 --> 00:15:08,959
a screen capture from um

00:15:05,760 --> 00:15:11,360
previous session um and

00:15:08,959 --> 00:15:12,160
here is just ramping up right i just hit

00:15:11,360 --> 00:15:15,440
the the

00:15:12,160 --> 00:15:18,320
web server or id hd web server um

00:15:15,440 --> 00:15:18,880
approximation and and rps is going up

00:15:18,320 --> 00:15:23,040
and then

00:15:18,880 --> 00:15:25,920
eventually the the latency stabilizes

00:15:23,040 --> 00:15:28,240
and on the next slide now this is what

00:15:25,920 --> 00:15:29,440
we just did right i mean we disabled all

00:15:28,240 --> 00:15:32,560
resource control

00:15:29,440 --> 00:15:33,360
and started a memory leak and then we

00:15:32,560 --> 00:15:36,880
saw

00:15:33,360 --> 00:15:40,079
the ips wrapping and if we if you

00:15:36,880 --> 00:15:42,639
uh if you if we take a closer look at it

00:15:40,079 --> 00:15:43,839
there are fairly several interesting

00:15:42,639 --> 00:15:46,160
aspects to it

00:15:43,839 --> 00:15:47,759
so this is the graph view and it's you

00:15:46,160 --> 00:15:50,320
know about the same graph

00:15:47,759 --> 00:15:51,920
as before um as all these instances are

00:15:50,320 --> 00:15:56,000
you know fairly similar

00:15:51,920 --> 00:15:59,199
um so so memory and io the green part

00:15:56,000 --> 00:16:00,079
the the two right the two graphs on the

00:15:59,199 --> 00:16:01,920
right side

00:16:00,079 --> 00:16:03,519
the greens are going up right that's not

00:16:01,920 --> 00:16:05,759
good that means that

00:16:03,519 --> 00:16:06,880
um our main workflow is experiencing

00:16:05,759 --> 00:16:08,720
memory and io

00:16:06,880 --> 00:16:10,000
pressure one thing which is interesting

00:16:08,720 --> 00:16:12,800
is that they are uh

00:16:10,000 --> 00:16:13,199
moving about the same right this means

00:16:12,800 --> 00:16:16,720
that

00:16:13,199 --> 00:16:17,440
um that um that there's a memory

00:16:16,720 --> 00:16:19,360
pressure like

00:16:17,440 --> 00:16:20,720
there's memory contention and memory

00:16:19,360 --> 00:16:24,000
condition is causing

00:16:20,720 --> 00:16:26,880
a lot of ios and what we are

00:16:24,000 --> 00:16:29,040
basically ending up strolling for uh is

00:16:26,880 --> 00:16:30,959
the ios right so we are waiting for ios

00:16:29,040 --> 00:16:33,440
and that's why we cannot make progress

00:16:30,959 --> 00:16:35,279
so that's why io pressure is deported

00:16:33,440 --> 00:16:36,000
and because all the memory operations

00:16:35,279 --> 00:16:39,199
are waiting for

00:16:36,000 --> 00:16:41,759
i o also memory pressure

00:16:39,199 --> 00:16:43,600
move in in tandem with i o pressure this

00:16:41,759 --> 00:16:45,839
is not always the case but you know in

00:16:43,600 --> 00:16:47,680
scenarios like this um you know this is

00:16:45,839 --> 00:16:50,160
the case

00:16:47,680 --> 00:16:51,680
so if if we look at the next part the

00:16:50,160 --> 00:16:53,920
utilization graph

00:16:51,680 --> 00:16:55,040
um top right there's the memory

00:16:53,920 --> 00:16:57,360
utilization

00:16:55,040 --> 00:16:58,639
so if you look at the green line green

00:16:57,360 --> 00:17:00,720
is you know

00:16:58,639 --> 00:17:02,320
falling down right and then at the

00:17:00,720 --> 00:17:05,919
bottom purple line is going

00:17:02,320 --> 00:17:09,520
up so purple line is the the

00:17:05,919 --> 00:17:11,199
management part of the system so um

00:17:09,520 --> 00:17:13,360
what's happening is that um as the

00:17:11,199 --> 00:17:15,120
purple line um this management part

00:17:13,360 --> 00:17:16,319
leaks memory it takes up more and more

00:17:15,120 --> 00:17:18,559
and more memory

00:17:16,319 --> 00:17:20,799
and that's eating into memory you know

00:17:18,559 --> 00:17:23,199
which you know should be going to to the

00:17:20,799 --> 00:17:24,079
the for the main workload so you know

00:17:23,199 --> 00:17:26,160
it's eating up

00:17:24,079 --> 00:17:27,679
and that's what's happening and if you

00:17:26,160 --> 00:17:32,000
look at the top left part

00:17:27,679 --> 00:17:35,280
that's swab utilization right so um

00:17:32,000 --> 00:17:36,880
sd i i think i'm not gonna wear on the

00:17:35,280 --> 00:17:40,640
right side it keeps falling

00:17:36,880 --> 00:17:42,720
down um so the on the left side um

00:17:40,640 --> 00:17:43,919
the purple line is going up and green

00:17:42,720 --> 00:17:44,320
light is going it just means that you

00:17:43,919 --> 00:17:46,080
know

00:17:44,320 --> 00:17:47,360
both are experiencing memory a lot of

00:17:46,080 --> 00:17:49,280
memory contention

00:17:47,360 --> 00:17:50,880
and and you know so and they're ending

00:17:49,280 --> 00:17:54,240
up swapping out their memory to

00:17:50,880 --> 00:17:57,360
to to swap right and um

00:17:54,240 --> 00:17:59,679
and you know and it cannot really run

00:17:57,360 --> 00:18:00,960
because it's you know so short on memory

00:17:59,679 --> 00:18:04,080
so cpu literature

00:18:00,960 --> 00:18:04,720
drops on the top left and and if you

00:18:04,080 --> 00:18:08,240
look at

00:18:04,720 --> 00:18:11,520
the next part the io graphs this um

00:18:08,240 --> 00:18:13,200
you can see uh so the previous script

00:18:11,520 --> 00:18:15,200
right i mean the um

00:18:13,200 --> 00:18:16,640
the memory utilization so this is

00:18:15,200 --> 00:18:19,520
happening because

00:18:16,640 --> 00:18:20,880
uh memory is not protected uh on the

00:18:19,520 --> 00:18:23,440
workload right so

00:18:20,880 --> 00:18:24,880
we don't want the memory late to be able

00:18:23,440 --> 00:18:26,240
to eat into

00:18:24,880 --> 00:18:28,160
main workloads memory but that's

00:18:26,240 --> 00:18:28,720
happening so memory protection is not

00:18:28,160 --> 00:18:30,480
there

00:18:28,720 --> 00:18:32,799
that's why that's failing and if you

00:18:30,480 --> 00:18:36,160
look at this what's going on is that

00:18:32,799 --> 00:18:37,440
so top left is read bps top right is

00:18:36,160 --> 00:18:40,720
right bps

00:18:37,440 --> 00:18:43,919
and the green line is our main workload

00:18:40,720 --> 00:18:46,799
purple line is you know our offender and

00:18:43,919 --> 00:18:48,720
if you look at the right part right um

00:18:46,799 --> 00:18:50,160
what's happening is as the memory gets

00:18:48,720 --> 00:18:52,320
tighter and tighter

00:18:50,160 --> 00:18:54,240
right there are there's supposed more

00:18:52,320 --> 00:18:56,400
reads because you know you need to 14

00:18:54,240 --> 00:18:58,559
more memory

00:18:56,400 --> 00:19:00,559
b14 more memory and there's also more

00:18:58,559 --> 00:19:02,880
rights because you are swapping out

00:19:00,559 --> 00:19:04,240
and and what's happening is that uh

00:19:02,880 --> 00:19:07,360
these reads and rights

00:19:04,240 --> 00:19:09,200
um the rights are adding up to 300 mega

00:19:07,360 --> 00:19:11,840
bps

00:19:09,200 --> 00:19:13,200
sustained which is about maximum this

00:19:11,840 --> 00:19:15,840
device can do

00:19:13,200 --> 00:19:16,799
um so this is completely saturating the

00:19:15,840 --> 00:19:19,039
device

00:19:16,799 --> 00:19:21,520
um and if you look at the bottom two

00:19:19,039 --> 00:19:24,720
graphs there's read and write latencies

00:19:21,520 --> 00:19:27,919
and and they're rising to

00:19:24,720 --> 00:19:31,120
to tens of uh milliseconds so both

00:19:27,919 --> 00:19:34,320
p p 90 p also p 50

00:19:31,120 --> 00:19:37,360
so the median median uh

00:19:34,320 --> 00:19:39,919
read completion latency 90th percentile

00:19:37,360 --> 00:19:41,840
99th percentile they're all going up to

00:19:39,919 --> 00:19:45,120
you know tens of milliseconds

00:19:41,840 --> 00:19:47,760
and if you remember that you know the

00:19:45,120 --> 00:19:50,080
the latency requirement latency target

00:19:47,760 --> 00:19:52,720
is around 100 milliseconds right we

00:19:50,080 --> 00:19:53,520
we want to be able to answer um you know

00:19:52,720 --> 00:19:56,720
n is

00:19:53,520 --> 00:19:58,960
under 100 milliseconds um and

00:19:56,720 --> 00:20:00,799
if you're missing multiple pages because

00:19:58,960 --> 00:20:02,559
of memory pressure you have to

00:20:00,799 --> 00:20:04,000
issue multiple ios completing a single

00:20:02,559 --> 00:20:07,039
request and if

00:20:04,000 --> 00:20:08,240
singly test takes you know you know 50

00:20:07,039 --> 00:20:10,400
milliseconds

00:20:08,240 --> 00:20:11,760
you you don't have a chance to meet that

00:20:10,400 --> 00:20:13,360
latency target

00:20:11,760 --> 00:20:15,200
so that's why you know the whole thing

00:20:13,360 --> 00:20:18,720
is failing now so

00:20:15,200 --> 00:20:20,320
the lego memory protection is causing

00:20:18,720 --> 00:20:22,880
the main workload to generate a lot of

00:20:20,320 --> 00:20:25,440
bias and leg of io protection

00:20:22,880 --> 00:20:26,400
is causing the i o latencies to spike

00:20:25,440 --> 00:20:28,159
all together

00:20:26,400 --> 00:20:31,200
and and combined you know the workload

00:20:28,159 --> 00:20:31,200
just doesn't have a chance

00:20:31,440 --> 00:20:35,760
now let's try the same scenario with all

00:20:34,080 --> 00:20:38,240
the protections turned on

00:20:35,760 --> 00:20:39,440
so here the protections are cpu weight

00:20:38,240 --> 00:20:42,640
which is proportional

00:20:39,440 --> 00:20:44,400
cpu controller memory that low it's not

00:20:42,640 --> 00:20:45,200
quite proportional but it behaves like a

00:20:44,400 --> 00:20:47,679
proportional

00:20:45,200 --> 00:20:49,520
uh in a way uh is is basically

00:20:47,679 --> 00:20:51,200
prioritized memory allocation for the

00:20:49,520 --> 00:20:53,280
main workload

00:20:51,200 --> 00:20:55,600
and io weight which is proportional io

00:20:53,280 --> 00:20:57,120
controller and the io8 is uh

00:20:55,600 --> 00:20:58,960
implemented by something called io cost

00:20:57,120 --> 00:21:01,039
controller um

00:20:58,960 --> 00:21:02,880
and and those are the c group

00:21:01,039 --> 00:21:05,840
controllers um

00:21:02,880 --> 00:21:07,520
prioritizing which would be prioritizing

00:21:05,840 --> 00:21:08,880
the main workload over the system

00:21:07,520 --> 00:21:11,200
management part

00:21:08,880 --> 00:21:12,960
and there's also something called umd

00:21:11,200 --> 00:21:15,120
and and what umd does is

00:21:12,960 --> 00:21:17,039
um kind of it's like an early warning

00:21:15,120 --> 00:21:17,919
system so before system gets you into

00:21:17,039 --> 00:21:20,480
real trouble

00:21:17,919 --> 00:21:22,720
it intervenes and and you know kills

00:21:20,480 --> 00:21:27,760
whatever is really misbehaving

00:21:22,720 --> 00:21:27,760
um so i'm gonna switch back to the live

00:21:28,840 --> 00:21:31,840
terminal

00:21:34,559 --> 00:21:36,880
all right

00:21:39,600 --> 00:21:50,000
okay we're back

00:21:45,360 --> 00:21:53,520
so uh because we left it along

00:21:50,000 --> 00:21:56,320
um the workload eventually um oops

00:21:53,520 --> 00:21:57,440
eventually um eventually recovered right

00:21:56,320 --> 00:21:59,600
um so

00:21:57,440 --> 00:22:00,880
so workload is running in four tilt uh

00:21:59,600 --> 00:22:02,720
at a maximum load

00:22:00,880 --> 00:22:05,120
and latency is you know about 100

00:22:02,720 --> 00:22:08,320
milliseconds slightly below that

00:22:05,120 --> 00:22:11,600
um so everything is looking good and

00:22:08,320 --> 00:22:14,960
and now all the resource uh

00:22:11,600 --> 00:22:17,840
are are enabled back uh that's uh

00:22:14,960 --> 00:22:18,720
indicated on the top left part um when

00:22:17,840 --> 00:22:20,799
you actually try it

00:22:18,720 --> 00:22:23,120
you'll be able to see but you know

00:22:20,799 --> 00:22:24,799
indicating that it's indicating that

00:22:23,120 --> 00:22:27,360
resource controls are enabled only is

00:22:24,799 --> 00:22:28,799
enabled and now i'm going to start the

00:22:27,360 --> 00:22:31,360
same memory hog

00:22:28,799 --> 00:22:31,840
or memory bomb memory leak that i used

00:22:31,360 --> 00:22:34,799
before

00:22:31,840 --> 00:22:35,360
as before so this is exactly the same

00:22:34,799 --> 00:22:37,200
thing

00:22:35,360 --> 00:22:40,240
the only difference is that the resource

00:22:37,200 --> 00:22:43,679
protection is turned on

00:22:40,240 --> 00:22:45,280
and if you if you remember our last try

00:22:43,679 --> 00:22:48,720
without protection

00:22:45,280 --> 00:22:49,679
after about 15-20 seconds our rps was at

00:22:48,720 --> 00:22:52,960
zero

00:22:49,679 --> 00:22:56,400
um and we are already at

00:22:52,960 --> 00:22:59,679
15 seconds um now about 20 seconds

00:22:56,400 --> 00:23:01,360
and you can see that um there's really

00:22:59,679 --> 00:23:02,960
not much change right i mean so there's

00:23:01,360 --> 00:23:05,600
a small dip so they're like

00:23:02,960 --> 00:23:06,000
really small dips but nothing really you

00:23:05,600 --> 00:23:09,200
know

00:23:06,000 --> 00:23:11,280
nothing drastic happens and if you

00:23:09,200 --> 00:23:12,400
check out the graphs and they look

00:23:11,280 --> 00:23:15,440
really different too

00:23:12,400 --> 00:23:19,200
we are going to go over them um so the

00:23:15,440 --> 00:23:19,200
pressure graphs look really different

00:23:20,159 --> 00:23:23,520
the utilization graph looks really

00:23:21,840 --> 00:23:27,520
different too and

00:23:23,520 --> 00:23:30,720
so does iographs um and um

00:23:27,520 --> 00:23:32,480
one thing is that like the system um

00:23:30,720 --> 00:23:34,000
left in this state the system gets

00:23:32,480 --> 00:23:35,679
sustained this um

00:23:34,000 --> 00:23:37,520
uh you know indefinitely it doesn't it

00:23:35,679 --> 00:23:38,880
doesn't care right i mean no matter how

00:23:37,520 --> 00:23:40,400
many times you try it there's

00:23:38,880 --> 00:23:42,080
you know the workload is the main

00:23:40,400 --> 00:23:44,799
workload is gonna be fine

00:23:42,080 --> 00:23:46,080
um and eventually umd is gonna kick in

00:23:44,799 --> 00:23:49,360
and and and visual

00:23:46,080 --> 00:23:51,360
situation so let's go back to slide

00:23:49,360 --> 00:23:54,000
and see what actually happened what's

00:23:51,360 --> 00:23:54,000
actually happening

00:24:00,320 --> 00:24:06,320
all right

00:24:04,080 --> 00:24:08,000
yeah this is you know our starting point

00:24:06,320 --> 00:24:12,880
we started the memory

00:24:08,000 --> 00:24:16,159
memory leak nothing really changed

00:24:12,880 --> 00:24:17,039
and this is the rps and resource

00:24:16,159 --> 00:24:20,960
pressure graph

00:24:17,039 --> 00:24:24,159
um and if you remember the previous

00:24:20,960 --> 00:24:24,880
uh you know try without protection we

00:24:24,159 --> 00:24:27,440
saw the

00:24:24,880 --> 00:24:28,400
the green graphs going up right so this

00:24:27,440 --> 00:24:30,960
that was the

00:24:28,400 --> 00:24:33,120
main workloads memory and io pressure

00:24:30,960 --> 00:24:35,279
going up in tandem

00:24:33,120 --> 00:24:36,320
and and that crashed everything here if

00:24:35,279 --> 00:24:39,440
you look at the two

00:24:36,320 --> 00:24:42,080
right the two graphs on the right side

00:24:39,440 --> 00:24:42,720
um green graph there's some green dust

00:24:42,080 --> 00:24:44,799
at the bottom

00:24:42,720 --> 00:24:47,200
meaning that um you know the the

00:24:44,799 --> 00:24:50,320
workload pressure went up a little bit

00:24:47,200 --> 00:24:51,520
but for the most part uh only the purple

00:24:50,320 --> 00:24:55,440
lines went up right

00:24:51,520 --> 00:24:57,600
both memory and io so only the um

00:24:55,440 --> 00:24:59,520
the uh the management part right the

00:24:57,600 --> 00:25:02,240
where the memory leak is happening

00:24:59,520 --> 00:25:06,000
they are experiencing pressure and main

00:25:02,240 --> 00:25:06,000
workload is isolated from it

00:25:06,720 --> 00:25:12,480
and um here too um

00:25:10,480 --> 00:25:14,720
like before right if you look looked at

00:25:12,480 --> 00:25:15,840
the looked at the memory utilization

00:25:14,720 --> 00:25:18,559
graph on the top

00:25:15,840 --> 00:25:19,679
right um purple was going up green was

00:25:18,559 --> 00:25:22,080
going down right

00:25:19,679 --> 00:25:23,520
here purple is staying you know still

00:25:22,080 --> 00:25:24,960
like i mean it's staying at the same

00:25:23,520 --> 00:25:25,919
high level it's using most of the

00:25:24,960 --> 00:25:28,240
machine

00:25:25,919 --> 00:25:30,320
and purple is you know it took a little

00:25:28,240 --> 00:25:31,200
bit of memory but it it cannot expand

00:25:30,320 --> 00:25:33,919
anymore

00:25:31,200 --> 00:25:35,039
um so that's memory uh protection uh

00:25:33,919 --> 00:25:37,360
working

00:25:35,039 --> 00:25:40,000
um and then if you look at the sub

00:25:37,360 --> 00:25:43,679
utilization graph on on top left

00:25:40,000 --> 00:25:46,080
um because the main workload didn't lose

00:25:43,679 --> 00:25:48,480
much memory the swap usage of the main

00:25:46,080 --> 00:25:51,279
workload doesn't really change much

00:25:48,480 --> 00:25:52,559
only the um the the management part the

00:25:51,279 --> 00:25:53,760
purple line is going up

00:25:52,559 --> 00:25:55,679
because you know it's still trying to

00:25:53,760 --> 00:25:57,840
expand with the memory leak and that's

00:25:55,679 --> 00:26:01,039
all getting kicked out to swap

00:25:57,840 --> 00:26:04,799
so that's what's happening and

00:26:01,039 --> 00:26:04,799
let's check out the io part

00:26:04,880 --> 00:26:07,919
and here what's different is that if if

00:26:07,360 --> 00:26:11,760
you

00:26:07,919 --> 00:26:14,559
look at the top right graph um

00:26:11,760 --> 00:26:15,120
before the the purple lines so that's

00:26:14,559 --> 00:26:18,480
this

00:26:15,120 --> 00:26:19,440
right bandwidth right bps to the to the

00:26:18,480 --> 00:26:21,279
ssd

00:26:19,440 --> 00:26:22,480
and before the purple line was

00:26:21,279 --> 00:26:25,360
dominating right

00:26:22,480 --> 00:26:27,440
and and it really overloaded the device

00:26:25,360 --> 00:26:30,480
it was doing like hundreds megabytes per

00:26:27,440 --> 00:26:31,360
per second of writes um and eventually

00:26:30,480 --> 00:26:33,200
the device just

00:26:31,360 --> 00:26:35,039
you know couldn't couldn't handle that

00:26:33,200 --> 00:26:37,200
with reasonable latency

00:26:35,039 --> 00:26:38,720
here if you look at the graph scale

00:26:37,200 --> 00:26:42,159
which might not be visible

00:26:38,720 --> 00:26:44,559
we are now staying at maybe 780

00:26:42,159 --> 00:26:46,240
added up maybe under probably but

00:26:44,559 --> 00:26:49,520
definitely under 100

00:26:46,240 --> 00:26:51,919
mega bps in terms of writes and and

00:26:49,520 --> 00:26:52,880
the the purple lines the the system

00:26:51,919 --> 00:26:55,039
management part

00:26:52,880 --> 00:26:56,640
is being throttled so that you know it

00:26:55,039 --> 00:26:57,919
doesn't push the device beyond these

00:26:56,640 --> 00:27:00,000
limits

00:26:57,919 --> 00:27:01,919
the result of that is if you look at the

00:27:00,000 --> 00:27:03,679
bottom two graphs like the reboost

00:27:01,919 --> 00:27:05,600
reading right latencies

00:27:03,679 --> 00:27:06,799
they are you know mostly staying under

00:27:05,600 --> 00:27:10,159
10 milliseconds

00:27:06,799 --> 00:27:12,960
and 50 is you know under a millisecond

00:27:10,159 --> 00:27:14,080
so um you know that that gives like

00:27:12,960 --> 00:27:16,480
ample time

00:27:14,080 --> 00:27:18,720
uh for the main workload to service

00:27:16,480 --> 00:27:19,679
traffic without violating its latency

00:27:18,720 --> 00:27:21,679
requirements

00:27:19,679 --> 00:27:23,279
so this is io controller uh working

00:27:21,679 --> 00:27:24,000
right i mean so io control is making

00:27:23,279 --> 00:27:26,240
sure

00:27:24,000 --> 00:27:27,440
that the device is staying within its

00:27:26,240 --> 00:27:30,720
own limits

00:27:27,440 --> 00:27:31,919
and and and that the the capacity the i

00:27:30,720 --> 00:27:33,840
o capacity

00:27:31,919 --> 00:27:36,799
is being distributed according to you

00:27:33,840 --> 00:27:36,799
know their priorities

00:27:37,360 --> 00:27:41,520
right so eventually right i mean uh

00:27:39,520 --> 00:27:44,720
after this happens for a while

00:27:41,520 --> 00:27:47,600
um this is the the low viewer part so

00:27:44,720 --> 00:27:48,960
umd kicks in and and only you know kills

00:27:47,600 --> 00:27:50,880
the uh the memory

00:27:48,960 --> 00:27:52,799
leak and then you know everything is

00:27:50,880 --> 00:27:54,159
less right and and

00:27:52,799 --> 00:27:55,520
what would happen like if you know

00:27:54,159 --> 00:27:56,320
something like this uh happens in the

00:27:55,520 --> 00:27:58,559
production

00:27:56,320 --> 00:28:00,000
what would happen is that um you know we

00:27:58,559 --> 00:28:00,960
will just have to debug it right this

00:28:00,000 --> 00:28:02,799
will get locked

00:28:00,960 --> 00:28:04,640
you know based on alarm and we will find

00:28:02,799 --> 00:28:07,200
out that some management thing

00:28:04,640 --> 00:28:08,640
um triggered a bunch of um kills so we

00:28:07,200 --> 00:28:10,240
just debug it and and production

00:28:08,640 --> 00:28:11,120
workload wouldn't really get affected

00:28:10,240 --> 00:28:14,399
all that much

00:28:11,120 --> 00:28:16,559
so that's great um and so

00:28:14,399 --> 00:28:18,880
resource control so that's how um visual

00:28:16,559 --> 00:28:20,480
control demo demonstrates and explains

00:28:18,880 --> 00:28:21,919
so there's a lot of text explaining you

00:28:20,480 --> 00:28:24,159
know what goes into

00:28:21,919 --> 00:28:24,960
and why and how they work together and

00:28:24,159 --> 00:28:26,880
all that

00:28:24,960 --> 00:28:28,640
um this so protection is one of the

00:28:26,880 --> 00:28:31,039
scenarios that it explains

00:28:28,640 --> 00:28:31,679
and they're like uh several different

00:28:31,039 --> 00:28:34,720
sections

00:28:31,679 --> 00:28:37,520
um to to to demo and and

00:28:34,720 --> 00:28:38,720
different scenarios and site loading is

00:28:37,520 --> 00:28:40,960
another of them

00:28:38,720 --> 00:28:42,080
um and it's because this is kind of kind

00:28:40,960 --> 00:28:45,279
of cool

00:28:42,080 --> 00:28:48,720
so let's take a look

00:28:45,279 --> 00:28:51,760
so um the site loading um is that

00:28:48,720 --> 00:28:55,039
so what is side loading

00:28:51,760 --> 00:28:57,120
a lot of machines um are not

00:28:55,039 --> 00:28:58,240
utilized fully and then there's a lot of

00:28:57,120 --> 00:29:00,080
reasons for that

00:28:58,240 --> 00:29:01,520
um scheduling inefficiencies you know

00:29:00,080 --> 00:29:03,360
stacking inefficiencies

00:29:01,520 --> 00:29:04,880
um which can be improved but also there

00:29:03,360 --> 00:29:08,640
are things like um what do you call

00:29:04,880 --> 00:29:10,480
a digestive readiness buffer um

00:29:08,640 --> 00:29:12,080
what they are is that you know for

00:29:10,480 --> 00:29:14,799
example if you lose a

00:29:12,080 --> 00:29:16,880
region right a data center for you know

00:29:14,799 --> 00:29:19,200
for an earthquake or whatever right

00:29:16,880 --> 00:29:19,919
if the data center goes down suddenly we

00:29:19,200 --> 00:29:21,679
have to

00:29:19,919 --> 00:29:23,200
uh other remaining data centers have to

00:29:21,679 --> 00:29:25,760
take over um

00:29:23,200 --> 00:29:26,960
immediately and and that has to happen

00:29:25,760 --> 00:29:28,960
like really quickly

00:29:26,960 --> 00:29:30,720
so that you know we don't our users you

00:29:28,960 --> 00:29:31,679
know don't experience any disruptions in

00:29:30,720 --> 00:29:35,200
service

00:29:31,679 --> 00:29:35,840
so we that's what djs already buffer so

00:29:35,200 --> 00:29:38,320
we run

00:29:35,840 --> 00:29:39,600
critical services with some headroom so

00:29:38,320 --> 00:29:41,679
that we can take over

00:29:39,600 --> 00:29:42,720
when some you know when some accidents

00:29:41,679 --> 00:29:44,640
happen

00:29:42,720 --> 00:29:45,840
means meaning that you know there are

00:29:44,640 --> 00:29:48,240
always some slack

00:29:45,840 --> 00:29:49,600
uh in a lot of machines that we use so

00:29:48,240 --> 00:29:54,399
that's the air buffer

00:29:49,600 --> 00:29:57,200
um so because we have like this uh

00:29:54,399 --> 00:29:58,399
unused capacity be nice if you can use

00:29:57,200 --> 00:29:59,600
you know something productive you know

00:29:58,399 --> 00:30:03,039
video encoding

00:29:59,600 --> 00:30:03,679
um you know a lot of ai training or

00:30:03,039 --> 00:30:05,600
whatever

00:30:03,679 --> 00:30:07,279
right i mean if you can use this um

00:30:05,600 --> 00:30:10,799
capacity for this

00:30:07,279 --> 00:30:12,159
you know uh batch opportunity workload

00:30:10,799 --> 00:30:13,279
it'd be really great right just be a lot

00:30:12,159 --> 00:30:14,799
more efficient

00:30:13,279 --> 00:30:17,279
so that's the idea of a site loading you

00:30:14,799 --> 00:30:19,600
know can we use the unused capacity for

00:30:17,279 --> 00:30:24,080
something else

00:30:19,600 --> 00:30:25,760
oh let's not go there yet um

00:30:24,080 --> 00:30:27,039
one thing is that like if you think

00:30:25,760 --> 00:30:28,720
about the you know previous the

00:30:27,039 --> 00:30:31,120
protection scenario

00:30:28,720 --> 00:30:32,480
um that was you know a form of side

00:30:31,120 --> 00:30:33,440
loading right i mean we had main

00:30:32,480 --> 00:30:36,960
workload

00:30:33,440 --> 00:30:38,480
and we had um we had the memory late

00:30:36,960 --> 00:30:40,080
which is the you know secondary workload

00:30:38,480 --> 00:30:42,000
let's call it secondary workload

00:30:40,080 --> 00:30:43,840
and and the protection did pretty well

00:30:42,000 --> 00:30:45,919
right i mean it protected

00:30:43,840 --> 00:30:46,880
um the main workload from the secondary

00:30:45,919 --> 00:30:48,880
workload so maybe

00:30:46,880 --> 00:30:50,960
that's enough but that that would be you

00:30:48,880 --> 00:30:53,840
know uh the first thought

00:30:50,960 --> 00:30:55,279
um which would occur um that's what we

00:30:53,840 --> 00:30:59,039
we try to right i mean

00:30:55,279 --> 00:31:01,440
maybe they will just work um and and

00:30:59,039 --> 00:31:03,360
so that's what you did um so if you

00:31:01,440 --> 00:31:06,559
navigate to

00:31:03,360 --> 00:31:09,039
the uh site loading section of um

00:31:06,559 --> 00:31:10,480
resource control demo there's a in the

00:31:09,039 --> 00:31:11,840
instruction part there's a section

00:31:10,480 --> 00:31:14,559
called a knife approach

00:31:11,840 --> 00:31:14,880
so it's emulating that exact scenario

00:31:14,559 --> 00:31:18,240
it's

00:31:14,880 --> 00:31:21,840
trying to run side load just with

00:31:18,240 --> 00:31:24,720
you know protection settings and um

00:31:21,840 --> 00:31:25,200
if you look at the left graph it's

00:31:24,720 --> 00:31:28,799
showing

00:31:25,200 --> 00:31:30,799
again ips and latency and and

00:31:28,799 --> 00:31:32,240
it's not running at full load like

00:31:30,799 --> 00:31:33,919
before uh so

00:31:32,240 --> 00:31:36,240
before you know things happened to the

00:31:33,919 --> 00:31:38,799
graph what it was doing is that uh

00:31:36,240 --> 00:31:39,440
the the web server or you know rd hd in

00:31:38,799 --> 00:31:43,039
this case

00:31:39,440 --> 00:31:46,240
was running at about 60 um load level

00:31:43,039 --> 00:31:49,519
which is you know not too unusual um for

00:31:46,240 --> 00:31:51,519
for a lot of services that we use um and

00:31:49,519 --> 00:31:53,120
then you know in the middle of the graph

00:31:51,519 --> 00:31:54,960
i uh started

00:31:53,120 --> 00:31:57,440
a linux build job right i mean so it's

00:31:54,960 --> 00:31:58,240
just built it's untiling and building

00:31:57,440 --> 00:32:01,440
linux corner

00:31:58,240 --> 00:32:03,360
with fairly high concurrency and after a

00:32:01,440 --> 00:32:05,440
bit you know it starts compiling so it's

00:32:03,360 --> 00:32:08,960
trying to occupy all the cpus

00:32:05,440 --> 00:32:11,760
and what happens is while our rps

00:32:08,960 --> 00:32:14,159
stays you know about at 60 so green line

00:32:11,760 --> 00:32:17,600
doesn't deviate from the middle match

00:32:14,159 --> 00:32:19,120
our blue line goes up right so what's

00:32:17,600 --> 00:32:20,640
happening here is that when the machine

00:32:19,120 --> 00:32:23,360
is not fully utilized

00:32:20,640 --> 00:32:24,960
we have uh we earn a lot of credit in

00:32:23,360 --> 00:32:27,360
terms of latency right

00:32:24,960 --> 00:32:28,640
at full load those hundred milliseconds

00:32:27,360 --> 00:32:30,399
without at 60

00:32:28,640 --> 00:32:32,159
we can serve our clients at 40

00:32:30,399 --> 00:32:34,159
milliseconds which is great

00:32:32,159 --> 00:32:35,519
but now we try to utilize what's the

00:32:34,159 --> 00:32:37,519
remaining of the machine

00:32:35,519 --> 00:32:38,799
and now we are now we are pushing up the

00:32:37,519 --> 00:32:41,200
latency you know to

00:32:38,799 --> 00:32:42,880
70 you know 80 milliseconds which is not

00:32:41,200 --> 00:32:44,559
great we don't want to take that heat

00:32:42,880 --> 00:32:45,919
just to utilize you know that the

00:32:44,559 --> 00:32:49,519
remaining capacity

00:32:45,919 --> 00:32:52,000
um it's it's a you know it's it's it's a

00:32:49,519 --> 00:32:55,200
difficult appeal to swallow when it's

00:32:52,000 --> 00:32:55,200
impacting usually experience

00:32:55,600 --> 00:33:03,039
um and this is the ips and psi graph

00:32:59,679 --> 00:33:03,519
um that i'm not going to go into right

00:33:03,039 --> 00:33:10,480
now

00:33:03,519 --> 00:33:13,200
um just because of time and yeah

00:33:10,480 --> 00:33:15,519
um so what why is latency deteriorating

00:33:13,200 --> 00:33:17,600
right i mean even with all the um

00:33:15,519 --> 00:33:18,799
or the resource protection why is it

00:33:17,600 --> 00:33:22,159
deteriorating

00:33:18,799 --> 00:33:24,159
um one thing is that we like to think

00:33:22,159 --> 00:33:25,200
that you know cpu is infinitely

00:33:24,159 --> 00:33:27,200
divisible

00:33:25,200 --> 00:33:28,559
right i mean like just abs you know

00:33:27,200 --> 00:33:30,399
conceptually thinking

00:33:28,559 --> 00:33:32,080
it's nice to think that you know you get

00:33:30,399 --> 00:33:34,399
20 of cpu you get 80

00:33:32,080 --> 00:33:35,120
of cpu but the thing is that we are

00:33:34,399 --> 00:33:37,679
scheduling

00:33:35,120 --> 00:33:38,240
you know these discrete time blocks

00:33:37,679 --> 00:33:40,880
right

00:33:38,240 --> 00:33:42,880
so as you saturate the cpu more and more

00:33:40,880 --> 00:33:44,159
there are like scheduling artifacts

00:33:42,880 --> 00:33:46,960
right you cannot

00:33:44,159 --> 00:33:48,080
you you generally don't want to schedule

00:33:46,960 --> 00:33:50,720
like switch context

00:33:48,080 --> 00:33:51,120
or every time you so there there are

00:33:50,720 --> 00:33:52,559
these

00:33:51,120 --> 00:33:54,480
artifacts and there's also

00:33:52,559 --> 00:33:54,799
inefficiencies in load balancing right i

00:33:54,480 --> 00:33:57,279
mean

00:33:54,799 --> 00:33:58,159
picking the idle the idle list core in

00:33:57,279 --> 00:34:01,120
the system

00:33:58,159 --> 00:34:02,559
this sometimes not trivial um so there

00:34:01,120 --> 00:34:06,159
are those artifacts

00:34:02,559 --> 00:34:09,760
and even more fundamental than that um

00:34:06,159 --> 00:34:12,079
cpus we measure cpu utilization um

00:34:09,760 --> 00:34:13,919
with workload time right i mean when we

00:34:12,079 --> 00:34:16,079
say we are 70

00:34:13,919 --> 00:34:18,320
utilizing the cpu we are saying that the

00:34:16,079 --> 00:34:19,200
cpu is busy seventy percent of time real

00:34:18,320 --> 00:34:21,919
time right

00:34:19,200 --> 00:34:23,599
on time but i mean that doesn't really

00:34:21,919 --> 00:34:26,159
mean that we are using 70

00:34:23,599 --> 00:34:27,760
resources on the cpu right uh the cpu

00:34:26,159 --> 00:34:28,639
has a lot of share resources you know

00:34:27,760 --> 00:34:32,159
cash

00:34:28,639 --> 00:34:35,520
uh memory bus uh tlb entries

00:34:32,159 --> 00:34:38,399
whatnot alus right or dynamically

00:34:35,520 --> 00:34:38,879
allocated as code execute on the cpus

00:34:38,399 --> 00:34:41,599
and

00:34:38,879 --> 00:34:43,679
as you use cpu you know more and more

00:34:41,599 --> 00:34:46,320
you get closer to content uh

00:34:43,679 --> 00:34:48,240
full saturation all of those you know

00:34:46,320 --> 00:34:50,960
resources get contended for

00:34:48,240 --> 00:34:53,359
and and as a result cpu just excuses

00:34:50,960 --> 00:34:56,399
slower given the same amount of time

00:34:53,359 --> 00:34:57,200
um the the number of instructions it can

00:34:56,399 --> 00:34:59,520
execute

00:34:57,200 --> 00:35:00,880
goes down as you you know saturate the

00:34:59,520 --> 00:35:03,520
cpu more and more

00:35:00,880 --> 00:35:04,320
um basically it's time kind of dilates

00:35:03,520 --> 00:35:07,760
because it gets

00:35:04,320 --> 00:35:10,640
too busy so this you know

00:35:07,760 --> 00:35:11,839
so those two are why those latency

00:35:10,640 --> 00:35:15,040
spikes are happening

00:35:11,839 --> 00:35:17,040
and and the way that we solved it

00:35:15,040 --> 00:35:19,200
is using something called side loader

00:35:17,040 --> 00:35:19,680
and what it does is that it guarantees

00:35:19,200 --> 00:35:21,520
that

00:35:19,680 --> 00:35:22,800
cpu always have a certain amount of

00:35:21,520 --> 00:35:26,000
headroom um

00:35:22,800 --> 00:35:26,800
that is not used to make sure that those

00:35:26,000 --> 00:35:30,000
latency

00:35:26,800 --> 00:35:30,720
artifacts don't happen and this is the

00:35:30,000 --> 00:35:33,839
same thing

00:35:30,720 --> 00:35:37,200
right um it's the same scenario

00:35:33,839 --> 00:35:38,960
run with um with a side load under the

00:35:37,200 --> 00:35:39,920
side loader with a supervision of side

00:35:38,960 --> 00:35:41,839
loader

00:35:39,920 --> 00:35:43,200
and and if you look at the you know

00:35:41,839 --> 00:35:44,480
green and blue line

00:35:43,200 --> 00:35:46,400
they are at different positions just

00:35:44,480 --> 00:35:48,800
because of the the graph scaling

00:35:46,400 --> 00:35:50,079
um changed but you know they're just

00:35:48,800 --> 00:35:51,520
staying the flat right

00:35:50,079 --> 00:35:53,200
they're not really changing much so

00:35:51,520 --> 00:35:54,960
that's what you want to see

00:35:53,200 --> 00:35:57,599
and if you look at the utilization graph

00:35:54,960 --> 00:36:01,040
here um

00:35:57,599 --> 00:36:02,400
what's cool is um um if you look at the

00:36:01,040 --> 00:36:05,599
cpu sound pressure so

00:36:02,400 --> 00:36:07,119
top uh bottom left graph that's in how

00:36:05,599 --> 00:36:09,839
much disappear contention

00:36:07,119 --> 00:36:11,280
um you know different parts of system

00:36:09,839 --> 00:36:12,720
are experiencing

00:36:11,280 --> 00:36:14,960
so the green line is for the main

00:36:12,720 --> 00:36:16,240
workload right so and the blue line is

00:36:14,960 --> 00:36:19,599
for for the um

00:36:16,240 --> 00:36:22,320
for our compile job and so green line uh

00:36:19,599 --> 00:36:23,280
came up a little bit but not by much and

00:36:22,320 --> 00:36:26,400
all the you know

00:36:23,280 --> 00:36:28,160
uh weight is you know uh or the pressure

00:36:26,400 --> 00:36:29,839
contention is experienced by the

00:36:28,160 --> 00:36:32,640
secondary workload which is the compile

00:36:29,839 --> 00:36:35,520
job and if you look at top

00:36:32,640 --> 00:36:36,960
top left graph right um if you look at

00:36:35,520 --> 00:36:38,640
the the blue one

00:36:36,960 --> 00:36:40,000
and there's the latency so latency goes

00:36:38,640 --> 00:36:40,320
up a little bit and there's something we

00:36:40,000 --> 00:36:42,320
can

00:36:40,320 --> 00:36:43,520
we can modulate by changing how much

00:36:42,320 --> 00:36:45,520
headroom we leave

00:36:43,520 --> 00:36:46,640
um but you know that's that's completely

00:36:45,520 --> 00:36:48,640
fine there's something

00:36:46,640 --> 00:36:52,000
we're willing to take if we can use you

00:36:48,640 --> 00:36:52,000
know 30 percent more of the machine

00:36:52,880 --> 00:36:57,200
and now this is the utilization part um

00:36:55,760 --> 00:36:58,640
one thing which is kind of interesting

00:36:57,200 --> 00:37:01,200
is that if you look at top

00:36:58,640 --> 00:37:02,720
uh bottom left graph there's a cpu

00:37:01,200 --> 00:37:05,280
utilization right so green

00:37:02,720 --> 00:37:06,880
is how much the main workload is using

00:37:05,280 --> 00:37:08,800
blue is how much the compile job is

00:37:06,880 --> 00:37:10,720
using um

00:37:08,800 --> 00:37:12,640
and and in the middle right the blue

00:37:10,720 --> 00:37:14,800
comes up that's you know the compiling

00:37:12,640 --> 00:37:17,599
phase of the linux build job starting

00:37:14,800 --> 00:37:18,880
and consuming cpus and you know if you

00:37:17,599 --> 00:37:21,599
add the two up

00:37:18,880 --> 00:37:22,160
uh you know it's registering 70 to 80 of

00:37:21,599 --> 00:37:24,079
cpu

00:37:22,160 --> 00:37:25,359
utilization is just fairly close to full

00:37:24,079 --> 00:37:28,160
um saturation

00:37:25,359 --> 00:37:29,359
um because you know on the top end it

00:37:28,160 --> 00:37:30,560
doesn't really improve that much in

00:37:29,359 --> 00:37:31,920
terms of bandwidth

00:37:30,560 --> 00:37:34,400
um but one thing which is really

00:37:31,920 --> 00:37:35,359
interesting is that the green graph goes

00:37:34,400 --> 00:37:38,160
up too

00:37:35,359 --> 00:37:38,880
um this is interesting just because um

00:37:38,160 --> 00:37:42,160
the

00:37:38,880 --> 00:37:45,440
the the rdhd the the main workload

00:37:42,160 --> 00:37:48,880
is doing exactly the same amount of work

00:37:45,440 --> 00:37:50,880
as before right i mean the

00:37:48,880 --> 00:37:52,880
the compile job starting didn't affect

00:37:50,880 --> 00:37:56,320
how many how many rps

00:37:52,880 --> 00:37:57,920
the uh the rdhd is serving so it's easy

00:37:56,320 --> 00:38:00,160
doing exactly the same amount of work

00:37:57,920 --> 00:38:01,040
the whole time but when the compile job

00:38:00,160 --> 00:38:04,000
starts

00:38:01,040 --> 00:38:05,119
uh the main workload cpu utilization

00:38:04,000 --> 00:38:06,560
goes up a little bit too

00:38:05,119 --> 00:38:08,400
so that's showing that you know cpu

00:38:06,560 --> 00:38:10,560
actually became slower so it's

00:38:08,400 --> 00:38:11,760
taking more time doing the same amount

00:38:10,560 --> 00:38:14,400
of work

00:38:11,760 --> 00:38:15,920
um so yeah that's you know that's part

00:38:14,400 --> 00:38:19,839
of the reason why you also see

00:38:15,920 --> 00:38:19,839
a slight increase in in latency

00:38:19,920 --> 00:38:23,040
all right so resource control demo is

00:38:21,520 --> 00:38:26,079
under active development

00:38:23,040 --> 00:38:27,280
and um the two things uh which are kind

00:38:26,079 --> 00:38:30,320
of not worth it is that

00:38:27,280 --> 00:38:31,280
one thing is that um currently like in

00:38:30,320 --> 00:38:34,640
the public version

00:38:31,280 --> 00:38:37,119
uh right now released version um

00:38:34,640 --> 00:38:40,000
has its own its parameters tuned in a

00:38:37,119 --> 00:38:43,200
way to maximize the differences in

00:38:40,000 --> 00:38:45,520
in resource uh consumption but uh

00:38:43,200 --> 00:38:46,720
the the newer version will have its

00:38:45,520 --> 00:38:49,599
behaviors

00:38:46,720 --> 00:38:50,400
uh kind of synced or or brought closer

00:38:49,599 --> 00:38:52,480
to

00:38:50,400 --> 00:38:54,000
one of our production workflows which is

00:38:52,480 --> 00:38:56,560
really popular or

00:38:54,000 --> 00:38:57,440
really widespread and used as benchmark

00:38:56,560 --> 00:39:00,640
so that it has

00:38:57,440 --> 00:39:01,839
it would have like a lot of resemblance

00:39:00,640 --> 00:39:03,520
to

00:39:01,839 --> 00:39:05,200
to actual production workload in terms

00:39:03,520 --> 00:39:07,280
of resource behavior

00:39:05,200 --> 00:39:09,200
or like how it responds to you know lego

00:39:07,280 --> 00:39:10,640
of certain resources

00:39:09,200 --> 00:39:13,760
and another thing is that uh something

00:39:10,640 --> 00:39:14,800
called resource control bench

00:39:13,760 --> 00:39:16,720
this controller demo is you know

00:39:14,800 --> 00:39:17,760
interactive demo explaining everything

00:39:16,720 --> 00:39:20,000
and you can play with it

00:39:17,760 --> 00:39:22,000
to you know to see how things behave

00:39:20,000 --> 00:39:25,839
users control bench is like uh this

00:39:22,000 --> 00:39:28,640
can't uh benchmarks um to to determine

00:39:25,839 --> 00:39:31,440
like io cost io controller parameters

00:39:28,640 --> 00:39:32,079
or evaluate how well things are isolated

00:39:31,440 --> 00:39:35,359
or

00:39:32,079 --> 00:39:36,400
how well you know work the total work is

00:39:35,359 --> 00:39:38,480
being conserved

00:39:36,400 --> 00:39:39,520
so it can be used for evaluating and

00:39:38,480 --> 00:39:41,200
verifying different

00:39:39,520 --> 00:39:43,200
um resource control setups and common

00:39:41,200 --> 00:39:45,599
features and kind of development

00:39:43,200 --> 00:39:46,480
um so that's what's happening and if you

00:39:45,599 --> 00:39:49,599
want to try it out

00:39:46,480 --> 00:39:52,880
um it's a little bit involved to try

00:39:49,599 --> 00:39:54,320
um right now the easiest way is either

00:39:52,880 --> 00:39:57,760
trying it on aws

00:39:54,320 --> 00:40:00,320
or installing uh on a you know dedicated

00:39:57,760 --> 00:40:01,680
ssd um just because you know it needs

00:40:00,320 --> 00:40:04,000
you know bottle fs and

00:40:01,680 --> 00:40:04,800
all those things um so if you visit this

00:40:04,000 --> 00:40:06,400
website

00:40:04,800 --> 00:40:08,319
um you know there's an instruction on

00:40:06,400 --> 00:40:10,000
how to start it and how to install it

00:40:08,319 --> 00:40:12,079
how to get started with it

00:40:10,000 --> 00:40:13,599
um and then we are working to make it

00:40:12,079 --> 00:40:15,440
you know more more accessible

00:40:13,599 --> 00:40:17,040
and it will become more accessible as a

00:40:15,440 --> 00:40:19,839
lot of these features

00:40:17,040 --> 00:40:20,960
are already or in upstream but it's also

00:40:19,839 --> 00:40:23,599
getting adapted

00:40:20,960 --> 00:40:24,319
um through the you know upstream uh

00:40:23,599 --> 00:40:26,319
systemd

00:40:24,319 --> 00:40:27,599
and then and fedora and different

00:40:26,319 --> 00:40:30,079
distros

00:40:27,599 --> 00:40:30,880
so um that's my presentation thank you

00:40:30,079 --> 00:40:33,920
very much and

00:40:30,880 --> 00:40:37,440
and we have about three minutes left so

00:40:33,920 --> 00:40:39,680
if we can have um q a if anybody has

00:40:37,440 --> 00:40:40,800
questions

00:40:39,680 --> 00:40:42,560
yes we've got a few minutes for

00:40:40,800 --> 00:40:44,960
questions if you've got a question

00:40:42,560 --> 00:40:49,440
please post it in the tux theater chat

00:40:44,960 --> 00:40:53,839
prefixed with question and we will

00:40:49,440 --> 00:40:53,839
answer them as we see them

00:41:04,079 --> 00:41:07,280
and i see a link to the facebook micro

00:41:06,800 --> 00:41:09,920
site

00:41:07,280 --> 00:41:11,920
um the url on the last slide has now

00:41:09,920 --> 00:41:21,839
been posted in the chat for

00:41:11,920 --> 00:41:21,839
anyone who wishes to look at that

00:41:38,160 --> 00:41:43,200
so locations right thank you very much

00:41:43,359 --> 00:41:49,839

YouTube URL: https://www.youtube.com/watch?v=2tSFDVDpxyc


