Title: "KUnit: Past, Present, and Future" - David Gow (LCA 2021 Online)
Publication date: 2021-02-18
Playlist: Kernel Miniconf (LCA 2021)
Description: 
	David Gow

https://lca2021.linux.org.au/schedule/presentation/98/

KUnit[1,2] is an in-kernel unit testing framework merged into Linux 5.5. This talk will provide a basic overview of what KUnit is and where it fits into the Linux testing ecosystem, as well as how to run and write basic unit tests.

We’ll take a look at what’s changed in the last year, since KUnit was merged, and what challenges have been overcome. We’ll touch on how KUnit better supports testing under different architectures and environments, has improved documentation and is standardising test names, hierarchies and output formats. We'll also look at some of the tests being written with KUnit today. 

Finally, we’ll look at where KUnit goes from here: including basic mocking features to make testing hardware drivers easier, better integration and compatibility with other testing systems, and new features like skippable tests. Lastly, we’ll look at the overall strategy for making testing easier,  what we think is necessary to integrate KUnit into the kernel development process, and what you can do to help.

[1]: https://kunit.dev/
[2]: https://www.kernel.org/doc/html/latest/dev-tools/kunit/index.html

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sat Jan 23 13:30:00 2021 at Tux Theatre
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,200 --> 00:00:17,680
welcome back i hope everyone had a great

00:00:17,199 --> 00:00:21,279
lunch

00:00:17,680 --> 00:00:23,760
um uh we now have david gao

00:00:21,279 --> 00:00:24,560
um who is a software engineer at google

00:00:23,760 --> 00:00:26,640
who works on

00:00:24,560 --> 00:00:28,400
kunit a unit testing framework for the

00:00:26,640 --> 00:00:29,039
linux kernel he'll be speaking to us

00:00:28,400 --> 00:00:30,960
today on

00:00:29,039 --> 00:00:33,599
unit past present and future please

00:00:30,960 --> 00:00:33,599
welcome david

00:00:37,040 --> 00:00:43,120
ah thank you um so

00:00:40,079 --> 00:00:45,920
i hope everyone has had a good lunch or

00:00:43,120 --> 00:00:46,800
appropriate uh lunch substitute for your

00:00:45,920 --> 00:00:48,719
time zone

00:00:46,800 --> 00:00:50,000
and uh has been enjoying the conference

00:00:48,719 --> 00:00:53,520
so far

00:00:50,000 --> 00:00:55,360
um as uh andrew mentioned and as you can

00:00:53,520 --> 00:00:56,239
probably guess from the slides uh my

00:00:55,360 --> 00:00:58,800
name is david

00:00:56,239 --> 00:00:59,520
i work for google and i work on k unit

00:00:58,800 --> 00:01:01,440
which

00:00:59,520 --> 00:01:02,640
is fortunately what this talk's going to

00:01:01,440 --> 00:01:05,519
be about

00:01:02,640 --> 00:01:06,159
um so we're going to talk about three

00:01:05,519 --> 00:01:08,560
things

00:01:06,159 --> 00:01:10,720
uh k units past k units present and k

00:01:08,560 --> 00:01:13,520
units future but not in that order

00:01:10,720 --> 00:01:14,080
um basically we're going to start off by

00:01:13,520 --> 00:01:17,119
uh

00:01:14,080 --> 00:01:19,920
talking about what k unit is uh you know

00:01:17,119 --> 00:01:21,439
what it currently is in the present uh

00:01:19,920 --> 00:01:23,600
for those of you who were at a

00:01:21,439 --> 00:01:25,360
lca last year you might remember brandon

00:01:23,600 --> 00:01:27,759
higgins giving a talk about k

00:01:25,360 --> 00:01:29,200
unit then so the past will be what's

00:01:27,759 --> 00:01:31,200
happened since then

00:01:29,200 --> 00:01:32,240
and for the future we're going to see

00:01:31,200 --> 00:01:34,159
what we can uh

00:01:32,240 --> 00:01:35,520
come up with what you can look forward

00:01:34,159 --> 00:01:38,799
to uh

00:01:35,520 --> 00:01:42,399
for the future of uh unit testing

00:01:38,799 --> 00:01:45,680
and other testing in the linux kernel um

00:01:42,399 --> 00:01:48,880
so let's get started what is k unit

00:01:45,680 --> 00:01:51,200
um so k unit officially is a unit

00:01:48,880 --> 00:01:54,799
testing framework for the linux kernel

00:01:51,200 --> 00:01:56,560
um well we're a little bit uh hazy about

00:01:54,799 --> 00:01:57,600
what the exact definition of unit

00:01:56,560 --> 00:02:00,399
testing should be

00:01:57,600 --> 00:02:02,479
uh no one particularly loves uh arguing

00:02:00,399 --> 00:02:04,799
over definitions i'm sure

00:02:02,479 --> 00:02:06,799
uh but basically it's a framework for

00:02:04,799 --> 00:02:09,360
small self-contained tests

00:02:06,799 --> 00:02:10,959
within the linux kernel and by within

00:02:09,360 --> 00:02:12,160
the column i mean k unit tests are

00:02:10,959 --> 00:02:15,680
actually

00:02:12,160 --> 00:02:16,720
written as kernel code in c linked into

00:02:15,680 --> 00:02:20,319
a kernel uh

00:02:16,720 --> 00:02:23,360
and run unit testing generally we mean

00:02:20,319 --> 00:02:25,120
small fast and self-contained tests

00:02:23,360 --> 00:02:26,800
think of you know testing a single

00:02:25,120 --> 00:02:28,640
kernel function or even a single code

00:02:26,800 --> 00:02:30,640
path through a kernel function

00:02:28,640 --> 00:02:32,000
rather than some enormous integration

00:02:30,640 --> 00:02:34,080
test that you know

00:02:32,000 --> 00:02:36,640
generates hundreds of files and checks

00:02:34,080 --> 00:02:39,599
file system performance or

00:02:36,640 --> 00:02:41,040
checks an entire system the whole way

00:02:39,599 --> 00:02:43,360
through

00:02:41,040 --> 00:02:45,040
so generally k unit lots of small

00:02:43,360 --> 00:02:47,280
independent tests

00:02:45,040 --> 00:02:48,400
uh and the other thing k-unit does is

00:02:47,280 --> 00:02:52,239
it's an effort to

00:02:48,400 --> 00:02:54,160
basically standardize these tests so

00:02:52,239 --> 00:02:55,680
what we have with things like k self

00:02:54,160 --> 00:02:58,720
test and that is

00:02:55,680 --> 00:03:00,959
lots of largely uh you know standardized

00:02:58,720 --> 00:03:04,159
scripts for running tests and a

00:03:00,959 --> 00:03:05,280
common output format but k unit provides

00:03:04,159 --> 00:03:08,080
helper functions

00:03:05,280 --> 00:03:08,720
and tools that make k unit tests

00:03:08,080 --> 00:03:12,080
essentially

00:03:08,720 --> 00:03:12,800
automatically run in a way that is

00:03:12,080 --> 00:03:15,440
consistent

00:03:12,800 --> 00:03:18,560
and always produce format that is

00:03:15,440 --> 00:03:21,680
passable by the same tools

00:03:18,560 --> 00:03:22,239
the k unit framework uh and that's the

00:03:21,680 --> 00:03:24,159
other

00:03:22,239 --> 00:03:25,760
interesting word in a unit testing

00:03:24,159 --> 00:03:29,519
framework basically means

00:03:25,760 --> 00:03:32,799
we have a set of helper functions that

00:03:29,519 --> 00:03:35,360
help you write tests as well as

00:03:32,799 --> 00:03:37,599
automatic execution of of tests on

00:03:35,360 --> 00:03:38,480
startup and k unit tests can now be

00:03:37,599 --> 00:03:40,080
built either

00:03:38,480 --> 00:03:41,680
into the kernel in which case all the

00:03:40,080 --> 00:03:44,560
tests run at startup

00:03:41,680 --> 00:03:46,720
or can be built as modules which you can

00:03:44,560 --> 00:03:49,200
load and run tests much as

00:03:46,720 --> 00:03:50,159
many uh existing kernel testing systems

00:03:49,200 --> 00:03:53,519
use

00:03:50,159 --> 00:03:56,319
um finally k unit tests uh can be run

00:03:53,519 --> 00:03:58,000
under basically any kernel architecture

00:03:56,319 --> 00:03:59,680
the k unit framework itself is

00:03:58,000 --> 00:04:02,159
architecture agnostic

00:03:59,680 --> 00:04:04,480
but we do provide tooling for running k

00:04:02,159 --> 00:04:07,519
unit tests under user mode linux

00:04:04,480 --> 00:04:09,599
which is a kernel architecture that

00:04:07,519 --> 00:04:12,159
basically builds the kernel as a normal

00:04:09,599 --> 00:04:14,640
x86 64 linux binary

00:04:12,159 --> 00:04:17,519
and the advantage of this is that k unit

00:04:14,640 --> 00:04:19,280
tests can be extremely fast you can run

00:04:17,519 --> 00:04:21,440
you know your entire test suite in a

00:04:19,280 --> 00:04:23,120
matter of seconds rather than minutes or

00:04:21,440 --> 00:04:26,160
hours setting up testing

00:04:23,120 --> 00:04:26,160
all hardware and the light

00:04:26,320 --> 00:04:30,720
so what actually do you need to do if

00:04:29,520 --> 00:04:34,000
you want to find k u

00:04:30,720 --> 00:04:37,440
k unit uh since uh 5.5

00:04:34,000 --> 00:04:39,600
is now upstream so you can find

00:04:37,440 --> 00:04:40,560
k unit itself and the number of k unit

00:04:39,600 --> 00:04:42,720
tests in

00:04:40,560 --> 00:04:43,840
the kernel you're probably running now

00:04:42,720 --> 00:04:46,080
um if you

00:04:43,840 --> 00:04:48,400
get the latest uh source tree from

00:04:46,080 --> 00:04:51,040
kernel.org k unit is there

00:04:48,400 --> 00:04:52,000
um you can enable k unit just by

00:04:51,040 --> 00:04:55,040
enabling a

00:04:52,000 --> 00:04:56,080
k config option called k unit uh and

00:04:55,040 --> 00:04:58,479
there's also one k

00:04:56,080 --> 00:05:00,560
unit all tests which will automatically

00:04:58,479 --> 00:05:03,120
enable a whole bunch of tests

00:05:00,560 --> 00:05:05,840
uh written with k unit for that apply to

00:05:03,120 --> 00:05:09,199
your current config

00:05:05,840 --> 00:05:12,080
so amongst uh that you can

00:05:09,199 --> 00:05:12,720
pretty easily add k units to a kernel

00:05:12,080 --> 00:05:15,440
you've got

00:05:12,720 --> 00:05:15,840
we also have a number of tools k unit

00:05:15,440 --> 00:05:18,320
tool

00:05:15,840 --> 00:05:19,919
or k unit dot pi is the main one which

00:05:18,320 --> 00:05:22,960
is as i mentioned something that

00:05:19,919 --> 00:05:26,000
builds configures runs a k

00:05:22,960 --> 00:05:28,479
unit uh user mode linux kernel

00:05:26,000 --> 00:05:29,360
um and then pauses and prettily prints

00:05:28,479 --> 00:05:32,639
all of the uh

00:05:29,360 --> 00:05:34,639
the test results um

00:05:32,639 --> 00:05:36,880
if you're looking for the k unit code

00:05:34,639 --> 00:05:40,000
you can find that generally

00:05:36,880 --> 00:05:40,960
in the lib k unit directory uh in the

00:05:40,000 --> 00:05:43,120
kernel and that's

00:05:40,960 --> 00:05:45,360
where you will find the code for the

00:05:43,120 --> 00:05:48,479
actual k unit helper functions

00:05:45,360 --> 00:05:51,520
k unit execution framework etc but

00:05:48,479 --> 00:05:52,800
tests generally sit just alongside the

00:05:51,520 --> 00:05:56,400
code being tested

00:05:52,800 --> 00:05:59,120
um so if you have you know a file

00:05:56,400 --> 00:05:59,600
list dot h list dot c containing you

00:05:59,120 --> 00:06:01,520
know

00:05:59,600 --> 00:06:02,880
list manipulation functions it'll often

00:06:01,520 --> 00:06:06,160
be in a list underscore k

00:06:02,880 --> 00:06:07,039
unit dot c uh file and if you build it

00:06:06,160 --> 00:06:10,000
as a module

00:06:07,039 --> 00:06:11,919
you'll get a uh list k unit dot ko

00:06:10,000 --> 00:06:14,960
module

00:06:11,919 --> 00:06:17,600
so basically the idea here is

00:06:14,960 --> 00:06:18,479
current kernel you can find and when

00:06:17,600 --> 00:06:21,600
you're writing

00:06:18,479 --> 00:06:22,479
tests you can just put a test alongside

00:06:21,600 --> 00:06:25,280
your code

00:06:22,479 --> 00:06:26,560
uh and k unit will quite easily be able

00:06:25,280 --> 00:06:28,319
to run it

00:06:26,560 --> 00:06:30,080
uh there's lots of documentation

00:06:28,319 --> 00:06:32,720
available for k unit which

00:06:30,080 --> 00:06:34,240
we like to think is at least not worse

00:06:32,720 --> 00:06:35,600
than the rest of the kernel

00:06:34,240 --> 00:06:38,160
documentation

00:06:35,600 --> 00:06:39,600
um it's you know in the documentation

00:06:38,160 --> 00:06:41,919
directory documentation

00:06:39,600 --> 00:06:44,800
dev tools k unit you'll find it there's

00:06:41,919 --> 00:06:46,560
also a kunit.dev website which

00:06:44,800 --> 00:06:48,000
basically is just a mirror of that with

00:06:46,560 --> 00:06:50,639
a few other things

00:06:48,000 --> 00:06:50,639
here and there

00:06:52,319 --> 00:06:56,800
so what one of the reasons you're

00:06:55,199 --> 00:06:59,440
probably here is

00:06:56,800 --> 00:07:00,880
wanting to know how do you write a a k

00:06:59,440 --> 00:07:04,080
unit test

00:07:00,880 --> 00:07:07,199
and k unit tests basically are just a

00:07:04,080 --> 00:07:07,680
single function um so function accepts

00:07:07,199 --> 00:07:10,880
this k

00:07:07,680 --> 00:07:14,639
unit uh argument as a structure

00:07:10,880 --> 00:07:15,120
um and you know function run some set up

00:07:14,639 --> 00:07:16,560
to

00:07:15,120 --> 00:07:18,639
set up whatever thing you're trying to

00:07:16,560 --> 00:07:20,720
test tests it

00:07:18,639 --> 00:07:23,360
and there are a bunch of assertion and

00:07:20,720 --> 00:07:25,599
similar macros that you can then run to

00:07:23,360 --> 00:07:28,160
verify that the resultant state matches

00:07:25,599 --> 00:07:30,400
what you expect

00:07:28,160 --> 00:07:31,280
k unit tests and then organized into

00:07:30,400 --> 00:07:34,000
test suites

00:07:31,280 --> 00:07:34,479
which are a collection of related tests

00:07:34,000 --> 00:07:37,599
uh

00:07:34,479 --> 00:07:40,960
just an array of these functions

00:07:37,599 --> 00:07:41,759
um and for example you know you might

00:07:40,960 --> 00:07:45,199
have

00:07:41,759 --> 00:07:49,039
a subsystem you know say

00:07:45,199 --> 00:07:53,039
ext4 and you might have a test suite

00:07:49,039 --> 00:07:55,840
for you know ext4

00:07:53,039 --> 00:07:56,879
within that tests for various functions

00:07:55,840 --> 00:07:59,919
within that

00:07:56,879 --> 00:08:03,360
similarly could be something smaller i

00:07:59,919 --> 00:08:07,199
in in practice ext4 has an inode suite

00:08:03,360 --> 00:08:08,879
so um the test suite is ext4i node and

00:08:07,199 --> 00:08:12,400
within that there are functions like

00:08:08,879 --> 00:08:15,680
checking timestamps

00:08:12,400 --> 00:08:19,280
uh so let's have a quick look at

00:08:15,680 --> 00:08:23,280
an actual uh test function um

00:08:19,280 --> 00:08:26,800
and basically what we have here is

00:08:23,280 --> 00:08:27,680
a single static function you know pretty

00:08:26,800 --> 00:08:31,440
boring

00:08:27,680 --> 00:08:34,240
um it accepts this k unit structure

00:08:31,440 --> 00:08:36,240
um which basically is just the context

00:08:34,240 --> 00:08:38,640
for the currently running test

00:08:36,240 --> 00:08:40,000
and in this case we're testing the list

00:08:38,640 --> 00:08:41,919
move tail

00:08:40,000 --> 00:08:45,279
function which is part of the kernel

00:08:41,919 --> 00:08:48,320
linked list data structure

00:08:45,279 --> 00:08:49,279
so you know we set up two lists we set

00:08:48,320 --> 00:08:53,200
up a couple of

00:08:49,279 --> 00:08:55,200
uh elements to add to those lists

00:08:53,200 --> 00:08:57,120
add them this is sort of a set up for

00:08:55,200 --> 00:08:59,920
this particular test

00:08:57,120 --> 00:09:02,080
we call the function list move tail

00:08:59,920 --> 00:09:04,480
which we're trying to test which should

00:09:02,080 --> 00:09:06,560
result in one empty list and one list

00:09:04,480 --> 00:09:07,279
with element b in it followed by element

00:09:06,560 --> 00:09:10,399
a in it

00:09:07,279 --> 00:09:13,440
and then just use these k unit expect uh

00:09:10,399 --> 00:09:16,959
macros to expect that uh

00:09:13,440 --> 00:09:20,560
the list is empty list one and that

00:09:16,959 --> 00:09:21,120
list two next pointers all nicely match

00:09:20,560 --> 00:09:23,680
up

00:09:21,120 --> 00:09:25,040
and that's basically what a k unit test

00:09:23,680 --> 00:09:27,839
tends to look like

00:09:25,040 --> 00:09:29,440
you have some set up some code you're

00:09:27,839 --> 00:09:32,880
testing and then a bunch of these

00:09:29,440 --> 00:09:36,320
expect macros being called which verify

00:09:32,880 --> 00:09:38,640
uh the result now

00:09:36,320 --> 00:09:41,200
in the case of list test we've got lots

00:09:38,640 --> 00:09:44,560
of tests for the lists data structure

00:09:41,200 --> 00:09:47,839
uh not just for that one function uh and

00:09:44,560 --> 00:09:50,480
the suite for that you know just a

00:09:47,839 --> 00:09:52,880
basic array of you know we have this k

00:09:50,480 --> 00:09:54,720
unit case macro that uh

00:09:52,880 --> 00:09:56,080
describes an individual test case and

00:09:54,720 --> 00:09:56,880
then you just put the function name

00:09:56,080 --> 00:09:59,600
through

00:09:56,880 --> 00:10:00,800
so it's pretty easy to group these lists

00:09:59,600 --> 00:10:04,079
of tests

00:10:00,800 --> 00:10:07,920
it's also possible you can see we create

00:10:04,079 --> 00:10:08,480
a list test module uh struct which is

00:10:07,920 --> 00:10:11,839
the uh

00:10:08,480 --> 00:10:14,000
suite uh you know give it a name

00:10:11,839 --> 00:10:15,120
give it the the list of test cases you

00:10:14,000 --> 00:10:17,760
can also

00:10:15,120 --> 00:10:18,560
if your test has a lot of common setup

00:10:17,760 --> 00:10:20,880
or

00:10:18,560 --> 00:10:22,320
tear down code pass function setup

00:10:20,880 --> 00:10:23,839
function and the teardown function which

00:10:22,320 --> 00:10:26,320
will be common between all of these

00:10:23,839 --> 00:10:26,320
tests

00:10:27,040 --> 00:10:32,320
so that's a rough idea of what a simple

00:10:30,399 --> 00:10:34,399
test looks like

00:10:32,320 --> 00:10:36,480
most k unit tests will be a little bit

00:10:34,399 --> 00:10:40,079
uh more complicated than that

00:10:36,480 --> 00:10:41,519
but not many and not much so

00:10:40,079 --> 00:10:43,360
for the most part you're again looking

00:10:41,519 --> 00:10:45,600
to test one function

00:10:43,360 --> 00:10:47,279
maybe you know a couple of functions

00:10:45,600 --> 00:10:49,120
that work very closely together

00:10:47,279 --> 00:10:50,480
sometimes even just one code path

00:10:49,120 --> 00:10:52,160
through a function you know you might

00:10:50,480 --> 00:10:54,320
have a separate test for a function

00:10:52,160 --> 00:10:57,040
working successfully or a function

00:10:54,320 --> 00:10:59,200
uh working incorrectly and returning an

00:10:57,040 --> 00:11:02,000
error

00:10:59,200 --> 00:11:02,720
uh and once you've got want to run them

00:11:02,000 --> 00:11:04,800
um

00:11:02,720 --> 00:11:07,040
there are broadly speaking two ways of

00:11:04,800 --> 00:11:07,519
doing this you can either use the k unit

00:11:07,040 --> 00:11:09,680
tool

00:11:07,519 --> 00:11:11,920
with uh script which will run them under

00:11:09,680 --> 00:11:13,760
uml or you can just build a kernel and

00:11:11,920 --> 00:11:15,600
enable them

00:11:13,760 --> 00:11:18,399
when you're writing a test you know you

00:11:15,600 --> 00:11:20,880
treat it as any other module

00:11:18,399 --> 00:11:22,560
you just add it to the make file k

00:11:20,880 --> 00:11:24,880
config file give it an option

00:11:22,560 --> 00:11:26,800
in this case we've got config list k

00:11:24,880 --> 00:11:30,000
unit test

00:11:26,800 --> 00:11:31,440
and to use k unit tool you create a dot

00:11:30,000 --> 00:11:33,760
k unit config file

00:11:31,440 --> 00:11:35,920
in the build directory of your kernel k

00:11:33,760 --> 00:11:37,040
unit tool defaults to a dot k unit

00:11:35,920 --> 00:11:38,880
directory

00:11:37,040 --> 00:11:40,240
uh and then include all the config

00:11:38,880 --> 00:11:43,519
options that you require

00:11:40,240 --> 00:11:45,519
so config k unit equals y

00:11:43,519 --> 00:11:46,880
you need k unit if you want to run any k

00:11:45,519 --> 00:11:49,920
unit tests and

00:11:46,880 --> 00:11:51,519
config list k unit test equals y if the

00:11:49,920 --> 00:11:54,240
thing you're testing requires

00:11:51,519 --> 00:11:56,160
other um config options to be enabled

00:11:54,240 --> 00:11:57,839
you're testing a particular driver

00:11:56,160 --> 00:11:59,200
you will also want to add the config

00:11:57,839 --> 00:12:02,079
option for that driver in

00:11:59,200 --> 00:12:03,440
obviously the linked list example every

00:12:02,079 --> 00:12:05,600
kernel has the linked list data

00:12:03,440 --> 00:12:07,040
structure enabled

00:12:05,600 --> 00:12:08,720
and then finally once you've got that

00:12:07,040 --> 00:12:10,560
set up you can just run this tools

00:12:08,720 --> 00:12:13,760
testing k unit k unit dot pi

00:12:10,560 --> 00:12:16,720
run command and magically

00:12:13,760 --> 00:12:17,360
uh everything will be configured built

00:12:16,720 --> 00:12:20,160
uh

00:12:17,360 --> 00:12:21,040
run and then a paused summary will will

00:12:20,160 --> 00:12:23,839
appear

00:12:21,040 --> 00:12:26,320
if you prefer to get the raw test output

00:12:23,839 --> 00:12:28,959
in the machine readable ktap format you

00:12:26,320 --> 00:12:28,959
can as well

00:12:29,279 --> 00:12:36,800
so this is what the raw

00:12:33,200 --> 00:12:38,959
tap output that k unit tests give

00:12:36,800 --> 00:12:40,560
on the left we have a successful run of

00:12:38,959 --> 00:12:44,079
list test on the right we have a

00:12:40,560 --> 00:12:47,920
uh one which has failed um

00:12:44,079 --> 00:12:50,959
so basically what we have here is um

00:12:47,920 --> 00:12:53,360
for the test suite you know it starts

00:12:50,959 --> 00:12:56,079
off with this tap version 14 and then a

00:12:53,360 --> 00:12:57,200
count of the number of test suites our

00:12:56,079 --> 00:13:00,240
subtesters

00:12:57,200 --> 00:13:03,600
list uh within that we then have

00:13:00,240 --> 00:13:06,560
in this case 36 uh list tests

00:13:03,600 --> 00:13:10,560
and they're all just marked as okay and

00:13:06,560 --> 00:13:12,320
so the final suite is also okay

00:13:10,560 --> 00:13:14,079
for the case where it's failed it

00:13:12,320 --> 00:13:17,200
basically looks the same except

00:13:14,079 --> 00:13:19,680
one of these tests says not okay

00:13:17,200 --> 00:13:21,200
and in this case it then prints say a

00:13:19,680 --> 00:13:23,360
nice error message saying

00:13:21,200 --> 00:13:24,240
you know an expectation failed on this

00:13:23,360 --> 00:13:26,800
line

00:13:24,240 --> 00:13:28,720
we expected list empty careful to be

00:13:26,800 --> 00:13:31,600
true but it's false

00:13:28,720 --> 00:13:33,440
um and this way you basically get a nice

00:13:31,600 --> 00:13:36,959
assertion error message for

00:13:33,440 --> 00:13:39,760
the case um and finally if any

00:13:36,959 --> 00:13:41,519
test fails the whole suite fails and

00:13:39,760 --> 00:13:43,839
that way you can just look at the

00:13:41,519 --> 00:13:44,720
resulting sort of sweet line and say

00:13:43,839 --> 00:13:46,480
okay i know

00:13:44,720 --> 00:13:48,160
there's something wrong with linkerlist

00:13:46,480 --> 00:13:50,320
somewhere i can dig in

00:13:48,160 --> 00:13:52,480
okay it's this particular test it's

00:13:50,320 --> 00:13:56,000
probably this dell init function that's

00:13:52,480 --> 00:13:56,399
that's failing if you use k unit tool

00:13:56,000 --> 00:13:59,680
there's

00:13:56,399 --> 00:14:01,839
in a tiny font here um a slightly

00:13:59,680 --> 00:14:02,480
prettier version of that where it nicely

00:14:01,839 --> 00:14:05,360
uh

00:14:02,480 --> 00:14:08,480
colorizes you know past as green and

00:14:05,360 --> 00:14:10,320
failed as red and warning messages as uh

00:14:08,480 --> 00:14:12,079
this sort of amber orange color and

00:14:10,320 --> 00:14:14,079
gives you a nice summary down the bottom

00:14:12,079 --> 00:14:17,040
of how long things took and

00:14:14,079 --> 00:14:18,480
uh how many tests ran how many failed

00:14:17,040 --> 00:14:21,519
how many crashed

00:14:18,480 --> 00:14:24,880
um it's you know relatively boring

00:14:21,519 --> 00:14:28,320
but uh does make for a very quick

00:14:24,880 --> 00:14:31,680
uh way of getting test results

00:14:28,320 --> 00:14:34,480
and what personally and one of the main

00:14:31,680 --> 00:14:37,040
aims of k unit is because this is

00:14:34,480 --> 00:14:37,680
relatively simple and fast to run you

00:14:37,040 --> 00:14:39,519
can

00:14:37,680 --> 00:14:41,920
you know write a few lines of code to

00:14:39,519 --> 00:14:45,120
try to fix something rerun the tests

00:14:41,920 --> 00:14:46,959
takes a few seconds change another thing

00:14:45,120 --> 00:14:48,639
rerun the test see if they've passed or

00:14:46,959 --> 00:14:50,959
failed

00:14:48,639 --> 00:14:52,959
unlike testing systems where you've got

00:14:50,959 --> 00:14:55,920
to boot up a whole machine

00:14:52,959 --> 00:14:57,279
do things testing is is basically

00:14:55,920 --> 00:14:59,279
instant and so

00:14:57,279 --> 00:15:02,639
it can become a much more integrated

00:14:59,279 --> 00:15:02,639
part of your workflow

00:15:03,199 --> 00:15:07,839
uh k unit has a few other neat tricks

00:15:06,320 --> 00:15:08,240
some of which are new and therefore

00:15:07,839 --> 00:15:10,079
we'll

00:15:08,240 --> 00:15:12,720
go into a little bit more detail when we

00:15:10,079 --> 00:15:15,040
talk about what's new later on

00:15:12,720 --> 00:15:16,800
but k unit also has a bunch of helper

00:15:15,040 --> 00:15:18,720
functions for managing memory and other

00:15:16,800 --> 00:15:22,240
resources

00:15:18,720 --> 00:15:24,240
it's quite easy to write a test which

00:15:22,240 --> 00:15:27,040
needs to set up a bunch of things and

00:15:24,240 --> 00:15:29,279
then have all sorts of error paths

00:15:27,040 --> 00:15:30,240
for you know if this allocation failed

00:15:29,279 --> 00:15:32,800
if that allocation

00:15:30,240 --> 00:15:34,160
failed three other things uh k unit you

00:15:32,800 --> 00:15:36,800
can register

00:15:34,160 --> 00:15:38,560
uh individual resources and have them

00:15:36,800 --> 00:15:40,160
automatically cleaned up if the test

00:15:38,560 --> 00:15:43,759
fails

00:15:40,160 --> 00:15:46,079
or if the test succeeds there are also

00:15:43,759 --> 00:15:47,120
helper functions like k unit kzellup

00:15:46,079 --> 00:15:48,959
which will

00:15:47,120 --> 00:15:52,399
do an allocation and automatically

00:15:48,959 --> 00:15:52,399
register it to be cleaned up

00:15:52,959 --> 00:15:56,880
one of the newer features is

00:15:54,240 --> 00:16:00,000
parameterized or data-driven tests

00:15:56,880 --> 00:16:01,920
uh so it's now possible to have a

00:16:00,000 --> 00:16:03,839
test where you have the same bit of test

00:16:01,920 --> 00:16:06,720
code that runs repeatedly against

00:16:03,839 --> 00:16:07,279
different inputs this is useful if

00:16:06,720 --> 00:16:08,880
you've saved

00:16:07,279 --> 00:16:11,040
a hash function you're testing and

00:16:08,880 --> 00:16:12,720
you've got a set of sort of standard

00:16:11,040 --> 00:16:14,560
test vectors you want you can just stick

00:16:12,720 --> 00:16:17,440
those in an array and have the same

00:16:14,560 --> 00:16:17,839
test run against all of those and k unit

00:16:17,440 --> 00:16:19,920
will

00:16:17,839 --> 00:16:21,920
automatically tell you which input

00:16:19,920 --> 00:16:23,040
failed uh you can do things like

00:16:21,920 --> 00:16:24,639
describe them

00:16:23,040 --> 00:16:26,240
you know we'll get into this in a bit

00:16:24,639 --> 00:16:30,480
more detail later but uh

00:16:26,240 --> 00:16:32,720
it's a a very useful feature um

00:16:30,480 --> 00:16:34,480
there are also a number of other small

00:16:32,720 --> 00:16:37,680
things worth knowing if you're writing k

00:16:34,480 --> 00:16:39,600
unit tests these expect macros

00:16:37,680 --> 00:16:41,199
have some interesting variants there's a

00:16:39,600 --> 00:16:42,720
string equals one which will actually do

00:16:41,199 --> 00:16:44,480
the full string compare

00:16:42,720 --> 00:16:47,440
there are message ones that let you pass

00:16:44,480 --> 00:16:49,839
your own messages if they failed

00:16:47,440 --> 00:16:50,480
which is particularly useful in the case

00:16:49,839 --> 00:16:54,399
where

00:16:50,480 --> 00:16:57,759
you know you have a named description

00:16:54,399 --> 00:17:00,480
of some data that you're testing uh

00:16:57,759 --> 00:17:01,600
you know if you're doing date time zone

00:17:00,480 --> 00:17:04,160
stuff you can

00:17:01,600 --> 00:17:06,559
instead of saying failed on on this you

00:17:04,160 --> 00:17:08,400
know unix timestamp you can have next to

00:17:06,559 --> 00:17:11,760
it failed on you know

00:17:08,400 --> 00:17:15,439
leap year on you know

00:17:11,760 --> 00:17:15,439
midnight sort of things

00:17:15,760 --> 00:17:19,839
and finally k unit also does provide its

00:17:18,160 --> 00:17:22,880
own logging macros that will

00:17:19,839 --> 00:17:23,439
output any log information in a format

00:17:22,880 --> 00:17:26,799
that

00:17:23,439 --> 00:17:29,120
the the tap standard approves of uh and

00:17:26,799 --> 00:17:30,160
which will show up both in the kernel

00:17:29,120 --> 00:17:33,360
log and

00:17:30,160 --> 00:17:37,039
in a test specific login debug fs if

00:17:33,360 --> 00:17:40,320
you've enabled that feature so that's a

00:17:37,039 --> 00:17:43,600
very quick overview of k

00:17:40,320 --> 00:17:46,720
unit as a whole um please

00:17:43,600 --> 00:17:47,760
if you haven't tried k unit before or

00:17:46,720 --> 00:17:50,160
you're interested do

00:17:47,760 --> 00:17:52,160
check out the the k unit website and the

00:17:50,160 --> 00:17:55,120
documentation in the kernel

00:17:52,160 --> 00:17:55,840
there are also lots of example tests um

00:17:55,120 --> 00:17:57,760
we'll

00:17:55,840 --> 00:17:59,440
go through a few of the tests that have

00:17:57,760 --> 00:18:02,799
been written over the last year

00:17:59,440 --> 00:18:03,840
shortly um but hopefully that's given

00:18:02,799 --> 00:18:07,120
you a very quick

00:18:03,840 --> 00:18:07,919
taste of you know what unit testing in

00:18:07,120 --> 00:18:11,760
the kernel

00:18:07,919 --> 00:18:15,039
broadly looks like um

00:18:11,760 --> 00:18:16,960
and you know what uh we're now looking

00:18:15,039 --> 00:18:17,600
at is the sort of past section of the

00:18:16,960 --> 00:18:19,600
talk

00:18:17,600 --> 00:18:21,280
uh what's changed in the last year okay

00:18:19,600 --> 00:18:24,400
unit only got upstream

00:18:21,280 --> 00:18:25,919
uh in five five which was you know just

00:18:24,400 --> 00:18:29,440
over a year ago

00:18:25,919 --> 00:18:32,160
um and so what was then

00:18:29,440 --> 00:18:32,880
this very basic you know you can write a

00:18:32,160 --> 00:18:36,240
test

00:18:32,880 --> 00:18:39,120
it will run uh has now had several

00:18:36,240 --> 00:18:41,280
additional uh features added and a

00:18:39,120 --> 00:18:44,880
frankly terrifying number of uh

00:18:41,280 --> 00:18:44,880
bugs and other issues fixed

00:18:45,679 --> 00:18:50,320
i'll go over all of these one by one as

00:18:48,400 --> 00:18:51,919
a few of these are quite interesting and

00:18:50,320 --> 00:18:54,880
useful

00:18:51,919 --> 00:18:56,720
but if you've played with kunit before

00:18:54,880 --> 00:18:58,160
these are some of the things that you

00:18:56,720 --> 00:18:59,840
you might not be aware of you haven't

00:18:58,160 --> 00:19:03,200
looked at it recently

00:18:59,840 --> 00:19:06,799
um so the first here is module support

00:19:03,200 --> 00:19:08,880
um and uh thanks to alan mcguire from

00:19:06,799 --> 00:19:11,039
oracle for for writing this and a few

00:19:08,880 --> 00:19:14,000
other features um

00:19:11,039 --> 00:19:15,760
this basically k unit tests originally

00:19:14,000 --> 00:19:16,960
were always built into the kernel always

00:19:15,760 --> 00:19:20,160
run at startup

00:19:16,960 --> 00:19:22,880
um now you can build k unit tests as

00:19:20,160 --> 00:19:26,080
modules and load them at any time

00:19:22,880 --> 00:19:29,679
this really has two big advantages k

00:19:26,080 --> 00:19:31,200
unit tests um you know now behave a

00:19:29,679 --> 00:19:31,760
little bit more like tests in a number

00:19:31,200 --> 00:19:33,919
of other

00:19:31,760 --> 00:19:35,760
test systems a lot of people testing the

00:19:33,919 --> 00:19:37,840
linux kernel have done so by having

00:19:35,760 --> 00:19:40,400
loading test modules

00:19:37,840 --> 00:19:40,880
and this is basically k units equivalent

00:19:40,400 --> 00:19:44,000
of

00:19:40,880 --> 00:19:46,000
loading a test module um it works

00:19:44,000 --> 00:19:47,200
exactly the same way it spits out this k

00:19:46,000 --> 00:19:50,400
tap format which is

00:19:47,200 --> 00:19:51,600
basically what uh self tests spit out as

00:19:50,400 --> 00:19:54,400
well

00:19:51,600 --> 00:19:57,360
so it's a you know much easier way of

00:19:54,400 --> 00:20:01,200
integrating into existing systems

00:19:57,360 --> 00:20:03,919
and the other really useful thing is

00:20:01,200 --> 00:20:06,400
that there are a number of things that

00:20:03,919 --> 00:20:09,440
you might want to test which require

00:20:06,400 --> 00:20:12,400
a user mode context you know there'd be

00:20:09,440 --> 00:20:14,640
some running user space process

00:20:12,400 --> 00:20:16,720
and when a module's loaded mod probe is

00:20:14,640 --> 00:20:20,000
is that

00:20:16,720 --> 00:20:22,480
but in k unit without module support

00:20:20,000 --> 00:20:23,600
um k unit tests run early enough in the

00:20:22,480 --> 00:20:26,480
boot process there's

00:20:23,600 --> 00:20:28,640
no user land running so any test that

00:20:26,480 --> 00:20:30,960
might want to detach userland and

00:20:28,640 --> 00:20:33,280
i wouldn't recommend tests to do so if

00:20:30,960 --> 00:20:35,200
they don't need to

00:20:33,280 --> 00:20:37,360
you know now can do things like you can

00:20:35,200 --> 00:20:37,919
test things that require copy to from

00:20:37,360 --> 00:20:40,640
user

00:20:37,919 --> 00:20:41,120
uh and other uh memory management things

00:20:40,640 --> 00:20:44,080
that

00:20:41,120 --> 00:20:45,600
expect there to be some user contacts

00:20:44,080 --> 00:20:48,640
running which uh

00:20:45,600 --> 00:20:50,159
only currently works as modules and one

00:20:48,640 --> 00:20:51,039
example of that which we'll get to in a

00:20:50,159 --> 00:20:53,760
minute is uh

00:20:51,039 --> 00:20:55,039
ka san the kernel address sanitizer has

00:20:53,760 --> 00:20:58,799
some tests

00:20:55,039 --> 00:21:01,919
um which could not work because uh

00:20:58,799 --> 00:21:03,760
they do require copy to from user

00:21:01,919 --> 00:21:06,080
and hopefully module support is

00:21:03,760 --> 00:21:09,679
something that you know will allow

00:21:06,080 --> 00:21:09,679
some of those eventually to be ported

00:21:10,400 --> 00:21:14,720
another new and useful feature is named

00:21:13,440 --> 00:21:17,280
resources

00:21:14,720 --> 00:21:18,799
so as i mentioned kunit can have uh

00:21:17,280 --> 00:21:20,400
individual test resources that are

00:21:18,799 --> 00:21:23,919
automatically cleaned up

00:21:20,400 --> 00:21:27,039
um a new feature um is

00:21:23,919 --> 00:21:29,039
the ability to have named resources

00:21:27,039 --> 00:21:31,840
that are associated with the current

00:21:29,039 --> 00:21:34,640
invocation of a test

00:21:31,840 --> 00:21:36,000
and this is a good way of passing test

00:21:34,640 --> 00:21:39,520
specific information

00:21:36,000 --> 00:21:42,640
to other subsystems again our ksan

00:21:39,520 --> 00:21:44,000
tests are using this as a way of having

00:21:42,640 --> 00:21:45,919
ka san understand

00:21:44,000 --> 00:21:47,039
a that a test is running and b that it

00:21:45,919 --> 00:21:49,280
might be expecting

00:21:47,039 --> 00:21:50,159
some particular thing that's not normal

00:21:49,280 --> 00:21:52,640
um

00:21:50,159 --> 00:21:54,880
so we can have a you know ksm context

00:21:52,640 --> 00:21:57,039
added to a named ka sound resource

00:21:54,880 --> 00:21:59,039
and other parts of the kernel code that

00:21:57,039 --> 00:22:00,559
needs to behave differently when under

00:21:59,039 --> 00:22:03,919
test

00:22:00,559 --> 00:22:07,919
can pull from that

00:22:03,919 --> 00:22:10,159
it also just can be useful as a way of

00:22:07,919 --> 00:22:10,960
storing resources in your own test code

00:22:10,159 --> 00:22:13,120
if you

00:22:10,960 --> 00:22:14,559
don't want to have to pass context

00:22:13,120 --> 00:22:18,480
through your own functions

00:22:14,559 --> 00:22:21,520
um uh one of the you know the existing

00:22:18,480 --> 00:22:23,520
uh resource framework you could create

00:22:21,520 --> 00:22:24,799
resources but there was up to you to

00:22:23,520 --> 00:22:26,400
keep track of a

00:22:24,799 --> 00:22:28,480
pointer to them so that you could use

00:22:26,400 --> 00:22:32,320
them uh now any of your code you can

00:22:28,480 --> 00:22:32,320
just pull a a resource by name

00:22:33,600 --> 00:22:37,039
one other thing which we'd wanted to

00:22:35,440 --> 00:22:39,200
have in the initial version of k

00:22:37,039 --> 00:22:40,880
unit but was a little bit too

00:22:39,200 --> 00:22:42,320
complicated to get working across all

00:22:40,880 --> 00:22:45,919
the architectures initially

00:22:42,320 --> 00:22:48,000
is this uh concept of a k-unit executor

00:22:45,919 --> 00:22:50,720
uh the first version of k-unit from a

00:22:48,000 --> 00:22:53,039
year ago uh all tests were just uh

00:22:50,720 --> 00:22:54,000
run at in at time as their own inner

00:22:53,039 --> 00:22:56,640
calls there was

00:22:54,000 --> 00:22:58,559
no part of the kernel that actually knew

00:22:56,640 --> 00:23:02,640
about all of the tests that

00:22:58,559 --> 00:23:06,400
were compiled in and running and

00:23:02,640 --> 00:23:08,000
now there is this executor that

00:23:06,400 --> 00:23:09,840
loops through all of the test suites

00:23:08,000 --> 00:23:12,480
runs them all um

00:23:09,840 --> 00:23:13,120
k unit now actually knows how many tests

00:23:12,480 --> 00:23:16,080
there are

00:23:13,120 --> 00:23:18,400
it can print out the the correct count

00:23:16,080 --> 00:23:20,080
of tests which previously didn't exist

00:23:18,400 --> 00:23:21,280
so all the summary lines in the output

00:23:20,080 --> 00:23:22,960
work correctly

00:23:21,280 --> 00:23:25,039
and it just makes it a little bit more

00:23:22,960 --> 00:23:27,120
of a

00:23:25,039 --> 00:23:28,799
standards compliant and simpler

00:23:27,120 --> 00:23:32,080
architecture

00:23:28,799 --> 00:23:35,360
for future feature work

00:23:32,080 --> 00:23:37,520
um as i mentioned a couple of times ksan

00:23:35,360 --> 00:23:39,200
integration the kernel address sanitizer

00:23:37,520 --> 00:23:42,320
for those who aren't aware

00:23:39,200 --> 00:23:44,960
uh is a feature which basically acts

00:23:42,320 --> 00:23:46,960
as a sort of valgrind address sanitizer

00:23:44,960 --> 00:23:49,200
for kernel uh memory accesses it

00:23:46,960 --> 00:23:49,760
validates every single memory access by

00:23:49,200 --> 00:23:52,480
using an

00:23:49,760 --> 00:23:54,240
instrumented kernel binary um and if

00:23:52,480 --> 00:23:57,200
there's any attempt to access

00:23:54,240 --> 00:23:58,080
uh invalid you know unallocated you know

00:23:57,200 --> 00:24:01,520
otherwise uh

00:23:58,080 --> 00:24:03,600
poisoned memory uh it will fail and

00:24:01,520 --> 00:24:06,240
this you know helps you find out of

00:24:03,600 --> 00:24:07,279
bounds on array accesses and all sorts

00:24:06,240 --> 00:24:09,520
of things that

00:24:07,279 --> 00:24:10,960
c code loves to do when you weren't

00:24:09,520 --> 00:24:14,799
expecting it to

00:24:10,960 --> 00:24:17,279
um and because k unit tests are

00:24:14,799 --> 00:24:18,799
going to be exercising a lot of parts of

00:24:17,279 --> 00:24:22,240
the kernel

00:24:18,799 --> 00:24:23,360
in a very predictable way being able to

00:24:22,240 --> 00:24:27,039
run

00:24:23,360 --> 00:24:30,080
k unit tests under ksn is important

00:24:27,039 --> 00:24:33,039
and now with the integration we have

00:24:30,080 --> 00:24:33,840
ksn errors will automatically cause any

00:24:33,039 --> 00:24:37,039
running test

00:24:33,840 --> 00:24:39,600
to fail um and this way you can

00:24:37,039 --> 00:24:41,360
quite easily pick oh you know this

00:24:39,600 --> 00:24:41,919
particular linked list test failed it

00:24:41,360 --> 00:24:44,880
must be

00:24:41,919 --> 00:24:46,240
scribbling over memory somewhere or uh

00:24:44,880 --> 00:24:48,240
something like that

00:24:46,240 --> 00:24:50,080
um you do have to be a little bit

00:24:48,240 --> 00:24:50,880
careful around there's a case and

00:24:50,080 --> 00:24:54,080
multi-shot

00:24:50,880 --> 00:24:56,640
um command line argument you need to set

00:24:54,080 --> 00:24:57,520
to stop ksn from just panicking the

00:24:56,640 --> 00:24:58,960
kernel

00:24:57,520 --> 00:25:00,559
as soon as there's any memory error

00:24:58,960 --> 00:25:01,919
which is definitely what you want in

00:25:00,559 --> 00:25:05,039
most cases

00:25:01,919 --> 00:25:08,159
but if you're you know wants to

00:25:05,039 --> 00:25:12,080
you can actually get several failures

00:25:08,159 --> 00:25:12,080
all printed out in a nice tap format

00:25:12,400 --> 00:25:18,880
finally k a lot of ka sam's own tests

00:25:15,760 --> 00:25:22,240
have been ported to k unit uh which is

00:25:18,880 --> 00:25:23,120
a you know good test of some of k units

00:25:22,240 --> 00:25:26,159
features

00:25:23,120 --> 00:25:28,159
um as well as being a bit more

00:25:26,159 --> 00:25:29,600
standardized than k uni other than okay

00:25:28,159 --> 00:25:32,880
sam's previous uh

00:25:29,600 --> 00:25:34,559
testing regime which involved just

00:25:32,880 --> 00:25:36,000
loading a module and

00:25:34,559 --> 00:25:38,320
manually checking to make sure the

00:25:36,000 --> 00:25:42,480
results matched what was expected

00:25:38,320 --> 00:25:44,640
um not all tests have yet been ported um

00:25:42,480 --> 00:25:46,480
again some need access to user memory

00:25:44,640 --> 00:25:47,120
stack traces under rcu and the light

00:25:46,480 --> 00:25:49,600
which

00:25:47,120 --> 00:25:52,400
uh k unit as a framework doesn't yet

00:25:49,600 --> 00:25:52,400
make easy

00:25:52,640 --> 00:25:56,080
or does not you know correctly plumb

00:25:55,520 --> 00:25:59,120
through

00:25:56,080 --> 00:26:02,559
is a test running through you know rcu

00:25:59,120 --> 00:26:04,240
calls and the like um a lot of nasty

00:26:02,559 --> 00:26:07,919
asynchronous stuff there

00:26:04,240 --> 00:26:11,279
but it's a great progress uh so far and

00:26:07,919 --> 00:26:12,559
i think has made most of the ksan tests

00:26:11,279 --> 00:26:16,480
much easier to

00:26:12,559 --> 00:26:20,880
quickly check um for for results

00:26:16,480 --> 00:26:24,400
um uh the parameterized testing feature

00:26:20,880 --> 00:26:26,960
that uh also was mentioned earlier

00:26:24,400 --> 00:26:28,400
is this way of running the same test

00:26:26,960 --> 00:26:31,600
code with different inputs

00:26:28,400 --> 00:26:34,480
um and this is

00:26:31,600 --> 00:26:35,600
again very very useful we've used this a

00:26:34,480 --> 00:26:39,600
few times already

00:26:35,600 --> 00:26:42,480
uh in the ext4 inode test

00:26:39,600 --> 00:26:43,200
and i know marco is looking to uh port

00:26:42,480 --> 00:26:46,400
the

00:26:43,200 --> 00:26:48,799
kcsan kernel concurrency sanitizer tests

00:26:46,400 --> 00:26:52,720
to use this as well

00:26:48,799 --> 00:26:53,279
this basically you create a generator

00:26:52,720 --> 00:26:56,640
function

00:26:53,279 --> 00:26:59,120
that generates a series of parameters

00:26:56,640 --> 00:27:01,360
um and then the test code will keep

00:26:59,120 --> 00:27:05,360
running until the generator function

00:27:01,360 --> 00:27:08,320
alerts that there are no further

00:27:05,360 --> 00:27:09,440
arguments that need to be passed this

00:27:08,320 --> 00:27:12,880
means that you can now

00:27:09,440 --> 00:27:18,240
actually run a number of tests

00:27:12,880 --> 00:27:20,000
which are not known at compile time

00:27:18,240 --> 00:27:22,399
so if you want to run an absolutely

00:27:20,000 --> 00:27:24,880
absurd number of tests you can

00:27:22,399 --> 00:27:25,600
um if you wanted to say check a maths

00:27:24,880 --> 00:27:28,880
function

00:27:25,600 --> 00:27:30,960
under every possible 32-bit float

00:27:28,880 --> 00:27:32,240
uh you could i'm not sure i'd recommend

00:27:30,960 --> 00:27:35,279
it but uh it's

00:27:32,240 --> 00:27:38,000
it's possible to now run a test you know

00:27:35,279 --> 00:27:41,279
billions of times and have that work

00:27:38,000 --> 00:27:42,320
um but the main use for this is what

00:27:41,279 --> 00:27:45,039
what we sometimes call

00:27:42,320 --> 00:27:46,320
table driven tests uh where you have an

00:27:45,039 --> 00:27:50,240
array of

00:27:46,320 --> 00:27:52,480
test vectors um you know nasty times for

00:27:50,240 --> 00:27:54,240
checking timestamp conversions of leap

00:27:52,480 --> 00:27:57,360
years and the like or

00:27:54,240 --> 00:27:58,080
um test vectors for hashing functions or

00:27:57,360 --> 00:27:59,679
a no

00:27:58,080 --> 00:28:02,240
series of known you know compressed

00:27:59,679 --> 00:28:04,640
decompressed inputs

00:28:02,240 --> 00:28:06,559
anything that involves format conversion

00:28:04,640 --> 00:28:09,520
this is very useful for or if you've got

00:28:06,559 --> 00:28:11,279
a big list of edge cases for something

00:28:09,520 --> 00:28:12,799
known inputs and outputs you can just

00:28:11,279 --> 00:28:16,240
have this as some data

00:28:12,799 --> 00:28:17,840
and k unit will run the same test code

00:28:16,240 --> 00:28:20,240
however many times you don't need to do

00:28:17,840 --> 00:28:23,520
your own loops you don't need to uh

00:28:20,240 --> 00:28:25,840
put anything special into a

00:28:23,520 --> 00:28:27,520
describe each thing k unit will run it

00:28:25,840 --> 00:28:30,080
treat it as one big test

00:28:27,520 --> 00:28:31,760
but tell you which inputs that failed on

00:28:30,080 --> 00:28:36,000
if it failed on any

00:28:31,760 --> 00:28:38,320
um and the other feature this has

00:28:36,000 --> 00:28:40,080
which you can can see a bit in the the

00:28:38,320 --> 00:28:42,399
example code here

00:28:40,080 --> 00:28:45,039
is there's the ability to pass a

00:28:42,399 --> 00:28:48,480
description function if you

00:28:45,039 --> 00:28:50,640
have a table that has a an element

00:28:48,480 --> 00:28:52,960
for a description of that particular

00:28:50,640 --> 00:28:56,080
test input

00:28:52,960 --> 00:28:59,360
and that way you get a

00:28:56,080 --> 00:29:02,880
ability to say as i mentioned um

00:28:59,360 --> 00:29:05,840
instead of failed on this unix timestamp

00:29:02,880 --> 00:29:07,120
you can say failed on midnight first of

00:29:05,840 --> 00:29:10,880
january 2000

00:29:07,120 --> 00:29:13,840
or something um and there are

00:29:10,880 --> 00:29:14,399
series of uh things like k unit array

00:29:13,840 --> 00:29:17,919
param

00:29:14,399 --> 00:29:20,240
which you just pass test name

00:29:17,919 --> 00:29:22,720
uh pointer to the array and a pointer to

00:29:20,240 --> 00:29:26,799
potentially this description function

00:29:22,720 --> 00:29:30,559
bam that's your your parameterized test

00:29:26,799 --> 00:29:33,679
uh sorted um

00:29:30,559 --> 00:29:36,559
one of the major goals for k unit um

00:29:33,679 --> 00:29:37,919
both in the last year and going forward

00:29:36,559 --> 00:29:39,919
is to

00:29:37,919 --> 00:29:41,039
integrate with continuous integration

00:29:39,919 --> 00:29:44,080
systems

00:29:41,039 --> 00:29:44,399
and the goal here is basically to make

00:29:44,080 --> 00:29:47,039
sure

00:29:44,399 --> 00:29:48,080
if you write a k unit test for anything

00:29:47,039 --> 00:29:51,120
um

00:29:48,080 --> 00:29:53,600
then we can effectively guarantee

00:29:51,120 --> 00:29:55,840
that you won't be that code won't be

00:29:53,600 --> 00:29:58,240
broken by new changes because

00:29:55,840 --> 00:29:59,919
anyone writing new changes should in

00:29:58,240 --> 00:30:01,600
theory be running these tests or have

00:29:59,919 --> 00:30:02,720
these tests automatically run on their

00:30:01,600 --> 00:30:05,760
behalf

00:30:02,720 --> 00:30:08,559
and in that case there will you know

00:30:05,760 --> 00:30:10,159
if they've broken the test uh we should

00:30:08,559 --> 00:30:12,159
know about it before that

00:30:10,159 --> 00:30:14,720
you know ends up in a stable kernel or

00:30:12,159 --> 00:30:17,279
something um

00:30:14,720 --> 00:30:18,320
so that's the goal um and there's been a

00:30:17,279 --> 00:30:21,840
number of

00:30:18,320 --> 00:30:22,240
pieces of progress towards that goal um

00:30:21,840 --> 00:30:25,360
the

00:30:22,240 --> 00:30:28,399
k unit both config

00:30:25,360 --> 00:30:31,760
system and tool have new ways of

00:30:28,399 --> 00:30:34,399
running all tests the aforementioned k

00:30:31,760 --> 00:30:35,120
unit all tests config option basically

00:30:34,399 --> 00:30:36,640
will enable

00:30:35,120 --> 00:30:38,320
all tests that have satisfied

00:30:36,640 --> 00:30:40,399
dependencies this is

00:30:38,320 --> 00:30:41,440
really useful if you know you either

00:30:40,399 --> 00:30:43,200
have a

00:30:41,440 --> 00:30:44,640
kernel for some device you've already

00:30:43,200 --> 00:30:47,200
got your config for

00:30:44,640 --> 00:30:48,000
or you know a distro kernel or something

00:30:47,200 --> 00:30:50,799
you can just

00:30:48,000 --> 00:30:52,559
enable k unit and k unit all tests and

00:30:50,799 --> 00:30:55,200
it will automatically enable

00:30:52,559 --> 00:30:56,480
basically every relevant test for for

00:30:55,200 --> 00:30:59,840
that config

00:30:56,480 --> 00:31:02,559
um if the dependencies for

00:30:59,840 --> 00:31:04,640
for the test are satisfied uh the test

00:31:02,559 --> 00:31:07,679
will be enabled um

00:31:04,640 --> 00:31:10,080
and that's very convenient for you know

00:31:07,679 --> 00:31:10,880
people who want to run all of the tests

00:31:10,080 --> 00:31:13,840
um

00:31:10,880 --> 00:31:15,039
there's also this k unit dot pi run all

00:31:13,840 --> 00:31:17,440
tests option

00:31:15,039 --> 00:31:18,159
uh as k unit pi is based around user

00:31:17,440 --> 00:31:20,480
mode linux

00:31:18,159 --> 00:31:22,640
this basically just uses make all yes

00:31:20,480 --> 00:31:26,559
config for user mode linux

00:31:22,640 --> 00:31:29,679
to run as many tests as possible um

00:31:26,559 --> 00:31:31,440
uml tends to have some breakages with

00:31:29,679 --> 00:31:32,640
obscure drivers which we've started

00:31:31,440 --> 00:31:34,480
catching

00:31:32,640 --> 00:31:36,399
with this so at the moment there's still

00:31:34,480 --> 00:31:37,679
a list of broken configs we're slowly

00:31:36,399 --> 00:31:41,200
going through trying to fix

00:31:37,679 --> 00:31:43,120
up so that um this works in in all cases

00:31:41,200 --> 00:31:45,120
with all drivers but this is

00:31:43,120 --> 00:31:47,039
effectively our way of please test

00:31:45,120 --> 00:31:47,679
everything you can enable every driver

00:31:47,039 --> 00:31:50,799
you can

00:31:47,679 --> 00:31:52,799
and run as many tests as as it's

00:31:50,799 --> 00:31:55,200
possible too

00:31:52,799 --> 00:31:55,919
unfortunately the actual idea of running

00:31:55,200 --> 00:31:58,399
every single

00:31:55,919 --> 00:31:59,760
k unit test is is not all that well

00:31:58,399 --> 00:32:02,559
defined in

00:31:59,760 --> 00:32:04,000
any individual invocation because it's

00:32:02,559 --> 00:32:06,159
possible that you know you've got two

00:32:04,000 --> 00:32:07,039
conflicting things which each have tests

00:32:06,159 --> 00:32:09,760
better

00:32:07,039 --> 00:32:11,279
this is you know a drastic improvement

00:32:09,760 --> 00:32:12,720
of just having to remember the names of

00:32:11,279 --> 00:32:15,840
all the tests and manually write them

00:32:12,720 --> 00:32:15,840
into a config file

00:32:17,039 --> 00:32:24,320
and then there are two existing

00:32:20,640 --> 00:32:27,440
continuous integration systems for

00:32:24,320 --> 00:32:30,640
the kernel which k-unit is integrating

00:32:27,440 --> 00:32:34,159
with kernel ci

00:32:30,640 --> 00:32:35,919
now we're well underway getting k unit

00:32:34,159 --> 00:32:40,320
integration into that so

00:32:35,919 --> 00:32:43,519
that will run the uh uml all tests as a

00:32:40,320 --> 00:32:46,399
new type of shell test um

00:32:43,519 --> 00:32:48,480
this is working um it's not fully

00:32:46,399 --> 00:32:51,600
upstream and enabled yet but uh

00:32:48,480 --> 00:32:55,360
this will basically mean colonel ci will

00:32:51,600 --> 00:32:58,320
soon on on various uh trees be

00:32:55,360 --> 00:32:59,600
running continually this uh set of k

00:32:58,320 --> 00:33:01,760
unit tests

00:32:59,600 --> 00:33:02,640
which include every driver we can we can

00:33:01,760 --> 00:33:06,480
find

00:33:02,640 --> 00:33:08,720
um and reporting any test failure

00:33:06,480 --> 00:33:10,399
the other thing which uh thanks a lot to

00:33:08,720 --> 00:33:12,799
the folks at lenara for doing the

00:33:10,399 --> 00:33:13,440
linux kernel uh functional testing

00:33:12,799 --> 00:33:16,640
project

00:33:13,440 --> 00:33:20,080
is now also running um

00:33:16,640 --> 00:33:24,320
k unit tests instead of under uml

00:33:20,080 --> 00:33:27,120
on almond xa 664 and reporting

00:33:24,320 --> 00:33:27,840
k unit test failures as a part of their

00:33:27,120 --> 00:33:30,880
uh

00:33:27,840 --> 00:33:33,200
um test results there uh and this is

00:33:30,880 --> 00:33:33,679
very exciting uh we've already seen you

00:33:33,200 --> 00:33:36,000
know

00:33:33,679 --> 00:33:37,039
the fact that that k unit tests amongst

00:33:36,000 --> 00:33:39,679
others are passing

00:33:37,039 --> 00:33:40,720
you know as as part of things and you

00:33:39,679 --> 00:33:43,600
know tested by

00:33:40,720 --> 00:33:45,600
tags on unstable kernels and this also

00:33:43,600 --> 00:33:46,960
is including all of the case and tests

00:33:45,600 --> 00:33:49,120
which uh

00:33:46,960 --> 00:33:50,080
due to chaos and not yet working under

00:33:49,120 --> 00:33:52,720
uml

00:33:50,080 --> 00:33:55,200
you know would not show up under k unit

00:33:52,720 --> 00:33:55,200
dot pi

00:33:55,919 --> 00:34:00,480
um there are a number of other

00:33:58,559 --> 00:34:03,200
miscellaneous tooling updates

00:34:00,480 --> 00:34:03,840
um k unit tool supports running all of

00:34:03,200 --> 00:34:07,760
these uh

00:34:03,840 --> 00:34:10,879
subtasks like building configuring

00:34:07,760 --> 00:34:12,800
compiling running kernels

00:34:10,879 --> 00:34:14,720
and then parsing the results as separate

00:34:12,800 --> 00:34:16,879
tasks previously it was just one

00:34:14,720 --> 00:34:18,960
monolithic script did them all

00:34:16,879 --> 00:34:20,879
the really convenient thing about this

00:34:18,960 --> 00:34:21,599
is now means you can use the tools

00:34:20,879 --> 00:34:24,720
parser

00:34:21,599 --> 00:34:25,919
and pretty printer of summaries uh as a

00:34:24,720 --> 00:34:28,879
way of

00:34:25,919 --> 00:34:29,280
very quickly you know getting a summary

00:34:28,879 --> 00:34:33,280
of

00:34:29,280 --> 00:34:35,119
tests run by other methods so if you're

00:34:33,280 --> 00:34:37,040
instead of using k unit tool to build a

00:34:35,119 --> 00:34:38,159
uml kernel you're using qemu you can

00:34:37,040 --> 00:34:41,599
just pipe the

00:34:38,159 --> 00:34:43,119
um kernel log to k unit dot pi parse

00:34:41,599 --> 00:34:44,720
and you'll get a nice summary of all the

00:34:43,119 --> 00:34:48,079
k unit tests there

00:34:44,720 --> 00:34:51,280
um equally you can

00:34:48,079 --> 00:34:53,280
if you're running a uh kernel

00:34:51,280 --> 00:34:54,800
with k unit on an actual physical

00:34:53,280 --> 00:34:56,960
machine um

00:34:54,800 --> 00:34:58,560
you're within that you can copy k unit

00:34:56,960 --> 00:35:01,920
tool over to that machine and

00:34:58,560 --> 00:35:02,320
you know run k unit dot pi pass against

00:35:01,920 --> 00:35:04,480
the

00:35:02,320 --> 00:35:06,640
test results in debug fs and you'll get

00:35:04,480 --> 00:35:10,000
a pretty uh summary for that test

00:35:06,640 --> 00:35:12,320
there k unit tool

00:35:10,000 --> 00:35:14,079
also now outputs json format in the

00:35:12,320 --> 00:35:17,599
kernel ci

00:35:14,079 --> 00:35:20,000
test output format um this is

00:35:17,599 --> 00:35:21,440
you know quite useful for the kernel ci

00:35:20,000 --> 00:35:22,320
integration mentioned on the previous

00:35:21,440 --> 00:35:25,440
slide

00:35:22,320 --> 00:35:27,760
um uh and another quite

00:35:25,440 --> 00:35:29,839
uh big change particularly for people

00:35:27,760 --> 00:35:30,320
who've been using k unit a little while

00:35:29,839 --> 00:35:33,359
ago

00:35:30,320 --> 00:35:35,680
and particularly k unit tool is that a

00:35:33,359 --> 00:35:37,280
number of the files that reads have been

00:35:35,680 --> 00:35:40,160
shifted around a bit so it no longer

00:35:37,280 --> 00:35:42,960
pollutes the source directory

00:35:40,160 --> 00:35:44,640
it now defaults to putting everything in

00:35:42,960 --> 00:35:47,839
a separate build directory which

00:35:44,640 --> 00:35:49,839
by default is dot k unit uh dot uh

00:35:47,839 --> 00:35:51,359
k unit config files are now called dot k

00:35:49,839 --> 00:35:54,000
unit config files and now live in the

00:35:51,359 --> 00:35:56,400
build directory instead of the uh

00:35:54,000 --> 00:35:58,079
uh the source directory and this

00:35:56,400 --> 00:35:59,760
basically means even if your

00:35:58,079 --> 00:36:01,119
source directory is you know read only

00:35:59,760 --> 00:36:02,000
somewhere else so you just don't want to

00:36:01,119 --> 00:36:05,200
pollute it

00:36:02,000 --> 00:36:07,760
you can quite easily run k unit uh tool

00:36:05,200 --> 00:36:10,320
against any source tree and you're not

00:36:07,760 --> 00:36:13,680
going to mess anything up

00:36:10,320 --> 00:36:16,079
nah okay that's now much safer to just

00:36:13,680 --> 00:36:16,720
try and run and it shouldn't cause any

00:36:16,079 --> 00:36:19,920
issues

00:36:16,720 --> 00:36:22,480
um and finally but uh

00:36:19,920 --> 00:36:23,119
i don't think least we've uh gone

00:36:22,480 --> 00:36:26,160
through and

00:36:23,119 --> 00:36:28,400
and thanks to the enormous amount of

00:36:26,160 --> 00:36:30,640
community input you usually get for for

00:36:28,400 --> 00:36:32,800
these sorts of bike shedding discussions

00:36:30,640 --> 00:36:34,000
we now have new naming guidelines for

00:36:32,800 --> 00:36:37,920
tests suites

00:36:34,000 --> 00:36:40,800
test modules um etc

00:36:37,920 --> 00:36:42,400
and this basically is a way of you know

00:36:40,800 --> 00:36:44,000
standardizing you know

00:36:42,400 --> 00:36:45,599
if you have a driver what should its

00:36:44,000 --> 00:36:49,280
test module be called

00:36:45,599 --> 00:36:51,119
um and you know uh

00:36:49,280 --> 00:36:52,480
fortunately everyone was eventually able

00:36:51,119 --> 00:36:55,599
to agree there and we've got

00:36:52,480 --> 00:36:58,400
uh what i think is quite a good

00:36:55,599 --> 00:36:58,800
way of making sure that it's easy to

00:36:58,400 --> 00:37:01,280
find

00:36:58,800 --> 00:37:01,280
tests

00:37:04,400 --> 00:37:09,200
and finally we've got a lot of new tests

00:37:07,440 --> 00:37:11,359
uh in a lot of areas there's

00:37:09,200 --> 00:37:13,040
power management quality of service

00:37:11,359 --> 00:37:14,720
tests um

00:37:13,040 --> 00:37:16,960
for parts of the power management

00:37:14,720 --> 00:37:19,119
subsystem multi-puff tcp

00:37:16,960 --> 00:37:21,040
there are tests for the crypto stuff

00:37:19,119 --> 00:37:22,240
there which will be imported to a k unit

00:37:21,040 --> 00:37:24,560
token

00:37:22,240 --> 00:37:26,720
systems kernel address sanitizer the

00:37:24,560 --> 00:37:30,720
kernel concurrency sanitizer both have k

00:37:26,720 --> 00:37:31,599
unit tests um some of the bit field

00:37:30,720 --> 00:37:34,560
manipulation

00:37:31,599 --> 00:37:36,560
helper functions have tests command line

00:37:34,560 --> 00:37:38,800
parsing for the kernel command line

00:37:36,560 --> 00:37:39,839
there are tests for that thunderbolt

00:37:38,800 --> 00:37:41,760
usb4

00:37:39,839 --> 00:37:43,200
some tests some stuff for managing io

00:37:41,760 --> 00:37:46,480
ports and resources that's

00:37:43,200 --> 00:37:48,839
just a very small very quick list but uh

00:37:46,480 --> 00:37:50,880
k unit tests certainly have picked up

00:37:48,839 --> 00:37:54,240
drastically uh in the last

00:37:50,880 --> 00:37:56,880
year and uh it's very encouraging to see

00:37:54,240 --> 00:37:58,480
people starting to play with this and

00:37:56,880 --> 00:38:00,240
write these tests or

00:37:58,480 --> 00:38:02,240
port existing tests that were doing

00:38:00,240 --> 00:38:05,359
their own ad hoc things and just

00:38:02,240 --> 00:38:09,839
printing their own um you know summaries

00:38:05,359 --> 00:38:09,839
um in whatever formatted they like

00:38:10,000 --> 00:38:13,760
uh and finally uh what's happening in

00:38:12,880 --> 00:38:17,040
the future with

00:38:13,760 --> 00:38:19,520
with k unit um and

00:38:17,040 --> 00:38:20,320
the biggest thing is mocking hardware

00:38:19,520 --> 00:38:23,520
testing

00:38:20,320 --> 00:38:26,480
this is probably the hardest problem

00:38:23,520 --> 00:38:27,359
that uh any sort of testing framework

00:38:26,480 --> 00:38:30,240
for something is

00:38:27,359 --> 00:38:31,680
as complicated as a kernel uh and as low

00:38:30,240 --> 00:38:33,760
level as a kernel has

00:38:31,680 --> 00:38:36,000
testing drivers is really hard because

00:38:33,760 --> 00:38:37,680
you need some way of getting in and

00:38:36,000 --> 00:38:39,520
intercepting reads and writes to the

00:38:37,680 --> 00:38:41,200
hardware preferably in a way that

00:38:39,520 --> 00:38:42,560
doesn't tank performance because

00:38:41,200 --> 00:38:45,280
kernel people really don't like

00:38:42,560 --> 00:38:46,560
performance being tanked

00:38:45,280 --> 00:38:48,320
there are several different ways we've

00:38:46,560 --> 00:38:51,280
been looking at to approach it

00:38:48,320 --> 00:38:53,280
you know the simplest thing for a um k

00:38:51,280 --> 00:38:54,640
unit is just to say look refactor your

00:38:53,280 --> 00:38:57,359
code to always allow

00:38:54,640 --> 00:38:57,920
some way of intercepting these things

00:38:57,359 --> 00:39:00,240
you know

00:38:57,920 --> 00:39:01,280
have it accept a function point or an

00:39:00,240 --> 00:39:03,839
obstruct

00:39:01,280 --> 00:39:05,040
uh some interface that we can inject a

00:39:03,839 --> 00:39:07,280
fake one in

00:39:05,040 --> 00:39:08,960
um this is still probably the best way

00:39:07,280 --> 00:39:12,320
of doing this if you can

00:39:08,960 --> 00:39:14,320
um but obviously it won't work in every

00:39:12,320 --> 00:39:17,359
possible situation uh

00:39:14,320 --> 00:39:19,040
similarly a way of forcibly intercepting

00:39:17,359 --> 00:39:21,599
functions is probably the most

00:39:19,040 --> 00:39:23,599
desired feature and a lot of uh people

00:39:21,599 --> 00:39:26,160
who have been playing with uh

00:39:23,599 --> 00:39:26,839
k unit uh certainly internally at google

00:39:26,160 --> 00:39:30,640
and

00:39:26,839 --> 00:39:32,640
elsewhere um have wanted a way of being

00:39:30,640 --> 00:39:35,760
able to say oh i want to you know

00:39:32,640 --> 00:39:38,800
intercept keizer or intercept you know

00:39:35,760 --> 00:39:40,480
um v map or something and fake that out

00:39:38,800 --> 00:39:42,880
when it's wrong in my test

00:39:40,480 --> 00:39:43,839
uh this is obviously dangerous you don't

00:39:42,880 --> 00:39:47,119
want to just replace

00:39:43,839 --> 00:39:50,480
important kernel functions so um

00:39:47,119 --> 00:39:51,440
finding a compromise of how much to

00:39:50,480 --> 00:39:53,920
support this

00:39:51,440 --> 00:39:54,880
and uh how much to find other ways of

00:39:53,920 --> 00:39:57,359
doing things

00:39:54,880 --> 00:39:58,079
is one of the big challenges um i would

00:39:57,359 --> 00:40:01,280
certainly

00:39:58,079 --> 00:40:03,440
appreciate people's input on that

00:40:01,280 --> 00:40:04,560
and finally a way of intercepting

00:40:03,440 --> 00:40:08,400
accesses to

00:40:04,560 --> 00:40:11,040
platform level uh uh i o memory and

00:40:08,400 --> 00:40:14,240
similar would be very good

00:40:11,040 --> 00:40:16,400
now in the past we've tried experiments

00:40:14,240 --> 00:40:18,720
of different mocking frameworks

00:40:16,400 --> 00:40:20,480
uh class mockingfor structures full of

00:40:18,720 --> 00:40:22,800
function pointers and things there's an

00:40:20,480 --> 00:40:24,720
rfc of that available uh

00:40:22,800 --> 00:40:26,720
you can find the function mocking i

00:40:24,720 --> 00:40:27,440
mentioned and the the platform mocking

00:40:26,720 --> 00:40:30,000
of inter

00:40:27,440 --> 00:40:31,599
implementing stub uh interfaces you've

00:40:30,000 --> 00:40:34,319
played around with a few of those

00:40:31,599 --> 00:40:34,880
they're you know in ancient branches on

00:40:34,319 --> 00:40:38,319
git

00:40:34,880 --> 00:40:42,000
uh repositories linked to on the um

00:40:38,319 --> 00:40:42,800
k unit web page but not really at a

00:40:42,000 --> 00:40:44,720
position

00:40:42,800 --> 00:40:46,880
that i think they're ready to be used

00:40:44,720 --> 00:40:48,880
yet um

00:40:46,880 --> 00:40:50,880
function mocking again in particular you

00:40:48,880 --> 00:40:52,720
know we've experiment with weak linking

00:40:50,880 --> 00:40:54,240
people have suggested f trace is a way

00:40:52,720 --> 00:40:55,839
of doing that but

00:40:54,240 --> 00:40:57,280
you've got to be very careful and i

00:40:55,839 --> 00:40:58,720
don't think whatever we

00:40:57,280 --> 00:41:02,000
we do there will be something we'd

00:40:58,720 --> 00:41:05,440
recommend people doing if they have it

00:41:02,000 --> 00:41:07,599
um another thing that we're looking

00:41:05,440 --> 00:41:08,880
forward to adding is the ability to skip

00:41:07,599 --> 00:41:12,319
a test at runtime

00:41:08,880 --> 00:41:14,480
um it's very uh

00:41:12,319 --> 00:41:15,920
there's some circumstances where a test

00:41:14,480 --> 00:41:17,359
really shouldn't be passing really

00:41:15,920 --> 00:41:19,760
shouldn't be failing because some

00:41:17,359 --> 00:41:22,240
fundamental uh assumption that it makes

00:41:19,760 --> 00:41:25,520
isn't true like you're trying to test

00:41:22,240 --> 00:41:27,520
um some multi-core system

00:41:25,520 --> 00:41:29,599
and you're on a system with only one

00:41:27,520 --> 00:41:30,960
processor um

00:41:29,599 --> 00:41:33,119
the correct thing to do there's not for

00:41:30,960 --> 00:41:36,160
the test to fail the test to pass

00:41:33,119 --> 00:41:38,240
but for it to be tipped skipped the ktap

00:41:36,160 --> 00:41:40,800
output specification we're following

00:41:38,240 --> 00:41:42,000
has support for skipped stuff uh we've

00:41:40,800 --> 00:41:44,400
got a prototype for this

00:41:42,000 --> 00:41:46,319
it's something we should be adding soon

00:41:44,400 --> 00:41:47,599
and we have a large number of bug fixes

00:41:46,319 --> 00:41:48,240
and tooling improvements that we're

00:41:47,599 --> 00:41:51,599
looking at

00:41:48,240 --> 00:41:52,480
um where the ktap format's not fully

00:41:51,599 --> 00:41:55,520
standardized yet

00:41:52,480 --> 00:41:58,160
timber's been looking at that a lot from

00:41:55,520 --> 00:42:00,160
the point of view of k self-test we want

00:41:58,160 --> 00:42:01,760
k unit and k self-test to output

00:42:00,160 --> 00:42:04,079
formats that are mutually sort of

00:42:01,760 --> 00:42:06,160
parsable and compatible

00:42:04,079 --> 00:42:08,000
and part of that will involve reworking

00:42:06,160 --> 00:42:09,040
the k unit tool positive at a support

00:42:08,000 --> 00:42:12,480
non-k-unit tap

00:42:09,040 --> 00:42:15,040
output we want

00:42:12,480 --> 00:42:16,880
improved tooling for being able to test

00:42:15,040 --> 00:42:18,319
individual subsystems one thing we'd

00:42:16,880 --> 00:42:20,560
really like to have

00:42:18,319 --> 00:42:21,440
is for a way for some system maintainers

00:42:20,560 --> 00:42:24,480
to be able to say

00:42:21,440 --> 00:42:26,480
hey uh if you're sending patches please

00:42:24,480 --> 00:42:28,640
run these tests and have tooling

00:42:26,480 --> 00:42:29,520
that makes it easy to just say oh you

00:42:28,640 --> 00:42:33,280
can run

00:42:29,520 --> 00:42:36,480
you know k unit dot pi run uh fs slash

00:42:33,280 --> 00:42:39,680
ext4 k unit config and it'll run

00:42:36,480 --> 00:42:42,240
this predefined list there um and

00:42:39,680 --> 00:42:42,800
more generally even outside k unit a way

00:42:42,240 --> 00:42:45,119
of

00:42:42,800 --> 00:42:46,960
specifying the testing maintainers

00:42:45,119 --> 00:42:48,640
expect maybe an extra list of

00:42:46,960 --> 00:42:50,640
instructions and maintainers or a test

00:42:48,640 --> 00:42:52,640
script or something and be

00:42:50,640 --> 00:42:55,119
something that a proposal would like to

00:42:52,640 --> 00:42:57,839
put together and bring to the community

00:42:55,119 --> 00:42:58,560
um and finally we'd just like to improve

00:42:57,839 --> 00:43:01,839
uh

00:42:58,560 --> 00:43:05,839
script uh the tooling for running

00:43:01,839 --> 00:43:07,280
non-uml based uh k unit tests

00:43:05,839 --> 00:43:09,839
uh and with that because we're uh

00:43:07,280 --> 00:43:12,720
dangerously low on time um

00:43:09,839 --> 00:43:14,480
any questions or comments i'd be uh

00:43:12,720 --> 00:43:16,400
happy to answer any of those

00:43:14,480 --> 00:43:18,319
uh thank you david we've got time for

00:43:16,400 --> 00:43:21,440
just a small number of questions

00:43:18,319 --> 00:43:21,839
um first one how flaky have k unit tests

00:43:21,440 --> 00:43:24,880
been

00:43:21,839 --> 00:43:27,200
in practice so

00:43:24,880 --> 00:43:28,720
k unit tests have actually not been

00:43:27,200 --> 00:43:32,160
flaky at all

00:43:28,720 --> 00:43:35,680
certainly upstream um we've seen

00:43:32,160 --> 00:43:37,599
very very few failures and all of them i

00:43:35,680 --> 00:43:39,760
think we've been able to link back to an

00:43:37,599 --> 00:43:42,480
actual issue

00:43:39,760 --> 00:43:43,359
um there have been i know a few people

00:43:42,480 --> 00:43:47,040
have been using k

00:43:43,359 --> 00:43:49,680
unit internally have broken things

00:43:47,040 --> 00:43:50,640
like particularly under uml which is not

00:43:49,680 --> 00:43:53,680
used a lot

00:43:50,640 --> 00:43:56,400
by anything other than k unit so people

00:43:53,680 --> 00:43:58,560
doing their own patches there have uh

00:43:56,400 --> 00:44:00,240
have hit issues with the k unit system

00:43:58,560 --> 00:44:02,880
as a whole but individual tests haven't

00:44:00,240 --> 00:44:02,880
been flaky

00:44:02,960 --> 00:44:06,720
um what's your favorite bug that you

00:44:06,839 --> 00:44:11,119
found

00:44:08,000 --> 00:44:15,040
um i know there was

00:44:11,119 --> 00:44:15,520
a ah train around it was something to do

00:44:15,040 --> 00:44:20,720
with

00:44:15,520 --> 00:44:20,720
the was it scheduling oh

00:44:20,960 --> 00:44:24,640
i'll have to get back to you on the

00:44:22,160 --> 00:44:28,560
detail it was a really nasty uh

00:44:24,640 --> 00:44:32,079
uh bug involving memory not being

00:44:28,560 --> 00:44:32,079
freed at the right point i think

00:44:32,800 --> 00:44:36,960
all right um well this brings us to the

00:44:35,200 --> 00:44:38,079
end of the time slot um so if you've got

00:44:36,960 --> 00:44:39,839
further questions

00:44:38,079 --> 00:44:42,960
go on over to the colonel minicon for

00:44:39,839 --> 00:44:45,839
boss channel and post them there

00:44:42,960 --> 00:44:47,839
and otherwise we will see you in 10

00:44:45,839 --> 00:44:56,400
minutes for the next talk

00:44:47,839 --> 00:44:56,400

YouTube URL: https://www.youtube.com/watch?v=Dzi2IrJ2z-I


