Title: "Microwatt grows up" - Paul Mackerras (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Paul Mackerras

https://lca2021.linux.org.au/schedule/presentation/61/

Microwatt is an open-source POWER CPU implementation which can run on cheap FPGAs, bringing new level of accessibility to POWER.  In the last year, we have added to Microwatt features such as a memory management unit, privilege modes, interrupts, a floating-point unit, an interrupt controller and a level-2 cache, so that now it can boot Linux.  This presentation will outline these new additions to Microwatt and talk about some interesting applications for Microwatt.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Mon Jan 25 14:25:00 2021 at Tux Theatre
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,839 --> 00:00:19,680
hello again

00:00:16,800 --> 00:00:20,000
welcome back to tux theater next up we

00:00:19,680 --> 00:00:23,039
have

00:00:20,000 --> 00:00:26,640
paul mcharris to talk to us about

00:00:23,039 --> 00:00:28,640
microwatt paul mcharris is a senior

00:00:26,640 --> 00:00:30,960
technical leader in the ibm linux

00:00:28,640 --> 00:00:32,800
technology center currently his main

00:00:30,960 --> 00:00:35,920
responsibility is as architect and

00:00:32,800 --> 00:00:38,399
maintainer for kvm on ibm power systems

00:00:35,920 --> 00:00:39,600
and on power power architecture machines

00:00:38,399 --> 00:00:41,360
more generally

00:00:39,600 --> 00:00:43,600
he is one of the main contributors to

00:00:41,360 --> 00:00:44,640
the microwatt open source power isa

00:00:43,600 --> 00:00:46,960
softcore

00:00:44,640 --> 00:00:49,120
he also contributes to the definition of

00:00:46,960 --> 00:00:52,399
the power instruction set architecture

00:00:49,120 --> 00:00:54,160
isa so paul um is hoping to have time to

00:00:52,399 --> 00:00:56,320
take questions at the end

00:00:54,160 --> 00:00:58,160
so uh hopefully by now you're familiar

00:00:56,320 --> 00:01:00,719
with the questions tab

00:00:58,160 --> 00:01:02,559
there next to the chat underneath where

00:01:00,719 --> 00:01:03,280
the video appears in the stream so

00:01:02,559 --> 00:01:05,040
please

00:01:03,280 --> 00:01:07,040
put your questions there and we'll pass

00:01:05,040 --> 00:01:10,240
them on to paul at the end of this time

00:01:07,040 --> 00:01:13,360
welcome paul thank you betsy

00:01:10,240 --> 00:01:15,920
and good afternoon everybody i'd like to

00:01:13,360 --> 00:01:17,920
tell you this afternoon about microwatt

00:01:15,920 --> 00:01:19,040
and what we've done in the last year or

00:01:17,920 --> 00:01:21,759
so

00:01:19,040 --> 00:01:23,680
microwave grows up so it's become much

00:01:21,759 --> 00:01:25,040
more mature and capable

00:01:23,680 --> 00:01:28,479
and i'd like to tell you what that

00:01:25,040 --> 00:01:31,759
involved and what it can do now

00:01:28,479 --> 00:01:33,520
so microwatt is an open source cpu core

00:01:31,759 --> 00:01:35,040
which implements the power instruction

00:01:33,520 --> 00:01:38,720
set architecture

00:01:35,040 --> 00:01:41,200
microroute is written in vhdl 2008

00:01:38,720 --> 00:01:44,240
and it was initially written by or

00:01:41,200 --> 00:01:46,159
started by anton blanchard

00:01:44,240 --> 00:01:47,840
when the announcement for the power

00:01:46,159 --> 00:01:48,799
instruction said architecture being

00:01:47,840 --> 00:01:51,920
opened

00:01:48,799 --> 00:01:53,680
uh was being you know planned

00:01:51,920 --> 00:01:54,960
and that announcement happened in august

00:01:53,680 --> 00:01:57,759
00:01:54,960 --> 00:01:58,320
and anton wanted there to be at least

00:01:57,759 --> 00:02:02,240
some

00:01:58,320 --> 00:02:04,880
even if it was a tiny uh example of

00:02:02,240 --> 00:02:05,600
an implementation of the power isa that

00:02:04,880 --> 00:02:07,759
was

00:02:05,600 --> 00:02:09,520
open source and you know people could

00:02:07,759 --> 00:02:11,360
look at it and play with it and

00:02:09,520 --> 00:02:12,879
work with it and develop it and all that

00:02:11,360 --> 00:02:15,680
kind of thing

00:02:12,879 --> 00:02:16,879
so anton being basically a software

00:02:15,680 --> 00:02:20,800
engineer

00:02:16,879 --> 00:02:23,920
had to learn vhdl for a start and

00:02:20,800 --> 00:02:26,560
so he did and he he wrote um

00:02:23,920 --> 00:02:28,959
a core that basically implemented the

00:02:26,560 --> 00:02:30,800
integer part of the instruction set and

00:02:28,959 --> 00:02:32,080
pretty much just the the user

00:02:30,800 --> 00:02:33,920
instructions

00:02:32,080 --> 00:02:35,760
but being a software engineer he wanted

00:02:33,920 --> 00:02:37,120
to use the

00:02:35,760 --> 00:02:38,959
software engineering techniques that

00:02:37,120 --> 00:02:40,160
we've become used to with things like

00:02:38,959 --> 00:02:43,599
the linux kernel and other

00:02:40,160 --> 00:02:44,160
open source projects where we have good

00:02:43,599 --> 00:02:48,319
tracking

00:02:44,160 --> 00:02:50,480
of the source code using git

00:02:48,319 --> 00:02:51,760
we've got a disciplined process for

00:02:50,480 --> 00:02:54,000
updating that

00:02:51,760 --> 00:02:55,920
and in particular that we've got quite a

00:02:54,000 --> 00:02:57,120
bit of automated testing so that we can

00:02:55,920 --> 00:03:00,159
catch bugs

00:02:57,120 --> 00:03:01,040
early on so we're not going to write

00:03:00,159 --> 00:03:04,159
code for

00:03:01,040 --> 00:03:06,959
you know three months and then say

00:03:04,159 --> 00:03:08,640
okay here's this big lump of stuff and

00:03:06,959 --> 00:03:10,080
and merge it and then find that it's got

00:03:08,640 --> 00:03:12,800
all sorts of bugs we're

00:03:10,080 --> 00:03:13,440
doing a more incremental development and

00:03:12,800 --> 00:03:16,159
testing

00:03:13,440 --> 00:03:17,280
you know with unit tests and with larger

00:03:16,159 --> 00:03:19,440
tests

00:03:17,280 --> 00:03:21,519
functional tests to make sure that we're

00:03:19,440 --> 00:03:24,560
not regressing the code

00:03:21,519 --> 00:03:26,799
so it's hosted on github.com and we now

00:03:24,560 --> 00:03:28,879
have github actions that run

00:03:26,799 --> 00:03:31,760
a bunch of simulations and also do a

00:03:28,879 --> 00:03:36,239
synthesis for an ecp 5

00:03:31,760 --> 00:03:40,000
fpga now microwatt is targeted mostly

00:03:36,239 --> 00:03:43,760
for both simulation and for fpgas

00:03:40,000 --> 00:03:45,200
so synthesis for fpgas and the fpgas

00:03:43,760 --> 00:03:47,280
that we're targeting

00:03:45,200 --> 00:03:48,480
what i would call kind of a mid-sized

00:03:47,280 --> 00:03:50,720
fpga

00:03:48,480 --> 00:03:51,920
not the really tiny ones not the really

00:03:50,720 --> 00:03:55,040
big enormous ones

00:03:51,920 --> 00:03:57,120
but the middle of the range so things

00:03:55,040 --> 00:04:00,000
like the xilinx arctic 7

00:03:57,120 --> 00:04:01,360
and the latter ccp5 and this is the

00:04:00,000 --> 00:04:05,040
range where you can get

00:04:01,360 --> 00:04:08,080
hardware that has these fpgas that is

00:04:05,040 --> 00:04:11,200
you know ranging from i guess

00:04:08,080 --> 00:04:13,120
20 30 50 up to a few hundred dollars so

00:04:11,200 --> 00:04:17,440
the board that i mostly use is

00:04:13,120 --> 00:04:19,359
this one here it's called an rda7

00:04:17,440 --> 00:04:20,720
this that comes in two variants one

00:04:19,359 --> 00:04:24,160
which has a

00:04:20,720 --> 00:04:26,000
35t fpga and the other one has a 100t

00:04:24,160 --> 00:04:27,440
and this one's got the 100t

00:04:26,000 --> 00:04:30,400
and that's actually been really good

00:04:27,440 --> 00:04:32,720
because uh microwatt on the 35t

00:04:30,400 --> 00:04:34,400
is pretty much starting to fill it up

00:04:32,720 --> 00:04:36,960
now uh but on 100t

00:04:34,400 --> 00:04:38,639
it's like three times as big so i've got

00:04:36,960 --> 00:04:40,560
plenty of room to play and do things

00:04:38,639 --> 00:04:42,160
like the floating point unit and

00:04:40,560 --> 00:04:45,440
start to implement vector instructions

00:04:42,160 --> 00:04:49,520
but i'll talk about that later

00:04:45,440 --> 00:04:53,360
so uh we use ghtl for simulation

00:04:49,520 --> 00:04:56,639
uh ghdl is a gnu it's a

00:04:53,360 --> 00:04:58,880
gpl licensed piece of software

00:04:56,639 --> 00:05:00,000
vhdl is actually based on ada which i

00:04:58,880 --> 00:05:02,560
didn't know

00:05:00,000 --> 00:05:03,440
before i started looking at it so ghdl

00:05:02,560 --> 00:05:07,199
is

00:05:03,440 --> 00:05:10,960
an extension of gnu ada for the

00:05:07,199 --> 00:05:12,880
latter ccp5 we use ghdl plus

00:05:10,960 --> 00:05:15,840
open source uh place and route type

00:05:12,880 --> 00:05:18,240
tools us and next pnr

00:05:15,840 --> 00:05:19,360
these tools are based largely on reverse

00:05:18,240 --> 00:05:22,720
engineering of

00:05:19,360 --> 00:05:26,639
the the lattice bitstream for

00:05:22,720 --> 00:05:30,320
the xilinx arctic 7 i at least still use

00:05:26,639 --> 00:05:33,280
vivado which is xilinx's proprietary

00:05:30,320 --> 00:05:34,240
tool fortunately there are free licenses

00:05:33,280 --> 00:05:38,560
available

00:05:34,240 --> 00:05:40,880
for that i would like to use free

00:05:38,560 --> 00:05:42,720
tools but they they don't quite seem to

00:05:40,880 --> 00:05:45,199
be there for the xilinx parts yet

00:05:42,720 --> 00:05:46,400
um there seems to be a lot in them in

00:05:45,199 --> 00:05:48,960
the xilinx parts

00:05:46,400 --> 00:05:50,479
that's difficult to work out about how

00:05:48,960 --> 00:05:51,680
the bitstream works from reverse

00:05:50,479 --> 00:05:53,680
engineering at least

00:05:51,680 --> 00:05:55,360
that's the impression i have so far but

00:05:53,680 --> 00:05:56,720
i would really love to have

00:05:55,360 --> 00:05:58,720
open source tools there that we could

00:05:56,720 --> 00:06:01,759
use as well

00:05:58,720 --> 00:06:03,520
now the microwatt core has a wishbone

00:06:01,759 --> 00:06:04,560
memory interface that's a particular

00:06:03,520 --> 00:06:07,680
style of

00:06:04,560 --> 00:06:10,080
how to connect to memory we use

00:06:07,680 --> 00:06:14,479
peripherals from the lytex project

00:06:10,080 --> 00:06:16,319
the that's um a project which

00:06:14,479 --> 00:06:17,840
has a whole pile of different kinds of

00:06:16,319 --> 00:06:19,039
things it's got you know dram

00:06:17,840 --> 00:06:22,720
controllers and

00:06:19,039 --> 00:06:25,919
ethernet and spi and sd card and

00:06:22,720 --> 00:06:27,039
all sorts of different peripherals it's

00:06:25,919 --> 00:06:29,199
all wrapped up in

00:06:27,039 --> 00:06:31,600
object oriented python which i

00:06:29,199 --> 00:06:33,680
personally find a bit difficult

00:06:31,600 --> 00:06:35,360
and it likes to create a whole sock not

00:06:33,680 --> 00:06:35,919
just a peripheral that i can then take

00:06:35,360 --> 00:06:37,919
and

00:06:35,919 --> 00:06:39,520
put in with my other stuff so

00:06:37,919 --> 00:06:42,000
nevertheless we we've

00:06:39,520 --> 00:06:43,680
we've worked around that and we have an

00:06:42,000 --> 00:06:46,800
ethernet and a dram controller

00:06:43,680 --> 00:06:48,479
from the lytex project so that's all

00:06:46,800 --> 00:06:50,880
great uh

00:06:48,479 --> 00:06:53,120
we've got this core that can run integer

00:06:50,880 --> 00:06:54,720
instructions and user space instructions

00:06:53,120 --> 00:06:57,120
and

00:06:54,720 --> 00:06:57,840
fine but you know we're all linux

00:06:57,120 --> 00:07:00,639
programmers

00:06:57,840 --> 00:07:01,520
so we really want to run linux on this

00:07:00,639 --> 00:07:05,120
thing

00:07:01,520 --> 00:07:06,720
what does it take to run linux so that's

00:07:05,120 --> 00:07:09,280
the main thing that i'll be going on

00:07:06,720 --> 00:07:13,039
with later on in this talk

00:07:09,280 --> 00:07:16,319
firstly though i'd like to just

00:07:13,039 --> 00:07:18,240
recap the basic

00:07:16,319 --> 00:07:19,599
features of the power instruction set

00:07:18,240 --> 00:07:23,280
architecture

00:07:19,599 --> 00:07:25,280
it's a 64-bit risk architecture

00:07:23,280 --> 00:07:26,560
i wrote it had fixed length instructions

00:07:25,280 --> 00:07:29,840
but then of course

00:07:26,560 --> 00:07:31,680
for power 10 and version 3.1 of the isa

00:07:29,840 --> 00:07:33,840
they added these prefix instructions and

00:07:31,680 --> 00:07:36,560
if you went to jordan nether's talk

00:07:33,840 --> 00:07:37,599
uh earlier today you he explained about

00:07:36,560 --> 00:07:39,840
those and

00:07:37,599 --> 00:07:41,280
what the advantage of those are we

00:07:39,840 --> 00:07:42,720
haven't actually implemented them in

00:07:41,280 --> 00:07:44,479
microwave yet

00:07:42,720 --> 00:07:46,400
so as far as microwave is concerned we

00:07:44,479 --> 00:07:47,759
still have fixed length 32-bit

00:07:46,400 --> 00:07:50,000
instructions

00:07:47,759 --> 00:07:51,199
uh we say it's risk and there are a

00:07:50,000 --> 00:07:53,759
number of characteristics

00:07:51,199 --> 00:07:54,479
um not you know having a small number of

00:07:53,759 --> 00:07:57,199
instructions

00:07:54,479 --> 00:07:59,280
is not one of them this isa does have

00:07:57,199 --> 00:08:01,039
quite a lot of instructions

00:07:59,280 --> 00:08:02,720
but there are characteristics such as

00:08:01,039 --> 00:08:03,599
that only the load and store

00:08:02,720 --> 00:08:06,000
instructions

00:08:03,599 --> 00:08:07,440
access memory and basically the load and

00:08:06,000 --> 00:08:09,520
store instructions don't do anything

00:08:07,440 --> 00:08:11,520
except accessing memory

00:08:09,520 --> 00:08:13,120
you have a lot of registers so the

00:08:11,520 --> 00:08:16,720
register stat set has

00:08:13,120 --> 00:08:18,160
32 general purpose registers gprs each

00:08:16,720 --> 00:08:22,080
of 64 bits

00:08:18,160 --> 00:08:25,120
it has 128 bit vector scalar registers

00:08:22,080 --> 00:08:27,680
it has 64 of them

00:08:25,120 --> 00:08:29,199
the 32 floating point registers that

00:08:27,680 --> 00:08:30,160
have been in the architecture for a long

00:08:29,199 --> 00:08:34,000
time

00:08:30,160 --> 00:08:37,200
uh incorporated into that sort of 64 by

00:08:34,000 --> 00:08:38,240
as one corner of that 64 by 128 bit

00:08:37,200 --> 00:08:41,680
square of

00:08:38,240 --> 00:08:43,519
vsrs there are also what we call special

00:08:41,680 --> 00:08:46,080
purpose registers

00:08:43,519 --> 00:08:47,920
these include some things that get used

00:08:46,080 --> 00:08:50,800
quite frequently in programs

00:08:47,920 --> 00:08:51,920
such as the link register used for

00:08:50,800 --> 00:08:54,720
procedure linkage

00:08:51,920 --> 00:08:56,959
the count register which is used for

00:08:54,720 --> 00:08:59,120
tight loops and a few other things

00:08:56,959 --> 00:09:01,839
but then there are also many special

00:08:59,120 --> 00:09:04,959
purpose registers that relate to

00:09:01,839 --> 00:09:05,680
features of the system that are accessed

00:09:04,959 --> 00:09:08,560
more rarely

00:09:05,680 --> 00:09:09,120
and they include things like a data

00:09:08,560 --> 00:09:12,240
address

00:09:09,120 --> 00:09:13,440
breakpoint register and

00:09:12,240 --> 00:09:14,880
you know registers in the memory

00:09:13,440 --> 00:09:15,360
management unit that tell you the

00:09:14,880 --> 00:09:17,120
address

00:09:15,360 --> 00:09:18,880
where a page fault happened and that

00:09:17,120 --> 00:09:21,440
that kind of thing

00:09:18,880 --> 00:09:22,640
and there's also a 32-bit condition

00:09:21,440 --> 00:09:25,360
register

00:09:22,640 --> 00:09:27,519
uh norm normally you'd expect a machine

00:09:25,360 --> 00:09:30,640
to have some sort of condition code

00:09:27,519 --> 00:09:32,000
register or condition codes in some

00:09:30,640 --> 00:09:35,040
register and there's normally

00:09:32,000 --> 00:09:37,279
you know four bits of condition code

00:09:35,040 --> 00:09:38,640
but the power architecture's got eight

00:09:37,279 --> 00:09:41,279
sets of four bits

00:09:38,640 --> 00:09:42,800
uh and and what this does is it lets you

00:09:41,279 --> 00:09:44,560
decouple a comparison

00:09:42,800 --> 00:09:47,600
from a branch for instance so that you

00:09:44,560 --> 00:09:49,680
can do a number of compares

00:09:47,600 --> 00:09:51,519
and then later on branch based on the

00:09:49,680 --> 00:09:54,080
result of those comparisons

00:09:51,519 --> 00:09:56,880
and you can hide the latency between the

00:09:54,080 --> 00:09:58,320
compare and the branch in that way

00:09:56,880 --> 00:10:01,040
finally there's what's called the

00:09:58,320 --> 00:10:03,600
machine status register msr

00:10:01,040 --> 00:10:06,320
which is you know one of those examples

00:10:03,600 --> 00:10:07,440
of ibm using an acronym for something

00:10:06,320 --> 00:10:11,040
different to what the rest of the

00:10:07,440 --> 00:10:14,560
industry is which we do quite frequently

00:10:11,040 --> 00:10:16,640
but the the the msr contains bits like

00:10:14,560 --> 00:10:19,120
are you in privileged mode or not are

00:10:16,640 --> 00:10:21,040
interrupts enabled or not

00:10:19,120 --> 00:10:22,399
is the mmu enabled or not that kind of

00:10:21,040 --> 00:10:25,920
thing

00:10:22,399 --> 00:10:26,560
now instructions have between zero and

00:10:25,920 --> 00:10:29,600
three

00:10:26,560 --> 00:10:31,360
register operands uh three

00:10:29,600 --> 00:10:33,279
an example of an of one with three

00:10:31,360 --> 00:10:35,279
operands would be a multiply ad type

00:10:33,279 --> 00:10:37,200
instruction

00:10:35,279 --> 00:10:38,560
and it has two addressing modes for

00:10:37,200 --> 00:10:40,560
accessing memory

00:10:38,560 --> 00:10:41,680
there's what's called offset mode which

00:10:40,560 --> 00:10:43,279
is that you take

00:10:41,680 --> 00:10:44,880
the value in a register and add a

00:10:43,279 --> 00:10:46,320
constant to it where the constant comes

00:10:44,880 --> 00:10:48,399
from the instruction

00:10:46,320 --> 00:10:49,360
and there's index mode where you have

00:10:48,399 --> 00:10:51,040
two registers

00:10:49,360 --> 00:10:53,040
and you add the contents of the

00:10:51,040 --> 00:10:55,920
registers together to get

00:10:53,040 --> 00:10:56,800
the the value that you want the address

00:10:55,920 --> 00:11:00,640
that you want

00:10:56,800 --> 00:11:02,399
what we call the effective address now

00:11:00,640 --> 00:11:03,839
the power instruction said architecture

00:11:02,399 --> 00:11:05,120
has actually been around for a very long

00:11:03,839 --> 00:11:08,480
time

00:11:05,120 --> 00:11:10,640
since the early 90s in fact you may well

00:11:08,480 --> 00:11:12,959
know it as powerpc

00:11:10,640 --> 00:11:16,480
because as hugh explained in his talk

00:11:12,959 --> 00:11:18,320
that he gave earlier on about open power

00:11:16,480 --> 00:11:20,160
it was initially power when it was an

00:11:18,320 --> 00:11:22,000
ibm thing and then

00:11:20,160 --> 00:11:24,079
when the apple ibm and motorola

00:11:22,000 --> 00:11:26,000
consortium was launched

00:11:24,079 --> 00:11:28,000
the architecture was revised and it was

00:11:26,000 --> 00:11:30,640
called powerpc

00:11:28,000 --> 00:11:31,600
uh and it was known as powerpc for for a

00:11:30,640 --> 00:11:34,240
long time

00:11:31,600 --> 00:11:35,040
and it's still called powerpc in the uh

00:11:34,240 --> 00:11:37,040
in the kernel

00:11:35,040 --> 00:11:38,320
tree for instance it's arch slash

00:11:37,040 --> 00:11:42,000
powerpc

00:11:38,320 --> 00:11:44,959
uh ibm renamed it back to power

00:11:42,000 --> 00:11:45,680
basically after you know apple stopped

00:11:44,959 --> 00:11:48,000
using it

00:11:45,680 --> 00:11:50,160
and free you know motorola slash

00:11:48,000 --> 00:11:53,360
freescale slash nxp

00:11:50,160 --> 00:11:57,920
um very much stopped

00:11:53,360 --> 00:11:59,519
using it so much and so then it became

00:11:57,920 --> 00:12:01,760
pretty much just the architecture for

00:11:59,519 --> 00:12:04,320
the ibm power server

00:12:01,760 --> 00:12:06,720
machines and so it was renamed back to

00:12:04,320 --> 00:12:09,519
power isa

00:12:06,720 --> 00:12:10,800
so we have um you know a number of

00:12:09,519 --> 00:12:14,000
versions

00:12:10,800 --> 00:12:15,200
version you know 1.1 is that the thing

00:12:14,000 --> 00:12:18,000
that was

00:12:15,200 --> 00:12:19,279
in the 90s it was 32-bit basically a lot

00:12:18,000 --> 00:12:22,560
had 64-bit

00:12:19,279 --> 00:12:24,240
as an extension and

00:12:22,560 --> 00:12:26,959
it was used for a lot of the chips that

00:12:24,240 --> 00:12:26,959
apple used

00:12:27,120 --> 00:12:31,600
version 2.0 corresponds to power 4 so

00:12:30,560 --> 00:12:35,440
that was in about

00:12:31,600 --> 00:12:37,600
2000 that power 4 came out and

00:12:35,440 --> 00:12:38,959
there's a correspondence between

00:12:37,600 --> 00:12:42,079
releases of the power

00:12:38,959 --> 00:12:43,760
processes and versions of the

00:12:42,079 --> 00:12:47,120
architecture we go from

00:12:43,760 --> 00:12:47,839
version 2.0 for power 4 to version 2.07

00:12:47,120 --> 00:12:52,160
b

00:12:47,839 --> 00:12:53,519
which is power 8. then version 3.0 b

00:12:52,160 --> 00:12:55,839
is power 9 and the interesting thing

00:12:53,519 --> 00:12:57,760
about that one is that it adds the

00:12:55,839 --> 00:13:00,320
radix memory management unit which i'll

00:12:57,760 --> 00:13:03,120
talk about later

00:13:00,320 --> 00:13:04,240
then in version 3.0c which was a minor

00:13:03,120 --> 00:13:06,639
revision

00:13:04,240 --> 00:13:08,399
they added this was after basically the

00:13:06,639 --> 00:13:10,240
architecture was opened or

00:13:08,399 --> 00:13:11,519
in conjunction with it being opened by

00:13:10,240 --> 00:13:13,920
ibm

00:13:11,519 --> 00:13:14,720
they added compliancy subsets and the

00:13:13,920 --> 00:13:18,480
idea here

00:13:14,720 --> 00:13:20,880
is that in opening up the architecture

00:13:18,480 --> 00:13:22,480
we expect that people will use it for

00:13:20,880 --> 00:13:25,680
all sorts of different things and that

00:13:22,480 --> 00:13:27,839
for some applications you may not want

00:13:25,680 --> 00:13:29,279
to implement everything that a power 9

00:13:27,839 --> 00:13:31,839
implements

00:13:29,279 --> 00:13:33,279
so you can implement what's called for

00:13:31,839 --> 00:13:35,040
example the scalar fixed point

00:13:33,279 --> 00:13:36,959
compliancy subset

00:13:35,040 --> 00:13:38,480
which says that you know you have to

00:13:36,959 --> 00:13:40,240
implement

00:13:38,480 --> 00:13:41,519
all the basic integer instructions and a

00:13:40,240 --> 00:13:42,800
bunch of other stuff but you don't have

00:13:41,519 --> 00:13:44,399
to implement floating point

00:13:42,800 --> 00:13:46,959
you don't have to implement the vector

00:13:44,399 --> 00:13:50,399
instructions you don't have to implement

00:13:46,959 --> 00:13:51,519
various other things then

00:13:50,399 --> 00:13:55,440
in particular you don't have to

00:13:51,519 --> 00:13:57,519
implement the hash page table mmu

00:13:55,440 --> 00:13:59,440
there's also a scalar fixed point plus

00:13:57,519 --> 00:14:00,000
floating point compliancy subset which

00:13:59,440 --> 00:14:02,240
is like

00:14:00,000 --> 00:14:03,360
sfs but adds just the floating point

00:14:02,240 --> 00:14:04,800
instructions

00:14:03,360 --> 00:14:06,480
and then there's what's called the linux

00:14:04,800 --> 00:14:09,600
compliancy subset

00:14:06,480 --> 00:14:11,519
uh which was intended to be kind of the

00:14:09,600 --> 00:14:13,360
minimum that you would need to run linux

00:14:11,519 --> 00:14:14,959
in fact it turns out you can run linux

00:14:13,360 --> 00:14:16,560
with less than the linux compliancy

00:14:14,959 --> 00:14:19,519
subset but

00:14:16,560 --> 00:14:21,199
i'll talk about that later too and then

00:14:19,519 --> 00:14:23,519
with version 3.1

00:14:21,199 --> 00:14:25,120
that corresponds to power 10 and we get

00:14:23,519 --> 00:14:26,240
the prefix instructions that jordan

00:14:25,120 --> 00:14:28,720
talked about

00:14:26,240 --> 00:14:30,079
and we have now some instructions that

00:14:28,720 --> 00:14:32,480
are 64 bits long

00:14:30,079 --> 00:14:34,160
but as i say i'm going to ignore them

00:14:32,480 --> 00:14:36,399
because microwatt doesn't implement them

00:14:34,160 --> 00:14:36,399
yet

00:14:36,720 --> 00:14:41,040
okay so we want to run linux we're all

00:14:39,519 --> 00:14:42,800
linux hackers

00:14:41,040 --> 00:14:44,639
what's the point of a processor if you

00:14:42,800 --> 00:14:47,760
can't run linux on it

00:14:44,639 --> 00:14:49,920
yeah i know but let's go with that

00:14:47,760 --> 00:14:52,000
so the first thing you need is you need

00:14:49,920 --> 00:14:54,320
privileged modes you need to be able to

00:14:52,000 --> 00:14:55,360
have a kernel that's running and is

00:14:54,320 --> 00:14:58,320
protected from

00:14:55,360 --> 00:15:00,079
what user space does and you need to be

00:14:58,320 --> 00:15:01,600
able to protect you know one user space

00:15:00,079 --> 00:15:02,399
from another user space so you need to

00:15:01,600 --> 00:15:05,040
have

00:15:02,399 --> 00:15:07,440
this concept of user mode and kernel

00:15:05,040 --> 00:15:08,880
mode or supervisor mode

00:15:07,440 --> 00:15:10,959
which in the architecture are called

00:15:08,880 --> 00:15:14,480
privileged state and problem state

00:15:10,959 --> 00:15:16,720
problem being because you know that's

00:15:14,480 --> 00:15:18,079
you you're running users user code to

00:15:16,720 --> 00:15:20,399
solve some problem

00:15:18,079 --> 00:15:21,120
so that's what's called problem state

00:15:20,399 --> 00:15:23,680
and

00:15:21,120 --> 00:15:24,800
then you have interrupts or exceptions

00:15:23,680 --> 00:15:26,320
or traps

00:15:24,800 --> 00:15:28,959
these are different names that people

00:15:26,320 --> 00:15:31,839
use in the architecture

00:15:28,959 --> 00:15:33,040
it uses the word interrupt a bit

00:15:31,839 --> 00:15:35,759
differently from

00:15:33,040 --> 00:15:37,839
how it's used in the rest of the

00:15:35,759 --> 00:15:40,320
industry another example of

00:15:37,839 --> 00:15:41,680
how ibm likes to do this but it is used

00:15:40,320 --> 00:15:44,480
quite precisely

00:15:41,680 --> 00:15:46,560
in the sense that the interrupt is the

00:15:44,480 --> 00:15:48,560
change in the flow of program control

00:15:46,560 --> 00:15:51,120
in other words the interrupt is the act

00:15:48,560 --> 00:15:52,959
of stopping executing the instructions

00:15:51,120 --> 00:15:55,519
that you were executing

00:15:52,959 --> 00:15:57,199
and saving a little bit of state and

00:15:55,519 --> 00:16:00,160
starting executing again

00:15:57,199 --> 00:16:01,519
from an interrupt handler so that

00:16:00,160 --> 00:16:03,839
applies to things like

00:16:01,519 --> 00:16:04,720
external device interrupts or timer

00:16:03,839 --> 00:16:06,720
interrupts

00:16:04,720 --> 00:16:08,800
but it also includes things like page

00:16:06,720 --> 00:16:10,480
faults and system calls

00:16:08,800 --> 00:16:12,720
and interrupts that your program might

00:16:10,480 --> 00:16:14,639
cause by trying to execute a privileged

00:16:12,720 --> 00:16:16,399
or a legal instruction

00:16:14,639 --> 00:16:18,160
or it could also be something like a

00:16:16,399 --> 00:16:19,839
debugging interrupt where

00:16:18,160 --> 00:16:22,399
you know you've done a single step and

00:16:19,839 --> 00:16:23,199
you've executed one instruction so then

00:16:22,399 --> 00:16:25,279
you go

00:16:23,199 --> 00:16:27,360
to the single step handler and that's an

00:16:25,279 --> 00:16:28,399
interrupt or if you execute a trap

00:16:27,360 --> 00:16:30,720
instruction

00:16:28,399 --> 00:16:32,399
which is like a software breakpoint

00:16:30,720 --> 00:16:34,880
that's an interrupt

00:16:32,399 --> 00:16:35,680
the exception then is in the

00:16:34,880 --> 00:16:38,320
architecture

00:16:35,680 --> 00:16:40,480
is the condition that causes the

00:16:38,320 --> 00:16:44,000
interrupt to be taken so

00:16:40,480 --> 00:16:46,560
the exception is for instance that uh

00:16:44,000 --> 00:16:48,000
no valid pte was found no valid page

00:16:46,560 --> 00:16:49,680
table entry was found

00:16:48,000 --> 00:16:51,279
when trying to translate an address

00:16:49,680 --> 00:16:54,639
that's an exception

00:16:51,279 --> 00:16:57,360
and then the interrupt is we jump to the

00:16:54,639 --> 00:16:58,880
300 hex address which is the you know

00:16:57,360 --> 00:17:02,399
data storage interrupt handler

00:16:58,880 --> 00:17:02,399
where you where you handle a page fault

00:17:02,480 --> 00:17:06,319
so we need them because that's how you

00:17:04,559 --> 00:17:09,600
get out of user mode back into

00:17:06,319 --> 00:17:10,799
uh into the kernel and that's how you

00:17:09,600 --> 00:17:13,760
enable

00:17:10,799 --> 00:17:14,559
drivers for instance to function uh

00:17:13,760 --> 00:17:19,280
while

00:17:14,559 --> 00:17:20,720
uh user space is running then

00:17:19,280 --> 00:17:23,199
so we need those we need a memory

00:17:20,720 --> 00:17:24,400
management unit we need an external

00:17:23,199 --> 00:17:26,160
interrupt controller

00:17:24,400 --> 00:17:27,760
there's basically a single wire that

00:17:26,160 --> 00:17:29,840
comes into the cpu

00:17:27,760 --> 00:17:30,880
that says there's a device needing an

00:17:29,840 --> 00:17:33,760
interrupt

00:17:30,880 --> 00:17:35,440
and you need some way to be able to

00:17:33,760 --> 00:17:36,320
control whether devices can interrupt

00:17:35,440 --> 00:17:38,480
and

00:17:36,320 --> 00:17:40,320
in an smp system you need to be able to

00:17:38,480 --> 00:17:42,559
control where those interrupts go

00:17:40,320 --> 00:17:43,679
and that kind of thing and finally we

00:17:42,559 --> 00:17:46,559
need enough

00:17:43,679 --> 00:17:47,200
memory for a linux kernel that's going

00:17:46,559 --> 00:17:49,679
to be

00:17:47,200 --> 00:17:51,440
at the least several megabytes and

00:17:49,679 --> 00:17:52,160
preferably quite a bit more than that

00:17:51,440 --> 00:17:55,840
and

00:17:52,160 --> 00:17:59,600
you know the more the better really

00:17:55,840 --> 00:18:01,520
okay so to implement interrupts

00:17:59,600 --> 00:18:03,360
this is one of the first things we did

00:18:01,520 --> 00:18:06,400
earlier last year

00:18:03,360 --> 00:18:07,600
in fact mikey newling did most of this

00:18:06,400 --> 00:18:10,400
work

00:18:07,600 --> 00:18:11,360
so we have in execute1.vhdl we have

00:18:10,400 --> 00:18:13,600
logic

00:18:11,360 --> 00:18:14,960
that detects the exception condition

00:18:13,600 --> 00:18:16,880
that's arisen

00:18:14,960 --> 00:18:18,880
and then we arranged to do the steps of

00:18:16,880 --> 00:18:21,120
taking an interrupt which is that

00:18:18,880 --> 00:18:22,240
the instruction address where we were up

00:18:21,120 --> 00:18:24,880
to

00:18:22,240 --> 00:18:26,480
gets written to this srr0 special

00:18:24,880 --> 00:18:29,440
purpose register

00:18:26,480 --> 00:18:30,880
and the contents of the msr plus some

00:18:29,440 --> 00:18:33,120
extra bits to say what

00:18:30,880 --> 00:18:35,120
the cause of the interrupt was etc get

00:18:33,120 --> 00:18:38,160
written to sro1

00:18:35,120 --> 00:18:40,880
and then we basically branch

00:18:38,160 --> 00:18:42,480
to the interrupt vector address so

00:18:40,880 --> 00:18:44,720
that's fine we did that

00:18:42,480 --> 00:18:46,080
uh mike you also wrote the external

00:18:44,720 --> 00:18:48,720
interrupt controller

00:18:46,080 --> 00:18:50,480
now there's a number of different

00:18:48,720 --> 00:18:52,720
possible ways you can organize an

00:18:50,480 --> 00:18:55,440
external interrupt controller we chose

00:18:52,720 --> 00:18:57,280
to use the one called xics

00:18:55,440 --> 00:18:59,440
this is not the one that's on power 9

00:18:57,280 --> 00:19:02,080
and power 10 it's the one that

00:18:59,440 --> 00:19:03,520
preceded that that was used on the ibm

00:19:02,080 --> 00:19:08,160
power machines

00:19:03,520 --> 00:19:11,200
basically from power 4 until power 8.

00:19:08,160 --> 00:19:12,960
it comes in two parts one is that there

00:19:11,200 --> 00:19:16,799
is an interrupt controller source

00:19:12,960 --> 00:19:19,520
per interrupt source so every

00:19:16,799 --> 00:19:20,160
you know possible device that can

00:19:19,520 --> 00:19:21,679
interrupt

00:19:20,160 --> 00:19:23,360
every interrupt line that comes from a

00:19:21,679 --> 00:19:25,919
device

00:19:23,360 --> 00:19:27,679
would have an ics register and that lets

00:19:25,919 --> 00:19:30,160
you control the priority

00:19:27,679 --> 00:19:31,760
of the interrupt where it goes to and

00:19:30,160 --> 00:19:34,799
turn it on and off

00:19:31,760 --> 00:19:36,400
then for each cpu you have this icp

00:19:34,799 --> 00:19:39,039
interrupt controller presentation

00:19:36,400 --> 00:19:40,160
set of registers and these say what the

00:19:39,039 --> 00:19:42,320
priority of the cpu

00:19:40,160 --> 00:19:43,679
is and by reading them you can

00:19:42,320 --> 00:19:45,120
acknowledge and interrupt

00:19:43,679 --> 00:19:46,720
and by writing you can cause an

00:19:45,120 --> 00:19:48,400
interprocessor interrupt where

00:19:46,720 --> 00:19:50,400
one cpu just wants to generate an

00:19:48,400 --> 00:19:53,520
interrupt directly to another one

00:19:50,400 --> 00:19:56,799
so it's actually pretty simple um

00:19:53,520 --> 00:19:58,640
it's way way simpler than the xive that

00:19:56,799 --> 00:20:01,440
was introduced with power9

00:19:58,640 --> 00:20:03,919
and it seemed like a good fit for

00:20:01,440 --> 00:20:03,919
microwatt

00:20:04,799 --> 00:20:07,840
now as for the privileged modes there

00:20:06,799 --> 00:20:11,039
are four modes

00:20:07,840 --> 00:20:12,320
defined in the isa uh we have ultravisor

00:20:11,039 --> 00:20:14,400
hypervisor

00:20:12,320 --> 00:20:15,919
privileged non-hypervisor which i

00:20:14,400 --> 00:20:17,840
normally call supervisor

00:20:15,919 --> 00:20:20,720
and problem state which most people

00:20:17,840 --> 00:20:24,240
usually call user mode

00:20:20,720 --> 00:20:25,679
hypervisor is there for virtualization

00:20:24,240 --> 00:20:26,640
so that you can have multiple virtual

00:20:25,679 --> 00:20:30,159
machines

00:20:26,640 --> 00:20:31,919
so you can do virtu you can have logical

00:20:30,159 --> 00:20:34,240
partitions or

00:20:31,919 --> 00:20:35,120
you can run kvm that kind of thing the

00:20:34,240 --> 00:20:37,600
ultravisor

00:20:35,120 --> 00:20:40,159
is there for a kind of trusted execution

00:20:37,600 --> 00:20:41,840
environment type of facility

00:20:40,159 --> 00:20:43,360
so i'm going to ignore ultravisor and

00:20:41,840 --> 00:20:45,600
hypervisor

00:20:43,360 --> 00:20:46,559
in microart we just do supervisor and

00:20:45,600 --> 00:20:48,480
user mode

00:20:46,559 --> 00:20:50,559
and there's one bit in the msr that

00:20:48,480 --> 00:20:52,640
selects that's the pr bit

00:20:50,559 --> 00:20:53,760
and when that bit is zero you're

00:20:52,640 --> 00:20:57,600
privileged when you're

00:20:53,760 --> 00:20:57,600
when it's one you're in problem state

00:20:57,840 --> 00:21:01,919
so what do we do to implement that well

00:21:00,320 --> 00:21:05,760
we have to add logic

00:21:01,919 --> 00:21:07,120
into microart so that we know for each

00:21:05,760 --> 00:21:08,400
instruction whether it's a privileged

00:21:07,120 --> 00:21:10,400
instruction or not

00:21:08,400 --> 00:21:11,440
and if it's a privileged instruction an

00:21:10,400 --> 00:21:13,679
msrpr

00:21:11,440 --> 00:21:14,720
is one then we don't execute the

00:21:13,679 --> 00:21:16,000
instruction we

00:21:14,720 --> 00:21:18,000
generate a privileged instruction

00:21:16,000 --> 00:21:21,280
interrupt instead

00:21:18,000 --> 00:21:22,559
then the interrupter course clears msrpr

00:21:21,280 --> 00:21:25,520
so then you are in

00:21:22,559 --> 00:21:25,520
supervisor state

00:21:25,840 --> 00:21:32,880
and and you can handle it and finally

00:21:29,360 --> 00:21:34,880
once we get to an mmu and we have ptes

00:21:32,880 --> 00:21:36,720
page table entries they have a

00:21:34,880 --> 00:21:37,360
privileged bid and if you're in user

00:21:36,720 --> 00:21:38,880
mode

00:21:37,360 --> 00:21:41,440
and you try and access a page where the

00:21:38,880 --> 00:21:44,080
pte says privileged

00:21:41,440 --> 00:21:46,640
then once again you take a page fault so

00:21:44,080 --> 00:21:46,640
we did all that

00:21:46,799 --> 00:21:49,840
then we come to the memory management

00:21:48,320 --> 00:21:52,799
unit

00:21:49,840 --> 00:21:53,520
now our instruction set architecture

00:21:52,799 --> 00:21:55,280
defines

00:21:53,520 --> 00:21:57,200
two different address translation

00:21:55,280 --> 00:22:00,240
schemes as i mentioned earlier

00:21:57,200 --> 00:22:01,520
we've got the hash page table this is

00:22:00,240 --> 00:22:04,799
the one that's

00:22:01,520 --> 00:22:07,679
been there since the beginning it's used

00:22:04,799 --> 00:22:11,039
by ibm's proprietary operating systems

00:22:07,679 --> 00:22:13,600
aix and ibmi and it's also used by older

00:22:11,039 --> 00:22:16,799
linux kernels because

00:22:13,600 --> 00:22:17,760
the the radix page table was added as i

00:22:16,799 --> 00:22:21,440
said in

00:22:17,760 --> 00:22:25,200
the isa version 3.0 for power nine

00:22:21,440 --> 00:22:28,720
and so before we got to the point of

00:22:25,200 --> 00:22:30,320
starting to support power 9 there was no

00:22:28,720 --> 00:22:32,799
radix page table support

00:22:30,320 --> 00:22:33,679
so if you're running a kernel that's

00:22:32,799 --> 00:22:37,039
let's say

00:22:33,679 --> 00:22:38,559
4.5 version 4.5 or older it doesn't have

00:22:37,039 --> 00:22:40,880
the support for

00:22:38,559 --> 00:22:42,400
radix page table at least not unless

00:22:40,880 --> 00:22:44,240
your distro has

00:22:42,400 --> 00:22:46,080
back ported all of that stuff into its

00:22:44,240 --> 00:22:48,080
older kernel like red hat did with the

00:22:46,080 --> 00:22:50,799
310 kernel

00:22:48,080 --> 00:22:52,080
that was a franken kernel anyway so

00:22:50,799 --> 00:22:54,320
older kernels

00:22:52,080 --> 00:22:55,520
don't know about radix newer ones do

00:22:54,320 --> 00:22:59,679
know about radix

00:22:55,520 --> 00:23:02,159
since about 4.6 and prefer to use radix

00:22:59,679 --> 00:23:04,320
in fact the radix page table was added

00:23:02,159 --> 00:23:05,919
to power9 specifically for linux and

00:23:04,320 --> 00:23:06,960
linux is the only operating system that

00:23:05,919 --> 00:23:10,240
uses it

00:23:06,960 --> 00:23:11,679
so it actually

00:23:10,240 --> 00:23:13,520
improves things quite a bit for us

00:23:11,679 --> 00:23:17,200
because we can map

00:23:13,520 --> 00:23:21,520
the kernel's architecture and dependent

00:23:17,200 --> 00:23:24,720
radix page tables which it's always had

00:23:21,520 --> 00:23:26,159
onto the hardware so that the hardware

00:23:24,720 --> 00:23:27,760
can read those radix page tables

00:23:26,159 --> 00:23:30,240
directly

00:23:27,760 --> 00:23:32,159
so that was a big win for us so

00:23:30,240 --> 00:23:34,799
microwater course implements radix a not

00:23:32,159 --> 00:23:37,120
hash page table

00:23:34,799 --> 00:23:39,600
radix i think is is generally simpler

00:23:37,120 --> 00:23:41,440
and requires less hardware and

00:23:39,600 --> 00:23:44,240
it's it's the better way to go for linux

00:23:41,440 --> 00:23:46,960
anyway now the isa defines

00:23:44,240 --> 00:23:48,640
a very general tree structure here and

00:23:46,960 --> 00:23:51,360
and i'll just walk through it because

00:23:48,640 --> 00:23:53,200
it's it's quite interesting at the start

00:23:51,360 --> 00:23:55,600
you have on the left

00:23:53,200 --> 00:23:57,360
this partition table control register

00:23:55,600 --> 00:23:59,600
which is an spr

00:23:57,360 --> 00:24:01,760
and that points to the partition table

00:23:59,600 --> 00:24:03,840
the partition table is in memory

00:24:01,760 --> 00:24:05,679
and it's indexed by this logical

00:24:03,840 --> 00:24:07,520
partition id register

00:24:05,679 --> 00:24:09,039
so this is used for virtualization and

00:24:07,520 --> 00:24:09,760
enables you to have different page

00:24:09,039 --> 00:24:11,600
tables

00:24:09,760 --> 00:24:14,320
for each different guest each different

00:24:11,600 --> 00:24:17,200
kvm or power vm guest

00:24:14,320 --> 00:24:19,919
the partition table entry then points to

00:24:17,200 --> 00:24:21,679
the process table this process table

00:24:19,919 --> 00:24:24,080
is in memory but it's in the guest

00:24:21,679 --> 00:24:26,559
memory if you're running in a guest

00:24:24,080 --> 00:24:27,440
and it's indexed by the process id

00:24:26,559 --> 00:24:30,559
register

00:24:27,440 --> 00:24:32,960
now this pid register is what the

00:24:30,559 --> 00:24:34,159
kernel changes when it switches from one

00:24:32,960 --> 00:24:35,760
process to another

00:24:34,159 --> 00:24:37,440
so each process has got a different

00:24:35,760 --> 00:24:39,840
value for the

00:24:37,440 --> 00:24:41,520
paid register it's got a different entry

00:24:39,840 --> 00:24:43,440
in this process table

00:24:41,520 --> 00:24:45,360
and therefore each process uses

00:24:43,440 --> 00:24:47,679
different radius page tables

00:24:45,360 --> 00:24:48,720
and then entry zero is used for the

00:24:47,679 --> 00:24:52,400
kernel

00:24:48,720 --> 00:24:54,240
so the mmu has got a arrangement where

00:24:52,400 --> 00:24:56,480
it looks basically the top two bits of

00:24:54,240 --> 00:24:58,559
the effective address that you generate

00:24:56,480 --> 00:25:00,080
and if those are one one then it's a

00:24:58,559 --> 00:25:03,279
kernel address and it uses entry

00:25:00,080 --> 00:25:04,880
0 here and if there are 0 0 it's a user

00:25:03,279 --> 00:25:07,279
space address and it uses

00:25:04,880 --> 00:25:08,880
whichever entry the bid register is

00:25:07,279 --> 00:25:12,559
pointing to

00:25:08,880 --> 00:25:15,120
then that process table entry points to

00:25:12,559 --> 00:25:16,960
the smaller boxes i've shown here which

00:25:15,120 --> 00:25:18,080
are the radix page tables and they're

00:25:16,960 --> 00:25:20,240
indexed by the

00:25:18,080 --> 00:25:22,320
uh by bit fields out of the address so

00:25:20,240 --> 00:25:25,760
you're taking the effective address

00:25:22,320 --> 00:25:29,360
and you're selecting uh you know a

00:25:25,760 --> 00:25:32,720
series of bits out of it and

00:25:29,360 --> 00:25:34,000
those series of bits are used to index

00:25:32,720 --> 00:25:36,320
each level of the tree

00:25:34,000 --> 00:25:37,520
this is just how radix page tables work

00:25:36,320 --> 00:25:39,279
and then at the end

00:25:37,520 --> 00:25:41,760
you get to something that points to your

00:25:39,279 --> 00:25:45,760
the the page of memory that your

00:25:41,760 --> 00:25:47,279
actually wanting to access so i'll just

00:25:45,760 --> 00:25:50,080
go into a little bit of detail here

00:25:47,279 --> 00:25:53,200
about this these page directory entry

00:25:50,080 --> 00:25:54,000
uh in in in the the top levels of the

00:25:53,200 --> 00:25:55,520
tree

00:25:54,000 --> 00:25:57,039
just to point out that they have this

00:25:55,520 --> 00:26:00,000
thing this nls

00:25:57,039 --> 00:26:01,360
field which is the next level size so

00:26:00,000 --> 00:26:03,919
the architecture has not

00:26:01,360 --> 00:26:05,200
actually hard coded that the page size

00:26:03,919 --> 00:26:08,240
is 4k

00:26:05,200 --> 00:26:10,880
and that you then have a pmd level of

00:26:08,240 --> 00:26:12,080
that maps let's say you know two

00:26:10,880 --> 00:26:13,520
megabytes and then you have another

00:26:12,080 --> 00:26:14,960
level that maps

00:26:13,520 --> 00:26:16,559
a gigabyte and you have another level

00:26:14,960 --> 00:26:20,000
that maps

00:26:16,559 --> 00:26:22,159
512 gigabytes or whatever it is uh

00:26:20,000 --> 00:26:24,159
as far as the architecture is concerned

00:26:22,159 --> 00:26:27,840
the programmer can set up

00:26:24,159 --> 00:26:29,279
whatever uh fields it likes to be the

00:26:27,840 --> 00:26:31,840
ones that are indexed

00:26:29,279 --> 00:26:33,039
out of the page tables out of the sorry

00:26:31,840 --> 00:26:36,480
out of the effective address

00:26:33,039 --> 00:26:37,440
to index the page tables so you could

00:26:36,480 --> 00:26:40,559
have

00:26:37,440 --> 00:26:42,960
uh two levels and just map

00:26:40,559 --> 00:26:44,240
two gigabytes or you could have ten

00:26:42,960 --> 00:26:48,799
levels and map

00:26:44,240 --> 00:26:50,400
um you know four exabytes or something

00:26:48,799 --> 00:26:52,159
the hardware engineers of course when

00:26:50,400 --> 00:26:53,360
they saw that threw up their hands and

00:26:52,159 --> 00:26:55,520
said this is totally

00:26:53,360 --> 00:26:57,200
impossible we can't cope with this so

00:26:55,520 --> 00:27:00,480
the isa does define

00:26:57,200 --> 00:27:03,200
two standard layouts both of which have

00:27:00,480 --> 00:27:05,760
a 52-bit effective address

00:27:03,200 --> 00:27:07,840
and notice that that's 52 bits for user

00:27:05,760 --> 00:27:11,279
space and another 52-bit

00:27:07,840 --> 00:27:11,840
space for the kernel um so it's a bit

00:27:11,279 --> 00:27:14,400
different

00:27:11,840 --> 00:27:15,360
in that you have you get to use two

00:27:14,400 --> 00:27:17,440
different trees

00:27:15,360 --> 00:27:19,360
one for the kernel and one for your

00:27:17,440 --> 00:27:22,480
current user space process

00:27:19,360 --> 00:27:25,840
52-bit effective address four levels

00:27:22,480 --> 00:27:28,880
uh and a 64k page size is the first

00:27:25,840 --> 00:27:31,360
standard layout so your index fields

00:27:28,880 --> 00:27:33,200
index 13 bits then nine bits then nine

00:27:31,360 --> 00:27:36,480
bits then five bits

00:27:33,200 --> 00:27:40,159
or one with a 52-bit ea

00:27:36,480 --> 00:27:41,840
and a 4k page size where you use 13 999

00:27:40,159 --> 00:27:43,760
bits

00:27:41,840 --> 00:27:45,840
however when we came to do this where i

00:27:43,760 --> 00:27:48,240
came to do this in fact for microart

00:27:45,840 --> 00:27:49,600
i thought why not just you know since

00:27:48,240 --> 00:27:51,200
we're going to do

00:27:49,600 --> 00:27:53,039
a state machine that's just going to

00:27:51,200 --> 00:27:55,200
walk through the levels

00:27:53,039 --> 00:27:56,720
and i'm not trying to do a very highly

00:27:55,200 --> 00:27:59,600
optimized

00:27:56,720 --> 00:28:01,600
implementation why don't i make it so

00:27:59,600 --> 00:28:04,799
that it will actually just take

00:28:01,600 --> 00:28:06,080
whatever layout you'd like and just

00:28:04,799 --> 00:28:07,600
process that according to the

00:28:06,080 --> 00:28:08,799
architecture and work out the

00:28:07,600 --> 00:28:12,240
translation

00:28:08,799 --> 00:28:15,120
so i did that so you can have

00:28:12,240 --> 00:28:16,320
any address in any nls value at each

00:28:15,120 --> 00:28:19,440
level of the tree

00:28:16,320 --> 00:28:21,600
between 5 and 16 you can have

00:28:19,440 --> 00:28:23,039
any size for your total address space

00:28:21,600 --> 00:28:26,080
from 31 bits to

00:28:23,039 --> 00:28:28,960
62 bits and any pair of page type

00:28:26,080 --> 00:28:30,880
any pair of two page size that you like

00:28:28,960 --> 00:28:33,120
from 4k outputs

00:28:30,880 --> 00:28:34,559
and that if you work out the math that

00:28:33,120 --> 00:28:36,960
means that you can then

00:28:34,559 --> 00:28:40,080
have any number of levels you like

00:28:36,960 --> 00:28:40,080
between 1 and 10.

00:28:40,320 --> 00:28:48,799
so we did that that

00:28:45,120 --> 00:28:50,399
turned out to be um

00:28:48,799 --> 00:28:52,640
it performed surprisingly well let me

00:28:50,399 --> 00:28:53,200
put it that way so what we did is we

00:28:52,640 --> 00:28:56,080
added

00:28:53,200 --> 00:28:56,960
level one tlbs to instruction and data

00:28:56,080 --> 00:28:59,200
caches

00:28:56,960 --> 00:29:00,159
so these are actually integrated in

00:28:59,200 --> 00:29:02,399
along with the

00:29:00,159 --> 00:29:04,080
cache tag lookup so in parallel with the

00:29:02,399 --> 00:29:06,399
cache tag lookup it's doing

00:29:04,080 --> 00:29:08,159
the tlb lookup and then at the end it's

00:29:06,399 --> 00:29:10,080
comparing the results and saying

00:29:08,159 --> 00:29:12,399
yes we've got a tlb hit that gives us a

00:29:10,080 --> 00:29:13,520
real address we've got a cache hit for

00:29:12,399 --> 00:29:16,640
that real address

00:29:13,520 --> 00:29:19,760
and we can access the cache or maybe not

00:29:16,640 --> 00:29:21,679
and then we get a page fault well

00:29:19,760 --> 00:29:25,039
we don't get a page fault we have to go

00:29:21,679 --> 00:29:28,240
and then ask the mmu to look up the pte

00:29:25,039 --> 00:29:30,640
so that's a fair i mean that that

00:29:28,240 --> 00:29:32,799
looking up the tlb and the cash tags in

00:29:30,640 --> 00:29:34,320
parallel is pretty standard technique

00:29:32,799 --> 00:29:36,000
uh but it meant that we didn't add any

00:29:34,320 --> 00:29:40,159
latency to the cash

00:29:36,000 --> 00:29:44,000
for uh having the address translation

00:29:40,159 --> 00:29:47,360
so we have a 4k 4k byte page size

00:29:44,000 --> 00:29:49,440
in the level one tlbs uh instruction tlb

00:29:47,360 --> 00:29:50,240
is direct mapped it has 64 entries the

00:29:49,440 --> 00:29:52,559
data tlb

00:29:50,240 --> 00:29:54,320
by default is two-way set associative

00:29:52,559 --> 00:29:57,039
with 128 entries

00:29:54,320 --> 00:29:58,080
and then the mmu is a state machine that

00:29:57,039 --> 00:30:00,080
gets kicked off

00:29:58,080 --> 00:30:01,919
when there is a miss in the

00:30:00,080 --> 00:30:04,000
instructional data caches or in fact

00:30:01,919 --> 00:30:05,279
a protection failure also kicks off the

00:30:04,000 --> 00:30:08,240
mmu

00:30:05,279 --> 00:30:09,279
so the mmu actually doesn't do any

00:30:08,240 --> 00:30:12,480
caching

00:30:09,279 --> 00:30:13,279
it just starts well it ca sorry it

00:30:12,480 --> 00:30:15,440
caches the

00:30:13,279 --> 00:30:17,440
process table entry it doesn't cache any

00:30:15,440 --> 00:30:19,840
of the pt's or pdes

00:30:17,440 --> 00:30:21,360
so it it sends a series of requests to

00:30:19,840 --> 00:30:23,200
the data cache

00:30:21,360 --> 00:30:24,480
basically works out an address to you

00:30:23,200 --> 00:30:25,440
know takes the next bit field of the

00:30:24,480 --> 00:30:28,240
address

00:30:25,440 --> 00:30:28,880
works out the address of the pte sends

00:30:28,240 --> 00:30:31,600
that off to the d

00:30:28,880 --> 00:30:32,799
cache gets the value back uses that to

00:30:31,600 --> 00:30:35,200
construct the next address

00:30:32,799 --> 00:30:36,159
eventually it gets to a leaf page table

00:30:35,200 --> 00:30:39,600
entry

00:30:36,159 --> 00:30:40,720
and then it sends that translation that

00:30:39,600 --> 00:30:42,720
it's calculated

00:30:40,720 --> 00:30:45,520
to the d cache or the i cache and then

00:30:42,720 --> 00:30:48,640
the i cache or d cache can

00:30:45,520 --> 00:30:49,520
proceed with the access or in the case

00:30:48,640 --> 00:30:52,080
where

00:30:49,520 --> 00:30:53,520
there was not a valid pte or there was a

00:30:52,080 --> 00:30:56,880
protection failure

00:30:53,520 --> 00:30:58,240
then we trigger a page fault but as i

00:30:56,880 --> 00:31:00,159
said there's no caching of

00:30:58,240 --> 00:31:02,399
page table entries or page directory

00:31:00,159 --> 00:31:05,039
entries in the mmu

00:31:02,399 --> 00:31:06,559
normally with a radix tree walker you

00:31:05,039 --> 00:31:08,000
would have quite a bit of caching

00:31:06,559 --> 00:31:10,080
including a thing called a page walk

00:31:08,000 --> 00:31:10,960
cache which is pretty essential for good

00:31:10,080 --> 00:31:13,679
performance

00:31:10,960 --> 00:31:15,519
we don't have that but still it works it

00:31:13,679 --> 00:31:17,200
performs more or less okay

00:31:15,519 --> 00:31:18,320
and we don't implement the partition

00:31:17,200 --> 00:31:19,679
table because we don't have

00:31:18,320 --> 00:31:22,320
virtualization

00:31:19,679 --> 00:31:25,519
instead we just have a pointer to the

00:31:22,320 --> 00:31:25,519
base of the process table

00:31:26,240 --> 00:31:32,799
okay so that's the mmu now

00:31:29,760 --> 00:31:33,600
the next thing we need is more memory uh

00:31:32,799 --> 00:31:35,360
so

00:31:33,600 --> 00:31:38,000
ben herrera schmidt actually did most of

00:31:35,360 --> 00:31:40,799
this work early last year

00:31:38,000 --> 00:31:41,440
before he got really busy with real work

00:31:40,799 --> 00:31:43,840
so he

00:31:41,440 --> 00:31:45,840
adapted the light dram controller code

00:31:43,840 --> 00:31:49,440
from the lytex project

00:31:45,840 --> 00:31:51,600
because they'd had a light dram that was

00:31:49,440 --> 00:31:52,559
pretty capable and knew how to control

00:31:51,600 --> 00:31:54,960
the

00:31:52,559 --> 00:31:56,720
drams that the sd rams that we have on

00:31:54,960 --> 00:31:59,279
the rt board and that kind of thing

00:31:56,720 --> 00:32:01,200
the rta 7 board that i use has 256

00:31:59,279 --> 00:32:04,320
megabytes of sdram

00:32:01,200 --> 00:32:06,960
and ben also did a level 2 cache

00:32:04,320 --> 00:32:09,519
which is integrated into the interface

00:32:06,960 --> 00:32:12,240
between wishbone and light dram

00:32:09,519 --> 00:32:12,880
so this level 2 cache is actually quite

00:32:12,240 --> 00:32:15,760
nice

00:32:12,880 --> 00:32:17,200
it has a 128-bit interface to the light

00:32:15,760 --> 00:32:20,159
to the

00:32:17,200 --> 00:32:22,000
dram controller that means that we can

00:32:20,159 --> 00:32:22,720
suck data out of memory into the level 2

00:32:22,000 --> 00:32:25,760
cache

00:32:22,720 --> 00:32:26,320
more quickly than if it was 64 bits and

00:32:25,760 --> 00:32:28,080
then it

00:32:26,320 --> 00:32:30,960
supplies the data in 64-bit chunks on

00:32:28,080 --> 00:32:34,559
the wishbone which is 64-bits

00:32:30,960 --> 00:32:37,440
it includes an 8-deep store queue

00:32:34,559 --> 00:32:39,039
and it has 128 byte line size it's

00:32:37,440 --> 00:32:41,360
four-way set associative

00:32:39,039 --> 00:32:42,399
and it's 32k bytes in total it actually

00:32:41,360 --> 00:32:44,000
gave us

00:32:42,399 --> 00:32:47,279
that this level two cache gave us quite

00:32:44,000 --> 00:32:47,279
a good performance improvement

00:32:47,600 --> 00:32:51,919
next the floating point unit um why do a

00:32:50,559 --> 00:32:53,919
floating point unit well

00:32:51,919 --> 00:32:55,440
it's it's in the architecture you don't

00:32:53,919 --> 00:32:58,399
have to do it but it's there so i

00:32:55,440 --> 00:33:00,399
thought it would be interesting

00:32:58,399 --> 00:33:04,000
more particularly we don't want to have

00:33:00,399 --> 00:33:07,440
to define a soft float abi

00:33:04,000 --> 00:33:09,919
we did have that in the old days of

00:33:07,440 --> 00:33:12,320
embedded 32-bit power pc and it just

00:33:09,919 --> 00:33:14,240
fragments your ecosystem and

00:33:12,320 --> 00:33:16,000
makes it harder to have compatibility if

00:33:14,240 --> 00:33:18,559
you code and that kind of thing

00:33:16,000 --> 00:33:20,480
so i thought let's try and make a

00:33:18,559 --> 00:33:23,519
floating point unit that

00:33:20,480 --> 00:33:25,360
implements the architecture

00:33:23,519 --> 00:33:27,039
it's fairly simple doesn't have to be

00:33:25,360 --> 00:33:27,440
blindingly fast doesn't want to be you

00:33:27,039 --> 00:33:29,840
know

00:33:27,440 --> 00:33:31,679
glacially slow either but let's see how

00:33:29,840 --> 00:33:34,790
small we can make it

00:33:31,679 --> 00:33:35,919
so then what are the difficulties well

00:33:34,790 --> 00:33:37,519
[Music]

00:33:35,919 --> 00:33:38,640
you know you have things like divide

00:33:37,519 --> 00:33:40,480
instructions and square root

00:33:38,640 --> 00:33:43,200
instructions in the architecture

00:33:40,480 --> 00:33:44,320
how do you do a division efficiently

00:33:43,200 --> 00:33:46,480
turns out that there are interesting

00:33:44,320 --> 00:33:49,600
numerical techniques that you can use

00:33:46,480 --> 00:33:52,720
particularly for things like square root

00:33:49,600 --> 00:33:54,240
things like newton-raphson iterations to

00:33:52,720 --> 00:33:56,960
refine estimates of

00:33:54,240 --> 00:33:58,240
reciprocals and and you can do one on

00:33:56,960 --> 00:34:00,399
square root of x

00:33:58,240 --> 00:34:01,919
estimates as well and there's a thing

00:34:00,399 --> 00:34:04,080
called i think the goldschmidt algorithm

00:34:01,919 --> 00:34:04,080
that

00:34:04,480 --> 00:34:07,600
iteratively gets you better and better

00:34:06,480 --> 00:34:10,079
approximations to

00:34:07,600 --> 00:34:11,599
square root and inverse square root

00:34:10,079 --> 00:34:12,879
there's also fused multiply add

00:34:11,599 --> 00:34:14,879
instructions

00:34:12,879 --> 00:34:17,119
you have to handle denormalized numbers

00:34:14,879 --> 00:34:18,480
and exception conditions correctly

00:34:17,119 --> 00:34:20,639
and all of this is specified in the

00:34:18,480 --> 00:34:22,560
architecture quite specifically

00:34:20,639 --> 00:34:24,240
and you need to get the right result

00:34:22,560 --> 00:34:25,679
down to the last bit in all rounding

00:34:24,240 --> 00:34:27,520
modes

00:34:25,679 --> 00:34:29,280
you know you have round to minus

00:34:27,520 --> 00:34:32,560
infinity round to zero

00:34:29,280 --> 00:34:35,760
round to plus infinity round to nearest

00:34:32,560 --> 00:34:37,119
so i did at fpu using a state machine

00:34:35,760 --> 00:34:38,639
for the control

00:34:37,119 --> 00:34:40,480
it only handles one instruction at a

00:34:38,639 --> 00:34:42,240
time it's not pipelined

00:34:40,480 --> 00:34:45,119
it ended up using about four and a half

00:34:42,240 --> 00:34:46,960
thousand luts on the xilinx arctic seven

00:34:45,119 --> 00:34:49,119
which is about twenty percent of the

00:34:46,960 --> 00:34:53,040
total system that we have at the moment

00:34:49,119 --> 00:34:56,079
or seven percent of the a7 100 part

00:34:53,040 --> 00:34:57,839
and you know add subtract take five to

00:34:56,079 --> 00:35:00,160
12 cycles it's not

00:34:57,839 --> 00:35:03,440
as i said not blindingly fast but it's a

00:35:00,160 --> 00:35:05,839
lot quicker than emulating

00:35:03,440 --> 00:35:07,839
here's a diagram very much simplified of

00:35:05,839 --> 00:35:09,599
the data paths

00:35:07,839 --> 00:35:12,160
it took me a long time to actually work

00:35:09,599 --> 00:35:13,200
out how to organize this in such a way

00:35:12,160 --> 00:35:14,839
that we could

00:35:13,200 --> 00:35:17,119
do everything we wanted reasonably

00:35:14,839 --> 00:35:18,880
efficiently

00:35:17,119 --> 00:35:20,160
but without using any more resources and

00:35:18,880 --> 00:35:22,400
we really need to

00:35:20,160 --> 00:35:24,000
and and you know we have the three input

00:35:22,400 --> 00:35:25,520
registers here because we need three

00:35:24,000 --> 00:35:28,079
input registers because we have flooding

00:35:25,520 --> 00:35:30,960
multiply add instructions

00:35:28,079 --> 00:35:33,119
they're interesting because you can you

00:35:30,960 --> 00:35:35,280
know you're doing a times b plus c

00:35:33,119 --> 00:35:36,400
but it could be that a times v b is very

00:35:35,280 --> 00:35:39,599
close in

00:35:36,400 --> 00:35:40,400
value but opposite in sign to c so that

00:35:39,599 --> 00:35:43,520
the result

00:35:40,400 --> 00:35:46,560
is very close to zero and you have to

00:35:43,520 --> 00:35:47,760
preserve those low order bits um and and

00:35:46,560 --> 00:35:49,520
the floating point multiplier

00:35:47,760 --> 00:35:52,079
instructions are defined

00:35:49,520 --> 00:35:53,760
such that you do get a high resolution

00:35:52,079 --> 00:35:54,640
intermediate product that then lets you

00:35:53,760 --> 00:35:57,200
get those

00:35:54,640 --> 00:35:59,119
low order bits accurately so we have

00:35:57,200 --> 00:36:01,040
these input registers we have a lookup

00:35:59,119 --> 00:36:03,200
table that we use for getting

00:36:01,040 --> 00:36:04,960
uh inverse estimates and inverse square

00:36:03,200 --> 00:36:07,359
root estimates

00:36:04,960 --> 00:36:09,040
we have a thing that can do addition and

00:36:07,359 --> 00:36:12,000
subtraction

00:36:09,040 --> 00:36:13,280
and a few other things and then we have

00:36:12,000 --> 00:36:17,599
a multiply adder

00:36:13,280 --> 00:36:19,440
64 by 64 plus 128 multiply add

00:36:17,599 --> 00:36:20,960
those results basically go into this r

00:36:19,440 --> 00:36:22,960
for result register

00:36:20,960 --> 00:36:24,640
we have this s is kind of an extension

00:36:22,960 --> 00:36:26,000
to the r for the lower bits of the

00:36:24,640 --> 00:36:28,320
product here

00:36:26,000 --> 00:36:29,680
and then we have p and y which are

00:36:28,320 --> 00:36:32,079
involved in the

00:36:29,680 --> 00:36:34,000
iterative algorithms for divide and

00:36:32,079 --> 00:36:35,599
square root so they do

00:36:34,000 --> 00:36:37,040
that they let you do the iterations of

00:36:35,599 --> 00:36:38,320
the newton-raphson or goldschmidt

00:36:37,040 --> 00:36:41,040
algorithm

00:36:38,320 --> 00:36:42,480
then we have a thing that can count the

00:36:41,040 --> 00:36:44,880
number of zeros at the left hand end of

00:36:42,480 --> 00:36:47,359
a word so that you can do normalization

00:36:44,880 --> 00:36:48,640
we have a a register that stores that

00:36:47,359 --> 00:36:50,720
and then we have a shifter

00:36:48,640 --> 00:36:53,040
and so we can put values into r we can

00:36:50,720 --> 00:36:55,359
shift them we can add things on

00:36:53,040 --> 00:36:57,040
or we can give constant values like

00:36:55,359 --> 00:37:00,400
infinities and so forth

00:36:57,040 --> 00:37:00,400
and then we send that to right bank

00:37:01,520 --> 00:37:05,920
another interesting thing that we added

00:37:03,599 --> 00:37:07,200
to microwatt is a hardware random number

00:37:05,920 --> 00:37:09,599
generator

00:37:07,200 --> 00:37:12,560
there is an instruction called dhan that

00:37:09,599 --> 00:37:14,000
stands for deliver a random number

00:37:12,560 --> 00:37:15,599
i'm sure someone was very pleased with

00:37:14,000 --> 00:37:16,320
themselves when they thought of that

00:37:15,599 --> 00:37:18,960
acronym

00:37:16,320 --> 00:37:19,599
so the dhan instruction can return

00:37:18,960 --> 00:37:22,400
either raw

00:37:19,599 --> 00:37:23,200
or conditioned random numbers and i went

00:37:22,400 --> 00:37:25,119
looking on

00:37:23,200 --> 00:37:26,240
on the web and i found a paper by

00:37:25,119 --> 00:37:29,040
catelyn

00:37:26,240 --> 00:37:30,880
petoniu called high speed true random

00:37:29,040 --> 00:37:32,480
number generators in silence fpgas it

00:37:30,880 --> 00:37:34,720
sounded like just the ticket

00:37:32,480 --> 00:37:36,640
and indeed it turns out to be a very

00:37:34,720 --> 00:37:38,240
interesting circuit we have

00:37:36,640 --> 00:37:40,320
this set of coupled ring oscillators

00:37:38,240 --> 00:37:42,880
here these are exclusive or gates

00:37:40,320 --> 00:37:44,079
and what each one is doing is it's uh

00:37:42,880 --> 00:37:46,320
xoring itself

00:37:44,079 --> 00:37:47,440
and its two neighbors and and it wraps

00:37:46,320 --> 00:37:49,280
around as a ring

00:37:47,440 --> 00:37:50,640
and then just to ensure that there isn't

00:37:49,280 --> 00:37:52,400
a stable state this

00:37:50,640 --> 00:37:55,359
this xor on the left one of them has got

00:37:52,400 --> 00:37:58,960
a inversion so that's an exclusive nor

00:37:55,359 --> 00:38:00,079
so this is all completely unstable and

00:37:58,960 --> 00:38:03,359
completely impossible

00:38:00,079 --> 00:38:05,440
for the tools to analyze the timing of

00:38:03,359 --> 00:38:07,440
because there's no stable state they

00:38:05,440 --> 00:38:09,200
basically all just oscillate chaotically

00:38:07,440 --> 00:38:10,560
at gigahertz speeds

00:38:09,200 --> 00:38:12,880
and then you put that through a register

00:38:10,560 --> 00:38:14,720
that samples at your clock rate which in

00:38:12,880 --> 00:38:16,720
our case is 100 megahertz

00:38:14,720 --> 00:38:18,079
and you get actually pretty nice random

00:38:16,720 --> 00:38:19,920
numbers out of here

00:38:18,079 --> 00:38:22,400
and the done instruction can read from

00:38:19,920 --> 00:38:24,720
this level here after this top

00:38:22,400 --> 00:38:26,720
just a couple ring oscillators or it can

00:38:24,720 --> 00:38:29,680
read these conditioned ones out of the

00:38:26,720 --> 00:38:30,000
linear hybrid cellular automaton which

00:38:29,680 --> 00:38:33,359
is

00:38:30,000 --> 00:38:36,320
a kind of relation of a

00:38:33,359 --> 00:38:36,800
linear feedback shift register and lfsr

00:38:36,320 --> 00:38:40,400
these

00:38:36,800 --> 00:38:41,520
dn things should be shown as and gates

00:38:40,400 --> 00:38:43,760
really

00:38:41,520 --> 00:38:44,640
because you either put zero in or you

00:38:43,760 --> 00:38:47,040
put the

00:38:44,640 --> 00:38:48,720
the value from that register in and that

00:38:47,040 --> 00:38:49,440
defines a polynomial that then defines

00:38:48,720 --> 00:38:51,040
the behavior

00:38:49,440 --> 00:38:52,400
but it's all in that paper there and i

00:38:51,040 --> 00:38:53,359
basically just implemented what was in

00:38:52,400 --> 00:38:55,520
the paper

00:38:53,359 --> 00:38:58,000
and it generates really nice hardware

00:38:55,520 --> 00:39:01,599
random numbers

00:38:58,000 --> 00:39:03,599
so then we hacked up the kernel um

00:39:01,599 --> 00:39:05,040
i'm running out of time so i'll proceed

00:39:03,599 --> 00:39:07,680
pretty quickly here

00:39:05,040 --> 00:39:08,560
um we defined a new microwatt platform

00:39:07,680 --> 00:39:12,160
which

00:39:08,560 --> 00:39:13,680
longer term we probably don't want to do

00:39:12,160 --> 00:39:15,920
we'd probably like to be able to use the

00:39:13,680 --> 00:39:18,240
parent v platform but to do that

00:39:15,920 --> 00:39:20,800
we'd need to port opel the opel firmware

00:39:18,240 --> 00:39:22,000
to microwave now opal is open source

00:39:20,800 --> 00:39:23,920
there's nothing stopping us from doing

00:39:22,000 --> 00:39:26,240
that except you know time and

00:39:23,920 --> 00:39:27,359
energy that kind of thing there are some

00:39:26,240 --> 00:39:29,839
other patches that we

00:39:27,359 --> 00:39:30,720
added including the the light ethe

00:39:29,839 --> 00:39:34,000
driver

00:39:30,720 --> 00:39:35,359
and we constructed a device tree by hand

00:39:34,000 --> 00:39:36,960
this describes

00:39:35,359 --> 00:39:38,960
cpus memory interrupt controller

00:39:36,960 --> 00:39:41,359
peripherals etc

00:39:38,960 --> 00:39:42,560
we create a dtb image and we put that in

00:39:41,359 --> 00:39:45,119
spi flash

00:39:42,560 --> 00:39:45,680
we have console on serial port and then

00:39:45,119 --> 00:39:48,720
either

00:39:45,680 --> 00:39:51,280
a ram disk or an nfs route and

00:39:48,720 --> 00:39:52,560
the stuff the the code is all there and

00:39:51,280 --> 00:39:57,520
in ben's branch although

00:39:52,560 --> 00:40:01,520
he hasn't updated it recently

00:39:57,520 --> 00:40:02,960
so what can we use it for well uh

00:40:01,520 --> 00:40:04,560
one of the things that we're looking at

00:40:02,960 --> 00:40:06,240
is doing a baseboard management

00:40:04,560 --> 00:40:10,000
controller with it

00:40:06,240 --> 00:40:13,440
and we're going to replace the bmc

00:40:10,000 --> 00:40:16,640
in a power9 server with one of these

00:40:13,440 --> 00:40:18,480
rda7 boards with an adapter and

00:40:16,640 --> 00:40:20,400
you know we want to find out is

00:40:18,480 --> 00:40:22,880
microwatts small enough fast enough to

00:40:20,400 --> 00:40:25,200
be practical

00:40:22,880 --> 00:40:27,119
and and just demonstrate that it it can

00:40:25,200 --> 00:40:29,280
be done and it and it can work

00:40:27,119 --> 00:40:30,960
reptile engineering as hugh mentioned in

00:40:29,280 --> 00:40:34,079
his talk has got a similar

00:40:30,960 --> 00:40:36,160
project underway the kestrel project and

00:40:34,079 --> 00:40:38,000
uh we're doing something fairly similar

00:40:36,160 --> 00:40:41,359
they're in fact also using the morocco

00:40:38,000 --> 00:40:43,200
core but

00:40:41,359 --> 00:40:45,920
you know we will probably have a full

00:40:43,200 --> 00:40:49,200
linux running

00:40:45,920 --> 00:40:52,480
underneath it okay

00:40:49,200 --> 00:40:56,000
what else can we do well there's

00:40:52,480 --> 00:40:58,160
a chip this is a picture of

00:40:56,000 --> 00:41:00,079
uh what anton's been working on for

00:40:58,160 --> 00:41:04,480
about the last month or so

00:41:00,079 --> 00:41:04,480
um if i just go to

00:41:05,359 --> 00:41:11,920
here this is a description of

00:41:09,040 --> 00:41:13,839
the openmpw shuttle program this is

00:41:11,920 --> 00:41:15,119
sponsored paid for by google

00:41:13,839 --> 00:41:16,480
basically what they're doing is they're

00:41:15,119 --> 00:41:17,680
saying if you have an open source

00:41:16,480 --> 00:41:20,160
hardware design

00:41:17,680 --> 00:41:21,440
you can get it put onto a chip and we

00:41:20,160 --> 00:41:23,040
will make the chip

00:41:21,440 --> 00:41:24,800
it's an old technology it's 130

00:41:23,040 --> 00:41:26,800
nanometers

00:41:24,800 --> 00:41:34,480
but it's a chip it's a real chip so

00:41:26,800 --> 00:41:37,200
that's what anton's been working on

00:41:34,480 --> 00:41:39,119
and where next well there are a number

00:41:37,200 --> 00:41:42,240
of things that we'd like to do

00:41:39,119 --> 00:41:44,480
um 32-bit

00:41:42,240 --> 00:41:46,640
add a vector unit at a performance

00:41:44,480 --> 00:41:48,640
monitor do smp

00:41:46,640 --> 00:41:50,240
add hypervisor mode eventually we'd like

00:41:48,640 --> 00:41:53,040
to get to actually implementing

00:41:50,240 --> 00:41:55,200
the complete architecture and see if we

00:41:53,040 --> 00:41:59,040
can do that in a modest site

00:41:55,200 --> 00:42:02,720
fpga finally what i'd like to do

00:41:59,040 --> 00:42:07,839
is just demonstrate linux booting

00:42:02,720 --> 00:42:12,000
on on my little rda7 here

00:42:07,839 --> 00:42:17,280
so what i'm going to do is i'm going to

00:42:12,000 --> 00:42:19,839
run a command that this xc3sp prog

00:42:17,280 --> 00:42:21,280
it's going to load a bit stream that i

00:42:19,839 --> 00:42:24,319
compiled earlier

00:42:21,280 --> 00:42:26,000
onto the onto that rda7 board

00:42:24,319 --> 00:42:27,720
and so i do that and then i'm going to

00:42:26,000 --> 00:42:30,800
run minicom which will connect to the

00:42:27,720 --> 00:42:33,200
serial um

00:42:30,800 --> 00:42:34,560
and we see some boot messages we're

00:42:33,200 --> 00:42:38,160
decompressing the kernel

00:42:34,560 --> 00:42:40,560
we're booting linux um

00:42:38,160 --> 00:42:42,560
now i'm using an nfs route here so

00:42:40,560 --> 00:42:44,720
basically the pause here is that it's

00:42:42,560 --> 00:42:46,720
fetching a whole pile of stuff over nfs

00:42:44,720 --> 00:42:48,000
and it's the the ethernet is 100 megabit

00:42:46,720 --> 00:42:50,319
not gigabit so

00:42:48,000 --> 00:42:51,920
a little bit of latency there but i mean

00:42:50,319 --> 00:42:56,400
that makes it easy for

00:42:51,920 --> 00:42:59,920
um it makes it easy for setting up

00:42:56,400 --> 00:43:02,960
and also recovering if the thing crashes

00:42:59,920 --> 00:43:06,160
so i can log in i can cat

00:43:02,960 --> 00:43:09,280
proc cpu info um

00:43:06,160 --> 00:43:12,640
there it is microwater 100 megahertz and

00:43:09,280 --> 00:43:14,079
i can do free i've got 56 gigs of memory

00:43:12,640 --> 00:43:17,520
minus a bit

00:43:14,079 --> 00:43:20,800
and so there we are linux running

00:43:17,520 --> 00:43:24,720
on that board so

00:43:20,800 --> 00:43:24,720
thank you very much do we have questions

00:43:24,800 --> 00:43:29,359
all right thank you paul we have quite a

00:43:27,520 --> 00:43:30,480
few questions in the list but i'm

00:43:29,359 --> 00:43:34,000
expecting that

00:43:30,480 --> 00:43:37,680
we only have time to answer one of them

00:43:34,000 --> 00:43:40,480
uh so because we have two minutes left

00:43:37,680 --> 00:43:42,480
so um here is one of the questions from

00:43:40,480 --> 00:43:44,240
earlier in your talk

00:43:42,480 --> 00:43:46,000
you have adopted good software

00:43:44,240 --> 00:43:48,160
engineering testing and iterative

00:43:46,000 --> 00:43:50,560
improvements with changes being tested

00:43:48,160 --> 00:43:52,560
have you seen any cpu designers from

00:43:50,560 --> 00:43:54,319
other areas watching your project

00:43:52,560 --> 00:43:57,119
adopt any of this to improve their own

00:43:54,319 --> 00:43:57,119
processes yet

00:43:57,440 --> 00:44:01,520
yeah that's a good question it's a

00:43:59,359 --> 00:44:05,200
little hard to say

00:44:01,520 --> 00:44:06,160
um certainly people like the libre sock

00:44:05,200 --> 00:44:08,960
process

00:44:06,160 --> 00:44:10,400
team are also using good software

00:44:08,960 --> 00:44:11,599
engineering practices but i wouldn't say

00:44:10,400 --> 00:44:12,720
that they necessarily got it from

00:44:11,599 --> 00:44:15,280
microsoft

00:44:12,720 --> 00:44:16,240
in terms of do i know of any hardware

00:44:15,280 --> 00:44:19,920
engineer who's

00:44:16,240 --> 00:44:21,680
uh reformed his ways um yes i think i

00:44:19,920 --> 00:44:24,720
mean that the guy that

00:44:21,680 --> 00:44:26,240
has been pushing the a2i and a20 cores i

00:44:24,720 --> 00:44:28,560
think has been starting to adopt some of

00:44:26,240 --> 00:44:32,240
these practices

00:44:28,560 --> 00:44:33,040
that's great um i think probably most of

00:44:32,240 --> 00:44:36,400
the other

00:44:33,040 --> 00:44:38,160
oh here we go let's do this one is the

00:44:36,400 --> 00:44:40,079
hardware random number generator

00:44:38,160 --> 00:44:42,720
suitable for use in programs where

00:44:40,079 --> 00:44:45,839
security is important

00:44:42,720 --> 00:44:47,200
i think so um i think that using a

00:44:45,839 --> 00:44:47,599
hardware random number generator like

00:44:47,200 --> 00:44:51,040
that

00:44:47,599 --> 00:44:52,079
uh in that you can actually see the

00:44:51,040 --> 00:44:54,160
source for

00:44:52,079 --> 00:44:56,160
and you can you can verify particularly

00:44:54,160 --> 00:44:58,160
if you're using an open tool chain

00:44:56,160 --> 00:44:59,359
that that's how the random numbers are

00:44:58,160 --> 00:45:00,880
generated that they're not being

00:44:59,359 --> 00:45:02,160
backdoored by something in the chip that

00:45:00,880 --> 00:45:03,520
you don't know about

00:45:02,160 --> 00:45:05,200
that in fact would be excellent for

00:45:03,520 --> 00:45:07,200
security and

00:45:05,200 --> 00:45:08,640
in fact i've run the full suite of die

00:45:07,200 --> 00:45:11,520
harder tests on it

00:45:08,640 --> 00:45:12,079
and you know it passed everything now of

00:45:11,520 --> 00:45:14,800
course

00:45:12,079 --> 00:45:15,200
with the die harder tests one or two you

00:45:14,800 --> 00:45:17,599
get

00:45:15,200 --> 00:45:18,480
that say oh this is a weak result but

00:45:17,599 --> 00:45:20,319
then that's just the

00:45:18,480 --> 00:45:22,079
nature of random numbers that if you

00:45:20,319 --> 00:45:23,760
didn't get any weak results that would

00:45:22,079 --> 00:45:26,000
mean that your random number generator

00:45:23,760 --> 00:45:28,560
actually wasn't very good

00:45:26,000 --> 00:45:30,400
which is a bit paradoxical but you know

00:45:28,560 --> 00:45:32,000
those ones that it says a week

00:45:30,400 --> 00:45:33,839
you run the test again and it says no

00:45:32,000 --> 00:45:34,960
that's a strong result so it was just a

00:45:33,839 --> 00:45:37,200
random fluctuation

00:45:34,960 --> 00:45:38,240
but yes i have run the entire die harder

00:45:37,200 --> 00:45:41,599
test suite and

00:45:38,240 --> 00:45:45,359
and it all looks really good and it only

00:45:41,599 --> 00:45:48,160
uses like 128 luts it's really tiny

00:45:45,359 --> 00:45:49,119
great okay we're out of time there are

00:45:48,160 --> 00:45:52,319
more questions

00:45:49,119 --> 00:45:56,800
asked in the chat so what we'll do is

00:45:52,319 --> 00:45:58,720
ask you paul um to and everybody who's

00:45:56,800 --> 00:46:00,240
in the audience who'd like to join in to

00:45:58,720 --> 00:46:04,000
head over to the

00:46:00,240 --> 00:46:04,640
post post talk q a channel for tux

00:46:04,000 --> 00:46:06,960
theater

00:46:04,640 --> 00:46:08,640
it's in venulis if you haven't accessed

00:46:06,960 --> 00:46:10,480
it before it's in the sidebar on the

00:46:08,640 --> 00:46:11,119
left you may have to click browse all

00:46:10,480 --> 00:46:14,000
channels

00:46:11,119 --> 00:46:15,599
and find tux theater post talk q a and

00:46:14,000 --> 00:46:17,920
those questions that we didn't have time

00:46:15,599 --> 00:46:20,880
to ask live i will paste them into that

00:46:17,920 --> 00:46:22,560
channel for you it's now afternoon tea

00:46:20,880 --> 00:46:23,760
time i believe i just have to double

00:46:22,560 --> 00:46:25,920
check the schedule yes

00:46:23,760 --> 00:46:27,680
afternoon tea time enjoy your afternoon

00:46:25,920 --> 00:46:29,520
tea everyone and we'll see you back

00:46:27,680 --> 00:46:33,839
later

00:46:29,520 --> 00:46:33,839

YouTube URL: https://www.youtube.com/watch?v=SO8a8zcAiZc


