Title: "What even is code? Building a non-code coding interface" - Katie Bell (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Katie Bell

https://lca2021.linux.org.au/schedule/presentation/45/

I confess, I hate writing code in text files. I hate dealing with syntax errors, carefully matching brackets, style rules, line-by-line git diffs and tiny character-specific cursor movements. That's why I set out on an epic quest to build a coding interface with no bracket matching, no syntax errors and no whitespace â€” but it still has to be fast to edit, keyboard controlled and can't sprawl spaghetti lines across the screen.

Not possible you say? Well you might be right, but I'm damn well going to try. Over the last year I've built a series of mocks and prototypes and every one of them has taught me something fascinating as I slowly grow closer to the goal. Join me on my exploration of what code even is and how human language influences how we think about code.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Mon Jan 25 11:40:00 2021 at Rusty R. Hall
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,200 --> 00:00:20,240
next we are excited to have katie bell

00:00:17,520 --> 00:00:21,039
presenting what even is code building a

00:00:20,240 --> 00:00:23,279
non-code

00:00:21,039 --> 00:00:25,039
coding interface so just a little bit

00:00:23,279 --> 00:00:26,720
about katie she has

00:00:25,039 --> 00:00:28,080
more than 10 years experience as a

00:00:26,720 --> 00:00:30,160
professional developer

00:00:28,080 --> 00:00:32,160
working across companies such as google

00:00:30,160 --> 00:00:34,000
grok learning and campaign monitor

00:00:32,160 --> 00:00:36,000
she's also volunteered in education to

00:00:34,000 --> 00:00:38,640
help rookie coders get started which

00:00:36,000 --> 00:00:39,600
i really appreciate today she's going to

00:00:38,640 --> 00:00:41,200
talk

00:00:39,600 --> 00:00:43,120
about her quest to build a coding

00:00:41,200 --> 00:00:44,079
interface with no bracket matching no

00:00:43,120 --> 00:00:45,760
syntax errors

00:00:44,079 --> 00:00:47,680
and no white space and share her

00:00:45,760 --> 00:00:50,559
explanation of what code even is

00:00:47,680 --> 00:00:51,680
and how human language influences how we

00:00:50,559 --> 00:00:53,360
think about it

00:00:51,680 --> 00:00:55,280
just a reminder that katie will be

00:00:53,360 --> 00:00:56,320
taking questions at the end of this

00:00:55,280 --> 00:00:58,160
presentation

00:00:56,320 --> 00:00:59,760
so post your questions in the venulis

00:00:58,160 --> 00:01:02,879
chat and we'll get to them at the end

00:00:59,760 --> 00:01:04,239
over to you katie awesome thanks all

00:01:02,879 --> 00:01:05,840
right so what are we going to talk about

00:01:04,239 --> 00:01:08,880
going to talk about what even

00:01:05,840 --> 00:01:11,680
is code and so

00:01:08,880 --> 00:01:12,720
here is some code this is some simple

00:01:11,680 --> 00:01:14,240
javascript code

00:01:12,720 --> 00:01:16,080
and the thing about the way that we do

00:01:14,240 --> 00:01:17,040
code is that it hasn't really changed

00:01:16,080 --> 00:01:20,000
very much

00:01:17,040 --> 00:01:21,840
uh since the 70s when you know c was

00:01:20,000 --> 00:01:22,720
developed it was influenced by languages

00:01:21,840 --> 00:01:25,759
before that

00:01:22,720 --> 00:01:27,840
but the syntax hasn't changed that much

00:01:25,759 --> 00:01:30,320
and the way that we code fundamentally

00:01:27,840 --> 00:01:32,159
hasn't changed that much in that time

00:01:30,320 --> 00:01:35,520
and regardless of whether you're using

00:01:32,159 --> 00:01:37,600
a notepad or vim or emacs or some kind

00:01:35,520 --> 00:01:40,000
of sophisticated ide

00:01:37,600 --> 00:01:42,159
fundamentally we're still writing code

00:01:40,000 --> 00:01:45,360
by entering the same sets of

00:01:42,159 --> 00:01:47,600
punctuation characters words and symbols

00:01:45,360 --> 00:01:49,520
into a text file that is then stored as

00:01:47,600 --> 00:01:52,960
a text file and handed over to

00:01:49,520 --> 00:01:55,119
like a parser interpreter or compiler

00:01:52,960 --> 00:01:56,799
and why do we why do we do it this way

00:01:55,119 --> 00:01:59,600
why have we been doing this way

00:01:56,799 --> 00:02:01,439
doing it this way since the 70s and it's

00:01:59,600 --> 00:02:03,520
largely because we're used to it

00:02:01,439 --> 00:02:04,640
even if someone develops a new

00:02:03,520 --> 00:02:06,640
programming language

00:02:04,640 --> 00:02:08,080
they typically just keep using the same

00:02:06,640 --> 00:02:10,160
structures and syntax

00:02:08,080 --> 00:02:11,840
that people are already familiar with

00:02:10,160 --> 00:02:12,959
because then it's easier for developers

00:02:11,840 --> 00:02:14,720
to pick up

00:02:12,959 --> 00:02:16,080
and when you like me have been coding

00:02:14,720 --> 00:02:18,879
for a long time

00:02:16,080 --> 00:02:21,120
it starts to feel really natural and you

00:02:18,879 --> 00:02:23,360
don't necessarily realize

00:02:21,120 --> 00:02:25,440
what you have done and how much you have

00:02:23,360 --> 00:02:28,560
learned to get to that point

00:02:25,440 --> 00:02:31,599
because writing code in a text file

00:02:28,560 --> 00:02:32,400
actually forces you to remember a lot of

00:02:31,599 --> 00:02:33,920
things

00:02:32,400 --> 00:02:36,400
and when you're starting out and you

00:02:33,920 --> 00:02:38,400
don't already know those things it has a

00:02:36,400 --> 00:02:40,239
really difficult learning curve because

00:02:38,400 --> 00:02:42,959
there is so much stuff

00:02:40,239 --> 00:02:45,360
that isn't necessarily intuitive and you

00:02:42,959 --> 00:02:48,879
just have to remember it

00:02:45,360 --> 00:02:51,280
so starting with punctuation symbols

00:02:48,879 --> 00:02:52,720
we use these throughout our code and we

00:02:51,280 --> 00:02:55,760
typically use punctuation

00:02:52,720 --> 00:02:57,760
and these symbols in a way that is not

00:02:55,760 --> 00:02:59,040
intuitive if the only thing you've ever

00:02:57,760 --> 00:02:59,519
done before which is what most people

00:02:59,040 --> 00:03:01,840
have done

00:02:59,519 --> 00:03:03,760
is english or whatever language you've

00:03:01,840 --> 00:03:05,360
learned plus mathematics

00:03:03,760 --> 00:03:07,840
in coding we use these symbols in

00:03:05,360 --> 00:03:10,080
entirely new and unexpected ways

00:03:07,840 --> 00:03:12,000
and you just have to learn what they

00:03:10,080 --> 00:03:14,000
mean you have to learn what they mean

00:03:12,000 --> 00:03:15,760
in order to read code and especially if

00:03:14,000 --> 00:03:17,680
you want to write code

00:03:15,760 --> 00:03:19,760
and these symbols we have a limited

00:03:17,680 --> 00:03:20,480
number of symbols available to us on the

00:03:19,760 --> 00:03:22,959
keyboard

00:03:20,480 --> 00:03:24,959
that are easy to type and so we tend to

00:03:22,959 --> 00:03:26,879
overload those symbols and use them for

00:03:24,959 --> 00:03:28,000
multiple purposes in any particular

00:03:26,879 --> 00:03:30,720
language

00:03:28,000 --> 00:03:32,159
so as an example in javascript you can

00:03:30,720 --> 00:03:34,560
use curly braces to

00:03:32,159 --> 00:03:36,799
define a new object you also use curly

00:03:34,560 --> 00:03:38,640
braces to define a block of code for a

00:03:36,799 --> 00:03:41,920
function or an if statement

00:03:38,640 --> 00:03:45,120
you also use curly braces to destruct an

00:03:41,920 --> 00:03:46,560
object or to insert a variable into a

00:03:45,120 --> 00:03:49,920
template string

00:03:46,560 --> 00:03:52,319
and again multiple uses of the same

00:03:49,920 --> 00:03:54,560
symbols in different contexts it's not

00:03:52,319 --> 00:03:56,400
ambiguous but you do have to learn

00:03:54,560 --> 00:03:58,799
each one of these different uses to be

00:03:56,400 --> 00:04:00,799
able to read code

00:03:58,799 --> 00:04:02,319
on top of that even once you've learned

00:04:00,799 --> 00:04:04,480
the syntax to a language

00:04:02,319 --> 00:04:06,480
you might find that there are extra

00:04:04,480 --> 00:04:08,640
hidden things that you only encounter

00:04:06,480 --> 00:04:09,519
sometimes that again you just have to

00:04:08,640 --> 00:04:11,439
learn or

00:04:09,519 --> 00:04:13,360
look up on stack overflow over and over

00:04:11,439 --> 00:04:15,920
again you might already know that in

00:04:13,360 --> 00:04:16,799
javascript a string is delineated with

00:04:15,920 --> 00:04:18,400
quote marks

00:04:16,799 --> 00:04:20,320
but then one day you'd find you have to

00:04:18,400 --> 00:04:22,400
write a quote mark inside the string

00:04:20,320 --> 00:04:24,320
or a new line or a slash and you have to

00:04:22,400 --> 00:04:26,160
learn the escaping rules for that

00:04:24,320 --> 00:04:28,240
html is particularly annoying for this

00:04:26,160 --> 00:04:31,360
because the escaping rules mean typing

00:04:28,240 --> 00:04:32,880
ampersand gt semicolon in order to type

00:04:31,360 --> 00:04:34,800
a greater than symbol

00:04:32,880 --> 00:04:38,400
just so that it doesn't accidentally get

00:04:34,800 --> 00:04:40,560
interpreted as part of the code

00:04:38,400 --> 00:04:42,880
on top of that you also need to learn

00:04:40,560 --> 00:04:44,800
operator precedence rules to be able to

00:04:42,880 --> 00:04:46,800
understand what the code is going to do

00:04:44,800 --> 00:04:48,479
and some rules are things like

00:04:46,800 --> 00:04:50,960
multiplication comes before

00:04:48,479 --> 00:04:52,320
an addition operation and that's fine

00:04:50,960 --> 00:04:54,240
people learn that in school

00:04:52,320 --> 00:04:55,840
people learn that in primary school they

00:04:54,240 --> 00:04:57,280
later learn that again in high school it

00:04:55,840 --> 00:04:59,199
kind of gets drilled into you

00:04:57,280 --> 00:05:01,840
it's not that weird for people to pick

00:04:59,199 --> 00:05:05,199
up basic operator principles

00:05:01,840 --> 00:05:05,840
like a basic operator precedence but in

00:05:05,199 --> 00:05:08,240
code

00:05:05,840 --> 00:05:10,240
we take that to another step and add

00:05:08,240 --> 00:05:12,160
many more operators than the ones that

00:05:10,240 --> 00:05:15,039
you would use in high school

00:05:12,160 --> 00:05:16,160
and you start to find that our you have

00:05:15,039 --> 00:05:18,800
an or operator

00:05:16,160 --> 00:05:20,479
and an and operator and a beginner coder

00:05:18,800 --> 00:05:23,039
isn't going to know

00:05:20,479 --> 00:05:25,039
that an and operator takes precedence

00:05:23,039 --> 00:05:26,880
over an ore operator so that bit gets

00:05:25,039 --> 00:05:28,560
evaluated first if you've done

00:05:26,880 --> 00:05:28,960
university level maths maybe you know

00:05:28,560 --> 00:05:31,600
this

00:05:28,960 --> 00:05:33,440
but most people haven't and so this is

00:05:31,600 --> 00:05:35,440
something you just have to learn

00:05:33,440 --> 00:05:36,960
and this even goes so far as to say that

00:05:35,440 --> 00:05:38,720
like i've seen

00:05:36,960 --> 00:05:40,479
style guides in companies where if you

00:05:38,720 --> 00:05:42,880
have more than one and an

00:05:40,479 --> 00:05:43,600
or you have to add the brackets just so

00:05:42,880 --> 00:05:45,759
it's clear

00:05:43,600 --> 00:05:46,880
and so that people aren't expected to

00:05:45,759 --> 00:05:48,479
remember

00:05:46,880 --> 00:05:51,199
as they're reading the code which one of

00:05:48,479 --> 00:05:52,960
these goes first

00:05:51,199 --> 00:05:54,720
even if you're an experienced programmer

00:05:52,960 --> 00:05:56,319
you might find cases where

00:05:54,720 --> 00:05:57,919
the operator precedence and

00:05:56,319 --> 00:06:00,800
associativity rules

00:05:57,919 --> 00:06:01,840
surprise you and behave in ways that you

00:06:00,800 --> 00:06:04,800
don't expect

00:06:01,840 --> 00:06:06,080
so this is the uh power of or

00:06:04,800 --> 00:06:08,240
exponentiation operator

00:06:06,080 --> 00:06:09,120
in javascript and you could kind of

00:06:08,240 --> 00:06:12,160
interpret this

00:06:09,120 --> 00:06:15,600
phrase in two ways either it's

00:06:12,160 --> 00:06:17,039
8 to the power of 2 or it's 2 to the

00:06:15,600 --> 00:06:19,199
power of 9

00:06:17,039 --> 00:06:20,319
and unless you happen to know or

00:06:19,199 --> 00:06:23,520
remember

00:06:20,319 --> 00:06:23,840
that javascript exponentiation operators

00:06:23,520 --> 00:06:26,479
are

00:06:23,840 --> 00:06:28,160
right associative you wouldn't know or

00:06:26,479 --> 00:06:28,639
even necessarily be able to reasonably

00:06:28,160 --> 00:06:30,479
guess

00:06:28,639 --> 00:06:33,680
that the second one is actually the way

00:06:30,479 --> 00:06:36,080
that this is interpreted in javascript

00:06:33,680 --> 00:06:38,319
so these things are kind of mostly okay

00:06:36,080 --> 00:06:40,720
you you have to learn them

00:06:38,319 --> 00:06:42,639
for a particular language but there's

00:06:40,720 --> 00:06:43,440
only a limited set of rules within a

00:06:42,639 --> 00:06:45,039
language

00:06:43,440 --> 00:06:47,039
that you have to learn you only have to

00:06:45,039 --> 00:06:48,960
learn it once and then you can remember

00:06:47,039 --> 00:06:50,319
it and code many more things over and

00:06:48,960 --> 00:06:52,319
over again

00:06:50,319 --> 00:06:53,840
but it's not just the language rules

00:06:52,319 --> 00:06:54,800
that are things that you have to keep in

00:06:53,840 --> 00:06:58,479
your head

00:06:54,800 --> 00:06:59,919
as you're coding and in particular if

00:06:58,479 --> 00:07:02,560
you read this code

00:06:59,919 --> 00:07:03,199
this is getting a canvas html canvas

00:07:02,560 --> 00:07:05,520
element

00:07:03,199 --> 00:07:06,560
and it is drawing to that canvas element

00:07:05,520 --> 00:07:09,840
and it's drawing an

00:07:06,560 --> 00:07:12,639
arc and this arc function

00:07:09,840 --> 00:07:14,800
has five parameters and just by reading

00:07:12,639 --> 00:07:16,800
this code i can't tell

00:07:14,800 --> 00:07:18,880
what this art function is doing because

00:07:16,800 --> 00:07:21,360
i don't know which parameter is which

00:07:18,880 --> 00:07:22,240
i can probably guess that the first two

00:07:21,360 --> 00:07:24,560
parameters

00:07:22,240 --> 00:07:26,160
are an x and y coordinate but the rest

00:07:24,560 --> 00:07:27,280
of the parameters i'm not sure what they

00:07:26,160 --> 00:07:29,360
are

00:07:27,280 --> 00:07:30,960
the code has this information but

00:07:29,360 --> 00:07:32,000
because we don't want the code to be

00:07:30,960 --> 00:07:33,520
redundantly

00:07:32,000 --> 00:07:34,800
copying the information over and over

00:07:33,520 --> 00:07:36,080
again because if you change it in one

00:07:34,800 --> 00:07:36,800
place you'd have to change it in another

00:07:36,080 --> 00:07:39,840
place

00:07:36,800 --> 00:07:40,479
most languages don't have the parameter

00:07:39,840 --> 00:07:44,000
names

00:07:40,479 --> 00:07:46,319
embedded in a function call some ides do

00:07:44,000 --> 00:07:47,919
this typically the ides that are aimed

00:07:46,319 --> 00:07:49,919
at professional developers

00:07:47,919 --> 00:07:51,199
high-end ides that cost money are the

00:07:49,919 --> 00:07:54,080
ones that do this and

00:07:51,199 --> 00:07:55,919
the beginner level ides typically don't

00:07:54,080 --> 00:07:57,440
have this information and you just kind

00:07:55,919 --> 00:07:58,879
of have to learn it

00:07:57,440 --> 00:08:00,879
but now that i have these parameter

00:07:58,879 --> 00:08:03,039
names i can see that

00:08:00,879 --> 00:08:04,639
the third parameter is the radius okay

00:08:03,039 --> 00:08:06,400
there's the radius of my arc

00:08:04,639 --> 00:08:08,800
the start angle is zero and the end

00:08:06,400 --> 00:08:10,879
angle is two pi oh now i can understand

00:08:08,800 --> 00:08:12,080
that this is drawing a full circle

00:08:10,879 --> 00:08:14,800
now that i understand what these

00:08:12,080 --> 00:08:16,560
parameter names actually are

00:08:14,800 --> 00:08:18,479
and there's a lot of information that

00:08:16,560 --> 00:08:19,680
you have to remember and keep in your

00:08:18,479 --> 00:08:21,440
head

00:08:19,680 --> 00:08:23,199
if you want to be able to code without

00:08:21,440 --> 00:08:25,360
stopping to go look up stuff on stack

00:08:23,199 --> 00:08:28,560
overflow or in the documentation

00:08:25,360 --> 00:08:29,919
every single step of the way so

00:08:28,560 --> 00:08:33,200
when you start coding and you're

00:08:29,919 --> 00:08:34,959
presented with just a blank text editor

00:08:33,200 --> 00:08:37,200
like how are you supposed to know what

00:08:34,959 --> 00:08:39,919
to write there's so much information

00:08:37,200 --> 00:08:41,039
that you have to learn before you can

00:08:39,919 --> 00:08:44,159
competently

00:08:41,039 --> 00:08:46,720
write code you have to know these

00:08:44,159 --> 00:08:48,399
arbitrary symbols and the multiple

00:08:46,720 --> 00:08:50,320
meanings that they have

00:08:48,399 --> 00:08:52,000
you have to know the syntax of the

00:08:50,320 --> 00:08:52,880
language the keywords and the rules

00:08:52,000 --> 00:08:54,959
around it

00:08:52,880 --> 00:08:56,720
you need to know the operator precedence

00:08:54,959 --> 00:08:58,160
rules and associativity rules to a

00:08:56,720 --> 00:08:59,360
certain extent before you can really

00:08:58,160 --> 00:09:01,279
make use of those

00:08:59,360 --> 00:09:03,040
you have to remember the functions and

00:09:01,279 --> 00:09:05,040
variables that are available to you in

00:09:03,040 --> 00:09:07,519
whatever library you're using

00:09:05,040 --> 00:09:09,600
including those function parameter names

00:09:07,519 --> 00:09:11,200
and the types of any variables that you

00:09:09,600 --> 00:09:12,720
use or create yourself

00:09:11,200 --> 00:09:14,959
you have to store that information in

00:09:12,720 --> 00:09:17,360
your head and there's a lot of

00:09:14,959 --> 00:09:18,080
cognitive load associated with writing

00:09:17,360 --> 00:09:20,160
code

00:09:18,080 --> 00:09:22,480
which makes interruptions particularly

00:09:20,160 --> 00:09:25,360
damaging for developers

00:09:22,480 --> 00:09:28,080
and makes coding particularly difficult

00:09:25,360 --> 00:09:31,760
to start learning as a newbie because

00:09:28,080 --> 00:09:32,480
it takes time to start to remember all

00:09:31,760 --> 00:09:35,920
of these things

00:09:32,480 --> 00:09:38,320
as you're coding so what else is there

00:09:35,920 --> 00:09:41,120
we've been mostly coding in text files

00:09:38,320 --> 00:09:41,839
for decades but that's not the only kind

00:09:41,120 --> 00:09:44,240
of code

00:09:41,839 --> 00:09:45,680
that exists out there and there are a

00:09:44,240 --> 00:09:48,720
number of really interesting

00:09:45,680 --> 00:09:50,640
visual coding interfaces that have found

00:09:48,720 --> 00:09:52,160
solutions to these problems there are

00:09:50,640 --> 00:09:55,680
ways that you can write code

00:09:52,160 --> 00:09:57,519
where you don't have to remember and

00:09:55,680 --> 00:09:59,200
formulate in your head everything that

00:09:57,519 --> 00:10:01,440
you want to write

00:09:59,200 --> 00:10:02,320
so my favorite example of this is

00:10:01,440 --> 00:10:04,079
scratch

00:10:02,320 --> 00:10:05,519
and scratch is particularly well known

00:10:04,079 --> 00:10:06,720
it's very popular language it's very

00:10:05,519 --> 00:10:10,079
popular among

00:10:06,720 --> 00:10:11,680
uh children teenagers and beginner

00:10:10,079 --> 00:10:12,800
coders

00:10:11,680 --> 00:10:14,959
and the thing that's beautiful about

00:10:12,800 --> 00:10:18,640
scratch is that you don't need to

00:10:14,959 --> 00:10:21,279
actually remember anything uh you can

00:10:18,640 --> 00:10:22,000
you have this tray of blocks available

00:10:21,279 --> 00:10:23,360
to you

00:10:22,000 --> 00:10:25,839
and you can just look through the list

00:10:23,360 --> 00:10:28,480
of blocks and you find a block that says

00:10:25,839 --> 00:10:29,040
very clearly turn to the right 15

00:10:28,480 --> 00:10:30,640
degrees

00:10:29,040 --> 00:10:33,040
and you can understand immediately what

00:10:30,640 --> 00:10:35,440
that block does and even if you don't

00:10:33,040 --> 00:10:37,279
know what it is that you're looking for

00:10:35,440 --> 00:10:39,200
you can still find blocks and start

00:10:37,279 --> 00:10:42,640
compiling a program

00:10:39,200 --> 00:10:44,800
out of them and so there's no kind of

00:10:42,640 --> 00:10:47,680
weird symbols that you need to remember

00:10:44,800 --> 00:10:48,399
um and the the blocks are available to

00:10:47,680 --> 00:10:50,240
you

00:10:48,399 --> 00:10:52,240
uh whenever you need them you don't have

00:10:50,240 --> 00:10:53,839
to remember what the blocks are or how

00:10:52,240 --> 00:10:56,640
the blocks are worded

00:10:53,839 --> 00:10:58,800
uh when you want to write some code this

00:10:56,640 --> 00:11:01,120
makes it very easy to just open scratch

00:10:58,800 --> 00:11:01,839
and start writing something on the

00:11:01,120 --> 00:11:04,560
downside

00:11:01,839 --> 00:11:06,399
once you do become familiar with scratch

00:11:04,560 --> 00:11:07,760
and once you do start to build bigger

00:11:06,399 --> 00:11:08,320
and bigger scratch programs and people

00:11:07,760 --> 00:11:12,399
have made

00:11:08,320 --> 00:11:15,120
amazing complicated games in scratch

00:11:12,399 --> 00:11:15,680
once you know what you're doing there is

00:11:15,120 --> 00:11:18,240
no

00:11:15,680 --> 00:11:19,920
faster way to get those blocks you still

00:11:18,240 --> 00:11:21,680
have to open the tray

00:11:19,920 --> 00:11:23,519
find the blocks that you're looking for

00:11:21,680 --> 00:11:25,760
and drag it into the program

00:11:23,519 --> 00:11:27,120
you can't kind of just type a few key

00:11:25,760 --> 00:11:28,079
strokes and magic the block into

00:11:27,120 --> 00:11:29,440
existence

00:11:28,079 --> 00:11:31,120
if you already know what it is that

00:11:29,440 --> 00:11:33,279
you're looking for

00:11:31,120 --> 00:11:34,640
so it does become a bit cumbersome and

00:11:33,279 --> 00:11:36,560
difficult to work with

00:11:34,640 --> 00:11:38,880
once you start building a bigger more

00:11:36,560 --> 00:11:41,120
complicated code

00:11:38,880 --> 00:11:43,360
my other favorite example is the unreal

00:11:41,120 --> 00:11:45,839
engine blueprints

00:11:43,360 --> 00:11:47,360
system which is this kind of also sort

00:11:45,839 --> 00:11:49,200
of block based where you have

00:11:47,360 --> 00:11:50,720
these blocks that represent function

00:11:49,200 --> 00:11:54,079
calls and

00:11:50,720 --> 00:11:55,440
conditionals and again you don't need to

00:11:54,079 --> 00:11:58,160
remember things

00:11:55,440 --> 00:11:58,959
in order to code using the blueprints

00:11:58,160 --> 00:12:01,839
engine

00:11:58,959 --> 00:12:03,600
you don't need to remember that the

00:12:01,839 --> 00:12:06,079
launch character function has

00:12:03,600 --> 00:12:07,279
these parameters over here on the right

00:12:06,079 --> 00:12:09,600
you don't need to remember

00:12:07,279 --> 00:12:11,200
that the launch velocity is a vector uh

00:12:09,600 --> 00:12:12,880
this yellow symbol means that it's a

00:12:11,200 --> 00:12:14,959
vector also you can see that it has an x

00:12:12,880 --> 00:12:16,720
y inside coordinate here

00:12:14,959 --> 00:12:18,800
uh you don't need to remember that this

00:12:16,720 --> 00:12:20,160
is a boolean there's a checkbox here and

00:12:18,800 --> 00:12:23,440
the red symbol

00:12:20,160 --> 00:12:25,680
indicates to you that it's a boolean so

00:12:23,440 --> 00:12:28,000
the the variables available to you and

00:12:25,680 --> 00:12:30,320
even when you want to create a new

00:12:28,000 --> 00:12:31,760
block there is just a list of blocks for

00:12:30,320 --> 00:12:32,959
you to choose from you don't need to

00:12:31,760 --> 00:12:35,279
remember anything

00:12:32,959 --> 00:12:37,519
and this is why in unreal engine even

00:12:35,279 --> 00:12:40,079
people who are very familiar with

00:12:37,519 --> 00:12:40,959
coding and a very competent professional

00:12:40,079 --> 00:12:43,279
coders

00:12:40,959 --> 00:12:44,560
they will still use blueprints for parts

00:12:43,279 --> 00:12:47,279
of their system

00:12:44,560 --> 00:12:48,160
because it is easier to write and faster

00:12:47,279 --> 00:12:51,519
to write

00:12:48,160 --> 00:12:53,360
than actually writing the code for it

00:12:51,519 --> 00:12:55,200
again there are some downsides it does

00:12:53,360 --> 00:12:58,160
take up a lot of screen space

00:12:55,200 --> 00:12:59,839
for a smaller amount of code and for a

00:12:58,160 --> 00:13:02,079
larger more complicated program

00:12:59,839 --> 00:13:03,760
you end up with lines going everywhere

00:13:02,079 --> 00:13:05,440
unless you're very careful about how you

00:13:03,760 --> 00:13:07,519
structure the layout of the code so

00:13:05,440 --> 00:13:09,279
there are some downsides to this

00:13:07,519 --> 00:13:11,519
and also with both of these examples

00:13:09,279 --> 00:13:14,399
with scratch and with blueprints

00:13:11,519 --> 00:13:14,959
these coding environments are limited to

00:13:14,399 --> 00:13:17,920
a

00:13:14,959 --> 00:13:18,399
sort of specific domain problem there

00:13:17,920 --> 00:13:20,240
are

00:13:18,399 --> 00:13:21,920
specific kinds of programs you can write

00:13:20,240 --> 00:13:23,040
and you can't necessarily do everything

00:13:21,920 --> 00:13:25,279
that you could do

00:13:23,040 --> 00:13:26,880
with a regular text-based programming

00:13:25,279 --> 00:13:29,279
language

00:13:26,880 --> 00:13:31,839
and i've gone looking through many

00:13:29,279 --> 00:13:35,120
different visual coding interfaces

00:13:31,839 --> 00:13:36,959
and none of them really do what i want

00:13:35,120 --> 00:13:39,279
to get out of a coding interface

00:13:36,959 --> 00:13:41,519
like i don't want to have to deal with

00:13:39,279 --> 00:13:44,480
syntax and symbols and

00:13:41,519 --> 00:13:46,320
parse errors and matching brackets and

00:13:44,480 --> 00:13:48,160
white space and indenting i don't want

00:13:46,320 --> 00:13:50,320
to have to deal with these things

00:13:48,160 --> 00:13:51,600
and in particular i want to be able to

00:13:50,320 --> 00:13:54,240
teach students

00:13:51,600 --> 00:13:55,600
how to do web development without having

00:13:54,240 --> 00:13:58,560
to teach them

00:13:55,600 --> 00:13:59,199
three different kinds of syntax in order

00:13:58,560 --> 00:14:01,279
to make

00:13:59,199 --> 00:14:03,279
anything happen when you do web

00:14:01,279 --> 00:14:06,959
development you really do need to know

00:14:03,279 --> 00:14:09,360
html and css and javascript

00:14:06,959 --> 00:14:10,720
and that is a lot of syntax and a lot of

00:14:09,360 --> 00:14:12,560
symbols and a lot of

00:14:10,720 --> 00:14:14,480
contradictory things that you need to

00:14:12,560 --> 00:14:15,519
learn in order to be able to do any of

00:14:14,480 --> 00:14:17,680
that

00:14:15,519 --> 00:14:18,800
so what i want is something that will

00:14:17,680 --> 00:14:22,160
let me uh

00:14:18,800 --> 00:14:26,079
code in javascript and not restrict me

00:14:22,160 --> 00:14:27,360
into one specific branch of problems

00:14:26,079 --> 00:14:29,199
i want to be able to do anything that i

00:14:27,360 --> 00:14:30,880
can do with javascript

00:14:29,199 --> 00:14:32,320
but without having to deal with text

00:14:30,880 --> 00:14:35,680
files

00:14:32,320 --> 00:14:37,680
and this is not an easy problem

00:14:35,680 --> 00:14:39,600
and this is how i started on this kind

00:14:37,680 --> 00:14:42,839
of epic quest to climb a mountain

00:14:39,600 --> 00:14:45,519
and find out if such a thing is even

00:14:42,839 --> 00:14:46,000
possible and so here i am on my quest

00:14:45,519 --> 00:14:48,240
i'm still

00:14:46,000 --> 00:14:49,680
very much at the beginning of this quest

00:14:48,240 --> 00:14:51,519
uh but

00:14:49,680 --> 00:14:53,199
i will hopefully show you that i am

00:14:51,519 --> 00:14:54,399
already at least making some steps and

00:14:53,199 --> 00:14:58,160
learning some things

00:14:54,399 --> 00:14:59,760
along the way to solving this problem so

00:14:58,160 --> 00:15:01,360
let's be a little bit more specific

00:14:59,760 --> 00:15:03,120
about what it is that i want so

00:15:01,360 --> 00:15:04,880
firstly i want a real world programming

00:15:03,120 --> 00:15:06,240
language and in particular i want to use

00:15:04,880 --> 00:15:08,320
javascript because i want to be able to

00:15:06,240 --> 00:15:10,720
build uis and do web development

00:15:08,320 --> 00:15:12,240
so i want to have a complete and

00:15:10,720 --> 00:15:14,399
functional implementation

00:15:12,240 --> 00:15:16,160
of javascript such that i'm not locked

00:15:14,399 --> 00:15:18,800
into some

00:15:16,160 --> 00:15:20,480
uh environment where if i want to learn

00:15:18,800 --> 00:15:22,399
real coding i have to get out of that

00:15:20,480 --> 00:15:25,680
environment

00:15:22,399 --> 00:15:27,600
um i want it to have a layout that is

00:15:25,680 --> 00:15:29,759
readable and scannable and i don't want

00:15:27,600 --> 00:15:31,440
it to be sort of spaghetti blocks

00:15:29,759 --> 00:15:32,959
all over the screen where it's kind of

00:15:31,440 --> 00:15:35,519
you have to follow lines and

00:15:32,959 --> 00:15:36,880
and to trace through what is going on i

00:15:35,519 --> 00:15:38,639
don't want it to have these

00:15:36,880 --> 00:15:40,480
arbitrary symbols i don't want to have

00:15:38,639 --> 00:15:41,839
to type the symbols and i don't want to

00:15:40,480 --> 00:15:44,240
have to understand

00:15:41,839 --> 00:15:45,759
and learn what these weird symbols mean

00:15:44,240 --> 00:15:48,959
to be able to interpret it

00:15:45,759 --> 00:15:50,320
everything should be either words or

00:15:48,959 --> 00:15:52,079
structures that are very easy to

00:15:50,320 --> 00:15:53,920
understand

00:15:52,079 --> 00:15:55,680
i don't want to have to deal with

00:15:53,920 --> 00:15:57,680
operator precedence rules

00:15:55,680 --> 00:15:59,120
and i don't want to have to and i don't

00:15:57,680 --> 00:16:00,959
want to have to learn those operator

00:15:59,120 --> 00:16:02,639
precedence rules

00:16:00,959 --> 00:16:04,000
and i don't want it to be a

00:16:02,639 --> 00:16:06,560
drag-and-drop

00:16:04,000 --> 00:16:07,680
interface i want to be able to navigate

00:16:06,560 --> 00:16:09,839
the code quickly

00:16:07,680 --> 00:16:11,839
i want to be able to add new elements to

00:16:09,839 --> 00:16:13,600
the code quickly

00:16:11,839 --> 00:16:15,120
in a way that i can probably just if i

00:16:13,600 --> 00:16:16,639
know what i'm doing i should be able to

00:16:15,120 --> 00:16:17,440
just type it and make it happen i want

00:16:16,639 --> 00:16:21,839
it to be

00:16:17,440 --> 00:16:22,720
as fast to edit as text-based coding is

00:16:21,839 --> 00:16:25,839
and

00:16:22,720 --> 00:16:28,240
yes i guess i'm asking a lot here um

00:16:25,839 --> 00:16:31,199
this is not an easy thing to achieve

00:16:28,240 --> 00:16:33,120
for any of these things but i'm willing

00:16:31,199 --> 00:16:33,920
to spend a lot of time on it so uh let's

00:16:33,120 --> 00:16:35,920
see how we go

00:16:33,920 --> 00:16:38,320
it did not start off very well so let's

00:16:35,920 --> 00:16:41,040
start with experiment number one

00:16:38,320 --> 00:16:42,639
and i called this the ast builder so

00:16:41,040 --> 00:16:44,800
what is an ast

00:16:42,639 --> 00:16:46,160
uh this is an ast so for a very simple

00:16:44,800 --> 00:16:48,800
line of javascript code

00:16:46,160 --> 00:16:51,600
which is console.log where we're logging

00:16:48,800 --> 00:16:52,800
the value x plus 10.

00:16:51,600 --> 00:16:54,880
the first thing that happens when you

00:16:52,800 --> 00:16:57,839
take text-based code and process

00:16:54,880 --> 00:16:58,480
it to run it is it gets parsed into

00:16:57,839 --> 00:17:01,199
what's called an

00:16:58,480 --> 00:17:02,639
abstract syntax tree or ast and in this

00:17:01,199 --> 00:17:04,799
case the ast would look something like

00:17:02,639 --> 00:17:06,799
this there is a call expression a

00:17:04,799 --> 00:17:08,880
function call expression

00:17:06,799 --> 00:17:10,480
which is the top level node and it has

00:17:08,880 --> 00:17:12,480
two children

00:17:10,480 --> 00:17:15,839
it has a callee which in this case is a

00:17:12,480 --> 00:17:18,240
member expression console.log

00:17:15,839 --> 00:17:19,839
and it has a set of arguments and in

00:17:18,240 --> 00:17:20,480
this case there's only one argument

00:17:19,839 --> 00:17:22,559
which is a

00:17:20,480 --> 00:17:24,640
binary expression which has the operator

00:17:22,559 --> 00:17:25,280
plus and so that is our expression that

00:17:24,640 --> 00:17:28,960
indicates

00:17:25,280 --> 00:17:31,760
x plus 10 and these things combined

00:17:28,960 --> 00:17:33,200
is the way that the computer understands

00:17:31,760 --> 00:17:35,039
code

00:17:33,200 --> 00:17:36,799
and what i want to do is skip the

00:17:35,039 --> 00:17:38,880
middleman i don't want to have

00:17:36,799 --> 00:17:40,320
a text-based representation of the code

00:17:38,880 --> 00:17:42,000
i want to have a tree-based

00:17:40,320 --> 00:17:44,480
representation of the code

00:17:42,000 --> 00:17:46,720
so that i can directly manipulate this

00:17:44,480 --> 00:17:49,919
abstract syntax tree

00:17:46,720 --> 00:17:52,320
without having to type characters

00:17:49,919 --> 00:17:54,000
and symbols that provide the structure

00:17:52,320 --> 00:17:56,480
to this tree

00:17:54,000 --> 00:17:57,600
so when you have code that looks like a

00:17:56,480 --> 00:18:00,000
tree

00:17:57,600 --> 00:18:01,520
instead of adding sort of characters to

00:18:00,000 --> 00:18:02,720
a string of characters like you would in

00:18:01,520 --> 00:18:04,240
text-based coding

00:18:02,720 --> 00:18:06,480
you have these operations that you can

00:18:04,240 --> 00:18:09,280
perform on the tree

00:18:06,480 --> 00:18:10,480
like an insert operation where you add a

00:18:09,280 --> 00:18:12,720
new node to the tree

00:18:10,480 --> 00:18:14,160
and this might mean you're adding a new

00:18:12,720 --> 00:18:16,720
argument to

00:18:14,160 --> 00:18:18,480
a function call it might mean you're

00:18:16,720 --> 00:18:19,120
adding a new statement to a block of

00:18:18,480 --> 00:18:21,360
code

00:18:19,120 --> 00:18:22,480
it's that kind of insert operation or

00:18:21,360 --> 00:18:23,919
you might

00:18:22,480 --> 00:18:25,360
delete a node from the tree you might

00:18:23,919 --> 00:18:26,960
delete an argument you might delete a

00:18:25,360 --> 00:18:28,640
line of code you might delete a whole if

00:18:26,960 --> 00:18:31,840
statement

00:18:28,640 --> 00:18:34,000
it's uh removing something from the tree

00:18:31,840 --> 00:18:35,280
but a lot of the time in code what we

00:18:34,000 --> 00:18:37,440
actually want to do is a

00:18:35,280 --> 00:18:39,200
what i would call a wrap operation where

00:18:37,440 --> 00:18:42,400
you're inserting a node

00:18:39,200 --> 00:18:45,919
part way into the tree between two

00:18:42,400 --> 00:18:47,919
existing nodes and this might be if you

00:18:45,919 --> 00:18:49,360
have a string and you want to pass that

00:18:47,919 --> 00:18:51,200
string into a function

00:18:49,360 --> 00:18:53,120
you would wrap that string in a function

00:18:51,200 --> 00:18:56,000
call or if you have

00:18:53,120 --> 00:18:56,799
a plus b and you want to make it plus c

00:18:56,000 --> 00:18:59,200
as well

00:18:56,799 --> 00:19:00,960
that is a wrap operation on the binary

00:18:59,200 --> 00:19:03,039
operator

00:19:00,960 --> 00:19:04,960
so i wanted to be able to do each of

00:19:03,039 --> 00:19:08,000
these three kinds of operations

00:19:04,960 --> 00:19:09,600
on a tree representation of the code but

00:19:08,000 --> 00:19:10,640
i want the code to be readable in the

00:19:09,600 --> 00:19:13,440
way that

00:19:10,640 --> 00:19:14,160
code is readable so this is what i built

00:19:13,440 --> 00:19:17,280
at first

00:19:14,160 --> 00:19:19,200
um it's very basic it only ever

00:19:17,280 --> 00:19:21,039
handled a small subset of javascript it

00:19:19,200 --> 00:19:23,039
was never actually runnable

00:19:21,039 --> 00:19:24,960
as javascript but i had the idea that

00:19:23,039 --> 00:19:26,960
you could kind of see it like code but

00:19:24,960 --> 00:19:28,559
when you like click on something

00:19:26,960 --> 00:19:30,320
it shows you the options that you can do

00:19:28,559 --> 00:19:31,440
with it you could insert statements

00:19:30,320 --> 00:19:33,440
before or after

00:19:31,440 --> 00:19:36,080
or if you click on a particular variable

00:19:33,440 --> 00:19:36,880
you could wrap that variable or insert

00:19:36,080 --> 00:19:39,520
things before

00:19:36,880 --> 00:19:41,760
and after it so you could say wrap this

00:19:39,520 --> 00:19:43,600
variable in an operator

00:19:41,760 --> 00:19:44,960
that then gives you options for what to

00:19:43,600 --> 00:19:46,720
fill in on the other side of that

00:19:44,960 --> 00:19:49,280
operator and

00:19:46,720 --> 00:19:49,840
honestly this ui was kind of terrible

00:19:49,280 --> 00:19:52,080
and

00:19:49,840 --> 00:19:53,840
the buttons popping up and disappearing

00:19:52,080 --> 00:19:55,600
all the time was a difficult

00:19:53,840 --> 00:19:57,360
user experience and honestly nothing

00:19:55,600 --> 00:19:58,240
nothing nothing in this prototype

00:19:57,360 --> 00:20:00,720
actually worked

00:19:58,240 --> 00:20:01,280
so i learned from this that ui design is

00:20:00,720 --> 00:20:02,720
hard

00:20:01,280 --> 00:20:04,840
i've been coding for a long time but i'm

00:20:02,720 --> 00:20:06,080
very much a backend and sort of devops

00:20:04,840 --> 00:20:09,280
engineer

00:20:06,080 --> 00:20:10,640
and js syntax is quite complicated in

00:20:09,280 --> 00:20:12,559
order to have a tree structure that

00:20:10,640 --> 00:20:14,880
represents javascript code

00:20:12,559 --> 00:20:17,600
there are a lot of different kinds of

00:20:14,880 --> 00:20:19,200
nodes in that abstract syntax tree

00:20:17,600 --> 00:20:20,799
if i was doing lisp this would probably

00:20:19,200 --> 00:20:23,600
be much easier

00:20:20,799 --> 00:20:25,520
but javascript has a lot of different

00:20:23,600 --> 00:20:28,799
bits of syntax associated with it

00:20:25,520 --> 00:20:30,720
so i decided to make this problem a bit

00:20:28,799 --> 00:20:32,640
easier for myself

00:20:30,720 --> 00:20:34,159
and instead of focusing on javascript to

00:20:32,640 --> 00:20:37,520
start with i decided to focus

00:20:34,159 --> 00:20:39,039
on html and build an html editor

00:20:37,520 --> 00:20:40,640
that again had the same properties that

00:20:39,039 --> 00:20:42,240
it was a tree based

00:20:40,640 --> 00:20:43,840
structure that you would insert and

00:20:42,240 --> 00:20:48,080
delete and wrap nodes

00:20:43,840 --> 00:20:50,400
in the tree so this html editor

00:20:48,080 --> 00:20:51,679
has a lot of the same properties as

00:20:50,400 --> 00:20:53,679
javascript because

00:20:51,679 --> 00:20:55,200
it's still a tree structure it's just a

00:20:53,679 --> 00:20:57,679
simpler kind of tree

00:20:55,200 --> 00:20:59,679
in html there aren't that many different

00:20:57,679 --> 00:21:02,240
kinds of nodes in the tree

00:20:59,679 --> 00:21:04,480
you basically have elements text nodes

00:21:02,240 --> 00:21:06,559
and attributes on those elements

00:21:04,480 --> 00:21:07,679
but it does have some similar properties

00:21:06,559 --> 00:21:10,480
to a

00:21:07,679 --> 00:21:11,120
javascript or otherwise code tree

00:21:10,480 --> 00:21:13,919
because

00:21:11,120 --> 00:21:14,400
one node in this tree can have multiple

00:21:13,919 --> 00:21:18,320
sets

00:21:14,400 --> 00:21:20,559
of children that are distinct

00:21:18,320 --> 00:21:21,919
a div element has a set of attributes

00:21:20,559 --> 00:21:23,760
and a set of

00:21:21,919 --> 00:21:25,600
content to it which might be other

00:21:23,760 --> 00:21:27,919
elements or a text node

00:21:25,600 --> 00:21:29,679
just like in javascript an if statement

00:21:27,919 --> 00:21:31,440
would have multiple children

00:21:29,679 --> 00:21:32,720
and that an if statement has a condition

00:21:31,440 --> 00:21:34,880
to it it also has

00:21:32,720 --> 00:21:36,400
a body which is the code that happens if

00:21:34,880 --> 00:21:37,919
the if statement is true

00:21:36,400 --> 00:21:39,840
and then it might also have another

00:21:37,919 --> 00:21:41,200
child which is an else or an lcf

00:21:39,840 --> 00:21:45,039
statement

00:21:41,200 --> 00:21:46,320
so having a tree which is a simple tree

00:21:45,039 --> 00:21:47,840
but still has some of the properties of

00:21:46,320 --> 00:21:49,200
like multiple different sets of children

00:21:47,840 --> 00:21:51,840
and how to navigate that

00:21:49,200 --> 00:21:53,679
was a good test of whether this kind of

00:21:51,840 --> 00:21:57,039
tree based editor idea could even

00:21:53,679 --> 00:21:58,559
work okay so it's going to load the

00:21:57,039 --> 00:22:01,520
video

00:21:58,559 --> 00:22:03,280
and this is this is what i built first

00:22:01,520 --> 00:22:06,480
as experiment number two

00:22:03,280 --> 00:22:07,360
so this is an html editor uh you can see

00:22:06,480 --> 00:22:10,400
it has sort of

00:22:07,360 --> 00:22:12,640
html head body elements you can select

00:22:10,400 --> 00:22:14,159
any one of these elements

00:22:12,640 --> 00:22:15,919
you can hide the editor and you can see

00:22:14,159 --> 00:22:18,559
that what i'm editing here is

00:22:15,919 --> 00:22:19,760
a fairly standard html sort of template

00:22:18,559 --> 00:22:22,320
page

00:22:19,760 --> 00:22:23,600
with some filler content in it but you

00:22:22,320 --> 00:22:26,559
can select a text node

00:22:23,600 --> 00:22:27,200
you can edit that text node uh and it

00:22:26,559 --> 00:22:31,520
updates

00:22:27,200 --> 00:22:33,520
the the frame html uh live

00:22:31,520 --> 00:22:35,600
in the same way you can kind of delete a

00:22:33,520 --> 00:22:37,679
node um there's this kind of purple

00:22:35,600 --> 00:22:38,720
cursor that you can move around with the

00:22:37,679 --> 00:22:41,919
keyboard

00:22:38,720 --> 00:22:43,440
you can select a node edit a node and in

00:22:41,919 --> 00:22:47,280
this case we're editing

00:22:43,440 --> 00:22:50,559
a an attribute on one of the elements

00:22:47,280 --> 00:22:52,400
uh in the same way i can select a node

00:22:50,559 --> 00:22:54,000
and perform a wrap operation by hitting

00:22:52,400 --> 00:22:55,840
that little wrap button at the top

00:22:54,000 --> 00:22:57,440
the ux for it is a bit janky but i've

00:22:55,840 --> 00:23:01,840
now wrapped this

00:22:57,440 --> 00:23:05,600
h3 element in a div tag

00:23:01,840 --> 00:23:09,039
and let's go to the next slide

00:23:05,600 --> 00:23:10,720
okay so ultimately this actually kind of

00:23:09,039 --> 00:23:11,039
works and one of the nice things about

00:23:10,720 --> 00:23:12,400
this

00:23:11,039 --> 00:23:14,960
is because it's stored in a tree

00:23:12,400 --> 00:23:16,960
structure escaping

00:23:14,960 --> 00:23:18,720
anything that's in the text so that it

00:23:16,960 --> 00:23:19,280
doesn't accidentally get interpreted as

00:23:18,720 --> 00:23:21,679
a tag

00:23:19,280 --> 00:23:23,600
is just a non-issue you can write

00:23:21,679 --> 00:23:26,400
whatever characters you want

00:23:23,600 --> 00:23:28,720
into this text string and it will only

00:23:26,400 --> 00:23:30,720
ever be interpreted as a text string

00:23:28,720 --> 00:23:31,919
the operation to add an element is a

00:23:30,720 --> 00:23:35,120
separate operation

00:23:31,919 --> 00:23:39,039
so escaping disappears

00:23:35,120 --> 00:23:40,960
as a problem in html in this interface

00:23:39,039 --> 00:23:42,799
and when we're editing this interface we

00:23:40,960 --> 00:23:44,320
can do all three of these operations we

00:23:42,799 --> 00:23:45,120
can do inserts we can do deletes and we

00:23:44,320 --> 00:23:47,360
can do

00:23:45,120 --> 00:23:48,960
wrap operations and it's not the

00:23:47,360 --> 00:23:49,600
greatest ui because i'm a terrible ui

00:23:48,960 --> 00:23:51,279
designer

00:23:49,600 --> 00:23:54,000
but it showed me enough that this

00:23:51,279 --> 00:23:55,440
solution was was workable

00:23:54,000 --> 00:23:57,600
what we can do is navigate with the

00:23:55,440 --> 00:23:59,279
keyboard we avoid escaping

00:23:57,600 --> 00:24:01,279
the design is not great i'm not a fan of

00:23:59,279 --> 00:24:01,840
these kind of like boxes of rounded

00:24:01,279 --> 00:24:03,679
corners

00:24:01,840 --> 00:24:05,360
um it takes up a lot of space it makes

00:24:03,679 --> 00:24:07,919
the code hard to scan

00:24:05,360 --> 00:24:09,840
uh it was clear to me that the tags were

00:24:07,919 --> 00:24:11,360
kind of difficult to see and the

00:24:09,840 --> 00:24:13,279
attributes were particularly difficult

00:24:11,360 --> 00:24:16,640
to see because there was no

00:24:13,279 --> 00:24:17,360
um ui around them to indicate where one

00:24:16,640 --> 00:24:20,080
attributed

00:24:17,360 --> 00:24:21,279
started and another one finished so if

00:24:20,080 --> 00:24:21,679
you look over here there's like a space

00:24:21,279 --> 00:24:22,880
here

00:24:21,679 --> 00:24:24,559
but there's no quotes around this

00:24:22,880 --> 00:24:26,240
attribute it's very hard to tell sort of

00:24:24,559 --> 00:24:29,520
that this is actually one

00:24:26,240 --> 00:24:30,559
class attribute on this span tag here so

00:24:29,520 --> 00:24:31,760
a couple of issues

00:24:30,559 --> 00:24:33,760
but it was enough to give me the

00:24:31,760 --> 00:24:35,919
confidence to uh have

00:24:33,760 --> 00:24:36,880
attempt number two at tackling

00:24:35,919 --> 00:24:40,320
javascript

00:24:36,880 --> 00:24:42,559
uh in the ui so if we go into

00:24:40,320 --> 00:24:43,440
javascript i learned that i needed to

00:24:42,559 --> 00:24:45,520
build

00:24:43,440 --> 00:24:46,559
design mocks before i started coding

00:24:45,520 --> 00:24:48,000
anything

00:24:46,559 --> 00:24:49,760
so that i at least had something that i

00:24:48,000 --> 00:24:50,559
was working towards again i'm not a ui

00:24:49,760 --> 00:24:53,840
designer

00:24:50,559 --> 00:24:55,840
even my mocks were really not that great

00:24:53,840 --> 00:24:58,400
but it gave me something to kind of

00:24:55,840 --> 00:25:01,760
think about how do i represent

00:24:58,400 --> 00:25:03,760
these javascript structures with

00:25:01,760 --> 00:25:05,919
things that are very clear that there

00:25:03,760 --> 00:25:06,559
are two sets of children associated with

00:25:05,919 --> 00:25:10,080
most

00:25:06,559 --> 00:25:12,159
nodes and i came up with some ideas

00:25:10,080 --> 00:25:14,559
uh and then i started implementing again

00:25:12,159 --> 00:25:17,200
and as placeholders i did use some

00:25:14,559 --> 00:25:19,200
characters to symbolize the sort of

00:25:17,200 --> 00:25:21,039
start and end of a set of brackets

00:25:19,200 --> 00:25:22,960
and i used brackets for this you don't

00:25:21,039 --> 00:25:24,159
actually type the brackets in this this

00:25:22,960 --> 00:25:26,720
ui

00:25:24,159 --> 00:25:28,159
um but they sort of were there until i

00:25:26,720 --> 00:25:31,279
could replace them to make it look

00:25:28,159 --> 00:25:32,159
more like the mock later on so this was

00:25:31,279 --> 00:25:34,960
the interface

00:25:32,159 --> 00:25:36,320
it looks like code um but when you

00:25:34,960 --> 00:25:39,360
select a node

00:25:36,320 --> 00:25:42,880
um it highlights the the whole node

00:25:39,360 --> 00:25:46,000
so um this if else is one node

00:25:42,880 --> 00:25:47,279
this sort of declare um declaration of

00:25:46,000 --> 00:25:49,200
variable is one node

00:25:47,279 --> 00:25:50,960
and the declare and as come together as

00:25:49,200 --> 00:25:52,880
a unit you can't you don't have to type

00:25:50,960 --> 00:25:56,320
them individually

00:25:52,880 --> 00:25:59,600
and you could kind of add code

00:25:56,320 --> 00:26:02,720
you could add arguments to this

00:25:59,600 --> 00:26:04,960
console.log call here

00:26:02,720 --> 00:26:06,799
and some parts of the interface were

00:26:04,960 --> 00:26:09,120
working and some parts of the interface

00:26:06,799 --> 00:26:11,600
were not working

00:26:09,120 --> 00:26:13,360
in particular you could do insert uh it

00:26:11,600 --> 00:26:15,840
was reasonably easy to

00:26:13,360 --> 00:26:16,799
code up insert in a tree based system

00:26:15,840 --> 00:26:18,640
because you just kind of

00:26:16,799 --> 00:26:20,000
find a place you can put a cursor you

00:26:18,640 --> 00:26:21,360
put the cursor there you insert a new

00:26:20,000 --> 00:26:23,200
node it's not that bad

00:26:21,360 --> 00:26:24,799
deleting nodes was also reasonably easy

00:26:23,200 --> 00:26:28,000
to implement but

00:26:24,799 --> 00:26:30,080
wrapping a node was incredibly difficult

00:26:28,000 --> 00:26:31,200
to figure out how the user interface

00:26:30,080 --> 00:26:33,440
would work for

00:26:31,200 --> 00:26:35,279
a wrap you could select a node you could

00:26:33,440 --> 00:26:37,120
try and hit a wrap operation

00:26:35,279 --> 00:26:38,960
but that wrap operation doesn't work in

00:26:37,120 --> 00:26:40,799
javascript anywhere near as well as it

00:26:38,960 --> 00:26:43,120
works in html

00:26:40,799 --> 00:26:43,840
in html if you're selecting an element

00:26:43,120 --> 00:26:45,520
and you wrap it

00:26:43,840 --> 00:26:46,960
the only thing that you can wrap it in

00:26:45,520 --> 00:26:49,039
is another element

00:26:46,960 --> 00:26:50,720
and it's very obvious where the original

00:26:49,039 --> 00:26:52,320
element should go it goes in the content

00:26:50,720 --> 00:26:54,559
of the new element

00:26:52,320 --> 00:26:56,159
so it's not that complicated to

00:26:54,559 --> 00:26:58,559
implement rap

00:26:56,159 --> 00:27:00,320
but in javascript it is difficult to

00:26:58,559 --> 00:27:03,360
implement rap

00:27:00,320 --> 00:27:05,679
because as an example let's take this

00:27:03,360 --> 00:27:06,480
plus operator and it has two children so

00:27:05,679 --> 00:27:09,840
this is x

00:27:06,480 --> 00:27:11,039
plus three in tree form and let's say i

00:27:09,840 --> 00:27:14,480
select this node

00:27:11,039 --> 00:27:16,080
and i want to wrap this node in another

00:27:14,480 --> 00:27:17,600
bit of an expression

00:27:16,080 --> 00:27:20,320
and i want to wrap it in a minus

00:27:17,600 --> 00:27:22,399
operation so i select this node i

00:27:20,320 --> 00:27:24,960
in some way i hit the w key or i click

00:27:22,399 --> 00:27:27,120
wrap um but do i mean

00:27:24,960 --> 00:27:28,559
that the minus sign should go on the

00:27:27,120 --> 00:27:31,200
left such that my

00:27:28,559 --> 00:27:33,039
uh original addition isn't to the right

00:27:31,200 --> 00:27:36,159
of that minus so it's something

00:27:33,039 --> 00:27:38,799
minus x plus 3 or do i want it to go

00:27:36,159 --> 00:27:40,640
on the right so that it's x plus 3 minus

00:27:38,799 --> 00:27:42,399
something

00:27:40,640 --> 00:27:44,159
and there's no way to know this and so

00:27:42,399 --> 00:27:46,240
you need to get the user to indicate

00:27:44,159 --> 00:27:47,039
whether they want to wrap left or wrap

00:27:46,240 --> 00:27:49,919
right

00:27:47,039 --> 00:27:50,320
and this honestly just wasn't working

00:27:49,919 --> 00:27:52,640
there

00:27:50,320 --> 00:27:54,559
was no good way to represent this

00:27:52,640 --> 00:27:56,640
because if you're learning to write code

00:27:54,559 --> 00:27:59,840
you don't want to have to learn

00:27:56,640 --> 00:28:01,520
what a left and right map operation is

00:27:59,840 --> 00:28:03,679
so i decided that the solution to this

00:28:01,520 --> 00:28:07,120
was to make the tree structure

00:28:03,679 --> 00:28:07,679
um more visible in the way that you

00:28:07,120 --> 00:28:10,080
write

00:28:07,679 --> 00:28:11,679
code so that when you do add a wrap

00:28:10,080 --> 00:28:13,360
operation it would be much more visible

00:28:11,679 --> 00:28:15,120
what that wrap operation is actually

00:28:13,360 --> 00:28:16,720
doing and in fact all of the tree

00:28:15,120 --> 00:28:18,799
structures would be more visible

00:28:16,720 --> 00:28:20,880
it'd be much more obvious that you're

00:28:18,799 --> 00:28:24,000
working on a tree and not working on

00:28:20,880 --> 00:28:25,760
just a series of text based characters

00:28:24,000 --> 00:28:27,679
so i started experimenting with some

00:28:25,760 --> 00:28:31,120
mocks for different kinds of

00:28:27,679 --> 00:28:31,760
tree structures um to see how they would

00:28:31,120 --> 00:28:33,760
work

00:28:31,760 --> 00:28:35,120
i started to move forward a bit more

00:28:33,760 --> 00:28:37,600
with uh this one

00:28:35,120 --> 00:28:39,279
you can see in this if statement here

00:28:37,600 --> 00:28:40,240
that there's like an equality operator

00:28:39,279 --> 00:28:43,360
so this is basically

00:28:40,240 --> 00:28:46,320
x is equal to a hundred

00:28:43,360 --> 00:28:47,600
as our as our if statement and whenever

00:28:46,320 --> 00:28:48,480
you make a design mark before you're

00:28:47,600 --> 00:28:49,919
implementing

00:28:48,480 --> 00:28:51,600
anything you should show it to people

00:28:49,919 --> 00:28:53,360
and say hey like

00:28:51,600 --> 00:28:55,440
do you understand this what does it mean

00:28:53,360 --> 00:28:56,960
to you and i showed this to people and

00:28:55,440 --> 00:28:58,559
like i don't i don't understand what's

00:28:56,960 --> 00:29:01,039
going on with that equality

00:28:58,559 --> 00:29:02,240
thing and so i decided to make it a

00:29:01,039 --> 00:29:04,799
little bit simpler

00:29:02,240 --> 00:29:06,480
and keep that kind of idea of there's a

00:29:04,799 --> 00:29:10,159
left and a right child

00:29:06,480 --> 00:29:12,399
by structuring it a bit more like this

00:29:10,159 --> 00:29:14,399
so in this top example you have a plus

00:29:12,399 --> 00:29:15,679
100 and it's much easier to figure out

00:29:14,399 --> 00:29:17,520
what's going on

00:29:15,679 --> 00:29:18,559
and this looked fine until i implemented

00:29:17,520 --> 00:29:20,240
it and realized that when you have

00:29:18,559 --> 00:29:22,320
multiple things in the structure it then

00:29:20,240 --> 00:29:24,000
becomes very difficult to read again

00:29:22,320 --> 00:29:25,520
and i showed it to people that like i

00:29:24,000 --> 00:29:27,520
don't get what's going on with this

00:29:25,520 --> 00:29:29,520
thing and you can kind of figure it out

00:29:27,520 --> 00:29:30,880
but only when people would put

00:29:29,520 --> 00:29:32,559
everything in order

00:29:30,880 --> 00:29:36,080
would they be able to understand it so

00:29:32,559 --> 00:29:39,120
this structure only makes sense once you

00:29:36,080 --> 00:29:41,679
interpret it and go okay 8 plus 2

00:29:39,120 --> 00:29:43,600
is equal to a hundred oh okay now i

00:29:41,679 --> 00:29:46,720
understand what that means

00:29:43,600 --> 00:29:49,840
so i decided that things needed to be

00:29:46,720 --> 00:29:52,000
uh actually laid out left to right

00:29:49,840 --> 00:29:54,480
and i came up with this form where the

00:29:52,000 --> 00:29:57,039
tree structure is still reasonably clear

00:29:54,480 --> 00:29:58,399
but you can read it very easily okay yep

00:29:57,039 --> 00:30:01,760
i'm declaring a new variable b

00:29:58,399 --> 00:30:04,080
it is a plus 100 cool

00:30:01,760 --> 00:30:05,760
but again when you start to build a more

00:30:04,080 --> 00:30:08,240
complicated expression

00:30:05,760 --> 00:30:09,279
it then again becomes difficult to read

00:30:08,240 --> 00:30:12,960
and i showed

00:30:09,279 --> 00:30:15,360
this example to people and one person

00:30:12,960 --> 00:30:16,880
was like i i get it now because i can

00:30:15,360 --> 00:30:18,799
read it left to right

00:30:16,880 --> 00:30:20,000
but i don't like that in order to read

00:30:18,799 --> 00:30:22,480
this line my

00:30:20,000 --> 00:30:24,720
eye has to track sideways and then loop

00:30:22,480 --> 00:30:26,240
down and come back up again

00:30:24,720 --> 00:30:28,000
and i showed this to another person and

00:30:26,240 --> 00:30:30,320
they're like i don't understand why does

00:30:28,000 --> 00:30:31,840
the plus come first what does that mean

00:30:30,320 --> 00:30:34,240
and i realized that they were following

00:30:31,840 --> 00:30:35,200
the line rather than reading it left to

00:30:34,240 --> 00:30:37,679
right and so this

00:30:35,200 --> 00:30:40,559
structure was still very unclear and

00:30:37,679 --> 00:30:42,960
non-intuitive to interpret

00:30:40,559 --> 00:30:44,240
and i ended up having to give up one of

00:30:42,960 --> 00:30:46,799
my principles

00:30:44,240 --> 00:30:47,840
and i allowed operator precedence to

00:30:46,799 --> 00:30:50,960
exist

00:30:47,840 --> 00:30:52,720
so for most of the code structure i

00:30:50,960 --> 00:30:53,679
still want it to be a tree it still

00:30:52,720 --> 00:30:56,880
works quite well

00:30:53,679 --> 00:30:58,080
as a tree structure but for operator

00:30:56,880 --> 00:31:00,640
expressions

00:30:58,080 --> 00:31:01,519
um and for sort of expressions of this

00:31:00,640 --> 00:31:04,559
form

00:31:01,519 --> 00:31:06,480
it is a series of tokens that you can

00:31:04,559 --> 00:31:08,240
just add a token to the list

00:31:06,480 --> 00:31:09,679
and then it gets passed when you need to

00:31:08,240 --> 00:31:12,320
pause it

00:31:09,679 --> 00:31:13,200
and this works so much better like this

00:31:12,320 --> 00:31:15,919
is

00:31:13,200 --> 00:31:17,120
this is how uh languages fundamentally

00:31:15,919 --> 00:31:18,000
work and this is how people have been

00:31:17,120 --> 00:31:21,679
doing maths

00:31:18,000 --> 00:31:24,480
since they were a child in a language um

00:31:21,679 --> 00:31:25,600
in english or other sort of similarly

00:31:24,480 --> 00:31:28,240
structured languages

00:31:25,600 --> 00:31:28,799
when you have a preposition you say the

00:31:28,240 --> 00:31:32,559
cat

00:31:28,799 --> 00:31:35,440
is in or the cat's in the tree

00:31:32,559 --> 00:31:36,000
and that is how we think we think in

00:31:35,440 --> 00:31:37,919
words

00:31:36,000 --> 00:31:39,440
and that is how mathematics is

00:31:37,919 --> 00:31:42,080
structured as well because you that's

00:31:39,440 --> 00:31:45,279
why you put the operator in between

00:31:42,080 --> 00:31:46,799
um a and b so it's a plus b

00:31:45,279 --> 00:31:47,760
and you can read that and think about

00:31:46,799 --> 00:31:49,279
that in the same way that you think

00:31:47,760 --> 00:31:51,200
about an english sentence

00:31:49,279 --> 00:31:53,840
and making things into some kind of tree

00:31:51,200 --> 00:31:57,120
form doesn't actually make them clearer

00:31:53,840 --> 00:31:58,480
for this particular kind of thing so

00:31:57,120 --> 00:32:00,480
i had to give up on my goal of not

00:31:58,480 --> 00:32:03,120
having having operator precedence

00:32:00,480 --> 00:32:03,600
but the operator precedence is limited

00:32:03,120 --> 00:32:05,919
to

00:32:03,600 --> 00:32:07,360
just these standard uh left and right

00:32:05,919 --> 00:32:11,039
side binary operators

00:32:07,360 --> 00:32:12,799
and unary operators rather than being

00:32:11,039 --> 00:32:14,880
a series of tokens is how the entire

00:32:12,799 --> 00:32:16,480
code is interpreted which is what text

00:32:14,880 --> 00:32:19,039
code is

00:32:16,480 --> 00:32:20,880
so the rest of the code is still

00:32:19,039 --> 00:32:22,640
fundamentally tree structured

00:32:20,880 --> 00:32:24,640
function arguments are still sort of

00:32:22,640 --> 00:32:28,080
represented as this tree

00:32:24,640 --> 00:32:29,679
list our if statement still has um a

00:32:28,080 --> 00:32:30,880
child which is represented in a

00:32:29,679 --> 00:32:32,559
tree-like way and

00:32:30,880 --> 00:32:34,159
a series of statements in the body which

00:32:32,559 --> 00:32:34,960
is also represented in this kind of

00:32:34,159 --> 00:32:38,399
nested

00:32:34,960 --> 00:32:40,640
indenting tree structure but

00:32:38,399 --> 00:32:42,080
the expressions themselves i have caved

00:32:40,640 --> 00:32:43,039
and gone in with more of a token

00:32:42,080 --> 00:32:44,559
approach

00:32:43,039 --> 00:32:46,240
it's still a little bit easier than tax

00:32:44,559 --> 00:32:48,880
code because the tokens

00:32:46,240 --> 00:32:50,480
are already tokenized for you um and

00:32:48,880 --> 00:32:51,919
it's not just a series of characters it

00:32:50,480 --> 00:32:53,840
is a series of tokens

00:32:51,919 --> 00:32:54,960
but it is a little bit more in that

00:32:53,840 --> 00:32:58,159
halfway ground

00:32:54,960 --> 00:33:01,519
between a full tree structure and a

00:32:58,159 --> 00:33:04,080
text like code structure

00:33:01,519 --> 00:33:05,840
okay so this one started to work better

00:33:04,080 --> 00:33:07,120
it started to become easier to edit it

00:33:05,840 --> 00:33:09,360
started to become easier to

00:33:07,120 --> 00:33:11,679
develop more features and make it more

00:33:09,360 --> 00:33:14,880
usable so i developed it further

00:33:11,679 --> 00:33:18,000
and this is what i have

00:33:14,880 --> 00:33:20,240
right now so this is a video and

00:33:18,000 --> 00:33:21,760
although i started off building again a

00:33:20,240 --> 00:33:23,919
javascript interface

00:33:21,760 --> 00:33:26,559
with this tree structure once i had a

00:33:23,919 --> 00:33:27,440
working system i was able to add in html

00:33:26,559 --> 00:33:29,840
as well

00:33:27,440 --> 00:33:30,799
such that you can create html and then

00:33:29,840 --> 00:33:33,840
add a script tag

00:33:30,799 --> 00:33:36,799
so here we have an html document

00:33:33,840 --> 00:33:38,000
has a head and a body in that body i can

00:33:36,799 --> 00:33:40,399
create an image element

00:33:38,000 --> 00:33:43,120
i can give it attributes in this case

00:33:40,399 --> 00:33:45,600
i'm adding a picture of a kitten

00:33:43,120 --> 00:33:46,960
i create a heading tag i can then put

00:33:45,600 --> 00:33:48,720
some text content

00:33:46,960 --> 00:33:50,399
in that heading and again because this

00:33:48,720 --> 00:33:53,200
is a string

00:33:50,399 --> 00:33:54,240
node it does not have any concept of

00:33:53,200 --> 00:33:56,640
escaping in it

00:33:54,240 --> 00:33:58,399
so you could put quote marks or anything

00:33:56,640 --> 00:33:59,360
that you want to inside that string and

00:33:58,399 --> 00:34:01,919
it will just

00:33:59,360 --> 00:34:03,039
work now that i've built a script tag

00:34:01,919 --> 00:34:05,279
here

00:34:03,039 --> 00:34:07,279
inside the script tag the interface

00:34:05,279 --> 00:34:08,800
knows that this is where javascript goes

00:34:07,279 --> 00:34:10,800
and not a place where it should be order

00:34:08,800 --> 00:34:13,359
completing other html elements

00:34:10,800 --> 00:34:15,440
so i can start writing actual javascript

00:34:13,359 --> 00:34:17,280
code here

00:34:15,440 --> 00:34:20,800
and it's got some autocomplete so i've

00:34:17,280 --> 00:34:23,359
got document.getelementbyid

00:34:20,800 --> 00:34:25,839
um i'll add an id back on that heading

00:34:23,359 --> 00:34:29,040
tag so that i can get that id

00:34:25,839 --> 00:34:32,800
here and

00:34:29,040 --> 00:34:35,520
on the next line i can then take that

00:34:32,800 --> 00:34:37,359
heading element object and i can

00:34:35,520 --> 00:34:40,399
manipulate it

00:34:37,359 --> 00:34:41,599
so i'm writing fairly standard um pure

00:34:40,399 --> 00:34:44,240
javascript code

00:34:41,599 --> 00:34:45,919
here and it's taking that text content

00:34:44,240 --> 00:34:48,879
and it's replacing the text content

00:34:45,919 --> 00:34:49,599
of that heading tag now the order

00:34:48,879 --> 00:34:52,159
refresh

00:34:49,599 --> 00:34:53,520
um isn't fully implemented yet so i do

00:34:52,159 --> 00:34:56,079
need to

00:34:53,520 --> 00:34:57,440
skip forward a little bit to where it's

00:34:56,079 --> 00:35:00,160
refreshed

00:34:57,440 --> 00:35:02,320
um so i go up to the top i sort of go to

00:35:00,160 --> 00:35:05,200
another page and come back

00:35:02,320 --> 00:35:06,800
and when it reloads that javascript is

00:35:05,200 --> 00:35:08,960
being executed

00:35:06,800 --> 00:35:10,720
and the contents of that heading tag has

00:35:08,960 --> 00:35:14,960
been changed

00:35:10,720 --> 00:35:14,960
so this is a fairly simple example

00:35:15,040 --> 00:35:20,720
um but it does work it doesn't work

00:35:18,240 --> 00:35:22,560
in every way that i want this system to

00:35:20,720 --> 00:35:24,000
work you still have to remember

00:35:22,560 --> 00:35:25,599
to a certain extent the tags and

00:35:24,000 --> 00:35:26,320
functions and variables that you want to

00:35:25,599 --> 00:35:28,560
use

00:35:26,320 --> 00:35:30,640
because there is auto complete but again

00:35:28,560 --> 00:35:32,160
it's only as good as autocomplete can be

00:35:30,640 --> 00:35:33,280
you have to kind of start typing what

00:35:32,160 --> 00:35:35,359
you want before it would really

00:35:33,280 --> 00:35:37,520
auto-complete in a useful way

00:35:35,359 --> 00:35:38,560
i still have the dot operator for member

00:35:37,520 --> 00:35:41,599
expressions

00:35:38,560 --> 00:35:43,920
um and you still have to remember

00:35:41,599 --> 00:35:45,520
the variable and function parameter

00:35:43,920 --> 00:35:46,640
types even though the labels are there

00:35:45,520 --> 00:35:48,480
for something so

00:35:46,640 --> 00:35:50,880
what it does have it does have

00:35:48,480 --> 00:35:54,400
autocomplete for

00:35:50,880 --> 00:35:56,400
most built-in javascript things and

00:35:54,400 --> 00:35:57,760
even though there is a dot operator here

00:35:56,400 --> 00:35:59,839
for a member expression

00:35:57,760 --> 00:36:01,599
it's kind of represented in a way that

00:35:59,839 --> 00:36:03,520
helps you understand what's going on it

00:36:01,599 --> 00:36:06,320
has this kind of little arrow bit

00:36:03,520 --> 00:36:07,599
here which is like the breadcrumbs that

00:36:06,320 --> 00:36:10,800
you might see

00:36:07,599 --> 00:36:11,599
on a website which show you that this

00:36:10,800 --> 00:36:13,359
thing is like

00:36:11,599 --> 00:36:15,040
this is where you are in the navigation

00:36:13,359 --> 00:36:15,839
tree of the website so it's a little bit

00:36:15,040 --> 00:36:18,640
like that

00:36:15,839 --> 00:36:20,240
there's autocomplete there is also uh

00:36:18,640 --> 00:36:21,040
automatically labeled function

00:36:20,240 --> 00:36:23,440
parameters

00:36:21,040 --> 00:36:25,440
for built-in javascript types as well i

00:36:23,440 --> 00:36:26,320
find with set timeout in javascript i

00:36:25,440 --> 00:36:28,800
always forget

00:36:26,320 --> 00:36:30,800
that the timeout value goes second and

00:36:28,800 --> 00:36:31,520
when these are automatically labeled for

00:36:30,800 --> 00:36:33,760
you

00:36:31,520 --> 00:36:35,040
uh it's much easier to figure out which

00:36:33,760 --> 00:36:37,920
parameter goes where

00:36:35,040 --> 00:36:38,800
so those labels are there you don't have

00:36:37,920 --> 00:36:40,400
to type them

00:36:38,800 --> 00:36:44,000
and they're sort of shown in the ui in a

00:36:40,400 --> 00:36:44,000
fairly unobtrusive way

00:36:44,480 --> 00:36:47,839
so yeah it's at the point where you can

00:36:46,320 --> 00:36:51,359
build something that is

00:36:47,839 --> 00:36:52,720
um not necessarily a real world project

00:36:51,359 --> 00:36:53,440
i haven't implemented all of the

00:36:52,720 --> 00:36:56,400
javascript

00:36:53,440 --> 00:36:58,800
syntax yet but you can build um enough

00:36:56,400 --> 00:37:02,160
of a website that it might actually

00:36:58,800 --> 00:37:04,160
do something so in this example

00:37:02,160 --> 00:37:05,520
i've got quite a bit of javascript code

00:37:04,160 --> 00:37:06,160
here i'm not expecting you to read all

00:37:05,520 --> 00:37:07,760
of it

00:37:06,160 --> 00:37:10,000
there are sort of three separate

00:37:07,760 --> 00:37:11,440
functions including setting like an

00:37:10,000 --> 00:37:14,240
onload handler

00:37:11,440 --> 00:37:15,440
um and this sets up an html canvas

00:37:14,240 --> 00:37:18,560
element

00:37:15,440 --> 00:37:21,680
which uh has a ball that bounces around

00:37:18,560 --> 00:37:24,640
like it's very exciting um but

00:37:21,680 --> 00:37:25,119
you can build actual javascript code in

00:37:24,640 --> 00:37:28,640
this

00:37:25,119 --> 00:37:30,160
in this system now um

00:37:28,640 --> 00:37:32,320
and when you're building javascript code

00:37:30,160 --> 00:37:34,720
using this system you don't need to

00:37:32,320 --> 00:37:36,160
remember these arbitrary symbols and

00:37:34,720 --> 00:37:39,599
punctuations braces

00:37:36,160 --> 00:37:40,960
and html tags you just need to

00:37:39,599 --> 00:37:43,200
the only things that you need to learn

00:37:40,960 --> 00:37:44,000
are the actual semantic meanings of what

00:37:43,200 --> 00:37:47,040
the things

00:37:44,000 --> 00:37:49,359
are you don't need to have escaping

00:37:47,040 --> 00:37:50,720
rules either for html or for javascript

00:37:49,359 --> 00:37:53,119
which makes it easier to sort of

00:37:50,720 --> 00:37:54,720
seamlessly move between the two

00:37:53,119 --> 00:37:56,800
i did gave and there is still some

00:37:54,720 --> 00:37:57,760
operator precedence but i have made

00:37:56,800 --> 00:38:00,880
things like and

00:37:57,760 --> 00:38:04,000
and or into structured tree elements

00:38:00,880 --> 00:38:06,240
rather than tokens so you can limit

00:38:04,000 --> 00:38:07,599
how much operator precedence actually

00:38:06,240 --> 00:38:08,880
affects the things that you have to

00:38:07,599 --> 00:38:10,160
learn

00:38:08,880 --> 00:38:12,320
you also don't need to remember function

00:38:10,160 --> 00:38:13,599
parameter names although that only works

00:38:12,320 --> 00:38:13,920
for built-in functions right now i do

00:38:13,599 --> 00:38:15,680
not

00:38:13,920 --> 00:38:17,440
infer them for functions that you create

00:38:15,680 --> 00:38:19,680
yourself

00:38:17,440 --> 00:38:21,520
so this is uh this is what i've got so

00:38:19,680 --> 00:38:24,640
far i've called it sploot code

00:38:21,520 --> 00:38:25,520
uh you can find it on github uh if you

00:38:24,640 --> 00:38:28,240
want to have

00:38:25,520 --> 00:38:29,920
progress updates uh there is a website

00:38:28,240 --> 00:38:32,560
with splutco.org you can sign up to like

00:38:29,920 --> 00:38:36,240
a mailing list and get updates on it

00:38:32,560 --> 00:38:38,960
um i'm still very much at the beginning

00:38:36,240 --> 00:38:39,440
of this journey there is a lot more to

00:38:38,960 --> 00:38:41,200
go

00:38:39,440 --> 00:38:43,680
before i have a complete implementation

00:38:41,200 --> 00:38:44,560
of javascript and before the system is

00:38:43,680 --> 00:38:47,200
usable

00:38:44,560 --> 00:38:49,200
there's a lot more to go in terms of

00:38:47,200 --> 00:38:52,240
making it easier to get started

00:38:49,200 --> 00:38:53,200
and to find the programming tools

00:38:52,240 --> 00:38:55,119
available to you

00:38:53,200 --> 00:38:57,359
if you don't already know what to write

00:38:55,119 --> 00:38:59,680
so that blank page problem is still a

00:38:57,359 --> 00:39:01,760
problem i'm still working on that

00:38:59,680 --> 00:39:04,160
but it's at a point where i think

00:39:01,760 --> 00:39:06,560
there's promise here i think there's

00:39:04,160 --> 00:39:08,079
um it's starting to get to the point

00:39:06,560 --> 00:39:10,240
where you can write code

00:39:08,079 --> 00:39:11,440
and you're typing fewer characters than

00:39:10,240 --> 00:39:12,880
you would have to type

00:39:11,440 --> 00:39:14,800
you're hitting fewer keystrokes than you

00:39:12,880 --> 00:39:18,560
would have to type to

00:39:14,800 --> 00:39:19,440
code in javascript and you can still

00:39:18,560 --> 00:39:22,960
build

00:39:19,440 --> 00:39:25,280
complicated bits of javascript code so

00:39:22,960 --> 00:39:26,640
it's really it's making progress um i'm

00:39:25,280 --> 00:39:28,079
excited about where it's going and i'm

00:39:26,640 --> 00:39:29,760
going to be continuing to work on this

00:39:28,079 --> 00:39:31,760
if you would like to join me that would

00:39:29,760 --> 00:39:33,200
be amazing i particularly need to help

00:39:31,760 --> 00:39:34,320
need help with ui design if you know

00:39:33,200 --> 00:39:35,920
anyone that's

00:39:34,320 --> 00:39:38,800
interested in working on a very

00:39:35,920 --> 00:39:42,320
difficult ui design challenge

00:39:38,800 --> 00:39:42,640
anyway that is uh all i have to explain

00:39:42,320 --> 00:39:45,040
i

00:39:42,640 --> 00:39:45,680
do have time for questions uh which is

00:39:45,040 --> 00:39:49,040
great

00:39:45,680 --> 00:39:50,880
and i will be around in the chat

00:39:49,040 --> 00:39:51,839
afterwards as well and i'm fairly easy

00:39:50,880 --> 00:39:55,200
to contact

00:39:51,839 --> 00:39:57,520
um either online or on twitter so yeah

00:39:55,200 --> 00:39:59,280
thank you so much katie that was amazing

00:39:57,520 --> 00:40:02,240
i certainly learnt a lot

00:39:59,280 --> 00:40:03,440
um and the visuals are really great um

00:40:02,240 --> 00:40:05,040
and i don't know i don't know if you

00:40:03,440 --> 00:40:06,319
need help with user interface because

00:40:05,040 --> 00:40:08,000
you seem to be

00:40:06,319 --> 00:40:09,440
all over it checking in with people

00:40:08,000 --> 00:40:11,440
seeing if they can see

00:40:09,440 --> 00:40:13,040
how it works the tree structures so

00:40:11,440 --> 00:40:13,839
that's great there's been a lot of

00:40:13,040 --> 00:40:16,000
lively chatter

00:40:13,839 --> 00:40:17,200
on the venulis chat but we do have some

00:40:16,000 --> 00:40:20,960
questions for you

00:40:17,200 --> 00:40:24,240
so first up how does the html

00:40:20,960 --> 00:40:27,839
editor handle adding text tags like am

00:40:24,240 --> 00:40:29,200
bolding tags inside the text notes

00:40:27,839 --> 00:40:31,280
uh that is a really great question the

00:40:29,200 --> 00:40:33,359
answer is it doesn't um that is

00:40:31,280 --> 00:40:35,040
another ui challenge that i have not

00:40:33,359 --> 00:40:37,359
solved yet

00:40:35,040 --> 00:40:38,400
um there are there are ways to do this

00:40:37,359 --> 00:40:41,760
so

00:40:38,400 --> 00:40:42,319
um with several of the even the open

00:40:41,760 --> 00:40:45,040
source

00:40:42,319 --> 00:40:45,520
uh text sort of text editor windows out

00:40:45,040 --> 00:40:48,000
there

00:40:45,520 --> 00:40:48,640
you can have text editors in an

00:40:48,000 --> 00:40:52,160
interface

00:40:48,640 --> 00:40:54,560
which let you add sort of widgets inside

00:40:52,160 --> 00:40:55,760
the text in the flow of the text so it

00:40:54,560 --> 00:40:58,079
is solvable from

00:40:55,760 --> 00:40:59,440
a ui perspective but that's a great

00:40:58,079 --> 00:41:01,359
question because it's very clear like

00:40:59,440 --> 00:41:02,960
from the interface that i've got so far

00:41:01,359 --> 00:41:04,720
that doesn't work at all and if you

00:41:02,960 --> 00:41:08,480
wanted to put say

00:41:04,720 --> 00:41:10,800
a bold uh tag inside some text

00:41:08,480 --> 00:41:12,400
you would have to create separate text

00:41:10,800 --> 00:41:14,560
notes you'd have like a text node

00:41:12,400 --> 00:41:16,720
then a bold node with the text in it and

00:41:14,560 --> 00:41:19,359
then another text node afterwards

00:41:16,720 --> 00:41:21,359
and having them spaced vertically in the

00:41:19,359 --> 00:41:23,520
ui is not a great

00:41:21,359 --> 00:41:25,760
ui for that but you anything that you

00:41:23,520 --> 00:41:27,839
can write in html you can actually write

00:41:25,760 --> 00:41:29,839
in this interface still it's just there

00:41:27,839 --> 00:41:32,560
is a much easier way to do it

00:41:29,839 --> 00:41:34,079
uh which i have not implemented yet so

00:41:32,560 --> 00:41:37,119
great question

00:41:34,079 --> 00:41:39,839
okay so up next um how does

00:41:37,119 --> 00:41:40,720
the html editor handle oh sorry we've

00:41:39,839 --> 00:41:42,480
got that one already

00:41:40,720 --> 00:41:44,800
let there be a plug-in architecture to

00:41:42,480 --> 00:41:46,960
do all the languages

00:41:44,800 --> 00:41:48,720
ah this is something that i learned very

00:41:46,960 --> 00:41:50,640
well from going through multiple

00:41:48,720 --> 00:41:53,119
prototypes in the early prototypes

00:41:50,640 --> 00:41:54,800
i had to write a lot of custom code and

00:41:53,119 --> 00:41:58,079
a lot of repetitive code

00:41:54,800 --> 00:42:01,200
to add new language features to it

00:41:58,079 --> 00:42:02,960
and in the fourth prototype i

00:42:01,200 --> 00:42:05,440
got rid of that and i started writing a

00:42:02,960 --> 00:42:09,440
kind of generic system

00:42:05,440 --> 00:42:10,000
for doing a adding a node to the

00:42:09,440 --> 00:42:13,760
language

00:42:10,000 --> 00:42:17,119
so in the code if you want to add a node

00:42:13,760 --> 00:42:19,040
to the language uh you create a kind of

00:42:17,119 --> 00:42:20,560
subclass of the node object

00:42:19,040 --> 00:42:22,720
you set a bunch of parameters and you

00:42:20,560 --> 00:42:24,880
set essentially maybe this much code to

00:42:22,720 --> 00:42:27,680
define how that node should be

00:42:24,880 --> 00:42:29,520
laid out in the ui and what children are

00:42:27,680 --> 00:42:30,800
allowed to be added to that node

00:42:29,520 --> 00:42:33,440
and so it's kind of this plug-in

00:42:30,800 --> 00:42:36,480
architecture where you can add a node

00:42:33,440 --> 00:42:37,200
to the language relatively easily one of

00:42:36,480 --> 00:42:39,839
the advantages

00:42:37,200 --> 00:42:41,040
is in this in the future is that people

00:42:39,839 --> 00:42:42,240
could potentially define their own

00:42:41,040 --> 00:42:45,440
custom nodes

00:42:42,240 --> 00:42:47,119
and adapting the ui to a new language

00:42:45,440 --> 00:42:50,000
would actually be pretty straightforward

00:42:47,119 --> 00:42:52,079
uh which is why when i had gotten a

00:42:50,000 --> 00:42:56,079
working javascript implementation

00:42:52,079 --> 00:42:58,000
it was actually very easy to add html

00:42:56,079 --> 00:42:59,200
nodes as well because this node

00:42:58,000 --> 00:43:03,119
architecture was actually

00:42:59,200 --> 00:43:04,560
quite pluggable yeah so

00:43:03,119 --> 00:43:05,839
yes eventually maybe there will be a

00:43:04,560 --> 00:43:06,560
plug-in architecture to do all the

00:43:05,839 --> 00:43:09,280
languages

00:43:06,560 --> 00:43:11,920
uh but i would like to get at least one

00:43:09,280 --> 00:43:11,920
working first

00:43:14,720 --> 00:43:19,280
okay so next uh question any thoughts on

00:43:17,680 --> 00:43:20,960
referencing other variables

00:43:19,280 --> 00:43:22,480
function pointers other than just by

00:43:20,960 --> 00:43:24,240
name

00:43:22,480 --> 00:43:26,079
uh yeah this is really great um this is

00:43:24,240 --> 00:43:27,680
one of the things that i think is a real

00:43:26,079 --> 00:43:28,319
advantage that you could have to a

00:43:27,680 --> 00:43:32,000
structured

00:43:28,319 --> 00:43:33,920
node 3 based language instead of having

00:43:32,000 --> 00:43:35,280
just a text string for a variable name

00:43:33,920 --> 00:43:38,000
it could be just

00:43:35,280 --> 00:43:39,119
a straight up internal reference to a

00:43:38,000 --> 00:43:40,800
variable

00:43:39,119 --> 00:43:42,319
the tricky thing about that is you you

00:43:40,800 --> 00:43:44,560
have to be very careful how that

00:43:42,319 --> 00:43:46,079
variable is represented to the user

00:43:44,560 --> 00:43:48,160
because named variables are very

00:43:46,079 --> 00:43:51,760
convenient way to show

00:43:48,160 --> 00:43:54,480
to the user what variable this is um

00:43:51,760 --> 00:43:55,040
at the moment in my interface a variable

00:43:54,480 --> 00:43:57,760
reference

00:43:55,040 --> 00:43:58,640
is just a string reference it's exactly

00:43:57,760 --> 00:44:00,960
the same as

00:43:58,640 --> 00:44:01,680
an identifier in the abstract syntax

00:44:00,960 --> 00:44:03,359
tree

00:44:01,680 --> 00:44:05,440
i do want to change this i do want to

00:44:03,359 --> 00:44:08,079
implement exactly what it is that you're

00:44:05,440 --> 00:44:09,040
uh talking about there which is when you

00:44:08,079 --> 00:44:10,480
define a variable

00:44:09,040 --> 00:44:12,400
anything that references that variable

00:44:10,480 --> 00:44:14,240
is a direct reference to this

00:44:12,400 --> 00:44:15,920
i haven't implemented yet it yet because

00:44:14,240 --> 00:44:17,520
it gets a little complicated when you're

00:44:15,920 --> 00:44:20,640
dealing with things like

00:44:17,520 --> 00:44:23,839
shadowed variables from another scope

00:44:20,640 --> 00:44:25,040
um when i show you a variable name in

00:44:23,839 --> 00:44:27,280
the ui

00:44:25,040 --> 00:44:28,800
i need to know i need to make it clear

00:44:27,280 --> 00:44:31,200
to the user somehow

00:44:28,800 --> 00:44:33,760
whether this is a variable in the local

00:44:31,200 --> 00:44:36,960
scope or a variable in a global scope

00:44:33,760 --> 00:44:40,000
that is the same name and in

00:44:36,960 --> 00:44:40,720
text code this is confusing a lot of the

00:44:40,000 --> 00:44:43,680
time

00:44:40,720 --> 00:44:44,400
but because the variable is just a

00:44:43,680 --> 00:44:47,520
string

00:44:44,400 --> 00:44:49,440
name it's a runtime problem

00:44:47,520 --> 00:44:51,440
uh whether or not it's the local scope

00:44:49,440 --> 00:44:54,079
or the global scope

00:44:51,440 --> 00:44:55,920
in a system where that variable

00:44:54,079 --> 00:44:57,200
reference is a direct reference to a

00:44:55,920 --> 00:44:59,760
variable

00:44:57,200 --> 00:45:01,680
it's confusing because it's probably

00:44:59,760 --> 00:45:03,520
referencing whichever variable was

00:45:01,680 --> 00:45:04,960
the variable of that name in the local

00:45:03,520 --> 00:45:05,760
scope or in the global scope when you

00:45:04,960 --> 00:45:07,119
wrote the code

00:45:05,760 --> 00:45:09,040
regardless of the changes that have to

00:45:07,119 --> 00:45:11,440
that code afterwards so it is an

00:45:09,040 --> 00:45:14,160
interesting problem how do you represent

00:45:11,440 --> 00:45:14,960
that that variable is of a particular

00:45:14,160 --> 00:45:17,359
scope

00:45:14,960 --> 00:45:18,000
even if someone might have created a new

00:45:17,359 --> 00:45:20,560
variable

00:45:18,000 --> 00:45:21,040
in a different scope of the same name

00:45:20,560 --> 00:45:23,920
wow

00:45:21,040 --> 00:45:24,880
so that it gets hard but yes absolutely

00:45:23,920 --> 00:45:28,240
i want to do that

00:45:24,880 --> 00:45:30,560
yes that's great okay so we'll

00:45:28,240 --> 00:45:32,800
we'll leave it there um thank you so

00:45:30,560 --> 00:45:34,720
much for presenting that was amazing

00:45:32,800 --> 00:45:37,119
and i think you said also that you're

00:45:34,720 --> 00:45:39,280
happy to take questions in venulis

00:45:37,119 --> 00:45:40,240
after the presentation and in the post

00:45:39,280 --> 00:45:43,359
talk q a

00:45:40,240 --> 00:45:44,560
channel um so we're going to take a

00:45:43,359 --> 00:45:47,599
lunch break now

00:45:44,560 --> 00:45:51,040
uh we're back here at 1 30. um

00:45:47,599 --> 00:45:53,520
and presenting next at the rusty rh hall

00:45:51,040 --> 00:45:55,920
is john manning with his talk on let's

00:45:53,520 --> 00:45:57,680
use an automated fear improver to verify

00:45:55,920 --> 00:45:59,599
video games and he swears

00:45:57,680 --> 00:46:00,960
that this is more fun than it sounds so

00:45:59,599 --> 00:46:10,880
we look forward to that

00:46:00,960 --> 00:46:10,880

YouTube URL: https://www.youtube.com/watch?v=UH0A2iujtY8


