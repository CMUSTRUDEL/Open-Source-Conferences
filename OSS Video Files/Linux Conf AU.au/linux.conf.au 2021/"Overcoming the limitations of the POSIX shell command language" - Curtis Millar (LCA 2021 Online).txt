Title: "Overcoming the limitations of the POSIX shell command language" - Curtis Millar (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Curtis Millar

https://lca2021.linux.org.au/schedule/presentation/32/

Shell scripts in all their incarnations have been the go-to for constructing portable glue that interacts with other scripts and programs. With the evolution of UNIX, the introduction of the POSIX Shell Command Language gave us a standardised shell language the is the most common mechanism for distributing code to operate in the most diverse of situations.

Whilst many shell implementations extend upon this standard to make it more usable, this talk will see how we can produce more expressive programming primitives to allow for truly composable and portable shell scripts, showing what the true power of the POSIX shell standard is, where the pain points lie, and why this standard is ultimately restricted in what it can provide.

Given the amount of effort required to make shell scripts that are both portable and reusable, we'll also discuss when you should reach for a shell script and when its best to reach for something more powerful, even if that power brings problems of its own.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Mon Jan 25 10:45:00 2021 at Rusty R. Hall
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,200 --> 00:00:19,600
ca 2021

00:00:16,800 --> 00:00:21,039
we have a great day ahead uh for you all

00:00:19,600 --> 00:00:23,680
in the rusty our hall

00:00:21,039 --> 00:00:24,800
room um first up we'll be hearing from

00:00:23,680 --> 00:00:27,439
curtis miller

00:00:24,800 --> 00:00:28,400
who is presenting uh overcoming the

00:00:27,439 --> 00:00:33,200
limitations

00:00:28,400 --> 00:00:34,800
of posex shell command language

00:00:33,200 --> 00:00:36,719
curtis will be happy to take questions

00:00:34,800 --> 00:00:38,719
in the last five minutes of this session

00:00:36,719 --> 00:00:40,000
so please post your questions questions

00:00:38,719 --> 00:00:41,600
in venulis

00:00:40,000 --> 00:00:43,280
you might see that there's a new

00:00:41,600 --> 00:00:45,280
questions tab so

00:00:43,280 --> 00:00:47,760
feel free to use that and we'll help

00:00:45,280 --> 00:00:51,840
moderate those questions at the end

00:00:47,760 --> 00:00:55,360
um i'll now hand over to you curtis

00:00:51,840 --> 00:00:57,199
thanks ariana um as i

00:00:55,360 --> 00:00:59,039
said this is overcoming the limitations

00:00:57,199 --> 00:01:00,719
of the posix command shell or

00:00:59,039 --> 00:01:02,640
how i learned to stop worrying and love

00:01:00,719 --> 00:01:04,799
eval i'm curtis miller

00:01:02,640 --> 00:01:06,240
i am a research engineer working for

00:01:04,799 --> 00:01:09,439
unsw sydney and

00:01:06,240 --> 00:01:12,320
as an affiliate with csiro's data61

00:01:09,439 --> 00:01:13,840
i work on the sel4 micro kernel and

00:01:12,320 --> 00:01:15,920
several systems that

00:01:13,840 --> 00:01:17,520
interoperate with that but that's not

00:01:15,920 --> 00:01:19,040
what i'm here to talk about today today

00:01:17,520 --> 00:01:20,479
i'm talking about posix

00:01:19,040 --> 00:01:22,240
and the posit command shell and

00:01:20,479 --> 00:01:25,439
particularly some ways

00:01:22,240 --> 00:01:25,759
in which it is problematic most notably

00:01:25,439 --> 00:01:28,799
its

00:01:25,759 --> 00:01:30,240
approach to global variable scope

00:01:28,799 --> 00:01:32,159
i'll also introduce some ways that we

00:01:30,240 --> 00:01:33,920
could use uh the tools available within

00:01:32,159 --> 00:01:35,840
posix to resolve this to introduce

00:01:33,920 --> 00:01:37,920
function scope and name spacing

00:01:35,840 --> 00:01:39,920
as well as import the collection of

00:01:37,920 --> 00:01:41,280
tools i have put together to make this

00:01:39,920 --> 00:01:43,360
actually usable

00:01:41,280 --> 00:01:44,720
um and then i'll finish up with an

00:01:43,360 --> 00:01:45,759
overview of some lessons learned in

00:01:44,720 --> 00:01:48,079
developing this

00:01:45,759 --> 00:01:50,320
and maybe evaluating when and when not

00:01:48,079 --> 00:01:53,119
this might be a good idea

00:01:50,320 --> 00:01:54,560
so the posix command shell or first up

00:01:53,119 --> 00:01:57,040
posix itself posix

00:01:54,560 --> 00:01:59,280
is an operating system interface

00:01:57,040 --> 00:02:01,520
standard so it's a general standard

00:01:59,280 --> 00:02:03,200
on an interface that an operating system

00:02:01,520 --> 00:02:05,200
provides that any software running on

00:02:03,200 --> 00:02:07,439
that operating system should expect

00:02:05,200 --> 00:02:09,440
to exist and behave in a certain way

00:02:07,439 --> 00:02:10,239
it's distilled from a number of unix

00:02:09,440 --> 00:02:12,400
derivatives

00:02:10,239 --> 00:02:14,080
uh from the uh at the point in the late

00:02:12,400 --> 00:02:16,640
80s that they had all reached

00:02:14,080 --> 00:02:18,160
it includes a c language api so function

00:02:16,640 --> 00:02:20,480
bindings that need to exist

00:02:18,160 --> 00:02:22,080
for programs written in c or that are

00:02:20,480 --> 00:02:25,120
interoperable with the

00:02:22,080 --> 00:02:26,160
ffi file system layout requirements the

00:02:25,120 --> 00:02:27,760
existing

00:02:26,160 --> 00:02:30,319
the existence of certain directories and

00:02:27,760 --> 00:02:32,720
things within directories

00:02:30,319 --> 00:02:34,080
the specification for the shell command

00:02:32,720 --> 00:02:36,480
language

00:02:34,080 --> 00:02:37,920
the syntax and the um semantics of that

00:02:36,480 --> 00:02:40,239
language and many other

00:02:37,920 --> 00:02:42,000
features of that interface exist but the

00:02:40,239 --> 00:02:43,680
one i care about most today is the posix

00:02:42,000 --> 00:02:45,840
command shell language

00:02:43,680 --> 00:02:47,200
it's a high-level language specification

00:02:45,840 --> 00:02:49,280
it exists to invoke

00:02:47,200 --> 00:02:50,480
other programs and applications within

00:02:49,280 --> 00:02:52,160
the operating system

00:02:50,480 --> 00:02:55,200
and allow them to communicate with each

00:02:52,160 --> 00:02:58,080
other and sequence them together

00:02:55,200 --> 00:02:59,920
it lives uh as a process at slash bin

00:02:58,080 --> 00:03:02,640
sure

00:02:59,920 --> 00:03:03,680
and for an operating system to be posix

00:03:02,640 --> 00:03:05,760
compliant

00:03:03,680 --> 00:03:07,840
that process that application has to

00:03:05,760 --> 00:03:10,480
exist at that directory and has to

00:03:07,840 --> 00:03:12,560
uh behave as described by the posix

00:03:10,480 --> 00:03:14,640
command shell specification

00:03:12,560 --> 00:03:16,840
this language is often extended in other

00:03:14,640 --> 00:03:18,000
shells such as bash and zsh and many

00:03:16,840 --> 00:03:20,879
others

00:03:18,000 --> 00:03:23,760
but what i care about today is the uh

00:03:20,879 --> 00:03:27,200
only the parts specified by the posix

00:03:23,760 --> 00:03:28,640
standard it's useful to have

00:03:27,200 --> 00:03:30,640
a high-level language as part of the

00:03:28,640 --> 00:03:32,720
operating system standard

00:03:30,640 --> 00:03:34,000
it's a language that uh specifically

00:03:32,720 --> 00:03:35,760
particularly one that is

00:03:34,000 --> 00:03:38,239
platform and architecture agnostic so

00:03:35,760 --> 00:03:40,640
you don't have to have any foreknowledge

00:03:38,239 --> 00:03:42,480
of the underlying architecture

00:03:40,640 --> 00:03:43,920
um being used to run the operating

00:03:42,480 --> 00:03:44,959
system you merely need to know that the

00:03:43,920 --> 00:03:46,319
operating system

00:03:44,959 --> 00:03:48,560
provides this language which you can

00:03:46,319 --> 00:03:50,400
then use to bootstrap

00:03:48,560 --> 00:03:51,840
many other processes on top of it it has

00:03:50,400 --> 00:03:54,239
a known and reliable

00:03:51,840 --> 00:03:55,920
behavior if you have a script that gets

00:03:54,239 --> 00:03:57,920
run on any puzzle system if you're only

00:03:55,920 --> 00:04:00,239
relying on other parts of the posix

00:03:57,920 --> 00:04:01,760
specification it should operate the

00:04:00,239 --> 00:04:05,120
exact same way no matter

00:04:01,760 --> 00:04:07,040
which variant of uh posix which

00:04:05,120 --> 00:04:08,640
actual implementation of the posix

00:04:07,040 --> 00:04:09,920
interface you're using

00:04:08,640 --> 00:04:11,200
you always know how to invoke it you

00:04:09,920 --> 00:04:11,760
might have a script that starts with the

00:04:11,200 --> 00:04:14,400
shebang

00:04:11,760 --> 00:04:15,920
or you pass it directly to the the

00:04:14,400 --> 00:04:16,880
application itself which lives up in

00:04:15,920 --> 00:04:18,479
show

00:04:16,880 --> 00:04:20,160
and it provides a nice standard way to

00:04:18,479 --> 00:04:22,720
run arbitrary code without knowing

00:04:20,160 --> 00:04:24,560
anything else about the operating system

00:04:22,720 --> 00:04:26,080
it has many features it has several

00:04:24,560 --> 00:04:27,440
features that

00:04:26,080 --> 00:04:28,880
are familiar to anyone who's looked at

00:04:27,440 --> 00:04:29,280
many other programming languages you

00:04:28,880 --> 00:04:32,560
have

00:04:29,280 --> 00:04:33,919
variables control flows such as loops

00:04:32,560 --> 00:04:35,360
conditional branches

00:04:33,919 --> 00:04:37,840
you have parameter expansion which

00:04:35,360 --> 00:04:40,960
allows you to pass essentially pass

00:04:37,840 --> 00:04:43,040
variables as

00:04:40,960 --> 00:04:45,280
uh arguments to other applications and

00:04:43,040 --> 00:04:46,880
functions as command substitution which

00:04:45,280 --> 00:04:48,720
allows you to take the text output

00:04:46,880 --> 00:04:51,520
produced by a command or a

00:04:48,720 --> 00:04:52,960
function and store that in a variable or

00:04:51,520 --> 00:04:55,440
pass it to another command

00:04:52,960 --> 00:04:58,080
you can even define functions so it has

00:04:55,440 --> 00:05:00,400
many features that are key to

00:04:58,080 --> 00:05:01,919
many different programming languages as

00:05:00,400 --> 00:05:04,160
a few other special uh

00:05:01,919 --> 00:05:05,919
uh features such as token aliasing

00:05:04,160 --> 00:05:09,360
arithmetic expansion

00:05:05,919 --> 00:05:11,520
there are some string manipulation um

00:05:09,360 --> 00:05:13,039
uh features that it has not all of which

00:05:11,520 --> 00:05:14,560
are always desirable such as field

00:05:13,039 --> 00:05:15,680
splitting path name expansion quote

00:05:14,560 --> 00:05:17,360
removal

00:05:15,680 --> 00:05:19,360
several other useful features that make

00:05:17,360 --> 00:05:20,320
that particularly suited for interacting

00:05:19,360 --> 00:05:22,320
with other

00:05:20,320 --> 00:05:23,600
uh processes and applications and

00:05:22,320 --> 00:05:25,759
getting them to communicate with each

00:05:23,600 --> 00:05:28,880
other

00:05:25,759 --> 00:05:31,199
one of the more prominent ways that

00:05:28,880 --> 00:05:32,800
bash that posix shell tends to be used

00:05:31,199 --> 00:05:34,160
is for co-distribution

00:05:32,800 --> 00:05:37,039
so if you're distributing code that

00:05:34,160 --> 00:05:38,639
needs to run on a posix operating system

00:05:37,039 --> 00:05:40,160
you can bootstrap that process of

00:05:38,639 --> 00:05:41,600
installing or getting that application

00:05:40,160 --> 00:05:43,600
running by running a shell

00:05:41,600 --> 00:05:45,120
and using that to inspect the

00:05:43,600 --> 00:05:46,160
capabilities of the rest of the

00:05:45,120 --> 00:05:49,360
operating system

00:05:46,160 --> 00:05:51,759
there are many other tools that call

00:05:49,360 --> 00:05:53,440
the posix shell or that depend on the

00:05:51,759 --> 00:05:55,199
semantics of the puzzle shell basically

00:05:53,440 --> 00:05:58,160
anything that uses the system function

00:05:55,199 --> 00:05:59,759
provided by posix

00:05:58,160 --> 00:06:01,360
depends on the behavior of the posix

00:05:59,759 --> 00:06:03,520
command shell so this is things like

00:06:01,360 --> 00:06:05,600
make or m4

00:06:03,520 --> 00:06:07,039
so essentially anytime you have high

00:06:05,600 --> 00:06:09,280
level code that needs to run

00:06:07,039 --> 00:06:10,880
on an arbitrary operating system that

00:06:09,280 --> 00:06:13,440
you know implements this

00:06:10,880 --> 00:06:14,960
operating system interface posix shell

00:06:13,440 --> 00:06:16,080
is the thing that you reach for first

00:06:14,960 --> 00:06:17,759
and

00:06:16,080 --> 00:06:21,280
often that is used to bootstrap several

00:06:17,759 --> 00:06:24,800
of several other things

00:06:21,280 --> 00:06:26,960
so one of the particular uh i'd

00:06:24,800 --> 00:06:28,319
say miss features of the posix command

00:06:26,960 --> 00:06:31,600
shell is that

00:06:28,319 --> 00:06:34,400
it has global variable scope

00:06:31,600 --> 00:06:36,319
there is only one scope for variables so

00:06:34,400 --> 00:06:37,600
if you have a variable with a particular

00:06:36,319 --> 00:06:40,000
name

00:06:37,600 --> 00:06:40,880
regardless of where that is executing

00:06:40,000 --> 00:06:42,800
inside a shell

00:06:40,880 --> 00:06:45,520
within a particular shell that name

00:06:42,800 --> 00:06:47,520
always refers to the same value

00:06:45,520 --> 00:06:49,199
if i create a new sub shell that gets

00:06:47,520 --> 00:06:50,639
copies of all the old values but they

00:06:49,199 --> 00:06:52,639
can be changed without affecting the

00:06:50,639 --> 00:06:55,440
parent shell

00:06:52,639 --> 00:06:57,280
and this weird dynamic means that it can

00:06:55,440 --> 00:06:58,560
be difficult to keep track of variables

00:06:57,280 --> 00:07:00,240
within shell scripts

00:06:58,560 --> 00:07:02,000
you need to know basically every

00:07:00,240 --> 00:07:03,840
instance where a particular variable of

00:07:02,000 --> 00:07:06,319
a particular name is used

00:07:03,840 --> 00:07:07,039
is dependent upon or is updated

00:07:06,319 --> 00:07:08,960
additionally

00:07:07,039 --> 00:07:10,479
these variables can in overlap with

00:07:08,960 --> 00:07:13,120
environment variables if a

00:07:10,479 --> 00:07:14,240
variable name is marked as export by the

00:07:13,120 --> 00:07:15,680
shell then

00:07:14,240 --> 00:07:19,120
whatever value gets placed in there will

00:07:15,680 --> 00:07:21,280
be passed to child processes

00:07:19,120 --> 00:07:22,319
so uh let's start with a demo to quickly

00:07:21,280 --> 00:07:25,280
demonstrate

00:07:22,319 --> 00:07:27,599
um a way on which this particular issue

00:07:25,280 --> 00:07:30,880
might manifest

00:07:27,599 --> 00:07:34,639
um so if i see to function

00:07:30,880 --> 00:07:37,199
i have this uh script here which is

00:07:34,639 --> 00:07:38,080
install file uh it just defines a few

00:07:37,199 --> 00:07:39,919
functions

00:07:38,080 --> 00:07:42,000
so we have install this install file

00:07:39,919 --> 00:07:44,400
function which

00:07:42,000 --> 00:07:45,120
takes an argument in the destination

00:07:44,400 --> 00:07:46,560
it's going to

00:07:45,120 --> 00:07:49,360
create the directory which is the

00:07:46,560 --> 00:07:50,639
destination uh which is the parent path

00:07:49,360 --> 00:07:52,400
of the destination

00:07:50,639 --> 00:07:54,000
then it's going to copy the source path

00:07:52,400 --> 00:07:55,360
to the destination path

00:07:54,000 --> 00:07:57,280
and it will link it if it's on the same

00:07:55,360 --> 00:07:59,759
file system so it's a nice

00:07:57,280 --> 00:08:00,879
fairly efficient way to just put files

00:07:59,759 --> 00:08:02,800
in place from a

00:08:00,879 --> 00:08:04,800
source directory we then have this

00:08:02,800 --> 00:08:07,120
install menu function it takes a source

00:08:04,800 --> 00:08:08,639
directory and a destination directory

00:08:07,120 --> 00:08:10,639
and then a list of files within the

00:08:08,639 --> 00:08:12,000
source directory and for every file

00:08:10,639 --> 00:08:14,400
within that source directory it's going

00:08:12,000 --> 00:08:16,080
to create the equivalent path in the

00:08:14,400 --> 00:08:18,879
destination directory and just call

00:08:16,080 --> 00:08:18,879
install file

00:08:19,039 --> 00:08:22,639
um so if i look at my current directory

00:08:21,120 --> 00:08:23,520
you can see we have this from directory

00:08:22,639 --> 00:08:27,120
and the files one

00:08:23,520 --> 00:08:30,000
two and one three and two

00:08:27,120 --> 00:08:31,280
i'm going to source install file so that

00:08:30,000 --> 00:08:34,080
means i'm going to have those

00:08:31,280 --> 00:08:35,360
two functions available to me now and

00:08:34,080 --> 00:08:39,120
then if i run

00:08:35,360 --> 00:08:42,240
install file and pass

00:08:39,120 --> 00:08:44,720
um a

00:08:42,240 --> 00:08:47,760
file path to it so i'm going to install

00:08:44,720 --> 00:08:50,560
from the file 1 to 2d file 2.

00:08:47,760 --> 00:08:50,560
if i try again

00:08:50,800 --> 00:08:54,000
if i tree again we can see that it's

00:08:52,959 --> 00:08:55,760
installed that file

00:08:54,000 --> 00:08:57,920
so everything's working as we expect so

00:08:55,760 --> 00:08:57,920
far

00:09:05,040 --> 00:09:08,320
so now let's try use install many so i

00:09:07,920 --> 00:09:09,839
want to

00:09:08,320 --> 00:09:12,959
install all of these files from the

00:09:09,839 --> 00:09:15,440
fronda into a two directory

00:09:12,959 --> 00:09:16,880
so i pass from there as the source tutor

00:09:15,440 --> 00:09:18,160
is the two directory

00:09:16,880 --> 00:09:22,240
and then we're just going to install

00:09:18,160 --> 00:09:24,959
file one two and three

00:09:22,240 --> 00:09:26,720
and what we get is some errors so the

00:09:24,959 --> 00:09:28,880
first error we see is that it can't

00:09:26,720 --> 00:09:30,399
create the directory 2 to file 1 because

00:09:28,880 --> 00:09:32,800
that file exists

00:09:30,399 --> 00:09:35,680
which is unexpected and then we can't

00:09:32,800 --> 00:09:37,680
access the file 2 to file 1 file 2

00:09:35,680 --> 00:09:39,760
and the end we're trying to access tutor

00:09:37,680 --> 00:09:42,800
file one file to file three

00:09:39,760 --> 00:09:44,480
in fact if we tree we can see that

00:09:42,800 --> 00:09:46,160
we've only managed to install that first

00:09:44,480 --> 00:09:49,440
file

00:09:46,160 --> 00:09:50,000
and the reason this is an issue is if we

00:09:49,440 --> 00:09:52,399
look at

00:09:50,000 --> 00:09:54,160
install file and install many they are

00:09:52,399 --> 00:09:55,040
reusing the same variable names here

00:09:54,160 --> 00:09:57,519
when we um

00:09:55,040 --> 00:09:59,279
take those arguments so install file is

00:09:57,519 --> 00:10:00,959
referring to source and destination so

00:09:59,279 --> 00:10:03,200
every time we call install file it sets

00:10:00,959 --> 00:10:05,120
source to its first argument

00:10:03,200 --> 00:10:06,959
and down and install many we're also

00:10:05,120 --> 00:10:08,720
using the variable source which is the

00:10:06,959 --> 00:10:09,920
same variable because we don't have any

00:10:08,720 --> 00:10:12,720
scope

00:10:09,920 --> 00:10:14,079
so source here is meant to be just a

00:10:12,720 --> 00:10:16,000
directory

00:10:14,079 --> 00:10:17,680
um and then we append each file name

00:10:16,000 --> 00:10:18,560
onto it but every time we call install

00:10:17,680 --> 00:10:21,519
file

00:10:18,560 --> 00:10:23,360
that changes source to be basically the

00:10:21,519 --> 00:10:25,680
value of this source file here

00:10:23,360 --> 00:10:26,720
so we end up appending each file one

00:10:25,680 --> 00:10:29,440
after the other

00:10:26,720 --> 00:10:31,440
because of this variable reuse and this

00:10:29,440 --> 00:10:34,560
is somewhat unexpected if you just

00:10:31,440 --> 00:10:35,839
read over the code and don't think too

00:10:34,560 --> 00:10:36,480
deeply about how these variables

00:10:35,839 --> 00:10:37,920
interact

00:10:36,480 --> 00:10:41,120
in fact the same thing is also happening

00:10:37,920 --> 00:10:41,120
with the destination variable

00:10:43,600 --> 00:10:46,880
so in order to resolve this particular

00:10:46,320 --> 00:10:49,360
issue

00:10:46,880 --> 00:10:50,320
function scope would be quite desirable

00:10:49,360 --> 00:10:52,399
being able to have

00:10:50,320 --> 00:10:53,920
in the independent calls to functions

00:10:52,399 --> 00:10:57,920
have their own copies

00:10:53,920 --> 00:10:59,440
of variables so in order to implement

00:10:57,920 --> 00:11:01,279
function scope we need to have some

00:10:59,440 --> 00:11:02,959
content of a

00:11:01,279 --> 00:11:04,880
variable context for a function so

00:11:02,959 --> 00:11:05,839
whenever we call a function we need to

00:11:04,880 --> 00:11:07,760
have some con

00:11:05,839 --> 00:11:09,360
concept of what which variables are

00:11:07,760 --> 00:11:11,519
available to that function and which

00:11:09,360 --> 00:11:13,920
names refer to those variables

00:11:11,519 --> 00:11:16,399
so whenever we call a function we need

00:11:13,920 --> 00:11:18,079
to create a new variable context

00:11:16,399 --> 00:11:20,320
we need to make sure that only variables

00:11:18,079 --> 00:11:22,560
defined or declared in that function

00:11:20,320 --> 00:11:23,760
can be modified within that function and

00:11:22,560 --> 00:11:24,720
then whenever we're returned from a

00:11:23,760 --> 00:11:26,959
function

00:11:24,720 --> 00:11:29,120
we destroy that context of variables

00:11:26,959 --> 00:11:31,200
that mapping of names to values

00:11:29,120 --> 00:11:32,880
and we restore whatever variable context

00:11:31,200 --> 00:11:34,800
was in whatever call us

00:11:32,880 --> 00:11:36,160
and this means that if we have even the

00:11:34,800 --> 00:11:38,000
same names for variables in different

00:11:36,160 --> 00:11:39,680
functions whenever we

00:11:38,000 --> 00:11:42,079
call into a new function and start a new

00:11:39,680 --> 00:11:43,680
function the names in that

00:11:42,079 --> 00:11:46,640
used in that function only refer to that

00:11:43,680 --> 00:11:46,640
functions variables

00:11:46,720 --> 00:11:50,480
and so we can model this with a call

00:11:48,079 --> 00:11:52,959
stack just as the the same way many

00:11:50,480 --> 00:11:53,760
uh programming languages would and in

00:11:52,959 --> 00:11:56,240
order to do this

00:11:53,760 --> 00:11:57,839
on function area entry we just need to

00:11:56,240 --> 00:11:59,600
take a copy of all of the variables in

00:11:57,839 --> 00:12:02,079
the current context figure out what

00:11:59,600 --> 00:12:04,000
has been defined copy them somewhere

00:12:02,079 --> 00:12:05,519
where they aren't accessible

00:12:04,000 --> 00:12:07,040
and then collect all of those names and

00:12:05,519 --> 00:12:08,959
push them onto a stack

00:12:07,040 --> 00:12:10,800
and then we unset all of those variables

00:12:08,959 --> 00:12:11,279
so whatever code starts executing after

00:12:10,800 --> 00:12:12,720
us

00:12:11,279 --> 00:12:14,959
now no longer has access to them and

00:12:12,720 --> 00:12:16,720
then whenever we return from a function

00:12:14,959 --> 00:12:18,079
we unset any variables that have been

00:12:16,720 --> 00:12:20,480
defined in that function

00:12:18,079 --> 00:12:21,519
we pop the context off of the stack and

00:12:20,480 --> 00:12:23,120
then we take a look at all of the

00:12:21,519 --> 00:12:24,000
variables that were in that context and

00:12:23,120 --> 00:12:29,519
fetch those values

00:12:24,000 --> 00:12:31,600
back and a way to programmatically

00:12:29,519 --> 00:12:33,040
determine assign these variables to

00:12:31,600 --> 00:12:34,240
somewhere which is basically

00:12:33,040 --> 00:12:36,240
unaccessible

00:12:34,240 --> 00:12:38,800
is we're going to generate variables

00:12:36,240 --> 00:12:41,920
that have a prefix that's

00:12:38,800 --> 00:12:42,560
basically reserved in this system and

00:12:41,920 --> 00:12:43,839
we're having a

00:12:42,560 --> 00:12:46,000
going to use a variable that's just

00:12:43,839 --> 00:12:47,440
going to track the depth of our

00:12:46,000 --> 00:12:48,800
call stack so every time we call a

00:12:47,440 --> 00:12:49,760
function we increment that depth and

00:12:48,800 --> 00:12:51,680
every time we refine

00:12:49,760 --> 00:12:53,519
a return from a function we decrease

00:12:51,680 --> 00:12:55,120
that depth

00:12:53,519 --> 00:12:56,880
whenever we declare a variable we track

00:12:55,120 --> 00:12:59,120
what that variable's declaration was

00:12:56,880 --> 00:13:00,639
and then in order to save all of these

00:12:59,120 --> 00:13:01,600
variables we just iterate through those

00:13:00,639 --> 00:13:03,600
variable names

00:13:01,600 --> 00:13:05,120
we do this eval which generates a name

00:13:03,600 --> 00:13:07,040
and assigns the

00:13:05,120 --> 00:13:10,560
current value of that variable and then

00:13:07,040 --> 00:13:10,560
we unset that variable

00:13:10,959 --> 00:13:15,839
the way this is going to look in our

00:13:12,160 --> 00:13:17,680
script is we're going to use a

00:13:15,839 --> 00:13:19,200
string as a list that's going to keep

00:13:17,680 --> 00:13:21,200
track of the stack

00:13:19,200 --> 00:13:22,560
our call stack and what's in it i'm

00:13:21,200 --> 00:13:24,160
going to add a scope command

00:13:22,560 --> 00:13:25,519
that marks function entry so every time

00:13:24,160 --> 00:13:26,320
we enter a function we call this scope

00:13:25,519 --> 00:13:27,680
command

00:13:26,320 --> 00:13:29,600
and this does the whole process of

00:13:27,680 --> 00:13:33,519
looking at the current variable context

00:13:29,600 --> 00:13:36,160
saving it and then clearing it we use a

00:13:33,519 --> 00:13:36,959
var uh command to declare variables to

00:13:36,160 --> 00:13:38,800
keep track of

00:13:36,959 --> 00:13:40,639
which variables have been declared and

00:13:38,800 --> 00:13:43,040
then we add scope return

00:13:40,639 --> 00:13:44,639
at the end of the function to clear out

00:13:43,040 --> 00:13:46,480
the current context and pop the old one

00:13:44,639 --> 00:13:48,079
off the stack

00:13:46,480 --> 00:13:49,570
so let's take a look at what that might

00:13:48,079 --> 00:13:52,649
look like

00:13:49,570 --> 00:13:52,649
[Music]

00:13:53,920 --> 00:14:02,720
um so if i cd

00:13:57,519 --> 00:14:04,880
into function scope

00:14:02,720 --> 00:14:06,639
so this is the updated version of that

00:14:04,880 --> 00:14:08,000
script that we just uh sorry this is a

00:14:06,639 --> 00:14:11,120
simplified version

00:14:08,000 --> 00:14:12,880
to a simplified example to show what

00:14:11,120 --> 00:14:14,480
variable use might look like so we have

00:14:12,880 --> 00:14:15,199
this show files which is just going to

00:14:14,480 --> 00:14:17,680
show

00:14:15,199 --> 00:14:19,279
in the current function what x y and z

00:14:17,680 --> 00:14:20,720
have been set to

00:14:19,279 --> 00:14:22,959
and so this is what a function might

00:14:20,720 --> 00:14:26,160
look like we have scope at the start

00:14:22,959 --> 00:14:27,600
we declare and set some variables we can

00:14:26,160 --> 00:14:29,199
show the variables for function one

00:14:27,600 --> 00:14:32,399
which is just going to print out

00:14:29,199 --> 00:14:33,360
x or undefined if it's not being set and

00:14:32,399 --> 00:14:35,040
y and z

00:14:33,360 --> 00:14:36,639
we then call function2 which declares

00:14:35,040 --> 00:14:38,480
its own scope

00:14:36,639 --> 00:14:39,920
which calls function 3 a couple of times

00:14:38,480 --> 00:14:42,560
shows its variables

00:14:39,920 --> 00:14:44,240
and function 3 has varx so what we

00:14:42,560 --> 00:14:46,880
should expect to see here

00:14:44,240 --> 00:14:49,040
is we call function 1 we see that x and

00:14:46,880 --> 00:14:50,160
z are 12 and 14 and that y is not

00:14:49,040 --> 00:14:52,800
defined

00:14:50,160 --> 00:14:54,560
when we call function 2 we see x is 22

00:14:52,800 --> 00:14:57,600
and y is 23

00:14:54,560 --> 00:14:59,040
and z is not defined

00:14:57,600 --> 00:15:01,279
for function 3 the only one that should

00:14:59,040 --> 00:15:02,880
be defined as x is equal to 32

00:15:01,279 --> 00:15:04,399
whenever we come back to function we

00:15:02,880 --> 00:15:07,440
should see those variables return to

00:15:04,399 --> 00:15:07,440
what they were for that function

00:15:08,480 --> 00:15:13,760
so if i source that and then run func

00:15:12,399 --> 00:15:15,519
one

00:15:13,760 --> 00:15:17,519
we can see that we actually get this so

00:15:15,519 --> 00:15:19,360
in whenever we have function one running

00:15:17,519 --> 00:15:20,639
we can see that x is twelve and z is

00:15:19,360 --> 00:15:22,639
fourteen

00:15:20,639 --> 00:15:23,920
at the start and at the end after having

00:15:22,639 --> 00:15:25,760
run everything

00:15:23,920 --> 00:15:27,920
when we run function two we have x

00:15:25,760 --> 00:15:29,120
equals 22 and y equals 23 and that's not

00:15:27,920 --> 00:15:30,880
defined and whenever

00:15:29,120 --> 00:15:32,399
we return from function 3 we can see

00:15:30,880 --> 00:15:35,519
that and then

00:15:32,399 --> 00:15:38,320
multiple calls to function 3 reset those

00:15:35,519 --> 00:15:38,320
those values

00:15:39,680 --> 00:15:44,399
so that works as basically as we want

00:15:42,959 --> 00:15:46,480
and in fact we can see how this is being

00:15:44,399 --> 00:15:49,279
tracked in the background

00:15:46,480 --> 00:15:49,279
if i

00:15:53,440 --> 00:15:56,399
uncomment this

00:15:58,000 --> 00:16:01,440
so if i source this again

00:16:02,800 --> 00:16:07,680
and call func one we can we're also

00:16:06,240 --> 00:16:09,759
going to take a look at the variables

00:16:07,680 --> 00:16:12,880
that have been set

00:16:09,759 --> 00:16:16,079
outside so in this sort of module scope

00:16:12,880 --> 00:16:17,600
prefix here we can

00:16:16,079 --> 00:16:19,600
one so this is the depth i was talking

00:16:17,600 --> 00:16:21,120
about we can see we have something that

00:16:19,600 --> 00:16:22,000
looks vaguely like a list here which

00:16:21,120 --> 00:16:24,720
says

00:16:22,000 --> 00:16:26,560
x and z have been declared and then when

00:16:24,720 --> 00:16:28,079
we call into two we can see that we have

00:16:26,560 --> 00:16:31,920
the scope here for a uh

00:16:28,079 --> 00:16:34,320
for the x the function one call stack

00:16:31,920 --> 00:16:36,160
frame and the variables that have been

00:16:34,320 --> 00:16:37,120
saved from that and the depth has been

00:16:36,160 --> 00:16:39,040
increased

00:16:37,120 --> 00:16:40,959
and the x and y declarations from

00:16:39,040 --> 00:16:42,800
function two and then when we call into

00:16:40,959 --> 00:16:45,360
function three we can see

00:16:42,800 --> 00:16:46,880
function twos variables function ones

00:16:45,360 --> 00:16:50,000
variables and the declaration

00:16:46,880 --> 00:16:51,680
for uh function three

00:16:50,000 --> 00:16:54,000
so if we now apply this to the example

00:16:51,680 --> 00:16:57,600
that we had before

00:16:54,000 --> 00:16:57,600
this is what it might look like

00:16:58,160 --> 00:17:02,639
so we have install file and we just add

00:17:00,800 --> 00:17:03,440
scope at the start scope return at the

00:17:02,639 --> 00:17:06,160
end

00:17:03,440 --> 00:17:07,760
and we use var to declare our variables

00:17:06,160 --> 00:17:09,280
the same thing here we have scope at the

00:17:07,760 --> 00:17:12,240
start scope at the end and var to

00:17:09,280 --> 00:17:12,240
declare our variables

00:17:12,880 --> 00:17:17,839
these ones as well but these lines

00:17:16,160 --> 00:17:19,360
are unchanged they're undead they're

00:17:17,839 --> 00:17:21,280
identical nothing has to change about

00:17:19,360 --> 00:17:24,480
them

00:17:21,280 --> 00:17:24,480
so if i source that one now

00:17:25,600 --> 00:17:30,400
and then i try and do the install many

00:17:27,199 --> 00:17:31,919
command as we had from before

00:17:30,400 --> 00:17:34,000
we don't get any errors and if i run

00:17:31,919 --> 00:17:36,559
tree you can see that all of the files

00:17:34,000 --> 00:17:39,200
have been installed correctly

00:17:36,559 --> 00:17:40,960
so that is how we can have function

00:17:39,200 --> 00:17:42,480
scope inside of the posix shell which it

00:17:40,960 --> 00:17:45,200
doesn't itself natively

00:17:42,480 --> 00:17:46,960
support another thing that's

00:17:45,200 --> 00:17:50,320
particularly useful is

00:17:46,960 --> 00:17:51,120
modules being able to encapsulate a set

00:17:50,320 --> 00:17:52,880
of

00:17:51,120 --> 00:17:54,480
things from our programming language

00:17:52,880 --> 00:17:55,840
that we can reuse in multiple cases

00:17:54,480 --> 00:17:57,280
elsewhere

00:17:55,840 --> 00:17:58,640
but in a way that we don't have to worry

00:17:57,280 --> 00:17:59,440
about the way that those modules are

00:17:58,640 --> 00:18:01,200
implemented

00:17:59,440 --> 00:18:03,360
nothing aside from the public interfaces

00:18:01,200 --> 00:18:05,200
of those modules will leak out

00:18:03,360 --> 00:18:07,440
into what we want and to what we're

00:18:05,200 --> 00:18:10,320
trying to use

00:18:07,440 --> 00:18:10,960
so what is a module a sort of technical

00:18:10,320 --> 00:18:12,720
sense

00:18:10,960 --> 00:18:14,720
it's just a set of named items we have

00:18:12,720 --> 00:18:15,600
names referring to variables that exist

00:18:14,720 --> 00:18:17,440
in the module

00:18:15,600 --> 00:18:19,120
names referring to constants and names

00:18:17,440 --> 00:18:21,120
referring to functions

00:18:19,120 --> 00:18:23,120
and if i wanted to use some or all of

00:18:21,120 --> 00:18:26,799
this module i could say

00:18:23,120 --> 00:18:28,960
take this module and add

00:18:26,799 --> 00:18:30,880
all of its contents or some subset of

00:18:28,960 --> 00:18:31,919
its contents to my current scope and

00:18:30,880 --> 00:18:33,679
this might be

00:18:31,919 --> 00:18:35,840
inside of another module if i wanted to

00:18:33,679 --> 00:18:36,720
import all the contents for that module

00:18:35,840 --> 00:18:38,320
into another one

00:18:36,720 --> 00:18:40,240
or it might even be in just a single

00:18:38,320 --> 00:18:41,360
function call for the duration of a

00:18:40,240 --> 00:18:44,160
single function

00:18:41,360 --> 00:18:44,720
bring in some of those items from that

00:18:44,160 --> 00:18:48,080
module

00:18:44,720 --> 00:18:49,280
into that function's scope another thing

00:18:48,080 --> 00:18:50,720
that's quite useful

00:18:49,280 --> 00:18:53,679
and that we would like to do generally

00:18:50,720 --> 00:18:55,760
by default is that functions

00:18:53,679 --> 00:18:57,520
from a module when they're executed also

00:18:55,760 --> 00:18:58,880
have the rest of that module in scope

00:18:57,520 --> 00:19:02,640
so a function can see everything that

00:18:58,880 --> 00:19:02,640
was defined in the same module as it was

00:19:03,600 --> 00:19:08,080
in order to model modules we need to

00:19:05,520 --> 00:19:09,600
sort of grapple with the idea of the way

00:19:08,080 --> 00:19:11,840
shell works because this is all still

00:19:09,600 --> 00:19:14,720
being implemented on top of shell

00:19:11,840 --> 00:19:16,080
using posix shell itself and so if we

00:19:14,720 --> 00:19:17,919
want to include a module

00:19:16,080 --> 00:19:19,120
we need to have something that executes

00:19:17,919 --> 00:19:21,840
but that doesn't

00:19:19,120 --> 00:19:22,960
modify the actual current state yet so

00:19:21,840 --> 00:19:24,480
what we're going to do

00:19:22,960 --> 00:19:26,240
is we're going to say that a module is a

00:19:24,480 --> 00:19:28,720
result of some script

00:19:26,240 --> 00:19:30,000
so when the script finishes executing

00:19:28,720 --> 00:19:31,600
all of the items from that module are

00:19:30,000 --> 00:19:32,480
now defined in that module itself is now

00:19:31,600 --> 00:19:34,160
defined but it

00:19:32,480 --> 00:19:36,080
it hasn't been introduced to any scope

00:19:34,160 --> 00:19:38,160
yet and then

00:19:36,080 --> 00:19:39,760
once that module has been defined we can

00:19:38,160 --> 00:19:41,360
select parts of it in any scope that

00:19:39,760 --> 00:19:44,160
gets generated after that

00:19:41,360 --> 00:19:46,080
to be included into it and for

00:19:44,160 --> 00:19:48,160
convenience we want to be able to nest

00:19:46,080 --> 00:19:50,160
the the creation of modules we don't

00:19:48,160 --> 00:19:51,679
want to be trying to set up modules

00:19:50,160 --> 00:19:55,039
ahead of time because that's

00:19:51,679 --> 00:19:56,880
somewhat wasteful and slow um

00:19:55,039 --> 00:19:58,400
it's preferable to do it lazily so what

00:19:56,880 --> 00:20:00,000
we want is for whenever

00:19:58,400 --> 00:20:01,440
a module needs to be loaded by a

00:20:00,000 --> 00:20:02,640
function or another module

00:20:01,440 --> 00:20:04,559
that's the point where we decide to

00:20:02,640 --> 00:20:06,640
initialize it and if that happens during

00:20:04,559 --> 00:20:09,520
another module we need to keep track of

00:20:06,640 --> 00:20:12,559
what module was being initialized before

00:20:09,520 --> 00:20:15,360
we started initializing this one

00:20:12,559 --> 00:20:16,240
and for that we're going to use a stack

00:20:15,360 --> 00:20:18,480
to track

00:20:16,240 --> 00:20:19,679
which modules are being constructed and

00:20:18,480 --> 00:20:21,440
as we

00:20:19,679 --> 00:20:23,120
introduce new modules to be constructed

00:20:21,440 --> 00:20:25,039
as ones are already being constructed

00:20:23,120 --> 00:20:26,880
they just get pushed onto the stack

00:20:25,039 --> 00:20:28,799
and once this is all done we'll have a

00:20:26,880 --> 00:20:30,720
way to map from module names

00:20:28,799 --> 00:20:32,840
and items in their scope to the actual

00:20:30,720 --> 00:20:35,840
underlying variables constants and

00:20:32,840 --> 00:20:35,840
functions

00:20:36,400 --> 00:20:39,919
defining variables and constants in the

00:20:38,159 --> 00:20:41,679
scope of a module is very similar to

00:20:39,919 --> 00:20:43,840
defining variables and constants within

00:20:41,679 --> 00:20:45,200
the scope of a function

00:20:43,840 --> 00:20:47,200
you just need to track the name and the

00:20:45,200 --> 00:20:49,679
value and copy the values around

00:20:47,200 --> 00:20:50,400
for constants r uh you would copy the

00:20:49,679 --> 00:20:51,919
value

00:20:50,400 --> 00:20:54,240
the constant value into the scope that

00:20:51,919 --> 00:20:57,280
it's being added to rather than

00:20:54,240 --> 00:21:01,520
uh allow that reference to be modified

00:20:57,280 --> 00:21:03,919
um globally for functions however

00:21:01,520 --> 00:21:04,960
we can't really treat them as values in

00:21:03,919 --> 00:21:07,679
the same way that we could in other

00:21:04,960 --> 00:21:09,840
languages we need some way of having

00:21:07,679 --> 00:21:11,919
the name of a function being added to a

00:21:09,840 --> 00:21:13,600
scope to still refer to the original

00:21:11,919 --> 00:21:14,799
function we can do that in posix shell

00:21:13,600 --> 00:21:16,640
with aliases

00:21:14,799 --> 00:21:18,400
and what i have on screen here is a

00:21:16,640 --> 00:21:19,280
programmatic way to generate these

00:21:18,400 --> 00:21:21,440
aliases

00:21:19,280 --> 00:21:24,880
and in fact what we do is we generate

00:21:21,440 --> 00:21:26,400
the alias before defining it

00:21:24,880 --> 00:21:27,760
this allows us to declare that a

00:21:26,400 --> 00:21:28,480
function is about to be declared to

00:21:27,760 --> 00:21:30,480
define the

00:21:28,480 --> 00:21:32,000
declare the function and have that name

00:21:30,480 --> 00:21:33,120
both in the module and everything that

00:21:32,000 --> 00:21:36,000
refers to it

00:21:33,120 --> 00:21:37,520
refer to the same underlying function

00:21:36,000 --> 00:21:39,840
and i'll just give a quick demonstration

00:21:37,520 --> 00:21:42,480
of what i mean here

00:21:39,840 --> 00:21:43,600
so if i have a function that i want to

00:21:42,480 --> 00:21:44,960
declare

00:21:43,600 --> 00:21:47,360
an alias for a function i want to

00:21:44,960 --> 00:21:51,200
declare such as

00:21:47,360 --> 00:21:52,720
say foo is equal to ba so foo is

00:21:51,200 --> 00:21:54,720
the public name for this function and

00:21:52,720 --> 00:21:59,840
bar might be the private name

00:21:54,720 --> 00:21:59,840
i can now define foo

00:22:02,720 --> 00:22:05,840
as this function so if i execute through

00:22:04,640 --> 00:22:08,159
i get this as foo

00:22:05,840 --> 00:22:08,880
but because of that alias if we look at

00:22:08,159 --> 00:22:10,320
foo foo

00:22:08,880 --> 00:22:12,799
is still not a function and it's still

00:22:10,320 --> 00:22:15,039
an alias for bar that means that bar was

00:22:12,799 --> 00:22:18,000
defined as fu

00:22:15,039 --> 00:22:18,320
so this allows us to have these hidden

00:22:18,000 --> 00:22:20,400
uh

00:22:18,320 --> 00:22:22,400
global names that people don't refer to

00:22:20,400 --> 00:22:24,799
in this case instead of bar

00:22:22,400 --> 00:22:27,280
but to have aliases generate generated

00:22:24,799 --> 00:22:30,480
whenever we need to actually manually

00:22:27,280 --> 00:22:30,480
uh refer to that function

00:22:30,559 --> 00:22:35,679
this isn't supported in all shells

00:22:33,840 --> 00:22:38,240
only ones that are strictly posix

00:22:35,679 --> 00:22:38,240
compliant

00:22:38,840 --> 00:22:42,960
so as for the interface we're going to

00:22:41,520 --> 00:22:45,039
get to set up these modules

00:22:42,960 --> 00:22:46,400
we have a list as a stack of modules in

00:22:45,039 --> 00:22:47,440
the same way that we had a call stack

00:22:46,400 --> 00:22:48,960
for functions

00:22:47,440 --> 00:22:50,480
we're going to add this module command

00:22:48,960 --> 00:22:51,520
that we put at the start of a script

00:22:50,480 --> 00:22:53,039
that defines a

00:22:51,520 --> 00:22:54,640
module to mark that it's been created

00:22:53,039 --> 00:22:56,960
and what name to give it

00:22:54,640 --> 00:22:58,640
we track variables with var const is

00:22:56,960 --> 00:23:00,720
like far but it doesn't allow you to

00:22:58,640 --> 00:23:02,559
modify the variable inside the module

00:23:00,720 --> 00:23:04,880
and we add fun to track function

00:23:02,559 --> 00:23:06,159
declarations we also have end module

00:23:04,880 --> 00:23:08,240
at the end of the module to mark when

00:23:06,159 --> 00:23:10,320
it's finished being declared to

00:23:08,240 --> 00:23:11,280
pop that module off the stack and go

00:23:10,320 --> 00:23:13,280
back to

00:23:11,280 --> 00:23:15,919
the execution of the script that was

00:23:13,280 --> 00:23:18,960
defining whatever called it

00:23:15,919 --> 00:23:20,559
and then whenever we want to use uh

00:23:18,960 --> 00:23:23,760
items from that module or the module

00:23:20,559 --> 00:23:26,559
itself after its definition we have

00:23:23,760 --> 00:23:28,240
we've added a use command so you can

00:23:26,559 --> 00:23:29,520
specify that module or the module in

00:23:28,240 --> 00:23:31,440
some of its children

00:23:29,520 --> 00:23:33,840
to add to the scope that you're

00:23:31,440 --> 00:23:38,240
currently executing in

00:23:33,840 --> 00:23:38,240
so let's take a look at how this works

00:23:40,640 --> 00:23:44,640
so i have a simple module defined here

00:23:45,200 --> 00:23:49,679
it's called module color it's got the

00:23:48,000 --> 00:23:52,080
public constant bold

00:23:49,679 --> 00:23:53,760
this is a private constant so you can't

00:23:52,080 --> 00:23:54,400
import it externally but it exists

00:23:53,760 --> 00:23:57,520
within this

00:23:54,400 --> 00:23:59,039
module we have red and cyan as colors

00:23:57,520 --> 00:24:00,880
defined here

00:23:59,039 --> 00:24:02,480
we have this unstyle function which is

00:24:00,880 --> 00:24:04,799
private so this can't be used outside

00:24:02,480 --> 00:24:07,440
the module we have this public function

00:24:04,799 --> 00:24:10,640
span which lets us style a span of text

00:24:07,440 --> 00:24:13,760
and then we end the module down here

00:24:10,640 --> 00:24:13,760
so if we look at

00:24:14,320 --> 00:24:19,039
the current state of our module system

00:24:17,520 --> 00:24:20,559
we have this global module which is

00:24:19,039 --> 00:24:22,240
what's currently being defined and it

00:24:20,559 --> 00:24:24,000
has no declarations yet and

00:24:22,240 --> 00:24:25,440
we have a scope depth of 0 and there's

00:24:24,000 --> 00:24:26,799
nothing in the stack

00:24:25,440 --> 00:24:29,039
and that's just where the state's being

00:24:26,799 --> 00:24:32,640
logged now if i

00:24:29,039 --> 00:24:34,320
run the script color.sh this is going to

00:24:32,640 --> 00:24:36,080
define that module but it's not going to

00:24:34,320 --> 00:24:36,799
introduce anything into our namespace

00:24:36,080 --> 00:24:40,640
yet

00:24:36,799 --> 00:24:42,960
so if i mod vars so we can see that we

00:24:40,640 --> 00:24:42,960
have

00:24:43,039 --> 00:24:46,559
these variables have been created we

00:24:44,880 --> 00:24:48,720
have this which defines all of the

00:24:46,559 --> 00:24:50,799
declarations of module we have

00:24:48,720 --> 00:24:52,320
the public constant ball the private

00:24:50,799 --> 00:24:55,679
constant fg base

00:24:52,320 --> 00:24:57,360
public constant red public constant cyan

00:24:55,679 --> 00:25:00,159
the private function on style and the

00:24:57,360 --> 00:25:02,240
public function span

00:25:00,159 --> 00:25:03,840
but there is still nothing in our global

00:25:02,240 --> 00:25:06,880
namespace

00:25:03,840 --> 00:25:08,640
so now if i were to try and refer to any

00:25:06,880 --> 00:25:11,760
of those variables because

00:25:08,640 --> 00:25:13,840
they haven't been introduced

00:25:11,760 --> 00:25:15,600
cyan doesn't exist if i try and refer to

00:25:13,840 --> 00:25:17,600
red

00:25:15,600 --> 00:25:18,640
it doesn't exist so this module has been

00:25:17,600 --> 00:25:20,159
defined but

00:25:18,640 --> 00:25:21,840
it's not been imported anywhere so we

00:25:20,159 --> 00:25:23,919
need to do that explicitly now after

00:25:21,840 --> 00:25:26,080
running that script

00:25:23,919 --> 00:25:28,240
so i'm going to use the module color

00:25:26,080 --> 00:25:29,360
using span and function cyan and what

00:25:28,240 --> 00:25:32,159
the using here means

00:25:29,360 --> 00:25:33,120
is that rather than prefixing span or

00:25:32,159 --> 00:25:35,039
cyan with

00:25:33,120 --> 00:25:37,279
color i can just refer to those names

00:25:35,039 --> 00:25:40,480
directly

00:25:37,279 --> 00:25:43,440
so if i look at mod files now

00:25:40,480 --> 00:25:45,520
our global namespace has just gotten a

00:25:43,440 --> 00:25:46,880
bunch of declarations for these imported

00:25:45,520 --> 00:25:51,200
values

00:25:46,880 --> 00:25:51,200
and it now has copies of the constants

00:25:53,120 --> 00:25:59,360
so now i can do things like refer to

00:25:56,400 --> 00:26:02,320
span and cyan because i imported them

00:25:59,360 --> 00:26:02,320
this is cyan

00:26:03,200 --> 00:26:10,880
if i try and do the same thing with red

00:26:07,039 --> 00:26:14,000
because red was not imported directly i

00:26:10,880 --> 00:26:14,000
still can't use that name

00:26:14,320 --> 00:26:17,919
what i can do is refer to it by a sort

00:26:16,400 --> 00:26:20,480
of full name

00:26:17,919 --> 00:26:22,240
so i get color fg red and in fact i can

00:26:20,480 --> 00:26:25,840
do that with span and cyan as well those

00:26:22,240 --> 00:26:25,840
names are also added

00:26:29,760 --> 00:26:33,840
and so this is how we get modules we

00:26:32,159 --> 00:26:35,120
have this concept of a script that

00:26:33,840 --> 00:26:36,880
defines a module that

00:26:35,120 --> 00:26:39,760
has its own internal state that we can't

00:26:36,880 --> 00:26:41,600
interact with and has some

00:26:39,760 --> 00:26:43,120
exported interface that we can access

00:26:41,600 --> 00:26:44,960
some variables and constants it's

00:26:43,120 --> 00:26:46,000
defining some functions it's defining

00:26:44,960 --> 00:26:48,159
that we can call

00:26:46,000 --> 00:26:50,159
and we can pick some subset of that to

00:26:48,159 --> 00:26:51,840
use elsewhere in our scripts

00:26:50,159 --> 00:26:53,360
and we don't have to care about the way

00:26:51,840 --> 00:26:55,279
its functions are implemented what its

00:26:53,360 --> 00:26:57,120
private variables are called

00:26:55,279 --> 00:26:58,320
because we can't modify them there's no

00:26:57,120 --> 00:26:59,919
way we can change them and there's no

00:26:58,320 --> 00:27:01,840
way it changes those are going to affect

00:26:59,919 --> 00:27:03,360
any code we run we can

00:27:01,840 --> 00:27:05,840
use those modules without having to

00:27:03,360 --> 00:27:07,039
worry about how variables are

00:27:05,840 --> 00:27:11,840
manipulated

00:27:07,039 --> 00:27:15,360
in those modules so

00:27:11,840 --> 00:27:18,880
i've packaged all of this up into a

00:27:15,360 --> 00:27:20,240
a set of tools called import so it has

00:27:18,880 --> 00:27:21,919
this function scoping that i've been

00:27:20,240 --> 00:27:23,760
demonstrating it has

00:27:21,919 --> 00:27:25,760
posix shell modules that i've been

00:27:23,760 --> 00:27:27,520
demonstrating it also has a mechanism

00:27:25,760 --> 00:27:29,919
for resolving module names and loading

00:27:27,520 --> 00:27:32,080
them so instead of using use you use

00:27:29,919 --> 00:27:33,200
import and that will find a copy of the

00:27:32,080 --> 00:27:34,559
script either

00:27:33,200 --> 00:27:36,159
on your local file system if you

00:27:34,559 --> 00:27:37,919
initialize it that way or if you use the

00:27:36,159 --> 00:27:40,159
remote initialization version

00:27:37,919 --> 00:27:41,600
it will search the github repository for

00:27:40,159 --> 00:27:43,520
a copy of that module

00:27:41,600 --> 00:27:45,679
initialize that module and then import

00:27:43,520 --> 00:27:47,039
whatever you've requested

00:27:45,679 --> 00:27:50,480
this allows you to have some sort of

00:27:47,039 --> 00:27:51,679
remote module store or a local version

00:27:50,480 --> 00:27:54,080
this is how you would initialize the

00:27:51,679 --> 00:27:56,799
remote version

00:27:54,080 --> 00:27:57,600
it's a bit complicated but we just check

00:27:56,799 --> 00:27:59,679
that

00:27:57,600 --> 00:28:02,640
we don't already have an import system

00:27:59,679 --> 00:28:05,279
set up which is what this function does

00:28:02,640 --> 00:28:06,320
um and then we create a temporary file

00:28:05,279 --> 00:28:08,640
to store the

00:28:06,320 --> 00:28:10,320
uh import script we download the import

00:28:08,640 --> 00:28:12,080
script and then we initialize it with

00:28:10,320 --> 00:28:13,440
these lines and then we remove it

00:28:12,080 --> 00:28:15,120
but this means that whatever shell

00:28:13,440 --> 00:28:16,240
executed that import script now has it

00:28:15,120 --> 00:28:18,640
sitting in memory

00:28:16,240 --> 00:28:20,399
as do all of the shells that it creates

00:28:18,640 --> 00:28:21,919
during execution

00:28:20,399 --> 00:28:24,880
for the local version you just keep a

00:28:21,919 --> 00:28:27,039
local copy of the repository somewhere

00:28:24,880 --> 00:28:30,880
and you set that as your import script

00:28:27,039 --> 00:28:34,000
and you initialize it

00:28:30,880 --> 00:28:34,880
so this is what the color module would

00:28:34,000 --> 00:28:38,159
look like

00:28:34,880 --> 00:28:40,320
for um uh

00:28:38,159 --> 00:28:41,760
within import or our basic version of

00:28:40,320 --> 00:28:43,039
the color module

00:28:41,760 --> 00:28:45,840
and it looks much like what i just

00:28:43,039 --> 00:28:45,840
showed recently

00:28:46,320 --> 00:28:50,320
so let's take a look at how import works

00:28:51,600 --> 00:28:56,880
so if i cd into import

00:28:57,440 --> 00:29:00,559
all i have is this main

00:29:01,039 --> 00:29:06,480
so if we look at that this is just going

00:29:03,679 --> 00:29:08,880
to use the local copy of import which is

00:29:06,480 --> 00:29:11,120
this uh these slides are actually inside

00:29:08,880 --> 00:29:12,960
of the import repository

00:29:11,120 --> 00:29:14,240
so it just uses the local version and

00:29:12,960 --> 00:29:16,240
initialize it

00:29:14,240 --> 00:29:18,000
and then instead of using our smaller

00:29:16,240 --> 00:29:19,039
version of color that we defined earlier

00:29:18,000 --> 00:29:22,559
this is using

00:29:19,039 --> 00:29:25,600
the full color library that comes out of

00:29:22,559 --> 00:29:27,440
um that's already in the import system

00:29:25,600 --> 00:29:28,720
so we're going to use span style

00:29:27,440 --> 00:29:31,919
unstyled we have a few

00:29:28,720 --> 00:29:33,279
foreground colors and a few text styles

00:29:31,919 --> 00:29:34,880
that we can use here

00:29:33,279 --> 00:29:36,880
and we're just going to define a main

00:29:34,880 --> 00:29:40,720
function and call it

00:29:36,880 --> 00:29:42,000
once the script is evaluated

00:29:40,720 --> 00:29:43,440
and it's just going to print some pretty

00:29:42,000 --> 00:29:43,760
text so we're going to get this text as

00:29:43,440 --> 00:29:45,919
red

00:29:43,760 --> 00:29:48,080
in red and italic we're going to get

00:29:45,919 --> 00:29:51,360
this text is in cyan

00:29:48,080 --> 00:29:55,039
aesthetic and italic bold yellow

00:29:51,360 --> 00:29:57,520
and some regular cyan exclamation marks

00:29:55,039 --> 00:29:59,039
so let's run it and see what happens

00:29:57,520 --> 00:30:00,720
another thing to note though is that

00:29:59,039 --> 00:30:03,840
this is all using dash

00:30:00,720 --> 00:30:05,600
this is because bash and zsh

00:30:03,840 --> 00:30:07,679
don't comply with the standard strictly

00:30:05,600 --> 00:30:11,600
enough

00:30:07,679 --> 00:30:11,600
so if i just run main.sh now

00:30:12,240 --> 00:30:15,600
you can see that it's a bit slow

00:30:15,840 --> 00:30:20,559
but it does eventually print out that

00:30:18,880 --> 00:30:22,799
text

00:30:20,559 --> 00:30:24,320
um and so that sort of leads me into

00:30:22,799 --> 00:30:26,640
some of the issues with

00:30:24,320 --> 00:30:28,640
import so whilst the syntax that i've

00:30:26,640 --> 00:30:32,000
managed to add here

00:30:28,640 --> 00:30:33,840
i feel is fairly ergonomic

00:30:32,000 --> 00:30:35,679
uh and makes this a lot more convenient

00:30:33,840 --> 00:30:37,200
to use there are a number of issues with

00:30:35,679 --> 00:30:39,200
this system none of this

00:30:37,200 --> 00:30:40,799
code that is being used is signed so it

00:30:39,200 --> 00:30:41,679
should be audited to some degree that

00:30:40,799 --> 00:30:43,279
said

00:30:41,679 --> 00:30:45,039
it's only shell scripts that aren't very

00:30:43,279 --> 00:30:46,720
large so maybe auditing isn't a big

00:30:45,039 --> 00:30:47,919
issue if you ever plan on using this

00:30:46,720 --> 00:30:49,520
realistically

00:30:47,919 --> 00:30:51,120
but the overheads this system adds

00:30:49,520 --> 00:30:51,600
because it's all implemented in posix

00:30:51,120 --> 00:30:54,240
shell

00:30:51,600 --> 00:30:55,279
are quite substantial takes a lot of

00:30:54,240 --> 00:30:56,799
time to

00:30:55,279 --> 00:30:58,480
uh set up and copy all of these

00:30:56,799 --> 00:31:00,159
variables around the shells

00:30:58,480 --> 00:31:01,600
uh especially when you end up with quite

00:31:00,159 --> 00:31:04,880
a large con

00:31:01,600 --> 00:31:05,919
state uh for all of the constants and

00:31:04,880 --> 00:31:07,360
variables and functions that you're

00:31:05,919 --> 00:31:10,000
keeping track of

00:31:07,360 --> 00:31:11,200
and additionally this requires strict

00:31:10,000 --> 00:31:14,720
politics compliant

00:31:11,200 --> 00:31:18,000
to the degree that bash and zsh can't

00:31:14,720 --> 00:31:19,840
don't support this bash has issues with

00:31:18,000 --> 00:31:22,320
name resolution and zsh

00:31:19,840 --> 00:31:23,600
will explicitly prevent you from alias

00:31:22,320 --> 00:31:26,960
uh defining

00:31:23,600 --> 00:31:30,000
functions using via alias names it tells

00:31:26,960 --> 00:31:33,039
you that it doesn't like you doing that

00:31:30,000 --> 00:31:34,720
so this may be not probably isn't the

00:31:33,039 --> 00:31:36,640
the biggest thing that i would recommend

00:31:34,720 --> 00:31:39,840
you actually using

00:31:36,640 --> 00:31:41,519
it's more of a uh this was more of a

00:31:39,840 --> 00:31:43,039
an exploration into what could be done

00:31:41,519 --> 00:31:44,640
with posix and

00:31:43,039 --> 00:31:47,360
where the logical boundaries of using

00:31:44,640 --> 00:31:49,279
posix shell might be

00:31:47,360 --> 00:31:51,200
so having a high level language is very

00:31:49,279 --> 00:31:53,200
useful as an os interface

00:31:51,200 --> 00:31:55,600
but this particular language scales very

00:31:53,200 --> 00:31:59,679
poorly it doesn't deal with

00:31:55,600 --> 00:32:01,279
highly modular or reused code so

00:31:59,679 --> 00:32:03,919
as it requires you to keep track of all

00:32:01,279 --> 00:32:06,000
of these this variable state everywhere

00:32:03,919 --> 00:32:07,519
and this means that if you're

00:32:06,000 --> 00:32:09,039
maintaining shell scripts

00:32:07,519 --> 00:32:10,880
especially cell strips that rely on

00:32:09,039 --> 00:32:13,440
other shell scripts they can break

00:32:10,880 --> 00:32:14,000
quite easily so my main recommendation

00:32:13,440 --> 00:32:16,559
would be rather

00:32:14,000 --> 00:32:17,679
than using import which was a fun tool

00:32:16,559 --> 00:32:19,679
to put together

00:32:17,679 --> 00:32:21,600
it's probably best to try and make the

00:32:19,679 --> 00:32:23,519
minimal use of shell that you can

00:32:21,600 --> 00:32:25,039
and in some cases this is very difficult

00:32:23,519 --> 00:32:26,240
to do particularly if you're relying on

00:32:25,039 --> 00:32:29,120
systems like

00:32:26,240 --> 00:32:31,279
make which make quite heavy use of posix

00:32:29,120 --> 00:32:33,679
shell

00:32:31,279 --> 00:32:35,360
and with that i hope you all found

00:32:33,679 --> 00:32:39,360
something useful in this talk

00:32:35,360 --> 00:32:39,360
and i'm happy to accept questions

00:32:40,480 --> 00:32:45,200
that is great what a fantastic and

00:32:43,440 --> 00:32:46,880
interactive presentation

00:32:45,200 --> 00:32:48,399
a bit over my head at times but i

00:32:46,880 --> 00:32:51,440
thoroughly enjoyed it

00:32:48,399 --> 00:32:52,480
um so we have some questions from the

00:32:51,440 --> 00:32:55,679
audience

00:32:52,480 --> 00:32:58,559
uh first up um

00:32:55,679 --> 00:32:58,960
so the first question coming is why not

00:32:58,559 --> 00:33:01,440
use

00:32:58,960 --> 00:33:02,960
subshells instead of manually creating a

00:33:01,440 --> 00:33:05,760
scope command

00:33:02,960 --> 00:33:07,440
and also an add-on to that every shell i

00:33:05,760 --> 00:33:10,960
know of that isn't running in

00:33:07,440 --> 00:33:14,159
strict uh per 6 mode has a local

00:33:10,960 --> 00:33:17,279
key a keyword yeah

00:33:14,159 --> 00:33:20,000
so using um scopes

00:33:17,279 --> 00:33:21,039
is a valid way of effectively having

00:33:20,000 --> 00:33:23,919
some sort of function

00:33:21,039 --> 00:33:25,519
scope but it doesn't really help if

00:33:23,919 --> 00:33:28,399
you're trying to maintain

00:33:25,519 --> 00:33:29,840
um variables outside the lifetime of a

00:33:28,399 --> 00:33:30,720
function in something like a reusable

00:33:29,840 --> 00:33:34,080
module

00:33:30,720 --> 00:33:36,080
um so it's not in

00:33:34,080 --> 00:33:38,000
so it can help in a large number of

00:33:36,080 --> 00:33:41,600
cases it also adds its own overhead

00:33:38,000 --> 00:33:42,960
by duplicating subshells and that can be

00:33:41,600 --> 00:33:45,279
implemented

00:33:42,960 --> 00:33:46,559
with some level of optimization by your

00:33:45,279 --> 00:33:49,279
shell implementation so

00:33:46,559 --> 00:33:50,000
that's probably a far easier thing to do

00:33:49,279 --> 00:33:52,799
and a far

00:33:50,000 --> 00:33:54,000
nicer thing to rely on as i said what i

00:33:52,799 --> 00:33:55,360
was trying to demonstrate here wasn't

00:33:54,000 --> 00:33:57,360
necessarily what should be done

00:33:55,360 --> 00:33:58,880
but what can be done with the posix

00:33:57,360 --> 00:34:00,559
standard itself and maybe where that

00:33:58,880 --> 00:34:01,919
standard itself is lacking

00:34:00,559 --> 00:34:03,760
so in addition where you mentioned that

00:34:01,919 --> 00:34:04,720
every shell you know of that isn't

00:34:03,760 --> 00:34:07,279
strict

00:34:04,720 --> 00:34:08,960
in strict posix compliance has a local

00:34:07,279 --> 00:34:11,040
keyword that works

00:34:08,960 --> 00:34:12,560
mostly the same across those shells that

00:34:11,040 --> 00:34:15,520
use them but

00:34:12,560 --> 00:34:16,960
once again if you're using relying on

00:34:15,520 --> 00:34:19,119
posix shell you're probably trying to

00:34:16,960 --> 00:34:21,040
target

00:34:19,119 --> 00:34:23,200
software distribution perhaps and you

00:34:21,040 --> 00:34:24,399
can't rely on the existence of other of

00:34:23,200 --> 00:34:26,159
those other shells if

00:34:24,399 --> 00:34:27,760
you're simply trying to target something

00:34:26,159 --> 00:34:29,200
and all you want to rely on is that

00:34:27,760 --> 00:34:31,040
posix interface

00:34:29,200 --> 00:34:33,119
you can't rely on things like the local

00:34:31,040 --> 00:34:35,839
keyword extension that bastion zsh and

00:34:33,119 --> 00:34:35,839
many others provide

00:34:38,800 --> 00:34:43,760
yeah so once again it's a matter of

00:34:42,000 --> 00:34:46,240
what tools you realistically can rely

00:34:43,760 --> 00:34:49,760
you on having available to you

00:34:46,240 --> 00:34:52,399
okay let's so next up we have a question

00:34:49,760 --> 00:34:54,240
um is the scope stack always safe in

00:34:52,399 --> 00:34:55,760
case the variables contain special

00:34:54,240 --> 00:34:57,440
characters

00:34:55,760 --> 00:34:59,280
that's an excellent question so the

00:34:57,440 --> 00:35:01,200
public standard actually restricts what

00:34:59,280 --> 00:35:03,200
characters can be used for variable

00:35:01,200 --> 00:35:04,000
names such that the mechanism i've

00:35:03,200 --> 00:35:06,240
described here

00:35:04,000 --> 00:35:08,720
if you're using strict uh strictly posix

00:35:06,240 --> 00:35:10,000
shell should work in all cases

00:35:08,720 --> 00:35:13,680
because it's only good if we're going to

00:35:10,000 --> 00:35:15,359
concatenate variables with other names

00:35:13,680 --> 00:35:17,040
uh with it's only ever going to

00:35:15,359 --> 00:35:18,480
concatenate safe variable names with

00:35:17,040 --> 00:35:20,000
other safe variable names

00:35:18,480 --> 00:35:21,359
although it's possible that in some

00:35:20,000 --> 00:35:22,000
perverse cases you'll end up with

00:35:21,359 --> 00:35:24,560
collisions

00:35:22,000 --> 00:35:26,240
between valid variable names inside of a

00:35:24,560 --> 00:35:30,079
module and the hidden variable names

00:35:26,240 --> 00:35:33,520
that it's creating

00:35:30,079 --> 00:35:36,000
okay so um what happens if

00:35:33,520 --> 00:35:37,920
your imported module script crashes

00:35:36,000 --> 00:35:39,440
before the normal end module

00:35:37,920 --> 00:35:41,440
aren't you then stuck with objects in

00:35:39,440 --> 00:35:44,880
the global scope or worse objects from

00:35:41,440 --> 00:35:46,480
global pushed into a stack oblivion

00:35:44,880 --> 00:35:48,720
yeah this was something that i had to

00:35:46,480 --> 00:35:50,000
deal with as i was constructing this

00:35:48,720 --> 00:35:52,800
this toy

00:35:50,000 --> 00:35:54,560
um it can happen though if your module

00:35:52,800 --> 00:35:56,480
crashes pop

00:35:54,560 --> 00:35:58,320
i wouldn't suggest trying to use this

00:35:56,480 --> 00:36:00,079
interactively if you did

00:35:58,320 --> 00:36:01,839
use this system interactively those are

00:36:00,079 --> 00:36:03,680
the sort of issues you come across

00:36:01,839 --> 00:36:05,359
if you weren't using it interactively

00:36:03,680 --> 00:36:05,920
then ideally the entire thing should

00:36:05,359 --> 00:36:08,480
crash

00:36:05,920 --> 00:36:09,280
um you shouldn't be left with too much

00:36:08,480 --> 00:36:10,560
external

00:36:09,280 --> 00:36:13,680
to the script that's relying on these

00:36:10,560 --> 00:36:15,040
modules from having broken

00:36:13,680 --> 00:36:17,040
would i recommend any shell check

00:36:15,040 --> 00:36:20,160
utilities

00:36:17,040 --> 00:36:22,880
sorry yeah that's up next do you

00:36:20,160 --> 00:36:26,079
recommend any shell check utilities

00:36:22,880 --> 00:36:28,320
yeah so i would definitely recommend

00:36:26,079 --> 00:36:29,359
if you're writing shell code that is

00:36:28,320 --> 00:36:32,480
being distributed

00:36:29,359 --> 00:36:33,760
to downstream users that you expect to

00:36:32,480 --> 00:36:36,240
use it without

00:36:33,760 --> 00:36:38,160
making big assumptions on what they have

00:36:36,240 --> 00:36:39,520
available to them specifically if you

00:36:38,160 --> 00:36:41,359
want to limit yourself

00:36:39,520 --> 00:36:42,880
to that posix interface then you should

00:36:41,359 --> 00:36:43,760
really be using shell checkers that

00:36:42,880 --> 00:36:45,920
check you aren't

00:36:43,760 --> 00:36:47,520
using things like bashisms things that

00:36:45,920 --> 00:36:50,160
would work in bash

00:36:47,520 --> 00:36:51,440
but if you're not explicitly targeting

00:36:50,160 --> 00:36:54,720
bash may fail

00:36:51,440 --> 00:36:55,680
in any other posix and any other shell

00:36:54,720 --> 00:36:59,040
that's only running

00:36:55,680 --> 00:37:00,320
in a way that supports posix um

00:36:59,040 --> 00:37:02,240
i don't know any of those off the top of

00:37:00,320 --> 00:37:04,000
my head because all of the ones that we

00:37:02,240 --> 00:37:06,560
use where i work are in our ci and i

00:37:04,000 --> 00:37:09,200
don't have to think about them

00:37:06,560 --> 00:37:11,200
okay um and also just a reminder to

00:37:09,200 --> 00:37:12,800
everyone that curtis will be available

00:37:11,200 --> 00:37:16,880
to take questions

00:37:12,800 --> 00:37:19,760
in the um rusty aisle hall post talk q a

00:37:16,880 --> 00:37:21,359
channel on venulis so you might be able

00:37:19,760 --> 00:37:22,160
to ask him some more curly questions

00:37:21,359 --> 00:37:24,240
there

00:37:22,160 --> 00:37:25,839
i do have another one that's a little

00:37:24,240 --> 00:37:29,200
bit sort of off topic but

00:37:25,839 --> 00:37:29,680
thought it might be relevant it's about

00:37:29,200 --> 00:37:33,359
your

00:37:29,680 --> 00:37:34,880
slides um what tools what tool are you

00:37:33,359 --> 00:37:38,560
using for these slides

00:37:34,880 --> 00:37:38,560
curtis one evidence

00:37:39,040 --> 00:37:43,040
these slides are written using import so

00:37:41,839 --> 00:37:44,800
the links for the slides

00:37:43,040 --> 00:37:46,079
should be on the screen now if we can

00:37:44,800 --> 00:37:48,720
flash that up

00:37:46,079 --> 00:37:49,359
so the slides are at this link that

00:37:48,720 --> 00:37:51,680
should be

00:37:49,359 --> 00:37:52,960
the get ref for the specific version

00:37:51,680 --> 00:37:53,760
that you've been seeing today the old

00:37:52,960 --> 00:37:58,400
project

00:37:53,760 --> 00:37:58,400
can be found at github at curtis import

00:37:58,880 --> 00:38:09,839
but i can show you

00:38:05,440 --> 00:38:11,119
uh the slides are literally just a shell

00:38:09,839 --> 00:38:14,800
script

00:38:11,119 --> 00:38:18,320
so i import setup import

00:38:14,800 --> 00:38:19,760
and then i import uh slides module

00:38:18,320 --> 00:38:23,520
that's there that you can look at

00:38:19,760 --> 00:38:25,200
i import the color module and then

00:38:23,520 --> 00:38:27,920
each slide is just a call to a slide

00:38:25,200 --> 00:38:30,400
command and at the end i just have a

00:38:27,920 --> 00:38:31,280
present command but you can go look at

00:38:30,400 --> 00:38:33,440
all of the

00:38:31,280 --> 00:38:34,640
uh there's the script that generates

00:38:33,440 --> 00:38:39,599
these slides

00:38:34,640 --> 00:38:42,720
uh on that in that github repository

00:38:39,599 --> 00:38:45,760
that's awesome okay questions are coming

00:38:42,720 --> 00:38:47,680
fast so if one uses

00:38:45,760 --> 00:38:49,599
read only does that conflict with

00:38:47,680 --> 00:38:53,520
temporarily expunging the set of

00:38:49,599 --> 00:38:56,960
visible variables um

00:38:53,520 --> 00:38:59,520
so i think read-only is a bashism

00:38:56,960 --> 00:39:00,800
so there is a private qualifier you can

00:38:59,520 --> 00:39:04,000
stick on

00:39:00,800 --> 00:39:06,240
so in modules names and modules can be

00:39:04,000 --> 00:39:08,560
either public or private and that just

00:39:06,240 --> 00:39:10,240
changes whether or not sorry there is

00:39:08,560 --> 00:39:14,560
const variables in modules

00:39:10,240 --> 00:39:16,720
which rather than being a

00:39:14,560 --> 00:39:18,640
duplicate rather than being an alias to

00:39:16,720 --> 00:39:20,880
another variable in a module so

00:39:18,640 --> 00:39:21,680
when you import that and you modify that

00:39:20,880 --> 00:39:22,960
and then that

00:39:21,680 --> 00:39:25,359
variable goes out of scope it gets

00:39:22,960 --> 00:39:26,720
copied back to the module consts only

00:39:25,359 --> 00:39:30,160
copy it in one direction

00:39:26,720 --> 00:39:33,760
so it is still possible for

00:39:30,160 --> 00:39:36,320
um for changes to

00:39:33,760 --> 00:39:37,280
those constant variables to actually

00:39:36,320 --> 00:39:41,040
persist throughout

00:39:37,280 --> 00:39:41,040
whichever scope they were imported into

00:39:41,599 --> 00:39:46,960
um but because this is just using normal

00:39:44,960 --> 00:39:49,680
shell variables anytime you do import

00:39:46,960 --> 00:39:50,720
a variable from another module or a name

00:39:49,680 --> 00:39:52,320
from another module

00:39:50,720 --> 00:39:57,839
that's going to overwrite whatever had

00:39:52,320 --> 00:39:57,839
that name currently in the scope

00:39:57,920 --> 00:40:01,440
and where do you see your work going

00:39:59,599 --> 00:40:03,119
next what would you what are you excited

00:40:01,440 --> 00:40:05,680
on working on next in this area

00:40:03,119 --> 00:40:06,480
or others so this was just something i

00:40:05,680 --> 00:40:09,040
spent my

00:40:06,480 --> 00:40:10,800
i was doing in my spare time i was

00:40:09,040 --> 00:40:11,839
getting frustrated at not being able to

00:40:10,800 --> 00:40:14,040
reuse code

00:40:11,839 --> 00:40:16,240
in posix shell sorry that's me

00:40:14,040 --> 00:40:18,319
[Music]

00:40:16,240 --> 00:40:20,160
i was being frustrated not being able to

00:40:18,319 --> 00:40:20,880
easily reuse code in posix shell so i

00:40:20,160 --> 00:40:23,599
wanted to see

00:40:20,880 --> 00:40:24,000
what i could do to alleviate that

00:40:23,599 --> 00:40:25,839
without

00:40:24,000 --> 00:40:27,839
having to rely on anything outside of

00:40:25,839 --> 00:40:29,119
the posix standard it's not something i

00:40:27,839 --> 00:40:30,960
would use practically

00:40:29,119 --> 00:40:32,720
or something that i would i would apply

00:40:30,960 --> 00:40:36,880
to the work i do with

00:40:32,720 --> 00:40:41,119
um scl4 okay yeah

00:40:36,880 --> 00:40:43,200
that's great okay um

00:40:41,119 --> 00:40:45,440
we're a little bit ahead of time but as

00:40:43,200 --> 00:40:48,560
i said we can keep the discussion going

00:40:45,440 --> 00:40:51,599
on venus in the rusty r

00:40:48,560 --> 00:40:52,800
post talk q a room i'd love to really

00:40:51,599 --> 00:40:54,319
thank you for coming in that was a

00:40:52,800 --> 00:40:55,119
really great presentation i certainly

00:40:54,319 --> 00:40:58,160
learnt a lot

00:40:55,119 --> 00:41:00,400
and have a lot to go with in the future

00:40:58,160 --> 00:41:01,280
um and i hope you enjoy the rest of the

00:41:00,400 --> 00:41:04,480
conference

00:41:01,280 --> 00:41:06,640
curtis um thanks everybody for attending

00:41:04,480 --> 00:41:09,280
yeah it's wonderful um we're going to

00:41:06,640 --> 00:41:11,119
have a 10 minute break now uh we're well

00:41:09,280 --> 00:41:12,880
probably more like a 15-minute break and

00:41:11,119 --> 00:41:14,800
we're back at 11 40

00:41:12,880 --> 00:41:16,160
where we'll be listening to katie bell

00:41:14,800 --> 00:41:18,880
who's presenting

00:41:16,160 --> 00:41:20,160
what even is code building a non-code

00:41:18,880 --> 00:41:22,480
coding interface

00:41:20,160 --> 00:41:24,079
so that looks great as well thanks again

00:41:22,480 --> 00:41:26,720
curtis and

00:41:24,079 --> 00:41:28,640
we'll hopefully have a good conference

00:41:26,720 --> 00:41:35,839
for the rest of the day

00:41:28,640 --> 00:41:35,839

YouTube URL: https://www.youtube.com/watch?v=oKA2aK0-tb4


