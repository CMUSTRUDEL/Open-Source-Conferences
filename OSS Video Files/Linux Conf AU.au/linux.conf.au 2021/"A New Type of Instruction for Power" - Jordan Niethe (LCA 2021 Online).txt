Title: "A New Type of Instruction for Power" - Jordan Niethe (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Jordan Niethe

https://lca2021.linux.org.au/schedule/presentation/44/

In the Linux kernel there are many times where we need to examine, manipulate and patch instructions, which is of course deeply tied to the instruction set of each architecture.
Like any good RISC architecture, Power has had a fixed instruction size. That only gives you so much space to play with, and we were running out of room.
Power10 presents a solution to that by introducing a new class of instructions which are twice as long.
This means our faithful "unsigned int" is no longer going to cut it as our instruction type and raises questions as how both types of instructions should be represented. Can we move to using "unsigned long"? Or a struct? How will this impact 32 bit and 64 bit systems? What about little and big endian ones? Do we have to change anything at all?
We will see how the mailing list's form of dialectic helps answer these questions.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Mon Jan 25 10:45:00 2021 at Blemings Labs
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,280 --> 00:00:19,520
to the bleming's lab

00:00:16,720 --> 00:00:20,080
uh today we have a fantastic lineup and

00:00:19,520 --> 00:00:22,320
i'm

00:00:20,080 --> 00:00:23,199
delighted to introduce our first speaker

00:00:22,320 --> 00:00:26,320
um in

00:00:23,199 --> 00:00:27,840
in this uh channel today jordan nithy

00:00:26,320 --> 00:00:29,840
uh will be talking to us about a new

00:00:27,840 --> 00:00:31,679
type of instruction for power

00:00:29,840 --> 00:00:33,280
jordan is a kernel hacker working on

00:00:31,679 --> 00:00:35,200
power at ibm's linux

00:00:33,280 --> 00:00:36,960
technology center we're not working on

00:00:35,200 --> 00:00:38,000
linux he likes to tinker with fourth and

00:00:36,960 --> 00:00:41,520
plan nine

00:00:38,000 --> 00:00:41,520
over to you jordan thank you very much

00:00:41,680 --> 00:00:45,600
great so hi everyone yes that's right

00:00:44,480 --> 00:00:49,120
i'm jordan

00:00:45,600 --> 00:00:51,280
and i work at auslabs in ibm camera

00:00:49,120 --> 00:00:53,120
and what i do is work on the linux

00:00:51,280 --> 00:00:56,480
kernel in particular

00:00:53,120 --> 00:00:56,480
on the power architecture

00:00:56,640 --> 00:00:59,680
and so what i'm going to be talking

00:00:58,399 --> 00:01:04,080
about today is

00:00:59,680 --> 00:01:07,360
a change to the to the power or power pc

00:01:04,080 --> 00:01:09,520
as you might know it architecture

00:01:07,360 --> 00:01:10,880
which is the introduction of a new type

00:01:09,520 --> 00:01:13,600
of instructions

00:01:10,880 --> 00:01:14,320
called prefix instructions and the

00:01:13,600 --> 00:01:17,840
process

00:01:14,320 --> 00:01:19,360
of supporting those in the kernel

00:01:17,840 --> 00:01:22,000
we will look at what prefixed

00:01:19,360 --> 00:01:24,640
instructions are and what problems it is

00:01:22,000 --> 00:01:26,799
that they help to solve for power

00:01:24,640 --> 00:01:30,560
then we will have a think about how the

00:01:26,799 --> 00:01:32,479
colonel will need to accommodate them

00:01:30,560 --> 00:01:34,880
finally we will look at how the mailing

00:01:32,479 --> 00:01:36,240
list shapes the form that these changes

00:01:34,880 --> 00:01:38,720
take

00:01:36,240 --> 00:01:39,840
so please bear with me when i talk about

00:01:38,720 --> 00:01:42,000
the kernel i

00:01:39,840 --> 00:01:43,520
normally mean the architecture specific

00:01:42,000 --> 00:01:45,680
parts to power

00:01:43,520 --> 00:01:46,720
and when i talk about the mailing list

00:01:45,680 --> 00:01:55,840
i'm in the

00:01:46,720 --> 00:01:55,840
powerpc mailing list

00:01:56,640 --> 00:02:00,719
so as i'm going to be talking about some

00:01:58,719 --> 00:02:01,600
changes to the power instruction set

00:02:00,719 --> 00:02:04,479
architecture

00:02:01,600 --> 00:02:06,479
or iso so that we are all on the same

00:02:04,479 --> 00:02:07,040
page i'd just like to give a brief kind

00:02:06,479 --> 00:02:08,959
of

00:02:07,040 --> 00:02:10,720
taste of the kind of the architecture

00:02:08,959 --> 00:02:13,040
that it is

00:02:10,720 --> 00:02:14,560
so power is the outgrowth of ibm's

00:02:13,040 --> 00:02:17,840
experiments

00:02:14,560 --> 00:02:19,920
with risk ideas in the 70s and 80s

00:02:17,840 --> 00:02:21,599
we don't really think about power being

00:02:19,920 --> 00:02:24,319
an acronym these days

00:02:21,599 --> 00:02:25,760
but performance optimization with

00:02:24,319 --> 00:02:28,720
enhanced risk

00:02:25,760 --> 00:02:30,560
pretty much spells out what the idea is

00:02:28,720 --> 00:02:33,920
compiling

00:02:30,560 --> 00:02:37,360
combining super scalar multi-dish patch

00:02:33,920 --> 00:02:39,200
execution with risk now

00:02:37,360 --> 00:02:40,560
we won't try and get too caught up in

00:02:39,200 --> 00:02:43,440
defining risk

00:02:40,560 --> 00:02:45,760
and cis architectures but there are

00:02:43,440 --> 00:02:48,879
certainly some things that are certainly

00:02:45,760 --> 00:02:51,840
more risky than others things like

00:02:48,879 --> 00:02:53,840
simplified memory access instructions

00:02:51,840 --> 00:02:57,200
single cycle instructions

00:02:53,840 --> 00:02:57,200
fixed length instructions

00:02:58,480 --> 00:03:01,840
now reduced doesn't necessarily mean

00:03:00,720 --> 00:03:04,239
simple and

00:03:01,840 --> 00:03:06,159
right from its inception power leaned

00:03:04,239 --> 00:03:09,920
much more heavily to the

00:03:06,159 --> 00:03:12,560
performance and enhanced side of things

00:03:09,920 --> 00:03:14,400
in its first very first iteration one of

00:03:12,560 --> 00:03:16,080
the things it did away with

00:03:14,400 --> 00:03:20,000
was getting rid of its predecessor's

00:03:16,080 --> 00:03:23,200
requirement for fixed cycle instructions

00:03:20,000 --> 00:03:26,239
then there are things like load multiple

00:03:23,200 --> 00:03:28,799
instructions string instructions an

00:03:26,239 --> 00:03:32,000
array of mask and shift operations

00:03:28,799 --> 00:03:35,840
transactional memory vectors

00:03:32,000 --> 00:03:35,840
a hash and a rhodex mmu

00:03:36,799 --> 00:03:42,319
hypervisor state and ultravisor state

00:03:40,480 --> 00:03:44,640
and there are some instructions with

00:03:42,319 --> 00:03:47,760
some very fun names such as

00:03:44,640 --> 00:03:53,360
the very rusticated in force in order

00:03:47,760 --> 00:03:53,360
execution of io or e-i-e-i-o

00:03:54,159 --> 00:03:58,560
and over time power has collected its

00:03:56,319 --> 00:04:00,959
fair share of operation modes

00:03:58,560 --> 00:04:01,920
to paint some very broad strokes here in

00:04:00,959 --> 00:04:05,360
the beginning

00:04:01,920 --> 00:04:08,560
it was just big ending under 32 bit

00:04:05,360 --> 00:04:10,080
then the power pc revision which some of

00:04:08,560 --> 00:04:11,360
you might be more familiar with this

00:04:10,080 --> 00:04:16,320
name

00:04:11,360 --> 00:04:18,320
this introduced an optional 64-bit mode

00:04:16,320 --> 00:04:20,479
then later on a little indian mode was

00:04:18,320 --> 00:04:21,440
introduced so that you can run in the

00:04:20,479 --> 00:04:24,960
correct ndn

00:04:21,440 --> 00:04:28,479
and little end down something that is

00:04:24,960 --> 00:04:32,400
important to note is that both the

00:04:28,479 --> 00:04:35,360
32-bit 64-bit and the endian-ness

00:04:32,400 --> 00:04:37,199
both endiannesses still continue to be

00:04:35,360 --> 00:04:40,479
used

00:04:37,199 --> 00:04:43,600
and need to be supported by the kernel

00:04:40,479 --> 00:04:44,639
so and now the latest revision of the

00:04:43,600 --> 00:04:48,080
iso

00:04:44,639 --> 00:04:50,320
is this we're up to iso version 3.1

00:04:48,080 --> 00:04:51,600
which is uh implemented in the

00:04:50,320 --> 00:04:55,360
forthcoming power

00:04:51,600 --> 00:04:57,600
10 release

00:04:55,360 --> 00:05:01,199
so hopefully that at least gives you a

00:04:57,600 --> 00:05:01,199
bit of a feel for power

00:05:03,840 --> 00:05:11,039
and so now that we have a feel for the

00:05:06,880 --> 00:05:13,759
kind of richness that power has

00:05:11,039 --> 00:05:15,039
then you might you can see why one day

00:05:13,759 --> 00:05:17,520
you might

00:05:15,039 --> 00:05:21,039
reach the limit of what can be done with

00:05:17,520 --> 00:05:24,320
a fixed sized 32-bit instruction

00:05:21,039 --> 00:05:26,720
so there has been some

00:05:24,320 --> 00:05:28,800
experiments in power with denser

00:05:26,720 --> 00:05:32,560
encoding allah

00:05:28,800 --> 00:05:35,280
um's arms thumb mode but we won't really

00:05:32,560 --> 00:05:35,280
go into that

00:05:35,759 --> 00:05:39,199
and so there are kind of two problems

00:05:37,440 --> 00:05:41,280
that you run into

00:05:39,199 --> 00:05:42,720
not enough opcode space for adding

00:05:41,280 --> 00:05:44,960
instructions

00:05:42,720 --> 00:05:46,479
and the need to encode more information

00:05:44,960 --> 00:05:49,680
into an instruction

00:05:46,479 --> 00:05:49,680
than can physically fit

00:05:49,759 --> 00:05:53,919
so power 10 provides an answer to these

00:05:51,919 --> 00:05:55,120
troubles with a whole new type of

00:05:53,919 --> 00:05:58,240
instructions

00:05:55,120 --> 00:06:00,000
the so-called prefixed instructions

00:05:58,240 --> 00:06:01,600
whereas instructions had always been

00:06:00,000 --> 00:06:05,039
four bytes

00:06:01,600 --> 00:06:09,360
which is a word length and an unsigned

00:06:05,039 --> 00:06:11,039
int and u32

00:06:09,360 --> 00:06:13,120
now there are instructions that are

00:06:11,039 --> 00:06:15,440
double as long

00:06:13,120 --> 00:06:18,840
and they're composed of a word length

00:06:15,440 --> 00:06:22,160
prefix followed by a word length self

00:06:18,840 --> 00:06:25,199
effects to give a motivating example

00:06:22,160 --> 00:06:27,199
of why add prefixed instructions

00:06:25,199 --> 00:06:29,600
we'll take a look at a problem that they

00:06:27,199 --> 00:06:33,199
can help solve for the gnu tool chain

00:06:29,600 --> 00:06:34,319
on power so what we have over here are

00:06:33,199 --> 00:06:38,160
just some

00:06:34,319 --> 00:06:38,880
normal were um normal load instructions

00:06:38,160 --> 00:06:41,280
which

00:06:38,880 --> 00:06:42,720
probably look pretty familiar from any

00:06:41,280 --> 00:06:46,960
architecture

00:06:42,720 --> 00:06:50,319
so you can see we have our 32-bit

00:06:46,960 --> 00:06:53,360
long instruction with an op code

00:06:50,319 --> 00:06:54,160
here then registers encoded here and

00:06:53,360 --> 00:06:57,680
here

00:06:54,160 --> 00:07:02,000
and then embedded in the instruction

00:06:57,680 --> 00:07:04,160
a 16 bit um offset

00:07:02,000 --> 00:07:05,919
and so what's going to happen is the

00:07:04,160 --> 00:07:09,520
address in ra

00:07:05,919 --> 00:07:11,840
will get the offset added to it then

00:07:09,520 --> 00:07:14,720
uh the word from that address will be

00:07:11,840 --> 00:07:16,400
loaded into rt

00:07:14,720 --> 00:07:18,000
and so as we were saying a word is

00:07:16,400 --> 00:07:22,240
32-bit

00:07:18,000 --> 00:07:25,840
but then as um as the power p

00:07:22,240 --> 00:07:28,400
c revision introduced 64-bit gps

00:07:25,840 --> 00:07:30,960
then there came the need for adding a

00:07:28,400 --> 00:07:34,639
new instruction type

00:07:30,960 --> 00:07:38,960
this ds form which will

00:07:34,639 --> 00:07:42,479
deal with these six 64 byte loads

00:07:38,960 --> 00:07:44,319
and to deal with that two bits were

00:07:42,479 --> 00:07:47,199
taken away from the

00:07:44,319 --> 00:07:49,280
displacement to be used as part of the

00:07:47,199 --> 00:07:51,120
instruction encoding

00:07:49,280 --> 00:07:53,360
so now those two bits that are taken

00:07:51,120 --> 00:07:56,240
away are basically

00:07:53,360 --> 00:07:57,199
always treated as zero which limits the

00:07:56,240 --> 00:08:00,720
alignment that

00:07:57,199 --> 00:08:05,759
this offset is able to access

00:08:00,720 --> 00:08:05,759
and then further for quadword or

00:08:07,919 --> 00:08:13,039
128 bit loads another two bits were

00:08:11,840 --> 00:08:16,000
taken away

00:08:13,039 --> 00:08:17,840
from the uh offset which limits the kind

00:08:16,000 --> 00:08:20,879
of alignments that you can access

00:08:17,840 --> 00:08:24,000
even more so now

00:08:20,879 --> 00:08:25,520
the load quad is not necessarily the

00:08:24,000 --> 00:08:28,720
most

00:08:25,520 --> 00:08:32,080
useful instruction but

00:08:28,720 --> 00:08:32,080
vectors which um

00:08:32,560 --> 00:08:37,120
you know they are longer they are

00:08:34,399 --> 00:08:41,039
normally 128 bit

00:08:37,120 --> 00:08:44,000
then they also use this dq form and

00:08:41,039 --> 00:08:46,240
then that stick the dq form starts to

00:08:44,000 --> 00:08:49,279
look pretty useful

00:08:46,240 --> 00:08:50,560
but just keep in mind that those bits

00:08:49,279 --> 00:08:54,880
taken away

00:08:50,560 --> 00:08:56,560
from the alignment of the address

00:08:54,880 --> 00:08:58,080
those bits taken away affect the

00:08:56,560 --> 00:09:00,480
alignments that you're going to be able

00:08:58,080 --> 00:09:00,480
to use

00:09:02,000 --> 00:09:05,360
and so in particular to have a look at

00:09:04,320 --> 00:09:09,040
the kind of

00:09:05,360 --> 00:09:09,600
problems that can cause for the tool

00:09:09,040 --> 00:09:13,760
chain

00:09:09,600 --> 00:09:13,760
maintaining that quad word alignment

00:09:14,480 --> 00:09:18,560
is a burdensome for the tool chain to

00:09:17,279 --> 00:09:20,800
have to deal with

00:09:18,560 --> 00:09:22,480
and for certain models of position

00:09:20,800 --> 00:09:24,959
independent code

00:09:22,480 --> 00:09:26,720
this kind of address with offset is

00:09:24,959 --> 00:09:27,920
basically the tool chains bread and

00:09:26,720 --> 00:09:30,880
bottom

00:09:27,920 --> 00:09:34,080
when it comes to static data objects so

00:09:30,880 --> 00:09:37,200
as you can see in this kind of

00:09:34,080 --> 00:09:37,920
that might be compiled down um off

00:09:37,200 --> 00:09:41,519
screen here

00:09:37,920 --> 00:09:44,640
imagine r2 is being set up to a table

00:09:41,519 --> 00:09:46,959
which will hold the value um

00:09:44,640 --> 00:09:48,000
hold locations for the source and

00:09:46,959 --> 00:09:50,640
destination

00:09:48,000 --> 00:09:52,160
so the tool chain is able to do things

00:09:50,640 --> 00:09:56,240
um

00:09:52,160 --> 00:09:56,240
relative to that using the offsets

00:09:56,800 --> 00:10:00,880
but for vector operations because of

00:09:58,959 --> 00:10:04,560
their using the dq form

00:10:00,880 --> 00:10:05,519
and the um difficulty that the tool

00:10:04,560 --> 00:10:07,920
chain

00:10:05,519 --> 00:10:09,040
you know needs to go to to maintain quad

00:10:07,920 --> 00:10:12,880
word

00:10:09,040 --> 00:10:15,920
alignment in um

00:10:12,880 --> 00:10:17,839
in arterial the talk

00:10:15,920 --> 00:10:20,000
then this kind of form cannot really

00:10:17,839 --> 00:10:22,240
easily be used for vectors

00:10:20,000 --> 00:10:24,480
and so you have to kind of do it another

00:10:22,240 --> 00:10:24,480
way

00:10:27,920 --> 00:10:32,079
and now let's have a look at how one of

00:10:30,240 --> 00:10:35,120
these prefixed instructions

00:10:32,079 --> 00:10:38,560
helps us solve the problem

00:10:35,120 --> 00:10:43,120
so to go with our loads with offsets

00:10:38,560 --> 00:10:46,560
we have this new prefix load

00:10:43,120 --> 00:10:49,760
and so as you can see we have the 32-bit

00:10:46,560 --> 00:10:53,680
prefix with a 32-bit suffix

00:10:49,760 --> 00:10:56,720
and now the displacement

00:10:53,680 --> 00:10:58,079
is encoded as the concatenation between

00:10:56,720 --> 00:11:01,279
this d0

00:10:58,079 --> 00:11:04,399
and d1 and as you can see

00:11:01,279 --> 00:11:05,040
there's no there's nothing taken away

00:11:04,399 --> 00:11:08,000
from the

00:11:05,040 --> 00:11:09,040
displacement to be used for the offset

00:11:08,000 --> 00:11:12,720
so you have no

00:11:09,040 --> 00:11:16,399
troubles with uh

00:11:12,720 --> 00:11:19,600
using any kind of address

00:11:16,399 --> 00:11:21,760
and yeah so you have 34 bits that's

00:11:19,600 --> 00:11:23,120
unfortunately not a factorial but just

00:11:21,760 --> 00:11:28,000
me expressing my

00:11:23,120 --> 00:11:29,839
enthusiasm um

00:11:28,000 --> 00:11:32,160
so we've doubled the space there's a

00:11:29,839 --> 00:11:33,519
whole new possibilities that open up for

00:11:32,160 --> 00:11:35,519
instructions

00:11:33,519 --> 00:11:37,519
for example this very form has another

00:11:35,519 --> 00:11:41,600
trick up at sleeve

00:11:37,519 --> 00:11:41,600
flipping this this r bit

00:11:41,760 --> 00:11:46,640
we'll change the instruction to use pc

00:11:44,560 --> 00:11:49,839
relative addressing

00:11:46,640 --> 00:11:51,120
which is a new uh addressing mode for

00:11:49,839 --> 00:11:53,360
power

00:11:51,120 --> 00:11:54,160
where the displacement is instead added

00:11:53,360 --> 00:11:57,360
to the current

00:11:54,160 --> 00:12:00,000
instruction pointer which

00:11:57,360 --> 00:12:01,360
you know has some cool benefits such as

00:12:00,000 --> 00:12:04,720
no longer

00:12:01,360 --> 00:12:06,560
needing to use a talk at all

00:12:04,720 --> 00:12:08,399
and of course these are not this is not

00:12:06,560 --> 00:12:11,360
the only

00:12:08,399 --> 00:12:12,720
new prefixed instruction there's a whole

00:12:11,360 --> 00:12:15,519
lot of new

00:12:12,720 --> 00:12:17,360
vector operations as well and if you're

00:12:15,519 --> 00:12:21,120
interested in seeing more of them

00:12:17,360 --> 00:12:21,120
i encourage you to take a look in the

00:12:22,839 --> 00:12:27,360
iso

00:12:24,560 --> 00:12:28,480
so whilst power now has variable length

00:12:27,360 --> 00:12:30,720
instructions

00:12:28,480 --> 00:12:31,600
it is still very much less freeform than

00:12:30,720 --> 00:12:35,839
something like

00:12:31,600 --> 00:12:37,120
x86 the instructions can only be word or

00:12:35,839 --> 00:12:40,160
double length

00:12:37,120 --> 00:12:43,839
and further to that all of the prefixes

00:12:40,160 --> 00:12:47,279
share this unique op code of

00:12:43,839 --> 00:12:49,839
of one so that

00:12:47,279 --> 00:12:51,279
if you see that then you always know

00:12:49,839 --> 00:12:53,279
that there's going to be a suffix

00:12:51,279 --> 00:12:55,839
following

00:12:53,279 --> 00:12:56,800
uh of course nothing costs nothing and

00:12:55,839 --> 00:12:58,880
there are some

00:12:56,800 --> 00:13:00,720
restrictions that these new prefix

00:12:58,880 --> 00:13:05,040
instructions bring with them

00:13:00,720 --> 00:13:05,040
in the hardware so

00:13:05,120 --> 00:13:08,160
so you cannot have a prefixed

00:13:07,200 --> 00:13:10,720
instruction

00:13:08,160 --> 00:13:13,120
that straddles a 64 byte boundary for

00:13:10,720 --> 00:13:13,120
example

00:13:16,160 --> 00:13:20,000
so for more information about how

00:13:18,240 --> 00:13:22,079
exactly these changes benefit

00:13:20,000 --> 00:13:23,279
and affect the tool chain there's a

00:13:22,079 --> 00:13:25,680
great talk given by

00:13:23,279 --> 00:13:27,839
mike meisner and bill schmidt that i

00:13:25,680 --> 00:13:35,839
shall have a link for in the final slide

00:13:27,839 --> 00:13:35,839
if you'd like to check that out

00:13:39,839 --> 00:13:43,519
and so now we have met our new type of

00:13:42,240 --> 00:13:45,680
instructions

00:13:43,519 --> 00:13:48,639
and seen some of the potential benefits

00:13:45,680 --> 00:13:50,880
that they might bring to our user space

00:13:48,639 --> 00:13:51,760
so now we come to thinking about how do

00:13:50,880 --> 00:13:53,839
these changes

00:13:51,760 --> 00:13:56,880
affect the kernel again the power

00:13:53,839 --> 00:13:59,360
specific parts of the kernel

00:13:56,880 --> 00:14:01,120
well for one thing we'll have to flip a

00:13:59,360 --> 00:14:03,680
bit to turn them on

00:14:01,120 --> 00:14:06,079
which actually is not as straightforward

00:14:03,680 --> 00:14:09,600
as one might think in power's

00:14:06,079 --> 00:14:12,240
initialization code but beyond that

00:14:09,600 --> 00:14:13,920
just to get in the right frame of mind

00:14:12,240 --> 00:14:14,880
let's have a think about some of the

00:14:13,920 --> 00:14:16,959
places

00:14:14,880 --> 00:14:20,320
where the kernel might need to be

00:14:16,959 --> 00:14:20,320
looking at instructions

00:14:21,600 --> 00:14:27,279
so imagine a user space program

00:14:24,720 --> 00:14:29,519
happily interacting with some region of

00:14:27,279 --> 00:14:33,360
cache inhibited memory

00:14:29,519 --> 00:14:33,360
maybe an i o device or something

00:14:33,600 --> 00:14:37,680
now we wouldn't necessarily expect the

00:14:35,600 --> 00:14:40,399
programmer of said program

00:14:37,680 --> 00:14:42,639
was writing assembly and choosing these

00:14:40,399 --> 00:14:45,839
new prefixed instructions

00:14:42,639 --> 00:14:48,959
but the tool chain may have used one

00:14:45,839 --> 00:14:51,360
and so something about power is that

00:14:48,959 --> 00:14:52,160
an instruction doing an unaligned access

00:14:51,360 --> 00:14:54,639
to a cache

00:14:52,160 --> 00:14:56,079
inhibited location will trigger an

00:14:54,639 --> 00:14:58,160
exception

00:14:56,079 --> 00:15:00,959
so that means we'll jump to an exception

00:14:58,160 --> 00:15:03,920
vector and switch to supervisor mode

00:15:00,959 --> 00:15:05,760
and we're then in the kernel we would

00:15:03,920 --> 00:15:07,040
still like the user to be able to

00:15:05,760 --> 00:15:08,720
perform this load

00:15:07,040 --> 00:15:10,560
so the kernel then reads in the

00:15:08,720 --> 00:15:11,760
instruction at the current instruction

00:15:10,560 --> 00:15:15,680
pointer

00:15:11,760 --> 00:15:17,360
analyzes it and if it can emulates it

00:15:15,680 --> 00:15:18,959
before returning back to the user

00:15:17,360 --> 00:15:21,440
without them ever knowing what have

00:15:18,959 --> 00:15:21,440
happened

00:15:23,760 --> 00:15:28,480
if the talk about kernel self-tests on

00:15:26,320 --> 00:15:30,560
saturday got you interested

00:15:28,480 --> 00:15:32,320
you might be not interested to know that

00:15:30,560 --> 00:15:34,800
there's a self-test for power that in

00:15:32,320 --> 00:15:38,240
fact does this very task

00:15:34,800 --> 00:15:40,000
and you can see how one might use

00:15:38,240 --> 00:15:43,440
prefix instructions before they're

00:15:40,000 --> 00:15:43,440
supported in the tool chain

00:15:44,880 --> 00:15:49,120
so the kernel on power then has a whole

00:15:47,279 --> 00:15:51,360
infrastructure for analyzing

00:15:49,120 --> 00:15:54,480
emulating patching and just otherwise

00:15:51,360 --> 00:15:58,160
manipulating instructions

00:15:54,480 --> 00:16:00,480
and so in all of this we have just been

00:15:58,160 --> 00:16:00,880
able to treat instructions as a regular

00:16:00,480 --> 00:16:04,000
old

00:16:00,880 --> 00:16:06,720
unsigned in u32 so

00:16:04,000 --> 00:16:07,839
that it like to to read an instruction

00:16:06,720 --> 00:16:11,120
from the user

00:16:07,839 --> 00:16:11,600
you can just use the regular function

00:16:11,120 --> 00:16:15,360
slash

00:16:11,600 --> 00:16:17,759
macro for integers there

00:16:15,360 --> 00:16:18,680
and this is kind of just an example of

00:16:17,759 --> 00:16:21,360
the sort of

00:16:18,680 --> 00:16:22,160
prototypical function that exists for

00:16:21,360 --> 00:16:25,279
dealing with

00:16:22,160 --> 00:16:30,480
instructions in power and

00:16:25,279 --> 00:16:30,480
how that passed around as an unsigned

00:16:34,839 --> 00:16:37,839
end

00:16:39,199 --> 00:16:43,519
so it's not just emulating instructions

00:16:41,519 --> 00:16:46,399
for the user space that the kernel needs

00:16:43,519 --> 00:16:48,160
to use this infrastructure

00:16:46,399 --> 00:16:49,920
often in the kernel there is code

00:16:48,160 --> 00:16:52,959
patching in which the kernel image

00:16:49,920 --> 00:16:55,519
itself is modified in particular within

00:16:52,959 --> 00:16:57,839
debugging and tracing code of the kernel

00:16:55,519 --> 00:16:59,360
the nature of instructions comes into

00:16:57,839 --> 00:17:02,480
play

00:16:59,360 --> 00:17:05,600
things like k-probes f-trace kdbug

00:17:02,480 --> 00:17:08,000
etc these are architecture

00:17:05,600 --> 00:17:09,839
independent features of the kernel but

00:17:08,000 --> 00:17:10,160
it's up to each architecture to fill in

00:17:09,839 --> 00:17:13,439
their

00:17:10,160 --> 00:17:16,880
low-level nuts and bolts

00:17:13,439 --> 00:17:19,360
so take k-probes for example

00:17:16,880 --> 00:17:20,400
in which you can attach a callback to be

00:17:19,360 --> 00:17:22,400
that will be triggered

00:17:20,400 --> 00:17:24,240
in response to a kernel address being

00:17:22,400 --> 00:17:27,199
executed

00:17:24,240 --> 00:17:28,240
you'll patch in a trap at that uh

00:17:27,199 --> 00:17:31,520
address

00:17:28,240 --> 00:17:34,160
then when that trap is uh hit in the

00:17:31,520 --> 00:17:36,160
handler you'll do your callbacks then

00:17:34,160 --> 00:17:37,200
you can either emulate that replaced

00:17:36,160 --> 00:17:40,480
instruction

00:17:37,200 --> 00:17:42,400
or you'll have it copied somewhere out

00:17:40,480 --> 00:17:44,640
somewhere else to be executed out of

00:17:42,400 --> 00:17:44,640
line

00:17:44,720 --> 00:17:49,600
and so you can see how the specific

00:17:46,559 --> 00:17:51,840
nature of instructions

00:17:49,600 --> 00:17:53,919
in an architecture are important when it

00:17:51,840 --> 00:17:57,440
comes to this sort of thing

00:17:53,919 --> 00:17:59,039
and so the fruit k probes provides this

00:17:57,440 --> 00:18:01,600
sort of struct and some

00:17:59,039 --> 00:18:04,400
helper functions that you can fill in so

00:18:01,600 --> 00:18:08,559
that each architecture can

00:18:04,400 --> 00:18:08,559
suit things to their own requirements

00:18:10,320 --> 00:18:14,240
and of course power also has some of its

00:18:13,360 --> 00:18:18,640
own specific

00:18:14,240 --> 00:18:18,640
stuff like its debugger x-men

00:18:25,760 --> 00:18:30,080
so the introduction of prefixed

00:18:28,720 --> 00:18:31,840
instructions

00:18:30,080 --> 00:18:33,440
brings with it a whole new range of

00:18:31,840 --> 00:18:35,600
complications

00:18:33,440 --> 00:18:38,240
some obvious some subtle to be

00:18:35,600 --> 00:18:38,240
considered

00:18:39,280 --> 00:18:42,640
assumptions of a fixed 32-bit

00:18:41,520 --> 00:18:46,080
instruction size

00:18:42,640 --> 00:18:48,799
run pretty deep on power when we need to

00:18:46,080 --> 00:18:50,640
load instructions for the user space

00:18:48,799 --> 00:18:53,840
it now might be necessary to load a

00:18:50,640 --> 00:18:56,000
second word of a prefixed instruction

00:18:53,840 --> 00:18:58,799
we also need to add emulation for all

00:18:56,000 --> 00:19:01,280
these new instructions

00:18:58,799 --> 00:19:03,360
for within the kernel when replacing an

00:19:01,280 --> 00:19:05,760
instruction with a trap

00:19:03,360 --> 00:19:07,200
with the intention to emulate it we are

00:19:05,760 --> 00:19:09,600
now going to need

00:19:07,200 --> 00:19:11,919
to check if we need to be saving the

00:19:09,600 --> 00:19:14,160
second word of a prefixed instruction as

00:19:11,919 --> 00:19:14,160
well

00:19:15,120 --> 00:19:18,400
or that we're not trying to put the

00:19:17,039 --> 00:19:20,400
breakpoint

00:19:18,400 --> 00:19:22,960
on the second word of a prefixed

00:19:20,400 --> 00:19:25,360
instruction

00:19:22,960 --> 00:19:26,640
some suffixes are actually legal normal

00:19:25,360 --> 00:19:28,880
instructions

00:19:26,640 --> 00:19:29,840
so what if f prefix is replaced with a

00:19:28,880 --> 00:19:32,080
trap

00:19:29,840 --> 00:19:34,240
then later the user tries to do the same

00:19:32,080 --> 00:19:36,559
with the suffix

00:19:34,240 --> 00:19:37,360
well now it just looks like a normal

00:19:36,559 --> 00:19:40,480
instruction

00:19:37,360 --> 00:19:41,840
after a trap if we're going to be

00:19:40,480 --> 00:19:44,160
stepping out of line

00:19:41,840 --> 00:19:46,960
then there needs to be enough space for

00:19:44,160 --> 00:19:48,960
holding double length instructions

00:19:46,960 --> 00:19:53,840
and yet for normal instructions we don't

00:19:48,960 --> 00:19:53,840
want to be leaving a gap after them

00:19:54,640 --> 00:19:59,120
and then as we were saying at the

00:19:56,160 --> 00:20:00,320
beginning power is capable of running in

00:19:59,120 --> 00:20:03,600
big endian mode

00:20:00,320 --> 00:20:06,159
as well as little endian mode

00:20:03,600 --> 00:20:07,200
with prefixed instructions regardless of

00:20:06,159 --> 00:20:10,480
the endianness

00:20:07,200 --> 00:20:12,640
the prefix obviously comes first so

00:20:10,480 --> 00:20:14,320
care needs to be taken if trying to load

00:20:12,640 --> 00:20:16,400
a prefix

00:20:14,320 --> 00:20:17,600
instruction using a low double

00:20:16,400 --> 00:20:19,600
instruction

00:20:17,600 --> 00:20:21,039
because depending on what endian mode

00:20:19,600 --> 00:20:23,280
you're running in

00:20:21,039 --> 00:20:25,440
things could end up in the wrong order

00:20:23,280 --> 00:20:28,640
with the prefix and the suffix

00:20:25,440 --> 00:20:28,640
being around the wrong way

00:20:28,960 --> 00:20:32,640
and the same thing for writing

00:20:30,240 --> 00:20:34,720
instructions

00:20:32,640 --> 00:20:36,480
also you do not want to be just loading

00:20:34,720 --> 00:20:38,480
double words constantly

00:20:36,480 --> 00:20:41,280
as if you need to read a word

00:20:38,480 --> 00:20:43,679
instruction that's at the end of a page

00:20:41,280 --> 00:20:45,840
but instead now read a double word

00:20:43,679 --> 00:20:48,159
you'll read over the end of the page

00:20:45,840 --> 00:20:50,960
which could trigger a page fault

00:20:48,159 --> 00:20:54,320
and in certain situations is definitely

00:20:50,960 --> 00:20:54,320
not what you want to happen

00:20:58,000 --> 00:21:03,039
and so for executing out of line now the

00:21:01,039 --> 00:21:04,799
location that is used will need to obey

00:21:03,039 --> 00:21:06,960
the alignment restrictions

00:21:04,799 --> 00:21:09,919
of the prefixed instructions and about

00:21:06,960 --> 00:21:11,919
not crossing 64 byte boundaries

00:21:09,919 --> 00:21:15,919
of wires you'll get an exception when it

00:21:11,919 --> 00:21:16,799
comes time to actually trying to step it

00:21:15,919 --> 00:21:19,679
or

00:21:16,799 --> 00:21:21,280
you want to skip an instruction normally

00:21:19,679 --> 00:21:24,320
we just add

00:21:21,280 --> 00:21:31,840
plus 4 to the instruction pointer

00:21:24,320 --> 00:21:31,840
but um

00:21:32,880 --> 00:21:37,039
but we have some cases like where we

00:21:35,120 --> 00:21:40,240
have 32-bit models

00:21:37,039 --> 00:21:42,240
of power which will never potentially

00:21:40,240 --> 00:21:44,720
have prefixed instructions

00:21:42,240 --> 00:21:46,880
and all of the existing models that

00:21:44,720 --> 00:21:49,840
don't have prefixed instructions

00:21:46,880 --> 00:21:52,320
we don't want to have any changes to the

00:21:49,840 --> 00:21:59,840
in the kernel to negatively impact

00:21:52,320 --> 00:21:59,840
such machines

00:22:00,080 --> 00:22:04,480
so now we have a fair idea of the sorts

00:22:02,720 --> 00:22:07,360
of places in the kernel

00:22:04,480 --> 00:22:08,880
that we are going to need to update and

00:22:07,360 --> 00:22:12,159
we have a fair idea

00:22:08,880 --> 00:22:14,320
of what's going to need to be changed

00:22:12,159 --> 00:22:17,120
but the question still remains of how

00:22:14,320 --> 00:22:18,880
are we going to make the changes

00:22:17,120 --> 00:22:21,600
what is going to be the best most

00:22:18,880 --> 00:22:24,159
aesthetic way

00:22:21,600 --> 00:22:26,000
to make those changes or at least what

00:22:24,159 --> 00:22:29,039
is going to

00:22:26,000 --> 00:22:32,799
most favorably balance the some

00:22:29,039 --> 00:22:32,799
of our competing requirements

00:22:33,760 --> 00:22:37,360
so what is going to replace our unsigned

00:22:36,799 --> 00:22:38,960
in

00:22:37,360 --> 00:22:42,240
in all of the places that we've been

00:22:38,960 --> 00:22:42,240
dealing with instructions

00:22:44,000 --> 00:22:47,120
there are a few sort of options that

00:22:46,400 --> 00:22:50,240
seem like

00:22:47,120 --> 00:22:50,240
they might be feasible

00:22:50,400 --> 00:22:53,520
one might think well a prefixed

00:22:52,640 --> 00:22:56,880
instruction

00:22:53,520 --> 00:23:00,320
is after all a word length prefix

00:22:56,880 --> 00:23:03,600
followed by a word length suffix so

00:23:00,320 --> 00:23:05,600
they are a bit of a special case

00:23:03,600 --> 00:23:08,080
and so potentially we might just treat

00:23:05,600 --> 00:23:10,240
them as two separate ends

00:23:08,080 --> 00:23:11,360
and if we squint our eyes that might be

00:23:10,240 --> 00:23:15,039
okay

00:23:11,360 --> 00:23:15,919
and maybe a lot of places where we don't

00:23:15,039 --> 00:23:18,000
expect

00:23:15,919 --> 00:23:22,320
prefixed instructions are going to end

00:23:18,000 --> 00:23:23,360
up can just continue as they were but of

00:23:22,320 --> 00:23:27,039
course then our

00:23:23,360 --> 00:23:27,919
functions dealing with instructions and

00:23:27,039 --> 00:23:30,159
now

00:23:27,919 --> 00:23:32,799
would have to take another parameter for

00:23:30,159 --> 00:23:36,159
the suffix

00:23:32,799 --> 00:23:37,760
and it does seem to miss the fact

00:23:36,159 --> 00:23:40,320
that in fact there is a deeper

00:23:37,760 --> 00:23:43,120
connection here between the prefix and

00:23:40,320 --> 00:23:43,120
the suffix

00:23:46,080 --> 00:23:50,960
so another way to look at things might

00:23:48,320 --> 00:23:52,159
be to say well we now have double the

00:23:50,960 --> 00:23:55,200
length of instruction

00:23:52,159 --> 00:23:58,720
so why not go from an unsigned int to an

00:23:55,200 --> 00:24:00,960
unsigned long or a u64

00:23:58,720 --> 00:24:03,200
but it does seem that that could

00:24:00,960 --> 00:24:05,039
potentially lead to some problems

00:24:03,200 --> 00:24:06,720
with the issues we were talking about

00:24:05,039 --> 00:24:09,679
with the fact that

00:24:06,720 --> 00:24:12,159
it's not really an unsigned long in

00:24:09,679 --> 00:24:15,520
regards to endianness

00:24:12,159 --> 00:24:21,120
and could we be wasting space by using

00:24:15,520 --> 00:24:24,799
u64s everywhere and if we're not careful

00:24:21,120 --> 00:24:28,240
then people could end up mixing up the

00:24:24,799 --> 00:24:28,240
prefix and the suffix

00:24:31,279 --> 00:24:36,400
or what about maybe using a derived type

00:24:34,320 --> 00:24:38,240
our instructions do now seem to be

00:24:36,400 --> 00:24:41,039
something of a sum

00:24:38,240 --> 00:24:41,679
could a union be useful there is some

00:24:41,039 --> 00:24:44,799
precedent

00:24:41,679 --> 00:24:46,320
in the kernel for using derived types

00:24:44,799 --> 00:24:49,840
for instance that should not be used

00:24:46,320 --> 00:24:52,559
directly things like page table types

00:24:49,840 --> 00:24:54,480
where we have things like pmd slat

00:24:52,559 --> 00:24:57,440
underscore t

00:24:54,480 --> 00:24:59,440
west rocks are used to wrap an integer

00:24:57,440 --> 00:25:00,480
to stop it being directly used

00:24:59,440 --> 00:25:03,360
incorrectly

00:25:00,480 --> 00:25:03,360
incorrectly

00:25:04,320 --> 00:25:07,840
so i tossed and turned about how to

00:25:06,240 --> 00:25:09,679
proceed here and

00:25:07,840 --> 00:25:12,240
tried to theorycraft what was going to

00:25:09,679 --> 00:25:15,360
be the best option

00:25:12,240 --> 00:25:28,080
and bounced ideas off colleagues with

00:25:15,360 --> 00:25:31,200
uh thanks to alistair pogba

00:25:28,080 --> 00:25:33,919
really you just have to yeah at the end

00:25:31,200 --> 00:25:36,720
you kind of have to start somewhere

00:25:33,919 --> 00:25:38,080
so to went with it to make a start i

00:25:36,720 --> 00:25:40,559
went with the option

00:25:38,080 --> 00:25:41,600
of passing around suffixes as a second

00:25:40,559 --> 00:25:44,640
word

00:25:41,600 --> 00:25:47,039
my thinking here was

00:25:44,640 --> 00:25:48,559
there's a bunch of booky 32-bit stuff

00:25:47,039 --> 00:25:50,720
lying around that i don't want to

00:25:48,559 --> 00:25:54,640
inadvertently mess up

00:25:50,720 --> 00:25:56,720
at least doing it this way the users

00:25:54,640 --> 00:25:57,760
who won't encounter prefixed

00:25:56,720 --> 00:25:59,679
instructions

00:25:57,760 --> 00:26:01,360
can kind of just not keep on doing what

00:25:59,679 --> 00:26:04,240
they're doing

00:26:01,360 --> 00:26:05,120
with the penalty of passing in a dummy

00:26:04,240 --> 00:26:08,559
suffix

00:26:05,120 --> 00:26:11,840
parameter they could basically pretend

00:26:08,559 --> 00:26:11,840
the suffix won't exist

00:26:11,919 --> 00:26:14,880
so i went this

00:26:15,760 --> 00:26:20,960
this initial series um the initial

00:26:18,559 --> 00:26:22,320
prefixed instruction list to the ppc

00:26:20,960 --> 00:26:27,760
mailing list

00:26:22,320 --> 00:26:27,760
on back in 2019 november

00:26:30,559 --> 00:26:34,960
and just to try to give a feel of the

00:26:32,880 --> 00:26:38,080
kind of change that we're making

00:26:34,960 --> 00:26:40,320
our prototypical

00:26:38,080 --> 00:26:41,440
of function now takes this second word

00:26:40,320 --> 00:26:44,559
parameter

00:26:41,440 --> 00:26:46,880
and all the places where we expect that

00:26:44,559 --> 00:26:50,840
there might be a prefix instruction

00:26:46,880 --> 00:26:54,080
have their own kind of ad hoc open coded

00:26:50,840 --> 00:26:56,320
loading loading and storing to deal with

00:26:54,080 --> 00:26:56,320
that

00:26:58,559 --> 00:27:04,400
so after a a little delay i guess

00:27:01,919 --> 00:27:06,400
for people to have a chance to read

00:27:04,400 --> 00:27:09,520
through the whole um

00:27:06,400 --> 00:27:11,760
you know to read through a lot of great

00:27:09,520 --> 00:27:13,840
feedback starts to roll in from a lot of

00:27:11,760 --> 00:27:17,440
people

00:27:13,840 --> 00:27:19,120
you know things from uh tips and little

00:27:17,440 --> 00:27:23,120
pointers um

00:27:19,120 --> 00:27:25,520
testing all the way from typos

00:27:23,120 --> 00:27:26,159
through to letting me know that i had

00:27:25,520 --> 00:27:31,600
once again

00:27:26,159 --> 00:27:31,600
broken compiling on 32-bit ppc

00:27:32,840 --> 00:27:37,520
now however there's one comment

00:27:35,760 --> 00:27:40,399
as much as i suppose it shouldn't have

00:27:37,520 --> 00:27:42,320
surprised me it did shock me in that

00:27:40,399 --> 00:27:44,880
how straight away they got to the heart

00:27:42,320 --> 00:27:44,880
of the issue

00:27:45,120 --> 00:27:49,360
so i'm not necessarily saying this is

00:27:47,360 --> 00:27:52,480
better but did you consider

00:27:49,360 --> 00:27:53,120
making instru 64 bits and using masking

00:27:52,480 --> 00:27:55,840
and shift

00:27:53,120 --> 00:27:56,640
macros to get the prefix and suffix

00:27:55,840 --> 00:27:59,039
defining an

00:27:56,640 --> 00:28:01,919
instruction type struct union whatever

00:27:59,039 --> 00:28:03,679
that contained both halves in one object

00:28:01,919 --> 00:28:04,240
i'm just happy to be told that it ends

00:28:03,679 --> 00:28:06,880
up

00:28:04,240 --> 00:28:07,600
being way way ugly or worse etc but i

00:28:06,880 --> 00:28:11,600
thought i would

00:28:07,600 --> 00:28:15,039
ask so this hit the nail

00:28:11,600 --> 00:28:17,120
right on the head i was a little

00:28:15,039 --> 00:28:18,399
reluctant to immediately go back to the

00:28:17,120 --> 00:28:21,039
drawing board

00:28:18,399 --> 00:28:21,760
as let's say at this point i did not

00:28:21,039 --> 00:28:25,120
have the most

00:28:21,760 --> 00:28:27,279
efficient testing workflow so i did try

00:28:25,120 --> 00:28:29,440
to mount a rather half-hearted defense

00:28:27,279 --> 00:28:30,399
but started experimenting with those

00:28:29,440 --> 00:28:33,919
other

00:28:30,399 --> 00:28:37,200
options in more earnest and then

00:28:33,919 --> 00:28:39,039
as more issues started to be raised

00:28:37,200 --> 00:28:44,240
it became clear that it was time to go

00:28:39,039 --> 00:28:47,600
back and try a different tact

00:28:44,240 --> 00:28:49,520
uh yes um not to single out this hunk or

00:28:47,600 --> 00:28:52,159
this patch even but what you reckon

00:28:49,520 --> 00:28:53,919
about adding an instruction data type

00:28:52,159 --> 00:28:55,840
and then using that in all these call

00:28:53,919 --> 00:28:57,840
sites rather than adding an

00:28:55,840 --> 00:28:58,880
extra arg or doing the extra copy

00:28:57,840 --> 00:29:01,600
manually

00:28:58,880 --> 00:29:02,720
in each place depending on the prefix

00:29:01,600 --> 00:29:06,320
and

00:29:02,720 --> 00:29:13,840
it is pretty and you know

00:29:06,320 --> 00:29:13,840
it kind of this makes sense

00:29:18,799 --> 00:29:23,520
so then it was out of this that the next

00:29:21,200 --> 00:29:26,399
major revision emerged

00:29:23,520 --> 00:29:27,200
as a reaction and in many ways as an

00:29:26,399 --> 00:29:29,520
opposite

00:29:27,200 --> 00:29:31,200
or perhaps the negation of the original

00:29:29,520 --> 00:29:33,679
form

00:29:31,200 --> 00:29:35,039
the first revision as we we see is

00:29:33,679 --> 00:29:38,960
rather

00:29:35,039 --> 00:29:40,480
ad hoc free form and in trying to not be

00:29:38,960 --> 00:29:42,399
too invasive

00:29:40,480 --> 00:29:44,960
ended up being pretty messy and

00:29:42,399 --> 00:29:49,279
repetitive

00:29:44,960 --> 00:29:52,840
so from this uh a consensus coalesced

00:29:49,279 --> 00:29:55,840
around using you know a real ma a real

00:29:52,840 --> 00:29:55,840
type

00:29:56,640 --> 00:30:03,039
and with some um

00:30:00,799 --> 00:30:03,919
some configurations so that it's going

00:30:03,039 --> 00:30:06,559
to be

00:30:03,919 --> 00:30:09,200
not impacting on our 32-bit

00:30:06,559 --> 00:30:11,840
architectures too much as well

00:30:09,200 --> 00:30:15,760
and so look we have equality functions

00:30:11,840 --> 00:30:15,760
accesses to string functions

00:30:17,120 --> 00:30:23,600
the future of obstruction is

00:30:21,520 --> 00:30:24,880
but all of this abstraction certainly

00:30:23,600 --> 00:30:27,440
came as a comment

00:30:24,880 --> 00:30:30,240
at a cost just as you can see from the

00:30:27,440 --> 00:30:30,240
diff stats here

00:30:32,080 --> 00:30:38,880
now not to say that um that this

00:30:36,159 --> 00:30:39,200
revision didn't you know miss things

00:30:38,880 --> 00:30:42,799
that

00:30:39,200 --> 00:30:46,559
the first version uh

00:30:42,799 --> 00:30:51,039
didn't add things like the first version

00:30:46,559 --> 00:30:51,919
missed but there is a quite a lot of

00:30:51,039 --> 00:30:56,080
churn

00:30:51,919 --> 00:30:56,080
that that that is going on

00:30:57,120 --> 00:30:59,360
so

00:31:00,880 --> 00:31:04,559
just due to the kind of nature of

00:31:02,720 --> 00:31:08,320
derived types

00:31:04,559 --> 00:31:10,960
compared to using them however

00:31:08,320 --> 00:31:11,679
how integers in c can be used with lots

00:31:10,960 --> 00:31:15,120
of

00:31:11,679 --> 00:31:18,559
shifting masking ending oring

00:31:15,120 --> 00:31:21,360
which just doesn't really work as well

00:31:18,559 --> 00:31:24,960
when you're trying to use a struct

00:31:21,360 --> 00:31:27,760
so we ended up with you know

00:31:24,960 --> 00:31:28,960
this is kind of endemic of the sort of

00:31:27,760 --> 00:31:32,399
um

00:31:28,960 --> 00:31:35,840
churn that we ended up with

00:31:32,399 --> 00:31:36,559
but however it does work and works well

00:31:35,840 --> 00:31:39,120
and

00:31:36,559 --> 00:31:40,720
you don't have to worry about people

00:31:39,120 --> 00:31:43,840
mixing up the prefix

00:31:40,720 --> 00:31:47,679
and the suffix um

00:31:43,840 --> 00:31:51,200
and indeed this has been merged upstream

00:31:47,679 --> 00:31:54,480
so once you get your hands on a

00:31:51,200 --> 00:31:56,480
power on a power tan

00:31:54,480 --> 00:31:58,840
the support's there in the tool chain

00:31:56,480 --> 00:32:00,159
already so you can start using prefixed

00:31:58,840 --> 00:32:03,120
instructions

00:32:00,159 --> 00:32:05,200
and you can be that programmer using

00:32:03,120 --> 00:32:07,919
prefixed instructions to load and store

00:32:05,200 --> 00:32:10,720
from cache inhibited location

00:32:07,919 --> 00:32:11,200
whilst loading in a module that you've

00:32:10,720 --> 00:32:14,320
got

00:32:11,200 --> 00:32:16,960
prefixed instructions in and

00:32:14,320 --> 00:32:17,760
using k-probes there then dumping your

00:32:16,960 --> 00:32:20,000
instructions

00:32:17,760 --> 00:32:22,320
using x-mon and every other thing that

00:32:20,000 --> 00:32:24,559
you might like to do with instructions

00:32:22,320 --> 00:32:29,360
to your heart's content knowing that the

00:32:24,559 --> 00:32:32,640
kernel has got you covered

00:32:29,360 --> 00:32:35,519
so i guess it seems that

00:32:32,640 --> 00:32:35,519
that's the end of it

00:32:39,760 --> 00:32:45,519
however there the question of

00:32:42,960 --> 00:32:47,120
who will supervise the supervisor it's

00:32:45,519 --> 00:32:49,760
not one that ever caused too much

00:32:47,120 --> 00:32:53,039
concern for computer engineers

00:32:49,760 --> 00:32:56,480
can just switch from latin to greek then

00:32:53,039 --> 00:32:57,519
later latin again meaning of course the

00:32:56,480 --> 00:33:00,960
hypervisor

00:32:57,519 --> 00:33:04,880
and well kvm in particular and so

00:33:00,960 --> 00:33:07,519
with that the mediterranean on our mind

00:33:04,880 --> 00:33:08,320
let's see if what we were looking at was

00:33:07,519 --> 00:33:14,159
not in fact

00:33:08,320 --> 00:33:16,799
just shadows or if we can exit this cave

00:33:14,159 --> 00:33:18,840
and perhaps from this higher plane will

00:33:16,799 --> 00:33:21,440
the tension between our opposing

00:33:18,840 --> 00:33:25,519
representation of instructions

00:33:21,440 --> 00:33:27,600
finally be subletted

00:33:25,519 --> 00:33:28,559
if you remember back earlier in the

00:33:27,600 --> 00:33:30,720
discussion

00:33:28,559 --> 00:33:32,640
where we talked about the supervisor

00:33:30,720 --> 00:33:35,919
needing to be aware of the prefix

00:33:32,640 --> 00:33:38,159
instructions to help out the user space

00:33:35,919 --> 00:33:39,919
well in the same way there are some

00:33:38,159 --> 00:33:42,159
cases where kvm

00:33:39,919 --> 00:33:43,840
needs to take a look at the instruction

00:33:42,159 --> 00:33:46,559
being used by the

00:33:43,840 --> 00:33:50,640
supervisor or user space that caused

00:33:46,559 --> 00:33:53,279
control flow to be transferred to it

00:33:50,640 --> 00:33:54,159
and we'll just proceed on with out

00:33:53,279 --> 00:33:57,200
thinking about it

00:33:54,159 --> 00:34:00,399
in as much detail as we did

00:33:57,200 --> 00:34:00,399
for the supervisor

00:34:00,640 --> 00:34:05,679
so thinking about this i sent out a new

00:34:03,679 --> 00:34:08,960
series

00:34:05,679 --> 00:34:11,919
to to the kvm mailing list

00:34:08,960 --> 00:34:14,240
to start using our new struct ppc ins

00:34:11,919 --> 00:34:14,240
type

00:34:15,200 --> 00:34:19,119
and perhaps casting a wider net on the

00:34:17,599 --> 00:34:21,839
kvm mailing list

00:34:19,119 --> 00:34:24,720
caught my responses in particular this

00:34:21,839 --> 00:34:27,200
one to all the churn

00:34:24,720 --> 00:34:27,760
um how would it be to do something like

00:34:27,200 --> 00:34:30,800
tap def

00:34:27,760 --> 00:34:34,399
unsigned long ppc institute

00:34:30,800 --> 00:34:38,079
so it's 32 bits on the 64 on the

00:34:34,399 --> 00:34:41,520
32-bit platforms and 64 bits on the 64

00:34:38,079 --> 00:34:43,839
bit platform and use that instead

00:34:41,520 --> 00:34:48,560
in particular it would avoid a lot of

00:34:43,839 --> 00:34:51,280
the churn

00:34:48,560 --> 00:34:52,320
again i was shocked have we come so far

00:34:51,280 --> 00:34:54,560
only to end up

00:34:52,320 --> 00:34:56,159
back where we had started and yet of

00:34:54,560 --> 00:34:58,960
course it's hard to argue

00:34:56,159 --> 00:35:01,280
against these reasons probably i'd been

00:34:58,960 --> 00:35:02,560
charging at windmills with over-imagined

00:35:01,280 --> 00:35:05,760
dangers of

00:35:02,560 --> 00:35:07,920
confusing the suffix and the prefix

00:35:05,760 --> 00:35:09,119
or at least the messiness was not worth

00:35:07,920 --> 00:35:12,720
it

00:35:09,119 --> 00:35:15,440
so no were this was not the start

00:35:12,720 --> 00:35:16,000
but the sublation here combining the

00:35:15,440 --> 00:35:19,040
benefits

00:35:16,000 --> 00:35:22,160
of being able to use the operators like

00:35:19,040 --> 00:35:25,599
and or all the c

00:35:22,160 --> 00:35:28,320
bit manipulation stuff with the

00:35:25,599 --> 00:35:31,520
cohesion that using the data type and

00:35:28,320 --> 00:35:34,240
its methods have brought with it

00:35:31,520 --> 00:35:35,440
so it took me a while to get here and a

00:35:34,240 --> 00:35:37,839
lot of

00:35:35,440 --> 00:35:39,040
help but eventually we seem to have

00:35:37,839 --> 00:35:42,839
reached

00:35:39,040 --> 00:35:45,839
perhaps in hindsight the very obvious

00:35:42,839 --> 00:35:45,839
end

00:35:47,119 --> 00:35:52,640
or rather not quite the end i've yet to

00:35:50,240 --> 00:35:53,359
post my patches that undo converting

00:35:52,640 --> 00:35:56,160
struct

00:35:53,359 --> 00:35:57,680
ppc ends and move that over to an

00:35:56,160 --> 00:36:01,440
unsigned line

00:35:57,680 --> 00:36:03,680
and again i was um

00:36:01,440 --> 00:36:05,440
in response to getting this talk ready i

00:36:03,680 --> 00:36:09,839
was talking with the

00:36:05,440 --> 00:36:13,599
current maintainer for ppc um

00:36:09,839 --> 00:36:16,640
mpe and he said that he did

00:36:13,599 --> 00:36:20,800
rather in fact like the struct

00:36:16,640 --> 00:36:24,240
ppc inst and was not yet convinced about

00:36:20,800 --> 00:36:28,400
the unsigned law now so

00:36:24,240 --> 00:36:28,400
paul is also a maintainer so

00:36:30,240 --> 00:36:36,480
so perhaps our synthesis is in fact just

00:36:33,680 --> 00:36:39,520
a thesis from a different point in time

00:36:36,480 --> 00:36:42,079
and we have some more iterations to go

00:36:39,520 --> 00:36:42,079
through yet

00:36:42,880 --> 00:36:49,280
so to to end i just want to

00:36:46,000 --> 00:36:51,599
say how the long-form public-facing

00:36:49,280 --> 00:36:52,800
and long-time constrained thoughtful

00:36:51,599 --> 00:36:55,359
discussion

00:36:52,800 --> 00:36:57,040
that the mailing list provides remains

00:36:55,359 --> 00:37:00,079
as good an approximation

00:36:57,040 --> 00:37:03,280
to a dialectic as any through which

00:37:00,079 --> 00:37:06,240
even the inexperienced such as me

00:37:03,280 --> 00:37:09,839
might eventually reach towards something

00:37:06,240 --> 00:37:09,839
getting closer to the truth

00:37:10,960 --> 00:37:15,119
and so i'd welcome if anyone else has

00:37:13,040 --> 00:37:18,720
any thoughts ideas

00:37:15,119 --> 00:37:18,720
then i'd be interested to hear them

00:37:20,000 --> 00:37:24,880
wonderful well thank you so much for um

00:37:22,880 --> 00:37:25,920
for the talk uh there's a lot in there

00:37:24,880 --> 00:37:29,040
to consider

00:37:25,920 --> 00:37:29,520
um while we're just waiting for um a few

00:37:29,040 --> 00:37:32,560
more

00:37:29,520 --> 00:37:34,160
uh comments or questions to come in um

00:37:32,560 --> 00:37:36,960
what what do you think will be your next

00:37:34,160 --> 00:37:40,560
steps what do you see coming

00:37:36,960 --> 00:37:43,040
next and and even shifting towards

00:37:40,560 --> 00:37:44,000
the different requirements into the

00:37:43,040 --> 00:37:47,920
future into

00:37:44,000 --> 00:37:47,920
you know 5 10 15 years in the future

00:37:48,839 --> 00:37:54,240
um

00:37:50,960 --> 00:37:56,000
well so uh that

00:37:54,240 --> 00:37:58,640
the next thing i guess will be to get

00:37:56,000 --> 00:38:02,839
those kvm um patches going

00:37:58,640 --> 00:38:04,960
then looking very far into the future

00:38:02,839 --> 00:38:08,240
um uh

00:38:04,960 --> 00:38:10,480
a bit hard to say but um

00:38:08,240 --> 00:38:11,520
well power has its new open

00:38:10,480 --> 00:38:15,119
implementation

00:38:11,520 --> 00:38:17,839
microwatt or in vhdl which does not have

00:38:15,119 --> 00:38:18,480
prefixed instructions yet so perhaps

00:38:17,839 --> 00:38:21,680
adding those

00:38:18,480 --> 00:38:23,680
there could be something

00:38:21,680 --> 00:38:25,599
if someone doesn't want to wait to get

00:38:23,680 --> 00:38:28,960
their hands on a power tan to

00:38:25,599 --> 00:38:32,160
try these new instructions out

00:38:28,960 --> 00:38:33,839
okay um we haven't really got a lot

00:38:32,160 --> 00:38:36,800
there's been some good conversation

00:38:33,839 --> 00:38:37,359
on the on the chat but um we don't have

00:38:36,800 --> 00:38:39,520
any

00:38:37,359 --> 00:38:41,119
questions specifically that have come up

00:38:39,520 --> 00:38:43,520
yet um

00:38:41,119 --> 00:38:44,240
so is there um anything else that you

00:38:43,520 --> 00:38:47,200
want to share

00:38:44,240 --> 00:38:48,079
um would for people who are interested

00:38:47,200 --> 00:38:50,240
in joining

00:38:48,079 --> 00:38:51,359
in the conversation um how can they do

00:38:50,240 --> 00:38:55,760
so

00:38:51,359 --> 00:38:57,520
um on the ppc like the powerpc linux

00:38:55,760 --> 00:39:00,640
mailing list is where this

00:38:57,520 --> 00:39:03,119
conversation sort of happens and

00:39:00,640 --> 00:39:04,640
i just forgot to put this side up but

00:39:03,119 --> 00:39:05,119
there's those links i was talking about

00:39:04,640 --> 00:39:08,240
if

00:39:05,119 --> 00:39:11,040
anyone else if anyone wants to get some

00:39:08,240 --> 00:39:13,599
more information

00:39:11,040 --> 00:39:14,960
fantastic yeah that's about it so if

00:39:13,599 --> 00:39:18,400
there's no questions then

00:39:14,960 --> 00:39:21,599
yeah that's it

00:39:18,400 --> 00:39:24,480
okay um we do have one have you

00:39:21,599 --> 00:39:25,839
we've got one question just come in have

00:39:24,480 --> 00:39:27,520
you found that there's a lot of hidden

00:39:25,839 --> 00:39:28,960
cases in the 32-bit instruction

00:39:27,520 --> 00:39:31,760
assumption

00:39:28,960 --> 00:39:34,240
uh yes yes that is one of the things

00:39:31,760 --> 00:39:36,800
that's kind of

00:39:34,240 --> 00:39:39,280
is to try and think about all the places

00:39:36,800 --> 00:39:42,480
where someone's you know just

00:39:39,280 --> 00:39:43,760
because when you're using an unsigned

00:39:42,480 --> 00:39:46,400
infrastructure

00:39:43,760 --> 00:39:48,000
it's very hard to you know just know at

00:39:46,400 --> 00:39:50,320
a glance was this meant to be an

00:39:48,000 --> 00:39:52,800
instruction or was this some other

00:39:50,320 --> 00:39:54,480
um something else that was just using

00:39:52,800 --> 00:39:57,520
that um

00:39:54,480 --> 00:40:00,079
unsigned in and then

00:39:57,520 --> 00:40:01,040
you know like a lot of places where

00:40:00,079 --> 00:40:03,280
you're just

00:40:01,040 --> 00:40:04,880
adding four to in advance the

00:40:03,280 --> 00:40:07,760
instruction pointer

00:40:04,880 --> 00:40:08,800
because well power always had and always

00:40:07,760 --> 00:40:12,400
will have

00:40:08,800 --> 00:40:15,359
a full black long instruction so yes it

00:40:12,400 --> 00:40:17,280
there's prob there's a lot of cases

00:40:15,359 --> 00:40:18,800
where it's easy to miss things and there

00:40:17,280 --> 00:40:20,640
probably still are some that have been

00:40:18,800 --> 00:40:23,760
missed

00:40:20,640 --> 00:40:25,200
okay wonderful uh i don't think we have

00:40:23,760 --> 00:40:26,000
any other questions right now so what

00:40:25,200 --> 00:40:28,079
i'm going to do

00:40:26,000 --> 00:40:30,160
is i might close there so thank you so

00:40:28,079 --> 00:40:30,560
much uh for the talk really appreciate

00:40:30,160 --> 00:40:33,440
it

00:40:30,560 --> 00:40:34,319
uh there is just for everyone a um the

00:40:33,440 --> 00:40:37,520
blemings

00:40:34,319 --> 00:40:40,480
labs post talk q a channel

00:40:37,520 --> 00:40:41,040
on venulis so if you do want to go there

00:40:40,480 --> 00:40:43,920
to

00:40:41,040 --> 00:40:44,960
have any follow-up conversation um then

00:40:43,920 --> 00:40:47,440
you'll be able to

00:40:44,960 --> 00:40:48,000
uh to join with um with speakers from

00:40:47,440 --> 00:40:49,599
throughout

00:40:48,000 --> 00:40:51,359
the the you know throughout the couple

00:40:49,599 --> 00:40:53,119
of days um and so

00:40:51,359 --> 00:40:54,640
um you wouldn't mind taking any extra

00:40:53,119 --> 00:40:57,200
questions there would you

00:40:54,640 --> 00:40:57,680
no of course fantastic all right then

00:40:57,200 --> 00:40:59,839
everyone

00:40:57,680 --> 00:41:01,040
well let's um finish up just a couple of

00:40:59,839 --> 00:41:03,200
minutes early

00:41:01,040 --> 00:41:04,560
uh for this session uh the next session

00:41:03,200 --> 00:41:07,839
starts at 11

00:41:04,560 --> 00:41:09,760
40 and it's uh it will be peter chubb

00:41:07,839 --> 00:41:12,480
talking about it's not down

00:41:09,760 --> 00:41:13,760
in the noise um and that will be a

00:41:12,480 --> 00:41:16,400
really interesting one so

00:41:13,760 --> 00:41:17,359
we'll leave it there and um thank you

00:41:16,400 --> 00:41:21,839
again so much

00:41:17,359 --> 00:41:21,839

YouTube URL: https://www.youtube.com/watch?v=mietZIK-Hgo


