Title: "Mathematics and development of fast TLS handshakes" - Alexander Krizhanovsky (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Alexander Krizhanovsky

https://lca2021.linux.org.au/schedule/presentation/64/

Tempesta TLS is an implementation of TLS handshakes for the Linux kernel. Since the kernel already provides symmetric ciphers, we focus on asymmetric cryptography only, elliptic curves in particular.

Use used the mbed TLS library as the foundation and almost fully rewrote it to make is x40 faster. During our development we also use parts of WolfSSL library. While WolfSSL outperforms OpenSSL, it uses the same algorithms, which are 5-7 years of old. Tempesta TLS uses newer and more efficient algorithms from the modern cryptography research.

While we still improving performance of Tempesta TLS, the implementation already establishes 40-80% more TLS handshakes per second than OpenSSL/Nginx and provides up to x4 lower latency in several tests.

This talk covers following topics with plenty of benchmarks:

* The fundamentals of elliptic curve computations and the most "hot spots"

* Side channel attacks (SCA) and methods to prevent them

* How the recent CPU vulnerabilities impact TLS handshakes

* Basics of the new fast algorithms used in the Tempesta TLS

* The design trade offs in OpenSSL, WolfSSL, mbed TLS, and Tempesta TLS

* The funny assembly code with is more straightforward than C

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sun Jan 24 11:40:00 2021 at Blemings Labs
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,120 --> 00:00:19,119
fleming's labs

00:00:16,160 --> 00:00:20,720
i'm your mc uh pierre andrews it's i'm

00:00:19,119 --> 00:00:24,000
delighted to introduce to you

00:00:20,720 --> 00:00:25,840
alex kuzzynovsky alex is the ceo of

00:00:24,000 --> 00:00:27,840
tempesta technologies and is the

00:00:25,840 --> 00:00:29,760
architect of tempesta fw

00:00:27,840 --> 00:00:31,599
a high performance open source linux

00:00:29,760 --> 00:00:33,840
application delivery controller

00:00:31,599 --> 00:00:35,360
alex is responsible for the design and

00:00:33,840 --> 00:00:37,360
performance of several products in the

00:00:35,360 --> 00:00:38,320
areas of network traffic processing and

00:00:37,360 --> 00:00:39,840
databases

00:00:38,320 --> 00:00:41,680
he designed the core architecture of a

00:00:39,840 --> 00:00:44,160
web application firewall mentioned in

00:00:41,680 --> 00:00:47,840
the gartner magic quadrant and maria db

00:00:44,160 --> 00:00:49,920
temporal data tables just quickly as a

00:00:47,840 --> 00:00:52,879
reminder please post your questions

00:00:49,920 --> 00:00:54,079
into the venueless chat for this room if

00:00:52,879 --> 00:00:56,320
you could use the hash

00:00:54,079 --> 00:00:58,399
questions just add it on your questions

00:00:56,320 --> 00:01:01,440
to make it easier for our moderators to

00:00:58,399 --> 00:01:03,280
find and moderate your question and

00:01:01,440 --> 00:01:06,320
please also remember that we have

00:01:03,280 --> 00:01:09,200
a bleming labs bleming's lab post talk q

00:01:06,320 --> 00:01:10,240
a channel on venulis so that you can

00:01:09,200 --> 00:01:12,240
continue to

00:01:10,240 --> 00:01:14,080
follow up with speakers uh after the

00:01:12,240 --> 00:01:16,240
talk including our previous speaker

00:01:14,080 --> 00:01:18,640
keith um i'll hand over to you over to

00:01:16,240 --> 00:01:20,000
you alex um thank you very much

00:01:18,640 --> 00:01:23,040
okay thank you very much for the

00:01:20,000 --> 00:01:25,119
introduction uh hello everyone

00:01:23,040 --> 00:01:26,720
uh let me start with a short

00:01:25,119 --> 00:01:30,079
introduction how did we

00:01:26,720 --> 00:01:32,560
come to the kernel tls

00:01:30,079 --> 00:01:34,640
handshakes our business is custom

00:01:32,560 --> 00:01:36,799
software development and we had the

00:01:34,640 --> 00:01:39,280
request from positive technologies

00:01:36,799 --> 00:01:40,159
to develop their call of web application

00:01:39,280 --> 00:01:43,840
firewall

00:01:40,159 --> 00:01:46,159
it that was in 2013 by the way

00:01:43,840 --> 00:01:47,600
the web application file was mentioned

00:01:46,159 --> 00:01:51,680
by the got magic

00:01:47,600 --> 00:01:54,799
quadrant in 2015 as a vision

00:01:51,680 --> 00:01:58,159
web application firewalls are typically

00:01:54,799 --> 00:01:59,920
built on top of common https boxes like

00:01:58,159 --> 00:02:03,439
engine x or hp boxing

00:01:59,920 --> 00:02:06,320
and extends them with very rich

00:02:03,439 --> 00:02:07,520
security features like web attacks

00:02:06,320 --> 00:02:10,879
filtration or

00:02:07,520 --> 00:02:14,080
layer 7 ddos attack filtration

00:02:10,879 --> 00:02:17,440
that time we realized that while common

00:02:14,080 --> 00:02:20,080
https boxes are good to deliver content

00:02:17,440 --> 00:02:21,200
they aren't perfect to filter out

00:02:20,080 --> 00:02:24,560
massive

00:02:21,200 --> 00:02:27,680
malicious attack like those attacks or

00:02:24,560 --> 00:02:30,720
password crackers whatever so we thought

00:02:27,680 --> 00:02:33,040
that uh well if we have a very good

00:02:30,720 --> 00:02:34,319
firewall in the linux kernel the net

00:02:33,040 --> 00:02:37,360
filter

00:02:34,319 --> 00:02:38,720
which works on gpi player then why not

00:02:37,360 --> 00:02:41,840
to extend the

00:02:38,720 --> 00:02:44,720
uh file with hps protocol

00:02:41,840 --> 00:02:45,519
so this is how our tempest vw product

00:02:44,720 --> 00:02:48,720
was

00:02:45,519 --> 00:02:51,680
born this basically a hybrid of hps

00:02:48,720 --> 00:02:54,400
proxy and the firewall which is directly

00:02:51,680 --> 00:02:57,760
embedded into the linux vip

00:02:54,400 --> 00:02:58,959
stack gps helis is a part of team paste

00:02:57,760 --> 00:03:02,640
of w

00:02:58,959 --> 00:03:06,239
and team ps2w

00:03:02,640 --> 00:03:10,239
is supposed to be a replacement or a

00:03:06,239 --> 00:03:13,680
open source alternative for proprietary

00:03:10,239 --> 00:03:15,360
software and appliances like five big ip

00:03:13,680 --> 00:03:16,720
or forty net application delivery

00:03:15,360 --> 00:03:19,599
controllers

00:03:16,720 --> 00:03:21,920
such kind of applications are appliances

00:03:19,599 --> 00:03:25,280
i mean application delivery controllers

00:03:21,920 --> 00:03:28,560
are basically hps uh load balancers

00:03:25,280 --> 00:03:32,480
uh reverse boxes which is uh

00:03:28,560 --> 00:03:34,959
extended with uh various logic like ddos

00:03:32,480 --> 00:03:36,879
protection class uploading uh

00:03:34,959 --> 00:03:39,680
replication security like

00:03:36,879 --> 00:03:40,400
valves and so on in our presentation uh

00:03:39,680 --> 00:03:42,400
ddos

00:03:40,400 --> 00:03:44,400
protection and television folding will

00:03:42,400 --> 00:03:47,519
be the main point

00:03:44,400 --> 00:03:50,560
uh also all the uh products

00:03:47,519 --> 00:03:54,400
uh always have a very

00:03:50,560 --> 00:03:55,120
um very crucial uh line in their uh data

00:03:54,400 --> 00:03:58,080
sheet this

00:03:55,120 --> 00:04:00,560
uh how many connection uh per second

00:03:58,080 --> 00:04:04,239
series connections per second they can

00:04:00,560 --> 00:04:06,799
make this important uh characteristic

00:04:04,239 --> 00:04:07,840
uh not only because of performance

00:04:06,799 --> 00:04:10,799
however speaking

00:04:07,840 --> 00:04:11,200
about performance we can make much more

00:04:10,799 --> 00:04:13,840
uh

00:04:11,200 --> 00:04:16,000
chariot handshakes per second than

00:04:13,840 --> 00:04:16,959
traditional application because we work

00:04:16,000 --> 00:04:20,000
in the

00:04:16,959 --> 00:04:23,840
uh linux kernel space uh

00:04:20,000 --> 00:04:27,280
not only uh for full cryptography

00:04:23,840 --> 00:04:30,560
handshake but also for a short

00:04:27,280 --> 00:04:33,680
abbreviated chariot uh sessions like uh

00:04:30,560 --> 00:04:37,680
cherius 1.3 uh zero gt

00:04:33,680 --> 00:04:41,040
or jls 1.2 uh tickets

00:04:37,680 --> 00:04:44,400
and uh oh

00:04:41,040 --> 00:04:46,880
mainly we work faster because there's no

00:04:44,400 --> 00:04:48,000
contact switches this optimized network

00:04:46,880 --> 00:04:51,440
io

00:04:48,000 --> 00:04:53,759
but also we employ uh plenty of modern

00:04:51,440 --> 00:04:56,080
research in elliptic curves uh to make

00:04:53,759 --> 00:04:58,400
the library much faster

00:04:56,080 --> 00:05:00,160
besides uh performance uh challenge

00:04:58,400 --> 00:05:02,479
handshakes is a typical

00:05:00,160 --> 00:05:04,000
target for ddos attacks so name it the

00:05:02,479 --> 00:05:06,560
symmetric ddos attacks

00:05:04,000 --> 00:05:07,600
like establishing uh as many interiors

00:05:06,560 --> 00:05:10,880
can shakes

00:05:07,600 --> 00:05:13,759
with the servers as possible

00:05:10,880 --> 00:05:15,120
also having chariots handshakes in the

00:05:13,759 --> 00:05:17,840
in the kernel

00:05:15,120 --> 00:05:18,400
provides additional layer of security

00:05:17,840 --> 00:05:22,400
this

00:05:18,400 --> 00:05:25,120
separation of cherries terminator

00:05:22,400 --> 00:05:25,680
from the application logic like a worker

00:05:25,120 --> 00:05:28,880
process

00:05:25,680 --> 00:05:31,440
this typical uh architecture for

00:05:28,880 --> 00:05:32,000
varnish in varnish we have a hitch

00:05:31,440 --> 00:05:34,880
chariot

00:05:32,000 --> 00:05:35,759
uh terminator and the walker process

00:05:34,880 --> 00:05:38,960
varnish

00:05:35,759 --> 00:05:40,800
demon and uh if some logic and worker

00:05:38,960 --> 00:05:44,240
processes compromises then

00:05:40,800 --> 00:05:48,080
uh none of them uh security crucial

00:05:44,240 --> 00:05:50,720
uh private keys or uh session keys

00:05:48,080 --> 00:05:52,960
won't be compromised uh similar

00:05:50,720 --> 00:05:56,080
architecture helped uh cloudflare

00:05:52,960 --> 00:05:59,120
to survive a cloud bleed attack uh while

00:05:56,080 --> 00:06:02,240
uh their uh their

00:05:59,120 --> 00:06:04,639
reverse box us were compromised they

00:06:02,240 --> 00:06:07,919
didn't leak any security sensitive data

00:06:04,639 --> 00:06:09,440
uh thanks to a separated television

00:06:07,919 --> 00:06:12,319
manager from

00:06:09,440 --> 00:06:13,759
vocal processors during this uh

00:06:12,319 --> 00:06:17,199
presentation i will focus

00:06:13,759 --> 00:06:19,919
on nih team 256 uh

00:06:17,199 --> 00:06:20,639
curve uh mostly because this uh the most

00:06:19,919 --> 00:06:22,720
widespread

00:06:20,639 --> 00:06:24,880
elliptical and the most optimized

00:06:22,720 --> 00:06:25,919
elliptical for example in open cell and

00:06:24,880 --> 00:06:29,520
the other

00:06:25,919 --> 00:06:32,960
libraries while this much faster

00:06:29,520 --> 00:06:35,199
elliptic of 255.19

00:06:32,960 --> 00:06:36,639
uh it's only can be used in elliptic

00:06:35,199 --> 00:06:39,680
roof difficult

00:06:36,639 --> 00:06:40,160
and uh you uh basically you cannot have

00:06:39,680 --> 00:06:43,600
a

00:06:40,160 --> 00:06:46,160
certificate with a cuv this 4ca

00:06:43,600 --> 00:06:47,199
if we have a look at the performance

00:06:46,160 --> 00:06:51,360
profile

00:06:47,199 --> 00:06:56,080
of open cell and the chariots can shake

00:06:51,360 --> 00:06:59,199
ddos attack then we see that while

00:06:56,080 --> 00:07:02,560
mathematic uh the blue

00:06:59,199 --> 00:07:05,680
lines on the strides the theoretic

00:07:02,560 --> 00:07:06,479
uh limitation for handshakes the library

00:07:05,680 --> 00:07:09,039
actually

00:07:06,479 --> 00:07:11,120
uh struggles from too many memory

00:07:09,039 --> 00:07:13,039
locations scorpius and another

00:07:11,120 --> 00:07:14,720
overhead the heads which can be

00:07:13,039 --> 00:07:18,080
eliminated all of them

00:07:14,720 --> 00:07:21,360
are wet on the side uh

00:07:18,080 --> 00:07:24,319
we both we started from the fork of

00:07:21,360 --> 00:07:26,240
mbterius library we made significant

00:07:24,319 --> 00:07:29,360
work to make it much much

00:07:26,240 --> 00:07:32,400
faster we made it more than

00:07:29,360 --> 00:07:33,120
40 times faster than the original source

00:07:32,400 --> 00:07:35,759
code

00:07:33,120 --> 00:07:37,440
also we borrow parts of the code from

00:07:35,759 --> 00:07:40,080
watch for sale library

00:07:37,440 --> 00:07:41,120
and also during our work we reported a

00:07:40,080 --> 00:07:46,160
security

00:07:41,120 --> 00:07:48,639
issue to work for sale library

00:07:46,160 --> 00:07:49,520
all the libraries have built-in

00:07:48,639 --> 00:07:52,240
benchmark

00:07:49,520 --> 00:07:54,080
tools and the benchmark tools are

00:07:52,240 --> 00:07:57,199
compatible between wi-fi cell

00:07:54,080 --> 00:07:59,199
and openness sale and we see that wi-fi

00:07:57,199 --> 00:08:00,479
sale is basically much faster than

00:07:59,199 --> 00:08:03,120
openness ssa

00:08:00,479 --> 00:08:04,479
however the similar benchmark tool for

00:08:03,120 --> 00:08:07,520
temperature yes

00:08:04,479 --> 00:08:10,879
isn't uh basically uh comparable with

00:08:07,520 --> 00:08:14,639
wall facility and open cell because in

00:08:10,879 --> 00:08:18,319
our benchmark 2 we use the full

00:08:14,639 --> 00:08:20,639
cryptographic operation required for

00:08:18,319 --> 00:08:22,479
a terrestrial check it means that if we

00:08:20,639 --> 00:08:26,080
measure ecgsa

00:08:22,479 --> 00:08:28,639
or cdh we also include a female keys

00:08:26,080 --> 00:08:29,360
generation so basically in this two you

00:08:28,639 --> 00:08:32,399
see much

00:08:29,360 --> 00:08:34,880
slower uh much lower numbers

00:08:32,399 --> 00:08:35,680
but actually there are two uh numbers

00:08:34,880 --> 00:08:40,240
which you

00:08:35,680 --> 00:08:42,240
have in js handshake so the more

00:08:40,240 --> 00:08:43,599
available for performance optimization

00:08:42,240 --> 00:08:46,720
for our site

00:08:43,599 --> 00:08:50,160
uh to compare uh the

00:08:46,720 --> 00:08:51,839
implementations let's make a small gamma

00:08:50,160 --> 00:08:54,320
and compare it in ps series with

00:08:51,839 --> 00:08:57,440
engineering 1.14 with

00:08:54,320 --> 00:09:00,560
open cell and nginx 1.17

00:08:57,440 --> 00:09:03,920
with wolf ssa during the benchmarks i

00:09:00,560 --> 00:09:05,760
will use stereos 1.2 in full handshakes

00:09:03,920 --> 00:09:09,279
and abbreviated handshakes

00:09:05,760 --> 00:09:10,000
and cherry spf our open source benchmark

00:09:09,279 --> 00:09:13,040
00:09:10,000 --> 00:09:13,360
uh will be used this tool basically just

00:09:13,040 --> 00:09:16,720
uh

00:09:13,360 --> 00:09:20,080
establishes as many as possible

00:09:16,720 --> 00:09:23,440
jvs connections with the target server

00:09:20,080 --> 00:09:26,560
and it uses plain openness cell with

00:09:23,440 --> 00:09:30,240
just a very basic uh repo and

00:09:26,560 --> 00:09:35,040
fast network io so let's have a

00:09:30,240 --> 00:09:39,480
demo uh first first let's benchmark

00:09:35,040 --> 00:09:42,880
uh wolf ssa uh this on port

00:09:39,480 --> 00:09:45,760
994 443 uh

00:09:42,880 --> 00:09:46,880
tickets on say that this abbreviated

00:09:45,760 --> 00:09:50,399
handshakes

00:09:46,880 --> 00:09:53,839
and in this benchmark i use uh 2000

00:09:50,399 --> 00:09:56,800
connections uh against their server

00:09:53,839 --> 00:09:58,640
next we go with open ssh also

00:09:56,800 --> 00:10:03,120
abbreviated handshakes

00:09:58,640 --> 00:10:07,440
uh we use four uh threads

00:10:03,120 --> 00:10:10,880
this is my local laptop

00:10:07,440 --> 00:10:14,079
last team team pasta challenges

00:10:10,880 --> 00:10:17,279
and benchmark is run against

00:10:14,079 --> 00:10:20,399
virtual machine for which has 4gb use

00:10:17,279 --> 00:10:23,600
on the same laptop so

00:10:20,399 --> 00:10:24,480
here we go we have the numbers uh let's

00:10:23,600 --> 00:10:27,600
compare them

00:10:24,480 --> 00:10:29,680
uh first of all we see that wolfe's sale

00:10:27,600 --> 00:10:33,279
is basically a slower than

00:10:29,680 --> 00:10:35,600
open cell frankly i didn't put that uh

00:10:33,279 --> 00:10:37,360
put enough in a photo on the center was

00:10:35,600 --> 00:10:38,320
a what's wrong with his wife would say

00:10:37,360 --> 00:10:40,560
but i did

00:10:38,320 --> 00:10:43,200
a lot of benchmark and basically it's

00:10:40,560 --> 00:10:46,640
slower on abbreviated handshakes

00:10:43,200 --> 00:10:48,800
uh second thing that uh tempest such

00:10:46,640 --> 00:10:50,640
areas is much much faster than both of

00:10:48,800 --> 00:10:55,120
them uh twice faster than

00:10:50,640 --> 00:10:57,279
uh wolf has to say and um uh

00:10:55,120 --> 00:10:58,560
twice faster than openstack and four

00:10:57,279 --> 00:11:02,800
times faster than

00:10:58,560 --> 00:11:06,399
uh worthless say also pay attention on

00:11:02,800 --> 00:11:09,519
latency this 95th latency

00:11:06,399 --> 00:11:12,640
for chimpiesta for openness cell

00:11:09,519 --> 00:11:17,040
and wallpace

00:11:12,640 --> 00:11:29,839
next let's try in the same sequence

00:11:17,040 --> 00:11:29,839
but full tell yes handshakes

00:11:40,839 --> 00:11:43,839
so

00:11:48,240 --> 00:11:57,839
and the last investor

00:12:02,079 --> 00:12:08,880
uh okay uh we

00:12:05,839 --> 00:12:12,480
done um

00:12:08,880 --> 00:12:16,880
okay let's um let's another the numbers

00:12:12,480 --> 00:12:20,240
we have uh fast uh the open cell is

00:12:16,880 --> 00:12:23,519
faster okay um

00:12:20,240 --> 00:12:25,360
tempest is slow uh let's

00:12:23,519 --> 00:12:29,440
this uh something wrong with the

00:12:25,360 --> 00:12:29,440
benchmark let's make another one

00:12:35,839 --> 00:12:40,320
i don't know what what's going on with

00:12:38,480 --> 00:12:44,959
probably this because of

00:12:40,320 --> 00:12:44,959
video translation let's remake the

00:12:50,839 --> 00:12:53,839
benchmark

00:13:08,160 --> 00:13:15,760
okay okay uh now now we're good uh

00:13:11,760 --> 00:13:18,880
which have uh better numbers than um

00:13:15,760 --> 00:13:22,000
this uh uh ninth port this uh

00:13:18,880 --> 00:13:25,040
wordpress cell this uh open cell

00:13:22,000 --> 00:13:26,079
uh usually we see that uh very facility

00:13:25,040 --> 00:13:29,600
faster than

00:13:26,079 --> 00:13:33,680
open cell but this is also because

00:13:29,600 --> 00:13:37,279
we run this run on

00:13:33,680 --> 00:13:40,959
virtual machine with uh with the

00:13:37,279 --> 00:13:44,399
video translation um

00:13:40,959 --> 00:13:47,120
percent um it's also very

00:13:44,399 --> 00:13:48,079
uh percentages now we can see uh

00:13:47,120 --> 00:13:51,199
vicinity

00:13:48,079 --> 00:13:54,959
uh also much lower than

00:13:51,199 --> 00:13:58,720
on gps zone on uh world fast sale

00:13:54,959 --> 00:14:03,839
and openness ssl

00:13:58,720 --> 00:14:03,839
so if we try uh

00:14:05,120 --> 00:14:09,199
this first time when i saw uh jim

00:14:07,199 --> 00:14:12,800
because i was on

00:14:09,199 --> 00:14:15,440
both of um open cell and wolf cell

00:14:12,800 --> 00:14:16,160
let me try the last time this is still

00:14:15,440 --> 00:14:19,199
faster

00:14:16,160 --> 00:14:22,399
and we're good uh let's back to

00:14:19,199 --> 00:14:23,120
uh the slides if we compare the data

00:14:22,399 --> 00:14:26,639
with

00:14:23,120 --> 00:14:30,560
copyright revenues uh this reference

00:14:26,639 --> 00:14:33,440
on the first line are two video from f5

00:14:30,560 --> 00:14:34,399
engineer comparing 5 big ip virtual

00:14:33,440 --> 00:14:37,600
machine against

00:14:34,399 --> 00:14:39,920
nginx uh with open cell built on top of

00:14:37,600 --> 00:14:43,440
dpdk

00:14:39,920 --> 00:14:46,639
f5 is faster than nginx for 30

00:14:43,440 --> 00:14:49,760
50 persons but actually this

00:14:46,639 --> 00:14:51,839
doesn't important uh that engine x is

00:14:49,760 --> 00:14:54,639
built on dpdk because the

00:14:51,839 --> 00:14:57,360
bottom neck of handshakes is surely open

00:14:54,639 --> 00:14:59,839
necessary not nginx or linux io

00:14:57,360 --> 00:15:02,000
if you compare it with another

00:14:59,839 --> 00:15:03,199
proprietary vendor iv vantage acquired

00:15:02,000 --> 00:15:05,920
by vmware

00:15:03,199 --> 00:15:07,600
then it makes only about two thousand

00:15:05,920 --> 00:15:10,720
hashtags per second for

00:15:07,600 --> 00:15:14,639
one cpu which is uh just compatible with

00:15:10,720 --> 00:15:15,199
open ssa uh why tempest areas is faster

00:15:14,639 --> 00:15:17,360
is this

00:15:15,199 --> 00:15:18,639
most because we have no contact switches

00:15:17,360 --> 00:15:21,199
we directly

00:15:18,639 --> 00:15:22,160
uh terminate alias handshakes in the

00:15:21,199 --> 00:15:26,560
kernel

00:15:22,160 --> 00:15:29,680
and also we use much uh advanced

00:15:26,560 --> 00:15:33,120
uh as a recent cryptography mathematic

00:15:29,680 --> 00:15:34,959
the basic uh zeocopium uh design is

00:15:33,120 --> 00:15:38,240
described on now in a jeff uh

00:15:34,959 --> 00:15:41,279
now on a deaf paper uh

00:15:38,240 --> 00:15:44,399
speaking about elliptic curves

00:15:41,279 --> 00:15:48,240
let's dig deeper into the subject

00:15:44,399 --> 00:15:51,120
uh first of all uh the nist 256

00:15:48,240 --> 00:15:52,240
elliptical uh uses uh prime of the

00:15:51,120 --> 00:15:54,720
special form

00:15:52,240 --> 00:15:55,360
this montgomery-friendly uh primes to

00:15:54,720 --> 00:15:58,720
name it

00:15:55,360 --> 00:16:02,160
this adjusts the sum of uh powers of

00:15:58,720 --> 00:16:03,040
are true in this uh field or over this

00:16:02,160 --> 00:16:06,399
prime

00:16:03,040 --> 00:16:09,600
ah there are defined uh group laws

00:16:06,399 --> 00:16:12,800
in particular uh addition of two

00:16:09,600 --> 00:16:13,839
elliptic curve points and doubling which

00:16:12,800 --> 00:16:16,959
is just the

00:16:13,839 --> 00:16:20,480
addition of the point to itself uh

00:16:16,959 --> 00:16:24,480
next we have uh multiplication

00:16:20,480 --> 00:16:26,880
uh scalar multiplied by elliptical

00:16:24,480 --> 00:16:28,240
point and the multiplication is

00:16:26,880 --> 00:16:31,440
expressed through

00:16:28,240 --> 00:16:34,639
uh doubling and additionals uh

00:16:31,440 --> 00:16:36,160
ecgsa uses uh non-point uh

00:16:34,639 --> 00:16:39,199
multiplication so

00:16:36,160 --> 00:16:42,399
all ecga say

00:16:39,199 --> 00:16:44,800
computations are performed over the same

00:16:42,399 --> 00:16:45,759
elliptical point but with different uh

00:16:44,800 --> 00:16:49,519
scalars

00:16:45,759 --> 00:16:53,519
but cgha uses a known public

00:16:49,519 --> 00:16:57,279
unknown elliptical point which is

00:16:53,519 --> 00:17:00,320
various with each handshake

00:16:57,279 --> 00:17:00,800
basically multiplication in elliptic

00:17:00,320 --> 00:17:05,039
curve

00:17:00,800 --> 00:17:07,839
is very similar to our usual binary

00:17:05,039 --> 00:17:09,760
multiplication if you multiply some

00:17:07,839 --> 00:17:12,000
binary numbers then you can

00:17:09,760 --> 00:17:12,799
do this with just uh traversing all the

00:17:12,000 --> 00:17:16,160
bits

00:17:12,799 --> 00:17:19,360
and if the bit is one then you

00:17:16,160 --> 00:17:21,600
double count value and at uh

00:17:19,360 --> 00:17:22,720
at previous uh value this is just

00:17:21,600 --> 00:17:24,959
straightforward

00:17:22,720 --> 00:17:26,000
uh from the binary edition this is the

00:17:24,959 --> 00:17:28,720
most uh

00:17:26,000 --> 00:17:29,679
straightforward algorithm uh it's uh

00:17:28,720 --> 00:17:32,400
nobody know but

00:17:29,679 --> 00:17:33,360
nobody uses this algorithm but this is

00:17:32,400 --> 00:17:36,640
just good to

00:17:33,360 --> 00:17:37,039
understand what's going on uh next as i

00:17:36,640 --> 00:17:40,240
said

00:17:37,039 --> 00:17:41,280
uh cgsa uses uh non-point multiplication

00:17:40,240 --> 00:17:45,200
means that

00:17:41,280 --> 00:17:48,960
uh we pre-compute point doubling for

00:17:45,200 --> 00:17:52,400
fixed point and can use the precomputed

00:17:48,960 --> 00:17:56,240
table in our multiplication process

00:17:52,400 --> 00:17:59,360
ecga team uses unknown

00:17:56,240 --> 00:18:00,000
point multiplication but it also uses a

00:17:59,360 --> 00:18:03,440
fixed point

00:18:00,000 --> 00:18:06,559
multiplication for uh perfect for

00:18:03,440 --> 00:18:07,520
secrecy to generate a female keys so in

00:18:06,559 --> 00:18:10,320
total we have

00:18:07,520 --> 00:18:10,799
uh in each careers handshake we have a

00:18:10,320 --> 00:18:13,120
two

00:18:10,799 --> 00:18:15,600
non-point multiplication and one unknown

00:18:13,120 --> 00:18:18,960
point multiplications

00:18:15,600 --> 00:18:22,000
uh next since we have uh points

00:18:18,960 --> 00:18:25,280
in uh some elliptical we deal with

00:18:22,000 --> 00:18:26,000
a coordinate system most of the

00:18:25,280 --> 00:18:30,400
libraries

00:18:26,000 --> 00:18:32,799
are used jacobian coordinate systems

00:18:30,400 --> 00:18:34,080
the coordinate systems works with

00:18:32,799 --> 00:18:36,880
frequent genetics

00:18:34,080 --> 00:18:37,520
x y and z i think coordinates aren't

00:18:36,880 --> 00:18:40,880
efficient

00:18:37,520 --> 00:18:44,559
and nobody uses them and they are just

00:18:40,880 --> 00:18:45,440
two basic uh uh basically generates x

00:18:44,559 --> 00:18:48,559
and y

00:18:45,440 --> 00:18:52,480
uh jacobi can unite is much faster

00:18:48,559 --> 00:18:56,480
and uh if if we

00:18:52,480 --> 00:18:59,760
compare how uh how

00:18:56,480 --> 00:19:02,720
how point multiplication with uh some

00:18:59,760 --> 00:19:03,919
combo algorithm works in uh two

00:19:02,720 --> 00:19:06,799
coordinate system

00:19:03,919 --> 00:19:08,640
then we see that jacobin is much more

00:19:06,799 --> 00:19:11,440
cheaper because we

00:19:08,640 --> 00:19:14,480
have to do a lot of additions and

00:19:11,440 --> 00:19:17,919
doubling during point multiplications

00:19:14,480 --> 00:19:19,760
uh next this form of four point addition

00:19:17,919 --> 00:19:23,039
in jacobian coordinates

00:19:19,760 --> 00:19:25,640
the important thing for us is that

00:19:23,039 --> 00:19:28,080
in this formal we have a lot of

00:19:25,640 --> 00:19:31,200
multiplications and squaring

00:19:28,080 --> 00:19:34,320
in actually this 11 multiplications and

00:19:31,200 --> 00:19:37,280
five squarings uh all the uh

00:19:34,320 --> 00:19:39,559
all the operations uh in ellipticals are

00:19:37,280 --> 00:19:43,039
expressed usually using

00:19:39,559 --> 00:19:46,559
multiplications multiplication is a

00:19:43,039 --> 00:19:50,320
basic measure for the formulas

00:19:46,559 --> 00:19:51,679
uh squaring also expresses for

00:19:50,320 --> 00:19:54,960
multiplications

00:19:51,679 --> 00:19:56,400
in fast montgomery multiplication with

00:19:54,960 --> 00:19:59,840
modular reduction

00:19:56,400 --> 00:20:02,880
this about eighty percent from um

00:19:59,840 --> 00:20:05,520
multiplication for slow fibs

00:20:02,880 --> 00:20:06,159
modular reduction with multiplication

00:20:05,520 --> 00:20:09,600
with this

00:20:06,159 --> 00:20:12,640
about 90 percent from

00:20:09,600 --> 00:20:15,440
uh model form multiplication

00:20:12,640 --> 00:20:16,240
this also modular inversion very slow

00:20:15,440 --> 00:20:19,039
operation

00:20:16,240 --> 00:20:20,799
which usually costs about 100 uh

00:20:19,039 --> 00:20:23,840
multiplications

00:20:20,799 --> 00:20:26,640
uh next we go down and

00:20:23,840 --> 00:20:29,440
now we work with uh scholar

00:20:26,640 --> 00:20:32,400
multiplications and uh

00:20:29,440 --> 00:20:34,240
squarings and the basic other basic uh

00:20:32,400 --> 00:20:37,440
mathematic operations

00:20:34,240 --> 00:20:41,280
we work with four limbs this means that

00:20:37,440 --> 00:20:44,720
in elliptical 256 uh we

00:20:41,280 --> 00:20:48,000
work with 256 bits this uh uh

00:20:44,720 --> 00:20:52,080
four uh unsigned longs by

00:20:48,000 --> 00:20:55,280
uh 48 bits and we work with a big

00:20:52,080 --> 00:20:58,799
integers of 256 bits

00:20:55,280 --> 00:21:02,720
ah this examples of finite

00:20:58,799 --> 00:21:06,799
field of 29 this

00:21:02,720 --> 00:21:11,520
in our actual uh elliptical will have

00:21:06,799 --> 00:21:13,600
that prime of 256 bids

00:21:11,520 --> 00:21:14,720
usually libraries use montgomery

00:21:13,600 --> 00:21:17,679
reduction

00:21:14,720 --> 00:21:18,960
and the only reason why i consider fips

00:21:17,679 --> 00:21:22,400
reduction in this uh

00:21:18,960 --> 00:21:24,000
size because original mp3s library uses

00:21:22,400 --> 00:21:27,840
a 5ps reduction

00:21:24,000 --> 00:21:31,039
we pay a lot of effort and to make it

00:21:27,840 --> 00:21:35,440
the reduction as fast as possible we

00:21:31,039 --> 00:21:38,640
used the research from both by 2012

00:21:35,440 --> 00:21:41,600
and our best result is to make it uh

00:21:38,640 --> 00:21:42,559
only 65 percent thousand montgomery

00:21:41,600 --> 00:21:45,360
reduction

00:21:42,559 --> 00:21:46,400
so we gave up and move it to montgomery

00:21:45,360 --> 00:21:49,679
reduction

00:21:46,400 --> 00:21:53,679
the basic idea of montgomery reduction

00:21:49,679 --> 00:21:56,720
is that in moderate magic you have to

00:21:53,679 --> 00:21:58,640
divide all your mathematical results of

00:21:56,720 --> 00:22:01,919
all your mathematic results

00:21:58,640 --> 00:22:04,559
by a large prime number to get the

00:22:01,919 --> 00:22:07,039
residuals

00:22:04,559 --> 00:22:08,000
the idea of montgomery reduction is to

00:22:07,039 --> 00:22:11,120
replace the

00:22:08,000 --> 00:22:14,559
division by sum prime by division

00:22:11,120 --> 00:22:17,679
by some power of 2 in this case

00:22:14,559 --> 00:22:21,360
2 in power of 256

00:22:17,679 --> 00:22:24,080
so intermediate first we

00:22:21,360 --> 00:22:25,360
convert all the appearance into

00:22:24,080 --> 00:22:28,400
montgomery form

00:22:25,360 --> 00:22:32,240
it means that we multiply them

00:22:28,400 --> 00:22:32,240
by our prime and

00:22:33,039 --> 00:22:40,000
make a residuals after that we

00:22:36,799 --> 00:22:43,200
we do very cheap intermediate

00:22:40,000 --> 00:22:45,520
computation and after that we at the end

00:22:43,200 --> 00:22:48,240
we have to convert to the

00:22:45,520 --> 00:22:48,799
normal form so we have our heads but

00:22:48,240 --> 00:22:51,919
since

00:22:48,799 --> 00:22:55,360
we do a lot of computations with

00:22:51,919 --> 00:22:59,600
very fast immediate results then now

00:22:55,360 --> 00:23:03,520
in general we go very quickly

00:22:59,600 --> 00:23:06,240
so at this point we understand that

00:23:03,520 --> 00:23:06,640
we have actually several layers we have

00:23:06,240 --> 00:23:09,600
a

00:23:06,640 --> 00:23:11,600
point multiplication which deals with

00:23:09,600 --> 00:23:15,200
point addition and point doubling

00:23:11,600 --> 00:23:16,799
we have uh scalar multiplications and

00:23:15,200 --> 00:23:19,919
basic operations

00:23:16,799 --> 00:23:21,039
and we have a reduction formula and

00:23:19,919 --> 00:23:24,159
finally we

00:23:21,039 --> 00:23:25,919
work with the actual assembly code which

00:23:24,159 --> 00:23:29,120
deals with

00:23:25,919 --> 00:23:32,240
registers and so on in general we

00:23:29,120 --> 00:23:35,520
have to find the balance between all the

00:23:32,240 --> 00:23:37,520
layers to make the balance as the most

00:23:35,520 --> 00:23:40,159
fast

00:23:37,520 --> 00:23:41,200
fast cryptography implementation as an

00:23:40,159 --> 00:23:44,320
example consider

00:23:41,200 --> 00:23:46,320
that we have a form of four point

00:23:44,320 --> 00:23:50,000
multiplication which requires

00:23:46,320 --> 00:23:52,400
55 point additionals uh we

00:23:50,000 --> 00:23:54,159
have for example we have a jacobian

00:23:52,400 --> 00:23:58,159
coordinates which

00:23:54,159 --> 00:24:00,880
just considers and we have a first

00:23:58,159 --> 00:24:03,360
faster form of four mixed coordinate

00:24:00,880 --> 00:24:05,440
system within jacobian

00:24:03,360 --> 00:24:07,360
this estimation for the mixed

00:24:05,440 --> 00:24:10,000
coordinates is

00:24:07,360 --> 00:24:11,760
much better than for plain jacobian

00:24:10,000 --> 00:24:15,279
coordinates

00:24:11,760 --> 00:24:18,080
and unfortunately we have to

00:24:15,279 --> 00:24:19,120
pay for coordinates normalization if we

00:24:18,080 --> 00:24:22,960
use a mixed

00:24:19,120 --> 00:24:26,400
cardinals and mixed coordinates implies

00:24:22,960 --> 00:24:30,320
um modular inversion

00:24:26,400 --> 00:24:30,960
and now if we have very fast modular

00:24:30,320 --> 00:24:34,559
inversion

00:24:30,960 --> 00:24:37,760
then we for this implementation we can

00:24:34,559 --> 00:24:39,679
uh go with the same speed in

00:24:37,760 --> 00:24:41,760
jacobian coordinates and i think

00:24:39,679 --> 00:24:45,039
jacobian mixed coordinates

00:24:41,760 --> 00:24:45,760
however if uh model inversion isn't so

00:24:45,039 --> 00:24:48,080
fast

00:24:45,760 --> 00:24:49,760
as now implementation then usually i

00:24:48,080 --> 00:24:53,919
think jacobian coordinates

00:24:49,760 --> 00:24:56,320
uh due to additional uh model inversion

00:24:53,919 --> 00:24:57,679
uh slower than plain uh jacobian

00:24:56,320 --> 00:25:00,880
coordinates

00:24:57,679 --> 00:25:02,880
uh however when we moved from fips

00:25:00,880 --> 00:25:03,840
modular reduction to montgomery

00:25:02,880 --> 00:25:06,880
arithmetics

00:25:03,840 --> 00:25:09,919
then we got very nice performance

00:25:06,880 --> 00:25:12,159
improvement from 28 percent for a cdhe

00:25:09,919 --> 00:25:14,960
and the sixth performance person

00:25:12,159 --> 00:25:18,400
performs improvement for cdsa

00:25:14,960 --> 00:25:19,440
uh while we discussed performance we

00:25:18,400 --> 00:25:22,720
also

00:25:19,440 --> 00:25:26,240
have to discuss uh security uh

00:25:22,720 --> 00:25:29,679
actually um most of most of

00:25:26,240 --> 00:25:33,039
cryptography implementations libraries

00:25:29,679 --> 00:25:36,240
use constant time algorithms

00:25:33,039 --> 00:25:37,440
this required to protect against side

00:25:36,240 --> 00:25:39,760
channel attacks

00:25:37,440 --> 00:25:41,120
for example if your algorithm isn't

00:25:39,760 --> 00:25:43,679
constant time

00:25:41,120 --> 00:25:45,360
then attacker may analyze different time

00:25:43,679 --> 00:25:48,720
required for computation

00:25:45,360 --> 00:25:52,000
uh depending on different uh input data

00:25:48,720 --> 00:25:52,960
so this is a side uh channel typically

00:25:52,000 --> 00:25:54,320
uh

00:25:52,960 --> 00:25:56,960
implementation use constant time

00:25:54,320 --> 00:26:00,159
algorithms which use the same

00:25:56,960 --> 00:26:02,559
time for all any input data

00:26:00,159 --> 00:26:04,640
however there are also possibility to

00:26:02,559 --> 00:26:07,440
use no faster non-constant time

00:26:04,640 --> 00:26:08,240
implementation and add a dime operation

00:26:07,440 --> 00:26:10,640
to make

00:26:08,240 --> 00:26:11,600
the whole computations uh with the same

00:26:10,640 --> 00:26:14,159
time

00:26:11,600 --> 00:26:15,360
and alternatively we have a point

00:26:14,159 --> 00:26:18,559
randomization

00:26:15,360 --> 00:26:19,360
which uh just uh randomizes the input

00:26:18,559 --> 00:26:22,240
data

00:26:19,360 --> 00:26:22,799
uh so uh if you go with non-constant

00:26:22,240 --> 00:26:24,799
time

00:26:22,799 --> 00:26:26,240
algorithms and attack still cannot

00:26:24,799 --> 00:26:29,120
predict the original

00:26:26,240 --> 00:26:30,080
input data because we multiplied them

00:26:29,120 --> 00:26:33,360
for some

00:26:30,080 --> 00:26:36,159
uh random number and this very uh

00:26:33,360 --> 00:26:38,000
we can very efficiently move back to the

00:26:36,159 --> 00:26:40,720
original representation

00:26:38,000 --> 00:26:41,200
uh for example if we use very fast led

00:26:40,720 --> 00:26:45,120
land

00:26:41,200 --> 00:26:45,120
uh cpu instruction which provide us

00:26:45,360 --> 00:26:51,840
a random number generator then we

00:26:48,720 --> 00:26:54,960
in case of module inversion we can uh

00:26:51,840 --> 00:26:59,039
make it almost three times faster the

00:26:54,960 --> 00:27:02,400
bad news is that this uh sri dbs

00:26:59,039 --> 00:27:05,440
vulnerability in modern cpus

00:27:02,400 --> 00:27:09,200
which also which just kills the

00:27:05,440 --> 00:27:10,240
perform and if we use uh mitigation for

00:27:09,200 --> 00:27:12,240
the vulnerability

00:27:10,240 --> 00:27:13,440
it just kills the performance of the

00:27:12,240 --> 00:27:17,440
instruction

00:27:13,440 --> 00:27:20,960
and this um which also knew that

00:27:17,440 --> 00:27:24,640
the latest cpus from intel

00:27:20,960 --> 00:27:28,399
already fixes the problem and the latest

00:27:24,640 --> 00:27:31,520
cpus can run on led land

00:27:28,399 --> 00:27:34,559
so if you trust your cpu vendor then you

00:27:31,520 --> 00:27:37,520
can use temperature vs with a

00:27:34,559 --> 00:27:39,200
random fast random number generation for

00:27:37,520 --> 00:27:41,600
formal development instruction

00:27:39,200 --> 00:27:43,039
if you don't trust then you can compile

00:27:41,600 --> 00:27:45,679
the source code with

00:27:43,039 --> 00:27:46,240
constant time crypto and just be safe

00:27:45,679 --> 00:27:49,520
but

00:27:46,240 --> 00:27:52,480
with slower next

00:27:49,520 --> 00:27:52,799
thing from the side channel attacks is

00:27:52,480 --> 00:27:56,559
the

00:27:52,799 --> 00:27:58,640
memory uh memory usage as i said that

00:27:56,559 --> 00:27:59,840
uh fixed point multiplication uses the

00:27:58,640 --> 00:28:03,279
computer table

00:27:59,840 --> 00:28:04,480
this pretty small for embedded uh mp3s

00:28:03,279 --> 00:28:08,399
but it's much

00:28:04,480 --> 00:28:12,559
larger than layer 1 cpu cache size

00:28:08,399 --> 00:28:15,679
for both of open cell and wolf ssa

00:28:12,559 --> 00:28:19,200
this was the subject for our bug report

00:28:15,679 --> 00:28:22,559
for wifi is that they didn't uh

00:28:19,200 --> 00:28:25,919
use the whole uh table scan on each

00:28:22,559 --> 00:28:29,200
uh point uh point addition

00:28:25,919 --> 00:28:33,200
in their implementation it means that

00:28:29,200 --> 00:28:37,120
um open a cell actually a scans of whole

00:28:33,200 --> 00:28:37,760
table and this means that about 56 or

00:28:37,120 --> 00:28:41,279
maybe

00:28:37,760 --> 00:28:44,720
uh yes i i i think 36 uh

00:28:41,279 --> 00:28:45,679
times open sales scans the whole 150

00:28:44,720 --> 00:28:48,799
kilobytes

00:28:45,679 --> 00:28:52,399
uh precomputed uh

00:28:48,799 --> 00:28:55,039
table or to go go with

00:28:52,399 --> 00:28:55,600
fixed point uh multiplication however if

00:28:55,039 --> 00:28:58,640
i said

00:28:55,600 --> 00:28:59,440
uh directly accesses the required item

00:28:58,640 --> 00:29:02,720
in the table

00:28:59,440 --> 00:29:05,919
and this make if we consider

00:29:02,720 --> 00:29:08,960
cache misses then very easy for

00:29:05,919 --> 00:29:12,720
attacker to predict the time

00:29:08,960 --> 00:29:15,919
actual data actual

00:29:12,720 --> 00:29:19,440
uh secret data depending on access time

00:29:15,919 --> 00:29:23,200
to lay first cpu cache

00:29:19,440 --> 00:29:26,799
uh this last topic about

00:29:23,200 --> 00:29:30,240
uh internals in of crypto libraries

00:29:26,799 --> 00:29:33,279
this abstraction for big integers

00:29:30,240 --> 00:29:36,159
uh this this site

00:29:33,279 --> 00:29:37,360
form from the linux scan which also uses

00:29:36,159 --> 00:29:41,840
big integers

00:29:37,360 --> 00:29:41,840
and all the libraries use them in

00:29:41,919 --> 00:29:46,960
more or less but in btl less overuse of

00:29:45,039 --> 00:29:49,200
them

00:29:46,960 --> 00:29:51,520
the problem is that if you have

00:29:49,200 --> 00:29:54,320
abstraction for

00:29:51,520 --> 00:29:55,279
various sizes of big integers then you

00:29:54,320 --> 00:29:59,279
have to deal

00:29:55,279 --> 00:30:02,320
with memory allocations copies and so on

00:29:59,279 --> 00:30:05,200
uh the basic ideas are very

00:30:02,320 --> 00:30:05,840
well described in the book by tom uh

00:30:05,200 --> 00:30:09,440
danis

00:30:05,840 --> 00:30:13,360
and the authors of ambitious used

00:30:09,440 --> 00:30:17,120
uh the book as a main reference

00:30:13,360 --> 00:30:17,760
however uh libraries like qualification

00:30:17,120 --> 00:30:20,960
open cell

00:30:17,760 --> 00:30:23,679
and investigate uh uses um

00:30:20,960 --> 00:30:24,480
size specific uh code which means that

00:30:23,679 --> 00:30:28,080
for

00:30:24,480 --> 00:30:28,559
uh elliptic off with uh 256 bits we have

00:30:28,080 --> 00:30:31,840
a

00:30:28,559 --> 00:30:32,720
uh separate implementation for all the

00:30:31,840 --> 00:30:35,039
mathematic

00:30:32,720 --> 00:30:35,760
operations like multiplication squaring

00:30:35,039 --> 00:30:39,440
and so on

00:30:35,760 --> 00:30:39,919
for 512 bits we have a completely

00:30:39,440 --> 00:30:42,159
different

00:30:39,919 --> 00:30:43,520
implementation and all the libraries

00:30:42,159 --> 00:30:46,799
juices and

00:30:43,520 --> 00:30:50,159
all them are hand written

00:30:46,799 --> 00:30:51,360
uh i mentioned that this assembly

00:30:50,159 --> 00:30:55,039
implementation

00:30:51,360 --> 00:30:57,600
and actually implement

00:30:55,039 --> 00:30:58,559
cryptography and assembly sometimes much

00:30:57,600 --> 00:31:01,679
easier than

00:30:58,559 --> 00:31:04,960
doing this in c as

00:31:01,679 --> 00:31:09,200
the code snippet above is a

00:31:04,960 --> 00:31:12,640
addition of two uh two big integers

00:31:09,200 --> 00:31:16,480
uh size of big integers are two limbs

00:31:12,640 --> 00:31:19,840
and we have to uh so what was going in

00:31:16,480 --> 00:31:20,960
on in the addition first we add the less

00:31:19,840 --> 00:31:23,760
significant

00:31:20,960 --> 00:31:24,640
limbs to each other next we have some

00:31:23,760 --> 00:31:28,799
carry

00:31:24,640 --> 00:31:32,080
and we add more significant limbs

00:31:28,799 --> 00:31:32,720
with the carrying this only three lines

00:31:32,080 --> 00:31:36,399
of code

00:31:32,720 --> 00:31:38,799
but probably you need some time to

00:31:36,399 --> 00:31:39,919
check whether the carry computation is

00:31:38,799 --> 00:31:43,120
correct

00:31:39,919 --> 00:31:46,960
however if we go to assembly then we

00:31:43,120 --> 00:31:50,320
do only two instruction we add

00:31:46,960 --> 00:31:52,559
less significant limbs next we use

00:31:50,320 --> 00:31:53,600
uh assembly instruction which

00:31:52,559 --> 00:31:56,880
automatically

00:31:53,600 --> 00:31:57,519
adds a current carry when you choose the

00:31:56,880 --> 00:32:01,200
next

00:31:57,519 --> 00:32:04,240
additional so sometimes using assembly

00:32:01,200 --> 00:32:08,880
not only more efficient but also

00:32:04,240 --> 00:32:11,360
much easier than theme ah they also

00:32:08,880 --> 00:32:12,399
we actually didn't finish our

00:32:11,360 --> 00:32:15,600
performance

00:32:12,399 --> 00:32:18,640
enhancement of tempest tls it will uh

00:32:15,600 --> 00:32:21,760
be much more faster uh first

00:32:18,640 --> 00:32:25,360
ice lake uh cpu center have amazing

00:32:21,760 --> 00:32:28,720
ivx 512 which

00:32:25,360 --> 00:32:31,519
in this implementation

00:32:28,720 --> 00:32:32,159
multiplication instruction are very fast

00:32:31,519 --> 00:32:36,000
and we

00:32:32,159 --> 00:32:39,760
don't have um nasty down clocking

00:32:36,000 --> 00:32:40,799
and the good thing is that there are a

00:32:39,760 --> 00:32:43,919
lot of

00:32:40,799 --> 00:32:44,640
recent research exploring the cpu

00:32:43,919 --> 00:32:48,240
extension

00:32:44,640 --> 00:32:52,720
in cryptography applications

00:32:48,240 --> 00:32:55,360
uh we also proposed the tempest gliac

00:32:52,720 --> 00:32:56,080
for the linux kernel upstream we

00:32:55,360 --> 00:32:59,519
discussed

00:32:56,080 --> 00:33:02,720
uh the implementation in the last nadief

00:32:59,519 --> 00:33:04,000
conference and also this reference to

00:33:02,720 --> 00:33:06,960
our github

00:33:04,000 --> 00:33:08,880
issue uh discussing the ipi which you

00:33:06,960 --> 00:33:12,159
suggest for the linux kernel

00:33:08,880 --> 00:33:16,720
we're going to focus on server side only

00:33:12,159 --> 00:33:19,120
and uh we also need to

00:33:16,720 --> 00:33:21,840
well uh the kernel implementation should

00:33:19,120 --> 00:33:24,640
be very restricted in its functionality

00:33:21,840 --> 00:33:24,960
so in the kernel implementation uh finds

00:33:24,640 --> 00:33:28,000
that

00:33:24,960 --> 00:33:30,720
it cannot establish uh

00:33:28,000 --> 00:33:31,840
serious uh handshake then this should be

00:33:30,720 --> 00:33:34,559
a way to

00:33:31,840 --> 00:33:36,240
uh fail back to user space

00:33:34,559 --> 00:33:39,760
implementation like openness

00:33:36,240 --> 00:33:42,640
say this a very very serious

00:33:39,760 --> 00:33:44,080
uh task which we need to solve for this

00:33:42,640 --> 00:33:46,480
implementation

00:33:44,080 --> 00:33:47,600
uh before moving to the kernel we also

00:33:46,480 --> 00:33:50,880
have to solve

00:33:47,600 --> 00:33:53,600
uh several problems uh the first one is

00:33:50,880 --> 00:33:55,600
performance as i said we didn't finish

00:33:53,600 --> 00:33:58,320
our performance optimization

00:33:55,600 --> 00:33:59,039
and there are two tasks which we need to

00:33:58,320 --> 00:34:02,159
accomplish

00:33:59,039 --> 00:34:05,279
before uh going to upstream next

00:34:02,159 --> 00:34:08,720
it me makes sense to

00:34:05,279 --> 00:34:10,800
go with tls 1.3 only for

00:34:08,720 --> 00:34:13,200
the kernel implementation and we also

00:34:10,800 --> 00:34:16,560
have issue on our github

00:34:13,200 --> 00:34:20,079
for this this also

00:34:16,560 --> 00:34:23,040
some infrastructure tasks

00:34:20,079 --> 00:34:23,919
to deal with the symmetric uh keys and

00:34:23,040 --> 00:34:26,159
lastly

00:34:23,919 --> 00:34:27,839
unfortunately the linux kernel crypto

00:34:26,159 --> 00:34:30,879
api isn't perfect

00:34:27,839 --> 00:34:34,000
for example it have very slow

00:34:30,879 --> 00:34:38,159
implementation of the hash function for

00:34:34,000 --> 00:34:41,440
sha 256 it's much lower than

00:34:38,159 --> 00:34:43,520
open cell also there are some extra

00:34:41,440 --> 00:34:46,800
copies and memory allocations

00:34:43,520 --> 00:34:50,000
for ktls so you also

00:34:46,800 --> 00:34:53,359
pay some overhead for basic

00:34:50,000 --> 00:34:56,560
ktls workloads and

00:34:53,359 --> 00:34:59,520
basically it's good to fix them before

00:34:56,560 --> 00:34:59,920
going upstream you can find more details

00:34:59,520 --> 00:35:04,960
about

00:34:59,920 --> 00:35:08,480
impersonations in our papers for net df

00:35:04,960 --> 00:35:09,760
and basically that's all uh if you're

00:35:08,480 --> 00:35:12,560
interested in

00:35:09,760 --> 00:35:14,000
fast linux kernel js implementation then

00:35:12,560 --> 00:35:17,680
we definitely

00:35:14,000 --> 00:35:20,000
want to have from you also

00:35:17,680 --> 00:35:20,960
as i mentioned there are plenty of work

00:35:20,000 --> 00:35:24,079
to make

00:35:20,960 --> 00:35:27,520
uh cannot elias in

00:35:24,079 --> 00:35:31,760
upstream so any contributions

00:35:27,520 --> 00:35:33,680
support any help is very appreciated and

00:35:31,760 --> 00:35:36,960
we definitely want to

00:35:33,680 --> 00:35:41,599
have from you guys so that's all

00:35:36,960 --> 00:35:41,599
thank you and i'm ready for questions

00:35:43,520 --> 00:35:47,599
wonderful thank you so much that was uh

00:35:45,839 --> 00:35:48,720
really great we've got a couple of good

00:35:47,599 --> 00:35:51,280
questions that have come

00:35:48,720 --> 00:35:53,040
through on the chat and could everyone

00:35:51,280 --> 00:35:54,960
please if you have questions

00:35:53,040 --> 00:35:57,119
post them now so we have a chance to get

00:35:54,960 --> 00:36:00,240
to them in the next 10 minutes we've got

00:35:57,119 --> 00:36:04,160
for q a so first question

00:36:00,240 --> 00:36:05,359
is from steve hanley does tls perth run

00:36:04,160 --> 00:36:07,280
in user space

00:36:05,359 --> 00:36:08,480
do you have limitations running tests

00:36:07,280 --> 00:36:11,040
from the single

00:36:08,480 --> 00:36:13,680
tls perf to a kernel space tls

00:36:11,040 --> 00:36:17,200
connection response

00:36:13,680 --> 00:36:19,599
um first thank you for question

00:36:17,200 --> 00:36:20,320
i didn't get the second part of the

00:36:19,599 --> 00:36:23,440
question

00:36:20,320 --> 00:36:26,640
yes tim best tv spf uh first you can

00:36:23,440 --> 00:36:30,079
find it on our github it's a very

00:36:26,640 --> 00:36:33,200
straightforward photo running in

00:36:30,079 --> 00:36:35,520
user space it's just open ssl uh

00:36:33,200 --> 00:36:36,160
implementation which runs in multi-flat

00:36:35,520 --> 00:36:39,440
users

00:36:36,160 --> 00:36:42,720
ipo and it's very very simple

00:36:39,440 --> 00:36:47,040
stuff do you have limitations

00:36:42,720 --> 00:36:50,400
from do you have any limitations

00:36:47,040 --> 00:36:52,880
sorry i i didn't get what it is

00:36:50,400 --> 00:36:56,400
oh i think the limitations are about any

00:36:52,880 --> 00:36:56,400
limitations running in user space

00:36:57,440 --> 00:37:04,400
kernel space i cannot imagine

00:37:00,800 --> 00:37:07,680
about any limitations

00:37:04,400 --> 00:37:08,079
the kernel works with user space in our

00:37:07,680 --> 00:37:11,760
case

00:37:08,079 --> 00:37:14,800
we are normal interfaces like

00:37:11,760 --> 00:37:18,960
turntab for virtual machine or

00:37:14,800 --> 00:37:22,320
just look back whatever maybe you can

00:37:18,960 --> 00:37:25,280
maybe you can specify what's uh

00:37:22,320 --> 00:37:26,960
which limitation do you mean okay well

00:37:25,280 --> 00:37:28,720
um steve if you want to add

00:37:26,960 --> 00:37:30,320
any more context please throw it in the

00:37:28,720 --> 00:37:30,880
chat and we'll come back to that in a

00:37:30,320 --> 00:37:32,880
moment

00:37:30,880 --> 00:37:35,520
we have another question from peter hugh

00:37:32,880 --> 00:37:37,760
uh why did you use jacobian coordinates

00:37:35,520 --> 00:37:39,280
not lopez dahab coordinates where the

00:37:37,760 --> 00:37:42,079
mixed addition takes even less

00:37:39,280 --> 00:37:42,079
multiplications

00:37:43,520 --> 00:37:47,280
um thank you very much for this question

00:37:46,720 --> 00:37:50,400
that's

00:37:47,280 --> 00:37:53,760
quite a good question uh

00:37:50,400 --> 00:37:55,920
we are just uh

00:37:53,760 --> 00:37:57,200
analyze the possibility to use or pass

00:37:55,920 --> 00:38:00,320
the half coordinates

00:37:57,200 --> 00:38:04,079
we didn't try it this is one of our to

00:38:00,320 --> 00:38:06,160
do to try oppress the hub coordinates

00:38:04,079 --> 00:38:07,359
okay wonderful um we've got another

00:38:06,160 --> 00:38:10,640
question from amateur

00:38:07,359 --> 00:38:13,960
isaacs why the choice of nist

00:38:10,640 --> 00:38:17,520
p 256 curve instead of the fasta

00:38:13,960 --> 00:38:20,560
25519 curve yeah

00:38:17,520 --> 00:38:21,520
probably i was too fast in my size i

00:38:20,560 --> 00:38:24,720
just um

00:38:21,520 --> 00:38:29,200
shared my site which addresses this

00:38:24,720 --> 00:38:29,200
uh question can you show the sites

00:38:30,880 --> 00:38:37,040
okay um oh sorry maybe maybe

00:38:33,920 --> 00:38:40,240
okay like i can say in my what

00:38:37,040 --> 00:38:44,160
um this um uh this

00:38:40,240 --> 00:38:47,520
requirement from um from ian

00:38:44,160 --> 00:38:51,040
i guess from a nice team uh

00:38:47,520 --> 00:38:54,720
that uh ca certificates can use

00:38:51,040 --> 00:38:57,920
only rsa or nist

00:38:54,720 --> 00:38:58,240
elliptic curve for ca certificates this

00:38:57,920 --> 00:39:02,160
uh

00:38:58,240 --> 00:39:07,200
first reference from uh cup forum

00:39:02,160 --> 00:39:11,760
so while curve 255.19 is faster than

00:39:07,200 --> 00:39:12,079
an st 256 it only can be used basically

00:39:11,760 --> 00:39:15,359
for

00:39:12,079 --> 00:39:18,480
cgha only so before first

00:39:15,359 --> 00:39:19,040
focused on a nice tier cuff which is

00:39:18,480 --> 00:39:22,240
here

00:39:19,040 --> 00:39:26,160
can be used in both of uh

00:39:22,240 --> 00:39:29,760
cdsa for certificate and the chcg

00:39:26,160 --> 00:39:33,040
and next we'll go to cough 255

00:39:29,760 --> 00:39:35,119
19. okay great

00:39:33,040 --> 00:39:36,880
um we've got we're just waiting to see

00:39:35,119 --> 00:39:37,280
if there's a couple more questions come

00:39:36,880 --> 00:39:39,520
through

00:39:37,280 --> 00:39:40,960
so i guess i just have a higher level

00:39:39,520 --> 00:39:43,520
question which is more

00:39:40,960 --> 00:39:44,320
what's uh what's next what's the next

00:39:43,520 --> 00:39:45,839
big

00:39:44,320 --> 00:39:47,760
challenge that you want to try to

00:39:45,839 --> 00:39:50,400
address

00:39:47,760 --> 00:39:51,599
uh the next change is performance we

00:39:50,400 --> 00:39:54,720
didn't finish with

00:39:51,599 --> 00:39:55,280
our um with our research and development

00:39:54,720 --> 00:39:58,640
for as

00:39:55,280 --> 00:39:59,440
i said for example we should have past

00:39:58,640 --> 00:40:03,440
the hub

00:39:59,440 --> 00:40:06,640
coordinates there also recent research

00:40:03,440 --> 00:40:08,200
uh for example from robert the research

00:40:06,640 --> 00:40:11,440
is dated by

00:40:08,200 --> 00:40:14,560
2019 about first

00:40:11,440 --> 00:40:17,359
point multiplication algorithm uh with

00:40:14,560 --> 00:40:20,480
constant time and non-constant time

00:40:17,359 --> 00:40:23,440
uh variations so we uh

00:40:20,480 --> 00:40:24,160
first first we focus on performance

00:40:23,440 --> 00:40:29,040
stuff

00:40:24,160 --> 00:40:31,760
next we should implement cherius 1.3

00:40:29,040 --> 00:40:32,400
and after that probably will be ready to

00:40:31,760 --> 00:40:35,839
go

00:40:32,400 --> 00:40:37,920
upstream with tempest stereos

00:40:35,839 --> 00:40:39,440
wonderful we don't have any more

00:40:37,920 --> 00:40:41,440
questions coming through on the chat

00:40:39,440 --> 00:40:42,480
quite yet so is there anything else that

00:40:41,440 --> 00:40:44,480
you'd like to share

00:40:42,480 --> 00:40:45,680
with the audience about uh about the

00:40:44,480 --> 00:40:48,640
work about

00:40:45,680 --> 00:40:49,599
um any of the challenges or or where

00:40:48,640 --> 00:40:52,800
you're trying to

00:40:49,599 --> 00:40:56,000
head um maybe not

00:40:52,800 --> 00:40:59,280
i i spoke about why what i had

00:40:56,000 --> 00:41:02,400
uh just please visit our github uh

00:40:59,280 --> 00:41:03,839
make comments we appreciate your

00:41:02,400 --> 00:41:06,960
comments your

00:41:03,839 --> 00:41:08,560
issues so whatever

00:41:06,960 --> 00:41:10,960
wonderful all right then what we'll do

00:41:08,560 --> 00:41:11,599
is we'll i'll actually do the outro then

00:41:10,960 --> 00:41:14,160
so

00:41:11,599 --> 00:41:15,520
uh thank you uh very much for coming

00:41:14,160 --> 00:41:17,040
speaking we do have one other question

00:41:15,520 --> 00:41:19,440
that's just popped in

00:41:17,040 --> 00:41:20,480
from amateur isaacs yeah are you also

00:41:19,440 --> 00:41:24,960
going to try

00:41:20,480 --> 00:41:28,000
nist p384 curve

00:41:24,960 --> 00:41:32,319
p which one 384

00:41:28,000 --> 00:41:36,079
i'll just post it um well

00:41:32,319 --> 00:41:39,200
they think is that we uh gave up

00:41:36,079 --> 00:41:42,240
and just throw it out their decision

00:41:39,200 --> 00:41:45,040
was uh that it seems

00:41:42,240 --> 00:41:45,599
that nobody uses this if you do use it

00:41:45,040 --> 00:41:48,960
uh

00:41:45,599 --> 00:41:52,720
please please comment us because um

00:41:48,960 --> 00:41:56,480
actually no one seriously optimizes it

00:41:52,720 --> 00:41:59,040
for example open cell um implementation

00:41:56,480 --> 00:41:59,680
for this group is much slower than even

00:41:59,040 --> 00:42:02,720
for

00:41:59,680 --> 00:42:05,520
pa 521

00:42:02,720 --> 00:42:07,119
so it turns out that just nobody

00:42:05,520 --> 00:42:09,440
interested in the groove

00:42:07,119 --> 00:42:10,319
if you do interested then we definitely

00:42:09,440 --> 00:42:12,880
want to

00:42:10,319 --> 00:42:13,920
uh hear from you that this proof is

00:42:12,880 --> 00:42:16,480
really important

00:42:13,920 --> 00:42:16,960
firstly we concentrated on only one

00:42:16,480 --> 00:42:20,000
group

00:42:16,960 --> 00:42:22,960
as a main effort for our

00:42:20,000 --> 00:42:24,640
research and development wonderful well

00:42:22,960 --> 00:42:28,560
thank you very much for an

00:42:24,640 --> 00:42:30,960
excellent talk um can everyone please

00:42:28,560 --> 00:42:34,480
just note that the blemings labs

00:42:30,960 --> 00:42:36,319
post talk q a channel on venulis

00:42:34,480 --> 00:42:38,560
is there specifically to follow up so

00:42:36,319 --> 00:42:40,800
amateur or any of the other questions

00:42:38,560 --> 00:42:41,920
um questioners if you would like to

00:42:40,800 --> 00:42:44,319
follow up um

00:42:41,920 --> 00:42:45,599
with alexander please do so there and

00:42:44,319 --> 00:42:46,880
alexander are you happy to

00:42:45,599 --> 00:42:48,800
to follow up with anyone that has

00:42:46,880 --> 00:42:50,240
questions with you in that channel then

00:42:48,800 --> 00:42:52,560
that would be great

00:42:50,240 --> 00:42:53,760
thank you so much thank you very much

00:42:52,560 --> 00:42:59,839
bye thank you

00:42:53,760 --> 00:42:59,839

YouTube URL: https://www.youtube.com/watch?v=AasSx9GpB-w


