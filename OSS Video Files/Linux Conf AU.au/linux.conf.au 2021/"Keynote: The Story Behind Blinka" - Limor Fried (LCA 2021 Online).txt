Title: "Keynote: The Story Behind Blinka" - Limor Fried (LCA 2021 Online)
Publication date: 2021-01-31
Playlist: linux.conf.au 2021
Description: 
	Limor Fried

https://lca2021.linux.org.au/schedule/presentation/122/

A love story of Blinka, going through the background, history and story behind Blinka.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sun Jan 24 09:10:00 2021 at Tux Theatre
Captions: 
	00:00:00,000 --> 00:00:06,264
(WIND BLOWING) (BABY PENGUINS CHIRPING)

00:00:06,264 --> 00:00:08,634
(LOUD THUD) (MUSICAL DRONE) (METALLIC "BLINK" SOUND EFFECT)

00:00:08,634 --> 00:00:12,322
(WHOOSH) (SHORT UPTEMPO MELODY)

00:00:15,200 --> 00:00:20,240
HOST: Now time for today's keynote. So it gives me  great pleasure in welcoming Limor Fried. 

00:00:20,240 --> 00:00:22,658
LIMOR: Hello! HOST: Hello!

00:00:22,658 --> 00:00:27,758
LIMOR: I'm here. This is amazing because  I've never been up this early. It's what, like 9 a.m for you?

00:00:29,041 --> 00:00:34,689
I get to fake it, I'm never up that early but it's awesome. I'm here in New York city

00:00:34,689 --> 00:00:42,640
and it's great to be able to speak here at Linux Conf Australia. I've never been to Australia, I don't know when I'll be able to go there because

00:00:42,640 --> 00:00:47,111
my country is totally screwed up right now  but when possible, I would love to visit.

00:00:47,111 --> 00:00:53,374
HOST: Well we'd love to have you here. I know our SwagBadge team we're very keen to be able to get to see you and 

00:00:53,374 --> 00:00:55,980
I think you've seen a little bit of about  our SwagBadge.

00:00:55,980 --> 00:00:58,800
LIMOR: Yeah, it's in the talk. It's one of the 167 slides.

00:00:59,451 --> 00:01:07,280
HOST: (LAUGHS) We're looking forward to it very much, so I'll hand over to you Limor, and we'll enjoy your keynote.  

00:01:07,280 --> 00:01:14,123
LIMOR: Alright, thank you. I'll enjoy it and if the people watching don't enjoy it, well I'm sorry but that's what it is. I'm the keynote speaker.

00:01:14,123 --> 00:01:22,720
So I'm gonna tell you a love story today. It's a beautiful love story between this snake Blinka, which i'm wearing on my shirt  

00:01:22,720 --> 00:01:27,280
but is also my first slide, let's go back there, okay. Let's stick like this, thank you Chris.

00:01:28,191 --> 00:01:35,011
And Blinka is our mascot for CircuitPython but Iwant to tell you the background, the history and the story behind this because 

00:01:35,011 --> 00:01:39,891
I'm at the point where i'm now meeting kids who like do not remember what it was like to do electronics

00:01:39,891 --> 00:01:46,788
and so they don't know why we made some choices and I thought that it could be illuminating and perhaps inspiring to know

00:01:46,788 --> 00:01:50,000
the story behind Blinka, this wonderful snake.

00:01:50,000 --> 00:02:00,850
So, start off. I'm Limor Fried, Ladyada, and I run this company called Adafruit and that's me in front of my pick and place machines.

00:02:00,850 --> 00:02:08,660
I went to school for electronics, I like building electronics and for some reason I just didn't want to get a job where somebody told me what to do 

00:02:08,660 --> 00:02:12,795
so instead, I got a job where I tell myself what to do and it sucks a lot more

00:02:12,795 --> 00:02:14,738
but I get to build cool electronics all day.

00:02:14,738 --> 00:02:22,320
So, we have a hundred plus people, we're in New York City, we're a couple blocks from the Prada store and the Apple store  

00:02:22,960 --> 00:02:28,795
which is pretty exciting and we do electronics and  making and 3D printing and all sorts of just like fun stuff.

00:02:28,795 --> 00:02:34,366
We've been kind of doing this for 15+ years, since 2005,

00:02:34,366 --> 00:02:44,746
when I started making synthesizers and mp3 players from scratch,  to now we stock 4,000 different products and make about 400.

00:02:46,154 --> 00:02:55,202
We tend to make microcontrollers, little boards that have LEDs or sensors and buttons and people can program them

00:02:55,202 --> 00:02:58,780
and so this is kind of what got me really excited about electrical engineering.

00:02:58,780 --> 00:03:05,231
When I went to school, I was actually a computer scientist. I studied software systems and compilers and stuff

00:03:05,231 --> 00:03:10,348
and I thought electrical engineering totally sucks because  all you do is make stereo systems

00:03:10,348 --> 00:03:15,688
but then I got interested in microcontrollers - and I'll show you the microcontroller that i learned on -

00:03:15,688 --> 00:03:19,622
and that totally captivated me because I was very excited to...

00:03:20,367 --> 00:03:24,851
If I'm going to get carpal tunnel from typing, at least I want to be able to show it off at the local pub.

00:03:24,851 --> 00:03:30,538
Here's two boards that we design and manufacture in New York City

00:03:30,538 --> 00:03:35,454
and this is a pre-COVID photo on our roof. Some of the people we have here, we have a whole team -

00:03:35,454 --> 00:03:40,543
shipping, engineering, facilities production, finance. Everyone here.

00:03:40,543 --> 00:03:44,773
A lot of us wear all black but not all of us, there's some exceptions.

00:03:45,360 --> 00:03:50,859
During the last year we've helped out also  with New York city's COVID response.

00:03:50,859 --> 00:03:55,730
New York City got hit really hard in April and it was  really bad

00:03:55,730 --> 00:03:59,752
we couldn't get face shields, for example, for medical professionals 

00:03:59,752 --> 00:04:05,789
so we had rolls of plastic and we had foam and we had laser cutters and 3d printers and so

00:04:05,789 --> 00:04:11,680
we kind of jumped up and said okay, well if we're not going to be manufacturing electronics because everything is shut down and locked down  

00:04:11,680 --> 00:04:17,542
how about we help out instead by helping make face shields. We made a couple thousand face shields for doctors 

00:04:17,542 --> 00:04:24,477
and here's here's some friends of ours who are wearing. We also have worked and are still working

00:04:24,477 --> 00:04:29,248
with folks making open source ventilators using the software and hardware that we've designed

00:04:29,248 --> 00:04:37,055
because it's easy to use, it's well documented and they can quickly integrate it, getting these DIY ventilators

00:04:37,055 --> 00:04:44,042
and sensor systems for ventilators and also now what's interesting is a lot of people are using our sensors to do

00:04:44,042 --> 00:04:49,420
air quality and air movement studies because ventilation is really important.

00:04:49,420 --> 00:04:54,180
How open do the windows have to be to make sure that you're getting full air circulation

00:04:54,180 --> 00:04:59,075
but not so open that everyone's freezing cold and you have to blast the heat and use a ton of energy

00:04:59,075 --> 00:05:04,142
so using uh airflow sensors and CO2 sensors is part of that as well

00:05:04,142 --> 00:05:08,618
and there's our factory which is kind of cool. Not the whole thing, we don't have the whole thing.

00:05:08,618 --> 00:05:13,225
we share it with a bunch of other companies as well, including a Starbucks in the basement

00:05:13,225 --> 00:05:18,201
which at the time was super deadly because I would have a coffee like, every day

00:05:18,201 --> 00:05:25,201
Okay, so let's actually get started with the talk itself. So, I'm going to start in the beginning of what it was like to build electronics

00:05:25,201 --> 00:05:32,373
because we have to go full circle from what it used to be, which was actually really awesome,

00:05:32,373 --> 00:05:37,123
to like this really murky period, to now which is, again, really awesome.

00:05:37,123 --> 00:05:44,765
So computers used to come with these parallel ports on the back, these really big DB25 pin things

00:05:44,765 --> 00:05:47,200
that were designed for printers or scanners

00:05:48,000 --> 00:05:53,040
and I looked around so, on Newegg, you can't buy computers with these but  

00:05:53,040 --> 00:05:57,760
there are still sellers of motherboards that have parallel ports on them  

00:05:57,760 --> 00:06:01,219
and they're still parallel port drivers in Linux and Windows

00:06:01,219 --> 00:06:07,657
and it was really cool because you had eight pins, general purpose input or output 

00:06:07,657 --> 00:06:13,414
and you had a couple of BUSY and ACK and whatever pins, you could tell by "Paper End" this is for printing.

00:06:13,414 --> 00:06:17,247
It was basically a print report but you could really abuse the heck out of this thing

00:06:17,247 --> 00:06:21,879
because you basically had a direct line to pins that would go high and low.

00:06:21,879 --> 00:06:26,388
So, for example, you can still to this day buy these CNC Controllers

00:06:26,388 --> 00:06:31,760
so these are for DIY, kind of like 3D printers but they cut material away.

00:06:32,880 --> 00:06:43,113
CNC lathes, CNC mills, CNC drawing machines. People still use parallel ports and here's an example of a build.

00:06:43,113 --> 00:06:48,732
I found this photo on Flickr and you can sort of see in the the bottom right here

00:06:48,732 --> 00:06:53,028
this is the parallel port converter and then it's plugged into this board

00:06:53,028 --> 00:06:58,441
and then these are like motor drivers, which are massive motor chips and this would be your CNC machine.

00:06:58,441 --> 00:07:03,477
And this is from the manual for the software. I just thought this clip art was just so awesome I had to share it with you

00:07:03,477 --> 00:07:10,898
but basically on the bottom left here you'd have a computer and then you have the power and data lines,

00:07:10,898 --> 00:07:14,062
it only shows four wires here but it's really the whole parallel port

00:07:14,062 --> 00:07:20,413
and then you would run the software on the computer and the software would run on Windows 3.1,

00:07:20,413 --> 00:07:26,165
pretty much was kind of the only thing, although there were some Linux CAM softwares written eventually

00:07:26,165 --> 00:07:33,440
and it would literally just say okay to move the stepper forward, toggle the pin once for every step and the stepper would move. 

00:07:33,440 --> 00:07:42,111
Super cool. Loved it. This is the parallel port assignments. Depending on what hardware you would plug in 

00:07:42,111 --> 00:07:48,790
you would align the pin number for the parallel port to your printer axis.

00:07:48,790 --> 00:07:53,045
So here, you've got x and y and z and all sorts of good stuff.

00:07:53,045 --> 00:08:00,210
So, this was a software called Mach3 which again, you can still buy it, although I don't think a lot of people use it

00:08:00,210 --> 00:08:05,555
But yeah, if you look for a parallel port motherboard on Newegg, all you get are these adapters.

00:08:05,555 --> 00:08:11,207
They don't sell computers with parallel ports really anymore. It's quite rare to get.

00:08:11,207 --> 00:08:16,939
Although if you're looking for just that, you probably would but my modern computer, it doesn't have one.

00:08:16,939 --> 00:08:21,167
Why? Because we got USB instead and I don't blame them, right?

00:08:21,167 --> 00:08:26,497
I mean, on one hand this was an idyllic time of innocence, when we had parallel ports

00:08:26,497 --> 00:08:31,278
and we would just plug whatever the hell we wanted into them, but it does limit you.

00:08:31,278 --> 00:08:35,957
You couldn't have more complicated protocols, there were speed reasons,

00:08:35,957 --> 00:08:41,652
you could only have one parallel port whereas now I think my computer has like, 18,000 USB ports.

00:08:41,652 --> 00:08:46,640
So, we had USB and eventually  those parallel ports started disappearing.

00:08:47,840 --> 00:08:55,520
So that was, I think, basically up to the year 2000. So, 2001/2002, about till then

00:08:55,520 --> 00:09:08,012
people were still doing parallel port stuff and then around 2002 or three-ish or so,

00:09:08,012 --> 00:09:15,120
this microcontroller chip came out and this is the 16F84 and in my opinion,  

00:09:15,120 --> 00:09:19,501
this chip is as important as like the 68,000 or something, Motorola chip.

00:09:19,501 --> 00:09:25,276
I mean those are important chips too, don't get me wrong or the 386, but this chip was really cool.

00:09:25,276 --> 00:09:34,397
now it only had you know 1024 words of program memory, so basically a kilobyte of memory, 68 bytes of RAM,

00:09:34,397 --> 00:09:38,300
you only had 35 instructions to learn. You would code this in assembly.

00:09:38,300 --> 00:09:43,380
Right there, at the time you weren't even coding it in C, although people did write compilers later for it

00:09:43,380 --> 00:09:51,106
but what was cool about it was the enhanced (look, it's enhanced) flash microcontroller.

00:09:51,106 --> 00:09:56,623
Okay, why? Because up to that point all microcontrollers that you would get,

00:09:56,623 --> 00:10:02,245
little devices that could toggle pins up and down like those parallel ports but you would program,

00:10:02,245 --> 00:10:11,600
came with a EEPROM memory like this, with a glass or a crystal window in it and this is a big ceramic chip

00:10:11,600 --> 00:10:17,821
and these would cost like 20 bucks or so, $10/$20  and you would have to use a UV eraser

00:10:17,821 --> 00:10:22,424
and I actually still have, I think somewhere, my UV eraser.  This is a very fancy one.

00:10:22,424 --> 00:10:25,121
I like how it has a pull out drawer and everything.

00:10:25,121 --> 00:10:32,118
But the most important thing to note about the UV eraser is the erase time, okay? That's in minutes, not seconds.

00:10:32,118 --> 00:10:36,806
You'd be waiting 10/20 minutes sometimes to erase your flash and here's the thing,

00:10:36,806 --> 00:10:41,607
if you pulled your flash out too early from the eraser, not all of the bits would be erased

00:10:41,607 --> 00:10:46,808
and so when you try to reprogram it it would fail on verification and then you would have to erase it again

00:10:46,808 --> 00:10:50,535
so you just lost twice as much time, tragic.

00:10:50,535 --> 00:10:57,593
But the nice thing about this, the PIC16F84 shown here, on the first microcontroller board I used,

00:10:57,593 --> 00:11:04,209
was that it did not have that glass window or crystal window  because you could actually program it in situ.

00:11:04,209 --> 00:11:13,993
It would erase itself instantaneously in a second or two and so you could (amazing) program it and then reprogram it within a minute or two

00:11:13,993 --> 00:11:23,178
you just have to recompile it and then connect whatever program or dongle you had and you could program it again, so this is amazing! 

00:11:23,680 --> 00:11:28,597
In fact, at the time, you could program these chips  through a parallel port.

00:11:28,597 --> 00:11:33,296
That's kind of combining the joy of parallel ports with the joy of microcontrollers.

00:11:33,296 --> 00:11:42,640
It's one of the first board designs I ever did, featuring the ATtiny2313, also a very early enhanced flash microcontroller  

00:11:42,640 --> 00:11:50,838
but this one with a slightly more risky (instead of siskie) instruction set. You can see that there's this parallel port on the side

00:11:50,838 --> 00:11:57,772
you would literally jam that into the back of your computer and then run the command line program to 

00:11:57,772 --> 00:12:04,221
program it with your compiled micro bit code and then this would flash the LEDs, this was a little LED flasher thing,

00:12:04,221 --> 00:12:10,960
it would flash the LEDs back and forth and you could make patterns with it. This is what we had for entertainment back in those days  

00:12:12,991 --> 00:12:21,108
but again there's this USB. We love this parallel port but eventually the parallel port went away

00:12:21,108 --> 00:12:31,585
and one of the side effects was that, about 2005 because there was so much USB going around, this is sort of where Arduino came up.

00:12:31,585 --> 00:12:37,959
Arduino is kind of a combination of these two things. This is a much later Arduino but the first one looked similar 

00:12:37,959 --> 00:12:44,756
but if you look down here, enhanced flash microcontroller can be reprogrammed without a UV eraser 

00:12:44,756 --> 00:12:52,880
and it has a USB port, big chunky printer port USB, so like the B- type  

00:12:52,880 --> 00:13:03,069
and then a USB to Serial converter this would take USB data and convert it to a friendly RX and TD data in/data out signal.

00:13:03,069 --> 00:13:11,594
And you would plug it into your computer using a USB cable, one of these new amazing protocols for your computer,

00:13:11,594 --> 00:13:16,007
you would run the ID and you'd program it and I'm sure almost everyone watching this

00:13:16,007 --> 00:13:21,083
has programmed an Arduino using the IDE or a similar ID. It's really common.

00:13:21,083 --> 00:13:29,374
I mean this has been now 15 years in the making non-stop. It's kind of the standard for electronics.  

00:13:30,160 --> 00:13:39,464
And so, there's just a lovely diagram I made 20 years ago but basically, data is moving back and forth between the computer and the Arduino

00:13:39,464 --> 00:13:46,616
and you can send and receive data as ASCII, just like a terminal basically, data coming back and forth.

00:13:46,616 --> 00:13:56,536
And so, let's say you want to measure the temperature in your home. There's a talk later I saw about measuring stuff in your home and automating it. 

00:13:56,536 --> 00:14:03,690
so um you would get a temperature sensor, I even have one here, this is a TMP36

00:14:03,690 --> 00:14:09,774
although there's many others, this is a very simple, easy to use analog temperature sensor.

00:14:10,000 --> 00:14:17,196
You give it some voltage on the leftmost pin, on the right hand pin you connect ground and an analog voltage comes out.

00:14:17,196 --> 00:14:22,895
You do a little bit of math on the analog voltage and you can get the temperature. Amazing, right?

00:14:22,895 --> 00:14:29,422
So, this is one of the earlier Arduinos, the Diecimila

00:14:29,422 --> 00:14:33,773
you wire it up, there's an analog input and then you would open up the IDE

00:14:33,773 --> 00:14:40,000
or this special software that would that was written in Java that would run on Mac, Windows or Linux

00:14:40,000 --> 00:14:45,029
this is the code you would put in, it's C code with some macros called "Arduino-ese"

00:14:45,029 --> 00:14:51,582
In my opinion it's basically just C with some macro help and you can see in the setup you...

00:14:51,582 --> 00:14:53,345
I don't know, maybe the text's a little small but

00:14:53,345 --> 00:15:00,560
you set up your serial port, you do an analog read, you multiply the voltage around just to get it into the right format  

00:15:00,560 --> 00:15:06,560
and convert it to centigrade and then you print it out to the serial port.

00:15:07,520 --> 00:15:11,864
and then if you open up the serial port with the terminal software -

00:15:11,864 --> 00:15:17,188
Minicom works, ZTerm works, whatever you want really, would work -

00:15:17,188 --> 00:15:25,840
you will get something like this tells you, "okay, I read this analog voltage and this is the temperature. It's about 80 degrees, at the time." 

00:15:25,840 --> 00:15:30,523
and then let's say you wanted to connect this to your computer. Let's say you want to read the temperature

00:15:30,523 --> 00:15:35,556
and then actually like data log it or something or maybe you want your computer to send you an email

00:15:35,556 --> 00:15:41,799
when the temperature gets too high or too low, maybe you're brewing beer or you're you're monitoring your greenhouse, what have you.

00:15:41,799 --> 00:15:50,980
You could run some python code, this is a different project but it kind of was the only file I could quickly find on my computer

00:15:50,980 --> 00:15:56,027
and this is in Python 2. You use the Python serial library,

00:15:56,027 --> 00:16:03,116
you open up the serial port - COM1/dev/ttyUSB0 what have you,

00:16:03,116 --> 00:16:13,854
you read the bytes in, you parse them and then now you have  that data that's been transmitted from the Arduino. 

00:16:13,854 --> 00:16:17,296
Data has been transmitted to your computer and then your computer can act on it.

00:16:17,296 --> 00:16:22,102
So, the Arduino can run on its own but if you want to have that data show up on your computer

00:16:22,102 --> 00:16:28,336
you have to, sort of, transmit it and then do this parsing thing where you convert the data

00:16:28,336 --> 00:16:33,604
from the serial port into a floating point number or what have you.

00:16:33,604 --> 00:16:39,592
This was great. So people did this for basically forever, they're still doing, it it's been 15 years

00:16:39,592 --> 00:16:50,196
and what's nice about this is the write, compile, upload, debug loop is quite smaller than it used to be.

00:16:50,196 --> 00:16:55,674
One thing that's nice about this is that it's only about two to three minutes between

00:16:55,674 --> 00:17:00,317
I'm writing code, I'm compiling it, I'm uploading it and I'm testing it and

00:17:00,317 --> 00:17:07,244
one thing that I've definitely learned as I've written more and more code is the shorter you can make that loop the better it is

00:17:07,244 --> 00:17:14,457
because you can learn from your mistakes faster, you can debug faster, your whole life is just better, you can get up and stretch more.

00:17:14,457 --> 00:17:21,360
Overall, I think it's a really good positive  thing and compared to EEPROM based programming

00:17:21,920 --> 00:17:27,672
this is so much superior that it caused this explosion in Arduinos and that's why Arduino basically took over

00:17:27,672 --> 00:17:32,658
it was such a superior way of programming.

00:17:32,658 --> 00:17:40,579
So, everyone's like really happy and then, about 2012, the Raspberry Pi came out, right?

00:17:40,579 --> 00:17:47,200
and everybody remembers they first heard about this thing and it's like "What is this? It's a single board Linux computer, what is that?"

00:17:47,200 --> 00:17:50,749
It's like a little thing, I have one here. This is a Pi 4.

00:17:50,749 --> 00:17:56,631
Credit card sized computer about 40 bucks that can run Linux. It runs Debian or a fork of Debian.

00:17:56,631 --> 00:18:01,867
This is one of the original ones. Not the very first but an early early one.

00:18:01,867 --> 00:18:05,431
It's kind of like a younger sister of the ones that most people have these days

00:18:05,431 --> 00:18:12,560
but I like how it has an RCA jack, it's so cool, as well as HDMI, two USB ports and Ethernet.

00:18:12,560 --> 00:18:16,015
And I wanna say this is not the first single board computer right? At all.

00:18:16,015 --> 00:18:24,510
there was the Chumby board which even had GPIO. It's a Freescale processor, it had multiple USB ports,

00:18:24,510 --> 00:18:31,509
audio, ran off of five volts, has a jaunty little ram chip over here. Quite cute.

00:18:31,509 --> 00:18:36,620
Even had, if you look here, this is a VGA output connector so you could connect it to,

00:18:36,620 --> 00:18:40,240
not necessarily VGA but a TFT display so it even had TFT built in.

00:18:41,360 --> 00:18:48,947
There's also the long history of PC/104 boards, right? These plug-and-play kind of stackable computer thingies. 

00:18:48,947 --> 00:18:55,420
If you've never had to use this, that's really awesome. Congratulate yourself, they were kind of a nightmare.

00:18:55,420 --> 00:19:02,731
I did once get one working and it took me like three weeks and then I was just like "What am I doing?" and I went and did something else.

00:19:03,040 --> 00:19:11,874
There's also the BeagleBone and the BeagleBoard. Also came before the Raspberry Pi. All kind of coming out around 2010, right?

00:19:11,874 --> 00:19:19,457
And the thing about the Raspberry Pi single board computer and why it won is basically, it was just 40 bucks.

00:19:19,457 --> 00:19:24,670
Nobody could compete with the price and the simplicity of it

00:19:24,670 --> 00:19:32,949
and that's kind of important because as we talk about why things happened, it's basically two things simplicity and price.

00:19:33,570 --> 00:19:43,099
Power is not that important, it's capabilities,  as long as you fulfilled the simplicity and price prerequisites.

00:19:43,099 --> 00:19:48,558
but given that, it was really sweet that the Raspberry Pi had Ethernet, I think that was also a big thing,

00:19:48,558 --> 00:19:53,124
and USB. You could plug in a USB Wi-Fi dongle, you could connect to the internet

00:19:53,124 --> 00:19:56,080
You could do internet projects very easily and very cheaply.

00:19:56,800 --> 00:19:59,870
In fact, chances are you probably have  a Raspberry Pi at home.

00:19:59,870 --> 00:20:04,531
It's running a home assistant or maybe it's running Pi-hole

00:20:04,531 --> 00:20:12,291
or you've got it doing some data logging thing for you or it's emulating video games that you play with your kids.

00:20:12,291 --> 00:20:16,476
Very popular, because they're five to thirty five dollars.

00:20:16,476 --> 00:20:21,170
You can buy them at computer stores, you can buy them online, you can even get them on Amazon.

00:20:22,400 --> 00:20:25,920
So one thing that's kind of fun,  I love this fun fact. This is from liz  

00:20:26,480 --> 00:20:33,385
She's the co-founder of the Raspberry Pi foundation and the director of communications

00:20:33,385 --> 00:20:36,480
and some people said "Why is the Raspberry Pi called what it is?" and she's like

00:20:36,480 --> 00:20:41,983
"Well, Raspberry is kind of a pun on Apple but the Pi stands for Python"

00:20:41,983 --> 00:20:50,732
and it was interesting to me that when the Raspberry Pi came out they basically said, the official language of the Raspberry Pi is Python

00:20:50,732 --> 00:20:57,093
and they have Scratch which is a beginner block-based programming language but they really pushed Python. 

00:20:57,093 --> 00:21:00,438
Python is like the way you were expected to program this.

00:21:00,438 --> 00:21:11,838
and given that you had a 700MHz ARM Cortex, A7 or whatever processor, it's totally reasonable to run python as your main language.

00:21:11,838 --> 00:21:18,498
Okay, now we want to rebuild that example that we had with the Arduino and the temperature sensor.

00:21:18,498 --> 00:21:25,018
We're going to use a different temperature sensor, this is an I2C temperature sensor so it uses digital data and analog.

00:21:25,018 --> 00:21:29,186
Why? Because the Raspberry Pi doesn't have an analog input that's one of the trade-offs that you get.

00:21:29,186 --> 00:21:36,696
It doesn't have as many peripherals as the Arduino does in some ways. It has digital and it has HDMI

00:21:36,696 --> 00:21:45,128
but it doesn't have analog and it doesn't really have PWM and a couple other things and one wire you can do but it's a little bit weird.

00:21:45,128 --> 00:21:52,975
so you you wire it up using the the pins on the on the side of the Raspberry Pi, these little guys here.

00:21:52,975 --> 00:21:56,040
You use little socket wires, you plug it in.

00:21:56,640 --> 00:22:03,903
We wrote a library and this library is in Python 2 and you can see all the Pythonisms

00:22:03,903 --> 00:22:10,868
and we use logger to log what's going on and we wrote a little helper library called Adafruit GPIO

00:22:10,868 --> 00:22:17,833
just to do a little bit of the I2C, SMBus, Octal stuff which is kind of a pain.

00:22:17,833 --> 00:22:24,775
But on the Raspberry Pi, you log in as a terminal, you run sudo apt -get update,

00:22:24,775 --> 00:22:31,466
you install python make sure you're running python and then you have to install RPi GPIO 

00:22:31,466 --> 00:22:40,031
and RPi GPIO is this library that does memory mapped noodling

00:22:40,031 --> 00:22:43,446
to basically let you get access  to the input and output.

00:22:43,446 --> 00:22:45,920
This is before llibgpiod.

00:22:45,920 --> 00:22:52,130
Maybe one day we will all live in a libgpiod land,  but pretty much everyone's memory mapping instead. 

00:22:53,760 --> 00:22:57,120
You also pip install the library. This is the example code. 

00:22:57,840 --> 00:23:02,902
It's pretty simple. There's a little helper function but mostly you import the library,

00:23:02,902 --> 00:23:08,400
you create the sensor, you start the sensor, you give a little print out and then you

00:23:08,400 --> 00:23:13,861
just read the sensor data and display  it and time sleep in between

00:23:13,861 --> 00:23:19,177
and oops, sorry right

00:23:19,177 --> 00:23:30,557
and that example comes with the library, you go into the example folder, you run Python simpletest and you get the temperature out.

00:23:30,557 --> 00:23:36,561
So now you have your temperature data but it's on your Raspberry Pi computer

00:23:36,561 --> 00:23:44,595
so if you again want to get this data off of this Raspberry Pi computer, you either have to use Ethernet or Wi-Fi and send it to some service

00:23:44,595 --> 00:23:51,821
or you can open up a socket and have another computer connect to it and somehow you have to transfer the data to somewhere else

00:23:51,821 --> 00:23:57,435
especially if you want it on like your desktop computer but you do have that internet capability.

00:23:57,435 --> 00:24:01,149
And what's really cool about python and  I'd kind of been writing python before

00:24:01,149 --> 00:24:05,880
but I never really got into it that much until the Raspberry Pi, is that it's even faster, right?

00:24:05,880 --> 00:24:12,880
so you went from a 15/20 minute per program cycle to Arduino, where you're using a C compiler to

00:24:12,880 --> 00:24:19,793
write, compile, upload, execute, debug loop of about two/three/four minutes

00:24:19,793 --> 00:24:24,563
and now we have like an interpreted language that's basically instantaneous.

00:24:24,563 --> 00:24:30,152
You're running and saving code and rerunning it in like under five or ten seconds because

00:24:30,152 --> 00:24:35,070
it's loading instantly into memory there's no compilation step.

00:24:35,070 --> 00:24:41,687
And that's really powerful because when we're moving from compiled to interpreted

00:24:41,687 --> 00:24:45,843
we get a lot of benefits, although of course there's some downsides.

00:24:45,843 --> 00:24:52,523
So, let's go back into microcontroller land because we've just been talking about microcomputers, right?

00:24:52,523 --> 00:24:58,723
This is a computer. It's not a microcontroller it's running a full operating system, Linux. I don't know if you've heard of it.

00:24:58,723 --> 00:25:03,196
And you're doing things in the file system and you're installing software and you're running pip

00:25:03,196 --> 00:25:07,724
and you've got a shell and all that good stuff but when we're talking about microcontrollers

00:25:07,724 --> 00:25:13,179
like say, this Pico, it does not run an operating system, right?

00:25:13,179 --> 00:25:17,945
When you compile to this your code is running directly on the bare metal

00:25:17,945 --> 00:25:25,211
which is kind of cool because you have full control over the chip but it also means you have to take care of the whole chip on your own.

00:25:26,668 --> 00:25:31,818
About the same time that the Raspberry Pi was coming out folks were saying "Well the Arduino is cool

00:25:31,818 --> 00:25:38,609
but this is 700MHz and it runs software really fast and that's kind of cool and I can do a lot more things with it"

00:25:38,609 --> 00:25:48,213
and Arduino had come out with the Due and personally, I'm not a huge fan of the Due because it had some weird bugs in it that drove me a little crazy

00:25:48,213 --> 00:25:57,702
but one thing that was neat about the Due is, it was like just as we had moved from UVE prompt chips to "enhanced" flash chips

00:25:57,702 --> 00:26:02,593
we are now moving to a next generation of high performance,

00:26:02,593 --> 00:26:06,568
although I'm sure if you watch this 10 years from now, you'll think of this as a rinky dink chip,

00:26:06,568 --> 00:26:10,953
at the time, this was and still is, a fairly high performance chip.

00:26:10,953 --> 00:26:18,492
It's a 32-bit ARM Cortex, so it's 32-bit  not 8-bit so it can process data much faster,

00:26:18,492 --> 00:26:30,377
it's running at 84MHz compared to an Arduino running at 16, it has a grand total of half a MB of flash up to 100 KB of SRAM.

00:26:30,377 --> 00:26:40,749
Look, obviously this is not a ton but it's easily an order or two magnitude more than the original Arduino that we were talking about in 2005 

00:26:40,749 --> 00:26:50,946
or even the enhanced flash PIC16f84  from back in 2000/2001.

00:26:50,946 --> 00:26:56,127
So this is the chip that was used in the Arduino, so if you look at the slides you can compare between the two.

00:26:56,127 --> 00:27:03,699
I mean, they're totally different processes, totally different generations. It's not fair to compare them, this one came a decade before.

00:27:03,699 --> 00:27:10,937
but now we're talking about chips that are kind of getting to your old 286 or 386 speed, right?

00:27:10,937 --> 00:27:20,764
even a turbo button here, which is pretty much why I picked this image, right? Think about your 486 or 386 running at 66MHz, well this is running at 84

00:27:20,764 --> 00:27:25,549
and it doesn't have as much RAM because it doesn't have to run a whole operating system but

00:27:25,549 --> 00:27:32,820
it is a 32-bit processor and it's running quite fast and so when you have extra cycles, you can spend them in different ways

00:27:32,820 --> 00:27:38,880
so instead of running code where you're literally just  controlling every single command as it's executed ,

00:27:39,920 --> 00:27:47,678
people started using real-time operating systems. Now, FreeRTOS did not get invented around now, this is actually from 2000 also

00:27:47,678 --> 00:27:53,552
and they were meant to be used on microcomputers however people started using them on microcontrollers

00:27:53,552 --> 00:28:00,300
because you had enough memory and enough Flash that you had overhead available to run a real-time operating system.

00:28:00,786 --> 00:28:12,257
and so in 2012 to 2014 there was this amazing cambrian explosion of interpreted languages running on microcontrollers 

00:28:12,257 --> 00:28:19,469
and Idon't exactly know why other than, i imagine, the chips just got powerful enough and cheap enough 

00:28:19,469 --> 00:28:21,398
and everyone sort of started seeing...

00:28:21,398 --> 00:28:29,944
it's also like when somebody beats a 500 meter sprint, the first person to like get it under like a minute or whatever,

00:28:29,944 --> 00:28:37,160
then everybody else is like, "Whoa! If that's possible, I can do it too" and then the world record starts dropping even more right?

00:28:37,160 --> 00:28:44,748
I don't know that this is the first one, there's probably  other embedded interpreted languages boards that came before it

00:28:44,748 --> 00:28:49,709
but the Espruino was pretty early so this is 2012.

00:28:49,709 --> 00:28:54,560
I also don't know why these boards came in these kind of  funky rectangular shapes but I'm digging it.

00:28:54,560 --> 00:29:02,905
This board is by Gordon Williams who also headed this project.  I'm sure there's other people as well.

00:29:02,905 --> 00:29:10,257
and this board is running on a microcontroller that's an STM32F1. Lovely series of chips.

00:29:10,257 --> 00:29:18,337
Again, 256 to 512k of Flash, 32-bit, 72 MHz, right? It's this kind of class of microcontroller

00:29:18,337 --> 00:29:25,515
and it's fast enough that you can run JavaScript on it and it's not a full implementation of JavaScript

00:29:25,515 --> 00:29:31,635
but it's enough that you can sort of have the JavaScript feeling and you can script your microcontroller.

00:29:31,635 --> 00:29:35,278
I'm sure that Gordon has awesome talks and presentations

00:29:35,278 --> 00:29:40,000
so if you want more detail about the implementation I'd check the website for Espurino

00:29:40,590 --> 00:29:45,040
but this is sort of what it looks like. He has a really cool IDE that runs in the browser.  

00:29:45,040 --> 00:29:52,073
You're now running code that is interpreted. This is not compiled and when you run it, you click execute 

00:29:52,073 --> 00:30:01,745
and it uploads to the board and again instead of that  three to four minute compile, upload, verify, run, debug loop,

00:30:01,745 --> 00:30:08,538
it's shrunk down to the speed of Python on the Raspberry Pi. It's like seconds, basically. Five to ten seconds.

00:30:08,538 --> 00:30:15,440
There was also the Tessel which I thought was really cool because this is a really high powered microcontroller  

00:30:15,440 --> 00:30:21,127
but it is a microcontroller with a lot of RAM and a lot of Flash and they did like a very large subset

00:30:21,127 --> 00:30:27,617
of javascript running on a microcontroller, even had Wi-Fi, had all these expansion ports.

00:30:27,617 --> 00:30:37,630
This is the Tessel team. I just love the exuberant positivity of this team. They're smiling so so wide. They love their hardware so much.

00:30:37,630 --> 00:30:44,581
They're using a LPC1830. You'll see definitely these are all ARM Cortex chips

00:30:44,581 --> 00:30:51,349
ARM just did a really good job getting low cost, high power microcontrollers out to people around this time.

00:30:51,349 --> 00:30:58,549
this is an -M3 running at 180MHz with 200k of SRAM but even put more SRAM on it

00:30:58,549 --> 00:31:05,652
and similarly you run JavaScript on it and in  your command line you even tell it what to do

00:31:05,652 --> 00:31:12,176
but yeah, it's basically JavaScript running on a chip that can also connect to the internet and download stuff.

00:31:12,176 --> 00:31:25,054
And then of course there's MicroPython this is the photo we found of the Pi Board. v 1.1. There's probably a v 1.0 before then. Also running on an STM32F405. 

00:31:25,054 --> 00:31:31,120
This is by Damien George who has been doing  so much with MicroPython and recently completed  

00:31:31,120 --> 00:31:36,239
the Pico port for MicroPython. Congratulations on that release this week.

00:31:36,239 --> 00:31:42,401
But he sort of looked at these JavaScript boards, I'm assuming, and said, "I want to do the same thing for Python"

00:31:42,401 --> 00:31:46,960
and the cool thing is he didn't know that it wasn't possible,  so he did it and it turns out it WAS possible.  

00:31:46,960 --> 00:31:54,500
A miniaturized version of Python 3, running  on a microcontroller and you get Python code

00:31:54,500 --> 00:32:03,694
and you're running Python 3 code but it's running on a microcontroller to blink an LED. This is the first example that you run for blinking an LED.

00:32:03,694 --> 00:32:11,161
and it really kicked off because and I'm not saying that people don't  run Espurino or even Tessel those are still alive but

00:32:11,161 --> 00:32:21,648
again, it was the price and the simplicity of it that I think made MicroPython really branch out and cover the world

00:32:21,648 --> 00:32:29,723
because when they did a Kickstarter, I think a year or two after the Pi-board came out or maybe a year afterwards

00:32:31,047 --> 00:32:40,832
The Kickstarter was to port it to the ESP8266 a you know basically a one to two dollar, Wi-Fi enabled microcontroller that's a Tensilica chip

00:32:40,832 --> 00:32:47,007
and again, just fast enough and just barely good enough to run MicroPython and was a huge success

00:32:47,007 --> 00:32:51,032
and we promoted it and we did some tutorials for it and it was awesome.

00:32:51,032 --> 00:33:00,109
In fact, if you look, you probably have this badge, which is running the next generation, the ESP32, the next generation chip

00:33:00,109 --> 00:33:05,257
and it's also running MicroPython on this Wi-Fi enabled microcontroller all on your badge which is like super neat

00:33:05,257 --> 00:33:11,228
It even has two screens. Why two screen? I don't know but why not, right?

00:33:11,228 --> 00:33:18,160
and you can program it from the command line, you can get files from Wi-Fi and save them to the file system. 

00:33:18,160 --> 00:33:27,447
people have done such cool stuff with this because it's so easy. It's so fast to get started and going because of that very short iteration loop of

00:33:27,447 --> 00:33:31,334
you don't compile, you don't upload. You just write and execute, write and execute.

00:33:32,080 --> 00:33:39,242
Okay so, let's talk about business and disruption and having fun

00:33:39,242 --> 00:33:47,360
because I think that this is something that engineers, they know it but they don't realize it. 

00:33:47,360 --> 00:33:54,732
If you go to business school, you get an MBA or something, you're gonna read Clayton Christensen's book 'The Innovator's Dilemma'

00:33:54,732 --> 00:34:01,200
and it's actually kind of a funny book, I mean, it's a good book overall but it's really funny because it's about hard drives  

00:34:01,200 --> 00:34:07,600
and they talk about like these massive hard drives  but they end before SSD or Flash memory comes up  

00:34:07,600 --> 00:34:15,013
so like they don't even realize that the Innovator's Dilemma is going to be like innovated 15 times over by the time you read it

00:34:15,013 --> 00:34:20,296
but anyways, you should read it because it is a good book but basically it says "Look, it doesn't matter

00:34:20,296 --> 00:34:29,200
if there's something that has a wide market, as long as there's something that's cheaper and does enough stuff - that it's interesting and gets adopted.

00:34:29,200 --> 00:34:36,726
Especially if it's less expensive and it's easier to use and performance isn't as important.

00:34:36,726 --> 00:34:45,978
So, as these disk drives in this book were being created, they went from super huge to

00:34:45,978 --> 00:34:53,055
smaller and smaller and smaller and they weren't as good but it didn't matter because the price and size was improved

00:34:53,055 --> 00:35:00,000
and so if you look at something like the Arduino what was actually innovative about it was not the hardware.

00:35:00,000 --> 00:35:05,680
I mean, the hardware was wonderful, it's great, don't get me wrong, it's perfect but the thing is how easy it was to use comparatively.  

00:35:05,680 --> 00:35:11,082
You've got this IDE and you open it up and you can pretty much just get started writing immediately 

00:35:11,082 --> 00:35:17,354
so if you want to make like these cool LED goggles, for example, we have an Arduino kit for it.

00:35:17,354 --> 00:35:22,630
This is something that would be really hard to do without Arduino because it's something that cosplayers and beginners want  to do.

00:35:22,630 --> 00:35:26,638
They don't want to have an engineering degree, they just want to get started.

00:35:26,638 --> 00:35:33,050
Or this LED tiara. Actually kind of a popular project. A lot of kids want to build their own LED glowing Tiara

00:35:33,050 --> 00:35:40,199
they do not want to go to school and study stacks and heaps and compiler design and the dragon book and all that stuff,

00:35:40,199 --> 00:35:46,185
they just want to get into having fun, right? That's the thing. It's about having fun with electronics.

00:35:46,185 --> 00:35:53,744
And before there was Arduino, the Arduino was very disruptive because, beforehand it was just like a yak shaving nightmare

00:35:53,744 --> 00:36:00,318
and it still is, right? So, if you're wanting to write code on the Raw Atmel chip that's on the Arduino,

00:36:00,318 --> 00:36:06,099
you download Atmel studio and it's in VS code. Don't get me wrong, it's wonderful.

00:36:06,099 --> 00:36:13,601
There's just too many damn buttons and there's too many file menus and there's like so many tabs, even I don't like using it

00:36:13,601 --> 00:36:17,649
and also it's not even available for Linux, even if you want it to, it's only for Windows.

00:36:17,649 --> 00:36:23,010
and then let's say you want to change chips you want to now run something on a MSP430.

00:36:23,010 --> 00:36:30,178
Okay, well you're gonna have to go into a totally different IDE, Code Composer Studio, for the official way of programming it from TI.

00:36:30,178 --> 00:36:32,444
NXP? They also have their own ID.

00:36:32,444 --> 00:36:38,828
Thankfully they have them available for all operating systems  but it just means that you're suffering in three different operating systems.

00:36:38,828 --> 00:36:41,788
I don't know if that's a really better way of doing it.

00:36:42,800 --> 00:36:46,308
And of course you can always use Eclipse and now there's PlatformIO

00:36:46,308 --> 00:36:51,320
and these are all good too, but I would not call them super fun,

00:36:51,320 --> 00:36:54,521
they're very powerful but I wouldn't call this fun

00:36:54,521 --> 00:36:58,929
you're happy when you're done but you're not enjoying the process

00:36:58,929 --> 00:37:03,782
and I say that as someone who writes five to ten hours of code a day.

00:37:04,480 --> 00:37:10,853
This is fun, right? Like apple basic is fun. You're just getting in there and you're just doing it 

00:37:10,853 --> 00:37:17,461
and people they say "Well, you know, back in the day kids were able to program computers

00:37:17,461 --> 00:37:20,295
and all they had was schematics and you had to do assembly and peak and poke."

00:37:20,295 --> 00:37:22,824
and I'm like, "Yeah, but they didn't have to deal with Eclipse, right?"

00:37:22,824 --> 00:37:31,530
and if you take that away then maybe it is easier. Maybe it's the tool chain. Maybe it's a tool system, not the actual programming that's complicated

00:37:31,530 --> 00:37:39,118
So, this is a a sort of a blurb from a Paul Graham essay from 2001

00:37:39,118 --> 00:37:43,998
and i can't remember the name of it off top of my head but maybe you can google for the first sentence and you'll find it.

00:37:43,998 --> 00:37:49,852
And I read this in 2001, when I was graduating from school and it's an article about LISP

00:37:49,852 --> 00:37:56,973
and he said the reason that his company was successful was because they wrote their entire application in LISP or a LISP variant 

00:37:56,973 --> 00:38:03,666
and not in whatever, C or C++, language other people are writing web code in

00:38:03,666 --> 00:38:09,873
and he said the reason is that "we chose the highest level language possible"

00:38:09,873 --> 00:38:15,952
and he says obviously we don't write software for computers and machine code,

00:38:15,952 --> 00:38:24,932
although at the time people were writing assembler for microcontrollers because that 16F84 basically didn't come with a compiler or a free compiler to start.

00:38:24,932 --> 00:38:31,054
He said, "you should always, if there's no other comparison..." of course he goes into performance and APIs and whatever

00:38:31,054 --> 00:38:36,499
"...but all things being equal pick the highest level language you can" and why?

00:38:36,499 --> 00:38:46,438
Because if you look at the studies, this one is compiled studies of how long it takes to solve a string parsing problem,

00:38:46,438 --> 00:38:51,452
you see here Perl and Python are at the top, C++, Java and C are at the bottom

00:38:51,452 --> 00:38:57,973
and it's not necessarily the code. It's not the language itself, right?

00:38:57,973 --> 00:39:04,227
They all have for loops and if statements and all that good stuff and you print strings and you have to format them, 

00:39:04,227 --> 00:39:08,176
it's that the number of lines of code  you write are smaller.

00:39:08,176 --> 00:39:11,355
The smaller the amount of code and the faster your development loop,

00:39:11,355 --> 00:39:15,680
I believe that's those are the core elements to making it easy to code

00:39:15,680 --> 00:39:18,400
because the number of lines you're coding is about the same per hour.

00:39:19,280 --> 00:39:25,600
And what I really like about MicroPython  and CircuitPython which we'll talk about, 

00:39:25,600 --> 00:39:31,649
is that there's no tool chain at all. Actually it just deletes the tool chain completely.

00:39:31,649 --> 00:39:37,619
Once you've installed circuit python or micro python  you edit a code.pi file for example here

00:39:37,619 --> 00:39:40,731
and then if you have images or audio, like in this project,

00:39:40,731 --> 00:39:45,087
I have a little thing that goes on the internet and finds out how many GitHub stars we have,

00:39:45,087 --> 00:39:50,581
displays the image and plays a coin sound every time we get a new star, so please star our repos.

00:39:50,581 --> 00:39:59,145
It all lives on the disk drive. A little bit reminiscent for me of ResEdit for those who who liked ResEdit hacking when they were kids.

00:39:59,600 --> 00:40:03,614
And then of course there's Chromebooks, where you can't even install an IDE if you wanted to, right?

00:40:03,614 --> 00:40:07,840
So you you have to get rid of the tool chain and getting rid of the tool chain  

00:40:07,840 --> 00:40:13,352
and being able to delete all the Code Composer Studio and Atmel Studios has just been glorious

00:40:13,352 --> 00:40:17,170
because they're just so complicated and so frustrating to use.

00:40:17,760 --> 00:40:21,840
Another nice thing I like about Python  is don't have to deal with pointers.  

00:40:21,840 --> 00:40:25,720
You don't have stacks and heaps, you don't have string parsing problems.

00:40:25,720 --> 00:40:30,008
you don't have a lot of bullshit that you get with C or C++.

00:40:30,008 --> 00:40:38,775
Again, I write five to ten hours of C++ a day so I know this. I use this application, I write this kind of code. I still hate it.  

00:40:38,775 --> 00:40:46,246
Even if it's efficient, it's just it's so scary to write compared to Python where if you divide by zero

00:40:46,246 --> 00:40:50,040
you don't get a hard fault and your entire microcontroller just stops working,

00:40:50,040 --> 00:40:57,410
instead you get a Python Interpreter that tells you, "Hey, on this line, dear sir, you made a mistake. Please fix."

00:40:58,880 --> 00:41:03,120
The only thing I would like is instead of white space, I wish there was brackets.

00:41:03,120 --> 00:41:08,240
I'm going to bring this up at the next Python Software Foundation meeting and hopefully I can convince them

00:41:08,240 --> 00:41:11,600
to get rid of white space and use brackets and semicolons instead.

00:41:12,400 --> 00:41:15,697
Okay, so how does CircuitPython fit into this?

00:41:15,697 --> 00:41:19,917
And in case you're wondering like what the hell does this have to do with Linux, we're getting there.

00:41:19,917 --> 00:41:29,243
So around, let's see, 2015 I think, is when the micro:bit came out. Arduino killer.

00:41:29,243 --> 00:41:34,251
But what I really liked, it wasn't Arduino shaped. Thank god, right? They actually kind of went in a totally different direction.

00:41:34,251 --> 00:41:41,789
The idea was low-cost microcontroller for kids. The cheapest possible thing to get people started with programming

00:41:41,789 --> 00:41:45,713
that had these LEDs on the front and buttons and chances are, again, you have one of these

00:41:45,713 --> 00:41:48,367
because everyone seems to have one of these.

00:41:48,367 --> 00:41:55,482
And this is on the back and the reason that this was to me really amazing and inspiring is

00:41:55,482 --> 00:41:57,963
that chip on the back, this one right here.

00:41:57,963 --> 00:42:06,894
So, this chip the NRF51822, I was familiar with this chip. This chip totally sucks. [laughs] What do I mean?

00:42:06,894 --> 00:42:15,500
It is a 32-bit ARM Cortex chip but compared to the chips  that were being used for MicroPython

00:42:15,500 --> 00:42:19,473
Cause this came up a little bit after MicroPython and Espurino and the Tessel.

00:42:19,473 --> 00:42:25,280
If you remember, those were running at 72 MHz and they had 200k of RAM and they were just like these massive chips

00:42:25,920 --> 00:42:29,666
and this one was really dinky by comparison

00:42:29,666 --> 00:42:36,459
Even at the most expensive variant, you only got 32k of RAM and that's not very much.

00:42:36,459 --> 00:42:47,226
I mean it is compared to 16F84 with 68 bytes of RAM but it's still not very much especially if you want to do Bluetooth stuff as well

00:42:47,226 --> 00:42:53,730
and so that was really interesting to me because it was almost the same specifications as the SAMD21 chip.

00:42:54,240 --> 00:42:59,028
And you're like, "Okay." You're like, "why even keep track of what these chips are?"

00:42:59,028 --> 00:43:03,938
The reason that this chip is interesting, it was used in the latest Arduino that had just come out

00:43:03,938 --> 00:43:11,249
and this Arduino, which looks like the original Arduino Uno,  this was their next generation.

00:43:11,249 --> 00:43:17,719
It was the first ARM Core 32-bit microcontroller based Arduino

00:43:17,719 --> 00:43:24,734
and I was like, "Oh my god. It is technically possible that we could get MicroPython to run on this."

00:43:24,734 --> 00:43:29,067
The only reason that I didn't end up going with Espurino or JavaScript is because

00:43:29,067 --> 00:43:35,062
MicroPython was kind of the first thing to prove that it could run on something this underpowered

00:43:35,062 --> 00:43:38,592
compared to what the Tessel was running, for example

00:43:38,592 --> 00:43:42,715
because I looked at that and I was like, "Oh, well, obviously you could run JavaScript on a microcontroller"

00:43:42,715 --> 00:43:49,691
but what you're talking about there is a $99 board unlike something that was more closer again to $30.

00:43:50,720 --> 00:43:54,605
This is where Scott comes in. This is a photo of Scott with Blinka the mascot.

00:43:54,605 --> 00:44:02,159
We we made a gigantic puppet, we know there's a woman in New York who works on 'The Muppet Show'.

00:44:02,159 --> 00:44:08,244
Well, we can't say that. She works on a common puppeteering  show that folks are familiar with

00:44:08,244 --> 00:44:13,390
and we hired her to make a puppet. It's not a Muppet because that's trademarked.

00:44:13,390 --> 00:44:18,800
So, we sent him an email because we'd seen him on the Show and Tell and he was working with this chip a lot and  

00:44:18,800 --> 00:44:22,321
he started a hardware company and then realized  he didn't really want to do that anymore

00:44:22,321 --> 00:44:27,279
and so we emailed and we said, "Hey, we have this idea", right? He's like, "Okay, what do you want to do?"

00:44:27,279 --> 00:44:33,360
and we basically said, "Look, can you just port MicroPython to this new chip that the Arduino is using?"

00:44:33,360 --> 00:44:41,683
And why? Because if you have people who have these Arduinos already

00:44:41,683 --> 00:44:49,604
it's going to be a lot easier to overcome that activation energy and get them to use CircuitPython or MicroPython 

00:44:49,604 --> 00:44:52,476
because they already have something that's Arduino. It's not as scary, right?

00:44:52,476 --> 00:44:57,886
Whereas, a lot of these boards - this is a much later photo -

00:44:57,886 --> 00:45:04,271
but when this first came out, the Tessel and Espruino and Pi board you had to have specialized hardware to do it

00:45:04,271 --> 00:45:06,470
whereas now it was more generic.

00:45:06,470 --> 00:45:10,551
So we actually started making hardware that could run MicroPython

00:45:10,771 --> 00:45:15,238
You could use Arduino or MicroPython and can go back and forth, it was kind of cool.

00:45:15,238 --> 00:45:20,640
And we started writing libraries. This is code that would let you use hardware

00:45:20,640 --> 00:45:29,243
and this is actually when I had a big change of heart because basically I looked at our GitHub repo 

00:45:29,243 --> 00:45:33,636
and this is... I took a screenshot today, you know,  1500 repositories

00:45:33,636 --> 00:45:38,942
but it was still like over a thousand at the time and I was like, oh my god. I can't.

00:45:38,942 --> 00:45:47,959
I can't have so many repositories. I have to be careful here because I have 400/500 Arduino libraries.

00:45:47,959 --> 00:45:53,215
this is the arduino library listing and it says 476 results for Adafruit

00:45:53,215 --> 00:45:59,865
and I was starting to have three libraries per... This temperature sensor that I talked about,

00:45:59,865 --> 00:46:04,864
I'd have one for Arduino I had one for Python, which was for the Raspberry Pi we mentioned,

00:46:04,864 --> 00:46:10,583
that would run in the command line and I would have one for MicroPython or CircuitPython

00:46:10,583 --> 00:46:18,322
and I really really did not want to have that 450 turn into an additional 450 and then another 450

00:46:18,322 --> 00:46:20,640
because my inbox is already toxic wasteland.

00:46:21,520 --> 00:46:27,251
And we had already written about 30 libraries of our most popular boards for Python.

00:46:27,251 --> 00:46:31,488
That's the Raspberry Pi - Python 2.7.

00:46:31,488 --> 00:46:39,016
And I realized I really wanted to combine at least the Python and MicroPython together

00:46:39,016 --> 00:46:43,081
and by the time we kind of got to this point - it was like a year or two later -

00:46:43,081 --> 00:46:48,297
Scott really wanted to have a unified interface and kind of came up with...

00:46:48,297 --> 00:46:51,971
These are not like the hard and fast rules. Rules are meant to be broken

00:46:51,971 --> 00:46:56,163
but we wanted to use mass storage for file management

00:46:56,163 --> 00:47:00,769
because using a command line tool was actually too complicated for some people

00:47:00,769 --> 00:47:05,782
and another thing is that if you had a Chromebook you might not be able to install command line tools at all.

00:47:05,782 --> 00:47:11,820
So mass storage is kind of the only universal interface for USB that every computer runs,

00:47:11,820 --> 00:47:16,124
Even serial ports aren't always easy to open on a Chromebook.

00:47:16,124 --> 00:47:25,020
we wanted to have a consistent API across all ports so any board that had CircuitPython, MicroPython

00:47:25,020 --> 00:47:31,234
that code would always run on each one and we wanted to make sure that it was a pure subset of CPython

00:47:31,234 --> 00:47:35,015
even if that meant that it was simpler and slower

00:47:35,015 --> 00:47:41,040
and that was so that we could have code that runs on Raspberry Pi or Microcontrollers - the same driver code.

00:47:42,800 --> 00:47:48,459
and this is when we actually decide to split the fork because this is something that we felt really strongly about because 

00:47:48,459 --> 00:47:52,896
I did not want to maintain another 1000 libraries and MicroPython folks were like

00:47:52,896 --> 00:47:59,452
well, we have our own direction and so we said okay, how about we fork it, we rename ourselves to CircuitPython -

00:47:59,452 --> 00:48:06,272
it's the same underlying Python code underneath but that API level is going to be a little bit different

00:48:06,272 --> 00:48:11,556
because these were really important to us. So for example, time.

00:48:11,556 --> 00:48:14,131
What time is it? I have about 15 minutes.

00:48:14,131 --> 00:48:22,038
So on CircuitPython on the top when you import time and you look at all the functions available in that module

00:48:22,038 --> 00:48:24,461
you see local time instruct and sleep.

00:48:24,461 --> 00:48:30,000
And then if i go down to my computer and I run Python3 and I import time and do the same thing, you'll see I have more stuff -

00:48:30,000 --> 00:48:35,094
I have process time, I have time zones, I have ASCII time, Alt zone -

00:48:35,094 --> 00:48:38,383
but everything in CircuitPython is a strict subset.

00:48:38,383 --> 00:48:44,720
There is no code that you should be able to run in CircuitPython that would not also run on Python 3.

00:48:45,680 --> 00:48:50,971
And that was really a good idea because by this point there was like a lot of Raspberry Pi computers

00:48:50,971 --> 00:48:56,360
because Raspberry Pi kept coming out with new ones. And this is 2018, it's even worse now. Right?

00:48:56,360 --> 00:49:00,800
It's not worse - better. There's even more amazing Raspberry Pi computers.

00:49:01,440 --> 00:49:11,382
and this is when there's like the teenage mutant... teenage ninja mutant turtles. Whatever. I can't say it anymore.

00:49:11,382 --> 00:49:19,562
And that was a really popular tv show and all the kids were watching it and so like all these other animation studios were like

00:49:19,562 --> 00:49:25,562
"Oh my god we need to have some sort of like, teenage amphibian like, fighting ninja show"

00:49:25,562 --> 00:49:29,545
and so there's like Battletoads and there's like Street Sharks

00:49:29,545 --> 00:49:32,802
and so that's just like the Battletoads zone of single board computers

00:49:32,802 --> 00:49:38,970
because Raspberry Pi was so successful that suddenly everybody that had chips was making single board computers.

00:49:38,970 --> 00:49:45,200
This is a Banana Pi, this is an Orange Pi. They have kind of... the fruit name's really popular.

00:49:45,200 --> 00:49:50,748
This is onion.io. They didn't go with the Pi, but it's still food based.

00:49:50,748 --> 00:49:58,699
You have ODROID and you've got Tinker Board, this is from ASUS. Basically, it's a jaunty angle here.

00:49:58,699 --> 00:50:02,080
You've got the NVIDIA - came out with their own - Jetson Nano.

00:50:02,720 --> 00:50:11,077
And this is just the categorizations on Wikipedia. There's like 54 categories, companies making single board computers

00:50:11,077 --> 00:50:16,305
and each one easily makes 10. I mean, there are hundreds and hundreds of single board computers

00:50:16,305 --> 00:50:21,980
and each one of them had slightly different ways to interface with the GPIO.

00:50:21,980 --> 00:50:29,200
They're all running Armbian or Debian, some were running Ubuntu but they're all kind of running mainline Linux. 

00:50:29,200 --> 00:50:36,575
But then if you actually wanted to twiddle those GPIO pins - the pins that would replace the parallel port - it's a little different

00:50:36,575 --> 00:50:47,766
and like, this one you can do through pip, this one you have to download this duxingkei33/orangepi and then set up install from inside of it.

00:50:47,766 --> 00:50:54,808
And I want to give credit to Periphery because among others they're one of the few libraries that tried really hard to say

00:50:54,808 --> 00:50:59,379
"Hey everybody! Let's have one standard for all of these hundreds of boards

00:50:59,379 --> 00:51:03,922
so people don't have to install a different package from some random ass GitHub repo"

00:51:03,922 --> 00:51:08,074
and we use periphery, actually. They're pretty cool.

00:51:08,074 --> 00:51:15,963
But then we have these other weird boards. We have the FT-232H. This is a device that you plug it into USB

00:51:15,963 --> 00:51:21,908
and it gives you GPIO connected to a computer,  so it's a bit banging USB device

00:51:21,908 --> 00:51:28,395
and you can use libusb with it and so you can connect it to your computer and then on your computer you run Python 3   

00:51:28,395 --> 00:51:33,200
and then you can blink LEDs for example. So you're running Python but not on a Raspberry Pi  

00:51:33,200 --> 00:51:38,200
and not on a microcontroller it's on your computer  and you're controlling hardware.

00:51:38,200 --> 00:51:47,449
So for example, EEPROM chip. You want to program this EEPROM chip, it's a 512K EEPROM. You can't fit that on an Arduino.

00:51:47,449 --> 00:51:54,360
 but if you have it on your file system it makes a lot more sense. It's quite easy to program it using a FTDI adapter.

00:51:54,360 --> 00:51:58,517
so we've got microcontrollers with low resources and lots of hardware,

00:51:58,517 --> 00:52:04,893
single board computers like the raspberry pi, medium resources and some hardware - like a lot but not everything,

00:52:04,893 --> 00:52:09,602
and then desktop computers which are like the most powerful they have access to everything, but low hardware

00:52:09,602 --> 00:52:17,211
and we wanted to make this all work together so why not come up with a new standard? Why not? Indeed.

00:52:17,211 --> 00:52:25,006
And so this is where Tux and Blinka: the Love Story begins, they become best friends. Hi! Wonderful graphics.

00:52:25,006 --> 00:52:31,405
So Binka started as CircuitPython running on the SAMD21, these microcontroller boards,

00:52:31,405 --> 00:52:37,316
but we wrote so many libraries that we decided, let's make a way for all of our libraries,

00:52:37,316 --> 00:52:42,400
for all these sensors and these LEDs and displays and motors to work with anybody.

00:52:42,400 --> 00:52:48,713
so we wrote Adafruit_Blinka, which is a way of using the hardware API from CircuitPython

00:52:48,713 --> 00:52:57,779
- which remember we defined as a strict subset of c python - so you could run all of these sensors and devices on any computer.

00:52:57,779 --> 00:53:01,261
So we started with the Raspberry Pi because of course, it's the most popular

00:53:01,261 --> 00:53:04,791
and it's actually interesting. You'd think, well how hard can it be?

00:53:04,791 --> 00:53:08,555
Actually turns out that there's like four different types of Raspberry Pi that you have to deal with.

00:53:08,555 --> 00:53:15,423
The compute modules have a lot of pins, the Rev1 and Rev2 have different pin outs and then the 40 pin is different

00:53:15,423 --> 00:53:22,560
so it turns out like even just dealing with one subset of the single board computer market is different.

00:53:23,360 --> 00:53:29,391
And then it's funny, as I was writing this  this issue came in - "How do I run this on nanopi?

00:53:29,391 --> 00:53:35,062
I want to run your Raspberry Pi projects on a nanopi which is a Pi clone."

00:53:35,062 --> 00:53:39,136
and it turns out, yeah. We have support for the nanopi too

00:53:39,136 --> 00:53:45,957
and we have support for computers using the FTDI converter chip as well.

00:53:45,957 --> 00:53:50,000
So if you go to circuitpython.org/blinka

00:53:50,000 --> 00:53:56,768
you will see that we have Banana Pis, BeagleBones, DragonBoards, ClockworkPis, JetsonNanos

00:53:56,768 --> 00:54:01,941
60 different boards altogether that  are supported with this library

00:54:01,941 --> 00:54:11,295
that let you do sensors, GPIO, PWM analog inputs all equivalently  with the same code over this entire family.

00:54:11,295 --> 00:54:14,477
And it's cool because we actually have people submitting new boards.

00:54:14,477 --> 00:54:24,758
Like a couple days ago somebody sent over a PR for the  LubenCat i.MX6ULL. What is it? I don't know but it's supported now.

00:54:24,758 --> 00:54:31,405
The Orange Pi Zero Plus Board, thanks twa127 and then we are also adding board support.

00:54:31,405 --> 00:54:38,041
Maker Melissa works on the team and she has been adding support for the NanoPi NEO. What is it? I don't know.

00:54:38,041 --> 00:54:45,600
I mean, I have these boards. There's just hundreds of them. They're super cute. These little Linux boards. 

00:54:45,600 --> 00:54:51,840
Some of them are only ten dollars or so some of them have Gigabit Ethernet. Whatever you want.  

00:54:53,600 --> 00:55:01,652
So the upshot is that once I had that fear of the "Oh my god. I'm gonna have three libraries per device" removed

00:55:01,652 --> 00:55:09,005
I was able to then actually go in and really start developing libraries and so we have 283 libraries so far.

00:55:09,005 --> 00:55:16,116
Some of them are hardware specific but about 250 of them i think are going to be generic  enough that run on everything

00:55:16,116 --> 00:55:24,160
and these are like OLED screens and sensors and NFC card readers and all that good stuff.

00:55:24,160 --> 00:55:29,396
Pretty much every every electronic device you'd  want leds, neopixels, all that.

00:55:29,396 --> 00:55:32,459
We also have community contributions which is awesome!

00:55:32,459 --> 00:55:36,668
I want to make sure... oh sorry. At the bottom right there's also people.

00:55:36,668 --> 00:55:43,194
There's a group of people from the community that help us manage PRs and issues and there's people who are submitting their own libraries.

00:55:43,194 --> 00:55:49,120
So there's a a library for the Mitutoyo Digimatic Caliper. I guess you can read data off of it.

00:55:49,920 --> 00:55:58,228
Or there's for DYNAMIXELs these are servos that  are used in high-end robotics. Somebody submitted a library that uses the standard API

00:55:58,228 --> 00:56:04,140
and it's cool we have a really powerful community of a lot of people who come in with different backgrounds.

00:56:04,140 --> 00:56:09,420
Some are really into linux, some are into microcontrollers, some are into ham radio. It's neat.

00:56:09,420 --> 00:56:15,291
What you're seeing, what people can do with this once they're free to move from chip to chip, from platform to platform,

00:56:15,291 --> 00:56:23,081
reducing that support burden but squeezing down that iteration loop. That's what's really important to me. 

00:56:23,081 --> 00:56:28,160
Okay, so there was this Thai restaurant and it closed a long long  time ago, it wasn't it wasn't like a COVID thing,

00:56:28,160 --> 00:56:32,358
but they had this dish called 'Duck three ways' and I loved it. It was like they had a duck

00:56:32,358 --> 00:56:36,115
and it was like some duck breasts and some good feet and then there was like some skin

00:56:36,115 --> 00:56:40,964
and I'm gonna do 'Duck three ways'. I'm not gonna do it live because I've learned my lesson not to...

00:56:40,964 --> 00:56:48,389
I don't want to stress out the organizers, but I did take screenshots of connecting to a temperature and humidity sensor three ways

00:56:48,389 --> 00:56:55,061
and showing how it's the same. So it's actually kind of boring. It's the same kind of duck. Quack! Or something.

00:56:55,061 --> 00:57:00,757
So let's start with the Pico. This just came out. This is a microcontroller from the Raspberry Pri Foundation.

00:57:00,757 --> 00:57:07,102
It's got an incredible, large amount of RAM. It's running at 200 MHz but it's actually only a Cortex-M0 chip.

00:57:07,102 --> 00:57:14,251
It's actually kind of designed specifically or it's optimized for running CircuitPython or MicroPython, which i think is awesome.  

00:57:14,560 --> 00:57:21,947
So you can download and install CircuitPython by dragging and dropping a file onto the chip which shows up as a disk drive

00:57:21,947 --> 00:57:31,760
and this morning I wired it up to this sensor which i have somewhere here on my desk - a AHT20 temperature and humidity reader.

00:57:32,960 --> 00:57:38,240
You wire up power, ground and then the two data lines for data transmission.

00:57:39,760 --> 00:57:47,237
Again, as CircuitPython, it shows up like a disk drive. On the disk drive I drag over ahtx0.py -

00:57:47,237 --> 00:57:53,783
 the the library file which defines how you read data over I2C and turn that into temperature readings and humidity readings.

00:57:53,783 --> 00:58:00,783
There's some F7SD and the meta never index and trashes. That's the mac stuff that I'm sure you're familiar with.

00:58:00,783 --> 00:58:07,873
boot.out.text is sort of like <D> message for microcontrollers. When you boot up

00:58:07,873 --> 00:58:12,080
it kind of gives you a little bit of output telling it the state so you can debug if something happened on boot.

00:58:12,960 --> 00:58:19,824
Bus device is a helper. It has some macros that makes it easy. It's in Python as well but it's in a folder

00:58:19,824 --> 00:58:24,427
and then you open up code.py in your favorite text editor, like Mou

00:58:24,800 --> 00:58:30,960
or you can use really any text editor. I also use  Atom sometimes or people use VS Studio or VS Code  

00:58:31,600 --> 00:58:38,880
and in this case the code, you import the time,  you import board and bus.io in the sensor.

00:58:40,480 --> 00:58:43,760
This is plain Python code for those  who may not be familiar with it.

00:58:43,760 --> 00:58:49,158
you create an I2C bus device saying 'I want to communicate digitally' over these two pins.

00:58:49,158 --> 00:58:54,000
You instantiate the sensor and then you  just read the temperature and relative humidity  

00:58:54,000 --> 00:58:58,080
and at the bottom you get the  temperature and humidity printed out  

00:58:58,080 --> 00:59:02,120
in degree C and percentage. Wonderful! Okay so, great.

00:59:02,120 --> 00:59:04,880
So now that code is running on the Pico.

00:59:06,480 --> 00:59:11,680
But now I'm going to pick out my Raspberry Pi 4, it's kind of the newest Raspberry Pi model  

00:59:11,680 --> 00:59:15,578
and in this case there's no download instead you follow the installation instructions.

00:59:15,578 --> 00:59:19,664
Here we have a shell script that you can run but basically you have to enable I2C

00:59:19,664 --> 00:59:24,000
and you have to install Python 3 and all that stuff that you're used to when you're installing software.

00:59:24,560 --> 00:59:32,922
If you've not installed Python 3 before, you wire it up. Again, connect to the GPIO, power, ground to data pins.

00:59:32,922 --> 00:59:38,075
You pip install the library. I already have but you can see all the dependencies are managed for you

00:59:38,075 --> 00:59:41,280
including uh... I'm trying to see... Blinka is here somewhere.

00:59:43,440 --> 00:59:47,999
I don't know, maybe I already have it installed. Oh yeah, here it is. Blinka gets installed first.

00:59:47,999 --> 00:59:55,760
Has all these dependencies including that RPI GPIO, I cat the example code which is essentially  

00:59:55,760 --> 01:00:01,462
the same as the the previous code except there's a  default I2C port and then same thing,

01:00:01,462 --> 01:00:06,560
I print out temperature and humidity, I run it from  the shell and it prints out to standard output.

01:00:07,680 --> 01:00:13,751
And finally, I want to run it on Windows. I have my windows computer, I grab my MCP2221

01:00:13,751 --> 01:00:20,557
which is like the FTDI board, it just happens to be the one I like more because it's so petite.

01:00:20,557 --> 01:00:25,920
In my windows Command Prompt, I pip install the same library that I installed on the Raspberry Pi  

01:00:25,920 --> 01:00:32,201
so it gets all my dependencies for me. I open up notepad which is my preferred editor in windows?

01:00:32,201 --> 01:00:36,548
I don't know, it's just convenient. I paste in that exact same code,

01:00:36,548 --> 01:00:42,079
I open up my Command Prompt and I go to the desktop and I run that code and the same exact output shows up.

01:00:42,079 --> 01:00:47,200
Same code, same output on a microcontroller,  on a microcomputer or a desktop computer.

01:00:48,080 --> 01:00:55,500
And so what I think is neat is that CircuitPython, while we originally sort of designed it as the easiest way to program microcontrollers

01:00:55,500 --> 01:01:01,556
we wanted to shrink that loop. Take away the compile/upload to make it edit, run, edit, run.

01:01:01,556 --> 01:01:04,625
Make it very fast because it's interpreted and you can do that.

01:01:04,625 --> 01:01:09,630
It turns out that it's actually kind of the best way to program electronics in general

01:01:09,630 --> 01:01:14,165
so by using Blinka with CircuitPython, CircuitPython sort of becomes...

01:01:14,165 --> 01:01:22,761
It's a language, yes, based on Python but it's more than that. It's more like an API and that API can be implemented in CPython

01:01:22,761 --> 01:01:28,078
that allows you to experiment and write code  and interface with hardware on any device -

01:01:28,078 --> 01:01:33,877
single board computers, desktops running any operating system as well as microcontroller boards.

01:01:33,877 --> 01:01:40,374
So especially for those of you who have Linux running on your favorite little funky single board computer

01:01:40,374 --> 01:01:44,240
if we don't support your board in Blinka, please open up an issue.

01:01:44,880 --> 01:01:50,622
We will try to get one or you can follow our guides we have on how to implement it yourself.

01:01:50,622 --> 01:01:55,099
We have a tutorial on how to add the detection code which is actually kind of the hardest part 

01:01:55,099 --> 01:02:01,017
to telling which single board computer you're running and then defining all the pins and peripherals

01:02:01,017 --> 01:02:07,588
so that Blinka knows what to look for and can make sure that the code runs smoothly on your favorite single board  computer.

01:02:07,588 --> 01:02:09,440
Thank you. I finished just on time.

01:02:11,520 --> 01:02:16,582
HOST: Thank you very much Limor, that was an excellent journey of microcontrollers

01:02:16,582 --> 01:02:21,443
LIMOR: I know! I took you on a place  and now you're back to where you started.

01:02:21,680 --> 01:02:25,080
HOST: It was great watching all the commentary along the side in the chat stream

01:02:25,080 --> 01:02:29,520
there were lots of really excited people talking about all the  different things that they've done with their  

01:02:29,520 --> 01:02:34,800
Arduinos and microcontrollers and Raspberry Pi's  LIMOR: Yeah. Have you have you built electronic projects  

01:02:34,800 --> 01:02:38,103
with Arduino or Raspberry Pi? HOST: I've done a little bit myself but

01:02:38,103 --> 01:02:44,924
nowhere near as much as people like our swag badge team. So I can give you an update on your question

01:02:44,924 --> 01:02:53,084
about why there's only two screens on the swag badge they said that  it's simply because they didn't have time to do six screens on there.

01:02:53,084 --> 01:02:59,114
LIMOR: Oh okay, that's a good reason, yeah. Next year. Six screens. HOST: I think so.

01:02:59,114 --> 01:03:02,397
LIMOR: Maybe like a cube, that'd be kind of fun like  a little like a die. HOST: Yeah, that would be pretty fun to play with

01:03:02,397 --> 01:03:05,583
LIMOR: Three-dimensional badges. That's where it's at. Alright well, thanks so much.

01:03:05,583 --> 01:03:13,338
We don't have question/answer for the keynote you told me but folks can come by our Discord and...

01:03:13,338 --> 01:03:15,825
HOST: They can LIMOR: Yeah, here's what I think I'm going to do.

01:03:15,825 --> 01:03:20,554
I'm going to stop. No, you stopped my screen. HOST: I've got to share for you.

01:03:20,554 --> 01:03:24,480
LIMOR: No, I have to stop my (INAUDIBLE) I'm going to share this window

01:03:25,040 --> 01:03:32,742
Okay, so if you could pop up the thing. So if you go to circuitpython.org and you can

01:03:32,742 --> 01:03:36,800
read all about it and all, you can click on Blinka if you want to see all these boards  

01:03:37,360 --> 01:03:44,360
but if you go to contributing and you look here -   okay, nice and big - there is a Discord.

01:03:44,360 --> 01:03:53,497
So if you're on Discord and I think almost everybody watching is probably on Discord because I think you have to be to go here

01:03:53,497 --> 01:03:58,000
(HOST LAUGHING) you can click on this link to go to the Adafruit Discord, this is an invite  

01:03:58,000 --> 01:04:03,100
and then we're in the CircuitPython channel  and you can ask us all sorts of questions

01:04:03,100 --> 01:04:06,147
because I'm sure people have all sorts of detailed questions HOST: I'm sure they do

01:04:06,147 --> 01:04:12,923
LIMOR: and we have a community and we also do a weekly meeting Mondays at 2pm eastern.

01:04:12,923 --> 01:04:17,868
Almost every Monday except when there's a holiday you can come by and you can be a total newbie.

01:04:17,868 --> 01:04:22,484
It's a voice chat but also text chat for those who don't like to do voice.

01:04:22,484 --> 01:04:24,122
HOST: Excellent LIMOR: Okay, cool.

01:04:24,123 --> 01:04:27,418
HOST: That's really good, thank you very much Limor. LIMOR: Alright, thank you.

01:04:27,418 --> 01:04:34,880

YouTube URL: https://www.youtube.com/watch?v=jZnDCs80b_A


