Title: "ClangBuiltLinux: What's Next?" - Nick Desaulniers (LCA 2021 Online)
Publication date: 2021-01-30
Playlist: linux.conf.au 2021
Description: 
	Nick Desaulniers

https://lca2021.linux.org.au/schedule/presentation/107/

2020 saw further adoption of LLVM for building Linux kernels by Linux distros, kernel developers, and CI systems.  But what tradeoffs exist, and what should be the focus of 2021?  Come join us for a quick retrospective of 2020, help us review outstanding work to be done/what use of LLVM unlocks, and learn how to get involved and participate in kernel AND toolchain development.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sat Jan 23 11:10:00 2021 at Tux Theatre
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,040 --> 00:00:19,039
second talk of the colonel miniconf

00:00:17,279 --> 00:00:20,320
and uh right now we've got uh nick

00:00:19,039 --> 00:00:22,080
desognier uh

00:00:20,320 --> 00:00:24,080
from google who will be talking about

00:00:22,080 --> 00:00:26,800
clang built linux what's next

00:00:24,080 --> 00:00:27,920
please welcome nick um and we will have

00:00:26,800 --> 00:00:30,080
a live q a

00:00:27,920 --> 00:00:31,599
at the end um so again please type your

00:00:30,080 --> 00:00:33,840
questions into the uh

00:00:31,599 --> 00:00:34,800
um tux theater chat prefixed with all

00:00:33,840 --> 00:00:37,200
caps question

00:00:34,800 --> 00:00:38,960
um so that we can see it great thank you

00:00:37,200 --> 00:00:40,559
so much andrew and uh thank you for

00:00:38,960 --> 00:00:42,960
having me here today thanks to all the

00:00:40,559 --> 00:00:44,800
organizers

00:00:42,960 --> 00:00:46,079
it's possible kind of thing you know i

00:00:44,800 --> 00:00:47,760
would have really loved to be there

00:00:46,079 --> 00:00:49,039
in person it's a conference i always

00:00:47,760 --> 00:00:49,840
love watching the videos and the talks

00:00:49,039 --> 00:00:51,360
from

00:00:49,840 --> 00:00:53,360
um you know unfortunate couldn't travel

00:00:51,360 --> 00:00:54,000
this year i feel like i'm missing out on

00:00:53,360 --> 00:00:56,399
my

00:00:54,000 --> 00:00:58,160
uh you know yearly quote of drop bear

00:00:56,399 --> 00:01:00,000
jokes at my expense but

00:00:58,160 --> 00:01:01,280
you know we shouldn't let kovid stop us

00:01:00,000 --> 00:01:01,840
you know let the drop bear jokes

00:01:01,280 --> 00:01:04,559
continue

00:01:01,840 --> 00:01:05,760
kind of thing but um anyways uh really

00:01:04,559 --> 00:01:08,159
happy to be talking about

00:01:05,760 --> 00:01:09,439
um a project that i've been working on

00:01:08,159 --> 00:01:11,119
uh and had the

00:01:09,439 --> 00:01:13,840
privilege to present um a lot of the

00:01:11,119 --> 00:01:16,880
work that we've been doing over the past

00:01:13,840 --> 00:01:18,720
two three four years i think we have

00:01:16,880 --> 00:01:19,280
over 100 contributors at this point so

00:01:18,720 --> 00:01:20,640
so

00:01:19,280 --> 00:01:22,880
you know really lucky to be able to work

00:01:20,640 --> 00:01:25,439
with a large group of folks

00:01:22,880 --> 00:01:27,119
on these things so just to recap really

00:01:25,439 --> 00:01:28,960
what did 2020 look like for us

00:01:27,119 --> 00:01:31,759
um you know my friend joel stanley

00:01:28,960 --> 00:01:33,680
presented here at linux cafe u in 2019

00:01:31,759 --> 00:01:36,159
so it's been you know about two years

00:01:33,680 --> 00:01:39,360
since any updates on in in this field

00:01:36,159 --> 00:01:41,280
um really 2020 was um about

00:01:39,360 --> 00:01:42,720
i think ci you know this there's this

00:01:41,280 --> 00:01:44,159
like football expression that really you

00:01:42,720 --> 00:01:45,280
need to have your blocking and tackling

00:01:44,159 --> 00:01:47,119
down before you can

00:01:45,280 --> 00:01:49,280
do any of the fancier plays and and

00:01:47,119 --> 00:01:51,920
really in software engineering i view

00:01:49,280 --> 00:01:53,439
continuous integration as your your

00:01:51,920 --> 00:01:54,000
basic building blocks you're blocking

00:01:53,439 --> 00:01:56,399
and tackling

00:01:54,000 --> 00:01:57,600
and what allows you to make aggressive

00:01:56,399 --> 00:01:58,880
changes and know that

00:01:57,600 --> 00:02:00,560
you haven't regressed or broken

00:01:58,880 --> 00:02:01,439
different things right so folks like

00:02:00,560 --> 00:02:04,719
kernel ci

00:02:01,439 --> 00:02:06,719
tuck suite red hat cki um

00:02:04,719 --> 00:02:08,959
but also intel xeribot lenovo's

00:02:06,719 --> 00:02:11,039
toolchain working group siz caller

00:02:08,959 --> 00:02:12,560
um you know we had a lot of ci running

00:02:11,039 --> 00:02:14,000
up on on travis ci

00:02:12,560 --> 00:02:16,800
and recently moved a lot of things to

00:02:14,000 --> 00:02:18,640
github actions as well um so having all

00:02:16,800 --> 00:02:20,400
this coverage and integrations of clang

00:02:18,640 --> 00:02:24,319
builds of linux kernels

00:02:20,400 --> 00:02:26,800
really gives us confidence in our builds

00:02:24,319 --> 00:02:29,599
so previously before 2020 android and

00:02:26,800 --> 00:02:31,200
chrome os had both built moved their

00:02:29,599 --> 00:02:33,280
linux kernel builds to being built with

00:02:31,200 --> 00:02:34,959
clang and finally in 2020

00:02:33,280 --> 00:02:36,879
we were actually able to move all of

00:02:34,959 --> 00:02:39,920
google's production servers

00:02:36,879 --> 00:02:42,400
in our fleet over to

00:02:39,920 --> 00:02:43,200
having their builds kernel builds be

00:02:42,400 --> 00:02:44,959
built with clang

00:02:43,200 --> 00:02:47,440
as well you know a ton of work from a

00:02:44,959 --> 00:02:49,280
lot of people went into that

00:02:47,440 --> 00:02:50,879
a compiler feature we implemented was

00:02:49,280 --> 00:02:53,920
called asm go to with outputs

00:02:50,879 --> 00:02:54,560
right so a very interesting kernel

00:02:53,920 --> 00:02:56,080
feature

00:02:54,560 --> 00:02:59,599
using inline assembly but transferring

00:02:56,080 --> 00:03:01,040
control flow back into c code

00:02:59,599 --> 00:03:02,879
had some limitations in the original

00:03:01,040 --> 00:03:05,920
design where

00:03:02,879 --> 00:03:08,879
very similar problem to calling

00:03:05,920 --> 00:03:10,239
functions or methods in c plus where uh

00:03:08,879 --> 00:03:12,159
maybe they would throw an exception so

00:03:10,239 --> 00:03:14,159
they could trigger control flow transfer

00:03:12,159 --> 00:03:15,760
um where you have this limitation where

00:03:14,159 --> 00:03:17,280
you almost like couldn't return values

00:03:15,760 --> 00:03:18,000
out of it right so if you had an azim

00:03:17,280 --> 00:03:19,840
block

00:03:18,000 --> 00:03:21,680
with control flow back into c you

00:03:19,840 --> 00:03:24,319
couldn't have any outputs kind of

00:03:21,680 --> 00:03:26,000
kind of thing and um so this is

00:03:24,319 --> 00:03:27,440
something that we were able to kind of

00:03:26,000 --> 00:03:30,080
i think improve on the design a little

00:03:27,440 --> 00:03:31,519
bit about and uh what was fun was

00:03:30,080 --> 00:03:32,799
actually i met linus for the first time

00:03:31,519 --> 00:03:35,440
in 2020

00:03:32,799 --> 00:03:37,200
and he was kind of like oh well you know

00:03:35,440 --> 00:03:38,720
i'd like to try clang but

00:03:37,200 --> 00:03:40,319
this is a feature i really want and if

00:03:38,720 --> 00:03:41,440
you guys could implement it you know i'd

00:03:40,319 --> 00:03:43,280
give it a try

00:03:41,440 --> 00:03:45,200
and what's funny is you know i knew he

00:03:43,280 --> 00:03:46,159
wanted this we knew he wanted this

00:03:45,200 --> 00:03:47,599
feature and so

00:03:46,159 --> 00:03:49,599
you know i went to this this meeting

00:03:47,599 --> 00:03:51,200
holding pocket aces because

00:03:49,599 --> 00:03:53,200
um you know one of my colleagues bill

00:03:51,200 --> 00:03:55,040
wendling had actually implemented this

00:03:53,200 --> 00:03:57,360
in llvm because we knew linus was

00:03:55,040 --> 00:03:59,120
interested in it and so linus was like

00:03:57,360 --> 00:04:00,720
send me the patches like show me how to

00:03:59,120 --> 00:04:01,760
build clang i will try it out kind of

00:04:00,720 --> 00:04:03,040
thing and so

00:04:01,760 --> 00:04:05,439
you know i was very nervous for that

00:04:03,040 --> 00:04:07,040
meeting because you know i i was nervous

00:04:05,439 --> 00:04:09,840
to see what would linus think

00:04:07,040 --> 00:04:11,680
um you know because i i viewed it as you

00:04:09,840 --> 00:04:13,280
he could say like this isn't important

00:04:11,680 --> 00:04:14,720
and then you know the whole effort would

00:04:13,280 --> 00:04:16,799
have been tanked kind of thing

00:04:14,720 --> 00:04:18,079
and i think very luckily you know i

00:04:16,799 --> 00:04:19,840
think linus saw the

00:04:18,079 --> 00:04:21,199
some of the benefits to some of this

00:04:19,840 --> 00:04:24,320
work kind of thing

00:04:21,199 --> 00:04:26,560
and it's been um really nice seeing

00:04:24,320 --> 00:04:28,160
like uh pull requests getting shot down

00:04:26,560 --> 00:04:29,759
that introduce new warnings

00:04:28,160 --> 00:04:31,520
that are observed with clang it's been

00:04:29,759 --> 00:04:32,880
interesting to kind of see that and

00:04:31,520 --> 00:04:34,800
just some other other discussions on the

00:04:32,880 --> 00:04:38,479
list and support and stuff

00:04:34,800 --> 00:04:40,560
in 2020 uh so we actually shipped

00:04:38,479 --> 00:04:41,919
we've been shipping lto and shadow call

00:04:40,560 --> 00:04:46,000
stack

00:04:41,919 --> 00:04:48,320
for for a while but 2020

00:04:46,000 --> 00:04:49,840
was really you know lto patches being

00:04:48,320 --> 00:04:50,800
sent upstream i think they're still

00:04:49,840 --> 00:04:52,560
undergoing

00:04:50,800 --> 00:04:54,960
iteration uh they'll probably land in

00:04:52,560 --> 00:04:55,680
5.12 i think they're kind of accepted

00:04:54,960 --> 00:04:57,759
but not

00:04:55,680 --> 00:04:58,720
not merged into mainline quite yet for

00:04:57,759 --> 00:05:00,560
arm64

00:04:58,720 --> 00:05:02,240
and then for x86 there's a large patch

00:05:00,560 --> 00:05:03,759
set that got posted yesterday

00:05:02,240 --> 00:05:06,560
fixing up um you know a bunch of

00:05:03,759 --> 00:05:09,039
different warnings that obstacle finds

00:05:06,560 --> 00:05:10,000
pgo patches i just reviewed them last

00:05:09,039 --> 00:05:12,080
night finally signed

00:05:10,000 --> 00:05:14,000
off on those but those are shipping in

00:05:12,080 --> 00:05:15,440
in chrome os all these chromebooks the

00:05:14,000 --> 00:05:16,880
one i'm presenting on i'll have pgo

00:05:15,440 --> 00:05:18,960
built kernels

00:05:16,880 --> 00:05:22,080
ltos used on android shadowcall stacks

00:05:18,960 --> 00:05:25,360
of rap chat channel uh

00:05:22,080 --> 00:05:26,240
rop attack prevention mechanism um auto

00:05:25,360 --> 00:05:28,720
fdo

00:05:26,240 --> 00:05:30,560
uh sorry i might be mixing these up auto

00:05:28,720 --> 00:05:33,199
fdo we're using on on the chromebooks

00:05:30,560 --> 00:05:35,039
pgo we're using in the data centers um

00:05:33,199 --> 00:05:36,400
very similar kind of mechanisms taking

00:05:35,039 --> 00:05:37,360
profiling information and feeding them

00:05:36,400 --> 00:05:38,880
back

00:05:37,360 --> 00:05:40,880
they're probably all landed mainline in

00:05:38,880 --> 00:05:42,639
2021 but 2020 is really when they

00:05:40,880 --> 00:05:44,479
all all shipped though lto was

00:05:42,639 --> 00:05:46,240
technically a little sooner than that

00:05:44,479 --> 00:05:47,520
um we formed the linux tool chains

00:05:46,240 --> 00:05:50,720
mailing list which

00:05:47,520 --> 00:05:52,400
uh is a kind of a neat little space for

00:05:50,720 --> 00:05:54,320
folks interested in in tool chain

00:05:52,400 --> 00:05:56,720
requests to kind of collaborate

00:05:54,320 --> 00:05:57,840
together on uh really what are the needs

00:05:56,720 --> 00:05:58,800
of the kernel community out of their

00:05:57,840 --> 00:06:00,160
tool chains

00:05:58,800 --> 00:06:01,840
and then really we spent a lot of time

00:06:00,160 --> 00:06:03,120
on 2020 getting clangs integrated

00:06:01,840 --> 00:06:06,000
assembler into shape

00:06:03,120 --> 00:06:07,680
in order to use it to assemble um either

00:06:06,000 --> 00:06:09,440
inline assembly or

00:06:07,680 --> 00:06:10,880
out of line assembler files in the linux

00:06:09,440 --> 00:06:12,479
kernel so

00:06:10,880 --> 00:06:15,199
it's very difficult it's a single pass

00:06:12,479 --> 00:06:17,120
assembler so um you know it's

00:06:15,199 --> 00:06:18,639
it's inflexible like c code where you

00:06:17,120 --> 00:06:21,680
can't refer to things until

00:06:18,639 --> 00:06:25,600
until you've seen them already and

00:06:21,680 --> 00:06:28,319
it's a lot closer to like a like a

00:06:25,600 --> 00:06:30,240
like a uh it's a generated assembler

00:06:28,319 --> 00:06:31,680
kind of thing so it's not as ad hoc

00:06:30,240 --> 00:06:33,120
it's a little less flexible to kind of

00:06:31,680 --> 00:06:35,280
work with kind of thing but a lot of

00:06:33,120 --> 00:06:38,240
work went into it in 2020

00:06:35,280 --> 00:06:38,720
but the theme of the the conference is

00:06:38,240 --> 00:06:40,720
is

00:06:38,720 --> 00:06:42,960
what's next right so i really wanted to

00:06:40,720 --> 00:06:44,720
talk um focus this talk on

00:06:42,960 --> 00:06:46,240
you know what do we want to do next for

00:06:44,720 --> 00:06:47,360
the for the project and what are some

00:06:46,240 --> 00:06:48,880
like far

00:06:47,360 --> 00:06:51,039
far reaching goals but things that i

00:06:48,880 --> 00:06:52,000
think we can either start or get done in

00:06:51,039 --> 00:06:54,720
00:06:52,000 --> 00:06:55,840
so i think the main thing on my mind

00:06:54,720 --> 00:06:57,759
really is

00:06:55,840 --> 00:06:59,680
compile time performance because i'd say

00:06:57,759 --> 00:07:01,199
clang is not competitive when it comes

00:06:59,680 --> 00:07:03,440
to compile times

00:07:01,199 --> 00:07:04,560
i don't think they're you know terribly

00:07:03,440 --> 00:07:06,240
bad but

00:07:04,560 --> 00:07:07,680
it really depends on you know what kind

00:07:06,240 --> 00:07:09,280
of machine you're building on

00:07:07,680 --> 00:07:10,800
you know how painful it is kind of thing

00:07:09,280 --> 00:07:11,199
and i think you know everyone would like

00:07:10,800 --> 00:07:13,280
to see

00:07:11,199 --> 00:07:14,960
improved compiler performance now you

00:07:13,280 --> 00:07:17,680
know i think in terms of link speed

00:07:14,960 --> 00:07:18,160
lld is is the fastest linker you'll find

00:07:17,680 --> 00:07:19,599
um

00:07:18,160 --> 00:07:21,759
it will take advantage of multiple cores

00:07:19,599 --> 00:07:23,919
on your system and do so quite well

00:07:21,759 --> 00:07:25,120
but i think there's a bit for clang so

00:07:23,919 --> 00:07:25,759
if you can imagine all the work that

00:07:25,120 --> 00:07:28,560
goes into a

00:07:25,759 --> 00:07:29,199
compilation job what might you imagine

00:07:28,560 --> 00:07:31,199
would be

00:07:29,199 --> 00:07:32,720
a you know relatively slow part of

00:07:31,199 --> 00:07:35,120
compilation right

00:07:32,720 --> 00:07:35,759
so here's a perf profile i captured

00:07:35,120 --> 00:07:39,360
yesterday

00:07:35,759 --> 00:07:42,080
from clang um this is from the entire

00:07:39,360 --> 00:07:42,960
invocation of make so you know all the

00:07:42,080 --> 00:07:44,639
thousands of in

00:07:42,960 --> 00:07:46,400
invocations of the compiler and

00:07:44,639 --> 00:07:48,160
assembler and linker and stuff

00:07:46,400 --> 00:07:49,680
um you know this is these are the top

00:07:48,160 --> 00:07:51,680
level traces and

00:07:49,680 --> 00:07:52,720
what's interesting in this trace to me

00:07:51,680 --> 00:07:55,199
is that

00:07:52,720 --> 00:07:55,840
um these are things in the clang name

00:07:55,199 --> 00:07:58,720
space

00:07:55,840 --> 00:07:59,599
uh are all front end work so lexing

00:07:58,720 --> 00:08:01,440
parsing

00:07:59,599 --> 00:08:03,599
you know a lot of work keeping track of

00:08:01,440 --> 00:08:06,400
tokens and what files they're in

00:08:03,599 --> 00:08:07,759
for macros but really not too much time

00:08:06,400 --> 00:08:09,120
spent in the back end the only thing

00:08:07,759 --> 00:08:11,120
that really sticks out

00:08:09,120 --> 00:08:13,360
from the llvm namespace is mostly some

00:08:11,120 --> 00:08:15,520
of the data structures

00:08:13,360 --> 00:08:16,560
which are already like very extensively

00:08:15,520 --> 00:08:18,800
optimized

00:08:16,560 --> 00:08:20,639
kind of thing you know check ice is

00:08:18,800 --> 00:08:22,720
integer constant expressions

00:08:20,639 --> 00:08:24,080
expensive to check so while i think we

00:08:22,720 --> 00:08:26,000
can

00:08:24,080 --> 00:08:27,280
visit individually optimizing each one

00:08:26,000 --> 00:08:28,960
of these uh

00:08:27,280 --> 00:08:30,560
i have some pretty crazy ideas that i've

00:08:28,960 --> 00:08:31,360
been speaking with the the front end

00:08:30,560 --> 00:08:33,760
maintainer about

00:08:31,360 --> 00:08:34,800
trying to bring ideas from uh the

00:08:33,760 --> 00:08:37,039
javascript world

00:08:34,800 --> 00:08:38,080
related to lazy excuse me related to

00:08:37,039 --> 00:08:40,159
lazy parsing

00:08:38,080 --> 00:08:41,839
to the cnc plus plus world is you know

00:08:40,159 --> 00:08:43,919
could we lazy parse

00:08:41,839 --> 00:08:45,920
um static inline functions or or

00:08:43,919 --> 00:08:48,160
templates not spend time

00:08:45,920 --> 00:08:49,040
uh kind of doing semantic analysis on

00:08:48,160 --> 00:08:51,040
undead code

00:08:49,040 --> 00:08:52,160
and what's interesting is chris lattner

00:08:51,040 --> 00:08:53,920
drops little hints at

00:08:52,160 --> 00:08:55,360
you know these kind of architectural

00:08:53,920 --> 00:08:58,480
changes um

00:08:55,360 --> 00:08:59,200
to to clang uh at seago was the latest

00:08:58,480 --> 00:09:03,600
one

00:08:59,200 --> 00:09:07,040
um so you know um if we had another ir

00:09:03,600 --> 00:09:08,880
uh in between clang and llvm ir

00:09:07,040 --> 00:09:10,880
we might be able to kind of raise c and

00:09:08,880 --> 00:09:14,320
c plus specific optimizations

00:09:10,880 --> 00:09:15,920
back into that ir um cleaning up llvmir

00:09:14,320 --> 00:09:19,360
for other languages really

00:09:15,920 --> 00:09:21,040
but also i think might lead interesting

00:09:19,360 --> 00:09:23,279
compile time

00:09:21,040 --> 00:09:24,640
opportunities but really macro expansion

00:09:23,279 --> 00:09:26,080
is really hurting compile times with

00:09:24,640 --> 00:09:28,240
both tool chains

00:09:26,080 --> 00:09:29,519
so aaron bergman a kernel developer has

00:09:28,240 --> 00:09:32,800
you know interesting

00:09:29,519 --> 00:09:34,399
studies into this in in some patches and

00:09:32,800 --> 00:09:36,080
i think we can try to automate some of

00:09:34,399 --> 00:09:37,600
these these clean cleanups um

00:09:36,080 --> 00:09:39,040
detangling some header dependencies and

00:09:37,600 --> 00:09:41,120
things like that that'll really help

00:09:39,040 --> 00:09:45,440
compile times with both compilers

00:09:41,120 --> 00:09:47,760
um so you know we we've had um

00:09:45,440 --> 00:09:49,360
you know kind of arm arm 64 and x86 are

00:09:47,760 --> 00:09:51,440
some of the main

00:09:49,360 --> 00:09:52,480
platforms that that uh we kind of

00:09:51,440 --> 00:09:54,480
support

00:09:52,480 --> 00:09:55,920
and you know things like risk five is

00:09:54,480 --> 00:09:58,240
you know on again off again

00:09:55,920 --> 00:10:00,080
with with support but i think in 2021

00:09:58,240 --> 00:10:05,360
we'll be able to add significantly more

00:10:00,080 --> 00:10:06,640
architectures um s390 is uh is

00:10:05,360 --> 00:10:09,279
we're pretty much waiting on the latest

00:10:06,640 --> 00:10:11,760
version of qmu to ship some fixes

00:10:09,279 --> 00:10:13,279
that were that were released uh recently

00:10:11,760 --> 00:10:14,399
you know found in fixed by david

00:10:13,279 --> 00:10:17,440
hildebrand at red hat

00:10:14,399 --> 00:10:18,959
um kind of thing and we have some some

00:10:17,440 --> 00:10:21,040
other fixes and stuff we'll need for

00:10:18,959 --> 00:10:24,480
some newer machines for inline azim but

00:10:21,040 --> 00:10:27,120
you know s390 is ready to go um motorola

00:10:24,480 --> 00:10:30,640
68k and sea sky are newish back ends

00:10:27,120 --> 00:10:32,160
in in clang and llvm uh that i think

00:10:30,640 --> 00:10:34,959
we'll probably see those land

00:10:32,160 --> 00:10:35,920
in 2021 and potentially become actual

00:10:34,959 --> 00:10:38,160
production

00:10:35,920 --> 00:10:39,920
back ends so you know i think as we

00:10:38,160 --> 00:10:41,839
improve our

00:10:39,920 --> 00:10:43,920
iso compatibility story it's interesting

00:10:41,839 --> 00:10:46,399
to see the kernel is actually

00:10:43,920 --> 00:10:47,279
kind of culling or removing support for

00:10:46,399 --> 00:10:49,279
some of the

00:10:47,279 --> 00:10:50,720
kind of longer tail architectures that

00:10:49,279 --> 00:10:52,560
that really haven't been in production

00:10:50,720 --> 00:10:54,399
for quite some time

00:10:52,560 --> 00:10:56,000
um one of the things that i think is

00:10:54,399 --> 00:10:58,079
really cool if you've heard of

00:10:56,000 --> 00:10:59,839
there's a project from facebook called

00:10:58,079 --> 00:11:02,320
bolt that does

00:10:59,839 --> 00:11:04,160
kind of optimization's post link it

00:11:02,320 --> 00:11:06,320
takes kind of profile data

00:11:04,160 --> 00:11:09,360
and it ends up reordering basic blocks

00:11:06,320 --> 00:11:11,200
which are kind of finer grain

00:11:09,360 --> 00:11:12,560
sub parts of your program finer grain

00:11:11,200 --> 00:11:14,640
than a function

00:11:12,560 --> 00:11:16,000
basically any sequence of statements

00:11:14,640 --> 00:11:17,600
before you have control flow is

00:11:16,000 --> 00:11:20,079
considered a basic block

00:11:17,600 --> 00:11:22,079
and you know they basically their paper

00:11:20,079 --> 00:11:24,800
shows that we're leaving

00:11:22,079 --> 00:11:26,959
optimization uh optimizations on the

00:11:24,800 --> 00:11:28,800
table by not reordering basic blocks

00:11:26,959 --> 00:11:31,360
based on how hot they are in a function

00:11:28,800 --> 00:11:32,000
and so propellers is kind of an llvm

00:11:31,360 --> 00:11:34,320
equivalent

00:11:32,000 --> 00:11:36,480
that doesn't involve um kind of blowing

00:11:34,320 --> 00:11:37,920
apart a binary and reordering it and

00:11:36,480 --> 00:11:40,000
reassembling it

00:11:37,920 --> 00:11:41,120
but during the build time as like a

00:11:40,000 --> 00:11:44,560
linker optimization

00:11:41,120 --> 00:11:45,680
of doing this basic block relay out kind

00:11:44,560 --> 00:11:49,760
of thing i think that's something that

00:11:45,680 --> 00:11:49,760
that needs to be investigated in 2021

00:11:50,720 --> 00:11:54,399
if you saw our talk at linux plumber's

00:11:53,519 --> 00:11:57,920
conf

00:11:54,399 --> 00:12:00,399
this year uh sorry 2020 last year

00:11:57,920 --> 00:12:01,519
uh we there's a lot of work going into

00:12:00,399 --> 00:12:05,120
um

00:12:01,519 --> 00:12:08,240
you know can we can we use a safer

00:12:05,120 --> 00:12:10,959
language to implement drivers and uh

00:12:08,240 --> 00:12:12,560
you know i've loaded drivers written in

00:12:10,959 --> 00:12:14,480
in rust built from the

00:12:12,560 --> 00:12:15,680
the core kernel you know directly into

00:12:14,480 --> 00:12:17,600
my machine and

00:12:15,680 --> 00:12:19,200
and you know we have the binary

00:12:17,600 --> 00:12:21,680
compatibility and

00:12:19,200 --> 00:12:23,120
i think this is uh you know something uh

00:12:21,680 --> 00:12:23,680
that's a very interesting topic to a lot

00:12:23,120 --> 00:12:25,440
of people

00:12:23,680 --> 00:12:26,880
so if you want to learn more about this

00:12:25,440 --> 00:12:29,040
there's there's a mailing list

00:12:26,880 --> 00:12:29,920
and projects hosted on github where you

00:12:29,040 --> 00:12:32,079
can see

00:12:29,920 --> 00:12:34,079
patches that are on actively undergoing

00:12:32,079 --> 00:12:35,839
review from parties that are interested

00:12:34,079 --> 00:12:38,000
in and they hope to put together a pull

00:12:35,839 --> 00:12:40,000
request you know eventually to send

00:12:38,000 --> 00:12:41,279
uh to the mainline colonel and i think i

00:12:40,000 --> 00:12:44,160
think we'll actually see that pull

00:12:41,279 --> 00:12:47,040
request go in 2021

00:12:44,160 --> 00:12:48,320
um really cool idea so tom rick's at red

00:12:47,040 --> 00:12:51,440
hat has been

00:12:48,320 --> 00:12:53,279
um playing with this idea like we have

00:12:51,440 --> 00:12:55,120
this this notion like tree wide patches

00:12:53,279 --> 00:12:56,720
in the kernel are kind of difficult of

00:12:55,120 --> 00:12:59,120
like timing wise and stuff

00:12:56,720 --> 00:13:00,560
um but can we leverage clang tidy and

00:12:59,120 --> 00:13:02,320
its ability to automatically apply

00:13:00,560 --> 00:13:05,279
fix-its to do tree-wide

00:13:02,320 --> 00:13:06,720
cleanups um it's kind of interesting uh

00:13:05,279 --> 00:13:08,240
you know there's a lot of configs in the

00:13:06,720 --> 00:13:09,760
kernel so when people ask you know does

00:13:08,240 --> 00:13:10,639
this work with clang i'm always like

00:13:09,760 --> 00:13:12,480
well

00:13:10,639 --> 00:13:14,399
there's too many combinations to test

00:13:12,480 --> 00:13:15,519
and and you know i would be more

00:13:14,399 --> 00:13:16,240
comfortable if we had the hardware to

00:13:15,519 --> 00:13:18,959
test it on

00:13:16,240 --> 00:13:19,519
so um but what's interesting is you know

00:13:18,959 --> 00:13:21,120
some of these

00:13:19,519 --> 00:13:22,639
combinations they don't they don't build

00:13:21,120 --> 00:13:25,040
with any compiler like code

00:13:22,639 --> 00:13:26,800
code is still broken so a lot to

00:13:25,040 --> 00:13:27,760
detangle but i think focusing on distro

00:13:26,800 --> 00:13:29,920
configs is

00:13:27,760 --> 00:13:30,959
you know what's important to people that

00:13:29,920 --> 00:13:33,040
gets a little bit into how do you

00:13:30,959 --> 00:13:34,800
package llvm for all these distributions

00:13:33,040 --> 00:13:36,079
how do you improve the documentation for

00:13:34,800 --> 00:13:38,000
all these distros

00:13:36,079 --> 00:13:39,920
right you know i i big fan i think arch

00:13:38,000 --> 00:13:40,800
linux has really great documentation for

00:13:39,920 --> 00:13:42,399
a lot of these things

00:13:40,800 --> 00:13:43,839
i would love to to write up like

00:13:42,399 --> 00:13:45,120
documentation for them on

00:13:43,839 --> 00:13:47,120
you know how do you build kernels with

00:13:45,120 --> 00:13:48,720
client how does that work um open

00:13:47,120 --> 00:13:50,560
driva it looks like they were really

00:13:48,720 --> 00:13:51,680
close their 4.2 release that's

00:13:50,560 --> 00:13:53,839
you know and currently in release

00:13:51,680 --> 00:13:56,000
candidate mode will probably ship

00:13:53,839 --> 00:13:57,040
in 2021 you know very close it seemed

00:13:56,000 --> 00:13:59,519
like the shipping in

00:13:57,040 --> 00:14:00,959
2020 but um for all the isis that we

00:13:59,519 --> 00:14:02,959
support i think they're on track still

00:14:00,959 --> 00:14:05,360
to switch over to clang built kernels

00:14:02,959 --> 00:14:06,160
so that'll be super cool to see and

00:14:05,360 --> 00:14:08,639
there's a lot more

00:14:06,160 --> 00:14:09,519
things in the love ecosystem i think

00:14:08,639 --> 00:14:12,160
really

00:14:09,519 --> 00:14:14,079
need more exploration so there's the

00:14:12,160 --> 00:14:15,279
dataflow sanitizer that no one's played

00:14:14,079 --> 00:14:16,399
with for the kernel i think it'll be

00:14:15,279 --> 00:14:19,440
really cool

00:14:16,399 --> 00:14:20,560
there was a google summer of code kind

00:14:19,440 --> 00:14:21,760
of research into using the thread

00:14:20,560 --> 00:14:24,000
locking annotations

00:14:21,760 --> 00:14:25,040
in the in the kernel i think there's

00:14:24,000 --> 00:14:27,040
there's still more

00:14:25,040 --> 00:14:28,079
that needs to be done there in terms of

00:14:27,040 --> 00:14:31,199
you know labeling

00:14:28,079 --> 00:14:33,680
precisely which variables certain

00:14:31,199 --> 00:14:34,320
like mutex or spinlocks are protecting

00:14:33,680 --> 00:14:37,199
kind of thing

00:14:34,320 --> 00:14:38,639
um one of the things i think we should

00:14:37,199 --> 00:14:40,639
be doing more of to

00:14:38,639 --> 00:14:42,160
you know help teach people how to

00:14:40,639 --> 00:14:43,120
contribute to linux or how to contribute

00:14:42,160 --> 00:14:44,480
to llvm

00:14:43,120 --> 00:14:45,920
is actually streaming some of the

00:14:44,480 --> 00:14:46,320
development work we do on twitch you

00:14:45,920 --> 00:14:47,920
know

00:14:46,320 --> 00:14:49,360
getting new developers is something that

00:14:47,920 --> 00:14:50,079
that's very important to me right it's

00:14:49,360 --> 00:14:52,000
like helping

00:14:50,079 --> 00:14:53,519
you know push people into the pool and

00:14:52,000 --> 00:14:56,560
you know teach them

00:14:53,519 --> 00:14:57,839
explain demonstrate guide and enable

00:14:56,560 --> 00:14:59,120
folks to contribute to the open source

00:14:57,839 --> 00:15:00,320
projects they love is something that's

00:14:59,120 --> 00:15:03,040
really important to me

00:15:00,320 --> 00:15:04,480
um but also you know the next big step

00:15:03,040 --> 00:15:06,399
is once you have all these contributors

00:15:04,480 --> 00:15:08,160
how do you get people paid and hired

00:15:06,399 --> 00:15:09,600
to work on this stuff full-time is

00:15:08,160 --> 00:15:10,639
something that i think is a very tricky

00:15:09,600 --> 00:15:13,440
thing i would love

00:15:10,639 --> 00:15:14,160
um to try to you know help solve in some

00:15:13,440 --> 00:15:17,839
form

00:15:14,160 --> 00:15:20,880
um and maybe even participation in iso

00:15:17,839 --> 00:15:22,079
standards body working group 14 for c

00:15:20,880 --> 00:15:24,000
i think there's some things that that

00:15:22,079 --> 00:15:25,519
need to get ironed out there

00:15:24,000 --> 00:15:28,079
and you know constant discussion on a

00:15:25,519 --> 00:15:29,120
list of oddities of the language kind of

00:15:28,079 --> 00:15:30,959
thing that could really

00:15:29,120 --> 00:15:32,160
um you know be nailed down would it

00:15:30,959 --> 00:15:36,079
would help a lot of people

00:15:32,160 --> 00:15:36,079
so if you want to learn more to get uh

00:15:36,160 --> 00:15:38,800
to get started to learn how to

00:15:37,360 --> 00:15:40,560
contribute check out our site clang

00:15:38,800 --> 00:15:42,959
built linux.github.com

00:15:40,560 --> 00:15:44,000
we're very active chat on telegram but

00:15:42,959 --> 00:15:46,240
we meet every

00:15:44,000 --> 00:15:47,360
uh every two weeks we have a public chat

00:15:46,240 --> 00:15:50,000
with folks from

00:15:47,360 --> 00:15:50,959
you know arm and red hat and lenaro and

00:15:50,000 --> 00:15:52,560
and

00:15:50,959 --> 00:15:54,639
intel and you know a bunch of folks will

00:15:52,560 --> 00:15:56,160
dial in and join in every two weeks is a

00:15:54,639 --> 00:15:58,240
lot of fun

00:15:56,160 --> 00:16:00,320
kind of thing and we use github for

00:15:58,240 --> 00:16:01,040
tracking all the bugs that we've quashed

00:16:00,320 --> 00:16:03,519
and

00:16:01,040 --> 00:16:06,079
and still have to quash so that's

00:16:03,519 --> 00:16:06,079
everything for me

00:16:06,839 --> 00:16:10,480
thanks

00:16:08,240 --> 00:16:12,160
thank you nick um we've got a few

00:16:10,480 --> 00:16:14,000
minutes for questions um so if you could

00:16:12,160 --> 00:16:16,720
please post questions in the chat

00:16:14,000 --> 00:16:17,440
um prefix them with question uh and then

00:16:16,720 --> 00:16:19,759
we will uh

00:16:17,440 --> 00:16:20,800
go through them um the first question

00:16:19,759 --> 00:16:22,800
from julian

00:16:20,800 --> 00:16:26,560
you mentioned dfsan what about the

00:16:22,800 --> 00:16:29,839
various other llvm hosted sanitizers

00:16:26,560 --> 00:16:32,880
yeah so i i

00:16:29,839 --> 00:16:34,639
so t-san is the only one that that is

00:16:32,880 --> 00:16:36,320
a little bit on shaky ground so i think

00:16:34,639 --> 00:16:39,519
t-san kind of morphed into

00:16:36,320 --> 00:16:41,440
um i think it's called kc sam is a

00:16:39,519 --> 00:16:43,199
a new form of like called kernel

00:16:41,440 --> 00:16:46,399
concurrency sanitizer

00:16:43,199 --> 00:16:48,800
and um so so that

00:16:46,399 --> 00:16:50,160
that's working well in in helping folks

00:16:48,800 --> 00:16:52,639
on the kernel land uh

00:16:50,160 --> 00:16:53,920
ka san kubstan are both in the kernel i

00:16:52,639 --> 00:16:55,040
think the thing that's a little tricky

00:16:53,920 --> 00:16:55,920
that we have right now with the clang

00:16:55,040 --> 00:16:59,759
implementations

00:16:55,920 --> 00:17:01,600
is um they they don't reuse stack slots

00:16:59,759 --> 00:17:02,800
which is a compiler optimization where

00:17:01,600 --> 00:17:05,120
if you can determine the lifetime of

00:17:02,800 --> 00:17:05,839
local variables you can reuse the stack

00:17:05,120 --> 00:17:07,280
slot for

00:17:05,839 --> 00:17:08,880
for a function for variables with

00:17:07,280 --> 00:17:11,679
non-overlapping lifetime

00:17:08,880 --> 00:17:13,839
and the the clang implementations will

00:17:11,679 --> 00:17:16,959
forcibly not reuse stack slots for the

00:17:13,839 --> 00:17:19,199
kasan ones and that leads to

00:17:16,959 --> 00:17:21,120
kind of excessive stack slot usage in

00:17:19,199 --> 00:17:22,160
the kernel almost dangerously high

00:17:21,120 --> 00:17:25,280
so i think that's something we still

00:17:22,160 --> 00:17:29,839
need to fix but ka san kusan kc san

00:17:25,280 --> 00:17:29,839
um all ready to go try them out

00:17:30,799 --> 00:17:34,960
uh the next question uh from clinton i'm

00:17:33,280 --> 00:17:36,640
not familiar with lazy passive

00:17:34,960 --> 00:17:38,480
parsing at all is there a single

00:17:36,640 --> 00:17:41,679
sentence summary

00:17:38,480 --> 00:17:44,080
um so the idea would be uh

00:17:41,679 --> 00:17:46,400
let's say there's lots of static inline

00:17:44,080 --> 00:17:49,039
functions that are defined in headers

00:17:46,400 --> 00:17:51,200
because you don't have odr violations uh

00:17:49,039 --> 00:17:53,280
but you wanna have code that's inline

00:17:51,200 --> 00:17:54,720
inlineable inline friendly kind of thing

00:17:53,280 --> 00:17:56,400
so you end up defining a whole bunch of

00:17:54,720 --> 00:17:58,640
functions and many many headers and

00:17:56,400 --> 00:18:00,320
headers that include more headers and

00:17:58,640 --> 00:18:01,440
then at the end of the day in your dot c

00:18:00,320 --> 00:18:03,520
source file you

00:18:01,440 --> 00:18:04,960
only end up referring to one of those in

00:18:03,520 --> 00:18:07,600
which case you end up spending lots of

00:18:04,960 --> 00:18:10,400
time lexing and parsing and tokenizing

00:18:07,600 --> 00:18:11,840
um the uh all these functions and then

00:18:10,400 --> 00:18:12,799
you don't end up using them it's kind of

00:18:11,840 --> 00:18:14,720
wasted

00:18:12,799 --> 00:18:16,720
time for a compilation job so the idea

00:18:14,720 --> 00:18:18,320
is you have a static inline function

00:18:16,720 --> 00:18:20,480
you basically skip ahead in the token

00:18:18,320 --> 00:18:23,679
stream to the end of the

00:18:20,480 --> 00:18:25,360
definition if it's well formed and then

00:18:23,679 --> 00:18:26,880
basically try to build a control flow

00:18:25,360 --> 00:18:28,640
graph and you start iterating between

00:18:26,880 --> 00:18:30,400
traversing the control flow graph

00:18:28,640 --> 00:18:32,000
and actually parsing the body of the

00:18:30,400 --> 00:18:34,080
function so

00:18:32,000 --> 00:18:35,679
you know it's not it's not free it adds

00:18:34,080 --> 00:18:38,160
overhead in certain cases

00:18:35,679 --> 00:18:40,160
kind of thing but basically we first

00:18:38,160 --> 00:18:42,799
need to do a bunch of statistics to see

00:18:40,160 --> 00:18:43,440
you know does my hypothesis hold or you

00:18:42,799 --> 00:18:47,280
know is it

00:18:43,440 --> 00:18:47,280
is it hypothetical

00:18:50,559 --> 00:18:54,640
um we are coming to the end of the time

00:18:52,720 --> 00:18:55,919
slot um so if you've got any further

00:18:54,640 --> 00:18:57,200
questions head on over to the colonel

00:18:55,919 --> 00:19:00,080
miniconf both channel

00:18:57,200 --> 00:19:01,280
and ask them over there thank you very

00:19:00,080 --> 00:19:03,039
much nick

00:19:01,280 --> 00:19:10,080
for your talk great thank you so much

00:19:03,039 --> 00:19:10,080

YouTube URL: https://www.youtube.com/watch?v=GpiWVXKs9Z0


