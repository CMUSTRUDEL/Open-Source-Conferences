Title: XArray: One Data Structure To Rule Them All
Publication date: 2020-01-09
Playlist: linux.conf.au 2019
Description: 
	Matthew Wilcox

https://2019.linux.conf.au/schedule/presentation/213/

The XArray has been merged for Linux 4.21.  Initially conceived as a replacement for the Radix Tree, it should also be used as a replacement for the IDR and can be used instead of a doubly-linked list in some circumstances.

Future improvements to the XArray may make this the only data structure we need, replacing linked lists under all circumstances, the rbtree and even hash tables.

Come to this talk and learn how to use the XArray now and how to use it in the future.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:03,540 --> 00:00:05,600
you

00:00:06,850 --> 00:00:14,050
testing Mic Check oh that's that's me

00:00:09,570 --> 00:00:16,209
all right yes I thought since since I'm

00:00:14,050 --> 00:00:18,430
in New Zealand I really must make more

00:00:16,209 --> 00:00:20,920
Tolkien references

00:00:18,430 --> 00:00:24,460
but the idea really is that this is the

00:00:20,920 --> 00:00:26,560
the only data structure you need so what

00:00:24,460 --> 00:00:28,869
it what is it it's an automatically

00:00:26,560 --> 00:00:30,009
resizing array of pointers and you don't

00:00:28,869 --> 00:00:31,720
need to know anything about the

00:00:30,009 --> 00:00:37,960
implementation of it because I'm going

00:00:31,720 --> 00:00:40,000
to change it hopefully for the better so

00:00:37,960 --> 00:00:42,070
this important traits is that it's an

00:00:40,000 --> 00:00:43,809
array of pointers it's indexed by an

00:00:42,070 --> 00:00:47,770
unsigned long some people been asking

00:00:43,809 --> 00:00:50,079
for you 64 index they're not getting it

00:00:47,770 --> 00:00:52,300
yet they might in the future it starts

00:00:50,079 --> 00:00:56,649
out with all pointers in it in our null

00:00:52,300 --> 00:00:59,350
and it occupies no it takes no memory to

00:00:56,649 --> 00:01:00,789
begin with it has a spin lock embedded

00:00:59,350 --> 00:01:02,199
in it so you don't need to not worry

00:01:00,789 --> 00:01:04,840
about locking it's taking care of its

00:01:02,199 --> 00:01:07,690
own locking at least if you're using the

00:01:04,840 --> 00:01:08,620
advance the the the regular API which is

00:01:07,690 --> 00:01:10,240
all I'm going to be talking about today

00:01:08,620 --> 00:01:13,060
there is an advanced API where you get

00:01:10,240 --> 00:01:15,939
to take care of the locking for it I've

00:01:13,060 --> 00:01:18,729
touched not in other talks if you go

00:01:15,939 --> 00:01:21,909
look at the Linux plumbers talk from

00:01:18,729 --> 00:01:23,740
November in in Vancouver you can find

00:01:21,909 --> 00:01:25,960
out more about that I don't talk about

00:01:23,740 --> 00:01:28,119
that today the other important

00:01:25,960 --> 00:01:30,490
performance aspect of this is that loads

00:01:28,119 --> 00:01:32,350
are store free so if you are doing a

00:01:30,490 --> 00:01:38,079
load you do not take the spin lock the

00:01:32,350 --> 00:01:41,470
the RCU thanks Alma Kenny is technique

00:01:38,079 --> 00:01:43,259
is used in order to avoid doing any

00:01:41,470 --> 00:01:45,189
modifications so a simultaneous

00:01:43,259 --> 00:01:47,020
modification can be happening to the

00:01:45,189 --> 00:01:50,469
array and you will get atomically either

00:01:47,020 --> 00:01:51,729
the the pointer that was in there or the

00:01:50,469 --> 00:01:53,680
pointer that was just stored in there

00:01:51,729 --> 00:01:55,210
but you won't get a mixture of the two

00:01:53,680 --> 00:01:58,659
and you won't get you will get something

00:01:55,210 --> 00:02:05,530
that was never stored at that and at

00:01:58,659 --> 00:02:09,149
that index so the most users only need

00:02:05,530 --> 00:02:12,780
to use these three or maybe even four

00:02:09,149 --> 00:02:14,740
functions you know you load you store

00:02:12,780 --> 00:02:16,920
maybe you were raised rather than

00:02:14,740 --> 00:02:20,959
storing a null some people prefer that

00:02:16,920 --> 00:02:23,450
and you can iterate over it be

00:02:20,959 --> 00:02:27,650
you know counting from 0 to infinity

00:02:23,450 --> 00:02:29,810
takes quite a long time so we have XA

00:02:27,650 --> 00:02:34,629
for each which we'll call which will

00:02:29,810 --> 00:02:39,129
execute the loop once for each non null

00:02:34,629 --> 00:02:39,129
entry in the X ray

00:02:39,230 --> 00:02:43,310
we have this functionality called

00:02:40,730 --> 00:02:47,930
marking these are search keys you get

00:02:43,310 --> 00:02:52,220
three three marks per entry so you can

00:02:47,930 --> 00:02:54,290
say you know I want to iterate over only

00:02:52,220 --> 00:02:56,030
the ones which have marked zero set or

00:02:54,290 --> 00:02:57,920
only ones that have marked two set and

00:02:56,030 --> 00:02:59,870
mostly users will define their own

00:02:57,920 --> 00:03:02,120
meanings from mark zero mark one and

00:02:59,870 --> 00:03:05,150
mark two so that they can say I want to

00:03:02,120 --> 00:03:07,549
iterate only over only the ones which

00:03:05,150 --> 00:03:09,470
are not yet written or I want to iterate

00:03:07,549 --> 00:03:14,859
only the ones which are currently being

00:03:09,470 --> 00:03:17,329
written now that that kind of thing so

00:03:14,859 --> 00:03:19,159
these are somewhat less used parts of

00:03:17,329 --> 00:03:23,720
the API than load and store so we have

00:03:19,159 --> 00:03:26,799
an insert and insert will only store if

00:03:23,720 --> 00:03:29,720
there was nothing already in the array

00:03:26,799 --> 00:03:31,849
compare an exchange so even if you only

00:03:29,720 --> 00:03:34,910
want to if you want to be certain that

00:03:31,849 --> 00:03:38,319
nobody else was racing with you you can

00:03:34,910 --> 00:03:41,569
use a comparing strange operation find

00:03:38,319 --> 00:03:44,540
will search through the array in order

00:03:41,569 --> 00:03:51,680
to find the the next one which matches

00:03:44,540 --> 00:03:55,099
the the filter and reserve is a shocking

00:03:51,680 --> 00:03:57,859
part of the it's an awful part of the

00:03:55,099 --> 00:04:00,349
API really but what it does is if your

00:03:57,859 --> 00:04:02,810
locking is so complicated that you would

00:04:00,349 --> 00:04:06,440
otherwise have to really mess around

00:04:02,810 --> 00:04:09,889
with with with the locking before you

00:04:06,440 --> 00:04:13,400
take any lock at all you can you can say

00:04:09,889 --> 00:04:17,139
preserve this index and then you can do

00:04:13,400 --> 00:04:17,139
a store later without allocating memory

00:04:18,280 --> 00:04:27,080
speaking of allocations you can also ask

00:04:22,760 --> 00:04:28,789
the for a store operation you say here

00:04:27,080 --> 00:04:32,240
was the point to which I want to put at

00:04:28,789 --> 00:04:33,110
this index with allocation you say here

00:04:32,240 --> 00:04:34,420
was a pointer

00:04:33,110 --> 00:04:38,470
please find

00:04:34,420 --> 00:04:43,090
null entry to put it out and it tells

00:04:38,470 --> 00:04:47,830
you where it put it with an allocating

00:04:43,090 --> 00:04:50,020
x-ray I said earlier but storing null is

00:04:47,830 --> 00:04:51,730
the same thing as doing an erase that's

00:04:50,020 --> 00:04:55,030
not ruining all with an allocating array

00:04:51,730 --> 00:04:59,590
because it is very convenient to be able

00:04:55,030 --> 00:05:01,930
to just to store a null we actually have

00:04:59,590 --> 00:05:04,350
users which depend on us which depend on

00:05:01,930 --> 00:05:09,070
being on they distinguish between

00:05:04,350 --> 00:05:13,030
storing a null and keeping the we

00:05:09,070 --> 00:05:16,030
storing they'll keeps the entry

00:05:13,030 --> 00:05:20,410
allocators so somebody else calling X a

00:05:16,030 --> 00:05:23,740
a lock will not be able to allocate that

00:05:20,410 --> 00:05:26,410
one who remains reserved just as if you

00:05:23,740 --> 00:05:28,720
use the X a reserved maybe I mentioned

00:05:26,410 --> 00:05:31,570
on the previous slide but so XA arrays

00:05:28,720 --> 00:05:35,460
will both set that pointer to null and

00:05:31,570 --> 00:05:37,390
make it available for reallocation and

00:05:35,460 --> 00:05:40,480
that's what most people want anyway so

00:05:37,390 --> 00:05:47,650
it works well for the for the users that

00:05:40,480 --> 00:05:51,120
we have now the the X ray was developed

00:05:47,650 --> 00:05:54,130
as a replacement for the radix tree and

00:05:51,120 --> 00:05:56,830
so I have converted all of the existing

00:05:54,130 --> 00:05:59,890
X all of the existing radix tree users

00:05:56,830 --> 00:06:04,360
to this new API and it's more in that

00:05:59,890 --> 00:06:06,670
get tree there I have not yet submitted

00:06:04,360 --> 00:06:10,210
a pull recording that I never intend to

00:06:06,670 --> 00:06:13,620
submit a pull request for this git

00:06:10,210 --> 00:06:15,820
branch I'm going to submit the

00:06:13,620 --> 00:06:18,250
conversions to the maintainer and get

00:06:15,820 --> 00:06:21,550
them to look it over because with

00:06:18,250 --> 00:06:24,280
something around 50 users of the radix

00:06:21,550 --> 00:06:27,580
tree API I've probably made a mistake or

00:06:24,280 --> 00:06:31,390
two so I want the maintainer to be

00:06:27,580 --> 00:06:35,830
responsible for the checking checking my

00:06:31,390 --> 00:06:37,840
work we have another data structure in

00:06:35,830 --> 00:06:43,180
the kernel the IDR which is where the

00:06:37,840 --> 00:06:46,210
whole allocation API comes from and I've

00:06:43,180 --> 00:06:48,100
converted most of we have rather more

00:06:46,210 --> 00:06:50,260
used with like 200 users

00:06:48,100 --> 00:06:51,850
the IDR I haven't converted all of them

00:06:50,260 --> 00:06:54,450
yet but I've converted and a large

00:06:51,850 --> 00:06:58,000
enough sample of the IDR users that I'm

00:06:54,450 --> 00:07:04,090
convinced the current API is is good

00:06:58,000 --> 00:07:06,040
enough for them so the another great

00:07:04,090 --> 00:07:08,370
thing you can already you can use it for

00:07:06,040 --> 00:07:10,570
today and you should use it for today is

00:07:08,370 --> 00:07:14,860
replacing custom implementations of

00:07:10,570 --> 00:07:17,020
resizing arrays so a fairly common thing

00:07:14,860 --> 00:07:19,390
we have a fairly common pattern you see

00:07:17,020 --> 00:07:23,200
in device drivers is people inventing

00:07:19,390 --> 00:07:27,820
their own resizing array is I just

00:07:23,200 --> 00:07:30,670
submitted a patch for the AIO code which

00:07:27,820 --> 00:07:32,830
has its own you you you you start out

00:07:30,670 --> 00:07:34,740
with one context and if you allocate a

00:07:32,830 --> 00:07:37,300
second context it doubles in size and

00:07:34,740 --> 00:07:40,120
third context it doubles in size to 4

00:07:37,300 --> 00:07:42,430
and then doubles again to 8 and really

00:07:40,120 --> 00:07:44,620
it's it's just a resizing array of

00:07:42,430 --> 00:07:48,430
pointers and that's exactly what the

00:07:44,620 --> 00:07:50,680
x-ray is you can also replace some

00:07:48,430 --> 00:07:52,000
linked lists which is kind of fun and I

00:07:50,680 --> 00:07:53,800
touched on that a little bit more in the

00:07:52,000 --> 00:07:56,560
plumbers talking I don't talk about it

00:07:53,800 --> 00:08:02,560
now because I want to get to the meat of

00:07:56,560 --> 00:08:04,810
this this presentation so here's the

00:08:02,560 --> 00:08:08,080
interesting things here is the laser

00:08:04,810 --> 00:08:11,710
which is not yet the one data structure

00:08:08,080 --> 00:08:17,350
to to rule them all if you try to use it

00:08:11,710 --> 00:08:20,860
for arrays with what I call sparse array

00:08:17,350 --> 00:08:23,020
so arrays with very sparse indices it

00:08:20,860 --> 00:08:25,300
will not work well if you try and

00:08:23,020 --> 00:08:28,240
replace a hash table again it's like

00:08:25,300 --> 00:08:32,200
having a very sparse array it won't work

00:08:28,240 --> 00:08:33,910
well we have an API in which I didn't

00:08:32,200 --> 00:08:35,380
even put on the slides because I'm a

00:08:33,910 --> 00:08:41,560
little bit ashamed of it

00:08:35,380 --> 00:08:44,530
to support storing a single pointer

00:08:41,560 --> 00:08:49,120
across a range of indices so if you look

00:08:44,530 --> 00:08:54,790
up any index between a and B it will

00:08:49,120 --> 00:09:01,630
return you the same pointer it there's

00:08:54,790 --> 00:09:04,060
this the implementation is not good the

00:09:01,630 --> 00:09:08,440
the API itself is not good either so I I

00:09:04,060 --> 00:09:12,220
need to do another round of refinement

00:09:08,440 --> 00:09:14,050
on that before we had more users we have

00:09:12,220 --> 00:09:18,760
a number of users in the kernel of a red

00:09:14,050 --> 00:09:22,540
book of red black trees don't don't try

00:09:18,760 --> 00:09:24,640
and you use the the x-ray instead of an

00:09:22,540 --> 00:09:27,279
RB tree yet unless you're very certain

00:09:24,640 --> 00:09:29,110
that it will work well and the file

00:09:27,279 --> 00:09:31,769
descriptor table for reasons that I will

00:09:29,110 --> 00:09:33,370
hopefully have time to get into later

00:09:31,769 --> 00:09:36,010
okay so why not

00:09:33,370 --> 00:09:40,180
what what what goes wrong if you try and

00:09:36,010 --> 00:09:43,269
eat and use if somebody else is choosing

00:09:40,180 --> 00:09:49,630
your array indices for you in order to

00:09:43,269 --> 00:09:51,579
force maximum damage the radix tree data

00:09:49,630 --> 00:09:56,019
structure that the x-ray current uses as

00:09:51,579 --> 00:10:00,640
its back hand really does not handle it

00:09:56,019 --> 00:10:03,490
well here's here's an example of storing

00:10:00,640 --> 00:10:05,980
a pointer at an index which is its own

00:10:03,490 --> 00:10:07,630
address which is actually a fairly

00:10:05,980 --> 00:10:10,180
sensible thing to want to do if you just

00:10:07,630 --> 00:10:14,320
want to say if you just want a list of

00:10:10,180 --> 00:10:16,810
all pointers then instead of instead of

00:10:14,320 --> 00:10:19,450
trying to invent somewhere to store it

00:10:16,810 --> 00:10:20,890
you distorted its own address and then

00:10:19,450 --> 00:10:24,610
you can iterate over all of them and

00:10:20,890 --> 00:10:26,740
you've got your list of pointers except

00:10:24,610 --> 00:10:29,100
that the radix tree really loses its

00:10:26,740 --> 00:10:34,570
mind when you try and do that because

00:10:29,100 --> 00:10:38,529
the index is implied by the position of

00:10:34,570 --> 00:10:43,720
the pointer in the tree and so in order

00:10:38,529 --> 00:10:46,449
to store it at this f-f-f-f-f-f-f it has

00:10:43,720 --> 00:10:49,750
to allocate nodes all the way down to

00:10:46,449 --> 00:10:51,790
the bottom and then store the pointer in

00:10:49,750 --> 00:10:55,540
one place and so you you have this

00:10:51,790 --> 00:10:57,970
incredibly deep tree and it's got one

00:10:55,540 --> 00:11:00,240
pointer in it and you've allocated about

00:10:57,970 --> 00:11:05,019
three about twelve kilobytes of memory

00:11:00,240 --> 00:11:08,079
in order to store a single pointer and

00:11:05,019 --> 00:11:10,899
the process of looking it up well six

00:11:08,079 --> 00:11:13,990
bits at a time you you you you get to

00:11:10,899 --> 00:11:16,600
the index that you sought us out this

00:11:13,990 --> 00:11:19,149
is this is not good this is this is

00:11:16,600 --> 00:11:23,860
quite the drawback and as I alluded to

00:11:19,149 --> 00:11:27,940
earlier some people receive the index

00:11:23,860 --> 00:11:31,899
they are storing the pointer out from

00:11:27,940 --> 00:11:35,440
another machine now maybe that machine

00:11:31,899 --> 00:11:38,080
has a different endianness and and it's

00:11:35,440 --> 00:11:40,959
actually malicious it's not trying to

00:11:38,080 --> 00:11:43,540
harm you but nevertheless is it's giving

00:11:40,959 --> 00:11:46,959
you an address it's giving you an index

00:11:43,540 --> 00:11:52,450
which doesn't work well for your

00:11:46,959 --> 00:11:54,160
machines endianness and there's a few

00:11:52,450 --> 00:11:56,770
examples of that scattered throughout

00:11:54,160 --> 00:11:58,870
network file systems network protocols

00:11:56,770 --> 00:12:01,120
anything where somebody else is giving

00:11:58,870 --> 00:12:07,690
is giving you an index that you're going

00:12:01,120 --> 00:12:11,100
to want to look at okay so I'm pretty

00:12:07,690 --> 00:12:14,800
happy at this point with the x-ray API

00:12:11,100 --> 00:12:18,310
but so time to look at what what we do

00:12:14,800 --> 00:12:21,570
about the backhand as I said we already

00:12:18,310 --> 00:12:23,709
have a red black tree in the kernel

00:12:21,570 --> 00:12:31,750
where black trees are not very cache

00:12:23,709 --> 00:12:35,110
efficient you if you have at each level

00:12:31,750 --> 00:12:39,790
of a red black tree you make a choice

00:12:35,110 --> 00:12:42,820
left or right so if you've got a

00:12:39,790 --> 00:12:47,339
thousand entries in your red black tree

00:12:42,820 --> 00:12:47,339
your red black tree is ten levels deep

00:12:47,850 --> 00:12:52,120
so it's not very cache efficient because

00:12:50,200 --> 00:12:54,490
every time you walk through it you you

00:12:52,120 --> 00:12:56,770
you you you basically take a cache miss

00:12:54,490 --> 00:12:59,410
it's like having a W is like using a

00:12:56,770 --> 00:13:01,600
doubly linked list sometimes in order to

00:12:59,410 --> 00:13:04,360
annoy computer theorists to people like

00:13:01,600 --> 00:13:06,850
also Trevor Lee linked list because each

00:13:04,360 --> 00:13:11,649
knows you're linking up to your parents

00:13:06,850 --> 00:13:13,839
and left and right so also the interface

00:13:11,649 --> 00:13:17,500
to the red black tree is really hard to

00:13:13,839 --> 00:13:20,260
use and you know if we use this as

00:13:17,500 --> 00:13:23,850
backend for the x-ray you know mate

00:13:20,260 --> 00:13:28,350
wouldn't be so hard to use but right now

00:13:23,850 --> 00:13:30,120
to convert something from using the

00:13:28,350 --> 00:13:32,310
the radix treaty using the red black

00:13:30,120 --> 00:13:38,040
tree would involve writing a lot of code

00:13:32,310 --> 00:13:44,910
because for each for each type of data

00:13:38,040 --> 00:13:46,200
you store in it you have to you you have

00:13:44,910 --> 00:13:50,550
to write your own search net search

00:13:46,200 --> 00:13:55,200
functions and in particular we saw a

00:13:50,550 --> 00:13:57,090
struck page in the inner radix tree all

00:13:55,200 --> 00:13:58,830
over the place and the last thing you

00:13:57,090 --> 00:14:02,970
want to be doing is talking to people

00:13:58,830 --> 00:14:07,980
about growing struct page that's not a

00:14:02,970 --> 00:14:09,390
popular thing to suggest when the very

00:14:07,980 --> 00:14:11,520
black tree isn't asked to you safe so

00:14:09,390 --> 00:14:14,250
you have to take some kind of lock every

00:14:11,520 --> 00:14:15,810
time you walk the tree one of the base

00:14:14,250 --> 00:14:20,430
one of the advantages of the radix tree

00:14:15,810 --> 00:14:21,930
is its RCU safe very very important for

00:14:20,430 --> 00:14:24,300
the page cache you you really don't want

00:14:21,930 --> 00:14:27,570
to use the page cache on a modern

00:14:24,300 --> 00:14:30,690
machine without RC RC in so the very

00:14:27,570 --> 00:14:32,400
black tree was out snow to the B tree we

00:14:30,690 --> 00:14:37,260
have a b-tree implementation inside the

00:14:32,400 --> 00:14:39,510
kernel it's not as efficient for densely

00:14:37,260 --> 00:14:41,550
packed indices as the radix tree is it's

00:14:39,510 --> 00:14:46,380
about half as efficient in fact because

00:14:41,550 --> 00:14:48,390
for each for each entry you are not only

00:14:46,380 --> 00:14:53,420
storing the pointer you're also storing

00:14:48,390 --> 00:14:56,580
the index at which that pointer says so

00:14:53,420 --> 00:14:58,740
that's not great it doesn't support

00:14:56,580 --> 00:15:01,830
ranges and the whole point behind me

00:14:58,740 --> 00:15:02,940
starting to do the x-ray work and the

00:15:01,830 --> 00:15:05,010
other work I've been doing with the page

00:15:02,940 --> 00:15:08,790
cache is that we want to support huge

00:15:05,010 --> 00:15:10,260
pages in the page cache and so what you

00:15:08,790 --> 00:15:14,450
want the huge page in the page cache is

00:15:10,260 --> 00:15:21,390
you want to say anything between indexes

00:15:14,450 --> 00:15:24,810
512 and 1023 gets the same pointer and

00:15:21,390 --> 00:15:27,750
the b-tree doesn't support that and the

00:15:24,810 --> 00:15:31,470
implementation inside the kernel dozen

00:15:27,750 --> 00:15:33,570
isn't our see you safe so i i rapidly

00:15:31,470 --> 00:15:40,140
discarded using the b-tree code we

00:15:33,570 --> 00:15:41,740
already have so colleague and i liam the

00:15:40,140 --> 00:15:44,320
at liam and I came up with some

00:15:41,740 --> 00:15:47,560
thing we're calling the maple tree now

00:15:44,320 --> 00:15:50,110
it is the reason it's called the maple

00:15:47,560 --> 00:15:56,260
tree is because we're both Canadian very

00:15:50,110 --> 00:15:59,200
patriotic people so the maple tree is an

00:15:56,260 --> 00:16:05,310
adaptive tree so we have several

00:15:59,200 --> 00:16:07,570
different types of node a range node

00:16:05,310 --> 00:16:09,310
you'd probably start at the top the

00:16:07,570 --> 00:16:11,800
trees looking to arrange note in the

00:16:09,310 --> 00:16:14,860
range node you would have eight pointers

00:16:11,800 --> 00:16:17,560
and you have seven pivots and so you you

00:16:14,860 --> 00:16:21,670
scan through the tiny this is the seven

00:16:17,560 --> 00:16:25,870
entry array of pivots looking to see

00:16:21,670 --> 00:16:28,020
where you sit where where the index

00:16:25,870 --> 00:16:30,190
you're looking for is going to fall and

00:16:28,020 --> 00:16:32,500
then you follow the corresponding

00:16:30,190 --> 00:16:34,420
pointer and you're thinking hang on

00:16:32,500 --> 00:16:36,910
you've got seven pivots and eight

00:16:34,420 --> 00:16:39,280
pointers how does that work we start out

00:16:36,910 --> 00:16:43,240
with a an implicit minimum and maximum

00:16:39,280 --> 00:16:46,090
for each node so you you you really have

00:16:43,240 --> 00:16:48,180
nine indices that you're looking at and

00:16:46,090 --> 00:16:50,770
eight pointers that fall between them

00:16:48,180 --> 00:16:52,930
but you don't need to store the minimum

00:16:50,770 --> 00:16:55,270
acts because either they were stored in

00:16:52,930 --> 00:16:57,220
the parent or they're implicitly zero

00:16:55,270 --> 00:17:01,350
and you long max because you're looking

00:16:57,220 --> 00:17:05,590
at the head of the of the tree

00:17:01,350 --> 00:17:07,990
now having only eight pointers per level

00:17:05,590 --> 00:17:12,010
of the tree doesn't sound like a most

00:17:07,990 --> 00:17:17,110
efficient way to look at it so when you

00:17:12,010 --> 00:17:20,260
get down to the when you when you get

00:17:17,110 --> 00:17:23,680
down to the leaf node you can just store

00:17:20,260 --> 00:17:26,980
fifteen pointers in there if you're

00:17:23,680 --> 00:17:30,460
looking at something like the allocating

00:17:26,980 --> 00:17:31,990
array where you start off with you know

00:17:30,460 --> 00:17:33,610
I miss all the first one at the zero and

00:17:31,990 --> 00:17:35,790
second one at one and then keep going

00:17:33,610 --> 00:17:38,920
two three four five

00:17:35,790 --> 00:17:45,490
you only need to allocate dense nodes at

00:17:38,920 --> 00:17:48,250
the leaf and it's it is actually more

00:17:45,490 --> 00:17:51,070
efficient sometimes than using the radix

00:17:48,250 --> 00:17:55,180
tree was simply because we have smaller

00:17:51,070 --> 00:17:55,660
nodes but there's less wasted space per

00:17:55,180 --> 00:17:58,300
node

00:17:55,660 --> 00:18:00,910
the the the important part of the Linux

00:17:58,300 --> 00:18:03,250
memory management is that it's it's

00:18:00,910 --> 00:18:06,550
based on pages I mean yes we're using

00:18:03,250 --> 00:18:09,850
the slab allocator but the slab

00:18:06,550 --> 00:18:13,780
allocator splits up pages so the

00:18:09,850 --> 00:18:19,030
question is how many nodes can you

00:18:13,780 --> 00:18:21,490
allocate per page and with the with the

00:18:19,030 --> 00:18:23,440
radix tree you get seven nodes per page

00:18:21,490 --> 00:18:25,540
and I'm talking about 64-bit systems

00:18:23,440 --> 00:18:27,880
here it's it's a it's a it's a different

00:18:25,540 --> 00:18:30,190
calculation on 32-bit systems but for

00:18:27,880 --> 00:18:33,310
the sake of keeping this brief I'm just

00:18:30,190 --> 00:18:37,360
going to talk about 64-bit systems you

00:18:33,310 --> 00:18:39,940
get you so with with the radix tree

00:18:37,360 --> 00:18:44,290
that's 64 entries at each level of the

00:18:39,940 --> 00:18:46,180
tree and you multiply up 64 times 8 and

00:18:44,290 --> 00:18:47,290
then you have to add on an extra 64

00:18:46,180 --> 00:18:50,320
bytes because there's some extra

00:18:47,290 --> 00:18:51,970
metadata associated with each level

00:18:50,320 --> 00:18:54,760
which we including things like a parent

00:18:51,970 --> 00:18:59,500
pointer and knowing what the shift is

00:18:54,760 --> 00:19:03,030
and all that kind of thing and we can

00:18:59,500 --> 00:19:05,740
cut most of that out for the maple tree

00:19:03,030 --> 00:19:10,140
and we end up with the calculation I'm

00:19:05,740 --> 00:19:10,140
not on the screen if you're just using

00:19:10,410 --> 00:19:16,870
if you're just using dense nodes you can

00:19:13,600 --> 00:19:21,280
get 448 entries per page with the radix

00:19:16,870 --> 00:19:24,520
tree and 480 per page with the with the

00:19:21,280 --> 00:19:27,640
maple tree so that's good I mean that's

00:19:24,520 --> 00:19:31,660
like a 10% improvement that's not not

00:19:27,640 --> 00:19:35,050
not not inconsiderable but you end up

00:19:31,660 --> 00:19:37,840
having to spend more nodes managing your

00:19:35,050 --> 00:19:41,290
other nodes so you you you you lose that

00:19:37,840 --> 00:19:46,650
10% advantage fairly rapidly but it's

00:19:41,290 --> 00:19:48,550
comparable and the nice thing with the

00:19:46,650 --> 00:19:52,180
pathological example I showed you

00:19:48,550 --> 00:19:54,490
earlier storing ext2 FS ty Paget so an

00:19:52,180 --> 00:20:00,520
address well that bad just fits in one

00:19:54,490 --> 00:20:03,310
knows because you say okay well all of

00:20:00,520 --> 00:20:07,300
the indices up to here like all of the

00:20:03,310 --> 00:20:09,549
entries up to this index 0 this one has

00:20:07,300 --> 00:20:12,429
a pointer to the excutive s5 and

00:20:09,549 --> 00:20:15,090
after it is also now and so all that

00:20:12,429 --> 00:20:21,009
information fits into a single earth

00:20:15,090 --> 00:20:26,919
that's pretty good now making this RC

00:20:21,009 --> 00:20:29,009
you safe is tricky I'm really glad that

00:20:26,919 --> 00:20:33,399
Liam and I are working on this together

00:20:29,009 --> 00:20:39,309
because it turns out that reasoning

00:20:33,399 --> 00:20:42,429
about when you can Ryu when you when you

00:20:39,309 --> 00:20:48,700
can use and reuse parts of the node is

00:20:42,429 --> 00:20:51,549
very very tricky we we had some very

00:20:48,700 --> 00:20:55,679
complicated code that we ended up having

00:20:51,549 --> 00:20:57,850
to throw away after having written it

00:20:55,679 --> 00:21:01,359
because we had not taken into account

00:20:57,850 --> 00:21:03,489
that two threads might move a different

00:21:01,359 --> 00:21:08,200
speed so we were looking doing inserts

00:21:03,489 --> 00:21:10,690
and of course one thread might take an

00:21:08,200 --> 00:21:16,379
interrupt while another thread continues

00:21:10,690 --> 00:21:21,970
execute at full speed and we managed to

00:21:16,379 --> 00:21:24,989
come up with scenarios where a very

00:21:21,970 --> 00:21:27,460
protected by RC you could end up seeing

00:21:24,989 --> 00:21:30,009
data which was never stored at a

00:21:27,460 --> 00:21:31,779
particular index and and that's what I'm

00:21:30,009 --> 00:21:35,679
a forgivable right you can either see

00:21:31,779 --> 00:21:38,799
the earliest stage of the the value of

00:21:35,679 --> 00:21:41,470
that index or the subsequent stage you

00:21:38,799 --> 00:21:43,509
may not see something which never

00:21:41,470 --> 00:21:45,669
existed you can't have a pointer which

00:21:43,509 --> 00:21:52,419
was never stored at that index that's

00:21:45,669 --> 00:21:56,980
just not allowed so injera throw that

00:21:52,419 --> 00:21:59,169
throw all that code away and we we end

00:21:56,980 --> 00:22:01,899
up just having to allocate and copy a

00:21:59,169 --> 00:22:04,950
lot of nodes and this is what has driven

00:22:01,899 --> 00:22:07,179
us to keep the nodes so small the

00:22:04,950 --> 00:22:08,799
computer theoreticians will tell you the

00:22:07,179 --> 00:22:10,690
larger branching factor you have at each

00:22:08,799 --> 00:22:14,139
level the more efficient your tree is

00:22:10,690 --> 00:22:18,609
and they're absolutely right but if

00:22:14,139 --> 00:22:21,789
you're having to copy a kilobyte every

00:22:18,609 --> 00:22:23,140
time you you you do an insert that isn't

00:22:21,789 --> 00:22:26,920
which isn't an append

00:22:23,140 --> 00:22:29,080
operation isn't into blank space at the

00:22:26,920 --> 00:22:33,010
end if you're doing an insert into the

00:22:29,080 --> 00:22:35,260
middle its it'll kill you

00:22:33,010 --> 00:22:42,790
so we've kept we've kept the notes very

00:22:35,260 --> 00:22:46,930
smaller just 128 bytes now in contrast

00:22:42,790 --> 00:22:52,120
to the b-tree literature which tells you

00:22:46,930 --> 00:23:00,250
that you should keep your nodes balanced

00:22:52,120 --> 00:23:03,100
at all times we say no we are going to

00:23:00,250 --> 00:23:10,270
keep we do not feel the need to balance

00:23:03,100 --> 00:23:13,840
our nodes at all times under two

00:23:10,270 --> 00:23:15,460
circumstances one is that when the

00:23:13,840 --> 00:23:18,100
indices are so dense there's no

00:23:15,460 --> 00:23:24,340
advantage to bouncing so take the

00:23:18,100 --> 00:23:26,320
example of filling up from zero uuuu

00:23:24,340 --> 00:23:29,290
allocate your first 15 and a dense node

00:23:26,320 --> 00:23:32,290
and then allocate number 16 into a new

00:23:29,290 --> 00:23:35,830
dense node and you have a node above it

00:23:32,290 --> 00:23:37,840
which shows that which says nought to 15

00:23:35,830 --> 00:23:42,640
over here and number 16 down there

00:23:37,840 --> 00:23:44,770
that's an unbalanced tree a tree would

00:23:42,640 --> 00:23:51,760
have you know nought to 8 over here and

00:23:44,770 --> 00:23:54,670
9 to 16 down there well why would you do

00:23:51,760 --> 00:24:02,740
that why why would you choose to balance

00:23:54,670 --> 00:24:06,690
your tree to satisfy the theoretical the

00:24:02,740 --> 00:24:08,770
theoretical basis behind the the B tree

00:24:06,690 --> 00:24:10,150
when there's actually no advantage to it

00:24:08,770 --> 00:24:14,410
in fact there are disadvantages to it

00:24:10,150 --> 00:24:21,700
because now when you come to the end of

00:24:14,410 --> 00:24:23,200
the the 9 - 9 + 15 24 when you've done

00:24:21,700 --> 00:24:25,840
number 24 note now you've got to go back

00:24:23,200 --> 00:24:27,670
and rebalance into the earlier node or

00:24:25,840 --> 00:24:32,470
you've got to grow the node again and

00:24:27,670 --> 00:24:35,290
this is actually noted as a as a problem

00:24:32,470 --> 00:24:37,440
with the B tree if you if you read some

00:24:35,290 --> 00:24:41,320
of the papers about B tree

00:24:37,440 --> 00:24:44,619
and they recommend having solutions like

00:24:41,320 --> 00:24:46,929
well when your load when you're doing

00:24:44,619 --> 00:24:52,269
the initial load of the database into

00:24:46,929 --> 00:24:54,549
the into the B tree then created

00:24:52,269 --> 00:24:56,320
unbalanced and then have one rebound on

00:24:54,549 --> 00:25:00,009
grand rebalancing operation at the end

00:24:56,320 --> 00:25:02,740
and you know we don't do that we don't

00:25:00,009 --> 00:25:04,480
have that luxury of being able to say oh

00:25:02,740 --> 00:25:09,519
this is this this is just the

00:25:04,480 --> 00:25:12,309
initialization phase so we just ignore

00:25:09,519 --> 00:25:14,830
the whole balancing aspect of it we say

00:25:12,309 --> 00:25:19,570
okay if it is clear that there is

00:25:14,830 --> 00:25:22,029
nowhere else to insert to the left then

00:25:19,570 --> 00:25:23,740
just leave that alone and and you know

00:25:22,029 --> 00:25:25,869
start allocating to the right

00:25:23,740 --> 00:25:28,179
don't move nodes over from the left

00:25:25,869 --> 00:25:37,450
nodes to the right notes just to keep

00:25:28,179 --> 00:25:41,259
things balanced supporting marks in the

00:25:37,450 --> 00:25:42,909
in the maple tree is is a little bit

00:25:41,259 --> 00:25:45,659
trickier so the way that this is done

00:25:42,909 --> 00:25:48,009
with the radix tree is that each node

00:25:45,659 --> 00:25:50,590
you may remember I told you earlier that

00:25:48,009 --> 00:25:56,590
each node has 64 bytes of metadata

00:25:50,590 --> 00:26:01,830
associated with it well 24 of those

00:25:56,590 --> 00:26:06,999
bytes are the the search markings and

00:26:01,830 --> 00:26:10,179
that that's a lot so we've started

00:26:06,999 --> 00:26:15,070
looking at what how we can support marks

00:26:10,179 --> 00:26:17,200
with the with the maple tree we're

00:26:15,070 --> 00:26:19,899
pretty committed to keeping on those 128

00:26:17,200 --> 00:26:22,179
bytes we've got eight bytes already

00:26:19,899 --> 00:26:26,039
allocated to be the parent node so it

00:26:22,179 --> 00:26:30,450
seems reasonable to start removing the

00:26:26,039 --> 00:26:30,450
two to start decreasing the number of

00:26:30,690 --> 00:26:36,789
pointers available to each level of the

00:26:32,740 --> 00:26:39,519
node if you choose to support if you

00:26:36,789 --> 00:26:43,570
choose to have search marks in your

00:26:39,519 --> 00:26:45,730
x-ray right now you get them whether you

00:26:43,570 --> 00:26:50,320
whether you use them or not you just get

00:26:45,730 --> 00:26:56,350
them there's part of the basic

00:26:50,320 --> 00:26:59,300
operation of the of the raid extreme but

00:26:56,350 --> 00:27:02,830
what we're going to do is is is force

00:26:59,300 --> 00:27:07,010
the users to say that when they declare

00:27:02,830 --> 00:27:08,930
their x-ray I'm going to use two marks

00:27:07,010 --> 00:27:12,140
or I'm going to use five marks or

00:27:08,930 --> 00:27:14,120
however many they want to use and we

00:27:12,140 --> 00:27:17,090
will then simply decrease them for

00:27:14,120 --> 00:27:18,710
pointers at each level until there's

00:27:17,090 --> 00:27:22,070
enough space to saw the number of marks

00:27:18,710 --> 00:27:23,560
that they've requested and this actually

00:27:22,070 --> 00:27:28,900
solves a problem for a lot of people

00:27:23,560 --> 00:27:32,480
because I've had requests from exe for

00:27:28,900 --> 00:27:38,750
butter FS and XFS all wanting to have

00:27:32,480 --> 00:27:43,010
more search marks and I say how many and

00:27:38,750 --> 00:27:45,890
they say well four would be nice five

00:27:43,010 --> 00:27:47,630
would be nice but one thing when you

00:27:45,890 --> 00:27:52,040
give me five I'm definitely going to ask

00:27:47,630 --> 00:27:54,020
for six and I said well how about 18 as

00:27:52,040 --> 00:27:57,800
a maximum and they're like yeah that's

00:27:54,020 --> 00:27:59,540
probably do us for a while I don't know

00:27:57,800 --> 00:28:02,870
how much they're going to enjoy having

00:27:59,540 --> 00:28:07,970
the the performance hit of having

00:28:02,870 --> 00:28:12,320
somewhat deeper trees but that is now

00:28:07,970 --> 00:28:14,950
their problem and not my problem so I'm

00:28:12,320 --> 00:28:14,950
happy about that

00:28:20,140 --> 00:28:29,510
okay so the last bullet here is well

00:28:26,510 --> 00:28:32,540
while we're working on this we obviously

00:28:29,510 --> 00:28:35,540
have the existing users of the X ray in

00:28:32,540 --> 00:28:37,820
mind and we want to be sure that we

00:28:35,540 --> 00:28:40,820
support them well but we also want to

00:28:37,820 --> 00:28:43,420
support some new users and one of the

00:28:40,820 --> 00:28:50,440
current pain points we have in Linux is

00:28:43,420 --> 00:28:54,710
the mm Sam and what the MSM does is it

00:28:50,440 --> 00:28:59,230
it protects the VM a tree so every time

00:28:54,710 --> 00:29:03,170
you call em map you get a new VM a and

00:28:59,230 --> 00:29:06,530
we keep those vma's in

00:29:03,170 --> 00:29:07,970
blackTree and like how saying that

00:29:06,530 --> 00:29:11,360
there's there's no concept using asks

00:29:07,970 --> 00:29:16,430
you to walk a red black tree you have to

00:29:11,360 --> 00:29:20,660
actually take this mmm semaphore in in

00:29:16,430 --> 00:29:22,310
read mode for every page fault so if you

00:29:20,660 --> 00:29:25,130
have a very multi-threaded application

00:29:22,310 --> 00:29:26,990
and you're running through it and and

00:29:25,130 --> 00:29:29,780
all the threads are running across all

00:29:26,990 --> 00:29:32,630
your CPUs they all take and taking lots

00:29:29,780 --> 00:29:37,490
of page faults they are all hitting this

00:29:32,630 --> 00:29:40,370
one cache line that contains the the

00:29:37,490 --> 00:29:43,130
semaphore taking it in read mode so so

00:29:40,370 --> 00:29:47,150
it just bounces around every CPUs making

00:29:43,130 --> 00:29:48,800
it dirty and this is not the most

00:29:47,150 --> 00:29:53,960
efficient way of doing it if we can walk

00:29:48,800 --> 00:30:01,400
the VMA tree by using RCU then we will

00:29:53,960 --> 00:30:05,600
have a fairly large gain but the the the

00:30:01,400 --> 00:30:09,950
the red black tree has support for doing

00:30:05,600 --> 00:30:12,230
efficient allocation of free space

00:30:09,950 --> 00:30:15,740
because when you call em map we have to

00:30:12,230 --> 00:30:18,620
search that VM a tree and find a hole in

00:30:15,740 --> 00:30:23,360
your address space of the right of a

00:30:18,620 --> 00:30:26,360
sufficient size to put in the VM map

00:30:23,360 --> 00:30:30,320
that you have asked for and doing a

00:30:26,360 --> 00:30:31,520
linear scanner it's not the not not

00:30:30,320 --> 00:30:33,950
really recommended you know if you've

00:30:31,520 --> 00:30:35,330
got a thousand VMAs you don't want to go

00:30:33,950 --> 00:30:38,690
looking through all of them try and find

00:30:35,330 --> 00:30:41,960
a gap so what we're going to do is in

00:30:38,690 --> 00:30:47,150
addition to supporting ma search marks

00:30:41,960 --> 00:30:50,660
also be able to note where what the

00:30:47,150 --> 00:30:55,250
largest hole is at any in in in any of

00:30:50,660 --> 00:30:56,840
the the pointers but that's going to be

00:30:55,250 --> 00:30:58,580
an optional feature that is that that's

00:30:56,840 --> 00:31:02,960
not something that most users are going

00:30:58,580 --> 00:31:05,420
to want to have it's entirely optional

00:31:02,960 --> 00:31:06,980
because again it's going to reduce the

00:31:05,420 --> 00:31:09,110
number of branches you have at each

00:31:06,980 --> 00:31:13,580
level which is going to lead to a deeper

00:31:09,110 --> 00:31:16,710
tree it's all about trade-offs

00:31:13,580 --> 00:31:20,460
so is this the one API to the one true

00:31:16,710 --> 00:31:23,520
data structure to my chagrin no there

00:31:20,460 --> 00:31:25,830
are there are still places where some

00:31:23,520 --> 00:31:28,410
users want to have overlapping ranges

00:31:25,830 --> 00:31:31,679
that that's not the metaphor I've gone

00:31:28,410 --> 00:31:34,799
for with the x-ray I have I I I have

00:31:31,679 --> 00:31:38,730
presented an API to something where for

00:31:34,799 --> 00:31:41,580
each index there was one pointer with

00:31:38,730 --> 00:31:46,020
these other users if you think about

00:31:41,580 --> 00:31:47,340
things like file locks there's some

00:31:46,020 --> 00:31:50,220
other good examples and there's gone

00:31:47,340 --> 00:31:54,840
right after ahead but they want to say

00:31:50,220 --> 00:31:58,970
okay there are three ranges which match

00:31:54,840 --> 00:31:58,970
the search key that you're looking for I

00:32:00,500 --> 00:32:07,080
mentioned when we're doing because we're

00:32:05,520 --> 00:32:11,159
you because we're I'll see you based we

00:32:07,080 --> 00:32:13,169
often have to allocate and free new

00:32:11,159 --> 00:32:15,390
nodes on an insert and the cost of doing

00:32:13,169 --> 00:32:18,210
that may be too high for some users so

00:32:15,390 --> 00:32:20,580
we're talking about maybe having a per

00:32:18,210 --> 00:32:22,980
instance of the x-ray flag to say you

00:32:20,580 --> 00:32:25,320
know what I don't do lookups under RCU

00:32:22,980 --> 00:32:27,630
so that's going to make the inserts run

00:32:25,320 --> 00:32:29,789
faster but it's going to make searches

00:32:27,630 --> 00:32:33,450
slower because every search will have to

00:32:29,789 --> 00:32:35,250
take the spin lock and for some users

00:32:33,450 --> 00:32:36,720
that's the right thing to do some users

00:32:35,250 --> 00:32:38,580
don't want to use our see you don't need

00:32:36,720 --> 00:32:44,640
to use ask to you in order to search the

00:32:38,580 --> 00:32:46,950
array some users can't tolerate memory

00:32:44,640 --> 00:32:50,159
allocations on insert to use the

00:32:46,950 --> 00:32:52,880
red-black tree you don't need to do

00:32:50,159 --> 00:32:56,789
memory allocation on every insert

00:32:52,880 --> 00:33:01,559
because the RB node is embedded within

00:32:56,789 --> 00:33:03,960
your data structure and so some some of

00:33:01,559 --> 00:33:05,600
them are just not written to tolerate

00:33:03,960 --> 00:33:09,150
memory allocations at that point because

00:33:05,600 --> 00:33:11,490
if you're doing a GFP atomic allocation

00:33:09,150 --> 00:33:16,169
that can fail and it it's pretty rare

00:33:11,490 --> 00:33:17,549
but it can happen summary there

00:33:16,169 --> 00:33:19,289
apparently there are some people who saw

00:33:17,549 --> 00:33:20,610
things other than pointers in erase

00:33:19,289 --> 00:33:22,110
apparent you can have an array of things

00:33:20,610 --> 00:33:25,500
that aren't pointers I don't know why

00:33:22,110 --> 00:33:27,270
you do that but so it's something some

00:33:25,500 --> 00:33:30,300
people do so we were also talking

00:33:27,270 --> 00:33:33,000
maybe coming up with another API for you

00:33:30,300 --> 00:33:37,410
know do so you can store 16-bit int and

00:33:33,000 --> 00:33:38,640
instead of a pointer well it's getting

00:33:37,410 --> 00:33:42,150
ahead of ourselves but we are

00:33:38,640 --> 00:33:43,800
considering it and of course the people

00:33:42,150 --> 00:33:45,150
who want 64 bit indices this is

00:33:43,800 --> 00:33:47,850
generally file system people again

00:33:45,150 --> 00:33:51,630
you know I've booted this 32-bit kernel

00:33:47,850 --> 00:33:54,060
and I want to address terabytes exabytes

00:33:51,630 --> 00:33:56,930
of storage so I want to look at things

00:33:54,060 --> 00:33:58,830
up with 64 bits indices yeah I

00:33:56,930 --> 00:34:02,880
understand where you're coming from but

00:33:58,830 --> 00:34:05,100
I don't want to write that code yet but

00:34:02,880 --> 00:34:10,560
you know I'm listening these are things

00:34:05,100 --> 00:34:13,470
which are on my wish list so with ten

00:34:10,560 --> 00:34:17,000
minutes to go what if I glossed over

00:34:13,470 --> 00:34:17,000
that you would like me to explain better

00:34:19,190 --> 00:34:23,480
is it like a question like that

00:34:29,349 --> 00:34:37,099
cool things but um have you looked at

00:34:33,500 --> 00:34:39,619
Judea rays have looked at Judea ray I'm

00:34:37,099 --> 00:34:40,490
assuming that you'd chose not to do that

00:34:39,619 --> 00:34:43,250
so why not

00:34:40,490 --> 00:34:44,839
wonderful question thank you yeah it's a

00:34:43,250 --> 00:34:46,760
bit of personal history

00:34:44,839 --> 00:34:49,869
I was actually sat across the cube wall

00:34:46,760 --> 00:34:54,440
from dog Baskins when he was writing the

00:34:49,869 --> 00:34:59,319
Judea Ray at HP back in I guess that was

00:34:54,440 --> 00:35:03,710
2000 2001 yeah

00:34:59,319 --> 00:35:07,490
Judea rays are really cool they are also

00:35:03,710 --> 00:35:10,010
radix trees but implemented in a much

00:35:07,490 --> 00:35:13,210
more clever fashion than the radix trees

00:35:10,010 --> 00:35:16,369
that we use in the kernel today they are

00:35:13,210 --> 00:35:18,170
adaptive and they they're really good

00:35:16,369 --> 00:35:21,799
for storing string it's because each

00:35:18,170 --> 00:35:24,640
layer is actually a uses eight bits

00:35:21,799 --> 00:35:30,289
instead of the six bits that we do so

00:35:24,640 --> 00:35:32,180
when each layer is a character you you

00:35:30,289 --> 00:35:37,279
can index your way through a string

00:35:32,180 --> 00:35:41,980
really efficiently the problem is that

00:35:37,279 --> 00:35:48,279
they don't they don't compress very well

00:35:41,980 --> 00:35:55,779
so when so the radix tree that we have

00:35:48,279 --> 00:35:58,250
will the rate the rate extreme we have

00:35:55,779 --> 00:36:00,380
compresses itself so if you only have

00:35:58,250 --> 00:36:02,869
very small indices that you're storing

00:36:00,380 --> 00:36:04,579
you don't allocate very many notes the

00:36:02,869 --> 00:36:10,010
problem comes when you in allocate

00:36:04,579 --> 00:36:15,380
really large nodes with the Judea ray at

00:36:10,010 --> 00:36:20,960
each at each level you you you you have

00:36:15,380 --> 00:36:23,240
to know are you staying or are you going

00:36:20,960 --> 00:36:25,520
and do various comparisons it's it's not

00:36:23,240 --> 00:36:28,549
the sort of general pub it's not the

00:36:25,520 --> 00:36:30,920
general-purpose data structure that we

00:36:28,549 --> 00:36:33,289
need and it doesn't really have support

00:36:30,920 --> 00:36:36,140
for doing ranges in the way that we need

00:36:33,289 --> 00:36:37,579
it to have and I think that's the key

00:36:36,140 --> 00:36:43,120
thing that you think that the maple tree

00:36:37,579 --> 00:36:45,650
is it was designed to be a range base

00:36:43,120 --> 00:36:48,680
because doubt that that was what we were

00:36:45,650 --> 00:36:52,430
missing we really did focus on the VMA

00:36:48,680 --> 00:36:54,500
tree as our prototypical user and we

00:36:52,430 --> 00:36:56,900
actually started out creating completely

00:36:54,500 --> 00:36:59,240
separate interface that was just for

00:36:56,900 --> 00:37:00,620
Rangers and it was only after word got a

00:36:59,240 --> 00:37:03,470
little way into development that we

00:37:00,620 --> 00:37:10,730
realized oh this will actually work

00:37:03,470 --> 00:37:17,420
really really well for single ranges of

00:37:10,730 --> 00:37:17,960
length one so yeah I hope that answers

00:37:17,420 --> 00:37:21,560
your question

00:37:17,960 --> 00:37:23,210
I'm not a huge expert on Judy I there

00:37:21,560 --> 00:37:27,440
wasn't a whole lot of osmosis across

00:37:23,210 --> 00:37:33,040
that cue ball but yeah I'm a big fan of

00:37:27,440 --> 00:37:35,210
the judy array idea the the

00:37:33,040 --> 00:37:38,360
implementation the Doug came up with was

00:37:35,210 --> 00:37:41,110
a little over complicated that matted

00:37:38,360 --> 00:37:43,490
Noa has written a much better

00:37:41,110 --> 00:37:47,510
implementation that sits in user space

00:37:43,490 --> 00:37:48,920
actually and I've read it over and I

00:37:47,510 --> 00:37:52,190
really like what he's done with it

00:37:48,920 --> 00:37:54,140
but I think the maple tree is probably a

00:37:52,190 --> 00:38:01,060
better choice for us but though that was

00:37:54,140 --> 00:38:01,060
a great question Thank You Tobin

00:38:06,130 --> 00:38:10,339
you said that if you know there's

00:38:08,750 --> 00:38:12,410
nothing no space that you don't

00:38:10,339 --> 00:38:14,119
rebalance the tree does that mean if you

00:38:12,410 --> 00:38:18,050
fill up from zero and then on the first

00:38:14,119 --> 00:38:21,050
delete you have to rebalance no no you

00:38:18,050 --> 00:38:24,890
you you you actually never rebalance in

00:38:21,050 --> 00:38:27,800
order to you never be balanced on a read

00:38:24,890 --> 00:38:29,630
ever ever because in order to rebalance

00:38:27,800 --> 00:38:31,790
you have to allocate memory and you

00:38:29,630 --> 00:38:34,369
you're on a read you're probably under

00:38:31,790 --> 00:38:37,520
the RCU lock so you you you you can't

00:38:34,369 --> 00:38:39,079
you can't do anything you you can't

00:38:37,520 --> 00:38:46,460
modify the tree if you're only holding

00:38:39,079 --> 00:38:53,390
the artsy you are you you don't

00:38:46,460 --> 00:39:00,530
rebalance you you don't rebalance in

00:38:53,390 --> 00:39:05,690
order to make the tree balanced unless

00:39:00,530 --> 00:39:12,770
it is possible for for you to improve

00:39:05,690 --> 00:39:17,270
the improve the the width of the tree

00:39:12,770 --> 00:39:20,569
all the depth of the tree so you you you

00:39:17,270 --> 00:39:23,329
you might rebalance in order to be able

00:39:20,569 --> 00:39:26,089
to delete one of the nodes but you

00:39:23,329 --> 00:39:28,490
wouldn't be balanced if the number of

00:39:26,089 --> 00:39:30,260
nodes would be the same just distribute

00:39:28,490 --> 00:39:33,380
just have the point as just attributed

00:39:30,260 --> 00:39:36,410
slightly differently between them so you

00:39:33,380 --> 00:39:40,400
you you you try and make the the the

00:39:36,410 --> 00:39:42,200
left side as heavy as possible in order

00:39:40,400 --> 00:39:44,240
that you can just keep allocating out to

00:39:42,200 --> 00:39:48,170
the right as far as possible without

00:39:44,240 --> 00:39:54,730
doing any more rebalance thing make

00:39:48,170 --> 00:39:54,730
sense okay question here

00:40:01,580 --> 00:40:08,300
so when you need to split a range node

00:40:04,670 --> 00:40:10,040
either so okay so when you need to split

00:40:08,300 --> 00:40:12,590
a range node how do you decide whether

00:40:10,040 --> 00:40:23,420
to allocate at the same level or one

00:40:12,590 --> 00:40:28,310
level below okay if there is space if

00:40:23,420 --> 00:40:29,420
there is space in that node okay so so

00:40:28,310 --> 00:40:37,940
so you're saying the root the root node

00:40:29,420 --> 00:40:39,650
is four okay so arrange nodes at any

00:40:37,940 --> 00:40:42,080
point in the tree is full and you need

00:40:39,650 --> 00:40:44,930
to do an insert in there okay so that

00:40:42,080 --> 00:40:48,980
point you are send to its parent and you

00:40:44,930 --> 00:40:52,550
split its parent now where do you choose

00:40:48,980 --> 00:40:54,170
the pivot for that split that that's the

00:40:52,550 --> 00:40:57,440
key thing what which is what I'm saying

00:40:54,170 --> 00:41:02,710
about the denseness of the indices if

00:40:57,440 --> 00:41:04,730
you can see that you can create if

00:41:02,710 --> 00:41:06,110
there's an advanced should be gained by

00:41:04,730 --> 00:41:09,800
splitting in the middle will split in

00:41:06,110 --> 00:41:11,710
the middle but generally what will try

00:41:09,800 --> 00:41:15,890
and keep the left as heavy as possible

00:41:11,710 --> 00:41:17,420
without without putting ourselves in a

00:41:15,890 --> 00:41:20,690
situation where we would need to

00:41:17,420 --> 00:41:24,470
rebalance and create what I call a

00:41:20,690 --> 00:41:28,870
spindly tree a tree that no longer

00:41:24,470 --> 00:41:28,870
satisfies the basic properties of B tree

00:41:29,200 --> 00:41:34,700
so I mean the basic properties of e tree

00:41:32,090 --> 00:41:40,760
is you know that you're within a certain

00:41:34,700 --> 00:41:45,410
percentage of being an optimal tree but

00:41:40,760 --> 00:41:50,540
you know but we play pretty fast and

00:41:45,410 --> 00:41:52,160
loose with that rule but we don't try

00:41:50,540 --> 00:41:56,690
and rebalance for the sake of being

00:41:52,160 --> 00:41:59,900
balancing yeah so when you're pivoting

00:41:56,690 --> 00:42:04,280
on a parent node you might have to shift

00:41:59,900 --> 00:42:07,870
some of the nodes from one at the level

00:42:04,280 --> 00:42:10,600
below from left to right yeah you know

00:42:07,870 --> 00:42:15,190
then how do you decide how many to shift

00:42:10,600 --> 00:42:18,529
yeah so we look at what the

00:42:15,190 --> 00:42:22,489
maxximum could be that what the maximum

00:42:18,529 --> 00:42:26,089
index could be in that left node right

00:42:22,489 --> 00:42:30,589
so if you've got one dense node there is

00:42:26,089 --> 00:42:33,650
no point in splitting in in allocating

00:42:30,589 --> 00:42:37,910
less than 15 right splitting that node

00:42:33,650 --> 00:42:41,480
ever you're just wasting space so we

00:42:37,910 --> 00:42:47,480
would happily have a 0 to 15 and then 16

00:42:41,480 --> 00:42:49,849
to 17 in the next node it can create

00:42:47,480 --> 00:42:51,980
trees which look spindly and and and

00:42:49,849 --> 00:42:54,470
then you you go and analyze it and you

00:42:51,980 --> 00:42:57,950
realize actually there was no way to

00:42:54,470 --> 00:43:00,470
have done this better it could look

00:42:57,950 --> 00:43:05,809
differently it could look less spindly

00:43:00,470 --> 00:43:07,339
but it's actually no more efficient at

00:43:05,809 --> 00:43:10,549
least not not any example I've been able

00:43:07,339 --> 00:43:14,569
to come up with now I could be wrong

00:43:10,549 --> 00:43:16,579
there could there could be bugs but you

00:43:14,569 --> 00:43:20,619
know we may need to change how we do

00:43:16,579 --> 00:43:22,730
things but we'll we'll look at that and

00:43:20,619 --> 00:43:25,849
it's definitely better than the radix

00:43:22,730 --> 00:43:26,869
tree at this point right we haven't been

00:43:25,849 --> 00:43:30,369
ever come up with any examples where

00:43:26,869 --> 00:43:30,369
we're doing worse than the radix tree

00:43:30,489 --> 00:43:35,509
there is example those words that you've

00:43:33,380 --> 00:43:39,259
used to describe the efficiency and the

00:43:35,509 --> 00:43:41,779
way that you make those decisions seem a

00:43:39,259 --> 00:43:44,589
little bit rubbery I guess is the word

00:43:41,779 --> 00:43:48,950
have you got any tests that actually

00:43:44,589 --> 00:43:50,390
quantify those results and you do is

00:43:48,950 --> 00:43:53,749
there a test suite that actually is

00:43:50,390 --> 00:43:57,559
working on analyzing what kind of tree

00:43:53,749 --> 00:44:01,339
comes out at the end yes we we have a

00:43:57,559 --> 00:44:03,920
test suite so the the x-ray has it has

00:44:01,339 --> 00:44:07,099
it has a test suite which is at this

00:44:03,920 --> 00:44:10,369
point mostly focused on being a

00:44:07,099 --> 00:44:13,400
regression test suite we we have had

00:44:10,369 --> 00:44:15,619
bugs in the past both in the the radix

00:44:13,400 --> 00:44:18,980
tree and in the x-ray rewrite the side

00:44:15,619 --> 00:44:21,619
of it and so that the tests are very

00:44:18,980 --> 00:44:24,880
focused on finding or making sure those

00:44:21,619 --> 00:44:30,250
bugs don't worry occur but we also have

00:44:24,880 --> 00:44:32,650
the the Liam and I aren't done yet we're

00:44:30,250 --> 00:44:34,840
not I mean the git tree is public but

00:44:32,650 --> 00:44:36,190
we're not publicizing it you know ty

00:44:34,840 --> 00:44:38,910
didn't put a link to our git tree

00:44:36,190 --> 00:44:41,350
because we're not ready for people to

00:44:38,910 --> 00:44:42,670
dive in and help at this point wherever

00:44:41,350 --> 00:44:45,070
there's a lot of things which are in

00:44:42,670 --> 00:44:49,000
flux but one of the things we are doing

00:44:45,070 --> 00:44:50,590
is yeah definitely a test some of the

00:44:49,000 --> 00:44:56,910
tests in the test suite are going to

00:44:50,590 --> 00:44:56,910
check that the tree is not inefficient

00:44:59,940 --> 00:45:11,380
well I think that's time so thank you

00:45:02,740 --> 00:45:13,330
very much this brings us to the end of

00:45:11,380 --> 00:45:16,600
the LCA 2019 kernel mini-cons

00:45:13,330 --> 00:45:18,100
please thank all of our speakers as well

00:45:16,600 --> 00:45:20,110
as all of our wonderful volunteers on

00:45:18,100 --> 00:45:22,000
the a/v team and the room monitors who

00:45:20,110 --> 00:45:24,760
have been helping us put this day

00:45:22,000 --> 00:45:27,240
together and thank you all for coming

00:45:24,760 --> 00:45:29,040
[Music]

00:45:27,240 --> 00:45:32,429
enjoy the rest of the conference

00:45:29,040 --> 00:45:32,429

YouTube URL: https://www.youtube.com/watch?v=-Bw-HWcrnss


