Title: RCU's First-Ever CVE, and How I Lived to Tell the Tale
Publication date: 2020-01-09
Playlist: linux.conf.au 2019
Description: 
	Paul E. McKenney

https://2019.linux.conf.au/schedule/presentation/107/

There was a time when I thought that Linux-kernel RCU was so low level that it was immune to security exploits. However, the 2014 advent of Rowhammer (https://en.wikipedia.org/wiki/Row_hammer) put paid to that naive thought.  After all, if the black hats can hit the DRAM, they can surely hit RCU!  And in early 2018, an RCU-related CVE duly appeared.  Now, RCU was operating as advertised, but it had a usability bug which lured a developer into mixing RCU flavors, which has about the same effect on your kernel's actuarial statistics as would acquiring the wrong lock.  So yes, usability bugs are real, so much so that they can result in security exploits!  Who knew?  Linus therefore asked if I could prevent future such exploits by consolidating the three RCU flavors (RCU-bh, RCU-preempt, and RCU-sched) into one flavor to rule them all.     This talk will briefly cover this consolidation, highlighting a few war stories and lessons (re)learned along the way.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:00,030 --> 00:00:04,560
our next book is titled our ciues

00:00:03,380 --> 00:00:08,280
first-ever

00:00:04,560 --> 00:00:11,880
CVE and how I live to tell the tale this

00:00:08,280 --> 00:00:13,980
talk will be given by Paul a McKinney so

00:00:11,880 --> 00:00:16,080
please can you all give a warm welcome

00:00:13,980 --> 00:00:17,990
to Paul McKinney with our ciues postive

00:00:16,080 --> 00:00:24,960
a CBE and how I live to tell the tale

00:00:17,990 --> 00:00:27,599
Thank You Cody thank you all right so

00:00:24,960 --> 00:00:30,179
you know things happen and this is

00:00:27,599 --> 00:00:32,130
perhaps not his world shaking his

00:00:30,179 --> 00:00:36,059
Specter or meltdown but I wasn't totally

00:00:32,130 --> 00:00:37,320
left out last year right okay this is

00:00:36,059 --> 00:00:38,879
kind of what I'm gonna go through please

00:00:37,320 --> 00:00:40,829
if you have a question any time just

00:00:38,879 --> 00:00:43,200
shout it out I'll repeat the question

00:00:40,829 --> 00:00:45,030
Cody said he wasn't he's in fairly good

00:00:43,200 --> 00:00:48,920
shape so he doesn't need extra exercise

00:00:45,030 --> 00:00:52,739
in this session so here we are and and

00:00:48,920 --> 00:00:55,320
one question isn't are you a little low

00:00:52,739 --> 00:00:58,680
level to be involved in a CVE you know a

00:00:55,320 --> 00:01:00,059
few years ago you know I just said you

00:00:58,680 --> 00:01:02,219
know our she's way down at the bottom of

00:01:00,059 --> 00:01:05,610
the stack you got some black hat out

00:01:02,219 --> 00:01:08,880
look I was hoping you tell me what's our

00:01:05,610 --> 00:01:10,920
Cu our CEO is read copy update we'll see

00:01:08,880 --> 00:01:12,240
aspects of as we go through there it's a

00:01:10,920 --> 00:01:15,720
synchronization primitive within the

00:01:12,240 --> 00:01:17,100
Linux kernel it allows reader if you

00:01:15,720 --> 00:01:19,500
have a link data structure with readers

00:01:17,100 --> 00:01:21,030
and updaters in the most aggressive case

00:01:19,500 --> 00:01:22,619
it allows the readers to go through the

00:01:21,030 --> 00:01:24,900
data structure with exactly the same

00:01:22,619 --> 00:01:27,630
sequence of instructions they would use

00:01:24,900 --> 00:01:28,920
in single threaded code despite the fact

00:01:27,630 --> 00:01:31,250
that the data structure is changing out

00:01:28,920 --> 00:01:35,329
from under them and it all works okay

00:01:31,250 --> 00:01:35,329
most of the time anyway

00:01:35,930 --> 00:01:40,110
anyway so we got this black hat he's off

00:01:38,369 --> 00:01:41,670
the cloud somewhere and why is he gonna

00:01:40,110 --> 00:01:42,780
pick on our shoe down at the bottom of

00:01:41,670 --> 00:01:43,770
the kernel when there's all sorts of

00:01:42,780 --> 00:01:46,200
other interesting things you know

00:01:43,770 --> 00:01:48,509
browsers and you know GPG keys and

00:01:46,200 --> 00:01:49,380
everything else up higher level and I

00:01:48,509 --> 00:01:51,170
would have said yeah they're not gonna

00:01:49,380 --> 00:01:54,240
bother I don't have to worry about this

00:01:51,170 --> 00:01:56,700
but you know some years ago how many

00:01:54,240 --> 00:01:59,149
people have heard of row hammer yeah

00:01:56,700 --> 00:02:02,759
yeah exactly

00:01:59,149 --> 00:02:05,460
that's attack on the dynamic RAM on the

00:02:02,759 --> 00:02:07,459
hardware and this is the obligatory

00:02:05,460 --> 00:02:09,599
diagram we've got all this really cool

00:02:07,459 --> 00:02:12,569
isolation and protection stuff so the

00:02:09,599 --> 00:02:13,790
blue rectangles there are different

00:02:12,569 --> 00:02:15,230
protection domains

00:02:13,790 --> 00:02:16,280
if you have access to the blue thing on

00:02:15,230 --> 00:02:17,450
the left you're not supposed to be I've

00:02:16,280 --> 00:02:20,719
access to the one on the right but you

00:02:17,450 --> 00:02:22,219
know what Sundy rams if you hammer that

00:02:20,719 --> 00:02:24,170
bit with the arrow pointing at it hard

00:02:22,219 --> 00:02:26,239
enough and did just right you will

00:02:24,170 --> 00:02:28,430
change the value of the bit on the other

00:02:26,239 --> 00:02:32,989
side all the page tables whatever

00:02:28,430 --> 00:02:35,480
notwithstanding and again if they can

00:02:32,989 --> 00:02:36,799
hit the hardware they can hit me and you

00:02:35,480 --> 00:02:38,599
know you just can't you can virtualize

00:02:36,799 --> 00:02:40,400
this a wonderful thing but you can't

00:02:38,599 --> 00:02:43,760
virtualize things like he and I out of

00:02:40,400 --> 00:02:45,849
existence I'm sorry you know all right

00:02:43,760 --> 00:02:48,379
so yeah thinking of the RAM then hit me

00:02:45,849 --> 00:02:49,970
that's why some years ago I got really

00:02:48,379 --> 00:02:51,859
interested in really making RC you

00:02:49,970 --> 00:02:53,569
torture really nasty and also talking to

00:02:51,859 --> 00:02:55,280
formal verification researchers to try

00:02:53,569 --> 00:02:59,180
to see if we can find bugs more

00:02:55,280 --> 00:03:02,840
aggressively but you know this is no

00:02:59,180 --> 00:03:06,230
longer a theoretical problem as of about

00:03:02,840 --> 00:03:08,060
this time last year yeah I was minding

00:03:06,230 --> 00:03:10,760
my own business early March and this

00:03:08,060 --> 00:03:13,549
email shows up of course it's really

00:03:10,760 --> 00:03:17,329
estores which gets one's attention often

00:03:13,549 --> 00:03:19,459
but another thing you might notice is it

00:03:17,329 --> 00:03:22,340
C sees this thing called security at

00:03:19,459 --> 00:03:26,109
kernel and org another thing might

00:03:22,340 --> 00:03:28,760
notice is it does not see CL KML and

00:03:26,109 --> 00:03:32,199
that's often a hint theer not going to

00:03:28,760 --> 00:03:32,199
be minding your own business for a while

00:03:32,379 --> 00:03:37,280
it was turned out to be a usage problem

00:03:34,790 --> 00:03:39,139
they fixed it and lena sent another to

00:03:37,280 --> 00:03:42,409
his credit he goes you know is there no

00:03:39,139 --> 00:03:44,180
way out of this mess is in you know okay

00:03:42,409 --> 00:03:45,620
maybe paul maybe you did things right

00:03:44,180 --> 00:03:48,019
but you've got an attractive new this is

00:03:45,620 --> 00:03:49,819
their key make it so that you like put a

00:03:48,019 --> 00:03:52,549
cover on this manhole so that people

00:03:49,819 --> 00:03:54,109
don't fall into it as often all right

00:03:52,549 --> 00:03:56,299
hand and that's actually the topic of

00:03:54,109 --> 00:03:58,040
this talk is how they get the cover on

00:03:56,299 --> 00:03:59,239
that nine hole cover you get the manhole

00:03:58,040 --> 00:04:03,349
cover on that manhole or some

00:03:59,239 --> 00:04:05,180
combination thereof alright so first off

00:04:03,349 --> 00:04:08,000
you know obviously if we've got a CVE

00:04:05,180 --> 00:04:11,540
what's the number well the honest answer

00:04:08,000 --> 00:04:14,349
is I don't know because you know I'm not

00:04:11,540 --> 00:04:16,900
cleared for embargoed security issues

00:04:14,349 --> 00:04:18,639
and I kind of like it that way actually

00:04:16,900 --> 00:04:20,769
I leave that to people like Casey here

00:04:18,639 --> 00:04:28,389
you know let them let them think he's

00:04:20,769 --> 00:04:30,070
shaking his head no and the other

00:04:28,389 --> 00:04:33,430
question is there really a CVD numbers

00:04:30,070 --> 00:04:35,620
issue and I don't know that either when

00:04:33,430 --> 00:04:37,360
I when I was starting on this project I

00:04:35,620 --> 00:04:41,410
assumed there was but since then I've

00:04:37,360 --> 00:04:43,150
found I was naive about Linux kernel

00:04:41,410 --> 00:04:45,039
maintainer Zand CVE some of them don't

00:04:43,150 --> 00:04:46,419
have that high of opinion of the CVD

00:04:45,039 --> 00:04:49,449
process so there might not be one I

00:04:46,419 --> 00:04:52,570
don't know but there was an exploitable

00:04:49,449 --> 00:04:53,710
bug and it seemed like CV number no it

00:04:52,570 --> 00:04:58,840
was something I should be taking

00:04:53,710 --> 00:05:00,400
seriously so what's the real problem I'm

00:04:58,840 --> 00:05:01,509
gonna just boil the code down really

00:05:00,400 --> 00:05:03,729
viciously and wind up something like

00:05:01,509 --> 00:05:05,259
this so we've got a reader and we got an

00:05:03,729 --> 00:05:08,560
update ER and running on different CPUs

00:05:05,259 --> 00:05:12,340
at the same time so the reader he does

00:05:08,560 --> 00:05:14,710
are Street locks CAD and in that doesn't

00:05:12,340 --> 00:05:16,539
do anything in non crippled kernels

00:05:14,710 --> 00:05:18,970
hence the thing about the same sequence

00:05:16,539 --> 00:05:20,139
of instructions he accesses the are

00:05:18,970 --> 00:05:21,639
cheaper ticket data structure goes

00:05:20,139 --> 00:05:23,740
running through some links somewhere and

00:05:21,639 --> 00:05:24,900
then he goes are sure he done locks CAD

00:05:23,740 --> 00:05:27,940
saying hey I'm done

00:05:24,900 --> 00:05:30,009
now what the updater does is he removes

00:05:27,940 --> 00:05:31,870
the old data so he changes some lengths

00:05:30,009 --> 00:05:34,479
some some data is no longer accessible

00:05:31,870 --> 00:05:36,820
to readers now old readers might still

00:05:34,479 --> 00:05:39,729
be accessing it because there was a link

00:05:36,820 --> 00:05:41,229
to it just a bit ago right and you know

00:05:39,729 --> 00:05:42,789
there might be an interrupt that might

00:05:41,229 --> 00:05:44,139
didn't get distributed where I wanted it

00:05:42,789 --> 00:05:46,620
to or maybe did gets tribute to where I

00:05:44,139 --> 00:05:48,310
wanted to there might be virtualization

00:05:46,620 --> 00:05:49,300
preemption there could be all sorts of

00:05:48,310 --> 00:05:51,880
things happening there could be long

00:05:49,300 --> 00:05:55,560
delays but synchronize RCU what it does

00:05:51,880 --> 00:05:58,090
is it waits for the readers to get done

00:05:55,560 --> 00:05:59,560
once all the old readers are done it

00:05:58,090 --> 00:06:02,169
just has to wait for the old readers not

00:05:59,560 --> 00:06:03,699
the new ones then there aren't any

00:06:02,169 --> 00:06:07,060
readers accessing the element we need to

00:06:03,699 --> 00:06:09,639
free it can somebody point out the bug

00:06:07,060 --> 00:06:12,630
in this thing yeah we got a guy up there

00:06:09,639 --> 00:06:12,630
what'swhat's wrong Willy

00:06:14,889 --> 00:06:20,119
very good very good there's a mismatch

00:06:17,929 --> 00:06:24,649
we'll we'll see the exact mismatch on a

00:06:20,119 --> 00:06:27,949
later slide but good show okay so why is

00:06:24,649 --> 00:06:29,959
this an abusive RCU well Willy call it

00:06:27,949 --> 00:06:32,719
out were you there's three flavors of

00:06:29,959 --> 00:06:34,189
RCU we're using one on the reader and

00:06:32,719 --> 00:06:36,709
we're using different one on the updater

00:06:34,189 --> 00:06:38,959
and that's about as good for your

00:06:36,709 --> 00:06:43,789
kernels life expectancy as grabbing the

00:06:38,959 --> 00:06:48,889
wrong lock and in this case it was an

00:06:43,789 --> 00:06:50,749
exploitable bug not just a bug and in

00:06:48,889 --> 00:06:51,979
pictorial form what's happening here so

00:06:50,749 --> 00:06:53,899
we've got the reader and we got the

00:06:51,979 --> 00:06:56,360
updater and we got the list up in the

00:06:53,899 --> 00:06:58,399
upper corner there and so we've got this

00:06:56,360 --> 00:07:00,499
list linked list and we want to remove B

00:06:58,399 --> 00:07:03,800
and we're pretending a singly linked

00:07:00,499 --> 00:07:06,580
just for simplicity so we've got a link

00:07:03,800 --> 00:07:09,889
from A to B if we store that pointer and

00:07:06,580 --> 00:07:11,689
make it point to C readers coming in at

00:07:09,889 --> 00:07:14,449
about that time will either see a list

00:07:11,689 --> 00:07:17,449
ABC or they'll see a list a see but

00:07:14,449 --> 00:07:19,909
either way they'll see a decent list at

00:07:17,449 --> 00:07:20,930
that point you know we we should be able

00:07:19,909 --> 00:07:22,279
to have the update or wait for the

00:07:20,930 --> 00:07:24,709
readers and so on so let's look what

00:07:22,279 --> 00:07:26,869
we're doing here so we do there are

00:07:24,709 --> 00:07:29,809
three locks CAD we're traversing the

00:07:26,869 --> 00:07:31,939
list we get a reference to be about this

00:07:29,809 --> 00:07:34,159
time the updater deletes it after we've

00:07:31,939 --> 00:07:37,039
got the reference and the after says

00:07:34,159 --> 00:07:38,839
okay synchronize RCU and synchronize

00:07:37,039 --> 00:07:41,539
ahrefs you either directly but mostly

00:07:38,839 --> 00:07:43,459
indirectly has to check with everybody

00:07:41,539 --> 00:07:46,249
that might have a reference to say are

00:07:43,459 --> 00:07:48,139
you a reader right now in other words

00:07:46,249 --> 00:07:50,930
have you are you under the influence of

00:07:48,139 --> 00:07:53,719
our C read lock so it goes over there

00:07:50,930 --> 00:07:55,999
we'll pretend this direct and says hey

00:07:53,719 --> 00:07:57,949
you got an RC read lock going yeah I got

00:07:55,999 --> 00:08:00,319
this RC locks CAD but now there's no R

00:07:57,949 --> 00:08:03,439
to read lock yeah fire away have a good

00:08:00,319 --> 00:08:05,839
time as a result this guys is great hey

00:08:03,439 --> 00:08:07,579
free which is kind of tough thing on the

00:08:05,839 --> 00:08:10,669
reader because they're still accessing B

00:08:07,579 --> 00:08:12,379
and having your memory 3 allocated out

00:08:10,669 --> 00:08:15,409
from under you to be something else can

00:08:12,379 --> 00:08:17,569
be quite a surprise so what a developer

00:08:15,409 --> 00:08:18,889
supposed to do instead and Willie call

00:08:17,569 --> 00:08:21,289
it out really there's two things you

00:08:18,889 --> 00:08:22,879
could do I'm going to do the take the

00:08:21,289 --> 00:08:26,180
choice Willie didn't first just to be

00:08:22,879 --> 00:08:28,430
perverse what you could do is adjust the

00:08:26,180 --> 00:08:30,650
reader and instead of using re are CV

00:08:28,430 --> 00:08:33,710
schedules are sure read lock which

00:08:30,650 --> 00:08:35,240
matches synchronized RCU at that point

00:08:33,710 --> 00:08:36,950
what happens is everything happens like

00:08:35,240 --> 00:08:38,900
those before we've got the reference the

00:08:36,950 --> 00:08:40,850
other guy deletes it and synchronize our

00:08:38,900 --> 00:08:42,530
ECU says hey you got an RC Reed lock our

00:08:40,850 --> 00:08:43,970
she would lock going I guess yeah I do

00:08:42,530 --> 00:08:46,700
you know kind of hand hold off here a

00:08:43,970 --> 00:08:49,160
bit so he waits there's an RC Reed

00:08:46,700 --> 00:08:50,570
unlock later and says usually it's very

00:08:49,160 --> 00:08:53,240
indirect I'm making it look very direct

00:08:50,570 --> 00:08:55,130
but that's fine and then he says great

00:08:53,240 --> 00:08:56,600
we're done okay fine okay freebie which

00:08:55,130 --> 00:08:59,030
is okay now because the other guy isn't

00:08:56,600 --> 00:09:01,520
using it anymore or we can do like

00:08:59,030 --> 00:09:02,930
Willie suggested which is make

00:09:01,520 --> 00:09:05,150
synchronized skin over here instead of

00:09:02,930 --> 00:09:07,630
synchronize our see you and the question

00:09:05,150 --> 00:09:09,740
I'll ask is is preemption disabled and

00:09:07,630 --> 00:09:12,260
well yes it is I've got an Archie

00:09:09,740 --> 00:09:13,370
Wheelock's kid going and again it'll say

00:09:12,260 --> 00:09:14,990
all right well let me know when you're

00:09:13,370 --> 00:09:17,870
when you're preemptable again so I can

00:09:14,990 --> 00:09:19,160
get rid of this guy that'll happen and

00:09:17,870 --> 00:09:24,370
then it cave freeze it and everything

00:09:19,160 --> 00:09:27,020
everybody's happy so the deal is

00:09:24,370 --> 00:09:28,940
consistency is required there are three

00:09:27,020 --> 00:09:30,470
different flavors and if we're gonna use

00:09:28,940 --> 00:09:33,380
the updater for one flavor you have to

00:09:30,470 --> 00:09:36,650
use the corresponding readers if you

00:09:33,380 --> 00:09:38,270
don't bad things happen how many people

00:09:36,650 --> 00:09:41,540
have heard the old proverb to err is

00:09:38,270 --> 00:09:43,100
human yeah it's been around for a couple

00:09:41,540 --> 00:09:45,680
centuries I guess I don't know maybe

00:09:43,100 --> 00:09:47,840
longer than that in fact when I was a

00:09:45,680 --> 00:09:50,120
kid there was a comic strip animal

00:09:47,840 --> 00:09:53,180
animal logic and one instance of it

00:09:50,120 --> 00:09:57,470
shows this this Grady chastising it's

00:09:53,180 --> 00:10:02,120
great a child cherish human stop beating

00:09:57,470 --> 00:10:03,800
human well most of us don't have the

00:10:02,120 --> 00:10:09,110
option of stopping being human by any

00:10:03,800 --> 00:10:11,540
reasonable means so we have to allow for

00:10:09,110 --> 00:10:13,280
these errors hence Lena says question

00:10:11,540 --> 00:10:15,200
can you do something about this ball and

00:10:13,280 --> 00:10:18,200
the other thing is user space controls

00:10:15,200 --> 00:10:20,390
the contents of much kernel data you

00:10:18,200 --> 00:10:21,500
know like the path names and constants

00:10:20,390 --> 00:10:23,720
of buffers and a whole pile of other

00:10:21,500 --> 00:10:25,040
stuff and that means that there's all

00:10:23,720 --> 00:10:26,720
sorts of opportunities for hackers to

00:10:25,040 --> 00:10:28,430
throw executable code and some strange

00:10:26,720 --> 00:10:30,320
chase in the kernel and if they can mess

00:10:28,430 --> 00:10:33,920
something else up they can make it do

00:10:30,320 --> 00:10:35,930
what they want so what would a fix even

00:10:33,920 --> 00:10:38,470
look like how would you how would you

00:10:35,930 --> 00:10:38,470
take care of this

00:10:39,850 --> 00:10:45,100
static analysis that's one possibility

00:10:42,960 --> 00:10:47,500
that's kind of a research topic right

00:10:45,100 --> 00:10:51,550
now and I'm encouraging people to try to

00:10:47,500 --> 00:10:52,900
find problems like that what you do is

00:10:51,550 --> 00:10:54,100
you tell them what the problem is and if

00:10:52,900 --> 00:10:55,810
they run away screaming then we're going

00:10:54,100 --> 00:10:56,950
to help you anyway if they're still

00:10:55,810 --> 00:10:59,020
talking to you they might be crazy

00:10:56,950 --> 00:11:02,340
enough to work on the problem but that's

00:10:59,020 --> 00:11:05,860
that's a good possibility I took of a

00:11:02,340 --> 00:11:08,110
more low brow approach which is or try

00:11:05,860 --> 00:11:09,250
to that was is to say look synchrony

00:11:08,110 --> 00:11:12,400
large three is gonna wait for everything

00:11:09,250 --> 00:11:13,720
all right so if you do our skewed lock

00:11:12,400 --> 00:11:16,690
is gonna wait for that like it does now

00:11:13,720 --> 00:11:18,150
if you have if you've disabled BHS and

00:11:16,690 --> 00:11:20,860
wait for that to be enabled if you've

00:11:18,150 --> 00:11:23,200
disabled the preemption that's gonna

00:11:20,860 --> 00:11:26,680
wait for that as well and we'll just

00:11:23,200 --> 00:11:29,020
have one update mechanism to rule them

00:11:26,680 --> 00:11:32,170
all to steal from somebody's earlier

00:11:29,020 --> 00:11:37,180
slide and we're in New Zealand anyway

00:11:32,170 --> 00:11:40,300
right anyway in order should I've said

00:11:37,180 --> 00:11:42,520
middle-earth anyway the the thing is

00:11:40,300 --> 00:11:44,050
that you know life's always a little

00:11:42,520 --> 00:11:47,980
more complicated things just never are

00:11:44,050 --> 00:11:49,990
quite that simple an archery lock an

00:11:47,980 --> 00:11:51,760
Irish read lock or how you do readers

00:11:49,990 --> 00:11:54,280
for the one flavour but you know you can

00:11:51,760 --> 00:11:56,410
do why she read lock thre new local pH

00:11:54,280 --> 00:11:57,910
disabled there's spin lock pH there's

00:11:56,410 --> 00:12:00,100
all sorts of ways as available bottom

00:11:57,910 --> 00:12:00,970
halves and with preemption it's even

00:12:00,100 --> 00:12:04,360
worse you got all the interrupts

00:12:00,970 --> 00:12:07,800
disabling stuff as well plus if you take

00:12:04,360 --> 00:12:13,480
a hard render up that does the trick too

00:12:07,800 --> 00:12:14,920
so in addition once we say that we're

00:12:13,480 --> 00:12:17,770
gonna have one set of our C weight on a

00:12:14,920 --> 00:12:20,170
bunch of stuff we have some fun

00:12:17,770 --> 00:12:22,090
combinations so we've got this thing

00:12:20,170 --> 00:12:24,010
here where we did our C read lock so we

00:12:22,090 --> 00:12:26,950
do something okay we're a reader right

00:12:24,010 --> 00:12:28,840
now and then we disable preemption and

00:12:26,950 --> 00:12:30,130
we do something else and we see our

00:12:28,840 --> 00:12:32,370
should be done lock but we're still a

00:12:30,130 --> 00:12:34,750
reader because preemption still disabled

00:12:32,370 --> 00:12:36,490
we do something more and finally we

00:12:34,750 --> 00:12:38,410
enable preemption and finally were not a

00:12:36,490 --> 00:12:39,460
reader anymore and you can make a more

00:12:38,410 --> 00:12:40,810
elaborate I'm not going to go through

00:12:39,460 --> 00:12:41,980
the one on the right hand side you can

00:12:40,810 --> 00:12:45,790
see we got three things overlapping

00:12:41,980 --> 00:12:48,790
there and to make this approach work we

00:12:45,790 --> 00:12:49,840
have to treat those as one big read side

00:12:48,790 --> 00:12:51,220
critical section even though they're

00:12:49,840 --> 00:12:53,430
kind of overlapping and chaining like

00:12:51,220 --> 00:12:53,430
that

00:12:53,620 --> 00:12:58,910
plus those are just two possible

00:12:56,570 --> 00:13:02,960
combinations there's a very large number

00:12:58,910 --> 00:13:05,690
of them in fact if you ignore CPU stall

00:13:02,960 --> 00:13:07,279
warnings and various other diagnosis the

00:13:05,690 --> 00:13:10,339
kernel would give you if you hang on to

00:13:07,279 --> 00:13:14,210
a CPU too long there's an infinite

00:13:10,339 --> 00:13:15,860
number I pout and made RC torture check

00:13:14,210 --> 00:13:18,860
random combinations of a up to eight

00:13:15,860 --> 00:13:20,660
chained together because I find it much

00:13:18,860 --> 00:13:23,270
more comfortable to find weird corner

00:13:20,660 --> 00:13:25,850
case bugs in the comfort of my own lab

00:13:23,270 --> 00:13:27,040
than to have to have people report the

00:13:25,850 --> 00:13:29,690
bug to me in the field

00:13:27,040 --> 00:13:32,360
I'm not cowardly that way I try to be

00:13:29,690 --> 00:13:35,810
anyway thankfully there's some good news

00:13:32,360 --> 00:13:39,650
if you have a non preemptable kernel

00:13:35,810 --> 00:13:43,130
config cramped equals n RC you already

00:13:39,650 --> 00:13:45,589
handles this give or take some details

00:13:43,130 --> 00:13:50,210
with our CVH quiescent states but we'll

00:13:45,589 --> 00:13:51,950
get there later because if you do RC

00:13:50,210 --> 00:13:53,390
read lock well you're already disabled

00:13:51,950 --> 00:13:55,520
because you're non preemptable to start

00:13:53,390 --> 00:13:56,960
with and so they just all changed

00:13:55,520 --> 00:13:59,150
together kind of automatically and

00:13:56,960 --> 00:14:01,070
that's really nice we have some things

00:13:59,150 --> 00:14:02,420
we had to fix with our cbh that's not a

00:14:01,070 --> 00:14:04,700
big deal is something that I've been

00:14:02,420 --> 00:14:07,279
considering for a while but yeah we

00:14:04,700 --> 00:14:08,959
really do have prepped equals y kernels

00:14:07,279 --> 00:14:12,740
we really do have printable kernels and

00:14:08,959 --> 00:14:15,200
we have to handle them as well ok so

00:14:12,740 --> 00:14:17,330
it's time to we've got a general idea of

00:14:15,200 --> 00:14:18,860
how we want to approach this or at least

00:14:17,330 --> 00:14:22,790
delusion about how it might be

00:14:18,860 --> 00:14:25,040
approached if in the worst case so let's

00:14:22,790 --> 00:14:27,770
look at some solutions one solution

00:14:25,040 --> 00:14:31,190
would be to add explicit RC readers to

00:14:27,770 --> 00:14:33,920
the various permission disable things so

00:14:31,190 --> 00:14:35,390
for example let's take preamp disable so

00:14:33,920 --> 00:14:37,250
we've got the code for pre active stable

00:14:35,390 --> 00:14:39,080
there if we just kind of put an RC read

00:14:37,250 --> 00:14:40,580
lock at the end of it so we do the

00:14:39,080 --> 00:14:42,620
preempted table stuff and then before we

00:14:40,580 --> 00:14:44,870
return we invoke or RC read lock one way

00:14:42,620 --> 00:14:46,310
or another and on the other hand before

00:14:44,870 --> 00:14:47,810
preempted able when the front of the

00:14:46,310 --> 00:14:49,339
code in the front of the of the macro

00:14:47,810 --> 00:14:51,890
function we put our sous-vide unlock

00:14:49,339 --> 00:14:53,690
then we've marked all of them with

00:14:51,890 --> 00:14:58,700
normal RC readers and the normal RSU

00:14:53,690 --> 00:15:00,860
update will just just work ok this adds

00:14:58,700 --> 00:15:02,630
some overhead on Fast Pass but hey this

00:15:00,860 --> 00:15:06,240
is a security bug alright get on my way

00:15:02,630 --> 00:15:08,410
right we're gonna take care of this

00:15:06,240 --> 00:15:14,139
it's cool now so I should do this right

00:15:08,410 --> 00:15:15,220
okay of course it's not quite that

00:15:14,139 --> 00:15:17,500
simple because there's a bunch of

00:15:15,220 --> 00:15:20,440
different ways to disable things and

00:15:17,500 --> 00:15:22,800
they all have to be tagged how many

00:15:20,440 --> 00:15:26,380
people besides me find this a bit scary

00:15:22,800 --> 00:15:28,180
yeah yeah the reason I find it scary is

00:15:26,380 --> 00:15:30,880
this is how I tried to do it when I

00:15:28,180 --> 00:15:32,500
first started preemptable RCU and it

00:15:30,880 --> 00:15:34,569
turned into a train wreck but that was

00:15:32,500 --> 00:15:37,180
years ago and the kernels change and so

00:15:34,569 --> 00:15:39,089
it's it's conceptually very simple so it

00:15:37,180 --> 00:15:41,949
I owe it to myself to try again right

00:15:39,089 --> 00:15:45,850
but I'm not gutting enough to throw RC

00:15:41,949 --> 00:15:48,459
read lock and to preempt enable so I'm

00:15:45,850 --> 00:15:52,389
gonna test it first what I do is I keep

00:15:48,459 --> 00:15:53,649
the counter per CPU and I increment and

00:15:52,389 --> 00:15:55,360
decrement that counter where I would

00:15:53,649 --> 00:15:57,430
have done arch to read lock and R so you

00:15:55,360 --> 00:15:58,930
read unlock respectively and then in

00:15:57,430 --> 00:16:00,310
various places where I know there's

00:15:58,930 --> 00:16:03,970
everything supposed to be enabled

00:16:00,310 --> 00:16:06,730
I put warned ons all right and then I

00:16:03,970 --> 00:16:14,009
run a bunch of stuff and and when I do

00:16:06,730 --> 00:16:17,800
that yeah but at least I tried right now

00:16:14,009 --> 00:16:19,089
in theory I could conceptually this can

00:16:17,800 --> 00:16:21,300
be made to work but there's a lot of

00:16:19,089 --> 00:16:23,500
fast path assembly code and that quickly

00:16:21,300 --> 00:16:26,170
proved maybe they haven't they clean

00:16:23,500 --> 00:16:27,699
some of that up but not all of it and I

00:16:26,170 --> 00:16:32,160
decided that it was time to try

00:16:27,699 --> 00:16:34,300
something else so one thing we can do

00:16:32,160 --> 00:16:35,889
part of the issue is who do this are she

00:16:34,300 --> 00:16:38,139
read unlock and that used to be hey

00:16:35,889 --> 00:16:39,430
we're good to go and now it's well we

00:16:38,139 --> 00:16:41,319
might be good to go or not depending

00:16:39,430 --> 00:16:43,779
where we were disabled so one thing we

00:16:41,319 --> 00:16:46,449
could do is is defer the we're good to

00:16:43,779 --> 00:16:51,370
go part and have our see kind of track

00:16:46,449 --> 00:16:53,050
deferred quest in the states and

00:16:51,370 --> 00:16:54,880
basically if we're disabled across arch

00:16:53,050 --> 00:16:56,170
you'd unlock don't report the quiz and

00:16:54,880 --> 00:16:59,800
stayed until later when everything is

00:16:56,170 --> 00:17:02,970
enabled now that's one simple sentence

00:16:59,800 --> 00:17:05,919
so it can't be that hard right and

00:17:02,970 --> 00:17:07,809
actually there's a lot of stuff already

00:17:05,919 --> 00:17:11,500
in RCU that kind of sort of does that so

00:17:07,809 --> 00:17:13,030
there is some hope but first we'll get

00:17:11,500 --> 00:17:14,770
to finally getting your question earlier

00:17:13,030 --> 00:17:16,689
on here

00:17:14,770 --> 00:17:19,299
what what the heck is this what is the

00:17:16,689 --> 00:17:20,260
quiescent state anyway so this is my

00:17:19,299 --> 00:17:22,120
standard

00:17:20,260 --> 00:17:25,030
deletion slides some of you've probably

00:17:22,120 --> 00:17:26,470
seen it a few times but instead of ABC

00:17:25,030 --> 00:17:27,459
we're gonna have boa cat and canoe we're

00:17:26,470 --> 00:17:29,830
gonna have animals in our linked list

00:17:27,459 --> 00:17:32,799
this time and we're still removing the

00:17:29,830 --> 00:17:34,929
middle one so if we do lift ldlr see you

00:17:32,799 --> 00:17:38,170
it hops the bolas pointer over canoe and

00:17:34,929 --> 00:17:39,670
at that point cat may still have old

00:17:38,170 --> 00:17:41,679
readers for some arbitrary length of

00:17:39,670 --> 00:17:43,179
time but it can't get any new readers

00:17:41,679 --> 00:17:47,350
because there's no way for the reader to

00:17:43,179 --> 00:17:49,210
get to the cat anymore then we do

00:17:47,350 --> 00:17:50,710
synchronize RCU which waits for all the

00:17:49,210 --> 00:17:53,110
readers somehow we're trying to work out

00:17:50,710 --> 00:17:55,809
how to do that but once that's done

00:17:53,110 --> 00:17:58,030
nobody's looking at the cat and then we

00:17:55,809 --> 00:18:00,820
can safely free it and quiescent states

00:17:58,030 --> 00:18:05,710
are what tells synchronized RCU how long

00:18:00,820 --> 00:18:07,360
it has to wait so and this and this

00:18:05,710 --> 00:18:09,220
we're preemptable we have tasks we have

00:18:07,360 --> 00:18:10,960
to worry about as well as CPUs and we'll

00:18:09,220 --> 00:18:12,730
talk more about that later but the

00:18:10,960 --> 00:18:14,320
general idea is we have an execution we

00:18:12,730 --> 00:18:15,610
have readers and blue there so there's

00:18:14,320 --> 00:18:17,080
being with our C read lock and our

00:18:15,610 --> 00:18:19,540
should be done lock or a crimp disable

00:18:17,080 --> 00:18:21,070
 disable or whatever and the green

00:18:19,540 --> 00:18:23,830
spots are where we get to a point where

00:18:21,070 --> 00:18:25,419
we know there are no readers there's no

00:18:23,830 --> 00:18:26,890
arch you read lock happening everything

00:18:25,419 --> 00:18:30,190
is enabled and so that's a point of

00:18:26,890 --> 00:18:32,350
which we know that this CPU or this task

00:18:30,190 --> 00:18:35,679
is done with anything it was reading

00:18:32,350 --> 00:18:37,360
before and so it's okay if we freed the

00:18:35,679 --> 00:18:39,010
cat before the quiescent state then

00:18:37,360 --> 00:18:42,340
after the quiescent state is okay with

00:18:39,010 --> 00:18:43,600
that particular entity to do the free so

00:18:42,340 --> 00:18:44,919
after all entities have been through a

00:18:43,600 --> 00:18:50,470
quiescent state we can free the cats

00:18:44,919 --> 00:18:52,150
safely okay so in this case what we're

00:18:50,470 --> 00:18:54,910
talking about doing is deferring when a

00:18:52,150 --> 00:18:57,280
quiescent state gets reported in order

00:18:54,910 --> 00:19:01,000
to handle this chaining of disables and

00:18:57,280 --> 00:19:02,110
our series echo sections one

00:19:01,000 --> 00:19:04,419
straightforward approach is to use

00:19:02,110 --> 00:19:05,860
counters so at the beginning sacred eyes

00:19:04,419 --> 00:19:07,330
are to you we could set a number to the

00:19:05,860 --> 00:19:08,950
number of things you need weight on we

00:19:07,330 --> 00:19:11,500
could wait for that to go to zero and

00:19:08,950 --> 00:19:14,770
then at the quiz and States we could

00:19:11,500 --> 00:19:16,240
deccan set and then do wake up and arch

00:19:14,770 --> 00:19:19,630
you kind of sort of used to work this

00:19:16,240 --> 00:19:21,760
way back in the old days but the first

00:19:19,630 --> 00:19:24,910
bug against it was reported in 2004 and

00:19:21,760 --> 00:19:28,390
a 512 byte CPU system massive contention

00:19:24,910 --> 00:19:31,570
right and so this has a scalability

00:19:28,390 --> 00:19:33,700
problem but that's ok there was a talk I

00:19:31,570 --> 00:19:33,970
gave about expedited grace periods on

00:19:33,700 --> 00:19:37,450
4th

00:19:33,970 --> 00:19:40,630
96 CPU systems at this event a couple

00:19:37,450 --> 00:19:44,200
years ago and this is a reprise of that

00:19:40,630 --> 00:19:45,280
we use a combining tree all right so

00:19:44,200 --> 00:19:46,930
what this thing is doing is this

00:19:45,280 --> 00:19:48,610
filtering quiescent states at the bottom

00:19:46,930 --> 00:19:50,680
and producing grace periods at the top

00:19:48,610 --> 00:19:52,510
so it's kind of pulling things in and

00:19:50,680 --> 00:19:53,800
funneling up and and getting a bunch of

00:19:52,510 --> 00:19:56,380
quiescent states and eventually saying

00:19:53,800 --> 00:19:58,150
ok we're done we all the readers are

00:19:56,380 --> 00:20:01,450
done we can safely free this old stuff

00:19:58,150 --> 00:20:04,240
and the bottom of the green stuff that's

00:20:01,450 --> 00:20:06,610
per CPU every CPU has an RC data

00:20:04,240 --> 00:20:09,310
structure and each of those has a flag

00:20:06,610 --> 00:20:11,140
that's CPU no QoS the CPU has not yet

00:20:09,310 --> 00:20:15,640
gone through a quiescent state so we're

00:20:11,140 --> 00:20:18,660
still have to wait for it now a group of

00:20:15,640 --> 00:20:22,120
CPUs has a leaf RCU node structure and

00:20:18,660 --> 00:20:24,640
that has a mask a bit mask and it has

00:20:22,120 --> 00:20:26,530
one bit freeze child if the bits set

00:20:24,640 --> 00:20:29,620
that child needs to report up to it and

00:20:26,530 --> 00:20:31,510
say I'm done and that in the tree can be

00:20:29,620 --> 00:20:38,050
up to four levels tall which in theory

00:20:31,510 --> 00:20:40,150
handles millions of CPUs and what

00:20:38,050 --> 00:20:42,430
happens is that once you get to a point

00:20:40,150 --> 00:20:44,620
you you clear the CPU no qus you go up

00:20:42,430 --> 00:20:47,620
you clear your bit if that bits 0 if the

00:20:44,620 --> 00:20:49,270
whole thing is 0 then you say great this

00:20:47,620 --> 00:20:51,040
node is done I can go to the next node

00:20:49,270 --> 00:20:53,380
clear that bit and keep going until

00:20:51,040 --> 00:20:54,520
there's some other bits set or until you

00:20:53,380 --> 00:20:56,100
get to the top and everything's 0 in

00:20:54,520 --> 00:20:59,290
which case you say great we're done now

00:20:56,100 --> 00:21:01,780
the cool thing about this is that

00:20:59,290 --> 00:21:04,450
there's a lock in the RC node structure

00:21:01,780 --> 00:21:07,270
but the contention is limited only the

00:21:04,450 --> 00:21:08,740
CPUs underneath it are going to be

00:21:07,270 --> 00:21:11,590
acquiring that lock in the common case

00:21:08,740 --> 00:21:14,680
and the same thing applies as you go up

00:21:11,590 --> 00:21:16,810
the tree each node of the tree only has

00:21:14,680 --> 00:21:18,880
one CPU per grace period coming up below

00:21:16,810 --> 00:21:20,740
it reporting which is going to be 30 you

00:21:18,880 --> 00:21:22,810
know 32 64 something like that a fairly

00:21:20,740 --> 00:21:25,300
small number and so no matter how many

00:21:22,810 --> 00:21:27,460
CPUs you have the level of contention on

00:21:25,300 --> 00:21:29,980
the tree at any point in the tree is is

00:21:27,460 --> 00:21:34,050
sharply bounded so this allows us to

00:21:29,980 --> 00:21:37,150
scale well still making things work ok

00:21:34,050 --> 00:21:39,220
so I'm not going to go through this what

00:21:37,150 --> 00:21:40,930
I'm going to do is I'm going to do this

00:21:39,220 --> 00:21:42,490
again showing italics for what change

00:21:40,930 --> 00:21:45,220
just give you an idea of the size of the

00:21:42,490 --> 00:21:47,020
change what we're gonna do in diagram

00:21:45,220 --> 00:21:47,860
form though is we're going to add

00:21:47,020 --> 00:21:50,200
another

00:21:47,860 --> 00:21:52,510
filled on the per CPU thing saying hey I

00:21:50,200 --> 00:21:54,100
deferred a quiescent state and we're

00:21:52,510 --> 00:21:56,920
gonna have a count of them at the leaf

00:21:54,100 --> 00:21:58,390
RCU node all right so the idea is if you

00:21:56,920 --> 00:22:00,250
get there you say all right

00:21:58,390 --> 00:22:02,020
we did our she read unlock but we're

00:22:00,250 --> 00:22:03,760
disabled okay fine clear we're at a

00:22:02,020 --> 00:22:05,830
quittin state sort of but we're deferred

00:22:03,760 --> 00:22:08,950
and also atomically increment the

00:22:05,830 --> 00:22:10,570
counter in the arse you note and then

00:22:08,950 --> 00:22:12,010
the rule is eventually we come to a

00:22:10,570 --> 00:22:13,960
place where our enabled we say how I'm

00:22:12,010 --> 00:22:17,140
enabled oh I've got a deferred quiescent

00:22:13,960 --> 00:22:19,270
state clear clear the that indication in

00:22:17,140 --> 00:22:21,490
our see data go up and Hahnel he

00:22:19,270 --> 00:22:24,520
decrement the defer QoS on the node if

00:22:21,490 --> 00:22:28,240
that's zero and if the mask is zero then

00:22:24,520 --> 00:22:30,880
propagate up the tree okay so we just

00:22:28,240 --> 00:22:33,100
have a way of telling our Cu to wait

00:22:30,880 --> 00:22:35,140
until everything's enabled this whole

00:22:33,100 --> 00:22:41,320
chain of things is done and it can

00:22:35,140 --> 00:22:42,790
proceed okay and this is kind of a again

00:22:41,320 --> 00:22:43,960
the italics for what change there's not

00:22:42,790 --> 00:22:45,490
a huge amount of changes that for the

00:22:43,960 --> 00:22:47,559
next slide there's some additional stuff

00:22:45,490 --> 00:22:49,830
because when we enable we have to do

00:22:47,559 --> 00:22:54,570
more work but still this isn't too bad

00:22:49,830 --> 00:22:57,730
which means it's time to start coding

00:22:54,570 --> 00:23:00,309
now for core R see you I have kind of a

00:22:57,730 --> 00:23:04,330
discipline where I write it in ink on

00:23:00,309 --> 00:23:06,370
paper and usually I get a pager too and

00:23:04,330 --> 00:23:08,020
I've totally got a total mess which

00:23:06,370 --> 00:23:10,059
means I set those pieces of paper over

00:23:08,020 --> 00:23:12,040
here and I get a couple more pieces of

00:23:10,059 --> 00:23:13,270
paper and and recopy at fixing the

00:23:12,040 --> 00:23:14,860
errors for example right here you can

00:23:13,270 --> 00:23:16,590
see up there there's that thing with two

00:23:14,860 --> 00:23:19,419
lines under it that's a mistake

00:23:16,590 --> 00:23:21,010
so that means I'm not done yet I'm gonna

00:23:19,419 --> 00:23:22,840
make another copy I'm gonna fix that I'm

00:23:21,010 --> 00:23:25,600
gonna take their I left a case out of

00:23:22,840 --> 00:23:27,130
the can if condition and when I end up

00:23:25,600 --> 00:23:28,840
with two copies that are identical at

00:23:27,130 --> 00:23:32,350
the end that means I'm done and it's now

00:23:28,840 --> 00:23:33,880
time to type it into the computer this

00:23:32,350 --> 00:23:35,679
kind of forces a self code review

00:23:33,880 --> 00:23:36,730
multiple of them because you type the

00:23:35,679 --> 00:23:39,340
code in the computer you never look at

00:23:36,730 --> 00:23:40,990
it again that's I mean there's you look

00:23:39,340 --> 00:23:43,090
at it again but the place where's is a

00:23:40,990 --> 00:23:46,150
bug a Murphy guarantees you don't look

00:23:43,090 --> 00:23:47,620
at that and the bug will persist if you

00:23:46,150 --> 00:23:50,549
do it this way you have to look at it

00:23:47,620 --> 00:23:50,549
each time to go through Willie

00:23:55,990 --> 00:24:02,420
so Willie asks if I've ever had two

00:23:59,570 --> 00:24:03,880
identical copies and start typing in and

00:24:02,420 --> 00:24:07,370
fighting bug when I'm typing it in

00:24:03,880 --> 00:24:08,990
sometimes more embarrassingly is I type

00:24:07,370 --> 00:24:10,280
it in and it's there for several years I

00:24:08,990 --> 00:24:12,700
realized the whole thing was stupid I

00:24:10,280 --> 00:24:15,920
should have written in the first place

00:24:12,700 --> 00:24:18,110
so yeah I mean the all these things are

00:24:15,920 --> 00:24:20,450
ways of reducing probability of error

00:24:18,110 --> 00:24:24,200
and reducing risk I don't know a way to

00:24:20,450 --> 00:24:25,490
eliminate to tie entirely sorry anyway

00:24:24,200 --> 00:24:27,559
at this point this is just part of a

00:24:25,490 --> 00:24:29,390
page and there's five pages total which

00:24:27,559 --> 00:24:31,730
is this is kind of reasonable this is

00:24:29,390 --> 00:24:33,559
kind of encouraging except that I forgot

00:24:31,730 --> 00:24:35,750
about granted task queuing install

00:24:33,559 --> 00:24:38,450
warnings expired grace periods so I need

00:24:35,750 --> 00:24:40,190
to do some more work and then I end up

00:24:38,450 --> 00:24:44,870
with eight pages and this is part of a

00:24:40,190 --> 00:24:48,080
page again except that I realized at

00:24:44,870 --> 00:24:50,929
that point that I've got this sequence

00:24:48,080 --> 00:24:54,740
I'm not handling correctly you see I

00:24:50,929 --> 00:24:56,240
start with RC read lock and it might get

00:24:54,740 --> 00:24:59,510
preempted and we'll talk about why this

00:24:56,240 --> 00:25:02,030
is a matters later and then we disable

00:24:59,510 --> 00:25:03,679
preemption and then we do the unlock and

00:25:02,030 --> 00:25:04,880
it says great I'm done with the grace

00:25:03,679 --> 00:25:07,640
period I'll set the thing deferring

00:25:04,880 --> 00:25:09,980
myself and then we do another read lock

00:25:07,640 --> 00:25:11,120
and then we enable preemption and then

00:25:09,980 --> 00:25:15,230
we get to the read unlock and now the

00:25:11,120 --> 00:25:17,059
thing is this second reads that critical

00:25:15,230 --> 00:25:19,280
section the second RC read lock are

00:25:17,059 --> 00:25:22,160
skewed unlock pair needs to block the

00:25:19,280 --> 00:25:24,559
original grace period but already

00:25:22,160 --> 00:25:28,040
changed state at the RC read unlock the

00:25:24,559 --> 00:25:28,910
first one saying I don't have to and so

00:25:28,040 --> 00:25:30,320
this is a bug

00:25:28,910 --> 00:25:32,840
it means the grace period would be too

00:25:30,320 --> 00:25:37,010
short and I haven't taken to account

00:25:32,840 --> 00:25:39,140
this now I could fix this I've done more

00:25:37,010 --> 00:25:40,730
complicated things but then it's not

00:25:39,140 --> 00:25:42,890
really hard failure it's something that

00:25:40,730 --> 00:25:45,530
you know needs more state I need to

00:25:42,890 --> 00:25:47,960
carry more state to fix it and how many

00:25:45,530 --> 00:25:49,210
people have seen this quotation yeah how

00:25:47,960 --> 00:25:51,320
I'm gonna read it it's bears repeating

00:25:49,210 --> 00:25:54,200
debugging is twice as hard as writing

00:25:51,320 --> 00:25:55,340
the code in the first place therefore if

00:25:54,200 --> 00:25:57,770
you write the code as cleverly as

00:25:55,340 --> 00:26:00,610
possible you are by definition not smart

00:25:57,770 --> 00:26:02,540
enough debug it Brian W Carnahan and

00:26:00,610 --> 00:26:04,750
there's always the question of are you

00:26:02,540 --> 00:26:07,400
smart enough to test it

00:26:04,750 --> 00:26:07,970
anyway that this is too I could make

00:26:07,400 --> 00:26:09,800
this work

00:26:07,970 --> 00:26:12,350
I made worse things work but this is a

00:26:09,800 --> 00:26:13,520
hint that there might be better waited

00:26:12,350 --> 00:26:17,750
to it I should spend some time looking

00:26:13,520 --> 00:26:20,090
right so back to the drawing board so

00:26:17,750 --> 00:26:21,890
the thing is the problem I had was that

00:26:20,090 --> 00:26:23,210
there was this DQ operation that I

00:26:21,890 --> 00:26:26,630
haven't explained it I will with some

00:26:23,210 --> 00:26:27,950
diagrams coming up and it happened and

00:26:26,630 --> 00:26:29,570
it prevented the later readers from

00:26:27,950 --> 00:26:30,980
realizing that they need were still in

00:26:29,570 --> 00:26:33,890
the way of the grace period so why not

00:26:30,980 --> 00:26:35,960
just defer the DQ operation so let's

00:26:33,890 --> 00:26:38,300
explain what this means we have this we

00:26:35,960 --> 00:26:40,790
have more state here this is still the

00:26:38,300 --> 00:26:47,270
pre state this is still the way RC

00:26:40,790 --> 00:26:48,710
worked before 4.20 - RC 1 and we've got

00:26:47,270 --> 00:26:51,590
the stuff we had before but the leaves

00:26:48,710 --> 00:26:53,990
also have a blocked task list and a

00:26:51,590 --> 00:26:55,280
grace so there's a waiting list of tasks

00:26:53,990 --> 00:26:57,290
and there's been a pointer in that list

00:26:55,280 --> 00:26:58,790
that's GP tasks that's gonna say which

00:26:57,290 --> 00:27:01,610
of those tasks are blocking the current

00:26:58,790 --> 00:27:04,700
grace period so let's say that if some

00:27:01,610 --> 00:27:07,550
cpu over on the leaf RC node on the left

00:27:04,700 --> 00:27:11,510
there that is blocking the current grace

00:27:07,550 --> 00:27:14,260
period and it's running task a alright

00:27:11,510 --> 00:27:16,880
well let's hit the right button maybe

00:27:14,260 --> 00:27:18,110
let's say the task a is preempted now

00:27:16,880 --> 00:27:19,490
it's still blocking the current grace

00:27:18,110 --> 00:27:21,650
period and we have to keep track of that

00:27:19,490 --> 00:27:23,150
one thing we could do is just make

00:27:21,650 --> 00:27:26,030
synchronize our so you scan the entire

00:27:23,150 --> 00:27:27,710
task list but task lists can be at least

00:27:26,030 --> 00:27:29,210
100,000 tasks and maybe they millions

00:27:27,710 --> 00:27:33,230
look nice now so that sounded like kind

00:27:29,210 --> 00:27:35,270
of a bad plan so what we do instead is

00:27:33,230 --> 00:27:35,930
we have a hook from the scheduler that's

00:27:35,270 --> 00:27:38,300
been there forever

00:27:35,930 --> 00:27:40,040
and if we're preempted inside a read

00:27:38,300 --> 00:27:43,670
side critical section we queue that task

00:27:40,040 --> 00:27:45,710
on the corresponding leaf RC node

00:27:43,670 --> 00:27:47,750
structure and we put on the block cast

00:27:45,710 --> 00:27:48,980
list and if it is blocking the current

00:27:47,750 --> 00:27:52,310
race for it and we're saying it is now

00:27:48,980 --> 00:27:53,570
we make GP tasks point to it so what

00:27:52,310 --> 00:27:56,840
we're doing is we're keeping track of

00:27:53,570 --> 00:27:58,310
the little pieces of the tasks list that

00:27:56,840 --> 00:28:01,460
we actually need to pay attention to in

00:27:58,310 --> 00:28:02,900
this case right now only task a so ok

00:28:01,460 --> 00:28:04,760
it's been preempted we switch to task B

00:28:02,900 --> 00:28:05,930
maybe task B was had his priority

00:28:04,760 --> 00:28:09,860
boosted because somebody else wanted

00:28:05,930 --> 00:28:11,510
this lock and now task b's priorities

00:28:09,860 --> 00:28:14,990
Lord because a release the lock and that

00:28:11,510 --> 00:28:16,670
meet a seek resumes well ok let's say

00:28:14,990 --> 00:28:17,870
task B was also in an RC reach that

00:28:16,670 --> 00:28:21,740
critical section we have to

00:28:17,870 --> 00:28:23,750
as well and we do okay now because task

00:28:21,740 --> 00:28:26,120
B started after the grace period we

00:28:23,750 --> 00:28:29,659
don't have to wait on it so GP TAS still

00:28:26,120 --> 00:28:32,059
points to task a so only task a is

00:28:29,659 --> 00:28:33,710
blocking the current grace period task B

00:28:32,059 --> 00:28:37,460
if it's still around would block B

00:28:33,710 --> 00:28:39,620
blocking the next one all right so this

00:28:37,460 --> 00:28:41,570
structure allows us to just focus on the

00:28:39,620 --> 00:28:43,909
few tasks that we care about and allows

00:28:41,570 --> 00:28:48,679
us ignore almost all the tasks list

00:28:43,909 --> 00:28:50,480
hopefully all right then of course Tasi

00:28:48,679 --> 00:28:53,210
is resuming sooner or later it will get

00:28:50,480 --> 00:28:56,120
our C read unlock and when that happens

00:28:53,210 --> 00:28:58,610
it needs to remove itself from the lists

00:28:56,120 --> 00:29:01,190
ok I'm not in the way anymore and it

00:28:58,610 --> 00:29:02,809
also needs to update GP tasks now what

00:29:01,190 --> 00:29:04,520
it would normally do or what it could do

00:29:02,809 --> 00:29:06,679
is it would point it to the tasks

00:29:04,520 --> 00:29:08,330
following it because it's not blocking

00:29:06,679 --> 00:29:09,860
things anymore but the next guy still is

00:29:08,330 --> 00:29:11,360
so it pointed down there but there is no

00:29:09,860 --> 00:29:14,120
next guy so it just sits it to null

00:29:11,360 --> 00:29:18,679
instead and so we end up with this state

00:29:14,120 --> 00:29:20,750
and and then we don't have anybody

00:29:18,679 --> 00:29:22,010
blocking the grace period on that are so

00:29:20,750 --> 00:29:23,450
you know it so we can propagate things

00:29:22,010 --> 00:29:24,890
up again and possibly in the grace

00:29:23,450 --> 00:29:28,130
period if nobody else is blocking us

00:29:24,890 --> 00:29:29,990
still ok so we keep track of only the

00:29:28,130 --> 00:29:31,460
tasks we need to pay attention to we

00:29:29,990 --> 00:29:33,020
track which ones are blocking the grace

00:29:31,460 --> 00:29:35,000
period to give or take expedited stuff

00:29:33,020 --> 00:29:36,799
which is an interesting topic but we

00:29:35,000 --> 00:29:41,779
don't have time for it

00:29:36,799 --> 00:29:44,899
and then what happens is that we what we

00:29:41,779 --> 00:29:46,789
do and this is again existing code I'm

00:29:44,899 --> 00:29:48,649
just telling you more about it if we ran

00:29:46,789 --> 00:29:50,149
our seria done lock if we're blocking

00:29:48,649 --> 00:29:51,559
the current grace period because we were

00:29:50,149 --> 00:29:53,380
preempted we have to remove ourselves to

00:29:51,559 --> 00:29:57,860
the list and we have to update GP tasks

00:29:53,380 --> 00:30:00,080
ok and we added the thing about check of

00:29:57,860 --> 00:30:01,010
GP tasks in all there and again don't

00:30:00,080 --> 00:30:04,340
worry about this will just show

00:30:01,010 --> 00:30:06,080
differences later the key thing here are

00:30:04,340 --> 00:30:07,940
she already knows all about the block

00:30:06,080 --> 00:30:09,409
task list and knows all about the GP

00:30:07,940 --> 00:30:12,860
tasks pointer so if we can somehow

00:30:09,409 --> 00:30:17,659
leverage those guys hopefully it'll be

00:30:12,860 --> 00:30:20,270
simple or simpler anyway so what the

00:30:17,659 --> 00:30:23,090
idea here what we'd like to do is we'd

00:30:20,270 --> 00:30:24,950
like to change the our CV to unlock part

00:30:23,090 --> 00:30:26,510
so it only if it's fully enabled only

00:30:24,950 --> 00:30:28,820
then does it remove itself from the list

00:30:26,510 --> 00:30:30,080
and then we're gonna have to have some

00:30:28,820 --> 00:30:31,490
checks elsewhere when we're fully

00:30:30,080 --> 00:30:33,710
disabled saying

00:30:31,490 --> 00:30:36,679
on this list still okay I am so rude

00:30:33,710 --> 00:30:39,020
myself and propagate report the quiz and

00:30:36,679 --> 00:30:41,720
state up the tree if need be so this is

00:30:39,020 --> 00:30:44,120
actually kind of a small diff at the

00:30:41,720 --> 00:30:46,340
conceptual level and so you know there

00:30:44,120 --> 00:30:47,770
might be some hope right I said that

00:30:46,340 --> 00:30:50,030
before haven't I

00:30:47,770 --> 00:30:51,140
well first let's check to make sure it

00:30:50,030 --> 00:30:52,520
actually works in the example that

00:30:51,140 --> 00:30:55,580
caused the problem of the previous thing

00:30:52,520 --> 00:30:57,830
and what happens we get to this re-read

00:30:55,580 --> 00:30:59,720
lock and perhaps a disabled therefore we

00:30:57,830 --> 00:31:01,790
don't DQ ourselves we're still there and

00:30:59,720 --> 00:31:04,880
that means when we do the arts read lock

00:31:01,790 --> 00:31:07,340
we're already marked as blocking the

00:31:04,880 --> 00:31:09,070
grace period and so things work out

00:31:07,340 --> 00:31:14,750
we've got one big reader is required

00:31:09,070 --> 00:31:16,130
hopefully okay but we another thing we

00:31:14,750 --> 00:31:18,530
have to do is we have to make sure that

00:31:16,130 --> 00:31:22,250
something happens later so he does his

00:31:18,530 --> 00:31:25,010
final RC read unlock he's disabled and

00:31:22,250 --> 00:31:26,870
we're gonna do a net preempt an able or

00:31:25,010 --> 00:31:29,030
something later on to make it so that

00:31:26,870 --> 00:31:32,179
the quest and stakin reporter we have to

00:31:29,030 --> 00:31:33,260
make our so you do something and pj

00:31:32,179 --> 00:31:36,020
actually mentioned this in a previous

00:31:33,260 --> 00:31:38,660
talk we've got this RC you soft irq hair

00:31:36,020 --> 00:31:40,460
this one way that happens if we have BH

00:31:38,660 --> 00:31:43,100
disabled we can do a race off tire queue

00:31:40,460 --> 00:31:45,320
and that will cause the RC soft irq

00:31:43,100 --> 00:31:46,790
handler to start running when we're

00:31:45,320 --> 00:31:48,200
enabled although we might have

00:31:46,790 --> 00:31:50,120
preemption disable that point which case

00:31:48,200 --> 00:31:51,950
we'll have to change if preemption is

00:31:50,120 --> 00:31:53,809
disabled then we have to tell the

00:31:51,950 --> 00:31:56,510
scheduler to do a context switch which

00:31:53,809 --> 00:31:57,620
you can't do until we're enabled now

00:31:56,510 --> 00:32:01,280
both of these things are kind of

00:31:57,620 --> 00:32:03,140
expensive you know soft I refuse if

00:32:01,280 --> 00:32:04,790
especially have a soft RQ and vault D

00:32:03,140 --> 00:32:06,860
involved is a context switch and the

00:32:04,790 --> 00:32:08,660
schedules can do a context switch but

00:32:06,860 --> 00:32:10,640
fortunately you only have to do this if

00:32:08,660 --> 00:32:12,440
you have an unusually long reads I

00:32:10,640 --> 00:32:15,200
critical section or one that was unlucky

00:32:12,440 --> 00:32:17,240
enough to be preempted so normally this

00:32:15,200 --> 00:32:21,040
doesn't come into play but it'll be

00:32:17,240 --> 00:32:24,710
there when you need it is the theory

00:32:21,040 --> 00:32:28,520
guess what time to start coding I said

00:32:24,710 --> 00:32:32,570
that a couple times before didn't I and

00:32:28,520 --> 00:32:37,370
we're down to three pages that's that's

00:32:32,570 --> 00:32:39,140
a good sign you know and in fact I did

00:32:37,370 --> 00:32:41,000
up with eight commits and that was

00:32:39,140 --> 00:32:43,370
because I was being paranoid and so I

00:32:41,000 --> 00:32:45,620
took baby steps so I added the deferral

00:32:43,370 --> 00:32:47,030
and then I made the

00:32:45,620 --> 00:32:48,530
the synchronized scared and the

00:32:47,030 --> 00:32:50,710
synchronized are CVH redirect

00:32:48,530 --> 00:32:52,580
synchronized RCU and different steps oh

00:32:50,710 --> 00:32:54,740
yeah and I mentioned this thing about

00:32:52,580 --> 00:32:57,050
our Cobh had a needing some help and

00:32:54,740 --> 00:33:01,040
that's that commit there and the last

00:32:57,050 --> 00:33:03,080
three are the the the fourth from last

00:33:01,040 --> 00:33:05,690
one is a bug that I fixed and the last

00:33:03,080 --> 00:33:09,350
three are performance issues that I also

00:33:05,690 --> 00:33:13,070
fixed so you know that's not too bad but

00:33:09,350 --> 00:33:14,480
this is the theory the practice is that

00:33:13,070 --> 00:33:19,070
there were some prep work to make this

00:33:14,480 --> 00:33:21,050
work for one thing in the old days there

00:33:19,070 --> 00:33:22,730
were two counters that together said

00:33:21,050 --> 00:33:24,980
what the state of the grace period was

00:33:22,730 --> 00:33:26,720
and that means you have to acquire a

00:33:24,980 --> 00:33:27,710
lock to sample them to reliably tell

00:33:26,720 --> 00:33:30,080
what the state of the grace period is

00:33:27,710 --> 00:33:31,310
and that means that when we defer the

00:33:30,080 --> 00:33:32,330
quiescent state we have to know the

00:33:31,310 --> 00:33:34,160
grace period which means you have to

00:33:32,330 --> 00:33:35,750
grab a lock and Peter's not going to be

00:33:34,160 --> 00:33:38,330
Peters Ulster's not gonna be happy with

00:33:35,750 --> 00:33:41,420
me if I start if I err unconditionally

00:33:38,330 --> 00:33:44,060
grab scheduled my locks in the context

00:33:41,420 --> 00:33:45,560
which path fast path and nobody's be

00:33:44,060 --> 00:33:48,500
happy with me I've do it inside the

00:33:45,560 --> 00:33:51,010
scudding lock interrupt so what I did

00:33:48,500 --> 00:33:53,540
was I combined it to one integer in

00:33:51,010 --> 00:33:55,700
order to be able to just sample it with

00:33:53,540 --> 00:33:59,180
a read once possible with barriers

00:33:55,700 --> 00:34:03,920
depending what I'm doing and that took a

00:33:59,180 --> 00:34:06,590
few connects like 35 of them also

00:34:03,920 --> 00:34:09,560
because I'm merging all the RCU updates

00:34:06,590 --> 00:34:12,169
I'm raising block contention so it would

00:34:09,560 --> 00:34:14,690
be wise to decrease it for example using

00:34:12,169 --> 00:34:16,040
a the same trick I do an expediter on

00:34:14,690 --> 00:34:17,750
the normal grace phrase use funnel

00:34:16,040 --> 00:34:20,870
locking that wasn't so bad that was only

00:34:17,750 --> 00:34:24,470
three commits I had some pre-existing

00:34:20,870 --> 00:34:25,820
very rare RC of torture failures and if

00:34:24,470 --> 00:34:28,280
you're gonna take a meat ax thar see you

00:34:25,820 --> 00:34:30,200
like this required one of the things you

00:34:28,280 --> 00:34:32,630
want to do is make everything squeaky

00:34:30,200 --> 00:34:34,190
clean first and it's a good thing I did

00:34:32,630 --> 00:34:36,350
there were most of more false positives

00:34:34,190 --> 00:34:39,230
but the changes I would make would have

00:34:36,350 --> 00:34:42,320
made a couple of the real real problems

00:34:39,230 --> 00:34:45,740
so I had 15 commits getting things all

00:34:42,320 --> 00:34:47,210
nice and clean and and all that I knew I

00:34:45,740 --> 00:34:49,100
was gonna be adding bugs so I added some

00:34:47,210 --> 00:34:53,810
debugging code those another 17 commits

00:34:49,100 --> 00:34:55,820
and well leanness has been giving me a

00:34:53,810 --> 00:34:57,470
will get there and the other thing is I

00:34:55,820 --> 00:34:58,580
had to clean up the deferral right I had

00:34:57,470 --> 00:35:00,260
actually defer stuff

00:34:58,580 --> 00:35:03,380
and pick it up and do that and so that

00:35:00,260 --> 00:35:06,650
was a few commits that's making RC

00:35:03,380 --> 00:35:08,840
torture do its work of doing stuff and

00:35:06,650 --> 00:35:10,430
then yeah Lina's to be give me a hard

00:35:08,840 --> 00:35:12,340
time about how our shoes too complicated

00:35:10,430 --> 00:35:15,170
so I reduced things down to a single

00:35:12,340 --> 00:35:17,000
flavor of RC u I'm also gonna remove the

00:35:15,170 --> 00:35:20,210
capability at multiple flavors of RC to

00:35:17,000 --> 00:35:23,810
make it smaller and that was a few

00:35:20,210 --> 00:35:27,410
commits it's one hundred and seven of

00:35:23,810 --> 00:35:28,940
them and there were places where I've

00:35:27,410 --> 00:35:30,140
come across the Dakotas like that stupid

00:35:28,940 --> 00:35:35,450
and so there's some drive-by

00:35:30,140 --> 00:35:37,340
optimizations the the is actually the

00:35:35,450 --> 00:35:38,420
cool thing is the RC was actually

00:35:37,340 --> 00:35:40,910
several hundred lines shorter than it

00:35:38,420 --> 00:35:43,430
was when I started which is possibly

00:35:40,910 --> 00:35:45,590
encouraging but still Murphy's always be

00:35:43,430 --> 00:35:47,690
with us and in fact I'd like to call a

00:35:45,590 --> 00:35:50,150
round of applause with zero detest robot

00:35:47,690 --> 00:35:52,720
Intel for doing this they found a lot of

00:35:50,150 --> 00:35:57,200
stuff for me ahead of time so you know

00:35:52,720 --> 00:35:59,150
big thanks to them and also to my

00:35:57,200 --> 00:36:00,710
reviewers and we got new reviewers role

00:35:59,150 --> 00:36:02,450
of this Joel Fernandez the guy from

00:36:00,710 --> 00:36:04,960
Google who found some really cool stuff

00:36:02,450 --> 00:36:08,720
that was really good

00:36:04,960 --> 00:36:10,670
and of course consequences right I mean

00:36:08,720 --> 00:36:12,800
I've made a bunch of changes arse you

00:36:10,670 --> 00:36:14,300
and you know new codes usually less

00:36:12,800 --> 00:36:16,130
reliable and old codes there might be

00:36:14,300 --> 00:36:19,790
some problems now Courtney Dorsey

00:36:16,130 --> 00:36:22,850
tortures more reliable but an RC

00:36:19,790 --> 00:36:24,760
tortures become more nasty but there

00:36:22,850 --> 00:36:29,000
were some bugs I mean people found them

00:36:24,760 --> 00:36:31,100
so what's estimator liability based on

00:36:29,000 --> 00:36:32,620
proxy page of code as one of those

00:36:31,100 --> 00:36:36,860
unusual cases were being older is better

00:36:32,620 --> 00:36:38,680
they're rare take my word for it ok so

00:36:36,860 --> 00:36:41,150
let's look the median age of our C code

00:36:38,680 --> 00:36:42,770
over the past couple years and that

00:36:41,150 --> 00:36:45,770
looks a little scary we've dropped from

00:36:42,770 --> 00:36:49,580
four years down to about two point eight

00:36:45,770 --> 00:36:51,260
years that's a 30% decrease should be

00:36:49,580 --> 00:36:54,440
worried how many people think we should

00:36:51,260 --> 00:36:58,040
be worried how many think people think

00:36:54,440 --> 00:37:00,920
is okay wow you guys have confidence in

00:36:58,040 --> 00:37:04,910
yeah all right I've got a bridge I'd

00:37:00,920 --> 00:37:06,340
like to sell you anyway if you take a

00:37:04,910 --> 00:37:09,500
longer view things don't look so bad

00:37:06,340 --> 00:37:11,390
back in 2011 the median age is about one

00:37:09,500 --> 00:37:12,349
point six years it rose steadily about

00:37:11,390 --> 00:37:14,900
four and we've dropped off

00:37:12,349 --> 00:37:16,640
about 2.8 there were two things this

00:37:14,900 --> 00:37:18,950
work was actually a smaller component

00:37:16,640 --> 00:37:20,359
the tree RCU and there were also Elina

00:37:18,950 --> 00:37:21,200
shield um about making it simpler so

00:37:20,359 --> 00:37:24,349
there's a little piece that made it

00:37:21,200 --> 00:37:26,170
simpler there as well but i here to tell

00:37:24,349 --> 00:37:29,029
you there's more bugs to find i mean i

00:37:26,170 --> 00:37:31,220
i've had a lot of experience with my

00:37:29,029 --> 00:37:32,599
code and i know about how reliable at

00:37:31,220 --> 00:37:34,099
his skipper take even if i'm trying

00:37:32,599 --> 00:37:36,859
really hard which i was in this case

00:37:34,099 --> 00:37:38,809
there's bugs in fact yeah well we'll get

00:37:36,859 --> 00:37:42,769
later so another thing you can do is

00:37:38,809 --> 00:37:45,739
look at fixes so and these are fixes

00:37:42,769 --> 00:37:48,170
that i applied during this time thomas

00:37:45,739 --> 00:37:49,910
and sebastian found an RT thing it

00:37:48,170 --> 00:37:50,779
doesn't affect non RT particularly but

00:37:49,910 --> 00:37:53,960
it's a real bug

00:37:50,779 --> 00:37:55,880
it increases real time latency and that

00:37:53,960 --> 00:37:58,519
was unrelated I didn't introduce this as

00:37:55,880 --> 00:38:00,200
part of trying to merge flavors there

00:37:58,519 --> 00:38:01,579
was also one that David and Marius

00:38:00,200 --> 00:38:03,859
reported that was kind of embarrassing

00:38:01,579 --> 00:38:05,779
it it was a performance bug so it's not

00:38:03,859 --> 00:38:07,430
that big of a deal other than the fact

00:38:05,779 --> 00:38:08,989
that performance meant that in a certain

00:38:07,430 --> 00:38:13,069
weird case that they can make happen all

00:38:08,989 --> 00:38:16,309
the time at Amazon and the duration went

00:38:13,069 --> 00:38:17,210
from 100 milliseconds to 10 seconds for

00:38:16,309 --> 00:38:21,979
some reason they thought that was a

00:38:17,210 --> 00:38:24,499
problem not sure why and Dennis Dennis

00:38:21,979 --> 00:38:26,630
is really this is really cool I left a

00:38:24,499 --> 00:38:28,910
clock out in a certain place and 3rc you

00:38:26,630 --> 00:38:31,130
SRC you but the lock contention was so

00:38:28,910 --> 00:38:33,109
low that it almost never happened I

00:38:31,130 --> 00:38:34,670
think I saw it happened twice I was

00:38:33,109 --> 00:38:36,499
going what the heck because it was just

00:38:34,670 --> 00:38:39,799
you know and and he made it happen

00:38:36,499 --> 00:38:41,599
really often but beyond that he also

00:38:39,799 --> 00:38:44,089
diagnosed it and gave me a patch which

00:38:41,599 --> 00:38:47,259
method that's really cool I think that

00:38:44,089 --> 00:38:47,259
deserves a round of applause guys

00:38:48,160 --> 00:38:55,060
and in the entry our CEO I also did a

00:38:51,640 --> 00:38:59,020
had a latency problem which again only

00:38:55,060 --> 00:39:00,910
affects RT but it's real there's also

00:38:59,020 --> 00:39:03,610
these guys on the guys from Intel in

00:39:00,910 --> 00:39:08,220
China found unrelated self wake up bug

00:39:03,610 --> 00:39:12,490
and that was back in from 2014 and then

00:39:08,220 --> 00:39:13,870
Sebastian again found one from 2011 so

00:39:12,490 --> 00:39:17,350
if we look at the work I did during this

00:39:13,870 --> 00:39:19,960
time I'm gonna leave the bottom two off

00:39:17,350 --> 00:39:21,790
because they're from the history it

00:39:19,960 --> 00:39:24,130
looks like I doubled the bug rate for

00:39:21,790 --> 00:39:25,030
tree RCU and I probably did it again

00:39:24,130 --> 00:39:27,340
with this thing

00:39:25,030 --> 00:39:29,140
so best guess there's probably another

00:39:27,340 --> 00:39:31,350
tree RCU bug just on general principles

00:39:29,140 --> 00:39:36,400
there's probably several RC flavor bugs

00:39:31,350 --> 00:39:38,890
so if you have a formal verification

00:39:36,400 --> 00:39:40,960
tool this would be a good time to apply

00:39:38,890 --> 00:39:42,160
it to our see you you see there people

00:39:40,960 --> 00:39:43,540
have done that there's been three

00:39:42,160 --> 00:39:46,660
different efforts to do formal

00:39:43,540 --> 00:39:48,370
verification RC successfully but none of

00:39:46,660 --> 00:39:50,650
them have found bugs I didn't already

00:39:48,370 --> 00:39:53,860
know about a fact I've been torturing

00:39:50,650 --> 00:39:55,180
with ever since this is your chance to

00:39:53,860 --> 00:39:57,100
find a bug with a formal verification

00:39:55,180 --> 00:40:01,150
thing that I don't know about be the

00:39:57,100 --> 00:40:05,950
first anyway I expect more bugs because

00:40:01,150 --> 00:40:07,420
Murphy never sleeps and you know as we

00:40:05,950 --> 00:40:08,560
know making your software do exactly

00:40:07,420 --> 00:40:11,020
what you want is difficult undertaking

00:40:08,560 --> 00:40:13,440
and it's also not clear that what you

00:40:11,020 --> 00:40:16,090
wanted to do is what it needs to do

00:40:13,440 --> 00:40:19,150
ease-of-use issues can result in

00:40:16,090 --> 00:40:20,440
security holes this was the place where

00:40:19,150 --> 00:40:23,230
I made are so you harder to use and it

00:40:20,440 --> 00:40:24,730
need to be and we got a whole and also

00:40:23,230 --> 00:40:26,740
you can do all the nice statistics you

00:40:24,730 --> 00:40:29,110
want about reliability from testing but

00:40:26,740 --> 00:40:30,100
they're these black swans from usability

00:40:29,110 --> 00:40:32,560
bugs and other things you don't know

00:40:30,100 --> 00:40:34,840
about are seems to be a pretty good

00:40:32,560 --> 00:40:36,790
shape right now I mentioned the for

00:40:34,840 --> 00:40:39,010
clarification opportunity synchronized

00:40:36,790 --> 00:40:41,140
skid always waits on preempted things

00:40:39,010 --> 00:40:42,910
that's a possible risk Peter gave me a

00:40:41,140 --> 00:40:46,840
hard time about it I think it's ok we'll

00:40:42,910 --> 00:40:50,080
see of course our C seems a good shapes

00:40:46,840 --> 00:40:54,400
is famous last words this is the usual

00:40:50,080 --> 00:40:55,330
slide promoted by IBM legal and we have

00:40:54,400 --> 00:40:58,470
a little bit of time for some more

00:40:55,330 --> 00:40:58,470
questions that people have them yeah

00:40:58,530 --> 00:41:02,880
hope will do here and then there

00:41:01,380 --> 00:41:06,720
and I think we got a microphone there's

00:41:02,880 --> 00:41:08,640
a microphone well it's a Paul more than

00:41:06,720 --> 00:41:11,279
a security bug it looks like an API bug

00:41:08,640 --> 00:41:12,930
in the sense that synchronize Darcy you

00:41:11,279 --> 00:41:14,940
should probably take a parameter that

00:41:12,930 --> 00:41:16,319
says what is synchronizing against as

00:41:14,940 --> 00:41:20,220
opposed to the three variants that you

00:41:16,319 --> 00:41:21,539
have okay so for so that's an

00:41:20,220 --> 00:41:22,680
interesting question but then the guy

00:41:21,539 --> 00:41:24,359
could have just handed the wrong

00:41:22,680 --> 00:41:25,859
parameter synchronizer see you and how

00:41:24,359 --> 00:41:27,660
would I have known but right now what

00:41:25,859 --> 00:41:32,309
happens is synchronized RC doesn't have

00:41:27,660 --> 00:41:34,559
a parameter and does all of them leaving

00:41:32,309 --> 00:41:36,269
a you know you take a spin lock and

00:41:34,559 --> 00:41:38,819
don't unlock it

00:41:36,269 --> 00:41:41,279
I think the concern stems from the fact

00:41:38,819 --> 00:41:44,249
that due to proliferation of the various

00:41:41,279 --> 00:41:46,109
RC use there's no easy way to say what

00:41:44,249 --> 00:41:48,690
variant to use and I think that's what

00:41:46,109 --> 00:41:51,539
can I write now there's only one ok used

00:41:48,690 --> 00:41:53,910
to be three now there's one yep yes so

00:41:51,539 --> 00:41:57,900
it looks more like an API bug to me then

00:41:53,910 --> 00:41:59,910
it's I could argue that a bunch of ways

00:41:57,900 --> 00:42:01,559
maybe we should talk afterwards on and

00:41:59,910 --> 00:42:03,769
look at this more we had one up there

00:42:01,559 --> 00:42:03,769
somewhere

00:42:06,229 --> 00:42:14,579
yeah how is it for you to reproduce such

00:42:09,539 --> 00:42:17,069
bugs the API bug the one we first you

00:42:14,579 --> 00:42:18,719
update yeah so so the original one that

00:42:17,069 --> 00:42:20,549
caused leanest send me an email to begin

00:42:18,719 --> 00:42:24,779
with yeah yeah the original one let's

00:42:20,549 --> 00:42:26,549
say you know it's easy for me to refer

00:42:24,779 --> 00:42:29,819
do this I can introduce the bug but I

00:42:26,549 --> 00:42:35,160
wouldn't you know that's that's a human

00:42:29,819 --> 00:42:36,900
factors question right so in this case

00:42:35,160 --> 00:42:38,880
it was easy enough somebody did it we

00:42:36,900 --> 00:42:40,859
got one up behind you and they may

00:42:38,880 --> 00:42:43,650
overhear that I missed I guess not okay

00:42:40,859 --> 00:42:47,489
or they're being yeah if the updater

00:42:43,650 --> 00:42:49,619
side had called KPRC you instead of

00:42:47,489 --> 00:42:52,289
calling synchronize us you followed by a

00:42:49,619 --> 00:42:56,549
free would this have been the exact same

00:42:52,289 --> 00:42:59,999
bug yes it would have because K free RCU

00:42:56,549 --> 00:43:01,650
is goes little synchronize our CEO so

00:42:59,999 --> 00:43:03,599
one cool thing is that now you can use K

00:43:01,650 --> 00:43:06,680
free RC you for R should be locks good

00:43:03,599 --> 00:43:11,519
nor should we lock the H so yeah

00:43:06,680 --> 00:43:13,469
anything else if not I think it's lunch

00:43:11,519 --> 00:43:14,760
time so thank you very much for your

00:43:13,469 --> 00:43:15,610
time and attention and have a great

00:43:14,760 --> 00:43:23,050
rest of the conference

00:43:15,610 --> 00:43:23,050

YouTube URL: https://www.youtube.com/watch?v=hZX1aokdNiY


