Title: Patching through the snow: decentralised kernel CI on every patch
Publication date: 2020-01-09
Playlist: linux.conf.au 2019
Description: 
	Russell Currey

https://2019.linux.conf.au/schedule/presentation/234/

Just like the development of the kernel itself, its testing is all over the
place.  There are countless public kernel testing projects and probably even
more private ones, with hardware vendors testing what works on their own
machines and maintainers automating checks for what should go into their trees.
If you're a developer, you probably don't know about any of this unless someone
directly tells you.

The granularity of running these tests is similarly all over the place:
many test environments just look at mainline, many look at linux-next or
trees of specific maintainers, and some run on every patch, like the Intel
0-day bot.  If you're a developer, unless your patch doesn't compile, you're
probably not going to hear about it.

Projects that use pull requests on GitHub as a code submission method have it
easy: a developer sends a PR, some CI system magically tests it, and
developers and maintainers alike can quickly see if the code has issues.
The value in continuous integration is about quick feedback to the developer,
and saving precious time of reviewers and maintainers.

This is where snowpatch comes in, using Patchwork as the publicly visible
platform for test results on patches.  Tests can come in from anywhere,
even an internal lab of a hardware vendor, and have their results published
for the world to see within minutes of a patch being sent.  It's the closest
thing we have in the world of mailing lists to the simplicity of the GitHub
workflow, it's easy to get going, and it can function as decentralised as
the rest of kernel development.

We're going to cover how snowpatch works, why it's useful, what we're doing
with it currently, and look to the future to determine just how much we could
tell the world about a patch, only minutes after it's been sent.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:05,420 --> 00:00:10,679
thank you very much Andrew hello

00:00:07,470 --> 00:00:13,440
everyone so I'm gonna be talking about

00:00:10,679 --> 00:00:16,980
as Andrew said decentralized kernel CI

00:00:13,440 --> 00:00:19,470
what that means what's been going on in

00:00:16,980 --> 00:00:23,130
the community overall and what I've been

00:00:19,470 --> 00:00:25,890
doing so my name is Russell I work at

00:00:23,130 --> 00:00:27,000
IBM at laws labs in Canberra you're

00:00:25,890 --> 00:00:31,050
probably sick of hearing people from

00:00:27,000 --> 00:00:32,640
there so far today I was working on the

00:00:31,050 --> 00:00:34,980
PCI stack for a while but now I'm

00:00:32,640 --> 00:00:39,840
decided I want to be cool so I'm working

00:00:34,980 --> 00:00:41,610
on hardening so they're gonna be talking

00:00:39,840 --> 00:00:43,320
about kernel CA what's going on I may be

00:00:41,610 --> 00:00:46,920
talking about my project snow patch and

00:00:43,320 --> 00:00:50,340
how its hopefully going to change the

00:00:46,920 --> 00:00:52,860
world in that space so what exactly is

00:00:50,340 --> 00:00:55,379
CI and a lot of people use the term and

00:00:52,860 --> 00:00:58,680
maybe don't know exactly what it meant

00:00:55,379 --> 00:01:00,120
meant so this is a quote from from

00:00:58,680 --> 00:01:01,559
Microsoft that says that CI is the

00:01:00,120 --> 00:01:03,629
process of automating the build and

00:01:01,559 --> 00:01:05,400
testing of code every time a team member

00:01:03,629 --> 00:01:09,140
commits changes to version control so

00:01:05,400 --> 00:01:13,280
it's from very much the agile world of

00:01:09,140 --> 00:01:15,360
development that we all loathe probably

00:01:13,280 --> 00:01:16,979
but I think the key thing a lot of

00:01:15,360 --> 00:01:18,750
people miss when I talk about CI a is

00:01:16,979 --> 00:01:20,640
feedback and there's a quote here that I

00:01:18,750 --> 00:01:22,860
quite like that CI at its core is about

00:01:20,640 --> 00:01:24,810
feedback and it's about implementing a

00:01:22,860 --> 00:01:26,040
process that facilitates feedback so the

00:01:24,810 --> 00:01:28,259
problems can be identified and corrected

00:01:26,040 --> 00:01:29,939
early in the development process when

00:01:28,259 --> 00:01:32,549
it's easy to diagnose a correction so

00:01:29,939 --> 00:01:34,020
the sooner that a developer knows that

00:01:32,549 --> 00:01:35,460
something they did has a problem the

00:01:34,020 --> 00:01:39,090
sooner they fix it the better the world

00:01:35,460 --> 00:01:42,299
is so when you send a patch to a mailing

00:01:39,090 --> 00:01:44,310
list let's say it has some obvious bug

00:01:42,299 --> 00:01:46,500
in it and this is an obvious bug you

00:01:44,310 --> 00:01:49,220
know maybe you'll get a reply in a day

00:01:46,500 --> 00:01:52,079
or two from a reviewer or maintainer who

00:01:49,220 --> 00:01:53,430
looks and tells you maybe no one even

00:01:52,079 --> 00:01:55,229
looks at your patch maybe no one cares

00:01:53,430 --> 00:01:56,909
but if you found out about that

00:01:55,229 --> 00:01:58,770
straightaway maybe ten minutes half an

00:01:56,909 --> 00:02:00,270
hour after you sent it then you have a

00:01:58,770 --> 00:02:03,479
v2 on the list straight away and save

00:02:00,270 --> 00:02:07,770
everyone a bunch of time there's another

00:02:03,479 --> 00:02:10,140
big factor here which is see how I can

00:02:07,770 --> 00:02:12,840
obviously run tests to catch things that

00:02:10,140 --> 00:02:13,560
humans aren't so good at doing whether

00:02:12,840 --> 00:02:17,099
that's something

00:02:13,560 --> 00:02:18,450
we obscure or whether it's just it takes

00:02:17,099 --> 00:02:20,250
a lot of time to find out whether a

00:02:18,450 --> 00:02:21,840
patch does something or doesn't so the

00:02:20,250 --> 00:02:24,569
whole code submission process gets

00:02:21,840 --> 00:02:27,720
faster the faster you can fix something

00:02:24,569 --> 00:02:29,520
without humans help the faster that your

00:02:27,720 --> 00:02:32,010
code gets in the less time reviewers and

00:02:29,520 --> 00:02:33,569
maintain this have to spend so what

00:02:32,010 --> 00:02:35,940
would this look like in a kernel context

00:02:33,569 --> 00:02:38,010
well you send a patch then some

00:02:35,940 --> 00:02:39,840
automated system merges the patch to

00:02:38,010 --> 00:02:42,150
whatever branch it's supposed to go to

00:02:39,840 --> 00:02:43,709
you would run tests on it to be

00:02:42,150 --> 00:02:45,750
something simple starting out just like

00:02:43,709 --> 00:02:47,100
check patch which everyone always runs

00:02:45,750 --> 00:02:50,670
before they send their patches of course

00:02:47,100 --> 00:02:54,600
and then building up to doing a build

00:02:50,670 --> 00:02:56,430
matrix the various configs and platforms

00:02:54,600 --> 00:02:57,810
and architectures and then getting into

00:02:56,430 --> 00:02:59,549
some heavier tests if you have the

00:02:57,810 --> 00:03:01,260
infrastructure like actually booting the

00:02:59,549 --> 00:03:02,430
thing you could do self tests you could

00:03:01,260 --> 00:03:05,040
do all sorts of stuff and use a space

00:03:02,430 --> 00:03:06,900
depending on what you wanted to do and

00:03:05,040 --> 00:03:09,209
then the most important thing is at the

00:03:06,900 --> 00:03:12,630
end reporting to the results back to the

00:03:09,209 --> 00:03:13,980
developer so what exactly makes this

00:03:12,630 --> 00:03:14,400
hard projects do this type of thing all

00:03:13,980 --> 00:03:16,019
the time

00:03:14,400 --> 00:03:17,670
you know if you look at github any

00:03:16,019 --> 00:03:19,920
decently sized project on github is

00:03:17,670 --> 00:03:22,500
gonna have all sorts of test automation

00:03:19,920 --> 00:03:24,390
going on but it's a lot easier to work

00:03:22,500 --> 00:03:27,150
with things like github and get lab that

00:03:24,390 --> 00:03:30,030
it is with a patch on a mailing list so

00:03:27,150 --> 00:03:33,390
this is kind of why this is a patch that

00:03:30,030 --> 00:03:35,549
was sent to a mailing this is the this

00:03:33,390 --> 00:03:37,980
is the start of a patch from Christopher

00:03:35,549 --> 00:03:39,780
Roy to the Mike's PPC Devon L KML

00:03:37,980 --> 00:03:41,940
mailing list and you can see a bunch of

00:03:39,780 --> 00:03:44,280
stuff about the body of code inside here

00:03:41,940 --> 00:03:45,870
you can see that this is revision 13 of

00:03:44,280 --> 00:03:46,950
this particular series of course you

00:03:45,870 --> 00:03:48,930
don't know where the rest of the series

00:03:46,950 --> 00:03:51,329
is you just have an email you can see

00:03:48,930 --> 00:03:53,340
this is patch seven of ten and that's

00:03:51,329 --> 00:03:54,959
pretty cool but where's the other nine

00:03:53,340 --> 00:03:57,389
do we know that all of them have even

00:03:54,959 --> 00:03:58,680
made it to the mailing list yet this is

00:03:57,389 --> 00:04:00,600
a bunch of stuff that takes a lot of

00:03:58,680 --> 00:04:03,239
fiddling to do whereas if you look at

00:04:00,600 --> 00:04:04,950
this Wow look all fifteen commits of the

00:04:03,239 --> 00:04:06,450
hair it's already in a branch that you

00:04:04,950 --> 00:04:09,630
can go ahead and test when you have a

00:04:06,450 --> 00:04:12,209
patch you don't know that it was applied

00:04:09,630 --> 00:04:14,730
to to maintain this next branch or Linux

00:04:12,209 --> 00:04:16,229
next or you know main line from a month

00:04:14,730 --> 00:04:17,700
ago that's a bunch of information you

00:04:16,229 --> 00:04:18,900
don't know which obviously you need to

00:04:17,700 --> 00:04:21,000
know if you want to actually go test the

00:04:18,900 --> 00:04:23,550
thing so it's a lot more difficult to

00:04:21,000 --> 00:04:25,260
get the metadata you need to actually do

00:04:23,550 --> 00:04:27,419
continuous integration when you're

00:04:25,260 --> 00:04:29,699
dealing with a mailing list and that's

00:04:27,419 --> 00:04:31,590
the fundamental problem here that makes

00:04:29,699 --> 00:04:33,259
this difficult mailing lists have a huge

00:04:31,590 --> 00:04:35,610
lack of metadata and it's hard to know

00:04:33,259 --> 00:04:38,610
not only stuff about the body of code

00:04:35,610 --> 00:04:40,020
itself but also where it sits in terms

00:04:38,610 --> 00:04:41,849
of the development cycle has the

00:04:40,020 --> 00:04:43,020
maintainer merged it in which case we

00:04:41,849 --> 00:04:45,749
probably don't need to go test it if

00:04:43,020 --> 00:04:47,460
it's been rejected we don't need to go

00:04:45,749 --> 00:04:48,840
test two that there's a new revision of

00:04:47,460 --> 00:04:53,099
that series we don't need to go test it

00:04:48,840 --> 00:04:54,779
so all of that stuff is is difficult so

00:04:53,099 --> 00:04:55,830
before I get into how we solve all these

00:04:54,779 --> 00:04:58,409
difficult problems let's talk about

00:04:55,830 --> 00:05:02,159
who's already doing kernel CI in the

00:04:58,409 --> 00:05:05,009
community so we have the biggest one of

00:05:02,159 --> 00:05:07,740
courses until zero day service there's a

00:05:05,009 --> 00:05:09,779
mentioned kernel co.org that's not doing

00:05:07,740 --> 00:05:10,979
the type of patch by patch testing

00:05:09,779 --> 00:05:15,120
seattle i'm talking about today they're

00:05:10,979 --> 00:05:17,699
looking at having a gazillion boards in

00:05:15,120 --> 00:05:19,409
a big test farm and then building stuff

00:05:17,699 --> 00:05:21,689
on them all the time but if you try to

00:05:19,409 --> 00:05:23,159
build every single patch on every

00:05:21,689 --> 00:05:25,830
mailing list on every piece of hardware

00:05:23,159 --> 00:05:26,819
imaginable the world would explode so

00:05:25,830 --> 00:05:29,789
that's not quite what I'm talking about

00:05:26,819 --> 00:05:31,439
today there's snow patch which we're

00:05:29,789 --> 00:05:33,479
mostly running on Linux PPC dev which is

00:05:31,439 --> 00:05:34,770
what I'm talking about and I'm sure

00:05:33,479 --> 00:05:36,060
there's plenty of maintainer --zz that

00:05:34,770 --> 00:05:37,229
have some amount of automation for

00:05:36,060 --> 00:05:38,279
what's going on there lists because

00:05:37,229 --> 00:05:39,689
there's too much work to do otherwise

00:05:38,279 --> 00:05:41,550
and there's probably some other stuff

00:05:39,689 --> 00:05:43,080
than another way up so please do tell me

00:05:41,550 --> 00:05:44,909
about those let's talk about about

00:05:43,080 --> 00:05:47,039
zero-day which is kind of the the big

00:05:44,909 --> 00:05:48,389
bone of a holiday safaris according to

00:05:47,039 --> 00:05:49,979
that website a test against more than a

00:05:48,389 --> 00:05:51,659
hundred different kernel configs does

00:05:49,979 --> 00:05:54,449
all sorts of clever things right

00:05:51,659 --> 00:05:56,129
especially on x86 it does substantive

00:05:54,449 --> 00:05:58,080
analysis it runs a bunch of performance

00:05:56,129 --> 00:06:00,659
tests and what kind of flag if something

00:05:58,080 --> 00:06:02,189
makes something drastically slower it

00:06:00,659 --> 00:06:05,490
will send you an email report on failure

00:06:02,189 --> 00:06:07,500
so I'm sure you've all seen zero day but

00:06:05,490 --> 00:06:10,770
tell you that you birds 32-bit because

00:06:07,500 --> 00:06:13,020
that happens quite a lot and zero day is

00:06:10,770 --> 00:06:14,729
a really impressive project the downside

00:06:13,020 --> 00:06:16,649
is that it's proprietary it's run by a

00:06:14,729 --> 00:06:18,479
team at Intel so you can't take it and

00:06:16,649 --> 00:06:22,289
go ahead and do whatever the heck you

00:06:18,479 --> 00:06:23,430
want similarly a lot of those fancy

00:06:22,289 --> 00:06:25,430
stuff they do they only do for the

00:06:23,430 --> 00:06:28,500
architecture that they care about so

00:06:25,430 --> 00:06:29,729
zero day is awesome but you can't get to

00:06:28,500 --> 00:06:32,430
do what you want and the other thing is

00:06:29,729 --> 00:06:33,870
that when you only send a report on

00:06:32,430 --> 00:06:35,819
failure you don't have any kind of

00:06:33,870 --> 00:06:39,060
receipt saying that yes we have actually

00:06:35,819 --> 00:06:40,830
tested this patch and it builds if

00:06:39,060 --> 00:06:41,190
you're a maintainer and you're not on an

00:06:40,830 --> 00:06:43,050
X

00:06:41,190 --> 00:06:45,180
six lists or something you can't

00:06:43,050 --> 00:06:46,560
actually know for sure that this Pat

00:06:45,180 --> 00:06:48,000
you're thinking about merging has passed

00:06:46,560 --> 00:06:49,980
all the smoke test that the bothers run

00:06:48,000 --> 00:06:52,110
you don't have that receipt you only get

00:06:49,980 --> 00:06:56,280
a receipt if it's broken but you can't

00:06:52,110 --> 00:06:57,900
confirm that it's not broken so how

00:06:56,280 --> 00:07:00,450
exactly do we bridge the gap with you

00:06:57,900 --> 00:07:06,210
know kids these days and their github

00:07:00,450 --> 00:07:07,830
and get lab well if it's it's a problem

00:07:06,210 --> 00:07:09,450
too because you know if this was a lot

00:07:07,830 --> 00:07:10,770
of other projects we could say okay cool

00:07:09,450 --> 00:07:12,630
we'll just run a git lab instance I'll

00:07:10,770 --> 00:07:14,610
put it on github and do it that way but

00:07:12,630 --> 00:07:15,930
everyone knows that's not gonna happen

00:07:14,610 --> 00:07:17,160
we can't just up with the entire

00:07:15,930 --> 00:07:19,470
development of the kernel that works so

00:07:17,160 --> 00:07:21,420
well I mean we've got you know very

00:07:19,470 --> 00:07:22,890
large very distributed decentralized

00:07:21,420 --> 00:07:25,050
project here that you can't just apply

00:07:22,890 --> 00:07:27,090
traditional methodologies to so how

00:07:25,050 --> 00:07:28,860
exactly do we do this and as you can

00:07:27,090 --> 00:07:33,350
tell by me being up here I have opinions

00:07:28,860 --> 00:07:37,350
on this so my my suggested solution

00:07:33,350 --> 00:07:40,530
comes in the form of of using patchwork

00:07:37,350 --> 00:07:41,460
as a source of state and patchwork if

00:07:40,530 --> 00:07:43,380
you haven't seen it before it's a

00:07:41,460 --> 00:07:44,700
web-based pack patch tracking system

00:07:43,380 --> 00:07:48,720
I'll show you more about in a second but

00:07:44,700 --> 00:07:50,160
this is what it looks like it's designed

00:07:48,720 --> 00:07:52,500
to supplement mailing lists and not

00:07:50,160 --> 00:07:53,850
replace them so it's a web-based view it

00:07:52,500 --> 00:07:56,040
gives you an idea of what's going on in

00:07:53,850 --> 00:07:59,580
the mailing list it will sort things

00:07:56,040 --> 00:08:02,010
into series it will let you know if a

00:07:59,580 --> 00:08:04,680
patch has been merged or superseded or

00:08:02,010 --> 00:08:06,270
what have you it's already used by the

00:08:04,680 --> 00:08:07,980
kernel so this is any crazy new

00:08:06,270 --> 00:08:09,870
infrastructure I think probably the

00:08:07,980 --> 00:08:11,880
majority of mailing lists are already on

00:08:09,870 --> 00:08:13,350
patchwork whether it's on kernel bottle

00:08:11,880 --> 00:08:15,090
or it's on all serves other which is the

00:08:13,350 --> 00:08:17,610
two biggest patchwork instances you can

00:08:15,090 --> 00:08:21,120
go to patchwork thought those things and

00:08:17,610 --> 00:08:22,470
find them and the important thing about

00:08:21,120 --> 00:08:24,480
patchwork is that you can push test

00:08:22,470 --> 00:08:26,430
results to it so when you have a list of

00:08:24,480 --> 00:08:28,260
a mailing list on patchwork you can see

00:08:26,430 --> 00:08:30,390
you know the series of they're on there

00:08:28,260 --> 00:08:31,890
that kind of state maybe they've already

00:08:30,390 --> 00:08:34,680
been most maybe they want to review

00:08:31,890 --> 00:08:36,990
whatever and you can go and see you know

00:08:34,680 --> 00:08:38,729
we'll do these things pass any kind of

00:08:36,990 --> 00:08:39,870
tests and the important thing for us in

00:08:38,729 --> 00:08:42,000
terms of people trying to build this

00:08:39,870 --> 00:08:44,250
continuous integration infrastructure is

00:08:42,000 --> 00:08:45,780
that it has a JSON API so you can do

00:08:44,250 --> 00:08:49,200
magic with it whether you're someone

00:08:45,780 --> 00:08:50,550
like me who just wants to automate a

00:08:49,200 --> 00:08:54,150
whole bunch of everything or if you're a

00:08:50,550 --> 00:08:54,930
maintainer who wants to add some magic

00:08:54,150 --> 00:08:57,750
to your

00:08:54,930 --> 00:08:59,280
merging process whatever so quick we'll

00:08:57,750 --> 00:09:03,180
get patchwork itself this is a patch

00:08:59,280 --> 00:09:05,550
list of the when XP PC dev mailing list

00:09:03,180 --> 00:09:08,130
on the left you have you know every

00:09:05,550 --> 00:09:10,350
patch on the middle you've got the

00:09:08,130 --> 00:09:12,450
series there in so you can easily find

00:09:10,350 --> 00:09:17,240
what's actually in a series it tracks in

00:09:12,450 --> 00:09:17,240
this case I think that's axe fixes

00:09:17,570 --> 00:09:21,180
reviewed buyers and tested buyers I

00:09:19,590 --> 00:09:23,280
think and the important column here is

00:09:21,180 --> 00:09:25,620
the the SWF one if you can see that that

00:09:23,280 --> 00:09:27,930
is successors warnings and failures

00:09:25,620 --> 00:09:30,000
there's a test results so if you send a

00:09:27,930 --> 00:09:33,090
patch you really want the testers to be

00:09:30,000 --> 00:09:34,410
more than the FS I suppose on the right

00:09:33,090 --> 00:09:35,670
you can see a bunch of patch state now

00:09:34,410 --> 00:09:37,650
one important thing to know about patch

00:09:35,670 --> 00:09:38,940
work is that that patch stayed on the

00:09:37,650 --> 00:09:41,100
right in terms of things that have been

00:09:38,940 --> 00:09:42,480
accepted or rejected or what-have-you

00:09:41,100 --> 00:09:43,950
you're only going to get that

00:09:42,480 --> 00:09:45,450
information if your maintainer actually

00:09:43,950 --> 00:09:48,690
uses patch work so that's important to

00:09:45,450 --> 00:09:50,010
note so if we go into what a patch looks

00:09:48,690 --> 00:09:52,230
like it's awful this is what you get you

00:09:50,010 --> 00:09:56,040
can see the the patch itself you can see

00:09:52,230 --> 00:09:59,160
this accepted so this is a patch to do

00:09:56,040 --> 00:10:00,720
some DMA stuff from Christoph Helbig and

00:09:59,160 --> 00:10:03,480
you can see that it's got all these

00:10:00,720 --> 00:10:04,710
checks listed here so these are test

00:10:03,480 --> 00:10:07,110
results that have been sent to patch

00:10:04,710 --> 00:10:08,670
work for this patch automatically by

00:10:07,110 --> 00:10:10,320
snow patch I'll get into that a bit

00:10:08,670 --> 00:10:12,420
later but you know you can see here that

00:10:10,320 --> 00:10:14,040
we're doing a bunch of different tests

00:10:12,420 --> 00:10:15,060
first of all we're just doing check

00:10:14,040 --> 00:10:17,970
patch and then we're doing four

00:10:15,060 --> 00:10:19,860
different builds in our particular case

00:10:17,970 --> 00:10:21,540
of what we're running now the cool thing

00:10:19,860 --> 00:10:23,310
about these builds is that basically

00:10:21,540 --> 00:10:25,580
what we're doing is we are building the

00:10:23,310 --> 00:10:28,440
base branch with sparse

00:10:25,580 --> 00:10:30,180
then we are applying this patch on top

00:10:28,440 --> 00:10:31,830
of it we're running sparse again and

00:10:30,180 --> 00:10:33,030
then doing a smart dip of the spa's

00:10:31,830 --> 00:10:34,620
results to see if we get any new

00:10:33,030 --> 00:10:36,330
warnings or any less warnings because

00:10:34,620 --> 00:10:39,390
less warnings it's probably pretty good

00:10:36,330 --> 00:10:41,580
so that's kind of what you look that's

00:10:39,390 --> 00:10:43,830
what you see when you go to any patch

00:10:41,580 --> 00:10:46,320
that's on the list that that's running

00:10:43,830 --> 00:10:49,530
these kind of tests so why exactly would

00:10:46,320 --> 00:10:52,500
we use patch work well we could you know

00:10:49,530 --> 00:10:55,230
send by our email every single tests

00:10:52,500 --> 00:10:56,820
that we run on every single patch but I

00:10:55,230 --> 00:10:59,370
don't think anyone wants their email

00:10:56,820 --> 00:11:00,900
blowing up like that it's it's a bit too

00:10:59,370 --> 00:11:03,900
much we don't want to be invasive if

00:11:00,900 --> 00:11:06,480
people just refuse to look at what we

00:11:03,900 --> 00:11:08,660
run that's their business I suppose

00:11:06,480 --> 00:11:10,640
Patrick is already used in the kernel

00:11:08,660 --> 00:11:12,830
different maintainer some don't use it

00:11:10,640 --> 00:11:14,570
at all some use it a lot but it's

00:11:12,830 --> 00:11:15,620
already in the ecosystem I suppose it's

00:11:14,570 --> 00:11:17,450
already out there people are already

00:11:15,620 --> 00:11:19,280
used to it it doesn't change the

00:11:17,450 --> 00:11:21,710
workflow of developers there's nothing

00:11:19,280 --> 00:11:23,150
changes about how you submit code or how

00:11:21,710 --> 00:11:24,410
you get reviewed feedback or any of that

00:11:23,150 --> 00:11:26,480
cool thing about software development

00:11:24,410 --> 00:11:28,580
it's still centered on the mailing list

00:11:26,480 --> 00:11:30,740
this is just sort of a cleaner view of

00:11:28,580 --> 00:11:32,810
it and I think the key thing in terms of

00:11:30,740 --> 00:11:33,980
a continuous integration approach that

00:11:32,810 --> 00:11:36,110
can actually work in something is

00:11:33,980 --> 00:11:37,430
decentralized as the panel is the test

00:11:36,110 --> 00:11:38,900
results can come from absolutely

00:11:37,430 --> 00:11:40,400
anywhere you know you have a whole bunch

00:11:38,900 --> 00:11:42,800
of different individuals and companies

00:11:40,400 --> 00:11:44,120
submitting coats of the kernel they can

00:11:42,800 --> 00:11:46,190
all be running their own tests

00:11:44,120 --> 00:11:47,780
internally on their own hardware on the

00:11:46,190 --> 00:11:49,400
things that they individually care about

00:11:47,780 --> 00:11:51,770
and then they can send those results

00:11:49,400 --> 00:11:53,990
publicly where everyone can see so in a

00:11:51,770 --> 00:11:55,070
my dream fantasy world which you don't

00:11:53,990 --> 00:11:57,770
wanna know about everything in there but

00:11:55,070 --> 00:11:59,300
if one thing in there is that you know

00:11:57,770 --> 00:12:00,650
you have multiple companies working on

00:11:59,300 --> 00:12:02,240
stuff on a mailing list so the developer

00:12:00,650 --> 00:12:04,070
sends a patching and sees that you know

00:12:02,240 --> 00:12:05,960
it works on these two peoples hardware

00:12:04,070 --> 00:12:08,690
and it broke this guy's hardware so that

00:12:05,960 --> 00:12:10,550
kind of decentralized testing where none

00:12:08,690 --> 00:12:11,810
of those test environments can see each

00:12:10,550 --> 00:12:13,730
other right they're all internal to a

00:12:11,810 --> 00:12:17,390
company but the results from them can

00:12:13,730 --> 00:12:19,160
all be public so how exactly do we we do

00:12:17,390 --> 00:12:21,110
this how do we you know put all this

00:12:19,160 --> 00:12:22,790
magic together to make you know

00:12:21,110 --> 00:12:23,990
continuous integration of workflow that

00:12:22,790 --> 00:12:25,820
we run all the time when every single

00:12:23,990 --> 00:12:28,190
patch that someone sends to a mailing

00:12:25,820 --> 00:12:29,780
list well you know we get the patch and

00:12:28,190 --> 00:12:31,610
it's dependencies from the patchwork API

00:12:29,780 --> 00:12:34,250
so let's say we're testing you know

00:12:31,610 --> 00:12:36,110
patch seven out of ten then you know we

00:12:34,250 --> 00:12:37,430
need to find patches one through six and

00:12:36,110 --> 00:12:39,590
apply them in order first and then we

00:12:37,430 --> 00:12:42,110
apply number seven we go off make it out

00:12:39,590 --> 00:12:43,900
of branch and go test that so we apply

00:12:42,110 --> 00:12:46,280
it to every branch that we care about

00:12:43,900 --> 00:12:47,540
you know it's a bit difficult in kernel

00:12:46,280 --> 00:12:50,600
land because you don't know exactly what

00:12:47,540 --> 00:12:52,100
something was based off of typically so

00:12:50,600 --> 00:12:54,080
we applied on something that we care

00:12:52,100 --> 00:12:56,330
about we push that branch to a remote so

00:12:54,080 --> 00:12:57,320
that we have some testing thing that can

00:12:56,330 --> 00:12:59,510
go off and grab it and run with it

00:12:57,320 --> 00:13:00,860
trigger the tests wait for them to

00:12:59,510 --> 00:13:03,070
finish and push the results to patch

00:13:00,860 --> 00:13:06,230
work so that's the basic workflow and

00:13:03,070 --> 00:13:09,560
think that I wrote alongside gracious

00:13:06,230 --> 00:13:11,090
Minicon host andrew is snow patch so

00:13:09,560 --> 00:13:13,990
snow patches of rust program because

00:13:11,090 --> 00:13:16,160
again I'm really trying to be cool so so

00:13:13,990 --> 00:13:17,360
kind of automate this flow and it's

00:13:16,160 --> 00:13:18,650
essentially based around using the

00:13:17,360 --> 00:13:20,850
patchwork API as its source of

00:13:18,650 --> 00:13:22,709
information to go off in and

00:13:20,850 --> 00:13:25,529
do this process I actually started

00:13:22,709 --> 00:13:28,529
writing it El Cid along because I don't

00:13:25,529 --> 00:13:30,329
know why it's just what I did it's

00:13:28,529 --> 00:13:31,229
running in production now so and by in

00:13:30,329 --> 00:13:32,759
production I mean you know we're

00:13:31,229 --> 00:13:35,069
publicly pushing results running on

00:13:32,759 --> 00:13:36,419
every single patch that hits Linux PPC

00:13:35,069 --> 00:13:39,809
dev it's also running on a couple other

00:13:36,419 --> 00:13:42,479
lists and it's still early days very

00:13:39,809 --> 00:13:44,699
much in development but does work mostly

00:13:42,479 --> 00:13:47,699
and it's GPL as well so you can grab it

00:13:44,699 --> 00:13:49,559
in do we have the GPL it's you so in

00:13:47,699 --> 00:13:50,850
terms of aside from patch work the

00:13:49,559 --> 00:13:52,619
infrastructure that we used to do this

00:13:50,850 --> 00:13:54,389
obviously we need some kind of engine

00:13:52,619 --> 00:13:56,189
that can actually execute tests and

00:13:54,389 --> 00:13:59,910
right now I'm kind of sorry to say that

00:13:56,189 --> 00:14:03,299
right now we just support Jenkins yeah I

00:13:59,910 --> 00:14:04,649
know Jenkins has an API that we can

00:14:03,299 --> 00:14:06,119
start test with it does everything we

00:14:04,649 --> 00:14:07,499
needed to do but obviously we definitely

00:14:06,119 --> 00:14:09,709
wanna support more than this even if

00:14:07,499 --> 00:14:13,350
it's just something like a simple

00:14:09,709 --> 00:14:15,809
something like a simple you know command

00:14:13,350 --> 00:14:18,539
line runner that we can get results from

00:14:15,809 --> 00:14:19,619
return codes or whatever so patches

00:14:18,539 --> 00:14:20,850
welcome because we have some I don't

00:14:19,619 --> 00:14:22,109
want to just support Jenkins but right

00:14:20,850 --> 00:14:24,959
now that's what we're rolling with so

00:14:22,109 --> 00:14:27,659
let's look at an example job and this is

00:14:24,959 --> 00:14:30,479
the the sparse dipping workflow that I

00:14:27,659 --> 00:14:34,079
talked about before where we we have a

00:14:30,479 --> 00:14:37,199
sort of base branch that we we build and

00:14:34,079 --> 00:14:39,269
do sparse on then we apply the patch on

00:14:37,199 --> 00:14:41,009
top of it run that again and compare the

00:14:39,269 --> 00:14:43,799
sparse output to see if the same your

00:14:41,009 --> 00:14:45,449
removed warnings so we pause those two

00:14:43,799 --> 00:14:47,850
references in we pass where the repo is

00:14:45,449 --> 00:14:49,379
and a def config in this case we change

00:14:47,850 --> 00:14:51,449
DEFCON things all the time to switch

00:14:49,379 --> 00:14:53,339
between you know so you two bit and 64

00:14:51,449 --> 00:14:57,239
bit and then better than that kind of

00:14:53,339 --> 00:14:59,189
stuff for power so this is kind of the

00:14:57,239 --> 00:15:01,470
API call we're making in you know in

00:14:59,189 --> 00:15:04,049
theory hopefully we can do this with

00:15:01,470 --> 00:15:05,789
things that aren't Jenkins that's the

00:15:04,049 --> 00:15:07,319
dream so what do you need to get all

00:15:05,789 --> 00:15:08,729
this going well obviously you need you

00:15:07,319 --> 00:15:10,619
know local repository because that's how

00:15:08,729 --> 00:15:11,970
we apply things you need if you want to

00:15:10,619 --> 00:15:14,399
push results publicly then you're gonna

00:15:11,970 --> 00:15:16,289
need patchwork credentials and you need

00:15:14,399 --> 00:15:18,899
the projects maintain those permissions

00:15:16,289 --> 00:15:19,499
to do this so you know you know what you

00:15:18,899 --> 00:15:22,229
couldn't just

00:15:19,499 --> 00:15:23,519
pollute mailing lists with a billion

00:15:22,229 --> 00:15:25,379
worthless tests you do actually need

00:15:23,519 --> 00:15:28,649
permission from the maintainer before

00:15:25,379 --> 00:15:30,269
you can do the some patch work your

00:15:28,649 --> 00:15:31,889
Jenkins server in this case to actually

00:15:30,269 --> 00:15:34,019
execute your tests and then you need to

00:15:31,889 --> 00:15:34,620
be able to push your branch to somewhere

00:15:34,019 --> 00:15:37,230
that Jenkins

00:15:34,620 --> 00:15:38,730
grab it so you kind of throw all this

00:15:37,230 --> 00:15:40,500
together you tell snow patch about it

00:15:38,730 --> 00:15:42,540
with this this config file so this is

00:15:40,500 --> 00:15:44,250
where patchwork is where Jenkins is this

00:15:42,540 --> 00:15:46,140
is a project so it's willing to PPC dev

00:15:44,250 --> 00:15:48,060
we're saying that we're gonna try it to

00:15:46,140 --> 00:15:49,950
apply stuff to branches master and next

00:15:48,060 --> 00:15:52,050
we're telling it where we're gonna push

00:15:49,950 --> 00:15:54,570
things so that Jenkins can see it and

00:15:52,050 --> 00:15:56,610
then we tell it about job we're gonna

00:15:54,570 --> 00:15:59,610
run so in this case we're calling it

00:15:56,610 --> 00:16:01,980
build PB 64 le that's the name of the

00:15:59,610 --> 00:16:03,750
job in Jenkins to go call we tell it

00:16:01,980 --> 00:16:06,270
what parameters to populate with the

00:16:03,750 --> 00:16:08,010
branch so that magically creates in this

00:16:06,270 --> 00:16:10,560
case for there our sparse build we're

00:16:08,010 --> 00:16:13,020
telling no patch that its hefty which is

00:16:10,560 --> 00:16:14,880
a great word which essentially just

00:16:13,020 --> 00:16:17,010
indicates that we don't want to run this

00:16:14,880 --> 00:16:18,570
on you know patches 1 through 14 of a

00:16:17,010 --> 00:16:20,190
fifteen patch series we only want to run

00:16:18,570 --> 00:16:23,880
it on the complete series because it's

00:16:20,190 --> 00:16:26,070
too computationally heavy and we're

00:16:23,880 --> 00:16:28,140
setting some other parameters and so

00:16:26,070 --> 00:16:29,910
then you've run the thing in it will

00:16:28,140 --> 00:16:31,200
just do this for every single patch on

00:16:29,910 --> 00:16:33,090
your mailing list you know every single

00:16:31,200 --> 00:16:35,940
patch that you have on your mailing list

00:16:33,090 --> 00:16:37,350
you just go in there and you'll you'll

00:16:35,940 --> 00:16:40,530
have all these results in this case

00:16:37,350 --> 00:16:43,620
what's this one we have a patch from on

00:16:40,530 --> 00:16:47,490
that introduced a sparse warning on all

00:16:43,620 --> 00:16:49,020
PB c64 platforms and so from there

00:16:47,490 --> 00:16:50,400
obviously it's patch work below this you

00:16:49,020 --> 00:16:52,350
have a view of the commit message in the

00:16:50,400 --> 00:16:53,490
patch and all replies to the patch but

00:16:52,350 --> 00:16:55,460
if you go into any of these you'll get

00:16:53,490 --> 00:16:57,870
more detail in this case we click on the

00:16:55,460 --> 00:17:00,390
the new sparse warning we can see that

00:16:57,870 --> 00:17:01,710
something should that's dead and so this

00:17:00,390 --> 00:17:03,300
is just a simple example of something

00:17:01,710 --> 00:17:04,650
you can do with it this positive thing

00:17:03,300 --> 00:17:06,660
you could do whatever the heck it is you

00:17:04,650 --> 00:17:08,610
want obviously quite often we find

00:17:06,660 --> 00:17:11,190
things like build failures most commonly

00:17:08,610 --> 00:17:12,510
people forgetting that 32-bit exists but

00:17:11,190 --> 00:17:13,740
there's a lot more you can do with this

00:17:12,510 --> 00:17:15,090
the more you build out your testing

00:17:13,740 --> 00:17:16,410
infrastructure and maybe already have

00:17:15,090 --> 00:17:19,620
some testing infrastructure that you

00:17:16,410 --> 00:17:21,570
could kind of put in here as you build

00:17:19,620 --> 00:17:22,860
out that capability you can do a lot of

00:17:21,570 --> 00:17:24,720
stuff here and you can do a lot of cool

00:17:22,860 --> 00:17:26,130
things that humans are never going to

00:17:24,720 --> 00:17:27,360
test for or the humans are particularly

00:17:26,130 --> 00:17:30,330
good at seeing all that humans just

00:17:27,360 --> 00:17:32,520
don't really want to do so what exactly

00:17:30,330 --> 00:17:34,350
do I think that this kind of overview

00:17:32,520 --> 00:17:36,240
using patchwork as the source of

00:17:34,350 --> 00:17:37,740
knowledge is the way to go well as I

00:17:36,240 --> 00:17:39,660
said before it's existing infrastructure

00:17:37,740 --> 00:17:42,660
it's nothing new and crazy the results

00:17:39,660 --> 00:17:44,370
can come from anywhere so they can come

00:17:42,660 --> 00:17:45,750
from you know multiple different

00:17:44,370 --> 00:17:47,490
companies working on the same thing

00:17:45,750 --> 00:17:48,920
without those needing to interact

00:17:47,490 --> 00:17:51,690
individual

00:17:48,920 --> 00:17:52,890
suliman's the maintainer okay's it again

00:17:51,690 --> 00:17:55,740
you can do whatever it is you actually

00:17:52,890 --> 00:17:58,080
want to do whatever amount of testing or

00:17:55,740 --> 00:18:00,570
what-have-you it's no patch to let you

00:17:58,080 --> 00:18:03,300
do it and it complements mailing lists

00:18:00,570 --> 00:18:06,050
we're not you know uh pending any part

00:18:03,300 --> 00:18:08,700
of the kernel development process we are

00:18:06,050 --> 00:18:10,110
just supplementing it we're not doing

00:18:08,700 --> 00:18:11,880
anything radical or crazy here we're

00:18:10,110 --> 00:18:14,280
keeping the existing development

00:18:11,880 --> 00:18:16,230
methodology of the kernel so what else

00:18:14,280 --> 00:18:17,760
can you do with this aside from some of

00:18:16,230 --> 00:18:19,410
the stuff I've been doing what don't

00:18:17,760 --> 00:18:21,600
actually have to make you results public

00:18:19,410 --> 00:18:22,710
if you you know you're making some super

00:18:21,600 --> 00:18:24,180
cool piece of hardware and you want to

00:18:22,710 --> 00:18:25,620
see how much but it kicks and see if

00:18:24,180 --> 00:18:28,140
anyone who's contributing upstream

00:18:25,620 --> 00:18:29,670
somehow makes it slower well you can do

00:18:28,140 --> 00:18:31,200
that you can either use a public

00:18:29,670 --> 00:18:34,380
patchwork because your knowledge source

00:18:31,200 --> 00:18:36,630
for a mailing list and just not report

00:18:34,380 --> 00:18:38,130
the results upstream you could run your

00:18:36,630 --> 00:18:39,630
own internal patchwork and have a really

00:18:38,130 --> 00:18:40,920
nice view of every patch in the test

00:18:39,630 --> 00:18:43,110
results without you know your

00:18:40,920 --> 00:18:45,720
competitors knowing about it you can do

00:18:43,110 --> 00:18:47,490
some crazy stuff for performance I guess

00:18:45,720 --> 00:18:48,930
like even if you're you're really

00:18:47,490 --> 00:18:50,280
concerned about kernel development

00:18:48,930 --> 00:18:51,720
impacting the performance of your user

00:18:50,280 --> 00:18:54,120
space application you could do something

00:18:51,720 --> 00:18:56,190
like that well whatever it is you want

00:18:54,120 --> 00:19:02,130
this is just sort of a set of tools to

00:18:56,190 --> 00:19:03,390
make your to make your infrastructure

00:19:02,130 --> 00:19:05,100
easy to manage in terms of running

00:19:03,390 --> 00:19:07,580
things on every individual path this is

00:19:05,100 --> 00:19:09,690
just a set of tools to do that

00:19:07,580 --> 00:19:12,770
so yeah that's all I have thanks very

00:19:09,690 --> 00:19:12,770
much and any questions

00:19:24,140 --> 00:19:30,289
so Circle CI and Travis CI have a

00:19:27,350 --> 00:19:32,990
default setting to not build external

00:19:30,289 --> 00:19:37,039
pull requests from Fox because it can be

00:19:32,990 --> 00:19:39,320
insecure what processes or plans do you

00:19:37,039 --> 00:19:41,330
have for people sending malicious things

00:19:39,320 --> 00:19:42,500
to your mailing list yes this is an

00:19:41,330 --> 00:19:45,799
interesting problem this is something we

00:19:42,500 --> 00:19:48,200
kind of handle in terms of the at the

00:19:45,799 --> 00:19:49,909
test level I suppose another the snow

00:19:48,200 --> 00:19:52,190
patch automation level we definitely

00:19:49,909 --> 00:19:53,990
want to have something we haven't forget

00:19:52,190 --> 00:19:56,059
how exactly this would work yet but

00:19:53,990 --> 00:19:57,320
especially for some maybe some larger

00:19:56,059 --> 00:19:59,570
tests or the more involved having

00:19:57,320 --> 00:20:01,970
something that's kind of maintainer

00:19:59,570 --> 00:20:04,340
indicated I suppose so for anything that

00:20:01,970 --> 00:20:05,480
would be big or controversial or

00:20:04,340 --> 00:20:07,100
difficult to test it's kind of by

00:20:05,480 --> 00:20:08,419
default you don't run that test unless

00:20:07,100 --> 00:20:10,940
the maintainer looks out of the manual

00:20:08,419 --> 00:20:14,570
he says okay so evany see need some kind

00:20:10,940 --> 00:20:15,830
of mechanism for that ultimately you

00:20:14,570 --> 00:20:17,269
know you're executing code from Rams on

00:20:15,830 --> 00:20:19,850
the internet there's a lot you can do in

00:20:17,269 --> 00:20:21,769
terms of obvious cases like you know you

00:20:19,850 --> 00:20:23,029
need to manually approve something if it

00:20:21,769 --> 00:20:25,340
touches a made file because I make file

00:20:23,029 --> 00:20:27,440
can do whatever the heck at once so I

00:20:25,340 --> 00:20:28,549
kind of just comes down to making sure

00:20:27,440 --> 00:20:30,980
that the infrastructure you running this

00:20:28,549 --> 00:20:32,330
on isn't going to exploit if someone's

00:20:30,980 --> 00:20:34,820
trying to hack it by sending a crappy

00:20:32,330 --> 00:20:36,230
patch to a mailing list and also looking

00:20:34,820 --> 00:20:37,789
at the points of okay where do we

00:20:36,230 --> 00:20:40,880
actually need manual approvals to go

00:20:37,789 --> 00:20:42,320
ahead and do things yes it's an

00:20:40,880 --> 00:20:44,419
interesting question and they're

00:20:42,320 --> 00:20:46,639
difficult to solve problem fortunately

00:20:44,419 --> 00:20:48,260
we haven't I've never seen a you know

00:20:46,639 --> 00:20:51,130
hostile patch to our mailing list I've

00:20:48,260 --> 00:20:58,940
seen plenty of bad ones but maybe not

00:20:51,130 --> 00:21:00,320
maybe not that intentionally well we've

00:20:58,940 --> 00:21:02,269
tried some other stuff before in the

00:21:00,320 --> 00:21:05,750
graphics area but how do you deal with

00:21:02,269 --> 00:21:07,370
the whole base line like how do you know

00:21:05,750 --> 00:21:08,990
where all these patches apply to how do

00:21:07,370 --> 00:21:13,250
you figure out if that patch requires

00:21:08,990 --> 00:21:15,220
some other patch set that's there's kind

00:21:13,250 --> 00:21:17,929
of two things there the first one is the

00:21:15,220 --> 00:21:20,539
was supposed to apply to and the other

00:21:17,929 --> 00:21:22,100
one is the dependency issue so for the

00:21:20,539 --> 00:21:24,139
dependency issue we don't have a

00:21:22,100 --> 00:21:25,370
concrete solution yet in terms of okay

00:21:24,139 --> 00:21:27,710
let's say in the cover letter or a

00:21:25,370 --> 00:21:30,710
mailing list someone says this series

00:21:27,710 --> 00:21:33,169
depends on X other series that's still

00:21:30,710 --> 00:21:34,399
on the list hasn't been most yet we

00:21:33,169 --> 00:21:36,200
haven't figured out how we're going to

00:21:34,399 --> 00:21:38,269
do that because we really don't want

00:21:36,200 --> 00:21:40,940
have any sort of specific metadata to

00:21:38,269 --> 00:21:43,549
this on a mailing list or definitely not

00:21:40,940 --> 00:21:47,029
in a committed so we haven't solved that

00:21:43,549 --> 00:21:52,029
problem yet in terms of what branch it's

00:21:47,029 --> 00:21:54,830
supposed to apply to we have a way to

00:21:52,029 --> 00:21:57,169
for some projects that aren't the Linux

00:21:54,830 --> 00:22:01,159
kernel indicate you know it's alongside

00:21:57,169 --> 00:22:02,450
you in your email subject patch comma V

00:22:01,159 --> 00:22:03,710
something and it's supposed to apply to

00:22:02,450 --> 00:22:05,630
that branch that can work in that

00:22:03,710 --> 00:22:08,990
specific case otherwise we essentially

00:22:05,630 --> 00:22:10,309
just have a list of branches that could

00:22:08,990 --> 00:22:11,870
be useful we'll have like the maintain

00:22:10,309 --> 00:22:13,580
as next and Linux next and current

00:22:11,870 --> 00:22:14,659
upstream and we'll just apply it to all

00:22:13,580 --> 00:22:16,340
of them and if it applies and those

00:22:14,659 --> 00:22:17,929
price-price to go there so it's not a

00:22:16,340 --> 00:22:23,210
perfect answer but it does seem to work

00:22:17,929 --> 00:22:25,720
in practice so that's how we do that any

00:22:23,210 --> 00:22:25,720
other questions

00:22:32,050 --> 00:22:37,030
I have something that needs to be tossed

00:22:34,330 --> 00:22:38,860
a tested on a cluster at least two notes

00:22:37,030 --> 00:22:42,340
even more is better

00:22:38,860 --> 00:22:44,490
and cannot be done or integrated with

00:22:42,340 --> 00:22:49,900
what you have done here

00:22:44,490 --> 00:22:51,250
I repeat well I've done something which

00:22:49,900 --> 00:22:54,940
needs to be tested on a cluster

00:22:51,250 --> 00:22:57,610
consisting of at least two nodes for

00:22:54,940 --> 00:23:01,300
under I'm testing yeah storage locally

00:22:57,610 --> 00:23:04,960
let's say 100 geeks or so yes so there's

00:23:01,300 --> 00:23:06,490
no limitation here in this case would a

00:23:04,960 --> 00:23:09,100
current sort of you could write

00:23:06,490 --> 00:23:11,080
something to do that on the job run

00:23:09,100 --> 00:23:12,429
aside so you could definitely engineer

00:23:11,080 --> 00:23:13,960
something in Jenkins that could go off

00:23:12,429 --> 00:23:16,150
and spawn that for you there's no

00:23:13,960 --> 00:23:19,929
limitation on our side in terms of what

00:23:16,150 --> 00:23:22,510
you can test we'll just kind of start it

00:23:19,929 --> 00:23:25,570
for you and then you know whatever your

00:23:22,510 --> 00:23:26,920
your job or your test run it is goes off

00:23:25,570 --> 00:23:28,150
and does it so there wouldn't be any

00:23:26,920 --> 00:23:30,250
limitation there obviously that'll be a

00:23:28,150 --> 00:23:32,050
pain in the butt to actually write

00:23:30,250 --> 00:23:33,490
something that automates but you could

00:23:32,050 --> 00:23:34,540
definitely do that there's be nothing

00:23:33,490 --> 00:23:37,179
stopping you from doing that there any

00:23:34,540 --> 00:23:39,750
other particularly complex thing other

00:23:37,179 --> 00:23:42,750
than your ability to write it yeah

00:23:39,750 --> 00:23:42,750
anymore

00:23:44,420 --> 00:23:49,870
all right cool thank you very much Thank

00:23:47,600 --> 00:23:49,870

YouTube URL: https://www.youtube.com/watch?v=IRtBqPNsM9g


