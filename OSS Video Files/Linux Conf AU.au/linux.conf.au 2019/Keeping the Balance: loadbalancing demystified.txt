Title: Keeping the Balance: loadbalancing demystified
Publication date: 2020-01-09
Playlist: linux.conf.au 2019
Description: 
	Murali Suriar

https://2019.linux.conf.au/schedule/presentation/207/

Can you explain the entire path that an IP packet takes from your users to your binary? What about a web request? Do you understand the tradeoffs that different kinds of load balancing techniques make? If not, this talk is for you.

Load balancing is hard, and it is made up of many disparate technologies. It cuts across network, transport and application layers. We'll describe different flavours of load balancing (network, naming, application) and how they work. 

We will then discuss example use cases, and which load balancing approaches are most appropriate in each case. We'll also relate these to several design patterns for high-availability services that have developed over the years. Finally, we'll relate the techniques we've been discussing to well-known open source technologies and to the major cloud load balancing services.

You will come away with:
- An understanding of various load balancing techniques, and some of their high points and pitfalls.
- Some criteria by which to evaluate different load balancing technologies.
- A framework of heuristics to use when deciding what load balancing pattern(s) to use with your service.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:00,140 --> 00:00:13,590
now we have Morelli who is going to talk

00:00:03,750 --> 00:00:14,910
to us about load balancing okay can

00:00:13,590 --> 00:00:17,910
everyone hear me yes I can hear my own

00:00:14,910 --> 00:00:20,340
voice excellent good afternoon everyone

00:00:17,910 --> 00:00:22,650
my name is Murali Surya and this is a

00:00:20,340 --> 00:00:23,670
talk that a colleague and I Laura Nolan

00:00:22,650 --> 00:00:30,720
put together

00:00:23,670 --> 00:00:32,160
I literally just tested this thing this

00:00:30,720 --> 00:00:36,570
is a talk that a colleague and I put

00:00:32,160 --> 00:00:39,989
together primarily because there is very

00:00:36,570 --> 00:00:42,059
little reference material for how to do

00:00:39,989 --> 00:00:43,050
kind of integrated load balancing up and

00:00:42,059 --> 00:00:45,030
down the stack there are plenty of

00:00:43,050 --> 00:00:46,440
things that tell you this is how you do

00:00:45,030 --> 00:00:47,399
Network load balancing or this is how

00:00:46,440 --> 00:00:50,460
you do high availability

00:00:47,399 --> 00:00:52,620
how it how you do DNS load balancing or

00:00:50,460 --> 00:00:54,840
how you do high availability web servers

00:00:52,620 --> 00:00:57,780
there's very little talking about how to

00:00:54,840 --> 00:01:01,050
do top to bottom stuff that that is

00:00:57,780 --> 00:01:02,940
modern the last one I'm aware of is fear

00:01:01,050 --> 00:01:06,479
shlush loss Nagle's book from like the

00:01:02,940 --> 00:01:08,939
early 2000s I am a computer scientist

00:01:06,479 --> 00:01:11,189
and network engineer turn Network sree

00:01:08,939 --> 00:01:13,409
sree is google's take on on how to do

00:01:11,189 --> 00:01:15,330
operations with software I now work in

00:01:13,409 --> 00:01:18,119
storage but I spend about eight years

00:01:15,330 --> 00:01:19,350
doing networking things Laura went the

00:01:18,119 --> 00:01:21,570
other way so she started off as a

00:01:19,350 --> 00:01:22,979
software engineer then became a non

00:01:21,570 --> 00:01:28,500
networking necessary and then joined

00:01:22,979 --> 00:01:30,659
networking later so why are we talking

00:01:28,500 --> 00:01:33,630
about load balancing load balancing

00:01:30,659 --> 00:01:36,150
failures turn into dropped requests

00:01:33,630 --> 00:01:38,040
right the short version of this is that

00:01:36,150 --> 00:01:39,720
I and I suspect many other people in

00:01:38,040 --> 00:01:42,329
this room have spent a lot of time

00:01:39,720 --> 00:01:44,130
debugging things that turned out to be

00:01:42,329 --> 00:01:50,399
network networking load balancing

00:01:44,130 --> 00:01:52,110
failures the goal here is to start with

00:01:50,399 --> 00:01:54,390
a very simple topology and then layer

00:01:52,110 --> 00:01:56,070
existing sets of load balancing

00:01:54,390 --> 00:01:58,860
technologies on top of that to get to

00:01:56,070 --> 00:02:01,710
the point where we're describing what

00:01:58,860 --> 00:02:03,750
could be a fairly like large highly

00:02:01,710 --> 00:02:05,670
scalable architecture that this is not a

00:02:03,750 --> 00:02:07,619
this is how you should look dude load

00:02:05,670 --> 00:02:09,360
balancing talk this is a here are all

00:02:07,619 --> 00:02:11,190
the tools available to you and how they

00:02:09,360 --> 00:02:13,240
interact and what you should think about

00:02:11,190 --> 00:02:16,720
when you are choosing which

00:02:13,240 --> 00:02:18,040
those tools to use just because we

00:02:16,720 --> 00:02:19,180
needed to pick up at the top or the

00:02:18,040 --> 00:02:21,010
bottom that start to start with we're

00:02:19,180 --> 00:02:25,960
gonna start with kind of a network

00:02:21,010 --> 00:02:28,390
focused view and then move our way up so

00:02:25,960 --> 00:02:30,610
we'll start with a very simple web app

00:02:28,390 --> 00:02:34,330
right it said it's a static content

00:02:30,610 --> 00:02:36,430
service just serving photos of owls

00:02:34,330 --> 00:02:37,380
right the highest quality owls you've

00:02:36,430 --> 00:02:39,490
ever seen on the Internet

00:02:37,380 --> 00:02:41,620
those of you who aren't aware this is an

00:02:39,490 --> 00:02:42,880
actual reddit it has it's great during

00:02:41,620 --> 00:02:45,640
the Superbowl because there are lots of

00:02:42,880 --> 00:02:49,960
very confused people trying to work out

00:02:45,640 --> 00:02:51,160
why there are pictures of ours so but

00:02:49,960 --> 00:02:52,990
yeah we'll start with the web app and

00:02:51,160 --> 00:02:55,810
we'll start with the singles a single

00:02:52,990 --> 00:02:59,290
server a single machine we're going to

00:02:55,810 --> 00:03:02,070
hand wave a hand wave over how you scale

00:02:59,290 --> 00:03:04,150
your application right there are many

00:03:02,070 --> 00:03:06,240
there are many good references on that

00:03:04,150 --> 00:03:08,830
if you want a recommendation from me

00:03:06,240 --> 00:03:10,180
Martin Clinton's designing data

00:03:08,830 --> 00:03:11,950
intensive applications I forget the

00:03:10,180 --> 00:03:15,310
exact title but mark 11 data intensive

00:03:11,950 --> 00:03:16,840
applications is like fantastic book so

00:03:15,310 --> 00:03:18,070
your customer who is a vendor of our

00:03:16,840 --> 00:03:20,170
related products are setting up their

00:03:18,070 --> 00:03:22,150
first website superballs comm this is

00:03:20,170 --> 00:03:26,710
where we're starting

00:03:22,150 --> 00:03:29,670
and so the 99 10 99 times out of 100

00:03:26,710 --> 00:03:32,260
what this will end up looking like is

00:03:29,670 --> 00:03:36,190
you will have a server in a rack

00:03:32,260 --> 00:03:38,080
somewhere you will assign a public IP

00:03:36,190 --> 00:03:42,330
address we're using ipv4 just because

00:03:38,080 --> 00:03:48,250
laziness an ipv4 address to that server

00:03:42,330 --> 00:03:50,350
to 0 3 0 1 1 320 your Colo provider or

00:03:48,250 --> 00:03:52,480
your internet service providers edge

00:03:50,350 --> 00:03:53,860
ruses are advertising a prefix

00:03:52,480 --> 00:03:57,340
containing that IP address to the

00:03:53,860 --> 00:03:59,500
internet via bgp and you have a DNS

00:03:57,340 --> 00:04:01,600
provider somewhere and who is

00:03:59,500 --> 00:04:04,350
responsible who's authoritative for

00:04:01,600 --> 00:04:08,170
superballs comm and you tell them to

00:04:04,350 --> 00:04:11,620
serve up an a record for that name which

00:04:08,170 --> 00:04:13,890
points to the address of your server you

00:04:11,620 --> 00:04:15,880
might there's basically very little

00:04:13,890 --> 00:04:17,620
redundancy in this picture right if

00:04:15,880 --> 00:04:20,890
you're lucky your Colo provider will

00:04:17,620 --> 00:04:22,690
have redundant ARP links to the Internet

00:04:20,890 --> 00:04:24,340
right but other than that we haven't

00:04:22,690 --> 00:04:27,100
really put any kind of high availability

00:04:24,340 --> 00:04:29,380
in here at all and it's very hard to

00:04:27,100 --> 00:04:31,690
scale this right you're only scaling

00:04:29,380 --> 00:04:34,120
dimensions are what is the size of the

00:04:31,690 --> 00:04:35,950
link between your server and your Kohler

00:04:34,120 --> 00:04:38,250
provider Mike maybe it's one gig then it

00:04:35,950 --> 00:04:40,600
moves to 10 gig then it moves to 40 gig

00:04:38,250 --> 00:04:42,070
and the other thing is how big is your

00:04:40,600 --> 00:04:43,990
server and that's those are the only two

00:04:42,070 --> 00:04:48,850
things that you can you can fiddle with

00:04:43,990 --> 00:04:50,530
in this scenario it doesn't have load

00:04:48,850 --> 00:04:52,390
distribution right like there's one web

00:04:50,530 --> 00:04:53,740
server we can't serve any more traffic

00:04:52,390 --> 00:04:55,090
than it can handle so you can keep

00:04:53,740 --> 00:04:57,940
throwing money at whoever your hardware

00:04:55,090 --> 00:04:59,920
vendor is but but that's it you don't

00:04:57,940 --> 00:05:01,630
have any high availability really right

00:04:59,920 --> 00:05:03,610
like if your machine goes down or if any

00:05:01,630 --> 00:05:06,070
of those components goes down you are

00:05:03,610 --> 00:05:11,530
you are basically your customer is down

00:05:06,070 --> 00:05:13,120
they cannot serve their customers there

00:05:11,530 --> 00:05:16,240
is some amount of load distribution

00:05:13,120 --> 00:05:18,730
though right like network engineers just

00:05:16,240 --> 00:05:20,260
kind of do redundancy by definition just

00:05:18,730 --> 00:05:22,000
architectural you'll end up with

00:05:20,260 --> 00:05:24,310
redundant paths across the internet or

00:05:22,000 --> 00:05:28,900
even redundant paths between two points

00:05:24,310 --> 00:05:30,370
in a single data center so the network

00:05:28,900 --> 00:05:31,630
piece of this and we're mostly going to

00:05:30,370 --> 00:05:33,100
hand wave over it we'll talk about it a

00:05:31,630 --> 00:05:36,040
little bit of detail can be

00:05:33,100 --> 00:05:38,920
transparently increased in size mostly

00:05:36,040 --> 00:05:40,390
transparently to the user and similarly

00:05:38,920 --> 00:05:41,770
this is true on the public internet as

00:05:40,390 --> 00:05:47,020
well right there are many redundant

00:05:41,770 --> 00:05:49,630
paths through the public Internet so the

00:05:47,020 --> 00:05:51,280
problem here is we have some high

00:05:49,630 --> 00:05:52,840
availability but it's mostly outside of

00:05:51,280 --> 00:05:56,260
our control right it's in the control of

00:05:52,840 --> 00:05:58,450
our ISP or in Arcola provider and you

00:05:56,260 --> 00:06:00,490
know you have things like what happens

00:05:58,450 --> 00:06:01,810
if you have a flaky link inside your

00:06:00,490 --> 00:06:03,850
data center right let's say the link

00:06:01,810 --> 00:06:05,650
between your server and your your Colo

00:06:03,850 --> 00:06:07,510
provider is flaky is that your problem

00:06:05,650 --> 00:06:08,680
is that your Colo providers problem what

00:06:07,510 --> 00:06:12,820
can you even do about it if you only

00:06:08,680 --> 00:06:14,320
have the one link so we'll add the first

00:06:12,820 --> 00:06:17,500
thing you're going to do probably is

00:06:14,320 --> 00:06:19,060
you're going to a single either add a

00:06:17,500 --> 00:06:21,310
second server right let's say for

00:06:19,060 --> 00:06:23,050
whatever whatever reason where we have

00:06:21,310 --> 00:06:24,490
chosen raspberry PI's as a hardware

00:06:23,050 --> 00:06:27,460
platform because we've all gone to LCA

00:06:24,490 --> 00:06:28,480
and we've got a free one and so our

00:06:27,460 --> 00:06:30,040
raspberry pi I don't know what a

00:06:28,480 --> 00:06:31,600
raspberry pi can serve how many how many

00:06:30,040 --> 00:06:33,520
owl pictures are conserved but let's say

00:06:31,600 --> 00:06:35,590
conserve five our pictures a second

00:06:33,520 --> 00:06:38,560
right and so if we only have one of them

00:06:35,590 --> 00:06:40,840
5 out 5 concurrent cost a second is the

00:06:38,560 --> 00:06:43,660
most we can serve so maybe we want to do

00:06:40,840 --> 00:06:45,270
and request a second and so if we have

00:06:43,660 --> 00:06:47,740
greater than five we need to add another

00:06:45,270 --> 00:06:50,650
unit of increment rights and that's a

00:06:47,740 --> 00:06:52,900
step function up this is not a capacity

00:06:50,650 --> 00:06:54,280
planning talk either so that that's yet

00:06:52,900 --> 00:06:55,449
another talk so we'll just kind of

00:06:54,280 --> 00:06:59,380
ignore how you come up with these

00:06:55,449 --> 00:07:01,900
numbers so in our existing setup the way

00:06:59,380 --> 00:07:04,180
we would add another server is we would

00:07:01,900 --> 00:07:06,430
add another server it would get another

00:07:04,180 --> 00:07:08,800
IP address probably it's from within the

00:07:06,430 --> 00:07:11,470
same network block that our existing

00:07:08,800 --> 00:07:13,780
server is in that's not guaranteed and

00:07:11,470 --> 00:07:16,360
we would probably add that second IP

00:07:13,780 --> 00:07:19,919
address to the DNS records for our for

00:07:16,360 --> 00:07:22,150
our services name and that will

00:07:19,919 --> 00:07:23,470
depending on a multitude of things there

00:07:22,150 --> 00:07:25,900
are several people here who I suspect

00:07:23,470 --> 00:07:28,030
are interested in the DNS but like DNS

00:07:25,900 --> 00:07:29,860
client library behavior stub resolver

00:07:28,030 --> 00:07:32,370
behavior recursive resolver behavior

00:07:29,860 --> 00:07:34,990
like many different things can influence

00:07:32,370 --> 00:07:36,820
whether an end user sees two IP

00:07:34,990 --> 00:07:39,970
addresses or just one what order are

00:07:36,820 --> 00:07:41,919
they returned in but let's assume all of

00:07:39,970 --> 00:07:43,570
this works as specs and as designed and

00:07:41,919 --> 00:07:45,910
you have large enough amounts of load

00:07:43,570 --> 00:07:47,530
you will probably end up with about half

00:07:45,910 --> 00:07:52,600
of your load going between each of your

00:07:47,530 --> 00:07:54,130
servers and this is fine except when it

00:07:52,600 --> 00:07:56,380
server goes away so when a server goes

00:07:54,130 --> 00:07:58,960
away what happens about half of your

00:07:56,380 --> 00:08:01,450
clients will see turnouts right so they

00:07:58,960 --> 00:08:02,740
will get let's say they get both IP

00:08:01,450 --> 00:08:04,060
addresses back and you're relying on the

00:08:02,740 --> 00:08:06,039
client to pick between them and they

00:08:04,060 --> 00:08:09,430
pick randomly half of your clients will

00:08:06,039 --> 00:08:10,960
get timeouts someone will probably tweet

00:08:09,430 --> 00:08:12,430
at you unless you have monitoring and

00:08:10,960 --> 00:08:15,669
then you'll know before someone tweets

00:08:12,430 --> 00:08:17,110
at you so then the way you fix this is

00:08:15,669 --> 00:08:18,460
you change your DNS configuration right

00:08:17,110 --> 00:08:21,099
so what we've done here is we've taken

00:08:18,460 --> 00:08:24,430
dot 21 is the server that's died we've

00:08:21,099 --> 00:08:26,160
taken dot 21 out of the out of the DNS

00:08:24,430 --> 00:08:31,180
records on the left-hand side and

00:08:26,160 --> 00:08:33,010
eventually after a TTL after a time to

00:08:31,180 --> 00:08:36,900
live your users will be happy again

00:08:33,010 --> 00:08:39,279
we'll talk about TTL Xin a bit shortly

00:08:36,900 --> 00:08:40,750
some clients may be a smart about this

00:08:39,279 --> 00:08:43,930
right you depending on the clients

00:08:40,750 --> 00:08:45,640
software you're using excuse me the

00:08:43,930 --> 00:08:47,500
client software may say oh I've got two

00:08:45,640 --> 00:08:48,670
endpoints to connect to but one of them

00:08:47,500 --> 00:08:50,800
is dead so I'll just prefer the other

00:08:48,670 --> 00:08:52,810
one but if this is just a browser right

00:08:50,800 --> 00:08:53,800
you'd like that could be people using

00:08:52,810 --> 00:08:55,480
like

00:08:53,800 --> 00:08:58,029
Android Froyo or whatever who are trying

00:08:55,480 --> 00:08:59,529
to access your website like it's it's by

00:08:58,029 --> 00:09:03,370
no means guaranteed these clients will

00:08:59,529 --> 00:09:03,670
be what I would consider well-behaved so

00:09:03,370 --> 00:09:09,760
yeah

00:09:03,670 --> 00:09:10,930
TTL trade-offs there are two dimensions

00:09:09,760 --> 00:09:12,519
here right you can either have super

00:09:10,930 --> 00:09:14,769
super long TTL z-- or you can have very

00:09:12,519 --> 00:09:16,029
short TTL very few people do anything in

00:09:14,769 --> 00:09:17,649
the middle right and when I say super

00:09:16,029 --> 00:09:20,769
long I'm talking like a day or multiple

00:09:17,649 --> 00:09:23,950
days when I'm saying short order of ten

00:09:20,769 --> 00:09:24,970
seconds to five minutes right like I'd

00:09:23,950 --> 00:09:26,110
be interested to know what the actual

00:09:24,970 --> 00:09:27,519
distribution is for names on the

00:09:26,110 --> 00:09:30,399
internet but I suspect that people do

00:09:27,519 --> 00:09:33,370
one or the other if you have long TTLs

00:09:30,399 --> 00:09:35,380
then your users will not see any change

00:09:33,370 --> 00:09:38,860
you make for a significant period of

00:09:35,380 --> 00:09:40,959
time right like 86 400 or 600 whichever

00:09:38,860 --> 00:09:42,760
way around it is is the number that many

00:09:40,959 --> 00:09:45,070
people know if they've configured DNS

00:09:42,760 --> 00:09:47,709
zone files if you have that number set

00:09:45,070 --> 00:09:50,110
then any change you make will take at

00:09:47,709 --> 00:09:52,950
least one day probably longer for it to

00:09:50,110 --> 00:09:55,420
be visible to all of your users

00:09:52,950 --> 00:09:57,610
conversely with very short times to live

00:09:55,420 --> 00:09:59,350
this means there will be much higher

00:09:57,610 --> 00:10:01,180
load on your DNS infrastructure right

00:09:59,350 --> 00:10:03,310
because let's say you say this was this

00:10:01,180 --> 00:10:07,660
response this DNS response is only valid

00:10:03,310 --> 00:10:09,670
for five minutes then we we end up with

00:10:07,660 --> 00:10:11,950
significantly more load on the DNS with

00:10:09,670 --> 00:10:16,149
benefit that it means that changes we

00:10:11,950 --> 00:10:18,100
make to the DNS are more quickly visible

00:10:16,149 --> 00:10:20,020
to cut to your customers to the the

00:10:18,100 --> 00:10:21,899
endpoints that you're trying to direct

00:10:20,020 --> 00:10:24,160
to your service

00:10:21,899 --> 00:10:26,820
quick clients have to query the DNS more

00:10:24,160 --> 00:10:29,290
often which adds latency and you know

00:10:26,820 --> 00:10:31,000
various DNS implementations maybe have

00:10:29,290 --> 00:10:33,100
weird timeout bugs and whatever and that

00:10:31,000 --> 00:10:35,589
could add by significant amounts of user

00:10:33,100 --> 00:10:37,480
user visible latency the other big thing

00:10:35,589 --> 00:10:41,620
to bear in mind is the lower your TTL

00:10:37,480 --> 00:10:44,170
czar the higher the proportion of your

00:10:41,620 --> 00:10:45,490
era budget is consumed by DNS right so

00:10:44,170 --> 00:10:47,500
if you're deep like when you have

00:10:45,490 --> 00:10:49,839
shorted CTLs you need much more reliable

00:10:47,500 --> 00:10:51,459
dns because it's at any given time or

00:10:49,839 --> 00:10:54,730
any given request it's much more likely

00:10:51,459 --> 00:10:55,990
to be hitting dns in some form and the

00:10:54,730 --> 00:10:57,220
other thing to bear in mind is many

00:10:55,990 --> 00:10:58,810
client and many DNS client

00:10:57,220 --> 00:11:01,209
implementations stub resolver 'z and

00:10:58,810 --> 00:11:04,089
recursive will ignore TTL below a

00:11:01,209 --> 00:11:05,500
certain threshold right so I don't know

00:11:04,089 --> 00:11:07,600
what the spec says I'm going to hand

00:11:05,500 --> 00:11:09,819
wave ten minutes five minutes rather

00:11:07,600 --> 00:11:12,069
I've seen some people use 10 seconds but

00:11:09,819 --> 00:11:13,630
again you have to know what client what

00:11:12,069 --> 00:11:16,300
the set of DN clients you're using is

00:11:13,630 --> 00:11:17,680
and what they will or will not obey five

00:11:16,300 --> 00:11:20,819
minutes is like a reasonable rule of

00:11:17,680 --> 00:11:27,040
thumb for a lower bound on the internet

00:11:20,819 --> 00:11:29,529
so back to our story so a new story now

00:11:27,040 --> 00:11:30,970
we have these multiple DNS record

00:11:29,529 --> 00:11:33,220
multiple servers with different public

00:11:30,970 --> 00:11:35,380
IP addresses we have a DNS record the

00:11:33,220 --> 00:11:37,149
points of both of them we're now doing

00:11:35,380 --> 00:11:40,180
load distribution right we have multiple

00:11:37,149 --> 00:11:42,399
pieces of serving infrastructure we

00:11:40,180 --> 00:11:44,769
don't really have high availability

00:11:42,399 --> 00:11:46,329
right and the other thing that's right

00:11:44,769 --> 00:11:48,190
to bear in mind I'm saying load

00:11:46,329 --> 00:11:49,779
distribution here and the talk here and

00:11:48,190 --> 00:11:51,220
the talks title is about load balancing

00:11:49,779 --> 00:11:54,190
the reason I'm saying load distribution

00:11:51,220 --> 00:11:56,620
is because the DNS has no concept of how

00:11:54,190 --> 00:11:58,089
loaded or busy any one of these servers

00:11:56,620 --> 00:12:00,730
is right in our current setup

00:11:58,089 --> 00:12:02,079
it's just assuming that all queries cost

00:12:00,730 --> 00:12:03,970
about the same amount in terms of

00:12:02,079 --> 00:12:05,380
compute resources on your machines it

00:12:03,970 --> 00:12:07,930
assumes they all last about the same

00:12:05,380 --> 00:12:09,940
amount of time and so you'll you'll get

00:12:07,930 --> 00:12:11,529
kind of approximately equal load but if

00:12:09,940 --> 00:12:13,750
you have a mix of queries right like

00:12:11,529 --> 00:12:15,220
maybe some owls are very expensive to

00:12:13,750 --> 00:12:17,350
serve and some hours are very cheap to

00:12:15,220 --> 00:12:19,750
serve then there'll be all sorts of

00:12:17,350 --> 00:12:21,790
interfering effects here high

00:12:19,750 --> 00:12:23,709
availability is not a great story right

00:12:21,790 --> 00:12:25,779
so firstly you've got propagation delay

00:12:23,709 --> 00:12:30,130
which is which is a function of whatever

00:12:25,779 --> 00:12:31,930
TTL you've set in the DNS and the second

00:12:30,130 --> 00:12:34,360
thing is you don't really have health

00:12:31,930 --> 00:12:35,889
tracking right like most if you're

00:12:34,360 --> 00:12:39,279
running your own DNS infrastructure most

00:12:35,889 --> 00:12:40,540
of most DNS resolvers do not have or DNS

00:12:39,279 --> 00:12:42,730
name servers excuse me authoritative

00:12:40,540 --> 00:12:44,529
name servers do not have the concept of

00:12:42,730 --> 00:12:46,329
health checking right like if you're

00:12:44,529 --> 00:12:47,949
running in I don't know and say

00:12:46,329 --> 00:12:50,800
kubernetes or maybe you're running in a

00:12:47,949 --> 00:12:52,959
public cloud some cloud providers have a

00:12:50,800 --> 00:12:54,339
DNS product that can health check the

00:12:52,959 --> 00:12:57,069
health of an instance and remove it from

00:12:54,339 --> 00:12:58,750
from a DNS load balancing group but this

00:12:57,069 --> 00:13:01,420
varies very widely depending on what

00:12:58,750 --> 00:13:03,279
you're using in terms of flexibility and

00:13:01,420 --> 00:13:06,579
when I say flexibility this is for like

00:13:03,279 --> 00:13:08,620
humans operators or like automation to

00:13:06,579 --> 00:13:10,930
redirect traffic in response to either

00:13:08,620 --> 00:13:13,360
failures or for planned maintenance it's

00:13:10,930 --> 00:13:14,769
like yeah but this is going to turn like

00:13:13,360 --> 00:13:16,839
depending on what DNS provider you're

00:13:14,769 --> 00:13:19,569
using this could end up being editor

00:13:16,839 --> 00:13:21,010
zone file and then like SCP it or post

00:13:19,569 --> 00:13:22,780
it via HTTP and

00:13:21,010 --> 00:13:26,140
and then wait for it to propagate

00:13:22,780 --> 00:13:27,940
through whatever magic and it's and it's

00:13:26,140 --> 00:13:29,740
still gonna be quite slow and to be

00:13:27,940 --> 00:13:31,420
clear right this is not us ripping on

00:13:29,740 --> 00:13:33,610
the date on the DNS DNS was not designed

00:13:31,420 --> 00:13:35,140
for load balancing rate like Paul vixie

00:13:33,610 --> 00:13:37,660
like if any of you followed Paul vixie

00:13:35,140 --> 00:13:38,670
on public mailing lists he's like this

00:13:37,660 --> 00:13:40,420
is not what it's for

00:13:38,670 --> 00:13:42,070
unfortunately because it's in everything

00:13:40,420 --> 00:13:43,450
people end up using DNS for load

00:13:42,070 --> 00:13:48,430
balancing because what it's the knob

00:13:43,450 --> 00:13:50,560
they have available so the next thing

00:13:48,430 --> 00:13:52,570
here is DNS details are a problem right

00:13:50,560 --> 00:13:55,090
because even in the case where where's

00:13:52,570 --> 00:13:57,040
my failure slide even in this case where

00:13:55,090 --> 00:13:59,260
let's say we have five-minute DNS TTLs

00:13:57,040 --> 00:14:00,580
serving 50% of errors for five minutes

00:13:59,260 --> 00:14:03,010
is not a great story

00:14:00,580 --> 00:14:04,360
like I just it offends me on kind of a

00:14:03,010 --> 00:14:07,390
fundamental level so we need a better

00:14:04,360 --> 00:14:10,420
story for this and so the next thing

00:14:07,390 --> 00:14:12,430
people often do is they will add a

00:14:10,420 --> 00:14:13,810
network load balancer right and that's

00:14:12,430 --> 00:14:17,080
what this black box in the middle here

00:14:13,810 --> 00:14:18,760
is so probably it's going to be a

00:14:17,080 --> 00:14:20,590
cluster of network load balancers we

00:14:18,760 --> 00:14:22,750
drew one here because the diagram was

00:14:20,590 --> 00:14:25,990
going to get busy otherwise but you know

00:14:22,750 --> 00:14:28,330
lots of third-party vendors or you know

00:14:25,990 --> 00:14:29,590
these could be just commodity x86

00:14:28,330 --> 00:14:32,680
servers running some open source

00:14:29,590 --> 00:14:34,570
software but what you do here is you put

00:14:32,680 --> 00:14:36,970
the public IP address that's associated

00:14:34,570 --> 00:14:40,270
with your service website you put that

00:14:36,970 --> 00:14:43,000
on your load balancer and it then is

00:14:40,270 --> 00:14:45,880
configured to say for super requests to

00:14:43,000 --> 00:14:47,530
this public IP address here are my two

00:14:45,880 --> 00:14:49,420
possible backends which are now

00:14:47,530 --> 00:14:51,280
addressed out of private IP address

00:14:49,420 --> 00:14:53,530
space you may or may not put them in

00:14:51,280 --> 00:14:55,570
private air space right or in ipv6 you

00:14:53,530 --> 00:14:56,680
use maybe non route small space wouldn't

00:14:55,570 --> 00:14:58,300
be private well maybe it would be

00:14:56,680 --> 00:15:00,010
private this that gets into

00:14:58,300 --> 00:15:04,570
philosophical conversations which best

00:15:00,010 --> 00:15:07,410
discussed over a beer but this now gives

00:15:04,570 --> 00:15:09,910
you the ability to take servers out of

00:15:07,410 --> 00:15:11,890
out of rotation either for maintenance

00:15:09,910 --> 00:15:13,600
or in response to failure without any

00:15:11,890 --> 00:15:15,340
client visible changes right because the

00:15:13,600 --> 00:15:17,620
configuration is on a device you control

00:15:15,340 --> 00:15:20,320
the DNS is back to having a single IP

00:15:17,620 --> 00:15:21,760
address in the a record and so you could

00:15:20,320 --> 00:15:24,130
actually have really long T TLS with

00:15:21,760 --> 00:15:25,990
this setup right because your your high

00:15:24,130 --> 00:15:27,580
availability is actually not coming at

00:15:25,990 --> 00:15:31,990
the DNS level it's coming up the network

00:15:27,580 --> 00:15:33,550
level things to bear in mind this

00:15:31,990 --> 00:15:34,250
network load balancer will not know

00:15:33,550 --> 00:15:36,530
anything

00:15:34,250 --> 00:15:37,490
you're out most of the time well not

00:15:36,530 --> 00:15:39,380
know anything about your application

00:15:37,490 --> 00:15:40,670
layer protocol right all it will do is

00:15:39,380 --> 00:15:44,450
look at the IP header of incoming

00:15:40,670 --> 00:15:46,190
packets it will look at and possibly the

00:15:44,450 --> 00:15:48,140
the TCP header right so it'll look at

00:15:46,190 --> 00:15:50,780
source IP destination IP source port

00:15:48,140 --> 00:15:54,410
destination port and then pick whichever

00:15:50,780 --> 00:15:55,940
back-end to use it also has a ton of

00:15:54,410 --> 00:15:58,070
state in it which we'll talk about later

00:15:55,940 --> 00:15:59,420
as a form of network engineer state and

00:15:58,070 --> 00:16:02,780
network devices the thing I think is a

00:15:59,420 --> 00:16:05,060
terrible idea but it does give us a lot

00:16:02,780 --> 00:16:07,280
more high availability and control over

00:16:05,060 --> 00:16:08,960
traffic routing right maintaining one of

00:16:07,280 --> 00:16:12,950
the two individual servers becomes a lot

00:16:08,960 --> 00:16:15,860
a lot easier okay so now we're going to

00:16:12,950 --> 00:16:19,330
go off into network LAN for a bit and

00:16:15,860 --> 00:16:22,070
we're so we're talking I talked about

00:16:19,330 --> 00:16:23,630
network multipathing early on right like

00:16:22,070 --> 00:16:25,220
the physical the public Internet has a

00:16:23,630 --> 00:16:26,870
lot of multipathing your datacenter

00:16:25,220 --> 00:16:28,250
provider probably have many redundant

00:16:26,870 --> 00:16:31,870
paths between machines and their data

00:16:28,250 --> 00:16:35,900
centers mechanically how does this work

00:16:31,870 --> 00:16:38,000
network devices typically use either

00:16:35,900 --> 00:16:39,620
what's called five tuple or three tuple

00:16:38,000 --> 00:16:41,710
hashing will explain five tuple

00:16:39,620 --> 00:16:44,690
the process for three tuple is the same

00:16:41,710 --> 00:16:47,450
so let's say for a given destination you

00:16:44,690 --> 00:16:49,040
have n different possible paths you can

00:16:47,450 --> 00:16:52,210
take your a network device and you want

00:16:49,040 --> 00:16:55,790
to send to picking up 1.2.3.4 whatever

00:16:52,210 --> 00:16:57,920
and there are ten paths you can take how

00:16:55,790 --> 00:16:59,600
do you choose well the thing the

00:16:57,920 --> 00:17:01,730
industry has settled on is you look at

00:16:59,600 --> 00:17:03,620
the packet and you look at the source IP

00:17:01,730 --> 00:17:06,470
address the desk the destination IP

00:17:03,620 --> 00:17:08,720
address the protocol so TCP or UDP or

00:17:06,470 --> 00:17:11,360
ICMP or whatever and if it's a protocol

00:17:08,720 --> 00:17:12,800
that has port numbers TCP or UDP you

00:17:11,360 --> 00:17:14,420
then also look at your source port in

00:17:12,800 --> 00:17:16,970
your destination port so that that

00:17:14,420 --> 00:17:19,970
entire bit pattern you then produce a

00:17:16,970 --> 00:17:21,380
hash of it had like network hash

00:17:19,970 --> 00:17:23,240
functions is a whole other talk which

00:17:21,380 --> 00:17:24,650
which ones you should use but based on

00:17:23,240 --> 00:17:27,079
the output of that hash function for a

00:17:24,650 --> 00:17:28,580
given five tuple you then pick you you

00:17:27,079 --> 00:17:31,310
index into your list of backends and

00:17:28,580 --> 00:17:34,280
pick which one to use why do we use the

00:17:31,310 --> 00:17:36,650
five tuple primarily because TCP reacts

00:17:34,280 --> 00:17:37,460
very very poor or you have it I should

00:17:36,650 --> 00:17:39,920
be slightly more careful

00:17:37,460 --> 00:17:43,160
TCP used to react very very poorly to

00:17:39,920 --> 00:17:45,050
packet reordering if you send two

00:17:43,160 --> 00:17:47,270
packets from the same TCP flow across

00:17:45,050 --> 00:17:48,049
different network paths it is possible

00:17:47,270 --> 00:17:52,879
even likely

00:17:48,049 --> 00:17:54,379
but they will end up arriving at the far

00:17:52,879 --> 00:17:55,549
end point possibly in a different order

00:17:54,379 --> 00:17:57,739
from the order in which they were

00:17:55,549 --> 00:17:59,119
transmitted and TCP if it season out of

00:17:57,739 --> 00:18:01,369
order packet will treat that as

00:17:59,119 --> 00:18:03,169
analogous to packet loss and packet loss

00:18:01,369 --> 00:18:06,440
is what TCP uses to say oh there's

00:18:03,169 --> 00:18:09,350
congestion let me slow down and so you

00:18:06,440 --> 00:18:11,029
want ideally all the packets from the

00:18:09,350 --> 00:18:13,820
same flow to traverse the same set of

00:18:11,029 --> 00:18:15,169
network links other things to bear and

00:18:13,820 --> 00:18:17,659
so this diagram below just kind of

00:18:15,169 --> 00:18:20,149
explains it shows some example inbound

00:18:17,659 --> 00:18:22,789
and outbound flows to two racks full of

00:18:20,149 --> 00:18:24,139
service I think to bear in mind as well

00:18:22,789 --> 00:18:27,649
just something to keep in the back of

00:18:24,139 --> 00:18:29,389
your head basically always unless you're

00:18:27,649 --> 00:18:31,309
in a very constrained data center and

00:18:29,389 --> 00:18:33,049
enterprise environment where your

00:18:31,309 --> 00:18:34,609
network operations engineering

00:18:33,049 --> 00:18:36,889
architecture people have set things up

00:18:34,609 --> 00:18:40,190
otherwise basically all the time

00:18:36,889 --> 00:18:42,100
otherwise all traffic is in the network

00:18:40,190 --> 00:18:44,299
is asymmetric which means that the

00:18:42,100 --> 00:18:46,220
traffic for the same flow in one

00:18:44,299 --> 00:18:47,570
direction will go over a different set

00:18:46,220 --> 00:18:49,820
of links when the response traffic goes

00:18:47,570 --> 00:18:53,960
back right just something to always

00:18:49,820 --> 00:18:57,289
always keep in your head in terms of

00:18:53,960 --> 00:19:00,019
what else do I want to mention here Oh

00:18:57,289 --> 00:19:01,759
hashing Google's Maglev paper is like

00:19:00,019 --> 00:19:03,289
several years old now but it explains

00:19:01,759 --> 00:19:05,929
some of the challenges and picking

00:19:03,289 --> 00:19:08,269
network hashing Facebook have a thing

00:19:05,929 --> 00:19:09,739
called Catan which is their software

00:19:08,269 --> 00:19:11,450
Network load balancer which they have

00:19:09,739 --> 00:19:13,820
open sourced which implements one of the

00:19:11,450 --> 00:19:19,399
hashing algorithms described in the

00:19:13,820 --> 00:19:24,440
Google paper ok so the next thing here

00:19:19,399 --> 00:19:26,090
is we the hash based algorithm is a very

00:19:24,440 --> 00:19:27,710
simple one right because it it's just

00:19:26,090 --> 00:19:29,749
like for this flow pick this back-end

00:19:27,710 --> 00:19:31,789
but you can do more interesting things

00:19:29,749 --> 00:19:33,529
in layer for load balancing right when I

00:19:31,789 --> 00:19:36,559
say layer 4 this is network layer 4

00:19:33,529 --> 00:19:38,509
because TCP and UDP transport protocols

00:19:36,559 --> 00:19:40,309
considered layer 4 you can do things

00:19:38,509 --> 00:19:42,320
like leased connections right so your

00:19:40,309 --> 00:19:43,940
load balancer because it's in in this

00:19:42,320 --> 00:19:46,129
set up in the path of every request

00:19:43,940 --> 00:19:47,509
knows how many open connections there

00:19:46,129 --> 00:19:49,730
are or pending requests there are to

00:19:47,509 --> 00:19:51,139
each back-end and so you could say pick

00:19:49,730 --> 00:19:52,909
the one that has the fewest connections

00:19:51,139 --> 00:19:54,830
which some workloads is actually not an

00:19:52,909 --> 00:20:00,540
unreasonable thing to do right assuming

00:19:54,830 --> 00:20:02,530
you you never go out of capacity so

00:20:00,540 --> 00:20:03,940
this gives us a lot more power an

00:20:02,530 --> 00:20:06,310
outright because we can add more

00:20:03,940 --> 00:20:07,840
instances to the back-end pool and this

00:20:06,310 --> 00:20:09,310
is completely transparent to the users

00:20:07,840 --> 00:20:12,400
right there's no DNS change there's no

00:20:09,310 --> 00:20:13,750
like basically like completely arbitrary

00:20:12,400 --> 00:20:15,190
right the only thing that can strange

00:20:13,750 --> 00:20:17,140
does is space and power and how quickly

00:20:15,190 --> 00:20:18,580
are our physical provider can give us

00:20:17,140 --> 00:20:20,620
new instances if you're in the cloud

00:20:18,580 --> 00:20:22,960
this is just click a button in the ideal

00:20:20,620 --> 00:20:26,260
AWS console or the Google Cloud console

00:20:22,960 --> 00:20:27,460
or whatever and it just appears we can

00:20:26,260 --> 00:20:29,890
add health checks here as well right

00:20:27,460 --> 00:20:31,570
because we can say hey network load

00:20:29,890 --> 00:20:34,360
balancer yes I know you're only doing

00:20:31,570 --> 00:20:35,680
packet forwarding but to establish the

00:20:34,360 --> 00:20:37,120
health of a server rather than just

00:20:35,680 --> 00:20:39,280
pinging it or rather than connecting on

00:20:37,120 --> 00:20:40,990
a TCP port hit this particular URL

00:20:39,280 --> 00:20:42,990
because this is a web server and if you

00:20:40,990 --> 00:20:46,330
can serve like out from winnie-the-pooh

00:20:42,990 --> 00:20:51,550
JPEG then this is probably a happy thing

00:20:46,330 --> 00:20:53,530
right so this is much better it gives us

00:20:51,550 --> 00:20:55,240
load distribution across multiple pieces

00:20:53,530 --> 00:20:57,850
of infrastructure it gives us avoiding

00:20:55,240 --> 00:20:59,950
unhealthy instances and it also gives

00:20:57,850 --> 00:21:02,400
the operators the ability to take

00:20:59,950 --> 00:21:04,600
individual servers out for maintenance

00:21:02,400 --> 00:21:07,450
usually the things it doesn't give you

00:21:04,600 --> 00:21:08,950
it doesn't give you knowledge of load on

00:21:07,450 --> 00:21:10,330
servers like the differences between

00:21:08,950 --> 00:21:11,710
different requests right because

00:21:10,330 --> 00:21:15,490
multiple requests can go over the same

00:21:11,710 --> 00:21:19,450
TCP connection it's also not content

00:21:15,490 --> 00:21:21,370
aware right so it's not going to be able

00:21:19,450 --> 00:21:22,720
to route different requests to different

00:21:21,370 --> 00:21:24,310
backends because maybe you want your

00:21:22,720 --> 00:21:26,130
images so from over here but you want

00:21:24,310 --> 00:21:29,800
your JavaScript server from over here

00:21:26,130 --> 00:21:31,690
and it's hard to do sensible load

00:21:29,800 --> 00:21:33,790
shedding and denial of service abuse

00:21:31,690 --> 00:21:35,890
protection because like to do that well

00:21:33,790 --> 00:21:38,020
you need to typically be aware of

00:21:35,890 --> 00:21:40,900
application level heuristics and

00:21:38,020 --> 00:21:45,670
information fir for fingerprinting okay

00:21:40,900 --> 00:21:48,340
so hiding a lot of network detail so I'm

00:21:45,670 --> 00:21:51,100
gonna talk a fairly quickly because I'm

00:21:48,340 --> 00:21:52,330
time constrained all of this stuff where

00:21:51,100 --> 00:21:54,910
we've said there's a magic network

00:21:52,330 --> 00:21:56,200
between you and your your servers and

00:21:54,910 --> 00:22:01,510
the internet we'll talk a bit more about

00:21:56,200 --> 00:22:03,670
how that works so your stateless load

00:22:01,510 --> 00:22:06,190
Network load distribution this is just

00:22:03,670 --> 00:22:07,570
you have many network devices in a path

00:22:06,190 --> 00:22:09,850
right so in this case you let's say you

00:22:07,570 --> 00:22:11,970
have two edge ruses in your data center

00:22:09,850 --> 00:22:13,470
and then you have two

00:22:11,970 --> 00:22:16,529
top of racks which is your acts of

00:22:13,470 --> 00:22:18,500
service 1+1 redundancy is just a very

00:22:16,529 --> 00:22:21,240
common model in in network provisioning

00:22:18,500 --> 00:22:23,190
3 plus 1 or whatever is becoming more

00:22:21,240 --> 00:22:24,600
common but historically network vendors

00:22:23,190 --> 00:22:27,090
have gone to scale up rather than scale

00:22:24,600 --> 00:22:30,480
out although this is changing but if we

00:22:27,090 --> 00:22:33,029
consider one server to and from Iraq you

00:22:30,480 --> 00:22:34,830
can do something like so you have to

00:22:33,029 --> 00:22:36,330
Reuters let's say the server is only

00:22:34,830 --> 00:22:38,460
connected to the one switch and then it

00:22:36,330 --> 00:22:40,919
has to reuters connected that switch you

00:22:38,460 --> 00:22:42,480
can do something like vrrp or similar to

00:22:40,919 --> 00:22:45,389
have like high availability at your

00:22:42,480 --> 00:22:47,309
network gateway level and the routing

00:22:45,389 --> 00:22:49,350
level you can say one of these to

00:22:47,309 --> 00:22:50,549
reuters these two circles is the primary

00:22:49,350 --> 00:22:52,440
gateway to get to the rest of the

00:22:50,549 --> 00:22:54,960
internet and receive incoming traffic or

00:22:52,440 --> 00:22:59,250
you can load balance across the two this

00:22:54,960 --> 00:23:01,129
is what's called IP multipath so with

00:22:59,250 --> 00:23:04,259
this setup if you have a broken router

00:23:01,129 --> 00:23:07,139
then stuff naturally converges via the

00:23:04,259 --> 00:23:09,509
other path right if you have a broken

00:23:07,139 --> 00:23:10,919
switch it depends on whether your server

00:23:09,509 --> 00:23:12,330
is connected to multiple switches or not

00:23:10,919 --> 00:23:14,129
if it's only connected to one switch the

00:23:12,330 --> 00:23:15,269
server goes away but maybe hopefully you

00:23:14,129 --> 00:23:20,970
have a redundant server in the other

00:23:15,269 --> 00:23:21,990
rack if you have racks full of machines

00:23:20,970 --> 00:23:25,769
and they're all connected to two

00:23:21,990 --> 00:23:27,269
switches how do you make use of all of

00:23:25,769 --> 00:23:28,950
your bandwidth right so this is now

00:23:27,269 --> 00:23:30,710
we're talking about a capacity question

00:23:28,950 --> 00:23:32,940
rather than high availability question

00:23:30,710 --> 00:23:35,490
and the answer to this is something

00:23:32,940 --> 00:23:36,600
called ecmp equal cost multi path this

00:23:35,490 --> 00:23:38,460
is the thing you'll hear Network people

00:23:36,600 --> 00:23:40,919
throw around you have many links they

00:23:38,460 --> 00:23:44,070
all have the same cost and you use your

00:23:40,919 --> 00:23:46,080
different links using the hash hashing

00:23:44,070 --> 00:23:47,580
algorithms we described before different

00:23:46,080 --> 00:23:49,230
flows go over different links and so

00:23:47,580 --> 00:23:50,820
suddenly your available bandwidth is the

00:23:49,230 --> 00:23:52,409
sum of the all of the available link

00:23:50,820 --> 00:23:54,570
bandwidth going up or down from a given

00:23:52,409 --> 00:23:55,889
network device typically this is all

00:23:54,570 --> 00:23:58,049
stateless right this is all done in

00:23:55,889 --> 00:23:59,519
silicon and there's no per connection or

00:23:58,049 --> 00:24:03,389
per flow State in any of these network

00:23:59,519 --> 00:24:05,519
devices yeah caveats all flows are

00:24:03,389 --> 00:24:06,990
asymmetric the other big thing here is

00:24:05,519 --> 00:24:08,759
elephant flows are a real problem

00:24:06,990 --> 00:24:11,759
elephant flows are where you have a

00:24:08,759 --> 00:24:13,679
single flow which is larger than the

00:24:11,759 --> 00:24:15,120
size of the biggest link you have in a

00:24:13,679 --> 00:24:16,919
bundle right so say your data sense

00:24:15,120 --> 00:24:18,960
provider is using all 10 gig links and

00:24:16,919 --> 00:24:21,299
you have a flow that is 20 gig there is

00:24:18,960 --> 00:24:23,700
no way to solve this problem right they

00:24:21,299 --> 00:24:26,010
will need to operate a 40 gig or 100 gig

00:24:23,700 --> 00:24:32,490
on the physical layer to

00:24:26,010 --> 00:24:35,460
to be able to serve that so yes so what

00:24:32,490 --> 00:24:36,990
about soft link failure with soft link

00:24:35,460 --> 00:24:38,040
failure this is generally much harder in

00:24:36,990 --> 00:24:39,390
the networking world than otherwise

00:24:38,040 --> 00:24:41,580
because what this turns into is

00:24:39,390 --> 00:24:43,530
intermittent packet drops and often

00:24:41,580 --> 00:24:45,000
hardware just lies right like it will

00:24:43,530 --> 00:24:47,610
not increment a counter it will not tell

00:24:45,000 --> 00:24:49,500
you anything is wrong and so the only

00:24:47,610 --> 00:24:51,240
really way to solve this is to is to

00:24:49,500 --> 00:24:53,220
have like some sort of external

00:24:51,240 --> 00:24:54,960
monitoring where you're like trying to

00:24:53,220 --> 00:24:56,790
spray traffic across as many links as

00:24:54,960 --> 00:24:57,890
possible and see what stuff has gone

00:24:56,790 --> 00:25:00,210
down

00:24:57,890 --> 00:25:01,410
NORAD again Facebook have a thing

00:25:00,210 --> 00:25:02,970
they've open sourced I think it's called

00:25:01,410 --> 00:25:05,700
net NORAD I can't remember the name of

00:25:02,970 --> 00:25:09,750
it which is is doing this kind of

00:25:05,700 --> 00:25:12,840
introspection ok I'm gonna skip over

00:25:09,750 --> 00:25:16,920
this because proxy this as well I'm

00:25:12,840 --> 00:25:20,190
going to skip over layer 3 DSR so I'll

00:25:16,920 --> 00:25:21,810
talk about these two slides so with

00:25:20,190 --> 00:25:23,670
network load balancing we talked about

00:25:21,810 --> 00:25:25,440
the proxy set up where all packets

00:25:23,670 --> 00:25:29,670
inbound and outbound go through the same

00:25:25,440 --> 00:25:31,110
device the problem with this is that you

00:25:29,670 --> 00:25:32,970
are then bandwidth limited by that

00:25:31,110 --> 00:25:35,550
device right so if you have a very

00:25:32,970 --> 00:25:37,050
asymmetric workload and in web requests

00:25:35,550 --> 00:25:39,090
this is typically true unless you're

00:25:37,050 --> 00:25:40,530
taking a lot of upload traffic typically

00:25:39,090 --> 00:25:42,360
your request size is significantly

00:25:40,530 --> 00:25:45,480
smaller than your response size and so

00:25:42,360 --> 00:25:47,070
it would be nice to be able to have make

00:25:45,480 --> 00:25:48,360
use of all of your inbound bandwidth on

00:25:47,070 --> 00:25:49,920
a single load balancer and have many

00:25:48,360 --> 00:25:51,570
backends be able to serve and this is

00:25:49,920 --> 00:25:53,400
the idea of direct server return and

00:25:51,570 --> 00:25:54,900
this is effectively where your incoming

00:25:53,400 --> 00:25:57,000
packets go through your load Network

00:25:54,900 --> 00:25:59,400
load balancer but your returned packets

00:25:57,000 --> 00:26:01,650
don't they go directly back out to the

00:25:59,400 --> 00:26:04,560
internet or to your to your office users

00:26:01,650 --> 00:26:06,090
or whatever we used to do this using

00:26:04,560 --> 00:26:07,550
Ethernet trickery I'm gonna skip over

00:26:06,090 --> 00:26:10,500
this we will make the slides available

00:26:07,550 --> 00:26:12,630
people can read after the fact with

00:26:10,500 --> 00:26:15,270
layer 3 DSR the way we solve this is

00:26:12,630 --> 00:26:17,550
this is a long set of slides which one

00:26:15,270 --> 00:26:20,790
do I want I want this one the short

00:26:17,550 --> 00:26:23,310
version is load balancer receives an IP

00:26:20,790 --> 00:26:25,170
packet it then looks at which back-end

00:26:23,310 --> 00:26:27,240
it wants to send traffic for this flow

00:26:25,170 --> 00:26:29,070
to and then it sticks another IP header

00:26:27,240 --> 00:26:30,930
on the outside of that packet and what

00:26:29,070 --> 00:26:33,300
this means is your network load balancer

00:26:30,930 --> 00:26:34,320
doesn't need to be in the same rack or

00:26:33,300 --> 00:26:36,270
in this or connected to the same

00:26:34,320 --> 00:26:38,340
Ethernet switch as any of your backends

00:26:36,270 --> 00:26:38,919
and it allows you to still preserve that

00:26:38,340 --> 00:26:40,539
original

00:26:38,919 --> 00:26:41,950
P address information which is very

00:26:40,539 --> 00:26:43,239
useful for like spam and abuse and

00:26:41,950 --> 00:26:48,879
reputation protection and various other

00:26:43,239 --> 00:26:49,989
things skip skip skip so yes back to our

00:26:48,879 --> 00:26:52,059
story

00:26:49,989 --> 00:26:54,340
so we've so far we've only talked about

00:26:52,059 --> 00:26:56,470
multiple data single data center if we

00:26:54,340 --> 00:26:57,580
wanted to do multiple data center there

00:26:56,470 --> 00:26:59,230
are many reasons you might want to do

00:26:57,580 --> 00:27:01,119
this right one is just disaster recovery

00:26:59,230 --> 00:27:02,470
right you don't want an earthquake or a

00:27:01,119 --> 00:27:04,570
tsunami or whatever to take out all of

00:27:02,470 --> 00:27:06,789
your serving capacity but there is also

00:27:04,570 --> 00:27:10,450
benefit for users right because let's

00:27:06,789 --> 00:27:12,850
say you're a you're a us-based company

00:27:10,450 --> 00:27:14,289
if you have your own data center on the

00:27:12,850 --> 00:27:15,759
East Coast your user experience for your

00:27:14,289 --> 00:27:17,499
West Coast user is going to be terrible

00:27:15,759 --> 00:27:19,450
and so if you can have multiple

00:27:17,499 --> 00:27:24,359
locations and if you can steer users to

00:27:19,450 --> 00:27:26,649
those locations then that will be better

00:27:24,359 --> 00:27:28,749
most of the time when people do this the

00:27:26,649 --> 00:27:30,759
first thing they do is they do something

00:27:28,749 --> 00:27:32,830
called anycast this is a whole other run

00:27:30,759 --> 00:27:36,879
that I am not giving a talk about this

00:27:32,830 --> 00:27:39,399
time any cost is hard to monitor but it

00:27:36,879 --> 00:27:40,779
is cheap and easy and to do upfront

00:27:39,399 --> 00:27:42,549
you basically announce the same address

00:27:40,779 --> 00:27:46,179
from multiple locations users go to the

00:27:42,549 --> 00:27:47,739
closest one yes it's not load balancing

00:27:46,179 --> 00:27:50,049
I gave a whole other talk about this you

00:27:47,739 --> 00:27:53,440
can find the slides from SEO recon last

00:27:50,049 --> 00:27:54,999
year I think the other option you can do

00:27:53,440 --> 00:27:56,440
is you can have your multiple data

00:27:54,999 --> 00:27:57,669
centers have different IP addresses

00:27:56,440 --> 00:27:59,590
right so you have they have completely

00:27:57,669 --> 00:28:01,210
independent net blocks and then you end

00:27:59,590 --> 00:28:02,889
up with back in this in the DNS

00:28:01,210 --> 00:28:06,009
configuration you have two IP addresses

00:28:02,889 --> 00:28:07,629
for a given name up sides down sides

00:28:06,009 --> 00:28:09,999
here because if the entire data centers

00:28:07,629 --> 00:28:11,710
goes away you still have the DNS TTL

00:28:09,999 --> 00:28:14,769
problem right and you have like five

00:28:11,710 --> 00:28:19,570
minutes or a day before your users are

00:28:14,769 --> 00:28:21,100
redirected so the way a lot of people

00:28:19,570 --> 00:28:23,799
solve this is with something called

00:28:21,100 --> 00:28:25,989
backup routes or cover routes where both

00:28:23,799 --> 00:28:29,649
locations announced both sets of IP

00:28:25,989 --> 00:28:31,600
prefixes but they each one is primary

00:28:29,649 --> 00:28:33,159
for one and so if the other datacenter

00:28:31,600 --> 00:28:36,179
goes away it suddenly starts serving

00:28:33,159 --> 00:28:39,309
that datacenters IP addresses but it's

00:28:36,179 --> 00:28:42,789
typically they only serve traffic for

00:28:39,309 --> 00:28:44,590
their own prefix DNS the Geo load

00:28:42,789 --> 00:28:47,230
balancing I'm going to skip over this

00:28:44,590 --> 00:28:48,340
because I think you know we'll talk

00:28:47,230 --> 00:28:50,259
about this I think I'm more finished

00:28:48,340 --> 00:28:52,539
there so the perils of DNS geo load

00:28:50,259 --> 00:28:56,009
balancing so we're talking about here

00:28:52,539 --> 00:28:59,829
the the idea here is based on the

00:28:56,009 --> 00:29:01,359
end-users request you work out where to

00:28:59,829 --> 00:29:02,919
send them right I think this user is

00:29:01,359 --> 00:29:04,359
approximately in the u.s. West Coast or

00:29:02,919 --> 00:29:06,820
on the US East Coast and I will send

00:29:04,359 --> 00:29:09,219
them to the relevant data center IP

00:29:06,820 --> 00:29:12,820
addressing particularly in ipv4 is very

00:29:09,219 --> 00:29:15,789
very fragmented secondly the IP address

00:29:12,820 --> 00:29:17,559
you see from DNS requests is typically

00:29:15,789 --> 00:29:19,479
not the end users IP address but the

00:29:17,559 --> 00:29:21,940
address of their recursive resolver and

00:29:19,479 --> 00:29:24,219
you may have a large user population

00:29:21,940 --> 00:29:25,839
behind a recursive resolver who have

00:29:24,219 --> 00:29:27,909
very different latency profiles to your

00:29:25,839 --> 00:29:30,489
service right let's say you're an isp in

00:29:27,909 --> 00:29:32,499
India maybe you put all of your users

00:29:30,489 --> 00:29:34,719
behind a single DNS server and then

00:29:32,499 --> 00:29:36,369
their user experience is going to be

00:29:34,719 --> 00:29:38,199
terrible if that's the only signal you

00:29:36,369 --> 00:29:40,709
have for load balancing there is an

00:29:38,199 --> 00:29:44,289
extension called a DNS client subnet

00:29:40,709 --> 00:29:48,369
which allows you to embed information

00:29:44,289 --> 00:29:49,929
about where your clients are to to the

00:29:48,369 --> 00:29:53,169
upstream authoritative nameservers which

00:29:49,929 --> 00:29:54,909
gives you a hint as to I know I'm a DNS

00:29:53,169 --> 00:29:56,799
server over here in the west coast of

00:29:54,909 --> 00:29:58,869
the US but this user is actually coming

00:29:56,799 --> 00:30:00,219
from Hawaii or whatever or from the east

00:29:58,869 --> 00:30:02,349
coast and you should route them

00:30:00,219 --> 00:30:03,909
accordingly this is implemented by a

00:30:02,349 --> 00:30:05,709
bunch of content delivery networks and

00:30:03,909 --> 00:30:06,789
by a bunch of DNS providers it's I don't

00:30:05,709 --> 00:30:08,289
think it's actually a standards track

00:30:06,789 --> 00:30:09,699
standard but pretty much everyone

00:30:08,289 --> 00:30:12,759
implements it at this point or large

00:30:09,699 --> 00:30:14,919
providers do I have one minute left so

00:30:12,759 --> 00:30:18,789
what I'm going to do is I'm going to

00:30:14,919 --> 00:30:20,859
skip to where's the thing damn it there

00:30:18,789 --> 00:30:24,009
we go

00:30:20,859 --> 00:30:25,899
when you read these slides this is what

00:30:24,009 --> 00:30:27,099
you should take away do you care about

00:30:25,899 --> 00:30:28,359
capacity do you care about high

00:30:27,099 --> 00:30:30,549
availability do you care about

00:30:28,359 --> 00:30:32,799
utilization how much control do you want

00:30:30,549 --> 00:30:34,059
over traffic racing how much telemetry

00:30:32,799 --> 00:30:35,589
do you want do you can only care about

00:30:34,059 --> 00:30:37,629
network level telemetry or do you care

00:30:35,589 --> 00:30:40,629
about service level telemetry which of

00:30:37,629 --> 00:30:42,699
those you care about will in turn impact

00:30:40,629 --> 00:30:44,589
which of these technologies you selects

00:30:42,699 --> 00:30:45,879
there's a whole bunch of stuff at the

00:30:44,589 --> 00:30:48,489
application layer we haven't talked

00:30:45,879 --> 00:30:51,009
about again the the slide contents fully

00:30:48,489 --> 00:30:53,109
available and the other thing here is

00:30:51,009 --> 00:30:54,759
there is a bunch of reference material

00:30:53,109 --> 00:30:57,819
which will be on the slides which people

00:30:54,759 --> 00:31:00,159
can go and read up on in in detail so I

00:30:57,819 --> 00:31:01,719
think I'll see a publish the slides on

00:31:00,159 --> 00:31:02,829
the website do they yeah so I'll send

00:31:01,719 --> 00:31:06,899
that through to you and after the fact

00:31:02,829 --> 00:31:06,899

YouTube URL: https://www.youtube.com/watch?v=FC0DARpayhw


