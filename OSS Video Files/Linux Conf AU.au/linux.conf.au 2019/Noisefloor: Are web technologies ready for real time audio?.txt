Title: Noisefloor: Are web technologies ready for real time audio?
Publication date: 2020-01-09
Playlist: linux.conf.au 2019
Description: 
	Jacob Lister

https://2019.linux.conf.au/schedule/presentation/244/

Javascript JITs have come a long way in recent years, now offering near native code performance on the fly for many application types.

With the recent adoption on AudioWorklets, the browser is now becoming a viable platform for real time audio processing.

Jacob will be presenting Noisefloor, a proof of concept software Module Synthesizer implemented in Golang and transpiled to Javascript,
and discussing some of the challenges involved in managing a reliable real time audio thread alongside a browser based UI.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:00,030 --> 00:00:08,519
later on okay so I'm without going too

00:00:05,160 --> 00:00:11,670
much further um I am going to hand hand

00:00:08,519 --> 00:00:13,250
over to Jacob and he's going to kick off

00:00:11,670 --> 00:00:17,359
our first talk for the day

00:00:13,250 --> 00:00:19,619
so Jacob Lester is he's a

00:00:17,359 --> 00:00:22,500
telecommunications engineer and kind of

00:00:19,619 --> 00:00:24,810
signals processing expert and he's come

00:00:22,500 --> 00:00:29,340
down from Wellington to present his his

00:00:24,810 --> 00:00:31,859
noise floor app and library which is he

00:00:29,340 --> 00:00:34,020
will go into a lot of detail about

00:00:31,859 --> 00:00:37,739
real-time audio processing in the

00:00:34,020 --> 00:00:39,510
browser and golang synthesis and I think

00:00:37,739 --> 00:00:41,100
it's kind of interesting this isn't

00:00:39,510 --> 00:00:45,090
actually the first time that Jacob has

00:00:41,100 --> 00:00:47,190
brought some music to LCA but I believe

00:00:45,090 --> 00:00:48,300
the previous time it was an acoustic

00:00:47,190 --> 00:00:50,820
guitar is that right

00:00:48,300 --> 00:00:53,399
yeah and so we've kind of ramped up the

00:00:50,820 --> 00:00:54,960
technology spectrum today so everyone

00:00:53,399 --> 00:01:06,710
give a big round of applause for Jacob

00:00:54,960 --> 00:01:06,710
thanks thank you very much thanks back

00:01:08,600 --> 00:01:11,600
okay

00:01:17,260 --> 00:01:40,120
okay that's behaving that's the one I'm

00:01:25,810 --> 00:01:45,730
gonna want here we are

00:01:40,120 --> 00:01:49,000
oh good morning thanks for that actually

00:01:45,730 --> 00:01:50,350
I quite correct introduction on a 105

00:01:49,000 --> 00:01:55,270
spike

00:01:50,350 --> 00:01:57,960
yeah I'm Jacob yeah look at me I love

00:01:55,270 --> 00:02:01,420
them Wellington married with one kit

00:01:57,960 --> 00:02:02,800
just kind of cute I've done some of

00:02:01,420 --> 00:02:05,170
these things embedded systems

00:02:02,800 --> 00:02:07,360
development and real farm systems

00:02:05,170 --> 00:02:09,130
scatter engineering a little bit of

00:02:07,360 --> 00:02:11,320
graphics telecommunications network

00:02:09,130 --> 00:02:14,770
engineering data science which is a bit

00:02:11,320 --> 00:02:17,260
new of all most topics some one of my

00:02:14,770 --> 00:02:18,970
long-term interests as a so hobby in the

00:02:17,260 --> 00:02:20,740
side project has actually been music

00:02:18,970 --> 00:02:23,800
technology and purposes and this kind of

00:02:20,740 --> 00:02:27,070
stuff and of all those experience areas

00:02:23,800 --> 00:02:29,650
one here embedded systems development

00:02:27,070 --> 00:02:32,739
and real-time systems has been probably

00:02:29,650 --> 00:02:37,380
the most directly relevant so some of

00:02:32,739 --> 00:02:39,489
that experiences it's related to

00:02:37,380 --> 00:02:43,870
real-time systems for actually dealing

00:02:39,489 --> 00:02:45,010
with live performance when using a

00:02:43,870 --> 00:02:46,989
musical instrument playing your guitar

00:02:45,010 --> 00:02:48,880
or a keyboard or something we're dealing

00:02:46,989 --> 00:02:51,400
with very short time frames down to the

00:02:48,880 --> 00:02:53,950
millisecond drum and having a system

00:02:51,400 --> 00:02:55,480
which is both correct on its output and

00:02:53,950 --> 00:02:59,050
also responsive so that it can actually

00:02:55,480 --> 00:03:04,780
deliver those outputs and a timely

00:02:59,050 --> 00:03:07,360
manner as as quite a challenge so a

00:03:04,780 --> 00:03:08,980
little bit of background on the project

00:03:07,360 --> 00:03:11,650
that I'm currently working on where it

00:03:08,980 --> 00:03:14,050
came from many many years ago I wrote a

00:03:11,650 --> 00:03:16,840
software topler and looper

00:03:14,050 --> 00:03:21,700
it's quite an aging project now the

00:03:16,840 --> 00:03:25,900
original wersal space is c and c++ it's

00:03:21,700 --> 00:03:28,720
looking quite long in the tooth I have

00:03:25,900 --> 00:03:30,000
intentions are basically re-implementing

00:03:28,720 --> 00:03:33,360
the software in

00:03:30,000 --> 00:03:35,430
some newer technologies get a bit of

00:03:33,360 --> 00:03:38,880
experience there and also make them a

00:03:35,430 --> 00:03:42,750
little bit more accessible so I wanted

00:03:38,880 --> 00:03:44,070
to just run that software briefly so I

00:03:42,750 --> 00:03:50,459
can show you a little bit about what

00:03:44,070 --> 00:03:54,270
it's about in a performance context I'd

00:03:50,459 --> 00:03:56,010
normally have a guitar I would play a

00:03:54,270 --> 00:03:59,340
section of music it would be recorded

00:03:56,010 --> 00:04:02,580
would be repeated in a loop and then I

00:03:59,340 --> 00:04:04,650
would play war music on top of that no

00:04:02,580 --> 00:04:06,630
guitar today but I have a pre-recorded

00:04:04,650 --> 00:04:09,260
section so you can just see a little bit

00:04:06,630 --> 00:04:12,270
from that interface those red blocks are

00:04:09,260 --> 00:04:16,380
recording sections greens are playback

00:04:12,270 --> 00:04:18,720
and these little blue chicks there are

00:04:16,380 --> 00:04:20,790
just basically a switcher track so I

00:04:18,720 --> 00:04:23,880
might be moving from a clean sound to a

00:04:20,790 --> 00:04:25,470
distorted one or something like that so

00:04:23,880 --> 00:04:34,370
I'm just going to play that in little it

00:04:25,470 --> 00:04:34,370
run for a little bit looks all good

00:04:39,650 --> 00:06:08,430
[Music]

00:06:08,770 --> 00:06:11,770
right

00:06:16,330 --> 00:06:21,260
right that also it's gonna check out

00:06:18,950 --> 00:06:21,970
just enough oops a little bit more sound

00:06:21,260 --> 00:06:30,529
than we wanted

00:06:21,970 --> 00:06:30,529
[Music]

00:06:30,550 --> 00:06:33,590
right it's gonna stop now that's better

00:06:32,810 --> 00:06:36,620
that's good timing

00:06:33,590 --> 00:06:38,200
okay so a little bit of thumb weight and

00:06:36,620 --> 00:06:42,880
that's a little bit of we're come from

00:06:38,200 --> 00:06:46,010
where I'm going with this as basically a

00:06:42,880 --> 00:06:48,620
upgrading and re implementing it in new

00:06:46,010 --> 00:06:51,170
languages and I wanted something that

00:06:48,620 --> 00:06:54,740
could be a little bit more sort of kind

00:06:51,170 --> 00:06:56,990
of she rubble so the question I started

00:06:54,740 --> 00:06:59,450
asking myself recently as I could I

00:06:56,990 --> 00:07:01,400
actually do this in a web environment I

00:06:59,450 --> 00:07:04,870
have an application which could run in

00:07:01,400 --> 00:07:09,020
the browser meet some of those real-time

00:07:04,870 --> 00:07:11,660
delivery goals and still be useful but

00:07:09,020 --> 00:07:12,950
just be quite sharable so when you have

00:07:11,660 --> 00:07:14,930
an application and you're asking people

00:07:12,950 --> 00:07:17,060
well I have written this cool thing do I

00:07:14,930 --> 00:07:18,620
have a look at it asking someone to

00:07:17,060 --> 00:07:20,870
download this application for the

00:07:18,620 --> 00:07:24,020
internet and still like configure it set

00:07:20,870 --> 00:07:26,930
it up it's actually quite a big ask for

00:07:24,020 --> 00:07:28,820
yeah a little-little phone but if it's

00:07:26,930 --> 00:07:30,320
just you know click on this link and

00:07:28,820 --> 00:07:36,140
it's in the browser and you can view it

00:07:30,320 --> 00:07:37,940
that's a lot more accessible other you

00:07:36,140 --> 00:07:39,710
know sort of goals here actually just

00:07:37,940 --> 00:07:41,360
learned some new technologies will be

00:07:39,710 --> 00:07:43,190
getting to go Lane which is the actual

00:07:41,360 --> 00:07:47,140
implementation language transferred to

00:07:43,190 --> 00:07:49,850
JavaScript shortly and just also that

00:07:47,140 --> 00:07:53,180
there's a hobby projects unconstrained

00:07:49,850 --> 00:07:54,680
by time and deadlines so basically I can

00:07:53,180 --> 00:07:57,170
just work on this until I'm satisfied

00:07:54,680 --> 00:08:03,560
with it I don't have a you know a

00:07:57,170 --> 00:08:06,400
customer or a boss is you know medium my

00:08:03,560 --> 00:08:08,810
long-term ambition for this project is

00:08:06,400 --> 00:08:10,870
DSP play a playground this is a piece of

00:08:08,810 --> 00:08:14,060
software called reactor it's really cool

00:08:10,870 --> 00:08:18,530
it basically lets you and have all these

00:08:14,060 --> 00:08:20,060
little quite simple modules of audio

00:08:18,530 --> 00:08:22,910
processing and just wire them up and a

00:08:20,060 --> 00:08:24,590
graph and play with it so obviously I'm

00:08:22,910 --> 00:08:31,850
nowhere near that stage yet but that's

00:08:24,590 --> 00:08:32,960
the that's the great ambition so why do

00:08:31,850 --> 00:08:35,720
I think we'd pick knowledge ease are

00:08:32,960 --> 00:08:37,580
actually now appropriate well probably

00:08:35,720 --> 00:08:39,620
the main thing is just how far those

00:08:37,580 --> 00:08:41,540
JavaScript terminal interpreters and

00:08:39,620 --> 00:08:43,100
just-in-time compilers actually can in

00:08:41,540 --> 00:08:44,450
recent years

00:08:43,100 --> 00:08:46,670
which is they've now actually got

00:08:44,450 --> 00:08:48,650
performance which is on par or close to

00:08:46,670 --> 00:08:52,400
what you can get with native code

00:08:48,650 --> 00:08:58,010
compiled and see and also just doing

00:08:52,400 --> 00:08:59,330
that in a very interactive environment

00:08:58,010 --> 00:09:01,010
we're basically downloading that

00:08:59,330 --> 00:09:02,150
application compiling on the fly and

00:09:01,010 --> 00:09:06,110
running it which gives a lot of

00:09:02,150 --> 00:09:07,400
possibilities the second thing is that

00:09:06,110 --> 00:09:09,620
there's another way that I can actually

00:09:07,400 --> 00:09:11,030
run this which is in the browser works

00:09:09,620 --> 00:09:15,050
pretty well but it's but constrained

00:09:11,030 --> 00:09:18,380
that the Google v8 engine which does

00:09:15,050 --> 00:09:22,210
what powers the Google Chrome browsers

00:09:18,380 --> 00:09:25,520
javascript is an open source projects

00:09:22,210 --> 00:09:30,590
you can download up and compile it and

00:09:25,520 --> 00:09:32,600
actually build it and that actually

00:09:30,590 --> 00:09:34,820
gives you a lot more opportunity to get

00:09:32,600 --> 00:09:37,700
those really tight real time deadlines

00:09:34,820 --> 00:09:45,730
meet and had something run you can

00:09:37,700 --> 00:09:45,730
actually use quite interactively so I

00:09:48,670 --> 00:09:55,250
see the problem

00:09:51,940 --> 00:09:59,120
right this is nothing that just a very

00:09:55,250 --> 00:10:00,770
simple example of audio processing

00:09:59,120 --> 00:10:03,320
running in the browser there's a simple

00:10:00,770 --> 00:10:05,500
on-screen keyboard I can just press the

00:10:03,320 --> 00:10:05,500
keys

00:10:05,970 --> 00:10:14,170
here the notes and if that works I mean

00:10:12,070 --> 00:10:16,030
that's something I just put on a website

00:10:14,170 --> 00:10:17,230
and cheer around for obviously it needs

00:10:16,030 --> 00:10:18,640
to be fleshed out a bit before it's got

00:10:17,230 --> 00:10:31,590
more interesting but you know proves

00:10:18,640 --> 00:10:31,590
that can be done and that will be there

00:10:32,580 --> 00:10:38,050
moving along and just talk a little bit

00:10:35,320 --> 00:10:40,030
about how that audio processing making

00:10:38,050 --> 00:10:42,100
those notes is working this is kind of

00:10:40,030 --> 00:10:45,310
my reference implementation which I call

00:10:42,100 --> 00:10:47,950
the minimum viable synthesizer so

00:10:45,310 --> 00:10:51,310
there's some basic fundamental building

00:10:47,950 --> 00:10:52,930
blocks that are used in audio synthesis

00:10:51,310 --> 00:10:54,850
and probably the most important one is

00:10:52,930 --> 00:10:59,370
the oscillator which produces a tone of

00:10:54,850 --> 00:11:02,050
a given waveform in a given frequency

00:10:59,370 --> 00:11:04,450
you have a things that you kind of need

00:11:02,050 --> 00:11:06,010
to actually start that may I'm sounding

00:11:04,450 --> 00:11:08,740
interesting and turning a little bit

00:11:06,010 --> 00:11:11,250
like an instrument as a thing called an

00:11:08,740 --> 00:11:15,730
envelope generator which basically

00:11:11,250 --> 00:11:19,150
shapes the level or the volume of the

00:11:15,730 --> 00:11:22,150
sound over time and this one here is the

00:11:19,150 --> 00:11:24,880
classic adsr attack decay sustain and

00:11:22,150 --> 00:11:27,040
release so most instruments when you hit

00:11:24,880 --> 00:11:28,390
them they get to the loudest point quite

00:11:27,040 --> 00:11:31,030
quickly and then they start sort of

00:11:28,390 --> 00:11:38,250
tailing off so you hit that oscillator

00:11:31,030 --> 00:11:40,780
up to building and the final component

00:11:38,250 --> 00:11:42,400
tying all that together is just a simple

00:11:40,780 --> 00:11:43,780
gain which is basically taking that

00:11:42,400 --> 00:11:46,090
oscillator and putting the envelope

00:11:43,780 --> 00:11:57,010
generator and just attenuating based on

00:11:46,090 --> 00:11:58,510
the game so why am i doing this crazy

00:11:57,010 --> 00:12:00,580
thing in JavaScript because I'm every

00:11:58,510 --> 00:12:02,050
time I've talked to people about this

00:12:00,580 --> 00:12:04,540
and said I'm doing this they'd they I

00:12:02,050 --> 00:12:06,820
get I get two responses they're pissed

00:12:04,540 --> 00:12:10,600
as that's really cool and the second one

00:12:06,820 --> 00:12:14,920
is you're crazy so I'm kind of cool with

00:12:10,600 --> 00:12:17,650
it as a hobby project here is why I'm

00:12:14,920 --> 00:12:19,270
interested in going as a implementation

00:12:17,650 --> 00:12:21,610
language JavaScript by fine

00:12:19,270 --> 00:12:24,790
a little bit raw especially for building

00:12:21,610 --> 00:12:26,860
anything really large I'd like something

00:12:24,790 --> 00:12:30,250
which is a bit more sort of type

00:12:26,860 --> 00:12:32,440
constrained and there's a bit stalling

00:12:30,250 --> 00:12:35,140
around it and all that but the other

00:12:32,440 --> 00:12:40,860
reason that it's really quite

00:12:35,140 --> 00:12:43,330
interesting is that I can compile it to

00:12:40,860 --> 00:12:44,920
native code but I can also transport

00:12:43,330 --> 00:12:47,140
lots of JavaScript so I can actually do

00:12:44,920 --> 00:12:48,040
a reference implementation if I want to

00:12:47,140 --> 00:12:52,720
get really down to the middle and

00:12:48,040 --> 00:12:53,950
actually have it may a systems

00:12:52,720 --> 00:12:55,540
programming language I can just do

00:12:53,950 --> 00:12:56,680
benchmarking on and actually just see

00:12:55,540 --> 00:13:01,330
how good I'm getting with the

00:12:56,680 --> 00:13:03,400
performance that I've done this list of

00:13:01,330 --> 00:13:05,320
languages here is just kind of a very

00:13:03,400 --> 00:13:07,810
rough approximation of you know what's

00:13:05,320 --> 00:13:10,000
the most of system programming language

00:13:07,810 --> 00:13:12,580
this in what's the most kind of high

00:13:10,000 --> 00:13:15,550
level and I sort of see golang and this

00:13:12,580 --> 00:13:17,500
nice kind of midpoint where I can kind

00:13:15,550 --> 00:13:21,450
of go down to system programming

00:13:17,500 --> 00:13:21,450
languages I can kind of go up to

00:13:21,660 --> 00:13:33,550
high-level languages so just a few sort

00:13:29,890 --> 00:13:36,190
of tips and tricks here about or just

00:13:33,550 --> 00:13:38,770
general advice for getting good

00:13:36,190 --> 00:13:45,880
real-time performance out of any audio

00:13:38,770 --> 00:13:46,990
application on Linux the important thing

00:13:45,880 --> 00:13:48,640
here is that these these real-time

00:13:46,990 --> 00:13:53,440
applications they're really down this

00:13:48,640 --> 00:13:55,300
they're kind of performance demands

00:13:53,440 --> 00:13:57,700
where you're really wanting about under

00:13:55,300 --> 00:13:59,440
five milliseconds of latency between

00:13:57,700 --> 00:14:00,460
impulses for you playing on a musical

00:13:59,440 --> 00:14:03,420
keyboard or so forth

00:14:00,460 --> 00:14:07,750
and hearing the output or hearing the UM

00:14:03,420 --> 00:14:11,440
the noise and that's quite a tight

00:14:07,750 --> 00:14:13,680
deadline but just the some relative fun

00:14:11,440 --> 00:14:17,350
comparison I've just introduced that

00:14:13,680 --> 00:14:18,700
reference of gaming which is a just

00:14:17,350 --> 00:14:20,410
because it's a common application which

00:14:18,700 --> 00:14:22,510
is getting close to that same territory

00:14:20,410 --> 00:14:25,270
but a hundred frames a second that's why

00:14:22,510 --> 00:14:27,250
references team milliseconds frame so

00:14:25,270 --> 00:14:28,540
you know general commodity operating

00:14:27,250 --> 00:14:30,640
systems are actually getting close but

00:14:28,540 --> 00:14:32,319
you know not quite and so you just need

00:14:30,640 --> 00:14:34,419
that little extra

00:14:32,319 --> 00:14:39,009
performance to actually get good

00:14:34,419 --> 00:14:40,269
real-time performance for our music so

00:14:39,009 --> 00:14:42,339
here's just a couple of things that you

00:14:40,269 --> 00:14:47,100
can do and a very good ideas that will

00:14:42,339 --> 00:14:49,869
help in the operating system sierra

00:14:47,100 --> 00:14:52,539
number one recommended advice is disable

00:14:49,869 --> 00:14:57,100
Wi-Fi chips it's they are notoriously

00:14:52,539 --> 00:15:01,649
bad at stealing resources use a low

00:14:57,100 --> 00:15:04,329
latency kernel that is becoming less

00:15:01,649 --> 00:15:09,069
important or significant difference

00:15:04,329 --> 00:15:10,629
nowadays between a stock kernel but low

00:15:09,069 --> 00:15:13,379
lessen see kernels still definitely have

00:15:10,629 --> 00:15:16,720
the edge so it's a good idea to use one

00:15:13,379 --> 00:15:18,850
use a lightweight window manager so

00:15:16,720 --> 00:15:22,839
again anything which is going to sort of

00:15:18,850 --> 00:15:23,919
steal resources is going to be

00:15:22,839 --> 00:15:27,999
detrimental to your real-time

00:15:23,919 --> 00:15:29,949
performance XFC is a good choice and if

00:15:27,999 --> 00:15:32,470
you want all of those things in one

00:15:29,949 --> 00:15:34,629
package Ubuntu Lee studio as they go out

00:15:32,470 --> 00:15:43,299
of the box solution because it does it

00:15:34,629 --> 00:15:48,309
has all of those about things so the

00:15:43,299 --> 00:15:50,709
next demo that I'm going to do is we're

00:15:48,309 --> 00:15:52,569
looking at the browser before some of

00:15:50,709 --> 00:15:55,029
some of the limitations there is that

00:15:52,569 --> 00:15:55,749
the the audio latency is okay but it

00:15:55,029 --> 00:15:58,769
wasn't great

00:15:55,749 --> 00:16:03,249
thus next demonstration we'll use the

00:15:58,769 --> 00:16:05,289
Google v8 engine interfacing directly

00:16:03,249 --> 00:16:06,759
off the audio hardware and latency is

00:16:05,289 --> 00:16:07,980
down to you know sort of five

00:16:06,759 --> 00:16:10,059
milliseconds that you want to work with

00:16:07,980 --> 00:16:13,299
another constraint running in the

00:16:10,059 --> 00:16:15,609
browser as it's possible but difficult

00:16:13,299 --> 00:16:17,739
to get some external inputs in as well

00:16:15,609 --> 00:16:21,069
getting an basic audio app store not

00:16:17,739 --> 00:16:24,129
hard but if you want to connect audio

00:16:21,069 --> 00:16:25,899
inputs like microphones and MIDI devices

00:16:24,129 --> 00:16:31,229
it is possible but there's a fair amount

00:16:25,899 --> 00:16:31,229
of configuration involved in doing it so

00:16:56,510 --> 00:17:04,370
it sounds good I have a microphone here

00:17:02,810 --> 00:17:07,370
this is merely I'm not going to sing or

00:17:04,370 --> 00:17:10,280
anything and because you do leave that

00:17:07,370 --> 00:17:11,990
this is merely for demonstrating that

00:17:10,280 --> 00:17:13,910
there and there is some audio input

00:17:11,990 --> 00:17:17,439
running through this engine had simply

00:17:13,910 --> 00:17:17,439
taken the input of applying a simple

00:17:19,000 --> 00:17:23,089
attenuation and filter on a low

00:17:21,230 --> 00:17:26,809
frequency oscillator and if I just sort

00:17:23,089 --> 00:17:35,390
of you know ah we can we can see that

00:17:26,809 --> 00:17:36,919
that's working simply because it sounds

00:17:35,390 --> 00:17:40,330
like it's chugging away like a freight

00:17:36,919 --> 00:17:40,330
train now I'm going to switch that off

00:17:40,900 --> 00:17:52,460
right and move on to the keyboard so

00:17:46,820 --> 00:17:53,280
again here I can play notes I can make a

00:17:52,460 --> 00:18:03,650
little choo

00:17:53,280 --> 00:18:06,030
[Music]

00:18:03,650 --> 00:18:13,809
[Applause]

00:18:06,030 --> 00:18:13,809
[Music]

00:18:19,200 --> 00:18:34,890
[Music]

00:18:26,930 --> 00:18:37,260
like so so that's actually am largely

00:18:34,890 --> 00:18:39,750
what I have in terms of demonstration

00:18:37,260 --> 00:18:43,110
and so forth just given that we have

00:18:39,750 --> 00:18:45,570
time on going to just get a little bit

00:18:43,110 --> 00:18:48,990
tikki and a little bit about the

00:18:45,570 --> 00:19:01,160
software how it's put together and what

00:18:48,990 --> 00:19:03,810
tools are used and and so forth right

00:19:01,160 --> 00:19:06,300
see the first thing I'm going to look at

00:19:03,810 --> 00:19:10,040
is just on those those audio wiring so

00:19:06,300 --> 00:19:12,690
the Audio API which is used as as Jack

00:19:10,040 --> 00:19:15,920
Jack as an audio application server on

00:19:12,690 --> 00:19:18,090
Linux it's very popular for this kind of

00:19:15,920 --> 00:19:20,550
musical applications because it's built

00:19:18,090 --> 00:19:23,550
around basically building signal paths

00:19:20,550 --> 00:19:27,750
and connections so we look at its

00:19:23,550 --> 00:19:31,170
interaction here's those clients which

00:19:27,750 --> 00:19:32,940
have come up my MIDI keyboard is

00:19:31,170 --> 00:19:41,160
connected by this connector into the

00:19:32,940 --> 00:19:44,390
application itself ends our application

00:19:41,160 --> 00:19:47,670
is connected to that system output

00:19:44,390 --> 00:19:50,550
there's various ways of doing the setup

00:19:47,670 --> 00:19:54,330
automatically I prefer to just you some

00:19:50,550 --> 00:19:56,880
scrubs there are some systems which will

00:19:54,330 --> 00:19:58,260
basically take a snapshot of what plants

00:19:56,880 --> 00:20:01,620
are running in why than I thought of

00:19:58,260 --> 00:20:02,820
medically I find them very unreliable so

00:20:01,620 --> 00:20:06,330
here I'm just simply running a script

00:20:02,820 --> 00:20:08,700
that runs the audio server there's a

00:20:06,330 --> 00:20:10,500
function here which just basically keeps

00:20:08,700 --> 00:20:14,430
trying to make those connections until

00:20:10,500 --> 00:20:16,410
they have a worker it goes forever and

00:20:14,430 --> 00:20:19,920
then it's just simply am connecting that

00:20:16,410 --> 00:20:22,020
MIDI input to the system and and so

00:20:19,920 --> 00:20:24,750
forth so it's just a nice simple way and

00:20:22,020 --> 00:20:28,310
it works well and it disables the Wi-Fi

00:20:24,750 --> 00:20:28,310
at the top because that kills things

00:20:31,740 --> 00:20:42,630
well have a look at some goalie as I've

00:20:36,110 --> 00:20:44,520
learned yesterday I'm deep as the has

00:20:42,630 --> 00:20:47,550
been the popular way of setting up a

00:20:44,520 --> 00:20:49,590
dependency management and go but it is

00:20:47,550 --> 00:20:52,500
falling out of fashion and I should

00:20:49,590 --> 00:20:55,560
really permitted modules my experiences

00:20:52,500 --> 00:21:05,420
with go deep have actually been pretty

00:20:55,560 --> 00:21:05,420
positive I need that yeah

00:21:10,570 --> 00:21:18,540
so we have our dip file things which

00:21:14,920 --> 00:21:22,480
give a little bit interesting here I'm

00:21:18,540 --> 00:21:25,950
bringing in the gopher jeaious package

00:21:22,480 --> 00:21:28,330
which is the JavaScript and transpiler

00:21:25,950 --> 00:21:30,040
why this is a little bit different from

00:21:28,330 --> 00:21:31,900
importing a regular package is it's

00:21:30,040 --> 00:21:34,330
actually a tool rather than a important

00:21:31,900 --> 00:21:35,680
dependency and so basically and port it

00:21:34,330 --> 00:21:37,120
and you build it and then you wind up

00:21:35,680 --> 00:21:45,430
with an executable which will transport

00:21:37,120 --> 00:21:47,250
go into JavaScript as I needed to make

00:21:45,430 --> 00:21:49,360
some tweaks to it to sort of get the

00:21:47,250 --> 00:21:51,220
performance output that I wanted from it

00:21:49,360 --> 00:21:54,100
of modify data bits so this is basically

00:21:51,220 --> 00:21:55,120
a fork on github so dip actually handles

00:21:54,100 --> 00:21:57,100
that pretty well you can basically

00:21:55,120 --> 00:22:00,430
support a project and then specify it

00:21:57,100 --> 00:22:04,420
some origin rather than using the

00:22:00,430 --> 00:22:07,240
original here have just got some extra

00:22:04,420 --> 00:22:16,650
libraries related to front-end and user

00:22:07,240 --> 00:22:16,650
interface so to have a look at the code

00:22:22,940 --> 00:22:28,999
right this section is just basically our

00:22:27,259 --> 00:22:33,739
main processor so we look right at the

00:22:28,999 --> 00:22:36,429
top we have a main processor which is

00:22:33,739 --> 00:22:40,639
just by taking an array of audio samples

00:22:36,429 --> 00:22:43,340
an array of MIDI events and then

00:22:40,639 --> 00:22:45,799
producing the corresponding samples out

00:22:43,340 --> 00:22:47,869
as well so notice here that's actually

00:22:45,799 --> 00:22:50,299
an array of arrays now the reason for

00:22:47,869 --> 00:22:51,979
that is that it might be a stereo input

00:22:50,299 --> 00:22:56,359
signal and so you're actually processing

00:22:51,979 --> 00:22:58,269
on to it once you know here we have our

00:22:56,359 --> 00:23:00,710
main loop we're going over every sample

00:22:58,269 --> 00:23:02,450
this is just a little bit of processing

00:23:00,710 --> 00:23:10,399
on that microphone input just a demo

00:23:02,450 --> 00:23:12,559
that it works and here oh this is

00:23:10,399 --> 00:23:15,019
interesting as well here we're basically

00:23:12,559 --> 00:23:16,460
taking a MIDI input event spring so

00:23:15,019 --> 00:23:21,529
every key that you press on the keyboard

00:23:16,460 --> 00:23:23,299
as a MIDI event there is a time to

00:23:21,529 --> 00:23:26,479
listen to wooden signals that are

00:23:23,299 --> 00:23:31,999
synthesized I can actually use in 1/2

00:23:26,479 --> 00:23:34,580
hour minimum viable synthesizer none of

00:23:31,999 --> 00:23:36,080
the inputs of this are MIDI the inputs

00:23:34,580 --> 00:23:38,929
of us are actually am trigger signals

00:23:36,080 --> 00:23:40,549
which and start the various things have

00:23:38,929 --> 00:23:42,710
to happen like that envelope generator

00:23:40,549 --> 00:23:44,539
running and a frequency which is the

00:23:42,710 --> 00:23:45,710
frequency of the oscillator runs so we

00:23:44,539 --> 00:23:47,779
need some way of basically taking those

00:23:45,710 --> 00:23:50,029
MIDI inputs and then turning them into

00:23:47,779 --> 00:23:53,960
those in the analog world we call them

00:23:50,029 --> 00:23:56,359
to see these a lot of those are just in

00:23:53,960 --> 00:23:59,450
the digital world we'll just call them

00:23:56,359 --> 00:24:03,919
numbers it's even a little bit more

00:23:59,450 --> 00:24:05,479
complicated in there because if we want

00:24:03,919 --> 00:24:07,729
to play more than one note at once we

00:24:05,479 --> 00:24:10,549
need some way of actually tracking the

00:24:07,729 --> 00:24:12,409
state of those those various notes this

00:24:10,549 --> 00:24:17,590
is an interesting side but they one of

00:24:12,409 --> 00:24:19,429
the reasons that synthesizers were not

00:24:17,590 --> 00:24:23,179
polyphonic until really about the late

00:24:19,429 --> 00:24:24,710
nineteen seventies early 1980s is that

00:24:23,179 --> 00:24:25,729
solving that problem and discreetly

00:24:24,710 --> 00:24:31,070
electronics it's actually really quite

00:24:25,729 --> 00:24:32,479
hard so and in digital electronics and

00:24:31,070 --> 00:24:34,399
microcontrollers it's actually quite

00:24:32,479 --> 00:24:36,110
easy and so the reason for that is

00:24:34,399 --> 00:24:38,720
there's quite a bit of state to track

00:24:36,110 --> 00:24:39,740
and so for that reason synthesizers

00:24:38,720 --> 00:24:41,620
which could actually generate multiple

00:24:39,740 --> 00:24:43,880
notes didn't really start becoming

00:24:41,620 --> 00:24:45,290
commonplace until around the late

00:24:43,880 --> 00:24:53,059
nineteen seventies might even nineteen

00:24:45,290 --> 00:24:55,100
eighties back to the codes that gives us

00:24:53,059 --> 00:24:59,210
an array of our frequencies within faded

00:24:55,100 --> 00:25:00,730
into a patch a patch just does those

00:24:59,210 --> 00:25:03,140
things that that minimum viable

00:25:00,730 --> 00:25:06,440
sequencer needs which is an input

00:25:03,140 --> 00:25:08,890
frequency an envelope generator and

00:25:06,440 --> 00:25:13,179
oscillator and then sums of mutton again

00:25:08,890 --> 00:25:13,179
and then that summed up into the output

00:25:25,629 --> 00:25:28,629
right

00:25:30,389 --> 00:25:34,739
javascript translation let's just have a

00:25:33,159 --> 00:25:39,340
look at the code for one of those

00:25:34,739 --> 00:25:40,450
processes like a envelope generator so

00:25:39,340 --> 00:25:42,460
that's kind of interesting

00:25:40,450 --> 00:25:44,080
so that envelope you know it's a it's a

00:25:42,460 --> 00:25:46,239
pretty simple state machine you know it

00:25:44,080 --> 00:25:47,559
starts in that idle phase and when it

00:25:46,239 --> 00:25:49,179
gets that trigger it goes to attack and

00:25:47,559 --> 00:25:50,739
then it goes to decay this is a very

00:25:49,179 --> 00:25:54,730
simple state machine and fermented

00:25:50,739 --> 00:25:55,989
without just a switch case statement so

00:25:54,730 --> 00:25:57,039
on the way up you know it's adding

00:25:55,989 --> 00:25:58,570
things and on the way down it's

00:25:57,039 --> 00:26:01,809
subtracting things and it's jumping

00:25:58,570 --> 00:26:04,350
through those various states if we have

00:26:01,809 --> 00:26:04,350
a look at the

00:26:16,460 --> 00:26:21,179
right there we got transpiled JavaScript

00:26:19,770 --> 00:26:23,730
that's you know it's actually pretty

00:26:21,179 --> 00:26:24,840
clean it's pretty readable it's pretty

00:26:23,730 --> 00:26:27,210
close to what you could actually write

00:26:24,840 --> 00:26:28,020
by hand so when I started looking at

00:26:27,210 --> 00:26:29,429
that I thought you know that's that's

00:26:28,020 --> 00:26:30,870
fireball I can actually take go and

00:26:29,429 --> 00:26:32,370
transport to JavaScript and get

00:26:30,870 --> 00:26:33,600
something which is about as efficient as

00:26:32,370 --> 00:26:35,429
would be able to write the hand oh I

00:26:33,600 --> 00:26:37,470
need to tweak it a bit you know make

00:26:35,429 --> 00:26:39,620
sure I get what I expect but it does

00:26:37,470 --> 00:26:39,620
work

00:26:42,809 --> 00:26:47,929
one of the caveats though with the trans

00:26:45,240 --> 00:26:53,010
piloff we'll go laying is that it does

00:26:47,929 --> 00:26:57,570
do a lot to give a consistent platform

00:26:53,010 --> 00:27:00,029
which is highly and can you just

00:26:57,570 --> 00:27:02,429
consistent we're firm they'd go and

00:27:00,029 --> 00:27:07,529
system and one of the expenses of that

00:27:02,429 --> 00:27:09,720
as a foreman so things like basically

00:27:07,529 --> 00:27:11,340
sort of type conversions as the jab the

00:27:09,720 --> 00:27:13,260
JavaScript doesn't have types is a bit

00:27:11,340 --> 00:27:15,480
of sort of fiddling that goes on when

00:27:13,260 --> 00:27:17,549
you expose a function of the Java strat

00:27:15,480 --> 00:27:20,070
Wilton in coulombs to go lean that

00:27:17,549 --> 00:27:22,190
involves some overhead one example of

00:27:20,070 --> 00:27:22,190
that

00:27:29,280 --> 00:27:34,400
find out when I first switched off my

00:27:31,440 --> 00:27:34,400
Wi-Fi it doesn't work anymore

00:27:48,880 --> 00:27:58,270
it's probably not I'm gonna decide

00:27:51,580 --> 00:28:01,450
that's not all that important yeah so

00:27:58,270 --> 00:28:04,230
one of the there's this thing so I can

00:28:01,450 --> 00:28:06,870
for example go has the some concept of a

00:28:04,230 --> 00:28:09,280
slice which is kind of a view of array

00:28:06,870 --> 00:28:10,720
in the transport JavaScript that will

00:28:09,280 --> 00:28:13,690
basically put a range check on every

00:28:10,720 --> 00:28:15,280
array access which doesn't really make a

00:28:13,690 --> 00:28:16,480
lot of sense and JavaScript cuz you're

00:28:15,280 --> 00:28:18,940
not going to get an exception if you try

00:28:16,480 --> 00:28:20,320
and read something that's not there so

00:28:18,940 --> 00:28:22,350
it's quite easy to actually jump into

00:28:20,320 --> 00:28:24,760
that source base and switch it off and

00:28:22,350 --> 00:28:27,040
many people do I should look at their

00:28:24,760 --> 00:28:28,870
project it's sort of you know several

00:28:27,040 --> 00:28:33,610
hundred Forks and like literally people

00:28:28,870 --> 00:28:37,230
doing the same kind of stuff how do you

00:28:33,610 --> 00:28:37,230
actually tie this into a browser

00:28:55,960 --> 00:29:00,039
yep very simple hands there who

00:28:57,940 --> 00:29:04,419
basically just create that audio context

00:29:00,039 --> 00:29:05,799
objects the browser's keep changing

00:29:04,419 --> 00:29:09,369
their policy on what's allowed to make

00:29:05,799 --> 00:29:10,720
sound and what's not so you have to do

00:29:09,369 --> 00:29:13,269
these workarounds they keep changing

00:29:10,720 --> 00:29:14,769
every year and sort of basically consent

00:29:13,269 --> 00:29:17,710
that the you know person using it

00:29:14,769 --> 00:29:20,049
actually wants sound so once you've

00:29:17,710 --> 00:29:22,950
clicked on some object on the browser

00:29:20,049 --> 00:29:25,539
then it's allowed to make noise again

00:29:22,950 --> 00:29:30,970
yeah we're simply creating a array of

00:29:25,539 --> 00:29:33,759
samples and they're passing atoms who

00:29:30,970 --> 00:29:36,210
are actual transport JavaScript so yeah

00:29:33,759 --> 00:29:36,210
nice and easy

00:29:40,090 --> 00:29:44,590
and just those general caveats were firm

00:29:42,759 --> 00:29:46,389
browser-based audio at some simple to

00:29:44,590 --> 00:29:47,649
set up and demo but it's a performance

00:29:46,389 --> 00:29:50,019
doesn't great and connectivity is

00:29:47,649 --> 00:29:53,519
limited she can't really actually MIDI

00:29:50,019 --> 00:29:53,519
devices without quite a bit of conflict

00:29:53,940 --> 00:30:03,879
so moving on to the 8a gear open source

00:30:01,990 --> 00:30:05,649
an embeddable implemented in C++ that's

00:30:03,879 --> 00:30:07,080
actually quite useful because if you

00:30:05,649 --> 00:30:10,840
really want to get close to the audio

00:30:07,080 --> 00:30:15,070
the native audio interfaces the best way

00:30:10,840 --> 00:30:16,809
to do that is for firm C so because you

00:30:15,070 --> 00:30:19,059
can actually just write that harness and

00:30:16,809 --> 00:30:21,580
C++ finger and the chrome engine see I'm

00:30:19,059 --> 00:30:27,490
sorry they're v8 engines implemented in

00:30:21,580 --> 00:30:29,799
C++ and well that works quite nicely and

00:30:27,490 --> 00:30:32,139
it's a single threaded so that's you

00:30:29,799 --> 00:30:34,419
know potentially a limitation it's an

00:30:32,139 --> 00:30:37,330
interesting sort of a side to audio

00:30:34,419 --> 00:30:39,279
processing which is particularly for DSP

00:30:37,330 --> 00:30:41,710
not much but actually very paralyzed

00:30:39,279 --> 00:30:43,720
well so the reason for that is if you've

00:30:41,710 --> 00:30:45,789
got anything like a feedback filter your

00:30:43,720 --> 00:30:47,200
NIC sample was dependent on the one that

00:30:45,789 --> 00:30:50,440
came before and there's just nowhere to

00:30:47,200 --> 00:30:52,330
paralyse that out the one thing that you

00:30:50,440 --> 00:30:54,039
can potentially don't want to the

00:30:52,330 --> 00:30:55,869
multi-core and parallel processing as if

00:30:54,039 --> 00:30:57,759
we've gotten strengths which makes a lot

00:30:55,869 --> 00:31:00,309
of notes you could sort of allocate a

00:30:57,759 --> 00:31:01,690
quarter note within this synchronization

00:31:00,309 --> 00:31:02,860
problems with that as well because

00:31:01,690 --> 00:31:04,330
they'd all has to be brought back to

00:31:02,860 --> 00:31:07,740
give her in a you know hard real-time

00:31:04,330 --> 00:31:07,740
deadline which is actually quite tricky

00:31:13,860 --> 00:31:17,740
front-ends

00:31:14,980 --> 00:31:23,410
yeah react to the one true way to write

00:31:17,740 --> 00:31:26,920
HTML notice and going there are bindings

00:31:23,410 --> 00:31:29,830
for react there are lots of them they

00:31:26,920 --> 00:31:31,530
all have issues and by spelling has an

00:31:29,830 --> 00:31:34,570
issue as well I'm going to ignore that

00:31:31,530 --> 00:31:49,780
again they're very hackable stuff we

00:31:34,570 --> 00:31:52,990
just have a look at the code right so we

00:31:49,780 --> 00:31:54,309
can see some you know react API stuff

00:31:52,990 --> 00:31:55,690
here which is I'm again just

00:31:54,309 --> 00:31:58,720
transporting to the actual JavaScript

00:31:55,690 --> 00:32:00,070
and used and those front end components

00:31:58,720 --> 00:32:01,720
end up being quite a bit simpler than

00:32:00,070 --> 00:32:07,990
what they are because they they no

00:32:01,720 --> 00:32:09,669
longer have to do their own update of

00:32:07,990 --> 00:32:11,169
state change when we get an event when

00:32:09,669 --> 00:32:12,910
you have the care you won't actually see

00:32:11,169 --> 00:32:14,230
the color change on that keyboards there

00:32:12,910 --> 00:32:15,610
rather than tracking those events and

00:32:14,230 --> 00:32:16,690
uploading the state we actually just

00:32:15,610 --> 00:32:18,160
stopped at the entire state of the

00:32:16,690 --> 00:32:25,600
keyboard and redraw it again react does

00:32:18,160 --> 00:32:27,640
magic as it does next things they want

00:32:25,600 --> 00:32:29,169
to do with this the first is actually

00:32:27,640 --> 00:32:31,090
just obviously just cover all the ground

00:32:29,169 --> 00:32:37,059
that I have my current existing software

00:32:31,090 --> 00:32:38,679
sampler and looper and I want to start

00:32:37,059 --> 00:32:42,160
building this new synthesizer reddit

00:32:38,679 --> 00:32:43,780
module starting actually the the point

00:32:42,160 --> 00:32:45,820
where this is going to become you know

00:32:43,780 --> 00:32:46,750
quite useful interesting to use this

00:32:45,820 --> 00:32:49,330
will have actually got a graphical

00:32:46,750 --> 00:32:50,770
editor and for this I can actually just

00:32:49,330 --> 00:32:53,830
why are these components happen test

00:32:50,770 --> 00:32:56,740
them on the fly when I first saw it from

00:32:53,830 --> 00:32:58,360
that is that one of the other reasons

00:32:56,740 --> 00:33:00,429
that makes JavaScript a really

00:32:58,360 --> 00:33:01,809
interesting platform for doing this is

00:33:00,429 --> 00:33:04,840
that when we go back to you know

00:33:01,809 --> 00:33:09,490
processing because we're dealing on a

00:33:04,840 --> 00:33:12,160
sample by sample timeframe right back to

00:33:09,490 --> 00:33:14,320
our Sun because we're dealing on a

00:33:12,160 --> 00:33:16,419
sample by sample timeframe if we just

00:33:14,320 --> 00:33:18,309
doing that in code it's fine but if

00:33:16,419 --> 00:33:19,680
we're actually talking about a graph

00:33:18,309 --> 00:33:22,200
definition that we're going to

00:33:19,680 --> 00:33:23,370
some basic graph traversal on to

00:33:22,200 --> 00:33:25,320
actually figure out the dependencies

00:33:23,370 --> 00:33:27,330
because one of the important things in

00:33:25,320 --> 00:33:28,980
the processing is just making saw sure

00:33:27,330 --> 00:33:30,630
that all those reverse dependencies are

00:33:28,980 --> 00:33:32,160
met so that the oscillator and the

00:33:30,630 --> 00:33:34,260
envelope here are actually ready before

00:33:32,160 --> 00:33:37,320
the gains done so that graph traversal

00:33:34,260 --> 00:33:39,450
pro time process actually takes more

00:33:37,320 --> 00:33:41,280
over here than been doing the work of

00:33:39,450 --> 00:33:43,350
the 11 of the DSP if it's going to be on

00:33:41,280 --> 00:33:44,760
a sample by sample basis so one of the

00:33:43,350 --> 00:33:46,920
really cool things about doing this in

00:33:44,760 --> 00:33:48,240
JavaScript it's because I can compile

00:33:46,920 --> 00:33:49,830
them the fly and actually basically just

00:33:48,240 --> 00:33:58,050
build code on the fly and then compile I

00:33:49,830 --> 00:34:00,270
can actually get it quite efficient and

00:33:58,050 --> 00:34:03,320
then I'd probably shoot pretty low for

00:34:00,270 --> 00:34:07,460
some demos to to actually build up first

00:34:03,320 --> 00:34:11,100
target the 8-bit era and generate some

00:34:07,460 --> 00:34:18,320
emulations of classics emphasizes sudden

00:34:11,100 --> 00:34:20,280
you know c64 sense and in ESA but and

00:34:18,320 --> 00:34:23,220
that that's where I'm gonna go off there

00:34:20,280 --> 00:34:45,420
and so and thank you very much and yeah

00:34:23,220 --> 00:34:50,430
it's been a lot of fun thanks my

00:34:45,420 --> 00:34:52,830
question ok good my question is with the

00:34:50,430 --> 00:34:54,510
graphical editor do you have any plan

00:34:52,830 --> 00:34:55,920
what are your plans for that you know

00:34:54,510 --> 00:34:57,870
these kind of drag and drop thingies

00:34:55,920 --> 00:34:59,190
yeah yeah so that's that's going to be

00:34:57,870 --> 00:35:01,290
an interesting question it's actually

00:34:59,190 --> 00:35:04,770
I'm a quite a hard one to solve in a

00:35:01,290 --> 00:35:07,860
number of ways it'll definitely be weird

00:35:04,770 --> 00:35:10,920
based on decided that's the way that I

00:35:07,860 --> 00:35:13,680
want to go one of the real complications

00:35:10,920 --> 00:35:16,170
the air is that kind of by necessity

00:35:13,680 --> 00:35:17,640
involves a back in front and split so

00:35:16,170 --> 00:35:21,210
the signal processing going on in the

00:35:17,640 --> 00:35:22,140
back end and then graphical editor

00:35:21,210 --> 00:35:23,790
around the front and they're gonna have

00:35:22,140 --> 00:35:25,050
to communicate by some kind of API and

00:35:23,790 --> 00:35:28,050
actually sort of splitting those out

00:35:25,050 --> 00:35:29,580
it's actually quite hard but yeah that's

00:35:28,050 --> 00:35:32,250
that's that's very much what I intend

00:35:29,580 --> 00:35:33,570
which Dolby drag-and-drop you have

00:35:32,250 --> 00:35:39,240
established a light of

00:35:33,570 --> 00:35:41,280
you know processes for one of the other

00:35:39,240 --> 00:35:45,570
things which gets a little bit tricky

00:35:41,280 --> 00:35:48,120
there here I've only got three

00:35:45,570 --> 00:35:49,710
processors but the fingers will actually

00:35:48,120 --> 00:35:51,870
didn't so that you know something useful

00:35:49,710 --> 00:35:53,280
there's gonna be hundreds of these so

00:35:51,870 --> 00:35:55,440
you actually need a way of kind of

00:35:53,280 --> 00:35:57,200
enumeration them and just having them is

00:35:55,440 --> 00:35:58,950
quite generic little processing units

00:35:57,200 --> 00:36:00,720
see all that the small thing called

00:35:58,950 --> 00:36:02,160
processor Factory and it just takes a

00:36:00,720 --> 00:36:05,070
name of a process or it gives you one

00:36:02,160 --> 00:36:09,870
back right but the next thing that's

00:36:05,070 --> 00:36:11,640
going to have to happen is in these

00:36:09,870 --> 00:36:13,860
processes I can put some metadata on

00:36:11,640 --> 00:36:15,440
them just saying these are your input

00:36:13,860 --> 00:36:18,000
parameters here's what they're called

00:36:15,440 --> 00:36:20,040
here's some sensible limits to them and

00:36:18,000 --> 00:36:22,710
here's their their beer accept all

00:36:20,040 --> 00:36:24,990
ranges so the the idea of the earth at

00:36:22,710 --> 00:36:26,820
that processor Factory and deface is

00:36:24,990 --> 00:36:28,080
actually going to give me back a process

00:36:26,820 --> 00:36:30,600
here where I can just ask what are your

00:36:28,080 --> 00:36:32,220
parameters and it's just going to lay

00:36:30,600 --> 00:36:34,550
them out and then your we are I'm still

00:36:32,220 --> 00:36:34,550
wire them up

00:36:45,610 --> 00:36:51,430
I think do you have can you give some

00:36:49,030 --> 00:36:52,900
idea of the performance and the browsers

00:36:51,430 --> 00:36:54,130
to kind of how many voices you might

00:36:52,900 --> 00:36:58,090
expect if you implement uh Cynthia

00:36:54,130 --> 00:37:00,250
bright yes a very good question these

00:36:58,090 --> 00:37:03,190
ones at the moment I'm kind of running

00:37:00,250 --> 00:37:04,690
up to kind of a hundred voices just to

00:37:03,190 --> 00:37:06,400
do benchmark testing and that's that's

00:37:04,690 --> 00:37:07,240
working alright now obviously that's

00:37:06,400 --> 00:37:08,470
going to get quite a bit more

00:37:07,240 --> 00:37:11,410
constrained when the voice has become

00:37:08,470 --> 00:37:13,060
quite a bit more complicated but it will

00:37:11,410 --> 00:37:14,860
you know it'll need to be in there in

00:37:13,060 --> 00:37:16,360
that sort of waters VM useful so

00:37:14,860 --> 00:37:19,000
benchmarking is can become quite

00:37:16,360 --> 00:37:21,700
important and a given one of the reasons

00:37:19,000 --> 00:37:22,900
I'm quite happy with using go so reflux

00:37:21,700 --> 00:37:27,910
lingers just what I would be able to do

00:37:22,900 --> 00:37:30,910
is build these are from JavaScript and

00:37:27,910 --> 00:37:32,440
test them but also compiled into native

00:37:30,910 --> 00:37:34,120
code and in beech marking into that's

00:37:32,440 --> 00:37:35,530
what we have to see quite quickly if I'm

00:37:34,120 --> 00:37:39,220
on the right track and the way the

00:37:35,530 --> 00:37:41,410
optimizations will yeah it needs to be

00:37:39,220 --> 00:37:44,140
hundreds of lists I mean so some of the

00:37:41,410 --> 00:37:46,870
more complicated synthesizer methods

00:37:44,140 --> 00:37:48,730
such as that additive work by just

00:37:46,870 --> 00:37:50,200
having a massive number of potential

00:37:48,730 --> 00:37:52,090
voices across the harmonic more at speak

00:37:50,200 --> 00:37:53,410
from and then building up from there so

00:37:52,090 --> 00:37:56,310
any you literally need hundreds of

00:37:53,410 --> 00:37:56,310

YouTube URL: https://www.youtube.com/watch?v=N8xwcLfjzNY


