Title: Open Source FPGA Tooling, Our Journey from Resistance to Adoption
Publication date: 2021-02-18
Playlist: Open Hardware Miniconf (LCA 2021)
Description: 
	Tim Saxe & Brian Faith

https://lca2021.linux.org.au/schedule/presentation/110/

This talk will take you on our journey from resistance to adoption of something unthinkable - An FPGA company adopting Open Source FPGA Tooling.

We are at a tipping point in the semiconductor industry.  Companies are demonstrating that you can build a successful business model based on open source; just look at the accelerating adoption rate that RISC-V ISA is seeing in the processor space.  And yet this is just the tip of the iceberg in terms of how disruptive open source hardware can become to the semiconductor industry.  

Since the inception of our industry, the vendor-supported FPGA development tools have been proprietary and closed source. Initially this was simply because that is the way things were done â€“ there were no open standards. But over time, keeping them closed and proprietary enabled a level of influence and control over users. If a designer liked your software, they tended not to change, and that implicitly makes your user base captive.

Open source FPGA tools have been around for a long time, being used primarily by hobbyists and in academia. Over the past few years, this situation has evolved, with an increasing number of new developers with software backgrounds gravitating towards open source FPGA development tools, including design teams at some of the largest companies in the electronics industry.

So, why do FPGA companies still resist them? 

Not Invented Here? Fear? Control?

This talk will serve two purposes:
1. To show how one company is building its future on top of open source FPGA tools
2. To share how we arrived at our decision in the hope that others will soon take the same leap.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by Next Day Video Australia: https://nextdayvideo.com.au

#linux.conf.au #linux #foss #opensource

Sat Jan 23 14:25:00 2021 at Rusty R. Hall
Captions: 
	00:00:10,820 --> 00:00:14,060
[Music]

00:00:15,120 --> 00:00:18,240
the open hardware mini conf

00:00:16,640 --> 00:00:20,080
we have a really exciting presentation

00:00:18,240 --> 00:00:22,400
this afternoon um we have

00:00:20,080 --> 00:00:23,439
here brian faith and tim sacks from

00:00:22,400 --> 00:00:26,640
quick logic

00:00:23,439 --> 00:00:27,439
uh brian is the ceo and tim is the cto i

00:00:26,640 --> 00:00:28,800
believe

00:00:27,439 --> 00:00:31,439
and they're going to be doing a talk

00:00:28,800 --> 00:00:35,440
today about fpgas

00:00:31,439 --> 00:00:36,960
and so if i tried to explain anything

00:00:35,440 --> 00:00:37,840
about this talk i would do a very bad

00:00:36,960 --> 00:00:39,920
job of it i think

00:00:37,840 --> 00:00:43,200
it would be best if i left it to brian

00:00:39,920 --> 00:00:44,800
so brian please take it away

00:00:43,200 --> 00:00:46,800
thanks jonathan it's great to be here uh

00:00:44,800 --> 00:00:47,920
with everybody uh coming in from the

00:00:46,800 --> 00:00:50,640
united states

00:00:47,920 --> 00:00:51,520
uh joining me is tim sacks our cto he's

00:00:50,640 --> 00:00:53,520
gonna lead us off

00:00:51,520 --> 00:00:55,039
and then uh if there's time then i'll

00:00:53,520 --> 00:00:58,079
come back at the end

00:00:55,039 --> 00:01:01,840
so tim okay great thank you

00:00:58,079 --> 00:01:04,239
both of you so um

00:01:01,840 --> 00:01:05,519
what i'm going to talk about is is a

00:01:04,239 --> 00:01:07,200
small device we built

00:01:05,519 --> 00:01:09,040
so here's a here's a board we have a

00:01:07,200 --> 00:01:11,119
quick feather board we call it we work

00:01:09,040 --> 00:01:12,159
it's a feather form factor we're working

00:01:11,119 --> 00:01:15,119
on a quick thing

00:01:12,159 --> 00:01:16,159
uh version of it and on it is this small

00:01:15,119 --> 00:01:18,400
device

00:01:16,159 --> 00:01:20,000
which was designed for wearables it has

00:01:18,400 --> 00:01:22,720
an m4 processor in it

00:01:20,000 --> 00:01:25,280
a little piece of fpga some memory

00:01:22,720 --> 00:01:26,799
microphones that kind of thing

00:01:25,280 --> 00:01:29,119
and what i'm going to show you is an

00:01:26,799 --> 00:01:32,880
evolution i went through this year

00:01:29,119 --> 00:01:34,880
we we decided to do a hackster io event

00:01:32,880 --> 00:01:36,320
about environment kind of things and we

00:01:34,880 --> 00:01:38,720
decided to do this right at the time

00:01:36,320 --> 00:01:42,000
when california was burning up

00:01:38,720 --> 00:01:44,720
so i got this blue box which is uh from

00:01:42,000 --> 00:01:47,040
adafruit which is a pm 2.5

00:01:44,720 --> 00:01:48,479
um sensor and i hooked it up to a quick

00:01:47,040 --> 00:01:51,119
feather so i could see what the air

00:01:48,479 --> 00:01:55,200
quality was and it was terrible

00:01:51,119 --> 00:01:57,040
and then um more recently i decided well

00:01:55,200 --> 00:01:59,600
that's kind of fun but it would be more

00:01:57,040 --> 00:02:02,240
fun to add more stuff to it

00:01:59,600 --> 00:02:03,040
so what i did was i took a another quick

00:02:02,240 --> 00:02:04,960
feather

00:02:03,040 --> 00:02:07,119
hooked up to uh another one of these

00:02:04,960 --> 00:02:10,720
boxes but i added this unit

00:02:07,119 --> 00:02:13,840
here which is uh mdot laura

00:02:10,720 --> 00:02:14,560
transmitter and the blue box over here

00:02:13,840 --> 00:02:17,040
is the

00:02:14,560 --> 00:02:19,040
laura receiver so i'll show you the

00:02:17,040 --> 00:02:22,560
process i went through to hook this up

00:02:19,040 --> 00:02:25,599
and the role that the fpga plays in this

00:02:22,560 --> 00:02:28,480
so if we could please switch to the

00:02:25,599 --> 00:02:28,480
screen share

00:02:28,959 --> 00:02:33,599
so we started when we started on this

00:02:31,680 --> 00:02:35,920
chip we were one of the the classical

00:02:33,599 --> 00:02:36,959
uh proprietary companies but we've we've

00:02:35,920 --> 00:02:39,680
been transitioning

00:02:36,959 --> 00:02:41,360
more to open source actually going 100

00:02:39,680 --> 00:02:43,280
in on open source

00:02:41,360 --> 00:02:44,959
so on our quick logic website you will

00:02:43,280 --> 00:02:47,920
see a couple of things you'll see

00:02:44,959 --> 00:02:49,040
a cork sdk which is the thing that runs

00:02:47,920 --> 00:02:50,800
on here

00:02:49,040 --> 00:02:52,160
you'll see a quick feather board which

00:02:50,800 --> 00:02:54,800
is the documentation on

00:02:52,160 --> 00:02:57,200
on the board i just showed you and

00:02:54,800 --> 00:02:59,200
you'll see a quick logic fpga tool chain

00:02:57,200 --> 00:03:01,120
although that's being replaced now by a

00:02:59,200 --> 00:03:02,879
simbaflow tool chain which is an open

00:03:01,120 --> 00:03:06,239
source tool chain for programming

00:03:02,879 --> 00:03:09,840
the fpga so

00:03:06,239 --> 00:03:09,840
how did i set this thing up well

00:03:14,720 --> 00:03:21,599
uh oh screenings not switching

00:03:18,239 --> 00:03:21,599
so i created a uh

00:03:21,840 --> 00:03:27,519
and i have it's in in the cork sdk

00:03:25,680 --> 00:03:29,599
so if you go into that repo and have a

00:03:27,519 --> 00:03:32,080
look you can you can find it there's a

00:03:29,599 --> 00:03:34,319
readme in there and it explains

00:03:32,080 --> 00:03:35,360
it goes through that this little

00:03:34,319 --> 00:03:37,360
adafruit box

00:03:35,360 --> 00:03:38,720
it shows you all of the pin out on it it

00:03:37,360 --> 00:03:39,440
shows you how you would make the

00:03:38,720 --> 00:03:41,680
decisions

00:03:39,440 --> 00:03:42,879
and which pins to choose to hook up and

00:03:41,680 --> 00:03:44,799
so forth

00:03:42,879 --> 00:03:46,640
turns out this particular version hooks

00:03:44,799 --> 00:03:50,000
up with the uart

00:03:46,640 --> 00:03:53,680
so i have this bunch of cables

00:03:50,000 --> 00:03:53,680
essentially just supplies power

00:03:54,000 --> 00:03:58,480
so here's the uh the readme for that

00:03:57,360 --> 00:04:01,439
application

00:03:58,480 --> 00:04:02,640
showing the box showing the pin out so

00:04:01,439 --> 00:04:04,480
you can

00:04:02,640 --> 00:04:05,920
it's showing the quick feather how it

00:04:04,480 --> 00:04:08,239
connects up

00:04:05,920 --> 00:04:11,040
and then the thought process on all of

00:04:08,239 --> 00:04:13,519
these the pins and how to drive it

00:04:11,040 --> 00:04:14,080
how how i figured out which pins to use

00:04:13,519 --> 00:04:16,239
because

00:04:14,080 --> 00:04:18,239
uh you know as it's common with most

00:04:16,239 --> 00:04:19,199
parts every pin can be used for several

00:04:18,239 --> 00:04:21,120
functions and

00:04:19,199 --> 00:04:23,120
and they never quite line up the way you

00:04:21,120 --> 00:04:26,000
would like them to so i stepped

00:04:23,120 --> 00:04:28,320
people through all of that and then the

00:04:26,000 --> 00:04:31,919
result of

00:04:28,320 --> 00:04:31,919
the result of all of this then

00:04:34,400 --> 00:04:38,320
is of course some code and the

00:04:36,800 --> 00:04:40,080
interesting thing about

00:04:38,320 --> 00:04:41,520
about the part is that you might have

00:04:40,080 --> 00:04:44,240
noticed that we have a usb

00:04:41,520 --> 00:04:47,040
connector and a usb cable but we don't

00:04:44,240 --> 00:04:47,040
have a usb

00:04:47,280 --> 00:04:51,440
peripheral in there so what we do is we

00:04:49,680 --> 00:04:54,720
program the fpga

00:04:51,440 --> 00:04:56,479
to be the us to do the usb function

00:04:54,720 --> 00:04:57,840
so if you look at our main function here

00:04:56,479 --> 00:05:00,880
we set up some clocks

00:04:57,840 --> 00:05:04,320
we load the fpga with a bit stream

00:05:00,880 --> 00:05:04,639
and here's what the bit stream looks

00:05:04,320 --> 00:05:06,880
like

00:05:04,639 --> 00:05:08,880
it's a kind of human and readable but

00:05:06,880 --> 00:05:10,960
that's that's life

00:05:08,880 --> 00:05:13,120
and when that bitstream's loaded then we

00:05:10,960 --> 00:05:15,199
can run usb serial init

00:05:13,120 --> 00:05:17,199
and we have our serial port hooked up

00:05:15,199 --> 00:05:18,320
all these messages then pop out on the

00:05:17,199 --> 00:05:21,280
stream

00:05:18,320 --> 00:05:22,960
and then we start uh the debug the

00:05:21,280 --> 00:05:26,400
monitor task

00:05:22,960 --> 00:05:29,440
so the monitor task as you'd expect

00:05:26,400 --> 00:05:30,720
looks like this so essentially it issues

00:05:29,440 --> 00:05:33,280
a reset

00:05:30,720 --> 00:05:34,400
uh brings the device out of reset and

00:05:33,280 --> 00:05:37,440
then it sits here just

00:05:34,400 --> 00:05:39,759
reading the bytes from the device and

00:05:37,440 --> 00:05:40,560
as it reads the device if i've set this

00:05:39,759 --> 00:05:43,680
variable

00:05:40,560 --> 00:05:46,080
it prints out the pm 2.5 standard to the

00:05:43,680 --> 00:05:47,600
screen and i can see it on the screen

00:05:46,080 --> 00:05:50,240
so now what i'm going to and that's all

00:05:47,600 --> 00:05:53,759
handled with our

00:05:50,240 --> 00:05:56,880
command line interface so we we set up

00:05:53,759 --> 00:06:00,720
an ability to toggle variables and and

00:05:56,880 --> 00:06:04,800
stuff like that so here we go uh

00:06:00,720 --> 00:06:04,800
just gotta find the right screen here

00:06:04,840 --> 00:06:10,160
yeah so here i've i'm connected to that

00:06:08,400 --> 00:06:12,319
first quick feather i say help

00:06:10,160 --> 00:06:13,600
it says hey you get to do these things

00:06:12,319 --> 00:06:17,840
so i'm going to say show

00:06:13,600 --> 00:06:19,280
2.5 and it starts printing out the pm

00:06:17,840 --> 00:06:21,680
2.5

00:06:19,280 --> 00:06:23,440
there's also an led on the device which

00:06:21,680 --> 00:06:25,600
you might have noticed blinking so i can

00:06:23,440 --> 00:06:26,880
link the colors according to the aqi so

00:06:25,600 --> 00:06:30,720
i can make it you know

00:06:26,880 --> 00:06:34,160
green yellow red so that was

00:06:30,720 --> 00:06:35,759
the simple one now how do we

00:06:34,160 --> 00:06:37,600
how do we get to laura it's an

00:06:35,759 --> 00:06:48,080
interesting question

00:06:37,600 --> 00:06:51,599
so the issue um

00:06:48,080 --> 00:06:54,080
so the issue with laura is now

00:06:51,599 --> 00:06:54,960
the lora device also hooks up with a

00:06:54,080 --> 00:06:58,479
uart

00:06:54,960 --> 00:06:58,479
and the quick feather only has

00:06:59,599 --> 00:07:04,479
only has one ui port on it and the

00:07:02,240 --> 00:07:07,520
serial port for the

00:07:04,479 --> 00:07:09,440
for the usb so i need a third uart port

00:07:07,520 --> 00:07:11,440
so how am i going to get that

00:07:09,440 --> 00:07:13,840
so the way we do that is by using the

00:07:11,440 --> 00:07:15,199
embedded fpga so this is one of the uses

00:07:13,840 --> 00:07:18,080
for the embedded fpga

00:07:15,199 --> 00:07:19,360
another use is for running high-speed

00:07:18,080 --> 00:07:22,160
peripherals

00:07:19,360 --> 00:07:23,360
so we did some work with megahertz kind

00:07:22,160 --> 00:07:26,479
of adc

00:07:23,360 --> 00:07:27,680
and we had to run spy at a megahertz not

00:07:26,479 --> 00:07:29,680
the spy bit rate but

00:07:27,680 --> 00:07:31,840
trigger spy transactions once every

00:07:29,680 --> 00:07:34,720
microsecond to read the adc

00:07:31,840 --> 00:07:35,440
use the fpga for that so in this case

00:07:34,720 --> 00:07:39,520
what i do

00:07:35,440 --> 00:07:42,960
is we have some gatewayer and we have a

00:07:39,520 --> 00:07:45,280
two ui piece of gatewayer i need the two

00:07:42,960 --> 00:07:47,360
uarts because if i'm using the fpga for

00:07:45,280 --> 00:07:47,919
the uarts i can't also use it for the

00:07:47,360 --> 00:07:51,440
usb

00:07:47,919 --> 00:07:54,560
serial why you ask is that true well

00:07:51,440 --> 00:07:56,080
the open source code right now doesn't

00:07:54,560 --> 00:07:57,360
get us enough performance out of the

00:07:56,080 --> 00:07:59,680
fpga

00:07:57,360 --> 00:08:02,000
to be able to run to use the open source

00:07:59,680 --> 00:08:03,520
fpga compilers to run the usb

00:08:02,000 --> 00:08:05,440
that's something that we expect to get

00:08:03,520 --> 00:08:08,720
fixed in the next few months if we

00:08:05,440 --> 00:08:12,400
it's the open source software improves

00:08:08,720 --> 00:08:16,479
so so we load two different fpgas

00:08:12,400 --> 00:08:18,560
into two different uarts into the fpga

00:08:16,479 --> 00:08:20,160
one of them connects to this command

00:08:18,560 --> 00:08:21,520
line interface the other one connects to

00:08:20,160 --> 00:08:24,840
the pm 2.5

00:08:21,520 --> 00:08:27,039
and then the third one i use for

00:08:24,840 --> 00:08:29,440
snooping uh

00:08:27,039 --> 00:08:30,800
for talking to the laura and then i also

00:08:29,440 --> 00:08:33,039
have a another

00:08:30,800 --> 00:08:34,640
physical ui so i can snoop on all of

00:08:33,039 --> 00:08:36,880
that then of course the

00:08:34,640 --> 00:08:38,479
laura radio talks to this multi-tech box

00:08:36,880 --> 00:08:40,959
the big blue box i showed you

00:08:38,479 --> 00:08:42,719
and then with ethernet we can go talk to

00:08:40,959 --> 00:08:45,839
that

00:08:42,719 --> 00:08:48,000
so what does that software look like so

00:08:45,839 --> 00:08:51,680
let's kill this

00:08:48,000 --> 00:08:53,920
so the main program um changes

00:08:51,680 --> 00:08:56,560
just a little bit so we set up the

00:08:53,920 --> 00:09:00,560
clocks again this time though we don't

00:08:56,560 --> 00:09:03,519
load the uh we load the fpga

00:09:00,560 --> 00:09:05,440
but we have a different dot h file so

00:09:03,519 --> 00:09:08,320
now we're loading top dot bit

00:09:05,440 --> 00:09:10,000
which actually has the usb stuff in we

00:09:08,320 --> 00:09:12,080
configure the usb

00:09:10,000 --> 00:09:13,360
and then we start a lower task and we

00:09:12,080 --> 00:09:16,720
start a pm

00:09:13,360 --> 00:09:20,399
2.5 task so

00:09:16,720 --> 00:09:23,760
uh topbit.h

00:09:20,399 --> 00:09:28,480
again not very readable

00:09:23,760 --> 00:09:31,600
um basic fpga this is all in verilog

00:09:28,480 --> 00:09:34,399
uh not the most friendly language in

00:09:31,600 --> 00:09:35,200
in in the world but that's the way it is

00:09:34,399 --> 00:09:37,760
and

00:09:35,200 --> 00:09:40,640
um the thing we really like about this

00:09:37,760 --> 00:09:43,279
is is the build process

00:09:40,640 --> 00:09:44,640
so i ran a build just a few minutes ago

00:09:43,279 --> 00:09:46,480
and you can see this is sort of a

00:09:44,640 --> 00:09:47,600
conventional build where we we go

00:09:46,480 --> 00:09:49,519
through and we enter

00:09:47,600 --> 00:09:50,959
the various directories so we enter the

00:09:49,519 --> 00:09:52,560
startup directory make it

00:09:50,959 --> 00:09:55,920
i've already done it so nothing to do

00:09:52,560 --> 00:09:58,000
how free rtos so on and so forth

00:09:55,920 --> 00:09:59,040
and then down here you'll notice that we

00:09:58,000 --> 00:10:02,079
dive into this

00:09:59,040 --> 00:10:06,000
this directory called gateway with

00:10:02,079 --> 00:10:09,760
s3 fpga 2 by uart we run

00:10:06,000 --> 00:10:13,360
ql simba flow which is the open source

00:10:09,760 --> 00:10:15,120
fpga compiler that munches on this

00:10:13,360 --> 00:10:18,000
string of verilog files

00:10:15,120 --> 00:10:20,480
and creates this top bit file which it

00:10:18,000 --> 00:10:25,360
pushes into the right directory

00:10:20,480 --> 00:10:25,360
and then the compile continues and

00:10:25,440 --> 00:10:30,800
incorporates that bitstream we do the

00:10:27,360 --> 00:10:32,720
link and then when we program the part

00:10:30,800 --> 00:10:34,640
which i did down here program the part

00:10:32,720 --> 00:10:35,200
now i've got my uarts in there instead

00:10:34,640 --> 00:10:38,240
of my

00:10:35,200 --> 00:10:40,240
my serial usb so you can sort of see the

00:10:38,240 --> 00:10:42,000
power of this now integrated method

00:10:40,240 --> 00:10:44,640
where you can treat the verilog

00:10:42,000 --> 00:10:45,519
just like you treat c code and bring it

00:10:44,640 --> 00:10:48,240
in there

00:10:45,519 --> 00:10:49,920
now it's a little wasteful to put the

00:10:48,240 --> 00:10:51,519
bit stream into the memory and load it

00:10:49,920 --> 00:10:52,720
from there so just another option to

00:10:51,519 --> 00:10:56,000
program the bitstream

00:10:52,720 --> 00:10:58,240
into into the flash device

00:10:56,000 --> 00:11:00,079
and then you load the m4 code from the

00:10:58,240 --> 00:11:01,440
flash device when you load the fpga from

00:11:00,079 --> 00:11:04,560
the flash device so

00:11:01,440 --> 00:11:06,560
you don't take the memory up to do that

00:11:04,560 --> 00:11:08,959
so now let's look at how we how we

00:11:06,560 --> 00:11:13,360
changed the code

00:11:08,959 --> 00:11:15,279
so the 2.5 task now

00:11:13,360 --> 00:11:16,880
i have a variable set where i say well

00:11:15,279 --> 00:11:18,959
do you want me to transmit

00:11:16,880 --> 00:11:21,279
the 2.5 stuff if you do want me to

00:11:18,959 --> 00:11:23,680
transmit the 2.5 stuff

00:11:21,279 --> 00:11:24,480
i write it in a particular variable i

00:11:23,680 --> 00:11:27,519
set this thing

00:11:24,480 --> 00:11:29,360
called f new data true and then the

00:11:27,519 --> 00:11:32,640
loratosk

00:11:29,360 --> 00:11:35,440
which is running in parallel uh

00:11:32,640 --> 00:11:37,040
he sets up uh tells it to join notice

00:11:35,440 --> 00:11:38,720
how we use at commands

00:11:37,040 --> 00:11:40,480
they've been around forever probably

00:11:38,720 --> 00:11:42,800
will be around forever

00:11:40,480 --> 00:11:45,360
if there's new data it creates this at

00:11:42,800 --> 00:11:48,880
command that includes the

00:11:45,360 --> 00:11:51,600
the data the 2.5 level

00:11:48,880 --> 00:11:52,240
sends it out over the ur to the lower

00:11:51,600 --> 00:11:55,279
device

00:11:52,240 --> 00:11:56,079
echoes it to my console gets the

00:11:55,279 --> 00:11:58,560
response back

00:11:56,079 --> 00:11:59,360
it goes up to the console sets that new

00:11:58,560 --> 00:12:01,360
data false

00:11:59,360 --> 00:12:03,680
waits a while and then continues in the

00:12:01,360 --> 00:12:06,079
loop so we've got these two tasks

00:12:03,680 --> 00:12:07,519
running together the pm 2.5 task is

00:12:06,079 --> 00:12:11,200
monitoring

00:12:07,519 --> 00:12:13,440
the little pm 2.5 device and every

00:12:11,200 --> 00:12:16,079
10 seconds or so it spits data out to

00:12:13,440 --> 00:12:19,680
the laura the laura transmits it and it

00:12:16,079 --> 00:12:22,399
shows up somewhere else most of the time

00:12:19,680 --> 00:12:24,160
um so we'll have a look at that so let

00:12:22,399 --> 00:12:26,480
me just pop up several windows

00:12:24,160 --> 00:12:26,480
here

00:12:30,399 --> 00:12:37,120
so this is uh this screen

00:12:34,160 --> 00:12:38,880
bottom right here is the console screen

00:12:37,120 --> 00:12:40,079
so you see that every now and then it's

00:12:38,880 --> 00:12:43,680
saying

00:12:40,079 --> 00:12:44,079
at send zero so right now my pm 2.5

00:12:43,680 --> 00:12:47,120
level

00:12:44,079 --> 00:12:49,519
zero so my room's nice and clean

00:12:47,120 --> 00:12:50,320
and then it gets back it's the echo so

00:12:49,519 --> 00:12:54,000
the mdot

00:12:50,320 --> 00:12:56,240
echoes yep i thought send and i'm okay

00:12:54,000 --> 00:12:57,200
this is actually the screen on the left

00:12:56,240 --> 00:12:58,880
here uh

00:12:57,200 --> 00:13:00,720
that i'm bouncing up and down is the one

00:12:58,880 --> 00:13:01,360
that's tracking what's actually going to

00:13:00,720 --> 00:13:03,200
the

00:13:01,360 --> 00:13:04,880
lora device so you can just see i send

00:13:03,200 --> 00:13:07,440
the a a t

00:13:04,880 --> 00:13:10,399
plus send zero uh you can see my my air

00:13:07,440 --> 00:13:13,360
quality is deteriorating it went to one

00:13:10,399 --> 00:13:14,720
and then this top screen is the ssh

00:13:13,360 --> 00:13:17,920
screen over to the

00:13:14,720 --> 00:13:18,480
laura receiver and it's printing out all

00:13:17,920 --> 00:13:21,440
of this

00:13:18,480 --> 00:13:22,959
mess of stuff um more information tons

00:13:21,440 --> 00:13:24,240
of information tells you what frequency

00:13:22,959 --> 00:13:25,920
is running at

00:13:24,240 --> 00:13:27,839
the critical thing in here is this

00:13:25,920 --> 00:13:30,880
little phrase data

00:13:27,839 --> 00:13:33,440
so you'll say up here it's saying data

00:13:30,880 --> 00:13:35,839
m a equal equal and down here it says

00:13:33,440 --> 00:13:37,839
data and q equal equal

00:13:35,839 --> 00:13:42,000
so what's going on so if we look at the

00:13:37,839 --> 00:13:43,920
uh the m dot they do a base 64 encoding

00:13:42,000 --> 00:13:45,199
so it turns out that m a is the way in

00:13:43,920 --> 00:13:48,399
code is it the

00:13:45,199 --> 00:13:51,600
ascii character for zero and q is

00:13:48,399 --> 00:13:53,279
like mq's the way you encode the ascii

00:13:51,600 --> 00:13:55,519
character for one

00:13:53,279 --> 00:13:56,800
of course the nice thing about this is

00:13:55,519 --> 00:14:03,279
that they

00:13:56,800 --> 00:14:06,240
use linux so

00:14:03,279 --> 00:14:07,839
so what i can do is take that stream and

00:14:06,240 --> 00:14:10,560
i have a nice little

00:14:07,839 --> 00:14:12,480
uh awk file here that i just entered all

00:14:10,560 --> 00:14:13,600
of these tables because i was too lazy

00:14:12,480 --> 00:14:16,639
to actually try to

00:14:13,600 --> 00:14:17,360
write the base64 decoder so my little

00:14:16,639 --> 00:14:20,399
arc script

00:14:17,360 --> 00:14:20,720
reads that string coming out strips out

00:14:20,399 --> 00:14:24,000
the

00:14:20,720 --> 00:14:27,120
data field and then runs it through this

00:14:24,000 --> 00:14:30,480
transformation array and

00:14:27,120 --> 00:14:33,360
with any luck i can

00:14:30,480 --> 00:14:33,360
go back there

00:14:33,760 --> 00:14:37,839
now what we see is what used to be this

00:14:35,839 --> 00:14:38,480
big string is translated into nice

00:14:37,839 --> 00:14:41,600
little

00:14:38,480 --> 00:14:42,480
information pm 2.5 is zero and then i

00:14:41,600 --> 00:14:45,519
put in

00:14:42,480 --> 00:14:47,279
the base base64 decoding just so i can

00:14:45,519 --> 00:14:49,600
i can see whether everything's working

00:14:47,279 --> 00:14:52,880
right so that gives you

00:14:49,600 --> 00:14:53,600
i hope a little insight into what we can

00:14:52,880 --> 00:14:56,320
do

00:14:53,600 --> 00:14:58,800
with the uh with the quick feather it

00:14:56,320 --> 00:15:01,600
gives you a little insight into

00:14:58,800 --> 00:15:02,560
what you can do if you have fpga built

00:15:01,600 --> 00:15:05,120
in

00:15:02,560 --> 00:15:06,240
our vision going forward is to add more

00:15:05,120 --> 00:15:10,560
fpga

00:15:06,240 --> 00:15:13,519
and to by using open source tools to

00:15:10,560 --> 00:15:15,279
make it run faster one of the challenges

00:15:13,519 --> 00:15:17,199
i believe today with fpga

00:15:15,279 --> 00:15:19,199
is all of that stuff that's really

00:15:17,199 --> 00:15:21,360
designed for hardware engineers hardware

00:15:19,199 --> 00:15:24,560
engineers are used to a very

00:15:21,360 --> 00:15:26,320
expensive time-consuming world so

00:15:24,560 --> 00:15:29,440
they're very patient

00:15:26,320 --> 00:15:30,639
with compilers i find most software

00:15:29,440 --> 00:15:32,160
engineers are a lot more

00:15:30,639 --> 00:15:34,800
impatient and want things to happen

00:15:32,160 --> 00:15:35,920
quickly and we would like to enable that

00:15:34,800 --> 00:15:39,120
for people

00:15:35,920 --> 00:15:39,759
and we would like to tie it in such that

00:15:39,120 --> 00:15:42,720
you can

00:15:39,759 --> 00:15:43,759
you can actually use the fpga for more

00:15:42,720 --> 00:15:46,320
interesting tasks

00:15:43,759 --> 00:15:47,279
like pre-processing data so we do things

00:15:46,320 --> 00:15:49,199
like um

00:15:47,279 --> 00:15:51,199
digital filtering in the fpga so we

00:15:49,199 --> 00:15:53,440
offload the cpu

00:15:51,199 --> 00:15:55,279
we do convolutions when it comes to

00:15:53,440 --> 00:15:57,920
things like machine learning we push

00:15:55,279 --> 00:15:59,920
the convolutions off into the fpga we

00:15:57,920 --> 00:16:03,120
see a whole world of that

00:15:59,920 --> 00:16:03,120
building up and developing

00:16:03,199 --> 00:16:10,800
so that is my brief demo of our

00:16:07,120 --> 00:16:13,199
hardware and where we've gotten so far

00:16:10,800 --> 00:16:13,199
brian

00:16:14,320 --> 00:16:17,279
over to you i think

00:16:17,839 --> 00:16:23,120
yeah i can do some uh sharing of

00:16:20,959 --> 00:16:24,480
our journey to this point and then uh

00:16:23,120 --> 00:16:26,240
i'm sure we'll have time for questions

00:16:24,480 --> 00:16:26,880
so that people can ask you tim questions

00:16:26,240 --> 00:16:29,440
on

00:16:26,880 --> 00:16:30,079
all that cool stuff you built out of it

00:16:29,440 --> 00:16:32,560
okay

00:16:30,079 --> 00:16:34,320
so um the title of this was actually our

00:16:32,560 --> 00:16:37,040
journey from resistance to adoption

00:16:34,320 --> 00:16:38,320
and um this was actually we just wanted

00:16:37,040 --> 00:16:39,440
to share with everybody how we got to

00:16:38,320 --> 00:16:41,839
this point because

00:16:39,440 --> 00:16:43,199
uh most programmable logic companies

00:16:41,839 --> 00:16:44,800
sort of resist doing anything in the

00:16:43,199 --> 00:16:48,160
open source domain so

00:16:44,800 --> 00:16:50,160
um not to market this at all quicklogix

00:16:48,160 --> 00:16:51,600
start as a programmable logic company we

00:16:50,160 --> 00:16:53,120
have devices like what tim was talking

00:16:51,600 --> 00:16:54,639
about that have combinations of

00:16:53,120 --> 00:16:55,920
microcontroller and fpga on the same

00:16:54,639 --> 00:16:57,839
chip and then we do

00:16:55,920 --> 00:17:00,240
um things like the quick featherboard

00:16:57,839 --> 00:17:01,440
and and soon to be others that are all

00:17:00,240 --> 00:17:04,240
open source

00:17:01,440 --> 00:17:05,039
so um we started as a company 30 years

00:17:04,240 --> 00:17:06,959
ago actually

00:17:05,039 --> 00:17:08,880
and 60 companies have come and gone in

00:17:06,959 --> 00:17:10,799
that space in that time frame

00:17:08,880 --> 00:17:12,160
and uh a lot of them have actually

00:17:10,799 --> 00:17:14,400
failed and

00:17:12,160 --> 00:17:15,919
it's an interesting trivia question but

00:17:14,400 --> 00:17:19,120
almost in every case

00:17:15,919 --> 00:17:20,959
it's due to software or lack thereof um

00:17:19,120 --> 00:17:22,880
and so for the ones that have lasted

00:17:20,959 --> 00:17:24,240
it's really about having robust software

00:17:22,880 --> 00:17:26,720
and that software is actually a walled

00:17:24,240 --> 00:17:27,280
garden so in most cases fpga companies

00:17:26,720 --> 00:17:28,880
like

00:17:27,280 --> 00:17:30,400
having people use proprietary tools

00:17:28,880 --> 00:17:33,840
because there's lock-in

00:17:30,400 --> 00:17:36,080
and then you're kind of stuck so um

00:17:33,840 --> 00:17:37,840
we took a very random path to get this

00:17:36,080 --> 00:17:39,280
point and i bet a lot of people

00:17:37,840 --> 00:17:41,039
uh that are watching this actually

00:17:39,280 --> 00:17:43,600
recognize that face there on the

00:17:41,039 --> 00:17:45,600
on the slide but this was a incredibly

00:17:43,600 --> 00:17:47,840
random path that led to this point

00:17:45,600 --> 00:17:50,160
um and if anybody needs a lesson in

00:17:47,840 --> 00:17:51,039
persistence uh you can go talk with tim

00:17:50,160 --> 00:17:54,080
ansel because

00:17:51,039 --> 00:17:56,400
he's a persistent guy um so

00:17:54,080 --> 00:17:57,840
you know it's it's actually incredible

00:17:56,400 --> 00:17:58,240
to go out and talk to these different

00:17:57,840 --> 00:18:00,880
folks

00:17:58,240 --> 00:18:01,280
in industry and in academia to realize

00:18:00,880 --> 00:18:03,280
so

00:18:01,280 --> 00:18:04,720
how far open source tools have come to

00:18:03,280 --> 00:18:06,559
the point where tim can

00:18:04,720 --> 00:18:07,919
knock out that demo in in less than a

00:18:06,559 --> 00:18:10,000
weekend um

00:18:07,919 --> 00:18:11,840
but we've talked to toronto which is a

00:18:10,000 --> 00:18:12,559
key part of this whole open source fpga

00:18:11,840 --> 00:18:14,000
tool

00:18:12,559 --> 00:18:16,080
they started the the place route

00:18:14,000 --> 00:18:18,000
component of it called vpr

00:18:16,080 --> 00:18:20,240
we've done test ships with eth and

00:18:18,000 --> 00:18:22,160
zurich with risk five processors

00:18:20,240 --> 00:18:23,919
uh university utah is heavily involved

00:18:22,160 --> 00:18:26,559
because they're doing things around um

00:18:23,919 --> 00:18:27,440
fpga p core creation with open source

00:18:26,559 --> 00:18:29,520
tools

00:18:27,440 --> 00:18:31,200
and then uh tim actually we still were

00:18:29,520 --> 00:18:32,000
resisting this by the way and and tim

00:18:31,200 --> 00:18:34,400
suggested

00:18:32,000 --> 00:18:35,440
you need to go to this fosse event in

00:18:34,400 --> 00:18:37,840
the or conference

00:18:35,440 --> 00:18:39,760
in europe and so tim and i went there

00:18:37,840 --> 00:18:42,160
and we were just blown away

00:18:39,760 --> 00:18:43,280
at the quality result of the open source

00:18:42,160 --> 00:18:45,280
fpga tools

00:18:43,280 --> 00:18:47,360
um and it really sort of shown this

00:18:45,280 --> 00:18:48,080
light on the the open source domain for

00:18:47,360 --> 00:18:49,840
us

00:18:48,080 --> 00:18:51,520
and that's uh really what changed our

00:18:49,840 --> 00:18:53,039
mind and so we were going from this

00:18:51,520 --> 00:18:54,559
resistance of no we don't need to do

00:18:53,039 --> 00:18:55,360
anything open source proprietary is

00:18:54,559 --> 00:18:57,840
lovely

00:18:55,360 --> 00:18:59,679
uh into this moment of of actually

00:18:57,840 --> 00:19:02,799
taking that leap and as tim said

00:18:59,679 --> 00:19:04,559
all in on the open fpga tools so

00:19:02,799 --> 00:19:06,000
that kicked off this whole collaboration

00:19:04,559 --> 00:19:09,520
with google and this company

00:19:06,000 --> 00:19:10,480
at micro in europe and that basically

00:19:09,520 --> 00:19:12,880
took all of our

00:19:10,480 --> 00:19:14,320
proprietary information on our devices

00:19:12,880 --> 00:19:15,919
and our architecture and moved it into

00:19:14,320 --> 00:19:18,480
the open source domain so

00:19:15,919 --> 00:19:19,360
that meant that we had to sort of lift

00:19:18,480 --> 00:19:21,679
up a little bit

00:19:19,360 --> 00:19:24,000
um the curtain on these technical

00:19:21,679 --> 00:19:26,160
details that we would normally hold back

00:19:24,000 --> 00:19:27,840
so that tools like simiflow which

00:19:26,160 --> 00:19:29,360
encompass the synthesis and placing

00:19:27,840 --> 00:19:31,120
around a bit stream creation

00:19:29,360 --> 00:19:33,120
can actually effectively target the

00:19:31,120 --> 00:19:34,559
device architecture

00:19:33,120 --> 00:19:36,240
and we didn't stop there so we did

00:19:34,559 --> 00:19:39,440
things like zephyr which is a

00:19:36,240 --> 00:19:41,120
an rtos for the cortex m4 and then app

00:19:39,440 --> 00:19:41,840
micro has a tool called renode which

00:19:41,120 --> 00:19:43,280
allows you to

00:19:41,840 --> 00:19:45,600
basically emulate the whole chip and

00:19:43,280 --> 00:19:46,559
software and not even have a board

00:19:45,600 --> 00:19:48,640
and then we have all these different

00:19:46,559 --> 00:19:50,559
open source boards now um

00:19:48,640 --> 00:19:52,240
that are available so you can get them

00:19:50,559 --> 00:19:54,559
for quick logic or you can

00:19:52,240 --> 00:19:56,160
go to the github repo get the

00:19:54,559 --> 00:19:57,120
information to do your own equivalent

00:19:56,160 --> 00:19:58,559
board

00:19:57,120 --> 00:20:00,160
some of these are actually unreleased

00:19:58,559 --> 00:20:02,400
they're going to be coming soon

00:20:00,160 --> 00:20:04,320
and they're they're pretty interesting

00:20:02,400 --> 00:20:04,880
to to build useful applications off of

00:20:04,320 --> 00:20:07,600
so

00:20:04,880 --> 00:20:09,360
once we got to that uh adoption point

00:20:07,600 --> 00:20:09,919
then we just sort of off to the races

00:20:09,360 --> 00:20:11,360
and

00:20:09,919 --> 00:20:13,120
joining all these different alliances

00:20:11,360 --> 00:20:14,880
that are really focused on open source

00:20:13,120 --> 00:20:16,960
tools open source software

00:20:14,880 --> 00:20:18,080
and building chips on that and like tim

00:20:16,960 --> 00:20:20,400
said we're all in so we're going to

00:20:18,080 --> 00:20:21,840
continue to do this in the future

00:20:20,400 --> 00:20:23,679
almost everything we do is going to be

00:20:21,840 --> 00:20:24,720
based on open source software and

00:20:23,679 --> 00:20:26,799
hardware

00:20:24,720 --> 00:20:28,320
and it was really cool because we had

00:20:26,799 --> 00:20:31,039
these things out there for some time and

00:20:28,320 --> 00:20:33,840
tim is doing these really neat demos

00:20:31,039 --> 00:20:34,720
around the pm 2.5 sensor and other

00:20:33,840 --> 00:20:37,120
things

00:20:34,720 --> 00:20:39,120
and then this company that was using our

00:20:37,120 --> 00:20:41,120
devices built this module

00:20:39,120 --> 00:20:42,480
and he sent me this video and he said

00:20:41,120 --> 00:20:44,799
hey check this out

00:20:42,480 --> 00:20:46,720
uh you don't even need a pc anymore to

00:20:44,799 --> 00:20:48,559
do fpj design

00:20:46,720 --> 00:20:50,320
and having been in the industry for 30

00:20:48,559 --> 00:20:51,919
years almost it was incredible to me

00:20:50,320 --> 00:20:53,440
that that was even possible to do that

00:20:51,919 --> 00:20:55,600
without a pc or

00:20:53,440 --> 00:20:56,799
a pretty high powered workstation and he

00:20:55,600 --> 00:20:58,480
basically sent me these

00:20:56,799 --> 00:20:59,919
videos where he'd taken the simpleflow

00:20:58,480 --> 00:21:00,799
open source tools because it's open

00:20:59,919 --> 00:21:02,480
source

00:21:00,799 --> 00:21:04,320
and he got it running on an android

00:21:02,480 --> 00:21:05,520
phone and i guess conceptually that

00:21:04,320 --> 00:21:06,880
makes sense because there's actually a

00:21:05,520 --> 00:21:07,360
lot of horsepower in the android phone

00:21:06,880 --> 00:21:09,600
now

00:21:07,360 --> 00:21:10,640
but just to see that actually working in

00:21:09,600 --> 00:21:12,559
real life

00:21:10,640 --> 00:21:13,919
basically taking the same systems that

00:21:12,559 --> 00:21:16,400
tim has shown you

00:21:13,919 --> 00:21:17,039
and designing uh changing the fpga

00:21:16,400 --> 00:21:18,880
gateway

00:21:17,039 --> 00:21:20,559
and then programming that through the uh

00:21:18,880 --> 00:21:20,880
the fpga tools using a smartphone which

00:21:20,559 --> 00:21:24,080
just

00:21:20,880 --> 00:21:25,760
blew me away um and then similarly they

00:21:24,080 --> 00:21:27,520
actually use the raspberry pi

00:21:25,760 --> 00:21:29,760
so raspberry pi now can also run the

00:21:27,520 --> 00:21:31,919
same fpga placement route tools

00:21:29,760 --> 00:21:33,520
you can change the gateway uh program

00:21:31,919 --> 00:21:34,400
the device uh back on that quick

00:21:33,520 --> 00:21:36,559
featherboard

00:21:34,400 --> 00:21:37,840
so again it's just sort of a glimpse

00:21:36,559 --> 00:21:38,720
into the future and it kind of makes you

00:21:37,840 --> 00:21:40,640
appreciate

00:21:38,720 --> 00:21:42,240
a guy of young kids they could actually

00:21:40,640 --> 00:21:43,840
use these things now

00:21:42,240 --> 00:21:45,679
on their tablets or chromebooks or

00:21:43,840 --> 00:21:47,760
whatever they are they're not limited by

00:21:45,679 --> 00:21:48,880
you know me going out and buying them a

00:21:47,760 --> 00:21:50,880
thousand dollar computer

00:21:48,880 --> 00:21:52,480
uh to go over and place them out so this

00:21:50,880 --> 00:21:54,400
i really think this is sort of

00:21:52,480 --> 00:21:55,919
um disruptive and change it's gonna

00:21:54,400 --> 00:21:58,960
change everything as far as

00:21:55,919 --> 00:22:00,000
who actually can start to do design with

00:21:58,960 --> 00:22:02,480
these types of uh

00:22:00,000 --> 00:22:03,919
devices some types of technology and

00:22:02,480 --> 00:22:05,520
it's not limited to quick logic this is

00:22:03,919 --> 00:22:06,559
not a sales pitch for quick logic it's

00:22:05,520 --> 00:22:08,320
really just the

00:22:06,559 --> 00:22:09,919
the idea that this is sort of

00:22:08,320 --> 00:22:13,360
democratizing this technology is

00:22:09,919 --> 00:22:16,400
is awesome um

00:22:13,360 --> 00:22:18,799
so what can we do together i think uh

00:22:16,400 --> 00:22:20,799
tim opened this up with uh talks about

00:22:18,799 --> 00:22:22,240
the fires in california so we had

00:22:20,799 --> 00:22:24,480
lots of fires in california i think

00:22:22,240 --> 00:22:25,600
there were uh definitely more than two

00:22:24,480 --> 00:22:26,400
million acres i think burned in

00:22:25,600 --> 00:22:28,480
california

00:22:26,400 --> 00:22:30,240
just this summer it was incredible and

00:22:28,480 --> 00:22:32,240
i've read that there's been a lot of

00:22:30,240 --> 00:22:33,919
fires down in australia as well

00:22:32,240 --> 00:22:35,360
so uh what we've actually done is

00:22:33,919 --> 00:22:35,760
created this contest that i think can

00:22:35,360 --> 00:22:38,720
actually

00:22:35,760 --> 00:22:40,320
sort of help out the world uh in the

00:22:38,720 --> 00:22:41,679
climate and that's basically taking the

00:22:40,320 --> 00:22:43,280
quick feather boards

00:22:41,679 --> 00:22:45,200
and then doing neat things like what tim

00:22:43,280 --> 00:22:46,559
is doing where you can attach different

00:22:45,200 --> 00:22:48,720
sensors to it that aren't on the board

00:22:46,559 --> 00:22:50,640
use the open source tools and just see

00:22:48,720 --> 00:22:52,159
see how creative you can get um so we

00:22:50,640 --> 00:22:54,720
did this contest with

00:22:52,159 --> 00:22:55,280
hackster.io and so i thought about it

00:22:54,720 --> 00:22:56,640
too late

00:22:55,280 --> 00:22:58,320
um but we should have actually sent a

00:22:56,640 --> 00:22:59,840
bunch of boards down to australia

00:22:58,320 --> 00:23:01,600
so you folks could have had boards while

00:22:59,840 --> 00:23:02,480
we uh did this conference and did this

00:23:01,600 --> 00:23:04,960
training

00:23:02,480 --> 00:23:05,600
um but i didn't think of it fast enough

00:23:04,960 --> 00:23:07,840
so but

00:23:05,600 --> 00:23:08,640
i will send the first 20 people aboard

00:23:07,840 --> 00:23:10,159
so just

00:23:08,640 --> 00:23:11,760
email that email address and i'll get

00:23:10,159 --> 00:23:13,280
you a board and hopefully

00:23:11,760 --> 00:23:15,520
you can get the tools and start

00:23:13,280 --> 00:23:15,840
designing as well and have some fun with

00:23:15,520 --> 00:23:18,880
us

00:23:15,840 --> 00:23:18,880
this open source tools

00:23:19,120 --> 00:23:22,960
so that was really quick i've done this

00:23:21,200 --> 00:23:25,039
presentation in a lot more time but i

00:23:22,960 --> 00:23:26,799
want to condense it for this this is uh

00:23:25,039 --> 00:23:28,400
i think the the persistence of the open

00:23:26,799 --> 00:23:29,679
source community is awesome the

00:23:28,400 --> 00:23:32,080
passion's there

00:23:29,679 --> 00:23:33,520
um and we're we're seeing it now and so

00:23:32,080 --> 00:23:34,159
we're we are fully committed as a

00:23:33,520 --> 00:23:36,320
company

00:23:34,159 --> 00:23:37,520
to the open source tool chain for fpgas

00:23:36,320 --> 00:23:39,440
now um

00:23:37,520 --> 00:23:41,039
no longer doing the proprietary stuff

00:23:39,440 --> 00:23:41,919
and we did it because i think the tools

00:23:41,039 --> 00:23:43,840
are ready

00:23:41,919 --> 00:23:45,120
and not just ready for our architecture

00:23:43,840 --> 00:23:46,559
again this is not a

00:23:45,120 --> 00:23:48,159
sales pitch for quick logic i think

00:23:46,559 --> 00:23:49,760
they're ready in general for many

00:23:48,159 --> 00:23:51,039
architectures

00:23:49,760 --> 00:23:53,039
and as long as companies provide

00:23:51,039 --> 00:23:53,840
information uh to the open source

00:23:53,039 --> 00:23:57,039
community

00:23:53,840 --> 00:23:59,679
those tools will yield good results um

00:23:57,039 --> 00:24:00,400
and resistance is for utah in this case

00:23:59,679 --> 00:24:02,000
so i think

00:24:00,400 --> 00:24:03,760
pretty soon we're going to see open

00:24:02,000 --> 00:24:05,840
source tools be the norm and not the

00:24:03,760 --> 00:24:09,360
exception

00:24:05,840 --> 00:24:12,720
and that is it

00:24:09,360 --> 00:24:16,480
fantastic okay thank you very much brian

00:24:12,720 --> 00:24:17,120
and tim so um there are a couple of

00:24:16,480 --> 00:24:19,039
questions

00:24:17,120 --> 00:24:20,880
that popped up in the chat and i have a

00:24:19,039 --> 00:24:23,120
question myself so

00:24:20,880 --> 00:24:25,279
uh tisham asked is there a sample

00:24:23,120 --> 00:24:26,480
gateway or asic recommendations for the

00:24:25,279 --> 00:24:29,919
high speed adc

00:24:26,480 --> 00:24:29,919
usage with the quick feather

00:24:30,720 --> 00:24:33,840
tim do you want to take that one

00:24:35,520 --> 00:24:38,640
if his name is not currently added to

00:24:37,520 --> 00:24:41,039
the stream

00:24:38,640 --> 00:24:42,080
okay well i can i can take that so yeah

00:24:41,039 --> 00:24:45,279
we actually have

00:24:42,080 --> 00:24:48,559
um gateway an example code

00:24:45,279 --> 00:24:53,760
for connecting uh um

00:24:48,559 --> 00:24:53,760
oh there's tim yeah i could take

00:24:54,320 --> 00:24:58,840
that uh actually if you look at the repo

00:24:57,039 --> 00:25:01,840
you will

00:24:58,840 --> 00:25:01,840
probably

00:25:07,840 --> 00:25:13,360
yeah i'm not sure looks like we might

00:25:10,080 --> 00:25:13,360
have his audio occasionally

00:25:13,679 --> 00:25:16,880
well the short answer is yes we do have

00:25:15,440 --> 00:25:19,760
example code

00:25:16,880 --> 00:25:21,120
okay it's i think it's in the examples

00:25:19,760 --> 00:25:22,799
uh

00:25:21,120 --> 00:25:25,200
directory off the github repo that we

00:25:22,799 --> 00:25:27,120
have okay so that's the example

00:25:25,200 --> 00:25:28,559
the specific question was about high

00:25:27,120 --> 00:25:30,720
speed adc

00:25:28,559 --> 00:25:32,240
so you've got examples related to that

00:25:30,720 --> 00:25:35,279
we do an existing

00:25:32,240 --> 00:25:37,679
connecting it to uh to grip feather yeah

00:25:35,279 --> 00:25:39,360
okay um well that sort of ties into what

00:25:37,679 --> 00:25:40,880
i was going to ask which was

00:25:39,360 --> 00:25:43,039
whether you have examples of blocks of

00:25:40,880 --> 00:25:45,440
code because in tim's example

00:25:43,039 --> 00:25:46,559
he mentioned adding a third uart which

00:25:45,440 --> 00:25:48,400
implies taking

00:25:46,559 --> 00:25:49,760
a chunk of functionality and adding it

00:25:48,400 --> 00:25:51,039
into the project

00:25:49,760 --> 00:25:53,279
right which is the sort of thing that

00:25:51,039 --> 00:25:55,360
gives the the amazing flexibility that

00:25:53,279 --> 00:25:58,720
you can achieve with fpgas

00:25:55,360 --> 00:26:00,400
so part of the the value

00:25:58,720 --> 00:26:02,000
that you would provide of course is

00:26:00,400 --> 00:26:06,000
making that easy for your

00:26:02,000 --> 00:26:08,799
customers so do you have a

00:26:06,000 --> 00:26:10,159
library of those sorts of functions we

00:26:08,799 --> 00:26:11,840
have a library functions and it's

00:26:10,159 --> 00:26:13,360
something that's going to grow over time

00:26:11,840 --> 00:26:15,360
we actually have a lot of gateway that

00:26:13,360 --> 00:26:17,360
we've sort of kept internal

00:26:15,360 --> 00:26:18,640
for a long time um and we need to sort

00:26:17,360 --> 00:26:20,080
of put that in the

00:26:18,640 --> 00:26:22,400
the right way for the open source

00:26:20,080 --> 00:26:24,400
community so the simple ones are like

00:26:22,400 --> 00:26:25,520
different gpio that you can do in the

00:26:24,400 --> 00:26:27,279
fpga

00:26:25,520 --> 00:26:29,600
uh the uarts the multiple yards the

00:26:27,279 --> 00:26:32,159
mixing and matching of those the usb

00:26:29,600 --> 00:26:32,640
uh device that tim was talking about um

00:26:32,159 --> 00:26:34,159
and then

00:26:32,640 --> 00:26:35,279
we actually have some internal gateway

00:26:34,159 --> 00:26:38,559
that we're going to start releasing

00:26:35,279 --> 00:26:40,640
which uses the efpj not for

00:26:38,559 --> 00:26:42,159
simple connectivity things like like

00:26:40,640 --> 00:26:44,799
uarts and gpio

00:26:42,159 --> 00:26:47,200
but more for offloading things from the

00:26:44,799 --> 00:26:48,960
processor so it sort of moves it into a

00:26:47,200 --> 00:26:51,200
an offload or an acceleration engine

00:26:48,960 --> 00:26:53,600
from the cortex m4

00:26:51,200 --> 00:26:54,320
totally different use case but uh we

00:26:53,600 --> 00:26:55,760
actually have

00:26:54,320 --> 00:26:57,919
examples of that running now that we're

00:26:55,760 --> 00:27:00,880
going to start to open source as well

00:26:57,919 --> 00:27:02,480
oh that's great so yeah i can imagine

00:27:00,880 --> 00:27:03,360
all sorts of applications for that you

00:27:02,480 --> 00:27:05,120
know related to

00:27:03,360 --> 00:27:06,799
crypto or whatever people might want to

00:27:05,120 --> 00:27:09,039
use so are there

00:27:06,799 --> 00:27:10,240
particular applications or projects that

00:27:09,039 --> 00:27:12,559
you have seen people build with the

00:27:10,240 --> 00:27:14,720
quick feather already

00:27:12,559 --> 00:27:16,320
yeah so actually um it's pretty

00:27:14,720 --> 00:27:17,600
interesting so if i just back i don't

00:27:16,320 --> 00:27:18,960
know if my flies are still fine but i

00:27:17,600 --> 00:27:22,799
can just speak to it so

00:27:18,960 --> 00:27:25,279
um that one we're talking about the uh

00:27:22,799 --> 00:27:26,799
the android phone and the raspberry pi

00:27:25,279 --> 00:27:27,679
and usually not to do the the design and

00:27:26,799 --> 00:27:30,159
programming

00:27:27,679 --> 00:27:32,000
they've actually built a module um of

00:27:30,159 --> 00:27:34,880
the slideshow but now they're not

00:27:32,000 --> 00:27:36,320
um they actually built a module um that

00:27:34,880 --> 00:27:38,000
was

00:27:36,320 --> 00:27:39,120
rectangular in shape but much smaller

00:27:38,000 --> 00:27:39,760
than quick feather that they could

00:27:39,120 --> 00:27:43,200
actually put

00:27:39,760 --> 00:27:44,640
um memory on and the eos s3 device

00:27:43,200 --> 00:27:46,320
and they're selling that as an open

00:27:44,640 --> 00:27:48,240
module

00:27:46,320 --> 00:27:49,840
to people that want to sort of integrate

00:27:48,240 --> 00:27:51,200
that at the board level without

00:27:49,840 --> 00:27:53,120
you know having to buy the big quick

00:27:51,200 --> 00:27:55,120
feather device um

00:27:53,120 --> 00:27:56,720
so that that is already happening and

00:27:55,120 --> 00:27:58,320
they're targeting wearables so they've

00:27:56,720 --> 00:27:59,600
actually made it pretty small so you can

00:27:58,320 --> 00:28:01,600
actually put it into a wristborne

00:27:59,600 --> 00:28:02,480
wearable or some type of a necklace

00:28:01,600 --> 00:28:04,640
device

00:28:02,480 --> 00:28:05,919
um because not only is it small but it's

00:28:04,640 --> 00:28:07,200
also low power so you can kind of get

00:28:05,919 --> 00:28:08,880
away with that for battery powered

00:28:07,200 --> 00:28:10,480
applications

00:28:08,880 --> 00:28:13,200
okay so that's another interesting

00:28:10,480 --> 00:28:15,360
aspect is the power requirements

00:28:13,200 --> 00:28:17,600
um so for people that haven't done

00:28:15,360 --> 00:28:19,760
anything with fpgas before could you

00:28:17,600 --> 00:28:21,520
um maybe speak a little bit about how

00:28:19,760 --> 00:28:22,880
the power requirements of something like

00:28:21,520 --> 00:28:25,840
a quick feather compares to a more

00:28:22,880 --> 00:28:29,200
traditional microcontroller

00:28:25,840 --> 00:28:31,279
yeah so the the eos device itself has

00:28:29,200 --> 00:28:33,039
i don't know i think more than 30

00:28:31,279 --> 00:28:34,720
different power islands

00:28:33,039 --> 00:28:36,559
so if you if you're only using the

00:28:34,720 --> 00:28:37,279
microcontroller you're actually going to

00:28:36,559 --> 00:28:39,039
find it to be

00:28:37,279 --> 00:28:40,799
of similar power as a low power

00:28:39,039 --> 00:28:42,640
microcontroller um

00:28:40,799 --> 00:28:44,240
the core voltage is like 1.2 because

00:28:42,640 --> 00:28:46,480
it's at 40 nanometer

00:28:44,240 --> 00:28:47,360
so microcontroller alone is in that

00:28:46,480 --> 00:28:50,720
range

00:28:47,360 --> 00:28:51,679
um our fpga is not sort of the classical

00:28:50,720 --> 00:28:53,440
like data center

00:28:51,679 --> 00:28:54,960
style fpga so it is actually designed

00:28:53,440 --> 00:28:56,799
for low power

00:28:54,960 --> 00:28:58,240
so in general the part itself when

00:28:56,799 --> 00:28:59,039
you're running full bore is going to

00:28:58,240 --> 00:29:01,279
draw

00:28:59,039 --> 00:29:03,120
easily less than 10 milliwatts and

00:29:01,279 --> 00:29:04,320
there's a lot of applications for always

00:29:03,120 --> 00:29:06,080
on

00:29:04,320 --> 00:29:07,760
sensing where you're doing microphone

00:29:06,080 --> 00:29:09,760
listening classification

00:29:07,760 --> 00:29:11,039
types of examples where you can you can

00:29:09,760 --> 00:29:13,200
actually run it

00:29:11,039 --> 00:29:15,279
probably like a 10 nips kind of model

00:29:13,200 --> 00:29:18,399
for less than a milliwatt

00:29:15,279 --> 00:29:20,640
um and the fpga itself is like standby

00:29:18,399 --> 00:29:22,240
is like 50 microwatts and

00:29:20,640 --> 00:29:23,679
if you run it at you know 10 or 20

00:29:22,240 --> 00:29:26,000
megahertz maybe you're drawing

00:29:23,679 --> 00:29:27,120
around a milliwatt too so it's actually

00:29:26,000 --> 00:29:28,640
you can do some pretty interesting

00:29:27,120 --> 00:29:31,200
things with a battery

00:29:28,640 --> 00:29:32,559
um yes our device you won't find the

00:29:31,200 --> 00:29:33,520
data center so it's on the other end of

00:29:32,559 --> 00:29:37,039
the spectrum but at

00:29:33,520 --> 00:29:38,799
that point we know but you're certainly

00:29:37,039 --> 00:29:39,279
not taking on a big power penalty by

00:29:38,799 --> 00:29:40,880
doing it

00:29:39,279 --> 00:29:43,919
it's um it's definitely something that

00:29:40,880 --> 00:29:45,440
can be built into a small device

00:29:43,919 --> 00:29:47,200
and there is a question from paul

00:29:45,440 --> 00:29:49,279
mccaris who asked

00:29:47,200 --> 00:29:53,120
how big in number of luts is quick

00:29:49,279 --> 00:29:53,120
logic's largest fpga

00:29:53,200 --> 00:29:56,799
so the largest we have many different

00:29:56,080 --> 00:30:00,159
technology

00:29:56,799 --> 00:30:00,559
fpgas um we have srm reprogrammable we

00:30:00,159 --> 00:30:02,880
have

00:30:00,559 --> 00:30:04,960
uh anti-fuse and then we've also done

00:30:02,880 --> 00:30:06,320
some srm we programmable on an fds-oi

00:30:04,960 --> 00:30:09,440
process that's a

00:30:06,320 --> 00:30:13,120
an efpj so it's a licensable ip

00:30:09,440 --> 00:30:16,559
um so this device has it's a thousand

00:30:13,120 --> 00:30:19,039
ish let force um equivalence

00:30:16,559 --> 00:30:21,440
in our logic cell we have anti-fuse

00:30:19,039 --> 00:30:25,440
based devices that i think go up to

00:30:21,440 --> 00:30:27,360
around 8 000 uh logic cells which are

00:30:25,440 --> 00:30:28,480
basically equivalent to a lot and then

00:30:27,360 --> 00:30:30,880
on some of our newer

00:30:28,480 --> 00:30:31,840
embedded fpgas we have uh ones that go

00:30:30,880 --> 00:30:34,960
up to like 32

00:30:31,840 --> 00:30:37,039
000 let's and then we're actually

00:30:34,960 --> 00:30:38,159
i didn't i put this in backups so i can

00:30:37,039 --> 00:30:40,320
actually

00:30:38,159 --> 00:30:41,600
put this on my slide now if you can go

00:30:40,320 --> 00:30:44,399
back to the slide but

00:30:41,600 --> 00:30:45,760
this test chip that was done by the eth

00:30:44,399 --> 00:30:49,039
university in zurich

00:30:45,760 --> 00:30:50,799
so this one has around 32 000

00:30:49,039 --> 00:30:52,960
no sorry this one has around 8 000 but

00:30:50,799 --> 00:30:54,240
there's another one that's uh coming

00:30:52,960 --> 00:30:55,760
that we're doing with the open hardware

00:30:54,240 --> 00:30:56,799
group that'll it'll have quite a bit

00:30:55,760 --> 00:30:58,640
more

00:30:56,799 --> 00:31:00,640
of those logic cells uh or lut

00:30:58,640 --> 00:31:02,559
equivalents that's going to be tightly

00:31:00,640 --> 00:31:04,080
coupled with a risk five processor and a

00:31:02,559 --> 00:31:05,600
bunch of peripherals so it can be used

00:31:04,080 --> 00:31:08,159
sort of in all those different use cases

00:31:05,600 --> 00:31:09,840
i was mentioning earlier

00:31:08,159 --> 00:31:12,480
but just generally speaking we're

00:31:09,840 --> 00:31:13,200
focused on the sort of lightweight fpgas

00:31:12,480 --> 00:31:14,960
where they're

00:31:13,200 --> 00:31:16,799
not too dense that you you couldn't use

00:31:14,960 --> 00:31:20,640
it in a low power application

00:31:16,799 --> 00:31:23,760
yeah sure okay um well related to that

00:31:20,640 --> 00:31:26,000
i believe you also have example

00:31:23,760 --> 00:31:27,279
so the quick further itself ultimately

00:31:26,000 --> 00:31:29,039
what you are wanting is for people to

00:31:27,279 --> 00:31:31,600
build your fpgas into their

00:31:29,039 --> 00:31:32,080
projects or products or whatever so the

00:31:31,600 --> 00:31:34,000
design

00:31:32,080 --> 00:31:35,679
for the quick feather i believe is open

00:31:34,000 --> 00:31:36,880
source as well is that was that done in

00:31:35,679 --> 00:31:39,440
keycard

00:31:36,880 --> 00:31:41,039
or what tool is that done in i think it

00:31:39,440 --> 00:31:43,279
was done in keycard yeah

00:31:41,039 --> 00:31:44,399
yeah that's great yeah fantastic so

00:31:43,279 --> 00:31:45,760
that's a good thing for people to get

00:31:44,399 --> 00:31:46,960
started with if they want to look at an

00:31:45,760 --> 00:31:49,600
example of how

00:31:46,960 --> 00:31:50,799
the fpga has been implemented on an

00:31:49,600 --> 00:31:53,360
actual board

00:31:50,799 --> 00:31:55,200
yes that's great there was a question

00:31:53,360 --> 00:31:58,159
from paul schultz

00:31:55,200 --> 00:32:00,480
who said this is talking about the

00:31:58,159 --> 00:32:02,480
example project with laura he said where

00:32:00,480 --> 00:32:05,440
is the laura processing done is it in

00:32:02,480 --> 00:32:05,440
the fpga

00:32:05,760 --> 00:32:12,640
no it's done in the mdot module

00:32:09,360 --> 00:32:15,039
yep okay and there is also a question

00:32:12,640 --> 00:32:16,799
from eleanor who said the quick logic

00:32:15,039 --> 00:32:19,440
website talks about support for windows

00:32:16,799 --> 00:32:22,960
10 and linux does that also cover mac os

00:32:19,440 --> 00:32:22,960
because of the unix-based tools

00:32:24,880 --> 00:32:31,679
you want to take that yeah so um

00:32:29,519 --> 00:32:33,679
yeah basically all of these all of the

00:32:31,679 --> 00:32:36,559
new open source tools run on

00:32:33,679 --> 00:32:37,360
you can run a virtual machine on on a

00:32:36,559 --> 00:32:40,480
mac os

00:32:37,360 --> 00:32:42,399
ubuntu 18 seems to work fine on the

00:32:40,480 --> 00:32:45,679
virtual machines in fact i run

00:32:42,399 --> 00:32:49,120
ubuntu on my windows machine

00:32:45,679 --> 00:32:52,000
virtual yes yeah

00:32:49,120 --> 00:32:53,760
okay great um now just putting the call

00:32:52,000 --> 00:32:54,960
out to the live stream here we've got a

00:32:53,760 --> 00:32:57,120
couple more minutes

00:32:54,960 --> 00:33:00,000
available so if anybody does have

00:32:57,120 --> 00:33:02,960
questions about fpgas or

00:33:00,000 --> 00:33:03,679
quick logic and their journey to open

00:33:02,960 --> 00:33:05,840
sourcing

00:33:03,679 --> 00:33:07,440
all the things which is seems to be what

00:33:05,840 --> 00:33:10,720
they're intending to do

00:33:07,440 --> 00:33:13,279
please drop questions in the in the chat

00:33:10,720 --> 00:33:14,799
while we have the chance this is uh this

00:33:13,279 --> 00:33:17,840
is a great chance to

00:33:14,799 --> 00:33:19,760
be able to ask questions directly

00:33:17,840 --> 00:33:20,960
and get the sort of information that you

00:33:19,760 --> 00:33:22,320
don't normally see

00:33:20,960 --> 00:33:24,159
oh and the other thing i should point

00:33:22,320 --> 00:33:26,720
out is

00:33:24,159 --> 00:33:27,519
uh brian was recently on the amp hour

00:33:26,720 --> 00:33:30,559
podcast

00:33:27,519 --> 00:33:33,440
with chris camel and dave jones

00:33:30,559 --> 00:33:34,320
so if you want to learn a little bit

00:33:33,440 --> 00:33:38,000
more about that

00:33:34,320 --> 00:33:40,640
and the journey of how he um

00:33:38,000 --> 00:33:43,039
he and tim ansel came to the conclusion

00:33:40,640 --> 00:33:45,120
that they needed to

00:33:43,039 --> 00:33:46,720
a tool chain uh go and check out that

00:33:45,120 --> 00:33:49,840
episode i think it might be the

00:33:46,720 --> 00:33:52,799
second most recent episode um

00:33:49,840 --> 00:33:55,360
brett downing said how quickly can the

00:33:52,799 --> 00:33:58,000
application processor replace the fpga

00:33:55,360 --> 00:33:58,000
bitstream

00:34:00,480 --> 00:34:04,640
yeah so this uh in the in the quick

00:34:04,000 --> 00:34:06,880
feather

00:34:04,640 --> 00:34:08,800
it's not actually reprogrammable in the

00:34:06,880 --> 00:34:09,839
sense of you have to power it down and

00:34:08,800 --> 00:34:13,119
power it back on

00:34:09,839 --> 00:34:15,679
because of a bug i hate to say that but

00:34:13,119 --> 00:34:17,200
um the actual programming time itself is

00:34:15,679 --> 00:34:18,320
is on the order of like maybe 10

00:34:17,200 --> 00:34:20,240
milliseconds

00:34:18,320 --> 00:34:21,679
if you can supply the data to it that

00:34:20,240 --> 00:34:24,800
quickly

00:34:21,679 --> 00:34:25,200
so in the eth one we do we can reprogram

00:34:24,800 --> 00:34:26,879
it

00:34:25,200 --> 00:34:29,599
time and time again and it's on the

00:34:26,879 --> 00:34:34,480
order of 10 milliseconds

00:34:29,599 --> 00:34:37,040
wow that's not very long

00:34:34,480 --> 00:34:38,320
um i don't think there are any other

00:34:37,040 --> 00:34:41,280
questions oh hang on

00:34:38,320 --> 00:34:41,760
uh there is one um jim has said what

00:34:41,280 --> 00:34:44,079
sample

00:34:41,760 --> 00:34:46,079
applications have you seen end users use

00:34:44,079 --> 00:34:49,280
these fpgas for

00:34:46,079 --> 00:34:50,480
and actually just as a relay to expand

00:34:49,280 --> 00:34:53,280
on that a little bit

00:34:50,480 --> 00:34:54,960
how long has this fpga been on the

00:34:53,280 --> 00:34:57,040
market i mean if it's brand new then you

00:34:54,960 --> 00:34:58,880
wouldn't have very many examples

00:34:57,040 --> 00:35:01,119
out there so when was it released and

00:34:58,880 --> 00:35:02,640
what have you seen so far

00:35:01,119 --> 00:35:04,560
so it was actually released in full

00:35:02,640 --> 00:35:06,400
production um

00:35:04,560 --> 00:35:08,560
two or three years ago but when we first

00:35:06,400 --> 00:35:09,839
released it we were focusing just on a

00:35:08,560 --> 00:35:12,160
very narrow set of people with

00:35:09,839 --> 00:35:13,520
proprietary tools so we weren't really

00:35:12,160 --> 00:35:15,119
we didn't even have our data sheet on

00:35:13,520 --> 00:35:16,400
the website that somebody could use it

00:35:15,119 --> 00:35:19,599
was really locked behind

00:35:16,400 --> 00:35:20,320
nbas so it this approach has only been

00:35:19,599 --> 00:35:22,960
since uh

00:35:20,320 --> 00:35:24,240
earlier in 2020 actually of springtime

00:35:22,960 --> 00:35:26,079
2020.

00:35:24,240 --> 00:35:27,680
so since then we have a lot of different

00:35:26,079 --> 00:35:30,240
fpga use cases so

00:35:27,680 --> 00:35:31,440
for example um millions of these are

00:35:30,240 --> 00:35:33,520
actually shipping in uh

00:35:31,440 --> 00:35:35,040
certain smartphones right now and some

00:35:33,520 --> 00:35:36,240
of the the pwm

00:35:35,040 --> 00:35:38,560
uh jonathan when you were talking about

00:35:36,240 --> 00:35:40,800
pwm earlier um so we're basically

00:35:38,560 --> 00:35:41,599
implementing a pwm in the fpga so that

00:35:40,800 --> 00:35:44,640
it can

00:35:41,599 --> 00:35:47,440
it can communicate with an ir led for

00:35:44,640 --> 00:35:49,839
infrared transfer out of the phone into

00:35:47,440 --> 00:35:50,640
for some elder applications so that's

00:35:49,839 --> 00:35:53,680
one

00:35:50,640 --> 00:35:55,760
um in a hearable application when i say

00:35:53,680 --> 00:35:58,320
hearable talk about a bluetooth headset

00:35:55,760 --> 00:36:00,079
so there's a voice software company

00:35:58,320 --> 00:36:01,119
that's doing some voice recognition

00:36:00,079 --> 00:36:03,520
software

00:36:01,119 --> 00:36:05,520
and uh some of the math functions of

00:36:03,520 --> 00:36:08,079
their software were pretty intense

00:36:05,520 --> 00:36:10,000
and so they they sort of capped out the

00:36:08,079 --> 00:36:11,200
mips that were available in the part

00:36:10,000 --> 00:36:13,520
and they asked us if we could they could

00:36:11,200 --> 00:36:14,160
use fpga for offloading that so they

00:36:13,520 --> 00:36:16,079
actually

00:36:14,160 --> 00:36:18,000
it's either fft or fir filter we're

00:36:16,079 --> 00:36:19,119
actually doing in the fpga that's

00:36:18,000 --> 00:36:22,240
offloaded from the

00:36:19,119 --> 00:36:23,839
cortex m4 um and that's a great example

00:36:22,240 --> 00:36:26,640
actually of the offload capability of

00:36:23,839 --> 00:36:27,760
that on chip the other ones that we're

00:36:26,640 --> 00:36:29,119
doing are like

00:36:27,760 --> 00:36:31,200
tim was showing where you're mixing and

00:36:29,119 --> 00:36:33,680
matching more simple

00:36:31,200 --> 00:36:34,240
interfaces like you are at spi i scored

00:36:33,680 --> 00:36:37,839
c and

00:36:34,240 --> 00:36:40,640
and general purpose io um in those areas

00:36:37,839 --> 00:36:42,160
that's for this chip the the tim has

00:36:40,640 --> 00:36:44,000
actually shown that you can do things

00:36:42,160 --> 00:36:45,359
like human presence detection with some

00:36:44,000 --> 00:36:48,400
really low power

00:36:45,359 --> 00:36:49,920
uh cmos imaging sensors like from hi-max

00:36:48,400 --> 00:36:52,079
and so that can actually run so it's

00:36:49,920 --> 00:36:52,800
running basically tensorflow lite neural

00:36:52,079 --> 00:36:56,000
nets

00:36:52,800 --> 00:36:58,480
um on that pull chip and we have some

00:36:56,000 --> 00:37:00,079
multipliers next to the fpga

00:36:58,480 --> 00:37:01,760
so you can actually offload some of the

00:37:00,079 --> 00:37:04,240
convolution uh

00:37:01,760 --> 00:37:05,760
heavy lifting math from the processor on

00:37:04,240 --> 00:37:06,160
the fpga as well and we've demonstrated

00:37:05,760 --> 00:37:08,240
that

00:37:06,160 --> 00:37:09,599
that's not in um a customer production

00:37:08,240 --> 00:37:10,160
yet but that's basically a use case

00:37:09,599 --> 00:37:11,680
that's

00:37:10,160 --> 00:37:13,680
that's sort of demonstrated at this

00:37:11,680 --> 00:37:15,599
point and hopefully a customer will take

00:37:13,680 --> 00:37:18,400
that to production

00:37:15,599 --> 00:37:20,079
okay great um just following up on the

00:37:18,400 --> 00:37:22,240
question earlier from tisham he asked

00:37:20,079 --> 00:37:24,560
about the example adc gateway code

00:37:22,240 --> 00:37:25,920
and he has found it in your examples and

00:37:24,560 --> 00:37:28,640
he's linked to it in the

00:37:25,920 --> 00:37:30,480
the chat so for anyone for anyone else

00:37:28,640 --> 00:37:32,480
that is interested in that

00:37:30,480 --> 00:37:34,960
check the chat in venulis it's right

00:37:32,480 --> 00:37:37,599
there and uh go and see quick logic's

00:37:34,960 --> 00:37:38,720
example code there was also a question

00:37:37,599 --> 00:37:41,520
from a couple more questions

00:37:38,720 --> 00:37:43,839
coming in andrew said for people who are

00:37:41,520 --> 00:37:45,680
new to computer science and hardware dev

00:37:43,839 --> 00:37:48,839
how long could it take to gain a

00:37:45,680 --> 00:37:51,839
functional understanding to use these

00:37:48,839 --> 00:37:51,839
technologies

00:37:51,920 --> 00:37:55,520
tim yeah

00:37:56,480 --> 00:37:58,880
i think

00:38:00,560 --> 00:38:04,320
it we have some examples that show

00:38:03,119 --> 00:38:07,200
things and i think

00:38:04,320 --> 00:38:08,400
you know if if you think logically and

00:38:07,200 --> 00:38:10,640
most engineers do

00:38:08,400 --> 00:38:12,240
it's not that hard to figure out how to

00:38:10,640 --> 00:38:14,640
how to use the

00:38:12,240 --> 00:38:16,720
the verilog and so on the biggest

00:38:14,640 --> 00:38:18,320
problem with verilog is they used

00:38:16,720 --> 00:38:20,880
it was written by a hardware guy who

00:38:18,320 --> 00:38:24,320
didn't understand programming languages

00:38:20,880 --> 00:38:26,160
and so it's kind of like c

00:38:24,320 --> 00:38:28,000
just enough that you'll keep making tons

00:38:26,160 --> 00:38:30,160
of mistakes but

00:38:28,000 --> 00:38:32,000
if you when you get through that the

00:38:30,160 --> 00:38:33,520
basic logic of doing it it's

00:38:32,000 --> 00:38:36,640
it's really not that different than

00:38:33,520 --> 00:38:38,720
writing any uh tight embedded code or

00:38:36,640 --> 00:38:39,680
kind of thing so it should it should

00:38:38,720 --> 00:38:41,839
only take like a

00:38:39,680 --> 00:38:44,240
week or so of playing with some of these

00:38:41,839 --> 00:38:46,640
examples to figure out how to do it

00:38:44,240 --> 00:38:48,000
and that's a cool thing that's the cool

00:38:46,640 --> 00:38:49,920
thing about how it depends on your

00:38:48,000 --> 00:38:51,119
background as well if you're a complete

00:38:49,920 --> 00:38:55,599
beginner then

00:38:51,119 --> 00:38:57,119
that that's a big hill to climb yep

00:38:55,599 --> 00:38:58,480
but i think the cool thing about having

00:38:57,119 --> 00:39:00,160
it in something like quick feather and

00:38:58,480 --> 00:39:02,000
open source where everybody can use it

00:39:00,160 --> 00:39:04,240
is you can take one of our examples

00:39:02,000 --> 00:39:06,160
you know and you can break it you can

00:39:04,240 --> 00:39:07,839
you can start changing it right

00:39:06,160 --> 00:39:09,520
i don't know how most people learn but

00:39:07,839 --> 00:39:11,440
the way i learn is i like to start with

00:39:09,520 --> 00:39:13,359
something that sort of works and i

00:39:11,440 --> 00:39:14,960
i improve it which usually goes in the

00:39:13,359 --> 00:39:18,000
wrong direction to begin with and

00:39:14,960 --> 00:39:18,000
that's how i learn right

00:39:18,240 --> 00:39:21,440
yes and there's some i can't remember

00:39:20,240 --> 00:39:23,280
the wording of it but there's some

00:39:21,440 --> 00:39:24,880
saying about the ways long

00:39:23,280 --> 00:39:27,359
if you follow the instructions but it's

00:39:24,880 --> 00:39:30,079
short if you go by example

00:39:27,359 --> 00:39:32,320
um something like that i just butchered

00:39:30,079 --> 00:39:32,320
that

00:39:32,800 --> 00:39:38,079
and um there's a question from

00:39:36,320 --> 00:39:39,440
joe shank sorry i hope i got the

00:39:38,079 --> 00:39:41,680
pronunciation correct

00:39:39,440 --> 00:39:42,800
how long did it take in time and dev

00:39:41,680 --> 00:39:44,720
effort to get from

00:39:42,800 --> 00:39:48,640
we would like to use open source tools

00:39:44,720 --> 00:39:51,440
to we can generate usable bit streams

00:39:48,640 --> 00:39:52,240
oh so firstly we did not do it alone we

00:39:51,440 --> 00:39:55,280
did it with

00:39:52,240 --> 00:39:57,440
the folks on the slide and i would say

00:39:55,280 --> 00:40:00,720
that was probably

00:39:57,440 --> 00:40:01,200
on the order of a year right tim yeah it

00:40:00,720 --> 00:40:04,720
was

00:40:01,200 --> 00:40:05,040
well it was a year to where we released

00:40:04,720 --> 00:40:06,960
it

00:40:05,040 --> 00:40:09,040
right having bit streams that we could

00:40:06,960 --> 00:40:11,200
run internally was probably only like

00:40:09,040 --> 00:40:12,880
four or five months

00:40:11,200 --> 00:40:14,400
and that's leveraging on a lot of work

00:40:12,880 --> 00:40:17,760
from vpr

00:40:14,400 --> 00:40:18,640
right and xp and r and the stuff that's

00:40:17,760 --> 00:40:21,280
being done by

00:40:18,640 --> 00:40:22,800
um you know reverse engineering lattice

00:40:21,280 --> 00:40:25,520
and reverse engineering

00:40:22,800 --> 00:40:27,359
silence right it's a good bit good

00:40:25,520 --> 00:40:31,119
infrastructure there to build on

00:40:27,359 --> 00:40:32,000
that's true great yeah that's really

00:40:31,119 --> 00:40:33,839
where

00:40:32,000 --> 00:40:35,520
the you start to see the benefits of the

00:40:33,839 --> 00:40:37,839
open source community

00:40:35,520 --> 00:40:38,640
and the collaborative efforts which is

00:40:37,839 --> 00:40:41,200
brilliant that's

00:40:38,640 --> 00:40:42,640
that's the whole story right there

00:40:41,200 --> 00:40:45,359
exactly

00:40:42,640 --> 00:40:45,760
yeah okay um well i think we're just

00:40:45,359 --> 00:40:48,560
about

00:40:45,760 --> 00:40:50,480
up to our time limit we're approaching

00:40:48,560 --> 00:40:51,359
the afternoon tea break now in about a

00:40:50,480 --> 00:40:54,160
minute

00:40:51,359 --> 00:40:54,480
so brian and tim thank you very much

00:40:54,160 --> 00:40:57,040
it's

00:40:54,480 --> 00:40:58,480
uh fpgas are a technology i haven't

00:40:57,040 --> 00:40:59,839
really done anything very much with

00:40:58,480 --> 00:41:02,000
myself but i am

00:40:59,839 --> 00:41:03,520
fascinated to see what other people do

00:41:02,000 --> 00:41:05,440
and different approaches to solving

00:41:03,520 --> 00:41:07,760
problems with different technologies

00:41:05,440 --> 00:41:09,359
so it's been very educational thank you

00:41:07,760 --> 00:41:12,720
very much for coming along

00:41:09,359 --> 00:41:14,400
thanks for having us yeah thank you

00:41:12,720 --> 00:41:15,920
all right so for everybody on the stream

00:41:14,400 --> 00:41:19,359
we will see you back here

00:41:15,920 --> 00:41:21,760
at um what time will it be 3

00:41:19,359 --> 00:41:24,720
45 melbourne time whatever that

00:41:21,760 --> 00:41:27,599
translates to so in about 25-ish minutes

00:41:24,720 --> 00:41:29,599
and we will have a talk about an amazing

00:41:27,599 --> 00:41:31,839
commodore 64

00:41:29,599 --> 00:41:33,280
computer reproduction which is also an

00:41:31,839 --> 00:41:35,280
fpga story

00:41:33,280 --> 00:41:36,400
so go and grab yourself a drink and i'll

00:41:35,280 --> 00:41:43,839
see you back here

00:41:36,400 --> 00:41:43,839

YouTube URL: https://www.youtube.com/watch?v=gjorwob1bzo


