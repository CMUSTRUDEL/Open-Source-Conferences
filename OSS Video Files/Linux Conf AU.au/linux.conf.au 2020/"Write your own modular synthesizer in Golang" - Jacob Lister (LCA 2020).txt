Title: "Write your own modular synthesizer in Golang" - Jacob Lister (LCA 2020)
Publication date: 2020-01-14
Playlist: linux.conf.au 2020
Description: 
	Jacob Lister

https://lca2020.linux.org.au/schedule/presentation/164/

Jacob will demonstrate Project Noisefloor, a modular software synthesizer implemented in Golang and transpiled to Javascript to run on the web, and talk through designing the software for multiple platforms (Linux, Windows and the web), some of the challenges of running real time signal processing in the browser

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Mon Jan 13 11:55:00 2020 at Room 5
Captions: 
	00:00:01,100 --> 00:00:06,450
okay welcome back so now we've got Jacob

00:00:04,140 --> 00:00:08,760
Lister and he will be to giving us his

00:00:06,450 --> 00:00:12,650
talk write your own modular synthesizer

00:00:08,760 --> 00:00:12,650
in Geylang Thanks

00:00:15,289 --> 00:00:25,890
hello alright so I'm I'm Jacob just a

00:00:24,930 --> 00:00:28,550
little bit about me

00:00:25,890 --> 00:00:31,940
I live in Wellington New Zealand I'm

00:00:28,550 --> 00:00:34,710
married with no children but one cats

00:00:31,940 --> 00:00:36,180
cats hasn't actually all that interested

00:00:34,710 --> 00:00:38,250
in synthesizers especially those a loud

00:00:36,180 --> 00:00:42,750
bass much you just run some hides under

00:00:38,250 --> 00:00:44,489
the under the beep I've done a broad

00:00:42,750 --> 00:00:47,489
variety offensive in so many industries

00:00:44,489 --> 00:00:49,940
in the software development and losing

00:00:47,489 --> 00:00:52,620
track of them now I started an embedded

00:00:49,940 --> 00:00:54,780
systems development and firmware

00:00:52,620 --> 00:00:56,969
development for us to use and Scott and

00:00:54,780 --> 00:00:59,129
engineering and that sort of thing I've

00:00:56,969 --> 00:01:01,109
done a fair amount in 2d graphics and

00:00:59,129 --> 00:01:02,550
drawing at editing tools and that's the

00:01:01,109 --> 00:01:04,670
stuff and I've been and the Internet

00:01:02,550 --> 00:01:06,479
service provider industry with Arvin

00:01:04,670 --> 00:01:08,790
telecommunications and people with you

00:01:06,479 --> 00:01:11,159
engineering for quite a bit of time as

00:01:08,790 --> 00:01:13,290
well and a little bit of every tick in

00:01:11,159 --> 00:01:16,049
there too and now I work for a payroll

00:01:13,290 --> 00:01:22,200
company which is weird the sinkhole of

00:01:16,049 --> 00:01:24,360
Java developers end up so this talk is

00:01:22,200 --> 00:01:25,380
just going to be a little of a few

00:01:24,360 --> 00:01:26,970
things and they're going to talk a

00:01:25,380 --> 00:01:30,299
little bit about building your own

00:01:26,970 --> 00:01:32,729
synthesizer one picking Dolan as an

00:01:30,299 --> 00:01:35,000
implementation challenge language some

00:01:32,729 --> 00:01:39,720
of the challenges that go around

00:01:35,000 --> 00:01:41,250
creating a user interface for that I'm

00:01:39,720 --> 00:01:42,509
going to talk towards the end of the

00:01:41,250 --> 00:01:44,700
talk all but more about the software

00:01:42,509 --> 00:01:46,939
design and just how I actually build

00:01:44,700 --> 00:01:49,649
this thing for a multi-platform

00:01:46,939 --> 00:01:51,000
but on testing and benchmarking and

00:01:49,649 --> 00:01:52,229
we've got a little bit of time we might

00:01:51,000 --> 00:01:54,119
just take a little bit of a look under

00:01:52,229 --> 00:01:59,759
the hood how the codes put together as

00:01:54,119 --> 00:02:01,560
well so when I'm not doing my day job

00:01:59,759 --> 00:02:03,060
stuff in my home sign I'm very

00:02:01,560 --> 00:02:06,259
interested in music technology and

00:02:03,060 --> 00:02:10,050
building and writing music software so

00:02:06,259 --> 00:02:11,310
very many years ago I rights

00:02:10,050 --> 00:02:13,650
little application here called the

00:02:11,310 --> 00:02:16,230
carbon looper this is a fairly

00:02:13,650 --> 00:02:20,430
conventional conventional MIDI sequencer

00:02:16,230 --> 00:02:23,400
and sampler so a screenshot of that here

00:02:20,430 --> 00:02:25,500
you've got these red blocks which are me

00:02:23,400 --> 00:02:27,780
playing my guitar and these green ones

00:02:25,500 --> 00:02:30,510
which are travelling software playing it

00:02:27,780 --> 00:02:32,910
back and they're just basically sort of

00:02:30,510 --> 00:02:35,910
builds up a song like that so as you can

00:02:32,910 --> 00:02:40,200
see from that screenshot that software

00:02:35,910 --> 00:02:43,800
is written in C and C++ the user

00:02:40,200 --> 00:02:45,690
interface is g GV g DK 2 and it's

00:02:43,800 --> 00:02:51,210
getting rather long in the tooth so i

00:02:45,690 --> 00:02:52,950
wanted to basically do a refresh so for

00:02:51,210 --> 00:02:54,810
that refresh i had a few new homes

00:02:52,950 --> 00:02:57,000
looking at a technology stack that i

00:02:54,810 --> 00:02:58,260
could actually pick and one of the

00:02:57,000 --> 00:02:59,340
things that I'd wanted to get out of

00:02:58,260 --> 00:03:03,720
this was something that could be very

00:02:59,340 --> 00:03:05,490
social so I wanted an application where

00:03:03,720 --> 00:03:07,020
I could just actually actually run it in

00:03:05,490 --> 00:03:11,540
javascript in the browser and share on

00:03:07,020 --> 00:03:15,600
the web without needing any installation

00:03:11,540 --> 00:03:17,370
and I just as it's a home project let's

00:03:15,600 --> 00:03:18,570
link and today I'm constrained by time

00:03:17,370 --> 00:03:19,830
and deadlines and that sort of thing so

00:03:18,570 --> 00:03:25,890
I think it's working I want to have time

00:03:19,830 --> 00:03:27,720
so I did build it up so my long term

00:03:25,890 --> 00:03:29,280
impatient what I'm trying to do for this

00:03:27,720 --> 00:03:31,440
is something like a piece of software

00:03:29,280 --> 00:03:34,080
called growl reactor or other comparable

00:03:31,440 --> 00:03:36,239
products like Max unity this P where you

00:03:34,080 --> 00:03:40,520
can basically have this modular arrange

00:03:36,239 --> 00:03:43,080
them layout your individual processing

00:03:40,520 --> 00:03:48,959
units graphically and then connect them

00:03:43,080 --> 00:03:51,590
all up and build your own synthesizer so

00:03:48,959 --> 00:03:54,750
why go like I looked at quite a few

00:03:51,590 --> 00:03:57,090
potential implementation languages for

00:03:54,750 --> 00:03:59,040
this and the reason I settled on golang

00:03:57,090 --> 00:04:01,170
and the end is though it's got a lot of

00:03:59,040 --> 00:04:02,459
compile targets so I've actually got

00:04:01,170 --> 00:04:04,830
multiple ways that I can build this

00:04:02,459 --> 00:04:07,370
application I can build it to a native

00:04:04,830 --> 00:04:10,170
target using native audio hardware with

00:04:07,370 --> 00:04:12,600
very good real time performance

00:04:10,170 --> 00:04:14,280
golang also has an excellent javascript

00:04:12,600 --> 00:04:16,410
transpiler which were actually just

00:04:14,280 --> 00:04:20,090
pleased javascript the output that you

00:04:16,410 --> 00:04:23,210
can intervene just run in the browser

00:04:20,090 --> 00:04:25,470
there's also a lot of

00:04:23,210 --> 00:04:27,090
activity in the space weed assembly

00:04:25,470 --> 00:04:28,920
target which sure looks like the future

00:04:27,090 --> 00:04:32,250
for running our code in the browser as

00:04:28,920 --> 00:04:35,250
well on top of that there's even

00:04:32,250 --> 00:04:38,250
transpilers for c and c++ of it quite

00:04:35,250 --> 00:04:44,150
experimental so there's a lot of options

00:04:38,250 --> 00:04:46,440
which is basically well I liked it so

00:04:44,150 --> 00:04:51,300
how do you start building a synthesizer

00:04:46,440 --> 00:04:53,910
I really AM L like Darrin's talk and one

00:04:51,300 --> 00:04:56,790
thing that I've decided in presentations

00:04:53,910 --> 00:04:59,850
is that if your diagrams are too

00:04:56,790 --> 00:05:01,680
complicated to draw an esky art then

00:04:59,850 --> 00:05:04,860
there's probably too much going on for a

00:05:01,680 --> 00:05:08,010
presentation so I firmly support the

00:05:04,860 --> 00:05:09,960
effort to make your Adenauer diagrams

00:05:08,010 --> 00:05:12,240
and asked yet the other thing is at

00:05:09,960 --> 00:05:14,700
least in our NGO presenter you put these

00:05:12,240 --> 00:05:17,040
dots down the side of the page it sort

00:05:14,700 --> 00:05:18,240
of lines things up and it also makes it

00:05:17,040 --> 00:05:24,360
look like it's come out of a dot matrix

00:05:18,240 --> 00:05:25,620
printer from the eighties so a little

00:05:24,360 --> 00:05:27,870
bit about what's going on here this

00:05:25,620 --> 00:05:30,360
block diagram this is basically the

00:05:27,870 --> 00:05:32,400
minimum processing units that you need

00:05:30,360 --> 00:05:39,000
in a synthesizer to make something which

00:05:32,400 --> 00:05:41,250
is going to start being musical so the

00:05:39,000 --> 00:05:42,660
the main thing is what is an oscillator

00:05:41,250 --> 00:05:46,950
which is just a periodic waveform

00:05:42,660 --> 00:05:49,080
generator which will produce a time an

00:05:46,950 --> 00:05:50,910
envelope generator below that which

00:05:49,080 --> 00:05:52,710
basically shapes the noise so when you

00:05:50,910 --> 00:05:54,300
hit a key it usually rises to its

00:05:52,710 --> 00:05:57,840
maximum volume quite quickly and then

00:05:54,300 --> 00:05:59,700
sinks off and then a gain which

00:05:57,840 --> 00:06:02,490
basically just multiplies those two

00:05:59,700 --> 00:06:04,080
inputs together so on the left here

00:06:02,490 --> 00:06:06,210
we've got some control signals which are

00:06:04,080 --> 00:06:08,790
inputs to that and the main ones are the

00:06:06,210 --> 00:06:10,670
frequency or the pitch that you want end

00:06:08,790 --> 00:06:13,200
of trigger which is just basically a

00:06:10,670 --> 00:06:19,440
impulse that sees things need to start

00:06:13,200 --> 00:06:23,160
now so all that sort of decided in

00:06:19,440 --> 00:06:25,170
golang as a implementation language a

00:06:23,160 --> 00:06:31,410
product to build being a minimum viable

00:06:25,170 --> 00:06:33,600
synthesizer and some some requirements

00:06:31,410 --> 00:06:35,210
which is via the multi-platform stuff so

00:06:33,600 --> 00:06:38,690
I want to be able to run this

00:06:35,210 --> 00:06:41,360
at least on Linux and Windows and also

00:06:38,690 --> 00:06:43,069
in the browser and I want to the

00:06:41,360 --> 00:06:44,630
audibility user interface where I can

00:06:43,069 --> 00:06:48,650
which I can run for all of those

00:06:44,630 --> 00:06:50,120
compiled targets so that really presents

00:06:48,650 --> 00:06:52,550
quite a bit of a challenge because

00:06:50,120 --> 00:06:54,860
there's a lot of activity in the go

00:06:52,550 --> 00:06:58,160
space on user interface at the moment

00:06:54,860 --> 00:07:02,509
but no real sort of player standards so

00:06:58,160 --> 00:07:05,000
I decided to add another one so some of

00:07:02,509 --> 00:07:07,570
the alternatives I'd looked unto when

00:07:05,000 --> 00:07:10,250
deciding when a user interface was

00:07:07,570 --> 00:07:11,660
perhaps on some platform so I just don't

00:07:10,250 --> 00:07:14,090
have run at all and just want it

00:07:11,660 --> 00:07:17,630
heedless for the native code

00:07:14,090 --> 00:07:20,240
perhaps I build up some minimal client

00:07:17,630 --> 00:07:21,169
server sort of REST API but that looked

00:07:20,240 --> 00:07:24,139
like there's going to be a lot of work

00:07:21,169 --> 00:07:30,070
and perhaps a actually poor low-level

00:07:24,139 --> 00:07:31,940
graphics yes yesteryear more HTML canvas

00:07:30,070 --> 00:07:35,360
which should may actually look at

00:07:31,940 --> 00:07:38,710
billing eventually but for now here's my

00:07:35,360 --> 00:07:41,419
idea which is stream the Dom so

00:07:38,710 --> 00:07:43,360
basically what I'm I've done is I've

00:07:41,419 --> 00:07:45,860
built a client-server application where

00:07:43,360 --> 00:07:48,949
most of the the audio processing is

00:07:45,860 --> 00:07:50,330
running on the server but they use

00:07:48,949 --> 00:07:52,310
rather face rooms and the browser is

00:07:50,330 --> 00:07:55,130
connected by WebSocket and I screamed on

00:07:52,310 --> 00:07:57,560
that dates back and forth after doing

00:07:55,130 --> 00:07:59,300
quite a bit of work with react to the

00:07:57,560 --> 00:08:00,680
front-end JavaScript library in the last

00:07:59,300 --> 00:08:02,360
couple of years I've decided that's

00:08:00,680 --> 00:08:04,370
quite a natural way of working and it

00:08:02,360 --> 00:08:09,199
it's quite easy to implement something

00:08:04,370 --> 00:08:12,500
similar so after talking about it for a

00:08:09,199 --> 00:08:17,840
while let's have a look at it so that's

00:08:12,500 --> 00:08:19,460
rather large at 100% right so here's the

00:08:17,840 --> 00:08:20,930
the building blocks of the the

00:08:19,460 --> 00:08:24,320
application that we saw in that minimum

00:08:20,930 --> 00:08:25,639
viable synth document so on that left

00:08:24,320 --> 00:08:28,849
here what a MIDI input which is

00:08:25,639 --> 00:08:30,349
basically taking MIDI events from an

00:08:28,849 --> 00:08:33,050
external device like a keyboard or so

00:08:30,349 --> 00:08:34,450
forth and transport translating them

00:08:33,050 --> 00:08:38,240
into the control signals

00:08:34,450 --> 00:08:40,479
oscillator generating the time envelope

00:08:38,240 --> 00:08:43,250
generator shape and the noise and gain

00:08:40,479 --> 00:08:44,760
producing the output I've got a little

00:08:43,250 --> 00:08:47,910
keyboard here

00:08:44,760 --> 00:08:51,690
press the keys we can hear the nights

00:08:47,910 --> 00:08:56,220
and a few scopes in the middle then you

00:08:51,690 --> 00:09:03,780
let try my luck and arpeggiator that

00:08:56,220 --> 00:09:05,460
should be fun there we go

00:09:03,780 --> 00:09:11,850
and the scope beyond the bottom is

00:09:05,460 --> 00:09:13,380
showing first one being the the tone and

00:09:11,850 --> 00:09:17,430
that second one being the output of the

00:09:13,380 --> 00:09:18,750
the envelope power generator so just a

00:09:17,430 --> 00:09:21,230
little bit more about what's going on

00:09:18,750 --> 00:09:26,250
there in terms of the user interface I

00:09:21,230 --> 00:09:27,690
turn on some logging yeah I can see if I

00:09:26,250 --> 00:09:37,190
move those around we can see those in

00:09:27,690 --> 00:09:39,780
there it's a lot of events just fine one

00:09:37,190 --> 00:09:41,280
can see those patches coming back and

00:09:39,780 --> 00:09:43,680
basically that's just a list of

00:09:41,280 --> 00:09:45,870
instructions of what are elements and

00:09:43,680 --> 00:09:47,810
the dawn to update so that'll we start a

00:09:45,870 --> 00:09:50,100
color change you can see as those

00:09:47,810 --> 00:09:51,450
signals are going through the colors on

00:09:50,100 --> 00:09:52,770
the connectors are changing and so

00:09:51,450 --> 00:09:53,790
there's basically just some update and

00:09:52,770 --> 00:09:59,280
feedback going on there

00:09:53,790 --> 00:10:05,340
I'm showing what's going on and just to

00:09:59,280 --> 00:10:10,290
make that just a little bit clearer if I

00:10:05,340 --> 00:10:14,700
were to just produce the second window

00:10:10,290 --> 00:10:16,200
the air which has a second can

00:10:14,700 --> 00:10:17,970
connection you can see there's another

00:10:16,200 --> 00:10:21,240
client there and now those are those are

00:10:17,970 --> 00:10:23,580
following along so that's a nice simple

00:10:21,240 --> 00:10:27,360
way to get a user interface out of a

00:10:23,580 --> 00:10:31,290
platform that's not really built for web

00:10:27,360 --> 00:10:32,520
development right now just to have a

00:10:31,290 --> 00:10:34,860
little bit of a look at the code and

00:10:32,520 --> 00:10:36,600
what that looks like you have something

00:10:34,860 --> 00:10:39,330
that looks similar to how you build

00:10:36,600 --> 00:10:41,610
things and react and JavaScript you're

00:10:39,330 --> 00:10:43,920
just building up a sort of development

00:10:41,610 --> 00:10:45,630
and then having various caves underneath

00:10:43,920 --> 00:10:48,500
it and registering have been handles for

00:10:45,630 --> 00:10:48,500
callbacks and so forth

00:10:48,600 --> 00:10:55,300
so some limitations of that approach

00:10:53,019 --> 00:10:58,060
it's very much one events and then one

00:10:55,300 --> 00:11:00,040
updated user interface response coming

00:10:58,060 --> 00:11:02,550
back so anything that you'd sort of

00:11:00,040 --> 00:11:05,529
normally do client-side for front-end

00:11:02,550 --> 00:11:09,160
the event propagation of in bubbling and

00:11:05,529 --> 00:11:10,329
that sort of thing is not possible so if

00:11:09,160 --> 00:11:12,700
to be a little bit creative about how

00:11:10,329 --> 00:11:15,579
you finish your user interface event

00:11:12,700 --> 00:11:16,839
handling no browser side API calls I

00:11:15,579 --> 00:11:18,190
cancel to go out to the internet and

00:11:16,839 --> 00:11:20,350
start making other calls or anything

00:11:18,190 --> 00:11:24,399
like that and I could potentially be

00:11:20,350 --> 00:11:27,579
quite slow for WebSocket so up till now

00:11:24,399 --> 00:11:30,730
we've been talking about the native

00:11:27,579 --> 00:11:36,690
build but it can build for JavaScript as

00:11:30,730 --> 00:11:36,690
well so if we simply go to that URL

00:11:43,230 --> 00:11:46,990
right we can see exactly the same

00:11:45,160 --> 00:11:50,589
application all running in the browser

00:11:46,990 --> 00:11:52,060
and it's not the audio is not coming out

00:11:50,589 --> 00:12:04,959
so it's coming up my laptop but it

00:11:52,060 --> 00:12:06,220
doesn't does work alright so just a few

00:12:04,959 --> 00:12:08,740
more things about how this is put

00:12:06,220 --> 00:12:10,209
together I really encourage everyone to

00:12:08,740 --> 00:12:11,890
read this book

00:12:10,209 --> 00:12:14,709
it's a very good summary clean up

00:12:11,890 --> 00:12:16,660
architecture by Uncle Bob man it's a

00:12:14,709 --> 00:12:18,519
very good summary of this practice

00:12:16,660 --> 00:12:20,829
design patterns in the industry and how

00:12:18,519 --> 00:12:22,269
to structure a an application well and

00:12:20,829 --> 00:12:23,920
well this is actually more talking about

00:12:22,269 --> 00:12:26,110
conventional you know kind of

00:12:23,920 --> 00:12:27,820
accountancy applications there's a whole

00:12:26,110 --> 00:12:30,790
chapter in there on embedded systems and

00:12:27,820 --> 00:12:37,209
how some of those design principles can

00:12:30,790 --> 00:12:39,579
be sort of ported on so in the audio

00:12:37,209 --> 00:12:42,029
clean architecture we have this concept

00:12:39,579 --> 00:12:45,699
of basically sort of onion ARCA C

00:12:42,029 --> 00:12:47,260
architectural concentric circles you

00:12:45,699 --> 00:12:49,120
can't really draw circles and that FD

00:12:47,260 --> 00:12:52,630
takes her art so we're using squares

00:12:49,120 --> 00:12:54,790
instead but the idea here is that we

00:12:52,630 --> 00:12:57,010
have kind of an enough sanctum or an N a

00:12:54,790 --> 00:13:00,610
layer of that audio component processing

00:12:57,010 --> 00:13:03,100
which have no knowledge or even weird

00:13:00,610 --> 00:13:05,829
awareness of existence of the

00:13:03,100 --> 00:13:07,329
the layers outsider and so as we move

00:13:05,829 --> 00:13:08,649
further out we get into user interface

00:13:07,329 --> 00:13:11,200
to move further out again we actually

00:13:08,649 --> 00:13:12,399
get the hardware so the the sort of

00:13:11,200 --> 00:13:13,870
golden role was the core if the

00:13:12,399 --> 00:13:17,589
processing logic shouldn't know anything

00:13:13,870 --> 00:13:19,000
about the platform and the interests

00:13:17,589 --> 00:13:21,730
those basic inputs and outputs again

00:13:19,000 --> 00:13:29,589
audio and MIDI going here and storage

00:13:21,730 --> 00:13:32,940
here and you I hear that's probably not

00:13:29,589 --> 00:13:35,290
the most yeah

00:13:32,940 --> 00:13:38,889
testing and benchmarking we'll come back

00:13:35,290 --> 00:13:40,870
to a few things actually what I would

00:13:38,889 --> 00:13:42,310
like to show you is just some of the

00:13:40,870 --> 00:13:43,870
progress that I've been making over the

00:13:42,310 --> 00:13:46,660
so of the holiday break

00:13:43,870 --> 00:13:48,750
and some new patches so what I intend

00:13:46,660 --> 00:13:51,130
with this sort of as a presentation

00:13:48,750 --> 00:13:53,019
platform is just build up a suite of

00:13:51,130 --> 00:13:56,139
kind of introduction to digital signal

00:13:53,019 --> 00:13:57,519
processing and synthesis 101 with a

00:13:56,139 --> 00:14:01,470
number of work examples that you can

00:13:57,519 --> 00:14:04,750
easily just kind of work through and

00:14:01,470 --> 00:14:06,399
nepia light so they looked at the

00:14:04,750 --> 00:14:09,610
minimum viable synth or just look at

00:14:06,399 --> 00:14:13,570
some other synthesis methods now this is

00:14:09,610 --> 00:14:18,010
an example of additive synthesis so if

00:14:13,570 --> 00:14:24,990
we just press these keys now right what

00:14:18,010 --> 00:14:28,449
we'll see yarn on there is we have

00:14:24,990 --> 00:14:30,100
construction of a more complex waveform

00:14:28,449 --> 00:14:32,410
through additive synthesis of the

00:14:30,100 --> 00:14:36,010
harmonic series at the top we have a

00:14:32,410 --> 00:14:38,500
fundamental notes below that x one below

00:14:36,010 --> 00:14:41,019
that again x times two and then below

00:14:38,500 --> 00:14:42,670
that times three so as you start adding

00:14:41,019 --> 00:14:44,800
those waveforms up in the harmonic

00:14:42,670 --> 00:14:46,990
series you'll start artificially

00:14:44,800 --> 00:14:48,130
constructing more complex waveforms and

00:14:46,990 --> 00:14:51,040
you can sort of see that if that's

00:14:48,130 --> 00:14:55,089
pressed we get that approaching

00:14:51,040 --> 00:14:56,529
triangular slides wave another principle

00:14:55,089 --> 00:14:59,069
there as a free take just the odd

00:14:56,529 --> 00:14:59,069
harmonics

00:15:02,180 --> 00:15:07,290
right we'll see that that wave starts

00:15:04,800 --> 00:15:09,330
taking on a more Square and appearance

00:15:07,290 --> 00:15:11,330
and it gets it starts fitting out and

00:15:09,330 --> 00:15:13,310
sounding a bit more hollow as well

00:15:11,330 --> 00:15:17,330
[Music]

00:15:13,310 --> 00:15:19,980
moving into some modulation techniques

00:15:17,330 --> 00:15:21,420
this one's a bit of a behemoth because

00:15:19,980 --> 00:15:25,650
it does by faintly shooting frequency

00:15:21,420 --> 00:15:26,880
modulation at the same time here we've

00:15:25,650 --> 00:15:29,850
got the concept of what we call a low

00:15:26,880 --> 00:15:31,770
frequency oscillator which is a periodic

00:15:29,850 --> 00:15:35,220
waveform which is operating in Rangers

00:15:31,770 --> 00:15:38,030
normally below the audible that can be

00:15:35,220 --> 00:15:40,590
used as a control to modulate the wave

00:15:38,030 --> 00:15:42,420
so in this configuration that's it for

00:15:40,590 --> 00:15:46,140
frequency modulation so if we had that

00:15:42,420 --> 00:15:48,750
key we can see that that wave on the

00:15:46,140 --> 00:15:57,410
right has into the swaying in and out

00:15:48,750 --> 00:16:13,130
and a kind of vibrato effect if I

00:15:57,410 --> 00:16:13,130
switched a few switches there sorry few

00:16:18,890 --> 00:16:25,140
more subtle but now we've got no but now

00:16:23,490 --> 00:16:27,840
I would ever achieve my modulation we

00:16:25,140 --> 00:16:29,220
were actually I'm varying the amplitude

00:16:27,840 --> 00:16:31,290
of the end of the wave rather than the

00:16:29,220 --> 00:16:32,910
frequency so you can see all of that

00:16:31,290 --> 00:16:34,770
basic stuff can actually built up I'm

00:16:32,910 --> 00:16:40,140
quite visually and and it's quite easy

00:16:34,770 --> 00:16:42,140
to I'm a demonstrator so just have a

00:16:40,140 --> 00:16:44,640
little bit of a look at the the code

00:16:42,140 --> 00:16:46,320
when I add these some processing units

00:16:44,640 --> 00:16:48,000
one one of the things that was going to

00:16:46,320 --> 00:16:49,700
be quite important as because there's

00:16:48,000 --> 00:16:52,680
just going to be such a volume of them

00:16:49,700 --> 00:16:54,240
you will literally have your hundreds of

00:16:52,680 --> 00:16:56,550
different little modules that do one

00:16:54,240 --> 00:16:58,589
very specific thing and it's quite

00:16:56,550 --> 00:17:00,750
important that they can be added in a

00:16:58,589 --> 00:17:02,400
very simple way so if we look at like

00:17:00,750 --> 00:17:05,970
the most simple example this is just a

00:17:02,400 --> 00:17:09,949
sum the code is literally just a couple

00:17:05,970 --> 00:17:14,970
of lines that needs to do that one thing

00:17:09,949 --> 00:17:16,949
go and they're pub the reason that go is

00:17:14,970 --> 00:17:18,810
quite good for having a lot of

00:17:16,949 --> 00:17:20,670
controlled is that the bulk of

00:17:18,810 --> 00:17:23,310
the compiler tool set is actually in the

00:17:20,670 --> 00:17:26,280
standard tools so it's very easy to

00:17:23,310 --> 00:17:29,820
parse go and go and it's very easy to

00:17:26,280 --> 00:17:30,929
generate new go code and go so what I

00:17:29,820 --> 00:17:33,720
would have got going on the air is

00:17:30,929 --> 00:17:36,120
basically a little builder generator

00:17:33,720 --> 00:17:40,890
which will pass their file and then

00:17:36,120 --> 00:17:42,900
generate a more for our output like this

00:17:40,890 --> 00:17:46,050
which adds these methods like start and

00:17:42,900 --> 00:17:47,760
stop if you didn't add them creates a

00:17:46,050 --> 00:17:49,710
definition saying what parameters that

00:17:47,760 --> 00:17:51,120
has and so forth and then when we come

00:17:49,710 --> 00:17:53,790
to the user interface we want to add a

00:17:51,120 --> 00:17:55,470
new one we just drop it in and all the

00:17:53,790 --> 00:17:56,820
user interface is built so for the

00:17:55,470 --> 00:17:57,840
simple case of actually just adding in

00:17:56,820 --> 00:18:04,160
your talk that can make sure you don't

00:17:57,840 --> 00:18:04,160
quite easily and then you can remove it

00:18:08,840 --> 00:18:13,919
testing and development yeah this has

00:18:11,640 --> 00:18:16,559
been one of the more challenging parts

00:18:13,919 --> 00:18:17,910
of building a tool like this is that

00:18:16,559 --> 00:18:19,380
because it's building for multiple

00:18:17,910 --> 00:18:23,640
control targets and particularly

00:18:19,380 --> 00:18:26,820
javascript it's good to have a handle on

00:18:23,640 --> 00:18:30,660
how well the code is performing on are

00:18:26,820 --> 00:18:34,850
just pure it's a benchmarking approach

00:18:30,660 --> 00:18:34,850
so dough has very good tools for that

00:18:37,250 --> 00:18:42,570
here I've got a set of benchmark tests

00:18:39,660 --> 00:18:44,669
which I can basically run the same tests

00:18:42,570 --> 00:18:46,380
for both the goal implementation and the

00:18:44,669 --> 00:18:51,330
Transvaal JavaScript and just see how

00:18:46,380 --> 00:18:53,040
they can peer this is quite neat you

00:18:51,330 --> 00:18:55,080
just set up a little snippet and put it

00:18:53,040 --> 00:18:56,940
in the test harness and the test suite

00:18:55,080 --> 00:18:58,890
itself will just exercise it until it's

00:18:56,940 --> 00:19:00,630
got enough data and run it run a million

00:18:58,890 --> 00:19:04,740
times and they give you a an output

00:19:00,630 --> 00:19:05,910
summary of how long it took and when I

00:19:04,740 --> 00:19:09,419
run it I can hear my laptop actually

00:19:05,910 --> 00:19:11,780
whirring up is the is that it sighs it's

00:19:09,419 --> 00:19:11,780
the middle

00:19:36,960 --> 00:19:42,249
right we can see the result of that

00:19:39,249 --> 00:19:43,480
output there some set like certain

00:19:42,249 --> 00:19:45,159
things like just making a single

00:19:43,480 --> 00:19:47,409
function call you actually get like an

00:19:45,159 --> 00:19:49,899
almost identical overhead between the

00:19:47,409 --> 00:19:52,049
native target and the transport

00:19:49,899 --> 00:19:54,840
JavaScript and then some other things

00:19:52,049 --> 00:19:57,609
and you'll see this compile into

00:19:54,840 --> 00:19:59,289
interpretive engine single sample so one

00:19:57,609 --> 00:20:08,340
of the other challenges with us social

00:19:59,289 --> 00:20:08,340
so those patches we were just looking at

00:20:11,580 --> 00:20:18,940
here we go that's what one of those

00:20:17,019 --> 00:20:21,279
patches looks like I'm saved out so it's

00:20:18,940 --> 00:20:23,710
just XML it's really simple just got a

00:20:21,279 --> 00:20:25,509
list of the processes of the livia and

00:20:23,710 --> 00:20:27,070
all most of the connectors and and where

00:20:25,509 --> 00:20:28,659
they go to so the format is really

00:20:27,070 --> 00:20:31,059
simple

00:20:28,659 --> 00:20:33,759
the next challenge that you have to

00:20:31,059 --> 00:20:35,019
actually run this thing as you need some

00:20:33,759 --> 00:20:36,789
kind of a strategy to actually walk

00:20:35,019 --> 00:20:40,029
through the graph and then process each

00:20:36,789 --> 00:20:41,529
sample at each at each point so the way

00:20:40,029 --> 00:20:43,119
of doing that is basically a tope tope

00:20:41,529 --> 00:20:45,789
illogical sort of the graph which will

00:20:43,119 --> 00:20:47,320
give you a list of the order you need to

00:20:45,789 --> 00:20:48,639
traverse the modules so that the

00:20:47,320 --> 00:20:51,759
dependence is wrong with the previous

00:20:48,639 --> 00:20:56,019
data from the previous operations or and

00:20:51,759 --> 00:20:58,779
sent the ideal way to do this is

00:20:56,019 --> 00:21:00,399
actually do it on every sample and 44

00:20:58,779 --> 00:21:02,080
thousand samples a second that's a lot

00:21:00,399 --> 00:21:03,700
of calls so the overhead of making a

00:21:02,080 --> 00:21:06,639
function call is actually more than

00:21:03,700 --> 00:21:08,350
doing the work so when we start having

00:21:06,639 --> 00:21:10,989
benchmarks like this it's quite helpful

00:21:08,350 --> 00:21:13,450
because it'll tell me things like the

00:21:10,989 --> 00:21:14,799
some single single sample example here

00:21:13,450 --> 00:21:16,450
is saying the JavaScript version is

00:21:14,799 --> 00:21:18,369
actually 40 times slower than the

00:21:16,450 --> 00:21:19,929
compiled one so that's something I'm

00:21:18,369 --> 00:21:21,340
just the reason for that is that

00:21:19,929 --> 00:21:23,679
abstracted over a basically a

00:21:21,340 --> 00:21:25,450
polymorphic interface and the go cool so

00:21:23,679 --> 00:21:26,710
it's that's quite slow so it's just not

00:21:25,450 --> 00:21:31,960
something I can do in JavaScript at the

00:21:26,710 --> 00:21:36,940
moment all right well I think we might

00:21:31,960 --> 00:21:39,450
just take some questions or people let's

00:21:36,940 --> 00:21:39,450

YouTube URL: https://www.youtube.com/watch?v=slhjDsMM1Zw


