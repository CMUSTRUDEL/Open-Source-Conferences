Title: "Anatomy of a run-time: your contract with the kernel" - Curtis Millar (LCA 2020)
Publication date: 2020-01-14
Playlist: linux.conf.au 2020
Description: 
	Curtis Millar

https://lca2020.linux.org.au/schedule/presentation/136/

When developing any kind of software your primary constraint is the interface offered by your operating system kernel. The interface is managed and abstracted by the run-time within which your program operates. This talks looks at how operating system and kernel design can affect the design of a language run-time, what features and components are necessary in a run-time to develop software, and how existing design choices in kernel, run-time, and language design affect the ability to write portable software and the future development of programming languages and kernels.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Tue Jan 14 10:50:00 2020 at Arena
Captions: 
	00:00:00,030 --> 00:00:05,430
do we have visual oh yes as a link that

00:00:03,540 --> 00:00:07,970
slides up there if you want to follow

00:00:05,430 --> 00:00:10,830
along and something easy to read but

00:00:07,970 --> 00:00:12,540
thanks for coming this morning - Colonel

00:00:10,830 --> 00:00:15,179
many Kampf I'm going to talk about run

00:00:12,540 --> 00:00:16,920
times language run times the anatomy of

00:00:15,179 --> 00:00:17,490
language run times in your contract with

00:00:16,920 --> 00:00:19,650
the colonel

00:00:17,490 --> 00:00:22,680
it's briefing - doctor knows - who I am

00:00:19,650 --> 00:00:23,910
Kurtis this is a clearer picture of me

00:00:22,680 --> 00:00:26,220
if you can't see my face from where you

00:00:23,910 --> 00:00:28,980
are I'm a research engineer I work at

00:00:26,220 --> 00:00:31,949
the trustworthy Systems Group at CSIRO s

00:00:28,980 --> 00:00:33,090
data 61 and I develop I'm part of the

00:00:31,949 --> 00:00:36,090
team that develops the SEO for

00:00:33,090 --> 00:00:39,110
microkernel and in my spare time I like

00:00:36,090 --> 00:00:40,950
to ride a lot of rust and this talk

00:00:39,110 --> 00:00:42,840
hopefully by the end of it you'll have

00:00:40,950 --> 00:00:45,390
some idea how the concept of write once

00:00:42,840 --> 00:00:47,270
run anywhere as possible and how a

00:00:45,390 --> 00:00:49,350
programming language is runtime

00:00:47,270 --> 00:00:50,940
interacts with its build system and the

00:00:49,350 --> 00:00:53,129
operating system in which it runs in

00:00:50,940 --> 00:00:55,920
order to provide a portable interface to

00:00:53,129 --> 00:00:58,320
satisfy that guarantee and how when you

00:00:55,920 --> 00:01:00,960
change what the operating system is able

00:00:58,320 --> 00:01:03,379
to provide that affects the ability of

00:01:00,960 --> 00:01:05,519
the language to provide that guarantee a

00:01:03,379 --> 00:01:08,070
brief overview of how we're going to get

00:01:05,519 --> 00:01:10,650
for all of that I'll start with what is

00:01:08,070 --> 00:01:12,810
a runtime look at how runtimes let us

00:01:10,650 --> 00:01:15,090
develop software for major operating

00:01:12,810 --> 00:01:17,340
systems and then we'll strip away the

00:01:15,090 --> 00:01:20,700
operating system and slowly build it

00:01:17,340 --> 00:01:24,439
back up on top of a microkernel to get

00:01:20,700 --> 00:01:26,490
an understanding of the scale at which a

00:01:24,439 --> 00:01:29,009
language can provide us with these

00:01:26,490 --> 00:01:30,540
portable tools up to the point where we

00:01:29,009 --> 00:01:32,549
can write user applications again and

00:01:30,540 --> 00:01:33,990
then I'll briefly mention the work I've

00:01:32,549 --> 00:01:36,540
done with trustworthy systems that mate

00:01:33,990 --> 00:01:38,790
got me into this mess to begin with so

00:01:36,540 --> 00:01:41,250
what is a runtime or a programming

00:01:38,790 --> 00:01:43,700
language runtime it is a component of

00:01:41,250 --> 00:01:46,770
the programming language tool chain and

00:01:43,700 --> 00:01:47,790
it executes within the application so

00:01:46,770 --> 00:01:48,840
for the purpose of this talk I'm

00:01:47,790 --> 00:01:51,020
referring to everything that the

00:01:48,840 --> 00:01:53,430
programming language toolchain provides

00:01:51,020 --> 00:01:55,740
that is executing at the same time the

00:01:53,430 --> 00:01:57,630
application is this can include

00:01:55,740 --> 00:01:59,820
components of the standard library or a

00:01:57,630 --> 00:02:03,210
monolithic runtime application itself

00:01:59,820 --> 00:02:05,790
and these together work to provide a

00:02:03,210 --> 00:02:07,590
high-level interface that is consistent

00:02:05,790 --> 00:02:08,759
to applications program to it that

00:02:07,590 --> 00:02:12,120
doesn't change as you move between

00:02:08,759 --> 00:02:13,500
platforms some features that runtimes

00:02:12,120 --> 00:02:15,540
tend to provide

00:02:13,500 --> 00:02:16,950
process entry and exit is the most

00:02:15,540 --> 00:02:18,570
fundamental thing that your runtime is

00:02:16,950 --> 00:02:21,180
going to handle for you and abstract for

00:02:18,570 --> 00:02:24,240
you runtimes will provide dynamic memory

00:02:21,180 --> 00:02:25,920
management capabilities this can be fire

00:02:24,240 --> 00:02:29,820
explicit mechanisms like malloc and free

00:02:25,920 --> 00:02:32,340
and it can also be by a more managed

00:02:29,820 --> 00:02:33,990
system such as garbage collection your

00:02:32,340 --> 00:02:35,580
runtime will often provide multitasking

00:02:33,990 --> 00:02:37,530
primitives for you this can be

00:02:35,580 --> 00:02:39,420
abstractions on threading mechanisms

00:02:37,530 --> 00:02:41,250
provided by your operating system but

00:02:39,420 --> 00:02:43,110
can also be mechanisms that perform

00:02:41,250 --> 00:02:45,060
multitasking within the application

00:02:43,110 --> 00:02:46,590
itself before handing off anything to

00:02:45,060 --> 00:02:49,950
the operating system for blocking and

00:02:46,590 --> 00:02:51,480
synchronization your runtime may

00:02:49,950 --> 00:02:53,160
obstruct over the concepts of process

00:02:51,480 --> 00:02:55,590
management how you start new processes

00:02:53,160 --> 00:02:57,240
and communicate with them and in general

00:02:55,590 --> 00:02:59,490
communication between processes and

00:02:57,240 --> 00:03:03,600
threads and synchronizing them over a

00:02:59,490 --> 00:03:06,480
scheduler more broadly your runtime will

00:03:03,600 --> 00:03:09,480
give you mechanisms to interact with the

00:03:06,480 --> 00:03:11,610
file system open files close files say

00:03:09,480 --> 00:03:13,650
ask write and read data use them as

00:03:11,610 --> 00:03:16,770
communication between processes or use

00:03:13,650 --> 00:03:18,269
them as persistent storage networking as

00:03:16,770 --> 00:03:21,209
well communicating with other computers

00:03:18,269 --> 00:03:22,769
via a network remote hosts and a bunch

00:03:21,209 --> 00:03:26,730
of OS independent utilities string

00:03:22,769 --> 00:03:29,730
manipulation arithmetic math often

00:03:26,730 --> 00:03:31,110
there'll be some kind of user interface

00:03:29,730 --> 00:03:32,820
usually this is just going to be the

00:03:31,110 --> 00:03:35,580
assumption that you can interact over a

00:03:32,820 --> 00:03:37,380
text text interface fire standard and

00:03:35,580 --> 00:03:38,850
standard out sometimes your runtime

00:03:37,380 --> 00:03:40,380
knows enough about the system provide

00:03:38,850 --> 00:03:44,190
you to provide you tools to set up

00:03:40,380 --> 00:03:45,690
graphical interfaces the main there are

00:03:44,190 --> 00:03:47,700
three main ways that a runtime is able

00:03:45,690 --> 00:03:50,239
to provide these features to you the

00:03:47,700 --> 00:03:52,620
first is via the tool chain so as the

00:03:50,239 --> 00:03:54,720
application is being built things can be

00:03:52,620 --> 00:03:56,100
analyzed your code could be analyzed or

00:03:54,720 --> 00:03:58,500
we could find files in the file system

00:03:56,100 --> 00:04:01,530
and embed those into the runtime itself

00:03:58,500 --> 00:04:02,850
to provide features when the application

00:04:01,530 --> 00:04:05,250
is running we can communicate with the

00:04:02,850 --> 00:04:07,920
operating system and offload the need to

00:04:05,250 --> 00:04:09,510
do work to that operating system this

00:04:07,920 --> 00:04:10,980
can be things like process metadata

00:04:09,510 --> 00:04:12,480
about what the current process that's

00:04:10,980 --> 00:04:14,370
running communication with other

00:04:12,480 --> 00:04:16,519
processes and communication with

00:04:14,370 --> 00:04:18,479
services offered by the operating system

00:04:16,519 --> 00:04:20,400
then finally there's just everything

00:04:18,479 --> 00:04:22,349
that the execution of the runtime is

00:04:20,400 --> 00:04:24,240
able to do itself it can do work when

00:04:22,349 --> 00:04:26,310
called in to explicitly by your

00:04:24,240 --> 00:04:28,410
application it does work before and

00:04:26,310 --> 00:04:30,630
the main process entry-and-exit and if

00:04:28,410 --> 00:04:32,790
you have a high-level language that's

00:04:30,630 --> 00:04:35,820
running in an interpreter or a bytecode

00:04:32,790 --> 00:04:37,290
vm it's able to perform a lot of work in

00:04:35,820 --> 00:04:39,030
the process of executing that

00:04:37,290 --> 00:04:40,290
application most of what I'm going to

00:04:39,030 --> 00:04:42,150
talk about today is this middle category

00:04:40,290 --> 00:04:45,900
the operating system and how we can

00:04:42,150 --> 00:04:47,040
offload work to that to begin with I'm

00:04:45,900 --> 00:04:49,110
going to give an example of what it's

00:04:47,040 --> 00:04:51,000
like to develop for a major operating

00:04:49,110 --> 00:04:53,040
system in this case I'm going to look at

00:04:51,000 --> 00:04:55,650
writing a rust application to run on

00:04:53,040 --> 00:04:57,180
Linux and in this case our rasp runtime

00:04:55,650 --> 00:05:00,150
is able to handle process an entry exit

00:04:57,180 --> 00:05:02,669
entry and exit for us it can provide us

00:05:00,150 --> 00:05:04,470
dynamic memory management primitives we

00:05:02,669 --> 00:05:07,110
can do multi tasking in this case rust

00:05:04,470 --> 00:05:08,820
can provide us with runtime level

00:05:07,110 --> 00:05:12,450
multitasking but we'll be looking at

00:05:08,820 --> 00:05:13,889
threading provided by Linux a user

00:05:12,450 --> 00:05:16,229
interface in this case would be standard

00:05:13,889 --> 00:05:18,180
in and standard out should we use it we

00:05:16,229 --> 00:05:20,970
can start new processes and communicate

00:05:18,180 --> 00:05:24,210
them using the command API the file

00:05:20,970 --> 00:05:27,110
system we can open files create files we

00:05:24,210 --> 00:05:29,160
can open network sockets using you know

00:05:27,110 --> 00:05:30,690
interface in the standard library for

00:05:29,160 --> 00:05:34,710
creating network socket listeners and

00:05:30,690 --> 00:05:36,539
connecting to other computers this is a

00:05:34,710 --> 00:05:38,669
simple file server that I've written in

00:05:36,539 --> 00:05:40,950
two functions which should demonstrate

00:05:38,669 --> 00:05:43,950
some of the features of the wrost

00:05:40,950 --> 00:05:45,000
runtime this is our main function the

00:05:43,950 --> 00:05:47,070
first thing it's going to do is handle

00:05:45,000 --> 00:05:49,140
process entry for us it takes the Linux

00:05:47,070 --> 00:05:51,090
let the mechanism Linux provides for

00:05:49,140 --> 00:05:53,070
starting a process and uses that to

00:05:51,090 --> 00:05:55,590
initialize itself and then call this

00:05:53,070 --> 00:05:57,180
main function which we've defined and in

00:05:55,590 --> 00:05:59,490
this case it's also going to handle any

00:05:57,180 --> 00:06:00,780
errors for us if our program hits upon

00:05:59,490 --> 00:06:02,400
any errors we're immediately going to

00:06:00,780 --> 00:06:05,490
return to the runtime it's going to

00:06:02,400 --> 00:06:06,600
print a message and then exit the first

00:06:05,490 --> 00:06:08,160
thing we're going to do is bind to a

00:06:06,600 --> 00:06:10,530
network address using a mechanism from

00:06:08,160 --> 00:06:12,990
the standard library for creating a TCP

00:06:10,530 --> 00:06:14,639
listener and then we're going to listen

00:06:12,990 --> 00:06:17,610
to every new connection that comes in to

00:06:14,639 --> 00:06:19,139
this network address and handle it we're

00:06:17,610 --> 00:06:21,270
going to spawn a thread dedicated to

00:06:19,139 --> 00:06:22,620
handling each new connection that thread

00:06:21,270 --> 00:06:24,510
is going to handle the request

00:06:22,620 --> 00:06:27,360
throw away any errors and then try and

00:06:24,510 --> 00:06:31,050
shut down the stream gracefully to close

00:06:27,360 --> 00:06:32,460
the connection and then in our handle

00:06:31,050 --> 00:06:35,220
function which is called in this new

00:06:32,460 --> 00:06:37,140
thread it's going to start reading

00:06:35,220 --> 00:06:39,100
information from this network stream

00:06:37,140 --> 00:06:41,830
it's going to read in a string

00:06:39,100 --> 00:06:43,750
to a path validate that path make sure

00:06:41,830 --> 00:06:45,520
it's correctly formatted it'll check

00:06:43,750 --> 00:06:47,290
that the location of that file is

00:06:45,520 --> 00:06:51,820
somewhere in the subdirectory of the

00:06:47,290 --> 00:06:54,130
current location that this program is

00:06:51,820 --> 00:06:56,020
executing will then open that file and

00:06:54,130 --> 00:06:59,200
then just read the contents of that file

00:06:56,020 --> 00:07:01,270
out to the network the easiest way to

00:06:59,200 --> 00:07:02,650
look at what mechanisms the runtime is

00:07:01,270 --> 00:07:04,600
providing to us here is to look at all

00:07:02,650 --> 00:07:06,790
of these imports so our first line is

00:07:04,600 --> 00:07:09,040
networking the networking module which

00:07:06,790 --> 00:07:12,070
gives us our TCP listener to wait for

00:07:09,040 --> 00:07:13,870
requests and listen to them and then the

00:07:12,070 --> 00:07:15,760
mechanisms to communicate via that TCP

00:07:13,870 --> 00:07:17,440
stream our second line is

00:07:15,760 --> 00:07:19,270
multi-threading this is an abstraction

00:07:17,440 --> 00:07:22,600
over the threading mechanisms provided

00:07:19,270 --> 00:07:25,540
by Linux I always a set of standardized

00:07:22,600 --> 00:07:26,860
interfaces for describing what an

00:07:25,540 --> 00:07:29,770
implementer would need to provide to

00:07:26,860 --> 00:07:31,960
allow us to communicate using bytes this

00:07:29,770 --> 00:07:35,470
could be two files two strings two

00:07:31,960 --> 00:07:38,470
buffers to network streams we have an

00:07:35,470 --> 00:07:41,980
abstraction over path resolution through

00:07:38,470 --> 00:07:43,240
the path api's here and this generalizes

00:07:41,980 --> 00:07:46,180
the different ways in which operating

00:07:43,240 --> 00:07:47,770
systems handle paths we have the process

00:07:46,180 --> 00:07:49,210
environment here where we try and

00:07:47,770 --> 00:07:51,910
determine which directory in the file

00:07:49,210 --> 00:07:54,580
system our process is executing in and

00:07:51,910 --> 00:07:56,710
we have the ability to open files and

00:07:54,580 --> 00:07:59,440
read files and this last line here is

00:07:56,710 --> 00:08:01,570
just a type alias to tidy up the error

00:07:59,440 --> 00:08:04,780
handling and rust to make the program

00:08:01,570 --> 00:08:07,330
nice and compact but with these few

00:08:04,780 --> 00:08:09,550
lines we have a basic file server that

00:08:07,330 --> 00:08:11,500
not only runs on Linux but it will run

00:08:09,550 --> 00:08:13,480
on most major os's without any change to

00:08:11,500 --> 00:08:16,870
this code so it'll run on Linux Windows

00:08:13,480 --> 00:08:19,330
Mac OS FreeBSD and I don't need to

00:08:16,870 --> 00:08:22,030
change anything that is written here and

00:08:19,330 --> 00:08:24,790
this is pretty representative of a lot

00:08:22,030 --> 00:08:26,200
of application level programming across

00:08:24,790 --> 00:08:27,970
these operating systems it doesn't do

00:08:26,200 --> 00:08:30,130
any graphical interface stuff it's not

00:08:27,970 --> 00:08:33,430
web applications but it covers most of

00:08:30,130 --> 00:08:35,050
the other cases look what happens when

00:08:33,430 --> 00:08:37,000
we take away the operating system and we

00:08:35,050 --> 00:08:37,419
now have to interact directly with the

00:08:37,000 --> 00:08:39,550
hardware

00:08:37,419 --> 00:08:42,040
what are we able to rely on if we have a

00:08:39,550 --> 00:08:45,940
portable language what is that language

00:08:42,040 --> 00:08:48,209
actually able to supply to us I'm going

00:08:45,940 --> 00:08:52,110
to take the example of free-standing C

00:08:48,209 --> 00:08:55,529
on top of this x86 platform and I'm

00:08:52,110 --> 00:08:57,209
going to talk about the most general

00:08:55,529 --> 00:08:58,709
form of runtime we can probably provide

00:08:57,209 --> 00:09:01,490
here that assumes the least amount of

00:08:58,709 --> 00:09:03,660
existed about the hardware case possible

00:09:01,490 --> 00:09:05,670
so it's going to need to handle process

00:09:03,660 --> 00:09:09,300
entry and exit for us our process needs

00:09:05,670 --> 00:09:10,649
to start somehow it could implement some

00:09:09,300 --> 00:09:12,089
sort of dynamic memory management it

00:09:10,649 --> 00:09:14,369
could have a statically mapped region

00:09:12,089 --> 00:09:16,019
for the heap it could provide some

00:09:14,369 --> 00:09:18,720
multitasking primitives but any

00:09:16,019 --> 00:09:21,360
mechanisms for blocking or waiting on

00:09:18,720 --> 00:09:22,529
signals and resuming of tasks is going

00:09:21,360 --> 00:09:25,740
to be largely provided by the

00:09:22,529 --> 00:09:28,740
application communicating with the user

00:09:25,740 --> 00:09:30,209
is quite difficult at this point there's

00:09:28,740 --> 00:09:32,009
a lot of ways it could be done we could

00:09:30,209 --> 00:09:34,679
make assumptions about the serial

00:09:32,009 --> 00:09:37,249
interface and use that but that would be

00:09:34,679 --> 00:09:39,740
baking a lot of stuff into our runtime

00:09:37,249 --> 00:09:42,029
there's no concept of processes here

00:09:39,740 --> 00:09:44,999
there's no file system here to interact

00:09:42,029 --> 00:09:46,559
with and there's no network drivers for

00:09:44,999 --> 00:09:48,959
us to assume exists so that we can

00:09:46,559 --> 00:09:50,939
create network connections and the Sirah

00:09:48,959 --> 00:09:53,459
standard specification doesn't even

00:09:50,939 --> 00:09:56,459
provide a networking API for that you

00:09:53,459 --> 00:09:58,319
need like POSIX so this is pretty

00:09:56,459 --> 00:10:00,839
minimal our application from before

00:09:58,319 --> 00:10:02,369
clearly we couldn't just run it here it

00:10:00,839 --> 00:10:04,860
would need a lot more work to provide

00:10:02,369 --> 00:10:06,029
features to this runtime and we would

00:10:04,860 --> 00:10:10,709
need to be doing a lot more work within

00:10:06,029 --> 00:10:12,839
the application so the next easiest step

00:10:10,709 --> 00:10:15,769
to take to provide just that little bit

00:10:12,839 --> 00:10:19,410
more abstraction is a microkernel and

00:10:15,769 --> 00:10:22,350
who cover just what exactly a

00:10:19,410 --> 00:10:24,420
microkernel is I think this quote from

00:10:22,350 --> 00:10:26,970
your hand lid key I hope I've pronounced

00:10:24,420 --> 00:10:29,490
that correctly sums it up really nicely

00:10:26,970 --> 00:10:31,860
and that a concept is tolerated inside

00:10:29,490 --> 00:10:33,240
the microkernel only if moving it

00:10:31,860 --> 00:10:34,889
outside the kernel ie permitting

00:10:33,240 --> 00:10:37,049
convenient implementations would prevent

00:10:34,889 --> 00:10:39,420
the implementations of the system's

00:10:37,049 --> 00:10:41,519
required functionality if I can take a

00:10:39,420 --> 00:10:44,129
component of my kernel and move it

00:10:41,519 --> 00:10:46,170
outside of that kernel as a user

00:10:44,129 --> 00:10:48,059
application and I'm still able to

00:10:46,170 --> 00:10:49,829
construct the same system I could before

00:10:48,059 --> 00:10:53,549
there's no reason that should be in the

00:10:49,829 --> 00:10:55,199
kernel so our kernel has the most

00:10:53,549 --> 00:10:58,410
minimal responsibility of the system

00:10:55,199 --> 00:11:00,149
possible we implement all of our system

00:10:58,410 --> 00:11:01,590
services outside the kernel as user

00:11:00,149 --> 00:11:03,210
applications

00:11:01,590 --> 00:11:05,070
we have very small modular components

00:11:03,210 --> 00:11:06,210
that can be independently worked on and

00:11:05,070 --> 00:11:09,120
a communicate over well-defined

00:11:06,210 --> 00:11:11,700
interfaces and we also end up with a

00:11:09,120 --> 00:11:13,350
very small trusted computing base if I

00:11:11,700 --> 00:11:15,420
have an application that needs to for

00:11:13,350 --> 00:11:16,860
example communicate over a network and

00:11:15,420 --> 00:11:19,620
it communicates with the networking

00:11:16,860 --> 00:11:21,090
component of the system and that

00:11:19,620 --> 00:11:23,340
networking component doesn't depend on

00:11:21,090 --> 00:11:25,260
the file system component then my

00:11:23,340 --> 00:11:26,790
application doesn't need to trust at all

00:11:25,260 --> 00:11:28,800
that the file system component is

00:11:26,790 --> 00:11:30,270
functional that it's available that it's

00:11:28,800 --> 00:11:30,900
implemented correctly or it's not

00:11:30,270 --> 00:11:35,010
malicious

00:11:30,900 --> 00:11:36,540
there's no dependency there the

00:11:35,010 --> 00:11:38,820
microkernel I'm going to use today to

00:11:36,540 --> 00:11:40,020
describe things is SEL for because

00:11:38,820 --> 00:11:41,940
that's what I am familiar with it's what

00:11:40,020 --> 00:11:43,650
I work on and this is a brief

00:11:41,940 --> 00:11:46,980
description of some of the features that

00:11:43,650 --> 00:11:49,080
it provides for us but primarily SEL for

00:11:46,980 --> 00:11:51,830
Garan is there to guarantee isolation

00:11:49,080 --> 00:11:54,240
between user mode processes and to

00:11:51,830 --> 00:11:55,500
provide the mechanism for us to control

00:11:54,240 --> 00:11:57,540
how those can communicate with each

00:11:55,500 --> 00:12:00,900
other and how they are scheduled and the

00:11:57,540 --> 00:12:02,850
resources that they can access but

00:12:00,900 --> 00:12:05,070
importantly the kernel itself in this

00:12:02,850 --> 00:12:07,800
case isn't providing any policy as to

00:12:05,070 --> 00:12:10,140
how that is done we use mechanisms to

00:12:07,800 --> 00:12:11,150
inform the colonel about what that

00:12:10,140 --> 00:12:15,150
policy should be

00:12:11,150 --> 00:12:17,490
we've also formally verified it the

00:12:15,150 --> 00:12:19,020
concepts that SEO four has firstly is

00:12:17,490 --> 00:12:20,370
virtual address spaces I can create a

00:12:19,020 --> 00:12:23,340
virtual address space I can map in

00:12:20,370 --> 00:12:24,930
physical memory and device memory into

00:12:23,340 --> 00:12:27,870
any virtual address space for a user

00:12:24,930 --> 00:12:30,000
process I can schedule threads that are

00:12:27,870 --> 00:12:33,030
executed in that virtual address space I

00:12:30,000 --> 00:12:35,550
can perform IPC and synchronization

00:12:33,030 --> 00:12:37,290
between threads executing in the same or

00:12:35,550 --> 00:12:38,820
different virtual address spaces we have

00:12:37,290 --> 00:12:41,580
two mechanisms for this endpoints

00:12:38,820 --> 00:12:43,850
synchronous communication notification

00:12:41,580 --> 00:12:46,560
objects for asynchronous communication

00:12:43,850 --> 00:12:50,280
and then we also have some mechanisms

00:12:46,560 --> 00:12:51,690
for device IO I accuse i/o ports tends

00:12:50,280 --> 00:12:54,930
to get a bit platform-specific at that

00:12:51,690 --> 00:12:56,460
point and then the policy for who has

00:12:54,930 --> 00:12:59,160
access to these objects and these

00:12:56,460 --> 00:13:01,040
resources and who can pass around access

00:12:59,160 --> 00:13:03,750
to these resources is encoded using

00:13:01,040 --> 00:13:09,420
capability objects and capabilities

00:13:03,750 --> 00:13:12,270
within C node objects but if this is the

00:13:09,420 --> 00:13:13,510
set of features that our SEO for kernel

00:13:12,270 --> 00:13:15,760
provides to us

00:13:13,510 --> 00:13:19,029
and we want to implement a system on top

00:13:15,760 --> 00:13:20,769
of it what is our application going to

00:13:19,029 --> 00:13:23,889
look like with just this in this case

00:13:20,769 --> 00:13:26,649
the first thing that executes with an

00:13:23,889 --> 00:13:30,220
SEO within an SEO for us the SEO for

00:13:26,649 --> 00:13:31,839
system is the initial thread what is

00:13:30,220 --> 00:13:34,440
going to be available to that first

00:13:31,839 --> 00:13:36,930
thread and as this thread the

00:13:34,440 --> 00:13:39,370
application the virtual address space

00:13:36,930 --> 00:13:40,660
regions are loaded into memory at the

00:13:39,370 --> 00:13:43,269
same time the kernel is by the boot

00:13:40,660 --> 00:13:45,339
loading process once the kernel has

00:13:43,269 --> 00:13:48,040
finished booting its constructed all of

00:13:45,339 --> 00:13:49,630
the objects kernel objects required to

00:13:48,040 --> 00:13:51,040
support a single thread running it's

00:13:49,630 --> 00:13:54,100
just going to jump straight to the entry

00:13:51,040 --> 00:13:56,050
point of that application and then it's

00:13:54,100 --> 00:13:57,970
going to provide an address to that

00:13:56,050 --> 00:14:00,820
application and an argument register

00:13:57,970 --> 00:14:02,320
that says this is the region in memory

00:14:00,820 --> 00:14:03,310
called the Buddha info region which just

00:14:02,320 --> 00:14:05,829
gives it a whole bunch of information

00:14:03,310 --> 00:14:09,370
about the configuration of the system in

00:14:05,829 --> 00:14:10,870
the cup and the kernel and then the

00:14:09,370 --> 00:14:12,490
initial thread is given capabilities to

00:14:10,870 --> 00:14:15,940
all of the resources in the system that

00:14:12,490 --> 00:14:18,630
are not used explicitly for the kernel

00:14:15,940 --> 00:14:20,620
this includes the current thread and

00:14:18,630 --> 00:14:24,180
capabilities to all of the resources

00:14:20,620 --> 00:14:26,110
that were required to construct it

00:14:24,180 --> 00:14:27,850
capabilities to objects needed to

00:14:26,110 --> 00:14:30,279
schedule new threads within the system

00:14:27,850 --> 00:14:34,899
to manage and create new virtual address

00:14:30,279 --> 00:14:36,279
spaces and the capabilities to all of

00:14:34,899 --> 00:14:39,970
the system memory and the device memory

00:14:36,279 --> 00:14:43,569
in the system and capabilities for

00:14:39,970 --> 00:14:45,819
performing i/o with devices so our C

00:14:43,569 --> 00:14:48,730
runtime for this initial thread on top

00:14:45,819 --> 00:14:50,769
of SEO for what is it able to provide to

00:14:48,730 --> 00:14:52,149
us what can we offload to this runtime

00:14:50,769 --> 00:14:55,149
so that we don't have to implement it in

00:14:52,149 --> 00:14:56,500
our application in this case SEO for is

00:14:55,149 --> 00:14:58,329
not abstracting over much Hardware

00:14:56,500 --> 00:15:01,720
beyond what the platform specifies the

00:14:58,329 --> 00:15:03,130
x86 64 platforms so we get process entry

00:15:01,720 --> 00:15:05,589
and exit that's well-defined for this

00:15:03,130 --> 00:15:07,720
initial thread we have dynamic memory

00:15:05,589 --> 00:15:09,430
management in fact if our runtime takes

00:15:07,720 --> 00:15:12,490
control over all of the memory pass to

00:15:09,430 --> 00:15:14,079
it and all of the capabilities pass to

00:15:12,490 --> 00:15:16,120
it it could manage a dynamic heap

00:15:14,079 --> 00:15:18,760
because it can modify the virtual

00:15:16,120 --> 00:15:20,290
address space of this initial thread it

00:15:18,760 --> 00:15:22,930
can provide multitasking by extracting

00:15:20,290 --> 00:15:24,160
over threading mechanisms in ser 4 it

00:15:22,930 --> 00:15:25,630
can use the memory provided to it to

00:15:24,160 --> 00:15:27,370
construct thread objects

00:15:25,630 --> 00:15:28,420
and to schedule those objects for us and

00:15:27,370 --> 00:15:31,030
so we can have things blocking

00:15:28,420 --> 00:15:33,550
independently we don't really have much

00:15:31,030 --> 00:15:35,230
of a user interface yet we don't have

00:15:33,550 --> 00:15:36,850
any mechanism with an SEO for to

00:15:35,230 --> 00:15:39,040
directly interact with the outside world

00:15:36,850 --> 00:15:41,020
in an abstract manner what we do have is

00:15:39,040 --> 00:15:42,970
just access to all of the devices and

00:15:41,020 --> 00:15:45,730
the ability to perform low-level i/o

00:15:42,970 --> 00:15:47,530
with them do not have any process

00:15:45,730 --> 00:15:48,790
management because we still don't have

00:15:47,530 --> 00:15:49,690
the concept of processes that's

00:15:48,790 --> 00:15:52,330
something we're going to need to

00:15:49,690 --> 00:15:55,120
construct ourselves we don't have a file

00:15:52,330 --> 00:15:56,560
system yet because there's nothing here

00:15:55,120 --> 00:15:59,080
to connect to a device or provide a

00:15:56,560 --> 00:16:01,240
virtual file system and likewise with

00:15:59,080 --> 00:16:03,520
networking so we're not doing too much

00:16:01,240 --> 00:16:05,080
better than what we had with an embedded

00:16:03,520 --> 00:16:07,540
environment as far as what we can

00:16:05,080 --> 00:16:11,230
offload it to a runtime but we will get

00:16:07,540 --> 00:16:12,790
there could we write a useful

00:16:11,230 --> 00:16:15,490
application just using runtime

00:16:12,790 --> 00:16:19,300
mechanisms on this initial thread not

00:16:15,490 --> 00:16:20,920
really the as we still don't have

00:16:19,300 --> 00:16:23,140
mechanisms to directly interact with the

00:16:20,920 --> 00:16:25,470
user or the outside world there's not a

00:16:23,140 --> 00:16:27,790
lot that we can offload to the runtime

00:16:25,470 --> 00:16:30,580
we have no mechanisms for creating or

00:16:27,790 --> 00:16:31,960
communicating with other processes we

00:16:30,580 --> 00:16:33,760
could potentially use the debugging

00:16:31,960 --> 00:16:37,360
configuration and SEO for which lets us

00:16:33,760 --> 00:16:40,750
print debug output to at least send a

00:16:37,360 --> 00:16:43,780
message to the user and we could in our

00:16:40,750 --> 00:16:47,200
runtime specify how file I will works

00:16:43,780 --> 00:16:50,680
and using our threads we could set up a

00:16:47,200 --> 00:16:52,450
thread using with a implementation of a

00:16:50,680 --> 00:16:55,510
serial driver and use that to be

00:16:52,450 --> 00:16:57,700
responsible communicating to the user

00:16:55,510 --> 00:16:59,230
and set up an interface that way but

00:16:57,700 --> 00:17:03,060
that still requires us to do a lot of

00:16:59,230 --> 00:17:05,530
work in our application ourselves to

00:17:03,060 --> 00:17:09,880
start having more of a friendly

00:17:05,530 --> 00:17:13,810
easy-to-use system so what we should do

00:17:09,880 --> 00:17:15,160
now is take this basis for a system and

00:17:13,810 --> 00:17:18,610
start building an operating system on

00:17:15,160 --> 00:17:19,810
top of it and so the first thing that

00:17:18,610 --> 00:17:22,180
we're going to have to do in our system

00:17:19,810 --> 00:17:24,010
is we're going to need to construct the

00:17:22,180 --> 00:17:26,890
minimal set of processes that's going to

00:17:24,010 --> 00:17:30,220
be required to allow us to write more

00:17:26,890 --> 00:17:31,570
general applications and we're going to

00:17:30,220 --> 00:17:33,190
use the initial thread to construct

00:17:31,570 --> 00:17:34,810
these components so one of the first

00:17:33,190 --> 00:17:37,030
things we might need is a serial server

00:17:34,810 --> 00:17:38,750
set up a dedicated process for managing

00:17:37,030 --> 00:17:39,830
the serial device and

00:17:38,750 --> 00:17:43,070
allow that to communicate with other

00:17:39,830 --> 00:17:44,540
processes to interact with the user we

00:17:43,070 --> 00:17:48,050
can set up a shared in memory file

00:17:44,540 --> 00:17:49,940
system we could have a preset selection

00:17:48,050 --> 00:17:52,160
of files built into that that gets

00:17:49,940 --> 00:17:54,200
loaded initially and we can now use that

00:17:52,160 --> 00:17:57,020
file system interface from any of our

00:17:54,200 --> 00:17:58,040
other processes we could set up a

00:17:57,020 --> 00:18:00,200
component that is going to be

00:17:58,040 --> 00:18:01,760
responsible for launching processes it

00:18:00,200 --> 00:18:04,550
has access to the file system and we can

00:18:01,760 --> 00:18:05,690
ask it on to set up a new process with

00:18:04,550 --> 00:18:08,630
its own virtual address base and

00:18:05,690 --> 00:18:09,710
threading on our behalf we would also

00:18:08,630 --> 00:18:11,450
probably want to set up a device

00:18:09,710 --> 00:18:12,920
initializer that is able to probe the

00:18:11,450 --> 00:18:16,100
hardware to find out what devices are

00:18:12,920 --> 00:18:18,980
there and go through our file system and

00:18:16,100 --> 00:18:22,480
initialize devices and subsystems using

00:18:18,980 --> 00:18:24,680
the applications it's stored there and

00:18:22,480 --> 00:18:26,680
once all this is done we are probably we

00:18:24,680 --> 00:18:29,860
tend to reuse this initial thread as a

00:18:26,680 --> 00:18:32,240
memory management service as it has the

00:18:29,860 --> 00:18:34,010
authority over all of the remaining

00:18:32,240 --> 00:18:36,110
memory in the system will make it

00:18:34,010 --> 00:18:38,350
responsible for managing the virtual

00:18:36,110 --> 00:18:41,750
address spaces of all of the processes

00:18:38,350 --> 00:18:43,730
for managing the creation of kernel

00:18:41,750 --> 00:18:46,390
objects for the processes and for

00:18:43,730 --> 00:18:48,710
performing large IPC operations between

00:18:46,390 --> 00:18:50,300
different applications for anything that

00:18:48,710 --> 00:18:51,560
needs a large buffer of memory to be

00:18:50,300 --> 00:18:55,490
copied between applications for

00:18:51,560 --> 00:18:58,190
communication so once we have this

00:18:55,490 --> 00:19:01,340
initial OS what are we now able to in

00:18:58,190 --> 00:19:04,220
our runtime offload to this operating

00:19:01,340 --> 00:19:07,070
system well it now has abstraction over

00:19:04,220 --> 00:19:10,040
tty it can handle interaction with the

00:19:07,070 --> 00:19:12,380
user directly we have process entry and

00:19:10,040 --> 00:19:15,320
exit we have dynamic memory management

00:19:12,380 --> 00:19:17,120
from before we have multitasking but

00:19:15,320 --> 00:19:19,250
before but in the case of these two

00:19:17,120 --> 00:19:20,720
these are now offloaded entirely there

00:19:19,250 --> 00:19:22,430
is another process that's able to set up

00:19:20,720 --> 00:19:25,310
threads for us there's another service

00:19:22,430 --> 00:19:28,010
that is able to manage our heap

00:19:25,310 --> 00:19:29,810
dynamically for us we can now interact

00:19:28,010 --> 00:19:31,310
directly with the user we've only have

00:19:29,810 --> 00:19:33,860
one application that's able to do this

00:19:31,310 --> 00:19:35,390
but it can communicate with the serial

00:19:33,860 --> 00:19:38,600
server directly we can get standard in

00:19:35,390 --> 00:19:40,400
and standard out we have the ability to

00:19:38,600 --> 00:19:42,530
create new processes from our file

00:19:40,400 --> 00:19:44,930
system we can specify to the process

00:19:42,530 --> 00:19:47,360
launcher go and start this process go

00:19:44,930 --> 00:19:50,179
and find bash and set it up and give it

00:19:47,360 --> 00:19:51,840
access to the user interface we still

00:19:50,179 --> 00:19:53,910
don't have networking

00:19:51,840 --> 00:19:55,080
or a full sail system based on a hard

00:19:53,910 --> 00:19:58,410
disk because we haven't loaded the

00:19:55,080 --> 00:20:00,870
drivers flows yet and so how do we move

00:19:58,410 --> 00:20:02,700
from this point to having a full

00:20:00,870 --> 00:20:06,090
operating system well the benefit of

00:20:02,700 --> 00:20:08,730
this is we now have most of everything

00:20:06,090 --> 00:20:11,130
we need to write applications in a

00:20:08,730 --> 00:20:12,420
portable language without having to do a

00:20:11,130 --> 00:20:13,980
lot of hard work ourselves

00:20:12,420 --> 00:20:15,930
so most of the applications we start

00:20:13,980 --> 00:20:17,880
from this point can be written as normal

00:20:15,930 --> 00:20:21,360
user that report user level programs

00:20:17,880 --> 00:20:24,390
even if they're providing low-level

00:20:21,360 --> 00:20:25,740
system services and so the next few

00:20:24,390 --> 00:20:27,900
components we can start can be easily

00:20:25,740 --> 00:20:30,330
implemented a bit easier some of them

00:20:27,900 --> 00:20:31,830
such as device drivers might need more

00:20:30,330 --> 00:20:34,550
implement their information and use

00:20:31,830 --> 00:20:36,630
low-level interfaces with the hardware

00:20:34,550 --> 00:20:38,550
about our device initializer is now

00:20:36,630 --> 00:20:39,870
going to start probing for devices it's

00:20:38,550 --> 00:20:41,970
going to start loading the drivers from

00:20:39,870 --> 00:20:44,010
the file system as it loads more devices

00:20:41,970 --> 00:20:45,630
it might find hard disks on those hard

00:20:44,010 --> 00:20:48,120
disks it'll find even more drivers and

00:20:45,630 --> 00:20:50,580
more components that it can set up it'll

00:20:48,120 --> 00:20:52,380
start you filesystem servers and our

00:20:50,580 --> 00:20:55,140
system is rapidly going to finish

00:20:52,380 --> 00:20:57,270
booting and we'll start getting other OS

00:20:55,140 --> 00:20:59,520
subsystems will get configuration will

00:20:57,270 --> 00:21:01,980
be upload configuration files from file

00:20:59,520 --> 00:21:04,350
systems we were able to connect audio

00:21:01,980 --> 00:21:05,940
devices and start making sounds get

00:21:04,350 --> 00:21:07,770
graphics subsystems working we can have

00:21:05,940 --> 00:21:09,330
a graphical user interface you have

00:21:07,770 --> 00:21:11,340
networking subsystems now we can now

00:21:09,330 --> 00:21:13,560
communicate with other computers on the

00:21:11,340 --> 00:21:15,180
network we can start doing human

00:21:13,560 --> 00:21:17,810
interface if we want to set up an actual

00:21:15,180 --> 00:21:21,540
graphical user interface we can do that

00:21:17,810 --> 00:21:23,850
USB etc we now have basically an entire

00:21:21,540 --> 00:21:26,160
operating system under our feet the next

00:21:23,850 --> 00:21:27,810
question is how do we take all of these

00:21:26,160 --> 00:21:31,170
disparate components and provide them to

00:21:27,810 --> 00:21:32,810
user applications henceforth the concept

00:21:31,170 --> 00:21:35,160
I'd like to introduce now is that of OS

00:21:32,810 --> 00:21:37,440
personalities it's not by any means a

00:21:35,160 --> 00:21:39,840
new concept the example I'd like to give

00:21:37,440 --> 00:21:42,720
comes from this mechanism from the

00:21:39,840 --> 00:21:44,280
Digital Equipment Corporation they

00:21:42,720 --> 00:21:47,010
developed a system on top of the mach

00:21:44,280 --> 00:21:49,380
kernel back in the early 90s what this

00:21:47,010 --> 00:21:51,450
system would do as much like our system

00:21:49,380 --> 00:21:53,430
it would have a set of common low-level

00:21:51,450 --> 00:21:55,320
resource and service processes which

00:21:53,430 --> 00:21:57,360
were accessible to any application that

00:21:55,320 --> 00:21:58,470
started in the system what they would

00:21:57,360 --> 00:22:00,330
then do is they would start up a

00:21:58,470 --> 00:22:01,770
personality server which would

00:22:00,330 --> 00:22:03,990
communicate with these resources and

00:22:01,770 --> 00:22:05,280
provide a single unified interface to

00:22:03,990 --> 00:22:06,840
applications that you

00:22:05,280 --> 00:22:09,180
level applications that started on that

00:22:06,840 --> 00:22:12,420
operating system now initially they set

00:22:09,180 --> 00:22:14,640
up a personality server that presented

00:22:12,420 --> 00:22:16,530
the interface of the old VMs server they

00:22:14,640 --> 00:22:18,470
were trying to emulate at the time but

00:22:16,530 --> 00:22:21,060
they found that they could also provide

00:22:18,470 --> 00:22:23,850
personality services servers that

00:22:21,060 --> 00:22:25,440
presented interfaces of different

00:22:23,850 --> 00:22:27,810
operating systems they had one that

00:22:25,440 --> 00:22:29,340
presented the interface of ms-dos and

00:22:27,810 --> 00:22:31,710
one that presented a UNIX compliant

00:22:29,340 --> 00:22:33,390
interface and what you could do given

00:22:31,710 --> 00:22:35,790
that all of these personality servers

00:22:33,390 --> 00:22:37,290
we're using the same resources and the

00:22:35,790 --> 00:22:38,670
backend was that they could all

00:22:37,290 --> 00:22:41,250
communicate with each other you could

00:22:38,670 --> 00:22:43,950
open your shell call into an ms-dos

00:22:41,250 --> 00:22:46,560
program pipe its output to a VMs program

00:22:43,950 --> 00:22:48,840
and format that using columns a UNIX

00:22:46,560 --> 00:22:51,080
program they would all happily

00:22:48,840 --> 00:22:53,130
communicate with each other

00:22:51,080 --> 00:22:55,470
window is actually currently uses a

00:22:53,130 --> 00:22:57,420
similar model presently evolved multiple

00:22:55,470 --> 00:23:00,060
personalities but rather than having

00:22:57,420 --> 00:23:01,830
personalities implemented as servers ud

00:23:00,060 --> 00:23:04,170
library that is linked into an

00:23:01,830 --> 00:23:05,610
application as it runs determines which

00:23:04,170 --> 00:23:07,400
personality is going to interact with

00:23:05,610 --> 00:23:10,830
they primarily use this to give a

00:23:07,400 --> 00:23:12,570
limited set of features two components

00:23:10,830 --> 00:23:14,370
started early in the system which are

00:23:12,570 --> 00:23:15,870
they need minimal resources minimal

00:23:14,370 --> 00:23:18,840
other service to communicate with and

00:23:15,870 --> 00:23:20,460
then more complete processes in the

00:23:18,840 --> 00:23:22,860
system communicate with everything that

00:23:20,460 --> 00:23:24,960
exists at that point they've also used

00:23:22,860 --> 00:23:28,550
this in the past to provide support for

00:23:24,960 --> 00:23:31,680
UNIX and other interfaces over the years

00:23:28,550 --> 00:23:34,200
so we may want to have this similar

00:23:31,680 --> 00:23:36,210
personality model we may wrap all of our

00:23:34,200 --> 00:23:38,190
interfaces all of our components into a

00:23:36,210 --> 00:23:41,550
single personality and provide that as a

00:23:38,190 --> 00:23:43,590
personality service for applications we

00:23:41,550 --> 00:23:45,600
abstract all of the services we now have

00:23:43,590 --> 00:23:47,580
a single unit interface that all of our

00:23:45,600 --> 00:23:49,860
applications are programmed to and in

00:23:47,580 --> 00:23:51,240
the case of any duplicated systems we

00:23:49,860 --> 00:23:53,390
might have started we may have multiple

00:23:51,240 --> 00:23:55,700
file systems multiple network interfaces

00:23:53,390 --> 00:23:58,170
we may at this point decide to

00:23:55,700 --> 00:24:02,070
virtualized and unify them so that they

00:23:58,170 --> 00:24:04,350
are more accessible for our runtime and

00:24:02,070 --> 00:24:07,650
so what user applications can we now run

00:24:04,350 --> 00:24:08,970
on our operating system well if we

00:24:07,650 --> 00:24:10,230
wanted to build a C runtime that

00:24:08,970 --> 00:24:12,690
offloaded is much work to our

00:24:10,230 --> 00:24:15,210
personality as possible we could do

00:24:12,690 --> 00:24:16,830
basically everything our operating

00:24:15,210 --> 00:24:18,130
system abstract over the entire system

00:24:16,830 --> 00:24:24,700
at this point

00:24:18,130 --> 00:24:26,770
that's his rust never mind but it can

00:24:24,700 --> 00:24:28,179
run we can now do process entry and exit

00:24:26,770 --> 00:24:30,340
as we could before dynamic memory

00:24:28,179 --> 00:24:32,710
management and multitasking as we could

00:24:30,340 --> 00:24:34,299
with a more limited operating system we

00:24:32,710 --> 00:24:36,370
have a standard user interface this

00:24:34,299 --> 00:24:38,500
might be - a serial device it might be

00:24:36,370 --> 00:24:42,400
to a virtual Tillie typewriter to a

00:24:38,500 --> 00:24:44,260
graphical terminal we might have we now

00:24:42,400 --> 00:24:46,140
have process management we can just run

00:24:44,260 --> 00:24:48,940
processes that exist in our file system

00:24:46,140 --> 00:24:52,990
which now includes all of our Hardware

00:24:48,940 --> 00:24:55,659
devices we can now start networking open

00:24:52,990 --> 00:24:58,480
sockets for networking communication so

00:24:55,659 --> 00:25:01,299
what we can do is if we implement a rust

00:24:58,480 --> 00:25:03,549
runtime and the standard library and

00:25:01,299 --> 00:25:06,549
targeted at our operating system

00:25:03,549 --> 00:25:08,070
personality is we can just take the code

00:25:06,549 --> 00:25:10,960
that we wrote before for our file server

00:25:08,070 --> 00:25:12,880
compile it using our implementation of

00:25:10,960 --> 00:25:15,250
the runtime and it will execute on our

00:25:12,880 --> 00:25:21,280
operating system just as it would on any

00:25:15,250 --> 00:25:23,110
other major OS but we may find at this

00:25:21,280 --> 00:25:24,850
point that we overlooked some

00:25:23,110 --> 00:25:27,220
assumptions made by the run the rust

00:25:24,850 --> 00:25:29,380
runtime or by the C runtime depending on

00:25:27,220 --> 00:25:31,179
what language we are implementing a few

00:25:29,380 --> 00:25:33,100
things that it might assume is that

00:25:31,179 --> 00:25:35,169
there is a single file system or a

00:25:33,100 --> 00:25:38,559
single service which is required to

00:25:35,169 --> 00:25:40,710
translate a string path into any file we

00:25:38,559 --> 00:25:43,570
may have access to and if we have

00:25:40,710 --> 00:25:47,169
distinct file systems the runtime may

00:25:43,570 --> 00:25:48,820
not work with that well it may make

00:25:47,169 --> 00:25:51,130
assumptions about how we interpret paths

00:25:48,820 --> 00:25:53,789
if we have weird semantics for path

00:25:51,130 --> 00:25:56,049
interpretation it may require some

00:25:53,789 --> 00:25:58,360
coaxing to get it to understand the

00:25:56,049 --> 00:26:01,870
particular requirements we have for

00:25:58,360 --> 00:26:04,780
paths or operating strings and operating

00:26:01,870 --> 00:26:06,429
system strings in general if we are

00:26:04,780 --> 00:26:09,070
using C for example it might assume that

00:26:06,429 --> 00:26:11,500
we have its understanding of strings

00:26:09,070 --> 00:26:16,090
rather than may be wide strings or more

00:26:11,500 --> 00:26:17,530
complex representations we might have

00:26:16,090 --> 00:26:19,450
the assumption of a single or a primary

00:26:17,530 --> 00:26:21,159
network interface that is internet

00:26:19,450 --> 00:26:22,210
connected or we might assume that it

00:26:21,159 --> 00:26:23,650
doesn't matter which of the network

00:26:22,210 --> 00:26:24,940
interfaces are available we're going to

00:26:23,650 --> 00:26:26,440
be able to connect to anything every way

00:26:24,940 --> 00:26:29,290
so the runtime may not give us

00:26:26,440 --> 00:26:31,419
mechanisms to select which interface

00:26:29,290 --> 00:26:34,929
we're going to connect via

00:26:31,419 --> 00:26:36,549
this might need to be resolved it might

00:26:34,929 --> 00:26:39,940
have assumptions about how processes are

00:26:36,549 --> 00:26:41,559
created if it may assume that we're

00:26:39,940 --> 00:26:43,599
going to start processes by giving them

00:26:41,559 --> 00:26:46,059
particularly formatted strings in a

00:26:43,599 --> 00:26:47,499
particular fashion we're going to pass

00:26:46,059 --> 00:26:49,450
additional argument and environment

00:26:47,499 --> 00:26:51,249
variables of strings and once the

00:26:49,450 --> 00:26:52,690
process is created we get pipes for

00:26:51,249 --> 00:26:54,879
standard in stand it out in the standard

00:26:52,690 --> 00:26:59,320
error and this is a pretty general

00:26:54,879 --> 00:27:01,389
assumption and if that's not how we have

00:26:59,320 --> 00:27:03,190
implemented processes that's not how

00:27:01,389 --> 00:27:05,320
processes start for our system it's

00:27:03,190 --> 00:27:08,079
going to be hard to get this portable

00:27:05,320 --> 00:27:09,579
runtime to agree with our system so this

00:27:08,079 --> 00:27:11,950
is stuff that could be an issue when

00:27:09,579 --> 00:27:13,419
deciding on what your OS personality is

00:27:11,950 --> 00:27:15,579
when deciding what your language

00:27:13,419 --> 00:27:17,499
portable language runtime is going to

00:27:15,579 --> 00:27:19,539
provide as an interface or when you're

00:27:17,499 --> 00:27:24,729
just implementing the runtime that

00:27:19,539 --> 00:27:25,809
matches the to my final notes here are

00:27:24,729 --> 00:27:27,940
some of the work I've done with

00:27:25,809 --> 00:27:29,169
trustworthy system at runtime George got

00:27:27,940 --> 00:27:34,029
me thinking about all of this in the

00:27:29,169 --> 00:27:36,279
first place I implemented a thing called

00:27:34,029 --> 00:27:38,979
the SEO for runtime to solve a few

00:27:36,279 --> 00:27:41,349
problems we were having with supporting

00:27:38,979 --> 00:27:42,369
all of the platforms that we do it's a

00:27:41,349 --> 00:27:44,499
non standard C runtime

00:27:42,369 --> 00:27:46,269
it's very incremental progress over what

00:27:44,499 --> 00:27:47,979
we had previously it doesn't implement

00:27:46,269 --> 00:27:49,570
much it just implements enough for us to

00:27:47,979 --> 00:27:51,969
do everything that we need to do on a

00:27:49,570 --> 00:27:53,709
day to day basis it was primarily

00:27:51,969 --> 00:27:56,320
targeting applications that were running

00:27:53,709 --> 00:27:58,599
on SCR for without the assumption of any

00:27:56,320 --> 00:28:00,339
sort of underlying operating system or

00:27:58,599 --> 00:28:02,229
standard interface with an underlying

00:28:00,339 --> 00:28:04,479
operating system this even meant that

00:28:02,229 --> 00:28:05,979
it's not necessarily targeted at a root

00:28:04,479 --> 00:28:07,599
server where we can assume we have all

00:28:05,979 --> 00:28:11,349
of these resources provided to us at

00:28:07,599 --> 00:28:13,389
startup but it's enough to let us use to

00:28:11,349 --> 00:28:16,029
let us build and run all of the systems

00:28:13,389 --> 00:28:18,669
that we do at trustworthy systems on all

00:28:16,029 --> 00:28:20,379
of the platforms that we support and it

00:28:18,669 --> 00:28:22,359
could be the basis for further runtime

00:28:20,379 --> 00:28:25,599
development as we have more complete

00:28:22,359 --> 00:28:27,940
systems to write interfaces to its

00:28:25,599 --> 00:28:30,159
current features very minimal it

00:28:27,940 --> 00:28:33,669
provides process entry so we can start a

00:28:30,159 --> 00:28:36,190
process if you have constructors dynamic

00:28:33,669 --> 00:28:38,950
initializes in your libraries it will

00:28:36,190 --> 00:28:39,999
run those for you and if you're running

00:28:38,950 --> 00:28:42,039
multiple threads in the same application

00:28:39,999 --> 00:28:44,499
it will initialize thread-local storage

00:28:42,039 --> 00:28:44,950
for your first thread and any subsequent

00:28:44,499 --> 00:28:47,080
threads

00:28:44,950 --> 00:28:50,139
provides mechanisms for your thread

00:28:47,080 --> 00:28:53,799
creation libraries to initialize TLS

00:28:50,139 --> 00:28:56,440
there hopefully at the end of all of

00:28:53,799 --> 00:28:58,419
this you may have a better understanding

00:28:56,440 --> 00:29:02,889
of how the concept of write once run

00:28:58,419 --> 00:29:05,080
everywhere is possible in many cases how

00:29:02,889 --> 00:29:07,059
it relies a lot on the build process and

00:29:05,080 --> 00:29:09,669
primarily operating system to provide

00:29:07,059 --> 00:29:12,309
features to your application

00:29:09,669 --> 00:29:13,659
but how if you make big changes in your

00:29:12,309 --> 00:29:16,559
operating system or your operating

00:29:13,659 --> 00:29:18,460
system doesn't provide features your

00:29:16,559 --> 00:29:21,510
programming language may not necessarily

00:29:18,460 --> 00:29:24,490
be as portable as it advertises itself

00:29:21,510 --> 00:29:35,610
any questions and what little time

00:29:24,490 --> 00:29:35,610
remains do we have any questions

00:29:39,200 --> 00:29:45,720
that's a no then thanks

00:29:41,600 --> 00:29:45,720

YouTube URL: https://www.youtube.com/watch?v=4Ss1Y5bzuAU


