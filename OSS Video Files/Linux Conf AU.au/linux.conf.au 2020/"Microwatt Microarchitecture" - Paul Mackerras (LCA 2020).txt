Title: "Microwatt Microarchitecture" - Paul Mackerras (LCA 2020)
Publication date: 2020-01-14
Playlist: linux.conf.au 2020
Description: 
	Paul Mackerras

https://lca2020.linux.org.au/schedule/presentation/149/

Microwatt is a new open-source soft-core implementation of the Power ISA written in VHDL. It has been developed from scratch in the last six months by Anton Blanchard and others, initially to provide an example implementation to accompany the announcement by IBM last August that it was opening the Power ISA. This talk will examine the microarchitecture of the Microwatt core in some detail and discuss how implementation choices were affected by the specific details of the Power ISA.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Mon Jan 13 14:10:00 2020 at Room 7
Captions: 
	00:00:04,240 --> 00:00:13,870
and would you join me in welcoming Paul

00:00:05,890 --> 00:00:16,540
McCurry's hi I'm going to talk this

00:00:13,870 --> 00:00:19,680
afternoon about some more details some

00:00:16,540 --> 00:00:22,060
low-level details of how microwatt works

00:00:19,680 --> 00:00:24,279
in the hope that some of you might find

00:00:22,060 --> 00:00:25,750
this all interesting enough and feel

00:00:24,279 --> 00:00:27,640
that this is an introduction that lets

00:00:25,750 --> 00:00:32,710
you get into it and actually start

00:00:27,640 --> 00:00:36,850
hacking on it so Anton's talked about a

00:00:32,710 --> 00:00:38,920
lot of this already started as a demo or

00:00:36,850 --> 00:00:41,530
proof of concept for the announcement of

00:00:38,920 --> 00:00:45,789
the power instruction set architecture

00:00:41,530 --> 00:00:47,890
being made open last August so Anton

00:00:45,789 --> 00:00:52,420
actually pretty much single-handedly I

00:00:47,890 --> 00:00:53,949
think put this together as the proof of

00:00:52,420 --> 00:00:57,399
concept that actually worked actually

00:00:53,949 --> 00:01:00,159
executed basically the entire integer

00:00:57,399 --> 00:01:02,469
user space instruction set of part of

00:01:00,159 --> 00:01:05,199
the instruction set architecture I'm

00:01:02,469 --> 00:01:06,790
still quite incomplete there's still a

00:01:05,199 --> 00:01:09,070
lot to be done

00:01:06,790 --> 00:01:12,250
but the thing is that it's currently I

00:01:09,070 --> 00:01:15,220
think under 10,000 lines of VHDL so

00:01:12,250 --> 00:01:17,649
10,000 lines is a size I mean like the

00:01:15,220 --> 00:01:19,750
original UNIX version 6 was 10,000 lines

00:01:17,649 --> 00:01:22,479
and that was a size that could be taught

00:01:19,750 --> 00:01:24,310
in a course and someone could read

00:01:22,479 --> 00:01:27,009
through it and actually understand

00:01:24,310 --> 00:01:29,110
everything that was going on so it's not

00:01:27,009 --> 00:01:31,270
this enormous pile of stuff that you can

00:01:29,110 --> 00:01:33,579
never get into it's something that a

00:01:31,270 --> 00:01:35,799
good person can recently expect to

00:01:33,579 --> 00:01:39,670
actually understand everything every

00:01:35,799 --> 00:01:43,509
part of it as Anton said it's all open

00:01:39,670 --> 00:01:47,859
source hosted on github and uses the

00:01:43,509 --> 00:01:49,630
github methodology of pull requests so

00:01:47,859 --> 00:01:52,149
that you know you have a clone of the

00:01:49,630 --> 00:01:54,159
repository on github and you do you make

00:01:52,149 --> 00:01:56,259
you clone you push your changes to your

00:01:54,159 --> 00:01:59,590
clone and then you do a pull request for

00:01:56,259 --> 00:02:03,070
Anton and he and his wisdom decides to

00:01:59,590 --> 00:02:08,170
pull or not as he said we're mostly

00:02:03,070 --> 00:02:09,840
targeting simulation and FPGAs and we're

00:02:08,170 --> 00:02:13,240
using wishbone for the memory interface

00:02:09,840 --> 00:02:15,160
wishbone is a kind of thing that's out

00:02:13,240 --> 00:02:18,040
there that is pretty simple it's just

00:02:15,160 --> 00:02:20,079
based on using multiplexers rather than

00:02:18,040 --> 00:02:24,579
a tri-state bus look we might have used

00:02:20,079 --> 00:02:28,379
in the old days I'll just talk briefly

00:02:24,579 --> 00:02:32,290
about what's the power I say is like

00:02:28,379 --> 00:02:35,500
it's a 64-bit RISC architecture risk in

00:02:32,290 --> 00:02:39,730
the sense that it has fixed length

00:02:35,500 --> 00:02:42,069
instructions of 32 bits and the only

00:02:39,730 --> 00:02:43,840
instructions that access memory are the

00:02:42,069 --> 00:02:47,680
load and store instructions so there's

00:02:43,840 --> 00:02:48,849
no like add two values and store the

00:02:47,680 --> 00:02:52,569
result in memory and one instruction

00:02:48,849 --> 00:02:55,480
like you would get on x86 or a system

00:02:52,569 --> 00:02:58,329
390 or 68,000 or those kind of

00:02:55,480 --> 00:03:01,359
architectures it's not reduced

00:02:58,329 --> 00:03:03,790
I mean people sometimes say reduced

00:03:01,359 --> 00:03:05,379
instruction set computing therefore it

00:03:03,790 --> 00:03:06,579
must be a small instruction set that's

00:03:05,379 --> 00:03:09,970
not that at all it's not a particularly

00:03:06,579 --> 00:03:13,859
small instruction set we do have lots of

00:03:09,970 --> 00:03:18,579
registers in the architecture there's 32

00:03:13,859 --> 00:03:22,859
general-purpose registers 64 bit sorry

00:03:18,579 --> 00:03:25,889
64 128 bit the vector scalar registers

00:03:22,859 --> 00:03:28,269
this is kind of a unification of the

00:03:25,889 --> 00:03:31,239
floating-point registers and the vector

00:03:28,269 --> 00:03:33,099
registers which we used to have we used

00:03:31,239 --> 00:03:36,549
to have 32 64 bit floating point

00:03:33,099 --> 00:03:39,519
registers and 32 128 bit victory

00:03:36,549 --> 00:03:42,430
boosters and then in power six power

00:03:39,519 --> 00:03:44,919
seven time frame they the architects

00:03:42,430 --> 00:03:46,629
added another 32 by 64 bit block and

00:03:44,919 --> 00:03:49,199
then said okay this makes a rectangle

00:03:46,629 --> 00:03:51,340
which is our vector scalar registers

00:03:49,199 --> 00:03:55,569
then there are the special purpose

00:03:51,340 --> 00:03:58,060
registers there's a 10 bit space so up

00:03:55,569 --> 00:04:00,849
to 1024 but not all that not all the

00:03:58,060 --> 00:04:04,540
space is occupied the important ones for

00:04:00,849 --> 00:04:07,060
user space code the link register used

00:04:04,540 --> 00:04:10,229
for procedure calls the count register

00:04:07,060 --> 00:04:13,239
which is used for indirect calls and for

00:04:10,229 --> 00:04:15,250
decrement and branch type loops and the

00:04:13,239 --> 00:04:18,039
integer exception register which has got

00:04:15,250 --> 00:04:20,889
some carry and overflow type bits in it

00:04:18,039 --> 00:04:22,570
and then separately there's this 32 bit

00:04:20,889 --> 00:04:24,430
condition register which stores the

00:04:22,570 --> 00:04:26,740
normal sorts of condition codes that you

00:04:24,430 --> 00:04:28,630
might expect except we've got eight sets

00:04:26,740 --> 00:04:31,120
so there are eight sets of condition

00:04:28,630 --> 00:04:31,409
codes that you can set with compare and

00:04:31,120 --> 00:04:35,849
stroke

00:04:31,409 --> 00:04:37,259
and then you can do you know operations

00:04:35,849 --> 00:04:39,539
between them and you can do branches

00:04:37,259 --> 00:04:42,059
based on that and there's the machine

00:04:39,539 --> 00:04:46,649
status register which stores things like

00:04:42,059 --> 00:04:48,629
privilege flags so that is one that we

00:04:46,649 --> 00:04:50,669
haven't implemented yet but if we want

00:04:48,629 --> 00:04:52,709
to do a supervisor mode then we need an

00:04:50,669 --> 00:04:54,059
MSR because it's got the bid in it that

00:04:52,709 --> 00:04:59,099
says whether your supervisor or a user

00:04:54,059 --> 00:05:02,339
mode our instructions have between zero

00:04:59,099 --> 00:05:04,889
and three register operands so an

00:05:02,339 --> 00:05:06,509
example of a zero instruction a zero

00:05:04,889 --> 00:05:09,029
operand instruction might be the

00:05:06,509 --> 00:05:12,659
synchronized instruction which is a

00:05:09,029 --> 00:05:14,429
memory barrier and essentially tells the

00:05:12,659 --> 00:05:16,469
CPU to stop and wait for all the

00:05:14,429 --> 00:05:20,339
previous instructions to finish before

00:05:16,469 --> 00:05:24,689
it goes on with the next thing one with

00:05:20,339 --> 00:05:27,449
three operands could be for instance a

00:05:24,689 --> 00:05:29,519
store with index mode addressing so

00:05:27,449 --> 00:05:31,199
you've got one register that gives you

00:05:29,519 --> 00:05:33,629
the data to be stored in two registers

00:05:31,199 --> 00:05:37,229
which get added together to give you the

00:05:33,629 --> 00:05:39,449
address to store two and we have two

00:05:37,229 --> 00:05:42,959
addressing modes register plus constant

00:05:39,449 --> 00:05:44,550
and register plus register the constant

00:05:42,959 --> 00:05:47,189
in the first mode comes from the

00:05:44,550 --> 00:05:54,599
instruction it's it's a 16-bit field in

00:05:47,189 --> 00:05:57,119
the instruction ok so then just looking

00:05:54,599 --> 00:05:59,360
at the overall structure of the pipeline

00:05:57,119 --> 00:06:04,079
this is similar to the diagram that

00:05:59,360 --> 00:06:06,749
Anton put up before fairly

00:06:04,079 --> 00:06:10,529
straightforward pipeline we have fetch

00:06:06,749 --> 00:06:12,659
one the I cache so then fetch one

00:06:10,529 --> 00:06:14,929
generates an address the I cache gets

00:06:12,659 --> 00:06:18,360
the instruction and passes that down

00:06:14,929 --> 00:06:22,019
decode one and decode to work out what

00:06:18,360 --> 00:06:23,969
the instruction is doing decode to read

00:06:22,019 --> 00:06:26,429
stuff from the register files and passes

00:06:23,969 --> 00:06:30,509
that down to either load store one or

00:06:26,429 --> 00:06:33,239
execute antwon's diagram had multiply

00:06:30,509 --> 00:06:35,339
and divide sort of parallel to execute

00:06:33,239 --> 00:06:38,579
but we've actually kind of moved them in

00:06:35,339 --> 00:06:39,880
inside execute or at least we have in my

00:06:38,579 --> 00:06:44,690
branch

00:06:39,880 --> 00:06:46,960
Evon most yet but that that's the plan

00:06:44,690 --> 00:06:49,190
load/store one goes down to the D cache

00:06:46,960 --> 00:06:51,590
you end up getting a result which goes

00:06:49,190 --> 00:06:52,910
back to right back which goes back into

00:06:51,590 --> 00:06:56,389
the register file and the condition

00:06:52,910 --> 00:06:58,400
register file right back sends the

00:06:56,389 --> 00:07:00,770
signal back to decode two to say that

00:06:58,400 --> 00:07:02,389
we're complete because it can take a

00:07:00,770 --> 00:07:06,740
variable and recycles to get through

00:07:02,389 --> 00:07:09,889
executable load store then I've drawn

00:07:06,740 --> 00:07:12,020
lines in blue which a stall that means

00:07:09,889 --> 00:07:13,909
that a pipeline stage can't do what it

00:07:12,020 --> 00:07:16,400
needs to do in this cycle and it needs

00:07:13,909 --> 00:07:19,330
the previous stage to to stop and not

00:07:16,400 --> 00:07:22,190
give it anything new so it can continue

00:07:19,330 --> 00:07:24,710
these stages are each effectively one

00:07:22,190 --> 00:07:26,509
clock cycle you can think of a thing

00:07:24,710 --> 00:07:29,180
moving you know an instruction moving

00:07:26,509 --> 00:07:31,460
down one step on each clock cycle in

00:07:29,180 --> 00:07:33,970
general although in some cases things

00:07:31,460 --> 00:07:36,440
take more than one clock cycle and

00:07:33,970 --> 00:07:39,740
there's a flush line that I've drawn in

00:07:36,440 --> 00:07:43,280
red and what that is is when a branch

00:07:39,740 --> 00:07:45,710
gets to execute one we use this pathway

00:07:43,280 --> 00:07:48,229
from execute one back to fetch one to

00:07:45,710 --> 00:07:50,990
send the into the the new address that

00:07:48,229 --> 00:07:52,820
we need to branch to and at the same

00:07:50,990 --> 00:07:55,180
time we send out this flush signal to

00:07:52,820 --> 00:07:57,860
tell the earlier stages of the pipeline

00:07:55,180 --> 00:07:58,849
forget what you're doing it's it's you

00:07:57,860 --> 00:08:01,250
know we're not executing that

00:07:58,849 --> 00:08:03,800
instruction because it comes after a

00:08:01,250 --> 00:08:06,590
branch that we're taking so just forget

00:08:03,800 --> 00:08:09,080
what you're doing and then that address

00:08:06,590 --> 00:08:10,759
goes up to fetch one and then we started

00:08:09,080 --> 00:08:15,830
fetching from that branch target

00:08:10,759 --> 00:08:18,250
instruction so that's it's pretty

00:08:15,830 --> 00:08:21,650
straightforward the the stall signal

00:08:18,250 --> 00:08:24,259
tends to be a combinatorial signal in

00:08:21,650 --> 00:08:26,539
that when you get a stall that executes

00:08:24,259 --> 00:08:30,050
one that's got a propagate all the way

00:08:26,539 --> 00:08:33,589
back to all the way back up to fetch one

00:08:30,050 --> 00:08:36,050
to say stop everything at least pause

00:08:33,589 --> 00:08:38,750
everything for a cycle because you know

00:08:36,050 --> 00:08:40,279
I can't take anything new next cycle so

00:08:38,750 --> 00:08:43,329
you better not give me anything new so

00:08:40,279 --> 00:08:47,450
that goes back up the pipeline to say

00:08:43,329 --> 00:08:50,770
pause for a cycle until you know we

00:08:47,450 --> 00:08:50,770
unblocked things down lower

00:08:52,020 --> 00:08:57,120
so that's that's a kind of view from how

00:08:55,200 --> 00:08:59,310
instructions propagate through the

00:08:57,120 --> 00:09:02,370
system it's also interesting to look at

00:08:59,310 --> 00:09:06,029
this from the point of view of data and

00:09:02,370 --> 00:09:07,890
how that propagates through it so what

00:09:06,029 --> 00:09:13,200
we have here is at the top left we've

00:09:07,890 --> 00:09:16,860
got our register file that's a four

00:09:13,200 --> 00:09:19,290
ported RAM so it's got three Reed ports

00:09:16,860 --> 00:09:20,610
that read asynchronously in other words

00:09:19,290 --> 00:09:22,890
you just put the address and you get the

00:09:20,610 --> 00:09:25,350
data in the same cycle and one

00:09:22,890 --> 00:09:27,720
synchronous right port in other words

00:09:25,350 --> 00:09:29,430
you give it the address and the data and

00:09:27,720 --> 00:09:34,290
then on the next clock edge it actually

00:09:29,430 --> 00:09:36,240
does the ride so that's fairly wide in

00:09:34,290 --> 00:09:41,010
if PGA's it tends to be implemented as

00:09:36,240 --> 00:09:42,510
what they call luck Ram we generally

00:09:41,010 --> 00:09:45,209
don't have to worry about that we just

00:09:42,510 --> 00:09:48,300
sort of say what we want and the

00:09:45,209 --> 00:09:51,140
synthesis tools work it out but I

00:09:48,300 --> 00:09:54,149
believe in the Xilinx one it turns into

00:09:51,140 --> 00:09:58,140
using the lots as as the storage for

00:09:54,149 --> 00:10:01,170
this so we have our three register

00:09:58,140 --> 00:10:04,670
operands which are indexed by these are

00:10:01,170 --> 00:10:07,800
ARB Ras fields of the instruction word

00:10:04,670 --> 00:10:09,440
so they're the specific sets of five

00:10:07,800 --> 00:10:12,750
bits in the instruction word that

00:10:09,440 --> 00:10:14,040
indicate which which are the register

00:10:12,750 --> 00:10:17,940
numbers you're reading for each of the

00:10:14,040 --> 00:10:20,130
three potential operands and that

00:10:17,940 --> 00:10:23,339
register file started out as 32 entries

00:10:20,130 --> 00:10:26,100
of 64 bits there since double it to 64

00:10:23,339 --> 00:10:28,560
entries and that means that we can store

00:10:26,100 --> 00:10:30,680
all of the special purpose registers

00:10:28,560 --> 00:10:33,390
that we implement in that Ram as well

00:10:30,680 --> 00:10:36,089
and it kind of unifies the hazard

00:10:33,390 --> 00:10:39,510
detection and and that kind of thing

00:10:36,089 --> 00:10:43,709
between the GPRS and these SP RS that

00:10:39,510 --> 00:10:45,630
we've implemented then there's a bypass

00:10:43,709 --> 00:10:49,800
the next set of multiplex as you can see

00:10:45,630 --> 00:10:52,320
that kind of trapezoidal symbol rhombic

00:10:49,800 --> 00:10:57,060
whatever whatever it is that

00:10:52,320 --> 00:11:00,029
quadrilateral is is a multiplexer which

00:10:57,060 --> 00:11:02,190
can select the data being written the

00:11:00,029 --> 00:11:03,900
data that's going to be written is like

00:11:02,190 --> 00:11:05,820
on the next clock edge can actually then

00:11:03,900 --> 00:11:07,950
be bypassed to be used

00:11:05,820 --> 00:11:10,410
in the current cycle if you're writing

00:11:07,950 --> 00:11:14,130
the same register that you're reading so

00:11:10,410 --> 00:11:15,930
there's that bypass on the B operand we

00:11:14,130 --> 00:11:18,900
can bring in an immediate constant which

00:11:15,930 --> 00:11:21,450
is one of several fields of the

00:11:18,900 --> 00:11:23,400
instruction word can come in there and

00:11:21,450 --> 00:11:27,360
we come down into these set of registers

00:11:23,400 --> 00:11:29,880
which this rd-180 283 are the actual

00:11:27,360 --> 00:11:33,780
operand values that are coming out of

00:11:29,880 --> 00:11:36,570
the decode to stage so that that that is

00:11:33,780 --> 00:11:38,460
the output of decode 2 which probably

00:11:36,570 --> 00:11:40,560
should be called issue but whatever it's

00:11:38,460 --> 00:11:43,760
called decode 2 so then we've got those

00:11:40,560 --> 00:11:48,120
three operands that go into the various

00:11:43,760 --> 00:11:51,510
execution units if you like the adder

00:11:48,120 --> 00:11:53,910
subtractor the rotator the logical unit

00:11:51,510 --> 00:11:56,340
the multiplier the divider and there's a

00:11:53,910 --> 00:12:00,150
bunch of other things so when you look

00:11:56,340 --> 00:12:02,730
in the VHDL in execute one there's this

00:12:00,150 --> 00:12:07,470
big case statement that says if it's you

00:12:02,730 --> 00:12:09,780
know op ed then result is the output of

00:12:07,470 --> 00:12:12,060
the adder and if it's you know Oh rotate

00:12:09,780 --> 00:12:14,520
then it's the output of the road result

00:12:12,060 --> 00:12:17,340
colon equals output of the rotator and

00:12:14,520 --> 00:12:19,080
it's just as big case statement so that

00:12:17,340 --> 00:12:21,810
big case statement then generates this

00:12:19,080 --> 00:12:25,080
enormous multiplexer at the bottom which

00:12:21,810 --> 00:12:27,330
is taking the answer from whichever

00:12:25,080 --> 00:12:29,040
functional unit it was that was supposed

00:12:27,330 --> 00:12:31,500
to generate according to what

00:12:29,040 --> 00:12:33,000
instruction we're executing and puts

00:12:31,500 --> 00:12:37,620
that into this result register which is

00:12:33,000 --> 00:12:39,300
the output of execute one now at the

00:12:37,620 --> 00:12:41,000
moment that then goes into write back

00:12:39,300 --> 00:12:44,910
which is kind of this stuff on the right

00:12:41,000 --> 00:12:47,070
where we select either the output from

00:12:44,910 --> 00:12:51,900
the execute or the output from the load

00:12:47,070 --> 00:12:54,770
store thing these these operands go also

00:12:51,900 --> 00:12:57,570
into the load store unit and for a load

00:12:54,770 --> 00:12:59,940
we get the data back which then goes

00:12:57,570 --> 00:13:03,900
through a formatting stage the

00:12:59,940 --> 00:13:06,810
formatting stage is that you get 64 bits

00:13:03,900 --> 00:13:09,120
back but you only did a load byte of you

00:13:06,810 --> 00:13:10,860
know this you know you read this much

00:13:09,120 --> 00:13:12,330
but you only wanted interested in that

00:13:10,860 --> 00:13:15,330
match so you've got to ship that to the

00:13:12,330 --> 00:13:17,600
right and mask off the rest in order to

00:13:15,330 --> 00:13:18,880
get the value to right into the register

00:13:17,600 --> 00:13:21,760
so

00:13:18,880 --> 00:13:24,820
it's that shifting and either zero

00:13:21,760 --> 00:13:27,130
extension or sign extension and in the

00:13:24,820 --> 00:13:29,010
future when we do unaligned loads it

00:13:27,130 --> 00:13:31,180
will be your so stitching together two

00:13:29,010 --> 00:13:32,650
for a non-aligned load you probably have

00:13:31,180 --> 00:13:35,230
to if it's more than one byte you

00:13:32,650 --> 00:13:37,510
probably have to do two eight byte reads

00:13:35,230 --> 00:13:38,860
and then take a bit of this eight bytes

00:13:37,510 --> 00:13:40,120
and a bit of that eight bytes and sort

00:13:38,860 --> 00:13:43,810
of rotate them and stick them together

00:13:40,120 --> 00:13:46,480
and that's what the formatter does and

00:13:43,810 --> 00:13:51,340
so that goes back up into the right data

00:13:46,480 --> 00:13:54,190
port so from the point of view of the

00:13:51,340 --> 00:13:58,960
data that's how stuff is going around

00:13:54,190 --> 00:14:00,580
and around in the system now what I want

00:13:58,960 --> 00:14:02,920
to do I've been working on but haven't

00:14:00,580 --> 00:14:05,380
quite got it ready to commit is then add

00:14:02,920 --> 00:14:09,730
another bypass from the output of the

00:14:05,380 --> 00:14:13,450
execute one back into the input of

00:14:09,730 --> 00:14:16,690
execute one and load store so that you

00:14:13,450 --> 00:14:18,610
see in the previous slide if you had

00:14:16,690 --> 00:14:21,820
let's say an add instruction that put a

00:14:18,610 --> 00:14:25,390
value into r5 and in an and instruction

00:14:21,820 --> 00:14:26,890
that used the value from r5 so the first

00:14:25,390 --> 00:14:30,310
one comes through it gets into the

00:14:26,890 --> 00:14:33,340
result but that is then not yet

00:14:30,310 --> 00:14:35,290
available to be used in the next cycle

00:14:33,340 --> 00:14:36,430
in execute one because we've got if you

00:14:35,290 --> 00:14:38,980
look at the loop we've got two

00:14:36,430 --> 00:14:41,200
flip-flops in the loop so that means

00:14:38,980 --> 00:14:43,000
that you do the add instruction and then

00:14:41,200 --> 00:14:44,680
you've got a stall cycle when you can't

00:14:43,000 --> 00:14:47,140
do anything because the operand isn't

00:14:44,680 --> 00:14:50,110
ready yet and then you can do the end in

00:14:47,140 --> 00:14:51,220
the second in the third cycle because

00:14:50,110 --> 00:14:54,430
you've got to go through these two

00:14:51,220 --> 00:14:57,460
flip-flops so the minimum time to go

00:14:54,430 --> 00:15:00,490
around the loop has two cycles with this

00:14:57,460 --> 00:15:02,980
bypass coming in after that set of

00:15:00,490 --> 00:15:05,580
rd-180 to our t3 we'll be able to do

00:15:02,980 --> 00:15:10,690
back-to-back integer operations where

00:15:05,580 --> 00:15:13,500
you know an ADD followed by an and can

00:15:10,690 --> 00:15:13,500
be done in two cycles

00:15:15,950 --> 00:15:20,329
okay so they're looking at the

00:15:18,260 --> 00:15:24,200
particular stages in order

00:15:20,329 --> 00:15:26,120
we start with fetch one basically all it

00:15:24,200 --> 00:15:28,370
does is just generate a stream of

00:15:26,120 --> 00:15:32,209
instruction addresses so we've got

00:15:28,370 --> 00:15:34,579
there's ni a thing and left to itself it

00:15:32,209 --> 00:15:37,370
would just generate you know 100 X 100

00:15:34,579 --> 00:15:41,920
for hex 108 hex when I see hex 1 1 to 0

00:15:37,370 --> 00:15:44,720
hex but just keep on doing this forever

00:15:41,920 --> 00:15:46,910
it has the signals coming in the stall

00:15:44,720 --> 00:15:50,089
and the redirect so the stall is going

00:15:46,910 --> 00:15:51,709
to say don't give me the next number on

00:15:50,089 --> 00:15:54,350
the next cycle just repeat the same

00:15:51,709 --> 00:15:57,440
number and the redirect is going to say

00:15:54,350 --> 00:15:59,000
start again from this number so you do a

00:15:57,440 --> 00:16:01,459
branch to two hundred hex then it's

00:15:59,000 --> 00:16:06,139
going to spit out 200 204 208 and so

00:16:01,459 --> 00:16:08,899
forth that goes into the I cache and as

00:16:06,139 --> 00:16:11,839
long as we're hitting in the I cache we

00:16:08,899 --> 00:16:14,209
can do it in one cycle we can accept a

00:16:11,839 --> 00:16:16,570
different ni a each cycle and generate

00:16:14,209 --> 00:16:20,360
the instruction word on the next cycle

00:16:16,570 --> 00:16:22,550
so we can do one one in you know one CPI

00:16:20,360 --> 00:16:23,660
one cycle per instruction as long as

00:16:22,550 --> 00:16:26,329
we're heading in the our cache

00:16:23,660 --> 00:16:28,160
if we miss then there's a state machine

00:16:26,329 --> 00:16:31,010
that starts up and we'd send the stall

00:16:28,160 --> 00:16:31,370
signal back to fetch one to say hang on

00:16:31,010 --> 00:16:35,680
a minute

00:16:31,370 --> 00:16:38,449
and then I cache is going to send out

00:16:35,680 --> 00:16:41,870
requests to memory to reload the cache

00:16:38,449 --> 00:16:44,630
line get the stuff back then off we go

00:16:41,870 --> 00:16:47,300
fetch to basically does pretty much

00:16:44,630 --> 00:16:54,290
nothing we could possibly maybe get rid

00:16:47,300 --> 00:16:56,060
of it I don't know okay so essentially

00:16:54,290 --> 00:16:59,510
what it does at the moment is provide a

00:16:56,060 --> 00:17:02,480
way to stall like ash it provides a

00:16:59,510 --> 00:17:05,150
buffer where you know if subsequent

00:17:02,480 --> 00:17:09,410
stages want to stall we can do the stall

00:17:05,150 --> 00:17:11,449
at that level and and it doesn't disturb

00:17:09,410 --> 00:17:16,819
I cache but we can possibly get rid of

00:17:11,449 --> 00:17:20,270
it decode an issue so decode we got

00:17:16,819 --> 00:17:21,890
decode 1 and decode two as Anton said

00:17:20,270 --> 00:17:24,949
we've got the major opcode in the top

00:17:21,890 --> 00:17:29,250
six bits that's you know 64 values

00:17:24,949 --> 00:17:32,130
obviously several of those op codes

00:17:29,250 --> 00:17:35,100
then have a minor opcode in lower bits

00:17:32,130 --> 00:17:36,870
like opcode 31 its bits one to ten of

00:17:35,100 --> 00:17:38,220
the instruction then give you a minor op

00:17:36,870 --> 00:17:39,929
code that tells you whether you're doing

00:17:38,220 --> 00:17:43,710
an add instruction or an end or a

00:17:39,929 --> 00:17:47,640
synchronize or whatever it is so we have

00:17:43,710 --> 00:17:49,830
a decode table for the top six bits and

00:17:47,640 --> 00:17:54,330
for some of the op codes we then have

00:17:49,830 --> 00:18:00,030
other decode tables for the minor opcode

00:17:54,330 --> 00:18:02,280
and that whether it's whichever table

00:18:00,030 --> 00:18:04,230
that comes from we get the same 38 bits

00:18:02,280 --> 00:18:09,150
of control information that then go down

00:18:04,230 --> 00:18:11,640
into decode to decode to gets a bit more

00:18:09,150 --> 00:18:14,580
interesting it's responsible for reading

00:18:11,640 --> 00:18:17,909
those operands general-purpose registers

00:18:14,580 --> 00:18:21,090
condition register x-ers PR from the

00:18:17,909 --> 00:18:26,760
register file the Reg file and the CI

00:18:21,090 --> 00:18:29,070
file and talked about that it also is

00:18:26,760 --> 00:18:32,549
the place where we detect hazards so we

00:18:29,070 --> 00:18:34,830
detect the fact here that the previous

00:18:32,549 --> 00:18:36,630
instruction wrote a register and this

00:18:34,830 --> 00:18:38,850
instruction is reading it so therefore

00:18:36,630 --> 00:18:42,690
there's a dependency there that we need

00:18:38,850 --> 00:18:44,280
to be aware of and to manage because not

00:18:42,690 --> 00:18:47,330
all instructions execute in a single

00:18:44,280 --> 00:18:49,590
cycle we need to know about that and to

00:18:47,330 --> 00:18:50,970
stall a previous instruction if it's

00:18:49,590 --> 00:19:03,419
needing some data that's not yet

00:18:50,970 --> 00:19:06,809
available we then go down to load store

00:19:03,419 --> 00:19:08,370
in d cache so the first cycle does a

00:19:06,809 --> 00:19:12,090
disk generation and store data

00:19:08,370 --> 00:19:13,770
formatting second cycle asynchronous

00:19:12,090 --> 00:19:16,320
read of the cache tag memory and compare

00:19:13,770 --> 00:19:18,360
and the third cycle we either have the

00:19:16,320 --> 00:19:20,970
data which we then select the right way

00:19:18,360 --> 00:19:30,850
or we start the state machine to access

00:19:20,970 --> 00:19:35,250
memory so that not quite right okay so

00:19:30,850 --> 00:19:38,200
a high level description reasonably good

00:19:35,250 --> 00:19:40,600
okay we can talk to Ben later if you

00:19:38,200 --> 00:19:45,100
want to know that fine tea - that's the

00:19:40,600 --> 00:19:47,649
bin rate all this stuff executes so

00:19:45,100 --> 00:19:49,690
currently all of our entered integer

00:19:47,649 --> 00:19:53,529
instructions except for the multipliers

00:19:49,690 --> 00:19:55,240
and divides executed in one cycle power

00:19:53,529 --> 00:19:58,330
the power is a has got these interesting

00:19:55,240 --> 00:20:01,480
instructions that do things like rotate

00:19:58,330 --> 00:20:03,309
and generate a mask from this bit to

00:20:01,480 --> 00:20:05,919
that bit and and the two together and

00:20:03,309 --> 00:20:07,149
then end with you know and a register

00:20:05,919 --> 00:20:09,009
with the complement of the mask and

00:20:07,149 --> 00:20:10,960
stick things together and write the

00:20:09,009 --> 00:20:14,830
result back all that happens in one

00:20:10,960 --> 00:20:16,659
cycle the divider is a bit slower it

00:20:14,830 --> 00:20:20,590
takes between ten and sixty six cycles

00:20:16,659 --> 00:20:22,629
depending on its operands that the

00:20:20,590 --> 00:20:24,850
divider was really more about getting it

00:20:22,629 --> 00:20:26,799
to work without using an enormous amount

00:20:24,850 --> 00:20:29,950
of resources than making it really

00:20:26,799 --> 00:20:33,970
really fast the multiplier needs work it

00:20:29,950 --> 00:20:35,529
currently takes 18 cycles part of the

00:20:33,970 --> 00:20:41,909
problem is that viv a dough for the

00:20:35,529 --> 00:20:44,409
Nexus parts mix I think seven whatever

00:20:41,909 --> 00:20:47,139
tends to have warnings that come up

00:20:44,409 --> 00:20:50,320
because it's got these DSP things in it

00:20:47,139 --> 00:20:53,440
that have got multipliers eighteen by

00:20:50,320 --> 00:20:56,559
fourteen bit multipliers and in VHDL you

00:20:53,440 --> 00:21:00,220
just write are 64 by 64 bit or 65 by 65

00:20:56,559 --> 00:21:02,620
bit multiplier and then the vivido tools

00:21:00,220 --> 00:21:05,620
are then turning that into using a whole

00:21:02,620 --> 00:21:08,289
pile of DSP things but then it has this

00:21:05,620 --> 00:21:10,419
checking stage that says you've got a

00:21:08,289 --> 00:21:12,269
have you know a foot flop on the input

00:21:10,419 --> 00:21:14,529
and the output of this multiplier and

00:21:12,269 --> 00:21:17,409
the individual things that has been

00:21:14,529 --> 00:21:21,129
broken down into so we tend to get a lot

00:21:17,409 --> 00:21:24,370
of warnings out of it so somebody really

00:21:21,129 --> 00:21:28,509
needs to have a good look at what the

00:21:24,370 --> 00:21:31,690
DSP in the Artic 7 can do and write some

00:21:28,509 --> 00:21:34,240
custom VHDL for the Arctic's 7 and then

00:21:31,690 --> 00:21:37,620
perhaps for the ECP 5 and whatever

00:21:34,240 --> 00:21:40,419
it's very unoptimized at this point

00:21:37,620 --> 00:21:42,940
there is a proposal to use a three-stage

00:21:40,419 --> 00:21:45,220
pipeline for execute

00:21:42,940 --> 00:21:48,810
in order to match the latency of

00:21:45,220 --> 00:21:51,820
load/store in order to reduce the

00:21:48,810 --> 00:21:53,410
effective load to use latency we would

00:21:51,820 --> 00:21:55,720
need to then have bypasses from each

00:21:53,410 --> 00:21:58,810
stage of that three cycle execute

00:21:55,720 --> 00:22:03,480
pipeline having three cycles might also

00:21:58,810 --> 00:22:03,480
enable us to optimize some other things

00:22:04,500 --> 00:22:10,390
moving on this right back so this

00:22:07,360 --> 00:22:12,520
includes the load data formatting that's

00:22:10,390 --> 00:22:15,640
taking that eight bytes that we get from

00:22:12,520 --> 00:22:17,530
the the D cache and rotating it and

00:22:15,640 --> 00:22:20,320
masking it and cyan extending it and and

00:22:17,530 --> 00:22:22,480
also by traversing it power has by

00:22:20,320 --> 00:22:26,890
traverse loadings and store instructions

00:22:22,480 --> 00:22:30,250
which which basically load or store in

00:22:26,890 --> 00:22:33,550
the opposite Indian aslam then processes

00:22:30,250 --> 00:22:35,740
natural Indian Asst so if your processor

00:22:33,550 --> 00:22:38,170
is naturally little Indian as microwatt

00:22:35,740 --> 00:22:42,490
is then these but reversed ones do big

00:22:38,170 --> 00:22:44,500
endian the CR zero setting for dot form

00:22:42,490 --> 00:22:48,370
instructions this is instructions like

00:22:44,500 --> 00:22:51,460
in in the power I say if you say add a

00:22:48,370 --> 00:22:54,160
zero I 102 it allowed I one on to and

00:22:51,460 --> 00:22:56,140
put it in a zero if you say add dot with

00:22:54,160 --> 00:22:58,270
a dot on the end of the instruction it

00:22:56,140 --> 00:23:01,450
will do the addition but also then

00:22:58,270 --> 00:23:03,400
compare the result with zero and put a

00:23:01,450 --> 00:23:05,200
condition code setting in condition

00:23:03,400 --> 00:23:07,720
register zero to say whether the result

00:23:05,200 --> 00:23:11,680
was equal less than or greater than zero

00:23:07,720 --> 00:23:16,480
so that that's done in right back and it

00:23:11,680 --> 00:23:18,850
sends data to the register files so that

00:23:16,480 --> 00:23:21,090
that's basically how everything fits

00:23:18,850 --> 00:23:21,090
together

00:23:22,770 --> 00:23:30,880
fairly considerable to-do list one thing

00:23:28,809 --> 00:23:34,260
that would be really useful is to get on

00:23:30,880 --> 00:23:36,580
and do well the privilege modes

00:23:34,260 --> 00:23:39,220
certainly supervisor mode because then

00:23:36,580 --> 00:23:40,270
that means we can run Linux and then

00:23:39,220 --> 00:23:41,830
it'd be kind of nice to do the

00:23:40,270 --> 00:23:43,570
hypervisor mode as well which wouldn't

00:23:41,830 --> 00:23:44,559
mean that we could then start running

00:23:43,570 --> 00:23:46,090
KVM on it

00:23:44,559 --> 00:23:50,410
which would be kind of cute because

00:23:46,090 --> 00:23:52,150
that's that's what i do i do kayvyun but

00:23:50,410 --> 00:23:54,670
of course for that we also need a memory

00:23:52,150 --> 00:23:56,590
management unit we don't have anything

00:23:54,670 --> 00:23:58,210
at the moment it's just completely that

00:23:56,590 --> 00:24:00,820
the effective address generated by the

00:23:58,210 --> 00:24:02,260
instruction is the address that goes to

00:24:00,820 --> 00:24:04,059
memory and it's the address that's used

00:24:02,260 --> 00:24:06,630
to look at that the data cache and the

00:24:04,059 --> 00:24:09,520
instruction cache and everything as

00:24:06,630 --> 00:24:14,280
Anton was saying perhaps we'll start

00:24:09,520 --> 00:24:16,240
with a software loaded TLB that would be

00:24:14,280 --> 00:24:18,130
relatively straightforward to do

00:24:16,240 --> 00:24:21,340
initially

00:24:18,130 --> 00:24:28,690
I guess particularly if we had separate

00:24:21,340 --> 00:24:30,520
ITIL d ITIL B&D TLB and then there's all

00:24:28,690 --> 00:24:33,010
sorts of ideas about like Ben was saying

00:24:30,520 --> 00:24:36,100
have some kind of hidden firm layer that

00:24:33,010 --> 00:24:39,640
implements the radix MMU from the that

00:24:36,100 --> 00:24:43,630
like paradigm does power 9 has actually

00:24:39,640 --> 00:24:45,790
got that the the radix MMU is new was

00:24:43,630 --> 00:24:48,280
power 9 the previous processors power 8

00:24:45,790 --> 00:24:51,610
and so forth simply use the hash page

00:24:48,280 --> 00:24:55,420
table which is a fairly complicated

00:24:51,610 --> 00:24:58,900
structure and has the disadvantage that

00:24:55,420 --> 00:25:00,820
it's not very cache friendly it's a when

00:24:58,900 --> 00:25:03,870
it balls when you boil it down that is

00:25:00,820 --> 00:25:08,890
the the big reason not to use it is that

00:25:03,870 --> 00:25:11,440
it it doesn't cache very well so yeah

00:25:08,890 --> 00:25:13,900
that's something where there's a lot of

00:25:11,440 --> 00:25:16,120
room for someone to come in and say I

00:25:13,900 --> 00:25:19,809
think we should do this and write some

00:25:16,120 --> 00:25:21,970
VHDL and get it going and will be very

00:25:19,809 --> 00:25:25,510
much appreciated we need to implement

00:25:21,970 --> 00:25:27,850
interrupts as well so both in the power

00:25:25,510 --> 00:25:30,340
instruction set architecture the term

00:25:27,850 --> 00:25:32,440
interrupts because we do the IBM thing

00:25:30,340 --> 00:25:34,160
of we use the same word as everyone else

00:25:32,440 --> 00:25:36,590
in the industry but we used mean

00:25:34,160 --> 00:25:40,090
slightly different thing by it so an

00:25:36,590 --> 00:25:43,910
interrupt is the change in control flow

00:25:40,090 --> 00:25:47,030
due to an event so both something like a

00:25:43,910 --> 00:25:48,559
page fault which is that the the program

00:25:47,030 --> 00:25:50,539
itself did something and it's a

00:25:48,559 --> 00:25:52,690
synchronous thing where it's direct

00:25:50,539 --> 00:25:56,419
result of the execution of the program

00:25:52,690 --> 00:25:59,179
that we that we divert execution flow

00:25:56,419 --> 00:26:01,010
from the program we're doing to the

00:25:59,179 --> 00:26:03,200
interrupt handler and an external

00:26:01,010 --> 00:26:05,150
interrupt where a device is saying I've

00:26:03,200 --> 00:26:06,770
read that block of data for you and it's

00:26:05,150 --> 00:26:11,059
in memory now and you can go and use it

00:26:06,770 --> 00:26:14,720
and it gives us an interrupt the term

00:26:11,059 --> 00:26:17,510
that covers both cases we need unaligned

00:26:14,720 --> 00:26:19,880
loads and stores we don't do them really

00:26:17,510 --> 00:26:23,630
well we kind of do them if they fit

00:26:19,880 --> 00:26:25,429
within an 8 byte chunk of memory but if

00:26:23,630 --> 00:26:29,360
they cross between two 8by trunks of

00:26:25,429 --> 00:26:31,960
memory we don't trap we just give you

00:26:29,360 --> 00:26:31,960
the wrong answer

00:26:33,919 --> 00:26:40,070
it'll be nice to reduce the load to use

00:26:35,840 --> 00:26:42,289
latency we need some kind of floating

00:26:40,070 --> 00:26:46,340
point particularly if we want to run a

00:26:42,289 --> 00:26:48,169
stock Linux kernel we don't necessarily

00:26:46,340 --> 00:26:49,909
have to have a complete floating point

00:26:48,169 --> 00:26:54,020
unit but we kind of do need the

00:26:49,909 --> 00:26:55,730
registers what we want to do is avoid

00:26:54,020 --> 00:26:58,850
the temptation to create a soft float

00:26:55,730 --> 00:27:01,100
variant of the ABI this happened on

00:26:58,850 --> 00:27:03,440
32-bit embedded PowerPC and it was a

00:27:01,100 --> 00:27:05,330
real pain because you know all of a

00:27:03,440 --> 00:27:08,030
sudden you need different tools and the

00:27:05,330 --> 00:27:11,390
one binary won't run here and will run

00:27:08,030 --> 00:27:14,659
here but won't run there we really want

00:27:11,390 --> 00:27:16,720
to avoid that and then get Linux running

00:27:14,659 --> 00:27:23,270
that would be terrific

00:27:16,720 --> 00:27:26,110
so that's that any questions are we

00:27:23,270 --> 00:27:26,110
doing the microphone thing

00:27:27,659 --> 00:27:32,860
so you're you're asking for volunteers

00:27:30,039 --> 00:27:35,169
to help you write some VHDL to implement

00:27:32,860 --> 00:27:38,080
some of the missing features or improve

00:27:35,169 --> 00:27:41,200
some of the features that are there how

00:27:38,080 --> 00:27:44,140
how would somebody do that and avoid

00:27:41,200 --> 00:27:50,650
stepping on the patent landmine from

00:27:44,140 --> 00:27:53,020
other cpu why I say vendors other cpu

00:27:50,650 --> 00:27:56,730
vendors yeah so I think there was a

00:27:53,020 --> 00:27:59,730
patent some sort of patent deal with the

00:27:56,730 --> 00:28:03,280
Pennine over the open power foundation

00:27:59,730 --> 00:28:04,990
so I'm presuming that you can use it I

00:28:03,280 --> 00:28:07,419
mean there's no patent Lane one as far

00:28:04,990 --> 00:28:11,919
as IBM patents are concerned yes but how

00:28:07,419 --> 00:28:13,360
well is so I'm not a CPU expert so how

00:28:11,919 --> 00:28:16,690
would I know I wasn't stepping on AMD

00:28:13,360 --> 00:28:22,299
well I mean that's that that is a good

00:28:16,690 --> 00:28:23,710
question I mean in general in well I

00:28:22,299 --> 00:28:28,809
mean at least the advice I've been given

00:28:23,710 --> 00:28:31,390
is not to go looking at patents because

00:28:28,809 --> 00:28:32,860
well because if you if you can be shown

00:28:31,390 --> 00:28:34,120
to have looked at a patent and infringed

00:28:32,860 --> 00:28:37,690
it then it's well it's willful

00:28:34,120 --> 00:28:39,429
infringement and triple damages so as a

00:28:37,690 --> 00:28:47,020
means of communication between engineers

00:28:39,429 --> 00:28:49,659
patents are completely useless or so we

00:28:47,020 --> 00:28:53,289
probably not at a stage where what we do

00:28:49,659 --> 00:28:55,960
is innovative enough to be an active

00:28:53,289 --> 00:28:58,030
patent today I mean pretty sure every

00:28:55,960 --> 00:29:02,830
idea we've been having here I've been

00:28:58,030 --> 00:29:04,919
problem or than 20 years old yeah that's

00:29:02,830 --> 00:29:08,530
a good point

00:29:04,919 --> 00:29:10,780
curious you said the currently it's a

00:29:08,530 --> 00:29:12,400
very similar 10,000 line infant age from

00:29:10,780 --> 00:29:15,429
microwatt and stuff to keep it simple

00:29:12,400 --> 00:29:16,659
for an educational someone can come in

00:29:15,429 --> 00:29:18,909
and actually understand the whole thing

00:29:16,659 --> 00:29:21,880
going forward is that going to continue

00:29:18,909 --> 00:29:23,590
b2b goals as I can get involved even if

00:29:21,880 --> 00:29:25,270
some more conflicts get the stuff gets

00:29:23,590 --> 00:29:28,510
in familiar you could still implement

00:29:25,270 --> 00:29:30,820
this and understand a lot yeah it's an

00:29:28,510 --> 00:29:32,770
interesting balance between on the one

00:29:30,820 --> 00:29:35,830
hand wanting it to be reasonably

00:29:32,770 --> 00:29:37,539
performant and you know not use too much

00:29:35,830 --> 00:29:40,269
resources but then on the other hand be

00:29:37,539 --> 00:29:43,299
easy to read and

00:29:40,269 --> 00:29:47,709
that's something we'll have to try and

00:29:43,299 --> 00:29:56,169
keep in balance as we go forward it's up

00:29:47,709 --> 00:29:58,690
to the maintainer really plenty of time

00:29:56,169 --> 00:30:04,029
I talk too quick today there's a

00:29:58,690 --> 00:30:06,369
question there when you say you're

00:30:04,029 --> 00:30:08,889
hoping to implement an MMU is that

00:30:06,369 --> 00:30:13,799
something that you would create your own

00:30:08,889 --> 00:30:18,429
one or try and use an existing design

00:30:13,799 --> 00:30:21,429
well at the level of architecture we

00:30:18,429 --> 00:30:25,389
would want it to look or at least made

00:30:21,429 --> 00:30:27,820
to be able to fake looking like the the

00:30:25,389 --> 00:30:31,389
Pennine architecture which is the is a

00:30:27,820 --> 00:30:33,070
version 3.0 B that I that instruction

00:30:31,389 --> 00:30:34,629
set architecture specification is

00:30:33,070 --> 00:30:37,809
publicly available I think on the open

00:30:34,629 --> 00:30:39,369
power org then open power foundation

00:30:37,809 --> 00:30:41,709
that all open power foundation.org

00:30:39,369 --> 00:30:44,769
website you can find the specification

00:30:41,709 --> 00:30:47,169
and it's fairly long and complicated and

00:30:44,769 --> 00:30:50,559
it talks about in-memory data structures

00:30:47,169 --> 00:30:53,159
and stuff now that all sounds very

00:30:50,559 --> 00:30:56,079
complicated but the saving grace is that

00:30:53,159 --> 00:30:59,889
there's a paragraph early on that says

00:30:56,079 --> 00:31:01,570
that the architecture can be implemented

00:30:59,889 --> 00:31:06,129
by a combination of hardware and

00:31:01,570 --> 00:31:08,259
software so it doesn't all have to be in

00:31:06,129 --> 00:31:09,959
Hardware you can have part of it in

00:31:08,259 --> 00:31:12,909
software and you can define

00:31:09,959 --> 00:31:16,450
implementation specific interrupts to do

00:31:12,909 --> 00:31:18,129
software emulation of most of the

00:31:16,450 --> 00:31:20,049
architecture there's a subset that has

00:31:18,129 --> 00:31:22,929
to be done in hardware which is

00:31:20,049 --> 00:31:24,789
basically the subset that's used for the

00:31:22,929 --> 00:31:28,450
early and early part of interrupt

00:31:24,789 --> 00:31:31,299
handling but certainly the MMU is

00:31:28,450 --> 00:31:33,159
something that can be implemented you

00:31:31,299 --> 00:31:35,229
know you can have the slider between all

00:31:33,159 --> 00:31:37,329
hardware and all the software and put

00:31:35,229 --> 00:31:42,519
the slider any reasonable point between

00:31:37,329 --> 00:31:45,849
them so we would want someone who knows

00:31:42,519 --> 00:31:47,979
who's read the architecture and know is

00:31:45,849 --> 00:31:50,469
kind of what we needed to at least be

00:31:47,979 --> 00:31:51,969
able to fake looking like somebody's

00:31:50,469 --> 00:31:54,119
interesting work on mmm you talk to me

00:31:51,969 --> 00:31:54,119
first

00:31:54,669 --> 00:32:00,789
so I should have mentioned that there is

00:31:57,200 --> 00:32:03,799
a slack channel where we discuss things

00:32:00,789 --> 00:32:06,100
you can get the address from Anton or

00:32:03,799 --> 00:32:12,500
possibly Hugh do you need an invitation

00:32:06,100 --> 00:32:14,570
or is it anyone can join if we are very

00:32:12,500 --> 00:32:18,730
very very much welcome people who have

00:32:14,570 --> 00:32:18,730
experience dealing with timing in FPGAs

00:32:22,059 --> 00:32:28,580
you also mentioned like reasons not his

00:32:25,549 --> 00:32:29,690
hash type memory lookup use reading

00:32:28,580 --> 00:32:32,350
straight song because you have cache

00:32:29,690 --> 00:32:39,380
coherency problems or something is that

00:32:32,350 --> 00:32:41,360
so no cache miss so ladies cache miss or

00:32:39,380 --> 00:32:42,559
maybe not on like size or something

00:32:41,360 --> 00:32:43,990
because I'm like you're using that a

00:32:42,559 --> 00:32:45,770
small activity you're not going to be

00:32:43,990 --> 00:32:52,010
running out of me

00:32:45,770 --> 00:32:53,630
okay the the hash page table I think

00:32:52,010 --> 00:33:00,070
would probably be more complex to

00:32:53,630 --> 00:33:00,070
implement yeah because of the SLB yeah

00:33:01,330 --> 00:33:07,429
no there's no subway but but if we did

00:33:06,200 --> 00:33:12,020
the hashed page table we would need to

00:33:07,429 --> 00:33:15,159
have an SLT but we don't particularly

00:33:12,020 --> 00:33:15,159
want to do the hashed page table

00:33:22,500 --> 00:33:35,480

YouTube URL: https://www.youtube.com/watch?v=JkDx_y0onSk


