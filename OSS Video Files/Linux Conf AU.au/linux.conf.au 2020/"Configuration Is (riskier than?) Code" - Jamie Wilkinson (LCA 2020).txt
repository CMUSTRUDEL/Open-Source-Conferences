Title: "Configuration Is (riskier than?) Code" - Jamie Wilkinson (LCA 2020)
Publication date: 2020-01-14
Playlist: linux.conf.au 2020
Description: 
	Jamie Wilkinson

https://lca2020.linux.org.au/schedule/presentation/141/

TL;DR: Configuration is code, and config changes should be treated with at least as much care, skepticism, and rigour as code changes are.  Config presents special challenges though as it's usually not a fully operational Turing equivalent language, but has a high "force multiplier" per character relative to code itself.  let's explore those challenges and how we can address them to reduce the risk of configuration-change-related outages. 

Over ten years ago Puppet Labs and others espoused the idea of "configuration as code," setting a course that crossed DevOps, the APIfication of systems, the Cloud, and Serverless.  Today, you can write a few lines of config and invoke thousands of CPUs, doing hundreds of operations, deploying entire clusters of systems, a huge force multiplier for IT operations.
         
This force multiplier comes at a cost, and that cost is risk and impact.  Never before has it been so easy to destroy an entire CDN in a single command. While numbers vary, studies show that a significant number of incidents in IT operations are caused by configuration changes. 

Configuration *is* code (and I'll prove it), but it sure lacks the same rigour that code receives. Configuration formats like YAML and JSON do not have the same quality of syntax checkers and debuggers that languages like C++, Go, and Ruby have.  Often the first time you know that a configuration is semantically correct is when it is running in production.
                                                                               
So what can we do about it?  Why does this presenter think that a comparison between configuration format and a debugger is even possible?

In this presentation we'll start by looking at this problem from a theoretical point, which will let us look to other areas that solve a similar problem, and then see how we can apply that perspective back to configuration to make future production changes safer than today.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Mon Jan 13 13:30:00 2020 at Arena
Captions: 
	00:00:00,000 --> 00:00:02,939
I want to talk to you about an idea that

00:00:01,530 --> 00:00:07,200
I had and then I did some research and

00:00:02,939 --> 00:00:09,380
then look some investigations and it was

00:00:07,200 --> 00:00:11,550
kind of somewhat disappointing but also

00:00:09,380 --> 00:00:13,170
empowering I guess in that I was

00:00:11,550 --> 00:00:14,130
partially right so I want to tell you

00:00:13,170 --> 00:00:16,109
this story

00:00:14,130 --> 00:00:18,869
I've been assisted men for over 20 years

00:00:16,109 --> 00:00:22,560
and before that I was a computer

00:00:18,869 --> 00:00:24,810
scientist at UNSW only barely but I

00:00:22,560 --> 00:00:26,369
learned enough during that I'm five

00:00:24,810 --> 00:00:29,250
years of my three at bachelor's degree

00:00:26,369 --> 00:00:31,349
to give just be dangerous enough with

00:00:29,250 --> 00:00:34,110
theory of computation which I found

00:00:31,349 --> 00:00:36,180
really interesting and so as I've been

00:00:34,110 --> 00:00:38,280
assisted in there's been what 15 years

00:00:36,180 --> 00:00:40,200
issue of DevOps and configuration code

00:00:38,280 --> 00:00:42,629
and stuff since a puppet first came out

00:00:40,200 --> 00:00:43,620
and before that you might remember

00:00:42,629 --> 00:00:49,890
cfengine

00:00:43,620 --> 00:00:51,690
and things like that this Cambrian

00:00:49,890 --> 00:00:54,030
explosion in the last 15 years you might

00:00:51,690 --> 00:00:57,750
call it of ways of doing configuration

00:00:54,030 --> 00:00:59,910
as code and I think this is really

00:00:57,750 --> 00:01:02,359
fantastic right as a industry we've been

00:00:59,910 --> 00:01:05,040
our we become very productive in and

00:01:02,359 --> 00:01:06,780
solve a lot of problems but there's a

00:01:05,040 --> 00:01:09,500
cost because these configurations lay

00:01:06,780 --> 00:01:12,869
abstractions on top of abstractions like

00:01:09,500 --> 00:01:15,060
geological layers you suddenly realize

00:01:12,869 --> 00:01:18,210
that you can affect a lot of change with

00:01:15,060 --> 00:01:19,380
fewer characters in a said git commit

00:01:18,210 --> 00:01:20,729
you make a small amount of change and

00:01:19,380 --> 00:01:21,869
then a lot of stuff can happen in the

00:01:20,729 --> 00:01:23,580
background so there's a lot of

00:01:21,869 --> 00:01:27,509
mechanical advantage to being able to

00:01:23,580 --> 00:01:30,540
describe a whole cloud setup in a single

00:01:27,509 --> 00:01:31,560
line of yeah more but you do have to

00:01:30,540 --> 00:01:34,500
hope that you type it correctly right

00:01:31,560 --> 00:01:36,030
because that feedback loop of making a

00:01:34,500 --> 00:01:38,400
change here and waiting for co2

00:01:36,030 --> 00:01:39,720
propagated out into cloud is very long

00:01:38,400 --> 00:01:41,070
and now there's layers of abstraction

00:01:39,720 --> 00:01:45,840
which are hiding all kinds of

00:01:41,070 --> 00:01:48,240
information from you so being able to

00:01:45,840 --> 00:01:49,740
edit test code is really fast rate but

00:01:48,240 --> 00:01:51,149
changing configuration seems to be

00:01:49,740 --> 00:01:52,770
relatively slow and it seems kind of

00:01:51,149 --> 00:01:53,970
fraud and so I'm kind of curious what's

00:01:52,770 --> 00:01:56,850
up with that

00:01:53,970 --> 00:01:59,460
so I've observed lots of configuration

00:01:56,850 --> 00:02:01,110
change related outages last year

00:01:59,460 --> 00:02:02,759
particularly which kind of reaffirmed

00:02:01,110 --> 00:02:05,189
this belief I've had the configuration

00:02:02,759 --> 00:02:08,190
is kind of dangerous and so we saw in

00:02:05,189 --> 00:02:10,470
the first half of last year a lot of

00:02:08,190 --> 00:02:13,600
public clouds had big outages and not

00:02:10,470 --> 00:02:14,890
just clouds but also vendors so here's a

00:02:13,600 --> 00:02:16,480
a bunch of post-mortems are available

00:02:14,890 --> 00:02:19,420
publicly also incidents reports you

00:02:16,480 --> 00:02:20,800
might call them where configuration is

00:02:19,420 --> 00:02:24,960
being rolled out and an outage occurs

00:02:20,800 --> 00:02:28,270
and sometimes we get to see that it's um

00:02:24,960 --> 00:02:29,650
well we see side effects of

00:02:28,270 --> 00:02:32,650
configuration changes we didn't we

00:02:29,650 --> 00:02:34,600
didn't expect things to happen sometimes

00:02:32,650 --> 00:02:36,310
DNS is the root cause right the DNS is

00:02:34,600 --> 00:02:40,390
changing DNS is also a configuration of

00:02:36,310 --> 00:02:43,510
a sort again overloads as a result of

00:02:40,390 --> 00:02:44,650
side effects we didn't expect and then

00:02:43,510 --> 00:02:46,300
sometimes it feels like there's just

00:02:44,650 --> 00:02:47,530
this lack of rigor like if only we'd

00:02:46,300 --> 00:02:49,720
done a little bit more testing before we

00:02:47,530 --> 00:02:53,110
deployed it to make sure that change had

00:02:49,720 --> 00:02:54,490
works as expected the if we don't do

00:02:53,110 --> 00:02:57,870
that sometimes the severity or the

00:02:54,490 --> 00:02:57,870
impact of an outage can be quite large

00:02:58,470 --> 00:03:02,350
and there's a taste of things that we

00:03:00,670 --> 00:03:04,480
might walk out a little bit later on

00:03:02,350 --> 00:03:06,820
where when is it configuration winners

00:03:04,480 --> 00:03:08,770
of software if we're compiling some

00:03:06,820 --> 00:03:11,440
strips into another language like wisdom

00:03:08,770 --> 00:03:16,180
is that now configuration or is it now

00:03:11,440 --> 00:03:18,540
code is a program that describes how to

00:03:16,180 --> 00:03:20,950
do matching and say a web firewall a

00:03:18,540 --> 00:03:21,940
program or is it just configuration

00:03:20,950 --> 00:03:24,430
because it's describing how to do

00:03:21,940 --> 00:03:27,690
matching so I guess that's a really

00:03:24,430 --> 00:03:30,550
tricky question because how do we define

00:03:27,690 --> 00:03:32,620
this this arbitrary distinction between

00:03:30,550 --> 00:03:35,080
these two things if I have to recompile

00:03:32,620 --> 00:03:37,480
a program and I know that that

00:03:35,080 --> 00:03:39,130
definition sucks because I don't have to

00:03:37,480 --> 00:03:40,510
recompile interpreted languages but

00:03:39,130 --> 00:03:41,830
let's say that that that's kind of my

00:03:40,510 --> 00:03:43,300
bar that if I have to recompile

00:03:41,830 --> 00:03:45,340
something then there's not configuration

00:03:43,300 --> 00:03:46,870
right that's definitely code but if I

00:03:45,340 --> 00:03:49,270
can separate my code in my config and

00:03:46,870 --> 00:03:51,430
distribute them separately maybe that's

00:03:49,270 --> 00:03:53,110
how I can tell them apart that are

00:03:51,430 --> 00:03:55,510
different release schedules and

00:03:53,110 --> 00:03:57,280
different speeds of deployment tells me

00:03:55,510 --> 00:03:58,480
how fast I can like a configuration

00:03:57,280 --> 00:04:00,790
change I can do very quickly because

00:03:58,480 --> 00:04:02,320
there's not a lot of machinery required

00:04:00,790 --> 00:04:05,290
to get it out into production but a

00:04:02,320 --> 00:04:08,530
compiled packaging up shipping that out

00:04:05,290 --> 00:04:09,400
maybe that's something different but I

00:04:08,530 --> 00:04:11,410
guess the most important thing about

00:04:09,400 --> 00:04:14,290
config is there's this abstraction that

00:04:11,410 --> 00:04:17,530
allows us to separate the details and

00:04:14,290 --> 00:04:19,359
hide a bunch of other details and a

00:04:17,530 --> 00:04:21,010
configuration once it exists is kind of

00:04:19,359 --> 00:04:22,540
hard to go away but you can really add

00:04:21,010 --> 00:04:25,270
to it very easily once once you've got

00:04:22,540 --> 00:04:27,410
that and I realize that this is a

00:04:25,270 --> 00:04:30,650
terrible definition but it's like a very

00:04:27,410 --> 00:04:33,140
muddy area a very gray area and I kind

00:04:30,650 --> 00:04:35,180
of like to explore that as well but

00:04:33,140 --> 00:04:37,190
where do we get these configurations

00:04:35,180 --> 00:04:38,390
from where do they exist in practice you

00:04:37,190 --> 00:04:40,760
know you can see them as command line

00:04:38,390 --> 00:04:42,620
flags you can see them as some files

00:04:40,760 --> 00:04:45,500
that are getting read like a dot ini'

00:04:42,620 --> 00:04:47,180
file or something etc most programs read

00:04:45,500 --> 00:04:50,090
them right most people most programs

00:04:47,180 --> 00:04:51,680
accept options some programs expect

00:04:50,090 --> 00:04:53,930
environment variables to change the way

00:04:51,680 --> 00:04:56,540
they behave and if you start up a

00:04:53,930 --> 00:04:58,400
process that accepts communications on a

00:04:56,540 --> 00:05:00,470
port like a daemon process or a server

00:04:58,400 --> 00:05:01,850
of some kind then you can interact with

00:05:00,470 --> 00:05:04,160
it right and once you start interacting

00:05:01,850 --> 00:05:05,990
with it maybe you can also tell it how

00:05:04,160 --> 00:05:08,060
you would like it to respond to the very

00:05:05,990 --> 00:05:09,380
next request like if I set an HTTP

00:05:08,060 --> 00:05:11,660
header saying please set the case

00:05:09,380 --> 00:05:13,580
control like blah then I would like you

00:05:11,660 --> 00:05:16,730
to change your behavior based on that on

00:05:13,580 --> 00:05:18,020
a case by case request so it's nice to

00:05:16,730 --> 00:05:19,580
look a little bit complicated how we

00:05:18,020 --> 00:05:20,960
define this barrier between code and

00:05:19,580 --> 00:05:23,420
configuration because it seems like we

00:05:20,960 --> 00:05:27,010
can configure a whole lot of stuff all

00:05:23,420 --> 00:05:29,510
over the place so here's some examples

00:05:27,010 --> 00:05:31,550
and I don't mean specifically

00:05:29,510 --> 00:05:32,960
environment variables as environment

00:05:31,550 --> 00:05:34,370
settings but stuff that's outside of the

00:05:32,960 --> 00:05:36,320
program that we're passing into it so

00:05:34,370 --> 00:05:37,700
parameters we can pass in parameters

00:05:36,320 --> 00:05:39,830
through the environment variables in

00:05:37,700 --> 00:05:42,860
UNIX we can pass them in as I said by

00:05:39,830 --> 00:05:44,780
reading files we can say that there are

00:05:42,860 --> 00:05:47,000
certain flags that cause behavioral

00:05:44,780 --> 00:05:48,470
change and then some flags also have to

00:05:47,000 --> 00:05:53,540
be there for the program to operate at

00:05:48,470 --> 00:05:55,040
all so we might have you know this

00:05:53,540 --> 00:05:56,810
program can't possibly function without

00:05:55,040 --> 00:05:58,670
a database so here's a flag that tells

00:05:56,810 --> 00:05:59,930
you how to find that database and that's

00:05:58,670 --> 00:06:01,910
absolutely required for it to execute

00:05:59,930 --> 00:06:03,350
correctly but then maybe we want to set

00:06:01,910 --> 00:06:05,300
the trace parameters and you can totally

00:06:03,350 --> 00:06:07,240
operate without a trace parameter

00:06:05,300 --> 00:06:10,850
setting you just don't do any tracing

00:06:07,240 --> 00:06:17,330
but if you do set it then we can set up

00:06:10,850 --> 00:06:19,340
tracing sometimes Flags

00:06:17,330 --> 00:06:21,620
sorry configuration parameters change

00:06:19,340 --> 00:06:23,990
the way in which the program responds to

00:06:21,620 --> 00:06:25,250
an action so we can say that there are

00:06:23,990 --> 00:06:26,690
parts of the program which now don't

00:06:25,250 --> 00:06:28,550
execute based on whether we turn on a

00:06:26,690 --> 00:06:30,190
flag or not and I'm going to use the

00:06:28,550 --> 00:06:32,450
word flag and configuration option

00:06:30,190 --> 00:06:36,380
interchange generally because I'm not

00:06:32,450 --> 00:06:38,330
very good at standardizing on things so

00:06:36,380 --> 00:06:40,470
a configuration flag in this case is a

00:06:38,330 --> 00:06:42,030
way of creating two different

00:06:40,470 --> 00:06:43,440
programs and it might seem either very

00:06:42,030 --> 00:06:45,690
obvious to you that that's the case or

00:06:43,440 --> 00:06:48,120
not obvious at all but it's kind of good

00:06:45,690 --> 00:06:49,980
to be explicit about this because I want

00:06:48,120 --> 00:06:51,540
you all to think about this this way by

00:06:49,980 --> 00:06:53,460
creating a flag that either turns on or

00:06:51,540 --> 00:06:57,030
off different code paths we now have two

00:06:53,460 --> 00:06:58,770
programs and you know there's a

00:06:57,030 --> 00:07:00,270
similarity here between running out of

00:06:58,770 --> 00:07:05,190
experiments and a/b testing and things

00:07:00,270 --> 00:07:06,900
like that calling things experiments or

00:07:05,190 --> 00:07:08,340
a/b tests can look a lot like

00:07:06,900 --> 00:07:10,170
configuration but like I don't really

00:07:08,340 --> 00:07:13,080
want to draw a strong distinction or or

00:07:10,170 --> 00:07:15,090
a equality between these things because

00:07:13,080 --> 00:07:16,800
I think for a thing to be called an

00:07:15,090 --> 00:07:19,230
experiment I feel like there's some

00:07:16,800 --> 00:07:20,940
rigor you know you set up a hypothesis

00:07:19,230 --> 00:07:22,410
we do some testing we get some results

00:07:20,940 --> 00:07:24,270
and stuff and I feel like rolling our

00:07:22,410 --> 00:07:25,830
configuration is not necessarily that so

00:07:24,270 --> 00:07:28,020
let's just say experiments are kind of a

00:07:25,830 --> 00:07:29,910
special case of of configuration um

00:07:28,020 --> 00:07:30,810
definitely they are configuration but

00:07:29,910 --> 00:07:32,370
they're kind of not really what I'm

00:07:30,810 --> 00:07:35,280
talking about so I spent already way too

00:07:32,370 --> 00:07:36,660
much time talking about them but there's

00:07:35,280 --> 00:07:38,400
another kind of configuration which is

00:07:36,660 --> 00:07:40,260
not just a boolean saying yes or no do

00:07:38,400 --> 00:07:42,090
the thing it's also like do the thing a

00:07:40,260 --> 00:07:44,700
certain amount there's a threshold

00:07:42,090 --> 00:07:46,560
involved let's say you set the number of

00:07:44,700 --> 00:07:48,150
connections that you can receive to a

00:07:46,560 --> 00:07:49,860
value then the comport the program

00:07:48,150 --> 00:07:51,720
suddenly changes its behavior based on

00:07:49,860 --> 00:07:53,070
the runtime condition of the program so

00:07:51,720 --> 00:07:54,600
if there's more than a thousand

00:07:53,070 --> 00:07:55,890
connections maybe you're in Craig's talk

00:07:54,600 --> 00:07:58,320
earlier where he's like we have the

00:07:55,890 --> 00:08:00,390
number of Max in flights unauthenticated

00:07:58,320 --> 00:08:02,400
ssh sessions we can have and the program

00:08:00,390 --> 00:08:05,930
Sully Bailey differently based on how

00:08:02,400 --> 00:08:08,370
many there actually are at the moment

00:08:05,930 --> 00:08:12,240
right so we depend on user behavior as

00:08:08,370 --> 00:08:13,890
well so I guess totally like my very

00:08:12,240 --> 00:08:16,350
general answer to what his configuration

00:08:13,890 --> 00:08:19,710
is it's inputs to a program which sounds

00:08:16,350 --> 00:08:21,390
a little bit scary I guess but we've act

00:08:19,710 --> 00:08:22,740
extracted as many parameters as we can

00:08:21,390 --> 00:08:25,080
from the algorithm and the program's

00:08:22,740 --> 00:08:26,460
implementing and put them somewhere and

00:08:25,080 --> 00:08:28,740
we pass them in to the program at some

00:08:26,460 --> 00:08:32,510
point and so there must be program

00:08:28,740 --> 00:08:35,490
inputs and I told you I really like

00:08:32,510 --> 00:08:37,469
computational theory so I'm gonna show

00:08:35,490 --> 00:08:40,280
you that I'm very bad at it and we're

00:08:37,469 --> 00:08:43,830
gonna go down some very rudimentary

00:08:40,280 --> 00:08:45,180
computational theory mathematics if we

00:08:43,830 --> 00:08:47,130
describe a program with a function

00:08:45,180 --> 00:08:50,430
called P and P takes inputs X and

00:08:47,130 --> 00:08:52,510
returns Y you know the the P is the

00:08:50,430 --> 00:08:56,360
program that's why you made it

00:08:52,510 --> 00:08:58,190
we can extract the parameters into a

00:08:56,360 --> 00:09:02,029
configuration called C so now P is a

00:08:58,190 --> 00:09:03,829
program that takes two inputs for given

00:09:02,029 --> 00:09:07,220
configuration and C a program still

00:09:03,829 --> 00:09:08,839
takes X and returns Y and if your

00:09:07,220 --> 00:09:11,779
program happens to be an online service

00:09:08,839 --> 00:09:14,240
then the users might not see P with C X

00:09:11,779 --> 00:09:16,399
returning why they might see Q of X and

00:09:14,240 --> 00:09:18,589
then that's actually like the C which is

00:09:16,399 --> 00:09:21,019
you the assisted man gets to program

00:09:18,589 --> 00:09:23,750
that part of the input you know this is

00:09:21,019 --> 00:09:25,490
just currying if you remember university

00:09:23,750 --> 00:09:27,529
maths sorry if you didn't do university

00:09:25,490 --> 00:09:31,130
there's a thing occurring Haskell loves

00:09:27,529 --> 00:09:32,839
it so we can change the behavior now

00:09:31,130 --> 00:09:35,990
without recompiling P we still have the

00:09:32,839 --> 00:09:37,850
same P but we've given it a new CC Prime

00:09:35,990 --> 00:09:41,149
and that's returning a new output Y

00:09:37,850 --> 00:09:43,730
Prime based on the same X right does

00:09:41,149 --> 00:09:46,940
everyone still follow good I see nodding

00:09:43,730 --> 00:09:48,170
of heads and this is not just

00:09:46,940 --> 00:09:51,769
theoretical because going back to the

00:09:48,170 --> 00:09:54,410
earlier examples if we create a config

00:09:51,769 --> 00:09:57,079
that says enable feature is true then we

00:09:54,410 --> 00:09:59,870
know that the execution path is going to

00:09:57,079 --> 00:10:01,160
go through that feature method so we

00:09:59,870 --> 00:10:02,420
have this implication that a certain bit

00:10:01,160 --> 00:10:04,130
of code was executed and if we turn it

00:10:02,420 --> 00:10:06,850
off in the configuration then the

00:10:04,130 --> 00:10:09,019
behavior of the program is different

00:10:06,850 --> 00:10:10,699
there's a formal definition for a lot

00:10:09,019 --> 00:10:11,899
this is Lac but I have a limited time so

00:10:10,699 --> 00:10:14,720
I don't really want to bore you with the

00:10:11,899 --> 00:10:15,949
definition of that there's something

00:10:14,720 --> 00:10:18,920
else that looks like this it's called an

00:10:15,949 --> 00:10:21,139
interpreter they take inputs program

00:10:18,920 --> 00:10:22,370
instructions and they walk around them

00:10:21,139 --> 00:10:24,290
doing things and then they branch around

00:10:22,370 --> 00:10:27,199
and and but they execute parts of code

00:10:24,290 --> 00:10:28,699
whether they switch and go hey there's

00:10:27,199 --> 00:10:30,079
an op so we're gonna do anything or

00:10:28,699 --> 00:10:31,579
maybe there's a jump instruction so I'll

00:10:30,079 --> 00:10:33,019
change the program counter maybe there's

00:10:31,579 --> 00:10:34,430
things that actually do real bits of

00:10:33,019 --> 00:10:37,190
work like adding things together that

00:10:34,430 --> 00:10:40,100
you can see how changing the input to

00:10:37,190 --> 00:10:41,540
this program changes the behavior and

00:10:40,100 --> 00:10:43,819
I'm gonna make the case that your

00:10:41,540 --> 00:10:44,899
program is very much like this one this

00:10:43,819 --> 00:10:46,519
is called the universal Turing machine

00:10:44,899 --> 00:10:47,810
where there is a machine that takes that

00:10:46,519 --> 00:10:49,430
all of the list of all the programs that

00:10:47,810 --> 00:10:52,180
knows how to decode those programs into

00:10:49,430 --> 00:10:55,940
actual programs and then executes them

00:10:52,180 --> 00:10:57,740
this is how compilers work and you might

00:10:55,940 --> 00:11:01,550
go hey Jamie this is kind of crazy and I

00:10:57,740 --> 00:11:02,899
say to you well consider the regular

00:11:01,550 --> 00:11:05,709
expression as a type of program because

00:11:02,899 --> 00:11:05,709
it's computable right

00:11:07,149 --> 00:11:11,050
we add constraints on our languages to

00:11:09,069 --> 00:11:12,279
make them easier to reason about or we

00:11:11,050 --> 00:11:13,990
can increase the power of those

00:11:12,279 --> 00:11:15,869
languages and make them harder to reason

00:11:13,990 --> 00:11:18,189
about but have more more flexibility so

00:11:15,869 --> 00:11:19,869
a regular expression is not a very

00:11:18,189 --> 00:11:22,329
powerful program but it's easy to

00:11:19,869 --> 00:11:26,709
understand I think unless using Pelle

00:11:22,329 --> 00:11:28,449
compatible regular expressions okay da

00:11:26,709 --> 00:11:29,709
da here's another program you need the

00:11:28,449 --> 00:11:34,389
right interpreter obviously but you can

00:11:29,709 --> 00:11:35,980
tell the program in llamo so I want to

00:11:34,389 --> 00:11:38,619
be very specific about this if you make

00:11:35,980 --> 00:11:40,269
a program that's not flexible it's not a

00:11:38,619 --> 00:11:41,980
general-purpose programming language but

00:11:40,269 --> 00:11:44,920
it still does stuff based on the input

00:11:41,980 --> 00:11:46,300
you give it to then by writing a program

00:11:44,920 --> 00:11:47,980
that can sorry by writing a

00:11:46,300 --> 00:11:49,269
configuration URL writing a program that

00:11:47,980 --> 00:11:51,249
configures that program so their

00:11:49,269 --> 00:11:53,199
programs their program so you can

00:11:51,249 --> 00:11:54,610
perform arbitrary can plot computation

00:11:53,199 --> 00:11:56,110
within the domain of whatever your P is

00:11:54,610 --> 00:11:59,920
supposed to there right and this is all

00:11:56,110 --> 00:12:01,329
very fine in theory InfoSec I've shown

00:11:59,920 --> 00:12:02,649
it in the last couple of years also the

00:12:01,329 --> 00:12:03,999
none of this is true like we can make

00:12:02,649 --> 00:12:09,040
the programs do whatever they like even

00:12:03,999 --> 00:12:11,049
if there weren't supposed to do them ok

00:12:09,040 --> 00:12:12,369
so the idea is that if you can prove

00:12:11,049 --> 00:12:13,629
that your program terminates under

00:12:12,369 --> 00:12:14,589
certain conditions then it has certain

00:12:13,629 --> 00:12:16,329
properties like it's a regular

00:12:14,589 --> 00:12:17,619
expression where you can say stuff like

00:12:16,329 --> 00:12:18,730
that if we can't prove that it

00:12:17,619 --> 00:12:20,889
terminates then we know it's like

00:12:18,730 --> 00:12:22,449
assuring equivalent program so we

00:12:20,889 --> 00:12:23,769
weren't a reducible if it's possible to

00:12:22,449 --> 00:12:25,179
reduce the strength of program to make

00:12:23,769 --> 00:12:28,089
it under easy to understand then it's

00:12:25,179 --> 00:12:30,970
still programming right likewise your

00:12:28,089 --> 00:12:31,809
program is an interpreter and all of

00:12:30,970 --> 00:12:33,970
that was trying to get to this point

00:12:31,809 --> 00:12:36,009
right it's not a very good one and the

00:12:33,970 --> 00:12:37,449
language is kind of weird the

00:12:36,009 --> 00:12:39,429
configuration is code not just

00:12:37,449 --> 00:12:40,420
configuration as code which people have

00:12:39,429 --> 00:12:42,429
been talking about on time the

00:12:40,420 --> 00:12:45,549
configuration is in fact the same as

00:12:42,429 --> 00:12:47,170
code people have dismissed configuration

00:12:45,549 --> 00:12:48,399
is not really programming am i really

00:12:47,170 --> 00:12:50,499
programming in yam all that sounds

00:12:48,399 --> 00:12:52,509
ridiculous old flame you on Twitter

00:12:50,499 --> 00:12:54,369
the I Triple E taught programming

00:12:52,509 --> 00:12:55,689
languages report last year says the HTML

00:12:54,369 --> 00:12:57,160
is totally a programming language and

00:12:55,689 --> 00:12:59,589
don't get bogged down in the details

00:12:57,160 --> 00:13:01,869
that people don't have conditionals or

00:12:59,589 --> 00:13:04,360
branching or loop instructions in HTML

00:13:01,869 --> 00:13:06,040
because that seems very elitist and I

00:13:04,360 --> 00:13:07,209
agree with them so don't let anyone tell

00:13:06,040 --> 00:13:11,170
you that you're not programming if

00:13:07,209 --> 00:13:12,610
you're writing HTML there's also against

00:13:11,170 --> 00:13:14,049
the laws or programming to talk about

00:13:12,610 --> 00:13:17,320
any of this stuff and not mention the

00:13:14,049 --> 00:13:19,720
Philippines funds what is a 10th law

00:13:17,320 --> 00:13:21,070
tenth rule you get to this point right

00:13:19,720 --> 00:13:24,730
your program now contains a fully

00:13:21,070 --> 00:13:26,800
implemented version of Lisp and so I

00:13:24,730 --> 00:13:28,450
gotta ask why is Lisp a good choice

00:13:26,800 --> 00:13:30,340
why do glue scheme people for the last

00:13:28,450 --> 00:13:32,470
thirty years or at least as long as I

00:13:30,340 --> 00:13:33,790
remember it's being saying hey scheme is

00:13:32,470 --> 00:13:37,240
a really good fun configuration language

00:13:33,790 --> 00:13:38,410
we should all use it so here's an

00:13:37,240 --> 00:13:42,280
example right we can write a program

00:13:38,410 --> 00:13:43,600
that emits a topple that says this is

00:13:42,280 --> 00:13:45,610
what the configuration should end up

00:13:43,600 --> 00:13:50,200
looking like and this is a very trivial

00:13:45,610 --> 00:13:52,360
example but we can imagine writing a sum

00:13:50,200 --> 00:13:53,560
this program that generates like takes a

00:13:52,360 --> 00:13:54,520
whole bunch of other imports iterates

00:13:53,560 --> 00:13:56,500
over suffering jenna is a very

00:13:54,520 --> 00:13:58,720
complicated couple that expresses a

00:13:56,500 --> 00:14:00,190
configuration and it's quite possible

00:13:58,720 --> 00:14:01,600
now because this is a computer

00:14:00,190 --> 00:14:04,750
programming language that we can inject

00:14:01,600 --> 00:14:08,080
parrot parameters externally to this new

00:14:04,750 --> 00:14:09,400
program or you can inject code into it

00:14:08,080 --> 00:14:12,130
at runtime and call that as a callback

00:14:09,400 --> 00:14:13,360
which sounds a little bit terrifying but

00:14:12,130 --> 00:14:15,040
you know you can have very complex data

00:14:13,360 --> 00:14:18,760
types including stuff that is executable

00:14:15,040 --> 00:14:20,350
code so I've been asked should have been

00:14:18,760 --> 00:14:22,000
less but I went and found a study that

00:14:20,350 --> 00:14:23,890
was done inside Google and it's kind of

00:14:22,000 --> 00:14:26,140
an active document and at the point I

00:14:23,890 --> 00:14:29,680
read it it said that there is a lot of

00:14:26,140 --> 00:14:31,530
dear cells inside of Google there's the

00:14:29,680 --> 00:14:33,790
big four that everyone talks about and

00:14:31,530 --> 00:14:35,290
then there's all of the other ones that

00:14:33,790 --> 00:14:40,690
people have written to try and solve the

00:14:35,290 --> 00:14:42,250
domain-specific languages many of these

00:14:40,690 --> 00:14:43,540
languages are chewing equivalent and

00:14:42,250 --> 00:14:46,570
they're designed to emit protocol

00:14:43,540 --> 00:14:48,130
buffers and some of them are executed

00:14:46,570 --> 00:14:49,900
within the address space of the program

00:14:48,130 --> 00:14:51,610
that receives them sometimes they're

00:14:49,900 --> 00:14:52,930
executed inside the CI pipeline to

00:14:51,610 --> 00:14:55,590
generate a static configuration that

00:14:52,930 --> 00:14:57,520
then gets shipped off and and loaded up

00:14:55,590 --> 00:14:58,780
so there's all different ways of

00:14:57,520 --> 00:15:01,510
handling this but there's there's a lot

00:14:58,780 --> 00:15:03,820
of different ways of expressing intent

00:15:01,510 --> 00:15:06,070
in different programming languages and

00:15:03,820 --> 00:15:08,230
this fellow Mike hadlow wrote about this

00:15:06,070 --> 00:15:11,770
many years ago 2012 according to his

00:15:08,230 --> 00:15:13,360
blog URL so you start this is called the

00:15:11,770 --> 00:15:14,800
configuration complexity clock and you

00:15:13,360 --> 00:15:16,120
start with a hard-coded value in your

00:15:14,800 --> 00:15:18,400
program and then you extract it to a

00:15:16,120 --> 00:15:19,360
flag and then you go wow I really don't

00:15:18,400 --> 00:15:22,030
like flags I'm gonna write a

00:15:19,360 --> 00:15:25,089
configuration file and then you go like

00:15:22,030 --> 00:15:27,129
a rules engine where I can generate more

00:15:25,089 --> 00:15:28,629
higher-level intent for what I want and

00:15:27,129 --> 00:15:29,889
then you realize the rules engine is no

00:15:28,629 --> 00:15:31,540
longer satisfactory I'd like to have a

00:15:29,889 --> 00:15:33,939
full DSL

00:15:31,540 --> 00:15:37,089
I need conditionals and branches and so

00:15:33,939 --> 00:15:39,939
forth and because it's very easy at that

00:15:37,089 --> 00:15:42,610
point then to add this stuff and so you

00:15:39,939 --> 00:15:44,319
can see how this relates back to sorry I

00:15:42,610 --> 00:15:46,689
forgot to introduce this as Chomsky's

00:15:44,319 --> 00:15:47,939
language hierarchy he says type 4

00:15:46,689 --> 00:15:49,930
irregularly anguish is a very

00:15:47,939 --> 00:15:53,019
constrained and easy to understand and

00:15:49,930 --> 00:15:54,670
type 0 recursively enumerable very

00:15:53,019 --> 00:15:56,889
difficult to understand in a general

00:15:54,670 --> 00:15:58,360
sense but if we increase the power of

00:15:56,889 --> 00:16:00,189
our languages allow us to do more things

00:15:58,360 --> 00:16:02,379
that we're moving up this hierarchy and

00:16:00,189 --> 00:16:04,509
if we remove the ability to do things

00:16:02,379 --> 00:16:06,639
easily constrain the languages more than

00:16:04,509 --> 00:16:08,230
we're moving back inside so this

00:16:06,639 --> 00:16:13,209
progression around like headless clock

00:16:08,230 --> 00:16:15,279
is increasing the language power but why

00:16:13,209 --> 00:16:18,189
actually see in practice is not a clock

00:16:15,279 --> 00:16:19,749
but a spiral of death where we start

00:16:18,189 --> 00:16:22,089
without thinking we end up with our DSL

00:16:19,749 --> 00:16:25,449
and then what we do is we create another

00:16:22,089 --> 00:16:28,749
language on top of that so imagine

00:16:25,449 --> 00:16:30,220
you've got you know you don't you don't

00:16:28,749 --> 00:16:31,749
remove the DSL anymore you still got

00:16:30,220 --> 00:16:33,009
that on a lower layer but you've got

00:16:31,749 --> 00:16:34,420
several systems they're all need

00:16:33,009 --> 00:16:35,860
configuring and there's some value that

00:16:34,420 --> 00:16:38,620
they need to share between these

00:16:35,860 --> 00:16:40,089
multiple systems so what you do is you

00:16:38,620 --> 00:16:42,999
create a boom your program that writes

00:16:40,089 --> 00:16:45,100
that value say google call it compile

00:16:42,999 --> 00:16:46,360
time so it generates a drinksy IM rights

00:16:45,100 --> 00:16:48,639
health configuration files for both

00:16:46,360 --> 00:16:51,189
systems and then you realize that that's

00:16:48,639 --> 00:16:53,050
an adaptive value so what we need is

00:16:51,189 --> 00:16:54,639
another program that reads something and

00:16:53,050 --> 00:16:56,679
then computes it and does it dynamically

00:16:54,639 --> 00:16:59,829
and then you have a service that is

00:16:56,679 --> 00:17:02,230
emitting these configuration files with

00:16:59,829 --> 00:17:03,399
on our five-minute Lea basis perhaps and

00:17:02,230 --> 00:17:04,480
then you need to abstract the top of

00:17:03,399 --> 00:17:05,529
that so you build another system on top

00:17:04,480 --> 00:17:06,789
of that was program this system and a

00:17:05,529 --> 00:17:08,470
bunch of other systems the programming

00:17:06,789 --> 00:17:10,750
systems and this is a common pattern

00:17:08,470 --> 00:17:13,449
inside of Google and I've also noticed

00:17:10,750 --> 00:17:15,990
that it is a common outside of Google

00:17:13,449 --> 00:17:18,189
because with terraform you can create

00:17:15,990 --> 00:17:20,380
thousands of nodes and then execute

00:17:18,189 --> 00:17:22,000
puppet on all of those nodes and puppet

00:17:20,380 --> 00:17:24,279
is going to execute some more GS code

00:17:22,000 --> 00:17:28,240
that is going to go and edit sinful

00:17:24,279 --> 00:17:29,500
Cemil configuration and I realize that

00:17:28,240 --> 00:17:32,970
joke might go over your heads because

00:17:29,500 --> 00:17:32,970
nobody runs mail servers anymore

00:17:35,179 --> 00:17:39,929
so I mentioned before that configuration

00:17:37,649 --> 00:17:43,710
has two users I'm not sure if I actually

00:17:39,929 --> 00:17:45,270
did but note that it does there's the

00:17:43,710 --> 00:17:48,270
person who writes the C in the person

00:17:45,270 --> 00:17:50,039
who writes the X so there's the

00:17:48,270 --> 00:17:53,990
administrator that's us and then there's

00:17:50,039 --> 00:17:53,990
the user and they have different roles

00:17:55,460 --> 00:17:58,770
so you can perform arbitrary

00:17:57,149 --> 00:18:00,270
computations within the scope of

00:17:58,770 --> 00:18:03,480
whatever your program P is supposed to

00:18:00,270 --> 00:18:04,980
do right so even though it's not sure

00:18:03,480 --> 00:18:07,080
and complete there's still possibly a

00:18:04,980 --> 00:18:09,240
large set of functionality it's capable

00:18:07,080 --> 00:18:11,490
of computing capable of computing so

00:18:09,240 --> 00:18:13,320
I've got to ask now what is the size of

00:18:11,490 --> 00:18:15,840
the input of this function what is the

00:18:13,320 --> 00:18:18,690
domain of P if you recall I think year

00:18:15,840 --> 00:18:20,309
10 year 9 mathematics or in a no less

00:18:18,690 --> 00:18:21,929
mathematical way how many different

00:18:20,309 --> 00:18:24,929
possible configurations do you have and

00:18:21,929 --> 00:18:26,010
in a mathematical way the number of

00:18:24,929 --> 00:18:28,590
options you have in your configuration

00:18:26,010 --> 00:18:29,880
is like the size of that set and then

00:18:28,590 --> 00:18:31,200
how many different values could all of

00:18:29,880 --> 00:18:33,720
those different options have and that is

00:18:31,200 --> 00:18:35,460
the Cartesian product of that set which

00:18:33,720 --> 00:18:36,600
is just multiply out the total number of

00:18:35,460 --> 00:18:38,909
things by each other so if you've got

00:18:36,600 --> 00:18:41,059
boolean says 2 right multiply it out by

00:18:38,909 --> 00:18:43,260
how many bullying's you have if you have

00:18:41,059 --> 00:18:44,789
flags that take integers right how many

00:18:43,260 --> 00:18:46,230
values can any did you take multiply

00:18:44,789 --> 00:18:47,970
that out if you have strings then

00:18:46,230 --> 00:18:52,770
there's it seems like an infinitely many

00:18:47,970 --> 00:18:54,149
bunch of them I want to kind of get to

00:18:52,770 --> 00:18:55,770
the point that this is seems like a very

00:18:54,149 --> 00:18:57,450
large number a number of knobs with a

00:18:55,770 --> 00:18:59,399
lot of different settings so what's the

00:18:57,450 --> 00:19:01,950
number of permutations of knobs in the

00:18:59,399 --> 00:19:06,690
concrete of the space shuttle does

00:19:01,950 --> 00:19:08,669
anyone know good nobody knows all right

00:19:06,690 --> 00:19:10,260
so the idea behind this whole talk is

00:19:08,669 --> 00:19:12,750
that configuration is really hard it's

00:19:10,260 --> 00:19:14,669
like code it has large force multipliers

00:19:12,750 --> 00:19:17,850
and empirically it's the cause of many

00:19:14,669 --> 00:19:19,860
outages so if I go looking will I find

00:19:17,850 --> 00:19:22,200
the configuration is a key factor in the

00:19:19,860 --> 00:19:24,000
majority of late outages that are

00:19:22,200 --> 00:19:25,789
related to change and we'll look

00:19:24,000 --> 00:19:28,770
correlate with higher severity outages

00:19:25,789 --> 00:19:30,000
so I mean look at the research and

00:19:28,770 --> 00:19:32,419
there's a bunch of there's a small

00:19:30,000 --> 00:19:34,890
number of bits of research about this

00:19:32,419 --> 00:19:36,299
and a lot of them are kind of

00:19:34,890 --> 00:19:39,299
unsatisfactory because they rely on

00:19:36,299 --> 00:19:41,700
public results and people are not really

00:19:39,299 --> 00:19:43,169
keen to share the reasons for the actual

00:19:41,700 --> 00:19:47,000
outage and they write publicly

00:19:43,169 --> 00:19:50,760
digestible incident reports

00:19:47,000 --> 00:19:52,160
so this one it says configuration is

00:19:50,760 --> 00:19:54,510
about fits in the ranking

00:19:52,160 --> 00:19:56,700
it says about 10% of root causes are

00:19:54,510 --> 00:19:59,059
related to configuration if you limit to

00:19:56,700 --> 00:20:02,490
only change related causes then

00:19:59,059 --> 00:20:04,380
configuration change is the third but

00:20:02,490 --> 00:20:06,570
only classified an outage if to use the

00:20:04,380 --> 00:20:07,890
explicit words they're looking for and

00:20:06,570 --> 00:20:10,860
they only classified a singular root

00:20:07,890 --> 00:20:12,270
cause which I feel like is not very in

00:20:10,860 --> 00:20:17,160
line with best practice in the industry

00:20:12,270 --> 00:20:19,230
at this point in time then there's

00:20:17,160 --> 00:20:21,150
another one that Microsoft did which is

00:20:19,230 --> 00:20:23,429
entirely based around the root cause of

00:20:21,150 --> 00:20:25,650
bugs that were introduced as software

00:20:23,429 --> 00:20:26,610
defects so has all the terminology is

00:20:25,650 --> 00:20:29,540
incorrect because they're actually

00:20:26,610 --> 00:20:32,429
measuring something totally different

00:20:29,540 --> 00:20:33,809
the sre book said that 70% of outages

00:20:32,429 --> 00:20:35,130
are due to changes in the life system

00:20:33,809 --> 00:20:36,809
and then didn't go on to explain

00:20:35,130 --> 00:20:40,380
anything about what to break down

00:20:36,809 --> 00:20:42,600
between code and configuration is and

00:20:40,380 --> 00:20:44,880
like that's it the entire mention in the

00:20:42,600 --> 00:20:48,530
book is that is that and then there was

00:20:44,880 --> 00:20:50,640
a blog post early last year which

00:20:48,530 --> 00:20:52,440
classifies based on what the trigger is

00:20:50,640 --> 00:20:55,860
for a bunch of outages how many did it

00:20:52,440 --> 00:20:57,510
do a large number it doesn't explain his

00:20:55,860 --> 00:20:58,920
methodology or the data it didn't share

00:20:57,510 --> 00:21:01,559
the data set but it came up with like

00:20:58,920 --> 00:21:04,590
five observations of all these outages

00:21:01,559 --> 00:21:07,559
and said the change was about one third

00:21:04,590 --> 00:21:12,059
of them and config drift was about one

00:21:07,559 --> 00:21:13,110
fifth so I like that the author did a

00:21:12,059 --> 00:21:15,330
lot of research but they didn't really

00:21:13,110 --> 00:21:18,600
share a lot of their method so it's

00:21:15,330 --> 00:21:20,700
tricky to reproduce and then there's

00:21:18,600 --> 00:21:22,559
this other one from July in 2019 which

00:21:20,700 --> 00:21:25,350
read 49 public outages and came up with

00:21:22,559 --> 00:21:26,490
yeah you can read the slide it's not

00:21:25,350 --> 00:21:27,840
very many attributed to miss

00:21:26,490 --> 00:21:30,000
configuration there's a bunch of to

00:21:27,840 --> 00:21:33,780
human error which I'm like not really

00:21:30,000 --> 00:21:35,309
cool and then there's a publicly updated

00:21:33,780 --> 00:21:37,980
github which has a bunch of post mortems

00:21:35,309 --> 00:21:39,809
on it it's about 200 there manually

00:21:37,980 --> 00:21:41,309
added to the end of the list and then

00:21:39,809 --> 00:21:42,480
someone else goes in triage ISM an atom

00:21:41,309 --> 00:21:44,190
somewhere else

00:21:42,480 --> 00:21:47,070
so I'm categorized has a very large

00:21:44,190 --> 00:21:48,179
number which is no excu the

00:21:47,070 --> 00:21:54,000
configuration is ranked second behind

00:21:48,179 --> 00:21:55,110
that which is which is kind of I like

00:21:54,000 --> 00:21:57,030
that because that's what I'm looking for

00:21:55,110 --> 00:21:58,050
and you know how people are biased was

00:21:57,030 --> 00:22:00,260
looking for the things they're expecting

00:21:58,050 --> 00:22:00,260
to find

00:22:00,370 --> 00:22:05,500
so I did my own research I went to the

00:22:02,500 --> 00:22:06,970
SRA weekly newsletter which is you can

00:22:05,500 --> 00:22:10,480
subscribe online and you send you an

00:22:06,970 --> 00:22:12,280
email every week so I tried to do a

00:22:10,480 --> 00:22:13,540
manual analysis they at the end of the

00:22:12,280 --> 00:22:15,040
newsletter they have here the outages

00:22:13,540 --> 00:22:17,500
that occurred this week linked to a news

00:22:15,040 --> 00:22:20,050
article or a public incident report so I

00:22:17,500 --> 00:22:23,350
went through and read all of them until

00:22:20,050 --> 00:22:26,080
I got really bored because terrible so I

00:22:23,350 --> 00:22:29,230
ended up reading about 87 links 46 of

00:22:26,080 --> 00:22:30,910
them were to accompany status page 41 to

00:22:29,230 --> 00:22:32,679
news articles news articles are terrible

00:22:30,910 --> 00:22:34,420
by the way because they tend to say the

00:22:32,679 --> 00:22:35,770
service went down people were angry on

00:22:34,420 --> 00:22:38,460
Twitter here's a screenshot of down

00:22:35,770 --> 00:22:40,210
detector saying that it was in fact down

00:22:38,460 --> 00:22:41,800
and so you don't actually get to

00:22:40,210 --> 00:22:43,210
understand why the outage occurred other

00:22:41,800 --> 00:22:46,600
than people were super unhappy that say

00:22:43,210 --> 00:22:48,370
Instagram wasn't working sixty two of

00:22:46,600 --> 00:22:50,020
those 87 didn't give it any description

00:22:48,370 --> 00:22:53,559
of anything that might even be

00:22:50,020 --> 00:22:55,090
interpreted as a cause or a trigger six

00:22:53,559 --> 00:22:56,559
of them said that the change or a deploy

00:22:55,090 --> 00:22:59,260
was the cause and three said it was a

00:22:56,559 --> 00:23:01,390
configuration change six of them were

00:22:59,260 --> 00:23:03,190
nice to read because they actually told

00:23:01,390 --> 00:23:06,910
me like a whole story about what was

00:23:03,190 --> 00:23:11,830
going on and I've got down here GCP

00:23:06,910 --> 00:23:17,350
number 187 talkbox Mons Oh whatsapp and

00:23:11,830 --> 00:23:19,120
a Heroku and read it so I like them I

00:23:17,350 --> 00:23:21,429
also note that a bunch of the ones I

00:23:19,120 --> 00:23:23,920
just named also did really terrible ones

00:23:21,429 --> 00:23:25,330
so okay it's kind of hidden mess I feel

00:23:23,920 --> 00:23:27,010
like the industry generally should get

00:23:25,330 --> 00:23:29,410
better somehow but I don't actually know

00:23:27,010 --> 00:23:30,790
how we're going to manifest that anyway

00:23:29,410 --> 00:23:32,140
so I was like this is really

00:23:30,790 --> 00:23:34,170
disappointing but I've also got one

00:23:32,140 --> 00:23:36,850
other data set available to me which is

00:23:34,170 --> 00:23:38,770
Google's internal post-mortem database

00:23:36,850 --> 00:23:40,900
and inside that database

00:23:38,770 --> 00:23:46,090
everyone classifies the outages as they

00:23:40,900 --> 00:23:48,790
occur roughly so it's about several

00:23:46,090 --> 00:23:52,420
thousand of reports multiple-choice

00:23:48,790 --> 00:23:54,490
classification of causes and triggers so

00:23:52,420 --> 00:23:56,559
it measures country pushes binary pushes

00:23:54,490 --> 00:23:57,610
both sorry my research I went and

00:23:56,559 --> 00:24:00,309
counted the ones that said they were

00:23:57,610 --> 00:24:01,630
config push triggered and caused binary

00:24:00,309 --> 00:24:02,650
push triggered and caused the ones that

00:24:01,630 --> 00:24:04,270
were both and the ones that will neither

00:24:02,650 --> 00:24:05,830
and then I found that very

00:24:04,270 --> 00:24:07,240
disappointingly config and binary

00:24:05,830 --> 00:24:10,450
related pushes are about the same size

00:24:07,240 --> 00:24:12,550
and configure is only slightly higher

00:24:10,450 --> 00:24:13,250
the binary in a not especially

00:24:12,550 --> 00:24:15,320
statistically

00:24:13,250 --> 00:24:17,450
significant way in the big severity

00:24:15,320 --> 00:24:23,390
outage and then year-over-year thank you

00:24:17,450 --> 00:24:24,680
it got slightly higher up until 2018 and

00:24:23,390 --> 00:24:28,250
the patent reverse and I can't explain

00:24:24,680 --> 00:24:30,230
why so it needs more investigation I'm

00:24:28,250 --> 00:24:32,150
sorry the results of basically I can't

00:24:30,230 --> 00:24:33,710
tell whether I was right or not it seems

00:24:32,150 --> 00:24:35,240
like I'm still roughly right because I

00:24:33,710 --> 00:24:36,800
can't prove myself wrong but on the

00:24:35,240 --> 00:24:39,470
other hand unsatisfying lis I can't

00:24:36,800 --> 00:24:41,060
really prove myself right either so now

00:24:39,470 --> 00:24:43,040
I've got a new question is Google an

00:24:41,060 --> 00:24:45,410
outlier or is this still indicative of

00:24:43,040 --> 00:24:46,550
the industry generally so I'm going I

00:24:45,410 --> 00:24:48,560
don't know I don't know how to answer

00:24:46,550 --> 00:24:51,200
that question but I can go and see what

00:24:48,560 --> 00:24:52,610
we do and so I want to tell you now some

00:24:51,200 --> 00:24:54,980
mitigations for the risk of

00:24:52,610 --> 00:24:56,810
configuration rollout and the idea

00:24:54,980 --> 00:24:58,670
basically is going well configuration is

00:24:56,810 --> 00:25:00,470
codes so if you are treating a

00:24:58,670 --> 00:25:03,410
configuration differently than card then

00:25:00,470 --> 00:25:05,030
you can't be doing it right so let's

00:25:03,410 --> 00:25:08,630
learn what we did with code and then

00:25:05,030 --> 00:25:11,210
apply that to configuration so there's

00:25:08,630 --> 00:25:13,310
another great paper which was from OSD I

00:25:11,210 --> 00:25:14,570
2014 that says that basically no one

00:25:13,310 --> 00:25:15,860
tests very well so there's a lot of

00:25:14,570 --> 00:25:18,800
low-hanging fruit if you just want to

00:25:15,860 --> 00:25:20,090
raise your early CI testing just that

00:25:18,800 --> 00:25:21,680
little bit and the whole lot of

00:25:20,090 --> 00:25:23,240
low-hanging fruit it turns out there's

00:25:21,680 --> 00:25:24,590
lots of outages that could be saved if

00:25:23,240 --> 00:25:27,740
you just did a little bit extra of

00:25:24,590 --> 00:25:29,260
testing simple pars tests or validate

00:25:27,740 --> 00:25:32,930
that the configuration contains the

00:25:29,260 --> 00:25:34,370
values you expect now obviously if you

00:25:32,930 --> 00:25:35,690
have a configuration file that is not

00:25:34,370 --> 00:25:37,280
true and complete you need to write

00:25:35,690 --> 00:25:40,310
another program that reads in that

00:25:37,280 --> 00:25:41,840
config and tests values and this is

00:25:40,310 --> 00:25:43,190
actually really easy because if you've

00:25:41,840 --> 00:25:45,770
got a yam L file you guys read the

00:25:43,190 --> 00:25:48,050
animal and then say all the number of

00:25:45,770 --> 00:25:50,000
connections should be higher than the

00:25:48,050 --> 00:25:51,680
value in the other service you know

00:25:50,000 --> 00:25:53,840
simple validations test whole bunch of

00:25:51,680 --> 00:25:55,010
stuff together but if you do have your

00:25:53,840 --> 00:25:56,090
incomplete language there maybe you just

00:25:55,010 --> 00:25:57,740
throw some asserts you gotta execute

00:25:56,090 --> 00:26:00,440
this program and if it follows the certs

00:25:57,740 --> 00:26:02,840
then it can't be valid and this is great

00:26:00,440 --> 00:26:04,730
if you are actually omitting values and

00:26:02,840 --> 00:26:06,110
testing things and you go I should never

00:26:04,730 --> 00:26:08,060
be negative so let's just make sure it

00:26:06,110 --> 00:26:10,130
never is negative and then somebody can

00:26:08,060 --> 00:26:11,930
program something that you know doesn't

00:26:10,130 --> 00:26:13,070
in rollover and all of a sudden things

00:26:11,930 --> 00:26:16,060
are broken at least you caught that

00:26:13,070 --> 00:26:16,060
before it went out into production

00:26:16,180 --> 00:26:22,310
version control and it might seem like a

00:26:20,660 --> 00:26:24,530
crazy idea but if we're talking about

00:26:22,310 --> 00:26:26,570
configuration as code one of the central

00:26:24,530 --> 00:26:27,860
feces of that idea is we'll put the

00:26:26,570 --> 00:26:29,480
figuration in version control and we'll

00:26:27,860 --> 00:26:31,070
do code review and look at it and roll

00:26:29,480 --> 00:26:33,799
it out through CI CA and all that client

00:26:31,070 --> 00:26:35,450
stuff right so code review and being

00:26:33,799 --> 00:26:38,509
able to review why things occurred is

00:26:35,450 --> 00:26:40,549
really good because it helps you resolve

00:26:38,509 --> 00:26:42,470
incidents faster if you're committing

00:26:40,549 --> 00:26:43,789
into a database that has logs of reviews

00:26:42,470 --> 00:26:45,710
and in the description of why it

00:26:43,789 --> 00:26:48,230
happened then you can understand quicker

00:26:45,710 --> 00:26:49,370
why something happened and Craig

00:26:48,230 --> 00:26:50,720
mentioned this earlier it's like you

00:26:49,370 --> 00:26:52,220
know something really good is being able

00:26:50,720 --> 00:26:53,600
to write a comment when we change a

00:26:52,220 --> 00:26:55,700
value saying the reason we change this

00:26:53,600 --> 00:26:58,399
value is because we noticed that the

00:26:55,700 --> 00:27:00,350
performance and service was degraded or

00:26:58,399 --> 00:27:02,720
the capacity of the system the user

00:27:00,350 --> 00:27:04,129
demand was much higher so being able to

00:27:02,720 --> 00:27:05,330
go back in time and say oh I know I

00:27:04,129 --> 00:27:08,600
understand why people made that change

00:27:05,330 --> 00:27:11,539
means that you have more understanding

00:27:08,600 --> 00:27:13,220
right I've also put running a command

00:27:11,539 --> 00:27:14,870
against an API endpoint because so many

00:27:13,220 --> 00:27:17,360
times people go well you know what I'm

00:27:14,870 --> 00:27:18,799
just gonna run my school admin do the

00:27:17,360 --> 00:27:23,990
thing and set the number of connections

00:27:18,799 --> 00:27:26,870
dynamically at runtime that's not great

00:27:23,990 --> 00:27:29,929
I feel because there's no way of doing

00:27:26,870 --> 00:27:31,970
audits or change history on that so if

00:27:29,929 --> 00:27:33,500
you have to run a command to make a

00:27:31,970 --> 00:27:35,149
change against an API then write a

00:27:33,500 --> 00:27:39,379
script that runs that command and stick

00:27:35,149 --> 00:27:43,429
that in revision control it seems very

00:27:39,379 --> 00:27:44,899
old-school and you know not API II you

00:27:43,429 --> 00:27:48,200
might not do it in like a fancy new

00:27:44,899 --> 00:27:50,990
language but it's gonna be much better

00:27:48,200 --> 00:27:52,190
than saying oh here's the script deploy

00:27:50,990 --> 00:27:54,289
the thing and then also run these

00:27:52,190 --> 00:27:55,759
commands manually and I find also for

00:27:54,289 --> 00:27:57,379
there's been some outages where someone

00:27:55,759 --> 00:27:59,600
goes I'm just going to run it the test

00:27:57,379 --> 00:28:01,519
maybe I'll just delete these this

00:27:59,600 --> 00:28:03,440
setting and it's totally safe to do

00:28:01,519 --> 00:28:05,960
because the system will protect me from

00:28:03,440 --> 00:28:07,309
itself and it never does and then all of

00:28:05,960 --> 00:28:08,539
a sudden there's an outage and trying to

00:28:07,309 --> 00:28:09,649
figure out why the outages occurred

00:28:08,539 --> 00:28:11,840
because all of a sudden in this

00:28:09,649 --> 00:28:13,879
particular setting thank you doesn't

00:28:11,840 --> 00:28:15,350
exist anymore is really really hard for

00:28:13,879 --> 00:28:16,669
people who are on call and the other

00:28:15,350 --> 00:28:20,929
debuggers because nobody has any idea

00:28:16,669 --> 00:28:22,159
that the command is run okay so I've got

00:28:20,929 --> 00:28:27,320
a minute so I'm gonna run really fast

00:28:22,159 --> 00:28:28,519
shift all the testing left help what the

00:28:27,320 --> 00:28:30,049
administrators make good decisions about

00:28:28,519 --> 00:28:31,399
how they're changing configuration if

00:28:30,049 --> 00:28:34,519
there's lots of configuration it's

00:28:31,399 --> 00:28:37,549
really hard to understand so validate

00:28:34,519 --> 00:28:39,409
really early diff when things are

00:28:37,549 --> 00:28:40,190
generated against the version is in

00:28:39,409 --> 00:28:41,659
revision

00:28:40,190 --> 00:28:43,519
so you can see what the generator

00:28:41,659 --> 00:28:44,720
changes look like because people want to

00:28:43,519 --> 00:28:46,669
know that the program that they've wrote

00:28:44,720 --> 00:28:48,710
that emits config is also going to do

00:28:46,669 --> 00:28:50,210
the thing they expect it to and config

00:28:48,710 --> 00:28:51,529
formatting is totally cool as well

00:28:50,210 --> 00:28:54,379
because then you don't have to argue

00:28:51,529 --> 00:28:56,720
about alignment but also if your Yama

00:28:54,379 --> 00:28:58,370
program changes its rendering all of a

00:28:56,720 --> 00:29:04,519
sudden you understand why it's called a

00:28:58,370 --> 00:29:05,690
series of unfortunate indents staging

00:29:04,519 --> 00:29:08,090
pre-production you might be on the fence

00:29:05,690 --> 00:29:09,139
about this you want to make sure that

00:29:08,090 --> 00:29:10,460
the configuration rolling out there's a

00:29:09,139 --> 00:29:11,720
break expectation so you've got

00:29:10,460 --> 00:29:12,679
functional test running is your staging

00:29:11,720 --> 00:29:15,019
environment you're allowed to deploy

00:29:12,679 --> 00:29:16,399
stuff really fast there it can't be

00:29:15,019 --> 00:29:19,580
equivalent to production obviously and

00:29:16,399 --> 00:29:20,509
you might know charity mages the monarch

00:29:19,580 --> 00:29:22,460
of monitoring the queen bee of

00:29:20,509 --> 00:29:24,350
observability says this is a terrible

00:29:22,460 --> 00:29:26,000
idea because exactly it can't be

00:29:24,350 --> 00:29:28,100
production so don't have it at all and I

00:29:26,000 --> 00:29:30,110
feel like I agree with her but I also

00:29:28,100 --> 00:29:31,669
think that are not unpopular techniques

00:29:30,110 --> 00:29:33,860
that come sometimes a stepping stone

00:29:31,669 --> 00:29:37,370
onto higher levels of continuous

00:29:33,860 --> 00:29:39,019
improvement property testing so if

00:29:37,370 --> 00:29:39,620
you've got a big configuration test all

00:29:39,019 --> 00:29:41,029
of it right

00:29:39,620 --> 00:29:42,169
fuzz it because you can't actually test

00:29:41,029 --> 00:29:45,169
all of it all the time but you can kind

00:29:42,169 --> 00:29:47,120
of approximate that they don't know how

00:29:45,169 --> 00:29:48,379
to test behavior and create logical

00:29:47,120 --> 00:29:49,960
tests but they can make sure that you

00:29:48,379 --> 00:29:54,200
aren't crashing the system by making a

00:29:49,960 --> 00:29:55,490
Rando change and this is kind of I

00:29:54,200 --> 00:29:56,929
really which had more time because this

00:29:55,490 --> 00:29:58,580
is the meat of it like the best single

00:29:56,929 --> 00:29:59,870
thing you can do to a system where

00:29:58,580 --> 00:30:01,909
you're rolling out new configuration

00:29:59,870 --> 00:30:03,470
that you can't possibly know what it's

00:30:01,909 --> 00:30:05,360
going to do in the general case is

00:30:03,470 --> 00:30:07,730
implement progressive rollouts and that

00:30:05,360 --> 00:30:09,080
means sound boxing a small amount of the

00:30:07,730 --> 00:30:11,440
production system where you deploy the

00:30:09,080 --> 00:30:13,279
changes to first and then gradually

00:30:11,440 --> 00:30:15,259
increase the radius of that

00:30:13,279 --> 00:30:17,120
configuration so more and more of the

00:30:15,259 --> 00:30:18,590
system get it and that way you can tell

00:30:17,120 --> 00:30:22,269
very early on if the systems behavior

00:30:18,590 --> 00:30:25,509
starts behaving badly or unpredictably

00:30:22,269 --> 00:30:28,250
and affect a small set of your user base

00:30:25,509 --> 00:30:29,779
there's a complication which if you have

00:30:28,250 --> 00:30:31,820
a globally distributed system using the

00:30:29,779 --> 00:30:33,620
same configuration and it's sharing

00:30:31,820 --> 00:30:35,149
information between each other making

00:30:33,620 --> 00:30:36,799
inferences about what it thinks the

00:30:35,149 --> 00:30:38,240
other systems know and then you roll out

00:30:36,799 --> 00:30:39,740
a new version of the conflict to one of

00:30:38,240 --> 00:30:41,360
them and all of a sudden it starts

00:30:39,740 --> 00:30:43,639
treating the other the other noise start

00:30:41,360 --> 00:30:45,639
treating it like it's gone crazy and you

00:30:43,639 --> 00:30:50,210
see it kind of need to understand that

00:30:45,639 --> 00:30:52,639
we had a system that was negotiating

00:30:50,210 --> 00:30:54,020
traffic levels and scaling between

00:30:52,639 --> 00:30:55,700
things and so if the algorithm

00:30:54,020 --> 00:30:57,410
change then the others would compensate

00:30:55,700 --> 00:30:58,220
for that thinking that the system had

00:30:57,410 --> 00:31:00,110
gone offline

00:30:58,220 --> 00:31:01,550
what we need to do is like share version

00:31:00,110 --> 00:31:04,550
numbers and stuff like that I'm sorry

00:31:01,550 --> 00:31:06,200
I'm almost done I'm so yeah we just add

00:31:04,550 --> 00:31:08,990
animal messages so the other nodes could

00:31:06,200 --> 00:31:11,150
cross check themselves and the last one

00:31:08,990 --> 00:31:12,830
is deleting code because the smaller the

00:31:11,150 --> 00:31:14,330
blast radius re the configuration

00:31:12,830 --> 00:31:15,980
service of your config then the less you

00:31:14,330 --> 00:31:19,100
have to think about the hot less complex

00:31:15,980 --> 00:31:23,690
it is so it's collapse scaffolding da da

00:31:19,100 --> 00:31:26,210
da change the power if you can make a

00:31:23,690 --> 00:31:28,490
config language less powerful and good I

00:31:26,210 --> 00:31:30,050
think but also high level languages

00:31:28,490 --> 00:31:31,970
allow you to be more expressive and be

00:31:30,050 --> 00:31:33,320
less likely to make mistakes so I don't

00:31:31,970 --> 00:31:35,050
really know what the right answer he is

00:31:33,320 --> 00:31:40,780
both of them cause outages

00:31:35,050 --> 00:31:43,820
configurations codes traded so thank you

00:31:40,780 --> 00:31:45,440
here's a QR code all the links are

00:31:43,820 --> 00:31:47,690
posted before and a bunch of information

00:31:45,440 --> 00:31:48,360
thanks very much for your time hope you

00:31:47,690 --> 00:31:52,619
have a great conference

00:31:48,360 --> 00:31:52,619

YouTube URL: https://www.youtube.com/watch?v=NcT8-IoImXE


