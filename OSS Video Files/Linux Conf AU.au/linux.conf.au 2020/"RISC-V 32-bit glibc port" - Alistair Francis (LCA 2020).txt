Title: "RISC-V 32-bit glibc port" - Alistair Francis (LCA 2020)
Publication date: 2020-01-14
Playlist: linux.conf.au 2020
Description: 
	Alistair Francis

https://lca2020.linux.org.au/schedule/presentation/206/

A talk about the RISC-V 32-bit glibc port. This will include details about the 64-bit time_t problem and how RV32 is going to be the first 32-bit architecture with a 64-bit time_t. This talk will also discuss what the current progress of upstreaming is, what is left to be done and why it has taken so long.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Mon Jan 13 11:45:00 2020 at Room 7
Captions: 
	00:00:00,030 --> 00:00:04,680
like I start I'm Alistair I work at

00:00:01,770 --> 00:00:07,500
Western Digital research and I'm here to

00:00:04,680 --> 00:00:14,820
talk about the risk five 32-bit jilebi

00:00:07,500 --> 00:00:16,850
seaport so before I jump into that you

00:00:14,820 --> 00:00:20,010
have to start with the year 2038 problem

00:00:16,850 --> 00:00:23,910
and we'll come back to the GFC point at

00:00:20,010 --> 00:00:25,650
the end so in january 2038 the unix

00:00:23,910 --> 00:00:28,320
epoch timer is going to overflow a

00:00:25,650 --> 00:00:30,480
32-bit signed integer so family doesn't

00:00:28,320 --> 00:00:33,630
know the unix epoch timer is this time

00:00:30,480 --> 00:00:37,050
since the first of January 1970 it's a

00:00:33,630 --> 00:00:38,790
number second since then and in January

00:00:37,050 --> 00:00:41,370
there's something I think it's the 13th

00:00:38,790 --> 00:00:44,579
or something in 2038 it'll overflow a 32

00:00:41,370 --> 00:00:47,340
it signed integer so it's like the y2k

00:00:44,579 --> 00:00:50,730
problem all over again but this is

00:00:47,340 --> 00:00:52,170
actually bad there's you if you set but

00:00:50,730 --> 00:00:53,760
normally what went over the flows it'll

00:00:52,170 --> 00:00:55,050
become a negative number a negative no

00:00:53,760 --> 00:00:57,539
you can't have negative time is in the

00:00:55,050 --> 00:00:59,250
kernel so they either won't fire I think

00:00:57,539 --> 00:01:01,739
the colonel used to just hang if you

00:00:59,250 --> 00:01:05,240
gave it a float values I think now it's

00:01:01,739 --> 00:01:07,380
a little better maybe just crashes but

00:01:05,240 --> 00:01:10,260
there's actually have this has come up

00:01:07,380 --> 00:01:12,150
before as well apparently there's been

00:01:10,260 --> 00:01:14,220
servers where people set really long

00:01:12,150 --> 00:01:16,860
time outs and a timeout extended past

00:01:14,220 --> 00:01:19,500
year 2038 and crash the server and so

00:01:16,860 --> 00:01:22,020
this is actually an issue ok but that's

00:01:19,500 --> 00:01:23,939
still like 18 years away so who cares 32

00:01:22,020 --> 00:01:25,470
bits getting deprecated in all the major

00:01:23,939 --> 00:01:27,840
distros anyway they're trying to cut

00:01:25,470 --> 00:01:30,450
layout and why do we need why don't care

00:01:27,840 --> 00:01:32,610
about something in 18 years time so lots

00:01:30,450 --> 00:01:34,829
of people still make things that last

00:01:32,610 --> 00:01:36,240
longer than your two year smart phone

00:01:34,829 --> 00:01:39,570
right so do you buy a car today

00:01:36,240 --> 00:01:40,799
and it has a 32-bit Linux in there in 20

00:01:39,570 --> 00:01:43,530
years time you probably want it to still

00:01:40,799 --> 00:01:44,670
work or a plane made today or a turbine

00:01:43,530 --> 00:01:46,290
made today or something right there's

00:01:44,670 --> 00:01:49,079
lots of industrial use cases those lots

00:01:46,290 --> 00:01:50,909
of embedded Linux all over the place a

00:01:49,079 --> 00:01:53,250
lot of it's probably 32-bit and you

00:01:50,909 --> 00:01:57,060
don't want it to break all the same time

00:01:53,250 --> 00:01:59,850
in 2038 so this is a problem and so how

00:01:57,060 --> 00:02:01,890
do you fix this so you can do on you can

00:01:59,850 --> 00:02:04,710
use unsigned and stuff but basically the

00:02:01,890 --> 00:02:06,750
solution is a 64 bit time T so 64-bit

00:02:04,710 --> 00:02:08,729
architectures already have a 64 bit time

00:02:06,750 --> 00:02:11,970
T if you just use along so they get it

00:02:08,729 --> 00:02:14,710
for free and Linux 5.1 added support for

00:02:11,970 --> 00:02:18,080
the 64 bit time T

00:02:14,710 --> 00:02:20,480
so if I like I said 5.1 ads all these

00:02:18,080 --> 00:02:24,320
new syscalls 432 reactors that use

00:02:20,480 --> 00:02:26,120
64-bit time T so there is a list there

00:02:24,320 --> 00:02:28,220
kind of get an example some of them are

00:02:26,120 --> 00:02:30,860
suffix with 64 some of them are suffix

00:02:28,220 --> 00:02:33,110
with x 64 weight ID is a whole new

00:02:30,860 --> 00:02:35,480
different thing that's another issue and

00:02:33,110 --> 00:02:36,500
padding changes around and it's a whole

00:02:35,480 --> 00:02:39,020
new mess but there's a whole new

00:02:36,500 --> 00:02:40,490
Siskel's so every existing architecture

00:02:39,020 --> 00:02:42,080
doesn't really care they keep using the

00:02:40,490 --> 00:02:43,850
same ones they've always used and they

00:02:42,080 --> 00:02:46,940
use 32-bit time T and eventually they

00:02:43,850 --> 00:02:49,820
can update but new architectures have to

00:02:46,940 --> 00:02:52,910
use the 64-bit time t6 goals and risk 5

00:02:49,820 --> 00:02:55,100
32-bit didn't have an upstream Lib C at

00:02:52,910 --> 00:02:58,430
the time of Linux 5.1 so where in your

00:02:55,100 --> 00:03:01,040
architecture so risk 5 as a 5.1 kernel

00:02:58,430 --> 00:03:03,230
has to use 64-bit time T you can go

00:03:01,040 --> 00:03:05,270
revert some hatches and do the old wait

00:03:03,230 --> 00:03:07,130
but your knees main line you have to use

00:03:05,270 --> 00:03:08,570
64-bit time T so you have to use all

00:03:07,130 --> 00:03:13,790
these new Cisco the old ones aren't

00:03:08,570 --> 00:03:15,740
there you can't even call them yeah

00:03:13,790 --> 00:03:17,750
eventually the 32-bit ones will probably

00:03:15,740 --> 00:03:18,140
be removed so after 2038 they won't work

00:03:17,750 --> 00:03:20,120
anymore

00:03:18,140 --> 00:03:22,250
so it will be moved then but maybe

00:03:20,120 --> 00:03:25,580
before then if ever an updates but

00:03:22,250 --> 00:03:28,640
that's always a question if people get

00:03:25,580 --> 00:03:31,030
update in time so I'll come back to this

00:03:28,640 --> 00:03:34,790
is called minute ok chillip see so GFC

00:03:31,030 --> 00:03:36,860
didn't have any support for 64-bit time

00:03:34,790 --> 00:03:38,540
T on 32 all right just came

00:03:36,860 --> 00:03:41,270
around Linux with no one else is there

00:03:38,540 --> 00:03:44,660
yet so upstream has been working with

00:03:41,270 --> 00:03:47,030
Lucas and myself to add support so this

00:03:44,660 --> 00:03:48,590
it applies to wrist 5 because we need it

00:03:47,030 --> 00:03:52,280
but other architectures also feel

00:03:48,590 --> 00:03:53,720
deploying some arm 32-bit Linux today in

00:03:52,280 --> 00:03:55,010
a car you probably want to make sure

00:03:53,720 --> 00:03:56,090
it's going to keep working or at least

00:03:55,010 --> 00:03:58,760
have an update plan to make sure it

00:03:56,090 --> 00:04:01,310
keeps working so all the Lib C functions

00:03:58,760 --> 00:04:04,060
that you used to now have to call the 64

00:04:01,310 --> 00:04:06,050
bits disk all under the hood that

00:04:04,060 --> 00:04:07,760
doesn't sound that hard but then you

00:04:06,050 --> 00:04:10,100
have to do it in a way that doesn't hurt

00:04:07,760 --> 00:04:12,500
performance on your high performance

00:04:10,100 --> 00:04:14,030
number one supercomputer and also do it

00:04:12,500 --> 00:04:16,820
in a way that's backwards compatible so

00:04:14,030 --> 00:04:19,640
you can use today's GFC to still run on

00:04:16,820 --> 00:04:22,030
the 3.15 kernel that some people are

00:04:19,640 --> 00:04:24,200
using so all of these things and

00:04:22,030 --> 00:04:25,430
architecture independent you don't want

00:04:24,200 --> 00:04:26,780
every architecture doing it in some

00:04:25,430 --> 00:04:27,290
different way so all this has to be

00:04:26,780 --> 00:04:29,480
taken in

00:04:27,290 --> 00:04:31,300
and put together and then you have to

00:04:29,480 --> 00:04:35,660
test it and make sure it doesn't break

00:04:31,300 --> 00:04:39,470
s/390 at the same time sir it's a lot of

00:04:35,660 --> 00:04:41,690
work to make it even hotter some

00:04:39,470 --> 00:04:44,000
syscalls still use the 32-bit time t

00:04:41,690 --> 00:04:45,440
because they're dipped I'm so like time

00:04:44,000 --> 00:04:47,390
in the future from now on time in the

00:04:45,440 --> 00:04:49,640
past so they didn't think we needed to

00:04:47,390 --> 00:04:52,370
update those so now you have to convert

00:04:49,640 --> 00:04:56,090
the 64-bit time T in users face to and

00:04:52,370 --> 00:04:57,560
from 32-bit time T Siskel's and convert

00:04:56,090 --> 00:04:59,690
it to do the physical convert it back

00:04:57,560 --> 00:05:01,280
and handle all these things with

00:04:59,690 --> 00:05:04,250
different padding and different Indian s

00:05:01,280 --> 00:05:07,940
and yeah they should have all been

00:05:04,250 --> 00:05:09,650
64-bit but and all this has to work but

00:05:07,940 --> 00:05:11,450
all this work will apply it to every

00:05:09,650 --> 00:05:14,240
32-bit architecture so and once this is

00:05:11,450 --> 00:05:16,850
done every 32-bit architecture I can

00:05:14,240 --> 00:05:19,280
just update to the 5.1 Plus kernel and

00:05:16,850 --> 00:05:24,770
take a box in a compiled flag somewhere

00:05:19,280 --> 00:05:27,710
and it'll should just work okay no

00:05:24,770 --> 00:05:31,280
they're ok I don't carry those ones but

00:05:27,710 --> 00:05:33,590
today the new ones so this is kind of

00:05:31,280 --> 00:05:36,020
where we are in the generic 64-bit time

00:05:33,590 --> 00:05:39,980
T updates so there's a whole list of

00:05:36,020 --> 00:05:42,200
ones on the right so where it gets so

00:05:39,980 --> 00:05:45,350
more slim is just kind of changing it so

00:05:42,200 --> 00:05:47,690
if this is defined call this or if

00:05:45,350 --> 00:05:49,970
32-bit try to do the 64-bit one first

00:05:47,690 --> 00:05:52,070
and if that fails with a notice co-found

00:05:49,970 --> 00:05:53,930
then fall back to the normal one things

00:05:52,070 --> 00:05:56,630
like that where it gets really fun is

00:05:53,930 --> 00:05:59,300
wait so wait all the weights have been

00:05:56,630 --> 00:06:02,510
removed except for weight ID in the new

00:05:59,300 --> 00:06:04,970
year 2038 safe syscalls so you have to

00:06:02,510 --> 00:06:07,420
re-implement the weight for in g loops

00:06:04,970 --> 00:06:11,000
in the Lib C to then call the weight ID

00:06:07,420 --> 00:06:13,730
and weight ID doesn't do this all the

00:06:11,000 --> 00:06:15,320
same things until the 5.4 kernel so now

00:06:13,730 --> 00:06:18,020
you need the 5.4 kernel because it has

00:06:15,320 --> 00:06:20,300
this new ID type which I mentioned at

00:06:18,020 --> 00:06:23,030
the enter and the extra one is get time

00:06:20,300 --> 00:06:26,750
a day which returns a time zone data

00:06:23,030 --> 00:06:28,670
which no one uses but so it doesn't this

00:06:26,750 --> 00:06:30,500
new kernel the year 2038 safe one

00:06:28,670 --> 00:06:31,670
doesn't return any time zone data it's

00:06:30,500 --> 00:06:33,920
no way to get it you cannot get it from

00:06:31,670 --> 00:06:36,470
the kernel but some system D use cases

00:06:33,920 --> 00:06:39,710
get it and expect it to not be no and

00:06:36,470 --> 00:06:41,330
yeah it's a mess but it's getting there

00:06:39,710 --> 00:06:44,479
everything besides

00:06:41,330 --> 00:06:46,909
web sees are now kind of happy busybox

00:06:44,479 --> 00:06:49,879
had to have some patches and urban SSL

00:06:46,909 --> 00:06:51,919
needed patches too but so there's more

00:06:49,879 --> 00:06:53,960
still going gypsies and freeze at the

00:06:51,919 --> 00:06:55,370
moment so nothing's getting accepted but

00:06:53,960 --> 00:06:58,189
there's patches reviewed patches on

00:06:55,370 --> 00:07:00,259
lists and peace like 64 Lucas was

00:06:58,189 --> 00:07:02,240
working on and he's waiting till after

00:07:00,259 --> 00:07:05,449
the GFC minimum version bumps up to

00:07:02,240 --> 00:07:08,990
above 3.15 so we're kind of getting

00:07:05,449 --> 00:07:11,960
there it's all this all this just to get

00:07:08,990 --> 00:07:15,710
the bloody risk for important so risk 5

00:07:11,960 --> 00:07:17,419
32 bit once all this comes in we can get

00:07:15,710 --> 00:07:20,030
the risk 5 tell you to be put in so who

00:07:17,419 --> 00:07:23,629
cares why does anyone want 32-bit risc 5

00:07:20,030 --> 00:07:26,900
so we already have $5 64-bit RISC 5

00:07:23,629 --> 00:07:29,210
Linux brooding chip CPU so why doesn't

00:07:26,900 --> 00:07:31,129
matter so on an FPGA it's a big

00:07:29,210 --> 00:07:33,710
difference a 64-bit system takes up a

00:07:31,129 --> 00:07:36,349
lot more space on an FPGA so you can put

00:07:33,710 --> 00:07:38,120
a Linux capable 32-bit system on a much

00:07:36,349 --> 00:07:40,789
smaller FPGA so it does matter people

00:07:38,120 --> 00:07:41,599
will use it even if in that a 6 it's not

00:07:40,789 --> 00:07:43,699
as big of an issue

00:07:41,599 --> 00:07:45,379
it also comes up for testing compiler

00:07:43,699 --> 00:07:47,870
glass of Hospice and they say these

00:07:45,379 --> 00:07:50,029
testing and also for completeness we do

00:07:47,870 --> 00:07:52,219
have a 32-bit risc 5 architecture it is

00:07:50,029 --> 00:07:53,750
fully supported one extra brunner

00:07:52,219 --> 00:07:54,949
there's no reason to say are now a dual

00:07:53,750 --> 00:07:57,229
ec doesn't work there do you love sees

00:07:54,949 --> 00:07:59,900
the most common live see so I think it's

00:07:57,229 --> 00:08:02,120
important if there so the next five that

00:07:59,900 --> 00:08:04,009
one plus does not support like that does

00:08:02,120 --> 00:08:06,139
not support the old ones you have to use

00:08:04,009 --> 00:08:08,089
in your wants you can't keep using the

00:08:06,139 --> 00:08:09,800
old one and without doing some reverts

00:08:08,089 --> 00:08:11,360
and things but so you have to use easy

00:08:09,800 --> 00:08:15,139
one so we need all this done before we

00:08:11,360 --> 00:08:17,690
can do it and like I said so this PG PG

00:08:15,139 --> 00:08:19,279
ID is the new one in the weight for

00:08:17,690 --> 00:08:21,289
function a weight function for the

00:08:19,279 --> 00:08:23,300
weight ID function so now we need the 5

00:08:21,289 --> 00:08:26,830
to 4 so hopefully the 5 before is the

00:08:23,300 --> 00:08:26,830
last one and there's no more bugs but

00:08:27,230 --> 00:08:35,340
yeah so the current status so there's a

00:08:33,390 --> 00:08:38,130
picture of all my failing test cases if

00:08:35,340 --> 00:08:40,050
anyone's done live C testing which Keith

00:08:38,130 --> 00:08:42,810
has you know how fun is to get all your

00:08:40,050 --> 00:08:45,090
test cases of us but at one point we had

00:08:42,810 --> 00:08:47,400
just infinite hangs and it would hang

00:08:45,090 --> 00:08:49,230
forever and now we had we had a thousand

00:08:47,400 --> 00:08:50,490
failing test cases and then seven

00:08:49,230 --> 00:08:53,850
hundred failing test cases and now at

00:08:50,490 --> 00:08:58,500
twenty eight twenty good it's not good

00:08:53,850 --> 00:09:01,890
enough yet but so GFC 3 dot 2.3 one is

00:08:58,500 --> 00:09:04,230
in freeze so normal patches it's just

00:09:01,890 --> 00:09:05,640
bug fixes all that stuff so you're not

00:09:04,230 --> 00:09:09,090
sending in patches I sent an RFC

00:09:05,640 --> 00:09:11,340
yesterday RFC version six when the 2.32

00:09:09,090 --> 00:09:13,520
window opens up I'll go back to standing

00:09:11,340 --> 00:09:17,160
patches I think there's about five

00:09:13,520 --> 00:09:19,680
generic ones still in my tree and then

00:09:17,160 --> 00:09:22,610
we're back on to all just risk five and

00:09:19,680 --> 00:09:25,200
mostly respite 32-bit support adding

00:09:22,610 --> 00:09:30,120
defines and all those things and sis

00:09:25,200 --> 00:09:31,620
colas so 32 and 32-bit risc five but

00:09:30,120 --> 00:09:34,320
they're currently the main ones pushing

00:09:31,620 --> 00:09:36,720
for 64-bit time T don't there is five

00:09:34,320 --> 00:09:38,820
one and Lucas is doing the sick the arm

00:09:36,720 --> 00:09:40,290
one we have a much easier than that we

00:09:38,820 --> 00:09:42,900
don't care about backwards compatibility

00:09:40,290 --> 00:09:45,660
there's no one out there running some

00:09:42,900 --> 00:09:48,300
kernel 4.19 and we need to keep using

00:09:45,660 --> 00:09:49,710
them we just say yeah don't just use the

00:09:48,300 --> 00:09:52,050
fiber for kernel give off on anything

00:09:49,710 --> 00:09:53,790
else so that helps that's the advantage

00:09:52,050 --> 00:09:57,720
of not having an upstream Lib C influent

00:09:53,790 --> 00:10:01,110
ation so think oh it's the one last

00:09:57,720 --> 00:10:03,810
thing I think julep see especially gets

00:10:01,110 --> 00:10:06,990
a very hard time for being a very hard

00:10:03,810 --> 00:10:09,660
upstream community to work with so I

00:10:06,990 --> 00:10:13,260
want to say it is very slow it's so slow

00:10:09,660 --> 00:10:16,230
to upstream stuff not that first is the

00:10:13,260 --> 00:10:17,460
SSF contribution agreement which gets

00:10:16,230 --> 00:10:19,470
lawyers involved so that takes a long

00:10:17,460 --> 00:10:22,650
time and then just testing everything

00:10:19,470 --> 00:10:24,240
has to be tested and they have scripts

00:10:22,650 --> 00:10:25,800
to help but that's kind of useful but it

00:10:24,240 --> 00:10:27,930
still takes 12 hours to run those and

00:10:25,800 --> 00:10:29,970
then at one point I had to make sure I

00:10:27,930 --> 00:10:31,680
didn't break any other 32-bit

00:10:29,970 --> 00:10:34,620
implementations so I was testing with

00:10:31,680 --> 00:10:36,630
the 4.19 kernel headers the 5.1 kernel

00:10:34,620 --> 00:10:39,300
with the photo like 5.1 kernel with the

00:10:36,630 --> 00:10:39,740
4.19 headers and the 5.1 kernel and 5.1

00:10:39,300 --> 00:10:42,380
head

00:10:39,740 --> 00:10:45,170
and each one takes 19 hours to run so

00:10:42,380 --> 00:10:47,090
it's just a slow slow and now I've got

00:10:45,170 --> 00:10:50,480
it down to yeah I can do the whole

00:10:47,090 --> 00:10:52,580
respire clean build test in 19 hours in

00:10:50,480 --> 00:10:54,770
care of you so it takes a long time to

00:10:52,580 --> 00:10:56,900
spin around you also have to worry about

00:10:54,770 --> 00:10:58,220
other architectures you break those

00:10:56,900 --> 00:10:59,630
architectures you don't even have access

00:10:58,220 --> 00:11:02,810
to and somehow you have to get that

00:10:59,630 --> 00:11:04,850
working and make and test those and but

00:11:02,810 --> 00:11:05,930
they are actually really friendly so I

00:11:04,850 --> 00:11:07,910
just wanted to say that so they're super

00:11:05,930 --> 00:11:09,650
friendly the GOC guys they're very very

00:11:07,910 --> 00:11:10,130
helpful they comment I send patches last

00:11:09,650 --> 00:11:11,750
night

00:11:10,130 --> 00:11:13,370
they're like 9 p.m. and before I went to

00:11:11,750 --> 00:11:14,420
bed like an hour later I already had

00:11:13,370 --> 00:11:16,430
multiple comments so they're very

00:11:14,420 --> 00:11:18,320
friendly the comments are useful they're

00:11:16,430 --> 00:11:21,050
very constructive I don't think they

00:11:18,320 --> 00:11:22,910
deserve the some of the reputation they

00:11:21,050 --> 00:11:24,500
I feel like they sometimes get very

00:11:22,910 --> 00:11:27,230
helpful and very friendly the testing is

00:11:24,500 --> 00:11:31,640
a pain but I don't think what knocking

00:11:27,230 --> 00:11:33,410
knock test it right so yeah sorry yeah

00:11:31,640 --> 00:11:34,940
just yeah keys it's gonna fill about

00:11:33,410 --> 00:11:37,220
testing later today's testing is good

00:11:34,940 --> 00:11:38,360
the requirements are testing our paint I

00:11:37,220 --> 00:11:40,660
mean they're pain but it definitely

00:11:38,360 --> 00:11:44,450
useful I'm not saying they're not useful

00:11:40,660 --> 00:11:46,580
okay so that's it so I think we're kind

00:11:44,450 --> 00:11:47,750
of out of time truth with me so unless

00:11:46,580 --> 00:11:48,860
anyone has any really cool questions

00:11:47,750 --> 00:11:55,400
we'll jump over to it

00:11:48,860 --> 00:11:59,060
oh yeah so I'm trying to find the escape

00:11:55,400 --> 00:12:02,060
button again you speak any more about

00:11:59,060 --> 00:12:06,560
the performance implications and how you

00:12:02,060 --> 00:12:09,260
manage to keep 64-bit fast while yeah

00:12:06,560 --> 00:12:15,400
the main thing is to not break or not

00:12:09,260 --> 00:12:18,970
affect the 64-bit stuff so sorry how Oh

00:12:15,400 --> 00:12:18,970
using a lot of macros

00:12:19,660 --> 00:12:25,490
yeah it's basically macro magic its

00:12:23,390 --> 00:12:28,220
macro magic and then if you kind of have

00:12:25,490 --> 00:12:30,800
Boris then it tries the 32-bit one first

00:12:28,220 --> 00:12:33,290
now it starts to 64-bit one first and if

00:12:30,800 --> 00:12:35,300
that fails and it pulls back so 31 but

00:12:33,290 --> 00:12:38,930
64-bit architectures don't have the

00:12:35,300 --> 00:12:40,040
64-bit suffixed calls they just use the

00:12:38,930 --> 00:12:42,230
standard ones that boys use they don't

00:12:40,040 --> 00:12:44,480
have these new calls so it's it was

00:12:42,230 --> 00:12:46,900
design in a way not to affect them it

00:12:44,480 --> 00:12:49,070
meant like compiles out with macro magic

00:12:46,900 --> 00:12:51,410
phenols what the GOC is a lot of macros

00:12:49,070 --> 00:12:53,600
it's all macro magic yeah I'll give you

00:12:51,410 --> 00:12:55,970
this video has any questions you can

00:12:53,600 --> 00:12:59,649
pharming out of this and now here's a

00:12:55,970 --> 00:12:59,649

YouTube URL: https://www.youtube.com/watch?v=wNM1VqEqvyE


