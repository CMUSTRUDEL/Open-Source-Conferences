Title: "Designing Syscalls for Extensibility" - Aleksa Sarai (LCA 2020)
Publication date: 2020-01-15
Playlist: linux.conf.au 2020
Description: 
	Aleksa Sarai

https://lca2020.linux.org.au/schedule/presentation/133/

Due to the nature of Linux's ABI guarantee, the problem of how to safely extend the functionality of syscalls has been a long-standing one. Several different approaches have been attempted over the decades, but many have had unavoidable downsides that have resulted in the introduction of newer syscalls. However, several recent syscalls have taken an alternative approach to syscall extensibility -- and in this talk we will discuss the trade-offs and possible future extensions available thanks to this newer design.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

Produced by NDV: https://youtube.com/channel/UCQ7dFBzZGlBvtU2hCecsBBg?sub_confirmation=1

#linux.conf.au #linux #foss #opensource

Tue Jan 14 16:35:00 2020 at Arena
Captions: 
	00:00:00,140 --> 00:00:06,089
right thank you much so this is gonna be

00:00:03,480 --> 00:00:08,910
a very very short talk about a new way

00:00:06,089 --> 00:00:11,010
or a semi new way of designing Cisco

00:00:08,910 --> 00:00:13,049
such that you can extend them sanely

00:00:11,010 --> 00:00:14,790
and it's based on some work that was

00:00:13,049 --> 00:00:17,039
done quite a few years ago by some other

00:00:14,790 --> 00:00:18,539
folks but has sort of been reborn given

00:00:17,039 --> 00:00:22,199
some new syscalls that recently came in

00:00:18,539 --> 00:00:24,180
to the kernel so first of all I guess

00:00:22,199 --> 00:00:26,010
the first question is why do you want

00:00:24,180 --> 00:00:27,269
extensibility or what are so the the

00:00:26,010 --> 00:00:29,070
spectrum of extensibility you can

00:00:27,269 --> 00:00:31,619
imagine and I've sort of given a couple

00:00:29,070 --> 00:00:34,020
of examples of Siskel's that have

00:00:31,619 --> 00:00:36,120
different levels of extensibility I

00:00:34,020 --> 00:00:37,860
octal being the most obvious most

00:00:36,120 --> 00:00:39,840
extensible Cisco land that you know it's

00:00:37,860 --> 00:00:41,700
basically a multiplexer it's like each

00:00:39,840 --> 00:00:44,070
individual I octal is kind of like a

00:00:41,700 --> 00:00:45,809
Cisco onto its own with different

00:00:44,070 --> 00:00:47,370
subsystems being able to set it up and I

00:00:45,809 --> 00:00:49,739
think it's fair to say that we shouldn't

00:00:47,370 --> 00:00:52,110
make all sis calls like I octal I think

00:00:49,739 --> 00:00:52,980
is a fair statement to make but then on

00:00:52,110 --> 00:00:54,840
the other hand you have things like

00:00:52,980 --> 00:00:57,239
create which in case you know used

00:00:54,840 --> 00:00:59,460
create it's like open Oh create but it

00:00:57,239 --> 00:01:01,620
takes know other flags so it's just it's

00:00:59,460 --> 00:01:04,710
literally a Cisco that is all it's doing

00:01:01,620 --> 00:01:06,840
is an open o creado exclusive which is

00:01:04,710 --> 00:01:08,040
lovely so for create if you want to that

00:01:06,840 --> 00:01:10,260
a new flag to create it wouldn't be

00:01:08,040 --> 00:01:12,750
possible so we have to decide at which

00:01:10,260 --> 00:01:15,210
point where we'll be happy with for a

00:01:12,750 --> 00:01:17,159
particular Cisco and obviously Open has

00:01:15,210 --> 00:01:19,619
Flags statics has an actual structure so

00:01:17,159 --> 00:01:23,100
there's different different ways you can

00:01:19,619 --> 00:01:24,720
do it the main reason why we would like

00:01:23,100 --> 00:01:26,820
them sensible to schools at all why

00:01:24,720 --> 00:01:28,890
isn't every Cisco like create is because

00:01:26,820 --> 00:01:31,170
having sensible sis goals allows us to

00:01:28,890 --> 00:01:33,210
have more flexible user space code so in

00:01:31,170 --> 00:01:36,240
other words if you have a library that

00:01:33,210 --> 00:01:38,549
that uses a particular Cisco you can

00:01:36,240 --> 00:01:40,320
make it can make use of Newark kernel

00:01:38,549 --> 00:01:42,540
features so you have a library that for

00:01:40,320 --> 00:01:45,060
instance poses some feature like open at

00:01:42,540 --> 00:01:48,329
to which I'll get to in a second you can

00:01:45,060 --> 00:01:49,680
a user of that library can use the new

00:01:48,329 --> 00:01:51,149
features without the library being

00:01:49,680 --> 00:01:52,380
modified at least assuming that it's

00:01:51,149 --> 00:01:54,170
assuming the library has the right

00:01:52,380 --> 00:01:56,219
interface and all the rest of it an

00:01:54,170 --> 00:01:57,689
application similarly this is a little

00:01:56,219 --> 00:01:59,430
bit more of a stretch but you can

00:01:57,689 --> 00:02:01,259
imagine like CLI applications or some

00:01:59,430 --> 00:02:03,420
graphical applications allowing you to

00:02:01,259 --> 00:02:04,860
use new kernel features new kernel

00:02:03,420 --> 00:02:05,939
features that are exposed to these these

00:02:04,860 --> 00:02:07,710
extensible syscalls

00:02:05,939 --> 00:02:10,679
without having to modify the program

00:02:07,710 --> 00:02:12,390
itself these are things that is not true

00:02:10,679 --> 00:02:13,710
is non-trivial if you have to create a

00:02:12,390 --> 00:02:15,150
new cisco leverage

00:02:13,710 --> 00:02:16,860
all time because if you have a new

00:02:15,150 --> 00:02:18,270
Siskel you have to rewrite the program

00:02:16,860 --> 00:02:20,460
to order use the new Siskel

00:02:18,270 --> 00:02:21,990
so having Siskel's where it's one cisco

00:02:20,460 --> 00:02:24,180
number but you can extend it over time

00:02:21,990 --> 00:02:26,790
is very beneficial in this respect and

00:02:24,180 --> 00:02:28,170
ideally we would want syscalls to both

00:02:26,790 --> 00:02:29,910
be forward and backward compatible

00:02:28,170 --> 00:02:31,620
meaning that if you have a program that

00:02:29,910 --> 00:02:32,970
what I mean obviously backward

00:02:31,620 --> 00:02:35,010
compatibility is a requirement of any in

00:02:32,970 --> 00:02:37,440
Cisco ABI but forward compatibility

00:02:35,010 --> 00:02:39,090
would be if you have a program that's

00:02:37,440 --> 00:02:42,270
written for a new account where there's

00:02:39,090 --> 00:02:44,130
new headers and it usually it has it was

00:02:42,270 --> 00:02:45,540
built on a newer system but isn't using

00:02:44,130 --> 00:02:46,980
any of the new features ideally you

00:02:45,540 --> 00:02:49,020
would like it to work on old kernels and

00:02:46,980 --> 00:02:51,510
this is why having different cisco

00:02:49,020 --> 00:02:53,640
numbers is not ideal is because well if

00:02:51,510 --> 00:02:54,840
a program is written to use a new assist

00:02:53,640 --> 00:02:56,880
call but doesn't use the new features

00:02:54,840 --> 00:03:00,510
when you go back to the old and to under

00:02:56,880 --> 00:03:03,360
an old colonel it just won't work so the

00:03:00,510 --> 00:03:05,160
oldest and most well known way of doing

00:03:03,360 --> 00:03:06,930
extensibility is obviously bit flags

00:03:05,160 --> 00:03:09,540
which everyone here presumably has at

00:03:06,930 --> 00:03:11,640
least seen and it works great bit flags

00:03:09,540 --> 00:03:14,430
are awesome for for solving the problem

00:03:11,640 --> 00:03:16,800
of we want to add new boolean flags to a

00:03:14,430 --> 00:03:19,140
particular Cisco the problem is is that

00:03:16,800 --> 00:03:20,610
that's sort of the only place they're

00:03:19,140 --> 00:03:23,460
good for if you want to add new

00:03:20,610 --> 00:03:26,400
arguments or if you want to add anything

00:03:23,460 --> 00:03:27,930
like that it's basically not it's

00:03:26,400 --> 00:03:30,330
non-trivial to add them idiomatically

00:03:27,930 --> 00:03:33,300
right oh I've given attempt file here as

00:03:30,330 --> 00:03:35,220
an example which is a combination both

00:03:33,300 --> 00:03:37,380
of opens weirdness and also the problems

00:03:35,220 --> 00:03:39,000
with bit flags which is that open open

00:03:37,380 --> 00:03:41,160
actually takes four arguments but it has

00:03:39,000 --> 00:03:43,440
historically only taken three and long

00:03:41,160 --> 00:03:45,810
story short GFC at a bug a while ago

00:03:43,440 --> 00:03:47,850
which was that when attempt files of

00:03:45,810 --> 00:03:49,650
what was added because gee ellipse II

00:03:47,850 --> 00:03:51,360
didn't know that Oh temp file requires

00:03:49,650 --> 00:03:53,790
the mode to be set it would just pass

00:03:51,360 --> 00:03:55,440
garbage to the kernel which would be fun

00:03:53,790 --> 00:03:57,720
so that was eventually fixed but it's an

00:03:55,440 --> 00:03:59,400
example where you've added a flag and

00:03:57,720 --> 00:04:00,720
now an argument that was previously

00:03:59,400 --> 00:04:03,480
unused or register was previously unused

00:04:00,720 --> 00:04:04,740
now is used for something these older

00:04:03,480 --> 00:04:05,220
programs a program that was using

00:04:04,740 --> 00:04:06,960
gilepsy

00:04:05,220 --> 00:04:09,960
couldn't use our temp file until it was

00:04:06,960 --> 00:04:12,180
fixed in jealousy so this is far from

00:04:09,960 --> 00:04:15,360
ideal in terms of extensibility and

00:04:12,180 --> 00:04:17,190
while bit flags are the most obvious and

00:04:15,360 --> 00:04:18,180
straight full way to do extensions there

00:04:17,190 --> 00:04:20,970
are some new assist goals that don't

00:04:18,180 --> 00:04:22,560
even use them I mean rename an arena to

00:04:20,970 --> 00:04:23,800
sort of it is a is a classic example

00:04:22,560 --> 00:04:25,900
this is a very

00:04:23,800 --> 00:04:28,060
well funny example I guess which is that

00:04:25,900 --> 00:04:30,130
rename at two was just obviously there

00:04:28,060 --> 00:04:32,770
was an extension or two all of the VFS

00:04:30,130 --> 00:04:35,590
sis calls a while ago to add you know a

00:04:32,770 --> 00:04:36,970
directory file descriptor argument but

00:04:35,590 --> 00:04:39,009
they forgot to add a flag argument to

00:04:36,970 --> 00:04:39,970
rename at which eventually meant that

00:04:39,009 --> 00:04:42,220
when they wanted to have like for

00:04:39,970 --> 00:04:43,569
instance atomic exchange renames and

00:04:42,220 --> 00:04:45,099
things like this they had to riad

00:04:43,569 --> 00:04:46,900
renamed at two in order to you know to

00:04:45,099 --> 00:04:47,979
work around this problem and there are

00:04:46,900 --> 00:04:49,870
there actually a couple other examples

00:04:47,979 --> 00:04:51,819
of sis calls that don't have that still

00:04:49,870 --> 00:04:53,470
don't have a Flags argument but probably

00:04:51,819 --> 00:04:55,000
will eventually have a version two added

00:04:53,470 --> 00:04:56,400
which have a flag whose argument I've

00:04:55,000 --> 00:04:58,539
given a red link out here as an example

00:04:56,400 --> 00:05:00,280
in that yeah red link at doesn't take a

00:04:58,539 --> 00:05:01,449
Flags argument which sucks if you like

00:05:00,280 --> 00:05:03,639
me and you want to add a feature real

00:05:01,449 --> 00:05:05,490
link out that you need to add a new

00:05:03,639 --> 00:05:08,759
cisco entirely just because there wasn't

00:05:05,490 --> 00:05:11,860
we didn't add any extensibility to them

00:05:08,759 --> 00:05:13,900
the second most common way or at least a

00:05:11,860 --> 00:05:16,030
way that is a little bit newer but still

00:05:13,900 --> 00:05:18,550
pretty old these fixed size structures

00:05:16,030 --> 00:05:19,720
so this is the most obvious I mean it's

00:05:18,550 --> 00:05:22,000
it's sort of I guess the simplest way to

00:05:19,720 --> 00:05:23,590
say well we need to have arguments but

00:05:22,000 --> 00:05:25,210
we can't have twenty arguments to a

00:05:23,590 --> 00:05:27,490
Cisco so let's make a structure that

00:05:25,210 --> 00:05:29,289
just has the arguments we want it's very

00:05:27,490 --> 00:05:31,120
simple to add new fields assuming you've

00:05:29,289 --> 00:05:32,770
allocated enough extra space in your

00:05:31,120 --> 00:05:34,330
structure to be able to do this you just

00:05:32,770 --> 00:05:36,909
you know rename one of the reserved

00:05:34,330 --> 00:05:39,009
fields the main problem with these is

00:05:36,909 --> 00:05:41,139
that and I've given shims to tell as an

00:05:39,009 --> 00:05:43,990
example stat X I think is a better

00:05:41,139 --> 00:05:47,080
example but it's in statics is like

00:05:43,990 --> 00:05:49,240
getting data so never mind but it's

00:05:47,080 --> 00:05:51,969
simple to add new fields to to things

00:05:49,240 --> 00:05:53,680
like to things like this the downside is

00:05:51,969 --> 00:05:55,030
that you it requires you have to go to

00:05:53,680 --> 00:05:56,380
know the future right you have to know

00:05:55,030 --> 00:05:58,120
how many extensions are gonna be needed

00:05:56,380 --> 00:06:00,880
and there are a couple of examples of

00:05:58,120 --> 00:06:03,069
syscalls that had a fixed size struct

00:06:00,880 --> 00:06:05,949
that wasn't big enough or it's a fixed

00:06:03,069 --> 00:06:09,009
size struct where like the last three

00:06:05,949 --> 00:06:10,840
bytes are not used because there's no UN

00:06:09,009 --> 00:06:13,870
type that is useful to be fit in three

00:06:10,840 --> 00:06:17,520
bytes so this is quite frustrating and

00:06:13,870 --> 00:06:20,319
as with bit flags you could in principle

00:06:17,520 --> 00:06:22,000
add further extensions to a fixed size

00:06:20,319 --> 00:06:23,590
struct so you could if one of the bits

00:06:22,000 --> 00:06:25,240
in the structures are Flags argument you

00:06:23,590 --> 00:06:28,000
can make it like oh here's a flag saying

00:06:25,240 --> 00:06:29,759
the struct is this size the downside of

00:06:28,000 --> 00:06:32,550
that is that again it's annoying to use

00:06:29,759 --> 00:06:34,949
with bit flags it would be like Oh

00:06:32,550 --> 00:06:35,849
and the next argument is a struct and

00:06:34,949 --> 00:06:39,479
then you would have another struct

00:06:35,849 --> 00:06:42,990
argument but these are not them not the

00:06:39,479 --> 00:06:45,569
nicest way of solving this problem yeah

00:06:42,990 --> 00:06:47,280
so then we come into what I'm gonna be

00:06:45,569 --> 00:06:49,590
talking about now which is extensible

00:06:47,280 --> 00:06:52,319
structs so this is as I said better than

00:06:49,590 --> 00:06:54,599
spliced sliced bread this is a way for

00:06:52,319 --> 00:06:57,720
us to avoid most of the problems with

00:06:54,599 --> 00:06:59,669
fixed size structs without having to

00:06:57,720 --> 00:07:01,740
have without making the rules overly

00:06:59,669 --> 00:07:03,120
complicated and so I've given open at

00:07:01,740 --> 00:07:04,860
two which is this is cool I worked on

00:07:03,120 --> 00:07:08,009
which will be and hopefully will be in

00:07:04,860 --> 00:07:09,810
five point six which effectively what it

00:07:08,009 --> 00:07:11,909
does is that you pass

00:07:09,810 --> 00:07:13,860
so in DFT construct path is just like

00:07:11,909 --> 00:07:16,919
open then you have a structure called

00:07:13,860 --> 00:07:18,389
open howl which it has some fields in it

00:07:16,919 --> 00:07:21,330
which I'll show you in a second and then

00:07:18,389 --> 00:07:22,979
userspace passes the size that it thinks

00:07:21,330 --> 00:07:25,500
this structure is or rather the size of

00:07:22,979 --> 00:07:27,090
this structure in user space and there

00:07:25,500 --> 00:07:30,750
are a couple of rules for how you handle

00:07:27,090 --> 00:07:32,310
this size but the net result is that we

00:07:30,750 --> 00:07:34,259
can add new fields as much as we like

00:07:32,310 --> 00:07:37,560
you can add new fields to the kernel

00:07:34,259 --> 00:07:39,690
struct and because the user space passes

00:07:37,560 --> 00:07:41,610
both the struct and the struct size the

00:07:39,690 --> 00:07:43,650
colonel knows which fields user space is

00:07:41,610 --> 00:07:46,259
aware of so you remove the the whole

00:07:43,650 --> 00:07:48,930
passing garbage problem and you get

00:07:46,259 --> 00:07:50,219
order to get to in a second you get some

00:07:48,930 --> 00:07:52,469
nice photos of backwards compatibility

00:07:50,219 --> 00:07:53,550
but more importantly and this is the

00:07:52,469 --> 00:07:54,539
neatest thing about it is that user

00:07:53,550 --> 00:07:56,969
space doesn't need to care at all about

00:07:54,539 --> 00:07:58,529
what new fields have been added that it

00:07:56,969 --> 00:08:00,180
doesn't know about from its perspective

00:07:58,529 --> 00:08:02,370
it's just using whatever structure it

00:08:00,180 --> 00:08:04,830
had at the time when it was compiled and

00:08:02,370 --> 00:08:06,870
nobody else cares and this this design

00:08:04,830 --> 00:08:10,400
is not new it's actually used by five

00:08:06,870 --> 00:08:14,279
Siskel's it's used by sheds set a de

00:08:10,400 --> 00:08:15,750
perfil an open BPF cloned three and open

00:08:14,279 --> 00:08:17,550
at two other main syscalls that this is

00:08:15,750 --> 00:08:19,979
useful the main reason why I decided to

00:08:17,550 --> 00:08:21,479
give this talk is because during the

00:08:19,979 --> 00:08:22,710
discussion of clone 3 and open at 2

00:08:21,479 --> 00:08:25,889
there was a lot of disagreements about

00:08:22,710 --> 00:08:27,690
this style until we eventually was

00:08:25,889 --> 00:08:29,130
pointed out that this style already

00:08:27,690 --> 00:08:30,599
existed in all the nice benefits so

00:08:29,130 --> 00:08:33,360
hopefully we can we can eliminate those

00:08:30,599 --> 00:08:33,719
um those confusions so what are the

00:08:33,360 --> 00:08:35,579
rules

00:08:33,719 --> 00:08:37,669
how does this work it's a bit long I'm

00:08:35,579 --> 00:08:41,399
afraid but effective the idea is that

00:08:37,669 --> 00:08:43,589
given a structure we guarantee that or

00:08:41,399 --> 00:08:45,449
the kernel as the piano community we all

00:08:43,589 --> 00:08:45,650
agree that extension fields will always

00:08:45,449 --> 00:08:48,710
be

00:08:45,650 --> 00:08:51,740
appended to the structure that any

00:08:48,710 --> 00:08:54,230
future fields we are add to the end of

00:08:51,740 --> 00:08:55,910
the structure must have the requirement

00:08:54,230 --> 00:08:57,290
that there's zero value means the old

00:08:55,910 --> 00:08:58,760
behavior whatever that means for

00:08:57,290 --> 00:09:00,950
particular Siskel's the most obvious

00:08:58,760 --> 00:09:02,839
example would be a Flags field a Flags

00:09:00,950 --> 00:09:04,430
field that is equal to zero means don't

00:09:02,839 --> 00:09:07,339
use any of the new features so you can't

00:09:04,430 --> 00:09:08,660
depend on the size of the user space

00:09:07,339 --> 00:09:10,640
struct or whether or not that field is

00:09:08,660 --> 00:09:11,750
exists to determine whether or not a

00:09:10,640 --> 00:09:14,300
feature should be used it should always

00:09:11,750 --> 00:09:16,610
be if it's nonzero then we use it for

00:09:14,300 --> 00:09:18,020
whatever its use is and there's only

00:09:16,610 --> 00:09:20,960
three basically cases you have to care

00:09:18,020 --> 00:09:22,250
about is the soak a size a new size case

00:09:20,960 --> 00:09:24,140
size the size of the structure in the

00:09:22,250 --> 00:09:26,300
kernel you size the size destruction

00:09:24,140 --> 00:09:28,339
user space if case sizes you size then

00:09:26,300 --> 00:09:30,560
we just copy the struct as is you know

00:09:28,339 --> 00:09:31,970
pretty easy if the kernel struct is

00:09:30,560 --> 00:09:33,770
bigger than the user space structure

00:09:31,970 --> 00:09:35,839
that means that the kernel is newer than

00:09:33,770 --> 00:09:39,290
user space meaning it has more fields

00:09:35,839 --> 00:09:41,810
then we copy the user space struct and

00:09:39,290 --> 00:09:43,940
then the trailing bytes that the user

00:09:41,810 --> 00:09:45,950
space didn't know about we zero fill and

00:09:43,940 --> 00:09:47,390
that means effectively because we say

00:09:45,950 --> 00:09:48,770
well if user space didn't know about the

00:09:47,390 --> 00:09:51,490
new features then they're not using them

00:09:48,770 --> 00:09:54,320
so we can just disable them all and

00:09:51,490 --> 00:09:56,390
that's sort of I guess fairly obvious

00:09:54,320 --> 00:09:58,640
the the inverse though when the kernel

00:09:56,390 --> 00:09:59,990
is older than user space is where we get

00:09:58,640 --> 00:10:03,080
the nice forward compatibility feature

00:09:59,990 --> 00:10:05,240
we'd like which is that we if case size

00:10:03,080 --> 00:10:07,250
is small the new size we copy the size

00:10:05,240 --> 00:10:08,990
of the kernel struct so we ignore all of

00:10:07,250 --> 00:10:10,940
the trailing stuff from user space we

00:10:08,990 --> 00:10:12,290
don't copy it rather and then we check

00:10:10,940 --> 00:10:15,410
whether or not the trailing parts are

00:10:12,290 --> 00:10:16,640
all zeroed meaning any future extension

00:10:15,410 --> 00:10:18,800
with this which is kernels and know

00:10:16,640 --> 00:10:21,560
about if it's not if the feature is not

00:10:18,800 --> 00:10:23,360
used we don't care and we just we just

00:10:21,560 --> 00:10:24,740
continue on but if there is a feature

00:10:23,360 --> 00:10:25,940
used then we give an error to make sure

00:10:24,740 --> 00:10:28,730
that we don't accidentally ignore

00:10:25,940 --> 00:10:30,620
garbage passed to the kernel and all

00:10:28,730 --> 00:10:31,970
this stuff is already implemented in

00:10:30,620 --> 00:10:35,120
copy stroke from user which was merged

00:10:31,970 --> 00:10:37,160
in a few releases ago and I've ported

00:10:35,120 --> 00:10:38,959
most of the syscalls that use this style

00:10:37,160 --> 00:10:40,279
to using copy stroke from user so if

00:10:38,959 --> 00:10:41,630
you're implementing a siskel that wants

00:10:40,279 --> 00:10:43,370
to have some sort of accessibility just

00:10:41,630 --> 00:10:45,110
use copy store amusing you don't have to

00:10:43,370 --> 00:10:46,670
worry about it but I think it's neat to

00:10:45,110 --> 00:10:49,430
think about like with these three small

00:10:46,670 --> 00:10:51,020
rules we now can say okay any user space

00:10:49,430 --> 00:10:55,490
program has these nice extensibility

00:10:51,020 --> 00:10:57,140
benefits so here's an example of open a

00:10:55,490 --> 00:10:59,190
to clone 3 and BPF are both fairly

00:10:57,140 --> 00:11:01,260
similar and how they use this

00:10:59,190 --> 00:11:02,640
which is yeah you have you know your

00:11:01,260 --> 00:11:04,050
Cisco which takes a struck to the size

00:11:02,640 --> 00:11:05,760
and then you have some fields that

00:11:04,050 --> 00:11:07,710
you've added and then you add future

00:11:05,760 --> 00:11:09,150
fields at the end and so if we add a

00:11:07,710 --> 00:11:11,700
future field let's imagine we added some

00:11:09,150 --> 00:11:14,130
field that does some other flag bits the

00:11:11,700 --> 00:11:15,630
colonel would know that it would be zero

00:11:14,130 --> 00:11:16,980
if if it's on old colonel

00:11:15,630 --> 00:11:22,280
or if it's on new Connally you can use

00:11:16,980 --> 00:11:22,280
the new the new flag bits and

00:11:22,520 --> 00:11:26,700
confusingly this is sort of where I hope

00:11:25,170 --> 00:11:28,710
we've made some improvement over the old

00:11:26,700 --> 00:11:30,390
way of doing it so as I mentioned sheds

00:11:28,710 --> 00:11:32,640
said I don't perceive an open existed

00:11:30,390 --> 00:11:34,380
before we did this for clone three and

00:11:32,640 --> 00:11:38,430
so on and this these were introduced I

00:11:34,380 --> 00:11:39,990
think in 2014 it's a bit strange and a

00:11:38,430 --> 00:11:41,190
bit weirder and so I'm just wanted to

00:11:39,990 --> 00:11:42,570
give an example of hopefully we've

00:11:41,190 --> 00:11:44,820
improved some of the economics of these

00:11:42,570 --> 00:11:47,970
api's like for instance sheds data

00:11:44,820 --> 00:11:49,650
confusingly has a Flags field that is

00:11:47,970 --> 00:11:52,140
separate from the structure but the

00:11:49,650 --> 00:11:53,760
flags field is unused and the argument

00:11:52,140 --> 00:11:54,810
in if you look at the commit message and

00:11:53,760 --> 00:11:57,210
everything the argument is that this

00:11:54,810 --> 00:12:00,000
Flags field can be used to change the

00:11:57,210 --> 00:12:01,320
structure but because this oh and the

00:12:00,000 --> 00:12:02,370
other thing is the size is embedded in

00:12:01,320 --> 00:12:04,550
the structure so if you read the code

00:12:02,370 --> 00:12:06,900
you have to actually get the size first

00:12:04,550 --> 00:12:08,220
and the argument for all of this is that

00:12:06,900 --> 00:12:10,110
because the size is part of the

00:12:08,220 --> 00:12:11,190
structure if there's an error in other

00:12:10,110 --> 00:12:13,530
words if you're trying to use a new

00:12:11,190 --> 00:12:16,380
feature and the kernel doesn't support

00:12:13,530 --> 00:12:17,970
it then you would get the size of the

00:12:16,380 --> 00:12:19,770
kernel structure returned in the

00:12:17,970 --> 00:12:23,370
structure you passed so size gets

00:12:19,770 --> 00:12:25,320
updated if you get too big which is the

00:12:23,370 --> 00:12:29,460
error we give the problem with this is

00:12:25,320 --> 00:12:30,990
basically that well it's not a problem

00:12:29,460 --> 00:12:32,640
it's just odd like it's it's a bit weird

00:12:30,990 --> 00:12:34,200
and the whole having an extra Flags

00:12:32,640 --> 00:12:35,670
argument that isn't used for anything

00:12:34,200 --> 00:12:37,620
and really should have just been inside

00:12:35,670 --> 00:12:39,150
the structure is also good old shed get

00:12:37,620 --> 00:12:41,070
a door is even weirder because it has a

00:12:39,150 --> 00:12:43,860
size both as an argument and in the

00:12:41,070 --> 00:12:44,820
structure so yeah I think hopefully

00:12:43,860 --> 00:12:46,560
we've improved a little bit on that

00:12:44,820 --> 00:12:47,970
interface with just give us the

00:12:46,560 --> 00:12:51,270
structure and the size and don't worry

00:12:47,970 --> 00:12:54,900
about it but a bit of future work that I

00:12:51,270 --> 00:12:57,810
would hope we can get done which I think

00:12:54,900 --> 00:13:00,000
will be quite neat is right now checking

00:12:57,810 --> 00:13:00,690
what flags are supported by particular

00:13:00,000 --> 00:13:03,660
Cisco

00:13:00,690 --> 00:13:06,330
absolutely sucks like you have to go and

00:13:03,660 --> 00:13:08,700
try each each individual flag and you

00:13:06,330 --> 00:13:10,320
have to if it's if it's a flag if it's a

00:13:08,700 --> 00:13:11,670
Cisco that does like something

00:13:10,320 --> 00:13:12,150
potentially destructive you don't have

00:13:11,670 --> 00:13:15,060
to call

00:13:12,150 --> 00:13:16,860
with like examples where the Cisco is

00:13:15,060 --> 00:13:18,630
either a no op or it gives you an error

00:13:16,860 --> 00:13:20,160
but not e'en vowel

00:13:18,630 --> 00:13:21,480
because e'en value couldn't figure out

00:13:20,160 --> 00:13:23,580
whether it was the flag was missing or

00:13:21,480 --> 00:13:25,140
not so you have to come up with users

00:13:23,580 --> 00:13:27,210
basis to come up with a bunch of

00:13:25,140 --> 00:13:29,130
different examples on startup to check

00:13:27,210 --> 00:13:30,630
what Siskel's supporter by the kernel

00:13:29,130 --> 00:13:32,340
and which features of which the schools

00:13:30,630 --> 00:13:33,930
are supported and it's it's all a

00:13:32,340 --> 00:13:35,520
massive pain you have to do a bunch of

00:13:33,930 --> 00:13:37,410
retries you have to come up with with

00:13:35,520 --> 00:13:39,900
these these these fly combinations that

00:13:37,410 --> 00:13:41,400
will fail but not give you in eval we in

00:13:39,900 --> 00:13:42,930
Val which is funny obviously because a

00:13:41,400 --> 00:13:44,490
lot of syscalls give you e in val for

00:13:42,930 --> 00:13:47,510
things that aren't invalid flags like

00:13:44,490 --> 00:13:49,860
mount gives you e'en Val all the time

00:13:47,510 --> 00:13:51,900
and yeah and then whether on a

00:13:49,860 --> 00:13:54,810
particular field is supported at all

00:13:51,900 --> 00:13:56,610
is even more fun for fixed for fixed

00:13:54,810 --> 00:13:59,190
sized structs you have to do it field by

00:13:56,610 --> 00:14:00,690
field luckily with the extensible

00:13:59,190 --> 00:14:02,400
structure is required you know with the

00:14:00,690 --> 00:14:06,000
binary search on e too big but still

00:14:02,400 --> 00:14:08,010
it's it's still not great fun so the

00:14:06,000 --> 00:14:11,580
solution to this is let's add a flag

00:14:08,010 --> 00:14:14,160
that just on return so you set a flag

00:14:11,580 --> 00:14:15,510
inside the flags thing saying okay check

00:14:14,160 --> 00:14:17,130
fields is what I've called it here but

00:14:15,510 --> 00:14:20,930
we can call it whatever where we say

00:14:17,130 --> 00:14:24,030
okay here is the here's a flag saying

00:14:20,930 --> 00:14:26,430
this syscall is a no op I want you to

00:14:24,030 --> 00:14:28,350
tell me which parts of the structure

00:14:26,430 --> 00:14:31,080
that I've given you you support meaning

00:14:28,350 --> 00:14:33,450
that if you have flags that are

00:14:31,080 --> 00:14:35,130
unsupported so if you if you have if you

00:14:33,450 --> 00:14:37,290
have you basically set all the flag bits

00:14:35,130 --> 00:14:39,000
to here are the flags that are supported

00:14:37,290 --> 00:14:41,010
for this kernel and also any other

00:14:39,000 --> 00:14:43,020
fields you said to like all oh XD FEV

00:14:41,010 --> 00:14:45,510
saying like this field is valid for this

00:14:43,020 --> 00:14:46,800
kernel and then obviously you don't want

00:14:45,510 --> 00:14:48,150
it to be a no op where you've returned

00:14:46,800 --> 00:14:49,740
zero because that would be very

00:14:48,150 --> 00:14:51,000
confusing especially with like open you

00:14:49,740 --> 00:14:52,770
don't want to accidentally return zero

00:14:51,000 --> 00:14:55,290
when you know because that's actually FD

00:14:52,770 --> 00:14:57,090
so instead we read in return I've given

00:14:55,290 --> 00:14:59,250
in oh I know as an example which as an

00:14:57,090 --> 00:15:01,650
aside is a siskel that as far as I can

00:14:59,250 --> 00:15:02,910
tell has like five uses within Linux and

00:15:01,650 --> 00:15:06,180
one of them I've been told is actually a

00:15:02,910 --> 00:15:08,010
typo but yeah it basically it's it's you

00:15:06,180 --> 00:15:09,660
know I know it's least use a no value we

00:15:08,010 --> 00:15:13,200
can add a new one I don't really care

00:15:09,660 --> 00:15:16,290
and please that a new one okay I will

00:15:13,200 --> 00:15:18,660
add a new one EE no up or something and

00:15:16,290 --> 00:15:20,250
yeah and ideally this check fields flag

00:15:18,660 --> 00:15:22,410
would be the same flag but for

00:15:20,250 --> 00:15:24,240
everything just to avoid the Oklo exact

00:15:22,410 --> 00:15:25,150
problem where we have 15 different ways

00:15:24,240 --> 00:15:26,500
to

00:15:25,150 --> 00:15:29,500
Oh Chloe exec for differences calls and

00:15:26,500 --> 00:15:32,230
luckily as far as I'm aware most flag

00:15:29,500 --> 00:15:35,260
most old sis calls that got a new

00:15:32,230 --> 00:15:37,270
version switched from you 32 to 64 so

00:15:35,260 --> 00:15:38,740
actually the the topmost bit is actually

00:15:37,270 --> 00:15:41,950
free as far as I'm aware for most his

00:15:38,740 --> 00:15:43,360
calls and you and the rules for this

00:15:41,950 --> 00:15:44,950
would be very similar to copy structure

00:15:43,360 --> 00:15:46,210
music except obviously rather than

00:15:44,950 --> 00:15:48,760
reading from user space we're writing to

00:15:46,210 --> 00:15:50,260
user space so you would do if the kernel

00:15:48,760 --> 00:15:51,640
size is bigger than you size then you

00:15:50,260 --> 00:15:53,500
only deal with the first user size bytes

00:15:51,640 --> 00:15:54,730
you don't care about anything else so in

00:15:53,500 --> 00:15:56,200
other words if the kernel is newer you

00:15:54,730 --> 00:15:57,700
just ignore the bits of the kernel that

00:15:56,200 --> 00:16:00,220
the kernel has the space does know about

00:15:57,700 --> 00:16:02,260
and vice versa you you would zero fill

00:16:00,220 --> 00:16:04,380
the parts the kernel doesn't know about

00:16:02,260 --> 00:16:06,880
because the kernel doesn't support them

00:16:04,380 --> 00:16:09,070
okay and this would be like a trivial

00:16:06,880 --> 00:16:10,960
example obviously because some syscalls

00:16:09,070 --> 00:16:12,520
don't support this feature would not

00:16:10,960 --> 00:16:15,280
exist you'd have to deal with both but

00:16:12,520 --> 00:16:17,050
basically would have you know the old

00:16:15,280 --> 00:16:18,760
way of doing it final supported bits and

00:16:17,050 --> 00:16:21,790
then if we have check fields and you can

00:16:18,760 --> 00:16:24,010
do something like okay give us open a to

00:16:21,790 --> 00:16:26,020
with the check fields flag and then if

00:16:24,010 --> 00:16:28,090
you get you know an ax or whatever new

00:16:26,020 --> 00:16:31,240
error we decide then we can just check

00:16:28,090 --> 00:16:32,920
does that flag contain this bit and if

00:16:31,240 --> 00:16:35,560
it's a field we're checking for we check

00:16:32,920 --> 00:16:37,870
is that field nonzero which I think is

00:16:35,560 --> 00:16:39,970
it's much nicer and it allows us to

00:16:37,870 --> 00:16:41,770
avoid having to just reach right with a

00:16:39,970 --> 00:16:43,450
bunch of examples I mean if you want to

00:16:41,770 --> 00:16:44,590
check if I said an open flag or rename

00:16:43,450 --> 00:16:47,020
flag a supporter you have to come up

00:16:44,590 --> 00:16:48,280
with examples where you won't even break

00:16:47,020 --> 00:16:50,770
the system in checking I actually I

00:16:48,280 --> 00:16:52,180
guess you mount is the most fun one like

00:16:50,770 --> 00:16:55,720
how do you you check you amount without

00:16:52,180 --> 00:16:56,950
doing anything bad but anyway yeah there

00:16:55,720 --> 00:16:59,410
are a couple of caveats that just want

00:16:56,950 --> 00:17:01,270
to mention before I finish up and this

00:16:59,410 --> 00:17:03,490
is an argument that has raged on the

00:17:01,270 --> 00:17:05,110
main least a little bit is what things

00:17:03,490 --> 00:17:06,580
should be this extensible I think it's

00:17:05,110 --> 00:17:10,030
quite fair to say that not all syscall

00:17:06,580 --> 00:17:11,290
z/28 is extensible because well there

00:17:10,030 --> 00:17:13,270
are a couple of problems with having to

00:17:11,290 --> 00:17:14,620
require a start like a having to require

00:17:13,270 --> 00:17:17,020
a structure that you pass this point it

00:17:14,620 --> 00:17:18,580
to namely in some languages I know that

00:17:17,020 --> 00:17:21,970
there's some Zig folks that complain

00:17:18,580 --> 00:17:24,310
about this that having to allocate on

00:17:21,970 --> 00:17:25,990
the on the stack for a structure when

00:17:24,310 --> 00:17:30,060
it's like you're just passing one field

00:17:25,990 --> 00:17:33,850
is annoying to them I think that sorry

00:17:30,060 --> 00:17:35,410
yeah yes oh I think that it's fair to

00:17:33,850 --> 00:17:37,330
say that that we shouldn't have all

00:17:35,410 --> 00:17:38,440
Cisco's work this way but syscalls which

00:17:37,330 --> 00:17:40,720
are going to be extensible

00:17:38,440 --> 00:17:42,730
are gonna be extended a lot like clone 3

00:17:40,720 --> 00:17:45,669
is the most obvious example clone 3

00:17:42,730 --> 00:17:47,440
broke past the six arguments limits

00:17:45,669 --> 00:17:49,240
almost immediately the second effort was

00:17:47,440 --> 00:17:51,639
merged so I think it's fair to say that

00:17:49,240 --> 00:17:53,980
some schools do deserve this others

00:17:51,639 --> 00:17:55,299
maybe not and there has been a some

00:17:53,980 --> 00:17:59,169
argument about whether I octal should be

00:17:55,299 --> 00:18:00,730
this extensible I think it's been agreed

00:17:59,169 --> 00:18:02,440
that they shouldn't be though it turns

00:18:00,730 --> 00:18:04,960
out actually the second party does this

00:18:02,440 --> 00:18:06,669
there's a safe comm notify which is

00:18:04,960 --> 00:18:07,929
extensible it's extensible in a

00:18:06,669 --> 00:18:10,149
different way to the way I've described

00:18:07,929 --> 00:18:11,679
but I think that the reason why it was

00:18:10,149 --> 00:18:12,970
done that way is because the way that I

00:18:11,679 --> 00:18:15,850
just described wasn't really well known

00:18:12,970 --> 00:18:17,830
at the time and yeah and it's and even

00:18:15,850 --> 00:18:19,539
though we can just extend stuff you know

00:18:17,830 --> 00:18:21,490
the struct layout I'm planning from the

00:18:19,539 --> 00:18:22,570
outset is very important if otherwise

00:18:21,490 --> 00:18:24,039
you'll end up with a bunch of you know

00:18:22,570 --> 00:18:25,269
padding holes and also have to worry

00:18:24,039 --> 00:18:26,679
about obviously alignment of uses to

00:18:25,269 --> 00:18:27,940
basically all the problems we had to

00:18:26,679 --> 00:18:30,009
worry about before when it comes to

00:18:27,940 --> 00:18:31,360
planning ahead still exists so you can't

00:18:30,009 --> 00:18:34,179
just you know just say Yolo and just

00:18:31,360 --> 00:18:36,309
throw everything in but at the very

00:18:34,179 --> 00:18:38,169
least we're no longer bound by the size

00:18:36,309 --> 00:18:39,309
of the struct is the thing we decided 15

00:18:38,169 --> 00:18:43,389
years ago and we haven't thought about

00:18:39,309 --> 00:18:43,899
the sins okay that's it for me any

00:18:43,389 --> 00:18:47,879
questions

00:18:43,899 --> 00:18:47,879
oh boy

00:19:01,790 --> 00:19:09,060
so it looks like you're proposing that

00:19:05,370 --> 00:19:10,980
we just have arbitrarily flexible system

00:19:09,060 --> 00:19:13,290
call arguments at all times and you'll

00:19:10,980 --> 00:19:17,120
never know at any given time what you're

00:19:13,290 --> 00:19:17,120
expected to send to your system calls

00:19:18,050 --> 00:19:22,200
how am I supposed to deal with this from

00:19:20,340 --> 00:19:24,360
a security side where I have no idea

00:19:22,200 --> 00:19:27,240
what information is coming in to the

00:19:24,360 --> 00:19:29,340
system call or what to expect to go out

00:19:27,240 --> 00:19:33,140
of it because the parameters are always

00:19:29,340 --> 00:19:37,500
going to be different is this question

00:19:33,140 --> 00:19:40,620
well the question okay I'm getting out

00:19:37,500 --> 00:19:45,090
my pitch for here yes I was invited it

00:19:40,620 --> 00:19:47,760
says right there okay so how am I

00:19:45,090 --> 00:19:50,490
supposed to deal with the fact in the

00:19:47,760 --> 00:19:53,220
kernel proper that I have no idea what's

00:19:50,490 --> 00:19:55,470
coming in on any given system call well

00:19:53,220 --> 00:19:57,300
so this the struct would only ever be

00:19:55,470 --> 00:19:58,710
appended to so you do know for a

00:19:57,300 --> 00:20:02,250
particular kernel what's being passed

00:19:58,710 --> 00:20:03,930
down and all of the parts that the

00:20:02,250 --> 00:20:05,360
kernel doesn't know about are just being

00:20:03,930 --> 00:20:07,440
checked for whether or not they're zero

00:20:05,360 --> 00:20:10,080
effectively so like the meaning is

00:20:07,440 --> 00:20:11,790
depends on the kernel well the user

00:20:10,080 --> 00:20:13,230
space is going to be in if the user

00:20:11,790 --> 00:20:16,760
space is going to be independent of the

00:20:13,230 --> 00:20:19,140
kernel yeah and you never know what

00:20:16,760 --> 00:20:21,980
arguments the kernel is going to accept

00:20:19,140 --> 00:20:24,660
and you're going to be passing down

00:20:21,980 --> 00:20:27,060
who knows what because your user space

00:20:24,660 --> 00:20:28,380
is expecting to be able to do things the

00:20:27,060 --> 00:20:30,630
way they're done at this point as

00:20:28,380 --> 00:20:34,380
opposed to things they were done three

00:20:30,630 --> 00:20:36,150
weeks ago you're never gonna be able to

00:20:34,380 --> 00:20:37,440
verify how are you going to be able to

00:20:36,150 --> 00:20:40,080
verify that you're getting the right

00:20:37,440 --> 00:20:42,480
parameter yeah are you expecting that

00:20:40,080 --> 00:20:45,060
I'll ask quickly are you expecting the

00:20:42,480 --> 00:20:47,880
kernel to verify the the parameters

00:20:45,060 --> 00:20:51,780
you're sending are consistent with its

00:20:47,880 --> 00:20:53,910
expectations yes so you it would be

00:20:51,780 --> 00:20:55,530
basically the kernel should I got no

00:20:53,910 --> 00:20:57,360
certainly are saying so the structure is

00:20:55,530 --> 00:20:59,040
going to only be appended to so any kind

00:20:57,360 --> 00:21:02,040
of release would only add new fields and

00:20:59,040 --> 00:21:04,590
those my fields would be what if the

00:21:02,040 --> 00:21:07,350
application sends and stuff beyond what

00:21:04,590 --> 00:21:09,120
you expect so like more fields than you

00:21:07,350 --> 00:21:11,130
would expect right it should that be a

00:21:09,120 --> 00:21:12,540
failure yeah you would get a failure you

00:21:11,130 --> 00:21:13,340
get each big in that case so you would

00:21:12,540 --> 00:21:14,980
get an

00:21:13,340 --> 00:21:17,660
you would get that because you would

00:21:14,980 --> 00:21:20,000
because the value of the fields being

00:21:17,660 --> 00:21:21,290
provided is nonzero so if someone passed

00:21:20,000 --> 00:21:23,330
a pointer or some flag that you don't

00:21:21,290 --> 00:21:26,120
know about you get e to bake immediately

00:21:23,330 --> 00:21:27,500
but like the check is it's a copy start

00:21:26,120 --> 00:21:29,660
from user like the check is immediately

00:21:27,500 --> 00:21:31,190
after the copy from user like it's that

00:21:29,660 --> 00:21:33,110
it's the next line literally in the in

00:21:31,190 --> 00:21:34,730
the in the function so it's like it

00:21:33,110 --> 00:21:36,250
basically does like it just checks

00:21:34,730 --> 00:21:40,400
zeroed user so it's like it's like a

00:21:36,250 --> 00:21:44,480
it's like mmm sure inverse of zero bytes

00:21:40,400 --> 00:21:46,970
on the thing that's passed down but what

00:21:44,480 --> 00:21:50,090
if zero bytes is a valid valid value

00:21:46,970 --> 00:21:52,340
they we got yes there's a zero bytes are

00:21:50,090 --> 00:21:54,800
fine but zero bytes as I mentioned oh

00:21:52,340 --> 00:21:57,340
boy let's see if I have it here yeah so

00:21:54,800 --> 00:22:00,860
so the essentials always appended and

00:21:57,340 --> 00:22:03,080
any future field that we add has zero

00:22:00,860 --> 00:22:04,520
mean whatever it was before we out of

00:22:03,080 --> 00:22:07,190
the field so that this is his call

00:22:04,520 --> 00:22:08,990
dependent obviously but the most obvious

00:22:07,190 --> 00:22:11,570
example is like a flags field your dad

00:22:08,990 --> 00:22:13,760
if the flags field is zero then none of

00:22:11,570 --> 00:22:16,310
the new Flags are enabled and the kernel

00:22:13,760 --> 00:22:18,560
old kernels would check these new fields

00:22:16,310 --> 00:22:21,800
that I have no idea about are they all

00:22:18,560 --> 00:22:24,770
zeroed like are all the bytes from K

00:22:21,800 --> 00:22:27,110
sighs to you sighs are they all zeroed

00:22:24,770 --> 00:22:28,910
if not then we give an error immediately

00:22:27,110 --> 00:22:31,100
and if it they're all zero then we're

00:22:28,910 --> 00:22:32,900
like okay I guess whatever new Karl

00:22:31,100 --> 00:22:37,160
features this user space is expecting it

00:22:32,900 --> 00:22:39,140
doesn't need so we just continue on okay

00:22:37,160 --> 00:22:42,620
okay we can we can continue this chat

00:22:39,140 --> 00:22:45,250
outside if you like ye did yeah yeah

00:22:42,620 --> 00:22:45,250
okay

00:22:54,990 --> 00:23:01,450
hello in ideal world where you can break

00:22:59,410 --> 00:23:03,670
backward compatibility what will be

00:23:01,450 --> 00:23:07,330
better way to implement that than just

00:23:03,670 --> 00:23:08,890
adding just patting the memory with

00:23:07,330 --> 00:23:12,460
zeros thank you

00:23:08,890 --> 00:23:14,020
in an ideal world yeah I mean in an

00:23:12,460 --> 00:23:15,400
ideal world we could just make it so

00:23:14,020 --> 00:23:17,380
that we have a new strategy I'm going on

00:23:15,400 --> 00:23:22,780
a new feature the nice thing about doing

00:23:17,380 --> 00:23:24,040
it this way is that so there are the

00:23:22,780 --> 00:23:25,990
like there are some schools that use

00:23:24,040 --> 00:23:28,660
version numbers like the capability ones

00:23:25,990 --> 00:23:29,920
use version numbers but the the the

00:23:28,660 --> 00:23:32,320
downside of having a version number

00:23:29,920 --> 00:23:33,940
which is just a version number is that

00:23:32,320 --> 00:23:37,510
old Colonels have no idea what to do

00:23:33,940 --> 00:23:38,470
with it and I think it's neat that we

00:23:37,510 --> 00:23:41,500
can we can try to solve this problem

00:23:38,470 --> 00:23:42,790
that way but ideally you could say

00:23:41,500 --> 00:23:43,930
ideally if we didn't get our backwards

00:23:42,790 --> 00:23:46,030
compatibility then you could just make a

00:23:43,930 --> 00:23:49,090
new struct each time though I personally

00:23:46,030 --> 00:23:50,290
think that yeah that extent being able

00:23:49,090 --> 00:23:52,840
to send that is like a neat thing to be

00:23:50,290 --> 00:23:54,250
able to do anyway especially cuz you get

00:23:52,840 --> 00:23:56,080
forwards compatibility as well I think

00:23:54,250 --> 00:23:57,430
is the neat thing yeah so like we've

00:23:56,080 --> 00:24:00,760
been doing this for years with iocked

00:23:57,430 --> 00:24:03,850
tools and graphics subsystem but one

00:24:00,760 --> 00:24:06,280
thing we've also added was like you have

00:24:03,850 --> 00:24:10,510
to let users base know that this can be

00:24:06,280 --> 00:24:11,860
used so like we add the new fields when

00:24:10,510 --> 00:24:13,090
you just based art you don't want the

00:24:11,860 --> 00:24:15,070
news to say it's certainly assuming that

00:24:13,090 --> 00:24:16,330
on older kernels they can start passing

00:24:15,070 --> 00:24:18,640
those new fields down if it's built

00:24:16,330 --> 00:24:20,800
against new headers right so at least

00:24:18,640 --> 00:24:22,480
some way for the system to notify users

00:24:20,800 --> 00:24:24,940
base that it was allowed use that you

00:24:22,480 --> 00:24:27,070
could keep bouncing Ino say Santino no

00:24:24,940 --> 00:24:29,350
but it's really not it it's a bit of a

00:24:27,070 --> 00:24:31,420
hostile thing for users to have to call

00:24:29,350 --> 00:24:33,490
us this call five times if you start

00:24:31,420 --> 00:24:34,990
scaling this out like for if I'm on an

00:24:33,490 --> 00:24:37,210
old kernel I have to call this syscall

00:24:34,990 --> 00:24:39,370
five times I have no idea of which

00:24:37,210 --> 00:24:40,780
version I should be using that yep there

00:24:39,370 --> 00:24:42,580
should be some way for the kernel as

00:24:40,780 --> 00:24:44,530
well possibly separate to this through

00:24:42,580 --> 00:24:46,720
some other mechanism that it can tell

00:24:44,530 --> 00:24:49,750
user space what version of Cisco is

00:24:46,720 --> 00:24:51,910
acceptable to it or what size yep and

00:24:49,750 --> 00:24:54,220
actually that is exactly what check

00:24:51,910 --> 00:24:56,410
fields would allow you to do it's not as

00:24:54,220 --> 00:24:58,030
directors here is the size instead it

00:24:56,410 --> 00:25:00,250
does a little bit more it also tells you

00:24:58,030 --> 00:25:02,490
what the flags that supported are yeah

00:25:00,250 --> 00:25:02,490
sorry

00:25:05,620 --> 00:25:09,919
this is user space would do this as like

00:25:08,240 --> 00:25:11,509
the initial thing so it's just once its

00:25:09,919 --> 00:25:13,039
goal and you say yeah right now this

00:25:11,509 --> 00:25:14,330
doesn't exist so right now you're quite

00:25:13,039 --> 00:25:16,070
right you have to do it five times and

00:25:14,330 --> 00:25:17,330
it's a real pain especially if you like

00:25:16,070 --> 00:25:19,100
tried it with mount and unmount I was

00:25:17,330 --> 00:25:20,720
like wait a second how do I not

00:25:19,100 --> 00:25:21,950
accidentally break slash when I'm

00:25:20,720 --> 00:25:23,960
checking on Mount Allah exactly I

00:25:21,950 --> 00:25:25,220
completely agree and I think that this

00:25:23,960 --> 00:25:26,690
would be a neat thing and the nice thing

00:25:25,220 --> 00:25:28,009
about this is that it like it perfectly

00:25:26,690 --> 00:25:29,539
fits in with having you be sensible

00:25:28,009 --> 00:25:31,629
struct because it also tells you the

00:25:29,539 --> 00:25:34,490
size because you know that the last

00:25:31,629 --> 00:25:36,590
sorry the last non-zero byte of the

00:25:34,490 --> 00:25:39,649
thing you get back is going to be the

00:25:36,590 --> 00:25:42,019
size of the kernel struct yeah okay I

00:25:39,649 --> 00:25:43,940
think that's it yeah well I think we're

00:25:42,019 --> 00:25:44,710
out of time so please thank Alexa for

00:25:43,940 --> 00:25:50,630
his talk

00:25:44,710 --> 00:25:50,630

YouTube URL: https://www.youtube.com/watch?v=ggD-eb3yPVs


