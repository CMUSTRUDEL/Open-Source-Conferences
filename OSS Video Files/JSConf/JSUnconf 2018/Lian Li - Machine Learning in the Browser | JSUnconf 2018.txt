Title: Lian Li - Machine Learning in the Browser | JSUnconf 2018
Publication date: 2018-05-13
Playlist: JSUnconf 2018
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:12,719
I said I'm gonna not move from here all

00:00:10,860 --> 00:00:14,549
right hello welcome thank you for

00:00:12,719 --> 00:00:16,320
joining me for this talk machine

00:00:14,549 --> 00:00:18,330
learning in the browser and I'm really

00:00:16,320 --> 00:00:20,910
happy that we could like start with some

00:00:18,330 --> 00:00:22,650
fluffiness today and gonna end with some

00:00:20,910 --> 00:00:23,840
fluffiness in this room so I'm really

00:00:22,650 --> 00:00:27,260
really proud of that

00:00:23,840 --> 00:00:29,039
so for those who don't know me yet oh

00:00:27,260 --> 00:00:33,059
this is not working

00:00:29,039 --> 00:00:40,379
oh wait because I turned it off yes this

00:00:33,059 --> 00:00:43,010
is me hello yes please come in hi no

00:00:40,379 --> 00:00:43,010
take your time

00:00:43,100 --> 00:00:51,180
all right so this is me this is actually

00:00:47,039 --> 00:00:52,829
not me so there's a company called Lian

00:00:51,180 --> 00:00:55,500
Li and they've basically be haunting me

00:00:52,829 --> 00:00:57,629
my entire life because people my friends

00:00:55,500 --> 00:01:00,480
come up to me who are also in the

00:00:57,629 --> 00:01:02,340
industry sometimes and they're like do

00:01:00,480 --> 00:01:05,339
you know of this company that's named

00:01:02,340 --> 00:01:08,070
Lian Li so like this is a friend of mine

00:01:05,339 --> 00:01:10,500
most recently was like haha I was a

00:01:08,070 --> 00:01:12,150
computer and like I was like okay I'm

00:01:10,500 --> 00:01:14,820
gonna be super polite and just like it

00:01:12,150 --> 00:01:16,320
and he liked it himself again like he

00:01:14,820 --> 00:01:18,509
liked his own post that he posted to my

00:01:16,320 --> 00:01:21,240
timeline and he was so happy with his

00:01:18,509 --> 00:01:23,909
post that he commented on it again with

00:01:21,240 --> 00:01:25,530
a smiley face so this is basically my

00:01:23,909 --> 00:01:27,720
relationship with the company Lee and

00:01:25,530 --> 00:01:29,970
Lee so they've been haunting their whole

00:01:27,720 --> 00:01:32,490
life like I said and I want to asked you

00:01:29,970 --> 00:01:35,130
to help me with something this is the

00:01:32,490 --> 00:01:36,960
situation on Twitter right now I have

00:01:35,130 --> 00:01:41,790
I'm shy of a hundred and ninety

00:01:36,960 --> 00:01:43,020
followers 191 as soon as I hit 892 I'm

00:01:41,790 --> 00:01:46,770
gonna ask Twitter to give me the

00:01:43,020 --> 00:01:49,710
checkmark and that will be the first

00:01:46,770 --> 00:01:51,990
step when people start asking them like

00:01:49,710 --> 00:01:53,369
do you know the speaker Lee Anne Lee and

00:01:51,990 --> 00:01:54,659
they're like oh of course we do like

00:01:53,369 --> 00:01:57,570
we've been in this business for thirty

00:01:54,659 --> 00:02:01,740
years now so yeah please follow me on

00:01:57,570 --> 00:02:03,360
Twitter or on github or on mass I have

00:02:01,740 --> 00:02:04,890
three followers of macedon so if you

00:02:03,360 --> 00:02:05,549
could like follow me there that would be

00:02:04,890 --> 00:02:07,710
great

00:02:05,549 --> 00:02:09,959
I don't think Lee Anne Lee is on there

00:02:07,710 --> 00:02:13,590
so I might get like a checkmark there

00:02:09,959 --> 00:02:17,129
just like that so yes that was the joke

00:02:13,590 --> 00:02:19,560
the introduction joke something else I

00:02:17,129 --> 00:02:22,590
do I'm a software engineer at pnina

00:02:19,560 --> 00:02:25,220
solutions it's a company doing cloud

00:02:22,590 --> 00:02:27,390
native consultancy based in Amsterdam

00:02:25,220 --> 00:02:28,670
it's really not that interesting I'm not

00:02:27,390 --> 00:02:32,459
gonna talk about my company because

00:02:28,670 --> 00:02:35,190
that's my day job during the night or

00:02:32,459 --> 00:02:37,680
any other time of day I am a machine

00:02:35,190 --> 00:02:39,900
learning enthusiast and by that I mean I

00:02:37,680 --> 00:02:43,290
have no education actually on machine

00:02:39,900 --> 00:02:45,360
learning I just did a course on Coursera

00:02:43,290 --> 00:02:48,239
which I highly recommend is like a

00:02:45,360 --> 00:02:50,310
12-week sucking out your soul kind of

00:02:48,239 --> 00:02:52,620
like super math intense course but it's

00:02:50,310 --> 00:02:54,480
like at the others end you're like okay

00:02:52,620 --> 00:02:59,250
I did something with my life

00:02:54,480 --> 00:03:01,290
so highly recommend this course I'm

00:02:59,250 --> 00:03:04,050
gonna show you I think I have a link on

00:03:01,290 --> 00:03:06,120
the slide later so okay let's talk about

00:03:04,050 --> 00:03:08,340
machine learning why do we want to do

00:03:06,120 --> 00:03:12,060
machine learning I think who hasn't

00:03:08,340 --> 00:03:13,620
heard of machine learning yet okay well

00:03:12,060 --> 00:03:14,370
maybe other way around who has heard of

00:03:13,620 --> 00:03:19,379
machine learning

00:03:14,370 --> 00:03:21,510
okay that's most okay so for this to be

00:03:19,379 --> 00:03:23,580
makes sense I have to take we have to

00:03:21,510 --> 00:03:25,950
take a look at how s expert system words

00:03:23,580 --> 00:03:28,470
so expert systems is what you built when

00:03:25,950 --> 00:03:30,900
you do conventional coding and the idea

00:03:28,470 --> 00:03:32,400
is kind of that you have a solution and

00:03:30,900 --> 00:03:35,010
the solution is your code you have a

00:03:32,400 --> 00:03:38,129
problem trying to find a solution you

00:03:35,010 --> 00:03:40,200
write this code as a solution and for

00:03:38,129 --> 00:03:42,060
that you kind of need like a person it

00:03:40,200 --> 00:03:44,400
was usually a developer and the

00:03:42,060 --> 00:03:46,260
developer has to maintain the code write

00:03:44,400 --> 00:03:48,930
the code expand the code so everything

00:03:46,260 --> 00:03:51,569
kind of funnels to him and for him to do

00:03:48,930 --> 00:03:54,060
a good job he has to do things like read

00:03:51,569 --> 00:03:56,519
documentation like use third-party

00:03:54,060 --> 00:03:58,530
libraries maybe or maybe has to talk to

00:03:56,519 --> 00:04:00,959
the main expert

00:03:58,530 --> 00:04:02,819
but the important thing here to take

00:04:00,959 --> 00:04:05,069
away from the slide basically is that

00:04:02,819 --> 00:04:06,239
everything goes to this one person and

00:04:05,069 --> 00:04:10,650
he has to have a perfect understanding

00:04:06,239 --> 00:04:12,840
of the system now if we look at machine

00:04:10,650 --> 00:04:15,030
learning it's kind of different

00:04:12,840 --> 00:04:17,400
so the solution in machine learning is a

00:04:15,030 --> 00:04:19,739
model the model it's a statistical model

00:04:17,400 --> 00:04:22,139
so everything's kind of represented in

00:04:19,739 --> 00:04:24,030
numbers and there are no like if you

00:04:22,139 --> 00:04:25,200
didn't implement this edge case where

00:04:24,030 --> 00:04:27,090
there's no really implementing of

00:04:25,200 --> 00:04:28,470
educators it still works it doesn't

00:04:27,090 --> 00:04:33,360
break it just gives you maybe like a

00:04:28,470 --> 00:04:37,350
weird number and the model is not built

00:04:33,360 --> 00:04:39,479
by hand by a developer it's just spit

00:04:37,350 --> 00:04:42,389
out by code by a machine learning

00:04:39,479 --> 00:04:44,639
algorithm so you run an algorithm and it

00:04:42,389 --> 00:04:48,479
gives you a model in the end explained

00:04:44,639 --> 00:04:51,300
to you and for this to work basically

00:04:48,479 --> 00:04:53,130
for this code to run efficiently or to

00:04:51,300 --> 00:04:56,310
do what it's supposed to do you need

00:04:53,130 --> 00:04:58,740
some data and you may need some kind of

00:04:56,310 --> 00:05:01,260
like data or machine learning experts so

00:04:58,740 --> 00:05:04,200
these data ml experts do not necessarily

00:05:01,260 --> 00:05:05,820
need to be domain experts although it

00:05:04,200 --> 00:05:08,669
does make sense for them to understand

00:05:05,820 --> 00:05:10,740
the domain but mainly they need to

00:05:08,669 --> 00:05:12,750
understand the statistical basically

00:05:10,740 --> 00:05:15,870
behavior of this pattern that they're

00:05:12,750 --> 00:05:18,030
trying to learn and adapt to so

00:05:15,870 --> 00:05:20,130
everything in the end kind of hinges on

00:05:18,030 --> 00:05:23,580
the data the data has to be the right

00:05:20,130 --> 00:05:25,740
amount the right format and yeah that's

00:05:23,580 --> 00:05:29,190
kind of the our job here in machine

00:05:25,740 --> 00:05:31,500
learning um so machine learning

00:05:29,190 --> 00:05:33,390
basically the kind of the way it works

00:05:31,500 --> 00:05:36,600
is pretty simple it's like how we learn

00:05:33,390 --> 00:05:38,640
as well for one there's experience you

00:05:36,600 --> 00:05:41,130
need experience that's the number of

00:05:38,640 --> 00:05:44,880
data points so like you have like

00:05:41,130 --> 00:05:47,250
different kinds of data points that

00:05:44,880 --> 00:05:51,060
represent different you know instances

00:05:47,250 --> 00:05:53,729
of the behavior you want to basically

00:05:51,060 --> 00:05:55,860
adapt to and then the other thing the

00:05:53,729 --> 00:05:58,950
same thing how we learn is repetition

00:05:55,860 --> 00:06:02,990
that's basically our number of training

00:05:58,950 --> 00:06:06,510
iterations so you were gonna have to

00:06:02,990 --> 00:06:09,060
take the same data points and then just

00:06:06,510 --> 00:06:10,400
train them a lot of times and by

00:06:09,060 --> 00:06:12,830
repeating you kind

00:06:10,400 --> 00:06:15,650
learn pattern behind it so pretty much

00:06:12,830 --> 00:06:16,570
this is kind of how we imagine people to

00:06:15,650 --> 00:06:19,669
learn as well

00:06:16,570 --> 00:06:21,290
right then the other thing that people

00:06:19,669 --> 00:06:23,300
have already asked me about like why

00:06:21,290 --> 00:06:25,070
does everything have to be JavaScript

00:06:23,300 --> 00:06:29,540
like can't you just not do that in

00:06:25,070 --> 00:06:34,430
JavaScript yes good point you could also

00:06:29,540 --> 00:06:36,710
not do it in JavaScript no well there

00:06:34,430 --> 00:06:38,389
are some arguments that I could make for

00:06:36,710 --> 00:06:41,120
client-side machine learning and I think

00:06:38,389 --> 00:06:44,449
you could think of some as well for one

00:06:41,120 --> 00:06:46,580
like speed not everyone lives in like a

00:06:44,449 --> 00:06:48,530
first world country some of us live in

00:06:46,580 --> 00:06:52,340
Germany where the internet speed is not

00:06:48,530 --> 00:06:54,889
always that great and then maybe you

00:06:52,340 --> 00:06:56,240
don't want to wait like two minutes for

00:06:54,889 --> 00:06:57,880
the server to answer you with the

00:06:56,240 --> 00:07:01,070
prediction or

00:06:57,880 --> 00:07:03,470
get from it then the other thing is

00:07:01,070 --> 00:07:06,800
availability again if you live in

00:07:03,470 --> 00:07:08,900
Germany you don't always have internet

00:07:06,800 --> 00:07:11,090
so maybe you just can't connect to the

00:07:08,900 --> 00:07:12,710
server and so that maybe you want to do

00:07:11,090 --> 00:07:16,880
the prediction on your client on your

00:07:12,710 --> 00:07:19,700
website or on your phone and then the

00:07:16,880 --> 00:07:24,080
third argument that I could bring this

00:07:19,700 --> 00:07:27,530
security so maybe you don't want to send

00:07:24,080 --> 00:07:29,240
your images to a third-party server to

00:07:27,530 --> 00:07:31,460
train on it and then predict something

00:07:29,240 --> 00:07:34,639
maybe you just want to do everything on

00:07:31,460 --> 00:07:37,639
your phone or on your own client should

00:07:34,639 --> 00:07:39,919
have more control over your data so all

00:07:37,639 --> 00:07:42,050
these arguments I think are valid enough

00:07:39,919 --> 00:07:43,880
to see effect you could build something

00:07:42,050 --> 00:07:50,090
with JavaScript so it runs a new browser

00:07:43,880 --> 00:07:51,620
right all right I want to try to explain

00:07:50,090 --> 00:07:53,900
the basic principles of machine learning

00:07:51,620 --> 00:07:56,240
to you and for that I think the best way

00:07:53,900 --> 00:07:58,669
is to think of an example that makes

00:07:56,240 --> 00:08:02,599
sense and then try it should translate

00:07:58,669 --> 00:08:06,740
like those really mad C terms to things

00:08:02,599 --> 00:08:10,000
that you know we all can understand all

00:08:06,740 --> 00:08:12,620
right and the example that I picked is

00:08:10,000 --> 00:08:15,110
complementary colors so the idea here is

00:08:12,620 --> 00:08:17,389
to input a specific color which is RGB

00:08:15,110 --> 00:08:20,090
channels so we're inputting three values

00:08:17,389 --> 00:08:22,550
which is the value for red green and

00:08:20,090 --> 00:08:24,410
blue and then we're outputting we're

00:08:22,550 --> 00:08:26,930
trying to predict the

00:08:24,410 --> 00:08:28,100
complementary color complementary color

00:08:26,930 --> 00:08:31,330
in case you don't know it's basically

00:08:28,100 --> 00:08:34,730
the opposite color of the color spectrum

00:08:31,330 --> 00:08:39,050
yeah you are like no one's totally lost

00:08:34,730 --> 00:08:41,090
here good alright so let's talk about

00:08:39,050 --> 00:08:42,500
terminology for a while because I'm

00:08:41,090 --> 00:08:44,930
gonna probably switch back and forth

00:08:42,500 --> 00:08:52,730
between the machine learning words and

00:08:44,930 --> 00:08:55,160
normal words so I'm gonna like do some

00:08:52,730 --> 00:08:57,440
like simple diagrams so we can all be on

00:08:55,160 --> 00:09:01,100
the same page when I expert explained

00:08:57,440 --> 00:09:04,730
later on so first we have our input an

00:09:01,100 --> 00:09:07,390
input it B or color the color we want to

00:09:04,730 --> 00:09:10,730
do the complementary color prediction on

00:09:07,390 --> 00:09:13,190
we pass that input into like a function

00:09:10,730 --> 00:09:15,890
something like a function and then we

00:09:13,190 --> 00:09:20,150
get an output that is the basic idea of

00:09:15,890 --> 00:09:22,100
any system right if we were to do it not

00:09:20,150 --> 00:09:23,720
with machine learning but with expert

00:09:22,100 --> 00:09:27,080
system we would also have something like

00:09:23,720 --> 00:09:29,150
that now if you look at like how we do

00:09:27,080 --> 00:09:32,090
it in machine learning the inputs become

00:09:29,150 --> 00:09:33,890
our features and in this case we have

00:09:32,090 --> 00:09:35,840
three features because we have like

00:09:33,890 --> 00:09:39,200
value for read a value for a green and a

00:09:35,840 --> 00:09:42,260
value blue then the function would be a

00:09:39,200 --> 00:09:44,570
network and like the network like it's a

00:09:42,260 --> 00:09:47,060
network of nodes right and each net node

00:09:44,570 --> 00:09:48,950
is already a function but like the

00:09:47,060 --> 00:09:50,570
entire network would be like like a

00:09:48,950 --> 00:09:53,360
total like a function of functions if

00:09:50,570 --> 00:09:55,250
you know what I'm getting here but we

00:09:53,360 --> 00:09:56,900
can look at it for now is like one

00:09:55,250 --> 00:09:59,000
function we pass something in and then

00:09:56,900 --> 00:10:03,410
we get something out and the output

00:09:59,000 --> 00:10:04,640
would be our prediction now M network

00:10:03,410 --> 00:10:05,780
and prediction have the same color here

00:10:04,640 --> 00:10:07,640
because the prediction is always

00:10:05,780 --> 00:10:10,640
dependent on a specific network if you

00:10:07,640 --> 00:10:12,200
in if we put in the same values in the

00:10:10,640 --> 00:10:16,460
exact same network you would always get

00:10:12,200 --> 00:10:18,230
the exact same prediction now if you

00:10:16,460 --> 00:10:20,060
want to like if you're starting with

00:10:18,230 --> 00:10:22,250
machine learning and starting with a new

00:10:20,060 --> 00:10:25,640
network usually your prediction is

00:10:22,250 --> 00:10:29,030
pretty crummy and in the beginning so

00:10:25,640 --> 00:10:31,430
what we kind of need to train is to also

00:10:29,030 --> 00:10:33,860
know in this case what our desired

00:10:31,430 --> 00:10:36,860
output would be what is the color that

00:10:33,860 --> 00:10:39,290
we do want it to predict and this is

00:10:36,860 --> 00:10:44,540
called the target this is what we want

00:10:39,290 --> 00:10:47,350
to predict right and so in this diagram

00:10:44,540 --> 00:10:50,330
what I wanted to show kind of is that

00:10:47,350 --> 00:10:52,670
the blue and the green ones this is the

00:10:50,330 --> 00:10:54,740
data that we actually need to do the

00:10:52,670 --> 00:10:55,880
training because then the network and

00:10:54,740 --> 00:10:58,160
the prediction is something that we're

00:10:55,880 --> 00:11:00,320
going to come up but we're gonna train

00:10:58,160 --> 00:11:04,340
by ourselves but we need to have like a

00:11:00,320 --> 00:11:05,770
good data set that's the input and the

00:11:04,340 --> 00:11:07,730
target or the features in the target

00:11:05,770 --> 00:11:10,220
this is just important for you to

00:11:07,730 --> 00:11:11,830
understand so a complementary Carlos is

00:11:10,220 --> 00:11:14,180
actually a really good example because

00:11:11,830 --> 00:11:16,040
we don't have to do a lot of data mining

00:11:14,180 --> 00:11:18,170
we don't have to go out and you know try

00:11:16,040 --> 00:11:20,300
to find like labeled data it's pretty

00:11:18,170 --> 00:11:24,620
easy to just generate data on the fly

00:11:20,300 --> 00:11:27,050
when you just want to try stuff out so

00:11:24,620 --> 00:11:28,970
this is kind of how our input generation

00:11:27,050 --> 00:11:31,550
could look like we just basically have

00:11:28,970 --> 00:11:34,610
to generate a random value between 0 and

00:11:31,550 --> 00:11:36,860
255 and then you know do that three

00:11:34,610 --> 00:11:40,400
times put in an array that's basically

00:11:36,860 --> 00:11:43,070
one random color and we just do that

00:11:40,400 --> 00:11:44,930
like 10,000 times for 10,000 data points

00:11:43,070 --> 00:11:47,450
and then there's a function for the

00:11:44,930 --> 00:11:50,390
output which is the so this is our

00:11:47,450 --> 00:11:51,890
desired output right I didn't put the

00:11:50,390 --> 00:11:53,180
full function there but there's a link

00:11:51,890 --> 00:11:55,610
to Stack Overflow if you want to check

00:11:53,180 --> 00:11:58,070
it out how to compute our complimentary

00:11:55,610 --> 00:12:01,280
colors just know that in the end you

00:11:58,070 --> 00:12:06,110
again have an array with values between

00:12:01,280 --> 00:12:07,550
0 and 255 all right to make it kind of

00:12:06,110 --> 00:12:09,230
easier to understand what we're getting

00:12:07,550 --> 00:12:11,390
at here how we're trying to build this

00:12:09,230 --> 00:12:14,320
thing I'd created this nice handy

00:12:11,390 --> 00:12:18,230
checklist so first thing we need data

00:12:14,320 --> 00:12:19,550
got that next thing kind of need a

00:12:18,230 --> 00:12:22,400
network thingy

00:12:19,550 --> 00:12:26,150
to make a prediction right when we have

00:12:22,400 --> 00:12:27,230
that doing something awesome in the end

00:12:26,150 --> 00:12:29,120
it's gonna be awesome

00:12:27,230 --> 00:12:30,680
that's all we need to know for now in

00:12:29,120 --> 00:12:34,610
your network then do something awesome

00:12:30,680 --> 00:12:36,560
gonna be awesome right the nice thing is

00:12:34,610 --> 00:12:38,690
that we don't have to implement every

00:12:36,560 --> 00:12:41,210
network by itself there's like Google

00:12:38,690 --> 00:12:43,270
doing stuff like deep lunges and

00:12:41,210 --> 00:12:46,360
different yes

00:12:43,270 --> 00:12:48,640
it is based on tensile flow I don't know

00:12:46,360 --> 00:12:51,160
if any of you have ever heard of tensile

00:12:48,640 --> 00:12:54,130
flow yes I see some heads nodding and

00:12:51,160 --> 00:12:56,260
fingers going up yes cool so deep learn

00:12:54,130 --> 00:12:58,570
Jess or as it's called now actually I

00:12:56,260 --> 00:12:59,850
think they released it like last week

00:12:58,570 --> 00:13:02,590
thank you google

00:12:59,850 --> 00:13:05,050
it's called tensorflow jess now it's

00:13:02,590 --> 00:13:06,850
like I said before they changed the API

00:13:05,050 --> 00:13:09,820
so the code I'm showing you might not be

00:13:06,850 --> 00:13:12,460
a 100% accurate but you can still like

00:13:09,820 --> 00:13:16,570
if you can get the NPM package of deep

00:13:12,460 --> 00:13:19,510
learn version 0.4 I think then you can

00:13:16,570 --> 00:13:22,150
check out the repository then you get

00:13:19,510 --> 00:13:24,700
the right version anyways

00:13:22,150 --> 00:13:26,860
so deep lunges provides us with a way to

00:13:24,700 --> 00:13:28,510
build neural networks and it's actually

00:13:26,860 --> 00:13:30,310
kind of sort of really straightforward

00:13:28,510 --> 00:13:32,050
so I'm hoping that you know I can show

00:13:30,310 --> 00:13:35,080
you this and you can like do it for

00:13:32,050 --> 00:13:38,680
yourself even though you know it's not

00:13:35,080 --> 00:13:40,990
exactly like this anymore but so a

00:13:38,680 --> 00:13:44,110
neural network like I said before it's

00:13:40,990 --> 00:13:45,700
the network made of notes and we don't

00:13:44,110 --> 00:13:50,190
look at each single node we look at

00:13:45,700 --> 00:13:52,900
these columns of nodes and I said before

00:13:50,190 --> 00:13:54,640
each one little note and we have like

00:13:52,900 --> 00:13:56,710
different columns and they can have a

00:13:54,640 --> 00:13:58,210
different number of nodes doesn't really

00:13:56,710 --> 00:13:58,990
matter just matters that it's a single

00:13:58,210 --> 00:14:01,870
column

00:13:58,990 --> 00:14:05,020
they can't have like weird other shapes

00:14:01,870 --> 00:14:08,380
it's just has to be comes and then you

00:14:05,020 --> 00:14:10,360
have this blue input basically in the

00:14:08,380 --> 00:14:13,420
green output so the input is our

00:14:10,360 --> 00:14:15,670
features the output is our prediction in

00:14:13,420 --> 00:14:17,290
this case we only have two output notes

00:14:15,670 --> 00:14:19,420
but that's just because I've do it this

00:14:17,290 --> 00:14:21,190
way and the important thing to

00:14:19,420 --> 00:14:24,040
understand is that each node is

00:14:21,190 --> 00:14:27,160
connected to all the other nodes in the

00:14:24,040 --> 00:14:29,560
next layer and the ligands that each

00:14:27,160 --> 00:14:31,600
node connected to all the other nodes

00:14:29,560 --> 00:14:35,610
they're not connected like in the same

00:14:31,600 --> 00:14:35,610
layer always to the next one

00:14:37,200 --> 00:14:43,320
right so let's look at one single note

00:14:41,550 --> 00:14:45,930
to try to understand what's happening

00:14:43,320 --> 00:14:47,430
there so in this case the snow like the

00:14:45,930 --> 00:14:48,870
layer before has three notes the layer

00:14:47,430 --> 00:14:50,730
after it has to be notes and we're just

00:14:48,870 --> 00:14:53,490
looking at one node in this layer and

00:14:50,730 --> 00:14:55,079
we're getting our inputs from the layer

00:14:53,490 --> 00:14:57,389
before and those are like three

00:14:55,079 --> 00:14:58,769
different values and kind of like doing

00:14:57,389 --> 00:15:01,740
something with them like adding them

00:14:58,769 --> 00:15:04,470
together to create one output and we

00:15:01,740 --> 00:15:06,540
output this same value to all the other

00:15:04,470 --> 00:15:09,269
notes so we receiving three different

00:15:06,540 --> 00:15:12,420
inputs but we're outputting the same

00:15:09,269 --> 00:15:14,370
value and now you will think for

00:15:12,420 --> 00:15:16,529
yourself like okay we're just adding all

00:15:14,370 --> 00:15:19,649
the inputs then all the nodes in this

00:15:16,529 --> 00:15:21,480
layer will output the same value this is

00:15:19,649 --> 00:15:23,040
kind of how the magic of machine

00:15:21,480 --> 00:15:24,420
learning works is that each node has

00:15:23,040 --> 00:15:27,209
these weights

00:15:24,420 --> 00:15:29,550
it has like a parameters for each of

00:15:27,209 --> 00:15:31,920
those inputs to define how important

00:15:29,550 --> 00:15:34,829
this input is to understand this pattern

00:15:31,920 --> 00:15:36,690
so maybe if we have come to the

00:15:34,829 --> 00:15:39,029
complementary color prediction one of

00:15:36,690 --> 00:15:42,420
the inputs is let's say the weather

00:15:39,029 --> 00:15:44,220
today then hopefully the system will

00:15:42,420 --> 00:15:46,350
kind of learn that this is a very like

00:15:44,220 --> 00:15:48,570
doesn't really matter this input and

00:15:46,350 --> 00:15:50,910
like will give it a very very small

00:15:48,570 --> 00:15:54,149
weight so once you multiply it it

00:15:50,910 --> 00:15:56,570
becomes like almost you know it doesn't

00:15:54,149 --> 00:16:00,510
matter in your in your sum in the end

00:15:56,570 --> 00:16:02,820
that's kind of the idea so by that

00:16:00,510 --> 00:16:05,519
that's the magic basically of neural

00:16:02,820 --> 00:16:07,980
networks so the weights are property of

00:16:05,519 --> 00:16:10,709
the node so they're not property of the

00:16:07,980 --> 00:16:13,620
input they're like that the node has the

00:16:10,709 --> 00:16:15,899
weights and you have one weight for each

00:16:13,620 --> 00:16:18,660
input to define how important that input

00:16:15,899 --> 00:16:20,640
is and all the weights in one network

00:16:18,660 --> 00:16:22,529
that those basically represent your

00:16:20,640 --> 00:16:26,459
model because that's basically what your

00:16:22,529 --> 00:16:28,529
model is it tells you like of all the

00:16:26,459 --> 00:16:29,640
inputs those are the how important are

00:16:28,529 --> 00:16:32,040
the inputs and then I'm going to

00:16:29,640 --> 00:16:33,690
calculate them and then I can give you

00:16:32,040 --> 00:16:36,360
like a value in the end that kind of

00:16:33,690 --> 00:16:38,250
tells you the probability of what you

00:16:36,360 --> 00:16:40,800
want to predict what's going to happen

00:16:38,250 --> 00:16:43,829
or complimentary colors or whatever you

00:16:40,800 --> 00:16:47,130
want to predict so we need a weight

00:16:43,829 --> 00:16:50,940
those are the most important things all

00:16:47,130 --> 00:16:53,820
right in deep lunges or tens of logic

00:16:50,940 --> 00:16:58,230
the columns of a network are represented

00:16:53,820 --> 00:17:00,780
by a thing that's called tensor so a

00:16:58,230 --> 00:17:03,420
tensor is a layer it's just one column

00:17:00,780 --> 00:17:05,010
and the reason why it has to be columns

00:17:03,420 --> 00:17:06,660
as because we're doing a lot of vector

00:17:05,010 --> 00:17:08,490
and matrix multiplication and that is

00:17:06,660 --> 00:17:10,340
also why machine learning is so powerful

00:17:08,490 --> 00:17:15,660
because we can do a lot of calculations

00:17:10,340 --> 00:17:18,210
in parallel with that and can do like

00:17:15,660 --> 00:17:21,630
can go over a lot of data in pretty

00:17:18,210 --> 00:17:24,120
short amount of time so yeah that's why

00:17:21,630 --> 00:17:28,080
we need columns and rows where each

00:17:24,120 --> 00:17:31,410
column represents basically a layer and

00:17:28,080 --> 00:17:33,110
a row represents the data set I'm going

00:17:31,410 --> 00:17:35,280
to explain that later don't yeah

00:17:33,110 --> 00:17:35,850
everything's gonna come together in the

00:17:35,280 --> 00:17:38,970
end I promise

00:17:35,850 --> 00:17:41,010
all right tutors we have do two

00:17:38,970 --> 00:17:43,590
different kinds of tensors the one kind

00:17:41,010 --> 00:17:46,200
as a placeholder where okay we need a

00:17:43,590 --> 00:17:48,150
name for that which is just like to find

00:17:46,200 --> 00:17:50,430
it basically and then we need a size so

00:17:48,150 --> 00:17:52,590
we have to know how many nodes have to

00:17:50,430 --> 00:17:55,080
be in this placeholder and we need a

00:17:52,590 --> 00:17:58,410
placeholder to input static values or

00:17:55,080 --> 00:18:02,880
output like static values basically for

00:17:58,410 --> 00:18:06,450
example for our input and target tensor

00:18:02,880 --> 00:18:08,820
so this is how the code looks we as deep

00:18:06,450 --> 00:18:10,500
learn the the library to give us a graph

00:18:08,820 --> 00:18:12,300
because the graph is where we get all

00:18:10,500 --> 00:18:15,510
our fancy tensors and everything from

00:18:12,300 --> 00:18:17,610
and then we have like this placeholder

00:18:15,510 --> 00:18:20,400
that is input tensor so that's where we

00:18:17,610 --> 00:18:22,590
put in our features and the target

00:18:20,400 --> 00:18:26,010
tensor this is where we put in our

00:18:22,590 --> 00:18:28,200
desired output what we want it to and

00:18:26,010 --> 00:18:29,970
since those are fixed values we know

00:18:28,200 --> 00:18:32,940
them from the data set that we created

00:18:29,970 --> 00:18:35,670
and those are placeholders the other

00:18:32,940 --> 00:18:38,150
kind of Tenzer is called in this case I

00:18:35,670 --> 00:18:40,500
call fully connected layer basically

00:18:38,150 --> 00:18:43,500
okay we need a name again we're the size

00:18:40,500 --> 00:18:46,410
again but here we need to give the fully

00:18:43,500 --> 00:18:48,630
connected layer an input layer so it

00:18:46,410 --> 00:18:51,090
knows which layer has to connect to and

00:18:48,630 --> 00:18:53,490
it's called fully connected because like

00:18:51,090 --> 00:18:55,680
I've explained before the node is

00:18:53,490 --> 00:18:58,380
connected to all the nodes of the of the

00:18:55,680 --> 00:19:00,150
next layer you can have like different

00:18:58,380 --> 00:19:02,670
kinds of connections but I'm just gonna

00:19:00,150 --> 00:19:03,580
show you like the super basic one

00:19:02,670 --> 00:19:07,090
basically

00:19:03,580 --> 00:19:09,580
and so this code goal is might look a

00:19:07,090 --> 00:19:13,480
little bit complicated we're starting

00:19:09,580 --> 00:19:15,220
with this with our input tensor this is

00:19:13,480 --> 00:19:17,169
this is the input tensor for this

00:19:15,220 --> 00:19:19,029
function where we add like a new

00:19:17,169 --> 00:19:20,980
connected layer I'm gonna show you the

00:19:19,029 --> 00:19:23,320
code for the function in a minute just

00:19:20,980 --> 00:19:25,360
want to show you that we take this input

00:19:23,320 --> 00:19:27,249
tensor adding another layer then adding

00:19:25,360 --> 00:19:28,869
another layer they never layer and then

00:19:27,249 --> 00:19:31,419
we're adding last layer which is our

00:19:28,869 --> 00:19:33,759
prediction and these are the ending

00:19:31,419 --> 00:19:35,350
indices for our layers just saying like

00:19:33,759 --> 00:19:40,989
this is the first one the second one and

00:19:35,350 --> 00:19:43,330
so on and these are the note sizes the

00:19:40,989 --> 00:19:45,629
prediction gender of course again has to

00:19:43,330 --> 00:19:49,840
be three nodes because we want like

00:19:45,629 --> 00:19:54,159
three values RGB and this is what the

00:19:49,840 --> 00:19:55,929
code looks like so again we have to call

00:19:54,159 --> 00:19:58,809
the graph to give us this like dense

00:19:55,929 --> 00:20:01,809
layers we're giving it a name giving it

00:19:58,809 --> 00:20:04,989
the input layer so where are the inputs

00:20:01,809 --> 00:20:08,169
coming from from layer before and then

00:20:04,989 --> 00:20:10,749
layer size okay this is an activation

00:20:08,169 --> 00:20:13,840
function normally in the layer all you

00:20:10,749 --> 00:20:16,029
have to all you do is multiply each

00:20:13,840 --> 00:20:19,179
input with its weight and then adding

00:20:16,029 --> 00:20:21,999
that together this is a super simple

00:20:19,179 --> 00:20:23,559
activation so if you if you hadn't have

00:20:21,999 --> 00:20:25,929
a activation function if this was

00:20:23,559 --> 00:20:28,149
undefined you would just get the result

00:20:25,929 --> 00:20:31,840
from the calculation I just explained to

00:20:28,149 --> 00:20:34,450
you once you have an input activation

00:20:31,840 --> 00:20:38,019
function X is basically the result of

00:20:34,450 --> 00:20:40,929
you know the multiplication to sum and

00:20:38,019 --> 00:20:43,480
then we pass it here this function it's

00:20:40,929 --> 00:20:47,230
called rectifier linear unit blah blah

00:20:43,480 --> 00:20:50,019
blah all it does is if X is smaller than

00:20:47,230 --> 00:20:50,830
zero it outputs zero and if X is bigger

00:20:50,019 --> 00:20:53,980
than zero

00:20:50,830 --> 00:20:57,460
it's just outputs takes it just sounds

00:20:53,980 --> 00:21:01,149
and then this is the bias

00:20:57,460 --> 00:21:04,179
boooooo we need a bias here because in

00:21:01,149 --> 00:21:05,980
case we get a zero here

00:21:04,179 --> 00:21:07,659
the next layer would think that the node

00:21:05,980 --> 00:21:10,330
before was not activated because it's

00:21:07,659 --> 00:21:12,730
getting a zero but we want the node to

00:21:10,330 --> 00:21:15,220
be activated no matter what because

00:21:12,730 --> 00:21:17,340
otherwise it would just basically think

00:21:15,220 --> 00:21:19,600
that there was no no door it's like

00:21:17,340 --> 00:21:21,280
really unimportant but that's not what

00:21:19,600 --> 00:21:23,100
it is it's just like unfortunate we just

00:21:21,280 --> 00:21:26,049
got a zero they have to add a bias

00:21:23,100 --> 00:21:29,230
that's just adding plus one to the end

00:21:26,049 --> 00:21:32,530
of the calculation so we know that the

00:21:29,230 --> 00:21:34,870
node was activated it's really not that

00:21:32,530 --> 00:21:36,250
like it's not that important if we're

00:21:34,870 --> 00:21:38,230
just gonna build stuff and we're just

00:21:36,250 --> 00:21:40,450
gonna put bias yes because someone told

00:21:38,230 --> 00:21:43,710
me that bias is good like in machine

00:21:40,450 --> 00:21:46,419
learning not in real life all right

00:21:43,710 --> 00:21:47,860
let's go through a checklist again as I

00:21:46,419 --> 00:21:53,350
already forgotten what I was talking

00:21:47,860 --> 00:21:55,780
about so we have our data we now build a

00:21:53,350 --> 00:21:58,059
network now we have to do something

00:21:55,780 --> 00:22:00,909
awesome and then we're gonna have

00:21:58,059 --> 00:22:02,620
something awesome right so let's talk

00:22:00,909 --> 00:22:05,140
about this awesome thing we have to do

00:22:02,620 --> 00:22:07,179
what like do you have an idea what we

00:22:05,140 --> 00:22:09,730
have to do now we have our network we

00:22:07,179 --> 00:22:16,510
have our data what do we think anyone

00:22:09,730 --> 00:22:18,429
have an idea yes yes very good yes we

00:22:16,510 --> 00:22:21,179
have to train our network because it has

00:22:18,429 --> 00:22:24,100
to become better so how do we do this

00:22:21,179 --> 00:22:26,530
let's just think about it like very high

00:22:24,100 --> 00:22:29,770
level e very abstract we need to kind of

00:22:26,530 --> 00:22:33,309
find a metric that tells us how good it

00:22:29,770 --> 00:22:33,880
is how good our machine is predicting

00:22:33,309 --> 00:22:36,370
right now

00:22:33,880 --> 00:22:37,990
then we're gonna change something and

00:22:36,370 --> 00:22:40,990
then we're gonna check the metric again

00:22:37,990 --> 00:22:43,780
that's how how we kind of be better

00:22:40,990 --> 00:22:45,669
that's kind of how I learned things you

00:22:43,780 --> 00:22:48,370
know I was like I got like feedback

00:22:45,669 --> 00:22:52,150
changed something like I'm on the right

00:22:48,370 --> 00:22:58,210
track so let's talk about this metric

00:22:52,150 --> 00:23:01,450
thing so we I call it cost loss or cost

00:22:58,210 --> 00:23:05,860
or loss and I'm trying to explain this

00:23:01,450 --> 00:23:08,169
graph to you so this is the x-axis which

00:23:05,860 --> 00:23:10,150
is our input there's just a measure

00:23:08,169 --> 00:23:12,700
which only have one input value right

00:23:10,150 --> 00:23:15,490
now and this is the output value that we

00:23:12,700 --> 00:23:18,250
have so I'm showing you this it

00:23:15,490 --> 00:23:20,770
basically means this is a model or like

00:23:18,250 --> 00:23:22,870
a system a pattern where when we input a

00:23:20,770 --> 00:23:25,270
hundred we're gonna get an output of

00:23:22,870 --> 00:23:27,670
like let's say a hundred

00:23:25,270 --> 00:23:29,980
not seeing that really well we input

00:23:27,670 --> 00:23:33,310
like 40 we're gonna get like I don't

00:23:29,980 --> 00:23:35,560
know 40 something and then if we input

00:23:33,310 --> 00:23:40,960
like 200 we're gonna get like a hundred

00:23:35,560 --> 00:23:43,560
and twenty maybe so this is our reality

00:23:40,960 --> 00:23:46,630
that we're trying to approximate and

00:23:43,560 --> 00:23:49,900
this is our prediction this is what our

00:23:46,630 --> 00:23:52,120
network is predicting right now so what

00:23:49,900 --> 00:23:54,760
that means is that the distance between

00:23:52,120 --> 00:23:58,330
the actual target value and what we

00:23:54,760 --> 00:24:01,330
predicted for this X that distance is

00:23:58,330 --> 00:24:03,610
our costs for our loss that's like how

00:24:01,330 --> 00:24:06,580
far we are away from the actual correct

00:24:03,610 --> 00:24:10,990
prediction or correct result or Target

00:24:06,580 --> 00:24:13,180
and so because we're not like doing all

00:24:10,990 --> 00:24:16,510
the calculations sequentially but like

00:24:13,180 --> 00:24:18,940
parallel the cost function is all the

00:24:16,510 --> 00:24:23,220
distances all the distances for all the

00:24:18,940 --> 00:24:28,000
XS that we have that's our cost for this

00:24:23,220 --> 00:24:29,980
model all right so if we want to

00:24:28,000 --> 00:24:31,990
implement it and deep learn GS

00:24:29,980 --> 00:24:35,080
all we have to do is find like choose an

00:24:31,990 --> 00:24:37,270
algorithm in this case I'm gonna choose

00:24:35,080 --> 00:24:38,500
mean squared error and you don't have to

00:24:37,270 --> 00:24:39,940
understand what it does if you're

00:24:38,500 --> 00:24:42,280
interested do the machine learning

00:24:39,940 --> 00:24:43,990
course because it gets kind of masked

00:24:42,280 --> 00:24:46,870
see you know don't really have the time

00:24:43,990 --> 00:24:48,820
to explain it right now so we need an

00:24:46,870 --> 00:24:52,180
algorithm and then we need the target

00:24:48,820 --> 00:24:54,040
Tenzer and the prediction tensor makes

00:24:52,180 --> 00:24:55,540
sense because we have to like calculate

00:24:54,040 --> 00:24:58,630
the difference like the distance between

00:24:55,540 --> 00:24:59,860
those two so calculate distance between

00:24:58,630 --> 00:25:02,440
what we want to have and what we

00:24:59,860 --> 00:25:05,290
actually have and then feed it in like

00:25:02,440 --> 00:25:06,760
some kind of function I am a mean

00:25:05,290 --> 00:25:09,940
squared error what it does is basically

00:25:06,760 --> 00:25:12,670
it squares the error so big error will

00:25:09,940 --> 00:25:15,010
always be like even more ridiculously

00:25:12,670 --> 00:25:19,150
big will make the loss even greater than

00:25:15,010 --> 00:25:21,250
like a smaller one squared so then the

00:25:19,150 --> 00:25:23,470
implementation or the code is actually

00:25:21,250 --> 00:25:25,480
super simple and deep learn we're just

00:25:23,470 --> 00:25:27,970
calling the graph and say oh give me

00:25:25,480 --> 00:25:29,680
mean squared cost that's the function

00:25:27,970 --> 00:25:31,540
I'm calling and then we passing in the

00:25:29,680 --> 00:25:35,200
target tensor and the prediction ten-ton

00:25:31,540 --> 00:25:37,000
pretty simple right and the next thing

00:25:35,200 --> 00:25:38,550
we need to talk about is the thing that

00:25:37,000 --> 00:25:40,110
actually changes

00:25:38,550 --> 00:25:41,970
values that actually so we have this

00:25:40,110 --> 00:25:43,730
metric right and then the next thing was

00:25:41,970 --> 00:25:46,590
the we need to change something to

00:25:43,730 --> 00:25:48,930
change something on our network we need

00:25:46,590 --> 00:25:52,830
this thing that dbrand calls an

00:25:48,930 --> 00:25:55,890
optimizer so in this graph the x-axis is

00:25:52,830 --> 00:25:58,290
the weight and the y-axis is the loss so

00:25:55,890 --> 00:26:00,540
in if I show you this it kind of it

00:25:58,290 --> 00:26:05,340
means that when the weight for our one

00:26:00,540 --> 00:26:09,150
input is like 60 the loss is about like

00:26:05,340 --> 00:26:13,230
30 if we have a weight of like 200 the

00:26:09,150 --> 00:26:15,210
loss of the ball like 80 something and

00:26:13,230 --> 00:26:17,160
it seems like if like a weight is around

00:26:15,210 --> 00:26:19,620
a hundred and this is the like the

00:26:17,160 --> 00:26:22,800
smallest loss we can have so this might

00:26:19,620 --> 00:26:27,510
be the point where a weight should be

00:26:22,800 --> 00:26:31,080
because like one small loss right right

00:26:27,510 --> 00:26:33,030
so when we start up a network the weight

00:26:31,080 --> 00:26:35,030
are always initialized randomly or they

00:26:33,030 --> 00:26:38,310
always should be initialized randomly

00:26:35,030 --> 00:26:40,950
when we start out anywhere and then what

00:26:38,310 --> 00:26:44,580
the optimizer does is use the magic of

00:26:40,950 --> 00:26:49,800
math to kind of take steps and try to

00:26:44,580 --> 00:26:54,480
get to the approximate the the point

00:26:49,800 --> 00:26:56,760
where the loss is less basically it's

00:26:54,480 --> 00:26:58,890
like a little more complicated than that

00:26:56,760 --> 00:27:01,200
but the way that we can imagine is that

00:26:58,890 --> 00:27:07,770
we're just taking steps towards

00:27:01,200 --> 00:27:09,930
hopefully the minimum and the the closer

00:27:07,770 --> 00:27:13,320
we get to the minimum the smaller the

00:27:09,930 --> 00:27:16,080
steps become as well so this is kind of

00:27:13,320 --> 00:27:19,950
what we're doing when we're machine

00:27:16,080 --> 00:27:23,270
learning with DJs so for the optimizer

00:27:19,950 --> 00:27:26,340
to implement that we need an algorithm

00:27:23,270 --> 00:27:28,620
again I'm just picking the algorithm

00:27:26,340 --> 00:27:30,600
that's called gradient descent which is

00:27:28,620 --> 00:27:32,550
which is doing what I just showed you

00:27:30,600 --> 00:27:34,890
there are other optimized algorithms but

00:27:32,550 --> 00:27:37,830
again I will like suggest to you that

00:27:34,890 --> 00:27:39,840
you just look into it yourself and then

00:27:37,830 --> 00:27:41,820
we need a learning rate the learning

00:27:39,840 --> 00:27:44,550
rate is just the parameter it's a number

00:27:41,820 --> 00:27:46,470
that determines how big these steps are

00:27:44,550 --> 00:27:48,420
so this is a small learning rate and

00:27:46,470 --> 00:27:50,190
this is a big learning rate in this

00:27:48,420 --> 00:27:52,060
example it kind of looks like the bigger

00:27:50,190 --> 00:27:55,000
learning rate is a problem because we

00:27:52,060 --> 00:27:57,250
move away from the minimum could be a

00:27:55,000 --> 00:28:00,130
problem it's just something that you

00:27:57,250 --> 00:28:02,200
kind of have to try out for yourself to

00:28:00,130 --> 00:28:04,690
see which learning rate is best suited

00:28:02,200 --> 00:28:08,140
for your problem

00:28:04,690 --> 00:28:10,210
and again the implementation is or was

00:28:08,140 --> 00:28:12,520
actually super simple we just had to

00:28:10,210 --> 00:28:14,530
call deep learn and just say give me the

00:28:12,520 --> 00:28:16,000
I don't know what the essence for but

00:28:14,530 --> 00:28:20,010
give me the gradient descent optimizer

00:28:16,000 --> 00:28:23,350
and then just pass in a learning rate

00:28:20,010 --> 00:28:25,300
that is basically it so we already have

00:28:23,350 --> 00:28:26,860
our data or network and now we set up

00:28:25,300 --> 00:28:30,850
the training and all we need to do is

00:28:26,860 --> 00:28:32,710
run now all of you I kind of look at me

00:28:30,850 --> 00:28:34,720
like well so how does it work

00:28:32,710 --> 00:28:35,740
actually I just yeah I understood what

00:28:34,720 --> 00:28:38,050
you said but I still don't understand

00:28:35,740 --> 00:28:40,390
how it works so I'm gonna try to show

00:28:38,050 --> 00:28:43,600
you how it actually works in a super

00:28:40,390 --> 00:28:47,910
nice diagram so we start out with this

00:28:43,600 --> 00:28:52,570
this is our network and we have our data

00:28:47,910 --> 00:28:54,280
all right we're feeding in our data into

00:28:52,570 --> 00:28:57,220
our network so this is we're feeding it

00:28:54,280 --> 00:28:59,650
into the input and then you know a

00:28:57,220 --> 00:29:02,050
compute staff blah blah blah and then it

00:28:59,650 --> 00:29:04,300
outputs three that's our prediction then

00:29:02,050 --> 00:29:07,660
we look into our data again and be fine

00:29:04,300 --> 00:29:09,700
out the target was actually two so what

00:29:07,660 --> 00:29:11,700
we had I have to do is calculate the

00:29:09,700 --> 00:29:14,290
distance in this case I'm just using

00:29:11,700 --> 00:29:15,700
subtraction I mean it's not what I used

00:29:14,290 --> 00:29:17,560
before like I said it was another

00:29:15,700 --> 00:29:20,680
algorithm was in this case to make it

00:29:17,560 --> 00:29:22,990
simple the cost is just one it's just a

00:29:20,680 --> 00:29:26,050
difference then we're feeding this one

00:29:22,990 --> 00:29:30,060
into our optimizer what's the optimizer

00:29:26,050 --> 00:29:33,850
does is take the one and then magically

00:29:30,060 --> 00:29:36,010
goes back through the and network and

00:29:33,850 --> 00:29:38,830
changes all the weights so when we go

00:29:36,010 --> 00:29:40,990
from the input to the back it's called

00:29:38,830 --> 00:29:43,270
forward propagation because we propagate

00:29:40,990 --> 00:29:45,580
all the data forward and then what the

00:29:43,270 --> 00:29:48,070
optimizer does is called backwards

00:29:45,580 --> 00:29:51,250
propagation because it propagates values

00:29:48,070 --> 00:29:53,380
backwards the difference is when we do

00:29:51,250 --> 00:29:55,780
forward propagation we take like actual

00:29:53,380 --> 00:29:57,310
inputs like the feature inputs

00:29:55,780 --> 00:29:59,740
pass it through to make a prediction

00:29:57,310 --> 00:30:02,320
when we do backwards propagation we're

00:29:59,740 --> 00:30:04,630
not actually caring about input values

00:30:02,320 --> 00:30:06,850
using the cost to try to change the

00:30:04,630 --> 00:30:08,260
weights so we're not actually doing

00:30:06,850 --> 00:30:09,940
anything with the prediction we just

00:30:08,260 --> 00:30:12,850
like we just need the prediction to know

00:30:09,940 --> 00:30:14,770
how good are our network is performing

00:30:12,850 --> 00:30:16,420
and then taking that information and

00:30:14,770 --> 00:30:18,400
trying to change the weight in a way

00:30:16,420 --> 00:30:23,050
that it's going to perform better next

00:30:18,400 --> 00:30:25,420
round so this is basically the entire

00:30:23,050 --> 00:30:27,340
magic which I hope is not that

00:30:25,420 --> 00:30:31,630
complicated anymore I hope it makes

00:30:27,340 --> 00:30:34,360
sense to you now there's like like I'm

00:30:31,630 --> 00:30:36,850
going to show some code on how to

00:30:34,360 --> 00:30:39,520
generate the training data but it's the

00:30:36,850 --> 00:30:42,460
important thing here so I'm like

00:30:39,520 --> 00:30:45,100
generating a bunch of training data here

00:30:42,460 --> 00:30:48,430
is that the input data and the target

00:30:45,100 --> 00:30:52,840
data data are in two separate arrays and

00:30:48,430 --> 00:30:56,740
the way that they're reference is just

00:30:52,840 --> 00:30:59,440
by the index and they're like two

00:30:56,740 --> 00:31:01,210
separate areas at the point and also we

00:30:59,440 --> 00:31:02,770
don't push just like normal arrays

00:31:01,210 --> 00:31:05,440
inside there we have to pull it like

00:31:02,770 --> 00:31:07,390
these deep learn areas but like I said I

00:31:05,440 --> 00:31:09,490
don't know I actually haven't looked

00:31:07,390 --> 00:31:11,710
into how it works in tenza flow right

00:31:09,490 --> 00:31:13,690
not like what you would have to call but

00:31:11,710 --> 00:31:18,090
they actually have good examples for

00:31:13,690 --> 00:31:20,650
that you can just check it out anyway so

00:31:18,090 --> 00:31:22,600
it's not that important what's happening

00:31:20,650 --> 00:31:25,720
here it's kind of just that we have to

00:31:22,600 --> 00:31:28,030
put the training data that we generated

00:31:25,720 --> 00:31:29,950
have to put it in this like shuffled

00:31:28,030 --> 00:31:31,960
input provider so it would shuffle the

00:31:29,950 --> 00:31:34,210
data for us but the reference is still

00:31:31,960 --> 00:31:36,880
intact from the input to the target

00:31:34,210 --> 00:31:40,930
that's basically all like this slide

00:31:36,880 --> 00:31:42,910
shows all right so when we train it when

00:31:40,930 --> 00:31:45,190
we run everything now that we have

00:31:42,910 --> 00:31:47,140
everything it actually it doesn't look

00:31:45,190 --> 00:31:50,890
that complicated anymore we have to

00:31:47,140 --> 00:31:53,980
start a session and we passed this math

00:31:50,890 --> 00:31:56,350
environment and math basically tells you

00:31:53,980 --> 00:31:58,990
if you are in the browser you can

00:31:56,350 --> 00:32:01,630
utilize the GPU if you're not in the

00:31:58,990 --> 00:32:03,430
browser you have to use the CPU and you

00:32:01,630 --> 00:32:06,030
know it's nice to have things need to be

00:32:03,430 --> 00:32:10,300
you because the leg runs much faster and

00:32:06,030 --> 00:32:14,260
then then you work with the CPU and then

00:32:10,300 --> 00:32:15,790
on this math environment you call I'm

00:32:14,260 --> 00:32:19,210
going to train this

00:32:15,790 --> 00:32:21,850
okay on the session call train pass it

00:32:19,210 --> 00:32:23,580
okay you need the cost tensor and you

00:32:21,850 --> 00:32:25,870
need the feed entries which is the data

00:32:23,580 --> 00:32:28,390
the batch size basically just

00:32:25,870 --> 00:32:31,840
determining how many data points are we

00:32:28,390 --> 00:32:34,030
going to iterate through right now the

00:32:31,840 --> 00:32:37,210
optimizer you know it like it takes the

00:32:34,030 --> 00:32:39,700
cost tensor and the network and then try

00:32:37,210 --> 00:32:41,980
to like change things change the weights

00:32:39,700 --> 00:32:45,940
and those last parameter is just we just

00:32:41,980 --> 00:32:48,580
needed to output the cost the loss that

00:32:45,940 --> 00:32:51,340
we have after each bedroom so this is

00:32:48,580 --> 00:32:52,630
the code and the nice thing about you

00:32:51,340 --> 00:32:54,250
know running in the browser is that you

00:32:52,630 --> 00:32:58,020
can utilize all the nice browser things

00:32:54,250 --> 00:33:00,940
like service workers and everything so I

00:32:58,020 --> 00:33:02,440
spun up a little demo and I'm gonna just

00:33:00,940 --> 00:33:05,590
show you the video right now cuz it

00:33:02,440 --> 00:33:08,950
takes forever for to run actually so

00:33:05,590 --> 00:33:11,020
like I said what we wanted to achieve

00:33:08,950 --> 00:33:14,200
was to do a complementary color

00:33:11,020 --> 00:33:16,360
prediction and in this case the input

00:33:14,200 --> 00:33:18,820
color will always be this like slight

00:33:16,360 --> 00:33:21,460
like light purple and this is our target

00:33:18,820 --> 00:33:22,990
color this is the color that we want the

00:33:21,460 --> 00:33:24,370
machine to predict this is the color

00:33:22,990 --> 00:33:26,740
that the machine is predicting right now

00:33:24,370 --> 00:33:29,380
this is completely randomly set up so it

00:33:26,740 --> 00:33:31,240
could be any color it says cost zero

00:33:29,380 --> 00:33:32,920
here but that's obviously wrong because

00:33:31,240 --> 00:33:35,560
cos zero would mean that we have the

00:33:32,920 --> 00:33:39,730
perfect prediction it should say cost

00:33:35,560 --> 00:33:40,690
one but yeah I didn't fix it and I

00:33:39,730 --> 00:33:42,400
thought it would be easier to just

00:33:40,690 --> 00:33:45,790
explain to you that it's not correct

00:33:42,400 --> 00:33:49,630
then should actually fix it so let's

00:33:45,790 --> 00:33:51,880
take a look at this video so you can see

00:33:49,630 --> 00:33:53,650
that it's like slowly like changing the

00:33:51,880 --> 00:33:56,640
values and getting like better and you

00:33:53,650 --> 00:33:58,390
can also see that the cost is getting

00:33:56,640 --> 00:34:00,730
smaller and smaller

00:33:58,390 --> 00:34:02,830
and then at some points I'm running like

00:34:00,730 --> 00:34:05,950
a thousand patch this year I think so

00:34:02,830 --> 00:34:07,990
I'm running a 25 batch size and doing it

00:34:05,950 --> 00:34:10,870
I'll run a thousand batches and here at

00:34:07,990 --> 00:34:12,460
the end I don't know how you feel about

00:34:10,870 --> 00:34:14,830
it but I think it's like almost

00:34:12,460 --> 00:34:17,409
indistinguishable the difference and if

00:34:14,830 --> 00:34:19,570
you like if we look at the beginning it

00:34:17,409 --> 00:34:22,720
starts all like with this and it like

00:34:19,570 --> 00:34:25,770
really gradually very slowly kind of

00:34:22,720 --> 00:34:27,550
like approximates the actual value and

00:34:25,770 --> 00:34:29,139
but

00:34:27,550 --> 00:34:31,119
every time you set it up it starts

00:34:29,139 --> 00:34:33,099
completely randomly so I had to make a

00:34:31,119 --> 00:34:36,700
video of like a nice run that actually

00:34:33,099 --> 00:34:38,320
shows what I want to show but you know

00:34:36,700 --> 00:34:40,119
you can like I said you can check out

00:34:38,320 --> 00:34:43,359
the repository and just try it for

00:34:40,119 --> 00:34:45,730
yourself this was one example from

00:34:43,359 --> 00:34:48,040
Google but they've scrapped it with all

00:34:45,730 --> 00:34:51,310
the with all the documentation and

00:34:48,040 --> 00:34:53,560
everything so you kind of have to check

00:34:51,310 --> 00:34:56,770
out my specific repository for still to

00:34:53,560 --> 00:34:58,839
run all right some links for you to

00:34:56,770 --> 00:35:01,869
check out so first of all that's the

00:34:58,839 --> 00:35:05,400
repository I was talking about then

00:35:01,869 --> 00:35:07,780
there's a deep learning j/s which is

00:35:05,400 --> 00:35:10,330
apparently not deep Londres anymore but

00:35:07,780 --> 00:35:15,130
it will take you to tens of florges

00:35:10,330 --> 00:35:18,130
this is like a really nice explanation

00:35:15,130 --> 00:35:20,380
no this is the demo which I don't

00:35:18,130 --> 00:35:22,990
actually know if it's still up or not

00:35:20,380 --> 00:35:24,880
so you have to see for yourself okay

00:35:22,990 --> 00:35:27,190
this is a very nice explanation of from

00:35:24,880 --> 00:35:29,470
deep learning fundamentals that I didn't

00:35:27,190 --> 00:35:31,450
cover like what kind of activation

00:35:29,470 --> 00:35:34,030
function should I use if you're

00:35:31,450 --> 00:35:36,930
interested in that and oh it's the

00:35:34,030 --> 00:35:39,700
phones I didn't put in the course so

00:35:36,930 --> 00:35:42,570
Coursera is the platform and it's just

00:35:39,700 --> 00:35:45,820
called Stanford machine learning course

00:35:42,570 --> 00:35:48,040
alright and I have to show the slide we

00:35:45,820 --> 00:35:49,420
are hiring we have offices in those

00:35:48,040 --> 00:35:51,550
beautiful cities so if you are

00:35:49,420 --> 00:35:53,560
interested and you know doing cloud

00:35:51,550 --> 00:35:56,230
computing which has nothing to do what I

00:35:53,560 --> 00:35:59,080
was just talking about you can talk to

00:35:56,230 --> 00:36:04,420
me or just go to the website thank you

00:35:59,080 --> 00:36:12,709
and then now that's

00:36:04,420 --> 00:36:12,709

YouTube URL: https://www.youtube.com/watch?v=4fzgDaILoTc


