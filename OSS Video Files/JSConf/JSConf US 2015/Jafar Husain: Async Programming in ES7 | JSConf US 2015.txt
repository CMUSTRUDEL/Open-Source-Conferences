Title: Jafar Husain: Async Programming in ES7 | JSConf US 2015
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	Currently there are ES7 features proposed for async programming that have never been seen in a programming language before. If accepted, these proposals could allow entire JS applications to be written without a single callback! By providing the same level of support for async functions as regular functions, ES7 could dramatically alter the way everyday developers write code. Imagine reading data from a stream or a web socket with a simple loop. Imagine catching async errors using try/catch, and never again finding yourself in the callback pyramid of doom.

Transcript: https://gist.github.com/voodootikigod/74935e99334367e2c09c
Captions: 
	00:00:14,889 --> 00:00:16,670
All right, everybody!

00:00:16,670 --> 00:00:18,890
Welcome to my talk.

00:00:18,890 --> 00:00:21,320
ES2016, the evolution of JavaScript.

00:00:21,320 --> 00:00:22,320
First a little bit about me.

00:00:22,320 --> 00:00:23,320
My name is Jafar Husain.

00:00:23,320 --> 00:00:27,110
I'm a tech lead at Netflix, I work for Falcor, an upcoming

00:00:27,110 --> 00:00:36,530
open data platform, which we intend to release pretty soon, and I'm

00:00:36,530 --> 00:00:40,949
also one of Netflix's representatives on TC-39, which is JavaScript's

00:00:40,949 --> 00:00:42,160
standard's committee.

00:00:42,160 --> 00:00:46,820
This talk used to be called ES7, the evolution

00:00:46,820 --> 00:00:49,570
of JavaScript, but something happened a couple of committee meetings ago.

00:00:49,570 --> 00:00:59,710
We decided to change ES6 to ES2015 and ES7 to ES2016.

00:00:59,710 --> 00:01:02,600
I want to explain this name change.

00:01:02,600 --> 00:01:05,110
We as a committee want to start shipping JavaScript

00:01:05,110 --> 00:01:08,720
every year.

00:01:08,720 --> 00:01:11,030
Just the way you would ship software in an agile way, we want

00:01:11,030 --> 00:01:13,720
to add features and ship them quickly.

00:01:13,720 --> 00:01:17,450
That's why we have this new name.

00:01:17,450 --> 00:01:22,290
The language formerly known as ES6 is ES2015 and the upcoming language version

00:01:22,290 --> 00:01:24,250
is ES2016.

00:01:24,250 --> 00:01:28,610
ES2016 features are already starting to roll on the browsers.

00:01:28,610 --> 00:01:32,430
For example, there's object.observe in Chrome right now.

00:01:32,430 --> 00:01:39,049
And it's important to know that ES2015 and ES2016 were developed concurrently.

00:01:39,049 --> 00:01:44,570
So although there was this big -- many, many years between ES5 and ES2015,

00:01:44,570 --> 00:01:46,869
what the committee is doing is they're developing new features.

00:01:46,869 --> 00:01:49,969
In the latest version of the language, at the same time that they're developing features

00:01:49,969 --> 00:01:51,550
in the next version of the language.

00:01:51,550 --> 00:01:54,860
And that's exciting, because it actually helps us plan the future of

00:01:54,860 --> 00:01:55,860
JavaScript.

00:01:55,860 --> 00:01:57,200
We don't have to do everything in one release.

00:01:57,200 --> 00:02:00,640
We can add features today to ES2015 and we can build

00:02:00,640 --> 00:02:04,950
on them, with the hopes of building on them later in ES2016.

00:02:04,950 --> 00:02:11,170
So the big story about ES2016 is: how do we make

00:02:11,170 --> 00:02:12,580
async programming easier?

00:02:12,580 --> 00:02:14,590
I think there's probably some folks out there who

00:02:14,590 --> 00:02:16,720
think this is kind of a hard problem.

00:02:16,720 --> 00:02:17,720
Right?

00:02:17,720 --> 00:02:19,040
Any pain out there, about async programming?

00:02:19,040 --> 00:02:22,370
Quite a few people, I'm guessing.

00:02:22,370 --> 00:02:26,400
So starting with ES5, we introduced something to make your life a little

00:02:26,400 --> 00:02:27,780
bit easier, which is arrow functions.

00:02:27,780 --> 00:02:32,430
I'm not going to dwell on this too long, but as of ES2015,

00:02:32,430 --> 00:02:35,780
you're now able to write this way.

00:02:35,780 --> 00:02:38,920
A lot of people are familiar with arrow functions.

00:02:38,920 --> 00:02:42,390
I'm not going to spend too long on this.

00:02:42,390 --> 00:02:45,610
This definitely helps when you have a lot of callback.

00:02:45,610 --> 00:02:50,730
Arrow functions are an improvement, but can we do better?

00:02:50,730 --> 00:02:55,630
What if you can write async programs without any callbacks at

00:02:55,630 --> 00:02:56,630
all?

00:02:56,630 --> 00:03:00,140
How does that sound?

00:03:00,140 --> 00:03:01,290
Right?

00:03:01,290 --> 00:03:02,450
Yeah?

00:03:02,450 --> 00:03:04,650
So we all know that blocking is easy.

00:03:04,650 --> 00:03:05,650
Right?

00:03:05,650 --> 00:03:06,870
Blocking is no problem.

00:03:06,870 --> 00:03:09,620
Blocking -- let's imagine for a moment this function which gets a stock

00:03:09,620 --> 00:03:14,461
price, calls, gets stock symbol, which makes a blocking XHR request, one

00:03:14,461 --> 00:03:16,360
of those things we're never supposed to do.

00:03:16,360 --> 00:03:18,170
Never make a blocking request.

00:03:18,170 --> 00:03:23,750
But it's easy, because we can wait for the request to come back, block when it

00:03:23,750 --> 00:03:27,540
does, and pass the symbol for that stock and get the price for it.

00:03:27,540 --> 00:03:29,500
We know blocking is easy but it produces a terrible

00:03:29,500 --> 00:03:30,720
User Experience.

00:03:30,720 --> 00:03:34,010
Because user might be sitting there and our UI is not responding

00:03:34,010 --> 00:03:36,950
to mouse clicks while we're making our request.

00:03:36,950 --> 00:03:38,900
So that's something you're not supposed to do in JavaScript.

00:03:38,900 --> 00:03:44,950
But when I say blocking, I want you to think pulling.

00:03:44,950 --> 00:03:47,830
When we call a function and receive the output in the return

00:03:47,830 --> 00:03:52,750
position of that functioning, we're pulling the value of that function.

00:03:52,750 --> 00:03:55,830
To the left hand side, pulling the value out.

00:03:55,830 --> 00:03:59,409
So when I say blocking, I mean pulling, and that means data is delivered

00:03:59,409 --> 00:04:01,299
in the return position of the function.

00:04:01,299 --> 00:04:03,260
That's how most functions are in JavaScript.

00:04:03,260 --> 00:04:05,760
Most functions return their data in the return position.

00:04:05,760 --> 00:04:09,879
But what if we decide that we want to wait instead of block?

00:04:09,879 --> 00:04:12,689
We don't want to block the UI, waiting for the output and not

00:04:12,689 --> 00:04:14,700
being able to respond to user input.

00:04:14,700 --> 00:04:16,180
We want to be able to just wait.

00:04:16,180 --> 00:04:20,510
Well, in order to wait in JavaScript, waiting means pushing.

00:04:20,510 --> 00:04:25,320
What it means is you hand the callback to that function and that function pushes the

00:04:25,320 --> 00:04:29,070
value, the result of that function, in the argument position of your

00:04:29,070 --> 00:04:30,070
callback.

00:04:30,070 --> 00:04:32,210
So this is a thing you would see in node.

00:04:32,210 --> 00:04:38,230
You hand the function to callback and it pushes the value, the result, in the argument position.

00:04:38,230 --> 00:04:41,600
So as soon as we try to do that, as soon as we try to wait in JavaScript,

00:04:41,600 --> 00:04:44,250
we very rapidly find ourselves in the pyramid of doom.

00:04:44,250 --> 00:04:46,610
If you've done a lot of node.js programming, you

00:04:46,610 --> 00:04:47,790
probably know what I mean.

00:04:47,790 --> 00:04:50,419
Your code takes on this pyramid-like structure that

00:04:50,419 --> 00:04:53,849
you see there on the left hand side.

00:04:53,849 --> 00:04:57,900
So on the left hand side here, with get stock price, we're doing a

00:04:57,900 --> 00:04:58,900
blocking function.

00:04:58,900 --> 00:05:00,900
Just the same function you saw earlier.

00:05:00,900 --> 00:05:03,010
But as soon as you want to move to waiting on the right hand

00:05:03,010 --> 00:05:07,219
side, take a look at how much more complicated our function becomes.

00:05:07,219 --> 00:05:09,099
Why is there so much more code here?

00:05:09,099 --> 00:05:12,070
For one thing, it's because we're doing the job that JavaScript usually

00:05:12,070 --> 00:05:13,340
does for us.

00:05:13,340 --> 00:05:17,060
If an error is encountered anywhere in this function, now as

00:05:17,060 --> 00:05:20,690
soon as we're using callbacks to forward on those errors, we're responsible.

00:05:20,690 --> 00:05:23,140
For making sure that those errors get forwarded up.

00:05:23,140 --> 00:05:26,349
Whereas when we're doing blocking code, we have try/catch to

00:05:26,349 --> 00:05:27,349
rely on.

00:05:27,349 --> 00:05:30,089
So as soon as -- the problem really, what's going on here, is since

00:05:30,089 --> 00:05:34,570
JavaScript doesn't expect functions to wait, in JavaScript, they sort

00:05:34,570 --> 00:05:38,010
of expect functions to block -- there's no support for reporting errors

00:05:38,010 --> 00:05:41,219
this way, and the language can't provide you with any sort of support, whether

00:05:41,219 --> 00:05:45,280
it's loops or try/catch, so you're kind of on your own.

00:05:45,280 --> 00:05:48,090
But what if waiting were just as easy as blocking?

00:05:48,090 --> 00:05:50,680
What if JavaScript understood this concept of functions that

00:05:50,680 --> 00:05:54,930
waited, and it could provide you syntactical support just like try/catch, and

00:05:54,930 --> 00:05:57,880
you could use loops, for example, to repeat asynchronous functions?

00:05:57,880 --> 00:06:02,910
Well, in ES2015, we got a little closer to this vision, with promises.

00:06:02,910 --> 00:06:06,870
Now, the way I think most of you are probably familiar with promises -- most of

00:06:06,870 --> 00:06:08,130
you have been exposed to them at this point.

00:06:08,130 --> 00:06:10,310
But the way to think about a promise is that it's an

00:06:10,310 --> 00:06:14,310
object that represents the eventual value of an asynchronous operation.

00:06:14,310 --> 00:06:17,410
So if you want to get the value from a promise,

00:06:17,410 --> 00:06:20,740
you call then and pass to callbacks.

00:06:20,740 --> 00:06:23,400
One is for receiving data if the asynchronous operation

00:06:23,400 --> 00:06:24,570
succeeded.

00:06:24,570 --> 00:06:26,240
That's on the left hand side there.

00:06:26,240 --> 00:06:29,940
And the other callback is for receiving the error if the asynchronous operation

00:06:29,940 --> 00:06:30,940
failed.

00:06:30,940 --> 00:06:32,872
So it's sort of like a promise is like a present that you

00:06:32,872 --> 00:06:36,280
unwrap, and great -- if everything worked out, you get a value.

00:06:36,280 --> 00:06:39,060
But if things go bad, you can get an error.

00:06:39,060 --> 00:06:41,100
So now let's take a look at that same previous

00:06:41,100 --> 00:06:44,460
example, waiting with callbacks, and that pyramid of doom structure

00:06:44,460 --> 00:06:49,690
you see there, and let's see how we can now do the same thing with promises.

00:06:49,690 --> 00:06:54,560
So what's happened here is promises actually take care -- they catch any

00:06:54,560 --> 00:06:59,320
errors that occur, and forward them up until they're actually caught,

00:06:59,320 --> 00:07:02,330
where you pass an error handler, notice on get stock price, we pass an

00:07:02,330 --> 00:07:03,330
error handler.

00:07:03,330 --> 00:07:05,599
We don't have to catch errors at every possible step in the

00:07:05,599 --> 00:07:06,599
function.

00:07:06,599 --> 00:07:09,880
We just catch errors in one place and the promise type will catch

00:07:09,880 --> 00:07:13,500
errors and forward it up until -- there's a function provided to handle

00:07:13,500 --> 00:07:14,500
that error.

00:07:14,500 --> 00:07:17,440
So what's actually happening is that type is doing the job that

00:07:17,440 --> 00:07:19,500
try/catch does for you in the language.

00:07:19,500 --> 00:07:22,660
So that's how we got back down to that nice little piece of code.

00:07:22,660 --> 00:07:24,280
That's an improvement.

00:07:24,280 --> 00:07:25,729
No more pyramid of doom.

00:07:25,729 --> 00:07:27,240
It's not bad.

00:07:27,240 --> 00:07:32,039
But why can't we just write code that looks pretty much the same, regardless of whether

00:07:32,039 --> 00:07:34,080
it's waiting or blocking, right?

00:07:34,080 --> 00:07:37,740
What if we could just write our algorithm and make it easy to switch that

00:07:37,740 --> 00:07:39,440
algorithm between waiting and blocking?

00:07:39,440 --> 00:07:43,450
That promise code you saw on the previous slide looks different from the synchronous

00:07:43,450 --> 00:07:45,760
blocking code you saw earlier.

00:07:45,760 --> 00:07:52,000
As of ES2015, you will now be able to wait like this.

00:07:52,000 --> 00:07:55,680
So using generator functions and the yield keyword, which is something

00:07:55,680 --> 00:07:58,860
I'm going to tell but later, you can actually write code that looks

00:07:58,860 --> 00:08:02,620
pretty much exactly like the blocking code, but instead waits.

00:08:02,620 --> 00:08:03,839
It doesn't block.

00:08:03,839 --> 00:08:07,510
And so you can allow handling of user input, but you can write

00:08:07,510 --> 00:08:09,240
your code top to bottom.

00:08:09,240 --> 00:08:16,280
More, you can take advantage of looping constructs to block flow in an asynchronous

00:08:16,280 --> 00:08:17,280
way.

00:08:17,280 --> 00:08:23,279
So on the right hand side I can use loops and I can even use try/catch.

00:08:23,279 --> 00:08:25,910
How do we make this work in JavaScript?

00:08:25,910 --> 00:08:29,130
In order to explain that to you, I have to explain generators.

00:08:29,130 --> 00:08:33,690
But the metapoint I want you to understand here is that pulling and pushing

00:08:33,690 --> 00:08:36,710
are symmetrical.

00:08:36,710 --> 00:08:38,690
You can do the exact same thing -- write your code

00:08:38,690 --> 00:08:41,729
precisely the same way, whether it's pulling or pushing.

00:08:41,729 --> 00:08:42,729
It's kind of a detail.

00:08:42,729 --> 00:08:45,890
Somehow be able to write your logic and after the fact decide

00:08:45,890 --> 00:08:49,260
whether you want that function to push or you want it to be a pulling

00:08:49,260 --> 00:08:50,260
function.

00:08:50,260 --> 00:08:52,620
Anything that you can push, you can pull out of a function.

00:08:52,620 --> 00:08:54,440
I'm going to demonstrate that in just a moment.

00:08:54,440 --> 00:08:57,280
So in order to understand how that works, I'm going to explain you to the

00:08:57,280 --> 00:09:02,270
most powerful and most misunderstood feature in ES2015, and that is

00:09:02,270 --> 00:09:03,270
generator functions.

00:09:03,270 --> 00:09:04,270
Hands up -- quick, how many people have heard of

00:09:04,270 --> 00:09:05,270
generator functions?

00:09:05,270 --> 00:09:06,270
Great.

00:09:06,270 --> 00:09:08,880
Quite a few people.

00:09:08,880 --> 00:09:11,640
How many people understand them?

00:09:11,640 --> 00:09:12,640
Right.

00:09:12,640 --> 00:09:13,640
Okay.

00:09:13,640 --> 00:09:15,960
So that's -- hopefully I want to rectify that today.

00:09:15,960 --> 00:09:17,710
If you get one thing out of this talk, it'll

00:09:17,710 --> 00:09:20,740
at least be a slightly better understanding of what generator functions

00:09:20,740 --> 00:09:22,650
are, because as I said, they're really powerful.

00:09:22,650 --> 00:09:25,830
At a high level, this is how I want you to think about

00:09:25,830 --> 00:09:26,830
generator functions.

00:09:26,830 --> 00:09:30,490
It's a function that can return multiple values.

00:09:30,490 --> 00:09:34,400
Well, you can already make a function that returns multiple values.

00:09:34,400 --> 00:09:36,510
Throw a few values in an array.

00:09:36,510 --> 00:09:41,780
But this allows you to do that more efficiently.

00:09:41,780 --> 00:09:47,270
This is what generator functions look like in ES2015.

00:09:47,270 --> 00:09:51,720
This yield keyword is like an intermediary return.

00:09:51,720 --> 00:09:56,080
It runs in the middle and you can return more values.

00:09:56,080 --> 00:10:00,830
So if you're consuming the data from a generator function, this is what it looks like.

00:10:00,830 --> 00:10:03,890
In order to get the data out, you request an iterator.

00:10:03,890 --> 00:10:05,400
By calling that function, what comes out is an

00:10:05,400 --> 00:10:06,530
iterator.

00:10:06,530 --> 00:10:11,000
An iterator is what you can call next on, and then what happens

00:10:11,000 --> 00:10:16,650
is the function evaluates to the first yield, and then stops and returns that

00:10:16,650 --> 00:10:17,650
value.

00:10:17,650 --> 00:10:20,370
And then it pops out of its little tuple which contains the value

00:10:20,370 --> 00:10:23,290
that was returned and a Boolean telling you whether or not there are

00:10:23,290 --> 00:10:24,420
more values.

00:10:24,420 --> 00:10:29,571
So if done is False, we can call next again, and execution is

00:10:29,571 --> 00:10:33,850
going to resume and move to the next yield and then pause and then return

00:10:33,850 --> 00:10:36,940
you another tuple, saying that value -- we know we have more to do, so I'm

00:10:36,940 --> 00:10:42,140
going to keep calling next, until finally we get return and we get our last

00:10:42,140 --> 00:10:47,000
value, and we know we're done, because done is True.

00:10:47,000 --> 00:10:52,310
If I want you to write a get numbers function today in ES2015,

00:10:52,310 --> 00:10:56,040
you would probably roll a sync machine.

00:10:56,040 --> 00:11:00,600
Calls next and I get the next value.

00:11:00,600 --> 00:11:03,460
Let's look at this Fibonacci sequence function here.

00:11:03,460 --> 00:11:11,280
And I'm going to show you what it desugars to, from ES2015 to ES5.

00:11:11,280 --> 00:11:13,570
So you can see I've got this stink variable on the

00:11:13,570 --> 00:11:16,750
left hand side and that's keeping track on of where I am.

00:11:16,750 --> 00:11:20,410
And I'm returning the object with this method, that's

00:11:20,410 --> 00:11:22,670
the iterator you saw earlier.

00:11:22,670 --> 00:11:28,430
Now, what this function actually is doing -- you can see here what generator

00:11:28,430 --> 00:11:32,790
functions do is they figure out every possible state that that function

00:11:32,790 --> 00:11:36,250
can be in and they build a state machine.

00:11:36,250 --> 00:11:40,460
So this get Fibonacci sequence can be in three different states when you call

00:11:40,460 --> 00:11:41,460
next.

00:11:41,460 --> 00:11:44,690
Where it's supposed to return zero at the beginning, where it's supposed

00:11:44,690 --> 00:11:49,320
to return one, and finally whatever it returned last time, whatever it

00:11:49,320 --> 00:11:53,040
returned before that, add them together, and return them.

00:11:53,040 --> 00:11:57,290
In JavaScript, in ES2015, this generator function is actually smart enough

00:11:57,290 --> 00:12:00,760
to figure that out and build this state machine for you.

00:12:00,760 --> 00:12:03,300
And what it's really doing is it's turning what

00:12:03,300 --> 00:12:04,980
looks like a push.

00:12:04,980 --> 00:12:08,410
Notice on the left hand side here -- yield kind of looks

00:12:08,410 --> 00:12:09,410
like a push.

00:12:09,410 --> 00:12:11,440
Imagine yield was a callback.

00:12:11,440 --> 00:12:12,440
Right?

00:12:12,440 --> 00:12:14,290
And there was brackets around that yield.

00:12:14,290 --> 00:12:16,980
The code looks like we're pushing the data.

00:12:16,980 --> 00:12:20,550
But the compiler turns it into code that pulls by

00:12:20,550 --> 00:12:23,040
building a state machine on the left hand side.

00:12:23,040 --> 00:12:24,990
So that's effectively what generator functions do.

00:12:24,990 --> 00:12:26,970
They let you write code that looks like you're pushing

00:12:26,970 --> 00:12:31,910
information when in fact it turns it inside out and then it uses pull

00:12:31,910 --> 00:12:33,540
for the control flow.

00:12:33,540 --> 00:12:38,080
So for each one of these yields, we have that return which returns the

00:12:38,080 --> 00:12:41,730
tuple, the value, and the done, and increments the state variables, as it goes

00:12:41,730 --> 00:12:45,420
along, and that's how we move through the states.

00:12:45,420 --> 00:12:46,420
This allows us to use iteration.

00:12:46,420 --> 00:12:51,990
The whole process of pulling a value out of it until you're done

00:12:51,990 --> 00:12:52,990
is called iteration.

00:12:52,990 --> 00:12:56,060
And it involves a consumer and a producer.

00:12:56,060 --> 00:13:00,560
The consumer requests an iterator from the producer,

00:13:00,560 --> 00:13:03,840
and then it pulls the value out by calling next.

00:13:03,840 --> 00:13:05,790
So the producer emits a value.

00:13:05,790 --> 00:13:06,790
Right?

00:13:06,790 --> 00:13:07,790
And why do I say it's pull?

00:13:07,790 --> 00:13:10,970
Well, notice I'm getting the value out in the return position

00:13:10,970 --> 00:13:11,970
of next.

00:13:11,970 --> 00:13:13,090
So I'm pulling functions out.

00:13:13,090 --> 00:13:14,540
I'm pulling values out.

00:13:14,540 --> 00:13:18,180
I keep pulling values out, until finally I pull out a value

00:13:18,180 --> 00:13:19,590
and the producer says you're done.

00:13:19,590 --> 00:13:20,770
So that's how iteration works.

00:13:20,770 --> 00:13:23,860
You keep pulling values out until the producer says I'm done.

00:13:23,860 --> 00:13:25,260
No more data.

00:13:25,260 --> 00:13:29,640
So if generator functions return iterators, why are they called generator

00:13:29,640 --> 00:13:30,640
functions?

00:13:30,640 --> 00:13:32,779
Why don't we just call them iterator functions?

00:13:32,779 --> 00:13:36,090
There's more than meets the eye when it comes to generator

00:13:36,090 --> 00:13:37,090
functions.

00:13:37,090 --> 00:13:40,670
A generator is actually built out of two different interfaces.

00:13:40,670 --> 00:13:43,730
The iterator you saw earlier, where you can call next and get out

00:13:43,730 --> 00:13:47,260
the little tuple saying what the value is and whether you're done -- it

00:13:47,260 --> 00:13:51,900
also has an entirely other side, a split personality, which is an observer

00:13:51,900 --> 00:13:55,130
interface, which gets push values.

00:13:55,130 --> 00:13:57,800
So a generator is both a source of data, which you can pull data out

00:13:57,800 --> 00:14:01,920
of, but it's also a sync which you can push data into.

00:14:01,920 --> 00:14:06,040
So these two sources combined create a generator.

00:14:06,040 --> 00:14:07,630
A generator is an iterator.

00:14:07,630 --> 00:14:10,360
You can pull a value out.

00:14:10,360 --> 00:14:13,050
If you attempt to pull a value out, you can get an error, because

00:14:13,050 --> 00:14:14,680
it might throw if you call next.

00:14:14,680 --> 00:14:19,930
And finally you can pull a value out and get that done:true in that little tuple.

00:14:19,930 --> 00:14:23,590
So there's three types of notifications that a producer can tell you

00:14:23,590 --> 00:14:24,590
during iteration.

00:14:24,590 --> 00:14:25,839
I've got some data.

00:14:25,839 --> 00:14:26,980
An error.

00:14:26,980 --> 00:14:29,670
And here's your final value.

00:14:29,670 --> 00:14:34,690
You can see all of those notifications in reverse on the observer side.

00:14:34,690 --> 00:14:39,620
So when you call next on a generator, you can also push a value in by

00:14:39,620 --> 00:14:42,690
passing a value in the argument position of next.

00:14:42,690 --> 00:14:47,089
You can also send an error in, by calling throw, and finally, you can send

00:14:47,089 --> 00:14:50,350
in a final value by calling return.

00:14:50,350 --> 00:14:53,820
So why does an observer have this sort of split personality of both being a source of

00:14:53,820 --> 00:14:56,089
data and sync?

00:14:56,089 --> 00:14:57,800
It's to solve a little problem.

00:14:57,800 --> 00:15:00,960
And that's that iteration only allows data to flow in one

00:15:00,960 --> 00:15:02,370
direction.

00:15:02,370 --> 00:15:05,870
Whereas with generators, two functions can effectively have a

00:15:05,870 --> 00:15:06,870
conversation.

00:15:06,870 --> 00:15:08,470
Have a long running conversation.

00:15:08,470 --> 00:15:09,710
I put a value out.

00:15:09,710 --> 00:15:10,930
I push a value back in.

00:15:10,930 --> 00:15:14,070
I pull a value out, I push a value back in.

00:15:14,070 --> 00:15:15,150
Why would I want to do that?

00:15:15,150 --> 00:15:16,960
What does that buy me?

00:15:16,960 --> 00:15:20,830
It allows us to use a very powerful pattern that I think a lot of people in the room are

00:15:20,830 --> 00:15:24,770
going to be using in the next few years called asynchronous iteration.

00:15:24,770 --> 00:15:28,910
So we have our generator function and the first thing I want you to notice is that

00:15:28,910 --> 00:15:31,360
I told you to use a mental model for understanding yield.

00:15:31,360 --> 00:15:35,290
The model I gave you was -- it's sort of like an intermediary return.

00:15:35,290 --> 00:15:40,520
But in this particular piece of code, it's used like an expression.

00:15:40,520 --> 00:15:43,899
We're siding to the result of a yield.

00:15:43,899 --> 00:15:46,160
So what's that about?

00:15:46,160 --> 00:15:47,680
Here we have a producer function.

00:15:47,680 --> 00:15:49,620
And what it's actually going to produce if you notice what's on the right

00:15:49,620 --> 00:15:53,250
hand side of those yields -- it's going to be an iterator of promises.

00:15:53,250 --> 00:15:57,339
So we're going to pull promises out of this iterator,

00:15:57,339 --> 00:16:00,990
and then what we're going to do is we're going to resolve those promises

00:16:00,990 --> 00:16:03,870
and then push the value back in.

00:16:03,870 --> 00:16:06,760
And so we need a consumer to go along with this producer.

00:16:06,760 --> 00:16:08,870
The consumer's job is just going to be to pull

00:16:08,870 --> 00:16:13,180
out, by calling next, pull out promises, resolve those promises, and push

00:16:13,180 --> 00:16:14,180
the value back in.

00:16:14,180 --> 00:16:16,290
And what you're going to see later is when you push

00:16:16,290 --> 00:16:21,080
a value back into the generator, the whole yield expression gets replaced with

00:16:21,080 --> 00:16:22,790
the value that you put back in.

00:16:22,790 --> 00:16:23,790
And this is the key.

00:16:23,790 --> 00:16:26,560
This is the recipe to allow you guys to write code that

00:16:26,560 --> 00:16:29,290
looks -- that looks like it blocks, but actually waits.

00:16:29,290 --> 00:16:30,750
So let's take a look at how this works.

00:16:30,750 --> 00:16:32,601
We have this spawn function, which I'm going to define

00:16:32,601 --> 00:16:33,610
in just a moment.

00:16:33,610 --> 00:16:35,779
Think about as the consumer -- it's pulling promises out

00:16:35,779 --> 00:16:38,390
of this iterator promise.

00:16:38,390 --> 00:16:40,340
So if I run this, what spawn is going to do is

00:16:40,340 --> 00:16:44,089
it's going to produce a promise which will be the eventual result of get

00:16:44,089 --> 00:16:47,830
stock price, after we resolve the get stock symbol promise and the get stock

00:16:47,830 --> 00:16:49,260
symbol price promise.

00:16:49,260 --> 00:16:52,070
So when I run this code eventually it's going to

00:16:52,070 --> 00:16:54,810
run the price of an individual stock.

00:16:54,810 --> 00:16:56,950
In this case, Pfizer stock.

00:16:56,950 --> 00:16:58,450
Well, asynchronous iteration works this way.

00:16:58,450 --> 00:17:01,010
You've got a consumer and a producer.

00:17:01,010 --> 00:17:04,959
The consumer requests a generator from the producer.

00:17:04,959 --> 00:17:08,369
And then calls next, pulls out the first value, but notice

00:17:08,369 --> 00:17:12,650
-- execution suspends at the first yield.

00:17:12,650 --> 00:17:15,299
And what we're yielding back is a promise.

00:17:15,299 --> 00:17:18,760
It's a promise that will eventually resolve to the symbol

00:17:18,760 --> 00:17:19,760
for Pfizer.

00:17:19,760 --> 00:17:22,520
And so that promise is handed to the consumer, and the consumer

00:17:22,520 --> 00:17:24,120
and the producer have an agreement.

00:17:24,120 --> 00:17:27,530
The consumer says -- every promise I pull out, I'm going to

00:17:27,530 --> 00:17:32,030
resolve, and then I'm going to push the value back into the producer.

00:17:32,030 --> 00:17:37,040
So the consumer calls then on the promise, waits until it's resolved, and

00:17:37,040 --> 00:17:41,550
then calls next again, on the generator, from the producer, except this time

00:17:41,550 --> 00:17:46,820
-- notice we pass PFE in the argument position of next.

00:17:46,820 --> 00:17:50,250
We're effectively pushing a value in, at the same time as we're

00:17:50,250 --> 00:17:51,930
pulling a value out.

00:17:51,930 --> 00:17:54,440
So we send PFE back in, and now I want you to look

00:17:54,440 --> 00:17:55,930
at what happens to the yield expression.

00:17:55,930 --> 00:18:00,190
It effectively gets replaced with a value that we get pushed

00:18:00,190 --> 00:18:04,960
in, and then execution resumes, and pauses at the next yield.

00:18:04,960 --> 00:18:07,900
So now the consumer's pushed in a value, and at the same

00:18:07,900 --> 00:18:10,030
time, they're pulling out another promise.

00:18:10,030 --> 00:18:12,809
This time for the price of that particular stock.

00:18:12,809 --> 00:18:14,679
So agreement between the consumer and the producer

00:18:14,679 --> 00:18:17,760
-- the consumer is going to resolve that promise.

00:18:17,760 --> 00:18:19,790
And when it gets a value, it's going to call next

00:18:19,790 --> 00:18:24,800
again, and this time, push 2783 back into the producer.

00:18:24,800 --> 00:18:28,020
That replaces yield.

00:18:28,020 --> 00:18:31,740
And we continue and stop at the final return value.

00:18:31,740 --> 00:18:33,460
So now we've actually returned -- it's not a promise.

00:18:33,460 --> 00:18:35,150
It's just a plain old value.

00:18:35,150 --> 00:18:36,150
Back to the consumer.

00:18:36,150 --> 00:18:37,150
And we said -- hey, we're done.

00:18:37,150 --> 00:18:38,310
We're not going to give you any more data.

00:18:38,310 --> 00:18:41,070
At this point, the consumer takes the promise that it

00:18:41,070 --> 00:18:47,020
returned, the spawn function, and it resolves it to the final value, 2783.

00:18:47,020 --> 00:18:48,550
So pictures are great.

00:18:48,550 --> 00:18:50,300
But let's take a look at some code.

00:18:50,300 --> 00:18:52,840
So here I have get stock price.

00:18:52,840 --> 00:18:55,900
And then I have this spawn function, which consumes it.

00:18:55,900 --> 00:18:59,370
So notice at the bottom I'm calling spawn, but I'm passing in

00:18:59,370 --> 00:19:01,950
the generator that comes out of get stock price into spawn.

00:19:01,950 --> 00:19:04,360
And what's going to come out of that is a promise that's

00:19:04,360 --> 00:19:07,530
eventually going to resolve to the final price of that stock.

00:19:07,530 --> 00:19:08,970
So I run this.

00:19:08,970 --> 00:19:11,961
And what happens is we immediately create a promise inside of the

00:19:11,961 --> 00:19:13,010
spawn function.

00:19:13,010 --> 00:19:15,920
And execution runs to the very bottom and hits this onresult

00:19:15,920 --> 00:19:16,920
function.

00:19:16,920 --> 00:19:20,080
And this function is basically my way of asynchronously looping

00:19:20,080 --> 00:19:21,490
and continuing to resolve promises.

00:19:21,490 --> 00:19:24,720
You're going to see me recursively call this function again and

00:19:24,720 --> 00:19:27,520
again, every single time I get a new value out of a promise.

00:19:27,520 --> 00:19:32,660
So we go up here, first time around, the last result is

00:19:32,660 --> 00:19:37,450
undefined, haven't gotten any yet, as soon as I call next, notice up

00:19:37,450 --> 00:19:42,950
there at the top, execution stops at the first yield and we return a promise

00:19:42,950 --> 00:19:45,610
that symbolizes the eventual stock symbol.

00:19:45,610 --> 00:19:47,790
And that gets returned to the consumer.

00:19:47,790 --> 00:19:51,650
If it's a promise, the consumer calls then on it.

00:19:51,650 --> 00:19:54,940
Notice here we're passing on the onresult function we started with.

00:19:54,940 --> 00:19:58,800
If but this time when the on result function is called it's going to get the result

00:19:58,800 --> 00:20:00,120
of that promise.

00:20:00,120 --> 00:20:03,160
So as soon as I do this, we're going to hop up back here,

00:20:03,160 --> 00:20:06,900
and the last promise result is going to be whatever came out of that promise.

00:20:06,900 --> 00:20:07,900
JNJ.

00:20:07,900 --> 00:20:09,950
So now I got the result of the promise as a producer, but I

00:20:09,950 --> 00:20:13,809
want to push it back -- excuse me, the consumer.

00:20:13,809 --> 00:20:15,480
I want to push it book back to the producer.

00:20:15,480 --> 00:20:16,510
So I call next.

00:20:16,510 --> 00:20:20,030
I pass back in JNJ as the argument, you look

00:20:20,030 --> 00:20:24,499
at the top there, notice what happens to the yield symbol promise expression

00:20:24,499 --> 00:20:28,500
-- it gets replaced with JNJ and execution resumes and stops at the next

00:20:28,500 --> 00:20:29,850
yield point.

00:20:29,850 --> 00:20:32,870
So get symbol price is a promise that eventually resolves to the

00:20:32,870 --> 00:20:34,740
price.

00:20:34,740 --> 00:20:36,740
That's what comes out to the consumer.

00:20:36,740 --> 00:20:37,740
Another promise.

00:20:37,740 --> 00:20:38,809
We call then on it again.

00:20:38,809 --> 00:20:41,950
Pass in on result, that recursively gets resolved to

00:20:41,950 --> 00:20:45,970
the next promise, which is the price.

00:20:45,970 --> 00:20:51,170
We call next, yield gets replaced with that price, and then we continue

00:20:51,170 --> 00:20:54,180
on to the very end of the generator function, at which point it comes out

00:20:54,180 --> 00:20:55,180
and says -- you know what?

00:20:55,180 --> 00:20:56,180
Done is true.

00:20:56,180 --> 00:20:57,650
We're not going to get any more values.

00:20:57,650 --> 00:20:59,530
Consumer takes that, doesn't need to resolve it, it's not a

00:20:59,530 --> 00:21:03,650
promise, and then resolves the overall promise that was returned from

00:21:03,650 --> 00:21:06,510
spawn to that final value.

00:21:06,510 --> 00:21:09,390
And that's how asynchronous iteration works.

00:21:09,390 --> 00:21:12,210
And that's how you can write code at the top, right?

00:21:12,210 --> 00:21:16,270
That looks like it blocks, but it actually waits.

00:21:16,270 --> 00:21:18,750
So there is this spawn function actually defined

00:21:18,750 --> 00:21:21,740
in a library that you can go and try, which is called task.js.

00:21:21,740 --> 00:21:26,420
If you're using a transpiler that allows you to use yield in your code or you're using

00:21:26,420 --> 00:21:31,160
a browser that is ES2015 capable, lucky you, you can do this today.

00:21:31,160 --> 00:21:36,450
You can download the spawn function, which is in task.js.

00:21:36,450 --> 00:21:40,929
So that's how asynchronous functions work and how generators interact with promises

00:21:40,929 --> 00:21:43,480
to produce this pretty impressive code.

00:21:43,480 --> 00:21:46,990
But why should we have to download a library to do

00:21:46,990 --> 00:21:47,990
this?

00:21:47,990 --> 00:21:53,880
This is going to be a common expression in JavaScript.

00:21:53,880 --> 00:21:55,100
Why do we need a library?

00:21:55,100 --> 00:21:58,230
Why can't we have direct support in the JavaScript language for

00:21:58,230 --> 00:21:59,230
this?

00:21:59,230 --> 00:22:04,150
And that is our first feature today from ES2016, and its async

00:22:04,150 --> 00:22:05,150
functions.

00:22:05,150 --> 00:22:06,600
And now you guys know everything you need to know about how

00:22:06,600 --> 00:22:07,950
async functions need to work.

00:22:07,950 --> 00:22:10,670
They are like sugar over what you just saw.

00:22:10,670 --> 00:22:15,000
This combination of spawn and yield -- soon in the next version of JavaScript

00:22:15,000 --> 00:22:18,510
you'll be able to write code like this, on the left hand side.

00:22:18,510 --> 00:22:20,840
For those of you who are familiar with C#, this feature

00:22:20,840 --> 00:22:22,490
is there as well.

00:22:22,490 --> 00:22:27,820
You can just put the word async in front of any function

00:22:27,820 --> 00:22:30,450
and then inside of there, any time you want to pause until a promise has

00:22:30,450 --> 00:22:33,500
been resolved, you can throw a wait in there.

00:22:33,500 --> 00:22:36,360
So that's what's coming in the next version of JavaScript.

00:22:36,360 --> 00:22:40,340
So we're getting closer to this vision of symmetrical

00:22:40,340 --> 00:22:43,040
support for blocking and waiting in JavaScript.

00:22:43,040 --> 00:22:44,040
Right?

00:22:44,040 --> 00:22:45,890
If I want to wait, I throw an async in front of that function.

00:22:45,890 --> 00:22:47,080
I throw a few waits in there.

00:22:47,080 --> 00:22:50,810
If I want to block, I take them out.

00:22:50,810 --> 00:22:52,590
In order to talk about any features in the next version

00:22:52,590 --> 00:22:57,810
of JavaScript, responsibly, we have talk about the ES feature maturity stages.

00:22:57,810 --> 00:23:01,610
So as we develop new protocols in JavaScript committee, we have to give time

00:23:01,610 --> 00:23:06,000
to move them out.

00:23:06,000 --> 00:23:11,000
So I'm going to tell you about which stage it is in maturity.

00:23:11,000 --> 00:23:13,380
So async functions are in the draft stage.

00:23:13,380 --> 00:23:16,240
That means that the committee expects the feature to be

00:23:16,240 --> 00:23:17,710
developed and included in the standard.

00:23:17,710 --> 00:23:20,429
I think it's very, very likely we're going to see async functions in the

00:23:20,429 --> 00:23:22,130
next version of JavaScript.

00:23:22,130 --> 00:23:23,540
It's definitely something you can play with today

00:23:23,540 --> 00:23:27,000
if you use Babel or a transpiler, like Tracer.

00:23:27,000 --> 00:23:28,340
Right now.

00:23:28,340 --> 00:23:29,630
If you want to.

00:23:29,630 --> 00:23:31,350
Go ahead, try it out.

00:23:31,350 --> 00:23:32,350
That's why it's there.

00:23:32,350 --> 00:23:35,090
And give us your feedback.

00:23:35,090 --> 00:23:40,059
You can try it in Babel, if you want to try it in Regenerator as well

00:23:40,059 --> 00:23:44,140
-- I think they're in the main branch.

00:23:44,140 --> 00:23:47,890
Babel is probably the easiest and most likely way by which you're

00:23:47,890 --> 00:23:49,809
going to try this feature.

00:23:49,809 --> 00:23:52,120
The await keyboard makes it easy to await one

00:23:52,120 --> 00:23:54,370
asynchronous value.

00:23:54,370 --> 00:23:56,809
What if you want to wait on multiple values?

00:23:56,809 --> 00:23:59,390
We await multiple values all the time.

00:23:59,390 --> 00:24:01,390
Web sockets, DOM events.

00:24:01,390 --> 00:24:05,510
Lots of streams of information that are being pushed at us, and

00:24:05,510 --> 00:24:09,440
there's no real language support for traversing those streams of information.

00:24:09,440 --> 00:24:13,130
Now, in ES6, all collections became iterable.

00:24:13,130 --> 00:24:16,300
And it's a contract.

00:24:16,300 --> 00:24:18,280
If you walk up to the array, for example, it means

00:24:18,280 --> 00:24:22,260
you can ask that array for an iterator, and gradually consume its items

00:24:22,260 --> 00:24:24,390
one at a time by pulling them out.

00:24:24,390 --> 00:24:26,010
Here's an example.

00:24:26,010 --> 00:24:31,090
I can call this symbol.iterator method and get out an

00:24:31,090 --> 00:24:33,340
iterator and keep looping and calling next.

00:24:33,340 --> 00:24:37,880
That's annoying, a lot of boilerplate, which is why in ES2016 we introduced

00:24:37,880 --> 00:24:44,040
this for of loop.

00:24:44,040 --> 00:24:46,140
So there's a couple of new collections coming

00:24:46,140 --> 00:24:50,690
in ES6 as well, like maps, and you can use this -- to consume that data.

00:24:50,690 --> 00:24:51,690
Progressively.

00:24:51,690 --> 00:24:53,280
So that's what the new for of loop is for.

00:24:53,280 --> 00:24:56,110
It just desugars to what you see on the left hand side.

00:24:56,110 --> 00:25:00,929
Now, if we can wait for values that we can pull out, for streams

00:25:00,929 --> 00:25:04,400
of values that we can pull out, why can't we wait for streams of values that

00:25:04,400 --> 00:25:06,230
are being pushed at us?

00:25:06,230 --> 00:25:08,650
Why can't we have an equal support, like a loop for

00:25:08,650 --> 00:25:12,400
consuming data that comes out of a web socket, or comes out of async IO, for

00:25:12,400 --> 00:25:13,830
example?

00:25:13,830 --> 00:25:18,100
That's the logic behind the proposed for on loop for the next

00:25:18,100 --> 00:25:19,460
version of JavaScript.

00:25:19,460 --> 00:25:21,711
If you can have a for of, why can't you have a for

00:25:21,711 --> 00:25:22,790
on?

00:25:22,790 --> 00:25:27,920
So I'm creating an async function and inside I'm consuming the prices

00:25:27,920 --> 00:25:29,100
from a web socket.

00:25:29,100 --> 00:25:31,720
And the very first price differential that's over a

00:25:31,720 --> 00:25:34,770
certain threshold -- I'm going to resolve the promise and grab that

00:25:34,770 --> 00:25:38,450
particular diff between the previous price and the next price.

00:25:38,450 --> 00:25:39,809
No callbacks required.

00:25:39,809 --> 00:25:42,590
I'm just looping over a stream of information being

00:25:42,590 --> 00:25:45,030
pushed at me.

00:25:45,030 --> 00:25:46,520
So this would be great to do.

00:25:46,520 --> 00:25:47,520
Right?

00:25:47,520 --> 00:25:49,380
Now when I run this, it resolves to a promise to give you the next

00:25:49,380 --> 00:25:51,400
price spike in this stream of stock prices.

00:25:51,400 --> 00:25:53,010
But there's a little problem.

00:25:53,010 --> 00:25:55,970
There's a reason we can't have nice things just yet.

00:25:55,970 --> 00:25:56,970
Right?

00:25:56,970 --> 00:26:00,840
The problem is that the web has no standard observable interface.

00:26:00,840 --> 00:26:01,840
We have iterable.

00:26:01,840 --> 00:26:06,750
As of ES6, this contract you saw earlier, what you call symbol.iterator.

00:26:06,750 --> 00:26:11,510
But today we have this proliferation of different APIs that push

00:26:11,510 --> 00:26:12,929
us streams of data.

00:26:12,929 --> 00:26:16,590
That push us data in a callback in a streamed way.

00:26:16,590 --> 00:26:24,680
DOM events, web sockets, node streams, XHTML requests -- can all push you

00:26:24,680 --> 00:26:26,370
values.

00:26:26,370 --> 00:26:28,940
But they don't implement one common interface.

00:26:28,940 --> 00:26:35,360
So one thing proposed for ES2016 is the observable contract.

00:26:35,360 --> 00:26:38,490
So here we have the iterable contract, introduced in

00:26:38,490 --> 00:26:39,490
2015.

00:26:39,490 --> 00:26:41,010
How are we going to get the observable contract?

00:26:41,010 --> 00:26:44,250
It's hidden inside of this type.

00:26:44,250 --> 00:26:49,481
If we just swap the arguments and the return type of the

00:26:49,481 --> 00:26:53,179
iterable what pops out is an observable.

00:26:53,179 --> 00:26:58,570
An observable accepts a generator, and then uses the push side of

00:26:58,570 --> 00:27:03,530
the generator, and pushes multiple values in it until it finally calls

00:27:03,530 --> 00:27:06,790
return to signal that no more values are coming.

00:27:06,790 --> 00:27:11,020
If you think about it, iteration and observation are both about the same thing.

00:27:11,020 --> 00:27:13,880
Both about a producer giving a consumer multiple values.

00:27:13,880 --> 00:27:16,309
The difference is in one circumstance with DOM

00:27:16,309 --> 00:27:19,470
events, the data is being pushed to you.

00:27:19,470 --> 00:27:22,559
But when you're using an iterator to pull values out of an array, you're

00:27:22,559 --> 00:27:23,559
pulling values.

00:27:23,559 --> 00:27:24,559
Right?

00:27:24,559 --> 00:27:26,460
In iteration, the consumer is in control, and in

00:27:26,460 --> 00:27:28,640
observation, the producer is in control.

00:27:28,640 --> 00:27:31,190
The web socket decides when it calls you.

00:27:31,190 --> 00:27:33,450
So it's sort of like they're it rating you.

00:27:33,450 --> 00:27:35,420
The producer is iterating you by calling your callback.

00:27:35,420 --> 00:27:38,010
So how does observation work?

00:27:38,010 --> 00:27:40,030
The consumer and producer and the relationship

00:27:40,030 --> 00:27:44,470
with iteration -- it's the exact same process but kind of the inverse.

00:27:44,470 --> 00:27:49,730
So here the producer, instead of the consumer requesting a generator from the producer,

00:27:49,730 --> 00:27:54,360
the producer -- or the consumer hands a generator to the producer.

00:27:54,360 --> 00:27:57,020
And in this context, just think about a generator as like three callbacks.

00:27:57,020 --> 00:28:00,179
It's got the next, the throw, and the return callbacks.

00:28:00,179 --> 00:28:02,480
Just like you're handing an API three callbacks and

00:28:02,480 --> 00:28:06,010
expecting it to push information to you by calling your callbacks.

00:28:06,010 --> 00:28:09,990
So the producer produces a value and calls the next

00:28:09,990 --> 00:28:12,890
method on your generator, the one you provided to it, and that's how

00:28:12,890 --> 00:28:17,940
it pushes 42 to you, and pushes another value and at its leisure, decides

00:28:17,940 --> 00:28:20,940
to push 39 to you, until finally it says you know what?

00:28:20,940 --> 00:28:22,370
There's no more data coming.

00:28:22,370 --> 00:28:25,470
So it calls return to indicate to you no more data will

00:28:25,470 --> 00:28:28,200
arrive.

00:28:28,200 --> 00:28:31,000
So observation and iteration are actually deeply linked.

00:28:31,000 --> 00:28:34,330
As we saw, we can turn one inside out and get the other.

00:28:34,330 --> 00:28:39,620
So this is what it would look like to consume a web socket or a DOM event that implemented

00:28:39,620 --> 00:28:40,620
this contract.

00:28:40,620 --> 00:28:42,890
You could just walk up to any of these data sources and hand it a

00:28:42,890 --> 00:28:47,090
generator, which is these three callbacks, and then it will just push

00:28:47,090 --> 00:28:48,090
streams of data at you.

00:28:48,090 --> 00:28:50,720
Until it tells you it's done.

00:28:50,720 --> 00:28:55,260
So we can add sugar, just like we added sugar for iteration, for

00:28:55,260 --> 00:28:58,840
that whole process of calling symbol.iterator, and that while loop, and

00:28:58,840 --> 00:29:02,320
checking the done property, just like we can add sugar for that, we can add

00:29:02,320 --> 00:29:04,450
sugar for observation.

00:29:04,450 --> 00:29:07,289
A 4H method, for example, to an observer that returned

00:29:07,289 --> 00:29:12,340
a promise when it resolved, or, as I showed you guys earlier, now that

00:29:12,340 --> 00:29:18,299
we have a well defined method for observation, which we do, a for on loop.

00:29:18,299 --> 00:29:22,590
So the push stream can be done entirely without callbacks.

00:29:22,590 --> 00:29:27,530
So the hope would be if we introduce observable, all the push APIs on the web can implement

00:29:27,530 --> 00:29:31,130
this contract and all of a sudden we can just add language support magically

00:29:31,130 --> 00:29:33,880
for all of these different push data sources.

00:29:33,880 --> 00:29:38,130
So if I wanted to consume an observable in ES2016, at least as the proposal

00:29:38,130 --> 00:29:40,240
stands, I could do something like this.

00:29:40,240 --> 00:29:43,970
And this is just going to keep printing out new sign-ups at Netflix.

00:29:43,970 --> 00:29:46,630
Just going to keep going.

00:29:46,630 --> 00:29:47,630
So...

00:29:47,630 --> 00:29:51,460
If an async function returns a promise, and a function

00:29:51,460 --> 00:29:57,059
star returns an iterator, we as language designers have a question to

00:29:57,059 --> 00:30:00,160
answer.

00:30:00,160 --> 00:30:02,190
What does an async function star return?

00:30:02,190 --> 00:30:04,150
You can't just go adding features to languages and

00:30:04,150 --> 00:30:07,820
not describing what happens when you put them together, when they

00:30:07,820 --> 00:30:08,820
interact.

00:30:08,820 --> 00:30:11,090
Well, there's a couple of different opinions about this.

00:30:11,090 --> 00:30:12,330
And there's actually a couple different ways the

00:30:12,330 --> 00:30:13,330
committee could go.

00:30:13,330 --> 00:30:15,030
I'm here today to tell you about one particular

00:30:15,030 --> 00:30:16,030
option.

00:30:16,030 --> 00:30:18,350
So if we look at this table, we've got synchronous functions,

00:30:18,350 --> 00:30:23,910
which return a value, synchronous generators, which return multiple values,

00:30:23,910 --> 00:30:28,100
you can pull multiple values out of -- but we also have asynchronous functions,

00:30:28,100 --> 00:30:32,360
which return a promise, and a promise pushes you one value.

00:30:32,360 --> 00:30:33,360
Right?

00:30:33,360 --> 00:30:36,130
You give it a callback and it pushes the value on that callback.

00:30:36,130 --> 00:30:38,440
But what goes here?

00:30:38,440 --> 00:30:44,120
Well, if a function star returns multiple values, and an async function

00:30:44,120 --> 00:30:51,440
pushes one value, maybe an async function star pushes multiple values.

00:30:51,440 --> 00:30:54,570
And what type pushes us multiple values?

00:30:54,570 --> 00:30:57,020
An observable.

00:30:57,020 --> 00:30:59,120
So we can envision, in the next version of JavaScript,

00:30:59,120 --> 00:31:04,160
an async function star, which pushes -- which actually returns you an observable.

00:31:04,160 --> 00:31:08,790
So you could build an asynchronous generator function,

00:31:08,790 --> 00:31:13,890
which consumes data, stock data, for example, and then translates it and produces

00:31:13,890 --> 00:31:16,060
new stock data.

00:31:16,060 --> 00:31:19,159
So now, instead of just getting the next price spike

00:31:19,159 --> 00:31:21,960
from a web socket, I want to get all the price spikes from a web socket.

00:31:21,960 --> 00:31:27,330
I'm going to use the for on loop and yield inside of async function star, and this

00:31:27,330 --> 00:31:31,480
whole thing is going to produce an observable that pushes me all the

00:31:31,480 --> 00:31:34,980
price spikes, all the stock differences, when one stock comes along and

00:31:34,980 --> 00:31:37,559
another stock comes along, and that price difference is over a certain

00:31:37,559 --> 00:31:39,910
threshold, just going to push it on through to me.

00:31:39,910 --> 00:31:42,909
And if I want to consume this, I can just use for

00:31:42,909 --> 00:31:43,909
on, inside of an async function.

00:31:43,909 --> 00:31:48,600
And print to the console.

00:31:48,600 --> 00:31:49,600
So what does that mean?

00:31:49,600 --> 00:31:52,880
It means symmetrical support for functions that return multiple

00:31:52,880 --> 00:31:53,880
values.

00:31:53,880 --> 00:31:55,630
Whether they're push or they're pull.

00:31:55,630 --> 00:31:58,539
You guys can stop worrying about the machinery and the callbacks and just

00:31:58,539 --> 00:32:00,419
focus on your code.

00:32:00,419 --> 00:32:01,730
So...

00:32:01,730 --> 00:32:05,030
This particular proposal -- I just want to call out -- is at the strawman phase.

00:32:05,030 --> 00:32:07,160
The earliest phase of the process.

00:32:07,160 --> 00:32:08,490
So we're definitely going to be thinking about

00:32:08,490 --> 00:32:11,770
this more, and this may not make it through as a final feature.

00:32:11,770 --> 00:32:13,030
Just want to make that clear.

00:32:13,030 --> 00:32:15,340
It's very early in the feature stages.

00:32:15,340 --> 00:32:16,840
We're looking for feedback on this.

00:32:16,840 --> 00:32:19,450
So we want to hear from you about whether this works for you

00:32:19,450 --> 00:32:21,590
and solves your problems.

00:32:21,590 --> 00:32:22,940
So thanks very much, everybody.

00:32:22,940 --> 00:32:25,649

YouTube URL: https://www.youtube.com/watch?v=lil4YCCXRYc


