Title: Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	Who in their right mind would ever want to work with RDBMS anymore. Especially in JavaScript, where you can just call "save" on your JSON and turn it into web-scale BSON, or get to choose between so many levels of DB that we don't even know which to use. This will be a story about one person's journey to try and make people believe that Node can actually be a thing for boring, early-2000's era web applications using (gasp) SQL. It'll also share some discoveries along the way including how ACID / transactions can be super useful in the everything-async world of JavaScript, and some tips and tricks for keeping a sane and organized data layer when venturing into the abyss of hybrid single-page / server-rendered applications.

Transcript: https://gist.github.com/voodootikigod/36d5eb51686805459bfa
Captions: 
	00:00:14,870 --> 00:00:15,870
Thanks.

00:00:15,870 --> 00:00:18,700
So yeah, I'm really excited to be here, talking about making

00:00:18,700 --> 00:00:21,620
relational cool again, and the subtitle is...

00:00:21,620 --> 00:00:23,420
Or JavaScript on ACID.

00:00:23,420 --> 00:00:27,210
And like I said, my name is Tim Griesser, Tgriesser

00:00:27,210 --> 00:00:31,140
on Github, and I'm here really excited to be talking about SQL.

00:00:31,140 --> 00:00:34,390
Or is it Ess-kyoo-ell?

00:00:34,390 --> 00:00:40,390
I know it's an issue that really divides programmers.

00:00:40,390 --> 00:00:46,700
So I Googled it, and the first result I came across was this English language and use in

00:00:46,700 --> 00:00:47,969
Stack Exchange.

00:00:47,969 --> 00:00:51,440
Which I thought was fitting, given that we're at a programming

00:00:51,440 --> 00:00:53,180
conference.

00:00:53,180 --> 00:00:55,760
And the first thing you'll notice is I'm not a member of the English

00:00:55,760 --> 00:01:01,129
language and usage, so if I make any mistakes up here, you'll know why.

00:01:01,129 --> 00:01:05,260
But the answer was that it was in fact first called the structured English query

00:01:05,260 --> 00:01:08,430
language, and so that acronym was SEQUEL.

00:01:08,430 --> 00:01:15,070
And then that was abbreviated as SQL.

00:01:15,070 --> 00:01:16,570
Now it's a matter of preference.

00:01:16,570 --> 00:01:18,900
And there's an urban legend that it came after the structured

00:01:18,900 --> 00:01:25,610
query language, which is the worst urban legend I ever heard.

00:01:25,610 --> 00:01:30,320
So I learned something new, and now I'm a member.

00:01:30,320 --> 00:01:35,570
It was a big day.

00:01:35,570 --> 00:01:39,120
But it's appropriate that we're talking about relational databases

00:01:39,120 --> 00:01:43,090
at a JavaScript conference, because I think there's a lot of similar features

00:01:43,090 --> 00:01:45,100
between the two.

00:01:45,100 --> 00:01:47,550
At a language level, maybe not so much.

00:01:47,550 --> 00:01:53,670
Relational, SQL is static and strongly typed, declarative, and in some ways procedural,

00:01:53,670 --> 00:01:58,280
and JavaScript is as loosely typed as you can get while still being a programming

00:01:58,280 --> 00:02:05,950
language, and it's object oriented, which leads to some interesting

00:02:05,950 --> 00:02:12,840
debates as to how to write the code correctly, and it shares some of the same

00:02:12,840 --> 00:02:17,590
operators, but we know in JavaScript the operators don't do what we want some of

00:02:17,590 --> 00:02:19,720
the time.

00:02:19,720 --> 00:02:23,280
So what do I mean when I say is theres a lot of similarities between

00:02:23,280 --> 00:02:25,280
SQL and JavaScript?

00:02:25,280 --> 00:02:29,680
They both sort of share this similar quality that is not

00:02:29,680 --> 00:02:33,689
often attained by all languages, which is what I like to term -- languages

00:02:33,689 --> 00:02:36,319
that will probably never die.

00:02:36,319 --> 00:02:38,900
As much as people try to kill off JavaScript

00:02:38,900 --> 00:02:44,170
with different other languages that will supersede it, it sort has this monopoly.

00:02:44,170 --> 00:02:45,500
It's the language of the web.

00:02:45,500 --> 00:02:47,819
It's the language that runs in web browsers.

00:02:47,819 --> 00:02:51,200
And similarly, SQL has so much momentum.

00:02:51,200 --> 00:02:55,519
It's been around since the '70s and it's been around forever.

00:02:55,519 --> 00:02:58,379
This is a slide that we often show when we're talking

00:02:58,379 --> 00:03:01,200
about JavaScript, just sort of illustrating that it runs everywhere.

00:03:01,200 --> 00:03:05,790
In the browsers, but also your television and your server and your nodebots

00:03:05,790 --> 00:03:09,430
and copters and also on your phones, and I think the same could be sort

00:03:09,430 --> 00:03:10,750
of said about SQL.

00:03:10,750 --> 00:03:13,529
Is that it powers the largest websites in the world.

00:03:13,529 --> 00:03:21,200
It's behind Facebook and Wikipedia, and also down to SQL-lite, flat file storage,

00:03:21,200 --> 00:03:27,760
which is in more places than you would imagine on your phones.

00:03:27,760 --> 00:03:31,350
So coming to node.js a couple years ago, I was

00:03:31,350 --> 00:03:32,420
sort of surprised.

00:03:32,420 --> 00:03:34,930
It seems like these two would be such a great fit.

00:03:34,930 --> 00:03:37,769
They're both everywhere.

00:03:37,769 --> 00:03:40,810
Why is there not more support for it?

00:03:40,810 --> 00:03:44,819
And I think the reason is that node starts with no, and no is the

00:03:44,819 --> 00:03:50,650
beginning of NoSQL, and around the time that node came out, it was like -- let's

00:03:50,650 --> 00:03:55,170
rethink the entire way that we're writing server side applications with

00:03:55,170 --> 00:03:56,700
this evented IO model.

00:03:56,700 --> 00:04:00,200
And at the time, it was sort of like -- let's rethink

00:04:00,200 --> 00:04:04,540
the standard relational database, because we're hitting web scale and we need

00:04:04,540 --> 00:04:07,269
to get past that.

00:04:07,269 --> 00:04:13,769
And so around the time that sort of the height of the NoSQL phase or moment --

00:04:13,769 --> 00:04:18,421
it's still going, of course -- is when node came out, and that's why there was

00:04:18,421 --> 00:04:19,421
so much of this.

00:04:19,421 --> 00:04:23,389
So all the tutorials I felt like for node were node and

00:04:23,389 --> 00:04:26,500
Mongo, getting started -- they have literally taken the software and web

00:04:26,500 --> 00:04:31,740
industries by storm.

00:04:31,740 --> 00:04:34,470
You've got Mongo express angular node, which everybody

00:04:34,470 --> 00:04:44,620
has heard of, and then my favorite, the LeBron stack, level DB slam dunk.

00:04:44,620 --> 00:04:47,460
And what happened to relational algebra?

00:04:47,460 --> 00:04:48,460
Right?

00:04:48,460 --> 00:04:50,860
This is proven and time tested.

00:04:50,860 --> 00:04:55,400
And SQL works great for a lot of things.

00:04:55,400 --> 00:04:59,400
And this stack overflow post that I came across sort of summed up what I was thinking,

00:04:59,400 --> 00:05:03,759
coming to node from outside.

00:05:03,759 --> 00:05:06,340
Are relational databases a poor fit?

00:05:06,340 --> 00:05:09,660
And this is sort of long, so let me just pick out a few things.

00:05:09,660 --> 00:05:15,139
There's a degree of antipathy toward relational databases, is an observation you could make

00:05:15,139 --> 00:05:17,479
of the node community.

00:05:17,479 --> 00:05:20,710
And that they're poorly supported, compared to non-relational

00:05:20,710 --> 00:05:21,710
databases.

00:05:21,710 --> 00:05:22,810
I sort of agree with this.

00:05:22,810 --> 00:05:27,580
Listening to the node up podcasts, listening to couch DB and

00:05:27,580 --> 00:05:33,159
Mongo, I guess it was like -- relational databases aren't cool anymore.

00:05:33,159 --> 00:05:36,851
I dug a little and found there actually are really

00:05:36,851 --> 00:05:42,280
great libraries for working with SQL in node.

00:05:42,280 --> 00:05:52,320
All the popular Open Source, and Oracle came out with another

00:05:52,320 --> 00:05:53,320
one.

00:05:53,320 --> 00:05:57,229
But there's not a common API all of them.

00:05:57,229 --> 00:06:01,120
Node didn't assume that a relational database was a given.

00:06:01,120 --> 00:06:07,259
In all other language systems, there's a standard for how you're interacting with common

00:06:07,259 --> 00:06:08,800
patterns of a database.

00:06:08,800 --> 00:06:11,169
How you connect, how you disconnect.

00:06:11,169 --> 00:06:12,169
That doesn't exist.

00:06:12,169 --> 00:06:16,539
So what that lends to is that all the different clients have a different

00:06:16,539 --> 00:06:20,370
way of dealing with these things that should be pretty common.

00:06:20,370 --> 00:06:25,379
And there's also, I guess -- the next thing I noticed was that the higher level

00:06:25,379 --> 00:06:27,960
abstractions were lacking a little bit.

00:06:27,960 --> 00:06:31,150
And what I mean by that is that a lot of them were database-specific.

00:06:31,150 --> 00:06:34,039
So there was a great query builder, but it works for

00:06:34,039 --> 00:06:36,509
postgres, specifically.

00:06:36,509 --> 00:06:39,940
Another great one for another language, and no way

00:06:39,940 --> 00:06:42,440
to use the same for both.

00:06:42,440 --> 00:06:43,740
Different APIs.

00:06:43,740 --> 00:06:47,120
Or there's a mix of an ORM layer and a query layer, so there's no

00:06:47,120 --> 00:06:52,189
ability to drop down and use just vanilla SQL if you need to.

00:06:52,189 --> 00:06:55,659
One that was big for me is the lack of transaction APIs.

00:06:55,659 --> 00:06:58,300
So there wasn't any mention of transactions.

00:06:58,300 --> 00:07:01,350
In any of the higher level libraries that I had seen at the

00:07:01,350 --> 00:07:02,350
time.

00:07:02,350 --> 00:07:05,840
And that is sort of what the second subtitle of the talk is that I'll

00:07:05,840 --> 00:07:06,979
get to in a little bit.

00:07:06,979 --> 00:07:09,129
And then there was the jack of all trades, where it's

00:07:09,129 --> 00:07:14,610
sort of like -- hey, you can use the same save API to save to Redis or Mongo

00:07:14,610 --> 00:07:17,460
or relational database or the file system.

00:07:17,460 --> 00:07:18,479
It's like...

00:07:18,479 --> 00:07:23,289
If you have the same API for all these different specialized data

00:07:23,289 --> 00:07:28,020
stores, you're really not taking advantage of the best use cases for each of

00:07:28,020 --> 00:07:29,020
them.

00:07:29,020 --> 00:07:30,940
Or there's sort of what I call the DIY.

00:07:30,940 --> 00:07:34,180
Like, it gets you most of the way, but modularity.

00:07:34,180 --> 00:07:37,500
So you have to assemble all these.

00:07:37,500 --> 00:07:41,330
The pooling, the construction, the abstracting the

00:07:41,330 --> 00:07:42,990
database API.

00:07:42,990 --> 00:07:46,941
So the ecosystem -- I would definitely agree with the Stack

00:07:46,941 --> 00:07:53,560
Overflow post, that there's a need there, that needs to be filled.

00:07:53,560 --> 00:07:55,200
But I really wanted this to happen.

00:07:55,200 --> 00:07:56,720
I really love writing JavaScript.

00:07:56,720 --> 00:07:58,460
So I was like...

00:07:58,460 --> 00:07:59,870
Maybe we can do something better.

00:07:59,870 --> 00:08:02,880
And at the time, I had been writing a lot of PHP.

00:08:02,880 --> 00:08:06,569
This was back in 2012, in a framework called Laravel, which some

00:08:06,569 --> 00:08:07,569
might have heard of.

00:08:07,569 --> 00:08:13,759
And it makes writing PHP pretty tolerable.

00:08:13,759 --> 00:08:15,560
And I was also using a lot of backbones.

00:08:15,560 --> 00:08:16,560
So I was thinking...

00:08:16,560 --> 00:08:20,410
Maybe I can take some of the ideas from both of these, and I sort of translated

00:08:20,410 --> 00:08:25,280
the query builder from Laravel into this project called Knex.JS.

00:08:25,280 --> 00:08:29,800
And this sort of illustrates what pieces were taken from each, but the eloquent

00:08:29,800 --> 00:08:33,950
ORM from Laravel and some of the ideas from backbone into bookshelf, and mix

00:08:33,950 --> 00:08:38,840
into promises -- and so I'm going to talk about these two libraries that I have

00:08:38,840 --> 00:08:41,530
put together, connects and bookshelf.

00:08:41,530 --> 00:08:43,470
The first is Knex.

00:08:43,470 --> 00:08:48,889
If you're not familiar with where the name comes from, it's this toy that was popular

00:08:48,889 --> 00:08:50,570
in the '90s.

00:08:50,570 --> 00:08:53,010
It's sort of like a cheaper version of Legos.

00:08:53,010 --> 00:08:56,070
You can assemble all these pieces together and build

00:08:56,070 --> 00:08:58,310
pretty cool-looking things.

00:08:58,310 --> 00:09:04,529
And actually, it's really great if you're procrastinating, making conference slides.

00:09:04,529 --> 00:09:09,560
I decided to make this little motorcycle here.

00:09:09,560 --> 00:09:14,089
All right, JSConf.

00:09:14,089 --> 00:09:16,950
But the reason that I think...

00:09:16,950 --> 00:09:22,279
What Knex tries to do is standardize some of the inconsistencies

00:09:22,279 --> 00:09:23,440
in SQL.

00:09:23,440 --> 00:09:28,420
So SQL is a language -- an ANSI language specification.

00:09:28,420 --> 00:09:33,949
But it's not like it is, what we're used to with, like, ES5 or ES6 and beyond.

00:09:33,949 --> 00:09:36,930
Where we sort of have this compatibility table, and we see that Babel

00:09:36,930 --> 00:09:41,519
is in ahead of everything else, in terms of implementing all the different features.

00:09:41,519 --> 00:09:45,339
But it feels more like the can I use.

00:09:45,339 --> 00:09:47,060
Sort of like a language guideline.

00:09:47,060 --> 00:09:55,300
There are features that exist in some dialects but not others.

00:09:55,300 --> 00:09:59,170
It doesn't fail, or it fails sometimes, or --

00:09:59,170 --> 00:10:04,310
different inconsistencies that Knex tries to paper over.

00:10:04,310 --> 00:10:07,370
This is an illustration of the different pieces as they're

00:10:07,370 --> 00:10:09,490
coming over internally.

00:10:09,490 --> 00:10:12,170
Have things like connection pooling, to make sure

00:10:12,170 --> 00:10:14,779
you're getting connections that you don't have to continually reconnect to

00:10:14,779 --> 00:10:19,040
the database every time you reissue a query, mixes in different grammars from

00:10:19,040 --> 00:10:25,529
the different dialects, and creates a client that's used in the schema and normal

00:10:25,529 --> 00:10:27,680
query building, as well as transactions.

00:10:27,680 --> 00:10:30,610
Which I sort of break out entirely, because I'm going to spend a

00:10:30,610 --> 00:10:35,050
little bit of time on those, and on top of that, we have higher level APIs for

00:10:35,050 --> 00:10:39,399
doing some familiar migrations and seeding as you would see for something like

00:10:39,399 --> 00:10:41,040
Rails.

00:10:41,040 --> 00:10:45,100
So how you get started with Knex is just give it a connection string.

00:10:45,100 --> 00:10:47,730
If you want to configure the pool, you can do that.

00:10:47,730 --> 00:10:51,720
And it works against a number of different databases.

00:10:51,720 --> 00:10:53,360
Including Oracle, which is pretty cool.

00:10:53,360 --> 00:10:54,760
Somebody just opened a pull request.

00:10:54,760 --> 00:10:57,079
And it's like -- oh, I don't use Oracle, but it's

00:10:57,079 --> 00:11:00,209
awesome that you opened a pull request.

00:11:00,209 --> 00:11:01,500
Yay, Open Source.

00:11:01,500 --> 00:11:05,070
And it also supports web SQL, but I don't really recommend that,

00:11:05,070 --> 00:11:07,820
because that's deprecated.

00:11:07,820 --> 00:11:11,100
Browsers killed that off.

00:11:11,100 --> 00:11:20,410
So you can select all from accounts, where activated

00:11:20,410 --> 00:11:24,700
is one, and then you call then on it, and it has the familiar promise chaining

00:11:24,700 --> 00:11:29,139
API, so it issues that query and returns the result of the query and then you

00:11:29,139 --> 00:11:34,120
can catch the error if that happens in the standard promise -- it's actually

00:11:34,120 --> 00:11:37,180
great that I don't have to argue too much in favor of promise, now that

00:11:37,180 --> 00:11:38,180
they're actually in the spec.

00:11:38,180 --> 00:11:43,779
But when I was starting out, that was a thing, whether it was -- it was still up for debate

00:11:43,779 --> 00:11:46,339
whether you should use that.

00:11:46,339 --> 00:11:47,560
Also it does joins.

00:11:47,560 --> 00:11:50,529
I don't have to read it out too much, but joins with

00:11:50,529 --> 00:11:55,550
multiple clauses, and then subqueries, so anywhere -- so here we have a where

00:11:55,550 --> 00:12:00,279
in clause, and anywhere you might want to use a subquery, the general rule of

00:12:00,279 --> 00:12:05,079
thumb is that you can pass a function and then use the context of that closure

00:12:05,079 --> 00:12:07,920
as a new subquery.

00:12:07,920 --> 00:12:10,970
And then from there, I'm not going to dive into all the

00:12:10,970 --> 00:12:13,269
features, because that's what documentation is for.

00:12:13,269 --> 00:12:16,100
But you can do raw queries, like if you have a specialized query

00:12:16,100 --> 00:12:17,779
that you don't want to...

00:12:17,779 --> 00:12:19,399
That maybe does some things that aren't supported

00:12:19,399 --> 00:12:26,300
by Knex, you can issue those, aggregates, subquery aliasing, and it tries

00:12:26,300 --> 00:12:28,660
hard not to let you screw up.

00:12:28,660 --> 00:12:31,320
It tries to catch different errors or paper over

00:12:31,320 --> 00:12:35,910
things for you, so you don't make too many mistakes.

00:12:35,910 --> 00:12:38,829
And so the subtitle of the talk, as I mentioned, is

00:12:38,829 --> 00:12:40,029
JavaScript on ACID.

00:12:40,029 --> 00:12:44,420
So this is not the ACID test, which...

00:12:44,420 --> 00:12:47,130
Some are probably familiar with.

00:12:47,130 --> 00:12:50,310
I've mentioned this to someone, and they're like -- oh, you mean the browser

00:12:50,310 --> 00:12:51,310
suite?

00:12:51,310 --> 00:12:52,310
No.

00:12:52,310 --> 00:12:53,310
Let me look that up, though.

00:12:53,310 --> 00:12:57,070
It's good to know that Chrome is passing the ACID 3 test, as of today.

00:12:57,070 --> 00:13:03,980
But I mean atomicity, consistency, isolation, and durability.

00:13:03,980 --> 00:13:06,851
I'm not going to go into each of them, because that

00:13:06,851 --> 00:13:12,950
could be a separate talk about each of the individual terms.

00:13:12,950 --> 00:13:16,050
But transactions -- I sort of sum up that.

00:13:16,050 --> 00:13:18,480
What they do is give you the ability to have a

00:13:18,480 --> 00:13:22,410
snapshot state of the world as you're working with your database.

00:13:22,410 --> 00:13:25,500
So what it allows you to do is roll back to a certain

00:13:25,500 --> 00:13:31,399
point in time, and also prevent other connections that might be working against

00:13:31,399 --> 00:13:35,649
your databases, from altering rows as you're working within a single atomic

00:13:35,649 --> 00:13:38,100
unit of state.

00:13:38,100 --> 00:13:41,470
And this is kind of difficult to do in node.

00:13:41,470 --> 00:13:46,441
You have to think about this API in advance, because in order for this to work, you have

00:13:46,441 --> 00:13:51,160
to have the same database connection passed to every single query that

00:13:51,160 --> 00:13:53,050
you're working against.

00:13:53,050 --> 00:13:55,110
So it's not like in synchronous languages, where you

00:13:55,110 --> 00:13:58,920
could just sort of say -- okay, start transaction here, and then all of these

00:13:58,920 --> 00:14:01,630
will run right here, and then end it right here.

00:14:01,630 --> 00:14:03,190
Because you sort of...

00:14:03,190 --> 00:14:10,050
With the event I/O model, you sort of lose that context as you go with the callback.

00:14:10,050 --> 00:14:11,170
You don't really know what's happening.

00:14:11,170 --> 00:14:16,450
So the connection explicitly has to be passed to every query.

00:14:16,450 --> 00:14:18,900
So let's think about a situation where we would

00:14:18,900 --> 00:14:20,259
actually want to use transactions.

00:14:20,259 --> 00:14:24,740
So here's a simple user flow situation, where someone is registering for a

00:14:24,740 --> 00:14:25,740
website.

00:14:25,740 --> 00:14:28,540
And they register, and you give them an ID and you have to send that

00:14:28,540 --> 00:14:32,790
to a third party service and then you have to create maybe some other rows for

00:14:32,790 --> 00:14:34,950
that user, and then it's all done.

00:14:34,950 --> 00:14:36,399
They're all registered.

00:14:36,399 --> 00:14:40,660
So let's think about what could go wrong in these four steps.

00:14:40,660 --> 00:14:45,220
So first you might depend on a module which doesn't follow semantic versioning.

00:14:45,220 --> 00:14:48,819
So something breaks, and it's completely out of your control, or the third

00:14:48,819 --> 00:14:53,269
party API that you're working against sort of shuts down, and your data

00:14:53,269 --> 00:14:55,140
gets into a bad state.

00:14:55,140 --> 00:14:58,830
So in order to deal with that, then, after step 2, if

00:14:58,830 --> 00:15:02,490
that fails, then you would have to undo what happened in step 1.

00:15:02,490 --> 00:15:08,850
Or in step 3, where you're creating additional rows to deal with that new user, maybe one

00:15:08,850 --> 00:15:12,930
or a few of them failed, so then you have to make sure the ones that did go

00:15:12,930 --> 00:15:17,819
through get rolled back, and then you have to unregister the user, and then

00:15:17,819 --> 00:15:20,160
say -- hey, something messed up.

00:15:20,160 --> 00:15:22,630
And that ends up pushing a lot of logic into your

00:15:22,630 --> 00:15:24,279
application code that you have to deal with.

00:15:24,279 --> 00:15:26,399
All of these potential bad states.

00:15:26,399 --> 00:15:30,029
Or you just don't deal with it, and then you have potentially bad data in your

00:15:30,029 --> 00:15:31,029
application.

00:15:31,029 --> 00:15:34,250
Because you want this whole register user flow to happen as one

00:15:34,250 --> 00:15:36,440
atomic event.

00:15:36,440 --> 00:15:39,140
Or here's another situation that can't be handled by the last

00:15:39,140 --> 00:15:40,140
one.

00:15:40,140 --> 00:15:44,390
Your servers just catch on fire halfway through registering the user.

00:15:44,390 --> 00:15:45,390
And actually...

00:15:45,390 --> 00:15:47,790
I created these libraries so I would one day have the ability to

00:15:47,790 --> 00:15:50,480
use this graphic in a keynote.

00:15:50,480 --> 00:15:51,730
No.

00:15:51,730 --> 00:15:52,970
But...

00:15:52,970 --> 00:15:59,220
So what Knex tries to do is you can say Knex transaction, and then it creates

00:15:59,220 --> 00:16:04,130
an instance that you treat as a normal query builder instance, but it knows

00:16:04,130 --> 00:16:08,380
what it's supposed to be on and the fact that it's inside an transaction.

00:16:08,380 --> 00:16:13,069
So you can pass that to other functions that can utilize it and work with

00:16:13,069 --> 00:16:18,700
it as if it's a normal API, but behind the scenes, you have a transaction

00:16:18,700 --> 00:16:20,420
that you're dealing with.

00:16:20,420 --> 00:16:23,319
And originally, the API was that you would just

00:16:23,319 --> 00:16:26,910
have to pass this explicitly to every single query that you built.

00:16:26,910 --> 00:16:31,230
So you had the transaction object, and then you could call commit or rollback at the very

00:16:31,230 --> 00:16:32,230
end.

00:16:32,230 --> 00:16:35,810
But that seemed to be kind of error-prone, that users would sort of forget

00:16:35,810 --> 00:16:39,949
to pass it to every single query necessary, and then they would have

00:16:39,949 --> 00:16:44,690
sort of queries not working on the same connection, and it caused all sorts of

00:16:44,690 --> 00:16:45,690
errors.

00:16:45,690 --> 00:16:46,740
So this is the new API.

00:16:46,740 --> 00:16:51,899
And like I said, Knex tries to make it hard to screw up, I guess.

00:16:51,899 --> 00:16:55,310
And so this is a little boilerplate here -- every time

00:16:55,310 --> 00:17:00,220
we call commit and roll back, this is a promise, and then we return the promise

00:17:00,220 --> 00:17:04,940
into the transaction, and we know if the entire promise chain fulfills, the

00:17:04,940 --> 00:17:09,140
transaction should be committed, and if it fails, the transaction should be rolled

00:17:09,140 --> 00:17:10,140
back.

00:17:10,140 --> 00:17:11,400
So that's pretty simple.

00:17:11,400 --> 00:17:13,069
Nesting transactions is new.

00:17:13,069 --> 00:17:15,140
And it's the idea that you shouldn't have to

00:17:15,140 --> 00:17:19,309
worry about whether the client is already inside a transaction.

00:17:19,309 --> 00:17:24,100
So if you call Knex transaction on something that is already

00:17:24,100 --> 00:17:28,310
a transaction Knex, it should just create a save point.

00:17:28,310 --> 00:17:31,030
And so a save point is sort of like a save point in,

00:17:31,030 --> 00:17:32,030
like, a video game.

00:17:32,030 --> 00:17:34,100
Where you get to a certain point, and if something fails

00:17:34,100 --> 00:17:37,480
beyond that, you don't go back to the very beginning, but you go back to just

00:17:37,480 --> 00:17:39,150
right here.

00:17:39,150 --> 00:17:41,320
And so it does this transparently.

00:17:41,320 --> 00:17:43,340
You know, for you.

00:17:43,340 --> 00:17:47,490
And you don't have to worry about it too much.

00:17:47,490 --> 00:17:51,770
So Knex likes to take what I call the batteries included approach, where it does a lot of

00:17:51,770 --> 00:17:56,390
this for you, and also provides a lot of different interfaces, like callbacks

00:17:56,390 --> 00:18:01,150
and streams and events, and two string -- the different things you would want

00:18:01,150 --> 00:18:04,790
to work with in a nice manner.

00:18:04,790 --> 00:18:07,020
So that's pretty much just a high level overview of Knex.

00:18:07,020 --> 00:18:08,970
And now I'm going to jump into bookshelf.

00:18:08,970 --> 00:18:13,670
Which is an ORM, which stands for object relational mapper.

00:18:13,670 --> 00:18:17,850
And in short what that tries to do is take care of standard SQL

00:18:17,850 --> 00:18:20,890
queries for you, especially in common app operations.

00:18:20,890 --> 00:18:24,250
So when you're building an app, there's a lot of things that are pretty

00:18:24,250 --> 00:18:25,250
standard.

00:18:25,250 --> 00:18:31,080
Like insert, return, fetch, save, dealing with -- relating different

00:18:31,080 --> 00:18:34,370
rows of data.

00:18:34,370 --> 00:18:36,559
And you don't want to have to write all of this by hand.

00:18:36,559 --> 00:18:39,990
So it sort of abstracts that a little bit for you, and takes a little bit

00:18:39,990 --> 00:18:46,070
of the flexibility away, but gives you a nicer, higher level piece to work with.

00:18:46,070 --> 00:18:49,990
So the different association types -- pretty familiar if you've ever worked

00:18:49,990 --> 00:18:52,630
with an ORM in another language.

00:18:52,630 --> 00:18:54,680
One to one, one to many, many to many.

00:18:54,680 --> 00:18:58,701
Polymorphic -- I don't know if these are necessarily a great idea, but

00:18:58,701 --> 00:19:00,120
sometimes they can be useful, I guess.

00:19:00,120 --> 00:19:01,800
So it supports those.

00:19:01,800 --> 00:19:03,010
And it builds on top of Knex.

00:19:03,010 --> 00:19:05,330
So that's where I was talking about having a separation between

00:19:05,330 --> 00:19:07,980
a query building layer and an ORM layer.

00:19:07,980 --> 00:19:11,130
You should be able to write raw SQL when you want and have

00:19:11,130 --> 00:19:16,000
something that works on top of that and also allows you to drop back into it

00:19:16,000 --> 00:19:17,580
when you need.

00:19:17,580 --> 00:19:20,480
So this is sort of what it looks like, to create a few models

00:19:20,480 --> 00:19:22,679
with associations.

00:19:22,679 --> 00:19:26,600
And you can also sort of filter with...

00:19:26,600 --> 00:19:29,520
So here we have comments, which is has many to a comment,

00:19:29,520 --> 00:19:36,370
but we also have moderated comments, and we can add in the where-moderated is true.

00:19:36,370 --> 00:19:42,539
And it also supports loading where you're trying to add data to a collection

00:19:42,539 --> 00:19:48,450
of data, if you have 26 items, you have 26 extra queries, so it tries to

00:19:48,450 --> 00:19:52,710
do one and then another query for the extra related results.

00:19:52,710 --> 00:19:56,020
An example here is to find an account with all the

00:19:56,020 --> 00:20:00,390
posts in the account, and then all the comments under those posts and all the

00:20:00,390 --> 00:20:04,880
accounts that actually made the comments on the posts for the account.

00:20:04,880 --> 00:20:09,100
So that's what that it would look like, to provide

00:20:09,100 --> 00:20:12,380
with-related, and this is all in the documentation.

00:20:12,380 --> 00:20:16,240
So I'm going to jump through this a little bit.

00:20:16,240 --> 00:20:23,460
Also, as you constrain your loads, you can dynamically constrain relations,

00:20:23,460 --> 00:20:25,110
and then load things after the fact.

00:20:25,110 --> 00:20:29,860
So if you want to fetch one row or a collection of rows and then only load onto

00:20:29,860 --> 00:20:33,380
one, it allows you to do that as well.

00:20:33,380 --> 00:20:37,630
And then as I was mentioning earlier, it allows you to tap into the

00:20:37,630 --> 00:20:40,880
query chain, to dynamically add things that are maybe a little more

00:20:40,880 --> 00:20:46,520
SQL-specific under the hood, as you're building the select statement or other

00:20:46,520 --> 00:20:49,630
statements for the model.

00:20:49,630 --> 00:20:52,440
And so transactions in bookshelf aren't quite where

00:20:52,440 --> 00:20:56,460
they are in Knex, where you still have to pass the explicit object to each of

00:20:56,460 --> 00:20:58,390
the async calls.

00:20:58,390 --> 00:21:00,660
Turns out it's a little harder to retrofit that, where you

00:21:00,660 --> 00:21:02,950
have a transactional bookshelf object.

00:21:02,950 --> 00:21:05,501
That's where it's going in the future.

00:21:05,501 --> 00:21:09,900
But transactions are absolutely supported in bookshelf.

00:21:09,900 --> 00:21:12,720
And just a little bit of where bookshelf sort of came from -- I

00:21:12,720 --> 00:21:18,070
mentioned that it came from some of the ideas from backbone models and collections.

00:21:18,070 --> 00:21:21,770
And ultimately the idea was to see if we could reuse some of the same models

00:21:21,770 --> 00:21:24,140
on the server and client.

00:21:24,140 --> 00:21:26,340
And this was back in, like, 2012, back before

00:21:26,340 --> 00:21:29,860
I even knew there was a term for doing this.

00:21:29,860 --> 00:21:31,110
Which I'm not going to say.

00:21:31,110 --> 00:21:35,680
Because he already covered it last year.

00:21:35,680 --> 00:21:36,740
And I actually sort of got there.

00:21:36,740 --> 00:21:41,770
I was able to swap out bookshelf models and collections for, like, the backbone TodoMVC

00:21:41,770 --> 00:21:44,360
and use it targeting webSQL.

00:21:44,360 --> 00:21:46,360
Which was kind of cool.

00:21:46,360 --> 00:21:47,789
I don't know.

00:21:47,789 --> 00:21:50,159
I built a to-do list.

00:21:50,159 --> 00:21:52,070
And that's pretty special.

00:21:52,070 --> 00:21:56,010
But really, I think, shared models sound great, but it's not really

00:21:56,010 --> 00:22:00,820
as great in practice, because you have to know a lot more -- or there's sort

00:22:00,820 --> 00:22:02,159
of a limit to what you can do.

00:22:02,159 --> 00:22:06,130
You have to load all the data, and lose out on

00:22:06,130 --> 00:22:07,169
a lot.

00:22:07,169 --> 00:22:10,890
Because you don't need as much of what you would need on the server on

00:22:10,890 --> 00:22:12,650
the client, if you're just displaying it.

00:22:12,650 --> 00:22:13,650
So it sounds great.

00:22:13,650 --> 00:22:14,650
Not as great in practice.

00:22:14,650 --> 00:22:17,150
And it's something that I'm sort of moving away from, some of the

00:22:17,150 --> 00:22:22,630
model and collection conventions from backbone, based on some of the things

00:22:22,630 --> 00:22:26,040
that I've learned, having been out there for a little while.

00:22:26,040 --> 00:22:27,059
So you can read more in the docs.

00:22:27,059 --> 00:22:29,630
I'm not going to go too much further into it.

00:22:29,630 --> 00:22:31,600
But I think one thing I would like to point out is that

00:22:31,600 --> 00:22:34,490
Knex and bookshelf are not the first to do this.

00:22:34,490 --> 00:22:38,460
So I mentioned earlier there was already higher level SQL

00:22:38,460 --> 00:22:41,770
abstractions in JavaScript that I saw, and I was like -- oh, I'll build these

00:22:41,770 --> 00:22:42,990
instead.

00:22:42,990 --> 00:22:44,460
And hopefully it's not the last to do this.

00:22:44,460 --> 00:22:49,220
So a few other projects -- openrecord is a really great project that's

00:22:49,220 --> 00:22:54,200
using Knex under the hood, and it provides more of an active record syntax.

00:22:54,200 --> 00:22:58,900
And SQLize is the big one, and is still a big one.

00:22:58,900 --> 00:23:01,710
And it didn't have support for transactions.

00:23:01,710 --> 00:23:03,789
It had a really...

00:23:03,789 --> 00:23:05,480
The APIs were sort of rough.

00:23:05,480 --> 00:23:07,330
And since then, it's come a long way.

00:23:07,330 --> 00:23:09,929
I've been really impressed with a lot of the development happening with

00:23:09,929 --> 00:23:10,929
SQLize.

00:23:10,929 --> 00:23:13,490
So if you haven't looked at it for a while, take another look.

00:23:13,490 --> 00:23:16,530
They're doing cool things, especially around the new

00:23:16,530 --> 00:23:20,930
postgres features that are coming out.

00:23:20,930 --> 00:23:25,740
A new one that I just saw recently, by someone who had been frequently

00:23:25,740 --> 00:23:30,830
commenting on bookshelf and Knex projects, and I guess maybe had some opinions

00:23:30,830 --> 00:23:34,270
that were different, created this Zuul.JS.

00:23:34,270 --> 00:23:36,110
And it's really impressive.

00:23:36,110 --> 00:23:39,179
It does transactions, doesn't have quite the separation

00:23:39,179 --> 00:23:43,750
between the query building and the ORM layer, but does a lot for you at the

00:23:43,750 --> 00:23:44,750
ORM layer.

00:23:44,750 --> 00:23:46,890
That's worth checking out.

00:23:46,890 --> 00:23:52,010
SQL bricks is pretty similar to Knex, but with different opinions.

00:23:52,010 --> 00:23:58,720
NodeSQL, by the guy who does the postgres driver.

00:23:58,720 --> 00:24:04,610
Even the drivers have come a long way since I looked at them in 2012.

00:24:04,610 --> 00:24:10,960
The node my SQL driver has a ton of documentation and a lot of features added.

00:24:10,960 --> 00:24:17,779
It's really impressive how far it's come in the last few years.

00:24:17,779 --> 00:24:19,890
Knex query lab allows you to demo this in the

00:24:19,890 --> 00:24:22,450
browser and have it spit out SQL.

00:24:22,450 --> 00:24:28,630
Bookends does nested data loading and querying really well.

00:24:28,630 --> 00:24:30,580
It's on top of bookshelf.

00:24:30,580 --> 00:24:38,620
And there's endpoints, a JSON API compliant library, which has Knex and

00:24:38,620 --> 00:24:44,409
bookshelf under the hood, and larger stack implementations like Sails, which has

00:24:44,409 --> 00:24:48,370
their own ORM, but they were potentially talking about using Knex as the

00:24:48,370 --> 00:24:50,500
query builder under the hood.

00:24:50,500 --> 00:24:55,830
So they're targeting all the different SQL drivers.

00:24:55,830 --> 00:24:57,130
That's just some of what's out there.

00:24:57,130 --> 00:24:59,540
But I really don't think this is enough.

00:24:59,540 --> 00:25:00,610
So...

00:25:00,610 --> 00:25:01,669
We're still sort of like...

00:25:01,669 --> 00:25:06,130
At this stage where node is a really young ecosystem.

00:25:06,130 --> 00:25:08,340
And a lot of times, you'll hear -- don't reinvent the wheel.

00:25:08,340 --> 00:25:09,730
Like it's already been done.

00:25:09,730 --> 00:25:11,140
But I sort of disagree with this.

00:25:11,140 --> 00:25:14,669
I think that people should absolutely be reinventing the wheel.

00:25:14,669 --> 00:25:17,169
With an asterisk.

00:25:17,169 --> 00:25:18,600
Just not on the client side.

00:25:18,600 --> 00:25:20,870
Because React already did this.

00:25:20,870 --> 00:25:22,870
No, I'm kidding there.

00:25:22,870 --> 00:25:26,300
But, like, we should have more experiments out there, because I think the

00:25:26,300 --> 00:25:30,950
types of conversations we're having since React are really different, about...

00:25:30,950 --> 00:25:32,690
Just the web in general.

00:25:32,690 --> 00:25:35,620
Because they questioned a lot of opinions.

00:25:35,620 --> 00:25:38,710
So I think that -- take a look at other libraries.

00:25:38,710 --> 00:25:39,940
Take a look at other languages.

00:25:39,940 --> 00:25:42,679
Which is what -- you know, a lot of what JavaScript

00:25:42,679 --> 00:25:43,679
is about.

00:25:43,679 --> 00:25:46,669
JavaScript is sort of late to the party of being on the server.

00:25:46,669 --> 00:25:54,090
And a lot of the great ideas coming out around async and ES7 and ES8 are looking

00:25:54,090 --> 00:25:55,980
at the best of what's around in other languages.

00:25:55,980 --> 00:25:58,940
So I think it's really important -- like, as I mentioned,

00:25:58,940 --> 00:26:04,179
these were adapted from the Laravel query builder in PHP, and I would like to

00:26:04,179 --> 00:26:11,570
move a lot further toward SQL Alchemy and query builder.

00:26:11,570 --> 00:26:18,640
But I would love to see node become more of a target for traditional

00:26:18,640 --> 00:26:20,970
web applications.

00:26:20,970 --> 00:26:25,391
Prove that Stack Overflow question wrong, and get more

00:26:25,391 --> 00:26:31,179
awareness out there, that you can do this type of boring traditional website

00:26:31,179 --> 00:26:37,960
development in node, and I think the more that that becomes something that's

00:26:37,960 --> 00:26:41,770
well known, the more people will be writing JavaScript, and then more goes

00:26:41,770 --> 00:26:42,770
into the ecosystem.

00:26:42,770 --> 00:26:45,580
So that was sort of the goal of creating these two libraries,

00:26:45,580 --> 00:26:48,530
to sort of say -- hey, you can do this.

00:26:48,530 --> 00:26:54,759

YouTube URL: https://www.youtube.com/watch?v=19Av0Lxml-I


