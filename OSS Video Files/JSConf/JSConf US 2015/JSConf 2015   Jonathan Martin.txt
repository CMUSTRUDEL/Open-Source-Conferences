Title: JSConf 2015   Jonathan Martin
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	
Captions: 
	00:00:13,970 --> 00:00:17,910
so you all see this big link on here

00:00:16,650 --> 00:00:19,800
hopefully you can see it in the back of

00:00:17,910 --> 00:00:22,430
the room this is just a gotomeeting that

00:00:19,800 --> 00:00:24,180
will show you guys the code and the

00:00:22,430 --> 00:00:25,590
slides and stuff that I will be going

00:00:24,180 --> 00:00:27,210
through this is so you all can hopefully

00:00:25,590 --> 00:00:30,180
see it because I'm going to be in them

00:00:27,210 --> 00:00:31,230
for about 25 minutes of this and it

00:00:30,180 --> 00:00:32,579
might be a little bit on the small side

00:00:31,230 --> 00:00:34,620
so if you're having trouble seeing the

00:00:32,579 --> 00:00:38,370
screens feel free to hop into this its

00:00:34,620 --> 00:00:40,050
tiny URL com / you to dash can dash

00:00:38,370 --> 00:00:42,030
believe it's gotomeeting just put it in

00:00:40,050 --> 00:00:43,800
your name and it will pop up go to

00:00:42,030 --> 00:00:44,640
meeting some of your web developers and

00:00:43,800 --> 00:00:46,590
saying I don't want to install

00:00:44,640 --> 00:00:48,390
gotomeeting that's okay I understand

00:00:46,590 --> 00:00:50,820
that just if you don't mind straining

00:00:48,390 --> 00:00:54,330
your eyes so thanks for coming out to my

00:00:50,820 --> 00:00:56,730
talk where I hope that with this one

00:00:54,330 --> 00:00:59,190
weird way to rewrite closures I can

00:00:56,730 --> 00:01:02,310
restore your faith in native JavaScript

00:00:59,190 --> 00:01:03,960
closures the rest of this time don't

00:01:02,310 --> 00:01:06,270
believe anything I say that is my only

00:01:03,960 --> 00:01:07,290
caveat so with that before we get into

00:01:06,270 --> 00:01:09,150
the mind blowing business I'll tell you

00:01:07,290 --> 00:01:10,979
just a quick little bit about myself I'm

00:01:09,150 --> 00:01:13,920
Jonathan Martin I work at the big nerd

00:01:10,979 --> 00:01:15,990
ranch up in Atlanta Georgia and I work

00:01:13,920 --> 00:01:17,640
as a backing in front end developer and

00:01:15,990 --> 00:01:19,470
also as an instructor if you happen to

00:01:17,640 --> 00:01:21,030
be up near the Atlanta campus we'd love

00:01:19,470 --> 00:01:23,820
to have you we probably have some swag

00:01:21,030 --> 00:01:26,220
at the end of this talk Todd in myself

00:01:23,820 --> 00:01:27,930
who also works at big nerd ranch at the

00:01:26,220 --> 00:01:29,700
front table we will be out at one of the

00:01:27,930 --> 00:01:31,409
booths or tables out there if you're

00:01:29,700 --> 00:01:33,630
interested in getting any koozies or

00:01:31,409 --> 00:01:36,450
nerdy glasses any of that stuff we have

00:01:33,630 --> 00:01:37,800
it all so everyone nowadays when they

00:01:36,450 --> 00:01:39,810
talk about JavaScript they talk about

00:01:37,800 --> 00:01:41,580
scopes and closures as being the big

00:01:39,810 --> 00:01:43,409
thing that make JavaScript so powerful

00:01:41,580 --> 00:01:45,090
but really for years people have

00:01:43,409 --> 00:01:46,940
survived without this memory intensive

00:01:45,090 --> 00:01:49,500
complication on the JavaScript runtime

00:01:46,940 --> 00:01:52,110
anytime you need to avoid variable name

00:01:49,500 --> 00:01:54,060
shadowing or global or any kind of

00:01:52,110 --> 00:01:55,860
variable name collisions all you needed

00:01:54,060 --> 00:01:58,260
to do was use unique global variable

00:01:55,860 --> 00:02:00,930
names maybe you prefix your variable

00:01:58,260 --> 00:02:02,640
names with some unknown unheard-of

00:02:00,930 --> 00:02:04,860
function name there's all kinds of

00:02:02,640 --> 00:02:07,830
techniques people used so the example I

00:02:04,860 --> 00:02:10,229
give first of all his Fortran Fortran

00:02:07,830 --> 00:02:12,060
introduced in 1957 that was back when a

00:02:10,229 --> 00:02:14,159
corrupted computer program probably

00:02:12,060 --> 00:02:16,260
meant you got mustard or something on

00:02:14,159 --> 00:02:17,849
your punch card Oh nowadays we don't

00:02:16,260 --> 00:02:20,700
have that excuse for corrupted program

00:02:17,849 --> 00:02:22,530
but considering that we still to this

00:02:20,700 --> 00:02:25,000
day rely on all these super optimized

00:02:22,530 --> 00:02:26,500
mouth algorithms that are written in

00:02:25,000 --> 00:02:28,840
Tran I'd say they did pretty well

00:02:26,500 --> 00:02:32,710
without any sort of local variables or

00:02:28,840 --> 00:02:34,270
closures then x86 assembly 1978 in my

00:02:32,710 --> 00:02:35,860
opinion one of the first real languages

00:02:34,270 --> 00:02:37,360
because you could write hello world and

00:02:35,860 --> 00:02:39,460
other insignificant things like

00:02:37,360 --> 00:02:41,830
operating systems in it they did all

00:02:39,460 --> 00:02:43,810
this just fine without any concept of

00:02:41,830 --> 00:02:45,610
closures or local variables all that's

00:02:43,810 --> 00:02:48,760
just kind of modern propaganda that gets

00:02:45,610 --> 00:02:50,920
thrown at us all day even ruby ruby was

00:02:48,760 --> 00:02:52,390
introduced in 1995 and we all know it

00:02:50,920 --> 00:02:54,580
really just came as a last ditch effort

00:02:52,390 --> 00:02:56,350
to save object-oriented programming in

00:02:54,580 --> 00:02:58,060
the wake of the closure craze well

00:02:56,350 --> 00:02:59,830
thanks to Ruby object-oriented

00:02:58,060 --> 00:03:01,959
programming apparently lives on and

00:02:59,830 --> 00:03:04,360
people still right things with classes

00:03:01,959 --> 00:03:06,820
instead of closures which is totally the

00:03:04,360 --> 00:03:09,280
way to do it nowadays but apparently

00:03:06,820 --> 00:03:10,900
that's frowned upon by Twitter so to the

00:03:09,280 --> 00:03:12,280
point you don't actually need closures

00:03:10,900 --> 00:03:15,730
or local variables or any of that

00:03:12,280 --> 00:03:17,230
nonsense however closures 10 because

00:03:15,730 --> 00:03:18,970
they were attacked on at the last minute

00:03:17,230 --> 00:03:21,160
into JavaScript they're slower than a

00:03:18,970 --> 00:03:23,680
java GUI so we spend most of our time

00:03:21,160 --> 00:03:25,239
waiting for closures to execute we have

00:03:23,680 --> 00:03:26,709
the sink called function overhead

00:03:25,239 --> 00:03:28,870
because it's got to initialize all these

00:03:26,709 --> 00:03:31,060
variables on a stack all this nonsense

00:03:28,870 --> 00:03:32,290
attached the functions when really it

00:03:31,060 --> 00:03:33,940
would be so much faster if we could do

00:03:32,290 --> 00:03:38,140
this all on the heat all at runtime

00:03:33,940 --> 00:03:39,850
dynamically so typically when we want to

00:03:38,140 --> 00:03:42,130
improve these sorts of things we rewrite

00:03:39,850 --> 00:03:43,989
them so reacts virtual Dom comes to mind

00:03:42,130 --> 00:03:45,730
it completely rewrote the DOM and

00:03:43,989 --> 00:03:47,769
completely replaces it so you don't need

00:03:45,730 --> 00:03:50,860
the Dom anymore and it makes everything

00:03:47,769 --> 00:03:52,930
so much faster well what if we did the

00:03:50,860 --> 00:03:57,489
same thing with closures because who

00:03:52,930 --> 00:04:01,420
here has used the closure who here has

00:03:57,489 --> 00:04:02,709
used local variables so you guys are

00:04:01,420 --> 00:04:04,660
probably plaguing ninety-nine point nine

00:04:02,709 --> 00:04:06,280
percent of your code with this memory

00:04:04,660 --> 00:04:08,290
intensive complication on the runtime

00:04:06,280 --> 00:04:09,760
engine it's all nonsense back in the day

00:04:08,290 --> 00:04:12,610
we just use global variables which

00:04:09,760 --> 00:04:13,870
really just registers registers are

00:04:12,610 --> 00:04:15,790
about as fast as you can get it's only

00:04:13,870 --> 00:04:17,410
one or two machine instructions away so

00:04:15,790 --> 00:04:19,600
to address the underlying performance

00:04:17,410 --> 00:04:22,600
problems in JavaScript we just need to

00:04:19,600 --> 00:04:24,130
replace it entirely ourselves and we're

00:04:22,600 --> 00:04:25,690
going to rewrite it all by yourself and

00:04:24,130 --> 00:04:27,610
by the way this will also give us a

00:04:25,690 --> 00:04:29,890
chance to completely redo the syntax

00:04:27,610 --> 00:04:32,350
because I mean really who remembers the

00:04:29,890 --> 00:04:34,690
VAR keyword every time without days

00:04:32,350 --> 00:04:37,270
hence not-so-subtle products so in the

00:04:34,690 --> 00:04:38,560
spirit of IE compatibility modes we are

00:04:37,270 --> 00:04:40,000
going to develop our own

00:04:38,560 --> 00:04:42,700
we fill for those clouds your closure

00:04:40,000 --> 00:04:44,169
bounds developer friends of ours who are

00:04:42,700 --> 00:04:46,419
still stuck in all this pure function

00:04:44,169 --> 00:04:47,770
and Y Combinator propaganda who knows

00:04:46,419 --> 00:04:50,200
where it came from and we're going to

00:04:47,770 --> 00:04:53,020
bring them back to the simplicity of

00:04:50,200 --> 00:04:55,180
global variables and registers all in

00:04:53,020 --> 00:04:56,770
JavaScript now before we go on this

00:04:55,180 --> 00:04:58,120
little journey we do have some rules we

00:04:56,770 --> 00:05:00,550
have to follow otherwise it would just

00:04:58,120 --> 00:05:02,650
be a free-for-all so any code that is

00:05:00,550 --> 00:05:04,990
going to be using this polyfill has to

00:05:02,650 --> 00:05:07,240
do five things first off it is not

00:05:04,990 --> 00:05:09,310
allowed to use any native local

00:05:07,240 --> 00:05:11,260
variables it is not allowed to use

00:05:09,310 --> 00:05:14,860
native local variable assignment or

00:05:11,260 --> 00:05:16,720
create functions with parameters or any

00:05:14,860 --> 00:05:18,729
sort arguments now those of you who are

00:05:16,720 --> 00:05:20,650
used to doing parameters it's really

00:05:18,729 --> 00:05:22,150
just local variables after all inside

00:05:20,650 --> 00:05:24,550
the function that get bound to some

00:05:22,150 --> 00:05:26,110
value so that's the local variable in

00:05:24,550 --> 00:05:28,150
and of itself will still have slow

00:05:26,110 --> 00:05:30,729
functions so we're going to nuke all of

00:05:28,150 --> 00:05:33,100
that you can't do any of that in your

00:05:30,729 --> 00:05:35,610
coat however the implementation as we

00:05:33,100 --> 00:05:38,410
will see is allowed to use some of those

00:05:35,610 --> 00:05:41,229
second you may not attach any data

00:05:38,410 --> 00:05:43,630
directly to a function object know sort

00:05:41,229 --> 00:05:46,690
of memoization no cache objects none of

00:05:43,630 --> 00:05:49,150
that functions are going to be a music

00:05:46,690 --> 00:05:51,700
or the terminology we'll see as a music

00:05:49,150 --> 00:05:54,190
function body we are allowed to do a few

00:05:51,700 --> 00:05:57,490
things we are allowed to access that one

00:05:54,190 --> 00:05:59,350
weird global variable and then we can

00:05:57,490 --> 00:06:01,360
use a music function bodies just to wrap

00:05:59,350 --> 00:06:02,919
around buckets of code again these

00:06:01,360 --> 00:06:04,510
buckets of code are not allowed to use

00:06:02,919 --> 00:06:06,490
local variables of any sort or

00:06:04,510 --> 00:06:07,810
parameters so I call them in music

00:06:06,490 --> 00:06:09,520
because they don't remember anything

00:06:07,810 --> 00:06:10,900
about their scoping rules which are

00:06:09,520 --> 00:06:13,000
built into JavaScript they're not

00:06:10,900 --> 00:06:15,070
allowed to do any of that so they will

00:06:13,000 --> 00:06:17,410
be a music just buckets of statements

00:06:15,070 --> 00:06:19,090
and then finally just to make things a

00:06:17,410 --> 00:06:21,010
little bit shorter for demo you are

00:06:19,090 --> 00:06:22,840
allowed to use shortcut local variables

00:06:21,010 --> 00:06:24,820
that will give you access to a few

00:06:22,840 --> 00:06:26,650
functions as we will see later on

00:06:24,820 --> 00:06:28,330
because they could just be expanded to

00:06:26,650 --> 00:06:29,770
the full global variable name some of

00:06:28,330 --> 00:06:31,780
you may remember this convention if you

00:06:29,770 --> 00:06:32,889
watch programming with nothing you

00:06:31,780 --> 00:06:35,020
mentioned at the beginning of the talk

00:06:32,889 --> 00:06:37,389
so that takes a similar convention where

00:06:35,020 --> 00:06:39,010
you can use constants just to simplify

00:06:37,389 --> 00:06:41,289
the code but at the end it can all be

00:06:39,010 --> 00:06:43,479
collapsed and not even use any sort of

00:06:41,289 --> 00:06:45,520
local variable names so we're going to

00:06:43,479 --> 00:06:46,810
do all that so with these rules we're

00:06:45,520 --> 00:06:49,000
going to make substitutions like this

00:06:46,810 --> 00:06:51,130
the first line you see is VAR local

00:06:49,000 --> 00:06:52,360
equals some value this is going to be

00:06:51,130 --> 00:06:55,060
replaced with

00:06:52,360 --> 00:06:56,710
mysterious function called s as for set

00:06:55,060 --> 00:06:58,689
it will take in the name of a local

00:06:56,710 --> 00:07:02,229
variable to which we want to assign and

00:06:58,689 --> 00:07:03,879
then that value so s will exactly

00:07:02,229 --> 00:07:05,800
replace the variable assignment we're

00:07:03,879 --> 00:07:09,009
used to anytime we want to do a lookup

00:07:05,800 --> 00:07:10,330
we call g which is 4g forget which takes

00:07:09,009 --> 00:07:12,250
in the name of the local variable and

00:07:10,330 --> 00:07:14,139
just returns the value in the current

00:07:12,250 --> 00:07:16,120
scope exactly the same as variable look

00:07:14,139 --> 00:07:18,340
up and anytime we have a function

00:07:16,120 --> 00:07:19,870
expression assigned to a variable we

00:07:18,340 --> 00:07:22,389
will replace all of that with a call to

00:07:19,870 --> 00:07:24,009
F F takes in the name of the local

00:07:22,389 --> 00:07:26,169
variable to which we would be assigning

00:07:24,009 --> 00:07:28,240
this function the list of parameters as

00:07:26,169 --> 00:07:30,400
an array and then that amnesic function

00:07:28,240 --> 00:07:32,529
body notice that the function body has

00:07:30,400 --> 00:07:34,689
no parameters it's not allowed to do

00:07:32,529 --> 00:07:38,919
this we're just using functions as a way

00:07:34,689 --> 00:07:39,969
to wrap around a bunch of code so with

00:07:38,919 --> 00:07:41,800
this in mind we're going to take an

00:07:39,969 --> 00:07:44,110
example that looks like this this is a

00:07:41,800 --> 00:07:46,360
canonical example of how closures work

00:07:44,110 --> 00:07:47,740
in JavaScript in this case we have an

00:07:46,360 --> 00:07:49,509
outer function which when invoked

00:07:47,740 --> 00:07:52,539
returns an inner function which when

00:07:49,509 --> 00:07:55,270
invoked prints out the values of x y and

00:07:52,539 --> 00:07:58,120
z now the prudent among you will notice

00:07:55,270 --> 00:08:00,190
that the inner function shadows the x

00:07:58,120 --> 00:08:01,930
variable of the outer one so if you were

00:08:00,190 --> 00:08:04,120
to evaluate what that bottom statement

00:08:01,930 --> 00:08:06,490
would run it would execute outer passing

00:08:04,120 --> 00:08:08,169
in 1 and 2 and inner passing in three

00:08:06,490 --> 00:08:11,050
and four and you should get an output of

00:08:08,169 --> 00:08:14,229
3 comma 2 comma 4 because it prints out

00:08:11,050 --> 00:08:17,289
X and X is shadowed so the second time

00:08:14,229 --> 00:08:18,940
we pass in the value of x into the inner

00:08:17,289 --> 00:08:21,189
function that's going to be what gets

00:08:18,940 --> 00:08:24,639
printed so remember the output of this

00:08:21,189 --> 00:08:25,990
should be 3 comma 2 comma 4 and with our

00:08:24,639 --> 00:08:27,580
little transformation we saw in the last

00:08:25,990 --> 00:08:29,080
slide we're going to make this look so

00:08:27,580 --> 00:08:32,740
much better we're going to replace it

00:08:29,080 --> 00:08:35,589
with this will call our f function or g

00:08:32,740 --> 00:08:37,149
function in our s function so notice in

00:08:35,589 --> 00:08:38,919
here there is no reference to native

00:08:37,149 --> 00:08:41,409
local variables or functions with

00:08:38,919 --> 00:08:43,690
parameters all we have are those three

00:08:41,409 --> 00:08:45,519
setter getter and function helpers so

00:08:43,690 --> 00:08:48,220
bear this in mind as we start developing

00:08:45,519 --> 00:08:49,690
it because the next step is to in 70

00:08:48,220 --> 00:08:51,550
lines of code we're going to

00:08:49,690 --> 00:08:55,240
re-implement this and all will be

00:08:51,550 --> 00:08:56,260
exposing our that s f and g functions so

00:08:55,240 --> 00:08:58,060
at this point i'm going to move to

00:08:56,260 --> 00:09:01,019
something very risky we're going to live

00:08:58,060 --> 00:09:01,019
code this in them

00:09:03,529 --> 00:09:16,290
first difficulty we will face is getting

00:09:05,939 --> 00:09:18,809
this large enough to see I need another

00:09:16,290 --> 00:09:21,240
screen so if you guys can't read this

00:09:18,809 --> 00:09:22,889
especially as you get back a few rows go

00:09:21,240 --> 00:09:24,839
ahead and go a launch up that

00:09:22,889 --> 00:09:27,029
gotomeeting I know it's a plug-in who

00:09:24,839 --> 00:09:29,309
wants a plug-in but WebRTC won't work on

00:09:27,029 --> 00:09:31,410
these firewalls unfortunately so you

00:09:29,309 --> 00:09:32,819
should be able to follow along then so

00:09:31,410 --> 00:09:34,860
I'm going to be taking a test driven

00:09:32,819 --> 00:09:36,629
approach to doing all this which means

00:09:34,860 --> 00:09:38,730
I've cheated before hand I've written

00:09:36,629 --> 00:09:40,529
out all these specs which describe this

00:09:38,730 --> 00:09:43,410
behavior that I want out of this i'm

00:09:40,529 --> 00:09:44,370
using mocha and chai okay i have not yet

00:09:43,410 --> 00:09:46,649
been instructed on the proper

00:09:44,370 --> 00:09:48,360
pronunciation so first off we're going

00:09:46,649 --> 00:09:50,339
to look at how a scope should work for a

00:09:48,360 --> 00:09:51,990
global context so whenever you think

00:09:50,339 --> 00:09:54,540
about scopes we're thinking about local

00:09:51,990 --> 00:09:56,610
variables back in the days of x86 and

00:09:54,540 --> 00:09:58,199
fortran all you had was the global scope

00:09:56,610 --> 00:10:00,480
variables that can be accessed from

00:09:58,199 --> 00:10:02,249
anywhere in your program so it's very

00:10:00,480 --> 00:10:04,199
easy to describe these so let me walk

00:10:02,249 --> 00:10:05,550
you through it first off we have a

00:10:04,199 --> 00:10:08,490
little bit of setup functionality for

00:10:05,550 --> 00:10:10,230
every test we create a scope object this

00:10:08,490 --> 00:10:11,850
scope object is going to be responsible

00:10:10,230 --> 00:10:14,220
for keeping track of local variables

00:10:11,850 --> 00:10:17,100
that have been created along with the

00:10:14,220 --> 00:10:19,259
values that are set to now again here

00:10:17,100 --> 00:10:21,870
are our shortcut functions which is just

00:10:19,259 --> 00:10:24,480
mapping s to the set function on scope

00:10:21,870 --> 00:10:26,069
and G to the get function on scope these

00:10:24,480 --> 00:10:27,720
are just shortcuts so we're not

00:10:26,069 --> 00:10:30,209
violating that rule we're taking

00:10:27,720 --> 00:10:33,540
advantage of rule 5 then our first test

00:10:30,209 --> 00:10:35,490
which instance it's that a scope which

00:10:33,540 --> 00:10:38,100
works like a global context should be

00:10:35,490 --> 00:10:40,439
able to set a variable in this case the

00:10:38,100 --> 00:10:42,120
variable X to 1 and then with we go to

00:10:40,439 --> 00:10:44,040
look it up with the G function it should

00:10:42,120 --> 00:10:45,990
return that same value and if we try to

00:10:44,040 --> 00:10:48,480
look up a variable that did not exist we

00:10:45,990 --> 00:10:50,879
should get undefined back so in fact if

00:10:48,480 --> 00:10:52,740
we run this spec we should see that it

00:10:50,879 --> 00:10:54,749
fails well first off it says that scope

00:10:52,740 --> 00:10:57,120
isn't even defined so first thing we

00:10:54,749 --> 00:10:59,069
need to do we need to go to find this so

00:10:57,120 --> 00:11:00,360
let's go over to this other file and I'm

00:10:59,069 --> 00:11:02,939
just going to use the revealing module

00:11:00,360 --> 00:11:06,569
pattern to keep things clean so I'm

00:11:02,939 --> 00:11:08,819
going to create a scoping object and the

00:11:06,569 --> 00:11:09,600
scope object it's going to expose it so

00:11:08,819 --> 00:11:11,190
well

00:11:09,600 --> 00:11:13,380
it's going to expose a constructor

00:11:11,190 --> 00:11:14,670
called scope and this constructor isn't

00:11:13,380 --> 00:11:17,040
really going to do anything it's only

00:11:14,670 --> 00:11:18,540
going to create one instance variable

00:11:17,040 --> 00:11:21,600
which is going to be underscored dick

00:11:18,540 --> 00:11:24,089
dick for dictionary so this dictionary

00:11:21,600 --> 00:11:26,310
is going to map from all local variable

00:11:24,089 --> 00:11:28,709
names we know about to their values in

00:11:26,310 --> 00:11:31,829
this particular scope this represents

00:11:28,709 --> 00:11:33,569
just one scope so we've got that set up

00:11:31,829 --> 00:11:37,139
let's run the specs now and see what

00:11:33,569 --> 00:11:38,639
happens now we moved a little bit

00:11:37,139 --> 00:11:40,139
further cannot read property bind of

00:11:38,639 --> 00:11:42,839
undefined it's because we don't yet have

00:11:40,139 --> 00:11:44,459
those get and set functions so let's

00:11:42,839 --> 00:11:46,980
just go ahead and write those those are

00:11:44,459 --> 00:11:48,480
pretty easy to write so get as you will

00:11:46,980 --> 00:11:50,100
recall takes in the name of the local

00:11:48,480 --> 00:11:52,829
variable we want to look up and returns

00:11:50,100 --> 00:11:54,899
it so this is a simple property lookup

00:11:52,829 --> 00:11:57,420
will look up in the dictionary the value

00:11:54,899 --> 00:12:00,329
by the name of key and set is going to

00:11:57,420 --> 00:12:02,420
be almost exactly the same set is going

00:12:00,329 --> 00:12:04,470
to take an icky as well as a value and

00:12:02,420 --> 00:12:07,829
then instead of returning it it's going

00:12:04,470 --> 00:12:10,259
to set it to it nothing too unusual here

00:12:07,829 --> 00:12:12,630
if we run this spec and I keep going to

00:12:10,259 --> 00:12:15,089
the wrong window if I run it we now see

00:12:12,630 --> 00:12:16,800
that our first spec which is a scope

00:12:15,089 --> 00:12:19,170
that works as a global context should

00:12:16,800 --> 00:12:20,639
work so awesome we have our first spec

00:12:19,170 --> 00:12:22,170
passing and we have the concept of

00:12:20,639 --> 00:12:24,300
global context which is not really

00:12:22,170 --> 00:12:26,250
groundbreaking we've had that since x86

00:12:24,300 --> 00:12:29,040
Fortran name any other language we had

00:12:26,250 --> 00:12:30,810
this with registers so let's go a little

00:12:29,040 --> 00:12:35,790
bit further we'll go to our next set of

00:12:30,810 --> 00:12:36,990
specs so that was for global context now

00:12:35,790 --> 00:12:39,029
we're going to enable this for what I

00:12:36,990 --> 00:12:40,949
call a context so some of you may have

00:12:39,029 --> 00:12:42,600
done some graphics programming before in

00:12:40,949 --> 00:12:45,029
graphics programming whenever you want

00:12:42,600 --> 00:12:46,949
to paint something you typically push on

00:12:45,029 --> 00:12:48,750
a context you change the stroke maybe

00:12:46,949 --> 00:12:51,000
the width the color a few other

00:12:48,750 --> 00:12:52,800
properties and then you do some work and

00:12:51,000 --> 00:12:55,230
then when you're done doing that work

00:12:52,800 --> 00:12:56,910
you pop the context you do this so that

00:12:55,230 --> 00:12:59,009
way the parent function that called you

00:12:56,910 --> 00:13:00,720
doesn't get into any side effects

00:12:59,009 --> 00:13:02,639
because of all the work that you wanted

00:13:00,720 --> 00:13:04,500
to do in your own little function so

00:13:02,639 --> 00:13:05,759
push and pop very often in graphics

00:13:04,500 --> 00:13:07,589
programming would be called at the

00:13:05,759 --> 00:13:09,449
boundaries of a function well in

00:13:07,589 --> 00:13:12,509
JavaScript our functions do exactly that

00:13:09,449 --> 00:13:15,029
functions act as boundaries between

00:13:12,509 --> 00:13:16,079
different scopes so before we get to

00:13:15,029 --> 00:13:18,209
that point we're just going to go ahead

00:13:16,079 --> 00:13:20,420
and create push and pop functions so

00:13:18,209 --> 00:13:23,370
notice we have two new aliases here and

00:13:20,420 --> 00:13:25,980
let's go over and implement those

00:13:23,370 --> 00:13:27,360
so hopefully now that we've enabled

00:13:25,980 --> 00:13:30,000
these we should see that we have some

00:13:27,360 --> 00:13:32,010
failing specs so it says scope for

00:13:30,000 --> 00:13:33,960
context first off it says it cannot read

00:13:32,010 --> 00:13:35,460
property bind this means that we haven't

00:13:33,960 --> 00:13:39,029
defined those push and pop methods at

00:13:35,460 --> 00:13:40,410
all yet so let's fix this will define a

00:13:39,029 --> 00:13:42,300
push we're not even going to fill out

00:13:40,410 --> 00:13:43,710
its implementation yet like all good

00:13:42,300 --> 00:13:45,660
test German developers we want to make

00:13:43,710 --> 00:13:48,180
sure our tests fail first and take it

00:13:45,660 --> 00:13:51,029
one step at a time so now that we've got

00:13:48,180 --> 00:13:52,200
push and pop we should see that some of

00:13:51,029 --> 00:13:54,300
these tests look a little bit more

00:13:52,200 --> 00:13:58,770
detailed now because now our setup law

00:13:54,300 --> 00:14:01,830
can actually run and we have 12 tests

00:13:58,770 --> 00:14:03,480
passing the first test is that the scope

00:14:01,830 --> 00:14:06,300
should inherit variables from outer

00:14:03,480 --> 00:14:07,620
contact sees well obviously at this

00:14:06,300 --> 00:14:09,060
point we've only done global contact

00:14:07,620 --> 00:14:12,240
sees so if you were to create a new

00:14:09,060 --> 00:14:14,040
scope by doing a push that pushes and no

00:14:12,240 --> 00:14:15,570
op so we're still in the global context

00:14:14,040 --> 00:14:18,120
so of course we inherit variables from

00:14:15,570 --> 00:14:19,620
outer contact seas and the last one is a

00:14:18,120 --> 00:14:21,630
little bit more related to something

00:14:19,620 --> 00:14:23,940
later on but will want to make sure that

00:14:21,630 --> 00:14:25,740
one passes as well the first and third

00:14:23,940 --> 00:14:27,450
tests are failing though it says that it

00:14:25,740 --> 00:14:29,550
should be able to isolate variables from

00:14:27,450 --> 00:14:32,790
outer context which means that whenever

00:14:29,550 --> 00:14:35,070
we supposedly push a new context we're

00:14:32,790 --> 00:14:36,930
leaking data into the external

00:14:35,070 --> 00:14:38,580
environment because this at this point

00:14:36,930 --> 00:14:39,990
we're only dealing with global contacts

00:14:38,580 --> 00:14:41,730
sees we haven't implemented local

00:14:39,990 --> 00:14:43,830
contacts ease and then the final one

00:14:41,730 --> 00:14:45,839
variable shadowing this says that if we

00:14:43,830 --> 00:14:48,750
have two variables of the same name that

00:14:45,839 --> 00:14:50,730
if we set the variable by the same name

00:14:48,750 --> 00:14:52,980
in the interscope it should not override

00:14:50,730 --> 00:14:56,640
that when we go back to the outer scope

00:14:52,980 --> 00:14:59,160
this is the isolation part so both of

00:14:56,640 --> 00:15:01,920
these tests fail so let's go back and

00:14:59,160 --> 00:15:03,839
actually make these sort of pass we're

00:15:01,920 --> 00:15:05,520
going to set this dictionary which again

00:15:03,839 --> 00:15:07,380
is a map from all the local variables in

00:15:05,520 --> 00:15:09,690
the scope to its value and set it to a

00:15:07,380 --> 00:15:11,490
brand new object and I'm going to cheat

00:15:09,690 --> 00:15:12,930
here any time we go to pop of context

00:15:11,490 --> 00:15:16,560
we'll just set it to a brand new object

00:15:12,930 --> 00:15:18,420
as well let's see what happens now so we

00:15:16,560 --> 00:15:20,700
have our first spec passing variables

00:15:18,420 --> 00:15:23,339
are now isolated but we broke everything

00:15:20,700 --> 00:15:24,810
else so we've taken a step backwards so

00:15:23,339 --> 00:15:27,209
at this point we actually have to get

00:15:24,810 --> 00:15:28,860
into the meat of this whole talk which

00:15:27,209 --> 00:15:32,130
is going to be how are we going to make

00:15:28,860 --> 00:15:34,110
scopes that can inherit variables from

00:15:32,130 --> 00:15:36,300
other scopes because this is essentially

00:15:34,110 --> 00:15:37,260
what happens enclosures a closure gets a

00:15:36,300 --> 00:15:39,420
scope and that's go

00:15:37,260 --> 00:15:41,610
has default values from the external

00:15:39,420 --> 00:15:44,100
environment but if we go to override it

00:15:41,610 --> 00:15:45,660
then we don't override the parents value

00:15:44,100 --> 00:15:48,810
we actually create a new variable in

00:15:45,660 --> 00:15:50,910
that scope so I use the word inheritance

00:15:48,810 --> 00:15:52,440
on purpose that should trigger a certain

00:15:50,910 --> 00:15:53,880
JavaScript concept in our minds and

00:15:52,440 --> 00:15:57,060
here's where we get to the buzzword

00:15:53,880 --> 00:15:59,730
prototypes what we want to do is we want

00:15:57,060 --> 00:16:01,770
to create an object which inherits all

00:15:59,730 --> 00:16:04,140
the default values from the parent scope

00:16:01,770 --> 00:16:05,220
or the parent context at this point but

00:16:04,140 --> 00:16:07,380
be able to override those without

00:16:05,220 --> 00:16:09,540
influencing the parent the best way to

00:16:07,380 --> 00:16:10,860
do this is we're going to use Douglas

00:16:09,540 --> 00:16:13,650
Crockford method of prototypical

00:16:10,860 --> 00:16:15,330
inheritance so whenever we go to push on

00:16:13,650 --> 00:16:17,010
a new context instead of setting it to a

00:16:15,330 --> 00:16:18,660
new object we are going to call a

00:16:17,010 --> 00:16:21,450
mysterious method we will define called

00:16:18,660 --> 00:16:23,430
fork this fork dick method will

00:16:21,450 --> 00:16:25,650
take the current dictionary of local

00:16:23,430 --> 00:16:27,420
variables and create an object which

00:16:25,650 --> 00:16:29,400
inherits from it through the prototype

00:16:27,420 --> 00:16:32,130
chain which means at any time we try to

00:16:29,400 --> 00:16:33,810
do a lookup for a variable of a name

00:16:32,130 --> 00:16:36,630
that was in a parent context we'll get

00:16:33,810 --> 00:16:38,760
it but if we try to set it then we'll

00:16:36,630 --> 00:16:42,540
get a completely new variable without

00:16:38,760 --> 00:16:44,310
changing the parent so now that we're

00:16:42,540 --> 00:16:45,870
calling for dick we should also probably

00:16:44,310 --> 00:16:47,760
do something about pop because right now

00:16:45,870 --> 00:16:49,440
pop is just creating a new object the

00:16:47,760 --> 00:16:51,060
way we'll get around this is we'll take

00:16:49,440 --> 00:16:53,520
a look at the current dictionary and

00:16:51,060 --> 00:16:55,890
then we'll keep track later on with add

00:16:53,520 --> 00:16:57,660
underscore parent will see exactly what

00:16:55,890 --> 00:17:00,720
that means but dunder parent is going to

00:16:57,660 --> 00:17:03,510
remember the object that will existed

00:17:00,720 --> 00:17:05,640
before we pushed so let's go implement

00:17:03,510 --> 00:17:07,410
that method will do it as a private

00:17:05,640 --> 00:17:09,900
looking method so we'll do underscore

00:17:07,410 --> 00:17:11,880
for dick it'll take in no arguments and

00:17:09,900 --> 00:17:14,520
at this point a lot of you may gloss

00:17:11,880 --> 00:17:16,050
over or some of you may be like oh I

00:17:14,520 --> 00:17:18,000
know this pattern it's Douglas Crockford

00:17:16,050 --> 00:17:20,280
method of prototypical inheritance with

00:17:18,000 --> 00:17:21,480
a little bit of salt thrown in so we're

00:17:20,280 --> 00:17:22,800
going to create a local variable here

00:17:21,480 --> 00:17:24,930
and just assign it to the current

00:17:22,800 --> 00:17:26,820
dictionary of local variables and then

00:17:24,930 --> 00:17:29,250
we're going to start doing the pattern

00:17:26,820 --> 00:17:31,200
which is we create a donor constructor

00:17:29,250 --> 00:17:33,270
function we're just using this for the

00:17:31,200 --> 00:17:35,310
prototypal chain this function will

00:17:33,270 --> 00:17:37,020
never actually be invoked and then we're

00:17:35,310 --> 00:17:39,210
going to set the prototype property on

00:17:37,020 --> 00:17:41,430
this function to do this we'll use an

00:17:39,210 --> 00:17:43,380
es5 feature which is object or creates

00:17:41,430 --> 00:17:45,120
this does kind of another level of

00:17:43,380 --> 00:17:47,550
inheritance but you could cut this all

00:17:45,120 --> 00:17:49,740
as well it's just this saves me a little

00:17:47,550 --> 00:17:50,580
bit of time so let's call object i'll

00:17:49,740 --> 00:17:52,350
create dick

00:17:50,580 --> 00:17:55,559
we'll set the functions prototype to

00:17:52,350 --> 00:17:57,390
that now we need to set a few methods on

00:17:55,559 --> 00:17:58,799
the prototype let's set the constructor

00:17:57,390 --> 00:18:04,679
just because we're going to be nice

00:17:58,799 --> 00:18:06,630
let's see instructor equals F and then f

00:18:04,679 --> 00:18:08,460
dot prototype we need a way to keep

00:18:06,630 --> 00:18:10,679
track of what the previous dictionary or

00:18:08,460 --> 00:18:13,019
the previous scope was so we're going to

00:18:10,679 --> 00:18:15,450
set that Dunder parent variable to

00:18:13,019 --> 00:18:17,070
 that way later on when we go to

00:18:15,450 --> 00:18:20,309
pop we can go back to the previous

00:18:17,070 --> 00:18:21,600
context and then to finish off Douglas

00:18:20,309 --> 00:18:23,700
Crawford's pattern we just need to

00:18:21,600 --> 00:18:26,519
return a function created by that

00:18:23,700 --> 00:18:27,720
constructor so that was quite a lot

00:18:26,519 --> 00:18:31,590
happening let's see if this actually

00:18:27,720 --> 00:18:33,630
works which is why we have specs yes so

00:18:31,590 --> 00:18:35,490
now we have our scope object and it

00:18:33,630 --> 00:18:37,470
works like local contact sees kind of

00:18:35,490 --> 00:18:40,500
like in the graphics idea a push and pop

00:18:37,470 --> 00:18:42,539
now nowhere in your JavaScript code do

00:18:40,500 --> 00:18:44,970
you see calls to push and pop you see

00:18:42,539 --> 00:18:47,010
functions being created so now we're

00:18:44,970 --> 00:18:48,690
going to actually implement that f

00:18:47,010 --> 00:18:50,789
function we saw in the slides earlier

00:18:48,690 --> 00:18:52,860
which will create a function expression

00:18:50,789 --> 00:18:55,409
and assign it to a local variable so

00:18:52,860 --> 00:18:57,960
let's go to our next set of specs will

00:18:55,409 --> 00:19:01,019
disable those for now and we'll go down

00:18:57,960 --> 00:19:02,880
to the next set just down here will call

00:19:01,019 --> 00:19:05,760
these wolf call scopes that act like

00:19:02,880 --> 00:19:07,080
this nested if ease so nested-if is if

00:19:05,760 --> 00:19:09,059
you think about it our whole lot like

00:19:07,080 --> 00:19:11,309
calling push and pop whenever you enter

00:19:09,059 --> 00:19:13,139
a function you immediately get a new

00:19:11,309 --> 00:19:15,149
scope which inherits from its previous

00:19:13,139 --> 00:19:16,889
scope and as soon as you finish

00:19:15,149 --> 00:19:19,620
executing that function and pop up the

00:19:16,889 --> 00:19:22,080
stack then you get the previous scope

00:19:19,620 --> 00:19:23,669
and that's like calling pop so in this

00:19:22,080 --> 00:19:25,230
case we just want to use nicer syntax

00:19:23,669 --> 00:19:28,529
notice that we found rid of push and pop

00:19:25,230 --> 00:19:30,210
and we just have s G and F F is going to

00:19:28,529 --> 00:19:32,220
be a new helper will write called funk

00:19:30,210 --> 00:19:33,929
and then we have a bunch of specs

00:19:32,220 --> 00:19:35,279
describing how this should work let's

00:19:33,929 --> 00:19:37,529
see if this even works to begin with

00:19:35,279 --> 00:19:39,090
well not at all it says cannot read

00:19:37,529 --> 00:19:41,490
property bind we haven't even written

00:19:39,090 --> 00:19:47,519
the funk helper so let's go give this a

00:19:41,490 --> 00:19:50,340
try so recall that the funk helper or F

00:19:47,519 --> 00:19:51,750
for the shorthand is supposed to take in

00:19:50,340 --> 00:19:53,340
the name of the local variable to which

00:19:51,750 --> 00:19:55,260
we want to assign this new function

00:19:53,340 --> 00:19:56,880
expression it takes in a list of the

00:19:55,260 --> 00:19:58,260
parameters by name that normally we

00:19:56,880 --> 00:20:00,029
would put in the function and then in

00:19:58,260 --> 00:20:01,830
between the parentheses and then it

00:20:00,029 --> 00:20:03,570
takes that amnesic function body i'm

00:20:01,830 --> 00:20:04,470
going to call it body here just so it's

00:20:03,570 --> 00:20:06,299
obvious

00:20:04,470 --> 00:20:08,640
that it doesn't have any memory of

00:20:06,299 --> 00:20:11,159
anything else we're basically just using

00:20:08,640 --> 00:20:12,450
functions as a way to get some code into

00:20:11,159 --> 00:20:14,250
this environment but it doesn't remember

00:20:12,450 --> 00:20:16,590
anything about its environment or where

00:20:14,250 --> 00:20:19,409
it was created as it pertains to the

00:20:16,590 --> 00:20:21,539
native scoping mechanism so in here only

00:20:19,409 --> 00:20:22,770
to do a few things first off I know I'm

00:20:21,539 --> 00:20:24,419
going to need to save the value of this

00:20:22,770 --> 00:20:27,720
because we're going to call some methods

00:20:24,419 --> 00:20:29,610
and then what I want to do is I want to

00:20:27,720 --> 00:20:32,039
expose this function that's being

00:20:29,610 --> 00:20:34,500
created as a local variable so I'm

00:20:32,039 --> 00:20:36,990
calling this set and I'll set it to the

00:20:34,500 --> 00:20:38,940
name that was passed in and then I'm

00:20:36,990 --> 00:20:41,220
going to pass it in the function that I

00:20:38,940 --> 00:20:43,409
want to set this local variable to now I

00:20:41,220 --> 00:20:45,780
can't just pass in body if I pass in

00:20:43,409 --> 00:20:47,400
body at this point body doesn't even

00:20:45,780 --> 00:20:48,539
Remember Who its parameters are it

00:20:47,400 --> 00:20:50,220
doesn't remember anything about its

00:20:48,539 --> 00:20:51,809
scope what I really need to be able to

00:20:50,220 --> 00:20:53,880
do is do a little bit of setup

00:20:51,809 --> 00:20:55,799
functionality first in a wrapper

00:20:53,880 --> 00:20:58,590
function and have that wrapper function

00:20:55,799 --> 00:21:00,150
then call our amnesic function body so

00:20:58,590 --> 00:21:02,490
will do exactly that will create a

00:21:00,150 --> 00:21:04,289
function wrapper and in here we're going

00:21:02,490 --> 00:21:06,210
to need to do a few things first off we

00:21:04,289 --> 00:21:07,830
know we'll need to invoke body because

00:21:06,210 --> 00:21:09,840
otherwise our code would never get run

00:21:07,830 --> 00:21:11,940
but then we also need to deal with the

00:21:09,840 --> 00:21:14,580
contacts sees we need to call push to

00:21:11,940 --> 00:21:17,070
get a new workspace and then just below

00:21:14,580 --> 00:21:18,630
it we need to do a pop now for this to

00:21:17,070 --> 00:21:20,220
be really useful we need return values

00:21:18,630 --> 00:21:22,679
so we're going to save off whatever the

00:21:20,220 --> 00:21:25,620
body returned and at the very end return

00:21:22,679 --> 00:21:27,299
that result this is pretty much it

00:21:25,620 --> 00:21:29,429
there's one last thing we haven't done

00:21:27,299 --> 00:21:31,890
though which is params notice we're not

00:21:29,429 --> 00:21:34,770
using it anywhere params gives us that

00:21:31,890 --> 00:21:37,440
list of local variables which get passed

00:21:34,770 --> 00:21:38,490
into a function that's essentially

00:21:37,440 --> 00:21:41,400
function parameters are just a

00:21:38,490 --> 00:21:43,200
convenience on top of it well we want

00:21:41,400 --> 00:21:45,090
that convenience so what we'd like to do

00:21:43,200 --> 00:21:47,400
is after we've gotten a brand new

00:21:45,090 --> 00:21:49,530
context we want to go over every

00:21:47,400 --> 00:21:51,270
parameter and look in the JavaScript

00:21:49,530 --> 00:21:53,970
arguments object that was passed into

00:21:51,270 --> 00:21:56,309
this function rapper oops let's go back

00:21:53,970 --> 00:21:58,080
where we were we want to set every

00:21:56,309 --> 00:21:59,820
single local variable in this new scope

00:21:58,080 --> 00:22:01,380
to all the values that were passing as

00:21:59,820 --> 00:22:02,700
parameters that's going to be a lot of

00:22:01,380 --> 00:22:04,289
code to type here though so I'm going to

00:22:02,700 --> 00:22:05,909
create a little funk a little helper

00:22:04,289 --> 00:22:07,830
this helper will take in an array of

00:22:05,909 --> 00:22:09,780
params and a corresponding array of

00:22:07,830 --> 00:22:11,490
parameter values which is going to be

00:22:09,780 --> 00:22:13,080
arguments and I'm going to use the

00:22:11,490 --> 00:22:15,419
arguments object here that JavaScript

00:22:13,080 --> 00:22:17,220
provides to every function very

00:22:15,419 --> 00:22:18,179
performant I assure you let's go a

00:22:17,220 --> 00:22:20,940
little bit further

00:22:18,179 --> 00:22:24,330
and let's go implement this arts helper

00:22:20,940 --> 00:22:25,919
so we'll do proto scope args and it

00:22:24,330 --> 00:22:28,740
takes in the names of local variables

00:22:25,919 --> 00:22:30,539
along with their values and this is just

00:22:28,740 --> 00:22:32,039
essentially a mass assignment operation

00:22:30,539 --> 00:22:35,730
so we're just going to for loop over all

00:22:32,039 --> 00:22:37,350
the names and then we're going to call

00:22:35,730 --> 00:22:41,720
this thought set for every single one of

00:22:37,350 --> 00:22:44,070
them so I'll names I and then values I

00:22:41,720 --> 00:22:48,720
that was a lot of typing let's see if

00:22:44,070 --> 00:22:51,149
any of this works it passes so now we

00:22:48,720 --> 00:22:55,139
have our closure implementation working

00:22:51,149 --> 00:22:57,029
whenever we build nested-if ease but we

00:22:55,139 --> 00:22:58,440
have one last class and this is probably

00:22:57,029 --> 00:22:59,879
the hardest class to deal with because

00:22:58,440 --> 00:23:03,090
it will completely change our code and

00:22:59,879 --> 00:23:06,679
break all of our assumptions so let's go

00:23:03,090 --> 00:23:08,700
down here to the bottom to the last set

00:23:06,679 --> 00:23:10,289
now if you look in here we've got the

00:23:08,700 --> 00:23:13,169
same SF and G but you'll notice that

00:23:10,289 --> 00:23:15,360
example that I wrote earlier which is

00:23:13,169 --> 00:23:16,529
we're doing in outer function which

00:23:15,360 --> 00:23:19,320
returns an inner function which returns

00:23:16,529 --> 00:23:22,289
the values of x y and z and then we

00:23:19,320 --> 00:23:24,029
invoke that function outside of its

00:23:22,289 --> 00:23:26,309
definition contacts this is where

00:23:24,029 --> 00:23:28,529
JavaScript's idea of closures becomes

00:23:26,309 --> 00:23:30,960
very powerful is a closure remembers its

00:23:28,529 --> 00:23:36,299
definition time scope not at execution

00:23:30,960 --> 00:23:38,580
scope so let's see if this runs it says

00:23:36,299 --> 00:23:41,909
it fails it says that it expected to get

00:23:38,580 --> 00:23:45,210
3 comma 2 comma 4 but instead it got

00:23:41,909 --> 00:23:48,029
three undefined for so this means that

00:23:45,210 --> 00:23:49,860
somewhere we were accessing a scope we

00:23:48,029 --> 00:23:51,389
didn't expect at least if we were

00:23:49,860 --> 00:23:54,240
thinking this as regular JavaScript in

00:23:51,389 --> 00:23:57,360
fact we made this error earlier if we go

00:23:54,240 --> 00:23:59,580
back to funk look at where this dot push

00:23:57,360 --> 00:24:01,409
is being called we're calling it inside

00:23:59,580 --> 00:24:03,960
the function wrapper which means that

00:24:01,409 --> 00:24:07,169
we're calling this stop push at the same

00:24:03,960 --> 00:24:09,389
time we invoke this body not at the time

00:24:07,169 --> 00:24:11,190
we define this function well recall that

00:24:09,389 --> 00:24:14,909
this stop push is going to look at the

00:24:11,190 --> 00:24:16,980
current scope and pork off of it so this

00:24:14,909 --> 00:24:19,259
means that we're not actually keeping

00:24:16,980 --> 00:24:20,970
track of the scope from when this

00:24:19,259 --> 00:24:22,919
function was defined we're actually

00:24:20,970 --> 00:24:24,539
looking at the scope and forking off of

00:24:22,919 --> 00:24:26,519
it at the time the function is invoked

00:24:24,539 --> 00:24:28,980
this is not at all how javascript

00:24:26,519 --> 00:24:31,190
closures work in javascript it's based

00:24:28,980 --> 00:24:34,250
on where you define the function

00:24:31,190 --> 00:24:36,590
not where it's executed so to fix this

00:24:34,250 --> 00:24:38,540
we kind of the this stop push statement

00:24:36,590 --> 00:24:40,250
up a level we need to move it to the

00:24:38,540 --> 00:24:41,960
time that we call our helper to define

00:24:40,250 --> 00:24:43,340
this function but that's not quite it

00:24:41,960 --> 00:24:45,800
either because as soon as we call this

00:24:43,340 --> 00:24:47,480
not push it will change scope and we

00:24:45,800 --> 00:24:49,370
don't want to change scope until we

00:24:47,480 --> 00:24:51,260
actually execute the code so what we

00:24:49,370 --> 00:24:53,810
really need is a way to keep track of

00:24:51,260 --> 00:24:56,480
what the current scope is at the time

00:24:53,810 --> 00:24:58,850
we're defining this function pre fork it

00:24:56,480 --> 00:25:00,200
and then let that rest for a while you

00:24:58,850 --> 00:25:01,910
need to save it off somewhere so that

00:25:00,200 --> 00:25:04,520
way when this function does it get

00:25:01,910 --> 00:25:08,300
executed it can resurrect that scope by

00:25:04,520 --> 00:25:10,400
doing a scope push well let's just a

00:25:08,300 --> 00:25:13,130
pseudocode this for a little bit will do

00:25:10,400 --> 00:25:14,720
this and we'll suppose that we have some

00:25:13,130 --> 00:25:19,400
way to get the scope for the current

00:25:14,720 --> 00:25:21,200
closure and assuming that we get that

00:25:19,400 --> 00:25:23,150
scope back which is going to be a scope

00:25:21,200 --> 00:25:25,550
object will do fork which is just going

00:25:23,150 --> 00:25:26,990
to be an inheritance now does anyone

00:25:25,550 --> 00:25:29,900
start to feel a little bit uncomfortable

00:25:26,990 --> 00:25:32,120
we're at 50 lines of code we don't have

00:25:29,900 --> 00:25:33,650
this actually working yet and we have a

00:25:32,120 --> 00:25:36,200
lot of functionality in this one scope

00:25:33,650 --> 00:25:38,690
class or revealing module pattern if you

00:25:36,200 --> 00:25:40,040
prefer this makes me uncomfortable we

00:25:38,690 --> 00:25:42,680
have the idea of a scope which is

00:25:40,040 --> 00:25:43,940
supposed to represent just one scope but

00:25:42,680 --> 00:25:45,740
somehow we're supposed to keep track of

00:25:43,940 --> 00:25:47,420
all the Scopes in memory so we can

00:25:45,740 --> 00:25:50,390
assign it to functions that sounds more

00:25:47,420 --> 00:25:53,170
like we need another class maybe so in

00:25:50,390 --> 00:25:56,060
fact let's do that back in our tests I

00:25:53,170 --> 00:25:58,250
preemptively did this we're going to

00:25:56,060 --> 00:26:00,110
create a closure registry this closure

00:25:58,250 --> 00:26:01,970
registry is going to keep track of all

00:26:00,110 --> 00:26:04,520
the scope objects we create any time we

00:26:01,970 --> 00:26:07,190
do a function it will collaborate with

00:26:04,520 --> 00:26:10,100
all these different objects so at the

00:26:07,190 --> 00:26:11,870
very top of our current file we're going

00:26:10,100 --> 00:26:16,370
to create a closure regÃ­strate will use

00:26:11,870 --> 00:26:18,520
the same revealing model pattern so we

00:26:16,370 --> 00:26:21,400
need to return the closure registry and

00:26:18,520 --> 00:26:23,510
then we need to create our constructor

00:26:21,400 --> 00:26:25,430
now this constructor won't take in

00:26:23,510 --> 00:26:28,340
anything right now but it does need to

00:26:25,430 --> 00:26:30,950
keep a registry this registry is going

00:26:28,340 --> 00:26:33,110
to be essentially the entire environment

00:26:30,950 --> 00:26:35,270
of our JavaScript runtime it's going to

00:26:33,110 --> 00:26:36,650
map from all of the current functions

00:26:35,270 --> 00:26:38,720
that have been created to their

00:26:36,650 --> 00:26:39,800
corresponding scope some of you are

00:26:38,720 --> 00:26:41,510
already thinking how are we going to do

00:26:39,800 --> 00:26:44,270
that you can't use a function as a key

00:26:41,510 --> 00:26:45,030
into a variable bear with me so we'll

00:26:44,270 --> 00:26:46,560
set this up

00:26:45,030 --> 00:26:48,800
and we'll need a way to keep track of

00:26:46,560 --> 00:26:52,680
what closure is currently executing

00:26:48,800 --> 00:26:54,360
we'll see just why in a moment so now we

00:26:52,680 --> 00:26:57,090
can start moving some functionality

00:26:54,360 --> 00:26:58,710
around push pop and funk really don't

00:26:57,090 --> 00:27:00,240
belong here they really belong in a

00:26:58,710 --> 00:27:04,410
closure registry because they all deal

00:27:00,240 --> 00:27:06,780
with creating new scopes so let's put

00:27:04,410 --> 00:27:08,160
that up here we don't really know how

00:27:06,780 --> 00:27:11,400
push and pop are going to work in this

00:27:08,160 --> 00:27:13,170
new context yet but we do know how the

00:27:11,400 --> 00:27:14,580
function helper is going to work we'll

00:27:13,170 --> 00:27:17,820
just change this out so its closure

00:27:14,580 --> 00:27:20,040
registry and what we would like to do is

00:27:17,820 --> 00:27:22,530
to implement this scope for current

00:27:20,040 --> 00:27:24,780
closure method and then when we call

00:27:22,530 --> 00:27:27,210
push instead of letting it fork off a

00:27:24,780 --> 00:27:29,190
new scope at runtime we're going to pass

00:27:27,210 --> 00:27:31,200
it in now some of you may be thinking

00:27:29,190 --> 00:27:33,120
he's cheating he's using local variables

00:27:31,200 --> 00:27:35,010
yes you can use local variables in the

00:27:33,120 --> 00:27:37,320
implementation just not in your

00:27:35,010 --> 00:27:39,360
consuming code that would be quite a bit

00:27:37,320 --> 00:27:41,730
more difficult admittedly if not

00:27:39,360 --> 00:27:44,040
impossible i have yet to explore that so

00:27:41,730 --> 00:27:45,740
when we call this stop push will push in

00:27:44,040 --> 00:27:47,760
that scope that we calculated at

00:27:45,740 --> 00:27:51,240
definition time when we call the f

00:27:47,760 --> 00:27:52,770
helper so we've got quite a few things

00:27:51,240 --> 00:27:54,840
we don't really know about we don't know

00:27:52,770 --> 00:27:58,050
how we're going to implement this scope

00:27:54,840 --> 00:28:00,150
for a current closure we don't really

00:27:58,050 --> 00:28:01,560
know how that's going to work yet and we

00:28:00,150 --> 00:28:04,650
don't know how push and pop are going to

00:28:01,560 --> 00:28:07,050
work so now is where we get a chance to

00:28:04,650 --> 00:28:08,760
make a fun little observation whenever

00:28:07,050 --> 00:28:11,490
our javascript is executing there's only

00:28:08,760 --> 00:28:13,230
one scope active at any given time this

00:28:11,490 --> 00:28:15,480
is a single threaded language so

00:28:13,230 --> 00:28:19,020
whenever we enter a function we are

00:28:15,480 --> 00:28:21,090
using the scope for that function seems

00:28:19,020 --> 00:28:24,330
pretty simple so that means that

00:28:21,090 --> 00:28:26,400
whenever we start a new function we push

00:28:24,330 --> 00:28:27,960
on the active scope kind of like

00:28:26,400 --> 00:28:30,630
contacts ease and as soon as that

00:28:27,960 --> 00:28:33,150
function finishes we pop it off what do

00:28:30,630 --> 00:28:34,830
we pop off back to whatever the previous

00:28:33,150 --> 00:28:36,630
function was that called this function

00:28:34,830 --> 00:28:38,400
we can guarantee this because we no

00:28:36,630 --> 00:28:40,620
longer let people arbitrarily call push

00:28:38,400 --> 00:28:42,240
and pop we always ensure that every

00:28:40,620 --> 00:28:44,700
function calls push at the beginning and

00:28:42,240 --> 00:28:46,460
pop at the end that means that we

00:28:44,700 --> 00:28:48,750
actually don't need to keep track of

00:28:46,460 --> 00:28:51,120
every function we've ever created and

00:28:48,750 --> 00:28:53,520
map it to a scope we really just need a

00:28:51,120 --> 00:28:55,830
stack of scopes so I'm going to turn

00:28:53,520 --> 00:28:58,470
registry into an object or excuse me

00:28:55,830 --> 00:29:00,240
into an array and this array is going

00:28:58,470 --> 00:29:03,480
to keep track of what the current scope

00:29:00,240 --> 00:29:06,780
is and all previous scopes at execution

00:29:03,480 --> 00:29:09,480
time so that actually makes some of this

00:29:06,780 --> 00:29:12,630
code a lot easier for example we know

00:29:09,480 --> 00:29:14,940
that with a stack the current item is

00:29:12,630 --> 00:29:17,640
going to be the last item so we'll just

00:29:14,940 --> 00:29:19,799
index into whatever the current scope is

00:29:17,640 --> 00:29:22,230
we'll look at the last item on top and

00:29:19,799 --> 00:29:24,720
return it so now we have scope for

00:29:22,230 --> 00:29:26,880
current closure defined now maybe we can

00:29:24,720 --> 00:29:29,340
go right these push and pop methods

00:29:26,880 --> 00:29:33,120
because push and pop will need to push a

00:29:29,340 --> 00:29:35,850
brand new scope at execution time so

00:29:33,120 --> 00:29:38,159
nowadays push is going to be taking in

00:29:35,850 --> 00:29:39,600
the exact scope so we actually don't

00:29:38,159 --> 00:29:42,059
need all this complicated fort dick

00:29:39,600 --> 00:29:44,460
logic that's all going to be below and

00:29:42,059 --> 00:29:46,559
we don't really need pop you know

00:29:44,460 --> 00:29:48,390
someone might recognize these method

00:29:46,559 --> 00:29:50,370
names and notice that I kind of saved us

00:29:48,390 --> 00:29:52,080
a step push and pop these are methods on

00:29:50,370 --> 00:29:54,059
a standard JavaScript array and they do

00:29:52,080 --> 00:29:56,190
exactly the same thing as what we've

00:29:54,059 --> 00:29:59,640
written here except that push pit takes

00:29:56,190 --> 00:30:00,840
in an item to push so we could write all

00:29:59,640 --> 00:30:02,909
these out in to be a lot of boilerplate

00:30:00,840 --> 00:30:04,950
code but we can actually save ourselves

00:30:02,909 --> 00:30:06,450
a few steps I've written a little helper

00:30:04,950 --> 00:30:08,760
you can go check out the repo which i'll

00:30:06,450 --> 00:30:11,190
post up later which is called delegate

00:30:08,760 --> 00:30:12,750
it takes in a list of functions that

00:30:11,190 --> 00:30:15,809
we'd like to create on the closure

00:30:12,750 --> 00:30:22,470
registry prototype so that excuse me not

00:30:15,809 --> 00:30:24,780
get set push and pop and then it takes

00:30:22,470 --> 00:30:27,299
in a few other arguments it lets us say

00:30:24,780 --> 00:30:29,940
we're to create these functions so i'm

00:30:27,299 --> 00:30:32,039
going to say on the closure registry

00:30:29,940 --> 00:30:34,679
prototype so it's just going to add

00:30:32,039 --> 00:30:37,049
these and then I want it to delegate any

00:30:34,679 --> 00:30:38,820
calls to those straight on to whatever

00:30:37,049 --> 00:30:40,890
the current closure excuse me to

00:30:38,820 --> 00:30:44,370
whatever the current scope is so call

00:30:40,890 --> 00:30:46,710
this dot scope for current closure and

00:30:44,370 --> 00:30:48,299
return that so again delegate is

00:30:46,710 --> 00:30:50,159
basically just creating push and pop

00:30:48,299 --> 00:30:51,900
methods for us on the closure registry

00:30:50,159 --> 00:30:53,940
prototype but it just delegates to

00:30:51,900 --> 00:30:56,520
whatever the current scope is which is

00:30:53,940 --> 00:30:57,720
what is on top of the registry now

00:30:56,520 --> 00:30:59,400
there's one other thing we haven't done

00:30:57,720 --> 00:31:01,500
here we're still in our funk

00:30:59,400 --> 00:31:04,620
implementation we're calling set and

00:31:01,500 --> 00:31:06,419
args we're calling it on this which is

00:31:04,620 --> 00:31:08,309
the closure registry it doesn't actually

00:31:06,419 --> 00:31:10,470
have access to these methods yet they're

00:31:08,309 --> 00:31:11,970
back on the scope well instead of

00:31:10,470 --> 00:31:13,350
copying those over

00:31:11,970 --> 00:31:14,760
be running an implementation here i'm

00:31:13,350 --> 00:31:17,220
going to make use of my little delegate

00:31:14,760 --> 00:31:23,100
helper again i'm going to delegate any

00:31:17,220 --> 00:31:27,840
calls to get set and args straight on to

00:31:23,100 --> 00:31:29,850
the registry and that should work so now

00:31:27,840 --> 00:31:31,950
whenever someone in close your registry

00:31:29,850 --> 00:31:33,570
tries to call get set or args it'll just

00:31:31,950 --> 00:31:38,040
Selig eight straight on to whatever the

00:31:33,570 --> 00:31:41,540
current closure is so this looks really

00:31:38,040 --> 00:31:43,890
really close let's see if it runs now

00:31:41,540 --> 00:31:45,900
cannot read property fork of undefined

00:31:43,890 --> 00:31:47,970
well we had one other thing we forgot to

00:31:45,900 --> 00:31:49,680
do so this means that scope for current

00:31:47,970 --> 00:31:51,510
closure is at some point returning

00:31:49,680 --> 00:31:53,100
undefined when we invoke it we don't

00:31:51,510 --> 00:31:55,620
want that that's going to be problematic

00:31:53,100 --> 00:31:58,440
that's because we start out our idea of

00:31:55,620 --> 00:32:00,960
scopes and closures without a global

00:31:58,440 --> 00:32:02,970
scope notice that the registry stack

00:32:00,960 --> 00:32:05,190
step starts out empty what we need to

00:32:02,970 --> 00:32:07,050
fix that all we need to do then is a day

00:32:05,190 --> 00:32:09,420
starting condition which is going to be

00:32:07,050 --> 00:32:11,940
to create a brand new scope and this is

00:32:09,420 --> 00:32:13,950
going to be our global scope just to

00:32:11,940 --> 00:32:15,450
start things off so we have a place to

00:32:13,950 --> 00:32:17,700
attach all these function bodies later

00:32:15,450 --> 00:32:20,070
on so we look really close to being done

00:32:17,700 --> 00:32:21,540
but well we kind of reference this fork

00:32:20,070 --> 00:32:23,460
function without defining it somehow I

00:32:21,540 --> 00:32:24,930
think that's going to be problematic so

00:32:23,460 --> 00:32:27,510
let's go on a little bit further and

00:32:24,930 --> 00:32:29,670
just write this last method scope for

00:32:27,510 --> 00:32:31,290
takes in no arguments and all it will do

00:32:29,670 --> 00:32:33,180
is it's going to create a brand new

00:32:31,290 --> 00:32:37,950
scope object so it is a constructor

00:32:33,180 --> 00:32:40,560
absorbs and initialize it to a

00:32:37,950 --> 00:32:42,840
dictionary using fork so this

00:32:40,560 --> 00:32:45,210
just returns a brand new scope object

00:32:42,840 --> 00:32:48,840
whose dictionary of local variables

00:32:45,210 --> 00:32:50,370
inherits from this current scope but of

00:32:48,840 --> 00:32:52,770
course our scope instructor doesn't take

00:32:50,370 --> 00:32:53,970
in a default dictionary so we'll have to

00:32:52,770 --> 00:32:56,160
do something like this so it can be

00:32:53,970 --> 00:33:03,000
taken in that was a lot of code let's

00:32:56,160 --> 00:33:06,030
see if it works nope not quite yet let's

00:33:03,000 --> 00:33:11,180
see what we did wrong this dot

00:33:06,030 --> 00:33:11,180
underscore registry dot length thank you

00:33:12,940 --> 00:33:17,330
alright let's see what's going on now

00:33:14,900 --> 00:33:21,020
cannot read property apply of undefined

00:33:17,330 --> 00:33:24,260
let's see where our other issue is no

00:33:21,020 --> 00:33:27,920
changes there do this Scott registry

00:33:24,260 --> 00:33:31,640
that looks correct let's go for current

00:33:27,920 --> 00:33:34,420
closure that looks fine when in doubt

00:33:31,640 --> 00:33:34,420
check get

00:33:44,190 --> 00:33:47,149
there's the issue

00:33:47,200 --> 00:33:50,940
I swap these up a little bit

00:33:55,850 --> 00:34:04,400
it runs so in let's see how many lines

00:33:59,480 --> 00:34:07,460
of code this was 68 lines of code so in

00:34:04,400 --> 00:34:09,590
less than 70 in 68 lines of code and you

00:34:07,460 --> 00:34:11,090
can actually trim this down to 67 we

00:34:09,590 --> 00:34:13,700
have our own implementation of local

00:34:11,090 --> 00:34:15,980
variables enclosures in JavaScript so

00:34:13,700 --> 00:34:18,230
you too can do this now some of you may

00:34:15,980 --> 00:34:19,639
be asking can I actually use this where

00:34:18,230 --> 00:34:21,679
would I go to use this and how can I

00:34:19,639 --> 00:34:23,179
mass convert all my code over to use

00:34:21,679 --> 00:34:25,159
this much more performant version of

00:34:23,179 --> 00:34:27,800
closures well there's a transpiler for

00:34:25,159 --> 00:34:30,980
it go to github github.com / nibbler

00:34:27,800 --> 00:34:33,470
that's six continents / closures and you

00:34:30,980 --> 00:34:35,330
can go try this particular demo online

00:34:33,470 --> 00:34:37,220
where you drop in any code that use

00:34:35,330 --> 00:34:38,750
variable assignments and lookups or

00:34:37,220 --> 00:34:41,090
function assignments and we'll convert

00:34:38,750 --> 00:34:43,850
it over to the appropriate code which

00:34:41,090 --> 00:34:46,340
uses f SN g yes this is a transpiler it

00:34:43,850 --> 00:34:48,500
is not doing regular expression math

00:34:46,340 --> 00:34:50,690
substitutions so this should generate

00:34:48,500 --> 00:34:52,460
usable code if you don't hit any of the

00:34:50,690 --> 00:34:55,070
edge conditions that i explicitly mark

00:34:52,460 --> 00:34:57,380
out so your next question may be should

00:34:55,070 --> 00:34:58,910
i actually use this well javascript and

00:34:57,380 --> 00:35:00,380
java script is a great way to get

00:34:58,910 --> 00:35:01,700
brownie points with your next employer

00:35:00,380 --> 00:35:03,560
so next time you're thinking about

00:35:01,700 --> 00:35:05,630
writing some uninteresting legacy code

00:35:03,560 --> 00:35:07,820
at your next job just so you can flee

00:35:05,630 --> 00:35:09,530
from it later on drop in your own

00:35:07,820 --> 00:35:13,250
implementation of closures and you'll

00:35:09,530 --> 00:35:14,780
have guaranteed job security and then

00:35:13,250 --> 00:35:16,160
your final question may really be is

00:35:14,780 --> 00:35:18,380
this the future of performance

00:35:16,160 --> 00:35:19,730
JavaScript and this is the first step

00:35:18,380 --> 00:35:21,980
the next step is going to be to

00:35:19,730 --> 00:35:24,200
re-implement prototypes with closures at

00:35:21,980 --> 00:35:27,350
which point we'll get an even faster

00:35:24,200 --> 00:35:30,560
tick in our benchmarks and the idea is

00:35:27,350 --> 00:35:33,250
to use eval scripts to get this working

00:35:30,560 --> 00:35:35,570
and I think the other one was to

00:35:33,250 --> 00:35:36,740
completely drop out prototypes and we're

00:35:35,570 --> 00:35:38,270
going to do that which is plain old

00:35:36,740 --> 00:35:40,250
closures which are evaluating a script

00:35:38,270 --> 00:35:41,750
so totally we're just going to swap out

00:35:40,250 --> 00:35:43,220
these two concepts because prototypes

00:35:41,750 --> 00:35:45,530
are faster closures and closures are

00:35:43,220 --> 00:35:47,359
faster at prototypes so with that I

00:35:45,530 --> 00:35:51,640
think you have all you need to make your

00:35:47,359 --> 00:35:51,640
code much more performant thanks guys

00:36:17,900 --> 00:36:19,960

YouTube URL: https://www.youtube.com/watch?v=zpD2R2iXiiU


