Title: Sebastian McKenzie: JavaScript Transformation | JSConf US 2015
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	I made the open source project Babel and will be presenting on how JavaScript transformation and ES6 can help improve developer workflow and how it can futureproof their code. Not only transpilation to ES6 but how Babel has support for Flow, JSX and React so it can be integrated into many workflows extremely nicely. There are many challenges associated with transforming JavaScript as well as AST manipulation that I think would be extremely beneficial for the average developer to know about. There's even crazy stuff like transpiling proxies/Object.observe which wraps every single expression in a method.
Captions: 
	00:00:15,150 --> 00:00:20,380
hi my name is Esther McKenzie I work on

00:00:18,490 --> 00:00:22,980
web content optimization and CloudFlare

00:00:20,380 --> 00:00:25,180
so I work on making websites faster

00:00:22,980 --> 00:00:25,630
monitoring performance that kind of

00:00:25,180 --> 00:00:27,369
thing

00:00:25,630 --> 00:00:29,860
so what I'm going to be talking to you

00:00:27,369 --> 00:00:32,829
about to you today about is JavaScript

00:00:29,860 --> 00:00:35,500
transformation so what is JavaScript

00:00:32,829 --> 00:00:37,899
transformation well you put JavaScript

00:00:35,500 --> 00:00:39,760
in and you get javascript out the

00:00:37,899 --> 00:00:42,070
generated output is determined by

00:00:39,760 --> 00:00:44,560
contextual information based on what you

00:00:42,070 --> 00:00:46,660
put in so it like statically checks and

00:00:44,560 --> 00:00:49,650
infer as kind of what the code does and

00:00:46,660 --> 00:00:53,829
then transforms it as such into the

00:00:49,650 --> 00:00:56,560
output JavaScript so first off let me

00:00:53,829 --> 00:00:59,520
explain some history so there was this

00:00:56,560 --> 00:01:02,140
thing new thing called es6 now es2015

00:00:59,520 --> 00:01:04,420
there was a large gap my knowledge arm

00:01:02,140 --> 00:01:06,970
passes compilers and generally the

00:01:04,420 --> 00:01:09,490
intricacies of JavaScript so I decided

00:01:06,970 --> 00:01:13,270
to make an a s-six transpiler to learn

00:01:09,490 --> 00:01:15,130
it called six-to-five unfortunately this

00:01:13,270 --> 00:01:18,159
wasn't a very good name people started

00:01:15,130 --> 00:01:20,920
to use it and 65 already supported like

00:01:18,159 --> 00:01:23,069
bleeding edge as7 stuff so it would have

00:01:20,920 --> 00:01:25,719
required a name change to seven to five

00:01:23,069 --> 00:01:28,350
and then once es6 became mainstream

00:01:25,719 --> 00:01:33,240
would have been had to be changed to 76

00:01:28,350 --> 00:01:33,240
but then es6 was renamed T as 2015

00:01:34,360 --> 00:01:39,860
so this obviously wouldn't be in very

00:01:37,250 --> 00:01:41,300
practical so in order to keep up with

00:01:39,860 --> 00:01:44,510
the rapid pace of the web the name was

00:01:41,300 --> 00:01:47,720
changed to babble with this name change

00:01:44,510 --> 00:01:49,520
on not only came like the sense of

00:01:47,720 --> 00:01:52,220
permanence where future versions be

00:01:49,520 --> 00:01:54,140
supported but the scope of the project

00:01:52,220 --> 00:01:57,260
was kind of expanded to be a more

00:01:54,140 --> 00:01:58,910
general JavaScript compiler I'll go into

00:01:57,260 --> 00:01:59,780
a bit more detail on what that actually

00:01:58,910 --> 00:02:02,120
means

00:01:59,780 --> 00:02:04,370
but basically different types of tools

00:02:02,120 --> 00:02:06,890
could be built on top of Babel and there

00:02:04,370 --> 00:02:08,780
be future-proof so what does that mean

00:02:06,890 --> 00:02:10,940
so for example if you build a minnow

00:02:08,780 --> 00:02:13,520
fire on top of Babel I mean some cool

00:02:10,940 --> 00:02:15,350
new ears feature came out as long as

00:02:13,520 --> 00:02:16,850
Babel supported it everything that was

00:02:15,350 --> 00:02:19,790
built on it or used it would support it

00:02:16,850 --> 00:02:21,650
too so to give some context on why this

00:02:19,790 --> 00:02:24,950
is neat I need kind of understand a bit

00:02:21,650 --> 00:02:27,050
about how it works so you have some

00:02:24,950 --> 00:02:29,120
source code cool

00:02:27,050 --> 00:02:31,459
how can I deal with this how would you

00:02:29,120 --> 00:02:33,140
throw a regex at it no not really

00:02:31,459 --> 00:02:35,660
there are way too many variations of

00:02:33,140 --> 00:02:38,060
syntax in order to kind of do anything

00:02:35,660 --> 00:02:39,950
good with just regular expressions so

00:02:38,060 --> 00:02:41,230
you need to represent this code in a

00:02:39,950 --> 00:02:44,690
data structure that you can deal with

00:02:41,230 --> 00:02:49,400
called in abstract syntax tree or AST

00:02:44,690 --> 00:02:51,860
for sure so this is the AST for the

00:02:49,400 --> 00:02:53,930
previous code it's a group of deeply

00:02:51,860 --> 00:02:57,230
nested objects that expressively define

00:02:53,930 --> 00:02:59,690
each syntactic element so each property

00:02:57,230 --> 00:03:02,120
of these nodes contains metadata about

00:02:59,690 --> 00:03:03,530
what it represents so this may kind of

00:03:02,120 --> 00:03:07,940
seem intimidating but an easy way to

00:03:03,530 --> 00:03:10,850
visualize this is via a tree so it is

00:03:07,940 --> 00:03:13,280
the T in AST after all so as I said

00:03:10,850 --> 00:03:15,170
before each syntactic element represents

00:03:13,280 --> 00:03:17,239
a node so now that you've got some

00:03:15,170 --> 00:03:19,220
context on what an ast is it's the data

00:03:17,239 --> 00:03:21,380
structure that we deal with when we're

00:03:19,220 --> 00:03:24,590
dealing with code it's easier to

00:03:21,380 --> 00:03:26,299
understand each component of Babel so

00:03:24,590 --> 00:03:29,390
this split up into three very distinct

00:03:26,299 --> 00:03:32,060
areas so you have the parser that turns

00:03:29,390 --> 00:03:33,650
your raw code into an AST or some parses

00:03:32,060 --> 00:03:36,110
it to the transformer to manipulate

00:03:33,650 --> 00:03:38,530
manipulate then on to the generator to

00:03:36,110 --> 00:03:41,090
turn back into code that you can execute

00:03:38,530 --> 00:03:43,220
and so this graph is more to scale that

00:03:41,090 --> 00:03:45,829
well most of the time in Babel is spent

00:03:43,220 --> 00:03:47,740
and where the smarts and car logic

00:03:45,829 --> 00:03:50,480
actually is

00:03:47,740 --> 00:03:52,790
so the transformer is mostly where the

00:03:50,480 --> 00:03:54,350
tricky stuff happens and in order to

00:03:52,790 --> 00:03:58,000
understand the core concept of the

00:03:54,350 --> 00:04:00,380
transformer is to understand traversal

00:03:58,000 --> 00:04:02,270
so traversal is where you have a tree

00:04:00,380 --> 00:04:03,530
represented by the red nodes and then

00:04:02,270 --> 00:04:05,690
you have a visitor represented by the

00:04:03,530 --> 00:04:07,459
blue node and you want to visit all

00:04:05,690 --> 00:04:11,239
these nodes so basically it happened

00:04:07,459 --> 00:04:13,040
like this so you would visit program the

00:04:11,239 --> 00:04:15,830
variable declaration and then you keep

00:04:13,040 --> 00:04:18,680
on continuing through the entire tree

00:04:15,830 --> 00:04:20,570
I'm going at any points additional nodes

00:04:18,680 --> 00:04:24,350
could pop into existence or no to be

00:04:20,570 --> 00:04:26,510
deleted and this can be tricky so if

00:04:24,350 --> 00:04:30,890
you're replacing a set of valid nodes

00:04:26,510 --> 00:04:32,840
with a set of invalid nodes so to make

00:04:30,890 --> 00:04:34,790
kind of this a bit easier bubble is

00:04:32,840 --> 00:04:40,250
aware of JavaScript semantics so it can

00:04:34,790 --> 00:04:42,590
understand what JavaScript means so what

00:04:40,250 --> 00:04:45,380
does this kind of mean so here's an

00:04:42,590 --> 00:04:48,350
example here you've got an array

00:04:45,380 --> 00:04:50,419
destructuring assignment this this

00:04:48,350 --> 00:04:52,790
should execute calculate coordinates and

00:04:50,419 --> 00:04:54,800
assign the values of x and y to the 0

00:04:52,790 --> 00:04:56,720
and 1 index of the result of the

00:04:54,800 --> 00:04:59,990
function call so this would look

00:04:56,720 --> 00:05:02,330
something like this so yeah this works

00:04:59,990 --> 00:05:05,090
it's in a statement position but what if

00:05:02,330 --> 00:05:08,060
we use the exact same transformer on an

00:05:05,090 --> 00:05:09,650
expression so this should do the same as

00:05:08,060 --> 00:05:11,720
before but the resulting value should be

00:05:09,650 --> 00:05:14,539
the right hand side so it should be the

00:05:11,720 --> 00:05:16,100
result of calculate coordinates so if

00:05:14,539 --> 00:05:19,250
you use the exact same transformer on

00:05:16,100 --> 00:05:20,900
that code it would output this which is

00:05:19,250 --> 00:05:22,370
obviously invalid you're trying to

00:05:20,900 --> 00:05:24,710
replace an expression with a list of

00:05:22,370 --> 00:05:27,440
statements and what does this even mean

00:05:24,710 --> 00:05:29,900
so JavaScript stems and expressions of

00:05:27,440 --> 00:05:33,169
different things but in Babel that kind

00:05:29,900 --> 00:05:35,780
of equivalent so it can tell kind of

00:05:33,169 --> 00:05:38,000
what you're doing and explode that into

00:05:35,780 --> 00:05:41,750
this so that's the exact same

00:05:38,000 --> 00:05:44,840
transformer is so it's written only from

00:05:41,750 --> 00:05:47,060
one context and it's can support many

00:05:44,840 --> 00:05:50,270
just based on inferring information

00:05:47,060 --> 00:05:52,100
about it and one of the other things

00:05:50,270 --> 00:05:53,690
that you made so replacement is one of

00:05:52,100 --> 00:05:57,530
the things you find yourself doing to

00:05:53,690 --> 00:05:59,720
the tree and the other is removal so

00:05:57,530 --> 00:06:00,770
here we have left + right is represented

00:05:59,720 --> 00:06:03,110
by a binary expression

00:06:00,770 --> 00:06:05,000
and say you won't remove the rat node so

00:06:03,110 --> 00:06:06,680
typically you'd get something like this

00:06:05,000 --> 00:06:11,449
scissors have left and missing a right

00:06:06,680 --> 00:06:13,370
node this is invalid and so so babble

00:06:11,449 --> 00:06:16,699
can tell or hey you're there's no right

00:06:13,370 --> 00:06:20,060
hand side so it just places with this so

00:06:16,699 --> 00:06:22,460
it's kind of powerful so that you just

00:06:20,060 --> 00:06:24,319
ride it for one context and the

00:06:22,460 --> 00:06:26,960
internals kind of handle it for you so

00:06:24,319 --> 00:06:29,419
it reduces a lot of bugs where you know

00:06:26,960 --> 00:06:31,520
repeating constantly each specific

00:06:29,419 --> 00:06:35,630
scenario that something can appear in

00:06:31,520 --> 00:06:37,940
and so there's a lot of applications for

00:06:35,630 --> 00:06:40,159
this it's extremely wide from browser

00:06:37,940 --> 00:06:42,500
compatibility to module mocking to

00:06:40,159 --> 00:06:46,060
profiling so it's more or less the same

00:06:42,500 --> 00:06:48,110
thing javascript in and javascript out

00:06:46,060 --> 00:06:50,060
so today i'm going to be focusing on

00:06:48,110 --> 00:06:53,259
four different areas translation so

00:06:50,060 --> 00:06:55,610
es2015 to es 5 application optimization

00:06:53,259 --> 00:06:58,240
browsing availability and a mystery use

00:06:55,610 --> 00:07:02,180
case which is by and large my favorite

00:06:58,240 --> 00:07:03,889
so first and foremost is translation so

00:07:02,180 --> 00:07:06,800
there's this new fancy thing called es

00:07:03,889 --> 00:07:09,310
2015 it adds a ton of new features from

00:07:06,800 --> 00:07:11,960
arrow functions as hell calls

00:07:09,310 --> 00:07:14,090
unfortunately browser support is fairly

00:07:11,960 --> 00:07:15,710
poor I mean it's entirely new standard

00:07:14,090 --> 00:07:17,000
these features are incredibly

00:07:15,710 --> 00:07:19,009
complicated to implement in modern

00:07:17,000 --> 00:07:20,719
engines and even when modern engine

00:07:19,009 --> 00:07:22,610
modern browsers do support the whole

00:07:20,719 --> 00:07:23,930
range of features there's always going

00:07:22,610 --> 00:07:25,699
to be mosaics of the world more

00:07:23,930 --> 00:07:29,090
importantly mobile browsers that rarely

00:07:25,699 --> 00:07:31,069
get updated in an accessible and open

00:07:29,090 --> 00:07:32,740
web it seems ridiculous how to limit

00:07:31,069 --> 00:07:35,150
yourself to the latest greatest browsers

00:07:32,740 --> 00:07:40,250
and so one of these new fancy features

00:07:35,150 --> 00:07:41,750
is es 2015 error functions so these are

00:07:40,250 --> 00:07:43,639
a different way to write functions

00:07:41,750 --> 00:07:45,159
I picked this feature specifically

00:07:43,639 --> 00:07:48,199
because it's seemingly straightforward

00:07:45,159 --> 00:07:50,389
how to transpile this but there are kind

00:07:48,199 --> 00:07:53,449
of some hitting gotchas associated with

00:07:50,389 --> 00:07:56,690
where it's not perfect so these are the

00:07:53,449 --> 00:07:59,330
four kind of main semantics of error

00:07:56,690 --> 00:08:01,789
functions it has an implicit return for

00:07:59,330 --> 00:08:03,650
expression bodies it inherits the

00:08:01,789 --> 00:08:07,310
arguments and this binding so you cannot

00:08:03,650 --> 00:08:09,979
new it and it has no prototype so for

00:08:07,310 --> 00:08:12,680
this example it turns the multiple disk

00:08:09,979 --> 00:08:14,580
into a return at this stage it's just

00:08:12,680 --> 00:08:17,490
kind of just syntax handy on

00:08:14,580 --> 00:08:19,409
around it so yes we can do implicit

00:08:17,490 --> 00:08:24,120
return for expression bodies but what

00:08:19,409 --> 00:08:27,270
about arguments in this well so we've

00:08:24,120 --> 00:08:29,280
got this it's meant to reference Bob but

00:08:27,270 --> 00:08:31,199
if it was just a normal function it

00:08:29,280 --> 00:08:34,440
would reference this top friends so in

00:08:31,199 --> 00:08:37,289
order to retain the same this binding

00:08:34,440 --> 00:08:39,450
you can just simply add the decorator at

00:08:37,289 --> 00:08:41,640
a reference of this and then replace the

00:08:39,450 --> 00:08:45,480
this inner functions to reference that

00:08:41,640 --> 00:08:48,149
temporary variable so we can inherit the

00:08:45,480 --> 00:08:48,690
arguments and this bindings but now for

00:08:48,149 --> 00:08:52,170
the bad news

00:08:48,690 --> 00:08:55,890
what about not being able to new it so

00:08:52,170 --> 00:08:57,480
in es2015 this should be illegal arrow

00:08:55,890 --> 00:08:59,730
functions aren't completely synonymous

00:08:57,480 --> 00:09:01,380
with normal functions I mean if it was

00:08:59,730 --> 00:09:03,360
there wouldn't really be much excuse to

00:09:01,380 --> 00:09:04,800
have it in the language and since we're

00:09:03,360 --> 00:09:08,100
just telling our functions into normal

00:09:04,800 --> 00:09:10,829
functions it works so one of the ways we

00:09:08,100 --> 00:09:12,540
could do this is by adding a name to the

00:09:10,829 --> 00:09:14,190
function so underscore error and then

00:09:12,540 --> 00:09:16,950
replacing all new expressions with this

00:09:14,190 --> 00:09:22,500
help a method that checks to save the

00:09:16,950 --> 00:09:24,630
name of the function is um spa error but

00:09:22,500 --> 00:09:25,980
what if you're relying on the name of an

00:09:24,630 --> 00:09:28,199
error function so if you don't name

00:09:25,980 --> 00:09:31,260
should be foo not an underscore error so

00:09:28,199 --> 00:09:33,750
you're trying to implement specific

00:09:31,260 --> 00:09:37,170
semantics by introducing bad ones as

00:09:33,750 --> 00:09:41,490
well so it's kind of or you could add a

00:09:37,170 --> 00:09:43,649
property and just use that and then in

00:09:41,490 --> 00:09:47,120
the construct helper check to see if it

00:09:43,649 --> 00:09:49,920
has the underscore our property this is

00:09:47,120 --> 00:09:51,839
it's kind of crap so in the first

00:09:49,920 --> 00:09:54,120
example we're adding the wrong name to

00:09:51,839 --> 00:09:56,850
the function and in the second we added

00:09:54,120 --> 00:09:58,380
a property even if this was practical it

00:09:56,850 --> 00:10:01,110
only really affects code that we've

00:09:58,380 --> 00:10:03,649
compiled so all third-party code that

00:10:01,110 --> 00:10:07,430
would execute it it would work normally

00:10:03,649 --> 00:10:09,959
so it's kind of iffy we can't completely

00:10:07,430 --> 00:10:12,390
replicate at least not practically some

00:10:09,959 --> 00:10:16,470
of these features and semantics so we

00:10:12,390 --> 00:10:19,699
can't not allow people to do it at least

00:10:16,470 --> 00:10:22,440
not practically what about no prototype

00:10:19,699 --> 00:10:26,310
so as I said before our functions aren't

00:10:22,440 --> 00:10:28,110
normal functions they so they have no

00:10:26,310 --> 00:10:30,660
prototype so you can't use them

00:10:28,110 --> 00:10:32,399
constructors so since we just turn them

00:10:30,660 --> 00:10:35,279
into normal functions how could we get

00:10:32,399 --> 00:10:37,529
the same behavior so we need some way to

00:10:35,279 --> 00:10:39,660
mark it as an arrow function in this

00:10:37,529 --> 00:10:41,730
case we add a property and then we

00:10:39,660 --> 00:10:44,430
change all references to just dot

00:10:41,730 --> 00:10:46,079
prototype to use this helper method that

00:10:44,430 --> 00:10:48,420
checks see if its function if it is

00:10:46,079 --> 00:10:52,050
returned undefined otherwise just return

00:10:48,420 --> 00:10:54,089
the prototype um this is problematic

00:10:52,050 --> 00:10:57,390
since Java scripts of dynamic language

00:10:54,089 --> 00:11:00,209
so it could be like this it's kind of

00:10:57,390 --> 00:11:02,220
difficult to catch so this means that

00:11:00,209 --> 00:11:04,500
you have to wrap every single property

00:11:02,220 --> 00:11:06,450
access computed property access to

00:11:04,500 --> 00:11:09,899
determine whether or not it's ever going

00:11:06,450 --> 00:11:11,430
to access prototype so you end up with

00:11:09,899 --> 00:11:12,779
something like this

00:11:11,430 --> 00:11:15,360
it's going to add a lot of additional

00:11:12,779 --> 00:11:17,850
overhead especially in hot code where

00:11:15,360 --> 00:11:20,850
performance is extremely critical it's

00:11:17,850 --> 00:11:23,310
not really ideal you're really

00:11:20,850 --> 00:11:27,000
implementing a lot of native JavaScript

00:11:23,310 --> 00:11:29,880
features that are kind of unnecessary so

00:11:27,000 --> 00:11:31,290
this is even worse the main wrapping or

00:11:29,880 --> 00:11:33,300
code that we think is dynamic with

00:11:31,290 --> 00:11:35,550
helpers so at this point were like a

00:11:33,300 --> 00:11:37,470
little engine that could you can almost

00:11:35,550 --> 00:11:38,640
get there you're so close but there are

00:11:37,470 --> 00:11:41,310
some things that you can't really

00:11:38,640 --> 00:11:42,839
practically implement using just a s5

00:11:41,310 --> 00:11:45,930
especially if you want really good

00:11:42,839 --> 00:11:47,519
performance so what is this mean for the

00:11:45,930 --> 00:11:49,709
average developer that's currently

00:11:47,519 --> 00:11:51,930
transpiring what would the migration

00:11:49,709 --> 00:11:55,459
path be like from transpiled es6 to

00:11:51,930 --> 00:11:57,870
normal es6 it'll likely be smooth but

00:11:55,459 --> 00:12:01,320
you know like if you're relying on some

00:11:57,870 --> 00:12:02,640
of these unspecified semantics split

00:12:01,320 --> 00:12:05,519
that the transpiler

00:12:02,640 --> 00:12:07,380
will kind of destroy then you may you're

00:12:05,519 --> 00:12:08,519
likely to run into issues but it's

00:12:07,380 --> 00:12:12,390
better than nothing

00:12:08,519 --> 00:12:14,850
and so following this kind of want to

00:12:12,390 --> 00:12:16,170
emphasize this point where you shouldn't

00:12:14,850 --> 00:12:19,410
be using transpilers to learn new

00:12:16,170 --> 00:12:21,209
language features you can definitely

00:12:19,410 --> 00:12:24,720
like compare the output but if you're

00:12:21,209 --> 00:12:26,070
just basing all of your knowledge on new

00:12:24,720 --> 00:12:27,839
language features on hey this is

00:12:26,070 --> 00:12:29,339
equivalent in es5 so it's exactly the

00:12:27,839 --> 00:12:30,660
same then you're likely going to be

00:12:29,339 --> 00:12:32,670
misinformed since there's a lot of

00:12:30,660 --> 00:12:36,810
hidden semantics that can't properly be

00:12:32,670 --> 00:12:38,190
replicated and even like stuff like

00:12:36,810 --> 00:12:40,440
referencing a variable can drastically

00:12:38,190 --> 00:12:44,070
change the way that the

00:12:40,440 --> 00:12:46,770
it is generated and so yeah it's it's

00:12:44,070 --> 00:12:50,280
really contextual so you shouldn't

00:12:46,770 --> 00:12:51,690
really be relying on transpilers to

00:12:50,280 --> 00:12:54,890
learn your language features so what

00:12:51,690 --> 00:12:57,690
about something a little more practical

00:12:54,890 --> 00:13:00,630
application optimization at face value

00:12:57,690 --> 00:13:01,440
this may seem like an eclaim but allow

00:13:00,630 --> 00:13:03,360
me to elaborate

00:13:01,440 --> 00:13:06,750
so the preface is so I have to talk

00:13:03,360 --> 00:13:09,270
about compile time versus run time so

00:13:06,750 --> 00:13:11,280
when you're compiling your code it so at

00:13:09,270 --> 00:13:12,930
compile time it's only compiling your

00:13:11,280 --> 00:13:15,540
code that hasn't even been executed yet

00:13:12,930 --> 00:13:16,950
and run time is when your code is

00:13:15,540 --> 00:13:18,660
actually running so when it's executing

00:13:16,950 --> 00:13:20,490
and you simply know different things at

00:13:18,660 --> 00:13:22,590
different times so when you're compiling

00:13:20,490 --> 00:13:24,780
the code you can determine that Square

00:13:22,590 --> 00:13:26,610
is called with a two literal and then

00:13:24,780 --> 00:13:29,970
and then Square is called the M with

00:13:26,610 --> 00:13:32,070
just a variable at runtime you can't

00:13:29,970 --> 00:13:33,510
determine the square function can't

00:13:32,070 --> 00:13:34,740
determine what it's being called with

00:13:33,510 --> 00:13:36,630
since it only cares about the actual

00:13:34,740 --> 00:13:39,330
value not kind of where it came from or

00:13:36,630 --> 00:13:40,830
how it was represented so this is

00:13:39,330 --> 00:13:44,510
extremely useful so we can determine

00:13:40,830 --> 00:13:47,610
what the exact intent of the code was

00:13:44,510 --> 00:13:50,790
this is so what are some examples of

00:13:47,610 --> 00:13:53,010
this so a big one is reiax

00:13:50,790 --> 00:13:58,410
you may have heard of it it has a neat

00:13:53,010 --> 00:14:00,270
feature or well feature JSX which is xml

00:13:58,410 --> 00:14:00,540
like syntax you either love it or hate

00:14:00,270 --> 00:14:02,910
it

00:14:00,540 --> 00:14:05,160
it is however good for one thing which

00:14:02,910 --> 00:14:06,720
is writing additional language semantics

00:14:05,160 --> 00:14:08,280
now traditionally it's really just being

00:14:06,720 --> 00:14:10,350
syntax handy so it's been like a

00:14:08,280 --> 00:14:14,070
one-to-one mapping to your function

00:14:10,350 --> 00:14:16,560
calls but in Reax 0.14 JSX elements are

00:14:14,070 --> 00:14:18,030
treated as constant value types so if it

00:14:16,560 --> 00:14:19,560
looks the same then we'll always return

00:14:18,030 --> 00:14:21,860
the same value so whenever you call

00:14:19,560 --> 00:14:25,320
render it will return the exact same

00:14:21,860 --> 00:14:27,270
instance so this is extremely important

00:14:25,320 --> 00:14:28,860
for performance since why you're

00:14:27,270 --> 00:14:31,770
constantly doing more work than you have

00:14:28,860 --> 00:14:33,210
to so this would be turn in something

00:14:31,770 --> 00:14:35,580
like this so it'd be hosted to the

00:14:33,210 --> 00:14:37,650
highest paper that could and then just

00:14:35,580 --> 00:14:40,200
return free would be done in the render

00:14:37,650 --> 00:14:43,040
method so each time you called through a

00:14:40,200 --> 00:14:46,530
render story it would return the same

00:14:43,040 --> 00:14:48,780
element so this works for immutable

00:14:46,530 --> 00:14:51,330
elements but this enough to be applied

00:14:48,780 --> 00:14:53,889
to readable ones as well so here the

00:14:51,330 --> 00:14:55,480
react the JSX element you

00:14:53,889 --> 00:14:58,239
as references the fruit and text

00:14:55,480 --> 00:15:02,549
variables and so that can be wasted to

00:14:58,239 --> 00:15:05,040
the create component function like so um

00:15:02,549 --> 00:15:07,720
and so the core concept is just

00:15:05,040 --> 00:15:10,269
pre-processing and making the JavaScript

00:15:07,720 --> 00:15:12,669
engine do less since doing less is

00:15:10,269 --> 00:15:14,949
generally faster and JavaScript engines

00:15:12,669 --> 00:15:18,009
have no way to infer this kind of

00:15:14,949 --> 00:15:21,059
behavior you have to tell it basically

00:15:18,009 --> 00:15:25,359
using this kind of techniques

00:15:21,059 --> 00:15:27,309
another example is M Bo so amber uses

00:15:25,359 --> 00:15:29,230
HTML bars now you may want to use these

00:15:27,309 --> 00:15:31,569
embedded in files in like stuff like

00:15:29,230 --> 00:15:33,790
tests it seems silly to have to

00:15:31,569 --> 00:15:35,379
constantly compile this every single

00:15:33,790 --> 00:15:39,639
time the credits run since this is

00:15:35,379 --> 00:15:42,309
static and like it's constant so there's

00:15:39,639 --> 00:15:44,049
no reason to really be making the client

00:15:42,309 --> 00:15:46,089
to it each and every time so you should

00:15:44,049 --> 00:15:47,319
be doing it when the when you're

00:15:46,089 --> 00:15:50,429
processing when you're building your

00:15:47,319 --> 00:15:53,619
JavaScript and so you can determine that

00:15:50,429 --> 00:15:55,749
tagged the the template and then compile

00:15:53,619 --> 00:15:57,160
it when you're pre processing it into

00:15:55,749 --> 00:16:02,429
something like that where the comment

00:15:57,160 --> 00:16:04,899
represents the actual template contents

00:16:02,429 --> 00:16:07,660
so the main points that I want to take

00:16:04,899 --> 00:16:09,669
away from this you shouldn't be relying

00:16:07,660 --> 00:16:12,449
on pre-processing for functionality so

00:16:09,669 --> 00:16:14,889
like this type of stuff should purely be

00:16:12,449 --> 00:16:17,079
supplementary instead of additive so it

00:16:14,889 --> 00:16:19,029
shouldn't be it should it shouldn't

00:16:17,079 --> 00:16:21,629
really be changing the way that the code

00:16:19,029 --> 00:16:23,889
works it should just making it faster or

00:16:21,629 --> 00:16:25,360
removing things that kind of don't

00:16:23,889 --> 00:16:27,850
matter since your code may not care

00:16:25,360 --> 00:16:29,769
about it and you're the only one who can

00:16:27,850 --> 00:16:31,449
make assumptions about your code the

00:16:29,769 --> 00:16:33,970
JavaScript engine copy more lenient it

00:16:31,449 --> 00:16:35,259
can't not do things if you tell it to do

00:16:33,970 --> 00:16:39,009
something it has to do it so you have to

00:16:35,259 --> 00:16:43,989
tell it to do less so the next item is

00:16:39,009 --> 00:16:45,610
browsing a pad ability it's a basically

00:16:43,989 --> 00:16:48,009
it's just trying to patch broken browser

00:16:45,610 --> 00:16:49,929
implementations of certain pages so this

00:16:48,009 --> 00:16:52,629
isn't relevant really in newer browsers

00:16:49,929 --> 00:16:54,809
but there's some things that in older

00:16:52,629 --> 00:16:58,269
browsers that are just completely broken

00:16:54,809 --> 00:16:59,139
sir Internet Explorer 8 who would have

00:16:58,269 --> 00:17:03,519
thought this would've been one of the

00:16:59,139 --> 00:17:04,809
browsers that was broken so there's an

00:17:03,519 --> 00:17:06,610
issue with named function expressions

00:17:04,809 --> 00:17:07,100
here we declare a variable with the

00:17:06,610 --> 00:17:10,730
function

00:17:07,100 --> 00:17:13,039
Russian note that it is named and then

00:17:10,730 --> 00:17:14,360
online to that it's leaking out so it's

00:17:13,039 --> 00:17:16,870
kinda been treated as a function

00:17:14,360 --> 00:17:19,069
declaration and then on line three it's

00:17:16,870 --> 00:17:26,209
trading two different bindings with two

00:17:19,069 --> 00:17:29,840
different objects what so it HAP what's

00:17:26,209 --> 00:17:31,640
the solution you automate it you fix it

00:17:29,840 --> 00:17:33,710
so this is a babel plugin that will

00:17:31,640 --> 00:17:35,750
change or name function expressions into

00:17:33,710 --> 00:17:37,850
an immediately invoked function that

00:17:35,750 --> 00:17:40,850
turns the function into a declaration

00:17:37,850 --> 00:17:42,169
then returns that declaration so this

00:17:40,850 --> 00:17:44,750
may is somewhat comprehend it actually

00:17:42,169 --> 00:17:48,440
is but this is basically what it does it

00:17:44,750 --> 00:17:50,090
turns the the function the name function

00:17:48,440 --> 00:17:51,980
expression into this emailing invoked

00:17:50,090 --> 00:17:53,150
function a return turns into a function

00:17:51,980 --> 00:17:55,789
declaration than then returns our

00:17:53,150 --> 00:17:59,570
function declaration so that basically

00:17:55,789 --> 00:18:03,770
fixes the buggy behavior of insects per

00:17:59,570 --> 00:18:06,650
eight so the last mystery application of

00:18:03,770 --> 00:18:09,559
javascript transformation is a mirja

00:18:06,650 --> 00:18:12,350
fication I have no idea if that's an

00:18:09,559 --> 00:18:16,840
actual word but I think it is now

00:18:12,350 --> 00:18:19,669
so is 2015 it has Unicode point escapes

00:18:16,840 --> 00:18:22,450
so you can do stuff like this where the

00:18:19,669 --> 00:18:25,630
variable declared our ID is a Unicode

00:18:22,450 --> 00:18:30,799
character so what does this really mean

00:18:25,630 --> 00:18:34,130
emojis so about this foreign code I took

00:18:30,799 --> 00:18:36,530
this from the jQuery sauce trimming

00:18:34,130 --> 00:18:40,220
letters and what can we do with this so

00:18:36,530 --> 00:18:42,710
we can convert this to this now here all

00:18:40,220 --> 00:18:45,740
the identifiers are escapes but have no

00:18:42,710 --> 00:18:49,150
fear they do represent emoji so unescape

00:18:45,740 --> 00:18:49,150
s-- it looks like this

00:18:56,950 --> 00:19:02,090
beautiful so don't even need comments at

00:19:00,740 --> 00:19:04,120
this stage you can just represent the

00:19:02,090 --> 00:19:09,470
intent of your variable is using emoji

00:19:04,120 --> 00:19:13,060
like so how can you do this well I made

00:19:09,470 --> 00:19:17,990
an NPM package you can install it and

00:19:13,060 --> 00:19:19,970
use it probably won't run in browsers

00:19:17,990 --> 00:19:21,260
since not many support or I'm not sure

00:19:19,970 --> 00:19:24,140
if there are any that's what Unicode

00:19:21,260 --> 00:19:31,720
point escapes for identifiers yet but

00:19:24,140 --> 00:19:36,080
the future so Java Script transformation

00:19:31,720 --> 00:19:38,270
JavaScript in JavaScript out hopefully

00:19:36,080 --> 00:19:40,010
by now kind of there's a lot of

00:19:38,270 --> 00:19:42,650
potential for extremely high quality

00:19:40,010 --> 00:19:45,140
tooling that not only evolves quickly

00:19:42,650 --> 00:19:47,210
but it's very stable that keeps up with

00:19:45,140 --> 00:19:53,030
the rapid pace of the web and as new

00:19:47,210 --> 00:19:55,780
features implemented yes sir that's it

00:19:53,030 --> 00:19:55,780

YouTube URL: https://www.youtube.com/watch?v=rKuNbEwoQfQ


