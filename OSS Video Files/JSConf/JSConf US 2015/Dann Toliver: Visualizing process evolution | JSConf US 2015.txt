Title: Dann Toliver: Visualizing process evolution | JSConf US 2015
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	What actually happens when your code is run? Our programs are simple text documents composed of patterns of rules, but the processes they guide aren't nearly as well behaved. Function scopes are generated, data is plumbed through pathways, bits are shifted and applications are evaluated. There's a lot of ins, a lot of outs. It's a very complicated case. We can gain some insight into the process with console.log and step-through debuggers, but we're left to develop a full program simulation in our minds based only on the code we wrote and the tiny snapshots our debugger gives us -- effectively requiring a JS interpreter to be compiled into our wetware. This can make it somewhat challenging to reason about our work. We'll look at some ways of remedying this, starting with basic data structures and tiptoeing toward full programs. Your code is the DNA for a process: let's build an illustrated anatomy guide.
Captions: 
	00:00:21,619 --> 00:00:22,630
I'd like to open with a quote.

00:00:22,630 --> 00:00:28,250
I read a book the other day, about speaking in public, and it said something about opening

00:00:28,250 --> 00:00:30,740
with a quote.

00:00:30,740 --> 00:00:33,070
Okay.

00:00:33,070 --> 00:00:34,070
It wasn't actually a book.

00:00:34,070 --> 00:00:35,870
It was a web page.

00:00:35,870 --> 00:00:38,260
It was called...

00:00:38,260 --> 00:00:43,370
Top ten things you should never do while giving a talk.

00:00:43,370 --> 00:00:45,340
But I'm going to open with a quote anyway.

00:00:45,340 --> 00:00:48,290
Because this is where it all started.

00:00:48,290 --> 00:00:56,670
We are about to study the idea of a computational process.

00:00:56,670 --> 00:00:58,780
Computational processes are abstract beings that

00:00:58,780 --> 00:01:01,010
inhabit computers.

00:01:01,010 --> 00:01:05,740
As they evolve, processes manipulate other abstract things,

00:01:05,740 --> 00:01:07,600
called data.

00:01:07,600 --> 00:01:11,050
The evolution of a process is directed by a pattern of rules

00:01:11,050 --> 00:01:13,110
called a program.

00:01:13,110 --> 00:01:15,759
People create programs to direct processes.

00:01:15,759 --> 00:01:21,310
In effect, we conjure the spirits of the computer with our

00:01:21,310 --> 00:01:23,000
spells.

00:01:23,000 --> 00:01:26,009
So when I first read that, two years ago, it was like something

00:01:26,009 --> 00:01:30,899
that had been misaligned suddenly snapped into place.

00:01:30,899 --> 00:01:36,649
This idea that the code that we write, the artifact that we're creating, and

00:01:36,649 --> 00:01:41,979
the process that unfurls in the system as that is being evaluated are two

00:01:41,979 --> 00:01:42,979
separate things.

00:01:42,979 --> 00:01:44,240
This is so simple.

00:01:44,240 --> 00:01:46,830
It's such a fundamental idea.

00:01:46,830 --> 00:01:50,789
But it's so easy to overlook.

00:01:50,789 --> 00:01:57,069
If our code is directing the evolution of a process, then in

00:01:57,069 --> 00:02:01,600
many ways it's a lot like the DNA in a cell, directing the evolution of that

00:02:01,600 --> 00:02:02,600
cell.

00:02:02,600 --> 00:02:06,320
But DNA is really the most boring part of the cell.

00:02:06,320 --> 00:02:11,210
It just sits there, curled up into little balls, being read, right?

00:02:11,210 --> 00:02:15,390
And all around it, there's this fantastic machinery that's involved in

00:02:15,390 --> 00:02:20,400
finding pieces of the DNA in a massively parallel way and unwrapping it and

00:02:20,400 --> 00:02:25,480
parsing it and opening it up and copying pieces out of it into RNA, jotting

00:02:25,480 --> 00:02:31,010
it down, and RNA goes into the rest of the cell and causes effects.

00:02:31,010 --> 00:02:35,410
Some of it gets pulled into ribosomes, which are these amazing molecular machines that

00:02:35,410 --> 00:02:40,191
kind of ratchet in a little bit of RNA and poop out a little bit of amino acid

00:02:40,191 --> 00:02:45,069
at the top, and they find the right amino acids to match that sequence of

00:02:45,069 --> 00:02:50,670
codons in the RNA and then they make this protein, which is like a data structure,

00:02:50,670 --> 00:02:52,290
that has active sites.

00:02:52,290 --> 00:02:53,930
It's like an object in JavaScript.

00:02:53,930 --> 00:02:55,550
And it causes effects on other things.

00:02:55,550 --> 00:02:57,750
And we can keep pushing this biological metaphor.

00:02:57,750 --> 00:03:03,549
But the point is that there's a party going on in there, and we weren't invited.

00:03:03,549 --> 00:03:08,700
I want to go to that party.

00:03:08,700 --> 00:03:12,280
So this talk is a series of three steps.

00:03:12,280 --> 00:03:15,359
Of me trying to find a path.

00:03:15,359 --> 00:03:18,379
To understand what's happening in this process, as it's

00:03:18,379 --> 00:03:19,379
evolving.

00:03:19,379 --> 00:03:21,269
Step one is data.

00:03:21,269 --> 00:03:25,709
Our data structures in JavaScript are becoming increasingly sophisticated.

00:03:25,709 --> 00:03:28,389
This is in response to our applications that we're

00:03:28,389 --> 00:03:32,790
developing, becoming increasingly sophisticated, and there's a lot of

00:03:32,790 --> 00:03:36,329
information added in asynchronous processes.

00:03:36,329 --> 00:03:40,450
And when we share mutable state and asynchronous processes we have exactly

00:03:40,450 --> 00:03:44,019
the same problem that people in other communities have when they share mutable

00:03:44,019 --> 00:03:47,030
state between threads in a multi-threading environment.

00:03:47,030 --> 00:03:53,219
So now we've got things here, thing A, and some

00:03:53,219 --> 00:03:58,150
other piece of code over here, thing B, and these two things are communicating

00:03:58,150 --> 00:03:59,739
through a communication channel.

00:03:59,739 --> 00:04:01,810
Sharing messages back and forth.

00:04:01,810 --> 00:04:03,860
But if they're also sharing mutable state, they're

00:04:03,860 --> 00:04:06,389
communicating through that too.

00:04:06,389 --> 00:04:09,750
And that communication happens instantly and it bypasses the communication

00:04:09,750 --> 00:04:14,120
passageways of your application.

00:04:14,120 --> 00:04:17,769
So that means you have this spooky action at a distance going on, when you're

00:04:17,769 --> 00:04:19,200
dealing with mutable state.

00:04:19,200 --> 00:04:20,200
Right?

00:04:20,200 --> 00:04:21,220
And it's...

00:04:21,220 --> 00:04:23,220
All right.

00:04:23,220 --> 00:04:24,220
So...

00:04:24,220 --> 00:04:27,250
We have persistent data structures that help us have

00:04:27,250 --> 00:04:31,360
immutable data so we can reason about our processes and our programs in a

00:04:31,360 --> 00:04:33,460
more effective fashion.

00:04:33,460 --> 00:04:35,500
And they do that in a performant way, rather than having

00:04:35,500 --> 00:04:39,699
to deep copy everything like you would if you were making immutable data yourself.

00:04:39,699 --> 00:04:44,080
So we're looking at two of those, immutable JS and Mori, from a particular

00:04:44,080 --> 00:04:45,530
perspective.

00:04:45,530 --> 00:04:47,990
So you have to know a little bit about (inaudible) trees.

00:04:47,990 --> 00:04:48,990
Or tris.

00:04:48,990 --> 00:04:50,310
Who says try?

00:04:50,310 --> 00:04:51,699
Who says tree?

00:04:51,699 --> 00:04:53,580
Either way is fine.

00:04:53,580 --> 00:04:55,910
You're both right.

00:04:55,910 --> 00:05:00,400
As long as people understand what you're saying.

00:05:00,400 --> 00:05:04,330
I'll try to say tri, because it disambiguates better.

00:05:04,330 --> 00:05:11,389
But a tri is a tree.

00:05:11,389 --> 00:05:16,620
This is just a super high level surface topology of a

00:05:16,620 --> 00:05:17,620
(inaudible).

00:05:17,620 --> 00:05:19,410
They're really interesting data structures.

00:05:19,410 --> 00:05:22,270
We put all of our values down at the bottom and use pieces of

00:05:22,270 --> 00:05:24,700
the key to walk down to that value.

00:05:24,700 --> 00:05:28,479
We're going to hash those keys first, so we can pull an unlimited

00:05:28,479 --> 00:05:29,720
number of bytes out of them.

00:05:29,720 --> 00:05:32,990
If we hit the end of the hash we rehash.

00:05:32,990 --> 00:05:36,350
So it gives us consistent and unlimited hash lengths,

00:05:36,350 --> 00:05:37,840
so we can deal with conflicts.

00:05:37,840 --> 00:05:43,409
Because if two things have the same key or the same piece of the hash of the

00:05:43,409 --> 00:05:46,550
key, then we have to go to the next piece of the hash.

00:05:46,550 --> 00:05:49,800
So we're going to take pieces of the hash, five bits at a time, and

00:05:49,800 --> 00:05:51,120
use that to walk down the street.

00:05:51,120 --> 00:05:54,570
Those five bits give us 32 possible values.

00:05:54,570 --> 00:05:59,940
So we're going to have an array of 32 possible values, up to 32 values, as the

00:05:59,940 --> 00:06:02,470
child of a particular node.

00:06:02,470 --> 00:06:06,050
And that's going to dereference into its children.

00:06:06,050 --> 00:06:11,650
So the things you have to remember from that are: 32 and hashing.

00:06:11,650 --> 00:06:13,169
Hashing gives us good distribution properties.

00:06:13,169 --> 00:06:17,479
We would rather have shallow, wide trees.

00:06:17,479 --> 00:06:21,240
We don't want deep trees, because depth increases our space usage and

00:06:21,240 --> 00:06:26,199
also our time usage.

00:06:26,199 --> 00:06:29,509
So we're going to put these two libraries under a

00:06:29,509 --> 00:06:30,509
microscope.

00:06:30,509 --> 00:06:32,449
We're going to use a thing called underscore, which is kind of

00:06:32,449 --> 00:06:36,439
like a data structure oscilloscope or something.

00:06:36,439 --> 00:06:38,330
And this is slightly the wrong aspect ratio.

00:06:38,330 --> 00:06:41,229
So you're not seeing all of the slides.

00:06:41,229 --> 00:06:42,229
That just says...

00:06:42,229 --> 00:06:44,900
Full history of the data structure down there.

00:06:44,900 --> 00:06:46,100
Okay.

00:06:46,100 --> 00:06:51,680
So these are the joys of AV confusion.

00:06:51,680 --> 00:06:52,680
Which was...

00:06:52,680 --> 00:06:53,680
Yeah, my fault, not theirs.

00:06:53,680 --> 00:06:56,270
They did an excellent job of recovering from that.

00:06:56,270 --> 00:06:58,680
So we're going to write out our data structure as a single long

00:06:58,680 --> 00:06:59,710
list.

00:06:59,710 --> 00:07:00,740
Right?

00:07:00,740 --> 00:07:03,100
We're going to take all of the numbers in it, and for each number

00:07:03,100 --> 00:07:05,379
in it, we're going to generate a pixel.

00:07:05,379 --> 00:07:07,379
That pixel will be colored according to that number.

00:07:07,379 --> 00:07:10,900
We're going to take that line of pixels, turn it on its side

00:07:10,900 --> 00:07:16,240
and make a column, and every time we make a new version of this data structure,

00:07:16,240 --> 00:07:18,150
we're going to move everything over and put the new column in

00:07:18,150 --> 00:07:21,419
place, so we can see the history of it.

00:07:21,419 --> 00:07:27,740
So let's cross our fingers and see if we can see what that looks like.

00:07:27,740 --> 00:07:29,670
Here we are...

00:07:29,670 --> 00:07:31,960
Oh, man.

00:07:31,960 --> 00:07:32,960
Aspect ratios!

00:07:32,960 --> 00:07:33,990
All right.

00:07:33,990 --> 00:07:37,669
So everything is kind of up in this corner.

00:07:37,669 --> 00:07:39,319
But that's cool.

00:07:39,319 --> 00:07:40,389
We can zoom here.

00:07:40,389 --> 00:07:42,430
This is the power of zoom.

00:07:42,430 --> 00:07:43,849
All right.

00:07:43,849 --> 00:07:49,580
So what we've done here is to start putting in some numbers.

00:07:49,580 --> 00:07:51,100
We see this triangle shape.

00:07:51,100 --> 00:07:52,100
That's what we're expecting.

00:07:52,100 --> 00:07:54,860
Because every single tick, we're adding a new number, enqueuing a new

00:07:54,860 --> 00:07:55,860
number.

00:07:55,860 --> 00:07:59,039
We see random numbers here.

00:07:59,039 --> 00:08:01,889
Those correlate to the numbers that we've added.

00:08:01,889 --> 00:08:05,349
So it just stays in place in this queue.

00:08:05,349 --> 00:08:09,819
The secondary feature we can pick out here is these shaded areas,

00:08:09,819 --> 00:08:13,120
which are shaded...

00:08:13,120 --> 00:08:17,490
They're less light, because they are down an extra level.

00:08:17,490 --> 00:08:20,430
So the lightness is corresponding to our depth in the tree.

00:08:20,430 --> 00:08:23,120
This area is down an extra level, so we can see it fills up

00:08:23,120 --> 00:08:24,759
with 32 things.

00:08:24,759 --> 00:08:27,370
And then those get added to the main data structure.

00:08:27,370 --> 00:08:29,889
And we start a new nursery at that point.

00:08:29,889 --> 00:08:32,590
Everybody on board so far?

00:08:32,590 --> 00:08:35,440
So both of these -- and I've cleverly code named them

00:08:35,440 --> 00:08:40,140
blue and red -- because this is not a performance comparison between Mori

00:08:40,140 --> 00:08:41,870
and immutable JS.

00:08:41,870 --> 00:08:45,290
It's just -- we're going to use these as a way of understanding

00:08:45,290 --> 00:08:49,690
what's happening in the process and in the program by looking at the data.

00:08:49,690 --> 00:08:53,470
Additionally, even if you figure out which is which, which is not very hard,

00:08:53,470 --> 00:08:56,960
after I hit a couple more buttons -- I'm using older versions of them.

00:08:56,960 --> 00:09:00,630
So it's not an effective performance comparison.

00:09:00,630 --> 00:09:02,450
So we start taking numbers off.

00:09:02,450 --> 00:09:07,889
They look more or less the same, but suddenly we see a really big difference.

00:09:07,889 --> 00:09:14,150
Here in the blue zone, we have a data structure that is the same size.

00:09:14,150 --> 00:09:15,170
Right?

00:09:15,170 --> 00:09:18,839
Here it was growing and here it's the same size every tick.

00:09:18,839 --> 00:09:21,740
And what we're doing every single tick is pushing on

00:09:21,740 --> 00:09:24,271
a number and dequeuing a number off of this end.

00:09:24,271 --> 00:09:27,740
And we can see it's actually happening in the data structure.

00:09:27,740 --> 00:09:28,740
Right?

00:09:28,740 --> 00:09:32,640
There's a couple of strange little places in here, like this little blip here,

00:09:32,640 --> 00:09:34,670
that occurs about six ticks in.

00:09:34,670 --> 00:09:36,470
I have no idea why but it's there every single

00:09:36,470 --> 00:09:38,399
time -- I haven't looked at the code for either of these.

00:09:38,399 --> 00:09:41,010
The point is to understand it by looking at the

00:09:41,010 --> 00:09:42,010
pictures.

00:09:42,010 --> 00:09:45,910
So this is a traditional queue, other than the fact that we still have our

00:09:45,910 --> 00:09:47,579
nurseries going.

00:09:47,579 --> 00:09:51,430
Shifting off of one end and pushing onto the other end.

00:09:51,430 --> 00:09:55,420
There's probably some performance implications here, because shift or unshift,

00:09:55,420 --> 00:09:59,020
whichever one we use, in JavaScript is not a very fast function.

00:09:59,020 --> 00:10:01,990
Over here we're doing something completely different.

00:10:01,990 --> 00:10:07,269
In particular, we can see that a whole new triangle has emerged, and we're

00:10:07,269 --> 00:10:09,889
keeping the old data up here.

00:10:09,889 --> 00:10:13,110
So what we infer from this is that rather than

00:10:13,110 --> 00:10:16,010
destroying things as we dequeue them, we're keeping pointers.

00:10:16,010 --> 00:10:17,860
And in fact, we can see these pointers here in

00:10:17,860 --> 00:10:19,470
this middle section.

00:10:19,470 --> 00:10:23,860
We're keeping pointers into this data and we're floating

00:10:23,860 --> 00:10:26,209
a counter to the end of it.

00:10:26,209 --> 00:10:27,950
As we dequeue things.

00:10:27,950 --> 00:10:32,639
And then when we hit the end of the old kind of master section or new growth

00:10:32,639 --> 00:10:36,610
section, we're dropping everything.

00:10:36,610 --> 00:10:41,120
And this new growth section down here becomes a new old one, and it starts getting

00:10:41,120 --> 00:10:43,420
dequeued, and we start over again here.

00:10:43,420 --> 00:10:46,760
Does that kind of make sense so far?

00:10:46,760 --> 00:10:50,630
So what we understand at this point is that there's a massive difference between

00:10:50,630 --> 00:10:53,110
these two libraries and how they handle queues.

00:10:53,110 --> 00:10:55,820
In particular, there may be some performance implications for

00:10:55,820 --> 00:10:57,470
that difference.

00:10:57,470 --> 00:11:00,240
We understand this not by looking at the code, but just by

00:11:00,240 --> 00:11:01,400
looking at these pictures.

00:11:01,400 --> 00:11:04,070
Let me show you another example.

00:11:04,070 --> 00:11:07,550
We're going to start throwing random numbers in here.

00:11:07,550 --> 00:11:11,560
So we'll take a number and we'll give it a key that is the number with the letter

00:11:11,560 --> 00:11:15,160
pre-pended, and insert this into the map.

00:11:15,160 --> 00:11:18,970
So what do we immediately see when we're looking at this?

00:11:18,970 --> 00:11:21,710
We immediately see that this blue side is about

00:11:21,710 --> 00:11:26,000
twice as tall as the red side over here.

00:11:26,000 --> 00:11:30,899
And so we can start to think that maybe there's some spatial implications

00:11:30,899 --> 00:11:31,899
here.

00:11:31,899 --> 00:11:32,899
Right?

00:11:32,899 --> 00:11:34,960
That our space usage is a little bit stronger over here.

00:11:34,960 --> 00:11:39,480
Let's turn on another way of looking at this.

00:11:39,480 --> 00:11:41,230
So this is a flattened tree view.

00:11:41,230 --> 00:11:43,770
What we're going to do is take our tree with all

00:11:43,770 --> 00:11:48,269
of its levels, and we're going to flatten every single level.

00:11:48,269 --> 00:11:49,589
And then we're going to turn the whole thing on

00:11:49,589 --> 00:11:51,180
its side.

00:11:51,180 --> 00:11:54,860
So if we look over here, we can see that we have our initial node

00:11:54,860 --> 00:11:59,130
here, this blue is a pointer to the secondary node here, this points to an

00:11:59,130 --> 00:12:04,540
array of 32 pointers, each point to a dereference column here, and then those

00:12:04,540 --> 00:12:08,260
point to this array over here, and so on.

00:12:08,260 --> 00:12:10,209
But just from eyeballing this...

00:12:10,209 --> 00:12:13,820
I don't know how much of this you can actually see...

00:12:13,820 --> 00:12:20,230
We can see that these are adding new key value pairs in very

00:12:20,230 --> 00:12:21,370
different ways.

00:12:21,370 --> 00:12:22,850
This one is a lot more compact.

00:12:22,850 --> 00:12:27,390
So this reconfirms our intuition that we saw just from looking at

00:12:27,390 --> 00:12:28,759
the sizes.

00:12:28,759 --> 00:12:34,430
Let's try, instead of adding these randomly, adding them...

00:12:34,430 --> 00:12:36,040
Hang on.

00:12:36,040 --> 00:12:37,660
Come on.

00:12:37,660 --> 00:12:38,730
You can do it.

00:12:38,730 --> 00:12:40,390
All right.

00:12:40,390 --> 00:12:46,120
Apparently the reload button is not actually the reload button.

00:12:46,120 --> 00:12:48,130
Borrowed laptop issues.

00:12:48,130 --> 00:12:50,690
All right.

00:12:50,690 --> 00:12:54,170
What's happening here?

00:12:54,170 --> 00:12:57,759
Now we're loading in numbers sequentially, instead of randomly.

00:12:57,759 --> 00:13:01,329
And something that we started to see toward the end of this one becomes very

00:13:01,329 --> 00:13:02,970
clear.

00:13:02,970 --> 00:13:05,680
We're seeing this banding effect.

00:13:05,680 --> 00:13:09,899
Whereas these colors are well distributed, these colors are patterned in a very particular

00:13:09,899 --> 00:13:10,899
way.

00:13:10,899 --> 00:13:12,650
And what that's telling us -- if we look here, we can see the same

00:13:12,650 --> 00:13:13,650
story.

00:13:13,650 --> 00:13:18,130
This one, even though we're adding them sequentially, is well populated.

00:13:18,130 --> 00:13:19,460
It's fairly dense.

00:13:19,460 --> 00:13:25,370
Over here, we see something that has these increasing sort

00:13:25,370 --> 00:13:30,430
of harmonic oscillations that are going on in the number of collisions.

00:13:30,430 --> 00:13:36,440
So this tells us that the hashing algorithm that blue is using is not distributing

00:13:36,440 --> 00:13:40,660
values or keys as well as the hashing algorithm that red is using.

00:13:40,660 --> 00:13:43,600
In fact, we're getting very bad hashing behavior out of this.

00:13:43,600 --> 00:13:47,279
It's probably modulo or something like that.

00:13:47,279 --> 00:13:49,670
Oh, dear.

00:13:49,670 --> 00:13:52,890
Fortunately, that was actually the end of the conclusions that we were going

00:13:52,890 --> 00:13:53,890
to draw from that.

00:13:53,890 --> 00:13:59,930
So what we've learned so far is that you should always

00:13:59,930 --> 00:14:03,350
bring a backup laptop when you're giving a talk.

00:14:03,350 --> 00:14:08,240
And the second thing that we've learned is that we can make observations

00:14:08,240 --> 00:14:11,610
about a piece of code without ever looking at that code at all.

00:14:11,610 --> 00:14:13,500
So we've learned something about these two libraries.

00:14:13,500 --> 00:14:15,279
But we didn't have to look at any code.

00:14:15,279 --> 00:14:21,519
And that's important, because it doesn't matter how good or poorly

00:14:21,519 --> 00:14:24,490
written that code was.

00:14:24,490 --> 00:14:26,190
Right?

00:14:26,190 --> 00:14:27,260
It could be obfuscated.

00:14:27,260 --> 00:14:28,550
Both of these are well written libraries.

00:14:28,550 --> 00:14:30,420
But it doesn't matter.

00:14:30,420 --> 00:14:40,920
For example, if a library is the framework we're using or that someone

00:14:40,920 --> 00:14:44,610
else is using, we have to take over maintenance of that code, there's hundreds

00:14:44,610 --> 00:14:48,250
of thousands of lines in the framework, so we could read the entire thing to

00:14:48,250 --> 00:14:53,551
understand how it works, or we could try to go in the back door and try to

00:14:53,551 --> 00:14:58,240
develop our intuitions by actually observing the process unfolding.

00:14:58,240 --> 00:14:59,899
So one problem that we saw...

00:14:59,899 --> 00:15:02,940
Or I guess we didn't see, but we should have seen --

00:15:02,940 --> 00:15:04,709
was that there was limited screen real estate.

00:15:04,709 --> 00:15:05,709
We had the opposite problem.

00:15:05,709 --> 00:15:09,220
There was way too much screen real estate.

00:15:09,220 --> 00:15:14,890
So fitting everything in can be an issue.

00:15:14,890 --> 00:15:16,980
Sorry?

00:15:16,980 --> 00:15:22,170
Will that actually work with images?

00:15:22,170 --> 00:15:23,170
It works!

00:15:23,170 --> 00:15:24,699
That's so great.

00:15:24,699 --> 00:15:27,170
Thank you!

00:15:27,170 --> 00:15:29,540
Cool.

00:15:29,540 --> 00:15:33,220
So we have some issues with the amount of available space to us.

00:15:33,220 --> 00:15:35,209
So we could, for example, look at a single line

00:15:35,209 --> 00:15:40,779
of code, and observe this line of code, or we could observe the entire code

00:15:40,779 --> 00:15:41,779
base.

00:15:41,779 --> 00:15:42,779
Right?

00:15:42,779 --> 00:15:43,990
And watch the entire process unfolding.

00:15:43,990 --> 00:15:47,100
So we can kind of pick a place along this continuum that

00:15:47,100 --> 00:15:48,279
we're interested in.

00:15:48,279 --> 00:15:51,180
We could also, on the temporal dimension, look at a

00:15:51,180 --> 00:15:53,490
single operation at a time.

00:15:53,490 --> 00:15:57,670
Or we could look at the entire process unfolding in realtime.

00:15:57,670 --> 00:16:01,980
And so we have really good tools for this end of the spectrum.

00:16:01,980 --> 00:16:05,220
For looking at a single operation, one at a time.

00:16:05,220 --> 00:16:06,220
Right?

00:16:06,220 --> 00:16:08,209
Step-through debuggers work great for this.

00:16:08,209 --> 00:16:10,959
And they give us a street level view of what's happening.

00:16:10,959 --> 00:16:11,959
Right?

00:16:11,959 --> 00:16:15,130
We're taking -- we're walking through the town of our process.

00:16:15,130 --> 00:16:18,839
But they don't give us the 10,000-foot view of what's

00:16:18,839 --> 00:16:25,120
happening all at once, so we can develop our intuitions about it, and we don't

00:16:25,120 --> 00:16:26,800
have very good tools for that right now.

00:16:26,800 --> 00:16:28,870
So that's what's on the left hand of the slide.

00:16:28,870 --> 00:16:33,050
On the right hand is some mathematics that ostensibly proves

00:16:33,050 --> 00:16:36,880
that the information we have is greater than the information we would like

00:16:36,880 --> 00:16:41,660
to have, but really it's a ham handed way of trying to work the '80s theme

00:16:41,660 --> 00:16:44,890
into my presentation.

00:16:44,890 --> 00:16:49,950
All right.

00:16:49,950 --> 00:16:52,480
So...

00:16:52,480 --> 00:16:54,060
What we're going to do...

00:16:54,060 --> 00:16:56,940
Because JavaScript is huge -- the ES5 spec is

00:16:56,940 --> 00:17:01,050
over 250 pages, and because we write huge applications in it, we're going to

00:17:01,050 --> 00:17:04,410
punt a little on this problem and we're going to start with a system where we

00:17:04,410 --> 00:17:09,310
can see everything at full granularity, with the entire process, all at the

00:17:09,310 --> 00:17:10,589
same time.

00:17:10,589 --> 00:17:11,589
Okay?

00:17:11,589 --> 00:17:14,690
So that means we're going to have to design a language.

00:17:14,690 --> 00:17:16,069
We have some design constraints for this.

00:17:16,069 --> 00:17:20,120
We're going to keep it very simple, so we have an 8-bit architecture.

00:17:20,120 --> 00:17:24,760
Our memory is going to be 256 bytes.

00:17:24,760 --> 00:17:26,650
And we would like to introduce random programs, because

00:17:26,650 --> 00:17:30,750
the whole idea is to gain intuition about the process that's unfolding

00:17:30,750 --> 00:17:33,630
from a program without actually understanding the program.

00:17:33,630 --> 00:17:35,220
If we understand the program, then we don't need to

00:17:35,220 --> 00:17:36,390
do that.

00:17:36,390 --> 00:17:37,390
Right?

00:17:37,390 --> 00:17:38,390
So we need random programs.

00:17:38,390 --> 00:17:39,940
So that means we're going to fuzz the compiler.

00:17:39,940 --> 00:17:42,010
We would like there not to be any compile time

00:17:42,010 --> 00:17:43,010
errors when we do this.

00:17:43,010 --> 00:17:45,820
We would like there not to be any runtime errors.

00:17:45,820 --> 00:17:50,250
And I will throw in an additional constraint that we want all of our programs

00:17:50,250 --> 00:17:51,980
to terminate.

00:17:51,980 --> 00:17:54,850
This sounds easy, right?

00:17:54,850 --> 00:17:55,850
Sure.

00:17:55,850 --> 00:17:58,380
Oh my gosh.

00:17:58,380 --> 00:18:00,760
It's so tiny.

00:18:00,760 --> 00:18:01,960
Woo!

00:18:01,960 --> 00:18:04,350
All right.

00:18:04,350 --> 00:18:10,260
So here is a program in our language, and this, over on the right,

00:18:10,260 --> 00:18:14,890
is supposed to be the JSConf Pegasus, but...

00:18:14,890 --> 00:18:16,450
My pixel art skills are not very good.

00:18:16,450 --> 00:18:20,900
It looks more like a flying aardvark with a Tommy gun or something.

00:18:20,900 --> 00:18:22,380
(laughter)

00:18:22,380 --> 00:18:25,350
>> All right.

00:18:25,350 --> 00:18:27,900
So if we run this, we can see that it's some type of

00:18:27,900 --> 00:18:30,800
image-blurring program.

00:18:30,800 --> 00:18:33,420
And just so you know that...

00:18:33,420 --> 00:18:34,950
Really?

00:18:34,950 --> 00:18:36,480
Okay.

00:18:36,480 --> 00:18:45,610
Did I get bounced off the subnet?

00:18:45,610 --> 00:18:50,000
Is that why I can't refresh?

00:18:50,000 --> 00:18:51,000
Agh!

00:18:51,000 --> 00:18:52,140
Thank you.

00:18:52,140 --> 00:18:53,270
Okay.

00:18:53,270 --> 00:18:54,400
So...

00:18:54,400 --> 00:18:56,590
I was going to show you that we could edit the program and it would

00:18:56,590 --> 00:18:57,590
still work.

00:18:57,590 --> 00:18:58,590
You'll have to take my word for that.

00:18:58,590 --> 00:19:01,799
That's the magic of live demos.

00:19:01,799 --> 00:19:03,350
So that's great.

00:19:03,350 --> 00:19:06,050
But we're not seeing individual steps.

00:19:06,050 --> 00:19:08,380
So we want to go back and be able to actually see things

00:19:08,380 --> 00:19:10,169
at a granular level.

00:19:10,169 --> 00:19:14,190
So now we can see the stack, we can see the return stack.

00:19:14,190 --> 00:19:15,630
These are the two...

00:19:15,630 --> 00:19:17,510
This is the entire process unfolding.

00:19:17,510 --> 00:19:18,799
We see the memory.

00:19:18,799 --> 00:19:19,809
We see the code.

00:19:19,809 --> 00:19:22,820
We see where we're at in the code, thanks to this highlight.

00:19:22,820 --> 00:19:26,429
And we see the full variable structure right here.

00:19:26,429 --> 00:19:27,429
So this is everything.

00:19:27,429 --> 00:19:31,210
If we took a picture of this, we could replicate this process at this moment

00:19:31,210 --> 00:19:34,809
perfectly, and we could step through and see that it is in fact doing some

00:19:34,809 --> 00:19:36,580
things as we step through.

00:19:36,580 --> 00:19:40,559
But in zooming into this level, we've lost our

00:19:40,559 --> 00:19:44,350
ability to see things unfold in realtime.

00:19:44,350 --> 00:19:47,830
So now we're back to the step-through debugger zone.

00:19:47,830 --> 00:19:51,470
So what we can do is...

00:19:51,470 --> 00:19:56,140
We have a connection between code, which, when it gets

00:19:56,140 --> 00:20:01,000
compiled down, all of these codes over here -- or these commands over here --

00:20:01,000 --> 00:20:03,650
get pushed down into numbers.

00:20:03,650 --> 00:20:06,270
So we can actually make an array of numbers out

00:20:06,270 --> 00:20:07,750
of our code.

00:20:07,750 --> 00:20:08,750
And that's exactly what happens.

00:20:08,750 --> 00:20:12,650
It gets compiled down to a machine code, which is an array of bytes.

00:20:12,650 --> 00:20:15,600
So at the machine code level, we have an array of bytes, and our memory is

00:20:15,600 --> 00:20:16,600
an array of bytes.

00:20:16,600 --> 00:20:20,190
We have a sort of trivial form of homoiconicity, where your

00:20:20,190 --> 00:20:24,460
code and your data is the same thing.

00:20:24,460 --> 00:20:32,870
It's the same type of data structure as you typically operate on.

00:20:32,870 --> 00:20:36,660
Machine code always has a trivial form of homoiconicity, but in our case, we

00:20:36,660 --> 00:20:42,909
have a similar trick up our sleeves, which is that our memory is being mapped

00:20:42,909 --> 00:20:48,309
to an image, so there's an isomorphism between the memory structure and the

00:20:48,309 --> 00:20:56,070
image, and there's also an isomorphism between the code and an image, or icon.

00:20:56,070 --> 00:21:00,179
So maybe our homoiconicity is not so trivial after all.

00:21:00,179 --> 00:21:02,779
That was a really involved joke.

00:21:02,779 --> 00:21:05,470
All right.

00:21:05,470 --> 00:21:07,910
So we can look at this as an image instead.

00:21:07,910 --> 00:21:09,500
Which is where things start to get fun.

00:21:09,500 --> 00:21:11,150
So this is our program running...

00:21:11,150 --> 00:21:15,390
Again, we could take a snapshot and reform our entire process at

00:21:15,390 --> 00:21:16,390
a moment in time.

00:21:16,390 --> 00:21:19,220
You can see the read head is this kind of white square here

00:21:19,220 --> 00:21:21,440
that's jumping through this subroutine.

00:21:21,440 --> 00:21:26,289
And you can see that it is in fact performing this image blur on

00:21:26,289 --> 00:21:28,059
our memory.

00:21:28,059 --> 00:21:29,330
So...

00:21:29,330 --> 00:21:30,330
That's great.

00:21:30,330 --> 00:21:32,890
But what we're really interested in is random programs.

00:21:32,890 --> 00:21:36,000
And I can't reload this, and it's stuck in a really silly loop.

00:21:36,000 --> 00:21:37,250
Are we good?

00:21:37,250 --> 00:21:38,780
Oh, yes.

00:21:38,780 --> 00:21:39,780
Nice.

00:21:39,780 --> 00:21:40,780
Okay.

00:21:40,780 --> 00:21:42,140
So we're watching an entirely random program.

00:21:42,140 --> 00:21:46,090
All the colored spots correlate to different kinds of op codes.

00:21:46,090 --> 00:21:49,530
This is an exit, so it's the beginning of the subroutine,

00:21:49,530 --> 00:21:54,049
and this is a jump, so it's jumping to the next subroutine when it hits

00:21:54,049 --> 00:21:55,240
that.

00:21:55,240 --> 00:22:00,929
The grey areas correlate to numbers that serve as constants in our program,

00:22:00,929 --> 00:22:03,890
and what can we infer about this?

00:22:03,890 --> 00:22:06,130
It's actually hard to infer much of anything from this system.

00:22:06,130 --> 00:22:11,320
We can see that this square is blinking a lot, and that

00:22:11,320 --> 00:22:15,279
we're going to take a little while before we end, because we've got 200

00:22:15,279 --> 00:22:19,610
counting down on a return stack.

00:22:19,610 --> 00:22:21,429
So what we're doing here is...

00:22:21,429 --> 00:22:23,250
We're applying the program to itself.

00:22:23,250 --> 00:22:25,970
We put a copy of it in memory, and we have it modify

00:22:25,970 --> 00:22:28,570
itself.

00:22:28,570 --> 00:22:31,440
And then when it's done, when it terminates, we're going to take the

00:22:31,440 --> 00:22:33,600
modified version and run that against itself.

00:22:33,600 --> 00:22:39,140
And we're going to keep doing this until our program doesn't do anything

00:22:39,140 --> 00:22:40,140
interesting.

00:22:40,140 --> 00:22:41,450
Well, this one is certainly doing something interesting -- down

00:22:41,450 --> 00:22:43,500
here, at least.

00:22:43,500 --> 00:22:48,419
Or we find a cycle where program A, applied to A, gives us program B, which,

00:22:48,419 --> 00:22:50,840
when applied to B, gives us program A again.

00:22:50,840 --> 00:22:54,770
And then we will be very happy and have champagne or something.

00:22:54,770 --> 00:22:57,470
All right.

00:22:57,470 --> 00:22:58,820
So...

00:22:58,820 --> 00:23:00,000
This was a nice experiment.

00:23:00,000 --> 00:23:02,980
But it's a little hard to infer much about these programs, because the

00:23:02,980 --> 00:23:05,420
language is a little obscure.

00:23:05,420 --> 00:23:10,140
And because we haven't looked at these pictures long enough.

00:23:10,140 --> 00:23:11,790
What if we could do this with JavaScript?

00:23:11,790 --> 00:23:15,380
That's the $25,000 question.

00:23:15,380 --> 00:23:24,049
So what if we could look at the interpreter for this in JavaScript?

00:23:24,049 --> 00:23:26,980
So I was hoping to not have to do this.

00:23:26,980 --> 00:23:29,780
But I have to do this.

00:23:29,780 --> 00:23:35,630
So we'll take this over here.

00:23:35,630 --> 00:23:39,270
And we will do this and we will do this.

00:23:39,270 --> 00:23:40,270
Oh, good.

00:23:40,270 --> 00:23:41,270
Okay.

00:23:41,270 --> 00:23:42,270
All right.

00:23:42,270 --> 00:23:43,270
Everyone cross your fingers.

00:23:43,270 --> 00:23:44,270
Take a deep breath.

00:23:44,270 --> 00:23:46,590
And we'll see if we can make this work.

00:23:46,590 --> 00:23:49,430
All right.

00:23:49,430 --> 00:23:55,029
So what we'd like to see is our virtual machine for this little language that we've written,

00:23:55,029 --> 00:23:58,559
running in realtime, in JavaScript.

00:23:58,559 --> 00:24:03,610
And over on the left, that's exactly what we're seeing.

00:24:03,610 --> 00:24:05,570
So we're back to the step-through on the right.

00:24:05,570 --> 00:24:07,620
We're stepping through, one step at a time.

00:24:07,620 --> 00:24:11,170
But as we step through, we're seeing three columns over here, which

00:24:11,170 --> 00:24:12,390
correlate to three files.

00:24:12,390 --> 00:24:15,330
This is the core virtual machine.

00:24:15,330 --> 00:24:16,920
This is the renderer.

00:24:16,920 --> 00:24:21,970
And this is the index HTML.

00:24:21,970 --> 00:24:23,520
Can you see that?

00:24:23,520 --> 00:24:26,200
Can anyone see that at all?

00:24:26,200 --> 00:24:27,380
You can?

00:24:27,380 --> 00:24:29,760
It's visible?

00:24:29,760 --> 00:24:30,940
Okay.

00:24:30,940 --> 00:24:32,130
Cool.

00:24:32,130 --> 00:24:38,480
So as we step through, there's going to be lots of flashing colors here.

00:24:38,480 --> 00:24:44,100
We can see different parts of this program being evaluated.

00:24:44,100 --> 00:24:46,179
So this is the actual underlying virtual machine.

00:24:46,179 --> 00:24:51,900
This, for example, is the draw function.

00:24:51,900 --> 00:24:54,809
And it's longer than you would expect, and it's also very, very

00:24:54,809 --> 00:24:55,809
hot.

00:24:55,809 --> 00:24:58,240
So this is forming a heat map.

00:24:58,240 --> 00:25:00,460
Because there's a tiny little virtual DOM inside here.

00:25:00,460 --> 00:25:03,809
So I just call it 256 times a tick.

00:25:03,809 --> 00:25:07,419
But the point of this isn't to be a profiler.

00:25:07,419 --> 00:25:08,419
Right?

00:25:08,419 --> 00:25:09,580
We already have really good profilers for finding hot

00:25:09,580 --> 00:25:11,000
spots in our code.

00:25:11,000 --> 00:25:14,980
The point of this is to -- at a 10,000-foot view --

00:25:14,980 --> 00:25:20,500
understand the process that's unfolding from our code.

00:25:20,500 --> 00:25:23,170
And...

00:25:23,170 --> 00:25:26,020
So another interesting thing that we can do is not just

00:25:26,020 --> 00:25:30,150
watch this in realtime, which we can do a little more effectively if we speed

00:25:30,150 --> 00:25:34,960
this up -- we can also slow it down and watch it happening essentially a

00:25:34,960 --> 00:25:36,539
tick at a time.

00:25:36,539 --> 00:25:39,820
So we can see the process...

00:25:39,820 --> 00:25:41,790
We can see the underlying engine kind of flowing through.

00:25:41,790 --> 00:25:45,700
And unfortunately this code is not very interesting.

00:25:45,700 --> 00:25:50,460
Because it's calling the draw function 256 times.

00:25:50,460 --> 00:25:52,779
But we can rewind and try to...

00:25:52,779 --> 00:25:54,409
We can rewind...

00:25:54,409 --> 00:25:57,070
Maybe we can rewind.

00:25:57,070 --> 00:26:00,390
We can't rewind.

00:26:00,390 --> 00:26:01,500
(laughter)

00:26:01,500 --> 00:26:02,600
>> Uh...

00:26:02,600 --> 00:26:03,710
Really?

00:26:03,710 --> 00:26:04,820
Okay.

00:26:04,820 --> 00:26:07,210
So this isn't very interesting for me, this particular

00:26:07,210 --> 00:26:08,799
piece of code, because I wrote it.

00:26:08,799 --> 00:26:11,210
So I understand exactly what's happening here.

00:26:11,210 --> 00:26:15,080
If we look at something else, though, something bigger, like, for

00:26:15,080 --> 00:26:18,740
example, a framework of some kind that we're not familiar with -- this one is

00:26:18,740 --> 00:26:22,270
Agility JS.

00:26:22,270 --> 00:26:26,580
And then if we do this magical thing that may or may not work...

00:26:26,580 --> 00:26:27,580
Okay, good.

00:26:27,580 --> 00:26:31,800
So I'm using fondue under the hood, which is an instrumentation

00:26:31,800 --> 00:26:42,460
library written for Theseus, which is a debugger for

00:26:42,460 --> 00:26:44,710
brackets.

00:26:44,710 --> 00:26:48,649
Typing and talking simultaneously are surprisingly difficult

00:26:48,649 --> 00:26:51,220
things to do well.

00:26:51,220 --> 00:26:52,330
Okay.

00:26:52,330 --> 00:26:53,580
Flashy lights!

00:26:53,580 --> 00:26:54,580
Woo.

00:26:54,580 --> 00:26:56,029
All right.

00:26:56,029 --> 00:26:58,039
So what are we really looking at here?

00:26:58,039 --> 00:27:03,940
What we're seeing unfold before us is...

00:27:03,940 --> 00:27:14,169
The entire process that's inside of Agility JS, as it's handling the things that

00:27:14,169 --> 00:27:25,210
we clicked over here -- so if we click this, for example -- 

00:27:25,210 --> 00:27:26,920
and then we...

00:27:26,920 --> 00:27:27,920
No.

00:27:27,920 --> 00:27:28,920
Okay.

00:27:28,920 --> 00:27:31,710
So I should slow this down a little.

00:27:31,710 --> 00:27:34,490
Okay.

00:27:34,490 --> 00:27:39,159
So we can observe at a high level the functions that are being

00:27:39,159 --> 00:27:56,950
called and the flow of functions as they're being called.

00:27:56,950 --> 00:27:58,530
So this shows us something about the process.

00:27:58,530 --> 00:28:00,480
And we can draw some inference from it.

00:28:00,480 --> 00:28:02,570
But there's more that we need.

00:28:02,570 --> 00:28:04,809
What we'd really like to see is the data that's

00:28:04,809 --> 00:28:06,850
flowing through here as well.

00:28:06,850 --> 00:28:11,400
And we'd like those data flow pathways to be highlighted.

00:28:11,400 --> 00:28:16,560
We want to be able to sort of pour data in some input of our program,

00:28:16,560 --> 00:28:21,600
and watch as it trickles through the function calls and invocations,

00:28:21,600 --> 00:28:25,350
and watch it as it pools up in some place and stays there for a while.

00:28:25,350 --> 00:28:28,679
See how it interfaces with other data that's flowing through.

00:28:28,679 --> 00:28:34,019
We want to be able to understand the applications that

00:28:34,019 --> 00:28:38,519
we're working with at the level of the process that they're evolving.

00:28:38,519 --> 00:28:42,070
And we want this because reading code is very slow,

00:28:42,070 --> 00:28:44,970
and it requires that we have an interpreter in our head.

00:28:44,970 --> 00:28:48,590
And if we can do this effectively, then we can understand -- for example,

00:28:48,590 --> 00:28:51,820
frameworks that we've never used -- at an intuitive level, without ever

00:28:51,820 --> 00:28:55,720
actually having used them or read their code or their documentation.

00:28:55,720 --> 00:28:57,960
So I want this for the programs that I'm writing, and

00:28:57,960 --> 00:29:00,860
I also want it for the programs that I'm reading.

00:29:00,860 --> 00:29:02,990
And if you want it too, then I think we should work together

00:29:02,990 --> 00:29:03,990
on this.

00:29:03,990 --> 00:29:05,210
I think we should make this happen.

00:29:05,210 --> 00:29:08,840
I think we should get this -- not this, but something like this -- into dev

00:29:08,840 --> 00:29:09,929
tools.

00:29:09,929 --> 00:29:12,659
So we have it available for everything that we're doing.

00:29:12,659 --> 00:29:16,940
Let's augment our vision.

00:29:16,940 --> 00:29:20,809
Let's let the computer do the hard work of helping us understand

00:29:20,809 --> 00:29:24,050
what it is we're working with.

00:29:24,050 --> 00:29:27,420
Let's go to that party.

00:29:27,420 --> 00:29:27,600

YouTube URL: https://www.youtube.com/watch?v=QPCXsG_iMlc


