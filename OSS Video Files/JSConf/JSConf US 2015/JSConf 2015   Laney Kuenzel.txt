Title: JSConf 2015   Laney Kuenzel
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	
Captions: 
	00:00:15,779 --> 00:00:19,810
yeah I'm Lanie kenzo I'm a software

00:00:18,160 --> 00:00:22,750
engineer i work on the product

00:00:19,810 --> 00:00:25,480
infrastructure team at facebook and back

00:00:22,750 --> 00:00:27,400
in january at react Jas comp to my

00:00:25,480 --> 00:00:30,160
teammates dan Schaefer and jing chen

00:00:27,400 --> 00:00:31,779
gave a talk introducing relay which is

00:00:30,160 --> 00:00:33,730
our data fetching framework for react

00:00:31,779 --> 00:00:36,640
and the query language that it uses

00:00:33,730 --> 00:00:38,650
called graph ql so today in this talk

00:00:36,640 --> 00:00:40,750
i'm going to start with a description of

00:00:38,650 --> 00:00:41,860
relay engraft well for anyone who didn't

00:00:40,750 --> 00:00:43,360
see their talk or who needs a refresher

00:00:41,860 --> 00:00:47,250
and then i'm going to dive into some

00:00:43,360 --> 00:00:49,660
specific parts of the real a framework

00:00:47,250 --> 00:00:51,190
so let's start by thinking about how we

00:00:49,660 --> 00:00:53,559
at facebook we're doing client

00:00:51,190 --> 00:00:56,020
development a year ago at that point

00:00:53,559 --> 00:00:58,059
we've developed react and we had also

00:00:56,020 --> 00:01:00,070
developed the flux architecture which

00:00:58,059 --> 00:01:02,710
provides a pattern for one-way data flow

00:01:00,070 --> 00:01:05,110
through an application and when we use

00:01:02,710 --> 00:01:06,310
both react and flux we found that we can

00:01:05,110 --> 00:01:08,200
move faster in the development process

00:01:06,310 --> 00:01:11,530
and we can build more robust reliable

00:01:08,200 --> 00:01:14,200
applications but there was one big

00:01:11,530 --> 00:01:17,110
problem that neither react nor flux

00:01:14,200 --> 00:01:18,670
really addressed that almost every

00:01:17,110 --> 00:01:20,590
client developer has faced at one time

00:01:18,670 --> 00:01:22,479
or another which is what's the best way

00:01:20,590 --> 00:01:24,160
to fetch data from the server and to

00:01:22,479 --> 00:01:27,550
organize that data once it's on the

00:01:24,160 --> 00:01:28,780
client so let's look at how data

00:01:27,550 --> 00:01:31,869
fetching might work in an application

00:01:28,780 --> 00:01:33,670
built with reactant flux I'm going to

00:01:31,869 --> 00:01:36,610
use this example of a news feed story

00:01:33,670 --> 00:01:38,440
that I wrote about Jay escon and in

00:01:36,610 --> 00:01:41,170
particular its likes and comments

00:01:38,440 --> 00:01:43,750
section on the bottom so this like and

00:01:41,170 --> 00:01:45,310
comment box is was one of the first

00:01:43,750 --> 00:01:47,830
parts of face book that we wrote with

00:01:45,310 --> 00:01:49,959
reactant flux it's a really central part

00:01:47,830 --> 00:01:51,700
of Facebook one where you get people

00:01:49,959 --> 00:01:53,709
from a bunch of different teams coming

00:01:51,700 --> 00:01:55,209
in and changing it frequently whether

00:01:53,709 --> 00:01:57,190
they're updating the design or adding

00:01:55,209 --> 00:02:00,819
new features so it's kind of a hot hot

00:01:57,190 --> 00:02:03,340
part of Facebook so let's consider the

00:02:00,819 --> 00:02:04,599
example of introducing stickers and

00:02:03,340 --> 00:02:08,679
comments which is something that we

00:02:04,599 --> 00:02:10,500
actually did last fall let's say that in

00:02:08,679 --> 00:02:12,940
this part of the application our

00:02:10,500 --> 00:02:16,180
component tree consists of this comment

00:02:12,940 --> 00:02:19,330
box which contains a comment list which

00:02:16,180 --> 00:02:21,189
contains a series of comment items so

00:02:19,330 --> 00:02:23,829
how does each of these components get

00:02:21,189 --> 00:02:25,209
the data that it needs the data comes

00:02:23,829 --> 00:02:25,660
from the server and then it will get

00:02:25,209 --> 00:02:27,880
past

00:02:25,660 --> 00:02:29,680
through the component tree so comment

00:02:27,880 --> 00:02:31,690
box is going to get some set of data and

00:02:29,680 --> 00:02:34,300
then it will take a subset of that and

00:02:31,690 --> 00:02:35,710
pass it into comment list and then

00:02:34,300 --> 00:02:37,360
comment list will take subsets of that

00:02:35,710 --> 00:02:40,480
data and pass that into each of the

00:02:37,360 --> 00:02:42,580
comment items in this model the

00:02:40,480 --> 00:02:44,530
important thing to notice is that every

00:02:42,580 --> 00:02:46,390
component needs to be aware of the data

00:02:44,530 --> 00:02:48,550
that its children need so that it can

00:02:46,390 --> 00:02:49,960
pass the right data down and then that

00:02:48,550 --> 00:02:51,490
server on point up there needs to be

00:02:49,960 --> 00:02:54,400
aware of the data required by every

00:02:51,490 --> 00:02:56,050
single component in that tree so in

00:02:54,400 --> 00:02:58,330
other words the implementation details

00:02:56,050 --> 00:03:00,130
of each component the details of what

00:02:58,330 --> 00:03:02,350
exact data each component needs are

00:03:00,130 --> 00:03:05,710
leaked up to the parents and to the

00:03:02,350 --> 00:03:07,300
server why does this matter well it

00:03:05,710 --> 00:03:08,650
means that if you come along and you

00:03:07,300 --> 00:03:10,390
want to introduce sticker comments you

00:03:08,650 --> 00:03:11,950
can't just make a change in comment item

00:03:10,390 --> 00:03:14,980
you're also going to need to change

00:03:11,950 --> 00:03:18,340
comment list comment box and that server

00:03:14,980 --> 00:03:20,650
endpoint this is not cool when you need

00:03:18,340 --> 00:03:21,940
to change all those files especially

00:03:20,650 --> 00:03:23,380
when you have different people coming in

00:03:21,940 --> 00:03:24,910
all trying to make their changes and

00:03:23,380 --> 00:03:26,890
needing to modify all those files every

00:03:24,910 --> 00:03:28,990
time you end up with more conflicts and

00:03:26,890 --> 00:03:32,500
just generally slower development

00:03:28,990 --> 00:03:34,150
process moreover things can get pretty

00:03:32,500 --> 00:03:35,590
confusing when you have your data

00:03:34,150 --> 00:03:37,660
fetching logic in one place on the

00:03:35,590 --> 00:03:39,970
server and then you're rendering logic

00:03:37,660 --> 00:03:42,340
on the client so let's say that you look

00:03:39,970 --> 00:03:43,900
at your server endpoint and you see that

00:03:42,340 --> 00:03:46,990
you're fetching the birthdays for all

00:03:43,900 --> 00:03:48,610
the commenters on a story it's really

00:03:46,990 --> 00:03:50,740
hard to know at a glance whether and

00:03:48,610 --> 00:03:53,530
where this birthday data is being used

00:03:50,740 --> 00:03:55,600
in your application on the client so

00:03:53,530 --> 00:03:57,070
maybe someone ran an a/b test a few

00:03:55,600 --> 00:03:58,300
months ago and they wanted to see what

00:03:57,070 --> 00:04:00,010
would happen if they added birthdays for

00:03:58,300 --> 00:04:01,630
commenters and it didn't really work

00:04:00,010 --> 00:04:07,420
that well so they removed that code from

00:04:01,630 --> 00:04:09,370
the client and now oops we have this

00:04:07,420 --> 00:04:11,230
over fetching situation where we're

00:04:09,370 --> 00:04:12,760
loading that birthday sending it to the

00:04:11,230 --> 00:04:15,580
client and then we're not doing anything

00:04:12,760 --> 00:04:16,660
with it and so it's just wasteful so

00:04:15,580 --> 00:04:19,090
maybe we're going to try to do a good

00:04:16,660 --> 00:04:20,859
deed and clean up the server remove that

00:04:19,090 --> 00:04:22,210
birthday code without realizing that

00:04:20,859 --> 00:04:24,040
there actually is some corner of

00:04:22,210 --> 00:04:26,140
application where we're still using the

00:04:24,040 --> 00:04:27,700
birthdays and now we have an under

00:04:26,140 --> 00:04:30,150
fetching bug so we're going to send some

00:04:27,700 --> 00:04:35,229
data the birthday won't be there and

00:04:30,150 --> 00:04:37,930
things won't be good it's pretty easy to

00:04:35,229 --> 00:04:38,940
for these data fetching pieces and the

00:04:37,930 --> 00:04:40,440
and the rendered pieces

00:04:38,940 --> 00:04:42,000
to get out of sync like this and it will

00:04:40,440 --> 00:04:45,870
often cause either over fetching or

00:04:42,000 --> 00:04:48,450
under fetching so how would this work in

00:04:45,870 --> 00:04:50,100
a perfect world ideally if we wanted to

00:04:48,450 --> 00:04:51,600
introduce sticker comments we would only

00:04:50,100 --> 00:04:54,120
need to change that comment item

00:04:51,600 --> 00:04:55,890
component and more generally rather than

00:04:54,120 --> 00:04:57,930
having our data fetching logic strewn

00:04:55,890 --> 00:05:00,900
throughout the application and on the

00:04:57,930 --> 00:05:02,510
server you reside in just one place the

00:05:00,900 --> 00:05:05,250
same place where we do our rendering

00:05:02,510 --> 00:05:07,470
this is the idea at the core of relay

00:05:05,250 --> 00:05:09,120
but to make development easier we should

00:05:07,470 --> 00:05:11,760
keep our logic for data fetching and

00:05:09,120 --> 00:05:18,300
rendering in the same place namely

00:05:11,760 --> 00:05:20,010
within the react component so rather

00:05:18,300 --> 00:05:21,660
than just containing the logic to render

00:05:20,010 --> 00:05:24,180
itself like a traditional react

00:05:21,660 --> 00:05:26,280
component a real a component also

00:05:24,180 --> 00:05:28,760
contains a declaration of the data that

00:05:26,280 --> 00:05:31,230
it needs in the form of a data query

00:05:28,760 --> 00:05:32,970
this way when someone wants to make a

00:05:31,230 --> 00:05:35,220
small change they can just find the

00:05:32,970 --> 00:05:37,320
relevant component change its data query

00:05:35,220 --> 00:05:38,640
and its render method and then they're

00:05:37,320 --> 00:05:40,050
done you don't they don't need to go

00:05:38,640 --> 00:05:42,420
change parent components or touch the

00:05:40,050 --> 00:05:44,010
server with the data query and the

00:05:42,420 --> 00:05:45,660
rendering in one place it's also a lot

00:05:44,010 --> 00:05:47,490
easier to know when you're fetching data

00:05:45,660 --> 00:05:49,740
that you don't don't use or trying to

00:05:47,490 --> 00:05:51,390
use data that you didn't fetch so you're

00:05:49,740 --> 00:05:54,419
less likely to get those over fetching

00:05:51,390 --> 00:05:56,310
and under fetching bugs in order to

00:05:54,419 --> 00:05:58,140
achieve all these benefits of putting

00:05:56,310 --> 00:05:59,850
the data query in the component we

00:05:58,140 --> 00:06:02,130
needed a common way for the components

00:05:59,850 --> 00:06:05,790
to declare their data requirements and

00:06:02,130 --> 00:06:08,130
this is where graph ql comes in graph UL

00:06:05,790 --> 00:06:10,440
at the data queering language and for

00:06:08,130 --> 00:06:11,880
the last couple years our client

00:06:10,440 --> 00:06:14,360
applications at facebook have been using

00:06:11,880 --> 00:06:16,950
graphs well to describe their data needs

00:06:14,360 --> 00:06:19,230
let's look at an example of what a graph

00:06:16,950 --> 00:06:20,760
ql query actually might look like so

00:06:19,230 --> 00:06:24,840
let's let's think about the data that we

00:06:20,760 --> 00:06:27,840
need to render a cup of comments author

00:06:24,840 --> 00:06:30,510
here so we want yet the ID of the person

00:06:27,840 --> 00:06:32,040
the person's name and then some data

00:06:30,510 --> 00:06:34,710
that we need to render the profile

00:06:32,040 --> 00:06:36,090
picture so look what happens if we

00:06:34,710 --> 00:06:38,850
highlight just the fields here and

00:06:36,090 --> 00:06:41,610
remove the values that's a graft well

00:06:38,850 --> 00:06:43,350
query as you can see the query here it

00:06:41,610 --> 00:06:45,480
not only expresses the data that it

00:06:43,350 --> 00:06:47,550
needs but also the precise nested

00:06:45,480 --> 00:06:50,820
structure that we want the response to

00:06:47,550 --> 00:06:52,280
that query to have graph ql is designed

00:06:50,820 --> 00:06:54,650
to be a thin layer over

00:06:52,280 --> 00:06:56,210
existing data model so that clients can

00:06:54,650 --> 00:06:57,980
get the benefit of writing queries like

00:06:56,210 --> 00:07:01,610
this one without the whole server

00:06:57,980 --> 00:07:03,610
needing to be totally rewritten another

00:07:01,610 --> 00:07:06,560
important feature of reps well is that

00:07:03,610 --> 00:07:08,030
you can compose queries so basically one

00:07:06,560 --> 00:07:10,910
graph field query can be built up of

00:07:08,030 --> 00:07:12,950
utter gaps filled queries so this means

00:07:10,910 --> 00:07:14,870
that if you take a component tree like

00:07:12,950 --> 00:07:17,750
this for an application on the one hand

00:07:14,870 --> 00:07:19,280
you can look at it as a way to build a

00:07:17,750 --> 00:07:21,830
view for the whole application so each

00:07:19,280 --> 00:07:25,250
parent component will render its

00:07:21,830 --> 00:07:26,720
children in the same way you can take

00:07:25,250 --> 00:07:28,340
this component tree and look at it as a

00:07:26,720 --> 00:07:30,080
guide for how to build the graph ql

00:07:28,340 --> 00:07:32,060
query for the whole application each

00:07:30,080 --> 00:07:33,980
parent components graph GL query is

00:07:32,060 --> 00:07:37,760
composed from the queries of its

00:07:33,980 --> 00:07:39,470
children so now that you see what graft

00:07:37,760 --> 00:07:41,870
well is we can look at how relay works

00:07:39,470 --> 00:07:44,600
overall each relay component contains

00:07:41,870 --> 00:07:45,919
this query and the render method relays

00:07:44,600 --> 00:07:47,630
going to take the queries from each

00:07:45,919 --> 00:07:50,270
component and build up that overall

00:07:47,630 --> 00:07:53,000
query and send that to the server the

00:07:50,270 --> 00:07:54,590
server is going to respond and then

00:07:53,000 --> 00:07:56,960
really puts our response data into a

00:07:54,590 --> 00:07:59,240
single store and then it will use that

00:07:56,960 --> 00:08:02,120
data to construct prop that it sends out

00:07:59,240 --> 00:08:05,330
to the components for rendering at its

00:08:02,120 --> 00:08:06,530
core this is a flux application the only

00:08:05,330 --> 00:08:08,750
difference is that rather than having

00:08:06,530 --> 00:08:10,520
several or many stores a relay

00:08:08,750 --> 00:08:12,919
application just has this one single

00:08:10,520 --> 00:08:16,039
store containing generic logic for

00:08:12,919 --> 00:08:17,780
dealing with graft well data having this

00:08:16,039 --> 00:08:20,300
single store provides a number of nice

00:08:17,780 --> 00:08:23,360
benefits so for one it reduces the need

00:08:20,300 --> 00:08:25,190
for a lot of the flux boilerplate it

00:08:23,360 --> 00:08:27,070
also helps with data consistency across

00:08:25,190 --> 00:08:29,870
different parts of the application and

00:08:27,070 --> 00:08:31,520
finally it lets us build certain common

00:08:29,870 --> 00:08:33,560
product pattern something like pagin

00:08:31,520 --> 00:08:35,060
aiding through a list of items something

00:08:33,560 --> 00:08:38,330
that you guys have probably implemented

00:08:35,060 --> 00:08:39,890
at least one right into relay so that

00:08:38,330 --> 00:08:44,540
people don't need to build them from

00:08:39,890 --> 00:08:46,010
scratch every time so now that we see

00:08:44,540 --> 00:08:47,570
how really works let's look back at this

00:08:46,010 --> 00:08:49,420
sticker common example and see how much

00:08:47,570 --> 00:08:51,680
easier relay is going to make our lives

00:08:49,420 --> 00:08:53,600
rather than needing to change a bunch of

00:08:51,680 --> 00:08:55,730
files up the whole tree and the server

00:08:53,600 --> 00:08:57,680
we just changed comment item so more

00:08:55,730 --> 00:09:00,020
specifically let's say that this is part

00:08:57,680 --> 00:09:01,670
of our graphical query right now we're

00:09:00,020 --> 00:09:04,620
just putting for the text of the comment

00:09:01,670 --> 00:09:06,660
and now we can also

00:09:04,620 --> 00:09:10,020
with a sticker use that in our render

00:09:06,660 --> 00:09:11,520
method and we're done we can go build

00:09:10,020 --> 00:09:12,990
other awesome stuff in the time that we

00:09:11,520 --> 00:09:16,710
would have spent changing those other

00:09:12,990 --> 00:09:18,570
files so really solves this big problem

00:09:16,710 --> 00:09:20,760
of how to fetch data in a way that we

00:09:18,570 --> 00:09:22,560
found scales really nicely to a complex

00:09:20,760 --> 00:09:24,510
application being developed by a big

00:09:22,560 --> 00:09:25,860
engineering team so because you have

00:09:24,510 --> 00:09:28,440
that data query and the render method

00:09:25,860 --> 00:09:30,240
encapsulated within the component it's

00:09:28,440 --> 00:09:32,010
easy for a lot of people to work on a

00:09:30,240 --> 00:09:35,010
lot of different parts of an application

00:09:32,010 --> 00:09:36,510
at once so I can make my changes my

00:09:35,010 --> 00:09:37,980
teammates can make their changes people

00:09:36,510 --> 00:09:39,180
on other teams can make their changes

00:09:37,980 --> 00:09:40,800
and we don't need to worry as much about

00:09:39,180 --> 00:09:43,080
whether we're stepping on each other's

00:09:40,800 --> 00:09:44,610
toes and whether we have full context on

00:09:43,080 --> 00:09:48,900
what every other person is doing at that

00:09:44,610 --> 00:09:50,850
time so far you've heard about the read

00:09:48,900 --> 00:09:53,160
path and relay but a framework would be

00:09:50,850 --> 00:09:54,750
would have limited usefulness if it

00:09:53,160 --> 00:09:57,300
didn't also support a right path if it

00:09:54,750 --> 00:09:59,640
didn't let developers give users a way

00:09:57,300 --> 00:10:03,150
to take actions that does liking a story

00:09:59,640 --> 00:10:04,950
maybe even liking my own story so I'll

00:10:03,150 --> 00:10:06,870
use the term mutations to refer to these

00:10:04,950 --> 00:10:09,300
actions that a user can take in an

00:10:06,870 --> 00:10:11,070
application so in facebook this could be

00:10:09,300 --> 00:10:14,090
something like sharing a link our suit

00:10:11,070 --> 00:10:16,320
came to an event or poking a friend and

00:10:14,090 --> 00:10:20,730
for the rest of the talk I'll focus on

00:10:16,320 --> 00:10:22,620
how mutations work in relay so to start

00:10:20,730 --> 00:10:24,390
I'm going to go back and talk about how

00:10:22,620 --> 00:10:27,000
we at facebook at least we're building

00:10:24,390 --> 00:10:28,710
mutations before relay so I joined

00:10:27,000 --> 00:10:29,910
facebook a little over three years ago

00:10:28,710 --> 00:10:32,070
and I was working on the newsfeed

00:10:29,910 --> 00:10:34,200
product team mostly working on the

00:10:32,070 --> 00:10:36,000
homepage of the website and i got really

00:10:34,200 --> 00:10:37,830
familiar with writing mutations like

00:10:36,000 --> 00:10:40,470
this i would write some custom

00:10:37,830 --> 00:10:42,600
JavaScript and I would write a custom

00:10:40,470 --> 00:10:44,700
server on point I would have the

00:10:42,600 --> 00:10:46,650
JavaScript called that in point I would

00:10:44,700 --> 00:10:49,710
have the endpoint return data and

00:10:46,650 --> 00:10:50,970
basically whatever format I chose then I

00:10:49,710 --> 00:10:52,500
would have the JavaScript make sense of

00:10:50,970 --> 00:10:55,350
that data and update the views

00:10:52,500 --> 00:10:58,290
accordingly usually by manually updating

00:10:55,350 --> 00:11:00,480
the DOM and then maybe I wanted to also

00:10:58,290 --> 00:11:02,430
use that same endpoint from a different

00:11:00,480 --> 00:11:04,200
part of the client I would need to shove

00:11:02,430 --> 00:11:06,480
some more messy logic in there to make

00:11:04,200 --> 00:11:09,000
sure that the server was returning the

00:11:06,480 --> 00:11:10,500
data that the client needed regardless

00:11:09,000 --> 00:11:13,710
of where it was being called from and

00:11:10,500 --> 00:11:15,480
the key word here is custom basically

00:11:13,710 --> 00:11:17,130
every time my team major I wanted to

00:11:15,480 --> 00:11:18,740
implement a new mutation we had to start

00:11:17,130 --> 00:11:20,720
from scratch

00:11:18,740 --> 00:11:22,310
I personally really disliked this

00:11:20,720 --> 00:11:24,440
pattern of writing mutations with these

00:11:22,310 --> 00:11:26,060
custom endpoints and custom client code

00:11:24,440 --> 00:11:28,940
if I'll really repetitive an error prone

00:11:26,060 --> 00:11:30,350
to me and in my mind this pattern became

00:11:28,940 --> 00:11:32,990
kind of synonymous with writing

00:11:30,350 --> 00:11:34,430
JavaScript because I had just started a

00:11:32,990 --> 00:11:35,839
Facebook I came right out of school this

00:11:34,430 --> 00:11:37,880
is what I did every time I would write

00:11:35,839 --> 00:11:39,649
JavaScript so to me this was JavaScript

00:11:37,880 --> 00:11:41,120
and so I came to think of myself as

00:11:39,649 --> 00:11:42,430
someone who really didn't like

00:11:41,120 --> 00:11:44,480
JavaScript and didn't want to write it

00:11:42,430 --> 00:11:46,790
it wasn't until I was introduced to

00:11:44,480 --> 00:11:48,680
react and flux that I started to realize

00:11:46,790 --> 00:11:51,890
that I don't dislike JavaScript I just

00:11:48,680 --> 00:11:54,110
like this kind of gross pattern of using

00:11:51,890 --> 00:11:55,970
it so I wouldn't have guessed three

00:11:54,110 --> 00:11:57,260
years ago that I would be now on a team

00:11:55,970 --> 00:11:59,510
where I'm writing JavaScript full-time

00:11:57,260 --> 00:12:01,790
or here with all of you guys but a

00:11:59,510 --> 00:12:04,670
JavaScript conference but here I am and

00:12:01,790 --> 00:12:07,310
I'm pretty excited about it so back to

00:12:04,670 --> 00:12:08,779
mutations we we took a step in the right

00:12:07,310 --> 00:12:11,450
direction when we introduced a more

00:12:08,779 --> 00:12:14,360
structured API for doing rights as part

00:12:11,450 --> 00:12:15,290
of our graph API so this was nice

00:12:14,360 --> 00:12:16,940
because it gave the client a

00:12:15,290 --> 00:12:19,880
standardized way to specify what

00:12:16,940 --> 00:12:21,200
mutation they wanted to do and also to

00:12:19,880 --> 00:12:24,740
provide the necessary inputs in a

00:12:21,200 --> 00:12:27,890
structured way but what about the data

00:12:24,740 --> 00:12:29,839
that that the server returns then each

00:12:27,890 --> 00:12:31,279
right endpoint in the graph API is being

00:12:29,839 --> 00:12:33,140
used by a bunch of different clients

00:12:31,279 --> 00:12:34,399
there's not really a great way to make

00:12:33,140 --> 00:12:36,320
sure that the server is going to return

00:12:34,399 --> 00:12:39,290
the data that any client might need to

00:12:36,320 --> 00:12:40,910
update itself so what we would do

00:12:39,290 --> 00:12:43,459
instead is usually provide these pretty

00:12:40,910 --> 00:12:45,500
minimal responses usually just an ID so

00:12:43,459 --> 00:12:46,940
maybe if it was the mutation was writing

00:12:45,500 --> 00:12:48,829
a comment we will just return the idea

00:12:46,940 --> 00:12:51,110
of the new comment or maybe even just a

00:12:48,829 --> 00:12:54,800
boolean saying this mutation succeeded

00:12:51,110 --> 00:12:56,750
or it did and so at that point there's

00:12:54,800 --> 00:12:59,240
two main options for how you update the

00:12:56,750 --> 00:13:01,040
client you can guess you can say okay I

00:12:59,240 --> 00:13:02,420
got this boolean things worked so this

00:13:01,040 --> 00:13:05,540
is how I think the data should look now

00:13:02,420 --> 00:13:07,100
or you could do a second round trip go

00:13:05,540 --> 00:13:08,779
back to the server and get the data that

00:13:07,100 --> 00:13:12,200
you need if you want to be really sure

00:13:08,779 --> 00:13:14,870
that it's right the first option has

00:13:12,200 --> 00:13:17,089
issues with correctness potentially and

00:13:14,870 --> 00:13:19,750
the second has issues with efficiency so

00:13:17,089 --> 00:13:22,279
neither one of those is really ideal

00:13:19,750 --> 00:13:24,230
ideally the response from the server

00:13:22,279 --> 00:13:27,110
would contain exactly the information

00:13:24,230 --> 00:13:29,750
that the client needs top date itself so

00:13:27,110 --> 00:13:31,190
let's talk about liking a story let's

00:13:29,750 --> 00:13:32,620
say we have this mobile client and it

00:13:31,190 --> 00:13:34,900
shows the number of people who

00:13:32,620 --> 00:13:36,760
like the story then we would want the

00:13:34,900 --> 00:13:38,860
server if you did a like to return the

00:13:36,760 --> 00:13:42,730
new light count so that we could update

00:13:38,860 --> 00:13:43,960
the story correctly in our web client

00:13:42,730 --> 00:13:45,070
instead of just showing the number of

00:13:43,960 --> 00:13:47,200
likes we show this thing that we call

00:13:45,070 --> 00:13:48,490
the like sentence and it's it's an

00:13:47,200 --> 00:13:49,930
internationalized string that we

00:13:48,490 --> 00:13:52,150
generate on the server that provides

00:13:49,930 --> 00:13:54,970
some social context about who else who

00:13:52,150 --> 00:13:57,580
who of your friends or who has liked the

00:13:54,970 --> 00:13:58,990
story so for this we would want the

00:13:57,580 --> 00:14:01,620
server to actually return the new like

00:13:58,990 --> 00:14:04,030
sentence so that we could do the update

00:14:01,620 --> 00:14:06,370
okay but then what if we wanted to

00:14:04,030 --> 00:14:08,920
change the mobile client to also show

00:14:06,370 --> 00:14:10,480
the profile pictures of the likers then

00:14:08,920 --> 00:14:12,220
we would want to make sure to update the

00:14:10,480 --> 00:14:14,380
server so that it also returns the new

00:14:12,220 --> 00:14:17,050
likers picture so that we can show that

00:14:14,380 --> 00:14:19,780
when someone likes it and then maybe if

00:14:17,050 --> 00:14:20,890
eventually we took out those pictures we

00:14:19,780 --> 00:14:22,720
would need to clean up that server

00:14:20,890 --> 00:14:25,150
endpoint get rid of the liker picture

00:14:22,720 --> 00:14:26,830
and this situation should start feeling

00:14:25,150 --> 00:14:28,900
kind of familiar to you it's similar to

00:14:26,830 --> 00:14:30,400
what we saw with data reads where we're

00:14:28,900 --> 00:14:32,080
in that situation where the server

00:14:30,400 --> 00:14:34,410
endpoint needed to be aware of the

00:14:32,080 --> 00:14:36,760
details of the clients rendering logic

00:14:34,410 --> 00:14:38,680
when we change the client rendering we

00:14:36,760 --> 00:14:40,090
need to change what we return from the

00:14:38,680 --> 00:14:41,740
right endpoint on the server and it gets

00:14:40,090 --> 00:14:45,880
kind of tough and time-consuming to keep

00:14:41,740 --> 00:14:47,950
those two places in sync just like

00:14:45,880 --> 00:14:50,290
before relay and graphs well can help us

00:14:47,950 --> 00:14:52,120
solve the problem so it turns out the

00:14:50,290 --> 00:14:54,970
graph ql doesn't just support doing data

00:14:52,120 --> 00:14:57,850
reads it also supports right graph ql

00:14:54,970 --> 00:14:59,140
mutations so how will this work and

00:14:57,850 --> 00:15:00,700
graph ql if you want to do a dick read

00:14:59,140 --> 00:15:02,800
you just provide a query and you get a

00:15:00,700 --> 00:15:04,330
response mutations are a little

00:15:02,800 --> 00:15:06,310
different so you need to provide three

00:15:04,330 --> 00:15:08,740
piece of information the type of the

00:15:06,310 --> 00:15:10,390
mutation that you're trying to do any

00:15:08,740 --> 00:15:13,090
inputs that will usually just be an ID

00:15:10,390 --> 00:15:15,040
or two and then a query for the data

00:15:13,090 --> 00:15:18,250
that you want after that mutation has

00:15:15,040 --> 00:15:20,710
been performed so for liking a story

00:15:18,250 --> 00:15:23,470
what would this be the type is just

00:15:20,710 --> 00:15:25,150
story like the inputs that you need to

00:15:23,470 --> 00:15:27,670
give our just the idea of the story that

00:15:25,150 --> 00:15:29,020
your liking and then the query can be

00:15:27,670 --> 00:15:30,610
anything but in this case let's say we

00:15:29,020 --> 00:15:31,840
want to know if the viewer likes the

00:15:30,610 --> 00:15:33,850
story so you know if you should make

00:15:31,840 --> 00:15:35,590
that little thumb blue and then the

00:15:33,850 --> 00:15:38,530
count of the number of people that like

00:15:35,590 --> 00:15:41,290
it so when we send this information to

00:15:38,530 --> 00:15:43,690
graft well it performs the right and

00:15:41,290 --> 00:15:45,880
then it runs that query and then it will

00:15:43,690 --> 00:15:46,300
send us back this payload which we can

00:15:45,880 --> 00:15:50,140
use

00:15:46,300 --> 00:15:51,760
to update the client relay uses graph ql

00:15:50,140 --> 00:15:53,590
mutations for all of its data rights

00:15:51,760 --> 00:15:55,210
which provides a standardized way to

00:15:53,590 --> 00:15:58,540
both perform the rites and then to

00:15:55,210 --> 00:15:59,740
update the client afterwards but let's

00:15:58,540 --> 00:16:01,870
look back at these three pieces of

00:15:59,740 --> 00:16:03,580
information here one of the more

00:16:01,870 --> 00:16:05,440
interesting problems that we face when

00:16:03,580 --> 00:16:08,290
developing this mutations framework for

00:16:05,440 --> 00:16:11,350
relay was how to decide what this query

00:16:08,290 --> 00:16:13,450
should actually be so our goal here was

00:16:11,350 --> 00:16:16,060
to get the client data consistent with

00:16:13,450 --> 00:16:18,940
the new post mutation state of the world

00:16:16,060 --> 00:16:21,760
so we want this query to be for anything

00:16:18,940 --> 00:16:23,620
that we had in the store in our in relay

00:16:21,760 --> 00:16:27,070
that could have changed as a result of

00:16:23,620 --> 00:16:28,570
the mutation happening so one option the

00:16:27,070 --> 00:16:30,910
easiest option is just to have the

00:16:28,570 --> 00:16:32,380
developer write these crazy manually so

00:16:30,910 --> 00:16:35,350
in this example they would write this

00:16:32,380 --> 00:16:38,560
query but then let's say someone came

00:16:35,350 --> 00:16:40,750
and added profile pictures here we would

00:16:38,560 --> 00:16:42,040
send this information to the server the

00:16:40,750 --> 00:16:44,710
right would happen we would get this

00:16:42,040 --> 00:16:46,000
response back and we wouldn't have the

00:16:44,710 --> 00:16:49,840
new profile picture in the right size

00:16:46,000 --> 00:16:51,400
and and this would be a bug so to avoid

00:16:49,840 --> 00:16:53,260
that the person who added the profile

00:16:51,400 --> 00:16:54,940
pictures would need to make sure to go

00:16:53,260 --> 00:16:57,040
find that mutation query probably

00:16:54,940 --> 00:16:59,080
somewhere in some other file and add the

00:16:57,040 --> 00:17:00,940
profile picture in there and more

00:16:59,080 --> 00:17:03,460
generally we would be in this situation

00:17:00,940 --> 00:17:04,630
where every time someone changed some

00:17:03,460 --> 00:17:06,040
rendering logic they would need to

00:17:04,630 --> 00:17:07,840
remember to go find all of the

00:17:06,040 --> 00:17:10,300
potentially relevant mutation queries

00:17:07,840 --> 00:17:12,250
and change them this wasn't a great

00:17:10,300 --> 00:17:14,320
option for us since with relay we really

00:17:12,250 --> 00:17:16,210
want to minimize these situations where

00:17:14,320 --> 00:17:17,320
you make a change somewhere and then you

00:17:16,210 --> 00:17:21,550
need to make a change in a bunch of

00:17:17,320 --> 00:17:23,320
other places so instead we put the logic

00:17:21,550 --> 00:17:26,490
to determine the correct mutation query

00:17:23,320 --> 00:17:29,110
into relay itself how does this work so

00:17:26,490 --> 00:17:31,810
intrinsic to every graph ql mutation is

00:17:29,110 --> 00:17:34,060
the set of data that can change as a

00:17:31,810 --> 00:17:36,040
result of that mutation so this is an

00:17:34,060 --> 00:17:37,660
independent of what any client renders

00:17:36,040 --> 00:17:39,340
it's a property of the mutation itself

00:17:37,660 --> 00:17:42,040
so it's a property of story like or a

00:17:39,340 --> 00:17:44,920
comment create so here's the set of

00:17:42,040 --> 00:17:47,800
things that can change when we do a

00:17:44,920 --> 00:17:49,780
story like and if we always queried for

00:17:47,800 --> 00:17:51,850
everything that can change every time we

00:17:49,780 --> 00:17:54,070
did a mutation we would clearly end up

00:17:51,850 --> 00:17:55,930
in a consistent state but we might be

00:17:54,070 --> 00:17:57,010
massively over fetching since maybe we

00:17:55,930 --> 00:17:59,920
never rendered any of

00:17:57,010 --> 00:18:02,580
data we don't care about some of them so

00:17:59,920 --> 00:18:05,130
we have relied keep track for each ID of

00:18:02,580 --> 00:18:07,420
the set of data that the client has

00:18:05,130 --> 00:18:10,380
retrieved for that ID and put into its

00:18:07,420 --> 00:18:12,670
store so if we had rendered my story

00:18:10,380 --> 00:18:14,610
maybe this would be the set of the data

00:18:12,670 --> 00:18:18,250
that we have fetched for my story and

00:18:14,610 --> 00:18:20,980
then when you do a mutation on some

00:18:18,250 --> 00:18:23,770
story or on some ID really builds a

00:18:20,980 --> 00:18:26,680
mutation query by intersecting this set

00:18:23,770 --> 00:18:28,750
of things that can possibly change with

00:18:26,680 --> 00:18:30,250
the set of things that it knows that it

00:18:28,750 --> 00:18:33,460
cares about the set of things that it

00:18:30,250 --> 00:18:35,590
has in a store this ensures that we

00:18:33,460 --> 00:18:39,220
query for exactly the set of field that

00:18:35,590 --> 00:18:42,520
needs to be updated so in this case we

00:18:39,220 --> 00:18:45,130
would end up with this query here and

00:18:42,520 --> 00:18:47,350
the really nice part of this is that if

00:18:45,130 --> 00:18:50,260
someone does come along and let's say

00:18:47,350 --> 00:18:54,400
they replace that three likes with the

00:18:50,260 --> 00:18:56,290
like sentence then relay this what we've

00:18:54,400 --> 00:18:57,850
stored will know that we've now fetched

00:18:56,290 --> 00:18:59,650
the like sentence for that story not the

00:18:57,850 --> 00:19:02,440
Lakers count and so when we do this

00:18:59,650 --> 00:19:03,850
intersection the intersected query will

00:19:02,440 --> 00:19:05,500
be the correct one will correctly ask

00:19:03,850 --> 00:19:09,850
the server for the new like sentence

00:19:05,500 --> 00:19:12,250
rather than the like count so those are

00:19:09,850 --> 00:19:15,400
the basics of how relay mutations work

00:19:12,250 --> 00:19:17,830
the user takes an action we send the

00:19:15,400 --> 00:19:19,900
name of the mutation and any inputs into

00:19:17,830 --> 00:19:21,790
relay and really does that intersection

00:19:19,900 --> 00:19:24,220
to figure out what the query should be

00:19:21,790 --> 00:19:26,560
it'll send that over to the server the

00:19:24,220 --> 00:19:28,660
server will respond will put that

00:19:26,560 --> 00:19:30,550
response into the store and then we'll

00:19:28,660 --> 00:19:33,220
notify the affected views by sending

00:19:30,550 --> 00:19:35,080
them updated crops and you'll notice

00:19:33,220 --> 00:19:36,490
that this diagram is kind of similar to

00:19:35,080 --> 00:19:39,490
the one I showed you for the read path

00:19:36,490 --> 00:19:41,680
before in particular the second part is

00:19:39,490 --> 00:19:43,390
identical in the two flows graph ql

00:19:41,680 --> 00:19:44,980
sends us some data relay puts it in the

00:19:43,390 --> 00:19:47,410
store and then we send the props to the

00:19:44,980 --> 00:19:48,910
components these parallels between the

00:19:47,410 --> 00:19:51,610
read and the right flows are not a

00:19:48,910 --> 00:19:54,190
coincidence just like flux relay treats

00:19:51,610 --> 00:19:56,140
data rights as first-class citizens by

00:19:54,190 --> 00:20:00,070
using the same core logic and code to

00:19:56,140 --> 00:20:02,320
handle both reads and writes so if

00:20:00,070 --> 00:20:04,270
you've written mutations before you'll

00:20:02,320 --> 00:20:05,560
know that even when you have v1 working

00:20:04,270 --> 00:20:07,300
when you have the right actually

00:20:05,560 --> 00:20:09,490
happening on the server and then the

00:20:07,300 --> 00:20:10,830
client getting updated correctly there's

00:20:09,490 --> 00:20:13,260
there's often a lot more

00:20:10,830 --> 00:20:15,690
to be done so maybe you have to think

00:20:13,260 --> 00:20:17,490
about things like making that feel more

00:20:15,690 --> 00:20:19,649
responsive by having the client kind of

00:20:17,490 --> 00:20:21,210
doing fake updates instantaneously or

00:20:19,649 --> 00:20:24,179
you have to worry about how to handle

00:20:21,210 --> 00:20:27,450
errors timeout retries or things like

00:20:24,179 --> 00:20:29,279
race conditions because relay has this

00:20:27,450 --> 00:20:31,049
centralized mutations framework we're

00:20:29,279 --> 00:20:33,120
able to take a lot of these common

00:20:31,049 --> 00:20:35,669
concerns and put them into relay itself

00:20:33,120 --> 00:20:37,320
so the developers get that get the

00:20:35,669 --> 00:20:38,669
handling of those issues for free rather

00:20:37,320 --> 00:20:41,370
than needing to solve them again and

00:20:38,669 --> 00:20:42,870
again with each new mutation so let's

00:20:41,370 --> 00:20:45,419
start with that app responsiveness

00:20:42,870 --> 00:20:46,950
example if I implement its story like

00:20:45,419 --> 00:20:49,080
the way that I've described so far and

00:20:46,950 --> 00:20:51,450
then someone use this app and hit the

00:20:49,080 --> 00:20:53,070
like button they notice a significant

00:20:51,450 --> 00:20:57,000
delay between when they hit like and

00:20:53,070 --> 00:20:57,960
when one app actually changes because

00:20:57,000 --> 00:20:59,370
we're sitting there waiting for the

00:20:57,960 --> 00:21:02,130
server response to come back waiting for

00:20:59,370 --> 00:21:03,480
that graphical response it would be nice

00:21:02,130 --> 00:21:06,120
if we didn't have to deal with this

00:21:03,480 --> 00:21:07,860
delay and lucky for us really provide

00:21:06,120 --> 00:21:10,049
support for what we call optimistic

00:21:07,860 --> 00:21:12,360
mutations where we immediately update

00:21:10,049 --> 00:21:13,860
the view to the expected post right

00:21:12,360 --> 00:21:16,820
state being optimistic that everything

00:21:13,860 --> 00:21:19,230
will work out nicely on the server

00:21:16,820 --> 00:21:21,179
essentially to make this happen you can

00:21:19,230 --> 00:21:23,309
provide a payload mimicking the server

00:21:21,179 --> 00:21:26,039
response and then the view will change

00:21:23,309 --> 00:21:27,659
instantly based on that payload so that

00:21:26,039 --> 00:21:29,159
optimistic payload doesn't have to

00:21:27,659 --> 00:21:30,929
include everything that would be in the

00:21:29,159 --> 00:21:32,429
server update it can include as much or

00:21:30,929 --> 00:21:33,929
as little information as you need to

00:21:32,429 --> 00:21:36,029
make things feel right so it's kind of

00:21:33,929 --> 00:21:37,139
just a we want this to feel good in

00:21:36,029 --> 00:21:39,510
between when we're waiting for the

00:21:37,139 --> 00:21:41,159
server response to come back so maybe

00:21:39,510 --> 00:21:42,840
for story like we would just do an

00:21:41,159 --> 00:21:45,450
optimistic peeled like this just slip

00:21:42,840 --> 00:21:46,860
does viewer like to true and that would

00:21:45,450 --> 00:21:48,720
cause the the thumb to turn blue

00:21:46,860 --> 00:21:50,250
immediately but maybe you'd think this

00:21:48,720 --> 00:21:53,010
is kind of weird because you still see

00:21:50,250 --> 00:21:54,750
to like so you could do this instead is

00:21:53,010 --> 00:21:57,539
optimistic payload we're now you're also

00:21:54,750 --> 00:21:59,429
incrementing the count by one so that

00:21:57,539 --> 00:22:02,760
you'll get the three likes and the blue

00:21:59,429 --> 00:22:04,409
thumb instantly if I had wanted to do an

00:22:02,760 --> 00:22:05,760
optimistic update like this back when I

00:22:04,409 --> 00:22:07,200
was writing mutation for the newsfeed

00:22:05,760 --> 00:22:09,870
team I would need to just add a bunch of

00:22:07,200 --> 00:22:11,429
code to manually update the Dom in a

00:22:09,870 --> 00:22:13,169
react application i could call us at

00:22:11,429 --> 00:22:15,870
state to get my component to rerender

00:22:13,169 --> 00:22:17,309
with this new optimistic data but in

00:22:15,870 --> 00:22:18,510
really i just provide this optimistic

00:22:17,309 --> 00:22:19,830
tailored and then everything else

00:22:18,510 --> 00:22:23,059
happens automatically the framework

00:22:19,830 --> 00:22:25,129
automatically will update the views

00:22:23,059 --> 00:22:27,139
so I want to describe now how these

00:22:25,129 --> 00:22:28,940
optimistic mutations have been behind

00:22:27,139 --> 00:22:30,980
the scenes even though the view is

00:22:28,940 --> 00:22:32,779
changing immediately with optimistic

00:22:30,980 --> 00:22:34,850
update really isn't immediately

00:22:32,779 --> 00:22:37,610
overriding the data in that graph you'll

00:22:34,850 --> 00:22:40,759
store so instead we maintain a queue of

00:22:37,610 --> 00:22:41,990
in-flight mutations mutations that we've

00:22:40,759 --> 00:22:43,669
done the optimistic update but the

00:22:41,990 --> 00:22:45,950
server response hasn't come back yet and

00:22:43,669 --> 00:22:48,379
when we read data from the store we read

00:22:45,950 --> 00:22:50,299
through that Q so what does that look

00:22:48,379 --> 00:22:53,509
like let's say that this is the data in

00:22:50,299 --> 00:22:54,860
our store for my story so the UI is

00:22:53,509 --> 00:22:58,429
going to reflect what we have in the

00:22:54,860 --> 00:22:59,899
store and then let's say I do alike so

00:22:58,429 --> 00:23:02,779
you'll notice that the UI block

00:22:59,899 --> 00:23:04,700
immediately changed blue but the store

00:23:02,779 --> 00:23:07,730
we haven't changed anything in the store

00:23:04,700 --> 00:23:09,679
yet and now I do a comment again because

00:23:07,730 --> 00:23:11,149
of the optimistic update the UI changes

00:23:09,679 --> 00:23:14,480
instantly but the store is still

00:23:11,149 --> 00:23:16,039
untouched so now we get the server

00:23:14,480 --> 00:23:18,499
payload let's say the like succeeded

00:23:16,039 --> 00:23:20,860
this is when will actually remove that

00:23:18,499 --> 00:23:23,840
like from the queue and update the store

00:23:20,860 --> 00:23:26,330
so now what if we get an error for the

00:23:23,840 --> 00:23:28,279
comment so if we had immediately written

00:23:26,330 --> 00:23:30,230
that comment into the store when as soon

00:23:28,279 --> 00:23:31,249
as I did it this is when we would be in

00:23:30,230 --> 00:23:33,799
a little bit of a sticky situation

00:23:31,249 --> 00:23:35,210
because we need to kind of roll back our

00:23:33,799 --> 00:23:36,529
changes make sure that we left the store

00:23:35,210 --> 00:23:38,779
in the exact state that it had been

00:23:36,529 --> 00:23:41,600
before but because we maintain this

00:23:38,779 --> 00:23:44,179
queue all you need to do is remove it

00:23:41,600 --> 00:23:46,190
from the queue the stores still in good

00:23:44,179 --> 00:23:49,759
shape and the UI goes back to taking the

00:23:46,190 --> 00:23:52,340
comment away the mutations q also makes

00:23:49,759 --> 00:23:53,929
it simple to deal with retries so let's

00:23:52,340 --> 00:23:56,450
say that I'm trying to comment and say

00:23:53,929 --> 00:23:58,490
thanks to my friends here so I hit post

00:23:56,450 --> 00:24:00,799
and the optimistic update happens

00:23:58,490 --> 00:24:03,200
immediately and is added to the queue

00:24:00,799 --> 00:24:04,820
and then an error comes back so in the

00:24:03,200 --> 00:24:06,440
example I just showed you I took them I

00:24:04,820 --> 00:24:09,740
just said okay there was an error take

00:24:06,440 --> 00:24:12,200
it out of the queue revert but what we

00:24:09,740 --> 00:24:15,649
can also do is keep it in the queue but

00:24:12,200 --> 00:24:17,240
mark it with an error state and the view

00:24:15,649 --> 00:24:18,679
can pick up on this air state and show

00:24:17,240 --> 00:24:21,440
that little message unable to post

00:24:18,679 --> 00:24:23,539
comment try again and then if I do hit

00:24:21,440 --> 00:24:25,460
try again it's easy to perform that

00:24:23,539 --> 00:24:26,990
retry since we have that comment

00:24:25,460 --> 00:24:28,580
mutation sitting in the queue and it

00:24:26,990 --> 00:24:30,590
contains all the data that it needs to

00:24:28,580 --> 00:24:34,940
basically send itself off to the server

00:24:30,590 --> 00:24:37,759
again so I hit retry and this time it

00:24:34,940 --> 00:24:40,169
works and voila

00:24:37,759 --> 00:24:42,450
so a final nice feature of relay

00:24:40,169 --> 00:24:44,220
mutations framework is that it provides

00:24:42,450 --> 00:24:46,440
a solution for race conditions that you

00:24:44,220 --> 00:24:48,570
can get when someone is performing a

00:24:46,440 --> 00:24:50,730
quick sequence of mutations on all

00:24:48,570 --> 00:24:52,950
affecting the same object so let's say

00:24:50,730 --> 00:24:56,100
that I quickly like and unlike my story

00:24:52,950 --> 00:24:57,509
a bunch of times in a row there's a

00:24:56,100 --> 00:24:59,639
pretty high chance here that something's

00:24:57,509 --> 00:25:02,989
going to go wrong if we just didn't have

00:24:59,639 --> 00:25:05,850
any special casing for the situation so

00:25:02,989 --> 00:25:08,399
there's a race condition for my

00:25:05,850 --> 00:25:10,859
mutations hitting the server if the if

00:25:08,399 --> 00:25:12,509
I've ended up on an unlike but the like

00:25:10,859 --> 00:25:13,830
is the last one hit the server then

00:25:12,509 --> 00:25:15,779
we're going to have the wrong state of

00:25:13,830 --> 00:25:18,679
data on the server and even if that all

00:25:15,779 --> 00:25:21,600
works out we have another race condition

00:25:18,679 --> 00:25:23,909
for those payloads coming back where

00:25:21,600 --> 00:25:24,929
it's the last one that comes back is the

00:25:23,909 --> 00:25:27,830
like then we're going to have an

00:25:24,929 --> 00:25:30,179
inconsistent State on the client in

00:25:27,830 --> 00:25:32,279
relay we have a way to detect the view

00:25:30,179 --> 00:25:33,869
mutations are dependent and guarantee

00:25:32,279 --> 00:25:36,690
that only one of them is in flight at a

00:25:33,869 --> 00:25:38,460
time so the first one goes off and only

00:25:36,690 --> 00:25:40,679
when that payload comes back do we send

00:25:38,460 --> 00:25:42,330
off the second one and so on so all the

00:25:40,679 --> 00:25:44,039
optimistic rights still happen

00:25:42,330 --> 00:25:45,359
immediately so the person using the

00:25:44,039 --> 00:25:46,559
application doesn't know that we're

00:25:45,359 --> 00:25:49,739
doing anything different behind the

00:25:46,559 --> 00:25:50,730
scenes but we do this thing to ensure

00:25:49,739 --> 00:25:54,899
that we're not going to get these

00:25:50,730 --> 00:25:56,820
collisions so all what I've described so

00:25:54,899 --> 00:25:58,710
far relay and its mutations framework

00:25:56,820 --> 00:26:00,989
are already being used in a few places

00:25:58,710 --> 00:26:03,239
in production at Facebook including our

00:26:00,989 --> 00:26:05,279
standalone groups app and our mobile ads

00:26:03,239 --> 00:26:07,889
manager app which are both using both

00:26:05,279 --> 00:26:09,059
relay and react native I'm going to

00:26:07,889 --> 00:26:10,859
spend the last few minutes here

00:26:09,059 --> 00:26:12,450
discussing a part of relay that we're

00:26:10,859 --> 00:26:15,989
still working on that's not yet in

00:26:12,450 --> 00:26:18,960
production so this was a diagram that I

00:26:15,989 --> 00:26:20,519
showed earlier to explain mutations as i

00:26:18,960 --> 00:26:22,950
explained really can take this mutation

00:26:20,519 --> 00:26:24,899
payload from graft well store it and

00:26:22,950 --> 00:26:27,600
then send the props to any effective

00:26:24,899 --> 00:26:28,710
views so here the action is originating

00:26:27,600 --> 00:26:30,960
from the person who's using the

00:26:28,710 --> 00:26:35,129
application but that doesn't have to be

00:26:30,960 --> 00:26:38,489
the case so imagine if Joe comments on

00:26:35,129 --> 00:26:41,159
my story from his phone we can actually

00:26:38,489 --> 00:26:43,799
use this same path once it goes through

00:26:41,159 --> 00:26:46,230
the cloud to send his mutation payload

00:26:43,799 --> 00:26:48,600
to relay put it in the store and then

00:26:46,230 --> 00:26:50,640
update the views to show his new comment

00:26:48,600 --> 00:26:52,650
do we call this a subscription

00:26:50,640 --> 00:26:54,570
basically if I'm looking at a new speed

00:26:52,650 --> 00:26:56,790
story I can subscribe to all new

00:26:54,570 --> 00:26:58,230
comments happening on that story and at

00:26:56,790 --> 00:27:00,360
the time that i subscribe i'll provide a

00:26:58,230 --> 00:27:02,910
graph to all queries saying here's the

00:27:00,360 --> 00:27:05,520
query for what data i want for every new

00:27:02,910 --> 00:27:07,680
comment that comes in and then using a

00:27:05,520 --> 00:27:09,390
pub sub system in the back end we can

00:27:07,680 --> 00:27:10,890
ensure that all of these mutation

00:27:09,390 --> 00:27:13,170
payloads for each new comment are

00:27:10,890 --> 00:27:14,700
delivered whenever someone comments and

00:27:13,170 --> 00:27:17,490
then relay will automatically update the

00:27:14,700 --> 00:27:19,500
views so along the same lines I've say

00:27:17,490 --> 00:27:21,750
media or firebase this subscriptions

00:27:19,500 --> 00:27:24,000
piece of relay provides a simple way to

00:27:21,750 --> 00:27:26,100
build dynamic applications that feel

00:27:24,000 --> 00:27:26,970
alive with real-time updates and this is

00:27:26,100 --> 00:27:28,650
something that we're excited about

00:27:26,970 --> 00:27:32,310
integrating into various parts of

00:27:28,650 --> 00:27:34,920
facebook so I'm going to close with just

00:27:32,310 --> 00:27:36,810
a few last points the core idea of relay

00:27:34,920 --> 00:27:38,160
just to re-emphasize that is that we

00:27:36,810 --> 00:27:40,230
should keep our data fetching logic

00:27:38,160 --> 00:27:42,120
together with our rendering logic within

00:27:40,230 --> 00:27:44,250
each component because we found this

00:27:42,120 --> 00:27:47,240
approach to really scale well to a big

00:27:44,250 --> 00:27:49,500
application being built by a big team

00:27:47,240 --> 00:27:51,810
one of our main goals when we've

00:27:49,500 --> 00:27:53,490
designed really has been to identify

00:27:51,810 --> 00:27:55,230
these problematic patterns that people

00:27:53,490 --> 00:27:57,180
are facing again and again and that are

00:27:55,230 --> 00:27:59,190
slowing them down and pull the

00:27:57,180 --> 00:28:01,380
complexity of those patterns into relay

00:27:59,190 --> 00:28:03,870
so we saw a few examples of this today

00:28:01,380 --> 00:28:05,670
with relay mutations from the way that

00:28:03,870 --> 00:28:07,800
we do that intersection to determine the

00:28:05,670 --> 00:28:09,810
correct mutation query to the way that

00:28:07,800 --> 00:28:12,330
we have optimistic updates in that queue

00:28:09,810 --> 00:28:14,550
to our solution for rage conditions in

00:28:12,330 --> 00:28:16,080
each case someone using relay will get

00:28:14,550 --> 00:28:18,270
these common problems solved for free

00:28:16,080 --> 00:28:20,640
and can focus on bigger and better

00:28:18,270 --> 00:28:23,010
things so I'm going to close with one

00:28:20,640 --> 00:28:25,100
last sticker comment thank you all for

00:28:23,010 --> 00:28:25,100
listening

00:28:51,500 --> 00:28:53,560

YouTube URL: https://www.youtube.com/watch?v=mmke4w4gc6c


