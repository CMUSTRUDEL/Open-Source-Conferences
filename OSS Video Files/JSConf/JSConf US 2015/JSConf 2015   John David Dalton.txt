Title: JSConf 2015   John David Dalton
Publication date: 2015-06-17
Playlist: JSConf US 2015
Description: 
	
Captions: 
	00:00:13,950 --> 00:00:19,689
so hi I'm John David Dalton I was

00:00:17,859 --> 00:00:23,320
formerly the Pro Performance Program

00:00:19,689 --> 00:00:26,140
Manager at chakra i'm also a javascript

00:00:23,320 --> 00:00:28,810
library author i developed lodash right

00:00:26,140 --> 00:00:31,269
now i am in the developer sorry the web

00:00:28,810 --> 00:00:32,769
frameworks ecosystem team on your ms

00:00:31,269 --> 00:00:34,540
edge so you'll be seeing me do a lot

00:00:32,769 --> 00:00:36,309
more open source work doing poor

00:00:34,540 --> 00:00:38,260
requests on your various projects and

00:00:36,309 --> 00:00:41,559
things like that but today's talk is on

00:00:38,260 --> 00:00:49,570
built-ins written in JavaScript so let's

00:00:41,559 --> 00:00:52,840
get into it so I entitled the talk

00:00:49,570 --> 00:00:54,489
drawing hands because it's JavaScript

00:00:52,840 --> 00:00:57,340
built-ins written in the language itself

00:00:54,489 --> 00:00:59,469
under the hood so you can't observe that

00:00:57,340 --> 00:01:01,480
it's written in JavaScript but it

00:00:59,469 --> 00:01:02,980
actually is and so this allows you to

00:01:01,480 --> 00:01:06,729
power and so that's this drawing here

00:01:02,980 --> 00:01:09,580
was the lithograph graph was done by MC

00:01:06,729 --> 00:01:11,530
Escher and self-hosting I'll be saying

00:01:09,580 --> 00:01:12,880
this a lot this is when parts or whole

00:01:11,530 --> 00:01:20,140
of a language written in the language

00:01:12,880 --> 00:01:23,709
itself but what is this ray this says

00:01:20,140 --> 00:01:28,050
bang go on this baby wipes did you leave

00:01:23,709 --> 00:01:33,940
this here from your first talk what yeah

00:01:28,050 --> 00:01:37,509
krill says hey by the way yeah all right

00:01:33,940 --> 00:01:43,170
now that that's done that was my most

00:01:37,509 --> 00:01:46,840
important bit all right all right so

00:01:43,170 --> 00:01:48,610
yeah yeah you must be here for this all

00:01:46,840 --> 00:01:51,429
right so first I'm going to go into the

00:01:48,610 --> 00:01:53,770
good the bad and the ugly of built-ins

00:01:51,429 --> 00:01:56,709
written in JavaScript so first let's

00:01:53,770 --> 00:01:58,869
talk about the good things so ease of

00:01:56,709 --> 00:01:59,950
development because they are built ins

00:01:58,869 --> 00:02:01,599
and they're written in javascript in

00:01:59,950 --> 00:02:03,340
these these engines are open source you

00:02:01,599 --> 00:02:04,690
can view them you can see them you can

00:02:03,340 --> 00:02:06,099
examine their code we're going to look

00:02:04,690 --> 00:02:08,679
at their code in just a little bit and

00:02:06,099 --> 00:02:10,509
kind of see how they're made so it

00:02:08,679 --> 00:02:13,770
allows you to contribute back to the

00:02:10,509 --> 00:02:17,849
project see more contributions naturally

00:02:13,770 --> 00:02:22,060
performance the good thing is is is it's

00:02:17,849 --> 00:02:23,680
widely used to allow the built-ins to

00:02:22,060 --> 00:02:25,630
leverage the same optimizations that

00:02:23,680 --> 00:02:28,630
your normal JavaScript gets celeb

00:02:25,630 --> 00:02:29,740
from the jit so you get in lining for

00:02:28,630 --> 00:02:32,470
free you don't have to do any extra

00:02:29,740 --> 00:02:34,540
extra work there and so there gives you

00:02:32,470 --> 00:02:37,750
some superior performance so some

00:02:34,540 --> 00:02:39,130
engines like Firefox and Chrome I'm

00:02:37,750 --> 00:02:41,980
sorry browsers like Firefox and Chrome

00:02:39,130 --> 00:02:44,980
will will use JavaScript to implement

00:02:41,980 --> 00:02:46,390
array for each filter map every in all

00:02:44,980 --> 00:02:53,020
of those because they get the inlining

00:02:46,390 --> 00:02:54,880
benefits so experimental API so this is

00:02:53,020 --> 00:02:57,880
something i'll be digging into a little

00:02:54,880 --> 00:03:00,940
bit later in my job to is is anytime

00:02:57,880 --> 00:03:03,960
there is an experimental API like a

00:03:00,940 --> 00:03:06,250
proposed api from the w3c you can use

00:03:03,960 --> 00:03:08,050
javascript to implement that quickly and

00:03:06,250 --> 00:03:10,330
get that into an experimental build and

00:03:08,050 --> 00:03:17,740
testable and so debs can try it out and

00:03:10,330 --> 00:03:22,030
use it so examples what do I mean when I

00:03:17,740 --> 00:03:25,570
say examples are JavaScript methods

00:03:22,030 --> 00:03:28,480
built-in in the language let's see do I

00:03:25,570 --> 00:03:32,670
have any examples here no i don't but i

00:03:28,480 --> 00:03:36,340
can go over here and I've got them so

00:03:32,670 --> 00:03:39,730
here's an example of a built-in written

00:03:36,340 --> 00:03:41,470
for Mozilla spider monkey and this is

00:03:39,730 --> 00:03:44,140
I'll zoom in here and zoom around so you

00:03:41,470 --> 00:03:47,320
all can see a little bit better here we

00:03:44,140 --> 00:03:49,270
go so here's array index up array index

00:03:47,320 --> 00:03:51,280
up is pretty straightforward it's

00:03:49,270 --> 00:03:53,290
basically you give it so you have an

00:03:51,280 --> 00:03:55,000
array and you're looking for a needle in

00:03:53,290 --> 00:03:57,520
a haystack you're looking for the index

00:03:55,000 --> 00:04:00,130
of a given element and it does strict

00:03:57,520 --> 00:04:01,360
equality comparisons and so this if

00:04:00,130 --> 00:04:05,700
you're if you're familiar with shims

00:04:01,360 --> 00:04:08,620
this looks really close to a shim right

00:04:05,700 --> 00:04:10,690
you can see down here it's doing a

00:04:08,620 --> 00:04:13,120
little extra check though it says hey if

00:04:10,690 --> 00:04:14,950
this array is packed so there's a

00:04:13,120 --> 00:04:17,859
there's a concept in arrays and the

00:04:14,950 --> 00:04:21,430
older es5 yes three methods had to be

00:04:17,859 --> 00:04:23,710
aware of this is sparse arrays sparse

00:04:21,430 --> 00:04:25,810
arrays are these things that I don't

00:04:23,710 --> 00:04:27,070
deal with I treat them as all dense but

00:04:25,810 --> 00:04:28,750
they have performance impacts and so

00:04:27,070 --> 00:04:30,940
that's why this JavaScript function is

00:04:28,750 --> 00:04:36,010
forking its behavior based on that so

00:04:30,940 --> 00:04:39,430
this is calling into a helper that is I

00:04:36,010 --> 00:04:41,680
believe C++ code that allows them to

00:04:39,430 --> 00:04:44,470
to Detective if an array is packed or

00:04:41,680 --> 00:04:46,720
not so basically dense or sparse and

00:04:44,470 --> 00:04:49,240
then it goes here so now we've seen that

00:04:46,720 --> 00:04:52,600
that looks pretty straight forward let's

00:04:49,240 --> 00:04:54,940
look at let's see we don't need to see

00:04:52,600 --> 00:04:58,570
the the is pack this is the check right

00:04:54,940 --> 00:05:01,810
here to see if a value is packed and I'm

00:04:58,570 --> 00:05:04,000
not a C++ dev so I really don't know a

00:05:01,810 --> 00:05:05,920
ton of what's going on there but you can

00:05:04,000 --> 00:05:08,320
see that you can you can a mix

00:05:05,920 --> 00:05:10,060
javascript and and native methods

00:05:08,320 --> 00:05:12,840
together to create your built-in

00:05:10,060 --> 00:05:18,810
implementation and that's really cool

00:05:12,840 --> 00:05:21,880
here is the eights version of index of

00:05:18,810 --> 00:05:23,320
so we can zoom in here you can see it's

00:05:21,880 --> 00:05:26,740
doing the same kind of juggling it's

00:05:23,320 --> 00:05:29,200
doing a length checks it's doing the

00:05:26,740 --> 00:05:31,300
same use like the use sparse variant

00:05:29,200 --> 00:05:34,000
check and there it's having to make an

00:05:31,300 --> 00:05:35,710
inference about the array so it's having

00:05:34,000 --> 00:05:38,620
to guess if the array is likely to be

00:05:35,710 --> 00:05:40,900
sparse and then go down this path else

00:05:38,620 --> 00:05:46,480
go down another path so you notice that

00:05:40,900 --> 00:05:49,810
here they may not have as much insight

00:05:46,480 --> 00:05:51,340
into the engine or into the into what's

00:05:49,810 --> 00:05:52,890
going on with the values that's being

00:05:51,340 --> 00:05:57,610
passed because it's just JavaScript

00:05:52,890 --> 00:05:58,960
right so that may be an issue with

00:05:57,610 --> 00:06:01,270
implementing it in JavaScript now you

00:05:58,960 --> 00:06:05,290
can see here the low dash implementation

00:06:01,270 --> 00:06:09,490
of this method and what i'm doing here

00:06:05,290 --> 00:06:11,020
is detecting if a value i do a little

00:06:09,490 --> 00:06:13,540
bit of argument juggling here i detect

00:06:11,020 --> 00:06:16,770
if you're passing true to be able to do

00:06:13,540 --> 00:06:19,960
a binary search or if you're passing

00:06:16,770 --> 00:06:23,950
just a note and index to do something

00:06:19,960 --> 00:06:28,240
like a from index and from there i also

00:06:23,950 --> 00:06:29,500
match i throw more functionality into

00:06:28,240 --> 00:06:33,640
this and i'll get into this a little bit

00:06:29,500 --> 00:06:35,350
with with features but with javascript

00:06:33,640 --> 00:06:37,900
implementations of your built-ins and if

00:06:35,350 --> 00:06:40,140
you're leveraging javascript i've found

00:06:37,900 --> 00:06:42,930
a way in lodash to have better than

00:06:40,140 --> 00:06:45,370
built in performance implementing a

00:06:42,930 --> 00:06:47,590
simpler subset of the built-in

00:06:45,370 --> 00:06:48,970
functionality but what I'm able to do on

00:06:47,590 --> 00:06:51,430
top of that then is go back and add

00:06:48,970 --> 00:06:52,090
features and still be on par or better

00:06:51,430 --> 00:06:55,330
than bill

00:06:52,090 --> 00:06:57,820
so in this case I'm also doing a check

00:06:55,330 --> 00:06:59,919
for na n so normally index sub doesn't

00:06:57,820 --> 00:07:01,540
support in again if you if you try to

00:06:59,919 --> 00:07:03,580
look for na n it's always going to

00:07:01,540 --> 00:07:05,350
return negative one but in this case

00:07:03,580 --> 00:07:07,479
I've added support for that because es6

00:07:05,350 --> 00:07:09,960
is starting to be able to match in a in

00:07:07,479 --> 00:07:12,100
value so like if you have a set or a map

00:07:09,960 --> 00:07:16,090
so i wanted that to be consistent

00:07:12,100 --> 00:07:18,130
throughout so you can see here a real

00:07:16,090 --> 00:07:20,229
basic implementation did you see the the

00:07:18,130 --> 00:07:22,360
the previous implementations were very

00:07:20,229 --> 00:07:24,400
complex they had all those forking for

00:07:22,360 --> 00:07:26,110
different cases and conditions but you

00:07:24,400 --> 00:07:28,300
can see here the vanilla JavaScript

00:07:26,110 --> 00:07:31,270
version is basically a for loop doing

00:07:28,300 --> 00:07:33,220
the strict equality check and you notice

00:07:31,270 --> 00:07:34,479
that if it's na n I hand off to another

00:07:33,220 --> 00:07:36,970
helper function because that's not the

00:07:34,479 --> 00:07:39,250
common case so these kinds of principles

00:07:36,970 --> 00:07:43,389
can also be applied to your array

00:07:39,250 --> 00:07:45,760
built-ins in the browser so we'll look

00:07:43,389 --> 00:07:49,060
at that the next example I want to show

00:07:45,760 --> 00:07:52,570
and discuss is int'l so the

00:07:49,060 --> 00:07:55,810
internationalization API and that's this

00:07:52,570 --> 00:07:57,220
spec hear that i'll zoom in on because

00:07:55,810 --> 00:08:00,729
everyone likes reading technical

00:07:57,220 --> 00:08:06,190
specifications huh talks about the Intel

00:08:00,729 --> 00:08:08,380
object so in an IE and in ms edge we

00:08:06,190 --> 00:08:10,960
implement the Intel internationalization

00:08:08,380 --> 00:08:15,150
API in JavaScript and so there's pros

00:08:10,960 --> 00:08:17,919
and cons to that so we got in on the

00:08:15,150 --> 00:08:22,660
self-hosting game as well so let's go

00:08:17,919 --> 00:08:24,820
back to here alright so the good here

00:08:22,660 --> 00:08:26,289
the good was we were able to write it in

00:08:24,820 --> 00:08:28,479
JavaScript it was able to simplify the

00:08:26,289 --> 00:08:31,090
arguments handling of the arguments it

00:08:28,479 --> 00:08:33,760
was able to be understood in red so like

00:08:31,090 --> 00:08:35,200
I'm not a C++ dev but I know JavaScript

00:08:33,760 --> 00:08:37,089
so I can look at that and help out and

00:08:35,200 --> 00:08:38,529
say like hey this or that other people

00:08:37,089 --> 00:08:40,300
JavaScript dad's that we have could

00:08:38,529 --> 00:08:43,360
could do that at the company so it was

00:08:40,300 --> 00:08:46,420
it was it was good simplified reading

00:08:43,360 --> 00:08:48,700
and understanding integrating with C++

00:08:46,420 --> 00:08:51,850
with simpler than we thought about that

00:08:48,700 --> 00:08:55,720
allowed us to spin this up rapidly and

00:08:51,850 --> 00:08:59,080
get the get that implemented but with

00:08:55,720 --> 00:09:00,910
the good comes the bad all of that

00:08:59,080 --> 00:09:02,860
JavaScript you know you can coerce

00:09:00,910 --> 00:09:04,660
values you've got value of you've got

00:09:02,860 --> 00:09:06,550
prototypical inheritance

00:09:04,660 --> 00:09:09,610
all these ways that you can manipulate

00:09:06,550 --> 00:09:11,379
the language to cause side effects and

00:09:09,610 --> 00:09:13,149
your built-ins shouldn't have side

00:09:11,379 --> 00:09:15,160
effects right they should just be

00:09:13,149 --> 00:09:16,899
isolated you shouldn't be able to to

00:09:15,160 --> 00:09:19,569
mess with the surrounding language and

00:09:16,899 --> 00:09:21,910
affect their behavior so all of that had

00:09:19,569 --> 00:09:25,750
to be had to be guarded against and so

00:09:21,910 --> 00:09:27,970
that was tricky to do you have to create

00:09:25,750 --> 00:09:30,370
and hold references 22 normally

00:09:27,970 --> 00:09:32,170
functions you take for granted and you

00:09:30,370 --> 00:09:34,540
have to find ways to guard against

00:09:32,170 --> 00:09:37,930
people changing things on the object a

00:09:34,540 --> 00:09:40,779
prototype or other other methods that

00:09:37,930 --> 00:09:42,879
would cause your functionality to have

00:09:40,779 --> 00:09:44,889
side effects there's also heavier

00:09:42,879 --> 00:09:47,439
boilerplate because of all of that

00:09:44,889 --> 00:09:50,410
spinning up the development of that that

00:09:47,439 --> 00:09:52,329
single implementation took longer of

00:09:50,410 --> 00:09:54,120
well took more boilerplate to get that

00:09:52,329 --> 00:09:55,810
that ready now hopefully future

00:09:54,120 --> 00:09:59,529
implementations will already have that

00:09:55,810 --> 00:10:01,540
boilerplate in place and then the ugly

00:09:59,529 --> 00:10:03,490
so I already mentioned preventing

00:10:01,540 --> 00:10:07,360
tainting of internal JS objects but then

00:10:03,490 --> 00:10:09,579
you have to be able to test that and try

00:10:07,360 --> 00:10:11,199
to to ensure that you're guarding

00:10:09,579 --> 00:10:13,660
against that so it not only complicates

00:10:11,199 --> 00:10:15,189
the guards so the implementing all the

00:10:13,660 --> 00:10:18,399
guards around it but also the testing of

00:10:15,189 --> 00:10:19,930
those two and then also ensuring that

00:10:18,399 --> 00:10:21,459
you have the correct stack behavior so

00:10:19,930 --> 00:10:22,959
if you're debugging and you want to walk

00:10:21,459 --> 00:10:24,819
the stack you don't want to go into the

00:10:22,959 --> 00:10:27,310
internals of the built-in you want that

00:10:24,819 --> 00:10:30,069
to be obscured and hidden away I

00:10:27,310 --> 00:10:33,009
remember there was versions of v8 that

00:10:30,069 --> 00:10:34,810
had their built-ins written in

00:10:33,009 --> 00:10:37,569
JavaScript and you could to string them

00:10:34,810 --> 00:10:38,800
and view their source and I was trying

00:10:37,569 --> 00:10:40,060
to find the version of that because I

00:10:38,800 --> 00:10:42,519
always thought that was so cool but

00:10:40,060 --> 00:10:46,480
apparently it leaked things that aren't

00:10:42,519 --> 00:10:48,519
supposed to be leaked but awesome and

00:10:46,480 --> 00:10:50,620
this would be another one to you don't

00:10:48,519 --> 00:10:53,019
want to walk your stack and then via gig

00:10:50,620 --> 00:10:57,699
into the internals of the built-in so

00:10:53,019 --> 00:11:01,120
there's that the bad and the ugly now

00:10:57,699 --> 00:11:02,589
moving on to other things before I said

00:11:01,120 --> 00:11:05,889
hey it's great for performance you get

00:11:02,589 --> 00:11:08,740
in lining but you also and i ended up

00:11:05,889 --> 00:11:13,300
this earlier you also don't have all of

00:11:08,740 --> 00:11:16,269
the tools in optimizations and and data

00:11:13,300 --> 00:11:17,600
available that the the the the engine

00:11:16,269 --> 00:11:21,440
would behind the scenes

00:11:17,600 --> 00:11:23,209
so that's why the v8 implementation was

00:11:21,440 --> 00:11:26,529
having to make a guess if something was

00:11:23,209 --> 00:11:28,670
a sparser rang right they didn't know

00:11:26,529 --> 00:11:32,470
right out the gate that something was

00:11:28,670 --> 00:11:40,519
and so that can cause overhead and so

00:11:32,470 --> 00:11:43,610
i'll show you this going back in 2012 i

00:11:40,519 --> 00:11:46,639
had a conference talk and it was called

00:11:43,610 --> 00:11:48,079
the hidden costs of JavaScript natives

00:11:46,639 --> 00:11:51,230
and that's where I went through and

00:11:48,079 --> 00:11:54,410
showed every built-in and how they were

00:11:51,230 --> 00:11:56,630
horribly slow compared to vanilla

00:11:54,410 --> 00:12:03,800
JavaScript alternatives so that was in

00:11:56,630 --> 00:12:09,290
2012 and one of those links was or let's

00:12:03,800 --> 00:12:12,589
see index of and I showed the

00:12:09,290 --> 00:12:19,490
performance of native versus the vanilla

00:12:12,589 --> 00:12:22,870
so let me go to let's see this one and

00:12:19,490 --> 00:12:22,870
let's see where we're at

00:12:28,470 --> 00:12:43,950
live live demo oh yeah and we're moving

00:12:37,590 --> 00:12:46,290
on from this the the benchmark would

00:12:43,950 --> 00:12:48,450
show that we're still behind so even

00:12:46,290 --> 00:12:51,000
with implementing these methods in

00:12:48,450 --> 00:12:53,850
JavaScript they're still not as fast as

00:12:51,000 --> 00:12:58,440
simplified alternatives so performance

00:12:53,850 --> 00:12:59,550
isn't guaranteed hmm oh sorry that well

00:12:58,440 --> 00:13:06,110
this this slide here isn't really

00:12:59,550 --> 00:13:06,110
important I'll go back to the other one

00:13:10,880 --> 00:13:18,150
so no silver bullet on performance but

00:13:15,180 --> 00:13:22,080
I've noticed that in those cases where

00:13:18,150 --> 00:13:27,360
you come out of the gate without the the

00:13:22,080 --> 00:13:29,130
performance here's one object at a sign

00:13:27,360 --> 00:13:33,720
I was very psyched as a library author

00:13:29,130 --> 00:13:35,130
to use this method and as soon as it

00:13:33,720 --> 00:13:37,530
appeared in windows 10 I tried it out

00:13:35,130 --> 00:13:39,810
yay we were sixty percent faster than

00:13:37,530 --> 00:13:42,740
vanilla JavaScript alternatives so I was

00:13:39,810 --> 00:13:46,170
going to use it in lodash but then I

00:13:42,740 --> 00:13:47,940
looked at the other browsers and Firefox

00:13:46,170 --> 00:13:50,670
nightly hey they removed their try-catch

00:13:47,940 --> 00:13:53,280
logic and object out a sign is on par

00:13:50,670 --> 00:13:57,090
with javascript alternatives okay so

00:13:53,280 --> 00:14:01,710
it's on par or better that's great but

00:13:57,090 --> 00:14:04,260
v8 its sixty-two percent slower than

00:14:01,710 --> 00:14:06,960
JavaScript alternatives so it puts me in

00:14:04,260 --> 00:14:08,730
a tricky spot of having to make tough

00:14:06,960 --> 00:14:10,710
choices about whether I want to go

00:14:08,730 --> 00:14:13,290
through all the hoops to fork my code to

00:14:10,710 --> 00:14:14,610
use this built-in when it's not as

00:14:13,290 --> 00:14:19,670
performance especially in a scenario

00:14:14,610 --> 00:14:22,620
that's like a node specific scenario so

00:14:19,670 --> 00:14:25,110
the lesson there is that these methods

00:14:22,620 --> 00:14:27,900
are all written in JavaScript and their

00:14:25,110 --> 00:14:31,980
self hosted except for chakras and

00:14:27,900 --> 00:14:35,070
chakras was the one that was the fastest

00:14:31,980 --> 00:14:36,750
so in that case we took the lump for

00:14:35,070 --> 00:14:39,150
implementation ease of implementation

00:14:36,750 --> 00:14:41,350
yes it was harder to implement right

00:14:39,150 --> 00:14:43,810
then let's say writing JavaScript

00:14:41,350 --> 00:14:45,100
the end result was a faster method out

00:14:43,810 --> 00:14:47,200
of the box and we still have room to

00:14:45,100 --> 00:14:49,240
optimize like this was normally when you

00:14:47,200 --> 00:14:51,160
when you create these methods its

00:14:49,240 --> 00:14:53,290
implement first get all your unit tests

00:14:51,160 --> 00:14:56,140
passing push it out and then go back in

00:14:53,290 --> 00:14:57,580
optimize right so this is this is our

00:14:56,140 --> 00:14:59,800
this is our right out of the gate

00:14:57,580 --> 00:15:02,050
performance and so if we want we can go

00:14:59,800 --> 00:15:03,850
back and iterate over that and improve

00:15:02,050 --> 00:15:05,680
that right now we're already giving

00:15:03,850 --> 00:15:07,990
developers what they want which is an

00:15:05,680 --> 00:15:09,730
API that's fast enough but they don't

00:15:07,990 --> 00:15:14,370
have to sit there and pull in another

00:15:09,730 --> 00:15:16,360
library dependency which brings me to

00:15:14,370 --> 00:15:17,920
developers shouldn't be forced to use a

00:15:16,360 --> 00:15:19,420
library to have faster built-in

00:15:17,920 --> 00:15:22,270
equivalents I shouldn't have to write

00:15:19,420 --> 00:15:24,400
lodash to have faster built-in

00:15:22,270 --> 00:15:27,640
performance for these common utility

00:15:24,400 --> 00:15:31,150
libraries so I've been pushing at chakra

00:15:27,640 --> 00:15:32,830
to to optimize our built-ins and so

00:15:31,150 --> 00:15:33,910
that's what that's what we've done we

00:15:32,830 --> 00:15:35,640
came out with the blog post where we

00:15:33,910 --> 00:15:39,820
talked about specifically array index of

00:15:35,640 --> 00:15:42,160
that wasn't a random method picked they

00:15:39,820 --> 00:15:44,920
crawled the top sites found the most

00:15:42,160 --> 00:15:46,660
used JavaScript methods and then put

00:15:44,920 --> 00:15:49,000
them on a priority list for optimization

00:15:46,660 --> 00:15:53,590
and array index of was that was one of

00:15:49,000 --> 00:15:56,500
the highest es five methods used so i

00:15:53,590 --> 00:15:58,510
would say expect more of that i want to

00:15:56,500 --> 00:15:59,950
to challenge the other browsers to to

00:15:58,510 --> 00:16:02,980
get involved in this and optimize your

00:15:59,950 --> 00:16:06,420
built-ins because we're creating a

00:16:02,980 --> 00:16:06,420
situation where we spend so much time

00:16:06,840 --> 00:16:10,990
creating these methods specifying these

00:16:09,340 --> 00:16:12,940
methods testing these methods

00:16:10,990 --> 00:16:15,130
implementing these methods in the

00:16:12,940 --> 00:16:17,050
browser and then having such poor

00:16:15,130 --> 00:16:19,300
performance that developers aren't using

00:16:17,050 --> 00:16:20,470
them so who are we making right we

00:16:19,300 --> 00:16:22,900
should we should be delighting

00:16:20,470 --> 00:16:24,610
developers with things like optimizing

00:16:22,900 --> 00:16:28,480
the built-ins and optimizing the usage

00:16:24,610 --> 00:16:31,300
pass those paths from es5 to es6 so for

00:16:28,480 --> 00:16:32,770
example your spread operator should be

00:16:31,300 --> 00:16:34,330
fast and the alternative that should

00:16:32,770 --> 00:16:37,450
also be optimized so you're not getting

00:16:34,330 --> 00:16:39,460
a penalty for switching to a new syntax

00:16:37,450 --> 00:16:41,080
they should make sure that the up the

00:16:39,460 --> 00:16:43,150
the paths the fast pads from one

00:16:41,080 --> 00:16:44,770
translate to the other so that's what

00:16:43,150 --> 00:16:48,750
you'll start seeing a focus on is is

00:16:44,770 --> 00:16:48,750
more built in performance

00:16:51,150 --> 00:16:55,660
I'm going to hit the next slide and I

00:16:53,650 --> 00:16:58,990
don't know what it's going to take me so

00:16:55,660 --> 00:17:00,040
here we go all right whoo optimizing the

00:16:58,990 --> 00:17:08,230
built-ins which I've already talked

00:17:00,040 --> 00:17:14,380
about nice one more all right that's the

00:17:08,230 --> 00:17:15,670
end one so I knew it was close if you

00:17:14,380 --> 00:17:19,329
want to talk to me in the hallway I'll

00:17:15,670 --> 00:17:22,120
talk to you about the other issues and

00:17:19,329 --> 00:17:23,380
in tweaks with with this other work

00:17:22,120 --> 00:17:29,910
we're doing with optimizing our

00:17:23,380 --> 00:17:29,910
built-ins and that's it cool thank you

00:17:36,660 --> 00:17:39,660

YouTube URL: https://www.youtube.com/watch?v=2DzaOnOyCqE


