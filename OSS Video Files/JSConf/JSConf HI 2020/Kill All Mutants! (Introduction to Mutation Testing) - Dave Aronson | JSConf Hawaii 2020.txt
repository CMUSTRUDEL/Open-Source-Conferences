Title: Kill All Mutants! (Introduction to Mutation Testing) - Dave Aronson | JSConf Hawaii 2020
Publication date: 2020-03-24
Playlist: JSConf HI 2020
Description: 
	How good are your tests? Would they still pass if the tested code was changed? If so, there may be problems with your code, your tests, or both!

Mutation Testing helps reveal these cases.It makes lots of slightly altered versions, called "mutants", of your functions, and runs your functions' unit tests, using each of its mutants instead. If a mutant makes any test fail, that mutant "dies". "Survivors" imply flaws: your code might not be meaningful enough that a slight mutation would change the behavior, your tests might not be strict enough to catch the difference that the mutation made, or both!

This talk will tell you how to use mutation testing, its benefits, drawbacks, and pitfalls, and how it works under the hood.There will be several examples(in clear pseudocode), and a list of tools for some popular languages(including of course Javascript).

You will come away equipped with a powerful new technique for making sure your tests are strict and your code is meaningful.

Slides: https://www.slideshare.net/slideshow/embed_code/key/aNJFQMKvzrBvO4

JSConf Hawaii will return soon
https://www.jsconfhi.com/
Captions: 
	00:00:08,920 --> 00:00:15,850
Aloha Hawaii Dave Aronson the t-rex of

00:00:13,150 --> 00:00:18,310
Coto Soros LLC and

00:00:15,850 --> 00:00:24,279
flew over here on my pet pterodactyl

00:00:18,310 --> 00:00:27,490
they teach you how to kill mutants so

00:00:24,279 --> 00:00:30,010
what are those in our universe that of

00:00:27,490 --> 00:00:32,440
software development not comic books

00:00:30,010 --> 00:00:35,080
there's something out of mutation

00:00:32,440 --> 00:00:39,010
testing so what on Infinite Earths is

00:00:35,080 --> 00:00:41,250
mutation testing you might look at the

00:00:39,010 --> 00:00:44,199
name and think it's a way to test the

00:00:41,250 --> 00:00:46,690
mutations used in genetic algorithms or

00:00:44,199 --> 00:00:49,930
something but no it's actually a way to

00:00:46,690 --> 00:00:54,489
test both our code and our unit test

00:00:49,930 --> 00:00:57,610
suite by using mutations it's most

00:00:54,489 --> 00:01:00,640
unusual benefit is to help ensure that

00:00:57,610 --> 00:01:02,769
our tests are strict by finding the gaps

00:01:00,640 --> 00:01:05,590
that let our code get away with

00:01:02,769 --> 00:01:07,780
unintended behavior lack of this

00:01:05,590 --> 00:01:10,710
strictness usually comes from lack of

00:01:07,780 --> 00:01:13,659
tests of course or poorly written or

00:01:10,710 --> 00:01:15,729
test set or poorly maintained and just

00:01:13,659 --> 00:01:18,610
didn't keep pace with changes in the

00:01:15,729 --> 00:01:20,770
code speaking of the code mutation

00:01:18,610 --> 00:01:23,380
testing can also help ensure that our

00:01:20,770 --> 00:01:26,289
code is meaningful by which I mean that

00:01:23,380 --> 00:01:29,649
any tiny little change to it to have a

00:01:26,289 --> 00:01:31,950
noticeable effect on its behavior lack

00:01:29,649 --> 00:01:35,500
of meaning usually comes from code being

00:01:31,950 --> 00:01:39,159
redundant or unreachable or otherwise

00:01:35,500 --> 00:01:42,250
not having any real effect mutation

00:01:39,159 --> 00:01:45,189
testing puts these two together by

00:01:42,250 --> 00:01:47,350
checking first that some tiny little

00:01:45,189 --> 00:01:50,350
change did indeed have a noticeable

00:01:47,350 --> 00:01:54,429
effect and then at our unit test sweet

00:01:50,350 --> 00:01:56,590
spots that change and fails not all the

00:01:54,429 --> 00:02:00,749
tests have to fail but each change

00:01:56,590 --> 00:02:04,689
should make at least one unit test fail

00:02:00,749 --> 00:02:07,420
now that's the plus side but as Fred

00:02:04,689 --> 00:02:09,729
Brooks told us back in 86 and multi

00:02:07,420 --> 00:02:11,950
reminded us the other day there's no

00:02:09,729 --> 00:02:14,900
silver bullet besides which they're for

00:02:11,950 --> 00:02:17,060
killing werewolves not mutants

00:02:14,900 --> 00:02:19,250
the first drawback is that it's rather

00:02:17,060 --> 00:02:22,159
hard labor on the CPU and therefore

00:02:19,250 --> 00:02:24,560
usually rather slow we don't want a

00:02:22,159 --> 00:02:28,129
mutation test our entire code base on

00:02:24,560 --> 00:02:30,650
every save maybe over a lunch break for

00:02:28,129 --> 00:02:33,860
a small system or overnight or over a

00:02:30,650 --> 00:02:35,360
weekend for a larger one fortunately

00:02:33,860 --> 00:02:38,569
most of the tools do include an

00:02:35,360 --> 00:02:41,390
incremental mode so we can test just

00:02:38,569 --> 00:02:44,930
what we changed since last time that

00:02:41,390 --> 00:02:47,239
maybe we can do on every save if we save

00:02:44,930 --> 00:02:50,959
early save often like we know we're

00:02:47,239 --> 00:02:53,390
supposed to but don't always another

00:02:50,959 --> 00:02:55,879
drawback is that it's not at all a

00:02:53,390 --> 00:02:57,890
beginner friendly technique it tells us

00:02:55,879 --> 00:03:00,620
that some particular change to the code

00:02:57,890 --> 00:03:04,519
made no difference to our test results

00:03:00,620 --> 00:03:07,129
but what does that mean you'll find that

00:03:04,519 --> 00:03:09,530
interpreting the results of mutation

00:03:07,129 --> 00:03:14,239
testing involves a lot of asking so what

00:03:09,530 --> 00:03:16,129
does that mean recursively it's it takes

00:03:14,239 --> 00:03:17,810
a lot of interpretation to figure out

00:03:16,129 --> 00:03:20,660
what a mutant is trying to tell us

00:03:17,810 --> 00:03:22,760
they're almost as incoherent as zombies

00:03:20,660 --> 00:03:25,870
but with a much larger vocabulary

00:03:22,760 --> 00:03:28,880
they're not always on about words

00:03:25,870 --> 00:03:31,819
they're usually trying to tell us that

00:03:28,880 --> 00:03:34,970
our code is meaningless or our tests are

00:03:31,819 --> 00:03:37,190
lacks or of course both but it can take

00:03:34,970 --> 00:03:40,519
a lot of time and effort to figure out

00:03:37,190 --> 00:03:42,330
exactly how and sometimes it's a false

00:03:40,519 --> 00:03:44,220
alarm

00:03:42,330 --> 00:03:47,250
for instance the mutant might not have

00:03:44,220 --> 00:03:50,430
made any test fail but it might not have

00:03:47,250 --> 00:03:53,070
made any actual difference in the toads

00:03:50,430 --> 00:03:56,490
behavior either at least not in anything

00:03:53,070 --> 00:03:59,220
we actually care about so those are the

00:03:56,490 --> 00:04:03,600
main pros and cons but what does

00:03:59,220 --> 00:04:06,720
mutation testing actually do it mutates

00:04:03,600 --> 00:04:09,590
hence the name copies of our code to

00:04:06,720 --> 00:04:14,220
create test failures otherwise known as

00:04:09,590 --> 00:04:16,890
faults so mutation testing is a fault

00:04:14,220 --> 00:04:19,410
based software testing technique and

00:04:16,890 --> 00:04:20,640
this means it's sort of related to

00:04:19,410 --> 00:04:25,230
something you might already be familiar

00:04:20,640 --> 00:04:28,170
with chaos monkey from Netflix just like

00:04:25,230 --> 00:04:29,820
chaos monkey uses faults to help Netflix

00:04:28,170 --> 00:04:33,930
discover flaws in their error recovery

00:04:29,820 --> 00:04:36,210
process mutation testing uses faults to

00:04:33,930 --> 00:04:39,150
help us discover flaws in our code and

00:04:36,210 --> 00:04:41,820
our unit test suite but the way this

00:04:39,150 --> 00:04:45,480
works is kind of upside down from what

00:04:41,820 --> 00:04:48,260
chaos monkey does chaos monkey is best

00:04:45,480 --> 00:04:52,220
known for injecting faults into

00:04:48,260 --> 00:04:52,220
Netflix's production network

00:04:52,409 --> 00:04:56,669
if the customers don't notice and the

00:04:54,629 --> 00:04:58,409
metrics still look fine then Netflix

00:04:56,669 --> 00:05:00,889
knows that their error recovery is

00:04:58,409 --> 00:05:05,240
working great

00:05:00,889 --> 00:05:08,419
but mutation testing injects instead not

00:05:05,240 --> 00:05:10,189
faults but changes it doesn't know

00:05:08,419 --> 00:05:13,280
whether these changes will produce

00:05:10,189 --> 00:05:15,080
faults or not we hope they all will but

00:05:13,280 --> 00:05:17,990
that's actually up to the unit test

00:05:15,080 --> 00:05:21,139
suite it injects them not into our

00:05:17,990 --> 00:05:24,250
actual network but copies of our code

00:05:21,139 --> 00:05:27,819
and it does this in our test environment

00:05:24,250 --> 00:05:27,819
not production

00:05:28,360 --> 00:05:33,789
and if everything still passes that

00:05:31,689 --> 00:05:36,370
doesn't mean everything is okay that's

00:05:33,789 --> 00:05:38,740
when we have a problem remember each

00:05:36,370 --> 00:05:44,169
change should make at least one unit

00:05:38,740 --> 00:05:46,479
test fail so how does it do all this

00:05:44,169 --> 00:05:49,889
let's peel back one layer of the onion

00:05:46,479 --> 00:05:53,469
and look at it from a high level view

00:05:49,889 --> 00:05:55,990
first our chosen tool breaks our code

00:05:53,469 --> 00:05:59,289
apart into pieces to test usually these

00:05:55,990 --> 00:06:02,610
are going to be our functions for each

00:05:59,289 --> 00:06:05,500
function it then tries to find the tests

00:06:02,610 --> 00:06:09,159
as if there aren't any tests well would

00:06:05,500 --> 00:06:13,270
be kind of redundant to impossible to

00:06:09,159 --> 00:06:16,629
run its tests assuming it finds any then

00:06:13,270 --> 00:06:19,150
the tool makes mutants out of that

00:06:16,629 --> 00:06:21,699
particular function and to do that it

00:06:19,150 --> 00:06:25,090
looks closely at the function to see how

00:06:21,699 --> 00:06:27,610
it can be changed and for each way that

00:06:25,090 --> 00:06:31,270
function can be changed the tool makes

00:06:27,610 --> 00:06:32,540
one mutant with just that one change in

00:06:31,270 --> 00:06:34,880
it

00:06:32,540 --> 00:06:38,420
after the tools done creating all the

00:06:34,880 --> 00:06:40,760
mutants it can on the given function and

00:06:38,420 --> 00:06:42,010
it iterates over the list and now we get

00:06:40,760 --> 00:06:44,930
to the heart of the matter

00:06:42,010 --> 00:06:48,170
for each mutant made from a given

00:06:44,930 --> 00:06:51,080
function the tool will run the unit

00:06:48,170 --> 00:06:54,410
tests from the original function but

00:06:51,080 --> 00:06:57,800
using a mutant instead and if one of

00:06:54,410 --> 00:07:00,800
those unit tests fails this is called

00:06:57,800 --> 00:07:03,500
killing the mutant quick sidenote

00:07:00,800 --> 00:07:07,940
some people object to the violent nature

00:07:03,500 --> 00:07:08,720
of this metaphor especially since in the

00:07:07,940 --> 00:07:11,300
comic books

00:07:08,720 --> 00:07:13,550
mutants are often used as a metaphor for

00:07:11,300 --> 00:07:16,100
marginalized people I'm trying to come

00:07:13,550 --> 00:07:18,590
up with a better term like maybe cover

00:07:16,100 --> 00:07:20,000
or rescue or somesuch but I couldn't

00:07:18,590 --> 00:07:23,960
come up with something good in time to

00:07:20,000 --> 00:07:26,180
change this talk oh well anyway killing

00:07:23,960 --> 00:07:28,370
the mutant means that the tiny little

00:07:26,180 --> 00:07:30,920
change that the tool made in order to

00:07:28,370 --> 00:07:32,890
create the mutant it indeed have a

00:07:30,920 --> 00:07:35,810
noticeable effect on the behavior and

00:07:32,890 --> 00:07:38,780
our test suite was strict enough to

00:07:35,810 --> 00:07:43,550
notice that change and fail at least one

00:07:38,780 --> 00:07:45,530
test after one test has failed the tool

00:07:43,550 --> 00:07:48,500
will stop running a test against that

00:07:45,530 --> 00:07:52,370
mutant and move on to the next one we

00:07:48,500 --> 00:07:55,610
don't care how many more unit tests that

00:07:52,370 --> 00:07:57,410
mutant might make fail like so much else

00:07:55,610 --> 00:08:00,710
in computer science we only care about

00:07:57,410 --> 00:08:04,009
ones and zeroes

00:08:00,710 --> 00:08:07,070
but if a mutant lets all the functions

00:08:04,009 --> 00:08:10,190
unit tests pass then it has the

00:08:07,070 --> 00:08:13,669
superpower of mimicry skilled enough to

00:08:10,190 --> 00:08:16,400
fool our tests this usually means that

00:08:13,669 --> 00:08:19,490
our code is meaningless or our tests are

00:08:16,400 --> 00:08:23,930
lacks or both and now it's up to us to

00:08:19,490 --> 00:08:26,000
figure out exactly how now let's peel

00:08:23,930 --> 00:08:28,009
back another layer of the onion and look

00:08:26,000 --> 00:08:31,370
at some technical details of how this

00:08:28,009 --> 00:08:34,279
works first our tool parses our code

00:08:31,370 --> 00:08:36,890
usually into an abstract syntax tree or

00:08:34,279 --> 00:08:41,659
AST I think those were mentioned on

00:08:36,890 --> 00:08:43,580
Wednesday I know these boxes are a

00:08:41,659 --> 00:08:46,190
little small to read but we don't need

00:08:43,580 --> 00:08:49,790
to actually understand this ast in

00:08:46,190 --> 00:08:52,899
detail after our tool makes an AST out

00:08:49,790 --> 00:08:56,750
of our code and it traverses that tree

00:08:52,899 --> 00:09:00,920
looking for sub trees that represent our

00:08:56,750 --> 00:09:02,209
functions after finding them it handles

00:09:00,920 --> 00:09:03,800
them pretty much like I described

00:09:02,209 --> 00:09:06,830
earlier starting with looking for the

00:09:03,800 --> 00:09:10,040
tests but how does it do that

00:09:06,830 --> 00:09:12,860
this usually relies on us developers

00:09:10,040 --> 00:09:15,350
either annotating our code or following

00:09:12,860 --> 00:09:17,779
some kind of naming convention and this

00:09:15,350 --> 00:09:20,830
is sometimes supplemented or even

00:09:17,779 --> 00:09:24,730
replaced by the tool looking at what

00:09:20,830 --> 00:09:27,850
functions each of the tests call

00:09:24,730 --> 00:09:31,150
next the tool makes the mutants and to

00:09:27,850 --> 00:09:33,610
make them from an ast subtree it then

00:09:31,150 --> 00:09:37,240
traverses the subtree just like it did

00:09:33,610 --> 00:09:40,570
to the whole thing this time it's not

00:09:37,240 --> 00:09:44,200
looking for even smaller sub trees twigs

00:09:40,570 --> 00:09:47,920
or something to extract but nodes where

00:09:44,200 --> 00:09:51,340
it can change something maybe substitute

00:09:47,920 --> 00:09:54,730
a different kind of node or whatever for

00:09:51,340 --> 00:09:57,730
instance suppose our tool was traversing

00:09:54,730 --> 00:10:00,430
the ast I showed earlier and it's gotten

00:09:57,730 --> 00:10:04,210
down to this not equals comparison

00:10:00,430 --> 00:10:07,120
following those red lines or each way it

00:10:04,210 --> 00:10:10,840
can change that node it will make a

00:10:07,120 --> 00:10:13,680
fresh copy of that entire subtree with

00:10:10,840 --> 00:10:17,110
just that node changed in that one way

00:10:13,680 --> 00:10:21,670
after it's done making as many copies

00:10:17,110 --> 00:10:23,860
which are the mutants by mutating that

00:10:21,670 --> 00:10:27,490
node it'll continue traversing this

00:10:23,860 --> 00:10:29,320
subtree and do likewise to the rest of

00:10:27,490 --> 00:10:31,180
the nodes

00:10:29,320 --> 00:10:33,880
I've been talking about it making

00:10:31,180 --> 00:10:37,750
changes so what kind of changes am I

00:10:33,880 --> 00:10:40,510
talking about there are quite a lot it

00:10:37,750 --> 00:10:43,830
can change a mathematical logical or

00:10:40,510 --> 00:10:46,870
bitwise operator from one to another in

00:10:43,830 --> 00:10:49,360
cases where you can do one of the

00:10:46,870 --> 00:10:51,640
totally different category it can even

00:10:49,360 --> 00:10:55,270
do that for instance in JavaScript we

00:10:51,640 --> 00:10:59,860
can treat anything as mullions so x

00:10:55,270 --> 00:11:04,480
times y could become x and y it could

00:10:59,860 --> 00:11:07,390
swap the order of operands in cases

00:11:04,480 --> 00:11:10,270
where that matters it can change a

00:11:07,390 --> 00:11:14,350
comparison from one to another it could

00:11:10,270 --> 00:11:18,310
insert or remove a logical negation it

00:11:14,350 --> 00:11:22,180
can remove a condition or a loop it

00:11:18,310 --> 00:11:24,580
could scramble or truncate the argument

00:11:22,180 --> 00:11:28,930
lists of function calls or function

00:11:24,580 --> 00:11:33,310
declarations it can replace a functions

00:11:28,930 --> 00:11:35,080
entire contents with turning a constant

00:11:33,310 --> 00:11:37,570
returning either of the arguments

00:11:35,080 --> 00:11:39,610
deliberately raising an error all kinds

00:11:37,570 --> 00:11:43,060
of things even nothing at all if the

00:11:39,610 --> 00:11:48,070
language permits and JavaScript does it

00:11:43,060 --> 00:11:50,890
could change a literal or a variable or

00:11:48,070 --> 00:11:53,350
an expression or a function call to some

00:11:50,890 --> 00:11:56,470
other value even one of a completely

00:11:53,350 --> 00:11:59,920
different type like changing a number

00:11:56,470 --> 00:12:02,430
two if I may quote smeagol string are

00:11:59,920 --> 00:12:02,430
nothing

00:12:02,570 --> 00:12:06,860
there are many many more but yeah I

00:12:04,040 --> 00:12:09,710
trust you get the idea from here on

00:12:06,860 --> 00:12:13,370
there are no low-level details I want to

00:12:09,710 --> 00:12:15,800
add so let's look at some examples we'll

00:12:13,370 --> 00:12:17,470
start with an easy one suppose we have a

00:12:15,800 --> 00:12:20,930
function like this

00:12:17,470 --> 00:12:23,240
think about what a mutant made from this

00:12:20,930 --> 00:12:25,280
but return because that's what our unit

00:12:23,240 --> 00:12:26,930
tests are almost certainly looking at

00:12:25,280 --> 00:12:30,650
this doesn't seem to have any side

00:12:26,930 --> 00:12:34,070
effects mainly such a mutant could

00:12:30,650 --> 00:12:36,260
return results such as any of these and

00:12:34,070 --> 00:12:38,530
many many more but I had to stop

00:12:36,260 --> 00:12:38,530
somewhere

00:12:38,730 --> 00:12:47,310
now suppose we have one test like so yes

00:12:44,310 --> 00:12:50,399
this is a rather poor test but even so

00:12:47,310 --> 00:12:52,019
the vast majority of these mutants

00:12:50,399 --> 00:12:55,260
well the mutants that would return these

00:12:52,019 --> 00:12:58,320
results would still would still get

00:12:55,260 --> 00:13:00,710
killed by this test ones shown here in

00:12:58,320 --> 00:13:02,670
crossed out green

00:13:00,710 --> 00:13:04,530
but

00:13:02,670 --> 00:13:07,740
addition multiplication and

00:13:04,530 --> 00:13:09,720
exponentiation in the reverse order all

00:13:07,740 --> 00:13:13,560
still get us the correct answer and

00:13:09,720 --> 00:13:16,170
would therefore survive the test we know

00:13:13,560 --> 00:13:18,420
this because when we run our tool it

00:13:16,170 --> 00:13:22,560
usually gives us a report that will look

00:13:18,420 --> 00:13:25,830
kinda sorta like this the exact format

00:13:22,560 --> 00:13:28,500
and amount of context and so forth well

00:13:25,830 --> 00:13:30,270
very enormous ly depending exactly what

00:13:28,500 --> 00:13:33,240
tool were using but the information

00:13:30,270 --> 00:13:35,820
should be pretty much the same and that

00:13:33,240 --> 00:13:38,910
is that if we change the function called

00:13:35,820 --> 00:13:42,240
power which is in file demo J s at line

00:13:38,910 --> 00:13:45,090
42 in any of four different ways all its

00:13:42,240 --> 00:13:47,040
unit tests would still pass and then

00:13:45,090 --> 00:13:50,400
that those four ways are to change line

00:13:47,040 --> 00:13:53,520
42 to swap the arguments line 43 to

00:13:50,400 --> 00:13:57,750
change the exponentiation into addition

00:13:53,520 --> 00:14:02,670
or multiplication or line 43 to swap the

00:13:57,750 --> 00:14:06,170
operands so what is this set of

00:14:02,670 --> 00:14:06,170
surviving mutants trying to tell us

00:14:06,510 --> 00:14:09,990
good start to figuring that out is to

00:14:08,190 --> 00:14:12,100
ask ourselves how are these mutants

00:14:09,990 --> 00:14:14,259
surviving

00:14:12,100 --> 00:14:16,839
and the usual answer is well they give

00:14:14,259 --> 00:14:19,959
the same result or have the same side

00:14:16,839 --> 00:14:23,440
effect as our original code to determine

00:14:19,959 --> 00:14:27,069
how that happens a good start is to look

00:14:23,440 --> 00:14:29,680
at one mutant along with one test that

00:14:27,069 --> 00:14:33,639
it passes so let's start with the plus

00:14:29,680 --> 00:14:37,410
mutant looking at this in combination

00:14:33,639 --> 00:14:40,300
with the test makes it pretty clear that

00:14:37,410 --> 00:14:44,800
this particular mutant survives because

00:14:40,300 --> 00:14:47,190
two plus two is the same as two to the

00:14:44,800 --> 00:14:47,190
second power

00:14:47,889 --> 00:14:53,079
in order to kill this mutant hover it

00:14:50,290 --> 00:14:56,829
rescue it whatever we need to have at

00:14:53,079 --> 00:15:01,149
least one test that uses inputs such

00:14:56,829 --> 00:15:04,989
that X plus y is not the same as X to

00:15:01,149 --> 00:15:07,809
the Y we can either add a test or tweak

00:15:04,989 --> 00:15:12,429
our existing test to maybe something

00:15:07,809 --> 00:15:15,850
like this 2 plus 4 is 6 which is not 16

00:15:12,429 --> 00:15:20,649
so this will kill the plus mutant better

00:15:15,850 --> 00:15:23,319
yet 2 times 4 is 8 also not 16 so as a

00:15:20,649 --> 00:15:27,249
side benefit it kills the x mutant as

00:15:23,319 --> 00:15:30,160
well but the argument swapping mutants

00:15:27,249 --> 00:15:32,889
still survived but that's ok we don't

00:15:30,160 --> 00:15:35,230
need to be a superhero about it and kill

00:15:32,889 --> 00:15:39,279
them all at once we can attack them

00:15:35,230 --> 00:15:42,040
separately to do that we can once again

00:15:39,279 --> 00:15:46,199
either add a test or tweak our existing

00:15:42,040 --> 00:15:46,199
test maybe to something like this

00:15:46,660 --> 00:15:52,020
ooh the Emmys three squared is nine

00:15:49,210 --> 00:15:55,870
which is not eight so that will kill the

00:15:52,020 --> 00:15:57,790
argument swapping mutants but also two

00:15:55,870 --> 00:15:58,360
plus three is five two times three is

00:15:57,790 --> 00:16:00,880
six

00:15:58,360 --> 00:16:03,220
both of those are not eight so the other

00:16:00,880 --> 00:16:08,080
mutants stay dead so we don't get any

00:16:03,220 --> 00:16:11,290
zombie mutants with these inputs the

00:16:08,080 --> 00:16:12,790
correct operation is the only simple

00:16:11,290 --> 00:16:16,330
common one that will get us the right

00:16:12,790 --> 00:16:19,630
answer this may make it may make

00:16:16,330 --> 00:16:21,640
mutation testing sound pretty simple but

00:16:19,630 --> 00:16:25,150
this was a downright trivial example so

00:16:21,640 --> 00:16:28,440
we could easily think up test inputs to

00:16:25,150 --> 00:16:31,120
make pretty much any reasonable mutant

00:16:28,440 --> 00:16:33,280
give different results from the original

00:16:31,120 --> 00:16:36,040
we could use for instance three to the

00:16:33,280 --> 00:16:40,390
fifth or vice versa whatever lots of

00:16:36,040 --> 00:16:43,240
ways to skin that florican so let's look

00:16:40,390 --> 00:16:47,010
at a more complex example suppose we

00:16:43,240 --> 00:16:50,380
have a function like this send message

00:16:47,010 --> 00:16:52,840
uses send bytes to send as many bytes as

00:16:50,380 --> 00:16:54,460
and bytes can handle over and over

00:16:52,840 --> 00:16:56,830
picking up where it left off last time

00:16:54,460 --> 00:16:59,770
until the message is all sent and I'm a

00:16:56,830 --> 00:17:02,020
fairly common pattern now a mutation

00:16:59,770 --> 00:17:04,510
testing tool could make lots and lots of

00:17:02,020 --> 00:17:06,939
mutants out of this but the one I want

00:17:04,510 --> 00:17:09,370
to show you is this it's an example of

00:17:06,939 --> 00:17:11,050
removing a loop control by deleting

00:17:09,370 --> 00:17:12,760
those two lines with the minus signs

00:17:11,050 --> 00:17:15,339
there

00:17:12,760 --> 00:17:18,130
now suppose that this mutant survives

00:17:15,339 --> 00:17:20,799
our test suite which consists mainly of

00:17:18,130 --> 00:17:22,929
this there's a little more than I'm not

00:17:20,799 --> 00:17:25,390
going to show you quite yet dealing with

00:17:22,929 --> 00:17:29,350
setting the size and creating the

00:17:25,390 --> 00:17:33,940
message but even just the fact that this

00:17:29,350 --> 00:17:36,370
mutant survives tells us something and

00:17:33,940 --> 00:17:40,480
that is that if a mutant that only goes

00:17:36,370 --> 00:17:44,200
through this loop body once big it has

00:17:40,480 --> 00:17:47,059
the same result as the original code

00:17:44,200 --> 00:17:48,830
does in the tests

00:17:47,059 --> 00:17:52,490
and our tests are only making the code

00:17:48,830 --> 00:17:55,580
go through the loop body once so what

00:17:52,490 --> 00:17:58,909
does that mean it means that we're only

00:17:55,580 --> 00:18:01,399
testing sending a message small enough

00:17:58,909 --> 00:18:04,490
that send bytes can handle it in one

00:18:01,399 --> 00:18:07,279
chunk the most likely cause of that in

00:18:04,490 --> 00:18:09,230
turn is that we're just not sending a

00:18:07,279 --> 00:18:14,240
big enough message to make it go through

00:18:09,230 --> 00:18:18,230
body twice or more such as in this case

00:18:14,240 --> 00:18:22,220
we might have a maximum chunk size what

00:18:18,230 --> 00:18:24,499
send bytes can handle in one shot 10,000

00:18:22,220 --> 00:18:27,499
bites yet we're only testing with a tiny

00:18:24,499 --> 00:18:30,309
little three byte message and they're

00:18:27,499 --> 00:18:33,019
the fix is pretty clear we can just

00:18:30,309 --> 00:18:36,039
instruct a larger message take the size

00:18:33,019 --> 00:18:40,390
add one make that bigger message and

00:18:36,039 --> 00:18:42,040
there we go but

00:18:40,390 --> 00:18:45,010
maybe it's not this particular cause

00:18:42,040 --> 00:18:46,990
maybe we did best with the largest

00:18:45,010 --> 00:18:49,590
permissible message out of a predefined

00:18:46,990 --> 00:18:52,330
set of messages or least message sizes

00:18:49,590 --> 00:18:55,600
for instance here we have small and

00:18:52,330 --> 00:18:59,620
large sizes and we did test with a large

00:18:55,600 --> 00:19:01,330
and yet the mutant survives in other

00:18:59,620 --> 00:19:04,210
words we're still only going through

00:19:01,330 --> 00:19:06,730
that loop body wants because send bytes

00:19:04,210 --> 00:19:09,220
is handling the whole message in one

00:19:06,730 --> 00:19:11,529
chunk so what's the mutant trying to

00:19:09,220 --> 00:19:14,210
tell us now

00:19:11,529 --> 00:19:17,000
now it's trying to tell us that a

00:19:14,210 --> 00:19:20,720
version of send bytes with the looping

00:19:17,000 --> 00:19:23,299
removed will do the job just fine and if

00:19:20,720 --> 00:19:27,260
we do that and then remove everything

00:19:23,299 --> 00:19:29,960
else that that makes redundant we wind

00:19:27,260 --> 00:19:32,990
up with this and now it's pretty clear

00:19:29,960 --> 00:19:34,789
at the ultimate message is that the

00:19:32,990 --> 00:19:37,899
whole send bytes and excuse me send

00:19:34,789 --> 00:19:40,700
message function may well be redundant

00:19:37,899 --> 00:19:43,010
now I say may well be rather than is

00:19:40,700 --> 00:19:45,679
just because in real-world code there

00:19:43,010 --> 00:19:48,649
may be some logging and error handling

00:19:45,679 --> 00:19:50,929
and whatnot we need to put in send

00:19:48,649 --> 00:19:53,419
message but at the very least the

00:19:50,929 --> 00:19:56,529
looping was redundant fortunately when

00:19:53,419 --> 00:19:59,929
it's this kind of case the solution is

00:19:56,529 --> 00:20:03,020
clear and easy just get rid of all the

00:19:59,929 --> 00:20:04,130
extra stuff the mutant didn't have that

00:20:03,020 --> 00:20:06,279
will also make our code more

00:20:04,130 --> 00:20:08,470
maintainable by getting rid of

00:20:06,279 --> 00:20:11,960
unnecessary cruft

00:20:08,470 --> 00:20:14,510
so to summarize mutation testing is a

00:20:11,960 --> 00:20:16,760
powerful technique to ensure that our

00:20:14,510 --> 00:20:21,710
code is meaningful and our tests are

00:20:16,760 --> 00:20:23,299
strict it's not so easy oh sorry one

00:20:21,710 --> 00:20:25,820
more thing that is easy it's easy to get

00:20:23,299 --> 00:20:28,460
started with in terms of setting up the

00:20:25,820 --> 00:20:31,429
tools and if need be annotating our

00:20:28,460 --> 00:20:33,649
tests which may be tedious but at least

00:20:31,429 --> 00:20:37,039
it should be easy but it's not so easy

00:20:33,649 --> 00:20:40,159
to interpret the results nor is it easy

00:20:37,039 --> 00:20:43,429
on the CPU even if these drawbacks mean

00:20:40,159 --> 00:20:44,809
that it might not be appropriate for our

00:20:43,429 --> 00:20:46,730
current projects right now

00:20:44,809 --> 00:20:51,190
I still think it's just a really cool

00:20:46,730 --> 00:20:52,780
idea in a geeky kind of way

00:20:51,190 --> 00:20:55,450
if you'd like to try mutation testing

00:20:52,780 --> 00:20:58,420
for yourself here's a list of ones for

00:20:55,450 --> 00:20:59,980
popular languages and platforms and some

00:20:58,420 --> 00:21:05,020
other ones I doubt many of you are doing

00:20:59,980 --> 00:21:07,900
fortran 77 these days as for JavaScript

00:21:05,020 --> 00:21:10,120
the only one I know of is Stryker there

00:21:07,900 --> 00:21:13,150
used to be one that was a plugin for the

00:21:10,120 --> 00:21:15,160
grunt task runner but that project has

00:21:13,150 --> 00:21:18,360
folded and it's code has been migrated

00:21:15,160 --> 00:21:18,360
into Stryker

00:21:18,750 --> 00:21:22,260
anybody still needs some time to take

00:21:20,640 --> 00:21:25,860
pictures I saw some cameras up there

00:21:22,260 --> 00:21:28,500
okay lastly a couple shoutouts first to

00:21:25,860 --> 00:21:30,750
talk to a consulting Network I'm in

00:21:28,500 --> 00:21:32,550
whose speaker's network helped me

00:21:30,750 --> 00:21:35,700
prepare and practice this presentation

00:21:32,550 --> 00:21:39,150
please use that referral link if you

00:21:35,700 --> 00:21:40,140
what IRS are join us and secondly to

00:21:39,150 --> 00:21:42,900
Marcus sharp

00:21:40,140 --> 00:21:45,510
creator of mutant a mutation testing

00:21:42,900 --> 00:21:48,360
tool for Ruby main when I've actually

00:21:45,510 --> 00:21:50,850
used these been very willing to answer

00:21:48,360 --> 00:21:53,880
my ignorant questions there being no

00:21:50,850 --> 00:21:56,310
such thing as stupid questions & pratik

00:21:53,880 --> 00:21:58,080
this presentation at least the longer

00:21:56,310 --> 00:22:01,110
forms is the shortest one I've done so

00:21:58,080 --> 00:22:03,030
far and if you have any questions while

00:22:01,110 --> 00:22:04,110
we're not supposed to do Q&A but I'll be

00:22:03,030 --> 00:22:07,730
around for the rest of the conference

00:22:04,110 --> 00:22:11,880
and there's my contact information Oh

00:22:07,730 --> 00:22:18,509
hallo and let's go get some lunch

00:22:11,880 --> 00:22:18,509

YouTube URL: https://www.youtube.com/watch?v=yNMBOj7JUPs


