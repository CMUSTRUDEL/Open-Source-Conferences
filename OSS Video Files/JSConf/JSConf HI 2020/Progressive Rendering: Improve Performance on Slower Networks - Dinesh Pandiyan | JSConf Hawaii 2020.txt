Title: Progressive Rendering: Improve Performance on Slower Networks - Dinesh Pandiyan | JSConf Hawaii 2020
Publication date: 2020-03-29
Playlist: JSConf HI 2020
Description: 
	Modern web applications have become increasingly costly in terms of size resulting in slower page load times in slower networks. Client Side Rendering (CSR) becomes a bottleneck in slower networks whereas Server Side Rendering (SSR) becomes a bottleneck when large volumes of content need to be generated in one-go.

Progressive rendering is a technique that allows us to flush portions of a webpage to the browser in chunks as soon as they are rendered on the server without having to wait for the whole page to be rendered. This will massively improve the FCP (First Contentful Paint) and FMP (First Meaningful Paint) metrics and reduce page load time in slower networks.

This talk will demonstrate effective ways to progressively render a webpage from the server to the client and highlight important performance aspects of rendering modern websites.

Slides: https://www.icloud.com/keynote/01RnZigm2R6g9FwMXVQ8uwmKw#jsconf-hi

JSConf Hawaii will return soon
https://www.jsconfhi.com/
Captions: 
	00:00:08,240 --> 00:00:13,469
all right thanks for the wonderful

00:00:10,320 --> 00:00:15,570
introduction Cassidy and Jenna there's

00:00:13,469 --> 00:00:16,800
one other fun fact that they did not

00:00:15,570 --> 00:00:19,259
mention which they couldn't have

00:00:16,800 --> 00:00:21,750
possibly known the talk I'm giving today

00:00:19,259 --> 00:00:24,029
progress surrendering I rehearsed it at

00:00:21,750 --> 00:00:27,029
least five times just in the last two

00:00:24,029 --> 00:00:30,029
days when I rehearsed it last night I

00:00:27,029 --> 00:00:32,430
gave the top two my shampoo bottle it

00:00:30,029 --> 00:00:34,080
took thirty five minutes whoa that's ten

00:00:32,430 --> 00:00:36,629
minute beyond the limits of time went to

00:00:34,080 --> 00:00:38,400
bed woke up today morning got ready gave

00:00:36,629 --> 00:00:38,940
the talk are going to another shampoo

00:00:38,400 --> 00:00:40,980
water

00:00:38,940 --> 00:00:43,379
I finished the talk in 20 minutes oh

00:00:40,980 --> 00:00:46,590
that's a bit too fast I need five

00:00:43,379 --> 00:00:49,890
minutes time to need Phyllis I think

00:00:46,590 --> 00:00:52,890
that's what I'm doing right now all

00:00:49,890 --> 00:00:54,750
right so my name is Dinesh Pandiyan I

00:00:52,890 --> 00:00:56,910
flew all the way from Sydney Australia

00:00:54,750 --> 00:01:01,140
to meet you all beautiful people here

00:00:56,910 --> 00:01:02,969
boy am I excited to be here I work at a

00:01:01,140 --> 00:01:05,220
company called pink well we are a team

00:01:02,969 --> 00:01:07,289
of JavaScript developers we work on a

00:01:05,220 --> 00:01:09,210
lot of JavaScript stuff we invest

00:01:07,289 --> 00:01:11,670
heavily in open-source if you are using

00:01:09,210 --> 00:01:13,679
react there's a good chance you're using

00:01:11,670 --> 00:01:15,179
one of the lips either built by the or

00:01:13,679 --> 00:01:16,950
someone I think Moe or is currently

00:01:15,179 --> 00:01:19,470
maintained by someone I think mother and

00:01:16,950 --> 00:01:22,020
the most important part I go by the

00:01:19,470 --> 00:01:24,630
Twitter handle flex Dinesh so I tweet

00:01:22,020 --> 00:01:26,250
about web dev web performance and

00:01:24,630 --> 00:01:29,550
recently I've been blabbering a lot

00:01:26,250 --> 00:01:33,780
about progress surrendering all right

00:01:29,550 --> 00:01:35,520
today we will be looking a lot about how

00:01:33,780 --> 00:01:37,170
a web page renders we'll start with the

00:01:35,520 --> 00:01:39,420
basics of what happens when a web page

00:01:37,170 --> 00:01:40,979
renders and we will look into the

00:01:39,420 --> 00:01:43,170
different strategies of loading webpages

00:01:40,979 --> 00:01:44,700
client-side rendering server-side

00:01:43,170 --> 00:01:45,840
rendering and there are two different

00:01:44,700 --> 00:01:47,429
types of service at rendering you either

00:01:45,840 --> 00:01:49,170
render it completely on the server are

00:01:47,429 --> 00:01:51,390
you partially render it on the server

00:01:49,170 --> 00:01:53,789
and but the most important part of all

00:01:51,390 --> 00:01:55,319
we will be looking into progress of

00:01:53,789 --> 00:01:58,729
server-side rendering and progress of

00:01:55,319 --> 00:02:01,229
client-side hydration let's get a high

00:01:58,729 --> 00:02:03,060
if you take any web site the simple

00:02:01,229 --> 00:02:05,099
would end up the render process is

00:02:03,060 --> 00:02:08,310
pretty simple your browser makes a

00:02:05,099 --> 00:02:11,280
request your server has the HTML your

00:02:08,310 --> 00:02:13,260
server sends a response back you see the

00:02:11,280 --> 00:02:15,780
little flashing there that is what where

00:02:13,260 --> 00:02:17,490
your browser passes the HTML and paints

00:02:15,780 --> 00:02:19,260
the content on the screen it straight to

00:02:17,490 --> 00:02:21,330
straightforward HTML comes from the

00:02:19,260 --> 00:02:21,900
server your browser takes the HTML

00:02:21,330 --> 00:02:25,709
passes

00:02:21,900 --> 00:02:27,209
the prints it on the screen as easy and

00:02:25,709 --> 00:02:29,700
as simple as a sound we are living in

00:02:27,209 --> 00:02:32,159
2020 now we are building feature-rich

00:02:29,700 --> 00:02:34,230
dynamic applications wave the content is

00:02:32,159 --> 00:02:36,420
generated by making API calls so

00:02:34,230 --> 00:02:40,129
rendering is not as simple as that we

00:02:36,420 --> 00:02:42,840
need to make API calls we use a

00:02:40,129 --> 00:02:45,060
frameworks like react to generate the

00:02:42,840 --> 00:02:46,439
content so essentially there is no empty

00:02:45,060 --> 00:02:48,989
content or we are not building static

00:02:46,439 --> 00:02:50,849
sites anymore we are using frameworks to

00:02:48,989 --> 00:02:53,609
iterate quickly the whole website is

00:02:50,849 --> 00:02:55,709
built using javascript so in this case

00:02:53,609 --> 00:02:58,260
we had different strategies to run our

00:02:55,709 --> 00:02:59,819
website using JavaScript first one is

00:02:58,260 --> 00:03:01,500
clients they don't drink that is this is

00:02:59,819 --> 00:03:03,930
the most straightforward approach and

00:03:01,500 --> 00:03:05,810
probably you will see a lot of simple

00:03:03,930 --> 00:03:08,159
applications using client-side rendering

00:03:05,810 --> 00:03:11,340
what happens in client-side rendering us

00:03:08,159 --> 00:03:14,819
when the browser makes the request the

00:03:11,340 --> 00:03:17,639
server sends an empty empty body to a

00:03:14,819 --> 00:03:19,439
client so here in the head we have the

00:03:17,639 --> 00:03:21,209
script to download The Pajama script

00:03:19,439 --> 00:03:23,519
bundle but you can see in the body that

00:03:21,209 --> 00:03:25,919
is only empty root element so once the

00:03:23,519 --> 00:03:27,959
browser parses it there is nothing to

00:03:25,919 --> 00:03:30,870
show on the screen so you just have an

00:03:27,959 --> 00:03:33,480
empty content the browser then downloads

00:03:30,870 --> 00:03:38,099
your javascript bundle once the download

00:03:33,480 --> 00:03:40,889
completes your reactor Water Framework

00:03:38,099 --> 00:03:42,780
uses high shows the content on the

00:03:40,889 --> 00:03:45,599
screen so this is client side rendering

00:03:42,780 --> 00:03:47,870
your whole JavaScript executes get the

00:03:45,599 --> 00:03:49,769
content ready puts it on the browser and

00:03:47,870 --> 00:03:51,750
everything happens only on the client

00:03:49,769 --> 00:03:53,459
side nothing happens on the server this

00:03:51,750 --> 00:03:55,229
has a serious drawback so if you are

00:03:53,459 --> 00:03:56,699
usually on slower and mobile network

00:03:55,229 --> 00:03:58,979
sauce I mean even if the network are

00:03:56,699 --> 00:04:02,190
slower if your bundle file is pretty big

00:03:58,979 --> 00:04:04,199
even if it's find at Kb sometimes no not

00:04:02,190 --> 00:04:06,389
kidding bundle says can go up to even 1

00:04:04,199 --> 00:04:08,069
MB if that happens it will take at least

00:04:06,389 --> 00:04:10,199
10 to 20 seconds for your browser to

00:04:08,069 --> 00:04:12,419
download the bundle so for 10 to 20

00:04:10,199 --> 00:04:14,129
seconds users are sitting ducks they

00:04:12,419 --> 00:04:17,010
just watch a blank screen there there is

00:04:14,129 --> 00:04:18,720
no update on what's happening so this is

00:04:17,010 --> 00:04:21,840
where we follow an approach called

00:04:18,720 --> 00:04:24,150
server-side rendering in server-side

00:04:21,840 --> 00:04:26,729
rendering when the browser makes the

00:04:24,150 --> 00:04:29,220
request the HTML is generated on the

00:04:26,729 --> 00:04:31,229
server so here frameworks like react

00:04:29,220 --> 00:04:33,419
they're capable of running Java when you

00:04:31,229 --> 00:04:35,340
use a node.js server we can execute the

00:04:33,419 --> 00:04:37,110
whole react application on the server

00:04:35,340 --> 00:04:39,720
generate the content that needs to be

00:04:37,110 --> 00:04:41,460
shown to the user on the server so here

00:04:39,720 --> 00:04:43,710
the HTML that comes back to the user is

00:04:41,460 --> 00:04:45,870
not just an empty empty root element it

00:04:43,710 --> 00:04:48,930
comes back with the content so the

00:04:45,870 --> 00:04:51,350
browser's they can pass it and show that

00:04:48,930 --> 00:04:54,210
content firsthand as soon as they passed

00:04:51,350 --> 00:04:56,430
now the browser starts downloading your

00:04:54,210 --> 00:04:57,810
bundle so what since the while the

00:04:56,430 --> 00:04:59,640
browser is downloading your sister users

00:04:57,810 --> 00:05:02,280
still sees content on the screen but

00:04:59,640 --> 00:05:04,590
that content is not interactive yet only

00:05:02,280 --> 00:05:08,880
after your bundle is downloaded the

00:05:04,590 --> 00:05:10,380
content becomes interactive so this

00:05:08,880 --> 00:05:12,750
process what's happening here is called

00:05:10,380 --> 00:05:16,920
hydration hydration is nothing but your

00:05:12,750 --> 00:05:18,720
react library whatever his stimulus on

00:05:16,920 --> 00:05:20,100
the Dom react once again on the browser

00:05:18,720 --> 00:05:22,290
and make sure the content is the same

00:05:20,100 --> 00:05:27,900
attaches even to listeners and makes it

00:05:22,290 --> 00:05:30,480
a dynamic but again as simple as the

00:05:27,900 --> 00:05:33,240
sounds the primary content secondary

00:05:30,480 --> 00:05:35,280
content we have here they not instantly

00:05:33,240 --> 00:05:37,830
generated on the server we have to make

00:05:35,280 --> 00:05:39,810
API calls to generate content so in

00:05:37,830 --> 00:05:42,600
reality this is all server-side entering

00:05:39,810 --> 00:05:45,600
will look if we render the whole content

00:05:42,600 --> 00:05:48,600
on the server browser makes a request

00:05:45,600 --> 00:05:50,910
so you see initially there is an empty

00:05:48,600 --> 00:05:53,010
HTML on the server now on the server

00:05:50,910 --> 00:05:56,550
your application makes an API request

00:05:53,010 --> 00:05:57,930
now the header portion is rendered on

00:05:56,550 --> 00:06:00,060
the server rendered in the sense the

00:05:57,930 --> 00:06:01,830
HTML string is generator now the rest of

00:06:00,060 --> 00:06:04,050
the portion our app your server will

00:06:01,830 --> 00:06:05,430
make another API request again the rest

00:06:04,050 --> 00:06:08,250
of the portion is again rendered on the

00:06:05,430 --> 00:06:10,410
server so this goes on until your whole

00:06:08,250 --> 00:06:12,570
site destined the content for your

00:06:10,410 --> 00:06:14,910
entire application is generated on the

00:06:12,570 --> 00:06:18,479
server only after it is done you can

00:06:14,910 --> 00:06:21,419
send the response back to the browser if

00:06:18,479 --> 00:06:23,190
if you look at you look at it here the

00:06:21,419 --> 00:06:24,840
time taken to generate the whole content

00:06:23,190 --> 00:06:26,580
is pretty high it can get really really

00:06:24,840 --> 00:06:28,919
high if the API calls take a longer time

00:06:26,580 --> 00:06:31,500
so your users they are still waiting

00:06:28,919 --> 00:06:33,330
now's the time taken to at the time that

00:06:31,500 --> 00:06:35,070
takes to send the first there our

00:06:33,330 --> 00:06:36,840
response back to the client is pretty

00:06:35,070 --> 00:06:38,430
high here it can easily take proper

00:06:36,840 --> 00:06:41,370
tween one or two seconds and that is not

00:06:38,430 --> 00:06:44,940
a small number but once the response

00:06:41,370 --> 00:06:47,130
comes back you can show it to the the

00:06:44,940 --> 00:06:49,050
browser parses it paints the content on

00:06:47,130 --> 00:06:51,449
the screen and starts downloading your

00:06:49,050 --> 00:06:54,300
or bundle javascript file and once the

00:06:51,449 --> 00:06:56,190
file is downloaded your browser

00:06:54,300 --> 00:06:58,199
react library runs on the client and

00:06:56,190 --> 00:07:02,370
hydrates your content and makes it

00:06:58,199 --> 00:07:04,289
interactive here the the drawback we

00:07:02,370 --> 00:07:06,120
have here is the time that's taking to

00:07:04,289 --> 00:07:09,080
generate the whole server content it is

00:07:06,120 --> 00:07:11,250
usually the strategy we opt for

00:07:09,080 --> 00:07:13,379
counteracting that this rendering

00:07:11,250 --> 00:07:15,180
placeholders on the server if you look

00:07:13,379 --> 00:07:17,789
at this approach instead of generating

00:07:15,180 --> 00:07:19,199
the whole content on the server we just

00:07:17,789 --> 00:07:21,060
generate the primary content on the

00:07:19,199 --> 00:07:23,120
server the non-critical content is not

00:07:21,060 --> 00:07:26,639
generated on the server we just send

00:07:23,120 --> 00:07:28,349
placeholders from the server so you see

00:07:26,639 --> 00:07:28,879
when the response goes back to the

00:07:28,349 --> 00:07:32,069
client

00:07:28,879 --> 00:07:34,500
instead of rendering the whole page you

00:07:32,069 --> 00:07:36,500
render the primary content and put in

00:07:34,500 --> 00:07:40,710
place holders for your secondary content

00:07:36,500 --> 00:07:43,020
and now your once your browser completes

00:07:40,710 --> 00:07:45,900
downloading your bundle file your

00:07:43,020 --> 00:07:47,819
browser will react will take care of

00:07:45,900 --> 00:07:49,969
making the API calls on the client and

00:07:47,819 --> 00:07:53,009
hydrate the whole portion of your site

00:07:49,969 --> 00:07:54,779
so you see in in full service and ring

00:07:53,009 --> 00:07:57,060
we get to generate all the content on

00:07:54,779 --> 00:07:59,430
the server but we cannot send the

00:07:57,060 --> 00:08:01,169
response immediately using placeholder

00:07:59,430 --> 00:08:03,180
approach we get to send the response

00:08:01,169 --> 00:08:05,940
immediately as soon as possible but we

00:08:03,180 --> 00:08:07,979
still make a certain portions of their

00:08:05,940 --> 00:08:09,659
app this rendered on the client and the

00:08:07,979 --> 00:08:12,210
API calls are made on the client the

00:08:09,659 --> 00:08:15,110
real burn is if we find a middle ground

00:08:12,210 --> 00:08:17,159
between full server-side rendering and

00:08:15,110 --> 00:08:19,319
rendering placeholders from the server

00:08:17,159 --> 00:08:22,650
and that is exactly what we are going to

00:08:19,319 --> 00:08:23,940
do with progressive rendering before we

00:08:22,650 --> 00:08:25,440
head into progressive rendering the

00:08:23,940 --> 00:08:30,090
whole idea and concept of progressive

00:08:25,440 --> 00:08:32,039
rendering was with this concept of HTML

00:08:30,090 --> 00:08:33,449
streaming this is not something new if

00:08:32,039 --> 00:08:35,310
we don't need the latest browsers for

00:08:33,449 --> 00:08:37,229
HTML streaming to work this has been

00:08:35,310 --> 00:08:39,750
around for decades even if you take the

00:08:37,229 --> 00:08:41,430
oldest of browsers in the early days

00:08:39,750 --> 00:08:43,740
most of the websites work based on the

00:08:41,430 --> 00:08:45,390
concept of customer streaming now we can

00:08:43,740 --> 00:08:48,060
bring it back to the latest frameworks

00:08:45,390 --> 00:08:50,070
like react so this is what happens in

00:08:48,060 --> 00:08:52,529
when you stream your HTML content to the

00:08:50,070 --> 00:08:54,240
browser the browser makes a request you

00:08:52,529 --> 00:08:55,860
can see the server sense doesn't send

00:08:54,240 --> 00:08:57,120
the whole history it's just sending the

00:08:55,860 --> 00:08:59,399
first part of your head similar it

00:08:57,120 --> 00:09:01,290
sliced it up to the header as soon as

00:08:59,399 --> 00:09:02,580
the browser receives it your browser can

00:09:01,290 --> 00:09:04,560
paint it on the screen

00:09:02,580 --> 00:09:06,510
now the connection is open the server

00:09:04,560 --> 00:09:09,120
can send the second chunk the other

00:09:06,510 --> 00:09:11,460
other portion of the HTML as soon as

00:09:09,120 --> 00:09:13,170
your browser receives it the browser can

00:09:11,460 --> 00:09:16,640
paint it on the screen this goes on

00:09:13,170 --> 00:09:19,350
until the last HTML it is C so this is

00:09:16,640 --> 00:09:21,660
streaming of content from the server the

00:09:19,350 --> 00:09:23,130
idea is your browser doesn't have to

00:09:21,660 --> 00:09:25,560
wait for the entire history ml to be

00:09:23,130 --> 00:09:27,690
downloaded and your server doesn't have

00:09:25,560 --> 00:09:30,600
to send the whole content in the first

00:09:27,690 --> 00:09:34,290
response it can send it responses in

00:09:30,600 --> 00:09:36,450
chunks predictably in streams now

00:09:34,290 --> 00:09:39,560
looking at how it works with progress of

00:09:36,450 --> 00:09:42,840
rendering your browser makes a request

00:09:39,560 --> 00:09:44,490
your server first time it sends a place

00:09:42,840 --> 00:09:46,650
or the like what we did for server and

00:09:44,490 --> 00:09:48,600
drink placeholder you just put in the

00:09:46,650 --> 00:09:51,720
primary content and placeholder on the

00:09:48,600 --> 00:09:53,340
screen now we don't have now JavaScript

00:09:51,720 --> 00:09:57,420
starts downloading in the background and

00:09:53,340 --> 00:09:59,970
your server can send the second chunk we

00:09:57,420 --> 00:10:02,070
can show the secondary content on the

00:09:59,970 --> 00:10:04,110
browser before your JavaScript bundle

00:10:02,070 --> 00:10:06,510
download completes and when the third

00:10:04,110 --> 00:10:08,340
chunk comes in we just send us kiss this

00:10:06,510 --> 00:10:10,680
is basically a concept of stitching we

00:10:08,340 --> 00:10:13,190
send a script that stitches the content

00:10:10,680 --> 00:10:16,230
on HTM that's already on the client

00:10:13,190 --> 00:10:17,820
now once the bundle download completes

00:10:16,230 --> 00:10:18,900
so because since everything is happening

00:10:17,820 --> 00:10:21,090
in the background it happens

00:10:18,900 --> 00:10:22,710
asynchronously once the bundle download

00:10:21,090 --> 00:10:25,350
completes you can just hydrate your

00:10:22,710 --> 00:10:26,610
content nothing fancy here so if we get

00:10:25,350 --> 00:10:29,520
the benefits of both

00:10:26,610 --> 00:10:31,740
using Play server under placeholders at

00:10:29,520 --> 00:10:36,390
the same time rendering all your content

00:10:31,740 --> 00:10:38,790
on the server so while I wrote the stock

00:10:36,390 --> 00:10:40,290
if we originally planned only to talk

00:10:38,790 --> 00:10:43,770
about progress of server rendering but

00:10:40,290 --> 00:10:45,630
the amazing react team recently released

00:10:43,770 --> 00:10:47,910
the experimental concurrent mode and

00:10:45,630 --> 00:10:50,460
with the concurrent mode we have this

00:10:47,910 --> 00:10:52,590
beautiful progress of hydration so the

00:10:50,460 --> 00:10:55,230
concept is simple crowd react concurrent

00:10:52,590 --> 00:10:56,730
mode is not just asynchronous updating

00:10:55,230 --> 00:10:59,940
the Dom it is not data bus performance

00:10:56,730 --> 00:11:01,980
it also has a progressive hydration

00:10:59,940 --> 00:11:05,130
around suspense boundaries what that

00:11:01,980 --> 00:11:07,440
means is whatever the surface boundary

00:11:05,130 --> 00:11:09,720
it is just plain old promises under the

00:11:07,440 --> 00:11:12,060
hood so when a chunk comes from the

00:11:09,720 --> 00:11:14,520
server we can declarative till react of

00:11:12,060 --> 00:11:15,920
a hydrate this portion only when this

00:11:14,520 --> 00:11:18,290
chunk comes out

00:11:15,920 --> 00:11:19,790
and we can also tell react hey if the

00:11:18,290 --> 00:11:21,350
chance takes a longer time to come in

00:11:19,790 --> 00:11:22,850
you can have you render the content on

00:11:21,350 --> 00:11:25,279
the client don't worry about it for the

00:11:22,850 --> 00:11:30,709
server so we have granular control over

00:11:25,279 --> 00:11:32,060
how a suspects boundary is rendered so

00:11:30,709 --> 00:11:34,940
you see when you if you look at progress

00:11:32,060 --> 00:11:38,510
of hydration you render the placeholder

00:11:34,940 --> 00:11:40,279
first and the server sends the chunk in

00:11:38,510 --> 00:11:42,949
the background your bundle file starts

00:11:40,279 --> 00:11:45,050
getting downloaded but here before the

00:11:42,949 --> 00:11:46,880
third chunk comes in don't bundle

00:11:45,050 --> 00:11:49,339
download completes so you hydrate

00:11:46,880 --> 00:11:51,589
whatever that's left on your client and

00:11:49,339 --> 00:11:53,779
when the rest of the chunk comes in

00:11:51,589 --> 00:11:55,430
react and hydrate that portion in the

00:11:53,779 --> 00:12:00,320
suspense boundary this is pretty

00:11:55,430 --> 00:12:00,889
fantastic alright those are all

00:12:00,320 --> 00:12:05,120
theoretical

00:12:00,889 --> 00:12:08,380
now I built a sample app to see how it

00:12:05,120 --> 00:12:08,380
works take a look

00:12:35,300 --> 00:12:40,210
let's assume this is an average website

00:12:37,760 --> 00:12:42,050
the content you see in darker shades

00:12:40,210 --> 00:12:43,610
those are going to be our primary

00:12:42,050 --> 00:12:44,930
content and the content you see in

00:12:43,610 --> 00:12:46,340
lighter shade that's going to be a

00:12:44,930 --> 00:12:48,230
secondary content which means secondary

00:12:46,340 --> 00:12:50,440
content is not critical you don't need

00:12:48,230 --> 00:12:54,080
to show it to user as soon as possible

00:12:50,440 --> 00:13:02,330
now if we render the app in client-side

00:12:54,080 --> 00:13:07,940
rendering mode I'm going to assign let

00:13:02,330 --> 00:13:09,230
the network speed to Wi-Fi this is

00:13:07,940 --> 00:13:10,910
pretty quick right because Wi-Fi is

00:13:09,230 --> 00:13:13,400
pretty fast well you usually we develop

00:13:10,910 --> 00:13:15,230
using a faster internet so you won't see

00:13:13,400 --> 00:13:17,300
much difference between client set and

00:13:15,230 --> 00:13:20,030
ring and server-side rendering in Wi-Fi

00:13:17,300 --> 00:13:22,730
mode so you see when you serve a render

00:13:20,030 --> 00:13:24,950
you have the content here but that

00:13:22,730 --> 00:13:28,820
bundle downloads pretty quickly and you

00:13:24,950 --> 00:13:31,130
hydrate the content pretty quickly but

00:13:28,820 --> 00:13:33,470
you you can see the real benefit and

00:13:31,130 --> 00:13:37,940
difference when you start simulating in

00:13:33,470 --> 00:13:39,620
the network mode so in mobile mode so if

00:13:37,940 --> 00:13:41,870
you render it using client-side

00:13:39,620 --> 00:13:43,700
rendering in the mobile mode see it

00:13:41,870 --> 00:13:45,770
takes a while just a white screen

00:13:43,700 --> 00:13:50,270
there's nothing to show to the user it

00:13:45,770 --> 00:13:51,620
takes about five six so there's one MB

00:13:50,270 --> 00:13:53,990
of bundle being downloaded for the sake

00:13:51,620 --> 00:13:55,610
of example and it took six seconds to

00:13:53,990 --> 00:13:57,200
show the first content of the user and

00:13:55,610 --> 00:13:59,360
it's not really good six seconds is

00:13:57,200 --> 00:14:03,320
really really slow if you render and

00:13:59,360 --> 00:14:05,450
server under more so you can see primary

00:14:03,320 --> 00:14:07,040
content comes in as soon as possible but

00:14:05,450 --> 00:14:10,070
secondary content you can show the

00:14:07,040 --> 00:14:13,040
secondary content only after the bundle

00:14:10,070 --> 00:14:14,660
downloads so still it's good that

00:14:13,040 --> 00:14:16,580
primary content shows as soon as

00:14:14,660 --> 00:14:18,590
possible but it takes time to show the

00:14:16,580 --> 00:14:19,850
secondary content if there is a way we

00:14:18,590 --> 00:14:21,440
could get the secondary content to the

00:14:19,850 --> 00:14:23,900
user as soon as possible then that's

00:14:21,440 --> 00:14:26,480
definitely waiting for everyone I'm

00:14:23,900 --> 00:14:28,700
going to show it one more time it's

00:14:26,480 --> 00:14:34,000
going to take six seconds here to show

00:14:28,700 --> 00:14:37,000
the secondary content oops yeah

00:14:34,000 --> 00:14:38,319
now if you read now what let's see what

00:14:37,000 --> 00:14:42,310
happens if we render this in progress

00:14:38,319 --> 00:14:44,350
surrender mode primary content is their

00:14:42,310 --> 00:14:47,439
second thing cotton gets stitched from

00:14:44,350 --> 00:14:49,209
chunks and so once your bundle

00:14:47,439 --> 00:14:51,100
javascript your bundle fat download

00:14:49,209 --> 00:14:52,930
completes you just need to hydrate so

00:14:51,100 --> 00:14:54,490
you have the capability to show the

00:14:52,930 --> 00:14:57,160
secondary content you are rendering your

00:14:54,490 --> 00:14:59,110
secondary content on the server chunking

00:14:57,160 --> 00:15:01,209
it to your client and just stitching it

00:14:59,110 --> 00:15:02,620
to your HTML so you don't have to rely

00:15:01,209 --> 00:15:04,959
on your client to download and show

00:15:02,620 --> 00:15:08,259
secondary content things get really

00:15:04,959 --> 00:15:09,730
crazy when you opt for a slow mode you

00:15:08,259 --> 00:15:11,920
can see there are just difference or

00:15:09,730 --> 00:15:18,399
obvious difference here I see let's

00:15:11,920 --> 00:15:22,750
render it on full client-side okay there

00:15:18,399 --> 00:15:24,040
we go so we have white screen I know how

00:15:22,750 --> 00:15:28,240
long this is gonna take because I've

00:15:24,040 --> 00:15:30,639
done this before but let's wait I think

00:15:28,240 --> 00:15:32,829
I can just walk out get a coffee and

00:15:30,639 --> 00:15:41,680
come back before we see something on the

00:15:32,829 --> 00:15:43,959
screen 20 21 22 yes

00:15:41,680 --> 00:15:45,970
so it takes 25 seconds to show any

00:15:43,959 --> 00:15:48,910
content for the ER to the user in slower

00:15:45,970 --> 00:15:51,279
mobile networks and if if the research

00:15:48,910 --> 00:15:53,559
shows that if you have a global user

00:15:51,279 --> 00:15:55,240
base there really lot of people are

00:15:53,559 --> 00:15:57,279
there on slower networks it's not just a

00:15:55,240 --> 00:15:59,649
marginal amount of people lot of people

00:15:57,279 --> 00:16:02,019
are there on slower networks fellow

00:15:59,649 --> 00:16:07,779
Australians will relate Internet in

00:16:02,019 --> 00:16:09,220
Australia is really really slow and so

00:16:07,779 --> 00:16:15,759
if you're under the same thing in super

00:16:09,220 --> 00:16:17,529
slow network in server and are more so

00:16:15,759 --> 00:16:18,819
you see it's good that we have content

00:16:17,529 --> 00:16:21,370
on the screen we have the primary

00:16:18,819 --> 00:16:23,050
content it's not really visible on the

00:16:21,370 --> 00:16:25,059
screen I but I am too proud of it the

00:16:23,050 --> 00:16:26,500
section right and left section you see

00:16:25,059 --> 00:16:27,970
they have similar views they are shining

00:16:26,500 --> 00:16:31,509
and there to show that content is

00:16:27,970 --> 00:16:33,910
loading yeah it'd be gone we have to

00:16:31,509 --> 00:16:35,740
wait 25 seconds to show the secondary

00:16:33,910 --> 00:16:37,420
content to the user it's better than

00:16:35,740 --> 00:16:38,800
prime side rendering but still you know

00:16:37,420 --> 00:16:41,410
it's going to take that long to show any

00:16:38,800 --> 00:16:45,000
content is not good at all but if you

00:16:41,410 --> 00:16:45,000
want to progressively render your app

00:16:47,660 --> 00:16:52,680
see you have the content here already

00:16:50,640 --> 00:16:54,540
you have to wait 25 seconds to hydrate

00:16:52,680 --> 00:16:56,820
but still all the content is here you

00:16:54,540 --> 00:16:59,010
might wonder why the secondary counter

00:16:56,820 --> 00:17:00,810
immediately loaded that is because the

00:16:59,010 --> 00:17:02,430
time it takes for the chunk to reach

00:17:00,810 --> 00:17:04,470
your user is really slow and slow

00:17:02,430 --> 00:17:05,730
network mode so when the first chunk was

00:17:04,470 --> 00:17:06,810
coming back the rest of the chunks were

00:17:05,730 --> 00:17:09,270
generated from the server and sent

00:17:06,810 --> 00:17:11,550
immediately so that's why you know chunk

00:17:09,270 --> 00:17:14,460
1 2 3 4 already loaded before the first

00:17:11,550 --> 00:17:16,230
response came to the browser you can if

00:17:14,460 --> 00:17:21,600
we can simulate the network latency a

00:17:16,230 --> 00:17:24,930
bit more you can see that in progressive

00:17:21,600 --> 00:17:27,839
rendering you have placeholders second

00:17:24,930 --> 00:17:30,000
chunk comes in you stitch it to the dom

00:17:27,839 --> 00:17:32,160
another term comes then you are going

00:17:30,000 --> 00:17:33,420
stitch it to the dom and now you can sit

00:17:32,160 --> 00:17:35,880
and wait until your whole bundle

00:17:33,420 --> 00:17:37,890
downloads you don't have interactivity

00:17:35,880 --> 00:17:39,510
here but still in all other modes you

00:17:37,890 --> 00:17:41,160
don't have interactivity either it's

00:17:39,510 --> 00:17:46,940
better to show content rather than show

00:17:41,160 --> 00:17:50,310
no content at all 23:25 there we go

00:17:46,940 --> 00:17:52,740
alright so if you want to take a look at

00:17:50,310 --> 00:17:53,820
how this is done in code wise I will

00:17:52,740 --> 00:17:58,190
briefly walk it through

00:17:53,820 --> 00:18:02,130
I remember what max said in his talk

00:17:58,190 --> 00:18:03,570
great abstractions are making the

00:18:02,130 --> 00:18:05,660
complete removing the complexities and

00:18:03,570 --> 00:18:08,640
reducing it to simple reusable steps

00:18:05,660 --> 00:18:10,380
that is one complication with the

00:18:08,640 --> 00:18:12,840
progress of rendering there is no

00:18:10,380 --> 00:18:14,430
reusable API since it's an experimental

00:18:12,840 --> 00:18:16,740
mode you are going to have to write

00:18:14,430 --> 00:18:19,230
really hacky code to get it done but it

00:18:16,740 --> 00:18:22,730
works nevertheless the benefit the users

00:18:19,230 --> 00:18:22,730
have the benefit not the devs though I

00:18:24,470 --> 00:18:29,160
mean come on if you are having a mobile

00:18:26,850 --> 00:18:30,510
phone and if your site can load really

00:18:29,160 --> 00:18:34,170
fast you're going to be super happy

00:18:30,510 --> 00:18:38,400
about it all right

00:18:34,170 --> 00:18:39,840
so in the server you're rendering so

00:18:38,400 --> 00:18:43,050
this part is where progress render

00:18:39,840 --> 00:18:46,350
happens so whenever there's a response

00:18:43,050 --> 00:18:48,330
right you render the first chunk and you

00:18:46,350 --> 00:18:50,640
have an await you wait for the response

00:18:48,330 --> 00:18:52,620
for the second chunk and then you write

00:18:50,640 --> 00:18:55,860
that you wait for the response for the

00:18:52,620 --> 00:18:58,860
further chunk and then you write it once

00:18:55,860 --> 00:19:00,419
everything is returned to the stream you

00:18:58,860 --> 00:19:02,399
close the stream it is as simple as that

00:19:00,419 --> 00:19:04,019
as to how we are rendering these

00:19:02,399 --> 00:19:07,350
progressive components I wrote a simple

00:19:04,019 --> 00:19:09,019
year tell it's pretty straightforward so

00:19:07,350 --> 00:19:11,250
we just need to tell the util how to

00:19:09,019 --> 00:19:12,779
from where we are rendering and we need

00:19:11,250 --> 00:19:14,750
to give an ID for the placeholder and

00:19:12,779 --> 00:19:16,500
with that placeholder you know the

00:19:14,750 --> 00:19:18,720
scripts that are coming through the

00:19:16,500 --> 00:19:21,059
chunks will know where to replace the

00:19:18,720 --> 00:19:23,100
content on the browser and if you are

00:19:21,059 --> 00:19:25,169
rendering on the client we wrap it in a

00:19:23,100 --> 00:19:26,970
lazy component if not we just use a

00:19:25,169 --> 00:19:30,120
normal component to render a server

00:19:26,970 --> 00:19:33,019
component it's as simple as that all

00:19:30,120 --> 00:19:33,019
right going back

00:19:43,960 --> 00:19:49,909
quickly recapping what all we saw here

00:19:46,610 --> 00:19:51,320
in client-side rendering no content

00:19:49,909 --> 00:19:53,330
comes from the server not your primary

00:19:51,320 --> 00:19:55,220
content not your cycling cotton only an

00:19:53,330 --> 00:19:58,309
empty dough comes from the server but

00:19:55,220 --> 00:20:00,200
and once you bundle downloads the

00:19:58,309 --> 00:20:01,070
latency to fetch data the API calls is

00:20:00,200 --> 00:20:03,559
going to be really high

00:20:01,070 --> 00:20:05,179
the reason being your API calls travel

00:20:03,559 --> 00:20:08,980
all over the world to your server there

00:20:05,179 --> 00:20:11,210
and the latins is high your ap the you

00:20:08,980 --> 00:20:14,990
service the urea pickles may correct was

00:20:11,210 --> 00:20:15,860
there not co-located and when we just

00:20:14,990 --> 00:20:17,539
saw what happened comes slow and

00:20:15,860 --> 00:20:21,049
networks so when your bundle size is

00:20:17,539 --> 00:20:23,059
pretty high your user satisfaction is

00:20:21,049 --> 00:20:26,210
going to take a huge hit in slower

00:20:23,059 --> 00:20:29,330
networks but the benefit is they're just

00:20:26,210 --> 00:20:32,570
HTML flights we can host them statically

00:20:29,330 --> 00:20:34,820
NAT will fly so we can host them

00:20:32,570 --> 00:20:38,120
statically in any of the static hosting

00:20:34,820 --> 00:20:39,830
sites in server rendering the benefit we

00:20:38,120 --> 00:20:41,780
have is primary content comes from the

00:20:39,830 --> 00:20:43,340
server we can send the secondary content

00:20:41,780 --> 00:20:46,400
as well but it's going to really slow

00:20:43,340 --> 00:20:48,620
down your response time so what we do

00:20:46,400 --> 00:20:50,990
instead we load the secondary content on

00:20:48,620 --> 00:20:53,270
the client we wait for the bundle to be

00:20:50,990 --> 00:20:54,730
downloaded so in slower networks it's

00:20:53,270 --> 00:20:57,110
better than prior client-side rendering

00:20:54,730 --> 00:20:59,179
but still it is not as good as

00:20:57,110 --> 00:21:01,669
progressive rendering but advantage

00:20:59,179 --> 00:21:03,350
though if you're the content on the

00:21:01,669 --> 00:21:07,159
you're showing on your web page it is

00:21:03,350 --> 00:21:08,570
not asked dynamically if there is going

00:21:07,159 --> 00:21:10,250
to be a part of the application that's

00:21:08,570 --> 00:21:12,409
common for all the users you can pre

00:21:10,250 --> 00:21:14,360
render them on yours during build time

00:21:12,409 --> 00:21:19,159
and then post it statically that's one

00:21:14,360 --> 00:21:21,169
of the advantages but when we opt for

00:21:19,159 --> 00:21:23,150
progressive server rendering coupled

00:21:21,169 --> 00:21:25,309
with progress behind client hydration

00:21:23,150 --> 00:21:27,020
you have a primary content from the

00:21:25,309 --> 00:21:29,150
server you have your secondary content

00:21:27,020 --> 00:21:31,640
from the server data fetch latency is

00:21:29,150 --> 00:21:33,530
super low the reason being your API

00:21:31,640 --> 00:21:35,450
calls happen in the server and most of

00:21:33,530 --> 00:21:37,909
the time arguably don't put me there but

00:21:35,450 --> 00:21:39,740
most of the time your APS are co-located

00:21:37,909 --> 00:21:43,580
with your server that means your EAP

00:21:39,740 --> 00:21:45,470
responds to super damp quick and it

00:21:43,580 --> 00:21:47,690
doesn't matter how fast or how slow your

00:21:45,470 --> 00:21:50,059
mobile network is even if on faster

00:21:47,690 --> 00:21:52,280
networks just once time is pretty much

00:21:50,059 --> 00:21:53,990
the same even on slow one networks time

00:21:52,280 --> 00:21:55,940
is poor depends the same because all the

00:21:53,990 --> 00:21:59,570
content is rendered on the server just

00:21:55,940 --> 00:22:00,950
time to hydrate is going to change one

00:21:59,570 --> 00:22:03,980
of the advantage here especially this

00:22:00,950 --> 00:22:05,240
applies only to react with the suspense

00:22:03,980 --> 00:22:07,279
boundaries you can build your own

00:22:05,240 --> 00:22:09,769
strategies what if your user is on a

00:22:07,279 --> 00:22:11,990
faster network what if your the bundle

00:22:09,769 --> 00:22:13,519
downloads quicker than the stream

00:22:11,990 --> 00:22:15,019
completes or what if your stream

00:22:13,519 --> 00:22:16,820
completes before you bundle download

00:22:15,019 --> 00:22:18,710
complex you have granular control over

00:22:16,820 --> 00:22:20,929
what to do when that happens whether to

00:22:18,710 --> 00:22:22,429
use the content from the server or just

00:22:20,929 --> 00:22:24,139
discard the chunk and just load it on

00:22:22,429 --> 00:22:26,330
the client you can do all kinds of fancy

00:22:24,139 --> 00:22:27,769
things with progressive memory one

00:22:26,330 --> 00:22:29,570
downside though you cannot pre render

00:22:27,769 --> 00:22:32,629
the reason being your server has to be

00:22:29,570 --> 00:22:34,190
dynamic and send stuff down the stream

00:22:32,629 --> 00:22:35,539
but it's ok I think about all the

00:22:34,190 --> 00:22:37,159
benefits we have here we can totally

00:22:35,539 --> 00:22:41,570
ignore that we cannot clear under your

00:22:37,159 --> 00:22:43,129
site that will be all my name is Dinesh

00:22:41,570 --> 00:22:43,760
Pandiyan thank you so much you are all

00:22:43,129 --> 00:22:51,170
awesome

00:22:43,760 --> 00:22:51,170

YouTube URL: https://www.youtube.com/watch?v=iYW7vKCqN6g


