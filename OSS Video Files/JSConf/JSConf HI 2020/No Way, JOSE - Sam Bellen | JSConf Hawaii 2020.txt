Title: No Way, JOSE - Sam Bellen | JSConf Hawaii 2020
Publication date: 2020-03-16
Playlist: JSConf HI 2020
Description: 
	Is your first thought when thinking about cryptography, “nope, that’s not for me!”? There’s no need to. When explained with simple examples, you can see the basics are not that complicated. The Javascript Object Signing and Encryption, or JOSE for short is a framework that helps us deal with encryption. It describes ways to securely transfer data either signed (JWS) or encrypted (JWE). Let’s take a leap of faith and explore the wonderful world of cryptography together, shall we?

In this talk, I will try to explain the basics of encryption and hashing through simple examples. We’ll look into how the JOSE standard can help us with encrypted content on the web using JSON Web Encryption (JWE) and JSON Web Keys (JWK). The audience does not need any specific knowledge about cryptography as this talk will go through the basics. Some JavaScript knowledge can be useful but not necessary as code examples will be simple and explained.

Why? The times when websites were just simple pieces of information is long gone. These days the web handles more sensitive data than ever before. To securely handle this data, we sometimes need to hash, encrypt or sign it. Sure there are a million tools, libraries and pieces of software that handle this for you, but knowing the basics can certainly come in handy!

Slides: https://jose.sambego.tech/

JSConf Hawaii will return soon
https://www.jsconfhi.com/
Captions: 
	00:00:09,320 --> 00:00:13,969
cryptography that's nice topic after

00:00:11,330 --> 00:00:17,980
lunch right who feels comfortable with

00:00:13,969 --> 00:00:17,980
cryptography and everything around them

00:00:18,860 --> 00:00:23,060
two people three people you can just go

00:00:21,500 --> 00:00:25,250
for a surf and I'll try to explain the

00:00:23,060 --> 00:00:27,259
basics of Catawba cryptography in this

00:00:25,250 --> 00:00:29,390
talk I will not go into detail and I

00:00:27,259 --> 00:00:31,400
might simplify certain things so don't

00:00:29,390 --> 00:00:33,220
expect to be an expert after this but

00:00:31,400 --> 00:00:34,940
it's good to know the basics of certain

00:00:33,220 --> 00:00:37,610
cryptography thingies it's very

00:00:34,940 --> 00:00:38,660
difficult to say cryptography for me so

00:00:37,610 --> 00:00:40,670
let's get started

00:00:38,660 --> 00:00:42,140
my name is Sam bellum I'm a developer

00:00:40,670 --> 00:00:43,640
advocate engineer at on zero and if

00:00:42,140 --> 00:00:47,000
you've never heard of alt 0 before

00:00:43,640 --> 00:00:48,170
shame on you know we're an identity is a

00:00:47,000 --> 00:00:49,699
service provider which basically means

00:00:48,170 --> 00:00:50,960
that we make it we try to make it as

00:00:49,699 --> 00:00:52,879
easy as possible for everybody to

00:00:50,960 --> 00:00:54,620
implement the secure authentication so

00:00:52,879 --> 00:00:56,120
you can focus on building your apps I'm

00:00:54,620 --> 00:00:58,159
a Google developer experts and I

00:00:56,120 --> 00:00:59,390
organized a few events from tears and

00:00:58,159 --> 00:01:00,979
Belgium which are meetups and the

00:00:59,390 --> 00:01:02,269
identity security meetups and London if

00:01:00,979 --> 00:01:04,670
you are from Belgium if you ever in

00:01:02,269 --> 00:01:06,820
London join us we're from and you can

00:01:04,670 --> 00:01:09,590
find me on the Internet is some big on

00:01:06,820 --> 00:01:13,250
this is a JavaScript conference so if

00:01:09,590 --> 00:01:15,260
you want you can NPM install me so at

00:01:13,250 --> 00:01:17,090
some biggest slash about me you'll

00:01:15,260 --> 00:01:18,860
download half of the Internet and when

00:01:17,090 --> 00:01:20,570
that's done you can see bit more about

00:01:18,860 --> 00:01:22,670
myself and find the link to these slides

00:01:20,570 --> 00:01:23,990
as well if you want to I have some cat

00:01:22,670 --> 00:01:25,490
stickers so if you don't have get

00:01:23,990 --> 00:01:28,100
stickers just send me a picture of your

00:01:25,490 --> 00:01:29,750
cat your dog your sea turtle whatever an

00:01:28,100 --> 00:01:33,740
animal and I'll give you some stickers

00:01:29,750 --> 00:01:35,450
after this talk okay so disclaimer I

00:01:33,740 --> 00:01:37,730
already said this I might simplify

00:01:35,450 --> 00:01:39,230
certain things because cryptography is

00:01:37,730 --> 00:01:41,270
very difficult it's very complicated

00:01:39,230 --> 00:01:44,150
real fast and I just want to stay on the

00:01:41,270 --> 00:01:46,190
surface of this so what we're going to

00:01:44,150 --> 00:01:49,190
be seeing today hashing signing

00:01:46,190 --> 00:01:51,800
encryption and Jose if you've never

00:01:49,190 --> 00:01:56,330
heard of these things perfect if you

00:01:51,800 --> 00:01:57,860
have also perfect so hashing hashing a

00:01:56,330 --> 00:01:59,540
national algorithm is a mathematical

00:01:57,860 --> 00:02:01,640
algorithm that map's data of an

00:01:59,540 --> 00:02:03,890
arbitrary size to a bit to a bit string

00:02:01,640 --> 00:02:06,260
of a fixed size there's a matter how big

00:02:03,890 --> 00:02:08,390
your string is or your conten this the

00:02:06,260 --> 00:02:10,940
event the end result will always be the

00:02:08,390 --> 00:02:13,430
same size that comes out of this

00:02:10,940 --> 00:02:14,780
algorithm the initial data is often

00:02:13,430 --> 00:02:16,040
called the message and the outcome of

00:02:14,780 --> 00:02:19,730
the hashing function is called the hash

00:02:16,040 --> 00:02:21,319
or the message digest and a hashing is a

00:02:19,730 --> 00:02:22,879
one-way function which means you can put

00:02:21,319 --> 00:02:24,470
in something in a hashing function you

00:02:22,879 --> 00:02:26,599
get out something but you cannot reverse

00:02:24,470 --> 00:02:28,520
the thing you just did your hair cannot

00:02:26,599 --> 00:02:31,850
be reversed to get the original content

00:02:28,520 --> 00:02:32,750
you put in that function so if you put

00:02:31,850 --> 00:02:34,550
input

00:02:32,750 --> 00:02:36,500
you get a certain string if you put dug

00:02:34,550 --> 00:02:38,390
Oh if you put in the quick brown fox

00:02:36,500 --> 00:02:40,459
jumps over the lazy dog you all get some

00:02:38,390 --> 00:02:41,630
output and they're all of the same size

00:02:40,459 --> 00:02:43,640
there's a matter if it's a three-letter

00:02:41,630 --> 00:02:45,739
word or a whole sentence or a whole book

00:02:43,640 --> 00:02:49,459
I'm not sure about the whole book but it

00:02:45,739 --> 00:02:51,080
should all be the same the same size and

00:02:49,459 --> 00:02:55,100
you cannot reverse it it's a one-way

00:02:51,080 --> 00:02:57,290
directional algorithm a bunch of them

00:02:55,100 --> 00:03:00,470
are these ones there's a bunch more we

00:02:57,290 --> 00:03:02,959
might have come across them yeah

00:03:00,470 --> 00:03:04,850
so there's another type of hashing it's

00:03:02,959 --> 00:03:06,350
called keyed hashing and it's a little

00:03:04,850 --> 00:03:07,880
bit different but it's also the same

00:03:06,350 --> 00:03:09,920
it's now algorithm it's one directional

00:03:07,880 --> 00:03:13,010
you get a fixed thingy out in the back

00:03:09,920 --> 00:03:15,319
of the function but keet hashes lets you

00:03:13,010 --> 00:03:17,600
validating integrity and authentic

00:03:15,319 --> 00:03:19,970
authenticity of the content of the hash

00:03:17,600 --> 00:03:22,130
which means that you can it can validate

00:03:19,970 --> 00:03:23,750
that the content of that that you're

00:03:22,130 --> 00:03:26,480
trying to validate it's not been

00:03:23,750 --> 00:03:28,400
tampered with in order to compute a key

00:03:26,480 --> 00:03:30,260
- you need a secret key something that a

00:03:28,400 --> 00:03:31,880
secret which you don't pass on to other

00:03:30,260 --> 00:03:35,330
people and you save it so more securely

00:03:31,880 --> 00:03:37,040
for yourself if you take the same thing

00:03:35,330 --> 00:03:38,750
as we saw before you basically have the

00:03:37,040 --> 00:03:41,239
same or an or we have an algorithm that

00:03:38,750 --> 00:03:42,859
outputs a hash but it also wants that

00:03:41,239 --> 00:03:45,109
secret and based on that secret the

00:03:42,859 --> 00:03:46,970
output the hashes is going to change so

00:03:45,109 --> 00:03:48,620
if I change my super secret to some

00:03:46,970 --> 00:03:50,780
other secret the hash will not be the

00:03:48,620 --> 00:03:53,540
same even though the input was still the

00:03:50,780 --> 00:03:56,480
same for example we have the quick brown

00:03:53,540 --> 00:03:58,489
fox etc as an input and we use super

00:03:56,480 --> 00:04:00,380
secret as a secret the algorithm will

00:03:58,489 --> 00:04:03,109
output a certain hash if you use another

00:04:00,380 --> 00:04:04,459
secret it will put another hash which

00:04:03,109 --> 00:04:09,140
means that you can validate that

00:04:04,459 --> 00:04:12,620
somebody had have has or has not changed

00:04:09,140 --> 00:04:15,950
something in the original input

00:04:12,620 --> 00:04:18,650
okay inside of this algorithm looks a

00:04:15,950 --> 00:04:20,120
bit like this your secret key gets split

00:04:18,650 --> 00:04:22,190
into two different keys and Enter key

00:04:20,120 --> 00:04:24,020
and an arrow key and you just make a

00:04:22,190 --> 00:04:25,850
first hash use that first hash to create

00:04:24,020 --> 00:04:29,960
the second edge and at second hash is an

00:04:25,850 --> 00:04:31,729
output this is specific to H Mac but you

00:04:29,960 --> 00:04:33,139
don't really need to need to notice the

00:04:31,729 --> 00:04:35,419
thing you need to know is that you get a

00:04:33,139 --> 00:04:39,410
fixed hash outside at the end of the

00:04:35,419 --> 00:04:41,780
function so some key key hashing

00:04:39,410 --> 00:04:43,820
algorithms are these image come across

00:04:41,780 --> 00:04:46,340
some others they're way too many

00:04:43,820 --> 00:04:49,790
algorithms to sum up in this talk in 25

00:04:46,340 --> 00:04:52,010
minutes so let's move on

00:04:49,790 --> 00:04:53,480
so all these algorithms have very

00:04:52,010 --> 00:04:55,310
difficult names with a lot of letters

00:04:53,480 --> 00:04:57,410
and a lot of numbers and sometimes it's

00:04:55,310 --> 00:04:59,960
confusing to know what they mean so if

00:04:57,410 --> 00:05:03,920
you break down this algorithm hmx char

00:04:59,960 --> 00:05:05,570
265 which would be 2 5 6 it's keyed hash

00:05:03,920 --> 00:05:07,640
message authentication code so we're

00:05:05,570 --> 00:05:10,370
going to create a keyed match geeky test

00:05:07,640 --> 00:05:12,740
hash message and it's using the secure

00:05:10,370 --> 00:05:17,360
hash algorithm to do this how we're

00:05:12,740 --> 00:05:19,370
getting in 256 bits output basically so

00:05:17,360 --> 00:05:21,440
all these algorithms are basically you

00:05:19,370 --> 00:05:23,120
can break them down into certain parts

00:05:21,440 --> 00:05:24,950
and they all tell you a certain thing

00:05:23,120 --> 00:05:26,810
about the algorithm what it's doing

00:05:24,950 --> 00:05:30,200
which algorithms using bit size and

00:05:26,810 --> 00:05:31,880
stuff like this fashion are often used

00:05:30,200 --> 00:05:33,740
to store passwords for example if you

00:05:31,880 --> 00:05:35,330
want to store passwords in a database by

00:05:33,740 --> 00:05:38,470
now we should all know to not do this in

00:05:35,330 --> 00:05:41,810
plain text who does that in plain text

00:05:38,470 --> 00:05:44,270
nobody hashes are often used for this

00:05:41,810 --> 00:05:46,040
because it's a one-way one-way algorithm

00:05:44,270 --> 00:05:47,960
so you can store it in there and even

00:05:46,040 --> 00:05:49,790
though if your data gets stolen which I

00:05:47,960 --> 00:05:51,290
hope it doesn't people can still not

00:05:49,790 --> 00:05:56,720
know the password because you cannot

00:05:51,290 --> 00:05:59,720
reverse it ok on to the next topic

00:05:56,720 --> 00:06:01,400
signing digital signatures offer all

00:05:59,720 --> 00:06:03,560
properties of kete hashes plus

00:06:01,400 --> 00:06:06,320
cryptographic non reputation which means

00:06:03,560 --> 00:06:09,770
that you can also check the integrity

00:06:06,320 --> 00:06:11,840
and authenticity of yet the output but

00:06:09,770 --> 00:06:14,420
it's also cryptographic non-repudiation

00:06:11,840 --> 00:06:16,400
or whatever it is

00:06:14,420 --> 00:06:18,260
which means cryptographic no reputation

00:06:16,400 --> 00:06:19,730
enables the other parties and the signer

00:06:18,260 --> 00:06:23,660
to check the signatures fidelity

00:06:19,730 --> 00:06:25,520
validity h max use the secret to create

00:06:23,660 --> 00:06:27,650
those hashes but if you want somebody to

00:06:25,520 --> 00:06:29,630
enable to check the output of that hash

00:06:27,650 --> 00:06:31,640
you also need to share that secret and

00:06:29,630 --> 00:06:34,790
we all know the more you share a secret

00:06:31,640 --> 00:06:35,990
the less secure your secret gets so it

00:06:34,790 --> 00:06:38,120
would be nice if you could do the same

00:06:35,990 --> 00:06:40,960
thing without sharing or secrets with

00:06:38,120 --> 00:06:44,060
other people with third parties

00:06:40,960 --> 00:06:46,940
signatures of digne signature signatures

00:06:44,060 --> 00:06:50,150
allow you to do this they use public key

00:06:46,940 --> 00:06:52,490
and a private key to do this there a

00:06:50,150 --> 00:06:53,810
symmetric cryptography which is

00:06:52,490 --> 00:06:55,870
basically the same I'm saying I use a

00:06:53,810 --> 00:06:58,250
public key and a private key to do stuff

00:06:55,870 --> 00:07:00,140
the styler creates a signature using the

00:06:58,250 --> 00:07:02,060
private key so you the person who's

00:07:00,140 --> 00:07:03,090
going to create the dignity the

00:07:02,060 --> 00:07:05,520
signature is

00:07:03,090 --> 00:07:07,710
are you going to use your private key to

00:07:05,520 --> 00:07:09,720
create a signature and then you're going

00:07:07,710 --> 00:07:12,389
to just send your signature to have a

00:07:09,720 --> 00:07:14,250
nice to use that one and that person or

00:07:12,389 --> 00:07:15,300
that party can you can use your public

00:07:14,250 --> 00:07:17,310
key which is something that can be

00:07:15,300 --> 00:07:19,590
probably available to check the validity

00:07:17,310 --> 00:07:20,790
of your signature that way you don't

00:07:19,590 --> 00:07:22,050
have to share your secret

00:07:20,790 --> 00:07:24,360
you don't have to share your private key

00:07:22,050 --> 00:07:26,430
you only have to use share your public

00:07:24,360 --> 00:07:29,250
key which can only be used to validate

00:07:26,430 --> 00:07:30,780
validate the output but you cannot

00:07:29,250 --> 00:07:33,770
create a new signature with that public

00:07:30,780 --> 00:07:35,669
key for that you need the private key

00:07:33,770 --> 00:07:37,320
understanding algorithm is usually a

00:07:35,669 --> 00:07:39,270
collection of three algorithms or maybe

00:07:37,320 --> 00:07:40,919
more a key generation something that

00:07:39,270 --> 00:07:43,290
generates the public key and a private

00:07:40,919 --> 00:07:45,210
key a signing algorithm something that

00:07:43,290 --> 00:07:46,500
makes a signature and a verifying

00:07:45,210 --> 00:07:48,450
algorithm something that knows how to

00:07:46,500 --> 00:07:52,470
verify those signatures

00:07:48,450 --> 00:07:53,370
created by that algorithm so it might

00:07:52,470 --> 00:07:56,250
look something like this

00:07:53,370 --> 00:07:58,680
you have your input hashing algorithm

00:07:56,250 --> 00:08:00,360
you sign that with a private key and you

00:07:58,680 --> 00:08:05,460
send that output to whoever needs to

00:08:00,360 --> 00:08:09,840
receive this we verify the input and

00:08:05,460 --> 00:08:12,539
then the person who wants to validate

00:08:09,840 --> 00:08:15,270
it's going to basically use it verifying

00:08:12,539 --> 00:08:17,190
algorithm to get a hash it's going to

00:08:15,270 --> 00:08:19,979
hash the original input and if those

00:08:17,190 --> 00:08:21,419
hashing if those hashes match they know

00:08:19,979 --> 00:08:23,280
that the content has not been tampered

00:08:21,419 --> 00:08:26,099
with it's going to use a public key to

00:08:23,280 --> 00:08:28,729
verify the to verify the signature not

00:08:26,099 --> 00:08:28,729
the private key

00:08:31,080 --> 00:08:34,320
so the most commonly used public key

00:08:32,669 --> 00:08:37,110
cryptography approaches when signing our

00:08:34,320 --> 00:08:39,060
RSA elliptic elliptic curve and at-risk

00:08:37,110 --> 00:08:42,659
curve there's a few others but these

00:08:39,060 --> 00:08:44,910
three are more common RSA could be a few

00:08:42,659 --> 00:08:48,300
of these and the good thing about them

00:08:44,910 --> 00:08:50,250
is they're fast the CP friendly have a

00:08:48,300 --> 00:08:52,590
good support oryzae has been been around

00:08:50,250 --> 00:08:55,020
for a while the bad thing is they

00:08:52,590 --> 00:08:56,900
require longer keys because you need a

00:08:55,020 --> 00:08:59,910
minimum of two thousand fifty six bits

00:08:56,900 --> 00:09:01,350
do you have them a bit more secure so

00:08:59,910 --> 00:09:02,940
your output will be longer your process

00:09:01,350 --> 00:09:06,000
will be longer the computations will be

00:09:02,940 --> 00:09:07,740
a bit more intense and as I said these

00:09:06,000 --> 00:09:12,150
signatures are a bit longer because we

00:09:07,740 --> 00:09:15,180
need this 2056 bit algorithms elliptic

00:09:12,150 --> 00:09:18,690
curve you're shorter for the same

00:09:15,180 --> 00:09:20,970
equivalent of security as RSA they have

00:09:18,690 --> 00:09:22,500
shorter keys shorter signatures but

00:09:20,970 --> 00:09:24,990
they're also a bit more complicated so

00:09:22,500 --> 00:09:28,440
they take a bit longer to compute and

00:09:24,990 --> 00:09:29,580
then Edwards curve they're the best for

00:09:28,440 --> 00:09:31,440
standing performance but they're

00:09:29,580 --> 00:09:32,640
relatively new so not all libraries that

00:09:31,440 --> 00:09:35,730
you might want to use in your project

00:09:32,640 --> 00:09:37,350
might support them it's new so it's

00:09:35,730 --> 00:09:40,200
coming to most libraries but it might

00:09:37,350 --> 00:09:42,209
not be there yet that's a downside but

00:09:40,200 --> 00:09:43,709
not forever

00:09:42,209 --> 00:09:47,459
all right we've seen hashing we've seen

00:09:43,709 --> 00:09:48,749
encryption has gone to encryption we've

00:09:47,459 --> 00:09:50,819
seen hashing we see styling that's going

00:09:48,749 --> 00:09:51,990
to encryption when encrypting data we

00:09:50,819 --> 00:09:55,499
cannot only ensure the intrigue

00:09:51,990 --> 00:09:57,929
integrity and authenticity like keyed

00:09:55,499 --> 00:09:59,970
hashes but we can also be sure that the

00:09:57,929 --> 00:10:01,319
data will stay secret for outsiders

00:09:59,970 --> 00:10:03,209
so people who should not know the

00:10:01,319 --> 00:10:06,809
contents of the data cannot know when

00:10:03,209 --> 00:10:08,639
it's encrypted or should not know so you

00:10:06,809 --> 00:10:10,619
need either a private key a secret key

00:10:08,639 --> 00:10:14,610
or a password to read the data to

00:10:10,619 --> 00:10:16,559
decrypt in the encrypted data encrypted

00:10:14,610 --> 00:10:18,600
message is often called a cipher so if

00:10:16,559 --> 00:10:20,429
we refer to a cipher it's basically the

00:10:18,600 --> 00:10:22,910
end result of an encryption algorithm

00:10:20,429 --> 00:10:26,699
it's the output of that algorithm it's

00:10:22,910 --> 00:10:28,249
the encrypted message and there's

00:10:26,699 --> 00:10:32,519
symmetric and asymmetric encryption

00:10:28,249 --> 00:10:33,869
symmetric encryption like some examples

00:10:32,519 --> 00:10:35,970
of those are when you want to encrypt

00:10:33,869 --> 00:10:38,720
your filesystem your hard drive or Wi-Fi

00:10:35,970 --> 00:10:42,089
protected access WPA database encryption

00:10:38,720 --> 00:10:43,619
anything that has a lot of content it's

00:10:42,089 --> 00:10:45,420
usually encrypted with a cig with a

00:10:43,619 --> 00:10:47,610
symmetric algorithm which uses a secret

00:10:45,420 --> 00:10:50,970
key or a password instead of a public

00:10:47,610 --> 00:10:53,819
and private key these are a few of these

00:10:50,970 --> 00:10:56,519
out of the algorithms and it works a bit

00:10:53,819 --> 00:10:58,230
like this your input gets encrypted with

00:10:56,519 --> 00:10:59,879
a sort of algorithm you get the output

00:10:58,230 --> 00:11:01,769
and then if you want to decrypt it you

00:10:59,879 --> 00:11:04,589
use a decryption algorithm but they both

00:11:01,769 --> 00:11:05,939
use the same secret key or passwords you

00:11:04,589 --> 00:11:07,049
don't have a separate key for encrypting

00:11:05,939 --> 00:11:08,910
you don't have a separate key for

00:11:07,049 --> 00:11:11,910
decrypting they use the same secret

00:11:08,910 --> 00:11:14,660
that's why it's symmetrical

00:11:11,910 --> 00:11:16,830
a symmetric encryption on the other hand

00:11:14,660 --> 00:11:19,110
the sender asked for the receivers

00:11:16,830 --> 00:11:21,420
public key first and uses a public key

00:11:19,110 --> 00:11:23,850
to encrypt the message so that the

00:11:21,420 --> 00:11:25,980
receiver can use s privately private key

00:11:23,850 --> 00:11:28,800
to decrypt the message so you have two

00:11:25,980 --> 00:11:31,260
different keys that work with this it's

00:11:28,800 --> 00:11:33,060
kind of algorithms so when the receiver

00:11:31,260 --> 00:11:34,380
receives a cipher they use their

00:11:33,060 --> 00:11:36,540
matching private key to decrypt a

00:11:34,380 --> 00:11:38,490
message encryption with the public key

00:11:36,540 --> 00:11:40,560
decryption with the private key you own

00:11:38,490 --> 00:11:42,630
and you will keep on owning the public

00:11:40,560 --> 00:11:43,950
key is public domain or could be public

00:11:42,630 --> 00:11:46,200
domain so anybody can use your public

00:11:43,950 --> 00:11:47,670
key to create an encrypted message send

00:11:46,200 --> 00:11:49,860
it to you and you'll be able to decrypt

00:11:47,670 --> 00:11:51,720
it with your private key and this means

00:11:49,860 --> 00:11:55,440
you will be the only one to be able to

00:11:51,720 --> 00:11:57,600
decrypt that with your private key so if

00:11:55,440 --> 00:11:58,140
you take the the example of we had

00:11:57,600 --> 00:11:59,790
before

00:11:58,140 --> 00:12:01,080
instead of fusing one shared secret we

00:11:59,790 --> 00:12:03,510
now use a public key and a private key

00:12:01,080 --> 00:12:05,560
public for encryption private for

00:12:03,510 --> 00:12:07,840
decryption

00:12:05,560 --> 00:12:09,760
so a little bit detailed example of RSA

00:12:07,840 --> 00:12:11,050
because it all sounds fancy but how does

00:12:09,760 --> 00:12:12,730
this actually work how can we use a

00:12:11,050 --> 00:12:14,770
public key or a private key and how does

00:12:12,730 --> 00:12:16,360
the magic behind that works it's quite

00:12:14,770 --> 00:12:19,779
complicated so I'm going to try to

00:12:16,360 --> 00:12:20,860
explain it a bit more simplified so the

00:12:19,779 --> 00:12:24,180
first thing you do when you work with

00:12:20,860 --> 00:12:26,529
with a synchronous similar synchronous

00:12:24,180 --> 00:12:27,880
algorithms is generating keys your

00:12:26,529 --> 00:12:32,020
public key and your private key so you

00:12:27,880 --> 00:12:33,850
can do stuff with them so cryptography

00:12:32,020 --> 00:12:36,190
is usually based on large prime numbers

00:12:33,850 --> 00:12:37,810
in this example I'm going to use small

00:12:36,190 --> 00:12:40,210
prime numbers just as a bit more

00:12:37,810 --> 00:12:43,330
variable but in practice you're going to

00:12:40,210 --> 00:12:45,370
use very very large numbers so the first

00:12:43,330 --> 00:12:47,110
thing we do we want to create a a set of

00:12:45,370 --> 00:12:49,660
keys a public key and a private key so

00:12:47,110 --> 00:12:51,160
we create two prime numbers and these

00:12:49,660 --> 00:12:53,620
are going to be huge and this in this

00:12:51,160 --> 00:12:55,630
instance 61 or 53 and we're going to

00:12:53,620 --> 00:12:58,000
calculate the lambda which is the least

00:12:55,630 --> 00:12:59,200
common something I forgot the name but

00:12:58,000 --> 00:13:01,750
it's basically a mathematical function

00:12:59,200 --> 00:13:04,660
you run with those prime numbers you get

00:13:01,750 --> 00:13:06,310
a result 780 you keep those numbers you

00:13:04,660 --> 00:13:07,810
don't give them to anybody but you use

00:13:06,310 --> 00:13:09,400
those to generate the public key and the

00:13:07,810 --> 00:13:12,580
private key then the public key

00:13:09,400 --> 00:13:14,350
basically contains some modulus and the

00:13:12,580 --> 00:13:16,060
public exponent and the private key

00:13:14,350 --> 00:13:18,310
contains the modulus and the private

00:13:16,060 --> 00:13:22,360
exponent and by just saving these pieces

00:13:18,310 --> 00:13:24,370
of data which we created from the top

00:13:22,360 --> 00:13:26,740
part the secrets we can later on use

00:13:24,370 --> 00:13:31,540
them to encrypt or decrypt certain

00:13:26,740 --> 00:13:33,490
messages so remember that there is the

00:13:31,540 --> 00:13:38,089
public exponent key and a private

00:13:33,490 --> 00:13:39,230
exponent D in the public and private key

00:13:38,089 --> 00:13:40,879
so if you want to use a public key to

00:13:39,230 --> 00:13:42,860
encrypt a certain message we're going to

00:13:40,879 --> 00:13:46,519
take that those numbers the data in the

00:13:42,860 --> 00:13:48,499
in the public key and we're going to do

00:13:46,519 --> 00:13:52,879
a mathematical complicated computation

00:13:48,499 --> 00:13:57,529
in this case it's M e mod M and where m

00:13:52,879 --> 00:13:58,879
is the message e we find Ian and we find

00:13:57,529 --> 00:14:02,930
a public key these are the things we

00:13:58,879 --> 00:14:04,970
just put in the public key right here

00:14:02,930 --> 00:14:07,579
and if you do this computation you end

00:14:04,970 --> 00:14:08,240
up with a result which is the message

00:14:07,579 --> 00:14:10,309
digest

00:14:08,240 --> 00:14:13,249
it's the decipher of the encryption

00:14:10,309 --> 00:14:14,870
algorithm and if you want to do it a bit

00:14:13,249 --> 00:14:16,579
more complicated you're probably going

00:14:14,870 --> 00:14:18,589
to take your input and then convert that

00:14:16,579 --> 00:14:20,930
to a string or binary and then to bake

00:14:18,589 --> 00:14:22,550
integer and do the whole thing again but

00:14:20,930 --> 00:14:24,829
the basic stay the same you have your

00:14:22,550 --> 00:14:27,529
big number here and you use that certain

00:14:24,829 --> 00:14:31,009
function to create an output which is 2

00:14:27,529 --> 00:14:33,079
1 8 3 in this case then if you want to

00:14:31,009 --> 00:14:34,730
use your private key to decrypt it

00:14:33,079 --> 00:14:36,680
we know that the private key has two

00:14:34,730 --> 00:14:39,499
things in it the modulus and it has D in

00:14:36,680 --> 00:14:42,709
it sorry again we can use a mathematical

00:14:39,499 --> 00:14:44,089
function to run on the input and if we

00:14:42,709 --> 00:14:46,759
do this we should be able to get the

00:14:44,089 --> 00:14:49,100
original value back this is because the

00:14:46,759 --> 00:14:50,360
the N value the D value the e value in

00:14:49,100 --> 00:14:52,459
your public key they're all derived from

00:14:50,360 --> 00:14:54,679
those secrets we created in the in the

00:14:52,459 --> 00:14:58,069
beginning we were creating our keys the

00:14:54,679 --> 00:15:00,379
two prime numbers and the lambda so we

00:14:58,069 --> 00:15:02,480
input the decipher we come back in the

00:15:00,379 --> 00:15:04,910
previous example and we should be able

00:15:02,480 --> 00:15:06,230
to get back 1 2 3 4 if you're very good

00:15:04,910 --> 00:15:09,379
in math in your head you can try to do

00:15:06,230 --> 00:15:14,720
this otherwise just believe me that it's

00:15:09,379 --> 00:15:16,999
true again usually you're not working

00:15:14,720 --> 00:15:18,559
with numbers is how you might want to

00:15:16,999 --> 00:15:20,959
get some text or something else out of

00:15:18,559 --> 00:15:23,179
it so you have to do some conversion

00:15:20,959 --> 00:15:25,970
between certain types but the essence is

00:15:23,179 --> 00:15:28,699
still big number do some mathematical

00:15:25,970 --> 00:15:33,230
operations get another number and use

00:15:28,699 --> 00:15:35,629
those those things so if we would look

00:15:33,230 --> 00:15:38,449
an example this is the same numbers that

00:15:35,629 --> 00:15:42,769
we saw earlier and then the encryption

00:15:38,449 --> 00:15:45,170
is just 16 16 to the 17th and a modulus

00:15:42,769 --> 00:15:47,570
2 into

00:15:45,170 --> 00:15:49,910
I think and the decryption is the same

00:15:47,570 --> 00:15:53,150
actually saw earlier and we can see that

00:15:49,910 --> 00:15:55,670
this works but in reality we're working

00:15:53,150 --> 00:15:57,860
with very big numbers so the numbers

00:15:55,670 --> 00:15:59,780
might be something like this notice that

00:15:57,860 --> 00:16:02,270
these are numbers with more than 150

00:15:59,780 --> 00:16:04,400
digits in them so they're quite large

00:16:02,270 --> 00:16:09,290
they're all quite quite large prime

00:16:04,400 --> 00:16:12,440
numbers okay a symmetric encryption use

00:16:09,290 --> 00:16:14,720
cases are TLS VPN SSH you might be

00:16:12,440 --> 00:16:17,570
familiar with those those use public

00:16:14,720 --> 00:16:23,270
keys and private keys as you might know

00:16:17,570 --> 00:16:24,980
or might not know some algorithms and

00:16:23,270 --> 00:16:26,660
simple it's it's it's worth they say

00:16:24,980 --> 00:16:28,460
that symmetrical algorithms are faster

00:16:26,660 --> 00:16:30,220
than a symmetrical ones just because of

00:16:28,460 --> 00:16:33,920
the amount of math that's included in

00:16:30,220 --> 00:16:36,710
doing something as symmetrical and like

00:16:33,920 --> 00:16:39,200
I said before when you want to encrypt a

00:16:36,710 --> 00:16:40,910
lot a big piece of data you're going to

00:16:39,200 --> 00:16:42,650
use something symmetrical because it

00:16:40,910 --> 00:16:45,310
would be not possible to do that with

00:16:42,650 --> 00:16:48,819
asymmetric algorithms

00:16:45,310 --> 00:16:52,029
so Jose the name of the talk what is

00:16:48,819 --> 00:16:53,410
Jose its JSON object signing and

00:16:52,029 --> 00:16:55,990
encryption so basically it's just a

00:16:53,410 --> 00:16:58,420
group of standards created by some

00:16:55,990 --> 00:17:01,689
governing body on the internet which

00:16:58,420 --> 00:17:05,169
combines a few standards based on Jason

00:17:01,689 --> 00:17:06,669
why Jason the Jason format is often used

00:17:05,169 --> 00:17:07,990
for serializing and transmitting

00:17:06,669 --> 00:17:10,030
structured data over a network

00:17:07,990 --> 00:17:11,890
connection which basically means we all

00:17:10,030 --> 00:17:14,620
know how Jason works we all have worked

00:17:11,890 --> 00:17:18,699
with Jason in the past we know we all

00:17:14,620 --> 00:17:19,990
know how to do that the thing and it is

00:17:18,699 --> 00:17:21,459
excellent support in most programming

00:17:19,990 --> 00:17:22,959
languages even though it was born out of

00:17:21,459 --> 00:17:25,510
JavaScript most programming languages

00:17:22,959 --> 00:17:29,230
now support Jason in one way or the

00:17:25,510 --> 00:17:30,730
other so like I said it's a collection

00:17:29,230 --> 00:17:32,890
of standards

00:17:30,730 --> 00:17:34,750
Jason reps something you might have

00:17:32,890 --> 00:17:36,700
heard of a few before Jason up token

00:17:34,750 --> 00:17:39,250
being the most common one but there's

00:17:36,700 --> 00:17:42,159
more than just tokens this JSON web keys

00:17:39,250 --> 00:17:44,860
what this basically means is a way of

00:17:42,159 --> 00:17:48,220
sharing public keys over the Internet in

00:17:44,860 --> 00:17:50,789
the form of Jason and this might look

00:17:48,220 --> 00:17:53,919
something like this this is a public key

00:17:50,789 --> 00:17:56,620
civilized or CLS to a JSON structure and

00:17:53,919 --> 00:17:58,570
if you paid attention you might see that

00:17:56,620 --> 00:18:00,399
there is the NDE value which we talked

00:17:58,570 --> 00:18:02,740
about earlier which is the public

00:18:00,399 --> 00:18:04,450
exponents and the modulus also in this

00:18:02,740 --> 00:18:06,580
so this is a public key it has some more

00:18:04,450 --> 00:18:07,750
information like a key ID and certain

00:18:06,580 --> 00:18:10,149
all of the other things like which

00:18:07,750 --> 00:18:12,030
algorithm can use this and the user

00:18:10,149 --> 00:18:14,740
should forsake for signing in this case

00:18:12,030 --> 00:18:19,179
but it's a JSON structure which contains

00:18:14,740 --> 00:18:23,140
all the information of a public key the

00:18:19,179 --> 00:18:24,070
next one is JSON web signature and you

00:18:23,140 --> 00:18:27,160
might have seen this which

00:18:24,070 --> 00:18:29,170
snap tokens it's some usually base64 dot

00:18:27,160 --> 00:18:31,870
base64 dot some random stuff which is

00:18:29,170 --> 00:18:33,580
also basic basic c4 so if you look at

00:18:31,870 --> 00:18:35,470
the JSON web signature it's three parts

00:18:33,580 --> 00:18:38,230
the first one the header the payload and

00:18:35,470 --> 00:18:40,510
the last part the signature and this

00:18:38,230 --> 00:18:43,360
could be a JSON of signature basic C for

00:18:40,510 --> 00:18:46,270
the base64 base64 looks all random data

00:18:43,360 --> 00:18:48,160
it is not if you would try to do decode

00:18:46,270 --> 00:18:51,670
those basic C for thing is the first one

00:18:48,160 --> 00:18:54,550
the header would be a other header and

00:18:51,670 --> 00:18:56,290
you would get something like this the

00:18:54,550 --> 00:18:58,960
algorithm that's being used in this

00:18:56,290 --> 00:19:02,290
signature if you do the same with the

00:18:58,960 --> 00:19:05,140
second part you would get something like

00:19:02,290 --> 00:19:06,760
this some JSON content fubar anything

00:19:05,140 --> 00:19:09,400
that fell Jason could be the pale out of

00:19:06,760 --> 00:19:13,090
a JSON web signature and then the third

00:19:09,400 --> 00:19:16,030
part is the last part in the string as

00:19:13,090 --> 00:19:17,620
well it's basically just did the actual

00:19:16,030 --> 00:19:19,450
signature so you take your header you

00:19:17,620 --> 00:19:20,680
take your payload run into a certain

00:19:19,450 --> 00:19:23,230
algorithm is going to create a signature

00:19:20,680 --> 00:19:24,610
and you're going to use a secret or a

00:19:23,230 --> 00:19:27,280
public and private key depending on the

00:19:24,610 --> 00:19:28,690
algorithm and you're going to paces in

00:19:27,280 --> 00:19:30,040
the end so you can verify that the

00:19:28,690 --> 00:19:31,630
content of your payload and your header

00:19:30,040 --> 00:19:34,870
has not been tampered with

00:19:31,630 --> 00:19:36,580
using that signature the next one

00:19:34,870 --> 00:19:38,560
Jason web encryption we've seen

00:19:36,580 --> 00:19:39,850
signatures we've seen please there's

00:19:38,560 --> 00:19:43,300
also something called JSON web

00:19:39,850 --> 00:19:44,550
encryption and instead of three parts it

00:19:43,300 --> 00:19:47,320
has five header

00:19:44,550 --> 00:19:50,940
encrypted key initialization vector

00:19:47,320 --> 00:19:53,770
ciphertext and authentication tag and

00:19:50,940 --> 00:19:56,500
it's good to know that JW is JSON web

00:19:53,770 --> 00:19:58,900
encryption thing is used to kind of

00:19:56,500 --> 00:20:00,850
encryption they use the content

00:19:58,900 --> 00:20:02,770
encryption key which is the second part

00:20:00,850 --> 00:20:04,540
we saw earlier it's usually encrypted

00:20:02,770 --> 00:20:06,520
with an asymmetric algorithm because

00:20:04,540 --> 00:20:09,100
it's usually a short piece it's just a

00:20:06,520 --> 00:20:12,430
key and content encryption key the

00:20:09,100 --> 00:20:14,410
second which is the second part and the

00:20:12,430 --> 00:20:16,840
cipher the actual message which we

00:20:14,410 --> 00:20:18,910
encrypt it with this jwe is encrypted

00:20:16,840 --> 00:20:22,600
using a symmetrical content encryption

00:20:18,910 --> 00:20:24,130
key the sec so it's ck sake no no you to

00:20:22,600 --> 00:20:26,200
pronounce it but that's something

00:20:24,130 --> 00:20:27,640
symmetrical because you sometimes want

00:20:26,200 --> 00:20:29,950
to encrypt a large piece of text or

00:20:27,640 --> 00:20:32,680
contents in a jwe so you need to do this

00:20:29,950 --> 00:20:36,260
symmetrically and that's the fourth part

00:20:32,680 --> 00:20:38,240
of your JW e so how does this work the

00:20:36,260 --> 00:20:39,950
first part Jason Heather the same thing

00:20:38,240 --> 00:20:43,160
you have an algorithm encoding and maybe

00:20:39,950 --> 00:20:45,110
a key ID the algorithm you use to

00:20:43,160 --> 00:20:47,510
decrypt the content encryption key which

00:20:45,110 --> 00:20:50,480
is in the jwe the encoding tells you

00:20:47,510 --> 00:20:53,360
which encoding can use that content

00:20:50,480 --> 00:20:54,920
question key and the D key ID often a

00:20:53,360 --> 00:20:56,360
reference to a public key available

00:20:54,920 --> 00:20:58,700
somewhere which you can use with the

00:20:56,360 --> 00:21:00,110
first algorithm so to the group to come

00:20:58,700 --> 00:21:01,880
to an encryption key the second part

00:21:00,110 --> 00:21:04,040
you're going to check in your header

00:21:01,880 --> 00:21:06,290
which algorithm do I need to use to

00:21:04,040 --> 00:21:07,730
decrypt this you're going to pass along

00:21:06,290 --> 00:21:09,770
your content encryption key which is the

00:21:07,730 --> 00:21:11,420
whole second part of that string and

00:21:09,770 --> 00:21:13,280
you're going to use the private key that

00:21:11,420 --> 00:21:15,250
you have available somewhere which is

00:21:13,280 --> 00:21:18,200
referenced as a key ID in your header

00:21:15,250 --> 00:21:20,300
and to decrypt the cipher you're going

00:21:18,200 --> 00:21:22,400
to check again and header which

00:21:20,300 --> 00:21:25,250
algorithm you need to use pass along the

00:21:22,400 --> 00:21:27,890
cipher the actual encrypted text in this

00:21:25,250 --> 00:21:29,690
chase and web encryption thingy pass

00:21:27,890 --> 00:21:31,130
along the content encryption key which

00:21:29,690 --> 00:21:33,320
is the thing we just decoded in a

00:21:31,130 --> 00:21:35,330
previous step and then some some

00:21:33,320 --> 00:21:37,070
algorithms require a initialization

00:21:35,330 --> 00:21:38,450
factor some don't so if you don't have

00:21:37,070 --> 00:21:41,030
one this will just be empty and empty

00:21:38,450 --> 00:21:43,670
string and lastly the authentication tag

00:21:41,030 --> 00:21:45,170
that's very basic what's happening you

00:21:43,670 --> 00:21:47,300
first decrypt the content and the

00:21:45,170 --> 00:21:48,080
content encryption key which is inside

00:21:47,300 --> 00:21:50,180
the jwe

00:21:48,080 --> 00:21:51,800
and then you use that key to decrypt the

00:21:50,180 --> 00:21:56,600
actual site for the actual content of

00:21:51,800 --> 00:21:58,910
your awwe both JSON web signatures and

00:21:56,600 --> 00:22:01,340
JSON web encryptions can be serialized

00:21:58,910 --> 00:22:03,080
as compact the ones we saw earlier the

00:22:01,340 --> 00:22:06,500
string with the dots in the middle or as

00:22:03,080 --> 00:22:09,530
jason this would be in AWS serialize

00:22:06,500 --> 00:22:11,030
says jason and this would be in JW eclss

00:22:09,530 --> 00:22:13,400
Jason and you might see that they have

00:22:11,030 --> 00:22:16,100
the same info div des cipher text attack

00:22:13,400 --> 00:22:18,110
the encryption key it's all in there but

00:22:16,100 --> 00:22:20,540
it's just a bit more readable even

00:22:18,110 --> 00:22:22,070
though the compact serialization is used

00:22:20,540 --> 00:22:25,300
more because you can just send it with

00:22:22,070 --> 00:22:25,300
requests it's it's smaller

00:22:25,700 --> 00:22:30,409
lastly JSON up token if you work with

00:22:28,250 --> 00:22:32,840
api's authentication you might use this

00:22:30,409 --> 00:22:35,830
you might have heard of this and a JSON

00:22:32,840 --> 00:22:38,240
web token is basically an AWS or a jwe

00:22:35,830 --> 00:22:41,809
table you yes is the more commonly used

00:22:38,240 --> 00:22:43,370
version of a JSON web token which if we

00:22:41,809 --> 00:22:45,139
would decode the header we would see

00:22:43,370 --> 00:22:47,480
something like the algorithm and now we

00:22:45,139 --> 00:22:49,190
just say that the type is JWT it's a

00:22:47,480 --> 00:22:51,230
token we're going to use it as an access

00:22:49,190 --> 00:22:53,690
token as an ID token as some kind of

00:22:51,230 --> 00:22:56,480
token with our API or whatever a use

00:22:53,690 --> 00:22:58,039
case here for those tokens so if you

00:22:56,480 --> 00:23:00,080
would decrypt the payload of this table

00:22:58,039 --> 00:23:01,519
to AWS and it would be an access token

00:23:00,080 --> 00:23:03,500
you might see something like this

00:23:01,519 --> 00:23:07,399
all data that's related to using it with

00:23:03,500 --> 00:23:09,409
an API audience scope issuer stuff like

00:23:07,399 --> 00:23:10,639
that if you would use it as an ID token

00:23:09,409 --> 00:23:12,260
it would contain a bit more information

00:23:10,639 --> 00:23:14,690
but the identity over the user that has

00:23:12,260 --> 00:23:16,340
been authenticated so you would see more

00:23:14,690 --> 00:23:18,200
data in the payload which is related to

00:23:16,340 --> 00:23:20,750
a user like a nickname or name or a

00:23:18,200 --> 00:23:22,970
picture stuff like this but it's all

00:23:20,750 --> 00:23:25,730
fella Jason can all be put in the

00:23:22,970 --> 00:23:27,500
payload and by using this signature we

00:23:25,730 --> 00:23:30,230
can still validate that nothing has been

00:23:27,500 --> 00:23:32,149
changed in the middle of whatever a

00:23:30,230 --> 00:23:34,190
natural process you had going on so that

00:23:32,149 --> 00:23:38,230
it's still a fella token nobody tried to

00:23:34,190 --> 00:23:39,340
tamper with it so just summarize

00:23:38,230 --> 00:23:41,049
compresses and makes it virtually

00:23:39,340 --> 00:23:43,059
impossible to get to the real data so

00:23:41,049 --> 00:23:45,280
for example if you want to store dates

00:23:43,059 --> 00:23:46,809
well if you want to store data securely

00:23:45,280 --> 00:23:49,240
like passwords are you going to use

00:23:46,809 --> 00:23:50,679
hashing for that kate hashes protect the

00:23:49,240 --> 00:23:52,179
integrity of the data because you need

00:23:50,679 --> 00:23:55,210
to know the secret you need to be know

00:23:52,179 --> 00:23:55,980
the key to get the same result over and

00:23:55,210 --> 00:23:58,240
over again

00:23:55,980 --> 00:24:00,280
didn't look technical signatures allow

00:23:58,240 --> 00:24:01,840
third parties to verify the validity and

00:24:00,280 --> 00:24:03,610
the origin of the data just because

00:24:01,840 --> 00:24:05,020
we're working with two keys a public key

00:24:03,610 --> 00:24:06,250
which we can share with everybody and

00:24:05,020 --> 00:24:09,549
the private key which we keep to herself

00:24:06,250 --> 00:24:11,110
we can share these signatures and people

00:24:09,549 --> 00:24:14,080
who have access to your public key can

00:24:11,110 --> 00:24:15,910
validate those signatures encryption

00:24:14,080 --> 00:24:18,910
allow us only authorized people to read

00:24:15,910 --> 00:24:20,740
the data because she needs it's the

00:24:18,910 --> 00:24:21,970
message gets encrypted with your public

00:24:20,740 --> 00:24:24,460
key I need your own private key to

00:24:21,970 --> 00:24:27,370
decrypt a message so only you can read

00:24:24,460 --> 00:24:28,990
the message and joses are some standards

00:24:27,370 --> 00:24:30,580
based on Chasen that help us with

00:24:28,990 --> 00:24:33,280
signatures and encryption on the web

00:24:30,580 --> 00:24:36,490
because jason and the web

00:24:33,280 --> 00:24:38,110
it's almost anonymous these days if you

00:24:36,490 --> 00:24:39,790
want to see see these slides again how

00:24:38,110 --> 00:24:42,850
is it not some bigger tech it'll be

00:24:39,790 --> 00:24:44,440
there for basically forever if you want

00:24:42,850 --> 00:24:46,030
to learn more about JSON web tokens we

00:24:44,440 --> 00:24:47,380
have this little website called JWT load

00:24:46,030 --> 00:24:49,919
io which contains a bunch of information

00:24:47,380 --> 00:24:52,240
a debugger some library stuff like this

00:24:49,919 --> 00:24:54,820
with a bunch of blog posts on our blog

00:24:52,240 --> 00:24:56,710
as well about anything authentication or

00:24:54,820 --> 00:25:00,570
encryption and a lot of different topics

00:24:56,710 --> 00:25:07,280
as well that being said thank you

00:25:00,570 --> 00:25:07,280

YouTube URL: https://www.youtube.com/watch?v=cZ7lRxr_yzE


