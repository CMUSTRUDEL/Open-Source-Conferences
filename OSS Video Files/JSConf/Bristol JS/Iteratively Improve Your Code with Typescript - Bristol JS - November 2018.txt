Title: Iteratively Improve Your Code with Typescript - Bristol JS - November 2018
Publication date: 2018-12-11
Playlist: Bristol JS
Description: 
	Presented by Pete West.

TypeScript is a language that extends JavaScript to support static typing.
It complements the open, malleable design principles of JavaScript, while catching bugs and improving code understandability.
In this talk, you'll learn how to use TypeScript in your existing project and how you can iteratively improve your code with stronger typing.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:06,509
hi there I'm Pete I'm at Peter J West on

00:00:03,090 --> 00:00:09,769
Twitter I'm going to be kind of doing a

00:00:06,509 --> 00:00:12,570
sort of intro talk to typescript so

00:00:09,769 --> 00:00:13,920
aimed at people who maybe you've just

00:00:12,570 --> 00:00:16,410
heard of it or never heard of it or

00:00:13,920 --> 00:00:18,480
maybe just started with it if you know

00:00:16,410 --> 00:00:20,520
type script quite well you probably be

00:00:18,480 --> 00:00:22,740
quite bored but maybe you can give me

00:00:20,520 --> 00:00:25,070
some like pointers afterwards about

00:00:22,740 --> 00:00:27,599
things I got wrong anything I can prove

00:00:25,070 --> 00:00:30,929
so what I'm going to do is go through

00:00:27,599 --> 00:00:35,370
some of the theoretical basics of

00:00:30,929 --> 00:00:37,460
typescript and then go through practical

00:00:35,370 --> 00:00:39,899
steps you can do to you can do to get

00:00:37,460 --> 00:00:42,000
typescript running on your existing

00:00:39,899 --> 00:00:47,280
projects because well it's quite nice to

00:00:42,000 --> 00:00:49,050
have this on kind of your new projects I

00:00:47,280 --> 00:00:51,870
think the most use will come from being

00:00:49,050 --> 00:00:54,570
able to sort of put it into existing

00:00:51,870 --> 00:00:57,059
projects and there'll be some kind of

00:00:54,570 --> 00:00:58,320
like gotchas along the way there's quite

00:00:57,059 --> 00:01:01,949
a lot of things that aren't really very

00:00:58,320 --> 00:01:02,940
well documented a sort of legacy so

00:01:01,949 --> 00:01:06,240
we're kind of try and catch some of

00:01:02,940 --> 00:01:09,060
those on the way so what is typescript

00:01:06,240 --> 00:01:12,390
it it's kind of in the name it adds

00:01:09,060 --> 00:01:16,500
strong typing to JavaScript and it

00:01:12,390 --> 00:01:18,810
compiles to JavaScript it's I like to

00:01:16,500 --> 00:01:20,310
say it complements the sort of open and

00:01:18,810 --> 00:01:23,790
malleable design principles of

00:01:20,310 --> 00:01:24,930
JavaScript so it lets you do a lot yeah

00:01:23,790 --> 00:01:27,030
by letting you do whatever the hell you

00:01:24,930 --> 00:01:29,340
want it lets you do a lot but you can

00:01:27,030 --> 00:01:33,390
also kind of screw things up by abusing

00:01:29,340 --> 00:01:36,689
it it's got a pretty steep learning

00:01:33,390 --> 00:01:39,119
curve I'd say it takes a couple of

00:01:36,689 --> 00:01:41,460
months of using it to really get to

00:01:39,119 --> 00:01:44,670
grips with all of the the things you'll

00:01:41,460 --> 00:01:46,470
need to be able to do but once you get

00:01:44,670 --> 00:01:49,439
there you get quite a lot of benefits to

00:01:46,470 --> 00:01:53,549
your code quality and preventing bugs

00:01:49,439 --> 00:01:55,979
and things so the other thing about it

00:01:53,549 --> 00:01:57,869
is it has no effect to your JavaScript

00:01:55,979 --> 00:02:00,899
if you convert your project from

00:01:57,869 --> 00:02:03,570
JavaScript to typescript the code you

00:02:00,899 --> 00:02:04,950
have online will be nearly if not

00:02:03,570 --> 00:02:08,910
entirely identical there's really

00:02:04,950 --> 00:02:10,979
nothing left once it's compiled so the

00:02:08,910 --> 00:02:12,480
compiler basically checks that your

00:02:10,979 --> 00:02:13,210
types make sense that all your code

00:02:12,480 --> 00:02:14,860
works

00:02:13,210 --> 00:02:16,270
and then it just removes all of

00:02:14,860 --> 00:02:22,210
typescript that's the compilation

00:02:16,270 --> 00:02:25,330
process is deleting typescript so why

00:02:22,210 --> 00:02:28,030
would you care we've been using no types

00:02:25,330 --> 00:02:29,410
or no dynamic you know loose typing in

00:02:28,030 --> 00:02:30,690
JavaScript for years and everything's

00:02:29,410 --> 00:02:34,600
fine

00:02:30,690 --> 00:02:37,570
so yeah improves your robustness kind of

00:02:34,600 --> 00:02:40,450
gets rid of stops bugs before they

00:02:37,570 --> 00:02:42,580
happen if you've got a nice editor

00:02:40,450 --> 00:02:46,180
they'll show up in the editor before you

00:02:42,580 --> 00:02:47,530
even save the file it's kind of you can

00:02:46,180 --> 00:02:48,750
think of the types as being the kind of

00:02:47,530 --> 00:02:51,910
the glue between your different

00:02:48,750 --> 00:02:53,800
components so it'll short ensure some

00:02:51,910 --> 00:02:57,580
kind of interpret integrity between them

00:02:53,800 --> 00:03:00,310
all the other thing is it kind of self

00:02:57,580 --> 00:03:02,740
does a bit of self documentation if

00:03:00,310 --> 00:03:05,470
anyone's ever used like dock blocks or

00:03:02,740 --> 00:03:08,110
been forced to use them basically if you

00:03:05,470 --> 00:03:10,480
write a dot block and then turn away and

00:03:08,110 --> 00:03:11,980
turn back it will be out of date because

00:03:10,480 --> 00:03:16,050
there's just no incentive to keep things

00:03:11,980 --> 00:03:18,220
in date to keep things synchronized

00:03:16,050 --> 00:03:18,940
unless you've got tools to do that as

00:03:18,220 --> 00:03:20,110
well

00:03:18,940 --> 00:03:22,180
but it's basically means you can't

00:03:20,110 --> 00:03:24,520
compile your code unless the types are

00:03:22,180 --> 00:03:26,020
up-to-date and the other thing I found

00:03:24,520 --> 00:03:27,490
which is quite interesting is it really

00:03:26,020 --> 00:03:30,540
improves your understanding of the

00:03:27,490 --> 00:03:33,400
language as you write so you end up

00:03:30,540 --> 00:03:35,440
knowing more about the thing the code

00:03:33,400 --> 00:03:37,870
you're writing whereas before I'd be

00:03:35,440 --> 00:03:39,370
quite fuzzy on exactly what a function

00:03:37,870 --> 00:03:41,380
was doing and what it was returning now

00:03:39,370 --> 00:03:46,780
I have to know because I have to know in

00:03:41,380 --> 00:03:51,850
order to write the types so taking a

00:03:46,780 --> 00:03:55,060
basic example in JavaScript so this is a

00:03:51,850 --> 00:03:57,790
thing that takes a array of strings and

00:03:55,060 --> 00:04:00,790
basically just counts all of the music

00:03:57,790 --> 00:04:02,650
it's not a great function but it's

00:04:00,790 --> 00:04:03,940
taking array of strings and counting all

00:04:02,650 --> 00:04:06,550
the letters in all the strings and

00:04:03,940 --> 00:04:08,740
adding them all up and in JavaScript

00:04:06,550 --> 00:04:10,420
we've got some hints as to what these

00:04:08,740 --> 00:04:11,920
things are if I didn't explain that to

00:04:10,420 --> 00:04:14,560
you you'd look at this and go okay well

00:04:11,920 --> 00:04:16,359
words is used in a for loop so it must

00:04:14,560 --> 00:04:18,400
be some kind of iterable thing and we're

00:04:16,359 --> 00:04:20,230
checking the length property of it so it

00:04:18,400 --> 00:04:24,220
must be something with a length property

00:04:20,230 --> 00:04:27,940
so probably a string or another list

00:04:24,220 --> 00:04:31,240
and we know that that's going to return

00:04:27,940 --> 00:04:35,530
in the number so moving on the

00:04:31,240 --> 00:04:36,850
typescript example of this is that so

00:04:35,530 --> 00:04:42,790
the only thing that's changed is we've

00:04:36,850 --> 00:04:45,790
added we've added the colon string

00:04:42,790 --> 00:04:48,010
square brackets so what this does is

00:04:45,790 --> 00:04:49,600
just told told typescript the type of

00:04:48,010 --> 00:04:53,470
that argument is going to be an array of

00:04:49,600 --> 00:04:55,210
strings everything else about this

00:04:53,470 --> 00:04:58,450
function so this function is now fully

00:04:55,210 --> 00:05:00,430
specified in typescript everything else

00:04:58,450 --> 00:05:03,370
all the other variables typescript has

00:05:00,430 --> 00:05:06,820
inferred and type inference is kind of a

00:05:03,370 --> 00:05:11,080
big deal in typescript it's a fairly big

00:05:06,820 --> 00:05:14,680
part of the language and why it's good

00:05:11,080 --> 00:05:18,040
so typescript knows this count needs to

00:05:14,680 --> 00:05:21,130
be a number because it's you've set it

00:05:18,040 --> 00:05:23,020
to zero it knows that word is a string

00:05:21,130 --> 00:05:25,650
because words is an array of strings it

00:05:23,020 --> 00:05:27,940
knows that length is a number because

00:05:25,650 --> 00:05:29,380
strings have a property called length

00:05:27,940 --> 00:05:31,360
which is a number and it knows the

00:05:29,380 --> 00:05:34,960
return type is number so all of this is

00:05:31,360 --> 00:05:36,669
inferred if we didn't want to rely on

00:05:34,960 --> 00:05:39,880
that inference if we wanted to be more

00:05:36,669 --> 00:05:42,340
explicit you can oh yeah sorry missed a

00:05:39,880 --> 00:05:45,430
bit if you've got an editor like vs code

00:05:42,340 --> 00:05:46,780
you can hover over count letters and you

00:05:45,430 --> 00:05:48,490
will get the complete type of the

00:05:46,780 --> 00:05:50,760
function so you can see typed if it

00:05:48,490 --> 00:05:52,750
knows that the return type is a number

00:05:50,760 --> 00:05:55,240
but yeah if we didn't want to rely on

00:05:52,750 --> 00:05:58,210
that inference we can set specify the

00:05:55,240 --> 00:06:01,360
return type here after the arguments and

00:05:58,210 --> 00:06:03,910
we can specify the type of the count

00:06:01,360 --> 00:06:05,710
variable as well so there's kind of two

00:06:03,910 --> 00:06:08,980
approaches you can you can go with the

00:06:05,710 --> 00:06:12,610
minimal or the maximal and that's kind

00:06:08,980 --> 00:06:14,980
of bringing me to should you use it I

00:06:12,610 --> 00:06:18,490
don't think there is an obvious answer

00:06:14,980 --> 00:06:21,400
it's in certain strongly typed languages

00:06:18,490 --> 00:06:24,820
it's kind of a hotly debated question of

00:06:21,400 --> 00:06:28,780
how much type inference is good so yeah

00:06:24,820 --> 00:06:33,850
it makes your code easier to write bit

00:06:28,780 --> 00:06:38,050
shorter maybe a bit less explicit and if

00:06:33,850 --> 00:06:39,520
you're using sort of this method then it

00:06:38,050 --> 00:06:41,710
maybe may have a bit of a reliance on

00:06:39,520 --> 00:06:45,039
your on your IDE on your editor to show

00:06:41,710 --> 00:06:48,370
you the inferred value if you want to

00:06:45,039 --> 00:06:51,610
know that personally I think it's really

00:06:48,370 --> 00:06:54,550
nice my entire team use vs code so we've

00:06:51,610 --> 00:06:56,020
all got the typescript plug in so we we

00:06:54,550 --> 00:07:01,090
don't really mind having stuff being

00:06:56,020 --> 00:07:04,270
implicit and kind of getting it from the

00:07:01,090 --> 00:07:09,970
editor but I don't think this is there's

00:07:04,270 --> 00:07:13,360
a there is ik one answer to this okay so

00:07:09,970 --> 00:07:16,750
we move on to some primitive types now

00:07:13,360 --> 00:07:18,159
they're all pretty obvious yeah you've

00:07:16,750 --> 00:07:22,240
got numbers strings brilliance null

00:07:18,159 --> 00:07:24,370
undefined as I saw in the as we saw in

00:07:22,240 --> 00:07:26,650
the previous example all of these are

00:07:24,370 --> 00:07:28,120
strictly redundant so if you didn't put

00:07:26,650 --> 00:07:30,460
any of these in typescript would guess

00:07:28,120 --> 00:07:32,229
the type if you give it a number it'll

00:07:30,460 --> 00:07:33,190
guess the type is number if you give it

00:07:32,229 --> 00:07:35,740
boolean you'll guess the types of

00:07:33,190 --> 00:07:36,849
brilliant yeah these were pretty

00:07:35,740 --> 00:07:41,370
straightforward

00:07:36,849 --> 00:07:44,349
then we've got object types so arrays

00:07:41,370 --> 00:07:45,639
we're also in the previous example so if

00:07:44,349 --> 00:07:48,069
you want an array of something you put

00:07:45,639 --> 00:07:51,130
square brackets after it and that's the

00:07:48,069 --> 00:07:53,770
type as an array type script kind of

00:07:51,130 --> 00:07:55,659
expects all arrayed arrays to have all

00:07:53,770 --> 00:07:59,770
the same type within them although you

00:07:55,659 --> 00:08:02,710
can get around that but with this syntax

00:07:59,770 --> 00:08:05,259
it kind of expects there to be an array

00:08:02,710 --> 00:08:07,210
of one particular type of thing

00:08:05,259 --> 00:08:10,960
typescript has a bit of a different

00:08:07,210 --> 00:08:13,000
approach to JavaScript for objects so in

00:08:10,960 --> 00:08:16,539
JavaScript objects are whatever you want

00:08:13,000 --> 00:08:18,250
them to be adds you know random

00:08:16,539 --> 00:08:19,569
properties at any point you want you

00:08:18,250 --> 00:08:21,219
know you could make a class and

00:08:19,569 --> 00:08:23,710
instantiate it in an add a property to

00:08:21,219 --> 00:08:26,770
it but in typescript it expects you to

00:08:23,710 --> 00:08:29,139
either use objects in kind of Clark

00:08:26,770 --> 00:08:30,969
object instance mode where they have

00:08:29,139 --> 00:08:32,709
specified property so in this case we've

00:08:30,969 --> 00:08:36,610
got a and B specified as a number in a

00:08:32,709 --> 00:08:39,909
string or have it in dictionary mode if

00:08:36,610 --> 00:08:41,529
anyone's a term from Python which is

00:08:39,909 --> 00:08:43,779
basically you can have any number of

00:08:41,529 --> 00:08:45,820
values and keys in this but it will have

00:08:43,779 --> 00:08:48,339
to have the same value which in this

00:08:45,820 --> 00:08:50,340
case is a number so we can have ABC in

00:08:48,339 --> 00:08:52,500
that one so

00:08:50,340 --> 00:08:54,240
it's a bit of a limitation you can

00:08:52,500 --> 00:08:55,740
technically combine these two but in

00:08:54,240 --> 00:08:57,630
general I find it works best to kind of

00:08:55,740 --> 00:08:59,880
have an object which is a dictionary

00:08:57,630 --> 00:09:02,130
where you put anything into it or an

00:08:59,880 --> 00:09:04,170
object which is more like an instance

00:09:02,130 --> 00:09:07,310
where you know exactly what the keys are

00:09:04,170 --> 00:09:07,310
and they don't ever change

00:09:07,520 --> 00:09:11,010
evil types so this is a bit of a initial

00:09:10,440 --> 00:09:13,860
gotcha

00:09:11,010 --> 00:09:15,630
for typescript there Doc's generally

00:09:13,860 --> 00:09:18,930
don't tell you about these so don't use

00:09:15,630 --> 00:09:24,000
any of these number string boolean are

00:09:18,930 --> 00:09:26,790
all referring to the the type the

00:09:24,000 --> 00:09:30,810
primitive constructors you can use so if

00:09:26,790 --> 00:09:32,790
you use new boolean you will get a

00:09:30,810 --> 00:09:35,610
boolean object which is not a boolean

00:09:32,790 --> 00:09:37,410
and so if you did new boolean with false

00:09:35,610 --> 00:09:43,470
as an argument you will get a boolean

00:09:37,410 --> 00:09:45,240
object which is true so basically just

00:09:43,470 --> 00:09:47,130
lower case these and you'll be fine and

00:09:45,240 --> 00:09:51,210
don't don't ever do new burley and new

00:09:47,130 --> 00:09:53,970
string that's not the way to do it with

00:09:51,210 --> 00:09:56,550
object and function as as sort of

00:09:53,970 --> 00:09:59,190
keyword types object basically just

00:09:56,550 --> 00:10:01,530
means this is the type of something that

00:09:59,190 --> 00:10:04,140
inherits from object it's it basically

00:10:01,530 --> 00:10:05,670
is not telling typescript anything

00:10:04,140 --> 00:10:06,990
useful about it other than it's an

00:10:05,670 --> 00:10:09,510
object and it's the same with function

00:10:06,990 --> 00:10:11,210
so in all these cases you would be

00:10:09,510 --> 00:10:13,190
better off just removing the type

00:10:11,210 --> 00:10:20,839
definition and you would get a more

00:10:13,190 --> 00:10:25,970
accurate type so okay so typescript adds

00:10:20,839 --> 00:10:29,820
two new statements you can use to

00:10:25,970 --> 00:10:32,880
specify more complex types it's adding

00:10:29,820 --> 00:10:34,620
interface so interface works a bit like

00:10:32,880 --> 00:10:37,670
a class definition so if you're using

00:10:34,620 --> 00:10:42,810
es6 classes this will be quite familiar

00:10:37,670 --> 00:10:44,430
so you specify your interface name you

00:10:42,810 --> 00:10:48,060
specify any properties and methods you

00:10:44,430 --> 00:10:48,870
want on it and you can then spread use

00:10:48,060 --> 00:10:52,670
this foo

00:10:48,870 --> 00:10:55,589
keywords as a type anywhere you want

00:10:52,670 --> 00:10:57,660
there's also the type statement which is

00:10:55,589 --> 00:10:59,760
so this one's a bit like classes this

00:10:57,660 --> 00:11:05,269
one's a bit like conventional code so

00:10:59,760 --> 00:11:07,230
you just say bar equals some other type

00:11:05,269 --> 00:11:12,600
so in this case we've basically just

00:11:07,230 --> 00:11:16,019
named this type as bar and it's a bit of

00:11:12,600 --> 00:11:18,180
a fake out because both of these types

00:11:16,019 --> 00:11:21,810
we've created foo and bar are both

00:11:18,180 --> 00:11:23,339
interfaces and types it's just a sort of

00:11:21,810 --> 00:11:26,130
syntactic difference at this at this

00:11:23,339 --> 00:11:28,230
point because they're both any type

00:11:26,130 --> 00:11:30,540
which is for an object is an interface

00:11:28,230 --> 00:11:32,250
as well so these are equivalent you

00:11:30,540 --> 00:11:34,500
could use either of them to do two you

00:11:32,250 --> 00:11:39,180
could swap the syntax around on these

00:11:34,500 --> 00:11:41,760
and it would work fine so with

00:11:39,180 --> 00:11:43,470
interfaces you can extend them like

00:11:41,760 --> 00:11:46,260
classes so if I have a base interface

00:11:43,470 --> 00:11:50,640
which has a property I can use make

00:11:46,260 --> 00:11:53,339
another one and then extend it and the

00:11:50,640 --> 00:11:57,029
child interface will contain both of

00:11:53,339 --> 00:11:59,070
them and then what we can do with this

00:11:57,029 --> 00:12:03,089
is we can say one of the things we can

00:11:59,070 --> 00:12:04,410
do is take that child interface and put

00:12:03,089 --> 00:12:07,790
it at the end of a class definition

00:12:04,410 --> 00:12:09,660
saying it implements this type

00:12:07,790 --> 00:12:12,690
implements this interface which means

00:12:09,660 --> 00:12:18,329
your your class will be required to have

00:12:12,690 --> 00:12:22,350
all the things specified in here type

00:12:18,329 --> 00:12:25,529
statements so yeah define it a bit like

00:12:22,350 --> 00:12:27,360
just assignment there you can also do

00:12:25,529 --> 00:12:29,070
this - alias type so we can have a child

00:12:27,360 --> 00:12:32,570
equals base if we just wanted to rename

00:12:29,070 --> 00:12:32,570
a type to use it in a different place

00:12:33,410 --> 00:12:41,880
okay one other thing is with types you

00:12:38,010 --> 00:12:45,480
can you can export them and import them

00:12:41,880 --> 00:12:48,630
like you would with anything else but

00:12:45,480 --> 00:12:50,810
they they do share the same namespace as

00:12:48,630 --> 00:12:54,240
all of you are they exports and imports

00:12:50,810 --> 00:12:56,430
some people do like I before all of

00:12:54,240 --> 00:12:57,810
their interface all of their types to

00:12:56,430 --> 00:13:02,550
sort of distinguish them so they're in a

00:12:57,810 --> 00:13:04,769
separate namespace so we can do some

00:13:02,550 --> 00:13:08,760
more cool stuff with combining types so

00:13:04,769 --> 00:13:10,949
unions so pipe operator gives us a union

00:13:08,760 --> 00:13:13,589
which basically means either this all

00:13:10,949 --> 00:13:15,750
that so in this case we've got a

00:13:13,589 --> 00:13:17,820
character list which we're defining as a

00:13:15,750 --> 00:13:20,880
number ray of numbers or

00:13:17,820 --> 00:13:25,140
a string yeah string is basically an

00:13:20,880 --> 00:13:29,330
array of numbers in a sense and so as an

00:13:25,140 --> 00:13:31,530
example I could make a thing is a

00:13:29,330 --> 00:13:33,570
truncate function which is going to sort

00:13:31,530 --> 00:13:35,190
of shorten something and I can set tests

00:13:33,570 --> 00:13:40,110
tell it to take character list as an

00:13:35,190 --> 00:13:42,210
input and you can see that typescript is

00:13:40,110 --> 00:13:44,540
kind of in my editor is already showing

00:13:42,210 --> 00:13:47,250
me an error here because it knows that

00:13:44,540 --> 00:13:50,580
although which one is it

00:13:47,250 --> 00:13:51,660
string has the method substr number and

00:13:50,580 --> 00:13:53,190
array of numbers doesn't have that

00:13:51,660 --> 00:13:55,470
method to see you so this isn't this

00:13:53,190 --> 00:13:57,180
isn't good right now so we can change

00:13:55,470 --> 00:13:58,890
that to slice because we know that

00:13:57,180 --> 00:14:03,420
arrays and strings have both got the

00:13:58,890 --> 00:14:05,990
slice method so now it's all good but

00:14:03,420 --> 00:14:09,240
there's a bit more of a like a problem

00:14:05,990 --> 00:14:10,740
is if we can't if we can't easily do

00:14:09,240 --> 00:14:13,980
this we need to be able to discriminate

00:14:10,740 --> 00:14:16,110
between the two types so this is called

00:14:13,980 --> 00:14:17,610
decomposing unions so if we have

00:14:16,110 --> 00:14:22,920
something which is a string or a number

00:14:17,610 --> 00:14:25,350
we need to be able to know two special

00:14:22,920 --> 00:14:27,210
case that into strings and into numbers

00:14:25,350 --> 00:14:28,710
so that we can treat them differently so

00:14:27,210 --> 00:14:30,240
if we want to take more than one type

00:14:28,710 --> 00:14:32,310
into a function we need to be able to

00:14:30,240 --> 00:14:33,900
break them down afterwards and that's

00:14:32,310 --> 00:14:36,390
where typescript really works nicely

00:14:33,900 --> 00:14:38,910
with JavaScript so what it's doing here

00:14:36,390 --> 00:14:41,370
is typescript knows about the typeof

00:14:38,910 --> 00:14:43,710
operator so it knows that if you do type

00:14:41,370 --> 00:14:46,500
or value equals equals number in a if

00:14:43,710 --> 00:14:50,010
block then anything inside this the

00:14:46,500 --> 00:14:51,510
value inside this must be a number it

00:14:50,010 --> 00:14:54,600
also knows that because the if block

00:14:51,510 --> 00:14:57,090
returns the return value here must be a

00:14:54,600 --> 00:14:58,680
string so if we were to I haven't got a

00:14:57,090 --> 00:15:03,060
slide for it but if we were to hover

00:14:58,680 --> 00:15:05,130
over format data it would know that form

00:15:03,060 --> 00:15:06,780
our data returns a string because to fix

00:15:05,130 --> 00:15:09,120
returns a string and the value here is

00:15:06,780 --> 00:15:11,160
definitely a string so this is where the

00:15:09,120 --> 00:15:13,920
some inference stuff gets kind of clever

00:15:11,160 --> 00:15:15,510
and yet type so it's got lots of nice

00:15:13,920 --> 00:15:19,800
things where it integrates well with the

00:15:15,510 --> 00:15:21,090
language to figure out stuff so

00:15:19,800 --> 00:15:22,890
intersections these are kind of a

00:15:21,090 --> 00:15:25,710
compliment to unions so this is an

00:15:22,890 --> 00:15:30,630
instead of all basically just lets you

00:15:25,710 --> 00:15:31,790
combine two two types so this is

00:15:30,630 --> 00:15:34,740
equivalent

00:15:31,790 --> 00:15:36,480
yeah this is equivalent to our

00:15:34,740 --> 00:15:38,670
inheritance we can do multiple

00:15:36,480 --> 00:15:42,540
inheritance in typescript I just sort of

00:15:38,670 --> 00:15:46,020
inherits them in order so we can kind of

00:15:42,540 --> 00:15:47,820
combine stuff together in either in

00:15:46,020 --> 00:15:50,010
either way and again both of these are

00:15:47,820 --> 00:15:53,780
still interfaces so you could use them

00:15:50,010 --> 00:15:58,560
in any way you'd use interfaces

00:15:53,780 --> 00:16:01,260
optionals so in JavaScript it gets a bit

00:15:58,560 --> 00:16:02,610
kind of vague with function arguments

00:16:01,260 --> 00:16:03,930
you sort of define a whole bunch of them

00:16:02,610 --> 00:16:06,210
and then use some of them some of the

00:16:03,930 --> 00:16:11,220
time in typescript it gets a bit upset

00:16:06,210 --> 00:16:13,740
if you use like more or less than a

00:16:11,220 --> 00:16:15,570
specified so if you do want to have ones

00:16:13,740 --> 00:16:17,910
that you're not going to always add in

00:16:15,570 --> 00:16:22,320
you'll need to use optional so that's a

00:16:17,910 --> 00:16:25,560
question mark there and that just means

00:16:22,320 --> 00:16:28,250
that you may not specify that so it also

00:16:25,560 --> 00:16:33,720
means that the the type is implicitly

00:16:28,250 --> 00:16:35,220
whatever type it is or undefined so it's

00:16:33,720 --> 00:16:38,490
kind of nice in that adds it directly

00:16:35,220 --> 00:16:41,240
into a into the type so we now know this

00:16:38,490 --> 00:16:43,770
function may or may not take the end

00:16:41,240 --> 00:16:46,050
argument and the dog may or may not

00:16:43,770 --> 00:16:47,940
contain a bone

00:16:46,050 --> 00:16:52,550
hopefully the dog contains some bones

00:16:47,940 --> 00:16:56,250
but hold a bone yeah

00:16:52,550 --> 00:16:58,010
so yeah this would be undefined which

00:16:56,250 --> 00:17:02,360
kind of brings us to null and undefined

00:16:58,010 --> 00:17:05,370
so if we look at the the dog bone

00:17:02,360 --> 00:17:06,689
example if we had a dog object that has

00:17:05,370 --> 00:17:09,900
it has a name because you have to name

00:17:06,689 --> 00:17:11,970
your dog but then the bone it may not

00:17:09,900 --> 00:17:16,770
exist so if you haven't set that key

00:17:11,970 --> 00:17:19,260
it's already going to be undefined so

00:17:16,770 --> 00:17:24,720
it's actually a lot more convenient in

00:17:19,260 --> 00:17:26,699
typescript to use undefined over null

00:17:24,720 --> 00:17:28,710
because you see you'll see under finds

00:17:26,699 --> 00:17:31,380
all the time and whereas in JavaScript

00:17:28,710 --> 00:17:32,790
you can be quite like wishy-washy over

00:17:31,380 --> 00:17:36,270
it like it's a null or undefined who

00:17:32,790 --> 00:17:38,400
cares in typescript it becomes starts to

00:17:36,270 --> 00:17:40,350
become like a real hassle to try and

00:17:38,400 --> 00:17:41,700
like manage all your nas and defines and

00:17:40,350 --> 00:17:45,390
if you just use undefined it's kind of

00:17:41,700 --> 00:17:49,080
easier ca occurs in personal training

00:17:45,390 --> 00:17:52,500
it returns unset properties and optional

00:17:49,080 --> 00:17:53,670
arguments so it kind of is natural if he

00:17:52,500 --> 00:17:55,500
did still want to use null it's

00:17:53,670 --> 00:17:59,130
completely fine you just have to put all

00:17:55,500 --> 00:18:00,950
null in a lot more places and yeah it

00:17:59,130 --> 00:18:03,990
works as normal

00:18:00,950 --> 00:18:07,980
okay so generics yeah if people know

00:18:03,990 --> 00:18:09,450
types already generics are kind of an

00:18:07,980 --> 00:18:12,360
obvious thing if you don't then they're

00:18:09,450 --> 00:18:13,890
kind of confusing so basically what

00:18:12,360 --> 00:18:19,170
we've done so far is stuff to do is like

00:18:13,890 --> 00:18:20,700
basic primitive types which is generally

00:18:19,170 --> 00:18:23,010
works quite well but when you come to

00:18:20,700 --> 00:18:24,870
work with utility functions you want to

00:18:23,010 --> 00:18:27,060
use in multiple places on multiple

00:18:24,870 --> 00:18:30,450
different things you start having to

00:18:27,060 --> 00:18:32,630
like rewrite them multiple times to to

00:18:30,450 --> 00:18:35,310
get the to have all the different types

00:18:32,630 --> 00:18:37,980
generics are a way to kind of say well

00:18:35,310 --> 00:18:38,190
this utility function can take an array

00:18:37,980 --> 00:18:40,260
of

00:18:38,190 --> 00:18:48,510
anything but it's still an array of

00:18:40,260 --> 00:18:53,510
something typed so if we have a cat we

00:18:48,510 --> 00:18:57,780
can specify cats to be an array of cat

00:18:53,510 --> 00:18:59,130
we had this before we've capped angle

00:18:57,780 --> 00:19:01,680
brackets this is the kind of a syntax

00:18:59,130 --> 00:19:03,960
syntactic sugar for arrays but in

00:19:01,680 --> 00:19:06,570
general array itself is a generic type

00:19:03,960 --> 00:19:08,220
that takes another type that goes inside

00:19:06,570 --> 00:19:09,930
it so you're giving of generic types are

00:19:08,220 --> 00:19:16,050
sort of specifying what's going in

00:19:09,930 --> 00:19:17,520
inside the thing oh yeah we've also got

00:19:16,050 --> 00:19:22,410
a promise so if anyone's using promises

00:19:17,520 --> 00:19:24,390
a promise is a type which you have to

00:19:22,410 --> 00:19:25,650
specify the return type so the value

00:19:24,390 --> 00:19:27,780
that's going to be resolved in that

00:19:25,650 --> 00:19:29,970
promise so promise not resolve true

00:19:27,780 --> 00:19:33,300
we're expecting to get a boolean back

00:19:29,970 --> 00:19:34,560
this is pretty like key if you do want

00:19:33,300 --> 00:19:38,610
to actually use promises and have

00:19:34,560 --> 00:19:41,370
typescript with promises as well so

00:19:38,610 --> 00:19:44,940
generic function may be hopefully a

00:19:41,370 --> 00:19:47,130
slightly easier example if you have a

00:19:44,940 --> 00:19:50,880
function filter value it's going to

00:19:47,130 --> 00:19:53,820
filter and keep only the values in an

00:19:50,880 --> 00:19:56,940
array which match a value you provide it

00:19:53,820 --> 00:19:58,140
not terribly useful but this could

00:19:56,940 --> 00:19:58,540
easily be turned into something a bit

00:19:58,140 --> 00:20:02,710
more you

00:19:58,540 --> 00:20:05,620
for what we do is we specify in angle

00:20:02,710 --> 00:20:09,090
brackets before the arguments one or

00:20:05,620 --> 00:20:11,680
more generic types are now so type is

00:20:09,090 --> 00:20:13,510
kind of like a function argument it

00:20:11,680 --> 00:20:15,490
doesn't exist anywhere yet it's just

00:20:13,510 --> 00:20:17,350
we've named it that because it's a

00:20:15,490 --> 00:20:19,840
convenient way to name it and then we're

00:20:17,350 --> 00:20:22,470
saying our array must be that type but

00:20:19,840 --> 00:20:29,230
an array and our value must be that type

00:20:22,470 --> 00:20:32,230
and then if we you call this function we

00:20:29,230 --> 00:20:33,130
then provide that generic type which

00:20:32,230 --> 00:20:35,050
we're going to say is going to be a

00:20:33,130 --> 00:20:37,510
number and now type scripts is going to

00:20:35,050 --> 00:20:39,310
check that the arguments match the

00:20:37,510 --> 00:20:41,560
generic type so it's just kind of like

00:20:39,310 --> 00:20:44,230
checking everything out and we don't

00:20:41,560 --> 00:20:46,390
even need to put in the generic type

00:20:44,230 --> 00:20:47,890
because type scripts are sort of smart

00:20:46,390 --> 00:20:51,570
enough to look through the arguments

00:20:47,890 --> 00:20:54,130
that have been provided and tell you if

00:20:51,570 --> 00:20:56,530
if they're going to make sense basically

00:20:54,130 --> 00:20:58,810
so at this point now typescript knows

00:20:56,530 --> 00:21:00,880
that the return value is going to be an

00:20:58,810 --> 00:21:06,130
array of strings here an array of

00:21:00,880 --> 00:21:09,850
numbers here Oh yep so that was probably

00:21:06,130 --> 00:21:12,580
the most complicated part of typescript

00:21:09,850 --> 00:21:14,230
I'm going to go through these bits do

00:21:12,580 --> 00:21:17,650
get a bit more involved some some of the

00:21:14,230 --> 00:21:20,460
stuff is a bit crazy but it general it

00:21:17,650 --> 00:21:25,060
doesn't get much more complex than that

00:21:20,460 --> 00:21:27,100
so typescript doesn't you don't just

00:21:25,060 --> 00:21:30,160
have to work with typescript modules so

00:21:27,100 --> 00:21:33,870
you can import JavaScript modules the

00:21:30,160 --> 00:21:36,790
fallback the problem with this is that

00:21:33,870 --> 00:21:38,650
your JavaScript modules don't have types

00:21:36,790 --> 00:21:40,420
or don't typescript can't necessarily

00:21:38,650 --> 00:21:43,780
tell everything you need to do about

00:21:40,420 --> 00:21:46,240
them so someone's come up with a way of

00:21:43,780 --> 00:21:50,710
kind of adding types into your modules

00:21:46,240 --> 00:21:52,990
like this so this is at types library so

00:21:50,710 --> 00:21:54,610
if you want to install a library so

00:21:52,990 --> 00:21:57,910
we've got the bluebird promise library

00:21:54,610 --> 00:22:00,100
then if we also install at type slash

00:21:57,910 --> 00:22:01,660
bluebird you'll get type definitions

00:22:00,100 --> 00:22:03,760
along with it and what that means is

00:22:01,660 --> 00:22:05,890
that typescript will know what what the

00:22:03,760 --> 00:22:08,110
hell's going on so when you start using

00:22:05,890 --> 00:22:09,610
bluebird it will say okay well this is

00:22:08,110 --> 00:22:12,590
this type this is this and it all kind

00:22:09,610 --> 00:22:15,010
of works together some downsides of

00:22:12,590 --> 00:22:17,360
this is that these don't always exist

00:22:15,010 --> 00:22:21,110
these aren't always maintained by the

00:22:17,360 --> 00:22:23,120
same authors some authors are but like

00:22:21,110 --> 00:22:23,510
now I don't want to do that typescript

00:22:23,120 --> 00:22:26,210
sucks

00:22:23,510 --> 00:22:29,299
so sometimes these are out of date

00:22:26,210 --> 00:22:30,679
sometimes these don't exist some of the

00:22:29,299 --> 00:22:33,200
bigger libraries have got the types

00:22:30,679 --> 00:22:36,770
built into into the libraries themselves

00:22:33,200 --> 00:22:39,409
you don't need the app types so yeah

00:22:36,770 --> 00:22:44,470
this is a little bit less than perfect

00:22:39,409 --> 00:22:47,480
right now okay so that's all theory

00:22:44,470 --> 00:22:49,250
hopefully not too boring what I wanted

00:22:47,480 --> 00:22:51,559
to do for the rest of this talk is kind

00:22:49,250 --> 00:22:52,760
of just go through how would you get if

00:22:51,559 --> 00:22:55,940
you wanted to get started with

00:22:52,760 --> 00:22:58,039
typescript how would you do that and I'm

00:22:55,940 --> 00:22:59,419
gonna split this into sections of what's

00:22:58,039 --> 00:23:02,330
the minimum you need to do to use

00:22:59,419 --> 00:23:07,250
typescript right now like the easy mode

00:23:02,330 --> 00:23:09,409
could work you could do this in I don't

00:23:07,250 --> 00:23:12,049
know a day on most repositories it's

00:23:09,409 --> 00:23:15,620
it's mostly just going through and doing

00:23:12,049 --> 00:23:17,059
quite manual steps later on there's sort

00:23:15,620 --> 00:23:18,919
of steps for actually making types of it

00:23:17,059 --> 00:23:20,510
really work for you but the biggest

00:23:18,919 --> 00:23:22,520
hurdle is actually you're taking a

00:23:20,510 --> 00:23:28,179
JavaScript board a project and getting

00:23:22,520 --> 00:23:32,140
it running in typescript so this is my

00:23:28,179 --> 00:23:34,990
patented guide for not patented for

00:23:32,140 --> 00:23:37,789
getting to your project into typescript

00:23:34,990 --> 00:23:40,520
so you need to have typescript installed

00:23:37,789 --> 00:23:42,919
doesn't need to be global but that's the

00:23:40,520 --> 00:23:44,899
easiest way you need a TS config file

00:23:42,919 --> 00:23:47,899
and we'll go through what needs to go in

00:23:44,899 --> 00:23:49,760
there you need to install your app type

00:23:47,899 --> 00:23:52,610
packages you don't need to actually but

00:23:49,760 --> 00:23:54,580
you may as well go through and try and

00:23:52,610 --> 00:23:57,740
install as many of those as you can and

00:23:54,580 --> 00:24:00,890
you rename all your files to TS and then

00:23:57,740 --> 00:24:05,570
you go through a loop of fixing stuff so

00:24:00,890 --> 00:24:06,620
basically try to compile with TS c you

00:24:05,570 --> 00:24:08,710
need to sort of point it at the right

00:24:06,620 --> 00:24:12,080
folder for what you want to compile to

00:24:08,710 --> 00:24:15,200
but in general it will just take

00:24:12,080 --> 00:24:17,639
typescript files out put them to another

00:24:15,200 --> 00:24:19,580
folder as javascript files

00:24:17,639 --> 00:24:22,970
and the JavaScript should be fairly

00:24:19,580 --> 00:24:25,830
readable it's mainly taking stuff out

00:24:22,970 --> 00:24:27,299
and yeah fix stuff until it compiles and

00:24:25,830 --> 00:24:32,009
I'll go through some of the things that

00:24:27,299 --> 00:24:35,519
are kind of common problems when you try

00:24:32,009 --> 00:24:37,950
and do that oh yes I start with TS

00:24:35,519 --> 00:24:40,019
kontrick so these are some of the I've

00:24:37,950 --> 00:24:42,869
picked some of the most confusing terms

00:24:40,019 --> 00:24:45,840
out of TS config a lot of them I mean we

00:24:42,869 --> 00:24:48,809
all use let tons of config files for

00:24:45,840 --> 00:24:51,149
various things in in web these days but

00:24:48,809 --> 00:24:52,470
a lot of them make a lot of sense these

00:24:51,149 --> 00:24:57,239
are the ones that make the least sense

00:24:52,470 --> 00:24:59,820
so module module is the export and

00:24:57,239 --> 00:25:04,499
import style that you that it's gonna

00:24:59,820 --> 00:25:07,830
output so if you're using es5 style you

00:25:04,499 --> 00:25:10,980
want commonjs I think it's es6 if you

00:25:07,830 --> 00:25:14,639
want the sort of import default export

00:25:10,980 --> 00:25:16,169
default type Styles module resolution

00:25:14,639 --> 00:25:18,119
this should always be know to never

00:25:16,169 --> 00:25:22,129
change it the other option is legacy and

00:25:18,119 --> 00:25:25,879
it's just there to confuse you target is

00:25:22,129 --> 00:25:29,340
the version of JavaScript to target but

00:25:25,879 --> 00:25:31,440
it's not doing poly filling it's not

00:25:29,340 --> 00:25:35,850
doing most things it's basically just

00:25:31,440 --> 00:25:38,429
it's doing syntactic sort of sugar

00:25:35,850 --> 00:25:40,619
changes so they'll I'm not showing the

00:25:38,429 --> 00:25:42,480
exact list but it will do some stuff but

00:25:40,619 --> 00:25:44,009
it's not poly filling this is not gonna

00:25:42,480 --> 00:25:48,480
make give you something that's suitable

00:25:44,009 --> 00:25:51,330
for web Lib so this is kind of

00:25:48,480 --> 00:25:55,559
specifying different libraries that you

00:25:51,330 --> 00:25:57,840
have available on your environment but

00:25:55,559 --> 00:26:01,320
again it's not doing any poly filling

00:25:57,840 --> 00:26:04,230
all this is doing is defining what types

00:26:01,320 --> 00:26:06,269
are available for those and annoying one

00:26:04,230 --> 00:26:07,739
is they don't support node in here so

00:26:06,269 --> 00:26:12,090
you have to do the node types in a

00:26:07,739 --> 00:26:14,340
different way okay so I've got a module

00:26:12,090 --> 00:26:17,549
that I've just turned into a type script

00:26:14,340 --> 00:26:19,830
file and I've got some common problems

00:26:17,549 --> 00:26:24,840
that happen with this one so we've got

00:26:19,830 --> 00:26:27,119
some red messages so these two are

00:26:24,840 --> 00:26:29,190
because we don't have our types for

00:26:27,119 --> 00:26:31,140
nodes I just mentioned so if we install

00:26:29,190 --> 00:26:34,380
the types for nodes and save that

00:26:31,140 --> 00:26:38,490
then they'll be fixed these two are

00:26:34,380 --> 00:26:41,580
probably the most weird and torturous

00:26:38,490 --> 00:26:46,010
part of typescript which is typescript

00:26:41,580 --> 00:26:50,430
tries to guess if you are using node

00:26:46,010 --> 00:26:53,940
code or like web code and it does that

00:26:50,430 --> 00:26:56,400
by looking for a es6 style export or

00:26:53,940 --> 00:26:58,920
import and if you don't have any so

00:26:56,400 --> 00:27:01,410
you've just got this es5 export it will

00:26:58,920 --> 00:27:03,090
interpret this script as global so

00:27:01,410 --> 00:27:05,220
actually it's complaining about left pad

00:27:03,090 --> 00:27:07,740
because I have left pad in another file

00:27:05,220 --> 00:27:11,700
in my project so to fix that we need to

00:27:07,740 --> 00:27:16,740
convert our es5 export into an ear 6

00:27:11,700 --> 00:27:18,300
export and then it's happy oh yeah I

00:27:16,740 --> 00:27:21,900
want to do a bit of an aside just for

00:27:18,300 --> 00:27:27,210
anyone who's not moved into kind of es6

00:27:21,900 --> 00:27:29,100
style imports and exports so if we have

00:27:27,210 --> 00:27:32,610
a variable which we want to export to

00:27:29,100 --> 00:27:35,060
another module and so left hand side is

00:27:32,610 --> 00:27:39,150
commonjs right hand side is es6

00:27:35,060 --> 00:27:41,880
we would have done exports equals and

00:27:39,150 --> 00:27:43,500
then hello equals require to get it back

00:27:41,880 --> 00:27:48,240
again so this is the export this is the

00:27:43,500 --> 00:27:50,430
import in ear 6 there is no way to do

00:27:48,240 --> 00:27:51,870
the first one and the second one really

00:27:50,430 --> 00:27:53,610
exists just for sort of backwards

00:27:51,870 --> 00:28:00,870
compatibility so that you can use

00:27:53,610 --> 00:28:02,640
old-style projects es6 has named exports

00:28:00,870 --> 00:28:04,200
so you can export something with a

00:28:02,640 --> 00:28:06,750
certain name and that's pretty much

00:28:04,200 --> 00:28:09,500
equivalent to doing this in es5 and

00:28:06,750 --> 00:28:13,200
these are sort of cross-compatible

00:28:09,500 --> 00:28:14,940
es6 has the new default export so you

00:28:13,200 --> 00:28:17,180
can it's like the main thing you're

00:28:14,940 --> 00:28:21,000
exporting which sort of replaces this

00:28:17,180 --> 00:28:26,130
and you do that via the exports default

00:28:21,000 --> 00:28:28,290
key in es5 so this is basically

00:28:26,130 --> 00:28:39,900
identical to typescript typescript uses

00:28:28,290 --> 00:28:42,230
the es6 I mean so so however typescript

00:28:39,900 --> 00:28:44,909
does add one additional way of doing

00:28:42,230 --> 00:28:46,679
exports so the one which does

00:28:44,909 --> 00:28:48,570
it has no equivalent near six in

00:28:46,679 --> 00:28:51,929
typescript we do have an equivalent so

00:28:48,570 --> 00:28:54,119
we have export equals which is slightly

00:28:51,929 --> 00:28:56,849
different but basically it does it is

00:28:54,119 --> 00:28:58,529
the same as module X modulo exports

00:28:56,849 --> 00:29:01,679
equals hello and I suspect this is

00:28:58,529 --> 00:29:04,049
because typescript has to support older

00:29:01,679 --> 00:29:07,879
versions of JavaScript so they kind of

00:29:04,049 --> 00:29:07,879
wanted to make that possible

00:29:08,460 --> 00:29:13,139
another gotcha required does not support

00:29:11,429 --> 00:29:15,359
types so if you're still using require

00:29:13,139 --> 00:29:18,330
you'll get stuff back it will work but

00:29:15,359 --> 00:29:20,759
it won't have any types associated with

00:29:18,330 --> 00:29:22,979
it and that's because you can't because

00:29:20,759 --> 00:29:25,649
require takes a string you can't

00:29:22,979 --> 00:29:27,299
statically analyze the types of it you

00:29:25,649 --> 00:29:32,129
don't know what thing is going to be

00:29:27,299 --> 00:29:37,710
required so yeah it just doesn't work

00:29:32,129 --> 00:29:40,440
for awhile for that okay so another

00:29:37,710 --> 00:29:43,379
common gotcha I came across in my kind

00:29:40,440 --> 00:29:45,509
of testing for this is reuse variables

00:29:43,379 --> 00:29:48,720
so if you reuse a variable

00:29:45,509 --> 00:29:53,119
typescript will have specified specified

00:29:48,720 --> 00:29:54,899
a single type for it and you'll be

00:29:53,119 --> 00:29:57,539
you'll be trying to redefine that

00:29:54,899 --> 00:30:00,259
anybody like it so you just rename it

00:29:57,539 --> 00:30:03,269
another common gotcha is if you're using

00:30:00,259 --> 00:30:04,830
es five style classes so this is like

00:30:03,269 --> 00:30:09,840
constructor function and then we add a

00:30:04,830 --> 00:30:12,269
static method on to that later on this

00:30:09,840 --> 00:30:13,739
is how sort of before the nice new class

00:30:12,269 --> 00:30:16,789
syntax came in we were sort of

00:30:13,739 --> 00:30:18,629
incrementally building up our classes

00:30:16,789 --> 00:30:21,269
typescript doesn't like this because

00:30:18,629 --> 00:30:25,559
when you defined this class this

00:30:21,269 --> 00:30:27,570
function it implicitly guessed the type

00:30:25,559 --> 00:30:29,789
and it gets that just being a raw

00:30:27,570 --> 00:30:33,119
function so it's not expecting this and

00:30:29,789 --> 00:30:38,059
now it's like go the easiest way to fix

00:30:33,119 --> 00:30:41,129
this is to move over to es6 classes so

00:30:38,059 --> 00:30:43,139
then the whole thing is is declared in

00:30:41,129 --> 00:30:44,369
one single block and we don't have to

00:30:43,139 --> 00:30:46,999
worry about sort of incremental

00:30:44,369 --> 00:30:46,999
structures

00:30:47,489 --> 00:30:52,799
another one is in your javascript code

00:30:50,729 --> 00:30:55,229
you may well have like default

00:30:52,799 --> 00:30:57,840
parameters which you've set so if count

00:30:55,229 --> 00:31:01,590
wasn't set we set it to one

00:30:57,840 --> 00:31:04,380
and so talk is gonna meow three times

00:31:01,590 --> 00:31:06,210
and talk with no argument is gonna meow

00:31:04,380 --> 00:31:12,330
once the typescript is unhappy about

00:31:06,210 --> 00:31:16,260
this and that's because it's that

00:31:12,330 --> 00:31:18,660
because it's expecting one argument here

00:31:16,260 --> 00:31:22,110
because we've specified one argument and

00:31:18,660 --> 00:31:26,280
so we can actually add an optional type

00:31:22,110 --> 00:31:28,950
there which means we are optionally

00:31:26,280 --> 00:31:31,680
expecting that parameter and now it's

00:31:28,950 --> 00:31:33,510
happy and typescript actually goes a bit

00:31:31,680 --> 00:31:36,000
further because it's got default

00:31:33,510 --> 00:31:38,520
arguments I'm not sure that's an es6

00:31:36,000 --> 00:31:40,860
feature as well but it's certainly in

00:31:38,520 --> 00:31:42,810
typescript so you can just say count

00:31:40,860 --> 00:31:45,420
equals one and that will work the same

00:31:42,810 --> 00:31:47,460
so count equals one is the same as the

00:31:45,420 --> 00:31:55,800
setting it to an optional type with

00:31:47,460 --> 00:31:59,100
number okay so for easy mode we've also

00:31:55,800 --> 00:32:01,800
got a cheat code which is any any is

00:31:59,100 --> 00:32:06,120
basically the type that tells typescript

00:32:01,800 --> 00:32:08,280
to just go away so if you set something

00:32:06,120 --> 00:32:10,590
to any typescript we'll kind of ignore

00:32:08,280 --> 00:32:13,830
anything it does until it comes back to

00:32:10,590 --> 00:32:15,440
not being in any type so yeah any ignore

00:32:13,830 --> 00:32:18,930
available and anything derive from it

00:32:15,440 --> 00:32:20,100
it's really good for beginners and it

00:32:18,930 --> 00:32:23,130
was really good when I was starting out

00:32:20,100 --> 00:32:27,450
because you can just go I have to get

00:32:23,130 --> 00:32:29,100
this like thing released and I can't be

00:32:27,450 --> 00:32:31,080
bothered with this type nonsense and you

00:32:29,100 --> 00:32:32,430
should go any only only and then later

00:32:31,080 --> 00:32:34,560
you can come back and figure out what's

00:32:32,430 --> 00:32:36,150
actually going on so we can actually go

00:32:34,560 --> 00:32:40,530
back through all the previous examples

00:32:36,150 --> 00:32:43,050
and just cheat so let's see we have this

00:32:40,530 --> 00:32:47,400
problem we just put cat curl on any now

00:32:43,050 --> 00:32:50,490
it's in any don't care value value curl

00:32:47,400 --> 00:32:52,560
on any now doesn't care so we can use

00:32:50,490 --> 00:32:55,500
that if you want to get a project into

00:32:52,560 --> 00:32:57,780
typescript you can use any to fix all

00:32:55,500 --> 00:33:01,230
the problems until you want to come back

00:32:57,780 --> 00:33:02,940
and fix them later because I mean it was

00:33:01,230 --> 00:33:04,410
a kind of a long process from us moving

00:33:02,940 --> 00:33:10,110
to typescript before we were actually

00:33:04,410 --> 00:33:11,760
getting rid of all of these okay so

00:33:10,110 --> 00:33:14,940
improving your types so

00:33:11,760 --> 00:33:17,250
the first section was how can you get

00:33:14,940 --> 00:33:20,639
your project into typescript second

00:33:17,250 --> 00:33:23,909
section is how can we actually get rid

00:33:20,639 --> 00:33:25,350
of those bad types and make it stricter

00:33:23,909 --> 00:33:28,799
so you actually get stuff out of it if

00:33:25,350 --> 00:33:30,000
you just stay back in this mode you

00:33:28,799 --> 00:33:37,230
won't get a huge amount out of

00:33:30,000 --> 00:33:39,960
typescript so improving basically tears

00:33:37,230 --> 00:33:41,880
config settings set these to true I'll

00:33:39,960 --> 00:33:43,139
go through them all one by one but these

00:33:41,880 --> 00:33:45,539
are all good things

00:33:43,139 --> 00:33:49,019
they will take work in your codebase to

00:33:45,539 --> 00:33:53,519
make them compile but they're definitely

00:33:49,019 --> 00:33:55,669
worth getting through always strict

00:33:53,519 --> 00:33:57,750
basically means that it's gonna when it

00:33:55,669 --> 00:34:02,460
compiles your code it's going to put you

00:33:57,750 --> 00:34:11,099
strict in there it's pretty good strict

00:34:02,460 --> 00:34:14,070
property okay so basically checks that

00:34:11,099 --> 00:34:16,079
you write to a property before you use

00:34:14,070 --> 00:34:17,310
it so if you said you're going to have a

00:34:16,079 --> 00:34:20,040
property and it's going to be a string

00:34:17,310 --> 00:34:21,899
you need to in your saves in an object

00:34:20,040 --> 00:34:25,220
in a class you need to set that

00:34:21,899 --> 00:34:27,389
somewhere before you try and access it

00:34:25,220 --> 00:34:29,099
and that's actually fairly intelligent

00:34:27,389 --> 00:34:30,869
so it knows if you put something in your

00:34:29,099 --> 00:34:35,300
constructor it knows that's going to run

00:34:30,869 --> 00:34:35,300
before anything outside of a constructor

00:34:35,389 --> 00:34:41,040
strict null checks yeah if you don't

00:34:39,210 --> 00:34:45,710
have this it will kind of let you use

00:34:41,040 --> 00:34:47,639
null or undefined in kind of as in any

00:34:45,710 --> 00:34:49,800
fact you should probably turn this on as

00:34:47,639 --> 00:34:54,540
soon as you can because it stops a lot

00:34:49,800 --> 00:34:55,500
of horrible cases so I mentioned any is

00:34:54,540 --> 00:34:58,800
great

00:34:55,500 --> 00:35:00,930
now we've gone to the next level any is

00:34:58,800 --> 00:35:06,119
not great and he is really bad so what

00:35:00,930 --> 00:35:09,210
we need to do is get rid of any so for

00:35:06,119 --> 00:35:11,670
example this cap thing looks fine

00:35:09,210 --> 00:35:14,819
typescript thingy and then we go and

00:35:11,670 --> 00:35:16,349
when we go and look at all of the types

00:35:14,819 --> 00:35:20,280
of everything and we've got all of these

00:35:16,349 --> 00:35:23,010
any's everywhere basically

00:35:20,280 --> 00:35:24,810
by default typescript will have implicit

00:35:23,010 --> 00:35:26,370
any's where if you don't specify it

00:35:24,810 --> 00:35:28,050
it'll guess

00:35:26,370 --> 00:35:30,420
and if you can't guess anything better

00:35:28,050 --> 00:35:32,100
so generally function arguments will I

00:35:30,420 --> 00:35:35,340
think always be any if you don't specify

00:35:32,100 --> 00:35:37,440
them so if we turn on no implicit any

00:35:35,340 --> 00:35:40,110
you're suddenly going to get about a

00:35:37,440 --> 00:35:41,790
million errors of all the places where

00:35:40,110 --> 00:35:44,220
it's not specified

00:35:41,790 --> 00:35:46,200
I'd suggest as a first step for this is

00:35:44,220 --> 00:35:49,740
you go and you manually put in any on

00:35:46,200 --> 00:35:51,960
all of those it's still not perfect but

00:35:49,740 --> 00:35:54,030
it means you who then have you can you

00:35:51,960 --> 00:35:56,490
can do a grep for all of the Enys in

00:35:54,030 --> 00:36:01,050
your repository and you know how bad

00:35:56,490 --> 00:36:02,520
your types are basically yeah so on type

00:36:01,050 --> 00:36:05,940
variables will become explicit and

00:36:02,520 --> 00:36:10,650
findable the other problem you'll get

00:36:05,940 --> 00:36:12,900
with with turning on that rule is that

00:36:10,650 --> 00:36:14,550
third-party modules will start being

00:36:12,900 --> 00:36:18,350
problems when you import them they're

00:36:14,550 --> 00:36:21,630
gonna kind of have errors on them so

00:36:18,350 --> 00:36:23,780
what you can do is you can do add this

00:36:21,630 --> 00:36:27,450
to your TS config which is type routes

00:36:23,780 --> 00:36:29,190
added types folder and then put this

00:36:27,450 --> 00:36:32,940
file in up types folder and you can

00:36:29,190 --> 00:36:35,070
start declaring modules just empty and

00:36:32,940 --> 00:36:38,190
if you declare a module empty like this

00:36:35,070 --> 00:36:41,070
then you're basically saying I'm okay

00:36:38,190 --> 00:36:43,290
with all of the types in this cucumber

00:36:41,070 --> 00:36:44,600
library being any just just stop

00:36:43,290 --> 00:36:47,130
complaining

00:36:44,600 --> 00:36:48,930
so this means you can kind of get then

00:36:47,130 --> 00:36:50,670
get an audit trail of all the libraries

00:36:48,930 --> 00:36:58,440
you're using they don't have types but

00:36:50,670 --> 00:37:00,630
they won't bother you so that mode is

00:36:58,440 --> 00:37:05,160
kind of a go back it's kind of an

00:37:00,630 --> 00:37:07,170
iterative cycle of gradually improving

00:37:05,160 --> 00:37:09,630
your types removing Enys adding proper

00:37:07,170 --> 00:37:16,350
structure types in you want to be using

00:37:09,630 --> 00:37:18,060
types and interfaces to to get rid of

00:37:16,350 --> 00:37:19,740
duplication in your types so you don't

00:37:18,060 --> 00:37:23,340
really want to be specifying like string

00:37:19,740 --> 00:37:25,740
or number or something all the time name

00:37:23,340 --> 00:37:31,910
the types and share them export them and

00:37:25,740 --> 00:37:36,660
share them between modules final section

00:37:31,910 --> 00:37:38,550
so one thing you can start doing when

00:37:36,660 --> 00:37:39,210
you've gotten everything else out of the

00:37:38,550 --> 00:37:41,160
way

00:37:39,210 --> 00:37:43,140
is you can start declaring modules but

00:37:41,160 --> 00:37:45,510
not just leaving them empty so we can

00:37:43,140 --> 00:37:49,080
declare a module and put stuff in it so

00:37:45,510 --> 00:37:51,839
this is an example library code glob get

00:37:49,080 --> 00:37:53,550
ignore that I use at work and it doesn't

00:37:51,839 --> 00:37:55,920
have types so we define the types we

00:37:53,550 --> 00:37:58,440
need and this isn't perfect we've got

00:37:55,920 --> 00:38:00,630
like an any there but it's kind of good

00:37:58,440 --> 00:38:02,599
enough to do what we need to do I'm also

00:38:00,630 --> 00:38:04,710
pretty sure this library's got more

00:38:02,599 --> 00:38:06,720
functions and things in it but this is

00:38:04,710 --> 00:38:09,109
the only one we use so you can sort of

00:38:06,720 --> 00:38:13,380
define your own types you can also

00:38:09,109 --> 00:38:14,609
contribute so the app types thing I

00:38:13,380 --> 00:38:17,369
showed earlier

00:38:14,609 --> 00:38:19,880
that's this library definitely typed and

00:38:17,369 --> 00:38:23,010
it contains all of the types for every

00:38:19,880 --> 00:38:24,839
NPM or every typescript module or

00:38:23,010 --> 00:38:28,020
JavaScript module that has types which

00:38:24,839 --> 00:38:30,950
is about like a thousand see if you load

00:38:28,020 --> 00:38:34,260
it in github it kind of crashes the page

00:38:30,950 --> 00:38:38,190
well certainly for a while but those are

00:38:34,260 --> 00:38:42,330
sore - can do it another thing is that

00:38:38,190 --> 00:38:44,420
your external sources might not do the

00:38:42,330 --> 00:38:46,440
thing that you're expecting because

00:38:44,420 --> 00:38:50,609
typescript gets removed at compile time

00:38:46,440 --> 00:38:52,830
by runtime there's nothing to stop the

00:38:50,609 --> 00:38:55,080
wrong data coming in so if you make an

00:38:52,830 --> 00:38:56,820
API call and you said to typescript yeah

00:38:55,080 --> 00:38:59,700
API call and it's going to return like

00:38:56,820 --> 00:39:02,190
an array of strings the API call might

00:38:59,700 --> 00:39:06,060
return whatever the hell it wants so you

00:39:02,190 --> 00:39:07,830
don't know you don't have safety here so

00:39:06,060 --> 00:39:09,780
if you want to be sort of truly type

00:39:07,830 --> 00:39:12,300
safe and have real confidence that your

00:39:09,780 --> 00:39:14,760
code is going to work you need to have

00:39:12,300 --> 00:39:16,140
some kind of validation and then you

00:39:14,760 --> 00:39:18,180
need a way to keep the validation in

00:39:16,140 --> 00:39:23,520
sync with your typescript types so it's

00:39:18,180 --> 00:39:25,920
really annoying but kind of unavoidable

00:39:23,520 --> 00:39:27,750
I don't know of any really cool

00:39:25,920 --> 00:39:32,510
libraries that kind of merge these

00:39:27,750 --> 00:39:34,109
together nicely yet another one is

00:39:32,510 --> 00:39:37,520
typecasting I haven't really covered

00:39:34,109 --> 00:39:40,560
this yet but it's a thing you can do so

00:39:37,520 --> 00:39:43,470
in other languages typecasting is kind

00:39:40,560 --> 00:39:46,380
of a good thing as far as I could see in

00:39:43,470 --> 00:39:50,700
in typescript it's mainly a way to lie

00:39:46,380 --> 00:39:51,590
to the to the compiler so if we have a

00:39:50,700 --> 00:39:53,750
cat here

00:39:51,590 --> 00:39:55,100
cat has to have a name and then we make

00:39:53,750 --> 00:39:58,430
a thing that's definitely not a cat

00:39:55,100 --> 00:40:01,430
doesn't have a name and then we can make

00:39:58,430 --> 00:40:03,500
a new variable and do this as cat which

00:40:01,430 --> 00:40:07,060
is our typecast so we're just saying to

00:40:03,500 --> 00:40:10,760
type strip yep definitely a cat trust me

00:40:07,060 --> 00:40:12,590
so that's not going to work your code

00:40:10,760 --> 00:40:14,170
here will be happily compiling and

00:40:12,590 --> 00:40:17,060
letting you do stuff with the name

00:40:14,170 --> 00:40:19,460
property expecting it to be a string but

00:40:17,060 --> 00:40:22,130
you could easily run into problems like

00:40:19,460 --> 00:40:25,010
if you try to do string dot length on a

00:40:22,130 --> 00:40:27,560
undefined because there's no name you're

00:40:25,010 --> 00:40:28,880
going to crash your program and like

00:40:27,560 --> 00:40:35,740
this is what happens if you trying

00:40:28,880 --> 00:40:38,090
typecast to a cat so one way to do

00:40:35,740 --> 00:40:40,790
typecasting that's sort of fairly

00:40:38,090 --> 00:40:43,040
responsible so if we're using react and

00:40:40,790 --> 00:40:45,560
using JSX then you might have this input

00:40:43,040 --> 00:40:50,350
element and we want to set an on-click

00:40:45,560 --> 00:40:53,120
event so the types that you get here

00:40:50,350 --> 00:40:55,310
with your event will be a generic of

00:40:53,120 --> 00:40:58,190
event and the target will be a generic

00:40:55,310 --> 00:41:00,260
HTML element so you've got it's got no

00:40:58,190 --> 00:41:01,850
idea what kind of HTML element but we

00:41:00,260 --> 00:41:03,800
want to get to the value property

00:41:01,850 --> 00:41:06,080
because we want to we know it's a it's

00:41:03,800 --> 00:41:09,890
an input box and we want to know what

00:41:06,080 --> 00:41:13,250
the value is so to do this we can cast

00:41:09,890 --> 00:41:15,320
two HTML input element because we know

00:41:13,250 --> 00:41:18,530
as responsible developers this is

00:41:15,320 --> 00:41:20,990
attached to an input field input element

00:41:18,530 --> 00:41:24,100
so we know that's going to work so

00:41:20,990 --> 00:41:26,030
that's one way to kind of do that nicely

00:41:24,100 --> 00:41:28,460
the other thing I wanted to give a quick

00:41:26,030 --> 00:41:30,830
shout-out to a library called TS node

00:41:28,460 --> 00:41:36,350
which is really cool for using

00:41:30,830 --> 00:41:38,780
typescript basically it is a normally

00:41:36,350 --> 00:41:41,120
install it globally you run it like node

00:41:38,780 --> 00:41:43,340
except you give it a type script file

00:41:41,120 --> 00:41:46,600
instead of a JavaScript file you can

00:41:43,340 --> 00:41:50,930
also call TS node and just use the

00:41:46,600 --> 00:41:53,480
what's it called ripple yeah you can

00:41:50,930 --> 00:41:58,400
just use the ripple to run typescript

00:41:53,480 --> 00:42:00,800
on the command line which is really nice

00:41:58,400 --> 00:42:01,970
so this is really great and means you

00:42:00,800 --> 00:42:04,760
don't have to have a like a whole

00:42:01,970 --> 00:42:08,480
compile step to use scripts so

00:42:04,760 --> 00:42:11,780
my company we're using all of our

00:42:08,480 --> 00:42:13,579
scripts run in typescript and this is

00:42:11,780 --> 00:42:14,690
kind of really nice for that because you

00:42:13,579 --> 00:42:17,740
don't have to go through a whole compile

00:42:14,690 --> 00:42:22,040
step to change them and run them again

00:42:17,740 --> 00:42:26,270
and that's everything I have I'm working

00:42:22,040 --> 00:42:29,780
at DIF blue in Oxford kind of cringy

00:42:26,270 --> 00:42:32,540
subtitle but yeah we're looking for full

00:42:29,780 --> 00:42:36,140
stack developers if anyone's interested

00:42:32,540 --> 00:42:38,060
in moving to Oxford and we use a number

00:42:36,140 --> 00:42:40,220
of things typescript react node

00:42:38,060 --> 00:42:43,820
docker I thought out like half of them

00:42:40,220 --> 00:42:46,190
we do loads of stuff yeah talk to me if

00:42:43,820 --> 00:42:48,460
you're interested and that's it

00:42:46,190 --> 00:42:53,309
slide link there

00:42:48,460 --> 00:42:53,309

YouTube URL: https://www.youtube.com/watch?v=PNNjZWVgBrU


