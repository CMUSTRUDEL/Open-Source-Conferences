Title: Bristol JS, Back to the Futures: Making the Case for Algebraic Promises, January 2018
Publication date: 2018-02-11
Playlist: Bristol JS
Description: 
	Asynchronous programming in JavaScript has been on an exciting journey over the life of the language. We've always needed to avoid blocking UI to do computation, and various solutions have been explored over the years - events, callbacks, Observables, Promises...

It's likely that you've encountered Promises if you've been writing any JavaScript in the last few years, and with native Promise implementations in NodeJS and all modern browsers, combined with the introduction of async/await in ES2017, they've never been more ubiquitous or useful.

It may seem like a crazy time to be looking for alternatives when Promises have so clearly 'won' the async battle, but I think there is a lot to be learned from an older technique from functional programming. A technique that is lazy (we functional folk consider this a good thing), cancellable, and conforms to the monadic interface, opening up a world of interactions with other useful functional techniques. I think it's time to try Promise's algebraic cousin, the Future.

More about Bristol JS: https://www.meetup.com/BristolJS/
Captions: 
	00:00:00,000 --> 00:00:03,419
well futures thank you so much for come

00:00:01,829 --> 00:00:06,000
down and listen to me talk about futures

00:00:03,419 --> 00:00:06,930
I've got a rather grand proposition here

00:00:06,000 --> 00:00:09,719
and you'll be making the case for

00:00:06,930 --> 00:00:11,219
algebraic promises don't worry about

00:00:09,719 --> 00:00:13,080
that I'm sure there's two questions in

00:00:11,219 --> 00:00:15,870
your mind question number one quite

00:00:13,080 --> 00:00:20,430
rightly is what is a future so a future

00:00:15,870 --> 00:00:22,289
is a wrapper for a value we really

00:00:20,430 --> 00:00:24,840
really cares about tight I'm not just

00:00:22,289 --> 00:00:26,789
talking about a good date were we're

00:00:24,840 --> 00:00:28,769
representing time but something that you

00:00:26,789 --> 00:00:31,050
actually have them waiting for and when

00:00:28,769 --> 00:00:32,759
it comes you might have succeeded or my

00:00:31,050 --> 00:00:35,399
failed I'm not talking about the bus

00:00:32,759 --> 00:00:37,260
these things like promises if you did

00:00:35,399 --> 00:00:39,210
you see the before and a second question

00:00:37,260 --> 00:00:41,100
I imagine on everybody's minds is how do

00:00:39,210 --> 00:00:44,070
you think you can get away is such an

00:00:41,100 --> 00:00:46,379
awful pun as back to the futures well

00:00:44,070 --> 00:00:49,129
reason number one I have a shame and

00:00:46,379 --> 00:00:52,680
reason number two you technically works

00:00:49,129 --> 00:00:56,760
so what's the functional JavaScript seen

00:00:52,680 --> 00:00:58,379
is fairly new each and thing around for

00:00:56,760 --> 00:01:00,449
only three or four years in JavaScript

00:00:58,379 --> 00:01:04,830
but they actually have a very old

00:01:00,449 --> 00:01:07,080
history see the IO type in Haskell is

00:01:04,830 --> 00:01:10,200
actually a kind of future and that's

00:01:07,080 --> 00:01:12,180
been the wave then interactions in

00:01:10,200 --> 00:01:15,570
Haskell for the last 20 years so

00:01:12,180 --> 00:01:22,799
technically we can go back to the

00:01:15,570 --> 00:01:24,630
futures so what I want to do well I

00:01:22,799 --> 00:01:28,530
think one of you is leave anyone behind

00:01:24,630 --> 00:01:30,780
so I'm starting the presentation with a

00:01:28,530 --> 00:01:32,369
little bit of a need-to-know section so

00:01:30,780 --> 00:01:35,610
this is what I would ideally like people

00:01:32,369 --> 00:01:37,110
to know so this is a common baseline so

00:01:35,610 --> 00:01:39,299
that we can press forward together so

00:01:37,110 --> 00:01:41,509
the Mike everyone tonight JavaScript you

00:01:39,299 --> 00:01:46,079
can I got mostly JavaScript guys here

00:01:41,509 --> 00:01:50,100
cool like people to have some experience

00:01:46,079 --> 00:01:51,869
of the map function if any of these well

00:01:50,100 --> 00:01:54,240
it's only the second team map and

00:01:51,869 --> 00:01:57,299
parameters if you don't know them

00:01:54,240 --> 00:01:57,600
I can do a really quick crash course on

00:01:57,299 --> 00:01:59,670
them

00:01:57,600 --> 00:02:01,680
so I'm gonna ask for a little bit of

00:01:59,670 --> 00:02:04,649
audience participation which isn't great

00:02:01,680 --> 00:02:06,960
but so if I have a rough show of hands

00:02:04,649 --> 00:02:09,860
the people who think they know what map

00:02:06,960 --> 00:02:13,170
is who have seen map their JavaScript

00:02:09,860 --> 00:02:14,880
everyone comfortable with map

00:02:13,170 --> 00:02:25,440
actually pretty high level of comfort

00:02:14,880 --> 00:02:27,209
with map there that's really good so I

00:02:25,440 --> 00:02:29,790
will talk about what we don't need to

00:02:27,209 --> 00:02:31,350
know okay so we don't need to know

00:02:29,790 --> 00:02:33,090
functional programming I know a

00:02:31,350 --> 00:02:34,709
name-checked has been already I'm really

00:02:33,090 --> 00:02:36,989
sorry for doing that one minute

00:02:34,709 --> 00:02:38,670
presentation this is about JavaScript I

00:02:36,989 --> 00:02:41,519
love JavaScript a lot functional

00:02:38,670 --> 00:02:43,920
JavaScript I don't expect you to know a

00:02:41,519 --> 00:02:45,750
strongly typed functional language don't

00:02:43,920 --> 00:02:47,700
expect you to know category theory for

00:02:45,750 --> 00:02:51,030
mathematics I like don't even expect you

00:02:47,700 --> 00:02:53,519
to know any other async techniques so

00:02:51,030 --> 00:02:55,340
events observables it's not like that's

00:02:53,519 --> 00:02:59,040
not important today we're just comparing

00:02:55,340 --> 00:03:00,900
futures and promises to give you a fair

00:02:59,040 --> 00:03:02,760
go on what if this is something you

00:03:00,900 --> 00:03:10,890
might want to try out at work or in your

00:03:02,760 --> 00:03:11,610
home for everything so no okay well

00:03:10,890 --> 00:03:16,850
there we go

00:03:11,610 --> 00:03:21,120
so yeah map a little refresher on that

00:03:16,850 --> 00:03:23,010
so map is a higher order function which

00:03:21,120 --> 00:03:25,680
basically means it's a function that

00:03:23,010 --> 00:03:28,590
takes another function and the function

00:03:25,680 --> 00:03:31,920
that you give it is then applied every

00:03:28,590 --> 00:03:34,620
item in a list so let's say for example

00:03:31,920 --> 00:03:38,190
we have a list with some numbers in one

00:03:34,620 --> 00:03:41,400
two and three and I call map on that

00:03:38,190 --> 00:03:44,370
list function I give to map I think it's

00:03:41,400 --> 00:03:45,780
applied to each item above this so for

00:03:44,370 --> 00:03:49,070
example if I call this function up there

00:03:45,780 --> 00:03:53,609
and what is evan called the arrow syntax

00:03:49,070 --> 00:03:56,579
yeah i've only kind of more traditional

00:03:53,609 --> 00:03:57,959
pre es6 version there for people who are

00:03:56,579 --> 00:04:01,079
not used to the arrow syntax but i've

00:03:57,959 --> 00:04:04,769
got add one take some x adds 1 to the X

00:04:01,079 --> 00:04:08,190
X plus 1 so if I call 1 2 3 Matt at 1

00:04:04,769 --> 00:04:09,750
the result should be 2 3 oh pretty

00:04:08,190 --> 00:04:12,420
simple I've also got an example there

00:04:09,750 --> 00:04:14,190
where we've used an anonymous learn the

00:04:12,420 --> 00:04:17,070
function is for the same thing so

00:04:14,190 --> 00:04:20,010
actually catch you up on that and then

00:04:17,070 --> 00:04:23,370
we've also got promises and then there's

00:04:20,010 --> 00:04:25,450
a ferry a kind of niche famous article

00:04:23,370 --> 00:04:26,710
on a broken promises

00:04:25,450 --> 00:04:28,540
which is all bad teachers so that

00:04:26,710 --> 00:04:31,330
teachers are a better there's no promise

00:04:28,540 --> 00:04:35,110
I think that's strictly true but they go

00:04:31,330 --> 00:04:39,280
you've got your broken process so just

00:04:35,110 --> 00:04:41,980
like futures a pro-x is an object that

00:04:39,280 --> 00:04:44,080
wraps an eventual value so the natal

00:04:41,980 --> 00:04:46,690
waiting for that will come to you

00:04:44,080 --> 00:04:49,540
it represents the eventual completion or

00:04:46,690 --> 00:04:52,570
eventual failure of some asynchronous

00:04:49,540 --> 00:04:55,540
operations so that might be sending out

00:04:52,570 --> 00:04:57,550
an HTTP server for Bennett Jason might

00:04:55,540 --> 00:04:59,800
be reading a file from a file system

00:04:57,550 --> 00:05:02,020
hoping like I example he's now in a lot

00:04:59,800 --> 00:05:05,950
as well as adding one to things that use

00:05:02,020 --> 00:05:11,770
that one so much today so to create a

00:05:05,950 --> 00:05:14,010
promise you've got new promise and so

00:05:11,770 --> 00:05:17,470
it's kind of a little bit object to that

00:05:14,010 --> 00:05:19,690
you parts of the function for a text

00:05:17,470 --> 00:05:22,540
function for resolve and reject so you

00:05:19,690 --> 00:05:25,930
then start your underlying asynchronous

00:05:22,540 --> 00:05:29,290
operation when it succeeds you call that

00:05:25,930 --> 00:05:33,250
resolve function with the success value

00:05:29,290 --> 00:05:35,170
like fails you call the reject value you

00:05:33,250 --> 00:05:38,200
pull the reject function with the

00:05:35,170 --> 00:05:40,570
failure value okay so when you're using

00:05:38,200 --> 00:05:43,330
promises it looks a have a lot like that

00:05:40,570 --> 00:05:45,070
second example because I'm doing

00:05:43,330 --> 00:05:46,870
something that takes some time and then

00:05:45,070 --> 00:05:51,030
there's a hell of a lot then top and

00:05:46,870 --> 00:05:53,440
then then as you kind of chain together

00:05:51,030 --> 00:05:58,330
everything that happens after this

00:05:53,440 --> 00:05:59,680
initial innovate synchronicity so we

00:05:58,330 --> 00:06:03,990
kind of thing in core with with Matt

00:05:59,680 --> 00:06:06,430
compromise you can kind of press up okay

00:06:03,990 --> 00:06:09,280
really really really crash course on

00:06:06,430 --> 00:06:13,810
what what matters to me about functional

00:06:09,280 --> 00:06:16,060
programming so punctual programs and

00:06:13,810 --> 00:06:18,430
again I crash the bus how many of you

00:06:16,060 --> 00:06:20,260
have kind of done functional programming

00:06:18,430 --> 00:06:21,900
seen functional programming heard of

00:06:20,260 --> 00:06:24,790
functional programming to be honest

00:06:21,900 --> 00:06:27,130
susan has again really really great

00:06:24,790 --> 00:06:29,940
numbers fantastic so yeah what matters

00:06:27,130 --> 00:06:33,070
doing functional programming is the

00:06:29,940 --> 00:06:35,710
programs are composed of smaller

00:06:33,070 --> 00:06:38,260
programs which eventually you get down

00:06:35,710 --> 00:06:39,220
into these kind of atomic values which

00:06:38,260 --> 00:06:42,520
are

00:06:39,220 --> 00:06:44,920
and values okay so values used to you

00:06:42,520 --> 00:06:47,440
things like number of strings objects

00:06:44,920 --> 00:06:49,240
arrays functions you've seen this add

00:06:47,440 --> 00:06:52,780
one function as a surface it come up a

00:06:49,240 --> 00:06:56,070
lot even things like this reduce is

00:06:52,780 --> 00:07:03,850
slightly slightly more complex example

00:06:56,070 --> 00:07:09,280
function so what I'm going to be doing

00:07:03,850 --> 00:07:12,340
is introducing couple types to really

00:07:09,280 --> 00:07:16,300
help you get a handle on what futures

00:07:12,340 --> 00:07:18,670
are in particular I'll be introducing

00:07:16,300 --> 00:07:20,710
the future type so please come in a

00:07:18,670 --> 00:07:23,950
title there and I'll be showing you the

00:07:20,710 --> 00:07:25,630
either type because it's a way of really

00:07:23,950 --> 00:07:28,690
unlocking some of the superpowers of

00:07:25,630 --> 00:07:31,360
futures this also means that we're going

00:07:28,690 --> 00:07:35,110
to need to make a little bit of a start

00:07:31,360 --> 00:07:36,460
on a concept called type classes okay so

00:07:35,110 --> 00:07:38,200
I'm not gonna go into too much detail

00:07:36,460 --> 00:07:40,660
because it pulls us down into a kind of

00:07:38,200 --> 00:07:43,450
category Theory rabbit hole there we go

00:07:40,660 --> 00:07:45,760
really really deep into them but if

00:07:43,450 --> 00:07:47,410
anybody does any object-oriented

00:07:45,760 --> 00:07:50,200
programming it might be useful to think

00:07:47,410 --> 00:07:52,090
of them as interfaces so the type class

00:07:50,200 --> 00:07:54,669
will generally come with one or more

00:07:52,090 --> 00:07:56,770
functions and in order to be a member of

00:07:54,669 --> 00:08:01,210
that type class you have to implement

00:07:56,770 --> 00:08:02,890
those punches don't worry it's those

00:08:01,210 --> 00:08:05,040
that don't worry we're mostly just

00:08:02,890 --> 00:08:10,060
naming them and moving on okay

00:08:05,040 --> 00:08:12,400
so type classes this kind of rainbows in

00:08:10,060 --> 00:08:13,780
the unicorn stuff this isn't just to

00:08:12,400 --> 00:08:16,090
make you feel happier at this point

00:08:13,780 --> 00:08:17,470
hopefully it is distracting you from

00:08:16,090 --> 00:08:19,510
some of the words that we're gonna come

00:08:17,470 --> 00:08:22,890
up in a second and this is actually the

00:08:19,510 --> 00:08:24,850
logo for a kind of movement called

00:08:22,890 --> 00:08:28,360
Fantasyland within the open source

00:08:24,850 --> 00:08:30,610
JavaScript community this comes from a

00:08:28,360 --> 00:08:33,520
common Dominic demo kernel made and I

00:08:30,610 --> 00:08:36,880
promise this colleague who went way back

00:08:33,520 --> 00:08:39,490
in the day where he said you can go and

00:08:36,880 --> 00:08:41,440
live in your typed languages Fantasyland

00:08:39,490 --> 00:08:44,560
we never introducing those changes into

00:08:41,440 --> 00:08:48,339
promises if the promise is a prospect

00:08:44,560 --> 00:08:50,110
and of course the monadic things that we

00:08:48,339 --> 00:08:50,510
were asking for didn't end up in the

00:08:50,110 --> 00:08:53,300
problem

00:08:50,510 --> 00:08:54,380
they perspec but we did decide to go and

00:08:53,300 --> 00:08:57,230
live in a fantasy land

00:08:54,380 --> 00:09:00,470
so this algebraic specification is

00:08:57,230 --> 00:09:03,080
created it's kind of cribbed from her

00:09:00,470 --> 00:09:05,330
school but it's not Haskell again the

00:09:03,080 --> 00:09:08,030
people working on algebraic typed

00:09:05,330 --> 00:09:10,520
functional JavaScript like me are

00:09:08,030 --> 00:09:14,330
passionate about JavaScript and it's the

00:09:10,520 --> 00:09:18,370
very idiomatic JavaScript field it's got

00:09:14,330 --> 00:09:20,330
some different different terminology for

00:09:18,370 --> 00:09:24,010
some other things you might know from

00:09:20,330 --> 00:09:28,160
Haskell so I'm going to start you with a

00:09:24,010 --> 00:09:29,870
couple of the type classes or a type

00:09:28,160 --> 00:09:33,110
that you already know so you all know

00:09:29,870 --> 00:09:38,090
what a list is the list is a container

00:09:33,110 --> 00:09:41,960
for zero or more values when there is

00:09:38,090 --> 00:09:44,900
more than one value the order matters

00:09:41,960 --> 00:09:47,660
and the type class is a couple under

00:09:44,900 --> 00:09:50,360
type classes involved in lists functor

00:09:47,660 --> 00:09:59,750
and foldable so just keep keep things in

00:09:50,360 --> 00:10:01,610
the back of your mind future has yeah

00:09:59,750 --> 00:10:04,070
well I'm not going to do today the Magno

00:10:01,610 --> 00:10:06,440
tutorial that's that's a topic that no

00:10:04,070 --> 00:10:08,390
really needs to get into again I will

00:10:06,440 --> 00:10:10,940
touch very likely I'll leave it alone

00:10:08,390 --> 00:10:13,400
and either I kind of name checks either

00:10:10,940 --> 00:10:16,400
the previous like that's also a fun time

00:10:13,400 --> 00:10:18,820
as a monad it's also - so it sounds

00:10:16,400 --> 00:10:18,820
pretty cool

00:10:18,850 --> 00:10:29,990
so pota any type which influenced the

00:10:26,510 --> 00:10:32,180
function map and it's not quite things

00:10:29,990 --> 00:10:34,430
like terminology but this is broadly for

00:10:32,180 --> 00:10:36,770
me what we're getting onto any type in

00:10:34,430 --> 00:10:37,640
finish approaching a man is a boater

00:10:36,770 --> 00:10:40,010
okay

00:10:37,640 --> 00:10:42,470
what map does do you think what that

00:10:40,010 --> 00:10:45,230
does to a list this is a function that

00:10:42,470 --> 00:10:49,040
run against every element of the list

00:10:45,230 --> 00:10:49,880
so when map is applied to a different

00:10:49,040 --> 00:10:52,460
kind of Hunter

00:10:49,880 --> 00:10:54,260
it runs the function you give it so

00:10:52,460 --> 00:10:57,230
every having in that photo

00:10:54,260 --> 00:10:59,540
now in the case of the future probably

00:10:57,230 --> 00:11:01,580
only one element in it probably just

00:10:59,540 --> 00:11:04,370
that one value that you're waiting for

00:11:01,580 --> 00:11:06,950
come back from HTTP over the file system

00:11:04,370 --> 00:11:10,490
when you call map on it it'll act on

00:11:06,950 --> 00:11:13,970
that one value follow the world type to

00:11:10,490 --> 00:11:15,710
the full world function can you can have

00:11:13,970 --> 00:11:19,370
a situation where all the animals of the

00:11:15,710 --> 00:11:22,370
structure folded together into a single

00:11:19,370 --> 00:11:28,790
value so you probably know this is

00:11:22,370 --> 00:11:30,440
reduce in JavaScript my map has two

00:11:28,790 --> 00:11:34,160
functions in the fantasyland

00:11:30,440 --> 00:11:37,610
specification they actually can be

00:11:34,160 --> 00:11:39,770
inherited from other types but so you've

00:11:37,610 --> 00:11:43,160
got chain which allows you to combine

00:11:39,770 --> 00:11:45,320
monads together and you've got off which

00:11:43,160 --> 00:11:49,150
lets you turn simple values into mo

00:11:45,320 --> 00:11:52,340
notes and then this will come a very end

00:11:49,150 --> 00:11:54,650
try remember though we've got I hunter I

00:11:52,340 --> 00:11:57,080
went to is the type that can hold two

00:11:54,650 --> 00:11:59,390
values and has several functions to

00:11:57,080 --> 00:12:02,030
change in those values which is left

00:11:59,390 --> 00:12:05,120
right and by none you sure it's on

00:12:02,030 --> 00:12:08,120
papyrus but you can kind of put that in

00:12:05,120 --> 00:12:11,830
your brain print it because I want to

00:12:08,120 --> 00:12:14,780
talk about a like a really cool logo

00:12:11,830 --> 00:12:18,320
this is called future I think it's

00:12:14,780 --> 00:12:20,780
called future might be called the luxury

00:12:18,320 --> 00:12:23,870
or something like that it seems more

00:12:20,780 --> 00:12:27,590
likely that it's complete check done at

00:12:23,870 --> 00:12:28,760
supply sector peak flat sorry anyway

00:12:27,590 --> 00:12:30,710
this is the what I really recommend

00:12:28,760 --> 00:12:33,140
there's a few different ways of getting

00:12:30,710 --> 00:12:35,510
up and running the futures or em here

00:12:33,140 --> 00:12:39,590
we'll get home I recommend future

00:12:35,510 --> 00:12:41,920
because of the great documentation it's

00:12:39,590 --> 00:12:44,210
got some links to some great wikis and

00:12:41,920 --> 00:12:47,270
really good articles a couple of good

00:12:44,210 --> 00:12:50,030
videos it's also measured as having the

00:12:47,270 --> 00:12:51,920
highest performance of all the future

00:12:50,030 --> 00:12:53,990
libraries and actually it seems fullness

00:12:51,920 --> 00:12:54,680
of some promise libraries so that's

00:12:53,990 --> 00:13:00,410
really good

00:12:54,680 --> 00:13:02,120
I recommend you check your name so we're

00:13:00,410 --> 00:13:03,770
kind of kind of point where we can

00:13:02,120 --> 00:13:05,690
actually start talking about features I

00:13:03,770 --> 00:13:07,640
think we've done the grain work because

00:13:05,690 --> 00:13:09,800
not something about this tight so if you

00:13:07,640 --> 00:13:12,399
remember I showed you a slide about how

00:13:09,800 --> 00:13:14,430
we might want to create a promise

00:13:12,399 --> 00:13:18,339
this is how you might create future

00:13:14,430 --> 00:13:22,230
looking really similar so far so the new

00:13:18,339 --> 00:13:25,449
keyword their new future reject reject

00:13:22,230 --> 00:13:28,089
okay I'll stick opposite way right so

00:13:25,449 --> 00:13:29,949
when you make the promise to resolve the

00:13:28,089 --> 00:13:33,160
reject when you make the future reject

00:13:29,949 --> 00:13:37,240
the result in futures error case always

00:13:33,160 --> 00:13:40,629
comes first because there's no way of

00:13:37,240 --> 00:13:45,300
ignoring the error case in futures just

00:13:40,629 --> 00:13:45,300
design decision a really sensible design

00:13:45,660 --> 00:13:50,829
at this point you would do or your async

00:13:48,480 --> 00:13:52,990
you start your underlying process

00:13:50,829 --> 00:13:55,360
whenever that might be when it comes

00:13:52,990 --> 00:13:58,480
back with success resolve when it comes

00:13:55,360 --> 00:14:00,550
with heylia you can't reject so all

00:13:58,480 --> 00:14:05,110
really similar so fun here's a concrete

00:14:00,550 --> 00:14:09,089
example of a little bit of node.js that

00:14:05,110 --> 00:14:13,230
i have converted to be to use a future

00:14:09,089 --> 00:14:17,589
so you've got read file as you'd expect

00:14:13,230 --> 00:14:22,209
takes apology as the argument we then

00:14:17,589 --> 00:14:26,819
move go too far we then instantiate our

00:14:22,209 --> 00:14:30,639
future with projecting yourself we call

00:14:26,819 --> 00:14:34,360
FS file system don't read file if you

00:14:30,639 --> 00:14:36,490
don't know note i don't think it should

00:14:34,360 --> 00:14:37,509
be a big problem i think the concepts of

00:14:36,490 --> 00:14:42,220
reading the file from a hard drive

00:14:37,509 --> 00:14:43,600
should be pretty straightforward utf-8

00:14:42,220 --> 00:14:47,379
is just encodings just something you

00:14:43,600 --> 00:14:48,730
need to write so takes the file name

00:14:47,379 --> 00:14:54,370
thanks team coding

00:14:48,730 --> 00:14:54,999
start an otoscope callback eric data if

00:14:54,370 --> 00:14:58,720
there's an error

00:14:54,999 --> 00:15:06,389
I reject providing the Heron helps lies

00:14:58,720 --> 00:15:09,490
a result and then the rest is just so

00:15:06,389 --> 00:15:10,480
once you've got your future maybe you've

00:15:09,490 --> 00:15:11,800
made it yourself

00:15:10,480 --> 00:15:13,569
maybe you're lucky enough that you're

00:15:11,800 --> 00:15:19,959
working with a library that exposes the

00:15:13,569 --> 00:15:21,399
futures API you then probably want to do

00:15:19,959 --> 00:15:21,759
things with the value that you've waited

00:15:21,399 --> 00:15:23,769
for

00:15:21,759 --> 00:15:26,120
we'd you've waited for it you fetched it

00:15:23,769 --> 00:15:28,589
from somewhere you must be

00:15:26,120 --> 00:15:31,320
and the really cool thing this is where

00:15:28,589 --> 00:15:34,130
those type classes start kicking it so a

00:15:31,320 --> 00:15:38,250
future is a functor if you remember that

00:15:34,130 --> 00:15:41,579
other boat that it can be mapped so what

00:15:38,250 --> 00:15:47,490
it can do is they have got a future of

00:15:41,579 --> 00:15:50,550
teeth I can map that probably my add one

00:15:47,490 --> 00:15:53,220
function and what I get I get out a

00:15:50,550 --> 00:15:55,350
future which holds the value three so

00:15:53,220 --> 00:15:57,000
relative transformation or I have

00:15:55,350 --> 00:15:59,970
prepared a transformation for that

00:15:57,000 --> 00:16:01,410
future slight difference get to in a

00:15:59,970 --> 00:16:04,950
minute

00:16:01,410 --> 00:16:09,180
same way of the era state so if your

00:16:04,950 --> 00:16:12,390
future is holding a fatal state in this

00:16:09,180 --> 00:16:14,970
case coming your string describing the

00:16:12,390 --> 00:16:17,790
type of area we can map over that as

00:16:14,970 --> 00:16:18,930
well in this case it could have been

00:16:17,790 --> 00:16:20,910
laws what you put in this much

00:16:18,930 --> 00:16:22,860
transformation and just carries on

00:16:20,910 --> 00:16:28,500
returning a future of the contents same

00:16:22,860 --> 00:16:34,350
errand so how do you get stuff eight of

00:16:28,500 --> 00:16:37,709
the future well two to finish off the

00:16:34,350 --> 00:16:41,160
future you have to go org what that does

00:16:37,709 --> 00:16:43,079
is it actually begins the computation so

00:16:41,160 --> 00:16:45,390
the point in which you call fork that's

00:16:43,079 --> 00:16:52,500
when that underlying async process kicks

00:16:45,390 --> 00:16:54,959
off okay so I make my future I do any

00:16:52,500 --> 00:16:58,279
sorts of transformations I want and then

00:16:54,959 --> 00:17:00,630
I'll call fork so as I said earlier

00:16:58,279 --> 00:17:03,450
futures are really really keen of making

00:17:00,630 --> 00:17:06,480
sure you handle your errors most future

00:17:03,450 --> 00:17:08,640
libraries will will throw errors if you

00:17:06,480 --> 00:17:10,410
don't provide two functions and you have

00:17:08,640 --> 00:17:12,750
to provide an error callback the error

00:17:10,410 --> 00:17:14,760
callbacks first it's very important and

00:17:12,750 --> 00:17:20,250
a success callback the success callback

00:17:14,760 --> 00:17:22,350
is second and these callbacks let you

00:17:20,250 --> 00:17:24,030
handle basically what comes out of your

00:17:22,350 --> 00:17:29,630
future to add all the subsequent

00:17:24,030 --> 00:17:31,580
transformations so

00:17:29,630 --> 00:17:33,440
come back to the homeowner thing

00:17:31,580 --> 00:17:37,250
unfortunately there was only a matter of

00:17:33,440 --> 00:17:41,360
time so I said that my notes have a

00:17:37,250 --> 00:17:47,300
chain function for combining with other

00:17:41,360 --> 00:17:50,200
monads so in the case of teachers the

00:17:47,300 --> 00:17:52,940
chain function will take the value

00:17:50,200 --> 00:17:54,620
wrapped up in your future so maybe

00:17:52,940 --> 00:17:57,400
you've got the number two with that like

00:17:54,620 --> 00:18:01,880
we've had a couple of times

00:17:57,400 --> 00:18:05,420
it must return a new monnet okay so I'd

00:18:01,880 --> 00:18:08,240
like map where we were able to take 210

00:18:05,420 --> 00:18:10,370
3 if we call chain we wouldn't be able

00:18:08,240 --> 00:18:13,730
to do that 3 would not be a valid return

00:18:10,370 --> 00:18:17,240
value it'd have to be a new moment ok so

00:18:13,730 --> 00:18:20,840
this could be used to chain different

00:18:17,240 --> 00:18:22,910
asynchronous actions ok so maybe you

00:18:20,840 --> 00:18:24,290
need to fetch something from HTTP and

00:18:22,910 --> 00:18:26,480
then you have to fetch something else

00:18:24,290 --> 00:18:29,570
from a different end point somewhere

00:18:26,480 --> 00:18:30,830
that's when the use case for chain comes

00:18:29,570 --> 00:18:32,750
in when you need to do something

00:18:30,830 --> 00:18:34,370
asynchronous and then another thing

00:18:32,750 --> 00:18:38,870
that's asynchronous so I'll give you a

00:18:34,370 --> 00:18:43,340
pet example here so I've got refiled but

00:18:38,870 --> 00:18:47,150
I spoke to you earlier I'm reading file

00:18:43,340 --> 00:18:49,520
conversion dot txt now this isn't the

00:18:47,150 --> 00:18:51,790
way to do software versioning just to be

00:18:49,520 --> 00:18:53,300
really really clear especially in your

00:18:51,790 --> 00:18:55,880
JavaScript there's a thing called

00:18:53,300 --> 00:18:58,520
package dot J's new stuffs em both way

00:18:55,880 --> 00:19:00,560
better but for this example we're

00:18:58,520 --> 00:19:04,580
loading version dot txt this is this is

00:19:00,560 --> 00:19:05,810
a text file with a number in it so as

00:19:04,580 --> 00:19:07,160
you can imagine we're going to think

00:19:05,810 --> 00:19:10,580
that thing we always do we're going to

00:19:07,160 --> 00:19:14,390
increment a number add one to it and

00:19:10,580 --> 00:19:17,360
then change something this is where we

00:19:14,390 --> 00:19:18,100
take our new measurement and we do write

00:19:17,360 --> 00:19:21,290
file

00:19:18,100 --> 00:19:24,650
Activision dot txt without new version

00:19:21,290 --> 00:19:27,710
of the selection so that we need to

00:19:24,650 --> 00:19:31,130
forget this tells the future to begin

00:19:27,710 --> 00:19:32,600
its computation with a total load

00:19:31,130 --> 00:19:35,410
conselheiro here for the every case

00:19:32,600 --> 00:19:38,360
could not save and give the reason white

00:19:35,410 --> 00:19:41,090
and it's a test case safety new version

00:19:38,360 --> 00:19:43,280
of that that is a working program I

00:19:41,090 --> 00:19:47,510
probably need some imports at the top

00:19:43,280 --> 00:19:49,640
this is JavaScript but compilers from

00:19:47,510 --> 00:19:53,050
just a few tiny parts you've got a

00:19:49,640 --> 00:19:56,630
working semi useful set a useful program

00:19:53,050 --> 00:19:59,600
for completeness that's a lot right fine

00:19:56,630 --> 00:20:01,340
would look like kind of encased in that

00:19:59,600 --> 00:20:07,070
notes I'll come back right part of the

00:20:01,340 --> 00:20:12,530
future hey won't come with that yeah

00:20:07,070 --> 00:20:13,880
yeah little bit me it appears a little

00:20:12,530 --> 00:20:15,290
bit more fiddly compromises with

00:20:13,880 --> 00:20:17,890
promises you'd be able to do the same

00:20:15,290 --> 00:20:22,490
thing and you just beyond so kind of

00:20:17,890 --> 00:20:26,530
them then it's a lot easier then dot and

00:20:22,490 --> 00:20:43,840
this forces you to be more precise but

00:20:26,530 --> 00:20:47,540
so far you know what's the benefit so I

00:20:43,840 --> 00:20:49,880
start getting into the actual benefits

00:20:47,540 --> 00:20:53,060
of futures because so far they seem like

00:20:49,880 --> 00:20:55,810
a slightly more fiddly province okay so

00:20:53,060 --> 00:20:59,620
we've seen how how we can use chain

00:20:55,810 --> 00:21:02,030
so-called to two futures in series

00:20:59,620 --> 00:21:04,220
sometimes there are common use cases

00:21:02,030 --> 00:21:06,500
where you need to call stuff in parallel

00:21:04,220 --> 00:21:08,780
so maybe there's a bunch of stuff that

00:21:06,500 --> 00:21:11,000
you need to fetch it once or just a mode

00:21:08,780 --> 00:21:12,920
of asynchronous thing just don't depend

00:21:11,000 --> 00:21:16,910
but another and you don't want them kind

00:21:12,920 --> 00:21:22,030
of lock in each other so here's a

00:21:16,910 --> 00:21:26,480
technique to do that and this is

00:21:22,030 --> 00:21:28,180
specific to the future library I'm going

00:21:26,480 --> 00:21:32,990
to talk about problems there in a moment

00:21:28,180 --> 00:21:35,240
so you can do future but peridot you can

00:21:32,990 --> 00:21:38,330
pass in a concurrency with it at this

00:21:35,240 --> 00:21:41,270
point so this basically tells it how

00:21:38,330 --> 00:21:44,390
many features to keep him fluent at once

00:21:41,270 --> 00:21:46,460
this means that you don't overload the

00:21:44,390 --> 00:21:48,710
system that you're calling out to if you

00:21:46,460 --> 00:21:51,530
have no concerns about that you can just

00:21:48,710 --> 00:21:54,840
use the number of into here second

00:21:51,530 --> 00:21:58,840
argument will be an array of features

00:21:54,840 --> 00:22:03,220
and what comes out of a parallel is a

00:21:58,840 --> 00:22:05,310
future that contains a list of the

00:22:03,220 --> 00:22:07,450
results from all those other features

00:22:05,310 --> 00:22:10,870
okay so I'll just go over that one more

00:22:07,450 --> 00:22:14,830
time what goes in in on the list of

00:22:10,870 --> 00:22:17,860
futures what comes out is a future of a

00:22:14,830 --> 00:22:19,660
list okay so you can see the types got

00:22:17,860 --> 00:22:21,790
kind of knocked over into their sites

00:22:19,660 --> 00:22:25,300
okay

00:22:21,790 --> 00:22:27,070
it's got this built in rate limiting so

00:22:25,300 --> 00:22:29,410
in this instance where I've set my limit

00:22:27,070 --> 00:22:32,830
is five I've got my futures as a couple

00:22:29,410 --> 00:22:34,360
of read files the result of the contents

00:22:32,830 --> 00:22:37,780
of file one and the contents of party

00:22:34,360 --> 00:22:39,850
yes is that sequence this is not in

00:22:37,780 --> 00:22:43,690
sequence this is no no it's not the same

00:22:39,850 --> 00:22:48,940
as sequence yes yeah yeah I'm going to

00:22:43,690 --> 00:22:49,900
get right to that cold so understand I

00:22:48,940 --> 00:22:54,010
was feeling a little bit problematic

00:22:49,900 --> 00:22:57,520
about the fact that parallels is mr.

00:22:54,010 --> 00:23:02,820
fiction future library in fact I'm kind

00:22:57,520 --> 00:23:04,720
of almost prepared in advance all the

00:23:02,820 --> 00:23:07,480
functions that I thought we would be

00:23:04,720 --> 00:23:08,920
using today I talked about chain about

00:23:07,480 --> 00:23:11,740
map I talked about oh I didn't mention

00:23:08,920 --> 00:23:12,370
parallel in there anyway so what's the

00:23:11,740 --> 00:23:16,150
deal with that

00:23:12,370 --> 00:23:19,780
well isn't interesting quote embodied

00:23:16,150 --> 00:23:23,950
success at all costs dr. Simon Paton

00:23:19,780 --> 00:23:26,440
Jones say what he doesn't need well he's

00:23:23,950 --> 00:23:28,480
not trying to do this is so this is the

00:23:26,440 --> 00:23:31,150
creator of Haskell wouldn't one of the

00:23:28,480 --> 00:23:34,450
creators of Haskell one of the maintain

00:23:31,150 --> 00:23:36,550
is its compiler what he never means by

00:23:34,450 --> 00:23:38,920
saying this and it's a little program

00:23:36,550 --> 00:23:42,250
that Jake witness he doesn't mean that

00:23:38,920 --> 00:23:44,500
he's trying to avoid success that's not

00:23:42,250 --> 00:23:46,600
what it means he's not scared of success

00:23:44,500 --> 00:23:49,120
he's not worried about giving away his

00:23:46,600 --> 00:23:51,490
cool language he wants success but what

00:23:49,120 --> 00:23:55,060
he doesn't want is part of the sentence

00:23:51,490 --> 00:23:57,010
success at all costs he thinks that is

00:23:55,060 --> 00:24:00,810
something to be avoided what is

00:23:57,010 --> 00:24:03,490
successful costs successful costs is

00:24:00,810 --> 00:24:05,060
succeeding at the expense of something

00:24:03,490 --> 00:24:07,690
else okay

00:24:05,060 --> 00:24:12,410
in the case of functional programming I

00:24:07,690 --> 00:24:14,570
think it's up 7-pin Jones's case he

00:24:12,410 --> 00:24:16,940
doesn't want to succeed at the cost of

00:24:14,570 --> 00:24:18,920
his descendants okay

00:24:16,940 --> 00:24:22,160
and I think this instance where we've

00:24:18,920 --> 00:24:23,870
used a parallel function is perhaps a

00:24:22,160 --> 00:24:27,050
case of us succeeding at the cost of our

00:24:23,870 --> 00:24:28,910
principles because by using a function

00:24:27,050 --> 00:24:32,270
that isn't type of a type part of the

00:24:28,910 --> 00:24:36,260
type cuts like now locked myself into

00:24:32,270 --> 00:24:39,160
the library future I've failed to learn

00:24:36,260 --> 00:24:43,250
something as well so by seeing this

00:24:39,160 --> 00:24:44,570
really useful really successful in

00:24:43,250 --> 00:24:47,660
parallel function

00:24:44,570 --> 00:24:51,920
I now haven't had to learn how to really

00:24:47,660 --> 00:24:54,230
do and how you really do it is a little

00:24:51,920 --> 00:24:57,560
bit more complex so how you might really

00:24:54,230 --> 00:25:01,100
want to tackle this is to use a more

00:24:57,560 --> 00:25:02,960
generic function called Traverse trigger

00:25:01,100 --> 00:25:05,480
this well let me do exactly the same

00:25:02,960 --> 00:25:08,090
thing it will let me take a list of

00:25:05,480 --> 00:25:13,010
futures and turn it into a future of

00:25:08,090 --> 00:25:15,290
lists let me do that 90 degree turn what

00:25:13,010 --> 00:25:18,560
it does it does it in a way that works

00:25:15,290 --> 00:25:21,020
at any photo Lonette and that is

00:25:18,560 --> 00:25:24,430
powerful and the reason that is powerful

00:25:21,020 --> 00:25:29,150
is because at that point it's not an API

00:25:24,430 --> 00:25:33,500
it's a grammar the beauty of learning

00:25:29,150 --> 00:25:36,980
small reusable pieces that can be

00:25:33,500 --> 00:25:40,220
combined in different ways is the core

00:25:36,980 --> 00:25:42,530
of functional programming at the point

00:25:40,220 --> 00:25:44,480
at which you start flooding your API

00:25:42,530 --> 00:25:47,390
with a hundred functions 300 potions

00:25:44,480 --> 00:25:50,360
four five six big libraries you've lost

00:25:47,390 --> 00:25:53,870
that elegance you have succeeded at too

00:25:50,360 --> 00:25:57,380
high a cost if you can build your

00:25:53,870 --> 00:25:59,840
programs in the smallest components from

00:25:57,380 --> 00:26:02,330
the smallest grammars and an infinite

00:25:59,840 --> 00:26:06,560
complexity rolls out from there you

00:26:02,330 --> 00:26:08,470
succeeded with principles so I'm not

00:26:06,560 --> 00:26:10,520
going to have time tonight to actually

00:26:08,470 --> 00:26:13,100
show you some of the better ways to do

00:26:10,520 --> 00:26:16,970
parallelism but just like that when you

00:26:13,100 --> 00:26:18,100
save a little nugget your minds so well

00:26:16,970 --> 00:26:21,100
you want to talk about

00:26:18,100 --> 00:26:23,590
is why term I thought about this one a

00:26:21,100 --> 00:26:28,299
long time a really good futures a use

00:26:23,590 --> 00:26:33,150
case okay and this is error tolerance so

00:26:28,299 --> 00:26:37,690
this okay mo came up with work okay so

00:26:33,150 --> 00:26:40,210
we've built we've got having I realize

00:26:37,690 --> 00:26:43,179
that what slide got missed at the start

00:26:40,210 --> 00:26:45,580
neg I'm gonna get back a second so the

00:26:43,179 --> 00:26:50,710
slider got missed there's a slide about

00:26:45,580 --> 00:26:55,059
Who I am to take you on this genuine

00:26:50,710 --> 00:26:58,419
Peter's new line new is this guy is his

00:26:55,059 --> 00:27:00,789
deal so I will share the slides at the

00:26:58,419 --> 00:27:01,240
end I'll marked with this nice to meet

00:27:00,789 --> 00:27:04,030
you

00:27:01,240 --> 00:27:05,559
I work for a company calm happy we do

00:27:04,030 --> 00:27:07,330
kind of work in software with based here

00:27:05,559 --> 00:27:08,620
in Bristol and then we'll also some

00:27:07,330 --> 00:27:10,720
other stuff they were stuff about my

00:27:08,620 --> 00:27:12,370
beard I keep some parasites and pictures

00:27:10,720 --> 00:27:13,450
of parents I don't know I've been a

00:27:12,370 --> 00:27:15,840
white or got lost

00:27:13,450 --> 00:27:19,690
it's got my kind of get over my Twitter

00:27:15,840 --> 00:27:25,690
so just pretend you saw there and it

00:27:19,690 --> 00:27:29,980
will happen right so we've got happy on

00:27:25,690 --> 00:27:33,429
AWS Lanza which are kind of which has

00:27:29,980 --> 00:27:37,600
service functions that exist in the

00:27:33,429 --> 00:27:39,130
cloud so what else's computer the really

00:27:37,600 --> 00:27:42,100
nice thing about this is we don't have a

00:27:39,130 --> 00:27:45,250
single ec2 instance we don't have to

00:27:42,100 --> 00:27:48,070
manage any databases a drawback of this

00:27:45,250 --> 00:27:49,960
is that you have to have all your useful

00:27:48,070 --> 00:27:55,240
work done in I'm function within five

00:27:49,960 --> 00:27:58,270
minutes at most so we have a few kind of

00:27:55,240 --> 00:28:00,580
end-of-month processes take longer than

00:27:58,270 --> 00:28:03,520
five minutes so we didn't want to just

00:28:00,580 --> 00:28:05,200
spin up an ec2 instance some write an

00:28:03,520 --> 00:28:09,520
Express server that would be too easy so

00:28:05,200 --> 00:28:12,970
when we wanted to keep it all hosted and

00:28:09,520 --> 00:28:16,870
keep it all managed so we came up with a

00:28:12,970 --> 00:28:20,600
cue system so we used only Mon bébé

00:28:16,870 --> 00:28:24,710
streams as our kind of cute

00:28:20,600 --> 00:28:27,080
and so what what the keep does is it

00:28:24,710 --> 00:28:28,789
allows you to cut a hole jobs in like

00:28:27,080 --> 00:28:31,159
way more than a single line the function

00:28:28,789 --> 00:28:33,259
will be up to handle and then they kind

00:28:31,159 --> 00:28:37,669
of just like a real cue like a nightclub

00:28:33,259 --> 00:28:39,769
or whatever then as the cube that's the

00:28:37,669 --> 00:28:44,899
doorman that's a batch of five in closes

00:28:39,769 --> 00:28:49,580
the thought yeah able a synchronously

00:28:44,899 --> 00:28:52,460
resolved I'm pretty sure I haven't been

00:28:49,580 --> 00:28:57,049
clubbing in a long time I remember it

00:28:52,460 --> 00:28:59,389
being a bit like that so this is what

00:28:57,049 --> 00:29:01,610
happens in having our big list of jobs

00:28:59,389 --> 00:29:04,309
in our case it's kind of indifferent

00:29:01,610 --> 00:29:07,070
binning where we challenge people on

00:29:04,309 --> 00:29:10,960
behalf of other people I'm able to take

00:29:07,070 --> 00:29:13,909
a few minutes time and resolve them so

00:29:10,960 --> 00:29:16,279
I've been about using process I thought

00:29:13,909 --> 00:29:17,059
honesty is good I'll take my batch of

00:29:16,279 --> 00:29:20,659
five jobs

00:29:17,059 --> 00:29:24,139
I'll put it all in a promise to all oh

00:29:20,659 --> 00:29:26,840
no some failed rather than failed if one

00:29:24,139 --> 00:29:28,940
fails they all fail that's a bit of a

00:29:26,840 --> 00:29:30,139
problem because I want to know the

00:29:28,940 --> 00:29:32,600
successes and I want to know the

00:29:30,139 --> 00:29:35,509
failures either successes I want to

00:29:32,600 --> 00:29:38,299
write the back to the DynamoDB table and

00:29:35,509 --> 00:29:40,399
say succeeded and for the failures I

00:29:38,299 --> 00:29:43,639
want to increment a retry number and

00:29:40,399 --> 00:29:45,080
leave the statuses is ready to go so

00:29:43,639 --> 00:29:48,440
that they go back to the back of the

00:29:45,080 --> 00:29:50,059
queue and they try again later so the

00:29:48,440 --> 00:29:57,799
fact that price that all failed them all

00:29:50,059 --> 00:30:00,500
it's a big problem so as promised like

00:29:57,799 --> 00:30:02,059
we called Bluebird the providing utility

00:30:00,500 --> 00:30:03,649
function for handle in this situation I

00:30:02,059 --> 00:30:05,029
saw how brilliant I use that in my last

00:30:03,649 --> 00:30:07,159
job that would be great I'm looking at

00:30:05,029 --> 00:30:10,039
this called settle so I go to the

00:30:07,159 --> 00:30:13,429
Bluebird website and I look up settled

00:30:10,039 --> 00:30:15,889
it's not that it's the API version 3 now

00:30:13,429 --> 00:30:18,230
it's called something else I definitely

00:30:15,889 --> 00:30:21,250
forgot what it's called and that's kind

00:30:18,230 --> 00:30:25,490
of the point right it's got a specific

00:30:21,250 --> 00:30:26,570
vendor locking style API if you forget

00:30:25,490 --> 00:30:27,049
what it's called you forget what it's

00:30:26,570 --> 00:30:30,440
called

00:30:27,049 --> 00:30:32,930
anyway I implemented it with Bluebird

00:30:30,440 --> 00:30:36,200
worked really nicely my colleagues sound

00:30:32,930 --> 00:30:37,670
said that he said we've got these we've

00:30:36,200 --> 00:30:39,980
got these handlers that we wrap around I

00:30:37,670 --> 00:30:43,070
like the functions and I don't know if

00:30:39,980 --> 00:30:44,780
you noticed they're using generic a plus

00:30:43,070 --> 00:30:46,550
spec promises I don't want them time to

00:30:44,780 --> 00:30:49,070
believe it it's just one implementation

00:30:46,550 --> 00:30:53,120
I was like okay maybe there's a better

00:30:49,070 --> 00:30:54,380
way so I thought well I've seen I've

00:30:53,120 --> 00:30:55,610
seen these features things that it be

00:30:54,380 --> 00:30:59,150
research on them before and I thought

00:30:55,610 --> 00:31:03,200
well let's try futures so I tried future

00:30:59,150 --> 00:31:05,600
parallel check my five jumps in at one

00:31:03,200 --> 00:31:08,180
fails and they all fail that's a problem

00:31:05,600 --> 00:31:10,400
right how do i how do I result how do I

00:31:08,180 --> 00:31:16,070
make them all look as if they've

00:31:10,400 --> 00:31:18,140
succeeded and your futures as an actual

00:31:16,070 --> 00:31:20,360
way to do it an actual sensible way

00:31:18,140 --> 00:31:23,750
using these type classes using this

00:31:20,360 --> 00:31:28,070
grammar using this small simple API

00:31:23,750 --> 00:31:31,640
there's a way of doing it and it's it

00:31:28,070 --> 00:31:35,060
involves the ether type so quick aside

00:31:31,640 --> 00:31:37,880
onto one either is and either is going

00:31:35,060 --> 00:31:41,390
to feel a lot like a future okay and

00:31:37,880 --> 00:31:43,940
either is a wrapper for about you which

00:31:41,390 --> 00:31:47,120
can either be one thing or another thing

00:31:43,940 --> 00:31:51,290
you can either be the left or right by

00:31:47,120 --> 00:31:54,830
convention we generally put a success

00:31:51,290 --> 00:31:56,120
value in the right hand side of an

00:31:54,830 --> 00:31:58,640
either think of it as like two little

00:31:56,120 --> 00:32:01,370
boxes made it we put the success in the

00:31:58,640 --> 00:32:04,460
right because right is right like

00:32:01,370 --> 00:32:07,820
correct it's not a political statement

00:32:04,460 --> 00:32:10,370
it's because everyone wonder how we use

00:32:07,820 --> 00:32:15,590
left for the area because it's the only

00:32:10,370 --> 00:32:19,370
business name so you code and either we

00:32:15,590 --> 00:32:21,830
look at it like this either Peninsula

00:32:19,370 --> 00:32:24,770
neither library not right put value in

00:32:21,830 --> 00:32:26,360
say five I don't know we can stop

00:32:24,770 --> 00:32:28,760
calling map against it because it's a

00:32:26,360 --> 00:32:30,560
filter we get to reuse these things

00:32:28,760 --> 00:32:33,550
again and again and again and what you

00:32:30,560 --> 00:32:36,170
get are you gonna write the score six in

00:32:33,550 --> 00:32:38,930
either thought that as per our messaging

00:32:36,170 --> 00:32:39,410
know a number Oh suddenly sounds

00:32:38,930 --> 00:32:40,769
interesting

00:32:39,410 --> 00:32:43,369
no matter I was great

00:32:40,769 --> 00:32:46,679
easy way of handling not under specific

00:32:43,369 --> 00:32:49,409
citing again we map it what comes out

00:32:46,679 --> 00:32:52,379
not number doesn't even touch it doesn't

00:32:49,409 --> 00:32:54,210
throw an error we've taken a we've taken

00:32:52,379 --> 00:32:56,159
they're not a number and tried to add

00:32:54,210 --> 00:32:58,710
one to it didn't even personnel exclude

00:32:56,159 --> 00:33:03,210
it it's also got these five app

00:32:58,710 --> 00:33:05,820
functions which let you put let you put

00:33:03,210 --> 00:33:08,039
a function for running against the value

00:33:05,820 --> 00:33:09,119
in the net box on the left function for

00:33:08,039 --> 00:33:11,159
running against the value in the right

00:33:09,119 --> 00:33:13,409
box on the right and then it calls the

00:33:11,159 --> 00:33:15,629
appropriate one based on what value that

00:33:13,409 --> 00:33:20,730
hasn't it so in this case if it's got a

00:33:15,629 --> 00:33:22,379
righty value it adds one Lefty value it

00:33:20,730 --> 00:33:28,519
goes all exclamation marking

00:33:22,379 --> 00:33:28,519
okay so thanks that's either why did

00:33:28,940 --> 00:33:35,909
well it did at work have it was I made

00:33:33,600 --> 00:33:37,529
this air intolerant batch handler this

00:33:35,909 --> 00:33:42,029
isn't the exact code really similar

00:33:37,529 --> 00:33:47,100
though so I've got my cucumber takes my

00:33:42,029 --> 00:33:48,720
array of futures future not parallel put

00:33:47,100 --> 00:33:52,499
in my linear it wouldn't be really five

00:33:48,720 --> 00:33:55,230
and B in configuration somewhere and

00:33:52,499 --> 00:33:56,730
then I'm at home in my futures we're

00:33:55,230 --> 00:34:00,869
mapping over a list here we're not

00:33:56,730 --> 00:34:10,349
nothing to the future and then I fold my

00:34:00,869 --> 00:34:12,540
future into left or right okay so you're

00:34:10,349 --> 00:34:15,240
all remember fold forward lets you take

00:34:12,540 --> 00:34:19,649
elements of the sequence and turn them

00:34:15,240 --> 00:34:22,139
into one value okay so in the case of

00:34:19,649 --> 00:34:24,929
the list we might have list of numbers

00:34:22,139 --> 00:34:28,440
one two three if we fold them all up

00:34:24,929 --> 00:34:30,720
with the the summer value I come up a

00:34:28,440 --> 00:34:33,119
six so it turned multiple things into

00:34:30,720 --> 00:34:35,790
one thing in the case of folding over a

00:34:33,119 --> 00:34:39,000
future you've turned the multiple

00:34:35,790 --> 00:34:41,099
potential values success on the Left

00:34:39,000 --> 00:34:45,760
failure on the right we've turned them

00:34:41,099 --> 00:34:49,119
into one thing which is always success

00:34:45,760 --> 00:34:51,820
okay so our futures are always mapped to

00:34:49,119 --> 00:34:53,200
a success we've been getting weird with

00:34:51,820 --> 00:34:57,150
chucking away the fact that they may

00:34:53,200 --> 00:35:00,760
fail but because we've now gotten either

00:34:57,150 --> 00:35:03,010
inside our future the either tells us

00:35:00,760 --> 00:35:05,350
whether it failed or succeeded so we

00:35:03,010 --> 00:35:08,290
haven't lost the information we've just

00:35:05,350 --> 00:35:12,880
hidden it buried inside the either okay

00:35:08,290 --> 00:35:14,830
so now - the future is they're all going

00:35:12,880 --> 00:35:16,990
to succeed they're all going to succeed

00:35:14,830 --> 00:35:19,359
but they're going to hold that failure

00:35:16,990 --> 00:35:23,520
or success data inside of their

00:35:19,359 --> 00:35:25,720
structure so at this point I know now

00:35:23,520 --> 00:35:28,090
all five of my future's are going to

00:35:25,720 --> 00:35:31,090
succeed and so I'm definitely gonna end

00:35:28,090 --> 00:35:33,190
up in the positive side of my book in

00:35:31,090 --> 00:35:37,330
that case I can call a function put

00:35:33,190 --> 00:35:40,720
value funny is like fork but you don't

00:35:37,330 --> 00:35:43,450
have to supply America you only have to

00:35:40,720 --> 00:35:47,680
supply the success case and it gives me

00:35:43,450 --> 00:35:49,570
my list of others so I can do them as I

00:35:47,680 --> 00:35:53,619
can extract the successes from them I

00:35:49,570 --> 00:35:55,750
can extract the failures from them I can

00:35:53,619 --> 00:35:58,300
record back into my database which ones

00:35:55,750 --> 00:36:02,830
succeeded which ones failed I can look

00:35:58,300 --> 00:36:04,090
at the failures and I've done so really

00:36:02,830 --> 00:36:07,090
really similar to the code we put into

00:36:04,090 --> 00:36:09,880
production this is so in there's a tiny

00:36:07,090 --> 00:36:12,490
amount of code using simple principles

00:36:09,880 --> 00:36:17,040
using the grammar of algebraic data

00:36:12,490 --> 00:36:20,530
types I've created simple reusable

00:36:17,040 --> 00:36:24,369
system or giving me an error tolerant

00:36:20,530 --> 00:36:26,800
key I'm really pleased about so into the

00:36:24,369 --> 00:36:28,109
conclusion apart should we be using

00:36:26,800 --> 00:36:30,250
these things

00:36:28,109 --> 00:36:31,540
another thing I've said tonight convince

00:36:30,250 --> 00:36:34,060
you that features might be worth and

00:36:31,540 --> 00:36:36,390
look at so I think what we want to do is

00:36:34,060 --> 00:36:39,670
go into some of the pros and cons

00:36:36,390 --> 00:36:41,140
because of the length of this piece the

00:36:39,670 --> 00:36:43,210
United content I was trying to squeeze

00:36:41,140 --> 00:36:47,740
in some of these pros I haven't actually

00:36:43,210 --> 00:36:50,470
even mentioned yet and so one thing I

00:36:47,740 --> 00:36:53,650
have some a lot of my it's got a precise

00:36:50,470 --> 00:36:56,920
API it's got this kind of grammar based

00:36:53,650 --> 00:36:58,940
API with consistency across different

00:36:56,920 --> 00:37:02,839
vendors so whether I'm using

00:36:58,940 --> 00:37:04,690
cause future future data's our future

00:37:02,839 --> 00:37:06,920
I'm getting a level of consistency

00:37:04,690 --> 00:37:08,569
because they all implement that they all

00:37:06,920 --> 00:37:10,640
implemented chain they all implement of

00:37:08,569 --> 00:37:13,789
they all import right you've got that

00:37:10,640 --> 00:37:16,579
consistency next up we've got great

00:37:13,789 --> 00:37:20,299
compatibility with all over fantasy and

00:37:16,579 --> 00:37:23,920
complaint monads focus etc so we got

00:37:20,299 --> 00:37:27,470
that compatibility angle so it's a lazy

00:37:23,920 --> 00:37:28,849
so laziness is a big advantage to

00:37:27,470 --> 00:37:30,549
functional programmers thinking about

00:37:28,849 --> 00:37:35,500
this job you already if you can be lazy

00:37:30,549 --> 00:37:38,299
it means that this really nice way of

00:37:35,500 --> 00:37:39,829
encapsulating side effects because they

00:37:38,299 --> 00:37:40,690
need to start happening in two equal

00:37:39,829 --> 00:37:44,450
four

00:37:40,690 --> 00:37:47,359
and also it can be cancelled this is

00:37:44,450 --> 00:37:48,589
just a straight-up efficiency game if

00:37:47,359 --> 00:37:52,490
you imagine if you had a promise that

00:37:48,589 --> 00:37:53,660
all the future not parallel or if you do

00:37:52,490 --> 00:37:57,319
not reverse whatever you want to think

00:37:53,660 --> 00:38:00,890
of it whatever those comes back in the

00:37:57,319 --> 00:38:02,359
fania you don't it stops

00:38:00,890 --> 00:38:06,760
you don't care about the rest of the

00:38:02,359 --> 00:38:10,599
results in the case of promised at all

00:38:06,760 --> 00:38:13,819
all those other four still carry on

00:38:10,599 --> 00:38:16,099
doing the underlying async operation

00:38:13,819 --> 00:38:18,380
though that's talking to HTTP whether

00:38:16,099 --> 00:38:19,460
life accessing the file system you can't

00:38:18,380 --> 00:38:21,680
tell them to stop

00:38:19,460 --> 00:38:23,869
so from an efficient efficiency

00:38:21,680 --> 00:38:25,569
perspective they're doing stuff in your

00:38:23,869 --> 00:38:28,390
program but they don't need to be doing

00:38:25,569 --> 00:38:30,920
whereas because features are cancelable

00:38:28,390 --> 00:38:32,450
if you've got a list of five features

00:38:30,920 --> 00:38:35,960
going on and one comes about quickly

00:38:32,450 --> 00:38:40,069
with a vania it's touch the rest clear

00:38:35,960 --> 00:38:41,660
that the resources you know just

00:38:40,069 --> 00:38:46,490
efficient just an efficient thing today

00:38:41,660 --> 00:38:48,470
so the pros are promises promises are

00:38:46,490 --> 00:38:51,319
deep back to industry standard

00:38:48,470 --> 00:38:53,750
everywhere you look you see promises

00:38:51,319 --> 00:38:55,160
there are lots not so whenever you need

00:38:53,750 --> 00:38:57,380
to access something where you're waiting

00:38:55,160 --> 00:39:00,200
for a response there will be a promise

00:38:57,380 --> 00:39:03,710
version of the library that's talking to

00:39:00,200 --> 00:39:05,900
a major database talking to you I think

00:39:03,710 --> 00:39:10,549
probably that just the API imagine has a

00:39:05,900 --> 00:39:11,630
promise based interface easier to learn

00:39:10,549 --> 00:39:14,059
and remember

00:39:11,630 --> 00:39:15,859
the basic API the other basics it might

00:39:14,059 --> 00:39:19,160
get trickier because it might get very

00:39:15,859 --> 00:39:21,799
very specific but the basic API it's

00:39:19,160 --> 00:39:23,019
just then and then like you've

00:39:21,799 --> 00:39:26,900
remembered it already

00:39:23,019 --> 00:39:30,589
congratulations the other great thing by

00:39:26,900 --> 00:39:33,259
promises is async/await syntax yes i

00:39:30,589 --> 00:39:35,719
babel really really good for imperative

00:39:33,259 --> 00:39:37,789
style makes you allows you to forget

00:39:35,719 --> 00:39:39,319
that you're even working with the label

00:39:37,789 --> 00:39:41,809
use at all so if you're writing an

00:39:39,319 --> 00:39:43,999
object-oriented or an imperative style a

00:39:41,809 --> 00:39:48,140
single way it's nicely got7 that's all

00:39:43,999 --> 00:39:51,759
powered by promises and finally it's

00:39:48,140 --> 00:39:55,549
functional enough for most purposes

00:39:51,759 --> 00:39:58,009
promises why you how about 80 other uses

00:39:55,549 --> 00:40:00,079
functions you get something returned

00:39:58,009 --> 00:40:01,910
that's a really good step one if you're

00:40:00,079 --> 00:40:04,309
a functional programmer it's a lot

00:40:01,910 --> 00:40:06,380
better than a callback you're actually

00:40:04,309 --> 00:40:08,660
getting a value back you can pass it

00:40:06,380 --> 00:40:09,880
around pass it through functions a lot

00:40:08,660 --> 00:40:13,699
of the time that's good enough

00:40:09,880 --> 00:40:20,839
so in conclusion do we want to be

00:40:13,699 --> 00:40:24,549
adopting futures well level the meanings

00:40:20,839 --> 00:40:26,410
of the word adoption so matters that

00:40:24,549 --> 00:40:29,319
don't use them at all

00:40:26,410 --> 00:40:31,160
just suck up the limitations of promises

00:40:29,319 --> 00:40:34,219
sometimes the error handling is a bit

00:40:31,160 --> 00:40:35,779
wonky maybe you can't cancel them maybe

00:40:34,219 --> 00:40:38,289
that's a bit inefficient but hey maybe

00:40:35,779 --> 00:40:41,390
it's someone else isn't it inefficiency

00:40:38,289 --> 00:40:43,869
option number two use the wiki

00:40:41,390 --> 00:40:48,709
consolation or another killer feature

00:40:43,869 --> 00:40:50,719
our table so Shoji if you do this you

00:40:48,709 --> 00:40:52,249
might have an ad hoc jump job to do so

00:40:50,719 --> 00:40:53,630
you might look at this of code the view

00:40:52,249 --> 00:40:56,959
code base that could be improved by

00:40:53,630 --> 00:40:59,089
futures and the codes surrounding that

00:40:56,959 --> 00:41:01,369
you might need to convert all your

00:40:59,089 --> 00:41:03,249
promises into futures you might won't

00:41:01,369 --> 00:41:06,589
have to entirely rewrite your code base

00:41:03,249 --> 00:41:08,420
well the third approach is to go all-in

00:41:06,589 --> 00:41:13,299
wrap all of your libraries in the

00:41:08,420 --> 00:41:17,930
futures API and enjoy sweet sweet sound

00:41:13,299 --> 00:41:21,229
coding to real principles and a real

00:41:17,930 --> 00:41:23,660
fully functional approach and we've got

00:41:21,229 --> 00:41:24,470
the kind of everyone we wean these folks

00:41:23,660 --> 00:41:25,760
at

00:41:24,470 --> 00:41:28,790
we've these features a couple of times

00:41:25,760 --> 00:41:31,610
but it's made sense we haven't been as

00:41:28,790 --> 00:41:33,590
Ellison at it but yeah hopefully a

00:41:31,610 --> 00:41:36,020
little bit of food for thought a little

00:41:33,590 --> 00:41:38,690
bit of an option Utes hopefully you

00:41:36,020 --> 00:41:40,310
learned something about and why grammar

00:41:38,690 --> 00:41:43,400
based API is might be better than

00:41:40,310 --> 00:41:44,510
grab-bag api's and hopefully on a bit

00:41:43,400 --> 00:41:46,820
more back functional programming they

00:41:44,510 --> 00:41:53,179
say thank you very much

00:41:46,820 --> 00:41:53,179

YouTube URL: https://www.youtube.com/watch?v=BvyGOeyTESE


