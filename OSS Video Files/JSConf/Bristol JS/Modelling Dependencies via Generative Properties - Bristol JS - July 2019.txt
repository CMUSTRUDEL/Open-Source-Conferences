Title: Modelling Dependencies via Generative Properties - Bristol JS - July 2019
Publication date: 2019-08-08
Playlist: Bristol JS
Description: 
	Presented by William Heslam

"Don’t write tests… generate them!" - John Hughes
Property testing is a powerful and fun way to test your code that builds upon and complements unit testing.

It finds those obscure, fiddly edge-cases for you whilst automatically simplifying complicated scenarios… and all it requires is thinking hard about the kind of inputs and outputs your code might have to deal with.

In this talk I’ll introduce property testing in general and then describe a technique using it to simulate your software’s dependencies (such as network requests or databases) to help make your code more robust in the face of uncertainty.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,970
hello hi I'm will and I'm gonna be

00:00:03,060 --> 00:00:07,919
giving a talk on modeling this is in

00:00:05,970 --> 00:00:11,280
presenting mode or yeah it's really cool

00:00:07,919 --> 00:00:12,360
I'm gonna be giving a talk on modeling

00:00:11,280 --> 00:00:14,400
your dependencies as generative

00:00:12,360 --> 00:00:16,170
properties now before I begin I want to

00:00:14,400 --> 00:00:17,550
say that I work at EQ tricity we're

00:00:16,170 --> 00:00:19,859
based in this building on the fifth

00:00:17,550 --> 00:00:22,500
floor and we are hiring we're hiring for

00:00:19,859 --> 00:00:24,539
mobile devs we're rebuilding our app in

00:00:22,500 --> 00:00:27,240
native native native which is one more

00:00:24,539 --> 00:00:30,090
than native native and we're also hiring

00:00:27,240 --> 00:00:31,949
for no devs we're doing a lot of AWS

00:00:30,090 --> 00:00:33,180
lambda stuff it's very cool so if you

00:00:31,949 --> 00:00:34,710
wanted to cut your teeth on some new

00:00:33,180 --> 00:00:37,440
technology or if you could have that

00:00:34,710 --> 00:00:38,670
stuff already then talk to me or Henry

00:00:37,440 --> 00:00:41,309
Henry's in the middle of crowd there

00:00:38,670 --> 00:00:42,899
let's get a little wave there yeah cool

00:00:41,309 --> 00:00:46,140
all right can everyone hear me and see

00:00:42,899 --> 00:00:47,640
this yeah all good all right cool so um

00:00:46,140 --> 00:00:50,520
yeah I want to talk to you about

00:00:47,640 --> 00:00:52,469
property testing it's a technique that I

00:00:50,520 --> 00:00:53,699
think a lot of people may not well we

00:00:52,469 --> 00:00:56,250
may not have used they may have heard of

00:00:53,699 --> 00:00:57,690
its to do with unit testing so hopefully

00:00:56,250 --> 00:01:01,230
you all do unit testing if you don't

00:00:57,690 --> 00:01:04,110
just leave them out I'll give you a

00:01:01,230 --> 00:01:06,270
minute yeah and then after that I'm

00:01:04,110 --> 00:01:08,130
gonna introduce an idea that I'm not

00:01:06,270 --> 00:01:09,600
gonna say I invented it's not necessary

00:01:08,130 --> 00:01:11,100
a novel technique but it's something

00:01:09,600 --> 00:01:14,580
that I found really useful when I was

00:01:11,100 --> 00:01:17,000
writing software for um for AWS lambda

00:01:14,580 --> 00:01:19,830
which is using javascript and Wiegel of

00:01:17,000 --> 00:01:24,119
first party dependencies famines Amazon

00:01:19,830 --> 00:01:26,850
services yeah so before I begin I

00:01:24,119 --> 00:01:29,540
decided in case this is a terrible talk

00:01:26,850 --> 00:01:32,100
that's quite dry I've wrote some jokes

00:01:29,540 --> 00:01:35,340
yeah and some some people are worried

00:01:32,100 --> 00:01:36,740
now I can see so you do have to laugh

00:01:35,340 --> 00:01:39,720
otherwise it'll be really awkward

00:01:36,740 --> 00:01:45,409
which javascript framework do farmers

00:01:39,720 --> 00:01:53,340
use new tools yeah yeah they do

00:01:45,409 --> 00:01:56,189
setting the level now I'll try and press

00:01:53,340 --> 00:01:59,759
you what is the Kaiser Chiefs favorite

00:01:56,189 --> 00:02:03,960
programming language hey there we go

00:01:59,759 --> 00:02:07,679
yeah and then why do typescript programs

00:02:03,960 --> 00:02:15,989
take a long time to write because it's a

00:02:07,679 --> 00:02:17,580
gradually typed programming language so

00:02:15,989 --> 00:02:18,090
I do have a few more but I'm gonna make

00:02:17,580 --> 00:02:19,260
you wait

00:02:18,090 --> 00:02:20,610
there's gonna be a few more halfway

00:02:19,260 --> 00:02:22,709
through and then at the end I've got the

00:02:20,610 --> 00:02:27,120
rest of them then I'll be off quite

00:02:22,709 --> 00:02:29,040
quickly I suppose so so how do I move on

00:02:27,120 --> 00:02:29,580
to the next life a spacebar nope that's

00:02:29,040 --> 00:02:32,400
too far

00:02:29,580 --> 00:02:35,010
alright a refresher on properly testing

00:02:32,400 --> 00:02:37,319
how many people here do unit testing or

00:02:35,010 --> 00:02:39,599
I've heard of unit testing hands up okay

00:02:37,319 --> 00:02:42,630
good that's most people that's excellent

00:02:39,599 --> 00:02:46,170
that's good news so far so property

00:02:42,630 --> 00:02:48,150
testing is is pretty similar to unit

00:02:46,170 --> 00:02:50,579
testing it's kind of similar techniques

00:02:48,150 --> 00:02:53,730
most people have reused example based

00:02:50,579 --> 00:02:56,190
testing this is my analogy for all my

00:02:53,730 --> 00:02:58,739
metaphor for example based testing okay

00:02:56,190 --> 00:03:00,359
want a little nerf gun it's pretty

00:02:58,739 --> 00:03:04,140
accurate you can be very specific but

00:03:00,359 --> 00:03:06,900
that's about it you put in an input get

00:03:04,140 --> 00:03:09,950
an output compare them good or bad ship

00:03:06,900 --> 00:03:14,400
your software this is property testing

00:03:09,950 --> 00:03:16,709
yeah so property testing is a form of

00:03:14,400 --> 00:03:19,799
unit testing it doesn't replace unit

00:03:16,709 --> 00:03:23,250
test you traditional example based unit

00:03:19,799 --> 00:03:25,049
testing it complements it it's you

00:03:23,250 --> 00:03:26,790
instead of working with specific inputs

00:03:25,049 --> 00:03:28,530
and outputs and centers if I put in a I

00:03:26,790 --> 00:03:30,870
get B yes or no

00:03:28,530 --> 00:03:34,109
instead you talk about spaces of inputs

00:03:30,870 --> 00:03:37,920
so you might say can my program accepts

00:03:34,109 --> 00:03:39,810
any integer or any string or an object

00:03:37,920 --> 00:03:41,370
that has these properties but some of

00:03:39,810 --> 00:03:43,380
the properties are bounded in certain

00:03:41,370 --> 00:03:47,370
ways or an array of those things and

00:03:43,380 --> 00:03:50,639
then you then check given those inputs

00:03:47,370 --> 00:03:53,400
and my my app do these properties hold

00:03:50,639 --> 00:03:55,049
I'll give some examples one of the

00:03:53,400 --> 00:03:58,150
clever things about property testing is

00:03:55,049 --> 00:04:00,549
if one of those properties don't hold

00:03:58,150 --> 00:04:02,110
a specific example let's say you've

00:04:00,549 --> 00:04:04,930
written your own sorting algorithm and

00:04:02,110 --> 00:04:08,319
it works on arrays and it finds that an

00:04:04,930 --> 00:04:11,049
array of a hundred numbers long doesn't

00:04:08,319 --> 00:04:13,239
sort in the way you expected it will

00:04:11,049 --> 00:04:16,150
then automatically know how to shrink

00:04:13,239 --> 00:04:18,489
that bam so it will try an array of 99

00:04:16,150 --> 00:04:20,289
numbers in 98 the 97 and then it

00:04:18,489 --> 00:04:22,180
although if the number at the very end

00:04:20,289 --> 00:04:23,949
is 5 I'll try 4 they'll try 3 you know

00:04:22,180 --> 00:04:25,449
keep on trying to find the smallest

00:04:23,949 --> 00:04:27,610
possible failing case you'll see that in

00:04:25,449 --> 00:04:29,530
the second the other nice thing about

00:04:27,610 --> 00:04:31,750
properties has testing is it allows you

00:04:29,530 --> 00:04:32,770
to become a cyborg developer now I'm not

00:04:31,750 --> 00:04:35,020
gonna explain what that is that's

00:04:32,770 --> 00:04:39,280
foreshadowing but if you pay attention

00:04:35,020 --> 00:04:42,520
you'll get it yes it was invented by a

00:04:39,280 --> 00:04:44,080
man called John Hughes who was pretty

00:04:42,520 --> 00:04:45,820
important when it came to he's still

00:04:44,080 --> 00:04:48,130
alive so say was pretty was still pretty

00:04:45,820 --> 00:04:49,360
important when it comes to software

00:04:48,130 --> 00:04:50,740
development very heavily involved in

00:04:49,360 --> 00:04:53,260
functional programming was heavily

00:04:50,740 --> 00:04:55,150
involved in Haskell and he says as you

00:04:53,260 --> 00:04:58,330
can see can everyone see that

00:04:55,150 --> 00:04:59,800
don't write tests generate them ok so he

00:04:58,330 --> 00:05:02,050
said people spend all their time writing

00:04:59,800 --> 00:05:03,370
all of these unit tests hundreds of

00:05:02,050 --> 00:05:06,789
thousands of lines long all these

00:05:03,370 --> 00:05:08,470
different new tests and they they just

00:05:06,789 --> 00:05:10,930
clog up your codebase it means making

00:05:08,470 --> 00:05:13,990
changes as hard work you can never be

00:05:10,930 --> 00:05:15,639
done writing unit tests because here's a

00:05:13,990 --> 00:05:17,080
classic example people try and use code

00:05:15,639 --> 00:05:19,090
coverage to prove we've done enough

00:05:17,080 --> 00:05:21,220
testing we've got 90% code coverage

00:05:19,090 --> 00:05:23,139
you've got 95 got 100% code coverage

00:05:21,220 --> 00:05:25,449
every single line in my program is

00:05:23,139 --> 00:05:28,389
touched by a test in some way well what

00:05:25,449 --> 00:05:29,620
if you're dividing a number by 0 ok what

00:05:28,389 --> 00:05:31,300
happens if that let's say you're doing

00:05:29,620 --> 00:05:33,340
food a valley by bar

00:05:31,300 --> 00:05:35,229
have you tried making sure in your unit

00:05:33,340 --> 00:05:36,880
test that bar is zero you'll still have

00:05:35,229 --> 00:05:38,919
all this code coverage saying

00:05:36,880 --> 00:05:40,180
everything's fine but actually there's

00:05:38,919 --> 00:05:41,800
one more test that would've caused your

00:05:40,180 --> 00:05:44,320
program to explode you ship it and

00:05:41,800 --> 00:05:45,699
everything there's a big disaster so you

00:05:44,320 --> 00:05:48,690
can never really be done right unit

00:05:45,699 --> 00:05:50,710
tests so he makes the point that yeah

00:05:48,690 --> 00:05:53,470
don't worry unit tests use properly

00:05:50,710 --> 00:05:55,210
testing you said this in a talk sorry so

00:05:53,470 --> 00:05:56,740
paper called testing experiences of a

00:05:55,210 --> 00:05:58,810
quick check testing the hard stuff and

00:05:56,740 --> 00:06:00,010
saying saying he also did a talk on

00:05:58,810 --> 00:06:01,389
property testing in general that's

00:06:00,010 --> 00:06:04,479
actually better than this one so if you

00:06:01,389 --> 00:06:05,860
get the chance do watch that it's been

00:06:04,479 --> 00:06:07,150
ported to many different languages so

00:06:05,860 --> 00:06:08,800
you don't have to use Haskell to do

00:06:07,150 --> 00:06:10,389
properly testing which is why I'm here

00:06:08,800 --> 00:06:11,770
at Bristol jeaious there are lots of

00:06:10,389 --> 00:06:12,009
different JavaScript libraries that do

00:06:11,770 --> 00:06:13,689
pop

00:06:12,009 --> 00:06:16,659
testing there's maybe three or four

00:06:13,689 --> 00:06:19,749
they're all in various degrees of lack

00:06:16,659 --> 00:06:21,759
of maintenance I'm going to be using

00:06:19,749 --> 00:06:24,279
fast check for my examples it's one of

00:06:21,759 --> 00:06:26,379
the few modern well-maintained property

00:06:24,279 --> 00:06:28,539
testing libraries for JavaScript

00:06:26,379 --> 00:06:31,779
however I would say that I'm biased

00:06:28,539 --> 00:06:37,499
because I am one of the top four most

00:06:31,779 --> 00:06:37,499
prolific contributors to fast check

00:06:39,230 --> 00:06:46,059
[Laughter]

00:06:42,599 --> 00:06:49,449
Thank You thanks yeah fixing a typo in

00:06:46,059 --> 00:06:51,490
the documentation that still counts that

00:06:49,449 --> 00:06:53,860
still counts and I'm still on number

00:06:51,490 --> 00:06:54,969
four I actually in the process of

00:06:53,860 --> 00:06:56,740
putting this talk together I found

00:06:54,969 --> 00:06:58,389
another typo in the documentation but I

00:06:56,740 --> 00:07:00,399
didn't want to send a pull request in

00:06:58,389 --> 00:07:03,009
case I got bumped up to number three in

00:07:00,399 --> 00:07:06,610
that ruin the visual joke so yeah that's

00:07:03,009 --> 00:07:09,159
my level of dedication to my craft so

00:07:06,610 --> 00:07:11,169
yeah now that's enough spiel I'm going

00:07:09,159 --> 00:07:12,610
to take you through some examples to

00:07:11,169 --> 00:07:14,080
show you what proper testing actually

00:07:12,610 --> 00:07:16,089
looks like in the real world I don't

00:07:14,080 --> 00:07:18,459
know whether this will display became

00:07:16,089 --> 00:07:19,050
nicely on this screen so let's just give

00:07:18,459 --> 00:07:21,430
it a go

00:07:19,050 --> 00:07:24,610
can people see that is that bright

00:07:21,430 --> 00:07:27,129
enough okay cool so if you can't see it

00:07:24,610 --> 00:07:29,080
although I'll explain it it's like a

00:07:27,129 --> 00:07:30,789
classic unit test you've got your

00:07:29,080 --> 00:07:33,219
testing function whether using a ver or

00:07:30,789 --> 00:07:34,689
Marco or jest doesn't matter your fast

00:07:33,219 --> 00:07:36,669
check will work with those there's

00:07:34,689 --> 00:07:39,099
either per testing library integration

00:07:36,669 --> 00:07:41,349
or you can do it manually it's kind of

00:07:39,099 --> 00:07:46,059
up to you doesn't matter you have your

00:07:41,349 --> 00:07:48,279
description of your tests and it's in

00:07:46,059 --> 00:07:50,409
this case we're testing a function that

00:07:48,279 --> 00:07:52,419
checks if a string contains another

00:07:50,409 --> 00:07:54,219
string does a contain B that's what

00:07:52,419 --> 00:07:55,689
we're testing is our own implementation

00:07:54,219 --> 00:07:57,129
we want to make sure it works and I

00:07:55,689 --> 00:07:58,289
didn't write this test myself by the way

00:07:57,129 --> 00:08:00,809
I took this from fast check

00:07:58,289 --> 00:08:03,519
documentation so you can find it there

00:08:00,809 --> 00:08:05,769
yeah so I'll take you through it you've

00:08:03,519 --> 00:08:09,009
got the body for tests here does text if

00:08:05,769 --> 00:08:11,860
you pass it to contains text text does

00:08:09,009 --> 00:08:13,240
it contain itself we run it 5,000 times

00:08:11,860 --> 00:08:14,889
I'll explain what that means in a second

00:08:13,240 --> 00:08:17,019
the thing you probably don't recognize

00:08:14,889 --> 00:08:19,300
is this bit here if you can't read that

00:08:17,019 --> 00:08:20,589
it says F C dot string so FC sounds a

00:08:19,300 --> 00:08:22,449
fast check you'll see that a lot in all

00:08:20,589 --> 00:08:24,249
these code examples but the point

00:08:22,449 --> 00:08:24,950
important point is it's calling a

00:08:24,249 --> 00:08:28,100
function called string

00:08:24,950 --> 00:08:29,600
this gives you back a generator now a

00:08:28,100 --> 00:08:30,650
generator is not in the sense of a

00:08:29,600 --> 00:08:34,130
JavaScript

00:08:30,650 --> 00:08:35,540
yes 2015 or 2016 generator it's not a

00:08:34,130 --> 00:08:38,150
generator function it's not a generator

00:08:35,540 --> 00:08:40,790
objects it's a specific idea for

00:08:38,150 --> 00:08:42,260
property testing it's not a value at

00:08:40,790 --> 00:08:44,270
this point it hasn't given you a string

00:08:42,260 --> 00:08:46,670
you have to plug it into a function like

00:08:44,270 --> 00:08:49,910
this one so if you test plug it into the

00:08:46,670 --> 00:08:51,980
test prop function it will run the body

00:08:49,910 --> 00:08:53,870
of our test here five thousand times and

00:08:51,980 --> 00:08:55,970
each time text will be a different

00:08:53,870 --> 00:08:58,160
string and it could be anything so it

00:08:55,970 --> 00:09:00,260
could be food could be bar it could be

00:08:58,160 --> 00:09:01,910
an empty string it could be some Unicode

00:09:00,260 --> 00:09:02,480
monstrosity it could be Chinese you

00:09:01,910 --> 00:09:05,200
never know right

00:09:02,480 --> 00:09:09,080
we'll try as many things as possible

00:09:05,200 --> 00:09:12,260
yeah looking at this we think that let's

00:09:09,080 --> 00:09:14,810
say this is foo while foo should contain

00:09:12,260 --> 00:09:16,160
foo right that's how a contains function

00:09:14,810 --> 00:09:17,780
should work so we think this property

00:09:16,160 --> 00:09:20,900
test should pass that should be good if

00:09:17,780 --> 00:09:24,320
if text is bar bar contains bar so that

00:09:20,900 --> 00:09:26,480
should pass here's another property test

00:09:24,320 --> 00:09:28,610
this is slightly more complicated this

00:09:26,480 --> 00:09:31,880
is describing the a string should always

00:09:28,610 --> 00:09:34,430
contain its sub strings okay we're

00:09:31,880 --> 00:09:36,140
seeing a body here we're test body here

00:09:34,430 --> 00:09:37,700
where we get a B and C these are three

00:09:36,140 --> 00:09:40,490
separate arguments and we're checking

00:09:37,700 --> 00:09:44,540
that a plus B plus C should always

00:09:40,490 --> 00:09:46,490
contain B okay so if you add three

00:09:44,540 --> 00:09:48,530
strings together the middle string

00:09:46,490 --> 00:09:50,660
should be inside those three strings you

00:09:48,530 --> 00:09:51,860
add it together this is a little bit

00:09:50,660 --> 00:09:53,420
more complicated here we've got an array

00:09:51,860 --> 00:09:55,610
of generators here and actually they

00:09:53,420 --> 00:09:57,860
match up so the first one here in the

00:09:55,610 --> 00:09:59,600
start of the array is a the one in the

00:09:57,860 --> 00:10:00,710
middle is B and on at the end of C you

00:09:59,600 --> 00:10:01,760
don't have to be strings it could be

00:10:00,710 --> 00:10:03,530
whatever you want they don't have to be

00:10:01,760 --> 00:10:06,650
an array of well strings but in this

00:10:03,530 --> 00:10:08,990
case that's what we want yeah and it won

00:10:06,650 --> 00:10:12,260
a million times that's actually not too

00:10:08,990 --> 00:10:14,360
slow even for JavaScript so let's have a

00:10:12,260 --> 00:10:16,910
look at our implementation of contains

00:10:14,360 --> 00:10:19,610
and we'll see if it is going to pass our

00:10:16,910 --> 00:10:20,930
property tests so this is our

00:10:19,610 --> 00:10:24,560
implementation hope I did a good job

00:10:20,930 --> 00:10:26,750
what you guys think not convinced so

00:10:24,560 --> 00:10:30,260
this is taking the two arguments and

00:10:26,750 --> 00:10:33,080
we're comparing them to each other so

00:10:30,260 --> 00:10:35,390
text equals equals equals pattern so if

00:10:33,080 --> 00:10:36,830
that's foo and foo or that should be

00:10:35,390 --> 00:10:37,880
true because foo equals equals equals

00:10:36,830 --> 00:10:38,360
foo

00:10:37,880 --> 00:10:40,550
if it

00:10:38,360 --> 00:10:42,170
foo and bar then they won't match so

00:10:40,550 --> 00:10:43,970
it'll fail so this should work right

00:10:42,170 --> 00:10:47,209
this'll this'll pass first time I'm

00:10:43,970 --> 00:10:51,019
pretty confident let's see what happens

00:10:47,209 --> 00:10:54,260
it fails okay so let's see which

00:10:51,019 --> 00:10:56,390
properties actually failed the first one

00:10:54,260 --> 00:10:59,120
is actually should always contain itself

00:10:56,390 --> 00:11:00,760
that actually passes because remember in

00:10:59,120 --> 00:11:03,350
that property we were passing the string

00:11:00,760 --> 00:11:04,550
two times into that function so if we're

00:11:03,350 --> 00:11:05,360
comparing them equally that will always

00:11:04,550 --> 00:11:09,820
pass that's good

00:11:05,360 --> 00:11:13,519
but comparing the substrings that fails

00:11:09,820 --> 00:11:15,800
and we're going to see exactly why so

00:11:13,519 --> 00:11:17,450
fast check will show you the smallest

00:11:15,800 --> 00:11:18,829
fading case as I explained property

00:11:17,450 --> 00:11:20,529
testing will shrink in their substrate

00:11:18,829 --> 00:11:22,850
things down so let's have a look at that

00:11:20,529 --> 00:11:24,890
so it's pointing out that the count the

00:11:22,850 --> 00:11:28,010
smallest failing counter example that's

00:11:24,890 --> 00:11:31,490
the terminology it uses is an empty

00:11:28,010 --> 00:11:35,029
string an empty string and a string with

00:11:31,490 --> 00:11:37,760
a single space in it yeah so let's

00:11:35,029 --> 00:11:39,380
consider this if it was let's say there

00:11:37,760 --> 00:11:41,390
foo bar and Baz so that's going to fail

00:11:39,380 --> 00:11:43,100
because foo bar in bags is not equal to

00:11:41,390 --> 00:11:45,440
bar which would be the middle string

00:11:43,100 --> 00:11:47,329
right whereas if they're three empty

00:11:45,440 --> 00:11:49,670
strings well an empty string add an

00:11:47,329 --> 00:11:52,970
empty string add an empty string is just

00:11:49,670 --> 00:11:55,310
an empty string so it's not going to be

00:11:52,970 --> 00:11:56,300
this it would be the same as the middle

00:11:55,310 --> 00:11:59,120
one which would be an empty string so

00:11:56,300 --> 00:12:00,350
that would pass so fast check has shrunk

00:11:59,120 --> 00:12:02,570
it all the way down until it's found

00:12:00,350 --> 00:12:04,699
that if you add an empty string an empty

00:12:02,570 --> 00:12:06,529
string and a string of a single space

00:12:04,699 --> 00:12:09,800
which gives you a string of single space

00:12:06,529 --> 00:12:12,199
that does not match an empty string so

00:12:09,800 --> 00:12:14,449
it fails okay that makes sense and let's

00:12:12,199 --> 00:12:17,690
see if we can fix our implementation to

00:12:14,449 --> 00:12:20,240
get it passing both properties so I've

00:12:17,690 --> 00:12:23,449
gone with index of everyone's use index

00:12:20,240 --> 00:12:25,670
off it's finding the index of a needle

00:12:23,449 --> 00:12:29,930
in a haystack okay so it gives you the

00:12:25,670 --> 00:12:32,420
index of the first character in a given

00:12:29,930 --> 00:12:34,519
target string so we're making sure that

00:12:32,420 --> 00:12:37,310
let's say that's foo and that's bar

00:12:34,519 --> 00:12:39,079
well firm bar would give you minus one

00:12:37,310 --> 00:12:42,170
because it can't find it at all whereas

00:12:39,079 --> 00:12:44,329
foo and ooh would give you one right and

00:12:42,170 --> 00:12:46,100
in foo and fo would give you zero foo

00:12:44,329 --> 00:12:47,180
and food give you zero so I think this

00:12:46,100 --> 00:12:49,390
is going to work we're making sure that

00:12:47,180 --> 00:12:51,420
the index is always greater than zero

00:12:49,390 --> 00:12:55,890
let's see what happens

00:12:51,420 --> 00:12:57,960
are they both fail okay there we go

00:12:55,890 --> 00:13:01,230
so why do they both fail why would that

00:12:57,960 --> 00:13:05,250
be the case let's see the reason why is

00:13:01,230 --> 00:13:07,710
that let's start with the simplest case

00:13:05,250 --> 00:13:12,450
which was passing the same string into

00:13:07,710 --> 00:13:16,860
contains twice so foo index of foo what

00:13:12,450 --> 00:13:18,540
does that give you zero perfect yeah but

00:13:16,860 --> 00:13:23,370
our test was checking that it's greater

00:13:18,540 --> 00:13:25,140
than zero very good okay all right let's

00:13:23,370 --> 00:13:26,100
see what happens well actually let's

00:13:25,140 --> 00:13:28,320
check the other property because that's

00:13:26,100 --> 00:13:31,830
sort of putting the slide but jumping

00:13:28,320 --> 00:13:35,490
ahead very very slightly yeah oh did I

00:13:31,830 --> 00:13:37,560
go forward yeah there you go so it's

00:13:35,490 --> 00:13:39,120
actually finding the three empty strings

00:13:37,560 --> 00:13:40,980
if you add them all up you get an empty

00:13:39,120 --> 00:13:42,570
string well the empty string index or

00:13:40,980 --> 00:13:45,000
empty string is 0 so it's failing for

00:13:42,570 --> 00:13:47,990
exactly the same reason let's try and

00:13:45,000 --> 00:13:52,890
fix our implementation let's go with

00:13:47,990 --> 00:13:54,810
greater or equal to the 0 thank you it

00:13:52,890 --> 00:13:57,300
passes amazing there we go

00:13:54,810 --> 00:13:59,280
both are properties pass you can see

00:13:57,300 --> 00:14:01,470
actually that should always contain

00:13:59,280 --> 00:14:02,940
itself took long enough that unit

00:14:01,470 --> 00:14:05,220
testing library wanted to explain it

00:14:02,940 --> 00:14:06,750
took 242 milliseconds so you can kind of

00:14:05,220 --> 00:14:10,830
see how property tests take a little bit

00:14:06,750 --> 00:14:12,510
longer than standard unit tests yeah I

00:14:10,830 --> 00:14:14,610
also wanted to show you that you can do

00:14:12,510 --> 00:14:16,590
more than just generate numbers or

00:14:14,610 --> 00:14:19,500
strings or very simple things you can

00:14:16,590 --> 00:14:21,990
actually generate compound objects you

00:14:19,500 --> 00:14:24,150
can generate arrays of things you can

00:14:21,990 --> 00:14:25,410
generate recursive objects you can

00:14:24,150 --> 00:14:27,390
generate almost anything like if you

00:14:25,410 --> 00:14:29,340
wanted you can generate dates or custom

00:14:27,390 --> 00:14:31,770
classes if you've built your own class

00:14:29,340 --> 00:14:33,720
or you for importing a library as long

00:14:31,770 --> 00:14:35,130
as you can take the built-in generators

00:14:33,720 --> 00:14:36,840
that fast check provides you we've only

00:14:35,130 --> 00:14:38,790
seen string but as long as you can take

00:14:36,840 --> 00:14:40,140
those values and turn them into some

00:14:38,790 --> 00:14:42,390
custom based structure then you can do

00:14:40,140 --> 00:14:45,540
whatever you like with it let's try and

00:14:42,390 --> 00:14:47,310
generate a shopping list can everyone

00:14:45,540 --> 00:14:49,200
see that so now it's the contrast is a

00:14:47,310 --> 00:14:51,510
little bit low so this is a shopping

00:14:49,200 --> 00:14:54,480
list we want our shopping list to be an

00:14:51,510 --> 00:14:55,830
object with three properties the first

00:14:54,480 --> 00:14:58,350
property is title and it should be

00:14:55,830 --> 00:15:01,230
so-and-so shopping list or every time

00:14:58,350 --> 00:15:03,840
you generate shopping lists we want that

00:15:01,230 --> 00:15:04,329
to be the title with whoever's name in

00:15:03,840 --> 00:15:06,249
the place

00:15:04,329 --> 00:15:08,259
X and we want a date because we want to

00:15:06,249 --> 00:15:10,179
know when we're gonna go go shopping if

00:15:08,259 --> 00:15:12,429
we find it later myself six months ago I

00:15:10,179 --> 00:15:16,600
was shopping for that and then we also

00:15:12,429 --> 00:15:19,600
want an array of items where each item

00:15:16,600 --> 00:15:20,709
has two properties the the actual item

00:15:19,600 --> 00:15:22,329
itself which would be a string they'll

00:15:20,709 --> 00:15:24,069
be bananas apples whatever you want and

00:15:22,329 --> 00:15:25,540
then the amount which would be the

00:15:24,069 --> 00:15:28,689
number of those things so pretty

00:15:25,540 --> 00:15:30,339
straightforward let's see how we put

00:15:28,689 --> 00:15:31,749
that together in fast check this is

00:15:30,339 --> 00:15:33,040
gonna look a little bit dense and that's

00:15:31,749 --> 00:15:35,290
partly cuz I'm trying to fit it all in

00:15:33,040 --> 00:15:36,759
one slide normally you would use you

00:15:35,290 --> 00:15:38,230
design things two variables give them

00:15:36,759 --> 00:15:40,209
names put them in different files you do

00:15:38,230 --> 00:15:41,079
whatever you need to so don't don't

00:15:40,209 --> 00:15:43,149
freak out

00:15:41,079 --> 00:15:45,910
can everyone see that that's way too

00:15:43,149 --> 00:15:49,470
small okay all right I'll take you

00:15:45,910 --> 00:15:52,360
through it so at the very top we've got

00:15:49,470 --> 00:15:54,040
constant from now constant from it's a

00:15:52,360 --> 00:15:56,019
fast check function that takes a series

00:15:54,040 --> 00:15:57,670
of arguments in this case I know people

00:15:56,019 --> 00:15:59,439
are back can't see anything this is

00:15:57,670 --> 00:16:07,239
series of strings like apples oranges

00:15:59,439 --> 00:16:10,059
toilet paper cereal tofu and hummus yes

00:16:07,239 --> 00:16:13,779
yes it is yeah yeah

00:16:10,059 --> 00:16:15,790
and then we're producing a set of those

00:16:13,779 --> 00:16:17,980
products okay so you can't see this but

00:16:15,790 --> 00:16:21,759
this is fast check set it'll produce an

00:16:17,980 --> 00:16:23,739
a unique array of any other arbitrary

00:16:21,759 --> 00:16:26,769
you give it so in this case we're saying

00:16:23,739 --> 00:16:28,660
create a unique set of products so it

00:16:26,769 --> 00:16:30,369
will give us a random arrangement which

00:16:28,660 --> 00:16:33,129
could be of any size could be five could

00:16:30,369 --> 00:16:34,959
be ten could be however long of oranges

00:16:33,129 --> 00:16:39,369
apples toilet paper cereal the other

00:16:34,959 --> 00:16:40,569
things we then shape see this it's gonna

00:16:39,369 --> 00:16:42,369
be difficult to explain because you guys

00:16:40,569 --> 00:16:44,829
guys can't see it effectively what we're

00:16:42,369 --> 00:16:47,259
doing is we're then using the chain

00:16:44,829 --> 00:16:49,179
function chain functions work exactly

00:16:47,259 --> 00:16:50,589
the same as promises do okay so if any

00:16:49,179 --> 00:16:53,709
ones you use promises before

00:16:50,589 --> 00:16:56,169
if the then function it's a method that

00:16:53,709 --> 00:16:57,639
you pass a function into and that inner

00:16:56,169 --> 00:16:59,559
function will be invoked when the

00:16:57,639 --> 00:17:01,509
promise resolves it works exactly the

00:16:59,559 --> 00:17:03,309
same for property tests except they call

00:17:01,509 --> 00:17:04,689
it chain rather than then it's almost

00:17:03,309 --> 00:17:06,399
the same for the purposes of this talk

00:17:04,689 --> 00:17:08,139
it will be the same if you're interested

00:17:06,399 --> 00:17:09,579
in why it's not quite the same I can

00:17:08,139 --> 00:17:11,500
boil you about it later

00:17:09,579 --> 00:17:13,809
effectively what we do then is we take

00:17:11,500 --> 00:17:15,819
that item that we generated and we

00:17:13,809 --> 00:17:18,189
create a random amount you guys can't

00:17:15,819 --> 00:17:20,079
see this fast check integer from one two

00:17:18,189 --> 00:17:23,319
so that means we get hundreds toilet

00:17:20,079 --> 00:17:25,780
papers or toilet rolls as those or 50 or

00:17:23,319 --> 00:17:27,339
ten or having what you want at the very

00:17:25,780 --> 00:17:29,289
end we chained it once again you can

00:17:27,339 --> 00:17:30,809
keep chaining property tests for its re

00:17:29,289 --> 00:17:35,200
generators for as long as you need to

00:17:30,809 --> 00:17:37,030
and we then combine it see this is quite

00:17:35,200 --> 00:17:40,030
good but you guys can't see it we take

00:17:37,030 --> 00:17:42,940
we take a title which is a constant from

00:17:40,030 --> 00:17:45,940
will Haslam John Hughes and Philip

00:17:42,940 --> 00:17:49,330
Wadler okay and then we map it in the

00:17:45,940 --> 00:17:52,630
same way you map an array to check if it

00:17:49,330 --> 00:17:53,950
ends with s you add a little apostrophe

00:17:52,630 --> 00:17:55,780
if it doesn't end with this you add

00:17:53,950 --> 00:17:57,820
pasta vs so you're handling the the

00:17:55,780 --> 00:17:59,590
pluralization there and then on the very

00:17:57,820 --> 00:18:01,150
end of that you add a shopping list okay

00:17:59,590 --> 00:18:03,100
so it's going to produce either will has

00:18:01,150 --> 00:18:06,640
some shopping list John Hughes or Philip

00:18:03,100 --> 00:18:11,230
wobblers this is an interesting bit the

00:18:06,640 --> 00:18:13,480
date we use F seen at the GNAT arbitrary

00:18:11,230 --> 00:18:15,100
or generator this will produce natural

00:18:13,480 --> 00:18:18,220
numbers so that means zero to

00:18:15,100 --> 00:18:19,780
effectively infinity as opposed to the

00:18:18,220 --> 00:18:23,169
integer generator which can give you

00:18:19,780 --> 00:18:25,510
negative numbers we then map it into a

00:18:23,169 --> 00:18:27,220
new date and it's that simple now you've

00:18:25,510 --> 00:18:28,539
got a generator that produces dates it's

00:18:27,220 --> 00:18:31,210
that easy to turn something into a

00:18:28,539 --> 00:18:33,130
generate into that a generator that

00:18:31,210 --> 00:18:35,470
produces primitive values into something

00:18:33,130 --> 00:18:40,120
that produces more complex ones

00:18:35,470 --> 00:18:41,350
that's about it let's see what examples

00:18:40,120 --> 00:18:43,030
it comes up with when we run this

00:18:41,350 --> 00:18:44,650
through there's a sampling function that

00:18:43,030 --> 00:18:46,870
you can pass any generator to and it'll

00:18:44,650 --> 00:18:49,809
produce examples for you so you don't

00:18:46,870 --> 00:18:51,309
have to test them straightaway yeah so

00:18:49,809 --> 00:18:55,409
there you go you've got a Phillip

00:18:51,309 --> 00:18:59,530
Wireless shopping list on the 23rd of

00:18:55,409 --> 00:19:02,679
January 1970 about midday just after

00:18:59,530 --> 00:19:04,299
midday he went shopping for 92 toilet

00:19:02,679 --> 00:19:10,990
papers he should have bought a whole

00:19:04,299 --> 00:19:14,080
roll really he's got 46 hummus and he

00:19:10,990 --> 00:19:14,590
went for just exactly you worth you

00:19:14,080 --> 00:19:17,020
would neither

00:19:14,590 --> 00:19:19,390
Anam and two apples gotta have some

00:19:17,020 --> 00:19:22,289
fiber in your diet so that's what

00:19:19,390 --> 00:19:26,350
Phillip wobbler one for on the 23rd of

00:19:22,289 --> 00:19:29,080
January 1917 John Hughes you can see

00:19:26,350 --> 00:19:31,780
there is a nice nicer s apostrophe

00:19:29,080 --> 00:19:35,590
rather than s apostrophe s

00:19:31,780 --> 00:19:38,560
about five milliseconds after the nuit

00:19:35,590 --> 00:19:39,910
sorry yeah the beginning of time five

00:19:38,560 --> 00:19:43,780
milliseconds at the beginning of time

00:19:39,910 --> 00:19:46,990
it's just seeing in New Year's Day 9

00:19:43,780 --> 00:19:50,080
1969 and he thought just kind of pop to

00:19:46,990 --> 00:19:53,140
the shops and he got four apples 18

00:19:50,080 --> 00:19:56,740
oranges a load of hummus some cereal

00:19:53,140 --> 00:19:58,570
this time and a bit tofu and then for

00:19:56,740 --> 00:20:05,350
good measure let's see what my shopping

00:19:58,570 --> 00:20:09,910
list was oops so yeah I'm not on the

00:20:05,350 --> 00:20:13,990
22nd of January 1970 about 20 past 1:00

00:20:09,910 --> 00:20:16,060
a.m. I just yeah I just panicked I went

00:20:13,990 --> 00:20:20,140
to the supermarket I panicked

00:20:16,060 --> 00:20:24,400
they have supermarkets in the 70s so

00:20:20,140 --> 00:20:26,470
yeah I bought a thing I bought there we

00:20:24,400 --> 00:20:28,660
go

00:20:26,470 --> 00:20:31,480
yeah and this is an important lesson

00:20:28,660 --> 00:20:33,070
which is that our batteries can give you

00:20:31,480 --> 00:20:34,420
kind of really unexpected stuff we were

00:20:33,070 --> 00:20:36,400
expecting a shopping list and what we

00:20:34,420 --> 00:20:38,860
got was an empty thing this is actually

00:20:36,400 --> 00:20:40,030
a strength not a weakness because if

00:20:38,860 --> 00:20:41,290
you've written your function and you're

00:20:40,030 --> 00:20:43,150
assuming that you're gonna take all

00:20:41,290 --> 00:20:44,410
these values and change them transform

00:20:43,150 --> 00:20:45,760
then you're making assumptions about how

00:20:44,410 --> 00:20:47,050
long it is you see well why would

00:20:45,760 --> 00:20:48,970
someone call my API if they didn't have

00:20:47,050 --> 00:20:51,000
a thing to give me well guess what they

00:20:48,970 --> 00:20:55,780
might not be giving you anything

00:20:51,000 --> 00:20:57,790
so yeah now we're going to do a demo

00:20:55,780 --> 00:21:00,460
we're gonna see how property testing

00:20:57,790 --> 00:21:02,560
works with Oracle functions now Oracle

00:21:00,460 --> 00:21:04,480
functions they're not special feature

00:21:02,560 --> 00:21:08,320
they're just a way of using property

00:21:04,480 --> 00:21:10,620
testing and it the way effectively works

00:21:08,320 --> 00:21:14,020
is let's say you've got a pre-existing

00:21:10,620 --> 00:21:15,610
implementation implementation a and you

00:21:14,020 --> 00:21:16,990
write your own implementation B because

00:21:15,610 --> 00:21:19,210
you want to make it faster your

00:21:16,990 --> 00:21:21,130
refactoring for whatever reason you can

00:21:19,210 --> 00:21:23,340
say you can build a property test that

00:21:21,130 --> 00:21:25,660
says for all of these inputs do

00:21:23,340 --> 00:21:28,270
functionary and function B agree with

00:21:25,660 --> 00:21:30,130
each other that's it you just say equal

00:21:28,270 --> 00:21:33,340
equals equals function a function b if

00:21:30,130 --> 00:21:35,260
it doesn't then fast check will find

00:21:33,340 --> 00:21:36,790
that failing case it'll shrink it down

00:21:35,260 --> 00:21:38,230
present you and say look these

00:21:36,790 --> 00:21:40,420
implementations don't agree with each

00:21:38,230 --> 00:21:42,280
other for this small failing case so

00:21:40,420 --> 00:21:44,559
it's pretty cool we're going to be doing

00:21:42,280 --> 00:21:47,950
this with fizzbuzz

00:21:44,559 --> 00:21:52,690
does everyone here know fizzbuzz yeah

00:21:47,950 --> 00:21:54,399
okay cool all right so yeah I need a

00:21:52,690 --> 00:21:56,950
volunteer does anyone want to volunteer

00:21:54,399 --> 00:21:59,440
so effectively what's happening here is

00:21:56,950 --> 00:22:02,289
we're creating an integer from 1 to 99

00:21:59,440 --> 00:22:06,249
and I'm gonna make that a little bit

00:22:02,289 --> 00:22:08,529
bigger so you can see it yeah and then

00:22:06,249 --> 00:22:10,809
we're chaining it into a record which is

00:22:08,529 --> 00:22:12,399
essentially an object where you have

00:22:10,809 --> 00:22:14,590
some fixed keys and then some values

00:22:12,399 --> 00:22:17,619
which are also generators and we're

00:22:14,590 --> 00:22:21,399
saying that the proper the the property

00:22:17,619 --> 00:22:22,840
start will always be whatever was passed

00:22:21,399 --> 00:22:26,259
in so let's say this is charity number

00:22:22,840 --> 00:22:28,840
50 start will always be 50 and then we

00:22:26,259 --> 00:22:31,600
generate end which is an integer from

00:22:28,840 --> 00:22:36,039
start to 100 so let's say start is 50

00:22:31,600 --> 00:22:37,389
then end could be 75 or 199 so we're

00:22:36,039 --> 00:22:41,740
just since you're generating ranges of

00:22:37,389 --> 00:22:43,450
numbers we then our test body is calling

00:22:41,740 --> 00:22:45,490
our Oracle or fizzbuzz Oracle and

00:22:43,450 --> 00:22:48,460
everything it prints it logs to this

00:22:45,490 --> 00:22:50,559
array and then we pass in our start on

00:22:48,460 --> 00:22:53,980
our end range and then we've got our

00:22:50,559 --> 00:22:57,159
implementation our solution prints the

00:22:53,980 --> 00:23:00,009
same array start and end or similar a

00:22:57,159 --> 00:23:01,720
and then we compare them assert that the

00:23:00,009 --> 00:23:03,249
solution login the Oracle log are the

00:23:01,720 --> 00:23:05,080
same that's it's that simple is gonna

00:23:03,249 --> 00:23:10,110
run ten times although you won't see

00:23:05,080 --> 00:23:14,169
that so yeah would you like to sit down

00:23:10,110 --> 00:23:16,570
take a seat so fizzbuzz I thought we

00:23:14,169 --> 00:23:18,429
were just gonna plate fizzbuzz man oh no

00:23:16,570 --> 00:23:23,769
we yeah okay we could play frisbee us

00:23:18,429 --> 00:23:24,759
manually so umm yeah it'll be fine I'll

00:23:23,769 --> 00:23:34,299
be fine what could go wrong

00:23:24,759 --> 00:23:35,860
so fizzbuzz how does fizzbuzz work more

00:23:34,299 --> 00:23:37,749
or less yeah yeah well you start off by

00:23:35,860 --> 00:23:39,249
printing all of the numbers okay and

00:23:37,749 --> 00:23:42,879
then if it is a multiple of three its

00:23:39,249 --> 00:23:45,539
face muffler five it's buzzed so let's

00:23:42,879 --> 00:23:45,539
start with that let's

00:23:46,159 --> 00:23:51,359
that's not golf script okay cool

00:23:49,289 --> 00:23:55,219
so let's start with a people think this

00:23:51,359 --> 00:23:55,219
is scripted it's gonna get really bad

00:23:55,739 --> 00:24:00,269
should we stole that start with a for

00:23:57,659 --> 00:24:05,219
loop go on so yeah we've got we've got a

00:24:00,269 --> 00:24:09,629
start on our end where you're it's fine

00:24:05,219 --> 00:24:13,349
it's fine so we will start going to

00:24:09,629 --> 00:24:21,119
start so be fine you'll be fine in fine

00:24:13,349 --> 00:24:23,279
we should rehearse this that's a good

00:24:21,119 --> 00:24:24,869
point that's a good point

00:24:23,279 --> 00:24:27,239
so instead of using consular we're gonna

00:24:24,869 --> 00:24:30,659
use print and we're gonna print the

00:24:27,239 --> 00:24:32,519
number yeah but you know what let's this

00:24:30,659 --> 00:24:35,969
stop there but I think we've done that

00:24:32,519 --> 00:24:45,829
works let's see what happens

00:24:35,969 --> 00:24:50,099
can everyone see that yep MPM run fears

00:24:45,829 --> 00:24:52,139
buzz hopefully this will work let me go

00:24:50,099 --> 00:24:53,369
and see that so it's going to take a few

00:24:52,139 --> 00:24:55,529
seconds this is trying all the

00:24:53,369 --> 00:24:57,839
variations so remember this testing

00:24:55,529 --> 00:25:00,149
Adams implementation his perfect

00:24:57,839 --> 00:25:01,829
implementation versus the Oracle that we

00:25:00,149 --> 00:25:05,159
downloaded from Stack Overflow a few

00:25:01,829 --> 00:25:10,649
hours ago whoa okay let's scroll up and

00:25:05,159 --> 00:25:12,629
see what happens okay so it's found a

00:25:10,649 --> 00:25:15,749
problem with your implementation sorry I

00:25:12,629 --> 00:25:18,149
don't you haven't got the job so the

00:25:15,749 --> 00:25:20,609
solution that you implant is goes 1 2 3

00:25:18,149 --> 00:25:23,549
where is the Oracle hopefully everyone

00:25:20,609 --> 00:25:30,359
can see this cuz one to face so we've

00:25:23,549 --> 00:25:37,999
made a mistake so I know so let's fix

00:25:30,359 --> 00:25:37,999
that what's the best way to check ok

00:25:42,799 --> 00:25:56,779
yeah modulo and this it so yeah you'll

00:25:53,129 --> 00:25:58,859
have to print sadly his side affecting I

00:25:56,779 --> 00:26:05,909
don't like functional programming anyway

00:25:58,859 --> 00:26:06,690
it's waste time let's go with buzz as

00:26:05,909 --> 00:26:16,049
well that's fine

00:26:06,690 --> 00:26:21,349
why not go all the way that should just

00:26:16,049 --> 00:26:23,729
be I should just be the number right

00:26:21,349 --> 00:26:25,440
that's fine that's fine let's go with

00:26:23,729 --> 00:26:27,799
that let's run it okay let's not panic

00:26:25,440 --> 00:26:27,799
it's fine

00:26:36,629 --> 00:26:43,409
I feel bad ok only a small percent of

00:26:41,399 --> 00:26:44,970
you know is despite running the

00:26:43,409 --> 00:26:48,899
JavaScript group I actually quite

00:26:44,970 --> 00:26:52,470
dislike JavaScript no I just think it's

00:26:48,899 --> 00:26:54,749
really important where are we

00:26:52,470 --> 00:26:57,149
so yeah that didn't quite work so that's

00:26:54,749 --> 00:26:59,039
that's fine so what we can do is we can

00:26:57,149 --> 00:27:01,979
actually check that the modulo 3 is

00:26:59,039 --> 00:27:04,739
equal to water 0 which is that would

00:27:01,979 --> 00:27:07,909
make sense and then we're gonna also

00:27:04,739 --> 00:27:09,149
change that to be fears right probably

00:27:07,909 --> 00:27:12,059
yes

00:27:09,149 --> 00:27:15,710
and then we're gonna go with same thing

00:27:12,059 --> 00:27:20,460
here same treatment equals zero

00:27:15,710 --> 00:27:25,169
cool this who happens that's why you

00:27:20,460 --> 00:27:27,029
should wait pepero grandkids will use an

00:27:25,169 --> 00:27:33,239
oracle function takes all the hard work

00:27:27,029 --> 00:27:36,960
out of it okay okay so it looks like our

00:27:33,239 --> 00:27:39,840
solution goes 1 2 v good 3 whereas our

00:27:36,960 --> 00:27:42,590
Oracle says 1 2 fears doesn't print 3

00:27:39,840 --> 00:27:45,769
the reason why is we've forgotten else

00:27:42,590 --> 00:27:45,769
so yeah

00:27:48,350 --> 00:27:56,360
God now I've forgotten how else's work

00:27:51,740 --> 00:28:09,870
so fine fine yeah so kids that work

00:27:56,360 --> 00:28:12,570
nobody's watching yeah okay yep see

00:28:09,870 --> 00:28:14,250
right there you go okay so it found this

00:28:12,570 --> 00:28:15,929
time you didn't go with one because it's

00:28:14,250 --> 00:28:19,529
found the more interesting failing case

00:28:15,929 --> 00:28:27,779
of two phase three so let's capitalize

00:28:19,529 --> 00:28:32,789
that buzz okay let's run it happens

00:28:27,779 --> 00:28:38,490
you're doing a great job Adam that's why

00:28:32,789 --> 00:28:41,629
I do it delegate and then we'll see what

00:28:38,490 --> 00:28:41,629
the areas Oh

00:28:42,899 --> 00:28:45,509
we're not meant to be printing the

00:28:44,159 --> 00:28:52,440
number so let's get rid of that as well

00:28:45,509 --> 00:28:54,799
that should be inside nails here cool

00:28:52,440 --> 00:28:54,799
good

00:29:00,060 --> 00:29:06,460
so it's a good idea to be doing live

00:29:02,440 --> 00:29:08,140
debugging okay this is more interesting

00:29:06,460 --> 00:29:09,280
and I quite happy well look at what's

00:29:08,140 --> 00:29:12,610
what's happening here

00:29:09,280 --> 00:29:14,020
so the solution goes actually it's kind

00:29:12,610 --> 00:29:16,630
of hard to read but I think that's the

00:29:14,020 --> 00:29:18,970
solution is one two fears for buzz fears

00:29:16,630 --> 00:29:21,250
seven eight fizzbuzz eleven this

00:29:18,970 --> 00:29:23,650
thirteen fourteen fears whereas the

00:29:21,250 --> 00:29:29,880
Oracle goes up that way and then it says

00:29:23,650 --> 00:29:29,880
13 14 15 or one do you I'll try that

00:29:45,780 --> 00:29:49,540
somebody's already solved there we could

00:29:48,250 --> 00:29:51,700
have done this if we just went to stack

00:29:49,540 --> 00:29:55,680
overflow

00:29:51,700 --> 00:29:55,680
I think of a fixing are we

00:30:02,460 --> 00:30:06,760
let's go up being like vs code plug-in

00:30:05,170 --> 00:30:08,220
now which is just like tell me what to

00:30:06,760 --> 00:30:18,420
do

00:30:08,220 --> 00:30:18,420
the motive truth we what did we do wrong

00:30:24,000 --> 00:30:39,630
where is that syntaxerror elsif okay

00:30:30,750 --> 00:30:44,210
probably just me everyone no it's fine

00:30:39,630 --> 00:30:44,210
you're doing a good job I mean okay

00:30:47,570 --> 00:30:54,180
thank you having you've done a fantastic

00:30:49,500 --> 00:30:54,750
job you've got the job when can you

00:30:54,180 --> 00:30:58,800
start

00:30:54,750 --> 00:31:00,960
okay so that was the fizzbuzz demo so

00:30:58,800 --> 00:31:03,630
now you see how Oracle functions work

00:31:00,960 --> 00:31:05,250
you can use this if anytime you reflect

00:31:03,630 --> 00:31:06,960
refactoring or you're implementing

00:31:05,250 --> 00:31:08,550
something in a more efficient way or you

00:31:06,960 --> 00:31:09,870
just want to mess around and see what

00:31:08,550 --> 00:31:13,230
happens you can compare two different

00:31:09,870 --> 00:31:15,150
functions one of the interesting things

00:31:13,230 --> 00:31:18,240
about generators is there is an art to

00:31:15,150 --> 00:31:20,550
writing a good generator here's a

00:31:18,240 --> 00:31:22,110
specific example let's say you want to

00:31:20,550 --> 00:31:24,000
generate even numbers let's say you want

00:31:22,110 --> 00:31:25,650
to generate thousands even numbers how

00:31:24,000 --> 00:31:27,030
could you go about this these generators

00:31:25,650 --> 00:31:29,100
will both do that for you

00:31:27,030 --> 00:31:31,110
okay but I'll I want to explain the

00:31:29,100 --> 00:31:32,730
differences so this one here if everyone

00:31:31,110 --> 00:31:34,620
can see that you're generating a natural

00:31:32,730 --> 00:31:36,630
number and then you're filtering it just

00:31:34,620 --> 00:31:39,510
like an array filter and you're making

00:31:36,630 --> 00:31:42,030
sure that each number modulo two is

00:31:39,510 --> 00:31:43,410
equal to zero so that's a good classic

00:31:42,030 --> 00:31:45,840
way of testing if something is an even

00:31:43,410 --> 00:31:49,200
number what this will do is it will

00:31:45,840 --> 00:31:51,570
generate two thousand numbers even an

00:31:49,200 --> 00:31:53,640
odd and so half of them away and give

00:31:51,570 --> 00:31:55,980
you a thousand even numbers so it's

00:31:53,640 --> 00:31:57,330
essentially 50% inefficient it's doing

00:31:55,980 --> 00:32:00,570
twice as much work as it needs to do

00:31:57,330 --> 00:32:01,860
whereas this implementation here takes

00:32:00,570 --> 00:32:03,630
natural numbers exactly the same way

00:32:01,860 --> 00:32:07,230
they said it Maps them and multiplies

00:32:03,630 --> 00:32:11,400
them by two okay so if that's one x two

00:32:07,230 --> 00:32:13,080
two two four three six the point is if

00:32:11,400 --> 00:32:14,250
you need a thousand even numbers this

00:32:13,080 --> 00:32:17,670
will generate you a thousand even

00:32:14,250 --> 00:32:19,740
numbers just like that the key thing

00:32:17,670 --> 00:32:21,870
here is that as I've said here the

00:32:19,740 --> 00:32:23,760
description is not the recipe often it's

00:32:21,870 --> 00:32:26,850
a better way to the best best way to

00:32:23,760 --> 00:32:29,460
generate a valid value that you want to

00:32:26,850 --> 00:32:31,680
use in your tests is using a recipe

00:32:29,460 --> 00:32:34,110
rather than filtering based on the

00:32:31,680 --> 00:32:36,750
description it's a bit like in a

00:32:34,110 --> 00:32:38,070
yeah on a factory line okay let's say

00:32:36,750 --> 00:32:40,350
you need to produce something like the

00:32:38,070 --> 00:32:43,080
iPhone you can either try completely

00:32:40,350 --> 00:32:45,630
random collections of metal and bits of

00:32:43,080 --> 00:32:47,940
glass and then check is this an iPhone

00:32:45,630 --> 00:32:50,340
no is this an iPhone you'd be there all

00:32:47,940 --> 00:32:53,880
day they were typically take your wages

00:32:50,340 --> 00:32:55,169
right whereas if you have an instruction

00:32:53,880 --> 00:32:56,970
manual that explains how to combine

00:32:55,169 --> 00:32:58,529
glass and metal in a particular way to

00:32:56,970 --> 00:33:00,120
make an iPhone you'll make one almost

00:32:58,529 --> 00:33:01,919
every time you might want to filter out

00:33:00,120 --> 00:33:03,570
the defective ones at the end but now

00:33:01,919 --> 00:33:05,640
that gives you a good intuition for how

00:33:03,570 --> 00:33:09,529
to build good generators versus bad

00:33:05,640 --> 00:33:14,159
generators it's bad bad generator so

00:33:09,529 --> 00:33:16,470
yeah next slide the other thing I want

00:33:14,159 --> 00:33:17,940
to talk about is the fact that a lot of

00:33:16,470 --> 00:33:20,220
unit testing libraries will encourage

00:33:17,940 --> 00:33:22,620
you to use before and after blocks to do

00:33:20,220 --> 00:33:24,690
test setup and teardown that's not going

00:33:22,620 --> 00:33:25,889
to work with fast check and it probably

00:33:24,690 --> 00:33:27,090
won't work with a lot of the proper

00:33:25,889 --> 00:33:29,279
testing libraries you use because they

00:33:27,090 --> 00:33:31,470
typically run their properties they show

00:33:29,279 --> 00:33:35,070
the exhausts or the combinations inside

00:33:31,470 --> 00:33:37,169
a given test so your before and after

00:33:35,070 --> 00:33:40,289
were on once and then it'll run a

00:33:37,169 --> 00:33:42,330
thousand actual tests so if you're doing

00:33:40,289 --> 00:33:43,769
any side effects if you need to reset

00:33:42,330 --> 00:33:45,870
the state of something it's not going to

00:33:43,769 --> 00:33:48,240
work how you expect you won't be just be

00:33:45,870 --> 00:33:49,769
able to dump it in fast check gives you

00:33:48,240 --> 00:33:51,330
some facility here gives you these

00:33:49,769 --> 00:33:53,039
before and after functions where you can

00:33:51,330 --> 00:33:56,149
essentially copy/paste your setup and

00:33:53,039 --> 00:33:59,639
teardown stuff to put in there however I

00:33:56,149 --> 00:34:03,059
would suggest actually teardown and set

00:33:59,639 --> 00:34:06,000
up functionalities essentially mutating

00:34:03,059 --> 00:34:08,310
global states that's why spies and mocks

00:34:06,000 --> 00:34:10,230
or a workaround there a spider to catch

00:34:08,310 --> 00:34:12,929
a fly and that's how you're better off

00:34:10,230 --> 00:34:15,570
not doing that at all if you can instead

00:34:12,929 --> 00:34:16,859
pass in your values into your functions

00:34:15,570 --> 00:34:19,530
your dependencies into your functions

00:34:16,859 --> 00:34:21,270
using dependency injection it may mean

00:34:19,530 --> 00:34:23,940
your code is a little bit more of a Bose

00:34:21,270 --> 00:34:25,679
but in the long run you're trading ease

00:34:23,940 --> 00:34:27,629
for simplicity and that's usually a good

00:34:25,679 --> 00:34:31,260
trade-off that's why I have this catch

00:34:27,629 --> 00:34:34,139
phrase don't side-effect dependency

00:34:31,260 --> 00:34:37,070
inject always saying it that's a con

00:34:34,139 --> 00:34:39,750
catch phrase you'll often hear me say a

00:34:37,070 --> 00:34:42,060
lot of you will be thinking well my code

00:34:39,750 --> 00:34:43,290
can't be tested I write untestable code

00:34:42,060 --> 00:34:45,119
it's a badge of honor

00:34:43,290 --> 00:34:46,710
well actually anyone who's done unit

00:34:45,119 --> 00:34:47,860
testing for a little while find out that

00:34:46,710 --> 00:34:49,810
first of all it's hard to

00:34:47,860 --> 00:34:54,010
tests until you change the way you write

00:34:49,810 --> 00:34:55,990
code to make to make it testable and

00:34:54,010 --> 00:34:57,520
actually the same is true for property

00:34:55,990 --> 00:34:59,020
tests people will be sitting there

00:34:57,520 --> 00:35:01,660
thinking I'm just imagining what you're

00:34:59,020 --> 00:35:04,330
thinking I can't think what properties

00:35:01,660 --> 00:35:05,980
would apply to my code this all seems

00:35:04,330 --> 00:35:07,750
very complicated my code just does this

00:35:05,980 --> 00:35:09,640
one thing another thing that it's done

00:35:07,750 --> 00:35:11,980
it's nice and simple well actually you'd

00:35:09,640 --> 00:35:13,630
be surprised if you if you take a little

00:35:11,980 --> 00:35:15,400
while look at your code think could I

00:35:13,630 --> 00:35:17,410
pull this out does this have a property

00:35:15,400 --> 00:35:19,510
that I could test against it doesn't

00:35:17,410 --> 00:35:20,200
even have to be particularly complicated

00:35:19,510 --> 00:35:21,970
okay

00:35:20,200 --> 00:35:23,800
so it could be that for all of these

00:35:21,970 --> 00:35:26,770
inputs my code never throws an exception

00:35:23,800 --> 00:35:30,280
that's a perfectly valid property to

00:35:26,770 --> 00:35:31,390
test for and that's a good for property

00:35:30,280 --> 00:35:33,490
to test for if you want your code to be

00:35:31,390 --> 00:35:35,410
robust you want exceptions to be thrown

00:35:33,490 --> 00:35:39,490
in specific circumstances you don't just

00:35:35,410 --> 00:35:41,860
explode randomly yeah it doesn't just

00:35:39,490 --> 00:35:43,360
provide robustness it also allows you to

00:35:41,860 --> 00:35:46,840
think carefully about the way your code

00:35:43,360 --> 00:35:49,120
works it allows you to think well this

00:35:46,840 --> 00:35:50,740
may I may be using this for user IDs but

00:35:49,120 --> 00:35:52,360
actually I'll work for any string if

00:35:50,740 --> 00:35:54,160
it's sorting customers in a specific

00:35:52,360 --> 00:35:55,900
order for example you might think

00:35:54,160 --> 00:35:57,610
actually I can reuse this elsewhere in

00:35:55,900 --> 00:35:59,350
other places because this works

00:35:57,610 --> 00:36:01,630
generically for all strings rather

00:35:59,350 --> 00:36:06,220
although all numbers instead of specific

00:36:01,630 --> 00:36:09,610
concepts yeah and that's the actually

00:36:06,220 --> 00:36:11,500
the end of the first part the way the

00:36:09,610 --> 00:36:13,960
second parts not as long as the first

00:36:11,500 --> 00:36:16,650
part but that's introducing property

00:36:13,960 --> 00:36:19,990
testing I'm now going to be explaining

00:36:16,650 --> 00:36:24,190
the specific technique that I used at

00:36:19,990 --> 00:36:27,700
Yuka tricity to test my test my Amazon

00:36:24,190 --> 00:36:29,170
service functions and the way you rely

00:36:27,700 --> 00:36:31,690
on dependencies like

00:36:29,170 --> 00:36:33,480
dynamodb or Kinesis or various

00:36:31,690 --> 00:36:35,290
technologies and Amazon gives you I

00:36:33,480 --> 00:36:37,600
developed them you can using property

00:36:35,290 --> 00:36:41,380
testing to simulate those but I'm going

00:36:37,600 --> 00:36:43,420
to tell some jokes again yeah

00:36:41,380 --> 00:36:48,660
why do functional programmers never get

00:36:43,420 --> 00:36:48,660
lost they always use Maps

00:36:50,920 --> 00:36:56,469
if you didn't like this one you're gonna

00:36:52,569 --> 00:37:00,009
hate this one if why did it take 20

00:36:56,469 --> 00:37:08,229
years for JavaScript to get classes they

00:37:00,009 --> 00:37:09,930
spent too long prototyping so modding

00:37:08,229 --> 00:37:12,369
dependencies as generative properties

00:37:09,930 --> 00:37:14,589
our dependency is any different to

00:37:12,369 --> 00:37:17,170
function arguments in my opinion I say

00:37:14,589 --> 00:37:18,549
they no they are the same thing I think

00:37:17,170 --> 00:37:20,949
it's a false dichotomy that people think

00:37:18,549 --> 00:37:23,229
of values and then they're the the rest

00:37:20,949 --> 00:37:26,589
of this the programmers fundamentally

00:37:23,229 --> 00:37:28,449
separate things I think you can actually

00:37:26,589 --> 00:37:30,880
treat your dependencies as value spaces

00:37:28,449 --> 00:37:33,759
in much the same way you treat any other

00:37:30,880 --> 00:37:35,380
kind of input to your functions the

00:37:33,759 --> 00:37:36,279
reason why I started thinking this way

00:37:35,380 --> 00:37:38,079
as I was working with a lot of

00:37:36,279 --> 00:37:39,880
documentation that was lacking I would

00:37:38,079 --> 00:37:42,160
be obvious what for example a database

00:37:39,880 --> 00:37:43,359
might return in a given context you're

00:37:42,160 --> 00:37:46,719
working with an eventually consistent

00:37:43,359 --> 00:37:48,039
database that might return one value one

00:37:46,719 --> 00:37:49,630
point and another value another point

00:37:48,039 --> 00:37:52,209
for the same operation well at this

00:37:49,630 --> 00:37:53,589
point you need to start using these kind

00:37:52,209 --> 00:37:57,849
of probabilistic techniques to simulate

00:37:53,589 --> 00:38:01,839
that and yeah it's said guessing why not

00:37:57,849 --> 00:38:04,749
try everything this leads me into poss

00:38:01,839 --> 00:38:06,369
tells law can you see this he said that

00:38:04,749 --> 00:38:08,199
you should be conservative in what you

00:38:06,369 --> 00:38:10,390
sends and liberal and what you accept

00:38:08,199 --> 00:38:12,099
it's less a law and more an economic

00:38:10,390 --> 00:38:15,160
principle really that if you're dealing

00:38:12,099 --> 00:38:19,150
with any distributed system whether it's

00:38:15,160 --> 00:38:20,920
network requests or whether it's things

00:38:19,150 --> 00:38:23,109
in the file system or a database of

00:38:20,920 --> 00:38:24,880
changes over time you need to be able to

00:38:23,109 --> 00:38:26,979
cope with change that you can't predict

00:38:24,880 --> 00:38:29,349
there's no type system that works across

00:38:26,979 --> 00:38:32,140
the network as much as people would like

00:38:29,349 --> 00:38:34,119
to believe there is so this is the only

00:38:32,140 --> 00:38:36,519
rational way to deal with with with

00:38:34,119 --> 00:38:37,989
change now we're going to look at

00:38:36,519 --> 00:38:40,180
another demo this is going to show off

00:38:37,989 --> 00:38:43,469
don't worry I don't need a volunteer so

00:38:40,180 --> 00:38:46,359
relax this is gonna be showing off

00:38:43,469 --> 00:38:47,859
modeling your dependencies as generative

00:38:46,359 --> 00:38:49,630
properties so what we're going to be

00:38:47,859 --> 00:38:55,559
simulating here is a piece of delivery

00:38:49,630 --> 00:38:58,040
service okay this is an API call that

00:38:55,559 --> 00:39:00,740
accepts

00:38:58,040 --> 00:39:04,550
as its dependencies it's a dependency

00:39:00,740 --> 00:39:09,200
injection a database and a city map and

00:39:04,550 --> 00:39:11,210
it responds to a user's request of their

00:39:09,200 --> 00:39:13,190
order and narrow address so their order

00:39:11,210 --> 00:39:16,130
would be a pepperoni pizza and their

00:39:13,190 --> 00:39:19,280
address would be wherever they live it

00:39:16,130 --> 00:39:20,750
then adds that order to the database so

00:39:19,280 --> 00:39:22,810
this is a dependency here you're adding

00:39:20,750 --> 00:39:24,920
order and the database will return back

00:39:22,810 --> 00:39:27,680
cooking time how long will take for that

00:39:24,920 --> 00:39:29,720
piece to be ready you then take the

00:39:27,680 --> 00:39:33,830
address on the cooking time and pass it

00:39:29,720 --> 00:39:36,380
into the city map which will give you an

00:39:33,830 --> 00:39:38,300
estimate a delivery estimate and you

00:39:36,380 --> 00:39:40,310
return that to the user so if you want

00:39:38,300 --> 00:39:42,080
to order pizza I'll tell you well it's

00:39:40,310 --> 00:39:43,400
gonna take 20 minutes to cook you live

00:39:42,080 --> 00:39:45,970
on the other side of Bristol so it's

00:39:43,400 --> 00:39:48,290
going to take 40 minutes to get there

00:39:45,970 --> 00:39:50,660
this seems pretty straightforward

00:39:48,290 --> 00:39:54,980
but actually there's plenty of ways this

00:39:50,660 --> 00:39:57,590
can break ahead of time I put together a

00:39:54,980 --> 00:40:01,550
fairly oh don't do that a fairly

00:39:57,590 --> 00:40:04,940
complicated looking property test that

00:40:01,550 --> 00:40:05,810
simulates our dependencies hopefully

00:40:04,940 --> 00:40:07,880
you'll be able to see this I'm going to

00:40:05,810 --> 00:40:10,700
show you a kind of key Hut keyhole view

00:40:07,880 --> 00:40:12,440
of what's happening here so we're gonna

00:40:10,700 --> 00:40:17,990
simulate our database by creating an

00:40:12,440 --> 00:40:22,190
array of either an integer undefined or

00:40:17,990 --> 00:40:24,260
a string of database error okay and our

00:40:22,190 --> 00:40:25,910
city map is gonna be simulated as a node

00:40:24,260 --> 00:40:27,680
again I look very mind the integer would

00:40:25,910 --> 00:40:29,720
be how long it's gonna take for the

00:40:27,680 --> 00:40:31,100
pizzas to cook and then the city map

00:40:29,720 --> 00:40:33,080
will be how long it take to get across

00:40:31,100 --> 00:40:37,190
the town could return undefined because

00:40:33,080 --> 00:40:39,830
the API has gone down and or it could

00:40:37,190 --> 00:40:43,340
return an estimation error what we do

00:40:39,830 --> 00:40:45,770
then is we store number of times a

00:40:43,340 --> 00:40:51,080
database in the city has been the city

00:40:45,770 --> 00:40:53,119
map estimation has been invoked and we

00:40:51,080 --> 00:40:54,950
expose these as functions so every time

00:40:53,119 --> 00:40:58,640
an order is added that's exactly same ad

00:40:54,950 --> 00:41:01,609
order function you saw before if there

00:40:58,640 --> 00:41:04,430
is no order throws an error otherwise

00:41:01,609 --> 00:41:06,710
increments of database count modulo zit

00:41:04,430 --> 00:41:08,480
with the length of the pattern that we

00:41:06,710 --> 00:41:10,820
just generated before which is going to

00:41:08,480 --> 00:41:12,699
be an array of numbers or undefined or

00:41:10,820 --> 00:41:14,779
so

00:41:12,699 --> 00:41:16,880
if it turns out it's a database error

00:41:14,779 --> 00:41:17,509
throw an exception also turn the value

00:41:16,880 --> 00:41:18,709
okay

00:41:17,509 --> 00:41:20,749
so let me explain what that would look

00:41:18,709 --> 00:41:24,079
like every time we generate let's say

00:41:20,749 --> 00:41:26,059
it's an array of you know 1015 database

00:41:24,079 --> 00:41:27,799
error undefined first time the database

00:41:26,059 --> 00:41:29,689
add order function is called

00:41:27,799 --> 00:41:31,819
it's gonna return 15 second time it's

00:41:29,689 --> 00:41:33,049
gonna be 15 third time it's gonna be

00:41:31,819 --> 00:41:35,809
database error and the fourth time it's

00:41:33,049 --> 00:41:37,369
gonna return undefined we don't exactly

00:41:35,809 --> 00:41:38,509
same thing for the city map I'm not

00:41:37,369 --> 00:41:41,719
gonna go into the details here but it's

00:41:38,509 --> 00:41:44,749
exactly the same principle we then

00:41:41,719 --> 00:41:46,699
generate our orders so you can see here

00:41:44,749 --> 00:41:48,409
pepperoni pizza margarita veggie pizza

00:41:46,699 --> 00:41:50,179
you have one of each we're going to

00:41:48,409 --> 00:41:53,509
generate a quantity and this is our

00:41:50,179 --> 00:41:55,189
array of our orders and our address is

00:41:53,509 --> 00:41:58,029
just an array of strings that we

00:41:55,189 --> 00:42:00,919
combined that's fine this is our test

00:41:58,029 --> 00:42:02,269
the way it works is we invoke our API

00:42:00,919 --> 00:42:05,599
this is exactly the same function you

00:42:02,269 --> 00:42:08,630
saw before okay and then we iterate

00:42:05,599 --> 00:42:11,959
through the results and we make sure

00:42:08,630 --> 00:42:14,689
that for every invocation we either got

00:42:11,959 --> 00:42:16,399
back status of success and our delivery

00:42:14,689 --> 00:42:18,289
time that's and a delivery estimate

00:42:16,399 --> 00:42:21,499
that's a number and greater than zero or

00:42:18,289 --> 00:42:23,959
a failure message or an error with a

00:42:21,499 --> 00:42:25,429
message that the use of is happy to see

00:42:23,959 --> 00:42:28,039
we're not exposing any internal

00:42:25,429 --> 00:42:30,199
implementation details that's it that's

00:42:28,039 --> 00:42:32,570
the entire test so let's see what

00:42:30,199 --> 00:42:35,639
happens okay

00:42:32,570 --> 00:42:35,639
[Music]

00:42:37,700 --> 00:42:41,619
and weakness

00:42:54,000 --> 00:43:02,460
all sorts of errors we have have to have

00:42:57,100 --> 00:43:04,750
at least one order we have to yet

00:43:02,460 --> 00:43:07,120
because it could generate an empty array

00:43:04,750 --> 00:43:12,070
if there's all sorts of exceptions could

00:43:07,120 --> 00:43:13,330
be thrown luckily I fix this beforehand

00:43:12,070 --> 00:43:15,070
so we're just going to use that instead

00:43:13,330 --> 00:43:19,960
so I'm going to show you what that looks

00:43:15,070 --> 00:43:22,180
like now here we go it's fixed can

00:43:19,960 --> 00:43:25,150
everyone see this so first of all we

00:43:22,180 --> 00:43:27,010
check the order length is zero if it is

00:43:25,150 --> 00:43:30,060
we return fail need at least one order

00:43:27,010 --> 00:43:32,590
we check the address this one order

00:43:30,060 --> 00:43:35,920
address you'd have least one in value as

00:43:32,590 --> 00:43:37,300
a typo we get the cooking time if it

00:43:35,920 --> 00:43:40,420
turns out it's not a number or if it's

00:43:37,300 --> 00:43:42,430
less than zero we return a complaint we

00:43:40,420 --> 00:43:44,710
get back the estimate estimate of time

00:43:42,430 --> 00:43:47,980
if it's not a number if it's less than

00:43:44,710 --> 00:43:49,840
zero we give you a guesstimate because

00:43:47,980 --> 00:43:50,800
at least the orders gone in we know it's

00:43:49,840 --> 00:43:51,640
going to take half an hour to make the

00:43:50,800 --> 00:43:52,870
beat so we don't know how long it's

00:43:51,640 --> 00:43:54,100
gonna take there to get there but we

00:43:52,870 --> 00:43:55,630
until the user is going to take an hour

00:43:54,100 --> 00:43:57,160
that's fine so we've got a fallback

00:43:55,630 --> 00:44:00,340
there of a thousand times 60 times 60

00:43:57,160 --> 00:44:02,980
and then we return success so this is an

00:44:00,340 --> 00:44:05,200
example of how if you have a dependency

00:44:02,980 --> 00:44:06,880
that could return all sorts of broken

00:44:05,200 --> 00:44:08,470
values such as undefined or throw an

00:44:06,880 --> 00:44:10,750
exception we're handling it in the very

00:44:08,470 --> 00:44:12,790
end we try and catch and wrap the entire

00:44:10,750 --> 00:44:14,770
things we don't expose any internal

00:44:12,790 --> 00:44:19,740
implementation details back to the user

00:44:14,770 --> 00:44:19,740
so let's run that again see what happens

00:44:27,380 --> 00:44:31,310
hopefully it should pass there we go

00:44:29,330 --> 00:44:35,200
that's good so it passes and furthermore

00:44:31,310 --> 00:44:35,200
I logged out all the examples of

00:44:35,890 --> 00:44:40,160
database and city map patterns that can

00:44:38,480 --> 00:44:41,450
be produced so you can see here that it

00:44:40,160 --> 00:44:43,400
went through all the iterations you can

00:44:41,450 --> 00:44:44,570
see that you've got a the first time in

00:44:43,400 --> 00:44:47,300
the database of court database error

00:44:44,570 --> 00:44:49,910
second time undefined negative number

00:44:47,300 --> 00:44:51,470
city map undefined first time so that's

00:44:49,910 --> 00:44:53,390
it's that easy to simulate it

00:44:51,470 --> 00:44:56,420
dependencies using properties are there

00:44:53,390 --> 00:44:57,320
any downsides to this yeah there are

00:44:56,420 --> 00:45:01,370
some downsides

00:44:57,320 --> 00:45:03,560
so the downsides are that there's a

00:45:01,370 --> 00:45:06,020
disconnect between your app code and

00:45:03,560 --> 00:45:07,130
your generators okay so your generators

00:45:06,020 --> 00:45:10,010
can be trying all these different

00:45:07,130 --> 00:45:11,990
combinations his example our database

00:45:10,010 --> 00:45:13,910
produced database error that was all

00:45:11,990 --> 00:45:14,870
it's going to ever produce but a city

00:45:13,910 --> 00:45:16,850
map would have produced all these

00:45:14,870 --> 00:45:19,400
interesting values but we know from our

00:45:16,850 --> 00:45:20,570
logic that if you didn't get a estimate

00:45:19,400 --> 00:45:22,850
on the cooking time you would never try

00:45:20,570 --> 00:45:25,490
and even get an estimate on the delivery

00:45:22,850 --> 00:45:27,200
time so this is wasted exploration of

00:45:25,490 --> 00:45:29,060
this phase space of your dependencies

00:45:27,200 --> 00:45:30,590
same with this one here sister

00:45:29,060 --> 00:45:32,150
database is undefined so we know the

00:45:30,590 --> 00:45:33,620
order wouldn't go through but we're

00:45:32,150 --> 00:45:36,410
testing all these different combinations

00:45:33,620 --> 00:45:37,940
of undefined large positive number large

00:45:36,410 --> 00:45:40,460
negative numbers this is wasted

00:45:37,940 --> 00:45:44,060
computational power nothing of value is

00:45:40,460 --> 00:45:45,830
being tested here is there a solution so

00:45:44,060 --> 00:45:48,680
there is a solution what if you could

00:45:45,830 --> 00:45:51,850
design your app code so that can it

00:45:48,680 --> 00:45:54,290
constrains the dimensions of your

00:45:51,850 --> 00:45:56,660
dependencies well if you can make it so

00:45:54,290 --> 00:45:59,360
that if you're not invoking the air

00:45:56,660 --> 00:46:00,140
database call five times it will never

00:45:59,360 --> 00:46:02,630
try and explore these different

00:46:00,140 --> 00:46:05,030
combinations there is a way to solve

00:46:02,630 --> 00:46:08,540
this actually solved it in this talk

00:46:05,030 --> 00:46:09,920
which is quite good using a custom monad

00:46:08,540 --> 00:46:11,960
now you don't have to know what monads

00:46:09,920 --> 00:46:14,960
are but effectively wraps the property

00:46:11,960 --> 00:46:16,670
generator with a way of storing State

00:46:14,960 --> 00:46:20,180
and a way of doing error handling in the

00:46:16,670 --> 00:46:22,340
same way the promises work by reframing

00:46:20,180 --> 00:46:25,400
your program as a sequence of monadic

00:46:22,340 --> 00:46:26,990
steps you can constrain the dimensions

00:46:25,400 --> 00:46:28,700
of your date of your dependencies to

00:46:26,990 --> 00:46:30,590
your business logic let's see what this

00:46:28,700 --> 00:46:36,620
would look like here's a contrived

00:46:30,590 --> 00:46:39,320
example so a contrived example is this

00:46:36,620 --> 00:46:45,120
one right here

00:46:39,320 --> 00:46:47,540
so we're generating a B and C oh sorry

00:46:45,120 --> 00:46:47,540
yep

00:46:54,349 --> 00:47:00,979
can you see that yeah you can see that

00:46:57,259 --> 00:47:01,640
cool okay so we've got a simple property

00:47:00,979 --> 00:47:03,559
test here

00:47:01,640 --> 00:47:05,689
where this is foo this assimilating to

00:47:03,559 --> 00:47:07,369
our database bar might be simulating our

00:47:05,689 --> 00:47:09,369
city map from before it can be whatever

00:47:07,369 --> 00:47:12,979
is just arbitrary different dependencies

00:47:09,369 --> 00:47:15,709
foo every time it's invoked returns a

00:47:12,979 --> 00:47:18,769
value from a B or C wrapped in this

00:47:15,709 --> 00:47:20,539
custom monad it then stores what value

00:47:18,769 --> 00:47:22,130
was generated in this state here you

00:47:20,539 --> 00:47:24,229
have to know too much about other state

00:47:22,130 --> 00:47:26,569
handling stuff works just just assume it

00:47:24,229 --> 00:47:28,729
does for now bar does the same thing but

00:47:26,569 --> 00:47:30,739
for one two and three it just stores in

00:47:28,729 --> 00:47:32,989
place so it's very very simple code a B

00:47:30,739 --> 00:47:35,089
and C store it one two and three store

00:47:32,989 --> 00:47:36,650
it we and then we have a very simple

00:47:35,089 --> 00:47:38,179
pretty test here it's actually just

00:47:36,650 --> 00:47:40,249
logging out what the state would be it

00:47:38,179 --> 00:47:41,839
doesn't do any actual testing we then

00:47:40,249 --> 00:47:44,349
invoke off function here this is our app

00:47:41,839 --> 00:47:46,519
code called enumerate now enumerate

00:47:44,349 --> 00:47:51,499
takes our dependencies and it only uses

00:47:46,519 --> 00:47:54,169
foo so it invokes foo and then with the

00:47:51,499 --> 00:47:55,789
result of foo which returns a monad that

00:47:54,169 --> 00:47:58,009
has a chain function remember that's

00:47:55,789 --> 00:48:01,609
exactly same as a promise then so

00:47:58,009 --> 00:48:04,489
imagine this is then we then invoke foo

00:48:01,609 --> 00:48:06,199
again and then we chain and invoke

00:48:04,489 --> 00:48:08,589
through once more so let's see what that

00:48:06,199 --> 00:48:08,589
would look like

00:48:16,590 --> 00:48:26,800
we don't want to be seeing any numbers

00:48:18,730 --> 00:48:27,580
just letters perfect so you can see that

00:48:26,800 --> 00:48:31,090
it's trying all the different

00:48:27,580 --> 00:48:32,470
combinations of CBC ACB you'll see it's

00:48:31,090 --> 00:48:34,990
trying all these different combinations

00:48:32,470 --> 00:48:36,400
you'll notice here that unlike our

00:48:34,990 --> 00:48:39,280
example before there's no different

00:48:36,400 --> 00:48:41,590
numbers it's just letters that means it

00:48:39,280 --> 00:48:43,090
isn't trying to explore that space of

00:48:41,590 --> 00:48:44,940
the dependency it never uses it

00:48:43,090 --> 00:48:47,380
understands you're only ever using foo

00:48:44,940 --> 00:48:50,500
to show how powerful this is here's a

00:48:47,380 --> 00:48:52,570
more complicated example this is the

00:48:50,500 --> 00:48:54,700
same version of the business logic but

00:48:52,570 --> 00:48:57,670
the sec the first time we call foo we

00:48:54,700 --> 00:49:01,990
check if X is equal to B then we invoke

00:48:57,670 --> 00:49:04,320
bar twice or just foo so let's see what

00:49:01,990 --> 00:49:04,320
that would look like

00:49:13,510 --> 00:49:19,570
cool so you can see that when the when

00:49:17,020 --> 00:49:21,609
be was the first result it actually did

00:49:19,570 --> 00:49:23,440
this used another dependency in a

00:49:21,609 --> 00:49:25,030
different way and that phase space was

00:49:23,440 --> 00:49:26,710
explored it did tried two and three

00:49:25,030 --> 00:49:28,960
whereas for all the examples where it

00:49:26,710 --> 00:49:31,060
was CIA it didn't even try exploring

00:49:28,960 --> 00:49:33,160
that space so it's essentially wrapping

00:49:31,060 --> 00:49:36,040
all those combinations it was trying

00:49:33,160 --> 00:49:38,290
blindly before it now understands that

00:49:36,040 --> 00:49:40,150
you're using only a specific part of

00:49:38,290 --> 00:49:41,680
your dependencies in your test and the

00:49:40,150 --> 00:49:43,900
reason why is that the app code is now

00:49:41,680 --> 00:49:45,670
generating the properties itself it's no

00:49:43,900 --> 00:49:48,340
longer in the test body but your app

00:49:45,670 --> 00:49:51,160
code is creating the generators through

00:49:48,340 --> 00:49:56,350
this chaining mechanism and that's

00:49:51,160 --> 00:50:00,490
that's basically that's it yeah I have a

00:49:56,350 --> 00:50:02,109
conclusion and the conclusion is the why

00:50:00,490 --> 00:50:04,180
have I told you all this I wanted to

00:50:02,109 --> 00:50:06,220
first of all prove that property testing

00:50:04,180 --> 00:50:08,109
can make your code more robust it can

00:50:06,220 --> 00:50:09,280
bust all of the assumptions that you

00:50:08,109 --> 00:50:11,590
make about what your function actually

00:50:09,280 --> 00:50:13,960
does instead of having to enumerate all

00:50:11,590 --> 00:50:16,119
these different unique example based

00:50:13,960 --> 00:50:18,130
unit tests it will just try everything

00:50:16,119 --> 00:50:19,180
for you and find the cases where you

00:50:18,130 --> 00:50:20,740
were wrong

00:50:19,180 --> 00:50:22,600
and the other thing I want to show is

00:50:20,740 --> 00:50:25,119
that property testing doesn't have to

00:50:22,600 --> 00:50:27,220
just be used for simple values you can

00:50:25,119 --> 00:50:31,330
actually use it to simulate processes or

00:50:27,220 --> 00:50:32,590
stateful systems and and there is some

00:50:31,330 --> 00:50:33,880
downsides of that it can be quite

00:50:32,590 --> 00:50:37,030
inefficient and let's use this Cheyney

00:50:33,880 --> 00:50:39,700
mechanism and I will open-source my

00:50:37,030 --> 00:50:40,290
custom monad at some point when I get

00:50:39,700 --> 00:50:42,880
around to it

00:50:40,290 --> 00:50:50,179
cool that's it

00:50:42,880 --> 00:50:50,179

YouTube URL: https://www.youtube.com/watch?v=ShlC4Ag2URI


