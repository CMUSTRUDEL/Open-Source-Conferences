Title: Dan Abramov: Beyond React 16 | JSConf Iceland
Publication date: 2018-04-06
Playlist: JSConf Iceland 2018
Description: 
	https://2018.jsconf.is/speakers/dan-abramov/

React 16 was released several months ago. Even though this update was largely API-compatible, the rewritten internal engine included new long-requested features and opened the door for exciting future possibilities.

In this talk, Dan will share the React teamâ€™s vision for what the future of React might look like, including some never before seen prototypes.

Whether or not you use React, Dan hopes that you will find something valuable in this talk, and that it sparks new conversations about building delightful user interfaces.
Captions: 
	00:00:02,060 --> 00:00:10,740
all right hi my name is Dan and I work

00:00:06,029 --> 00:00:12,150
at Facebook on the react team and in

00:00:10,740 --> 00:00:14,340
this talk I want to talk about the

00:00:12,150 --> 00:00:16,410
future of react and originally when I

00:00:14,340 --> 00:00:19,080
planned this talk I thought that I would

00:00:16,410 --> 00:00:21,750
talk about react 16o release and then

00:00:19,080 --> 00:00:24,150
the upcoming react 16 free release which

00:00:21,750 --> 00:00:26,310
finally fixes the contacts API and then

00:00:24,150 --> 00:00:28,529
talk a little bit at the end about the

00:00:26,310 --> 00:00:30,449
future of react but I was playing with

00:00:28,529 --> 00:00:33,390
some features that my teammates have

00:00:30,449 --> 00:00:34,920
been building like future features some

00:00:33,390 --> 00:00:37,620
of them we've talked before some of them

00:00:34,920 --> 00:00:39,000
we've never even talked before and I

00:00:37,620 --> 00:00:40,800
realized that I actually want to

00:00:39,000 --> 00:00:43,110
dedicate my whole talk to these new

00:00:40,800 --> 00:00:45,719
features that aren't available yet but I

00:00:43,110 --> 00:00:50,640
find them pretty fascinating and I hope

00:00:45,719 --> 00:00:52,649
you like them too so disclaimer I'm

00:00:50,640 --> 00:00:56,370
going to show the demos this is a very

00:00:52,649 --> 00:00:57,629
kind of demo oriented talk the things

00:00:56,370 --> 00:01:00,420
that I'm showing are not production

00:00:57,629 --> 00:01:04,229
already yet the exact api's will change

00:01:00,420 --> 00:01:06,390
don't fixate on them too much but I want

00:01:04,229 --> 00:01:08,130
to emphasize that this this is a real

00:01:06,390 --> 00:01:11,640
builds of react so there's enough fake

00:01:08,130 --> 00:01:15,420
journals these are using actual actual

00:01:11,640 --> 00:01:18,630
react code and I want to start with a

00:01:15,420 --> 00:01:22,070
question and the question is as library

00:01:18,630 --> 00:01:24,720
developers we need to think about our

00:01:22,070 --> 00:01:27,030
immediate users the developers who are

00:01:24,720 --> 00:01:29,280
building apps and also the users of our

00:01:27,030 --> 00:01:33,299
users that is the actual people parties

00:01:29,280 --> 00:01:35,430
in those apps and so at Facebook our

00:01:33,299 --> 00:01:37,439
scale is pretty global so we need to

00:01:35,430 --> 00:01:41,040
consider all kinds of connections and

00:01:37,439 --> 00:01:43,920
all kinds of devices such as you know

00:01:41,040 --> 00:01:46,619
high powered CPUs like on a laptop or

00:01:43,920 --> 00:01:48,869
low powered CPU such as on the mobile

00:01:46,619 --> 00:01:51,570
device and either fast or slow

00:01:48,869 --> 00:01:54,450
connections and we need to think about

00:01:51,570 --> 00:01:57,930
how can we as library developers empower

00:01:54,450 --> 00:02:00,840
the application developers to give the

00:01:57,930 --> 00:02:03,030
best user experience regardless of the

00:02:00,840 --> 00:02:04,829
device or the network and is there

00:02:03,030 --> 00:02:07,430
anything that we are can do better to

00:02:04,829 --> 00:02:07,430
enable them

00:02:10,289 --> 00:02:14,939
so when we think about those issues we

00:02:12,870 --> 00:02:18,000
tend to group them into two different

00:02:14,939 --> 00:02:19,739
areas the issues related to the

00:02:18,000 --> 00:02:21,750
computing power and the differences in

00:02:19,739 --> 00:02:23,519
the computing power and the different

00:02:21,750 --> 00:02:25,680
the issues are related to the

00:02:23,519 --> 00:02:29,870
differences in network speed and I'm

00:02:25,680 --> 00:02:33,239
going to refer to this as CPU and IO and

00:02:29,870 --> 00:02:35,549
in the context of react when we think of

00:02:33,239 --> 00:02:37,470
the CPU work you usually think about

00:02:35,549 --> 00:02:40,079
creating the Dom nodes creating

00:02:37,470 --> 00:02:43,230
components rendering them updating them

00:02:40,079 --> 00:02:45,180
calculating the updates and so on so

00:02:43,230 --> 00:02:48,299
things that are tend to be synchronous

00:02:45,180 --> 00:02:50,099
and when we think about the i/o work in

00:02:48,299 --> 00:02:51,750
the context of react we should think

00:02:50,099 --> 00:02:53,909
about the data fashion and the code

00:02:51,750 --> 00:02:57,420
splitting so is there something that we

00:02:53,909 --> 00:03:01,980
I could do better in those areas I'm

00:02:57,420 --> 00:03:04,470
going to start with the CPU area and I

00:03:01,980 --> 00:03:12,540
have a demo as I said this is a demo

00:03:04,470 --> 00:03:14,400
oriented talk so this is my demo if

00:03:12,540 --> 00:03:16,500
maybe it doesn't look like a real I have

00:03:14,400 --> 00:03:19,019
that T built but at least it's pretty

00:03:16,500 --> 00:03:22,440
beautiful and it's graphic so it's

00:03:19,019 --> 00:03:25,470
easier to see from the audience but what

00:03:22,440 --> 00:03:27,470
I have here is I have a tax box I can

00:03:25,470 --> 00:03:31,470
type into the text box

00:03:27,470 --> 00:03:33,329
hello yes come and I have a bunch of

00:03:31,470 --> 00:03:35,819
charts and every time I type the charts

00:03:33,329 --> 00:03:43,230
update and I made it so that the longer

00:03:35,819 --> 00:03:46,739
I type the more complicated the charts

00:03:43,230 --> 00:03:49,709
become so this lets me show that no

00:03:46,739 --> 00:03:52,620
matter how fast the implementation of

00:03:49,709 --> 00:03:55,230
component is eventually if the component

00:03:52,620 --> 00:03:57,900
tree is deep enough and there are enough

00:03:55,230 --> 00:04:00,480
Dom nodes there is enough computation is

00:03:57,900 --> 00:04:02,250
going to slow down and I don't mean to

00:04:00,480 --> 00:04:05,790
nitpick us on a specific like chart

00:04:02,250 --> 00:04:07,560
example the you can imagine that instead

00:04:05,790 --> 00:04:09,690
of a chart there could be any kind of

00:04:07,560 --> 00:04:11,340
react component tree so the main point

00:04:09,690 --> 00:04:12,989
is just that it's a heavy tree with a

00:04:11,340 --> 00:04:16,549
lot of dumb notes a lot of components

00:04:12,989 --> 00:04:19,409
and it updates every time I type and so

00:04:16,549 --> 00:04:21,470
already with this level of complexity

00:04:19,409 --> 00:04:23,060
when I type I experience color

00:04:21,470 --> 00:04:25,100
and I'm the one who experiences it

00:04:23,060 --> 00:04:29,840
you're probably maybe you don't see it

00:04:25,100 --> 00:04:34,280
so I build a small clock so the clock

00:04:29,840 --> 00:04:37,340
shows the how how the screen updates so

00:04:34,280 --> 00:04:40,190
when the when the crate sorry when the

00:04:37,340 --> 00:04:43,640
clock is green it means that the last

00:04:40,190 --> 00:04:47,030
frames are were drawn pretty near to

00:04:43,640 --> 00:04:50,840
each other so it feels responsive but if

00:04:47,030 --> 00:04:52,700
you see when I type I can see yellow and

00:04:50,840 --> 00:04:55,550
even red this means that it takes a lot

00:04:52,700 --> 00:05:03,620
of time between different frames so the

00:04:55,550 --> 00:05:06,110
user experience suffers and eventually

00:05:03,620 --> 00:05:07,580
no matter usually no matter what kind of

00:05:06,110 --> 00:05:09,440
app you're building eventually you're

00:05:07,580 --> 00:05:11,150
bumping into this problem where no

00:05:09,440 --> 00:05:12,860
particular component is slow but you

00:05:11,150 --> 00:05:15,910
just have so many features and such

00:05:12,860 --> 00:05:18,590
deepness then that you have this problem

00:05:15,910 --> 00:05:20,900
so the typical solution to this is to

00:05:18,590 --> 00:05:23,570
debounce the input so instead of

00:05:20,900 --> 00:05:26,570
updating the updating the output

00:05:23,570 --> 00:05:28,820
immediately as a type I can just wait

00:05:26,570 --> 00:05:34,100
until the type and finishes and then do

00:05:28,820 --> 00:05:38,180
a single update so I can type the the

00:05:34,100 --> 00:05:40,100
input is completely responsive but then

00:05:38,180 --> 00:05:42,770
the user experience suffers in the sense

00:05:40,100 --> 00:05:45,860
that if my computer is actually powerful

00:05:42,770 --> 00:05:48,350
enough so like I will remove some

00:05:45,860 --> 00:05:52,010
characters to make the the the

00:05:48,350 --> 00:05:54,650
complexity smaller I still have to wait

00:05:52,010 --> 00:05:56,660
until to finish typing to see the

00:05:54,650 --> 00:05:59,480
results so this program doesn't really

00:05:56,660 --> 00:06:01,970
adapt to the performance of the of my

00:05:59,480 --> 00:06:06,800
computer and to the complexity of the

00:06:01,970 --> 00:06:09,919
team and this is even more pronounced if

00:06:06,800 --> 00:06:12,740
I enable the CPU throttling so CPU

00:06:09,919 --> 00:06:15,140
throttling is a way to emulate

00:06:12,740 --> 00:06:17,630
performance of a mobile device of a less

00:06:15,140 --> 00:06:23,780
powered device so I will slow down the

00:06:17,630 --> 00:06:28,490
CPU by 4 times and now you can see that

00:06:23,780 --> 00:06:32,330
even so a type which is called Iceland

00:06:28,490 --> 00:06:35,360
and even though you waited a little bit

00:06:32,330 --> 00:06:37,220
it still froze the underlying

00:06:35,360 --> 00:06:39,199
it's just that the update is big and

00:06:37,220 --> 00:06:42,139
it's synchronous so as soon as the react

00:06:39,199 --> 00:06:44,650
starts rendering it cannot stop well

00:06:42,139 --> 00:06:47,750
what if there was a way to make updates

00:06:44,650 --> 00:06:49,819
asynchronous so that reactive starts

00:06:47,750 --> 00:06:51,710
rendering something but then healed back

00:06:49,819 --> 00:06:54,409
to the browser and if there is a higher

00:06:51,710 --> 00:06:56,689
priority event like an input the browser

00:06:54,409 --> 00:06:59,300
could handle that first and not started

00:06:56,689 --> 00:07:01,430
a thread so I will disable the throttle

00:06:59,300 --> 00:07:11,360
thing for now let's see how it normally

00:07:01,430 --> 00:07:13,669
behaves in asynchronous mode so what you

00:07:11,360 --> 00:07:16,969
can see here is that when the input is

00:07:13,669 --> 00:07:18,979
short and it doesn't there is not a lot

00:07:16,969 --> 00:07:21,469
of computation in a base almost

00:07:18,979 --> 00:07:30,169
synchronously so it feels like as if it

00:07:21,469 --> 00:07:32,509
were synchronous but if I type more what

00:07:30,169 --> 00:07:34,580
happens is that instead of hanging the

00:07:32,509 --> 00:07:36,379
thread the thread says responds if you

00:07:34,580 --> 00:07:39,440
can see that it's most agreeing but

00:07:36,379 --> 00:07:42,440
instead we actress updates the chart

00:07:39,440 --> 00:07:44,870
it's left less often and the elect

00:07:42,440 --> 00:07:46,940
behind my input a little bit but in many

00:07:44,870 --> 00:07:49,400
cases this actually doesn't matter and

00:07:46,940 --> 00:07:53,900
it's a completely fine compromise from

00:07:49,400 --> 00:07:56,990
the UI perspective let's see what

00:07:53,900 --> 00:08:02,289
happens on a slow device so I enable the

00:07:56,990 --> 00:08:02,289
CPU throttling four times slower

00:08:06,210 --> 00:08:10,780
you can see that it does starter a

00:08:08,380 --> 00:08:12,610
little bit but it's mostly green and it

00:08:10,780 --> 00:08:15,430
tries to catch up to of my typing even

00:08:12,610 --> 00:08:17,020
though the device is slower compared to

00:08:15,430 --> 00:08:20,310
the synchronous version where it just

00:08:17,020 --> 00:08:20,310
stutters on every keystroke

00:08:27,540 --> 00:08:32,320
of course in real apps you often can

00:08:30,280 --> 00:08:35,140
optimize updates specifically so maybe

00:08:32,320 --> 00:08:36,970
only part of your app updates and so you

00:08:35,140 --> 00:08:42,099
can just update those components and

00:08:36,970 --> 00:08:43,539
avoid a large update but not every there

00:08:42,099 --> 00:08:46,510
are also scenarios where you just need

00:08:43,539 --> 00:08:49,870
to mount and you have a tree so I will

00:08:46,510 --> 00:08:52,990
unmount this chart completely and then

00:08:49,870 --> 00:08:55,150
mount it again with froth enabled so

00:08:52,990 --> 00:08:57,070
that's simulating a slow device and you

00:08:55,150 --> 00:08:59,590
can see that it hangs every time and

00:08:57,070 --> 00:09:00,130
while it's while it's rendering the

00:08:59,590 --> 00:09:02,500
chart

00:09:00,130 --> 00:09:04,150
nothing is interactive so I can actually

00:09:02,500 --> 00:09:06,460
click on this clock to simulate an

00:09:04,150 --> 00:09:10,660
interaction but while it's mounting it

00:09:06,460 --> 00:09:12,130
doesn't register my clicks now

00:09:10,660 --> 00:09:14,350
debouncing doesn't help us here because

00:09:12,130 --> 00:09:16,240
d bouncing is only helpful for updates

00:09:14,350 --> 00:09:18,460
but here I'm just mounting a huge

00:09:16,240 --> 00:09:20,830
component tree so let's compare this

00:09:18,460 --> 00:09:22,270
with asynchronous mode and I still have

00:09:20,830 --> 00:09:26,350
the throttle and a enabled so that's

00:09:22,270 --> 00:09:28,840
emulating the slow device so in

00:09:26,350 --> 00:09:30,670
asynchronous mode you can see that even

00:09:28,840 --> 00:09:33,580
though it Strutters a little bit it

00:09:30,670 --> 00:09:36,490
doesn't go into red and interestingly

00:09:33,580 --> 00:09:39,490
the circle stays interactive so I can

00:09:36,490 --> 00:09:41,800
actually I can start mountain I can

00:09:39,490 --> 00:09:44,530
click on this interact with this so the

00:09:41,800 --> 00:09:47,440
whole app is still working while the

00:09:44,530 --> 00:09:50,350
rendering is mounting in fact I can even

00:09:47,440 --> 00:09:56,470
start typing in the input and it's going

00:09:50,350 --> 00:09:59,370
to update to my type in so that was the

00:09:56,470 --> 00:09:59,370
CPU demo

00:09:59,540 --> 00:10:08,960
[Applause]

00:10:06,070 --> 00:10:11,060
and I want to emphasize that this is not

00:10:08,960 --> 00:10:13,340
about the charts or the inputs we've

00:10:11,060 --> 00:10:15,560
built a generic way to ensure the high

00:10:13,340 --> 00:10:17,510
priority updates don't get blocked by

00:10:15,560 --> 00:10:19,670
low prior to update and in this

00:10:17,510 --> 00:10:21,710
particular example high priority update

00:10:19,670 --> 00:10:23,450
was updating the input and a low

00:10:21,710 --> 00:10:25,460
priority update was rerender in the

00:10:23,450 --> 00:10:28,370
chart but it could have been any kind of

00:10:25,460 --> 00:10:30,980
react component for example a feed story

00:10:28,370 --> 00:10:32,960
that gets loaded and we don't want to

00:10:30,980 --> 00:10:36,110
freeze the scroll while we'll load in

00:10:32,960 --> 00:10:40,190
new items and defeat and we call this

00:10:36,110 --> 00:10:42,170
feature time slicing so it doesn't block

00:10:40,190 --> 00:10:44,900
the Frog the thread while it's rendering

00:10:42,170 --> 00:10:47,390
and if my device is fast enough it feels

00:10:44,900 --> 00:10:49,550
almost like it's synchronous but if it

00:10:47,390 --> 00:10:52,430
is slow then it feels at least it feels

00:10:49,550 --> 00:10:54,800
responsive so it adapts to the device

00:10:52,430 --> 00:10:57,100
thanks to browser exposing a request

00:10:54,800 --> 00:10:59,600
idle callback api that we use for that

00:10:57,100 --> 00:11:02,270
also notice that only the final state

00:10:59,600 --> 00:11:04,040
was displayed the update the rendered

00:11:02,270 --> 00:11:07,280
screen is always consistent we don't get

00:11:04,040 --> 00:11:09,890
artifacts of slowly rendering something

00:11:07,280 --> 00:11:12,110
that is going to cause a junky user

00:11:09,890 --> 00:11:14,540
experience we only flush when the low

00:11:12,110 --> 00:11:17,960
priority update is ready and you might

00:11:14,540 --> 00:11:20,300
think oh maybe I changed those chars to

00:11:17,960 --> 00:11:23,420
like make it's probably a lot of work to

00:11:20,300 --> 00:11:25,700
make charts this chart component worked

00:11:23,420 --> 00:11:27,650
like this but actually I just used it a

00:11:25,700 --> 00:11:30,770
ready-made component from NPM

00:11:27,650 --> 00:11:34,550
I didn't make any changes to it so we

00:11:30,770 --> 00:11:36,350
can look at the code and it's just a run

00:11:34,550 --> 00:11:38,960
a regular render method I have a chart

00:11:36,350 --> 00:11:42,020
component it renders components from NPM

00:11:38,960 --> 00:11:44,240
I pass data to it and I call set state

00:11:42,020 --> 00:11:48,790
and I use a special flag to tell react

00:11:44,240 --> 00:11:48,790
that it's is a low priority sad state

00:11:54,130 --> 00:11:58,760
and personally I've found it very

00:11:56,330 --> 00:12:01,190
helpful to use version control as a

00:11:58,760 --> 00:12:02,870
metaphor for this so when I didn't know

00:12:01,190 --> 00:12:05,660
about version control and I would just

00:12:02,870 --> 00:12:07,880
modify the files as I've worked on them

00:12:05,660 --> 00:12:11,930
hopefully I never like did anything

00:12:07,880 --> 00:12:15,440
silly that I can't undo so I would just

00:12:11,930 --> 00:12:17,060
work on a feature in my application but

00:12:15,440 --> 00:12:18,740
then if suddenly in the middle of

00:12:17,060 --> 00:12:21,200
working on that feature I need to fix a

00:12:18,740 --> 00:12:23,990
bug now I can't do it because I only

00:12:21,200 --> 00:12:25,640
have one version of my tree so I have to

00:12:23,990 --> 00:12:28,130
finish working on the future first and

00:12:25,640 --> 00:12:30,680
this is kind of how react works without

00:12:28,130 --> 00:12:32,600
time slicing the react that you know is

00:12:30,680 --> 00:12:34,940
that it can't interrupt the lunk update

00:12:32,600 --> 00:12:36,740
but when I learned version control I

00:12:34,940 --> 00:12:38,630
learned to work in a branch so I could

00:12:36,740 --> 00:12:40,640
start working on the feature working it

00:12:38,630 --> 00:12:42,440
in the branch but then if I need to do

00:12:40,640 --> 00:12:44,960
an urgent bug fix I just do it and

00:12:42,440 --> 00:12:48,140
master and then I can rebase the branch

00:12:44,960 --> 00:12:50,180
on top of that and so this is pretty

00:12:48,140 --> 00:12:51,860
much how react works with time slicing

00:12:50,180 --> 00:12:53,930
except that you don't have to rebase

00:12:51,860 --> 00:12:55,610
anything and react does that work so

00:12:53,930 --> 00:12:58,220
reactive term is how to apply a

00:12:55,610 --> 00:13:00,590
low-priority update on the top and it

00:12:58,220 --> 00:13:02,390
can continue working and then flush when

00:13:00,590 --> 00:13:08,990
everything is ready just like I can

00:13:02,390 --> 00:13:10,970
merge the branch when it's ready so

00:13:08,990 --> 00:13:14,600
we'll look at what we have could do

00:13:10,970 --> 00:13:17,080
better at the CPU side what about the

00:13:14,600 --> 00:13:21,140
i/o data fashion and code splitting I

00:13:17,080 --> 00:13:22,280
have another demo that's that's the fun

00:13:21,140 --> 00:13:25,750
part

00:13:22,280 --> 00:13:29,170
[Applause]

00:13:25,750 --> 00:13:29,170
all right

00:13:30,740 --> 00:13:41,540
I built a movie app so you can see this

00:13:38,090 --> 00:13:42,920
is the app it has a list of movies I can

00:13:41,540 --> 00:13:44,870
click on a movie

00:13:42,920 --> 00:13:47,960
it shows the detailed page were with

00:13:44,870 --> 00:13:50,720
movie details and the reviews and that's

00:13:47,960 --> 00:13:53,360
basically pretty much everything that it

00:13:50,720 --> 00:13:56,330
does so it has an app component at the

00:13:53,360 --> 00:13:58,730
top the trenders either movie list from

00:13:56,330 --> 00:14:01,340
movie list page which is this page or

00:13:58,730 --> 00:14:03,860
the movie details page which is this

00:14:01,340 --> 00:14:06,200
page so there is just to kind of pages

00:14:03,860 --> 00:14:08,210
here and the data is currently

00:14:06,200 --> 00:14:11,120
absolutely hard-coded so there's like a

00:14:08,210 --> 00:14:14,750
Jason with with the array of those

00:14:11,120 --> 00:14:17,660
things and we take the data by ID from

00:14:14,750 --> 00:14:21,010
the Jason so what if I wanted to change

00:14:17,660 --> 00:14:24,200
that to fetch data from a remote API

00:14:21,010 --> 00:14:26,090
let's go to the movie page component I'm

00:14:24,200 --> 00:14:28,400
going to remove the hard-coded movie

00:14:26,090 --> 00:14:37,870
details trace and import and instead I

00:14:28,400 --> 00:14:41,600
will import fetch movie details from API

00:14:37,870 --> 00:14:44,030
alright and I'm going to use another

00:14:41,600 --> 00:14:48,440
function that I'll import from the

00:14:44,030 --> 00:14:52,310
future again the exact API doesn't

00:14:48,440 --> 00:14:56,330
matter it may change most likely so I

00:14:52,310 --> 00:14:57,590
will call it create fetcher for now then

00:14:56,330 --> 00:15:01,580
I'll go through the movie details

00:14:57,590 --> 00:15:05,510
component so currently movie details

00:15:01,580 --> 00:15:06,980
reads from JSON object but I'm going to

00:15:05,510 --> 00:15:09,500
do something different I will create

00:15:06,980 --> 00:15:13,520
something called a fetcher so I'll call

00:15:09,500 --> 00:15:16,100
it movie details fetcher equals create

00:15:13,520 --> 00:15:17,990
fetcher and I will pass my promised

00:15:16,100 --> 00:15:21,050
return the function fetch movie details

00:15:17,990 --> 00:15:25,310
through it now the next step is going to

00:15:21,050 --> 00:15:28,040
be a little bit controversial so if you

00:15:25,310 --> 00:15:29,780
know react you probably know that you're

00:15:28,040 --> 00:15:33,020
not supposed to do data fetch and in

00:15:29,780 --> 00:15:35,960
renderer so in this talk I'm going to

00:15:33,020 --> 00:15:38,870
ban this rule a little bit and I just

00:15:35,960 --> 00:15:42,740
want you to follow along with it and see

00:15:38,870 --> 00:15:44,480
where it leads us so when react came out

00:15:42,740 --> 00:15:47,809
it was pretty controversial

00:15:44,480 --> 00:15:55,249
I think we can make more controversial

00:15:47,809 --> 00:15:58,999
things all right so I have this fetcher

00:15:55,249 --> 00:16:01,129
object and it works as a cache it has a

00:15:58,999 --> 00:16:03,829
single method called read so I'm going

00:16:01,129 --> 00:16:08,720
to call movie details fetcher that read

00:16:03,829 --> 00:16:10,609
and pass the ID so what's going to

00:16:08,720 --> 00:16:12,769
happen is that when a reactor enters the

00:16:10,609 --> 00:16:15,410
movie details component it will try to

00:16:12,769 --> 00:16:17,149
get this data from the cache but the TV

00:16:15,410 --> 00:16:17,569
is not there because it's not fetched

00:16:17,149 --> 00:16:19,609
yet

00:16:17,569 --> 00:16:22,519
so reactor is going to fetch the data

00:16:19,609 --> 00:16:25,069
and Rehab is going to prevent the entire

00:16:22,519 --> 00:16:27,350
update from occurring until the data is

00:16:25,069 --> 00:16:29,329
ready there is just one more thing I

00:16:27,350 --> 00:16:32,389
need to do I need to tell react that is

00:16:29,329 --> 00:16:34,730
actually ok for the transition from this

00:16:32,389 --> 00:16:38,059
page to the details page to be

00:16:34,730 --> 00:16:40,639
asynchronous so again the exact API is

00:16:38,059 --> 00:16:42,259
probably going to be different but here

00:16:40,639 --> 00:16:46,459
in the movie click where it says state

00:16:42,259 --> 00:16:49,549
show detail true I will call something

00:16:46,459 --> 00:16:56,419
called differs at state with the same

00:16:49,549 --> 00:17:03,049
state so let's see if that works I click

00:16:56,419 --> 00:17:04,610
on an item it waits and it loads and if

00:17:03,049 --> 00:17:06,709
you don't believe me I actually built a

00:17:04,610 --> 00:17:09,110
small debugger here so it shows the

00:17:06,709 --> 00:17:11,329
pending requests and how requests happen

00:17:09,110 --> 00:17:13,189
so if I remove everything from the cache

00:17:11,329 --> 00:17:15,169
and I click on the movie there is a

00:17:13,189 --> 00:17:18,350
request here and when it comes back

00:17:15,169 --> 00:17:20,059
react renders the detail view now you

00:17:18,350 --> 00:17:22,939
might think oh there must be a race

00:17:20,059 --> 00:17:24,620
conditions and maybe you think that the

00:17:22,939 --> 00:17:27,139
screen is not interactive well as

00:17:24,620 --> 00:17:29,570
fashion no it's it's interactive I can

00:17:27,139 --> 00:17:32,029
click here I can click here it's going

00:17:29,570 --> 00:17:35,450
to load the right one now it's in cache

00:17:32,029 --> 00:17:39,429
I can go back I can click on this movie

00:17:35,450 --> 00:17:39,429
it's in cache so it renders instantly

00:17:40,690 --> 00:17:44,929
however what if the latency is high what

00:17:43,279 --> 00:17:47,419
if their network request takes a lot of

00:17:44,929 --> 00:17:49,159
time like in this example three seconds

00:17:47,419 --> 00:17:52,940
but it could have been like 15 seconds

00:17:49,159 --> 00:17:54,440
so now if I click on a movie it seems

00:17:52,940 --> 00:17:56,419
like nothing is happening if you don't

00:17:54,440 --> 00:17:57,960
have the debugger open so that's not a

00:17:56,419 --> 00:18:02,410
very good user

00:17:57,960 --> 00:18:06,490
we can improve it so I'm going to import

00:18:02,410 --> 00:18:09,540
something else from the future it's very

00:18:06,490 --> 00:18:12,070
convenient to have access to the feature

00:18:09,540 --> 00:18:17,880
I'm going to import the component called

00:18:12,070 --> 00:18:21,220
a placeholder and I'm going to say that

00:18:17,880 --> 00:18:24,990
if anything inside the movie page is not

00:18:21,220 --> 00:18:24,990
ready we're gonna render a placeholder

00:18:27,480 --> 00:18:33,880
if the movie page takes more than a

00:18:31,720 --> 00:18:37,330
second and a half to load so there's a

00:18:33,880 --> 00:18:40,110
delay milliseconds argument then I want

00:18:37,330 --> 00:18:40,110
to show a spinner

00:18:46,730 --> 00:18:51,020
so what we are is going to do is going

00:18:48,890 --> 00:18:53,810
to try to render this component but if

00:18:51,020 --> 00:18:56,930
any of its child is going to render as

00:18:53,810 --> 00:18:58,700
much of the tree as it can but if any of

00:18:56,930 --> 00:19:00,560
the children are waiting for a single

00:18:58,700 --> 00:19:02,840
dependencies is going to wait for those

00:19:00,560 --> 00:19:04,790
children and if it takes more than this

00:19:02,840 --> 00:19:07,400
amount of time is going to display the

00:19:04,790 --> 00:19:09,950
for the placeholder until those

00:19:07,400 --> 00:19:10,670
dependencies are resolved so let's see

00:19:09,950 --> 00:19:17,540
how this works

00:19:10,670 --> 00:19:20,000
I click on a movie in this case my

00:19:17,540 --> 00:19:23,330
default latency is 1 second so it

00:19:20,000 --> 00:19:25,610
actually feels almost instantaneous so I

00:19:23,330 --> 00:19:29,480
don't see the loading indicator but if

00:19:25,610 --> 00:19:34,220
the latency is high 3 seconds and I

00:19:29,480 --> 00:19:36,200
click on a movie then it shows the the

00:19:34,220 --> 00:19:39,980
placeholder and then it shows the real

00:19:36,200 --> 00:19:42,020
thing when it's ready here is another

00:19:39,980 --> 00:19:43,670
interesting thing even while it's

00:19:42,020 --> 00:19:46,160
showing the placeholder the app is fully

00:19:43,670 --> 00:19:49,930
interactive it is never frozen so I can

00:19:46,160 --> 00:19:54,850
pause all new requests start a fashion

00:19:49,930 --> 00:19:58,010
imitate the fetch it takes a long time

00:19:54,850 --> 00:20:00,410
but say I want to go back I can actually

00:19:58,010 --> 00:20:08,510
go back so the whole the screen is

00:20:00,410 --> 00:20:10,280
always interactive now which has fetched

00:20:08,510 --> 00:20:14,450
the details but what if we want to fetch

00:20:10,280 --> 00:20:16,610
the reviews as well to do that I'm going

00:20:14,450 --> 00:20:21,320
to back to movie page component and I'm

00:20:16,610 --> 00:20:23,420
opening the let me import remove the

00:20:21,320 --> 00:20:30,470
hard-coded chase on import and instead

00:20:23,420 --> 00:20:32,030
import fetch movie reviews and I'm

00:20:30,470 --> 00:20:34,970
scrolling down to my movie reviews

00:20:32,030 --> 00:20:40,570
component that currently reads it from

00:20:34,970 --> 00:20:44,990
Jason and I create movie reviews fetcher

00:20:40,570 --> 00:20:49,250
great fetcher with fetch movie reviews

00:20:44,990 --> 00:20:54,860
and again I just call read I said sorry

00:20:49,250 --> 00:20:57,340
movie reviews fetcher dot read for props

00:20:54,860 --> 00:20:57,340
idea

00:20:57,390 --> 00:21:01,810
so move your reviews and movie details

00:20:59,830 --> 00:21:03,820
are siblings but the reality is going to

00:21:01,810 --> 00:21:06,850
wait for both of them before continuing

00:21:03,820 --> 00:21:10,510
so let's see if the latency is 1 second

00:21:06,850 --> 00:21:12,700
is waiting for both but wolf resolved in

00:21:10,510 --> 00:21:14,500
time so it doesn't display any

00:21:12,700 --> 00:21:18,430
intermediate loading states and doesn't

00:21:14,500 --> 00:21:21,360
the page doesn't jump with spinners but

00:21:18,430 --> 00:21:23,020
let's say that I pause near request a

00:21:21,360 --> 00:21:24,940
start fetching

00:21:23,020 --> 00:21:27,250
I'll let the reviews come through first

00:21:24,940 --> 00:21:29,350
while reactor can't render reviews alone

00:21:27,250 --> 00:21:31,120
it's important that the screen is always

00:21:29,350 --> 00:21:32,920
consistent with what's in the render

00:21:31,120 --> 00:21:35,290
methods so react is still showing the

00:21:32,920 --> 00:21:37,330
placeholder but when the details of the

00:21:35,290 --> 00:21:41,230
movie are loaded this is when it shows

00:21:37,330 --> 00:21:42,610
everything together now this may be fine

00:21:41,230 --> 00:21:44,170
but there is a downside what if I

00:21:42,610 --> 00:21:46,330
actually don't care about the reviews

00:21:44,170 --> 00:21:48,190
that much and I don't want to delay

00:21:46,330 --> 00:21:49,290
showing the details if the details told

00:21:48,190 --> 00:21:52,150
it first

00:21:49,290 --> 00:21:56,800
well to do that I use the placeholder

00:21:52,150 --> 00:21:58,930
component from the future so I can wrap

00:21:56,800 --> 00:22:02,740
the movie reviews component in a

00:21:58,930 --> 00:22:05,230
placeholder and I can say that if the

00:22:02,740 --> 00:22:07,360
movie review specifically took longer

00:22:05,230 --> 00:22:09,790
than a second to load since the

00:22:07,360 --> 00:22:11,800
interaction we actually don't care about

00:22:09,790 --> 00:22:20,380
them that much and we're going to show

00:22:11,800 --> 00:22:24,700
another spinner with a medium size let's

00:22:20,380 --> 00:22:28,270
see what happens so I pause all new

00:22:24,700 --> 00:22:32,620
requests start loading a movie and allow

00:22:28,270 --> 00:22:34,570
the details first it shows the details

00:22:32,620 --> 00:22:37,060
but the reviews are still loading and

00:22:34,570 --> 00:22:39,190
when the read is already it shows the

00:22:37,060 --> 00:22:42,910
reviews and again there are no risk

00:22:39,190 --> 00:22:45,400
conditions I can go back I can clear

00:22:42,910 --> 00:22:48,900
this I can start fetching this start

00:22:45,400 --> 00:22:52,090
fetching the reviews go back well here

00:22:48,900 --> 00:22:55,360
start afresh in the details it knows

00:22:52,090 --> 00:22:56,770
exactly what's the right thing to do and

00:22:55,360 --> 00:22:59,740
it respects the props that I passed

00:22:56,770 --> 00:23:02,230
through it but we can still make the

00:22:59,740 --> 00:23:05,380
user experience better for example when

00:23:02,230 --> 00:23:06,040
I just click if the delay is less than a

00:23:05,380 --> 00:23:08,530
second

00:23:06,040 --> 00:23:11,020
it's nice that the screen pops in when

00:23:08,530 --> 00:23:12,370
is ready but before that happens I don't

00:23:11,020 --> 00:23:13,390
have any visual indication that

00:23:12,370 --> 00:23:19,570
something's happening

00:23:13,390 --> 00:23:25,870
so can we fix that yes I will go into

00:23:19,570 --> 00:23:27,690
the app component and I will import

00:23:25,870 --> 00:23:31,570
something else from the future

00:23:27,690 --> 00:23:34,300
it's called loading so this is not the

00:23:31,570 --> 00:23:37,210
final API this actually this API is most

00:23:34,300 --> 00:23:40,780
likely to change but for now loading is

00:23:37,210 --> 00:23:44,440
just a component that gives me a render

00:23:40,780 --> 00:23:47,050
prop cold is loading that lets me decide

00:23:44,440 --> 00:23:48,370
what to show for now I'll copy paste

00:23:47,050 --> 00:23:49,930
what I already have here

00:23:48,370 --> 00:23:55,930
so either the detail view or the

00:23:49,930 --> 00:23:58,300
ListView but I already prepared my movie

00:23:55,930 --> 00:24:00,580
list page in a way that I can pass a

00:23:58,300 --> 00:24:02,560
load and ID through it and it will show

00:24:00,580 --> 00:24:04,960
an inline spinner so for example if I

00:24:02,560 --> 00:24:07,360
pass loading ID equals 1 it shows a

00:24:04,960 --> 00:24:08,140
spinner like this if a passcode and D

00:24:07,360 --> 00:24:09,940
equals 2

00:24:08,140 --> 00:24:11,950
it shows the spinner on the second movie

00:24:09,940 --> 00:24:14,170
so what I'm going to do is I'm going to

00:24:11,950 --> 00:24:18,040
make loading ID and argument to render

00:24:14,170 --> 00:24:21,990
list and I'm going to call render

00:24:18,040 --> 00:24:24,340
released so if we are currently loading

00:24:21,990 --> 00:24:26,550
which is what we wanted to ask react

00:24:24,340 --> 00:24:30,940
then I just pass the current idea

00:24:26,550 --> 00:24:34,350
otherwise I pass null and I can even

00:24:30,940 --> 00:24:39,100
remove the the main placeholder now

00:24:34,350 --> 00:24:41,800
let's see what happens so now when I

00:24:39,100 --> 00:24:43,990
click it shows an inline spinner and

00:24:41,800 --> 00:24:46,000
again no race conditions I can click

00:24:43,990 --> 00:24:47,950
here then click here it shows the right

00:24:46,000 --> 00:24:51,330
thing the screen is always interactive

00:24:47,950 --> 00:24:51,330
and now this is cached

00:24:58,060 --> 00:25:03,430
so this is all cool but we can still

00:25:01,520 --> 00:25:07,280
improve the user experience even further

00:25:03,430 --> 00:25:09,560
for example currently we show the the

00:25:07,280 --> 00:25:11,300
movie page below the code for the movie

00:25:09,560 --> 00:25:14,060
page right away but we don't actually

00:25:11,300 --> 00:25:16,220
need it until we click on the movie so

00:25:14,060 --> 00:25:18,200
I'm going to replace this with a

00:25:16,220 --> 00:25:20,000
component that does code splitting so

00:25:18,200 --> 00:25:25,400
I'll call it movie page loader and I

00:25:20,000 --> 00:25:30,470
define it above it takes the props and

00:25:25,400 --> 00:25:32,240
passes them to movie page so if we are

00:25:30,470 --> 00:25:35,390
code splitting do we need to show a

00:25:32,240 --> 00:25:37,130
spinner while the code is loading or

00:25:35,390 --> 00:25:40,010
does a question even make sense if we

00:25:37,130 --> 00:25:44,990
have these new primitives that's him I'm

00:25:40,010 --> 00:25:52,550
going to import create fetcher again and

00:25:44,990 --> 00:25:54,170
I will create a movie page fetcher to

00:25:52,550 --> 00:25:57,350
fetch the movie page I will use the

00:25:54,170 --> 00:25:59,690
dynamic import syntax so I will return a

00:25:57,350 --> 00:26:02,060
promise that returns import to movie

00:25:59,690 --> 00:26:03,710
page and I remove the static webpack

00:26:02,060 --> 00:26:07,820
import so it's not going to be in the

00:26:03,710 --> 00:26:11,150
initial bundle finally to get the movie

00:26:07,820 --> 00:26:14,500
page component I call the read function

00:26:11,150 --> 00:26:16,880
on the fetcher and read the default

00:26:14,500 --> 00:26:20,420
default property from the module because

00:26:16,880 --> 00:26:23,210
it's the default export so I'll see if

00:26:20,420 --> 00:26:26,030
that works I click here there is no

00:26:23,210 --> 00:26:27,980
global loading indicator if the request

00:26:26,030 --> 00:26:31,990
takes fast enough

00:26:27,980 --> 00:26:35,510
yeah just edit code split into my app

00:26:31,990 --> 00:26:37,340
but if the request is slow oh I guess I

00:26:35,510 --> 00:26:41,270
removed the fallback so yeah that's not

00:26:37,340 --> 00:26:44,240
gonna work but we can check that this

00:26:41,270 --> 00:26:47,360
actually did something so if i refresh I

00:26:44,240 --> 00:26:49,400
clear the network top and I press you

00:26:47,360 --> 00:26:50,960
can see that there is a chunk here so

00:26:49,400 --> 00:26:54,470
you can see that this component truly

00:26:50,960 --> 00:26:56,570
was loaded with collision there is still

00:26:54,470 --> 00:26:59,500
one improvement to the user interface

00:26:56,570 --> 00:26:59,500
that I can make her

00:27:01,919 --> 00:27:09,039
you might have noticed that this movie

00:27:05,500 --> 00:27:10,779
has a taller posture than other movies

00:27:09,039 --> 00:27:13,299
let's say that we don't know their sizes

00:27:10,779 --> 00:27:15,460
immediately so when I click on it for

00:27:13,299 --> 00:27:19,029
the first time the page jumps a little

00:27:15,460 --> 00:27:21,820
bit when they when they movie loads so

00:27:19,029 --> 00:27:25,720
can we avoid showing the page until the

00:27:21,820 --> 00:27:29,049
image is ready well we can go to the

00:27:25,720 --> 00:27:31,200
movie page component and find the movie

00:27:29,049 --> 00:27:33,580
poster component that renders an image

00:27:31,200 --> 00:27:37,600
and I will create my custom image

00:27:33,580 --> 00:27:43,539
component with capital I the choice

00:27:37,600 --> 00:27:48,450
renders the browser image except with

00:27:43,539 --> 00:27:52,840
the twist I create an image feature

00:27:48,450 --> 00:27:55,140
which is a fetcher now I need to return

00:27:52,840 --> 00:27:59,320
a promise so return a function that

00:27:55,140 --> 00:28:03,490
returns a promise that resolves when I

00:27:59,320 --> 00:28:07,179
create a browser image object to preload

00:28:03,490 --> 00:28:11,950
the image and what that image loads I

00:28:07,179 --> 00:28:19,270
resolve my promise and I started the

00:28:11,950 --> 00:28:22,960
loading process and now I say that the

00:28:19,270 --> 00:28:30,909
source is image fetcher that read prop

00:28:22,960 --> 00:28:33,220
source I'm bad at this right yeah this

00:28:30,909 --> 00:28:34,840
should be an argument because I pass it

00:28:33,220 --> 00:28:40,779
to the wreath so it's going to come out

00:28:34,840 --> 00:28:44,140
here now if I click on it that didn't

00:28:40,779 --> 00:28:44,980
work okay it's a live demo some things

00:28:44,140 --> 00:28:46,840
don't

00:28:44,980 --> 00:28:49,750
oh right I forgot to use my image

00:28:46,840 --> 00:28:52,929
component that's why you should let look

00:28:49,750 --> 00:28:57,039
at the lint warnings so let's use the

00:28:52,929 --> 00:28:59,020
image component now I'll click on it and

00:28:57,039 --> 00:29:01,289
jumps on the page when the image is

00:28:59,020 --> 00:29:01,289
ready

00:29:03,910 --> 00:29:16,469
and this was the IO demo

00:29:07,550 --> 00:29:16,469
[Applause]

00:29:16,480 --> 00:29:21,200
we've built a generic way for components

00:29:19,130 --> 00:29:23,150
to suspend rendering when they load

00:29:21,200 --> 00:29:26,090
asynchronous data or dependencies or

00:29:23,150 --> 00:29:30,710
really anything asynchronous and we call

00:29:26,090 --> 00:29:32,809
this feature suspense you can pause any

00:29:30,710 --> 00:29:35,270
state update until the data is ready as

00:29:32,809 --> 00:29:37,640
specified by the components and you can

00:29:35,270 --> 00:29:39,200
add agent load into any component

00:29:37,640 --> 00:29:41,660
anywhere deep in the tree without

00:29:39,200 --> 00:29:44,590
clumping all the props and state and

00:29:41,660 --> 00:29:49,100
hoisting it up and using readouts or

00:29:44,590 --> 00:29:51,559
anything you usually do for that and on

00:29:49,100 --> 00:29:53,720
a fast Network the upside is that you

00:29:51,559 --> 00:29:56,809
can make it appear very fluent and

00:29:53,720 --> 00:29:59,150
almost instantaneous without the cheran

00:29:56,809 --> 00:30:01,760
cascade of spinners that appear and

00:29:59,150 --> 00:30:04,429
disappear all the time but on a slow

00:30:01,760 --> 00:30:06,440
Network you you can be intentional about

00:30:04,429 --> 00:30:09,110
design in the loading States and not

00:30:06,440 --> 00:30:11,330
just let them be artifacts of how the

00:30:09,110 --> 00:30:12,890
code is written in study explicitly

00:30:11,330 --> 00:30:14,840
design which load and States you want

00:30:12,890 --> 00:30:17,960
the user to see and how brenner

00:30:14,840 --> 00:30:20,360
of course they must be and there is both

00:30:17,960 --> 00:30:22,490
a high level and a low level API so the

00:30:20,360 --> 00:30:24,440
API that I showed you is a high level

00:30:22,490 --> 00:30:26,330
reference implementation that we're

00:30:24,440 --> 00:30:28,340
going to provide but there is a lower

00:30:26,330 --> 00:30:32,150
level API that libraries can use to

00:30:28,340 --> 00:30:33,650
integrate with this and again I found it

00:30:32,150 --> 00:30:37,280
helpful to use version control as a

00:30:33,650 --> 00:30:39,080
metaphor so when I use version version

00:30:37,280 --> 00:30:42,380
control and I start working on something

00:30:39,080 --> 00:30:44,179
and do this on a branch but sometimes

00:30:42,380 --> 00:30:45,920
maybe I can't continue working on the

00:30:44,179 --> 00:30:49,190
feature because I'm waiting for the

00:30:45,920 --> 00:30:51,950
designer to give me the final design so

00:30:49,190 --> 00:30:54,530
I put that work aside and I can do

00:30:51,950 --> 00:30:57,710
something else and this is how react

00:30:54,530 --> 00:30:59,480
suspends works is that react knows that

00:30:57,710 --> 00:31:01,970
these some of the children need some

00:30:59,480 --> 00:31:05,570
async dependencies so it just suspends

00:31:01,970 --> 00:31:07,610
that tree but it can still handle a

00:31:05,570 --> 00:31:10,270
higher priority event so this is why I

00:31:07,610 --> 00:31:14,240
was able to click on everything and

00:31:10,270 --> 00:31:16,850
continue navigating through the app and

00:31:14,240 --> 00:31:18,590
later just like I can rebase my old

00:31:16,850 --> 00:31:22,400
branch when I finally have the designs

00:31:18,590 --> 00:31:23,360
on top of the master react rebuses they

00:31:22,400 --> 00:31:25,610
suspended update

00:31:23,360 --> 00:31:27,620
and can continue when the async

00:31:25,610 --> 00:31:32,510
dependencies are satisfied and then

00:31:27,620 --> 00:31:34,940
committed to the Dom so coming back to

00:31:32,510 --> 00:31:36,950
my question how does how can a reaction

00:31:34,940 --> 00:31:38,450
able better user experiences for people

00:31:36,950 --> 00:31:42,530
with different devices and different

00:31:38,450 --> 00:31:47,390
networks we think that time slicing

00:31:42,530 --> 00:31:50,690
helps the CPU case and the the saucepans

00:31:47,390 --> 00:31:53,270
feature helps the i/o case is that we

00:31:50,690 --> 00:31:54,920
can be more intentional about designing

00:31:53,270 --> 00:31:57,680
for slower devices and how they should

00:31:54,920 --> 00:32:00,830
behave but we can also provide better

00:31:57,680 --> 00:32:03,080
experiences of past devices and you can

00:32:00,830 --> 00:32:06,740
see that there are a lot of similarities

00:32:03,080 --> 00:32:08,380
between these two these two axes so this

00:32:06,740 --> 00:32:11,210
is why we don't really think these are

00:32:08,380 --> 00:32:14,120
separate performance problems we think

00:32:11,210 --> 00:32:15,500
that both the problem the main problem

00:32:14,120 --> 00:32:18,080
here is not the performance but

00:32:15,500 --> 00:32:20,840
scheduling and the solution has to think

00:32:18,080 --> 00:32:23,450
about the scheduling and so we call this

00:32:20,840 --> 00:32:26,720
see the features async rendering in

00:32:23,450 --> 00:32:29,330
react and our goals is to let app

00:32:26,720 --> 00:32:31,580
developers adapt to users constraints

00:32:29,330 --> 00:32:33,620
such as device and network to make fast

00:32:31,580 --> 00:32:35,930
interactions feel instant without the

00:32:33,620 --> 00:32:39,230
janky things popping out of the screen

00:32:35,930 --> 00:32:41,410
and make slower interactions feel

00:32:39,230 --> 00:32:46,160
responsive and we designed intentionally

00:32:41,410 --> 00:32:47,930
and importantly this is still the react

00:32:46,160 --> 00:32:51,140
you know this is still the component

00:32:47,930 --> 00:32:53,270
declarative component paradigm now if he

00:32:51,140 --> 00:32:57,260
is reactive you probably that's what you

00:32:53,270 --> 00:33:00,170
like about it so it's not ready yet but

00:32:57,260 --> 00:33:03,680
these are not fake product like you saw

00:33:00,170 --> 00:33:06,310
me really using it so it's a real thing

00:33:03,680 --> 00:33:08,360
there is a pull request for this and

00:33:06,310 --> 00:33:10,880
there is more work to be done

00:33:08,360 --> 00:33:13,400
to enable this and to ship this as a

00:33:10,880 --> 00:33:16,810
stable feature and we hope to deliver it

00:33:13,400 --> 00:33:16,810
this year thank you

00:33:23,049 --> 00:33:25,110

YouTube URL: https://www.youtube.com/watch?v=nLF0n9SACd4


