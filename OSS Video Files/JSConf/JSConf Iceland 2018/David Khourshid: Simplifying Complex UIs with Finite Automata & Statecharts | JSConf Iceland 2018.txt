Title: David Khourshid: Simplifying Complex UIs with Finite Automata & Statecharts | JSConf Iceland 2018
Publication date: 2018-04-06
Playlist: JSConf Iceland 2018
Description: 
	https://2018.jsconf.is/speakers/david-khourshid/

As the number of possible states in your app grows, developing UIs can become exponentially more complex. With the help of finite automata, or finite state machines (FSMs), you will be able to manage your app's states in a simple, robust way, and even visualize them! In this session, we will discover how FSMs and statecharts can take your UIs to the next level, with innovative techniques for implementing, testing, and visualizing your app's finite states in a robust, automated way, with plenty of use cases, demos, and resources.
Captions: 
	00:00:01,040 --> 00:00:04,040
Thank you.

00:00:04,040 --> 00:00:05,210
Is this on?

00:00:05,210 --> 00:00:07,359
Can you all hear me?

00:00:07,359 --> 00:00:10,440
All right.

00:00:10,440 --> 00:00:11,440
There we go!

00:00:11,440 --> 00:00:12,640
All right.

00:00:12,640 --> 00:00:13,990
So, yeah.

00:00:13,990 --> 00:00:21,200
My talk is simplifying, though I would have liked to see a talk titled simplifying complex

00:00:21,200 --> 00:00:24,930
talk titles with fewer words.

00:00:24,930 --> 00:00:28,020
I know what you might be thinking right now.

00:00:28,020 --> 00:00:31,869
The react API, a little scary?

00:00:31,869 --> 00:00:40,180
There's a good book in order to understand how to best work with it, and it's doing whatever

00:00:40,180 --> 00:00:46,320
Danny says to do.

00:00:46,320 --> 00:00:52,170
The second half of this talk is exactly what I'm talking about today, except in the more

00:00:52,170 --> 00:00:55,940
general sense.

00:00:55,940 --> 00:00:58,150
I want to talk about it, though.

00:00:58,150 --> 00:01:04,330
Not in the context of React or you or angular or any of the last frameworks that came out

00:01:04,330 --> 00:01:05,330
last week.

00:01:05,330 --> 00:01:09,860
But I want to talk about it in a frameworkless context.

00:01:09,860 --> 00:01:14,920
This is an idea that doesn't just apply to any framework or no framework in general,

00:01:14,920 --> 00:01:17,720
but really any programming language as well.

00:01:17,720 --> 00:01:21,960
We can see how it could help us simplify our UIs.

00:01:21,960 --> 00:01:27,159
So I'm a pianist, and I have been playing for about 20 years.

00:01:27,159 --> 00:01:34,890
This is the approach that I take to software development.

00:01:34,890 --> 00:01:40,920
I made the analogy that if software is music, then developers are composers.

00:01:40,920 --> 00:01:48,210
We're taking that music, and we're composing it in a way that is applicable to any language

00:01:48,210 --> 00:01:49,440
or any platform.

00:01:49,440 --> 00:01:52,549
And we do so in a variety of ways.

00:01:52,549 --> 00:01:57,049
However, music's interesting, because with music, you have music notation, which you

00:01:57,049 --> 00:01:58,049
just saw there.

00:01:58,049 --> 00:02:00,370
Let's go back and see it.

00:02:00,370 --> 00:02:02,640
So this stuff right here.

00:02:02,640 --> 00:02:06,140
This music notation is hundreds and hundreds of years old.

00:02:06,140 --> 00:02:13,189
However, the exact same notation is used today to represent music from classical, romantic,

00:02:13,189 --> 00:02:15,590
whatever the hellï¿½Bjork is.

00:02:15,590 --> 00:02:25,680
You can give a musician who understands how to read sheet music, and they will be able

00:02:25,680 --> 00:02:27,060
to play it.

00:02:27,060 --> 00:02:32,090
And this works for all instruments, and you know, all musicians of all levels.

00:02:32,090 --> 00:02:41,980
So I was wondering, what is the music notation of user interfaces?

00:02:41,980 --> 00:02:49,389
What do all user interfaces have in common, and how can we represent that declaratively?

00:02:49,389 --> 00:02:53,969
So when we're working with software, we usually deal with APIs.

00:02:53,969 --> 00:02:58,730
Good APIs have three main qualities.

00:02:58,730 --> 00:03:00,159
They're well documented.

00:03:00,159 --> 00:03:04,159
You can read the documentation and understand exactly what's happening with the API.

00:03:04,159 --> 00:03:06,110
They are very predictable.

00:03:06,110 --> 00:03:11,189
The API is going to work the exact same way every time.

00:03:11,189 --> 00:03:12,870
And they're also testable.

00:03:12,870 --> 00:03:14,909
You can test against an API.

00:03:14,909 --> 00:03:20,999
They provide mocks for you or have a test database or something like that.

00:03:20,999 --> 00:03:24,819
So user interfaces, though?

00:03:24,819 --> 00:03:27,239
User interfaces are really complex.

00:03:27,239 --> 00:03:33,309
I mean, does anyone find developing user interfaces easy?

00:03:33,309 --> 00:03:37,120
Those of you watching online, no one raised their hand, which is good, because I would

00:03:37,120 --> 00:03:39,989
have called them out if they did.

00:03:39,989 --> 00:03:43,989
We have to deal with something called a human API.

00:03:43,989 --> 00:03:47,260
That's all of you, all of our clients, everyone we work with.

00:03:47,260 --> 00:03:52,719
Human API is undocumented or unpredictable, and we're untestable.

00:03:52,719 --> 00:03:55,720
And we're also extremely buggy.

00:03:55,720 --> 00:04:02,290
If you don't believe me, turn on an American news network, and you'll see proof of that.

00:04:02,290 --> 00:04:03,290
So I work for Microsoft.

00:04:03,290 --> 00:04:09,590
By the way, I'm not relating Microsoft to any of this terrible API stuff, I promise.

00:04:09,590 --> 00:04:16,940
And at Microsoft, we have more than 50,000 software engineers throughout the world, and

00:04:16,940 --> 00:04:19,900
at least 7 designers, I'm sure.

00:04:19,900 --> 00:04:24,720
[ Laughter ] And we also serve one and a half billion customers.

00:04:24,720 --> 00:04:26,300
I think this is just for windows.

00:04:26,300 --> 00:04:29,620
It might be more than that.

00:04:29,620 --> 00:04:35,560
When we're developing user interfaces for 1.5 billion people, we have to imagine all

00:04:35,560 --> 00:04:38,590
the different ways a user could use the user interface.

00:04:38,590 --> 00:04:42,210
And you know, this is different cultures and languages.

00:04:42,210 --> 00:04:45,440
You wonder why diversity is so important in tech?

00:04:45,440 --> 00:04:49,290
We have to reach the 1.5 billion people.

00:04:49,290 --> 00:04:52,450
So we don't develop software for just one person.

00:04:52,450 --> 00:04:58,980
However, when we're developing software with just the happy path in mind, that's essentially

00:04:58,980 --> 00:05:00,440
what we're doing.

00:05:00,440 --> 00:05:06,000
We're assuming that there's this ideal user who's using our applications in the exact

00:05:06,000 --> 00:05:07,700
way that we want them to.

00:05:07,700 --> 00:05:10,100
But this never happens.

00:05:10,100 --> 00:05:14,160
We're going to take a look at the code example, but I don't want you to read too deeply into

00:05:14,160 --> 00:05:15,160
the code.

00:05:15,160 --> 00:05:19,060
I just want to see if you relate to this.

00:05:19,060 --> 00:05:26,730
We're going to create a sample F where we query the flickr API and then the results.

00:05:26,730 --> 00:05:32,310
Similar to what Dan was doing with movies in his last talk.

00:05:32,310 --> 00:05:34,460
So it's pretty simple right?

00:05:34,460 --> 00:05:35,590
We do a fetch.

00:05:35,590 --> 00:05:40,500
Then when we get the data, we show it.

00:05:40,500 --> 00:05:41,650
Are there any bugs here?

00:05:41,650 --> 00:05:43,740
Are we done?

00:05:43,740 --> 00:05:44,740
Well...

00:05:44,740 --> 00:05:46,590
Let's say the data takes a long time to load.

00:05:46,590 --> 00:05:47,590
Okay.

00:05:47,590 --> 00:05:51,000
So now we have to set this loading flag, loading is true.

00:05:51,000 --> 00:05:55,750
And once we finish loading data, then we have to set loading to false.

00:05:55,750 --> 00:05:57,630
Are we done?

00:05:57,630 --> 00:05:58,630
No.

00:05:58,630 --> 00:06:00,650
What if we have an error.

00:06:00,650 --> 00:06:05,750
Well, we have to hide the loading screen, show the error, right?

00:06:05,750 --> 00:06:08,010
But, are we home free yet?

00:06:08,010 --> 00:06:09,010
No.

00:06:09,010 --> 00:06:16,280
Because, we also have to make sure that we clear the error once we try to search again.

00:06:16,280 --> 00:06:19,300
As you can see, the complexity is getting bigger and bigger.

00:06:19,300 --> 00:06:22,600
Now my onserve to vent handler is getting extremely huge.

00:06:22,600 --> 00:06:26,430
I'm sure many of you can relate to this code.

00:06:26,430 --> 00:06:30,640
Many of you will say yeah, some of my code looks like that.

00:06:30,640 --> 00:06:31,800
Sure.

00:06:31,800 --> 00:06:38,440
What if your boss comes to you and says we want the use tore be able to cancel the search,

00:06:38,440 --> 00:06:40,950
because, you know, sometimes it takes too long.

00:06:40,950 --> 00:06:43,670
Sometimes they want to search for something else.

00:06:43,670 --> 00:06:46,780
That logic gets crazier.

00:06:46,780 --> 00:06:48,220
I don't know if you can read that.

00:06:48,220 --> 00:06:50,120
I'll zoom in for you.

00:06:50,120 --> 00:06:57,580
But there's a lot of complexity in just one event handler.

00:06:57,580 --> 00:07:02,160
You might know this as spaghetti code, where our code quickly gets unmanageable.

00:07:02,160 --> 00:07:07,200
Some of you might see your engineers and think I don't do spaghetti code.

00:07:07,200 --> 00:07:13,150
All of my code is modular and layered and separation of concerns.

00:07:13,150 --> 00:07:17,420
You might not write spaghetti code, but you might write lasagne code, which is spaghetti

00:07:17,420 --> 00:07:20,460
code in layers.

00:07:20,460 --> 00:07:22,630
This is called the bottomup approach.

00:07:22,630 --> 00:07:30,889
That approach is whenever you have an event like onclick or on change, you do all of the

00:07:30,889 --> 00:07:32,260
logic in that event.

00:07:32,260 --> 00:07:38,180
And that can refer to so many different actions, and some of those actions might change the

00:07:38,180 --> 00:07:39,180
states.

00:07:39,180 --> 00:07:45,240
But you have to choose which actions are executed, otherwise you might edit the state in a wrong

00:07:45,240 --> 00:07:53,800
way, and you have to ad if statements.

00:07:53,800 --> 00:07:56,240
There's a lot of downsides to this.

00:07:56,240 --> 00:07:59,360
This bottomup code is difficult to test.

00:07:59,360 --> 00:08:01,740
All the application logic lives in your mind.

00:08:01,740 --> 00:08:06,550
So when you're writing your tests, you have to output it from the developer's mind on

00:08:06,550 --> 00:08:07,550
to the tests.

00:08:07,550 --> 00:08:10,780
And it makes it really hard to work with other developers.

00:08:10,780 --> 00:08:12,860
The code is difficult to understand.

00:08:12,860 --> 00:08:17,200
The code that I just showed you for showing and hiding the gallery, if you were to try

00:08:17,200 --> 00:08:22,520
to parse that as a brandnew developer working on the project, you would find it really difficult

00:08:22,520 --> 00:08:24,389
to do so.

00:08:24,389 --> 00:08:28,650
The code will contain bugs, for sure, because there's going to be edge cases that you might

00:08:28,650 --> 00:08:30,040
not have considered.

00:08:30,040 --> 00:08:33,909
It will also be difficult to enhance, just like we've seen with cancellation.

00:08:33,909 --> 00:08:38,749
And features, such as cancellation, make the code work.

00:08:38,749 --> 00:08:45,810
They explode the potential possible states and actions that could happen in your application.

00:08:45,810 --> 00:08:50,600
Here's an intuition for moving forward.

00:08:50,600 --> 00:08:54,300
We have a realization that UI components are not independent.

00:08:54,300 --> 00:08:59,889
We have frameworks that they isolate components and say these components fit in their nice

00:08:59,889 --> 00:09:09,820
little box, and we can stick them in the page anywhere.

00:09:09,820 --> 00:09:15,050
Everything they see on the screen is in the exact same context, and we have to coordinate

00:09:15,050 --> 00:09:17,740
from components to component.

00:09:17,740 --> 00:09:22,601
So another realization is that actions, which is what happens when you do an event, are

00:09:22,601 --> 00:09:30,610
based both on the events executed, and the current state of the context.

00:09:30,610 --> 00:09:38,860
And it's also that this event action paradigm is too simple to represent all the possible

00:09:38,860 --> 00:09:40,071
states our app can be in.

00:09:40,071 --> 00:09:45,210
So, what's the solution?

00:09:45,210 --> 00:09:47,790
Standard statecharts.

00:09:47,790 --> 00:09:55,040
I know a lot of you may have heard these before or studied them in school.

00:09:55,040 --> 00:10:00,009
Even though you might know what these are, you probably haven't applied them to user

00:10:00,009 --> 00:10:03,529
interfaces and actual software.

00:10:03,529 --> 00:10:07,040
So, looking up material for this could be a little complicated.

00:10:07,040 --> 00:10:16,579
I'm a visual person, and I'm going to do it in a very visual way.

00:10:16,579 --> 00:10:20,300
First you have an initial state.

00:10:20,300 --> 00:10:27,309
Then you have a finite number of states, which represents the states that the app could be

00:10:27,309 --> 00:10:28,309
in.

00:10:28,309 --> 00:10:32,930
When an app is in one state, it can't be in the other state at the same time.

00:10:32,930 --> 00:10:39,259
You have a finite number of events, such as fetching, resolving, or rejecting a promise.

00:10:39,259 --> 00:10:44,180
You have a mapping from state to state based on these events.

00:10:44,180 --> 00:10:48,800
So for example, when you're fetching a promise and it resolves, you go to the fulfilled state.

00:10:48,800 --> 00:10:52,360
And same way with reject and rejected state.

00:10:52,360 --> 00:10:57,470
And you have a finite number of final states.

00:10:57,470 --> 00:11:00,259
User interfaces can be continuous.

00:11:00,259 --> 00:11:02,360
We could keep using them.

00:11:02,360 --> 00:11:08,730
It doesn't say we're done, so go uninstall Instagram because you're not going to need

00:11:08,730 --> 00:11:09,730
it.

00:11:09,730 --> 00:11:16,439
If you go to this site, it's going to say promises are just a state machine.

00:11:16,439 --> 00:11:19,889
That should give you a big clue with what we're working with here.

00:11:19,889 --> 00:11:24,939
So the original app that I showed you, the gallery app can be modelled as the state machine

00:11:24,939 --> 00:11:26,129
right here.

00:11:26,129 --> 00:11:29,420
So we start in the idle state, and then we go to search.

00:11:29,420 --> 00:11:30,980
Then we're in the searching state.

00:11:30,980 --> 00:11:34,170
If we try to search again, it loops back.

00:11:34,170 --> 00:11:35,300
It's like hold on.

00:11:35,300 --> 00:11:36,800
We're already searching.

00:11:36,800 --> 00:11:42,220
We can either resolve or reject the search results.

00:11:42,220 --> 00:11:46,800
And from those two states, we could search again.

00:11:46,800 --> 00:11:53,939
This is clearly seen by the arrows going from success or failure back to searching again.

00:11:53,939 --> 00:12:02,040
So, the machine thatï¿½ the state machine that I envision looks sort of like this.

00:12:02,040 --> 00:12:03,399
It's a JSON object.

00:12:03,399 --> 00:12:09,490
I like JSON better than blackbox functions because you can enumerate all the possible

00:12:09,490 --> 00:12:15,670
states and actions and be able to transition from one to the other with nice, simple function

00:12:15,670 --> 00:12:16,700
right here.

00:12:16,700 --> 00:12:23,800
For example, if we're in the searching state, and I get a resolve, then I just look it up

00:12:23,800 --> 00:12:25,679
in this JSON object.

00:12:25,679 --> 00:12:29,329
This searching, on resolve, success.

00:12:29,329 --> 00:12:34,519
In type script, it's a record.

00:12:34,519 --> 00:12:41,069
I guess it's the same in C#.

00:12:41,069 --> 00:12:44,079
In PHP, they call for help.

00:12:44,079 --> 00:12:46,190
I don't know.

00:12:46,190 --> 00:12:51,350
So here's an example of what I just showed you.

00:12:51,350 --> 00:12:56,459
If I were to search for icelandï¿½ let's search for goats first.

00:12:56,459 --> 00:12:57,550
Let's say I don't want to search for goats.

00:12:57,550 --> 00:13:00,249
I'll just cancel that.

00:13:00,249 --> 00:13:10,790
Let's search for Iceland instead.

00:13:10,790 --> 00:13:16,249
When we do the event of selecting a photo, we have a state transition that goes from

00:13:16,249 --> 00:13:19,569
gallery to photo.

00:13:19,569 --> 00:13:24,529
We can exit that, search again, cancel, search.

00:13:24,529 --> 00:13:27,940
Let's cancel that.

00:13:27,940 --> 00:13:29,079
Iceland.

00:13:29,079 --> 00:13:32,889
And so you see it goes from state to state, and no matter how many times I try to break

00:13:32,889 --> 00:13:38,740
this app, it's not going to deviate from this state machine that I have here.

00:13:38,740 --> 00:13:43,059
And you see there was a few extra things such as actions over here.

00:13:43,059 --> 00:13:46,199
When I'm done searching, update the items?

00:13:46,199 --> 00:13:50,370
We're going to discuss that in a little further detail.

00:13:50,370 --> 00:13:55,079
And also this is part of an article that I wrote which gives an introduction to finite

00:13:55,079 --> 00:13:58,209
state machines.

00:13:58,209 --> 00:14:02,040
So I use visual studio share.

00:14:02,040 --> 00:14:04,160
I work on it and I also have to use it.

00:14:04,160 --> 00:14:07,300
It's called dog fooding.

00:14:07,300 --> 00:14:12,019
Anyway... and this is sort of what it looks like.

00:14:12,019 --> 00:14:16,709
And so, I don't know if we have Sarah and Burke in here.

00:14:16,709 --> 00:14:20,489
Here's Burke right now.

00:14:20,489 --> 00:14:24,369
You can think of it as Google docs for collaborative coding.

00:14:24,369 --> 00:14:27,380
It's in preview in Microsoft.

00:14:27,380 --> 00:14:32,170
And I have no control over what they're typing, and they're typing this in realtime.

00:14:32,170 --> 00:14:37,470
With this live share, we can collaboratively code in the exact same document at the same

00:14:37,470 --> 00:14:38,639
time.

00:14:38,639 --> 00:14:44,119
These are a complex series of events that are happening at the same time, and so we

00:14:44,119 --> 00:14:49,290
have to manage all of these possible events and all the possible states that this could

00:14:49,290 --> 00:14:53,119
be in.

00:14:53,119 --> 00:14:54,470
I have no idea...

00:14:54,470 --> 00:14:55,470
Oh God.

00:14:55,470 --> 00:14:57,699
Good luck breaking the demo.

00:14:57,699 --> 00:14:59,110
It probably will, though.

00:14:59,110 --> 00:15:00,110
Ha ha.

00:15:00,110 --> 00:15:01,110
Anyway!

00:15:01,110 --> 00:15:09,389
I'm going to end this before it gets too crazy...

00:15:09,389 --> 00:15:14,720
One of the big things I have to work on in liveshare is this whole signin flow.

00:15:14,720 --> 00:15:20,089
You would think that signing in is easy and, you know, signing in, signing out, all of

00:15:20,089 --> 00:15:21,790
that.

00:15:21,790 --> 00:15:23,100
But it's actually not.

00:15:23,100 --> 00:15:26,649
Once you start drawing it out, it becomes a lot more complex.

00:15:26,649 --> 00:15:29,009
So for example, there could be a signin failure.

00:15:29,009 --> 00:15:31,459
You know, especially from Iceland.

00:15:31,459 --> 00:15:33,600
I'm so glad that worked in Iceland.

00:15:33,600 --> 00:15:36,939
All of our servers are based in the United States.

00:15:36,939 --> 00:15:41,689
So when you have a signin success, then you go to the signin state.

00:15:41,689 --> 00:15:43,910
From there you could go do two things.

00:15:43,910 --> 00:15:47,769
You could either share a session or join a session.

00:15:47,769 --> 00:15:53,869
So what I did was a couple months back, I refactored this part of the app so that it

00:15:53,869 --> 00:15:57,339
uses an explicit state machine just like this.

00:15:57,339 --> 00:15:58,889
We were getting a lot of bugs.

00:15:58,889 --> 00:16:04,320
We were saying what if we're in the middle of sharing and the user signs out?

00:16:04,320 --> 00:16:09,339
What if we join the session, and then we decide to share a session at the same time?

00:16:09,339 --> 00:16:11,559
That shouldn't be allowed.

00:16:11,559 --> 00:16:18,529
We had all of these if/else and switch statements, so I decided there has to be a better way.

00:16:18,529 --> 00:16:23,790
I did the simple JSON object approach.

00:16:23,790 --> 00:16:28,850
The state machine that I set up?

00:16:28,850 --> 00:16:31,769
It was very easy to add telemetry to it.

00:16:31,769 --> 00:16:38,369
I added telemetry, and I get this nice visual showing exactly the frequency of how users

00:16:38,369 --> 00:16:40,079
go from state to state.

00:16:40,079 --> 00:16:45,059
So you could see obviously, most of the users go through this initializing and then signing

00:16:45,059 --> 00:16:49,769
in state, and then you could either externally sign in, or you could sign out.

00:16:49,769 --> 00:16:57,639
And then you could see that users tend to go to either joining or sharing, you know?

00:16:57,639 --> 00:16:59,959
At about the same frequency.

00:16:59,959 --> 00:17:01,360
And yeah.

00:17:01,360 --> 00:17:07,610
So it clearly shows, too, how many users go to the error state and how many users go to

00:17:07,610 --> 00:17:10,520
the success state for each of these states as well.

00:17:10,520 --> 00:17:12,740
Now, these are very powerful insights.

00:17:12,740 --> 00:17:17,520
Because while telemetry will only tell you an atomic bit of data, here is telemetry that

00:17:17,520 --> 00:17:21,500
tells you the entire user flow of what's happening.

00:17:21,500 --> 00:17:26,310
We could limit this to user and be able to see a nice path of what the user actually

00:17:26,310 --> 00:17:27,810
did in the app.

00:17:27,810 --> 00:17:35,840
So it's sort of like, you know, like the funnel diagrams, except even crazier.

00:17:35,840 --> 00:17:38,940
We could also use state machines for integration testing.

00:17:38,940 --> 00:17:43,470
And so this gets a little bit into graph theory, so bear with me a little bit.

00:17:43,470 --> 00:17:50,240
Here we would be using a shortest path algorithm.

00:17:50,240 --> 00:17:55,580
You could choose your favorite one.

00:17:55,580 --> 00:18:03,350
It sounds like an Icelandic name.

00:18:03,350 --> 00:18:06,780
Any of these formulas for finding the shortest path.

00:18:06,780 --> 00:18:11,370
And so, for those who don't know, the shortest path is just going from one state to the other

00:18:11,370 --> 00:18:13,280
with the minimal cost.

00:18:13,280 --> 00:18:17,680
So you could imagine each of these arrows have a wait.

00:18:17,680 --> 00:18:22,490
And so you just want to minimize, you know, how long it takes to get from one path to

00:18:22,490 --> 00:18:23,490
the other.

00:18:23,490 --> 00:18:28,430
Sort of like in Google maps, finding the shortest ETA from one point to the other.

00:18:28,430 --> 00:18:30,340
So analytics would provide these waits.

00:18:30,340 --> 00:18:35,280
And this represents all the happy paths a user could take.

00:18:35,280 --> 00:18:41,870
If we want a user to, let's say, share a session, and get to the shared state, we would imagine

00:18:41,870 --> 00:18:45,960
the user going from signed in to sharing to shared.

00:18:45,960 --> 00:18:47,430
Just that simple.

00:18:47,430 --> 00:18:54,660
These could be automatically generated from the JSON structure just like this.

00:18:54,660 --> 00:18:58,280
But, remember, we're not just dealing with the happy paths.

00:18:58,280 --> 00:19:06,360
So, we would do a death first search algorithm to find all the other paths a user could take.

00:19:06,360 --> 00:19:11,300
Some of you might be thinking these algorithm things, I didn't think I would need them.

00:19:11,300 --> 00:19:14,850
You sort of do; they're really helpful.

00:19:14,850 --> 00:19:20,690
And so, these represent all the possible user flows.

00:19:20,690 --> 00:19:28,280
You can imagine a user getting from state A to state C might not take the easiest route.

00:19:28,280 --> 00:19:34,680
They might take a longer route to get all the way to C. And it reveals all the edge

00:19:34,680 --> 00:19:36,010
cases.

00:19:36,010 --> 00:19:40,290
When you model every single possible state with every single possible action, and you

00:19:40,290 --> 00:19:47,610
get all of these flows, you're going to basically have 100,000% test coverage for anything that

00:19:47,610 --> 00:19:49,340
could possibly happen in your app.

00:19:49,340 --> 00:19:52,300
And of course these could all be automatically generated.

00:19:52,300 --> 00:19:57,910
I caution against this, because you would be generating integration testsï¿½ it would

00:19:57,910 --> 00:20:02,300
generate a lot of integration tests, which isn't necessarily a bad thing, but when you're

00:20:02,300 --> 00:20:07,760
doing continuous integration, you don't want your tests to take four hours long.

00:20:07,760 --> 00:20:12,880
It makes software bugs visually clear by drawing a map and putting them on the diagram.

00:20:12,880 --> 00:20:17,280
You can see when I do this event, I'm going to the wrong state.

00:20:17,280 --> 00:20:21,210
Or maybe I have an unhandled event, which does nothing.

00:20:21,210 --> 00:20:25,190
Or maybe I have a missing transition.

00:20:25,190 --> 00:20:26,190
That's shown here, too.

00:20:26,190 --> 00:20:32,320
For example, Dan was showing the example where when you click a movie, it just waits and

00:20:32,320 --> 00:20:37,130
waits, and then you get the next movie, and there's no loading state.

00:20:37,130 --> 00:20:40,490
You can clearly see that in the state transition diagram.

00:20:40,490 --> 00:20:43,860
And also, my favorite, race conditions.

00:20:43,860 --> 00:20:50,290
These are just made completely nil and void with state machines, because you explicitly

00:20:50,290 --> 00:20:54,180
say, when I get this event, I go to this state.

00:20:54,180 --> 00:20:59,080
If I get another event after that that I don't care about, it's not going to cause a race

00:20:59,080 --> 00:21:01,860
condition, because I will ignore that event.

00:21:01,860 --> 00:21:04,150
And that's what state machines can help with.

00:21:04,150 --> 00:21:08,550
Now I want to talk about Harold statecharts.

00:21:08,550 --> 00:21:12,960
This could go on for hours and hours, because there's so much information here.

00:21:12,960 --> 00:21:18,150
I'm going to give an overview of what these are and how these extend state machines in

00:21:18,150 --> 00:21:22,110
order to improve the way we look at user interfaces.

00:21:22,110 --> 00:21:26,730
Because, user interfaces can get complex, and finite state machines might not solve

00:21:26,730 --> 00:21:28,880
everything.

00:21:28,880 --> 00:21:32,890
So with statecharts, they are similar to state machines.

00:21:32,890 --> 00:21:35,420
They are an extension of it.

00:21:35,420 --> 00:21:38,400
Except we can have actions with Harel statecharts, too.

00:21:38,400 --> 00:21:42,880
They actually do things to the state and the app.

00:21:42,880 --> 00:21:50,850
We can have guards which prevent states from going from one to the other if something doesn't

00:21:50,850 --> 00:21:52,180
match the condition.

00:21:52,180 --> 00:21:57,880
If I'm trying to search for something, and the user didn't give me a search query, then

00:21:57,880 --> 00:22:01,090
I'm not going to transition to the next state.

00:22:01,090 --> 00:22:03,660
That could be declaratively modelled as well.

00:22:03,660 --> 00:22:09,580
There's the idea of nested states.

00:22:09,580 --> 00:22:10,780
This is parallel states.

00:22:10,780 --> 00:22:18,190
It is not concurrent states where an app can be in two states at the same time.

00:22:18,190 --> 00:22:22,830
It's more a way of simplifying the number of states you have so your state machine doesn't

00:22:22,830 --> 00:22:24,370
look all crazy.

00:22:24,370 --> 00:22:31,250
And also, history, which is a very common feature that many users would want in order

00:22:31,250 --> 00:22:34,770
to go back to their safe state.

00:22:34,770 --> 00:22:43,470
So I created this library called X states which models finite state machines and statecharts

00:22:43,470 --> 00:22:48,940
in a declarative way, so that all you would have to do is use this JSON structure to model

00:22:48,940 --> 00:22:54,730
your state machine, and then you would get the next state by calling transition on the

00:22:54,730 --> 00:22:57,460
current state and the action.

00:22:57,460 --> 00:23:03,310
It's functional, and it's going to work in any framework or no framework at all.

00:23:03,310 --> 00:23:08,790
It also has the notion of actions, so it will return you an object telling you, these are

00:23:08,790 --> 00:23:13,910
the next actions that you're going to take once you transition to a state.

00:23:13,910 --> 00:23:18,850
It also has guards, so you could pass in some external state, and it will validate against

00:23:18,850 --> 00:23:22,780
that external state and say, Okay, this condition is met.

00:23:22,780 --> 00:23:25,120
So you go on to the next state.

00:23:25,120 --> 00:23:31,090
It also has hierarchy so you can represent and compose machines easily.

00:23:31,090 --> 00:23:38,120
It has orthogonality so you can represent parallel states and also represent remembered

00:23:38,120 --> 00:23:39,130
states.

00:23:39,130 --> 00:23:45,560
If you're doing a payment flow and you're asking for cash or card, the user can switch

00:23:45,560 --> 00:23:48,630
between them, and the user gets to the review page.

00:23:48,630 --> 00:23:52,080
You want to remember if the user chose cash or card.

00:23:52,080 --> 00:23:56,630
So you go to method.history, and it would remember that.

00:23:56,630 --> 00:24:02,440
And this is a purely functional, no side effect type of thing.

00:24:02,440 --> 00:24:06,680
And so you can imagine the applications of where you could apply this.

00:24:06,680 --> 00:24:13,020
One example of where you would use orthoganal states is this example.

00:24:13,020 --> 00:24:15,740
Say you have bold, italic, or underline.

00:24:15,740 --> 00:24:24,940
A user can use all or none of them, and it's represented by all of these eight states.

00:24:24,940 --> 00:24:32,300
And you can imagine if we add more options such as align left, align center, justify,

00:24:32,300 --> 00:24:35,990
it's going to explode into even more states.

00:24:35,990 --> 00:24:44,870
With orthogonal statecharts, we just have this succinct representation of these possible

00:24:44,870 --> 00:24:50,841
states, so that we know we can go from bold on to after, italics on to off, and same way

00:24:50,841 --> 00:24:55,050
with underline, and we can represent all of those at the same time.

00:24:55,050 --> 00:25:02,160
And also, hierarchy helps to reduce the number of arrows that you have in your finite state

00:25:02,160 --> 00:25:03,160
machine.

00:25:03,160 --> 00:25:07,570
So for example, both the success and failure states, we could search again and go back

00:25:07,570 --> 00:25:09,290
to the searching state.

00:25:09,290 --> 00:25:15,240
We could simplify this by just nesting them in a single state, the search state.

00:25:15,240 --> 00:25:19,690
This is fully supported by X state, and yeah.

00:25:19,690 --> 00:25:26,660
So, you could imagine how this would simplify just really complex state machines.

00:25:26,660 --> 00:25:36,020
So, I released X state about six months ago at React rally, and since then, there has

00:25:36,020 --> 00:25:41,940
been a lot of development and a lot of people actually using it to make projects such as

00:25:41,940 --> 00:25:45,170
React automa and others.

00:25:45,170 --> 00:25:50,020
And pretty soon, I'm going to be releasing another version, minor version.

00:25:50,020 --> 00:25:54,680
Don't worry; nothing crazy, of Xstate where we improved the user ergonomics.

00:25:54,680 --> 00:25:59,650
It's full SCXML.

00:25:59,650 --> 00:26:01,100
It's not sexy.

00:26:01,100 --> 00:26:05,950
Code is not sexy at all.

00:26:05,950 --> 00:26:13,480
A Reactive interpreter, visualization interpreter, and a lot more examples.

00:26:13,480 --> 00:26:21,230
In order to show you what I'm talking about, here is an example of a visualization tool.

00:26:21,230 --> 00:26:26,900
That same JSON object that you passed into xstate and the same one I used for my gallery

00:26:26,900 --> 00:26:38,500
app, this is one example of where you would use this.

00:26:38,500 --> 00:26:45,280
My initial state is start, and I can hover over this search action, and go to this state.

00:26:45,280 --> 00:26:50,570
Then I could see the possible different actionsï¿½ sorry, events that I could take from this

00:26:50,570 --> 00:26:51,570
state.

00:26:51,570 --> 00:26:54,110
So let's say I have a search success.

00:26:54,110 --> 00:26:56,770
And so, I go into the gallery view.

00:26:56,770 --> 00:27:03,860
And then I choose to search again, or I could select a photo.

00:27:03,860 --> 00:27:13,630
So, I can visually see what's happening in my state machine by pasting in that JSON object.

00:27:13,630 --> 00:27:18,200
That's hard to do with just a function, so that's why I decided to do it in a more declarative

00:27:18,200 --> 00:27:20,310
way.

00:27:20,310 --> 00:27:22,380
I'm going to be releasing this soon.

00:27:22,380 --> 00:27:27,810
I want you all to enjoy the rest of the conference before I release it, so you can have time

00:27:27,810 --> 00:27:28,970
to play with it afterwards.

00:27:28,970 --> 00:27:32,250
That's my excuse, at least.

00:27:32,250 --> 00:27:38,680
It's not out yet.

00:27:38,680 --> 00:27:46,220
Now, it would be, you know, sort of remiss of me to not talk about sort of the downsides

00:27:46,220 --> 00:27:53,190
of state machines and statecharts, but the truth is that you all are already creating

00:27:53,190 --> 00:27:57,580
finite state machines and statecharts in your app already, and you don't even know it.

00:27:57,580 --> 00:28:00,770
However, the ones that you're creating are implicit.

00:28:00,770 --> 00:28:03,030
They're full of bugs.

00:28:03,030 --> 00:28:05,030
They're incomplete.

00:28:05,030 --> 00:28:10,250
And that's just the nature of how we code.

00:28:10,250 --> 00:28:16,630
So the advantage of finite state machines and modeling them in a very explicit way is

00:28:16,630 --> 00:28:23,490
that you reduce a lot of complexity up front just by getting rid of your if/else statements

00:28:23,490 --> 00:28:27,600
and getting rid of your switch statements and having a direct mapping.

00:28:27,600 --> 00:28:31,430
However, that quickly explodes into many, many different states.

00:28:31,430 --> 00:28:37,150
So statecharts help manage that with a little higher complexity cost up front.

00:28:37,150 --> 00:28:43,620
But in the long run, you will see it will be very easy to add features, remove features,

00:28:43,620 --> 00:28:49,740
and handle different actions and different possible modes of your application.

00:28:49,740 --> 00:28:55,630
So, of course, there's a lot of advantages to using statecharts, and the ones I am going

00:28:55,630 --> 00:28:59,270
to quote are not actually from me.

00:28:59,270 --> 00:29:01,240
They're from NASA.

00:29:01,240 --> 00:29:08,110
A few years ago, NASA had to send this little vehicle right here all the way to Mars.

00:29:08,110 --> 00:29:11,240
And they did so using statecharts.

00:29:11,240 --> 00:29:16,270
So the advantages that they said was, first of all, there's visualized modeling.

00:29:16,270 --> 00:29:23,650
So you could both model and examine the model of a state chart using visual tools.

00:29:23,650 --> 00:29:29,310
You get these precise diagrams that tell you exactly what's going to happen when certain

00:29:29,310 --> 00:29:33,400
conditions are met, when you're in a certain state, and this event happens.

00:29:33,400 --> 00:29:38,080
When you're sending something to Mars, you can't exactly just send it there and hope

00:29:38,080 --> 00:29:39,650
that it works, right?

00:29:39,650 --> 00:29:45,800
You have to be absolutely sure that your billion dollar project is going to handle every single

00:29:45,800 --> 00:29:48,240
possible state.

00:29:48,240 --> 00:29:51,790
And so they also use state charts for automatic code generation.

00:29:51,790 --> 00:29:56,930
I'm not a fan, but you could see how it could be beneficial.

00:29:56,930 --> 00:29:59,970
Also, comprehensive test coverage.

00:29:59,970 --> 00:30:06,470
By using state charts, they were able to generate just all of these integration tests where

00:30:06,470 --> 00:30:11,870
they could test each and every one, and ensure that every single state was being hit, and

00:30:11,870 --> 00:30:15,510
every single possible action or event was being handled.

00:30:15,510 --> 00:30:22,610
Also, you know, being on a big project, you have a lot of requirement changes.

00:30:22,610 --> 00:30:24,870
We want to add this to the rover.

00:30:24,870 --> 00:30:27,220
We want to remove this functionality.

00:30:27,220 --> 00:30:29,470
We want to change the way this works.

00:30:29,470 --> 00:30:34,630
And when you're working on a big project, and you have these late breaking requirement

00:30:34,630 --> 00:30:38,080
changes, then things can get really stressful.

00:30:38,080 --> 00:30:43,070
With state charts, since you could clearly see the full flow of your application, you

00:30:43,070 --> 00:30:48,670
could easily add and remove features without worrying what's going to break, what's going

00:30:48,670 --> 00:30:53,250
to change, what's going to be affected.

00:30:53,250 --> 00:30:55,760
So there are some disadvantages as well.

00:30:55,760 --> 00:31:00,529
And the disadvantage is that my screen just went black.

00:31:00,529 --> 00:31:03,980
I guess that means there are no disadvantages.

00:31:03,980 --> 00:31:05,630
Ha ha.

00:31:05,630 --> 00:31:06,630
Anyway...

00:31:06,630 --> 00:31:11,610
Since the rest of my slides are forked, I want to show you this real quick.

00:31:11,610 --> 00:31:16,580
I gave a talk about one and a half years ago.

00:31:16,580 --> 00:31:20,340
It was at JSConf Iceland.

00:31:20,340 --> 00:31:25,130
This is where I saw the primary use case for using state machines and statecharts.

00:31:25,130 --> 00:31:34,530
There was this really complex UI design that I really wanted to model, and I found it pretty

00:31:34,530 --> 00:31:39,160
difficult without using an explicit state machine or state chart.

00:31:39,160 --> 00:31:44,250
So what I'm doing here, there's three different states.

00:31:44,250 --> 00:31:45,809
This one.

00:31:45,809 --> 00:31:46,809
This one.

00:31:46,809 --> 00:31:48,620
And there's different actions as well.

00:31:48,620 --> 00:31:54,080
So the user could pan right, but just a little bit.

00:31:54,080 --> 00:32:01,080
So I handle that as a transition from going to state A, back to state A if they didn't

00:32:01,080 --> 00:32:02,240
move far enough.

00:32:02,240 --> 00:32:08,940
Of course, if they move far enough, it goes to the next state successfully.

00:32:08,940 --> 00:32:14,130
And also, it handles, like, if I'm going up, and I decide to go left and right, it's not

00:32:14,130 --> 00:32:18,809
going to do anything, because we're already going up and down.

00:32:18,809 --> 00:32:23,990
So it knows when this event happens, don't try to go to a different state, because we're

00:32:23,990 --> 00:32:32,570
already transitioning to one state.

00:32:32,570 --> 00:32:36,630
I also wanted to mention two very good resources.

00:32:36,630 --> 00:32:44,600
The first one is on spectrum.oi/statecharts.

00:32:44,600 --> 00:32:49,650
This is a community where we talk about statecharts, their possible applications, and how they're

00:32:49,650 --> 00:32:51,770
used everywhere.

00:32:51,770 --> 00:32:54,800
Statecharts are nothing new.

00:32:54,800 --> 00:32:58,550
They're invented by David Harel in 1987, which is what?

00:32:58,550 --> 00:33:01,000
30 years ago?

00:33:01,000 --> 00:33:03,020
This is not cuttingedge stuff.

00:33:03,020 --> 00:33:07,680
If people are asking why aren't we using statecharts everywhere now?

00:33:07,680 --> 00:33:13,970
Well, the thing is, they are in embedded systems or systems programming.

00:33:13,970 --> 00:33:17,670
People do use statecharts in order to model their applications.

00:33:17,670 --> 00:33:22,330
We don't, quite yet, but I think it's about time that we catch up to it.

00:33:22,330 --> 00:33:32,600
And so, Eric Mogansen made a wonderful resource called the unfinished world of statecharts.

00:33:32,600 --> 00:33:46,400
Over here, if you want to learn more information, there's a well wealth of information here.

00:33:46,400 --> 00:33:54,140
I really want to encourage you to revisit your application and the way you think about

00:33:54,140 --> 00:33:57,510
things, and actually try to visualize things.

00:33:57,510 --> 00:34:03,490
You will see that by visualizing your application, all of its possible states, all the events

00:34:03,490 --> 00:34:11,360
that could happen, that you're going to have a clearer representation of the possible bugs,

00:34:11,360 --> 00:34:16,389
the possible features that you might have, the user improvements, and everything else.

00:34:16,389 --> 00:34:18,720
So I want to thank you all for having me.

00:34:18,720 --> 00:34:22,230
Unfortunately, I can't show you my last slide, because it's not working, but thank you.

00:34:22,230 --> 00:34:22,440

YouTube URL: https://www.youtube.com/watch?v=RqTxtOXcv8Y


