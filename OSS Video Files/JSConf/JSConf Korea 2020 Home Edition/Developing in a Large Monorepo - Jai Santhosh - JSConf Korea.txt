Title: Developing in a Large Monorepo - Jai Santhosh - JSConf Korea
Publication date: 2020-10-16
Playlist: JSConf Korea 2020 Home Edition
Description: 
	At Microsoft, I work on a very large TypeScript-based git repository where over 300 developers build and write code for high-value frontend components which are used across all Microsoft365 products. It contains about 150 npm packages, containing over a million lines of TypeScript code. Co-locating these components encourages collaboration and sharing code across teams much easier.

In this talk, weâ€™ll focus on the tooling used and code organization to make the development easier, faster and more reliable, with a major focus on the largest pain point of package management and orchestrating common tasks across the packages.
Captions: 
	00:00:16,210 --> 00:00:17,043
- Hello, Korea.

00:00:17,043 --> 00:00:18,170
How are you doing?

00:00:18,170 --> 00:00:20,080
I'm very happy to meet you all.

00:00:20,080 --> 00:00:23,820
Hope you're all having a fantastic day at JSConf Korea.

00:00:23,820 --> 00:00:24,653
First of all,

00:00:24,653 --> 00:00:27,230
I want to thank all the organizers of this conference

00:00:27,230 --> 00:00:29,480
for all the hard work they've put in

00:00:29,480 --> 00:00:31,240
to make this conference possible

00:00:31,240 --> 00:00:33,660
despite the current global circumstances.

00:00:33,660 --> 00:00:35,610
Unfortunately, I can't be there in person,

00:00:35,610 --> 00:00:37,500
but I'm so happy that I can reach out

00:00:37,500 --> 00:00:39,630
to you all in this medium.

00:00:39,630 --> 00:00:41,120
I'm here to talk about

00:00:41,120 --> 00:00:45,140
how we can make the life of our developers much easier,

00:00:45,140 --> 00:00:47,140
who work on large monorepos.

00:00:48,000 --> 00:00:53,480
A monorepo or a mono-repository is a single repository

00:00:53,500 --> 00:00:58,410
that stores all of your code and assets for every project.

00:00:58,410 --> 00:01:03,050
We will look at JavaScript monorepo throughout this talk.

00:01:03,050 --> 00:01:05,280
In the beginning, we will try to understand

00:01:05,280 --> 00:01:06,790
what are some of the reasons

00:01:06,790 --> 00:01:09,510
why we opted for, you know,

00:01:09,510 --> 00:01:11,850
like a monorepo structure for our code.

00:01:11,850 --> 00:01:14,320
Then we look at some of the tooling and techniques

00:01:14,320 --> 00:01:17,043
which can help you be more productive with monorepos.

00:01:18,600 --> 00:01:20,270
I am Jai Santhosh

00:01:20,270 --> 00:01:23,570
and I work as an engineering manager at Microsoft.

00:01:23,570 --> 00:01:26,793
I am available on Twitter and my handle is @jaisanth.

00:01:27,650 --> 00:01:31,810
I'm from this beautiful city of Bangalore in South India.

00:01:31,810 --> 00:01:33,340
Usually the traffic is much more

00:01:33,340 --> 00:01:35,633
than what you can see in that illustration.

00:01:36,600 --> 00:01:40,250
At Microsoft I work on a product called Microsoft Search,

00:01:40,250 --> 00:01:44,040
where we built unified search experiences for, you know,

00:01:44,040 --> 00:01:46,480
like all your work related content

00:01:46,480 --> 00:01:51,373
across Microsoft 365 Apps suite, Windows and Bing.

00:01:52,920 --> 00:01:54,250
When you look at the search product,

00:01:54,250 --> 00:01:55,990
you can see that there are multiple components

00:01:55,990 --> 00:01:58,610
like the search box, the search results page,

00:01:58,610 --> 00:02:00,040
a lot of other components

00:02:00,040 --> 00:02:02,780
which are shared across the products

00:02:02,780 --> 00:02:04,930
so that we can achieve, you know,

00:02:04,930 --> 00:02:09,153
a uniform experience for the end user across the products.

00:02:10,980 --> 00:02:13,930
Experiences like search are what we considered

00:02:13,930 --> 00:02:17,520
as High-Value Experiences, which are critical operations

00:02:17,520 --> 00:02:20,530
a user does across applications

00:02:20,530 --> 00:02:24,290
and across platforms in the Office Suite.

00:02:24,290 --> 00:02:27,000
We also need to be more coherent

00:02:27,000 --> 00:02:30,860
to ensure the search experiences also look consistent

00:02:30,860 --> 00:02:33,020
with the rest of the application

00:02:33,020 --> 00:02:35,860
and across various apps and platforms.

00:02:35,860 --> 00:02:40,710
We have all the 400 developers who work on this monorepo.

00:02:40,710 --> 00:02:43,320
We also integrate the components we develop

00:02:43,320 --> 00:02:44,630
across the Microsoft Words

00:02:44,630 --> 00:02:47,310
like Office SharePoint, Themes, et cetera.

00:02:47,310 --> 00:02:50,833
And, you know, we mainly call this as host apps.

00:02:52,030 --> 00:02:55,980
Let's take the example of a simpler high-value experience,

00:02:55,980 --> 00:02:57,850
like the people card,

00:02:57,850 --> 00:02:59,940
the people card started out

00:02:59,940 --> 00:03:03,700
as a simpler contact information guide

00:03:03,700 --> 00:03:06,500
all time it has started growing in complexity.

00:03:06,500 --> 00:03:10,090
So now you can see that it has evolved in how it looks like

00:03:10,090 --> 00:03:12,403
and how much more feature rich it has become.

00:03:13,820 --> 00:03:16,940
Let us understand it in a bit more detail.

00:03:16,940 --> 00:03:18,670
You can see here that the people card

00:03:18,670 --> 00:03:22,610
now consists of various sections, such as insights,

00:03:22,610 --> 00:03:26,240
it contains recent activity, conversations,

00:03:26,240 --> 00:03:29,720
shared documents between you and the other person.

00:03:29,720 --> 00:03:32,540
What are the upcoming events between you two

00:03:32,540 --> 00:03:34,320
and a lot more

00:03:34,320 --> 00:03:37,500
apart from the contact information of the user.

00:03:37,500 --> 00:03:40,200
So it has actually evolved and grown in intelligence

00:03:40,200 --> 00:03:44,103
as well as how much information it actually contains.

00:03:45,120 --> 00:03:47,590
Also each section is actually expanded

00:03:47,590 --> 00:03:49,870
into even more detailed components,

00:03:49,870 --> 00:03:52,760
which are much much more complex in nature.

00:03:52,760 --> 00:03:53,920
Here, you can see that

00:03:53,920 --> 00:03:58,100
there are very like deeper conversations components

00:03:58,100 --> 00:04:00,040
that you can see that contact information

00:04:00,040 --> 00:04:01,633
also much more zoomed out.

00:04:03,090 --> 00:04:07,330
And so then, like you can have like documents

00:04:07,330 --> 00:04:10,100
between the two people that you've shared,

00:04:10,100 --> 00:04:12,600
or that you have access to.

00:04:12,600 --> 00:04:15,510
You can have access to all the events that are upcoming

00:04:15,510 --> 00:04:18,810
or the ones that you've recently had.

00:04:18,810 --> 00:04:22,370
The organization chart information for you,

00:04:22,370 --> 00:04:25,070
especially in large companies is really useful.

00:04:25,070 --> 00:04:26,790
And you will also have a lot more analytics

00:04:26,790 --> 00:04:29,650
and insights that you can get, right?

00:04:29,650 --> 00:04:31,920
So the people card now ended up having

00:04:31,920 --> 00:04:34,113
more than 20 categories of information.

00:04:35,360 --> 00:04:38,230
Now let's look at what we do as a developer

00:04:38,230 --> 00:04:40,780
when we're developing something like people card.

00:04:40,780 --> 00:04:43,070
If you visualize agility,

00:04:43,070 --> 00:04:45,840
we can see it is something like this.

00:04:45,840 --> 00:04:47,500
We can break it into two loops,

00:04:47,500 --> 00:04:50,020
the inner loop and the outer loop.

00:04:50,020 --> 00:04:53,870
The inner loop is more of, you know, a daily routine

00:04:53,870 --> 00:04:55,260
where you write new code,

00:04:55,260 --> 00:04:57,870
doesn't locally create a full request,

00:04:57,870 --> 00:04:59,950
verify build and test reports

00:04:59,950 --> 00:05:02,210
and merge it with the main branch.

00:05:02,210 --> 00:05:04,500
The outer loop consists of actions

00:05:04,500 --> 00:05:07,310
after the code is checked in, right?

00:05:07,310 --> 00:05:10,260
So we deployed two different rings to production,

00:05:10,260 --> 00:05:12,150
listen and measure feedback,

00:05:12,150 --> 00:05:13,830
propose what are the next steps

00:05:13,830 --> 00:05:16,310
to improve a feature or a certain component,

00:05:16,310 --> 00:05:20,093
and then write code and go back to inner loop again, right?

00:05:21,080 --> 00:05:26,080
So now let's, if you just zoom out a bit,

00:05:26,320 --> 00:05:30,100
you can see that how we can map this in practice

00:05:30,100 --> 00:05:32,010
for the people card scenario.

00:05:32,010 --> 00:05:36,680
Here, the outer loop is actually much more diverse, right.

00:05:36,680 --> 00:05:41,680
So, it is a more than any one given platform.

00:05:41,690 --> 00:05:44,410
So scaling out is really necessary,

00:05:44,410 --> 00:05:47,920
which works across the various platforms.

00:05:47,920 --> 00:05:51,930
We actually developed two six platforms as shown here,

00:05:51,930 --> 00:05:55,850
like the web, the iOS, UWP, Mac,

00:05:55,850 --> 00:05:59,690
MacOS, Win32 and so on.

00:05:59,690 --> 00:06:01,930
In most cases the usual norm is that

00:06:01,930 --> 00:06:06,150
each platform is typically siloed for the UX

00:06:06,150 --> 00:06:09,113
and development based on code basing people.

00:06:10,890 --> 00:06:13,870
Working across teams is very hard.

00:06:13,870 --> 00:06:17,040
It does scatter your developer environment,

00:06:17,040 --> 00:06:21,390
cross repo changes or rollback is very hard.

00:06:21,390 --> 00:06:24,810
It is very difficult to enforce conventions

00:06:24,810 --> 00:06:27,023
across different repos.

00:06:28,490 --> 00:06:31,210
Apart from all the software aspects,

00:06:31,210 --> 00:06:34,240
the largest problem is to tackle, you know,

00:06:34,240 --> 00:06:35,900
the people aspect.

00:06:35,900 --> 00:06:37,590
So we were working with, as I said,

00:06:37,590 --> 00:06:41,640
more than 400 developers across various teams

00:06:41,640 --> 00:06:45,400
and all of these people may not bide to the same goals.

00:06:45,400 --> 00:06:47,490
Hence we looked at unifying the core basis

00:06:47,490 --> 00:06:49,500
into a single source repository

00:06:49,500 --> 00:06:53,083
and evaluate if it can improve the develop rates tree

00:06:54,150 --> 00:06:55,690
To summarize the people card

00:06:55,690 --> 00:06:58,800
now has to be shared across multiple applications

00:06:58,800 --> 00:07:02,460
or host apps that we call in the Office 365 Suite,

00:07:02,460 --> 00:07:06,960
as well as across six platforms in a cohesive way where,

00:07:06,960 --> 00:07:09,100
you know, the people card still remains people card,

00:07:09,100 --> 00:07:11,420
but still has similar behavior

00:07:11,420 --> 00:07:13,780
and kind of looks homogeneous

00:07:13,780 --> 00:07:16,000
within each of these host apps

00:07:16,000 --> 00:07:19,310
and also kind of brings in native usage

00:07:19,310 --> 00:07:22,370
and intractability patterns into the people,

00:07:22,370 --> 00:07:24,000
to the same component.

00:07:24,000 --> 00:07:25,190
So we need to find a way

00:07:25,190 --> 00:07:27,423
to maximize deliberate agility here.

00:07:28,790 --> 00:07:30,600
We started adding all of this code

00:07:30,600 --> 00:07:33,830
to one single repository or monorepo

00:07:33,830 --> 00:07:36,913
and this brought in more singularity across packages.

00:07:38,360 --> 00:07:41,306
Now, let's look at what is a monorepo, right?

00:07:41,306 --> 00:07:43,560
A monorepo is a repository

00:07:43,560 --> 00:07:46,240
with multiple packages or projects.

00:07:46,240 --> 00:07:50,840
It may not necessarily be a colossal 86 terabyte monolith,

00:07:50,840 --> 00:07:53,390
but somewhere where various projects

00:07:53,390 --> 00:07:55,423
and packages can co-exist.

00:07:56,320 --> 00:08:00,940
It also allows us to break our code down to packages

00:08:00,940 --> 00:08:05,520
with single responsibility and hence multiple packages,

00:08:05,520 --> 00:08:08,010
which are aggregated this way can help in ensuring

00:08:08,010 --> 00:08:12,570
that even in other repository or the host apps repository

00:08:12,570 --> 00:08:16,070
they can actually pick a certain package and just use it.

00:08:16,070 --> 00:08:18,420
For example, think of the people card

00:08:19,730 --> 00:08:22,890
being used in a calendar widget in Outlook, right?

00:08:22,890 --> 00:08:26,860
So this way, it actually allows for use of small packages

00:08:26,860 --> 00:08:31,410
across multiple host apps and other repositories.

00:08:31,410 --> 00:08:33,370
Having all of this in a single repo

00:08:33,370 --> 00:08:37,020
also helped us unify process across packages,

00:08:37,020 --> 00:08:38,890
make developers more agile,

00:08:38,890 --> 00:08:40,863
achieve more code consistency.

00:08:41,729 --> 00:08:45,440
So even for developers, new developers who joined the team,

00:08:45,440 --> 00:08:47,470
it was very easy for them to discover code

00:08:47,470 --> 00:08:51,400
across the packages and that way it was helpful to have

00:08:51,400 --> 00:08:53,050
things in one place rather than scattered

00:08:53,050 --> 00:08:54,513
in multiple repositories.

00:08:55,770 --> 00:08:59,340
For our work on people card, it looks something like this.

00:08:59,340 --> 00:09:01,730
One thing we focused on was to ensure

00:09:01,730 --> 00:09:04,660
we break all the code down to smaller packages,

00:09:04,660 --> 00:09:07,610
which are single responsibility.

00:09:07,610 --> 00:09:10,240
You see, we were able to achieve maximum reuse

00:09:10,240 --> 00:09:11,850
across platforms.

00:09:11,850 --> 00:09:13,440
For example, here we broke

00:09:13,440 --> 00:09:16,913
the people card down into people data, people-api,

00:09:17,810 --> 00:09:20,800
people core, this can then be shared centrally

00:09:20,800 --> 00:09:23,090
across platforms specific packages,

00:09:23,090 --> 00:09:25,873
like people-web, people-ios and so on.

00:09:27,260 --> 00:09:31,920
So moving through a monorepo meant that we absolutely need

00:09:31,920 --> 00:09:35,380
and have reliable to link across various categories

00:09:35,380 --> 00:09:38,710
like package management, cross-package orchestration,

00:09:38,710 --> 00:09:40,803
linters, testing tools,

00:09:40,803 --> 00:09:44,790
build system, infrastructure and much more.

00:09:44,790 --> 00:09:48,290
In this stack, we mainly look at two of the hardest problems

00:09:48,290 --> 00:09:52,160
of package management and cross package orchestrators.

00:09:52,160 --> 00:09:54,600
These are some things that are very basic

00:09:54,600 --> 00:09:56,030
in the sense of monorepo

00:09:56,030 --> 00:09:57,650
and something where we might end up

00:09:57,650 --> 00:10:01,173
spending a lot more time and lose up for activity, right?

00:10:02,400 --> 00:10:05,170
Let's understand how we can simplify package management

00:10:05,170 --> 00:10:06,620
now in a JavaScript monorepo.

00:10:08,430 --> 00:10:10,600
So JavaScript packages are the building blocks

00:10:10,600 --> 00:10:13,858
of any large JavaScript repo.

00:10:13,858 --> 00:10:15,300
The repository that we've working

00:10:15,300 --> 00:10:19,270
has over 150 to 200 internal packages.

00:10:19,270 --> 00:10:23,900
We take a dependency of over 2,500 external packages

00:10:23,900 --> 00:10:26,610
for our components to work well with each other

00:10:26,610 --> 00:10:28,970
and with our partner repos,

00:10:28,970 --> 00:10:31,660
we really need to manage our packages really well.

00:10:32,957 --> 00:10:34,700
Before we learn more about it,

00:10:34,700 --> 00:10:38,520
let us first understand how a package gets used.

00:10:38,520 --> 00:10:41,240
The package.json file is actually read

00:10:41,240 --> 00:10:44,433
by the package managers such as NPM or Yarn,

00:10:45,853 --> 00:10:49,190
when you require a certain module in your JavaScript file

00:10:50,290 --> 00:10:54,360
NodeJS will resolve this by looking at the module on disk.

00:10:54,360 --> 00:10:57,620
So the package manager actually writes files to this

00:10:57,620 --> 00:11:02,120
which then your NodeJS process kind of looks at the files

00:11:03,390 --> 00:11:05,090
that are on the disk.

00:11:05,090 --> 00:11:06,700
So the key inside here is that

00:11:06,700 --> 00:11:09,070
Node will not resolve anything

00:11:09,070 --> 00:11:10,920
by looking at the package.json

00:11:10,920 --> 00:11:14,730
but rather it will just look at the file

00:11:14,730 --> 00:11:17,900
with node module resolution, which is present on the disk.

00:11:17,900 --> 00:11:22,100
It won't even verify that if it is getting the right version

00:11:22,100 --> 00:11:24,060
that is required or not, right?

00:11:24,060 --> 00:11:26,780
So we need to just ensure that the files on disk

00:11:26,780 --> 00:11:28,330
are actually proper

00:11:28,330 --> 00:11:30,743
and that's where Node can pick it up from.

00:11:32,040 --> 00:11:36,070
So Node Module Resolution is a key concept in Node.js.

00:11:36,070 --> 00:11:39,080
The basic idea behind this algorithm is started

00:11:39,080 --> 00:11:42,300
a recursively looks at of what a certain package

00:11:42,300 --> 00:11:43,240
that is required.

00:11:43,240 --> 00:11:44,373
Let's take an example,

00:11:45,390 --> 00:11:49,900
say for module in the people-core package depends on react,

00:11:49,900 --> 00:11:51,920
Node we'll look for it in the react

00:11:51,920 --> 00:11:54,370
in the node modules folder of people-core,

00:11:54,370 --> 00:11:55,380
if it can't find it there,

00:11:55,380 --> 00:11:57,640
it will look in the node_modules folder

00:11:57,640 --> 00:12:00,050
of the parent of people-core and so on

00:12:00,050 --> 00:12:03,750
all the way to the root of your hard drive, right?`.

00:12:03,750 --> 00:12:06,770
So now let's map this concept in case of a monorepo.

00:12:06,770 --> 00:12:08,810
I assume that we have two repositories

00:12:08,810 --> 00:12:12,210
with package one, package two with the monorepo,

00:12:12,210 --> 00:12:16,050
you can see that like both of these packages

00:12:16,050 --> 00:12:20,203
come to the same folder under a monorepo, right?

00:12:21,250 --> 00:12:23,740
We want to look at a few issues with monorepo

00:12:23,740 --> 00:12:26,550
which probably we can solve with our current understanding

00:12:26,550 --> 00:12:30,363
of how Node resolves modules, right?

00:12:31,370 --> 00:12:33,740
A concept package may just use

00:12:33,740 --> 00:12:36,140
is sharing common dependencies on disk

00:12:37,150 --> 00:12:39,870
because of the nature of monorepo

00:12:39,870 --> 00:12:42,530
most packages will share many dependencies

00:12:42,530 --> 00:12:44,578
and there can also be, you know,

00:12:44,578 --> 00:12:47,600
like some packages can be dependent on other packages

00:12:47,600 --> 00:12:49,770
of within the monorepo itself.

00:12:49,770 --> 00:12:52,260
So imagine having two packages, Oh, like I said,

00:12:52,260 --> 00:12:54,100
package one and package two.

00:12:54,100 --> 00:12:59,100
We have three dependencies here on package B,

00:12:59,560 --> 00:13:02,440
and then we have two versions.

00:13:02,440 --> 00:13:06,240
So say package one, depends on packages A, C,

00:13:06,240 --> 00:13:08,710
and then A internally it takes

00:13:08,710 --> 00:13:12,210
a dependency on B of 1.0 version.

00:13:12,210 --> 00:13:15,840
Package two also takes a dependency on B, 1.0 version.

00:13:15,840 --> 00:13:20,392
You can see here that package C actually takes a dependency

00:13:20,392 --> 00:13:23,400
on 2.0 version of B, not the 1.0 version.

00:13:23,400 --> 00:13:25,980
So there are like three copies of B,

00:13:25,980 --> 00:13:30,090
where we can do couple of them, like B at 1.0 version,

00:13:30,090 --> 00:13:35,090
but still retain to ensure that C kind of takes a dependency

00:13:35,390 --> 00:13:38,993
on the 2.0 version of package B, right?

00:13:40,560 --> 00:13:44,270
So leveraging the node module resolution algorithm,

00:13:44,270 --> 00:13:46,440
you can see that now,

00:13:46,440 --> 00:13:51,350
if we kind of install all this node packages or dependencies

00:13:51,350 --> 00:13:56,040
at a higher level of the monorepo folder,

00:13:58,180 --> 00:14:00,650
you can see that if you have these packages

00:14:00,650 --> 00:14:02,760
under a node modules folder like,

00:14:02,760 --> 00:14:04,570
you have A, B, C,

00:14:04,570 --> 00:14:06,940
and C taking a dependency internally

00:14:06,940 --> 00:14:10,680
on B, 2.0 under the node module folder.

00:14:10,680 --> 00:14:13,710
Also, you can see that there are symlinks created

00:14:13,710 --> 00:14:15,000
to package one and two

00:14:15,000 --> 00:14:18,010
so that say, if package three later on takes a dependency

00:14:18,010 --> 00:14:21,510
on package one, it can still be resolved

00:14:21,510 --> 00:14:24,323
with the node module resolution algorithm.

00:14:24,323 --> 00:14:27,220
This concept is called package hoisting.

00:14:27,220 --> 00:14:28,280
This is really great

00:14:28,280 --> 00:14:31,030
because this means that we can now have some tools

00:14:31,030 --> 00:14:32,147
which can help us achieve,

00:14:32,147 --> 00:14:35,983
you know, package management a lot easier, right?

00:14:37,130 --> 00:14:41,210
Some of the tools that you can use for managing packages

00:14:41,210 --> 00:14:44,070
in your monorepo are rush JS,

00:14:44,070 --> 00:14:47,510
there's something that Microsoft open so is long back.

00:14:47,510 --> 00:14:50,520
We also have yarn workspaces,

00:14:50,520 --> 00:14:52,490
you can also use pnpm workspaces,

00:14:52,490 --> 00:14:55,123
you can use, a tool called Lerna.

00:14:56,300 --> 00:14:59,770
So, in our monorepo we use yarn workspaces,

00:14:59,770 --> 00:15:03,400
let's just see how it works, right?

00:15:03,400 --> 00:15:07,150
To use yarn workspaces, you add a package.json

00:15:07,150 --> 00:15:10,040
in the monorepo root folder.

00:15:10,040 --> 00:15:12,500
You can set private to true,

00:15:12,500 --> 00:15:13,920
add a configuration around

00:15:13,920 --> 00:15:17,520
what packages need to be managed by workspaces.

00:15:17,520 --> 00:15:20,910
You can also use like a regex pattern

00:15:20,910 --> 00:15:25,030
for having all packages under a certain folder

00:15:25,030 --> 00:15:28,010
so that like you can continue adding new packages

00:15:28,010 --> 00:15:31,150
and you don't have to change this configuration.

00:15:31,150 --> 00:15:33,570
Additionally, you can also have like

00:15:33,570 --> 00:15:35,500
a no hoist configuration,

00:15:35,500 --> 00:15:37,580
say if you have some packages

00:15:37,580 --> 00:15:39,320
where you don't want to hoist them

00:15:39,320 --> 00:15:41,273
to the monorepo root level,

00:15:42,400 --> 00:15:44,663
you can exclude them from hoisting.

00:15:45,750 --> 00:15:48,210
And then all you need to do is run yarn

00:15:48,210 --> 00:15:51,190
from the root of the monorepo.

00:15:51,190 --> 00:15:55,343
So the package installation time for, I mean,

00:15:55,343 --> 00:15:57,720
we use 150 plus packages.

00:15:57,720 --> 00:16:00,710
So this actually came down from 20 minutes

00:16:00,710 --> 00:16:03,880
that we used to struggle before to six minutes.

00:16:03,880 --> 00:16:05,750
So this really improved

00:16:05,750 --> 00:16:07,950
a lot of developer productivity time, right?

00:16:10,710 --> 00:16:12,830
The next aspect that we'll look at is

00:16:12,830 --> 00:16:15,870
how to orchestrate actions or commands

00:16:15,870 --> 00:16:19,100
across packages in a monorepo,

00:16:19,100 --> 00:16:23,680
some of the popular tools to achieve this Rush.js again,

00:16:23,680 --> 00:16:28,450
you have Lerna, you can also use a task kernel like Gulp,

00:16:28,450 --> 00:16:31,160
you can also, if your monorepo is simple enough,

00:16:31,160 --> 00:16:35,028
you can even manage it with simple Shell scripts, right?

00:16:35,028 --> 00:16:40,028
We need these tools to perform operations across packages,

00:16:40,420 --> 00:16:43,253
usually from the root folder of the monorepo.

00:16:44,390 --> 00:16:47,258
So we use Lerna in our monorepo,

00:16:47,258 --> 00:16:52,258
you can just look at how insane the logo of Lerna is.

00:16:52,280 --> 00:16:54,313
It's just quite mentored, right?

00:16:56,250 --> 00:16:57,590
So for using Lerna,

00:16:57,590 --> 00:16:59,630
what you need to do is add

00:16:59,630 --> 00:17:02,410
a lerna.json configuration file

00:17:02,410 --> 00:17:04,969
in the root of your monorepo, right?

00:17:04,969 --> 00:17:08,540
So, that like you can actually start running scripts

00:17:08,540 --> 00:17:10,483
from the root folder itself.

00:17:11,410 --> 00:17:15,736
You can add what packages to run your commands

00:17:15,736 --> 00:17:19,100
and then you can specify which npmClient to use,

00:17:19,100 --> 00:17:21,140
in our case, we are using yarn.

00:17:21,140 --> 00:17:23,420
So we just add yarn,

00:17:23,420 --> 00:17:28,420
you can also add the configuration of useWorkspaces to true

00:17:29,400 --> 00:17:31,520
if you're using yarn workspaces.

00:17:31,520 --> 00:17:32,380
So there's options,

00:17:32,380 --> 00:17:35,270
so if you are not using yarn workspace

00:17:35,270 --> 00:17:38,253
or pnpm workspaces, you can actually set it to false.

00:17:39,870 --> 00:17:41,880
If you're using, if you set it to true,

00:17:41,880 --> 00:17:45,190
that one is that you get is a Lerna

00:17:45,190 --> 00:17:48,530
whenever it's trying to run the commands,

00:17:48,530 --> 00:17:52,594
it kind of leverages the workspaces dependency

00:17:52,594 --> 00:17:55,440
add resolution a lot easier, right?

00:17:55,440 --> 00:17:59,130
So what learner does is it automatically figures out

00:17:59,130 --> 00:18:01,500
the dependency tree, if there are some packages

00:18:01,500 --> 00:18:03,050
which require some other,

00:18:03,050 --> 00:18:05,500
which take a dependency on other local packages,

00:18:05,500 --> 00:18:08,500
so which means that if you're running a build command,

00:18:08,500 --> 00:18:10,720
then it will require the build command to be run

00:18:10,720 --> 00:18:14,990
in other local packages first and then a certain package.

00:18:14,990 --> 00:18:19,240
So this way it executes the commands

00:18:19,240 --> 00:18:21,870
for the packages in a certain order

00:18:21,870 --> 00:18:24,430
of the dependency tree, right?

00:18:24,430 --> 00:18:26,090
So all you have to do

00:18:26,090 --> 00:18:29,280
is then Lerna run and then the script name,

00:18:29,280 --> 00:18:33,810
which can be run across all the packages, right?

00:18:33,810 --> 00:18:36,473
Let's see an example of how we can use Lerna.

00:18:37,330 --> 00:18:41,951
So here I have a type script repo of four packages,

00:18:41,951 --> 00:18:43,580
A B, C, and D

00:18:43,580 --> 00:18:45,530
simple packages, nothing complicated.

00:18:45,530 --> 00:18:48,650
It's just a sample that I've just written.

00:18:48,650 --> 00:18:53,540
They all have similar set of scripts in their package.json.

00:18:53,540 --> 00:18:56,574
Here you can see that there are some scripts like prepare,

00:18:56,574 --> 00:19:01,574
watch, like run the build, use webpack and so on.

00:19:02,510 --> 00:19:04,600
You can also see that here package A

00:19:04,600 --> 00:19:07,773
takes a dependency on B and C internally, right?

00:19:09,490 --> 00:19:12,530
Now, if you run Lerna and watch in a panel mode,

00:19:12,530 --> 00:19:13,950
you can see the order

00:19:13,950 --> 00:19:15,920
in which the commands get executed, right?

00:19:15,920 --> 00:19:19,180
So it actually first shows that it executes

00:19:19,180 --> 00:19:22,800
the watch command on C and B packages first,

00:19:22,800 --> 00:19:25,960
and then it runs the watch command on the package A,

00:19:25,960 --> 00:19:27,640
because he takes a dependency on B and C

00:19:27,640 --> 00:19:31,320
and we need to ensure that B and C are compiled first

00:19:31,320 --> 00:19:35,190
and then you can try and like watch on the files

00:19:36,381 --> 00:19:38,160
in the package A.

00:19:38,160 --> 00:19:40,360
So this really solves a lot of pain

00:19:40,360 --> 00:19:43,270
if we need to execute some commands in a certain order.

00:19:43,270 --> 00:19:46,203
And this actually saves a lot of time for us, right.

00:19:47,740 --> 00:19:50,460
One of the other things I really love about Lerna

00:19:50,460 --> 00:19:51,913
is the scoping feature.

00:19:52,750 --> 00:19:56,450
In our monorepo, we use different test dev apps

00:19:56,450 --> 00:19:59,980
for each of the experiences like search people.

00:19:59,980 --> 00:20:01,630
So I worked for the project search,

00:20:01,630 --> 00:20:05,640
so what I need to do is I need to just run commands

00:20:05,640 --> 00:20:09,000
or watch on the code for all the packages

00:20:09,000 --> 00:20:11,370
that mainly pertain to search components, right?

00:20:11,370 --> 00:20:15,820
I don't have to really execute or watch on a components

00:20:15,820 --> 00:20:18,770
that are in people experiences

00:20:18,770 --> 00:20:21,760
if I don't have any dependency on them.

00:20:21,760 --> 00:20:26,350
So, it actually helps us to do quick,

00:20:26,350 --> 00:20:29,660
the validation, during development,

00:20:29,660 --> 00:20:32,573
instead of integrating with a different host apps

00:20:32,573 --> 00:20:33,960
like Sharepoint Office.

00:20:33,960 --> 00:20:36,450
We just use this test dev apps

00:20:36,450 --> 00:20:40,363
to quickly validate our code during development.

00:20:41,220 --> 00:20:45,030
The Lerna scope command allows you to only consider

00:20:45,030 --> 00:20:46,240
a certain set of packages

00:20:46,240 --> 00:20:48,930
instead of the whole monorepo, right?

00:20:48,930 --> 00:20:51,460
So if you define the scope using Lerna run

00:20:51,460 --> 00:20:54,010
and give the scope option,

00:20:54,010 --> 00:20:56,780
and you can give the list of packages

00:20:56,780 --> 00:21:00,003
that you want to scope that are command too.

00:21:01,010 --> 00:21:05,310
So this way it will allow you to scope this commands

00:21:05,310 --> 00:21:06,460
to a certain package.

00:21:06,460 --> 00:21:07,770
It only executes the command

00:21:07,770 --> 00:21:10,550
and one sub part of the dependency tree

00:21:10,550 --> 00:21:12,460
and this actually was a huge

00:21:12,460 --> 00:21:15,120
when for developer productivity.

00:21:15,120 --> 00:21:16,530
Here, you can see,

00:21:16,530 --> 00:21:19,300
we scope the command to package C,

00:21:19,300 --> 00:21:23,060
it only runs for the package C not for any other package.

00:21:23,060 --> 00:21:26,563
So that way it actually says a lot of time for us, right?

00:21:28,160 --> 00:21:31,200
Some of the other very helpful things that Lerna helps us

00:21:31,200 --> 00:21:36,200
was to manage versions, to publish packages,

00:21:36,310 --> 00:21:40,400
to manage releases of these packages really efficiently.

00:21:40,400 --> 00:21:43,530
So it comes with commands like publish,

00:21:43,530 --> 00:21:47,110
especially like some commands like diff and changed

00:21:47,110 --> 00:21:49,840
allow you to closely monitor the change log

00:21:49,840 --> 00:21:52,223
between any two releases very easily.

00:21:53,180 --> 00:21:56,060
Let's look at some of the things that we got out of Lerna.

00:21:56,060 --> 00:22:00,010
So Lerna actually helped us bring down our bill times

00:22:00,010 --> 00:22:01,830
by more than 5x.

00:22:01,830 --> 00:22:06,010
So even our watch times are improved so much

00:22:06,010 --> 00:22:08,770
and we continuously are trying to improve

00:22:09,850 --> 00:22:12,350
how we can in like, for a developer,

00:22:12,350 --> 00:22:16,563
how the productivity is always increased, right?

00:22:17,610 --> 00:22:20,490
Lerna also has a very good community adoption,

00:22:20,490 --> 00:22:22,160
which means it's quite reliable.

00:22:22,160 --> 00:22:25,300
It is adopted by popular JavaScript monorepo like,

00:22:25,300 --> 00:22:28,403
babel, react-router, jest and many more.

00:22:30,500 --> 00:22:32,730
To sum it all up, finally

00:22:32,730 --> 00:22:35,130
pick the right tools for your monorepo,

00:22:35,130 --> 00:22:38,630
if you're going for a TypeScript monorepo,

00:22:38,630 --> 00:22:40,320
you need not necessarily choose the tools

00:22:40,320 --> 00:22:41,440
that we've discussed,

00:22:41,440 --> 00:22:44,910
but based on the complexity of the packages that you have,

00:22:44,910 --> 00:22:47,150
you can improve the developer experience

00:22:47,150 --> 00:22:50,300
and ensure that you're picking the right set of tools

00:22:50,300 --> 00:22:53,850
that are conducive and really usable for your team

00:22:53,850 --> 00:22:56,853
and something that your team feels comfortable with.

00:22:57,837 --> 00:23:01,400
For linting unit or functional and perf testing

00:23:01,400 --> 00:23:04,420
you can always combine it with tools like Lerna

00:23:04,420 --> 00:23:06,373
to easily run commands across packages.

00:23:08,180 --> 00:23:10,290
Additionally, if you're using TypeScript,

00:23:10,290 --> 00:23:11,470
you should remember to ensure that

00:23:11,470 --> 00:23:13,720
you manage TypeScript compilation

00:23:13,720 --> 00:23:16,720
and manage typing generator properly

00:23:16,720 --> 00:23:19,260
so that you can leverage intellisense

00:23:19,260 --> 00:23:23,180
and that also helps in improving deliver productivity

00:23:23,180 --> 00:23:26,900
to basically have a good, robust code

00:23:26,900 --> 00:23:30,203
that can come out of the developers.

00:23:32,060 --> 00:23:34,390
These are some references to all the content

00:23:34,390 --> 00:23:37,590
that I've talked about in the stack.

00:23:37,590 --> 00:23:41,260
One of my friends, Vincent has written a detailed article

00:23:41,260 --> 00:23:46,220
on how we avoid a large mono repository, right.

00:23:46,220 --> 00:23:50,610
So you also have links to Rush, Lerna and yarn workspaces,

00:23:50,610 --> 00:23:53,860
so you can go through it and learn more about them.

00:23:53,860 --> 00:23:55,270
And yeah, so finally,

00:23:55,270 --> 00:23:57,330
thank you, thanks a lot.

00:23:57,330 --> 00:23:58,945
That's all in the talk.

00:23:58,945 --> 00:24:00,000
Thank you very much.

00:24:00,000 --> 00:24:02,960
I really hope this was very helpful for you.

00:24:02,960 --> 00:24:04,580
You can reach out to me on Twitter,

00:24:04,580 --> 00:24:07,560
if you have any questions or perhaps the live Q and A

00:24:07,560 --> 00:24:09,430
that might follow now.

00:24:09,430 --> 00:24:13,510
So reach out to me @jaisanth on Twitter anytime, right?

00:24:13,510 --> 00:24:14,500
Thank you, thank you so much.

00:24:14,500 --> 00:24:15,500
Hope you enjoyed this talk.

00:24:15,500 --> 00:24:17,363

YouTube URL: https://www.youtube.com/watch?v=pTi0MQbD7No


