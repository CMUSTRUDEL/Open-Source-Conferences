Title: Code Factorization: How to Organize Boilerplate Code - Jaewon Seo  - JSConf Korea[Korean language]
Publication date: 2020-10-16
Playlist: JSConf Korea 2020 Home Edition
Description: 
	Boilerplate code (repeatedly used pieces of code) is often the main culprit of unnecessary complexity and cognitive overload in programming. That's why many books and experienced programmers tell us to avoid it, and we try our best by employing all kinds of methods, like inheritance and abstraction.

Despite this constant effort, we often still encounter boilerplate code. Sometimes, we run into 'boss' boilerplate code, which we just don't know how to deal with.

This talk is for those of you who's tired of this endless battle. I will talk about ‘code factorization’, a technique that will help you gain an edge in the war against boilerplate codes. After this talk, you will be able to declare with confidence: veni, vidi, vici.
Captions: 
	00:00:13,546 --> 00:00:14,414
Nice to meet you.

00:00:14,581 --> 00:00:20,453
I am a presenter Seo Jae-won. I prepared a presentation on code factorization, specifically, how to remove boilerplate code.

00:00:20,820 --> 00:00:26,993
Boilerplate code, or repetitive performance code, make it difficult to identify the primary focus of code.

00:00:27,327 --> 00:00:31,498
And it also occupies and distracts programmers.

00:00:31,831 --> 00:00:37,604
That is why so many books and famous programmers advise not to use boilerplate code.

00:00:37,804 --> 00:00:44,611
Programmers try to avoid boilerplate code in all possible ways, including inheritance and abstraction.

00:00:45,812 --> 00:00:51,084
However, even with such constant efforts, we still encounter boilerplate code everyday.

00:00:51,451 --> 00:00:58,825
Sometimes encountering a very complicated "boss" boilerplate code that we have no idea how to solve.

00:00:59,325 --> 00:01:01,861
Aren't you tired of this endless war?

00:01:02,529 --> 00:01:04,230
I prepared for you all,

00:01:04,664 --> 00:01:09,969
some code factorization techniques to win in the war against boilerplate code.

00:01:10,470 --> 00:01:17,510
After the presentation, you will win in the battle against boilerplate code, with new strategies.

00:01:18,044 --> 00:01:21,247
Now, let us straight go for the presentation.

00:01:23,783 --> 00:01:28,855
The really long story of code factorization begins from boilerplate code.

00:01:29,222 --> 00:01:31,157
What is boilerplate code?

00:01:31,324 --> 00:01:34,260
The boilerplate code is code that is used repeatedly.

00:01:34,327 --> 00:01:40,967
If any code is used repeatedly, and appears redundant, it is boilerplate code.

00:01:41,868 --> 00:01:45,171
Let's take a look at some examples.

00:01:46,473 --> 00:01:54,714
Here's a function sum that adds all the numbers of an array, and a function evens that only picks even numbers from the array.

00:01:55,415 --> 00:01:58,518
Can you find the overlapping parts in the code of the two functions?

00:01:59,986 --> 00:02:02,489
I'll change the code to make it easier to understand.

00:02:07,894 --> 00:02:09,696
Now, do you see what they have in common?

00:02:09,896 --> 00:02:16,669
Both functions are iterating the array, performing specific actions, and combining the results with the previous results.

00:02:17,036 --> 00:02:19,305
Boilerplate code here is

00:02:21,074 --> 00:02:23,943
the code that is performing across the array and operation.

00:02:24,310 --> 00:02:28,581
Sum is continuously building up each element of the array by iterating.

00:02:28,948 --> 00:02:33,520
Evens is only storing results of even elements by iterating.

00:02:35,755 --> 00:02:37,390
Here's another example.

00:02:38,258 --> 00:02:42,829
There are functions that start different authentication procedures depending on the type of oAuth

00:02:42,962 --> 00:02:47,433
and functions that return different strings depending on the type of number.

00:02:47,800 --> 00:02:50,904
What is boilerplate code hidden in this code?

00:02:51,504 --> 00:02:55,341
It is the code that investigates the number of cases on one value, separately.

00:02:55,975 --> 00:02:57,410
This is it.

00:02:59,212 --> 00:03:04,951
In terms of signInwithOauth, it performs different authentication procedures depending on possible cases of the type.

00:03:05,084 --> 00:03:07,587
In terms of typeOfNumber, it returns each different string, depending on possible cases of a number,

00:03:07,720 --> 00:03:13,493
for example, being 0, positive, or negative.

00:03:15,461 --> 00:03:19,132
There is one big problem with boilerplate code though.

00:03:19,599 --> 00:03:24,637
It is that boilderplate creates unnecessary cognitive loads.

00:03:24,938 --> 00:03:28,274
Let's discuss more specifically about this.

00:03:35,548 --> 00:03:36,849
What is code?

00:03:37,283 --> 00:03:39,152
The code is the same as the text.

00:03:39,619 --> 00:03:44,357
Just like there's an author for a text, there's a programmer writing the code.

00:03:44,724 --> 00:03:50,763
Just like there's a reader who reads the text, there are programmers and computers that read the code.

00:03:51,231 --> 00:03:55,068
Just like there is a topic in an article that is the main content that the author is trying to deliver,

00:03:55,435 --> 00:03:59,339
A code has interests in problems that the programmer is trying to solve.

00:03:59,472 --> 00:04:04,344
Just like there is a topic for a text, a code has algorithms and concepts

00:04:04,544 --> 00:04:09,315
to solve the problems, thats the approach.

00:04:09,782 --> 00:04:13,519
Code describes how to solve a problem.

00:04:14,354 --> 00:04:16,189
That's how it can deliver messages.

00:04:16,389 --> 00:04:19,259
Bad code is like bad writing.

00:04:19,592 --> 00:04:27,233
Bad code is code that doesn't know how to solve its problems.

00:04:29,135 --> 00:04:36,576
And boilerplate is the main thing that makes bad code. By covering a code's main point, by causing cognitive loads.

00:04:37,877 --> 00:04:41,981
For example, in the example of boilerplate code that we're going to discuss first,

00:04:42,315 --> 00:04:45,251
the interests of each function can be specified as follows:

00:04:45,685 --> 00:04:48,054
First, how to combine the elements

00:04:48,187 --> 00:04:51,057
Second, how to pick even numbers

00:04:51,557 --> 00:04:55,028
Whether it's iterating from the end or from the beginning,

00:04:55,228 --> 00:04:59,666
or by iterator or by index,

00:04:59,899 --> 00:05:02,568
it's not so important for these functions.

00:05:02,635 --> 00:05:05,638
It's not the main factor.

00:05:06,472 --> 00:05:12,712
But if you look at our real code, code for how will it iterate the array,

00:05:12,912 --> 00:05:16,749
has as much code as code that solves our problem.

00:05:17,583 --> 00:05:20,219
As you can see, if you look at the yellow and the green lines,

00:05:21,054 --> 00:05:25,425
the boilerplate code continues to transmit unnecessary information to the programmer,

00:05:25,591 --> 00:05:30,263
and distracting him by causing cognition loads.

00:05:31,264 --> 00:05:35,501
Of course, boilerplate code is not the only thing causing cognitive loads.

00:05:36,269 --> 00:05:39,706
There can be enough other factors, such as grammar of a language.

00:05:40,273 --> 00:05:45,144
Nevertheless, the reason of me relating boilerplate code to cognitive loads is that

00:05:46,079 --> 00:05:51,551
since boilerplate codes distribute unnecessary information throughout code base,

00:05:51,818 --> 00:05:54,721
the share in the entire cognitive loads is significant,

00:05:55,421 --> 00:05:59,258
and most of the codes that cause cognitive loads is actually generic codes.

00:05:59,258 --> 00:06:02,962
It is because they are potentially widely used.

00:06:04,931 --> 00:06:09,736
Then, what are possible ways to remove boilerplate codes?

00:06:10,436 --> 00:06:15,808
Here are five programming paradigms, each with its own interesting approach.

00:06:16,576 --> 00:06:21,681
Firstly, we can remove boilerplate by procedural programming,

00:06:22,115 --> 00:06:24,250
in object-oriented programming, through the object,

00:06:24,484 --> 00:06:26,552
in generic programming, through generics.

00:06:26,552 --> 00:06:28,755
in meta-programming, through macro,

00:06:28,955 --> 00:06:32,892
and, in aspect-oriented programming, through aspect,

00:06:32,892 --> 00:06:34,827
we can remove boilerplate code.

00:06:35,361 --> 00:06:39,198
Let's learn more about object-oriented programming,

00:06:39,432 --> 00:06:42,201
that is the most widely used method in modern programming.

00:06:44,170 --> 00:06:48,541
The approach of object-oriented programming is basically based on data abstraction.

00:06:48,875 --> 00:06:52,745
They abstract programs through a series of data called objects,

00:06:53,079 --> 00:06:56,349
and through inheritance technologies such as class and prototype,

00:06:56,349 --> 00:06:58,684
reuse objects directly or indirectly,

00:06:58,885 --> 00:07:03,856
and increases reuse by allowing an object to be used in many forms., through polymorphism.

00:07:04,424 --> 00:07:06,392
This is a very effective method.

00:07:06,726 --> 00:07:08,795
But there are blind spots, too.

00:07:09,262 --> 00:07:14,834
Clearly, an object-oriented programming approach is very effective in structuring large programs.

00:07:15,067 --> 00:07:23,109
Even the object-oriented programming camp has a very cool program design formula called design patterns.

00:07:23,676 --> 00:07:27,280
But we should pay attention to the fact that, now, the root of object-oriented programming is

00:07:27,280 --> 00:07:32,718
not in computational abstraction, but in data abstraction.

00:07:32,785 --> 00:07:36,656
That's why object-oriented programmings are not so great

00:07:36,656 --> 00:07:38,958
in abstracting operations.

00:07:40,026 --> 00:07:46,032
What are the remaining pieces of the puzzle that will fill the remaining area of computational abstraction, that is the limitations of object-oriented programming?

00:07:47,200 --> 00:07:49,302
That is today's topic.

00:07:50,603 --> 00:07:53,339
And the answer is functional programming.

00:07:53,873 --> 00:07:57,109
Functional programming works in a way that contradicts object-oriented programming.

00:07:57,310 --> 00:08:01,547
It's a paradigm that's rooted in computational abstraction, not in data abstraction.

00:08:01,848 --> 00:08:07,920
It's a paradigm to actively use functions, a concept used to abstract a series of operations.

00:08:08,254 --> 00:08:12,959
It's the rest of the puzzle piece that's going to solve the abstraction of the operation that we're looking for.

00:08:13,559 --> 00:08:17,597
From now on, as a new approach to boilerplate code,

00:08:17,663 --> 00:08:20,466
Let's learn about functional programming.

00:08:23,002 --> 00:08:28,140
The beginning of functional programming is to release the constraints that were placed on the existing function.

00:08:28,808 --> 00:08:32,845
Unlike other program units, such as objects and components,

00:08:32,845 --> 00:08:37,750
there is a limitation that the function is not subject to any operations except calling operations.

00:08:38,184 --> 00:08:41,687
In programming linguistics or our thoughts,

00:08:42,255 --> 00:08:49,061
unlocking this limitation and accepting the function as the object of the calculation is the beginning of functional programming.

00:08:51,063 --> 00:08:56,702
If you remove the previous constraint, you will have new functions called functions that deal with functions.

00:08:57,203 --> 00:09:00,940
In functional programming, it is called higher-order function.

00:09:01,173 --> 00:09:02,375
It's a higher-order function because

00:09:02,375 --> 00:09:08,915
they are a little bit more advanced in terms of dealing with functions, unlike traditional functions that only deal with values.

00:09:09,415 --> 00:09:12,752
Now let's look at some practical examples of these functions.

00:09:14,754 --> 00:09:21,360
First, let's abstract the code that operates calculations by iterating array that we've seen earlier.

00:09:21,694 --> 00:09:27,333
This code is boilerplate code of the sum function and evens function that appeared in the previous example.

00:09:28,501 --> 00:09:32,605
If you look closely at this code, there are three main variables.

00:09:32,772 --> 00:09:39,779
The input array, the calculations to be performed during iteration, and the default result value to be released when the array is empty.

00:09:45,418 --> 00:09:51,090
Actually, the abstraction process is complete as soon as you make these three elements into parameters, as simple as that.

00:09:51,824 --> 00:09:54,727
Since we accepted existence of higher-order function,

00:09:54,727 --> 00:09:58,931
which means that we can now receive calculations, that are, functions,

00:09:59,131 --> 00:10:04,503
it's now possible to leave the partial calculations that make up the huge computations blank.

00:10:05,504 --> 00:10:10,843
With this Loop function, we will try to rewrite the code sum function that was previously in question.

00:10:11,944 --> 00:10:13,045
Yes, this code.

00:10:14,647 --> 00:10:17,316
This is what happens when you rewrite this function.

00:10:17,883 --> 00:10:22,822
As you can see, the interest in how to iterate has been shortened as the following line.

00:10:22,822 --> 00:10:23,823
It's in yellow.

00:10:24,256 --> 00:10:27,393
And the most important interest of sum function,

00:10:27,393 --> 00:10:31,897
that is, "How to keep adding" is the main interest of this code.

00:10:32,064 --> 00:10:33,499
Isn't it much clearer?

00:10:33,733 --> 00:10:34,800
This is the first example.

00:10:35,601 --> 00:10:36,402
And now the next one.

00:10:37,036 --> 00:10:42,174
This time, let's abstract the code that checked the value with a number of cases.

00:10:42,441 --> 00:10:49,248
This code is boilerplate code for signInWithoAuth function and typeOfNumber function that were in the previous example.

00:10:49,682 --> 00:10:55,554
The variable elements of this code are the values to be inspected and the number of cases to be inspected.

00:10:56,489 --> 00:10:59,058
Just like the loop function I just showed,

00:10:59,058 --> 00:11:03,863
we just need to parameterize these two elements, to get abstraction complete.

00:11:04,163 --> 00:11:07,833
But this time, we're going to discuss parameterizing variable elements

00:11:07,833 --> 00:11:10,903
in a different approach.

00:11:11,137 --> 00:11:20,813
Firstly, the number of cases are variable, so are the number of each case.

00:11:20,980 --> 00:11:24,784
For example, a computer has only two states, that are on and off,

00:11:24,784 --> 00:11:28,921
but there are 9 different grades of school.

00:11:29,488 --> 00:11:33,225
As such, the numbers of such cases must be expressed through the parameters.

00:11:33,693 --> 00:11:37,196
Secondly, I would model the number of each case more simply.

00:11:37,463 --> 00:11:40,833
In this boilerplate code, the number of cases were modeled as objects,

00:11:40,833 --> 00:11:45,004
to express the identification as a test method, and the calculation to operate to operation method,

00:11:45,004 --> 00:11:49,308
but for the simpler code, let me express the number of cases as a tuple instead of an object,

00:11:49,308 --> 00:11:54,480
and place the test method as the first element, and the operation method as the second element.

00:11:54,480 --> 00:11:59,418
Lastly, the first two aren't important due to the UX problem,

00:11:59,418 --> 00:12:03,422
but the final problem is what I want to tell you the most, in the second example.

00:12:04,323 --> 00:12:09,161
Lastly, we should separate the time when we receive a value to investigate, from when we receive the number of cases.

00:12:09,295 --> 00:12:14,133
As we've seen earlier, the places where codes are used to investigate the value with the number of cases

00:12:14,133 --> 00:12:20,439
are mostly the places where you only know how the numbers are divided, not what values actually came in.

00:12:20,673 --> 00:12:27,780
Therefore, we will split the operation in half, and receive the number of cases first,and then, receive the value to investigate.

00:12:30,750 --> 00:12:32,818
Now, let's look at the code. 이제 코드를 한 번 보도록 하겠습니다.

00:12:33,819 --> 00:12:34,787
This is the code. 바로 이 코드인데요.

00:12:35,087 --> 00:12:36,122
Isn't it so simple? 간단하지 않나요?

00:12:36,422 --> 00:12:41,961
We receive multiple cases as variable variables, 여기 가변 변수로 여러가지 경우의 수를 받고

00:12:42,061 --> 00:12:45,197
and as going into loop when the price comes in,

00:12:45,197 --> 00:12:51,170
check the number of cases, and if a function that occupies the position of the test method called that predicate,

00:12:51,170 --> 00:12:54,340
returns true, it's a simple code that executes the operation.

00:12:54,840 --> 00:13:00,646
Let's use this function to rewrite the previous typeOfNumber function.

00:13:07,319 --> 00:13:09,255
It's written as follows.

00:13:10,489 --> 00:13:12,925
It looks much clearer.

00:13:13,192 --> 00:13:15,895
The number of cases and the operation of them are seen at a glance.

00:13:26,305 --> 00:13:28,874
I just gave you some time to think about it.

00:13:28,874 --> 00:13:31,911
Is there anyone here who has the same question as I do?

00:13:32,244 --> 00:13:37,149
If you look closely at the new code, the calculations that produce constants look very similar.

00:13:37,550 --> 00:13:39,952
Which is called?

00:13:40,419 --> 00:13:42,121
Yes, boilerplate code!

00:13:42,488 --> 00:13:45,224
The boilerplate code should be removed.

00:13:45,524 --> 00:13:51,163
This code can be removed simply through the function that receives the constant as shown above, and returns the constant,

00:13:51,263 --> 00:13:53,632
that is, the function called constant.

00:13:54,300 --> 00:13:54,834
Good.

00:13:55,000 --> 00:13:56,535
It's much more satisfactory.

00:13:58,003 --> 00:14:02,474
For the next, we're going to look at a slightly unusual higher-order function.

00:14:02,675 --> 00:14:07,646
Firstly, suppose there are three values, A, B, and C.

00:14:08,047 --> 00:14:11,984
And a function f that makes the value A the value B,

00:14:13,385 --> 00:14:17,990
and a function g that makes the value B the value C.

00:14:19,258 --> 00:14:23,062
If you describe these elements in code, it will be as follows.

00:14:24,763 --> 00:14:28,868
Since value A is unknown, the variable x,

00:14:29,201 --> 00:14:32,104
and the function f, because calculation is the only thing we need,

00:14:32,104 --> 00:14:34,506
can simply be a function to add 1.

00:14:35,307 --> 00:14:38,310
If so, B is x+1.

00:14:38,777 --> 00:14:42,815
g, just like f, can be a function to simply add 2.

00:14:43,282 --> 00:14:46,318
c can be x+1+2.

00:14:47,019 --> 00:14:53,292
However, here, x+1+2 is the same as x+3, as you already know.

00:14:55,361 --> 00:14:59,899
If so, we can learn that there is the function h to add 3,

00:14:59,899 --> 00:15:02,902
between value A and C.

00:15:04,270 --> 00:15:14,446
And in terms of the function h adds 3, as we saw in inducing the function h,

00:15:14,446 --> 00:15:18,550
can also be represented as the function f and the function g.

00:15:19,985 --> 00:15:24,690
If you apply the f to A first, and then apply the g again to B that's obtained previously,

00:15:24,690 --> 00:15:27,660
you can get C from A, just like the h.

00:15:28,894 --> 00:15:34,733
Based on this, assume a function pipe that represents different functions with 2 functions,

00:15:34,900 --> 00:15:39,338
we can represent the function h as pipe(f, g).

00:15:40,606 --> 00:15:43,642
That is, representing big functions through small functions.

00:15:44,310 --> 00:15:48,080
This cool function is often used in combining or connecting functions

00:15:48,080 --> 00:15:52,384
in functional programming.

00:15:52,851 --> 00:15:55,821
When you actually implement this function, it's as follows.

00:15:58,657 --> 00:16:02,761
Let me show you an example of the real case that used this function.

00:16:03,028 --> 00:16:09,868
For example, by applying a function to each value in the array as shown below,

00:16:09,868 --> 00:16:15,708
we can create function values

00:16:16,075 --> 00:16:20,813
to get the value of every property of an object,

00:16:21,313 --> 00:16:25,617
by combining Object.entries function through pipe function.

00:16:25,684 --> 00:16:29,955
Let me briefly explain how these values function works.

00:16:32,624 --> 00:16:36,729
Firstly, we can deliver the object to get the value.

00:16:37,196 --> 00:16:40,666
The value functions are as follows.

00:16:40,799 --> 00:16:44,103
It's like the pipe(Object.entries, map(snd)).

00:16:44,203 --> 00:16:46,505
It's just like definition of the values.

00:16:48,340 --> 00:16:52,578
And we're going to change the pipe function back to the actual code here.

00:16:52,578 --> 00:16:56,782
If you reduce the pipe, it will become as follows.

00:17:02,454 --> 00:17:08,894
You can imagine the actual codes in each variable of the body in the pipe function.

00:17:10,396 --> 00:17:14,800
And let's implement Object.entries in our head here.

00:17:15,234 --> 00:17:19,838
Then, the entry of the properties come out as follows, right?

00:17:20,806 --> 00:17:23,742
And lastly, oh, not lastly yet,

00:17:23,742 --> 00:17:27,279
Let's iterate the map with the original code.

00:17:28,514 --> 00:17:36,922
Yes, the f is changed to the snd function, and the array is changed to the array.map (snd) code.

00:17:37,389 --> 00:17:43,695
To this point, calculation can be operated by filling the map function with snd function.

00:17:44,496 --> 00:17:47,099
Let me shorten this code again.

00:17:48,133 --> 00:17:52,371
The function that receives the array, and applies the map to the array,

00:17:52,371 --> 00:17:55,674
and since the array was given with that entry,

00:17:55,674 --> 00:17:57,776
it can provide the code as follows.

00:17:58,043 --> 00:18:01,580
And from now on, those who used JavaScript a lot will find it so familiar.

00:18:02,047 --> 00:18:08,921
The snd function is now applied to each element in the array, it gets 2 and 23 as the values.

00:18:09,655 --> 00:18:11,256
We got the values.

00:18:11,757 --> 00:18:14,960
What do you think? Isn't it so beautifully simple?

00:18:15,561 --> 00:18:22,634
It was the pipe function that connects different functions, that is, it helps to easily reuse small functions by combining them.

00:18:24,803 --> 00:18:31,543
The function that we're going discuss now looks very insignificant.

00:18:31,643 --> 00:18:35,013
It's a function that simply returns the given value.

00:18:35,948 --> 00:18:39,651
But this function, surprisingly, is considered one of the greatest and most important functions,

00:18:39,751 --> 00:18:45,257
along with the pipe mentioned earlier, in functional programming.

00:18:45,757 --> 00:18:52,531
It may be hard to believe, but it's a function of great value, both theoretically and practically.

00:18:53,665 --> 00:19:00,272
In fact, just by discussing this function, I could spend my entire presentation time that's given.

00:19:00,472 --> 00:19:04,143
But we don't enough have time for that, and it's very complicated,

00:19:04,309 --> 00:19:07,079
so I'll just give you one practical example.

00:19:08,013 --> 00:19:13,018
This identity function is the same as 0 in addition, and 1 in multiplication.

00:19:13,318 --> 00:19:17,489
If any function is associated with this function, the result is always that function.

00:19:17,723 --> 00:19:22,728
If you combine any function with this identity function, it's supposed to be the same function.

00:19:23,462 --> 00:19:26,431
I'll show you that here.

00:19:28,033 --> 00:19:35,240
Here's the pipe code that combines the two functions, the f and the identity.

00:19:35,874 --> 00:19:40,279
This code replaces the pipe function with the actual code:

00:19:44,249 --> 00:19:51,256
And here, when you replace this identity function with the actual code, it changes as follows.

00:19:56,295 --> 00:20:00,899
Then the arrow function that goes from x to x that follows,

00:20:00,899 --> 00:20:04,469
and then you will see this after focusing on the part to apply the value f(x) on that,

00:20:04,803 --> 00:20:09,675
and shortening the code by removing unnecessary parts of this part.

00:20:12,744 --> 00:20:17,115
And lastly, this code will be the f, back again.

00:20:17,983 --> 00:20:24,523
The function that takes a value, executes the f with the value, and produces the result is, in fact, no different than the f.

00:20:24,790 --> 00:20:26,592
It was just a cover.

00:20:27,526 --> 00:20:30,462
Why is this trivial feature so important?

00:20:30,796 --> 00:20:36,034
It's because, thanks to this feature, the identity function can act like the default function.

00:20:36,635 --> 00:20:42,441
As you've seen so far, functional programming brings together small operations to form a large operation.

00:20:42,741 --> 00:20:48,780
They can continue the operation with such as the pipe, or they can fill in the remaining blanks with the higher order function.

00:20:49,414 --> 00:20:54,519
But sometimes I don't really want to fill in the blanks of some higher-order functions.

00:20:54,519 --> 00:20:58,156
Indeed, I sometimes want to leave some blanks as they are, in such a huge higher-order function.

00:21:00,425 --> 00:21:05,564
In other words, in some ways, you might want to take some basic actions.

00:21:06,431 --> 00:21:10,369
Especially when that part has nothing to do with our interests.

00:21:11,103 --> 00:21:15,307
In this case, the identity function acts as a basic action.

00:21:16,141 --> 00:21:21,580
What's so useful about it is that, when you abstract a function,

00:21:21,580 --> 00:21:27,619
it lets you drill through the blanks while also making it easier to build up the function without having to worry about not using it.

00:21:28,453 --> 00:21:30,555
Let me show you a practical example.

00:21:32,090 --> 00:21:39,631
The bimap function that I'm going to show you now is a function that maps a function to each field by receiving two functions and the tuple,

00:21:40,265 --> 00:21:43,902
and it abstracts the operation that applies a function to the tuple.

00:21:44,436 --> 00:21:49,975
This function is a function that receives a function, and maps the function only to the first field of the tuple.

00:21:50,075 --> 00:21:51,610
It's also called the mapFst function.

00:21:53,645 --> 00:21:57,516
The two are very similar functions, both conceptually and formally.

00:21:58,317 --> 00:22:06,358
If you remove the g and the g(y) code from the bimap, it becomes the mapFst function.

00:22:07,292 --> 00:22:10,929
But it doesnt seem possible to use bimap

00:22:10,929 --> 00:22:13,732
to create the mapFst function.

00:22:14,032 --> 00:22:18,470
But with the identity function, you can do this very simply.

00:22:19,805 --> 00:22:21,873
You can change it like this.

00:22:23,175 --> 00:22:29,014
If you just give the body of the bimap function the f and the tuple to make the mapFst function,

00:22:29,014 --> 00:22:35,153
there will still be blanks in the function, with the unfilled parameters left, which makes it a function with blanks on the body.

00:22:35,787 --> 00:22:40,258
If you implement it, you'll be scolded by what's called Runtime Error.

00:22:41,059 --> 00:22:46,331
But if you add a function called identity that builds up a function,

00:22:46,431 --> 00:22:49,768
as the identity function fills the blanks,

00:22:50,435 --> 00:22:54,139
you can create a whole mapFst function with the bimap function.

00:22:55,073 --> 00:23:02,013
As being a basic function, when you build a function, or drill a hole in the function,

00:23:02,013 --> 00:23:08,487
it reduces concerns like, "Oh, I don't think I'm going to use it again." That's why it is a very valuable function.

00:23:11,423 --> 00:23:17,996
I'd like to discuss how to look at a function from a variety of perspectives rather than introducing a function.

00:23:18,630 --> 00:23:19,431
Currying is

00:23:19,664 --> 00:23:23,068
a method of expressing a multiple arguments function as a column of a singular arguments function.

00:23:23,468 --> 00:23:29,875
To put it more simply, currying was created by splitting arguments, and is a way of expressing a function.

00:23:30,609 --> 00:23:32,244
Let me give you a simple example.

00:23:32,711 --> 00:23:35,847
These are the two multiple arguments functions.

00:23:36,014 --> 00:23:40,986
If you curry this function, the two arguments split as follows.

00:23:41,319 --> 00:23:43,155
You'll receive arguments multiple times.

00:23:44,222 --> 00:23:47,793
The following are two main reasons for using currying.

00:23:48,226 --> 00:23:51,963
Firstly, it allows you to see the function from multiple angles.

00:23:52,264 --> 00:23:59,438
Secondly, it makes it easier to perform techniques to fill in blanks with parameters of a function called partial application.

00:23:59,905 --> 00:24:03,041
However, the first one is what we should pay attention to.

00:24:03,575 --> 00:24:09,448
The second one is not only in the extension of the first one, but also because the first one is so powerful,

00:24:10,048 --> 00:24:15,787
in order to spend our remaining time as valuable as possible, we should definitely focus on the first one.

00:24:16,354 --> 00:24:20,992
If you're curious about the second advantage, you can ask me later, or look it up yourself.

00:24:21,259 --> 00:24:23,995
So let's skip it for now.

00:24:25,330 --> 00:24:32,904
So here's the function map that applies a function to each element in the array, and returns the result.

00:24:33,371 --> 00:24:37,742
This function is actually very familiar to who use modern JavaScript.

00:24:38,543 --> 00:24:43,281
And now the function Array.prototype.map that you're familiar with is just the one did wrapping.

00:24:44,516 --> 00:24:48,019
Since objects that execute methods can also be viewed as parameters,

00:24:48,453 --> 00:24:50,922
the function that makes this explicit is this one.

00:24:51,590 --> 00:24:58,196
If you change the order of the parameters of this function, and do currying on the function, the function called lift comes out, as shown as follows.

00:24:59,264 --> 00:25:03,768
It's safe to say that the two functions are functionally matched.

00:25:04,236 --> 00:25:08,607
And yet, the reason I've distinguished these two functions in name is because

00:25:08,673 --> 00:25:12,677
the interpretation and meaning of the role of the functions varies.

00:25:12,978 --> 00:25:16,748
Let me show you an example of the changed use of the lift function.

00:25:18,416 --> 00:25:22,487
So here's the not function that negates the given value.

00:25:22,687 --> 00:25:25,724
In short, it is the functional version of the not operator.

00:25:26,324 --> 00:25:30,896
Apply the lift function to this function to create a function called liftedNot.

00:25:31,429 --> 00:25:32,264
Like this.

00:25:33,865 --> 00:25:35,834
What are the differences between these two functions?

00:25:36,268 --> 00:25:40,839
Yeah, it's just that, while the not denies only one given value,

00:25:40,839 --> 00:25:45,143
the liftedNot performs a negative operation on all elements of the given array.

00:25:45,510 --> 00:25:47,445
In terms of type, it's as follows.

00:25:47,846 --> 00:25:53,351
The not goes from boolean to boolean, and the liftedNot goes from array Boolean to array Boolean.

00:25:55,820 --> 00:25:58,423
Now, do you see everything at a glance?

00:25:59,124 --> 00:26:03,428
A function that worked on a simple value has become a function that works on an array.

00:26:04,596 --> 00:26:05,997
Through the lift function.

00:26:06,398 --> 00:26:10,602
It's that the lift function lifted the given function to the array function.

00:26:11,336 --> 00:26:18,343
What do you think? We just split the arguments, and changed the order of the function, but its meaning has changed a lot, right?

00:26:18,777 --> 00:26:26,117
Firstly, just applying the function to each element of an array, and to apply a function to an array that returns the result,

00:26:26,484 --> 00:26:32,991
but after a slight conversion with currying, it became a function to lift a function for a simple value, to one for an array,

00:26:32,991 --> 00:26:35,126
that is, the higher level function.

00:26:35,627 --> 00:26:37,662
This is the power of currying.

00:26:37,929 --> 00:26:41,066
What lets us see the same function from a different point of view,

00:26:41,066 --> 00:26:44,336
to give different meanings.

00:26:46,905 --> 00:26:50,842
So far, we've been discussing the basic ideas of functional programming

00:26:50,842 --> 00:26:53,612
that can help removing boilerplate code.

00:26:54,346 --> 00:26:59,718
In addition to the pipe, the identity, and currying that I introduced earlier,

00:26:59,951 --> 00:27:06,725
functional programmers have come up with beautiful and really wise concepts through their consideration of functions.

00:27:06,791 --> 00:27:10,729
Unfortunately, due to the limited time today, I can't introduce all of those concepts.

00:27:10,929 --> 00:27:15,266
but those of you who are curious about it, I'd like to briefly introduce some of the deeper concepts.

00:27:15,700 --> 00:27:17,035
Firstly, Y Combinator.

00:27:17,268 --> 00:27:22,273
Y Combinator is a non-recursive function that makes a given function a recursive function.

00:27:22,540 --> 00:27:25,610
It sounds really contradictory.

00:27:26,011 --> 00:27:30,515
This function lets us think deeply about the nature of recursion,

00:27:30,749 --> 00:27:34,319
that is, inductive thinking.

00:27:34,486 --> 00:27:38,657
If you really want to understand recursions well,

00:27:38,890 --> 00:27:41,993
I strongly recommend you to look it up.

00:27:42,661 --> 00:27:43,695
The next one is functor.

00:27:44,195 --> 00:27:48,700
Functor is the same as the lift function that was previously discussed in currying.

00:27:48,700 --> 00:27:55,907
The technique of lifting a given general function to a function for a data structure is called lifting.

00:27:56,508 --> 00:28:00,845
The concept of abstracting these lifting types is called functor.

00:28:01,146 --> 00:28:05,684
Those of you who think it's cool to introduce with a function,

00:28:05,850 --> 00:28:08,119
might want to look up for functor.

00:28:08,553 --> 00:28:10,088
The next one is monad.

00:28:10,822 --> 00:28:14,492
Monad is a concept that abstracts operations that can be combined.

00:28:14,659 --> 00:28:18,997
It's actually a concept that's too hard for me to explain simply.

00:28:19,464 --> 00:28:25,170
But I'd like to introduce you to this concept because once you've studied it,

00:28:25,437 --> 00:28:30,041
you will have a really deep insight into how to deal with operations

00:28:30,642 --> 00:28:35,313
including what is an operation, how to handle it, and how to define it.

00:28:35,680 --> 00:28:39,718
And also, this is the technology that works the most,

00:28:39,718 --> 00:28:42,153
in functional programming, to remove boilerplate code.

00:28:42,420 --> 00:28:47,992
Now, if you want to study more about removing boilerplate code using functional programming,

00:28:47,992 --> 00:28:50,595
I recommend you to look up this concept.

00:28:51,196 --> 00:28:53,198
The final concept is called optics.

00:28:53,331 --> 00:29:00,038
Optics is a concept about the relationship between an arbitrary structure and the part that can be derived from it.

00:29:00,238 --> 00:29:04,576
The fields and accessors of objects can also be explained through this concept.

00:29:05,210 --> 00:29:08,513
I'm not sure if anyone has heard of lens.

00:29:08,646 --> 00:29:11,282
The concept of lens is also a part of optics.

00:29:11,816 --> 00:29:18,123
So now, if you want to get both insight for structured data and for calculation,

00:29:18,123 --> 00:29:20,825
I strongly recommend you to take look up for this concept.

00:29:21,960 --> 00:29:25,730
I've attached good materials to the slides.

00:29:25,730 --> 00:29:30,435
So, i you want to study this concept, I recommend you to download the slides when they are released.

00:29:31,202 --> 00:29:37,308
And I didn't write it down because it had nothing to do with boilerplate code, but it's a good topic to learn about.

00:29:37,308 --> 00:29:41,579
There are basic concepts of functional programming, such as 'pure function' and 'partial application'.

00:29:41,813 --> 00:29:45,250
If you're curious about functional programming, you can take a look at them.

00:29:46,284 --> 00:29:51,623
So, that's all for today.

00:29:51,890 --> 00:29:58,163
From now on, we will wrap up the presentation by looking at what we discussed today.

00:29:59,130 --> 00:30:02,300
First of all, we discussed boilerplate code.

00:30:02,467 --> 00:30:04,702
Boilerplate code is repetitive.

00:30:05,603 --> 00:30:09,040
And it had some problems,

00:30:09,240 --> 00:30:11,476
which is, causing unnecessary cognitive loads.

00:30:12,510 --> 00:30:17,749
And we've discussed a number of ways, including object-oriented programming.

00:30:18,149 --> 00:30:24,255
But there were limitations, and we discussed functional programming with a new approach to solve those limitations.

00:30:24,589 --> 00:30:28,259
I introduced you to the idea of the higher-order functions in functional programming.

00:30:28,660 --> 00:30:34,065
Also, the pipe function that connects functions, and the special function called identity.

00:30:34,065 --> 00:30:38,770
Lastly, I introduced currying, a way to see functions from different point of views.

00:30:39,871 --> 00:30:42,941
That's all I discussed today.

00:30:43,575 --> 00:30:48,813
Lastly, I'd like to conclude as follows.

00:30:49,147 --> 00:30:55,453
In this presentation, we briefly looked at how we could access boilerplate code through functional programming.

00:30:55,753 --> 00:31:01,092
An approach based on the idea of splitting an operation into smaller pieces as a function for functional programming

00:31:01,292 --> 00:31:09,500
can be complementary to an idea of dividing the program of the object-oriented programming into objects.

00:31:10,235 --> 00:31:13,204
There are two main ways to solve the quadratic equation.

00:31:13,438 --> 00:31:18,543
One is to factorize the quadratic formula, and the other is to use the quadratic formula.

00:31:18,910 --> 00:31:21,546
Do you have any idea which is better?

00:31:22,847 --> 00:31:25,383
Of course, the answer is 'unanswerable'.

00:31:25,717 --> 00:31:28,319
The method of dispensing a quadratic equation is

00:31:28,319 --> 00:31:33,291
very effective when the given equation is really easily subdivided and easily subdivided through the formula.

00:31:33,758 --> 00:31:39,397
Just by a few operations to divide by integers, it can quickly determine the two values, that are, the roots.

00:31:39,898 --> 00:31:47,138
However, if the given formula is not easily subdivided, or if the two roots are imaginary ones, it won't be so efficient.

00:31:47,572 --> 00:31:53,478
Since you have to deal with numbers in a wider range than the integer, even a few calculations will be very complicated.

00:31:53,711 --> 00:32:01,920
The quadratic formula, on the other hand, is much easier to solve because you just need to put numbers in a fixed frame.

00:32:02,086 --> 00:32:06,024
But since the fixed frame is basically not small in size,

00:32:06,157 --> 00:32:11,095
it will be a little inconvenient to use this method, even when it can be easily solved by the factorization.

00:32:12,297 --> 00:32:15,033
The same goes for the functional programming and the object-oriented programming.

00:32:15,266 --> 00:32:18,336
Both can be used to fix boilerplate code.

00:32:18,636 --> 00:32:23,508
Both the functional programming and the object-oriented programming prevail, depending on situations.

00:32:25,543 --> 00:32:28,713
There is a saying, 'A good craftsman never blames their tools.'

00:32:28,846 --> 00:32:35,820
It can be interpreted as 'A talented person can work with any tools,' but it can be interpreted a little differently.

00:32:36,287 --> 00:32:37,622
Like this.

00:32:38,222 --> 00:32:41,592
'A talented person only uses tools that fit the situation.'

00:32:42,226 --> 00:32:50,101
As programmers who solves problems, rather than sticking to only one method,

00:32:50,101 --> 00:32:55,673
we should learn all the tools , and use them in the right place.

00:32:56,941 --> 00:33:00,411
So I'd like to say one last thing to you.

00:33:00,545 --> 00:33:02,747
Let's all be craftsmen.

00:33:03,014 --> 00:33:05,283

YouTube URL: https://www.youtube.com/watch?v=Urj-aaxB6mE


