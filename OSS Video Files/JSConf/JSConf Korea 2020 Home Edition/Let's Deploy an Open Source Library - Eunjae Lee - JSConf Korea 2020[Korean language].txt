Title: Let's Deploy an Open Source Library - Eunjae Lee - JSConf Korea 2020[Korean language]
Publication date: 2020-10-14
Playlist: JSConf Korea 2020 Home Edition
Description: 
	Deploying an open source library can be scary. You anxiously stare at the screen hoping that it'll be a success, that you didn't make any mistakes. There are many tools that can ease your worries, but perhaps can't eliminate them.

So I present to you a new process for deploying open source libraries. This process dramatically reduces the likelihood of making mistakes, and most of the process will happen asynchronously, allowing you to review with your teammates before deployment. I will also introduce Ship.js, a tool created for this purpose. With this newly defined process, let's continuously deploy our open source libraries without fear!
Captions: 
	00:00:13,213 --> 00:00:17,083
Yes hello! Let's deploy an open source library.

00:00:18,618 --> 00:00:20,787
My name is Eunjae Lee

00:00:21,588 --> 00:00:26,159
I was born in Korea and grew up there

00:00:26,626 --> 00:00:29,662
I moved to Singapore at the end of 2016

00:00:29,996 --> 00:00:35,735
And in 2019, I moved to France and I've been living here ever since.

00:00:36,803 --> 00:00:40,407
In France, I work for a company called Algolia.

00:00:40,774 --> 00:00:45,945
Algolia is a cloud service provider that provides search functionality.

00:00:46,379 --> 00:00:53,119
They provide a full suite of toolkits for developers

00:00:54,721 --> 00:00:56,089
In Algolia

00:00:56,856 --> 00:01:00,660
The brief description is

00:01:01,361 --> 00:01:06,966
The backend such as infrastructure, engines, databases, etc.

00:01:07,567 --> 00:01:10,070
On top of that is the REST API

00:01:10,770 --> 00:01:18,511
There are APIs in charge of indexing or search functions, for example.

00:01:20,180 --> 00:01:25,051
API clients are provided on top of that REST API.

00:01:26,152 --> 00:01:31,558
PHP, Ruby, JavaScript, Python, Kotlin, .NET

00:01:31,558 --> 00:01:35,595
Java, Golang, Scala, iOS, are Android

00:01:35,595 --> 00:01:40,400
are some of the languages in which you can use the API client.

00:01:41,534 --> 00:01:48,875
And on top of the JavaScript API client, we developed something called Instant Search

00:01:48,875 --> 00:01:53,980
You can think of it as a kind of JavaScript component library.

00:01:55,081 --> 00:02:01,988
The user can directly call the search API using the API client.

00:02:01,988 --> 00:02:05,725
Instead of displaying the results directly,

00:02:06,126 --> 00:02:14,701
you just have to attach the components that we provide for the website or app to be complete.

00:02:14,701 --> 00:02:18,304
For example, there are components for 

00:02:18,304 --> 00:02:21,207
a search bar, filter, pagination, and so on.

00:02:22,509 --> 00:02:28,815
So, I'm working on this JavaScript component library

00:02:29,883 --> 00:02:32,752
called Instant Search.

00:02:32,752 --> 00:02:35,688
I work on its team.

00:02:35,989 --> 00:02:45,865
So this team develops the InstantSearch.js vanilla JS library, but

00:02:46,032 --> 00:02:54,274
we are developing Instant Search in 4 flavors total, including React, Vue, and Angular.

00:02:54,274 --> 00:03:03,249
And I am developing and maintaining many other libraries.

00:03:05,718 --> 00:03:09,255
Coding seems to be loved by everyone.

00:03:09,255 --> 00:03:17,163
I don't think there are many people listening to the presentation that hate coding.

00:03:18,298 --> 00:03:21,034
They code at work

00:03:21,034 --> 00:03:27,874
Also, many people will like to do side projects at home after work and on weekends.

00:03:29,209 --> 00:03:35,114
And testing and debugging are pretty popular.

00:03:35,114 --> 00:03:40,920
In particular, the test was done with TDD or other ways

00:03:41,187 --> 00:03:47,860
There are people who are very passionate about this topic

00:03:48,261 --> 00:03:57,203
And rather than saying that I just like debugging itself, its the feeling when a bug is removed

00:03:57,203 --> 00:04:03,243
There are such joys, so it seems that many people like testing and debugging.

00:04:04,777 --> 00:04:10,216
But is there anyone who likes deploying?

00:04:10,216 --> 00:04:11,718
I Like deploying

00:04:11,951 --> 00:04:17,123
Well I love deployment. I will deploy it on the weekend.

00:04:17,123 --> 00:04:21,828
I will deploy on Friday evening. I don’t think I’ve heard anything like this.

00:04:21,828 --> 00:04:29,369
Especially when it comes to deploying libraries, it seems to get worse.

00:04:31,104 --> 00:04:34,274
First, before talking about libraries,

00:04:34,774 --> 00:04:37,543
let’s talk a little bit about app deployment.

00:04:37,877 --> 00:04:44,651
Many people now use CI/CD services to deploy apps.

00:04:44,651 --> 00:04:47,086
Just to name a few, we have

00:04:47,320 --> 00:04:56,763
Netlify, Vercel, Bamboo Jenkins, etc.--there are many CI/CD services.

00:04:56,763 --> 00:05:04,537
Since those people use a lot of these tools to deploy,

00:05:05,972 --> 00:05:11,711
But I think that deploying libraries in particular is a little less enjoyable.

00:05:13,946 --> 00:05:22,021
There are many reasons, but I'll just give you a few reasons I can think of.

00:05:23,523 --> 00:05:25,692
First, we're worried about bugs

00:05:26,159 --> 00:05:31,597
Once deployed, the bug is also deployed.

00:05:32,165 --> 00:05:37,670
Unlike apps, in the case of libraries,

00:05:37,704 --> 00:05:40,306
even if you deploy a fix

00:05:40,306 --> 00:05:44,444
the user has to update the library again.

00:05:44,444 --> 00:05:50,249
So it takes one more steps than an app, so I think we're more concerned about bugs.

00:05:51,017 --> 00:05:54,554
But now I can't help you with that part.

00:05:54,554 --> 00:06:00,193
Concerns about bugs can be solved only if you don't have a bug

00:06:00,660 --> 00:06:03,396
To ensure that, you have to write good code

00:06:03,663 --> 00:06:09,702
Also, to catch errors, you have to write good test cases,

00:06:10,002 --> 00:06:15,942
so that, even if something goes wrong, we can find the error.

00:06:15,942 --> 00:06:21,013
You need to have a system that monitors certain errors and exceptions.

00:06:21,381 --> 00:06:27,720
But that is completely outside the scope of my presentation

00:06:27,720 --> 00:06:33,159
Let's say that I can't help you with that, and let's ignore it.

00:06:34,427 --> 00:06:40,266
After that, I think we worry a lot about mistakes

00:06:40,533 --> 00:06:46,606
There are various mistakes, such as using the wrong version of NodeJS.

00:06:48,174 --> 00:06:51,844
Though there are many Node version managers,

00:06:51,844 --> 00:06:59,552
sometimes when we go back and forth between several projects,

00:07:00,052 --> 00:07:04,157
These kinds of problems definitely exists.

00:07:06,058 --> 00:07:10,229
And what we often forget is that

00:07:10,229 --> 00:07:12,999
if you forget to `git pull`

00:07:13,866 --> 00:07:18,504
it would be a fatal mistake to deploy the old version.

00:07:19,739 --> 00:07:24,243
Or you may be deploying with the command `npm publish`

00:07:25,578 --> 00:07:32,752
but if you forget the argument of `--tag beta` and deploy it

00:07:32,752 --> 00:07:38,858
It would be a big mistake. You'd be deploying it as a stable version rather than the beta.

00:07:39,692 --> 00:07:46,632
And I don't know how everyone feels about this folder called `node_modules`.

00:07:47,633 --> 00:07:55,541
We don't think we did anything wrong, but problems arise.

00:07:55,541 --> 00:08:02,348
That happened a few times for me, so I'd delete this folder and call `npm install`

00:08:02,348 --> 00:08:06,853
or `yarn install` again.

00:08:08,321 --> 00:08:14,360
Another problem is the wait.

00:08:15,661 --> 00:08:26,506
If you run lint, unit tests, and even end-to-end tests, you have to wait until everything finishes

00:08:27,807 --> 00:08:35,348
This screen shows an end-to-end test for Instant Search JS

00:08:35,348 --> 00:08:37,583
In fact, for an end-to-end test

00:08:37,950 --> 00:08:43,823
4min 30sec can be seen as not much, pretty short.

00:08:44,624 --> 00:08:49,929
However, though you might think that 4min 30sec is not long,

00:08:49,929 --> 00:08:54,667
while waiting, even just 5 to 10 seconds,

00:08:55,234 --> 00:09:00,172
at least in my case I lose my patience and immediately hit command + tab

00:09:00,339 --> 00:09:06,879
and go to Twitter, scroll for about 10 to 15 minutes before I remember I was running a test

00:09:07,280 --> 00:09:12,552
and when I check back, the test would already be over. This happens often.

00:09:12,552 --> 00:09:17,890
In the process of switching between contexts

00:09:18,224 --> 00:09:21,527
time and energy are lost

00:09:22,395 --> 00:09:24,463
Another way to wait

00:09:24,897 --> 00:09:33,039
Now it takes time to run lint or tests to deploy from your base branch.

00:09:33,039 --> 00:09:39,645
But during that time we might want to move to another branch

00:09:39,645 --> 00:09:44,116
and work on that branch, but that's risky.

00:09:44,116 --> 00:09:48,688
It's safe to just leave that folder in its base branch

00:09:48,688 --> 00:09:54,393
Because there is a risk of something going wrong, so we try not to touch it

00:09:54,393 --> 00:09:57,296
and just wait and wait.

00:10:02,168 --> 00:10:05,171
So now let's take a look at

00:10:05,738 --> 00:10:11,777
what kind of process we usually go through when deploying a library.

00:10:12,578 --> 00:10:23,189
The versions are named using the convenstion semver, which stands for semantic version.

00:10:23,422 --> 00:10:29,462
The first number is the major, then the minor, the patch, and so on.

00:10:30,262 --> 00:10:38,537
When deploying a library, it's important to decide what the next version will be, according to the convention.

00:10:39,538 --> 00:10:44,644
Then there is an idea called Conventional Commit.

00:10:45,378 --> 00:10:48,147
There is a website called Conventional Commit.

00:10:48,547 --> 00:10:55,388
You can visit the website to get more details but for example, there could be a commit message like this.

00:10:55,755 --> 00:11:03,029
The prefix 'fix' means that this commit fixes something.

00:11:03,029 --> 00:11:09,001
The part after the colon describes the actual commit.

00:11:09,735 --> 00:11:20,379
Writing 'fix(compiler)' defines the compile as the scope of the fix.

00:11:20,546 --> 00:11:26,552
So to repeat, this commit is a commit that fixes something

00:11:26,552 --> 00:11:32,658
in the compiler. It's saying the fix is related to the compiler.

00:11:32,658 --> 00:11:34,960
So that's how you parse the version name.

00:11:35,728 --> 00:11:42,902
It says 'chore', meaning this commit was in part of some kind of a chore.

00:11:43,302 --> 00:11:47,573
It would be a commit that doesn't have a big impact on the version

00:11:48,207 --> 00:11:58,384
You can consider something like documentation update, which may not affect the update much.

00:11:58,818 --> 00:12:06,659
Another is 'feat', indicating a new feature. You can specify the scope likewise.

00:12:07,993 --> 00:12:14,500
And in the case of this commit message, 'BREAKING CAHNGE' is entered in capital letters.

00:12:15,534 --> 00:12:19,572
This commit with 'BREAKING CHANGE' is literally

00:12:19,572 --> 00:12:25,611
the convention saying there's a breaking change, so the update had better be a major version update.

00:12:26,245 --> 00:12:33,319
So all commit messages starting with prefixes like fix, chore, docs, reactor, test, etc.

00:12:33,319 --> 00:12:37,323
These are commits that require patch updates.

00:12:37,890 --> 00:12:43,095
In addition, in case a new 'feat' function is added, but backward compatibility is maintained,

00:12:43,095 --> 00:12:45,631
then it is a minor update

00:12:45,631 --> 00:12:51,403
And if the BREAKING CHANGE is included in a commit message, this will be a major update.

00:12:52,071 --> 00:13:00,346
So this Conventional Commit message was influenced by the Angular team and has been developed.

00:13:00,546 --> 00:13:03,415
A lot of libraries are using it now

00:13:03,783 --> 00:13:09,722
Vue.js, WebPack, Angular, Nuxt., Gatsby, jest

00:13:09,722 --> 00:13:17,029
It is used by many open source libraries and also by many companies.

00:13:18,597 --> 00:13:22,935
Now lets look at the conventional changelog.

00:13:23,669 --> 00:13:31,544
If you have seen a changelog file like this, you can almost always use a tool called Conventional Changelog

00:13:31,544 --> 00:13:34,079
You can see it as a generated file

00:13:34,814 --> 00:13:40,052
Shall we look at what the Conventional Changelog does?

00:13:40,586 --> 00:13:45,658
Now the most recent release was version 0.15.0

00:13:45,658 --> 00:13:49,862
And on top of that, the commits are newly released commits.

00:13:51,463 --> 00:13:59,905
Then, the docs commit message does not affect the version

00:14:00,105 --> 00:14:02,341
They don't enter the changelog.

00:14:02,341 --> 00:14:12,852
Likewise, these chores commit messages are ignored by the conventional changelog.

00:14:12,852 --> 00:14:18,324
So in the end, only the three commit message are included in the changelog.

00:14:19,225 --> 00:14:23,028
You can see the result here

00:14:24,096 --> 00:14:28,234
This fix goes into the bug fix section like this

00:14:28,234 --> 00:14:30,202
This goes in like this

00:14:30,369 --> 00:14:34,907
Also, this feature goes into a section called features

00:14:34,907 --> 00:14:42,081
As you can see, the scope on error was included in bold

00:14:42,114 --> 00:14:47,519
And because new features were added, minor updates were made.

00:14:47,653 --> 00:14:49,955
And because new features were added, minor updates were made.

00:14:51,056 --> 00:14:57,596
Another thing to pay attention to when deploying the library is the argument '--tag'

00:14:58,464 --> 00:15:05,938
In some cases, it can be deployd by tagging alpha,beta,dev,canary,rc, etc.

00:15:06,438 --> 00:15:14,947
In fact, I once forgot to deploy as a beta and released as a stable version.

00:15:15,214 --> 00:15:23,289
It's important to watch out, but easy to overlook.

00:15:24,323 --> 00:15:29,695
Now let's see how the Instant Search team do a release.

00:15:30,029 --> 00:15:32,898
Now let's see how the Instant Search team do a release.

00:15:32,898 --> 00:15:38,370
The repository has a file called src/scripts/publish.js

00:15:38,404 --> 00:15:40,839
I ran this when deploying

00:15:41,106 --> 00:15:48,847
Then, when you run this, what the script does is makes sure that the working folder is cleaned and everything is committed.

00:15:49,882 --> 00:15:55,421
And we see if there is anything we're working on that needs to be committed

00:15:55,821 --> 00:16:00,159
After that, it updates the version in package.json.

00:16:00,359 --> 00:16:06,131
Update the changelog and 'git commit' those changes

00:16:06,665 --> 00:16:11,270
Run 'run test', build and 'npm publish'

00:16:11,437 --> 00:16:14,573
and add --tag beta as necessary.

00:16:15,240 --> 00:16:22,014
And by doing 'git tag', it creates a new version tag and pushes it.

00:16:22,715 --> 00:16:27,886
All of the processes I've been describing are in this script.

00:16:27,886 --> 00:16:33,125
So I just ran it as it is, so there was no problem

00:16:36,395 --> 00:16:45,637
But, as I mentioned, the repository has a file src/scripts/publish.js

00:16:46,271 --> 00:16:51,276
This is the file in the InstantSearch.js repository.

00:16:52,277 --> 00:16:56,281
But in fact, the same file exists in the React repository

00:16:56,815 --> 00:16:58,183
and it exsists in Vue,

00:16:58,417 --> 00:16:59,952
and in Angular as well.

00:17:01,253 --> 00:17:03,689
But it's all a little different

00:17:04,623 --> 00:17:09,428
I think that was one of the very difficult points to manage

00:17:10,863 --> 00:17:20,839
Anyway, I have this script, but I can still make mistakes for the reasons I listed earlier.

00:17:21,273 --> 00:17:27,813
That’s why I’m still nervous and every time I deploy

00:17:27,813 --> 00:17:33,252
I once called a colleague to sit in front of my computer to deploy together.

00:17:33,786 --> 00:17:38,924
And you still have to wait for those tests to succeed

00:17:39,291 --> 00:17:40,826
And you still have to wait for those tests to succeed

00:17:42,628 --> 00:17:45,364
If so, what can we do?

00:17:47,032 --> 00:17:50,102
I'll give you two solutions.

00:17:50,102 --> 00:17:52,638
First, there is a tool called 'np'

00:17:52,638 --> 00:17:56,842
I don’t know how to pronounce the name of this persion

00:17:56,842 --> 00:17:59,178
They're very famous

00:17:59,178 --> 00:18:07,453
They've been making a lot of active open source libraries and software

00:18:07,886 --> 00:18:15,227
This np is literally a better version of the npm publish tool.

00:18:15,928 --> 00:18:19,665
If you run this, it cleans up and

00:18:19,665 --> 00:18:23,502
installs dependencies, runs tests

00:18:23,669 --> 00:18:28,874
bumps the version, publishes the package, and pushes the tag.

00:18:30,209 --> 00:18:32,911
It's almost the same as the script I had.

00:18:33,512 --> 00:18:37,015
But now one problem is when trying to deploy

00:18:37,182 --> 00:18:39,618
it asks for the next version like this

00:18:40,185 --> 00:18:44,223
They are leaving the user to choose the next version.

00:18:45,057 --> 00:18:51,597
And another problem with this is that you have to wait until it's all over

00:18:51,630 --> 00:18:54,500
And another problem with this is that you have to wait until it's all over

00:18:55,634 --> 00:19:01,306
An alternative is sementic-release, another popular tool.

00:19:03,809 --> 00:19:08,814
It's titled a "fully automated version managment and package publishing tool".

00:19:08,947 --> 00:19:10,782
It's titled a "fully automated version managment and package publishing tool".

00:19:11,150 --> 00:19:13,285
So as you can see

00:19:13,285 --> 00:19:19,625
When you run this, it goes through steps like Verify Conditions, Get last release, Analyze commit,

00:19:19,625 --> 00:19:26,532
Verify release, Generate notes, Create git tag, prepare, publish, notify

00:19:26,532 --> 00:19:29,234
Verify release, Generate notes, Create git tag, prepare, publish, notify

00:19:29,468 --> 00:19:37,009
You can think of it as a slightly beefier version of what we talked about earlier.

00:19:37,009 --> 00:19:41,380
It's a good tool, and it's being used a lot.

00:19:41,380 --> 00:19:49,621
But the fact that it was fully automated rubbed me the wrong way

00:19:50,222 --> 00:19:53,792
because there's no room for me to intervene.

00:19:54,493 --> 00:20:02,134
So I wanted to balance something between completely manual and completely automatic.

00:20:02,768 --> 00:20:08,173
To do that, I thought I will need a different process.

00:20:08,173 --> 00:20:13,412
I thought it would require a different process than what I was doing

00:20:14,313 --> 00:20:16,114
So I was thinking

00:20:17,849 --> 00:20:21,386
and divided the process into three steps

00:20:22,187 --> 00:20:29,661
The first is Prepare, the second is the Review, and the third is the Trigger.

00:20:29,895 --> 00:20:31,396
Let's look at them one by one

00:20:31,396 --> 00:20:34,466
'Prepare' gets the next version.

00:20:34,766 --> 00:20:40,138
The next version can now be easily obtained because the commit message has a convention.

00:20:40,138 --> 00:20:44,076
Then it checks out to a temporary branch.

00:20:44,076 --> 00:20:55,187
For example, 'git checkout -b releases/v1.2.3' checkout to a temporary branch like this

00:20:55,187 --> 00:20:59,725
It updates the version of package.json in that branch.

00:20:59,725 --> 00:21:03,061
And the changelog is also updated.

00:21:03,695 --> 00:21:08,000
It commits that change and makes a pull request

00:21:08,734 --> 00:21:11,737
So this was the first part.

00:21:12,904 --> 00:21:16,074
The second part is simple.

00:21:16,074 --> 00:21:18,744
Just review the pull request.

00:21:19,044 --> 00:21:24,549
When reviewing a pull request, there are a number of factors, which includes a status check.

00:21:25,117 --> 00:21:27,452
I'm sure you've seen something like this a lot

00:21:27,452 --> 00:21:33,025
By default, through tools like these we can run through the tests.

00:21:33,325 --> 00:21:35,494
We can test it automatically.

00:21:35,894 --> 00:21:40,999
And now any additional tests, for example, can be run in a number of ways,

00:21:40,999 --> 00:21:45,937
using CodeSandbox, Pika CI, etc.

00:21:46,271 --> 00:21:49,875
Let me give you a brief description of the sandbox.

00:21:50,275 --> 00:21:54,880
If CodeSandBox's CI is linked to the repository,

00:21:54,880 --> 00:21:59,985
whenever you make a pull request, these comments are made automatically.

00:22:00,585 --> 00:22:08,593
Then this pull request temporarily deploys the current state to the branch.

00:22:08,593 --> 00:22:16,768
So this URL is created and with this you can install it

00:22:16,768 --> 00:22:21,106
on any environment and test the parts you want to test manually

00:22:21,106 --> 00:22:27,446
Or you can send it to a customer to see if this version works bettter.

00:22:27,446 --> 00:22:34,853
Also, since CodeSandBox CI provides a Sandbox using this version

00:22:34,853 --> 00:22:39,291
If you make a template in advance, you can easily test it.

00:22:39,958 --> 00:22:45,597
And, if an issue occurs, you can add a commit to that very branch.

00:22:45,597 --> 00:22:51,203
For example, say I simply want to change the wording of the changelog

00:22:51,203 --> 00:22:56,041
Then you can edit the changelog and push it to the pull request.

00:22:57,142 --> 00:23:03,115
Then, eventually, you can squash and merge the pull request.

00:23:03,548 --> 00:23:09,988
When you click the squash and merge button like this, a new commit is added.

00:23:10,389 --> 00:23:16,995
A message like 'chore: release v1.2.3' will be added.

00:23:17,629 --> 00:23:21,566
So now the third process is Trigger.

00:23:22,200 --> 00:23:26,872
A new commit will CI/CD and start the Trigger process

00:23:26,872 --> 00:23:30,342
For example, you might have Circle CI or travis-CI.

00:23:30,675 --> 00:23:37,015
Then the CI runs a script. What the script does is

00:23:37,849 --> 00:23:46,925
npm run build, npm publish, and in some cases --tag beta, git tag v1.2.3

00:23:46,925 --> 00:23:49,361
And it even git pushes.

00:23:51,129 --> 00:23:55,167
Now, let’s review again

00:23:55,167 --> 00:24:00,105
Update version, update changelog and git commit

00:24:00,372 --> 00:24:06,211
And test, build, publish, tag, push

00:24:06,211 --> 00:24:11,116
There is a whole process like this, this was part 1

00:24:11,149 --> 00:24:14,453
This is part 2, this is part 3

00:24:14,719 --> 00:24:18,857
So, this whole process has been broken down into three parts.

00:24:19,524 --> 00:24:23,728
You don't have to wait around as much using this new process.

00:24:23,728 --> 00:24:32,337
That's because, of the three parts, your computer only runs part 1

00:24:32,604 --> 00:24:37,742
Part 2 is from GitHub and part 3 is from CI/CD service.

00:24:37,909 --> 00:24:44,583
That means it takes less than a minute to run Part 1 on your computer.

00:24:47,052 --> 00:24:49,921
So you are less likely to make mistakes.

00:24:50,055 --> 00:24:57,729
Again, because in this whole process you only need to run Part 1

00:24:58,196 --> 00:25:01,867
Part 2 and Part 3 are not your responsibility.

00:25:01,867 --> 00:25:06,071
GitHub may suddenly go down or something like that

00:25:06,805 --> 00:25:10,442
but unless that happens, there's no problem

00:25:10,442 --> 00:25:16,381
reviewing on GitHub, and Circle CI won't stop working suddenly.

00:25:16,381 --> 00:25:23,188
You will be able to separate those responsibilities, so you only need to run part 1 well.

00:25:23,188 --> 00:25:29,528
The rest just follow a well-designed process.

00:25:29,594 --> 00:25:33,231
That's why I tend to be less nervous using this process.

00:25:33,765 --> 00:25:41,873
Also, if you run Part 2 which runs on GitHub, you can review it on your own

00:25:41,873 --> 00:25:47,779
but you can also review with your colleagues or community members. Because of that,

00:25:47,779 --> 00:25:54,619
you won't feel as stressed out about making mistakes.

00:25:55,520 --> 00:26:00,458
You can also automate Part 1 and Part 3 entirely.

00:26:01,426 --> 00:26:09,034
So I made a tool called Ship.js. This is a tool to automate Part 1 and Part 3.

00:26:09,868 --> 00:26:12,938
You can run Part 1 using Ship.js

00:26:13,338 --> 00:26:19,444
using the command 'shipjs preprare'

00:26:19,444 --> 00:26:27,185
Part 2 is reviewed on GitHub, you can do it yourself or with a colleague

00:26:27,185 --> 00:26:32,891
And Part 3 is the Ship.js trigger. This runs on CI/CD.

00:26:35,627 --> 00:26:40,332
Ship.js has been deployd using Ship.js.

00:26:40,865 --> 00:26:44,669
It's a little funny, but it actually only makes sense.

00:26:44,669 --> 00:26:51,509
If Ship.js deploys without using Ship.js, that would be ironic.

00:26:51,676 --> 00:26:56,781
So I’m going to show you a short video

00:26:56,781 --> 00:27:09,427
At the time of updating from 0.20.0-beta.3 to the stable version 0.20.0

00:27:09,594 --> 00:27:11,796
I have recorded the process

00:27:12,364 --> 00:27:13,698
Let’s take a quick look

00:27:14,933 --> 00:27:18,903
So there is this old version in the repository

00:27:20,071 --> 00:27:23,408
But I will update this to 0.20.0.

00:27:24,743 --> 00:27:29,247
I’m going to run the command from the command line, as you can see

00:27:29,247 --> 00:27:33,551
The release is supposed to run the command shipjs prepare

00:27:33,551 --> 00:27:36,554
Run yarn run release.

00:27:39,124 --> 00:27:44,329
Then pull and update

00:27:44,329 --> 00:27:49,768
Ship.js suggests making the next version a beta 4

00:27:49,768 --> 00:27:54,506
But we say no because that's not it.

00:27:56,741 --> 00:27:58,576
We enter the desired verison.

00:27:59,244 --> 00:28:05,050
Then create a staging branch to update the version and changelog

00:28:05,050 --> 00:28:08,620
That commit will make a pull request.

00:28:09,087 --> 00:28:13,591
And it automatically opens the pull request on the browser.

00:28:14,059 --> 00:28:18,730
So, if you look at it, lots of information is well summarized.

00:28:18,730 --> 00:28:23,435
After you look at these and the review is done,

00:28:23,635 --> 00:28:25,704
Squash and Merge, please.

00:28:25,704 --> 00:28:31,076
But since it's a demo, I'll just ignore it and merge it right away.

00:28:31,076 --> 00:28:36,848
You shouldn't do this in real life. You should wait for the approval then merge.

00:28:37,248 --> 00:28:42,020
So now that we have a new commit to Circle CI,

00:28:42,287 --> 00:28:45,824
A new task is running

00:28:48,626 --> 00:28:53,698
Now, let's take a quick look at this task.

00:28:55,467 --> 00:29:01,573
In this example, we're using Circle CI, and you can see the config here

00:29:02,474 --> 00:29:06,010
We have a task workflow called 'Release if needed'

00:29:06,010 --> 00:29:12,717
If you add it to the bramc called 'main', the task runs.

00:29:12,717 --> 00:29:18,957
It's a task that installs and executes a command called "yarn shipjs trigger".

00:29:19,557 --> 00:29:24,729
So after Circle CI prepares this and that,

00:29:26,498 --> 00:29:34,606
runs "yarn shipjs trigger", then runs yarn build

00:29:34,606 --> 00:29:38,276
then publishes to npm and then creates tags.

00:29:38,777 --> 00:29:42,714
You can see it push to the github, too.

00:29:43,748 --> 00:29:53,358
So if you refresh at npm, you'll see a new version of 0.20.0

00:29:53,792 --> 00:29:56,628
This was deployed with the latest tag.

00:29:56,995 --> 00:30:03,835
And if you go to GitHub, you can see a new version added to this release tab.

00:30:06,437 --> 00:30:10,241
So if you run the command called 'shipjs setup'

00:30:10,241 --> 00:30:18,149
You can use it easily because the CLI pops up to set up your repository.

00:30:18,716 --> 00:30:23,822
You can also use GitHub Actions. You can see it introduces 

00:30:24,322 --> 00:30:29,494
Circle CI and other useful settings

00:30:29,494 --> 00:30:33,331
or how the settings are set up

00:30:33,765 --> 00:30:39,070
The documentations are well written so that you can try various settings

00:30:39,537 --> 00:30:46,144
So far, so many contributors have helped us to develop Ship.js

00:30:47,312 --> 00:30:51,282
Ship.js is not about tools

00:30:51,282 --> 00:30:53,551
This is a story about a process

00:30:54,452 --> 00:31:00,291
I came up with a new process to improve a process I found inconvenient

00:31:00,291 --> 00:31:04,863
It’s the story of creating tools to support that process.

00:31:04,863 --> 00:31:14,772
So I want you to take this idea and apply it to other libraries, languages, or other environments.

00:31:14,772 --> 00:31:18,576
Just take it, but do let me know.

00:31:18,576 --> 00:31:22,213
I just want to know what you will try out.

00:31:22,580 --> 00:31:24,649
So, I'd like you to let me know and

00:31:24,649 --> 00:31:28,553
I hope you can use this idea without bounds

00:31:28,553 --> 00:31:32,357
and that your deployment process will be more enjoyable.

00:31:33,358 --> 00:31:35,927
Thank you for listening.

00:31:35,927 --> 00:31:40,598
You can find me on Twitter @eunjae_lee.

00:31:40,765 --> 00:31:49,274

YouTube URL: https://www.youtube.com/watch?v=JbzdDYo2w_I


