Title: Michael Mifsud: Real World HTTP 2 - CSSConf.Asia 2016
Publication date: 2016-12-15
Playlist: CSSConf.Asia 2016
Description: 
	HTTP/2 has rightfully garnered a lot of interest from the web performance community. For better or worse, the story of HTTP/2 has become tied to notions of free performance and how it will make "everything we know about web performance wrong".
The reality of HTTP/2 can sometimes be sobering. My talk will aim to highlight some rarely talked about caveats, in the hopes of bringing some balance to the HTTP/2 discussion.

Michael is a performance engineer at 99designs focusing primarily on frontend architecture, tooling, and site performance.
An advocate for open source software he's currently the project lead for Node Sass and a core contributor to LibSass.
He's also heavily involved in the local developer community as part of the CSSConf AU and the MelbCSS meetup organising teams.


CSSConf.Asia - Capitol Theatre, Singapore - 24 November 2016.

Source: https://2016.cssconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:00,120 --> 00:00:02,179
you

00:00:10,410 --> 00:00:15,790
so in 1989 Tim berners-lee first

00:00:13,809 --> 00:00:18,039
proposed the world wide web project and

00:00:15,790 --> 00:00:22,150
with that he'd his team at CERN invented

00:00:18,039 --> 00:00:25,020
HTTP and HTML the first implementation

00:00:22,150 --> 00:00:29,220
had one HP method and it was gap and

00:00:25,020 --> 00:00:32,020
every response returned a HTML page

00:00:29,220 --> 00:00:35,950
years before the creation of JPEGs or

00:00:32,020 --> 00:00:38,500
Windows 3.1 with just HTTP and HTML the

00:00:35,950 --> 00:00:42,850
first-ever web page was deployed and was

00:00:38,500 --> 00:00:46,360
responsive as the first version of HTTP

00:00:42,850 --> 00:00:47,620
was documented in 1991 multiple versions

00:00:46,360 --> 00:00:51,370
and revisions over the next eight years

00:00:47,620 --> 00:00:55,079
in a period of rapid evolution until

00:00:51,370 --> 00:00:58,300
until HTTP 1.1 was finalized in 1999 and

00:00:55,079 --> 00:01:00,190
what internet was born they should be

00:00:58,300 --> 00:01:01,899
1.1 is what most of us would know is HP

00:01:00,190 --> 00:01:04,960
one what most websites run on at the

00:01:01,899 --> 00:01:06,939
moment so I may use HP 11.1 it to change

00:01:04,960 --> 00:01:11,799
ibly but they're the same thing for the

00:01:06,939 --> 00:01:13,479
extent of this talk in the preceding 20

00:01:11,799 --> 00:01:14,979
years generations of developers use

00:01:13,479 --> 00:01:17,020
these simple building blocks to create

00:01:14,979 --> 00:01:18,789
engaging experiences of communities for

00:01:17,020 --> 00:01:20,679
journalists musicians artists designers

00:01:18,789 --> 00:01:23,439
crafters gamers and everything in

00:01:20,679 --> 00:01:25,299
between we went from 386 s the Pentiums

00:01:23,439 --> 00:01:27,429
to watches it more computing power than

00:01:25,299 --> 00:01:32,319
the Space Shuttle has said people to the

00:01:27,429 --> 00:01:33,759
moon we added JavaScript CSS images and

00:01:32,319 --> 00:01:36,189
most importantly gifts to our toolbox

00:01:33,759 --> 00:01:37,630
and with them we built new ways to

00:01:36,189 --> 00:01:39,249
connect to communicate share in our

00:01:37,630 --> 00:01:42,939
lives and engage with the world around

00:01:39,249 --> 00:01:44,229
us the hypertext Transfer Protocol of

00:01:42,939 --> 00:01:45,429
the revolutionary for its time is

00:01:44,229 --> 00:01:47,919
crumbling under the weight of our modern

00:01:45,429 --> 00:01:49,329
ambitions the design of the protocols at

00:01:47,919 --> 00:01:50,979
odds with what we as developers are

00:01:49,329 --> 00:01:56,259
building and with what our customers

00:01:50,979 --> 00:01:57,729
expect in 1999 google announced they're

00:01:56,259 --> 00:02:00,639
working internally on a modern revision

00:01:57,729 --> 00:02:02,049
of HTTP they named a speedy speedy

00:02:00,639 --> 00:02:04,479
primarily focus on reducing latency

00:02:02,049 --> 00:02:07,119
which as a result had larger performance

00:02:04,479 --> 00:02:08,619
improvements of HTTP one significant

00:02:07,119 --> 00:02:09,910
performance improvements to rapid

00:02:08,619 --> 00:02:11,379
adoption of the new protocol and

00:02:09,910 --> 00:02:16,000
browsers and large sites like Facebook

00:02:11,379 --> 00:02:16,810
and Google in 2012 looking to revitalize

00:02:16,000 --> 00:02:19,840
HTTP to

00:02:16,810 --> 00:02:21,610
nuvo HP with new version working group

00:02:19,840 --> 00:02:25,450
took speedy and made it the initial spec

00:02:21,610 --> 00:02:28,180
for HTTP to nature to spec was finalized

00:02:25,450 --> 00:02:29,860
last year and as of now all major

00:02:28,180 --> 00:02:34,030
browsers and web server support in the

00:02:29,860 --> 00:02:36,610
HTTP 20 Spidey speedy for better or for

00:02:34,030 --> 00:02:38,260
worse the story of HTTP two has become

00:02:36,610 --> 00:02:39,099
tired to notions of free performance and

00:02:38,260 --> 00:02:41,380
help make everything that web

00:02:39,099 --> 00:02:43,060
performance sprung unfortunately the

00:02:41,380 --> 00:02:44,590
promise of free performance comes with

00:02:43,060 --> 00:02:50,280
some fine print and that's what I'm here

00:02:44,590 --> 00:02:53,739
to talk about today so uh hi I'm Michael

00:02:50,280 --> 00:02:56,650
I'm from Australia and I'm a front-end

00:02:53,739 --> 00:02:58,390
performance engineer at 99designs and as

00:02:56,650 --> 00:03:00,130
was said earlier and one of the

00:02:58,390 --> 00:03:02,440
organizers of CSS company has confessed

00:03:00,130 --> 00:03:03,819
rally on and i work on suburban source

00:03:02,440 --> 00:03:08,110
projects you might be familiar with in

00:03:03,819 --> 00:03:09,220
nerd Sasson lips eyes i want to start

00:03:08,110 --> 00:03:12,280
off by saying what this talk won't be

00:03:09,220 --> 00:03:13,480
about this is not insured HTTP to a lot

00:03:12,280 --> 00:03:15,430
of great material out there a lot of

00:03:13,480 --> 00:03:17,880
great talks and blog posts that could do

00:03:15,430 --> 00:03:20,170
much better than I could in this time

00:03:17,880 --> 00:03:22,030
what I will be talking about is some of

00:03:20,170 --> 00:03:24,420
the differences when HTTP one HTTP two

00:03:22,030 --> 00:03:26,560
and what this can mean for performance i

00:03:24,420 --> 00:03:27,579
will quickly cover some fundamentals

00:03:26,560 --> 00:03:30,070
necessary to illustrate these

00:03:27,579 --> 00:03:32,200
differences so if networking protocols

00:03:30,070 --> 00:03:36,209
in HTTP aren't your thing don't worry i

00:03:32,200 --> 00:03:40,000
got you covered so let's jump right in

00:03:36,209 --> 00:03:41,530
all in all HTTP is fairly simple you

00:03:40,000 --> 00:03:43,239
connect to a server and then with a

00:03:41,530 --> 00:03:44,650
small set of commands you instruct the

00:03:43,239 --> 00:03:47,470
server perform some action and it

00:03:44,650 --> 00:03:51,519
responds these actions issued as HTTP

00:03:47,470 --> 00:03:54,090
methods in requests and metadata the

00:03:51,519 --> 00:03:56,889
most common method being the get method

00:03:54,090 --> 00:03:59,010
we instruct HTTP server to respond with

00:03:56,889 --> 00:04:01,209
the contents of a file at a certain path

00:03:59,010 --> 00:04:03,489
this simple interaction is largely

00:04:01,209 --> 00:04:08,440
unchanged in the 25 years since tim

00:04:03,489 --> 00:04:10,090
berners-lee created HTML HTTP they're a

00:04:08,440 --> 00:04:11,440
bunch of other methods that I won't

00:04:10,090 --> 00:04:13,630
cover today but for the most part of

00:04:11,440 --> 00:04:15,639
boils down to a client in our case a

00:04:13,630 --> 00:04:19,000
browser connects to a server and

00:04:15,639 --> 00:04:21,430
requests something with metadata and a

00:04:19,000 --> 00:04:23,950
method and the server responds with

00:04:21,430 --> 00:04:28,840
content something like CSS HTML

00:04:23,950 --> 00:04:31,419
Javascript underlying all this is our

00:04:28,840 --> 00:04:33,460
tcp/ip this is the primary networking

00:04:31,419 --> 00:04:37,360
protocol for all HP communication and

00:04:33,460 --> 00:04:39,550
for the Internet in general it's with

00:04:37,360 --> 00:04:43,180
this it's with these two protocols TCP

00:04:39,550 --> 00:04:44,349
and IP that the two remote servers are

00:04:43,180 --> 00:04:48,280
able to communicate and exchange

00:04:44,349 --> 00:04:50,140
information efficiently being that it is

00:04:48,280 --> 00:04:51,880
the primary protocol underpinning most

00:04:50,140 --> 00:04:53,140
to the internet it's integral part of

00:04:51,880 --> 00:04:56,349
what network performance is like when

00:04:53,140 --> 00:04:59,620
using it so we'll cover that a bit one

00:04:56,349 --> 00:05:02,110
of the important things of tcp/ip is the

00:04:59,620 --> 00:05:05,729
connection and that involves a three-way

00:05:02,110 --> 00:05:08,380
handshake essentially a client say your

00:05:05,729 --> 00:05:11,169
browser will set will check to a server

00:05:08,380 --> 00:05:14,320
and say hey Here I am with a syn packet

00:05:11,169 --> 00:05:16,570
and a browser will say Here I am I see

00:05:14,320 --> 00:05:18,880
you with a syn ACK packet and their clan

00:05:16,570 --> 00:05:23,020
will be like I see you at the next are

00:05:18,880 --> 00:05:24,340
communicating the details this aren't

00:05:23,020 --> 00:05:26,020
particularly important the important

00:05:24,340 --> 00:05:29,260
thing to take away from this is it takes

00:05:26,020 --> 00:05:30,880
a full networking round trip from you to

00:05:29,260 --> 00:05:35,260
the server on server back to you before

00:05:30,880 --> 00:05:37,000
you can exchange any information so we

00:05:35,260 --> 00:05:40,169
look at the anatomy of a request for a

00:05:37,000 --> 00:05:42,370
page say the index HTML page first

00:05:40,169 --> 00:05:44,860
client say the browser connects to a

00:05:42,370 --> 00:05:48,219
server I do a handshake at one round

00:05:44,860 --> 00:05:51,430
trip and then the browser can say hey

00:05:48,219 --> 00:05:53,050
give me index dot HTML that goes to

00:05:51,430 --> 00:05:55,030
server server does some work generates

00:05:53,050 --> 00:05:57,130
the page rather be WordPress or a static

00:05:55,030 --> 00:06:00,640
file the returns response in this case

00:05:57,130 --> 00:06:02,740
HTML and that connection is closed if in

00:06:00,640 --> 00:06:05,620
that response HTML there was a link to a

00:06:02,740 --> 00:06:08,169
CSS file that process starts again you

00:06:05,620 --> 00:06:10,510
find the server you handshake you then

00:06:08,169 --> 00:06:11,919
request the server for a thing the

00:06:10,510 --> 00:06:14,830
server does some work and returns it to

00:06:11,919 --> 00:06:16,750
you and that connection is closed so

00:06:14,830 --> 00:06:21,580
this is for round trips in total to ask

00:06:16,750 --> 00:06:24,180
for a HTML file and a CSS file and this

00:06:21,580 --> 00:06:26,830
this is important because one of the

00:06:24,180 --> 00:06:29,380
fundamental things of tcp and white is

00:06:26,830 --> 00:06:31,150
so reliable is it is a FIFO queue so

00:06:29,380 --> 00:06:33,280
first in first out so the first thing a

00:06:31,150 --> 00:06:34,660
server sends to you must be the first

00:06:33,280 --> 00:06:35,820
thing you receive and your receipt and

00:06:34,660 --> 00:06:37,380
you read them in order

00:06:35,820 --> 00:06:39,870
if for some reason along the way due to

00:06:37,380 --> 00:06:41,550
congestion or happenstance one of the

00:06:39,870 --> 00:06:43,800
one of the Packers of data has dropped

00:06:41,550 --> 00:06:45,750
on the floor or sequential packets are

00:06:43,800 --> 00:06:48,510
just held by this by the client and

00:06:45,750 --> 00:06:50,100
buffered and not read until we're able

00:06:48,510 --> 00:06:51,810
to tell the server that hey we missed

00:06:50,100 --> 00:06:53,130
something please resend it and then it

00:06:51,810 --> 00:06:54,840
receives that and then reads the rescue

00:06:53,130 --> 00:06:56,250
services that are it's a bit more

00:06:54,840 --> 00:06:59,220
complicated than that but that's really

00:06:56,250 --> 00:07:00,510
what we need for this talk and this will

00:06:59,220 --> 00:07:02,250
happens at a layer well below anything

00:07:00,510 --> 00:07:04,710
we see this is a networking layer in

00:07:02,250 --> 00:07:06,480
often in your OS or in your browser and

00:07:04,710 --> 00:07:08,520
so we have no control over it in our

00:07:06,480 --> 00:07:14,010
code and the end result is that things

00:07:08,520 --> 00:07:15,330
feel slow another impact of TCP another

00:07:14,010 --> 00:07:17,760
feature tease be its position control

00:07:15,330 --> 00:07:19,340
this is necessary because over the

00:07:17,760 --> 00:07:23,340
Internet there's many different

00:07:19,340 --> 00:07:25,170
bandwidths and between you and the

00:07:23,340 --> 00:07:27,600
server community came to is intermediate

00:07:25,170 --> 00:07:29,490
Abraxas many different computers and

00:07:27,600 --> 00:07:31,560
servers always carry different bandwidth

00:07:29,490 --> 00:07:34,080
and amplify that across the entire world

00:07:31,560 --> 00:07:35,370
you can get into a case where people are

00:07:34,080 --> 00:07:38,850
communicating at different speeds and

00:07:35,370 --> 00:07:40,140
packets start backing up and you start

00:07:38,850 --> 00:07:42,300
roping packets and soon you start

00:07:40,140 --> 00:07:44,190
dropping packets the service has to

00:07:42,300 --> 00:07:45,780
retransmit those packets that causes

00:07:44,190 --> 00:07:48,540
more congestion causing you to drop more

00:07:45,780 --> 00:07:50,310
packets causing you more weeks more

00:07:48,540 --> 00:07:52,140
retransmits and more congestion and it

00:07:50,310 --> 00:07:54,660
can go on on to the points can

00:07:52,140 --> 00:07:57,060
entire networks and has in the past so

00:07:54,660 --> 00:07:58,350
as a result congestion controls start

00:07:57,060 --> 00:07:59,760
with sending a really small window

00:07:58,350 --> 00:08:01,530
saying I'm going to send you a little

00:07:59,760 --> 00:08:03,510
bit and then the longer the connection

00:08:01,530 --> 00:08:04,890
lives on the mortal sin kind of a test

00:08:03,510 --> 00:08:07,950
to see whether capabilities that

00:08:04,890 --> 00:08:10,790
bandwidth are and that's interesting

00:08:07,950 --> 00:08:14,040
because it end up in this property of

00:08:10,790 --> 00:08:15,900
TCP where most internet connect

00:08:14,040 --> 00:08:17,970
communication is latency bound an

00:08:15,900 --> 00:08:21,000
experiment done at Google a couple years

00:08:17,970 --> 00:08:23,250
ago probably while ago now showed that

00:08:21,000 --> 00:08:24,990
with increases in bandwidth start show

00:08:23,250 --> 00:08:27,840
starring diminishing returns once about

00:08:24,990 --> 00:08:30,570
5 megabits per second but increased but

00:08:27,840 --> 00:08:33,240
decreases in latency have a linear

00:08:30,570 --> 00:08:34,919
increase over time so the more you can

00:08:33,240 --> 00:08:36,990
shrink down latency the faster things

00:08:34,919 --> 00:08:38,969
get and this is due to the fact

00:08:36,990 --> 00:08:42,469
everything requires your back and forth

00:08:38,969 --> 00:08:42,469
round trip and the handshake must happen

00:08:43,130 --> 00:08:48,270
so one of the things brought into HP 1.1

00:08:46,440 --> 00:08:49,320
was you I'd ever keep alive in that you

00:08:48,270 --> 00:08:51,570
can connect to a server

00:08:49,320 --> 00:08:53,820
and keep that connection open for

00:08:51,570 --> 00:08:55,740
multiple requests so still got a request

00:08:53,820 --> 00:08:57,660
in what I sort of say please give me the

00:08:55,740 --> 00:08:59,790
HTML file now please give me the CSS

00:08:57,660 --> 00:09:01,320
file but you save yourself that extra

00:08:59,790 --> 00:09:03,390
round trip in every connection each time

00:09:01,320 --> 00:09:04,980
a new file until eventually one of this

00:09:03,390 --> 00:09:08,610
one of the other client of the service

00:09:04,980 --> 00:09:11,130
says ok I'm done close connection an

00:09:08,610 --> 00:09:13,830
HTTP 1.1 was tried to bring in this idea

00:09:11,130 --> 00:09:16,290
of pipelining extending the keep alive

00:09:13,830 --> 00:09:18,390
keeping a connection over but saying hey

00:09:16,290 --> 00:09:21,840
I know I need these three files give me

00:09:18,390 --> 00:09:24,240
these three files at once and this runs

00:09:21,840 --> 00:09:28,110
into the heddle ahead of line problem in

00:09:24,240 --> 00:09:29,850
that the server must respond with one of

00:09:28,110 --> 00:09:31,740
the files generally the first of all you

00:09:29,850 --> 00:09:34,230
send but ice pack that receives an order

00:09:31,740 --> 00:09:36,300
so you can't intermix sending those

00:09:34,230 --> 00:09:39,680
files they must be sent in order so you

00:09:36,300 --> 00:09:43,950
kind of lose a lot of the benefits of

00:09:39,680 --> 00:09:47,130
use a lot of benefits of what you expect

00:09:43,950 --> 00:09:48,570
miss because you can't multiplex so this

00:09:47,130 --> 00:09:50,250
actually did have a lot of benefits in a

00:09:48,570 --> 00:09:53,430
lot of cases but it proved really hard

00:09:50,250 --> 00:09:55,920
to do well and there are classic cases

00:09:53,430 --> 00:09:57,780
in Safari where you would mix up the

00:09:55,920 --> 00:09:59,550
filename you requested with the actual

00:09:57,780 --> 00:10:02,280
body causing image to show in the wrong

00:09:59,550 --> 00:10:03,780
areas and intermediary proxies in the

00:10:02,280 --> 00:10:05,430
world of which there are many would

00:10:03,780 --> 00:10:07,110
understand these properly and mix up

00:10:05,430 --> 00:10:08,580
response and garble responses so

00:10:07,110 --> 00:10:10,230
although it actually has a lot of

00:10:08,580 --> 00:10:11,580
benefits it's hard to do well and

00:10:10,230 --> 00:10:13,650
there's a lot of bad actors in the world

00:10:11,580 --> 00:10:15,450
up there that get in the way of it so

00:10:13,650 --> 00:10:17,010
most browsers and servers will support

00:10:15,450 --> 00:10:21,900
this where divorce turned off and

00:10:17,010 --> 00:10:23,640
considered an advanced feature and

00:10:21,900 --> 00:10:26,460
keeping these with these things in mind

00:10:23,640 --> 00:10:28,320
you can see where when our common best

00:10:26,460 --> 00:10:30,240
performance factors come from the exact

00:10:28,320 --> 00:10:31,920
concatenations friday in lining and

00:10:30,240 --> 00:10:33,690
domain shouting are all ways to work

00:10:31,920 --> 00:10:37,440
around opening more connections and

00:10:33,690 --> 00:10:41,280
doing more handshakes and avoiding

00:10:37,440 --> 00:10:42,780
latency this is critical path is a way

00:10:41,280 --> 00:10:45,990
of working around condition control in

00:10:42,780 --> 00:10:48,180
the idea being you put C inline CSS into

00:10:45,990 --> 00:10:49,380
the into your page but only put enough

00:10:48,180 --> 00:10:51,360
in so you give fit within that first

00:10:49,380 --> 00:10:55,470
window while toothpaste or testing your

00:10:51,360 --> 00:10:58,760
connection so this is where HD video

00:10:55,470 --> 00:11:00,770
comes in h2b to like

00:10:58,760 --> 00:11:02,540
keeper lives and pipelining go forward

00:11:00,770 --> 00:11:05,630
which is under reducing latency ways you

00:11:02,540 --> 00:11:07,360
long live connections but something it

00:11:05,630 --> 00:11:09,830
does differently is this idea of streams

00:11:07,360 --> 00:11:11,720
and that you have one connection to a

00:11:09,830 --> 00:11:14,090
server within that connection you have

00:11:11,720 --> 00:11:17,060
multiple streams so this is like an

00:11:14,090 --> 00:11:18,350
analogy of a kind of lanes on a highway

00:11:17,060 --> 00:11:20,360
you have a highway to serve multiple

00:11:18,350 --> 00:11:24,530
lanes a communication independent from

00:11:20,360 --> 00:11:27,260
each other but they're bi-directional so

00:11:24,530 --> 00:11:29,750
I can ask I can ask for three files at

00:11:27,260 --> 00:11:31,490
the same time on one stream and get

00:11:29,750 --> 00:11:33,830
those responses back on that stream

00:11:31,490 --> 00:11:37,640
completely separate from another stream

00:11:33,830 --> 00:11:38,930
which is regressing JavaScript and what

00:11:37,640 --> 00:11:41,150
it has over pipelining that their of

00:11:38,930 --> 00:11:43,460
multiplexing so as a request three CSS

00:11:41,150 --> 00:11:45,800
files the server can respond to those

00:11:43,460 --> 00:11:47,810
files in any order and in bits of pieces

00:11:45,800 --> 00:11:49,280
so I can get the headers for one file

00:11:47,810 --> 00:11:51,260
get the headers for another file and

00:11:49,280 --> 00:11:52,610
it's part of its content and then after

00:11:51,260 --> 00:11:54,920
that the next pack could be the content

00:11:52,610 --> 00:11:56,540
of different file and this is baked into

00:11:54,920 --> 00:11:58,250
the protocol so the servers and clients

00:11:56,540 --> 00:12:00,710
understand how to reassemble these

00:11:58,250 --> 00:12:03,500
things and each one of these packets

00:12:00,710 --> 00:12:04,550
here is what's called the frame we're

00:12:03,500 --> 00:12:07,960
not going to dig into frames too much

00:12:04,550 --> 00:12:10,940
for this so as you can see with

00:12:07,960 --> 00:12:13,070
multiplexing and a long live connections

00:12:10,940 --> 00:12:15,560
and streams we're reducing a lot of

00:12:13,070 --> 00:12:17,210
problems with bandwidth and working

00:12:15,560 --> 00:12:19,970
around under the issues gesture control

00:12:17,210 --> 00:12:21,650
being lots of tiny requests I mean one

00:12:19,970 --> 00:12:23,600
on the request we at logic just from

00:12:21,650 --> 00:12:26,750
troy windows we go flow more data more

00:12:23,600 --> 00:12:29,720
freely and this is why people are

00:12:26,750 --> 00:12:31,040
telling us that I really when I

00:12:29,720 --> 00:12:32,240
performance is wrong you know I'm going

00:12:31,040 --> 00:12:34,460
to worry about latency anyway about

00:12:32,240 --> 00:12:38,000
congestion windows or bad with is free

00:12:34,460 --> 00:12:41,300
and latency is not a problem and I took

00:12:38,000 --> 00:12:43,460
this the research on internet is all in

00:12:41,300 --> 00:12:45,680
this behavior it was very little work

00:12:43,460 --> 00:12:48,590
bad we said about HTTP so with this

00:12:45,680 --> 00:12:53,450
confidence we started moving towards htp

00:12:48,590 --> 00:12:55,840
to at 99designs and before switch for

00:12:53,450 --> 00:12:58,430
flicking the switch on this I

00:12:55,840 --> 00:13:00,170
confidently said to my see to my boss

00:12:58,430 --> 00:13:04,580
that it couldn't possibly any slower

00:13:00,170 --> 00:13:07,370
we're fine to my chagrin we rapidly

00:13:04,580 --> 00:13:10,310
started seeing decreases are we we soon

00:13:07,370 --> 00:13:11,640
saw decreases in sight performance so

00:13:10,310 --> 00:13:13,500
this next

00:13:11,640 --> 00:13:17,430
save 15 minutes of my talk is me

00:13:13,500 --> 00:13:20,730
systematically eating my own hat so I

00:13:17,430 --> 00:13:22,320
work for 99 designs where a crowdsourced

00:13:20,730 --> 00:13:23,790
graphics design marketplace which is

00:13:22,320 --> 00:13:25,800
purely to say that images are very

00:13:23,790 --> 00:13:28,650
important we have lots and lots of

00:13:25,800 --> 00:13:32,640
images and to measure our site

00:13:28,650 --> 00:13:34,470
performance we pick some key metrics we

00:13:32,640 --> 00:13:36,030
focus more on perceived performance from

00:13:34,470 --> 00:13:37,770
the user so we use a couple of ways of

00:13:36,030 --> 00:13:41,010
doing this these are dashboards the

00:13:37,770 --> 00:13:43,980
float around our office so we look at

00:13:41,010 --> 00:13:45,510
content Dom content loaded to determine

00:13:43,980 --> 00:13:48,840
if synchronous groups are delaying our

00:13:45,510 --> 00:13:50,400
page loads we look at the first paint to

00:13:48,840 --> 00:13:53,280
see if delay if rendering is being

00:13:50,400 --> 00:13:55,920
delayed by fonts or CSS look at time to

00:13:53,280 --> 00:13:57,660
visually complete to look at non blonde

00:13:55,920 --> 00:14:00,750
non render blocking resources like

00:13:57,660 --> 00:14:02,910
images and asynchronous scripts and one

00:14:00,750 --> 00:14:04,710
of our main proxies at a glance is speed

00:14:02,910 --> 00:14:06,540
index which gives us a good idea of

00:14:04,710 --> 00:14:08,520
visual completion over time our sites

00:14:06,540 --> 00:14:11,610
being drawn faster are they finishing

00:14:08,520 --> 00:14:13,440
faster and visual pollution is mostly

00:14:11,610 --> 00:14:14,610
concerned with what's above the viewport

00:14:13,440 --> 00:14:17,190
so the initial viewed as the site

00:14:14,610 --> 00:14:19,560
thought look like it loaded fast and to

00:14:17,190 --> 00:14:21,540
get a lot of this data we use an app

00:14:19,560 --> 00:14:23,360
quad caliber subsidies calabar and we

00:14:21,540 --> 00:14:25,350
fetch the data route to store it locally

00:14:23,360 --> 00:14:27,180
so before I get to some of the problems

00:14:25,350 --> 00:14:30,320
in HD too we did see the great

00:14:27,180 --> 00:14:33,450
improvements pages like our designer

00:14:30,320 --> 00:14:34,740
portfolios which a typical

00:14:33,450 --> 00:14:36,570
representative typical page on our site

00:14:34,740 --> 00:14:38,430
you know they're mostly latency bound

00:14:36,570 --> 00:14:40,200
lots of really small files need to be

00:14:38,430 --> 00:14:42,960
pulled down lots of really small images

00:14:40,200 --> 00:14:44,460
and for these pages we saw like a five

00:14:42,960 --> 00:14:47,180
percent improvement on speed index so

00:14:44,460 --> 00:14:49,440
pages look like that were drawing faster

00:14:47,180 --> 00:14:51,540
the time to first paint was comparable

00:14:49,440 --> 00:14:53,220
so the first paint would happen around

00:14:51,540 --> 00:14:55,050
the same time and HP one versus age to

00:14:53,220 --> 00:15:00,240
be too but the page would finish drawing

00:14:55,050 --> 00:15:02,280
faster interesting interestingly was the

00:15:00,240 --> 00:15:04,770
initial render the first drawer on the

00:15:02,280 --> 00:15:06,300
page was macht HDD to which you'd expect

00:15:04,770 --> 00:15:10,260
as you'll be getting more data at the

00:15:06,300 --> 00:15:11,550
same time one of the bad things and the

00:15:10,260 --> 00:15:13,920
thing that really stuck out to us was

00:15:11,550 --> 00:15:16,320
our designer galleries these are

00:15:13,920 --> 00:15:18,690
extremely me have each pages so between

00:15:16,320 --> 00:15:21,150
80 pages on average and a page can be

00:15:18,690 --> 00:15:23,940
delay between 500 to 5 to 10 megs of

00:15:21,150 --> 00:15:24,329
images and these pages are Bam Bam

00:15:23,940 --> 00:15:29,100
whisperer

00:15:24,329 --> 00:15:30,420
not latency bound so because there

00:15:29,100 --> 00:15:32,730
weren't latency bound we didn't expect

00:15:30,420 --> 00:15:36,869
the reduction latency would have much

00:15:32,730 --> 00:15:39,769
impact on the performance these pages we

00:15:36,869 --> 00:15:42,299
actually saw a five to ten percent

00:15:39,769 --> 00:15:45,809
faster time the visual completion speed

00:15:42,299 --> 00:15:48,480
index us are slower so these pages would

00:15:45,809 --> 00:15:51,929
finish drawing much slower and HP to the

00:15:48,480 --> 00:15:54,480
HP one but we did see faster page load

00:15:51,929 --> 00:15:56,459
times which suggests that the reduced

00:15:54,480 --> 00:16:00,600
latency was having an effect which was

00:15:56,459 --> 00:16:02,519
very concentrated to us we also did some

00:16:00,600 --> 00:16:05,040
high latency testing because mobile is

00:16:02,519 --> 00:16:07,259
important to us and to everybody for

00:16:05,040 --> 00:16:12,089
this we use web page tests and compared

00:16:07,259 --> 00:16:13,769
to HP 1hp to continue to have more

00:16:12,089 --> 00:16:15,509
complete first paints so more data was

00:16:13,769 --> 00:16:17,040
getting there sooner and we'll drawing

00:16:15,509 --> 00:16:19,769
more complete the very first in the user

00:16:17,040 --> 00:16:21,569
saw but they'd happen noticeably later

00:16:19,769 --> 00:16:24,839
so the first pen would happen much

00:16:21,569 --> 00:16:29,040
before much later than the HP one paints

00:16:24,839 --> 00:16:30,419
but they'd be way more complete and we

00:16:29,040 --> 00:16:32,220
were continually seeing faster page

00:16:30,419 --> 00:16:36,029
loads so all the data was getting to the

00:16:32,220 --> 00:16:38,970
user far faster eventually but we were

00:16:36,029 --> 00:16:47,129
seeing much slower time to draw the page

00:16:38,970 --> 00:16:48,600
completely so to kind of sum that up for

00:16:47,129 --> 00:16:50,699
a typical page full of images on our

00:16:48,600 --> 00:16:53,339
site ones were latency bound lots of

00:16:50,699 --> 00:16:55,169
small farms a lot of small images we

00:16:53,339 --> 00:16:58,919
were seeing a five percent faster time

00:16:55,169 --> 00:17:00,689
to visually complete the entire page but

00:16:58,919 --> 00:17:02,489
for extremely me hedge pages pages that

00:17:00,689 --> 00:17:04,500
were latency bound painters it did a lot

00:17:02,489 --> 00:17:07,049
of work and transfer a lot of data who

00:17:04,500 --> 00:17:08,250
actually saw much slower visual

00:17:07,049 --> 00:17:11,970
completion some between five to ten

00:17:08,250 --> 00:17:14,789
percent slower than previously and on

00:17:11,970 --> 00:17:18,539
high latency connections with low speed

00:17:14,789 --> 00:17:20,789
say mobile networks we saw greater

00:17:18,539 --> 00:17:23,699
delays in reaching visual completion but

00:17:20,789 --> 00:17:24,990
in all tests the initial paints were

00:17:23,699 --> 00:17:33,330
more complete even though that happened

00:17:24,990 --> 00:17:35,340
much later so to summarize bandwidth

00:17:33,330 --> 00:17:37,350
bound pages sniffing it longer to reach

00:17:35,340 --> 00:17:38,160
visual completion despite loading way

00:17:37,350 --> 00:17:39,930
faster and we

00:17:38,160 --> 00:17:42,120
couldn't figure out why initially this

00:17:39,930 --> 00:17:45,300
was unexpected to us so our first

00:17:42,120 --> 00:17:47,190
hypothesis was network saturation it

00:17:45,300 --> 00:17:50,250
could it be that requesting so many

00:17:47,190 --> 00:17:52,560
things at once and having a single

00:17:50,250 --> 00:17:55,080
connection that could multiplex was that

00:17:52,560 --> 00:17:57,300
draining the training resources away

00:17:55,080 --> 00:17:59,310
from other things in the page like CSS

00:17:57,300 --> 00:18:02,220
and JavaScript that would actually block

00:17:59,310 --> 00:18:03,990
the rendering of the page in your

00:18:02,220 --> 00:18:06,930
typical hp1 water flow you see things

00:18:03,990 --> 00:18:08,400
are staged so things that happen earlier

00:18:06,930 --> 00:18:10,650
in the page tend to be loaded earlier

00:18:08,400 --> 00:18:13,710
and you get a good distribution of

00:18:10,650 --> 00:18:15,210
bandwidth across your requests so

00:18:13,710 --> 00:18:18,300
looking at these Network waterfalls we

00:18:15,210 --> 00:18:19,380
couldn't actually see that happening z

00:18:18,300 --> 00:18:21,090
says with loading when sister should

00:18:19,380 --> 00:18:22,920
load just blowing JavaScript reload

00:18:21,090 --> 00:18:24,090
image loading image should load and they

00:18:22,920 --> 00:18:27,870
think the loading and finishing at the

00:18:24,090 --> 00:18:31,740
same time so our next hypothesis with

00:18:27,870 --> 00:18:34,970
loading priority in h2 be one you have

00:18:31,740 --> 00:18:37,860
this limit of 60 / connections per host

00:18:34,970 --> 00:18:39,690
and this creates that first in first out

00:18:37,860 --> 00:18:41,460
q are talking about where the first

00:18:39,690 --> 00:18:42,900
thing in your page tends to be the first

00:18:41,460 --> 00:18:44,870
thing requested and the first thing

00:18:42,900 --> 00:18:48,090
responded to then things happen in order

00:18:44,870 --> 00:18:49,800
as a result the relation of things in

00:18:48,090 --> 00:18:51,180
your document document tend to be the

00:18:49,800 --> 00:18:52,680
relation of things will load so you have

00:18:51,180 --> 00:18:57,600
some control over the loading order of

00:18:52,680 --> 00:19:00,390
things with HTTP to it's a it allows

00:18:57,600 --> 00:19:01,590
multiple requests and responses over the

00:19:00,390 --> 00:19:04,200
one connection happened at the exact

00:19:01,590 --> 00:19:06,960
same time as a result you don't really

00:19:04,200 --> 00:19:08,910
get that priority anymore everything

00:19:06,960 --> 00:19:10,380
sees you at Oxford at the same time I

00:19:08,910 --> 00:19:11,880
said just give me what you got no figure

00:19:10,380 --> 00:19:13,350
it out and you kind of lose control of

00:19:11,880 --> 00:19:15,240
like what should we loaded first what

00:19:13,350 --> 00:19:18,060
should be loaded last what things are

00:19:15,240 --> 00:19:19,110
more important than others so the

00:19:18,060 --> 00:19:20,730
browsers do you have built-in

00:19:19,110 --> 00:19:22,230
prioritization for this but you lose

00:19:20,730 --> 00:19:24,270
control any document in your document so

00:19:22,230 --> 00:19:25,860
you could very well be that images the

00:19:24,270 --> 00:19:27,090
bottom of the page or given the same

00:19:25,860 --> 00:19:29,940
priorities images on top of the page

00:19:27,090 --> 00:19:34,470
causing those longer-term visual

00:19:29,940 --> 00:19:36,390
completion so part of this we'd consider

00:19:34,470 --> 00:19:38,310
the putting the best practice of putting

00:19:36,390 --> 00:19:39,300
scripts part of our pages was closing

00:19:38,310 --> 00:19:40,950
those scripts to get like a higher

00:19:39,300 --> 00:19:43,950
priority and actually pushing off image

00:19:40,950 --> 00:19:46,740
loading resources but we were able to

00:19:43,950 --> 00:19:48,420
figure out this was in the case because

00:19:46,740 --> 00:19:50,490
don't complete loaded at the same time

00:19:48,420 --> 00:19:52,110
and don't be blocked on these JavaScript

00:19:50,490 --> 00:19:53,580
files so with that being in the same

00:19:52,110 --> 00:19:55,260
place and ask monitoring that we could

00:19:53,580 --> 00:19:57,000
tell that the priority of this group's

00:19:55,260 --> 00:19:59,490
weren't being moved and weren't changing

00:19:57,000 --> 00:20:00,840
the render properties of the page so I

00:19:59,490 --> 00:20:02,040
later came down something happening at

00:20:00,840 --> 00:20:04,080
the network layer things just weren't

00:20:02,040 --> 00:20:07,770
coming to us the way we expected to as

00:20:04,080 --> 00:20:11,120
faster picking to come just release the

00:20:07,770 --> 00:20:13,110
idea of resource priority in practice

00:20:11,120 --> 00:20:16,049
the browsers download queue is

00:20:13,110 --> 00:20:17,790
prioritized so starting a team adding

00:20:16,049 --> 00:20:19,290
image requests before final script

00:20:17,790 --> 00:20:21,420
bottom of the page doesn't delay script

00:20:19,290 --> 00:20:23,730
loading at all these a coding behavioral

00:20:21,420 --> 00:20:25,410
resource is undocumented however it

00:20:23,730 --> 00:20:26,730
constantly changes our pilot problem is

00:20:25,410 --> 00:20:29,220
that browsers have their own heuristics

00:20:26,730 --> 00:20:31,440
in how they load things but typically

00:20:29,220 --> 00:20:32,700
images have very low priority things

00:20:31,440 --> 00:20:34,440
like fonts and java better higher

00:20:32,700 --> 00:20:36,720
priority and one of the interesting

00:20:34,440 --> 00:20:38,940
about is browser heuristics it developed

00:20:36,720 --> 00:20:40,860
by browser vendors over time to suit the

00:20:38,940 --> 00:20:43,770
current trends so an interesting one now

00:20:40,860 --> 00:20:46,440
is the hero image heuristic so images

00:20:43,770 --> 00:20:47,730
get a very low priority browsers will

00:20:46,440 --> 00:20:49,710
find the first image in the page and

00:20:47,730 --> 00:20:51,179
make it a very high priority the idea

00:20:49,710 --> 00:20:52,950
being a lot of sites have is big hero

00:20:51,179 --> 00:20:54,150
image and that should load first and

00:20:52,950 --> 00:20:57,809
given the same priority assists in

00:20:54,150 --> 00:21:00,270
JavaScript so knowing these heuristics

00:20:57,809 --> 00:21:04,230
are in play we want to look at the

00:21:00,270 --> 00:21:06,179
stream without that limit of six

00:21:04,230 --> 00:21:07,799
connections person we get HTTP one we

00:21:06,179 --> 00:21:10,080
could see ad image requests all firing

00:21:07,799 --> 00:21:11,250
ones to the server and the server would

00:21:10,080 --> 00:21:12,929
then respond to them simultaneously

00:21:11,250 --> 00:21:14,790
because they wouldn't know which was

00:21:12,929 --> 00:21:17,660
more important than the other and the

00:21:14,790 --> 00:21:19,950
browser would draw them as they came in

00:21:17,660 --> 00:21:22,679
this had an interesting effect and we

00:21:19,950 --> 00:21:26,130
see something like this comparing HTTP

00:21:22,679 --> 00:21:28,770
one and HTTP two we'd see that the HTTP

00:21:26,130 --> 00:21:30,990
one page was drawing this image on the

00:21:28,770 --> 00:21:33,660
fire image much slower which meant that

00:21:30,990 --> 00:21:35,280
it was getting the packets much slower

00:21:33,660 --> 00:21:37,799
but we knew that these pages were

00:21:35,280 --> 00:21:41,070
finishing to load generally much faster

00:21:37,799 --> 00:21:43,140
which led us into the area that let us

00:21:41,070 --> 00:21:44,970
down the track of thinking that there

00:21:43,140 --> 00:21:46,350
was some sort of bandwidth contention in

00:21:44,970 --> 00:21:47,970
that the browser was treating all images

00:21:46,350 --> 00:21:49,230
equally so there were images much

00:21:47,970 --> 00:21:52,200
further down the page that were being

00:21:49,230 --> 00:21:54,480
rendered and parse problem comes down to

00:21:52,200 --> 00:21:56,549
is if all images are the same size and

00:21:54,480 --> 00:21:58,169
the bandwidth distributed equally they

00:21:56,549 --> 00:22:00,090
should all load equally and this page

00:21:58,169 --> 00:22:02,700
would have been faster but in this case

00:22:00,090 --> 00:22:03,970
this image on the right is slightly

00:22:02,700 --> 00:22:06,210
larger than a 200

00:22:03,970 --> 00:22:08,260
left and as a result it has a different

00:22:06,210 --> 00:22:09,370
requires more data and is then drawn

00:22:08,260 --> 00:22:11,380
differently as different loading

00:22:09,370 --> 00:22:12,700
characteristics and because the

00:22:11,380 --> 00:22:14,940
bandwidth is being distributed to pages

00:22:12,700 --> 00:22:17,770
images off the page we see this kind of

00:22:14,940 --> 00:22:20,260
phased loading much slower than an HTTP

00:22:17,770 --> 00:22:21,820
one which had a baked in priority saying

00:22:20,260 --> 00:22:25,750
this image is more important than images

00:22:21,820 --> 00:22:28,240
down the bottom of the page um so there

00:22:25,750 --> 00:22:30,700
is some fine print with htp really not

00:22:28,240 --> 00:22:32,920
many people talking about an allegra

00:22:30,700 --> 00:22:35,500
goreck of the chrome team said this

00:22:32,920 --> 00:22:36,970
really well I with HTTP to the browser

00:22:35,500 --> 00:22:40,780
relies on the server I to deliver the

00:22:36,970 --> 00:22:42,490
responses in optimal way it's not just a

00:22:40,780 --> 00:22:44,050
number of bytes or requests per second

00:22:42,490 --> 00:22:46,990
by the order in which the bites are

00:22:44,050 --> 00:22:50,620
delivered near test rotation carefully

00:22:46,990 --> 00:22:53,440
the these loading heuristics that exists

00:22:50,620 --> 00:22:56,400
are undocumented and they're

00:22:53,440 --> 00:22:59,710
undocumented on purpose the idea is that

00:22:56,400 --> 00:23:00,910
browser vendors can choose what

00:22:59,710 --> 00:23:02,560
heuristics work better for their

00:23:00,910 --> 00:23:05,070
customers in their environments they can

00:23:02,560 --> 00:23:07,540
analyze that I'm they know better and

00:23:05,070 --> 00:23:08,920
they differ between versions a change in

00:23:07,540 --> 00:23:11,410
a heuristic in a version can actually

00:23:08,920 --> 00:23:13,900
improve certain sites but significant

00:23:11,410 --> 00:23:15,280
affect other sites and they're not

00:23:13,900 --> 00:23:17,140
documented and they're not told about

00:23:15,280 --> 00:23:20,320
these things and have a general for all

00:23:17,140 --> 00:23:21,850
sites so what is good for a big hero

00:23:20,320 --> 00:23:23,380
image may not be good for a site that is

00:23:21,850 --> 00:23:27,970
an app were single page app and these

00:23:23,380 --> 00:23:30,430
are concerns gotta be balanced so HTTP

00:23:27,970 --> 00:23:32,380
to took this shift and says as a

00:23:30,430 --> 00:23:34,150
developer on your site you know it's

00:23:32,380 --> 00:23:36,550
best for your site I change the

00:23:34,150 --> 00:23:37,930
landscape of resource prioritization the

00:23:36,550 --> 00:23:40,660
responsibilities now shared between the

00:23:37,930 --> 00:23:43,960
browser and the server the browser gives

00:23:40,660 --> 00:23:45,970
the server hints unlike this stream so

00:23:43,960 --> 00:23:47,620
it knows the stream of serving image

00:23:45,970 --> 00:23:49,420
user says this stream has a priority

00:23:47,620 --> 00:23:52,120
much lower than the priority of the

00:23:49,420 --> 00:23:54,460
stream serving CSS and that is low on

00:23:52,120 --> 00:23:55,870
the stream serving JavaScript as an

00:23:54,460 --> 00:23:57,850
option the browser has whether it works

00:23:55,870 --> 00:24:00,160
that way is different and most streams

00:23:57,850 --> 00:24:02,890
tend to be the same for the time being

00:24:00,160 --> 00:24:04,870
it's a change between browsers but this

00:24:02,890 --> 00:24:07,960
is the server can ignore that the server

00:24:04,870 --> 00:24:10,210
can just say actually I know that on

00:24:07,960 --> 00:24:12,190
this page we have lots of images so

00:24:10,210 --> 00:24:14,080
these get a higher priority than the

00:24:12,190 --> 00:24:15,490
JavaScript that affects a button at the

00:24:14,080 --> 00:24:16,820
bottom of the page and you can build

00:24:15,490 --> 00:24:18,679
that control into your own server

00:24:16,820 --> 00:24:19,909
in practice is much harder because he

00:24:18,679 --> 00:24:21,710
sent you to see the anodyne are in these

00:24:19,909 --> 00:24:23,360
servers yourself but if you run her own

00:24:21,710 --> 00:24:24,769
HTTP servers you can put in your own

00:24:23,360 --> 00:24:28,399
heuristics and it's option you now have

00:24:24,769 --> 00:24:30,460
and she didn't have with HTTP one but

00:24:28,399 --> 00:24:32,720
this ends up being a double-edged sword

00:24:30,460 --> 00:24:34,639
resource prioritization existing in both

00:24:32,720 --> 00:24:37,100
the client and the server I can really

00:24:34,639 --> 00:24:41,480
muddy the waters and open up way more

00:24:37,100 --> 00:24:42,679
problems we weren't aware of and put but

00:24:41,480 --> 00:24:44,149
it does give the ability put the

00:24:42,679 --> 00:24:45,590
developer in charge and the developer

00:24:44,149 --> 00:24:48,019
who knows their site can do really great

00:24:45,590 --> 00:24:49,789
things I previously hinted at the idea

00:24:48,019 --> 00:24:52,909
of weights and weight as a hint the

00:24:49,789 --> 00:24:55,250
browser gives at priority this happens

00:24:52,909 --> 00:24:57,139
in HTTP one where the browser uses the

00:24:55,250 --> 00:25:00,049
idea of priority to then determine what

00:24:57,139 --> 00:25:01,940
order to send requests in in HTTP two we

00:25:00,049 --> 00:25:03,620
send all requests the same time but we

00:25:01,940 --> 00:25:05,269
apply a weight signifying its priority

00:25:03,620 --> 00:25:06,769
something with a lower weight has less

00:25:05,269 --> 00:25:08,360
priority and should get less bandwidth

00:25:06,769 --> 00:25:10,490
there's something of a higher weight so

00:25:08,360 --> 00:25:12,440
images ver CSS for a sponsor JavaScript

00:25:10,490 --> 00:25:13,940
the browser can assign these different

00:25:12,440 --> 00:25:17,419
streams and different weights and saying

00:25:13,940 --> 00:25:19,789
these are more important than others the

00:25:17,419 --> 00:25:21,289
servers fries with more all that if you

00:25:19,789 --> 00:25:25,820
don't control eserver it's on you to

00:25:21,289 --> 00:25:27,740
test your service actually doing and

00:25:25,820 --> 00:25:29,690
dependencies so dependencies are

00:25:27,740 --> 00:25:32,950
interesting and one of the big things if

00:25:29,690 --> 00:25:35,539
HTTP two streams in that we can say that

00:25:32,950 --> 00:25:36,860
although something is important it's

00:25:35,539 --> 00:25:40,009
only important if its parent has already

00:25:36,860 --> 00:25:41,690
loaded this allows you to say that here

00:25:40,009 --> 00:25:42,710
all the JavaScript files on my site but

00:25:41,690 --> 00:25:44,779
don't wasn't loading anything else

00:25:42,710 --> 00:25:46,460
you've loaded jQuery or here are the

00:25:44,779 --> 00:25:47,960
images on my site but these three at the

00:25:46,460 --> 00:25:49,639
top of the page are way more important

00:25:47,960 --> 00:25:55,009
to 32 bottom of the page and you can

00:25:49,639 --> 00:25:56,480
describe this with dependencies so some

00:25:55,009 --> 00:25:58,309
of the takeaways my investigation was

00:25:56,480 --> 00:25:59,750
simply that there's no such thing as

00:25:58,309 --> 00:26:01,039
free performance and this is something

00:25:59,750 --> 00:26:04,029
our browser vendors have known for a

00:26:01,039 --> 00:26:08,029
very long time web performance is a

00:26:04,029 --> 00:26:11,500
series of trade-offs and new ones any

00:26:08,029 --> 00:26:14,299
heavy image-heavy pages tend to prefer

00:26:11,500 --> 00:26:17,450
HTTP two connections only when the bat

00:26:14,299 --> 00:26:19,909
total bandwidth is less than the latency

00:26:17,450 --> 00:26:22,429
incurred if your server lab which

00:26:19,909 --> 00:26:23,929
bandwidth if your bandwidth is less than

00:26:22,429 --> 00:26:25,159
the latency would have incurred then you

00:26:23,929 --> 00:26:26,960
gain a lot running single long live

00:26:25,159 --> 00:26:28,850
connection if you're very bound with

00:26:26,960 --> 00:26:31,580
heavy reducing latency

00:26:28,850 --> 00:26:33,860
actually save you that much so it's the

00:26:31,580 --> 00:26:36,530
right mix of high latency and low

00:26:33,860 --> 00:26:38,210
bandwidth you can see really big against

00:26:36,530 --> 00:26:41,780
and these are the site lots of small CSS

00:26:38,210 --> 00:26:43,220
files a lot of small images another

00:26:41,780 --> 00:26:45,290
thing to take away from this is HTTP two

00:26:43,220 --> 00:26:48,080
is very new and the surface area for the

00:26:45,290 --> 00:26:49,940
protocol is huge you have resource

00:26:48,080 --> 00:26:51,680
weight prioritization you have resource

00:26:49,940 --> 00:26:54,020
dependency prioritization you have

00:26:51,680 --> 00:26:57,490
multiplicity heuristics and you have

00:26:54,020 --> 00:26:59,240
streamer connection flows these things

00:26:57,490 --> 00:27:01,130
although the implementation is

00:26:59,240 --> 00:27:04,850
documented the heuristics art it's

00:27:01,130 --> 00:27:07,010
really free to you as developers for

00:27:04,850 --> 00:27:08,990
sites people who building servers CDN

00:27:07,010 --> 00:27:10,910
owners as on all of you to figure out

00:27:08,990 --> 00:27:14,540
what is best for your situation of your

00:27:10,910 --> 00:27:15,830
audience I hope and there is work in

00:27:14,540 --> 00:27:18,830
browsers coming through to hint at these

00:27:15,830 --> 00:27:20,420
so for you in markup or in JavaScript be

00:27:18,830 --> 00:27:21,410
able to say these resources are more

00:27:20,420 --> 00:27:23,120
important than others and have some

00:27:21,410 --> 00:27:26,150
control over that or that appears to be

00:27:23,120 --> 00:27:28,730
a while off just yet and there are other

00:27:26,150 --> 00:27:30,730
glaring issues with hd2 that make this

00:27:28,730 --> 00:27:33,290
really hard one is a lack of visibility

00:27:30,730 --> 00:27:35,120
HTTP to unlock a should be one is a

00:27:33,290 --> 00:27:36,800
binary protocol it's no longer clear

00:27:35,120 --> 00:27:38,690
text over the wire you can't look at

00:27:36,800 --> 00:27:40,550
what's happening requires specialized

00:27:38,690 --> 00:27:43,400
tools and because it all happens over a

00:27:40,550 --> 00:27:45,530
ssl it requires either man in building

00:27:43,400 --> 00:27:48,050
your connection or doing it manually via

00:27:45,530 --> 00:27:51,680
some sort of CLI that gives you access

00:27:48,050 --> 00:27:53,330
to emulate a browser and dev tools

00:27:51,680 --> 00:27:55,250
simply haven't caught up here they have

00:27:53,330 --> 00:27:58,370
the information but it's very hard to

00:27:55,250 --> 00:28:00,470
show to show in the dev console our

00:27:58,370 --> 00:28:02,450
minds are programmed our experiences

00:28:00,470 --> 00:28:03,860
print program to waterfalls of HTTP one

00:28:02,450 --> 00:28:05,840
let us really apply history between

00:28:03,860 --> 00:28:07,520
Timor and as a while all the tools still

00:28:05,840 --> 00:28:10,100
catching up for a long time tools

00:28:07,520 --> 00:28:11,990
reporting collection times being wrong

00:28:10,100 --> 00:28:15,620
because of the way then attempted SSL

00:28:11,990 --> 00:28:17,390
and these issues are bound and as I

00:28:15,620 --> 00:28:20,270
mentioned the binary protocol makes it

00:28:17,390 --> 00:28:22,880
very hard to sniff what's happening you

00:28:20,270 --> 00:28:24,890
can only have a good intuition of what

00:28:22,880 --> 00:28:26,510
what's been what's being sent you can no

00:28:24,890 --> 00:28:28,340
longer you can't easily inspect the

00:28:26,510 --> 00:28:29,990
heuristic supplier you can't see the

00:28:28,340 --> 00:28:32,060
server's prioritizing something over

00:28:29,990 --> 00:28:34,220
something else what order their packets

00:28:32,060 --> 00:28:35,390
are coming in and that's multiplexing

00:28:34,220 --> 00:28:39,170
payback we really important and have

00:28:35,390 --> 00:28:40,909
really subtle effects so there's some

00:28:39,170 --> 00:28:44,889
great resources in this area

00:28:40,909 --> 00:28:47,389
HTTP to 101 is a quick video by soma

00:28:44,889 --> 00:28:50,119
hopeful most high-performance browser

00:28:47,389 --> 00:28:51,710
networking is must read for anyone who

00:28:50,119 --> 00:28:53,599
work in sac performance or you care a

00:28:51,710 --> 00:28:55,309
sub performance earlier gorica the

00:28:53,599 --> 00:28:57,529
chrome team covers loaders material and

00:28:55,309 --> 00:28:59,419
way more detail and is responsible for

00:28:57,529 --> 00:29:02,749
much material in the beginning of this

00:28:59,419 --> 00:29:05,659
talk has to be to hear is less optimized

00:29:02,749 --> 00:29:07,009
is a one hour long talk by Alico gorrik

00:29:05,659 --> 00:29:11,840
it's definitely worth watching but is

00:29:07,009 --> 00:29:13,789
very in-depth HD 1.5 HP to an 1.5 world

00:29:11,840 --> 00:29:15,739
by peter wilson this is a great talk or

00:29:13,789 --> 00:29:18,320
not chopping on HP to train just yet and

00:29:15,739 --> 00:29:19,609
some of the trade-offs and keeping in

00:29:18,320 --> 00:29:23,470
mind that many of our users are still on

00:29:19,609 --> 00:29:25,789
HP one it will be for visible future and

00:29:23,470 --> 00:29:28,309
this is a blog post i wrote that goes

00:29:25,789 --> 00:29:30,919
into many of the things we ran into

00:29:28,309 --> 00:29:32,509
secure the hd2 in more detail and some

00:29:30,919 --> 00:29:36,859
more waterfalls at some of the quizzes

00:29:32,509 --> 00:29:39,129
we came to and thank you that is the

00:29:36,859 --> 00:29:39,129
wrong way

00:29:46,590 --> 00:29:48,650

YouTube URL: https://www.youtube.com/watch?v=3WIDa5-bPDs


