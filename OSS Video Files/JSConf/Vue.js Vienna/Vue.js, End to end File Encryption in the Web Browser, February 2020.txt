Title: Vue.js, End to end File Encryption in the Web Browser, February 2020
Publication date: 2020-02-15
Playlist: Vue.js Vienna
Description: 
	Talk by Thomas Konrad,


Ever thought that encrypting uploaded files in the web browser before it hits the server? Most web browsers nowadays offer encryption modules via the Web Crypto API for the encryption itself, but we’ll soon see that this isn’t enough. What about the correct cipher modes? How can we ensure confidentiality, integrity and authenticity? What about big files and limited memory availability?
Captions: 
	00:00:00,000 --> 00:00:04,680
had a good evening and welcome to the

00:00:02,100 --> 00:00:06,270
second talk of today's Meetup and I'm

00:00:04,680 --> 00:00:08,610
going to talk about an tell file

00:00:06,270 --> 00:00:10,080
encryption in the web browser now this

00:00:08,610 --> 00:00:11,790
is not about animations it's about

00:00:10,080 --> 00:00:14,340
something going on in the background and

00:00:11,790 --> 00:00:15,540
making stuff secure so maybe Samuel and

00:00:14,340 --> 00:00:19,189
me can team up and make something

00:00:15,540 --> 00:00:22,289
beautiful and secure that would be cool

00:00:19,189 --> 00:00:24,390
I'm Tom I work for a company called SBA

00:00:22,289 --> 00:00:26,250
research which is a Research Center for

00:00:24,390 --> 00:00:28,260
information security and I work in the

00:00:26,250 --> 00:00:30,330
software security team where I do stuff

00:00:28,260 --> 00:00:33,270
like penetration testing secure

00:00:30,330 --> 00:00:35,460
development lifecycle related things I

00:00:33,270 --> 00:00:38,399
do also some software development I have

00:00:35,460 --> 00:00:40,020
a little pet project which we use a web

00:00:38,399 --> 00:00:42,360
application that we use to exchange

00:00:40,020 --> 00:00:43,680
sensitive files with our customers for

00:00:42,360 --> 00:00:45,930
example and this is where we encrypt

00:00:43,680 --> 00:00:47,730
stuff in a web browser and that's what

00:00:45,930 --> 00:00:49,680
I'm gonna show you okay how we do this

00:00:47,730 --> 00:00:51,149
I'm also one of the founders of the sack

00:00:49,680 --> 00:00:53,699
for Def Con furan sin boot camp which I

00:00:51,149 --> 00:00:54,210
presented in the beginning and this is

00:00:53,699 --> 00:01:00,440
Olivia

00:00:54,210 --> 00:01:02,640
our mascot cool so what we'd like to do

00:01:00,440 --> 00:01:04,500
we would like to encrypt the files

00:01:02,640 --> 00:01:06,229
before they are uploaded to the server

00:01:04,500 --> 00:01:08,490
so we're not going to upload something

00:01:06,229 --> 00:01:09,630
via a secure channel and then store it

00:01:08,490 --> 00:01:11,400
somewhere in a server and encrypt it

00:01:09,630 --> 00:01:12,990
there or leave it unencrypted there we

00:01:11,400 --> 00:01:14,700
want to equipt stuff before it leaves

00:01:12,990 --> 00:01:17,070
the browser so that's the basic

00:01:14,700 --> 00:01:19,170
requirement I have to admit I didn't

00:01:17,070 --> 00:01:20,820
invent this okay

00:01:19,170 --> 00:01:23,460
there is a web application called

00:01:20,820 --> 00:01:24,900
Firefox end which is very cool you can

00:01:23,460 --> 00:01:28,140
use to exchange files with other people

00:01:24,900 --> 00:01:31,079
they use and - and file encryption for

00:01:28,140 --> 00:01:32,670
this purpose and the basic context that

00:01:31,079 --> 00:01:34,799
I'm gonna presented this talk are taken

00:01:32,670 --> 00:01:36,090
from there ok so if you want to have a

00:01:34,799 --> 00:01:37,650
look at the source code at work in

00:01:36,090 --> 00:01:38,579
example source code you can have a look

00:01:37,650 --> 00:01:40,860
at this source code because it's

00:01:38,579 --> 00:01:43,020
basically the same console concepts you

00:01:40,860 --> 00:01:44,310
can reach it under Sam Firefox comm is

00:01:43,020 --> 00:01:48,229
really good stuff if you want to share

00:01:44,310 --> 00:01:51,119
stuff securely with your peers use this

00:01:48,229 --> 00:01:53,220
so the requirements first I want to

00:01:51,119 --> 00:01:55,740
ensure confidentiality integrity and

00:01:53,220 --> 00:01:58,460
authenticity all three things with my

00:01:55,740 --> 00:02:01,110
files not just confidentiality but also

00:01:58,460 --> 00:02:03,810
authenticity so I want if somebody has

00:02:01,110 --> 00:02:05,969
the key to a file only those people are

00:02:03,810 --> 00:02:07,710
allowed to upload stuff ok nothing can

00:02:05,969 --> 00:02:09,690
be manipulated on the way that's an

00:02:07,710 --> 00:02:11,370
important requirement I want to do it in

00:02:09,690 --> 00:02:13,200
a browser as I said not only when it

00:02:11,370 --> 00:02:15,780
hits the server but before that

00:02:13,200 --> 00:02:17,670
I want to support big files so I want to

00:02:15,780 --> 00:02:19,290
upload and download files that are say

00:02:17,670 --> 00:02:21,720
for example bigger than 10 gigabytes

00:02:19,290 --> 00:02:23,580
this is going to be and very important

00:02:21,720 --> 00:02:25,470
in challenging requirements because I

00:02:23,580 --> 00:02:27,629
cannot encrypt stuff in the browser all

00:02:25,470 --> 00:02:30,420
at once because that would use 10

00:02:27,629 --> 00:02:32,700
gigabytes times 2 of memory which we

00:02:30,420 --> 00:02:33,989
basically usually don't have available

00:02:32,700 --> 00:02:35,220
in the browser so that's gonna be a big

00:02:33,989 --> 00:02:37,800
challenge that's why I stated as a

00:02:35,220 --> 00:02:40,650
separate requirement here and we want to

00:02:37,800 --> 00:02:43,860
support old browsers as well as as well

00:02:40,650 --> 00:02:46,170
as possible and I want to find a way to

00:02:43,860 --> 00:02:48,810
securely distribute keys via a link so I

00:02:46,170 --> 00:02:51,180
want to send you guys a link but I don't

00:02:48,810 --> 00:02:53,390
want to this the key part of the link to

00:02:51,180 --> 00:02:56,160
be sent to the browser because that

00:02:53,390 --> 00:02:57,989
would break the authenticity and and

00:02:56,160 --> 00:03:00,420
confidentiality requirement again ok so

00:02:57,989 --> 00:03:01,769
that's the last part cool so let's have

00:03:00,420 --> 00:03:03,030
a look at the first requirement

00:03:01,769 --> 00:03:08,010
confidentiality integrity and

00:03:03,030 --> 00:03:10,380
authenticity now before we go to you

00:03:08,010 --> 00:03:12,480
know taking keys to encrypt something we

00:03:10,380 --> 00:03:15,150
need to generate keys and generating

00:03:12,480 --> 00:03:16,950
keys in a secure way means using a

00:03:15,150 --> 00:03:18,660
secure random number generator so

00:03:16,950 --> 00:03:20,850
randomness is the most important thing

00:03:18,660 --> 00:03:27,299
here do you think this is a random

00:03:20,850 --> 00:03:28,620
number we can't say whether it's a

00:03:27,299 --> 00:03:33,060
random number or not is this a random

00:03:28,620 --> 00:03:34,980
number could be I don't know I don't

00:03:33,060 --> 00:03:37,109
know it could be randomly generated now

00:03:34,980 --> 00:03:38,819
the important thing is there isn't no

00:03:37,109 --> 00:03:42,150
such thing as a random number there are

00:03:38,819 --> 00:03:44,310
only ways to generate random numbers a

00:03:42,150 --> 00:03:47,389
guy called John from Romans said that in

00:03:44,310 --> 00:03:49,350
1961 so pretty long time ago

00:03:47,389 --> 00:03:53,190
mathematician Hungarian American

00:03:49,350 --> 00:03:55,230
mathematician who was dealing with those

00:03:53,190 --> 00:03:58,109
things now if you want to generate a

00:03:55,230 --> 00:04:00,180
secure random number secure random bytes

00:03:58,109 --> 00:04:03,060
in the web browser you can use web

00:04:00,180 --> 00:04:06,450
crypto for that purpose okay that's

00:04:03,060 --> 00:04:11,459
called you can see the code here in the

00:04:06,450 --> 00:04:13,169
middle crypto get random values and you

00:04:11,459 --> 00:04:15,630
can state the length of that random

00:04:13,169 --> 00:04:19,700
value in bytes down here so if you want

00:04:15,630 --> 00:04:22,530
a so for example 120 bit random number

00:04:19,700 --> 00:04:24,770
you would state how many bytes would

00:04:22,530 --> 00:04:24,770
that be

00:04:25,750 --> 00:04:36,550
128 bits are how many bytes any guesses

00:04:31,510 --> 00:04:39,060
I will say higher or lower it's 16 bytes

00:04:36,550 --> 00:04:43,360
okay a 16 byte random number would beat

00:04:39,060 --> 00:04:45,430
128 bit random number okay so we have

00:04:43,360 --> 00:04:47,770
that first very important requirement we

00:04:45,430 --> 00:04:49,600
want we need random numbers truly random

00:04:47,770 --> 00:04:51,430
numbers cryptographically secure random

00:04:49,600 --> 00:04:53,980
numbers and then we have to choose an

00:04:51,430 --> 00:04:56,470
algorithm to symmetrically encrypt the

00:04:53,980 --> 00:04:58,450
files now let's take as an example a

00:04:56,470 --> 00:05:00,850
very popular algorithm in a very popular

00:04:58,450 --> 00:05:03,790
mode a AES advanced encryption standard

00:05:00,850 --> 00:05:06,370
in CBC mode cipher block chaining mode

00:05:03,790 --> 00:05:07,260
now we have three things that we want to

00:05:06,370 --> 00:05:10,450
ensure we said in the beginning

00:05:07,260 --> 00:05:12,400
confidentiality question to you guys can

00:05:10,450 --> 00:05:18,850
a AES in a CBC mode ensure

00:05:12,400 --> 00:05:23,080
confidentiality you say no yes not sure

00:05:18,850 --> 00:05:24,820
I see yes so if you security distribute

00:05:23,080 --> 00:05:27,520
the keys and everything is okay with us

00:05:24,820 --> 00:05:29,800
using the algorithm basically AES can a

00:05:27,520 --> 00:05:31,840
yes in CBC mode the motors are important

00:05:29,800 --> 00:05:36,430
can ensure confidentiality

00:05:31,840 --> 00:05:39,010
how about integrity can we make sure

00:05:36,430 --> 00:05:41,160
that if I encrypt something here let's

00:05:39,010 --> 00:05:44,229
say I have distributed the keys before

00:05:41,160 --> 00:05:47,320
you and me we have we have both our keys

00:05:44,229 --> 00:05:51,010
the same key and no one has knows that

00:05:47,320 --> 00:05:53,530
key I encrypt something here and I send

00:05:51,010 --> 00:05:55,390
it over to you if there is an

00:05:53,530 --> 00:05:57,760
eavesdropper in the middle can they

00:05:55,390 --> 00:05:59,470
manipulate the data or can they not

00:05:57,760 --> 00:06:02,160
manipulate the data without you not

00:05:59,470 --> 00:06:02,160
noticing it

00:06:07,150 --> 00:06:10,960
so you're right I cannot ensure

00:06:09,070 --> 00:06:13,240
integrity somebody could manipulate the

00:06:10,960 --> 00:06:15,639
data on the wire you would not notice

00:06:13,240 --> 00:06:17,919
the decryption would not fail there is

00:06:15,639 --> 00:06:20,919
no exception thrown or anything you

00:06:17,919 --> 00:06:23,260
might get garbage but it doesn't fail

00:06:20,919 --> 00:06:25,270
and if I can't ensure integrity

00:06:23,260 --> 00:06:26,620
I can't ensure authenticity neither

00:06:25,270 --> 00:06:28,960
because I think if I can manipulate

00:06:26,620 --> 00:06:41,199
something authenticity and integrity are

00:06:28,960 --> 00:06:42,760
screwed I can ensure now if somebody

00:06:41,199 --> 00:06:45,370
breaks onto into the server and breaches

00:06:42,760 --> 00:06:47,710
all the data that's on the server they

00:06:45,370 --> 00:06:50,199
can still read the files that's what you

00:06:47,710 --> 00:06:52,660
mentioned TLS transport security is only

00:06:50,199 --> 00:06:55,000
encrypting the data on the transport

00:06:52,660 --> 00:06:55,990
layer if it's stored somewhere on the

00:06:55,000 --> 00:06:58,539
server in the file system its

00:06:55,990 --> 00:07:01,360
unencrypted in a normal and usual file

00:06:58,539 --> 00:07:03,310
upload say I was I want to make sure

00:07:01,360 --> 00:07:06,130
that even though the server's breached

00:07:03,310 --> 00:07:10,660
I still am in control of the

00:07:06,130 --> 00:07:15,130
confidentiality the data okay you will

00:07:10,660 --> 00:07:17,080
see later okay so a ESS CBC mode is

00:07:15,130 --> 00:07:18,729
considered a secure algorithm in a

00:07:17,080 --> 00:07:21,990
secure mode but in fact it's not really

00:07:18,729 --> 00:07:25,870
I'm gonna show you why that is the case

00:07:21,990 --> 00:07:28,690
so I echo some data

00:07:25,870 --> 00:07:31,180
bla bla bla something-something and then

00:07:28,690 --> 00:07:36,160
a new line and then let's eat , grandpa

00:07:31,180 --> 00:07:39,010
into a text file okay now I use open SSL

00:07:36,160 --> 00:07:41,710
in the encryption mode you see that it's

00:07:39,010 --> 00:07:45,849
encryption with the dash in here which

00:07:41,710 --> 00:07:48,520
just some key and I use AES with 128

00:07:45,849 --> 00:07:52,810
bits in length and CBC mode encrypt the

00:07:48,520 --> 00:07:55,210
data okay just let's convert this binary

00:07:52,810 --> 00:07:59,560
data into hexadecimal data so that can

00:07:55,210 --> 00:08:02,680
easier read it cipher text dot hex so

00:07:59,560 --> 00:08:04,930
this is the encrypted data okay cool now

00:08:02,680 --> 00:08:09,849
I will manipulate a little part over

00:08:04,930 --> 00:08:12,580
here and see what happens first I have

00:08:09,849 --> 00:08:16,630
to convert this back to hex into a bin

00:08:12,580 --> 00:08:18,909
file and then again I use open SSL in

00:08:16,630 --> 00:08:20,030
the decrypt mode which you can see with

00:08:18,909 --> 00:08:23,750
the dash D

00:08:20,030 --> 00:08:26,270
lower left and then I opened the

00:08:23,750 --> 00:08:29,750
plaintext and what happens is let's eat

00:08:26,270 --> 00:08:31,490
grandpa there is no comma you're

00:08:29,750 --> 00:08:33,350
supposed to laugh now but I know this is

00:08:31,490 --> 00:08:35,510
really sad because we all were relying

00:08:33,350 --> 00:08:37,280
on AES CBC for authenticity and

00:08:35,510 --> 00:08:40,370
integrity of an effect we're not I feel

00:08:37,280 --> 00:08:42,260
you okay I feel you

00:08:40,370 --> 00:08:45,680
we have manipulated the cypher text

00:08:42,260 --> 00:08:47,330
without decryption failing so integrity

00:08:45,680 --> 00:08:49,880
and authenticity are not ensured in this

00:08:47,330 --> 00:08:53,450
case okay just keep that in mind now the

00:08:49,880 --> 00:08:57,800
solution to this would be using a cypher

00:08:53,450 --> 00:09:00,470
in a EAD mode authenticated encryption

00:08:57,800 --> 00:09:02,180
with Associated data that just means

00:09:00,470 --> 00:09:04,430
stuff is encrypted and there's an

00:09:02,180 --> 00:09:07,340
authentication code calculated at the

00:09:04,430 --> 00:09:10,490
same time it's like using a SC b c plus

00:09:07,340 --> 00:09:12,080
h mac for example and that message

00:09:10,490 --> 00:09:14,720
authentication code is appended at the

00:09:12,080 --> 00:09:16,700
end of the cipher text so there's also

00:09:14,720 --> 00:09:18,200
authentication now if i manipulate

00:09:16,700 --> 00:09:19,640
something on the way the data is

00:09:18,200 --> 00:09:21,470
manipulated on the way and you decrypt

00:09:19,640 --> 00:09:23,030
it on the other side the crypt is going

00:09:21,470 --> 00:09:25,940
to fail because it's gonna notice that

00:09:23,030 --> 00:09:28,340
something changed okay so if you have

00:09:25,940 --> 00:09:30,950
the choice take one of those two ciphers

00:09:28,340 --> 00:09:33,710
over there on a bottom es GCM Galois

00:09:30,950 --> 00:09:35,540
counter mode which is an AEA d cipher or

00:09:33,710 --> 00:09:39,830
if you're a crypto hipster take cha-cha

00:09:35,540 --> 00:09:43,520
20 poly 1305 the most stupid crypto name

00:09:39,830 --> 00:09:46,310
ever but that is a cool algorithm it's

00:09:43,520 --> 00:09:50,180
very it's very solid ok so if you have

00:09:46,310 --> 00:09:52,640
two choice take one of those two cool so

00:09:50,180 --> 00:09:54,410
we now we basically we have the basic

00:09:52,640 --> 00:09:56,750
knowledge to ensure not only

00:09:54,410 --> 00:09:59,720
confidentiality but also integrity and

00:09:56,750 --> 00:10:01,130
authenticity of our data cool now we

00:09:59,720 --> 00:10:03,710
want to encrypt the files in our browser

00:10:01,130 --> 00:10:06,740
using that knowledge we already learned

00:10:03,710 --> 00:10:08,360
how to generate random keys random

00:10:06,740 --> 00:10:11,030
numbers truly random numbers in the

00:10:08,360 --> 00:10:15,260
browser now we want to learn how to

00:10:11,030 --> 00:10:16,670
encrypt data in the browser now the

00:10:15,260 --> 00:10:18,260
first thing we need to do when we have

00:10:16,670 --> 00:10:20,210
this random key that random number we

00:10:18,260 --> 00:10:23,890
have to import that key first you can

00:10:20,210 --> 00:10:28,340
see that down here we use web crypto and

00:10:23,890 --> 00:10:32,270
the function import key okay we take the

00:10:28,340 --> 00:10:32,880
Rakhi and what we get back is a crypto

00:10:32,270 --> 00:10:35,670
key of

00:10:32,880 --> 00:10:37,800
checked and that cryptically object we

00:10:35,670 --> 00:10:39,120
can use now to encrypt stuff we can

00:10:37,800 --> 00:10:42,360
encrypt the string we can encrypt the

00:10:39,120 --> 00:10:44,520
file we can include anything so over

00:10:42,360 --> 00:10:47,880
here next slide you can see that using

00:10:44,520 --> 00:10:50,730
crypto encrypt we can use that secret

00:10:47,880 --> 00:10:53,820
key and as an algorithm as we saw on a

00:10:50,730 --> 00:10:55,380
previous slide we choose AES GCM because

00:10:53,820 --> 00:10:57,540
that's an authenticated encryption with

00:10:55,380 --> 00:10:59,910
associated data a EAD cipher which is

00:10:57,540 --> 00:11:02,520
cool all the others are not so cool or

00:10:59,910 --> 00:11:04,890
many others are not so cool well the

00:11:02,520 --> 00:11:07,920
same goes for decrypt as you know with

00:11:04,890 --> 00:11:09,780
symmetric encryption like with AES we

00:11:07,920 --> 00:11:10,350
use the same key for both encryption and

00:11:09,780 --> 00:11:12,090
decryption

00:11:10,350 --> 00:11:14,640
that's what symmetric encryption is all

00:11:12,090 --> 00:11:17,820
about which is say crypto subtle dot

00:11:14,640 --> 00:11:19,620
decrypt using the same secret key so

00:11:17,820 --> 00:11:21,990
these are the Chava script API is that

00:11:19,620 --> 00:11:24,770
you can use to encrypt and to decrypt

00:11:21,990 --> 00:11:27,180
data in a web browser

00:11:24,770 --> 00:11:29,310
okay so when we basically know how to

00:11:27,180 --> 00:11:31,020
encrypt and decrypt stuff we know which

00:11:29,310 --> 00:11:34,470
algorithms to use we know which

00:11:31,020 --> 00:11:35,150
JavaScript API is to use in that for

00:11:34,470 --> 00:11:38,520
that scenario

00:11:35,150 --> 00:11:41,850
now comes the harder part we want to

00:11:38,520 --> 00:11:43,260
support big files we want to upload and

00:11:41,850 --> 00:11:44,820
download files that are maybe 10

00:11:43,260 --> 00:11:46,710
gigabytes in size or even bigger than

00:11:44,820 --> 00:11:49,380
that now that's a big challenge because

00:11:46,710 --> 00:11:51,810
you saw the API I can only throw in all

00:11:49,380 --> 00:11:53,340
the data at once if I want to encrypt a

00:11:51,810 --> 00:11:54,630
file I have to take all the filings and

00:11:53,340 --> 00:11:57,030
throw it in there there's no way to

00:11:54,630 --> 00:12:00,840
stream stuff in and out of an elf web

00:11:57,030 --> 00:12:02,550
crypto okay so we will have to chunk

00:12:00,840 --> 00:12:04,320
that file we will have to split it in

00:12:02,550 --> 00:12:06,210
smaller chunks and encrypt every chunk

00:12:04,320 --> 00:12:08,820
and then upload it to a server let me

00:12:06,210 --> 00:12:10,440
show you how we can do that so I have

00:12:08,820 --> 00:12:12,660
this file that's maybe 10 gigabytes in

00:12:10,440 --> 00:12:15,960
size I have an input element with type

00:12:12,660 --> 00:12:17,670
file I drag some file on there now what

00:12:15,960 --> 00:12:20,160
I want to do is I first want to split

00:12:17,670 --> 00:12:22,590
this file into small chunks in our case

00:12:20,160 --> 00:12:24,000
we take chunks of 64 kilobytes could be

00:12:22,590 --> 00:12:27,330
anything else could be one megabyte or

00:12:24,000 --> 00:12:29,430
smaller than that then I use the AES TCM

00:12:27,330 --> 00:12:32,670
algorithm in web crypto to decrypt that

00:12:29,430 --> 00:12:36,600
chunk then the resulting size is going

00:12:32,670 --> 00:12:40,100
to be 64 kilobytes plus 16 bytes where

00:12:36,600 --> 00:12:40,100
do those 16 bytes come from

00:12:41,480 --> 00:12:45,990
yes that's the authentication tech at

00:12:44,070 --> 00:12:47,730
the end a yes GCM does not have any

00:12:45,990 --> 00:12:49,200
padding so there's no padding coming to

00:12:47,730 --> 00:12:52,980
it there's only the authentication Tec

00:12:49,200 --> 00:12:54,960
that little 128 bits or 16 bytes of data

00:12:52,980 --> 00:12:58,350
that ensure authenticity and integrity

00:12:54,960 --> 00:13:00,030
of the data so this decryption will fail

00:12:58,350 --> 00:13:02,930
if something is manipulated on the wire

00:13:00,030 --> 00:13:07,860
so this is how we're gonna approach this

00:13:02,930 --> 00:13:10,470
now let me tell you for the upload the

00:13:07,860 --> 00:13:13,320
way to split files into smaller chunks

00:13:10,470 --> 00:13:16,980
is the file Reader API that is available

00:13:13,320 --> 00:13:18,930
in air in any modern browser you can see

00:13:16,980 --> 00:13:21,390
the call to the filereader api right

00:13:18,930 --> 00:13:23,820
here and there's a function called file

00:13:21,390 --> 00:13:26,610
dot slice so I can just take that file

00:13:23,820 --> 00:13:28,740
from the input slice it take out a slice

00:13:26,610 --> 00:13:30,600
and do something with it there is not

00:13:28,740 --> 00:13:32,580
going to be the whole file in the memory

00:13:30,600 --> 00:13:34,980
of your browser right it's only that

00:13:32,580 --> 00:13:36,600
slice the rest is gonna be thrown away

00:13:34,980 --> 00:13:38,430
so if I take the next slice the old

00:13:36,600 --> 00:13:40,530
slice is gonna be thrown away so this

00:13:38,430 --> 00:13:42,540
way you can slice a file of 10 gigabytes

00:13:40,530 --> 00:13:44,640
or even more in size into small chunks

00:13:42,540 --> 00:13:48,360
without using 10 gigabytes or more of

00:13:44,640 --> 00:13:50,850
memory so that's pretty cool ok now if I

00:13:48,360 --> 00:13:52,770
call that slice function I also add an

00:13:50,850 --> 00:13:54,480
event handler so that one that once the

00:13:52,770 --> 00:13:57,720
reading of that slice from the file

00:13:54,480 --> 00:13:58,890
system is done a function gets called so

00:13:57,720 --> 00:14:00,840
you can see that function here on the

00:13:58,890 --> 00:14:03,420
next slide it's called read event

00:14:00,840 --> 00:14:06,720
handler and what I do once I have this

00:14:03,420 --> 00:14:10,140
slice of my file of 64 kilobytes I call

00:14:06,720 --> 00:14:12,840
the encrypt function down here and then

00:14:10,140 --> 00:14:16,110
it upload that chunk ok so on the server

00:14:12,840 --> 00:14:18,810
side I will have to create an API where

00:14:16,110 --> 00:14:20,460
I can upload chunk after chunk ok I

00:14:18,810 --> 00:14:23,220
cannot upload the file all at once

00:14:20,460 --> 00:14:24,690
I will have to have a in this case I

00:14:23,220 --> 00:14:26,970
have a REST API that just takes one

00:14:24,690 --> 00:14:28,770
chunk after the other and in the URL

00:14:26,970 --> 00:14:31,530
there's the chunk index at the very end

00:14:28,770 --> 00:14:35,960
so it's upload file / 0 / 1 and so on

00:14:31,530 --> 00:14:38,520
and so forth ok cool

00:14:35,960 --> 00:14:40,530
just one more note when it comes to

00:14:38,520 --> 00:14:43,980
encrypting files so the encrypt function

00:14:40,530 --> 00:14:47,960
looks like this make sure to use a nonce

00:14:43,980 --> 00:14:51,000
nonce is short for a number used once

00:14:47,960 --> 00:14:53,940
and make sure that the index of the

00:14:51,000 --> 00:14:55,710
chunk also is part of that nots

00:14:53,940 --> 00:14:57,330
that nonce is going to be used in EES is

00:14:55,710 --> 00:14:59,460
an initialization vector so when I

00:14:57,330 --> 00:15:02,040
encrypt something with one key and I

00:14:59,460 --> 00:15:05,100
reuse the same key in every chunk of my

00:15:02,040 --> 00:15:06,660
file I will have to use a different

00:15:05,100 --> 00:15:09,750
nonce or a different initialization

00:15:06,660 --> 00:15:11,520
vector for each chunk why the reason for

00:15:09,750 --> 00:15:13,830
that is because there could be a file

00:15:11,520 --> 00:15:15,540
where the same content is coming over

00:15:13,830 --> 00:15:17,520
and over again and even in the

00:15:15,540 --> 00:15:19,170
ciphertext I will seed it's it's it's

00:15:17,520 --> 00:15:21,930
going to be the same ciphertext over

00:15:19,170 --> 00:15:24,150
over again okay so in order for the

00:15:21,930 --> 00:15:25,830
ciphertext change at every chunk no

00:15:24,150 --> 00:15:26,820
matter if it's the same or different I

00:15:25,830 --> 00:15:28,890
will have to use a different

00:15:26,820 --> 00:15:31,590
initialization vector for each time

00:15:28,890 --> 00:15:34,290
every time I encrypt something so the

00:15:31,590 --> 00:15:36,630
rule of thumb is if I reuse a key use a

00:15:34,290 --> 00:15:38,400
unique nonce or initialization vector

00:15:36,630 --> 00:15:39,120
and it every time you encrypt something

00:15:38,400 --> 00:15:41,310
okay

00:15:39,120 --> 00:15:45,600
don't reuse nonsense or initialization

00:15:41,310 --> 00:15:47,820
vectors cool so the filereader api is

00:15:45,600 --> 00:15:49,920
pretty well supported in all major

00:15:47,820 --> 00:15:53,910
browsers even Internet Explorer supports

00:15:49,920 --> 00:15:55,830
filed with our API there's it doesn't

00:15:53,910 --> 00:15:57,390
support read this binary string but

00:15:55,830 --> 00:15:58,980
that's we're not using that anyway in

00:15:57,390 --> 00:16:00,810
this case we're not using it so we can

00:15:58,980 --> 00:16:07,140
even upload files in Internet Explorer

00:16:00,810 --> 00:16:09,060
11 all right cool now it's getting

00:16:07,140 --> 00:16:11,460
harder and harder because download is

00:16:09,060 --> 00:16:13,410
even harder the thing is I want to

00:16:11,460 --> 00:16:15,810
stream the download I want to click on a

00:16:13,410 --> 00:16:19,050
link I want to save as dialog to pop up

00:16:15,810 --> 00:16:21,600
and I want the contents of the file to

00:16:19,050 --> 00:16:24,270
be decrypted one chunk after the other

00:16:21,600 --> 00:16:26,820
and I want to be streamed into my

00:16:24,270 --> 00:16:29,280
downloads folder now the only way in a

00:16:26,820 --> 00:16:31,110
web browser to stream stuff from the

00:16:29,280 --> 00:16:34,440
download into your downloads folder is

00:16:31,110 --> 00:16:36,240
having an anchor element with an H ref

00:16:34,440 --> 00:16:41,340
equals something and then you click on

00:16:36,240 --> 00:16:42,690
it okay now this is something I can not

00:16:41,340 --> 00:16:46,110
do unfortunately

00:16:42,690 --> 00:16:49,140
now if you look at the IU's access in

00:16:46,110 --> 00:16:51,560
this case I just called the download to

00:16:49,140 --> 00:16:54,690
the file and I say response type block

00:16:51,560 --> 00:16:57,330
which means I will have a byte array of

00:16:54,690 --> 00:16:59,760
the whole file in memory of my web

00:16:57,330 --> 00:17:01,890
browser and then I could go ahead and

00:16:59,760 --> 00:17:04,140
say I just chunked that file again

00:17:01,890 --> 00:17:06,240
decrypt it and then I create a save as

00:17:04,140 --> 00:17:07,470
dialog I can do that but that's going to

00:17:06,240 --> 00:17:10,829
use 10 gigabyte

00:17:07,470 --> 00:17:13,079
of memory times too if I have a file of

00:17:10,829 --> 00:17:14,730
ten gigabytes okay we will later see

00:17:13,079 --> 00:17:16,079
that we will still use this function for

00:17:14,730 --> 00:17:22,049
a different reason but we cannot use it

00:17:16,079 --> 00:17:25,829
for big files now that would be the way

00:17:22,049 --> 00:17:28,890
to have a decrypted byte array and then

00:17:25,829 --> 00:17:30,720
you create link in the Dom like this

00:17:28,890 --> 00:17:33,929
appendchild and then you click it

00:17:30,720 --> 00:17:36,840
programmatically that's really ugly

00:17:33,929 --> 00:17:39,000
isn't it so that would be the way to

00:17:36,840 --> 00:17:41,070
create a save as dialog in your browser

00:17:39,000 --> 00:17:43,799
with with just a byte array in your

00:17:41,070 --> 00:17:45,330
memory but again this would use a lot of

00:17:43,799 --> 00:17:49,140
memory for big files so that's something

00:17:45,330 --> 00:17:52,370
what we're gonna use okay we cannot

00:17:49,140 --> 00:17:55,340
stream data so what we can use now is

00:17:52,370 --> 00:17:59,000
serviceworkers now it gets a little bit

00:17:55,340 --> 00:18:01,230
complicated but still once you've

00:17:59,000 --> 00:18:02,460
grasped the concept of serviceworkers

00:18:01,230 --> 00:18:04,260
you're gonna see how it's gonna help us

00:18:02,460 --> 00:18:05,700
not just a quick primer on

00:18:04,260 --> 00:18:07,770
serviceworkers Charlet service workers

00:18:05,700 --> 00:18:09,799
are little pieces of JavaScript that run

00:18:07,770 --> 00:18:12,600
in the background of your browser and

00:18:09,799 --> 00:18:15,720
they kind of act as a little proxy

00:18:12,600 --> 00:18:17,610
server between your website and your

00:18:15,720 --> 00:18:19,409
server so you can for example intercept

00:18:17,610 --> 00:18:21,900
HTTP requests do something with it

00:18:19,409 --> 00:18:25,740
manipulate it or change it in a way and

00:18:21,900 --> 00:18:27,210
then send it back okay it runs in the

00:18:25,740 --> 00:18:28,740
worker context which in a browser is a

00:18:27,210 --> 00:18:30,240
different it's a special context there

00:18:28,740 --> 00:18:32,010
is no access to the Dom so you cannot

00:18:30,240 --> 00:18:33,659
access the Dom of the website itself you

00:18:32,010 --> 00:18:35,429
can only intercept requests and do

00:18:33,659 --> 00:18:38,340
something with it okay so they're kind

00:18:35,429 --> 00:18:42,270
of limited in what they can do with your

00:18:38,340 --> 00:18:44,789
website some music cases of service

00:18:42,270 --> 00:18:46,440
workers you could intercept the modifier

00:18:44,789 --> 00:18:47,880
requests as I just said and this was a

00:18:46,440 --> 00:18:50,250
feature that we're going to use to

00:18:47,880 --> 00:18:52,710
decrypt our files you could also go or

00:18:50,250 --> 00:18:55,380
the primary use case for service workers

00:18:52,710 --> 00:18:58,409
is caching resources you could use that

00:18:55,380 --> 00:19:01,860
to make your application a progressive

00:18:58,409 --> 00:19:03,659
web application PWA because you don't

00:19:01,860 --> 00:19:05,520
need internet tool to load the website

00:19:03,659 --> 00:19:07,860
okay you could cache your JavaScript

00:19:05,520 --> 00:19:10,890
resources your CSS your images to load

00:19:07,860 --> 00:19:12,690
the site and you can store temporarily

00:19:10,890 --> 00:19:14,130
store something the user creates on the

00:19:12,690 --> 00:19:15,659
website and then when the network is

00:19:14,130 --> 00:19:17,100
available again you can upload the stuff

00:19:15,659 --> 00:19:20,909
that's something that you can use

00:19:17,100 --> 00:19:21,600
service workers for so pwace make very

00:19:20,909 --> 00:19:25,140
heavy you

00:19:21,600 --> 00:19:26,669
of this concept so if you want to have a

00:19:25,140 --> 00:19:28,740
look at how it works

00:19:26,669 --> 00:19:31,010
maybe just visit the website it uses

00:19:28,740 --> 00:19:34,049
serviceworker and when you go to the

00:19:31,010 --> 00:19:35,539
application tab up here this is a

00:19:34,049 --> 00:19:37,890
chromium based browser in this case

00:19:35,539 --> 00:19:40,020
application DUP up here and then

00:19:37,890 --> 00:19:41,490
serviceworkers here on the left you're

00:19:40,020 --> 00:19:43,500
gonna see that there is a serviceworker

00:19:41,490 --> 00:19:47,070
running in the background of this test

00:19:43,500 --> 00:19:50,010
application here okay it's this little

00:19:47,070 --> 00:19:53,130
cog wheel icon that you can see that

00:19:50,010 --> 00:19:54,720
also will be in a network tab when the

00:19:53,130 --> 00:19:56,880
serviceworker is loaded there's going to

00:19:54,720 --> 00:20:00,450
be a little cog wheel on the side of the

00:19:56,880 --> 00:20:02,280
filename okay registering a

00:20:00,450 --> 00:20:04,890
serviceworker is pretty easy what you do

00:20:02,280 --> 00:20:08,039
is navigate your serviceworker register

00:20:04,890 --> 00:20:09,809
with the URL to your javascript file

00:20:08,039 --> 00:20:12,890
where the serviceworker resides and it's

00:20:09,809 --> 00:20:15,690
going to load that serviceworker

00:20:12,890 --> 00:20:18,030
now if you want just want to cache

00:20:15,690 --> 00:20:19,409
resources that's great if you just

00:20:18,030 --> 00:20:21,059
install the serviceworker but the thing

00:20:19,409 --> 00:20:22,380
is when we want to decrypt files we want

00:20:21,059 --> 00:20:24,630
this serviceworker to be available

00:20:22,380 --> 00:20:26,789
immediately usually it's only going to

00:20:24,630 --> 00:20:29,039
be available at the next page load okay

00:20:26,789 --> 00:20:30,720
if you want to the serviceworker to be

00:20:29,039 --> 00:20:32,460
available immediately what you can do is

00:20:30,720 --> 00:20:34,409
inside the serviceworker

00:20:32,460 --> 00:20:36,690
add to event listeners one for install

00:20:34,409 --> 00:20:38,130
and one for activate and just add these

00:20:36,690 --> 00:20:41,010
lines of code and it's going to be

00:20:38,130 --> 00:20:42,659
immediately available just copy and

00:20:41,010 --> 00:20:44,990
paste this stuff if you want it to be

00:20:42,659 --> 00:20:47,490
available immediately

00:20:44,990 --> 00:20:49,830
okay now let's have a look at how the

00:20:47,490 --> 00:20:51,419
download is going to work I hope this is

00:20:49,830 --> 00:20:56,010
big enough for everybody in the last row

00:20:51,419 --> 00:20:58,320
as well now here on the right-hand side

00:20:56,010 --> 00:20:59,400
the right half of the screen is the

00:20:58,320 --> 00:21:01,950
serviceworker so this is where our

00:20:59,400 --> 00:21:03,990
decryption stuff is going to happen now

00:21:01,950 --> 00:21:06,360
as the serviceworker does not have any

00:21:03,990 --> 00:21:08,190
access to the Dom we need to give the

00:21:06,360 --> 00:21:11,340
serviceworker the key to the file which

00:21:08,190 --> 00:21:14,130
it's going to use to decrypt in any

00:21:11,340 --> 00:21:15,780
other way there are ways to communion

00:21:14,130 --> 00:21:18,330
communicate with your serviceworker and

00:21:15,780 --> 00:21:20,370
that's going to work with navigate your

00:21:18,330 --> 00:21:23,039
serviceworker controller post message

00:21:20,370 --> 00:21:24,570
okay I can post messages over to the

00:21:23,039 --> 00:21:25,980
serviceworker and i can send the

00:21:24,570 --> 00:21:28,350
serviceworker the master key which is

00:21:25,980 --> 00:21:30,630
what i'm doing right here and in the

00:21:28,350 --> 00:21:33,240
serviceworker i say on message equals

00:21:30,630 --> 00:21:35,430
and a function i can take the master key

00:21:33,240 --> 00:21:36,960
so when the user hits the

00:21:35,430 --> 00:21:38,820
but enough to file on one decrypted

00:21:36,960 --> 00:21:41,420
first I sent over the master key and

00:21:38,820 --> 00:21:46,440
only then I'm going to load their URL

00:21:41,420 --> 00:21:47,670
now does the third step again I create

00:21:46,440 --> 00:21:50,160
an anchor element and just

00:21:47,670 --> 00:21:52,410
programmatically click it in my web

00:21:50,160 --> 00:21:55,580
application and here in a serviceworker

00:21:52,410 --> 00:21:59,430
I have an unfettered so every time

00:21:55,580 --> 00:22:01,320
anything is fetched or you know you

00:21:59,430 --> 00:22:04,170
click a link or you use the fetch method

00:22:01,320 --> 00:22:06,960
or you lose xml httprequest or anything

00:22:04,170 --> 00:22:10,140
like that that on fetch method here is

00:22:06,960 --> 00:22:13,110
going to fire and I can go ahead and

00:22:10,140 --> 00:22:17,040
manipulate the response okay what I do

00:22:13,110 --> 00:22:21,540
here is I respond with a stream which is

00:22:17,040 --> 00:22:23,760
going to decrypt the data and here's the

00:22:21,540 --> 00:22:25,440
function to decrypt that file and it's

00:22:23,760 --> 00:22:27,120
going to go back to the web application

00:22:25,440 --> 00:22:29,580
and the save as dialog is going to pop

00:22:27,120 --> 00:22:31,710
up I have to do it this way because on

00:22:29,580 --> 00:22:34,110
the left hand side I have to create an

00:22:31,710 --> 00:22:35,880
anchor element with an href and click on

00:22:34,110 --> 00:22:37,500
it because that's the only way to stream

00:22:35,880 --> 00:22:40,110
stuff into your downloads folder as I

00:22:37,500 --> 00:22:42,000
said before I cannot use fetch and then

00:22:40,110 --> 00:22:43,590
I blow up and decrypt the stuff because

00:22:42,000 --> 00:22:44,790
I can't stream that's the only reason

00:22:43,590 --> 00:22:47,010
why we're doing this we don't want to

00:22:44,790 --> 00:22:48,960
hold the whole file in memory that's why

00:22:47,010 --> 00:22:51,150
we need a serviceworker so that we can

00:22:48,960 --> 00:22:54,200
act as if everything is normal

00:22:51,150 --> 00:22:57,590
over there on the left side ok

00:22:54,200 --> 00:23:00,930
serviceworker support also pretty good

00:22:57,590 --> 00:23:04,460
with one exception in etch in older

00:23:00,930 --> 00:23:08,790
versions we cannot use this because

00:23:04,460 --> 00:23:10,800
readable streams so the stream that I'm

00:23:08,790 --> 00:23:12,510
creating here readable streams native

00:23:10,800 --> 00:23:14,520
streams are not available in service

00:23:12,510 --> 00:23:16,830
workers in edge only starting from

00:23:14,520 --> 00:23:19,620
version 79 where it's using the chromium

00:23:16,830 --> 00:23:20,880
engine already ok so with the current

00:23:19,620 --> 00:23:22,650
version of edge the current stable

00:23:20,880 --> 00:23:24,270
version fast you unfortunately cannot

00:23:22,650 --> 00:23:30,060
use this method so right now it's only

00:23:24,270 --> 00:23:32,340
for Firefox Chrome not even Safari ok so

00:23:30,060 --> 00:23:34,500
just a very short primer again this is

00:23:32,340 --> 00:23:35,880
very my I said you're gonna see a lot of

00:23:34,500 --> 00:23:38,130
code and you're gonna see a lot of

00:23:35,880 --> 00:23:42,150
JavaScript vanilla panino JavaScript API

00:23:38,130 --> 00:23:45,290
is the readable stream API it's just a

00:23:42,150 --> 00:23:49,200
method to stream data so you can take

00:23:45,290 --> 00:23:51,059
for example the result of a fetch call

00:23:49,200 --> 00:23:52,889
and stream it somewhere you can chunk it

00:23:51,059 --> 00:23:55,889
into little chunks of data you can do

00:23:52,889 --> 00:23:57,210
trip stuff you can pipe one stream

00:23:55,889 --> 00:23:57,570
through the other stream and stuff like

00:23:57,210 --> 00:24:02,970
that

00:23:57,570 --> 00:24:06,779
we need this to decrypt our data so we

00:24:02,970 --> 00:24:08,970
have two Transformers here we take the

00:24:06,779 --> 00:24:11,250
in the service worker we call the fetch

00:24:08,970 --> 00:24:15,120
method to get the encrypted data from

00:24:11,250 --> 00:24:18,510
the server then we use a stream slicer

00:24:15,120 --> 00:24:21,360
to again chunk it a big file into our 64

00:24:18,510 --> 00:24:23,820
by it's 64 kilobytes plus 16 bytes of

00:24:21,360 --> 00:24:26,779
data so we have those small encrypted

00:24:23,820 --> 00:24:28,980
chunks and then we pipe it to the next

00:24:26,779 --> 00:24:30,570
transformer which is the decrypt stream

00:24:28,980 --> 00:24:32,429
controller which is going to decrypt the

00:24:30,570 --> 00:24:35,760
stuff and then send it back to the

00:24:32,429 --> 00:24:39,210
website ok so that's what we can do with

00:24:35,760 --> 00:24:42,750
readable streams that's how the drip

00:24:39,210 --> 00:24:44,850
stream controller works like it's just

00:24:42,750 --> 00:24:49,950
going to call the web crypto API to use

00:24:44,850 --> 00:24:52,200
AES GCM to decrypt the data readable

00:24:49,950 --> 00:24:56,429
streams are also pretty well supported

00:24:52,200 --> 00:24:58,889
but not in Safari unfortunately and in

00:24:56,429 --> 00:25:01,019
edge they are only supported within

00:24:58,889 --> 00:25:03,139
service workers starting from version 79

00:25:01,019 --> 00:25:08,399
where the chromium engine is going to

00:25:03,139 --> 00:25:12,120
replace the HTML engine so no native

00:25:08,399 --> 00:25:15,570
streams inside service workers here cool

00:25:12,120 --> 00:25:17,970
so we are supporting big files okay so

00:25:15,570 --> 00:25:20,039
we can stream stuff up to the server

00:25:17,970 --> 00:25:22,350
using the filereader api slice it

00:25:20,039 --> 00:25:25,049
encrypted and then upload chunk after

00:25:22,350 --> 00:25:27,539
chunk and for downloading big files we

00:25:25,049 --> 00:25:29,639
can use service workers readable stream

00:25:27,539 --> 00:25:31,649
to again chunk the stuff and send it

00:25:29,639 --> 00:25:33,389
back to the website it's a bit

00:25:31,649 --> 00:25:34,529
complicated because for up and down

00:25:33,389 --> 00:25:37,110
we're using completely different

00:25:34,529 --> 00:25:40,649
javascript api s-- okay upload is way

00:25:37,110 --> 00:25:41,970
easier than download usually cool so we

00:25:40,649 --> 00:25:43,230
want to support old browsers as well

00:25:41,970 --> 00:25:44,880
because we have seen that service

00:25:43,230 --> 00:25:46,980
workers and readable streams and all the

00:25:44,880 --> 00:25:49,190
stuff is probably not supported in all

00:25:46,980 --> 00:25:54,299
the browsers like Internet Explorer and

00:25:49,190 --> 00:25:55,889
and others so for the upload everything

00:25:54,299 --> 00:25:57,510
is okay because file reader is widely

00:25:55,889 --> 00:25:59,399
supported and it's easy to use

00:25:57,510 --> 00:26:00,419
everything alright the download is the

00:25:59,399 --> 00:26:02,639
more complicated thing

00:26:00,419 --> 00:26:02,850
it requires service workers and natives

00:26:02,639 --> 00:26:04,350
to

00:26:02,850 --> 00:26:06,600
which are not supported by many browsers

00:26:04,350 --> 00:26:10,740
but we can use blob download remember

00:26:06,600 --> 00:26:15,240
what I showed you before I can use the

00:26:10,740 --> 00:26:16,530
create object URL function over here

00:26:15,240 --> 00:26:17,970
with the with the result with a

00:26:16,530 --> 00:26:19,830
decrypted result and then I can

00:26:17,970 --> 00:26:21,990
programmatically click on that link it

00:26:19,830 --> 00:26:25,050
the thing is just is going to be using a

00:26:21,990 --> 00:26:27,360
lot of memory my browser okay that's the

00:26:25,050 --> 00:26:28,680
only disadvantage if you use Firefox and

00:26:27,360 --> 00:26:30,750
for downloading a file that's bigger

00:26:28,680 --> 00:26:32,820
than 256 megabytes it's gonna show your

00:26:30,750 --> 00:26:35,760
warning in older browsers it's gonna say

00:26:32,820 --> 00:26:37,860
this is going to use a lot of memory you

00:26:35,760 --> 00:26:39,240
probably don't want to do this okay just

00:26:37,860 --> 00:26:41,400
for that reason they are doing the same

00:26:39,240 --> 00:26:44,280
stuff there because service workers are

00:26:41,400 --> 00:26:46,590
not available so that's the warning that

00:26:44,280 --> 00:26:49,320
they show this browser might not be able

00:26:46,590 --> 00:26:51,570
to decrypt a file this big okay for that

00:26:49,320 --> 00:26:54,030
reason we can stream it in older

00:26:51,570 --> 00:26:58,590
browsers because of readable stream and

00:26:54,030 --> 00:27:01,260
service workers not being available cool

00:26:58,590 --> 00:27:03,150
so for smaller files we can also use

00:27:01,260 --> 00:27:06,840
this in all the browsers for big files

00:27:03,150 --> 00:27:09,650
we have to use a modern browser now one

00:27:06,840 --> 00:27:12,240
last part securely distributing keys so

00:27:09,650 --> 00:27:14,940
the requirement is I want to upload a

00:27:12,240 --> 00:27:17,640
file I want to create a link I want to

00:27:14,940 --> 00:27:19,890
send you guys the link and you click it

00:27:17,640 --> 00:27:21,900
and you can download the file now when

00:27:19,890 --> 00:27:23,280
you open a link parts of the link are

00:27:21,900 --> 00:27:25,050
going to be sent to the server but I

00:27:23,280 --> 00:27:27,300
don't want the server to know that key

00:27:25,050 --> 00:27:30,000
it's supposed to store in my browser and

00:27:27,300 --> 00:27:31,650
then the messaging whatever method

00:27:30,000 --> 00:27:34,950
you're gonna use you send it by email or

00:27:31,650 --> 00:27:38,670
whatsapp or whatever it is okay how are

00:27:34,950 --> 00:27:40,680
we going to do this so the key must not

00:27:38,670 --> 00:27:42,900
be transferred to the server let's have

00:27:40,680 --> 00:27:44,010
a look at the URL because there's one

00:27:42,900 --> 00:27:45,630
special part in there that's not

00:27:44,010 --> 00:27:47,550
transferred to the server now we have

00:27:45,630 --> 00:27:50,880
the scheme we have the domain we have

00:27:47,550 --> 00:27:53,550
the resource path the query and then

00:27:50,880 --> 00:27:58,470
there's the fragment what's the fragment

00:27:53,550 --> 00:28:00,270
used for it's an anchor and what was you

00:27:58,470 --> 00:28:02,970
know in the old times of the web before

00:28:00,270 --> 00:28:04,800
Utes came up and other single page

00:28:02,970 --> 00:28:07,890
application frameworks what was it used

00:28:04,800 --> 00:28:09,750
for primarily for navigation so you

00:28:07,890 --> 00:28:12,870
could for example could send a link to a

00:28:09,750 --> 00:28:15,180
Wikipedia article the I don't know the

00:28:12,870 --> 00:28:16,470
tenth heading down there you could just

00:28:15,180 --> 00:28:18,000
create a link with

00:28:16,470 --> 00:28:20,040
anchor element and the browser would

00:28:18,000 --> 00:28:22,500
jump directly to that heading okay it

00:28:20,040 --> 00:28:25,980
jumps to the object that carries the ID

00:28:22,500 --> 00:28:29,730
of that fragment is this fragment sent

00:28:25,980 --> 00:28:31,230
to the server no it's not everything

00:28:29,730 --> 00:28:32,790
else is saying to the server but the

00:28:31,230 --> 00:28:35,460
fragment is not it's gonna stay on the

00:28:32,790 --> 00:28:39,450
client so we can use that to transfer

00:28:35,460 --> 00:28:41,130
our keys so if you have a look at for

00:28:39,450 --> 00:28:43,740
example I opened what I just said

00:28:41,130 --> 00:28:46,980
Wikipedia page and you can see that here

00:28:43,740 --> 00:28:49,170
is an anchor text say saying features so

00:28:46,980 --> 00:28:51,270
I'm jumping to the feature section of

00:28:49,170 --> 00:28:52,980
the Chava script Wikipedia article and

00:28:51,270 --> 00:28:54,360
you see here in the path that our

00:28:52,980 --> 00:28:58,800
fragment is not transferred to the

00:28:54,360 --> 00:29:02,040
server so it's secret to the server you

00:28:58,800 --> 00:29:07,320
see it okay so we're going to use this

00:29:02,040 --> 00:29:08,910
to securely distribute our keys demo

00:29:07,320 --> 00:29:10,830
time I'm gonna show you an application

00:29:08,910 --> 00:29:12,630
where I implemented this taking the

00:29:10,830 --> 00:29:14,490
basic concepts of Firefox and you can

00:29:12,630 --> 00:29:16,590
see the source code and doing just the

00:29:14,490 --> 00:29:19,350
same stuff using serviceworkers readable

00:29:16,590 --> 00:29:22,530
streams and filereader api and I just

00:29:19,350 --> 00:29:29,420
did basically the same application using

00:29:22,530 --> 00:29:29,420
UGS so I have to log in that's just my

00:29:29,690 --> 00:29:39,090
example account here the concept boat

00:29:36,900 --> 00:29:42,180
called lockers where the files are

00:29:39,090 --> 00:29:44,400
inside so here I have this upload area

00:29:42,180 --> 00:29:46,200
where I can just click and upload a file

00:29:44,400 --> 00:29:47,940
I'm going to open the network tab so you

00:29:46,200 --> 00:29:51,590
can see that the file is going to be

00:29:47,940 --> 00:29:55,800
uploaded in small chunks so I click here

00:29:51,590 --> 00:29:58,590
you can see it's uploading chunk after

00:29:55,800 --> 00:30:01,800
chunk because I first slice the file

00:29:58,590 --> 00:30:03,720
encrypted and then upload each chunk now

00:30:01,800 --> 00:30:05,940
I can go over here and create a shared

00:30:03,720 --> 00:30:09,090
link to that locker containing the files

00:30:05,940 --> 00:30:11,610
I copied that link to the clipboard just

00:30:09,090 --> 00:30:15,270
head over to another browser and you can

00:30:11,610 --> 00:30:18,360
see I use the fragment right here here's

00:30:15,270 --> 00:30:21,120
the hash sign to separate the ID to that

00:30:18,360 --> 00:30:22,890
file from the key to the file the key is

00:30:21,120 --> 00:30:25,320
not going to be transferred to the

00:30:22,890 --> 00:30:28,260
server I have to analog unlock it with

00:30:25,320 --> 00:30:29,980
the password you know if I click on this

00:30:28,260 --> 00:30:32,020
I'm going to I'm getting

00:30:29,980 --> 00:30:35,350
this open dialogue and I can save the

00:30:32,020 --> 00:30:38,140
file okay so at the download it's again

00:30:35,350 --> 00:30:40,540
the download comes in one big chunk but

00:30:38,140 --> 00:30:44,549
I'm slicing it back to the small

00:30:40,540 --> 00:30:44,549
encrypted chunks in my serviceworker

00:30:45,210 --> 00:30:53,650
okay so if you want to hear more about

00:30:52,150 --> 00:30:55,510
the implementation beauty as and also

00:30:53,650 --> 00:30:56,740
state management and keys and stuff just

00:30:55,510 --> 00:30:58,840
approach me after this talk it's a

00:30:56,740 --> 00:31:01,179
little bit beyond of what I I can fit

00:30:58,840 --> 00:31:03,360
into this talk here but I want to do a

00:31:01,179 --> 00:31:05,650
little wrap-up of what we'll learn today

00:31:03,360 --> 00:31:07,030
so if you want to ensure the

00:31:05,650 --> 00:31:09,669
confidentiality integrity and

00:31:07,030 --> 00:31:11,950
authenticity when encrypting something

00:31:09,669 --> 00:31:16,120
we have to choose to write cipher mode

00:31:11,950 --> 00:31:18,549
it's not just a es is a secure site it's

00:31:16,120 --> 00:31:20,380
considered secure cipher nowadays but it

00:31:18,549 --> 00:31:22,540
depends on which mode you're using if

00:31:20,380 --> 00:31:24,400
you have the choice don't use cipher

00:31:22,540 --> 00:31:27,210
block chaining mode or CBC mode because

00:31:24,400 --> 00:31:30,130
as we saw we don't want to eat grandpa

00:31:27,210 --> 00:31:33,220
use a different cipher that also ensures

00:31:30,130 --> 00:31:34,780
both integrity and authenticity and one

00:31:33,220 --> 00:31:36,730
such cipher that is available in mode

00:31:34,780 --> 00:31:40,419
that is available in your browser in the

00:31:36,730 --> 00:31:46,720
web crypto API is AES GCM it's an AE ad

00:31:40,419 --> 00:31:48,429
crypto hipster cipher very cool if you

00:31:46,720 --> 00:31:51,070
want to use cryptography in the browser

00:31:48,429 --> 00:31:54,100
to get generate random numbers you can

00:31:51,070 --> 00:31:56,320
use the web crypto get random values

00:31:54,100 --> 00:32:00,190
function which produces secure random

00:31:56,320 --> 00:32:02,530
numbers it's going to access the the

00:32:00,190 --> 00:32:04,030
operating system sources for secure

00:32:02,530 --> 00:32:06,010
random numbers okay so if you're on a

00:32:04,030 --> 00:32:08,410
Windows or Mac or Linux machine it's

00:32:06,010 --> 00:32:09,280
going to access the you know at the end

00:32:08,410 --> 00:32:10,720
of the day it's going to access the

00:32:09,280 --> 00:32:13,630
kernel function that generates random

00:32:10,720 --> 00:32:16,150
numbers use crypto sub will import key

00:32:13,630 --> 00:32:17,919
to take such a random key and get a

00:32:16,150 --> 00:32:19,440
cryptically object and then use crypto

00:32:17,919 --> 00:32:22,360
subtle encrypt and decrypt to

00:32:19,440 --> 00:32:25,870
symmetrically encrypt and decrypt stuff

00:32:22,360 --> 00:32:27,880
for example files or file chunks for

00:32:25,870 --> 00:32:30,160
chunked upload use the filereader api

00:32:27,880 --> 00:32:31,870
that's pretty easy to use and has very

00:32:30,160 --> 00:32:34,090
broad support you can chunk stuff into

00:32:31,870 --> 00:32:36,490
small chunks and then upload it to your

00:32:34,090 --> 00:32:37,960
server for chunk download that's a

00:32:36,490 --> 00:32:39,610
little bit more complicated you have to

00:32:37,960 --> 00:32:41,650
use service workers to do that in the

00:32:39,610 --> 00:32:42,630
background and your readable stream API

00:32:41,650 --> 00:32:46,470
to chunks

00:32:42,630 --> 00:32:48,240
in a download you can also support older

00:32:46,470 --> 00:32:50,550
browsers by just limiting the file size

00:32:48,240 --> 00:32:55,320
for old browsers you use the blob

00:32:50,550 --> 00:32:57,810
download cool so I just want to lose a

00:32:55,320 --> 00:32:59,730
word also about a sec for deaf bootcamp

00:32:57,810 --> 00:33:01,200
that's probably interesting to you folks

00:32:59,730 --> 00:33:03,090
because it's about single page

00:33:01,200 --> 00:33:05,100
application security this is Philip

00:33:03,090 --> 00:33:06,750
Tareq he was our boot camp instructor

00:33:05,100 --> 00:33:08,040
last year he's one of the best Tech

00:33:06,750 --> 00:33:09,990
instructors that I have seen in my life

00:33:08,040 --> 00:33:11,100
is really really good and he's going to

00:33:09,990 --> 00:33:12,870
give a bootcamp on single page

00:33:11,100 --> 00:33:14,280
application security where he talks

00:33:12,870 --> 00:33:15,690
about cross the scripting content

00:33:14,280 --> 00:33:17,910
security policy and how to integrate

00:33:15,690 --> 00:33:19,970
this in your application also to

00:33:17,910 --> 00:33:23,100
understand cross-origin resource sharing

00:33:19,970 --> 00:33:25,500
which is kind of hard to understand also

00:33:23,100 --> 00:33:28,020
chasing web token security and what this

00:33:25,500 --> 00:33:30,390
is all about and and so on and so forth

00:33:28,020 --> 00:33:32,940
a two day bootcamp the week after the

00:33:30,390 --> 00:33:34,890
next week Monday and Tuesday just check

00:33:32,940 --> 00:33:37,020
it out on secre deftly oh there's more

00:33:34,890 --> 00:33:39,270
three other boot camps and lots of talks

00:33:37,020 --> 00:33:41,450
that could be interesting thank you very

00:33:39,270 --> 00:33:44,630
much for listening and bearing with me

00:33:41,450 --> 00:33:46,860
although there were so many cold samples

00:33:44,630 --> 00:33:48,600
follow me on Twitter if you want to see

00:33:46,860 --> 00:33:52,170
more social security related content

00:33:48,600 --> 00:33:54,090
regarding software security and I'm also

00:33:52,170 --> 00:33:55,870
going to publish a link to the slides up

00:33:54,090 --> 00:33:58,820
there thank you very much

00:33:55,870 --> 00:33:58,820

YouTube URL: https://www.youtube.com/watch?v=SdePc87Ffik


