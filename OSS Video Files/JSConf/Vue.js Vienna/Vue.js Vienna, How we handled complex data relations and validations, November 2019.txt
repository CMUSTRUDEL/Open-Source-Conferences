Title: Vue.js Vienna, How we handled complex data relations and validations, November 2019
Publication date: 2019-11-20
Playlist: Vue.js Vienna
Description: 
	Talk by Roland Schütz

Vue.js doesn’t offer a convenient way of validating and handling complex data and rules in a bigger application. During our project we tried different strategies and I’m going to show you what worked the best for us.
Captions: 
	00:00:00,030 --> 00:00:08,280
welcome I want to talk about validation

00:00:02,639 --> 00:00:11,010
in pew and there's it can be become more

00:00:08,280 --> 00:00:14,429
complicated so I lead a software

00:00:11,010 --> 00:00:17,190
development company in Vienna we have a

00:00:14,429 --> 00:00:19,199
few bigger projects with few and I want

00:00:17,190 --> 00:00:21,449
to share you some insights from one our

00:00:19,199 --> 00:00:24,750
our project so the stack was in the back

00:00:21,449 --> 00:00:28,260
end we used laravel and we used few of

00:00:24,750 --> 00:00:29,490
course we use puma and wavy i'm never

00:00:28,260 --> 00:00:34,550
know how it's pronounced

00:00:29,490 --> 00:00:37,559
and we used few x for the data handling

00:00:34,550 --> 00:00:40,020
it was quite a big project where the

00:00:37,559 --> 00:00:45,120
goal was to create a data at like a

00:00:40,020 --> 00:00:48,149
price calculation tool roughly 2,000

00:00:45,120 --> 00:00:50,309
man-hours for concept and and

00:00:48,149 --> 00:00:54,570
development so it was quite big project

00:00:50,309 --> 00:00:56,699
and so the typical solutions didn't work

00:00:54,570 --> 00:00:59,370
well in that context and i want to talk

00:00:56,699 --> 00:01:04,019
a bit more about that and how we came to

00:00:59,370 --> 00:01:06,630
our project specific solution and and

00:01:04,019 --> 00:01:08,460
what you can learn I'm just using

00:01:06,630 --> 00:01:12,090
javascript new typescript

00:01:08,460 --> 00:01:15,619
I'm sure how everybody knows it or not

00:01:12,090 --> 00:01:18,360
and also I try to talk more about

00:01:15,619 --> 00:01:23,100
concept and patterns then actually like

00:01:18,360 --> 00:01:26,310
libraries or code first of all I'm not

00:01:23,100 --> 00:01:28,560
sure if everybody of you knows few X so

00:01:26,310 --> 00:01:31,920
I'm just trying to explain the very

00:01:28,560 --> 00:01:34,619
basic concept so in the few application

00:01:31,920 --> 00:01:36,450
you normally have your app arute and we

00:01:34,619 --> 00:01:38,340
know that you have components and those

00:01:36,450 --> 00:01:44,130
components can have other components and

00:01:38,340 --> 00:01:45,869
so on and so on and so on and data is

00:01:44,130 --> 00:01:49,200
handled that you have your data in the

00:01:45,869 --> 00:01:51,990
root typically so in this case in a

00:01:49,200 --> 00:01:56,189
parent and then every time you want to

00:01:51,990 --> 00:01:59,310
pass data down you're using props to to

00:01:56,189 --> 00:02:01,890
pass them down and if the child changes

00:01:59,310 --> 00:02:05,009
theater it sends them up emitting an

00:02:01,890 --> 00:02:07,700
event so that this goes to the parent in

00:02:05,009 --> 00:02:10,679
this context that looks pretty simple in

00:02:07,700 --> 00:02:12,580
bigger applications you soon have a

00:02:10,679 --> 00:02:15,010
parent of parent and

00:02:12,580 --> 00:02:17,350
and then you you start caring a lot

00:02:15,010 --> 00:02:22,090
about just emitting and catching events

00:02:17,350 --> 00:02:26,880
and it gets yeah it doesn't work well

00:02:22,090 --> 00:02:30,220
so this is where Q X comes in it's the

00:02:26,880 --> 00:02:32,800
it's similar to redux from react and the

00:02:30,220 --> 00:02:36,480
basic idea is the few component instead

00:02:32,800 --> 00:02:39,850
of sending to the parent it directly

00:02:36,480 --> 00:02:42,760
this path dispatches an action which

00:02:39,850 --> 00:02:45,040
saves the data in the the datastore so

00:02:42,760 --> 00:02:49,030
that the the data store is decoupled

00:02:45,040 --> 00:02:51,160
from the components and then if the

00:02:49,030 --> 00:02:53,320
store internally changes data that state

00:02:51,160 --> 00:02:59,170
gets rendered again in the few

00:02:53,320 --> 00:03:00,880
components and so you have one single

00:02:59,170 --> 00:03:04,030
source of truth which is if you X store

00:03:00,880 --> 00:03:08,200
this is where the current application

00:03:04,030 --> 00:03:10,810
state data is saved and components don't

00:03:08,200 --> 00:03:12,780
need to know which like how they are

00:03:10,810 --> 00:03:18,550
related

00:03:12,780 --> 00:03:20,920
all right so how this is the basic

00:03:18,550 --> 00:03:23,920
example of how to handle validation in

00:03:20,920 --> 00:03:27,370
view from from the documentation it's

00:03:23,920 --> 00:03:30,060
very simple the idea is here in your app

00:03:27,370 --> 00:03:34,330
rotator you have field one and two and

00:03:30,060 --> 00:03:37,269
and above you using a V model to bind

00:03:34,330 --> 00:03:40,540
that input data to the input the user

00:03:37,269 --> 00:03:43,269
can type in input and then if he clicks

00:03:40,540 --> 00:03:46,540
save you would call your check for

00:03:43,269 --> 00:03:49,360
method and that just checks if the if

00:03:46,540 --> 00:03:53,200
the value here for example is more than

00:03:49,360 --> 00:03:56,290
Swiss string characters if not you get

00:03:53,200 --> 00:04:01,720
an error and then eat the boards if you

00:03:56,290 --> 00:04:03,760
have arrows that is very simple and and

00:04:01,720 --> 00:04:07,330
what what's happening here is that the

00:04:03,760 --> 00:04:11,799
only safe data from the input to the

00:04:07,330 --> 00:04:14,950
store when someone clicks submit that

00:04:11,799 --> 00:04:17,560
pretty like fast becomes a problem

00:04:14,950 --> 00:04:20,229
because if you have to bandit properties

00:04:17,560 --> 00:04:22,539
or if you have some inputs but then you

00:04:20,229 --> 00:04:25,030
want to show a calculation result or

00:04:22,539 --> 00:04:25,970
something inputting data would not

00:04:25,030 --> 00:04:29,090
automatically up to

00:04:25,970 --> 00:04:31,670
day to those fields and so that's not a

00:04:29,090 --> 00:04:34,580
good solution so you actually want to

00:04:31,670 --> 00:04:39,170
save the data directly to the few X

00:04:34,580 --> 00:04:42,620
store so this would be done like here so

00:04:39,170 --> 00:04:46,400
I'm using few X map fields so what it

00:04:42,620 --> 00:04:49,580
does these fields look like normal data

00:04:46,400 --> 00:04:52,460
fields and you have a getter and a

00:04:49,580 --> 00:04:55,100
setter and so every time someone types

00:04:52,460 --> 00:05:00,440
in the input field that triggers a

00:04:55,100 --> 00:05:02,630
mutation goes into the store and yeah so

00:05:00,440 --> 00:05:05,600
everything is already changed directly

00:05:02,630 --> 00:05:09,560
in the few acts door but now our

00:05:05,600 --> 00:05:12,440
validations are only used when I would

00:05:09,560 --> 00:05:15,680
save it to the to the server the big

00:05:12,440 --> 00:05:19,120
problem here is if input here some in

00:05:15,680 --> 00:05:21,740
validator I break my whole application

00:05:19,120 --> 00:05:24,790
division by zero are some of these

00:05:21,740 --> 00:05:28,730
things which you don't want to deal with

00:05:24,790 --> 00:05:32,240
that's also very naive and bad problem

00:05:28,730 --> 00:05:35,000
so to take a step back what's actually

00:05:32,240 --> 00:05:38,300
going the actual problem behind is that

00:05:35,000 --> 00:05:43,460
we don't have one value we have one

00:05:38,300 --> 00:05:45,260
value in different representations so if

00:05:43,460 --> 00:05:50,380
you take for example euro a monetary

00:05:45,260 --> 00:05:54,590
value in the input it might look like 0

00:05:50,380 --> 00:05:58,910
comma 5 which is the localized German

00:05:54,590 --> 00:06:00,620
way of typing a number in the in the

00:05:58,910 --> 00:06:04,160
representation where I want to show it I

00:06:00,620 --> 00:06:06,410
would maybe at Euro sign before in my

00:06:04,160 --> 00:06:08,419
normalized value so the the thing I'm

00:06:06,410 --> 00:06:10,700
saving them a few acts store I might

00:06:08,419 --> 00:06:15,410
want to have it in the like as a real

00:06:10,700 --> 00:06:18,860
number 0.5 is a different type and maybe

00:06:15,410 --> 00:06:23,980
the server formats all the those as a

00:06:18,860 --> 00:06:26,360
string with with a precision afterwards

00:06:23,980 --> 00:06:28,850
so actually you have the same kind of

00:06:26,360 --> 00:06:31,130
value in different representations there

00:06:28,850 --> 00:06:33,080
would be a very good pattern to solve

00:06:31,130 --> 00:06:35,419
that which comes from the main drove

00:06:33,080 --> 00:06:36,800
design which is called a value object so

00:06:35,419 --> 00:06:39,949
you would have a value object which is

00:06:36,800 --> 00:06:43,639
my number type and I have different set

00:06:39,949 --> 00:06:46,099
to input any of those daters and then

00:06:43,639 --> 00:06:51,319
different gathers to get them in the

00:06:46,099 --> 00:06:52,909
other representation out that works

00:06:51,319 --> 00:06:54,830
really well for example if you work with

00:06:52,909 --> 00:06:58,159
larval or in any back-end application

00:06:54,830 --> 00:07:00,889
thing the problem here is this is our

00:06:58,159 --> 00:07:04,249
core domain just the tables related to

00:07:00,889 --> 00:07:06,529
calculation of prices so we have

00:07:04,249 --> 00:07:10,610
thousands of objects in our QX store and

00:07:06,529 --> 00:07:13,779
if we would use value objects the size

00:07:10,610 --> 00:07:17,029
goes like times five or something and

00:07:13,779 --> 00:07:21,139
that would mean like performance

00:07:17,029 --> 00:07:24,439
problems which we cannot accept so value

00:07:21,139 --> 00:07:27,680
objects are nubs in solution and the

00:07:24,439 --> 00:07:30,199
other solution is a heavy normalization

00:07:27,680 --> 00:07:33,169
so as soon as we get data from the

00:07:30,199 --> 00:07:36,349
server we normalizes it to our structure

00:07:33,169 --> 00:07:39,020
which is the only like way it's allowed

00:07:36,349 --> 00:07:40,539
to be in the application so all our

00:07:39,020 --> 00:07:43,159
components which are handling data

00:07:40,539 --> 00:07:48,129
become way simpler because there's just

00:07:43,159 --> 00:07:51,439
one thing they can expect to get and and

00:07:48,129 --> 00:07:53,719
then if we save again to the server we

00:07:51,439 --> 00:07:56,060
also like T normalize or like normalized

00:07:53,719 --> 00:07:58,310
to the server format and every time the

00:07:56,060 --> 00:08:00,889
user input something we make sure that

00:07:58,310 --> 00:08:04,550
it's also normalized before it goes into

00:08:00,889 --> 00:08:08,149
few acts and this reduces the complexity

00:08:04,550 --> 00:08:12,199
of the other code a lot because I always

00:08:08,149 --> 00:08:15,889
know what I can expect there was also a

00:08:12,199 --> 00:08:17,080
talk from from the one of the developers

00:08:15,889 --> 00:08:20,240
from pre-act

00:08:17,080 --> 00:08:23,120
and still latest pre-act did exactly the

00:08:20,240 --> 00:08:25,490
same they made sure that the normalized

00:08:23,120 --> 00:08:27,529
a lot a bunch of stuff and the library

00:08:25,490 --> 00:08:34,940
is like now half the size from before

00:08:27,529 --> 00:08:39,860
almost yes to explained that so that

00:08:34,940 --> 00:08:41,870
worked really well the other thing is we

00:08:39,860 --> 00:08:46,459
can have actually multiple states it's

00:08:41,870 --> 00:08:48,350
not that I just have a number I could so

00:08:46,459 --> 00:08:51,890
let's say I have a number and the number

00:08:48,350 --> 00:08:53,540
must be greater than five there would be

00:08:51,890 --> 00:08:57,170
a valid input like

00:08:53,540 --> 00:09:01,310
and that state can exist there could

00:08:57,170 --> 00:09:03,230
also be an invalid like for but there is

00:09:01,310 --> 00:09:06,410
a third one and this is the problem if

00:09:03,230 --> 00:09:10,490
the user starts typing they maybe write

00:09:06,410 --> 00:09:13,010
something like three dot because they're

00:09:10,490 --> 00:09:14,150
in typing and this is not any number

00:09:13,010 --> 00:09:16,370
which is just weird

00:09:14,150 --> 00:09:19,700
or like - because they want to type

00:09:16,370 --> 00:09:25,370
minus one so you have like non numeric

00:09:19,700 --> 00:09:27,890
things and so we have to so ii the

00:09:25,370 --> 00:09:30,560
search should actually go into this few

00:09:27,890 --> 00:09:32,000
acts door because if it's just a normal

00:09:30,560 --> 00:09:33,650
validation error i want to show you the

00:09:32,000 --> 00:09:35,780
validation error but I could still

00:09:33,650 --> 00:09:38,870
calculate the things based on that and

00:09:35,780 --> 00:09:40,250
and and can give a lot of feedback but

00:09:38,870 --> 00:09:42,710
if I get something like this I should

00:09:40,250 --> 00:09:44,780
never get it into my few X store because

00:09:42,710 --> 00:09:46,760
it will probably break some other code

00:09:44,780 --> 00:09:48,980
of duplication and that's very likely

00:09:46,760 --> 00:09:51,130
because you're not guarding against the

00:09:48,980 --> 00:09:55,910
things because you expect normalize data

00:09:51,130 --> 00:10:01,190
so yeah so the way to solve that is to

00:09:55,910 --> 00:10:03,590
actually make sure that invalid like

00:10:01,190 --> 00:10:10,040
really invalid things never go into view

00:10:03,590 --> 00:10:11,960
X so if you have a back end it's pretty

00:10:10,040 --> 00:10:15,290
simple the way how you process your

00:10:11,960 --> 00:10:17,030
request is linear you you make sure that

00:10:15,290 --> 00:10:18,950
the user actually locked in and that

00:10:17,030 --> 00:10:21,230
that you're allowed to change it then

00:10:18,950 --> 00:10:23,990
you do some normalization then you do

00:10:21,230 --> 00:10:25,580
the model validation things like it's

00:10:23,990 --> 00:10:28,690
the number bigger than 5 and these kind

00:10:25,580 --> 00:10:30,830
of things and then you can store it in

00:10:28,690 --> 00:10:33,950
in the front end it's more complicated

00:10:30,830 --> 00:10:35,540
because in the front end the user is

00:10:33,950 --> 00:10:37,250
always changing and we're not just like

00:10:35,540 --> 00:10:38,630
adding one final thing we want to say if

00:10:37,250 --> 00:10:42,830
and we can say yes or no but it's

00:10:38,630 --> 00:10:44,960
changing while the person is typing so a

00:10:42,830 --> 00:10:47,600
naive approach would be to just say like

00:10:44,960 --> 00:10:49,970
oh if the person loads the page we make

00:10:47,600 --> 00:10:53,450
sure that that the person's locked in

00:10:49,970 --> 00:10:56,270
and then if someone types in my input

00:10:53,450 --> 00:10:58,640
field it triggers with we model an

00:10:56,270 --> 00:11:02,690
action to save into X then we have a new

00:10:58,640 --> 00:11:07,220
X 3 X state which we can then validate

00:11:02,690 --> 00:11:09,939
and only allow saving if it's valid but

00:11:07,220 --> 00:11:13,759
what we discuss before we want to oh

00:11:09,939 --> 00:11:15,589
yeah we want to normalize before but we

00:11:13,759 --> 00:11:18,230
want to add this step here of basic

00:11:15,589 --> 00:11:24,829
input validation and only let's data

00:11:18,230 --> 00:11:30,379
through which looks usable and then if

00:11:24,829 --> 00:11:35,240
the if if the state is really valid so

00:11:30,379 --> 00:11:36,860
no error messages anymore the user the

00:11:35,240 --> 00:11:39,829
Save button is enabled the user can

00:11:36,860 --> 00:11:42,649
click Save it goes it's converted to the

00:11:39,829 --> 00:11:46,279
server formats safe there and when it

00:11:42,649 --> 00:11:51,110
comes back with the we began normalize

00:11:46,279 --> 00:11:56,949
it and put it back in our few X all

00:11:51,110 --> 00:12:03,589
right so let's get to a bit more code

00:11:56,949 --> 00:12:06,220
that actually is yeah let's skip that

00:12:03,589 --> 00:12:06,220
for a second

00:12:13,200 --> 00:12:20,940
all right so so here's an implementation

00:12:18,930 --> 00:12:24,450
of that and of course a very shortened

00:12:20,940 --> 00:12:26,940
version of that in our template we just

00:12:24,450 --> 00:12:29,820
have an input which binds the value of

00:12:26,940 --> 00:12:33,260
this we model and then we also care

00:12:29,820 --> 00:12:36,329
about the in blue input blur because

00:12:33,260 --> 00:12:40,550
there we are actually wanna maybe

00:12:36,329 --> 00:12:43,110
reformat date a bit then this is a

00:12:40,550 --> 00:12:48,500
component which is called I don't like

00:12:43,110 --> 00:12:51,779
my input field and it accepts a type

00:12:48,500 --> 00:12:54,019
like euro or Europe precise or integer

00:12:51,779 --> 00:12:57,149
or whatever and it accepts a value and

00:12:54,019 --> 00:13:01,639
then what it does is when it first loads

00:12:57,149 --> 00:13:05,670
up it gets the small typo here I

00:13:01,639 --> 00:13:10,430
contents the example it gets the the

00:13:05,670 --> 00:13:13,800
value this distal value and already

00:13:10,430 --> 00:13:16,470
reformatted from the few acts normalized

00:13:13,800 --> 00:13:18,630
version to the way it's supposed to be

00:13:16,470 --> 00:13:20,699
in the input so that would for example

00:13:18,630 --> 00:13:24,120
make sure that is a German number format

00:13:20,699 --> 00:13:31,920
and this is our initial values which the

00:13:24,120 --> 00:13:38,240
few input starts up and then we have our

00:13:31,920 --> 00:13:42,510
two main watch methods the first is if

00:13:38,240 --> 00:13:45,899
if let's start here if the user change

00:13:42,510 --> 00:13:48,240
something this this watch watch here

00:13:45,899 --> 00:13:52,320
would be triggered the person types into

00:13:48,240 --> 00:13:55,620
the input and this one is triggered if

00:13:52,320 --> 00:13:57,029
did so there are more rules here in the

00:13:55,620 --> 00:14:01,110
real one I'm just showing you a few

00:13:57,029 --> 00:14:04,290
examples so here if the type of this

00:14:01,110 --> 00:14:06,569
input is integer I don't want the user I

00:14:04,290 --> 00:14:09,600
don't wanna give the user a possibility

00:14:06,569 --> 00:14:11,760
to write decimals so if they want to

00:14:09,600 --> 00:14:13,589
start with typing I'm removing the

00:14:11,760 --> 00:14:18,329
character so they are never able to

00:14:13,589 --> 00:14:20,880
write that the most yeah you can do a

00:14:18,329 --> 00:14:23,459
lot of these things here then this one

00:14:20,880 --> 00:14:24,910
is also here important if the value is

00:14:23,459 --> 00:14:27,950
actually

00:14:24,910 --> 00:14:29,900
so if that's supposed to use the

00:14:27,950 --> 00:14:31,510
normalized value so if the normalized

00:14:29,900 --> 00:14:34,300
value is not a number

00:14:31,510 --> 00:14:38,240
so something weird is going on I'm

00:14:34,300 --> 00:14:42,560
setting it to zero and so it never gets

00:14:38,240 --> 00:14:44,750
to the store and and here I can apply

00:14:42,560 --> 00:14:48,860
some other things for example if the

00:14:44,750 --> 00:14:51,710
number cannot be more than 500 and the

00:14:48,860 --> 00:14:56,420
user type 700 it will decrease it to 500

00:14:51,710 --> 00:14:59,990
automatically and now that we have this

00:14:56,420 --> 00:15:02,930
so you have to so here let's say we have

00:14:59,990 --> 00:15:06,580
a valid case like the user types 50 and

00:15:02,930 --> 00:15:10,550
now 50 is saved into the view X store

00:15:06,580 --> 00:15:13,010
this will trigger as a few X creates a

00:15:10,550 --> 00:15:15,080
new state and that state will be

00:15:13,010 --> 00:15:17,450
rendered and this is the tricky part

00:15:15,080 --> 00:15:19,420
because that up a lot of actually

00:15:17,450 --> 00:15:22,760
that's in many applications weird

00:15:19,420 --> 00:15:26,000
because that would change the state of

00:15:22,760 --> 00:15:28,070
the input and so if I'm using a

00:15:26,000 --> 00:15:32,300
different formatting for example if I

00:15:28,070 --> 00:15:39,170
typically write euros with 10 or 50 I

00:15:32,300 --> 00:15:41,390
was example 50 50.00 and I would now do

00:15:39,170 --> 00:15:44,930
the whole loop the input would change

00:15:41,390 --> 00:15:48,170
from 50 to 50.00 and when the user maybe

00:15:44,930 --> 00:15:50,840
was typing he wanted is 500 for example

00:15:48,170 --> 00:15:54,770
it would change his input and so you

00:15:50,840 --> 00:15:56,390
can't type at and so so what we have to

00:15:54,770 --> 00:15:58,880
do with this watch value is to actually

00:15:56,390 --> 00:16:02,930
make sure that if we're using the same

00:15:58,880 --> 00:16:05,630
precision it's still the same value and

00:16:02,930 --> 00:16:09,470
only if the value really changed we're

00:16:05,630 --> 00:16:12,650
we're entering it and then on blur I can

00:16:09,470 --> 00:16:16,850
make sure that it's always shown the

00:16:12,650 --> 00:16:18,590
same way so if I type 50 and I moved to

00:16:16,850 --> 00:16:23,440
the next field it would automatically

00:16:18,590 --> 00:16:25,700
format the input as 50.00 which is the

00:16:23,440 --> 00:16:29,510
standard format for displaying a

00:16:25,700 --> 00:16:35,170
monetary value all right so that was a

00:16:29,510 --> 00:16:35,170
lot but that was the hard part

00:16:35,860 --> 00:16:42,040
and then there comes a simpler part

00:16:38,350 --> 00:16:45,420
which is now that we have for example in

00:16:42,040 --> 00:16:48,550
numeric value we can make a store field

00:16:45,420 --> 00:16:51,310
which encapsulate sound only did this

00:16:48,550 --> 00:16:55,180
handling but also saving too few acts

00:16:51,310 --> 00:16:58,570
and what I'm doing here is this

00:16:55,180 --> 00:17:02,860
implementation is almost exactly the

00:16:58,570 --> 00:17:05,020
same as the normal map fields the only

00:17:02,860 --> 00:17:07,380
thing which I'm changing here is I'm

00:17:05,020 --> 00:17:12,100
saying hey if this is not a valid number

00:17:07,380 --> 00:17:14,020
don't say if it too few X and I'm just

00:17:12,100 --> 00:17:16,330
this small thing make sure that I'm only

00:17:14,020 --> 00:17:19,720
having valid numbers in few X and that

00:17:16,330 --> 00:17:22,030
they are always formatted in in the

00:17:19,720 --> 00:17:27,520
courts way because I'm just refle like

00:17:22,030 --> 00:17:29,440
applying my normalization here and so

00:17:27,520 --> 00:17:31,750
all of that is encapsulated in this one

00:17:29,440 --> 00:17:33,790
store field and I never have to care

00:17:31,750 --> 00:17:35,740
about that in my whole application I can

00:17:33,790 --> 00:17:40,840
use it like 500 times and it always

00:17:35,740 --> 00:17:43,540
makes a predictable result and yeah that

00:17:40,840 --> 00:17:46,300
works really well so so I'm using it

00:17:43,540 --> 00:17:48,400
like this I'm saying hey I have a store

00:17:46,300 --> 00:17:53,800
field I'll give you the label I define

00:17:48,400 --> 00:17:54,840
the type I'm using few X with with

00:17:53,800 --> 00:17:57,340
sub-modules

00:17:54,840 --> 00:17:59,860
so this is where I'm defining what do a

00:17:57,340 --> 00:18:01,810
sub-module I'm using and I'm define

00:17:59,860 --> 00:18:05,410
finding the pass in the few X store

00:18:01,810 --> 00:18:11,800
where the value is bound to and that's

00:18:05,410 --> 00:18:14,440
it and so the the code where I'm using

00:18:11,800 --> 00:18:17,770
per half like a long form with a lot of

00:18:14,440 --> 00:18:20,920
inputs and they have different types and

00:18:17,770 --> 00:18:23,830
everything it's just really simple and

00:18:20,920 --> 00:18:28,270
readable and removed all the complexity

00:18:23,830 --> 00:18:31,060
and yeah and and it's a bit bigger

00:18:28,270 --> 00:18:33,490
because it doesn't not it does not only

00:18:31,060 --> 00:18:35,650
implement marek values but it also

00:18:33,490 --> 00:18:40,240
prevents string values and things like

00:18:35,650 --> 00:18:44,200
that you can imagine but the two the two

00:18:40,240 --> 00:18:46,840
files I showed you this one here which

00:18:44,200 --> 00:18:51,340
is the numeric input validation at the

00:18:46,840 --> 00:18:53,310
marek input and the store filled in the

00:18:51,340 --> 00:18:58,800
final solution with implementing

00:18:53,310 --> 00:18:58,800
required minimal back legs max length

00:18:59,460 --> 00:19:04,630
number sizes and all that kind of thing

00:19:02,380 --> 00:19:07,870
they're both less than 400 characters

00:19:04,630 --> 00:19:09,610
lines of code not characters that would

00:19:07,870 --> 00:19:13,030
be amazing

00:19:09,610 --> 00:19:16,330
yeah and if you have this or something

00:19:13,030 --> 00:19:19,740
like this it's not about the exact code

00:19:16,330 --> 00:19:23,050
but it's about the concept of saying hey

00:19:19,740 --> 00:19:25,750
few X only has normalized value it's

00:19:23,050 --> 00:19:28,750
later it may be has validation errors

00:19:25,750 --> 00:19:32,710
but it's like this the correct type and

00:19:28,750 --> 00:19:36,010
and a usable format and and handling

00:19:32,710 --> 00:19:37,720
everything before and then of course you

00:19:36,010 --> 00:19:39,070
will see if you do that in three

00:19:37,720 --> 00:19:40,480
components you see the pattern and you

00:19:39,070 --> 00:19:42,610
can abstract it to something like this

00:19:40,480 --> 00:19:47,770
and that might look a bit different in

00:19:42,610 --> 00:19:50,200
your application yeah if you have this

00:19:47,770 --> 00:19:53,500
you can do a lot of stuff for example

00:19:50,200 --> 00:19:56,080
let's say you have dependent things

00:19:53,500 --> 00:19:59,320
which are so for example let's say

00:19:56,080 --> 00:20:04,030
that's a made-up example if it would

00:19:59,320 --> 00:20:06,610
disable SMS sending on my product it

00:20:04,030 --> 00:20:09,820
would make sense to remove all the SMS

00:20:06,610 --> 00:20:13,290
packages and this can be implemented

00:20:09,820 --> 00:20:15,820
then in a few X store in the subscribe

00:20:13,290 --> 00:20:18,010
because I know only valid stuff is

00:20:15,820 --> 00:20:19,990
coming in too few X and so in few X I

00:20:18,010 --> 00:20:23,200
can say like hey subscribe to any

00:20:19,990 --> 00:20:25,450
mutation of product SMS enabled and then

00:20:23,200 --> 00:20:31,570
I'm just removing all the the packages

00:20:25,450 --> 00:20:34,960
and this is super easy to read and is

00:20:31,570 --> 00:20:39,160
stable and all your data consistency

00:20:34,960 --> 00:20:42,130
logic is in view and in view acts the

00:20:39,160 --> 00:20:44,380
one single source of truth and now the

00:20:42,130 --> 00:20:46,600
input components for for your editors

00:20:44,380 --> 00:20:48,340
they don't have to have any logic

00:20:46,600 --> 00:20:51,850
anymore that's why they look so simple

00:20:48,340 --> 00:20:54,880
in the end because all the logic is is

00:20:51,850 --> 00:20:57,100
placed somewhere else and independent of

00:20:54,880 --> 00:21:00,550
the actual form where the user changes

00:20:57,100 --> 00:21:04,420
stuff and this is different than

00:21:00,550 --> 00:21:06,280
most few applications you'll find most

00:21:04,420 --> 00:21:09,010
examples and things like that you find

00:21:06,280 --> 00:21:11,080
out on the web they always have a lot of

00:21:09,010 --> 00:21:14,470
business logic in the form component and

00:21:11,080 --> 00:21:20,830
that does not work in projects of this

00:21:14,470 --> 00:21:24,370
size also if we now know that the data

00:21:20,830 --> 00:21:28,140
is normalized exactly the same format in

00:21:24,370 --> 00:21:31,270
my few X store it's very easy to know if

00:21:28,140 --> 00:21:34,540
if the user actually changed something

00:21:31,270 --> 00:21:37,180
so I have 50 inputs on the field the

00:21:34,540 --> 00:21:39,520
user type something maybe removes it

00:21:37,180 --> 00:21:43,570
again changes it around five times and

00:21:39,520 --> 00:21:45,910
to check if it's dirty it's just really

00:21:43,570 --> 00:21:48,940
simple because what I'm doing here

00:21:45,910 --> 00:21:51,520
when I first hit the store I'm just

00:21:48,940 --> 00:21:53,050
making a clone of the data and saving it

00:21:51,520 --> 00:21:55,600
as server data that that's already

00:21:53,050 --> 00:21:57,250
normalize data that's important part you

00:21:55,600 --> 00:22:00,700
have to first normalize it and when it's

00:21:57,250 --> 00:22:02,380
normalized you make a copy and then you

00:22:00,700 --> 00:22:05,170
can simply check if it's dirty by

00:22:02,380 --> 00:22:06,580
comparing your current state to your

00:22:05,170 --> 00:22:11,380
initial State

00:22:06,580 --> 00:22:17,100
and yeah we passed Eve equal that that

00:22:11,380 --> 00:22:17,100
is really fast even more non big things

00:22:18,390 --> 00:22:27,370
yeah so so so the input component does

00:22:24,790 --> 00:22:30,540
not have to know anything about context

00:22:27,370 --> 00:22:34,600
anymore which you'll find also in in

00:22:30,540 --> 00:22:38,440
typical examples of of you validate or

00:22:34,600 --> 00:22:41,650
fee validate that that the outer form

00:22:38,440 --> 00:22:44,800
has some context and and understands the

00:22:41,650 --> 00:22:48,280
context now my single input no one has

00:22:44,800 --> 00:22:50,290
to know the context except UX the one

00:22:48,280 --> 00:22:53,050
one input field just knows hey I'm an

00:22:50,290 --> 00:22:54,490
input field for something and these

00:22:53,050 --> 00:22:59,050
dependencies and everything is handled

00:22:54,490 --> 00:23:04,110
in the store yeah and and it's only

00:22:59,050 --> 00:23:04,110
emitting valid things we had that

00:23:06,600 --> 00:23:14,910
all right um on top of that I added

00:23:11,910 --> 00:23:18,160
cliff input mask my true heart prompted

00:23:14,910 --> 00:23:20,680
so basically it would actually have an

00:23:18,160 --> 00:23:23,680
input mask on inputs like it shows the

00:23:20,680 --> 00:23:25,450
Euro sign before and and and or shows me

00:23:23,680 --> 00:23:33,160
some structure how phone numbers

00:23:25,450 --> 00:23:35,770
supposed to look things like that yeah

00:23:33,160 --> 00:23:40,540
yeah things are not that interesting for

00:23:35,770 --> 00:23:45,280
you let's see how in time so how much

00:23:40,540 --> 00:23:53,760
could you follow me so far yes no so so

00:23:45,280 --> 00:23:56,860
so okay so that's one final thing

00:23:53,760 --> 00:24:00,400
this was quite up to you to

00:23:56,860 --> 00:24:06,070
implement the basic idea of this thing

00:24:00,400 --> 00:24:08,850
here was that administrators of the

00:24:06,070 --> 00:24:11,980
platform should be able to find

00:24:08,850 --> 00:24:17,410
threshold validation so do you want to

00:24:11,980 --> 00:24:20,260
say they were to say I don't know some

00:24:17,410 --> 00:24:22,240
some input needs to be about five stuff

00:24:20,260 --> 00:24:25,630
like that but also they maybe want to

00:24:22,240 --> 00:24:31,090
say all the products counted together

00:24:25,630 --> 00:24:36,130
must at least have a monthly a charge of

00:24:31,090 --> 00:24:38,920
300 years or something like that and and

00:24:36,130 --> 00:24:41,860
at first we had that implemented like

00:24:38,920 --> 00:24:44,560
specifically like a we calculate some

00:24:41,860 --> 00:24:47,280
things and that became on one hand it

00:24:44,560 --> 00:24:50,050
became a bit messy on the other hand

00:24:47,280 --> 00:24:52,360
requirement was that some of the rules

00:24:50,050 --> 00:24:53,590
were actually hidden so it could not be

00:24:52,360 --> 00:24:56,830
in JavaScript they had to be on the

00:24:53,590 --> 00:24:59,050
server because they have some some

00:24:56,830 --> 00:25:04,360
matrixes and they should not be shared

00:24:59,050 --> 00:25:07,510
with everybody and the way we solve that

00:25:04,360 --> 00:25:10,780
and it was quite an unusual but funny

00:25:07,510 --> 00:25:13,360
solution was there's a library called

00:25:10,780 --> 00:25:16,330
cakephp hash

00:25:13,360 --> 00:25:18,440
there are similar libraries what you can

00:25:16,330 --> 00:25:22,840
do is you can can define

00:25:18,440 --> 00:25:28,280
like this it was a object dot any dot

00:25:22,840 --> 00:25:33,080
some other object dot any were the the

00:25:28,280 --> 00:25:34,550
ID equals something dot price so so on

00:25:33,080 --> 00:25:39,080
this server I can we find these kind of

00:25:34,550 --> 00:25:42,260
rules and then I want to validate them

00:25:39,080 --> 00:25:46,820
on the client the problem is since these

00:25:42,260 --> 00:25:48,980
are replaceable things you could for

00:25:46,820 --> 00:25:54,110
example say like here if this object

00:25:48,980 --> 00:25:58,010
here has a valid I don't know if lack of

00:25:54,110 --> 00:26:02,930
true only then check for the price here

00:25:58,010 --> 00:26:09,470
and so you cannot statically validate

00:26:02,930 --> 00:26:11,450
that and you cannot just check if the

00:26:09,470 --> 00:26:13,310
the rule applies because it depends on

00:26:11,450 --> 00:26:16,220
your current data depending on the

00:26:13,310 --> 00:26:21,560
current input ater the rule might apply

00:26:16,220 --> 00:26:23,180
or not apply and yeah and here at the

00:26:21,560 --> 00:26:25,460
top we define what we have before we

00:26:23,180 --> 00:26:28,760
define our current field past this is

00:26:25,460 --> 00:26:30,320
what's going on if you X and then here

00:26:28,760 --> 00:26:43,100
we can define validation rules in the

00:26:30,320 --> 00:26:50,330
way this is implemented is of course in

00:26:43,100 --> 00:26:55,700
an own store let me just find the

00:26:50,330 --> 00:26:59,000
interesting part yeah so what I'm I'm

00:26:55,700 --> 00:27:03,650
actually doing here is I'm taking the

00:26:59,000 --> 00:27:06,200
current state of UX I'm finding all the

00:27:03,650 --> 00:27:09,340
the passes which match and I'm sending a

00:27:06,200 --> 00:27:13,720
honeypot there and then I'm applying the

00:27:09,340 --> 00:27:16,280
the server side cake cake hatch and

00:27:13,720 --> 00:27:17,420
checking if it finds the honeypot and if

00:27:16,280 --> 00:27:18,560
it finds the honeypot then the

00:27:17,420 --> 00:27:24,890
validation rule needs to be applied on

00:27:18,560 --> 00:27:26,480
there yeah and then we had to do and

00:27:24,890 --> 00:27:27,860
then we have some automatic error

00:27:26,480 --> 00:27:31,130
messages and everything like that

00:27:27,860 --> 00:27:33,350
so now we could define

00:27:31,130 --> 00:27:39,500
huge amount of those rules just on the

00:27:33,350 --> 00:27:41,390
server and and and don't need to change

00:27:39,500 --> 00:27:48,050
anything in application but still can

00:27:41,390 --> 00:27:50,990
can push new rules yeah I think that's

00:27:48,050 --> 00:27:53,570
something maybe you have to can think

00:27:50,990 --> 00:27:56,500
about and of course that was super um

00:27:53,570 --> 00:27:58,150
performant in the beginning so we had to

00:27:56,500 --> 00:28:02,180
delay it

00:27:58,150 --> 00:28:05,210
after the initial rendering yeah but

00:28:02,180 --> 00:28:06,410
then it was really cool and now changes

00:28:05,210 --> 00:28:08,860
from the client they're super easy to

00:28:06,410 --> 00:28:11,870
implement because we have all of this

00:28:08,860 --> 00:28:13,340
build up and so if you want to add a few

00:28:11,870 --> 00:28:15,650
fields if you want to add a few really

00:28:13,340 --> 00:28:18,530
Dasia rules it's just want to place this

00:28:15,650 --> 00:28:23,380
in the backend and step location and it

00:28:18,530 --> 00:28:23,380
handle everything alright

00:28:24,430 --> 00:28:31,550
thank you for yeah oh yeah tables look

00:28:27,590 --> 00:28:33,260
like this so there's a lot of data and

00:28:31,550 --> 00:28:36,170
you can see some of them are invalidated

00:28:33,260 --> 00:28:38,210
and like not able to change depending on

00:28:36,170 --> 00:28:42,350
other properties so it gets quite

00:28:38,210 --> 00:28:44,990
complicated key takeaways normalize

00:28:42,350 --> 00:28:49,940
everything you get into your application

00:28:44,990 --> 00:28:51,920
at first and on user input and then your

00:28:49,940 --> 00:28:53,900
life becomes way easier because you

00:28:51,920 --> 00:28:55,900
never have to care about hey I'm getting

00:28:53,900 --> 00:28:58,790
the right type - I'm getting the right

00:28:55,900 --> 00:29:00,970
something because it just you know what

00:28:58,790 --> 00:29:00,970
to expect

00:29:01,150 --> 00:29:07,040
never and that's connected never save

00:29:05,270 --> 00:29:09,950
something in few X which has the wrong

00:29:07,040 --> 00:29:11,570
type or the wrong format or something

00:29:09,950 --> 00:29:24,020
because it will up your application

00:29:11,570 --> 00:29:28,150
very easily and which yeah and and and

00:29:24,020 --> 00:29:31,940
handle handle all business logic as for

00:29:28,150 --> 00:29:35,300
this kind of like data logic in few X

00:29:31,940 --> 00:29:37,400
that makes your life easier if you want

00:29:35,300 --> 00:29:39,620
to see specific code it's a huge project

00:29:37,400 --> 00:29:42,990
as I mentioned feel free to write me or

00:29:39,620 --> 00:29:46,499
ask me and thanks for listening

00:29:42,990 --> 00:29:46,499

YouTube URL: https://www.youtube.com/watch?v=UHAovBKGqRU


