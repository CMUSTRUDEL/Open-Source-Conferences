Title: Vue.js Vienna, Reactive Vue, November 2018
Publication date: 2018-12-01
Playlist: Vue.js Vienna
Description: 
	TALK: Reactive Vue, by Miroslav JonaÅ¡

In this talk, we will break down ReactiveX and reactiveness to basics by using everyday metaphors. Next, we will use this reactive mindset on stage to build the logic for a popular game.
Captions: 
	00:00:00,030 --> 00:00:06,029
so thank you for having me today now

00:00:02,760 --> 00:00:08,820
before I start before I dive into the

00:00:06,029 --> 00:00:12,080
reactive amazing world of you let me

00:00:08,820 --> 00:00:15,509
just briefly introduce myself

00:00:12,080 --> 00:00:17,690
yeah for this works there is some slight

00:00:15,509 --> 00:00:20,460
delay because of the chromecast so

00:00:17,690 --> 00:00:23,789
please have patience so as you can see

00:00:20,460 --> 00:00:26,609
my name is mere astonish underneath you

00:00:23,789 --> 00:00:29,130
have my Twitter handle and my github

00:00:26,609 --> 00:00:31,740
handle so feel free to follow me to it

00:00:29,130 --> 00:00:35,579
nice talk me fort me whatever I'm

00:00:31,740 --> 00:00:37,440
developer at 5g systems and I'm quite

00:00:35,579 --> 00:00:39,180
active in angular community I'm one of

00:00:37,440 --> 00:00:42,000
the cofounders of angular Austria

00:00:39,180 --> 00:00:46,649
association so although some of you

00:00:42,000 --> 00:00:51,530
might know rxjs as a socio the

00:00:46,649 --> 00:00:55,350
associated associated sorry to angular

00:00:51,530 --> 00:01:00,320
reactive axis actually we older than

00:00:55,350 --> 00:01:03,660
both angular and rxjs the reactive ideas

00:01:00,320 --> 00:01:06,810
first came out in 2009 they were

00:01:03,660 --> 00:01:09,750
implemented originally for dotnet inside

00:01:06,810 --> 00:01:12,210
the Microsoft by this guy his name is

00:01:09,750 --> 00:01:15,479
Eric Meyer and you can also recognize

00:01:12,210 --> 00:01:19,259
him by this psychedelic dishes that is

00:01:15,479 --> 00:01:21,390
that he likes to wear so he set up the

00:01:19,259 --> 00:01:23,970
whole theory about around the reactive

00:01:21,390 --> 00:01:27,180
programming and this idea was really

00:01:23,970 --> 00:01:29,040
well adopted first in.net so it soon

00:01:27,180 --> 00:01:31,829
followed in other programming languages

00:01:29,040 --> 00:01:33,570
so today now we have originally original

00:01:31,829 --> 00:01:37,619
reactive acts implemented not only

00:01:33,570 --> 00:01:40,970
dotnet but also in java in python in PHP

00:01:37,619 --> 00:01:43,799
in ruby go etcetera so in most of the

00:01:40,970 --> 00:01:46,770
popular programming languages you not

00:01:43,799 --> 00:01:48,930
only it exists as a part of this

00:01:46,770 --> 00:01:51,720
official reactive acts there are a lot

00:01:48,930 --> 00:01:55,229
of different libraries and frameworks

00:01:51,720 --> 00:01:57,329
that copy the same idea and have some

00:01:55,229 --> 00:02:00,119
slight differences some are more

00:01:57,329 --> 00:02:04,170
performance and have some different

00:02:00,119 --> 00:02:08,610
operators than reactive acts but in

00:02:04,170 --> 00:02:11,370
shell they share the same idea so let's

00:02:08,610 --> 00:02:14,030
see what exactly is reactive acts you

00:02:11,370 --> 00:02:16,880
know before I give you more insight

00:02:14,030 --> 00:02:18,530
on what is reactive X I want you first

00:02:16,880 --> 00:02:21,260
to tell me how many of you actually

00:02:18,530 --> 00:02:24,380
heard about our X yes and no it doesn't

00:02:21,260 --> 00:02:27,770
count if you just heard it minute ago so

00:02:24,380 --> 00:02:29,780
just raise your hands okay and how many

00:02:27,770 --> 00:02:33,680
of you have actually used rxjs

00:02:29,780 --> 00:02:37,250
in the software okay cool so this might

00:02:33,680 --> 00:02:39,709
be interesting to them so there are a

00:02:37,250 --> 00:02:43,280
lot of definitions on reactive X some

00:02:39,709 --> 00:02:46,790
are bit cryptic some are circular so

00:02:43,280 --> 00:02:49,370
they kind of explain itself by referring

00:02:46,790 --> 00:02:52,250
to itself but one of the definitions

00:02:49,370 --> 00:02:54,280
that I like the most is that reactive X

00:02:52,250 --> 00:02:57,380
is combination of the best ideas from

00:02:54,280 --> 00:02:59,450
three things that's functional

00:02:57,380 --> 00:03:02,180
programming iterator pattern and

00:02:59,450 --> 00:03:04,760
observer pattern now if some of these

00:03:02,180 --> 00:03:06,200
concepts are foreign to you don't worry

00:03:04,760 --> 00:03:09,709
because we're going to explain them one

00:03:06,200 --> 00:03:11,360
by one so the first one is functional

00:03:09,709 --> 00:03:14,500
programming functional programming is

00:03:11,360 --> 00:03:18,590
actually styled in programming where you

00:03:14,500 --> 00:03:21,680
instead of writing procedures you show

00:03:18,590 --> 00:03:23,630
the logic of your code through a list of

00:03:21,680 --> 00:03:27,019
chain functions where each function is

00:03:23,630 --> 00:03:30,440
pure function now pure function means

00:03:27,019 --> 00:03:33,019
that function has clear input and clear

00:03:30,440 --> 00:03:35,150
output and it doesn't have a state so if

00:03:33,019 --> 00:03:37,220
you run the same function with the same

00:03:35,150 --> 00:03:39,590
input it will always give you the same

00:03:37,220 --> 00:03:42,590
output also the second important thing

00:03:39,590 --> 00:03:45,230
is that every function doesn't have side

00:03:42,590 --> 00:03:47,060
effects so that means the function is

00:03:45,230 --> 00:03:49,489
doing exactly what it should it takes

00:03:47,060 --> 00:03:52,329
the input calculate somehow the output

00:03:49,489 --> 00:03:56,859
without changing something on the side

00:03:52,329 --> 00:03:59,690
now maybe it's bit easier if I explain

00:03:56,859 --> 00:04:01,549
how the functional programming works by

00:03:59,690 --> 00:04:05,269
showing what functional programming is

00:04:01,549 --> 00:04:08,720
not and for this we're going to have our

00:04:05,269 --> 00:04:12,320
first eating a metaphor for today so on

00:04:08,720 --> 00:04:14,239
the slide you can see one on what so

00:04:12,320 --> 00:04:17,239
we're going to show how the typical

00:04:14,239 --> 00:04:19,850
scrambled eggs recipe looks like I'm

00:04:17,239 --> 00:04:22,640
sure you all made scrambled eggs at

00:04:19,850 --> 00:04:25,039
least once in your life but this is

00:04:22,640 --> 00:04:26,410
generally how every recipe looks like so

00:04:25,039 --> 00:04:29,100
first you have some ingre

00:04:26,410 --> 00:04:32,770
you assemble them they all have some

00:04:29,100 --> 00:04:38,280
different amount in which you need them

00:04:32,770 --> 00:04:40,450
then you have usually some mechanical

00:04:38,280 --> 00:04:43,210
processing of these ingredients like

00:04:40,450 --> 00:04:45,910
chopping them slicing them mixing them

00:04:43,210 --> 00:04:47,650
etc then there's a main cooking part

00:04:45,910 --> 00:04:49,930
where you actually process the

00:04:47,650 --> 00:04:53,850
ingredients and finally your meal is

00:04:49,930 --> 00:04:56,260
done and you can serve it now this

00:04:53,850 --> 00:04:59,410
recipe that you see on the screen is

00:04:56,260 --> 00:05:02,530
quite trivial and most of the recipes

00:04:59,410 --> 00:05:04,840
are but there is one thing that recipes

00:05:02,530 --> 00:05:07,450
usually don't expose and that is what

00:05:04,840 --> 00:05:10,300
happens if you are dealing with some

00:05:07,450 --> 00:05:12,520
non-standard situation so normally this

00:05:10,300 --> 00:05:15,640
is a recipe for one person what would

00:05:12,520 --> 00:05:17,830
happen if you had two people or if you

00:05:15,640 --> 00:05:19,990
have one person that is really really

00:05:17,830 --> 00:05:23,380
hungry which part of these you have to

00:05:19,990 --> 00:05:25,450
double so normally everyone who made

00:05:23,380 --> 00:05:28,420
ever in their life some scrambled eggs

00:05:25,450 --> 00:05:32,050
they know that they need twice as much X

00:05:28,420 --> 00:05:33,660
if they want double portion maybe twice

00:05:32,050 --> 00:05:37,630
as much salt twice as much pepper

00:05:33,660 --> 00:05:41,110
perhaps twice as much oil but do we need

00:05:37,630 --> 00:05:44,200
two paths or two stalls now this

00:05:41,110 --> 00:05:46,540
question might sound trivial or stupid

00:05:44,200 --> 00:05:48,700
even but imagine that this is not

00:05:46,540 --> 00:05:52,000
scrambled eggs recipe imagine that this

00:05:48,700 --> 00:05:54,700
is some super complex chemical reaction

00:05:52,000 --> 00:05:57,790
that you have no no idea about would you

00:05:54,700 --> 00:05:59,650
still be able to confidently say which

00:05:57,790 --> 00:06:03,520
parts of this reaction have to be

00:05:59,650 --> 00:06:05,050
doubled or not and accidentally these

00:06:03,520 --> 00:06:06,910
are the questions that we ask ourselves

00:06:05,050 --> 00:06:09,250
every day when we implement something

00:06:06,910 --> 00:06:12,460
what things can we paralyze

00:06:09,250 --> 00:06:15,070
what can be reshuffled how can we reuse

00:06:12,460 --> 00:06:17,620
some resources what happens if there is

00:06:15,070 --> 00:06:20,020
an error for example if the energy

00:06:17,620 --> 00:06:22,000
electrical energy goes away do we have

00:06:20,020 --> 00:06:24,580
to restart everything or can we just

00:06:22,000 --> 00:06:27,190
continue making our scrambled eggs once

00:06:24,580 --> 00:06:30,160
the electricity is back of course this

00:06:27,190 --> 00:06:32,020
is trivial for scrambled eggs but for

00:06:30,160 --> 00:06:34,150
some things it might not be the trivial

00:06:32,020 --> 00:06:37,630
so let's see how this would look like in

00:06:34,150 --> 00:06:40,060
a functional way now you can clearly see

00:06:37,630 --> 00:06:41,830
the hierarchy coming

00:06:40,060 --> 00:06:44,440
just from these linked functions so we

00:06:41,830 --> 00:06:48,100
can see that we can only serve the meal

00:06:44,440 --> 00:06:50,560
once the steering has been done and we

00:06:48,100 --> 00:06:53,980
can see that steering depends on the

00:06:50,560 --> 00:06:57,520
fact that the ingredients or our main

00:06:53,980 --> 00:07:00,460
meal has thickened and we can also see

00:06:57,520 --> 00:07:03,190
that the heating the of the butter or

00:07:00,460 --> 00:07:06,490
oil in the pan can be done in parallel

00:07:03,190 --> 00:07:08,590
with the beating of X salt and pepper so

00:07:06,490 --> 00:07:11,050
you can already see that which parts can

00:07:08,590 --> 00:07:13,389
be done in parallel which parts can be

00:07:11,050 --> 00:07:15,340
shuffled what are the kind of

00:07:13,389 --> 00:07:18,910
hierarchical dependencies between the

00:07:15,340 --> 00:07:22,300
steps now if we consider that beating

00:07:18,910 --> 00:07:25,060
the eggs and steering them can be kind

00:07:22,300 --> 00:07:28,720
of explained as just simply mixing the

00:07:25,060 --> 00:07:31,090
ingredients then instead of this we can

00:07:28,720 --> 00:07:34,120
just say that we have some stream of

00:07:31,090 --> 00:07:35,860
ingredients that we put in the pan and

00:07:34,120 --> 00:07:37,930
we steered them until they have

00:07:35,860 --> 00:07:41,169
thickened that would also mean that we

00:07:37,930 --> 00:07:43,210
can start with 2x and somewhere when we

00:07:41,169 --> 00:07:45,850
are halfway there just add another egg

00:07:43,210 --> 00:07:48,880
in another egg of course we will finish

00:07:45,850 --> 00:07:51,760
once everything this has thickened but

00:07:48,880 --> 00:07:54,340
as long as it's not done we can still

00:07:51,760 --> 00:07:56,979
add ingredients and this is what

00:07:54,340 --> 00:07:59,140
functional view on your development

00:07:56,979 --> 00:08:02,320
gives you it gives you more insight what

00:07:59,140 --> 00:08:06,400
you can do and what you cannot do now

00:08:02,320 --> 00:08:08,500
the next two next two patterns that we

00:08:06,400 --> 00:08:11,590
are going to describe are the original

00:08:08,500 --> 00:08:13,479
patterns coming by the proposal from

00:08:11,590 --> 00:08:16,630
Gang of Four for those of you who don't

00:08:13,479 --> 00:08:19,600
know what can go for is those are for

00:08:16,630 --> 00:08:23,200
outers that wrote book back in the 90s

00:08:19,600 --> 00:08:24,940
and the book is called design patterns

00:08:23,200 --> 00:08:28,060
elements of reusable object-oriented

00:08:24,940 --> 00:08:31,750
software and although this book is more

00:08:28,060 --> 00:08:33,520
than twenty years old the patterns that

00:08:31,750 --> 00:08:36,580
are described in this book are still

00:08:33,520 --> 00:08:39,159
quite relevant in today's development

00:08:36,580 --> 00:08:41,560
maybe not as much as they were relevant

00:08:39,159 --> 00:08:42,940
back in the days but you can still use

00:08:41,560 --> 00:08:46,029
them and you still use them in your

00:08:42,940 --> 00:08:47,740
daily work so the first pattern that

00:08:46,029 --> 00:08:48,560
we're going to explain is iterator

00:08:47,740 --> 00:08:51,709
pattern

00:08:48,560 --> 00:08:54,499
now for this pattern I want you all to

00:08:51,709 --> 00:08:57,110
imagine the best pizza in the world

00:08:54,499 --> 00:08:59,810
just imagine the best pizza you ate in

00:08:57,110 --> 00:09:02,620
your life you can choose the toppings

00:08:59,810 --> 00:09:05,329
you can choose the size the size and

00:09:02,620 --> 00:09:07,009
imagine this pizza standing somewhere in

00:09:05,329 --> 00:09:10,249
front of you now for those of you who

00:09:07,009 --> 00:09:12,709
don't like pizza I have a bad news

00:09:10,249 --> 00:09:17,120
unfortunately this is pre requisite to

00:09:12,709 --> 00:09:19,550
learn reactiveness so sorry now imagine

00:09:17,120 --> 00:09:22,879
the best pizza and this pizza is already

00:09:19,550 --> 00:09:25,670
pre sliced you slowly approach this

00:09:22,879 --> 00:09:29,170
pizza first you look at it and then you

00:09:25,670 --> 00:09:32,660
say hey pizza can I have a slice and

00:09:29,170 --> 00:09:34,610
pizza replies sure go ahead and you take

00:09:32,660 --> 00:09:37,249
the slice and you eat the slice and it's

00:09:34,610 --> 00:09:40,249
the best lies you ate in your life but

00:09:37,249 --> 00:09:42,319
then you realize you're still hungry so

00:09:40,249 --> 00:09:44,959
you come to pizza and you say hey pizza

00:09:42,319 --> 00:09:48,319
can I have another slice and Peter says

00:09:44,959 --> 00:09:49,999
sure take another one and you keep

00:09:48,319 --> 00:09:53,209
taking one after another after another

00:09:49,999 --> 00:09:55,490
at some point you come to pizza and the

00:09:53,209 --> 00:09:59,209
pizza says sorry there are no slices

00:09:55,490 --> 00:10:02,569
left so this is in short how iterator

00:09:59,209 --> 00:10:05,569
works it gives you structure over a

00:10:02,569 --> 00:10:07,370
collection and you can retrieve the

00:10:05,569 --> 00:10:10,189
items from this collection one by one

00:10:07,370 --> 00:10:12,920
and it also tells you whether there are

00:10:10,189 --> 00:10:17,720
more items left and it has of course

00:10:12,920 --> 00:10:21,230
some limited capacity now if iterator

00:10:17,720 --> 00:10:24,230
was kind of manual because you have to

00:10:21,230 --> 00:10:27,470
ask for each slice the observer pattern

00:10:24,230 --> 00:10:29,480
works bit differently you subscribe once

00:10:27,470 --> 00:10:32,179
to the events and you just wait for

00:10:29,480 --> 00:10:34,329
these events to arrive now in order to

00:10:32,179 --> 00:10:38,089
explain this I'm going to tell you a

00:10:34,329 --> 00:10:41,779
short story when I was young I was

00:10:38,089 --> 00:10:43,699
living in a small town and being a small

00:10:41,779 --> 00:10:46,429
town you couldn't just buy bread

00:10:43,699 --> 00:10:49,429
whenever you want it you had to register

00:10:46,429 --> 00:10:51,740
in a local market day before and you

00:10:49,429 --> 00:10:54,829
have to kind of reserve the lot of bread

00:10:51,740 --> 00:10:57,199
now this bread would usually come

00:10:54,829 --> 00:11:00,199
between seven and eight which was time

00:10:57,199 --> 00:11:02,450
when my entire family would go to school

00:11:00,199 --> 00:11:05,000
/ work so it wouldn't be a

00:11:02,450 --> 00:11:07,190
physically to pick up our bread and we

00:11:05,000 --> 00:11:10,279
didn't want it to stay there in the

00:11:07,190 --> 00:11:13,220
market for the half of the day so a

00:11:10,279 --> 00:11:15,260
grandma who was living like quite close

00:11:13,220 --> 00:11:17,089
to us she would go in the morning she

00:11:15,260 --> 00:11:19,310
would pick up load of bread for them and

00:11:17,089 --> 00:11:21,800
for us and then when I was coming back

00:11:19,310 --> 00:11:24,139
from school I would stop by to take this

00:11:21,800 --> 00:11:27,170
bread now this was usually around

00:11:24,139 --> 00:11:29,959
lunchtime and I was of course at that

00:11:27,170 --> 00:11:32,540
point quite hungry so I would normally

00:11:29,959 --> 00:11:35,050
have lunch at their place now I would

00:11:32,540 --> 00:11:39,649
usually eat scrambled eggs which I just

00:11:35,050 --> 00:11:42,260
told you about but what my grandma was

00:11:39,649 --> 00:11:44,360
really what her speciality really was

00:11:42,260 --> 00:11:47,180
was making pancakes

00:11:44,360 --> 00:11:49,430
she was really expert in making the best

00:11:47,180 --> 00:11:51,769
pancakes in the world and what I would

00:11:49,430 --> 00:11:53,839
normally do if I felt like eating

00:11:51,769 --> 00:11:56,180
pancakes I would just come to grandma

00:11:53,839 --> 00:11:58,550
and I would say hey grandma I'm hungry

00:11:56,180 --> 00:12:00,410
can you make some pancakes and then a

00:11:58,550 --> 00:12:01,910
split second later should be standing

00:12:00,410 --> 00:12:04,250
next to the stove making the pancakes

00:12:01,910 --> 00:12:06,290
and I would wait couple of minutes and

00:12:04,250 --> 00:12:08,390
then pay cakes would start arriving one

00:12:06,290 --> 00:12:10,430
after another I mean they would keep

00:12:08,390 --> 00:12:12,649
coming and coming and coming and at some

00:12:10,430 --> 00:12:14,750
point I would have to say to my grandma

00:12:12,649 --> 00:12:16,790
hey grandma stop I'm full I cannot eat

00:12:14,750 --> 00:12:19,579
anymore and this is how the observer

00:12:16,790 --> 00:12:22,130
works so you subscribe to something you

00:12:19,579 --> 00:12:23,839
wait for this Stevens to arrive and at

00:12:22,130 --> 00:12:26,000
some point you have to cancel your

00:12:23,839 --> 00:12:30,910
subscription otherwise this will keep

00:12:26,000 --> 00:12:34,990
coming and coming in coming forever now

00:12:30,910 --> 00:12:37,390
observer doesn't have to give you

00:12:34,990 --> 00:12:40,250
subscription over a collection of items

00:12:37,390 --> 00:12:43,010
you can subscribe just to a single event

00:12:40,250 --> 00:12:45,470
just imagine if you're making HTTP call

00:12:43,010 --> 00:12:48,170
this is usually a one-time event so you

00:12:45,470 --> 00:12:50,060
subscribe you get something back and

00:12:48,170 --> 00:12:53,269
then your subscription is gone there's

00:12:50,060 --> 00:12:56,959
nothing else coming back now this is

00:12:53,269 --> 00:12:59,139
roughly two types of observables so we

00:12:56,959 --> 00:13:02,290
have like one-time observables and

00:12:59,139 --> 00:13:05,120
observables that come in the streams and

00:13:02,290 --> 00:13:06,889
anything can be observable the chair

00:13:05,120 --> 00:13:10,310
next to you the person next to you can

00:13:06,889 --> 00:13:12,649
be observable so any tangible or any

00:13:10,310 --> 00:13:13,630
item that you can think of can be

00:13:12,649 --> 00:13:17,050
wrapped as an observed

00:13:13,630 --> 00:13:21,820
but there are also roughly two types of

00:13:17,050 --> 00:13:23,800
observables hot and cold observables now

00:13:21,820 --> 00:13:26,410
for those of you that know me know that

00:13:23,800 --> 00:13:28,890
I'm a really big fan of sushi and I

00:13:26,410 --> 00:13:31,320
could eat sushi I think every single day

00:13:28,890 --> 00:13:33,670
and in Vienna if you want to eat sushi

00:13:31,320 --> 00:13:35,680
there are roughly two types of

00:13:33,670 --> 00:13:37,930
restaurants the first type of restaurant

00:13:35,680 --> 00:13:40,810
is your typical restaurant you come to

00:13:37,930 --> 00:13:43,930
the restaurant you take a seat then

00:13:40,810 --> 00:13:46,960
waiter or waitress approaches you you

00:13:43,930 --> 00:13:51,880
take an order you at a couple of minutes

00:13:46,960 --> 00:13:53,830
and your food arrives now what normally

00:13:51,880 --> 00:13:55,300
happens is that this sushi does not

00:13:53,830 --> 00:13:58,630
exist before you come to the restaurant

00:13:55,300 --> 00:14:02,800
so it was made hopefully fresh for you

00:13:58,630 --> 00:14:05,170
by the chef and these are so-called cold

00:14:02,800 --> 00:14:07,240
observables so they don't exist up front

00:14:05,170 --> 00:14:09,720
only when you subscribe to them only

00:14:07,240 --> 00:14:14,470
then they're made or prepared for you

00:14:09,720 --> 00:14:16,660
the hot observables would be so called

00:14:14,470 --> 00:14:18,970
conveyor belt sushi restaurant or

00:14:16,660 --> 00:14:23,560
running sushi restaurant these are the

00:14:18,970 --> 00:14:26,290
restaurants that have a track or belt

00:14:23,560 --> 00:14:28,090
where the food is going in circle and at

00:14:26,290 --> 00:14:29,980
some point of this track there are chefs

00:14:28,090 --> 00:14:31,990
making fresh sushi and putting another

00:14:29,980 --> 00:14:33,610
track and all you have to do you just

00:14:31,990 --> 00:14:36,940
come to this restaurant you take a seat

00:14:33,610 --> 00:14:38,500
and when food arrives to you you take it

00:14:36,940 --> 00:14:41,350
out and you eat it and then the next

00:14:38,500 --> 00:14:43,720
piece comes out again you eat it etc so

00:14:41,350 --> 00:14:45,520
difference is that this sushi was made

00:14:43,720 --> 00:14:48,820
even before you came to the restaurant

00:14:45,520 --> 00:14:51,070
and it the chefs will most likely keep

00:14:48,820 --> 00:14:52,600
making this sushi and all the other

00:14:51,070 --> 00:14:56,950
pieces of food once you leave the

00:14:52,600 --> 00:14:59,950
restaurant so this is for example taking

00:14:56,950 --> 00:15:02,500
a glass of water from the stream or from

00:14:59,950 --> 00:15:03,730
the tap so this water is coming whether

00:15:02,500 --> 00:15:06,730
you take it or not

00:15:03,730 --> 00:15:09,790
so you have to subscribe and you have to

00:15:06,730 --> 00:15:12,400
unsubscribe in development this would be

00:15:09,790 --> 00:15:14,530
for example click events or mouse moves

00:15:12,400 --> 00:15:19,030
the user will move Mouse whether you are

00:15:14,530 --> 00:15:22,540
listening to this event or not ok so I

00:15:19,030 --> 00:15:23,420
explained bit of HTTP calls and event

00:15:22,540 --> 00:15:25,990
handling

00:15:23,420 --> 00:15:29,870
and for some of you this might sound

00:15:25,990 --> 00:15:32,690
slightly like a promise in fact there

00:15:29,870 --> 00:15:34,430
are often cases where people are making

00:15:32,690 --> 00:15:36,140
HTTP calls and they are asking

00:15:34,430 --> 00:15:40,420
themselves should I use promises or

00:15:36,140 --> 00:15:45,290
observables and observables can be used

00:15:40,420 --> 00:15:47,360
instead of promises but the big

00:15:45,290 --> 00:15:51,650
difference is that they are like

00:15:47,360 --> 00:15:53,600
advanced version of promises so the one

00:15:51,650 --> 00:15:56,450
of the differences between promises and

00:15:53,600 --> 00:16:00,470
observables are that promises are not

00:15:56,450 --> 00:16:03,470
cancelable so once you make a call to

00:16:00,470 --> 00:16:05,270
the backend with a promise this call

00:16:03,470 --> 00:16:07,280
will come back whether you want it or

00:16:05,270 --> 00:16:09,830
not so you cannot cancel it once it's

00:16:07,280 --> 00:16:11,900
made there are now some changes where

00:16:09,830 --> 00:16:14,540
the promises will be cancelable but by

00:16:11,900 --> 00:16:16,640
definition promises are not cancelable

00:16:14,540 --> 00:16:18,140
observables are canceled both so if you

00:16:16,640 --> 00:16:20,600
imagine the situation in the restaurant

00:16:18,140 --> 00:16:23,030
that would mean that with a promise when

00:16:20,600 --> 00:16:24,410
you order sushi you have to eat it or

00:16:23,030 --> 00:16:26,330
you don't have to eat it but it will

00:16:24,410 --> 00:16:29,420
come nevertheless then you have to pay

00:16:26,330 --> 00:16:31,130
for it with observables you can order

00:16:29,420 --> 00:16:32,720
and then you can change your mind later

00:16:31,130 --> 00:16:35,840
and you can still cancel that

00:16:32,720 --> 00:16:38,210
subscription or change it the second

00:16:35,840 --> 00:16:41,330
thing is that promises are async by

00:16:38,210 --> 00:16:43,940
default and they guarantee that they are

00:16:41,330 --> 00:16:46,280
async so you can depend that the

00:16:43,940 --> 00:16:48,350
execution of the a synchronous callback

00:16:46,280 --> 00:16:50,090
will happen outside of the main context

00:16:48,350 --> 00:16:54,020
now with observables

00:16:50,090 --> 00:16:55,730
it depends depending on that what you

00:16:54,020 --> 00:16:58,520
are wrapping in observables so if you

00:16:55,730 --> 00:17:01,970
wrapping something static in observable

00:16:58,520 --> 00:17:05,240
the execution will happen synchronously

00:17:01,970 --> 00:17:07,400
so it will happen in the main context if

00:17:05,240 --> 00:17:10,760
you wrap something a synchronous like

00:17:07,400 --> 00:17:13,699
call to back-end it will be icing there

00:17:10,760 --> 00:17:16,550
are some parts in observables code

00:17:13,699 --> 00:17:19,190
schedulers which can change the

00:17:16,550 --> 00:17:20,900
synchronicity based on however you like

00:17:19,190 --> 00:17:24,100
but this is a bit more advanced stuff

00:17:20,900 --> 00:17:26,510
and one of the really good things that

00:17:24,100 --> 00:17:28,610
observables give you is they give you a

00:17:26,510 --> 00:17:31,610
lot of operators which we will see soon

00:17:28,610 --> 00:17:34,790
with which you can manipulate the data

00:17:31,610 --> 00:17:36,920
that's coming from from the observable

00:17:34,790 --> 00:17:40,520
to change it before

00:17:36,920 --> 00:17:45,740
pass it to your subscription now there

00:17:40,520 --> 00:17:47,330
was quite some theory around it but now

00:17:45,740 --> 00:17:50,750
let's see how this looks like in a code

00:17:47,330 --> 00:17:54,980
so I have my demo gods aligned hopefully

00:17:50,750 --> 00:17:57,950
everything works ok ok so we're gonna

00:17:54,980 --> 00:18:01,430
build a game as you can see on a screen

00:17:57,950 --> 00:18:04,730
this will be a Tetris game at the moment

00:18:01,430 --> 00:18:06,950
there's just simple view component it's

00:18:04,730 --> 00:18:12,320
written in typescript which might be a

00:18:06,950 --> 00:18:15,350
bit strange to you but typescript I

00:18:12,320 --> 00:18:16,820
personally prefer typescript over es6

00:18:15,350 --> 00:18:20,660
because it gives me a bit more

00:18:16,820 --> 00:18:24,140
intelligence and it allows me to code

00:18:20,660 --> 00:18:26,240
bit faster but it's just a preference so

00:18:24,140 --> 00:18:31,190
you can still do all this stuff in

00:18:26,240 --> 00:18:34,310
normal year 6 or es 5 even so as you can

00:18:31,190 --> 00:18:41,890
see we have a component can everyone see

00:18:34,310 --> 00:18:44,470
the code or should I enhance a bit well

00:18:41,890 --> 00:18:48,020
the lights I can't really fix

00:18:44,470 --> 00:18:52,580
unfortunately maybe we can kill one of

00:18:48,020 --> 00:18:56,570
these lights if possible so we have our

00:18:52,580 --> 00:19:00,050
mountain method or mount it life cycle

00:18:56,570 --> 00:19:03,650
hook where you can see I just have a

00:19:00,050 --> 00:19:06,520
reference to this main element which is

00:19:03,650 --> 00:19:10,310
actually canvas I'm setting some bit

00:19:06,520 --> 00:19:13,250
some size and then I'm passing the

00:19:10,310 --> 00:19:16,040
context of this canvas to the init game

00:19:13,250 --> 00:19:20,060
method where I'm just printing out the

00:19:16,040 --> 00:19:25,580
text I want to beat a trace now we will

00:19:20,060 --> 00:19:28,640
remove this and instead we're gonna put

00:19:25,580 --> 00:19:30,350
some code here now I did some

00:19:28,640 --> 00:19:35,270
preparation up front otherwise this

00:19:30,350 --> 00:19:37,610
would take a bit longer so I can show

00:19:35,270 --> 00:19:41,990
you just quickly what's there we have

00:19:37,610 --> 00:19:43,970
some constants such as shape colors so

00:19:41,990 --> 00:19:45,320
we want every block from that wrist to

00:19:43,970 --> 00:19:48,790
be in different color so that we can

00:19:45,320 --> 00:19:50,600
nicely see what's going on we have our

00:19:48,790 --> 00:19:52,940
keyboard keys which we are

00:19:50,600 --> 00:19:56,059
interested in like arrow left right down

00:19:52,940 --> 00:19:58,190
in space for rotation and I have the

00:19:56,059 --> 00:20:02,539
definitions for the board width height

00:19:58,190 --> 00:20:08,049
and cell size the next thing I have here

00:20:02,539 --> 00:20:10,640
is game logic again this is quite simple

00:20:08,049 --> 00:20:13,070
method to check if it's game over to

00:20:10,640 --> 00:20:16,160
move block to rotate block to remember

00:20:13,070 --> 00:20:19,100
the full rows then there are some

00:20:16,160 --> 00:20:23,720
rendering methods for rendering the

00:20:19,100 --> 00:20:26,470
background board the block and then we

00:20:23,720 --> 00:20:29,059
have our shapes definition so each

00:20:26,470 --> 00:20:32,179
possible shape is described with this

00:20:29,059 --> 00:20:36,710
matrix we see the interface for the

00:20:32,179 --> 00:20:38,600
block every block has XY position it has

00:20:36,710 --> 00:20:41,809
a shape which is one of these shapes

00:20:38,600 --> 00:20:44,690
underneath and it has colors to know in

00:20:41,809 --> 00:20:49,070
which color we should print it out and

00:20:44,690 --> 00:20:52,669
finally we have our main board for those

00:20:49,070 --> 00:20:55,970
of you who have used buicks or any other

00:20:52,669 --> 00:20:59,390
state management this might be familiar

00:20:55,970 --> 00:21:02,179
so we have a state it's quite simple

00:20:59,390 --> 00:21:05,450
state so our state consists of the board

00:21:02,179 --> 00:21:08,960
which is what you see behind and then

00:21:05,450 --> 00:21:11,659
the block which is not yet merged with a

00:21:08,960 --> 00:21:14,780
with the board so the block that's still

00:21:11,659 --> 00:21:17,000
moving and then there are a couple of

00:21:14,780 --> 00:21:21,760
methods here like choosing the random

00:21:17,000 --> 00:21:25,780
shape random color etc and then we have

00:21:21,760 --> 00:21:29,900
short reducer or mutations if you wish

00:21:25,780 --> 00:21:33,980
which just generate the scene on init on

00:21:29,900 --> 00:21:37,490
space rotate the block on left right or

00:21:33,980 --> 00:21:43,480
down are just moving blocks that's it so

00:21:37,490 --> 00:21:48,559
it's quite simple now let's see how

00:21:43,480 --> 00:21:52,100
we're gonna write this code so one thing

00:21:48,559 --> 00:21:55,309
that game has to have is be able to use

00:21:52,100 --> 00:22:00,640
keys to navigate right so we're going to

00:21:55,309 --> 00:22:00,640
use from event which is

00:22:02,899 --> 00:22:11,820
yeah from event is a wrapper around Dom

00:22:08,039 --> 00:22:20,149
event so what we are doing here is we

00:22:11,820 --> 00:22:20,149
are saying that for every just described

00:22:27,039 --> 00:22:33,559
so what we are saying that for every

00:22:30,049 --> 00:22:36,769
keydown event happening anywhere on the

00:22:33,559 --> 00:22:40,249
document we are subscribing to it and

00:22:36,769 --> 00:22:44,029
we're gonna console.log it so now if I

00:22:40,249 --> 00:22:51,679
go to my browser here you just see if

00:22:44,029 --> 00:22:55,850
this thing is running No maybe I should

00:22:51,679 --> 00:22:58,090
have done this first this is some stale

00:22:55,850 --> 00:22:58,090
data

00:23:13,970 --> 00:23:16,970
okay

00:23:20,139 --> 00:23:25,570
there are some leftovers here

00:23:30,040 --> 00:23:34,230
okay so I should be fine

00:23:37,290 --> 00:23:45,610
we restart and now if I'm pressing some

00:23:42,730 --> 00:23:49,060
Keys you might see that stuff is coming

00:23:45,610 --> 00:23:51,460
out here so we see that every keyboard

00:23:49,060 --> 00:23:56,470
event is printing out now we don't

00:23:51,460 --> 00:24:00,790
generally care about this big keyboard

00:23:56,470 --> 00:24:05,680
event all we care about is just a code

00:24:00,790 --> 00:24:08,050
of the key event so what we can do is as

00:24:05,680 --> 00:24:10,000
I mentioned before we for the

00:24:08,050 --> 00:24:11,950
observables there are a lot of operators

00:24:10,000 --> 00:24:14,080
which we can apply and we apply them

00:24:11,950 --> 00:24:18,100
through the pipe so we can type in the

00:24:14,080 --> 00:24:19,870
operators before we subscribe to it so

00:24:18,100 --> 00:24:22,540
first one we're going to use is a map

00:24:19,870 --> 00:24:27,670
this is the same thing as a standard

00:24:22,540 --> 00:24:34,020
array map so we take our key we're gonna

00:24:27,670 --> 00:24:41,350
say that this is key is a keyboard

00:24:34,020 --> 00:24:49,870
keyboard event and then we're gonna map

00:24:41,350 --> 00:24:52,890
this event to event dot code now if I

00:24:49,870 --> 00:24:52,890
save this

00:24:57,900 --> 00:25:02,790
now you can see that we no longer have

00:25:00,720 --> 00:25:07,380
the city the full event we have just the

00:25:02,790 --> 00:25:09,660
keycode now I showed you earlier that we

00:25:07,380 --> 00:25:12,930
are interested only in four codes four

00:25:09,660 --> 00:25:15,900
keys that's left right down and space

00:25:12,930 --> 00:25:17,640
for rotation so we would like to somehow

00:25:15,900 --> 00:25:20,730
get rid of this we are not interested in

00:25:17,640 --> 00:25:26,850
all of them so what are we going to do

00:25:20,730 --> 00:25:35,670
yes I have this Keys object and I'm

00:25:26,850 --> 00:25:42,420
gonna say that I will map every event

00:25:35,670 --> 00:25:47,760
code into my key object and now if I

00:25:42,420 --> 00:25:49,890
restart now you can see that it's

00:25:47,760 --> 00:25:52,710
printing undefined for some of them

00:25:49,890 --> 00:25:54,090
which is fine because it only prints for

00:25:52,710 --> 00:25:55,770
the ones we are interested in but we

00:25:54,090 --> 00:25:59,910
don't want this undefined that's kinda

00:25:55,770 --> 00:26:06,800
annoying so we can filter out the stuff

00:25:59,910 --> 00:26:13,500
we don't need so you're gonna say return

00:26:06,800 --> 00:26:19,230
only the ones that have some value so

00:26:13,500 --> 00:26:20,790
again if I restart and now I'm pressing

00:26:19,230 --> 00:26:25,020
some keys but you don't see anything

00:26:20,790 --> 00:26:29,179
unless I press one of the keys that were

00:26:25,020 --> 00:26:31,950
interested in now that's the first part

00:26:29,179 --> 00:26:35,280
listening to the keys now the second

00:26:31,950 --> 00:26:38,790
part that every tetris game has is that

00:26:35,280 --> 00:26:41,040
it has some flow so the whether we are

00:26:38,790 --> 00:26:42,990
using our keys or not whether we are

00:26:41,040 --> 00:26:46,410
playing the game or not the block will

00:26:42,990 --> 00:26:48,660
fall down so what we want to do we want

00:26:46,410 --> 00:26:51,750
to have some game pace so we're going to

00:26:48,660 --> 00:26:55,410
create observable around interval I'm

00:26:51,750 --> 00:26:57,900
gonna pass this game speed that I have

00:26:55,410 --> 00:27:04,670
prepared which I think it's 500

00:26:57,900 --> 00:27:04,670
milliseconds and now if we subscribe

00:27:05,490 --> 00:27:14,899
and we print it out again let's see what

00:27:12,299 --> 00:27:14,899
this gives us

00:27:17,470 --> 00:27:23,559
and we can see some numbers printing out

00:27:19,769 --> 00:27:26,289
so every half a second

00:27:23,559 --> 00:27:27,460
there is one increased number coming out

00:27:26,289 --> 00:27:30,129
now

00:27:27,460 --> 00:27:33,220
we don't want numbers what we care about

00:27:30,129 --> 00:27:36,460
is the key downs because what happens

00:27:33,220 --> 00:27:39,039
every half a second the block will fall

00:27:36,460 --> 00:27:42,309
down one line this is the same thing as

00:27:39,039 --> 00:27:46,419
someone just pressing down constantly so

00:27:42,309 --> 00:27:52,710
we're going to map this again with our

00:27:46,419 --> 00:28:00,090
pipe we will map whatever comes through

00:27:52,710 --> 00:28:00,090
two keys dot arrow down

00:28:04,050 --> 00:28:09,840
and now you can see that instead of

00:28:07,500 --> 00:28:13,080
numbers its arrow down and it's

00:28:09,840 --> 00:28:14,760
increasing now we have two subscriptions

00:28:13,080 --> 00:28:19,020
that are doing roughly the same thing

00:28:14,760 --> 00:28:22,590
they are printing our keys so we want to

00:28:19,020 --> 00:28:26,640
combine this as we mentioned every

00:28:22,590 --> 00:28:28,890
observe observable consists of two parts

00:28:26,640 --> 00:28:31,620
the thing that we observe and our

00:28:28,890 --> 00:28:34,290
subscriber that's observing now there's

00:28:31,620 --> 00:28:36,510
one more structure in the observable

00:28:34,290 --> 00:28:39,090
world which is combination of those two

00:28:36,510 --> 00:28:42,810
it's code subject so subject is both

00:28:39,090 --> 00:28:44,490
observer and observable so it can listen

00:28:42,810 --> 00:28:46,560
to events from somewhere else

00:28:44,490 --> 00:28:55,190
but it also emits the events that

00:28:46,560 --> 00:29:02,030
receives so we're going to create Const

00:28:55,190 --> 00:29:05,030
let's go it action we're gonna say new

00:29:02,030 --> 00:29:05,030
subject

00:29:05,090 --> 00:29:12,840
we don't know still what we gonna pass

00:29:07,560 --> 00:29:15,060
so let's say any and now instead of

00:29:12,840 --> 00:29:20,520
subscribing to Casa walk we're gonna

00:29:15,060 --> 00:29:27,150
test here action and the same thing

00:29:20,520 --> 00:29:34,970
we're gonna do here okay and now we can

00:29:27,150 --> 00:29:34,970
say action subscribe

00:29:38,440 --> 00:29:50,110
so walk okay now what we did now is we

00:29:45,900 --> 00:29:56,490
diverted the key the key press events

00:29:50,110 --> 00:30:01,030
and game speed events to the same action

00:29:56,490 --> 00:30:04,480
so when you look at the result it's

00:30:01,030 --> 00:30:12,490
actually the same but what we can do now

00:30:04,480 --> 00:30:15,220
is we can use our next operator which is

00:30:12,490 --> 00:30:19,090
called scan operator and we're going to

00:30:15,220 --> 00:30:26,170
pass two things our scene reducer

00:30:19,090 --> 00:30:32,220
function and we will generate scene okay

00:30:26,170 --> 00:30:38,320
let me just import all of these okay so

00:30:32,220 --> 00:30:40,660
scan operator works similarly like

00:30:38,320 --> 00:30:43,830
reduced function of the array so what

00:30:40,660 --> 00:30:46,780
the reduce function does is it has some

00:30:43,830 --> 00:30:51,310
initial value which in our case is this

00:30:46,780 --> 00:30:54,550
generate scene and based on a collection

00:30:51,310 --> 00:30:56,140
it will do constant recalculation and at

00:30:54,550 --> 00:30:59,500
the end it will give you the end result

00:30:56,140 --> 00:31:02,230
so hopefully everyone knows the reduce

00:30:59,500 --> 00:31:04,780
function in the array so you have two

00:31:02,230 --> 00:31:08,400
things one is the current value and then

00:31:04,780 --> 00:31:10,810
the accumulator and in every step you

00:31:08,400 --> 00:31:11,320
accumulate the new value you calculate

00:31:10,810 --> 00:31:15,730
the new value

00:31:11,320 --> 00:31:17,730
now this can works similarly but with

00:31:15,730 --> 00:31:20,500
one slight difference and that is that

00:31:17,730 --> 00:31:23,080
reducer a reduce only gives you result

00:31:20,500 --> 00:31:25,450
at the end while scan gives you a result

00:31:23,080 --> 00:31:27,790
along the way so every time we

00:31:25,450 --> 00:31:29,950
recalculate the new value the scan will

00:31:27,790 --> 00:31:31,540
spit out the current value so it doesn't

00:31:29,950 --> 00:31:33,700
wait until the end it will give you

00:31:31,540 --> 00:31:37,480
constantly values so what this does for

00:31:33,700 --> 00:31:38,560
us is that every time the key is

00:31:37,480 --> 00:31:41,830
triggered

00:31:38,560 --> 00:31:46,629
we will recalculate the scene and we're

00:31:41,830 --> 00:31:53,289
going to print it out so now

00:31:46,629 --> 00:31:57,440
refresh this you can see that instead of

00:31:53,289 --> 00:32:01,659
keys we have our board and block printed

00:31:57,440 --> 00:32:08,389
out now this doesn't give us a lot so

00:32:01,659 --> 00:32:14,749
let's bring this out so we say scene and

00:32:08,389 --> 00:32:22,149
we're gonna say render see we need to

00:32:14,749 --> 00:32:22,149
pass our context and our scene

00:32:26,570 --> 00:32:43,789
I save it I can get rid of this now and

00:32:38,179 --> 00:32:50,320
now we almost have a full game so you

00:32:43,789 --> 00:32:53,149
can use this use the keys see how there

00:32:50,320 --> 00:32:58,370
and now there is one thing still missing

00:32:53,149 --> 00:33:01,070
so we showed now when game changes how

00:32:58,370 --> 00:33:04,360
do we generate new scene but we still

00:33:01,070 --> 00:33:07,820
haven't told it how to handle game over

00:33:04,360 --> 00:33:11,299
so what we want is we don't want to

00:33:07,820 --> 00:33:20,570
calculate the new scene endlessly we

00:33:11,299 --> 00:33:29,809
want to do it only until our scene is

00:33:20,570 --> 00:33:33,230
not in game over state so this function

00:33:29,809 --> 00:33:36,440
that I have is game over simply checks

00:33:33,230 --> 00:33:40,669
based on a scene if it's game over sin

00:33:36,440 --> 00:33:42,710
if the block cannot be moved anymore and

00:33:40,669 --> 00:33:47,059
our take while operator is simply

00:33:42,710 --> 00:33:52,360
telling us take this observables or have

00:33:47,059 --> 00:33:59,570
the subscription as long as this is true

00:33:52,360 --> 00:34:03,649
now if we restart this we're going to

00:33:59,570 --> 00:34:07,100
see that although the our observable has

00:34:03,649 --> 00:34:09,050
finished we can't really tell because we

00:34:07,100 --> 00:34:11,270
didn't change anything we're still just

00:34:09,050 --> 00:34:13,240
rendering the scene so we don't know

00:34:11,270 --> 00:34:18,319
that rendering of the scene has stopped

00:34:13,240 --> 00:34:24,879
so now we're going to use the things

00:34:18,319 --> 00:34:24,879
from our iterator world

00:34:26,790 --> 00:34:33,400
now if you remember the story about

00:34:29,620 --> 00:34:36,760
pizza that was the that our iterator

00:34:33,400 --> 00:34:42,310
pattern was giving us possibility to get

00:34:36,760 --> 00:34:45,520
the next item but it was also allowing

00:34:42,310 --> 00:34:49,780
us to do something when there are no

00:34:45,520 --> 00:34:53,530
more items left so we're gonna say when

00:34:49,780 --> 00:34:55,120
our observable is complete we're not

00:34:53,530 --> 00:34:58,530
going to run their scene we're going to

00:34:55,120 --> 00:34:58,530
render game over

00:35:10,120 --> 00:35:13,380
now if we start

00:35:15,250 --> 00:35:18,780
let's try to end it again

00:35:21,020 --> 00:35:29,480
that's it now one thing which might not

00:35:25,430 --> 00:35:32,840
be clear immediately is that observable

00:35:29,480 --> 00:35:36,110
still work in the principles of even

00:35:32,840 --> 00:35:39,320
subscription and as you probably know

00:35:36,110 --> 00:35:42,170
when you subscribe to some events you

00:35:39,320 --> 00:35:44,930
might potentially end up with a bunch of

00:35:42,170 --> 00:35:47,090
subscriptions or listeners lying around

00:35:44,930 --> 00:35:50,810
filling up your memory so what you want

00:35:47,090 --> 00:35:52,460
to do is when the game is over or when

00:35:50,810 --> 00:35:54,200
you close the component or leave the

00:35:52,460 --> 00:35:55,880
page you want to get rid of this

00:35:54,200 --> 00:35:57,619
subscription you don't want this to be

00:35:55,880 --> 00:35:59,510
hanging around in your memory and still

00:35:57,619 --> 00:36:04,460
listening to the key press events and

00:35:59,510 --> 00:36:08,990
this interval timer still being still

00:36:04,460 --> 00:36:15,610
running so what we can use now we can

00:36:08,990 --> 00:36:15,610
use our hook up before destroy

00:36:23,060 --> 00:36:30,590
and we're going to create another

00:36:25,720 --> 00:36:38,390
subject which we're gonna call destroy

00:36:30,590 --> 00:36:45,170
subject and we'll see that this is type

00:36:38,390 --> 00:36:48,200
void it it doesn't return anything and

00:36:45,170 --> 00:36:56,960
on destroy we're gonna say it did this

00:36:48,200 --> 00:37:01,510
destroy will fire single item and then

00:36:56,960 --> 00:37:05,750
we're going to complete this stream so

00:37:01,510 --> 00:37:09,170
we are just firing one item and we are

00:37:05,750 --> 00:37:12,980
closing it and now what we want to do is

00:37:09,170 --> 00:37:15,200
we want to say this is fine for a take

00:37:12,980 --> 00:37:17,770
well until game is over but if user

00:37:15,200 --> 00:37:24,290
leaves the page before the game is over

00:37:17,770 --> 00:37:29,270
we want to say take until and we're

00:37:24,290 --> 00:37:31,220
going to pass in our destroy object so

00:37:29,270 --> 00:37:31,790
as long as you are here everything will

00:37:31,220 --> 00:37:36,710
be fine

00:37:31,790 --> 00:37:40,010
but as soon as user leaves the before

00:37:36,710 --> 00:37:42,860
destroy hook event happens which will

00:37:40,010 --> 00:37:44,870
then trigger this destroy subject which

00:37:42,860 --> 00:37:48,890
will fire single event and this single

00:37:44,870 --> 00:37:50,330
event will close our action and with

00:37:48,890 --> 00:37:55,910
action it will close the two

00:37:50,330 --> 00:37:59,030
subscription about so let's all from the

00:37:55,910 --> 00:38:04,670
coding example now let's go back to the

00:37:59,030 --> 00:38:07,250
presentation so hopefully by now you got

00:38:04,670 --> 00:38:09,710
enough information and enough motivation

00:38:07,250 --> 00:38:12,320
that you start experimenting yourself

00:38:09,710 --> 00:38:16,100
with rxjs and using it in your own

00:38:12,320 --> 00:38:19,820
solutions you can see here a link to the

00:38:16,100 --> 00:38:23,180
original repo where you can see this

00:38:19,820 --> 00:38:25,070
whole code if you go there next to it in

00:38:23,180 --> 00:38:27,410
one of my repos you can see the same

00:38:25,070 --> 00:38:32,660
solution with view X so you can compare

00:38:27,410 --> 00:38:34,610
you our X and dou X solution based on

00:38:32,660 --> 00:38:36,410
the lines of code it's more or less the

00:38:34,610 --> 00:38:40,130
same but you will

00:38:36,410 --> 00:38:43,130
clearly see that the RX solution is more

00:38:40,130 --> 00:38:46,070
clear and gives you nice nice flow of

00:38:43,130 --> 00:38:48,260
the application while view X at some

00:38:46,070 --> 00:38:50,330
point becomes over complicated with

00:38:48,260 --> 00:38:54,710
subscription to events and handling all

00:38:50,330 --> 00:38:57,830
the events listeners and the touching

00:38:54,710 --> 00:39:00,620
given listeners additional thing that

00:38:57,830 --> 00:39:03,590
exists in the view world is a solution

00:39:00,620 --> 00:39:06,080
called view rx which was built by Evan

00:39:03,590 --> 00:39:10,850
which gives you a possibility to have

00:39:06,080 --> 00:39:13,130
the streams as a properties so instead

00:39:10,850 --> 00:39:16,280
of having static props which you change

00:39:13,130 --> 00:39:18,620
you can have your props as a streams so

00:39:16,280 --> 00:39:20,090
your entire component at just the some

00:39:18,620 --> 00:39:22,430
logic in the component but actually

00:39:20,090 --> 00:39:27,740
entire component can be reactive and

00:39:22,430 --> 00:39:30,440
this is really really powerful so thank

00:39:27,740 --> 00:39:34,960
you for listening and hope to see your

00:39:30,440 --> 00:39:34,960

YouTube URL: https://www.youtube.com/watch?v=K1rckjbSN08


