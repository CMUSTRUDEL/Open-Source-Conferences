Title: Empathy-Driven Development - Marcy Sutton - JSConf EU 2018
Publication date: 2018-06-21
Playlist: JSConf EU 2018
Description: 
	Accessibility is often forgotten by JavaScript developers, even in 2018; as a result, people with disabilities get left behind. Fortunately, there are techniques and tools that can help kickstart the process. In this talk, youâ€™ll learn hands-on skills for developing inclusively with JavaScript and hard-coding accessibility into your workflow.

OMG JSConf EU is coming back in 2019 https://2019.jsconf.eu/
Captions: 
	00:00:09,500 --> 00:00:11,360
Hello, JSConf.

00:00:11,360 --> 00:00:12,940
I'm super excited to be back here.

00:00:12,940 --> 00:00:16,750
It's been a few years since I've been to JSConf EU.

00:00:16,750 --> 00:00:22,539
I wish I could say that accessibility has gotten better in that time, but we still need

00:00:22,539 --> 00:00:27,380
to be reminded that people with disabilities are left behind quite often.

00:00:27,380 --> 00:00:31,589
To tell you about accessibility today, I'm going to do something a little bit different.

00:00:31,589 --> 00:00:33,000
I don't have any slides.

00:00:33,000 --> 00:00:38,230
Instead, we're going to take a live debugging tour of a React application that I've built

00:00:38,230 --> 00:00:44,860
with a few components, the goal of which is to teach you how to debug components for accessibility

00:00:44,860 --> 00:00:49,040
because you're all capable of doing it, you just need a little bit of knowledge and a

00:00:49,040 --> 00:00:51,510
little bit of empathy for your user.

00:00:51,510 --> 00:00:56,500
You can find the repo a my GitHub.

00:00:56,500 --> 00:01:01,980
With that, we're going to dive right into code.

00:01:01,980 --> 00:01:08,130
If I go to the browser, I can show you the basing component library I've built.

00:01:08,130 --> 00:01:12,979
It's got three components - a login form, a card flip, and a menu.

00:01:12,979 --> 00:01:16,450
It's worth reiterating we can't cover all of it in 25 minutes.

00:01:16,450 --> 00:01:23,390
I will show you keyboard mechanics, screen reader support, and things that are chronically

00:01:23,390 --> 00:01:24,890
forgotten.

00:01:24,890 --> 00:01:26,770
It really ends up impacting users.

00:01:26,770 --> 00:01:30,149
So, to get started, let's look at our login form.

00:01:30,149 --> 00:01:31,869
It has three fields in it.

00:01:31,869 --> 00:01:33,770
Those fields have placeholders.

00:01:33,770 --> 00:01:39,229
Unfortunately, a placeholder is not enough for a screenreader user to use a web page,

00:01:39,229 --> 00:01:43,829
and I wish we could move on from this, but I see this so often.

00:01:43,829 --> 00:01:46,270
Let's check out how we can fix this.

00:01:46,270 --> 00:01:51,030
If I were debugging this on a real page, I would open the developer tools.

00:01:51,030 --> 00:01:56,999
So, if I open up my DevTools in Chrome, I can go and inspect this HTML and see what's

00:01:56,999 --> 00:01:57,999
going on.

00:01:57,999 --> 00:02:02,350
A quicker way to do this is to use a tool like the X Chrome extension.

00:02:02,350 --> 00:02:03,520
There are other tools.

00:02:03,520 --> 00:02:04,520
I like this one.

00:02:04,520 --> 00:02:05,520
I happy to work on it.

00:02:05,520 --> 00:02:08,369
It is built with React and JavaScript.

00:02:08,369 --> 00:02:13,030
I can analyse any web page and see what's going on with this, and, sure enough, those

00:02:13,030 --> 00:02:17,680
placeholder attributes are not enough for a screenreader user in all browsers.

00:02:17,680 --> 00:02:19,569
That's something that we could fix.

00:02:19,569 --> 00:02:26,100
There is also an error here about content not being contained in a landmark region.

00:02:26,100 --> 00:02:31,760
Our main content is just sitting there in the DOM, and it's not wrapped in a landmark.

00:02:31,760 --> 00:02:36,099
So we're not taking advantage of HTML to be screenreader users.

00:02:36,099 --> 00:02:42,200
Let's go back over to my text editor, poke around, and fix some of this stuff.

00:02:42,200 --> 00:02:48,580
In my app.js file, this is where everything comes together, my components.

00:02:48,580 --> 00:02:54,030
I can see that there is a header element here, so that acts and one landmark.

00:02:54,030 --> 00:02:58,719
If we scroll down, there is a main detective that has a class name.

00:02:58,719 --> 00:02:59,719
Guess what?

00:02:59,719 --> 00:03:00,980
That's not very semantic.

00:03:00,980 --> 00:03:02,360
Let's fix that.

00:03:02,360 --> 00:03:07,939
I'm going to change the divs to a main element which has an implicit role of main, but if

00:03:07,939 --> 00:03:12,950
you're supporting Internet Explorer 11, which a lot of people with disabilities rely on,

00:03:12,950 --> 00:03:14,790
we need to bolt on a role.

00:03:14,790 --> 00:03:16,790
I'm going to bolt on main.

00:03:16,790 --> 00:03:18,329
It is redundant.

00:03:18,329 --> 00:03:24,010
If you're supporting IE11 or below, you need to add that to expose the semantics.

00:03:24,010 --> 00:03:28,840
Similarly, on the header element, we can add a roll of banner and will expose the fact

00:03:28,840 --> 00:03:33,959
that this is a global header, not to be confused with a header inside an article tag.

00:03:33,959 --> 00:03:39,430
That way, assistive technology, they can use these landmarks as navigation points in our

00:03:39,430 --> 00:03:46,049
application, of like they might navigate by headings, you can also navigate by landmarks.

00:03:46,049 --> 00:03:49,890
We uncovered those few problems in the X Chrome extension.

00:03:49,890 --> 00:03:54,670
I am also going to show you the login form.

00:03:54,670 --> 00:04:01,159
The login form demo in JavaScript, this example uses an array with the three field names.

00:04:01,159 --> 00:04:09,349
They get past the login form and we can create a dynamic login form based on this array.

00:04:09,349 --> 00:04:17,289
If I look at the login form component, it takes that array of fields, maps them to a

00:04:17,289 --> 00:04:18,340
set of inputs.

00:04:18,340 --> 00:04:20,919
Each input we iterate over its name.

00:04:20,919 --> 00:04:24,190
This is where those labels are missing.

00:04:24,190 --> 00:04:31,970
So I'm going to add a label.

00:04:31,970 --> 00:04:34,970
We've got something redundant here with the placeholder.

00:04:34,970 --> 00:04:39,080
This is a design decision that you might need to make with your design team: do you have

00:04:39,080 --> 00:04:43,210
a visible label, or do you use something like area label?

00:04:43,210 --> 00:04:46,680
I'm going to opt for the visible label.

00:04:46,680 --> 00:04:50,970
I don't know about you, but when I type in a form field that only has a placeholder and

00:04:50,970 --> 00:04:56,169
I forget what I'm typing in, and I go back out and back, I would advocate for the visible

00:04:56,169 --> 00:04:57,419
label.

00:04:57,419 --> 00:05:01,470
If it was something like a telephone number, and it had a specific pattern, then that would

00:05:01,470 --> 00:05:03,229
be a good place for a placeholder.

00:05:03,229 --> 00:05:09,990
Additionally, we can use HTML better here by adding a field set element around our form

00:05:09,990 --> 00:05:10,990
fields.

00:05:10,990 --> 00:05:17,419
I'm going to wrap in in a field set, and then this H2 heading I will wrap in a legend tag.

00:05:17,419 --> 00:05:22,610
Leveraging HTML's capabilities to make a more semantic and accessible form, no matter how

00:05:22,610 --> 00:05:28,849
you're delivering your HTML, this happens to be in JSX using React, so, to test this

00:05:28,849 --> 00:05:34,360
in the spirit of test-driven development, I'm going to apply Selenium web driver.

00:05:34,360 --> 00:05:41,740
I have a script in my package JSON file called integration, so I'm going to run mpm run integration.

00:05:41,740 --> 00:05:46,539
It's going to use mocha.

00:05:46,539 --> 00:05:50,160
It has found that there are no violations in this.

00:05:50,160 --> 00:06:00,949
If we look at this test, no pressure doing is live!

00:06:00,949 --> 00:06:06,509
Login, this is the fun part, right, watching me type!

00:06:06,509 --> 00:06:08,100
So I have a test here.

00:06:08,100 --> 00:06:15,680
It's actually using the just library the same extension we were using in the browser extension,

00:06:15,680 --> 00:06:22,319
and we can leverage the accessibility API so we don't have to know the nitty-gritty

00:06:22,319 --> 00:06:28,980
details of accessible names, and colour contrasts, and a lot of common accessibility problems.

00:06:28,980 --> 00:06:33,830
So I'm using Selenium here because that's a lot like what a real user can experience.

00:06:33,830 --> 00:06:34,890
I can fire up a browser.

00:06:34,890 --> 00:06:37,389
In this case, I was using Chrome.

00:06:37,389 --> 00:06:42,830
It hits that localhost URL for the login form, and then I have a single test in here.

00:06:42,830 --> 00:06:45,180
It uses X build er.

00:06:45,180 --> 00:06:51,990
That will return to me an object with accessibility violations that I can use to assert accessibility

00:06:51,990 --> 00:06:53,139
problems.

00:06:53,139 --> 00:06:58,850
It's worth pointing out this will only catch the low-hanging fruit, so those basics we

00:06:58,850 --> 00:06:59,850
forget.

00:06:59,850 --> 00:07:05,449
It is nice to have a tool pointing out you've forgotten it and you can move on to use human

00:07:05,449 --> 00:07:10,419
power for more complex problems.

00:07:10,419 --> 00:07:13,319
We fixed our first few problems and our login form.

00:07:13,319 --> 00:07:16,879
Let's go back to the browser and look at our next component.

00:07:16,879 --> 00:07:20,409
I guess one thing to point out about this login form, when I added the field set, it

00:07:20,409 --> 00:07:25,070
did add a border around it.

00:07:25,070 --> 00:07:29,819
You can style it however you want, but under the hood, we've added great semantics to this

00:07:29,819 --> 00:07:30,819
form.

00:07:30,819 --> 00:07:33,710
So, on to our next component.

00:07:33,710 --> 00:07:34,710
The card flip.

00:07:34,710 --> 00:07:39,729
Now, I'm going - I'm not going to name where this came from, but it came from a real website

00:07:39,729 --> 00:07:42,639
out of respect for the innocent!

00:07:42,639 --> 00:07:44,379
It's a little profile.

00:07:44,379 --> 00:07:51,930
In this case, I'm using a picture of my dog, Mr Ranier McChetterton, but, when I hover

00:07:51,930 --> 00:07:57,760
over this, it reveals back side on the card flip.

00:07:57,760 --> 00:08:03,689
If I'm using a keyboard only, if I tab through this web page, I don't ever reach the card

00:08:03,689 --> 00:08:06,900
flip because it just works with the mouse.

00:08:06,900 --> 00:08:15,240
So, for a keyboard-only user, someone using a screenreader, by the end of the workweek

00:08:15,240 --> 00:08:24,040
when my programmer elbow problem flares up, this is super useful.

00:08:24,040 --> 00:08:26,530
We need to be able to focus and flip it back and forth.

00:08:26,530 --> 00:08:32,800
I'm going to make a design decision here to make it work on click rather than hover.

00:08:32,800 --> 00:08:38,560
I can tell you from experience that the reality of maintaining hover animations and keyboard

00:08:38,560 --> 00:08:44,200
support, you don't want to make this move on keyboard focus, so that one-to-one interaction

00:08:44,200 --> 00:08:45,280
isn't the same any more.

00:08:45,280 --> 00:08:50,880
I'm going to change it to work a little bit differently.

00:08:50,880 --> 00:08:54,830
Just to give you a little more info before we go and make our changes to this, we can

00:08:54,830 --> 00:08:58,670
go inspect what this markup under the hood is looking like.

00:08:58,670 --> 00:09:00,920
It is a series of detectives.

00:09:00,920 --> 00:09:04,070
It does -- it is a series of divs.

00:09:04,070 --> 00:09:05,920
I've got some content.

00:09:05,920 --> 00:09:12,260
The back side of this card, we want to make it revealed when we interact it for everybody,

00:09:12,260 --> 00:09:13,930
not just for mouse users.

00:09:13,930 --> 00:09:19,180
With that, let's go back to our card flip.

00:09:19,180 --> 00:09:24,760
The card flip demo is where we instantiate the component.

00:09:24,760 --> 00:09:29,720
It may be useful, they all have this card flip interaction.

00:09:29,720 --> 00:09:32,089
Isle passing it some data.

00:09:32,089 --> 00:09:35,400
It instantiates this card flip component.

00:09:35,400 --> 00:09:37,510
It needs to manage state.

00:09:37,510 --> 00:09:43,570
Is it active or not in we need to add markup to this to reach it.

00:09:43,570 --> 00:09:48,710
It's sad how I find user interface components who have completely forgotten the keyboard.

00:09:48,710 --> 00:09:57,790
We are going to fix this right now.

00:09:57,790 --> 00:10:09,230
So, our card flip, it is in a slightly better state.

00:10:09,230 --> 00:10:13,840
So, I'm going to give you a little tour of what I fixed here.

00:10:13,840 --> 00:10:20,260
Our card flip component, if we scroll down and look at this markup, now, instead of just

00:10:20,260 --> 00:10:23,810
a series of divs that we hover on, we actually have a button.

00:10:23,810 --> 00:10:26,370
The button is focusable by adult.

00:10:26,370 --> 00:10:29,510
The text inside it is the team member's name, and a subtitle.

00:10:29,510 --> 00:10:33,880
It is a short amount of title so okay for a button name.

00:10:33,880 --> 00:10:37,240
I'm working on the click event for the button which works for everybody.

00:10:37,240 --> 00:10:40,110
You can use it from the mouse, you can use it from the keyboard.

00:10:40,110 --> 00:10:41,990
This is way more accessible.

00:10:41,990 --> 00:10:46,089
So that button is then going to trigger the card flip, and that is going expose the back

00:10:46,089 --> 00:10:49,750
side of this card content inside of a dialogue element.

00:10:49,750 --> 00:10:52,250
I'm using a role of dialogue.

00:10:52,250 --> 00:10:53,970
It is similar to our landmarks earlier.

00:10:53,970 --> 00:10:58,352
If you're useful the landmark element, you need to bolt on the role of dialogue in order

00:10:58,352 --> 00:11:01,630
to support its semantics in older browsers.

00:11:01,630 --> 00:11:02,830
This is a good start.

00:11:02,830 --> 00:11:07,709
Now we need to look at how we are going to handle this interaction.

00:11:07,709 --> 00:11:12,360
So, when I land on that button, I'm going to fire that click event, and it's in React

00:11:12,360 --> 00:11:14,240
style, I'm going to change the state.

00:11:14,240 --> 00:11:16,370
That's why I'm going to flip between the front and back.

00:11:16,370 --> 00:11:20,550
There is something you should know about this type of interaction is that we need to handle

00:11:20,550 --> 00:11:24,420
the user's focus so they're not getting left behind in the background layer.

00:11:24,420 --> 00:11:27,300
We will send focus into it.

00:11:27,300 --> 00:11:31,820
In React, the great tool for that is the ref API.

00:11:31,820 --> 00:11:38,899
They've added a better handle for it, so, with each element you're going to send focus

00:11:38,899 --> 00:11:44,300
to, you can create a ref, it gives you a handle or a hook to add focus management.

00:11:44,300 --> 00:11:47,970
So, we have one for the toggle, which is where it starts.

00:11:47,970 --> 00:11:52,220
And then we have a close button now, because we've made this open on click, we need a way

00:11:52,220 --> 00:11:53,970
to get back.

00:11:53,970 --> 00:11:56,170
Let's check this out in the browser.

00:11:56,170 --> 00:12:02,800
Now, when I hover over it, that's the old version, so, now, it's not hover interaction

00:12:02,800 --> 00:12:03,820
any more.

00:12:03,820 --> 00:12:08,850
I've indicated that it's interactive by changing the text to have some other indication which,

00:12:08,850 --> 00:12:10,329
in this case, is an underline.

00:12:10,329 --> 00:12:15,389
When we look at it, we can tell it's more interactive than just text on the screen.

00:12:15,389 --> 00:12:21,470
So, when I click on it now, I can actually fire this interaction, and my focus is sent

00:12:21,470 --> 00:12:24,190
into it.

00:12:24,190 --> 00:12:31,019
If I'm using the keyboard, instead of passing by this component, I can use the enter key

00:12:31,019 --> 00:12:33,980
and this is sent into the component.

00:12:33,980 --> 00:12:39,730
This is a simple card flip, but these keyboard mechanics, you can use for other things, modal

00:12:39,730 --> 00:12:43,459
dialogues, menus - which we will look at in a second.

00:12:43,459 --> 00:12:48,790
We want to make make sure that we're not leaving the keyboard user behind completely by not

00:12:48,790 --> 00:12:52,430
making things focusable and not handling their focus.

00:12:52,430 --> 00:12:58,380
In JavaScript applications with be we want to be mindful of the user's focus and sending

00:12:58,380 --> 00:13:01,639
them in and out of interactive layer.

00:13:01,639 --> 00:13:03,639
This is a lot better.

00:13:03,639 --> 00:13:08,779
There is a Twitter link in here that also needs a little bit of help.

00:13:08,779 --> 00:13:14,160
One thing I want to fix now is, if you're seeing this blue focus ring, you might be

00:13:14,160 --> 00:13:16,860
going, "Wait a minute, I need to turn that off.

00:13:16,860 --> 00:13:18,209
I hate that blue outline.

00:13:18,209 --> 00:13:19,209
I've been there."

00:13:19,209 --> 00:13:22,440
So I have a solution for you: let's go back to our text editor.

00:13:22,440 --> 00:13:31,019
I'm actually going to add a tool called "what input".

00:13:31,019 --> 00:13:39,100
I can download it from MPM, gives you a hook in your - to input the user modality.

00:13:39,100 --> 00:13:46,720
If you're using a mouse, they can style one way, a keyboard another way, and so on.

00:13:46,720 --> 00:13:56,430
There is a standards-based condition coming been it's not ready for prime-time yet, so

00:13:56,430 --> 00:14:03,089
I'm still a what-input fan, but we need one more piece to this.

00:14:03,089 --> 00:14:05,490
I'm going to cheat a little bit.

00:14:05,490 --> 00:14:12,080
I'm going to check out the solution.

00:14:12,080 --> 00:14:18,339
If we add what-input, if we go to our CSS, instead of lining the outside line for everyone,

00:14:18,339 --> 00:14:22,070
which, if you have outlined none for everything, nuke it from orbit.

00:14:22,070 --> 00:14:23,680
Get rid of it.

00:14:23,680 --> 00:14:29,009
Put it to focus visible to be more selective about how you apply focus.

00:14:29,009 --> 00:14:36,440
With this what-intent input, whatever that matches, then we can hide the outline.

00:14:36,440 --> 00:14:38,759
I will show you what effect that has.

00:14:38,759 --> 00:14:42,740
Now, when we click on this component with the mouse, we don't get that outline.

00:14:42,740 --> 00:14:49,079
It keeps mouse users happy, but if I use the keyboard as an input modality, I still get

00:14:49,079 --> 00:14:53,420
that visible outline, so I can see where I am on the screen, which is super important

00:14:53,420 --> 00:14:56,940
if you can't use a mouse, or attraction pad, even.

00:14:56,940 --> 00:15:02,420
Users who rely on that can't magically grow the ability to see where they are on the screen.

00:15:02,420 --> 00:15:08,759
This is super helpful and makes it easy to support all users.

00:15:08,759 --> 00:15:14,730
That's a card flip animation, how we can support everybody by doing it.

00:15:14,730 --> 00:15:18,280
I guess before we move on, I want to show you what the tests are like for this card

00:15:18,280 --> 00:15:19,709
flip.

00:15:19,709 --> 00:15:24,000
So, I've written some unit tests for this.

00:15:24,000 --> 00:15:28,610
It's debatable whether you want your tests to live in unit tests or integrate tests.

00:15:28,610 --> 00:15:30,339
I think you can do both.

00:15:30,339 --> 00:15:35,400
It depends on what exactly you're testing, but for focus management, unit tests make

00:15:35,400 --> 00:15:40,459
a lot of sense if you're testing APIs, like, if you have a focus manager throughout your

00:15:40,459 --> 00:15:46,230
whole application, you can test with unit tests for that been in this case, I could

00:15:46,230 --> 00:15:47,230
have done either.

00:15:47,230 --> 00:15:50,199
I'm testing where the focus has been handled.

00:15:50,199 --> 00:15:55,470
I'm testing the state of this component, so I'm using Jest for this component.

00:15:55,470 --> 00:16:02,820
I'm first testing the active state, and check - or setting the state in the test to true.

00:16:02,820 --> 00:16:09,670
This is the mouse-user case, and just using pure state, so, the side effect of changing

00:16:09,670 --> 00:16:13,350
the state of this component is that it adds a CSS class of active.

00:16:13,350 --> 00:16:19,389
I can go and check, if I modify the state, that it is handling that appropriately.

00:16:19,389 --> 00:16:24,300
For the keyboard mechanics, I want to do the same thing, I want to see the side effect

00:16:24,300 --> 00:16:29,540
of the DOM being manipulated but I want to simulate it with a keydown event.

00:16:29,540 --> 00:16:34,250
With Enzyme in React land, you can simulate events.

00:16:34,250 --> 00:16:38,990
The catch is that your event handling has to be in React.

00:16:38,990 --> 00:16:45,200
You can't use Enzyme to simulate a native implement event, so a little bit of a gotcha

00:16:45,200 --> 00:16:50,470
there, but since I did use React for this, I can simulate that event and check that my

00:16:50,470 --> 00:16:53,230
logic and component is doing what I expect.

00:16:53,230 --> 00:16:59,850
In this case, I'm simulating a key down with an enter key on that burnt that I created.

00:16:59,850 --> 00:17:04,220
I suspect it will also add that touch of class.

00:17:04,220 --> 00:17:10,420
Gotcha number two is that sometimes, your DOM may not be ready when you go to test it.

00:17:10,420 --> 00:17:15,900
The element might not be visible yet, and you need a way to tick.

00:17:15,900 --> 00:17:16,900
Is sucks.

00:17:16,900 --> 00:17:19,020
I wish we didn't have to do that.

00:17:19,020 --> 00:17:26,270
If you're testing for accessibility, you might have to become friends with the sett function.

00:17:26,270 --> 00:17:27,680
We just tell - the setTimeout function.

00:17:27,680 --> 00:17:33,530
We tell the element with the focusable thing is actually visible and ready.

00:17:33,530 --> 00:17:39,740
Then to take this one step further, I've got the same API that we used earlier, and the

00:17:39,740 --> 00:17:45,660
AX web driver JS utility, using the underlying JavaScript core library.

00:17:45,660 --> 00:17:52,750
If you've used lighthouse in Google Chrome, it is the same accessibility there.

00:17:52,750 --> 00:18:03,010
The idea is that it's the same API to get accessibility basics into your tests automation.

00:18:03,010 --> 00:18:07,500
That way, if a team-mate breaks something for accessibility, or you come back a few

00:18:07,500 --> 00:18:12,840
weeks later and break your own thing, you can prevent those problems from making it

00:18:12,840 --> 00:18:14,700
into production.

00:18:14,700 --> 00:18:21,611
Because I'm using Jest here, which uses JS DOM, I've disabled two rules in AX: colour

00:18:21,611 --> 00:18:28,150
contrast and text block, because JS DOM doesn't have some of the necessary APIs for that,

00:18:28,150 --> 00:18:33,960
but then you would want to go back either to a browser extension and run those colour-contrast

00:18:33,960 --> 00:18:39,890
tests again because that's actually the number-one accessibility problem on the web.

00:18:39,890 --> 00:18:46,530
In this case, my app didn't really in have any colour contrast problems.

00:18:46,530 --> 00:18:57,340
I'm instantiating my component, passing it dummy data and then using x.run and making

00:18:57,340 --> 00:19:00,320
similar assertions as I did in my test.

00:19:00,320 --> 00:19:05,460
I'm going to do mpm test.

00:19:05,460 --> 00:19:07,960
That's going to fire up jest.

00:19:07,960 --> 00:19:11,110
I can hit "all", and we will see what is going on.

00:19:11,110 --> 00:19:14,060
Our tests are passing, which is amazing.

00:19:14,060 --> 00:19:15,400
I've got that card flip.

00:19:15,400 --> 00:19:16,880
It's checking the keyboard mechanics.

00:19:16,880 --> 00:19:22,260
So, if I broke it, like maybe somebody didn't know what the button was for, that test would

00:19:22,260 --> 00:19:23,260
then fail.

00:19:23,260 --> 00:19:30,070
It is not just accessibility testing off to the side, it's baked into our tests, so it's

00:19:30,070 --> 00:19:34,810
a holistic approach, and it really makes it embedded and mainstream.

00:19:34,810 --> 00:19:39,080
I love that way of working, especially with test-driven development when you can write

00:19:39,080 --> 00:19:44,090
a failing test, go at the feature, and then make the test pass.

00:19:44,090 --> 00:19:45,620
So that's a card flip.

00:19:45,620 --> 00:19:49,230
Let's look at our last component, which is a December top-style menu.

00:19:49,230 --> 00:19:55,120
Now, if you're building something like a text editor built with web technologies, or actually

00:19:55,120 --> 00:20:01,010
you have a complex web application that your menu doesn't necessarily navigate the user

00:20:01,010 --> 00:20:07,770
to places, but you can do things like find something, or split consent into lines, this

00:20:07,770 --> 00:20:14,130
menu that I have here is very - it looks like something you would pinned in a text editor.

00:20:14,130 --> 00:20:18,370
When I more over each of these selections, it opens that little sub menu.

00:20:18,370 --> 00:20:23,530
So, if I go in and inspect this, let's see what is going on with this markup.

00:20:23,530 --> 00:20:26,470
So the menu is an unordered list.

00:20:26,470 --> 00:20:33,060
It has a set of list items that are not interactive, so there is some hover going on here but no

00:20:33,060 --> 00:20:35,880
handle for a keyboard user to get to.

00:20:35,880 --> 00:20:40,510
The sub content is a sibling unordered list.

00:20:40,510 --> 00:20:46,350
There is no programmatic association between these two, no hooks for keyboards, no screenreader

00:20:46,350 --> 00:20:47,350
support.

00:20:47,350 --> 00:20:52,320
I just found this component in any event on the internet.

00:20:52,320 --> 00:20:54,060
You might find stuff like this.

00:20:54,060 --> 00:20:58,700
Without a second thought, you're shipping something that you naught was saving you time

00:20:58,700 --> 00:21:03,810
but opens you up for some accessibility risk, and leaving your users behind.

00:21:03,810 --> 00:21:09,090
So I thought this had potential, and let's go and look at how I actually fixed this.

00:21:09,090 --> 00:21:10,900
Let's go back to our text editor.

00:21:10,900 --> 00:21:14,470
I will open up our menu component.

00:21:14,470 --> 00:21:17,940
It's using this React menu AIM component.

00:21:17,940 --> 00:21:23,371
It is actually creating a React mix-in under the hood, and then the tell me mow that I

00:21:23,371 --> 00:21:27,620
pulled in gave me the opportunity to make changes to it.

00:21:27,620 --> 00:21:36,171
So the default state of this is all this good stuff that is sadly not accessible, so, let's

00:21:36,171 --> 00:21:37,850
go and fix it.

00:21:37,850 --> 00:21:43,560
I'm going to get out of Jest, and I'm going to check out the fixed solution for this.

00:21:43,560 --> 00:21:49,710
We will go and make sure that our solution is showing.

00:21:49,710 --> 00:21:53,420
I guess the first thing I had to do was add assist focusable.

00:21:53,420 --> 00:21:59,640
I added a few different items to this to the role of menu, to insist on the fact that this

00:21:59,640 --> 00:22:08,130
is a desktop-style menu, and, inside the top-level list items, I opted to create a button for

00:22:08,130 --> 00:22:11,280
each item so that it would be focusable by default.

00:22:11,280 --> 00:22:16,260
I'm giving that a role of menu item, so kind of overloading the default semantics of that

00:22:16,260 --> 00:22:19,990
element, but I'm getting the focusability for free.

00:22:19,990 --> 00:22:22,260
This pattern is not something I made up.

00:22:22,260 --> 00:22:27,030
It's from the authoring practices guide.

00:22:27,030 --> 00:22:33,930
I'm using their recommended attributes of RE has pop-up of true, using REX expanded,

00:22:33,930 --> 00:22:39,000
I can change that attribute to be true or false, and this is where the magic happens,

00:22:39,000 --> 00:22:41,060
the on-key-down function.

00:22:41,060 --> 00:22:44,920
It uses a ref so I can handle focus management between here.

00:22:44,920 --> 00:22:49,660
To finish out our our tour, I have the child list.

00:22:49,660 --> 00:22:54,040
Instead of being siblings, I moved it so it is inside of that list item.

00:22:54,040 --> 00:23:03,030
That way, we don't have to use something like the controls, which, if you've read -

00:23:03,030 --> 00:23:08,310
so I opted to use HTML's own hierarchy to make that association.

00:23:08,310 --> 00:23:13,300
Then the child items for this stage one, I just did the top level.

00:23:13,300 --> 00:23:18,180
When I handled the key events, I can hit handle up or down, and those will check where we

00:23:18,180 --> 00:23:21,730
are in the menu and change the state accordingly.

00:23:21,730 --> 00:23:27,230
So the state is really just setting the state of what the active index is, and then, if

00:23:27,230 --> 00:23:31,530
I've used the keyboard, which I know because I've used the keyboard to get there, I can

00:23:31,530 --> 00:23:37,830
add focus to the item.. if I go to this menu now, it looks slightly different but you can

00:23:37,830 --> 00:23:39,560
play around with the style.

00:23:39,560 --> 00:23:44,540
The idea of the desktop menu, it's not actual links.

00:23:44,540 --> 00:23:47,970
It is is one-tab stop.

00:23:47,970 --> 00:23:54,560
I can arrow around, and now I can real reach everything for this stage one.

00:23:54,560 --> 00:23:58,430
For stage 2, let's check that out real quick.

00:23:58,430 --> 00:24:04,400
Let's make sure we don't have any changes.

00:24:04,400 --> 00:24:08,990
For stage 2, it got a little more complex, because now I have to manage the state of

00:24:08,990 --> 00:24:15,350
two levels, so, for my first pass at this, I had to add hooks for the number of item

00:24:15,350 --> 00:24:23,040
in both levels, I had to refresh this, and I have to maintain the sub menu items, and

00:24:23,040 --> 00:24:24,420
all kinds of stuff.

00:24:24,420 --> 00:24:28,050
So, you can check this out on GitHub to see the full solution.

00:24:28,050 --> 00:24:33,560
If we go look at it in the browser, now, I can go through tease top-level items and I

00:24:33,560 --> 00:24:37,030
can get to the lower level of items.

00:24:37,030 --> 00:24:41,310
With a little bit of refactoring I was able to make this way more accessible than it was

00:24:41,310 --> 00:24:42,390
before.

00:24:42,390 --> 00:24:45,980
This is something I will probably contribute back to the component, because, when you're

00:24:45,980 --> 00:24:51,250
using components, you can really help other people out by filing issues for sensibility,

00:24:51,250 --> 00:24:57,340
and, if you have the solution, contribute it or suggest it in the issue before we have

00:24:57,340 --> 00:25:02,850
managed to make make some things way more accessible than they were before.

00:25:02,850 --> 00:25:04,110
I don't have slides.

00:25:04,110 --> 00:25:08,030
If you want to review what we worked on today, you can check out my GitHub.

00:25:08,030 --> 00:25:11,540
I've tagged all the fixes in git tags.

00:25:11,540 --> 00:25:13,180
There are resources here.

00:25:13,180 --> 00:25:18,240
If you're new to accessibility, need help, get your team members on here, got some resources

00:25:18,240 --> 00:25:19,240
here.

00:25:19,240 --> 00:25:25,780
I want to, you don't need to reinvent the wheel with a lot of these interactions and

00:25:25,780 --> 00:25:26,780
components.

00:25:26,780 --> 00:25:32,070
You can check what is out there already and learn more about accessibility.

00:25:32,070 --> 00:25:39,510
My last caveat is that automated testing and this type of work will only get to the low-hanging

00:25:39,510 --> 00:25:43,880
fruit, so you also want to test with real users, because automated tooling can't catch

00:25:43,880 --> 00:25:46,040
everything.

00:25:46,040 --> 00:25:51,340
It relies on you to know how to make the components in your app more successful with tips like

00:25:51,340 --> 00:25:57,360
I have in this repo but then test with peel people - people with disabilities.

00:25:57,360 --> 00:25:59,550
See how they use your application.

00:25:59,550 --> 00:26:04,350
You might be surprise they stumble and hit barriers.

00:26:04,350 --> 00:26:08,890
I hope I've given you tools and techniques you can use to make your apps so much more

00:26:08,890 --> 00:26:09,890
successful.

00:26:09,890 --> 00:26:10,890
Thanks very much for having me.

00:26:10,890 --> 00:26:11,390

YouTube URL: https://www.youtube.com/watch?v=l95VFLj3e2w


