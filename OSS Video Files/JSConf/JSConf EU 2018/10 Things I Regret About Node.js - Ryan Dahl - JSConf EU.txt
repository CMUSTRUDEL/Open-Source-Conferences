Title: 10 Things I Regret About Node.js - Ryan Dahl - JSConf EU
Publication date: 2018-06-06
Playlist: JSConf EU 2018
Description: 
	See also https://github.com/ry/deno

JSConf EU is coming back in 2019 https://2019.jsconf.eu/
Captions: 
	00:00:00,089 --> 00:00:04,160
Hello.

00:00:04,160 --> 00:00:19,180
Hey, so, yeah, I kind of wanted to give a different talk about some other stuff, but

00:00:19,180 --> 00:00:23,560
I wasn't ready, so this is a make-up talk.

00:00:23,560 --> 00:00:30,130
It's been some years since Node came out, and it's kind of stabilised, and it's a thing,

00:00:30,130 --> 00:00:33,710
and it's kind of going into its direction.

00:00:33,710 --> 00:00:39,890
I thought I would look back on it and tell you what I think about Node.

00:00:39,890 --> 00:00:44,880
So, sorry, I'm a little nervous.

00:00:44,880 --> 00:00:47,980
Excuse my wavering voice.

00:00:47,980 --> 00:00:50,040
Right, some background.

00:00:50,040 --> 00:00:55,430
I created Node and managed it through its initial development for a couple of years,

00:00:55,430 --> 00:01:07,770
and, my goal, as you may know was really around IO, and doing event-driven IO in JavaScript.

00:01:07,770 --> 00:01:14,259
I think that focus was really important in 2009 for getting server-side JavaScript off

00:01:14,259 --> 00:01:23,020
the frowned, because, as we know now, JavaScript is sing-threaded, and like - I'm sorry.

00:01:23,020 --> 00:01:28,030
And - sorry, lost my train of thought.

00:01:28,030 --> 00:01:37,210
JavaScript is single-threaded, blah, blah, blah, that allowed Node to succeed.

00:01:37,210 --> 00:01:46,049
I felt that Node was doing well in the IO department.

00:01:46,049 --> 00:01:56,479
Like we had protocol supports, like HTTP, and HTTPS, and we ported Node to windows using

00:01:56,479 --> 00:02:04,060
a nice systems calls IOCP, and we were running on Linux, Mac, and it had a relatively small

00:02:04,060 --> 00:02:05,060
core.

00:02:05,060 --> 00:02:09,409
I mean, it kind of got out of hand a little bit, but it was okay.

00:02:09,409 --> 00:02:16,250
It has a stable API, MPM was out, and there were people adding modules.

00:02:16,250 --> 00:02:20,530
I was like, "This project is done now."

00:02:20,530 --> 00:02:22,290
So wrong!

00:02:22,290 --> 00:02:31,790
Right, obviously, this is a tremendous effort to keep Node running on everybody's machines

00:02:31,790 --> 00:02:40,239
as it does today, and keep it updated with JavaScript, and fix the issues with it, and

00:02:40,239 --> 00:02:47,819
many people have been involved in this effort, many of them are here.

00:02:47,819 --> 00:02:55,609
And I'm sorry, I'm probably being leaving out many important people.

00:02:55,609 --> 00:03:02,239
I personally was kind of done with Node, and went on to do other.

00:03:02,239 --> 00:03:07,959
It's only really in the last six months that I've started using it heavily again.

00:03:07,959 --> 00:03:16,390
Largely because Go came out, and I was interested in servers, and doing fast servers, and, Go

00:03:16,390 --> 00:03:19,790
is a better language for doing Fast servers.

00:03:19,790 --> 00:03:23,340
There was no need for me to be using Node.

00:03:23,340 --> 00:03:28,040
But, I think Node is quite nice.

00:03:28,040 --> 00:03:30,670
JavaScript is really quite nice.

00:03:30,670 --> 00:03:37,269
In particular, dynamic languages with very nice.

00:03:37,269 --> 00:03:40,930
And they're nice for certain things, I should say.

00:03:40,930 --> 00:03:46,269
I think if you're building a server, and you want to really control every aspect of it,

00:03:46,269 --> 00:03:51,769
absolutely, you want it to be statically typed, but in scientific computing, for example,

00:03:51,769 --> 00:03:58,730
there is a lot of one-off calculations, you're kind of typing into a Jupiter notebook, and

00:03:58,730 --> 00:04:01,150
you really don't want to hit a type error at that point.

00:04:01,150 --> 00:04:03,159
You're just trying to plot something, right?

00:04:03,159 --> 00:04:06,560
There's a time and place for dynamic languages.

00:04:06,560 --> 00:04:08,349
Prototyping things is another situation.

00:04:08,349 --> 00:04:12,519
Like you want to move very fast, you don't want to worry about what the abstractions

00:04:12,519 --> 00:04:15,640
are, you just want to be dynamic.

00:04:15,640 --> 00:04:22,210
JavaScript, obviously, I mean maybe there's many people that don't agree, but here they

00:04:22,210 --> 00:04:23,210
do.

00:04:23,210 --> 00:04:25,840
It is the best dynamic language.

00:04:25,840 --> 00:04:37,750
So, right, using Node is kind of like nails on chalkboard to me at times, just because

00:04:37,750 --> 00:04:44,889
I see the bugs that I introduced that aren't really bugs at this point, they're just how

00:04:44,889 --> 00:04:47,960
it works, but they are bugs.

00:04:47,960 --> 00:04:53,070
And they were design mistakes made that just cannot be corrected now because there's so

00:04:53,070 --> 00:05:02,650
much software there that uses it, and I don't know, it offends my sensibilities.

00:05:02,650 --> 00:05:04,979
It could have been much nicer.

00:05:04,979 --> 00:05:10,360
So, one regret would be that I didn't stick with promises.

00:05:10,360 --> 00:05:17,349
So, promises were added very early, and I foolishly removed them not very long after

00:05:17,349 --> 00:05:22,030
with the idea that we should be minimal and promises introduced an extra object into every

00:05:22,030 --> 00:05:29,190
callback, and I could see my reasoning at the time, but had that gone differently, it

00:05:29,190 --> 00:05:36,979
might have made the ecosystem around building asynch await stuff happen faster unclear.

00:05:36,979 --> 00:05:42,810
It is an alternate history that we will never know.

00:05:42,810 --> 00:05:47,780
Maybe it was a good thing that promises were removed because it allowed the ecosystem to

00:05:47,780 --> 00:05:50,729
develop their own tools, and we found the right abstraction.

00:05:50,729 --> 00:05:55,280
But, I have often thought that I wish I had left that in.

00:05:55,280 --> 00:05:57,190
That was a rash decision.

00:05:57,190 --> 00:06:01,720
Did I say all of this?

00:06:01,720 --> 00:06:03,090
Yes.

00:06:03,090 --> 00:06:08,940
Another regret is security, because JavaScript is a very secure sandbox, unlike Python, right?

00:06:08,940 --> 00:06:13,879
Unfortunately, in Node, we just bounce to everything and is there is zero security.

00:06:13,879 --> 00:06:17,319
You run a Node programme, you have access to all sorts of system calls.

00:06:17,319 --> 00:06:25,470
That was really a missed opportunity to be able to make a sever side run time that could

00:06:25,470 --> 00:06:27,550
potentially be secured in certain situations.

00:06:27,550 --> 00:06:31,160
Obviously, if you wanted to give access to the disk, then people are going to be able

00:06:31,160 --> 00:06:37,120
to exploit the disk, but there are certain situations where you want to run a programme

00:06:37,120 --> 00:06:43,539
outside of the web browser, but you don't want to to access the disk or network.

00:06:43,539 --> 00:06:45,280
For example, a linter.

00:06:45,280 --> 00:06:53,110
It would be nice to download the massive codebase that Lint is and run it without it taking

00:06:53,110 --> 00:06:57,740
over my computer - which it could.

00:06:57,740 --> 00:07:01,180
Yes.

00:07:01,180 --> 00:07:08,889
Yes, probably biggest regret is the build system.

00:07:08,889 --> 00:07:10,250
Such a pain.

00:07:10,250 --> 00:07:16,380
Build systems are very, very difficult and very, very important to building projects.

00:07:16,380 --> 00:07:22,630
Node uses this thing called jip.

00:07:22,630 --> 00:07:29,330
If you're writing a module that links to a C library, you use this thing called jip to

00:07:29,330 --> 00:07:35,830
compile that C library and link it into Node, right?

00:07:35,830 --> 00:07:42,520
Jip is this thing that Chrome used to use, but Chrome, like abandoned jip for this other

00:07:42,520 --> 00:07:46,090
tool called GN several years later.

00:07:46,090 --> 00:07:50,870
We couldn't have predicted that, but that's what happens.

00:07:50,870 --> 00:07:55,620
Now it has been many years since that happened, and Node is the sole user of jip.

00:07:55,620 --> 00:08:04,009
It is a funky interface, a JSON file, but it's in Python.

00:08:04,009 --> 00:08:05,849
It's very terrible.

00:08:05,849 --> 00:08:07,970
Node has several wrappers around this.

00:08:07,970 --> 00:08:09,770
One of them is called node.jip.

00:08:09,770 --> 00:08:14,860
It is layers upon layers of unnecessary complexity.

00:08:14,860 --> 00:08:17,360
V8 doesn't build with jip any more.

00:08:17,360 --> 00:08:23,590
It has a jip wrapper to support node, there is just so much unnecessary complex technology

00:08:23,590 --> 00:08:28,479
there, and, gentlemen, frankly, I think this is one of the biggest failures of the Node

00:08:28,479 --> 00:08:31,150
technical leadership.

00:08:31,150 --> 00:08:33,810
It should be dealt with.

00:08:33,810 --> 00:08:44,650
So, I think yes, I am not sure which direction would be the right way to go at this point.

00:08:44,650 --> 00:08:45,750
It's a difficult problem.

00:08:45,750 --> 00:08:56,750
There's a lot of software to support, but I do think that I kind of made a kind of rash

00:08:56,750 --> 00:09:02,860
decision in thinking that everybody should compile their extension modules.

00:09:02,860 --> 00:09:07,400
We could have gone with a foreign function interface, which doesn't require any compiling

00:09:07,400 --> 00:09:12,960
necessarily, although you have to have your dependencies there, but I think this could

00:09:12,960 --> 00:09:21,370
have been a much more natural and easy interface for people who want to link to system libraries,

00:09:21,370 --> 00:09:28,700
and many people suggested this to me, namely Bryan Cantrell, but I totally ignored them.

00:09:28,700 --> 00:09:40,190
And, yes, LBUV moved to autotools which is unacceptable and regrettable.

00:09:40,190 --> 00:09:42,660
You know who you are!

00:09:42,660 --> 00:09:44,580
[Laughter].

00:09:44,580 --> 00:09:45,580
I didn't do that.

00:09:45,580 --> 00:09:49,300
That's a regret for somebody else.

00:09:49,300 --> 00:09:51,120
[Laughter].

00:09:51,120 --> 00:09:53,580
So, right been.

00:09:53,580 --> 00:09:54,580
Another thing.

00:09:54,580 --> 00:09:55,580
Package JSON.

00:09:55,580 --> 00:10:00,160
It is like the life blood of JavaScript at this point.

00:10:00,160 --> 00:10:07,980
But, you know, at some point, it wasn't, and Isaac of MPM fame more or less defined it,

00:10:07,980 --> 00:10:13,770
although there might have been some sort of specification, and I largely sanctioned it,

00:10:13,770 --> 00:10:21,310
and made it popular by allowing require in Node semantics to look into package JSON and

00:10:21,310 --> 00:10:25,130
look through files.

00:10:25,130 --> 00:10:34,080
This makes package JSON necessary for programmes, for Node programmes where it was not before,

00:10:34,080 --> 00:10:40,650
and then ultimately, I included MPM into Node which made MPM made them the standard Node

00:10:40,650 --> 00:10:55,740
distribution service, and yes, so, I have this problem about the little abstract, but

00:10:55,740 --> 00:11:02,960
in your JavaScript programme, right, if you require some module, that doesn't completely

00:11:02,960 --> 00:11:04,800
specify what that module is.

00:11:04,800 --> 00:11:12,080
It also needs to be defined in your pack age JSON, that is part of the resolution algorithm,

00:11:12,080 --> 00:11:20,410
like, which version it is and what not, in order to install it, and you also have this

00:11:20,410 --> 00:11:24,010
Node modules folder which does the modules resolution.

00:11:24,010 --> 00:11:33,360
So, you know, kind of linking to a package requires a lot of systems here, a lot of components

00:11:33,360 --> 00:11:37,030
that is not - what's that?

00:11:37,030 --> 00:11:39,550
I cloud.

00:11:39,550 --> 00:11:40,810
Urgh.

00:11:40,810 --> 00:11:43,320
All right.

00:11:43,320 --> 00:11:51,670
So, yes, I mean, pack age JSON, the problem I have with it is that it gives this rise

00:11:51,670 --> 00:11:57,740
to a concept of a module as this directory of files, where that wasn't really a concept

00:11:57,740 --> 00:11:58,740
before.

00:11:58,740 --> 00:12:00,070
Like we had JavaScript files.

00:12:00,070 --> 00:12:05,420
On the web, we had JavaScript files, and you can script-tag include them all over the place.

00:12:05,420 --> 00:12:06,710
There's, like, thing.

00:12:06,710 --> 00:12:10,980
There is no module pack age as there is in MPM.

00:12:10,980 --> 00:12:15,860
It is not a necessary abstraction.

00:12:15,860 --> 00:12:21,390
Package JSON has all this unnecessary noise in it.

00:12:21,390 --> 00:12:22,870
Like why am I filling this out?

00:12:22,870 --> 00:12:25,040
I feel like a bookkeeper.

00:12:25,040 --> 00:12:32,190
This is unnecessary stuff so do when all I'm trying to do is link to a library.

00:12:32,190 --> 00:12:38,580
I will get to relative URLs.

00:12:38,580 --> 00:12:45,140
Of course, Node modules get very big because it kind of has this vendoring by default semantics

00:12:45,140 --> 00:12:52,430
where modules are installed locally into your project folder, so you tend to have, if you

00:12:52,430 --> 00:12:56,000
have multiple projects, it gets big.

00:12:56,000 --> 00:12:57,190
This was my idea.

00:12:57,190 --> 00:13:02,470
I regret it.

00:13:02,470 --> 00:13:08,220
The whole algorithm or resolving module names is just wildly complex.

00:13:08,220 --> 00:13:16,750
It is kind of been added to over time in ways that are regrettable.

00:13:16,750 --> 00:13:26,420
I feel like the vendored by default, idea behind Node modules which is what I was going

00:13:26,420 --> 00:13:31,300
for there was kind of had good intentions, that we know exactly what we are linking to.

00:13:31,300 --> 00:13:37,130
It was supposed to be explicit, but, in practice, like a Node path type thing, a Python path

00:13:37,130 --> 00:13:41,120
type thing would have worked.

00:13:41,120 --> 00:13:44,220
You set an environmental variable.

00:13:44,220 --> 00:13:51,420
It just deviates greatly from how browsers do stuff, and it's my fault, and I'm very

00:13:51,420 --> 00:13:56,560
sorry, and, unfortunately, it is impossible to undo now.

00:13:56,560 --> 00:14:04,090
Also, this whole thing where you don't include the extension in the require module.

00:14:04,090 --> 00:14:05,450
Why?

00:14:05,450 --> 00:14:08,620
It's like needlessly non-explicit.

00:14:08,620 --> 00:14:12,370
You now have to, like, probe the file system for different things.

00:14:12,370 --> 00:14:15,960
Did you mean .just, .ts?

00:14:15,960 --> 00:14:21,760
No, just writing the ... extension in there!

00:14:21,760 --> 00:14:24,810
[Applause].

00:14:24,810 --> 00:14:31,770
I'm glad you guys agree with me, because there is still some debate about this stuff.

00:14:31,770 --> 00:14:33,860
People like the extension list thing.

00:14:33,860 --> 00:14:34,930
It is cleaner.

00:14:34,930 --> 00:14:37,190
Like no!

00:14:37,190 --> 00:14:39,410
Yes.

00:14:39,410 --> 00:14:40,610
Said all that.

00:14:40,610 --> 00:14:41,640
Also, index.js.

00:14:41,640 --> 00:14:43,000
I'm sorry.

00:14:43,000 --> 00:14:44,000
I thought it was cute.

00:14:44,000 --> 00:14:45,340
There's index.html.

00:14:45,340 --> 00:14:52,910
I thought when you include a directory, it would look up index.js.

00:14:52,910 --> 00:14:56,020
This was needlessly introduced.

00:14:56,020 --> 00:15:01,630
What I've come to learn now that I'm age willing is that, like, when you're designing a programme,

00:15:01,630 --> 00:15:05,230
there are things that you think might be cute to add in.

00:15:05,230 --> 00:15:06,790
You always regret those.

00:15:06,790 --> 00:15:17,140
If those are unnecessary and simply cute, like don't do them.

00:15:17,140 --> 00:15:21,660
My problems with Node aren't so much around the IO, and honestly, I like Node.

00:15:21,660 --> 00:15:22,670
I like programming in it.

00:15:22,670 --> 00:15:25,110
I think it is relatively nice.

00:15:25,110 --> 00:15:32,790
It is Unix-y but my problems are more to do with the module system and how it manages

00:15:32,790 --> 00:15:34,590
user code.

00:15:34,590 --> 00:15:39,760
And I think this is largely because, when I was making Node, like it was very focused

00:15:39,760 --> 00:15:41,230
on getting this IO stuff.

00:15:41,230 --> 00:15:51,010
I was nerding out hard-core on e pull and the module system was essentially an afterthought

00:15:51,010 --> 00:15:57,940
that got added on as users needed this stuff, and it is reflected in how Node works now.

00:15:57,940 --> 00:16:02,920
So, yes, with that in mind, I was writing up this talk.

00:16:02,920 --> 00:16:05,120
It seemed negative.

00:16:05,120 --> 00:16:10,520
I thought this is shitty to come you mean in front of people and complain about stuff

00:16:10,520 --> 00:16:17,490
without giving like you should offer some sort of solution, or like at least a prototype

00:16:17,490 --> 00:16:22,560
of how things might be differently, or how Node might be differently if you designed

00:16:22,560 --> 00:16:27,670
it today, and all I say is that don't try out this code.

00:16:27,670 --> 00:16:30,390
It's very, very unusable at this moment.

00:16:30,390 --> 00:16:32,090
It does not do anything.

00:16:32,090 --> 00:16:41,580
Unless you're well versed in LLDB, you should not try building it, but that said, you might

00:16:41,580 --> 00:16:50,530
want to check out - Dano is a secure typescript runtime on V8 working on the tag line.

00:16:50,530 --> 00:17:00,010
Not so sure about that this is a new piece of software, one month old.

00:17:00,010 --> 00:17:07,380
This is my riffing on what I think would be a nice server time runtime these days.

00:17:07,380 --> 00:17:10,919
Event IO is taken for granted.

00:17:10,919 --> 00:17:12,240
We have to do that.

00:17:12,240 --> 00:17:15,329
What else is important?

00:17:15,329 --> 00:17:17,209
For one, security.

00:17:17,209 --> 00:17:20,589
It would be nice to utilise that JavaScript is a sandbox.

00:17:20,589 --> 00:17:28,710
By default no write access, and that users can then opt into various access.

00:17:28,710 --> 00:17:34,370
So, if you want to allow it to access the network, you do dash dash allow network.

00:17:34,370 --> 00:17:42,220
This allows people in situations, you have some code that you want to run without giving

00:17:42,220 --> 00:17:49,519
it much access to the system that you're you are running on, and this allows you to do

00:17:49,519 --> 00:17:54,200
that via the fact that JavaScript is a runtime.

00:17:54,200 --> 00:18:10,510
We don't bind or allow the system to reach into the operating system.

00:18:10,510 --> 00:18:13,000
All system pulls are done through a message past.

00:18:13,000 --> 00:18:18,990
There's a single entry point where it's found all over the place, it's very difficult to

00:18:18,990 --> 00:18:26,100
keep track of what is happening in those single entry points, and this has caused a lot of

00:18:26,100 --> 00:18:44,389
problems trying to find the domains, and [sound feed distorted].

00:18:44,389 --> 00:18:51,509
I thought for many years, , having this ... thing would be nice.

00:18:51,509 --> 00:18:55,160
Here's a pig description of what it is.

00:18:55,160 --> 00:19:01,309
You have like the deno process which is written in Go at the moment, although I'm debating

00:19:01,309 --> 00:19:08,850
whether that is the right choice, and you have V8 running there inside of it, and there

00:19:08,850 --> 00:19:16,450
is the send-and-receive calls that are bound into V8, and it can send and receive proto-buff

00:19:16,450 --> 00:19:17,450
messages.

00:19:17,450 --> 00:19:19,779
They're array buffers.

00:19:19,779 --> 00:19:26,429
There is a dispatcher that kind of like sends out messages to various different modules,

00:19:26,429 --> 00:19:32,159
so these modules can kind of on both sides of the kind of privileged and unprivileged

00:19:32,159 --> 00:19:40,030
boundary sync up, and the Go side can handle the system calls and return your request for

00:19:40,030 --> 00:19:46,529
a set time out into a sleeper, whatever, and, in V8, you have a similar module system.

00:19:46,529 --> 00:19:53,620
Inside of V8 itself, you have the typescript compiler, built into the whole executable.

00:19:53,620 --> 00:19:54,700
I love type typescript.

00:19:54,700 --> 00:19:59,110
It is the best thing.

00:19:59,110 --> 00:20:06,289
I don't know the people who did this work at Microsoft, but, man, it is very pragmatic

00:20:06,289 --> 00:20:12,139
and well done and approachable, and I just love the fact that you can start hacking in

00:20:12,139 --> 00:20:16,820
normal JavaScript and just slowly kind of build your project up.

00:20:16,820 --> 00:20:20,279
This was one of the goals of Dart.

00:20:20,279 --> 00:20:27,110
Do you know Dart?

00:20:27,110 --> 00:20:30,220
Total failure!

00:20:30,220 --> 00:20:35,720
Very good intentions and cool, but obviously, a failure at this point.

00:20:35,720 --> 00:20:41,490
Typescript took a totally different approach to the problem and worked completely in JavaScript

00:20:41,490 --> 00:20:48,740
and I think you know, solved it in a way that is satisfying many people, so, if you have

00:20:48,740 --> 00:20:52,250
not been using typescript, like please check it out.

00:20:52,250 --> 00:20:55,889
I want this thing to do typescript, because I like it.

00:20:55,889 --> 00:21:04,840
Also, I want to simplify the module system, so screw all this stuff about how Node modules

00:21:04,840 --> 00:21:06,429
work, and that.

00:21:06,429 --> 00:21:10,470
I can't be compatible with Node, like otherwise you end up building Node.

00:21:10,470 --> 00:21:14,460
There's no attempt at compatibility with existent software.

00:21:14,460 --> 00:21:17,730
This is mostly a thought expert, right.

00:21:17,730 --> 00:21:23,500
I think it would be cute if you just import via where the source code came from, as you

00:21:23,500 --> 00:21:25,260
do in the web, right?

00:21:25,260 --> 00:21:26,679
There's a source file there.

00:21:26,679 --> 00:21:30,129
You link to that source file and now you've linked it into your programme.

00:21:30,129 --> 00:21:32,990
If it is a relative, you electric do a relative include.

00:21:32,990 --> 00:21:37,520
You should obviously provide an extension.

00:21:37,520 --> 00:21:41,230
You might be wondering, "I don't want this source code changing out from under me, this

00:21:41,230 --> 00:21:42,350
seems fishy."

00:21:42,350 --> 00:21:44,960
Well, it won't.

00:21:44,960 --> 00:21:51,330
So the first time you do this, if you don't have the URL loaded, then it downloads it,

00:21:51,330 --> 00:21:53,360
and it caches it somewhere.

00:21:53,360 --> 00:21:56,649
And, then it never updates that again.

00:21:56,649 --> 00:21:59,159
When you run it again, it is still using the same code.

00:21:59,159 --> 00:22:07,499
However, you can do a --reload as you do in the browser - that's my Control R hand signal.

00:22:07,499 --> 00:22:14,649
It has a similar semantics where it will do a hard reload of all the cache files.

00:22:14,649 --> 00:22:19,100
And, yes, you can do vendoring and stuff by giving it a different place where it downloads

00:22:19,100 --> 00:22:21,409
these files.

00:22:21,409 --> 00:22:26,220
I think this is viable.

00:22:26,220 --> 00:22:34,659
Typescript compiler built into it, blah, blah, blah, Deno hooks into ... yes, so, I mean,

00:22:34,659 --> 00:22:39,049
typescript should work out the box, and obviously JavaScript should still work out of the box

00:22:39,049 --> 00:22:48,080
but that's trivial because typescript is a super set of JavaScript, and yes.

00:22:48,080 --> 00:22:53,870
At the moment, it its start-up time is slow at one second which is completely unacceptable.

00:22:53,870 --> 00:23:01,799
However, I'm working on using V8 snapshots to snapshot the entire compiler, and plus

00:23:01,799 --> 00:23:04,120
other optimisations that have to be done.

00:23:04,120 --> 00:23:07,860
I'm confident it can be improved greatly.

00:23:07,860 --> 00:23:14,730
And so, Deno also, I don't like shipping all of these files, I hate that, I think it should

00:23:14,730 --> 00:23:22,090
be a single executable, so it should be an executable that doesn't link to too many things

00:23:22,090 --> 00:23:26,830
so you can just download the executable and run it.

00:23:26,830 --> 00:23:31,429
And yes, just generally take advantage of the fact that we are in the future now, and

00:23:31,429 --> 00:23:33,160
things are great.

00:23:33,160 --> 00:23:43,740
In the build process in Node, there is a complicated set-up of defining require, requiring the

00:23:43,740 --> 00:23:48,740
files, build them in a bundle, but now we have parcel, which is really great, by the

00:23:48,740 --> 00:23:55,860
way, so, what I can do is I can write kind of a normal Node programme structure to be

00:23:55,860 --> 00:24:04,440
the internal systems of Deno and then run Parcel on it, use it, and that will use Node's

00:24:04,440 --> 00:24:10,129
module resolution scheme and stuff but now I have a single bundled JavaScript file and

00:24:10,129 --> 00:24:12,110
I can dump that into V8.

00:24:12,110 --> 00:24:17,450
That makes the whole process of building this thing much simpler.

00:24:17,450 --> 00:24:23,620
Yes, and, great infrastructure exists now in native code, right?

00:24:23,620 --> 00:24:26,200
Part of Node was writing a web server.

00:24:26,200 --> 00:24:29,940
We spent a lot of time on the HTTP parser.

00:24:29,940 --> 00:24:31,129
There's no need to do that.

00:24:31,129 --> 00:24:33,460
That's done at this point.

00:24:33,460 --> 00:24:40,429
If this ends up being Go, then you link into the HTTP routines which are super good or

00:24:40,429 --> 00:24:49,149
maybe use Rust or C++, and, in the situation, there are easy ways to link into high-level

00:24:49,149 --> 00:24:58,639
code, high-level native code these days, and I think that that really ease s the job of

00:24:58,639 --> 00:25:02,070
this thing.

00:25:02,070 --> 00:25:05,500
Yeah.

00:25:05,500 --> 00:25:11,119
And so miscellaneous things like just die immediately when you have an unhandled promise.

00:25:11,119 --> 00:25:17,640
Who has ever wanted to, "Maybe I will add a catch handler later?

00:25:17,640 --> 00:25:19,990
I don't want this to die immediately."

00:25:19,990 --> 00:25:25,200
No, it should die as soon as it gets an error.

00:25:25,200 --> 00:25:30,159
Should support top-level - but it's not hard.

00:25:30,159 --> 00:25:32,960
And be browser compatible.

00:25:32,960 --> 00:25:40,100
In Node, I remember thinking like window is a really dumb variable name for the global

00:25:40,100 --> 00:25:41,559
scope.

00:25:41,559 --> 00:25:45,309
It is not a window, it should be called "global".

00:25:45,309 --> 00:25:47,710
Yes, I don't know.

00:25:47,710 --> 00:25:52,330
That was a mistake because now we have this whole, like, incompatibility issue with the

00:25:52,330 --> 00:25:54,419
browser.

00:25:54,419 --> 00:26:00,580
Where Deno with overlap with the browser, it should should use the browser semantics,

00:26:00,580 --> 00:26:05,370
the browser functions, and what not.

00:26:05,370 --> 00:26:07,289
Check it out maybe.

00:26:07,289 --> 00:26:08,289
I don't know.

00:26:08,289 --> 00:26:09,289
It is a prototype.

00:26:09,289 --> 00:26:16,690
It was just - yes, I think I'm mildly happy with it so far.

00:26:16,690 --> 00:26:17,759
Yes.

00:26:17,759 --> 00:26:24,340
If you have any comments or questions, I guess you can't ask me now, but please email me,

00:26:24,340 --> 00:26:33,580
and, yeah, first person to implement an HTTP server gets a star!

00:26:33,580 --> 00:26:34,929
I still have three minutes left.

00:26:34,929 --> 00:26:37,070

YouTube URL: https://www.youtube.com/watch?v=M3BM9TB-8yA


