Title: Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018
Publication date: 2018-06-21
Playlist: JSConf EU 2018
Description: 
	Most JavaScript developers are probably familiar with the event loop. It’s how JavaScript handles I/O events without blocking, even though it’s single-threaded. Event callbacks are added to the task queue. The browser then takes a callback from the queue and runs it from start to finish. Then it decides to either repaint or run another callback. Simple, right?

But what about web workers? And promises? And what happens when your JavaScript isn’t running in a browser? In this talk, we’ll look at how multi-threaded event loops work, how promises differ from other callbacks, and what goes on in the Node event loop.

OMG JSConf EU is coming back in 2019 https://2019.jsconf.eu/
Captions: 
	00:00:09,700 --> 00:00:13,340
Hi, I flew in from Australia the day before yesterday.

00:00:13,350 --> 00:00:19,990
I'm not saying that I'm the most jet lagged person here, but I would appreciate it if

00:00:19,990 --> 00:00:22,699
you could all just put in a little bit of effort to laugh at my jokes.

00:00:22,699 --> 00:00:25,630
That would really make things easier for me!

00:00:25,630 --> 00:00:29,650
So, the event loop.

00:00:29,650 --> 00:00:35,140
A couple of years back, here at this very conference, a guy by the name of Phil Roberts

00:00:35,140 --> 00:00:40,030
did a talk called "What the heck is the event loop anyway?"

00:00:40,030 --> 00:00:43,790
If you haven't seen it, I highly recommend you check it out.

00:00:43,790 --> 00:00:46,120
It is on the JSConf YouTube chapel.

00:00:46,120 --> 00:00:50,370
It is pretty fucking exciting because it catches on fire!

00:00:50,370 --> 00:00:52,710
In case you haven't seen it, though.

00:00:52,710 --> 00:00:57,800
It is an overview of the event loop, the different components, and how they work together.

00:00:57,800 --> 00:01:01,590
If you haven't seen it, we will do a quick overview of the things that are relevant for

00:01:01,590 --> 00:01:08,049
today, and then we are going to do a deep dive into specific parts of the event loop.

00:01:08,049 --> 00:01:15,390
So, you can think of the event loop as, like, the main function of the browser.

00:01:15,390 --> 00:01:17,369
It's just an infinite loop.

00:01:17,369 --> 00:01:22,810
It's going to grab a task off the task queue, and it's going to run that task.

00:01:22,810 --> 00:01:26,409
Which is great, but what is a task?

00:01:26,409 --> 00:01:31,690
So a task is how JavaScript gets run.

00:01:31,690 --> 00:01:37,689
If we have a bit of a script like this, we can see JavaScript in there.

00:01:37,689 --> 00:01:42,539
The browser will parse this script tag and create the task.

00:01:42,539 --> 00:01:45,329
So the code with the dark background is going to be a task.

00:01:45,329 --> 00:01:49,030
When it gets run, it's going to create a variable, it's going to do something, and it's going

00:01:49,030 --> 00:01:56,749
to register this event listener, and, then, whenever the browser gets a keydown event,

00:01:56,749 --> 00:01:59,529
the bit of blue is going to run as a task.

00:01:59,529 --> 00:02:05,209
Every bit of JavaScript that runs as a task could be a script or could be a callback.

00:02:05,209 --> 00:02:06,610
What does execute task do?

00:02:06,610 --> 00:02:08,240
It runs the code.

00:02:08,240 --> 00:02:09,890
What about the taskQueue.

00:02:09,890 --> 00:02:16,340
That's what we are going to look at today.

00:02:16,340 --> 00:02:22,270
We are going to look at taskQueues in the context of browsers, and look at Node, and

00:02:22,270 --> 00:02:25,769
we are going to have a real quick look at web workers.

00:02:25,769 --> 00:02:26,769
Constitutional.

00:02:26,769 --> 00:02:35,120
So what is a taskQueue and what is it for?

00:02:35,120 --> 00:02:38,120
It's where your code goes, where your JavaScript goes while it's waiting to execute.

00:02:38,120 --> 00:02:44,610
So, like before, we could parse a script tag, we could have callback on a click event, we

00:02:44,610 --> 00:02:48,780
could have a callback on a set time out.

00:02:48,780 --> 00:02:53,080
They're going to go into our queue there, and they're going to get executed.

00:02:53,080 --> 00:02:57,730
The important thing is that it is a queue, so things are going to get executed in the

00:02:57,730 --> 00:03:02,760
order that they arrive - first in, first out - and the other important thing is that a

00:03:02,760 --> 00:03:05,010
task is going to run from start to finish.

00:03:05,010 --> 00:03:06,629
There is no interrupted JavaScript.

00:03:06,629 --> 00:03:11,080
You don't have to worry about concurrency, locking, or any of that rubbish.

00:03:11,080 --> 00:03:13,170
It is super easy.

00:03:13,170 --> 00:03:14,170
Cool.

00:03:14,170 --> 00:03:15,690
That's our event loop.

00:03:15,690 --> 00:03:21,040
It turns out, though, it's a little bit more complicated than that.

00:03:21,040 --> 00:03:25,340
You see, the taskQueue works in conjunction with the rendering pipeline.

00:03:25,340 --> 00:03:29,950
The rendering pipeline is what it responsible for painting things in the browser window,

00:03:29,950 --> 00:03:34,719
so you make changes to the DOM, you update your style, and then the rendering pipeline

00:03:34,719 --> 00:03:37,769
runs and shows it on the screen.

00:03:37,769 --> 00:03:41,200
So, the webbed pipeline can run after a task finishes.

00:03:41,200 --> 00:03:48,030
The task finishes, the rendering pipeline can run, but browsers are pretty clever, right?

00:03:48,030 --> 00:03:53,700
They don't like to do work that they don't have to do, and there is really no point running

00:03:53,700 --> 00:03:58,780
the rendering pipeline unless the screen's about to refresh, so your average screen refresh

00:03:58,780 --> 00:04:07,090
s 60 times a second, once every 16 milliseconds, so, if we run a task, the rendering pipeline

00:04:07,090 --> 00:04:09,879
is going to wait that 16 milliseconds before it runs.

00:04:09,879 --> 00:04:13,269
If it is not obvious, this is the slowed down version.

00:04:13,269 --> 00:04:17,609
It is turns out it is hard to see, at 60 frames a second.

00:04:17,609 --> 00:04:23,330
Sitting around doing nothing all that time is a bit of a waste, so, in reality, the browser's

00:04:23,330 --> 00:04:27,150
going to run a where did you go of tasks, and then run the rendering pipeline.

00:04:27,150 --> 00:04:33,100
The important thing is that the rendering pipeline can't run until the task finishes.

00:04:33,100 --> 00:04:39,449
If you've got a task that takes a really long time, the rendering pipeline has to wait.

00:04:39,449 --> 00:04:41,940
A couple of milliseconds here and there isn't going to matter.

00:04:41,940 --> 00:04:48,919
If you take tasks that take a lot more than 16 milliseconds, your web page is going to

00:04:48,919 --> 00:04:53,310
start dropping frames and start running like this.

00:04:53,310 --> 00:04:57,590
If you do have long-running tasks, you can split them up, so you can create new tasks

00:04:57,590 --> 00:04:59,910
using something like setTimeout.

00:04:59,910 --> 00:05:07,919
You can use would be workers because that's what they are for.

00:05:07,919 --> 00:05:12,050
So now, an event loop looks a bit like this.

00:05:12,050 --> 00:05:18,430
We're going to run an infinite loop, pick a task off the task cube, and run that task,

00:05:18,430 --> 00:05:21,570
and then, if we're ready to repaint, we will repaint.

00:05:21,570 --> 00:05:24,990
That's cool, right?

00:05:24,990 --> 00:05:34,930
It turns out, it's more complicated than that, if you have a look at the spec, which I'm

00:05:34,930 --> 00:05:43,240
sure we do in our spare time, you will see that an event loop it have one or more taskQueues.

00:05:43,240 --> 00:06:06,350
At this point, what I will do is I will have a look at an query ... . [Sound distorted].

00:06:06,350 --> 00:06:16,010
So, instead, we are going to look at a theoretical browser with multiple taskQueue s.

00:06:16,010 --> 00:06:20,629
To be clear, this is the example that is give in the spec of having multiple taskQueues,

00:06:20,629 --> 00:06:26,919
so I didn't make it - somebody else made it up.

00:06:26,919 --> 00:06:32,040
This browser prioritises mouse-click event.

00:06:32,040 --> 00:06:35,460
It has got two taskQueues there.

00:06:35,460 --> 00:06:40,800
One where our mouse click is going to go and another queue where everything else goes.

00:06:40,800 --> 00:06:48,449
This is really simple, it's like the business class line at the airport.

00:06:48,449 --> 00:06:54,349
It's going to run all of the tasks in the mouse-click queue, and then the tasks in the

00:06:54,349 --> 00:06:55,349
other queue.

00:06:55,349 --> 00:07:00,199
It doesn't affect the rendering pipeline which will run after each task in it wants to.

00:07:00,199 --> 00:07:01,379
Super simple.

00:07:01,379 --> 00:07:05,139
It doesn't have to be like that, right?

00:07:05,139 --> 00:07:09,659
The browsers can actually execute the queues in any order they like, so we could have taken

00:07:09,659 --> 00:07:15,620
two off the mouse click queue and three off the other queue - whatever we like.

00:07:15,620 --> 00:07:18,000
The queues can be executed in any order.

00:07:18,000 --> 00:07:21,920
But, the queues still do have to be queues.

00:07:21,920 --> 00:07:25,349
So the tasks have to be executed in the order that they arrive.

00:07:25,349 --> 00:07:31,050
First in, first out.

00:07:31,050 --> 00:07:33,780
All of our mouse-click events have to go in that queue.

00:07:33,780 --> 00:07:39,870
Node uses a specific queue for timeout event, so all of the timeout events have to go in

00:07:39,870 --> 00:07:41,370
that queue.

00:07:41,370 --> 00:07:47,530
So this is how our event loop looks now: we've got an infinite loop, we are going to pick

00:07:47,530 --> 00:07:50,590
a queue, grab a task, and then it's time to repaint, and we will repaint.

00:07:50,590 --> 00:07:52,340
This is still straightforward, right?

00:07:52,340 --> 00:08:02,009
It turns out, it's a little bit more complicated than that, though.

00:08:02,009 --> 00:08:06,020
We also have microtasks.

00:08:06,020 --> 00:08:07,590
What is a microtask?

00:08:07,590 --> 00:08:12,840
For the purposes of this 20-minute talk, a microtask is a promise.

00:08:12,840 --> 00:08:17,849
There are other things that generate microtasks but 99.9 per cent of things that you do it's

00:08:17,849 --> 00:08:19,919
going to be promises.

00:08:19,919 --> 00:08:25,199
So our microtask queue is in yellow there next to the rendering pipeline, and we have

00:08:25,199 --> 00:08:27,849
a bit of code, it's going to run.

00:08:27,849 --> 00:08:31,729
We have a promise that resolves, it goes in the microtask queue.

00:08:31,729 --> 00:08:35,779
Now, the microtask queue has a couple of special properties.

00:08:35,779 --> 00:08:44,440
First of all, it runs after every task, so you finish a task, then you run the microtask

00:08:44,440 --> 00:08:45,440
queue.

00:08:45,440 --> 00:08:50,200
Even if the rendering pipeline would like it run, it has to wait until the microtask

00:08:50,200 --> 00:08:52,430
queue finishes.

00:08:52,430 --> 00:08:57,200
If we have multiple tasks in the microtask queue, they're all going to run.

00:08:57,200 --> 00:09:03,350
If we add more while we are running it, those will have to be run too, so this has some

00:09:03,350 --> 00:09:06,050
important implications for how things run.

00:09:06,050 --> 00:09:11,890
Let's have a quick look at the difference between how tasks run and how microtasks run.

00:09:11,890 --> 00:09:17,079
So this bit of code generates tasks.

00:09:17,079 --> 00:09:22,420
I click the button, it's going to principle out the number of tasks that it has run, and

00:09:22,420 --> 00:09:25,490
then it's going to generate another task, which is going to print out the number of

00:09:25,490 --> 00:09:28,810
tasks that is run so on, and so order infinitely.

00:09:28,810 --> 00:09:35,450
We can see it running, counting tasks, everything is great, I can select text, I can click stop.

00:09:35,450 --> 00:09:41,700
I can't click start again, because I didn't implement that.

00:09:41,700 --> 00:09:49,890
But, if we look at the same thing with microtasks, things are a bit different.

00:09:49,890 --> 00:09:54,209
So, if I start, so this is the same code, right?

00:09:54,209 --> 00:09:58,560
It is a coding and microtask, which is going to print out the number of microtasks that

00:09:58,560 --> 00:10:03,010
have run, and then create another microtask, and keep looping, the same as the set setTimeout

00:10:03,010 --> 00:10:04,420
but with promises.

00:10:04,420 --> 00:10:13,100
If I click start promising, we can see everything has immediately gone to shit.

00:10:13,100 --> 00:10:17,560
The button has clicked but it hasn't unclicked, right?

00:10:17,560 --> 00:10:20,730
The cursor, which you can't see there, it's still the little hand.

00:10:20,730 --> 00:10:23,050
I can't select text.

00:10:23,050 --> 00:10:27,280
I definitely can't click stop, which wouldn't have helped because I didn't implement it

00:10:27,280 --> 00:10:30,810
anyway, it's like I knew what was going to happen.

00:10:30,810 --> 00:10:33,990
This page is kaput.

00:10:33,990 --> 00:10:40,839
If we wait a little bit longer, Chrome will realise and tell us tell us but I don't have

00:10:40,839 --> 00:10:41,839
that kind of time.

00:10:41,839 --> 00:10:42,839
What happened there?

00:10:42,839 --> 00:10:47,440
Exactly like we saw in the example, we are stuck, just dealing with the microtask queue.

00:10:47,440 --> 00:10:50,740
So the rest of the event loop is blocked, we can't re-render the page, we can't do anything

00:10:50,740 --> 00:10:54,550
else, we are stuck in the event loop - stuck in the microtask queue.

00:10:54,550 --> 00:10:55,910
So, yes.

00:10:55,910 --> 00:10:56,910
Cool.

00:10:56,910 --> 00:11:01,740
This is how our event loop looks now.

00:11:01,740 --> 00:11:02,800
It's an infinite loop.

00:11:02,800 --> 00:11:08,990
We are going to pick a queue, a task off that queue, and run it.

00:11:08,990 --> 00:11:12,180
As long as there are microtasks to round, we're going to do microtasks, and, then.

00:11:12,180 --> 00:11:16,460
Would it be fair to say that is done, if it is time to repaint, we will repaint.

00:11:16,460 --> 00:11:24,190
Cool, so this is starting to look a little bit complicated but it turns out it's just

00:11:24,190 --> 00:11:27,380
a little bit more complicated than this.

00:11:27,380 --> 00:11:33,450
We also have the animation frame callback queue which I'm going to call the animation

00:11:33,450 --> 00:11:38,410
queue, because, if I keep saying animation frame callback queue, this talk won't get

00:11:38,410 --> 00:11:40,649
finished in time for lunch!

00:11:40,649 --> 00:11:46,920
So you can add things to the animation queue by calling request animation frame and passing

00:11:46,920 --> 00:11:48,840
a callback.

00:11:48,840 --> 00:11:49,840
Why would one do such a thing?

00:11:49,840 --> 00:11:56,829
I'm using it here to run the animation of the browser running into the browser right-hand

00:11:56,829 --> 00:11:58,949
window into the pipeline.

00:11:58,949 --> 00:12:06,020
I have my browser window and pipeline, and I remove a class which resets the frame, and

00:12:06,020 --> 00:12:16,620
then I add the slide class to the window which gives it a -

00:12:16,620 --> 00:12:20,600
which makes is slide down, through the magic of transitions.

00:12:20,600 --> 00:12:26,590
If I did it like this, as I said before, browsers are clever, and they like to be helpful.

00:12:26,590 --> 00:12:32,000
If I wrote this code, the browser would look at it and say you've removed the class, and

00:12:32,000 --> 00:12:34,680
then you've added the same class back again.

00:12:34,680 --> 00:12:37,560
That's the same as doing nothing.

00:12:37,560 --> 00:12:40,180
So, let's just do nothing.

00:12:40,180 --> 00:12:46,690
Instead where I have to make sure that things occur after - so to do one, I need the browser,

00:12:46,690 --> 00:12:49,279
the window to refresh, and then I need to do the next thing.

00:12:49,279 --> 00:12:51,370
We have a look at how that works.

00:12:51,370 --> 00:12:56,670
We've got our animation queue there in green beside the rendering pipeline.

00:12:56,670 --> 00:13:02,850
I've got my scripts running, and I call request animation frame which adds something to the

00:13:02,850 --> 00:13:04,030
animation queue.

00:13:04,030 --> 00:13:09,250
You can see it's going to sit there, and nothing's going to happen until we're ready to repaint,

00:13:09,250 --> 00:13:15,529
and then we will run the animation queue, and then we will repaint the browser.

00:13:15,529 --> 00:13:23,290
Like the microtask queue, the animation queue has a couple of special properties.

00:13:23,290 --> 00:13:28,350
If I have multiple things in the animation queue when it is ready to run, I'm going to

00:13:28,350 --> 00:13:31,320
run all those things.

00:13:31,320 --> 00:13:36,940
But, if I add more things to the animation queue while it's running, I'm not going to

00:13:36,940 --> 00:13:38,690
run those guys.

00:13:38,690 --> 00:13:42,449
The reason for that is that, if you're creating animations, you want to say this is what I

00:13:42,449 --> 00:13:45,980
want to do in this frame, and then you're going to set up what is going to happen in

00:13:45,980 --> 00:13:48,350
the next frame but you don't want run it, right?

00:13:48,350 --> 00:13:52,880
You want to wait until the window has refreshed.

00:13:52,880 --> 00:13:54,160
Cool.

00:13:54,160 --> 00:13:58,279
So, this is what our event loop looks like now.

00:13:58,279 --> 00:13:59,560
It's an infinite loop.

00:13:59,560 --> 00:14:01,300
We're going to pick a queue.

00:14:01,300 --> 00:14:05,270
We're going to grab the first task off that queue, and we're going to run the task.

00:14:05,270 --> 00:14:08,639
Then, as long as there are microtasks, we're going to run all those.

00:14:08,639 --> 00:14:14,190
Then, if we're ready to repaint, we're going to grab the animation tasks that are currently

00:14:14,190 --> 00:14:19,330
in the queue, and we're going to run all of those, and then we're going to repaint.

00:14:19,330 --> 00:14:23,440
And that is as complicated as it gets.

00:14:23,440 --> 00:14:26,790
But, what about node?

00:14:26,790 --> 00:14:30,690
First of all, good news.

00:14:30,690 --> 00:14:33,089
Node is a lot simpler than a browser.

00:14:33,089 --> 00:14:36,050
It has no script-parsing events.

00:14:36,050 --> 00:14:41,170
You're not picking JavaScript out of HTML all over the place, you just give it a JavaScript

00:14:41,170 --> 00:14:43,180
file and it runs it.

00:14:43,180 --> 00:14:46,899
There is no users clicking on shit all over the place.

00:14:46,899 --> 00:14:52,260
You don't have to worry about animation framework callbacks because there's no rendering pipeline.

00:14:52,260 --> 00:14:59,079
There is also another — important difference with Node: the browser event loop is like

00:14:59,079 --> 00:15:00,079
a merry-go-round.

00:15:00,079 --> 00:15:03,830
It just keeps going round and round and round.

00:15:03,830 --> 00:15:06,790
The Node event loop, it's more like a roller coaster.

00:15:06,790 --> 00:15:12,310
It is going to run through one loop, and there's more stuff to do, it will run through another

00:15:12,310 --> 00:15:13,730
loop.

00:15:13,730 --> 00:15:16,420
Once it's done, that's it.

00:15:16,420 --> 00:15:17,720
It's done.

00:15:17,720 --> 00:15:26,610
So, the Node event loop: Node has three queues that are interesting enough to talk about

00:15:26,610 --> 00:15:27,610
today.

00:15:27,610 --> 00:15:34,290
It's got one queue for all of your event callbacks, so your XHR requests, your disk reads and

00:15:34,290 --> 00:15:38,290
writes and that stuff will go in the first queue.

00:15:38,290 --> 00:15:40,730
They're called phases in nodes.

00:15:40,730 --> 00:15:44,579
The second phase is the check phase.

00:15:44,579 --> 00:15:49,870
And the third phase is your timers this that's all of your timers for callback and set interval

00:15:49,870 --> 00:15:52,430
will go into that third queue.

00:15:52,430 --> 00:15:59,880
Node is going to run everything in the event callback queue; it's going to run then everything

00:15:59,880 --> 00:16:00,899
in the check queue.

00:16:00,899 --> 00:16:04,120
Once that is done, it's going to run everything in the timer queue.

00:16:04,120 --> 00:16:08,410
Then, if there is more stuff, it will loop back around and run through the queues again.

00:16:08,410 --> 00:16:14,370
As soon as there is no task in any queues, and there are no event waiting anywhere, it

00:16:14,370 --> 00:16:16,230
will finish.

00:16:16,230 --> 00:16:20,699
It will end.

00:16:20,699 --> 00:16:25,089
So, how do you add stuff to the check phase?

00:16:25,089 --> 00:16:30,550
You can add things to the check phase queue by calling setImmediate and parsing a callback.

00:16:30,550 --> 00:16:36,110
setImmediate is the same as setTimeout with a time of zero, but because of the way the

00:16:36,110 --> 00:16:41,940
queues work, if you call setTimeout with a time of zero, and setImmediate, your setImmediate

00:16:41,940 --> 00:16:45,540
is going to run first.

00:16:45,540 --> 00:16:51,360
Node also has promises.

00:16:51,360 --> 00:16:56,980
Just like the browser, and Node promises work just the same as browser promises — after

00:16:56,980 --> 00:17:03,970
each task finishes, we will run the promise microtask queue.

00:17:03,970 --> 00:17:09,280
Node also has another micro task queue which is the nextTick queue.

00:17:09,280 --> 00:17:14,680
You can parse a callback.

00:17:14,680 --> 00:17:19,320
It works just the same.

00:17:19,320 --> 00:17:21,150
There's nothing really interesting there.

00:17:21,150 --> 00:17:28,481
The major difference is, if you have both promises and nextTick callbacks becomes all

00:17:28,481 --> 00:17:33,850
your nextTick callbacks will run before your promises, but that's pretty much it.

00:17:33,850 --> 00:17:39,980
The only new things, different things in Node are setImmediate and process.next tick.

00:17:39,980 --> 00:17:54,160
Pro why are they named like that?

00:17:54,160 --> 00:17:56,180
It turns out naming things are hard.

00:17:56,180 --> 00:17:59,930
You guys all know the two hard problems in computer signs, right?

00:17:59,930 --> 00:18:03,980
Validation, and naming things, and off by one errors.

00:18:03,980 --> 00:18:09,000
So this is our Node event loop.

00:18:09,000 --> 00:18:11,510
It's only going to run while there are still task.

00:18:11,510 --> 00:18:17,290
It's going to pick a queue, and then, while that queue has more tasks, it's going to grab

00:18:17,290 --> 00:18:23,210
the next task in that queue, it's going to run that task, and then while the next tick

00:18:23,210 --> 00:18:28,830
queue has more tasks, it's going to run all the next tick queue tasks, and then, while

00:18:28,830 --> 00:18:34,560
the promise queue has more tasks, it's going to do the promises.

00:18:34,560 --> 00:18:37,500
So that just leaves web workers.

00:18:37,500 --> 00:18:45,200
Anyone who is not familiar with Australian wildlife, this is a redback spider.

00:18:45,200 --> 00:18:47,300
Unlike most Australian wildlife, they're not that dangerous.

00:18:47,300 --> 00:18:52,920
Nobody has died from a redback spider bite since the 1950s.

00:18:52,920 --> 00:18:56,260
Probably don't get bitten by one, though.

00:18:56,260 --> 00:19:07,970
So web workers: web workers turn out to be dead simple.

00:19:07,970 --> 00:19:11,120
Each web worker run in its own thread.

00:19:11,120 --> 00:19:18,510
It has got its own event loan, got its own stack, task queue — everything just runs

00:19:18,510 --> 00:19:21,220
on its own.

00:19:21,220 --> 00:19:24,940
It's even easier than Node.

00:19:24,940 --> 00:19:26,270
So there are no script tags.

00:19:26,270 --> 00:19:28,410
Again, you parse in a JavaScript file.

00:19:28,410 --> 00:19:31,840
There are no user interactions.

00:19:31,840 --> 00:19:37,370
Web workers aren't allowed to manipulate the DOM so you don't have to worry about any animation

00:19:37,370 --> 00:19:41,980
frames or anything like that.

00:19:41,980 --> 00:19:51,310
If we look at a demo, we can generate a task, call a setTimeout, make HSR requests, we can

00:19:51,310 --> 00:19:59,170
send and receive post-message events, so, post-message is how your web worker communicates

00:19:59,170 --> 00:20:02,840
with the browser window.

00:20:02,840 --> 00:20:04,650
And we can make promises.

00:20:04,650 --> 00:20:07,730
It's — that's it.

00:20:07,730 --> 00:20:09,310
It's just really easy.

00:20:09,310 --> 00:20:10,320
Yes.

00:20:10,320 --> 00:20:16,420
So, that's a event — that's the event loop.

00:20:16,420 --> 00:20:24,440
Things to remember: long-running tasks will make your page run like a wonky cat.

00:20:24,440 --> 00:20:29,440
Promises and nextTick tasks can make it run like a dead cat.

00:20:29,440 --> 00:20:34,590
Make sure you break your tasks up into small pieces and don't have infinitely recursive

00:20:34,590 --> 00:20:37,800
promises and nextTick tasks.

00:20:37,800 --> 00:20:42,070
Node is a bit different to the browser.

00:20:42,070 --> 00:20:45,130
It's going to run through the event loop only as long as there are things to do.

00:20:45,130 --> 00:20:52,750
It has got those three specific tasks, and it's got setImmediate and process.nextTick.

00:20:52,750 --> 00:20:58,390
Web workers do their own thing, in their own event loop, and completely separate from anything

00:20:58,390 --> 00:21:01,320
else that is going on.

00:21:01,320 --> 00:21:07,810
Remember, the event loop is more exciting than you can possibly have imagined!

00:21:07,810 --> 00:21:09,220
Thank you.

00:21:09,220 --> 00:21:09,919

YouTube URL: https://www.youtube.com/watch?v=u1kqx6AenYw


