Title: Computer, build me an app - Rich Harris - JSConf EU 2018
Publication date: 2018-06-18
Playlist: JSConf EU 2018
Description: 
	Frameworks exist because writing maintainable apps in vanilla JavaScript is hard. But frameworks aren’t free: downloading and parsing those extra bytes slows things up, just when your users are deciding whether to stick around.

Instead of choosing between bulky frameworks and maintainability nightmares, what if we could tell the computer ‘here are the blueprints, now you write the code’? In this talk we’ll discover a new breed of tools, such as Svelte, that let you do exactly that.

OMG JSConf EU is coming back in 2019 https://2019.jsconf.eu/
Captions: 
	00:00:10,130 --> 00:00:15,050
Many moons ago, the wisest of the JavaScript elders came down from the mountain and said,

00:00:15,050 --> 00:00:18,170
I have created J query.

00:00:18,170 --> 00:00:20,520
And the villagers said, JQuery?

00:00:20,520 --> 00:00:23,000
The actor from zombie.

00:00:23,000 --> 00:00:26,920
And he said, no, it is not a man, it is magic.

00:00:26,920 --> 00:00:31,660
We will tame the browser gods.

00:00:31,660 --> 00:00:38,560
And the villagers were the browser gods were capricious and had misery on the lands.

00:00:38,560 --> 00:00:45,750
And re-plowed the fields, and at the time of the next harvest, they tasted sweet and

00:00:45,750 --> 00:00:48,110
AJAXy.

00:00:48,110 --> 00:00:54,960
And there were conferences and that was the end of the first JavaScript era.

00:00:54,960 --> 00:00:56,830
The tide came and went.

00:00:56,830 --> 00:00:58,470
The moon rose and fell.

00:00:58,470 --> 00:00:59,470
Years passed.

00:00:59,470 --> 00:01:05,210
And while JQuery was still a dominant religion, some were fearful it was not powerful enough

00:01:05,210 --> 00:01:11,320
for the elaborate designs of the modern age.

00:01:11,320 --> 00:01:17,420
And one came from Zuckerbergia and said, you're all doing it wrong.

00:01:17,420 --> 00:01:23,770
These primitive incantations do not befit our modern age of science and technology.

00:01:23,770 --> 00:01:28,289
Look at the wretched structures, I fear for my safety.

00:01:28,289 --> 00:01:35,670
In Zuckerbergia we make not mud huts, but magnificent towers not with magic, but with

00:01:35,670 --> 00:01:36,670
machines.

00:01:36,670 --> 00:01:38,369
Come, let me show you.

00:01:38,369 --> 00:01:42,219
And the villagers looked upon the machines and they liked not what they saw.

00:01:42,219 --> 00:01:46,570
The traveler was cast out as a heretic.

00:01:46,570 --> 00:01:50,840
And yet some followed these machines and helped to meet their ambitions.

00:01:50,840 --> 00:01:59,900
And the heretics, and the heresy became the new thing and that was the second era of JavaScript.

00:01:59,900 --> 00:02:03,649
And I'm here to talk about the third era.

00:02:03,649 --> 00:02:11,180
I'm Rich Harris from the "New York Times," and this is called computer, build me an app.

00:02:11,180 --> 00:02:17,069
You probably think I'm going to talk about using the platform.

00:02:17,069 --> 00:02:21,750
Web performance advocates are saying we should use the platform, it's interpreted as don't

00:02:21,750 --> 00:02:23,530
use React.

00:02:23,530 --> 00:02:26,150
And there's been this rather contentious debate between the two sides.

00:02:26,150 --> 00:02:28,810
And the trouble is, they're both kind of right.

00:02:28,810 --> 00:02:29,950
They're talking past each other.

00:02:29,950 --> 00:02:35,010
It can simultaneously be true that abusing frameworks leads to a degraded user experience,

00:02:35,010 --> 00:02:39,980
and the DOM APIs are hot garbage.

00:02:39,980 --> 00:02:43,260
I wanted to find a solution to the problem.

00:02:43,260 --> 00:02:47,300
In New York, you can attend Brooklyn JS and the other meetups.

00:02:47,300 --> 00:02:53,720
And it stands for Jed Schmidt, the co founder of the meetup.

00:02:53,720 --> 00:02:57,240
He's a brilliant programmer and an all around good guy.

00:02:57,240 --> 00:03:05,050
And he was explaining his vision of a next generation user and space framework.

00:03:05,050 --> 00:03:06,860
And he said something along these lines.

00:03:06,860 --> 00:03:11,851
The directed graphs, but the run time is to DOM.

00:03:11,851 --> 00:03:16,340
Writing an app should just be writing a graph and the compiler would figure out where the

00:03:16,340 --> 00:03:21,620
bipoles are and render the code to make sure that relationship stays consistent across

00:03:21,620 --> 00:03:22,620
states.

00:03:22,620 --> 00:03:24,600
I don't have a computer science background.

00:03:24,600 --> 00:03:29,380
And to be honest, I was in at the time, it was gibberish.

00:03:29,380 --> 00:03:32,420
One word stuck in my head, compiler.

00:03:32,420 --> 00:03:34,350
And it led to an epiphany.

00:03:34,350 --> 00:03:40,120
Frameworks are not tools for the code, they exist in your mind.

00:03:40,120 --> 00:03:46,430
They help write better code, but they can help you structure your thoughts and express

00:03:46,430 --> 00:03:47,510
them.

00:03:47,510 --> 00:03:50,040
What if the framework didn't run in the browser at all?

00:03:50,040 --> 00:03:53,310
What if it was a compiler.

00:03:53,310 --> 00:03:56,460
We need to understand how frame works work.

00:03:56,460 --> 00:03:59,260
Before I go on, there's something I need to make totally clear.

00:03:59,260 --> 00:04:00,820
I'm going to criticize React.

00:04:00,820 --> 00:04:04,880
And I need you all to know it comes from a place of love.

00:04:04,880 --> 00:04:07,120
It's a wonderful tool.

00:04:07,120 --> 00:04:12,400
It's like JQuery, Backbone and others that haven't just made life easier for people who

00:04:12,400 --> 00:04:17,819
use the tools, they changed the way the entire community thinks about solving the problem.

00:04:17,819 --> 00:04:21,180
But there's a tendency towards group think.

00:04:21,180 --> 00:04:28,940
And that React is the pinnacle and there's no further progress to be made.

00:04:28,940 --> 00:04:31,470
It looks like the maximum.

00:04:31,470 --> 00:04:36,690
This talk is talking about exploring this new one known territory.

00:04:36,690 --> 00:04:40,930
Now, the best thing that React did for the frontend community was to popularize the idea

00:04:40,930 --> 00:04:43,550
of state driven user interface.

00:04:43,550 --> 00:04:46,940
That was usually event driven.

00:04:46,940 --> 00:04:52,010
When the browser sees something happen, do these things.

00:04:52,010 --> 00:04:58,660
In the state driven world, you instead say this is how I want the user to see this is

00:04:58,660 --> 00:05:01,290
what I want the user to see for a given state.

00:05:01,290 --> 00:05:04,570
And you tell that to the framework and the framework communicates with the browser on

00:05:04,570 --> 00:05:06,310
your behalf.

00:05:06,310 --> 00:05:09,910
This is a very director and performant way of updating the DOM.

00:05:09,910 --> 00:05:13,440
But as you know from personal experience, it doesn't scale.

00:05:13,440 --> 00:05:17,400
Becomes too complex too quickly whereas this scales beautifully.

00:05:17,400 --> 00:05:23,870
The way that it does that, the paradigm today is the virtual DOM.

00:05:23,870 --> 00:05:27,810
Whenever your state changes, you reinvent your entire application and say, here you

00:05:27,810 --> 00:05:29,760
are, this is what the user should see.

00:05:29,760 --> 00:05:35,160
They compose the virtual DOM with the real DOM and figure out what it needs to bring

00:05:35,160 --> 00:05:36,760
the DOM up to date.

00:05:36,760 --> 00:05:42,030
And you hear people say that the virtual DOM is faster than the real DOM, which is complete

00:05:42,030 --> 00:05:43,030
bullocks.

00:05:43,030 --> 00:05:49,130
It is easier for the browser to go from the first step to the last step.

00:05:49,130 --> 00:05:50,710
Virtual DOM is pure overhead.

00:05:50,710 --> 00:05:55,280
We tolerate is because of the programming model that it enables.

00:05:55,280 --> 00:05:59,860
And could we achieve that without that in the middle?

00:05:59,860 --> 00:06:02,630
If so, the apps get leaner and faster.

00:06:02,630 --> 00:06:05,590
In other words, they would become svelte.

00:06:05,590 --> 00:06:08,419
Svelte is a real world.

00:06:08,419 --> 00:06:14,380
The Cambridge dictionary says it's attractively thin, stylish.

00:06:14,380 --> 00:06:28,150
Merriam Webster, suave, and urban dictionary, anything cool, hip or generally awesome.

00:06:28,150 --> 00:06:29,150
That was from 2005.

00:06:29,150 --> 00:06:31,620
I have no idea if kids are still saying that.

00:06:31,620 --> 00:06:34,300
Nevertheless, I will take it.

00:06:34,300 --> 00:06:42,420
Svelte works, and the compiler turns it into an AST.

00:06:42,420 --> 00:06:45,150
And this is svelte generated.

00:06:45,150 --> 00:06:50,280
That gives you a JavaScript class like any other that you can import into the application,

00:06:50,280 --> 00:06:57,520
give it something a render to and a tree of data and it does its thing.

00:06:57,520 --> 00:07:02,240
We now proceed to the live coding portion of the talk.

00:07:02,240 --> 00:07:08,990
So, I'm just writing bear with me.

00:07:08,990 --> 00:07:22,520
The demo gods are not on my side.

00:07:22,520 --> 00:07:34,081
Well, this is annoying.

00:07:34,081 --> 00:07:43,699
[ Laughter ] I have a big problem on my screen.

00:07:43,699 --> 00:07:53,160
Okay.

00:07:53,160 --> 00:08:02,620
Maybe.

00:08:02,620 --> 00:08:12,080
Yeah.

00:08:12,080 --> 00:08:49,930
I don't think so.

00:08:49,930 --> 00:08:59,390
>> Okay.

00:08:59,390 --> 00:09:27,770
[ Applause ] RICH: Okay.

00:09:27,770 --> 00:09:40,800
So, I've replaced the hard coded data with a variable.

00:09:40,800 --> 00:09:52,910
And if we have the DevTools, then we can manipulate the data using the component API.

00:09:52,910 --> 00:09:53,910
Like so.

00:09:53,910 --> 00:09:57,860
And we can put any JavaScript expression in these in these tags.

00:09:57,860 --> 00:10:00,120
So, we can do things like that.

00:10:00,120 --> 00:10:08,351
And the nice thing about using HTML is that you know what?

00:10:08,351 --> 00:10:15,820
I'm going to try to just do it all on this screen instead.

00:10:15,820 --> 00:10:20,060
Okay.

00:10:20,060 --> 00:10:30,520
So, a really important thing to know is this CSS is being inserted into the context of

00:10:30,520 --> 00:10:32,020
the component's markup.

00:10:32,020 --> 00:10:33,261
It's able to encapsulate it.

00:10:33,261 --> 00:10:39,730
It's added this computer generated class to the element and it's doing the same thing

00:10:39,730 --> 00:10:42,850
to the CSS class name down here.

00:10:42,850 --> 00:10:47,240
And you'll notice because it is generating a source map, we're able to see exactly where

00:10:47,240 --> 00:10:48,410
those styles came from.

00:10:48,410 --> 00:10:53,081
When you're building a big, complex app, it's incredibly useful to see where the CSS came

00:10:53,081 --> 00:10:54,730
from.

00:10:54,730 --> 00:10:59,570
That's often overlooked and it's a huge productivity win.

00:10:59,570 --> 00:11:11,459
And by analyzing the CSS markup, we can detect a new style sorry, I've just got to get back

00:11:11,459 --> 00:11:14,180
to the same place.

00:11:14,180 --> 00:11:16,750
Oh, my god, this is not on my way.

00:11:16,750 --> 00:11:22,760
I'm going to skip ahead to the next slide.

00:11:22,760 --> 00:11:31,610
We can add if any listeners in line on our elements.

00:11:31,610 --> 00:11:40,310
It might be.

00:11:40,310 --> 00:11:49,010
I don't know.

00:11:49,010 --> 00:11:51,910
Okay.

00:11:51,910 --> 00:11:57,860
I think I might skip some of the next parts of this because it's starting to get a little

00:11:57,860 --> 00:11:59,000
bit embarrassing.

00:11:59,000 --> 00:12:05,150
But we can what I wanted to show you is that we can start to do some nice, slick user interface

00:12:05,150 --> 00:12:06,150
things.

00:12:06,150 --> 00:12:07,930
Like some really effective custom transitions.

00:12:07,930 --> 00:12:14,670
What we're doing here is defining some CSS that's generated for a given moment when your

00:12:14,670 --> 00:12:18,959
component when your element is being transitioned into the DOM.

00:12:18,959 --> 00:12:24,070
And normally with animations and transitions, it's in a request animation callback.

00:12:24,070 --> 00:12:29,950
And that's less than ideal, it's a jank.

00:12:29,950 --> 00:12:40,500
And turns it into behind the scenes and they are more performant and kinder on your friends'

00:12:40,500 --> 00:12:41,500
battery.

00:12:41,500 --> 00:12:47,540
And we can get them to talk to each other in a sense.

00:12:47,540 --> 00:12:54,600
This is an application where we have some to dos that haven't been done and others that

00:12:54,600 --> 00:12:55,950
have been done.

00:12:55,950 --> 00:12:59,760
And if I click on the labels, it moves from one side to the other.

00:12:59,760 --> 00:13:03,080
Which is fine, but the human brain doesn't like that.

00:13:03,080 --> 00:13:07,540
It doesn't like it when objects disappear and reappear.

00:13:07,540 --> 00:13:11,870
It likes it when objects remain a sense of constancy.

00:13:11,870 --> 00:13:17,970
And we have helper transitions with this function, cross fade.

00:13:17,970 --> 00:13:28,140
And if I add those to my component.

00:13:28,140 --> 00:13:40,350
I this was fine an hour ago.

00:13:40,350 --> 00:13:45,830
[ Laughter ] Tell you what?

00:13:45,830 --> 00:13:49,880
I will Tweet out the slides as they are supposed to appear.

00:13:49,880 --> 00:13:51,570
Let's move on.

00:13:51,570 --> 00:13:55,570
And so, an important shift has happened here.

00:13:55,570 --> 00:14:01,190
In a very real sense, you're not writing the code behind your app.

00:14:01,190 --> 00:14:03,900
You are writing some instructions.

00:14:03,900 --> 00:14:21,300
And the browser, the compiler is generating the code for you.

00:14:21,300 --> 00:14:35,100
And this is because a lot of the code and I want [audio breaking up on Skype] the compiler.

00:14:35,100 --> 00:14:45,680
And it is why not use JSS?

00:14:45,680 --> 00:14:48,740
And I'm going to get, again, at this conference, and answer that.

00:14:48,740 --> 00:15:02,580
So, it still uses a language called HTML X, it's a super script of JavaScript.

00:15:02,580 --> 00:15:06,709
This is a nightmare for a compiler.

00:15:06,709 --> 00:15:16,180
In JSX, it's an element, component, text, an array of fragments containing all three.

00:15:16,180 --> 00:15:18,540
And the compiler can't do anything with that.

00:15:18,540 --> 00:15:22,220
It needs to know what the value of that expression is going to be.

00:15:22,220 --> 00:15:25,110
Which is why we need the virtual DOM machinery.

00:15:25,110 --> 00:15:31,850
Now, having said that, the Facebook team are working hard on this problem and just yesterday

00:15:31,850 --> 00:15:36,950
Dominik Galloway successfully completed a little experiment to get React server-side

00:15:36,950 --> 00:15:42,040
rendering in a similar compiled format.

00:15:42,040 --> 00:15:44,889
And React SSR is now as fast as svelte.

00:15:44,889 --> 00:15:48,980
And even though client side is a much were much harder problem, this is something you

00:15:48,980 --> 00:15:52,220
should be very excited about if you're a React user.

00:15:52,220 --> 00:15:58,720
Nevertheless, I prefer to use HTML based languages when I'm describing user interfaces because

00:15:58,720 --> 00:16:00,930
HTML is the language of the web.

00:16:00,930 --> 00:16:05,610
I don't need to worry about all of these others that JSS presents.

00:16:05,610 --> 00:16:11,680
And I also feel that using an HTML based language is more inclusive to the large number of developers

00:16:11,680 --> 00:16:17,010
who are simply more proficient with HTML and CSS than JavaScript.

00:16:17,010 --> 00:16:24,040
Now, am I the only person that's reached the conclusion that compilers are the next frameworks.

00:16:24,040 --> 00:16:29,160
This is a project for web components.

00:16:29,160 --> 00:16:36,100
Glimmer is an engine that compiles to a format.

00:16:36,100 --> 00:16:43,350
There's a framework from eBay that delivers really good performance with compiler techniques.

00:16:43,350 --> 00:16:46,940
And Angular is working on a next generation renderer called Ivy.

00:16:46,940 --> 00:16:51,780
These are fantastic frameworks and you should check them out.

00:16:51,780 --> 00:16:58,080
A question I get very often is, surely if your components are being converted into vanilla

00:16:58,080 --> 00:17:03,589
JavaScript, it's bulkier than just instructions to a framework.

00:17:03,589 --> 00:17:08,300
Efferently you reach an inflection point where you would have gotten a smaller app by using

00:17:08,300 --> 00:17:10,610
the framework in the first place.

00:17:10,610 --> 00:17:20,390
That differs from framework to framework but holds true.

00:17:20,390 --> 00:17:26,400
Svelte components have a low incremental cost because the compiler can reuse a lot of code.

00:17:26,400 --> 00:17:32,280
Secondly, in practice, by the time you get to that point, you should be using code splitting.

00:17:32,280 --> 00:17:36,840
And you just don't reach that inflection point.

00:17:36,840 --> 00:17:41,790
Code splitting is a technique that allows the browser to lazily load assets as they're

00:17:41,790 --> 00:17:42,790
needed.

00:17:42,790 --> 00:17:48,970
With a traditional framework, the smallest chunk is at least as large as the framework

00:17:48,970 --> 00:17:53,270
and the other dependencies that you're using and svelte doesn't have that problem.

00:17:53,270 --> 00:17:57,380
As it happens, we can solve this problem.

00:17:57,380 --> 00:18:04,880
Conduit is an application that is part of the real-world project which is an endeavor

00:18:04,880 --> 00:18:11,090
to get different frameworks to build the same app to see how they compare at a real use

00:18:11,090 --> 00:18:12,090
case.

00:18:12,090 --> 00:18:14,070
It's basically a medium frame.

00:18:14,070 --> 00:18:23,700
And according to a recent article, it just svelte is down here in the middle next to

00:18:23,700 --> 00:18:26,220
Apron and 2.

00:18:26,220 --> 00:18:29,660
This is the initial payload size.

00:18:29,660 --> 00:18:33,460
This is the React implementation.

00:18:33,460 --> 00:18:37,370
It's not entirely fair, this isn't using code splitting and svelte is.

00:18:37,370 --> 00:18:43,950
But adding all the JavaScript assets, svelte is about 40% of the size of the React one.

00:18:43,950 --> 00:18:44,950
It definitely does scale.

00:18:44,950 --> 00:18:50,190
And we can see the effect in the startup metrics.

00:18:50,190 --> 00:18:54,340
This is 3 seconds, time to first meaningful paint, and the other version is about a second

00:18:54,340 --> 00:18:57,540
and a half.

00:18:57,540 --> 00:19:02,250
There's another important metric, which is lines of code.

00:19:02,250 --> 00:19:05,820
Svelte has about half the number of lines of code that the React version does.

00:19:05,820 --> 00:19:06,820
And that's not an aberration.

00:19:06,820 --> 00:19:09,140
That's something that we see all the time.

00:19:09,140 --> 00:19:13,160
Because it turns out that you can express UI concepts much more cleanly and succinctly

00:19:13,160 --> 00:19:16,780
if you're using a language that's designed for that task.

00:19:16,780 --> 00:19:20,020
A few lines of code is good.

00:19:20,020 --> 00:19:24,970
You can write the lines quicker, but the app is more maintainable.

00:19:24,970 --> 00:19:25,970
Fewer bugs.

00:19:25,970 --> 00:19:31,550
Svelte is reasonably flexible and powerful, but you need something more if you're going

00:19:31,550 --> 00:19:32,660
to build ambition apps.

00:19:32,660 --> 00:19:36,630
And in the React world, we have a project called Next.

00:19:36,630 --> 00:19:40,220
The idea is each page is a comment.

00:19:40,220 --> 00:19:49,179
And you get the server and client rendered versions, so the navigation is instantaneous.

00:19:49,179 --> 00:19:56,510
And could we take the same svelte philosophy of compilers and apply it to that problem?

00:19:56,510 --> 00:19:58,230
Yes, we can.

00:19:58,230 --> 00:20:01,340
Where has my mouse gone?

00:20:01,340 --> 00:20:08,320
So, I'm going to create a new sample project.

00:20:08,320 --> 00:20:10,040
Short for svelte app maker.

00:20:10,040 --> 00:20:18,820
Here's one I made earlier so we don't need to wait for dependencies to install.

00:20:18,820 --> 00:20:25,200
And if I build my app, then this is the basic start to template.

00:20:25,200 --> 00:20:30,600
And you can see as before, we've got the client-side rendering, nice and slick.

00:20:30,600 --> 00:20:32,280
It's very fast.

00:20:32,280 --> 00:20:38,390
But if we look at the actual workup that you get from the server, it's server rendered.

00:20:38,390 --> 00:20:44,870
You get that fast initial load.

00:20:44,870 --> 00:21:06,320
If I were to build this, then we can have a look at production stats for this.

00:21:06,320 --> 00:21:09,080
And you can see that it's less than 7 kilobytes.

00:21:09,080 --> 00:21:10,770
You can't see.

00:21:10,770 --> 00:21:11,770
It's quite small.

00:21:11,770 --> 00:21:13,520
Less than 7 kilobytes of JavaScript.

00:21:13,520 --> 00:21:17,270
Which is more than necessary, but it's a good start.

00:21:17,270 --> 00:21:29,690
For reference, if we look at the same app built using Next, then it's well over 200

00:21:29,690 --> 00:21:30,710
kilobytes.

00:21:30,710 --> 00:21:38,800
Which is frankly too much for an app that doesn't yet do a great deal.

00:21:38,800 --> 00:21:42,669
I have some numbers on the server side rendering performance.

00:21:42,669 --> 00:21:46,240
So, I don't want to get too high up in the performance stuff.

00:21:46,240 --> 00:21:50,860
I want to promote the idea that we should be comparing frameworks along interesting

00:21:50,860 --> 00:21:51,860
dimension.

00:21:51,860 --> 00:21:56,630
Such as does this frame work help me build a more accessible web?

00:21:56,630 --> 00:22:03,039
Svelte will warn you if you build if you use things that aren't accessible.

00:22:03,039 --> 00:22:05,400
Does it help us build slick user interfaces?

00:22:05,400 --> 00:22:08,890
Does it help us write fewer lines of code?

00:22:08,890 --> 00:22:14,039
And can we write tools that are more sophisticated than stuff that's based on the command line.

00:22:14,039 --> 00:22:15,800
I have been inspired by these two projects.

00:22:15,800 --> 00:22:22,450
In the remaining 60 seconds, I'm going to try to show you what I have been working on.

00:22:22,450 --> 00:22:31,600
This is a graphical user interface for building apps.

00:22:31,600 --> 00:22:35,830
And you can do some pretty cool stuff if you have tools that are deeply integrated with

00:22:35,830 --> 00:22:37,250
the frameworks that they serve.

00:22:37,250 --> 00:22:42,289
I can open and I can go straight to the page that I'm currently on.

00:22:42,289 --> 00:22:47,860
If I want to look at a particular element and edit that, then I can click the cross

00:22:47,860 --> 00:22:48,860
hairs.

00:22:48,860 --> 00:22:53,270
But go straight to the source code to go ahead and edit it.

00:22:53,270 --> 00:22:57,000
I have been building apps like this for a short while and it's transformed how quickly

00:22:57,000 --> 00:22:59,169
I'm able to build stuff.

00:22:59,169 --> 00:23:07,620
In summary, the first era, homesteaders tended to code bases my hand.

00:23:07,620 --> 00:23:12,950
And the second era was the industrial age when we started to use machines for everything

00:23:12,950 --> 00:23:14,669
and people wrote a little bit about the pollution.

00:23:14,669 --> 00:23:18,900
But we can't deny that it have a transformative effect on productivity.

00:23:18,900 --> 00:23:21,800
The third age is the information age.

00:23:21,800 --> 00:23:25,230
Machines are becoming intelligent.

00:23:25,230 --> 00:23:31,820
How can computers, helpers, fulfill our potential as creative professionals?

00:23:31,820 --> 00:23:37,250
I think this is some largely unexplored territory.

00:23:37,250 --> 00:23:39,000
Doesn't just apply to user interface.

00:23:39,000 --> 00:23:42,160
It also applies to tools and everything else that we work on.

00:23:42,160 --> 00:23:45,280
So, I hope that you will come and explore it with me.

00:23:45,280 --> 00:23:46,520

YouTube URL: https://www.youtube.com/watch?v=qqt6YxAZoOc


