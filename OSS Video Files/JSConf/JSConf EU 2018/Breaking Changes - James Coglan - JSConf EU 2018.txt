Title: Breaking Changes - James Coglan - JSConf EU 2018
Publication date: 2018-07-12
Playlist: JSConf EU 2018
Description: 
	Semantic Versioning or SemVer has become a de-facto standard in the last few years, with several language ecosystems now relying on it to manage software upgrades. However, it is frequently misunderstood as a technical tool for making cold hard guarantees about code, rather than as a human tool for signaling intent and setting expectations.

Never is this more apparent than when we consider what a “breaking change” means. It’s highly contextual: it depends on which language you’re using, what your public interface is, what guarantees you’ve explicitly or implicitly made to users, how much software sits downstream of you, and so on. In this talk I’ll explore several ways you can accidentally break other people’s JavaScript apps, how to avoid them, and what to do when you can’t.

OMG JSConf EU is coming back in 2019 https://2019.jsconf.eu/
Captions: 
	00:00:09,200 --> 00:00:12,800
Hi, I'm James.

00:00:12,800 --> 00:00:15,690
I'm here to talk to you about breaking changes.

00:00:15,690 --> 00:00:20,270
To provide a bit of context and introduce myself, I am the creator of and maintainer

00:00:20,270 --> 00:00:27,490
of the this set of MPM packages that provide WebSocket messaging, various layers of that

00:00:27,490 --> 00:00:28,490
protocol.

00:00:28,490 --> 00:00:30,590
They're widely used by different projects.

00:00:30,590 --> 00:00:36,429
They generate about eight million downloads a week between them, and I've been maintaining

00:00:36,429 --> 00:00:41,000
these pretty much since Node was released, so since early 2010.

00:00:41,000 --> 00:00:45,750
So this is a reflection of my experience as an open-source maintainer of seeing things

00:00:45,750 --> 00:00:49,389
change over time, and what the effects of that are.

00:00:49,389 --> 00:00:51,309
An additional bit of context.

00:00:51,309 --> 00:00:55,409
This talk should not be construed as a complaint about how things work.

00:00:55,409 --> 00:00:59,929
We should be really grateful for all the software that we get for free that lets us do loads

00:00:59,929 --> 00:01:00,929
of amazing stuff.

00:01:00,929 --> 00:01:07,570
I'm trying to reflect on again my own experience rather than bashing anybody else and saying

00:01:07,570 --> 00:01:08,570
you're doing this wrong.

00:01:08,570 --> 00:01:12,780
It's how can we reflect and improve what we are doing?

00:01:12,780 --> 00:01:18,950
Okay, so, with that out of the way, what do we mean by "breaking"?

00:01:18,950 --> 00:01:26,100
Consider this module at the top that has a method called "get", and it takes a URL and

00:01:26,100 --> 00:01:33,340
makes an HTTP request of the URL and invokes a callback with a status code which I've hard-coded

00:01:33,340 --> 00:01:35,270
here as a number.

00:01:35,270 --> 00:01:40,830
Let's say we change that number 404 and replace it with the string 404.

00:01:40,830 --> 00:01:42,780
Do we think that is breaking change or not?

00:01:42,780 --> 00:01:45,370
To answer that, we have to look at some use cases.

00:01:45,370 --> 00:01:50,070
If something is calling this function, and it's using the weaker quality operator to

00:01:50,070 --> 00:01:54,800
compare the numbers, that will keep working, because, in JavaScript, a number is week weakly

00:01:54,800 --> 00:01:56,390
equal to its string representation.

00:01:56,390 --> 00:02:02,270
However, if we're using stricter quality, this code will now break because numbers and

00:02:02,270 --> 00:02:06,100
strings are never strictly equal to each other, so, if we have this code, we consider the

00:02:06,100 --> 00:02:09,789
change to the HTTP module to have broken our programme.

00:02:09,789 --> 00:02:17,250
Another example: this module contains a method that takes the name of a table and it runs

00:02:17,250 --> 00:02:21,780
a query to count the number of records in that table, and then it invokes your callback

00:02:21,780 --> 00:02:26,540
with the count which again I've hard-coded, and in the something about this module.

00:02:26,540 --> 00:02:29,739
This is structural usual identical to the other module that I just showed you.

00:02:29,739 --> 00:02:32,409
All I've done is replace some of the names.

00:02:32,409 --> 00:02:37,310
The actual programmatic structure in terms of what the compiler cares about is the same

00:02:37,310 --> 00:02:43,569
as the HTTP module, so, if we believe that that breaking change compatibility is purely

00:02:43,569 --> 00:02:47,639
a function of the source code itself, then we have to give the same answer for the HTTP

00:02:47,639 --> 00:02:49,920
module and this one.

00:02:49,920 --> 00:02:51,530
Let's look at some use cases.

00:02:51,530 --> 00:02:56,349
So, say somebody is counting the number of records in tables and then subtracting them,

00:02:56,349 --> 00:03:02,360
for example, to work out the number of remaining tickets left for a conference, now, in JavaScript,

00:03:02,360 --> 00:03:07,269
the subtraction operator coerces strings to number so you get arithmetic sub extraction

00:03:07,269 --> 00:03:11,629
and the same result you had before.

00:03:11,629 --> 00:03:18,670
If you're adding them together, the plus operator has an overloaded meeting, performing numbers

00:03:18,670 --> 00:03:21,260
and concatenate strings together.

00:03:21,260 --> 00:03:27,730
If something was a number and now a string, we get the string concatenation of those two

00:03:27,730 --> 00:03:31,090
values, so this value no longer — programme does the same thing, and the author of this

00:03:31,090 --> 00:03:34,730
programme would consider it broken by the changes made.

00:03:34,730 --> 00:03:42,230
So, yeah, we would have to make an explicit change here to account for the fact that the

00:03:42,230 --> 00:03:46,939
database module has changed how it represents the results to us by explicitly converting

00:03:46,939 --> 00:03:48,769
the strings back to numbers again.

00:03:48,769 --> 00:03:55,419
So, what we've seen here is that the meaning of values in programmes is not, like, fully

00:03:55,419 --> 00:03:56,419
contained within themselves.

00:03:56,419 --> 00:04:02,769
It is not to do with what their type is, like a number can be used for several different

00:04:02,769 --> 00:04:06,540
purposes, it depends how you're using it that determines whether changing it would be a

00:04:06,540 --> 00:04:07,790
problem.

00:04:07,790 --> 00:04:15,069
So, what we've seen is that, rather than just beak a number, like something having one type,

00:04:15,069 --> 00:04:17,579
it actually has a set of characteristic traits.

00:04:17,579 --> 00:04:21,230
A Java programmer might call these "interfacers".

00:04:21,230 --> 00:04:25,380
Haskell users might call them type classes, but the idea is that a value of a certain

00:04:25,380 --> 00:04:29,630
type can be used for different operations, and it's which of those operations that you're

00:04:29,630 --> 00:04:33,630
using which determines their true meaning.

00:04:33,630 --> 00:04:37,780
So we've seen a couple of these already, like a number might be used for its identity, like

00:04:37,780 --> 00:04:42,730
an HTTP status code is not like an arithmetic number, it's a machine-readable label for

00:04:42,730 --> 00:04:44,200
something.

00:04:44,200 --> 00:04:47,280
But numbers also have arithmetic properties.

00:04:47,280 --> 00:04:52,130
You might want to do maths with them, addition and subtraction, and so on.

00:04:52,130 --> 00:04:56,100
So that is a little bit of an example of why the complexity even exists in very simple

00:04:56,100 --> 00:04:57,480
values like numbers.

00:04:57,480 --> 00:04:58,700
What about objects?

00:04:58,700 --> 00:05:00,351
What happens when we change the interfaces to those?

00:05:00,351 --> 00:05:05,280
Let's say we have a function that returns an object that convince some information about

00:05:05,280 --> 00:05:08,670
— that returns some information about the returns of the conference, in fact, this talk

00:05:08,670 --> 00:05:10,250
in this conference.

00:05:10,250 --> 00:05:14,360
It contains a title, date, and a presenter, all of which are strings.

00:05:14,360 --> 00:05:20,010
Now, adding a new field to this object is probably not a problem.

00:05:20,010 --> 00:05:25,010
Any programme that is using this will probably just ignore the fact that the new field exists,

00:05:25,010 --> 00:05:26,010
right?

00:05:26,010 --> 00:05:30,430
It won't be relying on it, so this object gaping a few field won't disrupt any existing

00:05:30,430 --> 00:05:31,530
code.

00:05:31,530 --> 00:05:38,280
However, if we remove a field, like the title object — sorry, the title property — some

00:05:38,280 --> 00:05:42,150
code that is using this function will now probably break, so, for example, if we are

00:05:42,150 --> 00:05:47,170
calling get hook info and putting the title attribute of the result into a string, we

00:05:47,170 --> 00:05:52,280
will now get a string containing undefined, and this is a case where JavaScript doesn't

00:05:52,280 --> 00:05:54,060
alert you to the fact that it has made a mistake.

00:05:54,060 --> 00:05:58,290
You don't get an error if you access an attribute that doesn't exist, you get the value undefined,

00:05:58,290 --> 00:05:59,810
and that shows up in the spring.

00:05:59,810 --> 00:06:04,820
The programme hasn't broken in the sense that it is crashing, but it is clearly not doing

00:06:04,820 --> 00:06:07,400
what was intended.

00:06:07,400 --> 00:06:11,040
A user will notice that something weird has happened here.

00:06:11,040 --> 00:06:15,740
Likewise, changing the types of existing fields is likely to break existing programmes.

00:06:15,740 --> 00:06:22,030
So, for example, if we were calling get hook info and then split the date field on dashes

00:06:22,030 --> 00:06:26,310
to break the date into its component parts, that will no longer work because a date object

00:06:26,310 --> 00:06:28,960
doesn't have a split method.

00:06:28,960 --> 00:06:34,360
So, in broad terms, adding new fields to an object is fine.

00:06:34,360 --> 00:06:38,010
The existing callers will just ignore that new field.

00:06:38,010 --> 00:06:42,720
Removing a field might break things as we've seen, and JavaScript won't alert you to that

00:06:42,720 --> 00:06:43,720
problem.

00:06:43,720 --> 00:06:46,180
And changing the type of existing fields can also break things.

00:06:46,180 --> 00:06:49,930
Sometimes, you will get an error because you're using a method that doesn't exist, but sometimes,

00:06:49,930 --> 00:06:53,280
the programme will silently do the wrong thing.

00:06:53,280 --> 00:06:55,260
But it's not quite as simple as that.

00:06:55,260 --> 00:06:59,940
JavaScript being a small language has overloaded the few abstractions that it has with several

00:06:59,940 --> 00:07:01,560
different meanings.

00:07:01,560 --> 00:07:07,590
There are multiple different ideas and computation that is are overloaded on to the same thing

00:07:07,590 --> 00:07:12,240
in JavaScript, and, one of those things is object.

00:07:12,240 --> 00:07:18,650
We use object to represent the computational idea of maps, of records, of object-orientated

00:07:18,650 --> 00:07:23,900
style objects, and several other things, so what do these terms mean?

00:07:23,900 --> 00:07:26,340
We are using this one thing object for a lot of different functions.

00:07:26,340 --> 00:07:30,050
We need to think about the different ways in which it's used.

00:07:30,050 --> 00:07:37,880
So a map is an open-ended collection of key value pairs and, typically, the programme

00:07:37,880 --> 00:07:42,680
doesn't care about what specific keys are in the object, it is just data, and it gets

00:07:42,680 --> 00:07:45,410
processed, like whatever is there is processed.

00:07:45,410 --> 00:07:49,770
Typically, if your programme is iterating over an object and owing what is — and programming

00:07:49,770 --> 00:07:52,650
what it contains, it uses a map.

00:07:52,650 --> 00:07:58,610
A record is a fixed set of known fields where the field can have different types and the

00:07:58,610 --> 00:08:03,190
programme usually cares about specific fields within an object, so the proxy pass to react

00:08:03,190 --> 00:08:05,320
component are a good example of this.

00:08:05,320 --> 00:08:09,420
You don't just iterate over them and do the same thing over the fields, you normally pick

00:08:09,420 --> 00:08:13,820
out the specific fields and put them in specific places in your UI.

00:08:13,820 --> 00:08:19,770
An object-orientated programming kind of object is bit like an extension of a record.

00:08:19,770 --> 00:08:23,890
It is a computational value that combines state with behaviour, so it's like a record

00:08:23,890 --> 00:08:29,760
where some of the fields are functions that access the record's other data fields.

00:08:29,760 --> 00:08:34,150
So the image value that I used in the previous example here is a good example of that, that

00:08:34,150 --> 00:08:39,240
image.url bit comes from a class that takes a name, and it has a method that those how

00:08:39,240 --> 00:08:43,650
to calculate the URL for the particular size of an image.

00:08:43,650 --> 00:08:49,180
Typically, adding new methods to an OAP style object is fine which enables polymorphism,

00:08:49,180 --> 00:08:54,250
which means that one function can work with lots of different kind of objects as long

00:08:54,250 --> 00:08:56,840
as they have a method in common.

00:08:56,840 --> 00:09:06,580
Its rivel in JavaScript is an example of this adding now fields to other things like records

00:09:06,580 --> 00:09:08,000
can cause problems.

00:09:08,000 --> 00:09:15,550
So, for example, if you add a field to your web pack could be config that it doesn't recognise,

00:09:15,550 --> 00:09:18,890
you would get an error.

00:09:18,890 --> 00:09:22,290
It checks everything that your object includes, and, if it don't recognise it, it gets an

00:09:22,290 --> 00:09:24,820
error.

00:09:24,820 --> 00:09:30,360
The kind of programme that web pack is, it indicates an error on the part of the user

00:09:30,360 --> 00:09:35,190
if it includes data that should not be there — it usually indicates a typo, or a field

00:09:35,190 --> 00:09:39,570
that is no longer supported if you've upgraded from 3 to 4.

00:09:39,570 --> 00:09:43,630
So it's not always the case that adding new fields to something keeps your programme working.

00:09:43,630 --> 00:09:49,140
In some cases, it will break them, and that's done for ergonomic reasons to help the user

00:09:49,140 --> 00:09:51,600
use the programme correctly.

00:09:51,600 --> 00:09:56,090
Likewise, if you're inserting something in a database, if you trying to I to save an

00:09:56,090 --> 00:10:01,740
object to a table, should that be silently ignored if it doesn't have a property?

00:10:01,740 --> 00:10:05,070
Should that be silently ignored?

00:10:05,070 --> 00:10:12,080
ORMs typically include explicit instructions for these properties get saved to the database

00:10:12,080 --> 00:10:19,320
and these don't and the user has to decide which things belong in which category.

00:10:19,320 --> 00:10:25,260
So that's a little bit about — we've seen how primitive values like numbers can contain

00:10:25,260 --> 00:10:29,250
quite a lot of complexity, and, likewise, something like object can take on a lot of

00:10:29,250 --> 00:10:34,240
different computational meanings, and so changing it has different effects in different circumstances.

00:10:34,240 --> 00:10:42,050
But another thing that causes programmes to break is just the concepts we are expressing

00:10:42,050 --> 00:10:44,240
are too complicated.

00:10:44,240 --> 00:10:50,660
One example of this was the recent proposal to add the flat method to the array prototype,

00:10:50,660 --> 00:10:55,490
and a lot of people petitioned TC39 not to do this because it would conflict with another

00:10:55,490 --> 00:10:58,230
implementation already out in the wild.

00:10:58,230 --> 00:10:59,830
Why would this be a problem?

00:10:59,830 --> 00:11:07,810
It's partly for sort of logistical reasons, like, TC39 is responsible for the environment

00:11:07,810 --> 00:11:11,340
that exists in the browser, right, so we as developers don't have control over that, our

00:11:11,340 --> 00:11:15,520
code gets deployed into all these browsers, and it has to deal with whatever is there,

00:11:15,520 --> 00:11:16,520
right?

00:11:16,520 --> 00:11:19,570
It's not like one of our dependencies where we choose which version it is.

00:11:19,570 --> 00:11:24,510
Anything in the browser affects the code runs and we don't have direct control over it.

00:11:24,510 --> 00:11:30,020
TC39 changing things in a way that conflicts with our code can cause problems.

00:11:30,020 --> 00:11:33,850
Why does that conflict even exist in the first place?

00:11:33,850 --> 00:11:38,300
If we were talking about a fairly simple function, it is quite likely that TC39's definition

00:11:38,300 --> 00:11:43,090
would agree with the one the community had already adopted, and we wouldn't have a problem.

00:11:43,090 --> 00:11:48,860
But the thing with the flattened method is that it is extremely conceptually complicated.

00:11:48,860 --> 00:11:50,910
Here's one potential implementation of it.

00:11:50,910 --> 00:11:57,690
So, we implement flatten by introducing starting with an empty list and concatenating the array

00:11:57,690 --> 00:11:58,690
together.

00:11:58,690 --> 00:12:05,000
The way this works is that it is will combine any array inside the outer array and flatten

00:12:05,000 --> 00:12:07,760
the array to one level deep.

00:12:07,760 --> 00:12:12,370
You might decide you want your array flattened infinitely deep, and this won't do that.

00:12:12,370 --> 00:12:19,650
Or you might care about other collections, like iterable collections like strings, or

00:12:19,650 --> 00:12:24,320
a set that is already present in the outer array — what is the effect of null?

00:12:24,320 --> 00:12:26,420
What does it mean to combine these values?

00:12:26,420 --> 00:12:31,310
There is a broad set of decisions to be made here about what this function even means.

00:12:31,310 --> 00:12:36,160
And that means there is a broad spates of different implementations of it.

00:12:36,160 --> 00:12:40,260
If you put two implementations of this function in the same programme, they're likely to disagree

00:12:40,260 --> 00:12:41,980
with each other.

00:12:41,980 --> 00:12:46,779
And so, one way that you can avoid breaking things is to avoid using functions that are

00:12:46,779 --> 00:12:47,880
this complicated.

00:12:47,880 --> 00:12:51,279
Often, if you have something and you want to flatten is to one level deep, you want

00:12:51,279 --> 00:12:53,040
to use FlatMap instead.

00:12:53,040 --> 00:12:59,200
If you know your arbitrarily deep, you might want to use an interpreter.

00:12:59,200 --> 00:13:03,260
If you don't know how deeply nested your structure is, you have a deeper design problem that

00:13:03,260 --> 00:13:04,899
needs fixing.

00:13:04,899 --> 00:13:10,830
Yes, there is a lot of complexity inherent in this method which means it's hard to make

00:13:10,830 --> 00:13:13,170
it into operate.

00:13:13,170 --> 00:13:16,960
We saw a similar thing with the buffer constructor in node which was taking several different

00:13:16,960 --> 00:13:22,070
types of values and giving a different behaviour depending on the type, and it was easy to

00:13:22,070 --> 00:13:26,500
parse a number instead of a string and then get different behaviour and this caused security

00:13:26,500 --> 00:13:31,550
errors in some WebSocket implementations where you could make the server expose unsanitised

00:13:31,550 --> 00:13:34,770
memory to you.

00:13:34,770 --> 00:13:39,180
We fixed that by turning into several different methods that made it explicit, like the user

00:13:39,180 --> 00:13:42,730
would make it explicit what behaviour they wanted: either they want a buffer that contains

00:13:42,730 --> 00:13:47,580
the byte data for a string or they want a buffer that is a fixed size of memory, and

00:13:47,580 --> 00:13:48,670
now you've made it unambiguous.

00:13:48,670 --> 00:13:53,720
The user is saying what they want.

00:13:53,720 --> 00:13:57,250
So it's not just about the return values that our programmes have, and how things are consuming

00:13:57,250 --> 00:13:58,250
them.

00:13:58,250 --> 00:14:02,710
There's an implicit contract between any function and the things it takes in terms of of what

00:14:02,710 --> 00:14:04,850
properties it expects them to have.

00:14:04,850 --> 00:14:08,390
So, take this contains function.

00:14:08,390 --> 00:14:12,130
This takes a list and a value, and it returns a count of the number of times that value

00:14:12,130 --> 00:14:14,070
appears in the list.

00:14:14,070 --> 00:14:21,690
It does that by initialising a counter to zero, and then using a for-of-loop iterating

00:14:21,690 --> 00:14:26,140
over the counter.

00:14:26,140 --> 00:14:30,390
This works fine with arrays, as you would expect, but because it uses a for-of loop,

00:14:30,390 --> 00:14:32,890
it use any kind of iterable value.

00:14:32,890 --> 00:14:38,980
If somebody is using this with a set, it will only one a 0 or a 1 with the set because sets

00:14:38,980 --> 00:14:44,310
only contain one of each value but that is good to determine truthiness whether something

00:14:44,310 --> 00:14:48,880
exists in the set or not.

00:14:48,880 --> 00:14:53,050
Say the author of the contains function decides to change it, their assumption is that it

00:14:53,050 --> 00:14:56,410
is only being used with arrays, so they will use an array method.

00:14:56,410 --> 00:15:03,200
They use it using the filter method using values value to the input, and then return

00:15:03,200 --> 00:15:04,580
the length of the result.

00:15:04,580 --> 00:15:07,610
So this continues to to work with arrays just fine.

00:15:07,610 --> 00:15:12,540
But now it blows up when you give it a set, because sets don't implement the filter method.

00:15:12,540 --> 00:15:18,310
We get a slightly unobvious error here like the word "filter" doesn't correspond to anything

00:15:18,310 --> 00:15:23,020
the user has said here, it's an error being thrown by the internals, but the programme

00:15:23,020 --> 00:15:31,899
is rejecting an input that it previously accepted and that is because the author assumed that

00:15:31,899 --> 00:15:38,000
people would only use it with one kind of value, but they never made that explicit.

00:15:38,000 --> 00:15:43,700
So, we should also consider side effects when looking at our programmes.

00:15:43,700 --> 00:15:50,370
JavaScript being an imperative language, our programmes don't just call functions and returns

00:15:50,370 --> 00:15:51,660
values, they also have side effects.

00:15:51,660 --> 00:15:55,930
For example, here's a function that adds a dependency to your package.json by reading

00:15:55,930 --> 00:16:00,240
the file, parsing it, adding a dependency and copying back to list.

00:16:00,240 --> 00:16:06,279
If we add a console log line, is that breaking change?

00:16:06,279 --> 00:16:14,700
If it is embedded in a programme that expects to output JSON output, adding this log line

00:16:14,700 --> 00:16:16,810
will make that programme fail.

00:16:16,810 --> 00:16:23,700
Likewise, if you have an event emitter, you might decide to add a new value to the data

00:16:23,700 --> 00:16:27,690
that is emitted with an event, and JavaScript lets you call functions with more arguments

00:16:27,690 --> 00:16:31,030
than they were expecting, so this ought to be fine, right?

00:16:31,030 --> 00:16:36,980
Turns out somebody is using a vary added function and expects the values to be the same time

00:16:36,980 --> 00:16:41,459
and processed in the same way.

00:16:41,459 --> 00:16:46,910
I could go on with these sorts of examples all day, but the core theme here is that JavaScript

00:16:46,910 --> 00:16:51,610
doesn't make it particularly easy for you to write code that works and keeps working.

00:16:51,610 --> 00:16:55,769
It is permissive, works with code that you expect to throw you an error.

00:16:55,769 --> 00:17:00,340
When it gives an error message, it isn't helpful and doesn't identify which bit of the programme

00:17:00,340 --> 00:17:06,179
is incorrect, and you have no way of telling the compiler how you expect people to use

00:17:06,179 --> 00:17:07,179
your programme.

00:17:07,179 --> 00:17:10,920
The compiler can't tell you and you've done something that will break those.

00:17:10,920 --> 00:17:14,020
Enough complaining.

00:17:14,020 --> 00:17:19,390
What can we actually do?

00:17:19,390 --> 00:17:24,829
One popular answer to this problem is semantic versions, or Sam very for short, which is

00:17:24,829 --> 00:17:30,780
that you format your version numbers as three separate numbers where ink submitting the

00:17:30,780 --> 00:17:34,550
front one means you've made an backwards incompatible change.

00:17:34,550 --> 00:17:39,780
Second one is a new feature in a backwards compatible way, and changing the last number

00:17:39,780 --> 00:17:41,300
means you've made a bug fix.

00:17:41,300 --> 00:17:46,260
As we've seen, compatibility doesn't hinge on the module itself but on the context in

00:17:46,260 --> 00:17:48,490
which the module is being used.

00:17:48,490 --> 00:17:54,390
SemVer has conceptual limitations in that sense but also practical ones.

00:17:54,390 --> 00:17:57,780
It is hard to express fine-grained information.

00:17:57,780 --> 00:18:05,140
Like you might have released a breaking change but you haven't — like all the functions

00:18:05,140 --> 00:18:08,940
that I happen to be using from your package are still fine, so I can't tell from the version

00:18:08,940 --> 00:18:09,940
number whether it has saved the upgrade.

00:18:09,940 --> 00:18:12,490
— whether it is safe to upgrade.

00:18:12,490 --> 00:18:17,230
You can see it playing out in the ecosystem that a lot of time I've seen breaking changes

00:18:17,230 --> 00:18:21,429
in production, they show newspaper bug fixes releases.

00:18:21,429 --> 00:18:29,640
Last year, we had a denial of service vulnerability, and at the end of 2016, the sdlib library

00:18:29,640 --> 00:18:42,490
released since 2009, which gives you an idea — and that contained a change that meant

00:18:42,490 --> 00:18:46,190
previously valid configuration values that are required by the WebSocket compression

00:18:46,190 --> 00:18:48,980
protocol were now illegal and it would throw errors on them.

00:18:48,980 --> 00:18:56,040
In April the following year, Node.js released 4.8.2 and 6.10.2 which bundled this version

00:18:56,040 --> 00:18:58,950
of sdlib and broke WebSocket servers.

00:18:58,950 --> 00:19:07,960
In August, when we were releasing the new libraries, we discovered this issue, reported

00:19:07,960 --> 00:19:14,670
it to the Node project, and Miles from the Node project reported this issue to sdlib.

00:19:14,670 --> 00:19:21,220
This is not necessarily a bug in sdlib, it is sdlib's intention that these values are

00:19:21,220 --> 00:19:22,830
not legal and you should not use they will.

00:19:22,830 --> 00:19:25,929
They didn't know that this would break stuff to do with the WebSocket protocol.

00:19:25,929 --> 00:19:31,500
A month later after figuring out the possible solutions, the fact that we would have to

00:19:31,500 --> 00:19:37,770
deviate from the spec to make the programmes stop crashing and written everything up, deflate

00:19:37,770 --> 00:19:42,650
reels cache, and a month after that Node.js released versions four, six, and eight in

00:19:42,650 --> 00:19:47,410
a paper over the problem.

00:19:47,410 --> 00:19:52,600
This gives you some idea of the time it takes for these changes to propagate through the

00:19:52,600 --> 00:19:53,600
system.

00:19:53,600 --> 00:19:56,620
Everyone is working with imperfect information and we have to figure out what is going on,

00:19:56,620 --> 00:19:57,960
and that takes time.

00:19:57,960 --> 00:20:02,929
When you're changing a system, you don't have to look at the meaning of the programme like

00:20:02,929 --> 00:20:08,511
on its own, you have to think about the effect on the ecosystem of the community for the

00:20:08,511 --> 00:20:10,700
information of that change to spread.

00:20:10,700 --> 00:20:14,450
If you make too much change too quickly, you end up leaving everybody behind and you end

00:20:14,450 --> 00:20:17,790
up not upgrading your software.

00:20:17,790 --> 00:20:24,650
Another approach to breaking change is try to never break anything which sound like an

00:20:24,650 --> 00:20:25,730
extreme position.

00:20:25,730 --> 00:20:31,410
I'm not sure any of us would ever manage to live by this standard.

00:20:31,410 --> 00:20:34,480
But, it is a constraint that people try and live to.

00:20:34,480 --> 00:20:40,240
We saw Ryan yesterday say it's my fault, and I'm very sorry, unfortunately, it is impossible

00:20:40,240 --> 00:20:41,520
to undo now.

00:20:41,520 --> 00:20:43,840
This is the world we live in.

00:20:43,840 --> 00:20:47,140
Too much stuff depends on our code, and we can't change it.

00:20:47,140 --> 00:20:51,820
It is what I try to live by in my software and partly to do with how the maintenance

00:20:51,820 --> 00:20:53,990
works.

00:20:53,990 --> 00:20:57,330
There's two main reasons why I try to work this way.

00:20:57,330 --> 00:21:00,270
The first is I'm not in direct contact with all of my users.

00:21:00,270 --> 00:21:04,390
If I want to change something that's hard for me to inform the largest is people using

00:21:04,390 --> 00:21:07,940
this code that I'm going to change it and they might need to update something.

00:21:07,940 --> 00:21:14,220
Most of the people running my code don't know they're doing so.

00:21:14,220 --> 00:21:20,020
So, my modules are typically embedded as transitive dependencies inside other things that people

00:21:20,020 --> 00:21:26,090
are using, so there are two or three levels of intermediaries of the end-user and my code,

00:21:26,090 --> 00:21:30,460
so, if I break something, there are several other authors and projects that would have

00:21:30,460 --> 00:21:36,240
to paper over that for the end-user to see any benefit from it.

00:21:36,240 --> 00:21:41,230
Because I do a open source in my spare time, I don't have a predictable amount of bandwidth

00:21:41,230 --> 00:21:46,740
for switching problems so it's more valuable for me to keep things stable rather than release

00:21:46,740 --> 00:21:51,320
stuff that might break things and have no visibility when I might be able to do with

00:21:51,320 --> 00:21:52,320
that later.

00:21:52,320 --> 00:21:55,760
I take a similar approach to my dependencies.

00:21:55,760 --> 00:22:00,860
I leave them open-ended rather than pinning them with the carat or tilde operator.

00:22:00,860 --> 00:22:07,059
I don't want to be a bottleneck on people getting an upgrade to the things that I'm

00:22:07,059 --> 00:22:13,049
depending on.. and I'm taking a risk here that these things might not be stable, but

00:22:13,049 --> 00:22:14,510
that's countered by other measures.

00:22:14,510 --> 00:22:16,720
I'm conservative with the things that I depend on.

00:22:16,720 --> 00:22:22,309
I will typically try and adopt something and live with it for a few months and get an understanding

00:22:22,309 --> 00:22:28,230
how it behaves over time before I release it to my users.

00:22:28,230 --> 00:22:29,669
All this hinges on communication.

00:22:29,669 --> 00:22:33,270
All of this stuff is — we've seen a lot of talks at this conference about how we communicate

00:22:33,270 --> 00:22:35,500
with each other.

00:22:35,500 --> 00:22:42,559
The core message that I want you to take away from this is that compatibility isn't an objective

00:22:42,559 --> 00:22:47,730
technocratic thing about the code itself, it's about the tact that we all have imperfect

00:22:47,730 --> 00:22:52,610
information about the author and the user and the software know different things about

00:22:52,610 --> 00:22:59,650
the software, and that means that the author's intent and the user's usage will deviate.

00:22:59,650 --> 00:23:05,240
The best ways that we can try to avoid things breaking is by affecting how people use our

00:23:05,240 --> 00:23:07,120
software, in how we communicate with them.

00:23:07,120 --> 00:23:11,130
We can partly do that through the code that we write, so, JavaScript is still a small

00:23:11,130 --> 00:23:15,190
language but grown a few things recently to express yourself better.

00:23:15,190 --> 00:23:18,490
It might be more appropriate rather than using a plain array to use a set that might be the

00:23:18,490 --> 00:23:20,740
might help you be more specific about your meaning.

00:23:20,740 --> 00:23:25,530
Instead of using a plain old object it might be appropriate to use a map for the distinctions

00:23:25,530 --> 00:23:30,160
we saw earlier.

00:23:30,160 --> 00:23:32,961
If you want to think about the operators and functions that you're using, if you know you're

00:23:32,961 --> 00:23:38,290
doing string concatenation, rather than using the plus operator, which is ambiguous, consider

00:23:38,290 --> 00:23:44,929
using templates or the join method which tells people you know you're doing string concatenation.

00:23:44,929 --> 00:23:48,800
You can try as avoid brittle idioms in the language that make it likely you will have

00:23:48,800 --> 00:23:49,800
to change your mind later.

00:23:49,800 --> 00:23:56,950
If a programme is growing a long list of parameters, and you keep adding more things to it, that

00:23:56,950 --> 00:24:00,170
makes the callers to those functions a bit cryptic, like what do true and false and zero

00:24:00,170 --> 00:24:01,170
mean?

00:24:01,170 --> 00:24:02,539
I don't really know.

00:24:02,539 --> 00:24:05,080
Every time you add a new parameter, it gets more complicated.

00:24:05,080 --> 00:24:11,470
A nicer way to do this is object destructuring and simulating named arguments and you can

00:24:11,470 --> 00:24:12,770
give them default values.

00:24:12,770 --> 00:24:17,410
That makes the function easier to change and makes the caller clearer about what it is

00:24:17,410 --> 00:24:18,410
doing.

00:24:18,410 --> 00:24:20,680
A really good example of this is callback.

00:24:20,680 --> 00:24:25,510
If you want to add a new parameter to callback function, that parameter needs to go before

00:24:25,510 --> 00:24:31,510
the callback, and you need to do some mending-up at the top of your method to account for callers

00:24:31,510 --> 00:24:33,820
that aren't passing that new parameter yet.

00:24:33,820 --> 00:24:37,500
It is much easier to do this if your function returns a promise because the parameter list

00:24:37,500 --> 00:24:43,169
hasn't been polluted by this extra parameter that needs to be at the end, so it's much

00:24:43,169 --> 00:24:46,690
easier just to add a new parameter there with a default value and not to have to add any

00:24:46,690 --> 00:24:48,780
of that extra stuff.

00:24:48,780 --> 00:24:50,980
Think about the error design.

00:24:50,980 --> 00:24:54,179
Errors should be a way that help users write code that works.

00:24:54,179 --> 00:24:58,440
They should not be a Carey thing but there to help people.

00:24:58,440 --> 00:25:03,040
Things throwing errors when you're making a mistake is good for you.

00:25:03,040 --> 00:25:06,669
For example, rather than the cryptic error we saw later about filter not existing when

00:25:06,669 --> 00:25:11,770
we parsed in a set, we can put an assertion on the top of our method that I expect this

00:25:11,770 --> 00:25:12,809
to be used with an array.

00:25:12,809 --> 00:25:16,840
If not, I will give you a method that tells you that is what I expected.

00:25:16,840 --> 00:25:21,299
So you can spot the bug in this code.

00:25:21,299 --> 00:25:23,580
It's probably not very obvious.

00:25:23,580 --> 00:25:30,170
The bug is that bytes has be to an integer but not on a number divisible by eight.

00:25:30,170 --> 00:25:32,800
Sometimes, we will parse a fractional value here.

00:25:32,800 --> 00:25:36,670
This worked fine until Node 9.

00:25:36,670 --> 00:25:42,590
The crypto-library rounded the number down, but the programme that was using this it didn't

00:25:42,590 --> 00:25:47,280
matter too much because it was asking for a lot more random data than it really needed,

00:25:47,280 --> 00:25:50,200
so the number being rounded down slightly wasn't a problem.

00:25:50,200 --> 00:25:54,360
Then in node 10, we got an error, key element is out of range.

00:25:54,360 --> 00:25:56,500
This error is slightly unhelpful.

00:25:56,500 --> 00:26:01,270
The error that the number is not an integer, not that this that it is out of range, but

00:26:01,270 --> 00:26:03,390
crashing a programme that previously worked.

00:26:03,390 --> 00:26:08,750
When you're adding errors to a library later in its life, think about should that error

00:26:08,750 --> 00:26:11,660
get to crash the programmes currently using it?

00:26:11,660 --> 00:26:14,380
Is there a better way to communicate that failure to the user?

00:26:14,380 --> 00:26:18,440
It is quite common for people to dig around in the console and look at the properties

00:26:18,440 --> 00:26:20,180
tab to figure out how to use them.

00:26:20,180 --> 00:26:25,730
One convention we have in JavaScript is if you're accessing a lot of things with underscores,

00:26:25,730 --> 00:26:28,220
that's a signal that you're doing something private.

00:26:28,220 --> 00:26:34,040
That's not something the language enforces for you but it's a way that you can signal

00:26:34,040 --> 00:26:40,660
to the user I didn't mean for you to use this, and it will probably break later.

00:26:40,660 --> 00:26:44,120
The final thing that we have to rely on is documentation.

00:26:44,120 --> 00:26:47,370
Documentation should help people use the code in the way that you intended.

00:26:47,370 --> 00:26:54,990
Often, people land on Google and even if you have like really good documentation, arriving

00:26:54,990 --> 00:26:58,620
at pros that — prose that requires a lot of context will give meme more questions than

00:26:58,620 --> 00:26:59,690
they arrive with.

00:26:59,690 --> 00:27:05,650
I could be going what's a driver object, should the you shall object be a strict?

00:27:05,650 --> 00:27:07,080
How do I put this stuff together?

00:27:07,080 --> 00:27:14,280
It would help people to give a self-contained example and once they understand the basic

00:27:14,280 --> 00:27:20,450
concepts, more ready to dive into your API details and add things in more detail.

00:27:20,450 --> 00:27:24,890
And finally, we have testing.

00:27:24,890 --> 00:27:31,340
So, testing is a huge topic but I can't possibly cover in the minute I have remaining, but

00:27:31,340 --> 00:27:37,020
one thing that I often see of people advise with testing that you should not test your

00:27:37,020 --> 00:27:38,020
dependencies.

00:27:38,020 --> 00:27:39,020
Don't test third-party code.

00:27:39,020 --> 00:27:40,620
That's a really good idea.

00:27:40,620 --> 00:27:42,370
You can do that.

00:27:42,370 --> 00:27:46,530
What it does is validate your assumptions and tells you where they're no longer true.

00:27:46,530 --> 00:27:52,020
Me as the user of the contains function we saw earlier, I can say it works with sets.

00:27:52,020 --> 00:27:57,790
One day when the author changes it, that will step working, I will get an error, and then

00:27:57,790 --> 00:28:03,300
immediately know that the reason my application is failing is because the dependency no longer

00:28:03,300 --> 00:28:04,300
true.

00:28:04,300 --> 00:28:06,650
So, what have we learned?

00:28:06,650 --> 00:28:14,620
We've learned that compatibility is not pure a function of the source code but the context

00:28:14,620 --> 00:28:16,020
which it's used.

00:28:16,020 --> 00:28:21,200
We've learned that context is constructed by how people use your programme, something

00:28:21,200 --> 00:28:26,490
you don't have control over, and finally, that you can influence that context by how

00:28:26,490 --> 00:28:29,900
you communicate with the users, and how you tell them if the software is supposed to be

00:28:29,900 --> 00:28:31,460
used.

00:28:31,460 --> 00:28:32,460
Thank you very much.

00:28:32,460 --> 00:28:32,960

YouTube URL: https://www.youtube.com/watch?v=StN9QKnhhHc


