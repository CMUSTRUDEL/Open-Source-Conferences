Title: Sebastiaan Deckers: Bundling With H2 Server Push - JSConf.Asia 2016
Publication date: 2016-12-02
Playlist: JSConf.Asia 2016
Description: 
	Tools and techniques to optimise website delivery beyond Webpack and Browserify using the new worlds of HTTP/2.

Seb is is a software engineer with a passion for front-end web development and open-source software. With over 15 years of experience, he has expertise in bringing startups from idea to a launched minimum viable product and growing technical teams.
As a freelance front-end engineer, he has worked with various startups in Singapore, including RedMart, Migme, Adz (now CtrlShift), and Nugit.
When heâ€™s not busy coding, you can find him cultivating the local developer community. Seb is the co-organiser of the Front End Developers Singapore (FEDS) meetup and regularly speaks at SingaporeJS events.


JSConf.Asia - Capitol Theatre, Singapore - 26 November 2016.

Source: https://2016.jsconf.asia/
Slides: https://sebdeckers.gitlab.io/talk-http2server-unbundle/assets/player/KeynoteDHTMLPlayer.html

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:18,640 --> 00:00:22,970
hi everyone I'm going to talk about a

00:00:21,890 --> 00:00:26,330
couple of tools that I've been working

00:00:22,970 --> 00:00:28,250
on and how they help you bundle your

00:00:26,330 --> 00:00:31,400
front-end web applications with HTTP two

00:00:28,250 --> 00:00:34,430
so a couple things I'm uncover is just a

00:00:31,400 --> 00:00:36,260
rough intro on how server push actually

00:00:34,430 --> 00:00:37,550
works not the basics of HTTP to I'm

00:00:36,260 --> 00:00:39,620
assuming a familiar with that or there's

00:00:37,550 --> 00:00:40,610
other talks to explain that better and

00:00:39,620 --> 00:00:41,960
then there's two demos that I want to

00:00:40,610 --> 00:00:44,420
show the two projects that i mentioned

00:00:41,960 --> 00:00:46,820
one is going to help you reduce latency

00:00:44,420 --> 00:00:48,680
and save bandwidth so therefore

00:00:46,820 --> 00:00:51,020
accelerate your websites and the other

00:00:48,680 --> 00:00:53,329
one is going to help you a transpile but

00:00:51,020 --> 00:00:57,950
particularly for projects that are being

00:00:53,329 --> 00:01:00,200
served with HTTP server push it's

00:00:57,950 --> 00:01:02,270
produced over push is basically adding

00:01:00,200 --> 00:01:03,800
bundling like you would do with a web

00:01:02,270 --> 00:01:06,560
pack or browserify all these things into

00:01:03,800 --> 00:01:09,740
the protocol layer it's a introduces a

00:01:06,560 --> 00:01:11,960
new semantics into the protocol most of

00:01:09,740 --> 00:01:14,090
the other stuff in HP two is really just

00:01:11,960 --> 00:01:15,470
the same as HTTP 1.1 but better so you

00:01:14,090 --> 00:01:17,479
get marginal improvements in performance

00:01:15,470 --> 00:01:21,920
but would a to b to server push you can

00:01:17,479 --> 00:01:24,020
achieve much greater advantages so lots

00:01:21,920 --> 00:01:26,570
of different little little uh you know

00:01:24,020 --> 00:01:29,960
pros and cons up my plusses for a server

00:01:26,570 --> 00:01:32,930
push over the legacy file concatenation

00:01:29,960 --> 00:01:34,729
I guess you'd call it so its native in

00:01:32,930 --> 00:01:36,680
the browser so the browser can optimize

00:01:34,729 --> 00:01:38,990
it it works for any file and not just

00:01:36,680 --> 00:01:43,580
JavaScript or CSS or images it just

00:01:38,990 --> 00:01:45,860
works blindly across it all you can cash

00:01:43,580 --> 00:01:48,380
individual files and update just those

00:01:45,860 --> 00:01:49,670
ones rather than an entire bundle and it

00:01:48,380 --> 00:01:51,110
works on a foot on the very first

00:01:49,670 --> 00:01:53,299
request so you don't have to like load

00:01:51,110 --> 00:01:54,590
the HTML and then serve your

00:01:53,299 --> 00:01:56,540
concatenated file you can serve

00:01:54,590 --> 00:01:59,780
everything from the straight from the

00:01:56,540 --> 00:02:00,799
first response all right and you know

00:01:59,780 --> 00:02:03,110
falcon combination we're all familiar

00:02:00,799 --> 00:02:05,560
with some of the problems that it has so

00:02:03,110 --> 00:02:08,599
i want to show you basically how a

00:02:05,560 --> 00:02:10,249
server push request flow goes real quick

00:02:08,599 --> 00:02:11,989
so you get a request coming in from a

00:02:10,249 --> 00:02:13,440
browser to your web server let's say for

00:02:11,989 --> 00:02:15,120
/ for the home

00:02:13,440 --> 00:02:16,230
page what's going to happen is your

00:02:15,120 --> 00:02:17,460
observer is going to analyze that and

00:02:16,230 --> 00:02:18,690
say okay you know if you're looking for

00:02:17,460 --> 00:02:20,400
the home page you're probably gonna need

00:02:18,690 --> 00:02:22,260
a fab you con as well so I'm going to

00:02:20,400 --> 00:02:23,760
serve you a fake request because that's

00:02:22,260 --> 00:02:25,350
what a promise is it's a fake request

00:02:23,760 --> 00:02:27,000
not just a response with a request first

00:02:25,350 --> 00:02:29,310
and it's going to say I'm going to put

00:02:27,000 --> 00:02:30,720
it on another HP to stream HP has lots

00:02:29,310 --> 00:02:33,660
of different streams they all go over

00:02:30,720 --> 00:02:36,810
the same socket but just keep that a

00:02:33,660 --> 00:02:38,250
concept in mind but it can push lots of

00:02:36,810 --> 00:02:39,540
lots of different promises right lots of

00:02:38,250 --> 00:02:42,120
different requests I did anticipating

00:02:39,540 --> 00:02:43,470
the client to make finally it's going to

00:02:42,120 --> 00:02:45,300
serve the actual response to the

00:02:43,470 --> 00:02:47,010
original request it's going to serve the

00:02:45,300 --> 00:02:48,810
headers in the body and then once that's

00:02:47,010 --> 00:02:51,240
once the browser has that it's going to

00:02:48,810 --> 00:02:52,590
start pushing all those promises so now

00:02:51,240 --> 00:02:55,650
it's serving the responses to these

00:02:52,590 --> 00:02:57,090
requests that it pretended occurred so

00:02:55,650 --> 00:03:00,030
those I'll go over it over the wire and

00:02:57,090 --> 00:03:02,010
we've got a lot of these streams going

00:03:00,030 --> 00:03:04,320
on independently so you can prioritize

00:03:02,010 --> 00:03:06,240
things you can schedule things it's

00:03:04,320 --> 00:03:08,250
pretty cool so let's see what we can do

00:03:06,240 --> 00:03:11,100
we've got a tool called HTTP to server

00:03:08,250 --> 00:03:13,980
and let's do a little demo see what

00:03:11,100 --> 00:03:16,350
happens if we try to sum in comparison

00:03:13,980 --> 00:03:18,840
to previous practices I've taken one of

00:03:16,350 --> 00:03:21,209
Simon Swain's epic projects from last

00:03:18,840 --> 00:03:25,260
year's conference and I want to see how

00:03:21,209 --> 00:03:27,120
how fast it works with HB 2 versus hp1

00:03:25,260 --> 00:03:28,850
concatenation here on the left-hand side

00:03:27,120 --> 00:03:33,630
I've got a browser simulating a

00:03:28,850 --> 00:03:35,580
connection from Singapore to San

00:03:33,630 --> 00:03:37,800
Francisco that's roughly you know 300

00:03:35,580 --> 00:03:39,450
milliseconds of artificial latency but

00:03:37,800 --> 00:03:41,340
I've got a gigabit connection because

00:03:39,450 --> 00:03:42,630
Singapore's pretty good like that but

00:03:41,340 --> 00:03:46,290
what's going to happen with this latency

00:03:42,630 --> 00:03:48,750
if we run a server that serves the HTTP

00:03:46,290 --> 00:03:50,540
one version of the project which has a

00:03:48,750 --> 00:03:54,120
lot of jobs with clouds and some CSS and

00:03:50,540 --> 00:03:55,590
then we load that page that extra

00:03:54,120 --> 00:03:58,940
latency is going to force a lot of round

00:03:55,590 --> 00:04:02,100
trips so we've seeing this graph here

00:03:58,940 --> 00:04:03,600
this traditional waterfall the green

00:04:02,100 --> 00:04:05,160
parts are basically the latency on the

00:04:03,600 --> 00:04:06,239
network there's very little time

00:04:05,160 --> 00:04:08,489
actually transferring because I've got a

00:04:06,239 --> 00:04:11,130
gigabit right but the latency is going

00:04:08,489 --> 00:04:12,959
to kill my app look at that so it's

00:04:11,130 --> 00:04:15,360
taking like four seconds all right so

00:04:12,959 --> 00:04:17,250
let's see what happens with HTTP two if

00:04:15,360 --> 00:04:18,859
I runnin HP to server I'll have to do is

00:04:17,250 --> 00:04:21,840
this and by the way to the HP to server

00:04:18,859 --> 00:04:23,160
it's blind to any kind of file type so i

00:04:21,840 --> 00:04:24,870
don't have to configure you know

00:04:23,160 --> 00:04:27,280
complicated gulp script or a web pack

00:04:24,870 --> 00:04:31,240
config it just serves everything in

00:04:27,280 --> 00:04:34,300
pushes it very easy so let me turn off

00:04:31,240 --> 00:04:37,570
this cpu monster all right and go over

00:04:34,300 --> 00:04:38,889
to the HP to site run that and see what

00:04:37,570 --> 00:04:40,720
happens it's got its got one or cuts and

00:04:38,889 --> 00:04:43,480
it's pushing tons of files all those

00:04:40,720 --> 00:04:45,820
requests are now getting pushed how long

00:04:43,480 --> 00:04:48,340
did I take about the same oh that's not

00:04:45,820 --> 00:04:50,380
good right so why is that so there's a

00:04:48,340 --> 00:04:52,300
lot of that it goes up if you look at

00:04:50,380 --> 00:04:53,800
this left here is excruciatingly Lee

00:04:52,300 --> 00:04:55,780
slow right you get a request and then

00:04:53,800 --> 00:04:59,260
you know if a vivir con takes 100 5

00:04:55,780 --> 00:05:01,870
milliseconds what's hell so this server

00:04:59,260 --> 00:05:03,340
is optimizing your files with you know

00:05:01,870 --> 00:05:04,690
complicated compression that takes about

00:05:03,340 --> 00:05:06,160
a hundred times longer than gzip so it's

00:05:04,690 --> 00:05:07,450
not meant to be streaming so when you

00:05:06,160 --> 00:05:09,730
start the server it's gonna have a cold

00:05:07,450 --> 00:05:11,440
cash when you're running this again and

00:05:09,730 --> 00:05:12,970
again it's going to start warming up the

00:05:11,440 --> 00:05:14,290
cash you know keeping all these assets

00:05:12,970 --> 00:05:16,510
in memory and a compressed State and

00:05:14,290 --> 00:05:18,820
eliminate all of that so let's say we

00:05:16,510 --> 00:05:22,030
clear the log the server is still

00:05:18,820 --> 00:05:24,250
running and we can go back caching is

00:05:22,030 --> 00:05:26,680
disabled you can see and run it again

00:05:24,250 --> 00:05:28,690
BAM how fast was that right so

00:05:26,680 --> 00:05:32,440
everything is now like you know 0 0 1

00:05:28,690 --> 00:05:34,479
millisecond and on the network it took a

00:05:32,440 --> 00:05:36,220
second so we're three times faster just

00:05:34,479 --> 00:05:38,620
eliminating all the latency that's what

00:05:36,220 --> 00:05:40,330
server push will do you get one shot of

00:05:38,620 --> 00:05:41,320
latency that's the minimal amount of

00:05:40,330 --> 00:05:42,580
latency that you're going to have to

00:05:41,320 --> 00:05:44,110
accept because that's just your network

00:05:42,580 --> 00:05:46,300
but everything else can be eliminated

00:05:44,110 --> 00:05:48,970
with HP server push rest concatenation

00:05:46,300 --> 00:05:50,470
cannot do this so all right that's

00:05:48,970 --> 00:05:56,200
pretty good result let's talk about how

00:05:50,470 --> 00:05:57,850
that actually works go back so our page

00:05:56,200 --> 00:06:00,190
load time is really a function of

00:05:57,850 --> 00:06:01,570
latency and bandwidth there's a it's

00:06:00,190 --> 00:06:02,919
called a bandwidth delay product if you

00:06:01,570 --> 00:06:04,180
wanna look this up you know basically

00:06:02,919 --> 00:06:05,740
the product of your data link capacity

00:06:04,180 --> 00:06:07,990
that's like your aggregate band was like

00:06:05,740 --> 00:06:09,940
a gigabit per second and your round trip

00:06:07,990 --> 00:06:11,440
time measured in seconds would be you

00:06:09,940 --> 00:06:15,310
know point three seconds from here to

00:06:11,440 --> 00:06:18,430
you know west coast of us this is called

00:06:15,310 --> 00:06:20,560
the long fast networks I'm not sure it's

00:06:18,430 --> 00:06:22,440
called 11 or elephant I like elephants

00:06:20,560 --> 00:06:24,669
so I'm going to call it elephants and

00:06:22,440 --> 00:06:25,720
this is a common case for most people

00:06:24,669 --> 00:06:26,770
around the world nowadays that you have

00:06:25,720 --> 00:06:28,030
a data center that's around the world

00:06:26,770 --> 00:06:30,010
and you yourself have a very

00:06:28,030 --> 00:06:32,140
high-powered mobile device and you're

00:06:30,010 --> 00:06:34,990
probably on a pretty speedy 4G

00:06:32,140 --> 00:06:37,270
connection or beyond going forward and

00:06:34,990 --> 00:06:38,950
we need to optimize the latency so how

00:06:37,270 --> 00:06:40,700
does a to do that we saw it basically

00:06:38,950 --> 00:06:41,990
cuts out your graph

00:06:40,700 --> 00:06:44,090
you know left-hand side loads in one

00:06:41,990 --> 00:06:45,470
second if you have a lot of latency take

00:06:44,090 --> 00:06:48,140
like an order of magnitude more than

00:06:45,470 --> 00:06:50,840
that just because requests induce and

00:06:48,140 --> 00:06:52,460
compound this latency so that's pretty

00:06:50,840 --> 00:06:54,380
sweet what else can we do to eliminate

00:06:52,460 --> 00:06:56,330
well the other half the product would be

00:06:54,380 --> 00:06:58,010
the bandwidth if you can if you can get

00:06:56,330 --> 00:07:00,260
free bandwidth from compression and this

00:06:58,010 --> 00:07:02,000
magical thing called cash digests that

00:07:00,260 --> 00:07:03,650
will help a lot so let's let's look at

00:07:02,000 --> 00:07:06,470
that so I mentioned that we doing this

00:07:03,650 --> 00:07:08,480
very fancy compression it introduces a

00:07:06,470 --> 00:07:11,240
massive load of you know computational

00:07:08,480 --> 00:07:13,010
demand on the server but you know but

00:07:11,240 --> 00:07:15,290
caching we can we can avoid you know any

00:07:13,010 --> 00:07:17,330
kind of performance impact and the two

00:07:15,290 --> 00:07:18,620
codecs that i'm using here zup flea or

00:07:17,330 --> 00:07:21,260
zip fly I don't know how it could

00:07:18,620 --> 00:07:22,460
pronounce it basically that's compatible

00:07:21,260 --> 00:07:24,980
with gzip so any browser that supports

00:07:22,460 --> 00:07:26,900
gzip it's going to support this slightly

00:07:24,980 --> 00:07:29,390
more compressed version of your output

00:07:26,900 --> 00:07:31,970
but if you're using let's say Firefox or

00:07:29,390 --> 00:07:34,550
Chrome you can support broadly and

00:07:31,970 --> 00:07:36,320
that's going to save significant amounts

00:07:34,550 --> 00:07:39,080
of bandwidth now it's only working on

00:07:36,320 --> 00:07:41,450
HTTPS if you hadn't if you notice that

00:07:39,080 --> 00:07:42,950
in the the demo data showed the HTTP one

00:07:41,450 --> 00:07:45,710
version was just you know playing static

00:07:42,950 --> 00:07:48,260
web server running on HTTP but the HTTP

00:07:45,710 --> 00:07:49,670
two one had to run on HTTPS and one of

00:07:48,260 --> 00:07:51,110
the troubles that I think a lot of

00:07:49,670 --> 00:07:52,460
developers are familiar with is setting

00:07:51,110 --> 00:07:54,440
up like certificates for localhost

00:07:52,460 --> 00:07:56,360
development getting the sign adding the

00:07:54,440 --> 00:07:57,950
exceptions to your browser to pain so

00:07:56,360 --> 00:07:59,810
I've kind of taken care of that it's

00:07:57,950 --> 00:08:02,060
when you run HP server the first time

00:07:59,810 --> 00:08:03,620
it'll register generator tificate hook

00:08:02,060 --> 00:08:05,540
it up to your keychain and your browser

00:08:03,620 --> 00:08:07,250
will just have a green secure website

00:08:05,540 --> 00:08:08,780
thing it's fantastic so even if you just

00:08:07,250 --> 00:08:12,830
use it for that you're gonna have a good

00:08:08,780 --> 00:08:15,020
time next we've got cash digests to save

00:08:12,830 --> 00:08:17,270
us then say for some bandwidth and this

00:08:15,020 --> 00:08:19,370
is huge and this is new to me until like

00:08:17,270 --> 00:08:22,220
a month ago I not a computer science

00:08:19,370 --> 00:08:24,680
type of person so I didn't know anything

00:08:22,220 --> 00:08:27,170
about bloom filters and I was like lord

00:08:24,680 --> 00:08:30,200
of the rings gollum coded bloom filters

00:08:27,170 --> 00:08:31,850
it's a thing right but basically right

00:08:30,200 --> 00:08:33,500
what we're doing is we're telling the

00:08:31,850 --> 00:08:36,170
server which files we've already got

00:08:33,500 --> 00:08:38,390
cached and we're basically hashing

00:08:36,170 --> 00:08:40,520
fingerprinting every file or just the

00:08:38,390 --> 00:08:42,110
URL taking a couple of bits from that

00:08:40,520 --> 00:08:44,330
sticking them all together into a little

00:08:42,110 --> 00:08:45,710
header and telling the server here this

00:08:44,330 --> 00:08:47,300
is these are the files we have anything

00:08:45,710 --> 00:08:48,500
y'all anything that matches that that

00:08:47,300 --> 00:08:50,660
you're trying to push me just don't push

00:08:48,500 --> 00:08:52,220
it so essentially we're skipping all of

00:08:50,660 --> 00:08:53,630
the unnecessary files that haven't

00:08:52,220 --> 00:08:54,529
changed since the last time I visited a

00:08:53,630 --> 00:08:56,389
page he

00:08:54,529 --> 00:08:58,670
savings because most of times not your

00:08:56,389 --> 00:09:00,949
entire app is changing tiny parts of

00:08:58,670 --> 00:09:01,910
your code base incrementally evolve but

00:09:00,949 --> 00:09:04,759
most of the libraries and frameworks

00:09:01,910 --> 00:09:06,560
they're not changing all the time so

00:09:04,759 --> 00:09:08,689
that's basically how it works that's

00:09:06,560 --> 00:09:10,999
what it's meant to do there's a speck

00:09:08,689 --> 00:09:15,319
pretty recent from this year that's

00:09:10,999 --> 00:09:17,120
doing this all over HTTP frames I'm

00:09:15,319 --> 00:09:18,529
using because if the browser knee

00:09:17,120 --> 00:09:19,910
support that natively I'm using a

00:09:18,529 --> 00:09:22,249
service worker for Chrome and Firefox

00:09:19,910 --> 00:09:24,139
and a cookie fallback so it works on

00:09:22,249 --> 00:09:25,519
every single browser right now which is

00:09:24,139 --> 00:09:26,809
pretty cool so we save a lot of

00:09:25,519 --> 00:09:27,860
bandwidth and we save a lot of latency

00:09:26,809 --> 00:09:31,029
whether i do because all these round

00:09:27,860 --> 00:09:34,249
trips are now eliminated so second tool

00:09:31,029 --> 00:09:36,199
that I've got for you is called unbundle

00:09:34,249 --> 00:09:38,089
and I'll show you a little demo of that

00:09:36,199 --> 00:09:39,879
as well this is going to help you with

00:09:38,089 --> 00:09:41,720
the front-end development side of things

00:09:39,879 --> 00:09:43,579
everyone's familiar with the JavaScript

00:09:41,720 --> 00:09:46,490
fatigue so let's let's set up a little

00:09:43,579 --> 00:09:49,910
imaginary tiny little hello world

00:09:46,490 --> 00:09:51,800
project so we know we want to use proper

00:09:49,910 --> 00:09:55,069
tools we've got react framework from NPM

00:09:51,800 --> 00:09:57,379
which is awesome and p.m. i mean i'm not

00:09:55,069 --> 00:10:00,199
really react whatever each their own and

00:09:57,379 --> 00:10:03,500
I've got a minimalist application

00:10:00,199 --> 00:10:04,730
javascript HTML and there we go so what

00:10:03,500 --> 00:10:07,040
do we normally do we set up a web pack

00:10:04,730 --> 00:10:08,559
build or a gulp thing or you know who

00:10:07,040 --> 00:10:11,680
knows what right it's a lot of work

00:10:08,559 --> 00:10:15,439
let's cut all that short and say

00:10:11,680 --> 00:10:16,850
unbundle and it's going to run but you

00:10:15,439 --> 00:10:18,649
know this this computer has about the

00:10:16,850 --> 00:10:21,319
power of most people's phones if you

00:10:18,649 --> 00:10:23,540
bought them this year but yet it's going

00:10:21,319 --> 00:10:25,100
to be pretty quick right the reason is

00:10:23,540 --> 00:10:26,600
that it's doing all this stuff in

00:10:25,100 --> 00:10:28,850
parallel so I've got two cores in here

00:10:26,600 --> 00:10:30,649
no to physical cores so he's going to

00:10:28,850 --> 00:10:32,269
run you know parallel builds on this and

00:10:30,649 --> 00:10:34,459
it's tracing all of the files that we

00:10:32,269 --> 00:10:36,529
have which is all mostly react obviously

00:10:34,459 --> 00:10:39,379
this is one one of my own files and

00:10:36,529 --> 00:10:42,290
probably 170 files from react it

00:10:39,379 --> 00:10:44,660
processed them all and then we run HTTP

00:10:42,290 --> 00:10:47,929
to server and we're going to host that

00:10:44,660 --> 00:10:52,600
website maybe not okay I gotta kill the

00:10:47,929 --> 00:10:55,959
I don't give me a second here we go okay

00:10:52,600 --> 00:10:55,959
port issues

00:10:56,240 --> 00:11:01,620
here we go so we're running our server

00:10:58,530 --> 00:11:03,150
now and serving the files that we just

00:11:01,620 --> 00:11:04,680
created that's the static files and

00:11:03,150 --> 00:11:06,030
because these commands have nothing

00:11:04,680 --> 00:11:07,530
inherently to each other but they just

00:11:06,030 --> 00:11:09,540
assume you know sensible defaults so

00:11:07,530 --> 00:11:11,070
they kind of work well together you

00:11:09,540 --> 00:11:12,870
could use either one without theater so

00:11:11,070 --> 00:11:15,570
let's clear our browser no tricks up our

00:11:12,870 --> 00:11:19,770
sleeves and see what happens if we load

00:11:15,570 --> 00:11:21,840
our app okay like I said the first time

00:11:19,770 --> 00:11:23,700
the caching meets the load okay well it

00:11:21,840 --> 00:11:26,010
worked so we've got our es6 app we've

00:11:23,700 --> 00:11:28,260
got node modules it's all working it's

00:11:26,010 --> 00:11:30,480
pretty sweet and if we look at the log

00:11:28,260 --> 00:11:33,540
we can see there's a lot going on here

00:11:30,480 --> 00:11:35,190
what is that right but really we're

00:11:33,540 --> 00:11:38,700
using push just like before with the

00:11:35,190 --> 00:11:40,410
static cold war demo here we've got one

00:11:38,700 --> 00:11:42,120
request coming in at the top this get

00:11:40,410 --> 00:11:45,060
for the homepage and then we're just

00:11:42,120 --> 00:11:46,410
going to push app GS and a lot of emoji

00:11:45,060 --> 00:11:48,900
that's kind of interesting we'll talk

00:11:46,410 --> 00:11:49,800
about that but a lot of these node

00:11:48,900 --> 00:11:51,510
modules is you're going to push

00:11:49,800 --> 00:11:53,430
individually rather than like a web pack

00:11:51,510 --> 00:11:55,410
bundle everything in one in one blob

00:11:53,430 --> 00:11:56,430
it's all happening individually and at

00:11:55,410 --> 00:11:58,020
the end here does a service worker

00:11:56,430 --> 00:12:00,660
that's got something to do with the cash

00:11:58,020 --> 00:12:09,839
digests so that's kind of sweet let's

00:12:00,660 --> 00:12:12,000
let's jump back into the slides so this

00:12:09,839 --> 00:12:14,970
tool is all based on you know really

00:12:12,000 --> 00:12:17,339
incredible technology browser 54

00:12:14,970 --> 00:12:19,020
dependency tracing battle for doing a

00:12:17,339 --> 00:12:21,120
lot of the processing you know mapping

00:12:19,020 --> 00:12:23,360
the file paths and then finally using

00:12:21,120 --> 00:12:25,020
system jas behind the scenes to

00:12:23,360 --> 00:12:27,120
asynchronously load things in the

00:12:25,020 --> 00:12:28,860
browser you're not actually interacting

00:12:27,120 --> 00:12:29,880
with these tools any more reps tracting

00:12:28,860 --> 00:12:31,380
over them and building the next

00:12:29,880 --> 00:12:34,589
generation of tools for frontal

00:12:31,380 --> 00:12:36,780
development it's got a lot of stuff

00:12:34,589 --> 00:12:38,430
built in batteries included it's

00:12:36,780 --> 00:12:40,020
minified you got your source maps for

00:12:38,430 --> 00:12:42,180
your development and you've got all this

00:12:40,020 --> 00:12:44,490
latest syntax available for yourself to

00:12:42,180 --> 00:12:45,720
use normally this takes a lot of time I

00:12:44,490 --> 00:12:47,430
know I took a lot of time to learn all

00:12:45,720 --> 00:12:50,130
these things and set it all up now it's

00:12:47,430 --> 00:12:51,510
very easy like I said it's very it's

00:12:50,130 --> 00:12:53,190
going to be very fast especially if you

00:12:51,510 --> 00:12:54,450
like quad core or going forward or

00:12:53,190 --> 00:12:56,010
you're running this on a build server

00:12:54,450 --> 00:12:57,900
with like I mean it maybe have like 32

00:12:56,010 --> 00:12:59,520
cores on your bills or your builds going

00:12:57,900 --> 00:13:00,690
to be lightning fast it's got a watch

00:12:59,520 --> 00:13:04,380
mode as well for incremental build

00:13:00,690 --> 00:13:07,150
sticks milliseconds right happening in

00:13:04,380 --> 00:13:09,230
parallel it's pretty sweet all right

00:13:07,150 --> 00:13:11,540
like I said we're using service works

00:13:09,230 --> 00:13:13,340
using service workers that means it's

00:13:11,540 --> 00:13:15,140
got some little JavaScript running in

00:13:13,340 --> 00:13:17,810
the browser right it's like having a CDN

00:13:15,140 --> 00:13:19,430
on the clients machine the same it's

00:13:17,810 --> 00:13:21,410
using the cache API which is kind of a

00:13:19,430 --> 00:13:22,610
misnomer like it the more I started

00:13:21,410 --> 00:13:25,340
using it i'm more i figured out that

00:13:22,610 --> 00:13:28,790
this isn't really for caching it's kind

00:13:25,340 --> 00:13:30,410
of just a key value storage for requests

00:13:28,790 --> 00:13:31,970
and responses doesn't have any kind of

00:13:30,410 --> 00:13:34,610
complicated and if you have to have to

00:13:31,970 --> 00:13:36,740
implement all of the HTTP caching logic

00:13:34,610 --> 00:13:39,170
from scratch which isn't something

00:13:36,740 --> 00:13:40,610
everyone should be doing I feel so you

00:13:39,170 --> 00:13:43,280
can rely on something like that that's

00:13:40,610 --> 00:13:45,470
been that's already prepared to take

00:13:43,280 --> 00:13:47,030
care of that without errors now

00:13:45,470 --> 00:13:48,610
cache-control immutable is another

00:13:47,030 --> 00:13:51,170
recent spec that came out this year and

00:13:48,610 --> 00:13:53,570
it's going to tell the browser to never

00:13:51,170 --> 00:13:55,190
invalidate an asset that's kind of cool

00:13:53,570 --> 00:13:56,600
right if you have a asset that you

00:13:55,190 --> 00:13:58,760
guaranteed to never change like your

00:13:56,600 --> 00:14:00,320
file revving it you should your browser

00:13:58,760 --> 00:14:02,990
should isn't even going to check if it's

00:14:00,320 --> 00:14:05,930
you know out expired until that max age

00:14:02,990 --> 00:14:09,650
has a past but if you set like a file

00:14:05,930 --> 00:14:10,940
rift asset to expire in 10 years your

00:14:09,650 --> 00:14:13,310
browser is never going to be even doing

00:14:10,940 --> 00:14:14,630
round trip at all you can guarantee that

00:14:13,310 --> 00:14:16,310
you can rely on that and your servers

00:14:14,630 --> 00:14:17,630
wrkn is going to read it from cache put

00:14:16,310 --> 00:14:19,490
it in a digest your server is never

00:14:17,630 --> 00:14:22,400
going to push that file ever again so

00:14:19,490 --> 00:14:24,050
you save huge bandwidth of course you

00:14:22,400 --> 00:14:26,690
have to be careful with that so I'm only

00:14:24,050 --> 00:14:29,180
applying as the reft files now those

00:14:26,690 --> 00:14:31,220
emoji and the file names what's up with

00:14:29,180 --> 00:14:32,360
that well this is my solution to cache

00:14:31,220 --> 00:14:35,510
invalidation which is the hardest

00:14:32,360 --> 00:14:36,980
problem in computer science and I think

00:14:35,510 --> 00:14:40,760
I'm owed your the solution to most hard

00:14:36,980 --> 00:14:42,460
problems i'm using x.x hash 64 which is

00:14:40,760 --> 00:14:44,990
really really fast fingerprinting

00:14:42,460 --> 00:14:46,970
algorithm and then encoding that in

00:14:44,990 --> 00:14:49,820
emoji right because it's just bits and

00:14:46,970 --> 00:14:51,440
why not you know hex is so lame so you

00:14:49,820 --> 00:14:52,640
stick an emotion there we need to change

00:14:51,440 --> 00:14:55,280
your file is going to come up with the

00:14:52,640 --> 00:14:56,840
new emoji and to the browser it's all

00:14:55,280 --> 00:14:57,920
transparent this works you know I'm

00:14:56,840 --> 00:15:00,280
surprised there wasn't actually any

00:14:57,920 --> 00:15:02,240
serious issues with this many tools

00:15:00,280 --> 00:15:06,350
showed us to some people and they liked

00:15:02,240 --> 00:15:08,240
it as well so that's my two projects and

00:15:06,350 --> 00:15:09,800
I hope you enjoy them I enjoyed working

00:15:08,240 --> 00:15:11,790
on them and I think this is the future

00:15:09,800 --> 00:15:13,850
thank you

00:15:11,790 --> 00:15:13,850

YouTube URL: https://www.youtube.com/watch?v=BPcjN_1qsdA


