Title: James Kyle: From Zero To Binary Search Tree - JSConf.Asia 2016
Publication date: 2016-12-17
Playlist: JSConf.Asia 2016
Description: 
	We don’t have a whole lot of data structures here in JavaScript world, but there’s a whole world of super useful data structures out there. In this talk we're going to learn all about the fundamental data structures. Hash Tables, Arrays, Stacks, Queues, Linked Lists, and Binary Search Trees, we won’t just learn them, we’re going to build them. When we’re done you’ll be impressing all your friends with your mad structured data skills.

James is an engineer at Facebook as well as a core contributor to projects like Yarn, BabelJS and Lerna. Outside of work James is trying to make computer science more approachable to front-end developers.


JSConf.Asia - Capitol Theatre, Singapore - 25+26 November 2016.

Source: https://2016.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:00,290 --> 00:00:27,710
ah there we go hi jas conf Asia I'm

00:00:23,960 --> 00:00:29,000
James Kyle i work at facebook i work on

00:00:27,710 --> 00:00:30,410
the flow team where we're trying to make

00:00:29,000 --> 00:00:33,290
developers happier and more productive

00:00:30,410 --> 00:00:34,880
writing JavaScript so that you can all

00:00:33,290 --> 00:00:37,820
go out and write more code that we need

00:00:34,880 --> 00:00:39,410
to install I also started this project

00:00:37,820 --> 00:00:41,360
called Babel which was designed to

00:00:39,410 --> 00:00:43,580
convince people they need to install 400

00:00:41,360 --> 00:00:46,730
packages so that just so they have

00:00:43,580 --> 00:00:48,140
pretty-looking syntax I also helped

00:00:46,730 --> 00:00:49,460
build this project called learner so

00:00:48,140 --> 00:00:51,260
that's easier to create a bunch of

00:00:49,460 --> 00:00:53,000
packages that need to be installed and

00:00:51,260 --> 00:00:55,040
then finally I helped launch this

00:00:53,000 --> 00:00:56,720
project called yarn which takes the four

00:00:55,040 --> 00:00:58,690
billion packages we just created it

00:00:56,720 --> 00:01:00,739
makes it way faster to install them

00:00:58,690 --> 00:01:02,360
anyways if you wanna make a bad decision

00:01:00,739 --> 00:01:06,500
you can follow me on twitter at the

00:01:02,360 --> 00:01:09,080
james Kyle this is my first time in

00:01:06,500 --> 00:01:13,370
Singapore and I must say it's really

00:01:09,080 --> 00:01:15,110
freaking hot I'm dying out there I'm

00:01:13,370 --> 00:01:21,380
from Boston so I'm much more comfortable

00:01:15,110 --> 00:01:24,740
in weather like this yeah anyways so I

00:01:21,380 --> 00:01:27,680
know what you're probably thinking data

00:01:24,740 --> 00:01:30,500
structures are awesome and you're right

00:01:27,680 --> 00:01:33,200
because they're very important not just

00:01:30,500 --> 00:01:35,299
to pass computer science 101 but in

00:01:33,200 --> 00:01:37,610
order to be a better programmer knowing

00:01:35,299 --> 00:01:39,950
your data structures can help you manage

00:01:37,610 --> 00:01:42,860
complexity and make your programs easier

00:01:39,950 --> 00:01:46,280
to follow and build highly performant

00:01:42,860 --> 00:01:48,350
memory efficient programs the first of

00:01:46,280 --> 00:01:50,810
those is I believe to be more important

00:01:48,350 --> 00:01:52,070
using the right data structure can

00:01:50,810 --> 00:01:54,130
drastically simplify what would

00:01:52,070 --> 00:01:56,659
otherwise be really complicated logic

00:01:54,130 --> 00:01:58,700
the second point is important too if

00:01:56,659 --> 00:02:00,290
performance our memory matters then

00:01:58,700 --> 00:02:03,830
using the right data structure is more

00:02:00,290 --> 00:02:07,280
than often essential so what are data

00:02:03,830 --> 00:02:08,899
structures essentially they are

00:02:07,280 --> 00:02:10,669
different methods of storing and

00:02:08,899 --> 00:02:13,579
organizing data that serve a number of

00:02:10,669 --> 00:02:14,210
different needs data can always be

00:02:13,579 --> 00:02:16,370
represented

00:02:14,210 --> 00:02:18,770
many different ways however depending on

00:02:16,370 --> 00:02:20,600
what your code or what your data is and

00:02:18,770 --> 00:02:22,820
what you need to do with it one

00:02:20,600 --> 00:02:24,980
representation will pretty much always

00:02:22,820 --> 00:02:26,510
be a better choice than the others to

00:02:24,980 --> 00:02:30,530
understand why let's first talk about

00:02:26,510 --> 00:02:32,360
algorithms algorithms is just a fancy

00:02:30,530 --> 00:02:34,880
name for a step-by-step set of

00:02:32,360 --> 00:02:36,410
operations to be performed data

00:02:34,880 --> 00:02:38,690
structures are often implemented with

00:02:36,410 --> 00:02:41,210
algorithms and algorithms I'm go to data

00:02:38,690 --> 00:02:43,250
structures and just data structures and

00:02:41,210 --> 00:02:45,770
algorithms all the way down until you

00:02:43,250 --> 00:02:46,790
reach the tiny microscopic people with

00:02:45,770 --> 00:02:50,450
the punch cards that control the

00:02:46,790 --> 00:02:54,080
computer yeah it's not by code it's it's

00:02:50,450 --> 00:02:55,580
it's these people any given task can be

00:02:54,080 --> 00:02:58,130
implemented an infinite number of ways

00:02:55,580 --> 00:02:59,660
so for common tasks are often many

00:02:58,130 --> 00:03:02,600
different algorithms people have come up

00:02:59,660 --> 00:03:04,700
with for example there is an absurd

00:03:02,600 --> 00:03:07,520
number of algorithms for sorting a set

00:03:04,700 --> 00:03:10,460
of unordered items there's insertion

00:03:07,520 --> 00:03:13,810
short there's selection sort merge sort

00:03:10,460 --> 00:03:19,640
bubble sort heap sort quicksort

00:03:13,810 --> 00:03:22,640
shellsort Tim sort bucket sort and

00:03:19,640 --> 00:03:24,470
there's more but you get the point some

00:03:22,640 --> 00:03:27,170
of these are significantly faster than

00:03:24,470 --> 00:03:28,940
others some use less memory some are

00:03:27,170 --> 00:03:31,490
easy to implement some are based of

00:03:28,940 --> 00:03:32,860
assumptions about the data set every

00:03:31,490 --> 00:03:35,960
single one of these will be better for

00:03:32,860 --> 00:03:38,090
something so you'll need to make a

00:03:35,960 --> 00:03:40,160
decision based on what your needs are

00:03:38,090 --> 00:03:42,760
and for that you'll need a way of

00:03:40,160 --> 00:03:44,900
comparing them a way to measure them

00:03:42,760 --> 00:03:46,970
when we compare the performance of

00:03:44,900 --> 00:03:48,350
algorithms we use a rough measurement of

00:03:46,970 --> 00:03:51,800
their average and worst-case performance

00:03:48,350 --> 00:03:54,530
using something called big o big o

00:03:51,800 --> 00:03:56,060
notation is a way to roughly measure the

00:03:54,530 --> 00:03:57,980
performance of algorithms in order to

00:03:56,060 --> 00:04:00,650
compare them against one another when

00:03:57,980 --> 00:04:02,870
discussing them Big O is a mathematical

00:04:00,650 --> 00:04:06,200
notation that we borrowed in computer

00:04:02,870 --> 00:04:08,210
science to classify algorithms by how

00:04:06,200 --> 00:04:11,000
they respond to the number of items that

00:04:08,210 --> 00:04:13,340
you give them there's two primary things

00:04:11,000 --> 00:04:15,470
that you measure what they go there's

00:04:13,340 --> 00:04:17,600
time complexity which refers to the

00:04:15,470 --> 00:04:20,590
total count of operations and algorithm

00:04:17,600 --> 00:04:23,450
will perform for a given set of items

00:04:20,590 --> 00:04:25,160
and then there's space complexity which

00:04:23,450 --> 00:04:26,630
refers to the total memory and algorithm

00:04:25,160 --> 00:04:30,350
will take up when running

00:04:26,630 --> 00:04:33,380
on a given set of items we measure these

00:04:30,350 --> 00:04:36,020
independently from one another because

00:04:33,380 --> 00:04:38,420
while an algorithm may perform less

00:04:36,020 --> 00:04:41,210
operations than another it may also take

00:04:38,420 --> 00:04:43,640
up way more memory depending on what

00:04:41,210 --> 00:04:46,310
your requirements are one may be a

00:04:43,640 --> 00:04:48,440
better choice in the other so these are

00:04:46,310 --> 00:04:52,280
some of the common big O's we have their

00:04:48,440 --> 00:04:54,410
name and their number or notation and

00:04:52,280 --> 00:05:00,080
how you feel when they show up at your

00:04:54,410 --> 00:05:02,690
party uninvited first you have constant

00:05:00,080 --> 00:05:04,790
or 0 1 which means it's always going to

00:05:02,690 --> 00:05:06,620
take the same amount of operations and

00:05:04,790 --> 00:05:10,540
when you see this friend walk in your

00:05:06,620 --> 00:05:14,270
leg we need to take a selfie right now

00:05:10,540 --> 00:05:16,310
the next is logarithmic or o log of n

00:05:14,270 --> 00:05:18,680
which means the number of operations

00:05:16,310 --> 00:05:20,780
increases very slowly as you add more

00:05:18,680 --> 00:05:23,420
items and when this friend shows up

00:05:20,780 --> 00:05:27,500
your leg hey let me get you a drink

00:05:23,420 --> 00:05:29,480
let's do this up next is linear or 0 n

00:05:27,500 --> 00:05:31,310
which means the number of operations

00:05:29,480 --> 00:05:33,590
increases at the same rate as a number

00:05:31,310 --> 00:05:37,100
of items and when this person shows up

00:05:33,590 --> 00:05:39,920
you're like oh hey how's it going it's

00:05:37,100 --> 00:05:44,840
been a while we should catch up later

00:05:39,920 --> 00:05:49,000
when you're done running next is linear

00:05:44,840 --> 00:05:52,340
if Mick or a log at our 0 n log of n

00:05:49,000 --> 00:05:54,320
where the number of operations increases

00:05:52,340 --> 00:05:56,480
a bit faster than the rate that linear

00:05:54,320 --> 00:05:59,240
does and when this person shows up

00:05:56,480 --> 00:06:04,640
you're like who brought them they smell

00:05:59,240 --> 00:06:07,370
like soup next is polynomial or 0 n to

00:06:04,640 --> 00:06:09,680
the power of 2 where the number of

00:06:07,370 --> 00:06:13,220
operations increases exponentially and

00:06:09,680 --> 00:06:15,170
quickly gets to be too many when this

00:06:13,220 --> 00:06:17,360
person shows up you get all in their

00:06:15,170 --> 00:06:20,060
face like salty you're like I don't

00:06:17,360 --> 00:06:21,620
remember inviting you I was like really

00:06:20,060 --> 00:06:24,920
drunk the other day so maybe I did

00:06:21,620 --> 00:06:29,570
invite you then but didn't want you here

00:06:24,920 --> 00:06:32,210
and last is factorial or 0 factorial of

00:06:29,570 --> 00:06:34,669
n where the number of operations just

00:06:32,210 --> 00:06:36,560
shoots like straight up getting into the

00:06:34,669 --> 00:06:38,840
billions and trillions and quadriplegic

00:06:36,560 --> 00:06:40,400
aliens really really fast and when this

00:06:38,840 --> 00:06:42,350
person shows up and you're like

00:06:40,400 --> 00:06:44,870
I invite you for a very specific reason

00:06:42,350 --> 00:06:51,350
and that reason is I hate your guts so

00:06:44,870 --> 00:06:53,030
bye I'm a very mean party person to give

00:06:51,350 --> 00:06:55,030
you an idea of how many operations were

00:06:53,030 --> 00:06:57,620
talking about let's look at how these

00:06:55,030 --> 00:07:00,830
would equal what what these would equal

00:06:57,620 --> 00:07:04,039
for a given set of items with five items

00:07:00,830 --> 00:07:07,460
nothing is really that bad small number

00:07:04,039 --> 00:07:10,759
and we can do lots of operations so but

00:07:07,460 --> 00:07:13,100
by 10 items you're already got a pretty

00:07:10,759 --> 00:07:15,260
big difference for polynomial starting

00:07:13,100 --> 00:07:18,490
the millions of operations but

00:07:15,260 --> 00:07:23,240
everything else is mostly acceptable

00:07:18,490 --> 00:07:25,490
next ship 20 and it's getting absurd and

00:07:23,240 --> 00:07:28,880
then by 30 polynomial is just just

00:07:25,490 --> 00:07:30,410
ridiculous and you can already see how

00:07:28,880 --> 00:07:32,720
the other ones of those are already

00:07:30,410 --> 00:07:38,870
getting to be pretty large numbers for

00:07:32,720 --> 00:07:41,030
what could be like pretty low numbers so

00:07:38,870 --> 00:07:43,460
with data structures you have four

00:07:41,030 --> 00:07:47,440
primary types of actions that you can

00:07:43,460 --> 00:07:49,789
perform in sess search insert or delete

00:07:47,440 --> 00:07:51,380
and it's important to note that data

00:07:49,789 --> 00:07:55,550
structures may be good at one of these

00:07:51,380 --> 00:07:56,960
things and not at another and so here

00:07:55,550 --> 00:08:00,080
you can see three common types of

00:07:56,960 --> 00:08:02,690
ordered data structures arrays linked

00:08:00,080 --> 00:08:04,250
lists in binary search trees and you can

00:08:02,690 --> 00:08:07,010
see their average time complexity for

00:08:04,250 --> 00:08:09,919
the most common operations and here's

00:08:07,010 --> 00:08:12,050
them with our party descriptions even

00:08:09,919 --> 00:08:14,330
further some actions will have a

00:08:12,050 --> 00:08:16,580
different average performance in a

00:08:14,330 --> 00:08:18,289
worst-case performance meaning they

00:08:16,580 --> 00:08:20,840
perform very differently depending on

00:08:18,289 --> 00:08:23,150
the type of data set and sometimes

00:08:20,840 --> 00:08:25,490
random things are thrown in there but

00:08:23,150 --> 00:08:27,560
there is no perfect data structure and

00:08:25,490 --> 00:08:29,150
you choose one over the other based on

00:08:27,560 --> 00:08:30,620
the data that you're working with and

00:08:29,150 --> 00:08:33,169
the things that you're going to do with

00:08:30,620 --> 00:08:35,029
it this is why it's very important to

00:08:33,169 --> 00:08:36,770
know a number of different common data

00:08:35,029 --> 00:08:38,330
structures so that you can choose from

00:08:36,770 --> 00:08:42,169
them and know what you're getting

00:08:38,330 --> 00:08:44,779
yourself into a computer's memory is

00:08:42,169 --> 00:08:46,160
pretty boring it's just a bunch of

00:08:44,779 --> 00:08:49,100
ordered slots where you can store

00:08:46,160 --> 00:08:53,410
information you hold on to memory

00:08:49,100 --> 00:08:53,410
addresses in order to find information

00:08:53,620 --> 00:08:59,050
let's imagine a chunk of memory like

00:08:55,660 --> 00:09:00,940
this if you've ever wondered why things

00:08:59,050 --> 00:09:03,040
in programming languages are zero index

00:09:00,940 --> 00:09:05,620
sort of works kind of like memory in

00:09:03,040 --> 00:09:09,510
terms of like it starts at zero but ends

00:09:05,620 --> 00:09:12,250
at one so that's like the first item and

00:09:09,510 --> 00:09:15,040
so when we're reading a block of memory

00:09:12,250 --> 00:09:19,360
we're reading the space between 0 and 1

00:09:15,040 --> 00:09:21,660
or 1 and 2 and so on your computer

00:09:19,360 --> 00:09:24,670
obviously has way more memory than this

00:09:21,660 --> 00:09:30,070
we have to have some space to store all

00:09:24,670 --> 00:09:31,750
that JavaScript cached by code but it's

00:09:30,070 --> 00:09:34,930
pretty much a continuation of the

00:09:31,750 --> 00:09:37,420
pattern above memory is a bit like the

00:09:34,930 --> 00:09:39,730
Wild West every program running on your

00:09:37,420 --> 00:09:42,130
machine is stored in this same physical

00:09:39,730 --> 00:09:43,779
data structure and without layers of

00:09:42,130 --> 00:09:46,600
abstraction over it it can be pretty

00:09:43,779 --> 00:09:49,750
difficult to use and these abstractions

00:09:46,600 --> 00:09:51,670
serve two additional purposes storing

00:09:49,750 --> 00:09:53,740
data in memory in a way that is more

00:09:51,670 --> 00:09:55,660
efficient or faster to work with and

00:09:53,740 --> 00:09:59,950
storing data in a way that makes it

00:09:55,660 --> 00:10:02,170
easier to use so now that we've covered

00:09:59,950 --> 00:10:04,570
a lot of the basics I want to dive into

00:10:02,170 --> 00:10:07,029
some actual data structures and we're

00:10:04,570 --> 00:10:10,570
going to quickly cover lists hash tables

00:10:07,029 --> 00:10:14,290
stacks queues graphs linked lists trees

00:10:10,570 --> 00:10:15,970
and binary search trees we go through a

00:10:14,290 --> 00:10:18,040
lot of stuff and don't worry about

00:10:15,970 --> 00:10:19,959
understanding all of this code it's

00:10:18,040 --> 00:10:22,360
really only there to act as an aid to

00:10:19,959 --> 00:10:23,589
the things that I'm saying they're not

00:10:22,360 --> 00:10:25,959
even like really feature complete

00:10:23,589 --> 00:10:29,770
implementations so don't really worry

00:10:25,959 --> 00:10:31,959
about it but let's get into it so to

00:10:29,770 --> 00:10:33,610
demonstrate the raw interaction between

00:10:31,959 --> 00:10:36,459
memory and the data structure we're

00:10:33,610 --> 00:10:38,410
going to first implement a list list is

00:10:36,459 --> 00:10:40,839
a representation of an ordered sequence

00:10:38,410 --> 00:10:45,130
of values where the same value may

00:10:40,839 --> 00:10:48,279
appear many times because lists have an

00:10:45,130 --> 00:10:51,160
order you can insert insert stuff at the

00:10:48,279 --> 00:10:52,839
start middle or end of them for our

00:10:51,160 --> 00:10:54,970
implementation we're going to focus on

00:10:52,839 --> 00:10:56,740
adding and removing values from the

00:10:54,970 --> 00:10:59,580
start and end of our list using these

00:10:56,740 --> 00:11:01,839
four methods push pop on shift and shift

00:10:59,580 --> 00:11:04,060
which you should hope all hopefully be

00:11:01,839 --> 00:11:05,440
familiar with because I'm assuming most

00:11:04,060 --> 00:11:07,589
of you write JavaScript since you're

00:11:05,440 --> 00:11:07,589
here

00:11:08,550 --> 00:11:16,089
starting with push we need a way to add

00:11:11,410 --> 00:11:19,710
items to the end of our list actually

00:11:16,089 --> 00:11:22,690
skipped a bit here let me go back sorry

00:11:19,710 --> 00:11:25,420
we're gonna in our list we're going to

00:11:22,690 --> 00:11:26,560
start with a empty block of memory which

00:11:25,420 --> 00:11:28,750
we're just going to represent with a

00:11:26,560 --> 00:11:32,080
JavaScript array and we're also going to

00:11:28,750 --> 00:11:33,850
store the length of the list note that

00:11:32,080 --> 00:11:35,500
we want to store the length separately

00:11:33,850 --> 00:11:37,270
because in real life memory doesn't

00:11:35,500 --> 00:11:40,839
really have a length that you can read

00:11:37,270 --> 00:11:42,610
from so you want to remember that so

00:11:40,839 --> 00:11:44,890
starting with push we need a way to add

00:11:42,610 --> 00:11:47,050
items to the end of our list it's as

00:11:44,890 --> 00:11:49,510
simple as adding a value to the address

00:11:47,050 --> 00:11:51,040
at the end of our list and because we

00:11:49,510 --> 00:11:52,960
store it the length it's easy to

00:11:51,040 --> 00:11:56,290
calculate we just add the value and

00:11:52,960 --> 00:12:00,160
increment our length pushing an item to

00:11:56,290 --> 00:12:02,140
the end of the list is constant next we

00:12:00,160 --> 00:12:04,330
need to wait to pop items off the end of

00:12:02,140 --> 00:12:07,029
our list similar to push all we need is

00:12:04,330 --> 00:12:08,260
to remove the value at the address at

00:12:07,029 --> 00:12:10,990
the end of our list and then just

00:12:08,260 --> 00:12:13,950
decrement the length popping an item

00:12:10,990 --> 00:12:17,170
from the end of list is also constant

00:12:13,950 --> 00:12:19,209
push in pop both operate on the end of

00:12:17,170 --> 00:12:20,800
the list in our overall pretty simple

00:12:19,209 --> 00:12:23,770
operations because they don't need to be

00:12:20,800 --> 00:12:25,300
concerned with the rest of the list but

00:12:23,770 --> 00:12:26,589
let's see what happens when we operate

00:12:25,300 --> 00:12:31,180
at the beginning of the list with

00:12:26,589 --> 00:12:32,920
unshifted shift in order to add a new

00:12:31,180 --> 00:12:35,050
item at the beginning of the list we

00:12:32,920 --> 00:12:36,670
need to make room for our value we can't

00:12:35,050 --> 00:12:40,600
just keep going past the beginning of

00:12:36,670 --> 00:12:44,500
memory so we do this by shifting all of

00:12:40,600 --> 00:12:47,290
the items in our lists over by one in

00:12:44,500 --> 00:12:50,620
order to slide all of the items over we

00:12:47,290 --> 00:12:53,860
need to iterate over each one moving the

00:12:50,620 --> 00:12:56,589
previous value over because we have to

00:12:53,860 --> 00:12:58,810
over iterate over every single item in

00:12:56,589 --> 00:13:03,209
the list on shifting an item from the

00:12:58,810 --> 00:13:06,730
start of a list is linear so that o n

00:13:03,209 --> 00:13:08,770
first we start with the value at the

00:13:06,730 --> 00:13:11,709
beginning the list we iterate through

00:13:08,770 --> 00:13:14,530
each item replacing the current value

00:13:11,709 --> 00:13:17,250
with the previous value and storing the

00:13:14,530 --> 00:13:20,170
current value for the next iteration and

00:13:17,250 --> 00:13:21,940
then finally we just add the last item

00:13:20,170 --> 00:13:25,720
new position which is the start of our

00:13:21,940 --> 00:13:27,250
list and increment length finally when

00:13:25,720 --> 00:13:29,410
you write a shift function or to move in

00:13:27,250 --> 00:13:31,959
the opposite direction we delete the

00:13:29,410 --> 00:13:34,450
first value and then slide through every

00:13:31,959 --> 00:13:39,550
single item in a list to move it down

00:13:34,450 --> 00:13:42,790
one address shift is pretty much

00:13:39,550 --> 00:13:45,880
identical to on shift except backwards

00:13:42,790 --> 00:13:48,010
so the code is very similar and again

00:13:45,880 --> 00:13:53,230
shifting an item from the start of the

00:13:48,010 --> 00:13:55,779
list is linear so lists are great for

00:13:53,230 --> 00:13:58,360
fast access and dealing with items at

00:13:55,779 --> 00:13:59,709
the end of the list however as we've

00:13:58,360 --> 00:14:01,570
seen it's not great at dealing with

00:13:59,709 --> 00:14:03,790
items that are not at the end of the

00:14:01,570 --> 00:14:07,120
list and we have to manually hold on to

00:14:03,790 --> 00:14:08,920
memory addresses so let's take a look at

00:14:07,120 --> 00:14:11,199
a different data structure and see how

00:14:08,920 --> 00:14:13,089
it deals with adding accessing removing

00:14:11,199 --> 00:14:16,779
values without needing to know memory

00:14:13,089 --> 00:14:20,110
addresses so we'll talk about hash

00:14:16,779 --> 00:14:23,260
tables so hash tables don't have any

00:14:20,110 --> 00:14:26,490
order to them instead we have keys and

00:14:23,260 --> 00:14:33,910
values or a computed address in memory

00:14:26,490 --> 00:14:36,070
is its computed by the using the key so

00:14:33,910 --> 00:14:39,760
this is exactly what objects are in

00:14:36,070 --> 00:14:42,160
JavaScript the idea is that we have keys

00:14:39,760 --> 00:14:46,209
that are hashable which we'll get to in

00:14:42,160 --> 00:14:49,990
a second and can be used to add access

00:14:46,209 --> 00:14:51,190
and remove data very efficiently again

00:14:49,990 --> 00:14:54,839
we're just going to use a plain

00:14:51,190 --> 00:14:57,970
JavaScript array to represent our memory

00:14:54,839 --> 00:14:59,620
in order to store key value pairs in

00:14:57,970 --> 00:15:01,360
memory from our hash table we're going

00:14:59,620 --> 00:15:03,519
to need a way to turn them into an

00:15:01,360 --> 00:15:08,410
address we do this through an operation

00:15:03,519 --> 00:15:10,540
known as hashing all that happens is it

00:15:08,410 --> 00:15:13,180
takes a key and serialize it into a

00:15:10,540 --> 00:15:15,459
unique number for that key you have to

00:15:13,180 --> 00:15:18,069
be careful though if you had a really

00:15:15,459 --> 00:15:19,600
big key you don't want to member match

00:15:18,069 --> 00:15:22,300
it to a memory address that doesn't

00:15:19,600 --> 00:15:24,339
exist so the hashing algorithm needs to

00:15:22,300 --> 00:15:27,399
limit the size which means there's a

00:15:24,339 --> 00:15:31,300
limited number of addresses for an

00:15:27,399 --> 00:15:32,680
unlimited number of key value pairs the

00:15:31,300 --> 00:15:33,740
result is that you can end up with

00:15:32,680 --> 00:15:35,660
collisions

00:15:33,740 --> 00:15:39,020
places where two keys get turned into

00:15:35,660 --> 00:15:40,880
the same address any real world hash

00:15:39,020 --> 00:15:42,830
table implementation would have to deal

00:15:40,880 --> 00:15:44,150
with this however we're just going to

00:15:42,830 --> 00:15:47,960
kind of glaze over it and pretend that

00:15:44,150 --> 00:15:52,310
doesn't happen so let's set up our hash

00:15:47,960 --> 00:15:54,020
key function don't understand don't

00:15:52,310 --> 00:15:56,210
worry about understanding the logic of

00:15:54,020 --> 00:15:58,730
this function just know that it accepts

00:15:56,210 --> 00:16:01,310
a string and outputs a mostly unique

00:15:58,730 --> 00:16:07,370
address that we will use in our other

00:16:01,310 --> 00:16:08,990
functions next let's define our get

00:16:07,370 --> 00:16:12,110
function so that we have a way of

00:16:08,990 --> 00:16:16,730
accessing values by their key hash table

00:16:12,110 --> 00:16:18,260
access is constant yeah so we turn the

00:16:16,730 --> 00:16:22,370
key into an address and then get that

00:16:18,260 --> 00:16:24,830
address we also need a way of adding

00:16:22,370 --> 00:16:27,590
data before we access it so we create a

00:16:24,830 --> 00:16:29,480
set function that inserts value that

00:16:27,590 --> 00:16:32,660
does basically the same thing except

00:16:29,480 --> 00:16:36,170
setting at this time and setting and a

00:16:32,660 --> 00:16:38,420
hash table is constant friendly we need

00:16:36,170 --> 00:16:42,260
a way to remove items from our hash

00:16:38,420 --> 00:16:43,640
table which is just deleting the value

00:16:42,260 --> 00:16:46,340
at the memory address that was

00:16:43,640 --> 00:16:50,870
calculated by our hash key function in

00:16:46,340 --> 00:16:53,330
this operation is also constant from

00:16:50,870 --> 00:16:55,670
this point forward we're going to stop

00:16:53,330 --> 00:16:57,260
interacting directly with memory as the

00:16:55,670 --> 00:16:58,910
rest of these data structures start to

00:16:57,260 --> 00:17:01,970
be implemented with other data

00:16:58,910 --> 00:17:04,880
structures these data structures focus

00:17:01,970 --> 00:17:07,580
on doing two things organizing data

00:17:04,880 --> 00:17:10,850
based on how it's used and abstracting

00:17:07,580 --> 00:17:12,320
away implementation details these data

00:17:10,850 --> 00:17:14,210
structures focus on creating an

00:17:12,320 --> 00:17:16,880
organization which makes sense for

00:17:14,210 --> 00:17:18,800
various types of programs they insert a

00:17:16,880 --> 00:17:20,990
language that allows you to discuss more

00:17:18,800 --> 00:17:23,240
complicated logic all well abstracting

00:17:20,990 --> 00:17:25,010
away implementation details so that the

00:17:23,240 --> 00:17:30,680
implementation can change to be made

00:17:25,010 --> 00:17:33,170
much faster so stacks are similar to

00:17:30,680 --> 00:17:34,850
lists in that they have in order but

00:17:33,170 --> 00:17:36,440
they limit you to only pushing and

00:17:34,850 --> 00:17:39,530
popping values at the end of our list

00:17:36,440 --> 00:17:41,330
which as we saw before are very fast

00:17:39,530 --> 00:17:44,780
operations when mapping directly to

00:17:41,330 --> 00:17:46,580
memory however stacks can also be

00:17:44,780 --> 00:17:47,420
implemented with other data structures

00:17:46,580 --> 00:17:50,000
in order to add

00:17:47,420 --> 00:17:53,240
functionality to them the most common

00:17:50,000 --> 00:17:55,940
usage of stacks is places where you have

00:17:53,240 --> 00:17:57,260
one process adding items to the stack in

00:17:55,940 --> 00:17:59,420
another process removing them from the

00:17:57,260 --> 00:18:03,080
end prioritizing the items that were

00:17:59,420 --> 00:18:05,690
added most recently we're going to again

00:18:03,080 --> 00:18:08,060
be backed by a JavaScript array but this

00:18:05,690 --> 00:18:09,740
time it represents a list that we

00:18:08,060 --> 00:18:16,010
implemented before and rather than the

00:18:09,740 --> 00:18:17,980
memory that we were using often times

00:18:16,010 --> 00:18:20,060
people don't implement it with a list

00:18:17,980 --> 00:18:24,020
but we're going to you for the sake of

00:18:20,060 --> 00:18:26,690
this and we're going to implement the

00:18:24,020 --> 00:18:28,730
two functions from lists push and pop

00:18:26,690 --> 00:18:32,900
which are going to be identical in terms

00:18:28,730 --> 00:18:36,140
of functionality we push items to the

00:18:32,900 --> 00:18:37,610
top of the stack and pop items to remove

00:18:36,140 --> 00:18:40,250
items from the talk of the top of the

00:18:37,610 --> 00:18:42,350
stack we're also going to add a function

00:18:40,250 --> 00:18:43,850
just in order to view the item at the

00:18:42,350 --> 00:18:48,290
top of the stack without removing it

00:18:43,850 --> 00:18:50,330
from the stack next we're going to build

00:18:48,290 --> 00:18:54,350
a queue which is sort of complementary

00:18:50,330 --> 00:18:56,120
to a stack the difference is that this

00:18:54,350 --> 00:18:59,330
time you remove items from the start of

00:18:56,120 --> 00:19:00,920
the queue rather than the end removing

00:18:59,330 --> 00:19:04,400
the oldest items rather than the most

00:19:00,920 --> 00:19:06,140
recent again because this limits the

00:19:04,400 --> 00:19:08,420
amount of functionality there are many

00:19:06,140 --> 00:19:11,480
different ways of implementing it a good

00:19:08,420 --> 00:19:14,450
way might be a good way might to be used

00:19:11,480 --> 00:19:17,570
a linked list which will see a little

00:19:14,450 --> 00:19:19,400
bit later again our queue is just using

00:19:17,570 --> 00:19:22,310
a JavaScript array rather as a list

00:19:19,400 --> 00:19:23,930
rather than memory similar to stacks

00:19:22,310 --> 00:19:25,760
we're going to find two functions for

00:19:23,930 --> 00:19:28,700
adding and removing items from the queue

00:19:25,760 --> 00:19:32,450
the first is NQ that will push items to

00:19:28,700 --> 00:19:33,650
the end of our list in DQ which instead

00:19:32,450 --> 00:19:35,020
of removing them from the Edit list

00:19:33,650 --> 00:19:37,970
we're gonna remove them from the start

00:19:35,020 --> 00:19:39,410
and you could see we're using the shift

00:19:37,970 --> 00:19:42,350
function there which as I mentioned was

00:19:39,410 --> 00:19:45,830
not very fast but we're abstracting away

00:19:42,350 --> 00:19:48,470
to this functionality so that it could

00:19:45,830 --> 00:19:49,640
be implemented in many other ways and

00:19:48,470 --> 00:19:51,890
again we're just going to find a peek

00:19:49,640 --> 00:19:55,100
function from viewing the next item the

00:19:51,890 --> 00:20:00,560
queue the important thing to note here

00:19:55,100 --> 00:20:01,240
is again that we use a list of a car q

00:20:00,560 --> 00:20:05,020
in

00:20:01,240 --> 00:20:08,110
that performance of shift and you can

00:20:05,020 --> 00:20:11,350
use a linked list which we'll get to in

00:20:08,110 --> 00:20:13,570
a few seconds the next station structure

00:20:11,350 --> 00:20:16,060
is graphs note that these are very

00:20:13,570 --> 00:20:19,480
different than a visual graph that you

00:20:16,060 --> 00:20:22,450
would use to represent data instead

00:20:19,480 --> 00:20:26,140
imagine it like this we have a bunch of

00:20:22,450 --> 00:20:30,270
nodes ABCD and E that are connected with

00:20:26,140 --> 00:20:32,530
lines that sort of point to one another

00:20:30,270 --> 00:20:35,050
these nodes are going to look like this

00:20:32,530 --> 00:20:36,910
where they have a value and a set of

00:20:35,050 --> 00:20:40,300
lines that they're pointing to other

00:20:36,910 --> 00:20:41,950
nodes and the entire graph will look

00:20:40,300 --> 00:20:44,890
like this and it's going to just have

00:20:41,950 --> 00:20:49,210
all the nodes which will contain

00:20:44,890 --> 00:20:51,250
references to one another will hold on

00:20:49,210 --> 00:20:53,380
to all of our nodes in a regular

00:20:51,250 --> 00:20:55,300
JavaScript array not because there's any

00:20:53,380 --> 00:20:56,830
particular of order to the nodes but

00:20:55,300 --> 00:21:01,870
because we just need a way of storing

00:20:56,830 --> 00:21:03,940
them as references for everything we can

00:21:01,870 --> 00:21:09,100
start to add values to our graph by

00:21:03,940 --> 00:21:10,960
creating nodes without any lines next we

00:21:09,100 --> 00:21:13,090
need to be able to look up nodes in the

00:21:10,960 --> 00:21:14,920
graph most of the time you'll have a

00:21:13,090 --> 00:21:16,690
different data structure on top of the

00:21:14,920 --> 00:21:18,040
graph in order to make searching faster

00:21:16,690 --> 00:21:19,270
because otherwise you're just searching

00:21:18,040 --> 00:21:22,090
through every single node and that's

00:21:19,270 --> 00:21:23,410
kind of slow but for our case we're just

00:21:22,090 --> 00:21:25,870
simply going to go through every single

00:21:23,410 --> 00:21:30,580
node that we have and try matching the

00:21:25,870 --> 00:21:33,940
value next we can connect two nodes by

00:21:30,580 --> 00:21:35,980
making a line from one another we're

00:21:33,940 --> 00:21:38,470
going to find the nodes for each value

00:21:35,980 --> 00:21:39,700
that we have and then we're going to

00:21:38,470 --> 00:21:43,180
freak out if we don't have one on the

00:21:39,700 --> 00:21:45,310
other and finally we're going to add a

00:21:43,180 --> 00:21:50,650
reference to the end node from the start

00:21:45,310 --> 00:21:54,100
node finally you can use a graph like

00:21:50,650 --> 00:21:56,320
this this might seem like a lot of work

00:21:54,100 --> 00:21:58,600
to do very little but it's actually

00:21:56,320 --> 00:22:00,160
quite powerful pattern especially for

00:21:58,600 --> 00:22:03,460
finding sanity and really complex

00:22:00,160 --> 00:22:05,200
programs they do this by optima

00:22:03,460 --> 00:22:07,600
optimizing for the connections between

00:22:05,200 --> 00:22:10,150
data rather than operating on the data

00:22:07,600 --> 00:22:12,010
itself once you have a node in the graph

00:22:10,150 --> 00:22:13,990
it's really simple to find all the

00:22:12,010 --> 00:22:16,330
related items in the graph

00:22:13,990 --> 00:22:19,300
tons of things can be you can be

00:22:16,330 --> 00:22:21,970
represented this way users with friends

00:22:19,300 --> 00:22:24,400
the 800 transitive dependencies we have

00:22:21,970 --> 00:22:26,500
in a node modules folder the internet

00:22:24,400 --> 00:22:30,700
self is a graph of web pages connected

00:22:26,500 --> 00:22:32,860
together by links in next we're going to

00:22:30,700 --> 00:22:38,110
see how a graph like data structure can

00:22:32,860 --> 00:22:40,210
optimize an ordered list of data linked

00:22:38,110 --> 00:22:42,460
lists are a pretty common data structure

00:22:40,210 --> 00:22:43,690
it's often used to implement the other

00:22:42,460 --> 00:22:45,610
data structures as I mentioned before

00:22:43,690 --> 00:22:48,280
because of its ability to efficiently

00:22:45,610 --> 00:22:51,340
add items at the start middle or end of

00:22:48,280 --> 00:22:53,800
list the basic idea of linked lists is

00:22:51,340 --> 00:22:55,570
similar to a graph you have nodes that

00:22:53,800 --> 00:23:00,070
point to other nodes that sort of look

00:22:55,570 --> 00:23:01,990
like this and visualizing them as a data

00:23:00,070 --> 00:23:03,820
structure that looks like this where we

00:23:01,990 --> 00:23:05,620
have the value that points the next

00:23:03,820 --> 00:23:09,880
value which point to the next value but

00:23:05,620 --> 00:23:11,650
what's the next one unlike a graph a

00:23:09,880 --> 00:23:13,960
linked list has a single node that

00:23:11,650 --> 00:23:15,870
starts off the entire chain this is

00:23:13,960 --> 00:23:18,790
known as the head of the linked list

00:23:15,870 --> 00:23:23,710
we're also going to drink the track the

00:23:18,790 --> 00:23:26,140
length of the list here oops first we

00:23:23,710 --> 00:23:28,510
need a way to retrieve a value for in a

00:23:26,140 --> 00:23:31,030
given position this works differently

00:23:28,510 --> 00:23:33,520
than normal list because we can't just

00:23:31,030 --> 00:23:34,750
jump to the correct position instead we

00:23:33,520 --> 00:23:38,200
need to move through the individual

00:23:34,750 --> 00:23:40,420
nodes will start with the head of our

00:23:38,200 --> 00:23:42,550
list and then slide through all of the

00:23:40,420 --> 00:23:45,640
items using node next until we've

00:23:42,550 --> 00:23:48,900
reached a specified position and then

00:23:45,640 --> 00:23:51,640
we'll just return the node that we found

00:23:48,900 --> 00:23:54,309
next we need a way to add nodes to a

00:23:51,640 --> 00:23:56,530
specified position we're going for a

00:23:54,309 --> 00:24:00,309
generic add method that accepts a value

00:23:56,530 --> 00:24:03,309
into position first we create a node to

00:24:00,309 --> 00:24:05,290
hold our value and then we need to have

00:24:03,309 --> 00:24:08,800
a special case for nodes that are being

00:24:05,290 --> 00:24:10,870
inserted at the head will set the next

00:24:08,800 --> 00:24:15,550
field from the current head and replace

00:24:10,870 --> 00:24:18,160
it with our new node otherwise if we're

00:24:15,550 --> 00:24:19,720
adding a note in any other position we

00:24:18,160 --> 00:24:22,450
need to splice it in between the current

00:24:19,720 --> 00:24:24,760
node in the previous node so we just

00:24:22,450 --> 00:24:27,090
sort of like split it apart and link it

00:24:24,760 --> 00:24:27,090
back together

00:24:27,500 --> 00:24:33,899
so we find the previous node in our

00:24:29,940 --> 00:24:36,720
current node we insert the new node in

00:24:33,899 --> 00:24:38,399
by between them by setting its next

00:24:36,720 --> 00:24:41,000
fields the current node and updating the

00:24:38,399 --> 00:24:43,470
previous nodes next field to the new one

00:24:41,000 --> 00:24:46,950
and then finally we just increment the

00:24:43,470 --> 00:24:48,960
length the last method we need is a

00:24:46,950 --> 00:24:52,380
remove method we're just going to go

00:24:48,960 --> 00:24:55,620
look up a node by its position and

00:24:52,380 --> 00:24:57,450
splice it out of the chain again if

00:24:55,620 --> 00:24:59,250
we're removing the first node we simply

00:24:57,450 --> 00:25:03,090
need to set the head to our new to the

00:24:59,250 --> 00:25:04,679
next node in the chain for any other

00:25:03,090 --> 00:25:06,750
position we need to look up the previous

00:25:04,679 --> 00:25:09,210
node and set it to the node after the

00:25:06,750 --> 00:25:13,139
current position and then we're just

00:25:09,210 --> 00:25:14,730
going to decrement the length so the

00:25:13,139 --> 00:25:16,500
remaining two data structures we're

00:25:14,730 --> 00:25:20,519
going to cover are both in the tree

00:25:16,500 --> 00:25:24,440
family much in like real life there are

00:25:20,519 --> 00:25:26,490
many different types of trees like a lot

00:25:24,440 --> 00:25:29,309
little did you know you'd be studying

00:25:26,490 --> 00:25:31,470
dendrology today and that's not even all

00:25:29,309 --> 00:25:34,169
of them but don't let this scare you

00:25:31,470 --> 00:25:36,149
most of those don't matter at all there

00:25:34,169 --> 00:25:41,399
was just a lot of computer science PhDs

00:25:36,149 --> 00:25:43,620
who had something to prove trees are

00:25:41,399 --> 00:25:45,870
much like graphs or linked lists and

00:25:43,620 --> 00:25:47,820
that they are you need directional all

00:25:45,870 --> 00:25:51,029
this means is that I can't have loops in

00:25:47,820 --> 00:25:53,730
their references if you can draw a loop

00:25:51,029 --> 00:25:56,029
between connected nodes in a tree well

00:25:53,730 --> 00:25:59,279
you don't have a tree you have a graph

00:25:56,029 --> 00:26:01,529
trees have many different use cases they

00:25:59,279 --> 00:26:03,630
can be used to optimize searching or

00:26:01,529 --> 00:26:04,710
sorting they can organize programs

00:26:03,630 --> 00:26:06,179
better they can give you a

00:26:04,710 --> 00:26:10,139
representation that's easier to work

00:26:06,179 --> 00:26:15,059
with we're going to start off with a

00:26:10,139 --> 00:26:16,710
extremely simple tree structure it

00:26:15,059 --> 00:26:18,090
doesn't have any special rules to it and

00:26:16,710 --> 00:26:20,130
it looks something like this where we

00:26:18,090 --> 00:26:22,590
have a root and a value with children

00:26:20,130 --> 00:26:26,639
with values and more children so when

00:26:22,590 --> 00:26:28,679
they keep going that way the tree has to

00:26:26,639 --> 00:26:32,820
start with a single parent or the root

00:26:28,679 --> 00:26:35,190
of the tree we need a way to reverse our

00:26:32,820 --> 00:26:38,250
tree and call a function on each node in

00:26:35,190 --> 00:26:39,690
the tree will define a walk function

00:26:38,250 --> 00:26:42,720
that will call recursively on

00:26:39,690 --> 00:26:45,570
every single node in the tree it'll

00:26:42,720 --> 00:26:47,730
first call the callback on the node and

00:26:45,570 --> 00:26:50,190
then recursively call the walk function

00:26:47,730 --> 00:26:51,960
on all of its children and then we just

00:26:50,190 --> 00:26:56,039
kick the traversal process off at the

00:26:51,960 --> 00:26:59,220
root next we need a way to add nodes to

00:26:56,039 --> 00:27:02,129
our tree first we create the node that

00:26:59,220 --> 00:27:04,980
we're going to add if there's no route

00:27:02,129 --> 00:27:07,440
we just set it to a new node otherwise

00:27:04,980 --> 00:27:09,840
we traverse the entire tree and find a

00:27:07,440 --> 00:27:14,309
node with a matching value and add the

00:27:09,840 --> 00:27:15,990
new node to its children so this is one

00:27:14,309 --> 00:27:18,960
of the most basic trees that you could

00:27:15,990 --> 00:27:21,149
possibly have it's probably only useful

00:27:18,960 --> 00:27:24,779
if the data you're representing actually

00:27:21,149 --> 00:27:26,970
resembles a tree identical to this but

00:27:24,779 --> 00:27:30,809
with some extra rules a tree can serve a

00:27:26,970 --> 00:27:33,450
lot of different purposes binary search

00:27:30,809 --> 00:27:35,399
trees are a fairly common form of tree

00:27:33,450 --> 00:27:38,220
for their ability to efficiently access

00:27:35,399 --> 00:27:41,840
search insert and delete values all

00:27:38,220 --> 00:27:41,840
while keeping them in a sorted order

00:27:42,110 --> 00:27:48,179
imagine taking a sequence of numbers and

00:27:45,919 --> 00:27:52,440
then just turning them into a tree

00:27:48,179 --> 00:27:55,320
starting from the center this is how a

00:27:52,440 --> 00:27:57,899
binary tree works each node can have two

00:27:55,320 --> 00:27:59,759
children the left which is less than the

00:27:57,899 --> 00:28:01,909
parent nodes value and the right which

00:27:59,759 --> 00:28:05,370
is greater than the parent nodes value

00:28:01,909 --> 00:28:08,009
note that in order to make this work all

00:28:05,370 --> 00:28:09,629
values must be unique in the tree you

00:28:08,009 --> 00:28:13,710
can't have two fives because they would

00:28:09,629 --> 00:28:16,139
fall in the same position this makes

00:28:13,710 --> 00:28:18,090
traversal to find a value very efficient

00:28:16,139 --> 00:28:21,240
say we're trying to find the number five

00:28:18,090 --> 00:28:23,220
in our tree we go start at four and we

00:28:21,240 --> 00:28:25,860
say five is greater than four so we move

00:28:23,220 --> 00:28:28,200
right five is less than six so we move

00:28:25,860 --> 00:28:31,769
less and then boom we reach tree or

00:28:28,200 --> 00:28:33,379
reached five notice how we only had to

00:28:31,769 --> 00:28:36,259
do three checks to reach the number five

00:28:33,379 --> 00:28:41,789
if we were to expand this to a tree of

00:28:36,259 --> 00:28:47,119
1,000 items we'd go 500 to 250 to 125 to

00:28:41,789 --> 00:28:49,049
62 230 12 15 27 23 24 25 and that's

00:28:47,119 --> 00:28:53,140
sound like a lot but it's only ten

00:28:49,049 --> 00:28:58,300
checks to go placed in 1,000 items

00:28:53,140 --> 00:29:01,900
and while it would have been faster if

00:28:58,300 --> 00:29:05,800
we just went 1 2 3 4 5 in general if we

00:29:01,900 --> 00:29:09,550
were going to 999 that would have been

00:29:05,800 --> 00:29:13,420
909 checks down to 10 that's where 0 and

00:29:09,550 --> 00:29:15,640
comes from the other important thing to

00:29:13,420 --> 00:29:17,380
note about binary search trees is that

00:29:15,640 --> 00:29:19,630
they're very similar to linked lists and

00:29:17,380 --> 00:29:21,490
that they in the sense you only need to

00:29:19,630 --> 00:29:24,010
update the immediately surrounding items

00:29:21,490 --> 00:29:29,230
when removing or adding or removing a

00:29:24,010 --> 00:29:30,820
value so same as the previous tree we're

00:29:29,230 --> 00:29:34,870
going to have a root of our binary

00:29:30,820 --> 00:29:37,600
search tree in order to test if a value

00:29:34,870 --> 00:29:41,170
exists in the tree we're going to need

00:29:37,600 --> 00:29:43,720
to first search through the tree we

00:29:41,170 --> 00:29:45,550
start at the root and then we're going

00:29:43,720 --> 00:29:49,630
to keep running as long as we have

00:29:45,550 --> 00:29:52,570
another node to visit if we reach a left

00:29:49,630 --> 00:29:53,980
or right that is no then this loop ends

00:29:52,570 --> 00:29:57,730
and we assume that we did not have

00:29:53,980 --> 00:30:00,100
anything in the tree if the value is

00:29:57,730 --> 00:30:03,610
greater than the current value we move

00:30:00,100 --> 00:30:05,610
to the right if the value is less than

00:30:03,610 --> 00:30:08,470
current value we move to the left

00:30:05,610 --> 00:30:11,350
otherwise if it's not greater than or

00:30:08,470 --> 00:30:15,610
less than it must be equal to and so we

00:30:11,350 --> 00:30:17,560
return true if we not have if we haven't

00:30:15,610 --> 00:30:21,070
matched anything then we return false

00:30:17,560 --> 00:30:22,840
that's how we implement contains in

00:30:21,070 --> 00:30:24,520
order to add items for the tree we're

00:30:22,840 --> 00:30:26,740
going to do the same sort of traversal

00:30:24,520 --> 00:30:28,690
as before bouncing between left and

00:30:26,740 --> 00:30:30,040
right nodes depending on them being less

00:30:28,690 --> 00:30:32,560
are greater than the value that we're

00:30:30,040 --> 00:30:35,110
adding however this time when we reach a

00:30:32,560 --> 00:30:39,610
left or right that is null we're going

00:30:35,110 --> 00:30:43,900
to add a new node in that position first

00:30:39,610 --> 00:30:46,330
let's set up our node well special case

00:30:43,900 --> 00:30:49,080
for when there isn't any root node so

00:30:46,330 --> 00:30:52,510
that we just add one and return

00:30:49,080 --> 00:30:53,950
otherwise we start at the roots and

00:30:52,510 --> 00:30:55,660
we're going to loop until we've either

00:30:53,950 --> 00:30:59,290
added our item or discovered that it

00:30:55,660 --> 00:31:00,700
already exists in our tree if the value

00:30:59,290 --> 00:31:03,400
is greater than the current value we

00:31:00,700 --> 00:31:06,040
move to the right if the right does not

00:31:03,400 --> 00:31:07,190
exist we set it to our node and stop

00:31:06,040 --> 00:31:09,899
traverse

00:31:07,190 --> 00:31:12,840
otherwise we just continue on to keep

00:31:09,899 --> 00:31:14,759
searching the right node if the value is

00:31:12,840 --> 00:31:16,649
less than the current value we move to

00:31:14,759 --> 00:31:19,169
the left now we do the same thing where

00:31:16,649 --> 00:31:21,019
we check if it does not exist we set it

00:31:19,169 --> 00:31:23,340
to our node and stop traversing

00:31:21,019 --> 00:31:26,519
otherwise we just move on to the left

00:31:23,340 --> 00:31:28,679
node if the number isn't less than or

00:31:26,519 --> 00:31:30,269
greater to then it must be the same and

00:31:28,679 --> 00:31:32,249
so we don't do anything we just break

00:31:30,269 --> 00:31:36,029
and stop and the note isn't added

00:31:32,249 --> 00:31:40,789
because it's already exists and that's

00:31:36,029 --> 00:31:44,070
all all the different data structures if

00:31:40,789 --> 00:31:46,799
you want to read this code and review it

00:31:44,070 --> 00:31:49,470
again you can go to this URL I have a

00:31:46,799 --> 00:31:52,590
whole guide on it contains mostly same

00:31:49,470 --> 00:31:55,440
content you can also check out some of

00:31:52,590 --> 00:31:57,450
my other works I wrote about a compiler

00:31:55,440 --> 00:32:00,269
a super tiny compiler that you can go

00:31:57,450 --> 00:32:01,950
see here because of my work on babble I

00:32:00,269 --> 00:32:04,349
also wrote a Babel handbook that you can

00:32:01,950 --> 00:32:06,720
also check out anyways now we're

00:32:04,349 --> 00:32:09,889
actually done I'm James Kyle follow me

00:32:06,720 --> 00:32:09,889

YouTube URL: https://www.youtube.com/watch?v=bM5Wfmh9i5k


