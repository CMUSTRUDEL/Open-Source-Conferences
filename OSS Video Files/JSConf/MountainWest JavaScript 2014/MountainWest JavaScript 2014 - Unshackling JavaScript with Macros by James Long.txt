Title: MountainWest JavaScript 2014 - Unshackling JavaScript with Macros by James Long
Publication date: 2020-01-24
Playlist: MountainWest JavaScript 2014
Description: 
	By James Long

JavaScript is thriving, but the language itself is shackled to the long process of ECMA standardization and implementation in all engines. We have to wait many years for a simple feature like variable destructuring.
Macros allow you to extend a language with new syntax and semantics, just like you would build new APIs on top of native ones. There's no reason the language itself shouldn't be extensible, which allows it to grow naturally.
sweet.js is a project that implements robust hygienic macros for JavaScript. I will explain how this works and why it's such an exciting idea. I will show how you can already have ES6 variable destructuring, classes, fat arrow syntax, and more just with a few macros. In addition, you can use things like function tracing, native pattern matching, better assertions (logs contain the original expression), and much more. sweet.js macros track the original source location and generates sourcemaps, so debug away like normal! Let's unshackle ourselves from the the mire of standardization, and take control of the language we love!

Help us caption & translate this video!

http://amara.org/v/FG3C/
Captions: 
	00:00:26,200 --> 00:00:34,010
I'm James long I work for Mozilla I help

00:00:31,820 --> 00:00:37,160
developers write web apps and on the

00:00:34,010 --> 00:00:40,790
side I contribute to projects like sweet

00:00:37,160 --> 00:00:41,930
GS and as MJS and I pretty much like

00:00:40,790 --> 00:00:44,540
anything that has to do with low-level

00:00:41,930 --> 00:00:45,500
compiler suffer just cool stuff so if

00:00:44,540 --> 00:00:48,830
you go to my blogging because the other

00:00:45,500 --> 00:00:53,360
stuff that I work on so I'm going to

00:00:48,830 --> 00:00:57,079
talk to you about sweet GS sweet GS is a

00:00:53,360 --> 00:00:59,899
macro system for JavaScript started at

00:00:57,079 --> 00:01:02,809
Mozilla about two years ago an intern

00:00:59,899 --> 00:01:04,280
named Tim Tim disney store started it

00:01:02,809 --> 00:01:07,520
and he did some fantastic work

00:01:04,280 --> 00:01:10,180
throughout that summer he essentially

00:01:07,520 --> 00:01:13,399
was able to prove that this is possible

00:01:10,180 --> 00:01:16,190
in the past few years we've seen a whole

00:01:13,399 --> 00:01:18,440
lot of amazing contributions amazing

00:01:16,190 --> 00:01:20,990
features we've pretty much been able to

00:01:18,440 --> 00:01:22,280
just blow through a lot of academic

00:01:20,990 --> 00:01:25,069
papers and implement a lot of really

00:01:22,280 --> 00:01:28,369
cool stuff so it's working really well

00:01:25,069 --> 00:01:32,780
and I've personally been impressed at

00:01:28,369 --> 00:01:35,990
the positivity of the reactions because

00:01:32,780 --> 00:01:38,959
usually Mackers have kind of a bad

00:01:35,990 --> 00:01:40,729
reputation and a lot of people have this

00:01:38,959 --> 00:01:42,319
weird taste in my mouth of them but

00:01:40,729 --> 00:01:44,869
people seem excited about which makes me

00:01:42,319 --> 00:01:46,340
excited a few months ago I wrote this

00:01:44,869 --> 00:01:49,280
blog post stop writing JavaScript

00:01:46,340 --> 00:01:53,050
compilers make macros instead so if you

00:01:49,280 --> 00:01:56,660
saw it post I was one who wrote that and

00:01:53,050 --> 00:01:59,119
I was blown away again by the positive

00:01:56,660 --> 00:02:01,729
reception I was it got pretty popular

00:01:59,119 --> 00:02:03,440
about 50,000 views there are some

00:02:01,729 --> 00:02:06,649
negative comments which is constructive

00:02:03,440 --> 00:02:08,539
and good but it proved to me that this

00:02:06,649 --> 00:02:10,009
is something that is something that

00:02:08,539 --> 00:02:12,709
people want and is something that really

00:02:10,009 --> 00:02:16,430
will enable you to do some awesome

00:02:12,709 --> 00:02:18,980
things JavaScript so let me let's dig

00:02:16,430 --> 00:02:22,280
into a little bit I think sweet is a is

00:02:18,980 --> 00:02:23,599
a perfect name for for this because it

00:02:22,280 --> 00:02:26,750
either gives you the vision that you are

00:02:23,599 --> 00:02:30,219
drinking the sweet fluid of JavaScript

00:02:26,750 --> 00:02:30,219
and macros or you're on drugs

00:02:30,300 --> 00:02:38,320
so so when it takes there a few phases

00:02:35,320 --> 00:02:40,870
that your your program goes through when

00:02:38,320 --> 00:02:43,930
you as you write code and to make it do

00:02:40,870 --> 00:02:46,090
something it needs to be parsed it needs

00:02:43,930 --> 00:02:49,480
to be compiled and it needs to be

00:02:46,090 --> 00:02:51,040
executed macros add another phase to

00:02:49,480 --> 00:02:54,100
this before all of that happens the

00:02:51,040 --> 00:02:57,790
expansion phase and this basically

00:02:54,100 --> 00:03:00,760
allows you to tell the system certain

00:02:57,790 --> 00:03:03,070
patterns of code that you want to take

00:03:00,760 --> 00:03:05,380
and turn into something else and then

00:03:03,070 --> 00:03:07,930
the compiler or that the system will

00:03:05,380 --> 00:03:11,740
take that new code and then run through

00:03:07,930 --> 00:03:13,500
the last three phases so essentially it

00:03:11,740 --> 00:03:17,050
enables you you to do things like this

00:03:13,500 --> 00:03:19,510
you can tell the system hey when you see

00:03:17,050 --> 00:03:22,150
a a VAR keyword and there's an object

00:03:19,510 --> 00:03:24,460
literal on the left-hand side I want to

00:03:22,150 --> 00:03:27,040
turn that into two bar statements which

00:03:24,460 --> 00:03:29,590
declare the variables x and y and set

00:03:27,040 --> 00:03:31,960
them to pasa x and pawpaws at why i'm

00:03:29,590 --> 00:03:35,740
sure that you recognize we essentially

00:03:31,960 --> 00:03:38,520
just implemented abstractly the a basic

00:03:35,740 --> 00:03:41,650
variable D structuring which is in es6

00:03:38,520 --> 00:03:45,400
of course I'm sure that you've you also

00:03:41,650 --> 00:03:47,680
see that the the first form of code is

00:03:45,400 --> 00:03:49,450
not valid JavaScript but because the

00:03:47,680 --> 00:03:52,690
expansion phase happens before any part

00:03:49,450 --> 00:03:54,490
seen before any compiling happens we can

00:03:52,690 --> 00:03:56,380
take things that are completely invalid

00:03:54,490 --> 00:04:01,350
Java scripts and turn them into things

00:03:56,380 --> 00:04:03,760
that are valid JavaScript so if we take

00:04:01,350 --> 00:04:06,580
take a little bit of code this is just a

00:04:03,760 --> 00:04:09,100
function that replaces a space with

00:04:06,580 --> 00:04:10,360
dashes and then we call it we're used to

00:04:09,100 --> 00:04:12,400
looking at it like this we kind of load

00:04:10,360 --> 00:04:14,200
this into our head and we simulate it in

00:04:12,400 --> 00:04:17,380
our head this is how we typically write

00:04:14,200 --> 00:04:20,290
code and recode this is how we should

00:04:17,380 --> 00:04:23,500
write and recode but we see that get

00:04:20,290 --> 00:04:26,470
name is called dash if I is called what

00:04:23,500 --> 00:04:29,169
the result a serta replace is called

00:04:26,470 --> 00:04:31,960
within dash if I I'm in the result is

00:04:29,169 --> 00:04:36,370
passed to display name we're training

00:04:31,960 --> 00:04:39,280
training to recode this way and most

00:04:36,370 --> 00:04:40,780
most of you all should Rico this way if

00:04:39,280 --> 00:04:41,919
you're a compiler writer you typically

00:04:40,780 --> 00:04:43,090
could look at code a little bit

00:04:41,919 --> 00:04:45,610
differently

00:04:43,090 --> 00:04:47,830
and it's true that you could say that

00:04:45,610 --> 00:04:50,560
macros are essentially hooks for a

00:04:47,830 --> 00:04:52,720
little mini compilers but it's actually

00:04:50,560 --> 00:04:55,210
much more than that which I'll I'll go

00:04:52,720 --> 00:04:56,650
into but let's let's look at this

00:04:55,210 --> 00:04:58,830
syntactically what does this actually

00:04:56,650 --> 00:05:03,300
look like well there's the function

00:04:58,830 --> 00:05:06,010
token then there's a dash if I token

00:05:03,300 --> 00:05:07,930
then there's a left parenthesis then

00:05:06,010 --> 00:05:11,650
there's stir then there is a right

00:05:07,930 --> 00:05:14,260
parenthesis etc etc so you can kind of

00:05:11,650 --> 00:05:18,910
see this syntax as one long list of

00:05:14,260 --> 00:05:20,680
tokens real real good macros are

00:05:18,910 --> 00:05:22,660
actually much more than just operating

00:05:20,680 --> 00:05:25,080
order list of tokens oh it wouldn't be

00:05:22,660 --> 00:05:28,000
that hard to somehow implement something

00:05:25,080 --> 00:05:30,340
in most languages that give you hooks

00:05:28,000 --> 00:05:33,250
into the compilot process where you

00:05:30,340 --> 00:05:35,800
received either a list of tokens or a

00:05:33,250 --> 00:05:37,539
raw ASD and you mangled it and then you

00:05:35,800 --> 00:05:40,450
return it back and then it kept on doing

00:05:37,539 --> 00:05:41,949
it that's not very interesting it turns

00:05:40,450 --> 00:05:45,039
out in real-world practice that's

00:05:41,949 --> 00:05:47,650
incredibly hard to work with introduces

00:05:45,039 --> 00:05:51,729
all sorts of bugs and just really

00:05:47,650 --> 00:05:53,169
doesn't work so a good macro system

00:05:51,729 --> 00:05:55,870
knows a little bit more about the code

00:05:53,169 --> 00:05:57,250
than just the syntactical structure so

00:05:55,870 --> 00:05:59,740
sweet GS knows about things like

00:05:57,250 --> 00:06:02,830
variable declarations so it actually

00:05:59,740 --> 00:06:04,810
knows the scope of every variable it

00:06:02,830 --> 00:06:07,389
knows about things called de limiters

00:06:04,810 --> 00:06:10,990
which are any parentheses any curly

00:06:07,389 --> 00:06:12,820
brace or square brace so sweet jeaious

00:06:10,990 --> 00:06:14,139
actually works on a nested tree

00:06:12,820 --> 00:06:17,080
structure it doesn't work just on one

00:06:14,139 --> 00:06:20,169
long list of tokens essentially it works

00:06:17,080 --> 00:06:23,650
on tokens but there's a very very

00:06:20,169 --> 00:06:26,440
lightweight tree so what we get is this

00:06:23,650 --> 00:06:30,520
lightweight ASC that sweet just can can

00:06:26,440 --> 00:06:32,590
work on now when I say ASC it's still

00:06:30,520 --> 00:06:34,720
really not even in ASC because it really

00:06:32,590 --> 00:06:36,940
doesn't represent of the true JavaScript

00:06:34,720 --> 00:06:39,370
semantics it's not grouped by semantics

00:06:36,940 --> 00:06:42,070
it's screwed by structure and this means

00:06:39,370 --> 00:06:44,710
that we can still do all sorts of things

00:06:42,070 --> 00:06:48,880
that are are invalid JavaScript and turn

00:06:44,710 --> 00:06:54,159
them into valid JavaScript so this is

00:06:48,880 --> 00:06:55,729
what a macro definition looks like this

00:06:54,159 --> 00:06:59,419
is a macro do

00:06:55,729 --> 00:07:03,469
and you have for the sweet GS macros you

00:06:59,419 --> 00:07:07,969
have a list of rules and within those

00:07:03,469 --> 00:07:09,979
rules you use pattern matching so if so

00:07:07,969 --> 00:07:11,779
this is the the first pattern in the

00:07:09,979 --> 00:07:13,699
rule so it checks to see if it matches

00:07:11,779 --> 00:07:15,979
this pattern and if it does match a

00:07:13,699 --> 00:07:21,999
pattern then it expands to the code

00:07:15,979 --> 00:07:25,639
inside the rule and so if we invoke do

00:07:21,999 --> 00:07:28,039
the first thing it does is it checks if

00:07:25,639 --> 00:07:31,069
the left curly brace mattress which

00:07:28,039 --> 00:07:33,589
there is a left curly brace and then it

00:07:31,069 --> 00:07:35,719
checks if there is an expression within

00:07:33,589 --> 00:07:38,960
the curly brace and there is and then it

00:07:35,719 --> 00:07:41,389
checks the rightfully brace so it

00:07:38,960 --> 00:07:45,649
correctly matches and it returns the

00:07:41,389 --> 00:07:47,659
this rap this call to underscore rap if

00:07:45,649 --> 00:07:49,580
it didn't match it with Rho not not

00:07:47,659 --> 00:07:53,389
matched here at the at the expansion

00:07:49,580 --> 00:07:56,899
time and so that's that's a very high

00:07:53,389 --> 00:08:00,349
level overview of how you define macro

00:07:56,899 --> 00:08:02,389
how the macro X way it works we'll get

00:08:00,349 --> 00:08:07,430
into more more more details of the

00:08:02,389 --> 00:08:10,099
features so with this macro system we've

00:08:07,430 --> 00:08:12,800
added this this new phase expand and

00:08:10,099 --> 00:08:15,379
we've we've added a way to to define

00:08:12,800 --> 00:08:17,360
your own abstractions with macro this is

00:08:15,379 --> 00:08:19,249
very important because the keyword

00:08:17,360 --> 00:08:20,449
function is actually a really really

00:08:19,249 --> 00:08:22,759
important thing I think we could have

00:08:20,449 --> 00:08:23,959
take it for granted sometimes because if

00:08:22,759 --> 00:08:25,789
you look back at some really old

00:08:23,959 --> 00:08:27,909
languages you it was actually credibly

00:08:25,789 --> 00:08:30,919
hard to build up your in abstractions

00:08:27,909 --> 00:08:34,250
function allows us to take built-in

00:08:30,919 --> 00:08:37,459
api's built-in primitives as we're doing

00:08:34,250 --> 00:08:39,440
a set of instructions function allows us

00:08:37,459 --> 00:08:41,089
to group those up into a small unit of

00:08:39,440 --> 00:08:43,279
functionality that we can reuse

00:08:41,089 --> 00:08:44,360
throughout our system we did this all

00:08:43,279 --> 00:08:46,250
the time when you sit down to write our

00:08:44,360 --> 00:08:49,279
project you right tons of functions and

00:08:46,250 --> 00:08:50,300
you create your your architecture if it

00:08:49,279 --> 00:08:51,980
weren't for function we wouldn't be able

00:08:50,300 --> 00:08:53,209
to write any any sort of complex system

00:08:51,980 --> 00:08:55,600
at all because you'd have to constantly

00:08:53,209 --> 00:08:59,019
be dealing with implementation details

00:08:55,600 --> 00:09:02,180
macro gives us the same thing

00:08:59,019 --> 00:09:05,540
syntactically and so now we have hooks

00:09:02,180 --> 00:09:07,399
on both ends of the process to implement

00:09:05,540 --> 00:09:09,170
really interesting features so

00:09:07,399 --> 00:09:09,470
syntactical abstraction and functional

00:09:09,170 --> 00:09:11,870
up

00:09:09,470 --> 00:09:15,470
to allow you to do four more things than

00:09:11,870 --> 00:09:17,480
you could before and you could argue

00:09:15,470 --> 00:09:20,360
this is terrible I will get to this

00:09:17,480 --> 00:09:22,820
argument i tur in the grand scheme of

00:09:20,360 --> 00:09:24,020
things you should still be writing a lot

00:09:22,820 --> 00:09:26,240
more functions you shouldn't really be

00:09:24,020 --> 00:09:28,040
writing a lot of macros but the ability

00:09:26,240 --> 00:09:32,390
to have the syntactical abstraction

00:09:28,040 --> 00:09:35,300
allow unlocks the language from the

00:09:32,390 --> 00:09:37,270
virtual machine version and makes it

00:09:35,300 --> 00:09:39,890
much easier for the language to evolve

00:09:37,270 --> 00:09:45,350
and I'll get into why that's important

00:09:39,890 --> 00:09:47,210
for JavaScript too so let's let's dig

00:09:45,350 --> 00:09:48,500
into the actual suite ga smackers how do

00:09:47,210 --> 00:09:49,610
you actually use how you actually write

00:09:48,500 --> 00:09:52,910
macros what are the features that

00:09:49,610 --> 00:09:59,210
enables you to do things so this is a

00:09:52,910 --> 00:10:04,850
basic macro again this is a macro foo so

00:09:59,210 --> 00:10:06,290
there's one rule and it the identifiers

00:10:04,850 --> 00:10:09,530
that are prefixed with a dollar sign are

00:10:06,290 --> 00:10:12,350
called pattern pattern variables pattern

00:10:09,530 --> 00:10:14,570
matches so it basically binds whatever

00:10:12,350 --> 00:10:17,720
syntactical structure is at that place

00:10:14,570 --> 00:10:19,820
to that variable that you can use within

00:10:17,720 --> 00:10:22,850
the rule to omit the same syntactical

00:10:19,820 --> 00:10:24,320
item if you don't prefix it with dollar

00:10:22,850 --> 00:10:27,140
sign you'll c plus does not have a

00:10:24,320 --> 00:10:29,660
dollar sign it will match that literal

00:10:27,140 --> 00:10:33,320
word so you can see that I call foo with

00:10:29,660 --> 00:10:36,260
five plus six and it matches plus and

00:10:33,320 --> 00:10:39,890
then it binds 5 and 6 2 x and y and it

00:10:36,260 --> 00:10:41,330
returns the 5 plus 6 so that's how you

00:10:39,890 --> 00:10:43,220
can introduce literal words and then you

00:10:41,330 --> 00:10:47,180
can also use the dollar signs to bind

00:10:43,220 --> 00:10:49,670
whatever is in that place right macro

00:10:47,180 --> 00:10:51,080
names can be anything except any of the

00:10:49,670 --> 00:10:53,840
delimiter so they can be anything except

00:10:51,080 --> 00:10:55,880
for parentheses or brackets so we could

00:10:53,840 --> 00:10:59,450
actually define a macro named foo arrow

00:10:55,880 --> 00:11:04,430
if we wanted to if you use multi tokens

00:10:59,450 --> 00:11:07,250
which is essentially multiple of the of

00:11:04,430 --> 00:11:10,280
the like symbols like equals and if you

00:11:07,250 --> 00:11:12,200
use a elicits you have to wrap it in

00:11:10,280 --> 00:11:14,270
parentheses when you were defining the

00:11:12,200 --> 00:11:16,070
macro name just for various reasons but

00:11:14,270 --> 00:11:19,700
this this defines a macro name named foo

00:11:16,070 --> 00:11:22,070
arrow so you can do like just just the

00:11:19,700 --> 00:11:22,970
error macro which lets you implement the

00:11:22,070 --> 00:11:25,699
fat fat air

00:11:22,970 --> 00:11:30,069
syntax which in es6 and you can do a lot

00:11:25,699 --> 00:11:32,480
of other interesting things like that so

00:11:30,069 --> 00:11:35,269
this is a macro which defines multiple

00:11:32,480 --> 00:11:38,060
patterns this is where it starts to get

00:11:35,269 --> 00:11:39,829
really powerful because if it doesn't

00:11:38,060 --> 00:11:41,240
match one rule it will just walk to the

00:11:39,829 --> 00:11:43,399
next one and it will just continually

00:11:41,240 --> 00:11:44,899
pattern match down if you ever use any

00:11:43,399 --> 00:11:48,980
kind of pattern matching you're probably

00:11:44,899 --> 00:11:51,170
used to this kind of workflow so you can

00:11:48,980 --> 00:11:54,410
see that this macro foo will accept an

00:11:51,170 --> 00:11:56,959
arrow and then an item or a literal

00:11:54,410 --> 00:12:01,399
array syntax with one item inside of it

00:11:56,959 --> 00:12:05,000
or just anything so if we call foo with

00:12:01,399 --> 00:12:06,649
the arrow bar it expands it into a call

00:12:05,000 --> 00:12:08,600
to the function arrow passes bar into it

00:12:06,649 --> 00:12:10,970
they call it with a literal array with

00:12:08,600 --> 00:12:13,519
one item bar it will expand into a

00:12:10,970 --> 00:12:15,470
function call array so this just is

00:12:13,519 --> 00:12:18,910
showing you a very very basic example

00:12:15,470 --> 00:12:22,449
about how you can use multiple rules to

00:12:18,910 --> 00:12:27,670
degenerate can generate code

00:12:22,449 --> 00:12:27,670
conditionally based on the syntax

00:12:27,790 --> 00:12:33,680
another feature is pattern classes this

00:12:31,100 --> 00:12:36,350
allows you to tag a pattern variable

00:12:33,680 --> 00:12:39,139
with and tell the system a certain type

00:12:36,350 --> 00:12:41,329
of syntax that you want to match so

00:12:39,139 --> 00:12:45,050
there's built-in pattern classes i dint

00:12:41,329 --> 00:12:46,759
lit an expert i dint basically says any

00:12:45,050 --> 00:12:48,709
sort of identifier which is essentially

00:12:46,759 --> 00:12:50,089
any kind of word maybe has an underscore

00:12:48,709 --> 00:12:52,459
in it any any valid JavaScript

00:12:50,089 --> 00:12:54,800
identifier will be bound to this lit

00:12:52,459 --> 00:12:56,930
means it means a literal so any any

00:12:54,800 --> 00:12:59,180
JavaScript literal like five or like a

00:12:56,930 --> 00:13:01,759
number or a to false many of those

00:12:59,180 --> 00:13:04,879
liberals will be bound here expert means

00:13:01,759 --> 00:13:06,439
any valid JavaScript expression and that

00:13:04,879 --> 00:13:09,649
one is really important which I will

00:13:06,439 --> 00:13:12,470
show you in the next slide so here we

00:13:09,649 --> 00:13:14,779
have a macro which binds a literal to X

00:13:12,470 --> 00:13:16,629
so if we called it with an identifier

00:13:14,779 --> 00:13:19,309
bar it would actually throw a match here

00:13:16,629 --> 00:13:22,850
so this this lets you specify specific

00:13:19,309 --> 00:13:24,949
things to the system which not only give

00:13:22,850 --> 00:13:27,259
you better errors but sometimes actually

00:13:24,949 --> 00:13:29,180
indicate we could have multiple rules

00:13:27,259 --> 00:13:32,059
here and the second rule could buy next

00:13:29,180 --> 00:13:33,410
to a identifier so you could actually

00:13:32,059 --> 00:13:36,910
generate different code depending on

00:13:33,410 --> 00:13:36,910
whether it's a literal or an identifier

00:13:36,970 --> 00:13:43,430
so this is the expert class which binds

00:13:40,550 --> 00:13:45,589
to an expression you find that you you

00:13:43,430 --> 00:13:48,529
you really want this because essentially

00:13:45,589 --> 00:13:52,130
sweet jeaious is just binding working on

00:13:48,529 --> 00:13:54,470
a stream of tokens and so when you just

00:13:52,130 --> 00:13:57,890
use dollar sign x it doesn't know

00:13:54,470 --> 00:14:00,050
whether you mean in a den if you call it

00:13:57,890 --> 00:14:02,240
with a function call bar it doesn't know

00:14:00,050 --> 00:14:04,580
if you mean I just want bar I just want

00:14:02,240 --> 00:14:06,200
the identifier bar or if you want the

00:14:04,580 --> 00:14:08,959
whole complete expression of the

00:14:06,200 --> 00:14:11,720
function call so by default sweet GS

00:14:08,959 --> 00:14:13,220
will bind on on on one token so if you

00:14:11,720 --> 00:14:15,800
just use dollar sign X without any

00:14:13,220 --> 00:14:18,140
pattern class it would just take off bar

00:14:15,800 --> 00:14:20,630
and it would match bar text but since

00:14:18,140 --> 00:14:22,310
we've used the pattern class expression

00:14:20,630 --> 00:14:24,050
we're telling I want a whole valid

00:14:22,310 --> 00:14:25,550
JavaScript expression so it's going to

00:14:24,050 --> 00:14:28,399
consume the whole function called a bar

00:14:25,550 --> 00:14:30,560
and so you'll see with expert this will

00:14:28,399 --> 00:14:32,540
generate bar parenthesis the whole

00:14:30,560 --> 00:14:36,020
function call and I can wrap that in

00:14:32,540 --> 00:14:38,600
some something else in my in my macro if

00:14:36,020 --> 00:14:40,940
I didn't use with if I didn't use the

00:14:38,600 --> 00:14:42,529
expression I would just get bar and you

00:14:40,940 --> 00:14:44,180
would generate a lot of code and then

00:14:42,529 --> 00:14:45,529
after the expansion happens you would

00:14:44,180 --> 00:14:48,500
still have some trailing parentheses

00:14:45,529 --> 00:14:50,180
which would probably be a syntax error a

00:14:48,500 --> 00:14:52,040
lot of the time you really want in

00:14:50,180 --> 00:14:53,300
expression so you you end up using this

00:14:52,040 --> 00:14:58,670
pattern class a lot which is very

00:14:53,300 --> 00:15:00,880
important there's also let let macros

00:14:58,670 --> 00:15:04,760
which is another way to define macros

00:15:00,880 --> 00:15:06,440
it's let doesn't it's not really the es6

00:15:04,760 --> 00:15:08,690
let at all this this all happens that

00:15:06,440 --> 00:15:10,730
expansion phase but if you define a

00:15:08,690 --> 00:15:14,330
macro this way you say let and then the

00:15:10,730 --> 00:15:18,320
macro name equals macro it lets you

00:15:14,330 --> 00:15:20,060
generate code that uses the same name

00:15:18,320 --> 00:15:22,130
that is the name of your macro by

00:15:20,060 --> 00:15:24,770
default macros and sweet GSR recursive

00:15:22,130 --> 00:15:28,850
so if you had a macro named foo and you

00:15:24,770 --> 00:15:30,800
generated code that invoked foo as well

00:15:28,850 --> 00:15:33,140
it would recursively experian it until

00:15:30,800 --> 00:15:34,490
all of the macros are expanded out the

00:15:33,140 --> 00:15:35,690
problem with that is if you wanted to do

00:15:34,490 --> 00:15:38,149
something like override a built-in

00:15:35,690 --> 00:15:40,070
keyword like VAR or function you

00:15:38,149 --> 00:15:42,890
couldn't get access to the built-in

00:15:40,070 --> 00:15:44,570
keyword var or function so what you do

00:15:42,890 --> 00:15:47,450
is you define a let macro and sweet GS

00:15:44,570 --> 00:15:49,920
says the VAR that I'm expanding to is

00:15:47,450 --> 00:15:51,690
not my VAR macro it's the built-in bar

00:15:49,920 --> 00:15:56,970
so this is what lets you override

00:15:51,690 --> 00:15:59,279
built-in keywords there's also repeating

00:15:56,970 --> 00:16:03,420
patterns you basically use this with the

00:15:59,279 --> 00:16:06,839
dot this says whatever was proceeding

00:16:03,420 --> 00:16:10,019
the the dot dot I want to match as many

00:16:06,839 --> 00:16:12,240
of them as possible so if you're inside

00:16:10,019 --> 00:16:14,310
say like a function body it's going to

00:16:12,240 --> 00:16:15,570
match up to it to the end end of the

00:16:14,310 --> 00:16:17,250
function body because remember we're

00:16:15,570 --> 00:16:18,449
inside we're inside this nested tree

00:16:17,250 --> 00:16:22,050
structure that's kind of a lightweight

00:16:18,449 --> 00:16:23,850
AST so whatever level you're at in that

00:16:22,050 --> 00:16:25,139
ASC it will match up to the end of that

00:16:23,850 --> 00:16:28,920
it's not going to match the whole rest

00:16:25,139 --> 00:16:32,040
of the file so you can also specify an

00:16:28,920 --> 00:16:33,630
optional delimiter so if you with the

00:16:32,040 --> 00:16:35,279
parentheses you can say parentheses

00:16:33,630 --> 00:16:37,260
comma and that means that it's comma

00:16:35,279 --> 00:16:39,029
delimited so there's commas in between

00:16:37,260 --> 00:16:40,290
each item and that turns out to be

00:16:39,029 --> 00:16:41,430
really useful because then you don't

00:16:40,290 --> 00:16:44,269
have to worry about trailing commas and

00:16:41,430 --> 00:16:47,760
all that kind of stuff and it will match

00:16:44,269 --> 00:16:50,220
IDs that are with commas in between them

00:16:47,760 --> 00:16:52,440
you can also specify a complex pattern

00:16:50,220 --> 00:16:54,600
group somewhat similar to regular

00:16:52,440 --> 00:16:56,850
expressions you can like route them and

00:16:54,600 --> 00:17:00,149
then that match match them multiple so

00:16:56,850 --> 00:17:03,240
this is actually matching this syntax

00:17:00,149 --> 00:17:05,010
some ID and then the literal word as and

00:17:03,240 --> 00:17:06,959
then some other thing that's bound

00:17:05,010 --> 00:17:09,480
d'ivoire match that whole thing with

00:17:06,959 --> 00:17:11,819
commas in between them as many as you

00:17:09,480 --> 00:17:13,790
can so this is a macro that that looks

00:17:11,819 --> 00:17:17,160
like this this is our do macro again

00:17:13,790 --> 00:17:19,350
except now we've extended it to support

00:17:17,160 --> 00:17:22,169
multiple expressions so now within do

00:17:19,350 --> 00:17:24,419
you can comment delimit expressions and

00:17:22,169 --> 00:17:26,280
it will match all of them so you see

00:17:24,419 --> 00:17:29,549
that there is i'm using item with an

00:17:26,280 --> 00:17:31,559
expression pattern class it will it will

00:17:29,549 --> 00:17:32,970
match a full expression and then it will

00:17:31,559 --> 00:17:35,220
comment to limit them and it will match

00:17:32,970 --> 00:17:37,080
all of these items to use them in your

00:17:35,220 --> 00:17:40,140
in the code that you want to generate

00:17:37,080 --> 00:17:43,470
you you use the exact same syntax you

00:17:40,140 --> 00:17:46,980
use the optional delimiter plus the plus

00:17:43,470 --> 00:17:48,570
the dot and it will take whatever amount

00:17:46,980 --> 00:17:51,000
that it matched and put it into the

00:17:48,570 --> 00:17:54,840
generated code so here we've wrapped foo

00:17:51,000 --> 00:17:58,700
and bar the function calls this is a

00:17:54,840 --> 00:18:02,110
quicker hope I'm not going too fast

00:17:58,700 --> 00:18:06,100
sweetie ice implements hygienic macros

00:18:02,110 --> 00:18:08,890
and there's a whole history of this that

00:18:06,100 --> 00:18:13,360
I'm not going to go into a whole lot but

00:18:08,890 --> 00:18:14,290
because macros actually originated well

00:18:13,360 --> 00:18:15,760
I'm not sure exactly where they

00:18:14,290 --> 00:18:17,950
originated but they were used widely in

00:18:15,760 --> 00:18:19,360
list but that's this is kind of the list

00:18:17,950 --> 00:18:20,650
claim to fame is that they use macros

00:18:19,360 --> 00:18:22,720
and they're able to evolve and do all

00:18:20,650 --> 00:18:23,920
sorts of awesome stuff their problem

00:18:22,720 --> 00:18:25,929
with a lot of those macro systems is

00:18:23,920 --> 00:18:30,280
that they're not hygienic what hygiene

00:18:25,929 --> 00:18:32,410
means is that it tracks the the meaning

00:18:30,280 --> 00:18:35,020
of variable definitions across your

00:18:32,410 --> 00:18:36,340
program and within your macros and so it

00:18:35,020 --> 00:18:38,320
will make sure that there are not any

00:18:36,340 --> 00:18:40,480
collisions so if you have a macro and

00:18:38,320 --> 00:18:43,390
you define a variable if you expand out

00:18:40,480 --> 00:18:46,000
the code that defines a variable it will

00:18:43,390 --> 00:18:47,950
make sure that that variable is only

00:18:46,000 --> 00:18:50,169
meaning what you want it to be within

00:18:47,950 --> 00:18:51,520
that code expansion and if there's

00:18:50,169 --> 00:18:53,500
another variable with the same name that

00:18:51,520 --> 00:18:55,929
happens to expand to in the same scope

00:18:53,500 --> 00:18:59,679
it will rename this identifier to make

00:18:55,929 --> 00:19:04,929
sure that they're renamed and unique so

00:18:59,679 --> 00:19:09,070
if we have this macro which takes an

00:19:04,929 --> 00:19:11,860
expression and squares that it will you

00:19:09,070 --> 00:19:14,559
can see that it's renamed this X 2 X

00:19:11,860 --> 00:19:17,799
dollar sign too and then it's renamed

00:19:14,559 --> 00:19:20,230
the X that the user defined 2x our sign

00:19:17,799 --> 00:19:22,270
one and then it multiplies X are

00:19:20,230 --> 00:19:24,340
assigned to you by itself so it

00:19:22,270 --> 00:19:26,290
maintains the uniqueness of the variable

00:19:24,340 --> 00:19:28,270
which is what you originally intended

00:19:26,290 --> 00:19:31,090
this isn't this ends up being extremely

00:19:28,270 --> 00:19:32,470
important for real world macros because

00:19:31,090 --> 00:19:35,049
when it comes down to it if you're

00:19:32,470 --> 00:19:37,510
writing a lot of macros they tend to get

00:19:35,049 --> 00:19:39,760
pretty complex you tend to want to use

00:19:37,510 --> 00:19:42,640
temporary variables to maintain maintain

00:19:39,760 --> 00:19:45,370
state between certain calls of the macro

00:19:42,640 --> 00:19:47,980
and the ability to define these

00:19:45,370 --> 00:19:51,160
temporary variables without any without

00:19:47,980 --> 00:19:53,500
collision guarantees then is very very

00:19:51,160 --> 00:19:55,030
nice and if you don't have hygiene the

00:19:53,500 --> 00:19:58,000
list world i think has dealt with this a

00:19:55,030 --> 00:19:59,200
lot it's really just a headache turns

00:19:58,000 --> 00:20:01,900
out to be really really useful for

00:19:59,200 --> 00:20:03,850
modules as well because modules we

00:20:01,900 --> 00:20:05,919
haven't done it yet but sweet GS should

00:20:03,850 --> 00:20:07,990
implement with the es6 mot module system

00:20:05,919 --> 00:20:11,530
for for javascript so you can actually

00:20:07,990 --> 00:20:12,750
import macros from a module we need to

00:20:11,530 --> 00:20:15,760
make sure that everything that's

00:20:12,750 --> 00:20:17,050
identified in those macros is still

00:20:15,760 --> 00:20:19,510
seeing the correct thing that was within

00:20:17,050 --> 00:20:21,310
that module so hygiene is very important

00:20:19,510 --> 00:20:22,480
and I'm not going to go into exactly how

00:20:21,310 --> 00:20:25,780
that works because it's a pretty

00:20:22,480 --> 00:20:27,400
complicated algorithm actually so

00:20:25,780 --> 00:20:31,420
another interesting thing is in fixed

00:20:27,400 --> 00:20:34,570
macros so JavaScript Lisp doesn't have

00:20:31,420 --> 00:20:38,050
this problem because it's all postfix or

00:20:34,570 --> 00:20:41,590
prefix um Africa so but javascript is

00:20:38,050 --> 00:20:44,080
all in fix and so you you really need in

00:20:41,590 --> 00:20:46,090
fig smackers because this this you

00:20:44,080 --> 00:20:48,340
there's a lot of stuff that you couldn't

00:20:46,090 --> 00:20:50,740
do if you can do in fix macros I'm

00:20:48,340 --> 00:20:53,080
actually showing you the full macro that

00:20:50,740 --> 00:20:55,350
implements fat arrows this is the full

00:20:53,080 --> 00:20:59,230
macro that's in my es6 mackeage project

00:20:55,350 --> 00:21:01,450
so it's pretty simple and I hope I've

00:20:59,230 --> 00:21:03,400
explained the techniques so far clear

00:21:01,450 --> 00:21:05,650
enough to where this isn't shocking to

00:21:03,400 --> 00:21:09,400
you but you define in fixed macros by

00:21:05,650 --> 00:21:12,820
using the bar to that bar that's inside

00:21:09,400 --> 00:21:14,800
of each rule specifies where the macro

00:21:12,820 --> 00:21:16,630
was invoked and on the left-hand side of

00:21:14,800 --> 00:21:19,150
the bar is when I want to match before

00:21:16,630 --> 00:21:20,590
the invocation of my macro and then the

00:21:19,150 --> 00:21:23,770
right-hand side is just everything after

00:21:20,590 --> 00:21:25,750
it to you also have to say rule in fix

00:21:23,770 --> 00:21:29,050
and just a rule to you have to tag it

00:21:25,750 --> 00:21:32,580
specifically as an infix macro so using

00:21:29,050 --> 00:21:35,290
this macro you can see that we we match

00:21:32,580 --> 00:21:37,210
any number of arguments in the first

00:21:35,290 --> 00:21:39,070
rule and then that they're going to be

00:21:37,210 --> 00:21:41,110
the arrow and then when we match a

00:21:39,070 --> 00:21:42,790
literal curly brace and then we matched

00:21:41,110 --> 00:21:44,890
all of the body inside of it and then we

00:21:42,790 --> 00:21:47,500
match the end curly brace and if it's of

00:21:44,890 --> 00:21:50,110
that form then we generate a function

00:21:47,500 --> 00:21:51,790
that accepts all of those arguments just

00:21:50,110 --> 00:21:53,410
puts puts the body inside of this

00:21:51,790 --> 00:21:55,030
function and then calls bind this

00:21:53,410 --> 00:21:57,910
because that's the whole idea about

00:21:55,030 --> 00:22:01,330
federer's is that the this context is

00:21:57,910 --> 00:22:04,150
kept from the outer context for whatever

00:22:01,330 --> 00:22:05,950
wherever that function was defined it

00:22:04,150 --> 00:22:11,019
should be bonded

00:22:05,950 --> 00:22:13,000
so the second one matches it's the

00:22:11,019 --> 00:22:14,590
fatter or syntax if you just have one

00:22:13,000 --> 00:22:16,210
expression right after the arrow you can

00:22:14,590 --> 00:22:18,490
do that with it without using curly

00:22:16,210 --> 00:22:22,179
brackets and if you do that it actually

00:22:18,490 --> 00:22:23,760
returns that expression by default so

00:22:22,179 --> 00:22:27,190
you can see that there's a few different

00:22:23,760 --> 00:22:29,649
you this I was hoping to show you a real

00:22:27,190 --> 00:22:32,350
world macro which helps show you the

00:22:29,649 --> 00:22:34,929
power of using multiple rules turning

00:22:32,350 --> 00:22:37,179
slightly different syntax that lets you

00:22:34,929 --> 00:22:38,950
do cool things so this is what you're

00:22:37,179 --> 00:22:41,080
able to do with that macro if you use

00:22:38,950 --> 00:22:42,460
arrow this is the patter of syntaxin if

00:22:41,080 --> 00:22:46,419
you use this that this will be bound for

00:22:42,460 --> 00:22:48,039
the outer outer context I know I'm

00:22:46,419 --> 00:22:48,850
flying through these this is the last

00:22:48,039 --> 00:22:49,840
thing I'm going to mention i'm not even

00:22:48,850 --> 00:22:51,970
gonna go into it much because it's

00:22:49,840 --> 00:22:53,889
really it's really complicated if you

00:22:51,970 --> 00:22:55,600
just absolutely can't do anything with

00:22:53,889 --> 00:22:57,700
the whole pattern matching system which

00:22:55,600 --> 00:23:00,909
is actually pretty rare you can use

00:22:57,700 --> 00:23:03,909
something called case macros case macros

00:23:00,909 --> 00:23:06,730
actually allow you to execute raw

00:23:03,909 --> 00:23:10,539
JavaScript so you see that we use case

00:23:06,730 --> 00:23:13,389
instead of rule and when this when this

00:23:10,539 --> 00:23:16,149
hits this this code you see there's a

00:23:13,389 --> 00:23:17,769
console dot log this code this is actual

00:23:16,149 --> 00:23:21,690
just real JavaScript code in here that's

00:23:17,769 --> 00:23:24,100
run at expansion time so this lets you

00:23:21,690 --> 00:23:26,620
there's there's there certain methods in

00:23:24,100 --> 00:23:29,289
here to introspect what the pattern

00:23:26,620 --> 00:23:32,350
variable ID and bar is you can actually

00:23:29,289 --> 00:23:35,200
access through the raw token list so you

00:23:32,350 --> 00:23:37,990
can do anything you want to the thing

00:23:35,200 --> 00:23:40,990
that case macros are mostly used for is

00:23:37,990 --> 00:23:42,940
breaking hygiene so with since

00:23:40,990 --> 00:23:44,260
everything is hygienic and we have the

00:23:42,940 --> 00:23:45,909
whole pattern matching and everything is

00:23:44,260 --> 00:23:49,179
automatically tracked with the right

00:23:45,909 --> 00:23:51,130
scope there's no way to introduce a new

00:23:49,179 --> 00:23:54,130
variable so if you wanted to write a

00:23:51,130 --> 00:23:58,710
macro that wrapped a body of code but

00:23:54,130 --> 00:24:01,029
you wanted to say the the variable ID is

00:23:58,710 --> 00:24:03,610
defined as a specific thing inside that

00:24:01,029 --> 00:24:05,799
body you can't you can't actually let

00:24:03,610 --> 00:24:07,539
the user access that variable with just

00:24:05,799 --> 00:24:09,700
the normal rule macros but with case

00:24:07,539 --> 00:24:11,110
macros there's certain functions to let

00:24:09,700 --> 00:24:13,419
you break the hygiene it's actually

00:24:11,110 --> 00:24:15,460
frowned upon you you rarely should have

00:24:13,419 --> 00:24:18,519
to write case macros there's just a few

00:24:15,460 --> 00:24:19,100
a few cases that are useful for that

00:24:18,519 --> 00:24:20,530
kind of a thing

00:24:19,100 --> 00:24:23,230
I'm not really going to go into all the

00:24:20,530 --> 00:24:25,640
methods and different ways to do that

00:24:23,230 --> 00:24:28,250
but just when I thought it was worth men

00:24:25,640 --> 00:24:31,520
worth mentioning so there's a whole lot

00:24:28,250 --> 00:24:32,870
more I didn't want to dig too deep into

00:24:31,520 --> 00:24:36,350
it but it's hard not to you kind of have

00:24:32,870 --> 00:24:38,450
to go through enough to show you what

00:24:36,350 --> 00:24:40,340
it's what it can do but there's custom

00:24:38,450 --> 00:24:41,690
pattern classes you can actually write

00:24:40,340 --> 00:24:43,850
your own macros and invoke them as

00:24:41,690 --> 00:24:45,620
pattern classes there's macro generator

00:24:43,850 --> 00:24:47,179
in your macros there's recursive macros

00:24:45,620 --> 00:24:48,860
there's all there's all sorts of

00:24:47,179 --> 00:24:52,159
patterns for matching all sorts of

00:24:48,860 --> 00:24:53,659
complex code but it's really cool it's a

00:24:52,159 --> 00:24:57,169
whole lot easier than writing compilers

00:24:53,659 --> 00:24:58,880
that's for sure and it's it's also far

00:24:57,169 --> 00:24:59,900
more composable because of the hygiene

00:24:58,880 --> 00:25:02,270
and because of all these other things

00:24:59,900 --> 00:25:03,590
that the system knows about because if

00:25:02,270 --> 00:25:05,480
you write multiple compilers the

00:25:03,590 --> 00:25:06,799
compilers don't compose that was what my

00:25:05,480 --> 00:25:08,720
original blog post was mainly about

00:25:06,799 --> 00:25:11,780
whereas if you write a compiler that

00:25:08,720 --> 00:25:13,460
extends a syntax in a certain way your

00:25:11,780 --> 00:25:16,130
second compiler that does something else

00:25:13,460 --> 00:25:18,020
can't parse the original sin tax that

00:25:16,130 --> 00:25:20,960
you extended macros allow you to all of

00:25:18,020 --> 00:25:22,400
this I've written some tutorials on my

00:25:20,960 --> 00:25:26,140
blog do long stroke on so if you're

00:25:22,400 --> 00:25:29,330
interested in this and not such a rush

00:25:26,140 --> 00:25:30,799
walkthrough of sweet yes I recommend

00:25:29,330 --> 00:25:33,440
going to my blog there's two tutorials

00:25:30,799 --> 00:25:34,549
up and hopefully that will be a little

00:25:33,440 --> 00:25:38,360
bit better explanation about what's

00:25:34,549 --> 00:25:40,010
going on so to use this system it's

00:25:38,360 --> 00:25:43,130
really easy you just NPM install sweetie

00:25:40,010 --> 00:25:45,049
s and you call the SJS compiler if you

00:25:43,130 --> 00:25:47,539
pass that see it generates source maps

00:25:45,049 --> 00:25:48,890
so this is another extremely interesting

00:25:47,539 --> 00:25:50,929
or extremely important part about

00:25:48,890 --> 00:25:52,549
sweetie s which is that guarantees that

00:25:50,929 --> 00:25:55,429
you're going to have source maps so

00:25:52,549 --> 00:25:56,929
every single macro that you write you

00:25:55,429 --> 00:25:59,900
will always be able to debug your

00:25:56,929 --> 00:26:01,880
original code whereas if you're using ad

00:25:59,900 --> 00:26:03,169
hoc compilers and stuff like that you'll

00:26:01,880 --> 00:26:06,289
find this the source amount of support

00:26:03,169 --> 00:26:07,970
is usually pretty lacking but this this

00:26:06,289 --> 00:26:09,710
this ensures that you do have source

00:26:07,970 --> 00:26:11,720
maps and that the debugging is actually

00:26:09,710 --> 00:26:13,789
very natural whereas most of the

00:26:11,720 --> 00:26:18,740
browsers these days or supporting source

00:26:13,789 --> 00:26:20,750
maps is pretty awesome so I'm sure some

00:26:18,740 --> 00:26:23,299
of you are sitting there and being like

00:26:20,750 --> 00:26:25,100
well hold on i can't let can't you

00:26:23,299 --> 00:26:26,510
implement some really weird syntax

00:26:25,100 --> 00:26:28,700
doesn't matter isn't this a little bit

00:26:26,510 --> 00:26:30,110
too powerful aren't there going to be

00:26:28,700 --> 00:26:31,790
some really weird things that people do

00:26:30,110 --> 00:26:32,720
i mean like you should never ever be

00:26:31,790 --> 00:26:34,580
able to assign

00:26:32,720 --> 00:26:36,530
to a function call and what it's I mean

00:26:34,580 --> 00:26:38,480
what is that dash even doing I mean like

00:26:36,530 --> 00:26:41,390
like people are going to be doing these

00:26:38,480 --> 00:26:43,429
things that are like what like with what

00:26:41,390 --> 00:26:47,049
the heck is going on here and yes you

00:26:43,429 --> 00:26:49,220
you could do this with with sweet GS and

00:26:47,049 --> 00:26:50,330
we've already seen people do these weird

00:26:49,220 --> 00:26:53,929
things where they're trying to do like

00:26:50,330 --> 00:26:55,850
Ruby do notation sorry if you're like hi

00:26:53,929 --> 00:26:59,929
but I these are the things we shouldn't

00:26:55,850 --> 00:27:03,289
be doing there's a whole decades of

00:26:59,929 --> 00:27:04,520
culture in the list world and a few

00:27:03,289 --> 00:27:06,590
other languages that we can look at to

00:27:04,520 --> 00:27:09,890
see what the right way to write macros

00:27:06,590 --> 00:27:12,679
is I think the in common list they had a

00:27:09,890 --> 00:27:14,960
they I don't know a whole lot about

00:27:12,679 --> 00:27:17,120
communists but as far as I know they

00:27:14,960 --> 00:27:19,360
they kind of got into a culture where

00:27:17,120 --> 00:27:21,590
it's okay to write lots of macros and

00:27:19,360 --> 00:27:22,370
that's actually not right you really

00:27:21,590 --> 00:27:25,309
shouldn't be writing a whole lot of

00:27:22,370 --> 00:27:26,570
macros but if you look at the closure

00:27:25,309 --> 00:27:28,250
world I think they've been able to

00:27:26,570 --> 00:27:30,140
establish a really good culture which

00:27:28,250 --> 00:27:31,880
there's macros used for the really

00:27:30,140 --> 00:27:33,679
powerful features by the people who know

00:27:31,880 --> 00:27:36,350
what they're doing usually internally

00:27:33,679 --> 00:27:39,530
and their release as a library and in

00:27:36,350 --> 00:27:41,299
the core dot something and you can just

00:27:39,530 --> 00:27:42,909
include that library and use it without

00:27:41,299 --> 00:27:45,200
having upgrade your version of closure

00:27:42,909 --> 00:27:46,669
but when you go and sit down to write a

00:27:45,200 --> 00:27:50,210
project you should not go in sit down

00:27:46,669 --> 00:27:52,760
write ten Mackers that's ridiculous so

00:27:50,210 --> 00:27:54,260
there is there are a few problems people

00:27:52,760 --> 00:27:56,780
might have use it there's a syntax

00:27:54,260 --> 00:27:58,700
syntax highlighting problems and some

00:27:56,780 --> 00:28:01,549
people don't like a build step hopefully

00:27:58,700 --> 00:28:04,429
in 10 years me my my goals I have macros

00:28:01,549 --> 00:28:06,230
natively in JavaScript and i'm back by

00:28:04,429 --> 00:28:09,890
brendan eich on that one I think so

00:28:06,230 --> 00:28:11,390
there's some legitimacy to that um but

00:28:09,890 --> 00:28:13,159
really here are my rules for writing

00:28:11,390 --> 00:28:19,549
backers I'm first of all don't run a

00:28:13,159 --> 00:28:20,900
macro because I mean if you don't know

00:28:19,549 --> 00:28:24,169
why you're running a macro then just

00:28:20,900 --> 00:28:25,280
just don't run a macro and if you're

00:28:24,169 --> 00:28:27,559
really going to write a macro don't

00:28:25,280 --> 00:28:29,659
break Jaya syntax don't don't go and

00:28:27,559 --> 00:28:31,970
like if you're tired of curly braces you

00:28:29,659 --> 00:28:33,080
should just be using CoffeeScript don't

00:28:31,970 --> 00:28:35,780
write macros just to get rid of the

00:28:33,080 --> 00:28:38,830
curly braces the macros really just

00:28:35,780 --> 00:28:41,210
enable powerful powerful features like

00:28:38,830 --> 00:28:43,789
variable D structuring all of these es6

00:28:41,210 --> 00:28:46,010
semantics and things like that and

00:28:43,789 --> 00:28:46,640
personally I think if your macro can use

00:28:46,010 --> 00:28:48,560
it as an ex

00:28:46,640 --> 00:28:50,240
if you explain how to code that is still

00:28:48,560 --> 00:28:52,580
an expression I think it's okay to use

00:28:50,240 --> 00:28:53,720
it as a as a parenthesis which looks

00:28:52,580 --> 00:28:55,940
like a function call but I kind of

00:28:53,720 --> 00:28:57,290
expands it out to something else and if

00:28:55,940 --> 00:28:58,940
you're Mike roads as going to be used as

00:28:57,290 --> 00:29:00,920
a statement then you can kind of invoke

00:28:58,940 --> 00:29:03,050
it with a curly brace and it just makes

00:29:00,920 --> 00:29:04,760
it look a little bit more nice syntax

00:29:03,050 --> 00:29:05,960
holler is mostly will deal okay with

00:29:04,760 --> 00:29:07,700
this if you're using something like Jays

00:29:05,960 --> 00:29:08,840
hint things like that that is a problem

00:29:07,700 --> 00:29:11,390
and I think that there are some

00:29:08,840 --> 00:29:13,220
solutions to that maybe extensions to

00:29:11,390 --> 00:29:15,740
those things that implement you actually

00:29:13,220 --> 00:29:17,990
implement your own little patch 2 i'm

00:29:15,740 --> 00:29:20,120
not sure how that looks yep but if you

00:29:17,990 --> 00:29:21,860
really don't want to enable macros in

00:29:20,120 --> 00:29:23,330
your project but you want to use them if

00:29:21,860 --> 00:29:25,820
you're afraid you have an engineer

00:29:23,330 --> 00:29:27,290
that's really overzealous then you could

00:29:25,820 --> 00:29:30,260
write a macro that actually disables

00:29:27,290 --> 00:29:32,780
macros so this lets you this lets you

00:29:30,260 --> 00:29:33,920
use macros NPM install the macros all

00:29:32,780 --> 00:29:37,330
you want to and use a really cool stuff

00:29:33,920 --> 00:29:39,980
npm install es6 but if your overzealous

00:29:37,330 --> 00:29:41,120
college graduate goes and like thinks is

00:29:39,980 --> 00:29:43,520
going to be cool in write macros he'll

00:29:41,120 --> 00:29:45,140
just get an error a syntax error so this

00:29:43,520 --> 00:29:47,930
is a case macro that's run an expansion

00:29:45,140 --> 00:29:52,190
time and throws a syntax error and tells

00:29:47,930 --> 00:29:54,530
him that he's foolish so I think I think

00:29:52,190 --> 00:29:56,180
we can look at things like closure I've

00:29:54,530 --> 00:29:58,660
been really impressed at the court court

00:29:56,180 --> 00:30:00,560
facing library because they were able to

00:29:58,660 --> 00:30:02,240
release this library and people were

00:30:00,560 --> 00:30:03,830
able to use it immediately and this this

00:30:02,240 --> 00:30:07,040
essentially implements not something

00:30:03,830 --> 00:30:08,360
similar to generators at least it's a

00:30:07,040 --> 00:30:10,340
lot more powerful than generators but

00:30:08,360 --> 00:30:11,930
the essential technique is similar to

00:30:10,340 --> 00:30:14,990
the idea of generators we a function can

00:30:11,930 --> 00:30:17,210
be paused at any time they were able to

00:30:14,990 --> 00:30:18,680
do that completely with macros come so

00:30:17,210 --> 00:30:21,320
they so they released it completely as a

00:30:18,680 --> 00:30:22,430
library and I think this is the this is

00:30:21,320 --> 00:30:24,800
the direction that I would love to see

00:30:22,430 --> 00:30:26,330
JavaScript going we we need to get out

00:30:24,800 --> 00:30:29,030
of this standardization process which

00:30:26,330 --> 00:30:30,950
takes decades to get simple things like

00:30:29,030 --> 00:30:32,120
variable D structuring there's no reason

00:30:30,950 --> 00:30:33,440
we need to wait for that when it's such

00:30:32,120 --> 00:30:36,110
a simple macro which I've already

00:30:33,440 --> 00:30:39,200
written in the project i'm going to show

00:30:36,110 --> 00:30:41,000
you there's there's so many things in

00:30:39,200 --> 00:30:43,100
es6 that we can implement as macros and

00:30:41,000 --> 00:30:44,660
that if people were used to macros and

00:30:43,100 --> 00:30:46,610
if we had macros and I wish it more

00:30:44,660 --> 00:30:50,150
natively than we could be go ahead and

00:30:46,610 --> 00:30:51,890
just use them so that's that's my goal

00:30:50,150 --> 00:30:53,840
for first week Jess I think that's kind

00:30:51,890 --> 00:30:55,850
of Mozilla's goal as well to help

00:30:53,840 --> 00:30:58,640
liberate JavaScript from this process of

00:30:55,850 --> 00:31:00,260
sit standardization which typically is

00:30:58,640 --> 00:31:02,300
longer than other languages especially

00:31:00,260 --> 00:31:04,190
because javascript is the mostly wide

00:31:02,300 --> 00:31:05,390
widely use language it's the only

00:31:04,190 --> 00:31:07,850
language I know where there's at least

00:31:05,390 --> 00:31:10,130
three or four extremely competitive with

00:31:07,850 --> 00:31:11,450
implementations of JavaScript so you can

00:31:10,130 --> 00:31:12,980
imagine why the standardization process

00:31:11,450 --> 00:31:14,390
is a little bit slower because you have

00:31:12,980 --> 00:31:16,730
to work with all these vendors all these

00:31:14,390 --> 00:31:18,590
implementations to make sure and then we

00:31:16,730 --> 00:31:19,550
can't even once your standardized we

00:31:18,590 --> 00:31:21,170
can't even use them until they're

00:31:19,550 --> 00:31:22,340
actually implemented what if we took

00:31:21,170 --> 00:31:24,560
control of that what if we actually

00:31:22,340 --> 00:31:25,640
implement them as macro is not not only

00:31:24,560 --> 00:31:26,960
how did not wait for them to be

00:31:25,640 --> 00:31:28,670
standardized but could actually use them

00:31:26,960 --> 00:31:31,490
immediately and then push them into

00:31:28,670 --> 00:31:34,370
standardization we could actually test

00:31:31,490 --> 00:31:36,560
test our ideas test our structures in

00:31:34,370 --> 00:31:37,970
real-world code instead of relying on

00:31:36,560 --> 00:31:41,420
the ECMO committee to make those

00:31:37,970 --> 00:31:43,970
decisions for us so just a quick thing

00:31:41,420 --> 00:31:47,990
if you want es6 i wrote a project asics

00:31:43,970 --> 00:31:51,140
macros it it has destructuring classes

00:31:47,990 --> 00:31:53,870
fat arrows I wrote a macro called define

00:31:51,140 --> 00:31:57,470
record does static allocation it

00:31:53,870 --> 00:31:59,600
actually lets you use types and then it

00:31:57,470 --> 00:32:02,090
compiles the accessors like food X and

00:31:59,600 --> 00:32:04,490
fill out why down to just references

00:32:02,090 --> 00:32:06,380
into a floating-point typed array if you

00:32:04,490 --> 00:32:08,330
want pattern matching one of the core

00:32:06,380 --> 00:32:11,780
contributors he's an awesome guy Nate

00:32:08,330 --> 00:32:13,250
Fallon wrote this pattern matching macro

00:32:11,780 --> 00:32:16,580
which lets you define a function and

00:32:13,250 --> 00:32:18,350
just define patterns if you want better

00:32:16,580 --> 00:32:21,620
we actually a syntax if you want

00:32:18,350 --> 00:32:23,870
generators you can even do that so

00:32:21,620 --> 00:32:25,670
that's the extensibility of macros and I

00:32:23,870 --> 00:32:29,890
think it really does improve the story

00:32:25,670 --> 00:32:29,890

YouTube URL: https://www.youtube.com/watch?v=dxaCWhDFAl4


