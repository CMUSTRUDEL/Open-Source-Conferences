Title: MountainWest JavaScript 2014 - Adding Even More Fun to Functional Programming With RXJS
Publication date: 2020-01-24
Playlist: MountainWest JavaScript 2014
Description: 
	Adding Even More Fun to Functional Programming With RXJS by Ryan Anklam

With the rise in popularity of functional programming lately new ways of writing concise and expressive code have emerged. Reactive JavaScript (RXJS) is one of these and takes functional programming a step further by turning events and asynchronous calls into compostable data streams.
Focusing on how we use RXJS at Netflix, this session will show attendees how to use the 5 pillars of Functional programming: map, mergeAll, filter, reduce, and zip and how they are superior to their imperative counterparts. Attendees will then learn how to use Observable objects to put the "reactive" into their functional code to write code that will react to asynchronous calls and events using the RXJS library.

Help us caption & translate this video!

http://amara.org/v/FG3E/
Captions: 
	00:00:25,930 --> 00:00:30,300
so hopefully I don't spend too much time

00:00:28,540 --> 00:00:32,710
going over what jefra did and kind of

00:00:30,300 --> 00:00:34,809
reiterate his concepts in just a

00:00:32,710 --> 00:00:36,160
slightly different way we're covering a

00:00:34,809 --> 00:00:38,070
lot of the same things but just in it

00:00:36,160 --> 00:00:41,140
from a slightly different approach

00:00:38,070 --> 00:00:44,140
so bought me real quick I am a senior UI

00:00:41,140 --> 00:00:46,510
engineer on Netflix and like jaffer

00:00:44,140 --> 00:00:48,850
point out we do a lot of rx stuff we do

00:00:46,510 --> 00:00:51,549
a lot of rx stuff with Java we do a lot

00:00:48,850 --> 00:00:53,500
of rx programming with groovy and of

00:00:51,549 --> 00:00:58,449
course we do a lot of rx stuff with

00:00:53,500 --> 00:01:00,580
JavaScript I'm also known as bitter

00:00:58,449 --> 00:01:02,229
street riot Ryan pretty much every run

00:01:00,580 --> 00:01:03,699
the internet so follow me on Twitter if

00:01:02,229 --> 00:01:05,560
you like to talked about JavaScript

00:01:03,699 --> 00:01:09,100
check out my github page if you want to

00:01:05,560 --> 00:01:10,840
see some of the stuff I've worked on and

00:01:09,100 --> 00:01:12,610
before I begin I just want to start off

00:01:10,840 --> 00:01:16,210
with a real quick public service

00:01:12,610 --> 00:01:20,200
announcement and that's to be kind to

00:01:16,210 --> 00:01:22,980
those of us with OCD so who this picture

00:01:20,200 --> 00:01:25,090
make anyone else squirm raise your hand

00:01:22,980 --> 00:01:28,330
alright good so you'll understand this

00:01:25,090 --> 00:01:30,850
next slide then and that's please change

00:01:28,330 --> 00:01:37,210
your Dropbox icons to the black and

00:01:30,850 --> 00:01:39,340
white icon all right if you suffer from

00:01:37,210 --> 00:01:41,470
OCD and are talking to someone that has

00:01:39,340 --> 00:01:43,660
that blue icon we won't hear anything

00:01:41,470 --> 00:01:47,320
you say all we're gonna do is look at

00:01:43,660 --> 00:01:49,090
that icon so this right here will make

00:01:47,320 --> 00:01:54,310
us much happier and we'll actually be

00:01:49,090 --> 00:01:56,140
able to listen to you alright so when

00:01:54,310 --> 00:01:59,110
we're talking about reactive JavaScript

00:01:56,140 --> 00:02:02,020
it's built highly on top of functional

00:01:59,110 --> 00:02:03,100
programming so I want to make sure that

00:02:02,020 --> 00:02:05,530
we all have a very solid understanding

00:02:03,100 --> 00:02:07,240
of a lot of the functional concepts that

00:02:05,530 --> 00:02:09,670
we're going to use to build upon to

00:02:07,240 --> 00:02:13,420
create these nice functional observable

00:02:09,670 --> 00:02:14,650
streams so the first one I want to talk

00:02:13,420 --> 00:02:19,060
about I'm gonna talk about the map

00:02:14,650 --> 00:02:25,360
function the filter function the reduce

00:02:19,060 --> 00:02:27,700
function and a function called zip so

00:02:25,360 --> 00:02:28,810
again the map function when we think of

00:02:27,700 --> 00:02:31,090
the map function we're actually thinking

00:02:28,810 --> 00:02:33,220
of data transformation right we're

00:02:31,090 --> 00:02:36,070
taking a collection of objects

00:02:33,220 --> 00:02:38,230
passing them into a projection function

00:02:36,070 --> 00:02:40,840
one item at a time and turning it into

00:02:38,230 --> 00:02:43,920
something else but we're not actually

00:02:40,840 --> 00:02:47,080
going to change our original collection

00:02:43,920 --> 00:02:50,170
so here we're just going to create a new

00:02:47,080 --> 00:02:52,330
set our new collection that's going to

00:02:50,170 --> 00:02:54,130
take a key up a collection and change it

00:02:52,330 --> 00:02:55,630
into something else so this map

00:02:54,130 --> 00:02:59,050
functions going to take every key that's

00:02:55,630 --> 00:03:00,460
pressed and turn that into an AJAX

00:02:59,050 --> 00:03:07,360
request that's going to return another

00:03:00,460 --> 00:03:09,070
observable of JSON results the next

00:03:07,360 --> 00:03:10,870
function I want to talk about is filter

00:03:09,070 --> 00:03:13,780
and that's going to kind of narrow a

00:03:10,870 --> 00:03:16,510
collection down so we're going to expand

00:03:13,780 --> 00:03:17,620
upon that search result sets here and

00:03:16,510 --> 00:03:20,140
we're gonna make sure that we only want

00:03:17,620 --> 00:03:23,020
to take certain or get search result

00:03:20,140 --> 00:03:24,370
sets if their input is one character

00:03:23,020 --> 00:03:27,040
greater so if we don't want to go and

00:03:24,370 --> 00:03:28,090
search a huge data set for just a write

00:03:27,040 --> 00:03:30,190
we want to make sure it's a little bit

00:03:28,090 --> 00:03:32,890
more specific so we want to check for a

00:03:30,190 --> 00:03:35,590
B or something like that and then we can

00:03:32,890 --> 00:03:40,209
just take that and turn those key

00:03:35,590 --> 00:03:41,769
presses again into that JSON data now

00:03:40,209 --> 00:03:43,180
reduces a real interesting one

00:03:41,769 --> 00:03:45,130
it basically is going to take a

00:03:43,180 --> 00:03:49,000
collection and kind of turn it into a

00:03:45,130 --> 00:03:51,070
single value so here we have some eight

00:03:49,000 --> 00:03:54,730
or a variable called HTML that's going

00:03:51,070 --> 00:03:57,580
to be equal to the reduction of that

00:03:54,730 --> 00:03:59,410
search result sets function and so this

00:03:57,580 --> 00:04:01,690
projection function we pass in two

00:03:59,410 --> 00:04:04,120
search results sets is going to get two

00:04:01,690 --> 00:04:07,630
arguments passed into it a previous and

00:04:04,120 --> 00:04:09,910
current that previous argument is going

00:04:07,630 --> 00:04:12,850
to be whatever that function returns and

00:04:09,910 --> 00:04:15,370
the current value is going to be the

00:04:12,850 --> 00:04:16,810
next item in that collection so here

00:04:15,370 --> 00:04:19,959
we're just taking that search result

00:04:16,810 --> 00:04:22,330
sets so a list of values and turning it

00:04:19,959 --> 00:04:23,890
into a single string of HTML that later

00:04:22,330 --> 00:04:28,780
on we can probably insert into the Dom

00:04:23,890 --> 00:04:31,210
or something like that the next one I

00:04:28,780 --> 00:04:32,710
want to talk about is zip zip Swilley a

00:04:31,210 --> 00:04:34,930
hard one to wrap your mind around at

00:04:32,710 --> 00:04:35,860
first because you don't really see the

00:04:34,930 --> 00:04:37,150
usefulness of it

00:04:35,860 --> 00:04:39,280
but when you start doing a lot of

00:04:37,150 --> 00:04:42,220
reactive programming you'll notice that

00:04:39,280 --> 00:04:43,900
you get a lot of lists of data that

00:04:42,220 --> 00:04:46,150
aren't always connected and all the

00:04:43,900 --> 00:04:47,080
times you want to connect those and turn

00:04:46,150 --> 00:04:50,110
them into

00:04:47,080 --> 00:04:53,979
a single value so in this example here

00:04:50,110 --> 00:04:56,289
we have an array of movies and another

00:04:53,979 --> 00:04:58,000
collection that's an array of box arts

00:04:56,289 --> 00:05:00,370
for those movies but right now they're

00:04:58,000 --> 00:05:02,319
not actually synchronized right we have

00:05:00,370 --> 00:05:04,870
these just to two different arrays so

00:05:02,319 --> 00:05:08,169
using the zip function we can take these

00:05:04,870 --> 00:05:09,430
two arrays and zip them together to

00:05:08,169 --> 00:05:11,889
combine them into a single data

00:05:09,430 --> 00:05:13,930
structure that we can actually use so

00:05:11,889 --> 00:05:16,629
here we're going to say with art

00:05:13,930 --> 00:05:19,180
observable dot zip and we're gonna pass

00:05:16,629 --> 00:05:20,440
in both of our arrays and what the zip

00:05:19,180 --> 00:05:22,449
function is going to do is iterate

00:05:20,440 --> 00:05:23,949
through those arrays at the same index

00:05:22,449 --> 00:05:26,199
and pull that out so it's going to give

00:05:23,949 --> 00:05:28,090
you Super Troopers and that first value

00:05:26,199 --> 00:05:30,190
in box arts and then we're gonna combine

00:05:28,090 --> 00:05:33,009
them into a new object that's going to

00:05:30,190 --> 00:05:34,210
have the title in box art and so when we

00:05:33,009 --> 00:05:36,849
do that you see down at the bottom here

00:05:34,210 --> 00:05:39,250
we get an array of objects that have the

00:05:36,849 --> 00:05:45,430
title and box art associated in a single

00:05:39,250 --> 00:05:47,650
object now observable data streams are a

00:05:45,430 --> 00:05:50,110
little bit different than doing

00:05:47,650 --> 00:05:56,680
MapReduce and filter on an object like

00:05:50,110 --> 00:05:58,300
an array in observable I kind of like to

00:05:56,680 --> 00:06:00,310
think of these data streams like a crazy

00:05:58,300 --> 00:06:02,379
straw right you put a crazy straw on a

00:06:00,310 --> 00:06:03,759
cup of milk and you suck it up and it

00:06:02,379 --> 00:06:07,120
kind of twists and turns to the crazy

00:06:03,759 --> 00:06:09,009
straw until you're drinking your milk so

00:06:07,120 --> 00:06:10,569
in this example here at the bottom our

00:06:09,009 --> 00:06:13,240
cup of milk is going to be a keypress

00:06:10,569 --> 00:06:15,879
observable and it's gonna start pushing

00:06:13,240 --> 00:06:17,110
data up this straw as it does it's gonna

00:06:15,879 --> 00:06:19,599
take a twist and turn and we're gonna

00:06:17,110 --> 00:06:22,930
start doing things to that data right so

00:06:19,599 --> 00:06:24,520
first we're gonna throttle it then we're

00:06:22,930 --> 00:06:25,509
gonna filter it out just to get longer

00:06:24,520 --> 00:06:27,279
search results

00:06:25,509 --> 00:06:28,900
so as it travels up the straw it's

00:06:27,279 --> 00:06:30,789
getting it's changing every time

00:06:28,900 --> 00:06:32,889
then we're gonna map through those key

00:06:30,789 --> 00:06:35,620
results to probably get some type of

00:06:32,889 --> 00:06:37,509
Ajax data from them then we're gonna

00:06:35,620 --> 00:06:38,710
call that distinct until change so we'll

00:06:37,509 --> 00:06:41,949
make sure that we're only pushing data

00:06:38,710 --> 00:06:45,669
once it changes into the stream then we

00:06:41,949 --> 00:06:48,009
can reduce it into a single HTML

00:06:45,669 --> 00:06:50,139
structure but none of these are actually

00:06:48,009 --> 00:06:52,750
going to get called until we actually

00:06:50,139 --> 00:06:54,099
start for eating through that data so

00:06:52,750 --> 00:06:55,930
when you build up your compostable data

00:06:54,099 --> 00:06:57,940
stream and observable it's just going to

00:06:55,930 --> 00:06:59,649
sit there until some data actually gets

00:06:57,940 --> 00:07:00,620
called from it or pushed into it then

00:06:59,649 --> 00:07:07,940
all those functions are

00:07:00,620 --> 00:07:09,830
run at once so thinking in a functional

00:07:07,940 --> 00:07:13,639
manner is another very important part of

00:07:09,830 --> 00:07:16,910
reactive programming and there's a lot

00:07:13,639 --> 00:07:18,979
of it's a big transition going from old

00:07:16,910 --> 00:07:22,370
imperative style programming to external

00:07:18,979 --> 00:07:23,630
functional style programming so the

00:07:22,370 --> 00:07:24,830
first thing I want to ask you to do when

00:07:23,630 --> 00:07:28,310
we're when you're writing functional

00:07:24,830 --> 00:07:31,580
code is to replace your loops with the

00:07:28,310 --> 00:07:33,050
functional functions Map Reduce and

00:07:31,580 --> 00:07:36,020
filters a lot of what you can do in a

00:07:33,050 --> 00:07:38,570
loop actually should be inside of a map

00:07:36,020 --> 00:07:41,150
or something like that so here we're

00:07:38,570 --> 00:07:43,729
going to have our search results which

00:07:41,150 --> 00:07:46,760
is going to be an observable of Ajax

00:07:43,729 --> 00:07:48,350
requests and what we really want to do

00:07:46,760 --> 00:07:49,940
is actually take those so it's going to

00:07:48,350 --> 00:07:51,860
be an array of first name and last names

00:07:49,940 --> 00:07:53,660
and what we want to do is take those

00:07:51,860 --> 00:07:56,210
names that combine them together into an

00:07:53,660 --> 00:07:59,090
array of names that is the first name

00:07:56,210 --> 00:08:00,350
combined with the last name so here's

00:07:59,090 --> 00:08:02,360
one way to do it we could get this

00:08:00,350 --> 00:08:04,190
search results observable and then start

00:08:02,360 --> 00:08:06,490
for eaching over them and then inside of

00:08:04,190 --> 00:08:08,690
our for each we're gonna use our

00:08:06,490 --> 00:08:10,990
old-style imperative array to loop

00:08:08,690 --> 00:08:13,220
through those and create that new array

00:08:10,990 --> 00:08:15,770
but we got a lot of Staton here we're

00:08:13,220 --> 00:08:17,389
creating a new variable and we're

00:08:15,770 --> 00:08:18,410
pushing to it so you know it's not

00:08:17,389 --> 00:08:21,710
really the best way to do it

00:08:18,410 --> 00:08:23,930
functionally so a better way would be to

00:08:21,710 --> 00:08:26,180
replace that loop with the map a little

00:08:23,930 --> 00:08:28,340
bit higher up in the data stream so now

00:08:26,180 --> 00:08:30,590
we're going to get those search results

00:08:28,340 --> 00:08:33,140
we're gonna take each one of those Ajax

00:08:30,590 --> 00:08:35,029
requests and map it into a first name

00:08:33,140 --> 00:08:37,599
plus last name then we're we're going to

00:08:35,029 --> 00:08:40,219
for each of those search results each

00:08:37,599 --> 00:08:41,659
thing getting passed into that our

00:08:40,219 --> 00:08:45,950
projection function is actually going to

00:08:41,659 --> 00:08:47,570
be first name and last name so the

00:08:45,950 --> 00:08:51,680
second thing I want to talk about is

00:08:47,570 --> 00:08:53,420
replace if statements with filters so a

00:08:51,680 --> 00:08:55,370
good example of this is when you're

00:08:53,420 --> 00:08:56,990
listening for creaky presses right if

00:08:55,370 --> 00:08:59,000
you want to just do something on the in

00:08:56,990 --> 00:09:01,670
Turkey so here we're just going to

00:08:59,000 --> 00:09:03,800
create a new observable from key presses

00:09:01,670 --> 00:09:05,510
and then we're gonna do our for each and

00:09:03,800 --> 00:09:08,390
inside of that for each we're gonna say

00:09:05,510 --> 00:09:09,260
if eat out which is the Enter key then

00:09:08,390 --> 00:09:12,260
we're going to do something with that

00:09:09,260 --> 00:09:14,180
data so a more functional way to look at

00:09:12,260 --> 00:09:15,410
that problem is using filter

00:09:14,180 --> 00:09:17,960
and we're gonna create a variable called

00:09:15,410 --> 00:09:19,190
inter presses so there are variables

00:09:17,960 --> 00:09:21,050
gonna be a little bit more specific to

00:09:19,190 --> 00:09:22,430
what we're trying to accomplish and

00:09:21,050 --> 00:09:25,130
we're just gonna do the same thing we're

00:09:22,430 --> 00:09:27,230
gonna say o dot from event key ups and

00:09:25,130 --> 00:09:27,830
then we're gonna filter out only our key

00:09:27,230 --> 00:09:30,290
presses

00:09:27,830 --> 00:09:32,030
there are inter keys then we can loop

00:09:30,290 --> 00:09:34,190
through those inter presses and do only

00:09:32,030 --> 00:09:38,530
the thing that we want to do for inter

00:09:34,190 --> 00:09:38,530
presses in this particular for each loop

00:09:39,850 --> 00:09:44,060
another thing that you can get caught up

00:09:42,380 --> 00:09:45,920
and doing when you're writing reactive

00:09:44,060 --> 00:09:48,740
JavaScript or functional programming is

00:09:45,920 --> 00:09:51,080
create this huge stream with map filters

00:09:48,740 --> 00:09:53,690
reduce throttles and you're trying to do

00:09:51,080 --> 00:09:55,190
a ton of stuff in a single stream when

00:09:53,690 --> 00:09:56,780
really what you want to do is try to

00:09:55,190 --> 00:09:58,790
kind of break these things up into two

00:09:56,780 --> 00:10:00,830
different streams so here if you look

00:09:58,790 --> 00:10:02,390
down at that filter function we're

00:10:00,830 --> 00:10:03,770
actually gonna do we're trying to create

00:10:02,390 --> 00:10:07,460
a stream that does something for both

00:10:03,770 --> 00:10:09,320
enter keys and escape keys so a better

00:10:07,460 --> 00:10:11,300
way to think about this this particular

00:10:09,320 --> 00:10:13,310
problem here is to break that up into

00:10:11,300 --> 00:10:15,020
two different streams so here we have

00:10:13,310 --> 00:10:17,390
our throttle in map just like we had

00:10:15,020 --> 00:10:19,310
before but we're gonna create two new

00:10:17,390 --> 00:10:21,890
streams an inter stream that's going to

00:10:19,310 --> 00:10:24,320
be only for inter presses an escape

00:10:21,890 --> 00:10:34,310
scream stream that's only going to be

00:10:24,320 --> 00:10:36,500
for escape key presses so like Jeff Brad

00:10:34,310 --> 00:10:38,990
mentioned before flattening patterns is

00:10:36,500 --> 00:10:41,210
a very important part of reactive

00:10:38,990 --> 00:10:44,120
JavaScript so once we get these data

00:10:41,210 --> 00:10:45,250
streams composed of observables or in a

00:10:44,120 --> 00:10:48,200
lot of cases we're gonna have

00:10:45,250 --> 00:10:50,390
observables with nested observables in

00:10:48,200 --> 00:10:52,880
them we gotta take that nested structure

00:10:50,390 --> 00:10:54,560
and build it out into a flat structure

00:10:52,880 --> 00:10:57,110
and that's where flattening patterns

00:10:54,560 --> 00:11:00,070
come in that's also how we manage

00:10:57,110 --> 00:11:04,610
concurrency and asynchronous requests in

00:11:00,070 --> 00:11:07,100
observable streams so let's take a look

00:11:04,610 --> 00:11:10,100
at key presses right so the key presses

00:11:07,100 --> 00:11:12,470
an observable of key presses is just a

00:11:10,100 --> 00:11:14,480
list of key presses over a period of

00:11:12,470 --> 00:11:16,250
time so you can think of that timeline

00:11:14,480 --> 00:11:18,410
on the bottom is actually being an

00:11:16,250 --> 00:11:20,150
observable object and if someone's

00:11:18,410 --> 00:11:22,580
trying to search a Netflix for the movie

00:11:20,150 --> 00:11:24,290
Breaking Bad every time they type a key

00:11:22,580 --> 00:11:27,100
it's going to add that data to our

00:11:24,290 --> 00:11:29,020
observable

00:11:27,100 --> 00:11:31,270
it's not always perfect right because

00:11:29,020 --> 00:11:32,800
what if they have a typo in that they

00:11:31,270 --> 00:11:34,510
start typing breaking bad but they hit a

00:11:32,800 --> 00:11:36,070
J instead of an eye they're gonna hit

00:11:34,510 --> 00:11:38,830
the back key then they're gonna hit the

00:11:36,070 --> 00:11:41,560
eye and where this gets interesting is

00:11:38,830 --> 00:11:45,100
when we take those key presses and start

00:11:41,560 --> 00:11:48,400
turning those into Ajax requests so down

00:11:45,100 --> 00:11:50,410
here again our timeline is unobservable

00:11:48,400 --> 00:11:53,080
but inside of that observer but we have

00:11:50,410 --> 00:11:55,540
all these other observables that our

00:11:53,080 --> 00:11:56,290
Ajax requests and if you look at the

00:11:55,540 --> 00:11:59,440
problem here

00:11:56,290 --> 00:12:02,230
this fourth request is actually going to

00:11:59,440 --> 00:12:03,220
come in before that third request we

00:12:02,230 --> 00:12:05,980
want to make sure that the user never

00:12:03,220 --> 00:12:11,410
sees that third request once this fourth

00:12:05,980 --> 00:12:13,810
one comes in so reactive JavaScript's

00:12:11,410 --> 00:12:15,850
gives us three different types of

00:12:13,810 --> 00:12:17,560
flattening patterns that we can use to

00:12:15,850 --> 00:12:19,660
accomplish just about any type of

00:12:17,560 --> 00:12:22,870
concurrency or solve any type of problem

00:12:19,660 --> 00:12:25,990
we have so the first one is going to be

00:12:22,870 --> 00:12:29,290
the merge function second one is going

00:12:25,990 --> 00:12:35,140
to be concat and the third one is going

00:12:29,290 --> 00:12:36,640
to be switch latest so merge like Java

00:12:35,140 --> 00:12:40,030
showed you before it's going to actually

00:12:36,640 --> 00:12:41,950
combine each item in collections as they

00:12:40,030 --> 00:12:44,080
arrive so if we have nested collections

00:12:41,950 --> 00:12:45,640
when one of those nested collections has

00:12:44,080 --> 00:12:48,630
a piece of data it's just going to throw

00:12:45,640 --> 00:12:51,130
it into that observable or the outer one

00:12:48,630 --> 00:12:52,840
concat is going to combine entire

00:12:51,130 --> 00:12:55,030
collections at a time so if we have an

00:12:52,840 --> 00:12:56,710
observable above observable collections

00:12:55,030 --> 00:12:58,180
it's going to wait till the first one is

00:12:56,710 --> 00:12:59,710
done setting data before it starts

00:12:58,180 --> 00:13:02,860
grabbing data from the second one and

00:12:59,710 --> 00:13:05,080
the third one and switch latest is

00:13:02,860 --> 00:13:07,930
actually going to switch to the latest

00:13:05,080 --> 00:13:11,770
collection that arrives in a nested

00:13:07,930 --> 00:13:15,010
observable structure so here's a quick

00:13:11,770 --> 00:13:17,700
visualization of how merge works so here

00:13:15,010 --> 00:13:20,530
we have this purple bar at the bottom

00:13:17,700 --> 00:13:22,780
represents an observable and these other

00:13:20,530 --> 00:13:26,020
colored bars inside of it represent

00:13:22,780 --> 00:13:29,410
nested observables inside of that so as

00:13:26,020 --> 00:13:30,400
time goes by our our first observable is

00:13:29,410 --> 00:13:32,290
going to hit and it's going to put the

00:13:30,400 --> 00:13:34,360
data in that structure and since we're

00:13:32,290 --> 00:13:36,760
merging them together when the second

00:13:34,360 --> 00:13:38,800
one comes it's going to put that one in

00:13:36,760 --> 00:13:40,450
the structure out of order so this this

00:13:38,800 --> 00:13:40,630
green bar here is actually requests with

00:13:40,450 --> 00:13:42,970
X

00:13:40,630 --> 00:13:44,950
sent out before that third one but the

00:13:42,970 --> 00:13:46,450
data arrived in the third one first so

00:13:44,950 --> 00:13:49,750
since we're merging it it gets put in

00:13:46,450 --> 00:13:53,920
the observable next then our third one

00:13:49,750 --> 00:13:57,630
and then our fourth one so here's a

00:13:53,920 --> 00:13:57,630
little bit more concrete example I have

00:14:02,970 --> 00:14:09,400
chrome all right

00:14:07,450 --> 00:14:21,550
let's see if I can navigate this one I

00:14:09,400 --> 00:14:24,160
am turned around okay so we just want

00:14:21,550 --> 00:14:26,940
our so here's our JavaScript basically

00:14:24,160 --> 00:14:31,120
we're taking an observable of vegetables

00:14:26,940 --> 00:14:33,190
and an observable the fruits up here and

00:14:31,120 --> 00:14:35,470
the important part is that very last

00:14:33,190 --> 00:14:39,250
line right here we're gonna say fruits

00:14:35,470 --> 00:14:43,060
dot concat actually I want the merge

00:14:39,250 --> 00:14:45,340
example first sorry about that okay so

00:14:43,060 --> 00:14:47,830
here we go we're going to say fruits dot

00:14:45,340 --> 00:14:50,710
merge veggies and then we're going to

00:14:47,830 --> 00:14:53,440
form each over them so we're gonna get

00:14:50,710 --> 00:14:55,510
is the fruits is gonna send off a data

00:14:53,440 --> 00:14:57,340
of a fruit and a random interval and the

00:14:55,510 --> 00:14:59,830
veggies are gonna fire an event at a

00:14:57,340 --> 00:15:04,120
random interval and so we actually go

00:14:59,830 --> 00:15:06,700
ahead and run this code you see that we

00:15:04,120 --> 00:15:08,020
get our fruits mixed in with our veggies

00:15:06,700 --> 00:15:10,840
when this observable starts emitting

00:15:08,020 --> 00:15:13,300
data so apple tomato banana carrot

00:15:10,840 --> 00:15:17,160
pepper so it's very random right we got

00:15:13,300 --> 00:15:17,160
fruits intermixed with veggies

00:15:22,370 --> 00:15:28,370
talk about concat so what can cats going

00:15:25,040 --> 00:15:30,589
to do is it's going to add elements or

00:15:28,370 --> 00:15:32,360
data to that outer observable that you

00:15:30,589 --> 00:15:36,259
want to flatten it to in the order they

00:15:32,360 --> 00:15:39,529
were created so in this case data is

00:15:36,259 --> 00:15:40,399
going to come in first then that second

00:15:39,529 --> 00:15:41,839
one's gonna come in and it's gonna

00:15:40,399 --> 00:15:43,639
actually add that data the animation

00:15:41,839 --> 00:15:45,230
actually didn't run properly but the

00:15:43,639 --> 00:15:47,300
second one is gonna come in and add it

00:15:45,230 --> 00:15:50,709
to that stream then the third one is

00:15:47,300 --> 00:15:56,290
going to go and order than the last one

00:15:50,709 --> 00:15:56,290
let's look at that example up here again

00:15:59,290 --> 00:16:04,220
okay so the important part here is that

00:16:01,490 --> 00:16:06,620
we're actually using fruits dot concat

00:16:04,220 --> 00:16:10,689
instead of merge and we run this code

00:16:06,620 --> 00:16:13,459
here you see that we get all of our

00:16:10,689 --> 00:16:15,529
fruits before all of our vegetables

00:16:13,459 --> 00:16:18,490
soken cat is going to put them in the

00:16:15,529 --> 00:16:18,490
order that you add them

00:16:27,470 --> 00:16:32,060
there's my animation that I wanted great

00:16:30,160 --> 00:16:35,780
okay so the last one I want to talk

00:16:32,060 --> 00:16:37,910
about is switch latest and what switch

00:16:35,780 --> 00:16:39,950
latest is going to do is actually change

00:16:37,910 --> 00:16:43,010
the observable that's in that outer

00:16:39,950 --> 00:16:45,290
observable as data comes in so when our

00:16:43,010 --> 00:16:47,480
first one hits the data is going to be

00:16:45,290 --> 00:16:49,250
the first the data from our first

00:16:47,480 --> 00:16:51,350
observable that's gonna come along in

00:16:49,250 --> 00:16:54,350
our second one's going to hit and it's

00:16:51,350 --> 00:16:55,820
going to add that data to our observable

00:16:54,350 --> 00:16:57,710
and it's just going to forget about the

00:16:55,820 --> 00:16:59,690
second one because we're switching to

00:16:57,710 --> 00:17:01,610
the latest data we want then when the

00:16:59,690 --> 00:17:05,030
third one comes in it's going to go

00:17:01,610 --> 00:17:11,630
ahead and add that third one to our

00:17:05,030 --> 00:17:13,550
outer observable all right

00:17:11,630 --> 00:17:15,770
so now what I want to do is kind of take

00:17:13,550 --> 00:17:18,020
Jaffer's example of an autocomplete and

00:17:15,770 --> 00:17:20,089
actually build upon that and kind of

00:17:18,020 --> 00:17:24,050
build something that's what we call an

00:17:20,089 --> 00:17:27,079
animated autocomplete so at Netflix on

00:17:24,050 --> 00:17:29,060
certain consoles we have an autocomplete

00:17:27,079 --> 00:17:33,140
that looks a little bit like this so

00:17:29,060 --> 00:17:36,890
when a user starts typing data comes in

00:17:33,140 --> 00:17:38,990
from the right-hand side as as as it

00:17:36,890 --> 00:17:41,990
comes in from the Ajax request then as

00:17:38,990 --> 00:17:44,900
they keep typing the next result will

00:17:41,990 --> 00:17:48,580
fade out the next one will fade in and

00:17:44,900 --> 00:17:51,110
that's a really tricky thing to actually

00:17:48,580 --> 00:17:52,640
synchronize here because Ajax requests

00:17:51,110 --> 00:17:54,860
are coming in at different intervals and

00:17:52,640 --> 00:17:57,050
if you have an ajax request that comes

00:17:54,860 --> 00:17:58,760
in well that the results are animating

00:17:57,050 --> 00:18:00,620
in you don't want that animate just to

00:17:58,760 --> 00:18:01,610
pop right off another one to come in you

00:18:00,620 --> 00:18:03,560
want to make sure those animations

00:18:01,610 --> 00:18:05,830
actually complete in the order they were

00:18:03,560 --> 00:18:07,550
given or the order they were added

00:18:05,830 --> 00:18:09,560
otherwise the user is going to have a

00:18:07,550 --> 00:18:12,440
bad experience and it's gonna seem real

00:18:09,560 --> 00:18:14,240
jumpy so I like to think of an

00:18:12,440 --> 00:18:16,850
autocomplete as it's as a real simple

00:18:14,240 --> 00:18:19,040
widget with the real high amount of

00:18:16,850 --> 00:18:21,470
complexity right so we got to respond to

00:18:19,040 --> 00:18:25,460
key presses for each key press we're

00:18:21,470 --> 00:18:27,140
gonna send off an ajax request for each

00:18:25,460 --> 00:18:29,570
key press we're also going to add a mate

00:18:27,140 --> 00:18:32,660
out when old search results become

00:18:29,570 --> 00:18:35,810
invalid and we need to animate in when

00:18:32,660 --> 00:18:36,890
new research results come in and again

00:18:35,810 --> 00:18:38,960
we need to make sure that we're only

00:18:36,890 --> 00:18:41,350
showing showing them the most current

00:18:38,960 --> 00:18:43,400
search that they had

00:18:41,350 --> 00:18:46,640
and lastly we got to make sure one

00:18:43,400 --> 00:18:56,000
animation is completely finished before

00:18:46,640 --> 00:18:57,890
we start another animation so let's

00:18:56,000 --> 00:18:59,420
build this out so the first thing we

00:18:57,890 --> 00:19:01,130
need to do is listen for those key ups

00:18:59,420 --> 00:19:04,490
so we're going to create a new

00:19:01,130 --> 00:19:08,240
observable from every time the user hits

00:19:04,490 --> 00:19:10,760
a key inside of a our search thing our

00:19:08,240 --> 00:19:12,710
search input then we're going to need to

00:19:10,760 --> 00:19:16,430
do again is transfer those search

00:19:12,710 --> 00:19:17,690
results into Ajax requests so here we're

00:19:16,430 --> 00:19:19,940
just going to take those search result

00:19:17,690 --> 00:19:21,770
sets we're gonna filter them make sure

00:19:19,940 --> 00:19:23,900
that the user has entered more than one

00:19:21,770 --> 00:19:26,240
key press and we're going to take those

00:19:23,900 --> 00:19:28,400
key presses and map them into the data

00:19:26,240 --> 00:19:30,980
we actually want to do something with

00:19:28,400 --> 00:19:35,450
which is data returned from our Search

00:19:30,980 --> 00:19:37,040
API and again the important part to

00:19:35,450 --> 00:19:38,540
notice down here is switch latest so

00:19:37,040 --> 00:19:40,730
we're always going to only get and

00:19:38,540 --> 00:19:45,200
display the latest data that comes in

00:19:40,730 --> 00:19:47,120
from those Ajax requests now this is

00:19:45,200 --> 00:19:49,340
where it gets interesting because now we

00:19:47,120 --> 00:19:51,440
got to take those Ajax results and start

00:19:49,340 --> 00:19:53,120
animating things and we need to make

00:19:51,440 --> 00:19:55,490
sure that those animations are going to

00:19:53,120 --> 00:19:57,320
be in the right order so the first thing

00:19:55,490 --> 00:20:01,310
we're going to do is actually create two

00:19:57,320 --> 00:20:02,660
new observables one for key ups so every

00:20:01,310 --> 00:20:03,920
time the user hits an additional key

00:20:02,660 --> 00:20:07,250
we're going to invalidate the old

00:20:03,920 --> 00:20:09,200
results and so all we're going to do

00:20:07,250 --> 00:20:11,240
there is return a new observable called

00:20:09,200 --> 00:20:13,850
animate out that's going to take a div

00:20:11,240 --> 00:20:15,920
and animate it off the screen and we

00:20:13,850 --> 00:20:18,260
create another observable called animate

00:20:15,920 --> 00:20:20,660
ins and that's going to take the search

00:20:18,260 --> 00:20:24,500
result sets so those are the results

00:20:20,660 --> 00:20:26,540
from your Ajax request and it's going to

00:20:24,500 --> 00:20:27,770
map them and do two different things so

00:20:26,540 --> 00:20:30,620
first it's going to create a new

00:20:27,770 --> 00:20:32,060
observable that's going to take the

00:20:30,620 --> 00:20:34,970
actual data from their search results

00:20:32,060 --> 00:20:37,790
and add it to that new observable and is

00:20:34,970 --> 00:20:40,070
also going to concatenate and animate in

00:20:37,790 --> 00:20:42,080
observable with that so when we do this

00:20:40,070 --> 00:20:44,270
because an animation really doesn't have

00:20:42,080 --> 00:20:45,650
any data to add to the stream we need to

00:20:44,270 --> 00:20:47,150
make sure that when we return this out

00:20:45,650 --> 00:20:49,010
of the map function we still have our

00:20:47,150 --> 00:20:51,020
search results so when we listen to that

00:20:49,010 --> 00:20:55,060
stream we can pull the data out of that

00:20:51,020 --> 00:21:00,020
to add them to the UI

00:20:55,060 --> 00:21:01,940
and these first four lines are all we

00:21:00,020 --> 00:21:04,780
really need to do to make sure that all

00:21:01,940 --> 00:21:08,270
of this happens in the right order and

00:21:04,780 --> 00:21:09,980
that's kind of a the real powerful or

00:21:08,270 --> 00:21:12,710
the powerful part of observables right

00:21:09,980 --> 00:21:14,900
so we're gonna take the animate outs and

00:21:12,710 --> 00:21:16,880
we're gonna merge them with animate ends

00:21:14,900 --> 00:21:18,710
because we don't really care what order

00:21:16,880 --> 00:21:21,050
they happen if we have to animate outs

00:21:18,710 --> 00:21:22,280
at the same time ones can already be off

00:21:21,050 --> 00:21:25,280
the screen so you're not going to see

00:21:22,280 --> 00:21:27,110
that twice in a row if we have to

00:21:25,280 --> 00:21:29,480
animate ends in a row we do want to make

00:21:27,110 --> 00:21:30,980
sure they complete and that's where this

00:21:29,480 --> 00:21:33,020
can cat all comes in so now we're just

00:21:30,980 --> 00:21:35,420
going to add them to the outer

00:21:33,020 --> 00:21:38,450
observable in the order they come in but

00:21:35,420 --> 00:21:40,430
by concatenating them all we make sure

00:21:38,450 --> 00:21:43,310
that they happen one after the other so

00:21:40,430 --> 00:21:46,760
we don't have janky fly ins and fly outs

00:21:43,310 --> 00:21:49,160
and the last part of it all we have to

00:21:46,760 --> 00:21:51,830
do is take that combined observable and

00:21:49,160 --> 00:21:53,300
now we start for reaching over them so

00:21:51,830 --> 00:21:55,250
this is where you can kind of break out

00:21:53,300 --> 00:21:57,560
of the functional programming and start

00:21:55,250 --> 00:21:59,750
doing some imperative programming so in

00:21:57,560 --> 00:22:02,450
Netflix we try to only manipulate the

00:21:59,750 --> 00:22:03,620
Dom inside of a for each statement so we

00:22:02,450 --> 00:22:04,820
don't try to do any type of Dom

00:22:03,620 --> 00:22:06,920
manipulation or anything like that

00:22:04,820 --> 00:22:08,540
inside of a map or filter or reduce or

00:22:06,920 --> 00:22:12,170
anything like that it's always at the

00:22:08,540 --> 00:22:14,330
end of a data stream so all we're going

00:22:12,170 --> 00:22:16,850
to do is for each it and then we're

00:22:14,330 --> 00:22:18,710
gonna hide it if there are no results

00:22:16,850 --> 00:22:21,440
there otherwise we're just gonna set the

00:22:18,710 --> 00:22:27,770
inner HTML of that div or the are fly-in

00:22:21,440 --> 00:22:30,650
and if you put all that together it's

00:22:27,770 --> 00:22:32,150
not a whole lot of code um it's some of

00:22:30,650 --> 00:22:34,340
these observable data streams do get a

00:22:32,150 --> 00:22:38,300
little bit longer because you are

00:22:34,340 --> 00:22:39,890
creating you know short snippets of code

00:22:38,300 --> 00:22:41,660
your your cold line length is really

00:22:39,890 --> 00:22:43,240
short when you're doing these but that's

00:22:41,660 --> 00:22:45,610
not a ton of code for an autocomplete

00:22:43,240 --> 00:22:52,880
especially considering how much

00:22:45,610 --> 00:22:55,400
concurrency we have to manage there all

00:22:52,880 --> 00:22:56,870
right and that's all I have if you do

00:22:55,400 --> 00:22:59,180
have any questions you want to talk to

00:22:56,870 --> 00:23:00,140
me more about reactive JavaScript you

00:22:59,180 --> 00:23:03,020
want to get together and hack on

00:23:00,140 --> 00:23:07,040
reactive JavaScript I am our ankle

00:23:03,020 --> 00:23:08,299
amande netflix.com and I also am on

00:23:07,040 --> 00:23:10,399
Twitter again at bitter Street right

00:23:08,299 --> 00:23:11,599
if you want to come talk to me about you

00:23:10,399 --> 00:23:12,619
know what we're doing at Netflix we're

00:23:11,599 --> 00:23:14,869
doing some really neat things with

00:23:12,619 --> 00:23:16,219
JavaScript these days so if you want to

00:23:14,869 --> 00:23:17,989
talk to us talk to me and find out what

00:23:16,219 --> 00:23:21,339
we're doing and get a little more

00:23:17,989 --> 00:23:21,339

YouTube URL: https://www.youtube.com/watch?v=8EExNfm0gt4


