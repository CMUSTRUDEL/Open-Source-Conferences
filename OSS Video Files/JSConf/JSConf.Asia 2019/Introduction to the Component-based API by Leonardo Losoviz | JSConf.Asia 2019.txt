Title: Introduction to the Component-based API by Leonardo Losoviz | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	The Component-based API is a new concept of API which pushes further from GraphQL the boundaries of how much data can be retrieved in a single request, how data is organized into an effective hierarchical structure, and how fast can data be retrieved from the DB. We will learn what this new API looks like, how to use it, and how our application can become more modular through it.

Leonardo is an independent open source developer, creator of a framework for building modular websites called "PoP". The only non-musician in his family, this doesn't bother him, because coding is also making art. He lives in a loop: he dreams of code and, when he wakes up, he codes his dreams.


JSConf.Asia - LASALLE College of the Arts, Singapore - 15 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:00,000 --> 00:00:21,060
oh hello everyone I can see that people

00:00:18,600 --> 00:00:23,220
are still having a coffee out there so

00:00:21,060 --> 00:00:24,810
hopefully you can rush and come in so

00:00:23,220 --> 00:00:27,060
that we don't lose much time with this

00:00:24,810 --> 00:00:29,160
presentation okay so we start my name is

00:00:27,060 --> 00:00:31,920
Naruto so ease as they were mentioning

00:00:29,160 --> 00:00:36,600
I'm from Argentina very living kale and

00:00:31,920 --> 00:00:38,730
I came to talk about api's the

00:00:36,600 --> 00:00:39,840
presentation slice are already online so

00:00:38,730 --> 00:00:42,140
you can actually check it out

00:00:39,840 --> 00:00:44,940
slice come slash lilo so slash

00:00:42,140 --> 00:00:47,610
component-based API you can actually

00:00:44,940 --> 00:00:50,250
take a picture of that if you want to

00:00:47,610 --> 00:00:52,739
check it out later I will give quite

00:00:50,250 --> 00:00:55,199
some stuff 25 minutes is kind of hard to

00:00:52,739 --> 00:00:57,750
fit everything in so if you want to find

00:00:55,199 --> 00:00:59,910
out more later I mean maybe we can go in

00:00:57,750 --> 00:01:03,420
more detail and my twitter handle is

00:00:59,910 --> 00:01:06,570
your service same as my surname okay so

00:01:03,420 --> 00:01:08,700
we start so if we're talking old api's

00:01:06,570 --> 00:01:13,830
we must talk about the current host

00:01:08,700 --> 00:01:17,130
stuff which is what graph cured right so

00:01:13,830 --> 00:01:19,590
graph QL is increasingly popular this is

00:01:17,130 --> 00:01:22,470
the stats from the state of JavaScript

00:01:19,590 --> 00:01:24,720
from last year that is says that 20% of

00:01:22,470 --> 00:01:25,979
people who have used it they have they

00:01:24,720 --> 00:01:29,159
have liked it so they won't talk should

00:01:25,979 --> 00:01:31,409
use it again and 62% they have heard of

00:01:29,159 --> 00:01:34,140
it unlike to learn so I mean this is

00:01:31,409 --> 00:01:36,210
certainly gaining ground and we can

00:01:34,140 --> 00:01:39,720
expect graph QL to be the new normal

00:01:36,210 --> 00:01:41,820
affion maybe time out for rest a lot of

00:01:39,720 --> 00:01:43,680
rest api switch are still out there of

00:01:41,820 --> 00:01:45,390
course but it like if you have to start

00:01:43,680 --> 00:01:46,770
a new project quite likely you might

00:01:45,390 --> 00:01:49,829
actually want to do it graph QL oh

00:01:46,770 --> 00:01:52,649
that's the situation right now so why is

00:01:49,829 --> 00:01:54,720
it so the one characteristic from graph

00:01:52,649 --> 00:01:56,549
QL that everyone talks about is how you

00:01:54,720 --> 00:01:59,040
can actually get exactly the data that

00:01:56,549 --> 00:02:00,990
you need to fill your layouts your

00:01:59,040 --> 00:02:03,689
components so say that you have this

00:02:00,990 --> 00:02:05,549
layout ok so this is like a widget with

00:02:03,689 --> 00:02:07,619
a feature director we have they're

00:02:05,549 --> 00:02:10,270
showing a couple of themes and each film

00:02:07,619 --> 00:02:12,010
showing some of its outdoors

00:02:10,270 --> 00:02:14,740
so the way that you actually fetch the

00:02:12,010 --> 00:02:17,110
data through mmm through okay well

00:02:14,740 --> 00:02:18,910
actually you need to get data so in the

00:02:17,110 --> 00:02:21,610
case of the director we need to get the

00:02:18,910 --> 00:02:23,080
name the country on the avatar then for

00:02:21,610 --> 00:02:25,600
each of the things we have the thumbnail

00:02:23,080 --> 00:02:28,300
and the time and then for reactors we

00:02:25,600 --> 00:02:30,670
have the avatar and the name so graph QL

00:02:28,300 --> 00:02:32,740
is very straightforward you can define a

00:02:30,670 --> 00:02:35,110
scheme and then you define a query that

00:02:32,740 --> 00:02:37,210
lets you get the data as you need it and

00:02:35,110 --> 00:02:39,070
what you're actually get from this is a

00:02:37,210 --> 00:02:40,540
response with the data in the structure

00:02:39,070 --> 00:02:42,790
as you need it so this is actually quite

00:02:40,540 --> 00:02:45,130
cool right you get exactly what you need

00:02:42,790 --> 00:02:48,550
so this is improvement of a rest and why

00:02:45,130 --> 00:02:50,680
is taking over from rest and this plays

00:02:48,550 --> 00:02:52,330
very nicely with components so if you're

00:02:50,680 --> 00:02:55,680
actually guys calling with Riyadh and

00:02:52,330 --> 00:03:00,070
buges I guess that's in the situation

00:02:55,680 --> 00:03:02,710
you will actually love graph QL because

00:03:00,070 --> 00:03:04,300
it goes one-to-one with with with the

00:03:02,710 --> 00:03:06,160
concept of components so in this

00:03:04,300 --> 00:03:10,360
situation we have an outer component

00:03:06,160 --> 00:03:12,520
called feature director which has a film

00:03:10,360 --> 00:03:15,460
it iterates over the list of films and

00:03:12,520 --> 00:03:19,030
each film component has an called an

00:03:15,460 --> 00:03:20,920
actor component okay and if you actually

00:03:19,030 --> 00:03:23,560
pay attention to this is exactly the

00:03:20,920 --> 00:03:26,590
same structure so very practical for

00:03:23,560 --> 00:03:29,830
this so so far so good graph QL is

00:03:26,590 --> 00:03:31,630
awesome but it is not perfect and

00:03:29,830 --> 00:03:33,910
luckily so it comes with a few

00:03:31,630 --> 00:03:36,850
limitations or trade-offs we can

00:03:33,910 --> 00:03:38,590
actually say so one of the trade-offs is

00:03:36,850 --> 00:03:42,730
that it is not catchable on the back end

00:03:38,590 --> 00:03:44,620
you can still cache the aquarium but it

00:03:42,730 --> 00:03:46,480
has to be on the client side and there

00:03:44,620 --> 00:03:48,760
is a penalty for that because you're

00:03:46,480 --> 00:03:50,170
adding code to the front-end you had to

00:03:48,760 --> 00:03:52,980
part the JavaScript you had to execute

00:03:50,170 --> 00:03:55,390
the JavaScript sorry not ideal okay

00:03:52,980 --> 00:03:58,450
another problem is that this is

00:03:55,390 --> 00:04:00,400
acceptable to denial of service attacks

00:03:58,450 --> 00:04:02,410
because now you're given a lot of power

00:04:00,400 --> 00:04:07,570
to the client to fetch whatever data

00:04:02,410 --> 00:04:10,720
they want so if any evil person they

00:04:07,570 --> 00:04:13,360
won't actually take your database down

00:04:10,720 --> 00:04:16,060
they can actually execute a very complex

00:04:13,360 --> 00:04:18,040
query that maybe you're thoroughly like

00:04:16,060 --> 00:04:20,680
take one second to process it doesn't

00:04:18,040 --> 00:04:22,630
seem so much but actually doing that for

00:04:20,680 --> 00:04:24,100
many many thousands of course can

00:04:22,630 --> 00:04:24,699
actually take the data rate down on your

00:04:24,100 --> 00:04:27,009
server

00:04:24,699 --> 00:04:30,070
so once again they can be mitigated

00:04:27,009 --> 00:04:34,000
they're like strategies for dealing with

00:04:30,070 --> 00:04:35,590
the with these gos attacks but it's all

00:04:34,000 --> 00:04:36,850
in complexity to the application now you

00:04:35,590 --> 00:04:38,500
had to actually think about the

00:04:36,850 --> 00:04:41,169
complexity of the query you have to

00:04:38,500 --> 00:04:42,850
think out the nested that the depth of

00:04:41,169 --> 00:04:44,470
the query you can limit that you can

00:04:42,850 --> 00:04:48,639
actually think about timeout so once

00:04:44,470 --> 00:04:49,690
again this is not ideal so let me

00:04:48,639 --> 00:04:52,389
present you a project that I've been

00:04:49,690 --> 00:04:55,810
working on that it's called the

00:04:52,389 --> 00:04:57,220
component based API and before anything

00:04:55,810 --> 00:04:59,020
I need to say it's a work in progress

00:04:57,220 --> 00:05:01,510
and it will be released in a few months

00:04:59,020 --> 00:05:03,789
so I'm kind of sorry about this I wanted

00:05:01,510 --> 00:05:05,740
to finish it for J's conf

00:05:03,789 --> 00:05:09,070
be here saying okay we're releasing it

00:05:05,740 --> 00:05:10,930
today and you know I mean a planning

00:05:09,070 --> 00:05:12,699
time management of time is one of the

00:05:10,930 --> 00:05:15,580
most complex things in software

00:05:12,699 --> 00:05:16,930
development so it hasn't happened it has

00:05:15,580 --> 00:05:20,770
been like two months away from being

00:05:16,930 --> 00:05:24,400
ready for like six months now and still

00:05:20,770 --> 00:05:27,699
a few months away so yeah I'm sorry

00:05:24,400 --> 00:05:29,530
about this but everything that I'm going

00:05:27,699 --> 00:05:31,210
to show you now is working all the

00:05:29,530 --> 00:05:32,470
fundamental having implemented and I

00:05:31,210 --> 00:05:35,919
also have it running on a couple of

00:05:32,470 --> 00:05:38,080
production sites so whatever you will

00:05:35,919 --> 00:05:39,490
actually see here is pretty much there

00:05:38,080 --> 00:05:41,229
okay I'm not talking I'm not bluffing

00:05:39,490 --> 00:05:45,190
everything I will show is actually

00:05:41,229 --> 00:05:48,039
working I will try to do this following

00:05:45,190 --> 00:05:50,380
the example by graphical of having an

00:05:48,039 --> 00:05:51,639
open specification so then you can

00:05:50,380 --> 00:05:53,470
implement it for different technologies

00:05:51,639 --> 00:05:54,930
and how different systems interact with

00:05:53,470 --> 00:05:57,190
each other independently of their

00:05:54,930 --> 00:06:00,639
underlying implementation that's pretty

00:05:57,190 --> 00:06:02,380
cool what it is and finally it's a

00:06:00,639 --> 00:06:05,289
recognition that not everything is bad

00:06:02,380 --> 00:06:07,000
about rest so graph QL is actually

00:06:05,289 --> 00:06:09,280
taking over from rest not because rest

00:06:07,000 --> 00:06:12,330
is pal both have advantages and

00:06:09,280 --> 00:06:14,380
disadvantages and actually they may even

00:06:12,330 --> 00:06:16,720
complement each other in the sense that

00:06:14,380 --> 00:06:20,050
res has advantages that graphical does

00:06:16,720 --> 00:06:22,000
not have and the other way around so I

00:06:20,050 --> 00:06:23,650
was actually thinking this is actually

00:06:22,000 --> 00:06:25,570
pretty cool from retina to discard that

00:06:23,650 --> 00:06:28,030
and were actually try to do is to get

00:06:25,570 --> 00:06:31,270
the best from both approaches which is

00:06:28,030 --> 00:06:34,750
what I'm going to show you now so mostly

00:06:31,270 --> 00:06:36,400
concerning fetching data basically the

00:06:34,750 --> 00:06:38,110
good thing about graph QL is that it

00:06:36,400 --> 00:06:39,820
allows you to fetch the data that you

00:06:38,110 --> 00:06:41,860
need exactly that and that was the big

00:06:39,820 --> 00:06:44,110
problem with rest so I actually took

00:06:41,860 --> 00:06:45,250
this it allows you to fetch exactly the

00:06:44,110 --> 00:06:50,110
data that you need like Rafkin

00:06:45,250 --> 00:06:52,120
but it has an interface like rest so if

00:06:50,110 --> 00:06:53,980
in graph curl you have a Korean of this

00:06:52,120 --> 00:06:57,430
type you have a feature detector with a

00:06:53,980 --> 00:07:00,430
few properties then film with a few

00:06:57,430 --> 00:07:02,350
properties and then an actor the way

00:07:00,430 --> 00:07:04,480
that I translate this through the URL is

00:07:02,350 --> 00:07:08,340
first I get the properties for the

00:07:04,480 --> 00:07:12,100
director and I pass it through a field

00:07:08,340 --> 00:07:14,950
parameter on the uran then I get the

00:07:12,100 --> 00:07:16,690
property for the film and I also passes

00:07:14,950 --> 00:07:19,240
through the fields parameter in a kind

00:07:16,690 --> 00:07:21,580
of dot notation so it now films to

00:07:19,240 --> 00:07:23,290
tighten and then a pipe thumbnail to say

00:07:21,580 --> 00:07:25,960
this property or that probably watch a

00:07:23,290 --> 00:07:27,970
deeper the and that property and finally

00:07:25,960 --> 00:07:31,570
once again for the actors starting from

00:07:27,970 --> 00:07:34,930
the root films dot actors dot name pipe

00:07:31,570 --> 00:07:37,540
avatar so having these syntax I can

00:07:34,930 --> 00:07:40,450
actually query the the service from the

00:07:37,540 --> 00:07:43,090
URL so we have solved the catch ability

00:07:40,450 --> 00:07:45,670
issue because now my URL is my

00:07:43,090 --> 00:07:47,320
identifier and I can actually cache this

00:07:45,670 --> 00:07:49,600
in the backend so that's the first thing

00:07:47,320 --> 00:07:52,450
that is actually solved a combination

00:07:49,600 --> 00:07:54,670
from rest and graphical now concerning

00:07:52,450 --> 00:07:58,780
the shape of the data that were actually

00:07:54,670 --> 00:08:01,360
fetching so in graph QL what you have is

00:07:58,780 --> 00:08:04,780
that the shape of the data mirrors one

00:08:01,360 --> 00:08:06,160
to one their query right you say give me

00:08:04,780 --> 00:08:08,560
future director and then the future

00:08:06,160 --> 00:08:10,930
director has the film and if you has a

00:08:08,560 --> 00:08:13,150
doctor and you're actually returning

00:08:10,930 --> 00:08:16,300
exactly that same shape but I decide to

00:08:13,150 --> 00:08:19,240
use the structure as the data has been

00:08:16,300 --> 00:08:21,220
defined on the database assuming there

00:08:19,240 --> 00:08:23,290
is an SQL database maybe this doesn't

00:08:21,220 --> 00:08:25,090
make much sense within no SQL database

00:08:23,290 --> 00:08:27,010
but you have an SQL database that you

00:08:25,090 --> 00:08:29,200
have like tables and you're thinking of

00:08:27,010 --> 00:08:30,910
rows and columns okay and then you have

00:08:29,200 --> 00:08:31,540
relationships among the entities that

00:08:30,910 --> 00:08:33,340
you have an ID

00:08:31,540 --> 00:08:37,229
pointing to an object on another table

00:08:33,340 --> 00:08:40,330
so that was my model on which I actually

00:08:37,229 --> 00:08:41,830
implemented this so once again this is

00:08:40,330 --> 00:08:44,200
graph QL this is how you get the

00:08:41,830 --> 00:08:49,590
response and what we have in this other

00:08:44,200 --> 00:08:52,500
paradigm is databases and then you

00:08:49,590 --> 00:08:54,600
this you can call it the table sort of I

00:08:52,500 --> 00:08:56,850
call it people with the idea of the

00:08:54,600 --> 00:08:59,940
entity okay now he has the name the

00:08:56,850 --> 00:09:02,700
country avatar and themes and the film's

00:08:59,940 --> 00:09:05,510
is of being nested to get the entity of

00:09:02,700 --> 00:09:09,420
the film it has a reference to the ID

00:09:05,510 --> 00:09:12,420
entity so then we go to the film's down

00:09:09,420 --> 00:09:14,640
here here we have the entity with that

00:09:12,420 --> 00:09:16,290
idea so this one has its own property

00:09:14,640 --> 00:09:19,170
style thumbnail and then he has the

00:09:16,290 --> 00:09:23,070
property actors which is an ID pointing

00:09:19,170 --> 00:09:25,680
to the actor entity back again on people

00:09:23,070 --> 00:09:28,920
so it's you know as you can see this is

00:09:25,680 --> 00:09:30,210
actually replicating sort of the

00:09:28,920 --> 00:09:33,150
structure of the database are you have

00:09:30,210 --> 00:09:36,420
it on the back end like like bringing it

00:09:33,150 --> 00:09:40,310
to the front end these solves the denial

00:09:36,420 --> 00:09:42,779
of service attacks now why is that I

00:09:40,310 --> 00:09:44,550
will actually have a different quality

00:09:42,779 --> 00:09:45,720
to explain better this is a tiny bit

00:09:44,550 --> 00:09:47,460
exaggerated I don't think I would

00:09:45,720 --> 00:09:48,779
actually have a body like this but it

00:09:47,460 --> 00:09:50,279
makes the point imagine that you have

00:09:48,779 --> 00:09:52,529
this query that you're querying for

00:09:50,279 --> 00:09:54,870
posts and all the post you bring the

00:09:52,529 --> 00:09:56,130
tile and the author then the author you

00:09:54,870 --> 00:09:57,390
have the name and followers the

00:09:56,130 --> 00:09:59,010
followers have the name and the

00:09:57,390 --> 00:10:02,520
recommended post which has a tile author

00:09:59,010 --> 00:10:03,660
whatever okay so if you actually pay

00:10:02,520 --> 00:10:06,930
attention to this you are given

00:10:03,660 --> 00:10:11,430
different names to the same two entities

00:10:06,930 --> 00:10:12,870
which are the post and the users okay so

00:10:11,430 --> 00:10:14,910
if you actually think about this in

00:10:12,870 --> 00:10:16,380
terms of graph QL you have a nested

00:10:14,910 --> 00:10:18,630
relationship upon all of the entities

00:10:16,380 --> 00:10:20,190
and you have a query executes after

00:10:18,630 --> 00:10:22,260
query executes in after a query executes

00:10:20,190 --> 00:10:25,890
after acquiring right so everything is

00:10:22,260 --> 00:10:28,530
is compound and I've read in a paper

00:10:25,890 --> 00:10:30,150
that the complexity of this I don't know

00:10:28,530 --> 00:10:32,310
if it is right or not because I hadn't

00:10:30,150 --> 00:10:34,650
seen any validation of the paper I can

00:10:32,310 --> 00:10:37,350
share the URL with you but he says that

00:10:34,650 --> 00:10:40,470
the complexity is exponential to fetch

00:10:37,350 --> 00:10:43,680
data and it's polynomial to find out the

00:10:40,470 --> 00:10:46,010
complexity of the query so that if it

00:10:43,680 --> 00:10:48,779
goes over the threshold of your security

00:10:46,010 --> 00:10:51,510
limitations you cannot execute it but at

00:10:48,779 --> 00:10:53,580
least it takes polynomial time but if

00:10:51,510 --> 00:10:56,400
you think about this structure in terms

00:10:53,580 --> 00:10:58,560
of database that you have in there like

00:10:56,400 --> 00:11:00,480
SQL database this is simply two tables

00:10:58,560 --> 00:11:02,370
like post and users with relationships

00:11:00,480 --> 00:11:03,089
among them and you have actually made it

00:11:02,370 --> 00:11:05,819
flat

00:11:03,089 --> 00:11:07,259
No and because it's flood and I know

00:11:05,819 --> 00:11:09,989
that the entity that I will have is the

00:11:07,259 --> 00:11:11,969
sender I already have loaded in advance

00:11:09,989 --> 00:11:14,249
I just get the aquarium sorry I get the

00:11:11,969 --> 00:11:16,439
IDS from the forth or executions and

00:11:14,249 --> 00:11:20,789
then I compile everything together the

00:11:16,439 --> 00:11:23,029
time complexity is linear so because

00:11:20,789 --> 00:11:27,719
it's linear you can actually have 200

00:11:23,029 --> 00:11:30,509
nested the relationship among entity can

00:11:27,719 --> 00:11:32,909
be like 200 levels down okay

00:11:30,509 --> 00:11:34,019
and this still be performs well I don't

00:11:32,909 --> 00:11:35,399
know if that's a game with graph QL I

00:11:34,019 --> 00:11:39,179
don't think that you'll have a use case

00:11:35,399 --> 00:11:41,429
to have like 200 levels deep down but if

00:11:39,179 --> 00:11:44,839
you ever had to this performs better

00:11:41,429 --> 00:11:44,839
because it's flat

00:11:44,899 --> 00:11:49,829
so let's I'll show you a tiny bit more

00:11:47,879 --> 00:11:51,869
about the API response whether we

00:11:49,829 --> 00:11:54,449
actually get so the idea is that you

00:11:51,869 --> 00:11:55,889
have the data it comes back how do you

00:11:54,449 --> 00:11:57,869
use the data right I mean how do I know

00:11:55,889 --> 00:12:00,389
which is the data that I need to show in

00:11:57,869 --> 00:12:02,069
my component so we say that we have

00:12:00,389 --> 00:12:04,379
another component called feature

00:12:02,069 --> 00:12:07,709
director getting its fields name country

00:12:04,379 --> 00:12:10,949
now water then you have an inner

00:12:07,709 --> 00:12:12,959
component the film and then you have

00:12:10,949 --> 00:12:16,139
another another component the actor

00:12:12,959 --> 00:12:19,379
right so the way that I actually solved

00:12:16,139 --> 00:12:24,419
that problem is that you have the idea

00:12:19,379 --> 00:12:27,329
of the of the entity that is querying

00:12:24,419 --> 00:12:28,649
for the data in this case the the one

00:12:27,329 --> 00:12:30,359
who's calling for the data is a feature

00:12:28,649 --> 00:12:32,609
director is saying I need the feature

00:12:30,359 --> 00:12:34,919
director okay and then the subcomponents

00:12:32,609 --> 00:12:38,669
will be asking for properties from this

00:12:34,919 --> 00:12:41,479
rich field entity so this guy he says

00:12:38,669 --> 00:12:46,319
here the future director the result is

00:12:41,479 --> 00:12:49,589
entity with ID 1 ok from which database

00:12:46,319 --> 00:12:53,099
or which database tell it appears under

00:12:49,589 --> 00:12:56,669
the key ID which is people so when you

00:12:53,099 --> 00:13:00,689
go to people here it says people entity

00:12:56,669 --> 00:13:03,289
with ID 1 name country avatar and then

00:13:00,689 --> 00:13:07,079
films and then he gives me the ID of the

00:13:03,289 --> 00:13:09,899
films from this guy so and it is 1 and 2

00:13:07,079 --> 00:13:11,830
where do I retrieve this data from here

00:13:09,899 --> 00:13:14,589
it says from the

00:13:11,830 --> 00:13:17,380
key under films which is called films

00:13:14,589 --> 00:13:19,990
also so now we come to films and he

00:13:17,380 --> 00:13:22,060
gives me the entity okay Tyler thumbnail

00:13:19,990 --> 00:13:24,610
actors and I trust he gives me the

00:13:22,060 --> 00:13:27,490
actors with IDs two and three once again

00:13:24,610 --> 00:13:29,500
what do I get them from from films dot

00:13:27,490 --> 00:13:33,399
actors and he says you have to get these

00:13:29,500 --> 00:13:36,640
from the database or table called people

00:13:33,399 --> 00:13:38,709
okay so now in people two and three we

00:13:36,640 --> 00:13:40,209
have these entities and you can see that

00:13:38,709 --> 00:13:42,519
the data that are actually retrieved

00:13:40,209 --> 00:13:46,240
from from each is exactly what they need

00:13:42,519 --> 00:13:47,589
so this number one is George Lucas is

00:13:46,240 --> 00:13:50,950
the director I need to display the

00:13:47,589 --> 00:13:53,920
avatar from him and the country okay a

00:13:50,950 --> 00:13:56,560
one McGregor he's only an actor so I'm

00:13:53,920 --> 00:13:57,940
not sure in the the country from him and

00:13:56,560 --> 00:13:59,740
not even display this

00:13:57,940 --> 00:14:03,220
okay so doesn't bring it is pretty much

00:13:59,740 --> 00:14:06,279
like graph QL but the data is arranged

00:14:03,220 --> 00:14:07,450
on a different structure what is the

00:14:06,279 --> 00:14:10,000
cool thing about this one thing that

00:14:07,450 --> 00:14:11,760
they take normalized so you can see on

00:14:10,000 --> 00:14:14,800
the example we have the same actor twice

00:14:11,760 --> 00:14:16,420
Natalie Portman so in graphic where you

00:14:14,800 --> 00:14:20,230
actually bring this data twice here you

00:14:16,420 --> 00:14:22,149
bring it only once then they they say

00:14:20,230 --> 00:14:23,980
unique database containing all the dates

00:14:22,149 --> 00:14:25,570
and the client so you can actually merge

00:14:23,980 --> 00:14:29,050
all of these because now it's flat you

00:14:25,570 --> 00:14:31,149
know how like next levels with renaming

00:14:29,050 --> 00:14:33,579
of the same entity now you know I posted

00:14:31,149 --> 00:14:35,200
suppose the user is a user it's flat you

00:14:33,579 --> 00:14:37,300
can actually merge it when you bring it

00:14:35,200 --> 00:14:39,010
from the from your cultural API you

00:14:37,300 --> 00:14:40,750
merge it on the client and you have a

00:14:39,010 --> 00:14:42,670
cache so if you know that you will need

00:14:40,750 --> 00:14:44,260
to fetch this data later on and you

00:14:42,670 --> 00:14:45,579
already have retrieved it you have it

00:14:44,260 --> 00:14:47,260
there you don't even need to make that

00:14:45,579 --> 00:14:51,420
that call so this is awesome for

00:14:47,260 --> 00:14:53,920
performance because the most performing

00:14:51,420 --> 00:14:56,709
application is the one that does not

00:14:53,920 --> 00:14:58,630
need to make that HTTP call if it is

00:14:56,709 --> 00:15:01,600
redundant don't make it and this makes

00:14:58,630 --> 00:15:04,060
it possible and finally another cool

00:15:01,600 --> 00:15:05,290
property is that because the dates

00:15:04,060 --> 00:15:07,839
already share among all of the

00:15:05,290 --> 00:15:11,740
components if one component is fetching

00:15:07,839 --> 00:15:13,870
data okay and this data has been updated

00:15:11,740 --> 00:15:15,790
in the time in between and another

00:15:13,870 --> 00:15:18,610
component also was using the same data

00:15:15,790 --> 00:15:21,160
then both components can be render

00:15:18,610 --> 00:15:23,589
Europe you can observe on the database

00:15:21,160 --> 00:15:24,030
basically so it's a building content

00:15:23,589 --> 00:15:25,470
object

00:15:24,030 --> 00:15:28,380
on the fly and then observe this object

00:15:25,470 --> 00:15:30,570
you can actually have an idea of being

00:15:28,380 --> 00:15:33,540
overly observing the database and the

00:15:30,570 --> 00:15:35,190
layout can be can react to the data

00:15:33,540 --> 00:15:38,430
inside the database this is not

00:15:35,190 --> 00:15:40,650
implemented by the way but the

00:15:38,430 --> 00:15:41,970
architecture supports this and that's

00:15:40,650 --> 00:15:44,460
hopefully one of the upcoming things are

00:15:41,970 --> 00:15:46,020
will implement soon so concerning the

00:15:44,460 --> 00:15:47,850
API response I don't have enough time so

00:15:46,020 --> 00:15:49,050
I cannot show it to you but if you are

00:15:47,850 --> 00:15:50,970
going to check out the presentation

00:15:49,050 --> 00:15:53,010
later on you can click on these two

00:15:50,970 --> 00:15:54,300
links and this is deployed on a

00:15:53,010 --> 00:15:56,960
production server so you can actually

00:15:54,300 --> 00:15:59,100
see it working already so having this

00:15:56,960 --> 00:16:01,380
everything that comes that I would

00:15:59,100 --> 00:16:06,230
actually explain in the next slides is

00:16:01,380 --> 00:16:08,790
working so let's see how this works so

00:16:06,230 --> 00:16:11,220
the important thing here and I'm sorry

00:16:08,790 --> 00:16:13,440
about this is that the components are

00:16:11,220 --> 00:16:15,990
implemented partly in the front end and

00:16:13,440 --> 00:16:19,950
partly in the back end so I know that

00:16:15,990 --> 00:16:23,970
you're not that you don't trust back-end

00:16:19,950 --> 00:16:26,760
developers yeah this is something that

00:16:23,970 --> 00:16:28,230
believe me makes sense and I will try to

00:16:26,760 --> 00:16:32,700
convince you so that maybe you can have

00:16:28,230 --> 00:16:35,190
a tiny bit more of steam for us but the

00:16:32,700 --> 00:16:37,680
thing about these is that is it not back

00:16:35,190 --> 00:16:40,020
end or front end the component actually

00:16:37,680 --> 00:16:42,450
lives pretty in the back end and the

00:16:40,020 --> 00:16:44,220
front end and implements part of your

00:16:42,450 --> 00:16:46,830
responsibilities where it makes most

00:16:44,220 --> 00:16:47,400
sense so what am I talking about here is

00:16:46,830 --> 00:16:50,850
a following

00:16:47,400 --> 00:16:53,330
I have delineated four layers okay that

00:16:50,850 --> 00:16:57,660
make it up as a progressively enhanced

00:16:53,330 --> 00:16:59,130
service from API to application on the

00:16:57,660 --> 00:17:02,220
very first layer you have the data layer

00:16:59,130 --> 00:17:05,220
okay so this is basically your API you

00:17:02,220 --> 00:17:06,600
define what data the component needs and

00:17:05,220 --> 00:17:08,790
having that alone you really have the

00:17:06,600 --> 00:17:11,550
API you can actually stop it there okay

00:17:08,790 --> 00:17:13,410
but you can also continue you can on top

00:17:11,550 --> 00:17:15,930
of the data layer you can add a

00:17:13,410 --> 00:17:18,000
configuration layer okay on the backend

00:17:15,930 --> 00:17:19,560
so I'm talking about defining classes

00:17:18,000 --> 00:17:21,270
and styles and the strings that you need

00:17:19,560 --> 00:17:24,060
to display in your view that you

00:17:21,270 --> 00:17:26,970
actually set it up on the backend then

00:17:24,060 --> 00:17:28,500
we got referent in the view layer is in

00:17:26,970 --> 00:17:30,620
the fronton and of course reactivity

00:17:28,500 --> 00:17:33,000
also will happen on on the front end so

00:17:30,620 --> 00:17:35,790
what basically I'm saying with all of

00:17:33,000 --> 00:17:37,620
this is that the application your own

00:17:35,790 --> 00:17:40,740
application that you have for your own

00:17:37,620 --> 00:17:42,990
it can be model as an extension of your

00:17:40,740 --> 00:17:44,940
API so you have to provide an API for

00:17:42,990 --> 00:17:46,890
your clients to retrieve your data well

00:17:44,940 --> 00:17:50,460
your application can actually continue

00:17:46,890 --> 00:17:53,390
from there and and yeah and demonstrate

00:17:50,460 --> 00:17:56,190
the API the application becomes the API

00:17:53,390 --> 00:17:57,450
the other thing is that the examples

00:17:56,190 --> 00:17:59,779
that I showed you about querying

00:17:57,450 --> 00:18:01,890
specific fields to the URL which is the

00:17:59,779 --> 00:18:04,799
basically the graph QL like

00:18:01,890 --> 00:18:07,020
functionality is simply a specific use

00:18:04,799 --> 00:18:09,899
case of this architecture because what I

00:18:07,020 --> 00:18:13,380
do is to basically on runtime create the

00:18:09,899 --> 00:18:15,270
hierarchy of components that I need to

00:18:13,380 --> 00:18:17,190
match those fields and I and I give it

00:18:15,270 --> 00:18:18,840
back to you so that's just one use case

00:18:17,190 --> 00:18:20,669
and what you can do with this is

00:18:18,840 --> 00:18:23,789
actually much more so I found out

00:18:20,669 --> 00:18:26,070
actually pretty pretty cool how does

00:18:23,789 --> 00:18:28,980
this work so on the back end we have a

00:18:26,070 --> 00:18:30,659
component hierarchy which is how a

00:18:28,980 --> 00:18:33,390
component relates to each other like I

00:18:30,659 --> 00:18:34,610
own like I'm dropping this component and

00:18:33,390 --> 00:18:38,250
that component wrapping that component

00:18:34,610 --> 00:18:40,200
you have props you have data fields and

00:18:38,250 --> 00:18:43,350
you have the configuration so I have

00:18:40,200 --> 00:18:45,929
coded this in PHP this PHP code so you

00:18:43,350 --> 00:18:47,730
have functions get some modules which

00:18:45,929 --> 00:18:49,230
first define the hierarchy or how

00:18:47,730 --> 00:18:51,870
companies read to each other then you

00:18:49,230 --> 00:18:53,940
have init props and init props is very

00:18:51,870 --> 00:18:57,649
interesting I mean it receives a module

00:18:53,940 --> 00:19:00,659
and the object props to initialize a

00:18:57,649 --> 00:19:03,240
component can set properties for itself

00:19:00,659 --> 00:19:05,340
of course and also for his children

00:19:03,240 --> 00:19:07,919
component like all the way down right

00:19:05,340 --> 00:19:11,190
and every ancestor has higher priority

00:19:07,919 --> 00:19:13,440
over its children so the top most

00:19:11,190 --> 00:19:15,510
component at every job conferring the

00:19:13,440 --> 00:19:18,390
properties overriding all the properties

00:19:15,510 --> 00:19:19,470
from its children ok that's one thing

00:19:18,390 --> 00:19:21,539
but second thing that this is on the

00:19:19,470 --> 00:19:24,299
back end so it's a very easy to set

00:19:21,539 --> 00:19:26,250
properties horizontally not just

00:19:24,299 --> 00:19:29,010
vertically so you can actually in just

00:19:26,250 --> 00:19:31,200
one line of code say all these many

00:19:29,010 --> 00:19:33,029
components inject this property and it

00:19:31,200 --> 00:19:34,590
just works and you don't need to deploy

00:19:33,029 --> 00:19:37,799
any JavaScript file you know when you

00:19:34,590 --> 00:19:41,460
change one string you know like I mean

00:19:37,799 --> 00:19:43,590
one description or one class name ok it

00:19:41,460 --> 00:19:45,029
you you touching it on the bakken and

00:19:43,590 --> 00:19:46,640
it's already live no need to deploy

00:19:45,029 --> 00:19:49,080
anything only for web pack or anything

00:19:46,640 --> 00:19:50,370
then you have the data fields I will

00:19:49,080 --> 00:19:54,230
explain this tiny bit later

00:19:50,370 --> 00:19:56,309
and the configuration and this is the

00:19:54,230 --> 00:19:58,620
how it looks on the view have

00:19:56,309 --> 00:20:00,930
implemented he would handlebars so this

00:19:58,620 --> 00:20:03,360
is an example of a drop-down and you can

00:20:00,930 --> 00:20:06,540
see basically a deal then they say

00:20:03,360 --> 00:20:08,820
button then they say a ul and it

00:20:06,540 --> 00:20:11,400
iterates all of its sub modules and for

00:20:08,820 --> 00:20:13,050
each of them like it prints on LI and it

00:20:11,400 --> 00:20:15,840
says each of the sub modules

00:20:13,050 --> 00:20:18,840
render yourself so what's so cool about

00:20:15,840 --> 00:20:21,210
this is that the component the view in

00:20:18,840 --> 00:20:23,550
this case is completely decoupled from

00:20:21,210 --> 00:20:25,020
its children this drop-down doesn't know

00:20:23,550 --> 00:20:27,570
whose children is going to be you

00:20:25,020 --> 00:20:30,090
actually settle that on the on the on

00:20:27,570 --> 00:20:31,830
the back end through configuration so

00:20:30,090 --> 00:20:33,870
then you are really playing like Lego

00:20:31,830 --> 00:20:35,250
like this is on steroids because you

00:20:33,870 --> 00:20:37,620
have any one implementation of the of

00:20:35,250 --> 00:20:39,780
the view that you can actually add

00:20:37,620 --> 00:20:42,660
inject everywhere yesterday when we had

00:20:39,780 --> 00:20:45,929
the talk by issue and she was mentioning

00:20:42,660 --> 00:20:47,670
about this approp collapsing right this

00:20:45,929 --> 00:20:50,520
complexity of props because you don't

00:20:47,670 --> 00:20:51,510
want to separate the component into

00:20:50,520 --> 00:20:53,400
another component because the

00:20:51,510 --> 00:20:56,370
functionality is kind of the same and

00:20:53,400 --> 00:20:58,350
you don't want to duplicate : right you

00:20:56,370 --> 00:21:00,660
want to stick to dry and then you end up

00:20:58,350 --> 00:21:02,490
having a monster and you're saying it's

00:21:00,660 --> 00:21:05,250
okay you can repeat call it makes sense

00:21:02,490 --> 00:21:07,020
okay with this architecture they no need

00:21:05,250 --> 00:21:09,080
for that because this is how the

00:21:07,020 --> 00:21:11,850
component looks like in the front end

00:21:09,080 --> 00:21:14,309
okay it's extremely decoupled from all

00:21:11,850 --> 00:21:19,290
of its children so then they know a prop

00:21:14,309 --> 00:21:22,260
Clips it just cannot happen so every

00:21:19,290 --> 00:21:24,840
component creates its context on the

00:21:22,260 --> 00:21:27,450
back end and it receives its context on

00:21:24,840 --> 00:21:29,280
the front end and only its context conde

00:21:27,450 --> 00:21:32,660
on the view you just don't care about

00:21:29,280 --> 00:21:34,740
having to iterate the data you carried

00:21:32,660 --> 00:21:36,690
the view doesn't know or doesn't care

00:21:34,740 --> 00:21:41,550
about its subcomponents and props can be

00:21:36,690 --> 00:21:43,800
set vertically and horizontally so this

00:21:41,550 --> 00:21:45,330
is the component architecture let's say

00:21:43,800 --> 00:21:48,750
that we actually have a page in this

00:21:45,330 --> 00:21:50,730
case / po / lovely tango at the very top

00:21:48,750 --> 00:21:54,320
of the other page my component is called

00:21:50,730 --> 00:21:57,330
post and it will contain some other

00:21:54,320 --> 00:21:59,850
components right so in this case I have

00:21:57,330 --> 00:22:01,920
a sub component called post l1 called

00:21:59,850 --> 00:22:03,860
post thumbnail and one called post

00:22:01,920 --> 00:22:05,929
content so this is

00:22:03,860 --> 00:22:07,580
the way to represent is very simple okay

00:22:05,929 --> 00:22:09,380
just like that this is an

00:22:07,580 --> 00:22:11,090
oversimplification I mean you can see

00:22:09,380 --> 00:22:12,710
that like a big widget there and the

00:22:11,090 --> 00:22:14,750
widget contains other components in the

00:22:12,710 --> 00:22:16,670
component contains other components this

00:22:14,750 --> 00:22:18,830
is just to simply to simplify okay it

00:22:16,670 --> 00:22:20,450
makes the case and the way that it works

00:22:18,830 --> 00:22:21,590
on the backend is that you define the

00:22:20,450 --> 00:22:25,100
relationships among all of these

00:22:21,590 --> 00:22:26,960
components with that function for

00:22:25,100 --> 00:22:28,640
retrieving data each component must

00:22:26,960 --> 00:22:32,059
define what data fits in is from the

00:22:28,640 --> 00:22:33,679
database just for itself without

00:22:32,059 --> 00:22:35,270
including the data fields for its sub

00:22:33,679 --> 00:22:37,400
components so you can think of these

00:22:35,270 --> 00:22:39,890
like fragments in graph QL but on

00:22:37,400 --> 00:22:42,679
steroids because once again each level

00:22:39,890 --> 00:22:45,049
of the component defines this is my data

00:22:42,679 --> 00:22:46,549
that I need not my cell components

00:22:45,049 --> 00:22:48,410
somewhere QL right now you have the

00:22:46,549 --> 00:22:50,990
possibility of a component getting the

00:22:48,410 --> 00:22:53,299
data also for its sub components okay

00:22:50,990 --> 00:22:55,190
but in this case each component at each

00:22:53,299 --> 00:22:57,500
layer says this is the data Deranian at

00:22:55,190 --> 00:22:59,360
every single level and the cool thing

00:22:57,500 --> 00:23:01,940
about this is a by having this

00:22:59,360 --> 00:23:04,220
architecture the endpoint URL from which

00:23:01,940 --> 00:23:06,320
to fetch the data and also the query to

00:23:04,220 --> 00:23:07,790
execute against the database can be

00:23:06,320 --> 00:23:10,250
automatically generated from the

00:23:07,790 --> 00:23:12,710
component hierarchy itself so what does

00:23:10,250 --> 00:23:16,760
this mean so we have this component

00:23:12,710 --> 00:23:19,460
architecture right so the originally the

00:23:16,760 --> 00:23:22,010
topmost component says I need to fetch

00:23:19,460 --> 00:23:24,500
data from this post okay the one

00:23:22,010 --> 00:23:27,200
corresponding to the URL and for that

00:23:24,500 --> 00:23:29,059
moment on all the components inside of

00:23:27,200 --> 00:23:32,299
this guy whenever they fetch a property

00:23:29,059 --> 00:23:34,010
it will be referencing this entity in

00:23:32,299 --> 00:23:35,960
this post so post title will actually

00:23:34,010 --> 00:23:37,400
load property title the post terminal

00:23:35,960 --> 00:23:39,260
will load property thumbnail and post

00:23:37,400 --> 00:23:42,679
constant will actually load property

00:23:39,260 --> 00:23:44,870
content so iterating from the topmost

00:23:42,679 --> 00:23:46,760
component all the way down you get the

00:23:44,870 --> 00:23:49,610
property from each and you can construct

00:23:46,760 --> 00:23:51,230
the URL so now this endpoint URL okay

00:23:49,610 --> 00:23:53,480
that I was showing you how you can fetch

00:23:51,230 --> 00:23:55,790
the data and you need it like graph QL

00:23:53,480 --> 00:23:58,160
like sorts I don't even need to call it

00:23:55,790 --> 00:24:00,290
anymore because it's automatically

00:23:58,160 --> 00:24:02,900
generated from the structure of the

00:24:00,290 --> 00:24:04,220
components itself and that's amazing if

00:24:02,900 --> 00:24:07,910
you actually change one component that

00:24:04,220 --> 00:24:11,179
you have another component is it already

00:24:07,910 --> 00:24:14,179
works but not only that because now this

00:24:11,179 --> 00:24:15,470
is on living on the backend I have the

00:24:14,179 --> 00:24:17,390
possibility to also create the query

00:24:15,470 --> 00:24:19,850
okay so you can also say

00:24:17,390 --> 00:24:21,620
so execute the data Amelie on the server

00:24:19,850 --> 00:24:23,179
and retrieve and return the date I

00:24:21,620 --> 00:24:26,809
merely no need to actually have that

00:24:23,179 --> 00:24:28,070
round-trip to give to load the client

00:24:26,809 --> 00:24:29,179
and then the client needs to fetch the

00:24:28,070 --> 00:24:30,740
data from the server and then the server

00:24:29,179 --> 00:24:32,830
returns the date and then you render

00:24:30,740 --> 00:24:35,420
that you can just return the data

00:24:32,830 --> 00:24:37,160
directly that's an option understand

00:24:35,420 --> 00:24:38,740
that you had to do this but now you had

00:24:37,160 --> 00:24:42,230
the possibility you can actually choose

00:24:38,740 --> 00:24:45,170
so if you actually want to have like

00:24:42,230 --> 00:24:47,360
relationships among entities this also

00:24:45,170 --> 00:24:50,360
works when we're actually loading this

00:24:47,360 --> 00:24:52,520
post author component he will actually

00:24:50,360 --> 00:24:54,980
change the entity from the post to the

00:24:52,520 --> 00:24:56,780
post offer okay and from that moment on

00:24:54,980 --> 00:24:58,640
all the sub components from this guy

00:24:56,780 --> 00:25:01,490
will be loading properties on this

00:24:58,640 --> 00:25:04,130
entity on the user or author in this

00:25:01,490 --> 00:25:07,220
case the user name lost property name

00:25:04,130 --> 00:25:10,160
and the user loads property avatar once

00:25:07,220 --> 00:25:14,030
again the endpoint URL and the database

00:25:10,160 --> 00:25:15,200
query are automatically generated how

00:25:14,030 --> 00:25:18,320
does it look on the back and on the

00:25:15,200 --> 00:25:22,580
front end so we had a view for the outer

00:25:18,320 --> 00:25:25,250
most component which is basically a

00:25:22,580 --> 00:25:28,160
simple field line saying okay now inject

00:25:25,250 --> 00:25:31,130
this entity into the context and then

00:25:28,160 --> 00:25:33,410
iterate over all my sub modules or sub

00:25:31,130 --> 00:25:35,660
components and for each of them render

00:25:33,410 --> 00:25:40,460
yourself using this entity on your

00:25:35,660 --> 00:25:41,780
context okay so when this sub component

00:25:40,460 --> 00:25:45,049
the receive the data in this case the

00:25:41,780 --> 00:25:46,549
tile it just prints itself okay you have

00:25:45,049 --> 00:25:48,770
the objector having loaded on its

00:25:46,549 --> 00:25:51,380
context and he says I want to show my

00:25:48,770 --> 00:25:52,070
property tile that you have expesive ID

00:25:51,380 --> 00:25:54,169
on the backend

00:25:52,070 --> 00:25:56,000
okay property tile but now also because

00:25:54,169 --> 00:25:58,040
we can load configuration we can even do

00:25:56,000 --> 00:26:00,230
something like this we can actually say

00:25:58,040 --> 00:26:01,549
okay I want instead of saying h1

00:26:00,230 --> 00:26:04,700
straight on the view you can actually

00:26:01,549 --> 00:26:07,280
say h1 through configuration add a class

00:26:04,700 --> 00:26:10,090
also and you can change this through

00:26:07,280 --> 00:26:17,680
configuration that's pretty powerful

00:26:10,090 --> 00:26:19,960
what is it so

00:26:17,680 --> 00:26:21,850
when he reaches the post author is the

00:26:19,960 --> 00:26:25,000
same so this guy will actually change

00:26:21,850 --> 00:26:27,490
from the current post to the post of

00:26:25,000 --> 00:26:29,920
Thor into the context and tell all of

00:26:27,490 --> 00:26:34,390
its subcomponents render yourself using

00:26:29,920 --> 00:26:35,800
the new entity I had to wrap up so I'm

00:26:34,390 --> 00:26:37,690
going to be pretty quick now with this

00:26:35,800 --> 00:26:39,610
but I want to enumerate all the many

00:26:37,690 --> 00:26:41,620
advantages of this architecture first

00:26:39,610 --> 00:26:43,660
one is isomorphism which is basically

00:26:41,620 --> 00:26:45,580
the capability of running your call on

00:26:43,660 --> 00:26:47,740
the on the server side or on the front

00:26:45,580 --> 00:26:50,500
end you're thinking of JavaScript this

00:26:47,740 --> 00:26:51,820
is another approach so on one side the

00:26:50,500 --> 00:26:55,180
handle bar templates they can be

00:26:51,820 --> 00:26:56,320
compiled to run as PHP they say

00:26:55,180 --> 00:26:58,240
wonderful library called light on

00:26:56,320 --> 00:27:00,760
candidate at that and he runs like like

00:26:58,240 --> 00:27:01,870
native PHP code is very fast awesome and

00:27:00,760 --> 00:27:04,450
on the other side the pitch free

00:27:01,870 --> 00:27:07,060
configuration can be exported as a JSON

00:27:04,450 --> 00:27:11,110
file because basically this component

00:27:07,060 --> 00:27:13,090
hierarchy is a big array of components

00:27:11,110 --> 00:27:14,590
listing all of their properties and then

00:27:13,090 --> 00:27:16,270
saying these are my sub components

00:27:14,590 --> 00:27:18,550
listen they're producing these are minor

00:27:16,270 --> 00:27:20,800
components so listen an array you just

00:27:18,550 --> 00:27:23,230
execute JSON encode on this and you

00:27:20,800 --> 00:27:25,150
obtain a JSON so that means that you

00:27:23,230 --> 00:27:27,280
have on one side the possibility to run

00:27:25,150 --> 00:27:29,500
this on the server and execute

00:27:27,280 --> 00:27:31,990
server-side rendering okay I don't I

00:27:29,500 --> 00:27:33,700
decide you can export these for the

00:27:31,990 --> 00:27:36,340
front-end you have a service application

00:27:33,700 --> 00:27:38,620
it's up to you and the cone is the same

00:27:36,340 --> 00:27:43,420
an ewok it works on both back in and

00:27:38,620 --> 00:27:46,810
from them then you can also target

00:27:43,420 --> 00:27:49,690
specific components so in this case we

00:27:46,810 --> 00:27:52,480
have a post and the post has a component

00:27:49,690 --> 00:27:54,880
called post I'll I can through the URL

00:27:52,480 --> 00:27:57,630
saying I want the data just for this

00:27:54,880 --> 00:28:01,090
component and also for this other

00:27:57,630 --> 00:28:02,800
component okay and what you get is the

00:28:01,090 --> 00:28:05,530
equivalent of getting the data just for

00:28:02,800 --> 00:28:08,500
these two guys and nothing else and that

00:28:05,530 --> 00:28:10,000
I find wonderful because what it means

00:28:08,500 --> 00:28:12,460
is that the component is its own API

00:28:10,000 --> 00:28:15,190
imaginary have a component that is like

00:28:12,460 --> 00:28:16,810
a infinite scroll you reach the bottom

00:28:15,190 --> 00:28:19,120
of the page you need to get more data

00:28:16,810 --> 00:28:23,530
now the component can just talk to

00:28:19,120 --> 00:28:25,810
itself say I need more data so you

00:28:23,530 --> 00:28:28,360
construct the URL the current URL and

00:28:25,810 --> 00:28:30,230
the path to this component starting from

00:28:28,360 --> 00:28:32,210
the top and you will only

00:28:30,230 --> 00:28:34,309
the data for this guy and once again

00:28:32,210 --> 00:28:36,500
because the hierarchy is such that at

00:28:34,309 --> 00:28:39,049
the top you have one component at the

00:28:36,500 --> 00:28:41,090
very top then the website is its own API

00:28:39,049 --> 00:28:43,130
so then you know different between API

00:28:41,090 --> 00:28:47,390
and website anymore this is both an API

00:28:43,130 --> 00:28:48,650
and a website at the same time so you

00:28:47,390 --> 00:28:50,660
can also implement single page

00:28:48,650 --> 00:28:53,630
applications and you can also create

00:28:50,660 --> 00:28:56,120
pattern libraries very easily because

00:28:53,630 --> 00:28:59,299
you render a component and it gives you

00:28:56,120 --> 00:29:02,150
the the visual identity it a component

00:28:59,299 --> 00:29:04,460
also knows which is css3 hostel and it's

00:29:02,150 --> 00:29:05,840
JavaScript files it just that's it you

00:29:04,460 --> 00:29:09,350
don't need to call it somewhere else

00:29:05,840 --> 00:29:11,960
finally you can implement cope which

00:29:09,350 --> 00:29:13,250
means create once publish everywhere so

00:29:11,960 --> 00:29:16,760
you have a single source of truth for

00:29:13,250 --> 00:29:18,890
multiple platforms wave email apps so

00:29:16,760 --> 00:29:21,049
you can actually have a JS component

00:29:18,890 --> 00:29:23,299
that extends HTML CSS component and then

00:29:21,049 --> 00:29:25,190
html's is a component that extends from

00:29:23,299 --> 00:29:27,380
your abstract component so you can

00:29:25,190 --> 00:29:28,700
actually layer the generations of the

00:29:27,380 --> 00:29:30,679
other layout in this case we have a

00:29:28,700 --> 00:29:32,419
website and then you have the email

00:29:30,679 --> 00:29:36,580
every page on the website can be sent by

00:29:32,419 --> 00:29:40,610
email for no extra cost so I'm finishing

00:29:36,580 --> 00:29:42,890
yeah in a nutshell advantages of this

00:29:40,610 --> 00:29:45,350
architecture you have the client-side

00:29:42,890 --> 00:29:47,990
cache is it change the behavior of the

00:29:45,350 --> 00:29:49,730
application is isomorphic they've

00:29:47,990 --> 00:29:51,850
component anniversary's is own API

00:29:49,730 --> 00:29:53,929
implement single page applications

00:29:51,850 --> 00:29:54,770
generated pattern library you can

00:29:53,929 --> 00:29:57,590
implement cope

00:29:54,770 --> 00:29:59,809
so in summary from all of these you have

00:29:57,590 --> 00:30:01,160
a lot of reduced complexity because if

00:29:59,809 --> 00:30:03,049
you want to do all of these other things

00:30:01,160 --> 00:30:04,340
anyway you have to do two three four

00:30:03,049 --> 00:30:06,110
different technologies here with one

00:30:04,340 --> 00:30:07,000
with just one architecture you solve

00:30:06,110 --> 00:30:09,290
everything

00:30:07,000 --> 00:30:14,690
more output in less time with fewer

00:30:09,290 --> 00:30:18,020
resources so finishing finishing so this

00:30:14,690 --> 00:30:21,140
is open source of course MIT license the

00:30:18,020 --> 00:30:25,490
URL is github.com slash lilo so slash

00:30:21,140 --> 00:30:28,730
pop okay so check it out is not ready

00:30:25,490 --> 00:30:30,919
yet okay I'm a few months away from

00:30:28,730 --> 00:30:32,960
finishing okay so if you cannot wait

00:30:30,919 --> 00:30:34,490
come talk to me they know much

00:30:32,960 --> 00:30:36,230
documentation there's some documentation

00:30:34,490 --> 00:30:39,380
so you have to talk to me okay

00:30:36,230 --> 00:30:40,429
but check it out okay and once again if

00:30:39,380 --> 00:30:42,080
you want to check the presentations

00:30:40,429 --> 00:30:43,580
right so come so I shoulda loss of slash

00:30:42,080 --> 00:30:43,910
component by CPR you can click on the

00:30:43,580 --> 00:30:47,350
list

00:30:43,910 --> 00:30:47,350

YouTube URL: https://www.youtube.com/watch?v=9pT-q0SSYow


