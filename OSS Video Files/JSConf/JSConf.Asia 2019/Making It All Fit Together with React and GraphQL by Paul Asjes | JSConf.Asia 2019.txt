Title: Making It All Fit Together with React and GraphQL by Paul Asjes | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	Many tools and processes go into modern front-end development: from component development to design and data fetching to testing and more. How does Stripe make these all work together? Join Paul Asjes from Stripeâ€™s engineering team for a talk on how to make all these components and processes work in a way that makes the modern front-end greater than the sum of its many parts.

Paul is a developer support engineer at Stripe by day and a sleepy one at night. He helps companies get set up with Stripe in a variety of languages, but JavaScript is his favourite. He's written a book on Slack bots and likes to spend time underwater when not running around Singapore eating all the things.

This talk is sponsored by Stripe - https://stripe.com


JSConf.Asia - LASALLE College of the Arts, Singapore - 15 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:00,620 --> 00:00:15,820
[Music]

00:00:15,890 --> 00:00:21,300
my name is Paul I live in Singapore when

00:00:19,470 --> 00:00:22,529
I'm engineer and I work at stripe if

00:00:21,300 --> 00:00:24,539
you're not familiar with stripe stripe

00:00:22,529 --> 00:00:26,550
is a payments infrastructure company and

00:00:24,539 --> 00:00:30,570
today I want to talk to you about how we

00:00:26,550 --> 00:00:32,009
use reacting graph QL so just quick

00:00:30,570 --> 00:00:33,239
current disclaimer like what we're going

00:00:32,009 --> 00:00:35,160
to talk about here this talk isn't

00:00:33,239 --> 00:00:36,719
necessarily about what graph QL is and

00:00:35,160 --> 00:00:39,030
why you should use it it's more about

00:00:36,719 --> 00:00:40,860
how stripe uses graphic UL and why we

00:00:39,030 --> 00:00:42,210
use it why do you think it's great so I

00:00:40,860 --> 00:00:44,340
want to talk a bit more about that graph

00:00:42,210 --> 00:00:46,260
QL and the modern product development

00:00:44,340 --> 00:00:48,750
stack talk about some stuff that we

00:00:46,260 --> 00:00:50,969
built that stripe with graph QL and some

00:00:48,750 --> 00:00:54,510
unexpected cool benefits that we found

00:00:50,969 --> 00:00:56,399
out the first very important Eric I'm

00:00:54,510 --> 00:00:58,469
talking about here was developed by many

00:00:56,399 --> 00:00:59,780
people over many different teams I can't

00:00:58,469 --> 00:01:03,570
take any credit for any of this

00:00:59,780 --> 00:01:04,979
yeah it takes a bit to do this stuff so

00:01:03,570 --> 00:01:06,570
in the screenshot here on the left you

00:01:04,979 --> 00:01:08,310
see just a little small part of the

00:01:06,570 --> 00:01:10,290
stripe dashboard now the stripe

00:01:08,310 --> 00:01:12,600
dashboard is the main tool that we use

00:01:10,290 --> 00:01:14,100
what our users use to find out

00:01:12,600 --> 00:01:16,799
everything about their strife account

00:01:14,100 --> 00:01:18,509
you can look at some logs here you can

00:01:16,799 --> 00:01:20,820
find out about your API keys make

00:01:18,509 --> 00:01:22,350
payments etc it's a really important

00:01:20,820 --> 00:01:24,540
tool and kind of the first thing that I

00:01:22,350 --> 00:01:26,369
use are C and we have a lot of teams

00:01:24,540 --> 00:01:28,140
working on this at the same time so it

00:01:26,369 --> 00:01:33,840
really needs to work had gel together as

00:01:28,140 --> 00:01:38,280
much as possible so here's our stack yes

00:01:33,840 --> 00:01:39,750
we use flow don't at me but whatever we

00:01:38,280 --> 00:01:41,610
want to talk about is the last part here

00:01:39,750 --> 00:01:43,530
which is graph QL and Apollo which is

00:01:41,610 --> 00:01:44,820
kind of new for a stack so there Nardo

00:01:43,530 --> 00:01:47,100
earlier or decay like a really good

00:01:44,820 --> 00:01:48,600
little run-through of graph go I'll make

00:01:47,100 --> 00:01:50,159
this really brief so first of all kind

00:01:48,600 --> 00:01:51,570
of get by a show of hands obviously

00:01:50,159 --> 00:01:55,369
everyone here has now heard of graph QL

00:01:51,570 --> 00:01:58,290
but who is actually use graph QL here

00:01:55,369 --> 00:02:00,210
okay enough people first to not be super

00:01:58,290 --> 00:02:02,009
obvious right so on the left hand side

00:02:00,210 --> 00:02:06,750
you see we have a more traditional REST

00:02:02,009 --> 00:02:08,429
API recipe has great but graph QL is an

00:02:06,750 --> 00:02:09,929
API technology you know it works in

00:02:08,429 --> 00:02:11,370
terms of a schema instead of defined

00:02:09,929 --> 00:02:13,470
endpoints so everything you see on the

00:02:11,370 --> 00:02:15,960
left hand side and authors and posts

00:02:13,470 --> 00:02:22,350
I instead have a schema sprayed here on

00:02:15,960 --> 00:02:24,540
the right so one of the big benefits of

00:02:22,350 --> 00:02:27,240
graph QL has ever showed earlier is that

00:02:24,540 --> 00:02:28,980
it prevents over fetching Raul for REST

00:02:27,240 --> 00:02:30,660
API where I don't know exactly what data

00:02:28,980 --> 00:02:33,300
I'm getting back where graph QL I

00:02:30,660 --> 00:02:35,070
explicitly tell the backend what I want

00:02:33,300 --> 00:02:39,360
and it gives me exactly what I want and

00:02:35,070 --> 00:02:41,100
I'm like having to have one URL or sorry

00:02:39,360 --> 00:02:42,900
instead of having multiple URLs for rest

00:02:41,100 --> 00:02:46,590
I only have one for sauce graph QL

00:02:42,900 --> 00:02:49,590
endpoint which is great so how do we

00:02:46,590 --> 00:02:50,910
make product development better at scale

00:02:49,590 --> 00:02:53,100
it's the ad scale part here which I'm

00:02:50,910 --> 00:02:54,630
really interested in the kind of

00:02:53,100 --> 00:02:56,220
traditional product development looks a

00:02:54,630 --> 00:02:58,200
bit like this right you have a front end

00:02:56,220 --> 00:02:59,459
you have a back end and you have an API

00:02:58,200 --> 00:03:01,500
which lets you talk to one another

00:02:59,459 --> 00:03:03,270
that's what the ideal situation would

00:03:01,500 --> 00:03:05,870
look like but in reality it looks more

00:03:03,270 --> 00:03:08,390
like this there's a lot going on here

00:03:05,870 --> 00:03:11,580
especially at a modern JavaScript

00:03:08,390 --> 00:03:13,890
ecosystem even I even have two backends

00:03:11,580 --> 00:03:15,209
here which is becoming more popular how

00:03:13,890 --> 00:03:16,740
do you make sure all these parts

00:03:15,209 --> 00:03:18,570
communicate with one another the most

00:03:16,740 --> 00:03:20,280
valuable systems are those that can tie

00:03:18,570 --> 00:03:24,239
into all these aspects of development so

00:03:20,280 --> 00:03:25,350
for example a UI component system so

00:03:24,239 --> 00:03:26,850
what we've done that stripe is we've

00:03:25,350 --> 00:03:30,170
kind of replaced these middle two bits

00:03:26,850 --> 00:03:32,130
with Apollo cogent and graph QL API and

00:03:30,170 --> 00:03:33,630
the best thing about this that means

00:03:32,130 --> 00:03:35,190
that all these components here can now

00:03:33,630 --> 00:03:36,780
talk to one another using the same

00:03:35,190 --> 00:03:39,690
format in the same data which in this

00:03:36,780 --> 00:03:41,160
case is graph QL so all these things

00:03:39,690 --> 00:03:44,340
know how to talk each others share the

00:03:41,160 --> 00:03:46,769
data so as graph car has such a big

00:03:44,340 --> 00:03:49,049
impact well schema defines capabilities

00:03:46,769 --> 00:03:50,850
queries defined data requirements from

00:03:49,049 --> 00:03:52,260
this schema here on the Left I can

00:03:50,850 --> 00:03:53,640
command into on the right even gets a

00:03:52,260 --> 00:03:56,820
little auto completion as you can see

00:03:53,640 --> 00:03:59,220
here and I can reduce over fetching of

00:03:56,820 --> 00:04:00,030
data I can have accurate monitoring this

00:03:59,220 --> 00:04:01,769
is something I'll talk a little bit

00:04:00,030 --> 00:04:04,230
later and we have a really good mocking

00:04:01,769 --> 00:04:06,480
system here's a couple of more big

00:04:04,230 --> 00:04:08,160
impact stories with graph QL what I want

00:04:06,480 --> 00:04:12,239
to highlight here really is monitoring

00:04:08,160 --> 00:04:14,010
in graph QL you can track usage for a

00:04:12,239 --> 00:04:15,239
specific field this is traditionally

00:04:14,010 --> 00:04:17,130
been a very difficult thing to do it in

00:04:15,239 --> 00:04:19,109
a REST API you don't know what fields

00:04:17,130 --> 00:04:22,320
are actually being used when fetched

00:04:19,109 --> 00:04:23,520
from your back-end that's really hard to

00:04:22,320 --> 00:04:25,020
do I'm going to talk about other marks

00:04:23,520 --> 00:04:25,919
on them things in a sec servers let's

00:04:25,020 --> 00:04:27,060
took a look some of the tools that we

00:04:25,919 --> 00:04:30,060
built that stripe

00:04:27,060 --> 00:04:33,600
first data mocking so why would you mock

00:04:30,060 --> 00:04:34,830
stuff it seems like you know obvious why

00:04:33,600 --> 00:04:36,480
we'd mock but it's really good to kind

00:04:34,830 --> 00:04:39,060
of steady text back take step back and

00:04:36,480 --> 00:04:40,230
really think about it so when you mock

00:04:39,060 --> 00:04:41,639
self you have faster more resilient

00:04:40,230 --> 00:04:43,950
chest you don't have to wait on an API

00:04:41,639 --> 00:04:46,050
you have immediately test results you

00:04:43,950 --> 00:04:47,370
can avoid the waterfall flow by actually

00:04:46,050 --> 00:04:48,960
being able to develop your front-end

00:04:47,370 --> 00:04:51,360
components before the backends even

00:04:48,960 --> 00:04:54,500
built when you mock stuff and it's

00:04:51,360 --> 00:04:57,330
really easy to generate educate States

00:04:54,500 --> 00:04:59,790
so graph code makes mocking really easy

00:04:57,330 --> 00:05:01,740
because we have a schema and the schema

00:04:59,790 --> 00:05:03,120
has types in it we already know what

00:05:01,740 --> 00:05:04,770
shape our data's going to look like and

00:05:03,120 --> 00:05:05,880
exactly what type is gonna look like so

00:05:04,770 --> 00:05:07,830
this is actually the code snippet I

00:05:05,880 --> 00:05:11,070
grabbed from the graph to our tools on

00:05:07,830 --> 00:05:12,930
the Left I have a schema string on the

00:05:11,070 --> 00:05:15,210
right I'm actually I'm mocking it with

00:05:12,930 --> 00:05:17,370
admonished the schema function I have my

00:05:15,210 --> 00:05:20,310
query and I was as a result I have the

00:05:17,370 --> 00:05:23,280
data with just some generic data based

00:05:20,310 --> 00:05:24,660
on those types but the problem here is

00:05:23,280 --> 00:05:26,280
you know what about edge cases right if

00:05:24,660 --> 00:05:28,500
I have a globally mock schema which is

00:05:26,280 --> 00:05:29,910
what what we're looking for what about

00:05:28,500 --> 00:05:32,160
these little edge cases well

00:05:29,910 --> 00:05:33,690
traditionally what you would do is you

00:05:32,160 --> 00:05:35,340
would have perv request mocking its

00:05:33,690 --> 00:05:37,860
means that for all my edge cases I would

00:05:35,340 --> 00:05:39,720
have a request and a response and I'll

00:05:37,860 --> 00:05:41,790
have the exact response here this is

00:05:39,720 --> 00:05:43,289
nice this is good but now I'll lose all

00:05:41,790 --> 00:05:45,180
the benefits of my schema base mocking

00:05:43,289 --> 00:05:47,070
so what we do at stripe is we try to

00:05:45,180 --> 00:05:49,560
have the best of both worlds where we

00:05:47,070 --> 00:05:51,360
have overrides this means that I have my

00:05:49,560 --> 00:05:54,060
generic data which created from my

00:05:51,360 --> 00:05:56,419
schema but I can override some things so

00:05:54,060 --> 00:05:59,370
I can test for for a specific edge case

00:05:56,419 --> 00:06:01,289
over here my customers overs is the

00:05:59,370 --> 00:06:02,880
function that we wrote which actually

00:06:01,289 --> 00:06:05,280
lets me add extra data this is just a

00:06:02,880 --> 00:06:06,840
simple to-do list all I care for this

00:06:05,280 --> 00:06:08,640
particular to-do list is that there is

00:06:06,840 --> 00:06:10,200
two items one that is completed and one

00:06:08,640 --> 00:06:10,710
that is not everything else has been

00:06:10,200 --> 00:06:12,630
mocked

00:06:10,710 --> 00:06:14,100
which means that when I run my code and

00:06:12,630 --> 00:06:16,350
I test it I know exactly what I'm

00:06:14,100 --> 00:06:20,280
testing for so here's like an example of

00:06:16,350 --> 00:06:21,990
these default marks in this case I have

00:06:20,280 --> 00:06:23,910
this connect overview page react

00:06:21,990 --> 00:06:26,039
component this actually takes a lot of

00:06:23,910 --> 00:06:27,900
props and a lot of data but in this test

00:06:26,039 --> 00:06:29,789
I don't care about what kind of data

00:06:27,900 --> 00:06:31,860
goes in I just care that it renders and

00:06:29,789 --> 00:06:34,560
then it doesn't it break or anything so

00:06:31,860 --> 00:06:36,030
with global mocking by the SQL I

00:06:34,560 --> 00:06:38,640
actually have a lot of props are being

00:06:36,030 --> 00:06:39,900
passed into this component via Apollo

00:06:38,640 --> 00:06:43,460
test provider and I

00:06:39,900 --> 00:06:46,530
very easily check does this work or not

00:06:43,460 --> 00:06:48,600
his example of the same except we're

00:06:46,530 --> 00:06:51,960
using overrides now so I now have this

00:06:48,600 --> 00:06:53,450
custom resolver where I can add like

00:06:51,960 --> 00:06:56,550
things like a currency availability

00:06:53,450 --> 00:06:57,750
pending etc and I can test for exactly

00:06:56,550 --> 00:06:59,310
that what I'm interesting at the very

00:06:57,750 --> 00:07:01,950
bottom without having to worry about all

00:06:59,310 --> 00:07:06,180
the other props that are put into this

00:07:01,950 --> 00:07:08,640
particular component we also have some

00:07:06,180 --> 00:07:10,020
nice mocks for a really common edge case

00:07:08,640 --> 00:07:12,690
which can be reducing quite difficult to

00:07:10,020 --> 00:07:15,060
test which is error states and loading

00:07:12,690 --> 00:07:16,530
States so here I have an error provider

00:07:15,060 --> 00:07:18,210
and I have a loading provider which

00:07:16,530 --> 00:07:20,790
keeps those components in a perpetual

00:07:18,210 --> 00:07:23,310
state of are the loading or error so you

00:07:20,790 --> 00:07:26,940
can very easily see what your users will

00:07:23,310 --> 00:07:29,280
see if something goes wrong next don't

00:07:26,940 --> 00:07:30,330
talk about schema validation and this is

00:07:29,280 --> 00:07:32,520
something that's really important very

00:07:30,330 --> 00:07:34,260
dear to us at stripe because we are have

00:07:32,520 --> 00:07:35,880
grow it into a larger company where we

00:07:34,260 --> 00:07:39,330
have many people working on the same

00:07:35,880 --> 00:07:41,610
thing so when you make a small focused

00:07:39,330 --> 00:07:43,680
API change I want to make sure that I

00:07:41,610 --> 00:07:44,910
don't break a hundred other components

00:07:43,680 --> 00:07:46,740
from scratch out about our component

00:07:44,910 --> 00:07:49,440
base in a component system because it's

00:07:46,740 --> 00:07:51,060
really easy to do that because of the

00:07:49,440 --> 00:07:52,860
very nature of that component and Hana

00:07:51,060 --> 00:07:55,260
hereditary system so we need guardrails

00:07:52,860 --> 00:07:56,610
were able to do this what's really hard

00:07:55,260 --> 00:07:58,080
about like that stripe dashboard is that

00:07:56,610 --> 00:07:59,190
we do have a lot of people who work on

00:07:58,080 --> 00:08:01,080
the same project who don't necessarily

00:07:59,190 --> 00:08:03,510
see each other in person because we have

00:08:01,080 --> 00:08:05,400
a global distributed teams so how do we

00:08:03,510 --> 00:08:07,140
coordinate all these people build this

00:08:05,400 --> 00:08:10,580
thing especially across multiple time

00:08:07,140 --> 00:08:12,600
zones so that we have like a guardrail

00:08:10,580 --> 00:08:13,530
well so I'm going to talk about a little

00:08:12,600 --> 00:08:15,780
bit more about this in a sec but

00:08:13,530 --> 00:08:18,150
generally we have a one schema graph QL

00:08:15,780 --> 00:08:20,460
file we can generate flow types

00:08:18,150 --> 00:08:24,780
automatically and we have a backwards

00:08:20,460 --> 00:08:27,030
compatibility check er so first all of

00:08:24,780 --> 00:08:29,340
our graph QL our whole schema is in one

00:08:27,030 --> 00:08:31,770
file it's checked into our mono repo

00:08:29,340 --> 00:08:34,230
it's automatically generated by our API

00:08:31,770 --> 00:08:36,180
code and everything that we need like

00:08:34,230 --> 00:08:37,590
this is the source of truth for all our

00:08:36,180 --> 00:08:39,420
data that goes from the back end to the

00:08:37,590 --> 00:08:41,730
front end and what's cool about this is

00:08:39,420 --> 00:08:43,770
that as you can see here every single

00:08:41,730 --> 00:08:45,660
item here in this address has a type

00:08:43,770 --> 00:08:48,480
associated with that what can we do with

00:08:45,660 --> 00:08:50,610
that well with Apollo coach and tools we

00:08:48,480 --> 00:08:52,800
can actually generate flow types on the

00:08:50,610 --> 00:08:53,660
fly automatically everything that comes

00:08:52,800 --> 00:08:57,800
from the schema

00:08:53,660 --> 00:08:59,600
now has an automatic types set to it

00:08:57,800 --> 00:09:01,490
which makes developing a lot easier this

00:08:59,600 --> 00:09:03,190
is really cool so what we build at

00:09:01,490 --> 00:09:07,879
stripe is something called krory wrapper

00:09:03,190 --> 00:09:09,500
this is a function which takes an owner

00:09:07,879 --> 00:09:11,990
in this case the T though is responsible

00:09:09,500 --> 00:09:13,639
for this code and it takes a query this

00:09:11,990 --> 00:09:15,410
is just a normal graph QL query and it

00:09:13,639 --> 00:09:17,500
says exactly what data that I want for

00:09:15,410 --> 00:09:21,529
this component and it gives me back I

00:09:17,500 --> 00:09:26,240
ready to use react component here it is

00:09:21,529 --> 00:09:27,949
in use when I try to render it I have

00:09:26,240 --> 00:09:29,779
some props I have a loading state I have

00:09:27,949 --> 00:09:31,819
an arrow state and I have data and this

00:09:29,779 --> 00:09:33,740
data object is just what I specify what

00:09:31,819 --> 00:09:36,740
I wanted in the previous graph QL a

00:09:33,740 --> 00:09:39,199
query so this is a really nice and easy

00:09:36,740 --> 00:09:42,620
way to get my profs and my corners up

00:09:39,199 --> 00:09:44,120
running fast as possible but we need a

00:09:42,620 --> 00:09:46,370
backwards compatibility checker why do

00:09:44,120 --> 00:09:48,889
we need this well we found that at

00:09:46,370 --> 00:09:51,680
stripe sometimes people do not refresh

00:09:48,889 --> 00:09:53,149
their front-end ever and one instance we

00:09:51,680 --> 00:09:55,519
have someone who took over a month

00:09:53,149 --> 00:09:56,959
before they refresh their pages and we

00:09:55,519 --> 00:09:59,180
want to make sure that even those people

00:09:56,959 --> 00:10:01,220
who do like to close tabs you know who

00:09:59,180 --> 00:10:04,220
you are want to make sure that they

00:10:01,220 --> 00:10:06,050
don't have a bad experience with if they

00:10:04,220 --> 00:10:07,310
try like an operation and they get the

00:10:06,050 --> 00:10:10,819
front end gets back data wasn't

00:10:07,310 --> 00:10:12,370
expecting you get errors not good so we

00:10:10,819 --> 00:10:14,630
actually have built this into our CI

00:10:12,370 --> 00:10:16,160
component where if you change the schema

00:10:14,630 --> 00:10:18,019
in any way it yells at you and says

00:10:16,160 --> 00:10:18,889
don't do that but then you say okay well

00:10:18,019 --> 00:10:20,269
how do you actually make breaking

00:10:18,889 --> 00:10:22,269
changes then how do you how do we

00:10:20,269 --> 00:10:24,230
actually add stuff to this well

00:10:22,269 --> 00:10:25,430
sometimes we don't want to fields and

00:10:24,230 --> 00:10:27,740
your effort no one's using we can have a

00:10:25,430 --> 00:10:29,930
simple two step process we mark a field

00:10:27,740 --> 00:10:32,240
as deprecated and we delete it merge

00:10:29,930 --> 00:10:33,860
sorry we mark applies field as

00:10:32,240 --> 00:10:35,360
deprecated then we merge and that one's

00:10:33,860 --> 00:10:37,100
for sure that no one's using their field

00:10:35,360 --> 00:10:40,160
anymore which we can do via monitoring

00:10:37,100 --> 00:10:41,720
with graph QL we can just delete it this

00:10:40,160 --> 00:10:43,730
is not ideal for things like modifying

00:10:41,720 --> 00:10:47,209
an existing field but we're working on

00:10:43,730 --> 00:10:48,649
things like that next I will talk about

00:10:47,209 --> 00:10:51,199
just the benefits we've seen from

00:10:48,649 --> 00:10:52,790
adopting graph QL so if you've ever read

00:10:51,199 --> 00:10:55,610
about graph QL I've ever seen a video

00:10:52,790 --> 00:10:57,050
you see like these common benefits which

00:10:55,610 --> 00:10:59,480
we absolutely agree with these are

00:10:57,050 --> 00:11:01,009
fantastic but it is over fetching you

00:10:59,480 --> 00:11:02,660
know not having too many queries to

00:11:01,009 --> 00:11:04,370
worry about these are all fantastic but

00:11:02,660 --> 00:11:05,930
I want to talk more about what we at

00:11:04,370 --> 00:11:07,390
stripe have really found has been really

00:11:05,930 --> 00:11:11,260
beneficial about

00:11:07,390 --> 00:11:13,920
using graph QL at scale which can be

00:11:11,260 --> 00:11:16,960
somewhere in great tools and community

00:11:13,920 --> 00:11:18,520
easily add stuff and those static types

00:11:16,960 --> 00:11:19,990
first I just want to talk about the

00:11:18,520 --> 00:11:23,740
tools and Docs

00:11:19,990 --> 00:11:26,710
so because graph QL an Apollo coach n

00:11:23,740 --> 00:11:28,750
are open source communities a lot of

00:11:26,710 --> 00:11:31,240
work goes into this stuff as much as we

00:11:28,750 --> 00:11:33,130
love the very proudly internal tooling

00:11:31,240 --> 00:11:34,210
we have every two we build in-house is

00:11:33,130 --> 00:11:36,430
something we have to maintain ourselves

00:11:34,210 --> 00:11:38,200
by using graph QL there are many large

00:11:36,430 --> 00:11:40,350
companies that are using this it kind of

00:11:38,200 --> 00:11:44,290
takes the strain off of us

00:11:40,350 --> 00:11:45,940
and they're just fantastic documentation

00:11:44,290 --> 00:11:48,130
to be had with graph QL as well one of

00:11:45,940 --> 00:11:50,410
the best things about graph QL is that

00:11:48,130 --> 00:11:52,030
if you have heard of graphical and have

00:11:50,410 --> 00:11:53,830
used in a previous job if you start work

00:11:52,030 --> 00:11:55,570
at stripe you already know how stripes

00:11:53,830 --> 00:12:00,010
front-end works because it's exactly the

00:11:55,570 --> 00:12:01,630
same way it was before and finally the

00:12:00,010 --> 00:12:03,700
real big benefit we've seen is just the

00:12:01,630 --> 00:12:05,920
automatically generated static types so

00:12:03,700 --> 00:12:08,020
this we use flow internally however this

00:12:05,920 --> 00:12:09,520
will work with typescript as well it's

00:12:08,020 --> 00:12:11,980
just really nice to have a component

00:12:09,520 --> 00:12:14,440
with data and know exactly what types

00:12:11,980 --> 00:12:16,650
those data is and it makes really easy

00:12:14,440 --> 00:12:18,490
to review code gives you more or less

00:12:16,650 --> 00:12:25,180
unintentional side effects and you can

00:12:18,490 --> 00:12:27,790
modify a couple of so much faster same

00:12:25,180 --> 00:12:29,080
conclusion I promise this would be short

00:12:27,790 --> 00:12:32,410
because I know we're holding up lunch

00:12:29,080 --> 00:12:35,290
right now graph kill works across the

00:12:32,410 --> 00:12:38,380
stack at scale really nicely it's makes

00:12:35,290 --> 00:12:39,760
everyone happy it's lets you well that's

00:12:38,380 --> 00:12:42,250
all your developers kind of work in

00:12:39,760 --> 00:12:43,360
unison and touch the same code without

00:12:42,250 --> 00:12:45,970
getting stepping on each other's feet

00:12:43,360 --> 00:12:48,460
makes testing easier and what's really

00:12:45,970 --> 00:12:51,070
nice is just how quickly people can ramp

00:12:48,460 --> 00:12:53,170
up and start developing with graph QL

00:12:51,070 --> 00:12:54,430
and I promise I was not paid by Rothko

00:12:53,170 --> 00:12:58,090
to say these things i generally do you

00:12:54,430 --> 00:12:59,620
think it's a fantastic service right

00:12:58,090 --> 00:13:01,920
with that thank you so much for having

00:12:59,620 --> 00:13:03,970
me please do check out stripe dev and

00:13:01,920 --> 00:13:06,819
come to our workshop which is hopefully

00:13:03,970 --> 00:13:08,879
starting in about an hour's time

00:13:06,819 --> 00:13:08,879

YouTube URL: https://www.youtube.com/watch?v=EjJVf2s60s8


