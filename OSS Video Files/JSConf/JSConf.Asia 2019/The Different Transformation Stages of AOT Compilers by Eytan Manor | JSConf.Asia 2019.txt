Title: The Different Transformation Stages of AOT Compilers by Eytan Manor | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	Have you ever noticed the recent trend where no one uses ES5 anymore? AOT compilers became a trivial thing nowadays; everyone uses it but very few really understand how they work. With the knowledge that I'm gonna give you in my talk, a new exciting world of possibilities will open up for you; you will understand how popular compilers such as TypeScript and Babel work behind the scenes and you be able to build cool Babel plugins. With this knowledge you will be able to not only implement things which aren't possible to do during runtime, such as ng-anotate, but you will also be able to save some precious processing power and make your apps more efficient.

Eytan is a JavaScript artist who codes for fun. Originally comes from the land of the Promise(), but has been traveling the world to discover its deepest secrets. Despite NPM goodies being his favorite treat, he consumes vanilla JavaScript the most, because less is more. His hobbies are eating, sleeping; and open-source... He loves open-source.


JSConf.Asia - LASALLE College of the Arts, Singapore - 16 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:00,000 --> 00:00:15,820
[Music]

00:00:17,640 --> 00:00:21,750
so hey guys I hope you are having a

00:00:19,439 --> 00:00:23,789
great time in Singapore I love Singapore

00:00:21,750 --> 00:00:25,890
personally are there any people from

00:00:23,789 --> 00:00:31,050
Israel by the way can you raise their

00:00:25,890 --> 00:00:32,880
hand okay I guess not so first of all

00:00:31,050 --> 00:00:35,010
let me introduce myself my name is a tan

00:00:32,880 --> 00:00:35,790
I come from Israel at the moment I live

00:00:35,010 --> 00:00:38,070
in Taipei

00:00:35,790 --> 00:00:40,200
I'm a full-stack JavaScript engineer I

00:00:38,070 --> 00:00:42,540
do that full-time and I also do that for

00:00:40,200 --> 00:00:45,360
fun this is why I give a talk right now

00:00:42,540 --> 00:00:47,940
and when it comes to programming I

00:00:45,360 --> 00:00:51,030
really like to dive deeply into stuff

00:00:47,940 --> 00:00:53,219
which are trivial so trivial that it's

00:00:51,030 --> 00:00:59,550
part of our daily routine and we just

00:00:53,219 --> 00:01:01,770
overlook it and because it's something

00:00:59,550 --> 00:01:03,480
so trivial then I'm gonna dive deeply

00:01:01,770 --> 00:01:05,700
into it and naturally it's gonna be a

00:01:03,480 --> 00:01:08,610
lot of a level talk so it's not gonna

00:01:05,700 --> 00:01:11,520
turn you necessarily into better react

00:01:08,610 --> 00:01:13,229
or angular developers but at the end of

00:01:11,520 --> 00:01:15,240
the day you'll be able to solve problems

00:01:13,229 --> 00:01:17,549
that a lot of programmers don't know how

00:01:15,240 --> 00:01:19,759
to solve and just a new world of

00:01:17,549 --> 00:01:23,790
possibilities will open up to you and

00:01:19,759 --> 00:01:27,930
the subject of the day is äôt compilers

00:01:23,790 --> 00:01:29,850
ahead of time so I assume that you're

00:01:27,930 --> 00:01:30,659
pretty much familiar with the concept

00:01:29,850 --> 00:01:34,759
okay

00:01:30,659 --> 00:01:37,409
example compilers compilers for C or C++

00:01:34,759 --> 00:01:40,189
where you basically take a code string

00:01:37,409 --> 00:01:42,600
and you get it from one format into

00:01:40,189 --> 00:01:45,960
native machine code or in the case of

00:01:42,600 --> 00:01:50,340
JavaScript where you take yes next and

00:01:45,960 --> 00:01:52,860
you compile it two years five now why is

00:01:50,340 --> 00:01:55,500
it such a trivial topic to prove my

00:01:52,860 --> 00:01:59,189
point I have few questions if it's true

00:01:55,500 --> 00:02:01,920
for you please raise your hand who here

00:01:59,189 --> 00:02:05,040
uses Babel to compile JavaScript

00:02:01,920 --> 00:02:08,520
applications please raise your hand okay

00:02:05,040 --> 00:02:11,580
a lot of people who here uses typescript

00:02:08,520 --> 00:02:13,440
raise your hand okay again a lot of

00:02:11,580 --> 00:02:13,830
people now listen carefully this is

00:02:13,440 --> 00:02:17,130
likely

00:02:13,830 --> 00:02:18,690
different who here uses es5 to write

00:02:17,130 --> 00:02:20,510
Java see applications please raise your

00:02:18,690 --> 00:02:24,770
hand

00:02:20,510 --> 00:02:28,560
get out you know No

00:02:24,770 --> 00:02:31,290
okay so we see that there's a common

00:02:28,560 --> 00:02:32,460
pattern here right we all use Babel and

00:02:31,290 --> 00:02:34,950
typescript and all these sort of

00:02:32,460 --> 00:02:38,390
compilers but no one ever stopped and

00:02:34,950 --> 00:02:40,350
wonder how does it actually work and

00:02:38,390 --> 00:02:41,940
there's a lot of advantages to that

00:02:40,350 --> 00:02:44,610
because once you know how it actually

00:02:41,940 --> 00:02:46,620
works then you would know how to run

00:02:44,610 --> 00:02:48,600
some processing before you actually go

00:02:46,620 --> 00:02:53,250
to the interpreter rather than race

00:02:48,600 --> 00:02:56,540
wasting some runtime processing power so

00:02:53,250 --> 00:03:01,290
I'm gonna go through very trivial stuff

00:02:56,540 --> 00:03:06,870
and later on I'm gonna dive deeply into

00:03:01,290 --> 00:03:08,370
that so just bear with me yeah so why

00:03:06,870 --> 00:03:10,290
exactly do we use ahead of time

00:03:08,370 --> 00:03:13,100
compilers what are the advantages first

00:03:10,290 --> 00:03:15,900
of all you can use it to optimize code

00:03:13,100 --> 00:03:18,570
so let's say that we have parts of code

00:03:15,900 --> 00:03:21,060
that we don't actually use such as tree

00:03:18,570 --> 00:03:23,370
shaking where we import modules and we

00:03:21,060 --> 00:03:25,440
end up not using these modules therefore

00:03:23,370 --> 00:03:29,820
we can reduce that part of goat and

00:03:25,440 --> 00:03:32,160
reduce bundle size or for example if we

00:03:29,820 --> 00:03:34,200
have variable assignments of variables

00:03:32,160 --> 00:03:35,820
that we don't actually use then we can

00:03:34,200 --> 00:03:37,380
just delete that when we compile the

00:03:35,820 --> 00:03:41,190
code and therefore save some memory

00:03:37,380 --> 00:03:43,200
locations and one night what night why

00:03:41,190 --> 00:03:45,600
not take it a step further using linters

00:03:43,200 --> 00:03:47,940
so basically what the linter does it

00:03:45,600 --> 00:03:50,070
says hey man listen there's something

00:03:47,940 --> 00:03:52,260
wrong here okay you import that module

00:03:50,070 --> 00:03:56,060
and you don't use it or maybe there's a

00:03:52,260 --> 00:03:58,920
standard of code that we wanted to just

00:03:56,060 --> 00:04:01,350
live up to our own expectations so let's

00:03:58,920 --> 00:04:03,510
say we want to use conditions in a

00:04:01,350 --> 00:04:06,209
specific way maybe closures in specific

00:04:03,510 --> 00:04:09,300
places maybe we want to use to force use

00:04:06,209 --> 00:04:11,750
constant variables so before we actually

00:04:09,300 --> 00:04:14,640
run the optimization itself we can

00:04:11,750 --> 00:04:17,880
basically make the code look a lot

00:04:14,640 --> 00:04:22,020
better before we push it into our get

00:04:17,880 --> 00:04:23,060
host also it enables backward

00:04:22,020 --> 00:04:26,510
compatibility

00:04:23,060 --> 00:04:29,820
now we all

00:04:26,510 --> 00:04:33,150
use the latest features of JavaScript

00:04:29,820 --> 00:04:36,600
and if I'll just open chrome dev tools

00:04:33,150 --> 00:04:38,490
right now and I'll try to use syntax

00:04:36,600 --> 00:04:42,360
such as arrow functions async/await

00:04:38,490 --> 00:04:44,850
and so on it will work but we all know

00:04:42,360 --> 00:04:47,370
that unfortunately there are internet

00:04:44,850 --> 00:04:50,460
explorer 11 out there okay users that

00:04:47,370 --> 00:04:52,860
use this old browser and we need to

00:04:50,460 --> 00:04:54,630
enable backward compatibility because we

00:04:52,860 --> 00:04:56,010
don't know what type of browser what

00:04:54,630 --> 00:04:58,530
version of the browser the user is gonna

00:04:56,010 --> 00:04:59,820
run therefore we need to ensure that we

00:04:58,530 --> 00:05:03,740
use the least amount of features

00:04:59,820 --> 00:05:08,700
possible when it comes to Eggman script

00:05:03,740 --> 00:05:11,430
also when someone suggests a new feature

00:05:08,700 --> 00:05:13,650
for the set of specifications for Eggman

00:05:11,430 --> 00:05:16,910
script it takes time before it actually

00:05:13,650 --> 00:05:19,160
gets accepted into the language because

00:05:16,910 --> 00:05:22,289
the Committee needs to look at it

00:05:19,160 --> 00:05:24,030
afterwards the community needs to also

00:05:22,289 --> 00:05:28,110
see how it fits within the echo system

00:05:24,030 --> 00:05:32,400
it needs to go through stages 0 1 2 3

00:05:28,110 --> 00:05:34,650
and then all the browser's need they

00:05:32,400 --> 00:05:36,690
need to implement that natively within

00:05:34,650 --> 00:05:39,380
C++ and they all need to be aligned with

00:05:36,690 --> 00:05:42,389
one another this process takes time

00:05:39,380 --> 00:05:45,210
using an external compiler this is

00:05:42,389 --> 00:05:47,460
relatively easy to just plug in another

00:05:45,210 --> 00:05:49,380
feature and then basically there's a

00:05:47,460 --> 00:05:52,680
layer on top which is common for all

00:05:49,380 --> 00:05:54,450
browsers so it's very easy especially in

00:05:52,680 --> 00:05:56,520
the case of Babel where the compiler is

00:05:54,450 --> 00:05:58,770
written in a high-level languages such

00:05:56,520 --> 00:06:00,750
as JavaScript and we also have the

00:05:58,770 --> 00:06:04,800
opportunity to test the new feature and

00:06:00,750 --> 00:06:09,210
see if it actually fits one final reason

00:06:04,800 --> 00:06:12,150
is that we can use costume syntax also

00:06:09,210 --> 00:06:15,780
known as language extensions such as

00:06:12,150 --> 00:06:18,510
typescript where we basically have type

00:06:15,780 --> 00:06:21,660
safety okay and we can see if the code

00:06:18,510 --> 00:06:22,770
actually behaves the way we want or we

00:06:21,660 --> 00:06:25,200
can use JSX

00:06:22,770 --> 00:06:28,130
which is used vastly to write react

00:06:25,200 --> 00:06:30,330
applications in a better way so

00:06:28,130 --> 00:06:38,430
obviously there are advantages to the

00:06:30,330 --> 00:06:40,319
compilers wait okay so there aren't

00:06:38,430 --> 00:06:41,789
gonna be many slides the

00:06:40,319 --> 00:06:43,080
there's gonna be this slide and another

00:06:41,789 --> 00:06:45,569
one and that's it it's mostly gonna be

00:06:43,080 --> 00:06:47,789
demonstration I hope I can get it right

00:06:45,569 --> 00:06:49,830
because I'm not used to this setup like

00:06:47,789 --> 00:06:52,139
they said this is like I mean I'm used

00:06:49,830 --> 00:06:56,940
to Linux and this is like another world

00:06:52,139 --> 00:07:00,000
for me anyways what are the stages of

00:06:56,940 --> 00:07:03,599
the compilation everything that I'm

00:07:00,000 --> 00:07:06,000
gonna mention it's um it is true for all

00:07:03,599 --> 00:07:08,789
IOT compilers I believe although I want

00:07:06,000 --> 00:07:11,550
to be more specific to Babel because

00:07:08,789 --> 00:07:14,280
it's very popular within the ecosystem

00:07:11,550 --> 00:07:17,789
it's also very easy to write plugins

00:07:14,280 --> 00:07:21,090
into Babel but yeah everything is true

00:07:17,789 --> 00:07:24,750
for all a ot compilers out there so

00:07:21,090 --> 00:07:27,590
first stage first of all we take as an

00:07:24,750 --> 00:07:30,030
input a code string and then we parse it

00:07:27,590 --> 00:07:33,180
parsing what it means is that we put it

00:07:30,030 --> 00:07:35,610
into a JSON ok this JSON is basically a

00:07:33,180 --> 00:07:38,219
tree and the tree is made out of nodes

00:07:35,610 --> 00:07:41,580
each and every node with that in that

00:07:38,219 --> 00:07:43,969
tree represent a different feature

00:07:41,580 --> 00:07:46,919
within the syntax this tree is called

00:07:43,969 --> 00:07:51,630
ast abstract syntax tree because it

00:07:46,919 --> 00:07:55,199
represents the syntax now comes the

00:07:51,630 --> 00:07:58,229
second stage once we have the AST we

00:07:55,199 --> 00:08:02,099
take it as an input and we generate code

00:07:58,229 --> 00:08:03,960
out of it in a different format ok it's

00:08:02,099 --> 00:08:06,360
very easy to do so we basically take a

00:08:03,960 --> 00:08:08,580
specific node and then we generate the

00:08:06,360 --> 00:08:10,830
magic code string to that specific node

00:08:08,580 --> 00:08:13,680
in the case of Babel it's it's slightly

00:08:10,830 --> 00:08:15,659
different but because Babel is it's not

00:08:13,680 --> 00:08:16,919
exactly a compiler but it works exactly

00:08:15,659 --> 00:08:19,860
the same way it's more like a

00:08:16,919 --> 00:08:22,229
transformer so even though you take an

00:08:19,860 --> 00:08:25,199
ast the generated code should be exactly

00:08:22,229 --> 00:08:28,560
the same now I put a lot of information

00:08:25,199 --> 00:08:30,330
out there and stuff like that the best

00:08:28,560 --> 00:08:32,130
way to explain something is by

00:08:30,330 --> 00:08:36,289
demonstrating so this is exactly what

00:08:32,130 --> 00:08:36,289
I'm gonna do now so Lance

00:08:36,560 --> 00:08:43,349
ok so let's focus on the ASD first how

00:08:40,560 --> 00:08:44,610
does it the ASD looks like exactly so

00:08:43,349 --> 00:08:50,630
there's a website out there it's called

00:08:44,610 --> 00:08:56,870
a is the Explorer this one

00:08:50,630 --> 00:09:01,500
and let's okay

00:08:56,870 --> 00:09:04,110
and we have two windows in here okay in

00:09:01,500 --> 00:09:06,900
the left window what we have is the text

00:09:04,110 --> 00:09:09,720
editor where we can type code in the

00:09:06,900 --> 00:09:12,480
right we have an object the Java sweet

00:09:09,720 --> 00:09:17,340
object as I said the ast that represents

00:09:12,480 --> 00:09:19,590
the code so what happens if I type just

00:09:17,340 --> 00:09:26,280
a very generic code nothing special

00:09:19,590 --> 00:09:29,340
about it so we see on the right that the

00:09:26,280 --> 00:09:31,920
view got updated okay and on the right

00:09:29,340 --> 00:09:35,220
this actually this is the ASD that

00:09:31,920 --> 00:09:37,710
represents the code now what's nice

00:09:35,220 --> 00:09:41,430
about this tool is not is that not only

00:09:37,710 --> 00:09:43,920
it shows us the ast but it's very easy

00:09:41,430 --> 00:09:47,460
to highlight the code and match it with

00:09:43,920 --> 00:09:52,470
a correlated node so let's highlight

00:09:47,460 --> 00:09:56,520
something on the left ok wait it doesn't

00:09:52,470 --> 00:10:00,540
use the right parser okay I also explain

00:09:56,520 --> 00:10:03,540
what it is so once I highlight something

00:10:00,540 --> 00:10:06,900
on the left it will also be highlighted

00:10:03,540 --> 00:10:09,660
on the right and vice versa if I hover

00:10:06,900 --> 00:10:13,320
over a specific node type it will be

00:10:09,660 --> 00:10:15,810
highlighted on the left so it's very

00:10:13,320 --> 00:10:17,940
easy to see what represents the code and

00:10:15,810 --> 00:10:20,880
if we'll take a specific node as an

00:10:17,940 --> 00:10:23,880
example let's highlight number one over

00:10:20,880 --> 00:10:27,120
there and we'll look at the node we'll

00:10:23,880 --> 00:10:29,310
see that the type name actually matches

00:10:27,120 --> 00:10:31,530
the description okay this is called a

00:10:29,310 --> 00:10:37,080
numeric literal because literally this

00:10:31,530 --> 00:10:39,660
is a number with the value 1 so this is

00:10:37,080 --> 00:10:41,370
basically an ast and you see their nodes

00:10:39,660 --> 00:10:45,840
which are nested with with one another

00:10:41,370 --> 00:10:49,650
and it all starts from the root so this

00:10:45,840 --> 00:10:54,120
principle is true for all syntax and

00:10:49,650 --> 00:10:55,860
languages and a tree doesn't need to

00:10:54,120 --> 00:10:58,920
look a certain way they can there can be

00:10:55,860 --> 00:11:02,520
many parsers so baby launch seven is

00:10:58,920 --> 00:11:04,080
what Babel used to use under the hood

00:11:02,520 --> 00:11:06,180
now they read

00:11:04,080 --> 00:11:08,040
they made it part of maples mono repo

00:11:06,180 --> 00:11:10,500
and it they call it just Babel parser

00:11:08,040 --> 00:11:11,690
but there are other parsers such as a

00:11:10,500 --> 00:11:16,230
corn esprima

00:11:11,690 --> 00:11:18,740
which played a very important role in in

00:11:16,230 --> 00:11:22,560
when it comes to parsers in JavaScript

00:11:18,740 --> 00:11:24,510
flow and typescript in utterly

00:11:22,560 --> 00:11:27,060
JavaScript there can be many languages

00:11:24,510 --> 00:11:29,610
there can be CSS graph QL HTML

00:11:27,060 --> 00:11:34,519
handlebars services these principles

00:11:29,610 --> 00:11:40,800
apply to all syntax and languages okay

00:11:34,519 --> 00:11:42,810
now how exactly does it look within a

00:11:40,800 --> 00:11:46,820
node.js application how exactly do I

00:11:42,810 --> 00:11:48,990
take code and parse it into an AST so

00:11:46,820 --> 00:11:50,820
because I'm here right now I can just

00:11:48,990 --> 00:11:53,070
say anything and you would believe me

00:11:50,820 --> 00:11:55,079
but I don't want that okay everything

00:11:53,070 --> 00:11:59,310
that I say I want to back it up with

00:11:55,079 --> 00:12:11,850
proofs so for that we will go to Babel

00:11:59,310 --> 00:12:14,370
documentation website okay okay and in

00:12:11,850 --> 00:12:18,990
the search bar there's a library called

00:12:14,370 --> 00:12:22,770
Babel parser I hope you can see that

00:12:18,990 --> 00:12:26,160
yeah and the API is fairly simple we

00:12:22,770 --> 00:12:28,560
just import the parse function and we

00:12:26,160 --> 00:12:31,110
provide it with a code string and the

00:12:28,560 --> 00:12:33,600
output should be an ast now it accepts

00:12:31,110 --> 00:12:36,029
all different kind of options but there

00:12:33,600 --> 00:12:37,470
there is I don't want to go through it

00:12:36,029 --> 00:12:40,560
because I want to keep things simple but

00:12:37,470 --> 00:12:41,760
however there is a specific option that

00:12:40,560 --> 00:12:48,740
would like to focus on this is the

00:12:41,760 --> 00:12:53,209
plugins option by default it will parse

00:12:48,740 --> 00:12:57,120
only a limited set of features of nodes

00:12:53,209 --> 00:13:00,060
but there are different nodes which are

00:12:57,120 --> 00:13:04,170
not officially part of ACMA script nodes

00:13:00,060 --> 00:13:06,300
which are in stage 0 1 2 or 3 so they

00:13:04,170 --> 00:13:09,620
won't be parsed by default and for that

00:13:06,300 --> 00:13:12,260
we need to say to the 3d parser

00:13:09,620 --> 00:13:14,100
explicitly that it needs to parse them

00:13:12,260 --> 00:13:16,680
so features that you're probably

00:13:14,100 --> 00:13:18,180
familiar with such as a single radar big

00:13:16,680 --> 00:13:20,130
in that we just stopped

00:13:18,180 --> 00:13:21,899
class property is quite private class

00:13:20,130 --> 00:13:25,440
properties and things that are quite

00:13:21,899 --> 00:13:28,980
frankly not even familiar with and we

00:13:25,440 --> 00:13:31,440
can also tell the parser to support no

00:13:28,980 --> 00:13:33,420
types of language extensions okay so

00:13:31,440 --> 00:13:34,740
like I mentioned earlier there are some

00:13:33,420 --> 00:13:38,660
features which are not part of any

00:13:34,740 --> 00:13:41,970
specification such as flow JSX

00:13:38,660 --> 00:13:43,800
so under the hood this is how it happens

00:13:41,970 --> 00:13:46,649
Babel officially supports it and also

00:13:43,800 --> 00:13:49,290
typescript that's interesting this is

00:13:46,649 --> 00:13:51,509
not what typescript uses typescript has

00:13:49,290 --> 00:13:54,360
a dedicated parser and compiler

00:13:51,509 --> 00:13:56,310
although babel also supports parsing

00:13:54,360 --> 00:14:01,110
types with limited features of of it

00:13:56,310 --> 00:14:05,089
it's still nice to have so now let's see

00:14:01,110 --> 00:14:05,089
a demonstration in a node.js application

00:14:09,350 --> 00:14:15,420
yeah so this is a very simple program

00:14:12,740 --> 00:14:20,160
what I have here I import the parse

00:14:15,420 --> 00:14:24,209
function and then I provide it with a

00:14:20,160 --> 00:14:26,459
code string and then I parse it and the

00:14:24,209 --> 00:14:28,439
output is an AST and what I do I print

00:14:26,459 --> 00:14:31,170
to the console a string if I'd version

00:14:28,439 --> 00:14:33,540
of the ast and the expected output

00:14:31,170 --> 00:14:37,319
should simply be an ast now I'll run the

00:14:33,540 --> 00:14:44,360
program right again this is an

00:14:37,319 --> 00:14:48,180
environment I'm not really used to okay

00:14:44,360 --> 00:14:51,180
so the output is is an ast this is just

00:14:48,180 --> 00:14:52,649
a JSON JSON that is described describes

00:14:51,180 --> 00:14:54,600
the code I'm not going to go through it

00:14:52,649 --> 00:14:57,449
because this is very boring but I think

00:14:54,600 --> 00:15:00,750
we got the principle once we saw because

00:14:57,449 --> 00:15:04,860
of what we saw in is DX for now the

00:15:00,750 --> 00:15:07,860
second stage once we have an ast we put

00:15:04,860 --> 00:15:11,490
it back into code this stage is called

00:15:07,860 --> 00:15:14,279
generating so I'll go to babbles

00:15:11,490 --> 00:15:21,269
documentation website again and we will

00:15:14,279 --> 00:15:24,000
look at the library called generator so

00:15:21,269 --> 00:15:27,300
again very simple API we simply accept

00:15:24,000 --> 00:15:30,809
an ast as the first argument the output

00:15:27,300 --> 00:15:31,740
should be code and again I would like to

00:15:30,809 --> 00:15:34,250
demonstrate that

00:15:31,740 --> 00:15:34,250
quickly

00:15:41,850 --> 00:15:50,670
okay good so in addition to what I did

00:15:47,040 --> 00:15:54,630
earlier now I have the generate function

00:15:50,670 --> 00:15:56,880
and once I import it I provided with the

00:15:54,630 --> 00:16:00,060
generated ast and I print it to the

00:15:56,880 --> 00:16:04,850
console and the output should be exactly

00:16:00,060 --> 00:16:04,850
the same and let's run the program again

00:16:05,870 --> 00:16:12,000
you see this is it's not exactly the

00:16:09,120 --> 00:16:13,260
same it's slightly different because

00:16:12,000 --> 00:16:14,970
there are semicolons white are

00:16:13,260 --> 00:16:15,990
semicolons because the ast doesn't

00:16:14,970 --> 00:16:19,050
contain information about these

00:16:15,990 --> 00:16:27,750
semicolons it simply puts the code back

00:16:19,050 --> 00:16:31,680
in the way it can and now I want to go

00:16:27,750 --> 00:16:33,480
back to the slides by the way you see

00:16:31,680 --> 00:16:35,280
that the output is exactly similar to

00:16:33,480 --> 00:16:38,040
the input now when we look at the

00:16:35,280 --> 00:16:40,410
traditional compiler the input and the

00:16:38,040 --> 00:16:42,330
output should be different okay when it

00:16:40,410 --> 00:16:43,950
when you look at C++ for example because

00:16:42,330 --> 00:16:47,160
the output is in native machine code but

00:16:43,950 --> 00:16:49,890
Babel is not exactly a compiler it's

00:16:47,160 --> 00:16:54,990
like a transformer or a transpiler and

00:16:49,890 --> 00:16:56,850
it works in a slightly different way but

00:16:54,990 --> 00:17:02,460
soon I'll talk about it and we'll see

00:16:56,850 --> 00:17:05,520
how from yes next it goes to es5 so back

00:17:02,460 --> 00:17:10,680
to the slides i would like to add

00:17:05,520 --> 00:17:12,530
another optional stage it comes between

00:17:10,680 --> 00:17:16,050
stage 1 and stage 2

00:17:12,530 --> 00:17:18,180
okay so stage 2 becomes stage 3 and why

00:17:16,050 --> 00:17:21,980
this is like I do it like that this is

00:17:18,180 --> 00:17:24,420
an optional stage because most compilers

00:17:21,980 --> 00:17:26,670
sorry a compiler doesn't necessarily

00:17:24,420 --> 00:17:30,000
need to have that stage in order to work

00:17:26,670 --> 00:17:33,690
properly but this is a very powerful

00:17:30,000 --> 00:17:37,050
stage because using that stage we can

00:17:33,690 --> 00:17:39,750
actually apply pre-processing to the

00:17:37,050 --> 00:17:42,380
code and run optimizations before we

00:17:39,750 --> 00:17:44,940
actually address the interpreter and

00:17:42,380 --> 00:17:46,980
this is by far the most complex stage

00:17:44,940 --> 00:17:49,260
because this is API specific there's a

00:17:46,980 --> 00:17:54,090
lot a lot of things to know about the

00:17:49,260 --> 00:17:56,630
API and we'll soon see why so going back

00:17:54,090 --> 00:17:56,630
to the code

00:17:56,810 --> 00:18:01,860
now let's say that I would like to

00:17:58,830 --> 00:18:04,470
transform the code with traditional

00:18:01,860 --> 00:18:08,400
methods using only regular expression

00:18:04,470 --> 00:18:12,690
this would be very complicated because a

00:18:08,400 --> 00:18:14,550
code can have scopes and maybe there's a

00:18:12,690 --> 00:18:16,620
a piece of code which is wrapped with

00:18:14,550 --> 00:18:19,920
brackets or something like that which

00:18:16,620 --> 00:18:23,580
makes the the transformation irrelevant

00:18:19,920 --> 00:18:26,460
this is why we have the ASD the ASD

00:18:23,580 --> 00:18:30,560
makes it easy on us to transform the

00:18:26,460 --> 00:18:35,370
code so let's say that I would like

00:18:30,560 --> 00:18:41,300
through transformation to change Const C

00:18:35,370 --> 00:18:45,480
into Const B so how do I do that

00:18:41,300 --> 00:18:48,720
what do I need to do is to address the

00:18:45,480 --> 00:18:52,050
right node with the right property and

00:18:48,720 --> 00:18:55,290
then change its value and once we put it

00:18:52,050 --> 00:18:56,790
back into a code stream because the code

00:18:55,290 --> 00:18:59,910
string the new code string is derived

00:18:56,790 --> 00:19:05,490
from the ast then we should have a

00:18:59,910 --> 00:19:07,530
transformed code so we copy that and we

00:19:05,490 --> 00:19:09,510
go to ast export this is how I actually

00:19:07,530 --> 00:19:16,830
work when I write Babel plugins oh I

00:19:09,510 --> 00:19:19,950
want to transform code and I paste it ok

00:19:16,830 --> 00:19:24,630
and then we see that it got updated on

00:19:19,950 --> 00:19:27,560
the right now what I do I highlight the

00:19:24,630 --> 00:19:30,360
code that I would like to transform and

00:19:27,560 --> 00:19:34,830
then the corresponding node is being

00:19:30,360 --> 00:19:36,840
highlighted on the right now what I do I

00:19:34,830 --> 00:19:38,430
need to look for the path that

00:19:36,840 --> 00:19:42,000
represents the node so I start from the

00:19:38,430 --> 00:19:44,960
root and I try I write down the path so

00:19:42,000 --> 00:19:49,290
it goes to program body position 0

00:19:44,960 --> 00:19:51,390
declarations position 0 ID name let's

00:19:49,290 --> 00:19:55,970
say that I wrote everything down in the

00:19:51,390 --> 00:19:55,970
text editor and I have it right here

00:19:59,520 --> 00:20:07,890
yes yeah so I changed the ASD I changed

00:20:05,850 --> 00:20:10,200
the value C to B and therefore once I

00:20:07,890 --> 00:20:17,570
put it back into code the expected

00:20:10,200 --> 00:20:22,410
output should be the following you see

00:20:17,570 --> 00:20:25,110
so I changed the code now there's a

00:20:22,410 --> 00:20:28,230
problem with that approach because what

00:20:25,110 --> 00:20:30,120
I did right now is to specific I want to

00:20:28,230 --> 00:20:33,150
have like some sort of a generic pattern

00:20:30,120 --> 00:20:35,660
that I can apply and it will be true for

00:20:33,150 --> 00:20:37,980
any code string that I get as an input

00:20:35,660 --> 00:20:42,270
something like regular expression okay

00:20:37,980 --> 00:20:42,840
because a code can wear many shapes and

00:20:42,270 --> 00:20:46,440
forms

00:20:42,840 --> 00:20:49,230
this is way too specific so there's a

00:20:46,440 --> 00:20:51,900
problem with that approach many

00:20:49,230 --> 00:20:54,350
compilers they implement a mechanism and

00:20:51,900 --> 00:20:59,520
they provided provide us with an API

00:20:54,350 --> 00:21:06,530
which lets us transform the code in a

00:20:59,520 --> 00:21:09,960
more generic way okay so using that API

00:21:06,530 --> 00:21:12,360
what we do we basically walk through the

00:21:09,960 --> 00:21:14,250
ast through each and every node in the

00:21:12,360 --> 00:21:16,110
ast you can call it walk or run or

00:21:14,250 --> 00:21:18,960
traverse essentially these verbs they

00:21:16,110 --> 00:21:21,720
all represent the same thing and then we

00:21:18,960 --> 00:21:24,240
apply transformation callbacks for each

00:21:21,720 --> 00:21:26,430
and every node individually so if we

00:21:24,240 --> 00:21:28,980
look at the ASD and we'll try to

00:21:26,430 --> 00:21:31,830
demonstrate it what it does it goes - it

00:21:28,980 --> 00:21:34,980
starts with the root it goes through the

00:21:31,830 --> 00:21:37,770
the the root node it goes deeper to

00:21:34,980 --> 00:21:39,900
program variable declaration and then

00:21:37,770 --> 00:21:41,610
once it sees a transformation callback

00:21:39,900 --> 00:21:43,530
then it goes to the callback applies the

00:21:41,610 --> 00:21:47,490
logic and then it keeps walking through

00:21:43,530 --> 00:21:50,640
the tree if we look at babel labels

00:21:47,490 --> 00:21:53,960
documentation website there's a library

00:21:50,640 --> 00:21:53,960
called babel Traverse

00:21:57,389 --> 00:22:03,779
and Traverse does exactly what I said

00:22:00,169 --> 00:22:07,559
it's the first argument it accepts an

00:22:03,779 --> 00:22:10,139
ASD as the second argument it accepts an

00:22:07,559 --> 00:22:13,589
object which is called a visitor because

00:22:10,139 --> 00:22:16,950
this object visits the ASD as we walk

00:22:13,589 --> 00:22:20,309
through it and this object contains

00:22:16,950 --> 00:22:24,239
callbacks the names of the callbacks

00:22:20,309 --> 00:22:27,779
represents the nodes that is it is going

00:22:24,239 --> 00:22:30,299
to transform and as the first argument

00:22:27,779 --> 00:22:33,899
it accepts an object that contains the

00:22:30,299 --> 00:22:36,299
node and then we can actually do all our

00:22:33,899 --> 00:22:37,679
changes on the node that we would like

00:22:36,299 --> 00:22:41,159
to transform and we can also apply

00:22:37,679 --> 00:22:43,259
conditions and logic to it it also

00:22:41,159 --> 00:22:44,639
accepts more arguments I don't want to

00:22:43,259 --> 00:22:47,039
get into that because I want to keep

00:22:44,639 --> 00:22:49,979
things very simple once you understand

00:22:47,039 --> 00:22:52,320
the core it's very easy to get deeper

00:22:49,979 --> 00:22:56,459
and and investigate more about the

00:22:52,320 --> 00:22:59,479
subject so let me show you another

00:22:56,459 --> 00:22:59,479
demonstration of that

00:23:08,440 --> 00:23:15,290
so in addition to what I had earlier now

00:23:12,590 --> 00:23:19,070
I use the Traverse function to traverse

00:23:15,290 --> 00:23:24,140
to the ast and I apply transformation

00:23:19,070 --> 00:23:31,820
callbacks so if I have that input what I

00:23:24,140 --> 00:23:34,250
would like to have whoop the expected

00:23:31,820 --> 00:23:37,280
output should be something like that so

00:23:34,250 --> 00:23:40,180
let's say that I change all the variable

00:23:37,280 --> 00:23:44,780
assignments from whatever this is to be

00:23:40,180 --> 00:23:51,230
everything should be B and the values

00:23:44,780 --> 00:23:54,230
should all change to two an FN should

00:23:51,230 --> 00:23:59,410
change to F and two so this is the

00:23:54,230 --> 00:24:03,710
expected output so how do I do that I

00:23:59,410 --> 00:24:07,100
use the right callback names with the

00:24:03,710 --> 00:24:09,880
right visitor and then I change the

00:24:07,100 --> 00:24:12,500
corresponding nodes again how do I know

00:24:09,880 --> 00:24:13,580
how does the API looks like and what

00:24:12,500 --> 00:24:19,510
notes to address

00:24:13,580 --> 00:24:23,660
I go to ASD Explorer and then I

00:24:19,510 --> 00:24:24,980
highlight the code the the parts of the

00:24:23,660 --> 00:24:26,870
code that I would actually like to

00:24:24,980 --> 00:24:30,050
transform and then I look at the node I

00:24:26,870 --> 00:24:31,730
see what is the name of the node and I

00:24:30,050 --> 00:24:34,250
see how the signature of the nodes of

00:24:31,730 --> 00:24:40,910
the node looks like and this is how I

00:24:34,250 --> 00:24:44,260
know how the API looks like now if I

00:24:40,910 --> 00:24:48,640
will run the code the output should be

00:24:44,260 --> 00:24:48,640
what I just wrote over there

00:24:54,750 --> 00:25:01,030
you see and just to prove it to you that

00:24:59,050 --> 00:25:03,610
this is a general pattern and it's not

00:25:01,030 --> 00:25:06,210
just specific to that code I can add

00:25:03,610 --> 00:25:10,210
another variable assignment over here

00:25:06,210 --> 00:25:25,600
and this should change to be equals to

00:25:10,210 --> 00:25:30,550
as well right this is nice now this is

00:25:25,600 --> 00:25:34,450
how we transform code so the visitor

00:25:30,550 --> 00:25:36,850
over here this is what a Babel plugin is

00:25:34,450 --> 00:25:39,400
all about a plug-in is just a visitor

00:25:36,850 --> 00:25:42,760
okay Babel wanted to make it easy on us

00:25:39,400 --> 00:25:46,480
and they wanted to give us a way to

00:25:42,760 --> 00:25:48,970
implement custom features using plugins

00:25:46,480 --> 00:25:51,360
and so in order to do that what we need

00:25:48,970 --> 00:25:54,010
to do is simply to write a visitor and

00:25:51,360 --> 00:25:56,260
what we do we specify it in the Babel

00:25:54,010 --> 00:25:58,090
r/c then it looks for the the right name

00:25:56,260 --> 00:26:00,910
in the non modules and then it applies

00:25:58,090 --> 00:26:04,240
the visitor once it walks to the ast

00:26:00,910 --> 00:26:11,140
before it actually compiles it now let's

00:26:04,240 --> 00:26:14,260
see an example plug-in so what I have

00:26:11,140 --> 00:26:16,150
here is a program which the input is

00:26:14,260 --> 00:26:18,040
exactly the same as we had earlier and

00:26:16,150 --> 00:26:20,050
the plug-in is exactly what we had

00:26:18,040 --> 00:26:22,180
earlier again a plug-in is a visitor it

00:26:20,050 --> 00:26:25,720
accepts more options that will make it

00:26:22,180 --> 00:26:27,540
easy on us to transform the code but

00:26:25,720 --> 00:26:30,760
again I want to keep things very simple

00:26:27,540 --> 00:26:33,130
because the visitor is the same and the

00:26:30,760 --> 00:26:35,890
input is the same therefore the output

00:26:33,130 --> 00:26:39,210
should be exactly the same as well so

00:26:35,890 --> 00:26:39,210
I'm going to run the program again and

00:26:43,680 --> 00:26:56,850
the output is exactly the same now how

00:26:51,070 --> 00:26:59,230
exactly from that do we reach yes five

00:26:56,850 --> 00:27:06,610
okay because so far it just it looks

00:26:59,230 --> 00:27:11,200
like it remains to be is next so

00:27:06,610 --> 00:27:15,190
yes five is simply a set of plugins that

00:27:11,200 --> 00:27:19,419
transforms the code in a way that it

00:27:15,190 --> 00:27:22,720
will from east next it will turn into es

00:27:19,419 --> 00:27:25,659
five a set of plugins is also called a

00:27:22,720 --> 00:27:31,090
preset this is what a preset is a preset

00:27:25,659 --> 00:27:35,440
is simply a set of plugins so in order

00:27:31,090 --> 00:27:39,279
to transform to es 5 what we do we load

00:27:35,440 --> 00:27:44,320
a set of plugins using the Babel E&V

00:27:39,279 --> 00:27:46,779
preset the env env preset what it does

00:27:44,320 --> 00:27:48,429
it applies plugins based on the

00:27:46,779 --> 00:27:50,760
environment that we would like to

00:27:48,429 --> 00:27:56,309
transform to okay how does it know that

00:27:50,760 --> 00:27:59,970
based on what's written on package.json

00:27:56,309 --> 00:28:02,110
now I'm gonna apply this plug-in and

00:27:59,970 --> 00:28:08,289
you'll see that we'll be transformed to

00:28:02,110 --> 00:28:13,200
years five and let's make the input a

00:28:08,289 --> 00:28:13,200
little bit more yes next

00:28:20,330 --> 00:28:34,859
and we'll run the demo again and the

00:28:31,049 --> 00:28:37,229
output is the s5 as you can see does so

00:28:34,859 --> 00:28:40,470
this is how Babel works okay this is how

00:28:37,229 --> 00:28:43,830
it works now what's the point of it okay

00:28:40,470 --> 00:28:45,179
why is it such a powerful tool because

00:28:43,830 --> 00:28:47,970
using that knowledge you can write

00:28:45,179 --> 00:28:51,570
plugins yourself and enhance the user

00:28:47,970 --> 00:28:54,019
experience as a programmer so I'll give

00:28:51,570 --> 00:28:56,549
you example plugins that I wrote myself

00:28:54,019 --> 00:28:58,409
you don't necessarily have to agree with

00:28:56,549 --> 00:29:00,450
what they do maybe you don't like their

00:28:58,409 --> 00:29:02,249
functionality but again just understand

00:29:00,450 --> 00:29:04,549
the power behind that sort of

00:29:02,249 --> 00:29:04,549
information

00:29:06,590 --> 00:29:13,019
okay so first plug-in is a plug-in for

00:29:10,320 --> 00:29:17,389
if you're familiar with the new react

00:29:13,019 --> 00:29:20,220
hooks API in what I do I transform data

00:29:17,389 --> 00:29:21,989
okay and the problem is that once I

00:29:20,220 --> 00:29:25,639
enter the rendering phase each and every

00:29:21,989 --> 00:29:29,700
time I would need to apply that logic or

00:29:25,639 --> 00:29:32,009
here if I have anonymous call back each

00:29:29,700 --> 00:29:33,539
time and enter the rendering phase I

00:29:32,009 --> 00:29:36,419
would need to initialize that callback

00:29:33,539 --> 00:29:39,599
so what I need to do is to cache the

00:29:36,419 --> 00:29:43,169
result using your use call back or use

00:29:39,599 --> 00:29:47,099
me-mow so with that plug-in you can

00:29:43,169 --> 00:29:49,080
automatically apply use mimo with the

00:29:47,099 --> 00:29:52,109
right arguments you just type it

00:29:49,080 --> 00:29:53,909
normally as you would and then it

00:29:52,109 --> 00:29:57,389
optimizes the code for you ahead of time

00:29:53,909 --> 00:30:01,349
or it also does things like creating

00:29:57,389 --> 00:30:04,049
anonymous components where it caches the

00:30:01,349 --> 00:30:06,899
callback results and you don't need to

00:30:04,049 --> 00:30:11,489
put used callback and therefore save

00:30:06,899 --> 00:30:12,749
some errors second and final plug-in

00:30:11,489 --> 00:30:14,940
that I wrote something for style

00:30:12,749 --> 00:30:17,340
components rather than creating a

00:30:14,940 --> 00:30:19,470
dedicated component per each component

00:30:17,340 --> 00:30:24,090
that you would like to encapsulate its

00:30:19,470 --> 00:30:27,149
style you can use the single stylesheet

00:30:24,090 --> 00:30:30,320
component and use underscore to

00:30:27,149 --> 00:30:32,000
encapsulate private class names

00:30:30,320 --> 00:30:34,639
and what the plugin will do it will

00:30:32,000 --> 00:30:43,519
prefix it automatically therefore

00:30:34,639 --> 00:30:44,480
encapsulate the styles so that was

00:30:43,519 --> 00:30:47,330
basically it

00:30:44,480 --> 00:30:49,029
I hope you liked it there isn't much

00:30:47,330 --> 00:30:52,340
information about it online

00:30:49,029 --> 00:30:54,769
documentation is very very poor but I

00:30:52,340 --> 00:30:56,710
did write few articles about it and I'm

00:30:54,769 --> 00:31:00,799
also gonna upload a video about it and

00:30:56,710 --> 00:31:03,289
also be sure to use se explore and babel

00:31:00,799 --> 00:31:06,200
dogs if you have any further questions

00:31:03,289 --> 00:31:09,879
feel free to address me later on in the

00:31:06,200 --> 00:31:09,879

YouTube URL: https://www.youtube.com/watch?v=B1IUxzOdmyc


