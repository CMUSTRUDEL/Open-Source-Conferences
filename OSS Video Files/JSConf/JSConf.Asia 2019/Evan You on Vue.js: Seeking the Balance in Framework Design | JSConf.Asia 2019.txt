Title: Evan You on Vue.js: Seeking the Balance in Framework Design | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	As the author of Vue, I often get asked on how the major JavaScript frameworks today differ from one another. Typically people expect technical details: size, performance, ecosystem... but to me, what fundamentally differentiates frameworks from one another is where a framework lands on the primitives vs. conventions spectrum. This is usually a conscious design decision, and the major frameworks we see today manifests three different segments of this spectrum. In this talk I'll discuss how these design choices have affected the adoption and growth of these frameworks, and why there might not be one single optimal balance point.

Evan is an independent open source developer. He created Vue.js, a popular frontend framework and now works on it full-time. Before going full-time open source, Evan worked as a core dev at Meteor, and before that as a creative technologist at Google Creative Lab.
              


JSConf.Asia - LASALLE College of the Arts, Singapore - 15 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:16,590 --> 00:00:17,280
Hi, everyone.

00:00:18,180 --> 00:00:19,320
It's really nice to be here.

00:00:20,400 --> 00:00:21,840
How's it - How's your day been goin'?

00:00:22,710 --> 00:00:23,820
Great. Okay.

00:00:24,030 --> 00:00:29,700
So hopefully this one is not too boring to be, you know, a talk at this time of the day

00:00:29,700 --> 00:00:32,970
because I'm pretty sure you have seen a lot of talks already.

00:00:33,000 --> 00:00:38,370
But just briefly introducing myself for those who don't know me.

00:00:38,520 --> 00:00:39,630
My name is Evan You.

00:00:40,290 --> 00:00:44,070
My Twitter handle is @youyuxi, which is my Chinese name.

00:00:44,580 --> 00:00:49,680
I am an independent open source developer since 2016, so

00:00:51,720 --> 00:00:56,700
that is to say, I've been working just on open source independently for three years now.

00:00:57,330 --> 00:00:59,820
And I work primarily on Vue.js.

00:01:00,690 --> 00:01:02,430
How many of you actually use it?

00:01:05,040 --> 00:01:05,790
Alright, great.

00:01:06,240 --> 00:01:12,930
So it started as a side project in 2013 and I've been working on it full time since 2016.

00:01:13,410 --> 00:01:19,260
And over the years of working on frameworks, right, I've learned a lot of stuff.

00:01:20,310 --> 00:01:31,590
And that kind of also gives me a lot of perspective on the internal design, some of the trade-offs, decisions that people make when it comes to building frameworks, right?

00:01:32,710 --> 00:01:35,770
How many of you remember the days back in like 2013,

00:01:35,770 --> 00:01:39,820
when there's probably a new JavaScript framework coming out every single day?

00:01:40,750 --> 00:01:46,810
ToDoMVC has a list of like 40-50 frameworks, all building the same thing?

00:01:47,230 --> 00:01:54,220
And Vue kind of started around that time where I was just looking at some of these existing solutions and trying to figure out,

00:01:54,910 --> 00:01:59,320
what would I do if I were to build something like this?

00:01:59,770 --> 00:02:05,350
Okay, but obviously, my ideas around what should be done has evolved over time and changed a lot.

00:02:05,350 --> 00:02:12,880
But today, I'm going to be talking about some of these findings, specifically, front end framework design.

00:02:15,460 --> 00:02:22,000
I bet a lot of you have been using a framework, even if you're not using Vue, you probably use React, Angular or some other framework.

00:02:22,540 --> 00:02:28,960
It's hard to imagine building a complex front end application without something of that sort today, right?

00:02:29,590 --> 00:02:35,350
You can probably still build things with vanilla JavaScript, but we know it's going to take a bit more time.

00:02:36,370 --> 00:02:39,310
However, at the same time, like because of all these frameworks,

00:02:39,310 --> 00:02:44,800
I guess most of you are also kind of tired of all these framework comparisons, right?

00:02:45,160 --> 00:02:50,650
This is how I look like whenever I see yet another framework comparison article pop up on Medium,

00:02:50,950 --> 00:02:55,150
like "The best seven new frameworks to using 2019".

00:02:55,600 --> 00:02:56,680
I just like "ew".

00:02:58,870 --> 00:03:02,980
Not because, you know, not because I built Vue, and I want people to use it,

00:03:03,010 --> 00:03:05,530
or I don't want to see people hating on it, right?

00:03:05,680 --> 00:03:11,830
But because most of the time, these articles just focus on things like GitHub stars,

00:03:11,820 --> 00:03:13,080
or NPM download counts,

00:03:13,060 --> 00:03:14,380
or Stack Overflow questions,

00:03:14,740 --> 00:03:19,390
these stats that you can just easily find anywhere, anybody can just google them up, right.

00:03:19,390 --> 00:03:27,160
But these stats, while still kind of useful to a certain extent, maybe for marketers, right.

00:03:27,670 --> 00:03:29,800
But if you're trying to make a technical decision,

00:03:30,010 --> 00:03:33,640
and you're trying to compete some of these relatively mature technologies,

00:03:33,870 --> 00:03:37,860
these numbers are less and less relevant above a certain threshold, right?

00:03:38,740 --> 00:03:45,550
Like most of these, you know, what we use in production today probably have over 10,000 stars on GitHub, right.

00:03:45,580 --> 00:03:52,090
Above that threshold, like, really? Does it really matter how many stars, like, several thousand stars this library has got?

00:03:52,990 --> 00:03:54,400
It doesn't really matter that much.

00:03:54,400 --> 00:04:02,590
What you should probably care more about is some of the internal technical decisions, like what actually differs these frameworks.

00:04:03,700 --> 00:04:11,050
So before we dig into that, take a step back and think about all the common goals of these frameworks.

00:04:11,080 --> 00:04:13,660
We all are working towards the same goal -

00:04:13,690 --> 00:04:20,020
all these framework authors are trying to provide you with something that helps you to build web apps as efficiently as possible,

00:04:20,170 --> 00:04:23,230
then why do we have all these different competing ideas?

00:04:23,830 --> 00:04:26,290
And is it a good thing or is it a bad thing? Right?

00:04:26,320 --> 00:04:32,080
So why do we have so many different frameworks, each with a decent sizable following, right?

00:04:32,290 --> 00:04:38,920
Because I believe, like, React Angular Vue, each have more than half a million users.

00:04:39,280 --> 00:04:41,380
So why is that?

00:04:41,950 --> 00:04:49,750
I think the source, the reason is that there isn't a single good versus bad spectrum for frameworks, right?

00:04:49,750 --> 00:04:54,910
People tend to ask questions like, which framework is better?

00:04:55,350 --> 00:05:02,370
Just stop asking that. Because it's not that simple to say framework A is better than framework B.

00:05:03,420 --> 00:05:08,280
We know that software design is about trade offs. So are front end framework design.

00:05:08,490 --> 00:05:13,380
There's so many trade offs, in fact, especially in the web world, right,

00:05:13,410 --> 00:05:18,030
because the web is the platform with probably the most diverse set of use cases.

00:05:18,390 --> 00:05:25,830
We build all kinds of crazy stuff on the web, from the simplest page possible to the most complex application you use every day.

00:05:26,940 --> 00:05:34,380
So to accommodate all these use cases, frameworks have to make trade offs not just on a single spectrum.

00:05:34,860 --> 00:05:40,200
We have to make trade offs on multiple spectrums, a lot of different areas. So -

00:05:41,520 --> 00:05:51,150
And today, I'm going to be talking about some of these, hopefully, giving you some insight on what to look at,

00:05:51,150 --> 00:05:56,340
but due to the time constraints I won't be able to dig in to all of these possible dimensions.

00:05:56,610 --> 00:05:59,880
So I'll focus on a few of them - scope.

00:06:00,120 --> 00:06:03,600
So this is essentially how much the framework is trying to do for you.

00:06:04,410 --> 00:06:07,800
And then the render mechanism -

00:06:07,830 --> 00:06:15,330
when you use the framework, how do you express your view structure? And how does the framework handle your code? How does it actually render stuff to the page?

00:06:16,170 --> 00:06:25,440
And then there's the state mechanism - mutable versus immutable, dirty checking versus dependency tracking, reactivity versus simulated reactivity.

00:06:26,460 --> 00:06:30,600
Actually, I won't have time to dig into this one, maybe this will be another talk at a later time.

00:06:30,960 --> 00:06:37,170
So I'll go right into scope - how much a framework is trying to do for you.

00:06:39,030 --> 00:06:49,410
So let's put it on a spectrum and you'll have one end where the framework, or the library, is doing intentionally smaller things

00:06:49,680 --> 00:06:58,440
where on the other end, we have more monolithic things, like frameworks that try to provide as many features as possible.

00:06:58,620 --> 00:06:59,130
Excuse me.

00:07:00,270 --> 00:07:04,590
So some of the iconic examples, probably most people know about, right?

00:07:04,620 --> 00:07:10,080
React kind of nicely falls onto the end of libraries, primitives.

00:07:10,350 --> 00:07:15,210
And Angular falls on the side of frameworks providing you with a lot of abstractions, right?

00:07:15,390 --> 00:07:23,670
So React exemplifies the philosophy where the library is focused on providing a very fundamental model for thinking about UI.

00:07:23,940 --> 00:07:31,230
It tries to focus on providing you with these lower level good primitives on which you can build your own abstractions with.

00:07:31,920 --> 00:07:34,170
The scope is intentionally small.

00:07:34,440 --> 00:07:39,990
So that's why also why React has a very, very active ecosystem, right.

00:07:39,990 --> 00:07:51,180
So along with the ecosystem, React is like the bazaar where the system is sort of organically built bottom up by the community around the core model that React has established.

00:07:52,200 --> 00:07:59,970
On the other end, so Angular and alongside to some of the other frameworks like Ember, Aurelia are more like the cathedral, right.

00:08:00,000 --> 00:08:10,380
They're designed top down, where most of the conceivable problems that the users will probably run into has been sort of considered during the design process -

00:08:10,410 --> 00:08:18,690
form validation, animations - most of the common things you will encounter during the daily development, the framework tries to provide a solution for you.

00:08:19,650 --> 00:08:24,810
And in order to do that, the framework has to be designed in a way that is very top down,

00:08:25,140 --> 00:08:30,780
we have to think about everything how everything works together, fits together, from day one, right.

00:08:32,580 --> 00:08:41,670
And this, this scope is intentionally big, because the goal of such a design is so that when you are trying to solve a problem,

00:08:41,670 --> 00:08:44,760
you will be able to find the solution within the framework.

00:08:46,170 --> 00:08:53,310
Now, we call this small scope versus big scope and it's not necessarily about good or bad.

00:08:53,370 --> 00:08:55,230
Again, I want to emphasize that.

00:08:55,260 --> 00:09:05,100
So some pros of the small scope is, there are fewer concepts to get started with and there's more flexibility.

00:09:05,360 --> 00:09:12,440
So there's more userland opportunities, right, because the framework, the library is only providing with some really low level primitives.

00:09:13,160 --> 00:09:19,040
So you have a component model, you have some props, you can pass props to it, and then you can return some virtual DOM tree.

00:09:19,420 --> 00:09:22,600
That's pretty much it. That's pretty much it about React, right.

00:09:22,840 --> 00:09:25,780
But on top of that, you can build arbitrary complex systems.

00:09:26,620 --> 00:09:30,280
So React has a very, very active ecosystem.

00:09:30,340 --> 00:09:36,790
People see that they have these very flexible tools and, you know, they just run wild with their creativity.

00:09:36,790 --> 00:09:41,440
So there are a lot of great ideas coming out of the React community.

00:09:42,670 --> 00:09:51,190
And in addition, being intentionally small in scope, also allows the team to have a smaller maintenance surface

00:09:51,220 --> 00:09:54,850
so that they can focus on the things that they believe that matters, right.

00:09:54,850 --> 00:10:01,630
So the team can focus on exploring new ideas, which is why react can spend such a long time working on things like

00:10:02,110 --> 00:10:10,810
concurrent mode, suspense, React hooks, and all these interesting stuff they've been cranking out in the past few weeks or months.

00:10:11,500 --> 00:10:14,560
Right, they've actually been working on it for a few years already so.

00:10:15,520 --> 00:10:20,350
But this is because, you know, they have a small scope, so they can focus on these things.

00:10:21,520 --> 00:10:25,180
So there are some cons of small scope, obviously.

00:10:25,330 --> 00:10:31,510
So first is there's more plumbing work needed when solving inherently complex problems with simple concepts.

00:10:31,780 --> 00:10:38,110
So there was a talk that I really liked, by Guy Steele, called "Growing a Language".

00:10:38,140 --> 00:10:47,020
So during the talk, Guy set himself a rule so during that talk, he can only use single syllable words.

00:10:47,050 --> 00:10:53,440
And if you want to use any words that has more than one syllables, he has to define it first with single syllable words.

00:10:54,070 --> 00:11:02,320
So he is given a very limited list of primitive stuff to to be able to construct more complex ideas with.

00:11:02,620 --> 00:11:04,960
So you can imagine how that talk went, right?

00:11:05,560 --> 00:11:10,840
Before he speaks every sentence, he has to like, take out a few slides and define a bunch of words before he can proceed.

00:11:11,140 --> 00:11:18,070
And that's kind of like building a really complex production grade app with very, very low level primitives -

00:11:18,250 --> 00:11:23,560
you have to build a lot of abstract abstractions, to make yourself more efficient along the way.

00:11:24,670 --> 00:11:28,900
Now, because of that, patterns naturally emerge over time, right?

00:11:30,010 --> 00:11:32,800
When we say React is really simple to get started with,

00:11:32,950 --> 00:11:40,090
we're kind of ignoring the fact that you sort of more or less have to learn Redux before you can consider yourself a real React developer.

00:11:40,390 --> 00:11:46,480
And then you have to know about things like higher order components, or prod - render props,

00:11:46,480 --> 00:11:53,170
and then now you have to learn hooks, and the many different ways of using CSS in JS, right.

00:11:53,170 --> 00:11:58,900
So all of these patterns emerge over time, and they kind of become semi required, right?

00:11:58,930 --> 00:12:03,070
If you don't know about these, you really can't call yourself a React developer.

00:12:04,120 --> 00:12:07,060
And oftentimes, these things are not officially documented.

00:12:07,000 --> 00:12:11,260
If you go to the React website, they're not going to tell you which CSS JS solution to use.

00:12:11,260 --> 00:12:13,840
You have to do your own research and learn it.

00:12:14,680 --> 00:12:22,120
So that's kind of the cons of having a really, really, you know, userland dominated system.

00:12:22,870 --> 00:12:28,360
Now, the ecosystem can be moving too fast, and can lead to fragmentation and constant churn.

00:12:29,440 --> 00:12:37,180
And I believe anyone who's been following along in the early days of the flux, sort of, every day there's a new flux implementation,

00:12:37,180 --> 00:12:41,080
and then later on, everyday there's a new CSS JS implementation, right?

00:12:41,890 --> 00:12:44,770
It's good and bad at the same time.

00:12:45,580 --> 00:12:48,790
The good is there are always these new ideas coming out,

00:12:48,790 --> 00:12:52,150
and we're trying to figure out what is actually the best way to do it.

00:12:52,180 --> 00:12:56,260
The bad thing is, for people who are just trying to follow along and get something built,

00:12:57,280 --> 00:13:02,950
you have this constant FOMO, right, you're always in fear of missing out on the next best thing.

00:13:03,910 --> 00:13:11,740
So we're done with the small scope, cons, and let's talk about the pros of being large in scope.

00:13:13,510 --> 00:13:19,000
The most obvious advantage is most common problems can be solved with building abstractions.

00:13:19,150 --> 00:13:25,060
So if you're just trying to get something built, I just need a router, I need some animation,

00:13:25,000 --> 00:13:28,000
I need to fetch some data with an HTTP client...

00:13:28,660 --> 00:13:32,470
A framework like Angular provides everything you need to get that out of the door.

00:13:33,760 --> 00:13:35,920
So you don't actually have to look elsewhere.

00:13:35,920 --> 00:13:39,820
Just read the documentation, use the framework, and you can get things done.

00:13:40,930 --> 00:13:45,040
Centralized design process ensures consistent and coherent ecosystem, right.

00:13:45,040 --> 00:13:52,120
So you don't have to shop for different solutions when you're running into a specific problem.

00:13:52,480 --> 00:13:55,660
You just look at the framework, see what the framework tells you to do, right?

00:13:55,660 --> 00:13:58,060
Most likely, it has an opinion on it.

00:13:58,240 --> 00:14:07,000
So you don't have to go dig into 10 different competing solutions and figure out which one fits your use case best.

00:14:08,020 --> 00:14:12,340
Now, the cons of being large in scope is there is a higher upfront learning barrier.

00:14:13,030 --> 00:14:19,780
In order to get the pixel onto the screen, the hoops you have to jump through to get there.

00:14:20,470 --> 00:14:25,450
This can be a big deterrent for beginners, for people without proper, or

00:14:25,480 --> 00:14:32,290
I wouldn't say proper - people without prior experience in dealing with back end languages.

00:14:32,320 --> 00:14:37,000
Like if you've never used Java or C#, you've only learned HTML, CSS and JavaScript,

00:14:37,390 --> 00:14:43,750
reading the Angular documentation is probably a pretty humbling experience, I would say.

00:14:45,190 --> 00:14:46,270
It is still for me.

00:14:47,470 --> 00:14:51,700
Now, it can be inflexible if built in solution doesn't fit the use case, right?

00:14:52,000 --> 00:14:55,990
Sometimes you might just feel like, I wish I could do it the other way but

00:14:56,020 --> 00:14:58,000
I don't have the option to swap it out.

00:14:59,290 --> 00:15:07,000
And finally, a framework that is large in scope inherently makes introducing fundamental new ideas much more costly,

00:15:07,000 --> 00:15:12,550
because there are so many associated pieces that need to work consistently together.

00:15:12,910 --> 00:15:15,640
And when you try to change a fundamental idea,

00:15:15,730 --> 00:15:18,280
it affects every component in your system.

00:15:18,520 --> 00:15:21,760
So making changes is just a much harder thing.

00:15:21,970 --> 00:15:26,650
Whereas if you think about in the React ecosystem,

00:15:27,170 --> 00:15:31,640
because the core team is not really responsible for a lot of these solutions in the wild.

00:15:32,220 --> 00:15:40,530
When you, say, introduce hooks, which made Redux more or less redundant, it's not eally a problem.

00:15:40,520 --> 00:15:41,630
So there's that.

00:15:42,710 --> 00:15:45,920
OK, so now this is where Vue kind of falls on.

00:15:45,920 --> 00:15:53,390
But before we dig into what Vue is doing, I want to emphasize like this is not about like how Vue is better than both of these, right?

00:15:53,420 --> 00:15:58,190
Because being in the middle doesn't necessarily indicate it's the best.

00:15:58,480 --> 00:16:03,310
If you stretch this spectrum long enough, you zoom out long enough,

00:16:03,310 --> 00:16:07,630
you'll see like, they are actually all kind of in the optimal zone already.

00:16:07,840 --> 00:16:12,730
So it's just like we slightly differ on where we think the optimal point is.

00:16:12,970 --> 00:16:18,550
So each choice also kind of fits the needs of different groups of users, right?

00:16:18,580 --> 00:16:21,220
It's not like one thing that can fit all.

00:16:22,180 --> 00:16:28,270
So what I call the way Vue takes on the scope problem is,

00:16:29,320 --> 00:16:34,660
you probably know the tagline Vue is called - we call Vue the progressive framework.

00:16:34,810 --> 00:16:43,840
So being progressive in scope means framework uses a layer design that allows features to be opted in, in a progressive manner.

00:16:44,380 --> 00:16:50,590
That is to say, if you don't need routing, if you don't need state management, if you don't need a built step, even,

00:16:50,930 --> 00:16:53,150
you can use Vue without any of those.

00:16:53,180 --> 00:16:57,650
You just pull in Vue.JS onto your page, and you can instantly start working on something.

00:16:58,700 --> 00:17:03,620
The learning barrier of jumping from beginner to getting a pixel on the screen

00:17:04,100 --> 00:17:11,630
is shortened by removing anything that could be in your way in your first minute of learning.

00:17:12,680 --> 00:17:17,240
So this is - the low entry learning barrier is really important for us because

00:17:17,780 --> 00:17:22,100
one of the missions of Vue is to allow more people to get into web development,

00:17:22,130 --> 00:17:29,510
to allow people to learn this and to focus on building things instead of

00:17:29,510 --> 00:17:35,480
learning about a lot of concepts that might not be necessary for your current use case.

00:17:38,030 --> 00:17:45,500
But we still have documented solutions for these common problems, like as your use case gets more complicated,

00:17:45,500 --> 00:17:47,510
as you're building something more complex,

00:17:48,290 --> 00:17:50,870
you realize, okay, I do need a router.

00:17:51,080 --> 00:17:55,910
So you're looking to the documentation, you see, okay, Vue actually does provide a router, which I can use.

00:17:56,810 --> 00:18:02,780
But at the same time, the router is not a required piece and you can actually implement your own if you want to,

00:18:02,780 --> 00:18:09,380
because you see how Vue's router is built and it is cleanly decoupled from the core implementation,

00:18:09,380 --> 00:18:13,640
so you kind of realize that you can build your own solution too, if you want to.

00:18:13,790 --> 00:18:23,780
So it's not perfect, because we being in the middle actually means we are sharing the cons of both sides.

00:18:23,870 --> 00:18:31,730
So first, although we are making the adoption incremental, we are still responsible for maintaining all these things.

00:18:32,210 --> 00:18:35,540
So we share the same maintenance surface problem of big scope -

00:18:35,750 --> 00:18:40,460
when we want to change something fundamentally, we have to make sure the whole ecosystem moves along with it,

00:18:40,700 --> 00:18:43,970
so this maintenance burden is almost the same with big scope.

00:18:43,000 --> 00:18:50,470
And at the same time, because we do provide these pre built solutions,

00:18:51,070 --> 00:18:56,980
our ecosystem probably will be not as diverse as, say, React, the small scope system,

00:18:56,980 --> 00:19:01,360
because small scope is inherently like leaving the problem to the community

00:19:01,570 --> 00:19:09,010
whereas in our case, a lot of users will be happy with our solutions and they probably won't spend time on trying to figure out their own solutions.

00:19:10,030 --> 00:19:13,690
So that is the scope problem.

00:19:13,690 --> 00:19:17,920
So hopefully, you can kind of, you now have an idea of where sort of -

00:19:18,310 --> 00:19:24,250
this is what I think is the most fundamental difference between React, Vue and Angular.

00:19:25,690 --> 00:19:30,430
This exact positioning is what defines our different user bases.

00:19:32,140 --> 00:19:37,030
And I think a lot of times, we're making intentional decisions, in terms of where we stand.

00:19:37,390 --> 00:19:43,930
And we, as framework designers, we know that we are attacking different sectors

00:19:43,930 --> 00:19:49,900
and I think that's a good thing because different developers needed different solutions.

00:19:49,000 --> 00:19:55,810
And having major frameworks covering the whole spectrum ensures everyone gets what they want.

00:19:57,520 --> 00:20:02,620
Okay, so now let's talk about our rendering mechanism, i.e.,

00:20:02,950 --> 00:20:08,320
how a framework allows you to express your UI structure and how it renders stuff.

00:20:11,260 --> 00:20:16,420
And primarily, this is actually a pretty complex spectrum spectrum in itself.

00:20:16,450 --> 00:20:18,820
It's not just a single thing.

00:20:18,840 --> 00:20:29,580
So it's like a multi dimension in itself, but let's briefly simplify it and think of it as JSX versus templates,

00:20:29,610 --> 00:20:37,590
that is, dynamic render functions versus static string-based compilation-based Vue expressions.

00:20:37,920 --> 00:20:41,040
And then there's expressiveness versus raw performance,

00:20:41,070 --> 00:20:45,240
then there's runtime scheduling versus ahead of time optimizations.

00:20:47,370 --> 00:20:55,560
Some people have really strong opinions on this,but I personally feel that they are more alike, inherently,

00:20:55,710 --> 00:20:59,040
they're just different strategies of expressing the same underlying idea.

00:20:59,220 --> 00:21:01,980
So it's more about the technical trade offs, right?

00:21:01,990 --> 00:21:19,390
So on the left, the spectrum, obviously JSX, React, and all the React-like libraries that use some sort of virtual DOM, like, pre-act, Stencil, Infernal, right.

00:21:19,570 --> 00:21:24,490
And then on the other side, template-based solutions, so I'll talk about Vue later but

00:21:24,720 --> 00:21:31,890
the more representative template-based solution, Svelte,

00:21:33,150 --> 00:21:39,870
and then there's Ember, so that logo is actually Glimmer's logo - so Glimmer is the rendering engine inside Ember -

00:21:40,320 --> 00:21:41,940
and then Angular as well.

00:21:41,970 --> 00:21:49,050
So these are primarily template-based, and they compile templates into relatively lower level instructions to render stuff.

00:21:50,250 --> 00:21:54,810
Now, let's talk about the pros of the JSX and virtual DOM approach.

00:21:55,830 --> 00:22:04,710
The most important reason people like JSX or virtual DOM is they have the full expressiveness of JavaScript -

00:22:05,160 --> 00:22:11,370
you're not confined to a arbitrary syntax, you have a language at your disposal - you can

00:22:11,400 --> 00:22:14,550
it's Turing complete, you can pretty much do anything you want.

00:22:16,860 --> 00:22:20,490
So you can build arbitrarily complex logic, you know, components.

00:22:20,520 --> 00:22:22,950
And it's really powerful and liberating, right?

00:22:23,250 --> 00:22:26,520
A lot of people like React for this particular reason.

00:22:27,990 --> 00:22:32,040
And it also allows you to treat the view as data.

00:22:32,430 --> 00:22:35,190
When you render a component, it always returns something -

00:22:35,000 --> 00:22:39,680
it returns the tree, the virtual DOM tree that represents the current state of a component.

00:22:39,950 --> 00:22:42,650
And this data can be used for a lot of interesting purposes.

00:22:43,250 --> 00:22:48,350
It gives you userland possibility to build, say, testing solutions.

00:22:48,380 --> 00:22:53,120
You can take snapshots based on the virtual DOM, you can render it to alternative targets,

00:22:53,540 --> 00:23:00,800
people have been doing things like rendering it to terminals, PDF, Canvas, WebGL, anything you can think of that you can render to.

00:23:02,690 --> 00:23:06,650
Because the view is data, and you can do anything with data.

00:23:07,700 --> 00:23:14,390
Now, the cons of virtual DOM, is that it is actually inherently expensive, right?

00:23:14,420 --> 00:23:18,830
Think about it, when React first came out, a lot of people are like, isn't this going to be slow?

00:23:19,200 --> 00:23:23,550
And React's answer was, "Yes, it's slow, but it's fast enough".

00:23:24,390 --> 00:23:30,720
But still, like, from a pure technical perspective, you're doing a lot of unnecessary work.

00:23:30,990 --> 00:23:38,610
Think about this simple template where the amount of work needed to just update that single message binding in there,

00:23:38,900 --> 00:23:45,200
we have to walk through the whole virtual DOM tree, and diff diff diff diff diff -

00:23:45,230 --> 00:23:52,400
you just have to recursively keep going down until somehow you update this in this process.

00:23:52,600 --> 00:23:59,650
So standard virtual DOM diffing cost is relative to the total size of your view, rather than the number of nodes that may change.

00:24:00,890 --> 00:24:06,140
Even if you only have one node that may change, the virtual DOM diffing algorithm doesn't know.

00:24:06,200 --> 00:24:12,170
The reason is the dynamic nature of render functions makes it hard to optimize for.

00:24:13,010 --> 00:24:16,280
By dynamic I mean, you can write code like this,

00:24:16,850 --> 00:24:23,780
you can just use a for loop to construct a children array and then give it to your parent node.

00:24:24,170 --> 00:24:26,270
And God knows what other things you can do.

00:24:27,260 --> 00:24:31,670
Say you can create this parent node first, then mutate its children,

00:24:31,670 --> 00:24:34,160
you can push additional elements into it.

00:24:34,990 --> 00:24:39,820
The compiler won't be able to cover all the possible edge cases you can do with JavaScript,

00:24:39,970 --> 00:24:42,430
because JavaScript is simply too dynamic.

00:24:43,570 --> 00:24:52,300
There are a lot of attempts in this space but inherently, it's hard to provide safe optimizations in this way,

00:24:54,220 --> 00:24:57,160
because there isn't simply enough assumptions you can make.

00:24:57,190 --> 00:25:01,990
The more assumptions you can make about the user intention, the easier it is to optimize the code.

00:25:02,200 --> 00:25:04,930
And with JavaScript, it's just really, really hard.

00:25:06,610 --> 00:25:18,370
Now, finally, React's solution to this problem is to instead of focusing on making virtual DOM itself faster, how about making perceived performance better?

00:25:18,420 --> 00:25:24,330
So it introduces runtime scheduling, concurrent mode, time slicing.

00:25:24,810 --> 00:25:32,550
But this, having this runtime solution, having this whole fiber, kind of like almost managing your own stack,

00:25:34,950 --> 00:25:39,330
like entering and exiting, rendering, all the stuff requires a heavy runtime.

00:25:40,200 --> 00:25:47,520
So this means whenever you load React, you have to load all the code that is necessary for handling all these complex runtime scheduling stuff.

00:25:47,990 --> 00:25:52,670
That's like several 20, 30KB of JavaScript, right.

00:25:53,390 --> 00:25:56,360
And that, in turn, also makes your initial loading suffer a little bit.

00:25:59,330 --> 00:26:05,150
And, on the other hand, if you are compiling, rendering code from a template,

00:26:05,720 --> 00:26:10,520
usually it can produce far more direct render instructions with better raw performance.

00:26:10,700 --> 00:26:16,700
The reason being that the template is, by definition a very, very constrained language -

00:26:16,820 --> 00:26:18,890
you can only write template a certain way.

00:26:19,070 --> 00:26:22,610
For example, when you write code like this,

00:26:23,120 --> 00:26:28,040
we can instantly tell that there's no way the order of these p can ever change,

00:26:28,070 --> 00:26:30,080
there's no way this ID can ever change,

00:26:30,080 --> 00:26:31,610
there's no way this class can ever change,

00:26:31,610 --> 00:26:33,290
the only thing that can change is this.

00:26:33,890 --> 00:26:42,080
So being static, and very restrictive actually allows the compiler to make more assumptions about your intention.

00:26:42,140 --> 00:26:44,900
And that gives it more room to perform optimizations.

00:26:45,290 --> 00:26:48,470
Think about what Svelte does when it compiles your code.

00:26:50,600 --> 00:26:54,380
Everything else is static, but only name could possibly change, so

00:26:54,720 --> 00:27:01,350
this P is the update function in Svelte code, and the only thing it does is change when a name has changed,

00:27:01,350 --> 00:27:03,240
and then update it if it has changed.

00:27:03,630 --> 00:27:09,420
So compare this to all the things a virtual DOM diffing algorithm tries to do.

00:27:09,900 --> 00:27:12,780
The difference is just orders of magnitude faster.

00:27:14,460 --> 00:27:24,840
So depending on strategy, template compilation, or in general,compilation-based approach can also result in much lighter runtime baseline size,

00:27:24,840 --> 00:27:31,440
because it doesn't need all the complex runtime scheduling to trying to make things look faster,

00:27:31,560 --> 00:27:33,510
because it's already fast, right?

00:27:33,690 --> 00:27:44,700
So Svelte can produce extremely lightweight output without having to require heavy, heavy baseline runtime to accommodate to all the possible runtime behavior.

00:27:45,930 --> 00:27:50,700
Now, the cons of template compilation is obviously, you are constrained by the template syntax -

00:27:50,910 --> 00:27:53,760
you lose the expressiveness of JavaScript.

00:27:54,210 --> 00:27:58,950
So when you are trying to build a really complex component, you'll feel like

00:27:58,980 --> 00:28:03,210
Oh, I wish I can do this in the template, but the compiler does not support it, right,

00:28:03,330 --> 00:28:07,110
you're out of luck, there's no escape hatch if you go the full compilation route,

00:28:07,290 --> 00:28:16,380
because the more lower level the compiler output is, the less likely you'll be able to actually hook into it and do your custom operations there.

00:28:16,900 --> 00:28:24,850
It's like an opa compiler that you won't be able to dig into assembly with C.

00:28:25,300 --> 00:28:27,730
that's just, you know, the way it is.

00:28:30,670 --> 00:28:34,000
It's as if you won't be able to debug your assembly code with C.

00:28:34,000 --> 00:28:43,180
So now, lighter runtime, lighter baseline runtime may also come at the cost of more verbose output per template, because

00:28:44,740 --> 00:28:54,490
when you're trying to produce code that executes as efficiently as possible, sometimes you would have to encode more information in the output directly.

00:28:55,360 --> 00:29:07,780
For example, the code that Svelte produces actually imperatively creates all the elements line by line, insert them one by one, and they have a separate function for updating them.

00:29:08,950 --> 00:29:15,220
In comparison, virtual DOM based results, you would have to just have one line.

00:29:15,460 --> 00:29:19,000
And that's just a single expression that returns the virtual DOM structure.

00:29:20,440 --> 00:29:22,420
So, runtime compilation.

00:29:25,180 --> 00:29:28,570
There's a runtime compilation cost if you compile on the fly.

00:29:30,340 --> 00:29:38,170
So most likely, for production use case, you would require users to compile beforehand so that places a hard requirement on a build step,

00:29:38,560 --> 00:29:41,890
which is something, you know, it's just inevitable.

00:29:41,000 --> 00:29:49,760
You either compile on the fly or pre built, which then involves all the node.js tool chains, which we are more or less used to now.

00:29:49,760 --> 00:29:55,640
But still, if you can avoid it, it would be really nice when people are getting started.

00:29:56,780 --> 00:29:59,810
Ok. So again, Vue kind of falls in the middle.

00:30:00,410 --> 00:30:03,080
Again, I want to emphasize, this is not saying Vue is the best.

00:30:05,300 --> 00:30:11,660
But the unique thing about Vue's rendering mechanism is we have both virtual DOM and template compilation.

00:30:12,110 --> 00:30:16,190
Vue actually compile those templates into virtual DOM under the hood.

00:30:17,330 --> 00:30:21,140
So we kind of get the best of both worlds.

00:30:22,550 --> 00:30:27,500
We have performance - the compilation step produces specially optimized, vdom render function.

00:30:27,500 --> 00:30:30,620
I'll talk about this in a bit of more details later.

00:30:30,860 --> 00:30:37,310
In ver 2.x, we actually haven't fully exploited this opportunity.

00:30:37,940 --> 00:30:44,840
The current Vue 2.x virtual DOM performance is probably just average virtual DOM, typical virtual DOM performance.

00:30:45,320 --> 00:30:50,240
But I'll talk a bit about what we're doing in 3.0 to make this much, much faster.

00:30:50,750 --> 00:30:52,250
And then there's expressiveness.

00:30:53,170 --> 00:31:03,310
You can actually skip the template layer, you can drop down into render functions and directly leverage JavaScript to perform arbitrarily complex logic.

00:31:03,400 --> 00:31:07,330
So this gives you an escape hatch when you feel you're constrained by templates.

00:31:08,620 --> 00:31:16,000
Now, the downside is, right, although we can be really fast, we're not

00:31:16,030 --> 00:31:26,590
we can probably never be as fast as say, Svelte because Svelte, it's the vanilla - its output is pretty much vanilla JavaScript.

00:31:27,130 --> 00:31:36,400
Whereas in order to be compatible with handwritten render functions, Vue still has to maintain a virtual DOM, so that cost is inevitable.

00:31:36,930 --> 00:31:42,060
And on the other hand, it kind of also creates a split between like, "which one should I use" problem.

00:31:43,500 --> 00:31:48,180
So a lot of users, although they can actually use render function, they'll probably just never use it.

00:31:48,600 --> 00:31:58,830
So now let's dig into what we're doing in v3.0 to make Vue's template compile to virtual DOM run faster than normal virtual DOM.

00:31:59,730 --> 00:32:04,470
This is what we already talked about, right, this template there's only one node that would change -

00:32:04,470 --> 00:32:09,690
the ideal update path is just diff this message string directly.

00:32:10,470 --> 00:32:12,450
No structure is static and never changes.

00:32:12,600 --> 00:32:14,130
There's only one dynamic node.

00:32:14,160 --> 00:32:17,640
So if we consider this template, it's a very, very simple case.

00:32:18,590 --> 00:32:23,750
It becomes a bit more complicated when you have things like v-if, which is what we call a structural directive.

00:32:24,560 --> 00:32:31,610
In JSX, this is pretty much an equivalent of a ternary - based on a condition you return different branches.

00:32:32,780 --> 00:32:38,990
Now, this creates a dynamic node structure, because the node may be there or may not be there.

00:32:39,770 --> 00:32:48,920
So to deal with this, a naive virtual DOM diffing algorithm would have to just assume the note list has changed and try to diff the two children arrays.

00:32:49,430 --> 00:32:56,030
But if we try to split it apart and see v-if separates the template into two nested blocks -

00:32:56,300 --> 00:33:05,540
the outer block, if we consider the v-if itself as a node, then the outer block has a static node content, node structure.

00:33:05,900 --> 00:33:08,480
Inside the v-if block it also is static.

00:33:08,900 --> 00:33:19,370
Now we have two static blocks, where within each block, you will have no need to diff any node order changes,

00:33:19,400 --> 00:33:24,830
the only thing you need is a flat array of the things that could possibly change inside this block.

00:33:25,500 --> 00:33:30,240
Similarly, for v-for - every v-for iteration, we consider it a static block.

00:33:31,110 --> 00:33:37,140
So if you have more like a v-if inside v-for you just split further into nested blocks.

00:33:38,010 --> 00:33:41,280
So we end up with something I call a block tree.

00:33:42,000 --> 00:33:51,120
This is just a play on something we know, but the block tree is a nested block - blocks, because

00:33:52,710 --> 00:34:01,500
within each block, you have a completely static node structure, so there's no need for any sort of like recursively going down and trying to diff two children lists.

00:34:02,970 --> 00:34:08,610
Within each block, you just have one single flat array of the nodes that could possibly change.

00:34:08,840 --> 00:34:15,950
On top of this, we also have additional organization hints on, for example, if a node has only a dynamic class binding,

00:34:15,950 --> 00:34:23,240
we have a fast path that you just directly set the class and you can go ahead, you don't have to diff the props if you don't want to.

00:34:24,290 --> 00:34:25,370
You don't have to, right.

00:34:26,960 --> 00:34:30,470
So the before and after is pretty obvious.

00:34:31,590 --> 00:34:37,650
For the same template, previously, we had to do all the full algorithm for different everything.

00:34:37,650 --> 00:34:46,740
And afterwards, we just do a single, flat, there will be a single array containing just this node with a dynamic text.

00:34:46,800 --> 00:34:50,250
And the only thing you need to do is compare whether the text has changed.

00:34:51,660 --> 00:35:08,130
So we did a brief benchmark with this is a list of 1000 v-for iterations - within each block, you have around 12 DOM nodes, that is a total of 12,000 DOM nodes.

00:35:08,700 --> 00:35:16,980
Within each iteration, you have four dynamic bindings, some classes, some text, so that is 4000, dynamic bindings on the page.

00:35:17,020 --> 00:35:23,650
And we update all of these bindings, and we do 100 runs, take the average.

00:35:23,920 --> 00:35:36,880
Current v2.6, per update is 36 milliseconds and current v3.0 prototype with the new compilation strategy it takes only like around 5.4 milliseconds.

00:35:36,880 --> 00:35:41,380
So that is more than six times faster in this benchmark, right.

00:35:43,620 --> 00:35:44,190
Thanks.

00:35:47,780 --> 00:35:57,110
So note in this benchmark alone, probably your real app probably will have a different number but you know, more or less, it's going to be a lot faster.

00:35:57,240 --> 00:35:58,590
That's the baseline.

00:36:00,600 --> 00:36:04,650
And then state mechanism, I probably don't have time to really dig into this.

00:36:04,830 --> 00:36:07,110
So that'll be another talk.

00:36:07,530 --> 00:36:15,510
But to wrap up, where is the perfect balance point here, when you're trying to design a framework?

00:36:16,620 --> 00:36:23,310
The question should probably be rephrased - does a perfect balance even exist?

00:36:24,300 --> 00:36:29,520
And is a single perfect balance point even optimal for JS devs as a whole, right?

00:36:29,880 --> 00:36:36,330
Because, like, all of us are trying to optimize for different things, when you're building something specific.

00:36:36,360 --> 00:36:44,820
For example, like, for Svelte, it's advantage is it can produce extremely lightweight code when you're building something small.

00:36:45,030 --> 00:36:49,770
And it is also extremely fast uses very, very little memory.

00:36:49,770 --> 00:36:52,590
So it can be used on like, even embedded devices.

00:36:52,920 --> 00:36:59,700
But if you're targeting use cases where, you know, you probably have a more complex use case,

00:37:00,000 --> 00:37:01,470
you have more components,

00:37:01,470 --> 00:37:06,240
you want the expressiveness of JavaScript but you also want a bit more performance from the templates,

00:37:06,240 --> 00:37:07,350
you can probably go with Vue.

00:37:07,300 --> 00:37:14,980
And then if you don't really care that much about extreme performance but you're like "I like React's ecosystem",

00:37:14,980 --> 00:37:15,850
you can go with React.

00:37:16,600 --> 00:37:19,180
There's all these options you can pick.

00:37:20,560 --> 00:37:28,300
So I think it's nice that the framework landscape is like a multi-dimensional space with multiple ever moving entities,

00:37:28,300 --> 00:37:35,770
like think of each framework as an entity, trying to look for the balance point it believes is the best.

00:37:35,800 --> 00:37:39,070
We're all trying to figure out, what's the best way to do things.

00:37:39,280 --> 00:37:41,950
And there will be multiple of us always, right.

00:37:42,040 --> 00:37:46,300
So as developers, you're like floating around in between these entities.

00:37:47,230 --> 00:37:50,080
You're dragged towards one of them by their gravity.

00:37:50,620 --> 00:37:56,080
And sometimes you may just, you know, switch around, you hop around and try to figure out which one is best for you.

00:37:56,350 --> 00:37:58,090
I think that's a good thing, right?

00:38:01,510 --> 00:38:06,310
But as a user, right, trying to navigate this multi-dimensional space can be daunting.

00:38:07,270 --> 00:38:10,750
But if you want to pick up the framework properly the hard way,

00:38:11,170 --> 00:38:15,280
then you have to understand some of these internal trade offs the frameworks are making.

00:38:15,970 --> 00:38:27,370
You have to be aware of which direction this framework is heading towards and whether it aligns with what you are prioritizing in the thing you're trying to build.

00:38:27,970 --> 00:38:35,890
So hopefully this talk has shed some light on that topic and could help you when you are trying to pick between frameworks in the future or

00:38:36,250 --> 00:38:38,620
tell other people how they should pick a framework.

00:38:38,710 --> 00:38:39,130

YouTube URL: https://www.youtube.com/watch?v=ANtSWq-zI0s


