Title: Double the Beyoncé: Navigating Numbers in JavaScript by Meggan Turner | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	Do you lie awake at night wondering why you can’t count up past 9 quadrillion in JavaScript? Have you ever been troubled by numbers that don’t add up correctly or do what you expect (looking at you, 0.1 + 0.2)?
JavaScript’s numbers can behave a little… unexpectedly at times, and cause bugs that can have you scratching your head for hours on end. From incorrect arithmetic to Beyoncé showing up on your page twice as often as you expect, in this talk we’ll take a look at the quirks that come from numbers in JavaScript & the strange issues they can cause.

Meggan is a Software Engineer at Jaxsta, a music startup dedicated to providing credit where credit is due. At Jaxsta, she writes code for the front-end platform, tinkers with databases & derails conversations with random music trivia (mostly about Beyoncé). When she's not coding you can find her rock climbing, swimming with sharks, or doing something else that makes her parents nervous.


JSConf.Asia - LASALLE College of the Arts, Singapore - 16 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:00,620 --> 00:00:15,820
[Music]

00:00:19,400 --> 00:00:25,410
excited to be here cool hi so I'm Megan

00:00:22,980 --> 00:00:27,720
I am a software engineer at JAXA in

00:00:25,410 --> 00:00:29,849
Sydney and I'm here today to talk to you

00:00:27,720 --> 00:00:33,030
all about numbers in general but also

00:00:29,849 --> 00:00:34,140
specifically in JavaScript and to have a

00:00:33,030 --> 00:00:35,579
little bit of fun with it I'm gonna put

00:00:34,140 --> 00:00:36,210
it in the context of Beyonce a little

00:00:35,579 --> 00:00:40,100
bit

00:00:36,210 --> 00:00:42,360
can I see who here is a fan of Beyonce

00:00:40,100 --> 00:00:43,920
can't actually see any of you so I'm

00:00:42,360 --> 00:00:47,090
just gonna assume you're all fans of

00:00:43,920 --> 00:00:50,850
Beyonce and you're gonna love this talk

00:00:47,090 --> 00:00:53,129
so I hope you are ready to learn so

00:00:50,850 --> 00:00:55,980
let's go back to basics what actually is

00:00:53,129 --> 00:00:58,199
a number well a number is an abstract

00:00:55,980 --> 00:01:01,530
concept which we use to count measure

00:00:58,199 --> 00:01:02,190
label and identify things we kind of use

00:01:01,530 --> 00:01:05,909
them every day

00:01:02,190 --> 00:01:07,890
they're pretty familiar concept and to

00:01:05,909 --> 00:01:10,820
help us kind of group them in and

00:01:07,890 --> 00:01:12,570
understand them we can classify them so

00:01:10,820 --> 00:01:14,780
we can group them into certain

00:01:12,570 --> 00:01:17,130
categories so we can start off with

00:01:14,780 --> 00:01:21,210
natural numbers which are our positive

00:01:17,130 --> 00:01:24,330
whole numbers integers we have integers

00:01:21,210 --> 00:01:27,689
which is negative and positive whole

00:01:24,330 --> 00:01:28,950
numbers and includes 0 we have rational

00:01:27,689 --> 00:01:32,220
numbers which numbers that can be

00:01:28,950 --> 00:01:33,540
expressed as fractions irrational

00:01:32,220 --> 00:01:36,210
numbers and numbers which cannot be

00:01:33,540 --> 00:01:38,939
expressed as fractions such as pie or

00:01:36,210 --> 00:01:40,470
the square root of 2 and we also have

00:01:38,939 --> 00:01:42,680
real numbers so real numbers are a

00:01:40,470 --> 00:01:45,899
superset of all of the above categories

00:01:42,680 --> 00:01:51,659
and basically represent any number that

00:01:45,899 --> 00:01:55,560
you can see on the number line we also

00:01:51,659 --> 00:01:59,729
have complex numbers transcendental

00:01:55,560 --> 00:02:05,219
numbers imaginary infinity and negative

00:01:59,729 --> 00:02:07,799
infinity infinitesimally it's real none

00:02:05,219 --> 00:02:11,780
of which I know anything about so not

00:02:07,799 --> 00:02:13,690
going to go there so just as we can

00:02:11,780 --> 00:02:14,740
classify numbers

00:02:13,690 --> 00:02:17,020
in two different ways we can also

00:02:14,740 --> 00:02:18,670
represent them in different ways so when

00:02:17,020 --> 00:02:20,740
I talk about representation I just mean

00:02:18,670 --> 00:02:24,400
how we communicate the numbers that were

00:02:20,740 --> 00:02:26,980
using so in human languages if I asked

00:02:24,400 --> 00:02:28,600
you to think of the number 8 many people

00:02:26,980 --> 00:02:33,610
here would imagine in the Arabic numeral

00:02:28,600 --> 00:02:37,030
eight some of us might imagine bar the

00:02:33,610 --> 00:02:40,330
Mandarin Chinese characters some of us

00:02:37,030 --> 00:02:43,930
might may think of us ah which is the

00:02:40,330 --> 00:02:45,700
Hindi number of eight so all of these

00:02:43,930 --> 00:02:47,440
are actually the same thing they're just

00:02:45,700 --> 00:02:51,160
different symbols which we use to

00:02:47,440 --> 00:02:52,360
represent the number eight and apologies

00:02:51,160 --> 00:02:54,220
if I've just like butchered the

00:02:52,360 --> 00:02:58,150
pronunciation of those feel free to come

00:02:54,220 --> 00:02:59,860
and correct me afterwards so just as we

00:02:58,150 --> 00:03:01,900
can represent numbers in different ways

00:02:59,860 --> 00:03:04,390
in human languages we can also represent

00:03:01,900 --> 00:03:05,830
them in different ways in JavaScript so

00:03:04,390 --> 00:03:08,020
in JavaScript there are five ways that

00:03:05,830 --> 00:03:10,600
we can represent numbers we have our

00:03:08,020 --> 00:03:16,210
standard base 10 so if we imagine that

00:03:10,600 --> 00:03:21,060
number 1234567 we can also represent

00:03:16,210 --> 00:03:25,690
that as a binary number which is base to

00:03:21,060 --> 00:03:28,630
octal which is base 8 hexadecimal which

00:03:25,690 --> 00:03:31,930
is base 16 you'll use that a lot if

00:03:28,630 --> 00:03:35,530
you're working with CSS as well and

00:03:31,930 --> 00:03:36,910
scientific notation so that little so

00:03:35,530 --> 00:03:39,640
this is what we use when we are handling

00:03:36,910 --> 00:03:43,090
really large numbers and that a just

00:03:39,640 --> 00:03:47,470
means like times 10 to the power of 6 in

00:03:43,090 --> 00:03:51,489
this case so what is a number in

00:03:47,470 --> 00:03:53,110
JavaScript well just as a girl has to

00:03:51,489 --> 00:03:55,600
have her standards so to does a

00:03:53,110 --> 00:03:58,019
programming language and in JavaScript

00:03:55,600 --> 00:04:01,480
we follow the OEE

00:03:58,019 --> 00:04:03,519
754 standard for floating-point

00:04:01,480 --> 00:04:07,360
arithmetic that's the Institute of

00:04:03,519 --> 00:04:09,910
Electrical and Electronic engineers it's

00:04:07,360 --> 00:04:11,650
a super long really dry document if

00:04:09,910 --> 00:04:16,299
you're having trouble sleeping I can

00:04:11,650 --> 00:04:20,680
recommend it it's very interesting I

00:04:16,299 --> 00:04:23,470
just don't have the the ability to read

00:04:20,680 --> 00:04:26,199
that kind of document power to you if

00:04:23,470 --> 00:04:28,900
you do but basically it

00:04:26,199 --> 00:04:32,110
outlines how numbers are implemented in

00:04:28,900 --> 00:04:34,659
JavaScript and gives us a reason why

00:04:32,110 --> 00:04:36,849
zero point one plus zero point two does

00:04:34,659 --> 00:04:41,009
not equal zero point 3 which is

00:04:36,849 --> 00:04:41,009
everyone's favorite JavaScript joke

00:04:41,169 --> 00:04:45,249
so the ieee-754 specifies the

00:04:43,870 --> 00:04:48,069
implementation of floating-point

00:04:45,249 --> 00:04:50,830
arithmetic in JavaScript which is how we

00:04:48,069 --> 00:04:52,539
represent decimal points in binary and

00:04:50,830 --> 00:04:54,879
it allows us to represent real numbers

00:04:52,539 --> 00:04:59,110
as an approximation to support a

00:04:54,879 --> 00:05:00,819
trade-off between range and precision so

00:04:59,110 --> 00:05:03,789
when I talk about range and precision

00:05:00,819 --> 00:05:05,789
computers have limited space they're not

00:05:03,789 --> 00:05:09,849
that amazing

00:05:05,789 --> 00:05:12,279
sorry no offense so when I talk about

00:05:09,849 --> 00:05:15,069
range in JavaScript we have a range of

00:05:12,279 --> 00:05:16,330
numbers that's like the size of the set

00:05:15,069 --> 00:05:17,949
that we can represent so we can

00:05:16,330 --> 00:05:20,439
represent from about negative 9

00:05:17,949 --> 00:05:22,509
quadrillion all the way up to positive 9

00:05:20,439 --> 00:05:24,969
quadrillion so that's a pretty decent

00:05:22,509 --> 00:05:28,240
sample size and when I talk about

00:05:24,969 --> 00:05:30,610
precision I mean in JavaScript we can

00:05:28,240 --> 00:05:34,060
represent numbers safely to 17 decimal

00:05:30,610 --> 00:05:37,779
places beyond that it'll just get kind

00:05:34,060 --> 00:05:39,219
of wacky and because computers have

00:05:37,779 --> 00:05:40,960
limited space we have to make a

00:05:39,219 --> 00:05:43,089
trade-off between range and precision we

00:05:40,960 --> 00:05:45,969
can either have greater range or greater

00:05:43,089 --> 00:05:50,680
precision we can't really have both

00:05:45,969 --> 00:05:56,490
unfortunately so computers are super

00:05:50,680 --> 00:05:56,490
basic to you guys

00:05:57,219 --> 00:06:04,110
this says hello Singapore in binary so

00:06:02,349 --> 00:06:06,819
regardless of how you write your number

00:06:04,110 --> 00:06:08,800
everything in your computer is going to

00:06:06,819 --> 00:06:12,550
be stored in binary it's all just ones

00:06:08,800 --> 00:06:15,399
and zeros but we can't have decimal

00:06:12,550 --> 00:06:18,969
points in binary decimal coming from the

00:06:15,399 --> 00:06:20,710
word deco meaning 10 binary is based too

00:06:18,969 --> 00:06:23,379
so we can't really represent decimal

00:06:20,710 --> 00:06:27,250
points safely so floating-point

00:06:23,379 --> 00:06:29,289
arithmetic tries to account for that so

00:06:27,250 --> 00:06:35,469
let's think about our number 1 million

00:06:29,289 --> 00:06:37,300
230 4567 underneath that is the

00:06:35,469 --> 00:06:38,860
representation of that number in binary

00:06:37,300 --> 00:06:44,650
floating-point

00:06:38,860 --> 00:06:48,110
we have 64 bits so 64 individual digits

00:06:44,650 --> 00:06:50,150
and it's helpful to kind of think about

00:06:48,110 --> 00:06:51,680
this in terms of scientific notation if

00:06:50,150 --> 00:06:54,350
you're already familiar with it to break

00:06:51,680 --> 00:06:58,280
down these bits so the first bit

00:06:54,350 --> 00:07:00,500
represents the sign if it's a zero it's

00:06:58,280 --> 00:07:03,710
a positive number if it's a 1 it's a

00:07:00,500 --> 00:07:06,050
negative number the next 11 bits

00:07:03,710 --> 00:07:10,250
represent the exponent so how far along

00:07:06,050 --> 00:07:13,670
the decimal place should be in this case

00:07:10,250 --> 00:07:16,700
it would be like six points along six

00:07:13,670 --> 00:07:19,640
places alone and we also have the

00:07:16,700 --> 00:07:25,460
significant or mantissa which actually

00:07:19,640 --> 00:07:30,350
represents the the like actual digits of

00:07:25,460 --> 00:07:32,300
the number so let's have a look a closer

00:07:30,350 --> 00:07:36,169
look at everybody's favorite JavaScript

00:07:32,300 --> 00:07:38,590
bug when I was a kid one of my maths

00:07:36,169 --> 00:07:42,730
teachers always used to tell me that

00:07:38,590 --> 00:07:42,730
calculators are never wrong humans are

00:07:48,020 --> 00:07:56,010
yeah that's all I have to say about that

00:07:50,010 --> 00:07:58,500
mr. Edwards so when we are representing

00:07:56,010 --> 00:08:00,600
numbers in floating-point arithmetic we

00:07:58,500 --> 00:08:02,520
can represent integers super-easy it's

00:08:00,600 --> 00:08:05,670
fine the conversion to binary is totally

00:08:02,520 --> 00:08:07,590
easy but when we start representing

00:08:05,670 --> 00:08:09,660
fractions things become a little more

00:08:07,590 --> 00:08:12,450
difficult so if we were trying to

00:08:09,660 --> 00:08:15,600
represent say one tenth in binary binary

00:08:12,450 --> 00:08:17,970
is based to so representing one out of

00:08:15,600 --> 00:08:19,140
ten in a system that only counts up to

00:08:17,970 --> 00:08:24,180
two it's gonna present some

00:08:19,140 --> 00:08:27,270
complications let's think about a third

00:08:24,180 --> 00:08:28,350
when we represent a third in decimal we

00:08:27,270 --> 00:08:32,580
round it

00:08:28,350 --> 00:08:34,950
we don't say 0.33 3 3 3 3 3 3 3 3 3 3 3

00:08:32,580 --> 00:08:40,350
3 3 3 3 for the rest of our lives we

00:08:34,950 --> 00:08:42,750
just say 0.3 0.33 but as anyone who's

00:08:40,350 --> 00:08:46,550
tried to like implement a three column

00:08:42,750 --> 00:08:50,960
layout grid layout and CSS we'll know

00:08:46,550 --> 00:08:58,310
it's ready 33% x 3 doesn't equal 100%

00:08:50,960 --> 00:09:03,200
it's always that pesky little 1% so our

00:08:58,310 --> 00:09:06,660
0.1 plus 0.2 problem is similar to this

00:09:03,200 --> 00:09:10,110
if we think about 0.1 represented in

00:09:06,660 --> 00:09:13,380
decimal it's easy 0.1 let's convert that

00:09:10,110 --> 00:09:17,250
to binary ok

00:09:13,380 --> 00:09:18,660
that's a lot more complicated I did say

00:09:17,250 --> 00:09:20,490
that we don't have decimal points in

00:09:18,660 --> 00:09:23,960
binary that's not a decimal point

00:09:20,490 --> 00:09:26,820
it's a radix point a radix binary point

00:09:23,960 --> 00:09:29,160
so it's a similar concept but just in

00:09:26,820 --> 00:09:31,980
base 2 we're not going to get into that

00:09:29,160 --> 00:09:34,650
but if you look at this representation

00:09:31,980 --> 00:09:38,610
you'll see it's zero point zero zero

00:09:34,650 --> 00:09:41,580
zero one one zero zero one one zero zero

00:09:38,610 --> 00:09:43,920
one one zero zero and that repetition

00:09:41,580 --> 00:09:47,280
just keeps on going

00:09:43,920 --> 00:09:49,320
but because we only have 64 bits we only

00:09:47,280 --> 00:09:52,350
have a certain amount of space to store

00:09:49,320 --> 00:09:55,620
this number we have to round it at some

00:09:52,350 --> 00:09:58,830
point and so when we take that rounded

00:09:55,620 --> 00:10:00,380
binary representation of 0.1 and convert

00:09:58,830 --> 00:10:09,920
it back to decimal

00:10:00,380 --> 00:10:15,200
we get this so that's not 0.1 hence this

00:10:09,920 --> 00:10:19,730
problem so it's a rounding error how big

00:10:15,200 --> 00:10:24,830
a problem is this really if I was trying

00:10:19,730 --> 00:10:29,510
to measure 1 centimeter and I had 0.16

00:10:24,830 --> 00:10:34,760
zeros for centimeters of era that would

00:10:29,510 --> 00:10:39,220
be 0.9 0 3 times as long as a glucose

00:10:34,760 --> 00:10:42,650
molecule okay that seems pretty tiny

00:10:39,220 --> 00:10:45,260
let's go bigger if I were trying to

00:10:42,650 --> 00:10:49,550
measure a kilometer and I had a margin

00:10:45,260 --> 00:10:52,550
of error of 0.16 0 4 kilometers that

00:10:49,550 --> 00:10:55,100
would be zero point twenty one zero

00:10:52,550 --> 00:10:56,800
times as long as the distance from Earth

00:10:55,100 --> 00:10:59,690
to the Moon

00:10:56,800 --> 00:11:02,870
okay not big enough let's go big or go

00:10:59,690 --> 00:11:05,780
home if I were trying to measure a

00:11:02,870 --> 00:11:09,770
Lightyear that's the distance that light

00:11:05,780 --> 00:11:13,580
travels in a year and I had a margin of

00:11:09,770 --> 00:11:16,370
zero margin of error of 0.16 zero four

00:11:13,580 --> 00:11:18,380
light-years I'd be about thirty eight

00:11:16,370 --> 00:11:20,060
point three eight centimeters off or

00:11:18,380 --> 00:11:25,250
about the height of a standard bowling

00:11:20,060 --> 00:11:27,800
pin things you learn so in most cases

00:11:25,250 --> 00:11:30,530
this degree of accuracy is really just

00:11:27,800 --> 00:11:33,260
not gonna be that important

00:11:30,530 --> 00:11:37,580
we don't usually need to know a value to

00:11:33,260 --> 00:11:39,200
17 decimal places if we're creating a

00:11:37,580 --> 00:11:41,240
shopping cart for instance does your

00:11:39,200 --> 00:11:44,750
user really need to know their cart

00:11:41,240 --> 00:11:47,090
total to 17 decimal places no they need

00:11:44,750 --> 00:11:49,190
to know it's like 2 maximum so we can

00:11:47,090 --> 00:11:51,230
just round it and we can just round it

00:11:49,190 --> 00:11:54,980
really easily using the rounding methods

00:11:51,230 --> 00:11:57,110
inside of the math object so we've

00:11:54,980 --> 00:12:03,400
talked a bit about precision now let's

00:11:57,110 --> 00:12:03,400
move on to range size really does matter

00:12:04,120 --> 00:12:08,840
in my defense Charlie started the willy

00:12:06,950 --> 00:12:10,730
jokes yesterday so I'm just carrying on

00:12:08,840 --> 00:12:12,990
from her work

00:12:10,730 --> 00:12:16,020
so I mentioned that we have a trade-off

00:12:12,990 --> 00:12:18,230
between range and precision and when I

00:12:16,020 --> 00:12:20,460
mentioned our range I said we have a

00:12:18,230 --> 00:12:22,320
range in JavaScript of about negative

00:12:20,460 --> 00:12:24,840
nine quadrillion through two positive

00:12:22,320 --> 00:12:29,150
nine quadrillion but I wasn't telling

00:12:24,840 --> 00:12:31,740
the entire truth way to build trust cool

00:12:29,150 --> 00:12:34,890
so if I went into my JavaScript console

00:12:31,740 --> 00:12:38,370
and I typed in 1.7 times 10 to the power

00:12:34,890 --> 00:12:40,140
of 308 I'd get that number back so

00:12:38,370 --> 00:12:42,600
obviously I can represent that number

00:12:40,140 --> 00:12:45,360
that's way bigger than nine quadrillion

00:12:42,600 --> 00:12:50,070
nine quadrillions only like 16 zeros and

00:12:45,360 --> 00:12:52,860
this has 308 that's massive but if I go

00:12:50,070 --> 00:12:59,820
1.8 to the power times 10 to the power

00:12:52,860 --> 00:13:03,270
of 308 any infinity I'm confused

00:12:59,820 --> 00:13:07,800
I really remember that being how Matz

00:13:03,270 --> 00:13:10,620
works but okay so javascript actually

00:13:07,800 --> 00:13:12,180
has a maximum value and you can access

00:13:10,620 --> 00:13:14,520
that inside of the number object and

00:13:12,180 --> 00:13:17,400
it's one point seven nine seven six nine

00:13:14,520 --> 00:13:20,130
all the rest of those numbers times 10

00:13:17,400 --> 00:13:23,670
to the power of 308 so that's a really

00:13:20,130 --> 00:13:27,060
big number and for really big numbers we

00:13:23,670 --> 00:13:30,810
have naming conventions so like a

00:13:27,060 --> 00:13:33,150
million a billion a quadrillion and

00:13:30,810 --> 00:13:36,510
those naming conventions go all the way

00:13:33,150 --> 00:13:39,990
up to a number that is followed by 303

00:13:36,510 --> 00:13:41,700
zeroes which is called a Santa lien so

00:13:39,990 --> 00:13:44,130
JavaScript actually exceeds naming

00:13:41,700 --> 00:13:47,520
conventions like that's massive that's

00:13:44,130 --> 00:13:48,750
huge that's a pretty good range if

00:13:47,520 --> 00:13:52,620
you're still not convinced that that's a

00:13:48,750 --> 00:13:55,560
good range three point two eight times

00:13:52,620 --> 00:13:58,740
ten to the power of 80 is a number of

00:13:55,560 --> 00:14:01,650
particles in the universe so if you're

00:13:58,740 --> 00:14:05,760
using any numbers bigger than that what

00:14:01,650 --> 00:14:10,110
are you doing stop I'm gonna create a

00:14:05,760 --> 00:14:11,490
black hole or something if you are using

00:14:10,110 --> 00:14:12,540
numbers bigger than that like tell me I

00:14:11,490 --> 00:14:16,860
want to know what you're doing for real

00:14:12,540 --> 00:14:19,370
that's cool so we have no business using

00:14:16,860 --> 00:14:22,810
numbers greater than that maximum number

00:14:19,370 --> 00:14:27,199
this is this is fine

00:14:22,810 --> 00:14:30,529
so we have a massive range up to three

00:14:27,199 --> 00:14:32,990
hundred and eight zeros but we can't

00:14:30,529 --> 00:14:34,850
safely represent numbers beyond this

00:14:32,990 --> 00:14:37,399
nine quadrillion that I'm keep banging

00:14:34,850 --> 00:14:39,649
on about so in JavaScript we have a

00:14:37,399 --> 00:14:42,139
maximum and minimum safe integers and

00:14:39,649 --> 00:14:44,569
that's that nine quadrillion value but

00:14:42,139 --> 00:14:48,560
if we move me on those values things get

00:14:44,569 --> 00:14:50,870
a little bit weird all right we've got

00:14:48,560 --> 00:14:52,370
our maximum safe integer we just pay

00:14:50,870 --> 00:14:53,899
attention to the last three digits

00:14:52,370 --> 00:14:55,279
because the rest of it it's just too

00:14:53,899 --> 00:14:58,190
much

00:14:55,279 --> 00:15:02,449
it ends in nine nine one all right let's

00:14:58,190 --> 00:15:21,230
try to do some maths all right working

00:15:02,449 --> 00:15:23,209
so far okay back on track so the

00:15:21,230 --> 00:15:28,550
arithmetic just stops adding up at a

00:15:23,209 --> 00:15:30,529
certain point and so this big number

00:15:28,550 --> 00:15:32,329
problem is actually what inspired this

00:15:30,529 --> 00:15:34,430
talk and now we're gonna get into

00:15:32,329 --> 00:15:38,149
Beyonce I promise show you've all been

00:15:34,430 --> 00:15:41,180
waiting with bated breath so at work so

00:15:38,149 --> 00:15:43,610
for a bit of context at jackster we're

00:15:41,180 --> 00:15:45,110
building a massive database of music

00:15:43,610 --> 00:15:47,810
credits so you can look up your favorite

00:15:45,110 --> 00:15:51,079
song and see who wrote produced recorded

00:15:47,810 --> 00:15:54,260
whatever and you can see all their names

00:15:51,079 --> 00:15:56,060
and click through whatever so work one

00:15:54,260 --> 00:15:58,519
day I was working on a page let's say I

00:15:56,060 --> 00:16:00,529
was looking at drunk in love by Beyonce

00:15:58,519 --> 00:16:07,250
which happens to be one of my favorite

00:16:00,529 --> 00:16:08,930
karaoke songs make it happen also in

00:16:07,250 --> 00:16:10,730
case you didn't understand the reference

00:16:08,930 --> 00:16:13,459
of my shirt because you weren't familiar

00:16:10,730 --> 00:16:21,769
with Beyonce's discography this is the

00:16:13,459 --> 00:16:25,240
reference okay so this is the page for

00:16:21,769 --> 00:16:27,290
drunken love by the USA on Jack's toe

00:16:25,240 --> 00:16:29,750
but you might notice something a bit

00:16:27,290 --> 00:16:32,360
weird in that credits panel on the left

00:16:29,750 --> 00:16:35,720
is that Beyonce is both the featured

00:16:32,360 --> 00:16:37,490
artist and the main artist which is

00:16:35,720 --> 00:16:40,670
not really true because jay-z's the

00:16:37,490 --> 00:16:44,200
featured artist on that song I mean to

00:16:40,670 --> 00:16:48,620
me this is a feature more than a bug but

00:16:44,200 --> 00:16:50,300
double Beyonce hell yeah cool so I

00:16:48,620 --> 00:16:54,380
noticed that we had this duplicate Dada

00:16:50,300 --> 00:16:55,970
rendering on the page and Beyonce

00:16:54,380 --> 00:17:01,070
wouldn't like this right she'd probably

00:16:55,970 --> 00:17:04,310
want jay-z to be represented fairly so I

00:17:01,070 --> 00:17:05,630
checked the API response and I saw that

00:17:04,310 --> 00:17:07,730
yeah we've got beyond saying we've got

00:17:05,630 --> 00:17:10,699
jay-z there's those two things are

00:17:07,730 --> 00:17:12,920
coming through but having a look at

00:17:10,699 --> 00:17:19,010
those IDs if you notice the last few

00:17:12,920 --> 00:17:20,540
digits that's not unique which is not

00:17:19,010 --> 00:17:28,300
ideal because they're clearly not the

00:17:20,540 --> 00:17:31,580
same object and so the problem here is

00:17:28,300 --> 00:17:35,630
that when we take the original IDs which

00:17:31,580 --> 00:17:37,550
ended in 167 and 168 JavaScript was

00:17:35,630 --> 00:17:39,020
passing them in correctly when I got

00:17:37,550 --> 00:17:44,330
them because those numbers were too

00:17:39,020 --> 00:17:46,220
large and so what was happening because

00:17:44,330 --> 00:17:48,830
we were getting the same IDs the

00:17:46,220 --> 00:17:50,450
framework that I use is embo and Amba

00:17:48,830 --> 00:17:52,280
Dada was saying hey I've already got a

00:17:50,450 --> 00:17:53,840
resource object with that ID I'm not

00:17:52,280 --> 00:17:57,380
gonna fetch it again so here have

00:17:53,840 --> 00:17:57,860
beyonce again she's again feature or not

00:17:57,380 --> 00:18:05,360
a bug

00:17:57,860 --> 00:18:07,790
but my boss didn't think so yeah so as

00:18:05,360 --> 00:18:10,220
you can see if you have IDs without

00:18:07,790 --> 00:18:12,620
numeric and they are incrementing and

00:18:10,220 --> 00:18:14,480
they're too large probably gonna run

00:18:12,620 --> 00:18:15,920
into problems like this and you probably

00:18:14,480 --> 00:18:22,550
gonna stare you screen for like three

00:18:15,920 --> 00:18:24,050
hours going why maybe right and so we

00:18:22,550 --> 00:18:29,060
were getting chiefly katana on the page

00:18:24,050 --> 00:18:31,370
which was not ideal something to look

00:18:29,060 --> 00:18:34,460
out for when you are handling really big

00:18:31,370 --> 00:18:35,660
numbers in API responses is that

00:18:34,460 --> 00:18:37,700
sometimes they'll be a difference

00:18:35,660 --> 00:18:41,150
between like when you open your response

00:18:37,700 --> 00:18:43,280
in a new tab versus in dev tools so when

00:18:41,150 --> 00:18:44,900
I was looking in dev tools the IDs were

00:18:43,280 --> 00:18:45,530
exactly the same so they were passed

00:18:44,900 --> 00:18:47,630
already

00:18:45,530 --> 00:18:50,179
where is when I opened the response up

00:18:47,630 --> 00:18:52,760
in a new tab it was the original

00:18:50,179 --> 00:18:57,320
i D that was one six seven and one six

00:18:52,760 --> 00:19:00,140
eight so that's not ideal that's

00:18:57,320 --> 00:19:02,510
happening in Chrome and Safari so you

00:19:00,140 --> 00:19:04,669
get the correct unpassed integer in a

00:19:02,510 --> 00:19:07,669
new tab but the past integer and dev

00:19:04,669 --> 00:19:09,770
tools in Firefox you get the past

00:19:07,669 --> 00:19:10,840
integer in both the new tab and the dev

00:19:09,770 --> 00:19:16,039
tools

00:19:10,840 --> 00:19:17,299
who knows although in edge now that it's

00:19:16,039 --> 00:19:20,539
chromium you'll probably get the same

00:19:17,299 --> 00:19:22,220
behavior as Chrome so that's cool I

00:19:20,539 --> 00:19:24,890
don't really understand why that's

00:19:22,220 --> 00:19:26,419
happening if anyone works on these kind

00:19:24,890 --> 00:19:28,309
of tools and can enlighten me I would

00:19:26,419 --> 00:19:32,630
love to know why it's like different in

00:19:28,309 --> 00:19:35,960
a new tab versus in the dev tools yeah

00:19:32,630 --> 00:19:38,600
so because we had the incremental

00:19:35,960 --> 00:19:42,020
numeric IDs it was a problem so our

00:19:38,600 --> 00:19:44,630
solution was to move to you IDs which is

00:19:42,020 --> 00:19:48,049
a pretty common solution they solve a

00:19:44,630 --> 00:19:51,110
bunch of problems for us that was

00:19:48,049 --> 00:19:53,899
primarily this problem where numbers

00:19:51,110 --> 00:19:55,789
were too large and the funny thing was

00:19:53,899 --> 00:19:58,100
we were actually using you IDs unlike

00:19:55,789 --> 00:20:01,659
every other table we just forgotten this

00:19:58,100 --> 00:20:01,659
one in the database and that was like

00:20:04,330 --> 00:20:10,309
and so because we fixed that now drunken

00:20:08,539 --> 00:20:14,210
love appears with the correct credits

00:20:10,309 --> 00:20:19,909
for jay-z and Beyonce and the king and

00:20:14,210 --> 00:20:23,809
queen are happy so this just in well

00:20:19,909 --> 00:20:27,890
like a year ago but this just in we also

00:20:23,809 --> 00:20:29,929
have now big int which is a new numeric

00:20:27,890 --> 00:20:33,710
primitive that was introduced about

00:20:29,929 --> 00:20:35,270
twelve months ago like a week before the

00:20:33,710 --> 00:20:41,870
first time I gave this talk and I was

00:20:35,270 --> 00:20:44,990
like oh my god so stressful so it is

00:20:41,870 --> 00:20:47,990
available in Chrome Firefox 68 Vita and

00:20:44,990 --> 00:20:49,970
edge it became available in Firefox 68

00:20:47,990 --> 00:20:53,830
beta like a week ago which was super

00:20:49,970 --> 00:20:56,390
exciting if your numbers nerd like me

00:20:53,830 --> 00:20:58,880
and it means we can represent numbers

00:20:56,390 --> 00:21:01,770
beyond that maximum safe integer which

00:20:58,880 --> 00:21:05,049
is pretty exciting

00:21:01,770 --> 00:21:09,400
so we can create them by appending

00:21:05,049 --> 00:21:13,530
in to a number so we type in 100 N and

00:21:09,400 --> 00:21:16,870
we receive back 100 N which is a big int

00:21:13,530 --> 00:21:20,590
you can also use the big int method with

00:21:16,870 --> 00:21:23,230
a string or a number we can't use any

00:21:20,590 --> 00:21:31,120
floats because it is an integer not the

00:21:23,230 --> 00:21:33,460
float or not big int not big decimal we

00:21:31,120 --> 00:21:37,299
can do arithmetic with other big in

00:21:33,460 --> 00:21:42,330
switch is cool we can do adding

00:21:37,299 --> 00:21:45,160
subtracting multiplying we can divide

00:21:42,330 --> 00:21:47,530
but because we won't return any decimals

00:21:45,160 --> 00:21:53,890
it will just round to 0 so 10 divided by

00:21:47,530 --> 00:21:56,770
3 is 3 and 1/3 but it'll just say 3 we

00:21:53,890 --> 00:21:58,419
can do this operation I don't know what

00:21:56,770 --> 00:22:00,610
it's called but it's like when you do

00:21:58,419 --> 00:22:05,500
something to the power of let's call it

00:22:00,610 --> 00:22:08,890
^ and we can also do modulo which is

00:22:05,500 --> 00:22:12,820
cool we can't do mixed type operations

00:22:08,890 --> 00:22:16,000
so we can't add 100 into 100 they're

00:22:12,820 --> 00:22:19,120
different numeric types so we can't

00:22:16,000 --> 00:22:21,840
actually mix them but we can compare

00:22:19,120 --> 00:22:28,090
them so they have loose can loose

00:22:21,840 --> 00:22:30,220
equality to regular numbers and we can

00:22:28,090 --> 00:22:32,590
compare them like with greater than and

00:22:30,220 --> 00:22:35,650
less then they'll compare correctly so

00:22:32,590 --> 00:22:40,660
if we have like a array of mixed types

00:22:35,650 --> 00:22:42,970
we can sort them things like that um now

00:22:40,660 --> 00:22:45,910
let's do some maths like some real maths

00:22:42,970 --> 00:22:48,460
with these big numbers so earlier we had

00:22:45,910 --> 00:22:50,380
this problem where we were adding to the

00:22:48,460 --> 00:22:52,780
maximum safe integer and everything was

00:22:50,380 --> 00:22:57,250
just really confusing and weird let's

00:22:52,780 --> 00:22:59,890
try that with big num Oh big integer so

00:22:57,250 --> 00:23:06,170
I'll set a variable big num and then

00:22:59,890 --> 00:23:09,170
I'll add 1 all right cool it works

00:23:06,170 --> 00:23:14,180
it works yeah clap for the creators of

00:23:09,170 --> 00:23:20,510
bigot it just keeps going it's so

00:23:14,180 --> 00:23:22,550
beautiful I love it I love it yeah so

00:23:20,510 --> 00:23:25,280
big in is not yet ready for production

00:23:22,550 --> 00:23:26,600
apps it's not available in all browsers

00:23:25,280 --> 00:23:29,750
and there's not a huge amount of

00:23:26,600 --> 00:23:32,410
documentation available but um this is

00:23:29,750 --> 00:23:32,410
how I feel about it

00:23:32,560 --> 00:23:41,660
big numbers cool what I think is most

00:23:37,790 --> 00:23:43,370
exciting about this is that this problem

00:23:41,660 --> 00:23:46,850
didn't even exist when JavaScript was

00:23:43,370 --> 00:23:49,250
created like what 23 24 years ago

00:23:46,850 --> 00:23:52,100
I mean javascript is kind of still like

00:23:49,250 --> 00:23:54,680
a baby in terms of what it can do but

00:23:52,100 --> 00:23:59,090
like some babies grow up to be Beyonce

00:23:54,680 --> 00:24:01,220
so maybe JavaScript will grow up to be

00:23:59,090 --> 00:24:03,860
Beyonce but I think it's really cool

00:24:01,220 --> 00:24:05,930
that you know it's easy to get caught up

00:24:03,860 --> 00:24:08,600
in JavaScript fatigue sometimes but I

00:24:05,930 --> 00:24:10,250
think it's really cool to be working in

00:24:08,600 --> 00:24:13,250
an ecosystem that is constantly evolving

00:24:10,250 --> 00:24:17,920
and growing and loading and fixing its

00:24:13,250 --> 00:24:20,000
mistakes which is cool so to summarize

00:24:17,920 --> 00:24:22,250
javascript has some really weird number

00:24:20,000 --> 00:24:25,810
quirks but when you kind of dig into

00:24:22,250 --> 00:24:28,100
them they're not totally unreasonable I

00:24:25,810 --> 00:24:31,520
would say they are totally reasonable

00:24:28,100 --> 00:24:33,950
when you kind of know what's going on so

00:24:31,520 --> 00:24:36,950
something to kind of just be aware of I

00:24:33,950 --> 00:24:40,010
guess when you're talking about precise

00:24:36,950 --> 00:24:42,470
numbers remember that javascript uses 64

00:24:40,010 --> 00:24:43,940
bit floating points so there are going

00:24:42,470 --> 00:24:48,320
to be precision errors when you're going

00:24:43,940 --> 00:24:51,230
any further than 17 decimal places so

00:24:48,320 --> 00:24:53,240
around things and when we're talking

00:24:51,230 --> 00:24:56,000
about really big numbers remember that

00:24:53,240 --> 00:24:59,270
there's that maximum safe integer try

00:24:56,000 --> 00:25:01,460
not to go beyond it if you can I'll have

00:24:59,270 --> 00:25:04,220
your IDs passed through with strings or

00:25:01,460 --> 00:25:06,080
different kind of types and remember

00:25:04,220 --> 00:25:09,830
that big ant is coming which is really

00:25:06,080 --> 00:25:12,620
cool I'm excited so I'm hoping that

00:25:09,830 --> 00:25:18,880
after this talk with mass you'll be a

00:25:12,620 --> 00:25:18,880
little less confused like this good boy

00:25:20,619 --> 00:25:34,620
or a little less confused be and a

00:25:26,599 --> 00:25:38,800
little more slay thank you so much

00:25:34,620 --> 00:25:38,800

YouTube URL: https://www.youtube.com/watch?v=4zveh5TzB6U


