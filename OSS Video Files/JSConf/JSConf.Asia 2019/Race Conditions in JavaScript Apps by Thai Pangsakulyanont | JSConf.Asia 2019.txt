Title: Race Conditions in JavaScript Apps by Thai Pangsakulyanont | JSConf.Asia 2019
Publication date: 2019-06-24
Playlist: JSConf.Asia 2019
Description: 
	"During an 'await' anything could happen." ... It’s easy to create race conditions in JavaScript if you’re not careful. This talk is about dealing with common kinds of race conditions based on my experience working on a real-time collaborative app.

Thai is a front-end architect at Taskworld. He’s interested in the ways of building better software, and helps organizing various tech events in Bangkok. He likes to and make music for fun. He also develops an open-source web-based rhythm game in his free time.


JSConf.Asia - LASALLE College of the Arts, Singapore - 16 June 2019

Source: https://2019.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.


Intro animation "something something prisms" by Martin Schuhfuss
https://codepen.io/usefulthink/pen/WogmvW

Intro music "Know" by Matt McKegg
https://soundcloud.com/destroy-with-science/know
Captions: 
	00:00:00,620 --> 00:00:20,430
[Music]

00:00:14,630 --> 00:00:25,380
okay let's begin good morning everyone

00:00:20,430 --> 00:00:28,619
so today I'm going to talk about race

00:00:25,380 --> 00:00:30,480
conditions in JavaScript apps and so

00:00:28,619 --> 00:00:33,390
right the title of this talk is about

00:00:30,480 --> 00:00:36,329
race conditions today I'm going to talk

00:00:33,390 --> 00:00:38,820
about other things as well maybe other

00:00:36,329 --> 00:00:41,100
edge cases that are not strictly race

00:00:38,820 --> 00:00:44,190
conditions but you may encounter them

00:00:41,100 --> 00:00:47,030
when you write a synchronous code so

00:00:44,190 --> 00:00:51,030
before I begin to talk I would like to

00:00:47,030 --> 00:00:54,629
share a bit of story before like how

00:00:51,030 --> 00:00:59,370
this talk came to be so I first got the

00:00:54,629 --> 00:01:01,320
idea of for this talk on one day on that

00:00:59,370 --> 00:01:03,989
day I went to a local meet up in

00:01:01,320 --> 00:01:06,450
Thailand and after the talks are done

00:01:03,989 --> 00:01:10,860
it's like networking time and my friend

00:01:06,450 --> 00:01:13,260
approached me and asked me hey ty is it

00:01:10,860 --> 00:01:17,159
hard to deal with race conditions in

00:01:13,260 --> 00:01:20,850
JavaScript so I answered well is

00:01:17,159 --> 00:01:24,390
actually pretty easy you just don't

00:01:20,850 --> 00:01:27,360
forget about them he gives me a bit of a

00:01:24,390 --> 00:01:30,720
confused look and I was like hey I'm

00:01:27,360 --> 00:01:32,880
totally serious here let me show you a

00:01:30,720 --> 00:01:35,430
couple of examples so I took out my

00:01:32,880 --> 00:01:38,430
laptop and start coding showing him some

00:01:35,430 --> 00:01:42,720
examples and before long it turned into

00:01:38,430 --> 00:01:46,799
a really deep discussion so after that

00:01:42,720 --> 00:01:50,729
discussion my friend told me whoa this

00:01:46,799 --> 00:01:52,170
could have been a food talk why don't

00:01:50,729 --> 00:01:54,990
you make a talk out of it and submit it

00:01:52,170 --> 00:01:59,219
to judge point for something so here I

00:01:54,990 --> 00:02:01,250
am and a big shout out goes to same for

00:01:59,219 --> 00:02:05,369
giving me the inspiration for this talk

00:02:01,250 --> 00:02:07,290
he's with us here as well so next time

00:02:05,369 --> 00:02:09,629
you have a deep technical discussion

00:02:07,290 --> 00:02:12,660
maybe you can tell your friend to like

00:02:09,629 --> 00:02:16,770
consider submitting a talk

00:02:12,660 --> 00:02:19,770
so this makes it my second time speaking

00:02:16,770 --> 00:02:22,920
here at just wants a CS so big big

00:02:19,770 --> 00:02:25,290
thanks to Thomas and all the organizers

00:02:22,920 --> 00:02:27,300
involved in running this conference it's

00:02:25,290 --> 00:02:30,060
really great and thank you for having me

00:02:27,300 --> 00:02:32,100
once again so today I'm going to show

00:02:30,060 --> 00:02:35,090
you two stories from my experience

00:02:32,100 --> 00:02:37,800
dealing with race conditions and stuff

00:02:35,090 --> 00:02:41,250
so I hope you can learn something out of

00:02:37,800 --> 00:02:44,490
these stories as I did by the way my

00:02:41,250 --> 00:02:47,910
name is ty and I'm from Thailand my

00:02:44,490 --> 00:02:49,860
twitter handle is at DT ints and if you

00:02:47,910 --> 00:02:52,320
have any feedback about this talk please

00:02:49,860 --> 00:02:55,680
send it to me and I would really

00:02:52,320 --> 00:02:57,780
appreciate it I'm currently working at

00:02:55,680 --> 00:02:59,310
task whereas the front-end architect and

00:02:57,780 --> 00:03:02,600
I'll get back to that later

00:02:59,310 --> 00:03:06,810
but now here comes the first story and

00:03:02,600 --> 00:03:09,060
this story involves little search box so

00:03:06,810 --> 00:03:12,170
in this search boss as I type a keyword

00:03:09,060 --> 00:03:14,670
is going to show the search result and

00:03:12,170 --> 00:03:16,260
it's going to show the result instantly

00:03:14,670 --> 00:03:16,620
so I don't have to press ENTER or

00:03:16,260 --> 00:03:19,740
anything

00:03:16,620 --> 00:03:21,510
it's like Google's autosuggest so let's

00:03:19,740 --> 00:03:25,050
build this real quick first we need the

00:03:21,510 --> 00:03:27,450
mock up so here I'm going to use the

00:03:25,050 --> 00:03:30,420
section for the rapper then it does an

00:03:27,450 --> 00:03:34,080
input box right there and then list

00:03:30,420 --> 00:03:37,020
containing the result so that's all the

00:03:34,080 --> 00:03:40,110
mock-up we need and next we're going to

00:03:37,020 --> 00:03:45,900
add some interactivity and for that I'm

00:03:40,110 --> 00:03:48,180
going to use VJ s so let's start with

00:03:45,900 --> 00:03:50,340
the data model for our state first we

00:03:48,180 --> 00:03:54,810
need to store the security that the user

00:03:50,340 --> 00:03:58,020
type and we can buy that today input box

00:03:54,810 --> 00:04:00,180
using the Wemo directive then we also

00:03:58,020 --> 00:04:02,340
need to store the search result to be

00:04:00,180 --> 00:04:06,150
displayed on the list here and to do

00:04:02,340 --> 00:04:08,040
that we can use the we four directive to

00:04:06,150 --> 00:04:10,080
do the binding and finally we buy the

00:04:08,040 --> 00:04:14,220
content of each result into the

00:04:10,080 --> 00:04:16,459
respective elements so that the data and

00:04:14,220 --> 00:04:19,500
the Dom they are now kept in sync so

00:04:16,459 --> 00:04:22,350
when the user enters the text Kure into

00:04:19,500 --> 00:04:25,710
the input field is going to update the

00:04:22,350 --> 00:04:26,500
text right here and we can wash for when

00:04:25,710 --> 00:04:30,040
it changes

00:04:26,500 --> 00:04:32,740
and when it changes we can perform in a

00:04:30,040 --> 00:04:35,440
synchronous Kure by calling the search

00:04:32,740 --> 00:04:37,390
function right there it's going to

00:04:35,440 --> 00:04:40,660
return a promise so we have to await it

00:04:37,390 --> 00:04:42,490
and once the result arrived we save it

00:04:40,660 --> 00:04:46,600
into this page which will be displayed

00:04:42,490 --> 00:04:48,760
on the user interface so then we have it

00:04:46,600 --> 00:04:52,810
and let's see how it goes

00:04:48,760 --> 00:04:57,160
so okay I'm going to type in react I

00:04:52,810 --> 00:05:00,130
don't know why but okay so the result

00:04:57,160 --> 00:05:02,740
shows up and that's good but it seems

00:05:00,130 --> 00:05:05,770
that the result that I see here doesn't

00:05:02,740 --> 00:05:08,380
have anything to do with react so what's

00:05:05,770 --> 00:05:10,830
going on here let's try again but this

00:05:08,380 --> 00:05:15,660
time I built an inspector on the right

00:05:10,830 --> 00:05:19,570
so that we can see what's going on okay

00:05:15,660 --> 00:05:23,590
you can see here that the result I want

00:05:19,570 --> 00:05:26,500
to see is overwritten by the result of

00:05:23,590 --> 00:05:29,590
the request that I made earlier but it

00:05:26,500 --> 00:05:32,710
finished later so it overrides their the

00:05:29,590 --> 00:05:35,830
the Dom and you know this kind of makes

00:05:32,710 --> 00:05:37,810
sense because the shorter the Kure maybe

00:05:35,830 --> 00:05:41,580
it will return more result and maybe it

00:05:37,810 --> 00:05:44,560
will take longer to load so you cannot

00:05:41,580 --> 00:05:46,530
depend on the order of the request to

00:05:44,560 --> 00:05:50,380
correspond to the order of the response

00:05:46,530 --> 00:05:54,430
so you can think of an a sync function

00:05:50,380 --> 00:05:57,310
as a function that spawns the trade and

00:05:54,430 --> 00:05:59,919
the Dom here is a shared mutable state

00:05:57,310 --> 00:06:02,950
so you know when dealing with shared

00:05:59,919 --> 00:06:06,460
mutable state we have to be careful

00:06:02,950 --> 00:06:08,860
so let's come back to this code when we

00:06:06,460 --> 00:06:12,130
face problem like this one of the common

00:06:08,860 --> 00:06:14,919
approach I see very often is to do a D

00:06:12,130 --> 00:06:16,990
bounce and what I mean by D bouncing is

00:06:14,919 --> 00:06:19,960
that instead of doing the search right

00:06:16,990 --> 00:06:22,960
away we're going to wait a bit until the

00:06:19,960 --> 00:06:25,960
user has finished typing and after that

00:06:22,960 --> 00:06:31,150
period of inactivity then we do the

00:06:25,960 --> 00:06:33,940
search as usual so let's try it okay it

00:06:31,150 --> 00:06:36,580
seems to work because now it only

00:06:33,940 --> 00:06:39,729
performs a single request there are no

00:06:36,580 --> 00:06:42,130
more competing requests but you know it

00:06:39,729 --> 00:06:45,789
went with the D bounce it still doesn't

00:06:42,130 --> 00:06:48,669
guarantee the order of the response so I

00:06:45,789 --> 00:06:51,340
could do something like this then we're

00:06:48,669 --> 00:06:54,700
back to the same problem so let's step

00:06:51,340 --> 00:06:57,070
back and look at this code again the

00:06:54,700 --> 00:07:00,160
real problem here is that while we are

00:06:57,070 --> 00:07:02,770
waiting for the result to arrive I could

00:07:00,160 --> 00:07:06,010
have triggered another search and in

00:07:02,770 --> 00:07:07,750
this case when the result did arrive it

00:07:06,010 --> 00:07:11,020
might not make sense to use it anymore

00:07:07,750 --> 00:07:14,020
because now I have already triggered

00:07:11,020 --> 00:07:15,729
another search so let's fix this but

00:07:14,020 --> 00:07:19,210
first I'm going to get rid of the D

00:07:15,729 --> 00:07:22,210
bounce because it didn't work instead

00:07:19,210 --> 00:07:25,120
I'm going to generate a unique ID for

00:07:22,210 --> 00:07:30,789
each request then keep track of the

00:07:25,120 --> 00:07:33,820
latest request ID here and when we after

00:07:30,789 --> 00:07:36,700
we await maybe this not latest request

00:07:33,820 --> 00:07:38,729
ID could have changed so we compare if

00:07:36,700 --> 00:07:41,289
the request ID we are holding onto

00:07:38,729 --> 00:07:43,659
doesn't corresponds to the latest

00:07:41,289 --> 00:07:50,159
request we'll just discard the result

00:07:43,659 --> 00:07:53,110
and let's see okay now it works and

00:07:50,159 --> 00:07:57,190
because we only care about the result of

00:07:53,110 --> 00:08:01,659
the latest request other other response

00:07:57,190 --> 00:08:03,970
got discarded but here now I am

00:08:01,659 --> 00:08:08,020
searching really slowly and you can see

00:08:03,970 --> 00:08:10,120
that until I finished typing I get no

00:08:08,020 --> 00:08:13,659
feedback whatsoever from the search box

00:08:10,120 --> 00:08:18,280
and that makes me fear that the search

00:08:13,659 --> 00:08:20,650
box is a bit unresponsive because you

00:08:18,280 --> 00:08:23,919
know before the resolve could arrive I

00:08:20,650 --> 00:08:28,450
type another letter so it discarded the

00:08:23,919 --> 00:08:30,729
result that the interim result but if we

00:08:28,450 --> 00:08:33,969
compare that to Google even on a very

00:08:30,729 --> 00:08:36,940
slow internet I still get the result as

00:08:33,969 --> 00:08:40,209
I type even if it lacks behind by

00:08:36,940 --> 00:08:43,780
several characters so it's clear that

00:08:40,209 --> 00:08:48,250
they are not totally disregarding the

00:08:43,780 --> 00:08:50,500
result that is not the latest so I think

00:08:48,250 --> 00:08:52,370
we can do better so instead of

00:08:50,500 --> 00:08:53,899
discarding the result that

00:08:52,370 --> 00:08:57,290
doesn't correspond to the latest

00:08:53,899 --> 00:09:01,670
requests what if we only discard the

00:08:57,290 --> 00:09:06,800
result that arrived out of order so we

00:09:01,670 --> 00:09:09,230
can do this and let's see okay now it

00:09:06,800 --> 00:09:11,930
seems to work and you can see here that

00:09:09,230 --> 00:09:17,509
I get the result I want even before I

00:09:11,930 --> 00:09:21,139
finished typing so yeah you can see that

00:09:17,509 --> 00:09:23,809
this humble little search box it took me

00:09:21,139 --> 00:09:27,079
three attempts until I can get it right

00:09:23,809 --> 00:09:30,379
and that brings me to the first takeaway

00:09:27,079 --> 00:09:33,439
for this first story which is to always

00:09:30,379 --> 00:09:35,920
remember about the potential risk

00:09:33,439 --> 00:09:39,439
conditions whenever there is an await

00:09:35,920 --> 00:09:42,050
call so each time you see in a wait

00:09:39,439 --> 00:09:44,089
maybe think about what else could happen

00:09:42,050 --> 00:09:46,759
while we are waiting for the result and

00:09:44,089 --> 00:09:50,920
also think about whether or not it makes

00:09:46,759 --> 00:09:52,370
sense to use the result after the wait

00:09:50,920 --> 00:09:55,399
all right

00:09:52,370 --> 00:09:58,430
that's the first story we're going to

00:09:55,399 --> 00:10:00,709
continue with the second story and this

00:09:58,430 --> 00:10:03,529
story came from like my experience

00:10:00,709 --> 00:10:05,689
working at Tazewell and it is a

00:10:03,529 --> 00:10:08,569
real-time collaborative project

00:10:05,689 --> 00:10:12,470
management app and that's important and

00:10:08,569 --> 00:10:15,379
you'll see why the story happened when

00:10:12,470 --> 00:10:17,720
we built the app in its early days so

00:10:15,379 --> 00:10:19,579
we're just starting out there it

00:10:17,720 --> 00:10:22,639
happened about two to three years ago

00:10:19,579 --> 00:10:26,420
and it has to do with something called

00:10:22,639 --> 00:10:29,209
optimistic updates so for example our

00:10:26,420 --> 00:10:31,129
app provides a Kanban board and suppose

00:10:29,209 --> 00:10:33,740
that you drag a task from one list to

00:10:31,129 --> 00:10:37,129
the other you wouldn't expect the task

00:10:33,740 --> 00:10:39,470
to go into the loading State right well

00:10:37,129 --> 00:10:42,769
no you expect the task to just snap

00:10:39,470 --> 00:10:46,069
right into the new list and that's what

00:10:42,769 --> 00:10:49,879
optimistic update is so basic idea is we

00:10:46,069 --> 00:10:52,730
update the UI first in anticipation that

00:10:49,879 --> 00:10:55,819
the request will be completed

00:10:52,730 --> 00:10:58,730
successfully and raw we synchronize this

00:10:55,819 --> 00:11:01,579
change with the server in the background

00:10:58,730 --> 00:11:04,129
so having this kind of experience like

00:11:01,579 --> 00:11:06,540
optimistic updates it's really important

00:11:04,129 --> 00:11:10,590
for collaborative epic

00:11:06,540 --> 00:11:12,570
patience but our app users react and

00:11:10,590 --> 00:11:15,900
when we use to react

00:11:12,570 --> 00:11:18,570
we like to derive our user interface

00:11:15,900 --> 00:11:22,200
from the underlying data model so in

00:11:18,570 --> 00:11:24,960
this case is the reader store so in

00:11:22,200 --> 00:11:28,110
order to preserve the unidirectional

00:11:24,960 --> 00:11:31,920
data flow we update the data model

00:11:28,110 --> 00:11:36,180
instead and we're going to let it flow

00:11:31,920 --> 00:11:39,210
into the UI and for this example maybe

00:11:36,180 --> 00:11:42,330
moving a task is a bit complex operation

00:11:39,210 --> 00:11:45,330
because it involves both a task and the

00:11:42,330 --> 00:11:50,370
list so instead I'm going to just focus

00:11:45,330 --> 00:11:54,420
on something simpler such as renaming a

00:11:50,370 --> 00:11:57,630
task so when I hit enter here is going

00:11:54,420 --> 00:12:00,450
to trigger an event handler and it will

00:11:57,630 --> 00:12:04,320
call a function here rename task which

00:12:00,450 --> 00:12:06,660
is our action and following this basic

00:12:04,320 --> 00:12:09,180
pattern what we did is okay we update

00:12:06,660 --> 00:12:12,120
the data model here and that's going to

00:12:09,180 --> 00:12:15,480
cost the data model to flow into the

00:12:12,120 --> 00:12:17,370
user interface and like that then we

00:12:15,480 --> 00:12:20,330
make the API call to synchronize with

00:12:17,370 --> 00:12:22,980
the backend and because sometimes

00:12:20,330 --> 00:12:24,720
internet connection may not be stable or

00:12:22,980 --> 00:12:28,140
something we are just going on with the

00:12:24,720 --> 00:12:31,080
API we use a try cache to display the

00:12:28,140 --> 00:12:33,660
error message just for good measure and

00:12:31,080 --> 00:12:37,200
that's it that is how we implement it

00:12:33,660 --> 00:12:40,530
basic optimistic updates and for most of

00:12:37,200 --> 00:12:44,130
our operations in our app we write code

00:12:40,530 --> 00:12:46,770
following this basic pattern and you

00:12:44,130 --> 00:12:50,940
know this works really well and gives us

00:12:46,770 --> 00:12:53,880
a really great experience as long as

00:12:50,940 --> 00:12:56,820
never as long as nothing goes wrong so

00:12:53,880 --> 00:12:59,580
it works well in the early days when we

00:12:56,820 --> 00:13:03,210
are just starting out and our focus was

00:12:59,580 --> 00:13:05,970
to figure out how we can make project

00:13:03,210 --> 00:13:09,660
management to that our customers would

00:13:05,970 --> 00:13:12,570
like to use however as we get more

00:13:09,660 --> 00:13:14,910
customers we start getting reports such

00:13:12,570 --> 00:13:18,540
as well our screens are displaying

00:13:14,910 --> 00:13:19,950
different things you know they become

00:13:18,540 --> 00:13:23,010
incomes

00:13:19,950 --> 00:13:25,920
or something more serious such as this

00:13:23,010 --> 00:13:27,600
one so someone writes a comment the

00:13:25,920 --> 00:13:31,320
other person didn't receive it because

00:13:27,600 --> 00:13:35,490
it never gets sent but the app acts as

00:13:31,320 --> 00:13:38,790
if it was already sent so you know work

00:13:35,490 --> 00:13:42,270
is lost and that's pretty serious I

00:13:38,790 --> 00:13:45,890
think we came back to our code and it

00:13:42,270 --> 00:13:49,230
became clear that our implementation of

00:13:45,890 --> 00:13:53,400
optimistic update was indeed too

00:13:49,230 --> 00:13:56,190
optimistic so there's no room for

00:13:53,400 --> 00:13:58,980
anything to go wrong here and when it

00:13:56,190 --> 00:14:02,580
does let's see for example if this API

00:13:58,980 --> 00:14:04,860
call fails first we didn't live with our

00:14:02,580 --> 00:14:07,800
data model back to the previous state so

00:14:04,860 --> 00:14:10,800
each client will go its own way and it

00:14:07,800 --> 00:14:13,590
will be totally out of sync and we also

00:14:10,800 --> 00:14:16,230
didn't really try to request and this is

00:14:13,590 --> 00:14:18,240
really bad because you know we tried so

00:14:16,230 --> 00:14:21,600
hard and put in a lot of effort to like

00:14:18,240 --> 00:14:23,460
craft a great experience that the

00:14:21,600 --> 00:14:26,430
customer will want to use and now we are

00:14:23,460 --> 00:14:28,140
just throwing their data away and you

00:14:26,430 --> 00:14:31,740
know that's not what we want for our

00:14:28,140 --> 00:14:35,600
users but well that was what we

00:14:31,740 --> 00:14:38,610
implemented so at that time we

00:14:35,600 --> 00:14:41,910
incorrectly assumed that building a

00:14:38,610 --> 00:14:45,270
single page real-time collaborative app

00:14:41,910 --> 00:14:48,600
and task management apps you know is

00:14:45,270 --> 00:14:51,900
it's just like CI UD apps create read

00:14:48,600 --> 00:14:54,420
update delete that's all that's mostly

00:14:51,900 --> 00:14:57,480
what it does so it should be as simple

00:14:54,420 --> 00:15:00,150
as Oh screw multi page application

00:14:57,480 --> 00:15:01,590
because right because you know that's

00:15:00,150 --> 00:15:05,970
what we know that's what we're familiar

00:15:01,590 --> 00:15:09,810
with and if you write Ruby on Rails ya

00:15:05,970 --> 00:15:13,110
doing a create thing is just as simple

00:15:09,810 --> 00:15:17,450
as that so it's supposed to be simple

00:15:13,110 --> 00:15:21,930
right well maybe not really and now here

00:15:17,450 --> 00:15:24,360
here we are facing its consequence so we

00:15:21,930 --> 00:15:26,850
have to fix it and that means we have to

00:15:24,360 --> 00:15:31,900
go back and fix all of these operations

00:15:26,850 --> 00:15:36,640
that we've implemented so far as well so

00:15:31,900 --> 00:15:40,570
our goals shift data loss is a serious

00:15:36,640 --> 00:15:43,780
problem and first to fix that we need to

00:15:40,570 --> 00:15:46,240
try to achieve eventual consistency that

00:15:43,780 --> 00:15:48,730
means everyone will eventually see the

00:15:46,240 --> 00:15:51,940
same thing on their screen which I call

00:15:48,730 --> 00:15:55,750
the ground truth without having to like

00:15:51,940 --> 00:15:59,530
press refresh and second we want to

00:15:55,750 --> 00:16:01,860
prevent data loss as much as we can so

00:15:59,530 --> 00:16:04,870
let's first talk about the first one

00:16:01,860 --> 00:16:07,480
coming back to this code record the

00:16:04,870 --> 00:16:09,280
previous part where I say when the API

00:16:07,480 --> 00:16:10,360
call failed we didn't reword this state

00:16:09,280 --> 00:16:13,420
right

00:16:10,360 --> 00:16:16,990
maybe that's quite easy to fix right

00:16:13,420 --> 00:16:18,460
we just start a previous title here and

00:16:16,990 --> 00:16:23,800
when that's an error

00:16:18,460 --> 00:16:28,860
we just revert and that would work would

00:16:23,800 --> 00:16:31,990
it as we learned from our first story

00:16:28,860 --> 00:16:34,450
you see in a weight and anything could

00:16:31,990 --> 00:16:38,430
happen here especially in a real-time

00:16:34,450 --> 00:16:40,720
app so for example someone may

00:16:38,430 --> 00:16:43,180
successfully update this task while

00:16:40,720 --> 00:16:46,660
we're awaiting here and that means the

00:16:43,180 --> 00:16:48,370
previous title that we stored will no

00:16:46,660 --> 00:16:49,180
longer become well it and we cannot use

00:16:48,370 --> 00:16:53,200
it anymore

00:16:49,180 --> 00:16:56,470
so the more is cases we try to solve the

00:16:53,200 --> 00:16:58,240
more they seem to come up and what about

00:16:56,470 --> 00:17:01,180
more complex operations such as like

00:16:58,240 --> 00:17:04,420
moving a task between lists how how much

00:17:01,180 --> 00:17:06,580
complex would our quote be if we were to

00:17:04,420 --> 00:17:10,480
handle all the edge cases in all of

00:17:06,580 --> 00:17:12,340
these operations uh is there something

00:17:10,480 --> 00:17:16,360
fundamentally wrong with the way we are

00:17:12,340 --> 00:17:18,220
writing code so I took another step back

00:17:16,360 --> 00:17:21,040
and think about the way we are

00:17:18,220 --> 00:17:24,660
approaching optimistic updates and then

00:17:21,040 --> 00:17:27,610
I realized that if we want to have

00:17:24,660 --> 00:17:31,660
eventual consistency we must try to

00:17:27,610 --> 00:17:34,090
stick with the ground truth I defined it

00:17:31,660 --> 00:17:37,390
as the letter state that we received

00:17:34,090 --> 00:17:40,300
from or delay or delayed the thing that

00:17:37,390 --> 00:17:42,370
was acknowledged by the backend can be

00:17:40,300 --> 00:17:45,040
considered the ground truth and each

00:17:42,370 --> 00:17:48,780
time we update the model of the

00:17:45,040 --> 00:17:52,210
basically here we are moving away from

00:17:48,780 --> 00:17:54,520
that ground truth and considering that

00:17:52,210 --> 00:17:57,420
everything else may be going on and

00:17:54,520 --> 00:18:01,720
happening all around that will make it

00:17:57,420 --> 00:18:04,780
hard harder to ever come back to it so

00:18:01,720 --> 00:18:07,950
maybe we should leave that data model

00:18:04,780 --> 00:18:12,000
alone and don't update it optimistically

00:18:07,950 --> 00:18:18,310
but then how would we implement

00:18:12,000 --> 00:18:23,580
optimistic UI then we figure something

00:18:18,310 --> 00:18:25,540
out what if we had a separate data model

00:18:23,580 --> 00:18:28,960
representing a list of the pending

00:18:25,540 --> 00:18:33,190
operations instead of optimistically

00:18:28,960 --> 00:18:35,140
update the data model directly we just

00:18:33,190 --> 00:18:38,430
add it to the list of pending operations

00:18:35,140 --> 00:18:42,010
and when it's done we just remove it

00:18:38,430 --> 00:18:44,530
when we render the UI we overlay the

00:18:42,010 --> 00:18:47,470
pending change on top of what's inside

00:18:44,530 --> 00:18:49,960
the model essentially computing a

00:18:47,470 --> 00:18:56,230
project optimistic version of the task

00:18:49,960 --> 00:18:57,970
on the fly in our components and that

00:18:56,230 --> 00:19:00,850
could work because if the operation

00:18:57,970 --> 00:19:04,720
fails the data model would be left alone

00:19:00,850 --> 00:19:07,740
and the UI will revert back but if the

00:19:04,720 --> 00:19:10,840
operation succeeded the ground truth

00:19:07,740 --> 00:19:14,050
will be updated first then the operation

00:19:10,840 --> 00:19:17,170
will be removed from the list and from

00:19:14,050 --> 00:19:20,470
the UI perspective it's nothing change

00:19:17,170 --> 00:19:22,570
so now we have a data model that allows

00:19:20,470 --> 00:19:26,980
us to do optimistic up Dre updates

00:19:22,570 --> 00:19:30,640
without driving us insane so now let's

00:19:26,980 --> 00:19:33,760
consider a case where I just created a

00:19:30,640 --> 00:19:35,590
task here and the blue bar right there

00:19:33,760 --> 00:19:39,070
represents the time it take for the

00:19:35,590 --> 00:19:40,600
operation to complete but now since we

00:19:39,070 --> 00:19:43,620
have optimistic update

00:19:40,600 --> 00:19:46,210
I see the task appear right away and

00:19:43,620 --> 00:19:48,790
that means I can also interact with it

00:19:46,210 --> 00:19:52,630
so let's say I immediately assigned

00:19:48,790 --> 00:19:55,030
someone to that task in this case this

00:19:52,630 --> 00:19:57,550
API call would fail because at this time

00:19:55,030 --> 00:19:58,710
the task doesn't exist in the backend

00:19:57,550 --> 00:20:03,639
yet

00:19:58,710 --> 00:20:06,970
right so that will lead to a data loss

00:20:03,639 --> 00:20:08,679
and we don't want that and that means I

00:20:06,970 --> 00:20:13,450
need to wait until the previous

00:20:08,679 --> 00:20:16,179
operation complete first before before

00:20:13,450 --> 00:20:19,419
we can work on the subsequent operation

00:20:16,179 --> 00:20:23,169
and that essentially means we have to

00:20:19,419 --> 00:20:27,129
sequence our operations into an

00:20:23,169 --> 00:20:29,889
operation queue so with the operation

00:20:27,129 --> 00:20:33,009
queue implemented the action code now

00:20:29,889 --> 00:20:34,629
looks like this so this is now even

00:20:33,009 --> 00:20:37,509
simpler than the first one that we came

00:20:34,629 --> 00:20:40,989
up and we just let the queue do his

00:20:37,509 --> 00:20:44,109
thing so now all of our write operations

00:20:40,989 --> 00:20:45,940
can be fixed by making it right to the

00:20:44,109 --> 00:20:50,349
queue instead of calling the API

00:20:45,940 --> 00:20:53,499
directly then we can update the UI to

00:20:50,349 --> 00:20:57,099
compute the projected state by reading

00:20:53,499 --> 00:20:59,710
from that queue so because the

00:20:57,099 --> 00:21:02,979
operations are now sequence and managed

00:20:59,710 --> 00:21:05,080
by the queue that means it can also take

00:21:02,979 --> 00:21:10,169
care of Lee trying the failed request

00:21:05,080 --> 00:21:13,450
and that helps us deal with data loss so

00:21:10,169 --> 00:21:16,779
we haven't covered all the edge cases

00:21:13,450 --> 00:21:18,609
yet and preventing further data loss

00:21:16,779 --> 00:21:22,779
from here is like just a matter of

00:21:18,609 --> 00:21:25,059
asking a series of what-if questions for

00:21:22,779 --> 00:21:27,239
example what if the user closes the

00:21:25,059 --> 00:21:29,979
browser arrived a queue is still running

00:21:27,239 --> 00:21:32,649
well we can try to prevent the user from

00:21:29,979 --> 00:21:34,899
quitting the browser or we can persist

00:21:32,649 --> 00:21:37,960
the content of the queue into the

00:21:34,899 --> 00:21:40,690
client-side storage so that it can be

00:21:37,960 --> 00:21:45,159
resumed afterwards or we can do both

00:21:40,690 --> 00:21:48,489
right but our user may be using our app

00:21:45,159 --> 00:21:52,059
from a mobile device and it might not be

00:21:48,489 --> 00:21:54,220
practical to do that so we decided to

00:21:52,059 --> 00:21:59,950
also save the queue to the client

00:21:54,220 --> 00:22:03,309
storage and that gives us as a bonus

00:21:59,950 --> 00:22:06,009
give us a building block that if we want

00:22:03,309 --> 00:22:08,799
to make our app work offline in the

00:22:06,009 --> 00:22:11,830
future because you know progressive web

00:22:08,799 --> 00:22:14,890
apps are becoming more popular each year

00:22:11,830 --> 00:22:16,809
so yeah that's a good bonus for for

00:22:14,890 --> 00:22:21,390
purchasing the cute to the clients

00:22:16,809 --> 00:22:27,160
knowledge but then a user may be running

00:22:21,390 --> 00:22:29,860
our app in multiple attempts so before

00:22:27,160 --> 00:22:32,140
we decide to purchase the queue there

00:22:29,860 --> 00:22:34,960
was no problem because each tap would

00:22:32,140 --> 00:22:35,710
have its own queue but now the queue is

00:22:34,960 --> 00:22:39,760
persistent

00:22:35,710 --> 00:22:42,490
so it become a shared mutable state here

00:22:39,760 --> 00:22:46,390
if every tap runs the queue at the same

00:22:42,490 --> 00:22:48,550
time bad things going to happen so that

00:22:46,390 --> 00:22:55,780
can be only one tab that runs this queue

00:22:48,550 --> 00:22:58,179
but which one so today with today's web

00:22:55,780 --> 00:23:00,580
technology we have shared web workers

00:22:58,179 --> 00:23:04,570
and also so its workers so we have two

00:23:00,580 --> 00:23:07,720
things so maybe we don't need any tap to

00:23:04,570 --> 00:23:13,240
run it at all we can just do it in the

00:23:07,720 --> 00:23:18,309
workers but today we also have this so I

00:23:13,240 --> 00:23:20,650
guess we cannot use the workers yet so

00:23:18,309 --> 00:23:23,740
we have to make it so that any tab can

00:23:20,650 --> 00:23:27,640
work on the queue if and only if no

00:23:23,740 --> 00:23:30,630
other tabs work on it but since our

00:23:27,640 --> 00:23:33,460
client side storage can be a synchronous

00:23:30,630 --> 00:23:36,309
there might be the case where more than

00:23:33,460 --> 00:23:40,000
one tab looking at the queue and saw

00:23:36,309 --> 00:23:46,660
that no one's running the queue and both

00:23:40,000 --> 00:23:50,170
decide to work on it so who wins and you

00:23:46,660 --> 00:23:52,030
know there can be only one tap working

00:23:50,170 --> 00:23:54,790
on the queue that's a hot requirement

00:23:52,030 --> 00:23:57,520
otherwise bad things going to happen so

00:23:54,790 --> 00:24:01,059
we use a shared client-side storage and

00:23:57,520 --> 00:24:04,090
have each I have each tap write its own

00:24:01,059 --> 00:24:08,050
ID to this storage and after allow

00:24:04,090 --> 00:24:11,440
really we read it back so the letters

00:24:08,050 --> 00:24:14,830
the latest have to write wins and the

00:24:11,440 --> 00:24:16,960
winning tap will periodically report its

00:24:14,830 --> 00:24:19,690
status to the shared storage so that

00:24:16,960 --> 00:24:21,190
other taps know that okay someone is

00:24:19,690 --> 00:24:23,140
taking care of the queue and it's due

00:24:21,190 --> 00:24:28,390
alive but

00:24:23,140 --> 00:24:31,660
if that tap somehow disappeared um maybe

00:24:28,390 --> 00:24:35,320
it maybe the user closed it maybe it

00:24:31,660 --> 00:24:37,990
crashed then that we have to set up a

00:24:35,320 --> 00:24:40,750
time out so that other taps could decide

00:24:37,990 --> 00:24:45,790
that well the tap that originally work

00:24:40,750 --> 00:24:49,840
on it has gone and can take over can

00:24:45,790 --> 00:24:55,590
take a word the work left from the

00:24:49,840 --> 00:24:59,830
previous tab so but what if the tap tap

00:24:55,590 --> 00:25:04,600
disappeared didn't didn't went away it

00:24:59,830 --> 00:25:07,240
just slept and it came back so we also

00:25:04,600 --> 00:25:09,610
have to handle the case where where

00:25:07,240 --> 00:25:12,790
where the cue has been taken away from

00:25:09,610 --> 00:25:15,250
the tap that is not dead so as you can

00:25:12,790 --> 00:25:17,860
see there was a lot of edge cases that

00:25:15,250 --> 00:25:21,850
we have to handle to make our app more

00:25:17,860 --> 00:25:25,540
resilient and to prevent data loss that

00:25:21,850 --> 00:25:28,240
brings me to the takeaway that first I

00:25:25,540 --> 00:25:31,809
didn't know that writing as the IUD apps

00:25:28,240 --> 00:25:34,049
would have to be this complex you know

00:25:31,809 --> 00:25:36,540
there's a lot of tutorials out there

00:25:34,049 --> 00:25:39,240
teaching you to like how to make a

00:25:36,540 --> 00:25:42,400
real-time to do application

00:25:39,240 --> 00:25:45,190
collaborative using let's say socket IO

00:25:42,400 --> 00:25:49,660
I have never seen any of them want me

00:25:45,190 --> 00:25:51,700
about this when so these are the

00:25:49,660 --> 00:25:55,299
problems we face when we try to build

00:25:51,700 --> 00:25:58,840
production quality apps and that's why I

00:25:55,299 --> 00:26:01,419
want to give this talk so much and the

00:25:58,840 --> 00:26:04,030
next takeaway is knowing your tools can

00:26:01,419 --> 00:26:07,240
help so there are higher level

00:26:04,030 --> 00:26:10,630
primitives that can help you write code

00:26:07,240 --> 00:26:16,419
that's free of race conditions there are

00:26:10,630 --> 00:26:20,559
some cloud cloud providers and SDKs that

00:26:16,419 --> 00:26:23,679
will take care of these problems to some

00:26:20,559 --> 00:26:25,960
extent some open source database are

00:26:23,679 --> 00:26:32,470
designed to be about to synchronize and

00:26:25,960 --> 00:26:34,059
work offline so sometimes if you can

00:26:32,470 --> 00:26:34,780
take advantage of them that's great

00:26:34,059 --> 00:26:37,750
you

00:26:34,780 --> 00:26:39,880
less problem to solve but sometimes your

00:26:37,750 --> 00:26:43,570
circumstance might prevent you from

00:26:39,880 --> 00:26:46,210
using the tools that you want and that's

00:26:43,570 --> 00:26:49,000
why in my opinion the most important

00:26:46,210 --> 00:26:52,860
thing the most important thing here is

00:26:49,000 --> 00:26:57,100
to become aware of the existence of this

00:26:52,860 --> 00:26:59,500
class of problems because even if you

00:26:57,100 --> 00:27:03,790
don't know the solutions or if you don't

00:26:59,500 --> 00:27:06,870
know the wish to to use at least you

00:27:03,790 --> 00:27:10,180
know that you should try to avoid it so

00:27:06,870 --> 00:27:13,240
to close this talk I would consider this

00:27:10,180 --> 00:27:16,000
talk success if you go home today and

00:27:13,240 --> 00:27:20,380
become more careful when you see the

00:27:16,000 --> 00:27:24,760
keyword await in your codebase you don't

00:27:20,380 --> 00:27:26,550
have to be paranoid just maybe just be

00:27:24,760 --> 00:27:30,790
aware that during an a wait

00:27:26,550 --> 00:27:35,850
anything could happen I don't know if

00:27:30,790 --> 00:27:37,930
that's paranoid or not but but and maybe

00:27:35,850 --> 00:27:39,760
when you test your app try

00:27:37,930 --> 00:27:44,800
double-clicking everything instead of

00:27:39,760 --> 00:27:48,400
single clicking and the next time you

00:27:44,800 --> 00:27:51,680
see all right there were a wait I hope

00:27:48,400 --> 00:27:54,900
you think about this talk thank you

00:27:51,680 --> 00:27:54,900

YouTube URL: https://www.youtube.com/watch?v=DWZj56qUNfs


