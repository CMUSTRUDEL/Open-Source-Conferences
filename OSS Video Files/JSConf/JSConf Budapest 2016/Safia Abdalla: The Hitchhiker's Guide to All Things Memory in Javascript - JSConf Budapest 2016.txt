Title: Safia Abdalla: The Hitchhiker's Guide to All Things Memory in Javascript - JSConf Budapest 2016
Publication date: 2016-06-09
Playlist: JSConf Budapest 2016
Description: 
	Unlike C and other low-level programming languages, Javascript takes away the pain of memory management and garbage collection from the programmer. However, this doesn't mean that developers shouldn't be aware of the memory management and garbage collection implementation details of the Javascript programming language. Indeed, knowledge of both of those things can go a long way towards improving the performance of code.

This talk will take beginners through an exploration of Javascript's garbage collector and memory allocation implementations and their implications on how performant code should be written. Attendees will leave this talk having gained insights into the under-the-hood operations of Javascript and how they can leverage them to produce performant code.

http://jsconfbp.com/speakers/safia-abdalla.html
Captions: 
	00:00:10,900 --> 00:00:19,670
okay um so the errand is flaky so we'll

00:00:16,460 --> 00:00:22,010
see if I can get through this talk um so

00:00:19,670 --> 00:00:24,320
as Jake so eloquently mentioned I am

00:00:22,010 --> 00:00:30,470
Sofia and I'm here to talk to you about

00:00:24,320 --> 00:00:33,020
memory management and JavaScript if

00:00:30,470 --> 00:00:34,790
you're sitting in the back or you can't

00:00:33,020 --> 00:00:37,790
see the screen or for whatever reason

00:00:34,790 --> 00:00:43,399
you can follow along with the talk at

00:00:37,790 --> 00:00:45,170
JMP /j s - ma'am - live and you'll just

00:00:43,399 --> 00:00:55,460
automatically see everything but also

00:00:45,170 --> 00:01:02,200
the internet is down so you can't it's

00:00:55,460 --> 00:01:02,200
not moving I'm sorry guys this is no fun

00:01:04,239 --> 00:01:07,290
it's reconnecting

00:01:10,330 --> 00:01:15,880
is so awkward oh my god

00:01:17,229 --> 00:01:24,950
I'm not worried I could do this thing

00:01:21,290 --> 00:01:27,460
just without slides but that wouldn't be

00:01:24,950 --> 00:01:27,460
fun Oh

00:01:39,240 --> 00:01:48,390
I actually can't do this thing about

00:01:40,860 --> 00:01:54,500
slides yes do we have Ethernet I could

00:01:48,390 --> 00:02:00,470
tell jokes in the meantime knock-knock

00:01:54,500 --> 00:02:00,470
King Tut King Chucky fried chicken

00:02:00,590 --> 00:02:11,430
what does it web developers ghosts a

00:02:04,280 --> 00:02:14,510
Twitter bootstrap I was going to come on

00:02:11,430 --> 00:02:17,760
stage and help but you've got this rao's

00:02:14,510 --> 00:02:21,540
the faster he works the quicker this

00:02:17,760 --> 00:02:25,160
torture will be over let's see if I can

00:02:21,540 --> 00:02:27,690
remember another one oh god I can't even

00:02:25,160 --> 00:02:29,250
have any good memory bank banter what's

00:02:27,690 --> 00:02:38,489
your what's your favorite memory address

00:02:29,250 --> 00:02:40,319
oh my god so you see if you have you've

00:02:38,489 --> 00:02:42,150
been able to use the chrome dev tools in

00:02:40,319 --> 00:02:44,010
terms of memory cleanup wow you are the

00:02:42,150 --> 00:02:46,220
only person in the world who can use

00:02:44,010 --> 00:02:48,989
that that's amazing believe it or not um

00:02:46,220 --> 00:02:50,459
once this is set up you guys are

00:02:48,989 --> 00:02:52,920
actually going to be getting the

00:02:50,459 --> 00:02:55,200
opportunity to interact with the chrome

00:02:52,920 --> 00:02:57,269
dev tools a bit more I created a

00:02:55,200 --> 00:02:58,829
tutorial an interactive tutorial for

00:02:57,269 --> 00:03:00,750
everyone at the conference to follow

00:02:58,829 --> 00:03:03,510
along with to learn how to use dev tools

00:03:00,750 --> 00:03:04,739
I always find that it's one of the

00:03:03,510 --> 00:03:07,079
reasons that I kind of stay away from

00:03:04,739 --> 00:03:08,579
like the kind of single page app push

00:03:07,079 --> 00:03:11,160
State stuff because I think no matter

00:03:08,579 --> 00:03:12,780
how bad I handle memory I know I'm one

00:03:11,160 --> 00:03:16,920
navigation away from it all being

00:03:12,780 --> 00:03:20,480
cleared and starting again awesome okay

00:03:16,920 --> 00:03:20,480
right I'll go away bye bye

00:03:21,520 --> 00:03:29,380
okay awesome uh so I'm Safi as I already

00:03:26,680 --> 00:03:31,480
mentioned my two passions in life are

00:03:29,380 --> 00:03:33,670
data science for social good and open

00:03:31,480 --> 00:03:35,560
source software and if you're interested

00:03:33,670 --> 00:03:37,330
in learning more about that or the open

00:03:35,560 --> 00:03:40,720
source work that I'm doing I'm captain

00:03:37,330 --> 00:03:45,040
Sofia on Twitter and github and NPM um

00:03:40,720 --> 00:03:47,200
and like MySpace and Friendster and all

00:03:45,040 --> 00:03:51,010
the stuff and Sophia don't rocks is my

00:03:47,200 --> 00:03:52,810
website so what are we going to be

00:03:51,010 --> 00:03:54,280
talking about today I just want to give

00:03:52,810 --> 00:03:58,180
you a quick outline of what you guys are

00:03:54,280 --> 00:03:59,800
getting yourselves into so first I'm

00:03:58,180 --> 00:04:02,050
going to talk a little bit about why we

00:03:59,800 --> 00:04:03,730
should care about memory as software

00:04:02,050 --> 00:04:05,530
engineers whether you're working in the

00:04:03,730 --> 00:04:06,700
client-side with JavaScript or the

00:04:05,530 --> 00:04:11,190
server-side I'm going to give you

00:04:06,700 --> 00:04:13,270
reasons to think about memory first and

00:04:11,190 --> 00:04:15,250
then we're going to talk about what it

00:04:13,270 --> 00:04:16,600
means to manage memory and for those of

00:04:15,250 --> 00:04:18,790
you who might have computer science

00:04:16,600 --> 00:04:22,180
degrees this is going to be a throwback

00:04:18,790 --> 00:04:23,860
to your systems or compilers courses so

00:04:22,180 --> 00:04:25,960
I'm sorry if I'm bringing up very

00:04:23,860 --> 00:04:29,680
horrifying flashbacks right now please

00:04:25,960 --> 00:04:31,570
bear with me and then we're going to

00:04:29,680 --> 00:04:35,500
talk it all in particular about how

00:04:31,570 --> 00:04:37,450
JavaScript manages memory and then we'll

00:04:35,500 --> 00:04:39,580
finish it off with how we can write

00:04:37,450 --> 00:04:41,080
memory performant applications but what

00:04:39,580 --> 00:04:45,100
are some tools and techniques that you

00:04:41,080 --> 00:04:47,440
folks can use and once all that is done

00:04:45,100 --> 00:04:51,640
you will be wizards and witches of

00:04:47,440 --> 00:04:56,650
JavaScript after battling the Dark Lord

00:04:51,640 --> 00:04:58,540
of memory leaks um so first why do we

00:04:56,650 --> 00:05:00,310
care about memory why is memory

00:04:58,540 --> 00:05:02,860
important to us as programmers and these

00:05:00,310 --> 00:05:06,580
are three very bias reasons that I have

00:05:02,860 --> 00:05:08,410
for caring about memory the first is

00:05:06,580 --> 00:05:10,960
that it forces us to be more inventive

00:05:08,410 --> 00:05:13,270
programmers I always think it's great to

00:05:10,960 --> 00:05:15,160
add restrictions to the way that we

00:05:13,270 --> 00:05:17,410
develop our software because it forces

00:05:15,160 --> 00:05:20,740
us to reason critically of our our

00:05:17,410 --> 00:05:22,390
applications to analyze and debug things

00:05:20,740 --> 00:05:25,750
and use tools like the chrome dev tools

00:05:22,390 --> 00:05:27,370
and to build better there's no way to

00:05:25,750 --> 00:05:30,690
get somebody more creative and inventive

00:05:27,370 --> 00:05:32,800
than by locking them in a dark room or

00:05:30,690 --> 00:05:33,960
by placing them in the middle of the

00:05:32,800 --> 00:05:35,910
Sahara in 100

00:05:33,960 --> 00:05:39,949
degree weather with no Wi-Fi and having

00:05:35,910 --> 00:05:39,949
them code ask me about that later

00:05:41,850 --> 00:05:46,530
memory is scarce and although the amount

00:05:44,789 --> 00:05:48,900
of memory that's available on machines

00:05:46,530 --> 00:05:52,289
has been increasing over the past couple

00:05:48,900 --> 00:05:54,960
of decades so have people's expectations

00:05:52,289 --> 00:05:57,270
of what their machines can do your users

00:05:54,960 --> 00:05:59,060
expect your applications to be able to

00:05:57,270 --> 00:06:03,180
handle their multitasking workflows

00:05:59,060 --> 00:06:05,190
users expect and deserve really rich

00:06:03,180 --> 00:06:06,419
interactive web experience and those

00:06:05,190 --> 00:06:11,340
things tend to be really memory

00:06:06,419 --> 00:06:13,620
intensive and then finally it helps us

00:06:11,340 --> 00:06:16,310
exercise our empathy muscles I view

00:06:13,620 --> 00:06:18,690
empathy as a muscle that you can train

00:06:16,310 --> 00:06:20,580
in thinking about the different

00:06:18,690 --> 00:06:22,259
conditions that your program is going to

00:06:20,580 --> 00:06:25,080
be used in or your application is going

00:06:22,259 --> 00:06:26,610
to be used in in the context of memories

00:06:25,080 --> 00:06:28,259
a really great way for you to discover

00:06:26,610 --> 00:06:31,729
new user stories and start to think

00:06:28,259 --> 00:06:31,729
about how your applications being used

00:06:32,479 --> 00:06:38,909
so now that we have a couple of reasons

00:06:36,810 --> 00:06:41,280
to care about memory management let's go

00:06:38,909 --> 00:06:45,800
a brief overview of what memory

00:06:41,280 --> 00:06:48,449
management is so if you programmed in C

00:06:45,800 --> 00:06:51,900
you are familiar with a paradigm known

00:06:48,449 --> 00:06:54,240
as manual memory management what that

00:06:51,900 --> 00:06:56,310
means is that you as the programmer had

00:06:54,240 --> 00:06:58,620
to allocate memory on the machine using

00:06:56,310 --> 00:07:00,860
malloc then you were done with it you're

00:06:58,620 --> 00:07:03,570
responsible for freeing it using free

00:07:00,860 --> 00:07:06,030
now there's a fundamental issue with

00:07:03,570 --> 00:07:08,580
that and it's that this is a huge

00:07:06,030 --> 00:07:10,919
cognitive load on you as the engineer

00:07:08,580 --> 00:07:14,099
you can imagine in addition to having

00:07:10,919 --> 00:07:15,900
top-down missing semicolons and arguing

00:07:14,099 --> 00:07:17,880
over where you place your curly braces

00:07:15,900 --> 00:07:19,830
and thinking about algorithm design and

00:07:17,880 --> 00:07:22,440
software architecture you have this

00:07:19,830 --> 00:07:23,639
additional cognitive load of managing

00:07:22,440 --> 00:07:26,039
the memory of your application and

00:07:23,639 --> 00:07:29,639
actively thinking about it so you can

00:07:26,039 --> 00:07:31,800
imagine software written this way has

00:07:29,639 --> 00:07:35,180
lots of memory leaks has lots of other

00:07:31,800 --> 00:07:39,180
memory related bugs no fun for anybody

00:07:35,180 --> 00:07:41,580
and that's where the concept of

00:07:39,180 --> 00:07:43,289
automated memory management comes in

00:07:41,580 --> 00:07:46,639
it's known as the garbage collector this

00:07:43,289 --> 00:07:49,789
is Oscar the Grouch from Sesame Street

00:07:46,639 --> 00:07:52,039
um and the garbage collector is really

00:07:49,789 --> 00:07:54,680
in charge of finding out where garbage

00:07:52,039 --> 00:07:56,439
memory is and then clearing it away and

00:07:54,680 --> 00:08:01,550
we'll get into that a little bit later

00:07:56,439 --> 00:08:04,639
an automated memory management has its

00:08:01,550 --> 00:08:07,310
pros and consequences the first big Pro

00:08:04,639 --> 00:08:09,139
really for us as engineers is we don't

00:08:07,310 --> 00:08:12,919
have that cognitive load of having to

00:08:09,139 --> 00:08:14,810
manage memory on our own the consequence

00:08:12,919 --> 00:08:17,599
is that the garbage collector is an

00:08:14,810 --> 00:08:20,000
application it's another program that

00:08:17,599 --> 00:08:21,879
runs in order to clear your memory so it

00:08:20,000 --> 00:08:23,750
does have a performance endurance and

00:08:21,879 --> 00:08:25,669
depending on how good your memory

00:08:23,750 --> 00:08:27,590
allocator is and what technique it's

00:08:25,669 --> 00:08:34,219
using that hindrance might not be as bad

00:08:27,590 --> 00:08:35,930
that is still a consequence also so now

00:08:34,219 --> 00:08:37,459
we talked about memory management and

00:08:35,930 --> 00:08:39,500
we're going to cover it in JavaScript

00:08:37,459 --> 00:08:46,010
really quickly is everyone with me so

00:08:39,500 --> 00:08:47,510
far oh yeah get hyped so for the rest of

00:08:46,010 --> 00:08:50,709
this talk I'm really going to be

00:08:47,510 --> 00:08:53,420
focusing on the v8 JavaScript engine um

00:08:50,709 --> 00:08:55,899
we're all pretty familiar with it if you

00:08:53,420 --> 00:08:57,560
use Chrome that's the thing that's

00:08:55,899 --> 00:09:00,380
interpreting and executing your code

00:08:57,560 --> 00:09:03,370
you're using node or MongoDB on the

00:09:00,380 --> 00:09:06,079
server side it's responsible there so um

00:09:03,370 --> 00:09:07,820
sorry for all the other JavaScript

00:09:06,079 --> 00:09:13,339
engines who won't be getting any love

00:09:07,820 --> 00:09:14,630
from me today but v8 swear it's up so

00:09:13,339 --> 00:09:16,699
let's start off by going through the

00:09:14,630 --> 00:09:18,470
basic data types in Java Script I'm

00:09:16,699 --> 00:09:21,079
going to start off really easy and then

00:09:18,470 --> 00:09:23,300
like ramp it up super fast so if you're

00:09:21,079 --> 00:09:26,060
boole's right you're trues your falses

00:09:23,300 --> 00:09:28,220
your numbers your one two threes any of

00:09:26,060 --> 00:09:33,709
your strings your hello worlds and your

00:09:28,220 --> 00:09:35,839
man cats and all that and all of these

00:09:33,709 --> 00:09:37,519
are the sort of elements in the

00:09:35,839 --> 00:09:39,890
JavaScript universe and they can be

00:09:37,519 --> 00:09:42,380
combined to form different compounds and

00:09:39,890 --> 00:09:45,410
molecules in your application these are

00:09:42,380 --> 00:09:48,410
really the basics and where that becomes

00:09:45,410 --> 00:09:51,440
relevant is how memory is allocated

00:09:48,410 --> 00:09:54,350
memory is allocated in a heap structure

00:09:51,440 --> 00:09:56,769
so it looks something like this so the

00:09:54,350 --> 00:09:59,620
read node you see there is the root node

00:09:56,769 --> 00:10:03,140
this is something like the window object

00:09:59,620 --> 00:10:05,000
the root node has edges pointing to

00:10:03,140 --> 00:10:07,490
other nodes in this case the blue nodes

00:10:05,000 --> 00:10:09,319
and the green nodes the green nodes in

00:10:07,490 --> 00:10:11,990
this particular case are your boolean's

00:10:09,319 --> 00:10:14,660
your numbers and your strengths those

00:10:11,990 --> 00:10:16,970
fundamental elements the blues are

00:10:14,660 --> 00:10:18,649
references to those things so this is

00:10:16,970 --> 00:10:21,649
what memory looks like it's definitely a

00:10:18,649 --> 00:10:27,050
giant heap which is why Jake made that

00:10:21,649 --> 00:10:29,360
joke earlier and v8 does something where

00:10:27,050 --> 00:10:32,690
allocates memory into six different

00:10:29,360 --> 00:10:34,519
spaces or chunks and there's sort of a

00:10:32,690 --> 00:10:35,750
method to the madness of why it does

00:10:34,519 --> 00:10:38,930
this and we're going to find out why

00:10:35,750 --> 00:10:40,399
later I hope I'm keeping you on the edge

00:10:38,930 --> 00:10:41,810
of your seats with all this like we'll

00:10:40,399 --> 00:10:46,089
find out later try to keep you guys

00:10:41,810 --> 00:10:48,290
excited so let's talk a little bit

00:10:46,089 --> 00:10:51,199
different kinds of spaces so the first

00:10:48,290 --> 00:10:53,899
space is the new space this is where

00:10:51,199 --> 00:10:55,850
memory gets allocated when an object is

00:10:53,899 --> 00:10:59,470
immediately created objects in the new

00:10:55,850 --> 00:11:03,230
space tend to be smaller they're newer

00:10:59,470 --> 00:11:05,810
new space your next space is the old

00:11:03,230 --> 00:11:08,029
pointer space so if an object is in the

00:11:05,810 --> 00:11:10,430
new space and it's a reference to an

00:11:08,029 --> 00:11:12,290
object it's not a scalar itself and it's

00:11:10,430 --> 00:11:15,019
resided in the new space for a while

00:11:12,290 --> 00:11:18,050
it's been actively used it graduates the

00:11:15,019 --> 00:11:21,019
old pointer space and if it's not a

00:11:18,050 --> 00:11:26,329
reference the scalar graduates to the

00:11:21,019 --> 00:11:28,220
old data space and then you have the

00:11:26,329 --> 00:11:31,040
large object space this is where you

00:11:28,220 --> 00:11:33,019
store giant look-up tables and things

00:11:31,040 --> 00:11:34,760
that don't you don't want to fall under

00:11:33,019 --> 00:11:38,779
the memory restrictions or the size

00:11:34,760 --> 00:11:42,800
restrictions of the new old end of the

00:11:38,779 --> 00:11:45,649
new and old space and then you have the

00:11:42,800 --> 00:11:46,699
code space the code space is special

00:11:45,649 --> 00:11:49,699
because it contains

00:11:46,699 --> 00:11:52,040
executable memory memory on your machine

00:11:49,699 --> 00:11:53,600
by default is not executable because you

00:11:52,040 --> 00:11:55,459
don't want to go around just running

00:11:53,600 --> 00:12:00,680
whatever data is on your memory that

00:11:55,459 --> 00:12:02,120
would not be good and so items in the

00:12:00,680 --> 00:12:05,600
code space are generally get

00:12:02,120 --> 00:12:07,880
instructions just-in-time compiled and

00:12:05,600 --> 00:12:11,209
then the last space is the map space and

00:12:07,880 --> 00:12:11,660
this contains maps property cells and

00:12:11,209 --> 00:12:13,870
cell

00:12:11,660 --> 00:12:16,610
these are used by the JavaScript engine

00:12:13,870 --> 00:12:18,680
and really for the rest of this talk

00:12:16,610 --> 00:12:21,410
we're going to focus on two spaces the

00:12:18,680 --> 00:12:23,060
new space in the old space so you can

00:12:21,410 --> 00:12:24,530
kind of forget about the rest and you

00:12:23,060 --> 00:12:29,060
can treat it as like fun stuff you

00:12:24,530 --> 00:12:33,100
learned so this point we've allocated

00:12:29,060 --> 00:12:33,100
objects in memory they're in our heap

00:12:33,430 --> 00:12:41,660
how do we know what to clean and how to

00:12:37,220 --> 00:12:45,830
clean it and really the answer and the

00:12:41,660 --> 00:12:47,600
basis for this is reach ability memory

00:12:45,830 --> 00:12:49,550
is considered garbage when it's no

00:12:47,600 --> 00:12:53,990
longer reachable or accessible in your

00:12:49,550 --> 00:12:56,960
code this usually tends to be data that

00:12:53,990 --> 00:12:59,150
is not reserved for local variables or

00:12:56,960 --> 00:13:03,260
function parameters or global variables

00:12:59,150 --> 00:13:05,150
if you look back into the heap the way

00:13:03,260 --> 00:13:07,580
that we can determine what is considered

00:13:05,150 --> 00:13:09,500
garbage is by traversing through our

00:13:07,580 --> 00:13:12,140
heap so you can start off at the root

00:13:09,500 --> 00:13:14,440
node anything that you can access by

00:13:12,140 --> 00:13:16,750
traveling through nodes in the heap is

00:13:14,440 --> 00:13:18,920
considered accessible and reachable

00:13:16,750 --> 00:13:22,700
things that you can access are not

00:13:18,920 --> 00:13:30,610
reachable in their garbage so these two

00:13:22,700 --> 00:13:32,870
your out garbage but how exactly does

00:13:30,610 --> 00:13:35,990
JavaScript collect garbage or the v8

00:13:32,870 --> 00:13:37,460
engine collect garbage we know how the

00:13:35,990 --> 00:13:39,430
allocates memory we know what it

00:13:37,460 --> 00:13:44,540
considers garbage how does it collect it

00:13:39,430 --> 00:13:46,790
and the v8 engine employs something

00:13:44,540 --> 00:13:48,350
called stop the world technique for

00:13:46,790 --> 00:13:53,140
garbage collection and so what happens

00:13:48,350 --> 00:13:58,850
is programs halted like complete stop

00:13:53,140 --> 00:14:00,800
and then there's a pause and that pause

00:13:58,850 --> 00:14:03,710
there's a moment where the garbage

00:14:00,800 --> 00:14:05,870
collector runs and it's a brief short

00:14:03,710 --> 00:14:07,310
cycle and that's really to offset that

00:14:05,870 --> 00:14:09,370
performance hindrance so you're just

00:14:07,310 --> 00:14:13,670
running quick garbage collection cycles

00:14:09,370 --> 00:14:15,610
in pauses in between your program this

00:14:13,670 --> 00:14:19,540
next step is going to be a perfect

00:14:15,610 --> 00:14:19,540
representation of what this means

00:14:19,940 --> 00:14:25,190
yes we've all seen this um so if you

00:14:23,210 --> 00:14:29,900
remember earlier we talked about the new

00:14:25,190 --> 00:14:32,270
space and the old space and so when you

00:14:29,900 --> 00:14:34,820
start to go through these garbage

00:14:32,270 --> 00:14:36,980
collection cycles the v8 engine has

00:14:34,820 --> 00:14:39,170
different approaches to how it collects

00:14:36,980 --> 00:14:42,470
garbage in the new space and how it

00:14:39,170 --> 00:14:44,540
collects garbage in the old space so

00:14:42,470 --> 00:14:51,620
we'll start off by talking about how it

00:14:44,540 --> 00:14:54,920
collects garbage in the new space and

00:14:51,620 --> 00:14:57,530
and before I go there this sort of idea

00:14:54,920 --> 00:15:02,060
of having a different garbage collection

00:14:57,530 --> 00:15:03,770
approach to old memory or and to old

00:15:02,060 --> 00:15:07,340
data versus new data is known as a

00:15:03,770 --> 00:15:08,750
generational garbage collector just

00:15:07,340 --> 00:15:10,430
think you're kind of like approaching

00:15:08,750 --> 00:15:12,140
the age of your memory in-app

00:15:10,430 --> 00:15:20,210
generations and you're treating each one

00:15:12,140 --> 00:15:23,390
differently and so let's talk about how

00:15:20,210 --> 00:15:25,730
garbage is collected in the new space

00:15:23,390 --> 00:15:29,660
and it's a process known as scavenging

00:15:25,730 --> 00:15:31,640
and so generally memory and the new

00:15:29,660 --> 00:15:33,410
space is collected more quickly than

00:15:31,640 --> 00:15:34,430
memory in the old space just because

00:15:33,410 --> 00:15:37,460
it's newer

00:15:34,430 --> 00:15:40,670
um and what tends to happen is when your

00:15:37,460 --> 00:15:42,380
new space is filled the v8 engines going

00:15:40,670 --> 00:15:44,930
to go ahead and start a scavenging

00:15:42,380 --> 00:15:47,120
garbage collection cycle in the new

00:15:44,930 --> 00:15:49,670
space and what happens in this Gavan

00:15:47,120 --> 00:15:51,580
process is your garbage collector is

00:15:49,670 --> 00:15:53,870
going to go through your entire heap

00:15:51,580 --> 00:15:56,420
it's going to traverse it starting from

00:15:53,870 --> 00:15:59,570
the route it's going to make copies of

00:15:56,420 --> 00:16:01,670
everything that it traverses and it's

00:15:59,570 --> 00:16:05,150
going to clear out what was previously

00:16:01,670 --> 00:16:07,400
in the new space and so the copies it

00:16:05,150 --> 00:16:09,610
has made is everything that it could

00:16:07,400 --> 00:16:11,510
reach in a traversal of the heap and

00:16:09,610 --> 00:16:13,340
everything that I couldn't reach and

00:16:11,510 --> 00:16:17,000
couldn't copy is considered garbage

00:16:13,340 --> 00:16:18,320
memory so that's okay now for those of

00:16:17,000 --> 00:16:20,000
you are paying attention to how this

00:16:18,320 --> 00:16:22,130
technique works you might realize the

00:16:20,000 --> 00:16:24,940
fundamental problem with it which is

00:16:22,130 --> 00:16:28,340
that it has a very high space complexity

00:16:24,940 --> 00:16:30,140
you need to have double the amount of

00:16:28,340 --> 00:16:32,050
memory that is the size of your new

00:16:30,140 --> 00:16:34,749
space for that copying over

00:16:32,050 --> 00:16:36,610
and this might be a kind of

00:16:34,749 --> 00:16:40,420
consequential thing but is if you recall

00:16:36,610 --> 00:16:42,639
the data in the new space is younger

00:16:40,420 --> 00:16:44,290
smaller data so the sort of fact that

00:16:42,639 --> 00:16:48,670
you need double the size of the new

00:16:44,290 --> 00:16:54,489
space is not that big a deal so if we go

00:16:48,670 --> 00:16:57,699
back to our lovely memory heap we're

00:16:54,489 --> 00:17:00,249
going to start off at the red root node

00:16:57,699 --> 00:17:02,319
and then traverse over to the blue and

00:17:00,249 --> 00:17:04,720
then go over to the two blues and then

00:17:02,319 --> 00:17:07,029
go over to the greens and our garbage

00:17:04,720 --> 00:17:08,620
nodes are never traversed and they're

00:17:07,029 --> 00:17:11,799
never each and they're never copied over

00:17:08,620 --> 00:17:17,860
and they're just like obliterated into

00:17:11,799 --> 00:17:19,870
nothingness and then for the old data

00:17:17,860 --> 00:17:21,939
space um there's a different technique

00:17:19,870 --> 00:17:26,409
that's gets used and it's the mark and

00:17:21,939 --> 00:17:28,899
sweep technique and the mark and sweep

00:17:26,409 --> 00:17:31,960
technique works by traversing the nodes

00:17:28,899 --> 00:17:34,270
in the heap marking the ones that are

00:17:31,960 --> 00:17:36,669
active and then removing unmarked

00:17:34,270 --> 00:17:39,610
objects on a regular basis and I know

00:17:36,669 --> 00:17:42,700
that was a super cryptic description and

00:17:39,610 --> 00:17:44,260
I could like for you guys right now with

00:17:42,700 --> 00:17:47,980
an entire discussion on mark-and-sweep

00:17:44,260 --> 00:17:50,770
um but I want you to stay my friends I

00:17:47,980 --> 00:17:53,639
really hope you do ah so I won't torture

00:17:50,770 --> 00:17:56,279
you that way but in all seriousness

00:17:53,639 --> 00:18:00,520
mark-and-sweep has a very rich history

00:17:56,279 --> 00:18:02,409
in computing and it merits its own 30

00:18:00,520 --> 00:18:04,659
minute maybe 45 minute talk if the

00:18:02,409 --> 00:18:07,630
organizers will let me but if you guys

00:18:04,659 --> 00:18:08,799
just want to grab me during lunch maybe

00:18:07,630 --> 00:18:12,190
do it tomorrow because I'm still

00:18:08,799 --> 00:18:17,889
jet-lagged but yes I'm happy to talk

00:18:12,190 --> 00:18:21,460
about it so at this point you're almost

00:18:17,889 --> 00:18:23,409
almost masters of memory management or

00:18:21,460 --> 00:18:25,840
JavaScript you have an understanding of

00:18:23,409 --> 00:18:27,750
why we care about it what memory

00:18:25,840 --> 00:18:30,639
management is in a general perspective

00:18:27,750 --> 00:18:33,610
how it works in JavaScript how the v8

00:18:30,639 --> 00:18:36,370
garbage collector works now you want to

00:18:33,610 --> 00:18:39,100
start to apply these and only the best

00:18:36,370 --> 00:18:43,169
way to approach this is to start by

00:18:39,100 --> 00:18:43,169
asking yourself two simple questions

00:18:43,820 --> 00:18:48,630
which is how much memory is my

00:18:46,650 --> 00:18:51,270
application using and you're never going

00:18:48,630 --> 00:18:55,260
to get a solid quantified answer for

00:18:51,270 --> 00:18:57,870
this because that's not how it works but

00:18:55,260 --> 00:18:59,880
you can start to develop ranges you can

00:18:57,870 --> 00:19:01,200
start develop metrics with how much

00:18:59,880 --> 00:19:03,900
memory you're comfortable with having

00:19:01,200 --> 00:19:05,700
your application use and when you

00:19:03,900 --> 00:19:08,549
develop these metrics it's important to

00:19:05,700 --> 00:19:11,580
consider that your application runs in

00:19:08,549 --> 00:19:14,400
the context of other applications so

00:19:11,580 --> 00:19:16,320
like all eight gigabytes of memory or

00:19:14,400 --> 00:19:18,659
all four gigabytes of memory on a

00:19:16,320 --> 00:19:21,630
machine like belong to you entirely

00:19:18,659 --> 00:19:23,130
which is sad you're sharing these lots

00:19:21,630 --> 00:19:26,490
of other applications if you've seen

00:19:23,130 --> 00:19:27,750
people use like 48 tabs in their Chrome

00:19:26,490 --> 00:19:31,770
browser and you're like why do you

00:19:27,750 --> 00:19:33,539
torture your browser like that you have

00:19:31,770 --> 00:19:38,070
to like share memory with all of the

00:19:33,539 --> 00:19:39,539
other taps that they have open and the

00:19:38,070 --> 00:19:41,720
second question that you want to ask is

00:19:39,539 --> 00:19:44,730
how often does the garbage collector

00:19:41,720 --> 00:19:46,740
cycle in my application how often does

00:19:44,730 --> 00:19:48,539
it run and you can actually find this

00:19:46,740 --> 00:19:51,570
out all I don't have pictures of it in

00:19:48,539 --> 00:19:55,740
my talk but if you use the chrome dev

00:19:51,570 --> 00:19:57,000
tools timeline tab thing that shows all

00:19:55,740 --> 00:20:01,049
the stuff that's happening in your

00:19:57,000 --> 00:20:03,240
application Jake will explain later you

00:20:01,049 --> 00:20:05,510
can actually find when garbage

00:20:03,240 --> 00:20:07,230
collection cycles are running in your

00:20:05,510 --> 00:20:08,880
application you can determine how

00:20:07,230 --> 00:20:11,520
frequently they're occurring that might

00:20:08,880 --> 00:20:13,260
be symptomatic of how fast stuff is

00:20:11,520 --> 00:20:16,020
allocating in the new space so if you're

00:20:13,260 --> 00:20:17,549
like aggressively allocating new memory

00:20:16,020 --> 00:20:20,700
and a loop or something like that you

00:20:17,549 --> 00:20:23,970
might want optimize that there's like

00:20:20,700 --> 00:20:26,659
stuff you can do that brings us to the

00:20:23,970 --> 00:20:29,250
right tools for really messy job

00:20:26,659 --> 00:20:31,530
debugging memory is no fun like I'm

00:20:29,250 --> 00:20:36,299
surprised most of you are still engaged

00:20:31,530 --> 00:20:41,070
in this talk way to go good job but good

00:20:36,299 --> 00:20:45,059
tools can make it much easier and so the

00:20:41,070 --> 00:20:45,900
first awesome tool once again in chrome

00:20:45,059 --> 00:20:48,510
dev tools

00:20:45,900 --> 00:20:50,340
there's tons of awesome tools and chrome

00:20:48,510 --> 00:20:52,559
dev tools mostly because the folks at

00:20:50,340 --> 00:20:53,100
Google are building lots of very memory

00:20:52,559 --> 00:20:55,919
intense

00:20:53,100 --> 00:20:57,870
applications things like Gmail things

00:20:55,919 --> 00:20:59,910
like Google Drive and so you know if the

00:20:57,870 --> 00:21:03,030
like Google Drive team or the Gmail team

00:20:59,910 --> 00:21:05,429
is like and we need tools to like debug

00:21:03,030 --> 00:21:07,950
figure out memory in our applications

00:21:05,429 --> 00:21:09,179
they'll like go go bug the chrome team

00:21:07,950 --> 00:21:12,030
and the chrome team will be all like

00:21:09,179 --> 00:21:14,090
alright we're at your service and so the

00:21:12,030 --> 00:21:18,480
result is that there's a rich toolset

00:21:14,090 --> 00:21:20,880
for inspecting heap allocation and for

00:21:18,480 --> 00:21:23,190
examining and profiling our applications

00:21:20,880 --> 00:21:27,150
and dev tools yeah that's great for us

00:21:23,190 --> 00:21:30,570
as programmers and so this is a snapshot

00:21:27,150 --> 00:21:32,640
that I took of the chrome dev tools heap

00:21:30,570 --> 00:21:35,549
allocation profiler running on the

00:21:32,640 --> 00:21:37,799
Facebook web application and there's

00:21:35,549 --> 00:21:40,650
sort of two curious things that I want

00:21:37,799 --> 00:21:43,080
to point everyone to which are the

00:21:40,650 --> 00:21:44,789
retained size and the shallow size of an

00:21:43,080 --> 00:21:47,640
object and you'll see these mentioned a

00:21:44,789 --> 00:21:49,440
lot when you start to like independently

00:21:47,640 --> 00:21:52,950
research memory management because I got

00:21:49,440 --> 00:21:55,559
you so excited about it the shallow size

00:21:52,950 --> 00:21:58,740
of an object is the amount of memory

00:21:55,559 --> 00:22:02,280
that it holds in and of itself and the

00:21:58,740 --> 00:22:03,870
retained size is its size and all of its

00:22:02,280 --> 00:22:05,490
dependents if it's pointing to anything

00:22:03,870 --> 00:22:08,640
in the heap structure it's all of those

00:22:05,490 --> 00:22:14,190
and the chrome dev tools allows you to

00:22:08,640 --> 00:22:17,460
see that oh my god there's there had to

00:22:14,190 --> 00:22:19,380
be an NPM command and this after load is

00:22:17,460 --> 00:22:21,900
talk yay

00:22:19,380 --> 00:22:23,970
another great thing about having tools

00:22:21,900 --> 00:22:26,190
like NPM available to us is that people

00:22:23,970 --> 00:22:28,110
can build utilities to help other

00:22:26,190 --> 00:22:30,929
programmers do their stuff and things

00:22:28,110 --> 00:22:33,299
better and so we're all happy people as

00:22:30,929 --> 00:22:38,190
a particular utility that I want to

00:22:33,299 --> 00:22:41,190
showcase here is called heap dump um

00:22:38,190 --> 00:22:43,260
heap dump is a JavaScript library that

00:22:41,190 --> 00:22:46,230
you can install for node and it allows

00:22:43,260 --> 00:22:48,570
you to take a snapshot of your heap at a

00:22:46,230 --> 00:22:50,460
particular instance and it's a super

00:22:48,570 --> 00:22:52,320
easy to use library it's got a very

00:22:50,460 --> 00:22:54,480
simple API there's only like one

00:22:52,320 --> 00:22:57,840
function that exports which is write

00:22:54,480 --> 00:22:59,520
snapshot what you can do is you can take

00:22:57,840 --> 00:23:02,400
a snapshot of your application at a

00:22:59,520 --> 00:23:03,990
particular instant and you'll get a file

00:23:02,400 --> 00:23:05,520
with a dot heap snapshot

00:23:03,990 --> 00:23:08,640
extension and then you can actually load

00:23:05,520 --> 00:23:10,530
it into the chrome dev tools profiler

00:23:08,640 --> 00:23:12,150
and start to analyze it inside that

00:23:10,530 --> 00:23:14,370
really awesome interface that the team

00:23:12,150 --> 00:23:17,760
at chrome built instead of reading the

00:23:14,370 --> 00:23:18,960
like raw Heath snapshot file don't don't

00:23:17,760 --> 00:23:25,350
do that that's not smart

00:23:18,960 --> 00:23:27,920
spare yourself the trouble awesome so

00:23:25,350 --> 00:23:30,540
I'm going to try and stay on time um

00:23:27,920 --> 00:23:32,610
here with four minutes left

00:23:30,540 --> 00:23:37,410
I mentioned that I put together a

00:23:32,610 --> 00:23:41,660
resource for everyone here today ah that

00:23:37,410 --> 00:23:46,410
I will show off now um

00:23:41,660 --> 00:23:49,040
awesome okay hopefully everyone can see

00:23:46,410 --> 00:23:52,530
this awesome so this is just a

00:23:49,040 --> 00:23:54,270
interactive experience that I set up and

00:23:52,530 --> 00:23:58,290
it starts off with the very basic

00:23:54,270 --> 00:24:00,950
console logging things um and you start

00:23:58,290 --> 00:24:03,330
to get familiar with the heap dump tool

00:24:00,950 --> 00:24:05,160
in writing snapshots and there are some

00:24:03,330 --> 00:24:06,960
questions for you to think about this is

00:24:05,160 --> 00:24:08,820
basically a homework assignment so I'm

00:24:06,960 --> 00:24:11,309
like I'm like your college ciass

00:24:08,820 --> 00:24:17,030
professor that you hated but hopefully

00:24:11,309 --> 00:24:21,660
funnier um so I'm going to go ahead and

00:24:17,030 --> 00:24:27,450
publish this really quickly so if it

00:24:21,660 --> 00:24:33,660
works awesome I'm going to live tweet it

00:24:27,450 --> 00:24:38,010
out awesome so this way you guys will be

00:24:33,660 --> 00:24:39,600
able to see I can't live code in my

00:24:38,010 --> 00:24:43,670
presentation so the least I could do is

00:24:39,600 --> 00:24:43,670
like live tweet that'll help right

00:24:47,410 --> 00:24:50,130
also

00:25:04,580 --> 00:25:09,679
there's probably a typo in that as is

00:25:07,099 --> 00:25:13,609
there a typo and all my tweets thank you

00:25:09,679 --> 00:25:15,349
for the applause I know that was all of

00:25:13,609 --> 00:25:18,320
computation led up to that

00:25:15,349 --> 00:25:20,209
um awesome so feel free to check out

00:25:18,320 --> 00:25:22,129
that tool there is a link to that github

00:25:20,209 --> 00:25:24,799
repository for it so if you have trouble

00:25:22,129 --> 00:25:26,269
with it or like you're confused my my

00:25:24,799 --> 00:25:27,739
directions or you think there should be

00:25:26,269 --> 00:25:31,369
more jokes in there just open up an

00:25:27,739 --> 00:25:33,169
issue and I'll address it if you want to

00:25:31,369 --> 00:25:36,950
get the slides for this talk they're

00:25:33,169 --> 00:25:39,259
available at sofia Rox um there's a talk

00:25:36,950 --> 00:25:42,789
section on my website and if you scroll

00:25:39,259 --> 00:25:46,190
down you'll see all the good stuff and

00:25:42,789 --> 00:25:48,529
finally thanks for being a wonderful

00:25:46,190 --> 00:25:50,539
audience thanks to the organizers for

00:25:48,529 --> 00:25:53,149
putting this together and for like

00:25:50,539 --> 00:25:54,709
bringing us all here I'll try and get a

00:25:53,149 --> 00:25:56,539
lot of sleep tonight so I can like

00:25:54,709 --> 00:25:57,950
actually communicate and interact with

00:25:56,539 --> 00:26:01,219
you people without being jet-lagged

00:25:57,950 --> 00:26:03,019
insane but thanks I hope my talk was

00:26:01,219 --> 00:26:05,209
like super informative and you took

00:26:03,019 --> 00:26:07,039
something away from it or you just like

00:26:05,209 --> 00:26:08,509
liked my jokes that's fine too I'll stop

00:26:07,039 --> 00:26:11,289
talking now and Jake can come up and

00:26:08,509 --> 00:26:11,289

YouTube URL: https://www.youtube.com/watch?v=AeUCN2lPqL8


