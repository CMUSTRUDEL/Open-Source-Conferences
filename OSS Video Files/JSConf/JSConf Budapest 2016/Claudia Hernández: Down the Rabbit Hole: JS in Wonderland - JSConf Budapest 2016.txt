Title: Claudia Hernández: Down the Rabbit Hole: JS in Wonderland - JSConf Budapest 2016
Publication date: 2016-06-20
Playlist: JSConf Budapest 2016
Description: 
	What even makes sense in Javascript?

For a language originally created in 10 days it surely has a lot of quirks and perks many JS developers are unaware of. Sometimes, it might even seem like we fell down the rabbit hole only to find that NaN is actually a Number, undefined can be defined, +!![] equals 1, Array.sort()may not work as you suspected and so much other nonsense that can trip any JS developer’s mind.

This talk is a collection of Javascript’s oddities and unexpected behaviors that hopefully will prevent some future headaches and help understand the language that we all love in a more deeper and meaningful way.

http://jsconfbp.com/speakers/claudia-hernandez.html
Captions: 
	00:00:12,490 --> 00:00:16,279
first of all thank you very much for

00:00:14,690 --> 00:00:18,770
having me here today I'm so excited to

00:00:16,279 --> 00:00:20,270
be in Buda this is my first time and I'm

00:00:18,770 --> 00:00:24,230
loving the city I don't want to ever

00:00:20,270 --> 00:00:26,630
live here but um Who am I who is this

00:00:24,230 --> 00:00:28,490
random girl here in stage uh my name is

00:00:26,630 --> 00:00:30,380
Claire my missus I said before and I am

00:00:28,490 --> 00:00:32,449
a Mexican front-end developer in a

00:00:30,380 --> 00:00:34,610
digital agency in Paris and if you have

00:00:32,449 --> 00:00:35,600
any questions comments or complaints or

00:00:34,610 --> 00:00:37,519
perhaps you want to see my awesome

00:00:35,600 --> 00:00:52,760
pictures of Budapest you can now find me

00:00:37,519 --> 00:00:54,079
on twitter as Kosti for because for the

00:00:52,760 --> 00:00:55,700
following half an hour I'm actually

00:00:54,079 --> 00:00:57,110
going to be your own personal wardrobe

00:00:55,700 --> 00:00:58,879
and I'm going to be showing you a

00:00:57,110 --> 00:01:00,140
collection of oddities and unexpected

00:00:58,879 --> 00:01:03,860
behaviors that I hope that are gonna

00:01:00,140 --> 00:01:05,180
surely make you mine strip but first of

00:01:03,860 --> 00:01:06,320
all just a little bit of a disclaimer

00:01:05,180 --> 00:01:09,710
because I love these flavors

00:01:06,320 --> 00:01:11,720
um I ain't no expert but I'm a highly

00:01:09,710 --> 00:01:13,820
clearest person and I just need to know

00:01:11,720 --> 00:01:15,650
how things work so today I'm gonna share

00:01:13,820 --> 00:01:17,180
with you some of my personal discoveries

00:01:15,650 --> 00:01:20,000
in hopes that it will help you as well

00:01:17,180 --> 00:01:21,680
um discover some of clear up some of the

00:01:20,000 --> 00:01:23,450
weirdness JavaScript caches that you may

00:01:21,680 --> 00:01:26,180
encounter integers are individual asset

00:01:23,450 --> 00:01:28,369
a script developer so what I'm gonna

00:01:26,180 --> 00:01:34,040
show you next is actual unseen footage

00:01:28,369 --> 00:01:35,180
of Brendan Eich mountain for creating or

00:01:34,040 --> 00:01:38,210
at least it's how I picture him a

00:01:35,180 --> 00:01:39,530
imagine in JavaScript but of course I'm

00:01:38,210 --> 00:01:42,619
just kidding I don't when I getting shot

00:01:39,530 --> 00:01:45,220
with mister like um what hold up am I

00:01:42,619 --> 00:01:45,220
really kidding

00:01:47,320 --> 00:01:52,640
javascript is the kind of language where

00:01:49,490 --> 00:01:55,130
nothing is what it is cuz everything is

00:01:52,640 --> 00:01:57,740
what it isn't and um contrariwise what

00:01:55,130 --> 00:02:00,950
is it's not you know what it's not yes

00:01:57,740 --> 00:02:02,420
you see oh no a person just trying to

00:02:00,950 --> 00:02:05,180
myself with you guys before I even begin

00:02:02,420 --> 00:02:06,259
talking but um in all seriousness if

00:02:05,180 --> 00:02:06,920
you're curious about the previous

00:02:06,259 --> 00:02:08,840
examples

00:02:06,920 --> 00:02:10,429
they're just either the result of

00:02:08,840 --> 00:02:12,890
inconsistencies with floating point math

00:02:10,429 --> 00:02:14,390
that okay to be quite a fair it's not

00:02:12,890 --> 00:02:15,799
only an issue in JavaScript but also you

00:02:14,390 --> 00:02:18,140
know their own languages that uses

00:02:15,799 --> 00:02:20,150
floating-point numbers they're also the

00:02:18,140 --> 00:02:22,400
result of either the way JavaScript

00:02:20,150 --> 00:02:25,250
interprets okto integers and

00:02:22,400 --> 00:02:28,010
so knowing the fact of the difference

00:02:25,250 --> 00:02:29,569
between reference and primitive types so

00:02:28,010 --> 00:02:31,250
you know the thing is that javascript is

00:02:29,569 --> 00:02:32,959
awesome that's why we're all here

00:02:31,250 --> 00:02:34,879
because we love JavaScript well then

00:02:32,959 --> 00:02:37,239
that javascript is really easy to learn

00:02:34,879 --> 00:02:41,030
but it's even harder to learn completely

00:02:37,239 --> 00:02:42,890
so once I fit this we're gonna enter the

00:02:41,030 --> 00:02:48,500
first part of our journey to wander line

00:02:42,890 --> 00:02:52,640
Anna our first stop is man if you can

00:02:48,500 --> 00:02:55,909
get all three laughing so man literally

00:02:52,640 --> 00:02:59,150
stands for not a number however a type

00:02:55,909 --> 00:03:00,970
of man is a number so um JavaScript

00:02:59,150 --> 00:03:03,079
please get your trip together it's like

00:03:00,970 --> 00:03:04,549
you know in really simplistic terms

00:03:03,079 --> 00:03:07,400
nanny's use the return value of a

00:03:04,549 --> 00:03:08,959
mathematical operation that fail and if

00:03:07,400 --> 00:03:11,510
you try to perform an operation without

00:03:08,959 --> 00:03:13,730
both operands being numbers are you will

00:03:11,510 --> 00:03:16,400
get man in the same fashion if you try

00:03:13,730 --> 00:03:17,840
to perform an operation without without

00:03:16,400 --> 00:03:20,510
with numbers that are not defined such

00:03:17,840 --> 00:03:22,010
as dividing 0 by 0 or the or getting the

00:03:20,510 --> 00:03:26,209
square the square root of a negative

00:03:22,010 --> 00:03:27,919
number you will as well get man so you

00:03:26,209 --> 00:03:30,079
know what man is actually trying to tell

00:03:27,919 --> 00:03:32,480
us is like hey I try to perform this

00:03:30,079 --> 00:03:37,459
mathematical operation what I spell so

00:03:32,480 --> 00:03:39,349
here this fail number instead so yeah

00:03:37,459 --> 00:03:41,060
you know the problem with nan is that

00:03:39,349 --> 00:03:42,919
perhaps the label name is a little bit

00:03:41,060 --> 00:03:44,599
misleading maybe it would be easier to

00:03:42,919 --> 00:03:46,489
think of it as our own fail number

00:03:44,599 --> 00:03:48,590
invalid number back numbered I'm

00:03:46,489 --> 00:03:50,659
thinking of it as not a number because

00:03:48,590 --> 00:03:52,940
bottom line nan is still a numeric type

00:03:50,659 --> 00:03:56,269
however it represents a value that could

00:03:52,940 --> 00:03:58,909
not represent a valid number so you know

00:03:56,269 --> 00:04:00,440
it's a script ezpz mathematical

00:03:58,909 --> 00:04:04,340
operations cannot crash or cause errors

00:04:00,440 --> 00:04:06,849
they just give you nan so what if we

00:04:04,340 --> 00:04:09,799
wanted to know if a batter is not or not

00:04:06,849 --> 00:04:12,169
this was your first guess oh let me tell

00:04:09,799 --> 00:04:14,540
you something guys nan is not equal

00:04:12,169 --> 00:04:17,090
greater than or less than anything

00:04:14,540 --> 00:04:18,919
including itself and you have you

00:04:17,090 --> 00:04:20,510
already know this but do you know why a

00:04:18,919 --> 00:04:23,120
man is not equal to man

00:04:20,510 --> 00:04:25,370
so to give you a little bit of context

00:04:23,120 --> 00:04:28,849
nan is actually part of the I Triple E

00:04:25,370 --> 00:04:30,710
754 a floating point standard that to

00:04:28,849 --> 00:04:34,159
keep things short he finds that there

00:04:30,710 --> 00:04:36,720
are 16 million 777

00:04:34,159 --> 00:04:39,479
214 different different floating-point

00:04:36,720 --> 00:04:41,699
values as man so what does this mean

00:04:39,479 --> 00:04:43,949
this means that there are so many

00:04:41,699 --> 00:04:46,289
different kind of man's that it's highly

00:04:43,949 --> 00:04:49,560
unlikely that one man is equal to

00:04:46,289 --> 00:04:52,110
another now so yes indeed none is not

00:04:49,560 --> 00:04:54,900
equal to none and at this point I guess

00:04:52,110 --> 00:04:59,490
we can all say that man stands for not a

00:04:54,900 --> 00:05:01,949
not a number if we actually want to know

00:04:59,490 --> 00:05:06,509
if a value is man we can use the - the

00:05:01,949 --> 00:05:12,650
built-in function if man let's talk

00:05:06,509 --> 00:05:15,389
about now so type of know is object what

00:05:12,650 --> 00:05:17,400
we all know that no is a primitive the

00:05:15,389 --> 00:05:19,469
value and therefore type of no should be

00:05:17,400 --> 00:05:22,289
no but you know interpret things are

00:05:19,469 --> 00:05:24,120
never what they seem and unfortunately

00:05:22,289 --> 00:05:25,560
this is a well-known mistake it's even

00:05:24,120 --> 00:05:27,150
written on the Indian dogs everyone

00:05:25,560 --> 00:05:29,159
knows about it but then is that this is

00:05:27,150 --> 00:05:30,870
a mistake in a specification due to

00:05:29,159 --> 00:05:32,400
historical reasons involving the way

00:05:30,870 --> 00:05:34,469
reference types were implemented in the

00:05:32,400 --> 00:05:36,689
first version of JavaScript and in words

00:05:34,469 --> 00:05:38,159
of Rendon I unfortunately this is about

00:05:36,689 --> 00:05:42,690
that cannot be fixed because it will

00:05:38,159 --> 00:05:48,090
just break too many sites so what would

00:05:42,690 --> 00:05:50,370
happen in this case if rabbit is no yeah

00:05:48,090 --> 00:05:52,310
we will get an error and one of the main

00:05:50,370 --> 00:05:56,039
takeaways of this talk that I want to

00:05:52,310 --> 00:05:57,810
give you is that um you have to be aware

00:05:56,039 --> 00:05:59,159
of these kind of errors there are a lot

00:05:57,810 --> 00:06:00,690
of things going on in JavaScript and you

00:05:59,159 --> 00:06:01,789
we just have to realize that these

00:06:00,690 --> 00:06:03,930
things can happen

00:06:01,789 --> 00:06:05,430
so yeah the good news is that we can

00:06:03,930 --> 00:06:07,050
always make some corrections in our code

00:06:05,430 --> 00:06:08,789
add extra validations in order to make

00:06:07,050 --> 00:06:12,210
sure that we never fell into these

00:06:08,789 --> 00:06:13,740
errors so now let's talk about sorting

00:06:12,210 --> 00:06:17,129
arrays that seems like a little bit more

00:06:13,740 --> 00:06:18,870
fun so what can we expect from a

00:06:17,129 --> 00:06:21,089
function that it's all sort

00:06:18,870 --> 00:06:23,669
I get definitely not this outcome

00:06:21,089 --> 00:06:27,810
because normally in planet Earth for

00:06:23,669 --> 00:06:30,719
comes before 25 and 33 no right but not

00:06:27,810 --> 00:06:32,669
in JavaScript so what's actually

00:06:30,719 --> 00:06:35,159
happening here the thing is that the

00:06:32,669 --> 00:06:36,990
elements to be sorted they are

00:06:35,159 --> 00:06:39,089
transforming two strings and then they

00:06:36,990 --> 00:06:40,740
are comparing lexicographical order you

00:06:39,089 --> 00:06:43,229
know what is this lexicographical order

00:06:40,740 --> 00:06:45,149
I'm talking about basically it is the

00:06:43,229 --> 00:06:46,720
same way you will look through a word or

00:06:45,149 --> 00:06:48,430
a know you will

00:06:46,720 --> 00:06:50,140
for a word in a dictionary or in a

00:06:48,430 --> 00:06:53,080
telephone book so let's see like in

00:06:50,140 --> 00:06:55,210
alphabetical order so in this example

00:06:53,080 --> 00:06:58,120
yeah the first one is really easy blue

00:06:55,210 --> 00:07:00,310
will come before before read it slow no

00:06:58,120 --> 00:07:01,390
brainer but in the second a case since

00:07:00,310 --> 00:07:03,850
there are numbers and they're being

00:07:01,390 --> 00:07:05,800
converted to strings ad will come before

00:07:03,850 --> 00:07:07,780
nine due to their Unicode code point

00:07:05,800 --> 00:07:10,060
value and what is this unicode code

00:07:07,780 --> 00:07:13,090
value basically it's just the ID of any

00:07:10,060 --> 00:07:15,750
Unicode character so in similar terms

00:07:13,090 --> 00:07:18,580
let's just say that 80 is

00:07:15,750 --> 00:07:21,360
lexicographically less than nine so it

00:07:18,580 --> 00:07:23,830
starts to make a little bit more sense

00:07:21,360 --> 00:07:25,450
if you want to get the coke invaluable

00:07:23,830 --> 00:07:28,480
character you can use JavaScript a

00:07:25,450 --> 00:07:31,780
function called pointer so going back to

00:07:28,480 --> 00:07:33,550
our example in this case we now

00:07:31,780 --> 00:07:36,340
understand that yeah yes you need four

00:07:33,550 --> 00:07:38,500
is lexicographically greater than 25 and

00:07:36,340 --> 00:07:40,930
33 but this was not the outcome that we

00:07:38,500 --> 00:07:42,910
were expecting on the first place and

00:07:40,930 --> 00:07:44,500
what we're missing here is that actually

00:07:42,910 --> 00:07:46,870
the store function can take a compare

00:07:44,500 --> 00:07:48,910
function as a parameter and if I compare

00:07:46,870 --> 00:07:50,800
function e supply even that a and B are

00:07:48,910 --> 00:07:52,690
the elements to be compared if a is less

00:07:50,800 --> 00:07:54,340
than B you will return minus 1 and a

00:07:52,690 --> 00:07:56,200
will come before B if a is greater than

00:07:54,340 --> 00:07:57,520
B you will return 1 and B will come

00:07:56,200 --> 00:07:59,500
before a unique a and B are the same

00:07:57,520 --> 00:08:01,720
they will turn 0 and no changes will be

00:07:59,500 --> 00:08:03,760
made and if you are as furious as I am

00:08:01,720 --> 00:08:05,650
you might be wondering like what is the

00:08:03,760 --> 00:08:07,419
actual algorithm used by the sort

00:08:05,650 --> 00:08:08,740
function to make the actual sorting and

00:08:07,419 --> 00:08:10,630
when I was doing some research I

00:08:08,740 --> 00:08:13,030
realized that Firefox for example it

00:08:10,630 --> 00:08:14,830
uses the merge sort algorithm and I

00:08:13,030 --> 00:08:16,360
think the WebKit browsers use some

00:08:14,830 --> 00:08:19,750
variation of the quicksort algorithm

00:08:16,360 --> 00:08:21,520
just fun fact so going back to our

00:08:19,750 --> 00:08:23,229
previous example we can simplify our

00:08:21,520 --> 00:08:24,729
compare function by just subtracting B

00:08:23,229 --> 00:08:26,680
from a because it would also give us a

00:08:24,729 --> 00:08:28,390
valid comparison value and we can

00:08:26,680 --> 00:08:30,310
finally arrived our expected result

00:08:28,390 --> 00:08:31,530
which was an array sorted in numerical

00:08:30,310 --> 00:08:34,419
order

00:08:31,530 --> 00:08:37,539
Anna now let's talk about the mysterious

00:08:34,419 --> 00:08:39,490
still the operator so how many of you

00:08:37,539 --> 00:08:44,950
guys know what this operator actually

00:08:39,490 --> 00:08:47,200
does ok so not so many um I wasn't asked

00:08:44,950 --> 00:08:49,570
next like who has used it on other

00:08:47,200 --> 00:08:53,740
programs what's seen that you were not

00:08:49,570 --> 00:08:55,660
much how many of you guys actually knew

00:08:53,740 --> 00:08:57,610
the name of this operator because I

00:08:55,660 --> 00:08:57,920
always okay because I always will say

00:08:57,610 --> 00:09:00,079
like

00:08:57,920 --> 00:09:03,230
away the operator but it's a click old

00:09:00,079 --> 00:09:05,269
TV anyway so I'm gonna give you a few

00:09:03,230 --> 00:09:06,560
seconds just to see the code and try to

00:09:05,269 --> 00:09:07,870
understand what's going on here do you

00:09:06,560 --> 00:09:11,149
see any pattern

00:09:07,870 --> 00:09:13,730
can you guess so the thing is that

00:09:11,149 --> 00:09:16,459
actually the till the operator is doing

00:09:13,730 --> 00:09:19,070
just this small algorithm where n is the

00:09:16,459 --> 00:09:19,670
the number next to the to the right of

00:09:19,070 --> 00:09:23,690
the operator

00:09:19,670 --> 00:09:25,940
so um unless you're actually using that

00:09:23,690 --> 00:09:29,440
a specific algorithm in your application

00:09:25,940 --> 00:09:32,600
what else could it be good for so

00:09:29,440 --> 00:09:37,040
actually be pretty cool for functions

00:09:32,600 --> 00:09:41,269
returning minus 1 and let me remember

00:09:37,040 --> 00:09:43,490
one like index of and index of function

00:09:41,269 --> 00:09:45,980
returns minus 1 when I give an element

00:09:43,490 --> 00:09:48,230
is not found in a given array so let's

00:09:45,980 --> 00:09:49,940
all consider this this small array over

00:09:48,230 --> 00:09:51,410
here which is the guest list for the tea

00:09:49,940 --> 00:09:55,579
party that we're gonna have a little bit

00:09:51,410 --> 00:09:57,680
later and you know we can see if an

00:09:55,579 --> 00:09:59,690
element is in that area or not by just

00:09:57,680 --> 00:10:02,300
check doing any of this comparison we

00:09:59,690 --> 00:10:06,920
can check if the if the result of index

00:10:02,300 --> 00:10:09,110
off is equal to minus 1 but all of this

00:10:06,920 --> 00:10:12,050
can actually be simplified by using that

00:10:09,110 --> 00:10:13,640
tilde operator and in this case

00:10:12,050 --> 00:10:15,740
basically what the tilde operator is

00:10:13,640 --> 00:10:17,570
just taking the result of the index of

00:10:15,740 --> 00:10:20,329
function and it's converting it into a

00:10:17,570 --> 00:10:21,529
false is 0 and any other value will be

00:10:20,329 --> 00:10:23,839
automatically true

00:10:21,529 --> 00:10:25,459
so in simpler terms we can say that the

00:10:23,839 --> 00:10:27,589
tilde operator is just transforming the

00:10:25,459 --> 00:10:29,240
result of the index of function into an

00:10:27,589 --> 00:10:32,870
appropriate boolean value that we can

00:10:29,240 --> 00:10:34,820
use in our comparison and you know there

00:10:32,870 --> 00:10:36,230
is some discussion store this because

00:10:34,820 --> 00:10:38,329
there are people that think that this

00:10:36,230 --> 00:10:39,500
can lead to a cleaner code because

00:10:38,329 --> 00:10:41,630
instead of just writing all those

00:10:39,500 --> 00:10:43,279
Messier comparisons we can simplify and

00:10:41,630 --> 00:10:45,140
use these and there are other people

00:10:43,279 --> 00:10:46,850
that don't think this is clear enough

00:10:45,140 --> 00:10:48,410
because imagine for someone that has no

00:10:46,850 --> 00:10:51,110
idea what the operate this operator does

00:10:48,410 --> 00:10:53,569
it's quite confusing just seen these so

00:10:51,110 --> 00:10:54,889
I don't know I'm just showing you what

00:10:53,569 --> 00:10:56,060
the possibilities it's up to you

00:10:54,889 --> 00:10:58,910
depending on the project that you're

00:10:56,060 --> 00:11:03,230
working on it's up to you to decide

00:10:58,910 --> 00:11:06,620
depending on your so either way it's

00:11:03,230 --> 00:11:08,269
it's a cool trick let's say and now

00:11:06,620 --> 00:11:10,680
let's talk about for loops because they

00:11:08,269 --> 00:11:13,829
can be also really really interesting

00:11:10,680 --> 00:11:16,110
and when I was reading a JavaScript book

00:11:13,829 --> 00:11:19,379
I came across this really weird looking

00:11:16,110 --> 00:11:20,939
for loop and you know after doing some

00:11:19,379 --> 00:11:22,589
research I realized that people coming

00:11:20,939 --> 00:11:25,350
from a seed background didn't found this

00:11:22,589 --> 00:11:27,449
for loop as we decided but you know as

00:11:25,350 --> 00:11:29,360
I'm the courier person I am I just

00:11:27,449 --> 00:11:31,800
needed to know how it works

00:11:29,360 --> 00:11:33,749
so now I'm gonna bring you back to your

00:11:31,800 --> 00:11:34,800
programming 101 course you know back in

00:11:33,749 --> 00:11:36,899
the day when you were learning about

00:11:34,800 --> 00:11:38,160
programming so excited to code and

00:11:36,899 --> 00:11:40,079
you're let me have a variables and loops

00:11:38,160 --> 00:11:42,899
and everything and I'm just gonna remind

00:11:40,079 --> 00:11:44,269
you about something really basic for for

00:11:42,899 --> 00:11:46,740
loops have three parts they have a

00:11:44,269 --> 00:11:49,980
initialization for a condition for in an

00:11:46,740 --> 00:11:52,910
iteration part so what I actually didn't

00:11:49,980 --> 00:11:55,290
know is that all of them are optional so

00:11:52,910 --> 00:11:56,730
we can escape the first world because

00:11:55,290 --> 00:11:58,829
yeah we can basically just declare the

00:11:56,730 --> 00:12:00,749
variables outside the for loop we can

00:11:58,829 --> 00:12:01,949
escape the second part and the condition

00:12:00,749 --> 00:12:05,339
part is missing it actually ultimately

00:12:01,949 --> 00:12:06,990
access true or even we can escape the

00:12:05,339 --> 00:12:09,269
third part anyway skip the third in this

00:12:06,990 --> 00:12:10,920
particular example the condition part is

00:12:09,269 --> 00:12:14,160
act innocent at the same time as

00:12:10,920 --> 00:12:15,360
iteration part or we can even skip

00:12:14,160 --> 00:12:17,910
everything as I show you in the

00:12:15,360 --> 00:12:19,829
beginning and basically the middle part

00:12:17,910 --> 00:12:21,480
is acting as true and basically this is

00:12:19,829 --> 00:12:23,610
the same thing as a while true so this

00:12:21,480 --> 00:12:28,829
is just like an infinite or endless loop

00:12:23,610 --> 00:12:31,499
so a miss resolved and now let's talk

00:12:28,829 --> 00:12:33,240
about on define so we don't know that

00:12:31,499 --> 00:12:34,889
only fine is just a variable that has

00:12:33,240 --> 00:12:37,050
been declared but at the moment holds

00:12:34,889 --> 00:12:38,759
not by oles so this piece of code

00:12:37,050 --> 00:12:41,879
shouldn't comment shocking for anybody I

00:12:38,759 --> 00:12:43,709
hope the thing is that only fine is part

00:12:41,879 --> 00:12:45,959
of the global object so what would

00:12:43,709 --> 00:12:50,879
happen if we actually try defining on be

00:12:45,959 --> 00:12:53,160
fine so actually the outcome of this of

00:12:50,879 --> 00:12:55,829
this code really depends on the work of

00:12:53,160 --> 00:12:57,059
the browser that you are using so for

00:12:55,829 --> 00:12:59,249
all the browsers you can actually

00:12:57,059 --> 00:13:01,410
redefine only fine but in modern

00:12:59,249 --> 00:13:03,480
browsers discuss already been fixed and

00:13:01,410 --> 00:13:05,639
yeah I get it well it's becoming less

00:13:03,480 --> 00:13:07,470
and less of a problem if you're actually

00:13:05,639 --> 00:13:08,999
giving support to older browsers you

00:13:07,470 --> 00:13:10,949
have to defend yourself against the

00:13:08,999 --> 00:13:12,629
possibility of other code redefining

00:13:10,949 --> 00:13:15,299
you're only fine because the thing is

00:13:12,629 --> 00:13:18,059
that javascript rarely runs in isolation

00:13:15,299 --> 00:13:20,220
it often Browns mix with code from

00:13:18,059 --> 00:13:21,569
third-party libraries and we have to be

00:13:20,220 --> 00:13:22,860
aware as I told you with right we have

00:13:21,569 --> 00:13:23,250
to be aware of these things and actually

00:13:22,860 --> 00:13:27,090
have

00:13:23,250 --> 00:13:29,580
a ninja's try to defend ourselves and

00:13:27,090 --> 00:13:31,980
you know these doesn't entirely prevent

00:13:29,580 --> 00:13:33,330
us from overriding only fine because as

00:13:31,980 --> 00:13:35,340
strange as it might sound

00:13:33,330 --> 00:13:37,230
only fine is not a reserved word in

00:13:35,340 --> 00:13:40,740
JavaScript meaning that you can actually

00:13:37,230 --> 00:13:42,270
use it as a variable as well so just a

00:13:40,740 --> 00:13:44,610
little bit of a recap what have we

00:13:42,270 --> 00:13:48,210
learned so far not a number it's a

00:13:44,610 --> 00:13:50,250
number null is an object the sort

00:13:48,210 --> 00:13:52,830
function sorts lexicographically by

00:13:50,250 --> 00:13:54,630
default the tilde operator can be pretty

00:13:52,830 --> 00:13:57,390
useful with function return n minus 1

00:13:54,630 --> 00:14:00,380
and all parts are in a for loop are

00:13:57,390 --> 00:14:08,330
optional and only fine can be defined

00:14:00,380 --> 00:14:08,330
sometimes am i boring you guys exciting

00:14:11,330 --> 00:14:17,820
hold up because the man JavaScript party

00:14:14,520 --> 00:14:19,530
is just about to begin and just a little

00:14:17,820 --> 00:14:21,540
bit of a disclaimer disclaimer because I

00:14:19,530 --> 00:14:22,860
told you that I love disclaimers um the

00:14:21,540 --> 00:14:24,450
following content is designed to

00:14:22,860 --> 00:14:27,120
challenge enemies programmers not make

00:14:24,450 --> 00:14:28,580
to be suitable for practical use and now

00:14:27,120 --> 00:14:30,810
I'm gonna talk about non alphanumeric

00:14:28,580 --> 00:14:32,820
JavaScript and what is this not as fun

00:14:30,810 --> 00:14:36,060
America nonsense I'm gonna get into that

00:14:32,820 --> 00:14:37,740
in a minute so before that this just all

00:14:36,060 --> 00:14:40,410
remember a really key characteristic of

00:14:37,740 --> 00:14:42,120
JavaScript so javascript is a non type

00:14:40,410 --> 00:14:43,860
language which means that you don't have

00:14:42,120 --> 00:14:45,240
to specify the king of data that a

00:14:43,860 --> 00:14:47,070
variable will hold when you're declaring

00:14:45,240 --> 00:14:49,440
so it's really up to the interpreter to

00:14:47,070 --> 00:14:51,060
determine this and when we meet slaves

00:14:49,440 --> 00:14:52,710
we can obtain in bulk implicit

00:14:51,060 --> 00:14:55,500
conversions that can lead to really

00:14:52,710 --> 00:14:57,630
crazy results so what I'm gonna show you

00:14:55,500 --> 00:15:00,120
next is how to write valid JavaScript

00:14:57,630 --> 00:15:02,310
using only square brackets parenthesis

00:15:00,120 --> 00:15:06,030
the curly brackets the plan separator

00:15:02,310 --> 00:15:08,400
and exclamation point I surrounded crazy

00:15:06,030 --> 00:15:10,230
these actually wards you can test it out

00:15:08,400 --> 00:15:14,310
right away in your developer tools keys

00:15:10,230 --> 00:15:15,900
it's it's part of a JavaScript magic but

00:15:14,310 --> 00:15:18,450
I'm gonna start grading easy don't worry

00:15:15,900 --> 00:15:20,400
ah in this first example of what we're

00:15:18,450 --> 00:15:22,320
trying to do is we're negating an empty

00:15:20,400 --> 00:15:26,339
array so we're first in JavaScript to

00:15:22,320 --> 00:15:27,780
treat that empty array as a boolean so

00:15:26,339 --> 00:15:29,760
if you're familiar with the concept of

00:15:27,780 --> 00:15:32,550
truthy and falsy values you will know

00:15:29,760 --> 00:15:34,690
that an empty array is a truth value so

00:15:32,550 --> 00:15:36,579
negating a truth value of give us of

00:15:34,690 --> 00:15:39,700
it's in a second sample is more easy so

00:15:36,579 --> 00:15:42,010
we're just negating a force and we're

00:15:39,700 --> 00:15:45,160
getting through so from two ampoules

00:15:42,010 --> 00:15:47,200
it's really easy to get to zero and one

00:15:45,160 --> 00:15:49,870
because we're just converting true and

00:15:47,200 --> 00:15:51,579
false to serum one using that unary plus

00:15:49,870 --> 00:15:52,690
operator and this is not the same

00:15:51,579 --> 00:15:54,490
operator we normally use for

00:15:52,690 --> 00:15:56,529
concatenating strings the actual usage

00:15:54,490 --> 00:15:59,380
of the unary operator is to convert

00:15:56,529 --> 00:16:01,870
things into numbers so now that we have

00:15:59,380 --> 00:16:05,440
one in and zero and one we have a base

00:16:01,870 --> 00:16:07,149
to create any other number so you can

00:16:05,440 --> 00:16:11,950
picture that that's just adding one plus

00:16:07,149 --> 00:16:13,839
one plus one plus one plus one easy you

00:16:11,950 --> 00:16:15,700
can convert things into strings by just

00:16:13,839 --> 00:16:20,140
adding an empty array because empty

00:16:15,700 --> 00:16:24,370
array are coarse to string this also

00:16:20,140 --> 00:16:25,959
works for four numbers and what would

00:16:24,370 --> 00:16:28,120
happen if you actually wanted to convert

00:16:25,959 --> 00:16:30,160
like bigger numbers into this weird non

00:16:28,120 --> 00:16:32,950
of an America's stuff that I'm saying

00:16:30,160 --> 00:16:35,140
um well instead of adding one plus one

00:16:32,950 --> 00:16:37,120
plus one until infinity obviously nobody

00:16:35,140 --> 00:16:39,310
has time to do that we can basically

00:16:37,120 --> 00:16:42,250
just transform every single digit of the

00:16:39,310 --> 00:16:44,320
number into string then concatenate the

00:16:42,250 --> 00:16:46,089
whole string and convert the whole thing

00:16:44,320 --> 00:16:49,779
back into a number using the unary plus

00:16:46,089 --> 00:16:51,310
operator as I shown you before so that's

00:16:49,779 --> 00:16:52,959
what a hundred and twenty-three looks

00:16:51,310 --> 00:16:54,339
like in non alphanumeric JavaScript and

00:16:52,959 --> 00:16:56,260
you can test it on right away and it

00:16:54,339 --> 00:17:01,149
works your console will actually print

00:16:56,260 --> 00:17:03,430
out a hundred twenty-three so we can get

00:17:01,149 --> 00:17:05,169
more stuff using this weird technique we

00:17:03,430 --> 00:17:08,189
can get on defined by trying to access

00:17:05,169 --> 00:17:10,959
and a non-existent element in an array

00:17:08,189 --> 00:17:13,419
we can get none by casting an object

00:17:10,959 --> 00:17:15,160
into a number and we can get the string

00:17:13,419 --> 00:17:19,030
object object by trying to cast an

00:17:15,160 --> 00:17:21,069
object into string so now that we have

00:17:19,030 --> 00:17:23,559
access to all of these words and

00:17:21,069 --> 00:17:26,470
vocabulary such as true/false object

00:17:23,559 --> 00:17:28,540
only fine blah blah blah we can convert

00:17:26,470 --> 00:17:31,240
and convert them into strings as I show

00:17:28,540 --> 00:17:35,020
you before and access them as if they

00:17:31,240 --> 00:17:37,750
were Eric's so in this way we can get

00:17:35,020 --> 00:17:40,570
even more single characters from which

00:17:37,750 --> 00:17:45,720
we can get even more words that actually

00:17:40,570 --> 00:17:45,720
means something to JavaScript in

00:17:46,580 --> 00:17:51,210
and you know Martin clipper the creator

00:17:49,500 --> 00:17:51,630
of Jays book which I'm going to talk

00:17:51,210 --> 00:17:52,980
later

00:17:51,630 --> 00:17:54,809
really cleverly called these JavaScript

00:17:52,980 --> 00:17:56,100
Scrabble because you know basically what

00:17:54,809 --> 00:17:58,290
we're doing is we're just we're just

00:17:56,100 --> 00:17:59,700
creating new words from the my level set

00:17:58,290 --> 00:18:02,040
of characters that were getting from the

00:17:59,700 --> 00:18:03,740
previous technique and to keep things

00:18:02,040 --> 00:18:06,059
short because this is a 30 minute taught

00:18:03,740 --> 00:18:07,620
we basically can have access to

00:18:06,059 --> 00:18:12,030
functions such as call count cap

00:18:07,620 --> 00:18:13,770
constructor join slice or filter I know

00:18:12,030 --> 00:18:15,450
you are with really willing to see this

00:18:13,770 --> 00:18:17,640
in action and I'm gonna walk you through

00:18:15,450 --> 00:18:19,490
this really little simple example that

00:18:17,640 --> 00:18:23,400
actually just alerts one in your browser

00:18:19,490 --> 00:18:25,590
and it's really easy don't worry so this

00:18:23,400 --> 00:18:27,620
first part is just an empty array okay

00:18:25,590 --> 00:18:31,020
that nothing nothing we're over there

00:18:27,620 --> 00:18:32,910
the filter segment is just accessing the

00:18:31,020 --> 00:18:37,559
filter function of that empty array

00:18:32,910 --> 00:18:39,870
which is a function the constructor part

00:18:37,559 --> 00:18:43,320
is getting the constructor for functions

00:18:39,870 --> 00:18:45,720
and the constructor of functions takes a

00:18:43,320 --> 00:18:47,460
parameter a script that returns back a

00:18:45,720 --> 00:18:51,480
new function with that script as its

00:18:47,460 --> 00:18:54,300
body so finally that last parenthesis is

00:18:51,480 --> 00:18:55,500
just executing that new function in the

00:18:54,300 --> 00:18:57,420
outcome of this as you might have

00:18:55,500 --> 00:19:00,570
guessed it's just an alert one in your

00:18:57,420 --> 00:19:02,460
browser and that could behind that is

00:19:00,570 --> 00:19:05,809
the actual code that you can use so

00:19:02,460 --> 00:19:05,809
crazy I know

00:19:10,769 --> 00:19:15,999
so I know it's really it's a lot to take

00:19:13,659 --> 00:19:17,169
in it's really weird but the good thing

00:19:15,999 --> 00:19:18,789
is that there are a lot of online

00:19:17,169 --> 00:19:20,049
converters that you can check out in

00:19:18,789 --> 00:19:22,479
order to test this technique to play

00:19:20,049 --> 00:19:24,429
around I really recommend you guys to

00:19:22,479 --> 00:19:25,749
see the source code of some of the of

00:19:24,429 --> 00:19:27,039
the online converters because they are

00:19:25,749 --> 00:19:29,789
they can be really really really

00:19:27,039 --> 00:19:32,349
educational so just check it out and

00:19:29,789 --> 00:19:34,599
well there is a yellow TV more by

00:19:32,349 --> 00:19:36,970
Patricia Palladino there is a J's for

00:19:34,599 --> 00:19:39,970
the moon there is it Saturday yes there

00:19:36,970 --> 00:19:42,190
is Jaya screw it and most well-known is

00:19:39,970 --> 00:19:45,340
Jay's the day is fought by American

00:19:42,190 --> 00:19:47,200
clapping and seriously there's like no

00:19:45,340 --> 00:19:49,629
limit with this but when I was doing

00:19:47,200 --> 00:19:51,549
research for this conference I realized

00:19:49,629 --> 00:19:53,919
that I came across this get hot ripple

00:19:51,549 --> 00:19:55,479
from a guy that basically just rewrote

00:19:53,919 --> 00:19:57,489
the whole thing curry library using

00:19:55,479 --> 00:20:02,889
non-alphanumeric JavaScript it's like

00:19:57,489 --> 00:20:04,570
what this is a source code like people

00:20:02,889 --> 00:20:08,739
have way too much time on their hands

00:20:04,570 --> 00:20:11,200
like and at this point you might be

00:20:08,739 --> 00:20:13,299
wondering like okay that's really fun

00:20:11,200 --> 00:20:16,090
but why on earth would I ever care to

00:20:13,299 --> 00:20:18,009
learn this or why would I ever do this

00:20:16,090 --> 00:20:20,409
so if you think that this is totally

00:20:18,009 --> 00:20:21,909
useless um I think that hackers beg to

00:20:20,409 --> 00:20:23,830
differ

00:20:21,909 --> 00:20:25,599
I saw this tweet by Martin clip a few

00:20:23,830 --> 00:20:29,529
weeks ago in which he pointed to a

00:20:25,599 --> 00:20:32,229
security article from a security

00:20:29,529 --> 00:20:34,389
researcher that Faneuil vulnerability on

00:20:32,229 --> 00:20:37,149
eBay in which basically you could just

00:20:34,389 --> 00:20:40,749
insert malicious code using non

00:20:37,149 --> 00:20:42,039
alphanumeric JavaScript and well this

00:20:40,749 --> 00:20:44,559
kind of makes sense since apparently

00:20:42,039 --> 00:20:46,720
eBay just filters HTML tags such as

00:20:44,559 --> 00:20:49,149
iframe and scripts but it's totally

00:20:46,720 --> 00:20:53,049
unaware of code inserted in a different

00:20:49,149 --> 00:20:54,609
way so oh and if anybody asked you about

00:20:53,049 --> 00:20:57,220
this you didn't hear it from me I don't

00:20:54,609 --> 00:21:02,349
want a people hacking eBay you think it

00:20:57,220 --> 00:21:04,090
for me so yeah I also really really love

00:21:02,349 --> 00:21:08,529
these things will make a sensor for a

00:21:04,090 --> 00:21:11,229
change and sadly we're reaching the end

00:21:08,529 --> 00:21:12,519
of our journey but of course I cannot

00:21:11,229 --> 00:21:15,099
leave without talking about our

00:21:12,519 --> 00:21:18,789
functions and es6 because I want to be

00:21:15,099 --> 00:21:20,919
part of the cool gang so we normally

00:21:18,789 --> 00:21:23,650
know that functions create your own

00:21:20,919 --> 00:21:25,900
scope so this piece of code would

00:21:23,650 --> 00:21:27,520
word because the deeds that were

00:21:25,900 --> 00:21:29,380
referring in the inner function of the

00:21:27,520 --> 00:21:31,210
city malfunction is no longer the same

00:21:29,380 --> 00:21:33,960
DS that we began with it's not on the

00:21:31,210 --> 00:21:36,040
scope of the full function so you know

00:21:33,960 --> 00:21:38,590
developers have found workarounds for

00:21:36,040 --> 00:21:39,910
this such as declaring variables in the

00:21:38,590 --> 00:21:41,920
outer scope in order to capture the

00:21:39,910 --> 00:21:44,470
properties and then referring to that

00:21:41,920 --> 00:21:46,660
variable in the inner function yeah it

00:21:44,470 --> 00:21:48,310
works but it's confusing and it's messy

00:21:46,660 --> 00:21:50,860
it's like then you have variables that

00:21:48,310 --> 00:21:52,450
are cool like bar selfie Kobe's bar data

00:21:50,860 --> 00:21:54,100
code is visible that it's just like way

00:21:52,450 --> 00:21:57,340
too confusing and maybe I don't like it

00:21:54,100 --> 00:22:01,060
and the thing is that our functions

00:21:57,340 --> 00:22:04,260
don't have a disk at all and actually

00:22:01,060 --> 00:22:08,890
our functions don't have these arguments

00:22:04,260 --> 00:22:10,720
super or the new target if there is any

00:22:08,890 --> 00:22:13,350
reference to they mean they will just

00:22:10,720 --> 00:22:17,950
lexically resolve up to the outer scope

00:22:13,350 --> 00:22:19,390
so that's really really cool and the

00:22:17,950 --> 00:22:21,520
previous example can just be rewritten

00:22:19,390 --> 00:22:24,460
with that with an arrow function because

00:22:21,520 --> 00:22:26,380
if anybody will work and we don't have

00:22:24,460 --> 00:22:28,150
we don't we don't have the need to

00:22:26,380 --> 00:22:31,000
actually use those ugly-looking

00:22:28,150 --> 00:22:33,550
variables that I showed you before and

00:22:31,000 --> 00:22:35,830
even if you were like so stubborn and

00:22:33,550 --> 00:22:37,480
you actually wanted to use to harbor

00:22:35,830 --> 00:22:39,790
inner these to an arrow functions no

00:22:37,480 --> 00:22:41,800
matter what you just can't because

00:22:39,790 --> 00:22:43,570
arrows functions don't have these at all

00:22:41,800 --> 00:22:45,940
and therefore the bang method has

00:22:43,570 --> 00:22:48,280
nothing to operate on so in this example

00:22:45,940 --> 00:22:50,380
even when we try hard binding a hundred

00:22:48,280 --> 00:22:54,880
to the arrow function it doesn't work it

00:22:50,380 --> 00:22:57,040
still prints out 42 so I get that the

00:22:54,880 --> 00:22:59,680
bottom line is that arrow functions are

00:22:57,040 --> 00:23:01,600
not about less typing or seem that sugar

00:22:59,680 --> 00:23:03,400
for functions they actually have an

00:23:01,600 --> 00:23:07,590
intentional behavioral purpose that we

00:23:03,400 --> 00:23:09,430
should all know and use accordingly and

00:23:07,590 --> 00:23:12,100
what's it all a dream

00:23:09,430 --> 00:23:14,200
no it wasin this is true this is just

00:23:12,100 --> 00:23:16,150
how JavaScript works in it's great it's

00:23:14,200 --> 00:23:19,240
amazing and amazing than that this is

00:23:16,150 --> 00:23:21,640
why I love this language and you know

00:23:19,240 --> 00:23:25,240
why why should we care about all of

00:23:21,640 --> 00:23:27,370
these things that I just show you first

00:23:25,240 --> 00:23:28,570
of all knowledge is power we have to

00:23:27,370 --> 00:23:30,930
know why we're writing the code were

00:23:28,570 --> 00:23:32,980
writing and how it works

00:23:30,930 --> 00:23:35,200
secondly is

00:23:32,980 --> 00:23:36,430
it's really the future the future of

00:23:35,200 --> 00:23:38,200
JavaScript really depends on the

00:23:36,430 --> 00:23:40,210
willingness of its developers to push

00:23:38,200 --> 00:23:43,210
the limits to create new panels and just

00:23:40,210 --> 00:23:46,360
move the community forward it's all

00:23:43,210 --> 00:23:48,040
about breaking rules also we have to

00:23:46,360 --> 00:23:49,630
remember that playing is learning it's

00:23:48,040 --> 00:23:51,850
really JavaScript quirkiness that

00:23:49,630 --> 00:23:53,590
encourages to play around with it to

00:23:51,850 --> 00:23:56,350
make mistakes to just mess around in the

00:23:53,590 --> 00:23:58,300
console and ultimately it will just make

00:23:56,350 --> 00:23:59,860
us better developers just being in

00:23:58,300 --> 00:24:03,460
constant interaction with the language

00:23:59,860 --> 00:24:04,810
itself and lastly it's about the power

00:24:03,460 --> 00:24:07,800
of the language and this is a quote from

00:24:04,810 --> 00:24:10,360
a book that I read a while ago that says

00:24:07,800 --> 00:24:13,540
JavaScript survive not despite its flaws

00:24:10,360 --> 00:24:15,700
but because of them and before I

00:24:13,540 --> 00:24:18,220
completely completely finish I want to

00:24:15,700 --> 00:24:19,870
read you guys this quote that says the

00:24:18,220 --> 00:24:21,550
best JavaScript developers are those

00:24:19,870 --> 00:24:23,140
cops s about language explore and play

00:24:21,550 --> 00:24:25,120
with it every day and in doing so

00:24:23,140 --> 00:24:27,550
develop their own idioms in their own

00:24:25,120 --> 00:24:28,900
voice these by angers underscore from

00:24:27,550 --> 00:24:30,670
his book it came in he wrote a script

00:24:28,900 --> 00:24:31,990
that I really really recommend you guys

00:24:30,670 --> 00:24:37,080
three it's really awesome

00:24:31,990 --> 00:24:37,080

YouTube URL: https://www.youtube.com/watch?v=YXdTfLqnIf8


