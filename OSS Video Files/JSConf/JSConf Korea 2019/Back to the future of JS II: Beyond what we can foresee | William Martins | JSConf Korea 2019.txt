Title: Back to the future of JS II: Beyond what we can foresee | William Martins | JSConf Korea 2019
Publication date: 2019-10-01
Playlist: JSConf Korea 2019
Description: 
	Learn about the upcoming JavaScript features you never knew you needed: Pattern Matching, Pipeline Operator, and Binary AST. I'll show you how these proposals may change the way you write code forever, as the spread operator once did. After that, I'd like to invite you to help TC39 push them forward.

What would you like to see implemented in JavaScript next?
Captions: 
	00:00:00,000 --> 00:00:09,570
[Music]

00:00:03,960 --> 00:00:13,500
hello everyone thanks for having me here

00:00:09,570 --> 00:00:17,730
so my name is villian I'm Brazilian and

00:00:13,500 --> 00:00:21,130
Mozilla tech speaker and I work for eBay

00:00:17,730 --> 00:00:24,009
I like to play video games

00:00:21,130 --> 00:00:26,050
I'm big monster hunter for fun so if

00:00:24,009 --> 00:00:28,929
wanna talk about Monster Hunter sing

00:00:26,050 --> 00:00:33,550
racy games or football please reach me

00:00:28,929 --> 00:00:36,280
out of this talk before I start my

00:00:33,550 --> 00:00:38,050
presentation just a small disclaimer all

00:00:36,280 --> 00:00:40,840
the proposal wouldn't show here are

00:00:38,050 --> 00:00:42,430
under construction the main intention

00:00:40,840 --> 00:00:45,910
here is to give you a sneak peek about

00:00:42,430 --> 00:00:48,190
the future of JavaScript and try to help

00:00:45,910 --> 00:00:51,550
you to understand the use case and the

00:00:48,190 --> 00:00:54,850
pros accounts and of all of these

00:00:51,550 --> 00:00:58,239
features and show there are mazing

00:00:54,850 --> 00:01:01,050
amazing work that the ct-9 community is

00:00:58,239 --> 00:01:03,820
doing to improve the language we love

00:01:01,050 --> 00:01:06,490
some of some of these feature may or may

00:01:03,820 --> 00:01:09,100
not be present on JavaScript if you like

00:01:06,490 --> 00:01:12,820
on of this proposal if you have some

00:01:09,100 --> 00:01:14,650
concern if you want to express your your

00:01:12,820 --> 00:01:17,560
support with some of these proposals

00:01:14,650 --> 00:01:19,870
please use this link below and open

00:01:17,560 --> 00:01:23,890
issue put a star and getting getting

00:01:19,870 --> 00:01:26,200
engaged so the agenda for today

00:01:23,890 --> 00:01:29,740
we are talk about parent matching

00:01:26,200 --> 00:01:32,950
pipeline operator binary AST and a gives

00:01:29,740 --> 00:01:35,650
an opinion so whenever you see a red

00:01:32,950 --> 00:01:38,980
border and the slide is just my opinion

00:01:35,650 --> 00:01:41,650
if you disagree just ignore or talk to

00:01:38,980 --> 00:01:44,790
me afterwards that said

00:01:41,650 --> 00:01:44,790
[Music]

00:01:51,590 --> 00:01:58,650
so to give up a quick background

00:01:54,630 --> 00:02:00,180
motivation of the first feature I want

00:01:58,650 --> 00:02:02,880
to talk about a bit more about a

00:02:00,180 --> 00:02:04,650
condition on JavaScript nowadays we have

00:02:02,880 --> 00:02:07,920
only three ways to do condition service

00:02:04,650 --> 00:02:10,560
in JavaScript we need to will we have an

00:02:07,920 --> 00:02:14,130
if-else statement switch statement and

00:02:10,560 --> 00:02:17,430
for an ternary expression just to setup

00:02:14,130 --> 00:02:19,680
common ground so everyone an expression

00:02:17,430 --> 00:02:23,070
is something that evaluates down to an

00:02:19,680 --> 00:02:26,489
value and in a statement is just

00:02:23,070 --> 00:02:28,500
something that does something so an

00:02:26,489 --> 00:02:31,230
if-else statement requires a condition

00:02:28,500 --> 00:02:34,890
which evaluates to true fee or false e

00:02:31,230 --> 00:02:38,790
value if the condition is true it

00:02:34,890 --> 00:02:40,920
executes the adjacent block and if it's

00:02:38,790 --> 00:02:44,370
not it tries to syke deathblow else

00:02:40,920 --> 00:02:46,380
block if you have one but it can get

00:02:44,370 --> 00:02:49,620
complicated let's check it out

00:02:46,380 --> 00:02:55,290
for this section I'm using this a simple

00:02:49,620 --> 00:02:57,420
function that just tries to return emoji

00:02:55,290 --> 00:03:01,799
that tries to reflect the chimp the

00:02:57,420 --> 00:03:04,709
current temperature as you can see here

00:03:01,799 --> 00:03:08,040
this function it's just an if statement

00:03:04,709 --> 00:03:10,500
that if it's true just return the demo G

00:03:08,040 --> 00:03:11,910
but else statement it's again another if

00:03:10,500 --> 00:03:14,549
statement so this is a way to

00:03:11,910 --> 00:03:18,209
concatenate and chain one if statement

00:03:14,549 --> 00:03:21,660
after the order it can get it can get

00:03:18,209 --> 00:03:26,810
really tricky because I'm not even talk

00:03:21,660 --> 00:03:26,810
about chain s the first statement right

00:03:29,640 --> 00:03:37,200
for this kind of special special checks

00:03:32,520 --> 00:03:39,150
when I have a lot of small lot of

00:03:37,200 --> 00:03:42,210
options in the small code to react to

00:03:39,150 --> 00:03:45,680
I think switch statements handy too so

00:03:42,210 --> 00:03:45,680
let's check how switch statement works

00:03:46,160 --> 00:03:53,550
so if statement is a it's good whenever

00:03:49,710 --> 00:03:56,820
you have you need to react to a couple

00:03:53,550 --> 00:04:00,690
of choice or you have a lot of a lot of

00:03:56,820 --> 00:04:02,700
chunk of code to execute but when you

00:04:00,690 --> 00:04:05,390
have a multiple choices and I just a

00:04:02,700 --> 00:04:07,590
small a small set of comments I think

00:04:05,390 --> 00:04:10,440
sweet statement could be a good choice

00:04:07,590 --> 00:04:13,590
the switch statement works as the

00:04:10,440 --> 00:04:16,950
following are given an expression inside

00:04:13,590 --> 00:04:21,390
the parentheses and switch it tries to

00:04:16,950 --> 00:04:23,490
match with each one of this case

00:04:21,390 --> 00:04:26,130
statement and when it matches with the

00:04:23,490 --> 00:04:29,520
first one it yep that's the starting

00:04:26,130 --> 00:04:32,970
point or point of this block statement

00:04:29,520 --> 00:04:40,190
and then that's why we have the break

00:04:32,970 --> 00:04:40,190
statement just to finalize the the block

00:04:40,400 --> 00:04:48,720
so come back to our initial example this

00:04:45,120 --> 00:04:50,880
is how we would write something using

00:04:48,720 --> 00:04:53,190
switch statement there are two things I

00:04:50,880 --> 00:04:56,280
want to highlight here first I'm not

00:04:53,190 --> 00:05:00,419
used using a break statement because

00:04:56,280 --> 00:05:02,940
just by using a return I have my

00:05:00,419 --> 00:05:04,500
function stopping at that at that line

00:05:02,940 --> 00:05:08,520
so that's why I don't need to use break

00:05:04,500 --> 00:05:13,200
and the second thing is people may not

00:05:08,520 --> 00:05:15,690
get it but the case Staton accepts

00:05:13,200 --> 00:05:17,610
expression as well so I can put instead

00:05:15,690 --> 00:05:21,240
of just a constant that this is not most

00:05:17,610 --> 00:05:23,100
used used use case there you just put a

00:05:21,240 --> 00:05:25,680
constant and you put this expression in

00:05:23,100 --> 00:05:28,290
switch so then I swap like I use the X

00:05:25,680 --> 00:05:30,660
and the constant in switch and I use the

00:05:28,290 --> 00:05:33,930
expression there

00:05:30,660 --> 00:05:36,930
so the ternary operator become popular

00:05:33,930 --> 00:05:40,380
recently because more for the functional

00:05:36,930 --> 00:05:42,090
developer fan and who tried to write the

00:05:40,380 --> 00:05:44,910
the code with as much expression as

00:05:42,090 --> 00:05:48,390
possible it basically works as the

00:05:44,910 --> 00:05:49,500
following given a condition if this if

00:05:48,390 --> 00:05:51,840
this condition is true

00:05:49,500 --> 00:05:55,230
it runs the first first block after the

00:05:51,840 --> 00:06:00,990
question mark if it's not it's false it

00:05:55,230 --> 00:06:03,090
runs what we have after column and since

00:06:00,990 --> 00:06:06,000
ternary expression eternal is a

00:06:03,090 --> 00:06:09,540
expression we can write that function

00:06:06,000 --> 00:06:10,950
using error function and that tries to

00:06:09,540 --> 00:06:14,510
make everything more concise

00:06:10,950 --> 00:06:16,950
but then you have a code like this and I

00:06:14,510 --> 00:06:18,240
don't know if you like I don't like but

00:06:16,950 --> 00:06:19,890
there are a lot of people that like this

00:06:18,240 --> 00:06:22,980
kind of code I'm not here to judge I'm

00:06:19,890 --> 00:06:24,600
just showing you and as you can see we

00:06:22,980 --> 00:06:27,030
have three ways to do conditions

00:06:24,600 --> 00:06:27,330
nowadays in JavaScript but what's the

00:06:27,030 --> 00:06:31,140
matter

00:06:27,330 --> 00:06:33,660
the fourth one could we imagine what

00:06:31,140 --> 00:06:36,030
could happen if you mix if statement

00:06:33,660 --> 00:06:38,850
with switch statement and the power of

00:06:36,030 --> 00:06:48,570
destruction destroy the structure in

00:06:38,850 --> 00:06:51,360
pattern variant matching to understand

00:06:48,570 --> 00:06:54,080
how parent match works I need to use a

00:06:51,360 --> 00:06:58,650
try example to be able to explore the

00:06:54,080 --> 00:07:00,900
parent matching statement so let's

00:06:58,650 --> 00:07:04,140
suppose I have a list of shapes and I

00:07:00,900 --> 00:07:07,760
need to log in detect all these circles

00:07:04,140 --> 00:07:10,860
Red Square Square and big blob try goes

00:07:07,760 --> 00:07:15,950
how could they do this nowadays with if

00:07:10,860 --> 00:07:21,240
statement just to give a small context

00:07:15,950 --> 00:07:23,190
this is the sample entry and this is one

00:07:21,240 --> 00:07:26,910
of potential a solution for the problem

00:07:23,190 --> 00:07:29,100
it's tricky because it can grow as the

00:07:26,910 --> 00:07:32,190
requirements grows right you can keep

00:07:29,100 --> 00:07:36,810
put if in there as more the more you

00:07:32,190 --> 00:07:39,960
have further requirements and as this is

00:07:36,810 --> 00:07:42,660
how we can do this using pattern

00:07:39,960 --> 00:07:43,800
matching because of the time here I will

00:07:42,660 --> 00:07:46,169
just explain the car

00:07:43,800 --> 00:07:48,569
concepts and if you are interested in it

00:07:46,169 --> 00:07:51,150
you can either check the documentation

00:07:48,569 --> 00:07:55,639
on the github repository talk to me

00:07:51,150 --> 00:07:58,169
afterwards this is the case statement

00:07:55,639 --> 00:08:03,090
which defines the start of the pattern

00:07:58,169 --> 00:08:05,879
matching block it receives only one

00:08:03,090 --> 00:08:10,199
value as input and this value is called

00:08:05,879 --> 00:08:12,720
case expression then we have the Wayne

00:08:10,199 --> 00:08:16,949
cause which is divine some parts I will

00:08:12,720 --> 00:08:19,229
just show two up then today again you

00:08:16,949 --> 00:08:21,930
can have more in the spec in a

00:08:19,229 --> 00:08:25,560
repository okay

00:08:21,930 --> 00:08:27,930
in this first wing close we are we have

00:08:25,560 --> 00:08:32,039
split into like the first part before

00:08:27,930 --> 00:08:35,570
the error is the match pattern and the

00:08:32,039 --> 00:08:38,579
second part is the Wayne cross body so

00:08:35,570 --> 00:08:41,159
the match parent pattern will execute

00:08:38,579 --> 00:08:43,440
the body whenever the shape of the

00:08:41,159 --> 00:08:46,320
pattern match the shape effects

00:08:43,440 --> 00:08:50,779
expression in this case every single

00:08:46,320 --> 00:08:54,540
object that has the type of sorry circle

00:08:50,779 --> 00:08:57,149
and then to achieve the second use a use

00:08:54,540 --> 00:09:04,170
case I can just create another pattern

00:08:57,149 --> 00:09:06,270
which is type square color red and and

00:09:04,170 --> 00:09:08,910
this step you see a if statement in the

00:09:06,270 --> 00:09:12,600
middle this is called match word it

00:09:08,910 --> 00:09:16,829
means that even though the the match

00:09:12,600 --> 00:09:19,560
match with the the object if the if

00:09:16,829 --> 00:09:22,529
statement which is called match world

00:09:19,560 --> 00:09:28,579
returns false it will not execute the

00:09:22,529 --> 00:09:32,250
the block and the last case is whenever

00:09:28,579 --> 00:09:35,579
we have a standalone variable it matched

00:09:32,250 --> 00:09:39,060
everything so it's kind of the full

00:09:35,579 --> 00:09:44,730
statement for for switch case but a bit

00:09:39,060 --> 00:09:48,120
different checking our checking our

00:09:44,730 --> 00:09:50,360
Nisha example this is how we should work

00:09:48,120 --> 00:09:56,420
with parent matching

00:09:50,360 --> 00:09:59,329
it's nice and if somehow we saw this

00:09:56,420 --> 00:10:00,829
talk before this would be the part that

00:09:59,329 --> 00:10:03,319
will start to complain why parent

00:10:00,829 --> 00:10:05,600
matching this is a statement but then

00:10:03,319 --> 00:10:09,439
the deceit or noncom he just changed

00:10:05,600 --> 00:10:11,389
this so very much in all languages is an

00:10:09,439 --> 00:10:13,129
expression and being a statement in

00:10:11,389 --> 00:10:15,769
JavaScript will be tricky because we

00:10:13,129 --> 00:10:18,559
wouldn't know we will it will be

00:10:15,769 --> 00:10:20,660
difficult to decide whether to use

00:10:18,559 --> 00:10:21,889
pattern matching or just a bunch of

00:10:20,660 --> 00:10:24,769
if-else statement

00:10:21,889 --> 00:10:27,860
but then if now that parent match is

00:10:24,769 --> 00:10:33,410
just an expression it's become as a

00:10:27,860 --> 00:10:37,189
powerful tool as a substitute for

00:10:33,410 --> 00:10:39,410
Fortran and expression and now they are

00:10:37,189 --> 00:10:40,699
trying to assess if we need to use if

00:10:39,410 --> 00:10:43,279
you need to have the when at the

00:10:40,699 --> 00:10:46,759
beginning of the wine clause or we just

00:10:43,279 --> 00:10:49,480
need to use the let Const or var so to

00:10:46,759 --> 00:10:54,619
give an example this is the way they're

00:10:49,480 --> 00:10:58,100
discussing that the syntax may look like

00:10:54,619 --> 00:11:00,619
do you like it you don't like it do you

00:10:58,100 --> 00:11:05,269
have a better idea again go to the

00:11:00,619 --> 00:11:06,949
repository and calm down okay before

00:11:05,269 --> 00:11:09,709
introduce the next proposal a last check

00:11:06,949 --> 00:11:11,299
whole function composition what is

00:11:09,709 --> 00:11:14,360
function composition how it works in

00:11:11,299 --> 00:11:15,850
JavaScript nowadays so function

00:11:14,360 --> 00:11:19,009
compositions are Mary mark my

00:11:15,850 --> 00:11:22,549
mathematical concept that allows you to

00:11:19,009 --> 00:11:25,850
combine multiple functions to create a

00:11:22,549 --> 00:11:28,549
new function so to help you to get the

00:11:25,850 --> 00:11:30,619
picture let's cook a bento I came up

00:11:28,549 --> 00:11:33,019
with this example because it's easy to

00:11:30,619 --> 00:11:36,649
easier to reason about food and I like

00:11:33,019 --> 00:11:38,480
to use emoji so this is just a function

00:11:36,649 --> 00:11:41,509
that creates a bento following sake with

00:11:38,480 --> 00:11:44,600
a sequential series of steps and where

00:11:41,509 --> 00:11:46,369
the next steps needs to receive the

00:11:44,600 --> 00:11:48,589
result from the previous steps so in

00:11:46,369 --> 00:11:50,779
this case to achieve this I need to have

00:11:48,589 --> 00:11:52,639
this intermediate intermediary variables

00:11:50,779 --> 00:11:55,910
just to hold the data to pass to the

00:11:52,639 --> 00:11:57,649
next function but I don't I don't want

00:11:55,910 --> 00:12:00,529
to use this intermediate variable just

00:11:57,649 --> 00:12:02,850
for this right but I can go I can go and

00:12:00,529 --> 00:12:05,970
write this kind of

00:12:02,850 --> 00:12:09,119
code which is not so easy to reason

00:12:05,970 --> 00:12:12,269
about because the more we compose the

00:12:09,119 --> 00:12:13,799
bigger is the invitation we have and the

00:12:12,269 --> 00:12:15,539
way we read the code is different the

00:12:13,799 --> 00:12:18,119
way the data flow because the data flow

00:12:15,539 --> 00:12:20,429
for the from the innermost function to

00:12:18,119 --> 00:12:22,709
the outermost function and we read this

00:12:20,429 --> 00:12:27,660
data usually top down that left and

00:12:22,709 --> 00:12:31,109
right right but I can use lodash flow

00:12:27,660 --> 00:12:35,100
for achieving a similar effect and make

00:12:31,109 --> 00:12:38,549
this more readable or use ram the pipe

00:12:35,100 --> 00:12:42,359
for this or even create my custom

00:12:38,549 --> 00:12:44,189
vanilla JavaScript function so wouldn't

00:12:42,359 --> 00:12:46,049
be nice to have all of this capability

00:12:44,189 --> 00:12:48,209
somehow incorporate to JavaScript

00:12:46,049 --> 00:12:50,699
without having to rely on this external

00:12:48,209 --> 00:12:53,129
library or create a custom homemade

00:12:50,699 --> 00:12:57,689
functions so let's bring the second

00:12:53,129 --> 00:13:03,989
javascript purpose of this talk pipeline

00:12:57,689 --> 00:13:07,079
operator so pipeline operate is as

00:13:03,989 --> 00:13:10,559
syntax sugar for creating streamlines

00:13:07,079 --> 00:13:11,429
chain of function in a readable in a

00:13:10,559 --> 00:13:14,100
functional manner

00:13:11,429 --> 00:13:15,720
it's backward compatible and provides

00:13:14,100 --> 00:13:20,039
alternative for extend building

00:13:15,720 --> 00:13:22,350
prototypes so our initial example was

00:13:20,039 --> 00:13:25,319
written and I like this snippet but

00:13:22,350 --> 00:13:26,639
using pipeline operator this will look

00:13:25,319 --> 00:13:30,769
more like this

00:13:26,639 --> 00:13:36,209
and then this will be the sugar to this

00:13:30,769 --> 00:13:38,189
it's nice right but what if one of my

00:13:36,209 --> 00:13:40,589
chaining functions needs one extra

00:13:38,189 --> 00:13:43,559
parameter let's suppose that the add

00:13:40,589 --> 00:13:45,809
fish function needs to receive a second

00:13:43,559 --> 00:13:47,549
parameter which is the type of fish I

00:13:45,809 --> 00:13:51,329
want to add them to my two great men

00:13:47,549 --> 00:13:54,179
agree how should we add this to the

00:13:51,329 --> 00:13:56,759
pipeline chain so to achieve this we can

00:13:54,179 --> 00:13:59,579
wrap this function with an arrow

00:13:56,759 --> 00:14:01,019
function so then we received only the

00:13:59,579 --> 00:14:04,919
result for the previous step and then

00:14:01,019 --> 00:14:06,269
add this to the next step and note that

00:14:04,919 --> 00:14:08,189
in the minimum propose the arrow

00:14:06,269 --> 00:14:09,509
function has to be wrapped with

00:14:08,189 --> 00:14:13,529
parentheses otherwise we will have a

00:14:09,509 --> 00:14:16,380
syntax error but the bento is not only

00:14:13,529 --> 00:14:19,860
about Nigri we need to put some stuff

00:14:16,380 --> 00:14:23,400
we need right I know how to do a agree

00:14:19,860 --> 00:14:26,130
it's kind of just like smash some rice

00:14:23,400 --> 00:14:28,170
and put a fish on top of it but it's

00:14:26,130 --> 00:14:31,760
simple but I just realized that I don't

00:14:28,170 --> 00:14:36,080
know how to toss my bento and I need to

00:14:31,760 --> 00:14:36,080
somehow delegate is to another function

00:14:36,380 --> 00:14:42,990
just figure out that I don't know how to

00:14:38,460 --> 00:14:45,660
semi the bento so I will delegate to

00:14:42,990 --> 00:14:47,940
this to a nursing function that will

00:14:45,660 --> 00:14:50,280
creating the assembly been tough for me

00:14:47,940 --> 00:14:53,730
but how can I do this using pipeline

00:14:50,280 --> 00:14:57,030
operator it's tricky right I could use a

00:14:53,730 --> 00:14:59,850
weight to await this function but there

00:14:57,030 --> 00:15:02,190
is a problem in it and note that the

00:14:59,850 --> 00:15:07,050
line for is ambiguous in explaining why

00:15:02,190 --> 00:15:09,600
now if the implementation add add mental

00:15:07,050 --> 00:15:12,630
it's just as straightforward async

00:15:09,600 --> 00:15:15,590
function I want to have this line this

00:15:12,630 --> 00:15:18,540
sugar to the line six like this one but

00:15:15,590 --> 00:15:20,970
if I have uncommon implementation which

00:15:18,540 --> 00:15:23,100
behaves like a factory that returns me a

00:15:20,970 --> 00:15:25,680
function that I need to call passing

00:15:23,100 --> 00:15:30,900
that the then agree to create the bento

00:15:25,680 --> 00:15:35,520
I would like to have this line BD sugar

00:15:30,900 --> 00:15:36,960
to this line six the problem is in the

00:15:35,520 --> 00:15:39,750
minimum proposal there is no guarantee

00:15:36,960 --> 00:15:41,670
that I can that that a weight step could

00:15:39,750 --> 00:15:46,710
be the sugar neither to the line fiber C

00:15:41,670 --> 00:15:48,390
or three or five as you can see the

00:15:46,710 --> 00:15:50,520
minimum proposal has some caveats that

00:15:48,390 --> 00:15:55,080
me we need to address in order to have

00:15:50,520 --> 00:15:58,440
this proposal progress in the tc39

00:15:55,080 --> 00:16:00,750
proposal pipeline currently we have two

00:15:58,440 --> 00:16:03,840
comparing proposal that tries to solve

00:16:00,750 --> 00:16:06,150
this in different ways so a one I want

00:16:03,840 --> 00:16:10,140
to explain first the smart pipeline

00:16:06,150 --> 00:16:11,910
proposal so as you can see here this is

00:16:10,140 --> 00:16:16,440
how I could solve this use this mattress

00:16:11,910 --> 00:16:18,150
is my pipeline and you can see that we

00:16:16,440 --> 00:16:20,130
have two styles there whenever you have

00:16:18,150 --> 00:16:23,460
like a just a straightforward function

00:16:20,130 --> 00:16:27,450
call you use the berry berry style and

00:16:23,460 --> 00:16:30,390
we never need to do like X passing extra

00:16:27,450 --> 00:16:33,130
parameters or user weights or

00:16:30,390 --> 00:16:35,760
use this in a different way you can use

00:16:33,130 --> 00:16:38,530
top Castillo there are some rules

00:16:35,760 --> 00:16:41,320
whenever you need to use parentheses and

00:16:38,530 --> 00:16:43,420
square brackets you have to use top

00:16:41,320 --> 00:16:46,150
Castillo otherwise you will have a

00:16:43,420 --> 00:16:49,480
single seatbacks error and the sharp is

00:16:46,150 --> 00:16:51,430
you saw in the previous step this sharp

00:16:49,480 --> 00:16:53,860
tokens is just a placeholder for the

00:16:51,430 --> 00:16:56,100
result of the previous step and it's not

00:16:53,860 --> 00:16:58,810
finally sharp it's subject to change

00:16:56,100 --> 00:17:02,980
there discuss if the short talk is the

00:16:58,810 --> 00:17:05,560
best way okay if I have a career donk

00:17:02,980 --> 00:17:07,570
ssin you have to use popke style

00:17:05,560 --> 00:17:10,120
otherwise again you have a syntax error

00:17:07,570 --> 00:17:12,670
because you're using parenthesis this

00:17:10,120 --> 00:17:15,130
proposal has extensive documentation for

00:17:12,670 --> 00:17:18,220
further enhancements over this card

00:17:15,130 --> 00:17:22,180
proposal again check that out and and

00:17:18,220 --> 00:17:24,610
and see what you think about it and as a

00:17:22,180 --> 00:17:26,440
counterpart we have the F sharp proposal

00:17:24,610 --> 00:17:29,680
that tries to address the this ambiguity

00:17:26,440 --> 00:17:34,090
of as a sinc function using one thing

00:17:29,680 --> 00:17:36,190
called a wait step it's sink it's in

00:17:34,090 --> 00:17:38,050
simpler but still we need to rap

00:17:36,190 --> 00:17:39,670
whenever you need to use extra

00:17:38,050 --> 00:17:41,740
parameters we need to wrap this function

00:17:39,670 --> 00:17:45,730
with an arrow function and this too we

00:17:41,740 --> 00:17:49,600
have the overhead of have these

00:17:45,730 --> 00:17:57,100
parentheses there but this could be a

00:17:49,600 --> 00:17:59,470
softening and enough food or proposal so

00:17:57,100 --> 00:18:01,210
just to summarize it's a nice addition

00:17:59,470 --> 00:18:03,720
to JavaScript to create an a

00:18:01,210 --> 00:18:08,140
streamlining way of composite functions

00:18:03,720 --> 00:18:10,720
the minimum proposed has two caveats the

00:18:08,140 --> 00:18:13,240
smart pipe line traces of that using a

00:18:10,720 --> 00:18:16,900
token and I have shark tries to solve

00:18:13,240 --> 00:18:20,830
that using a wedge step which brings to

00:18:16,900 --> 00:18:22,480
my rent my point is I really really like

00:18:20,830 --> 00:18:25,480
prattle on operator and I'm gonna have

00:18:22,480 --> 00:18:29,590
this shipped so JavaScript as soon as

00:18:25,480 --> 00:18:33,730
possible so then I have a proposal here

00:18:29,590 --> 00:18:35,500
I think F sharp proposes great and this

00:18:33,730 --> 00:18:38,200
only extends the minimum proposed with

00:18:35,500 --> 00:18:39,970
their weight step I think we should try

00:18:38,200 --> 00:18:41,620
to ship this as much as possible then

00:18:39,970 --> 00:18:43,660
afterwards we could have another

00:18:41,620 --> 00:18:46,330
proposal try to others

00:18:43,660 --> 00:18:50,110
they users you have the sharp token or

00:18:46,330 --> 00:18:54,160
not nevertheless Bobo has a plugin for

00:18:50,110 --> 00:18:59,680
using a smart pad planning proposal you

00:18:54,160 --> 00:19:03,010
can check that out and use on your to

00:18:59,680 --> 00:19:07,330
play a bit and then you have a formula

00:19:03,010 --> 00:19:08,950
or opinion okay before are we going to

00:19:07,330 --> 00:19:10,750
know or less proposal this presentation

00:19:08,950 --> 00:19:13,690
I would like to mention some performance

00:19:10,750 --> 00:19:15,610
tips have you ever heard about any of

00:19:13,690 --> 00:19:18,880
this JavaScript performance chips here

00:19:15,610 --> 00:19:21,460
do ever wonder why they are so important

00:19:18,880 --> 00:19:25,960
for the perceived performance of your

00:19:21,460 --> 00:19:29,200
application so 2010 this practice and

00:19:25,960 --> 00:19:31,480
and understand why they are important

00:19:29,200 --> 00:19:34,270
and why our next proposal is to relate

00:19:31,480 --> 00:19:38,770
to that we need first to check how

00:19:34,270 --> 00:19:42,300
javascript engine is generally words to

00:19:38,770 --> 00:19:45,550
roughly explain how the JavaScript works

00:19:42,300 --> 00:19:47,740
I would show this is I would use this

00:19:45,550 --> 00:19:49,350
illustrates terrible phone an excellent

00:19:47,740 --> 00:19:51,250
article from lenders money

00:19:49,350 --> 00:19:54,040
regarding the extractor extractor

00:19:51,250 --> 00:19:56,260
performance of JavaScript so whenever

00:19:54,040 --> 00:19:58,920
the browser's of writing script tag they

00:19:56,260 --> 00:20:01,960
try to download the text content of it

00:19:58,920 --> 00:20:04,090
then it tries to parse this text content

00:20:01,960 --> 00:20:07,240
and the result of this text content

00:20:04,090 --> 00:20:12,100
would be abstract syntax tree or ast

00:20:07,240 --> 00:20:16,330
which is 3 a tree representation of your

00:20:12,100 --> 00:20:18,640
code and then after this ast is done the

00:20:16,330 --> 00:20:22,390
browser starts to compile and create the

00:20:18,640 --> 00:20:24,910
bytecode so this last part is regarding

00:20:22,390 --> 00:20:28,060
a runtime opposite of optimizations that

00:20:24,910 --> 00:20:30,850
the browser does to make the JavaScript

00:20:28,060 --> 00:20:32,860
is the Kishin faster but this is not the

00:20:30,850 --> 00:20:36,400
the the their targets of this

00:20:32,860 --> 00:20:38,560
presentation okay to put in short

00:20:36,400 --> 00:20:41,050
javascript lifestyle lifestyle could be

00:20:38,560 --> 00:20:43,720
described generally as download parse

00:20:41,050 --> 00:20:46,950
compilation run optimization the

00:20:43,720 --> 00:20:49,630
optimization and the garbage collector

00:20:46,950 --> 00:20:52,470
but here I want to focus on on the

00:20:49,630 --> 00:20:52,470
parsing phase why

00:20:52,500 --> 00:20:58,270
thinking about the the code startup in

00:20:54,970 --> 00:21:00,190
JavaScript we can see that this is

00:20:58,270 --> 00:21:03,490
crucial for the perceived performance of

00:21:00,190 --> 00:21:05,680
an application so to make an application

00:21:03,490 --> 00:21:07,540
start faster we end up doing those

00:21:05,680 --> 00:21:11,350
things I mentioned the first slide of

00:21:07,540 --> 00:21:14,950
this section but one thing doesn't

00:21:11,350 --> 00:21:17,080
change the parsing time parsing the

00:21:14,950 --> 00:21:19,510
initial compilation of JavaScript can

00:21:17,080 --> 00:21:22,900
take up to 30 percent of the main thread

00:21:19,510 --> 00:21:25,180
time and 1 megabytes of uncompressed

00:21:22,900 --> 00:21:28,270
JavaScript can easily take a whole

00:21:25,180 --> 00:21:30,820
section second to be parsing an average

00:21:28,270 --> 00:21:33,010
mobile cell phone normally the browser

00:21:30,820 --> 00:21:37,420
needs to parse the whole fire before I

00:21:33,010 --> 00:21:38,980
start start compiling it and these are

00:21:37,420 --> 00:21:45,910
the motivation for the last propose of

00:21:38,980 --> 00:21:48,400
this talk binary AST the bunny HT

00:21:45,910 --> 00:21:51,970
proposal proposes a new over the wire

00:21:48,400 --> 00:21:55,800
format for the JavaScript based on the

00:21:51,970 --> 00:21:58,600
binary representation of the custom ast

00:21:55,800 --> 00:22:00,490
this could petition decrease this the

00:21:58,600 --> 00:22:03,910
code startup of a large JavaScript

00:22:00,490 --> 00:22:05,890
application and the browser that doesn't

00:22:03,910 --> 00:22:09,610
support it just load the normal

00:22:05,890 --> 00:22:11,740
javascript file so this is how it may

00:22:09,610 --> 00:22:13,540
work first you need to write your

00:22:11,740 --> 00:22:19,480
beautiful and delightful piece of

00:22:13,540 --> 00:22:23,560
JavaScript then you compile or bundle it

00:22:19,480 --> 00:22:26,460
user best flavor of bonder to spiral

00:22:23,560 --> 00:22:29,530
like that provides such a feature and

00:22:26,460 --> 00:22:33,940
this process will give not only the

00:22:29,530 --> 00:22:36,580
media's file but it will give you as

00:22:33,940 --> 00:22:39,130
well the binary representation of your

00:22:36,580 --> 00:22:41,110
javascript file so the browsers that

00:22:39,130 --> 00:22:43,870
support this formant could have the

00:22:41,110 --> 00:22:48,610
parsing their mask Lee domestically

00:22:43,870 --> 00:22:52,180
decreased since the majority of this

00:22:48,610 --> 00:22:54,190
tile task is done in build time so the

00:22:52,180 --> 00:22:57,700
chance of this proposal crater PLC on

00:22:54,190 --> 00:22:59,750
spider monkey using the JavaScript chess

00:22:57,700 --> 00:23:03,740
engine II and

00:22:59,750 --> 00:23:06,380
and they try to compile some JavaScript

00:23:03,740 --> 00:23:08,630
into binary st and measure the

00:23:06,380 --> 00:23:12,380
performance and this is the follow of

00:23:08,630 --> 00:23:15,110
the the following outcomes the result

00:23:12,380 --> 00:23:21,310
was the following they try they they use

00:23:15,110 --> 00:23:24,830
the static news feed from Facebook and

00:23:21,310 --> 00:23:27,740
the size of the binary st was slightly

00:23:24,830 --> 00:23:29,480
smaller than the original javascript the

00:23:27,740 --> 00:23:32,230
timing for create DST from plain

00:23:29,480 --> 00:23:35,420
JavaScript was between 500 800

00:23:32,230 --> 00:23:39,800
milliseconds but the time for create the

00:23:35,420 --> 00:23:41,510
binary st was twice as fast as before so

00:23:39,800 --> 00:23:44,660
the POC showed some evidence that

00:23:41,510 --> 00:23:47,240
shipping playing binary AST was a good

00:23:44,660 --> 00:23:49,760
performance wing and the extra

00:23:47,240 --> 00:23:53,750
annotation that the binary st is will

00:23:49,760 --> 00:23:56,630
have can enable enable Derrick that

00:23:53,750 --> 00:23:59,330
coordination without relying on plugins

00:23:56,630 --> 00:24:01,520
such tree shaking and this anotation

00:23:59,330 --> 00:24:04,010
Quinn could improve to the point that's

00:24:01,520 --> 00:24:06,830
possible to enable string compilation

00:24:04,010 --> 00:24:09,620
and if the performance of this

00:24:06,830 --> 00:24:11,440
hypothetical string compilation was

00:24:09,620 --> 00:24:14,870
close to the current it wasn't

00:24:11,440 --> 00:24:17,150
webassembly string compilation we can

00:24:14,870 --> 00:24:19,490
reach to the point that the compilation

00:24:17,150 --> 00:24:21,440
time for your JavaScript using this

00:24:19,490 --> 00:24:23,990
binary St could be faster than the data

00:24:21,440 --> 00:24:25,370
load time so you can start your

00:24:23,990 --> 00:24:31,970
application right after downloaded

00:24:25,370 --> 00:24:33,650
amazing right so these are footer read

00:24:31,970 --> 00:24:36,470
for you if we want to check that out

00:24:33,650 --> 00:24:40,940
like there's plenty more information

00:24:36,470 --> 00:24:44,240
these links these are my links if you

00:24:40,940 --> 00:24:46,520
want to reach me out if you wanna follow

00:24:44,240 --> 00:24:47,990
me on Twitter I don't do it so much but

00:24:46,520 --> 00:24:53,110
we need we tight with some JavaScript

00:24:47,990 --> 00:24:53,110

YouTube URL: https://www.youtube.com/watch?v=45fQHUmjqZQ


