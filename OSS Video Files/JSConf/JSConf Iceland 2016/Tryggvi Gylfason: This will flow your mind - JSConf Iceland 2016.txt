Title: Tryggvi Gylfason: This will flow your mind - JSConf Iceland 2016
Publication date: 2016-09-22
Playlist: JSConf Iceland 2016
Description: 
	This talk is about flow, a static type-checker for JavaScript which is developed and maintained by Facebook. We have been using flow extensively at QuizUp for half a year now and it's been a great success in a big JS codebase. In this talk I will answer the following questions:

What is it?
Why use it?
What can it do?
What can't it do?
Lastly I will go over lessons learned and our experience with using flow.
Captions: 
	00:00:12,550 --> 00:00:22,099
thanks for the introduction shower my

00:00:17,750 --> 00:00:23,840
name is trickery and you can follow

00:00:22,099 --> 00:00:25,910
along on speaker deck if you want to I

00:00:23,840 --> 00:00:27,619
put the slides are you can see the link

00:00:25,910 --> 00:00:31,279
there it's just the same as my twitter

00:00:27,619 --> 00:00:34,940
handle and the title of the talk is this

00:00:31,279 --> 00:00:37,760
will flow your mind and this talk is

00:00:34,940 --> 00:00:41,059
actually nested it has a sub talk in it

00:00:37,760 --> 00:00:45,020
the thing is that I found this one weird

00:00:41,059 --> 00:00:49,310
trick while making this talk and

00:00:45,020 --> 00:00:53,530
speakers will hate you for it it's how

00:00:49,310 --> 00:00:59,210
to find a title for your talk step one

00:00:53,530 --> 00:01:04,990
go to punch generator org look at the

00:00:59,210 --> 00:01:04,990
list and find something that you like

00:01:05,799 --> 00:01:14,920
other notable candidates were flow your

00:01:09,170 --> 00:01:19,759
own trumpet and flow in the towel so

00:01:14,920 --> 00:01:21,350
step through each prophet thank you but

00:01:19,759 --> 00:01:25,039
let me fall back to the original talk

00:01:21,350 --> 00:01:26,539
now so we've been using flow at

00:01:25,039 --> 00:01:29,869
Queenston for over half a year so we

00:01:26,539 --> 00:01:34,189
have kind of we have ever seen some of

00:01:29,869 --> 00:01:36,649
its ups and downs and i'll go into what

00:01:34,189 --> 00:01:37,969
it actually is in a moment but first i

00:01:36,649 --> 00:01:41,600
just want to briefly go over their

00:01:37,969 --> 00:01:43,700
structure of the talk the talk is very

00:01:41,600 --> 00:01:45,709
linear it's split into five sections and

00:01:43,700 --> 00:01:47,509
first this is the short introduction

00:01:45,709 --> 00:01:49,340
then are really shallow dive into the

00:01:47,509 --> 00:01:50,899
hood then I'll showcase some of the

00:01:49,340 --> 00:01:53,420
features that flow can do and some of

00:01:50,899 --> 00:01:55,189
its limitations and lastly I'll just go

00:01:53,420 --> 00:01:58,159
over the lessons some of the lessons we

00:01:55,189 --> 00:02:03,409
learned and color our experiences using

00:01:58,159 --> 00:02:10,340
it so how many of you have heard about

00:02:03,409 --> 00:02:11,810
flow okay a fair amount awesome so for

00:02:10,340 --> 00:02:14,450
those of you don't know flow is a static

00:02:11,810 --> 00:02:17,120
type checker for javascript it was open

00:02:14,450 --> 00:02:19,850
sourced by Facebook and November of 2014

00:02:17,120 --> 00:02:22,840
and that's their logo there it's kind of

00:02:19,850 --> 00:02:26,030
made out of these modules of triangles

00:02:22,840 --> 00:02:28,430
kind of and it's written in O'Connell

00:02:26,030 --> 00:02:32,060
it's maintained by a team of around five

00:02:28,430 --> 00:02:34,549
to seven people you can see the

00:02:32,060 --> 00:02:38,390
contributions to master on the getup

00:02:34,549 --> 00:02:40,540
repository since initial commit and it's

00:02:38,390 --> 00:02:44,810
kind of interesting to compare that to

00:02:40,540 --> 00:02:48,440
react flow is a little bit more than

00:02:44,810 --> 00:02:51,709
half younger then react the red line

00:02:48,440 --> 00:02:53,870
represents the lifetime of flow and we

00:02:51,709 --> 00:02:57,379
can see that react really goes out with

00:02:53,870 --> 00:03:01,430
a big bang and the Christmas months are

00:02:57,379 --> 00:03:04,099
like really busy on the other hand flow

00:03:01,430 --> 00:03:06,230
has this huge spike in contributions but

00:03:04,099 --> 00:03:10,370
then this kind of goes into hibernation

00:03:06,230 --> 00:03:13,069
for a few months but it's been picking

00:03:10,370 --> 00:03:15,530
up a lot of steam lately and over the

00:03:13,069 --> 00:03:17,420
last six months flow has actually been

00:03:15,530 --> 00:03:21,859
more actively developed and react in

00:03:17,420 --> 00:03:24,379
terms of contributions to master and to

00:03:21,859 --> 00:03:27,079
compare flow and react again for no good

00:03:24,379 --> 00:03:30,380
reason let's look at the punch cards of

00:03:27,079 --> 00:03:33,650
the projects we can see that flow

00:03:30,380 --> 00:03:36,919
contributors really hate contributing on

00:03:33,650 --> 00:03:41,930
Sunday mornings and they ship the

00:03:36,919 --> 00:03:44,329
hardest on Fridays but all nonsense

00:03:41,930 --> 00:03:48,560
aside what what what is this well what

00:03:44,329 --> 00:03:51,260
does it do how does it work so imagine

00:03:48,560 --> 00:03:54,319
that the blue dots are JavaScript files

00:03:51,260 --> 00:03:56,780
or modules if you will interconnected

00:03:54,319 --> 00:03:59,239
and depending on each other what flow

00:03:56,780 --> 00:04:01,250
does is it looks at those files parses

00:03:59,239 --> 00:04:02,630
them and creates from the raw source

00:04:01,250 --> 00:04:07,370
code this kind of format that it

00:04:02,630 --> 00:04:09,650
understands and once all the files have

00:04:07,370 --> 00:04:13,819
been parsed in this way we end up with

00:04:09,650 --> 00:04:15,440
what is called a flow chart and using

00:04:13,819 --> 00:04:17,959
the flow chart and this special format

00:04:15,440 --> 00:04:20,419
flow notes down what your code is doing

00:04:17,959 --> 00:04:22,520
for example what types go into functions

00:04:20,419 --> 00:04:24,949
and come out of functions either by

00:04:22,520 --> 00:04:28,280
inferring them or getting hints from

00:04:24,949 --> 00:04:30,919
developers what kind of hints am I

00:04:28,280 --> 00:04:32,780
talking about the hints are the type

00:04:30,919 --> 00:04:34,669
annotations that they put to the

00:04:32,780 --> 00:04:36,529
parameters and return types of functions

00:04:34,669 --> 00:04:38,329
you can see that the

00:04:36,529 --> 00:04:40,159
parameter has been annotated to be a

00:04:38,329 --> 00:04:44,059
number and the return type of this

00:04:40,159 --> 00:04:45,529
function must always be a string this is

00:04:44,059 --> 00:04:50,119
an example of a function the flow can

00:04:45,529 --> 00:04:52,039
fully understand flow is an opt-in tool

00:04:50,119 --> 00:04:54,229
so we put this special line at the top

00:04:52,039 --> 00:04:56,299
of files that we want to enable type

00:04:54,229 --> 00:04:58,459
checking in this way it's really easy to

00:04:56,299 --> 00:05:00,589
incrementally type check our large code

00:04:58,459 --> 00:05:04,939
base that can be really important and

00:05:00,589 --> 00:05:06,529
even vital to some projects you may not

00:05:04,939 --> 00:05:08,059
notice that this isn't actually valid

00:05:06,529 --> 00:05:10,519
JavaScript code if you try to run this

00:05:08,059 --> 00:05:12,739
you'll get a syntax error and that's

00:05:10,519 --> 00:05:16,459
because of the type annotations but

00:05:12,739 --> 00:05:18,709
luckily flow support type annotations

00:05:16,459 --> 00:05:20,299
inside of comments so the below function

00:05:18,709 --> 00:05:24,409
is actually valid JavaScript and you can

00:05:20,299 --> 00:05:27,349
run that but most projects nowadays use

00:05:24,409 --> 00:05:28,759
some kind of transporation step so it's

00:05:27,349 --> 00:05:30,859
really easy to just strip the type

00:05:28,759 --> 00:05:32,689
annotations from the above function with

00:05:30,859 --> 00:05:38,599
something like babe will precede react

00:05:32,689 --> 00:05:40,789
or flow remove types but why would we

00:05:38,599 --> 00:05:43,669
want to do this we have to type more as

00:05:40,789 --> 00:05:46,069
in typing on our keyboards we're adding

00:05:43,669 --> 00:05:47,989
restrictions to the code isn't a point

00:05:46,069 --> 00:05:52,189
of dynamic languages to be faster

00:05:47,989 --> 00:05:53,689
development and flexible and these

00:05:52,189 --> 00:05:55,399
questions kind of bring us to the next

00:05:53,689 --> 00:05:58,189
chapter of the talk which is why I

00:05:55,399 --> 00:06:01,729
usually use it let me make it clear that

00:05:58,189 --> 00:06:04,639
type checking might not be useful in all

00:06:01,729 --> 00:06:06,649
projects if the project this small scope

00:06:04,639 --> 00:06:08,869
tour short live it doesn't really

00:06:06,649 --> 00:06:10,969
benefit as much from type checking that

00:06:08,869 --> 00:06:13,099
being said flow is an opt-in tool so

00:06:10,969 --> 00:06:16,989
it's really easy to just type check few

00:06:13,099 --> 00:06:16,989
files and then go about your business

00:06:17,949 --> 00:06:25,249
one of the most compelling reasons to

00:06:20,419 --> 00:06:28,009
use type checker is bug prevention this

00:06:25,249 --> 00:06:30,919
function should always return an object

00:06:28,009 --> 00:06:34,279
no matter what it gets if it gets an

00:06:30,919 --> 00:06:37,099
object its return that object else it

00:06:34,279 --> 00:06:39,349
should return an empty object but this

00:06:37,099 --> 00:06:45,009
function has a classic javascript bug in

00:06:39,349 --> 00:06:45,009
it can anyone see it take a sec

00:06:46,410 --> 00:06:52,090
ya know right so in JavaScript no

00:06:50,320 --> 00:06:53,530
there's actually an object so if you

00:06:52,090 --> 00:06:56,170
would pass null to this function would

00:06:53,530 --> 00:06:58,890
go through it unharmed it won't resolve

00:06:56,170 --> 00:07:02,410
to an empty object like we expect it to

00:06:58,890 --> 00:07:07,930
so how we go about fixing this we could

00:07:02,410 --> 00:07:09,670
just add a simple mail check but this is

00:07:07,930 --> 00:07:12,820
exactly the kind of errors that flow can

00:07:09,670 --> 00:07:15,250
help you find if we would have added

00:07:12,820 --> 00:07:16,660
type annotations to this function pull

00:07:15,250 --> 00:07:18,550
over the totals hey this thing you're

00:07:16,660 --> 00:07:22,960
doing right here is not okay you have to

00:07:18,550 --> 00:07:24,880
check for now notice the type annotation

00:07:22,960 --> 00:07:27,580
on the x parameter has a question mark

00:07:24,880 --> 00:07:29,650
in front of it and that tells flow that

00:07:27,580 --> 00:07:32,170
X might be an object but it could also

00:07:29,650 --> 00:07:36,850
be null or undefined so it's kind of a

00:07:32,170 --> 00:07:38,290
maybe object other cases for using a

00:07:36,850 --> 00:07:40,780
static type checker other than bug

00:07:38,290 --> 00:07:43,480
prevention like this are auto completion

00:07:40,780 --> 00:07:47,950
and refactoring tools as well as that

00:07:43,480 --> 00:07:49,720
code elimination not all of those have

00:07:47,950 --> 00:07:52,300
been implemented into useful tools back

00:07:49,720 --> 00:08:01,540
by flow but auto-completion has and I'll

00:07:52,300 --> 00:08:05,170
go over that in sac so what can I do you

00:08:01,540 --> 00:08:08,110
can do auto completion so this is a

00:08:05,170 --> 00:08:09,580
retouched action created it might

00:08:08,110 --> 00:08:11,440
provide some context to those of you who

00:08:09,580 --> 00:08:14,920
know Redux but is not important for this

00:08:11,440 --> 00:08:17,110
example we're importing action types

00:08:14,920 --> 00:08:19,720
from another file and the action types

00:08:17,110 --> 00:08:22,090
are fully under flow fully understands

00:08:19,720 --> 00:08:24,160
these action types it knows all the

00:08:22,090 --> 00:08:27,910
properties on the object and the types

00:08:24,160 --> 00:08:30,310
of those properties here I'm using a

00:08:27,910 --> 00:08:33,430
plug-in called nuclide for the atom text

00:08:30,310 --> 00:08:36,099
editor it's it's developed by Facebook

00:08:33,430 --> 00:08:38,890
and it heavily integrates with flow it

00:08:36,099 --> 00:08:42,340
provides type checks and safe and in

00:08:38,890 --> 00:08:44,710
line adults just like each lens and also

00:08:42,340 --> 00:08:46,540
type coverage so I can show you which

00:08:44,710 --> 00:08:49,380
types flow can infer and which ones it

00:08:46,540 --> 00:08:49,380
doesn't really understand

00:08:53,810 --> 00:08:59,370
want to start typing the action types we

00:08:57,510 --> 00:09:02,160
can see that we get Auto completion for

00:08:59,370 --> 00:09:03,780
all of the properties and here I tried

00:09:02,160 --> 00:09:08,280
to access the error and throw and I can

00:09:03,780 --> 00:09:11,250
see that there are strings and this auto

00:09:08,280 --> 00:09:14,670
completion applies to all JavaScript

00:09:11,250 --> 00:09:18,530
native objects and all imports of

00:09:14,670 --> 00:09:18,530
libraries that you have definitions for

00:09:20,720 --> 00:09:26,490
fluids great support for a lot of new

00:09:23,400 --> 00:09:29,190
JavaScript features and it ships with

00:09:26,490 --> 00:09:33,560
support for native node libraries and

00:09:29,190 --> 00:09:33,560
native jscript JavaScript objects

00:09:33,680 --> 00:09:41,030
there's enough official repository that

00:09:36,210 --> 00:09:43,800
is trying to gather all of this these

00:09:41,030 --> 00:09:48,980
type signatures for all kinds of

00:09:43,800 --> 00:09:48,980
libraries you can also write your own

00:09:50,150 --> 00:09:55,310
it's also possible to do a little bit

00:09:53,280 --> 00:09:58,260
more complex things with type parameters

00:09:55,310 --> 00:10:00,300
so the big R and the big you here are

00:09:58,260 --> 00:10:06,990
just placeholders for some type that you

00:10:00,300 --> 00:10:09,240
will pass into this type this is a type

00:10:06,990 --> 00:10:11,310
which describes an object which is a van

00:10:09,240 --> 00:10:13,860
method that behaves exactly like the

00:10:11,310 --> 00:10:16,200
done method of a promise so it's kind of

00:10:13,860 --> 00:10:17,820
like an object which which is promise

00:10:16,200 --> 00:10:22,710
like it behaves a little bit like a

00:10:17,820 --> 00:10:26,190
promise and another thing the flow

00:10:22,710 --> 00:10:29,460
supports really well is react react is

00:10:26,190 --> 00:10:31,140
also developed by Facebook so naturally

00:10:29,460 --> 00:10:35,240
flow can understand a lot about react

00:10:31,140 --> 00:10:39,720
code let's look at one example of how

00:10:35,240 --> 00:10:43,530
how flow can help reactive elbers so

00:10:39,720 --> 00:10:45,960
flow can actually replace the the

00:10:43,530 --> 00:10:48,900
reactor prop types type checking the run

00:10:45,960 --> 00:10:52,110
the runtime type check that react you

00:10:48,900 --> 00:10:54,090
can you can do with react so you can you

00:10:52,110 --> 00:10:57,300
can throw away the runtime type checking

00:10:54,090 --> 00:10:59,550
in favor of static type checking here

00:10:57,300 --> 00:11:03,000
you can see a coffee image component

00:10:59,550 --> 00:11:05,020
which only has one prop its format and

00:11:03,000 --> 00:11:10,360
it can either be P&G or J

00:11:05,020 --> 00:11:14,710
back so if we start to use the coffee in

00:11:10,360 --> 00:11:17,940
it's in our application and we pass it a

00:11:14,710 --> 00:11:23,190
format and if we give it something else

00:11:17,940 --> 00:11:25,780
like a gif will get an inline error and

00:11:23,190 --> 00:11:28,600
the error says that this string isn't in

00:11:25,780 --> 00:11:32,250
the string item that you told me the

00:11:28,600 --> 00:11:34,960
format is so this can be really useful

00:11:32,250 --> 00:11:36,550
just for completeness sake we could have

00:11:34,960 --> 00:11:38,080
implemented coffee images to save this

00:11:36,550 --> 00:11:47,370
component and flow and support for that

00:11:38,080 --> 00:11:52,600
as well so what can't do this section is

00:11:47,370 --> 00:11:54,940
pretty short and pretty specific it

00:11:52,600 --> 00:11:59,500
can't warn about additional properties

00:11:54,940 --> 00:12:00,760
declared on a components prop type this

00:11:59,500 --> 00:12:02,860
is an example of what I'm talking about

00:12:00,760 --> 00:12:06,490
we have a hallow component which is only

00:12:02,860 --> 00:12:08,890
has one prop name and if we invoke it

00:12:06,490 --> 00:12:11,410
with another property like H we don't

00:12:08,890 --> 00:12:15,160
get matter at all this is something that

00:12:11,410 --> 00:12:19,350
the full team is looking into and will

00:12:15,160 --> 00:12:21,760
probably be improved in the near future

00:12:19,350 --> 00:12:24,310
the root cause of this is that flow

00:12:21,760 --> 00:12:26,770
doesn't really support exact object I'm

00:12:24,310 --> 00:12:29,260
kind of going to skip this slide but I

00:12:26,770 --> 00:12:34,330
want it in the slide deck so you can

00:12:29,260 --> 00:12:36,250
look at it later if you want to another

00:12:34,330 --> 00:12:38,470
thing that is problematic with flow are

00:12:36,250 --> 00:12:40,180
non-native data structures and what I

00:12:38,470 --> 00:12:42,370
mean by non-native data structures are

00:12:40,180 --> 00:12:45,250
their searches that don't behave like

00:12:42,370 --> 00:12:49,060
normal JavaScript native data structures

00:12:45,250 --> 00:12:51,250
like array and object for example we're

00:12:49,060 --> 00:12:53,530
using immutable J's a lot and it's

00:12:51,250 --> 00:12:55,990
really difficult to model mutable data

00:12:53,530 --> 00:12:58,360
structures and flow I think it's mainly

00:12:55,990 --> 00:12:59,920
because of how the API is constructed if

00:12:58,360 --> 00:13:02,020
you're going to access a property deep

00:12:59,920 --> 00:13:03,910
down in our object you have to give it a

00:13:02,020 --> 00:13:08,410
key path which is an array of strings

00:13:03,910 --> 00:13:10,690
it's really hard to model that but the

00:13:08,410 --> 00:13:12,640
good news is that in a recent QA the

00:13:10,690 --> 00:13:16,770
fluid flow team revealed that better

00:13:12,640 --> 00:13:16,770
support for immutability is in the works

00:13:17,500 --> 00:13:21,940
again I'm kind of going to skip this

00:13:19,810 --> 00:13:27,840
slide this is this is how we're doing it

00:13:21,940 --> 00:13:31,330
right now it's not really that good and

00:13:27,840 --> 00:13:34,750
you can see that the kyare I was talking

00:13:31,330 --> 00:13:35,800
about the keypad on line fourteen again

00:13:34,750 --> 00:13:40,510
I'm going to skip this slide you can

00:13:35,800 --> 00:13:42,850
look at it later if you want to this is

00:13:40,510 --> 00:13:44,800
the last section of the talk I'll go

00:13:42,850 --> 00:13:50,560
over some of the lessons learned then

00:13:44,800 --> 00:13:52,240
kind of our experiences using flow so

00:13:50,560 --> 00:13:54,160
the first point i want to make is but

00:13:52,240 --> 00:13:57,010
it's super easy to start using an

00:13:54,160 --> 00:13:59,050
existing project we have internal tools

00:13:57,010 --> 00:14:00,940
that amount to about 60,000 lines of

00:13:59,050 --> 00:14:02,470
JavaScript code and we started type

00:14:00,940 --> 00:14:05,410
checking just a few files to see how it

00:14:02,470 --> 00:14:07,240
felt and flow even copped some existing

00:14:05,410 --> 00:14:09,340
errors while we're integrating it

00:14:07,240 --> 00:14:12,550
indoors are a codebase incrementally

00:14:09,340 --> 00:14:17,980
that would just what we're there since

00:14:12,550 --> 00:14:20,650
the beginning and sometimes it doesn't

00:14:17,980 --> 00:14:22,600
really make much sense to type check for

00:14:20,650 --> 00:14:24,550
example functions which do really basic

00:14:22,600 --> 00:14:27,310
operations flow can usually infer the

00:14:24,550 --> 00:14:28,720
types of those functions so here's an

00:14:27,310 --> 00:14:31,510
example of a function that flow can

00:14:28,720 --> 00:14:33,520
fully understand you can infer the type

00:14:31,510 --> 00:14:36,910
of the parameter and the return type of

00:14:33,520 --> 00:14:38,410
the function and nuclide can really help

00:14:36,910 --> 00:14:40,690
you here nuclear there's the plugin for

00:14:38,410 --> 00:14:42,400
the atom text of the door and it can

00:14:40,690 --> 00:14:45,190
highlight which part of the javascript

00:14:42,400 --> 00:14:51,850
file flow can infer and which ones you

00:14:45,190 --> 00:14:54,070
can't try to avoid type laziness it can

00:14:51,850 --> 00:14:56,950
be really tempting sometimes to just

00:14:54,070 --> 00:14:59,560
write object when you're describing a

00:14:56,950 --> 00:15:01,780
type instead of creating a more

00:14:59,560 --> 00:15:04,810
descriptive type that conveys more

00:15:01,780 --> 00:15:07,150
information to flow this is happen to us

00:15:04,810 --> 00:15:09,760
on several occasion and and it really

00:15:07,150 --> 00:15:14,010
diminishes the benefits of static type

00:15:09,760 --> 00:15:17,800
checking so try to avoid doing this and

00:15:14,010 --> 00:15:21,990
do this instead notice the difference in

00:15:17,800 --> 00:15:21,990
the power of parameter type annotation

00:15:29,660 --> 00:15:34,310
adding type annotations in some cases

00:15:32,810 --> 00:15:38,330
has made a code a little bit more

00:15:34,310 --> 00:15:39,380
understandable and readable and when

00:15:38,330 --> 00:15:41,210
you're looking at code that someone

00:15:39,380 --> 00:15:43,660
somebody else wrote it kind of takes

00:15:41,210 --> 00:15:48,110
just a little bit less mental power to

00:15:43,660 --> 00:15:52,370
understand what what's going on I love

00:15:48,110 --> 00:15:54,200
healthy discussion has also surfaced as

00:15:52,370 --> 00:15:57,110
an effect of using the flow type system

00:15:54,200 --> 00:15:58,490
for example in code reviews questions

00:15:57,110 --> 00:16:00,590
like should this be able to return

00:15:58,490 --> 00:16:03,530
undefined or should this parameter be

00:16:00,590 --> 00:16:09,020
optional are discussed so it really has

00:16:03,530 --> 00:16:11,900
a positive effect on code quality so to

00:16:09,020 --> 00:16:14,360
sum it up flow has been a great success

00:16:11,900 --> 00:16:16,730
at quizup it's really improved our

00:16:14,360 --> 00:16:18,710
development experience by a lot and I

00:16:16,730 --> 00:16:20,030
recommend using that usually try it out

00:16:18,710 --> 00:16:23,390
if you're maintaining a JavaScript code

00:16:20,030 --> 00:16:25,820
 and I hope some of this stuff blew

00:16:23,390 --> 00:16:27,200
your mind but just in case that no one's

00:16:25,820 --> 00:16:34,060
mind was blown I'm going to blow this

00:16:27,200 --> 00:16:34,060

YouTube URL: https://www.youtube.com/watch?v=p6rybcXZOD0


