Title: Lin Clark: A cartoon guide to performance in React - JSConf Iceland 2016
Publication date: 2016-09-15
Playlist: JSConf Iceland 2016
Description: 
	Everyone talks about how performant React is... but why? What makes people talk about how speedy React is? In this talk, you'll learn why people talk about React being fast, and what you can do to make it faster.
Captions: 
	00:00:13,809 --> 00:00:21,020
hi everyone I'm Lin Clark and I make

00:00:17,930 --> 00:00:24,250
Coke cartoons and I also work at Mozilla

00:00:21,020 --> 00:00:26,750
of course we make the Firefox browser

00:00:24,250 --> 00:00:28,399
but you might not know we have a few

00:00:26,750 --> 00:00:30,200
other browser projects in the works at

00:00:28,399 --> 00:00:32,870
the moment too and one of them uses

00:00:30,200 --> 00:00:34,760
react so I was working on this project I

00:00:32,870 --> 00:00:37,070
was hacking on it I thought I should

00:00:34,760 --> 00:00:39,050
really dive more deeply into Reax

00:00:37,070 --> 00:00:41,059
internals to see how it's doing things

00:00:39,050 --> 00:00:44,149
so that I can make our project more

00:00:41,059 --> 00:00:45,230
performant and what happened when I do

00:00:44,149 --> 00:00:47,749
that is I had to step through the

00:00:45,230 --> 00:00:49,670
virtual Dom algorithm over and over and

00:00:47,749 --> 00:00:51,710
over and over and over and over again

00:00:49,670 --> 00:00:53,239
and so I figured as long as I had gone

00:00:51,710 --> 00:00:54,920
through that process I might as well

00:00:53,239 --> 00:00:56,989
write it down and turn it into a cartoon

00:00:54,920 --> 00:00:59,839
so that other people could share the

00:00:56,989 --> 00:01:03,199
benefit of that so that is what started

00:00:59,839 --> 00:01:05,540
this talk I'm gonna be focusing on the

00:01:03,199 --> 00:01:07,670
performance what you can do to make your

00:01:05,540 --> 00:01:09,590
react apps more performant and I should

00:01:07,670 --> 00:01:10,670
start by saying that I'm not gonna be

00:01:09,590 --> 00:01:12,799
telling you anything that you don't

00:01:10,670 --> 00:01:15,020
already know I'm gonna be talking about

00:01:12,799 --> 00:01:18,470
things like keys and should component

00:01:15,020 --> 00:01:20,440
update and immutability the reason I

00:01:18,470 --> 00:01:23,690
wanted to talk about them though is

00:01:20,440 --> 00:01:26,690
because I think that we often have this

00:01:23,690 --> 00:01:28,460
fuzzy concept of the ideas around

00:01:26,690 --> 00:01:30,470
performance again we don't really take

00:01:28,460 --> 00:01:34,370
the time to bring those concepts into

00:01:30,470 --> 00:01:35,720
focus so this means that the knowledge

00:01:34,370 --> 00:01:38,810
about these ideas

00:01:35,720 --> 00:01:40,430
it's just received knowledge you know

00:01:38,810 --> 00:01:42,380
you just add a show component update

00:01:40,430 --> 00:01:43,910
because somebody told you on was

00:01:42,380 --> 00:01:47,450
standing on a stage and they told you to

00:01:43,910 --> 00:01:50,450
do that but not all recommendations work

00:01:47,450 --> 00:01:52,070
the same in all situations so I want to

00:01:50,450 --> 00:01:54,920
bring these concepts around performance

00:01:52,070 --> 00:01:57,200
into focus so that you can have a better

00:01:54,920 --> 00:02:00,680
understanding of the why behind each

00:01:57,200 --> 00:02:02,390
recommendation and I should also say

00:02:00,680 --> 00:02:05,120
before I start that I'm focusing on a

00:02:02,390 --> 00:02:07,100
very specific part of render perform of

00:02:05,120 --> 00:02:09,709
performance and react and that is

00:02:07,100 --> 00:02:11,090
performance during the render cycle so

00:02:09,709 --> 00:02:13,430
other things that you can do to make

00:02:11,090 --> 00:02:15,349
react more performant are things like if

00:02:13,430 --> 00:02:17,030
you're in production use the production

00:02:15,349 --> 00:02:18,860
version of react those kinds of things

00:02:17,030 --> 00:02:20,420
does have a huge impact and a lot of

00:02:18,860 --> 00:02:22,730
people slip up and don't realize that

00:02:20,420 --> 00:02:23,930
they're doing that but

00:02:22,730 --> 00:02:28,610
I'm not gonna talk about those little

00:02:23,930 --> 00:02:29,450
gotchas so the talks gonna go a little

00:02:28,610 --> 00:02:31,940
something like this

00:02:29,450 --> 00:02:33,470
first I'm gonna talk about the basics of

00:02:31,940 --> 00:02:35,000
rendering in the browser so how the

00:02:33,470 --> 00:02:36,980
browser actually renders your web page

00:02:35,000 --> 00:02:40,459
and what parts of that can possibly be

00:02:36,980 --> 00:02:42,860
slow and then I'm gonna talk about what

00:02:40,459 --> 00:02:45,319
react does to minimize and batch Dom

00:02:42,860 --> 00:02:48,799
changes with the virtual Dom to make it

00:02:45,319 --> 00:02:53,090
a little bit faster and then I'm gonna

00:02:48,799 --> 00:02:57,860
cover what you can do to make react even

00:02:53,090 --> 00:02:59,930
faster than that so let's start with

00:02:57,860 --> 00:03:01,790
number one how the browser builds your

00:02:59,930 --> 00:03:05,810
web page how it actually renders the

00:03:01,790 --> 00:03:07,340
page and what parts are slow and you can

00:03:05,810 --> 00:03:09,799
kind of think of this in the same way

00:03:07,340 --> 00:03:12,470
that you think of developing the website

00:03:09,799 --> 00:03:14,599
yourself so there's work that takes

00:03:12,470 --> 00:03:16,640
place over time and there's an initial

00:03:14,599 --> 00:03:18,230
period of work this would be before the

00:03:16,640 --> 00:03:20,019
initial launch if you were developing

00:03:18,230 --> 00:03:23,230
you know in the development process and

00:03:20,019 --> 00:03:26,540
in react this is the initial render and

00:03:23,230 --> 00:03:29,540
then there are updates that happen after

00:03:26,540 --> 00:03:31,040
that so in if you were working on a

00:03:29,540 --> 00:03:34,669
project that would be any feature

00:03:31,040 --> 00:03:35,780
updates if you're working in react that

00:03:34,669 --> 00:03:40,669
is gonna be something like this that

00:03:35,780 --> 00:03:42,290
says date updating the UI to extend this

00:03:40,669 --> 00:03:43,880
metaphor your code is kind of like the

00:03:42,290 --> 00:03:46,720
project Li planning the project and

00:03:43,880 --> 00:03:49,940
telling folks what to do unfortunately

00:03:46,720 --> 00:03:52,250
your code only has one person working on

00:03:49,940 --> 00:03:56,180
this project for it and that's the main

00:03:52,250 --> 00:03:59,480
thread so the main thread is kind of

00:03:56,180 --> 00:04:00,819
like a JavaScript developer it err sorry

00:03:59,480 --> 00:04:04,419
it's kind of like a full-stack developer

00:04:00,819 --> 00:04:06,349
it covers JavaScript the Dom and layout

00:04:04,419 --> 00:04:08,840
just as when you're working on a project

00:04:06,349 --> 00:04:10,280
in real life if you only have one person

00:04:08,840 --> 00:04:12,739
working on the project you're gonna

00:04:10,280 --> 00:04:15,169
limit the number of tasks that you

00:04:12,739 --> 00:04:19,039
assign to that one person if you want

00:04:15,169 --> 00:04:20,840
that project to be delivered on time but

00:04:19,039 --> 00:04:22,669
before we know how to reduce the amount

00:04:20,840 --> 00:04:24,650
of work that the main thread is doing we

00:04:22,669 --> 00:04:27,440
need to know more about the work that

00:04:24,650 --> 00:04:29,449
the main thread does so as I mentioned

00:04:27,440 --> 00:04:31,880
before the main thread is in charge of

00:04:29,449 --> 00:04:33,110
JavaScript so this is you know you're

00:04:31,880 --> 00:04:34,640
familiar with JavaScript this is where

00:04:33,110 --> 00:04:37,120
you define your functions where you call

00:04:34,640 --> 00:04:37,120
functions

00:04:38,350 --> 00:04:43,570
the DOM is the way the functions tell

00:04:42,020 --> 00:04:45,680
the page what to do

00:04:43,570 --> 00:04:47,390
basically the Dom gives you a set of

00:04:45,680 --> 00:04:49,850
objects that you can move around and

00:04:47,390 --> 00:04:52,490
manipulate in order to change what the

00:04:49,850 --> 00:04:53,840
browsers rendering and the way that this

00:04:52,490 --> 00:04:56,360
works is that there's something behind

00:04:53,840 --> 00:04:58,370
the scenes called the render tree and so

00:04:56,360 --> 00:05:01,220
the main thread combines the Dom with

00:04:58,370 --> 00:05:02,540
CSS to create the render tree and it

00:05:01,220 --> 00:05:05,330
figures out a thing from that called the

00:05:02,540 --> 00:05:06,950
box model and this is what it passes off

00:05:05,330 --> 00:05:10,310
to the thing that actually passes the

00:05:06,950 --> 00:05:12,470
pixels to the page this little process

00:05:10,310 --> 00:05:14,930
is called a reflow and that computation

00:05:12,470 --> 00:05:16,880
takes a bit of time so the main thread

00:05:14,930 --> 00:05:18,590
doesn't do it on every single Dom change

00:05:16,880 --> 00:05:20,690
instead what it tries to do is bash

00:05:18,590 --> 00:05:23,240
those changes together so that it can

00:05:20,690 --> 00:05:26,900
cover more of them in a single pass

00:05:23,240 --> 00:05:28,730
through computing the render tree so the

00:05:26,900 --> 00:05:30,800
way this works is you know your code

00:05:28,730 --> 00:05:33,980
might say change the class name on that

00:05:30,800 --> 00:05:38,120
button and then the main thread goes

00:05:33,980 --> 00:05:39,590
over and does it and then additive the

00:05:38,120 --> 00:05:41,750
main thread goes over and does it and

00:05:39,590 --> 00:05:44,780
then add another button the main thread

00:05:41,750 --> 00:05:47,510
goes over and does it the main thread

00:05:44,780 --> 00:05:49,400
will also meet a note to itself sometime

00:05:47,510 --> 00:05:51,680
in the future I need to recalculate that

00:05:49,400 --> 00:05:53,930
render tree and so when that time in the

00:05:51,680 --> 00:05:56,690
future comes is going to go over to the

00:05:53,930 --> 00:06:00,680
render tree and calculate all of those

00:05:56,690 --> 00:06:01,820
things together so we want to reduce the

00:06:00,680 --> 00:06:04,580
amount of work that the main thread is

00:06:01,820 --> 00:06:07,940
doing here you might have figured out

00:06:04,580 --> 00:06:11,120
two good ways one way is to reduce the

00:06:07,940 --> 00:06:13,490
number of Dom changes and another way is

00:06:11,120 --> 00:06:15,470
to batch those Dom changes together in

00:06:13,490 --> 00:06:16,880
time so that the main thread can take

00:06:15,470 --> 00:06:19,880
care of all that recalculation on the

00:06:16,880 --> 00:06:22,850
same reflow and this is something that

00:06:19,880 --> 00:06:24,980
react helps you do now I want to be

00:06:22,850 --> 00:06:26,780
clear react isn't the only way to do

00:06:24,980 --> 00:06:29,570
this it's actually not even a necessary

00:06:26,780 --> 00:06:32,120
way of doing this these ideas have been

00:06:29,570 --> 00:06:33,680
around since well before react so it's

00:06:32,120 --> 00:06:37,640
not that react is necessarily more

00:06:33,680 --> 00:06:39,650
performant than vanilla JavaScript the

00:06:37,640 --> 00:06:41,810
thing is in order to get these

00:06:39,650 --> 00:06:44,360
performance gains your code has to be

00:06:41,810 --> 00:06:46,700
smart your code needs to know how to

00:06:44,360 --> 00:06:48,660
direct the main thread pretty precisely

00:06:46,700 --> 00:06:51,010
to do these things

00:06:48,660 --> 00:06:52,150
so go back to the metaphor your code

00:06:51,010 --> 00:06:54,580
needs to be able it's a really really

00:06:52,150 --> 00:06:58,330
good product manager it needs to know

00:06:54,580 --> 00:06:59,710
what to display in this webpage and it

00:06:58,330 --> 00:07:01,690
also needs to be a really really good

00:06:59,710 --> 00:07:05,280
tech lead it needs to know how to build

00:07:01,690 --> 00:07:05,280
the page in the most efficient way of

00:07:05,340 --> 00:07:09,670
course your code is only as smart as you

00:07:07,750 --> 00:07:10,930
make it so that means that all of the

00:07:09,670 --> 00:07:13,540
developers on your team have to have a

00:07:10,930 --> 00:07:15,850
really solid understanding of how these

00:07:13,540 --> 00:07:17,590
things work together and they need to

00:07:15,850 --> 00:07:19,240
not be prone to making mistakes they

00:07:17,590 --> 00:07:19,930
always need to be on their game on top

00:07:19,240 --> 00:07:21,970
of their game

00:07:19,930 --> 00:07:24,970
so what react does for you is it

00:07:21,970 --> 00:07:26,950
offloads that work it's kind of like

00:07:24,970 --> 00:07:29,620
your code brings in the consultant to do

00:07:26,950 --> 00:07:30,940
all the tech leave work and that frees

00:07:29,620 --> 00:07:33,250
up your code just to be a good product

00:07:30,940 --> 00:07:35,260
manager so that your code can just focus

00:07:33,250 --> 00:07:38,800
on what needs to be displayed not on how

00:07:35,260 --> 00:07:40,990
to make it happen so let's take a look

00:07:38,800 --> 00:07:43,240
at how these to react in your code work

00:07:40,990 --> 00:07:46,750
together to direct the main thread in

00:07:43,240 --> 00:07:47,920
shipping and I won't be showing the main

00:07:46,750 --> 00:07:49,630
thread through the rest of the slides

00:07:47,920 --> 00:07:53,100
but just assume wherever you're seeing

00:07:49,630 --> 00:07:55,870
work being done the main thread is there

00:07:53,100 --> 00:07:58,680
so this brings us to part two how react

00:07:55,870 --> 00:08:01,540
minimizes work using the virtual DOM and

00:07:58,680 --> 00:08:05,050
I'm going to start this off with a UI

00:08:01,540 --> 00:08:07,000
that we're gonna build so this UI is

00:08:05,050 --> 00:08:10,030
just a list of numbers and when you

00:08:07,000 --> 00:08:12,820
click the button the numbers multiply by

00:08:10,030 --> 00:08:15,490
itself so let's walk through the initial

00:08:12,820 --> 00:08:18,640
render on this most are from the very

00:08:15,490 --> 00:08:21,370
beginning a user is downloaded some HTML

00:08:18,640 --> 00:08:22,840
and it's been parsed and there is an

00:08:21,370 --> 00:08:26,830
HTML element that's going to serve as

00:08:22,840 --> 00:08:28,360
the container for the react app and your

00:08:26,830 --> 00:08:30,040
code has been loaded and react has been

00:08:28,360 --> 00:08:32,169
loaded along with your code these things

00:08:30,040 --> 00:08:33,610
called components have been loaded and

00:08:32,169 --> 00:08:35,229
so these are kind of like deputy product

00:08:33,610 --> 00:08:37,080
managers that know about specific parts

00:08:35,229 --> 00:08:40,930
of the page and what they should render

00:08:37,080 --> 00:08:43,960
and in case you aren't familiar this is

00:08:40,930 --> 00:08:46,930
what code that corresponds to react Dom

00:08:43,960 --> 00:08:50,770
render and then the first parameter is

00:08:46,930 --> 00:08:53,200
list asking as a react element and then

00:08:50,770 --> 00:08:54,490
the second parameter is the HTML

00:08:53,200 --> 00:08:56,020
container that we were just talking

00:08:54,490 --> 00:09:00,330
about so we covered that HTML container

00:08:56,020 --> 00:09:00,330
but what is the react element

00:09:00,770 --> 00:09:05,300
it's a way for your code to handoff

00:09:02,720 --> 00:09:08,180
requirements to react to tell react what

00:09:05,300 --> 00:09:10,520
needs to be displayed so following the

00:09:08,180 --> 00:09:12,200
analogy it's like a little note card

00:09:10,520 --> 00:09:15,950
that has a few notes about what react

00:09:12,200 --> 00:09:17,330
needs to build it has the type which is

00:09:15,950 --> 00:09:19,459
the component that's gonna be used to

00:09:17,330 --> 00:09:22,310
build the thing and has the props and

00:09:19,459 --> 00:09:23,630
children and reacts gonna hold on to the

00:09:22,310 --> 00:09:25,370
style element is just gonna tuck this

00:09:23,630 --> 00:09:29,720
note card away until it's ready to build

00:09:25,370 --> 00:09:31,190
the thing the thing that it builds using

00:09:29,720 --> 00:09:33,500
these specs using this these

00:09:31,190 --> 00:09:36,380
requirements is an instance of the

00:09:33,500 --> 00:09:38,660
component so an instance is the thing

00:09:36,380 --> 00:09:40,370
that holds on to the state is the thing

00:09:38,660 --> 00:09:43,240
that you call this dot set state on the

00:09:40,370 --> 00:09:45,980
thing that holds on to the Refs

00:09:43,240 --> 00:09:47,180
it's the thing that react uses to figure

00:09:45,980 --> 00:09:50,300
out whether or not it means to update

00:09:47,180 --> 00:09:51,740
the Dom but you don't actually interact

00:09:50,300 --> 00:09:53,750
with instances too much you don't need

00:09:51,740 --> 00:09:56,120
to manage instances react manages the

00:09:53,750 --> 00:09:57,980
instances for you you just need to give

00:09:56,120 --> 00:10:01,490
it these requirements and form of

00:09:57,980 --> 00:10:05,510
elements so your code asks for an

00:10:01,490 --> 00:10:07,250
element and react creates it and then

00:10:05,510 --> 00:10:09,350
your code tells react to start rendering

00:10:07,250 --> 00:10:11,300
this is react Dom render your code tells

00:10:09,350 --> 00:10:14,089
react to start rendering that element

00:10:11,300 --> 00:10:17,839
into the container and this begins

00:10:14,089 --> 00:10:19,399
construction of reacts render tree now

00:10:17,839 --> 00:10:21,170
if you don't follow I'm gonna have to

00:10:19,399 --> 00:10:23,060
move through this pretty quickly but

00:10:21,170 --> 00:10:25,220
this is being recorded so you can catch

00:10:23,060 --> 00:10:28,130
up on it there and if you want a version

00:10:25,220 --> 00:10:30,740
of this for yourself I've posted it on

00:10:28,130 --> 00:10:32,420
Twitter both Lin Clark & Co cartoons so

00:10:30,740 --> 00:10:36,140
you can go there and download a version

00:10:32,420 --> 00:10:38,029
of this I should say say before I start

00:10:36,140 --> 00:10:39,950
going through this algorithm it has

00:10:38,029 --> 00:10:41,870
changed it actually has changed since I

00:10:39,950 --> 00:10:44,089
started writing this talk and it will

00:10:41,870 --> 00:10:45,560
change again there are some pretty big

00:10:44,089 --> 00:10:48,440
changes to this algorithm in the

00:10:45,560 --> 00:10:51,709
pipeline currently but for now this is

00:10:48,440 --> 00:10:53,329
how it works so react starts by creating

00:10:51,709 --> 00:10:56,630
this thing called a top level wrapper

00:10:53,329 --> 00:10:58,220
and it's just a little implementation

00:10:56,630 --> 00:11:01,910
detail it makes it easier for react to

00:10:58,220 --> 00:11:03,320
wrap up some stuff together then it

00:11:01,910 --> 00:11:05,240
creates an instance of that top level

00:11:03,320 --> 00:11:06,860
wrapper and it sets it so that when it

00:11:05,240 --> 00:11:10,220
calls render on that top level wrapper

00:11:06,860 --> 00:11:12,650
is going to render to the list this is

00:11:10,220 --> 00:11:14,570
the raft element that was passed in

00:11:12,650 --> 00:11:16,730
which has now been instantiated

00:11:14,570 --> 00:11:18,590
so it's that's the province date on the

00:11:16,730 --> 00:11:22,070
list and then it wants to create the

00:11:18,590 --> 00:11:24,110
corresponding Dom for the list but

00:11:22,070 --> 00:11:27,200
unfortunately it doesn't know how you

00:11:24,110 --> 00:11:29,570
know if this were a div react knows

00:11:27,200 --> 00:11:31,310
about divs and knows what Dom it needs

00:11:29,570 --> 00:11:34,550
to create for a div react element it

00:11:31,310 --> 00:11:35,750
needs to create a div HTML element but

00:11:34,550 --> 00:11:38,540
since this is something that it doesn't

00:11:35,750 --> 00:11:41,600
know about it's gonna have to ask so it

00:11:38,540 --> 00:11:43,640
asks the component and list responds

00:11:41,600 --> 00:11:45,260
okay well I'm gonna need you to create

00:11:43,640 --> 00:11:47,390
some elements for me I need you to

00:11:45,260 --> 00:11:49,190
create a button element and I need you

00:11:47,390 --> 00:11:52,430
to create for each thing that's in my

00:11:49,190 --> 00:11:55,580
this dot state items list I need you to

00:11:52,430 --> 00:11:58,870
create an item element and then I need

00:11:55,580 --> 00:12:01,790
you to create a div to wrap all of those

00:11:58,870 --> 00:12:04,490
so reactive takes all those elements

00:12:01,790 --> 00:12:05,810
builds them out and then tucks them away

00:12:04,490 --> 00:12:08,210
and the only one that it cares about

00:12:05,810 --> 00:12:11,450
right now is that wrapping div so it'll

00:12:08,210 --> 00:12:15,710
pull that out of the pile and create the

00:12:11,450 --> 00:12:17,180
instance for that and because this is a

00:12:15,710 --> 00:12:18,770
div it knows what the AMA needs to

00:12:17,180 --> 00:12:21,500
create for the div so it goes over to

00:12:18,770 --> 00:12:24,910
the Dom and creates that no note it

00:12:21,500 --> 00:12:28,250
didn't actually make that div a child of

00:12:24,910 --> 00:12:31,130
the container that's there that would

00:12:28,250 --> 00:12:32,840
have scheduled that reflow instead what

00:12:31,130 --> 00:12:34,640
it wants to do is wait until all of the

00:12:32,840 --> 00:12:38,660
nodes are there before it schedules that

00:12:34,640 --> 00:12:39,920
reflow so now to do that to get all

00:12:38,660 --> 00:12:41,600
those dominoes there is gonna need to

00:12:39,920 --> 00:12:44,420
create instances of all of the children

00:12:41,600 --> 00:12:46,750
and for this that goes from a complex to

00:12:44,420 --> 00:12:51,490
a simple structure it goes from this

00:12:46,750 --> 00:12:54,320
nested array into an object and that

00:12:51,490 --> 00:12:55,700
object has property names that

00:12:54,320 --> 00:12:59,240
correspond to the structure of that

00:12:55,700 --> 00:13:01,100
array so the first item is dot 0 the the

00:12:59,240 --> 00:13:03,350
name of the first item is dot 0 and

00:13:01,100 --> 00:13:07,160
that's because the button was the 0th

00:13:03,350 --> 00:13:09,770
item in that array now the items they

00:13:07,160 --> 00:13:12,650
have more complex names because they're

00:13:09,770 --> 00:13:14,750
in a nested structure so dot one dot 0

00:13:12,650 --> 00:13:18,470
is the first item dot one dot one is the

00:13:14,750 --> 00:13:20,030
second item so react takes this

00:13:18,470 --> 00:13:22,700
flattened list increased the instances

00:13:20,030 --> 00:13:25,300
from that now it's time to make the Dom

00:13:22,700 --> 00:13:25,300
elements

00:13:25,370 --> 00:13:30,610
so react knows how to create the Dom for

00:13:28,040 --> 00:13:33,770
a button and it goes over and does that

00:13:30,610 --> 00:13:35,180
then it gets the items and once again

00:13:33,770 --> 00:13:36,980
these are things that it doesn't know

00:13:35,180 --> 00:13:39,410
how to create the Dom for so it has to

00:13:36,980 --> 00:13:40,580
ask again and so the item is going to

00:13:39,410 --> 00:13:42,830
say okay I need you to create a div

00:13:40,580 --> 00:13:44,330
element and take the prop that was

00:13:42,830 --> 00:13:48,620
passed in to me and turn that into text

00:13:44,330 --> 00:13:51,500
content so we got crease the element and

00:13:48,620 --> 00:13:53,780
then the instance and then the Dom node

00:13:51,500 --> 00:13:58,130
it does this two more times to get that

00:13:53,780 --> 00:13:59,900
full set of Dom nodes then it goes over

00:13:58,130 --> 00:14:03,080
to the Dom and it wires up all of those

00:13:59,900 --> 00:14:05,030
children to their parent and then hooks

00:14:03,080 --> 00:14:08,060
up the wrapper div to the container div

00:14:05,030 --> 00:14:12,380
and this is what's gonna trigger that

00:14:08,060 --> 00:14:14,300
reflow but you notice that it waited to

00:14:12,380 --> 00:14:16,570
the end to trigger that that's that

00:14:14,300 --> 00:14:19,160
batching that I was talking about before

00:14:16,570 --> 00:14:24,290
that way the main thread can handle

00:14:19,160 --> 00:14:26,120
these changes all at once so we get our

00:14:24,290 --> 00:14:30,530
riu I and it's ready for people to

00:14:26,120 --> 00:14:32,120
interact with it let's see how the how

00:14:30,530 --> 00:14:35,720
the virtual Dom actually handles that

00:14:32,120 --> 00:14:38,960
user interaction so the users going to

00:14:35,720 --> 00:14:41,450
click the button and react figures out

00:14:38,960 --> 00:14:43,730
the onclick handler for the click and it

00:14:41,450 --> 00:14:45,590
does this using something called event

00:14:43,730 --> 00:14:48,230
delegation unfortunately I don't have

00:14:45,590 --> 00:14:50,660
time to go into what event delegation is

00:14:48,230 --> 00:14:53,960
but you can find an explanation of it

00:14:50,660 --> 00:14:55,970
and the react Doc's so from there calls

00:14:53,960 --> 00:14:57,470
the handler and the handler would be

00:14:55,970 --> 00:14:59,240
code like this you know you get a list

00:14:57,470 --> 00:15:01,670
of items from the state perform

00:14:59,240 --> 00:15:04,040
operations on the items then call set

00:15:01,670 --> 00:15:05,780
state with the items and if he thinks

00:15:04,040 --> 00:15:09,250
that you see a possible bug with this

00:15:05,780 --> 00:15:11,480
code we're gonna get to that later

00:15:09,250 --> 00:15:15,050
so the handler would have been defined

00:15:11,480 --> 00:15:18,980
in the list component it would have been

00:15:15,050 --> 00:15:23,960
bound to the list instance when it calls

00:15:18,980 --> 00:15:28,040
this thought set state it calls set

00:15:23,960 --> 00:15:31,310
state on that list instance so what

00:15:28,040 --> 00:15:34,040
happens when set state is called what

00:15:31,310 --> 00:15:37,580
react does is it sets up a few different

00:15:34,040 --> 00:15:39,170
lists it takes the partial state that

00:15:37,580 --> 00:15:40,939
was passed in with this dot set state

00:15:39,170 --> 00:15:43,309
and it adds it to an array on the

00:15:40,939 --> 00:15:46,249
instance of pending state changes and

00:15:43,309 --> 00:15:47,509
then it takes that instance and it adds

00:15:46,249 --> 00:15:49,939
it to this thing called the dirty

00:15:47,509 --> 00:15:51,529
components array and these are all of

00:15:49,939 --> 00:15:53,209
the things that are going to need to be

00:15:51,529 --> 00:15:55,669
updated but it doesn't take care of

00:15:53,209 --> 00:15:57,290
those yet it waits to see if that

00:15:55,669 --> 00:15:59,600
clickhandler might have done any other

00:15:57,290 --> 00:16:01,579
things might have set ste on any other

00:15:59,600 --> 00:16:05,209
instances before it actually starts

00:16:01,579 --> 00:16:06,980
processing this once it's figured out if

00:16:05,209 --> 00:16:08,839
there have or haven't been any other

00:16:06,980 --> 00:16:12,709
updates it goes through and it flushes

00:16:08,839 --> 00:16:13,999
this cue and since this is the only

00:16:12,709 --> 00:16:18,589
thing on this cue this is the only thing

00:16:13,999 --> 00:16:19,850
that we're going to process so we start

00:16:18,589 --> 00:16:23,179
with the instance that had sets they

00:16:19,850 --> 00:16:25,549
called and work down from there I'm just

00:16:23,179 --> 00:16:26,629
praying everything out react hold on to

00:16:25,549 --> 00:16:27,980
all of these things so it can do

00:16:26,629 --> 00:16:30,949
comparisons between the previous and the

00:16:27,980 --> 00:16:36,199
next but this will make it easier for

00:16:30,949 --> 00:16:38,359
you to see what's going on so react

00:16:36,199 --> 00:16:42,649
calculates the next state on the

00:16:38,359 --> 00:16:46,309
instance and sets that and then it has

00:16:42,649 --> 00:16:48,049
to ask the component okay now that you

00:16:46,309 --> 00:16:50,749
have this new state what are you gonna

00:16:48,049 --> 00:16:53,689
rend you to now and so the component

00:16:50,749 --> 00:16:55,160
responds and it creates the new elements

00:16:53,689 --> 00:16:59,360
the new set of elements that it would

00:16:55,160 --> 00:17:02,119
render to and from there it updates the

00:16:59,360 --> 00:17:04,220
instances and then it compares the

00:17:02,119 --> 00:17:06,139
instances the previous instances to the

00:17:04,220 --> 00:17:08,569
new ones and figures out whether or not

00:17:06,139 --> 00:17:10,250
easy to make Dom changes so for the

00:17:08,569 --> 00:17:12,589
button it doesn't need to make any Dom

00:17:10,250 --> 00:17:15,470
changes because the button hasn't

00:17:12,589 --> 00:17:17,419
changed at all that gets to the first

00:17:15,470 --> 00:17:19,100
item and it's gonna have to ask the item

00:17:17,419 --> 00:17:21,559
again what do you render to before it

00:17:19,100 --> 00:17:24,380
figures out whether or not item is has

00:17:21,559 --> 00:17:27,319
changed or not so item responds that

00:17:24,380 --> 00:17:32,480
creates the element for that updates the

00:17:27,319 --> 00:17:34,970
div instance and since there were no

00:17:32,480 --> 00:17:37,100
changes you know in the previous list it

00:17:34,970 --> 00:17:39,110
was one in the new list is one that text

00:17:37,100 --> 00:17:41,240
content hasn't changed it figures it can

00:17:39,110 --> 00:17:42,799
save a little work by not going over to

00:17:41,240 --> 00:17:46,789
them not making any changes to the Dom

00:17:42,799 --> 00:17:48,289
for that so then for the second one it

00:17:46,789 --> 00:17:50,809
has to go through that same process it

00:17:48,289 --> 00:17:52,129
updates the instance and figures out

00:17:50,809 --> 00:17:53,180
actually there is a change between these

00:17:52,129 --> 00:17:54,530
two so

00:17:53,180 --> 00:17:57,470
goes over to the domina makes the change

00:17:54,530 --> 00:18:00,440
and then it does the same thing for the

00:17:57,470 --> 00:18:03,160
third one and that's when you get that

00:18:00,440 --> 00:18:05,780
reflow because those two happened in

00:18:03,160 --> 00:18:09,590
pretty quick succession they probably

00:18:05,780 --> 00:18:11,120
hit the same reflow so this is how react

00:18:09,590 --> 00:18:12,590
makes things faster figures up the

00:18:11,120 --> 00:18:14,090
smallest number of changes that it needs

00:18:12,590 --> 00:18:15,920
to make to the Dom and it batches them

00:18:14,090 --> 00:18:18,560
all together so that the browser can do

00:18:15,920 --> 00:18:19,700
a smaller number of reflows but there's

00:18:18,560 --> 00:18:24,040
still a good amount of work happening

00:18:19,700 --> 00:18:26,180
here so how could we reduce this and

00:18:24,040 --> 00:18:28,520
this brings us to the third part of the

00:18:26,180 --> 00:18:32,930
talk which is what you can do to make

00:18:28,520 --> 00:18:34,640
react faster and the first technique is

00:18:32,930 --> 00:18:37,190
one that you probably already know

00:18:34,640 --> 00:18:39,650
because react yells at you if you don't

00:18:37,190 --> 00:18:41,630
do it whenever you're creating an array

00:18:39,650 --> 00:18:42,950
of children it's going to tell you that

00:18:41,630 --> 00:18:45,620
you should be using keys for those

00:18:42,950 --> 00:18:49,940
children so I want to show you why this

00:18:45,620 --> 00:18:51,190
can help your performance to do this I'm

00:18:49,940 --> 00:18:54,230
going to need to switch up my example

00:18:51,190 --> 00:18:56,360
we're going to be we're gonna have a

00:18:54,230 --> 00:18:58,220
list of fruits in alphabetical order and

00:18:56,360 --> 00:19:03,470
when you click the button they're gonna

00:18:58,220 --> 00:19:04,670
reverse order so we've gotten part of

00:19:03,470 --> 00:19:05,630
the way through the set state process

00:19:04,670 --> 00:19:08,480
this is where it starts to get

00:19:05,630 --> 00:19:10,490
interesting this is where react is

00:19:08,480 --> 00:19:13,400
actually dealing with the children those

00:19:10,490 --> 00:19:15,860
items that have changed order so if you

00:19:13,400 --> 00:19:17,480
remember when it was flattening them it

00:19:15,860 --> 00:19:19,640
was turning that nested array into a

00:19:17,480 --> 00:19:23,540
flat object and assigning these property

00:19:19,640 --> 00:19:25,370
names and from that it updated the

00:19:23,540 --> 00:19:27,290
instance of instances of the children

00:19:25,370 --> 00:19:30,770
and then compared the old instances to

00:19:27,290 --> 00:19:33,700
the new instances let's look more

00:19:30,770 --> 00:19:37,640
closely at how that comparison happens

00:19:33,700 --> 00:19:41,720
so reacts looking at the old set and the

00:19:37,640 --> 00:19:44,350
new set and it's going to look at the

00:19:41,720 --> 00:19:47,720
two things that have the same name so

00:19:44,350 --> 00:19:51,380
dot one zero and one zero and each of

00:19:47,720 --> 00:19:54,380
these lists so the name is just the

00:19:51,380 --> 00:19:58,130
index of the array and we reversed the

00:19:54,380 --> 00:19:59,750
order this means that react is comparing

00:19:58,130 --> 00:20:02,420
apples to oranges quite literally in

00:19:59,750 --> 00:20:05,660
this case Apple was at position zero

00:20:02,420 --> 00:20:06,890
before and now oranges so when it

00:20:05,660 --> 00:20:08,870
compares these two lists

00:20:06,890 --> 00:20:10,670
it thinks it needs to update the values

00:20:08,870 --> 00:20:12,380
of all of the items that are in the list

00:20:10,670 --> 00:20:17,600
except for the middle one because they

00:20:12,380 --> 00:20:18,770
all look different than they used to now

00:20:17,600 --> 00:20:21,080
let's say that we had given react

00:20:18,770 --> 00:20:25,010
meaningful keys something like the

00:20:21,080 --> 00:20:28,220
actual name of the fruit the key would

00:20:25,010 --> 00:20:31,430
then be used in that name and then react

00:20:28,220 --> 00:20:32,780
can tell which of the previous instances

00:20:31,430 --> 00:20:35,270
corresponds to which of the next

00:20:32,780 --> 00:20:38,390
instances and you can tell that nothing

00:20:35,270 --> 00:20:40,070
but change changed about the order so we

00:20:38,390 --> 00:20:43,100
know that I can just reorder those Dom

00:20:40,070 --> 00:20:45,890
nodes now in this case it's not a huge

00:20:43,100 --> 00:20:48,950
difference but just imagine if each of

00:20:45,890 --> 00:20:51,350
these were a complex Dom structure that

00:20:48,950 --> 00:20:53,830
could be a real time savings only moving

00:20:51,350 --> 00:20:57,080
them around instead of recreating them

00:20:53,830 --> 00:21:00,260
but it's only really a time savings if

00:20:57,080 --> 00:21:03,080
your list is gonna be reordered like if

00:21:00,260 --> 00:21:04,790
you're going to reverse the order or

00:21:03,080 --> 00:21:06,770
take something out of the middle of the

00:21:04,790 --> 00:21:08,990
array if you aren't changing the order

00:21:06,770 --> 00:21:11,240
then there's no real performance impact

00:21:08,990 --> 00:21:13,370
to this and that's one of the reasons

00:21:11,240 --> 00:21:16,070
why it's important to understand the why

00:21:13,370 --> 00:21:17,720
behind any recommendation because

00:21:16,070 --> 00:21:21,370
recommendations don't always have the

00:21:17,720 --> 00:21:21,370
same impact across different use cases

00:21:21,670 --> 00:21:26,450
so let's look at a use case where this

00:21:24,410 --> 00:21:27,950
adding keys wouldn't have as much of a

00:21:26,450 --> 00:21:30,860
performance impact but we're another

00:21:27,950 --> 00:21:32,270
trick would so it's a list where items

00:21:30,860 --> 00:21:35,270
are being fetched from a server and

00:21:32,270 --> 00:21:37,550
added to the end of a list and let's say

00:21:35,270 --> 00:21:39,910
the user pushes the button but there are

00:21:37,550 --> 00:21:42,410
no new messages

00:21:39,910 --> 00:21:44,300
so racks gonna go through the entire

00:21:42,410 --> 00:21:46,190
process of building out this render tree

00:21:44,300 --> 00:21:49,520
of building out the elements and the

00:21:46,190 --> 00:21:52,280
instances and everything but it's not

00:21:49,520 --> 00:21:54,230
going to change anything in the Dom so

00:21:52,280 --> 00:21:56,930
this is called wasted time you can see

00:21:54,230 --> 00:21:58,660
it react perf tools and how can we avoid

00:21:56,930 --> 00:22:01,100
wasting time like this

00:21:58,660 --> 00:22:04,850
I'm sure you've heard of one way and

00:22:01,100 --> 00:22:07,730
that's should component update what

00:22:04,850 --> 00:22:09,680
happens is when the user clicks and this

00:22:07,730 --> 00:22:11,960
dots that state is called before

00:22:09,680 --> 00:22:13,580
building up the render tree below the

00:22:11,960 --> 00:22:16,520
list react will ask the component a

00:22:13,580 --> 00:22:18,590
question it'll say if I give you these

00:22:16,520 --> 00:22:19,570
next props and next state do you need an

00:22:18,590 --> 00:22:22,799
update

00:22:19,570 --> 00:22:25,840
and then the list will say no I'm good

00:22:22,799 --> 00:22:27,519
so react won't call render or do

00:22:25,840 --> 00:22:31,450
anything else on that component or

00:22:27,519 --> 00:22:33,399
children so this is great because we can

00:22:31,450 --> 00:22:34,899
skip computing the list and everything

00:22:33,399 --> 00:22:40,149
under it we can save a whole lot of

00:22:34,899 --> 00:22:42,389
processing there but if you were looking

00:22:40,149 --> 00:22:44,799
closely at that should component update

00:22:42,389 --> 00:22:46,809
you might have noticed a potential bug

00:22:44,799 --> 00:22:48,220
and this works hand-in-hand with the

00:22:46,809 --> 00:22:52,690
potential bug I was calling out in the

00:22:48,220 --> 00:22:55,239
handler before it depends on how you're

00:22:52,690 --> 00:22:56,799
updating the state so let's say you that

00:22:55,239 --> 00:22:59,049
you were updating it the way that I was

00:22:56,799 --> 00:23:02,830
saying where you set a new variable next

00:22:59,049 --> 00:23:04,539
items to this dot state items and then

00:23:02,830 --> 00:23:06,220
you push an item on the array and then

00:23:04,539 --> 00:23:10,149
call set state with that next items

00:23:06,220 --> 00:23:12,099
variable what would happen here is that

00:23:10,149 --> 00:23:15,009
you'd never see the new items rendered

00:23:12,099 --> 00:23:18,629
in your UI your should component update

00:23:15,009 --> 00:23:20,889
would always return false why is that

00:23:18,629 --> 00:23:22,929
it's because even though you have two

00:23:20,889 --> 00:23:25,899
names for this thing they're both

00:23:22,929 --> 00:23:27,909
pointing at the same object the exact

00:23:25,899 --> 00:23:30,609
same thing and when you do an equals

00:23:27,909 --> 00:23:32,379
check in JavaScript on object variables

00:23:30,609 --> 00:23:34,629
it just checks that the two variables

00:23:32,379 --> 00:23:37,570
point to the same object so even if you

00:23:34,629 --> 00:23:39,549
make a change the should component

00:23:37,570 --> 00:23:42,729
update is going to think that the old

00:23:39,549 --> 00:23:46,809
state and the new state are the same so

00:23:42,729 --> 00:23:48,789
it's not gonna see this change now you

00:23:46,809 --> 00:23:50,259
could make it so that whenever you do

00:23:48,789 --> 00:23:52,149
call that handler whenever you are

00:23:50,259 --> 00:23:54,940
calling this offset state what you're

00:23:52,149 --> 00:23:56,169
doing is creating a new object from the

00:23:54,940 --> 00:23:59,019
old one using something like object

00:23:56,169 --> 00:24:00,369
assign then your she'd component update

00:23:59,019 --> 00:24:03,070
would see that the previous and the new

00:24:00,369 --> 00:24:04,690
one are different the problem is it

00:24:03,070 --> 00:24:05,799
would think that they're worth always

00:24:04,690 --> 00:24:07,840
something that was different between

00:24:05,799 --> 00:24:10,359
them because it was always pointing to a

00:24:07,840 --> 00:24:11,889
new object so it would never return

00:24:10,359 --> 00:24:14,619
false your should component update would

00:24:11,889 --> 00:24:16,809
be completely ineffective now you could

00:24:14,619 --> 00:24:19,599
do a deep equality check where you

00:24:16,809 --> 00:24:20,919
compare the actual values but depending

00:24:19,599 --> 00:24:27,099
on how heavy that is it might actually

00:24:20,919 --> 00:24:29,860
take more time so be nice to have that

00:24:27,099 --> 00:24:33,580
simple quick qualities check

00:24:29,860 --> 00:24:37,450
but still catch changes in the data and

00:24:33,580 --> 00:24:39,280
this is what immutability gives you so

00:24:37,450 --> 00:24:41,290
with immutable data if two variables are

00:24:39,280 --> 00:24:44,620
pointing to the same object you know

00:24:41,290 --> 00:24:45,790
that the data hasn't changed and if it

00:24:44,620 --> 00:24:48,220
does need to change you create a new

00:24:45,790 --> 00:24:50,170
object so if you're using immutable data

00:24:48,220 --> 00:24:51,429
then you can do these quick Equality

00:24:50,170 --> 00:24:55,030
checks which are fast and should

00:24:51,429 --> 00:24:56,170
component update so with should

00:24:55,030 --> 00:24:58,270
component update you can short-circuit

00:24:56,170 --> 00:25:00,370
work lower in the tree than the place

00:24:58,270 --> 00:25:02,080
where you call this not that state but

00:25:00,370 --> 00:25:05,110
what if the change happens in one of the

00:25:02,080 --> 00:25:08,980
children do you still need to compute

00:25:05,110 --> 00:25:12,160
this whole set of things let's walk

00:25:08,980 --> 00:25:16,620
through that case so we have a to do

00:25:12,160 --> 00:25:19,750
list and we check off one of the items

00:25:16,620 --> 00:25:21,250
that item has to change but the rest of

00:25:19,750 --> 00:25:22,480
the list the other items in the list and

00:25:21,250 --> 00:25:27,429
Alyssa itself they don't really need to

00:25:22,480 --> 00:25:31,360
change so how can you make sure that you

00:25:27,429 --> 00:25:33,790
aren't updating those other things when

00:25:31,360 --> 00:25:35,049
you're using vanilla react with local

00:25:33,790 --> 00:25:37,960
component State it's actually pretty

00:25:35,049 --> 00:25:39,730
easy you just restructure your state so

00:25:37,960 --> 00:25:42,429
that you can call set state lowering the

00:25:39,730 --> 00:25:44,549
tree but when you're using something

00:25:42,429 --> 00:25:47,169
like Redux this can be harder to do

00:25:44,549 --> 00:25:49,390
that's because you're firing off actions

00:25:47,169 --> 00:25:51,790
and then the state is coming in through

00:25:49,390 --> 00:25:54,250
connect and most people will use connect

00:25:51,790 --> 00:25:57,970
at the top level of their tree or many

00:25:54,250 --> 00:26:00,610
people well there is a way to do this

00:25:57,970 --> 00:26:03,790
though and that's the using connect at

00:26:00,610 --> 00:26:05,440
lower levels of the tree now if you're

00:26:03,790 --> 00:26:06,730
gonna do this you'll probably need to

00:26:05,440 --> 00:26:09,640
rethink how you're handling your data

00:26:06,730 --> 00:26:12,790
for this to work because you'd have a

00:26:09,640 --> 00:26:14,169
component structure like this and most

00:26:12,790 --> 00:26:17,679
people would pass in their array of

00:26:14,169 --> 00:26:24,549
items to the list and then those would

00:26:17,679 --> 00:26:26,530
be passed down to each item component so

00:26:24,549 --> 00:26:28,540
when an item needs to be changed it not

00:26:26,530 --> 00:26:30,340
only needs to change in the item itself

00:26:28,540 --> 00:26:33,970
but also in the array that's being

00:26:30,340 --> 00:26:35,650
passed to list so that's trigging

00:26:33,970 --> 00:26:38,080
triggering an update at the list level

00:26:35,650 --> 00:26:40,809
but you can reduce the work here and the

00:26:38,080 --> 00:26:43,540
way you do that is by passing in IDs to

00:26:40,809 --> 00:26:43,810
the list and then passing those ids down

00:26:43,540 --> 00:26:46,720
to the

00:26:43,810 --> 00:26:49,750
items and from there you can actually

00:26:46,720 --> 00:26:53,080
use the ID and map map state two props

00:26:49,750 --> 00:26:56,860
to convert that ID into the item and so

00:26:53,080 --> 00:27:01,690
then when the item is changed you only

00:26:56,860 --> 00:27:03,040
see that change in the item itself so

00:27:01,690 --> 00:27:05,020
this is how you can save them work at

00:27:03,040 --> 00:27:09,280
higher levels and sibling levels of the

00:27:05,020 --> 00:27:10,540
tree I wish I've had time to cover other

00:27:09,280 --> 00:27:12,640
performance tricks things like

00:27:10,540 --> 00:27:14,650
memoization and virtualization and

00:27:12,640 --> 00:27:16,480
incremental rendering and how you could

00:27:14,650 --> 00:27:18,340
use observables which things like mob X

00:27:16,480 --> 00:27:19,600
and relay used to notify components of

00:27:18,340 --> 00:27:22,600
changes but this is gonna have to be it

00:27:19,600 --> 00:27:25,390
for now so here are the techniques that

00:27:22,600 --> 00:27:27,480
we covered using keys to help react

00:27:25,390 --> 00:27:29,890
match previous instances to me once

00:27:27,480 --> 00:27:31,770
using should component updates a short

00:27:29,890 --> 00:27:34,890
circuit to work lower in the tree and

00:27:31,770 --> 00:27:37,840
how immutability factors into that and

00:27:34,890 --> 00:27:39,910
using set seed or connect lower in the

00:27:37,840 --> 00:27:44,290
tree so you can reduce work higher in

00:27:39,910 --> 00:27:46,450
the tree so I hope this has given you a

00:27:44,290 --> 00:27:48,130
good overview of a few starting points

00:27:46,450 --> 00:27:50,410
as you can see there are lots of tweaks

00:27:48,130 --> 00:27:51,880
that you can make some of them are a for

00:27:50,410 --> 00:27:53,980
some cases some of them are a for other

00:27:51,880 --> 00:27:55,780
cases and some actually had negative

00:27:53,980 --> 00:27:58,510
impacts if they're used in the wrong way

00:27:55,780 --> 00:28:00,510
in the wrong circumstances so this is

00:27:58,510 --> 00:28:02,770
why people say it's good to measure and

00:28:00,510 --> 00:28:05,050
hopefully this talk is giving you a good

00:28:02,770 --> 00:28:09,810
framework for understanding what it is

00:28:05,050 --> 00:28:09,810

YouTube URL: https://www.youtube.com/watch?v=NGxVLnJKhP8


