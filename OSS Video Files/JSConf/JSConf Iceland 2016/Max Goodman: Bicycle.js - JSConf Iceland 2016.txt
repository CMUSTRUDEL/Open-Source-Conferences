Title: Max Goodman: Bicycle.js - JSConf Iceland 2016
Publication date: 2016-09-16
Playlist: JSConf Iceland 2016
Description: 
	Did you know that there’s an experimental Web Bluetooth API under development in Chrome? Let’s explore this brave new world of hardware-accessing offline-accessible web apps together by building a fully functional mobile bike computer. We’ll talk about the BLE protocol and use Web Bluetooth to connect to Bluetooth Smart sensors providing real-time heart rate, speed, and pedaling cadence metrics. Then, we’ll dive into Functional Reactive Programming using the cycle.js library to represent and transform sensor data as observable streams. It’s going to be a wild ride, though be warned: there will be some wheely bad bike puns.
Captions: 
	00:00:11,230 --> 00:00:17,300
hey everyone thanks for coming I'm max

00:00:14,480 --> 00:00:19,250
as was said I'm from San Francisco a

00:00:17,300 --> 00:00:21,349
place it's almost as beautiful as

00:00:19,250 --> 00:00:24,110
Iceland on a nice day this is a picture

00:00:21,349 --> 00:00:25,250
of one of my favorite places there today

00:00:24,110 --> 00:00:27,980
we're going to be talking about

00:00:25,250 --> 00:00:30,080
Bluetooth Harald Bluetooth was a king of

00:00:27,980 --> 00:00:32,480
denmark and norway in the 10th century

00:00:30,080 --> 00:00:34,100
AD he's widely known as the inventor of

00:00:32,480 --> 00:00:35,690
Bluetooth technology but there are no

00:00:34,100 --> 00:00:37,220
Bluetooth devices in his day so the

00:00:35,690 --> 00:00:41,360
technology went on used for hundreds of

00:00:37,220 --> 00:00:42,500
years actually not quite we're going to

00:00:41,360 --> 00:00:46,370
be talking about bluetooth low energy

00:00:42,500 --> 00:00:47,840
which is a variant of Bluetooth 4.2 'the

00:00:46,370 --> 00:00:50,960
smart it was originally developed by

00:00:47,840 --> 00:00:53,539
nokia in the early 2000s for lower power

00:00:50,960 --> 00:00:56,800
lower bandwidth devices like sensors and

00:00:53,539 --> 00:00:58,910
what we now call the Internet of Things

00:00:56,800 --> 00:01:00,920
bluetooth low energy can be thought of

00:00:58,910 --> 00:01:03,729
as a hierarchy of key value pairs what

00:01:00,920 --> 00:01:07,940
we call is the generic attribute profile

00:01:03,729 --> 00:01:09,530
and short for a gap so let's take a look

00:01:07,940 --> 00:01:11,750
at what this looks like so for example

00:01:09,530 --> 00:01:14,030
let's say we have a heart rate wristband

00:01:11,750 --> 00:01:15,740
and get terminology we would call that a

00:01:14,030 --> 00:01:18,860
gat server because it's what we connect

00:01:15,740 --> 00:01:21,679
to a GATT server contains a collection

00:01:18,860 --> 00:01:23,630
of services for instance this server has

00:01:21,679 --> 00:01:26,060
device information such as the vendor

00:01:23,630 --> 00:01:27,979
serial number inversion live heart rate

00:01:26,060 --> 00:01:30,140
data and a battery service which we can

00:01:27,979 --> 00:01:32,750
get battery up-to-date battery info from

00:01:30,140 --> 00:01:34,880
each of these services has a unique

00:01:32,750 --> 00:01:38,300
identifier which we can use to request

00:01:34,880 --> 00:01:40,160
it from the device a service contains a

00:01:38,300 --> 00:01:42,140
collection of characteristics for

00:01:40,160 --> 00:01:43,610
instance the heart rate service has live

00:01:42,140 --> 00:01:45,590
heart rate measurement data and body

00:01:43,610 --> 00:01:46,880
sensor location in this case the body

00:01:45,590 --> 00:01:50,270
sensor location would be the risk

00:01:46,880 --> 00:01:52,459
because this is a wristband services are

00:01:50,270 --> 00:01:54,200
really important for Bluetooth discovery

00:01:52,459 --> 00:01:57,020
when you want to find a device to

00:01:54,200 --> 00:01:59,330
connect to you do that by looking for a

00:01:57,020 --> 00:02:01,190
specific service a service provides

00:01:59,330 --> 00:02:02,390
interoperability between different

00:02:01,190 --> 00:02:04,489
devices by different manufacturers

00:02:02,390 --> 00:02:06,110
because it's like a schema if you have a

00:02:04,489 --> 00:02:08,690
heart rate service it'll be the same no

00:02:06,110 --> 00:02:10,940
matter what device you are talking to so

00:02:08,690 --> 00:02:12,920
for instance a client like a phone can

00:02:10,940 --> 00:02:14,390
look for a heart rate service and if

00:02:12,920 --> 00:02:15,920
there's a device that is offering the

00:02:14,390 --> 00:02:17,600
heart rate service out there it will be

00:02:15,920 --> 00:02:19,700
broadcasting it'll be advertising hey

00:02:17,600 --> 00:02:22,710
I've got heart rate service and then the

00:02:19,700 --> 00:02:25,140
client can start a connection with them

00:02:22,710 --> 00:02:27,450
web bluetooth is a relatively new

00:02:25,140 --> 00:02:30,030
development it's available right now in

00:02:27,450 --> 00:02:31,710
as flagged in Google Chrome so if you

00:02:30,030 --> 00:02:33,240
have google chrome stable you probably

00:02:31,710 --> 00:02:34,890
already have a browser which supports

00:02:33,240 --> 00:02:37,440
web bluetooth but it's still very

00:02:34,890 --> 00:02:39,150
experimental it's still changing and

00:02:37,440 --> 00:02:40,770
there may be unpredictability or even

00:02:39,150 --> 00:02:43,530
the potential for undiscovered security

00:02:40,770 --> 00:02:46,410
issues so it's still you know hold on to

00:02:43,530 --> 00:02:50,060
your horses and it is also under

00:02:46,410 --> 00:02:52,710
development in the servo browser engine

00:02:50,060 --> 00:02:54,420
so now let's take a look and make our

00:02:52,710 --> 00:02:56,760
first connection to a Bluetooth device

00:02:54,420 --> 00:02:59,760
this is called oh my oh I'm wearing one

00:02:56,760 --> 00:03:02,940
right here the Myo is a ring of

00:02:59,760 --> 00:03:05,130
electrical contacts and it's based it is

00:03:02,940 --> 00:03:07,530
able to detect electrical changes on

00:03:05,130 --> 00:03:09,090
your skin and recognize like crude arm

00:03:07,530 --> 00:03:12,240
gestures like if I make a fist it can

00:03:09,090 --> 00:03:13,920
recognize that and let's step through in

00:03:12,240 --> 00:03:17,400
the console how to connect to this Maya

00:03:13,920 --> 00:03:19,650
and we're going to do this live the Maya

00:03:17,400 --> 00:03:21,050
this is what the Maya looks like in

00:03:19,650 --> 00:03:22,650
terms of services and and

00:03:21,050 --> 00:03:24,330
characteristics there's a command

00:03:22,650 --> 00:03:26,070
characteristic which we can write values

00:03:24,330 --> 00:03:28,050
to to send commands to the device and

00:03:26,070 --> 00:03:30,830
there's a gesture characteristic which

00:03:28,050 --> 00:03:35,360
we can use to observe live gestures from

00:03:30,830 --> 00:03:38,100
here's the ideas for those services and

00:03:35,360 --> 00:03:39,660
as I advance the slides this these

00:03:38,100 --> 00:03:42,510
commands are going to be running live in

00:03:39,660 --> 00:03:44,580
the console dunno life so the first

00:03:42,510 --> 00:03:47,760
thing we need to do too is we need to

00:03:44,580 --> 00:03:49,710
find or discover the Myo device the Myo

00:03:47,760 --> 00:03:51,630
device is broadcasting hey I've got the

00:03:49,710 --> 00:03:53,730
Myo control service so what we're going

00:03:51,630 --> 00:03:55,800
to do is call navigator bluetooth dart

00:03:53,730 --> 00:03:57,840
request device and what we do is we pass

00:03:55,800 --> 00:03:59,550
it a filters object and the filters is

00:03:57,840 --> 00:04:01,740
basically describing what the device

00:03:59,550 --> 00:04:03,510
looks like that we want to connect to we

00:04:01,740 --> 00:04:05,070
also need to specify the gesture service

00:04:03,510 --> 00:04:06,600
here because we're going to need to

00:04:05,070 --> 00:04:08,190
access it later we need to specify up

00:04:06,600 --> 00:04:10,290
front all the servers were going

00:04:08,190 --> 00:04:13,140
services we're going to access on the

00:04:10,290 --> 00:04:15,420
device so when we run this code you'll

00:04:13,140 --> 00:04:18,359
see there's now a pop-up here that is

00:04:15,420 --> 00:04:22,860
offering to connect to the DeMaio on my

00:04:18,359 --> 00:04:26,010
arm this navigator Bluetooth dot request

00:04:22,860 --> 00:04:27,780
device requires user interaction so you

00:04:26,010 --> 00:04:30,030
need to have it connected to a mouse

00:04:27,780 --> 00:04:32,130
click or a key press we'll talk a little

00:04:30,030 --> 00:04:34,500
bit more about that later when I press

00:04:32,130 --> 00:04:36,090
the connect button the promise that is

00:04:34,500 --> 00:04:36,569
returned by a request device will

00:04:36,090 --> 00:04:38,159
resolve

00:04:36,569 --> 00:04:41,189
and as you see we've successfully got

00:04:38,159 --> 00:04:43,020
just a representation of a Bluetooth

00:04:41,189 --> 00:04:46,709
device here but we haven't connected to

00:04:43,020 --> 00:04:50,189
it yet to do that we call a gap connect

00:04:46,709 --> 00:04:52,889
on it let's give that a shot and let's

00:04:50,189 --> 00:04:55,289
wait cool okay so now we're actually

00:04:52,889 --> 00:04:56,669
connected to the device let's take

00:04:55,289 --> 00:04:58,979
another look at what the services and

00:04:56,669 --> 00:05:01,469
characteristics look like as a demo I'd

00:04:58,979 --> 00:05:03,689
like to show how to read and observe

00:05:01,469 --> 00:05:05,159
gestures from the device so what we need

00:05:03,689 --> 00:05:07,349
to do is drill down into the GATT

00:05:05,159 --> 00:05:08,909
hierarchy and get the gesture service

00:05:07,349 --> 00:05:11,999
and then the gesture characteristic from

00:05:08,909 --> 00:05:13,709
that to get the service we call get

00:05:11,999 --> 00:05:16,469
primary service with the idea of the

00:05:13,709 --> 00:05:19,529
service that we want that returns a gat

00:05:16,469 --> 00:05:21,360
service object and then we want to drill

00:05:19,529 --> 00:05:23,129
down and get the characteristic we call

00:05:21,360 --> 00:05:24,689
get characteristic on the service with

00:05:23,129 --> 00:05:26,729
the idea of the characteristic we're

00:05:24,689 --> 00:05:28,800
interested in characteristics are the

00:05:26,729 --> 00:05:34,830
values of the key value pairs in the

00:05:28,800 --> 00:05:37,409
hierarchy now that we have a reference

00:05:34,830 --> 00:05:39,240
to this characteristic we need to do two

00:05:37,409 --> 00:05:41,490
things we need to ask the device to

00:05:39,240 --> 00:05:43,740
notify us as the characteristic value

00:05:41,490 --> 00:05:45,539
changes and then we can set up an event

00:05:43,740 --> 00:05:47,039
listener that will print out the

00:05:45,539 --> 00:05:48,839
gestures as they received from the

00:05:47,039 --> 00:05:51,089
device I'm calling a function here

00:05:48,839 --> 00:05:52,649
called par smile gesture because the

00:05:51,089 --> 00:05:54,839
data you get from these characteristics

00:05:52,649 --> 00:05:57,089
is an encoded binary you have to decode

00:05:54,839 --> 00:05:58,800
it and interpret it into a higher level

00:05:57,089 --> 00:06:01,199
JavaScript form that's nice for us to

00:05:58,800 --> 00:06:03,059
work with so when I press the next

00:06:01,199 --> 00:06:04,349
button in advance the slide hopefully we

00:06:03,059 --> 00:06:07,610
should receive gestures from the device

00:06:04,349 --> 00:06:11,279
I'm going to make a fist with my hand

00:06:07,610 --> 00:06:13,199
uh-oh oh no that's okay there's one more

00:06:11,279 --> 00:06:15,689
thing that we have to do we need to send

00:06:13,199 --> 00:06:17,849
a command to the mile telling it please

00:06:15,689 --> 00:06:19,169
start recognizing gestures and sending

00:06:17,849 --> 00:06:20,819
them to me this is something specific to

00:06:19,169 --> 00:06:22,499
the mile we're turning on its internal

00:06:20,819 --> 00:06:24,389
classifier but this is a great example

00:06:22,499 --> 00:06:26,369
of how to write a value to a

00:06:24,389 --> 00:06:28,409
characteristic to do that we're going to

00:06:26,369 --> 00:06:31,110
need to encode a binary characteristic

00:06:28,409 --> 00:06:32,849
command value we do this using typed

00:06:31,110 --> 00:06:37,110
arrays as you can see this is a five

00:06:32,849 --> 00:06:40,379
byte array notably the last the last

00:06:37,110 --> 00:06:42,839
bite of the array is the value one and

00:06:40,379 --> 00:06:44,809
in the for the Myo that means please

00:06:42,839 --> 00:06:47,300
turn on the gesture classifier and

00:06:44,809 --> 00:06:48,990
that's what it looks like on the console

00:06:47,300 --> 00:06:49,740
finally we're going to write this

00:06:48,990 --> 00:06:51,389
command

00:06:49,740 --> 00:06:53,940
please turn on the carrot the recognizer

00:06:51,389 --> 00:06:56,759
to the to the control service of the

00:06:53,940 --> 00:06:58,169
Maya this is a this is similar to before

00:06:56,759 --> 00:07:00,810
but we're just using a lot of promise

00:06:58,169 --> 00:07:02,550
changing the entire web Bluetooth API is

00:07:00,810 --> 00:07:05,220
a lot of promises because each of these

00:07:02,550 --> 00:07:06,449
steps could involve asynchrony so we're

00:07:05,220 --> 00:07:08,370
getting the primaries we're getting the

00:07:06,449 --> 00:07:09,240
service for the control service then

00:07:08,370 --> 00:07:11,490
we're drilling down into the

00:07:09,240 --> 00:07:13,229
characteristic for sending commands and

00:07:11,490 --> 00:07:15,090
finally we're writing a value to the

00:07:13,229 --> 00:07:19,020
command characteristic which is the

00:07:15,090 --> 00:07:21,240
gestures command we have up here and now

00:07:19,020 --> 00:07:24,810
we have live Bluetooth data from the

00:07:21,240 --> 00:07:28,289
Mayo so the model can recognize a couple

00:07:24,810 --> 00:07:31,080
things if I spread my fingers I can also

00:07:28,289 --> 00:07:38,419
make a fist I can wave in I can wave out

00:07:31,080 --> 00:07:38,419
and I can tap my fingers maybe magic

00:07:43,009 --> 00:07:48,300
this is so freaking cool oh my gosh like

00:07:46,740 --> 00:07:50,099
the first time I got this working was

00:07:48,300 --> 00:07:51,690
amazing because i've had this my 0

00:07:50,099 --> 00:07:53,370
device for about like one or two years

00:07:51,690 --> 00:07:55,380
and i've never been able to use it on

00:07:53,370 --> 00:07:57,870
linux because the manufacturer never

00:07:55,380 --> 00:08:00,300
made a device driver for linux but here

00:07:57,870 --> 00:08:01,680
in just like what like 15 lines of code

00:08:00,300 --> 00:08:03,210
we have a connection to the device and

00:08:01,680 --> 00:08:06,659
we're able to get gestures off it this

00:08:03,210 --> 00:08:09,719
is magical let's talk more about what's

00:08:06,659 --> 00:08:11,219
going on here so from the mile which is

00:08:09,719 --> 00:08:12,990
like many of the bluetooth devices i'll

00:08:11,219 --> 00:08:15,840
show you today we're essentially getting

00:08:12,990 --> 00:08:18,569
a real time stream of data updates from

00:08:15,840 --> 00:08:21,030
the device if you're familiar with any

00:08:18,569 --> 00:08:22,590
functional reactive programming perhaps

00:08:21,030 --> 00:08:24,569
you've come across this concept of a

00:08:22,590 --> 00:08:28,580
stream before but you may be thinking of

00:08:24,569 --> 00:08:34,050
something that looks more like this or

00:08:28,580 --> 00:08:36,209
maybe this but uh that's okay here's an

00:08:34,050 --> 00:08:39,630
introduction of how to work with streams

00:08:36,209 --> 00:08:42,029
in reactive mind set we're going to use

00:08:39,630 --> 00:08:43,890
a library called extreme for this here's

00:08:42,029 --> 00:08:46,260
how to create a stream that will

00:08:43,890 --> 00:08:50,300
immediately emit five events the numbers

00:08:46,260 --> 00:08:50,300
one through five as JavaScript objects

00:08:53,769 --> 00:08:59,559
there we go but the stream is not going

00:08:57,610 --> 00:09:02,079
to do anything until we add our first

00:08:59,559 --> 00:09:04,300
listener to it a stream can be basically

00:09:02,079 --> 00:09:07,149
thought of as a value changing over time

00:09:04,300 --> 00:09:10,239
or a periodic sequence of events the

00:09:07,149 --> 00:09:12,309
stream listener is basically three

00:09:10,239 --> 00:09:15,959
callbacks a callback that is called when

00:09:12,309 --> 00:09:18,610
a new value is emitted from the stream a

00:09:15,959 --> 00:09:20,499
fatal error call back and a call back

00:09:18,610 --> 00:09:22,360
when the stream is complete and will no

00:09:20,499 --> 00:09:25,149
longer emit any values so what we have

00:09:22,360 --> 00:09:27,790
here is a utility function that will

00:09:25,149 --> 00:09:29,499
print out on the console when each of

00:09:27,790 --> 00:09:31,509
these callbacks is called so if we try

00:09:29,499 --> 00:09:33,399
that on our numbers stream as expected

00:09:31,509 --> 00:09:36,429
we get the numbers one through five and

00:09:33,399 --> 00:09:40,389
then the stream completes but where

00:09:36,429 --> 00:09:43,299
streams get really powerful got a got a

00:09:40,389 --> 00:09:45,339
key into this Maya gesture here is when

00:09:43,299 --> 00:09:49,029
you can use them to manipulate data and

00:09:45,339 --> 00:09:51,220
create data flows stream processes by

00:09:49,029 --> 00:09:53,079
which we're transforming the data so for

00:09:51,220 --> 00:09:56,259
example we can create a new stream of

00:09:53,079 --> 00:09:58,179
the values x 10 based on our original

00:09:56,259 --> 00:10:00,999
stream by mapping a function over it so

00:09:58,179 --> 00:10:04,959
in here we're mapping x 10 to our stream

00:10:00,999 --> 00:10:06,879
and we're printing it out maybe I should

00:10:04,959 --> 00:10:09,490
switch back to the keyboard as you can

00:10:06,879 --> 00:10:11,439
see now we have printed out the numbers

00:10:09,490 --> 00:10:13,990
1 through 10 through 50 and the stream

00:10:11,439 --> 00:10:18,040
completes but where this gets really

00:10:13,990 --> 00:10:19,600
interesting is asynchrony this time

00:10:18,040 --> 00:10:21,459
let's try printing out the numbers one

00:10:19,600 --> 00:10:24,899
through five but let's wait a second in

00:10:21,459 --> 00:10:27,519
between each in between each increment

00:10:24,899 --> 00:10:29,379
access periodic will give us a stream

00:10:27,519 --> 00:10:31,449
that waits a certain amount of time and

00:10:29,379 --> 00:10:32,920
will count up into infinity but we don't

00:10:31,449 --> 00:10:35,410
want to count into infinity we want to

00:10:32,920 --> 00:10:36,910
count up to the number five so we can

00:10:35,410 --> 00:10:40,299
create another stream called finished

00:10:36,910 --> 00:10:43,360
that weight that filters out any values

00:10:40,299 --> 00:10:45,759
that are less that are not greater than

00:10:43,360 --> 00:10:47,529
five so the first value will emit is

00:10:45,759 --> 00:10:49,149
when the count reaches six and then we

00:10:47,529 --> 00:10:51,610
can end our original stream the count

00:10:49,149 --> 00:10:53,019
stream when six is emitted so then we

00:10:51,610 --> 00:10:56,819
can just get the numbers one through

00:10:53,019 --> 00:11:03,070
five waiting a second in between mitts

00:10:56,819 --> 00:11:05,420
and then the stream completes cool

00:11:03,070 --> 00:11:10,270
wouldn't it be cool if we could treat

00:11:05,420 --> 00:11:12,800
Bluetooth devices like uh like streams

00:11:10,270 --> 00:11:15,710
I've been tinkering with a library for

00:11:12,800 --> 00:11:18,140
doing this the first thing we give this

00:11:15,710 --> 00:11:19,760
library is a description of the device

00:11:18,140 --> 00:11:22,370
we'd like to connect to this looks like

00:11:19,760 --> 00:11:24,560
the call to navigator dot bluetooth that

00:11:22,370 --> 00:11:26,480
request device we're passing in filters

00:11:24,560 --> 00:11:28,160
and optional services but now we give it

00:11:26,480 --> 00:11:30,260
a listen object that's a description of

00:11:28,160 --> 00:11:32,330
the services and characteristics and

00:11:30,260 --> 00:11:34,430
those services that we want to observe

00:11:32,330 --> 00:11:38,320
as a stream and what this library does

00:11:34,430 --> 00:11:40,820
is it it gets that characteristic it

00:11:38,320 --> 00:11:42,320
starts notifications running from them

00:11:40,820 --> 00:11:44,870
and it hooks up an event listener and it

00:11:42,320 --> 00:11:46,610
emits those events as a stream and if

00:11:44,870 --> 00:11:49,940
the device disconnects it will reconnect

00:11:46,610 --> 00:11:52,760
automatically so here is a view of the

00:11:49,940 --> 00:11:56,270
live data coming off of the Myo device

00:11:52,760 --> 00:11:58,280
on my arm it we're printing it out in

00:11:56,270 --> 00:12:01,510
hex format and if I make a fist you can

00:11:58,280 --> 00:12:04,430
see the value changes from 0 to 1 and

00:12:01,510 --> 00:12:06,590
we're using this library to we're just

00:12:04,430 --> 00:12:09,500
pulling out the the gesture service and

00:12:06,590 --> 00:12:11,720
gesture characteristic as a stream but

00:12:09,500 --> 00:12:15,170
that's not very nice to look at or code

00:12:11,720 --> 00:12:16,970
with so to parse this Milo gesture

00:12:15,170 --> 00:12:20,500
here's an example of how you can decode

00:12:16,970 --> 00:12:25,430
one of these binary events we have a

00:12:20,500 --> 00:12:28,340
mapping from from values to string

00:12:25,430 --> 00:12:31,280
gestures and we're just going to get the

00:12:28,340 --> 00:12:33,680
the value of the gesture in binary from

00:12:31,280 --> 00:12:36,970
the mile look it up on our table and

00:12:33,680 --> 00:12:40,040
return the value if we have a match and

00:12:36,970 --> 00:12:43,820
that's what this looks like so now we

00:12:40,040 --> 00:12:46,220
have a live stream of high-level like

00:12:43,820 --> 00:12:47,690
easy to work with gesture data you'll

00:12:46,220 --> 00:12:51,260
notice there's kind of a funny dollar

00:12:47,690 --> 00:12:55,760
sign after raw gesture that's how that's

00:12:51,260 --> 00:12:57,830
a convention for indicating whoops have

00:12:55,760 --> 00:13:00,830
to get a little bit less less excited

00:12:57,830 --> 00:13:02,510
with my arms that's a convention the

00:13:00,830 --> 00:13:04,310
dollar sign tells us that the variable

00:13:02,510 --> 00:13:05,930
we are working with is a stream and as

00:13:04,310 --> 00:13:08,750
we've see in the slides to follow all of

00:13:05,930 --> 00:13:10,760
these slides are transforming one stream

00:13:08,750 --> 00:13:14,060
of data into another stream of data and

00:13:10,760 --> 00:13:15,520
processing it as we go let's look at a

00:13:14,060 --> 00:13:17,550
second device

00:13:15,520 --> 00:13:20,230
this is a Bluetooth heart rate monitor

00:13:17,550 --> 00:13:22,900
the way it works is it shines a green

00:13:20,230 --> 00:13:24,670
light into your wrist and it detects the

00:13:22,900 --> 00:13:27,520
my new changes in color from blood

00:13:24,670 --> 00:13:31,060
pumping into and out of your skin out of

00:13:27,520 --> 00:13:33,070
your veins in underneath your skin this

00:13:31,060 --> 00:13:34,810
device is similar to the mile we're

00:13:33,070 --> 00:13:36,610
looking for a device this time that is

00:13:34,810 --> 00:13:38,200
advertising the heart rate service and

00:13:36,610 --> 00:13:39,280
we're going to pull we're going to dig

00:13:38,200 --> 00:13:40,630
into it and get the heart rate

00:13:39,280 --> 00:13:43,090
measurement characteristic from there

00:13:40,630 --> 00:13:44,650
you'll notice that instead of a variable

00:13:43,090 --> 00:13:47,140
where I'm holding an ID for these

00:13:44,650 --> 00:13:49,180
services and characteristics we're just

00:13:47,140 --> 00:13:51,610
passing a plain old JavaScript strings

00:13:49,180 --> 00:13:53,050
in here the reason is the heart rate

00:13:51,610 --> 00:13:55,270
service and heart rate characteristic

00:13:53,050 --> 00:14:00,220
are standard services provided by the

00:13:55,270 --> 00:14:02,260
bluetooth sig on back to that in a

00:14:00,220 --> 00:14:04,450
moment here's the binary data coming off

00:14:02,260 --> 00:14:09,190
of the heart rate heart rate stream

00:14:04,450 --> 00:14:10,870
coming straight from my arm right now so

00:14:09,190 --> 00:14:11,980
you may be wondering where you find

00:14:10,870 --> 00:14:13,330
information about these binary

00:14:11,980 --> 00:14:15,370
representations and what kind of

00:14:13,330 --> 00:14:17,830
services and characteristics there are

00:14:15,370 --> 00:14:19,240
this is a website from the bluetooth sig

00:14:17,830 --> 00:14:20,710
where they describe each of these

00:14:19,240 --> 00:14:22,750
characteristics and the data formats

00:14:20,710 --> 00:14:24,520
inside so we can drill down the

00:14:22,750 --> 00:14:26,410
characteristics listing to find heart

00:14:24,520 --> 00:14:29,100
rate measurement and then when we go

00:14:26,410 --> 00:14:31,240
look into their we find a table

00:14:29,100 --> 00:14:32,650
describing what each byte does and how

00:14:31,240 --> 00:14:34,180
to interpret it what the what the

00:14:32,650 --> 00:14:36,700
description is what the units are etc

00:14:34,180 --> 00:14:41,740
and this is what the heart rate

00:14:36,700 --> 00:14:43,270
measurement one looks like and then you

00:14:41,740 --> 00:14:44,440
can turn that into a big old JavaScript

00:14:43,270 --> 00:14:45,760
function we're not going to go into the

00:14:44,440 --> 00:14:46,990
details here but what's interesting

00:14:45,760 --> 00:14:48,760
about this function is it's actually

00:14:46,990 --> 00:14:52,570
straight from the web bluetooth spec

00:14:48,760 --> 00:14:54,100
draft it's used as an example there so

00:14:52,570 --> 00:14:56,380
if we apply this parse heart rate

00:14:54,100 --> 00:14:58,650
function to our stream of binary data we

00:14:56,380 --> 00:15:01,360
can get a live feed of heart rate data

00:14:58,650 --> 00:15:05,590
as a stream you can see here that

00:15:01,360 --> 00:15:07,540
there's the the heart rate value that's

00:15:05,590 --> 00:15:09,370
in beats per minute and there's also our

00:15:07,540 --> 00:15:12,900
hour intervals which is the amount of

00:15:09,370 --> 00:15:12,900
time in between each heart rate pulse

00:15:13,440 --> 00:15:17,890
now we're going to look at the last and

00:15:15,790 --> 00:15:21,250
most exciting device for me which is a

00:15:17,890 --> 00:15:23,290
bicycle sensor this bicycle sensor sits

00:15:21,250 --> 00:15:27,570
on the chainstay of your bike we have

00:15:23,290 --> 00:15:29,430
one right here and it basically there's

00:15:27,570 --> 00:15:32,580
there's a there's two magnets on this

00:15:29,430 --> 00:15:34,650
bike there's a magnet on the on the

00:15:32,580 --> 00:15:36,840
crank here by the pedal and there's a

00:15:34,650 --> 00:15:39,000
magnet on the spoke of the bike and as

00:15:36,840 --> 00:15:42,450
these magnets pass by the bike sensor

00:15:39,000 --> 00:15:45,360
it's going to count how many times how

00:15:42,450 --> 00:15:50,970
many times they've passed by frankly

00:15:45,360 --> 00:15:52,740
it's a glorified stopwatch but a

00:15:50,970 --> 00:15:56,550
stopwatch isn't a very useful piece of

00:15:52,740 --> 00:15:58,980
data to to work with to connect to the

00:15:56,550 --> 00:16:00,780
cycling cycle sensor we're going to use

00:15:58,980 --> 00:16:04,830
the cycling speed and cadence service

00:16:00,780 --> 00:16:07,170
which this device advertises and as you

00:16:04,830 --> 00:16:09,030
can see these are all so friendly string

00:16:07,170 --> 00:16:11,550
names so this is a standard service that

00:16:09,030 --> 00:16:13,440
you can you can refer to by its its its

00:16:11,550 --> 00:16:16,890
name alias when you're using the web

00:16:13,440 --> 00:16:18,840
Bluetooth API so let's look at the

00:16:16,890 --> 00:16:22,710
binary data coming off of the device if

00:16:18,840 --> 00:16:25,680
I give the wheel a turn we should see it

00:16:22,710 --> 00:16:27,900
update in a moment cool so what it's

00:16:25,680 --> 00:16:35,820
doing we can try turning the crank as

00:16:27,900 --> 00:16:40,470
well really exciting alright it will get

00:16:35,820 --> 00:16:43,050
more exciting a moment I'm going to save

00:16:40,470 --> 00:16:44,820
us the trouble of you know writing a

00:16:43,050 --> 00:16:46,230
parser for this and jump straight to the

00:16:44,820 --> 00:16:48,030
abstract data we're getting off of the

00:16:46,230 --> 00:16:52,380
device as you can see if I give the

00:16:48,030 --> 00:16:56,730
wheel another turn you're going to see

00:16:52,380 --> 00:16:59,130
indeed that the the revolutions of the

00:16:56,730 --> 00:17:05,490
wheel are ticking up and when I turn the

00:16:59,130 --> 00:17:07,800
crank the crank revolutions take up as

00:17:05,490 --> 00:17:09,329
well and we also have time stamps for

00:17:07,800 --> 00:17:14,490
those values which we can use to

00:17:09,329 --> 00:17:16,320
calculate the speed of rotation but

00:17:14,490 --> 00:17:18,240
first let's uh let's calculate distance

00:17:16,320 --> 00:17:20,250
distance is really easy we take the

00:17:18,240 --> 00:17:21,510
circumference of the wheel and multiply

00:17:20,250 --> 00:17:25,770
it by how many times it's turned around

00:17:21,510 --> 00:17:28,350
and then we can get a stream of the

00:17:25,770 --> 00:17:30,150
distance traveled we'll use this in our

00:17:28,350 --> 00:17:33,360
in our bike computer if we're going to

00:17:30,150 --> 00:17:36,590
display it to the to the rider and this

00:17:33,360 --> 00:17:36,590
is in kilometers

00:17:41,350 --> 00:17:48,380
cool now let's figure out how to create

00:17:46,910 --> 00:17:49,130
a stream of the speed of the bike

00:17:48,380 --> 00:17:51,650
because that's what we're really

00:17:49,130 --> 00:17:53,180
interested in going fast we want to

00:17:51,650 --> 00:17:54,920
measure the speed first of all in

00:17:53,180 --> 00:17:58,280
revolutions per minute the number of

00:17:54,920 --> 00:18:00,950
times the bicycle wheel goes around to

00:17:58,280 --> 00:18:02,270
do that we're going to take two samples

00:18:00,950 --> 00:18:04,850
we're going to look at like over time

00:18:02,270 --> 00:18:08,420
how much how many times the wheel is

00:18:04,850 --> 00:18:11,180
rotated over how much time but we

00:18:08,420 --> 00:18:13,400
haven't looked at a history yet in the

00:18:11,180 --> 00:18:15,290
context of the stream how do we get that

00:18:13,400 --> 00:18:16,610
previous value because currently the

00:18:15,290 --> 00:18:18,200
streams I've shown you so far are just

00:18:16,610 --> 00:18:21,140
the current most live value emitted

00:18:18,200 --> 00:18:23,090
every time well excess extreme has us

00:18:21,140 --> 00:18:24,830
covered here with an operator called

00:18:23,090 --> 00:18:26,300
pairwise and this operator you basically

00:18:24,830 --> 00:18:28,250
apply it to your stream and it

00:18:26,300 --> 00:18:30,860
transforms your stream into a new form

00:18:28,250 --> 00:18:33,830
that emits different types of values

00:18:30,860 --> 00:18:36,770
what pairwise does is it will emit

00:18:33,830 --> 00:18:39,080
consecutive values as array pairs of a

00:18:36,770 --> 00:18:41,650
stream so if we call print stream on

00:18:39,080 --> 00:18:44,060
this you can see 1 2 2 2 2 3 3 to 4 etc

00:18:41,650 --> 00:18:45,890
so we can use this to pair up our

00:18:44,060 --> 00:18:47,810
samples of data from the bicycle

00:18:45,890 --> 00:18:50,840
computer and we can use that to

00:18:47,810 --> 00:18:52,790
calculate rpm first we're going to do

00:18:50,840 --> 00:18:54,860
cadence cyclists like to know how

00:18:52,790 --> 00:18:56,450
quickly they're turning their how

00:18:54,860 --> 00:18:58,850
quickly they're turning the pedals and

00:18:56,450 --> 00:19:01,700
we measure that as cadence directly as

00:18:58,850 --> 00:19:10,280
rpm so this is how quickly I'm turning

00:19:01,700 --> 00:19:13,280
the pedals right now yeah but for the

00:19:10,280 --> 00:19:15,230
speed of the wheel Oh what you see

00:19:13,280 --> 00:19:17,030
happening here is we're taking the pairs

00:19:15,230 --> 00:19:18,710
of samples and we're just doing a little

00:19:17,030 --> 00:19:20,360
bit object plunging before we pass it

00:19:18,710 --> 00:19:22,400
into utility that does the math for us

00:19:20,360 --> 00:19:24,680
we're pulling out the the crank

00:19:22,400 --> 00:19:26,000
revolutions from the first sample and

00:19:24,680 --> 00:19:28,430
then the crank revolutions from the

00:19:26,000 --> 00:19:30,740
second sample and then the function revs

00:19:28,430 --> 00:19:32,510
to rpm is going to just do the math

00:19:30,740 --> 00:19:35,240
comparing how much time has passed and

00:19:32,510 --> 00:19:36,980
how many cranks have happened we can do

00:19:35,240 --> 00:19:40,780
that for speed as well so if i turn the

00:19:36,980 --> 00:19:45,350
wheel we can get our PM off of the wheel

00:19:40,780 --> 00:19:48,800
and finally what we want to do is

00:19:45,350 --> 00:19:50,060
convert convert that RPM to km/h and we

00:19:48,800 --> 00:19:51,820
do that by multiplying it by the

00:19:50,060 --> 00:19:54,340
circumference of the wheel giving

00:19:51,820 --> 00:19:56,320
how much how much distance we were

00:19:54,340 --> 00:20:03,280
travelling over time let's give this

00:19:56,320 --> 00:20:07,000
another world oops yeah so there there

00:20:03,280 --> 00:20:09,520
you have it we've created four streams

00:20:07,000 --> 00:20:11,800
of data now coming off of this bike I'll

00:20:09,520 --> 00:20:13,450
end my arm this is all completely live

00:20:11,800 --> 00:20:16,630
you can see my heart rate is going in a

00:20:13,450 --> 00:20:18,850
nice 120 beats per minute everyone's

00:20:16,630 --> 00:20:21,370
favorite electronic music tempo and as

00:20:18,850 --> 00:20:26,890
we interact with the bike we can get a

00:20:21,370 --> 00:20:31,300
live data off of it if we take a goals I

00:20:26,890 --> 00:20:32,800
view of what's going on here we've taken

00:20:31,300 --> 00:20:35,290
we've connected to a heart rate sensor

00:20:32,800 --> 00:20:38,460
here we've converted a stream of binary

00:20:35,290 --> 00:20:41,350
data into abstract heart rate data

00:20:38,460 --> 00:20:43,960
similarly we've connected to the bicycle

00:20:41,350 --> 00:20:45,790
sensor and we've got a system of streams

00:20:43,960 --> 00:20:52,810
that are all you know one step in the

00:20:45,790 --> 00:20:55,990
data processing flow oops yeah so based

00:20:52,810 --> 00:20:58,810
on the ABS on the parsed revolution

00:20:55,990 --> 00:21:01,330
counts and time stamps we can derive the

00:20:58,810 --> 00:21:03,670
distance travel the wheel rpm the crank

00:21:01,330 --> 00:21:06,100
rpm and from the wheel rpm we can do a

00:21:03,670 --> 00:21:09,460
little math and get the km/h and now we

00:21:06,100 --> 00:21:12,160
have four streams of bicycle information

00:21:09,460 --> 00:21:14,950
there's one last step to make a awesome

00:21:12,160 --> 00:21:17,770
bicycle computer which is we need to

00:21:14,950 --> 00:21:22,950
pipe this all into the Dom somehow we

00:21:17,770 --> 00:21:26,590
can use handlebars j/s for this get it

00:21:22,950 --> 00:21:28,900
just kidding instead we're going to use

00:21:26,590 --> 00:21:30,760
cycle jas for this there's no relation

00:21:28,900 --> 00:21:32,040
between cycle jets and bicycle jets by

00:21:30,760 --> 00:21:34,780
the way which is the name of this talk

00:21:32,040 --> 00:21:36,550
cycle j/s is a really cool library for

00:21:34,780 --> 00:21:40,060
building applications and behavior

00:21:36,550 --> 00:21:42,310
systems out of streams in cycle j/s your

00:21:40,060 --> 00:21:44,080
view is also a stream so we take our

00:21:42,310 --> 00:21:45,910
stream of all these like four different

00:21:44,080 --> 00:21:48,070
cycling metrics that we've collected up

00:21:45,910 --> 00:21:49,900
and we transform that stream into

00:21:48,070 --> 00:21:51,640
virtual Dom and when our stream emits

00:21:49,900 --> 00:21:56,170
virtual Dom in this case the component

00:21:51,640 --> 00:21:57,340
bicycle j/s each emitted virtual Dom get

00:21:56,170 --> 00:22:00,940
stiffed with the current state of the

00:21:57,340 --> 00:22:02,200
page and the page gets updated and in

00:22:00,940 --> 00:22:06,440
the end we get something that looks like

00:22:02,200 --> 00:22:09,539
this I'd like to give it a spin

00:22:06,440 --> 00:22:13,349
now it's very important to wear a helmet

00:22:09,539 --> 00:22:16,109
oh sorry it's very important to wear a

00:22:13,349 --> 00:22:18,299
helmet when you ride a bicycle someone

00:22:16,109 --> 00:22:21,269
once told me that your head is about the

00:22:18,299 --> 00:22:24,529
toughness of a ripe watermelon so keep

00:22:21,269 --> 00:22:26,759
that in mind and be safe it's also

00:22:24,529 --> 00:22:29,359
really important to wear shades when

00:22:26,759 --> 00:22:34,559
you're bicycling because it looks cool

00:22:29,359 --> 00:22:36,209
and oh wow I should have probably should

00:22:34,559 --> 00:22:37,829
have toned down the gestures but it's

00:22:36,209 --> 00:22:39,149
cool we've got wireless control because

00:22:37,829 --> 00:22:41,820
it's Bluetooth so everything's fine

00:22:39,149 --> 00:22:43,919
let's give this a spin this is my

00:22:41,820 --> 00:22:47,909
everyday ride you guys just riding along

00:22:43,919 --> 00:22:49,739
and harpa really cool so now you have it

00:22:47,909 --> 00:22:56,399
somehow we managed to go in the negative

00:22:49,739 --> 00:22:58,679
distance but you know time travel and

00:22:56,399 --> 00:23:03,919
we've got some cool graphs everything

00:22:58,679 --> 00:23:03,919
works great so that's that's bicycle jas

00:23:08,959 --> 00:23:16,499
thank you now as you saw by my my rudely

00:23:14,159 --> 00:23:18,389
advancing the slide too early the point

00:23:16,499 --> 00:23:20,609
I'm trying to make about all this is

00:23:18,389 --> 00:23:23,809
that the web is changing rather our

00:23:20,609 --> 00:23:26,940
expectations for the web are expanding

00:23:23,809 --> 00:23:29,039
bicycle j/s is an example of a web app

00:23:26,940 --> 00:23:30,659
that can run pretty much like a native

00:23:29,039 --> 00:23:32,519
app on your phone it works offline

00:23:30,659 --> 00:23:34,559
thanks to a service worker and it

00:23:32,519 --> 00:23:37,619
connects natively to your Bluetooth

00:23:34,559 --> 00:23:39,929
devices this is previously something

00:23:37,619 --> 00:23:41,700
that was a task relegated to native iOS

00:23:39,929 --> 00:23:43,469
and Android devices in fact for any of

00:23:41,700 --> 00:23:45,269
these gadgets many of which you may own

00:23:43,469 --> 00:23:46,289
you have the first thing you do when

00:23:45,269 --> 00:23:48,869
you're setting up one of these gadgets

00:23:46,289 --> 00:23:50,549
is you download and install and iOS are

00:23:48,869 --> 00:23:52,259
an Android app and if you're a PC user

00:23:50,549 --> 00:23:55,139
you're just left in the dust because

00:23:52,259 --> 00:23:56,759
it's not supported but now like that's

00:23:55,139 --> 00:23:58,739
that's the whole point of the web the

00:23:56,759 --> 00:24:01,589
web works everywhere for everyone so the

00:23:58,739 --> 00:24:03,809
promise of web bluetooth is now these

00:24:01,589 --> 00:24:06,739
interactions with real physical devices

00:24:03,809 --> 00:24:10,229
can happen straight from a web page

00:24:06,739 --> 00:24:11,549
that's really powerful another really

00:24:10,229 --> 00:24:13,469
cool thing if you see any node bots

00:24:11,549 --> 00:24:16,019
happening around if you have a node bot

00:24:13,469 --> 00:24:17,999
with a Bluetooth Low Energy chip you can

00:24:16,019 --> 00:24:19,440
actually send commands to your node bot

00:24:17,999 --> 00:24:21,389
now straight from the browser

00:24:19,440 --> 00:24:23,429
this is amazing for education and for

00:24:21,389 --> 00:24:25,379
like creative experimentation the

00:24:23,429 --> 00:24:29,789
barrier to entry of talking to these

00:24:25,379 --> 00:24:31,289
devices has just been decimated now you

00:24:29,789 --> 00:24:33,570
may be wondering a little bit and we're

00:24:31,289 --> 00:24:34,830
going to use this to conclude what are

00:24:33,570 --> 00:24:36,509
the security implications of this

00:24:34,830 --> 00:24:37,889
amazing wireless communication with

00:24:36,509 --> 00:24:40,080
devices around us and I'm going to talk

00:24:37,889 --> 00:24:42,240
about this a little bit remember how I

00:24:40,080 --> 00:24:44,220
said in the beginning that it requires

00:24:42,240 --> 00:24:46,440
user interaction before you can connect

00:24:44,220 --> 00:24:50,340
to a device that is really important

00:24:46,440 --> 00:24:52,769
because many of the devices out there

00:24:50,340 --> 00:24:54,539
may not have been designed with an

00:24:52,769 --> 00:24:55,980
adversarial attacker in mind they're

00:24:54,539 --> 00:24:57,389
like oh it's cool it's just cell phones

00:24:55,980 --> 00:24:59,700
or whatever you just have to install an

00:24:57,389 --> 00:25:02,220
app but now what a webpage can talk to

00:24:59,700 --> 00:25:04,769
my bluetooth device even worse these

00:25:02,220 --> 00:25:06,120
potentially insecure or buggy devices

00:25:04,769 --> 00:25:08,639
probably will never get their firmware

00:25:06,120 --> 00:25:11,100
updated so there was a serious concern

00:25:08,639 --> 00:25:13,350
about being able to send like nasty

00:25:11,100 --> 00:25:15,149
packets to Bluetooth devices but there's

00:25:13,350 --> 00:25:17,490
two defenses against this first the web

00:25:15,149 --> 00:25:19,909
Bluetooth API is very high level so the

00:25:17,490 --> 00:25:23,639
potential for crafting nasty packets is

00:25:19,909 --> 00:25:26,129
is limited but also every interaction

00:25:23,639 --> 00:25:27,629
with a Bluetooth device has to start

00:25:26,129 --> 00:25:29,490
with an interaction with the user and

00:25:27,629 --> 00:25:31,679
you can play a little fishing games but

00:25:29,490 --> 00:25:33,330
it's very hard to spoof getting that

00:25:31,679 --> 00:25:36,330
like do you want to connect to a device

00:25:33,330 --> 00:25:37,409
dialogue now there's a couple little

00:25:36,330 --> 00:25:40,649
nitty-gritty things that are interesting

00:25:37,409 --> 00:25:43,259
which is that Bluetooth devices around

00:25:40,649 --> 00:25:44,759
you can be a finger printing method like

00:25:43,259 --> 00:25:46,470
if you have a SmartWatch or a smart TV

00:25:44,759 --> 00:25:48,570
around you and you open up your browser

00:25:46,470 --> 00:25:51,059
and is just able to scan willy-nilly for

00:25:48,570 --> 00:25:53,070
devices that may be used to fingerprint

00:25:51,059 --> 00:25:55,830
you but thankfully that's also gated

00:25:53,070 --> 00:25:57,029
behind a user interaction finally and

00:25:55,830 --> 00:25:59,159
this is just nice to know about whenever

00:25:57,029 --> 00:26:00,480
you're dealing with Bluetooth or you

00:25:59,159 --> 00:26:02,399
know radio there's a potential of

00:26:00,480 --> 00:26:04,769
leaking your existence to the outside

00:26:02,399 --> 00:26:06,960
world so I don't know unless you're in a

00:26:04,769 --> 00:26:08,490
spy movie but if you open up your phone

00:26:06,960 --> 00:26:11,490
and scan for Bluetooth devices you're

00:26:08,490 --> 00:26:12,929
making your phone discoverable and what

00:26:11,490 --> 00:26:14,940
that means is it's broadcasting hey I'm

00:26:12,929 --> 00:26:17,480
here I'm a phone cool or what I'm a

00:26:14,940 --> 00:26:20,129
phone I'm talking I'm alive anyway uh

00:26:17,480 --> 00:26:22,830
your laptop is going to do that too when

00:26:20,129 --> 00:26:25,529
you open up a you know web bluetooth

00:26:22,830 --> 00:26:27,450
scan that's worth knowing about if you

00:26:25,529 --> 00:26:30,139
want to learn more about web bluetooth i

00:26:27,450 --> 00:26:32,970
suggest starting here the web bluetooth

00:26:30,139 --> 00:26:33,420
standard drafting process is very open

00:26:32,970 --> 00:26:34,890
and they

00:26:33,420 --> 00:26:37,290
have this great document if you go to

00:26:34,890 --> 00:26:38,850
their github with a browser support

00:26:37,290 --> 00:26:40,320
matrix for web bluetooth and there's

00:26:38,850 --> 00:26:42,360
also some really cool demos and like

00:26:40,320 --> 00:26:47,160
sample algorithms offered by the chrome

00:26:42,360 --> 00:26:49,200
team I want to say thank you to Andre

00:26:47,160 --> 00:26:50,700
salts for creating cycle j/s an extreme

00:26:49,200 --> 00:26:52,590
that was majorly inspiring and

00:26:50,700 --> 00:26:54,720
influential for this talk this entire

00:26:52,590 --> 00:26:56,460
presentation has been cycle j

00:26:54,720 --> 00:26:59,250
application it's composed using these

00:26:56,460 --> 00:27:00,870
streams of values and behaviors and i

00:26:59,250 --> 00:27:02,490
also want to thank hall door who is

00:27:00,870 --> 00:27:04,950
sitting somewhere over here for loaning

00:27:02,490 --> 00:27:06,900
us his totally sweet bike it's would

00:27:04,950 --> 00:27:09,380
have been possible without it so thank

00:27:06,900 --> 00:27:09,380

YouTube URL: https://www.youtube.com/watch?v=mk6s20Kbbow


