Title: Azat Mardan: You Don't Know Node.js - JSConf Iceland 2016
Publication date: 2016-09-16
Playlist: JSConf Iceland 2016
Description: 
	"Node.js is fast and scalable web-oriented non-blocking I/O built on top of Google Chrome V8 engine. Almost every web developer uses Node or Node-based tools to some extent. However, Node has some really powerful features worth knowing.

This talk dives deep into the core mechanisms of the Node.js platform and some of its most interesting features such as Event Loop, Streams and buffers, Process and global, Event emitters, Clusters, AsyncWrap, Domain and uncaughtException, and C++ addons.
Captions: 
	00:00:13,280 --> 00:00:21,410
everyone so how many of you are

00:00:18,189 --> 00:00:23,689
front-end engineers you work with mostly

00:00:21,410 --> 00:00:28,759
on the front end okay how many of you

00:00:23,689 --> 00:00:33,110
back-end engineers okay more about 60%

00:00:28,759 --> 00:00:37,130
cocoa cocoa how many of you think they

00:00:33,110 --> 00:00:38,600
know no js' but are still here okay so

00:00:37,130 --> 00:00:45,110
you have enough time to go to the next

00:00:38,600 --> 00:00:48,410
room so if you have computers if you're

00:00:45,110 --> 00:00:50,809
not tired already from all this amazing

00:00:48,410 --> 00:00:54,699
information you can code along with me

00:00:50,809 --> 00:01:00,350
and because I have some code examples or

00:00:54,699 --> 00:01:03,469
you can just relax and know that all the

00:01:00,350 --> 00:01:08,200
slides are on the github so yep take a

00:01:03,469 --> 00:01:11,960
picture it's their soul open source okay

00:01:08,200 --> 00:01:14,570
so just to remind you why we here and

00:01:11,960 --> 00:01:17,750
why it's good to know such thing as no

00:01:14,570 --> 00:01:21,619
js' and JavaScript so generally software

00:01:17,750 --> 00:01:24,439
is kind of becoming everywhere our

00:01:21,619 --> 00:01:26,119
life's becoming digital so by building

00:01:24,439 --> 00:01:29,659
better software we can actually improve

00:01:26,119 --> 00:01:30,320
lives of other people a little bit about

00:01:29,659 --> 00:01:32,810
myself

00:01:30,320 --> 00:01:35,689
she already introduced me so I will skip

00:01:32,810 --> 00:01:38,509
through the slides faster some of my

00:01:35,689 --> 00:01:41,570
books practical node and Pro Express we

00:01:38,509 --> 00:01:44,479
have them here my publisher a press they

00:01:41,570 --> 00:01:47,539
currently provided the books so we will

00:01:44,479 --> 00:01:53,119
do the giveaways and signing you can

00:01:47,539 --> 00:01:55,159
find me on Twitter and blog and some of

00:01:53,119 --> 00:01:58,130
the other highlights I've worked at

00:01:55,159 --> 00:01:58,880
Storify and DocuSign early users of

00:01:58,130 --> 00:02:02,060
nodejs

00:01:58,880 --> 00:02:02,929
so I know what I'm talking about more or

00:02:02,060 --> 00:02:05,240
less

00:02:02,929 --> 00:02:08,420
Capital one it's famous for its Viking

00:02:05,240 --> 00:02:10,490
commercials it's one of the top 10 US

00:02:08,420 --> 00:02:15,710
banks I promise I'm not going to have a

00:02:10,490 --> 00:02:18,080
lot of gifts only two more okay so let's

00:02:15,710 --> 00:02:20,600
start with basics first of all like why

00:02:18,080 --> 00:02:24,230
do we even want to use node.js right

00:02:20,600 --> 00:02:25,810
because we might have people completely

00:02:24,230 --> 00:02:29,180
new to know the ass

00:02:25,810 --> 00:02:32,150
so there are typically two categories of

00:02:29,180 --> 00:02:34,700
systems one is input and output bount

00:02:32,150 --> 00:02:37,239
and another a cpu-bound so when we're

00:02:34,700 --> 00:02:40,159
building web applications we're usually

00:02:37,239 --> 00:02:42,890
working with the input and output bound

00:02:40,159 --> 00:02:45,260
systems so what is input and output it

00:02:42,890 --> 00:02:49,010
could be writing to the database as

00:02:45,260 --> 00:02:52,420
making a request to a server or a third

00:02:49,010 --> 00:02:56,269
party service or doing something else

00:02:52,420 --> 00:03:00,409
which is usually takes a lot of time

00:02:56,269 --> 00:03:02,090
just for the waiting for that process so

00:03:00,409 --> 00:03:05,540
know just has the thing it's called

00:03:02,090 --> 00:03:09,879
non-blocking i/o now or non-blocking

00:03:05,540 --> 00:03:12,730
input and output why this is good so

00:03:09,879 --> 00:03:15,650
when we're working with nodejs and

00:03:12,730 --> 00:03:17,959
usually we're building web servers we

00:03:15,650 --> 00:03:21,260
might have some clients making requests

00:03:17,959 --> 00:03:23,959
so under the hood of nodejs we have a

00:03:21,260 --> 00:03:27,170
vent loop which was borrowed from google

00:03:23,959 --> 00:03:29,329
chrome v8 engine so that event loop is

00:03:27,170 --> 00:03:32,239
always looking for things to execute and

00:03:29,329 --> 00:03:35,359
then it delegates the actual jobs the

00:03:32,239 --> 00:03:38,900
actual processes to some other systems

00:03:35,359 --> 00:03:44,359
for example a file system or database

00:03:38,900 --> 00:03:47,150
etc so when the delegation happens event

00:03:44,359 --> 00:03:49,609
loop also passes the callback which is

00:03:47,150 --> 00:03:52,549
typically some JavaScript or node.js

00:03:49,609 --> 00:03:54,620
code and when the system is done it's

00:03:52,549 --> 00:03:57,290
over it's finished that callback is

00:03:54,620 --> 00:03:59,900
executed and usually that go back has

00:03:57,290 --> 00:04:01,819
the code to send back the data to the

00:03:59,900 --> 00:04:05,030
client if we're talking about web

00:04:01,819 --> 00:04:09,349
servers so how many of your Java

00:04:05,030 --> 00:04:11,930
developers or started with Java okay so

00:04:09,349 --> 00:04:13,669
even if you're not hardcore Java

00:04:11,930 --> 00:04:16,459
developer you kind of guess what is

00:04:13,669 --> 00:04:20,510
happening here there is a sleep method

00:04:16,459 --> 00:04:22,280
and the key here probably this is the

00:04:20,510 --> 00:04:25,070
most important piece in like the whole

00:04:22,280 --> 00:04:28,970
presentation the key here is that Java

00:04:25,070 --> 00:04:32,419
process will be put into so to say sleep

00:04:28,970 --> 00:04:35,240
so nothing will be executed until that

00:04:32,419 --> 00:04:38,780
one second passes so 1,000 milliseconds

00:04:35,240 --> 00:04:42,940
or one second blocks the entire process

00:04:38,780 --> 00:04:46,100
game contrat that with this node.js code

00:04:42,940 --> 00:04:48,590
where we're scheduling the process in

00:04:46,100 --> 00:04:50,570
the future by using a callback so that

00:04:48,590 --> 00:04:53,360
function is sort of a set timeout it's

00:04:50,570 --> 00:04:56,540
not executed right away it will be

00:04:53,360 --> 00:04:59,180
executed in the future so from step one

00:04:56,540 --> 00:05:02,060
we skip right to the step two then one

00:04:59,180 --> 00:05:05,000
second passes and we would see step

00:05:02,060 --> 00:05:07,669
three so why this is good because we

00:05:05,000 --> 00:05:10,340
could execute more code while the

00:05:07,669 --> 00:05:11,510
waiting is happening so the waiting is

00:05:10,340 --> 00:05:14,330
not actually sleeping

00:05:11,510 --> 00:05:16,370
it's just scheduling in the future so we

00:05:14,330 --> 00:05:18,620
would see step one step two then we

00:05:16,370 --> 00:05:21,800
would see step four and then we would

00:05:18,620 --> 00:05:23,900
see after 1000 milliseconds step three

00:05:21,800 --> 00:05:26,960
and step five so this is probably the

00:05:23,900 --> 00:05:30,380
most important piece from this whole

00:05:26,960 --> 00:05:34,690
presentation not just allows you to

00:05:30,380 --> 00:05:37,520
write faster applications typically

00:05:34,690 --> 00:05:40,910
because we're utilizing that idle

00:05:37,520 --> 00:05:43,130
waiting time so let's talk about web

00:05:40,910 --> 00:05:45,830
servers a little bit so this is how we

00:05:43,130 --> 00:05:49,400
would write a web server schematically

00:05:45,830 --> 00:05:52,340
of course just a diagram using some of

00:05:49,400 --> 00:05:56,539
those blocking i/o systems like Python

00:05:52,340 --> 00:05:58,940
Ruby Java etc each subsequent request

00:05:56,539 --> 00:06:01,280
would be blocked by the previous request

00:05:58,940 --> 00:06:04,460
so you have the queue and they have to

00:06:01,280 --> 00:06:06,380
wait in that queue I always like to give

00:06:04,460 --> 00:06:08,800
this a knowledge of a coffee shop you go

00:06:06,380 --> 00:06:12,080
to coffee shop and you order your drink

00:06:08,800 --> 00:06:14,330
he or she the barista the cashier at the

00:06:12,080 --> 00:06:16,160
register they would take your order they

00:06:14,330 --> 00:06:19,270
would take your money and then they

00:06:16,160 --> 00:06:22,190
would turn around and make you drink and

00:06:19,270 --> 00:06:25,550
usually that leads to long lines people

00:06:22,190 --> 00:06:28,280
are waiting in line because each person

00:06:25,550 --> 00:06:30,260
before you has to order the drink and

00:06:28,280 --> 00:06:33,260
wait for that drink right so you have

00:06:30,260 --> 00:06:35,780
unhappy customers the line is blocked

00:06:33,260 --> 00:06:41,090
your typical blocking input and output

00:06:35,780 --> 00:06:43,760
system now let's take a look how things

00:06:41,090 --> 00:06:46,400
are in no js' so we have event loop

00:06:43,760 --> 00:06:49,789
again and event loop delegates the

00:06:46,400 --> 00:06:52,529
processes to others underlying systems

00:06:49,789 --> 00:06:54,959
so event loop is almost never

00:06:52,529 --> 00:06:57,749
locked it's almost never blocked and

00:06:54,959 --> 00:06:59,609
that's a good thing and it's also a

00:06:57,749 --> 00:07:02,459
single-threaded we will talk about it in

00:06:59,609 --> 00:07:04,739
the next slide but basically going back

00:07:02,459 --> 00:07:07,799
to our coffee shop analogies this is how

00:07:04,739 --> 00:07:11,359
Starbucks works and maybe Dunkin Donuts

00:07:07,799 --> 00:07:14,039
which I've heard people like in Iceland

00:07:11,359 --> 00:07:16,709
so people are happier they're sitting at

00:07:14,039 --> 00:07:18,869
the tables because it's asynchronous we

00:07:16,709 --> 00:07:21,119
have this non-blocking in input and

00:07:18,869 --> 00:07:23,639
output system implemented so you go

00:07:21,119 --> 00:07:26,459
order your drink they write down your

00:07:23,639 --> 00:07:28,589
name and or maybe they give you number

00:07:26,459 --> 00:07:32,219
and then you go back to your table and

00:07:28,589 --> 00:07:34,739
you continue working on your JavaScript

00:07:32,219 --> 00:07:36,839
application and they call you you go

00:07:34,739 --> 00:07:39,479
back and get your drink right so people

00:07:36,839 --> 00:07:42,719
are happy we don't have a line and also

00:07:39,479 --> 00:07:44,879
this process tends to be a better at

00:07:42,719 --> 00:07:47,129
scaling because the only way you can

00:07:44,879 --> 00:07:48,839
actually scale the blocking system by

00:07:47,129 --> 00:07:50,879
increasing the number of threads or

00:07:48,839 --> 00:07:53,549
increasing the number of registers the

00:07:50,879 --> 00:07:56,099
cash registers that will increase the

00:07:53,549 --> 00:07:59,599
number of lines but in this example you

00:07:56,099 --> 00:08:02,549
can increase the number of workers so

00:07:59,599 --> 00:08:05,849
multi-threading it's not necessarily a

00:08:02,549 --> 00:08:07,619
great thing sometimes it can blow up in

00:08:05,849 --> 00:08:10,049
your face especially if you don't know

00:08:07,619 --> 00:08:12,599
how to use it so it comes with

00:08:10,049 --> 00:08:15,119
complexity and it was born out of the

00:08:12,599 --> 00:08:19,079
necessity how you would scale a blocking

00:08:15,119 --> 00:08:21,269
system right so the blocking system they

00:08:19,079 --> 00:08:23,879
have to be multi-threaded in nodejs

00:08:21,269 --> 00:08:25,649
it's a single threaded system so it

00:08:23,879 --> 00:08:27,979
eliminates complexities such as

00:08:25,649 --> 00:08:31,949
synchronizing the data between threads

00:08:27,979 --> 00:08:34,169
deadlocks racing conditions etc but it's

00:08:31,949 --> 00:08:38,129
still possible to write blocking code in

00:08:34,169 --> 00:08:41,339
ogs so by just the knowing that no js'

00:08:38,129 --> 00:08:42,959
is have the non blocking i/o it's still

00:08:41,339 --> 00:08:46,259
not going to prevent developers from

00:08:42,959 --> 00:08:49,170
writing blocking code let's take a look

00:08:46,259 --> 00:08:51,990
at this example and you can run there is

00:08:49,170 --> 00:08:53,850
a file blocking j/s so you can just go

00:08:51,990 --> 00:08:58,379
into your terminal and execute that file

00:08:53,850 --> 00:09:00,959
once you get my source code and I get

00:08:58,379 --> 00:09:04,350
anywhere from 100 milliseconds to 1,000

00:09:00,959 --> 00:09:06,570
milliseconds obviously most of the times

00:09:04,350 --> 00:09:09,030
we don't get the blocking code

00:09:06,570 --> 00:09:12,300
just obvious which is like a for-loop

00:09:09,030 --> 00:09:15,440
this blocking code is buried inside of

00:09:12,300 --> 00:09:19,980
the module I know that module that

00:09:15,440 --> 00:09:21,810
that's how so the way to know that it's

00:09:19,980 --> 00:09:24,150
a synchronous basically you need either

00:09:21,810 --> 00:09:28,470
to read the documentation or read the

00:09:24,150 --> 00:09:29,550
source code in this case FS the naming

00:09:28,470 --> 00:09:31,920
convention

00:09:29,550 --> 00:09:33,570
it has the word sink in it so we know

00:09:31,920 --> 00:09:36,420
that it's a synchronous module by

00:09:33,570 --> 00:09:38,010
looking at it another dead giveaway

00:09:36,420 --> 00:09:40,230
signer that the content will be

00:09:38,010 --> 00:09:43,230
available right there on the next line

00:09:40,230 --> 00:09:46,080
so I can assign var and then the result

00:09:43,230 --> 00:09:49,050
of read file sync and I can cancel log

00:09:46,080 --> 00:09:52,800
that so we will go from top to bottom

00:09:49,050 --> 00:09:55,350
just as in any other traditional

00:09:52,800 --> 00:09:57,300
programming language in a synchronous

00:09:55,350 --> 00:09:59,820
language so it's very easy to reason

00:09:57,300 --> 00:10:02,340
about but this would not be very

00:09:59,820 --> 00:10:05,550
efficient code this is much more

00:10:02,340 --> 00:10:09,570
efficient code it's also in node.js but

00:10:05,550 --> 00:10:12,450
now we're using a function which is read

00:10:09,570 --> 00:10:15,420
file not read file sync and with this

00:10:12,450 --> 00:10:17,250
file we're using callbacks so the trick

00:10:15,420 --> 00:10:20,010
here is that the data would not be

00:10:17,250 --> 00:10:22,710
available on the next line so council

00:10:20,010 --> 00:10:25,290
log hello Ruby would not have the

00:10:22,710 --> 00:10:27,630
content of the file available the

00:10:25,290 --> 00:10:29,310
content of the file will be available in

00:10:27,630 --> 00:10:32,430
the future when the callback is

00:10:29,310 --> 00:10:35,610
happening and your result might vary so

00:10:32,430 --> 00:10:38,700
first you might get the accounts or IP

00:10:35,610 --> 00:10:42,360
addresses from IPS dot txt or you might

00:10:38,700 --> 00:10:44,790
get IPS first depending on what file is

00:10:42,360 --> 00:10:47,520
larger right so we're executing them in

00:10:44,790 --> 00:10:49,290
parallel parallel and concurrency the

00:10:47,520 --> 00:10:53,130
different terms but when it comes to

00:10:49,290 --> 00:10:55,710
node.js they usually interchangeable so

00:10:53,130 --> 00:10:58,670
node.js is typically much much faster

00:10:55,710 --> 00:11:02,220
than other platforms and languages

00:10:58,670 --> 00:11:04,680
because of this input optimization input

00:11:02,220 --> 00:11:07,050
and output and optimization but let's be

00:11:04,680 --> 00:11:10,760
honest how many of you actually hit the

00:11:07,050 --> 00:11:13,530
bottleneck when it counts a performance

00:11:10,760 --> 00:11:15,950
personally I don't experience that

00:11:13,530 --> 00:11:19,280
problem if I have that problem I can add

00:11:15,950 --> 00:11:21,710
RAM I can add CPU I can add workers

00:11:19,280 --> 00:11:23,540
it's it's cheaper to scale than it used

00:11:21,710 --> 00:11:27,350
to be ten years ago so I'm not building

00:11:23,540 --> 00:11:30,980
the next Facebook or Google for me my

00:11:27,350 --> 00:11:32,870
personal no js' benefit and a lot of

00:11:30,980 --> 00:11:37,010
other developers also shared this is

00:11:32,870 --> 00:11:39,110
that we can use javascript so we have

00:11:37,010 --> 00:11:42,380
one language two rules to rule basically

00:11:39,110 --> 00:11:44,510
the entire stack we can think faster we

00:11:42,380 --> 00:11:46,730
can reuse code if I'm using lodash or

00:11:44,510 --> 00:11:50,210
underscore on the browser can use that

00:11:46,730 --> 00:11:52,910
on on the server as well and also if I'm

00:11:50,210 --> 00:11:57,380
using the same API the same interface

00:11:52,910 --> 00:11:59,540
all over the stack I'm learning quicker

00:11:57,380 --> 00:12:02,810
I don't need to refer to the

00:11:59,540 --> 00:12:05,720
documentation that that much so the good

00:12:02,810 --> 00:12:07,880
thing about not just that most of this

00:12:05,720 --> 00:12:11,000
classes the subjects they are available

00:12:07,880 --> 00:12:14,630
as this right we have arrays drinks

00:12:11,000 --> 00:12:16,640
primitives so if you know nodejs it's

00:12:14,630 --> 00:12:18,590
very easy if you know JavaScript it's

00:12:16,640 --> 00:12:21,350
very easy to get started with node it

00:12:18,590 --> 00:12:24,620
could take it just like a weekend but

00:12:21,350 --> 00:12:26,630
note is not triple equals browser so

00:12:24,620 --> 00:12:28,580
there are a few differences we will talk

00:12:26,630 --> 00:12:30,980
about them for example there is no

00:12:28,580 --> 00:12:35,050
window object obviously there is no

00:12:30,980 --> 00:12:39,650
windows when we work with nodejs right

00:12:35,050 --> 00:12:42,190
but there is global so if you're just

00:12:39,650 --> 00:12:46,280
working with the browser JavaScript

00:12:42,190 --> 00:12:48,580
think about global as the window it can

00:12:46,280 --> 00:12:54,170
surf everywhere it's kind of magical and

00:12:48,580 --> 00:12:56,600
then it has properties by the way the

00:12:54,170 --> 00:12:59,810
property it's also accessible without

00:12:56,600 --> 00:13:01,670
the prefix without global dot so I can

00:12:59,810 --> 00:13:04,520
just say understorms the score dual name

00:13:01,670 --> 00:13:06,860
for example it would work so all the

00:13:04,520 --> 00:13:10,130
properties of global they also kind of

00:13:06,860 --> 00:13:13,940
global in themselves so file name would

00:13:10,130 --> 00:13:16,400
give me the path an absolute path to the

00:13:13,940 --> 00:13:18,440
currently running script the dear name

00:13:16,400 --> 00:13:22,280
would also give me the path but without

00:13:18,440 --> 00:13:24,380
the filename so we don't have that in

00:13:22,280 --> 00:13:27,530
the browser right you don't want to

00:13:24,380 --> 00:13:30,620
navigate the websites and you don't want

00:13:27,530 --> 00:13:32,690
the websites to know your file system

00:13:30,620 --> 00:13:34,460
what folder you're running the script

00:13:32,690 --> 00:13:36,350
but on the server it's a completely

00:13:34,460 --> 00:13:39,110
different picture we have that extra

00:13:36,350 --> 00:13:42,230
information another thing we don't have

00:13:39,110 --> 00:13:43,820
in the browser javascript is modules so

00:13:42,230 --> 00:13:46,730
modules are native in nodejs

00:13:43,820 --> 00:13:49,550
the way we work with them we have module

00:13:46,730 --> 00:13:53,540
to export and then we have required to

00:13:49,550 --> 00:13:55,850
import modules it's started from the

00:13:53,540 --> 00:13:58,310
common J's where web standard the

00:13:55,850 --> 00:14:02,930
browser standard but now it's more or

00:13:58,310 --> 00:14:06,890
less the standard for nongenius some of

00:14:02,930 --> 00:14:08,540
the other useful things that we can do

00:14:06,890 --> 00:14:13,940
with node which we cannot do with the

00:14:08,540 --> 00:14:16,790
browser JavaScript process or global

00:14:13,940 --> 00:14:19,450
dead process it will give you a lot of

00:14:16,790 --> 00:14:22,850
information about the underlying node.js

00:14:19,450 --> 00:14:25,250
process and your machine for example you

00:14:22,850 --> 00:14:27,230
can get the process ID we can get the

00:14:25,250 --> 00:14:29,630
versions not just the version of node.js

00:14:27,230 --> 00:14:32,540
but the version of the v8 engine for

00:14:29,630 --> 00:14:35,180
example can get the architecture if it's

00:14:32,540 --> 00:14:38,030
Windows or if it's some of the POSIX

00:14:35,180 --> 00:14:40,370
systems if you're building a

00:14:38,030 --> 00:14:43,250
command-line tool like web pack or grunt

00:14:40,370 --> 00:14:45,470
you can get those options and

00:14:43,250 --> 00:14:48,260
command-line arguments inside the vien

00:14:45,470 --> 00:14:51,050
of your node process we can get

00:14:48,260 --> 00:14:55,760
environmental variables things like API

00:14:51,050 --> 00:14:58,130
keys passwords etc can get the app time

00:14:55,760 --> 00:15:03,620
and current memory usage from the

00:14:58,130 --> 00:15:06,200
machine as well and CWD that's very

00:15:03,620 --> 00:15:08,750
similar to the door name but only if

00:15:06,200 --> 00:15:10,760
you're running your node program from

00:15:08,750 --> 00:15:13,130
the same file from the same folder from

00:15:10,760 --> 00:15:16,310
the same directory in which you have the

00:15:13,130 --> 00:15:18,950
source code so in some cases this value

00:15:16,310 --> 00:15:20,810
would be different and then we can exit

00:15:18,950 --> 00:15:24,020
the current process and we can also

00:15:20,810 --> 00:15:26,180
terminate other processes that comes in

00:15:24,020 --> 00:15:29,900
handy when we're scaling when we use in

00:15:26,180 --> 00:15:32,089
clusters okay so this is a tricky

00:15:29,900 --> 00:15:40,010
question so who likes and understands

00:15:32,089 --> 00:15:44,750
callbacks okay it's like 40% what about

00:15:40,010 --> 00:15:46,520
callback hell once in a while we might

00:15:44,750 --> 00:15:50,779
get ourselves into this mess

00:15:46,520 --> 00:15:53,779
right so developmental scalability that

00:15:50,779 --> 00:15:56,270
means bringing more people more

00:15:53,779 --> 00:15:58,310
developers to current projects having

00:15:56,270 --> 00:16:02,899
more people work on a single piece of

00:15:58,310 --> 00:16:06,410
code and callbacks they're not very

00:16:02,899 --> 00:16:08,360
developmental scalable that that's how I

00:16:06,410 --> 00:16:13,700
feel sometimes and working with

00:16:08,360 --> 00:16:17,390
callbacks so there are other patterns

00:16:13,700 --> 00:16:20,480
like promises and async await and

00:16:17,390 --> 00:16:23,240
generators but they don't solve all the

00:16:20,480 --> 00:16:28,430
problems they sold some of the problem

00:16:23,240 --> 00:16:33,110
that callbacks have but what if you for

00:16:28,430 --> 00:16:35,450
example want to execute something many

00:16:33,110 --> 00:16:37,940
many times and you want to execute that

00:16:35,450 --> 00:16:39,740
not just at the end like with callbacks

00:16:37,940 --> 00:16:41,690
or promises but you want to execute it

00:16:39,740 --> 00:16:46,750
in the middle or in the beginning of a

00:16:41,690 --> 00:16:50,240
job or a process so please meet event or

00:16:46,750 --> 00:16:52,399
event emitters they're a singleton pad

00:16:50,240 --> 00:16:55,490
not a single term they absorber pattern

00:16:52,399 --> 00:16:57,800
so no js' observer pattern a good thing

00:16:55,490 --> 00:17:00,589
about events they are everywhere in the

00:16:57,800 --> 00:17:04,069
core node.js modules so if you know how

00:17:00,589 --> 00:17:06,350
to work with events you would understand

00:17:04,069 --> 00:17:09,650
how to work with pretty much all of the

00:17:06,350 --> 00:17:11,990
core modules of nodejs so we have our

00:17:09,650 --> 00:17:14,089
subject we have an object and then we

00:17:11,990 --> 00:17:16,970
have event triggers right so we have

00:17:14,089 --> 00:17:19,400
three things working together so to

00:17:16,970 --> 00:17:22,780
create an object all we need to do is

00:17:19,400 --> 00:17:25,550
require events and then we using

00:17:22,780 --> 00:17:28,760
prototypal inheritance to create an

00:17:25,550 --> 00:17:32,179
object and then we can attach event

00:17:28,760 --> 00:17:37,220
listeners so for example I want to

00:17:32,179 --> 00:17:40,010
listen for the done event a good thing

00:17:37,220 --> 00:17:43,059
about event listeners and like callbacks

00:17:40,010 --> 00:17:46,670
or promises that we can have multiple

00:17:43,059 --> 00:17:49,520
pieces of logic executed on a single

00:17:46,670 --> 00:17:51,880
event so for example knock it's a single

00:17:49,520 --> 00:17:54,950
event but I can have many many

00:17:51,880 --> 00:17:56,690
functionality executed and the order in

00:17:54,950 --> 00:17:59,870
which it will be executed is the same

00:17:56,690 --> 00:18:00,320
order in which I define them now this is

00:17:59,870 --> 00:18:04,210
very big

00:18:00,320 --> 00:18:06,980
take example so let's see something more

00:18:04,210 --> 00:18:09,309
real-life something more realistic so

00:18:06,980 --> 00:18:12,500
let's say I have a job which is like a

00:18:09,309 --> 00:18:16,159
job to send email and then I have three

00:18:12,500 --> 00:18:20,240
different types of emails monthly weekly

00:18:16,159 --> 00:18:23,419
and daily emails so I want to implement

00:18:20,240 --> 00:18:25,340
the job module the way that I can

00:18:23,419 --> 00:18:29,299
customize what is happening at the very

00:18:25,340 --> 00:18:33,679
end so my job module will emit an event

00:18:29,299 --> 00:18:36,200
job that Amit and then when I'm using

00:18:33,679 --> 00:18:38,899
this module when I'm actually consuming

00:18:36,200 --> 00:18:41,149
now I want to put that custom logic and

00:18:38,899 --> 00:18:44,419
the way I do it by creating an event

00:18:41,149 --> 00:18:47,419
listener so I know my module is emitting

00:18:44,419 --> 00:18:49,669
this event I know the name is done do an

00:18:47,419 --> 00:18:52,970
e so all I need to do is put an event

00:18:49,669 --> 00:18:55,580
listener the good thing compared to just

00:18:52,970 --> 00:18:58,250
callbacks if I don't specify this event

00:18:55,580 --> 00:19:00,259
listener it's not going to crash right

00:18:58,250 --> 00:19:03,019
if you don't specify a callback and your

00:19:00,259 --> 00:19:06,919
module expects it right so the module

00:19:03,019 --> 00:19:09,110
will crash another thing is that I can

00:19:06,919 --> 00:19:11,059
remove event listeners I can get the

00:19:09,110 --> 00:19:13,909
list of event listeners I can have many

00:19:11,059 --> 00:19:15,850
of them not just a single callbacks is

00:19:13,909 --> 00:19:21,129
typically just a single callback

00:19:15,850 --> 00:19:25,519
I've highly highly recommend this book

00:19:21,129 --> 00:19:28,009
node.js patterns oh it's not a book okay

00:19:25,519 --> 00:19:31,639
just a blog post I'll have the link to

00:19:28,009 --> 00:19:34,519
the book later ok so the next problem is

00:19:31,639 --> 00:19:36,919
how to handle large data so if you're

00:19:34,519 --> 00:19:39,350
working with files larger than 1

00:19:36,919 --> 00:19:43,669
gigabyte you might heat the buffer limit

00:19:39,350 --> 00:19:46,549
and it's just not a nice experience to

00:19:43,669 --> 00:19:50,059
wait for the entire large data to load

00:19:46,549 --> 00:19:52,539
so please meet streams they are

00:19:50,059 --> 00:19:56,870
abstractions to allow us to work with

00:19:52,539 --> 00:19:59,720
continuous chunking of data so we don't

00:19:56,870 --> 00:20:03,169
need to wait for the entire large chunk

00:19:59,720 --> 00:20:05,659
of data piece of data to load so there

00:20:03,169 --> 00:20:08,450
are four types of streams writable

00:20:05,659 --> 00:20:10,250
readable than the duplex which are both

00:20:08,450 --> 00:20:12,909
readable and writable and then the

00:20:10,250 --> 00:20:16,220
transform streams

00:20:12,909 --> 00:20:18,379
so streams inherit from Aventa meters so

00:20:16,220 --> 00:20:20,899
we will be using the knowledge which we

00:20:18,379 --> 00:20:25,159
just acquired in the previous slides to

00:20:20,899 --> 00:20:28,840
work with the Aventa meters so streams

00:20:25,159 --> 00:20:31,850
they're pretty much in a lot of places

00:20:28,840 --> 00:20:35,269
the HTTP requests and response their

00:20:31,850 --> 00:20:37,460
streams when we're reading from standard

00:20:35,269 --> 00:20:39,710
input and output those are streams as

00:20:37,460 --> 00:20:44,059
well when we're working with files their

00:20:39,710 --> 00:20:47,629
streams example of a readable stream

00:20:44,059 --> 00:20:54,190
process that STD in there is a read

00:20:47,629 --> 00:20:58,789
operation so this example will capture

00:20:54,190 --> 00:21:01,039
me typing on a keyboard and my program

00:20:58,789 --> 00:21:04,279
will output whatever I'm typing so line

00:21:01,039 --> 00:21:07,730
by line so when for each line I would

00:21:04,279 --> 00:21:12,259
have the console log chunk : output me

00:21:07,730 --> 00:21:14,570
the previous line you can run this demo

00:21:12,259 --> 00:21:18,440
on your computer's if you following

00:21:14,570 --> 00:21:21,590
along now our streams has another

00:21:18,440 --> 00:21:24,080
approach which you can also use so

00:21:21,590 --> 00:21:26,869
readable that read it's a synchronous

00:21:24,080 --> 00:21:29,899
method which returns the current chunk

00:21:26,869 --> 00:21:32,779
of data and once the stream is finished

00:21:29,899 --> 00:21:35,990
it will return null so we can put it in

00:21:32,779 --> 00:21:39,740
a while condition so when it's now the

00:21:35,990 --> 00:21:41,509
wild will stop working and it's it's

00:21:39,740 --> 00:21:43,519
okay that it's synchronous because each

00:21:41,509 --> 00:21:45,440
chunks is just a line of data if we're

00:21:43,519 --> 00:21:48,740
reading from a file working with the

00:21:45,440 --> 00:21:50,899
text data so it's not a big deal in this

00:21:48,740 --> 00:21:53,840
case it's synchronous what about

00:21:50,899 --> 00:21:59,929
writable streams so there is a write

00:21:53,840 --> 00:22:02,869
operation so the next example will write

00:21:59,929 --> 00:22:05,240
a an output to a terminal it's actually

00:22:02,869 --> 00:22:10,450
very similar to what counsel that log is

00:22:05,240 --> 00:22:14,509
using under the hood so what about HTTP

00:22:10,450 --> 00:22:17,059
so when we're working with HTTP that's

00:22:14,509 --> 00:22:19,730
where streams are really really

00:22:17,059 --> 00:22:21,529
beneficial because now your clients they

00:22:19,730 --> 00:22:24,710
can start receiving the data right away

00:22:21,529 --> 00:22:26,390
or if you're consuming the data you can

00:22:24,710 --> 00:22:28,640
transform the data right

00:22:26,390 --> 00:22:30,860
way so in this case we're using invent

00:22:28,640 --> 00:22:33,560
emitters and we're listening for the

00:22:30,860 --> 00:22:36,080
data which is coming from the request

00:22:33,560 --> 00:22:38,860
and then I have this function transform

00:22:36,080 --> 00:22:42,020
let's say it's a transform stream and

00:22:38,860 --> 00:22:45,140
maybe I'm writing this data somewhere or

00:22:42,020 --> 00:22:48,560
just transforming it it's very very

00:22:45,140 --> 00:22:51,830
useful another interface are using dot

00:22:48,560 --> 00:22:54,200
pipe it's very similar to Linux command

00:22:51,830 --> 00:22:56,300
line so you can pipe from one process to

00:22:54,200 --> 00:23:01,940
another or in this case from one string

00:22:56,300 --> 00:23:04,190
to another so to work with binary data

00:23:01,940 --> 00:23:08,270
and no gel there is a type called buffer

00:23:04,190 --> 00:23:11,780
in es6 there also in u67 they're also

00:23:08,270 --> 00:23:15,470
adding this similar but so far it's not

00:23:11,780 --> 00:23:17,420
as popular on the browser JavaScript so

00:23:15,470 --> 00:23:21,080
think about buffers as the binary type

00:23:17,420 --> 00:23:24,530
and when you're working with the file

00:23:21,080 --> 00:23:27,650
systems or even working with HTTP

00:23:24,530 --> 00:23:31,160
servers by default the data it's in

00:23:27,650 --> 00:23:32,870
buffer so if you see we're string that

00:23:31,160 --> 00:23:34,610
you're supposed to look like a normal

00:23:32,870 --> 00:23:36,740
text but it's bunch of numbers looks

00:23:34,610 --> 00:23:39,860
like an array probably you need to

00:23:36,740 --> 00:23:41,960
convert it from a buffer to a string to

00:23:39,860 --> 00:23:47,060
do that you can use a two string and

00:23:41,960 --> 00:23:50,840
then pass an encoding so FS module by

00:23:47,060 --> 00:23:54,740
default the data is the buffer and I

00:23:50,840 --> 00:23:58,520
have a example of Server Express server

00:23:54,740 --> 00:24:00,950
which uses two endpoints one with

00:23:58,520 --> 00:24:03,230
streams and other without streams once

00:24:00,950 --> 00:24:06,800
you start it you can go to slash stream

00:24:03,230 --> 00:24:08,930
and slash stream slash non stream non -

00:24:06,800 --> 00:24:14,210
stream and you would see the difference

00:24:08,930 --> 00:24:17,420
in my case the response time was way way

00:24:14,210 --> 00:24:18,890
faster for the stream endpoint and I

00:24:17,420 --> 00:24:22,100
have the large picture I have eight

00:24:18,890 --> 00:24:26,420
megabyte infographic so so that's

00:24:22,100 --> 00:24:29,780
noticeable some of their cool stream

00:24:26,420 --> 00:24:32,120
resources how to recommend stream

00:24:29,780 --> 00:24:36,710
adventure and stream handbook it's all

00:24:32,120 --> 00:24:39,710
open source free to use and view if you

00:24:36,710 --> 00:24:40,440
know streams you pretty much can become

00:24:39,710 --> 00:24:43,260
like a guru

00:24:40,440 --> 00:24:46,370
of nodejs in your team maybe even in

00:24:43,260 --> 00:24:49,920
your company if your company is not big

00:24:46,370 --> 00:24:51,930
so okay so back to scaling how we can

00:24:49,920 --> 00:24:54,360
scale node.js because remember it's

00:24:51,930 --> 00:24:56,610
single threaded right and this is one of

00:24:54,360 --> 00:24:59,580
the arguments which you might hear from

00:24:56,610 --> 00:25:01,800
your co-workers from hardcore Java

00:24:59,580 --> 00:25:03,960
developers like oh no just a single

00:25:01,800 --> 00:25:07,470
threaded we cannot use it

00:25:03,960 --> 00:25:11,010
well actually it's relatively easy to

00:25:07,470 --> 00:25:13,740
scale nodejs what we can do we can have

00:25:11,010 --> 00:25:16,890
one master process and then we can have

00:25:13,740 --> 00:25:20,040
multiple worker processes so the master

00:25:16,890 --> 00:25:22,320
will be just creating new workers and

00:25:20,040 --> 00:25:26,580
listening when those workers are dying

00:25:22,320 --> 00:25:28,560
or crashing to restart them and then the

00:25:26,580 --> 00:25:30,930
workers they would be actually doing all

00:25:28,560 --> 00:25:33,480
the heavy lifting they will be doing all

00:25:30,930 --> 00:25:35,580
the processing there would be our HTTP

00:25:33,480 --> 00:25:38,300
servers so the good thing about this

00:25:35,580 --> 00:25:41,370
core module cluster is the core module

00:25:38,300 --> 00:25:43,950
well that's a good thing probably the

00:25:41,370 --> 00:25:47,670
only good thing so there are better

00:25:43,950 --> 00:25:50,430
alternatives I have an example as well

00:25:47,670 --> 00:25:53,130
I'm using load test so you can load test

00:25:50,430 --> 00:25:56,640
your server with cluster and without the

00:25:53,130 --> 00:25:59,940
cluster so other alternatives are strong

00:25:56,640 --> 00:26:02,760
strong cluster control and PM to a lot

00:25:59,940 --> 00:26:06,030
of developers like p.m. 2 p.m. stands

00:26:02,760 --> 00:26:08,940
for process manager so basically you can

00:26:06,030 --> 00:26:12,900
use PM 2 or a similar tool without

00:26:08,940 --> 00:26:15,780
anything else just like that and your

00:26:12,900 --> 00:26:19,080
application would be really really good

00:26:15,780 --> 00:26:22,880
and robust in production so that's when

00:26:19,080 --> 00:26:22,880
you want to scale and go to production

00:26:25,670 --> 00:26:30,270
my personal favorite thing about PM 2

00:26:28,650 --> 00:26:33,540
that you don't need to modify your

00:26:30,270 --> 00:26:35,700
source code so you just use the source

00:26:33,540 --> 00:26:38,040
code exactly the same as for the single

00:26:35,700 --> 00:26:40,590
process PM 2 will create multiple

00:26:38,040 --> 00:26:43,140
process and utilize the maximum CPU

00:26:40,590 --> 00:26:46,350
power from each machine so that's a

00:26:43,140 --> 00:26:49,740
vertical scaling I have some demos as

00:26:46,350 --> 00:26:53,220
well in the source code so you can play

00:26:49,740 --> 00:26:54,060
with that there are multiple ways to

00:26:53,220 --> 00:26:56,370
start

00:26:54,060 --> 00:26:59,700
a different process not just fork so

00:26:56,370 --> 00:27:01,380
fork it's mostly for nodejs and then we

00:26:59,700 --> 00:27:04,020
have spawn which is pretty much for

00:27:01,380 --> 00:27:07,080
anything they work very similarly you

00:27:04,020 --> 00:27:09,890
can process big big data large data with

00:27:07,080 --> 00:27:14,310
both of them because they use stream and

00:27:09,890 --> 00:27:16,440
exact it does not use dream it uses just

00:27:14,310 --> 00:27:19,320
a callback so you don't use event

00:27:16,440 --> 00:27:21,420
emitters and obviously if it uses a

00:27:19,320 --> 00:27:24,620
buffer you will run into buffer limits

00:27:21,420 --> 00:27:28,110
so usually exact it's for small command

00:27:24,620 --> 00:27:30,570
here's an example spoon no js' program

00:27:28,110 --> 00:27:34,680
yes so I can run a different node.js

00:27:30,570 --> 00:27:36,870
instance for it very similar only don't

00:27:34,680 --> 00:27:39,390
need to specify that it's note so it's

00:27:36,870 --> 00:27:42,780
only going to work with node process it

00:27:39,390 --> 00:27:45,450
an exact example I have a callback so in

00:27:42,780 --> 00:27:49,580
the callback I would get STD out STD in

00:27:45,450 --> 00:27:54,060
STD are from that process

00:27:49,580 --> 00:27:56,970
okay so asynchronous errors they're a

00:27:54,060 --> 00:28:00,600
little bit tricky because remember that

00:27:56,970 --> 00:28:03,030
event loop from the first slides so

00:28:00,600 --> 00:28:06,180
actually what happens when we use event

00:28:03,030 --> 00:28:07,710
loop will lose the context so this is

00:28:06,180 --> 00:28:10,980
how you would handle errors in

00:28:07,710 --> 00:28:13,200
traditional languages and asynchronous

00:28:10,980 --> 00:28:16,950
errors in JavaScript we will put try

00:28:13,200 --> 00:28:19,200
catch but try catch totally useless when

00:28:16,950 --> 00:28:21,000
it comes to asynchronous code because

00:28:19,200 --> 00:28:23,340
that event loop when it schedules

00:28:21,000 --> 00:28:25,890
something in the future it loses the

00:28:23,340 --> 00:28:29,100
contents it loses the try catch so when

00:28:25,890 --> 00:28:31,080
the callbacks come comes back we don't

00:28:29,100 --> 00:28:35,310
have that try catch anymore so this will

00:28:31,080 --> 00:28:37,620
fail miserably and this is how I feel

00:28:35,310 --> 00:28:41,460
when I work with that and try to debug

00:28:37,620 --> 00:28:47,690
is synchronous errors I promise this is

00:28:41,460 --> 00:28:50,580
the last gift so how to deal with this

00:28:47,690 --> 00:28:53,000
there are multiple things that consider

00:28:50,580 --> 00:28:56,010
that I consider the best practice I

00:28:53,000 --> 00:28:59,310
would not go into details about all of

00:28:56,010 --> 00:29:02,400
them but I think the most important one

00:28:59,310 --> 00:29:03,840
is uncaught exception so process

00:29:02,400 --> 00:29:06,050
remember process how many of you

00:29:03,840 --> 00:29:08,460
remember process

00:29:06,050 --> 00:29:11,240
okay that's a good ratio half of the

00:29:08,460 --> 00:29:14,970
room another half is already sleeping

00:29:11,240 --> 00:29:23,280
ungass exception so process that on

00:29:14,970 --> 00:29:25,650
uncut exception this is how we attach an

00:29:23,280 --> 00:29:28,140
event listener so again process

00:29:25,650 --> 00:29:32,450
implements event listener and the event

00:29:28,140 --> 00:29:34,920
emitter pattern why this is good because

00:29:32,450 --> 00:29:39,420
this is like the last step before

00:29:34,920 --> 00:29:42,420
application crashes so we definitely

00:29:39,420 --> 00:29:46,110
want to listen to this error handler to

00:29:42,420 --> 00:29:48,180
this event we want to log it we want to

00:29:46,110 --> 00:29:50,880
maybe send an email or a slack

00:29:48,180 --> 00:29:52,680
notification and then we want to exit

00:29:50,880 --> 00:29:55,050
gracefully so we don't want to resume

00:29:52,680 --> 00:30:00,000
the application because the state might

00:29:55,050 --> 00:30:03,740
be lost at this point okay here's the

00:30:00,000 --> 00:30:06,750
domain which is softly deprecated

00:30:03,740 --> 00:30:08,190
nothing scary about self-deprecation it

00:30:06,750 --> 00:30:11,190
just means they're going to remove it

00:30:08,190 --> 00:30:14,100
from the core but I'm sure it will be

00:30:11,190 --> 00:30:16,890
like a standalone NPM module the way it

00:30:14,100 --> 00:30:20,010
works we can put code inside of the main

00:30:16,890 --> 00:30:23,250
dot run and even it's a synchronous code

00:30:20,010 --> 00:30:25,770
it will still catch those pairs it will

00:30:23,250 --> 00:30:28,200
still casual sizing cursors so if you're

00:30:25,770 --> 00:30:31,830
building an express server you can wrap

00:30:28,200 --> 00:30:34,110
all middleware all routes in the main

00:30:31,830 --> 00:30:37,140
dog run or you can just rub a single

00:30:34,110 --> 00:30:40,170
route I have a few examples in the

00:30:37,140 --> 00:30:44,400
source code folder as well so this code

00:30:40,170 --> 00:30:48,500
will run okay and then the last bonus

00:30:44,400 --> 00:30:52,470
part we three minutes over the time so I

00:30:48,500 --> 00:30:56,850
will move a little bit faster it's about

00:30:52,470 --> 00:30:58,650
writing the C++ add-ons so a lot of

00:30:56,850 --> 00:31:01,620
people think that no jess is just

00:30:58,650 --> 00:31:04,530
JavaScript well actually there is more C

00:31:01,620 --> 00:31:07,710
and C++ in nodejs itself in the platform

00:31:04,530 --> 00:31:10,350
itself than JavaScript and it's very

00:31:07,710 --> 00:31:12,450
very straightforward how to make them

00:31:10,350 --> 00:31:15,570
work together if you want to write a

00:31:12,450 --> 00:31:19,260
module or a driver to your database or

00:31:15,570 --> 00:31:22,050
maybe some hardware device

00:31:19,260 --> 00:31:24,210
all you need to do is have a simple aah

00:31:22,050 --> 00:31:25,950
splat file obviously right

00:31:24,210 --> 00:31:28,980
so I'm going to work if you don't have

00:31:25,950 --> 00:31:34,080
the source code and then notice this

00:31:28,980 --> 00:31:37,680
thing so this thing will output a string

00:31:34,080 --> 00:31:39,420
and then I'm exporting my method so you

00:31:37,680 --> 00:31:41,820
need to do two things inside of your C

00:31:39,420 --> 00:31:45,180
code you need to well write your code

00:31:41,820 --> 00:31:48,750
right and then expose it as the method

00:31:45,180 --> 00:31:52,590
and then I'm creating this JSON file

00:31:48,750 --> 00:31:57,390
which has the name of my add-on the name

00:31:52,590 --> 00:31:59,640
of my library and my source code I'm

00:31:57,390 --> 00:32:02,640
installing no which will do the

00:31:59,640 --> 00:32:06,060
compilation and run this two commands

00:32:02,640 --> 00:32:09,300
configure and build and that's it boom I

00:32:06,060 --> 00:32:12,300
would have this folder build release now

00:32:09,300 --> 00:32:16,620
from the node all I'm doing is just

00:32:12,300 --> 00:32:19,410
requiring this folder and I can use my

00:32:16,620 --> 00:32:22,470
method so hello that's the same method

00:32:19,410 --> 00:32:25,290
that I defined and exported in C++ so

00:32:22,470 --> 00:32:28,380
that would output Capital One when I run

00:32:25,290 --> 00:32:30,930
it so you can basically communicate

00:32:28,380 --> 00:32:33,240
between two worlds two different

00:32:30,930 --> 00:32:36,380
languages I think that's pretty pretty

00:32:33,240 --> 00:32:39,330
cool if you want to hear more about

00:32:36,380 --> 00:32:43,430
node.js at Capital One we are top US

00:32:39,330 --> 00:32:43,430
bank there is a YouTube video and

00:32:44,150 --> 00:32:49,320
30-second summary we'll make it like

00:32:46,260 --> 00:32:53,910
three seconds summary so invented meters

00:32:49,320 --> 00:33:00,840
streams clusters the main c++ add-ons

00:32:53,910 --> 00:33:05,250
and streams so this slides on github to

00:33:00,840 --> 00:33:08,370
search my name and also find it can

00:33:05,250 --> 00:33:12,060
reach me on twitter and if you want to

00:33:08,370 --> 00:33:14,370
learn more at node university I have I

00:33:12,060 --> 00:33:17,670
would have this stock available there

00:33:14,370 --> 00:33:19,410
for free all open-source as an online

00:33:17,670 --> 00:33:22,440
course and also have a bunch of other

00:33:19,410 --> 00:33:24,840
online courses and node.js as well one

00:33:22,440 --> 00:33:28,170
last thing this is a quote from coding

00:33:24,840 --> 00:33:31,200
horror dot-com and JavaScript is

00:33:28,170 --> 00:33:32,930
everywhere and it could be a good thing

00:33:31,200 --> 00:33:36,080
or it could be a scary thing

00:33:32,930 --> 00:33:39,910
to think about Tesla running on

00:33:36,080 --> 00:33:42,350
JavaScript but if you think about

00:33:39,910 --> 00:33:46,130
terminators running on JavaScript

00:33:42,350 --> 00:33:46,730
maybe humanity will have a hope thank

00:33:46,130 --> 00:33:49,840
you everyone

00:33:46,730 --> 00:33:49,840

YouTube URL: https://www.youtube.com/watch?v=NLtL-EEclRc


