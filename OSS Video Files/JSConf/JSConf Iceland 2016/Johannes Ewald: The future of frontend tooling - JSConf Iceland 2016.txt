Title: Johannes Ewald: The future of frontend tooling - JSConf Iceland 2016
Publication date: 2016-09-20
Playlist: JSConf Iceland 2016
Description: 
	Our frontend toolstack has become quite complex over the past few years. In order to overcome typical problems when building large websites, we've built a variety of tools with shiny names like Grunt, Gulp or Webpack. However, things are about to change. With new technologies like HTTP2, ES2015 and Web Components around the corner, we need to ask ourselves: are the best practices from today still valid in the future? What kind of tools will we be using in the next few years? Will we need them at all? In my talk, I am going to show you how these new technologies will change the way we work.
Captions: 
	00:00:11,680 --> 00:00:17,960
hi welcome everyone who are few things

00:00:15,830 --> 00:00:23,110
that front end development has become

00:00:17,960 --> 00:00:27,259
more complex in the past 45 years okay

00:00:23,110 --> 00:00:29,689
you're not alone I think 2015 was the

00:00:27,259 --> 00:00:32,360
year of JavaScript fatigue and the term

00:00:29,689 --> 00:00:35,000
was coined by an excellent article by

00:00:32,360 --> 00:00:38,930
Eric Clemens it was published in

00:00:35,000 --> 00:00:42,740
December 20 2015 and it was about the

00:00:38,930 --> 00:00:44,870
explosion of libraries and tools that he

00:00:42,740 --> 00:00:48,310
had experienced when starting with react

00:00:44,870 --> 00:00:51,500
and he certainly right so I try to

00:00:48,310 --> 00:00:54,320
collect all the truths it's just a small

00:00:51,500 --> 00:00:56,600
collection we have custom languages we

00:00:54,320 --> 00:00:59,300
have linters we have bundlers we have

00:00:56,600 --> 00:01:01,880
many fires we have def troops to support

00:00:59,300 --> 00:01:04,699
our development workflow we have task

00:01:01,880 --> 00:01:07,340
runners we have Tom libraries routing

00:01:04,699 --> 00:01:09,439
libraries state libraries and of course

00:01:07,340 --> 00:01:14,270
we have package managers to install all

00:01:09,439 --> 00:01:18,409
these things so a lot of tools and but I

00:01:14,270 --> 00:01:22,030
think this was in the end of 2015 but

00:01:18,409 --> 00:01:25,009
now it's 2016 so we in the future right

00:01:22,030 --> 00:01:28,810
there are a lot of exciting new

00:01:25,009 --> 00:01:32,689
technologies coming up like HTTP two or

00:01:28,810 --> 00:01:38,600
es2015 or web components and the browser

00:01:32,689 --> 00:01:41,299
support is getting better each day so in

00:01:38,600 --> 00:01:44,899
modern browsers so how do these new

00:01:41,299 --> 00:01:47,420
features change the way we work and do

00:01:44,899 --> 00:01:50,749
we need even to even eat these tools

00:01:47,420 --> 00:01:52,819
that I've mentioned before but it become

00:01:50,749 --> 00:01:55,189
natively available through the platform

00:01:52,819 --> 00:01:57,709
and that's actually the topic of my talk

00:01:55,189 --> 00:02:00,529
it's about the future of front and

00:01:57,709 --> 00:02:04,189
chilling and my name is Johanna say but

00:02:00,529 --> 00:02:06,619
i founded a company in Germany with my

00:02:04,189 --> 00:02:09,349
friends it's called Paragon and this is

00:02:06,619 --> 00:02:14,120
my twitter handle and yes it's 3m

00:02:09,349 --> 00:02:17,240
because 2n was already taking yeah and

00:02:14,120 --> 00:02:19,190
we do also a lot of open source we are

00:02:17,240 --> 00:02:22,760
very passionate about all source I think

00:02:19,190 --> 00:02:25,580
every company should do more open source

00:02:22,760 --> 00:02:29,450
and I'm also happy to be a member of the

00:02:25,580 --> 00:02:32,510
web pack core team and now we do weekly

00:02:29,450 --> 00:02:35,989
meetups and talk about a new stuff in

00:02:32,510 --> 00:02:38,840
backpack so let's explore these new

00:02:35,989 --> 00:02:41,090
technologies and we start with East 2015

00:02:38,840 --> 00:02:43,430
modules because I think they are really

00:02:41,090 --> 00:02:47,930
great and you probably have seen them

00:02:43,430 --> 00:02:50,180
already if not I just show it to you you

00:02:47,930 --> 00:02:53,870
have an export statement and you can

00:02:50,180 --> 00:02:55,879
import stuff and directly and it's a

00:02:53,870 --> 00:02:58,819
real nice syntax it avoids naming

00:02:55,879 --> 00:03:01,519
collisions and I think that's one of the

00:02:58,819 --> 00:03:05,269
biggest parts that has been missing to

00:03:01,519 --> 00:03:07,220
JavaScript and actually it looks pretty

00:03:05,269 --> 00:03:12,560
similar to come and guess what we are

00:03:07,220 --> 00:03:16,159
used to write in nodejs so it looks

00:03:12,560 --> 00:03:20,030
almost the same but actually there's a

00:03:16,159 --> 00:03:24,379
big difference there are two important

00:03:20,030 --> 00:03:27,919
differences so in common j/s you can do

00:03:24,379 --> 00:03:30,620
dynamic imports like this one where you

00:03:27,919 --> 00:03:33,310
require just a variable you don't know

00:03:30,620 --> 00:03:35,900
what the path will be it will be

00:03:33,310 --> 00:03:39,019
determined on ranch I'm so it's totally

00:03:35,900 --> 00:03:41,930
valid but you can't do that with is 2015

00:03:39,019 --> 00:03:45,139
modules this would be a syntax error if

00:03:41,930 --> 00:03:50,930
you import a variable you need to name

00:03:45,139 --> 00:03:54,440
the exact half up front and another

00:03:50,930 --> 00:03:57,019
difference is that with come on Jas you

00:03:54,440 --> 00:03:59,660
actually get a copied value so if you

00:03:57,019 --> 00:04:01,940
import a number you get a copy of that

00:03:59,660 --> 00:04:04,910
number and if you import a function you

00:04:01,940 --> 00:04:10,489
get a copy of the reference to that

00:04:04,910 --> 00:04:14,299
function so in this example when I

00:04:10,489 --> 00:04:16,810
increment when I call increment and the

00:04:14,299 --> 00:04:20,180
number will not actually be incremented

00:04:16,810 --> 00:04:24,650
incremented in maine j/s because i got a

00:04:20,180 --> 00:04:26,750
copy and with is 2015 you get life

00:04:24,650 --> 00:04:29,750
values which means that you get the

00:04:26,750 --> 00:04:32,389
actual value into the module scope it's

00:04:29,750 --> 00:04:34,849
like like it has been defined in the

00:04:32,389 --> 00:04:36,200
extra scope so that's a real difference

00:04:34,849 --> 00:04:39,590
and you could not

00:04:36,200 --> 00:04:44,510
really do that without the native

00:04:39,590 --> 00:04:47,500
support these properties make is 2015

00:04:44,510 --> 00:04:50,300
modules less flexible than comment yes

00:04:47,500 --> 00:04:54,830
but they are also the foundation for

00:04:50,300 --> 00:04:57,350
three shaking and three shaking is let

00:04:54,830 --> 00:05:01,460
me explain that so for instance if you

00:04:57,350 --> 00:05:03,050
have a module that has a value and we

00:05:01,460 --> 00:05:06,080
have two functions increment and

00:05:03,050 --> 00:05:09,290
decrement but we only use the function

00:05:06,080 --> 00:05:13,160
increment so we don't really need to

00:05:09,290 --> 00:05:16,220
include the function decrement and with

00:05:13,160 --> 00:05:19,490
tree shaking and is 23 modules we are

00:05:16,220 --> 00:05:21,800
able to resolve that because we can just

00:05:19,490 --> 00:05:23,390
just by looking at the source code we

00:05:21,800 --> 00:05:26,120
know that the function decrement is

00:05:23,390 --> 00:05:28,010
never called so we can just remove it

00:05:26,120 --> 00:05:33,590
from the code and this is called tree

00:05:28,010 --> 00:05:35,960
shaking so the static nature of is 2015

00:05:33,590 --> 00:05:40,310
modules makes it possible to trace all

00:05:35,960 --> 00:05:42,560
the exports that are actually used but

00:05:40,310 --> 00:05:45,260
with a static model system how do we

00:05:42,560 --> 00:05:47,330
load things on demand that's still

00:05:45,260 --> 00:05:52,370
important especially in the front end

00:05:47,330 --> 00:05:55,340
and so there's another tool it's called

00:05:52,370 --> 00:05:59,080
system import so system import all

00:05:55,340 --> 00:06:01,970
things and that's a way to load

00:05:59,080 --> 00:06:06,260
asynchronously and in a dynamic way and

00:06:01,970 --> 00:06:08,480
to load modules into the program it

00:06:06,260 --> 00:06:11,270
looks like this where you call system

00:06:08,480 --> 00:06:13,610
import and you specify the module and

00:06:11,270 --> 00:06:16,010
you get back a promise and of course

00:06:13,610 --> 00:06:17,900
this could fail because network is down

00:06:16,010 --> 00:06:20,690
or something or the money could not be

00:06:17,900 --> 00:06:26,870
found so we have also to handle the

00:06:20,690 --> 00:06:30,950
error but unfortunately things aren't

00:06:26,870 --> 00:06:33,400
finalized yet so that's because system

00:06:30,950 --> 00:06:35,780
import is very platform specific and

00:06:33,400 --> 00:06:38,150
many things need to be consistent

00:06:35,780 --> 00:06:40,310
considered so system import works

00:06:38,150 --> 00:06:43,040
different in node then it works in the

00:06:40,310 --> 00:06:47,720
browser so it's hard to get these things

00:06:43,040 --> 00:06:48,620
right and that's why the tc39 decided to

00:06:47,720 --> 00:06:52,210
exclude

00:06:48,620 --> 00:06:56,630
is 2015 and it is now currently

00:06:52,210 --> 00:06:58,430
specified as separate loader standard so

00:06:56,630 --> 00:07:00,139
once we can load more is natively in the

00:06:58,430 --> 00:07:04,190
browser do we need tools like browser

00:07:00,139 --> 00:07:06,350
fire or web pack anymore well to answer

00:07:04,190 --> 00:07:08,300
this question we should take a look at

00:07:06,350 --> 00:07:11,660
another technology first and this is

00:07:08,300 --> 00:07:13,100
HTTP two and I will not talk about all

00:07:11,660 --> 00:07:15,020
the new features of HTTP true there are

00:07:13,100 --> 00:07:17,720
a lot of creatures like header

00:07:15,020 --> 00:07:21,139
compression but I don't think this would

00:07:17,720 --> 00:07:23,510
be another talk so I just keep my focus

00:07:21,139 --> 00:07:27,710
on features that are important for the

00:07:23,510 --> 00:07:30,470
front and tooling so first feature HTTP

00:07:27,710 --> 00:07:35,060
two is a binary protocol you know HTTP

00:07:30,470 --> 00:07:38,229
one is a text based protocol so requests

00:07:35,060 --> 00:07:42,710
and responses are actually streams and

00:07:38,229 --> 00:07:47,060
you screams can be divided into frames

00:07:42,710 --> 00:07:49,690
and frames can be interleaved so now we

00:07:47,060 --> 00:07:51,949
have multiple requests and responses

00:07:49,690 --> 00:07:55,750
simultaneously on a single TCP

00:07:51,949 --> 00:07:58,190
connection and this actually eliminates

00:07:55,750 --> 00:08:00,460
HTTP one's problem of head of line

00:07:58,190 --> 00:08:03,080
blocking where you had to wait for the

00:08:00,460 --> 00:08:06,349
response to be finished to send the next

00:08:03,080 --> 00:08:08,960
request and this actually invalidates

00:08:06,349 --> 00:08:11,150
some of our best practices like bundling

00:08:08,960 --> 00:08:13,550
multiple resources into one file to

00:08:11,150 --> 00:08:18,070
avoid requests or domain sharding where

00:08:13,550 --> 00:08:21,020
you put your assets on different domains

00:08:18,070 --> 00:08:22,610
great so let's get rid of all the

00:08:21,020 --> 00:08:26,630
bundles and just include our development

00:08:22,610 --> 00:08:29,990
files well not so fast there are

00:08:26,630 --> 00:08:31,970
problems first one tree shaking when

00:08:29,990 --> 00:08:34,190
there are no bundles who is doing the

00:08:31,970 --> 00:08:37,330
tree shaking we still need a tool that

00:08:34,190 --> 00:08:41,209
figure out all the dependencies and

00:08:37,330 --> 00:08:44,900
resource all the imports and then that's

00:08:41,209 --> 00:08:46,700
the tree shaking on a moral code the

00:08:44,900 --> 00:08:51,080
second problem is minification we also

00:08:46,700 --> 00:08:56,690
need to minify the HTML CSS and

00:08:51,080 --> 00:08:59,450
JavaScript we still there we also have

00:08:56,690 --> 00:09:02,800
compression and choose the compression

00:08:59,450 --> 00:09:04,730
is better if the

00:09:02,800 --> 00:09:07,640
choo-choos the compression is good at

00:09:04,730 --> 00:09:10,820
removing repetition so when we have a

00:09:07,640 --> 00:09:13,910
big file it's more efficient if we then

00:09:10,820 --> 00:09:16,820
compared to compressing many small files

00:09:13,910 --> 00:09:19,960
so it may be still a good idea to put

00:09:16,820 --> 00:09:23,720
all the files into one file probably and

00:09:19,960 --> 00:09:25,010
the last problem is the round trip the

00:09:23,720 --> 00:09:27,920
browser can only discover additional

00:09:25,010 --> 00:09:31,550
dependencies after the response has been

00:09:27,920 --> 00:09:34,790
received and passed so I call this the

00:09:31,550 --> 00:09:38,870
A&D problem like the client says oh give

00:09:34,790 --> 00:09:42,340
me HS and services here we go oh I see

00:09:38,870 --> 00:09:45,290
now I also need pjs no prop here you go

00:09:42,340 --> 00:09:49,820
sorry do you also have CJ s so it goes

00:09:45,290 --> 00:09:52,040
all the way like this and that's where

00:09:49,820 --> 00:09:57,860
another feature of HTTP comes into play

00:09:52,040 --> 00:09:59,780
it's called server push and with the

00:09:57,860 --> 00:10:03,410
server push we are able to push

00:09:59,780 --> 00:10:05,810
resources proactively to the client so

00:10:03,410 --> 00:10:08,090
now when the when the client tries to

00:10:05,810 --> 00:10:11,390
request that file it is instantly

00:10:08,090 --> 00:10:18,140
available available and can be cashed so

00:10:11,390 --> 00:10:23,780
then yeah so what do we need to provide

00:10:18,140 --> 00:10:26,360
sort of push and for instance we could

00:10:23,780 --> 00:10:30,260
use a dependency tree like if we have

00:10:26,360 --> 00:10:33,590
index HTML we have an index.html and we

00:10:30,260 --> 00:10:37,040
know this index HTML imports or requires

00:10:33,590 --> 00:10:39,470
a style sheet and it requires JavaScript

00:10:37,040 --> 00:10:43,310
we can put that into one chasing file

00:10:39,470 --> 00:10:46,250
and just let us serve a handle that

00:10:43,310 --> 00:10:48,110
manifest so this is actually a proposal

00:10:46,250 --> 00:10:51,620
from google it's called the push

00:10:48,110 --> 00:10:55,250
manifest proposal and then for we have

00:10:51,620 --> 00:10:59,180
this dependency tree for each file for

00:10:55,250 --> 00:11:04,040
instance for the app CSS there's also an

00:10:59,180 --> 00:11:08,200
else statement that imports the image so

00:11:04,040 --> 00:11:08,200
we have to do that for every file

00:11:09,980 --> 00:11:16,340
and how do we get this depends tree so

00:11:12,770 --> 00:11:18,740
there are two ways to do that we could

00:11:16,340 --> 00:11:23,390
analyze the traffic using the referer

00:11:18,740 --> 00:11:26,390
header and see where the requests are

00:11:23,390 --> 00:11:28,280
coming from or we could use a tool like

00:11:26,390 --> 00:11:30,530
a bundler that figures out the

00:11:28,280 --> 00:11:32,750
dependency graph the dependency graph is

00:11:30,530 --> 00:11:34,580
the data model where you say oh this

00:11:32,750 --> 00:11:39,170
fire requires this file this file

00:11:34,580 --> 00:11:40,850
requires this file and so on okay so

00:11:39,170 --> 00:11:42,590
great let's figure out the dependency

00:11:40,850 --> 00:11:45,580
graph and push everything to the client

00:11:42,590 --> 00:11:48,370
oh not so fast there are still problems

00:11:45,580 --> 00:11:50,780
the first problem is responsive images

00:11:48,370 --> 00:11:51,770
we need information about the client

00:11:50,780 --> 00:11:53,540
because we don't want to push

00:11:51,770 --> 00:11:57,230
high-resolution images to small screens

00:11:53,540 --> 00:11:59,420
for instance the second problem is the

00:11:57,230 --> 00:12:02,540
cash we don't know what the client has

00:11:59,420 --> 00:12:04,340
already cashed so we cannot just push

00:12:02,540 --> 00:12:07,150
all the things to the client because

00:12:04,340 --> 00:12:09,320
maybe it has it has cashed it already so

00:12:07,150 --> 00:12:12,650
we don't want to waste that precious

00:12:09,320 --> 00:12:14,660
bandwidth and there's a proposal for a

00:12:12,650 --> 00:12:18,370
proposed solution for this it's called

00:12:14,660 --> 00:12:21,110
cash digest the next problem is

00:12:18,370 --> 00:12:22,910
authorization so we need to make sure

00:12:21,110 --> 00:12:25,310
that we don't push confidential

00:12:22,910 --> 00:12:27,200
resources to the client so push

00:12:25,310 --> 00:12:34,120
basically requires the same of a

00:12:27,200 --> 00:12:37,010
relation flow as requests and we can't

00:12:34,120 --> 00:12:39,260
we can't push resources from third

00:12:37,010 --> 00:12:43,720
parties or so if we are using a CDN and

00:12:39,260 --> 00:12:46,610
our own server we see the end can't push

00:12:43,720 --> 00:12:51,010
just push a resource to the client there

00:12:46,610 --> 00:12:54,250
must be one initial request first and

00:12:51,010 --> 00:12:56,750
the last problem is prioritization

00:12:54,250 --> 00:12:59,690
because if we just push all the

00:12:56,750 --> 00:13:02,420
resources without prioritization it

00:12:59,690 --> 00:13:04,550
actually harms performance so for

00:13:02,420 --> 00:13:07,940
instance if we have an HTML file like

00:13:04,550 --> 00:13:11,020
this where we include a main CSS and in

00:13:07,940 --> 00:13:15,220
the main.css there is a phone face

00:13:11,020 --> 00:13:19,010
included and we have two heavy images

00:13:15,220 --> 00:13:23,930
now CSS and fonts a render blocking and

00:13:19,010 --> 00:13:27,110
images or not but if you just push

00:13:23,930 --> 00:13:29,870
everything to the client the images

00:13:27,110 --> 00:13:34,580
would waste our precious spent if so the

00:13:29,870 --> 00:13:36,680
initial render would be way slower than

00:13:34,580 --> 00:13:39,970
with HTTP one because we are wasting

00:13:36,680 --> 00:13:43,420
bandwidth on images but we should push

00:13:39,970 --> 00:13:46,490
the style sheets and fonts first and

00:13:43,420 --> 00:13:50,270
that's why hcp provides a way to weigh

00:13:46,490 --> 00:13:53,870
each stream and pause resume and pencil

00:13:50,270 --> 00:13:56,149
extreme but a good implementation that

00:13:53,870 --> 00:13:59,420
takes everything into account is very

00:13:56,149 --> 00:14:01,670
challenging and complex and actually

00:13:59,420 --> 00:14:04,160
with HPV one with the head of line

00:14:01,670 --> 00:14:07,820
blocking it actually prevented this kind

00:14:04,160 --> 00:14:10,730
of wrong prioritization because if we

00:14:07,820 --> 00:14:12,529
had an HTML file like this we knew

00:14:10,730 --> 00:14:16,190
exactly in which order the files are

00:14:12,529 --> 00:14:18,680
requested so maybe the head of line

00:14:16,190 --> 00:14:22,550
blocking was not so bad at least it was

00:14:18,680 --> 00:14:26,270
predictable what will happen so in this

00:14:22,550 --> 00:14:30,350
case we can even include dimensions to

00:14:26,270 --> 00:14:32,800
the image so the image layout is already

00:14:30,350 --> 00:14:35,660
rendered and the browser chest needs to

00:14:32,800 --> 00:14:43,000
actually render the image but it already

00:14:35,660 --> 00:14:46,040
can build the layout of the page then as

00:14:43,000 --> 00:14:51,320
next and last technology we have web

00:14:46,040 --> 00:14:54,650
components and the vision of web

00:14:51,320 --> 00:14:57,380
components is you can think of web

00:14:54,650 --> 00:15:00,260
components as reusable user interface

00:14:57,380 --> 00:15:02,990
which is that I created using open web

00:15:00,260 --> 00:15:05,000
technology they are part of the browser

00:15:02,990 --> 00:15:07,100
and so they do not need external

00:15:05,000 --> 00:15:08,930
libraries like jQuery or dojo an

00:15:07,100 --> 00:15:10,910
existing web permanent can be used

00:15:08,930 --> 00:15:13,160
without writing code simply by adding an

00:15:10,910 --> 00:15:15,620
import statement to an HTML page I've

00:15:13,160 --> 00:15:19,790
copied that from the Mozilla developer

00:15:15,620 --> 00:15:23,480
Network but actually web components is a

00:15:19,790 --> 00:15:26,899
bit as a fuzzy term because it refers to

00:15:23,480 --> 00:15:29,899
four different technologies we have HTML

00:15:26,899 --> 00:15:32,600
templates we have HTML custom elements

00:15:29,899 --> 00:15:37,610
we have the shadow DOM and we have HTML

00:15:32,600 --> 00:15:39,589
imports and actually custom elements

00:15:37,610 --> 00:15:41,529
HTML imports and the shadow Dom have

00:15:39,589 --> 00:15:43,910
already gone through several revisions

00:15:41,529 --> 00:15:46,910
which makes it really hard to find

00:15:43,910 --> 00:15:50,779
up-to-date information when I was

00:15:46,910 --> 00:15:52,970
preparing the talk it was very confusing

00:15:50,779 --> 00:15:56,899
for me too and I was not sure if this is

00:15:52,970 --> 00:15:59,870
the current draft so and even Mozilla

00:15:56,899 --> 00:16:02,570
Microsoft decided to post development on

00:15:59,870 --> 00:16:05,000
HTML imports entirely because they

00:16:02,570 --> 00:16:10,180
thought that the es lo de spec has too

00:16:05,000 --> 00:16:16,220
much overlap with HTML imports so yes

00:16:10,180 --> 00:16:18,769
this spec is currently paused but let's

00:16:16,220 --> 00:16:21,380
start with HTML templates they provide a

00:16:18,769 --> 00:16:25,220
way to define HTML fragments that are

00:16:21,380 --> 00:16:29,240
parts but all interpreted so these

00:16:25,220 --> 00:16:31,970
templates are inert which means that no

00:16:29,240 --> 00:16:34,100
markup is displayed no styles are

00:16:31,970 --> 00:16:37,010
applied no images are loaded no

00:16:34,100 --> 00:16:38,899
javascript is executed and the inner

00:16:37,010 --> 00:16:42,320
contents of the templates are invisible

00:16:38,899 --> 00:16:45,949
to selectors so it's just an inactive

00:16:42,320 --> 00:16:51,320
part of the page and we can get that

00:16:45,949 --> 00:16:53,540
into the drum by importing it into the

00:16:51,320 --> 00:16:59,990
drum and now we get real Dom nodes and

00:16:53,540 --> 00:17:03,230
then it will get active the second part

00:16:59,990 --> 00:17:05,299
is custom elements it's in a JavaScript

00:17:03,230 --> 00:17:08,329
API to register custom implementation

00:17:05,299 --> 00:17:10,669
for arbitrary elements and the current

00:17:08,329 --> 00:17:13,309
draft looks like this we define a class

00:17:10,669 --> 00:17:15,640
my button that extends the HTML button

00:17:13,309 --> 00:17:18,650
element for instance and we have

00:17:15,640 --> 00:17:22,040
lifecycle hooks like connected callback

00:17:18,650 --> 00:17:25,790
disconnected call that it looks a bit

00:17:22,040 --> 00:17:28,309
like a react component and then we can

00:17:25,790 --> 00:17:31,570
register the element by calling custom

00:17:28,309 --> 00:17:36,200
elements that define and we can even

00:17:31,570 --> 00:17:43,460
extend built-in texts like the button

00:17:36,200 --> 00:17:45,410
and like this the next part of the web

00:17:43,460 --> 00:17:47,540
components back is the shadow DOM and I

00:17:45,410 --> 00:17:49,400
think this the heart of the web

00:17:47,540 --> 00:17:51,560
components and the

00:17:49,400 --> 00:17:55,670
most it's difficult to polyfill this

00:17:51,560 --> 00:17:57,500
because it's encapsulated in heitz

00:17:55,670 --> 00:18:00,650
elements styles and events behind a

00:17:57,500 --> 00:18:02,750
single element and it also describes how

00:18:00,650 --> 00:18:05,330
content of the documentary is trans

00:18:02,750 --> 00:18:07,970
cluded into the shadow tree it's a bit

00:18:05,330 --> 00:18:12,620
complicated and I will not go much into

00:18:07,970 --> 00:18:15,560
detail here but it's looked it looks

00:18:12,620 --> 00:18:20,120
like this where you attach a shadow Dom

00:18:15,560 --> 00:18:24,370
it's like encapsulated part of the DOM

00:18:20,120 --> 00:18:31,720
and that's where all the styles and all

00:18:24,370 --> 00:18:35,030
all the texts are just encapsulated and

00:18:31,720 --> 00:18:37,340
last part is HTML imports where you can

00:18:35,030 --> 00:18:39,530
import other HTML documents into the

00:18:37,340 --> 00:18:43,970
current one including all the templates

00:18:39,530 --> 00:18:47,990
styles and scripts so for instance if we

00:18:43,970 --> 00:18:53,200
have a link tag here and we import blog

00:18:47,990 --> 00:18:55,670
post dot HTML all these styles are

00:18:53,200 --> 00:18:58,040
immediately applied to the importing

00:18:55,670 --> 00:19:01,370
document all the scripts are executed in

00:18:58,040 --> 00:19:03,770
the important documents context but all

00:19:01,370 --> 00:19:08,120
the HTML needs to be appended to the

00:19:03,770 --> 00:19:09,740
dome via JavaScript great so let's get

00:19:08,120 --> 00:19:13,390
rid of all the frameworks and just write

00:19:09,740 --> 00:19:17,360
native web components well not so fast

00:19:13,390 --> 00:19:21,110
the first problem I see is the data flow

00:19:17,360 --> 00:19:23,270
with web components data is usually

00:19:21,110 --> 00:19:27,100
provided as strings by attributes on the

00:19:23,270 --> 00:19:29,210
shadow host like this in this example I

00:19:27,100 --> 00:19:31,100
think this may work for simple

00:19:29,210 --> 00:19:34,610
components but not for more complex ones

00:19:31,100 --> 00:19:36,280
like higher-order components and I don't

00:19:34,610 --> 00:19:40,570
really want to write code like this

00:19:36,280 --> 00:19:44,690
where you have to write a chase and

00:19:40,570 --> 00:19:48,620
attribute value the second problem is

00:19:44,690 --> 00:19:50,600
it's still very imperative so with web

00:19:48,620 --> 00:19:56,200
forum frameworks we get a declarative

00:19:50,600 --> 00:19:59,770
way to to describe Dom manipulations but

00:19:56,200 --> 00:20:02,320
with web components it's just like

00:19:59,770 --> 00:20:04,299
manual Dom manipulation and where

00:20:02,320 --> 00:20:06,340
imperative way so personally I don't

00:20:04,299 --> 00:20:12,130
want to go back to that kind of style

00:20:06,340 --> 00:20:14,889
and they are self-contained which sounds

00:20:12,130 --> 00:20:17,889
nice but my encapsulation is a good

00:20:14,889 --> 00:20:19,450
thing true self contained web components

00:20:17,889 --> 00:20:22,720
from different sources may not be

00:20:19,450 --> 00:20:24,549
desirable so for instance we may end up

00:20:22,720 --> 00:20:26,500
with different versions of react angular

00:20:24,549 --> 00:20:30,370
and ember on the same page and I don't

00:20:26,500 --> 00:20:33,820
know if we really want that and the

00:20:30,370 --> 00:20:36,820
second a fourth problem is global

00:20:33,820 --> 00:20:39,909
namespace it's like the mistakes from

00:20:36,820 --> 00:20:42,039
the past where we always have to care

00:20:39,909 --> 00:20:45,100
about conflicting namespaces and to

00:20:42,039 --> 00:20:50,200
prefix all the stuff so hmm imports

00:20:45,100 --> 00:20:53,200
don't really solve that well we may have

00:20:50,200 --> 00:20:54,879
a fly flash of unstyled content if we

00:20:53,200 --> 00:20:57,820
fail to deliver the implementation of a

00:20:54,879 --> 00:20:59,799
custom element fast enough the browser

00:20:57,820 --> 00:21:02,350
will display the custom element is HTML

00:20:59,799 --> 00:21:07,000
unknown element which is not not good

00:21:02,350 --> 00:21:09,070
and last but at least we don't really

00:21:07,000 --> 00:21:11,919
have a path for progressive enhancement

00:21:09,070 --> 00:21:14,830
so web components are defined via

00:21:11,919 --> 00:21:17,559
JavaScript and if something goes wrong

00:21:14,830 --> 00:21:19,629
our web app will be problem and of

00:21:17,559 --> 00:21:22,210
course that's also the case with a

00:21:19,629 --> 00:21:25,360
single page application frameworks but I

00:21:22,210 --> 00:21:29,320
think Universal javascript is a good way

00:21:25,360 --> 00:21:31,000
to always fall back to server side

00:21:29,320 --> 00:21:35,320
rendering if something goes wrong on the

00:21:31,000 --> 00:21:36,610
client so I still think we should keep

00:21:35,320 --> 00:21:44,590
the idea of progressive enhancement

00:21:36,610 --> 00:21:47,620
alive okay so the conclusion will is

00:21:44,590 --> 00:21:49,659
2015 models change the way we work yes

00:21:47,620 --> 00:21:52,149
of course finally we have a universal

00:21:49,659 --> 00:21:54,220
module format for JavaScript it's a

00:21:52,149 --> 00:21:57,460
great sin tax it avoids typical problems

00:21:54,220 --> 00:21:59,440
like namespace conflicts it enables tree

00:21:57,460 --> 00:22:02,950
shaking through static analysis so I

00:21:59,440 --> 00:22:05,799
just have i can write choose that reads

00:22:02,950 --> 00:22:08,919
the code and understands what what the

00:22:05,799 --> 00:22:13,480
code is importing and then we can remove

00:22:08,919 --> 00:22:15,580
all the unused stuff and i think it's a

00:22:13,480 --> 00:22:16,120
good idea to encapsulate platform

00:22:15,580 --> 00:22:18,640
semantics

00:22:16,120 --> 00:22:21,610
into a separate lower spec so we can

00:22:18,640 --> 00:22:24,910
define all things for the browser in a

00:22:21,610 --> 00:22:27,070
in the Lotus back and for node and maybe

00:22:24,910 --> 00:22:32,200
whatever need JavaScript environment

00:22:27,070 --> 00:22:34,690
will come up we'll hdb to change the way

00:22:32,200 --> 00:22:37,240
we work yes of course by new streams

00:22:34,690 --> 00:22:41,230
invalidate former best practices we have

00:22:37,240 --> 00:22:43,290
to rethink all of them again we have a

00:22:41,230 --> 00:22:47,500
more fine-grained control over

00:22:43,290 --> 00:22:49,600
optimization and so approach provides a

00:22:47,500 --> 00:22:53,080
new way to deliver resources separately

00:22:49,600 --> 00:22:55,600
but in order to leverage streams and

00:22:53,080 --> 00:22:57,460
server push we need to weigh in control

00:22:55,600 --> 00:23:00,400
these streams we need sophisticated

00:22:57,460 --> 00:23:02,290
server implementations and we need tools

00:23:00,400 --> 00:23:05,020
that feed these servers with relative

00:23:02,290 --> 00:23:07,690
information about our web app and of

00:23:05,020 --> 00:23:11,680
course we need careful and hopefully our

00:23:07,690 --> 00:23:15,610
automated testing to check if the

00:23:11,680 --> 00:23:17,800
performance is still good and went up we

00:23:15,610 --> 00:23:20,530
should stick to all that best practices

00:23:17,800 --> 00:23:25,120
where appropriate so we should not throw

00:23:20,530 --> 00:23:28,420
all the way well that components change

00:23:25,120 --> 00:23:30,490
the way work yes they provide new dawn

00:23:28,420 --> 00:23:31,990
parameters for future frameworks they

00:23:30,490 --> 00:23:33,640
make the platform itself more

00:23:31,990 --> 00:23:36,520
customizable and I think that's a good

00:23:33,640 --> 00:23:40,510
idea to explain the internals of the

00:23:36,520 --> 00:23:44,320
browser true to ask developers and that

00:23:40,510 --> 00:23:45,820
we can extend the browser but I think

00:23:44,320 --> 00:23:48,190
they don't provide choose to actually

00:23:45,820 --> 00:23:51,390
compose a more complex web app so we

00:23:48,190 --> 00:23:54,250
probably still will be using frameworks

00:23:51,390 --> 00:23:55,900
they don't provide ways to deliver these

00:23:54,250 --> 00:23:58,930
compliments companies efficiently

00:23:55,900 --> 00:24:01,450
especially with HTML imports I don't

00:23:58,930 --> 00:24:03,940
know and I think they can also make the

00:24:01,450 --> 00:24:09,340
platform or fragile because there's no

00:24:03,940 --> 00:24:11,020
path for progressive enhancement so how

00:24:09,340 --> 00:24:13,650
will front and develop and look like in

00:24:11,020 --> 00:24:18,040
the next year's and this is of course a

00:24:13,650 --> 00:24:19,960
biased view my biased view and you may

00:24:18,040 --> 00:24:23,200
have a different opinion on that so you

00:24:19,960 --> 00:24:26,620
can come to me and talk after the talk

00:24:23,200 --> 00:24:30,040
and we can discuss about that I think we

00:24:26,620 --> 00:24:33,430
will use tools like Babel post CSS and

00:24:30,040 --> 00:24:38,440
and that expose hackable abstract syntax

00:24:33,430 --> 00:24:41,890
trees and that provides plugins and

00:24:38,440 --> 00:24:45,900
presets for instance Babel and Eastland

00:24:41,890 --> 00:24:51,100
have have and posters as they have a

00:24:45,900 --> 00:24:52,750
common way to extend the features so

00:24:51,100 --> 00:24:54,790
Babel for instance if you don't apply

00:24:52,750 --> 00:24:59,280
any plugins it will do nothing on the

00:24:54,790 --> 00:24:59,280
source code you have to apply plugins I

00:24:59,370 --> 00:25:04,900
think we will be using languages with

00:25:02,200 --> 00:25:08,320
explicit exports and imports that avoid

00:25:04,900 --> 00:25:10,600
name space in collisions we had them too

00:25:08,320 --> 00:25:13,090
long and I think we want to get rid of

00:25:10,600 --> 00:25:17,380
them and year's 2015 models are a great

00:25:13,090 --> 00:25:21,400
way to do that and languages that allow

00:25:17,380 --> 00:25:23,530
static analysis that our truths can

00:25:21,400 --> 00:25:29,080
understand our source code and optimize

00:25:23,530 --> 00:25:31,690
it for us I think we will be using

00:25:29,080 --> 00:25:34,710
languages like chase X that embed other

00:25:31,690 --> 00:25:38,620
languages into is 2050 modules because

00:25:34,710 --> 00:25:41,770
then we get things like tree shaking for

00:25:38,620 --> 00:25:45,220
free and we really use bundlers that

00:25:41,770 --> 00:25:51,450
compose is 2015 modules and tree shake

00:25:45,220 --> 00:25:55,420
and use parts and now we have these

00:25:51,450 --> 00:25:59,590
syntax and these languages that can be

00:25:55,420 --> 00:26:02,080
analyzed statically we can create rules

00:25:59,590 --> 00:26:05,020
that analyze the critical rendering path

00:26:02,080 --> 00:26:10,330
and optimized for it so we don't have to

00:26:05,020 --> 00:26:14,620
do that by hand and optimized for the

00:26:10,330 --> 00:26:17,070
first meaningful paint and I think that

00:26:14,620 --> 00:26:21,310
a universal javascript is a good idea

00:26:17,070 --> 00:26:22,900
where we can always fall back so even if

00:26:21,310 --> 00:26:24,820
the client does not have enabled

00:26:22,900 --> 00:26:27,640
JavaScript or if something goes wrong

00:26:24,820 --> 00:26:29,140
the site will still be usable so I

00:26:27,640 --> 00:26:33,510
really think that server side rendering

00:26:29,140 --> 00:26:37,200
as a fallback strategy is a good idea so

00:26:33,510 --> 00:26:39,680
let's go and build these new things

00:26:37,200 --> 00:26:41,740
thank you

00:26:39,680 --> 00:26:41,740

YouTube URL: https://www.youtube.com/watch?v=VYjBp4z4XjY


