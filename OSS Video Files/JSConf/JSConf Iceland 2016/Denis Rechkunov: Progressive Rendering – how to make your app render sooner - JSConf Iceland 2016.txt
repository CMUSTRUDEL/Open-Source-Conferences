Title: Denis Rechkunov: Progressive Rendering â€“ how to make your app render sooner - JSConf Iceland 2016
Publication date: 2016-09-20
Playlist: JSConf Iceland 2016
Description: 
	Time To First Byte (TTFB) is a measurement used for the responsiveness of a web-server. TTFB measures the duration from the user or client making an HTTP request to the first byte of the page being received by the client's browser.

This value has a high impact on the perceived performance of your web application. This makes TTFB an important metric as it directly correlates with your customers happiness and willingness to stay and interact with your application, especially if your app needs much time to request data for building a page.

I'll talk about Node.js streams, the progressive rendering approach and how we can use them to make our web-app look blazing fast.
Captions: 
	00:00:12,190 --> 00:00:17,000
hi everyone thank you for having me here

00:00:15,260 --> 00:00:19,130
today and today we will be talking about

00:00:17,000 --> 00:00:23,119
progressive rendering and how to make

00:00:19,130 --> 00:00:25,700
your apps render sooner and first let me

00:00:23,119 --> 00:00:28,220
introduce myself a little bit and maybe

00:00:25,700 --> 00:00:31,100
you find some interesting facts from

00:00:28,220 --> 00:00:33,170
here I worked as a dot net developer for

00:00:31,100 --> 00:00:36,620
three years sorry for that I was blind

00:00:33,170 --> 00:00:39,590
and then I fell in love with no jazz

00:00:36,620 --> 00:00:42,769
because of its wonderful not blocking I

00:00:39,590 --> 00:00:45,110
oh I really fell off that especially

00:00:42,769 --> 00:00:48,370
from after the talk by Brian Dolph who's

00:00:45,110 --> 00:00:51,680
a creator of node and then I worked as a

00:00:48,370 --> 00:00:55,070
lead developer at flump which is like

00:00:51,680 --> 00:01:00,500
really popular service in Russia kind of

00:00:55,070 --> 00:01:02,330
like Yelp here and as you might guess I

00:01:00,500 --> 00:01:04,850
work as a JavaScript developer already

00:01:02,330 --> 00:01:08,000
and now I leave in Berlin and work for

00:01:04,850 --> 00:01:10,659
Amazon building UI components for amazon

00:01:08,000 --> 00:01:13,490
web services along with my great team

00:01:10,659 --> 00:01:15,380
Michael colleagues and you can find me

00:01:13,490 --> 00:01:17,570
online by these handle which is

00:01:15,380 --> 00:01:22,570
pragmatic on Twitter github medium and

00:01:17,570 --> 00:01:25,520
maybe something else give it a try and

00:01:22,570 --> 00:01:28,789
we are going to talk about server-side

00:01:25,520 --> 00:01:30,439
rendering and I think it's very

00:01:28,789 --> 00:01:32,990
important to have service side rendering

00:01:30,439 --> 00:01:36,859
today even if you have single page

00:01:32,990 --> 00:01:39,679
applications mostly on on the Internet

00:01:36,859 --> 00:01:44,270
we need sometimes we need server side

00:01:39,679 --> 00:01:47,439
rendering 404 crawlers or maybe other

00:01:44,270 --> 00:01:49,899
reasons and there is a good point how to

00:01:47,439 --> 00:01:56,539
improve this server side rendering and

00:01:49,899 --> 00:02:01,039
make it more film faster for our users

00:01:56,539 --> 00:02:03,530
and for this we would talk about typical

00:02:01,039 --> 00:02:05,030
server-side rendering today all

00:02:03,530 --> 00:02:07,490
developers implement around the world

00:02:05,030 --> 00:02:10,039
and why it's not that good for user

00:02:07,490 --> 00:02:12,890
experience and how can we make it better

00:02:10,039 --> 00:02:17,270
and let's start with a server-side

00:02:12,890 --> 00:02:19,190
rendering in general like how typically

00:02:17,270 --> 00:02:22,760
people implement server-side rendering

00:02:19,190 --> 00:02:24,680
nowadays so usually use expert

00:02:22,760 --> 00:02:28,040
is or connect or something like that and

00:02:24,680 --> 00:02:30,700
just implement middleware for that and

00:02:28,040 --> 00:02:33,709
it's basically a function that takes

00:02:30,700 --> 00:02:36,129
HTTP requests HTTP response and

00:02:33,709 --> 00:02:38,780
something like next call back if we

00:02:36,129 --> 00:02:43,129
don't want to serve a page and just pass

00:02:38,780 --> 00:02:45,890
the control to another middleware and in

00:02:43,129 --> 00:02:50,359
this case we just parse some parameters

00:02:45,890 --> 00:02:53,659
from URL then we just query some data

00:02:50,359 --> 00:02:56,629
from the database or maybe a restful api

00:02:53,659 --> 00:02:58,700
from somewhere doesn't matter then we

00:02:56,629 --> 00:03:05,590
render template for this data and then

00:02:58,700 --> 00:03:09,920
just end HTTP response with HTML so um

00:03:05,590 --> 00:03:15,859
who has ever implemented rendering like

00:03:09,920 --> 00:03:18,459
this raise your hands yeah and you might

00:03:15,859 --> 00:03:22,099
be wondering what's wrong with that and

00:03:18,459 --> 00:03:25,370
actually there are some things they that

00:03:22,099 --> 00:03:28,940
are on so if you have dynamic HTML

00:03:25,370 --> 00:03:32,419
document dynamic page we need to render

00:03:28,940 --> 00:03:36,620
the whole page in suburbs memory in a

00:03:32,419 --> 00:03:38,889
buffer and of course to generate this

00:03:36,620 --> 00:03:42,410
page and to render template we need to

00:03:38,889 --> 00:03:44,859
go to the database for data or maybe to

00:03:42,410 --> 00:03:48,199
restful api just somewhere and

00:03:44,859 --> 00:03:50,510
potentially it's a very slow operation

00:03:48,199 --> 00:03:54,260
it might last for half a second maybe

00:03:50,510 --> 00:03:56,090
more it depends and therefore it's kind

00:03:54,260 --> 00:03:58,549
of risky because it depends on your load

00:03:56,090 --> 00:04:00,139
on your network and the instant

00:03:58,549 --> 00:04:04,310
infrastructure you had where a lot of

00:04:00,139 --> 00:04:07,459
the facts of factors can influence um

00:04:04,310 --> 00:04:11,780
that and let's imagine that we have up

00:04:07,459 --> 00:04:15,530
to 10 requests for data and each of them

00:04:11,780 --> 00:04:19,070
depends on a previous one in this

00:04:15,530 --> 00:04:23,599
worst-case your users would not see

00:04:19,070 --> 00:04:26,300
anything for five seconds and that's

00:04:23,599 --> 00:04:29,720
really scary and let's ask our users

00:04:26,300 --> 00:04:33,190
what do they think about that so some of

00:04:29,720 --> 00:04:36,110
them I just said and they are crying

00:04:33,190 --> 00:04:42,110
seeing how our appt renders

00:04:36,110 --> 00:04:44,870
but they wait but some of them are very

00:04:42,110 --> 00:04:46,640
angry and might be even want to find us

00:04:44,870 --> 00:04:51,530
it kill us because we implemented this

00:04:46,640 --> 00:04:54,440
up and some of our users are also

00:04:51,530 --> 00:04:57,200
developers and might be they know that

00:04:54,440 --> 00:05:02,980
progressive rendering exists and they

00:04:57,200 --> 00:05:08,140
are just saying that our app is crap and

00:05:02,980 --> 00:05:10,820
how can we fix this how can we make our

00:05:08,140 --> 00:05:14,300
application render sooner despite these

00:05:10,820 --> 00:05:18,740
reasons we have liked for requesting

00:05:14,300 --> 00:05:21,620
data and maybe other air conditions we

00:05:18,740 --> 00:05:24,740
have in our app instead of sending em

00:05:21,620 --> 00:05:28,700
the whole HTML buffer at once like

00:05:24,740 --> 00:05:33,020
previous code does we can use a simple

00:05:28,700 --> 00:05:36,110
idea instead of trying to serve this

00:05:33,020 --> 00:05:39,770
very heavy and slow page like lifting up

00:05:36,110 --> 00:05:44,870
is the stadium we can just split this

00:05:39,770 --> 00:05:49,810
page and small pieces in chunks and send

00:05:44,870 --> 00:05:52,490
this HTML page as multiple chunks and

00:05:49,810 --> 00:05:57,830
obviously it looks more powerful right

00:05:52,490 --> 00:06:04,700
and easy so and this approach would be

00:05:57,830 --> 00:06:07,880
progressive rendering this animation is

00:06:04,700 --> 00:06:10,760
trying to explain how that works so on

00:06:07,880 --> 00:06:13,430
the left side you have typical rendering

00:06:10,760 --> 00:06:15,650
implementation which goes for data

00:06:13,430 --> 00:06:18,680
building the page in memory and then

00:06:15,650 --> 00:06:21,890
just gives the whole page service from

00:06:18,680 --> 00:06:24,980
the server in browser and until this

00:06:21,890 --> 00:06:28,400
moment nobody sees anything I mean our

00:06:24,980 --> 00:06:31,610
users of course and on the right the app

00:06:28,400 --> 00:06:35,540
uses progressive rendering which means

00:06:31,610 --> 00:06:39,100
it has last time to first byte and you

00:06:35,540 --> 00:06:44,260
have something as soon as your first

00:06:39,100 --> 00:06:46,850
portion of data is radiant server and

00:06:44,260 --> 00:06:49,280
this is really tricky because from the

00:06:46,850 --> 00:06:51,440
performance point of view I mean from

00:06:49,280 --> 00:06:55,010
amber's point of view it's kind of maybe

00:06:51,440 --> 00:06:58,540
even slower but from the perception

00:06:55,010 --> 00:07:01,700
point of view our users they see that

00:06:58,540 --> 00:07:04,400
our app works for them and does

00:07:01,700 --> 00:07:06,950
something for them and this perception

00:07:04,400 --> 00:07:09,410
is much better than seeing nothing for

00:07:06,950 --> 00:07:14,410
five seconds even though maybe it's

00:07:09,410 --> 00:07:17,930
technically a little bit slower and

00:07:14,410 --> 00:07:21,800
there was a talk at last jest Cairo in

00:07:17,930 --> 00:07:23,240
Berlin where I unfortunately I can't

00:07:21,800 --> 00:07:25,400
remember the name but it was a talk

00:07:23,240 --> 00:07:28,580
about perception of performance and that

00:07:25,400 --> 00:07:32,960
was a very similar idea that perception

00:07:28,580 --> 00:07:35,150
says us that we need to do something as

00:07:32,960 --> 00:07:37,400
soon as possible to show that our app

00:07:35,150 --> 00:07:41,540
works for our user that we appreciate

00:07:37,400 --> 00:07:46,250
that our user uses are up and this

00:07:41,540 --> 00:07:48,020
exactly the point so you might be

00:07:46,250 --> 00:07:49,790
wondering never heard of it never heard

00:07:48,020 --> 00:07:52,310
of progressive rendering is it new or

00:07:49,790 --> 00:07:57,020
like something train seeing which

00:07:52,310 --> 00:08:02,000
invented recently actually now if we go

00:07:57,020 --> 00:08:07,340
back in the history in 1997 HTTP 1.1 was

00:08:02,000 --> 00:08:10,220
introduced as RFC and the most important

00:08:07,340 --> 00:08:13,760
part in this for us is a Chunkin

00:08:10,220 --> 00:08:16,280
encoding and basically what it says that

00:08:13,760 --> 00:08:19,039
instead of serving the whole page the

00:08:16,280 --> 00:08:22,220
whole buffer to a server you can split

00:08:19,039 --> 00:08:25,330
it in several buffers and serve it

00:08:22,220 --> 00:08:28,160
specifying length for each of them and

00:08:25,330 --> 00:08:30,050
this is kind of a concept concept of

00:08:28,160 --> 00:08:33,320
streaming if you are familiar with

00:08:30,050 --> 00:08:36,520
Iraq's jazz observable or not jet

00:08:33,320 --> 00:08:42,760
streams it's exactly the thing with

00:08:36,520 --> 00:08:45,200
serving page in chunks and the first

00:08:42,760 --> 00:08:47,450
mentioning of progressive rendering I

00:08:45,200 --> 00:08:50,750
managed to find on the Internet is this

00:08:47,450 --> 00:08:53,450
blog post by Jeff Atwood but let's call

00:08:50,750 --> 00:08:56,660
the lost art of progressive HTML

00:08:53,450 --> 00:08:59,810
rendering and it has two very

00:08:56,660 --> 00:09:01,459
interesting points the first one is one

00:08:59,810 --> 00:09:03,980
thing I dislike about a

00:09:01,459 --> 00:09:06,740
dotnet is that it renders the entire web

00:09:03,980 --> 00:09:09,589
page in memory before sending one single

00:09:06,740 --> 00:09:13,309
bite of the page to the browser I am

00:09:09,589 --> 00:09:17,119
totally agree with it and the second one

00:09:13,309 --> 00:09:18,529
is what's even more galling is that HTML

00:09:17,119 --> 00:09:21,230
was originally designed to render

00:09:18,529 --> 00:09:24,980
progressively as content is received

00:09:21,230 --> 00:09:27,980
what it means it means that even first

00:09:24,980 --> 00:09:32,360
versions of the first browser in the

00:09:27,980 --> 00:09:34,610
world Netscape they had support for

00:09:32,360 --> 00:09:37,309
progressive rendering even in first

00:09:34,610 --> 00:09:41,499
early beta releases that means that

00:09:37,309 --> 00:09:44,769
browser goes through iterations

00:09:41,499 --> 00:09:50,920
rendering the HTML in browser that means

00:09:44,769 --> 00:09:54,439
if you have what partially piece of HTML

00:09:50,920 --> 00:09:57,529
that come to you from the server you can

00:09:54,439 --> 00:10:00,230
start parsing recognized resources like

00:09:57,529 --> 00:10:03,290
screeds images styles and start load-in

00:10:00,230 --> 00:10:06,110
them and in this case it works more

00:10:03,290 --> 00:10:09,470
efficient because browser goes for for

00:10:06,110 --> 00:10:15,799
resources in parallel while your whole

00:10:09,470 --> 00:10:17,679
page is not ready yet so if you added

00:10:15,799 --> 00:10:21,199
the previous code I showed you before

00:10:17,679 --> 00:10:27,139
which looks like this which just ends

00:10:21,199 --> 00:10:31,399
HTTP response with a vendor template we

00:10:27,139 --> 00:10:33,529
can go further and using a little bit

00:10:31,399 --> 00:10:37,339
more logic and maybe more complex

00:10:33,529 --> 00:10:40,429
approach we can reach progressive

00:10:37,339 --> 00:10:44,540
rendering without any additional tool we

00:10:40,429 --> 00:10:47,209
just need to go for data just split our

00:10:44,540 --> 00:10:50,990
data in small pieces and go for it in

00:10:47,209 --> 00:10:54,410
steps like if we need data for a header

00:10:50,990 --> 00:10:56,600
we go for just data for the header and

00:10:54,410 --> 00:10:58,449
then render this team played for the

00:10:56,600 --> 00:11:01,490
header and then serve the cutter and

00:10:58,449 --> 00:11:05,540
this is perfectly done by right function

00:11:01,490 --> 00:11:08,600
in response in HTTP response stream as

00:11:05,540 --> 00:11:10,579
you can see here and then we go for

00:11:08,600 --> 00:11:13,009
another blog another blog and do the

00:11:10,579 --> 00:11:13,590
same operation for every blog on the

00:11:13,009 --> 00:11:16,550
page

00:11:13,590 --> 00:11:20,460
yeah I totally agree that this coat

00:11:16,550 --> 00:11:23,610
looks really difficult and more

00:11:20,460 --> 00:11:28,710
difficult even to split your every page

00:11:23,610 --> 00:11:31,890
in such pieces and then serve it but at

00:11:28,710 --> 00:11:36,780
the end we can use wonderful not GS

00:11:31,890 --> 00:11:42,060
streams and the previous code would like

00:11:36,780 --> 00:11:48,060
like this would look like this so it's

00:11:42,060 --> 00:11:50,790
just we create our own stream with the

00:11:48,060 --> 00:11:53,250
parameters we got from the URL and then

00:11:50,790 --> 00:11:57,920
just pipe this dream through the HTTP

00:11:53,250 --> 00:12:00,780
response stream and that's it but the

00:11:57,920 --> 00:12:02,580
you might be wondering my response my

00:12:00,780 --> 00:12:05,910
breed of all stream how to implement

00:12:02,580 --> 00:12:08,850
that for those who is not familiar with

00:12:05,910 --> 00:12:12,690
not jet streams API it's quite simple as

00:12:08,850 --> 00:12:15,600
that you just extend some built-in class

00:12:12,690 --> 00:12:17,820
in node you just implement read function

00:12:15,600 --> 00:12:21,870
which allows you to push chunks of data

00:12:17,820 --> 00:12:24,690
through the stream and that's of course

00:12:21,870 --> 00:12:28,530
a synchronous and you can push whenever

00:12:24,690 --> 00:12:30,990
you want and then when you stop pushing

00:12:28,530 --> 00:12:35,640
and like the whole page is served you

00:12:30,990 --> 00:12:37,830
just push now as a data this is how real

00:12:35,640 --> 00:12:43,520
all streams work in not jazz without any

00:12:37,830 --> 00:12:47,310
additional libraries just built in so

00:12:43,520 --> 00:12:49,320
why progressive rendering is better so

00:12:47,310 --> 00:12:53,340
the first thing I already mentioned is

00:12:49,320 --> 00:12:55,830
less time to first byte for some

00:12:53,340 --> 00:13:02,220
projects it's really an important

00:12:55,830 --> 00:13:04,980
metrics used by teams by performance

00:13:02,220 --> 00:13:07,620
engineers and other stuff in the company

00:13:04,980 --> 00:13:11,220
and also it's very important for our

00:13:07,620 --> 00:13:14,400
user experience because users should see

00:13:11,220 --> 00:13:19,650
our app as soon as possible even though

00:13:14,400 --> 00:13:21,390
it's not completely ready maybe but we

00:13:19,650 --> 00:13:23,690
need to show something that we work for

00:13:21,390 --> 00:13:23,690
our user

00:13:24,710 --> 00:13:30,170
the second thing is browser works more

00:13:28,340 --> 00:13:32,480
efficiently loading resources in

00:13:30,170 --> 00:13:36,950
parallel and I will show you a

00:13:32,480 --> 00:13:39,020
screenshot in a second how that works it

00:13:36,950 --> 00:13:42,500
aligns with architecture based on

00:13:39,020 --> 00:13:45,770
microservices very well because of the

00:13:42,500 --> 00:13:49,700
main idea to split your data in small

00:13:45,770 --> 00:13:53,540
pieces and serve them in blocks of your

00:13:49,700 --> 00:13:55,880
page it's perfectly fine to have a set

00:13:53,540 --> 00:13:58,100
of micro services which you can use

00:13:55,880 --> 00:14:03,200
separately and every micro service is

00:13:58,100 --> 00:14:05,300
just serves data of scope not going like

00:14:03,200 --> 00:14:09,890
using other micro services you can use

00:14:05,300 --> 00:14:12,620
them directly to build a page and even

00:14:09,890 --> 00:14:16,490
though your API I mean restful api or

00:14:12,620 --> 00:14:19,130
database is very very slow a user is

00:14:16,490 --> 00:14:22,670
thinking that you're up in general is

00:14:19,130 --> 00:14:24,410
really fast it's just technology this is

00:14:22,670 --> 00:14:28,730
how it works how the perception of

00:14:24,410 --> 00:14:30,770
performance works and this approach is

00:14:28,730 --> 00:14:33,710
more scalable than buffering the whole

00:14:30,770 --> 00:14:35,750
page why is that because if you add a

00:14:33,710 --> 00:14:38,210
new block on your page like at the

00:14:35,750 --> 00:14:40,880
bottom with some data if you have a

00:14:38,210 --> 00:14:44,030
buffering approach your up would be

00:14:40,880 --> 00:14:46,040
rendering slower but if you have

00:14:44,030 --> 00:14:48,380
progress if rendering time to first by

00:14:46,040 --> 00:14:50,480
it would be the same even though you add

00:14:48,380 --> 00:14:53,420
something on the bottom or maybe on the

00:14:50,480 --> 00:14:55,360
right of new page the first part of the

00:14:53,420 --> 00:14:59,750
page would be delivered at the same time

00:14:55,360 --> 00:15:02,300
which is very important and this is the

00:14:59,750 --> 00:15:05,540
picture I promised to show this is a

00:15:02,300 --> 00:15:08,960
screenshot of a real project built using

00:15:05,540 --> 00:15:11,690
progressive rendering and for some

00:15:08,960 --> 00:15:14,990
reasons the API of this project doesn't

00:15:11,690 --> 00:15:17,060
serve data very fast and you can see

00:15:14,990 --> 00:15:20,660
that the whole process of rendering

00:15:17,060 --> 00:15:23,960
takes about three and a half seconds but

00:15:20,660 --> 00:15:28,490
the first byte the first part of the

00:15:23,960 --> 00:15:31,340
page was delivered in 327 milliseconds

00:15:28,490 --> 00:15:33,740
which is pretty good like our users

00:15:31,340 --> 00:15:36,950
didn't even notice that this app is very

00:15:33,740 --> 00:15:38,030
slow and which is more important you can

00:15:36,950 --> 00:15:41,210
see that

00:15:38,030 --> 00:15:43,580
in parallel browser started involved in

00:15:41,210 --> 00:15:46,730
other stuff like images scraped styles

00:15:43,580 --> 00:15:49,880
and every browser has this limitation

00:15:46,730 --> 00:15:52,460
how many HTTP requests that can do in

00:15:49,880 --> 00:15:55,460
this at the same time and in this case

00:15:52,460 --> 00:15:57,820
you can see that it's about four HTTP

00:15:55,460 --> 00:16:01,460
requests in this tab of a browser

00:15:57,820 --> 00:16:04,070
therefore like it blow loads resources

00:16:01,460 --> 00:16:06,560
like all these three sources in parallel

00:16:04,070 --> 00:16:15,380
then go goes for another three sources

00:16:06,560 --> 00:16:17,930
and exactly so but however as all things

00:16:15,380 --> 00:16:22,370
in real world it's not perfect and it

00:16:17,930 --> 00:16:27,310
has problems that can stop you from

00:16:22,370 --> 00:16:33,470
using it this how HTTP protocol works

00:16:27,310 --> 00:16:35,510
before we have to specify HTTP status

00:16:33,470 --> 00:16:37,690
code and always TP headers we need to

00:16:35,510 --> 00:16:41,030
set before sending the first by

00:16:37,690 --> 00:16:44,600
otherwise now JCP I just would ignore

00:16:41,030 --> 00:16:46,910
all things you said after and even

00:16:44,600 --> 00:16:52,310
doesn't throw an error or something we

00:16:46,910 --> 00:16:54,740
just downside a cookie but you wouldn't

00:16:52,310 --> 00:16:58,430
even notice that and you should keep in

00:16:54,740 --> 00:17:01,700
mind that so that means that cookies

00:16:58,430 --> 00:17:03,670
Redlegs not found statuses and stuff

00:17:01,700 --> 00:17:06,290
like that you need to serve before

00:17:03,670 --> 00:17:09,830
sending the first part of the page and

00:17:06,290 --> 00:17:13,040
that means that you have to request the

00:17:09,830 --> 00:17:16,160
main entity of your page first like if

00:17:13,040 --> 00:17:19,400
you have online shop or something like

00:17:16,160 --> 00:17:21,920
that you need to request the item of the

00:17:19,400 --> 00:17:26,110
like of the shop on the market place

00:17:21,920 --> 00:17:29,750
first and decide if the page status is

00:17:26,110 --> 00:17:33,290
404 not found or maybe you need to set

00:17:29,750 --> 00:17:35,330
some cookie but you would do it anyway

00:17:33,290 --> 00:17:38,810
because you need meta tags and other

00:17:35,330 --> 00:17:43,760
things in header which include this item

00:17:38,810 --> 00:17:46,380
description and other stuff so in

00:17:43,760 --> 00:17:49,830
practice it's not a huge deal

00:17:46,380 --> 00:17:52,620
and user isn't able to interact with a

00:17:49,830 --> 00:17:54,990
page till it's fully loaded I'm not

00:17:52,620 --> 00:17:59,090
saying like the full interaction but if

00:17:54,990 --> 00:18:01,920
you have JavaScript event handlers or

00:17:59,090 --> 00:18:05,850
something related to JavaScript you

00:18:01,920 --> 00:18:09,360
would probably need to wait for Adam

00:18:05,850 --> 00:18:11,910
ready event and only then subscribe and

00:18:09,360 --> 00:18:15,180
events and other things related to

00:18:11,910 --> 00:18:18,360
JavaScript logic and that means that

00:18:15,180 --> 00:18:21,270
your user would be able to click links

00:18:18,360 --> 00:18:23,490
and to open those links on the page and

00:18:21,270 --> 00:18:26,730
maybe submit forms all native HTML

00:18:23,490 --> 00:18:30,390
experience works till the whole page is

00:18:26,730 --> 00:18:33,120
loading and it's not ready yet but if

00:18:30,390 --> 00:18:35,940
you have some JavaScript that attached

00:18:33,120 --> 00:18:39,660
to an HTML and does something it does it

00:18:35,940 --> 00:18:44,280
after dumb radiate end and I've found

00:18:39,660 --> 00:18:46,680
some libraries that are still under

00:18:44,280 --> 00:18:51,390
development but they make it part make

00:18:46,680 --> 00:18:54,120
it possible to have this attachment to

00:18:51,390 --> 00:19:00,210
Evans even before the dominant don't

00:18:54,120 --> 00:19:05,340
read even I mean but it still up to you

00:19:00,210 --> 00:19:07,680
to decide to use them or not and maybe

00:19:05,340 --> 00:19:10,350
for someone it would be a decent

00:19:07,680 --> 00:19:12,420
villages disadvantage as well but you

00:19:10,350 --> 00:19:15,500
have to split your page the page data

00:19:12,420 --> 00:19:20,160
into small pieces or microservices and

00:19:15,500 --> 00:19:23,400
not I noticed that not everyone wants

00:19:20,160 --> 00:19:25,680
that and not everyone likes that but to

00:19:23,400 --> 00:19:29,190
have progress a friend when you need to

00:19:25,680 --> 00:19:32,490
split your huge data request you have in

00:19:29,190 --> 00:19:38,660
small pieces which would serve the page

00:19:32,490 --> 00:19:41,310
like step by step chunk by chunk and

00:19:38,660 --> 00:19:43,830
what about clients I'd rather you might

00:19:41,310 --> 00:19:45,780
be wondering why I'm saying all the

00:19:43,830 --> 00:19:49,620
things about server-side rendering and

00:19:45,780 --> 00:19:52,710
say nothing about client signed that's

00:19:49,620 --> 00:19:55,590
because actually it's very simple and

00:19:52,710 --> 00:19:57,690
it's already used by many people in

00:19:55,590 --> 00:19:59,600
single page applications like using

00:19:57,690 --> 00:20:03,270
react library or

00:19:59,600 --> 00:20:05,840
stuff like that and it's simple as just

00:20:03,270 --> 00:20:08,670
split your data into small queries

00:20:05,840 --> 00:20:13,080
render as soon as you've got its data

00:20:08,670 --> 00:20:16,020
and try to make your interface not jumpy

00:20:13,080 --> 00:20:18,780
using placeholders because it scans

00:20:16,020 --> 00:20:21,420
constantly moving by a login and you

00:20:18,780 --> 00:20:23,790
need to reserve the place for the

00:20:21,420 --> 00:20:25,980
content like for instance Facebook does

00:20:23,790 --> 00:20:28,920
Facebook actually uses progressive

00:20:25,980 --> 00:20:32,970
rendering a client signed it and you can

00:20:28,920 --> 00:20:36,480
see this like placeholders and your feet

00:20:32,970 --> 00:20:39,320
on the right instead of like friends

00:20:36,480 --> 00:20:44,670
suggestion or whatever is there and

00:20:39,320 --> 00:20:48,260
before all data was loaded you can see

00:20:44,670 --> 00:20:48,260
those clicks placeholders on the screen

00:20:48,620 --> 00:20:56,850
and another question you might be

00:20:53,790 --> 00:20:58,560
wondering is like is there a library of

00:20:56,850 --> 00:21:00,960
framework which make it makes it

00:20:58,560 --> 00:21:04,050
possible we don't want to read like a

00:21:00,960 --> 00:21:08,250
lot of dogs and write this stream I

00:21:04,050 --> 00:21:12,360
showed before and of course there are a

00:21:08,250 --> 00:21:17,640
lot of ready solutions for that so I've

00:21:12,360 --> 00:21:19,710
seen that some enthusiasts makes work on

00:21:17,640 --> 00:21:23,280
the rag downstream which is the library

00:21:19,710 --> 00:21:26,780
that makes it possible to render virtual

00:21:23,280 --> 00:21:30,090
Dom on server like a stream in chunks

00:21:26,780 --> 00:21:33,720
but I'm not sure about the lips is there

00:21:30,090 --> 00:21:36,030
is library stable or is there any

00:21:33,720 --> 00:21:38,970
problem with that I i would recommend to

00:21:36,030 --> 00:21:44,700
check it out on your own and see if it

00:21:38,970 --> 00:21:48,330
works also if you know the Zoolander

00:21:44,700 --> 00:21:50,640
fashion online shop they use a project

00:21:48,330 --> 00:21:54,750
called Taylor and what it basically does

00:21:50,640 --> 00:21:57,930
just gathers HTML pieces from a set of

00:21:54,750 --> 00:22:01,020
micro services every team develops like

00:21:57,930 --> 00:22:03,750
a piece of HTML on the page and then

00:22:01,020 --> 00:22:07,430
Taylor just gathers everything in one

00:22:03,750 --> 00:22:12,240
piece and serves a page also there is a

00:22:07,430 --> 00:22:13,030
click quite old team plant engine which

00:22:12,240 --> 00:22:16,870
is does Jay

00:22:13,030 --> 00:22:20,670
and it's forth by linkedin and what they

00:22:16,870 --> 00:22:23,920
do is you can specify a function as a

00:22:20,670 --> 00:22:26,500
property of data object when you render

00:22:23,920 --> 00:22:29,320
your team played and when template

00:22:26,500 --> 00:22:32,050
renders like this function it allows you

00:22:29,320 --> 00:22:35,350
to go as synchronous and like request

00:22:32,050 --> 00:22:38,760
any data and the stream would be post

00:22:35,350 --> 00:22:43,540
till the moment your cut this data and

00:22:38,760 --> 00:22:45,880
return is a call back also there is a

00:22:43,540 --> 00:22:49,540
template engine called Marco or mark of

00:22:45,880 --> 00:22:52,150
idiots it does pretty similar thing it

00:22:49,540 --> 00:22:54,070
works as progressive rendering

00:22:52,150 --> 00:22:58,510
everywhere on client signed and on

00:22:54,070 --> 00:23:00,370
server also there's picking you template

00:22:58,510 --> 00:23:04,120
engine called talisman I've just read

00:23:00,370 --> 00:23:06,670
about this a month ago on medium and it

00:23:04,120 --> 00:23:08,590
looks really promising and also if you

00:23:06,670 --> 00:23:10,270
need not just a template engine but the

00:23:08,590 --> 00:23:14,230
whole framework for building your art

00:23:10,270 --> 00:23:17,860
based on this approach on progressive

00:23:14,230 --> 00:23:21,190
rendering you might want to use Cadbury

00:23:17,860 --> 00:23:24,160
jazz which is isomorphic framework based

00:23:21,190 --> 00:23:29,470
on web components ideology using

00:23:24,160 --> 00:23:33,940
progressive rendering let's summarize

00:23:29,470 --> 00:23:37,210
the talk if you have many data requests

00:23:33,940 --> 00:23:39,850
or a huge request you should plead in

00:23:37,210 --> 00:23:41,800
small pieces it means you need

00:23:39,850 --> 00:23:45,580
progressive rendering otherwise it would

00:23:41,800 --> 00:23:47,730
be not that good user experience the

00:23:45,580 --> 00:23:50,980
technology is basically very old and

00:23:47,730 --> 00:23:54,870
perfectly supported by browsers since

00:23:50,980 --> 00:23:59,080
the Netscape one point 0 therefore

00:23:54,870 --> 00:24:01,720
everyone can use that it's not that hard

00:23:59,080 --> 00:24:06,670
to implement and you can use not jet

00:24:01,720 --> 00:24:10,180
streams for that and even if you don't

00:24:06,670 --> 00:24:13,900
want to do that there are a lot of ready

00:24:10,180 --> 00:24:16,240
solutions but you have to keep in mind

00:24:13,900 --> 00:24:20,220
some disadvantages of that like setting

00:24:16,240 --> 00:24:22,630
HTTP status code or HTTP headers cookies

00:24:20,220 --> 00:24:24,820
redirects anything like that you have to

00:24:22,630 --> 00:24:28,080
do that before the first chunk of data

00:24:24,820 --> 00:24:28,080
is searched from the server

00:24:28,470 --> 00:24:35,110
there are some existing solutions I

00:24:31,110 --> 00:24:37,149
would really recommend them to check

00:24:35,110 --> 00:24:41,710
them out and to experiment with them

00:24:37,149 --> 00:24:44,620
maybe it's a good use case even not even

00:24:41,710 --> 00:24:47,500
but especially for your project and your

00:24:44,620 --> 00:24:51,899
company might be it would be better user

00:24:47,500 --> 00:24:55,570
experience for your users or customers

00:24:51,899 --> 00:24:57,820
but the point of the talk is don't make

00:24:55,570 --> 00:25:00,130
your users wait just make your apps

00:24:57,820 --> 00:25:06,149
render sooner and let them look like

00:25:00,130 --> 00:25:06,149

YouTube URL: https://www.youtube.com/watch?v=aRaQe9n1lPk


