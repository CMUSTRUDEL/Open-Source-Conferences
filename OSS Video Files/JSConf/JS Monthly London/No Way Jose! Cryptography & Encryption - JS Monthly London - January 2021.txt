Title: No Way Jose! Cryptography & Encryption - JS Monthly London - January 2021
Publication date: 2021-02-12
Playlist: JS Monthly London
Description: 
	Sam Bellen - No way Jose

Is your first thought when thinking about cryptography, “nope, that’s not for me!”? There’s no need to. When explained with simple examples, you can see the basics are not that complicated. The JavaScript Object Signing and Encryption, or JOSE for short is a framework that helps us deal with encryption. It describes ways to securely transfer data either signed (JWS) or encrypted (JWE). Let’s take a leap of faith and explore the wonderful world of cryptography together, shall we?

Chapters / Excerpts:
Introduction [00:00:00] 

About Sam [00:00:38

What is Hashing? [00:02:31]
A hashing algorithm is a mathematical algorithm that maps data of an arbitrary size to bit string of a fixed size, which basically means that no matter how big the input you give to this algorithm, the output will always be of the same size and that size is depending on the algorithm. 

Hashing Algorithm [00:03:11] It's a one way function.

Keyed Hashing [00:03:49

Keyed Hashing Algorithm [00:04:19] 

Secret Key [00:05:08]

Salted Key Hash [00:06:25] 

Signing and Digital Signatures [00:07:35] 

Cryptographic Non-Repudiation [00:09:06] 

Signing & Verifying Algorithm [00:10:12]

RSA Keys [00:11:35]

Elliptic Curve Keys [00:12:03] 

Edwards Curve Octet Keys [00:12:21] 

Encryption [00:12:44] 

Symmetric & Asymmetric Encryption [00:13:29] 

Generating Keys [00:16:24] 

Using a private key to decrypt [00:19:17

RSA Demo [00:20:47]

Jose [00:21:37]

JSON Web Keys [00:22:31] 

JSON Web Signature [00:23:32]

Jose Header [00:23:55] 

A JSON Web Token can be JWS or a JWE [00:29:34] 

Summary [00:30:25] 

Q&A [00:31:38] 

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,080 --> 00:00:03,919
thank you everybody for sticking around

00:00:02,159 --> 00:00:06,560
i know it's getting late but um

00:00:03,919 --> 00:00:07,839
i hope i can teach you a thing or two

00:00:06,560 --> 00:00:09,840
about encryption

00:00:07,839 --> 00:00:11,200
now this talk is called norway jose and

00:00:09,840 --> 00:00:13,040
you might be saying what does

00:00:11,200 --> 00:00:15,280
that have to do with encryption well

00:00:13,040 --> 00:00:17,680
jose is is a standard

00:00:15,280 --> 00:00:18,320
um which basically stands for djs and

00:00:17,680 --> 00:00:20,480
object

00:00:18,320 --> 00:00:21,840
signatures and or signing and encryption

00:00:20,480 --> 00:00:23,760
so it's a standard

00:00:21,840 --> 00:00:25,599
for using json with signatures and

00:00:23,760 --> 00:00:27,760
encrypted content um but before i can

00:00:25,599 --> 00:00:29,439
dive into the jose standard as it is

00:00:27,760 --> 00:00:31,119
you first have to see what signatures

00:00:29,439 --> 00:00:32,399
are and what encryption are so i'd like

00:00:31,119 --> 00:00:34,399
to start with a

00:00:32,399 --> 00:00:36,079
a little introduction to the basics of

00:00:34,399 --> 00:00:38,239
cryptography before we move on to the

00:00:36,079 --> 00:00:40,719
actual jose standard

00:00:38,239 --> 00:00:41,360
so let me quickly introduce myself my

00:00:40,719 --> 00:00:42,879
name is

00:00:41,360 --> 00:00:44,480
sam mellen i'm from belgium as

00:00:42,879 --> 00:00:45,920
introduced and i'm a developer advocate

00:00:44,480 --> 00:00:47,039
engineer at alt0

00:00:45,920 --> 00:00:48,640
if you don't know alzero we're an

00:00:47,039 --> 00:00:50,160
identity as a service provider which

00:00:48,640 --> 00:00:52,000
basically means that we try to make it

00:00:50,160 --> 00:00:54,000
as easy as possible for anybody

00:00:52,000 --> 00:00:55,520
to implement and a secure authentication

00:00:54,000 --> 00:00:57,520
flow so you can focus on building your

00:00:55,520 --> 00:00:59,680
actual applications instead of just

00:00:57,520 --> 00:01:01,600
worrying about your user uh user's

00:00:59,680 --> 00:01:02,160
identity or worrying about signing up

00:01:01,600 --> 00:01:04,080
and

00:01:02,160 --> 00:01:06,080
logging in users i'm also a google

00:01:04,080 --> 00:01:09,840
developer expert and you can find me all

00:01:06,080 --> 00:01:12,080
over the internet um as atsambigo

00:01:09,840 --> 00:01:13,680
i'm a am a web developer so it only

00:01:12,080 --> 00:01:15,360
makes sense to me that i would be npm

00:01:13,680 --> 00:01:16,720
installable so if you run mpx at some

00:01:15,360 --> 00:01:18,240
mega slash about me

00:01:16,720 --> 00:01:19,840
download half of the internet and wait a

00:01:18,240 --> 00:01:21,680
few seconds you'll find all the

00:01:19,840 --> 00:01:23,680
necessary links you need to contact me

00:01:21,680 --> 00:01:24,479
or to find my other presentations or

00:01:23,680 --> 00:01:26,880
this one

00:01:24,479 --> 00:01:28,479
on the internet so if you would like to

00:01:26,880 --> 00:01:30,439
follow along with my slides

00:01:28,479 --> 00:01:31,600
just like dwayne did you can just go to

00:01:30,439 --> 00:01:33,520
jose.sumbego.tech

00:01:31,600 --> 00:01:35,840
mine do not ultimately sync so you have

00:01:33,520 --> 00:01:37,680
to skip forward with your arrow keys

00:01:35,840 --> 00:01:39,439
but if you prefer the slides on your own

00:01:37,680 --> 00:01:42,399
screen you can go to the website

00:01:39,439 --> 00:01:44,000
and follow along there um so i have to

00:01:42,399 --> 00:01:46,240
start with a disclaimer

00:01:44,000 --> 00:01:47,680
and the thing is i might simplify

00:01:46,240 --> 00:01:48,960
certain things in order to try to

00:01:47,680 --> 00:01:50,799
explain them an easier way

00:01:48,960 --> 00:01:52,479
because once you start with cryptography

00:01:50,799 --> 00:01:54,079
it's very easy to go down the rabbit

00:01:52,479 --> 00:01:56,159
hole and get to very complicated

00:01:54,079 --> 00:01:57,759
matter very fast so i'm going to try to

00:01:56,159 --> 00:01:59,200
stick to the surface and maybe i

00:01:57,759 --> 00:02:02,799
simplify certain things

00:01:59,200 --> 00:02:04,640
just for the sake of explanation also

00:02:02,799 --> 00:02:06,159
don't reinvent the wheel use existing

00:02:04,640 --> 00:02:07,520
libraries and services when doing

00:02:06,159 --> 00:02:08,959
something with cryptography

00:02:07,520 --> 00:02:10,399
just because they haven't proven they

00:02:08,959 --> 00:02:11,520
have been researched by researchers or

00:02:10,399 --> 00:02:12,080
people who know actually what they're

00:02:11,520 --> 00:02:13,599
doing

00:02:12,080 --> 00:02:15,599
so if you have to do something with

00:02:13,599 --> 00:02:17,200
encryption or signatures or hashing

00:02:15,599 --> 00:02:19,360
use one of these existing libraries that

00:02:17,200 --> 00:02:21,280
have been proven to work

00:02:19,360 --> 00:02:23,520
okay a little summary we're going to be

00:02:21,280 --> 00:02:26,080
looking at hashing and key hashing

00:02:23,520 --> 00:02:27,200
signing encryption and lastly jose

00:02:26,080 --> 00:02:30,959
because the talk is called

00:02:27,200 --> 00:02:32,720
no way jose so what is hashing

00:02:30,959 --> 00:02:34,720
a hashing algorithm is a mathematical

00:02:32,720 --> 00:02:35,280
algorithm that maps data of an arbitrary

00:02:34,720 --> 00:02:37,360
size

00:02:35,280 --> 00:02:39,280
to bit string of a fixed size which

00:02:37,360 --> 00:02:41,360
basically means that no matter how big

00:02:39,280 --> 00:02:43,280
the input you give to this algorithm

00:02:41,360 --> 00:02:45,440
the output will always be of the same

00:02:43,280 --> 00:02:46,239
size and that size is depending on the

00:02:45,440 --> 00:02:49,280
algorithm

00:02:46,239 --> 00:02:51,280
um so if you input one word 10 words the

00:02:49,280 --> 00:02:54,879
whole book the output will always be

00:02:51,280 --> 00:02:56,640
of the same fixed size the initial data

00:02:54,879 --> 00:02:58,080
is often called the message

00:02:56,640 --> 00:02:59,760
and the outcome of the hashing function

00:02:58,080 --> 00:03:02,800
is called a hash or a message

00:02:59,760 --> 00:03:04,319
message digest and hashing is a one-way

00:03:02,800 --> 00:03:04,800
function which means that what you put

00:03:04,319 --> 00:03:06,480
in

00:03:04,800 --> 00:03:08,560
and what you get out cannot be reversed

00:03:06,480 --> 00:03:10,000
you cannot reverse a hash once it has

00:03:08,560 --> 00:03:10,560
been hashed you cannot get back to that

00:03:10,000 --> 00:03:13,200
original

00:03:10,560 --> 00:03:15,040
input it's a one-way function so if you

00:03:13,200 --> 00:03:17,440
look at a little diagram here on screen

00:03:15,040 --> 00:03:19,280
if you have three inputs dog doggo and a

00:03:17,440 --> 00:03:20,879
quick brown fox jumps over the lazy dog

00:03:19,280 --> 00:03:23,280
and we all run them to the same hashing

00:03:20,879 --> 00:03:24,959
algorithm we get three different outputs

00:03:23,280 --> 00:03:26,319
but we can see that these outputs are

00:03:24,959 --> 00:03:29,360
all of the same length

00:03:26,319 --> 00:03:30,799
um 256 bits for this algorithm but

00:03:29,360 --> 00:03:32,080
they're different and we cannot take

00:03:30,799 --> 00:03:33,599
these outputs these hashes

00:03:32,080 --> 00:03:35,519
and go back to the original input

00:03:33,599 --> 00:03:37,280
because hashing functions and hashing

00:03:35,519 --> 00:03:39,599
algorithms are one-way functions

00:03:37,280 --> 00:03:41,680
input gets you an output but the output

00:03:39,599 --> 00:03:43,519
cannot be reversed

00:03:41,680 --> 00:03:45,040
so some of these hashing algorithms you

00:03:43,519 --> 00:03:48,159
might have heard of are md5

00:03:45,040 --> 00:03:49,840
sha 1 2 3 and tlm and these are all

00:03:48,159 --> 00:03:52,000
hashing algorithms that are

00:03:49,840 --> 00:03:54,080
commonly seen when you're dealing with

00:03:52,000 --> 00:03:55,840
hashing

00:03:54,080 --> 00:03:57,120
and a variant of hashing is keyed

00:03:55,840 --> 00:03:59,439
hashing and this

00:03:57,120 --> 00:04:01,680
is basically everything that a hash is

00:03:59,439 --> 00:04:03,680
um but it let's also lets you validate

00:04:01,680 --> 00:04:05,200
the integrity and the authenticity of

00:04:03,680 --> 00:04:07,519
the content of a hash

00:04:05,200 --> 00:04:09,760
which means that you can validate that

00:04:07,519 --> 00:04:12,080
the input has not been tampered with

00:04:09,760 --> 00:04:14,159
based on the the the key that's that's

00:04:12,080 --> 00:04:15,920
associated with this kid hashing and you

00:04:14,159 --> 00:04:17,519
can also validate the integrity

00:04:15,920 --> 00:04:19,440
or the authenticity that it's a real

00:04:17,519 --> 00:04:21,280
hash that you're expecting to have

00:04:19,440 --> 00:04:23,040
so in order to computer kit hash you

00:04:21,280 --> 00:04:24,800
need a secret key

00:04:23,040 --> 00:04:26,320
um so if you have the same schematic as

00:04:24,800 --> 00:04:28,080
before input doc

00:04:26,320 --> 00:04:30,080
doggo the queen greek brown fox james

00:04:28,080 --> 00:04:31,360
with lazy dog we run them through a heat

00:04:30,080 --> 00:04:34,000
hashing algorithm in this

00:04:31,360 --> 00:04:36,479
this instance is hmx shot 256 so still

00:04:34,000 --> 00:04:38,320
we get a 256 bit output

00:04:36,479 --> 00:04:39,759
it's the same for all inputs but

00:04:38,320 --> 00:04:42,000
together with the input

00:04:39,759 --> 00:04:42,800
the dog doggo and so forth we also input

00:04:42,000 --> 00:04:44,720
a secret

00:04:42,800 --> 00:04:46,000
in this case it will be super secret

00:04:44,720 --> 00:04:47,759
usually it's a randomized

00:04:46,000 --> 00:04:49,199
string that you have to keep secret to

00:04:47,759 --> 00:04:51,040
yourself otherwise

00:04:49,199 --> 00:04:52,639
it would be useless but based on the

00:04:51,040 --> 00:04:55,120
secret the output would always be the

00:04:52,639 --> 00:04:57,600
same if i would input a different secret

00:04:55,120 --> 00:04:59,040
for the input dog my output would be

00:04:57,600 --> 00:05:01,039
different

00:04:59,040 --> 00:05:02,720
for example if we have the same imp we

00:05:01,039 --> 00:05:04,240
have the input the quick brown fox jumps

00:05:02,720 --> 00:05:06,560
out the lazy dog and with two different

00:05:04,240 --> 00:05:09,120
secrets the real one my super secret

00:05:06,560 --> 00:05:10,000
and a wrong one wrong secret the output

00:05:09,120 --> 00:05:12,240
of that algorithm

00:05:10,000 --> 00:05:13,680
will be different for both secrets even

00:05:12,240 --> 00:05:15,520
though that the input the quick brown

00:05:13,680 --> 00:05:17,199
fox is the same for both of them

00:05:15,520 --> 00:05:18,960
this makes sure that if we know the

00:05:17,199 --> 00:05:22,080
secret we can validate the

00:05:18,960 --> 00:05:22,800
authenticity of this hash or at least of

00:05:22,080 --> 00:05:26,240
the input

00:05:22,800 --> 00:05:28,000
of this hash um internally

00:05:26,240 --> 00:05:29,440
it's a bit more complicated and usually

00:05:28,000 --> 00:05:30,800
your secret key is converted to an

00:05:29,440 --> 00:05:32,320
entertaining outer key and then you

00:05:30,800 --> 00:05:33,039
first make a first hash with the enter

00:05:32,320 --> 00:05:34,479
key

00:05:33,039 --> 00:05:36,479
and take that first hash and use the

00:05:34,479 --> 00:05:37,680
other key to set the secondary hash and

00:05:36,479 --> 00:05:38,880
then you get an output

00:05:37,680 --> 00:05:40,080
you don't really need to know this i

00:05:38,880 --> 00:05:41,360
just wanted to mention is that

00:05:40,080 --> 00:05:42,960
internally these algorithms are

00:05:41,360 --> 00:05:45,440
sometimes quite complicated

00:05:42,960 --> 00:05:47,440
but the essence is quite simple input

00:05:45,440 --> 00:05:50,639
gets you a fixed output

00:05:47,440 --> 00:05:53,039
and cannot be reversed some of these

00:05:50,639 --> 00:05:55,600
algorithms are hmac shot two five six

00:05:53,039 --> 00:05:57,039
three eight four and five twelve and of

00:05:55,600 --> 00:05:59,680
course these numbers they mean

00:05:57,039 --> 00:06:00,080
the uh bit length of the output um and

00:05:59,680 --> 00:06:01,759
if

00:06:00,080 --> 00:06:03,600
these these this just seems like some

00:06:01,759 --> 00:06:05,840
random letters it basically stands for

00:06:03,600 --> 00:06:07,840
key task message authentication code

00:06:05,840 --> 00:06:10,639
with a secure hash algorithm

00:06:07,840 --> 00:06:11,440
and it's a 256 bit output like i

00:06:10,639 --> 00:06:13,280
mentioned before

00:06:11,440 --> 00:06:15,120
so it's not just random random letters

00:06:13,280 --> 00:06:17,039
and random numbers they actually do me

00:06:15,120 --> 00:06:18,800
something most of the time

00:06:17,039 --> 00:06:20,400
i was talking about storing passwords

00:06:18,800 --> 00:06:22,160
and databases and often you would store

00:06:20,400 --> 00:06:24,080
them as a keyed hash

00:06:22,160 --> 00:06:26,000
but before you store a password usually

00:06:24,080 --> 00:06:27,039
they are salted um and what this means

00:06:26,000 --> 00:06:29,759
is that you

00:06:27,039 --> 00:06:31,600
um basically add a random or randomized

00:06:29,759 --> 00:06:33,120
value before the actual password or the

00:06:31,600 --> 00:06:34,720
actual data you want to solve

00:06:33,120 --> 00:06:36,800
um just so that the hash output would

00:06:34,720 --> 00:06:38,639
always be different um so this has a

00:06:36,800 --> 00:06:40,400
benefit that similar passwords do not

00:06:38,639 --> 00:06:42,560
have the same hash if for example

00:06:40,400 --> 00:06:43,759
me and richard and alex all happen to

00:06:42,560 --> 00:06:45,039
have the same password and we would

00:06:43,759 --> 00:06:47,039
store them as a hedge

00:06:45,039 --> 00:06:48,880
some a a regular keyed hash in our

00:06:47,039 --> 00:06:50,720
database these hashes would all be

00:06:48,880 --> 00:06:53,120
all be the same and even though i do not

00:06:50,720 --> 00:06:54,880
necessarily know alex and richard's

00:06:53,120 --> 00:06:55,919
password because our hashes are the same

00:06:54,880 --> 00:06:56,880
we can assume that it's the same

00:06:55,919 --> 00:06:58,560
password as me

00:06:56,880 --> 00:07:00,240
so if we add some random data to all of

00:06:58,560 --> 00:07:01,680
our passwords before we hash it

00:07:00,240 --> 00:07:03,759
the outputs will always be a bit

00:07:01,680 --> 00:07:05,199
different that's called a salt and this

00:07:03,759 --> 00:07:06,639
also means that you cannot really use

00:07:05,199 --> 00:07:08,319
rainbow tables and a rainbow table is

00:07:06,639 --> 00:07:08,880
just a very big database a very big

00:07:08,319 --> 00:07:11,680
table

00:07:08,880 --> 00:07:12,800
with all possible strings and their hash

00:07:11,680 --> 00:07:14,720
outcomes

00:07:12,800 --> 00:07:16,560
so if you add some random data that

00:07:14,720 --> 00:07:17,759
would make those rainbow tables also

00:07:16,560 --> 00:07:20,560
useless

00:07:17,759 --> 00:07:22,080
and so the same example we have our kit

00:07:20,560 --> 00:07:24,000
algorithm we have our secret we have our

00:07:22,080 --> 00:07:25,919
input the quick brown fox

00:07:24,000 --> 00:07:27,840
but together with that input we also add

00:07:25,919 --> 00:07:28,479
some random salt in this case a random

00:07:27,840 --> 00:07:30,560
string

00:07:28,479 --> 00:07:32,080
and we get our output so that's usually

00:07:30,560 --> 00:07:34,560
done when you have to store

00:07:32,080 --> 00:07:35,919
key passwords or some other sensitive

00:07:34,560 --> 00:07:37,759
data

00:07:35,919 --> 00:07:39,199
okay we've seen ketchus and regular

00:07:37,759 --> 00:07:42,639
hashes onto

00:07:39,199 --> 00:07:44,400
signing and digital signatures offer all

00:07:42,639 --> 00:07:45,360
properties of keith hashes so everything

00:07:44,400 --> 00:07:47,759
a keith hash has

00:07:45,360 --> 00:07:49,759
is also true for a big digital signature

00:07:47,759 --> 00:07:50,520
plus they are cryptographic non-repeat

00:07:49,759 --> 00:07:52,960
your

00:07:50,520 --> 00:07:54,319
non-repudiatable or whatever you say and

00:07:52,960 --> 00:07:56,879
they enjoy the principle of

00:07:54,319 --> 00:07:58,479
cryptographic non-repudiation

00:07:56,879 --> 00:08:00,240
and it's a very fancy word and if you

00:07:58,479 --> 00:08:02,160
look it up on wikipedia it means

00:08:00,240 --> 00:08:04,319
something like non-repudiation refers to

00:08:02,160 --> 00:08:05,840
a situation where a statements author

00:08:04,319 --> 00:08:07,440
cannot successfully dispute its

00:08:05,840 --> 00:08:09,120
authorship or the validity

00:08:07,440 --> 00:08:10,879
of an associated contract and that's

00:08:09,120 --> 00:08:11,520
still a lot of fancy words so if we take

00:08:10,879 --> 00:08:15,120
a very

00:08:11,520 --> 00:08:16,720
simple example we all know cash checks

00:08:15,120 --> 00:08:18,319
from back in the day when nobody had a

00:08:16,720 --> 00:08:19,039
credit card but they had a checkbook in

00:08:18,319 --> 00:08:22,319
their pocket

00:08:19,039 --> 00:08:24,160
and let's say in the 60s you would buy a

00:08:22,319 --> 00:08:25,840
car you would go to a car dealership

00:08:24,160 --> 00:08:27,199
and you would pay your car with a check

00:08:25,840 --> 00:08:29,280
now on that check you would write your

00:08:27,199 --> 00:08:31,599
signature and once the car dealership

00:08:29,280 --> 00:08:32,800
goes to the bank and says hey i got a i

00:08:31,599 --> 00:08:34,240
got a check from some

00:08:32,800 --> 00:08:36,800
can i please get some money return of

00:08:34,240 --> 00:08:37,279
this check and the bank would say oh but

00:08:36,800 --> 00:08:38,959
this

00:08:37,279 --> 00:08:40,719
sum does not really have any money are

00:08:38,959 --> 00:08:42,399
you sure he signed it the bank

00:08:40,719 --> 00:08:44,480
or the car dealership could be could be

00:08:42,399 --> 00:08:45,680
saying i'm sure he signed it because his

00:08:44,480 --> 00:08:48,320
signature is on

00:08:45,680 --> 00:08:50,000
this check now a real signature is just

00:08:48,320 --> 00:08:52,080
a bit of

00:08:50,000 --> 00:08:54,240
ink on a piece of paper so it's easy to

00:08:52,080 --> 00:08:55,519
forge a digital signature is usually

00:08:54,240 --> 00:08:57,440
less easy to forge

00:08:55,519 --> 00:08:58,560
but it still does the same thing it can

00:08:57,440 --> 00:09:01,040
prove who

00:08:58,560 --> 00:09:03,200
created that signature and that's what

00:09:01,040 --> 00:09:06,320
this non-repudiation means

00:09:03,200 --> 00:09:08,480
it can prove who created the signature

00:09:06,320 --> 00:09:10,080
so cryptographic no repudiation enables

00:09:08,480 --> 00:09:10,720
other parties other than the signer to

00:09:10,080 --> 00:09:12,640
check this

00:09:10,720 --> 00:09:14,560
signature's validity so i can share my

00:09:12,640 --> 00:09:14,959
signature with a lot of people and they

00:09:14,560 --> 00:09:17,839
all

00:09:14,959 --> 00:09:18,800
would be able to to validate the

00:09:17,839 --> 00:09:23,519
signature

00:09:18,800 --> 00:09:25,360
validity based on a public key

00:09:23,519 --> 00:09:27,360
um so like i just said the digital

00:09:25,360 --> 00:09:29,279
signatures use public key cryptography

00:09:27,360 --> 00:09:30,640
or asymmetric cryptography which means

00:09:29,279 --> 00:09:32,560
that you have a private key

00:09:30,640 --> 00:09:34,320
and a public key an assigner is going to

00:09:32,560 --> 00:09:35,600
create let's say the signature using the

00:09:34,320 --> 00:09:37,519
private key and a private key is

00:09:35,600 --> 00:09:38,959
something you keep secret to yourself

00:09:37,519 --> 00:09:40,480
it's private it's called private for a

00:09:38,959 --> 00:09:42,800
reason so you're going to create the

00:09:40,480 --> 00:09:43,760
signature with your private key

00:09:42,800 --> 00:09:45,519
and then you're going to send that

00:09:43,760 --> 00:09:47,200
signature together with some data to

00:09:45,519 --> 00:09:48,800
whoever wants to receive it

00:09:47,200 --> 00:09:50,480
and they can use your public key which

00:09:48,800 --> 00:09:52,000
is something public that you can share

00:09:50,480 --> 00:09:53,440
with everybody in the world

00:09:52,000 --> 00:09:55,839
and they can use a public key which is

00:09:53,440 --> 00:10:00,880
linked to the private key to validate

00:09:55,839 --> 00:10:00,880
the signature of that payload

00:10:01,360 --> 00:10:04,399
and assigning algorithm is usually a

00:10:02,880 --> 00:10:05,920
collection of three different algorithms

00:10:04,399 --> 00:10:06,399
something that generates a private and

00:10:05,920 --> 00:10:08,160
keeper

00:10:06,399 --> 00:10:10,079
private and public key pair something

00:10:08,160 --> 00:10:12,399
that signs or creates a signature

00:10:10,079 --> 00:10:15,200
and something that's able to verify the

00:10:12,399 --> 00:10:17,120
signature a verifying algorithm

00:10:15,200 --> 00:10:19,360
so if you look again at a more schematic

00:10:17,120 --> 00:10:21,200
kind of way our input is still the same

00:10:19,360 --> 00:10:23,040
the quick brown fox strips over the lazy

00:10:21,200 --> 00:10:25,680
dog but if we run into a signing

00:10:23,040 --> 00:10:28,480
algorithm and we use our private key

00:10:25,680 --> 00:10:29,839
we get a signature now if we want to

00:10:28,480 --> 00:10:31,760
verify that signature

00:10:29,839 --> 00:10:33,839
we're going to take our signature which

00:10:31,760 --> 00:10:36,000
is a d7a8 and so forth

00:10:33,839 --> 00:10:37,200
run it to that verifying algorithm

00:10:36,000 --> 00:10:39,200
together with the public key which is

00:10:37,200 --> 00:10:41,040
linked to the private key we used before

00:10:39,200 --> 00:10:43,120
and we would get the output the quick

00:10:41,040 --> 00:10:44,640
brown fox jumps over the lazy dog

00:10:43,120 --> 00:10:46,399
now if we see that this output is the

00:10:44,640 --> 00:10:47,440
same as the output we expect the quick

00:10:46,399 --> 00:10:49,200
brownfox

00:10:47,440 --> 00:10:51,200
we know that the content match so the

00:10:49,200 --> 00:10:53,040
signature is valid the content has not

00:10:51,200 --> 00:10:54,959
been tampered with

00:10:53,040 --> 00:10:56,079
signatures usually are hashed before

00:10:54,959 --> 00:10:57,760
they are signed

00:10:56,079 --> 00:10:59,279
just so you have a fixed outcome because

00:10:57,760 --> 00:11:02,240
we've seen that hashes always have a

00:10:59,279 --> 00:11:04,399
fixed length of an outcome

00:11:02,240 --> 00:11:06,079
so and before we run into designing

00:11:04,399 --> 00:11:06,640
algorithm we usually run it to a hashing

00:11:06,079 --> 00:11:08,880
algorithm

00:11:06,640 --> 00:11:11,200
but the concept stays the same you use

00:11:08,880 --> 00:11:13,839
your private key to create a signature

00:11:11,200 --> 00:11:14,560
and you use the public key to verify the

00:11:13,839 --> 00:11:16,959
signature

00:11:14,560 --> 00:11:18,240
but instead of directly comparing the

00:11:16,959 --> 00:11:19,279
input and the output you're going to

00:11:18,240 --> 00:11:21,519
compare hashes

00:11:19,279 --> 00:11:24,320
which is always going to be the same for

00:11:21,519 --> 00:11:24,320
the same input

00:11:24,560 --> 00:11:27,760
so some signing algorithms the most

00:11:26,079 --> 00:11:30,079
commonly used ones are rsa

00:11:27,760 --> 00:11:33,519
elliptic curve or sometimes ec and

00:11:30,079 --> 00:11:36,560
edwards curve octet key pairs are okp

00:11:33,519 --> 00:11:38,959
and rsa keys they they are often used in

00:11:36,560 --> 00:11:40,320
the rs and ps algorithms

00:11:38,959 --> 00:11:42,240
they're very fast to compute because

00:11:40,320 --> 00:11:44,480
they're relatively easy they're

00:11:42,240 --> 00:11:46,079
relatively simple that's also means that

00:11:44,480 --> 00:11:48,000
they're quite cpu friendly and they have

00:11:46,079 --> 00:11:49,279
quite a very good support because

00:11:48,000 --> 00:11:50,959
they're quite easy to implement and

00:11:49,279 --> 00:11:53,200
they've been around for quite a while

00:11:50,959 --> 00:11:54,160
um now they do require longer keys with

00:11:53,200 --> 00:11:57,200
a minimum of 20

00:11:54,160 --> 00:11:58,160
of 2056 bits to have a certain amount of

00:11:57,200 --> 00:11:59,760
security

00:11:58,160 --> 00:12:02,000
which means that you also get longer

00:11:59,760 --> 00:12:06,399
signatures 20 56 bits

00:12:02,000 --> 00:12:07,680
in this case while elliptic curves yes

00:12:06,399 --> 00:12:09,760
they have shorter keys for the same

00:12:07,680 --> 00:12:11,040
amount of strength than rsa which means

00:12:09,760 --> 00:12:12,480
they have shorter signatures

00:12:11,040 --> 00:12:14,560
but they're a bit more complex so

00:12:12,480 --> 00:12:17,120
computing them and verifying them is

00:12:14,560 --> 00:12:19,760
going to take a little bit longer

00:12:17,120 --> 00:12:20,320
and adverse curve optic keys they're a

00:12:19,760 --> 00:12:22,000
bit of

00:12:20,320 --> 00:12:25,200
best of both worlds they have the best

00:12:22,000 --> 00:12:27,279
signing performance they're quite secure

00:12:25,200 --> 00:12:28,959
but they are relatively new so not all

00:12:27,279 --> 00:12:30,800
libraries out there might support them

00:12:28,959 --> 00:12:32,480
even though that support for the adwords

00:12:30,800 --> 00:12:34,399
curve update keys

00:12:32,480 --> 00:12:35,600
are picking up and most libraries are

00:12:34,399 --> 00:12:39,279
implementing them or have

00:12:35,600 --> 00:12:42,240
implemented them already okay

00:12:39,279 --> 00:12:44,399
hashing ketching signatures onto the

00:12:42,240 --> 00:12:47,360
last part of cryptography encryption

00:12:44,399 --> 00:12:48,720
um and when encrypting data we cannot

00:12:47,360 --> 00:12:50,240
only ensure its integrity and

00:12:48,720 --> 00:12:52,480
authenticity like we did with keith

00:12:50,240 --> 00:12:54,560
hashes and like we did with a signature

00:12:52,480 --> 00:12:56,399
the data of of something that is

00:12:54,560 --> 00:12:58,240
encrypted will also stay secret for

00:12:56,399 --> 00:13:00,399
outsiders which means that only

00:12:58,240 --> 00:13:01,680
the the party that created the encrypted

00:13:00,399 --> 00:13:03,920
data and the party that is

00:13:01,680 --> 00:13:06,399
intended to receive this this encrypted

00:13:03,920 --> 00:13:07,680
data will be able to actually read the

00:13:06,399 --> 00:13:09,519
data

00:13:07,680 --> 00:13:11,279
so you need either a private key a

00:13:09,519 --> 00:13:12,880
secret key or a password to read

00:13:11,279 --> 00:13:15,360
the data this depends on the algorithm

00:13:12,880 --> 00:13:16,959
that you're using

00:13:15,360 --> 00:13:18,560
the encrypted message is often called a

00:13:16,959 --> 00:13:19,200
cipher so if you hear a cipher it

00:13:18,560 --> 00:13:21,680
usually

00:13:19,200 --> 00:13:22,800
refers to the output of a an encryption

00:13:21,680 --> 00:13:26,399
algorithm

00:13:22,800 --> 00:13:28,079
the encrypted message itself um and

00:13:26,399 --> 00:13:29,680
there's a few different kind of algo

00:13:28,079 --> 00:13:31,440
kinds of algorithms they're symmetric

00:13:29,680 --> 00:13:33,120
ones and there's asymmetrical ones

00:13:31,440 --> 00:13:35,279
both have their use case um let's start

00:13:33,120 --> 00:13:37,600
with the simplest one symmetrical ones

00:13:35,279 --> 00:13:40,320
some example use cases are file systems

00:13:37,600 --> 00:13:42,240
wi-fi database encryption basically all

00:13:40,320 --> 00:13:42,800
systems that deal with a big volume of

00:13:42,240 --> 00:13:45,519
data

00:13:42,800 --> 00:13:45,839
are often encrypted with a symmetrical

00:13:45,519 --> 00:13:47,440
one

00:13:45,839 --> 00:13:49,120
just because they're faster to compute

00:13:47,440 --> 00:13:51,760
they're simpler

00:13:49,120 --> 00:13:52,160
and what is a symmetric algorithm some

00:13:51,760 --> 00:13:54,800
of the

00:13:52,160 --> 00:13:56,399
uh the algorithms are listed here it

00:13:54,800 --> 00:13:59,120
basically uses the same key

00:13:56,399 --> 00:14:00,720
the shared secret to do both encryption

00:13:59,120 --> 00:14:02,079
and decryption this makes the math

00:14:00,720 --> 00:14:02,560
underneath these algorithms a bit more

00:14:02,079 --> 00:14:04,320
simple

00:14:02,560 --> 00:14:06,079
that's why we use them for big pieces of

00:14:04,320 --> 00:14:07,120
data so if you know the shared secret

00:14:06,079 --> 00:14:09,360
you can create

00:14:07,120 --> 00:14:11,360
both the encrypted message and decrypt

00:14:09,360 --> 00:14:13,680
that encrypted message

00:14:11,360 --> 00:14:15,360
now with asymmetrical encryption that's

00:14:13,680 --> 00:14:16,560
not going to be the case

00:14:15,360 --> 00:14:18,480
the sender is going to ask the

00:14:16,560 --> 00:14:19,920
receiver's public key because a public

00:14:18,480 --> 00:14:21,360
key like we saw with signatures is

00:14:19,920 --> 00:14:23,279
something you can share

00:14:21,360 --> 00:14:25,040
with the world and it's going to use

00:14:23,279 --> 00:14:25,680
that public key to create the encrypted

00:14:25,040 --> 00:14:27,440
message

00:14:25,680 --> 00:14:28,880
now this might get a little bit

00:14:27,440 --> 00:14:29,680
confusing because when you create a

00:14:28,880 --> 00:14:31,120
signature you

00:14:29,680 --> 00:14:32,560
create that signature with the private

00:14:31,120 --> 00:14:33,440
key and you validate that with your

00:14:32,560 --> 00:14:35,120
public key

00:14:33,440 --> 00:14:36,560
with an encryption it's it's the other

00:14:35,120 --> 00:14:38,079
way around you're going to ask for

00:14:36,560 --> 00:14:38,720
somebody's public key and use that

00:14:38,079 --> 00:14:40,639
public key

00:14:38,720 --> 00:14:42,320
to encrypt the message so that that

00:14:40,639 --> 00:14:43,600
receiving party that person that just

00:14:42,320 --> 00:14:46,000
shared his public key

00:14:43,600 --> 00:14:47,920
can use their matching private key to

00:14:46,000 --> 00:14:48,880
encrypt or to decrypt your encrypted

00:14:47,920 --> 00:14:50,320
message

00:14:48,880 --> 00:14:52,079
um so when the receiver receives a

00:14:50,320 --> 00:14:53,920
cipher you get the message they're going

00:14:52,079 --> 00:14:57,920
to use the matching private key

00:14:53,920 --> 00:14:58,720
to decrypt that message the same example

00:14:57,920 --> 00:15:00,800
okay

00:14:58,720 --> 00:15:02,800
quick the quick brown fox we're going to

00:15:00,800 --> 00:15:03,519
use this the receiver's public key to

00:15:02,800 --> 00:15:06,000
encrypt

00:15:03,519 --> 00:15:07,760
we get our encrypted message and then

00:15:06,000 --> 00:15:09,519
the party that wants to decrypt it

00:15:07,760 --> 00:15:11,440
that's the intended party the intended

00:15:09,519 --> 00:15:12,240
receiver can use a private key to

00:15:11,440 --> 00:15:13,680
decrypt the

00:15:12,240 --> 00:15:16,399
uh the message and get back to the

00:15:13,680 --> 00:15:18,639
original input

00:15:16,399 --> 00:15:21,120
some uh forms of asymmetrical encryption

00:15:18,639 --> 00:15:23,199
are tls vpn ssh

00:15:21,120 --> 00:15:24,880
so things if you're dealing with web web

00:15:23,199 --> 00:15:27,680
development you might have seen

00:15:24,880 --> 00:15:28,480
floating around and some of the

00:15:27,680 --> 00:15:33,680
algorithms are

00:15:28,480 --> 00:15:35,680
rsa ecdh things like that

00:15:33,680 --> 00:15:37,279
so like i said before symmetrical

00:15:35,680 --> 00:15:38,800
algorithms are faster than asymmetrical

00:15:37,279 --> 00:15:40,480
ones just because they use the same

00:15:38,800 --> 00:15:41,279
secret to both do encryption and

00:15:40,480 --> 00:15:43,279
decryption

00:15:41,279 --> 00:15:44,720
um but both have their use cases

00:15:43,279 --> 00:15:45,440
asymmetrical ones are usually a bit more

00:15:44,720 --> 00:15:48,240
secure

00:15:45,440 --> 00:15:49,680
so what often is being done is you use

00:15:48,240 --> 00:15:51,360
an asymmetrical algorithm

00:15:49,680 --> 00:15:53,279
to encrypt your secret that you're then

00:15:51,360 --> 00:15:54,880
going to use with your symmetric

00:15:53,279 --> 00:15:57,120
algorithm to actually encrypt and

00:15:54,880 --> 00:15:59,440
decrypt the data

00:15:57,120 --> 00:16:00,320
um so let's look at a detailed example

00:15:59,440 --> 00:16:03,120
rsa

00:16:00,320 --> 00:16:04,880
rsa it's a abbreviation of the people

00:16:03,120 --> 00:16:06,320
that actually created this algorithm but

00:16:04,880 --> 00:16:07,360
i'm terrible with names so i don't

00:16:06,320 --> 00:16:08,800
remember those names

00:16:07,360 --> 00:16:10,639
but it doesn't mean something clever

00:16:08,800 --> 00:16:12,399
it's just the people who created this

00:16:10,639 --> 00:16:14,079
algorithm

00:16:12,399 --> 00:16:15,920
and the first thing we need to do with

00:16:14,079 --> 00:16:18,480
rsa or with any of these

00:16:15,920 --> 00:16:19,279
encryption or signature asymmetrical

00:16:18,480 --> 00:16:21,199
algorithms

00:16:19,279 --> 00:16:23,440
is generate a public key and a private

00:16:21,199 --> 00:16:26,000
key pair

00:16:23,440 --> 00:16:27,839
no cryptography is usually based on some

00:16:26,000 --> 00:16:29,839
algorithms using very large prime

00:16:27,839 --> 00:16:31,680
numbers and rsa is no exception

00:16:29,839 --> 00:16:33,199
and when i talk about very large numbers

00:16:31,680 --> 00:16:36,000
do i mean a million

00:16:33,199 --> 00:16:37,759
do i mean a billion well no i mean

00:16:36,000 --> 00:16:39,759
something that might look like this

00:16:37,759 --> 00:16:41,279
where this is a million this is a

00:16:39,759 --> 00:16:42,480
billion and you see how many other

00:16:41,279 --> 00:16:44,240
digits are on screen

00:16:42,480 --> 00:16:47,199
you often deal with numbers which are

00:16:44,240 --> 00:16:48,399
150 300 and more digits long

00:16:47,199 --> 00:16:50,079
i don't even know the names of these

00:16:48,399 --> 00:16:51,040
kind of numbers but they're very big

00:16:50,079 --> 00:16:53,279
prime numbers

00:16:51,040 --> 00:16:54,320
which means that computing these these

00:16:53,279 --> 00:16:57,279
things is very

00:16:54,320 --> 00:16:59,040
intensive very um difficult also this

00:16:57,279 --> 00:17:01,839
also means that brute forcing

00:16:59,040 --> 00:17:03,360
these algorithms is very time consuming

00:17:01,839 --> 00:17:05,199
and very difficult and that makes them

00:17:03,360 --> 00:17:07,679
so secure

00:17:05,199 --> 00:17:08,720
so we had to create our private key and

00:17:07,679 --> 00:17:11,760
our public key

00:17:08,720 --> 00:17:14,160
first so in rsa it's done like this

00:17:11,760 --> 00:17:15,760
first your rsa algorithm or your your

00:17:14,160 --> 00:17:16,400
key generating algorithm is going to

00:17:15,760 --> 00:17:19,520
create

00:17:16,400 --> 00:17:20,559
two very large prime numbers random uh

00:17:19,520 --> 00:17:22,640
our first one is p

00:17:20,559 --> 00:17:23,839
our second one is q i've used very small

00:17:22,640 --> 00:17:26,720
numbers in this example

00:17:23,839 --> 00:17:28,480
61 and 53 in essence in reality it's

00:17:26,720 --> 00:17:32,080
going to be very large numbers but

00:17:28,480 --> 00:17:33,520
to have a better example 61-53 and then

00:17:32,080 --> 00:17:34,640
we're going to create the lambda which

00:17:33,520 --> 00:17:37,280
is the lcm the

00:17:34,640 --> 00:17:37,679
the lowest common multiplier of p minus

00:17:37,280 --> 00:17:40,080
00:17:37,679 --> 00:17:40,799
and q minus 1 which if you want to do

00:17:40,080 --> 00:17:42,480
the math is

00:17:40,799 --> 00:17:44,080
780. and you're going to keep these

00:17:42,480 --> 00:17:45,679
secrets in memory we're going to keep

00:17:44,080 --> 00:17:46,160
them secret but you're going to use

00:17:45,679 --> 00:17:47,760
these

00:17:46,160 --> 00:17:49,280
to create both your public key and

00:17:47,760 --> 00:17:50,480
private key which means that they're

00:17:49,280 --> 00:17:52,240
going to be mathematically

00:17:50,480 --> 00:17:53,520
linked um now your public key might

00:17:52,240 --> 00:17:56,559
contain a bunch of data

00:17:53,520 --> 00:17:57,039
but it will also contain a modulus which

00:17:56,559 --> 00:17:58,880
is

00:17:57,039 --> 00:18:00,880
the first prime number times the second

00:17:58,880 --> 00:18:03,200
prime number and your public exponent

00:18:00,880 --> 00:18:05,840
which is a co prime of lambda in this

00:18:03,200 --> 00:18:07,440
algorithm and the private key is also

00:18:05,840 --> 00:18:09,200
going to contain that modulus but

00:18:07,440 --> 00:18:11,280
instead of a public exponent

00:18:09,200 --> 00:18:12,559
it's going to contain this private

00:18:11,280 --> 00:18:15,120
exponent which is e

00:18:12,559 --> 00:18:17,280
with the is of lambda and it's a bunch

00:18:15,120 --> 00:18:19,440
of fancy mathematics under the hood

00:18:17,280 --> 00:18:20,880
um but what you have to remember is that

00:18:19,440 --> 00:18:22,799
they're both linked

00:18:20,880 --> 00:18:24,400
both the private key and the public key

00:18:22,799 --> 00:18:26,080
because of those two prime numbers and

00:18:24,400 --> 00:18:28,720
alumna that we created

00:18:26,080 --> 00:18:30,480
when we created those two keys now

00:18:28,720 --> 00:18:31,440
remember modulus public exponents are

00:18:30,480 --> 00:18:34,080
private exponents

00:18:31,440 --> 00:18:36,480
they're part of our keys um when we want

00:18:34,080 --> 00:18:38,400
to use a public key to encrypt some data

00:18:36,480 --> 00:18:39,840
we're going to do something like this or

00:18:38,400 --> 00:18:41,679
input one two three four

00:18:39,840 --> 00:18:43,360
it's a number just because that's easier

00:18:41,679 --> 00:18:43,919
we're dealing with math underneath the

00:18:43,360 --> 00:18:47,840
hood

00:18:43,919 --> 00:18:50,000
and our public key has a modulus of 3233

00:18:47,840 --> 00:18:51,200
and then public exponent of 17.

00:18:50,000 --> 00:18:53,120
if you run it to the encryption

00:18:51,200 --> 00:18:54,240
algorithm of rsa which is in the middle

00:18:53,120 --> 00:18:57,280
of this yellow box

00:18:54,240 --> 00:19:00,640
you'll get a 2183 as an output

00:18:57,280 --> 00:19:02,160
um that's just some math usually you're

00:19:00,640 --> 00:19:02,880
not dealing with numbers but you're

00:19:02,160 --> 00:19:04,400
dealing with

00:19:02,880 --> 00:19:06,000
text or other data so you might have to

00:19:04,400 --> 00:19:08,000
do some data conversion

00:19:06,000 --> 00:19:09,919
but at the core it's always still this

00:19:08,000 --> 00:19:11,440
algorithm this encryption algorithm

00:19:09,919 --> 00:19:14,520
using the public key

00:19:11,440 --> 00:19:17,600
exponent and modulus to do some

00:19:14,520 --> 00:19:19,440
mathematical equations

00:19:17,600 --> 00:19:20,880
now if you want to reverse this you know

00:19:19,440 --> 00:19:23,760
if you want to use our private key to

00:19:20,880 --> 00:19:24,880
decrypt that message we just created

00:19:23,760 --> 00:19:27,440
we're going to do the same thing

00:19:24,880 --> 00:19:29,360
so our output of our encryption um

00:19:27,440 --> 00:19:32,160
thingy earlier was 2183

00:19:29,360 --> 00:19:33,360
we're going to input this decryption run

00:19:32,160 --> 00:19:35,679
it through the algorithm

00:19:33,360 --> 00:19:36,480
and our original message shows up again

00:19:35,679 --> 00:19:38,400
one two three

00:19:36,480 --> 00:19:40,559
four um but instead of using our private

00:19:38,400 --> 00:19:41,840
or public key we use our private key

00:19:40,559 --> 00:19:43,919
and remember that these are

00:19:41,840 --> 00:19:45,280
mathematically linked to each other both

00:19:43,919 --> 00:19:47,280
the public and the private key

00:19:45,280 --> 00:19:50,880
which means that we can decrypt the

00:19:47,280 --> 00:19:50,880
message if we know the private key

00:19:50,960 --> 00:19:54,400
again usually you don't use a numbers

00:19:52,640 --> 00:19:55,360
but you have something like a string or

00:19:54,400 --> 00:19:58,000
some other data

00:19:55,360 --> 00:19:58,400
so there's some data conversion um that

00:19:58,000 --> 00:20:00,559
takes

00:19:58,400 --> 00:20:01,919
that this is going on but at the essence

00:20:00,559 --> 00:20:03,039
at the core it's still just that

00:20:01,919 --> 00:20:07,840
mathematical

00:20:03,039 --> 00:20:07,840
algorithm uh running in the background

00:20:09,679 --> 00:20:15,600
let's see why i cannot skip okay

00:20:12,799 --> 00:20:15,919
so i created a little very small script

00:20:15,600 --> 00:20:19,200
that

00:20:15,919 --> 00:20:20,559
um you can link to in a second but what

00:20:19,200 --> 00:20:21,360
this does is basically it's a node

00:20:20,559 --> 00:20:22,720
script and it

00:20:21,360 --> 00:20:24,559
generates the two prime numbers the

00:20:22,720 --> 00:20:26,320
modulus the lambda and the public and

00:20:24,559 --> 00:20:27,440
private exponent and you can see it in

00:20:26,320 --> 00:20:29,200
action yourself

00:20:27,440 --> 00:20:30,640
but like i said we usually don't use

00:20:29,200 --> 00:20:32,960
small numbers we use

00:20:30,640 --> 00:20:34,400
large prime numbers so if we change the

00:20:32,960 --> 00:20:35,440
numbers the first one and the second one

00:20:34,400 --> 00:20:38,000
do something with

00:20:35,440 --> 00:20:39,120
more than 150 digits and we get very big

00:20:38,000 --> 00:20:41,840
numbers to work with

00:20:39,120 --> 00:20:42,400
so we get very complicated mathematics

00:20:41,840 --> 00:20:44,799
um and

00:20:42,400 --> 00:20:46,880
if you like to see how i've implemented

00:20:44,799 --> 00:20:48,640
this no this is just for demo purposes

00:20:46,880 --> 00:20:51,120
don't use this and in production you can

00:20:48,640 --> 00:20:53,679
go to github.combiegel

00:20:51,120 --> 00:20:55,280
rsa demo and there's three ranges one

00:20:53,679 --> 00:20:57,039
with simple numbers one with large

00:20:55,280 --> 00:20:57,760
numbers and one that does a bit of data

00:20:57,039 --> 00:21:01,679
conversion

00:20:57,760 --> 00:21:06,240
but you'll see that the basics of rsa

00:21:01,679 --> 00:21:09,440
can be written in 63 lines

00:21:06,240 --> 00:21:11,200
of code where the most

00:21:09,440 --> 00:21:13,120
mathematical thing is going on we get a

00:21:11,200 --> 00:21:14,640
co-prime we get a random prime

00:21:13,120 --> 00:21:17,760
and then we do some mathematical

00:21:14,640 --> 00:21:19,440
equations so it's not that complicated

00:21:17,760 --> 00:21:21,679
the basics once you go beyond these

00:21:19,440 --> 00:21:22,240
basics it gets quite complicated quite

00:21:21,679 --> 00:21:23,520
fast

00:21:22,240 --> 00:21:25,840
but you don't need to know this because

00:21:23,520 --> 00:21:28,240
you go you should use a

00:21:25,840 --> 00:21:30,880
test tested and proven library anyway

00:21:28,240 --> 00:21:33,120
when you're dealing with cryptography

00:21:30,880 --> 00:21:34,000
okay we've seen all of the basics of

00:21:33,120 --> 00:21:36,159
cryptography

00:21:34,000 --> 00:21:38,320
hashing ketching signatures and

00:21:36,159 --> 00:21:39,760
encryption let's move on to jose

00:21:38,320 --> 00:21:41,520
the thing that's actually in the title

00:21:39,760 --> 00:21:43,200
of this talk

00:21:41,520 --> 00:21:45,200
and jose like i mentioned in the very

00:21:43,200 --> 00:21:46,240
beginning stands for json object signing

00:21:45,200 --> 00:21:48,880
and encryption

00:21:46,240 --> 00:21:49,520
and this might not be familiar to you

00:21:48,880 --> 00:21:51,200
but

00:21:49,520 --> 00:21:52,799
i think a lot of developers out there

00:21:51,200 --> 00:21:54,880
especially if you deal with apis and

00:21:52,799 --> 00:21:57,120
authentication once in a while

00:21:54,880 --> 00:21:59,039
you might use json web tokens and json

00:21:57,120 --> 00:22:00,720
web tokens are part of the jose

00:21:59,039 --> 00:22:02,159
json object signing and encryption

00:22:00,720 --> 00:22:05,039
standard

00:22:02,159 --> 00:22:06,480
um so why json the json format is often

00:22:05,039 --> 00:22:08,480
used for serializing and transmitting

00:22:06,480 --> 00:22:10,159
structured data over network connection

00:22:08,480 --> 00:22:12,400
which means that we use it all the time

00:22:10,159 --> 00:22:14,400
on the internet right who uses xml these

00:22:12,400 --> 00:22:15,919
days everybody uses json

00:22:14,400 --> 00:22:17,600
and it also has excellent support in

00:22:15,919 --> 00:22:20,000
most program programming languages

00:22:17,600 --> 00:22:21,120
especially in javascript so it's very

00:22:20,000 --> 00:22:24,080
commonly used

00:22:21,120 --> 00:22:25,200
all over the place so i mentioned json

00:22:24,080 --> 00:22:26,960
web tokens

00:22:25,200 --> 00:22:28,400
everything that's part of the json of

00:22:26,960 --> 00:22:29,520
the of the jose standard is going to be

00:22:28,400 --> 00:22:32,640
jw

00:22:29,520 --> 00:22:32,960
something jwt for tokens but let's start

00:22:32,640 --> 00:22:36,400
with

00:22:32,960 --> 00:22:37,120
the more simpler examples json webkeys

00:22:36,400 --> 00:22:38,880
because

00:22:37,120 --> 00:22:40,400
sometimes you want to share a public key

00:22:38,880 --> 00:22:41,840
and remember publicly something you can

00:22:40,400 --> 00:22:43,039
share with the rest of the world

00:22:41,840 --> 00:22:44,720
and you might want to share this on the

00:22:43,039 --> 00:22:46,320
internet and we like to share things in

00:22:44,720 --> 00:22:48,320
json format over the internet

00:22:46,320 --> 00:22:51,679
so we would like to create some json web

00:22:48,320 --> 00:22:54,640
keys a public keys in the form of json

00:22:51,679 --> 00:22:56,240
and this is an example of a json web key

00:22:54,640 --> 00:22:58,640
containing my public key

00:22:56,240 --> 00:22:59,679
or one of my public keys but remember

00:22:58,640 --> 00:23:01,760
when we

00:22:59,679 --> 00:23:03,760
had a look at that rsa example where we

00:23:01,760 --> 00:23:05,360
created the public and private key

00:23:03,760 --> 00:23:07,039
and the public key had the modulus and

00:23:05,360 --> 00:23:09,280
the public exponent the n and the e

00:23:07,039 --> 00:23:11,760
value well they're exactly

00:23:09,280 --> 00:23:12,960
you can find these in this r in this

00:23:11,760 --> 00:23:14,960
json web key as well

00:23:12,960 --> 00:23:16,480
where the n is a modulus it's the first

00:23:14,960 --> 00:23:18,880
prime times the second prime

00:23:16,480 --> 00:23:20,559
and the e is the public exponent which

00:23:18,880 --> 00:23:22,080
is the lambda

00:23:20,559 --> 00:23:24,559
something mathematical with your lambda

00:23:22,080 --> 00:23:26,080
function um so both these values are in

00:23:24,559 --> 00:23:27,440
this json map key

00:23:26,080 --> 00:23:29,200
together with some other information

00:23:27,440 --> 00:23:35,280
like which algorithm we're using

00:23:29,200 --> 00:23:35,280
and so forth next up json web signature

00:23:35,520 --> 00:23:39,120
where it's often or most of the time

00:23:37,520 --> 00:23:41,200
it's it's serialized as a string where

00:23:39,120 --> 00:23:41,679
you have the first part dot second part

00:23:41,200 --> 00:23:43,200
dot

00:23:41,679 --> 00:23:45,039
third part and it's always going to be

00:23:43,200 --> 00:23:45,760
three parts a signature adjacent web

00:23:45,039 --> 00:23:47,360
signature

00:23:45,760 --> 00:23:49,279
where the first work part is going to be

00:23:47,360 --> 00:23:51,440
base 64 of a json object

00:23:49,279 --> 00:23:52,400
which is called header the second part

00:23:51,440 --> 00:23:53,679
the payload

00:23:52,400 --> 00:23:55,520
and the last part is going to be the

00:23:53,679 --> 00:23:57,919
actual signature

00:23:55,520 --> 00:23:58,640
so if we look at an example and we would

00:23:57,919 --> 00:24:00,400
um

00:23:58,640 --> 00:24:02,720
look at the first part the joise header

00:24:00,400 --> 00:24:05,200
or the json web signature header

00:24:02,720 --> 00:24:07,279
we basically for decode this we get a

00:24:05,200 --> 00:24:08,240
json object which tells us the algorithm

00:24:07,279 --> 00:24:11,120
that we've used to

00:24:08,240 --> 00:24:12,720
create this signature is hs256 so please

00:24:11,120 --> 00:24:15,200
use this algorithm to verify this

00:24:12,720 --> 00:24:17,200
signature if you want to verify it

00:24:15,200 --> 00:24:19,039
the same thing for the payload if we

00:24:17,200 --> 00:24:21,360
base64 decode this

00:24:19,039 --> 00:24:22,240
string we get another json object in

00:24:21,360 --> 00:24:24,799
this case foo

00:24:22,240 --> 00:24:25,279
is bar but as long as it's valid json

00:24:24,799 --> 00:24:27,679
you can

00:24:25,279 --> 00:24:30,000
base 64 d encode it and put it as a

00:24:27,679 --> 00:24:32,640
payload over json web signature

00:24:30,000 --> 00:24:34,159
and lastly is a signature where um we're

00:24:32,640 --> 00:24:35,760
basically going to check in the header

00:24:34,159 --> 00:24:38,000
which algorithm do you need to use

00:24:35,760 --> 00:24:40,080
now we're going to feed both the header

00:24:38,000 --> 00:24:42,080
and the payload into this algorithm

00:24:40,080 --> 00:24:43,520
together with the secret because it's h

00:24:42,080 --> 00:24:46,159
mark which is basically

00:24:43,520 --> 00:24:48,480
a and a keyed hash and not a real

00:24:46,159 --> 00:24:50,400
signature but if you would use a

00:24:48,480 --> 00:24:52,159
another algorithm you would input here

00:24:50,400 --> 00:24:52,960
the public key so you can verify the

00:24:52,159 --> 00:24:55,039
signature

00:24:52,960 --> 00:24:56,240
um based on that public key so you're

00:24:55,039 --> 00:24:58,159
just going to take the header the

00:24:56,240 --> 00:25:00,080
payload and your secret or public key

00:24:58,159 --> 00:25:01,600
and you can verify the payload has not

00:25:00,080 --> 00:25:03,120
been tempered with so

00:25:01,600 --> 00:25:04,799
like this you know that everything that

00:25:03,120 --> 00:25:05,919
is in the payload was intended to be in

00:25:04,799 --> 00:25:07,279
the payload and nobody

00:25:05,919 --> 00:25:09,360
tried to change something in that

00:25:07,279 --> 00:25:12,080
payload because the payload is part of

00:25:09,360 --> 00:25:12,080
your signature

00:25:12,159 --> 00:25:16,640
key signature now it's happened to jason

00:25:14,880 --> 00:25:18,480
web encryption

00:25:16,640 --> 00:25:20,159
again we see the most common the most

00:25:18,480 --> 00:25:22,000
common format of this is serialized as a

00:25:20,159 --> 00:25:24,159
string but instead of three parts

00:25:22,000 --> 00:25:25,279
it consists out of five parts and this

00:25:24,159 --> 00:25:26,240
is where it gets a little bit more

00:25:25,279 --> 00:25:27,840
complicated

00:25:26,240 --> 00:25:29,679
the first part is our header we've seen

00:25:27,840 --> 00:25:30,640
this with your base64 decode this we get

00:25:29,679 --> 00:25:32,159
it some json

00:25:30,640 --> 00:25:34,960
with some information about this json

00:25:32,159 --> 00:25:37,440
web encryption thingy the second part is

00:25:34,960 --> 00:25:40,159
a json web encryption encrypted key

00:25:37,440 --> 00:25:42,240
so this is the actual key we're going to

00:25:40,159 --> 00:25:42,880
use to decrypt or ciphertext which is a

00:25:42,240 --> 00:25:44,960
four part

00:25:42,880 --> 00:25:46,559
but it's still encrypted so first we

00:25:44,960 --> 00:25:47,760
have to go and decrypt that one before

00:25:46,559 --> 00:25:49,520
we can actually use it

00:25:47,760 --> 00:25:51,279
and the initialization vector the third

00:25:49,520 --> 00:25:53,600
part and the authentication tag

00:25:51,279 --> 00:25:55,120
the fifth part are used to decrypt

00:25:53,600 --> 00:25:58,720
decipher as well

00:25:55,120 --> 00:26:00,240
but um jwe is used to kind of encryption

00:25:58,720 --> 00:26:02,000
and like i've mentioned before

00:26:00,240 --> 00:26:03,760
often when you're dealing with a

00:26:02,000 --> 00:26:04,559
symmetrical encryption you're first

00:26:03,760 --> 00:26:06,159
going to

00:26:04,559 --> 00:26:07,919
uh with symmetrical one sorry you're

00:26:06,159 --> 00:26:09,440
first going to encrypt your actual key

00:26:07,919 --> 00:26:10,159
the key you can use to encrypt and

00:26:09,440 --> 00:26:12,240
decrypt

00:26:10,159 --> 00:26:14,240
with an asymmetrical one so you can then

00:26:12,240 --> 00:26:16,960
decrypt that one with a private key

00:26:14,240 --> 00:26:18,799
um but that's what what's being done

00:26:16,960 --> 00:26:20,559
with json web encryptions

00:26:18,799 --> 00:26:22,080
so the content encryption key the second

00:26:20,559 --> 00:26:24,240
part is usually encrypted with an

00:26:22,080 --> 00:26:26,240
asymmetrical algorithm

00:26:24,240 --> 00:26:27,840
so if we take this second part it's

00:26:26,240 --> 00:26:31,200
going to be an encrypted

00:26:27,840 --> 00:26:33,039
uh secret key so

00:26:31,200 --> 00:26:34,799
and the second part the cipher or third

00:26:33,039 --> 00:26:36,559
part the fifth part fourth part

00:26:34,799 --> 00:26:38,159
the cypher is encrypted using that

00:26:36,559 --> 00:26:39,440
content encryption key which is part of

00:26:38,159 --> 00:26:41,760
the string but still

00:26:39,440 --> 00:26:43,200
encrypted so what we're going to do is

00:26:41,760 --> 00:26:45,120
we're going to look into the header

00:26:43,200 --> 00:26:46,960
and in the header tells us the algorithm

00:26:45,120 --> 00:26:48,880
the encoding our encryption and the

00:26:46,960 --> 00:26:50,320
the key id so now we know which

00:26:48,880 --> 00:26:52,159
algorithms to work with

00:26:50,320 --> 00:26:54,000
so if you want to degrade the content

00:26:52,159 --> 00:26:55,120
encryption key the second part of this

00:26:54,000 --> 00:26:56,960
string

00:26:55,120 --> 00:26:58,799
we're going to check in our header which

00:26:56,960 --> 00:27:00,559
algorithm you need to use rsa

00:26:58,799 --> 00:27:02,000
which we know from the example is an

00:27:00,559 --> 00:27:04,400
asymmetrical one

00:27:02,000 --> 00:27:05,200
um so we're going to take this algorithm

00:27:04,400 --> 00:27:06,880
which

00:27:05,200 --> 00:27:08,400
takes the input the content encryption

00:27:06,880 --> 00:27:10,240
key that is encrypted

00:27:08,400 --> 00:27:12,159
but it also takes a private key because

00:27:10,240 --> 00:27:12,880
it's an asymmetrical ones and to decrypt

00:27:12,159 --> 00:27:16,080
something

00:27:12,880 --> 00:27:17,279
uh we need a private key so we know that

00:27:16,080 --> 00:27:19,360
we have the private key because the

00:27:17,279 --> 00:27:21,440
private key is something keep secret

00:27:19,360 --> 00:27:23,200
and it tells us which the key id so it

00:27:21,440 --> 00:27:24,559
tells us which private key to use

00:27:23,200 --> 00:27:26,240
so by looking into the header we know

00:27:24,559 --> 00:27:27,279
which algorithm to use and we know which

00:27:26,240 --> 00:27:29,760
private key to use

00:27:27,279 --> 00:27:31,679
so when we know those those that those

00:27:29,760 --> 00:27:34,720
details we can actually decrypt

00:27:31,679 --> 00:27:37,520
the json web encryption encrypted key

00:27:34,720 --> 00:27:39,039
and once we decrypt that key we can use

00:27:37,520 --> 00:27:42,080
it to decrypt the actual

00:27:39,039 --> 00:27:44,399
encrypted message decipher

00:27:42,080 --> 00:27:45,600
so again we look into our header which

00:27:44,399 --> 00:27:49,120
algorithm to use

00:27:45,600 --> 00:27:50,880
a23 gcm in this case

00:27:49,120 --> 00:27:53,279
we pass along the cipher the encrypted

00:27:50,880 --> 00:27:55,120
message together with the encrypted

00:27:53,279 --> 00:27:56,799
uh decrypted sorry decrypted content

00:27:55,120 --> 00:27:58,640
encryption key together with the

00:27:56,799 --> 00:28:00,559
initialization vector which is a third

00:27:58,640 --> 00:28:01,679
part which sometimes is empty depending

00:28:00,559 --> 00:28:04,000
on the algorithm

00:28:01,679 --> 00:28:05,279
and together with the authentication tag

00:28:04,000 --> 00:28:07,440
which is the fifth part

00:28:05,279 --> 00:28:09,120
so first we decrypt the actual key and

00:28:07,440 --> 00:28:12,240
then we use that key to do

00:28:09,120 --> 00:28:14,960
decrypt the actual cipher the actual

00:28:12,240 --> 00:28:17,039
the encrypted message it's a bit more

00:28:14,960 --> 00:28:18,880
complicated but that's how json web

00:28:17,039 --> 00:28:21,840
encryption thingies work

00:28:18,880 --> 00:28:24,000
um and both json web signatures jws and

00:28:21,840 --> 00:28:26,159
json web encryption jwe

00:28:24,000 --> 00:28:27,679
can be serialized as compact as a string

00:28:26,159 --> 00:28:29,200
as we've seen before where json web

00:28:27,679 --> 00:28:31,440
signatures have three parts

00:28:29,200 --> 00:28:32,559
and the encryptions are five five parts

00:28:31,440 --> 00:28:34,480
but they can also be

00:28:32,559 --> 00:28:36,240
as serialized as json because it's

00:28:34,480 --> 00:28:37,919
adjacent standards

00:28:36,240 --> 00:28:39,600
where this would be a signature and

00:28:37,919 --> 00:28:41,200
again you see you have your payload you

00:28:39,600 --> 00:28:42,960
have your header you have your signature

00:28:41,200 --> 00:28:43,919
so all of the data is still in this json

00:28:42,960 --> 00:28:45,919
object

00:28:43,919 --> 00:28:47,200
but structured according to the

00:28:45,919 --> 00:28:48,640
specification

00:28:47,200 --> 00:28:50,480
and if you would look at the json web

00:28:48,640 --> 00:28:52,240
encryption thingy this is how it looks

00:28:50,480 --> 00:28:54,000
like

00:28:52,240 --> 00:28:55,919
in the form of json now why would you

00:28:54,000 --> 00:28:58,000
choose one form or the other if you

00:28:55,919 --> 00:28:59,279
have to send it as a header for example

00:28:58,000 --> 00:29:00,559
in an api request

00:28:59,279 --> 00:29:02,159
you might send it as a string because

00:29:00,559 --> 00:29:04,080
it's much shorter but if you have all

00:29:02,159 --> 00:29:07,440
the luxury and all the time and all the

00:29:04,080 --> 00:29:08,159
the the size uh constraints that you

00:29:07,440 --> 00:29:10,320
want

00:29:08,159 --> 00:29:12,000
you can just send the uh the actual json

00:29:10,320 --> 00:29:13,600
object and it's a bit easier to work

00:29:12,000 --> 00:29:15,600
with but most of the time we've used

00:29:13,600 --> 00:29:16,880
these serialized as a string versions of

00:29:15,600 --> 00:29:20,159
json web s

00:29:16,880 --> 00:29:22,320
json web signatures and encryption so

00:29:20,159 --> 00:29:23,679
i've touched on this json token is the

00:29:22,320 --> 00:29:25,600
last one in this hosting standard that i

00:29:23,679 --> 00:29:27,919
want to be talking about

00:29:25,600 --> 00:29:29,279
and a json up token is basically just a

00:29:27,919 --> 00:29:31,919
json signature

00:29:29,279 --> 00:29:34,320
or a json web encryption thingy um where

00:29:31,919 --> 00:29:35,760
most of the time is going to be ajws

00:29:34,320 --> 00:29:37,520
but if you really want to you can also

00:29:35,760 --> 00:29:39,039
encrypt it so nobody can look inside of

00:29:37,520 --> 00:29:42,159
the payloads without

00:29:39,039 --> 00:29:43,520
being able to decrypt the the payloads

00:29:42,159 --> 00:29:46,240
but most of the time it's going to be a

00:29:43,520 --> 00:29:46,240
jws

00:29:47,440 --> 00:29:50,640
where the only difference is going to be

00:29:49,120 --> 00:29:52,399
that in the header you're also going to

00:29:50,640 --> 00:29:54,480
have type json up token

00:29:52,399 --> 00:29:56,000
just so you know that it's going to be a

00:29:54,480 --> 00:29:57,520
token that you have to treat it as a

00:29:56,000 --> 00:30:00,000
token

00:29:57,520 --> 00:30:01,520
and some form of the one of the most

00:30:00,000 --> 00:30:02,960
commonly used tokens these days on the

00:30:01,520 --> 00:30:04,480
web is an access token

00:30:02,960 --> 00:30:06,000
so if you would look into the payload

00:30:04,480 --> 00:30:08,240
you would see some some information

00:30:06,000 --> 00:30:08,960
which is related to an api to access an

00:30:08,240 --> 00:30:10,559
api

00:30:08,960 --> 00:30:12,159
things like the issuer the subject which

00:30:10,559 --> 00:30:14,960
is usually the user id

00:30:12,159 --> 00:30:16,640
the audience and scopes things like this

00:30:14,960 --> 00:30:18,320
if it's an id token it's a token that's

00:30:16,640 --> 00:30:19,600
related to the identity of somebody that

00:30:18,320 --> 00:30:21,039
has authenticated

00:30:19,600 --> 00:30:23,200
so it's going to contain a bunch of

00:30:21,039 --> 00:30:25,520
information about the identity of a user

00:30:23,200 --> 00:30:27,279
inside of the payload

00:30:25,520 --> 00:30:28,960
but they're all json web signatures or

00:30:27,279 --> 00:30:31,600
encryption which means they have a

00:30:28,960 --> 00:30:33,679
they have a payload which you can either

00:30:31,600 --> 00:30:35,120
encrypt and decrypt or you can

00:30:33,679 --> 00:30:36,799
sign so you know that nobody has

00:30:35,120 --> 00:30:39,679
tempered with the payload

00:30:36,799 --> 00:30:41,039
so if we go to the summary hashing

00:30:39,679 --> 00:30:42,880
compresses and makes it virtually

00:30:41,039 --> 00:30:44,000
impossible to get the real data it's a

00:30:42,880 --> 00:30:47,279
one-way function

00:30:44,000 --> 00:30:48,960
with a fixed size output kit hashes

00:30:47,279 --> 00:30:51,360
protect the integrity of the data

00:30:48,960 --> 00:30:53,520
because we introduce a key a secret key

00:30:51,360 --> 00:30:55,360
to these hashing algorithms

00:30:53,520 --> 00:30:57,279
digital signatures allow third parties

00:30:55,360 --> 00:30:59,679
to verify the validity and the origin of

00:30:57,279 --> 00:30:59,679
data

00:31:00,000 --> 00:31:03,519
encryption allows only authorized people

00:31:01,919 --> 00:31:04,000
to treat the data only people who should

00:31:03,519 --> 00:31:07,039
be reading

00:31:04,000 --> 00:31:09,279
the data would be able to read the data

00:31:07,039 --> 00:31:10,080
and the jose is a set of standards based

00:31:09,279 --> 00:31:11,519
on json

00:31:10,080 --> 00:31:13,600
that helps us with signatures and

00:31:11,519 --> 00:31:16,080
encryption on the web and most

00:31:13,600 --> 00:31:18,399
commonly to send them across the web in

00:31:16,080 --> 00:31:19,600
different ways

00:31:18,399 --> 00:31:21,159
again if you would like to see these

00:31:19,600 --> 00:31:23,760
slides they're going to be here on

00:31:21,159 --> 00:31:25,279
jose.obtech forever they might evolve

00:31:23,760 --> 00:31:26,480
but the essence is always going to be

00:31:25,279 --> 00:31:28,240
the same

00:31:26,480 --> 00:31:30,799
um if you want to know more about json

00:31:28,240 --> 00:31:33,519
web tokens jwt dot io

00:31:30,799 --> 00:31:34,080
our blog has a few very interesting uh

00:31:33,519 --> 00:31:36,799
articles

00:31:34,080 --> 00:31:38,880
other.com blog that being said thank you

00:31:36,799 --> 00:31:41,760
very much

00:31:38,880 --> 00:31:43,440
thanks thanks so much sam yeah there was

00:31:41,760 --> 00:31:44,000
a lot of content in there so i'm glad

00:31:43,440 --> 00:31:46,480
you said

00:31:44,000 --> 00:31:47,440
the the slides are available to

00:31:46,480 --> 00:31:49,919
everybody

00:31:47,440 --> 00:31:51,440
yeah um thanks so much for the talk that

00:31:49,919 --> 00:31:54,480
was that was awesome

00:31:51,440 --> 00:31:56,320
um yeah uh

00:31:54,480 --> 00:31:58,159
i guess we got a few questions in the

00:31:56,320 --> 00:32:00,399
chat which is a good place to start i've

00:31:58,159 --> 00:32:02,399
also got one or two of my own and um

00:32:00,399 --> 00:32:03,679
there's there's maybe just a little bit

00:32:02,399 --> 00:32:07,120
of um

00:32:03,679 --> 00:32:10,480
uh of a kind of um base level

00:32:07,120 --> 00:32:13,120
uh understanding of um encryption

00:32:10,480 --> 00:32:13,519
and and algorithms that a lot of people

00:32:13,120 --> 00:32:15,360
don't

00:32:13,519 --> 00:32:16,559
have we can't take a lot of these things

00:32:15,360 --> 00:32:19,679
for granted

00:32:16,559 --> 00:32:23,279
mentioned um tls

00:32:19,679 --> 00:32:26,240
yeah so so what actually is tlsn so

00:32:23,279 --> 00:32:28,080
it has a way of um it has some way of

00:32:26,240 --> 00:32:29,919
encrypting data which is which is really

00:32:28,080 --> 00:32:30,799
useful for us right stops man in the

00:32:29,919 --> 00:32:33,679
middle attacks

00:32:30,799 --> 00:32:35,440
right stops people seeing our data as it

00:32:33,679 --> 00:32:38,240
flies around the internet but

00:32:35,440 --> 00:32:41,120
um does it use just one preferred

00:32:38,240 --> 00:32:43,519
algorithm does it use multiple

00:32:41,120 --> 00:32:44,640
there's usually a whole range of

00:32:43,519 --> 00:32:46,399
algorithms you can use

00:32:44,640 --> 00:32:47,760
and they all have their strengths and

00:32:46,399 --> 00:32:51,120
weaknesses um

00:32:47,760 --> 00:32:54,240
but i think if i go back to my slides

00:32:51,120 --> 00:32:56,080
which is quite back tls we had them with

00:32:54,240 --> 00:32:58,240
asymmetrical encryption which means it

00:32:56,080 --> 00:33:01,200
still uses a public and a private key

00:32:58,240 --> 00:33:01,919
to do the encryption um so what what's

00:33:01,200 --> 00:33:03,279
what's uh

00:33:01,919 --> 00:33:04,799
being used with tls is something

00:33:03,279 --> 00:33:06,000
asymmetrical instead of a symmetrical

00:33:04,799 --> 00:33:07,519
algorithm but in this

00:33:06,000 --> 00:33:09,519
range of asymmetrical encryption

00:33:07,519 --> 00:33:10,960
algorithms there's a whole bunch of them

00:33:09,519 --> 00:33:13,120
and depending on what you choose for

00:33:10,960 --> 00:33:15,519
what reason um they should all be okay

00:33:13,120 --> 00:33:15,519
to use

00:33:15,679 --> 00:33:20,399
right awesome um yeah

00:33:19,039 --> 00:33:22,000
i'm definitely gonna i'm definitely

00:33:20,399 --> 00:33:23,919
gonna pick over this so i'm gonna call

00:33:22,000 --> 00:33:25,200
out a couple of questions people had so

00:33:23,919 --> 00:33:27,440
one was about

00:33:25,200 --> 00:33:29,279
um those very large numbers those prime

00:33:27,440 --> 00:33:32,240
numbers you you talked about

00:33:29,279 --> 00:33:33,760
um so yeah the question was from um

00:33:32,240 --> 00:33:36,159
september do you do you want to ask it

00:33:33,760 --> 00:33:36,159
yourself

00:33:36,320 --> 00:33:43,039
uh yes thank you uh you first of all

00:33:40,159 --> 00:33:45,279
great uh you deciphered this complex

00:33:43,039 --> 00:33:48,320
topic really well

00:33:45,279 --> 00:33:51,120
um so

00:33:48,320 --> 00:33:52,080
uh you mentioned that we are using

00:33:51,120 --> 00:33:54,640
really really

00:33:52,080 --> 00:33:56,559
large prime numbers then i wondered how

00:33:54,640 --> 00:33:57,279
can one produce such a prime number

00:33:56,559 --> 00:34:00,000
because

00:33:57,279 --> 00:34:01,840
the search will be like we will need

00:34:00,000 --> 00:34:04,240
immense amount of time to find such a

00:34:01,840 --> 00:34:06,480
prime number how does one find it

00:34:04,240 --> 00:34:08,000
well there's also algorithms to do that

00:34:06,480 --> 00:34:09,280
um if you're a mathematician that's

00:34:08,000 --> 00:34:10,480
something you might deal with on a

00:34:09,280 --> 00:34:12,879
regular basis

00:34:10,480 --> 00:34:15,040
i am not but if you look in this example

00:34:12,879 --> 00:34:17,919
that i showed so maybe i can zoom in

00:34:15,040 --> 00:34:18,960
a little bit we have this function get

00:34:17,919 --> 00:34:21,040
random prime

00:34:18,960 --> 00:34:22,159
which is one of the algorithms that you

00:34:21,040 --> 00:34:25,520
could use um

00:34:22,159 --> 00:34:26,320
to to generate large random prime

00:34:25,520 --> 00:34:28,000
numbers so this

00:34:26,320 --> 00:34:29,679
this function will always spit out a

00:34:28,000 --> 00:34:31,440
large random prime number

00:34:29,679 --> 00:34:33,119
and you can also say how big it needs to

00:34:31,440 --> 00:34:35,359
be so it's

00:34:33,119 --> 00:34:37,280
i think 10-ish lines of code but it will

00:34:35,359 --> 00:34:38,320
do that for you there's more efficient

00:34:37,280 --> 00:34:41,119
algorithms out there

00:34:38,320 --> 00:34:41,919
which are a bit more complicated but um

00:34:41,119 --> 00:34:42,879
what you need to

00:34:41,919 --> 00:34:44,480
need to remember is that there's

00:34:42,879 --> 00:34:46,240
mathematical algorithms that will

00:34:44,480 --> 00:34:47,119
generate these large prime numbers for

00:34:46,240 --> 00:34:50,879
you

00:34:47,119 --> 00:34:52,560
does anyone else have uh have a question

00:34:50,879 --> 00:34:54,320
for sam i'm not sure if it's really

00:34:52,560 --> 00:34:57,359
something that can be answered

00:34:54,320 --> 00:34:58,960
uh because i was i was reading articles

00:34:57,359 --> 00:35:01,839
about like quantum computers

00:34:58,960 --> 00:35:03,280
and kind of like how they can be used to

00:35:01,839 --> 00:35:04,480
break certain encryptions

00:35:03,280 --> 00:35:07,200
do you think do you know anything about

00:35:04,480 --> 00:35:09,119
that or is that is that an issue yeah so

00:35:07,200 --> 00:35:11,040
the reason why these algorithms that i

00:35:09,119 --> 00:35:13,440
just talked about are so secure are

00:35:11,040 --> 00:35:14,960
because they use these very big large

00:35:13,440 --> 00:35:16,240
numbers and if you want to brute force

00:35:14,960 --> 00:35:17,520
it means that you have to calculate

00:35:16,240 --> 00:35:20,160
every prime number

00:35:17,520 --> 00:35:22,480
from zero until you reach those kind of

00:35:20,160 --> 00:35:23,920
numbers which is very intensive and

00:35:22,480 --> 00:35:25,760
practically impossible with our current

00:35:23,920 --> 00:35:26,480
computing power if you take quantum

00:35:25,760 --> 00:35:28,640
computers

00:35:26,480 --> 00:35:31,040
they are so much faster than our current

00:35:28,640 --> 00:35:32,960
computers so they would be able to

00:35:31,040 --> 00:35:34,079
theoretically crack these large numbers

00:35:32,960 --> 00:35:36,640
or brute forces

00:35:34,079 --> 00:35:37,920
in a very fast time so um i get this

00:35:36,640 --> 00:35:39,280
question a lot and

00:35:37,920 --> 00:35:40,480
currently there's no solution to this

00:35:39,280 --> 00:35:41,839
because we don't really have quantum

00:35:40,480 --> 00:35:43,200
computers yet it's something they're

00:35:41,839 --> 00:35:45,200
working on but i'm sure

00:35:43,200 --> 00:35:46,480
once we have quantum computers there's

00:35:45,200 --> 00:35:46,880
also going to be people who are going to

00:35:46,480 --> 00:35:49,760
create

00:35:46,880 --> 00:35:50,720
quantum encryption and decryption

00:35:49,760 --> 00:35:52,720
algorithms so

00:35:50,720 --> 00:35:54,320
um it's going to use the same thing but

00:35:52,720 --> 00:35:57,200
then even numbers that are

00:35:54,320 --> 00:35:59,440
even bigger i guess does that make sense

00:35:57,200 --> 00:36:01,920
no that makes that makes sense yeah

00:35:59,440 --> 00:36:03,599
cool cheers i think um dwayne had a

00:36:01,920 --> 00:36:06,880
question as well actually

00:36:03,599 --> 00:36:09,280
yeah about a2b and b2a in the browser um

00:36:06,880 --> 00:36:11,200
that's like he mentioned it's encoding

00:36:09,280 --> 00:36:12,000
and decoding that's base64 encoding and

00:36:11,200 --> 00:36:14,320
decoding which

00:36:12,000 --> 00:36:15,839
is still something else it does not

00:36:14,320 --> 00:36:17,839
create a fixed out

00:36:15,839 --> 00:36:19,280
a length output depending on input for

00:36:17,839 --> 00:36:20,880
example so it's not hashing

00:36:19,280 --> 00:36:22,079
it's closer to hashing than any of the

00:36:20,880 --> 00:36:23,359
other things i talked about but it's

00:36:22,079 --> 00:36:26,640
still something else

00:36:23,359 --> 00:36:29,359
um you're just going to encode it in a

00:36:26,640 --> 00:36:30,960
different way so that's not secure at

00:36:29,359 --> 00:36:32,720
all by the way um

00:36:30,960 --> 00:36:34,160
or something that's basically foreign

00:36:32,720 --> 00:36:35,119
code it's somewhere it's usually just

00:36:34,160 --> 00:36:38,000
used to

00:36:35,119 --> 00:36:38,800
reduce the size of a string um most of

00:36:38,000 --> 00:36:40,880
the time it's

00:36:38,800 --> 00:36:43,520
it's smaller but that's about the only

00:36:40,880 --> 00:36:46,000
use case you have for it

00:36:43,520 --> 00:36:47,760
yeah good thing that uh you qualify that

00:36:46,000 --> 00:36:49,839
before anyone starts

00:36:47,760 --> 00:36:52,079
not to store a password at all the

00:36:49,839 --> 00:36:55,200
output looks like a hash but it is not a

00:36:52,079 --> 00:36:55,200
hash at all wow

00:36:55,440 --> 00:36:59,359
great any other questions before we

00:36:57,440 --> 00:37:02,000
close up any thoughts on the web

00:36:59,359 --> 00:37:03,440
of authentication api well i have a

00:37:02,000 --> 00:37:05,119
whole talk about that if you really want

00:37:03,440 --> 00:37:08,240
to hear my thoughts

00:37:05,119 --> 00:37:09,839
but the newest cool thing about web

00:37:08,240 --> 00:37:12,079
authentic authentication api

00:37:09,839 --> 00:37:13,599
is also public and private key based

00:37:12,079 --> 00:37:14,480
authentication on the web which means

00:37:13,599 --> 00:37:17,280
you can use

00:37:14,480 --> 00:37:18,079
a ubi key or a titan key or a google

00:37:17,280 --> 00:37:19,520
whatever

00:37:18,079 --> 00:37:21,200
key it's called or you can use your

00:37:19,520 --> 00:37:23,280
touch id or something and

00:37:21,200 --> 00:37:25,040
built into your device to generate a

00:37:23,280 --> 00:37:26,560
public and private key pair and then

00:37:25,040 --> 00:37:28,079
authenticate using that public and

00:37:26,560 --> 00:37:29,280
private key pair instead of using a

00:37:28,079 --> 00:37:31,839
password for example

00:37:29,280 --> 00:37:32,640
so i think it's the future um adaption

00:37:31,839 --> 00:37:34,400
is getting

00:37:32,640 --> 00:37:36,079
along very slowly it's getting better

00:37:34,400 --> 00:37:39,119
and better and better um but it's

00:37:36,079 --> 00:37:40,880
certainly something to keep an eye on

00:37:39,119 --> 00:37:42,640
yeah i'm glad that question was asked

00:37:40,880 --> 00:37:45,680
i'm a fan of it because of

00:37:42,640 --> 00:37:47,760
um the clear benefits to to the user

00:37:45,680 --> 00:37:48,800
right i mean just so much there's so

00:37:47,760 --> 00:37:51,680
much convenience

00:37:48,800 --> 00:37:53,040
when uh when a browser supports a

00:37:51,680 --> 00:37:55,359
feature like this

00:37:53,040 --> 00:37:57,119
um yeah support is really good by the

00:37:55,359 --> 00:37:57,520
way all major browsers support it these

00:37:57,119 --> 00:38:00,240
days

00:37:57,520 --> 00:38:01,520
in some form of the other um and i think

00:38:00,240 --> 00:38:03,119
google githubs

00:38:01,520 --> 00:38:05,040
all of the bigger players also have some

00:38:03,119 --> 00:38:07,680
kind of support for it as

00:38:05,040 --> 00:38:08,560
a second factor or as first factor um

00:38:07,680 --> 00:38:11,839
depending on

00:38:08,560 --> 00:38:13,040
the service itself yeah yeah it's a

00:38:11,839 --> 00:38:16,079
great way of

00:38:13,040 --> 00:38:18,400
of managing credentials across

00:38:16,079 --> 00:38:19,200
different different devices that you

00:38:18,400 --> 00:38:22,240
have and

00:38:19,200 --> 00:38:23,839
yeah it's so i've made a note sam to um

00:38:22,240 --> 00:38:27,200
to ask you back at some point

00:38:23,839 --> 00:38:30,400
for your talk on that um

00:38:27,200 --> 00:38:33,440
yeah brilliant um okay

00:38:30,400 --> 00:38:36,400
i think we should wrap up um but uh

00:38:33,440 --> 00:38:37,440
thank you so much to both of our

00:38:36,400 --> 00:38:40,400
speakers

00:38:37,440 --> 00:38:42,320
uh sam and dwayne who both uh as i said

00:38:40,400 --> 00:38:44,000
earlier beamed in from uh across the

00:38:42,320 --> 00:38:46,000
world where we're going proper

00:38:44,000 --> 00:38:47,760
international these days and and why not

00:38:46,000 --> 00:38:51,680
right we're we're online

00:38:47,760 --> 00:38:53,359
um but uh yeah i understand dwayne

00:38:51,680 --> 00:38:54,720
i would love you to come over to the uk

00:38:53,359 --> 00:38:56,320
sometime maybe

00:38:54,720 --> 00:38:58,320
uh you know we can hope for that in the

00:38:56,320 --> 00:39:02,800
next 12 months who knows but

00:38:58,320 --> 00:39:05,119
um yeah yeah so round of applause for

00:39:02,800 --> 00:39:07,040
for our speakers i can see lots of

00:39:05,119 --> 00:39:08,640
thanks appearing in the chat

00:39:07,040 --> 00:39:10,079
uh i guess a round of applause doesn't

00:39:08,640 --> 00:39:11,839
work that well online but

00:39:10,079 --> 00:39:13,119
uh yeah i know everyone really

00:39:11,839 --> 00:39:16,079
appreciates all the

00:39:13,119 --> 00:39:17,760
effort you put in uh yeah both really

00:39:16,079 --> 00:39:19,760
insightful talks thank you so much

00:39:17,760 --> 00:39:22,720
uh and thanks everyone for joining i'll

00:39:19,760 --> 00:39:22,720
see you in

00:39:26,839 --> 00:39:29,839
february

00:39:31,320 --> 00:39:36,469
[Music]

00:39:38,359 --> 00:39:41,359

YouTube URL: https://www.youtube.com/watch?v=dpm00tLhSc4


