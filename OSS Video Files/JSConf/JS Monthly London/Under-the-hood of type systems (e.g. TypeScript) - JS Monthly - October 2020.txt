Title: Under-the-hood of type systems (e.g. TypeScript) - JS Monthly - October 2020
Publication date: 2020-11-12
Playlist: JS Monthly London
Description: 
	Under-the-hood of type systems (e.g. TypeScript) // Craig Taub
This talk was presented live at JS Monthly, to see the Q&A you can view the original live-stream: https://youtu.be/OArbAGhVIF4

This talk aims to shine a light on some of the fundamentals at work under-the-hood for type systems such as TypeScript or Flow. It is not possible to focus on everything in 1 article so here we will be looking at "type checks" specifically.

Starting with an overview of type systems then building our own compiler which can run type checks and output sensible messages.

A blog post for this video can be found here: https://craigtaub.dev/under-the-hood-of-type-systems

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,080 --> 00:00:05,600
so hi everyone my name is craig um

00:00:03,360 --> 00:00:06,640
i struggled to find an explanation from

00:00:05,600 --> 00:00:08,639
a low-level view

00:00:06,640 --> 00:00:10,400
of exactly how a javascript type system

00:00:08,639 --> 00:00:12,240
compiler is implemented

00:00:10,400 --> 00:00:14,320
i understood many of the jobs of the

00:00:12,240 --> 00:00:15,839
type system but was really unsure on the

00:00:14,320 --> 00:00:17,039
mechanisms involved and how they work

00:00:15,839 --> 00:00:19,039
together

00:00:17,039 --> 00:00:20,560
so this talk aims to shine a light on

00:00:19,039 --> 00:00:22,720
the fundamentals at work

00:00:20,560 --> 00:00:24,640
under the hood it's not possible to

00:00:22,720 --> 00:00:25,920
focus on everything in one talk

00:00:24,640 --> 00:00:28,080
so here we're going to be looking at

00:00:25,920 --> 00:00:30,000
type checks specifically we're going to

00:00:28,080 --> 00:00:31,599
start with an overview of type systems

00:00:30,000 --> 00:00:33,760
then build our own compiler which can

00:00:31,599 --> 00:00:35,600
run type checks and output some sensible

00:00:33,760 --> 00:00:38,239
messages

00:00:35,600 --> 00:00:40,160
so first a little bit about me i'm

00:00:38,239 --> 00:00:42,559
producing an under the hood of series

00:00:40,160 --> 00:00:44,719
which this is actually a part of so far

00:00:42,559 --> 00:00:46,879
it includes webpack react hooks

00:00:44,719 --> 00:00:47,840
source maps vs code and there's a couple

00:00:46,879 --> 00:00:49,600
of others

00:00:47,840 --> 00:00:51,440
uh they usually include building a small

00:00:49,600 --> 00:00:53,840
proof of concept to demonstrate the

00:00:51,440 --> 00:00:55,920
internal mechanisms of the tool

00:00:53,840 --> 00:00:58,399
i'm an engineer at fit where a startup

00:00:55,920 --> 00:01:00,239
helping people create fitness habits

00:00:58,399 --> 00:01:01,840
i'm a member of the mocha core team for

00:01:00,239 --> 00:01:03,440
a little over two and a half years

00:01:01,840 --> 00:01:05,040
so i'm a big advocate of testing and

00:01:03,440 --> 00:01:06,240
open source

00:01:05,040 --> 00:01:08,560
i'm a big football fan of the

00:01:06,240 --> 00:01:12,479
championship club qpr and you can find

00:01:08,560 --> 00:01:14,720
me on twitter and github at craigtob

00:01:12,479 --> 00:01:16,159
so this talk is going to be broken down

00:01:14,720 --> 00:01:18,880
into two parts

00:01:16,159 --> 00:01:20,479
uh plan a pi is going to be an overview

00:01:18,880 --> 00:01:22,320
of type system compilers

00:01:20,479 --> 00:01:24,240
including typescript we're going to look

00:01:22,320 --> 00:01:27,439
at syntax versus semantics

00:01:24,240 --> 00:01:28,880
what is ast types of compilers language

00:01:27,439 --> 00:01:30,720
compilers on their jobs

00:01:28,880 --> 00:01:32,159
and then part b will be building our own

00:01:30,720 --> 00:01:34,720
type system compiler

00:01:32,159 --> 00:01:35,920
which looks like the pasta the checker

00:01:34,720 --> 00:01:38,400
running our own compiler

00:01:35,920 --> 00:01:40,079
and then finally what have we missed and

00:01:38,400 --> 00:01:42,240
that's going to be having a look at what

00:01:40,079 --> 00:01:45,040
the things that ours do not do that most

00:01:42,240 --> 00:01:48,720
other compilers would do

00:01:45,040 --> 00:01:48,720
so let's start with an overview

00:01:48,880 --> 00:01:52,000
so something which is important to run

00:01:50,479 --> 00:01:54,560
over early is the difference between

00:01:52,000 --> 00:01:56,240
syntax and semantics syntax

00:01:54,560 --> 00:01:58,560
is typically code which is native to

00:01:56,240 --> 00:02:00,000
javascript you're essentially asking if

00:01:58,560 --> 00:02:01,439
the given code is correct for the

00:02:00,000 --> 00:02:02,880
javascript runtime

00:02:01,439 --> 00:02:05,040
for example the below might be

00:02:02,880 --> 00:02:07,600
syntactically correct although

00:02:05,040 --> 00:02:08,879
ignoring the the type and then some and

00:02:07,600 --> 00:02:10,959
then the semantics

00:02:08,879 --> 00:02:12,239
so this is code specific to the type

00:02:10,959 --> 00:02:14,000
system that is

00:02:12,239 --> 00:02:15,599
essentially asking if the given types

00:02:14,000 --> 00:02:16,959
attached to the code are correct

00:02:15,599 --> 00:02:19,120
for example the above could be

00:02:16,959 --> 00:02:20,959
syntactically correct but semantically

00:02:19,120 --> 00:02:21,520
wrong as we're defining a variable with

00:02:20,959 --> 00:02:24,879
a number

00:02:21,520 --> 00:02:26,879
but setting it as a string so

00:02:24,879 --> 00:02:28,000
before we go much further we need to

00:02:26,879 --> 00:02:29,599
take a quick look at one of the

00:02:28,000 --> 00:02:30,720
important mechanisms inside of any

00:02:29,599 --> 00:02:33,840
javascript compiler

00:02:30,720 --> 00:02:34,720
that's ast so ast stands for abstract

00:02:33,840 --> 00:02:36,879
syntax tree

00:02:34,720 --> 00:02:39,040
as i'm sure many of you are aware it's

00:02:36,879 --> 00:02:42,319
basically a tree of nodes

00:02:39,040 --> 00:02:44,000
representing a program of code a node

00:02:42,319 --> 00:02:45,680
being the smallest possible unit

00:02:44,000 --> 00:02:48,800
and is basically a plain old javascript

00:02:45,680 --> 00:02:50,879
object with type and location properties

00:02:48,800 --> 00:02:51,840
all nodes have those two properties but

00:02:50,879 --> 00:02:53,200
based on the type

00:02:51,840 --> 00:02:55,120
they can have various other properties

00:02:53,200 --> 00:02:57,920
as well so

00:02:55,120 --> 00:02:58,800
in ast form code is very easy to

00:02:57,920 --> 00:03:00,319
manipulate

00:02:58,800 --> 00:03:02,080
so operations like adding to code

00:03:00,319 --> 00:03:03,280
removing or even replacing parts becomes

00:03:02,080 --> 00:03:04,959
much easier

00:03:03,280 --> 00:03:07,120
an example is the code at the top you

00:03:04,959 --> 00:03:09,440
can the image and then just below that

00:03:07,120 --> 00:03:11,920
is the ast would produce and there are

00:03:09,440 --> 00:03:13,120
websites such as astxplorer.net

00:03:11,920 --> 00:03:14,400
which are great at letting you write

00:03:13,120 --> 00:03:18,080
some javascript code and then

00:03:14,400 --> 00:03:19,920
immediately seeing its ast

00:03:18,080 --> 00:03:22,400
there are really two types of compilers

00:03:19,920 --> 00:03:24,239
which exist there are native compilers

00:03:22,400 --> 00:03:26,319
which convert code into a form that can

00:03:24,239 --> 00:03:28,799
be run by a server or a computer

00:03:26,319 --> 00:03:30,640
uh ie machine code a compiler such as

00:03:28,799 --> 00:03:32,640
the one funding the java ecosystem

00:03:30,640 --> 00:03:34,319
converts code into bytecode and then

00:03:32,640 --> 00:03:35,760
into native machine code

00:03:34,319 --> 00:03:37,360
and then there's a language compiler

00:03:35,760 --> 00:03:39,760
which is quite a different role

00:03:37,360 --> 00:03:41,440
the compilers for typescript and flow

00:03:39,760 --> 00:03:44,000
and most other javascript

00:03:41,440 --> 00:03:44,959
tools both count in the category as

00:03:44,000 --> 00:03:47,519
language compilers

00:03:44,959 --> 00:03:49,200
as they output code into javascript the

00:03:47,519 --> 00:03:51,200
main difference with nato compilers

00:03:49,200 --> 00:03:53,439
is that they compile for for tooling's

00:03:51,200 --> 00:03:55,040
sake so for optimizing code performance

00:03:53,439 --> 00:03:57,280
or for adding additional features

00:03:55,040 --> 00:03:59,120
not to produce the machine code they all

00:03:57,280 --> 00:04:00,080
still rely on the javascript runtime

00:03:59,120 --> 00:04:03,200
native compiler

00:04:00,080 --> 00:04:05,439
to do that so

00:04:03,200 --> 00:04:06,560
a few of the core jobs found in any type

00:04:05,439 --> 00:04:09,360
system

00:04:06,560 --> 00:04:11,120
are one performing type checks by this i

00:04:09,360 --> 00:04:13,439
mean the introduction of types

00:04:11,120 --> 00:04:14,959
often via explicit annotations or

00:04:13,439 --> 00:04:16,799
implicit inference

00:04:14,959 --> 00:04:18,320
and a way to check that one type matches

00:04:16,799 --> 00:04:20,799
another

00:04:18,320 --> 00:04:21,759
and then there's transf two transforming

00:04:20,799 --> 00:04:23,680
code

00:04:21,759 --> 00:04:25,440
many type systems contain code which is

00:04:23,680 --> 00:04:27,120
not supported in native javascript

00:04:25,440 --> 00:04:28,960
for example type annotations are not

00:04:27,120 --> 00:04:31,199
supportive supported

00:04:28,960 --> 00:04:33,360
so they must transform from unsupported

00:04:31,199 --> 00:04:35,040
javascript to supported javascript

00:04:33,360 --> 00:04:37,360
i actually explore transforming code

00:04:35,040 --> 00:04:39,759
more in my post on web bundlers

00:04:37,360 --> 00:04:40,560
and my posts and source maps and then

00:04:39,759 --> 00:04:42,880
three

00:04:40,560 --> 00:04:44,240
run from a language server so for a type

00:04:42,880 --> 00:04:44,960
system to work in a development

00:04:44,240 --> 00:04:46,800
environment

00:04:44,960 --> 00:04:48,400
it's best if it can run any type checks

00:04:46,800 --> 00:04:50,320
in an ide and provide

00:04:48,400 --> 00:04:52,400
instant feedback for the user so

00:04:50,320 --> 00:04:54,560
language servers connect the type system

00:04:52,400 --> 00:04:55,440
to an ide they can run the compiler in

00:04:54,560 --> 00:04:58,160
the background

00:04:55,440 --> 00:04:59,199
and re-run when a user saves a file

00:04:58,160 --> 00:05:00,960
popular languages

00:04:59,199 --> 00:05:02,639
such as typescript from flow both

00:05:00,960 --> 00:05:05,360
contain a language server

00:05:02,639 --> 00:05:07,280
so for vs code users the main extension

00:05:05,360 --> 00:05:08,880
spawns a language server

00:05:07,280 --> 00:05:10,320
you can actually see my blog post on vs

00:05:08,880 --> 00:05:11,360
code for a bit more of an in-depth look

00:05:10,320 --> 00:05:13,440
at those

00:05:11,360 --> 00:05:14,400
so as mentioned at the start we're just

00:05:13,440 --> 00:05:16,240
going to be focusing

00:05:14,400 --> 00:05:18,479
on point one today so that's performing

00:05:16,240 --> 00:05:21,600
type checks

00:05:18,479 --> 00:05:22,560
so how does a language compiler work so

00:05:21,600 --> 00:05:24,479
now we're going to look at a couple of

00:05:22,560 --> 00:05:26,160
the steps required to perform

00:05:24,479 --> 00:05:27,840
all the previously mentioned jobs in an

00:05:26,160 --> 00:05:29,520
efficient and scalable way

00:05:27,840 --> 00:05:31,919
there are three common jobs to most

00:05:29,520 --> 00:05:32,720
compilers in some form of an error of

00:05:31,919 --> 00:05:34,560
another

00:05:32,720 --> 00:05:35,919
step one is where you pass the source

00:05:34,560 --> 00:05:38,160
code into ast

00:05:35,919 --> 00:05:39,440
this involves lexical analysis which is

00:05:38,160 --> 00:05:41,440
turning a string of code

00:05:39,440 --> 00:05:42,639
into a stream of tokens and then

00:05:41,440 --> 00:05:44,639
syntactic analysis

00:05:42,639 --> 00:05:46,560
where we turn our stream of tokens into

00:05:44,639 --> 00:05:48,720
its ast representation

00:05:46,560 --> 00:05:50,400
passes are responsible for checking the

00:05:48,720 --> 00:05:52,320
syntax of the given code

00:05:50,400 --> 00:05:53,520
a type system will typically have to

00:05:52,320 --> 00:05:55,120
house its own parser

00:05:53,520 --> 00:05:56,800
often containing thousands of lines of

00:05:55,120 --> 00:05:58,880
code there are

00:05:56,800 --> 00:06:00,400
a lot of them are open source like babel

00:05:58,880 --> 00:06:02,160
and typescript but actually a lot of the

00:06:00,400 --> 00:06:04,960
the bigger libraries house their own

00:06:02,160 --> 00:06:05,759
so the babel parser is just over 2 000

00:06:04,960 --> 00:06:07,840
lines of code

00:06:05,759 --> 00:06:09,680
to process the code statements which can

00:06:07,840 --> 00:06:10,080
understand the syntactical analysis of

00:06:09,680 --> 00:06:12,800
any

00:06:10,080 --> 00:06:15,280
compiler specific code but also append

00:06:12,800 --> 00:06:18,160
the additional information for types

00:06:15,280 --> 00:06:19,919
the hegel compiler parser attends

00:06:18,160 --> 00:06:20,880
appends an additional type annotation

00:06:19,919 --> 00:06:23,520
property to code

00:06:20,880 --> 00:06:24,960
which is a type annotation and actually

00:06:23,520 --> 00:06:28,000
we'll be looking a bit more at that

00:06:24,960 --> 00:06:30,800
shortly typescript compiler types gets

00:06:28,000 --> 00:06:31,360
passes sorry is a whopping 8600 lines of

00:06:30,800 --> 00:06:33,120
code

00:06:31,360 --> 00:06:35,199
it houses an entire superset of

00:06:33,120 --> 00:06:36,240
javascript which requires the parser to

00:06:35,199 --> 00:06:38,160
understand all of it

00:06:36,240 --> 00:06:39,919
so it's far larger than most that you

00:06:38,160 --> 00:06:42,639
find step two

00:06:39,919 --> 00:06:44,880
is where we transform the nodes on ast

00:06:42,639 --> 00:06:47,039
where we manipulate the ast nodes

00:06:44,880 --> 00:06:48,800
here any transformations to apply to the

00:06:47,039 --> 00:06:50,400
st are performed

00:06:48,800 --> 00:06:52,639
and then the final step is to generate

00:06:50,400 --> 00:06:54,560
source code so here we're going to turn

00:06:52,639 --> 00:06:56,960
ast into a string of javascript source

00:06:54,560 --> 00:06:59,120
code the type system has to map any

00:06:56,960 --> 00:07:02,000
non-js compliant ast

00:06:59,120 --> 00:07:05,599
back to native.js so how does a type

00:07:02,000 --> 00:07:07,680
system file a compiler fit into this

00:07:05,599 --> 00:07:09,440
as well as the mentioned steps type

00:07:07,680 --> 00:07:10,880
system compilers will usually include an

00:07:09,440 --> 00:07:13,360
additional step or two

00:07:10,880 --> 00:07:15,440
after passing which we which will

00:07:13,360 --> 00:07:18,080
include the type specific work

00:07:15,440 --> 00:07:20,319
so on a side note typesc actually has a

00:07:18,080 --> 00:07:22,000
total of five phases in its compiler

00:07:20,319 --> 00:07:24,479
and they are the language server

00:07:22,000 --> 00:07:27,039
preprocessor which works via import

00:07:24,479 --> 00:07:28,400
the parser the binder the checker and

00:07:27,039 --> 00:07:30,560
the emitter

00:07:28,400 --> 00:07:32,400
so as you can see it's got a

00:07:30,560 --> 00:07:33,759
preprocessor which triggers the type

00:07:32,400 --> 00:07:36,000
compiler to only run

00:07:33,759 --> 00:07:37,680
over the files which have changed this

00:07:36,000 --> 00:07:39,039
will follow any import statements

00:07:37,680 --> 00:07:41,039
to determine what else could have

00:07:39,039 --> 00:07:42,840
changed i would need to be included in

00:07:41,039 --> 00:07:45,440
the next rerun

00:07:42,840 --> 00:07:47,919
additionally the typescript compiler

00:07:45,440 --> 00:07:50,000
actually has the ability to reprocess

00:07:47,919 --> 00:07:52,080
to only reprocess the node tree branch

00:07:50,000 --> 00:07:53,360
or the asd graph which has changed

00:07:52,080 --> 00:07:55,440
that's actually a technique known as

00:07:53,360 --> 00:07:57,280
lazy compilation so

00:07:55,440 --> 00:08:00,160
previously run ast can be stored in

00:07:57,280 --> 00:08:01,599
memory which it calls look aside tables

00:08:00,160 --> 00:08:04,639
and then that allows for even faster

00:08:01,599 --> 00:08:04,639
compilation in the future

00:08:05,199 --> 00:08:09,440
so for general type system compilers

00:08:07,759 --> 00:08:12,319
there are two common jobs

00:08:09,440 --> 00:08:14,000
there's inferring so inferring is

00:08:12,319 --> 00:08:15,520
required for code which does not have an

00:08:14,000 --> 00:08:17,680
annotation

00:08:15,520 --> 00:08:19,680
using a predefined algorithm the engine

00:08:17,680 --> 00:08:20,319
will calculate what type for a given

00:08:19,680 --> 00:08:22,479
variable

00:08:20,319 --> 00:08:23,919
what what the type for a given variable

00:08:22,479 --> 00:08:25,919
a function is

00:08:23,919 --> 00:08:27,280
typescript uses the algorithm best

00:08:25,919 --> 00:08:28,879
common type

00:08:27,280 --> 00:08:31,039
and it applies inside of its binding

00:08:28,879 --> 00:08:33,519
phase which is the first of two

00:08:31,039 --> 00:08:34,560
semantic passes it considers each

00:08:33,519 --> 00:08:36,399
candidate type

00:08:34,560 --> 00:08:38,159
and picks the type that is compatible

00:08:36,399 --> 00:08:40,240
with all other types

00:08:38,159 --> 00:08:41,680
contextual typing comes into play here

00:08:40,240 --> 00:08:43,279
which is using their location in the

00:08:41,680 --> 00:08:45,120
inference

00:08:43,279 --> 00:08:47,680
typescript actually introduces the idea

00:08:45,120 --> 00:08:48,320
of symbols these are named declarations

00:08:47,680 --> 00:08:50,959
which connect

00:08:48,320 --> 00:08:52,640
declaration nodes in the ast to other

00:08:50,959 --> 00:08:53,519
declarations contributing to the same

00:08:52,640 --> 00:08:54,880
entity

00:08:53,519 --> 00:08:56,959
they are the basic building block of the

00:08:54,880 --> 00:08:58,080
typescript semantic system and actually

00:08:56,959 --> 00:08:59,920
when i was digging through it

00:08:58,080 --> 00:09:01,440
it was kind of relatively easy to get

00:08:59,920 --> 00:09:03,519
pretty lost with them it's a

00:09:01,440 --> 00:09:05,519
it's a huge system built with symbols so

00:09:03,519 --> 00:09:06,720
um i've tried to not follow that same

00:09:05,519 --> 00:09:08,880
approach so we can kind of

00:09:06,720 --> 00:09:10,640
really show the mechanisms here today

00:09:08,880 --> 00:09:11,519
and then the second common job is

00:09:10,640 --> 00:09:13,360
checking

00:09:11,519 --> 00:09:14,720
so now that inferring is complete and

00:09:13,360 --> 00:09:16,959
the types have been assigned

00:09:14,720 --> 00:09:18,800
the engine can run its type checks they

00:09:16,959 --> 00:09:20,320
check the semantics of the given code

00:09:18,800 --> 00:09:22,000
and there are many flavors of these

00:09:20,320 --> 00:09:24,800
types of checks ranging from

00:09:22,000 --> 00:09:25,680
mismatches to non-existing types for

00:09:24,800 --> 00:09:27,760
typescript

00:09:25,680 --> 00:09:29,680
this is the checker which is actually

00:09:27,760 --> 00:09:33,120
the second semantic pass

00:09:29,680 --> 00:09:34,959
and it's 20 000 lines of code long so

00:09:33,120 --> 00:09:37,200
i really feel that that gives a strong

00:09:34,959 --> 00:09:40,320
idea of just how complicated

00:09:37,200 --> 00:09:42,160
and difficult it is to check

00:09:40,320 --> 00:09:43,440
so many different types across so many

00:09:42,160 --> 00:09:45,200
different scenarios

00:09:43,440 --> 00:09:46,560
the type checker is not dependent on the

00:09:45,200 --> 00:09:48,720
calling code i

00:09:46,560 --> 00:09:49,920
if the file executes any of its own code

00:09:48,720 --> 00:09:51,839
at time

00:09:49,920 --> 00:09:53,120
the type checker will process each line

00:09:51,839 --> 00:09:56,480
in a given file itself

00:09:53,120 --> 00:09:56,480
and run the appropriate checks

00:09:56,720 --> 00:10:00,320
so that's it for part a that's the

00:09:59,120 --> 00:10:02,000
overview finished

00:10:00,320 --> 00:10:03,920
so now we're going to be looking at

00:10:02,000 --> 00:10:04,640
building our own compiler which can run

00:10:03,920 --> 00:10:06,720
type checks

00:10:04,640 --> 00:10:08,560
for three different scenarios and throw

00:10:06,720 --> 00:10:10,079
a specific message for each

00:10:08,560 --> 00:10:12,399
the reason we're going to limit it to

00:10:10,079 --> 00:10:14,720
three scenarios is so we can focus on

00:10:12,399 --> 00:10:15,440
the specific mechanisms that work around

00:10:14,720 --> 00:10:17,200
each one

00:10:15,440 --> 00:10:19,360
and hopefully by the end have a really

00:10:17,200 --> 00:10:21,920
strong idea on how to introduce

00:10:19,360 --> 00:10:24,079
more complex type checks we will be

00:10:21,920 --> 00:10:25,600
working with a function declaration

00:10:24,079 --> 00:10:27,040
and then a function expression and the

00:10:25,600 --> 00:10:29,680
expression is going to be calling that

00:10:27,040 --> 00:10:29,680
declaration

00:10:30,560 --> 00:10:35,360
so these are the scenarios so scenario

00:10:33,600 --> 00:10:37,519
one is going to be an issue with a type

00:10:35,360 --> 00:10:38,959
matching a string versus a number

00:10:37,519 --> 00:10:40,720
you can see we've defined a function

00:10:38,959 --> 00:10:41,920
there we've got a type of number

00:10:40,720 --> 00:10:44,240
but we're calling the function with a

00:10:41,920 --> 00:10:45,600
string we've got scenario two

00:10:44,240 --> 00:10:47,839
where there's an issue with using an

00:10:45,600 --> 00:10:50,079
unknown type which is not defined

00:10:47,839 --> 00:10:51,440
so again we're defining our function but

00:10:50,079 --> 00:10:53,519
this time with a type which

00:10:51,440 --> 00:10:55,839
does not exist and we're calling our

00:10:53,519 --> 00:10:58,640
function with a string again

00:10:55,839 --> 00:11:00,160
and then scenario three where there's an

00:10:58,640 --> 00:11:02,160
issue with using a property name

00:11:00,160 --> 00:11:03,360
not found on the interface so we've

00:11:02,160 --> 00:11:05,040
defined an interface

00:11:03,360 --> 00:11:06,800
we've defined a function which should be

00:11:05,040 --> 00:11:08,560
using this interface and now we're

00:11:06,800 --> 00:11:10,000
calling that function and actually

00:11:08,560 --> 00:11:11,920
handing it an object with the wrong

00:11:10,000 --> 00:11:14,560
property name

00:11:11,920 --> 00:11:15,600
so those are our scenarios now onto the

00:11:14,560 --> 00:11:17,600
compiler

00:11:15,600 --> 00:11:18,880
there are two parts to the compiler

00:11:17,600 --> 00:11:21,040
there's the parser

00:11:18,880 --> 00:11:22,480
and the checker and as previously

00:11:21,040 --> 00:11:23,600
mentioned we won't be focusing on the

00:11:22,480 --> 00:11:24,640
past today

00:11:23,600 --> 00:11:26,720
we're just going to be following the

00:11:24,640 --> 00:11:28,160
hegel passing approach of assuming a

00:11:26,720 --> 00:11:30,000
type annotation object

00:11:28,160 --> 00:11:32,399
has been attached to all the annotated

00:11:30,000 --> 00:11:34,240
ast nodes so what i've basically done is

00:11:32,399 --> 00:11:37,279
i've hard coded the ast objects

00:11:34,240 --> 00:11:39,360
so we're going to go through that now

00:11:37,279 --> 00:11:40,480
so scenario one is going to use this

00:11:39,360 --> 00:11:41,600
parser and ast

00:11:40,480 --> 00:11:42,959
so we've got to imagine that it's

00:11:41,600 --> 00:11:44,240
already been put through the hegel

00:11:42,959 --> 00:11:46,079
parser

00:11:44,240 --> 00:11:48,240
i've actually put a comment above any of

00:11:46,079 --> 00:11:48,959
the ast block to clarify what code it's

00:11:48,240 --> 00:11:51,360
for

00:11:48,959 --> 00:11:53,040
so on the left on line three you can see

00:11:51,360 --> 00:11:55,279
the expression st block

00:11:53,040 --> 00:11:56,720
for our top line expression statement

00:11:55,279 --> 00:11:57,920
which you can see actually on line two

00:11:56,720 --> 00:12:00,320
commented out

00:11:57,920 --> 00:12:01,839
and on the right on line 21 is the

00:12:00,320 --> 00:12:03,040
declaration as t

00:12:01,839 --> 00:12:05,519
this is for where we have declared our

00:12:03,040 --> 00:12:08,839
function on line 20 comment it out

00:12:05,519 --> 00:12:10,320
so staying on the right on line 46 we

00:12:08,839 --> 00:12:13,120
return a

00:12:10,320 --> 00:12:15,360
program ast object which is the program

00:12:13,120 --> 00:12:17,200
with both ast nodes in

00:12:15,360 --> 00:12:18,639
the program body is basically an array

00:12:17,200 --> 00:12:20,320
which which is going to be holding these

00:12:18,639 --> 00:12:24,240
objects

00:12:20,320 --> 00:12:26,240
so inside the declaration ast on line 31

00:12:24,240 --> 00:12:28,480
you can see the type annotation on the

00:12:26,240 --> 00:12:30,639
param identifier a

00:12:28,480 --> 00:12:32,000
which you can see online 30 which

00:12:30,639 --> 00:12:33,680
matches where it sits in the code so

00:12:32,000 --> 00:12:34,480
this is what i mean by we've i've hard

00:12:33,680 --> 00:12:39,600
coded the

00:12:34,480 --> 00:12:41,600
the actual the passes type annotations

00:12:39,600 --> 00:12:44,000
on scenario 2 it's going to be using

00:12:41,600 --> 00:12:45,760
this passer nst

00:12:44,000 --> 00:12:47,519
it's very similar to scenario 1 with its

00:12:45,760 --> 00:12:49,920
expression its declaration

00:12:47,519 --> 00:12:51,360
and program ast blocks the code is seen

00:12:49,920 --> 00:12:53,519
on line 1.

00:12:51,360 --> 00:12:54,959
however the difference is on line 12.

00:12:53,519 --> 00:12:57,519
the type annotation

00:12:54,959 --> 00:12:58,639
inside the declarations params array is

00:12:57,519 --> 00:13:00,880
made-up type

00:12:58,639 --> 00:13:02,079
and you can see it on line 16 instead of

00:13:00,880 --> 00:13:04,240
what scenario has

00:13:02,079 --> 00:13:06,000
which was a number type annotation and

00:13:04,240 --> 00:13:09,519
we can actually see that if we go back

00:13:06,000 --> 00:13:11,120
and you look on 9 30 slide line line 35

00:13:09,519 --> 00:13:13,120
on the right you can see the number type

00:13:11,120 --> 00:13:14,560
annotation and so if i go back to

00:13:13,120 --> 00:13:15,839
scenario two you can see it's now made

00:13:14,560 --> 00:13:18,240
up type

00:13:15,839 --> 00:13:20,480
so the expression and the program ast

00:13:18,240 --> 00:13:21,839
blocks are identical scenario one

00:13:20,480 --> 00:13:23,440
so i haven't displayed them here again

00:13:21,839 --> 00:13:25,360
so that's really the main the main

00:13:23,440 --> 00:13:28,399
change in scenario two between the two

00:13:25,360 --> 00:13:29,920
ast blocks and then finally we've got

00:13:28,399 --> 00:13:31,040
scenario three which is going to use

00:13:29,920 --> 00:13:32,880
this parser nst

00:13:31,040 --> 00:13:34,480
i apologize there's a lot a lot of code

00:13:32,880 --> 00:13:36,639
on the screen but um

00:13:34,480 --> 00:13:38,800
it's just to get across how the objects

00:13:36,639 --> 00:13:40,800
look going into the program

00:13:38,800 --> 00:13:42,399
so as well as our expression and

00:13:40,800 --> 00:13:44,480
declaration and program st

00:13:42,399 --> 00:13:46,079
blocks there's now an interface ast

00:13:44,480 --> 00:13:48,000
block and that that's on the left

00:13:46,079 --> 00:13:49,120
and you can see that starting the ast

00:13:48,000 --> 00:13:50,800
starting on line four

00:13:49,120 --> 00:13:53,519
and you can see the type the interface

00:13:50,800 --> 00:13:55,760
declaration on line five

00:13:53,519 --> 00:13:57,120
also looking on the far right now the

00:13:55,760 --> 00:13:59,680
declaration ast

00:13:57,120 --> 00:14:01,600
now has a generic type on its annotation

00:13:59,680 --> 00:14:04,399
and you can see that on line 74

00:14:01,600 --> 00:14:05,120
so instead of it being a string or a

00:14:04,399 --> 00:14:06,880
numeric

00:14:05,120 --> 00:14:08,639
it's now a generic type and that's

00:14:06,880 --> 00:14:11,040
actually just something i've called

00:14:08,639 --> 00:14:12,480
it because it's an object and this is

00:14:11,040 --> 00:14:13,199
this is the part that takes our object

00:14:12,480 --> 00:14:15,760
identifier

00:14:13,199 --> 00:14:17,600
which is person and you can see its name

00:14:15,760 --> 00:14:19,199
on line 77.

00:14:17,600 --> 00:14:21,279
uh yeah and the init the initial code

00:14:19,199 --> 00:14:24,800
for this is on the top

00:14:21,279 --> 00:14:27,040
on line 60. so similarly to scenario one

00:14:24,800 --> 00:14:28,720
and two the program ast is going to

00:14:27,040 --> 00:14:30,160
return an array of these three objects

00:14:28,720 --> 00:14:32,320
for this scenario

00:14:30,160 --> 00:14:33,600
so you can see on line 50 if i go back

00:14:32,320 --> 00:14:37,040
to scenario one

00:14:33,600 --> 00:14:38,160
the program ast body in this in scenario

00:14:37,040 --> 00:14:40,800
three it's going to be

00:14:38,160 --> 00:14:41,920
an array of all three st blocks whereas

00:14:40,800 --> 00:14:43,279
for scenario one and two

00:14:41,920 --> 00:14:45,360
it's just got the expression and

00:14:43,279 --> 00:14:47,920
exploration

00:14:45,360 --> 00:14:48,480
uh so as you can see from this previous

00:14:47,920 --> 00:14:49,920
slides

00:14:48,480 --> 00:14:52,000
the main area which actually holds the

00:14:49,920 --> 00:14:52,800
type annotation object for all three

00:14:52,000 --> 00:14:54,800
scenarios

00:14:52,800 --> 00:14:56,399
is the declaration parameter which is

00:14:54,800 --> 00:14:58,160
the declaration ast

00:14:56,399 --> 00:14:59,839
all three have that in common so you can

00:14:58,160 --> 00:15:03,199
see line 71 here

00:14:59,839 --> 00:15:05,360
got type annotation line 12 here

00:15:03,199 --> 00:15:07,440
type annotation on scenario two and on

00:15:05,360 --> 00:15:08,959
scenario one on line 34.

00:15:07,440 --> 00:15:10,839
so and they're all so all of the type

00:15:08,959 --> 00:15:13,120
annotations are under the declaration

00:15:10,839 --> 00:15:15,519
asd

00:15:13,120 --> 00:15:16,880
so now onto the part of the compiler

00:15:15,519 --> 00:15:18,240
which does our type checks

00:15:16,880 --> 00:15:20,079
we've got three slides to look up for

00:15:18,240 --> 00:15:21,440
this all under the single function which

00:15:20,079 --> 00:15:24,240
is called checker

00:15:21,440 --> 00:15:26,079
so what does it need to do it needs to

00:15:24,240 --> 00:15:26,720
iterate through all the program body ast

00:15:26,079 --> 00:15:28,560
objects

00:15:26,720 --> 00:15:30,240
and depending on the node type do the

00:15:28,560 --> 00:15:32,399
appropriate checks

00:15:30,240 --> 00:15:34,000
we're going to add any errors onto an

00:15:32,399 --> 00:15:35,680
array to be returned

00:15:34,000 --> 00:15:37,199
to the caller for printing so we can

00:15:35,680 --> 00:15:39,519
actually see the error

00:15:37,199 --> 00:15:41,040
so before we go any further the basic

00:15:39,519 --> 00:15:44,480
logic we will work with

00:15:41,040 --> 00:15:46,399
for each type is is this so

00:15:44,480 --> 00:15:47,920
for our function declaration we're going

00:15:46,399 --> 00:15:48,880
to check the types for the argument are

00:15:47,920 --> 00:15:50,560
valid

00:15:48,880 --> 00:15:52,720
then check each statement in the block

00:15:50,560 --> 00:15:54,320
body for our expression

00:15:52,720 --> 00:15:56,079
we're going to find the function

00:15:54,320 --> 00:15:57,759
declaration for the caller

00:15:56,079 --> 00:15:59,440
we're going to grab the type of the

00:15:57,759 --> 00:16:01,440
declarations argument

00:15:59,440 --> 00:16:03,440
lastly grab the type of the expressions

00:16:01,440 --> 00:16:06,560
call argument and then compare them

00:16:03,440 --> 00:16:09,279
to make sure that they're the same type

00:16:06,560 --> 00:16:11,279
so this code contains the type

00:16:09,279 --> 00:16:13,600
typechecks utility object

00:16:11,279 --> 00:16:15,360
and an empty errors array which will be

00:16:13,600 --> 00:16:18,079
used to check our expression

00:16:15,360 --> 00:16:19,199
and the basic annotation check so

00:16:18,079 --> 00:16:21,120
nothing has been called yet we're just

00:16:19,199 --> 00:16:23,279
defining this utility object

00:16:21,120 --> 00:16:24,240
so this object has got this is for for

00:16:23,279 --> 00:16:26,800
the expression

00:16:24,240 --> 00:16:27,759
there are two types of checks so on line

00:16:26,800 --> 00:16:30,959
00:16:27,759 --> 00:16:33,360
you can see the numeric type annotation

00:16:30,959 --> 00:16:34,160
here the caller type should be a numeric

00:16:33,360 --> 00:16:37,360
literal

00:16:34,160 --> 00:16:39,120
as you can see on line 14. so if if it

00:16:37,360 --> 00:16:41,600
was annotated as a number

00:16:39,120 --> 00:16:43,360
the caller type should be a number

00:16:41,600 --> 00:16:45,920
scenario one would fail here but

00:16:43,360 --> 00:16:47,360
nothing has actually been logged yet for

00:16:45,920 --> 00:16:49,600
our there's also a generic type

00:16:47,360 --> 00:16:52,720
annotation on line 15

00:16:49,600 --> 00:16:54,560
and if it's an object we search the tree

00:16:52,720 --> 00:16:56,000
for an interface declaration there's the

00:16:54,560 --> 00:16:59,199
the uh scope

00:16:56,000 --> 00:17:00,880
uh we see you can see online 19 and then

00:16:59,199 --> 00:17:02,240
we check each property of the caller

00:17:00,880 --> 00:17:04,559
on that interface which you can see

00:17:02,240 --> 00:17:05,760
online 26 to 35

00:17:04,559 --> 00:17:08,559
we're checking each property on the

00:17:05,760 --> 00:17:09,600
caller and then if there are any issues

00:17:08,559 --> 00:17:11,280
they're going to get pushed into the

00:17:09,600 --> 00:17:11,919
errors array and you can see that online

00:17:11,280 --> 00:17:13,760
00:17:11,919 --> 00:17:15,120
with a helpful message about what

00:17:13,760 --> 00:17:17,439
property name does exist

00:17:15,120 --> 00:17:19,280
and therefore what it could actually be

00:17:17,439 --> 00:17:21,280
this is actually limited because

00:17:19,280 --> 00:17:22,959
it only works with the one object but

00:17:21,280 --> 00:17:24,799
it's the proof of concept

00:17:22,959 --> 00:17:26,559
scenario three would fail here and get

00:17:24,799 --> 00:17:28,319
this error

00:17:26,559 --> 00:17:29,520
so you can probably see that the

00:17:28,319 --> 00:17:29,840
processing is going to be limited to

00:17:29,520 --> 00:17:32,799
this

00:17:29,840 --> 00:17:34,799
file to the file was given however most

00:17:32,799 --> 00:17:36,320
type checks will have a notion of scope

00:17:34,799 --> 00:17:38,640
so they're able to determine if a

00:17:36,320 --> 00:17:41,280
declaration was anywhere in the runtime

00:17:38,640 --> 00:17:42,720
and not just available in this program

00:17:41,280 --> 00:17:45,039
again ours has an easier job because

00:17:42,720 --> 00:17:48,080
it's this proof of concept

00:17:45,039 --> 00:17:50,080
so uh slide number two this code

00:17:48,080 --> 00:17:50,480
contains the processing of each node

00:17:50,080 --> 00:17:52,799
type

00:17:50,480 --> 00:17:54,240
in the program body so this is where the

00:17:52,799 --> 00:17:55,039
type check logic that we defined

00:17:54,240 --> 00:17:57,440
previously

00:17:55,039 --> 00:17:58,320
is going to be called from so let's walk

00:17:57,440 --> 00:18:01,360
through the code again

00:17:58,320 --> 00:18:02,960
and then break it down by type so

00:18:01,360 --> 00:18:04,160
here we have the function declaration

00:18:02,960 --> 00:18:05,120
which is where we would define our

00:18:04,160 --> 00:18:08,000
function

00:18:05,120 --> 00:18:09,600
uh you can see that on line 48 so we

00:18:08,000 --> 00:18:10,400
start by processing the arguments and

00:18:09,600 --> 00:18:13,200
the params

00:18:10,400 --> 00:18:14,160
on line 49. if it finds a type

00:18:13,200 --> 00:18:17,280
annotation

00:18:14,160 --> 00:18:18,720
which here it doesn't line 50 on line 51

00:18:17,280 --> 00:18:21,039
check if the type exists for the

00:18:18,720 --> 00:18:23,039
argument given id arc type

00:18:21,039 --> 00:18:25,120
if it does not add an error to the

00:18:23,039 --> 00:18:27,120
errors which was on line 56

00:18:25,120 --> 00:18:30,160
scenario 2 would get an error here

00:18:27,120 --> 00:18:32,400
because the type does not exist

00:18:30,160 --> 00:18:34,160
lastly we process the function body

00:18:32,400 --> 00:18:36,000
however as we know there's no function

00:18:34,160 --> 00:18:38,559
body to process i've left it blank

00:18:36,000 --> 00:18:39,280
the function body is the actual block of

00:18:38,559 --> 00:18:41,520
the function

00:18:39,280 --> 00:18:42,960
and if you remember when i defined the

00:18:41,520 --> 00:18:44,160
function there was nothing actually

00:18:42,960 --> 00:18:45,360
inside of it it was all about the

00:18:44,160 --> 00:18:48,080
arguments and the

00:18:45,360 --> 00:18:49,679
type definition so now on to the last

00:18:48,080 --> 00:18:52,000
slide of code

00:18:49,679 --> 00:18:53,120
this is the final bit here we have the

00:18:52,000 --> 00:18:56,320
expression statement

00:18:53,120 --> 00:18:58,000
at line 69 on the top

00:18:56,320 --> 00:18:59,360
first we check the program body for the

00:18:58,000 --> 00:19:01,280
declaration of the function

00:18:59,360 --> 00:19:02,720
on line 71 so we've got to go off and

00:19:01,280 --> 00:19:04,480
find the declaration

00:19:02,720 --> 00:19:06,080
this is where scope would apply to real

00:19:04,480 --> 00:19:08,559
chart checker so

00:19:06,080 --> 00:19:10,080
if no declaration is found add an error

00:19:08,559 --> 00:19:12,160
to the to the errors array which we're

00:19:10,080 --> 00:19:14,799
doing on line 79.

00:19:12,160 --> 00:19:16,240
next on the right we check each defined

00:19:14,799 --> 00:19:17,360
argument type against the caller

00:19:16,240 --> 00:19:18,799
argument type

00:19:17,360 --> 00:19:20,960
and then if there's a type mismatch

00:19:18,799 --> 00:19:23,440
found then add an error onto the errors

00:19:20,960 --> 00:19:25,360
array which we're doing on line 105.

00:19:23,440 --> 00:19:27,840
so both scenario one and scenario two

00:19:25,360 --> 00:19:30,640
will get this error

00:19:27,840 --> 00:19:32,080
so what i'm out for now we can have a

00:19:30,640 --> 00:19:36,080
look at what this is output

00:19:32,080 --> 00:19:38,080
outputted so i've introduced a basic

00:19:36,080 --> 00:19:40,880
repository with a simple index file

00:19:38,080 --> 00:19:41,360
and some tests which processes these ast

00:19:40,880 --> 00:19:43,760
nodes

00:19:41,360 --> 00:19:44,799
and logs the errors when i run it i get

00:19:43,760 --> 00:19:46,160
this output

00:19:44,799 --> 00:19:48,720
so here you can see the errors for

00:19:46,160 --> 00:19:50,480
scenario one is type craig string

00:19:48,720 --> 00:19:51,600
is incompatible with number and i've

00:19:50,480 --> 00:19:52,640
actually just realized that that should

00:19:51,600 --> 00:19:54,400
probably be

00:19:52,640 --> 00:19:56,000
the string literal because it's the type

00:19:54,400 --> 00:19:59,520
that it should give us but

00:19:56,000 --> 00:20:00,400
proof of concept uh then scenario errors

00:19:59,520 --> 00:20:02,000
for scenario two

00:20:00,400 --> 00:20:03,440
we can see we've got the type craig

00:20:02,000 --> 00:20:05,600
string off done again

00:20:03,440 --> 00:20:07,919
is incompatible with undefined so this

00:20:05,600 --> 00:20:09,919
would again be a string literal

00:20:07,919 --> 00:20:11,760
and then we've also got type made up for

00:20:09,919 --> 00:20:13,679
argument a does not exist

00:20:11,760 --> 00:20:14,799
this is where the type match type does

00:20:13,679 --> 00:20:17,520
not exist

00:20:14,799 --> 00:20:18,720
and then errors for scenario three this

00:20:17,520 --> 00:20:20,480
is the interface

00:20:18,720 --> 00:20:22,720
property nam does not exist on interface

00:20:20,480 --> 00:20:24,880
person did you mean name

00:20:22,720 --> 00:20:25,840
so if we are to summarize what these are

00:20:24,880 --> 00:20:28,320
actually talking about

00:20:25,840 --> 00:20:29,039
scenario one we defined an argument type

00:20:28,320 --> 00:20:31,600
of number

00:20:29,039 --> 00:20:32,320
but we called it with a string scenario

00:20:31,600 --> 00:20:34,000
two

00:20:32,320 --> 00:20:35,600
we defined a type on the function

00:20:34,000 --> 00:20:37,120
argument which does not exist

00:20:35,600 --> 00:20:38,960
and then we called our function so we

00:20:37,120 --> 00:20:39,760
get two errors one for the bad type

00:20:38,960 --> 00:20:41,760
defined

00:20:39,760 --> 00:20:44,159
one for the type mismatch and then

00:20:41,760 --> 00:20:46,080
scenario three we defined an interface

00:20:44,159 --> 00:20:47,520
but use the property called nam which

00:20:46,080 --> 00:20:50,480
was not in the object

00:20:47,520 --> 00:20:52,400
we asked if it asked if if we meant to

00:20:50,480 --> 00:20:54,880
use name instead

00:20:52,400 --> 00:20:58,159
so that's it it's a basic type checker

00:20:54,880 --> 00:21:02,480
in less than 100 lines of code

00:20:58,159 --> 00:21:04,559
so what have we missed as mentioned

00:21:02,480 --> 00:21:06,400
many many many additional parts to a

00:21:04,559 --> 00:21:07,120
type compiler which we've emitted from

00:21:06,400 --> 00:21:09,200
our compiler

00:21:07,120 --> 00:21:10,640
and some of these are listed here so we

00:21:09,200 --> 00:21:12,559
can start with the most basic which is

00:21:10,640 --> 00:21:14,080
the parser you know we we manually wrote

00:21:12,559 --> 00:21:15,600
these says t blocks

00:21:14,080 --> 00:21:17,200
uh within a real compiler these would

00:21:15,600 --> 00:21:18,640
have to be generated

00:21:17,200 --> 00:21:21,520
then there's the pre-processing in the

00:21:18,640 --> 00:21:23,919
language server a real compiler has this

00:21:21,520 --> 00:21:25,120
uh language language server mechanism to

00:21:23,919 --> 00:21:26,960
plug into an ide

00:21:25,120 --> 00:21:29,440
and we run out appropriate times ours

00:21:26,960 --> 00:21:31,200
doesn't it's the lazy compilation

00:21:29,440 --> 00:21:33,039
we've got no intelligence around what's

00:21:31,200 --> 00:21:35,360
being changed or used or storing any of

00:21:33,039 --> 00:21:37,520
the st blocks in memory

00:21:35,360 --> 00:21:39,200
uh the transform step we've completely

00:21:37,520 --> 00:21:41,120
skipped the final part of the compiler

00:21:39,200 --> 00:21:42,720
which is where it would be converted

00:21:41,120 --> 00:21:43,840
back into our javascript code which can

00:21:42,720 --> 00:21:44,880
actually be read by the javascript

00:21:43,840 --> 00:21:46,640
runtime

00:21:44,880 --> 00:21:48,400
and also scope which is something we

00:21:46,640 --> 00:21:50,320
meant touched on a few times

00:21:48,400 --> 00:21:52,240
as it's a proof of concept it's all in a

00:21:50,320 --> 00:21:53,600
single file didn't really need to know

00:21:52,240 --> 00:21:55,520
the notion of scope

00:21:53,600 --> 00:21:59,840
however real compilers have to be really

00:21:55,520 --> 00:21:59,840
aware of what has access to what

00:22:00,159 --> 00:22:04,400
so that's it thank you so much for

00:22:02,159 --> 00:22:06,559
listening i learned a huge amount from

00:22:04,400 --> 00:22:08,799
this research on type on type systems

00:22:06,559 --> 00:22:10,640
um i hope it was useful for you you can

00:22:08,799 --> 00:22:11,600
find the repository for the code and the

00:22:10,640 --> 00:22:14,559
tests

00:22:11,600 --> 00:22:15,919
on github and github at this link and

00:22:14,559 --> 00:22:16,640
also you can check my site for more

00:22:15,919 --> 00:22:20,000
under the hoods

00:22:16,640 --> 00:22:22,880
which is craigtob so thank you very much

00:22:20,000 --> 00:22:22,880

YouTube URL: https://www.youtube.com/watch?v=8ybDmBxBOU4


