Title: React: What's Coming and What's Unstable - JS Monthly - September 2019
Publication date: 2019-10-02
Playlist: JS Monthly London
Description: 
	Presented by Andrew Collins (Funding Circle)

A lot of people know how to use React, but how it works and what is up and coming can be hard to plan for. I will be talking about some of the up and coming and currently unstable parts of React.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,710
my name's Andrew I'm a software engineer

00:00:01,260 --> 00:00:07,890
at funny circle and hopefully this is

00:00:04,710 --> 00:00:09,150
representative of current react it seems

00:00:07,890 --> 00:00:13,500
to be performing quite well it was

00:00:09,150 --> 00:00:15,330
performing very badly earlier with all

00:00:13,500 --> 00:00:18,660
these animations happening on the screen

00:00:15,330 --> 00:00:21,090
at the same time so I'm gonna get right

00:00:18,660 --> 00:00:23,789
into what my talk is about

00:00:21,090 --> 00:00:24,330
so reactors a complex engine just like

00:00:23,789 --> 00:00:28,460
this one

00:00:24,330 --> 00:00:28,460
can anyone actually name what this is

00:00:30,320 --> 00:00:36,930
it's the difference engine which is

00:00:33,059 --> 00:00:38,579
inside of the London Science Museum I

00:00:36,930 --> 00:00:42,180
thought it would be the closest thing

00:00:38,579 --> 00:00:46,370
which is representative to the

00:00:42,180 --> 00:00:51,120
differencing algorithm inside of react

00:00:46,370 --> 00:00:54,410
so the inventor of this machine actually

00:00:51,120 --> 00:00:57,750
invented a couple of things inside of

00:00:54,410 --> 00:00:59,789
his career I guess in one of them much

00:00:57,750 --> 00:01:00,930
weirder than the others is something

00:00:59,789 --> 00:01:02,879
called the cowcatcher

00:01:00,930 --> 00:01:07,110
I had no idea that was the name for it

00:01:02,879 --> 00:01:13,500
but what I thought was more of a Cal

00:01:07,110 --> 00:01:15,990
pusher away but I have no idea so can

00:01:13,500 --> 00:01:19,350
everyone raise a hand who currently uses

00:01:15,990 --> 00:01:20,430
react at the moment or okay yeah I would

00:01:19,350 --> 00:01:21,810
have gotten really awkward if there was

00:01:20,430 --> 00:01:27,990
about two people and I've had to explain

00:01:21,810 --> 00:01:32,640
everything in react yeah so this talks

00:01:27,990 --> 00:01:34,380
hopefully about how react works under

00:01:32,640 --> 00:01:36,990
the hood and how you can get better at

00:01:34,380 --> 00:01:42,390
understanding your software that you use

00:01:36,990 --> 00:01:43,950
and be able to be confidently used api's

00:01:42,390 --> 00:01:50,280
that that software provides to you

00:01:43,950 --> 00:01:52,470
without let's say realizing something's

00:01:50,280 --> 00:01:54,000
happened and you don't know why some

00:01:52,470 --> 00:01:55,680
side effect happened for example like

00:01:54,000 --> 00:01:58,110
I'm sure everyone else rooms run like a

00:01:55,680 --> 00:02:00,240
set state and it didn't update when you

00:01:58,110 --> 00:02:03,299
wanted it to just all the quirks in

00:02:00,240 --> 00:02:05,189
react having set state and set state can

00:02:03,299 --> 00:02:08,160
run in so many different ways in react

00:02:05,189 --> 00:02:10,530
right now before that asynchronous fiber

00:02:08,160 --> 00:02:12,450
comes out it can run synchronously can

00:02:10,530 --> 00:02:13,740
run asynchronously you can run in a

00:02:12,450 --> 00:02:15,390
bunch of ways

00:02:13,740 --> 00:02:16,890
so I think it's just super important to

00:02:15,390 --> 00:02:19,680
stay engaged with the community which

00:02:16,890 --> 00:02:22,110
you work in and I think issues are a

00:02:19,680 --> 00:02:24,960
really good way of doing that react is

00:02:22,110 --> 00:02:28,050
really good at maintaining what they're

00:02:24,960 --> 00:02:29,910
working on and what they're going to be

00:02:28,050 --> 00:02:32,250
releasing it's how I found out a lot

00:02:29,910 --> 00:02:38,250
about this talk and how it works under

00:02:32,250 --> 00:02:41,040
the hood yeah so over the last couple

00:02:38,250 --> 00:02:45,450
years react fibres been like released

00:02:41,040 --> 00:02:47,280
and it's really some lot of issues for

00:02:45,450 --> 00:02:48,510
example one of them was react umbrella I

00:02:47,280 --> 00:02:51,450
don't know if anyone's heard about that

00:02:48,510 --> 00:02:57,360
my more recent one is react flare which

00:02:51,450 --> 00:03:00,230
is more focused on user events and how

00:02:57,360 --> 00:03:02,370
react can get better at handling this I

00:03:00,230 --> 00:03:04,530
think like every now and then you should

00:03:02,370 --> 00:03:08,970
just go ahead and look at the issues

00:03:04,530 --> 00:03:10,530
page on react and maybe search some cool

00:03:08,970 --> 00:03:12,930
things which you'd like to use for

00:03:10,530 --> 00:03:14,250
example a sync mode concurrent create

00:03:12,930 --> 00:03:20,700
route and all those things that are

00:03:14,250 --> 00:03:22,020
being released so you can go through

00:03:20,700 --> 00:03:23,610
with the issues but you might get to

00:03:22,020 --> 00:03:25,200
something like this which I don't think

00:03:23,610 --> 00:03:26,520
is the worst thing it makes it super to

00:03:25,200 --> 00:03:28,650
understand I had to try and research

00:03:26,520 --> 00:03:31,710
react in a couple of weeks after going

00:03:28,650 --> 00:03:32,850
on holiday and it is it's not easy there

00:03:31,710 --> 00:03:34,800
are a lot of talks out there but a lot

00:03:32,850 --> 00:03:38,430
of them outdated and react keeps

00:03:34,800 --> 00:03:40,320
evolving like every single day you get

00:03:38,430 --> 00:03:42,180
into a state like this but I don't think

00:03:40,320 --> 00:03:43,920
it's the worst thing if you keep the

00:03:42,180 --> 00:03:45,660
understanding and be able to bring that

00:03:43,920 --> 00:03:48,300
back to your team or your codebase which

00:03:45,660 --> 00:03:53,070
you're working on so 60 frames per

00:03:48,300 --> 00:03:55,020
second is considered smooth I guess and

00:03:53,070 --> 00:03:59,070
that's something we want to constantly

00:03:55,020 --> 00:04:01,700
achieve while working on the web so 60

00:03:59,070 --> 00:04:06,170
frames per second approximately and

00:04:01,700 --> 00:04:08,340
outputs about 16 points 6 6 6 6 7

00:04:06,170 --> 00:04:11,070
milliseconds which you have time to do

00:04:08,340 --> 00:04:12,630
between frame updates I'm sure a lot of

00:04:11,070 --> 00:04:15,780
you who've seen a slide very similar to

00:04:12,630 --> 00:04:17,580
this before but I thought I'd just

00:04:15,780 --> 00:04:20,790
reiterate right before I go into the

00:04:17,580 --> 00:04:22,860
main points so I said react fibre but

00:04:20,790 --> 00:04:26,430
what does that mean it's kind of split

00:04:22,860 --> 00:04:27,180
up into many parts I found this on

00:04:26,430 --> 00:04:30,300
Twitter from Andrew

00:04:27,180 --> 00:04:32,400
one of the main contributors to the

00:04:30,300 --> 00:04:34,400
react core team so time slicing is what

00:04:32,400 --> 00:04:37,919
we're going to be focusing on today

00:04:34,400 --> 00:04:39,870
basically what it is is rendering it

00:04:37,919 --> 00:04:42,690
makes rendering non-blocking it runs

00:04:39,870 --> 00:04:45,949
rendering in the black background that's

00:04:42,690 --> 00:04:48,539
not including committing but there is

00:04:45,949 --> 00:04:49,530
some explanation I'll do between the

00:04:48,539 --> 00:04:54,570
difference between rendering and

00:04:49,530 --> 00:04:55,500
committing so react fiber can also yield

00:04:54,570 --> 00:04:58,650
to the browser

00:04:55,500 --> 00:05:00,720
currently react fiber is behind a bunch

00:04:58,650 --> 00:05:03,840
of flags and can only run in synchronous

00:05:00,720 --> 00:05:06,500
mode which means you cannot yield to the

00:05:03,840 --> 00:05:08,759
Barret browser between renders and

00:05:06,500 --> 00:05:11,520
yielding is basically telling the

00:05:08,759 --> 00:05:13,800
browser hey I'll let you do some work in

00:05:11,520 --> 00:05:19,169
between meeting work in and I'll pick it

00:05:13,800 --> 00:05:21,360
up later so another benefit of

00:05:19,169 --> 00:05:26,340
concurrent react is also priority-based

00:05:21,360 --> 00:05:28,520
scheduling which is say you have a bunch

00:05:26,340 --> 00:05:31,800
of work that you need to do but in

00:05:28,520 --> 00:05:34,470
queueing it might not be the best thing

00:05:31,800 --> 00:05:37,199
to do in the order which you do in queue

00:05:34,470 --> 00:05:39,419
I think the best way to do it is on

00:05:37,199 --> 00:05:40,919
priority and that's the direction that

00:05:39,419 --> 00:05:42,539
they've gone and I'm going to be talking

00:05:40,919 --> 00:05:44,870
a bit about that later so the side of

00:05:42,539 --> 00:05:47,460
suspense I'm not covering too much

00:05:44,870 --> 00:05:50,639
because there are so many other talks

00:05:47,460 --> 00:05:56,720
which cover it and I think they do a way

00:05:50,639 --> 00:05:59,820
better job I just thought the underlying

00:05:56,720 --> 00:06:02,370
layers of react aren't really explained

00:05:59,820 --> 00:06:06,380
that much and are quite complicated so

00:06:02,370 --> 00:06:09,210
I've just stolen this from another talk

00:06:06,380 --> 00:06:13,050
so this is how react currently works

00:06:09,210 --> 00:06:14,820
even in react fiber today so the render

00:06:13,050 --> 00:06:16,710
phase in yellow at the top run

00:06:14,820 --> 00:06:18,210
synchronously so no work can run it in

00:06:16,710 --> 00:06:21,750
between this and then the commit phase

00:06:18,210 --> 00:06:24,509
at the end swaps the shadow Dom into the

00:06:21,750 --> 00:06:27,360
browser and then only on each side of

00:06:24,509 --> 00:06:29,759
this can anything else run so what this

00:06:27,360 --> 00:06:34,110
means is you're basically screwed

00:06:29,759 --> 00:06:36,510
until reactors down it's work so async

00:06:34,110 --> 00:06:39,360
mode or react fiber what it does is it

00:06:36,510 --> 00:06:40,740
does something time slicing where every

00:06:39,360 --> 00:06:43,560
5 milliseconds that check

00:06:40,740 --> 00:06:44,699
if the browser needs to do work since we

00:06:43,560 --> 00:06:46,050
have a budget of sixteen point six

00:06:44,699 --> 00:06:49,860
milliseconds it can do this multiple

00:06:46,050 --> 00:06:51,840
times per update and then let the

00:06:49,860 --> 00:06:53,520
browser do the work on the in-between

00:06:51,840 --> 00:06:56,580
part this isn't just on initial render

00:06:53,520 --> 00:06:58,199
but this is on updating as well the

00:06:56,580 --> 00:06:59,759
commit at the end has to say synchronous

00:06:58,199 --> 00:07:06,020
because the swapping of the elements

00:06:59,759 --> 00:07:09,389
into the Dom also cannot be I guess

00:07:06,020 --> 00:07:14,729
split up without you seeing some pretty

00:07:09,389 --> 00:07:16,979
janky effects of things getting to the

00:07:14,729 --> 00:07:21,030
page of different times I'm not going to

00:07:16,979 --> 00:07:24,210
be covering the in depth of how exactly

00:07:21,030 --> 00:07:28,139
the fiber works the the single element

00:07:24,210 --> 00:07:29,729
which makes up a fiber tree just cuz is

00:07:28,139 --> 00:07:31,349
quite complicated and I didn't have

00:07:29,729 --> 00:07:35,729
enough time to do it we're gonna be

00:07:31,349 --> 00:07:43,220
honest just just a bit stat actually

00:07:35,729 --> 00:07:46,520
render the fibers or process them so

00:07:43,220 --> 00:07:49,289
this is like new world react I'm sure

00:07:46,520 --> 00:07:55,669
everyone seen as I have people seen the

00:07:49,289 --> 00:07:59,340
new crate route API before anyone okay

00:07:55,669 --> 00:08:03,270
so create route is a different way of

00:07:59,340 --> 00:08:06,090
rendering and allows you to make this

00:08:03,270 --> 00:08:07,259
process asynchronous for rendering you

00:08:06,090 --> 00:08:09,240
can see at the bottom this is how they

00:08:07,259 --> 00:08:11,069
export it they have a crate route which

00:08:09,240 --> 00:08:13,530
is now the default or would leave the

00:08:11,069 --> 00:08:15,270
default and create sync route which is

00:08:13,530 --> 00:08:17,340
going to be the old way of doing things

00:08:15,270 --> 00:08:20,400
if you ever need to do that for some

00:08:17,340 --> 00:08:23,370
reason so create route takes an element

00:08:20,400 --> 00:08:28,560
in the body or takes an element and then

00:08:23,370 --> 00:08:31,979
you can push a render to this element to

00:08:28,560 --> 00:08:33,209
this react root node and then it renders

00:08:31,979 --> 00:08:35,729
what if you give it

00:08:33,209 --> 00:08:38,520
so this render face is actually split up

00:08:35,729 --> 00:08:40,140
as you can see on the right but inside

00:08:38,520 --> 00:08:43,770
of this API which is only one currently

00:08:40,140 --> 00:08:45,870
released you cannot in the current API

00:08:43,770 --> 00:08:48,480
you can't split up but it is still

00:08:45,870 --> 00:08:52,170
asynchronous at point so on the right

00:08:48,480 --> 00:08:53,579
hand side which are unexploited api's

00:08:52,170 --> 00:08:54,540
there's the crate route you have

00:08:53,579 --> 00:08:56,160
pre-render

00:08:54,540 --> 00:08:59,009
and you can perform actions before it

00:08:56,160 --> 00:09:03,240
makes a switch to the Dom which i think

00:08:59,009 --> 00:09:14,310
is pretty cool I've completely lost my

00:09:03,240 --> 00:09:15,120
cursor there is so I think I might skip

00:09:14,310 --> 00:09:19,170
one I didn't

00:09:15,120 --> 00:09:24,709
so the scheduler which makes all of this

00:09:19,170 --> 00:09:27,240
happen and reorders tasks is also

00:09:24,709 --> 00:09:31,519
asynchronous it is the thing that runs

00:09:27,240 --> 00:09:35,550
the task every 5 milliseconds yielding

00:09:31,519 --> 00:09:37,980
so there are a couple ways that react

00:09:35,550 --> 00:09:40,550
decided to do this initially they looked

00:09:37,980 --> 00:09:44,029
at requests idle callback unfortunately

00:09:40,550 --> 00:09:47,069
well I'll explain what it does first it

00:09:44,029 --> 00:09:50,670
basically tells the browser with an

00:09:47,069 --> 00:09:53,970
event when the browser isn't doing very

00:09:50,670 --> 00:09:57,269
much and it's able to basically yield

00:09:53,970 --> 00:09:59,790
back to your web application it also

00:09:57,269 --> 00:10:02,760
provides you when it expects the next

00:09:59,790 --> 00:10:04,230
unit of work to happen so it gives you a

00:10:02,760 --> 00:10:07,649
time allotted where you can't perform

00:10:04,230 --> 00:10:10,170
that work requestanimationframe was

00:10:07,649 --> 00:10:14,279
something that was implementing until

00:10:10,170 --> 00:10:17,639
about last week basically it's not

00:10:14,279 --> 00:10:21,839
really fit for purpose it's mostly made

00:10:17,639 --> 00:10:24,649
to versus animations obviously and then

00:10:21,839 --> 00:10:28,880
eventually what was decided was yielding

00:10:24,649 --> 00:10:32,279
so as I described before what it does is

00:10:28,880 --> 00:10:34,440
when scheduling it checks if the browser

00:10:32,279 --> 00:10:35,490
needs to do any work what it just yields

00:10:34,440 --> 00:10:37,740
to the browser and the browser will do

00:10:35,490 --> 00:10:40,939
work otherwise it will do work so it

00:10:37,740 --> 00:10:40,939
doesn't specifically ask

00:10:43,350 --> 00:10:49,020
I said five milliseconds but when I was

00:10:46,290 --> 00:10:50,850
looking through the source code it kept

00:10:49,020 --> 00:10:53,490
saying that it was a thousand over

00:10:50,850 --> 00:10:57,140
frames per second which isn't five

00:10:53,490 --> 00:11:00,870
milliseconds when you give it 60 but

00:10:57,140 --> 00:11:03,630
other sources said five milliseconds so

00:11:00,870 --> 00:11:05,730
it's really hard to read documentation

00:11:03,630 --> 00:11:12,300
in source code at the same time and see

00:11:05,730 --> 00:11:13,890
what's up to date so as I mentioned the

00:11:12,300 --> 00:11:15,390
key components are the scheduler the

00:11:13,890 --> 00:11:19,230
work loop and update key which are going

00:11:15,390 --> 00:11:21,750
to be going through today but they're

00:11:19,230 --> 00:11:22,920
not the only components which build up

00:11:21,750 --> 00:11:24,630
react but I think they're the most

00:11:22,920 --> 00:11:27,690
important bits to understand when

00:11:24,630 --> 00:11:30,360
running code and considering performance

00:11:27,690 --> 00:11:32,940
and there are a lot of things I've heard

00:11:30,360 --> 00:11:35,310
about like processing Dom and how react

00:11:32,940 --> 00:11:40,040
is very different from react Dom but

00:11:35,310 --> 00:11:43,580
they're becoming more tightly knit so

00:11:40,040 --> 00:11:46,470
this is the classes which build up

00:11:43,580 --> 00:11:47,490
priority well I believe there are so

00:11:46,470 --> 00:11:51,870
many different parts which have

00:11:47,490 --> 00:11:58,580
priorities summer literally just numbers

00:11:51,870 --> 00:12:01,560
other other classes and other things so

00:11:58,580 --> 00:12:03,930
it's broken down into immediate and user

00:12:01,560 --> 00:12:05,280
blocking are pretty much happening in

00:12:03,930 --> 00:12:06,930
the same amount of time almost

00:12:05,280 --> 00:12:09,000
synchronous immediate is definitely

00:12:06,930 --> 00:12:11,880
synchronous and as you can see by the

00:12:09,000 --> 00:12:12,600
minus 1 and user blocking is 250

00:12:11,880 --> 00:12:16,320
milliseconds

00:12:12,600 --> 00:12:18,090
no more timeout is 5,000 so normal

00:12:16,320 --> 00:12:21,320
timeout is when you need something to

00:12:18,090 --> 00:12:23,610
happen but you're not you're not

00:12:21,320 --> 00:12:26,870
dependent on a having right now like a

00:12:23,610 --> 00:12:29,880
network request or anything like that

00:12:26,870 --> 00:12:31,200
idle priority is maybe something like

00:12:29,880 --> 00:12:34,140
analytics where you want it to happen

00:12:31,200 --> 00:12:36,920
eventually but not like it doesn't

00:12:34,140 --> 00:12:39,540
matter if it doesn't happen at all so

00:12:36,920 --> 00:12:42,570
this is kind of how a schedule is built

00:12:39,540 --> 00:12:43,920
up you have a tea initially I'm just

00:12:42,570 --> 00:12:46,620
going to run Frison sequentially and

00:12:43,920 --> 00:12:49,290
then pipe them back into the bottom and

00:12:46,620 --> 00:12:51,600
try to explain it so a tea

00:12:49,290 --> 00:12:55,350
we run a flash and a to straightaway

00:12:51,600 --> 00:12:57,080
gets so the letter is equivalent of the

00:12:55,350 --> 00:12:59,960
state and the number is equivalent

00:12:57,080 --> 00:13:01,450
of the priority it's not exactly how it

00:12:59,960 --> 00:13:05,840
works with priorities more based on

00:13:01,450 --> 00:13:09,200
timeouts and explorations so a two runs

00:13:05,840 --> 00:13:11,510
a flush a two gets outputted even though

00:13:09,200 --> 00:13:13,700
it's a lower priority than c1 and d1 so

00:13:11,510 --> 00:13:14,810
you have with these api's which some of

00:13:13,700 --> 00:13:18,860
them are going to go through and try

00:13:14,810 --> 00:13:22,340
explain why they're really useful but

00:13:18,860 --> 00:13:24,710
right now we need to know is a two run

00:13:22,340 --> 00:13:27,020
flash it gets put into the output of the

00:13:24,710 --> 00:13:32,020
schedule so it actually gets run and

00:13:27,020 --> 00:13:34,280
then B two runs then it waits about

00:13:32,020 --> 00:13:39,620
until it's time our expiration as you

00:13:34,280 --> 00:13:40,880
saw before and then by that time c1 and

00:13:39,620 --> 00:13:45,410
d1 getting queued and then they get

00:13:40,880 --> 00:13:47,360
pushed ahead of b2 which they get re

00:13:45,410 --> 00:13:51,860
sorted into a task queue which gets

00:13:47,360 --> 00:13:55,720
sorted on the sort index which I wish

00:13:51,860 --> 00:13:55,720
had more time to explain or know myself

00:13:57,160 --> 00:14:04,850
yeah so expiration time I mentioned is

00:14:00,800 --> 00:14:07,190
the time is in queued to sorry times in

00:14:04,850 --> 00:14:09,740
queued plus some timer that has and it

00:14:07,190 --> 00:14:11,960
has to execute by that point they're

00:14:09,740 --> 00:14:13,160
really complicated thing there are other

00:14:11,960 --> 00:14:15,820
complicated things which I don't quite

00:14:13,160 --> 00:14:19,490
understand which are advancing of timers

00:14:15,820 --> 00:14:24,320
which I'd love to know about where by

00:14:19,490 --> 00:14:28,040
the time a a deadline has been met on

00:14:24,320 --> 00:14:30,770
the browser it goes back and tells the

00:14:28,040 --> 00:14:33,080
scheduler to rerun it again with a hose

00:14:30,770 --> 00:14:35,000
idle callback so it tells the host which

00:14:33,080 --> 00:14:39,950
is the browser to tell us again when

00:14:35,000 --> 00:14:41,330
we're ready to perform tasks but and

00:14:39,950 --> 00:14:42,860
then after that it needs to advance the

00:14:41,330 --> 00:14:47,650
time as otherwise they'll be out of sync

00:14:42,860 --> 00:14:50,210
so the scheduler is really cool and

00:14:47,650 --> 00:14:54,160
what's really great about it is their

00:14:50,210 --> 00:14:57,680
plan to not make it solely for react and

00:14:54,160 --> 00:15:00,260
they've taken the name in NPM just

00:14:57,680 --> 00:15:02,480
scheduler so these are all the api's

00:15:00,260 --> 00:15:03,860
they're currently exports and I think

00:15:02,480 --> 00:15:05,090
some of them look really cool if you

00:15:03,860 --> 00:15:07,160
have a look at some of them you can

00:15:05,090 --> 00:15:08,690
request when the next paint is you can

00:15:07,160 --> 00:15:10,370
check if the browser should yield to you

00:15:08,690 --> 00:15:13,100
you can

00:15:10,370 --> 00:15:14,330
do unstable necks which is hey I want an

00:15:13,100 --> 00:15:16,930
update to happen but I don't need to

00:15:14,330 --> 00:15:21,170
happen right now so I can get a lot of

00:15:16,930 --> 00:15:24,589
performance updates out of that you can

00:15:21,170 --> 00:15:26,330
pause execution as a scheduler yeah and

00:15:24,589 --> 00:15:34,160
you can do quite a lot of stuff without

00:15:26,330 --> 00:15:37,670
priority so the work loop happens back

00:15:34,160 --> 00:15:42,290
in the render sorry the commit phase and

00:15:37,670 --> 00:15:43,940
this runs over every element and every

00:15:42,290 --> 00:15:47,420
element that needs to be processed and

00:15:43,940 --> 00:15:49,040
then it runs in the schedule to make

00:15:47,420 --> 00:15:51,230
sure these happen in the correct order

00:15:49,040 --> 00:15:53,150
because there could be other things like

00:15:51,230 --> 00:15:54,890
Dom updates and events that need to

00:15:53,150 --> 00:15:59,390
happen in the meantime I don't really

00:15:54,890 --> 00:16:03,770
have much explanation other than the

00:15:59,390 --> 00:16:06,950
structure of it so the structure what it

00:16:03,770 --> 00:16:08,779
needs to do it needs to be able to do

00:16:06,950 --> 00:16:10,130
some work which is what everything is

00:16:08,779 --> 00:16:11,870
good and round everything is work which

00:16:10,130 --> 00:16:16,480
makes everything really complicated to

00:16:11,870 --> 00:16:23,900
read because every API just says work

00:16:16,480 --> 00:16:24,890
and because this is asynchronous sorry I

00:16:23,900 --> 00:16:26,150
think I said this happening in the

00:16:24,890 --> 00:16:27,950
commit where it happens in a random and

00:16:26,150 --> 00:16:30,709
because this is asynchronous and runs

00:16:27,950 --> 00:16:36,589
over the Dom it needs to be able to stop

00:16:30,709 --> 00:16:39,470
and pick up where it left off so there

00:16:36,589 --> 00:16:42,500
are very few ways of doing this without

00:16:39,470 --> 00:16:46,300
losing data one way it does this is like

00:16:42,500 --> 00:16:51,110
with these three pointers in each node

00:16:46,300 --> 00:16:53,360
so child sibling and returned so this is

00:16:51,110 --> 00:16:56,690
kind of hard to explain but this is the

00:16:53,360 --> 00:16:59,540
wirklich concurrent as long as it has a

00:16:56,690 --> 00:17:03,050
work in progress this is a global

00:16:59,540 --> 00:17:04,790
variable in far so if something updates

00:17:03,050 --> 00:17:08,000
work in progress in one of these

00:17:04,790 --> 00:17:10,939
function being called it will attach

00:17:08,000 --> 00:17:13,429
itself to this while loop and still work

00:17:10,939 --> 00:17:19,069
so it checks if it should yield because

00:17:13,429 --> 00:17:21,829
this runs over every Roman and so the

00:17:19,069 --> 00:17:23,230
work in progress performs a unit of work

00:17:21,829 --> 00:17:26,189
on the root node

00:17:23,230 --> 00:17:29,919
and then what it does is it begins work

00:17:26,189 --> 00:17:33,490
so yeah begin to work and then begin

00:17:29,919 --> 00:17:42,100
work all it does is right now let's

00:17:33,490 --> 00:17:43,990
imagine that this sorry I'm having yeah

00:17:42,100 --> 00:17:47,110
so let's imagine that this console.log

00:17:43,990 --> 00:17:48,400
just actually completes work and puts it

00:17:47,110 --> 00:17:52,630
into the right place updating the

00:17:48,400 --> 00:17:54,910
elements then so we begin the work for

00:17:52,630 --> 00:17:57,280
this work perform for this and then we

00:17:54,910 --> 00:17:59,200
return the work in progress charge for

00:17:57,280 --> 00:18:02,350
that to be performed as well back here

00:17:59,200 --> 00:18:03,970
so we perform the work and then the next

00:18:02,350 --> 00:18:07,240
block in progress is the child and then

00:18:03,970 --> 00:18:08,230
that continues again so until it does

00:18:07,240 --> 00:18:11,620
not have a child anymore

00:18:08,230 --> 00:18:15,760
it goes once it doesn't have a child so

00:18:11,620 --> 00:18:18,090
next is equal to null what it does is it

00:18:15,760 --> 00:18:21,760
continues into complete unit of work and

00:18:18,090 --> 00:18:25,120
this is where the data structure allows

00:18:21,760 --> 00:18:26,290
it to be able to process siblings

00:18:25,120 --> 00:18:28,780
without using a tree because the tree

00:18:26,290 --> 00:18:31,360
means you go down one path and then lose

00:18:28,780 --> 00:18:32,559
that other half of the tree if it stops

00:18:31,360 --> 00:18:35,350
working at that point once the deadline

00:18:32,559 --> 00:18:37,690
is met so it goes into the next unit

00:18:35,350 --> 00:18:39,429
work and it checks if it has a sibling

00:18:37,690 --> 00:18:43,000
fiber if it has a sibling 5-bit returns

00:18:39,429 --> 00:18:44,710
that well actually initially it

00:18:43,000 --> 00:18:49,390
completes the work for the current

00:18:44,710 --> 00:18:50,799
element so the return statement and if

00:18:49,390 --> 00:18:51,910
has a sibling and goes down that tree

00:18:50,799 --> 00:18:56,140
and keeps going and going and going

00:18:51,910 --> 00:18:58,450
across and down and that returns it back

00:18:56,140 --> 00:19:04,360
and eventually gets all of them back

00:18:58,450 --> 00:19:08,110
into the complete work State so the

00:19:04,360 --> 00:19:12,760
update queue is just a fancy complicated

00:19:08,110 --> 00:19:14,679
way of updating state it goes over so

00:19:12,760 --> 00:19:16,090
when the render phase happens it

00:19:14,679 --> 00:19:19,360
captures all the updates that need to

00:19:16,090 --> 00:19:21,360
happen in the fibers and then when the

00:19:19,360 --> 00:19:24,460
commit happens it picks up all of these

00:19:21,360 --> 00:19:26,950
fibers that need to be updated and runs

00:19:24,460 --> 00:19:28,770
that are baked you with a next effect

00:19:26,950 --> 00:19:31,090
which happens which in effect is

00:19:28,770 --> 00:19:34,600
effective and in fact is effectively

00:19:31,090 --> 00:19:37,180
what that are they queue does affect as

00:19:34,600 --> 00:19:46,190
a term they use for a side effect

00:19:37,180 --> 00:19:49,910
which is just set States so I'm getting

00:19:46,190 --> 00:19:52,280
kind of close to the end here it's just

00:19:49,910 --> 00:19:54,140
an example of something I saw in a web

00:19:52,280 --> 00:19:56,180
what this could be useful which I

00:19:54,140 --> 00:20:01,940
thought was quite cool so say you're

00:19:56,180 --> 00:20:05,630
setting an input value in react and that

00:20:01,940 --> 00:20:08,480
updates value on the server or wherever

00:20:05,630 --> 00:20:12,800
and you only want the unchanged call

00:20:08,480 --> 00:20:15,470
back at the top to happen after some

00:20:12,800 --> 00:20:17,780
sort of priority you say unstable next

00:20:15,470 --> 00:20:21,380
and then you trigger that one change for

00:20:17,780 --> 00:20:23,210
reason and even lower priority is you

00:20:21,380 --> 00:20:25,010
want to trigger some analytics but you

00:20:23,210 --> 00:20:27,440
don't want all these analytics requests

00:20:25,010 --> 00:20:28,910
to be going off and it be messing up the

00:20:27,440 --> 00:20:30,590
performance your application so you give

00:20:28,910 --> 00:20:35,000
it a low priority and then you send that

00:20:30,590 --> 00:20:38,810
update into analytics and this is just a

00:20:35,000 --> 00:20:41,090
way of being able to split up your code

00:20:38,810 --> 00:20:47,930
into more performant pieces but I really

00:20:41,090 --> 00:20:49,880
think if we go back to yeah I think it's

00:20:47,930 --> 00:20:51,470
some of these api's are really important

00:20:49,880 --> 00:20:55,010
in the web and I think it's really cool

00:20:51,470 --> 00:20:56,510
that they're not going to be just stuck

00:20:55,010 --> 00:20:58,910
inside react hopefully you'll be able to

00:20:56,510 --> 00:21:00,500
use this inside of any repository in the

00:20:58,910 --> 00:21:06,890
future but you should keep checking back

00:21:00,500 --> 00:21:08,960
on that so thanks for listening and I

00:21:06,890 --> 00:21:13,570
hope it was useful for those who didn't

00:21:08,960 --> 00:21:13,570
raise a hand when I said to use react

00:21:16,559 --> 00:21:18,620

YouTube URL: https://www.youtube.com/watch?v=HBHw3HbF2zU


