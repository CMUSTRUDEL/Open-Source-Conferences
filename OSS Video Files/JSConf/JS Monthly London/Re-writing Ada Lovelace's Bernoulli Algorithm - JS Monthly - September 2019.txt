Title: Re-writing Ada Lovelace's Bernoulli Algorithm - JS Monthly - September 2019
Publication date: 2019-10-02
Playlist: JS Monthly London
Description: 
	Presented by Sam Galson.

The very first computer program was Ada Lovelace's calculator for Bernoulli numbers. Inspired by the 200th Anniversary of her birth I set about re-writing that program in every language I knew. And several I didn't. I'm aiming for 99...

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,319
first just brief words Who am I I'm a

00:00:02,460 --> 00:00:06,569
software engineer I work for a company

00:00:04,319 --> 00:00:08,940
called Wildey we're a consultancy

00:00:06,569 --> 00:00:10,700
specializing in JavaScript and

00:00:08,940 --> 00:00:14,210
kubernetes

00:00:10,700 --> 00:00:17,609
and I write a lot of blog posts

00:00:14,210 --> 00:00:19,590
that's my medium profile please go there

00:00:17,609 --> 00:00:21,630
and like and share and it makes a big

00:00:19,590 --> 00:00:24,590
difference if you enjoyed this talk it's

00:00:21,630 --> 00:00:24,590
the best way to thank me

00:00:24,920 --> 00:00:32,009
so what this talk is not about is either

00:00:28,890 --> 00:00:33,360
of these things Oracle if you know what

00:00:32,009 --> 00:00:36,000
that Boston thing is my commiserations

00:00:33,360 --> 00:00:38,390
know about that either what it is about

00:00:36,000 --> 00:00:43,500
is something called the Oracle problem

00:00:38,390 --> 00:00:48,809
what is the Oracle problem so the term

00:00:43,500 --> 00:00:51,480
Oracle first entered computer science in

00:00:48,809 --> 00:00:53,360
the writing of cheering he introduced it

00:00:51,480 --> 00:00:55,379
to me something that you given a

00:00:53,360 --> 00:00:57,360
computer or a Turing machine which is an

00:00:55,379 --> 00:01:00,090
abstract computer comes from outside

00:00:57,360 --> 00:01:02,899
that machine and enables that machine to

00:01:00,090 --> 00:01:05,309
solve a problem without any computation

00:01:02,899 --> 00:01:07,740
and this was useful for theorizing about

00:01:05,309 --> 00:01:11,400
various problems in computational

00:01:07,740 --> 00:01:14,040
science and then a bit later in I think

00:01:11,400 --> 00:01:17,460
it was the 70s this idea was taken up in

00:01:14,040 --> 00:01:22,320
the then nascent field of software

00:01:17,460 --> 00:01:24,720
testing because tests rely essentially

00:01:22,320 --> 00:01:26,009
on Oracle's so how do you know your

00:01:24,720 --> 00:01:30,390
system is functioning you have to have

00:01:26,009 --> 00:01:32,460
some kind of external input that

00:01:30,390 --> 00:01:36,180
typically consists of three parts you

00:01:32,460 --> 00:01:37,619
have what's called a generator which is

00:01:36,180 --> 00:01:40,350
somewhere where you create an

00:01:37,619 --> 00:01:42,150
expectation you have a comparator which

00:01:40,350 --> 00:01:44,490
is some actual data to compare to your

00:01:42,150 --> 00:01:47,640
expectation and you have an evaluator

00:01:44,490 --> 00:01:50,570
which is the session and we're probably

00:01:47,640 --> 00:01:56,549
all written hundreds of tests like this

00:01:50,570 --> 00:02:00,380
these are test Oracle's this is also an

00:01:56,549 --> 00:02:00,380
Oracle does anyone know who this is

00:02:00,619 --> 00:02:03,619
polymerase

00:02:03,810 --> 00:02:12,790
IRA philadelphi correct well done so way

00:02:09,700 --> 00:02:17,380
before cheering the Greeks did an awful

00:02:12,790 --> 00:02:18,880
lot of thinking about Oracle's and one

00:02:17,380 --> 00:02:21,610
of the cap stones of this thinking was

00:02:18,880 --> 00:02:23,680
this this profound thought by the

00:02:21,610 --> 00:02:25,840
philosopher Heraclitus he wrote that the

00:02:23,680 --> 00:02:32,580
God whose Oracle is a Delfy neither

00:02:25,840 --> 00:02:35,410
speaks nor conceals but gives a sign so

00:02:32,580 --> 00:02:38,410
the Greeks were well aware of problems

00:02:35,410 --> 00:02:41,350
with Oracle's and the story they told to

00:02:38,410 --> 00:02:44,709
illustrate these problems was often the

00:02:41,350 --> 00:02:47,620
story of the rich King Croesus so I'm

00:02:44,709 --> 00:02:49,090
going to tell you that now Croesus was

00:02:47,620 --> 00:02:50,980
the richest king in the world he was

00:02:49,090 --> 00:02:53,890
from Asia Minor and he was fascinated by

00:02:50,980 --> 00:02:55,930
Oracle's he thought he would give them

00:02:53,890 --> 00:02:59,590
he thought that they could give him an

00:02:55,930 --> 00:03:01,720
edge over his enemies so he went to the

00:02:59,590 --> 00:03:06,040
Oracle at Delphi he was thinking about

00:03:01,720 --> 00:03:07,630
invading the Persians and he so he said

00:03:06,040 --> 00:03:11,320
well what will happen if i invade the

00:03:07,630 --> 00:03:16,150
persian empire the Oracle said if you do

00:03:11,320 --> 00:03:18,459
this a great Empire will fall in Croesus

00:03:16,150 --> 00:03:20,350
went away delighted of course this means

00:03:18,459 --> 00:03:21,730
that I'm going to win so he made it and

00:03:20,350 --> 00:03:25,390
of course the Empire that fell was his

00:03:21,730 --> 00:03:28,269
own and the Greek historian Herodotus he

00:03:25,390 --> 00:03:29,830
tells this this story says well this

00:03:28,269 --> 00:03:31,900
shows that when you're going for an

00:03:29,830 --> 00:03:35,019
Oracle you really need to go back again

00:03:31,900 --> 00:03:36,580
you really need two Oracle's one get to

00:03:35,019 --> 00:03:38,640
give you your achill and a second one to

00:03:36,580 --> 00:03:41,290
clarify what that Oracle actually meant

00:03:38,640 --> 00:03:43,290
and we really we have this exact same

00:03:41,290 --> 00:03:46,450
problem with tests Oracle's

00:03:43,290 --> 00:03:48,640
almost all of our tests are testing one

00:03:46,450 --> 00:03:50,410
thing I make sure we have multiple tests

00:03:48,640 --> 00:03:54,100
but each interval individual tests

00:03:50,410 --> 00:03:55,600
should test one thing we run our tests

00:03:54,100 --> 00:03:58,000
with a limited number of initial States

00:03:55,600 --> 00:03:59,530
typically one we generate actual data

00:03:58,000 --> 00:04:01,540
from a limited number of inputs again

00:03:59,530 --> 00:04:04,450
often one and we make a limited number

00:04:01,540 --> 00:04:06,130
of assertions about that data what this

00:04:04,450 --> 00:04:10,299
means is that our test Oracle's are

00:04:06,130 --> 00:04:12,110
deceptive the classic example of this is

00:04:10,299 --> 00:04:14,060
a test suite that has 100%

00:04:12,110 --> 00:04:19,850
coverage but doesn't actually test

00:04:14,060 --> 00:04:21,260
anything valuable in the code so this

00:04:19,850 --> 00:04:23,810
this is the Oracle problem

00:04:21,260 --> 00:04:26,680
it's that Oracle's somehow don't quite

00:04:23,810 --> 00:04:32,030
capture the complexity of the system

00:04:26,680 --> 00:04:32,660
that we're trying to test what can we do

00:04:32,030 --> 00:04:35,030
about it

00:04:32,660 --> 00:04:38,240
and here is where I reveal what this

00:04:35,030 --> 00:04:40,120
talk is actually about so B or one of

00:04:38,240 --> 00:04:43,520
the solutions to the Oracle problem is

00:04:40,120 --> 00:04:46,820
fuzz testing first testing is a very

00:04:43,520 --> 00:04:48,350
generic term you'll hear it used to

00:04:46,820 --> 00:04:49,700
describe something very specific but

00:04:48,350 --> 00:04:54,980
actually it can be used to describe all

00:04:49,700 --> 00:04:56,660
sorts of things so just just curiosity

00:04:54,980 --> 00:05:05,630
how many people have actually done fuzz

00:04:56,660 --> 00:05:07,640
testing okay what is it so the basic

00:05:05,630 --> 00:05:10,010
idea that common to all the sorts of

00:05:07,640 --> 00:05:12,950
post testing is that instead of writing

00:05:10,010 --> 00:05:16,160
our tests Oracle's by hand we generate

00:05:12,950 --> 00:05:19,310
them automatically so now instead of one

00:05:16,160 --> 00:05:23,750
100 1000 tests we can have 10,000

00:05:19,310 --> 00:05:25,640
100,000 okay this doesn't solve the

00:05:23,750 --> 00:05:27,500
Oracle problem because the end of the

00:05:25,640 --> 00:05:29,510
day these Oracle's are still finite

00:05:27,500 --> 00:05:31,790
human representations of the divine

00:05:29,510 --> 00:05:34,130
truths of our program they're not going

00:05:31,790 --> 00:05:38,450
to fully capture it but it's a good

00:05:34,130 --> 00:05:42,229
mitigation so these are some of the ways

00:05:38,450 --> 00:05:47,090
you can chop up first testing I'm going

00:05:42,229 --> 00:05:49,550
to go through each of these so no one

00:05:47,090 --> 00:05:51,590
here is or will admit to having having

00:05:49,550 --> 00:05:54,140
done it that bad is really the main

00:05:51,590 --> 00:05:56,320
motivation for my interest in this topic

00:05:54,140 --> 00:06:00,740
because there are other communities

00:05:56,320 --> 00:06:03,140
where fuzz testing is quite popular in

00:06:00,740 --> 00:06:05,810
the JavaScript community there's very

00:06:03,140 --> 00:06:07,280
little knowledge about fuzz testing and

00:06:05,810 --> 00:06:09,890
our tooling is lagging behind that of

00:06:07,280 --> 00:06:11,270
other languages and so it's hard for us

00:06:09,890 --> 00:06:15,680
to get a sense of the value of these

00:06:11,270 --> 00:06:17,240
techniques and it's a vicious circle so

00:06:15,680 --> 00:06:19,910
I'm going to show you what we can do

00:06:17,240 --> 00:06:21,560
today in JavaScript and where the

00:06:19,910 --> 00:06:24,460
opportunities are for contributing to

00:06:21,560 --> 00:06:24,460
existing projects

00:06:24,860 --> 00:06:30,960
first thing we can do is cheat so

00:06:27,750 --> 00:06:35,340
actually this is probably the quickest

00:06:30,960 --> 00:06:37,919
way to get a good result a good return

00:06:35,340 --> 00:06:39,509
on your investment with both testing so

00:06:37,919 --> 00:06:42,080
instead of generating your because

00:06:39,509 --> 00:06:47,069
automatically you just pulled from a a

00:06:42,080 --> 00:06:49,229
crowd-sourced list of input that's known

00:06:47,069 --> 00:06:51,330
to be problematic for a lot of systems

00:06:49,229 --> 00:06:53,310
which aren't sufficiently robust so this

00:06:51,330 --> 00:06:56,190
is a thing you can find I'll get her

00:06:53,310 --> 00:06:58,229
bits text file with just a thousand

00:06:56,190 --> 00:06:59,789
strings that if you fire them into your

00:06:58,229 --> 00:07:05,220
application could well break it if

00:06:59,789 --> 00:07:07,699
you've not been careful enough oops it's

00:07:05,220 --> 00:07:10,110
dead easy to use you can download

00:07:07,699 --> 00:07:11,669
artillery which is a load testing

00:07:10,110 --> 00:07:13,530
framework but it has this nice plugin

00:07:11,669 --> 00:07:17,310
that integrates with the list of not

00:07:13,530 --> 00:07:20,370
naughty strings you just this is telling

00:07:17,310 --> 00:07:23,880
artillery fire using a password Jason at

00:07:20,370 --> 00:07:25,620
my session endpoint and do it hundreds

00:07:23,880 --> 00:07:27,360
of times and each time you do it use a

00:07:25,620 --> 00:07:29,039
different naughty string

00:07:27,360 --> 00:07:34,979
and really that's all the config you

00:07:29,039 --> 00:07:36,479
knew it's that simple just to give you

00:07:34,979 --> 00:07:39,750
an example of the kind of bugs this can

00:07:36,479 --> 00:07:43,889
catch this was a bug very popular bug in

00:07:39,750 --> 00:07:46,199
JIRA a few years ago now someone figured

00:07:43,889 --> 00:07:47,759
out if you put an emoji in the right

00:07:46,199 --> 00:07:52,650
field you could take down your company's

00:07:47,759 --> 00:07:54,330
JIRA system one of the few examples of a

00:07:52,650 --> 00:07:56,580
bug that actually improves the software

00:07:54,330 --> 00:07:59,219
but you can this is the kind of thing

00:07:56,580 --> 00:08:02,880
you can avoid if you just just take that

00:07:59,219 --> 00:08:04,289
simple step with artillery so now the

00:08:02,880 --> 00:08:07,139
second cut type of first system I

00:08:04,289 --> 00:08:08,580
mentioned is called blind fuzzing this

00:08:07,139 --> 00:08:09,780
is where we do actually generate data

00:08:08,580 --> 00:08:13,080
and there's a couple of command-line

00:08:09,780 --> 00:08:17,969
tools you can use to do this the basic

00:08:13,080 --> 00:08:19,500
idea is we have a seed which explain

00:08:17,969 --> 00:08:21,150
what that is in a minute we have some

00:08:19,500 --> 00:08:27,120
data which is our input which in this

00:08:21,150 --> 00:08:31,770
case is hello we our program will mutate

00:08:27,120 --> 00:08:35,789
that data randomly and it will those do

00:08:31,770 --> 00:08:37,450
so using a seed the seed allows us to

00:08:35,789 --> 00:08:41,469
recreate that mutation

00:08:37,450 --> 00:08:46,180
- so the mutation is random esque but

00:08:41,469 --> 00:08:47,470
deterministic based on the seed and the

00:08:46,180 --> 00:08:49,570
output something like this it doesn't

00:08:47,470 --> 00:08:50,950
crash or Terminal which is good if you

00:08:49,570 --> 00:08:53,350
did crash the terminal then we would

00:08:50,950 --> 00:08:58,839
have discovered a bug using closed

00:08:53,350 --> 00:09:00,519
testing I'm going to skip over this a

00:08:58,839 --> 00:09:02,550
bit but so what one of them the main

00:09:00,519 --> 00:09:04,630
applications for us testing is

00:09:02,550 --> 00:09:06,490
situations where we we literally don't

00:09:04,630 --> 00:09:07,720
know what Oracle's to write and a good

00:09:06,490 --> 00:09:08,860
example these systems that are so

00:09:07,720 --> 00:09:12,130
complicated that we don't know what

00:09:08,860 --> 00:09:15,880
their output should be but I really want

00:09:12,130 --> 00:09:17,380
to argue that processing actually has

00:09:15,880 --> 00:09:19,480
much broader applications than that

00:09:17,380 --> 00:09:22,750
that's just the traditional way in which

00:09:19,480 --> 00:09:26,139
is being used this is a library worth

00:09:22,750 --> 00:09:28,570
checking out called sink dweller it's

00:09:26,139 --> 00:09:30,220
it's very simple just a node wrapper for

00:09:28,570 --> 00:09:34,300
atoms Oh which is another command line

00:09:30,220 --> 00:09:36,130
further like because of what's quite

00:09:34,300 --> 00:09:39,519
nice about it is you can choose an

00:09:36,130 --> 00:09:43,630
insertion point so this is just doing

00:09:39,519 --> 00:09:47,079
the same thing as I showed you but you

00:09:43,630 --> 00:09:48,279
can choose an insertion point so some

00:09:47,079 --> 00:09:50,199
bit of data is coming into your

00:09:48,279 --> 00:09:51,760
application you decide from this point

00:09:50,199 --> 00:09:53,170
on this stage will be fuzzed so every

00:09:51,760 --> 00:09:54,579
time the application is run the date

00:09:53,170 --> 00:10:00,760
will be slightly different based on what

00:09:54,579 --> 00:10:03,790
came in and Radames au produces output

00:10:00,760 --> 00:10:05,740
like this you'll notice the style of the

00:10:03,790 --> 00:10:08,140
fuzzing is quite different deserve so

00:10:05,740 --> 00:10:11,050
you get much more varying output much

00:10:08,140 --> 00:10:13,680
more quickly so it's just something to

00:10:11,050 --> 00:10:16,990
bear in mind when choosing between them

00:10:13,680 --> 00:10:18,220
and okay on to the next type of fuzzing

00:10:16,990 --> 00:10:19,480
and the next step up in terms of

00:10:18,220 --> 00:10:21,880
sophistication is something called

00:10:19,480 --> 00:10:23,260
genetic fuzzing so now instead of just

00:10:21,880 --> 00:10:26,980
throwing random input that our

00:10:23,260 --> 00:10:30,160
application and seeing what happens we

00:10:26,980 --> 00:10:33,760
use code coverage to reflect on that

00:10:30,160 --> 00:10:35,819
input and select further input which is

00:10:33,760 --> 00:10:38,550
more likely to trigger a bug

00:10:35,819 --> 00:10:41,620
so the algorithm for these sorts of

00:10:38,550 --> 00:10:43,149
photos works basically like this you

00:10:41,620 --> 00:10:46,029
have a list of inputs that you start

00:10:43,149 --> 00:10:48,459
with you pop an input you fuzz it you

00:10:46,029 --> 00:10:50,860
run your code you then check did that

00:10:48,459 --> 00:10:53,860
increase the coverage if so you

00:10:50,860 --> 00:10:56,560
your first input back on the list and do

00:10:53,860 --> 00:10:59,680
the same thing again and this allows you

00:10:56,560 --> 00:11:02,290
to serve narrow could narrow down your

00:10:59,680 --> 00:11:04,120
eventually your fudged input to exercise

00:11:02,290 --> 00:11:06,570
as many paths of the application as

00:11:04,120 --> 00:11:06,570
possible

00:11:06,660 --> 00:11:11,050
American fuzzy lob is the oldest and

00:11:08,920 --> 00:11:11,470
most popular piece of software for doing

00:11:11,050 --> 00:11:13,570
this

00:11:11,470 --> 00:11:16,480
it's designed to work with see the

00:11:13,570 --> 00:11:17,980
problem with genetic fuzzing is that you

00:11:16,480 --> 00:11:21,130
need to instrument your code for the

00:11:17,980 --> 00:11:23,920
coverage so that means if you port

00:11:21,130 --> 00:11:25,420
American fuzzy lot to a new language but

00:11:23,920 --> 00:11:26,950
that means you have to port it to a new

00:11:25,420 --> 00:11:31,840
language you can't just run it on your

00:11:26,950 --> 00:11:33,730
JavaScript application unless you

00:11:31,840 --> 00:11:35,380
recompile node with afl's

00:11:33,730 --> 00:11:37,440
instrumentation but that's probably not

00:11:35,380 --> 00:11:41,380
a good way to do it

00:11:37,440 --> 00:11:44,800
ports exist for several languages in go

00:11:41,380 --> 00:11:48,190
it's very popular - it has a nice stable

00:11:44,800 --> 00:11:50,080
library rust again relatively popular

00:11:48,190 --> 00:11:56,140
javascript has one library which doesn't

00:11:50,080 --> 00:11:57,580
work I I've checked it out it looks like

00:11:56,140 --> 00:11:59,950
it's kind of halfway there or three

00:11:57,580 --> 00:12:01,960
courses away there I think it's a great

00:11:59,950 --> 00:12:03,640
thing for someone to pick up and get us

00:12:01,960 --> 00:12:09,610
a working AFL implementation in Java

00:12:03,640 --> 00:12:15,270
scripts shouldn't be that hard what's

00:12:09,610 --> 00:12:20,380
the next kind of fuzzing well not blind

00:12:15,270 --> 00:12:23,950
it's something called grammar based

00:12:20,380 --> 00:12:27,640
buzzing so these are some libraries that

00:12:23,950 --> 00:12:29,620
do grammar based fuzzing grammar based

00:12:27,640 --> 00:12:31,900
fuzzing is where we write a grammar

00:12:29,620 --> 00:12:36,310
which constrains what our first data

00:12:31,900 --> 00:12:37,300
will look like so we sort of narrowing

00:12:36,310 --> 00:12:39,280
down now

00:12:37,300 --> 00:12:40,810
the types of input that we're firing in

00:12:39,280 --> 00:12:42,490
our application we're going to end up

00:12:40,810 --> 00:12:44,350
much more quickly with input that

00:12:42,490 --> 00:12:47,260
penetrates deep into our application and

00:12:44,350 --> 00:12:49,420
target specific areas but we're going to

00:12:47,260 --> 00:12:55,030
have less exposure to those and more

00:12:49,420 --> 00:12:57,220
edgier edge cases this is an example of

00:12:55,030 --> 00:13:00,130
a grammar written with Dharma that will

00:12:57,220 --> 00:13:01,810
give you a valid URL so you run the

00:13:00,130 --> 00:13:04,710
puzzle and you'll just get as many valid

00:13:01,810 --> 00:13:04,710
URLs as you like

00:13:05,240 --> 00:13:11,940
okay but if we're generating specific

00:13:09,180 --> 00:13:13,620
data types like URLs why not just

00:13:11,940 --> 00:13:16,440
generate our data types within

00:13:13,620 --> 00:13:18,180
JavaScript natively generally we we

00:13:16,440 --> 00:13:21,420
trust the JavaScript runtime to deal

00:13:18,180 --> 00:13:25,800
with degenerate data types so why not

00:13:21,420 --> 00:13:29,040
just work from that basis there's a few

00:13:25,800 --> 00:13:31,860
options that allow us to do that it's a

00:13:29,040 --> 00:13:34,740
very simple one opto from Mozilla

00:13:31,860 --> 00:13:38,160
Mozilla maintaining gamma or as well do

00:13:34,740 --> 00:13:39,630
to in general do a lot of composing so

00:13:38,160 --> 00:13:43,650
this will allow you to generate some

00:13:39,630 --> 00:13:46,170
random stuff and it's not like faker

00:13:43,650 --> 00:13:47,460
so faker gives you realistic data this

00:13:46,170 --> 00:13:53,810
gives you data that's designed to break

00:13:47,460 --> 00:13:53,810
your application you get stuff like that

00:13:54,890 --> 00:14:00,780
we can use fazool

00:13:57,770 --> 00:14:03,720
which we pass an object and it will

00:14:00,780 --> 00:14:05,910
mutate every key in that object I'm

00:14:03,720 --> 00:14:13,740
inspecting what the type is just easy it

00:14:05,910 --> 00:14:15,630
potentially get something like that okay

00:14:13,740 --> 00:14:18,540
now once we have the ability to generate

00:14:15,630 --> 00:14:20,010
native data types we can actually do

00:14:18,540 --> 00:14:24,200
something much more interesting than

00:14:20,010 --> 00:14:27,450
just firing those randomly at our

00:14:24,200 --> 00:14:32,160
application we can do something called

00:14:27,450 --> 00:14:34,140
generative or property based testing so

00:14:32,160 --> 00:14:36,120
what we do with this is we test

00:14:34,140 --> 00:14:40,350
individual functions we fuzz individual

00:14:36,120 --> 00:14:45,300
functions so we tell our test on its

00:14:40,350 --> 00:14:47,480
what types that function expects and

00:14:45,300 --> 00:14:52,650
instead of just giving it one test case

00:14:47,480 --> 00:14:56,250
we fuzz the input to that function such

00:14:52,650 --> 00:14:58,260
that the input satisfies the type and we

00:14:56,250 --> 00:15:00,090
assert on what is referred to as a

00:14:58,260 --> 00:15:03,420
property of that function that is

00:15:00,090 --> 00:15:06,030
something that has to remain constant

00:15:03,420 --> 00:15:08,390
just whatever valid input you've given

00:15:06,030 --> 00:15:08,390
to the phone

00:15:11,060 --> 00:15:17,579
now generative testing in particular has

00:15:14,610 --> 00:15:21,199
achieved quite a wide level of adoption

00:15:17,579 --> 00:15:24,930
and popularity in other ecosystems a

00:15:21,199 --> 00:15:26,699
good example is closure where not only

00:15:24,930 --> 00:15:28,579
is it part of the core library but the

00:15:26,699 --> 00:15:31,319
writers is the closure documentation

00:15:28,579 --> 00:15:35,730
actually assert that it's better than

00:15:31,319 --> 00:15:38,220
standard unit testing so my question is

00:15:35,730 --> 00:15:39,569
really why there's no a few people do

00:15:38,220 --> 00:15:42,089
but basically no one does this in

00:15:39,569 --> 00:15:45,060
JavaScript and I don't think it's a good

00:15:42,089 --> 00:15:47,670
reason for that other than as I said

00:15:45,060 --> 00:15:49,019
this vicious circle of sort of there not

00:15:47,670 --> 00:15:54,600
being any tools looking around and no

00:15:49,019 --> 00:15:56,100
one really knowing about it in Python

00:15:54,600 --> 00:15:57,660
the situation is very different there's

00:15:56,100 --> 00:16:00,480
quite an old and very actively

00:15:57,660 --> 00:16:04,670
maintained library called hypothesis for

00:16:00,480 --> 00:16:06,660
doing property based testing and

00:16:04,670 --> 00:16:08,459
actually in JavaScript

00:16:06,660 --> 00:16:11,009
having said that we didn't have good

00:16:08,459 --> 00:16:12,690
tools actually we do have good tools for

00:16:11,009 --> 00:16:15,060
generative base testing in JavaScript

00:16:12,690 --> 00:16:18,930
one problem is we have too many of them

00:16:15,060 --> 00:16:20,250
no really well they limit things but it

00:16:18,930 --> 00:16:24,839
makes it more confusing if you're new to

00:16:20,250 --> 00:16:27,300
this but there's plenty of stuff you can

00:16:24,839 --> 00:16:31,199
check out so I'm going to give you an

00:16:27,300 --> 00:16:35,490
example using pests so here we're going

00:16:31,199 --> 00:16:37,680
to test a function called add 10 Max and

00:16:35,490 --> 00:16:40,050
we're specifying that our input so that

00:16:37,680 --> 00:16:41,939
this function here this function is

00:16:40,050 --> 00:16:44,459
wrong the developer commented out the

00:16:41,939 --> 00:16:48,209
code to make it work but what it should

00:16:44,459 --> 00:16:51,389
do is add two numbers except if they're

00:16:48,209 --> 00:16:54,300
greater than 10 return 10 so we set up

00:16:51,389 --> 00:16:57,569
our test by specifying the input types

00:16:54,300 --> 00:16:59,310
which are integers and then we set a

00:16:57,569 --> 00:17:02,490
property of that function which is that

00:16:59,310 --> 00:17:07,949
the result is always under 10 or equal

00:17:02,490 --> 00:17:10,199
to 10 and this library integrates with

00:17:07,949 --> 00:17:11,850
all the major testing libraries so we

00:17:10,199 --> 00:17:13,829
can write our tests in a nicer way like

00:17:11,850 --> 00:17:18,540
this if we're using gest we just have

00:17:13,829 --> 00:17:21,110
two more arguments to it function which

00:17:18,540 --> 00:17:21,110
are the types

00:17:21,529 --> 00:17:29,520
and this is the list of types that you

00:17:25,409 --> 00:17:35,909
get with the library you can also define

00:17:29,520 --> 00:17:37,770
your own types you can sample the type

00:17:35,909 --> 00:17:39,240
to see what it looks like this is a sort

00:17:37,770 --> 00:17:43,350
of data that will be passed in if you

00:17:39,240 --> 00:17:45,779
specify the Jason pipe now the really

00:17:43,350 --> 00:17:48,480
cool thing about these property base

00:17:45,779 --> 00:17:51,750
testing libraries is something called

00:17:48,480 --> 00:17:57,059
shrinking and this was something device

00:17:51,750 --> 00:18:00,600
in Haskell which was the first property

00:17:57,059 --> 00:18:02,220
based testing so it was the first

00:18:00,600 --> 00:18:06,539
language to incorporate property based

00:18:02,220 --> 00:18:08,970
testing in its call library and the idea

00:18:06,539 --> 00:18:12,690
of shrinking is that when the test

00:18:08,970 --> 00:18:15,179
harness detects a violation of your

00:18:12,690 --> 00:18:17,039
property instead of just testing you

00:18:15,179 --> 00:18:18,899
that this weird input instead of telling

00:18:17,039 --> 00:18:22,620
you that this weird input failed your

00:18:18,899 --> 00:18:25,559
test it progressively alters that input

00:18:22,620 --> 00:18:29,309
to shrink it to the smallest possible

00:18:25,559 --> 00:18:32,520
case that breaks your test so in this

00:18:29,309 --> 00:18:34,710
case it tried twenty-one and eight it

00:18:32,520 --> 00:18:39,720
figured out that the test failed so

00:18:34,710 --> 00:18:47,159
tried again looks like three times until

00:18:39,720 --> 00:18:48,419
it found the smallest failing test case

00:18:47,159 --> 00:18:51,720
which is three and eight now this is

00:18:48,419 --> 00:18:54,779
obviously incredibly helpful for helping

00:18:51,720 --> 00:18:59,130
you to figure out what why exactly your

00:18:54,779 --> 00:19:00,360
test failed okay so the main downside of

00:18:59,130 --> 00:19:03,240
generative testing is you need to

00:19:00,360 --> 00:19:06,510
annotate your types it's just a bit of a

00:19:03,240 --> 00:19:08,220
fart there are ways around this so

00:19:06,510 --> 00:19:10,860
here's a library if you're using flow

00:19:08,220 --> 00:19:15,380
which I guess is becoming less common

00:19:10,860 --> 00:19:18,149
nowadays but you can use this library to

00:19:15,380 --> 00:19:23,700
generate types based on your flow types

00:19:18,149 --> 00:19:31,320
so generate types for your tests based

00:19:23,700 --> 00:19:33,330
on your flow types that's how it works

00:19:31,320 --> 00:19:35,100
so problem with it not updated in two

00:19:33,330 --> 00:19:38,250
years not widely used missing

00:19:35,100 --> 00:19:42,180
functionality again a good thing for

00:19:38,250 --> 00:19:46,500
someone to pick up and work on another

00:19:42,180 --> 00:19:50,550
interesting library is just this will

00:19:46,500 --> 00:19:52,770
take in a joy specification and generate

00:19:50,550 --> 00:19:54,360
data based on that specification so you

00:19:52,770 --> 00:19:57,600
can use this in combination with a

00:19:54,360 --> 00:19:59,730
generative testing library to get your

00:19:57,600 --> 00:20:05,430
types for free if you're using joy

00:19:59,730 --> 00:20:06,090
schemas again proof of concept currently

00:20:05,430 --> 00:20:12,030
working progress

00:20:06,090 --> 00:20:15,330
mostly used by me so experimental and I

00:20:12,030 --> 00:20:17,190
haven't found one for typescript please

00:20:15,330 --> 00:20:23,810
someone make make something like this

00:20:17,190 --> 00:20:26,160
for typescript so there's various tricks

00:20:23,810 --> 00:20:28,970
identifying properties is difficult it's

00:20:26,160 --> 00:20:33,450
something that needs to be learned

00:20:28,970 --> 00:20:35,280
there's various avenues you can go down

00:20:33,450 --> 00:20:40,620
to try and help you do that I'm not

00:20:35,280 --> 00:20:42,210
gonna get too far into it the main thing

00:20:40,620 --> 00:20:43,530
I want to do is before we leave property

00:20:42,210 --> 00:20:45,270
based testing I want to mention this

00:20:43,530 --> 00:20:48,600
library which is currently the most

00:20:45,270 --> 00:20:50,100
actively developed that does this it's

00:20:48,600 --> 00:20:54,450
the one I would go to I think if I was

00:20:50,100 --> 00:20:56,850
going to use it on a project and it has

00:20:54,450 --> 00:20:58,680
one particular feature which I'd find

00:20:56,850 --> 00:21:01,170
very interesting which is something

00:20:58,680 --> 00:21:02,910
called model-based tests this is similar

00:21:01,170 --> 00:21:05,430
to generative testing but just again

00:21:02,910 --> 00:21:07,800
just another variation so what this is

00:21:05,430 --> 00:21:10,140
it's the testing mainly UI's and other

00:21:07,800 --> 00:21:15,890
state machines and it's for catching

00:21:10,140 --> 00:21:18,330
bugs of the sort that you find let's say

00:21:15,890 --> 00:21:21,630
let's say I have a bug on my login page

00:21:18,330 --> 00:21:23,910
which prevents me logging in but I only

00:21:21,630 --> 00:21:27,180
experience this bug if I go to some

00:21:23,910 --> 00:21:28,860
other page in the application as a

00:21:27,180 --> 00:21:30,180
normal writer of tests you're never

00:21:28,860 --> 00:21:31,590
gonna catch this bug in your test

00:21:30,180 --> 00:21:33,330
because you're not going to test all the

00:21:31,590 --> 00:21:37,950
parts that a user can take through your

00:21:33,330 --> 00:21:40,320
UI so instead what you do is you define

00:21:37,950 --> 00:21:43,110
a list of operations so that might be

00:21:40,320 --> 00:21:44,250
click this button you define

00:21:43,110 --> 00:21:46,590
preconditions for those

00:21:44,250 --> 00:21:50,430
operations so I can only click this

00:21:46,590 --> 00:21:52,800
button if I'm on this page and you

00:21:50,430 --> 00:21:54,930
assert on the post conditions so you say

00:21:52,800 --> 00:21:59,910
after I've clicked this button I should

00:21:54,930 --> 00:22:02,070
be on this other page now you have your

00:21:59,910 --> 00:22:03,510
list of operations the testing engine is

00:22:02,070 --> 00:22:05,790
going to combine them string them

00:22:03,510 --> 00:22:09,990
together to construct valid sequences of

00:22:05,790 --> 00:22:12,000
user events and generate as many as you

00:22:09,990 --> 00:22:14,100
like random sequences of user events and

00:22:12,000 --> 00:22:25,650
see if any of your post conditions are

00:22:14,100 --> 00:22:27,270
violated okay so classically a lot one

00:22:25,650 --> 00:22:28,890
reason these weren't used these sorts of

00:22:27,270 --> 00:22:35,040
testing techniques was lack of computing

00:22:28,890 --> 00:22:37,560
power that's no excuse anymore you can

00:22:35,040 --> 00:22:41,690
actually fully paralyze them if you want

00:22:37,560 --> 00:22:44,730
you probably won't need to most projects

00:22:41,690 --> 00:22:47,220
the real reason as I said is just I

00:22:44,730 --> 00:22:50,640
think lack of operational and practical

00:22:47,220 --> 00:22:53,190
understanding so we need to try these

00:22:50,640 --> 00:22:56,400
things but I want to finish by just

00:22:53,190 --> 00:22:59,250
reflecting on a another another issue

00:22:56,400 --> 00:23:00,720
which is so testing is notoriously one

00:22:59,250 --> 00:23:03,810
of the hardest parts of software

00:23:00,720 --> 00:23:06,990
engineering and one of the reasons for

00:23:03,810 --> 00:23:08,850
that is it's so difficult to know how

00:23:06,990 --> 00:23:11,580
much testing you should do what you

00:23:08,850 --> 00:23:13,470
should be testing and to be honest I

00:23:11,580 --> 00:23:15,390
think any any senior developer who tells

00:23:13,470 --> 00:23:17,910
you they know exactly what and how many

00:23:15,390 --> 00:23:19,710
tests there should be has probably just

00:23:17,910 --> 00:23:21,840
come to believe a lie but he told his

00:23:19,710 --> 00:23:26,370
line manager some or her line managers

00:23:21,840 --> 00:23:34,130
some time ago we don't have a good way

00:23:26,370 --> 00:23:34,130
of measuring test quality or do we

00:23:35,330 --> 00:23:41,580
so there is something called mutation

00:23:37,859 --> 00:23:43,019
testing and again I think this is one of

00:23:41,580 --> 00:23:44,460
the greatest things that hasn't yet made

00:23:43,019 --> 00:23:48,029
it big in the JavaScript community and I

00:23:44,460 --> 00:23:49,919
hope will soon the idea is simple your

00:23:48,029 --> 00:23:53,789
testing engine instead of mutating your

00:23:49,919 --> 00:23:56,450
input mutates your source code so it

00:23:53,789 --> 00:23:59,220
will do things like alter return values

00:23:56,450 --> 00:24:01,919
change equal statements to not equal

00:23:59,220 --> 00:24:04,619
statements so it alters your source code

00:24:01,919 --> 00:24:07,950
it then runs your tests and it sees if

00:24:04,619 --> 00:24:12,090
your tests fail if they do then that's a

00:24:07,950 --> 00:24:15,269
good sign if they don't then you fail to

00:24:12,090 --> 00:24:19,349
test you fail to capture what your

00:24:15,269 --> 00:24:21,619
application does in your tests so it

00:24:19,349 --> 00:24:23,909
performs lots of these make mutations

00:24:21,619 --> 00:24:26,009
every one which triggers a test failure

00:24:23,909 --> 00:24:28,139
is referred to as a kill it's a mutant

00:24:26,009 --> 00:24:30,269
that gets killed and you end up with a

00:24:28,139 --> 00:24:36,749
kill ratio which is an indication an

00:24:30,269 --> 00:24:39,389
indicator of how good your tests are and

00:24:36,749 --> 00:24:42,929
we actually have surprisingly a pretty

00:24:39,389 --> 00:24:46,379
good and almost mature now library for

00:24:42,929 --> 00:24:51,570
doing this in JavaScript check it out

00:24:46,379 --> 00:24:53,909
it's called Stryker that's it I've

00:24:51,570 --> 00:24:55,739
written quite a long blog post about all

00:24:53,909 --> 00:24:57,720
of this stuff so if you're interested in

00:24:55,739 --> 00:24:59,970
following any any bit up there's links

00:24:57,720 --> 00:25:03,840
and stuff there just check out my medium

00:24:59,970 --> 00:25:10,260
profile underscore Golson thank you

00:25:03,840 --> 00:25:10,260

YouTube URL: https://www.youtube.com/watch?v=11PAUUOkZHQ


