Title: Ole Michaelis: Whirlwind Tour through the HTTP2 Spec - JSUnconf 2016
Publication date: 2016-05-31
Playlist: JSUnconf 2016
Description: 
	Slides: https://slidr.io/nesQuick/whirlwind-tour-through-the-http2-spec

The Hypertext Transfer Protocol, which powers the modern web, has come a long way since its first version HTTP V0.9 in 1991 and with the final release of the Version 2 (HTTP2) specification at the beginning of 2015 a whole next chapter of web development is ahead of us! After a quick tour through the protocol history, you will discover the gems from in HTTP/2 spec, like server push or connection multiplexing, and see why this is an awesome step for a modern web. What can you already use today? And why today's best practices are tomorrow's antipatterns?
Captions: 
	00:00:10,310 --> 00:00:18,020
thank you okay I can fulfill this so

00:00:15,890 --> 00:00:20,779
this talk was designed to be like 45

00:00:18,020 --> 00:00:24,140
minutes it's mentioned woven talk so i

00:00:20,779 --> 00:00:25,580
guess i can go pre fast and i will go

00:00:24,140 --> 00:00:27,770
pretty fast if it's too fast just raise

00:00:25,580 --> 00:00:29,680
yen and we get the sordid I just tried

00:00:27,770 --> 00:00:32,480
to speak slow just skip more slides

00:00:29,680 --> 00:00:35,630
first question who of you is using HP to

00:00:32,480 --> 00:00:38,590
in production hands up it's like five

00:00:35,630 --> 00:00:41,239
hands almost it's great appreciate that

00:00:38,590 --> 00:00:43,070
for the other side before we start I

00:00:41,239 --> 00:00:46,790
really want to get the most important

00:00:43,070 --> 00:00:48,260
question sorted so first question is if

00:00:46,790 --> 00:00:52,070
you really done what do you think yeah

00:00:48,260 --> 00:00:53,870
yes raise your hands is it done well

00:00:52,070 --> 00:00:55,910
it's three hands really like yeah it's

00:00:53,870 --> 00:00:58,070
done sense of what you hear and I even

00:00:55,910 --> 00:01:00,350
mentioned this in my pitch by anyway so

00:00:58,070 --> 00:01:06,430
it's ssl mandatory yes raise your hands

00:01:00,350 --> 00:01:06,430
oh that's good fifty percent it's not

00:01:06,549 --> 00:01:12,080
but actually all implementations you

00:01:09,259 --> 00:01:16,850
will see in the wild they are only ssl

00:01:12,080 --> 00:01:19,039
so in IRL it's all encrypted but the

00:01:16,850 --> 00:01:23,359
specs say you can also use a plain text

00:01:19,039 --> 00:01:25,609
is it made by google no one great no

00:01:23,359 --> 00:01:31,280
it's not what speedy well it's just a

00:01:25,609 --> 00:01:35,649
different protocol is it plain text no

00:01:31,280 --> 00:01:35,649
it's not binary I had asked impressed

00:01:35,710 --> 00:01:44,479
yeah they are my favorite question so

00:01:39,619 --> 00:01:45,979
will you won't still work you think sure

00:01:44,479 --> 00:01:48,499
it will write and we will break the web

00:01:45,979 --> 00:01:50,960
even HP one it's still supported by the

00:01:48,499 --> 00:01:53,060
browser's all right in order to

00:01:50,960 --> 00:01:56,270
understand why HP to is kind of like

00:01:53,060 --> 00:01:58,789
great and amazing and so mind-blowing we

00:01:56,270 --> 00:02:01,999
have to understand what are the problems

00:01:58,789 --> 00:02:03,619
with the protocol we have in order to do

00:02:01,999 --> 00:02:08,990
that we need to take a look at the

00:02:03,619 --> 00:02:10,850
histories so in 1989 and 90-89 sorry Tim

00:02:08,990 --> 00:02:13,940
berners-lee invented or came up with

00:02:10,850 --> 00:02:16,700
this idea of the World Wide Web so where

00:02:13,940 --> 00:02:19,129
every researcher the CERN can share the

00:02:16,700 --> 00:02:22,159
results to other universities and wishes

00:02:19,129 --> 00:02:23,380
research centers and stuff and only two

00:02:22,159 --> 00:02:25,180
years later

00:02:23,380 --> 00:02:29,460
the first version the first version of

00:02:25,180 --> 00:02:32,470
HMG HTTP so version 09 was released

00:02:29,460 --> 00:02:35,470
going on in history just a few years

00:02:32,470 --> 00:02:39,130
later version the first version draft

00:02:35,470 --> 00:02:41,740
came up and four years later they

00:02:39,130 --> 00:02:44,080
released the first version what's

00:02:41,740 --> 00:02:46,480
actually pretty funny is that just one

00:02:44,080 --> 00:02:48,160
year after the release of the first

00:02:46,480 --> 00:02:50,260
version they figured that it was not

00:02:48,160 --> 00:02:53,050
that good and they released a patch so

00:02:50,260 --> 00:02:57,910
since then we have HP 11 which is what

00:02:53,050 --> 00:03:01,600
most of you still use today then in 1998

00:02:57,910 --> 00:03:05,940
there was RFC where you have 23 26 who

00:03:01,600 --> 00:03:09,930
knows what this RC is about ends up one

00:03:05,940 --> 00:03:12,430
awesome so this RFC specifies how

00:03:09,930 --> 00:03:14,560
machines interconnected network should

00:03:12,430 --> 00:03:18,100
react on request on making coffee and

00:03:14,560 --> 00:03:20,380
this is where the HPT status for 118

00:03:18,100 --> 00:03:22,180
comes from I'm a teapot so its

00:03:20,380 --> 00:03:23,350
neighborhoods full RC check it out it's

00:03:22,180 --> 00:03:27,040
pretty it's pretty funny to read it's a

00:03:23,350 --> 00:03:30,610
good read so going on in history we have

00:03:27,040 --> 00:03:32,410
another version of a TV 11 because they

00:03:30,610 --> 00:03:36,730
figured the first version was also but

00:03:32,410 --> 00:03:38,500
has a few flaws but it's basically not

00:03:36,730 --> 00:03:41,830
that much semantics change so it was

00:03:38,500 --> 00:03:44,800
more like a like writing changes in this

00:03:41,830 --> 00:03:46,480
draft and then there was a lot of stuff

00:03:44,800 --> 00:03:48,010
happening lots of like improvement in

00:03:46,480 --> 00:03:50,890
different RFC's I haven't listed here

00:03:48,010 --> 00:03:52,959
and then in 2007 the ift forms the HTV

00:03:50,890 --> 00:03:55,930
boost working group and as far as Google

00:03:52,959 --> 00:04:00,610
told me business latin for to and this

00:03:55,930 --> 00:04:03,970
group's task was to to get some some

00:04:00,610 --> 00:04:05,920
like structure in the 11 draft and in

00:04:03,970 --> 00:04:07,930
early 2012 there was a call for

00:04:05,920 --> 00:04:11,020
proposals fetch v2 and Google jumped in

00:04:07,930 --> 00:04:13,870
here and proposed speedy as less as a

00:04:11,020 --> 00:04:15,459
base as a base draft to use and to work

00:04:13,870 --> 00:04:17,650
on this is how speedy and age which will

00:04:15,459 --> 00:04:19,959
relate to each other so speedy is the

00:04:17,650 --> 00:04:26,860
base where the iterated over and created

00:04:19,959 --> 00:04:30,340
HP to so when we go on in 2014 so two

00:04:26,860 --> 00:04:32,200
years ago now that was hp11 split this

00:04:30,340 --> 00:04:33,850
was the result of the a tubeless working

00:04:32,200 --> 00:04:36,010
group and they split it all the

00:04:33,850 --> 00:04:36,790
different RFC's which have been out

00:04:36,010 --> 00:04:40,090
there in

00:04:36,790 --> 00:04:41,980
just six different ones each dealing was

00:04:40,090 --> 00:04:44,890
a different sub part of the protocol so

00:04:41,980 --> 00:04:49,510
all information on HP 11 you can find in

00:04:44,890 --> 00:04:52,090
this RFC's then in may 2015 issue 2 was

00:04:49,510 --> 00:04:54,070
finally released and at the end of the

00:04:52,090 --> 00:04:57,220
last year twenty two percent of all web

00:04:54,070 --> 00:05:00,640
traffic was already hb2 due to the fact

00:04:57,220 --> 00:05:03,160
that s i mentioned only ssl traffic is

00:05:00,640 --> 00:05:05,170
supported 4g with you it makes sense to

00:05:03,160 --> 00:05:08,650
look at this number as well and on

00:05:05,170 --> 00:05:11,080
Firefox 35 percent of all HTTPS traffic

00:05:08,650 --> 00:05:14,980
was already a tree to I think this is

00:05:11,080 --> 00:05:17,980
pretty amazing so far so in order to

00:05:14,980 --> 00:05:19,840
them start at the Edit like at the same

00:05:17,980 --> 00:05:22,320
plate at the same point I really want to

00:05:19,840 --> 00:05:26,320
talk really quick about the HTTP basics

00:05:22,320 --> 00:05:29,170
so first one HP one is plain text so I

00:05:26,320 --> 00:05:31,660
can just spin up my terminal and then

00:05:29,170 --> 00:05:34,420
opening up a TCP connection to google

00:05:31,660 --> 00:05:37,570
that common port 80 and then just write

00:05:34,420 --> 00:05:39,400
the characters for the status line at

00:05:37,570 --> 00:05:41,920
the host header and Google will reply

00:05:39,400 --> 00:05:46,420
with an actual response so you can just

00:05:41,920 --> 00:05:49,960
do this stuff with HP 1hp was a issue

00:05:46,420 --> 00:05:51,490
one is stateless and to us as well and

00:05:49,960 --> 00:05:53,020
it's super flexible and it's used

00:05:51,490 --> 00:05:54,490
everything right it was invented for a

00:05:53,020 --> 00:05:57,490
completely different thing it was

00:05:54,490 --> 00:05:59,440
invented to share documents tim burton's

00:05:57,490 --> 00:06:01,840
the idea was even that browsers could be

00:05:59,440 --> 00:06:07,420
like editors this idea is completely

00:06:01,840 --> 00:06:08,800
gone now almost but a tree has changed a

00:06:07,420 --> 00:06:09,820
lot since then right we use it for all

00:06:08,800 --> 00:06:12,760
different kinds of stuff we use it for

00:06:09,820 --> 00:06:14,860
streaming we use it for database

00:06:12,760 --> 00:06:17,170
connections we use it for lots of

00:06:14,860 --> 00:06:22,270
different things but it was not designed

00:06:17,170 --> 00:06:26,110
with this gnosis task in mind so hv1 has

00:06:22,270 --> 00:06:28,360
a bunch of problems the web matric and

00:06:26,110 --> 00:06:31,540
if we take a look in the last four years

00:06:28,360 --> 00:06:33,940
the size of requests and the number of

00:06:31,540 --> 00:06:36,700
requests almost doubled and if we take a

00:06:33,940 --> 00:06:40,390
look at average website every connection

00:06:36,700 --> 00:06:42,670
has 38 every page load has 38 different

00:06:40,390 --> 00:06:46,120
connections TCP connections just to load

00:06:42,670 --> 00:06:48,310
one page and when we know talking about

00:06:46,120 --> 00:06:49,040
the mobile web the latency is pretty

00:06:48,310 --> 00:06:52,460
high

00:06:49,040 --> 00:06:55,460
and this leads to a problem often

00:06:52,460 --> 00:06:58,040
referred as request melantha and what I

00:06:55,460 --> 00:07:00,110
mean with that is a issue you see every

00:06:58,040 --> 00:07:01,970
day so what you see here is you have the

00:07:00,110 --> 00:07:04,820
browser and server and the browser is

00:07:01,970 --> 00:07:06,830
requesting some sign of asset so in this

00:07:04,820 --> 00:07:08,930
case it's requesting the next HTML the

00:07:06,830 --> 00:07:11,120
server response and the browser pauses

00:07:08,930 --> 00:07:12,740
it and find some more assets so then the

00:07:11,120 --> 00:07:15,440
browser's asking again for some more

00:07:12,740 --> 00:07:17,330
assets in this case for CSS file and

00:07:15,440 --> 00:07:20,180
then the server response the browser

00:07:17,330 --> 00:07:22,130
path of it and then it might find an

00:07:20,180 --> 00:07:23,540
image or in our case which is like a

00:07:22,130 --> 00:07:25,220
little bit unrealistic it finds

00:07:23,540 --> 00:07:27,590
JavaScript acid and then it's going to

00:07:25,220 --> 00:07:29,390
request this one as well so this is a

00:07:27,590 --> 00:07:32,600
lot of round trips right we have to do

00:07:29,390 --> 00:07:34,310
and this adds a lot of latency right

00:07:32,600 --> 00:07:38,180
especially if we are now talking about

00:07:34,310 --> 00:07:39,740
the mobile web throughput is pretty good

00:07:38,180 --> 00:07:41,150
when we talk about LTE or 4G the

00:07:39,740 --> 00:07:43,490
throughput is pretty good but the

00:07:41,150 --> 00:07:46,070
latency is still not that good and it's

00:07:43,490 --> 00:07:47,660
like chili and I want to illustrate that

00:07:46,070 --> 00:07:50,840
so I got a little bit a little video

00:07:47,660 --> 00:07:52,100
here so i wanted to load the verge this

00:07:50,840 --> 00:07:53,840
video is a bit older it might not be

00:07:52,100 --> 00:07:56,510
that accurate anymore it's like half a

00:07:53,840 --> 00:07:57,860
year but if you want to just load the

00:07:56,510 --> 00:08:01,730
website and take a look at the network

00:07:57,860 --> 00:08:04,580
tab let's do this together so we loaded

00:08:01,730 --> 00:08:06,980
you see the initial request and what you

00:08:04,580 --> 00:08:08,660
now see is like this huge waterfall

00:08:06,980 --> 00:08:10,850
while I'm here on there on the right

00:08:08,660 --> 00:08:13,220
side right there's lots of stuff lots of

00:08:10,850 --> 00:08:16,880
assets loaded every essay triggers more

00:08:13,220 --> 00:08:18,740
assets and it takes a long time this is

00:08:16,880 --> 00:08:22,840
real time by the way so it's like 10

00:08:18,740 --> 00:08:22,840
minutes to load we're at 10 seconds

00:08:23,120 --> 00:08:29,150
echo moderate know it's a 12 seconds and

00:08:26,220 --> 00:08:32,070
it's 1.5 megabyte to load the verge

00:08:29,150 --> 00:08:34,409
that's like ten percent of my daily

00:08:32,070 --> 00:08:37,440
mobile plan l my monthly mobile plan

00:08:34,409 --> 00:08:39,479
that's crazy I got it the same video but

00:08:37,440 --> 00:08:41,130
a little bit slower so there's not real

00:08:39,479 --> 00:08:43,650
time anymore and we can take a look on

00:08:41,130 --> 00:08:45,750
what's going on there so we see the

00:08:43,650 --> 00:08:48,030
initial request the document here then

00:08:45,750 --> 00:08:50,010
we see in parallel triggered some more

00:08:48,030 --> 00:08:52,080
requests going on then here's a lot of

00:08:50,010 --> 00:08:53,700
like pause so I assume there's a lot of

00:08:52,080 --> 00:08:57,000
pausing going on from the essence

00:08:53,700 --> 00:08:59,160
livered here and all this stuff you can

00:08:57,000 --> 00:09:01,110
read but it's all tracking and bad stuff

00:08:59,160 --> 00:09:03,480
so I don't have a blocker for this

00:09:01,110 --> 00:09:07,650
example right so it's the page was

00:09:03,480 --> 00:09:09,740
loaded from you expected but it was not

00:09:07,650 --> 00:09:12,120
a complete page load and even my browser

00:09:09,740 --> 00:09:16,560
loading any kata was still spinning at

00:09:12,120 --> 00:09:19,080
this time so I got a little bit angry on

00:09:16,560 --> 00:09:22,340
that so I treated them they didn't reply

00:09:19,080 --> 00:09:25,530
at all I don't know if they even fix it

00:09:22,340 --> 00:09:27,600
now your first response might um yeah

00:09:25,530 --> 00:09:29,280
you can just fix this with loading SS in

00:09:27,600 --> 00:09:31,320
parallel and this is true but this

00:09:29,280 --> 00:09:33,240
suffers one problem and this is head of

00:09:31,320 --> 00:09:35,730
line blocking what is head of line

00:09:33,240 --> 00:09:37,680
blocking exactly well let's have a look

00:09:35,730 --> 00:09:39,990
at loading essence in parallel you would

00:09:37,680 --> 00:09:42,240
just request them in parallel but the

00:09:39,990 --> 00:09:44,070
index lost so the initial document might

00:09:42,240 --> 00:09:45,930
take the longest time right because it's

00:09:44,070 --> 00:09:47,790
like done dynamically rendered and the

00:09:45,930 --> 00:09:49,740
other ones just static assets but due to

00:09:47,790 --> 00:09:51,930
the fact that we requested this in this

00:09:49,740 --> 00:09:54,450
order the server we are forcing the

00:09:51,930 --> 00:09:56,190
server to reply in the same to reply in

00:09:54,450 --> 00:09:58,800
the same order if we are sharing one tcp

00:09:56,190 --> 00:10:02,220
connection because HTTP has no way of

00:09:58,800 --> 00:10:04,589
identifying resources in the response so

00:10:02,220 --> 00:10:07,560
the only way to identify that this acid

00:10:04,589 --> 00:10:10,800
is this requested acid is to keep the

00:10:07,560 --> 00:10:15,150
order so you had the head blocks right

00:10:10,800 --> 00:10:16,650
this is head of line blocking and it's a

00:10:15,150 --> 00:10:22,470
little bit recap on this so the head of

00:10:16,650 --> 00:10:25,440
line blocking is the other matters the

00:10:22,470 --> 00:10:27,060
slowest request blocks there are almost

00:10:25,440 --> 00:10:30,630
no workarounds for this because it's an

00:10:27,060 --> 00:10:32,490
issue of the protocol right and due to

00:10:30,630 --> 00:10:35,430
that fact that's often unused so a lot

00:10:32,490 --> 00:10:36,130
of browsers just turn this off as

00:10:35,430 --> 00:10:39,220
developers

00:10:36,130 --> 00:10:41,740
David Wright to changes and I think this

00:10:39,220 --> 00:10:45,040
was like the best option we had at this

00:10:41,740 --> 00:10:46,840
point but that could have been like if

00:10:45,040 --> 00:10:48,640
we would just invest more efforts we

00:10:46,840 --> 00:10:50,140
could have jumped into the protocol

00:10:48,640 --> 00:10:52,120
specs and try to work on this on this

00:10:50,140 --> 00:10:54,100
side but we did the other way we

00:10:52,120 --> 00:10:57,100
improved our tooling so we came up with

00:10:54,100 --> 00:10:59,740
ideas like spriting concatenating domain

00:10:57,100 --> 00:11:03,100
sharding my slides are slow domain

00:10:59,740 --> 00:11:04,900
charting the weirdest inlining hacks or

00:11:03,100 --> 00:11:07,360
preloading hacks I've seen so many

00:11:04,900 --> 00:11:08,860
applications they have the application

00:11:07,360 --> 00:11:10,660
JavaScript on the landing page just

00:11:08,860 --> 00:11:13,420
though the application could look pretty

00:11:10,660 --> 00:11:16,600
fast this violates almost all rules on

00:11:13,420 --> 00:11:18,850
software design I know right this is a

00:11:16,600 --> 00:11:22,060
really bad idea we did cookie free

00:11:18,850 --> 00:11:24,880
domains this is great keep this oh this

00:11:22,060 --> 00:11:27,100
is even a great idea on HP to on we so

00:11:24,880 --> 00:11:28,900
really try to save all the requests so

00:11:27,100 --> 00:11:32,260
we optimized again for the throughput

00:11:28,900 --> 00:11:33,700
but not for the round trip time but I'm

00:11:32,260 --> 00:11:35,980
not here to talk about the problems we

00:11:33,700 --> 00:11:37,660
have I'm rather here to talk about hd2

00:11:35,980 --> 00:11:40,210
and the solutions we have to this

00:11:37,660 --> 00:11:42,610
problem mention first of all HP two is

00:11:40,210 --> 00:11:44,980
compatible so it's not going to break

00:11:42,610 --> 00:11:47,170
the web the scheme will stay so you'll

00:11:44,980 --> 00:11:50,410
never see an hd2 in your browser bar it

00:11:47,170 --> 00:11:52,000
will stay hph vs the semantic stay like

00:11:50,410 --> 00:11:55,540
headers message request response cycle

00:11:52,000 --> 00:11:58,110
all this day have a look at the upgrade

00:11:55,540 --> 00:12:00,250
right how does operate works first the

00:11:58,110 --> 00:12:02,040
non-secure way this is just a

00:12:00,250 --> 00:12:04,600
theoretical one using the upgrade header

00:12:02,040 --> 00:12:06,900
due to time constraints and try to go

00:12:04,600 --> 00:12:10,000
with this pretty fast so we'll just send

00:12:06,900 --> 00:12:12,190
the upgrade header HTC see as plain text

00:12:10,000 --> 00:12:14,410
or clear text then we sent the settings

00:12:12,190 --> 00:12:18,190
along of the server will reply with an H

00:12:14,410 --> 00:12:20,740
to view 11 101 switching protocols and

00:12:18,190 --> 00:12:23,920
then upgrade to the protocol and then it

00:12:20,740 --> 00:12:25,510
will just start running a binary so

00:12:23,920 --> 00:12:26,980
let's take a look and how it how it

00:12:25,510 --> 00:12:29,190
would work on a secured connection so

00:12:26,980 --> 00:12:31,750
this is how it would work on all your

00:12:29,190 --> 00:12:35,230
laptops I see around here it's actually

00:12:31,750 --> 00:12:37,270
using an extension for TLS so it's TLS a

00:12:35,230 --> 00:12:39,520
OPN lpns application layer protocol

00:12:37,270 --> 00:12:41,140
negotiation which is just newer version

00:12:39,520 --> 00:12:42,400
of NPN which is the next protocol

00:12:41,140 --> 00:12:45,070
negotiation which was the protocol

00:12:42,400 --> 00:12:48,520
invented by Google for speedy anyway

00:12:45,070 --> 00:12:50,380
it's an extension CLS and it's using

00:12:48,520 --> 00:12:53,350
this part of the TLS protocol

00:12:50,380 --> 00:12:55,030
where they exchange protocols both sides

00:12:53,350 --> 00:12:58,510
support and they can just negotiate

00:12:55,030 --> 00:13:02,170
which one to use and the protocol

00:12:58,510 --> 00:13:04,660
shorthand h2 is the short version for hv

00:13:02,170 --> 00:13:08,520
two on a secured connection the funny

00:13:04,660 --> 00:13:12,070
side funny side note is that HTC is

00:13:08,520 --> 00:13:15,190
actually registered in the name space of

00:13:12,070 --> 00:13:18,090
for a LPN but due to the fact that is

00:13:15,190 --> 00:13:22,780
clear text it's not even used in the APN

00:13:18,090 --> 00:13:25,030
so this led to a few problems ok so a 22

00:13:22,780 --> 00:13:27,040
is multiplexed what does this means so

00:13:25,030 --> 00:13:29,590
we have one more or less physical TCP

00:13:27,040 --> 00:13:32,590
connection which has logical streams on

00:13:29,590 --> 00:13:34,960
it and on this their RTC like the data

00:13:32,590 --> 00:13:36,520
frames and each frame belongs to a

00:13:34,960 --> 00:13:38,590
stream so this model makes the most

00:13:36,520 --> 00:13:40,810
sense even though on a more technical

00:13:38,590 --> 00:13:44,110
term it's frames directly on one

00:13:40,810 --> 00:13:47,200
connection so these frames are binary

00:13:44,110 --> 00:13:50,170
and they follow a certain layout so they

00:13:47,200 --> 00:13:51,880
can be passed by service more easily so

00:13:50,170 --> 00:13:54,190
they have a length they have type flags

00:13:51,880 --> 00:13:56,320
they have a type that have flags they

00:13:54,190 --> 00:13:59,560
have a 1-bit which always have to be set

00:13:56,320 --> 00:14:02,200
to 0 then the stream identifier of 31

00:13:59,560 --> 00:14:04,210
beds and then their sexual payload I was

00:14:02,200 --> 00:14:06,430
wondering what this little bit means

00:14:04,210 --> 00:14:08,080
because the specs is this one has to be

00:14:06,430 --> 00:14:12,250
there and it always has to be 0 ignoring

00:14:08,080 --> 00:14:14,470
like what it's actually for it's

00:14:12,250 --> 00:14:17,980
actually four platforms which do not

00:14:14,470 --> 00:14:23,080
support unsigned I'm 31 bit integers so

00:14:17,980 --> 00:14:24,820
they can just use 32-bit integers ok

00:14:23,080 --> 00:14:26,920
anyway so let's take a lot of different

00:14:24,820 --> 00:14:28,750
types of frames we have the first one in

00:14:26,920 --> 00:14:31,300
the one you will see most of the times

00:14:28,750 --> 00:14:33,850
the data frame it has a padding length

00:14:31,300 --> 00:14:35,530
padding a security feature and then

00:14:33,850 --> 00:14:38,380
there's the data and the padding their

00:14:35,530 --> 00:14:40,510
priority frames to reprioritize package

00:14:38,380 --> 00:14:42,100
on the fly that's reset screen which

00:14:40,510 --> 00:14:45,340
resets one stream of one connection

00:14:42,100 --> 00:14:47,290
their settings to transfer settings from

00:14:45,340 --> 00:14:49,080
the server to the client they're also

00:14:47,290 --> 00:14:51,450
bunch more I have a little example here

00:14:49,080 --> 00:14:54,430
but as I said we have to be really quick

00:14:51,450 --> 00:14:56,710
what you see here is the length of the

00:14:54,430 --> 00:15:00,550
body so the lengths always ignores the

00:14:56,710 --> 00:15:03,280
initial frame so we have the ping that's

00:15:00,550 --> 00:15:04,450
the type of the of the package it has

00:15:03,280 --> 00:15:07,030
the flag

00:15:04,450 --> 00:15:09,310
set so this flag on the pink frame means

00:15:07,030 --> 00:15:11,050
that the server has to send back or the

00:15:09,310 --> 00:15:13,090
other side has to send back a punk frame

00:15:11,050 --> 00:15:15,130
hopefully without the flag because this

00:15:13,090 --> 00:15:17,770
would lead to like ping pong then we

00:15:15,130 --> 00:15:20,110
have this troll bit and we have this

00:15:17,770 --> 00:15:22,060
scream at you the cool thing is that i

00:15:20,110 --> 00:15:24,280
can say with this one that this frame is

00:15:22,060 --> 00:15:26,920
from client because client always have

00:15:24,280 --> 00:15:30,940
no this from the server because client

00:15:26,920 --> 00:15:32,500
always have odd numbers so each each

00:15:30,940 --> 00:15:34,870
server and clients maintain their own

00:15:32,500 --> 00:15:36,550
stream IDs and then there's some epic

00:15:34,870 --> 00:15:40,870
data which is like necessary by the

00:15:36,550 --> 00:15:43,660
protocol let's talk about the HP two

00:15:40,870 --> 00:15:46,810
features first one I want to talk about

00:15:43,660 --> 00:15:48,520
a server push and I think this is going

00:15:46,810 --> 00:15:50,950
to be the the biggest change and the

00:15:48,520 --> 00:15:54,160
change with the biggest impact but on

00:15:50,950 --> 00:15:57,250
the same hand it's also the change we

00:15:54,160 --> 00:15:58,690
haven't made use of yet and we really

00:15:57,250 --> 00:16:00,970
should because this is going to improve

00:15:58,690 --> 00:16:04,630
our applications as I mentioned by pitch

00:16:00,970 --> 00:16:07,020
right so what is server push so ever

00:16:04,630 --> 00:16:10,210
push is initiated by push frame and

00:16:07,020 --> 00:16:12,190
seven push actually comes in place where

00:16:10,210 --> 00:16:13,930
a visitor who has never seen your web

00:16:12,190 --> 00:16:15,550
app it's going to see your app for the

00:16:13,930 --> 00:16:18,970
very first time so it has a complete

00:16:15,550 --> 00:16:21,490
empty cache and requesting a sign our

00:16:18,970 --> 00:16:23,410
document like in the next HTML and now

00:16:21,490 --> 00:16:26,020
imagine your server could tell the

00:16:23,410 --> 00:16:30,010
client without further requests the

00:16:26,020 --> 00:16:32,410
essence it will need so the server the

00:16:30,010 --> 00:16:34,810
client asks for an XHTML and your server

00:16:32,410 --> 00:16:36,880
could respond like oh I know this page

00:16:34,810 --> 00:16:39,760
you will need the application CSS and

00:16:36,880 --> 00:16:41,500
the application JavaScript as well so

00:16:39,760 --> 00:16:44,590
the push promise frame is basically I

00:16:41,500 --> 00:16:46,140
can add a frame but is it's a head of

00:16:44,590 --> 00:16:49,630
frame what's the transportation

00:16:46,140 --> 00:16:51,970
mechanism without an request and this is

00:16:49,630 --> 00:16:56,620
one of the biggest change from even in

00:16:51,970 --> 00:17:00,730
semantics right from HP 12 hp to it also

00:16:56,620 --> 00:17:04,089
supports flow control so all assets all

00:17:00,730 --> 00:17:06,070
requests all connections or all streams

00:17:04,089 --> 00:17:09,579
on one connection are sharing one actual

00:17:06,070 --> 00:17:12,270
TCP connection and in order to transfer

00:17:09,579 --> 00:17:15,520
some assets faster than others every

00:17:12,270 --> 00:17:16,660
stream has dependency and they use

00:17:15,520 --> 00:17:17,829
weighted dependency in order to

00:17:16,660 --> 00:17:21,010
determine which stream

00:17:17,829 --> 00:17:22,929
should be transferred first so let's

00:17:21,010 --> 00:17:25,089
look at how they implemented it the use

00:17:22,929 --> 00:17:29,140
a technique called priority three so

00:17:25,089 --> 00:17:32,289
here we have the stream id0 stream 83

00:17:29,140 --> 00:17:36,549
and three depends on 0 then we have the

00:17:32,289 --> 00:17:38,950
stream 85 they both know the three has a

00:17:36,549 --> 00:17:42,909
weight of 128 and five hundredweight of

00:17:38,950 --> 00:17:46,809
64 and then there's some wall streams in

00:17:42,909 --> 00:17:49,750
here and this is a the complete picture

00:17:46,809 --> 00:17:55,480
for the like for the priority three and

00:17:49,750 --> 00:17:57,820
now take a look that 16 down here is the

00:17:55,480 --> 00:18:00,789
default weight of every stream so if you

00:17:57,820 --> 00:18:02,889
don't specify it it's always 16 and the

00:18:00,789 --> 00:18:05,230
priority of the stream is determined by

00:18:02,889 --> 00:18:07,630
the relative proportion of weights so

00:18:05,230 --> 00:18:10,179
stream 83 should receive two thirds of

00:18:07,630 --> 00:18:11,740
the available resources and stream it is

00:18:10,179 --> 00:18:14,440
seven should receive half of the

00:18:11,740 --> 00:18:18,250
resources of three minute three if this

00:18:14,440 --> 00:18:20,409
makes sense this is very theoretical but

00:18:18,250 --> 00:18:22,600
what really blew my mind when I was like

00:18:20,409 --> 00:18:23,769
researching into it taking a look and

00:18:22,600 --> 00:18:25,659
how it's actually implementing it and

00:18:23,769 --> 00:18:29,380
firefox at the moment has the most

00:18:25,659 --> 00:18:32,620
efficient implementation so let's take a

00:18:29,380 --> 00:18:34,750
look on how they do it so first off this

00:18:32,620 --> 00:18:36,750
initial stream is simply 0 and the first

00:18:34,750 --> 00:18:39,610
thing they do without transferring

00:18:36,750 --> 00:18:43,330
anything on the data they set up the

00:18:39,610 --> 00:18:47,409
dependency tree then they transfer the

00:18:43,330 --> 00:18:52,809
HTML in this remedy 13 then they order

00:18:47,409 --> 00:18:56,320
the CSS on this page that's the CSS from

00:18:52,809 --> 00:18:58,840
the head out in the Hat and then there's

00:18:56,320 --> 00:19:00,789
the javis group in the Hat then we have

00:18:58,840 --> 00:19:02,110
some images they go on a different sub

00:19:00,789 --> 00:19:05,679
tree with a different priority and

00:19:02,110 --> 00:19:08,049
different waited and then there might

00:19:05,679 --> 00:19:11,950
also be some JavaScript at the bottom of

00:19:08,049 --> 00:19:13,649
the page which um goes below here i can

00:19:11,950 --> 00:19:17,080
tell you why they made the decisions

00:19:13,649 --> 00:19:19,000
even if it love if i could do but I

00:19:17,080 --> 00:19:20,919
didn't have the I didn't had the chance

00:19:19,000 --> 00:19:24,370
to talk to any of them or didn't like

00:19:20,919 --> 00:19:26,049
make myself enough time to do that but I

00:19:24,370 --> 00:19:27,880
know that they do it this way and that's

00:19:26,049 --> 00:19:29,180
the most efficient one it's the most

00:19:27,880 --> 00:19:31,280
efficient one we

00:19:29,180 --> 00:19:32,750
Google still uses the dependency tree

00:19:31,280 --> 00:19:34,340
that invented for speedy which was a bit

00:19:32,750 --> 00:19:36,980
different and they didn't change it yet

00:19:34,340 --> 00:19:38,540
and what I found pretty interesting is

00:19:36,980 --> 00:19:41,000
that the in the next door don't make use

00:19:38,540 --> 00:19:43,700
of this at all so they support it but

00:19:41,000 --> 00:19:48,200
it's like flat thing so it's not a tree

00:19:43,700 --> 00:19:51,800
everything depends on stream of the 0 so

00:19:48,200 --> 00:19:55,210
hd2 is also compressed headers which

00:19:51,800 --> 00:19:57,380
will reduce the size of every request

00:19:55,210 --> 00:19:59,360
this is how a header looks like so it

00:19:57,380 --> 00:20:02,240
has the padding again that has this

00:19:59,360 --> 00:20:04,130
interesting 0 bit the stream IDE I'm a

00:20:02,240 --> 00:20:05,600
weight and the header block fragment the

00:20:04,130 --> 00:20:08,780
header block fragment is specified in a

00:20:05,600 --> 00:20:11,510
different RFC its specified in RFC 75 41

00:20:08,780 --> 00:20:13,040
and I really want to go pretty quick

00:20:11,510 --> 00:20:14,780
into that because I found this one

00:20:13,040 --> 00:20:17,210
pretty interesting and how they do it

00:20:14,780 --> 00:20:19,040
they use a static they use a header

00:20:17,210 --> 00:20:23,090
compression table for this it consists

00:20:19,040 --> 00:20:24,800
of static and dynamic table and this is

00:20:23,090 --> 00:20:28,070
how the compress or encoded headers

00:20:24,800 --> 00:20:31,220
looks like so here you see the master

00:20:28,070 --> 00:20:32,900
for example is referenced as ID too so

00:20:31,220 --> 00:20:37,010
whenever you have this method header

00:20:32,900 --> 00:20:38,930
it's always this ID too and you will

00:20:37,010 --> 00:20:43,010
just find this too in the encoded

00:20:38,930 --> 00:20:45,740
headers and for value is not known it's

00:20:43,010 --> 00:20:47,570
using Huffman encoding and what I also

00:20:45,740 --> 00:20:51,350
think is pretty interesting on this is

00:20:47,570 --> 00:20:55,730
that here the statelessness is a little

00:20:51,350 --> 00:20:59,000
bit it's a little bit violated because

00:20:55,730 --> 00:21:03,350
header compression is stateful so the

00:20:59,000 --> 00:21:05,090
state belongs to one connection and the

00:21:03,350 --> 00:21:07,760
dynamic table builds up her connection

00:21:05,090 --> 00:21:10,340
so for example the user agent probably

00:21:07,760 --> 00:21:13,040
won't change on one single TCP connector

00:21:10,340 --> 00:21:14,540
right so this one is a header which will

00:21:13,040 --> 00:21:17,600
end up with the dynamic here pretty fast

00:21:14,540 --> 00:21:20,840
and it's up to the compressor of the

00:21:17,600 --> 00:21:23,120
header which headers go into their go

00:21:20,840 --> 00:21:25,460
into this dynamic table I actually

00:21:23,120 --> 00:21:26,990
implemented this list HP algorithm

00:21:25,460 --> 00:21:29,090
myself so if you want to like know more

00:21:26,990 --> 00:21:31,670
details about this ask me later about

00:21:29,090 --> 00:21:33,260
this I think it's pretty interesting and

00:21:31,670 --> 00:21:36,410
it's pretty efficient for HTV two

00:21:33,260 --> 00:21:37,910
headers let's take a really deep joke

00:21:36,410 --> 00:21:39,740
until half an encoding I want to do it

00:21:37,910 --> 00:21:41,690
in one minute let's see who she knows it

00:21:39,740 --> 00:21:42,530
already happen encoding well that's half

00:21:41,690 --> 00:21:45,170
the audience it's

00:21:42,530 --> 00:21:47,000
aight i didn't do it might be for myself

00:21:45,170 --> 00:21:49,250
when i found an awesome youtube video

00:21:47,000 --> 00:21:51,020
expanding in like seven minutes so i try

00:21:49,250 --> 00:21:52,940
to break this down into one minute let's

00:21:51,020 --> 00:21:54,620
see if this if this works so we have

00:21:52,940 --> 00:21:57,170
this drink mississippi river and these

00:21:54,620 --> 00:22:00,700
are 17 characters each character's 8-bit

00:21:57,170 --> 00:22:04,010
so we have an initial string length of

00:22:00,700 --> 00:22:05,600
136 bits first thing we do we just count

00:22:04,010 --> 00:22:07,730
the characters or the occurrences of the

00:22:05,600 --> 00:22:10,880
character then we order them by

00:22:07,730 --> 00:22:12,710
occurrence so I 5s for p 2 and so on and

00:22:10,880 --> 00:22:14,600
then we start building up a tree we

00:22:12,710 --> 00:22:17,420
always take the lowest numbers and

00:22:14,600 --> 00:22:19,880
concatenate the characters and some of

00:22:17,420 --> 00:22:24,650
the numbers so we do this for the whole

00:22:19,880 --> 00:22:26,360
tree always using the lowest and with

00:22:24,650 --> 00:22:30,940
this technique we're building up this

00:22:26,360 --> 00:22:33,500
tree right and next step we do is we

00:22:30,940 --> 00:22:35,480
enumerate the branches so the left

00:22:33,500 --> 00:22:38,390
branch is always 0 where the right

00:22:35,480 --> 00:22:41,660
branch is always one and next step is

00:22:38,390 --> 00:22:45,410
you walk down every possible branch and

00:22:41,660 --> 00:22:46,550
you end up with this table and this is

00:22:45,410 --> 00:22:49,880
actually the compression table you can

00:22:46,550 --> 00:22:53,180
use it follows the idea that characters

00:22:49,880 --> 00:22:55,640
which occur often take less space in the

00:22:53,180 --> 00:22:58,420
compressed string so the eye which

00:22:55,640 --> 00:23:05,120
occurs five times only takes up two bits

00:22:58,420 --> 00:23:10,220
right while the space or the v while the

00:23:05,120 --> 00:23:11,630
space only takes four bits yeah this is

00:23:10,220 --> 00:23:14,210
the compression table and with a

00:23:11,630 --> 00:23:17,540
compression table the result will be 46

00:23:14,210 --> 00:23:20,330
bits plus the table so on this string we

00:23:17,540 --> 00:23:22,340
have all around seventy percent we

00:23:20,330 --> 00:23:26,420
compressed which is I think pretty great

00:23:22,340 --> 00:23:29,120
and in hv to the header the header table

00:23:26,420 --> 00:23:31,250
of the Halfmoon encoding table is part

00:23:29,120 --> 00:23:32,480
of the protocol so it's not not

00:23:31,250 --> 00:23:35,120
something which has to be transferred

00:23:32,480 --> 00:23:38,260
all the time it's just you just have to

00:23:35,120 --> 00:23:40,520
copy it and when you're implementing it

00:23:38,260 --> 00:23:43,460
okay now I want to talk about and I'm

00:23:40,520 --> 00:23:45,170
tuned in the real world and important

00:23:43,460 --> 00:23:46,730
for me is that it's already here and if

00:23:45,170 --> 00:23:49,370
I have if I would have more time we'll

00:23:46,730 --> 00:23:51,530
do a demo here but I don't so let's take

00:23:49,370 --> 00:23:53,750
a look at the implementations and we are

00:23:51,530 --> 00:23:56,330
at jas I'm conf so let's take a look at

00:23:53,750 --> 00:23:58,820
the browsers and what do we do

00:23:56,330 --> 00:24:01,250
need to know if you can use the future

00:23:58,820 --> 00:24:03,740
not you going to can i use and this is

00:24:01,250 --> 00:24:07,250
the actual usage chart it's two weeks

00:24:03,740 --> 00:24:09,320
old um let's for activity two and you

00:24:07,250 --> 00:24:10,820
see it's almost all green and the

00:24:09,320 --> 00:24:16,490
current versions right I mean this is

00:24:10,820 --> 00:24:19,220
opera mini and Android stock and can I

00:24:16,490 --> 00:24:21,950
use also has a different view on this

00:24:19,220 --> 00:24:24,679
chart but i think is more useful they

00:24:21,950 --> 00:24:29,630
also display the usage of the extra

00:24:24,679 --> 00:24:31,370
browser versions so we have this and so

00:24:29,630 --> 00:24:33,320
this is iOS they were the last ones

00:24:31,370 --> 00:24:36,380
adapting but due to the great adoption

00:24:33,320 --> 00:24:40,279
rate of iOS devices with the recent iOS

00:24:36,380 --> 00:24:45,250
version 9 to it they had they shipped

00:24:40,279 --> 00:24:47,960
support and you see this one right and

00:24:45,250 --> 00:24:50,419
when i asked at the beginning who many

00:24:47,960 --> 00:24:53,960
of you how many of you are using HP to

00:24:50,419 --> 00:24:57,080
now there were like five hands and I

00:24:53,960 --> 00:25:00,380
want to know why are you optimizing for

00:24:57,080 --> 00:25:04,330
this your whole asset pipeline you hold

00:25:00,380 --> 00:25:09,080
asset concatenation ugly firing

00:25:04,330 --> 00:25:13,850
packaging in line hacking it's for

00:25:09,080 --> 00:25:17,299
this don't have this your bosses right

00:25:13,850 --> 00:25:18,889
the super inefficient but I will come

00:25:17,299 --> 00:25:21,889
back to this later first let's take a

00:25:18,889 --> 00:25:24,559
look at the server side in order to know

00:25:21,889 --> 00:25:26,389
how important one implementation is the

00:25:24,559 --> 00:25:29,360
market share might be interesting so

00:25:26,389 --> 00:25:30,950
here's the market share diagram what I

00:25:29,360 --> 00:25:33,289
found pretty interesting that the google

00:25:30,950 --> 00:25:35,929
web server is already two percent of the

00:25:33,289 --> 00:25:37,789
whole web traffic this is not something

00:25:35,929 --> 00:25:39,230
you can deploy on your own right it's

00:25:37,789 --> 00:25:41,870
not like apache you can install

00:25:39,230 --> 00:25:44,510
everywhere and they take up two percent

00:25:41,870 --> 00:25:46,100
of their server landscape for the google

00:25:44,510 --> 00:25:48,740
web server it's not known when they

00:25:46,100 --> 00:25:51,649
implemented it by they said that job

00:25:48,740 --> 00:25:55,370
speedy in February last year so probably

00:25:51,649 --> 00:25:57,710
they adopted since then Apache the said

00:25:55,370 --> 00:26:01,399
since July last year engine extent

00:25:57,710 --> 00:26:04,610
September and I is even does this as

00:26:01,399 --> 00:26:07,580
well so all major browsers supported at

00:26:04,610 --> 00:26:09,529
the moment and in order to enable it on

00:26:07,580 --> 00:26:10,740
your setup it's pretty easy let's take a

00:26:09,529 --> 00:26:14,290
look at the attached

00:26:10,740 --> 00:26:19,210
Apache one first you would need the heo

00:26:14,290 --> 00:26:21,310
to module and that's it yeah that's this

00:26:19,210 --> 00:26:24,640
is optional this is just the login part

00:26:21,310 --> 00:26:27,430
so it's a one-line change find genetics

00:26:24,640 --> 00:26:29,890
it's even better it's like a five

00:26:27,430 --> 00:26:31,720
character change so you'll have this

00:26:29,890 --> 00:26:34,390
line anyway right it's opening up its

00:26:31,720 --> 00:26:37,240
binding the port address so you just

00:26:34,390 --> 00:26:38,590
have to add this keyword here and have a

00:26:37,240 --> 00:26:41,380
recent version and then you're

00:26:38,590 --> 00:26:45,510
supporting it so don't tell me it's too

00:26:41,380 --> 00:26:51,370
complex to support it right it's not I

00:26:45,510 --> 00:26:55,450
think you're holding it wrong right you

00:26:51,370 --> 00:26:58,960
should stop concatenating you should

00:26:55,450 --> 00:27:01,420
stop spriting you should especially stop

00:26:58,960 --> 00:27:03,310
the main sharding and i really want you

00:27:01,420 --> 00:27:07,540
to trash your asset pipeline the one too

00:27:03,310 --> 00:27:09,850
far sorry um yeah you should really

00:27:07,540 --> 00:27:11,470
trash your asset pipeline remember the

00:27:09,850 --> 00:27:13,630
graph I showed you the browser

00:27:11,470 --> 00:27:15,460
supporting it and you are still like

00:27:13,630 --> 00:27:17,920
concatenating all your assets into one

00:27:15,460 --> 00:27:21,940
big chunk destroying all server caching

00:27:17,920 --> 00:27:23,710
mechanics right if you have 11 line

00:27:21,940 --> 00:27:25,870
change in your JavaScript and you have

00:27:23,710 --> 00:27:27,880
your one point five megabits application

00:27:25,870 --> 00:27:30,130
j has changed the browser's have to

00:27:27,880 --> 00:27:34,030
redownload it again even if it's in cash

00:27:30,130 --> 00:27:36,040
it's just 11 line changed and hd2 is you

00:27:34,030 --> 00:27:38,440
don't get a penalty for more resources

00:27:36,040 --> 00:27:40,840
so the more resources you have the

00:27:38,440 --> 00:27:42,220
better you cashing works right and you

00:27:40,840 --> 00:27:44,530
don't get you don't get even one

00:27:42,220 --> 00:27:48,640
millisecond of penalty for having more

00:27:44,530 --> 00:27:50,500
assets so just like split your

00:27:48,640 --> 00:27:53,190
javascript against with your CSS again

00:27:50,500 --> 00:27:57,550
and just make the whole development

00:27:53,190 --> 00:28:01,990
process easier again right so I want you

00:27:57,550 --> 00:28:04,750
to start using it the best right now not

00:28:01,990 --> 00:28:06,100
only upgrading because and you might

00:28:04,750 --> 00:28:07,840
have seen the blog post articles as well

00:28:06,100 --> 00:28:10,180
right if you just upgrade your

00:28:07,840 --> 00:28:12,190
performance may decrease and this is not

00:28:10,180 --> 00:28:14,260
the fault of the protocol and the

00:28:12,190 --> 00:28:16,360
company's operating often say that if

00:28:14,260 --> 00:28:18,550
this makes me so angry because they are

00:28:16,360 --> 00:28:21,970
holding it wrong as well if you still

00:28:18,550 --> 00:28:23,860
concatenate all your assets sure it will

00:28:21,970 --> 00:28:26,020
get slower or it

00:28:23,860 --> 00:28:28,900
should change like it shouldn't change

00:28:26,020 --> 00:28:30,220
but it it's it's not you're like really

00:28:28,900 --> 00:28:33,640
holding it wrong you're just doing it

00:28:30,220 --> 00:28:35,559
wrong and I want you to just start using

00:28:33,640 --> 00:28:38,980
it understand the protocol and optimized

00:28:35,559 --> 00:28:41,860
for this and this what's true on this is

00:28:38,980 --> 00:28:44,020
that customers using one one will see a

00:28:41,860 --> 00:28:46,000
performance decrease so they will get

00:28:44,020 --> 00:28:47,740
slow off of them but the others will get

00:28:46,000 --> 00:28:50,470
an increase which is way higher than the

00:28:47,740 --> 00:28:51,670
people using 11 and for JavaScript

00:28:50,470 --> 00:28:53,530
features you're doing it all the time

00:28:51,670 --> 00:28:55,870
right you want users to upgrade the

00:28:53,530 --> 00:28:57,460
browser so you can use I don't know es6

00:28:55,870 --> 00:29:00,640
modules which is this part in one

00:28:57,460 --> 00:29:05,950
browser and this one is a way more

00:29:00,640 --> 00:29:09,370
bigger impacting change and I see way

00:29:05,950 --> 00:29:10,870
too little talk about this and you

00:29:09,370 --> 00:29:14,860
should really make use of the features

00:29:10,870 --> 00:29:16,870
and not just upgrading I want to change

00:29:14,860 --> 00:29:18,610
my company I want to know I don't want

00:29:16,870 --> 00:29:24,160
to change it sorry i want it i want to

00:29:18,610 --> 00:29:27,070
thank it i want to thank my company

00:29:24,160 --> 00:29:30,340
because they gave me all the time to

00:29:27,070 --> 00:29:33,910
research on this yeah this one is gone

00:29:30,340 --> 00:29:36,850
now all this ok if you want to appear

00:29:33,910 --> 00:29:38,620
here like next year you can just stay in

00:29:36,850 --> 00:29:42,070
this room awesome colleagues of mine

00:29:38,620 --> 00:29:43,780
will follow here my name is Alicia Ellis

00:29:42,070 --> 00:29:45,549
we had talked about this you can follow

00:29:43,780 --> 00:29:47,200
me on twitter if you're into this thing

00:29:45,549 --> 00:29:49,110
you can just follow me on github if it's

00:29:47,200 --> 00:29:51,700
a prayer anything you do I don't do that

00:29:49,110 --> 00:29:54,730
you can just read my blog which is like

00:29:51,700 --> 00:29:57,030
currently super outdated or grab a

00:29:54,730 --> 00:29:59,049
sticker of the side projects I run and

00:29:57,030 --> 00:30:01,260
this is all I got thank you very much

00:29:59,049 --> 00:30:01,260
for your attention

00:30:02,850 --> 00:30:04,910

YouTube URL: https://www.youtube.com/watch?v=UBtU606qWOI


