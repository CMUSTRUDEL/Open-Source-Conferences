Title: Learning Functional Programming with JavaScript - Anjana Vakil - JSUnconf
Publication date: 2016-06-14
Playlist: JSUnconf 2016
Description: 
	Anjana's next talk at JSConf EU in May: http://2017.jsconf.eu/speakers/anjana-vakil-immutable-data-structures-for-functional-js.html

Slides: https://slidr.io/vakila/learning-functional-programming-with-javascript
Captions: 
	00:00:09,800 --> 00:00:12,200
[Applause]

00:00:12,200 --> 00:00:13,200
Hi!

00:00:13,800 --> 00:00:14,600
First of all,

00:00:14,600 --> 00:00:18,050
I just want to give a big shout-out to the organizers of this conference.

00:00:18,050 --> 00:00:22,480
I feel like this has been a fantastic smooth experience from start to finish,

00:00:22,480 --> 00:00:23,160
so...

00:00:23,160 --> 00:00:26,260
[Applause]

00:00:26,260 --> 00:00:27,500
Amazing job.

00:00:28,000 --> 00:00:30,320
Hi! I'm Anjana Vakil.

00:00:30,920 --> 00:00:35,400
I am an English teacher turned computational linguist

00:00:35,400 --> 00:00:37,100
turned software developer

00:00:37,350 --> 00:00:40,300
and as I mentioned a little bit earlier today,

00:00:41,000 --> 00:00:43,900
about six months ago, I knew nothing about functional programming

00:00:43,900 --> 00:00:45,900
and very little about JavaScript.

00:00:45,900 --> 00:00:48,250
So, what I want to do today is kind of

00:00:48,750 --> 00:00:51,250
take you guys along on some of the things I've learned

00:00:51,250 --> 00:00:54,600
about doing functional programming in JavaScript

00:00:54,850 --> 00:00:57,800
and I am not an expert in any of this,

00:00:57,800 --> 00:01:01,480
so this is going to be me taking you along on my learning journey

00:01:01,480 --> 00:01:03,000
and nothing more.

00:01:03,750 --> 00:01:07,100
I'm going to try and save a little time for questions at the end,

00:01:07,100 --> 00:01:09,100
but we'll see how that turns out.

00:01:09,100 --> 00:01:12,600
So, how did I end up standing here

00:01:12,600 --> 00:01:15,500
talking to you guys about functional programming in JavaScript?

00:01:15,650 --> 00:01:18,450
About six months ago in the fall of 2015,

00:01:18,450 --> 00:01:21,440
I went to a programming community in New York City

00:01:21,440 --> 00:01:23,000
called The Recurse Center

00:01:23,200 --> 00:01:24,400
which quick plug

00:01:24,400 --> 00:01:28,120
is probably the best programming community I've ever experienced

00:01:28,120 --> 00:01:29,820
and it's a programming retreat

00:01:29,820 --> 00:01:31,200
where you can go and learn about

00:01:31,200 --> 00:01:34,300
whatever is interesting to you in the world of computer science

00:01:34,950 --> 00:01:35,900
and so I got there

00:01:35,900 --> 00:01:38,100
and a lot of people were talking about functional programming,

00:01:38,100 --> 00:01:41,500
functional programming, Haskell, Clojure, all this cool stuff,

00:01:41,500 --> 00:01:44,160
a lot of people were working in JavaScript getting into node

00:01:44,300 --> 00:01:46,300
and these were some really interesting topics

00:01:46,300 --> 00:01:47,900
and so I started talking to people there

00:01:47,900 --> 00:01:50,200
and finding out what is all this stuff.

00:01:50,450 --> 00:01:53,080
So, what is functional programming?

00:01:53,480 --> 00:01:55,800
Few different ways that question can be answered.

00:01:56,200 --> 00:01:58,880
First of all, it's a programming paradigm.

00:01:59,580 --> 00:02:02,760
Some other paradigms are like imperative programming

00:02:02,760 --> 00:02:04,560
where you say do this and then do that

00:02:04,560 --> 00:02:06,350
or object-oriented programming

00:02:06,350 --> 00:02:09,450
which maybe a lot of you write object-oriented JavaScript

00:02:09,450 --> 00:02:12,480
where you have objects and they have methods on them

00:02:12,480 --> 00:02:14,780
and you change them, etc., etc.

00:02:15,100 --> 00:02:17,520
Functional programming is also a paradigm

00:02:17,520 --> 00:02:19,480
where functions are king

00:02:19,480 --> 00:02:21,480
and we'll talk about what that means in a little bit.

00:02:22,280 --> 00:02:24,580
It's also a style of coding,

00:02:24,580 --> 00:02:26,100
of organizing your code,

00:02:26,100 --> 00:02:27,500
writing your code,

00:02:28,350 --> 00:02:30,000
style of approaching projects

00:02:30,400 --> 00:02:34,000
and really more than that it's kind of a mindset you can get into,

00:02:34,000 --> 00:02:35,480
a way of thinking about a problem,

00:02:35,480 --> 00:02:37,480
a way of approaching a task

00:02:38,180 --> 00:02:40,320
and it's also a really sexy trend

00:02:40,320 --> 00:02:43,360
with lots of buzzwords that'll make you super popular

00:02:43,360 --> 00:02:47,400
when you're talking with people at the pre-conference party or whatever it is.

00:02:47,700 --> 00:02:48,400
No, just kidding.

00:02:48,400 --> 00:02:50,400
But it is something that's gotten a lot of attention

00:02:50,400 --> 00:02:53,000
and, so yeah, I thought it was important

00:02:53,000 --> 00:02:55,200
to find out why everybody was so excited about it.

00:02:56,500 --> 00:03:00,640
So, why do functional programming in JavaScript specifically?

00:03:00,940 --> 00:03:03,440
Well, I don't know about for all of you,

00:03:03,700 --> 00:03:06,000
perhaps more experienced JavaScript developers,

00:03:06,000 --> 00:03:08,000
but when I started learning JavaScript

00:03:08,000 --> 00:03:12,650
having had some object-oriented programming experience with Java, C-Sharp,

00:03:12,650 --> 00:03:13,560
that kind of thing,

00:03:13,860 --> 00:03:18,480
I found object-oriented JavaScript super confusing,

00:03:19,300 --> 00:03:22,400
prototypal inheritance, how does that work?

00:03:23,800 --> 00:03:25,700
How many of you guys, quick show of hands,

00:03:25,700 --> 00:03:29,600
have ever run into a bug or a problem or something unexpected with this,

00:03:29,900 --> 00:03:30,600
doing something...

00:03:30,600 --> 00:03:32,600
Yeah, exactly. Right?

00:03:32,750 --> 00:03:35,200
So, I found that really tricky and confusing

00:03:35,200 --> 00:03:37,950
and so I thought, all right, I know I want to get more into JavaScript

00:03:37,950 --> 00:03:39,950
but let me set aside the object orientation

00:03:39,950 --> 00:03:43,100
and try to think about things in a functional way

00:03:43,100 --> 00:03:45,450
which is maybe simpler in some ways

00:03:45,450 --> 00:03:47,250
and avoid some of these problems

00:03:47,550 --> 00:03:51,400
like bugs introduced by binding this to the wrong thing.

00:03:51,900 --> 00:03:55,760
So, functional JavaScript to me at least is a bit safer,

00:03:56,200 --> 00:03:57,160
a bit less tricky,

00:03:57,160 --> 00:03:58,600
a bit easier to debug

00:03:58,600 --> 00:04:01,500
but easier to maintain as you're building a project

00:04:02,100 --> 00:04:03,700
and we'll take a look at some of the features

00:04:03,700 --> 00:04:05,700
that make that easier in a bit.

00:04:06,900 --> 00:04:10,400
Also, there is already a huge community of developers

00:04:10,400 --> 00:04:12,700
who are doing JavaScript in a functional style,

00:04:12,700 --> 00:04:15,100
so there's a lot of libraries out there

00:04:15,100 --> 00:04:18,680
to help you write functional JavaScript.

00:04:18,780 --> 00:04:21,480
There's a lot of people out there that are experts in this,

00:04:21,480 --> 00:04:25,800
for example, there was a talk in the next room over earlier today on Ramda

00:04:26,000 --> 00:04:27,450
and there are people here you can talk to

00:04:27,450 --> 00:04:30,360
that probably know a lot more about functional JavaScript than I do,

00:04:30,460 --> 00:04:32,160
but the point is there's already a community,

00:04:32,160 --> 00:04:36,360
so this isn't necessarily something you'd be doing on your own,

00:04:36,360 --> 00:04:38,160
grappling you versus JavaScript,

00:04:38,160 --> 00:04:39,760
there's other people to support you,

00:04:39,760 --> 00:04:41,460
which I found really helpful.

00:04:43,100 --> 00:04:43,460
Okay.

00:04:43,460 --> 00:04:45,460
So, hopefully by now I've convinced you

00:04:45,460 --> 00:04:47,880
that functional programming is at least interesting

00:04:47,880 --> 00:04:51,360
and that we could do it in JavaScript to avoid these headaches, etc.

00:04:52,760 --> 00:04:54,360
How can we do it?

00:04:54,360 --> 00:04:55,660
What does it mean?

00:04:56,400 --> 00:04:57,860
This is what I was asking myself.

00:04:58,460 --> 00:04:59,460
So, the main thing

00:04:59,460 --> 00:05:02,960
and maybe it sounds like a tautology or obvious is that

00:05:02,960 --> 00:05:04,040
in functional programming

00:05:04,040 --> 00:05:05,840
you want to do everything with functions,

00:05:05,840 --> 00:05:10,440
so we want to express everything in our program in terms of functions.

00:05:11,200 --> 00:05:12,800
And a function of course is just something

00:05:12,800 --> 00:05:15,880
that takes an input and gives an output.

00:05:16,100 --> 00:05:17,780
So, we want to be thinking about

00:05:17,780 --> 00:05:21,480
kind of the flow of data of inputs and outputs through the program,

00:05:21,480 --> 00:05:24,280
instead of thinking about objects and how they interact

00:05:24,280 --> 00:05:25,150
and how they manipulate

00:05:25,150 --> 00:05:30,000
or thinking about steps in a recipe like in an imperative style.

00:05:30,200 --> 00:05:32,600
Here we're really thinking about how we can express everything

00:05:32,600 --> 00:05:34,050
in terms of functions,

00:05:34,050 --> 00:05:36,050
taking inputs, giving outputs.

00:05:37,750 --> 00:05:39,160
So, for example,

00:05:39,160 --> 00:05:42,160
this would be a non-functional way for me to get the text

00:05:42,160 --> 00:05:44,400
“Hi, I'm Anjana” to appear on the screen.

00:05:44,400 --> 00:05:49,800
I could assign a variable, I call it “name”

00:05:49,800 --> 00:05:51,400
and have it store the text “Anjana.”

00:05:51,550 --> 00:05:55,520
I could have a greeting like “Hi, I'm” or “Hello, I'm”, whatever,

00:05:55,520 --> 00:05:57,520
and then I could log that to the console.

00:05:57,520 --> 00:06:00,400
This is sort of an imperative style.

00:06:00,400 --> 00:06:03,000
First do this, then do that, then do this other thing,

00:06:03,200 --> 00:06:04,200
we don't have functions here,

00:06:04,200 --> 00:06:08,080
we're not expressing this in terms of how inputs are transformed into outputs.

00:06:08,980 --> 00:06:11,700
So, maybe a more functional way of doing the same thing

00:06:11,900 --> 00:06:14,520
and this is a really simple example, just for the sake of it,

00:06:14,800 --> 00:06:17,000
is to define a function called greet

00:06:17,000 --> 00:06:19,400
which takes a parameter name

00:06:19,650 --> 00:06:22,840
and returns a string which adds “Hi, I'm”

00:06:23,000 --> 00:06:24,840
to the beginning of that name.

00:06:24,840 --> 00:06:26,440
So, for example, if I type greet,

00:06:26,440 --> 00:06:27,640
the string Anjana,

00:06:28,300 --> 00:06:29,360
feeding that as input

00:06:29,360 --> 00:06:31,360
then I get the output “Hi, I'm Anjana”,

00:06:31,800 --> 00:06:34,720
that's a more functional way expressing this in terms of functions.

00:06:37,120 --> 00:06:39,000
Okay. So, another...

00:06:39,000 --> 00:06:41,600
maybe the main thing about functional programming

00:06:41,600 --> 00:06:43,800
is to avoid side effects

00:06:44,100 --> 00:06:46,100
and instead to use pure functions.

00:06:46,100 --> 00:06:47,440
So, what does that mean?

00:06:47,440 --> 00:06:50,760
A side effect is anything that a function might do

00:06:50,760 --> 00:06:55,560
that isn't computing its output from the inputs you've given

00:06:55,800 --> 00:06:57,560
and returning that output.

00:06:58,160 --> 00:06:59,560
So, for example,

00:07:00,300 --> 00:07:03,500
printing something to the console is not returning an output,

00:07:03,500 --> 00:07:05,000
it's doing something else,

00:07:05,000 --> 00:07:07,300
something that's on the side of the function

00:07:07,700 --> 00:07:14,160
or if you have a function that uses some globally defined variable

00:07:14,160 --> 00:07:16,000
to compute its output

00:07:16,000 --> 00:07:19,800
that doesn't depend only on the input to that function,

00:07:19,800 --> 00:07:21,000
so that's not pure.

00:07:21,000 --> 00:07:23,350
It's taking something from outside the function

00:07:23,350 --> 00:07:26,000
and involving it in some way in what the function does.

00:07:26,950 --> 00:07:31,000
So, this is just a really quick explanation of what a pure function

00:07:31,000 --> 00:07:33,000
that avoids side-effects would do.

00:07:34,500 --> 00:07:36,000
For more information on that

00:07:36,000 --> 00:07:39,000
there's excellent Wikipedia articles on these sorts of things,

00:07:39,200 --> 00:07:40,240
but basically the idea is that

00:07:40,240 --> 00:07:42,100
you want your function to do nothing

00:07:42,100 --> 00:07:44,950
except take its input, use that and only that

00:07:44,950 --> 00:07:46,000
to compute an output

00:07:46,000 --> 00:07:47,000
and then return it.

00:07:47,000 --> 00:07:48,000
That's pure.

00:07:48,700 --> 00:07:52,040
So, for example, this function here,

00:07:52,740 --> 00:07:56,360
we have this globally defined variable name

00:07:56,700 --> 00:07:58,550
which gets used in the function

00:07:58,550 --> 00:08:01,440
as you can see in the last line there,

00:08:01,440 --> 00:08:03,500
it gets used, so there's no input,

00:08:03,500 --> 00:08:06,100
we don't have name as an argument to this function,

00:08:06,100 --> 00:08:08,500
it's just reading something in from the global state.

00:08:08,700 --> 00:08:09,600
That's not pure.

00:08:09,900 --> 00:08:11,300
Also, not pure because

00:08:11,450 --> 00:08:14,450
the return value of this function here isn't what we care about,

00:08:14,450 --> 00:08:16,160
we care about doing something,

00:08:16,160 --> 00:08:18,000
changing the world in some way

00:08:18,000 --> 00:08:19,100
other than the return value,

00:08:19,100 --> 00:08:21,000
in this case, printing to the console.

00:08:21,500 --> 00:08:24,120
So, this is a not pure function here.

00:08:24,320 --> 00:08:26,320
A pure function might look like this.

00:08:27,900 --> 00:08:29,160
Here we have,

00:08:29,160 --> 00:08:30,660
the only thing that matters

00:08:30,660 --> 00:08:32,900
to the output of this function is its input,

00:08:32,900 --> 00:08:36,200
the argument that we pass to it

00:08:36,400 --> 00:08:39,840
and the only thing that it does is return its output.

00:08:40,940 --> 00:08:43,750
Okay, so I've been talking for a while now about pure functions

00:08:43,750 --> 00:08:47,000
that's because this is really like a key thing at least for me,

00:08:47,000 --> 00:08:51,200
something I've taken as one of the key parts of functional programming

00:08:51,200 --> 00:08:53,900
is thinking about things as purely as possible.

00:08:56,200 --> 00:09:00,000
Another key point would be using higher-order functions.

00:09:00,250 --> 00:09:04,400
So, this means functions that can take as inputs other functions

00:09:04,400 --> 00:09:07,880
or a function that can return a function as its output.

00:09:07,980 --> 00:09:11,720
So, basically, we're treating functions kind of as objects themselves.

00:09:11,720 --> 00:09:14,400
They can be passed to other functions.

00:09:14,400 --> 00:09:17,680
You can have layers of functions within functions within functions, etc.,

00:09:17,680 --> 00:09:19,380
and these are what's called higher-order functions,

00:09:19,380 --> 00:09:21,380
they come up a lot in functional programming.

00:09:22,980 --> 00:09:25,500
This is a bit of a random example,

00:09:25,500 --> 00:09:28,280
but let's say we have this function at the top here,

00:09:28,280 --> 00:09:30,280
makeAdjectifier

00:09:30,280 --> 00:09:31,780
where we give it an adjective

00:09:32,150 --> 00:09:34,720
and it returns actually a function.

00:09:34,820 --> 00:09:37,920
It doesn't return a string or a number or anything like that,

00:09:37,920 --> 00:09:39,220
it returns us a function

00:09:39,450 --> 00:09:43,840
which adds that adjective to a string that you give it.

00:09:44,200 --> 00:09:47,840
So, for example, I can use the makeAdjectifier function

00:09:48,440 --> 00:09:50,100
feed it the input “cool”

00:09:50,250 --> 00:09:52,900
and get a function that's called coolifier.

00:09:53,550 --> 00:09:56,200
So, now when I pass a string to coolifier,

00:09:56,750 --> 00:09:59,280
I get “cool” added to that string.

00:09:59,380 --> 00:10:02,720
So, if I pass conference, I get cool conference.

00:10:03,320 --> 00:10:08,000
So, the idea here is that we have a higher-order function

00:10:08,100 --> 00:10:09,200
which returns a function.

00:10:09,750 --> 00:10:12,350
And this kind of wrapping your head around this

00:10:12,350 --> 00:10:13,350
at least for me

00:10:13,350 --> 00:10:16,750
is one of the key things to being able to write in a functional style

00:10:16,750 --> 00:10:18,100
because as we'll see a bit later,

00:10:18,100 --> 00:10:20,100
we need these higher-order functions

00:10:20,100 --> 00:10:25,500
in order to avoid some of the tricks

00:10:25,500 --> 00:10:27,500
that we're used to using from other paradigms.

00:10:27,900 --> 00:10:31,280
So, learning the thing to get into that functional mindset

00:10:31,280 --> 00:10:34,400
for me really involved wrapping my head around this concept.

00:10:36,600 --> 00:10:37,050
Okay.

00:10:37,050 --> 00:10:38,900
So, one of these things that we're going to avoid

00:10:38,900 --> 00:10:41,200
that we're used to doing is iterating,

00:10:41,200 --> 00:10:43,600
using like “for” or “while”, these sort of things.

00:10:43,600 --> 00:10:47,600
We're used to going over lists and doing things to all the items in it.

00:10:48,100 --> 00:10:50,600
Instead, in a functional style,

00:10:50,600 --> 00:10:55,600
we might use higher-order functions like Map or Reduce or Filter

00:10:55,600 --> 00:10:57,600
which often take as an input

00:10:57,600 --> 00:11:01,480
not only the list that you want to do something to in some way

00:11:01,680 --> 00:11:05,040
but also a function that then you're going to apply to it.

00:11:06,440 --> 00:11:09,600
In the interest of time I'm not going to go into too much detail

00:11:09,600 --> 00:11:12,250
about what Map, Reduce, and Filter do,

00:11:12,250 --> 00:11:17,880
but I found and also thanks to my colleague Khalid up there,

00:11:18,100 --> 00:11:21,750
a really cool graphic that I think expresses Map and Reduce pretty well,

00:11:21,750 --> 00:11:23,150
maybe you guys have seen it before,

00:11:23,150 --> 00:11:25,550
the MapReduce Sandwich, everyone!

00:11:26,550 --> 00:11:29,550
So, the idea here is that let's say you have a list,

00:11:29,550 --> 00:11:31,750
in this case, a bunch of vegetables.

00:11:32,450 --> 00:11:33,600
They're whole vegetables.

00:11:33,600 --> 00:11:35,100
We got some bread in there too

00:11:35,550 --> 00:11:39,000
and we want to transform that data in some way.

00:11:39,000 --> 00:11:41,750
So, for example, let's say we want to slice that data

00:11:41,750 --> 00:11:45,160
and we have a function ‘slice up’ or ‘cut up’ or ‘chop’

00:11:45,460 --> 00:11:48,360
which we can apply to each item in that list.

00:11:48,360 --> 00:11:53,000
Now, usually I would do “for vegetable in sandwich ingredients,”

00:11:54,150 --> 00:11:54,900
do all of this,

00:11:54,900 --> 00:11:56,200
do all this chopping,

00:11:56,900 --> 00:12:00,000
but in a functional style we'd use Map,

00:12:00,600 --> 00:12:04,840
give it the list of ingredients and give it the function ‘chop’

00:12:05,300 --> 00:12:10,360
and I would get out a new list where everything has been chopped.

00:12:11,150 --> 00:12:12,960
Then we have a Reduce function

00:12:12,960 --> 00:12:18,760
which basically combines all of the items in a list in a certain way,

00:12:18,760 --> 00:12:20,760
in this case, layering

00:12:20,760 --> 00:12:22,460
to make a delicious sandwich,

00:12:23,100 --> 00:12:25,100
and Filter let's say

00:12:25,300 --> 00:12:27,500
could be if you hate cucumbers,

00:12:27,900 --> 00:12:29,500
you could have a Filter function

00:12:29,500 --> 00:12:31,500
which makes sure that

00:12:32,150 --> 00:12:35,600
only things that are not cucumbers get through the filter.

00:12:36,100 --> 00:12:39,480
So, these are the ways we use these higher-order functions

00:12:39,480 --> 00:12:45,480
to get around the type of “for” or “while” iteration

00:12:45,480 --> 00:12:48,300
that we're used to doing in functional programming,

00:12:48,300 --> 00:12:51,560
instead we're going to feed functions to higher-order functions

00:12:51,560 --> 00:12:53,160
like Map, Reduce, and Filter

00:12:53,160 --> 00:12:55,000
to get the sandwich that we want.

00:12:56,000 --> 00:12:59,600
And again, this is not intended to be a totally clear explanation

00:12:59,600 --> 00:13:01,400
of how Map, Reduce, and Filter work,

00:13:01,400 --> 00:13:03,800
but there's plenty of information on that online.

00:13:03,900 --> 00:13:07,120
The idea is that we want to use these instead of “for.”

00:13:09,120 --> 00:13:11,220
So, another thing that we want to do is

00:13:11,220 --> 00:13:14,900
we want to avoid mutating data, |avoid mutability.

00:13:16,300 --> 00:13:20,280
Mutation in the sense I just mean changing objects in place.

00:13:20,880 --> 00:13:23,500
So, when we have something that's immutable,

00:13:23,500 --> 00:13:26,400
I'm sure a lot of you guys are familiar with the term,

00:13:26,400 --> 00:13:29,100
it's something data that can't be changed in place.

00:13:29,100 --> 00:13:31,850
Once we've set it it's there forever.

00:13:31,850 --> 00:13:33,160
It's never going to change.

00:13:34,000 --> 00:13:35,200
So, let's take a look at an example.

00:13:35,300 --> 00:13:36,750
Just because for me

00:13:36,750 --> 00:13:39,250
this was another thing that required a little head wrapping.

00:13:39,850 --> 00:13:43,600
So, this would be an example of mutation which is non-functional.

00:13:44,550 --> 00:13:46,750
We have a rooms variable which stores a list,

00:13:46,750 --> 00:13:48,750
so “H1,” “H2,” and “H3,”

00:13:48,750 --> 00:13:50,200
because that's what we thought the rooms were,

00:13:50,200 --> 00:13:52,200
at least that's what I thought the relevant rooms were,

00:13:52,900 --> 00:13:56,050
and then we say no no no actually it's not “H3,” it's “H4”.

00:13:56,050 --> 00:14:01,600
So, let's replace the thing at index [2] in rooms with “H4.”

00:14:02,200 --> 00:14:05,440
And so, then we have rooms has actually changed,

00:14:05,440 --> 00:14:07,700
we went from [“H1,” “H2,” “H3”]

00:14:07,700 --> 00:14:09,200
to [“H1,” “H2,” “H4”].

00:14:09,450 --> 00:14:12,480
So, that is still stored in the variable rooms

00:14:12,480 --> 00:14:14,480
but we've actually changed something in place

00:14:15,300 --> 00:14:18,880
and this is something that functional programming avoids

00:14:18,880 --> 00:14:20,880
because this can cause a lot of problems

00:14:20,880 --> 00:14:23,350
and this is part of the reason why we get into trouble with this

00:14:23,350 --> 00:14:25,750
and with these sort of object-oriented approaches,

00:14:25,750 --> 00:14:29,320
sometimes you can change things in a way that you didn't intend,

00:14:29,420 --> 00:14:31,220
so that what you thought you were dealing with

00:14:31,220 --> 00:14:34,300
if I thought that rooms meant [“H1,” “H2,” “H3”]

00:14:34,500 --> 00:14:36,800
and I didn't know that somewhere else in my code

00:14:36,800 --> 00:14:40,100
I had replaced something in the rooms array

00:14:41,200 --> 00:14:42,600
I could run into trouble.

00:14:42,600 --> 00:14:44,900
I could end up introducing bugs into my code

00:14:44,900 --> 00:14:46,900
and having a really hard time tracking them down

00:14:46,900 --> 00:14:48,800
because rooms here is the right thing,

00:14:48,800 --> 00:14:50,080
rooms there is the wrong thing,

00:14:50,080 --> 00:14:52,080
ah! what happened? Where did this go wrong?

00:14:52,080 --> 00:14:52,900
Oh! my God!

00:14:52,900 --> 00:14:54,400
You end up crying in front of your computer.

00:14:54,600 --> 00:14:55,400
No, just me.

00:14:56,600 --> 00:14:58,800
So, a better way to go about things

00:14:58,800 --> 00:15:02,120
is to think of all data as immutable, never changing.

00:15:02,900 --> 00:15:04,120
For example,

00:15:04,820 --> 00:15:08,360
with no mutation we still have our rooms which has the wrong

00:15:08,360 --> 00:15:09,860
[“H1,” “H2,” “H3”]

00:15:10,100 --> 00:15:11,600
but instead of changing it in place

00:15:11,600 --> 00:15:13,600
I'm going to make a new rooms array

00:15:13,950 --> 00:15:15,600
using this map function

00:15:15,600 --> 00:15:17,600
that we talked about a little bit earlier

00:15:17,950 --> 00:15:19,600
where I'm mapping,

00:15:20,050 --> 00:15:24,360
I'm feeding a function into this map,

00:15:24,760 --> 00:15:28,100
which looks at each room in the list

00:15:28,600 --> 00:15:30,200
and if it's “H3”,

00:15:30,800 --> 00:15:33,000
oops! I have a missing = sign there,

00:15:33,000 --> 00:15:34,300
last-minute slides,

00:15:34,500 --> 00:15:39,690
if the room is “H3” it returns “H4” instead of “H3”,

00:15:39,790 --> 00:15:42,090
otherwise it returns whatever the room was.

00:15:43,000 --> 00:15:46,440
Okay. Understanding this specific example is not crucial

00:15:46,600 --> 00:15:50,840
but the point is that once I've assigned this new rooms variable,

00:15:50,840 --> 00:15:55,560
new rooms has the correct values I expect “H1,” “H2,” and “H4”.

00:15:55,560 --> 00:15:58,800
But rooms is the same as it always was,

00:15:58,800 --> 00:16:00,000
it hasn't changed at all.

00:16:00,300 --> 00:16:02,550
So, this is thinking about rooms as being immutable,

00:16:02,550 --> 00:16:03,800
we're not changing it

00:16:03,950 --> 00:16:07,380
and that's something that's really important for functional programming

00:16:07,580 --> 00:16:08,350
because as I said,

00:16:08,350 --> 00:16:10,750
it helps you avoid a lot of headaches, a lot of bugs.

00:16:12,650 --> 00:16:14,650
So, how much time do I have?

00:16:14,650 --> 00:16:15,300
Okay. Good.

00:16:15,300 --> 00:16:18,160
We have a little time to talk about persistent data structures, yey!

00:16:19,100 --> 00:16:21,760
The problem with immutability is that

00:16:21,760 --> 00:16:25,760
when you're treating arrays and things like that as immutable,

00:16:25,860 --> 00:16:28,900
what you end up doing is making new copies of everything.

00:16:29,000 --> 00:16:32,680
So, if I want to change my one room in this list

00:16:32,680 --> 00:16:34,680
I have to make a whole new array

00:16:35,700 --> 00:16:38,350
and when you're dealing with short little things like this

00:16:38,350 --> 00:16:39,450
maybe that's not a big deal,

00:16:39,450 --> 00:16:42,000
but as your objects get bigger, more complex,

00:16:42,200 --> 00:16:44,600
this can give you efficiency problems

00:16:44,600 --> 00:16:46,600
because if you have to copy over everything,

00:16:46,600 --> 00:16:48,600
even the things that didn't change,

00:16:48,800 --> 00:16:51,050
every time you make one little adjustment

00:16:51,050 --> 00:16:52,950
and you want to make a new copy,

00:16:52,950 --> 00:16:55,720
a slightly different copy of your array,

00:16:56,320 --> 00:16:58,720
it takes you a lot of time,

00:16:58,720 --> 00:17:01,100
you have to go through everything in the list to copy it over,

00:17:01,100 --> 00:17:03,300
you end up using a lot of space

00:17:03,300 --> 00:17:05,960
that maybe once the objects start getting bigger and bigger

00:17:05,960 --> 00:17:07,560
becomes a problem.

00:17:08,100 --> 00:17:13,520
And so, one thing that's very popular in the functional world

00:17:13,720 --> 00:17:16,720
as a way of getting around these efficiency issues

00:17:17,100 --> 00:17:19,300
is to use persistent data structures.

00:17:20,200 --> 00:17:24,950
This was something introduced sort of theoretically by Phil Bagwell,

00:17:24,950 --> 00:17:27,100
he wrote a paper called Ideal Hash Trees.

00:17:28,200 --> 00:17:30,100
I can put a link in the slide to that later

00:17:30,300 --> 00:17:33,640
and then Rich Hickey who invented the language Clojure

00:17:34,100 --> 00:17:38,320
implemented the data structures using Bagwell's ideas

00:17:38,720 --> 00:17:43,500
to make Clojure really efficient for these immutable data structures

00:17:43,500 --> 00:17:45,500
and for these functional operations.

00:17:46,100 --> 00:17:46,400
Okay.

00:17:46,400 --> 00:17:49,800
So, the way persistent data structures work if I may,

00:17:49,800 --> 00:17:50,800
if you will indulge me,

00:17:50,800 --> 00:17:53,400
I'm going to step back to the chalkboard right here.

00:17:53,800 --> 00:17:56,100
We're getting retro. Yeah, it's happening.

00:17:58,100 --> 00:17:58,400
Okay.

00:17:58,400 --> 00:18:06,560
So, if we have like an array where we had H1, H2, H3,

00:18:08,000 --> 00:18:12,120
typically what I do in a mutable world is just get rid of this

00:18:12,120 --> 00:18:14,120
and replace it with H4,

00:18:14,700 --> 00:18:16,320
but as we said we want to avoid that.

00:18:16,320 --> 00:18:23,800
So, instead, if I copy it over into a new array,

00:18:23,800 --> 00:18:25,800
I copy H1,

00:18:25,800 --> 00:18:27,800
I copy H2

00:18:28,000 --> 00:18:31,800
and I replace, instead of copying H3 I put in H4.

00:18:31,950 --> 00:18:32,200
Great!

00:18:32,200 --> 00:18:34,100
But now I have to store two arrays,

00:18:34,100 --> 00:18:35,200
taking up a lot of time,

00:18:35,200 --> 00:18:37,200
look how long that took me to do all of that.

00:18:37,500 --> 00:18:38,480
Terrible. Right?

00:18:38,480 --> 00:18:41,100
I know you guys feel as upset about this as I do.

00:18:41,100 --> 00:18:42,500
I can see it in your faces.

00:18:43,700 --> 00:18:50,840
What if instead we represented this array right here as a tree,

00:18:54,400 --> 00:18:59,400
such that each leaf node of the tree

00:18:59,400 --> 00:19:02,000
is one of the things that I'm trying to store

00:19:02,200 --> 00:19:06,680
or perhaps 2 of the things or 3 or 32 or some number of the things

00:19:07,100 --> 00:19:09,720
and if I want to change something,

00:19:09,720 --> 00:19:12,300
I don't need to replace the entire array,

00:19:12,550 --> 00:19:16,680
I can just make a new node over here, like H4,

00:19:17,280 --> 00:19:19,900
and now I can make a new tree

00:19:19,900 --> 00:19:25,400
which instead of repeating H1 and H2

00:19:25,400 --> 00:19:29,840
I can reuse those same things and just make a new node

00:19:29,840 --> 00:19:33,160
which connects them to my new element over here,

00:19:33,700 --> 00:19:41,840
so that now I have here a data structure which contains H1, H2 and H4

00:19:42,150 --> 00:19:45,560
but I didn't need to make a whole new thing.

00:19:45,760 --> 00:19:48,300
I just needed to make my one little part.

00:19:48,300 --> 00:19:51,360
I can reuse the old structure of the list.

00:19:51,600 --> 00:19:56,400
So, this idea, this sort of topic is called structural sharing

00:19:56,400 --> 00:20:01,160
because we can share parts of the old versions with the new versions,

00:20:01,560 --> 00:20:04,500
so we have much more efficient operations for adding,

00:20:04,500 --> 00:20:08,840
changing things or moving things from vectors, for example, or arrays

00:20:09,500 --> 00:20:15,480
and this can also be done for maps, for hash maps that sort of thing

00:20:15,780 --> 00:20:19,980
and it basically makes the world of functional programming bust wide open

00:20:19,980 --> 00:20:23,040
so that we don't have to go through these long time

00:20:23,040 --> 00:20:25,040
and expensive space operations

00:20:25,040 --> 00:20:28,800
to update our immutable data all the time.

00:20:29,250 --> 00:20:32,120
So, to do this in JavaScript,

00:20:32,320 --> 00:20:34,720
there are a couple of libraries that are really popular.

00:20:35,000 --> 00:20:37,400
One which I like to use is called Mori

00:20:37,550 --> 00:20:39,400
which I'll show you the link for in a little bit

00:20:39,400 --> 00:20:41,880
which actually uses ClojureScript

00:20:41,880 --> 00:20:44,600
which has these type of data structures natively,

00:20:44,800 --> 00:20:46,800
it ports them over to JavaScript,

00:20:46,800 --> 00:20:48,800
so you can use them right from JavaScript

00:20:48,800 --> 00:20:49,560
and it's great.

00:20:49,560 --> 00:20:52,900
It has a lot of also like general functional programming helpers

00:20:52,900 --> 00:20:55,600
like Map and Reduce and lots of other things.

00:20:55,950 --> 00:20:58,800
There's also another popular library called Immutable.js

00:20:58,800 --> 00:20:59,880
which Facebook put out

00:20:59,880 --> 00:21:02,480
which is JavaScript through and through.

00:21:02,680 --> 00:21:04,380
I haven't worked as much with that

00:21:04,380 --> 00:21:06,380
but I know a lot of people like that as well.

00:21:06,680 --> 00:21:08,580
And yeah, so these are ways

00:21:08,580 --> 00:21:11,000
you can try out using these immutable data structures

00:21:11,000 --> 00:21:14,880
if that is something you feel like you can't wait to do now.

00:21:16,100 --> 00:21:16,600
I know.

00:21:16,600 --> 00:21:19,200
I can just feel the excitement. Yeah, that's great.

00:21:19,200 --> 00:21:20,800
Okay. Moving on.

00:21:21,700 --> 00:21:23,200
If you're ready to try it out,

00:21:24,100 --> 00:21:27,600
like I said, we have Mori and Immutable.js,

00:21:28,000 --> 00:21:29,600
links there to those libraries.

00:21:29,850 --> 00:21:31,700
There's also a lot of utility libraries

00:21:31,700 --> 00:21:34,800
which don't focus so much on this persistent data structure thing,

00:21:34,950 --> 00:21:41,000
but instead give you a lot of helper functions like Map, Reduce, etc.

00:21:42,300 --> 00:21:45,360
So, Underscore, Lodash, for example.

00:21:45,560 --> 00:21:48,000
Today I found out that Ramda is a thing

00:21:48,500 --> 00:21:50,300
because there was a talk on it the other day

00:21:50,550 --> 00:21:51,700
and there are many more.

00:21:51,900 --> 00:21:55,900
And in fact, JavaScript has some built-in functions,

00:21:55,900 --> 00:22:00,300
like for example, arrays have a built in Map, Reduce functions.

00:22:00,300 --> 00:22:04,160
So, a few slides ago we saw this rooms.map,

00:22:04,700 --> 00:22:09,280
that's because the array prototype has these functions Map, Reduce, etc.

00:22:09,400 --> 00:22:13,000
So, you can even do some functional programming in pure vanilla JavaScript

00:22:13,000 --> 00:22:15,000
without using any of these libraries.

00:22:17,150 --> 00:22:17,650
Okay.

00:22:17,650 --> 00:22:20,340
So, if you are sitting there thinking,

00:22:20,340 --> 00:22:24,850
What? Huh? I didn't really get that something about immutability,

00:22:24,850 --> 00:22:27,000
side effects, pure functions. What now, huh?

00:22:27,400 --> 00:22:32,240
If you want to learn a bit more about all these buzzwords,

00:22:32,240 --> 00:22:33,900
like I said, all these sexy buzzwords

00:22:33,900 --> 00:22:36,400
that I've been throwing at you for the last 20 minutes,

00:22:36,800 --> 00:22:41,000
I highly recommend a nice gentle introductory article called

00:22:41,000 --> 00:22:43,000
“An introduction to functional programming”

00:22:43,100 --> 00:22:44,300
 by Mary Rose Cook

00:22:44,300 --> 00:22:47,000
who is a former facilitator at The Recurse Center

00:22:47,000 --> 00:22:48,000
that I keep talking about.

00:22:48,850 --> 00:22:50,300
The link is up there,

00:22:50,300 --> 00:22:54,040
but basically this is a really nice introduction

00:22:54,040 --> 00:22:56,400
that kind of goes into a little bit more depth

00:22:56,400 --> 00:23:00,000
in some of the “commandments” of functional programming

00:23:00,000 --> 00:23:01,280
that I've mentioned today.

00:23:01,480 --> 00:23:04,380
So, if you are a little intrigued

00:23:04,380 --> 00:23:07,680
but not quite clear on this stuff that I've been mentioning,

00:23:07,680 --> 00:23:09,080
I highly recommend you check it out.

00:23:10,180 --> 00:23:13,280
So, I think that's it for my talk.

00:23:13,780 --> 00:23:16,600
We have a couple of minutes for questions, I suppose,

00:23:16,600 --> 00:23:18,000
eight minutes by my account,

00:23:18,300 --> 00:23:21,700
but first of all I just wanted to say thank you guys very much.

00:23:22,200 --> 00:23:23,600
I'm Anjana Vakil.

00:23:23,600 --> 00:23:25,100
Anjana Vakil on Twitter

00:23:25,100 --> 00:23:26,700
and has link there to my GitHub.

00:23:26,700 --> 00:23:28,600
So, would love to keep in touch

00:23:28,600 --> 00:23:30,800
if anybody else is out there also learning

00:23:30,800 --> 00:23:33,680
functional JavaScript as a newbie like myself,

00:23:33,980 --> 00:23:35,280
definitely reach out,

00:23:35,280 --> 00:23:36,520
we could stick together,

00:23:37,000 --> 00:23:39,200
but first of all I want to give a huge thanks

00:23:39,200 --> 00:23:41,800
to again the JSUnconf organizers,

00:23:41,800 --> 00:23:43,550
especially the diversity sponsors.

00:23:43,550 --> 00:23:45,650
I'm here on a diversity ticket myself

00:23:45,650 --> 00:23:48,100
and wouldn't have been able to come without that awesome program

00:23:48,400 --> 00:23:52,120
and all of you and the sponsors who sponsored those tickets

00:23:52,420 --> 00:23:55,000
and also a huge huge thank you to The Recurse Center

00:23:55,000 --> 00:23:58,250
and some of the alumni there who have helped me learn all this stuff

00:23:58,250 --> 00:24:00,250
including Khalid at the back there

00:24:00,700 --> 00:24:02,850
and Sal Becker, another alum,

00:24:02,850 --> 00:24:04,850
who explained a lot of this stuff to me

00:24:04,850 --> 00:24:08,700
over several long caffeine-fueled conversations at The Recurse Center

00:24:09,100 --> 00:24:12,100
and if any of you are interested in spending time

00:24:12,100 --> 00:24:18,280
on self-directed educational programming retreat in New York City

00:24:18,280 --> 00:24:20,480
definitely check out recurse.com,

00:24:20,480 --> 00:24:22,000
it's an amazing community.

00:24:22,650 --> 00:24:24,840
Okay, that's it for me. Thanks.

00:24:24,840 --> 00:24:33,000
[Applause]

00:24:33,500 --> 00:24:35,000
Thank you very much.

00:24:35,300 --> 00:24:37,000
Yes, _____

00:24:37,000 --> 00:24:41,300
Does anybody have any questions about functional programming?

00:24:43,200 --> 00:24:45,300
Don’t know if I'll be able to answer them but I can try.

00:24:45,700 --> 00:24:46,440
Yeah.

00:24:55,100 --> 00:24:57,600
Actually, always the professors at my faculty

00:24:57,600 --> 00:24:59,600
always said that object-oriented programming

00:24:59,600 --> 00:25:02,880
is better than functional programming

00:25:03,280 --> 00:25:06,100
and I was thinking that is it better

00:25:06,100 --> 00:25:08,100
or is it you think that we should use

00:25:08,100 --> 00:25:09,900
functional programming only on JavaScript

00:25:09,900 --> 00:25:14,100
or also on other programming languages like C _____

00:25:15,600 --> 00:25:16,800
So, I think that's a great question

00:25:16,800 --> 00:25:19,000
and it kind of gets into a little bit of the,

00:25:19,650 --> 00:25:23,000
what I think of as kind of the philosophy of programming paradigms.

00:25:23,300 --> 00:25:25,800
So, as I was learning about functional programming

00:25:26,300 --> 00:25:29,240
I started even wondering what is a programming paradigm

00:25:29,240 --> 00:25:31,000
and why do people fight about them,

00:25:31,000 --> 00:25:33,300
why do people say object orientation sucks,

00:25:33,300 --> 00:25:34,720
we have to do everything functional

00:25:34,720 --> 00:25:37,120
and why do people say no, functional programming sucks,

00:25:37,120 --> 00:25:38,820
we need object orientation.

00:25:38,820 --> 00:25:41,820
And the conclusion that I came to is that

00:25:42,620 --> 00:25:46,650
no one paradigm is better or worse than other paradigms.

00:25:46,650 --> 00:25:49,280
They just have different advantages and disadvantages

00:25:49,280 --> 00:25:51,180
and they have different situations

00:25:51,180 --> 00:25:54,820
in which they're going to be kind of the best tool

00:25:55,100 --> 00:25:56,520
for that particular problem.

00:25:56,820 --> 00:25:59,750
So, for example, if you just want to really quickly write up a script

00:25:59,750 --> 00:26:03,240
that just does something on your computer once really fast,

00:26:03,540 --> 00:26:05,540
you're probably just going to do it in an imperative style,

00:26:05,540 --> 00:26:07,240
do this, then do that, then do the other thing.

00:26:07,240 --> 00:26:08,300
If you don't need to maintain it,

00:26:08,300 --> 00:26:10,000
if you just need it to happen right there,

00:26:10,120 --> 00:26:13,600
imperative programming is a totally legit paradigm for that.

00:26:14,100 --> 00:26:17,300
If you're trying to model real world objects

00:26:17,300 --> 00:26:18,700
and how they interact

00:26:18,700 --> 00:26:22,100
and how they go around and things you can do,

00:26:22,100 --> 00:26:24,100
like if you're trying to model, I don't know,

00:26:24,500 --> 00:26:26,100
books in a library

00:26:26,100 --> 00:26:29,850
or classes with teachers and students

00:26:29,850 --> 00:26:31,850
and how they all interrelate that sort of thing,

00:26:32,260 --> 00:26:36,080
maybe thinking about it in an object-oriented way makes most sense

00:26:36,380 --> 00:26:38,700
because that's exactly the problem you're trying to solve,

00:26:38,700 --> 00:26:40,000
is modeling objects

00:26:40,200 --> 00:26:42,000
and that's why that paradigm came about.

00:26:43,000 --> 00:26:46,080
But if you're trying to avoid some of those problems

00:26:46,080 --> 00:26:46,960
that I was talking about

00:26:46,960 --> 00:26:48,960
when you have maybe a situation

00:26:48,960 --> 00:26:51,560
that doesn't actually refer to real-world objects,

00:26:51,560 --> 00:26:54,240
where you're using objects just because you have to

00:26:54,240 --> 00:26:57,440
and that's introducing all kinds of side effects and weird bugs

00:26:57,440 --> 00:26:58,800
that are hard to track down,

00:26:59,000 --> 00:27:00,900
maybe you want to consider thinking about it

00:27:00,900 --> 00:27:03,050
in terms of functions on your data

00:27:03,050 --> 00:27:05,550
and things being pipelined through multiple functions

00:27:05,550 --> 00:27:09,150
and undergoing various transformations,

00:27:09,150 --> 00:27:12,400
not in the sense that the data is being mutated

00:27:12,400 --> 00:27:14,850
but in the sense that we're getting new outputs

00:27:14,850 --> 00:27:16,850
based on old inputs,

00:27:16,950 --> 00:27:19,850
then functional programming is probably the way to go

00:27:19,850 --> 00:27:23,700
and it has a lot of advantages such as being nicely,

00:27:24,250 --> 00:27:28,200
you can break things down into small functions that only do one thing.

00:27:28,200 --> 00:27:29,900
So, if you want to change something

00:27:29,900 --> 00:27:32,960
you don't have to change an entire class structure,

00:27:32,960 --> 00:27:34,800
you can just change the one little function

00:27:34,800 --> 00:27:36,400
that does the thing you want to change.

00:27:36,700 --> 00:27:40,440
So, I think it has advantages, it has disadvantages.

00:27:40,800 --> 00:27:44,780
I definitely wouldn't say it's better than object orientation in all cases

00:27:44,780 --> 00:27:48,440
and I definitely wouldn't say object orientation is better in all cases either,

00:27:48,740 --> 00:27:51,240
it really depends on your situation.

00:27:52,000 --> 00:27:54,800
Also, very good introduction of programming philosophy.

00:27:54,800 --> 00:27:58,760
I used to be a philosophy major, so that might be why.

00:27:59,760 --> 00:28:01,000
Any other questions?

00:28:10,600 --> 00:28:12,000
You mentioned Map function

00:28:12,000 --> 00:28:14,200
and the Map function is not working,

00:28:14,200 --> 00:28:17,000
so do you mix it...

00:28:18,500 --> 00:28:22,240
Before that, I come from object-oriented programming style

00:28:22,240 --> 00:28:25,160
and not so much into functional.

00:28:25,960 --> 00:28:27,160
That’s cool too.

00:28:27,160 --> 00:28:31,000
The professors really just test our functions

00:28:31,000 --> 00:28:34,120
and can avoid the concurrency

00:28:34,120 --> 00:28:37,500
that the Map function could possibly introduce.

00:28:38,500 --> 00:28:42,600
Non-blocking and concurrency and promises

00:28:42,600 --> 00:28:46,520
are all things that I do not feel qualified to talk about right here.

00:28:46,720 --> 00:28:49,800
I would love to turn that question over to the audience though.

00:28:49,800 --> 00:28:51,400
Anybody want to respond?

00:28:52,900 --> 00:29:10,900
_____

00:29:10,900 --> 00:29:12,400
Fight fight fight.

00:29:12,400 --> 00:29:14,400
Just kidding.

00:29:15,100 --> 00:29:16,400
Just kidding, just kidding.

00:29:16,400 --> 00:29:18,800
That would be against the code of conduct, you guys.

00:29:18,800 --> 00:29:22,000
_____

00:29:22,000 --> 00:29:25,520
I would also guess that perhaps it's blocking

00:29:25,520 --> 00:29:29,800
but we can discuss this later in a small room or outside.

00:29:29,800 --> 00:29:31,600
[Laughter]

00:29:31,600 --> 00:29:35,440
Thank you for the conversation starter question though.

00:29:35,640 --> 00:29:36,500
Excellent question

00:29:36,500 --> 00:29:38,300
and I would love to know the answer.

00:29:38,800 --> 00:29:40,500
Look forward to talking you guys more.

00:29:41,100 --> 00:29:42,000
I guess...

00:29:42,000 --> 00:29:46,320
I guess we are done with the talks, the big talks now.

00:29:46,320 --> 00:29:46,920
Thank you.

00:29:46,920 --> 00:29:48,120
Thank you. - Again.

00:29:48,120 --> 00:29:51,920

YouTube URL: https://www.youtube.com/watch?v=e-5obm1G_FY


