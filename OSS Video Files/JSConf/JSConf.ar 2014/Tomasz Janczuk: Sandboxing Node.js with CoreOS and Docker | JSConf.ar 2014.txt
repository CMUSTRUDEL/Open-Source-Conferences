Title: Tomasz Janczuk: Sandboxing Node.js with CoreOS and Docker | JSConf.ar 2014
Publication date: 2015-05-10
Playlist: JSConf.ar 2014
Description: 
	You are writing a cloud application that executes custom code on behalf of your users. You need to protect one user's data from another's, and you must ensure fair access to computing resources among your users, without imposing undue constraints on their code. In other words, you must build a sandbox for executing custom code. In this talk I will demonstrate a design for such a sandbox that we have created at Auth0. You will learn how we are using modern container technologies based on CoreOS and Docker to enable customers to run custom Node.js and C# code (via Edge.js) in a way that is safe, fair, and fast.

https://www.jsconfar.com/
Captions: 
	00:00:10,870 --> 00:00:16,390
so my name is thomas yang Chuck I work

00:00:13,450 --> 00:00:17,980
for of zero with gum tow and during this

00:00:16,390 --> 00:00:22,590
session will be talking about sin boxing

00:00:17,980 --> 00:00:25,869
no dress code in multi-channel systems

00:00:22,590 --> 00:00:27,820
so why would you even think about sin

00:00:25,869 --> 00:00:31,000
boxing no dress code many multi-tenant

00:00:27,820 --> 00:00:33,640
systems enable extensibility by allowing

00:00:31,000 --> 00:00:35,530
users to write custom code that is then

00:00:33,640 --> 00:00:37,300
running as part of the platform and

00:00:35,530 --> 00:00:38,829
since you since you know very little

00:00:37,300 --> 00:00:40,989
about what that code does and how it

00:00:38,829 --> 00:00:42,550
behaves you cannot fully trust it so

00:00:40,989 --> 00:00:46,239
that's why you need a sandbox to run it

00:00:42,550 --> 00:00:48,190
in he not 0 we are offering identity as

00:00:46,239 --> 00:00:49,809
a service and as part of the

00:00:48,190 --> 00:00:52,600
authentication pipeline we allow people

00:00:49,809 --> 00:00:54,100
to provide custom nodejs code that we

00:00:52,600 --> 00:00:56,140
are executing as part of every

00:00:54,100 --> 00:00:58,179
authentication transaction people can

00:00:56,140 --> 00:01:00,100
basically customize the behavior the

00:00:58,179 --> 00:01:03,579
authentication behavior for their

00:01:00,100 --> 00:01:05,920
applications and users that way however

00:01:03,579 --> 00:01:08,440
given that we don't have full control

00:01:05,920 --> 00:01:13,659
over what that code can do we need a

00:01:08,440 --> 00:01:17,020
sandbox to run that code in all custom

00:01:13,659 --> 00:01:19,660
code in ode 0 right runs in the context

00:01:17,020 --> 00:01:22,120
of an HTTP request so basically the code

00:01:19,660 --> 00:01:23,740
must execute fully within the lifetime

00:01:22,120 --> 00:01:25,000
for a single HTTP request which is the

00:01:23,740 --> 00:01:27,940
like a time span of a single

00:01:25,000 --> 00:01:30,160
authentication transaction given that

00:01:27,940 --> 00:01:32,770
the sandbox model that we required also

00:01:30,160 --> 00:01:35,080
was based on HTTP basically you were

00:01:32,770 --> 00:01:37,420
sending an HTTP POST request to the

00:01:35,080 --> 00:01:39,460
sandbox the body of the HTTP POST

00:01:37,420 --> 00:01:42,490
request contains the node.js code to

00:01:39,460 --> 00:01:44,050
execute the sandbox runs dovecote and

00:01:42,490 --> 00:01:46,660
when the result is available it sends it

00:01:44,050 --> 00:01:49,570
back to the color is Jason object in the

00:01:46,660 --> 00:01:52,630
HTTP response so this is a very basic

00:01:49,570 --> 00:01:54,250
sandbox model the program programming

00:01:52,630 --> 00:01:56,350
model around that we have created is

00:01:54,250 --> 00:02:00,210
also very simple you're basically

00:01:56,350 --> 00:02:03,880
writing a node.js code that returns

00:02:00,210 --> 00:02:05,410
javascript function closure that

00:02:03,880 --> 00:02:07,060
function accepts a single callback

00:02:05,410 --> 00:02:08,830
parameter when you're done executing

00:02:07,060 --> 00:02:11,890
your code you're supposed to return the

00:02:08,830 --> 00:02:13,900
result value to that callback that

00:02:11,890 --> 00:02:17,260
result is then civilized into Jason and

00:02:13,900 --> 00:02:19,150
returning to the color what kind of

00:02:17,260 --> 00:02:21,489
properties that we require out of that

00:02:19,150 --> 00:02:24,340
sandbox so first and foremost we require

00:02:21,489 --> 00:02:26,470
data isolation if we r XZ

00:02:24,340 --> 00:02:29,470
getting code of one tenant we expect

00:02:26,470 --> 00:02:31,569
that code to be unable to affect

00:02:29,470 --> 00:02:33,370
execution of code from other tenants in

00:02:31,569 --> 00:02:34,930
any way or from accessing data of other

00:02:33,370 --> 00:02:38,319
tenants so this is the kind of primary

00:02:34,930 --> 00:02:40,150
security requirement that we had in

00:02:38,319 --> 00:02:43,330
addition to that we also had a number of

00:02:40,150 --> 00:02:45,879
resource governance requirements around

00:02:43,330 --> 00:02:48,849
how memory CPU and networking is

00:02:45,879 --> 00:02:51,430
allocated we wanted to prevent one

00:02:48,849 --> 00:02:53,470
tenant from executing an authenticated

00:02:51,430 --> 00:02:56,380
us attack against resources of our

00:02:53,470 --> 00:02:59,440
sandbox that would prevent other tenants

00:02:56,380 --> 00:03:04,959
from running code in the same time in

00:02:59,440 --> 00:03:06,069
that sandbox so the very high level we

00:03:04,959 --> 00:03:07,989
basically looked at what is available

00:03:06,069 --> 00:03:09,879
out there in terms of sandbox in node.js

00:03:07,989 --> 00:03:12,610
code and none of the of the shelf

00:03:09,879 --> 00:03:15,310
components were meeting our requirement

00:03:12,610 --> 00:03:17,410
so we decided to build our own high

00:03:15,310 --> 00:03:20,470
level our sandbox is built on core OS

00:03:17,410 --> 00:03:23,349
dockery tcd and fleet which is a great

00:03:20,470 --> 00:03:25,690
set of technologies that help you write

00:03:23,349 --> 00:03:28,540
container based distributed applications

00:03:25,690 --> 00:03:30,190
however in themselves these technologies

00:03:28,540 --> 00:03:31,900
are insufficient to provide the kind of

00:03:30,190 --> 00:03:34,600
security guarantees we expected around

00:03:31,900 --> 00:03:37,329
the sandbox so he had to enhance the

00:03:34,600 --> 00:03:40,480
basic setup of chorus and docker with

00:03:37,329 --> 00:03:42,880
additional sandboxing mechanisms so this

00:03:40,480 --> 00:03:46,420
is the view of a single VM in a core OS

00:03:42,880 --> 00:03:48,190
cluster that runs our sandbox the

00:03:46,420 --> 00:03:50,280
primary mechanism by which we ensure

00:03:48,190 --> 00:03:53,650
data isolation between tenants is

00:03:50,280 --> 00:03:58,030
running every tenants code in their own

00:03:53,650 --> 00:03:59,950
docker container in addition to that we

00:03:58,030 --> 00:04:01,870
are creating an egress firewall around

00:03:59,950 --> 00:04:03,849
that docker container so that the code

00:04:01,870 --> 00:04:07,060
running in that container can only talk

00:04:03,849 --> 00:04:08,980
to the public Internet it cannot talk to

00:04:07,060 --> 00:04:10,810
other two endpoints exposed by other

00:04:08,980 --> 00:04:14,290
docker containers running on behalf of

00:04:10,810 --> 00:04:16,419
other tenants or two endpoints exposed

00:04:14,290 --> 00:04:19,180
by our sandbox infrastructure like the

00:04:16,419 --> 00:04:22,270
proxy the controller or etcd running on

00:04:19,180 --> 00:04:24,099
that box so the way the system functions

00:04:22,270 --> 00:04:26,200
is that when that HTTP POST request

00:04:24,099 --> 00:04:29,229
containing the code to execute arrives

00:04:26,200 --> 00:04:31,990
on the box it is first landing at the

00:04:29,229 --> 00:04:33,669
proxy component the proxy consults etcd

00:04:31,990 --> 00:04:35,870
which is a distributed configuration

00:04:33,669 --> 00:04:38,270
system like zookeeper

00:04:35,870 --> 00:04:40,100
to see if a container associated to the

00:04:38,270 --> 00:04:42,760
particular tenant is already running if

00:04:40,100 --> 00:04:45,560
it is that request is then reverse proxy

00:04:42,760 --> 00:04:47,270
to that existing container if the

00:04:45,560 --> 00:04:49,250
container doesn't exist in the proxy

00:04:47,270 --> 00:04:52,220
will create a new one associated with a

00:04:49,250 --> 00:04:56,090
tenant a creator registration etcd for

00:04:52,220 --> 00:05:00,280
future requests and reverse proxy the

00:04:56,090 --> 00:05:00,280
request to the newly created component

00:05:00,520 --> 00:05:08,290
in terms of preventing authenticated us

00:05:06,380 --> 00:05:10,460
attacks against memory CPU and other

00:05:08,290 --> 00:05:12,260
operating system resources you are using

00:05:10,460 --> 00:05:14,870
a number of mechanisms first and

00:05:12,260 --> 00:05:17,390
foremost we are leveraging limits

00:05:14,870 --> 00:05:19,400
imposed the see groups level so see

00:05:17,390 --> 00:05:29,210
groups is a Linux mechanism that docker

00:05:19,400 --> 00:05:31,490
also exposes that wasn't me the doctor

00:05:29,210 --> 00:05:33,380
also expose issue which which unable to

00:05:31,490 --> 00:05:35,150
put limits on the memory and CPU

00:05:33,380 --> 00:05:37,970
consumption of individual docking docker

00:05:35,150 --> 00:05:40,670
containers in addition to that within

00:05:37,970 --> 00:05:42,560
the sandbox containers themselves we are

00:05:40,670 --> 00:05:44,030
creating transient users basically

00:05:42,560 --> 00:05:45,650
whenever we spin up a new docker

00:05:44,030 --> 00:05:48,440
container we are creating a brand new

00:05:45,650 --> 00:05:50,630
operating system user and then we are

00:05:48,440 --> 00:05:52,520
imposing pam limits for that user so for

00:05:50,630 --> 00:05:56,090
example you are saying that user cannot

00:05:52,520 --> 00:06:00,230
create more than 50 processes or threads

00:05:56,090 --> 00:06:02,510
or he cannot create more than 5000 files

00:06:00,230 --> 00:06:05,510
in the file system so this provides us

00:06:02,510 --> 00:06:07,220
with the very basic mechanisms to limit

00:06:05,510 --> 00:06:10,850
what the code running in the sandbox

00:06:07,220 --> 00:06:13,040
container can do so with that I want to

00:06:10,850 --> 00:06:16,430
do a few demos and take our sandbox for

00:06:13,040 --> 00:06:19,550
a spin you have seen one map during the

00:06:16,430 --> 00:06:20,960
RabbitMQ presentation and I just

00:06:19,550 --> 00:06:24,050
couldn't resist I'll show you another

00:06:20,960 --> 00:06:26,780
one we also have a map about ours with

00:06:24,050 --> 00:06:30,320
more dots on it so what we are seeing

00:06:26,780 --> 00:06:31,730
here is basically eight places around

00:06:30,320 --> 00:06:33,300
the world where we have deployed our

00:06:31,730 --> 00:06:35,669
sandbox

00:06:33,300 --> 00:06:38,159
cluster so each of these places can

00:06:35,669 --> 00:06:39,930
execute custom code on our behalf during

00:06:38,159 --> 00:06:41,940
this demo I'm going to use the one that

00:06:39,930 --> 00:06:45,030
is just around the corner in Sao Paulo

00:06:41,940 --> 00:06:47,879
in Brazil just because it is the closest

00:06:45,030 --> 00:06:51,150
one latency wise so with that let's have

00:06:47,879 --> 00:06:53,699
a look at some code so this is the very

00:06:51,150 --> 00:06:55,919
basic hello world example we are

00:06:53,699 --> 00:06:57,720
creating a JavaScript function that

00:06:55,919 --> 00:06:59,190
accepts a call back in immediately turns

00:06:57,720 --> 00:07:00,930
around and codes are called back with a

00:06:59,190 --> 00:07:04,080
simple string as a result and that

00:07:00,930 --> 00:07:07,409
string is pretty much saying hello from

00:07:04,080 --> 00:07:10,169
Las Vegas and it's offending the version

00:07:07,409 --> 00:07:12,000
of node.js to it so the way you run that

00:07:10,169 --> 00:07:15,300
code i'm going to show you the organic

00:07:12,000 --> 00:07:17,400
version first we are going to use curve

00:07:15,300 --> 00:07:19,979
because this is just a simple HTTP POST

00:07:17,400 --> 00:07:21,650
request so courage enough and so we are

00:07:19,979 --> 00:07:25,050
using Colonel we are pointing it at our

00:07:21,650 --> 00:07:26,789
sandbox deployed in Sao Paulo we are

00:07:25,050 --> 00:07:28,770
saying that this code is to be executing

00:07:26,789 --> 00:07:31,050
on behalf of 10 and Q 1 and this is just

00:07:28,770 --> 00:07:32,819
an arbitrary string that denotes the

00:07:31,050 --> 00:07:39,840
isolation boundary between containers

00:07:32,819 --> 00:07:42,690
and then we are just providing the body

00:07:39,840 --> 00:07:46,050
of the HTTP POST request which is that

00:07:42,690 --> 00:07:48,770
not Jes code that we won't execute so we

00:07:46,050 --> 00:07:52,050
are going to return a function that

00:07:48,770 --> 00:07:53,580
takes a single callback parameter and

00:07:52,050 --> 00:07:59,669
you immediately calls that callback

00:07:53,580 --> 00:08:12,090
parameter with hello world and i hope i

00:07:59,669 --> 00:08:12,900
didn't make and i did make what did i

00:08:12,090 --> 00:08:16,139
miss here

00:08:12,900 --> 00:08:18,120
no our sandbox also has a very simple

00:08:16,139 --> 00:08:20,160
authentication mechanism so I have to

00:08:18,120 --> 00:08:23,940
basically provide an authentication key

00:08:20,160 --> 00:08:30,060
here this is a query parameter which is

00:08:23,940 --> 00:08:33,990
what I missed so you're sending it over

00:08:30,060 --> 00:08:36,240
to some Pablo our sandbox compilers that

00:08:33,990 --> 00:08:38,690
code executes serializes the result and

00:08:36,240 --> 00:08:41,279
here it comes back so let's run it again

00:08:38,690 --> 00:08:42,659
it is not much faster because the second

00:08:41,279 --> 00:08:45,120
time I run it the container is already

00:08:42,659 --> 00:08:48,600
running in Sao Paulo for that tenant so

00:08:45,120 --> 00:08:50,160
no extra provisioning is required so

00:08:48,600 --> 00:08:52,920
with that let's move on to a slightly

00:08:50,160 --> 00:08:54,209
more advanced example in this case the

00:08:52,920 --> 00:08:55,830
only difference is that we have a

00:08:54,209 --> 00:08:58,350
variation of the programming model which

00:08:55,830 --> 00:09:00,810
allows URL query parameters of that HTTP

00:08:58,350 --> 00:09:02,880
POST request to be propagated to the

00:09:00,810 --> 00:09:05,040
JavaScript code as part of the context

00:09:02,880 --> 00:09:07,800
object so what i'm doing here is i'm

00:09:05,040 --> 00:09:10,470
prepending a name equals of 0 URL query

00:09:07,800 --> 00:09:12,810
parameter to the URL i'm going to be

00:09:10,470 --> 00:09:15,089
involved to be invoking and then i can

00:09:12,810 --> 00:09:17,580
access that name parameter off of the

00:09:15,089 --> 00:09:19,800
context object passed into the function

00:09:17,580 --> 00:09:21,980
that I'm authoring so let's run this

00:09:19,800 --> 00:09:21,980
game

00:09:28,290 --> 00:09:32,190
oh hello of zero and just make sure

00:09:30,690 --> 00:09:37,500
up against really well i'm going to

00:09:32,190 --> 00:09:42,090
change the 02 jas cone and what comes

00:09:37,500 --> 00:09:43,950
back is calories count so here is a

00:09:42,090 --> 00:09:45,780
slightly more interesting example so

00:09:43,950 --> 00:09:47,970
let's say now that we have the ability

00:09:45,780 --> 00:09:49,980
to run arbitrary code in eight places in

00:09:47,970 --> 00:09:52,560
the world one one way we can use it is

00:09:49,980 --> 00:09:54,780
to measure latency of accessing a

00:09:52,560 --> 00:09:56,400
particular end point from those eight

00:09:54,780 --> 00:10:00,600
places around the world and this is what

00:09:56,400 --> 00:10:03,510
that code does it will call in 20 20 com

00:10:00,600 --> 00:10:05,910
basically to an HTTP GET against zero at

00:10:03,510 --> 00:10:09,720
colleges our website measure the latency

00:10:05,910 --> 00:10:14,310
of that call and return the latency in

00:10:09,720 --> 00:10:20,040
the result so let's run it from Northern

00:10:14,310 --> 00:10:23,340
California which is the other sandbox

00:10:20,040 --> 00:10:24,840
lastly we have deployed and you'll

00:10:23,340 --> 00:10:28,410
notice the latency to Northern

00:10:24,840 --> 00:10:30,300
California is very long but once you are

00:10:28,410 --> 00:10:32,250
in Northern California the latency of

00:10:30,300 --> 00:10:34,590
calling ohdeedoh.com is just 26

00:10:32,250 --> 00:10:36,450
milliseconds that is because our website

00:10:34,590 --> 00:10:38,730
of zero dot com is hosted in Northern

00:10:36,450 --> 00:10:40,710
California as well if we do the same

00:10:38,730 --> 00:10:49,260
test and send that code to be executed

00:10:40,710 --> 00:10:52,020
in Singapore that called take more time

00:10:49,260 --> 00:10:55,350
than my flight here even not is the

00:10:52,020 --> 00:10:57,840
latency from Singapore to of zero is 750

00:10:55,350 --> 00:10:59,820
two milliseconds so that way you can

00:10:57,840 --> 00:11:01,350
basically conduct very simple latency

00:10:59,820 --> 00:11:02,490
measurements by having the code deploy

00:11:01,350 --> 00:11:09,840
to different places around the world

00:11:02,490 --> 00:11:11,160
with a sim simple HTTP POST request so

00:11:09,840 --> 00:11:13,770
here comes something interesting that

00:11:11,160 --> 00:11:15,480
that ghanta mentioned the beginning in

00:11:13,770 --> 00:11:16,980
addition to running no dress code we

00:11:15,480 --> 00:11:19,650
also have the ability to run c-sharp

00:11:16,980 --> 00:11:23,040
code and you are doing this using the

00:11:19,650 --> 00:11:25,200
eds module which allows you to host CLR

00:11:23,040 --> 00:11:26,820
and v8 inside of a single process and

00:11:25,200 --> 00:11:29,040
provides an interrupt mechanism between

00:11:26,820 --> 00:11:31,230
these two so what happens here is that

00:11:29,040 --> 00:11:35,100
the node.js code is creating a

00:11:31,230 --> 00:11:37,350
JavaScript proxy around async lambda

00:11:35,100 --> 00:11:39,150
expression in c-sharp and it's also

00:11:37,350 --> 00:11:40,650
providing a marshalling capability such

00:11:39,150 --> 00:11:42,040
a thing you can exchange data between

00:11:40,650 --> 00:11:43,990
JavaScript and see

00:11:42,040 --> 00:11:45,160
are and also you can sighs threading

00:11:43,990 --> 00:11:47,970
models because see that is

00:11:45,160 --> 00:11:52,060
multi-threaded and v8 is single threaded

00:11:47,970 --> 00:11:54,820
so this code should effectively do the

00:11:52,060 --> 00:11:57,220
very same hello world example that we

00:11:54,820 --> 00:12:00,190
have done previously in purely non je s

00:11:57,220 --> 00:12:02,440
basically the URL query parameter name

00:12:00,190 --> 00:12:06,579
of zero is going to be first propagated

00:12:02,440 --> 00:12:08,440
into that context object in not Jes from

00:12:06,579 --> 00:12:12,730
there it is going to be propagated to

00:12:08,440 --> 00:12:15,220
the JavaScript function which wraps the

00:12:12,730 --> 00:12:17,649
sea shop is in lambda expression from

00:12:15,220 --> 00:12:20,560
there hjs will actually propagate it

00:12:17,649 --> 00:12:22,660
into the dynamic context parameter to

00:12:20,560 --> 00:12:26,019
that acing lambda expression and c-sharp

00:12:22,660 --> 00:12:33,399
will generate a response let's send it

00:12:26,019 --> 00:12:35,199
over to Brazil hello world 0 just to

00:12:33,399 --> 00:12:39,699
make sure that we have the entire

00:12:35,199 --> 00:12:41,560
pipeline covered the fool and here comes

00:12:39,699 --> 00:12:43,060
the phone so the interesting thing you

00:12:41,560 --> 00:12:44,649
know you know you notice it was actually

00:12:43,060 --> 00:12:47,019
pretty fast so what happened here is we

00:12:44,649 --> 00:12:49,899
sent a JavaScript code with embedded c

00:12:47,019 --> 00:12:51,910
sharp code to brazil the sandbox took

00:12:49,899 --> 00:12:53,680
this thing extracted the seashore code

00:12:51,910 --> 00:12:56,110
compiled it on the fly into an in-memory

00:12:53,680 --> 00:12:57,639
assembly marshal the request in to c

00:12:56,110 --> 00:12:59,589
sharp C sharp generated the response

00:12:57,639 --> 00:13:04,230
JavaScript serialize it into Jason and

00:12:59,589 --> 00:13:04,230
send back to us so that was pretty quick

00:13:06,839 --> 00:13:11,500
so with that let's move into something

00:13:09,310 --> 00:13:13,750
slightly more complex and let's see how

00:13:11,500 --> 00:13:15,459
that sandbox preventing the different

00:13:13,750 --> 00:13:16,959
provides the different isolation Gavitt

00:13:15,459 --> 00:13:18,430
guarantees that I've been talking about

00:13:16,959 --> 00:13:21,550
and also prevents different kinds of

00:13:18,430 --> 00:13:23,290
attacks so what you see here is a code

00:13:21,550 --> 00:13:26,459
that we are going to be executing on

00:13:23,290 --> 00:13:26,459
behalf of two different tenants

00:13:26,670 --> 00:13:31,390
sequentially what this code does it

00:13:29,050 --> 00:13:34,570
first it looks if there is a secret

00:13:31,390 --> 00:13:36,520
property in the global namespace of what

00:13:34,570 --> 00:13:39,010
whatever context that code executes

00:13:36,520 --> 00:13:40,899
saying if there is no secret object a

00:13:39,010 --> 00:13:43,720
one will be created using math.random

00:13:40,899 --> 00:13:45,490
and you know the second time you execute

00:13:43,720 --> 00:13:48,640
that code the secret will already exist

00:13:45,490 --> 00:13:50,950
so it will remain unchanged and then the

00:13:48,640 --> 00:13:52,870
function that we are returning from the

00:13:50,950 --> 00:13:55,750
snow dress code simply turns around and

00:13:52,870 --> 00:13:58,959
returns the global secret so let's run

00:13:55,750 --> 00:14:02,920
it on behalf of 10 and full in some Sao

00:13:58,959 --> 00:14:04,959
Paulo so the first time we done it the

00:14:02,920 --> 00:14:07,890
secret will be generated and will be

00:14:04,959 --> 00:14:11,080
returned to to us and that secret is

00:14:07,890 --> 00:14:13,570
0.56 to something something next time

00:14:11,080 --> 00:14:15,310
you call it the secret is the same but

00:14:13,570 --> 00:14:23,440
now if i go ahead and I change the

00:14:15,310 --> 00:14:24,390
tenant named here to full 10 and 1 i'll

00:14:23,440 --> 00:14:27,960
get an oosik

00:14:24,390 --> 00:14:32,160
generated 0.35 if I call tenant one

00:14:27,960 --> 00:14:35,430
again I will again get zero 3.5 but if i

00:14:32,160 --> 00:14:36,510
go back to tenant I'll get back the old

00:14:35,430 --> 00:14:40,080
secret so this is just a demonstration

00:14:36,510 --> 00:14:41,790
that the data context in which the

00:14:40,080 --> 00:14:44,670
requests on behalf of different tenants

00:14:41,790 --> 00:14:51,600
execute is different so tenants do not

00:14:44,670 --> 00:14:53,199
have access to their data let's have a

00:14:51,600 --> 00:14:55,899
look

00:14:53,199 --> 00:14:58,879
my favorite kind of attack on nodejs

00:14:55,899 --> 00:15:01,009
very elaborate that I can CPU we are

00:14:58,879 --> 00:15:03,800
basically going to run an infinite loop

00:15:01,009 --> 00:15:06,620
while true so what this does in Dantes

00:15:03,800 --> 00:15:09,170
it blocks the event loop the event loop

00:15:06,620 --> 00:15:12,050
can process any any more requests but

00:15:09,170 --> 00:15:15,800
the basic premise of our sandbox is that

00:15:12,050 --> 00:15:17,389
it is fine to do so as long as it

00:15:15,800 --> 00:15:20,329
doesn't prevent other tenants from

00:15:17,389 --> 00:15:22,490
executing code in the sandbox if you are

00:15:20,329 --> 00:15:24,230
writing bad cold it is okay if you

00:15:22,490 --> 00:15:25,959
should you yourself in the food but you

00:15:24,230 --> 00:15:29,779
shouldn't be able to affect how others

00:15:25,959 --> 00:15:31,819
execute code so let's let's take a guy

00:15:29,779 --> 00:15:34,040
who's actually in who actually knows how

00:15:31,819 --> 00:15:38,019
to write good code and he will be

00:15:34,040 --> 00:15:40,850
issuing request request to the sandbox

00:15:38,019 --> 00:15:42,560
thousand requests sequentially will

00:15:40,850 --> 00:15:44,720
basically be responding with hello one

00:15:42,560 --> 00:15:47,689
two three and so on and now I'm going to

00:15:44,720 --> 00:15:50,569
run the bed code in the same sandbox and

00:15:47,689 --> 00:15:51,980
see if it affects the behavior of the

00:15:50,569 --> 00:15:55,009
first tenant which is running the

00:15:51,980 --> 00:15:57,019
well-behaved code so I'm not going to

00:15:55,009 --> 00:15:59,899
take that wire through code that the

00:15:57,019 --> 00:16:04,480
loop you are seeing here and I'm going

00:15:59,899 --> 00:16:04,480
to run it from this console the Derby

00:16:04,720 --> 00:16:11,509
the first of all take a moment is what

00:16:09,620 --> 00:16:13,399
happens here is that we are starting to

00:16:11,509 --> 00:16:16,040
execute the JavaScript code that does

00:16:13,399 --> 00:16:17,870
the infinite loop and before our system

00:16:16,040 --> 00:16:19,189
realizes that the event loop is blocked

00:16:17,870 --> 00:16:21,290
it is like two seconds it is a

00:16:19,189 --> 00:16:24,529
configurable time period but eventually

00:16:21,290 --> 00:16:26,300
the our sandbox realizes okay this this

00:16:24,529 --> 00:16:29,540
process is gone so we are going to

00:16:26,300 --> 00:16:31,699
terminate it this results in that tenant

00:16:29,540 --> 00:16:34,579
who wrote the bed code getting an HTTP

00:16:31,699 --> 00:16:37,100
500 back but you'll notice that the code

00:16:34,579 --> 00:16:38,540
who wrote the word written code is

00:16:37,100 --> 00:16:42,430
running just fine so he remained

00:16:38,540 --> 00:16:47,290
unaffected by the attempted CPU attack

00:16:42,430 --> 00:16:50,750
to keep that well-behaved 10 and going

00:16:47,290 --> 00:16:52,759
and we will do another kind of attack on

00:16:50,750 --> 00:16:55,639
memory this time so here we have a

00:16:52,759 --> 00:16:57,439
string evil and you are going to run a

00:16:55,639 --> 00:16:59,540
very tight loop which basically doubles

00:16:57,439 --> 00:17:00,860
the size of evil so eventually after a

00:16:59,540 --> 00:17:04,549
few iterations we are going to run out

00:17:00,860 --> 00:17:05,510
of memory so let's run this thing in the

00:17:04,549 --> 00:17:10,040
same sandbox

00:17:05,510 --> 00:17:11,780
as the tenant running the well executing

00:17:10,040 --> 00:17:15,199
code so you'll notice that we got HTT if

00:17:11,780 --> 00:17:17,180
I found it much faster however the the

00:17:15,199 --> 00:17:20,540
tenant that is well behaved was

00:17:17,180 --> 00:17:22,970
unaffected again and the last kind of

00:17:20,540 --> 00:17:26,360
attack is a traditional fork bomb so we

00:17:22,970 --> 00:17:29,270
are going to use spawn to basically keep

00:17:26,360 --> 00:17:30,800
creating note processes child node

00:17:29,270 --> 00:17:32,510
processes they're not processes are not

00:17:30,800 --> 00:17:34,580
doing much but it is that is beside the

00:17:32,510 --> 00:17:36,320
point the idea is that you know we are

00:17:34,580 --> 00:17:40,460
trying to create a billion processes on

00:17:36,320 --> 00:17:41,960
that machine and see that well behave

00:17:40,460 --> 00:17:57,470
tonight is affected so let's do this

00:17:41,960 --> 00:17:58,700
again I will take a moment until it is

00:17:57,470 --> 00:18:00,890
it should be 500

00:17:58,700 --> 00:18:02,630
and the world we hit tennis continues

00:18:00,890 --> 00:18:05,990
running just fine so this just

00:18:02,630 --> 00:18:07,610
demonstrated some very basic send boxing

00:18:05,990 --> 00:18:09,860
capabilities of the technology that

00:18:07,610 --> 00:18:11,720
we've created one last thing I really

00:18:09,860 --> 00:18:14,780
want to talk about in this presentation

00:18:11,720 --> 00:18:20,330
is logging because that in itself is

00:18:14,780 --> 00:18:22,160
very interesting logging is a very basic

00:18:20,330 --> 00:18:23,750
diagnostic mechanism that is very

00:18:22,160 --> 00:18:27,080
frequently used in node in a distributed

00:18:23,750 --> 00:18:29,540
system like that it is interesting how

00:18:27,080 --> 00:18:30,770
to structure a collection of logs such

00:18:29,540 --> 00:18:32,510
as it is actually usable to the

00:18:30,770 --> 00:18:35,180
developer and other systems that consume

00:18:32,510 --> 00:18:37,310
them so what we are doing here is we are

00:18:35,180 --> 00:18:38,810
normalizing logs generated by all

00:18:37,310 --> 00:18:41,480
components in the system both the

00:18:38,810 --> 00:18:42,830
sandbox the proxy and the user code

00:18:41,480 --> 00:18:46,190
using anything you write using

00:18:42,830 --> 00:18:47,960
console.log now into Bunyan first such

00:18:46,190 --> 00:18:50,150
that we have structured Jason locks then

00:18:47,960 --> 00:18:52,460
we put those logs into Kafka we have a

00:18:50,150 --> 00:18:55,160
Kafka cluster deployed across the car OS

00:18:52,460 --> 00:18:56,660
cluster Kafka SMS messaging server that

00:18:55,160 --> 00:18:59,360
is highly optimized for logging

00:18:56,660 --> 00:19:03,890
scenarios and then we expose the logs

00:18:59,360 --> 00:19:05,720
over HTTP so let's take it for a spin

00:19:03,890 --> 00:19:07,520
again so what i'm doing here is

00:19:05,720 --> 00:19:10,300
basically writing a single simple

00:19:07,520 --> 00:19:14,750
function that the calls console.log ones

00:19:10,300 --> 00:19:17,150
first I'm going to attach my streaming

00:19:14,750 --> 00:19:21,080
logging endpoint that exposes the locks

00:19:17,150 --> 00:19:23,150
from Kafka and I'm filtering Lee let me

00:19:21,080 --> 00:19:25,400
actually filter the output through

00:19:23,150 --> 00:19:28,310
Bunyan so that we get pretty printing

00:19:25,400 --> 00:19:33,160
and then I'm going to invoke this code

00:19:28,310 --> 00:19:33,160
that actually perform some some logging

00:19:34,510 --> 00:19:40,660
here it is

00:19:36,250 --> 00:19:46,450
all returned Monte is 0 10 30 which is

00:19:40,660 --> 00:19:48,070
what this code did but you also notice

00:19:46,450 --> 00:19:53,230
that there is a console.log statement

00:19:48,070 --> 00:19:56,320
and that console log showed up here if I

00:19:53,230 --> 00:19:58,990
run it again it will basically get a new

00:19:56,320 --> 00:20:00,940
entry here down here so this gives you a

00:19:58,990 --> 00:20:02,980
streaming logging capability real time

00:20:00,940 --> 00:20:05,830
access to logs generated by the sandbox

00:20:02,980 --> 00:20:13,900
code and you can post process it in

00:20:05,830 --> 00:20:16,420
whatever way you want so this is this is

00:20:13,900 --> 00:20:19,210
what we have built we are kind of we

00:20:16,420 --> 00:20:21,400
built it primarily with a scenario in

00:20:19,210 --> 00:20:23,590
mind of enabling our customers to run

00:20:21,400 --> 00:20:25,690
custom code on a platform but once we

00:20:23,590 --> 00:20:27,970
build it we are actually started

00:20:25,690 --> 00:20:29,710
noticing certain scenarios and patterns

00:20:27,970 --> 00:20:31,750
where the sandbox is very very usable

00:20:29,710 --> 00:20:33,430
for example we've built our entire

00:20:31,750 --> 00:20:35,080
health monitoring system around the

00:20:33,430 --> 00:20:36,700
system we have these eight sandboxes

00:20:35,080 --> 00:20:38,350
deployed around the world and every 30

00:20:36,700 --> 00:20:40,870
seconds they are basically executing a

00:20:38,350 --> 00:20:42,940
bunch of tests not just HTTP test but

00:20:40,870 --> 00:20:46,000
you know you can contact you can

00:20:42,940 --> 00:20:47,470
do anything you can do with no Jas in

00:20:46,000 --> 00:20:49,060
those sand boxes around the world and

00:20:47,470 --> 00:20:51,220
they are then consolidating results

00:20:49,060 --> 00:20:53,950
across the world but such a technology

00:20:51,220 --> 00:20:56,020
really we think the sweet spot it is

00:20:53,950 --> 00:20:59,890
targeting multi-tenant systems or things

00:20:56,020 --> 00:21:02,560
like if this than that things like

00:20:59,890 --> 00:21:04,420
custom web hooks for example so the

00:21:02,560 --> 00:21:09,240
possibilities are really quite quite

00:21:04,420 --> 00:21:09,240

YouTube URL: https://www.youtube.com/watch?v=u81pS05W1JY


