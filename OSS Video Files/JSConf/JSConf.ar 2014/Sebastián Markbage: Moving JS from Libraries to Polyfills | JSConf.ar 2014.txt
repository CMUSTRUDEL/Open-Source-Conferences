Title: SebastiÃ¡n Markbage: Moving JS from Libraries to Polyfills | JSConf.ar 2014
Publication date: 2015-05-10
Playlist: JSConf.ar 2014
Description: 
	Iâ€™ll explain how React is moving towards a minimal API surface area. Instead of providing many framework features, React is trying to utilize patterns, paradigms and JavaScript language features to accomplish the same tasks that other frameworks have dedicated APIs for. Not all environments have these natively. We need to polyfill new an experimental features. How can we safely do that? Is it better to have a non-standard library?

https://www.jsconfar.com/
Captions: 
	00:00:08,809 --> 00:00:24,790
thank you I'm sure it's fine

00:00:20,350 --> 00:00:27,670
I like to start off with a question is

00:00:24,790 --> 00:00:30,340
does anyone have a favorite utility

00:00:27,670 --> 00:00:36,030
library like low dash or jQuery or

00:00:30,340 --> 00:00:44,890
something like that we use this lodash

00:00:36,030 --> 00:00:46,480
underscore knockout that's cool is it

00:00:44,890 --> 00:00:48,129
great that we have this community that

00:00:46,480 --> 00:00:50,290
we can use all these different features

00:00:48,129 --> 00:00:52,239
and different libraries we want to and

00:00:50,290 --> 00:00:54,760
nobody can tell us that we can't do it

00:00:52,239 --> 00:00:58,720
and there's like no single company that

00:00:54,760 --> 00:01:01,150
controls our community except do we

00:00:58,720 --> 00:01:04,510
really need this many ways to iterate

00:01:01,150 --> 00:01:05,950
over an ordinary do you even know all

00:01:04,510 --> 00:01:09,010
the ways to filter in the array and

00:01:05,950 --> 00:01:10,810
underscore is it the same exact version

00:01:09,010 --> 00:01:11,830
in lodash or is it I think it's slightly

00:01:10,810 --> 00:01:15,600
different depending on which version

00:01:11,830 --> 00:01:18,270
you're using do you even know all the

00:01:15,600 --> 00:01:22,540
JavaScript standard library functions

00:01:18,270 --> 00:01:23,860
what about the ones in he is six I don't

00:01:22,540 --> 00:01:27,100
think Brendan even knows all that wants

00:01:23,860 --> 00:01:30,070
to make six pretty sure let alone all

00:01:27,100 --> 00:01:33,340
the libraries on top of it it's not that

00:01:30,070 --> 00:01:36,009
a library is too big it's pretty cool

00:01:33,340 --> 00:01:38,590
every library is pretty cool it is it

00:01:36,009 --> 00:01:39,939
has a nice feature size extensions the

00:01:38,590 --> 00:01:42,039
problem is that we have a lot of them

00:01:39,939 --> 00:01:44,619
and each one has a lot of different

00:01:42,039 --> 00:01:46,539
functions and a total amount of AP is

00:01:44,619 --> 00:01:49,270
that you have to learn to be productive

00:01:46,539 --> 00:01:52,030
in this industry is huge it's way too

00:01:49,270 --> 00:01:54,070
much to learn so what happens when you

00:01:52,030 --> 00:01:57,039
get a new team member coming out to your

00:01:54,070 --> 00:01:59,100
team how many special utility calls to

00:01:57,039 --> 00:02:01,899
be able to find in your code base and

00:01:59,100 --> 00:02:03,429
how much ramp up time didn't need to

00:02:01,899 --> 00:02:08,320
figure out what's actually going on

00:02:03,429 --> 00:02:10,929
there so why do we actually use

00:02:08,320 --> 00:02:13,980
javascript to begin with it's not the

00:02:10,929 --> 00:02:16,030
best language in the world there's

00:02:13,980 --> 00:02:18,130
regardless of what style you prefer

00:02:16,030 --> 00:02:20,790
there's at least one language that's

00:02:18,130 --> 00:02:26,500
better that can compile to JavaScript

00:02:20,790 --> 00:02:28,960
except javascript is everywhere this is

00:02:26,500 --> 00:02:30,340
why we're using it it's at least

00:02:28,960 --> 00:02:31,560
something that a lot of people could

00:02:30,340 --> 00:02:33,810
agree on

00:02:31,560 --> 00:02:37,470
an art industry needs a baseline to

00:02:33,810 --> 00:02:38,940
build on top so javascript is one of

00:02:37,470 --> 00:02:41,910
those bass lines so we can build on top

00:02:38,940 --> 00:02:43,860
of and using a standard comes with a lot

00:02:41,910 --> 00:02:46,890
of benefits the right information is

00:02:43,860 --> 00:02:50,940
accessible tooling people to hire and so

00:02:46,890 --> 00:02:52,800
on so by introducing divergence in the

00:02:50,940 --> 00:02:55,670
library community we're actually

00:02:52,800 --> 00:02:58,170
undermining what makes JavaScript great

00:02:55,670 --> 00:03:00,390
we're already created in environments

00:02:58,170 --> 00:03:02,400
where you can't hire a JavaScript

00:03:00,390 --> 00:03:04,680
generalist anymore you have to hire a

00:03:02,400 --> 00:03:08,670
JavaScript specialist and a specific

00:03:04,680 --> 00:03:12,750
library at Facebook we have a very

00:03:08,670 --> 00:03:14,819
simple story we use JavaScript standard

00:03:12,750 --> 00:03:17,430
library there's one way to do things and

00:03:14,819 --> 00:03:19,380
it's the standard way they don't have an

00:03:17,430 --> 00:03:21,540
underscore we don't have utility

00:03:19,380 --> 00:03:24,390
libraries and avoids a very simple

00:03:21,540 --> 00:03:27,180
problem bike shedding it's the biggest

00:03:24,390 --> 00:03:28,650
waste of time of all we still have to do

00:03:27,180 --> 00:03:30,480
that but we keep that to the standards

00:03:28,650 --> 00:03:31,860
mailing lists and most of it is

00:03:30,480 --> 00:03:34,440
arbitrary anyways it doesn't really

00:03:31,860 --> 00:03:37,250
matter that much so why is the industry

00:03:34,440 --> 00:03:40,650
still using so many JavaScript libraries

00:03:37,250 --> 00:03:42,750
well this standard library is pretty

00:03:40,650 --> 00:03:46,079
small and it doesn't have all the

00:03:42,750 --> 00:03:48,720
features that you may want but many

00:03:46,079 --> 00:03:51,900
times the answer is just write a little

00:03:48,720 --> 00:03:53,850
bit more boilerplate code it takes you a

00:03:51,900 --> 00:03:56,459
few seconds longer you don't take on a

00:03:53,850 --> 00:03:59,370
dependency the person coming to fix your

00:03:56,459 --> 00:04:01,829
code later after your left or if they're

00:03:59,370 --> 00:04:03,810
busy in a meeting they don't have to

00:04:01,829 --> 00:04:05,430
learn some obscure functions or twenty

00:04:03,810 --> 00:04:07,470
other versions of the same functions

00:04:05,430 --> 00:04:11,480
that someone else bought was slightly

00:04:07,470 --> 00:04:14,010
better than this one one of the best

00:04:11,480 --> 00:04:16,410
lessons that I've learned that Facebook

00:04:14,010 --> 00:04:19,459
is that no abstraction can actually be

00:04:16,410 --> 00:04:21,600
better than a prong extraction and

00:04:19,459 --> 00:04:23,039
especially since abstractions build on

00:04:21,600 --> 00:04:28,610
top of each other they're difficult to

00:04:23,039 --> 00:04:32,340
unwind so proving that a general

00:04:28,610 --> 00:04:34,260
abstraction is worthwhile can actually

00:04:32,340 --> 00:04:36,270
be quite difficult and teaching it to in

00:04:34,260 --> 00:04:39,810
our entire industry is even more

00:04:36,270 --> 00:04:41,729
difficult it takes time and this is

00:04:39,810 --> 00:04:44,400
where the reason why standards are slow

00:04:41,729 --> 00:04:45,280
you may want JavaScript to copy feature

00:04:44,400 --> 00:04:47,380
from

00:04:45,280 --> 00:04:49,090
language but once you look at a lot of

00:04:47,380 --> 00:04:51,250
different languages is not really clear

00:04:49,090 --> 00:04:52,810
which one is the best one now you have

00:04:51,250 --> 00:04:55,540
to figure out which one is the best one

00:04:52,810 --> 00:04:57,370
because picking the wrong one is highly

00:04:55,540 --> 00:05:02,200
risky because our entire industry will

00:04:57,370 --> 00:05:04,990
have to figure that out but there are

00:05:02,200 --> 00:05:06,580
some features to a language that are

00:05:04,990 --> 00:05:08,530
really powerful and we really need them

00:05:06,580 --> 00:05:12,639
and we really need them as soon as

00:05:08,530 --> 00:05:15,010
possible the problem is that even after

00:05:12,639 --> 00:05:17,530
there's agreement on the value of this

00:05:15,010 --> 00:05:19,690
specific feature there's still a long

00:05:17,530 --> 00:05:22,090
process before it's actually implemented

00:05:19,690 --> 00:05:24,780
in browsers so this is proposal their

00:05:22,090 --> 00:05:27,070
standardization initial implementation

00:05:24,780 --> 00:05:32,080
mainstream browser support and then the

00:05:27,070 --> 00:05:34,360
long tail of browsers right and once the

00:05:32,080 --> 00:05:36,729
browser implements it it's too late to

00:05:34,360 --> 00:05:38,020
take it back so engines actually

00:05:36,729 --> 00:05:40,510
optimize for correctness and

00:05:38,020 --> 00:05:44,110
compatibility before speed performance

00:05:40,510 --> 00:05:46,120
or early implementations that's why the

00:05:44,110 --> 00:05:49,060
employability looks like this because

00:05:46,120 --> 00:05:52,780
for browsers is way too risky to

00:05:49,060 --> 00:05:54,310
implement something way too early but

00:05:52,780 --> 00:05:57,280
that's not really what adoption curve

00:05:54,310 --> 00:06:01,539
looks like because third party libraries

00:05:57,280 --> 00:06:03,010
don't have this restriction they get

00:06:01,539 --> 00:06:05,860
adopted before the standards in the

00:06:03,010 --> 00:06:07,450
provoke post the industry has already

00:06:05,860 --> 00:06:12,430
learned them by the time there is a

00:06:07,450 --> 00:06:16,710
standard and at the end of the curve we

00:06:12,430 --> 00:06:20,050
have support for new language features

00:06:16,710 --> 00:06:23,410
but by the time the new language feature

00:06:20,050 --> 00:06:25,180
occurs and it's available there's

00:06:23,410 --> 00:06:26,560
already ten libraries that have the same

00:06:25,180 --> 00:06:29,110
feature and now you have to learn to

00:06:26,560 --> 00:06:31,330
those ten libraries plus another

00:06:29,110 --> 00:06:32,590
language feature this is the point when

00:06:31,330 --> 00:06:34,780
people are starting to have a strong

00:06:32,590 --> 00:06:36,160
reaction against standards because they

00:06:34,780 --> 00:06:39,190
already have the feature they already

00:06:36,160 --> 00:06:42,340
have the possibility to do this and I

00:06:39,190 --> 00:06:45,190
don't want to learn at one more thing at

00:06:42,340 --> 00:06:48,070
Facebook it looks something like this we

00:06:45,190 --> 00:06:50,050
use small experimental libraries we roll

00:06:48,070 --> 00:06:53,470
it up slowly unless you really need it

00:06:50,050 --> 00:06:55,960
you're not going to use it too much and

00:06:53,470 --> 00:06:57,950
when there's a standard proposal we

00:06:55,960 --> 00:07:00,810
quickly roll off our

00:06:57,950 --> 00:07:03,060
experimental libraries and use polyfills

00:07:00,810 --> 00:07:07,110
instead even before the standard is

00:07:03,060 --> 00:07:09,540
filing so most developers won't actually

00:07:07,110 --> 00:07:11,790
see these ten different things of doing

00:07:09,540 --> 00:07:15,720
things they will jump straight on to the

00:07:11,790 --> 00:07:17,160
standards version and I'd like to see

00:07:15,720 --> 00:07:20,670
this happening more in our industry as a

00:07:17,160 --> 00:07:23,820
whole so why aren't you all using just

00:07:20,670 --> 00:07:26,360
poly feels so it's not that easy

00:07:23,820 --> 00:07:29,070
actually there's a few problems with it

00:07:26,360 --> 00:07:30,540
the primary problem of adopting too

00:07:29,070 --> 00:07:34,320
early is that the standards actually

00:07:30,540 --> 00:07:36,870
change a lot during the process and poly

00:07:34,320 --> 00:07:40,830
fills was differed slightly in various

00:07:36,870 --> 00:07:42,540
ways libraries have these problems as

00:07:40,830 --> 00:07:45,780
well within consistencies between

00:07:42,540 --> 00:07:49,320
versions so often you'll never never

00:07:45,780 --> 00:07:51,480
actually noticed this but it does become

00:07:49,320 --> 00:07:54,840
a problem when you have a third party

00:07:51,480 --> 00:07:56,790
code that depend on the changing

00:07:54,840 --> 00:08:00,780
standard and the various versions of

00:07:56,790 --> 00:08:03,420
polyfills and one of the reasons this is

00:08:00,780 --> 00:08:05,340
a problem is because most built-ins are

00:08:03,420 --> 00:08:08,160
only global object or in the prototype

00:08:05,340 --> 00:08:09,690
you can only have really realistically

00:08:08,160 --> 00:08:12,330
you can only really have one version at

00:08:09,690 --> 00:08:13,890
a time and different libraries may

00:08:12,330 --> 00:08:16,710
depend on different edge cases that

00:08:13,890 --> 00:08:18,420
can't be used together so if they go

00:08:16,710 --> 00:08:19,920
unfixed for a long time which they

00:08:18,420 --> 00:08:22,590
actually do unfortunately a lot of

00:08:19,920 --> 00:08:25,260
polyfills more and more code starts

00:08:22,590 --> 00:08:28,710
relying on a particular version of a

00:08:25,260 --> 00:08:30,300
polyfill so it's very important for its

00:08:28,710 --> 00:08:31,920
Paula feels to stay up to date but also

00:08:30,300 --> 00:08:34,260
the code that uses them to stay up to

00:08:31,920 --> 00:08:35,670
date but you can package multiple

00:08:34,260 --> 00:08:38,130
versions the Varden scores with your

00:08:35,670 --> 00:08:40,490
apps it's not ideal but you can it's

00:08:38,130 --> 00:08:44,130
much more difficult with a polyfill

00:08:40,490 --> 00:08:48,320
another issue which is similar to the

00:08:44,130 --> 00:08:50,670
one which brought up earlier is that

00:08:48,320 --> 00:08:52,200
some people like to discourage polyfills

00:08:50,670 --> 00:08:56,430
because they might actually break the

00:08:52,200 --> 00:09:00,960
spec and i'll explain what happened with

00:08:56,430 --> 00:09:03,450
string contains so this was another era

00:09:00,960 --> 00:09:07,650
long before es5 in the new wave of

00:09:03,450 --> 00:09:08,700
standards it was before Guillermo had

00:09:07,650 --> 00:09:11,940
facial hair

00:09:08,700 --> 00:09:14,850
where are you so gear when I was working

00:09:11,940 --> 00:09:17,700
on a framework called mootools at the

00:09:14,850 --> 00:09:19,650
time so muches was extending the

00:09:17,700 --> 00:09:23,570
building prototypes with some extra

00:09:19,650 --> 00:09:26,790
helper functions and we did it this way

00:09:23,570 --> 00:09:28,710
we checked if there was at existing

00:09:26,790 --> 00:09:31,860
function and if there wasn't we

00:09:28,710 --> 00:09:34,110
introduced our own one so what happens

00:09:31,860 --> 00:09:39,390
when the browser's try to implement this

00:09:34,110 --> 00:09:42,570
feature the new version comes in and it

00:09:39,390 --> 00:09:44,580
replaces the Muto's version which means

00:09:42,570 --> 00:09:49,260
that the website that relies on the

00:09:44,580 --> 00:09:52,740
Muto's behavior breaks so luckily we're

00:09:49,260 --> 00:09:56,460
learned our lesson with mootools 1.3 so

00:09:52,740 --> 00:09:58,770
instead of overriding them conditionally

00:09:56,460 --> 00:10:04,260
we unconditionally override any built-in

00:09:58,770 --> 00:10:07,290
version except the built-in version has

00:10:04,260 --> 00:10:08,880
a new mobility flag set to false which

00:10:07,290 --> 00:10:12,510
means that you can't loop over the

00:10:08,880 --> 00:10:16,190
property to find it so what happens with

00:10:12,510 --> 00:10:18,660
a second statement it no longer copies

00:10:16,190 --> 00:10:21,060
the object if the browser ever

00:10:18,660 --> 00:10:24,570
implements this feature so this is

00:10:21,060 --> 00:10:28,050
actually the reason why the browsers

00:10:24,570 --> 00:10:31,890
refuse to implement this so they're both

00:10:28,050 --> 00:10:33,690
fixed in newer versions of mootools but

00:10:31,890 --> 00:10:36,150
mucosal is a popular library back then

00:10:33,690 --> 00:10:39,090
and a lot of websites have deployed this

00:10:36,150 --> 00:10:42,660
version so we I guess we could just

00:10:39,090 --> 00:10:44,070
break them except nobody is working on

00:10:42,660 --> 00:10:46,470
them anymore there's no consultants

00:10:44,070 --> 00:10:49,440
working on these websites so if a

00:10:46,470 --> 00:10:53,070
browser introduces this feature it will

00:10:49,440 --> 00:10:55,740
break the website and people will start

00:10:53,070 --> 00:10:58,020
using another browser so whoever browser

00:10:55,740 --> 00:11:00,540
is the first one it's going to lose out

00:10:58,020 --> 00:11:02,430
and this is the classic browser game

00:11:00,540 --> 00:11:04,020
theory problem no browser wants to be

00:11:02,430 --> 00:11:09,930
the first one because they will lose

00:11:04,020 --> 00:11:12,990
customers so this is why a bad polyfill

00:11:09,930 --> 00:11:15,690
could potentially risk breaking the web

00:11:12,990 --> 00:11:19,370
and actually breaking the future

00:11:15,690 --> 00:11:19,370
standards that are trying to polyfill

00:11:20,430 --> 00:11:27,430
however this is not just a problem with

00:11:23,199 --> 00:11:30,430
coded mutates the prototype I've found

00:11:27,430 --> 00:11:33,519
this this we can react we actually check

00:11:30,430 --> 00:11:38,170
that the string object doesn't have a

00:11:33,519 --> 00:11:39,699
key property so if a browser ever

00:11:38,170 --> 00:11:42,189
implements the key property on the

00:11:39,699 --> 00:11:47,339
string they might break old versions of

00:11:42,189 --> 00:11:49,149
react and I picked two examples from

00:11:47,339 --> 00:11:51,550
libraries that I've been involved with

00:11:49,149 --> 00:11:53,499
but I'm not the only one doing this only

00:11:51,550 --> 00:11:56,589
one screwing up this is pretty easy

00:11:53,499 --> 00:11:58,990
mistakes to make but as you can see it's

00:11:56,589 --> 00:12:02,379
not just if you try to change prototypes

00:11:58,990 --> 00:12:04,749
it happens in libraries all the time and

00:12:02,379 --> 00:12:07,059
we just renamed pertains to includes

00:12:04,749 --> 00:12:08,790
it's not a big deal our suspects will

00:12:07,059 --> 00:12:12,399
have to find a way to work around this

00:12:08,790 --> 00:12:18,999
it's not a reason to not to you to avoid

00:12:12,399 --> 00:12:20,589
using polyfills there's a common

00:12:18,999 --> 00:12:23,170
misunderstanding that native functions

00:12:20,589 --> 00:12:25,740
are always faster than the polyfills or

00:12:23,170 --> 00:12:30,220
library features that's not true so

00:12:25,740 --> 00:12:33,399
naive polyfills tend to use the native

00:12:30,220 --> 00:12:34,750
implementation if it's available but

00:12:33,399 --> 00:12:37,240
then you can end up with the same

00:12:34,750 --> 00:12:42,459
problem that Muto's did right if the

00:12:37,240 --> 00:12:44,769
spec actually changes then people using

00:12:42,459 --> 00:12:49,689
your polyfill might actually break this

00:12:44,769 --> 00:12:51,250
back and additionally early

00:12:49,689 --> 00:12:53,649
implementations are often really very

00:12:51,250 --> 00:12:55,120
slow they're not optimized for speed yet

00:12:53,649 --> 00:12:57,129
they're optimized for correctness

00:12:55,120 --> 00:12:59,110
because it's high risk for a browser to

00:12:57,129 --> 00:13:04,959
introducing a feature so you have to

00:12:59,110 --> 00:13:06,970
make it correct so the solution is to

00:13:04,959 --> 00:13:10,179
simply just always override the native

00:13:06,970 --> 00:13:13,259
implementation until way into the long

00:13:10,179 --> 00:13:13,259
tail of browser support

00:13:19,080 --> 00:13:26,050
so for new syntax is general solution is

00:13:23,050 --> 00:13:28,660
to compile your modern code down to an

00:13:26,050 --> 00:13:31,000
older version you're not modifying the

00:13:28,660 --> 00:13:34,270
runtime so you don't really suffer from

00:13:31,000 --> 00:13:37,120
the same versioning problem and you can

00:13:34,270 --> 00:13:42,370
ship different versions of pre compiled

00:13:37,120 --> 00:13:44,770
code however transpiring tools I mean

00:13:42,370 --> 00:13:46,470
they're great they're they're efficient

00:13:44,770 --> 00:13:49,660
than the this setup is fairly easy

00:13:46,470 --> 00:13:52,090
however people have a very strong

00:13:49,660 --> 00:13:55,960
reaction to that extra compilation step

00:13:52,090 --> 00:13:57,100
people don't like compilation for

00:13:55,960 --> 00:13:59,080
production it doesn't really matter that

00:13:57,100 --> 00:14:01,750
much to be honest like you have a mini

00:13:59,080 --> 00:14:04,780
fire in packager anyway so plugging in a

00:14:01,750 --> 00:14:06,340
compiler in your pipeline isn't that big

00:14:04,780 --> 00:14:07,690
of deal if it's fast enough and the

00:14:06,340 --> 00:14:10,840
Facebook we're working very hard on

00:14:07,690 --> 00:14:12,550
making these tools fast enough however

00:14:10,840 --> 00:14:14,680
looking at the long tail of the jse

00:14:12,550 --> 00:14:17,650
ecosystem support for new language

00:14:14,680 --> 00:14:19,270
features is actually pretty bad but this

00:14:17,650 --> 00:14:21,730
is strictly a tooling problem that we

00:14:19,270 --> 00:14:23,380
can solve if you use the well supported

00:14:21,730 --> 00:14:25,990
and frequently updated parser than

00:14:23,380 --> 00:14:29,350
linters will work with that and what

00:14:25,990 --> 00:14:32,290
happens is that these tools tend to die

00:14:29,350 --> 00:14:34,150
off when they don't support the new

00:14:32,290 --> 00:14:41,350
features they get replaced by other ones

00:14:34,150 --> 00:14:44,170
anyway and compilation isn't really an

00:14:41,350 --> 00:14:48,940
inherence problem to to this transpire

00:14:44,170 --> 00:14:51,430
situation browsers could have

00:14:48,940 --> 00:14:53,080
first-class support for trailers or you

00:14:51,430 --> 00:14:55,660
can make it browser extension to do it

00:14:53,080 --> 00:14:57,160
or you can make a operating system

00:14:55,660 --> 00:15:01,110
extension that makes it easy to just

00:14:57,160 --> 00:15:01,110
open any file and have a chance pilot

00:15:01,230 --> 00:15:06,550
completion happens anyway in the browser

00:15:03,280 --> 00:15:09,700
it it happens within the runtime on the

00:15:06,550 --> 00:15:12,640
fly so why shouldn't be able to do that

00:15:09,700 --> 00:15:16,180
on the fly with a client side to a

00:15:12,640 --> 00:15:18,040
spider as well one problem with the

00:15:16,180 --> 00:15:20,200
currents which is that there's way too

00:15:18,040 --> 00:15:22,260
many options out there having too many

00:15:20,200 --> 00:15:24,550
options can actually be a bad thing

00:15:22,260 --> 00:15:26,830
getting the polo fields right it's very

00:15:24,550 --> 00:15:28,630
difficult and various polyfills depend

00:15:26,830 --> 00:15:31,180
on each other's and when they overlap

00:15:28,630 --> 00:15:33,700
they might not be compatible with it

00:15:31,180 --> 00:15:35,290
other in slightly different ways so I

00:15:33,700 --> 00:15:42,970
would recommend using like a full

00:15:35,290 --> 00:15:44,830
end-to-end solution and it's not having

00:15:42,970 --> 00:15:47,200
too many choices not actually a good

00:15:44,830 --> 00:15:50,320
thing in this regard because people

00:15:47,200 --> 00:15:52,990
avoid using polyfills because is so

00:15:50,320 --> 00:15:54,730
difficult to set up so you actually want

00:15:52,990 --> 00:15:58,120
something that is easy and we're just

00:15:54,730 --> 00:16:00,220
works out of the box policy tools as a

00:15:58,120 --> 00:16:03,310
service is one of these new easy

00:16:00,220 --> 00:16:06,130
phenomenons it only really works on

00:16:03,310 --> 00:16:08,500
runtime follicles it's pretty easy good

00:16:06,130 --> 00:16:13,390
to get started there's still kind of a

00:16:08,500 --> 00:16:16,330
lot of configuration options but there's

00:16:13,390 --> 00:16:20,560
also a single point of failure which

00:16:16,330 --> 00:16:23,970
means that if the CDN updates or goes

00:16:20,560 --> 00:16:28,200
down in the future in the long term then

00:16:23,970 --> 00:16:32,110
you might break the website and that's

00:16:28,200 --> 00:16:33,820
that may seem like a bad thing and for

00:16:32,110 --> 00:16:34,900
your clients this probably is but for

00:16:33,820 --> 00:16:37,450
the rest of us is actually a good thing

00:16:34,900 --> 00:16:42,070
because you can't accidentally break the

00:16:37,450 --> 00:16:43,870
future of the web it's the right spirit

00:16:42,070 --> 00:16:46,180
that like I've enumerated a lot of

00:16:43,870 --> 00:16:47,710
problems here and there all solvable we

00:16:46,180 --> 00:16:49,930
just need to start building a cohesive

00:16:47,710 --> 00:16:53,530
story around public wheels and buy into

00:16:49,930 --> 00:16:55,090
it from the end-to-end stack some people

00:16:53,530 --> 00:16:56,740
think the polyfills is a temporary hack

00:16:55,090 --> 00:17:00,520
that we don't really have to focus on

00:16:56,740 --> 00:17:05,530
it's something that we use now to to get

00:17:00,520 --> 00:17:09,370
rid of older browsers eventually but we

00:17:05,530 --> 00:17:11,770
won't as long as the web is evolving

00:17:09,370 --> 00:17:13,930
it's not an ad hoc hack it needs to be a

00:17:11,770 --> 00:17:16,300
natural part of all of our tools chain

00:17:13,930 --> 00:17:18,340
and if your tool chain doesn't support

00:17:16,300 --> 00:17:21,000
the bleeding edge polyfills entrance

00:17:18,340 --> 00:17:23,980
filers it might actually be left behind

00:17:21,000 --> 00:17:26,410
so all the major UI frameworks have

00:17:23,980 --> 00:17:29,830
announced intentions to design their new

00:17:26,410 --> 00:17:35,440
versions or new features with es7 in

00:17:29,830 --> 00:17:37,900
mind naughty s6 s7 and this is because

00:17:35,440 --> 00:17:39,880
all the new frameworks buy into this

00:17:37,900 --> 00:17:43,980
story of having polyfills and and

00:17:39,880 --> 00:17:43,980
adopting new standards very early

00:17:44,460 --> 00:17:49,120
another faint is showing up there's all

00:17:46,690 --> 00:17:51,460
these new type systems making the right

00:17:49,120 --> 00:17:53,650
into JavaScript they all have special

00:17:51,460 --> 00:17:55,750
annotations and if you want to use the

00:17:53,650 --> 00:17:57,850
type annotations you still need some

00:17:55,750 --> 00:18:00,160
kind of compile step to strip them out

00:17:57,850 --> 00:18:01,960
because they will realistically not be

00:18:00,160 --> 00:18:03,640
standardized anytime soon it will take a

00:18:01,960 --> 00:18:07,420
long time to standardize these type

00:18:03,640 --> 00:18:09,549
systems because this the tc39 doesn't

00:18:07,420 --> 00:18:10,870
want to standardize an incomplete type

00:18:09,549 --> 00:18:16,360
system they want a complete solution

00:18:10,870 --> 00:18:18,070
standardized which means that these

00:18:16,360 --> 00:18:22,630
limitations will live on for a long time

00:18:18,070 --> 00:18:23,590
without supporting the browser's ideally

00:18:22,630 --> 00:18:25,900
we don't want to end up in this

00:18:23,590 --> 00:18:28,030
situation where every framework has its

00:18:25,900 --> 00:18:31,390
own language and depends on a certain

00:18:28,030 --> 00:18:32,890
segment of transpires and polyfills it's

00:18:31,390 --> 00:18:34,780
natural that every framework cares

00:18:32,890 --> 00:18:37,690
little bit more about certain features

00:18:34,780 --> 00:18:39,520
than other features so they will try to

00:18:37,690 --> 00:18:42,730
jump on a particular transpiler

00:18:39,520 --> 00:18:45,160
particular polyfill but this is a

00:18:42,730 --> 00:18:47,320
configuration problem that doesn't

00:18:45,160 --> 00:18:50,320
affect most developers then in their

00:18:47,320 --> 00:18:52,059
day-to-day life but it's everyone's

00:18:50,320 --> 00:18:54,370
responsibility to sort of cooperate and

00:18:52,059 --> 00:18:57,280
try to move towards a unified JavaScript

00:18:54,370 --> 00:19:03,340
so we avoid the situation with the

00:18:57,280 --> 00:19:05,290
virgin libraries but using just

00:19:03,340 --> 00:19:07,780
JavaScript doesn't matter necessarily

00:19:05,290 --> 00:19:09,490
mean that you have to use all of it so

00:19:07,780 --> 00:19:11,980
JavaScript already has a very large

00:19:09,490 --> 00:19:14,020
surface area and if we want to add more

00:19:11,980 --> 00:19:16,120
features to it we need to remove

00:19:14,020 --> 00:19:18,280
something so that we can learn any

00:19:16,120 --> 00:19:19,990
features and the new people coming into

00:19:18,280 --> 00:19:22,500
our industry doesn't have to learn all

00:19:19,990 --> 00:19:26,820
the legacy that comes with along with it

00:19:22,500 --> 00:19:29,590
so linters strictmode vm optimizations

00:19:26,820 --> 00:19:31,570
they all discourage certain behavior

00:19:29,590 --> 00:19:34,240
certain JavaScript features they can

00:19:31,570 --> 00:19:36,250
never be removed and unsupported but

00:19:34,240 --> 00:19:38,169
they can be removed from our industry's

00:19:36,250 --> 00:19:39,700
mental surface area in the sense that

00:19:38,169 --> 00:19:42,549
you don't really have to know them to be

00:19:39,700 --> 00:19:44,290
productive in our industry so don't use

00:19:42,549 --> 00:19:48,040
the crazy parts of JavaScript just

00:19:44,290 --> 00:19:50,620
because we can and hopefully we can get

00:19:48,040 --> 00:19:53,850
to a adoption rate that looks something

00:19:50,620 --> 00:19:53,850

YouTube URL: https://www.youtube.com/watch?v=UZjqdW9_qSg


