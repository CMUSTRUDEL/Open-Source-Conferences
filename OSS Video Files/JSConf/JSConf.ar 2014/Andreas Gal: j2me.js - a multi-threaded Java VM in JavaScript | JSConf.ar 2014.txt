Title: Andreas Gal: j2me.js - a multi-threaded Java VM in JavaScript | JSConf.ar 2014
Publication date: 2015-05-10
Playlist: JSConf.ar 2014
Description: 
	j2me.js is a Java VM written in pure JavaScript that is geared towards modern Web-enabled mobile devices such as Firefox OS. Its designed to run Java/MIDP games and apps in an HTML5 environment, enabling old feature phone content to live on in the modern smartphone world. My talk will in focus in particular on mapping the more complex language features of the Java VM onto JavaScript and HTML5, including multithreading and synchronous I/O.

https://www.jsconfar.com/
Captions: 
	00:00:10,130 --> 00:00:15,050
okay since we were so nice to wait for

00:00:12,800 --> 00:00:17,180
me I will actually do tell you how I met

00:00:15,050 --> 00:00:20,930
Brandon it was about seven and a half

00:00:17,180 --> 00:00:22,550
years ago or so and I wasn't like in

00:00:20,930 --> 00:00:26,480
academia as you heard of a PhD in

00:00:22,550 --> 00:00:28,220
computer science and my entire career

00:00:26,480 --> 00:00:29,840
was really going towards being a

00:00:28,220 --> 00:00:31,730
professor so I've worked all my life

00:00:29,840 --> 00:00:33,920
being a professor I'm in two different

00:00:31,730 --> 00:00:35,720
schools I got every degree available in

00:00:33,920 --> 00:00:38,420
my field and I was trying to write

00:00:35,720 --> 00:00:40,730
compilers and back then in the beginning

00:00:38,420 --> 00:00:42,440
I was writing Java compilers and then

00:00:40,730 --> 00:00:45,650
add the idea to write a JavaScript

00:00:42,440 --> 00:00:47,870
compiler and the entire academic field

00:00:45,650 --> 00:00:50,750
that I've worked for thought that it's a

00:00:47,870 --> 00:00:52,760
really dumb idea I submitted paper after

00:00:50,750 --> 00:00:56,150
paper showing how we can make JavaScript

00:00:52,760 --> 00:00:57,770
go really fast and everyone told me that

00:00:56,150 --> 00:00:59,600
I'm solving the wrong problem that

00:00:57,770 --> 00:01:02,600
problem was already solved someone

00:00:59,600 --> 00:01:04,189
invented java and typed languages all

00:01:02,600 --> 00:01:05,840
you had to do is use Java instead of

00:01:04,189 --> 00:01:08,420
JavaScript and then you wouldn't need

00:01:05,840 --> 00:01:10,100
compilers for JavaScript so I couldn't

00:01:08,420 --> 00:01:12,950
convince anyone in my own field in

00:01:10,100 --> 00:01:15,049
academia to do javascript compilation i

00:01:12,950 --> 00:01:18,140
ran into brandon this was all the time

00:01:15,049 --> 00:01:19,700
when chrome was about to come out and we

00:01:18,140 --> 00:01:22,549
knew that performance would kind of heat

00:01:19,700 --> 00:01:24,079
up in the web and brandon hired me to

00:01:22,549 --> 00:01:26,299
missoula to write a compiler for

00:01:24,079 --> 00:01:28,009
javascript and we together released one

00:01:26,299 --> 00:01:30,380
the the first commercially available

00:01:28,009 --> 00:01:33,649
JavaScript compiler a couple days before

00:01:30,380 --> 00:01:36,079
actually chrome came out so that's how

00:01:33,649 --> 00:01:38,240
my Brendan and it was meant to be a very

00:01:36,079 --> 00:01:40,100
short stay I was originally planned to

00:01:38,240 --> 00:01:41,630
come up for three months the estimated

00:01:40,100 --> 00:01:43,789
you can write a compiler for javascript

00:01:41,630 --> 00:01:46,340
in three months and somehow ended up

00:01:43,789 --> 00:01:49,780
never leaving all right but now let's

00:01:46,340 --> 00:01:54,380
talk about Java and JavaScript some more

00:01:49,780 --> 00:01:57,200
my talk today is going to explore why we

00:01:54,380 --> 00:01:58,670
are doing Java and JavaScript but also I

00:01:57,200 --> 00:02:00,229
one will be a little bit technical and

00:01:58,670 --> 00:02:02,719
show you a little bit of the details of

00:02:00,229 --> 00:02:04,700
Java and show you how you can implement

00:02:02,719 --> 00:02:07,780
Java in JavaScript and some in some

00:02:04,700 --> 00:02:10,729
interesting things emerge if you do that

00:02:07,780 --> 00:02:12,410
first of all let me explain why we would

00:02:10,729 --> 00:02:15,140
do this why would anyone in the year

00:02:12,410 --> 00:02:18,290
2014 try to write a Java VM for

00:02:15,140 --> 00:02:20,540
JavaScript Java v almost successfully

00:02:18,290 --> 00:02:21,950
removed from the web stack today it's

00:02:20,540 --> 00:02:23,640
very very rare that you're running

00:02:21,950 --> 00:02:25,680
across Java applets

00:02:23,640 --> 00:02:31,170
mostly banks I think that use it still

00:02:25,680 --> 00:02:33,420
for security and login mechanisms their

00:02:31,170 --> 00:02:37,110
reasons to you this year you might know

00:02:33,420 --> 00:02:39,680
that we started bringing smartphones to

00:02:37,110 --> 00:02:42,090
market about a year ago firefox OS and

00:02:39,680 --> 00:02:44,970
firefox OS is targeting parts of the

00:02:42,090 --> 00:02:46,140
world that have a lot of people who

00:02:44,970 --> 00:02:47,640
currently have a feature phone and

00:02:46,140 --> 00:02:50,160
they're looking to get their first

00:02:47,640 --> 00:02:51,750
smartphone so device we are seeing here

00:02:50,160 --> 00:02:54,030
it's actually a device we launched about

00:02:51,750 --> 00:02:56,340
two months ago in India the price with

00:02:54,030 --> 00:02:58,709
this device is around 30 US dollars so

00:02:56,340 --> 00:03:00,000
it's about the cost of like a lunch in

00:02:58,709 --> 00:03:02,100
San Francisco you can get a smartphone

00:03:00,000 --> 00:03:04,320
and this thing is completed powered by

00:03:02,100 --> 00:03:05,880
html5 so everything you can see in this

00:03:04,320 --> 00:03:08,970
phone everything that runs on the phone

00:03:05,880 --> 00:03:13,500
all the apps the UI itself everything is

00:03:08,970 --> 00:03:16,070
written by html5 in html5 one problem we

00:03:13,500 --> 00:03:18,750
run into is that it's over the top

00:03:16,070 --> 00:03:21,570
messaging apps like Watsa are very

00:03:18,750 --> 00:03:23,730
popular around the world and it differs

00:03:21,570 --> 00:03:25,590
a little bit where what is popular but

00:03:23,730 --> 00:03:27,810
you can see that the parts of the world

00:03:25,590 --> 00:03:31,290
very particularly focusing on is Firefox

00:03:27,810 --> 00:03:33,510
OS such as here in Latin but also I Asia

00:03:31,290 --> 00:03:35,670
in those parts of the world there's

00:03:33,510 --> 00:03:38,910
specific messaging apps that are really

00:03:35,670 --> 00:03:41,489
popular and it's very hard to convince a

00:03:38,910 --> 00:03:43,680
maker of this messaging app to make an

00:03:41,489 --> 00:03:45,870
appt for html5 in some of these cases

00:03:43,680 --> 00:03:48,150
because there's not a lot of devices out

00:03:45,870 --> 00:03:50,940
there where today you can only bring

00:03:48,150 --> 00:03:53,190
html5 content to so an Android you can

00:03:50,940 --> 00:03:55,290
run an html5 app but you can also run an

00:03:53,190 --> 00:03:58,440
Android app so these guys have all

00:03:55,290 --> 00:04:00,480
written android apps for us there's no

00:03:58,440 --> 00:04:03,090
Android in our stack there's no iOS

00:04:00,480 --> 00:04:05,280
there's only the web and html5 so we

00:04:03,090 --> 00:04:08,220
needed somehow away to get these apps to

00:04:05,280 --> 00:04:10,560
run in our platform in some cases we

00:04:08,220 --> 00:04:11,760
were able to convince them that html5 is

00:04:10,560 --> 00:04:14,459
the future and they should write an

00:04:11,760 --> 00:04:16,769
html5 app for the platform line for

00:04:14,459 --> 00:04:18,510
example did that but a couple other guys

00:04:16,769 --> 00:04:20,340
didn't do that and if you look at this

00:04:18,510 --> 00:04:22,520
graph this data is about a year old but

00:04:20,340 --> 00:04:25,110
it shows that in some parts of the world

00:04:22,520 --> 00:04:27,060
some of these messaging apps are very

00:04:25,110 --> 00:04:28,590
very popular and if you don't have them

00:04:27,060 --> 00:04:31,200
on your phone nobody's going to buy it

00:04:28,590 --> 00:04:33,720
look down here for example in many parts

00:04:31,200 --> 00:04:35,370
of Latin if you don't have what's up

00:04:33,720 --> 00:04:36,870
it's really difficult to explain to

00:04:35,370 --> 00:04:39,480
someone why they would want to buy your

00:04:36,870 --> 00:04:41,760
so we needed a way to have what's up on

00:04:39,480 --> 00:04:44,250
this device even if what's up was not

00:04:41,760 --> 00:04:46,650
willing to make an appt an html5 just

00:04:44,250 --> 00:04:50,700
yet because when we started last year we

00:04:46,650 --> 00:04:53,220
had we started with 0 users so there's

00:04:50,700 --> 00:04:55,830
basic two things you can do one you can

00:04:53,220 --> 00:04:58,020
go ahead and try to just write your own

00:04:55,830 --> 00:05:00,420
wats up implementation or line

00:04:58,020 --> 00:05:02,070
implementation we did that and some of

00:05:00,420 --> 00:05:04,200
those who can get in the marketplace but

00:05:02,070 --> 00:05:06,150
people often ask specifically for what's

00:05:04,200 --> 00:05:09,480
up so to go in a store and want to buy a

00:05:06,150 --> 00:05:13,020
phone this what's up or is lying or his

00:05:09,480 --> 00:05:14,610
y ver and in these cases people in the

00:05:13,020 --> 00:05:17,670
store would say well it doesn't have

00:05:14,610 --> 00:05:19,110
what's up but the moment you start a

00:05:17,670 --> 00:05:21,120
sentence with it doesn't have what's up

00:05:19,110 --> 00:05:22,980
the person basically media doesn't want

00:05:21,120 --> 00:05:24,510
to phone anymore so to solve this

00:05:22,980 --> 00:05:28,380
problem somehow we have to get what's up

00:05:24,510 --> 00:05:30,600
onto our phone without relying on them

00:05:28,380 --> 00:05:33,240
making a wats up version until the

00:05:30,600 --> 00:05:35,490
enough users that people right naturally

00:05:33,240 --> 00:05:36,720
software for html5 as well that's kind

00:05:35,490 --> 00:05:38,790
of the whole idea what Mozilla is all

00:05:36,720 --> 00:05:41,670
about right we want to try to make html5

00:05:38,790 --> 00:05:45,390
as successful mobile as it's today on a

00:05:41,670 --> 00:05:48,240
desktop it gets even a little bit worse

00:05:45,390 --> 00:05:50,490
because the main competition for Firefox

00:05:48,240 --> 00:05:53,760
OS phones are these things future phones

00:05:50,490 --> 00:05:56,010
so for the price range of the very

00:05:53,760 --> 00:05:57,720
entry-level Firefox OS devices that's

00:05:56,010 --> 00:06:00,360
kind of the competition you can get some

00:05:57,720 --> 00:06:02,730
like Nokia feature phone with a dart pad

00:06:00,360 --> 00:06:04,680
in the small screen these things

00:06:02,730 --> 00:06:06,540
actually many of these messaging apps

00:06:04,680 --> 00:06:07,980
are available so this makes the

00:06:06,540 --> 00:06:10,740
situation for us a little bit more

00:06:07,980 --> 00:06:12,510
tricky because on the thing we compete

00:06:10,740 --> 00:06:14,280
with which is so much worse and hardware

00:06:12,510 --> 00:06:15,450
and it doesn't have proper web

00:06:14,280 --> 00:06:18,420
experience doesn't have a touch screen

00:06:15,450 --> 00:06:20,010
but it has whatsapp so people go in a

00:06:18,420 --> 00:06:22,260
store and I'm on a thing with what's up

00:06:20,010 --> 00:06:25,200
and then they get this here and not the

00:06:22,260 --> 00:06:27,330
smartphone at the same time though this

00:06:25,200 --> 00:06:29,310
is actually also a nice solution because

00:06:27,330 --> 00:06:31,140
as I said these things run these

00:06:29,310 --> 00:06:33,030
messaging apps so the idea we were

00:06:31,140 --> 00:06:35,400
looking at how can we take these

00:06:33,030 --> 00:06:37,710
messaging apps that are designed for

00:06:35,400 --> 00:06:42,120
these feature phones and run them on

00:06:37,710 --> 00:06:43,740
Firefox OS these things of course run

00:06:42,120 --> 00:06:45,990
Java all right in case you didn't know

00:06:43,740 --> 00:06:47,370
that if you ever have to install Java

00:06:45,990 --> 00:06:49,590
and I hope nobody here is that

00:06:47,370 --> 00:06:50,610
unfortunate when you install that it

00:06:49,590 --> 00:06:52,919
tells you that this Oh

00:06:50,610 --> 00:06:54,990
three billion devices or three billion

00:06:52,919 --> 00:06:56,219
phones running java I'm not sure it's

00:06:54,990 --> 00:06:58,050
still true today but it's probably

00:06:56,219 --> 00:06:59,460
roughly the right ballpark there's

00:06:58,050 --> 00:07:01,379
literally billions of phones out there

00:06:59,460 --> 00:07:04,469
anything that's not a smartphone today

00:07:01,379 --> 00:07:05,939
tends to run Java inside of it and it

00:07:04,469 --> 00:07:10,229
runs a very specific version of Java

00:07:05,939 --> 00:07:12,240
that's called j2me and I will kind of

00:07:10,229 --> 00:07:14,159
explain where that fits in many of you

00:07:12,240 --> 00:07:15,599
have probably never seen this that's not

00:07:14,159 --> 00:07:17,280
a problem it's just this is all stuff

00:07:15,599 --> 00:07:19,259
this is like I pulled this we can see

00:07:17,280 --> 00:07:21,539
how bad the phones are this is like a 14

00:07:19,259 --> 00:07:23,729
year old picture so this is what some

00:07:21,539 --> 00:07:26,819
thought the world would look like in the

00:07:23,729 --> 00:07:29,460
future like 14 years ago so basically

00:07:26,819 --> 00:07:31,860
idea was that everything is Java all the

00:07:29,460 --> 00:07:33,539
way from Java cards this is this is sim

00:07:31,860 --> 00:07:36,389
cards new phone for example another on

00:07:33,539 --> 00:07:38,759
the way right side here and then there's

00:07:36,389 --> 00:07:41,009
this lightweight versions of Java this

00:07:38,759 --> 00:07:42,779
is a micro edition or limited device

00:07:41,009 --> 00:07:45,469
edition of Java and then here's the

00:07:42,779 --> 00:07:47,340
grown-up job on desktop a nun service of

00:07:45,469 --> 00:07:49,110
course today this totally looks

00:07:47,340 --> 00:07:51,389
different right so the only place where

00:07:49,110 --> 00:07:53,460
Java really survived is in sim cards

00:07:51,389 --> 00:07:55,289
that's still javo today and then on a

00:07:53,460 --> 00:07:56,969
very far end here in enterprise and

00:07:55,289 --> 00:07:58,800
servers there's still some Java in the

00:07:56,969 --> 00:08:00,210
middle of it is small is dead the

00:07:58,800 --> 00:08:03,419
particular piece we care about is this

00:08:00,210 --> 00:08:05,479
one here the limited configuration of

00:08:03,419 --> 00:08:09,060
Java that runs on these feature phones

00:08:05,479 --> 00:08:11,490
the vm that that was built for that is

00:08:09,060 --> 00:08:12,750
called kvm or the killer x 3m that meant

00:08:11,490 --> 00:08:14,310
to express that these things are

00:08:12,750 --> 00:08:15,719
designed to run this relatively little

00:08:14,310 --> 00:08:19,919
memory that you have available in his

00:08:15,719 --> 00:08:22,199
future phones so there's a couple

00:08:19,919 --> 00:08:26,699
different ways how we can go and

00:08:22,199 --> 00:08:28,050
implement a Java VM in our phone to

00:08:26,699 --> 00:08:30,659
explain that of this architecture

00:08:28,050 --> 00:08:32,039
diagram here or Firefox OS I have no

00:08:30,659 --> 00:08:34,050
idea what the Japanese characters mean

00:08:32,039 --> 00:08:35,610
in case you wonder I just found this and

00:08:34,050 --> 00:08:38,190
its really cool graphics I also don't

00:08:35,610 --> 00:08:39,719
have no idea what the ice cone means but

00:08:38,190 --> 00:08:41,940
it was really kind of funny and I like

00:08:39,719 --> 00:08:43,409
the picture so I decided to use this it

00:08:41,940 --> 00:08:44,850
does show the necessary things I have to

00:08:43,409 --> 00:08:46,380
show so just ignore the Japanese

00:08:44,850 --> 00:08:49,410
characters and ignore the ice cream cone

00:08:46,380 --> 00:08:51,899
for a moment so we have it at the bottom

00:08:49,410 --> 00:08:53,339
we have gonk which is our version of

00:08:51,899 --> 00:08:55,410
Linux and a couple other low-level

00:08:53,339 --> 00:08:57,360
things that are really boring and on top

00:08:55,410 --> 00:08:58,890
of that is gecko gecko is mozillas

00:08:57,360 --> 00:09:00,690
rendering engine that's the thing that

00:08:58,890 --> 00:09:04,259
displays the web and then on top of

00:09:00,690 --> 00:09:05,819
gecko des Gaia Gaia is this html5

00:09:04,259 --> 00:09:07,529
experience that we talked about so all

00:09:05,819 --> 00:09:09,989
the things that you see in Firefox OS

00:09:07,529 --> 00:09:13,410
are all implemented in html5 and that's

00:09:09,989 --> 00:09:14,850
what we call Gaia so the simplest way to

00:09:13,410 --> 00:09:17,729
implement this would be of course to

00:09:14,850 --> 00:09:19,589
take a Java VM symbolized here to the

00:09:17,729 --> 00:09:21,929
inventor of Java and you could just kind

00:09:19,589 --> 00:09:23,669
of like stick that on top of gong next

00:09:21,929 --> 00:09:26,489
to gecko and basically just kind of veg

00:09:23,669 --> 00:09:29,089
it into our phone home and then we could

00:09:26,489 --> 00:09:31,410
run messaging things on top of that of

00:09:29,089 --> 00:09:35,669
course this is bad at least for two

00:09:31,410 --> 00:09:37,759
reasons first of all Java has a really

00:09:35,669 --> 00:09:40,410
bad track record with security um

00:09:37,759 --> 00:09:42,749
they're still finding really fundamental

00:09:40,410 --> 00:09:44,399
bugs in Java and they often really bad

00:09:42,749 --> 00:09:46,769
because they affect all browsers at the

00:09:44,399 --> 00:09:48,959
same time so if you do this if you take

00:09:46,769 --> 00:09:51,689
a Java VM and kind of like stick it into

00:09:48,959 --> 00:09:53,910
our system since the Java VM would be

00:09:51,689 --> 00:09:56,939
sitting directly on top of Linux and the

00:09:53,910 --> 00:09:59,939
OS core we would basically create a

00:09:56,939 --> 00:10:01,229
second surface for vulnerabilities there

00:09:59,939 --> 00:10:03,299
could be like additional bugs in the

00:10:01,229 --> 00:10:06,239
Java VM and they would create additional

00:10:03,299 --> 00:10:07,799
room for the phone to be broken into so

00:10:06,239 --> 00:10:09,660
that's a really bad idea to kind of put

00:10:07,799 --> 00:10:10,709
it in addition to the rendering engine

00:10:09,660 --> 00:10:13,789
you basically have twice as much

00:10:10,709 --> 00:10:16,739
opportunity for something to go wrong

00:10:13,789 --> 00:10:18,929
and in the second reason of course is

00:10:16,739 --> 00:10:20,879
that it would be really bad karma to put

00:10:18,929 --> 00:10:22,499
another Java VM into the vet stack right

00:10:20,879 --> 00:10:25,289
so we got to the point where you don't

00:10:22,499 --> 00:10:26,549
want a neat job on a desktop and this

00:10:25,289 --> 00:10:29,369
feature phones over the next couple

00:10:26,549 --> 00:10:32,069
years going out of fashion java will

00:10:29,369 --> 00:10:34,230
also go out of fashion with it so at

00:10:32,069 --> 00:10:36,209
this point putting a Java VM into a

00:10:34,230 --> 00:10:38,369
web-based and standards-based an

00:10:36,209 --> 00:10:40,589
html5-based phone it seems like a really

00:10:38,369 --> 00:10:44,910
bad idea so we decided not to go that

00:10:40,589 --> 00:10:46,859
route so of course what that leaves us

00:10:44,910 --> 00:10:48,989
is this then is to take our little

00:10:46,859 --> 00:10:52,169
diagram here with a Japanese characters

00:10:48,989 --> 00:10:55,259
in the ice cream cone and simply take a

00:10:52,169 --> 00:10:58,039
Java VM and put it on top of the entire

00:10:55,259 --> 00:11:03,509
system so we simply avoid a nap in html5

00:10:58,039 --> 00:11:05,789
that implement the Java VM and that app

00:11:03,509 --> 00:11:08,039
knows how to download the messaging app

00:11:05,789 --> 00:11:11,819
itself and I can run this whole thing on

00:11:08,039 --> 00:11:14,220
an existing phone the really nice part

00:11:11,819 --> 00:11:15,929
of this is that at the time that we

00:11:14,220 --> 00:11:17,759
started this which was about four or

00:11:15,929 --> 00:11:19,919
five months ago we already had a large

00:11:17,759 --> 00:11:21,689
number of phones out in the field that

00:11:19,919 --> 00:11:24,329
all don't have the original version of

00:11:21,689 --> 00:11:26,220
some of these messaging apps if we do it

00:11:24,329 --> 00:11:28,859
this way since we're not using any

00:11:26,220 --> 00:11:30,809
privileged html5 capabilities you're not

00:11:28,859 --> 00:11:33,869
kind of trying to bypass the platform in

00:11:30,809 --> 00:11:36,569
any way we can actually make an appt an

00:11:33,869 --> 00:11:38,069
html5 web app like this and just put it

00:11:36,569 --> 00:11:40,799
in a marketplace where people can

00:11:38,069 --> 00:11:42,749
download it and it can use this let me

00:11:40,799 --> 00:11:44,189
sort having to buy a new phone so this

00:11:42,749 --> 00:11:48,839
is very nice because we address the

00:11:44,189 --> 00:11:50,909
existing on set of phones as well all

00:11:48,839 --> 00:11:52,679
right the the downside of it of course

00:11:50,909 --> 00:11:55,739
is now we have to write a Java VM in

00:11:52,679 --> 00:11:58,529
JavaScript that's very exciting as I

00:11:55,739 --> 00:12:00,359
said my background is in writing

00:11:58,529 --> 00:12:05,159
compilers that's what i did in academia

00:12:00,359 --> 00:12:07,589
before brennan kind of freed me from

00:12:05,159 --> 00:12:09,029
academia let's put this way and my

00:12:07,589 --> 00:12:10,919
entire background net revolves in Java

00:12:09,029 --> 00:12:12,509
compilers before i started to JavaScript

00:12:10,919 --> 00:12:14,519
compiler so this is one of the reasons

00:12:12,509 --> 00:12:15,689
that i found this project particular

00:12:14,519 --> 00:12:17,819
interesting because i have done both

00:12:15,689 --> 00:12:19,679
extensively i have written several java

00:12:17,819 --> 00:12:21,600
VMs and i have written several

00:12:19,679 --> 00:12:24,689
implementations of java spoken powders I

00:12:21,600 --> 00:12:26,489
never really try to write a Java VM on

00:12:24,689 --> 00:12:31,289
top of JavaScript so that seemed very

00:12:26,489 --> 00:12:33,239
appealing to me so for the next couple

00:12:31,289 --> 00:12:35,100
of slides I will dive a little bit into

00:12:33,239 --> 00:12:36,869
technical details and explain to you at

00:12:35,100 --> 00:12:39,779
the high level of how Java works and

00:12:36,869 --> 00:12:42,539
show you some of the problems that i ran

00:12:39,779 --> 00:12:44,909
into trying to build a Java VM that's

00:12:42,539 --> 00:12:47,999
really ready to run production level

00:12:44,909 --> 00:12:49,769
code on a device like this don't worry

00:12:47,999 --> 00:12:51,119
too much if you don't see on understand

00:12:49,769 --> 00:12:53,249
some of the details for example there

00:12:51,119 --> 00:12:55,079
will be no quiz after my talk on the

00:12:53,249 --> 00:12:56,959
details of this slide this is merely

00:12:55,079 --> 00:12:59,100
meant to kind of highlight some of the

00:12:56,959 --> 00:13:00,959
concepts need to understand so we can

00:12:59,100 --> 00:13:02,579
understand the next slide so in this

00:13:00,959 --> 00:13:05,279
slide here really the only thing you

00:13:02,579 --> 00:13:07,859
should memorize is that Java is built

00:13:05,279 --> 00:13:09,809
from class files every Java program that

00:13:07,859 --> 00:13:12,350
you get consists of a large number of

00:13:09,809 --> 00:13:15,389
class files and each class file

00:13:12,350 --> 00:13:18,119
represents one class and these things

00:13:15,389 --> 00:13:19,769
are stored in a binary format it's

00:13:18,119 --> 00:13:21,480
basically an array of bytes that

00:13:19,769 --> 00:13:24,689
contains information about the class

00:13:21,480 --> 00:13:26,730
itself it contains the fields and the

00:13:24,689 --> 00:13:29,130
methods of a class

00:13:26,730 --> 00:13:31,620
the actual code which is sort of the

00:13:29,130 --> 00:13:34,199
bytecode the bytecode you can think of

00:13:31,620 --> 00:13:36,720
as a sequence of bytes that explains

00:13:34,199 --> 00:13:39,180
what instruction the vm should take and

00:13:36,720 --> 00:13:42,180
the vm goes step-by-step through these

00:13:39,180 --> 00:13:43,980
by code instructions so really all you

00:13:42,180 --> 00:13:46,139
have to do to run a Java program is you

00:13:43,980 --> 00:13:48,630
have to find a way how you can parse

00:13:46,139 --> 00:13:51,029
these class files and then you write an

00:13:48,630 --> 00:13:53,760
interpreter for this language this java

00:13:51,029 --> 00:13:56,100
bytecode language and then you run that

00:13:53,760 --> 00:13:58,410
interpreter over the code that you find

00:13:56,100 --> 00:14:01,320
in these classes and once you have one

00:13:58,410 --> 00:14:03,630
class let's your starting class it will

00:14:01,320 --> 00:14:05,519
call methods it can call methods in the

00:14:03,630 --> 00:14:07,680
same class or it can call to other

00:14:05,519 --> 00:14:09,870
classes whenever it calls another class

00:14:07,680 --> 00:14:12,180
you have to go and find the class file

00:14:09,870 --> 00:14:15,660
for the other class so that's that's the

00:14:12,180 --> 00:14:19,199
other than in time magic behind Java now

00:14:15,660 --> 00:14:22,430
as I said javac on Java programs consist

00:14:19,199 --> 00:14:24,720
of a large number of this class files a

00:14:22,430 --> 00:14:26,370
popular messaging app like what's up or

00:14:24,720 --> 00:14:28,949
viber is often hundreds of different

00:14:26,370 --> 00:14:30,899
classes in addition to that you also

00:14:28,949 --> 00:14:33,449
have library classes which are often

00:14:30,899 --> 00:14:35,399
thousands of classes it would be of

00:14:33,449 --> 00:14:37,019
course kind of awkward to have to carry

00:14:35,399 --> 00:14:39,000
around a thousand files if you're

00:14:37,019 --> 00:14:43,319
installing a drama program so what they

00:14:39,000 --> 00:14:47,430
came up this is jar files a jar file is

00:14:43,319 --> 00:14:49,350
a java java like name for a zip file so

00:14:47,430 --> 00:14:51,300
it turns out jar fights really are like

00:14:49,350 --> 00:14:53,069
zip files they are exactly structured

00:14:51,300 --> 00:14:56,279
the same in there basically just a zip

00:14:53,069 --> 00:14:57,899
archive miss all the Java class files

00:14:56,279 --> 00:14:59,730
inside of that and if you want to

00:14:57,899 --> 00:15:01,620
distribute a Java app all you do is you

00:14:59,730 --> 00:15:03,959
give someone a jar file and then the vm

00:15:01,620 --> 00:15:07,410
can go and read all that stuff out of

00:15:03,959 --> 00:15:10,019
the jar file the first problem we run

00:15:07,410 --> 00:15:11,610
into is that as i explained what you

00:15:10,019 --> 00:15:14,130
want to do is we want to write an app

00:15:11,610 --> 00:15:16,380
that knows how to run a Java program and

00:15:14,130 --> 00:15:18,449
it will get that actual Java program

00:15:16,380 --> 00:15:21,420
from whoever is distributing the Java

00:15:18,449 --> 00:15:23,819
program not from us so the first step we

00:15:21,420 --> 00:15:26,130
have to make sure of is that this Java

00:15:23,819 --> 00:15:27,810
VM that we are writing can read this

00:15:26,130 --> 00:15:32,910
original jar files so we need to be able

00:15:27,810 --> 00:15:34,620
to parse zip files fortunately that's

00:15:32,910 --> 00:15:36,899
something I had to do before so we did

00:15:34,620 --> 00:15:40,050
PDF ojs a couple years ago to display

00:15:36,899 --> 00:15:41,820
PDF documents as html5 and there

00:15:40,050 --> 00:15:43,950
Oh as well the first problem we have to

00:15:41,820 --> 00:15:46,470
solve is that PDF documents are

00:15:43,950 --> 00:15:47,790
basically zip files as well so you can

00:15:46,470 --> 00:15:49,320
if you can see a mean here like

00:15:47,790 --> 00:15:52,019
everything out there is a fob basically

00:15:49,320 --> 00:15:54,269
and we had actually implemented for PDF

00:15:52,019 --> 00:15:57,630
ojs a zip file reader lets up on github

00:15:54,269 --> 00:15:59,220
and I'd lying around there for like the

00:15:57,630 --> 00:16:03,029
last two years and we didn't touch it

00:15:59,220 --> 00:16:05,040
since then so I took zip file dodge is

00:16:03,029 --> 00:16:08,010
my word al-ilah parser for class file so

00:16:05,040 --> 00:16:09,480
kind of see how this goes and should

00:16:08,010 --> 00:16:11,279
work great right we have again parse

00:16:09,480 --> 00:16:15,720
class files now we can read the files

00:16:11,279 --> 00:16:17,910
and it totally didn't work at all that

00:16:15,720 --> 00:16:20,640
was somewhat unexpected so I spent a

00:16:17,910 --> 00:16:22,380
good afternoon trying to find out why

00:16:20,640 --> 00:16:27,180
the class files I was getting out of the

00:16:22,380 --> 00:16:31,110
jar files did not make any sense and it

00:16:27,180 --> 00:16:33,740
turns out that if you read the

00:16:31,110 --> 00:16:37,410
specification of zip files which I did

00:16:33,740 --> 00:16:39,000
it's a very painful process I hope you

00:16:37,410 --> 00:16:43,730
never have to do that it's really it

00:16:39,000 --> 00:16:47,550
sucks the specification says that any

00:16:43,730 --> 00:16:49,649
zeros at the end of a stream you don't

00:16:47,550 --> 00:16:51,450
have to store so if you're storing a

00:16:49,649 --> 00:16:53,820
compressed file and the last couple

00:16:51,450 --> 00:16:56,670
things in the file are zeros you can

00:16:53,820 --> 00:16:58,560
leave out those zeros the program that

00:16:56,670 --> 00:17:00,660
parses the zip file is supposed to know

00:16:58,560 --> 00:17:04,470
that there's something missing just add

00:17:00,660 --> 00:17:05,790
an 0 and I somewhat didn't read this

00:17:04,470 --> 00:17:07,770
right the first time we wrote this

00:17:05,790 --> 00:17:09,600
implementation so what the code

00:17:07,770 --> 00:17:14,100
originally did is if you're running out

00:17:09,600 --> 00:17:15,480
of bytes in your typed array and you get

00:17:14,100 --> 00:17:17,579
an undefined back you raise an exception

00:17:15,480 --> 00:17:20,040
so this is the error of your running

00:17:17,579 --> 00:17:22,800
into and the fix of course is very easy

00:17:20,040 --> 00:17:25,800
you simply read data from a byte array

00:17:22,800 --> 00:17:27,179
and then we just or a 0 in there this is

00:17:25,800 --> 00:17:28,650
a trick we will use a little bit later

00:17:27,179 --> 00:17:32,280
on a slide as well what this basically

00:17:28,650 --> 00:17:36,150
does it it it forces that to be an

00:17:32,280 --> 00:17:37,770
integer number and undefined is the

00:17:36,150 --> 00:17:39,540
equivalent of the integer number 0 so

00:17:37,770 --> 00:17:41,730
whenever we read past the end of this

00:17:39,540 --> 00:17:43,350
byte stream then we will start reading

00:17:41,730 --> 00:17:46,200
back zeros which is exactly what the

00:17:43,350 --> 00:17:49,919
specification calls for the neat part is

00:17:46,200 --> 00:17:52,890
that we ship this bug in PDF no Jas for

00:17:49,919 --> 00:17:53,510
years so people have looked at like

00:17:52,890 --> 00:17:55,700
billions

00:17:53,510 --> 00:17:57,770
PDF documents and nobody notices that

00:17:55,700 --> 00:18:00,500
this was wrong this must be because the

00:17:57,770 --> 00:18:02,330
implementation of jar files and of PDF

00:18:00,500 --> 00:18:03,980
readers is separate so the PDF readers

00:18:02,330 --> 00:18:06,320
seemed or generators don't seem to

00:18:03,980 --> 00:18:08,510
generate this kind of optimization with

00:18:06,320 --> 00:18:11,380
zero at the end so since then we

00:18:08,510 --> 00:18:15,350
actually fix that in in Firefox as well

00:18:11,380 --> 00:18:17,990
all right next step so I had now a way

00:18:15,350 --> 00:18:21,530
to read your files after some pain and I

00:18:17,990 --> 00:18:23,300
had a way to parse class files the next

00:18:21,530 --> 00:18:25,250
step of course is VM we have to go and

00:18:23,300 --> 00:18:26,810
get something it will interpret that

00:18:25,250 --> 00:18:29,240
byte code and run the actual Java

00:18:26,810 --> 00:18:30,770
program for us the most natural way of

00:18:29,240 --> 00:18:33,440
doing that these days would be of course

00:18:30,770 --> 00:18:37,730
to take and scripting and scripting is

00:18:33,440 --> 00:18:41,150
this C++ or C C++ compiler that takes

00:18:37,730 --> 00:18:43,940
existing C++ code and it emits through

00:18:41,150 --> 00:18:46,790
llvm and a couple other steps JavaScript

00:18:43,940 --> 00:18:48,590
from that all the last year actually we

00:18:46,790 --> 00:18:50,930
also did an extension of that called

00:18:48,590 --> 00:18:53,150
SMGs which I think Brendan will show in

00:18:50,930 --> 00:18:54,530
his talk in a little bit that makes it

00:18:53,150 --> 00:18:56,780
possible to make this really efficient

00:18:54,530 --> 00:18:59,510
so if you do this path if you go from C

00:18:56,780 --> 00:19:00,680
C++ down to JavaScript you can get

00:18:59,510 --> 00:19:03,290
really really close to native

00:19:00,680 --> 00:19:04,700
performance so is this work this would

00:19:03,290 --> 00:19:08,420
be great because all i have to do is

00:19:04,700 --> 00:19:10,630
take kvm which is written in c and i

00:19:08,420 --> 00:19:13,130
could compile that and i would have a vm

00:19:10,630 --> 00:19:16,550
in my browser or am I rendering engine

00:19:13,130 --> 00:19:18,020
in theory that's really great and you

00:19:16,550 --> 00:19:20,540
should always reuse code if you can

00:19:18,020 --> 00:19:23,330
however in this case I couldn't find a

00:19:20,540 --> 00:19:24,710
license for kvm and I'm serious there's

00:19:23,330 --> 00:19:26,480
no license they put on coat there

00:19:24,710 --> 00:19:28,160
they're saying that there's no license

00:19:26,480 --> 00:19:29,840
and didn't have a license for it so i

00:19:28,160 --> 00:19:32,480
started calling up some old friends from

00:19:29,840 --> 00:19:33,890
sun and there's really no license out

00:19:32,480 --> 00:19:36,080
there so for some reason is out there

00:19:33,890 --> 00:19:38,180
there's no license right now to use it

00:19:36,080 --> 00:19:41,030
and i couldn't find anyone left at

00:19:38,180 --> 00:19:42,860
Oracle who knows how they could slap and

00:19:41,030 --> 00:19:45,110
open-source license on to it so I ended

00:19:42,860 --> 00:19:46,730
up basically not be able to use kvm

00:19:45,110 --> 00:19:48,380
because it's not allowed you can only

00:19:46,730 --> 00:19:50,600
use it for research purposes you cannot

00:19:48,380 --> 00:19:52,700
use it for any other purpose so this was

00:19:50,600 --> 00:19:54,710
very sad because there's essentially no

00:19:52,700 --> 00:19:57,470
other open source project that

00:19:54,710 --> 00:19:59,900
implements this specific flavor of the

00:19:57,470 --> 00:20:01,460
vm there's a couple open-source VMs that

00:19:59,900 --> 00:20:04,040
implement a more heavyweight complete

00:20:01,460 --> 00:20:07,040
java VMS but nothing implements this

00:20:04,040 --> 00:20:09,260
limited configuration at kvm needs

00:20:07,040 --> 00:20:11,000
so one of the reasons I'm here today

00:20:09,260 --> 00:20:16,450
with you is because son didn't put a

00:20:11,000 --> 00:20:22,790
license on kvm 14 years ago I all right

00:20:16,450 --> 00:20:24,860
um so divided a vm i went to github and

00:20:22,790 --> 00:20:26,060
try to find who else try to do this and

00:20:24,860 --> 00:20:28,040
it turns out a whole bunch of people

00:20:26,060 --> 00:20:30,410
have tried to write Java VM sin

00:20:28,040 --> 00:20:33,460
JavaScript and everyone tends to do that

00:20:30,410 --> 00:20:35,090
for about two months before they give up

00:20:33,460 --> 00:20:36,500
so I looked at all the different

00:20:35,090 --> 00:20:38,930
implementations that were completely

00:20:36,500 --> 00:20:42,800
incomplete and the one I like the best

00:20:38,930 --> 00:20:44,060
is called no JVM I liked it because the

00:20:42,800 --> 00:20:47,450
code structure was gonna be very nice

00:20:44,060 --> 00:20:50,420
and neat or maybe just because his style

00:20:47,450 --> 00:20:52,130
match my random style very well but

00:20:50,420 --> 00:20:54,920
anyway this was the one that I started

00:20:52,130 --> 00:20:56,900
with I'd had our classified parser and a

00:20:54,920 --> 00:20:58,310
bunch of different other pieces that I

00:20:56,900 --> 00:20:59,840
was able to be used so if this actually

00:20:58,310 --> 00:21:03,380
was able to get the first hello world

00:20:59,840 --> 00:21:05,170
program to work I very quickly realized

00:21:03,380 --> 00:21:09,260
that the way that they implemented

00:21:05,170 --> 00:21:11,990
natives is a really bad idea so what is

00:21:09,260 --> 00:21:14,420
the native and drama as you probably

00:21:11,990 --> 00:21:15,980
know Java is a type-safe language so

00:21:14,420 --> 00:21:18,020
there's a lot of things you cannot do in

00:21:15,980 --> 00:21:20,180
Java you cannot poke around this memory

00:21:18,020 --> 00:21:22,160
addresses you cannot directly call a

00:21:20,180 --> 00:21:24,500
system call that would invoke some

00:21:22,160 --> 00:21:26,420
service from the operating system to do

00:21:24,500 --> 00:21:29,180
these things Java has to somehow paul

00:21:26,420 --> 00:21:31,760
into c code and this C code is what Java

00:21:29,180 --> 00:21:33,620
called native code it's basically in the

00:21:31,760 --> 00:21:36,380
vm a way to recognize that you're

00:21:33,620 --> 00:21:38,870
calling a special magic method this a

00:21:36,380 --> 00:21:41,870
specific name and that name is mapped to

00:21:38,870 --> 00:21:45,100
running a c function instead of trying

00:21:41,870 --> 00:21:50,420
to run actual javascript by core program

00:21:45,100 --> 00:21:53,990
the way that the author of this vm

00:21:50,420 --> 00:21:57,410
implemented all the java libraries is

00:21:53,990 --> 00:22:00,110
that he basically made every single java

00:21:57,410 --> 00:22:01,700
library method a native method so you

00:22:00,110 --> 00:22:03,320
would go ahead and JavaScript implement

00:22:01,700 --> 00:22:07,730
every single thing did you need in Java

00:22:03,320 --> 00:22:09,350
in JavaScript that again is a bad idea

00:22:07,730 --> 00:22:12,620
for a couple different reasons first of

00:22:09,350 --> 00:22:14,960
all there's a lot of stuff the Java

00:22:12,620 --> 00:22:16,640
library that you need for this phones

00:22:14,960 --> 00:22:19,910
that you're not very large is about one

00:22:16,640 --> 00:22:20,870
megabyte as a compressed jar file if you

00:22:19,910 --> 00:22:23,390
I'm

00:22:20,870 --> 00:22:25,309
Press that and because classify it's

00:22:23,390 --> 00:22:27,170
actually very compact there's actually a

00:22:25,309 --> 00:22:29,990
ton of code it's a couple of thousand

00:22:27,170 --> 00:22:32,750
classes and those classes have a lot of

00:22:29,990 --> 00:22:34,340
different implementation details my life

00:22:32,750 --> 00:22:36,290
is too short to like write all of that

00:22:34,340 --> 00:22:38,900
again in JavaScript 14 years later and

00:22:36,290 --> 00:22:40,400
again I was it kind of felt bad karma to

00:22:38,900 --> 00:22:42,290
redo all this work that was done 14

00:22:40,400 --> 00:22:44,330
years ago so of course a much better

00:22:42,290 --> 00:22:49,430
idea would be even though they cannot

00:22:44,330 --> 00:22:51,440
use the same vm that um son did 14 years

00:22:49,430 --> 00:22:53,690
ago we could at least use the same

00:22:51,440 --> 00:22:57,050
libraries maybe and this is very good

00:22:53,690 --> 00:23:00,140
lucky and I'll come back to in a second

00:22:57,050 --> 00:23:02,870
the second piece that the second reason

00:23:00,140 --> 00:23:06,290
it's a really bad idea to try to write a

00:23:02,870 --> 00:23:07,970
Java library in javascript is that even

00:23:06,290 --> 00:23:09,230
though the name is very similar and i'm

00:23:07,970 --> 00:23:12,290
sure brandon has a couple more jobs on

00:23:09,230 --> 00:23:13,940
this one to the name is very similar but

00:23:12,290 --> 00:23:17,690
semantically this languages are very

00:23:13,940 --> 00:23:20,809
very different so in Java for example if

00:23:17,690 --> 00:23:24,920
you invoke a method and give it an

00:23:20,809 --> 00:23:27,380
object that is null something very

00:23:24,920 --> 00:23:30,080
specific happens in Java and you're

00:23:27,380 --> 00:23:32,390
supposed to raise a Java exception so

00:23:30,080 --> 00:23:34,220
what the vm has to do basically it's not

00:23:32,390 --> 00:23:36,170
just throw an underlying javascript

00:23:34,220 --> 00:23:38,330
exception but the vm has to throw a java

00:23:36,170 --> 00:23:40,790
exception has to take a different path

00:23:38,330 --> 00:23:43,190
running bytecode and it has to give the

00:23:40,790 --> 00:23:47,179
program a chance to react properly to

00:23:43,190 --> 00:23:48,790
that null exception and because Java is

00:23:47,179 --> 00:23:51,890
so old and has gone through so many

00:23:48,790 --> 00:23:54,920
rewrites and so many as much cool that's

00:23:51,890 --> 00:23:57,230
written for it java applications tend to

00:23:54,920 --> 00:23:59,390
often really rely on these very subtle

00:23:57,230 --> 00:24:02,059
little details so when you're starting

00:23:59,390 --> 00:24:05,000
what's up for example it does rely on

00:24:02,059 --> 00:24:08,210
the proper handling of a null objective

00:24:05,000 --> 00:24:10,850
reference if you start v-chat like this

00:24:08,210 --> 00:24:12,679
it relies on an integer division by zero

00:24:10,850 --> 00:24:15,260
being thrown as an exception and being

00:24:12,679 --> 00:24:18,530
reported so it would be very difficult

00:24:15,260 --> 00:24:20,750
to rewrite all this JavaScript code or

00:24:18,530 --> 00:24:23,270
the Java code in JavaScript and make

00:24:20,750 --> 00:24:26,780
sure that every single step you maintain

00:24:23,270 --> 00:24:28,490
precisely the semantics of Java it would

00:24:26,780 --> 00:24:31,190
be of course much better if you can

00:24:28,490 --> 00:24:33,410
simply take the library code as Java and

00:24:31,190 --> 00:24:34,620
then they simply run that in a vm then

00:24:33,410 --> 00:24:36,300
you don't have to write the code

00:24:34,620 --> 00:24:40,590
and we have guaranteed to write

00:24:36,300 --> 00:24:44,850
semantics so as I said we got lucky here

00:24:40,590 --> 00:24:48,809
because son open sourced the library

00:24:44,850 --> 00:24:50,970
parts of Java just not the kvm itself so

00:24:48,809 --> 00:24:52,770
we could simply download from Sons site

00:24:50,970 --> 00:24:54,980
the entire source code of the library

00:24:52,770 --> 00:24:56,970
that you need for these phones to work

00:24:54,980 --> 00:25:00,809
that saved a ton of effort right there

00:24:56,970 --> 00:25:02,580
that's great all right let's talk a bit

00:25:00,809 --> 00:25:04,830
about the vm so now we have busy all the

00:25:02,580 --> 00:25:08,640
basic pieces we have we can redraw files

00:25:04,830 --> 00:25:11,190
you can look at class files we have the

00:25:08,640 --> 00:25:15,480
library stuff as bytecode not only in a

00:25:11,190 --> 00:25:17,940
vm that can actually run this code the

00:25:15,480 --> 00:25:20,760
vm itself is really straightforward as i

00:25:17,940 --> 00:25:22,770
said earlier java bytecode this is busy

00:25:20,760 --> 00:25:25,440
a sequence of bytes these instructions

00:25:22,770 --> 00:25:27,960
in their encoded there's a little bit

00:25:25,440 --> 00:25:30,030
less than 255 instructions they're

00:25:27,960 --> 00:25:33,630
numbered and there's a definition that

00:25:30,030 --> 00:25:35,850
says if you see zero in your byte stream

00:25:33,630 --> 00:25:37,860
that's a no op don't do anything let's

00:25:35,850 --> 00:25:41,250
go to the next instruction if you see

00:25:37,860 --> 00:25:44,220
one its and it pushes on now constant

00:25:41,250 --> 00:25:45,720
onto the Java stack and so on so the

00:25:44,220 --> 00:25:47,730
most trivial way of implementing this is

00:25:45,720 --> 00:25:50,700
simply you go ahead and you've read a

00:25:47,730 --> 00:25:53,100
little interpreter it grabs the current

00:25:50,700 --> 00:25:55,220
frame and it pulls out the stack and

00:25:53,100 --> 00:26:01,920
then it does operations on it you know

00:25:55,220 --> 00:26:04,200
infinitely spinning wildly it's

00:26:01,920 --> 00:26:08,670
interesting to look at two parts of this

00:26:04,200 --> 00:26:10,200
loop or this instruction execution the

00:26:08,670 --> 00:26:13,620
1i dough is showed briefly a couple

00:26:10,200 --> 00:26:15,360
slides earlier in Java you have strict

00:26:13,620 --> 00:26:17,160
typing so in Java actually have

00:26:15,360 --> 00:26:19,470
different by code instructions for

00:26:17,160 --> 00:26:22,170
adding two integers or adding two long

00:26:19,470 --> 00:26:24,720
integers integers are defined as 32-bit

00:26:22,170 --> 00:26:27,600
integers and lungs are defined 64-bit

00:26:24,720 --> 00:26:29,070
integers so for integer addition what

00:26:27,600 --> 00:26:31,020
you have to make sure is that when you

00:26:29,070 --> 00:26:33,800
add two numbers they're always

00:26:31,020 --> 00:26:37,050
guaranteed come out as an integer again

00:26:33,800 --> 00:26:39,809
now we could make sure that the number

00:26:37,050 --> 00:26:41,730
that goes in into stack pop on those two

00:26:39,809 --> 00:26:44,280
there are always integers however if you

00:26:41,730 --> 00:26:46,920
add two integers in JavaScript and its

00:26:44,280 --> 00:26:49,380
larger than a 32-bit integer what you

00:26:46,920 --> 00:26:51,760
get is a

00:26:49,380 --> 00:26:53,560
right this is overflow to the doubles so

00:26:51,760 --> 00:26:57,190
JavaScript doesn't have this weird case

00:26:53,560 --> 00:26:59,020
of Java where if you go over the

00:26:57,190 --> 00:27:00,370
definition range of an integer you can

00:26:59,020 --> 00:27:02,620
you kind of come back out on the other

00:27:00,370 --> 00:27:05,590
side of the world or like if you add one

00:27:02,620 --> 00:27:08,710
to the largest 32-bit integer then you

00:27:05,590 --> 00:27:11,370
get a negative number so that's really

00:27:08,710 --> 00:27:14,410
nice for javascript but in case of a

00:27:11,370 --> 00:27:16,420
Java VM we have to actually emulate the

00:27:14,410 --> 00:27:17,830
way java reacts here otherwise if some

00:27:16,420 --> 00:27:19,870
program relies on this it wouldn't work

00:27:17,830 --> 00:27:22,750
anymore use the same trick here if you

00:27:19,870 --> 00:27:24,580
or a number of a 0 you force it to be

00:27:22,750 --> 00:27:25,960
converted to an integer number and that

00:27:24,580 --> 00:27:28,150
way we can implement the integer

00:27:25,960 --> 00:27:30,670
semantics of JavaScript the second one

00:27:28,150 --> 00:27:32,950
is a long addition down there and that's

00:27:30,670 --> 00:27:36,070
actually bit harder because javascript

00:27:32,950 --> 00:27:38,530
cannot directly calculate 64-bit numbers

00:27:36,070 --> 00:27:41,050
you have only doubles and a part of the

00:27:38,530 --> 00:27:43,590
doubles is reserved for essentially

00:27:41,050 --> 00:27:46,930
telling the system where the period goes

00:27:43,590 --> 00:27:51,280
so as a result of that we are using

00:27:46,930 --> 00:27:53,050
geelong ojs which is the 64-bit math

00:27:51,280 --> 00:27:55,930
library that ships with a closure

00:27:53,050 --> 00:27:57,430
compiler so all longs that are generated

00:27:55,930 --> 00:27:59,110
on the stack evasive wrapped into those

00:27:57,430 --> 00:28:02,110
objects that allow you to do 64-bit

00:27:59,110 --> 00:28:05,140
computation fortunately on these feature

00:28:02,110 --> 00:28:06,970
phones 64-bit math is very rare so it's

00:28:05,140 --> 00:28:10,510
important to support it but it's not

00:28:06,970 --> 00:28:12,700
really a performance problem a more

00:28:10,510 --> 00:28:14,320
interesting instructions get filled and

00:28:12,700 --> 00:28:15,880
for those of you who don't like reading

00:28:14,320 --> 00:28:17,590
code I promise there's only two or three

00:28:15,880 --> 00:28:20,650
slides left before we go back to memes

00:28:17,590 --> 00:28:22,090
and things to laugh about I wanted to

00:28:20,650 --> 00:28:23,050
show a couple of more examples of stuff

00:28:22,090 --> 00:28:25,120
that's was really interesting to

00:28:23,050 --> 00:28:27,870
implement and as I said I've written

00:28:25,120 --> 00:28:29,830
several Java the ends at this point and

00:28:27,870 --> 00:28:33,220
implementing some of the more complex

00:28:29,830 --> 00:28:35,110
features of Java this time around in

00:28:33,220 --> 00:28:36,820
JavaScript turned out to be very very

00:28:35,110 --> 00:28:38,710
different from any other implementation

00:28:36,820 --> 00:28:41,440
that I've done a good example for this

00:28:38,710 --> 00:28:44,490
get feel what get filled does it gets

00:28:41,440 --> 00:28:46,900
the value of a field of a Java object

00:28:44,490 --> 00:28:50,140
basically what it does is it resolves

00:28:46,900 --> 00:28:52,600
the field into a slot into the object

00:28:50,140 --> 00:28:56,620
and then tries to read from that slot

00:28:52,600 --> 00:28:58,559
and the object the Java specification

00:28:56,620 --> 00:29:00,330
defines certain air

00:28:58,559 --> 00:29:04,100
conditions that can happen one example

00:29:00,330 --> 00:29:07,110
is if you give get filled and null

00:29:04,100 --> 00:29:09,840
object then it is supposed to throw an

00:29:07,110 --> 00:29:12,779
exception so as the interpreters running

00:29:09,840 --> 00:29:14,460
if object happens to be null then this

00:29:12,779 --> 00:29:16,529
race exceptional yield is going to be

00:29:14,460 --> 00:29:19,049
invoked so let's look at that for a

00:29:16,529 --> 00:29:21,600
second because that's so interesting the

00:29:19,049 --> 00:29:23,639
way we did that so what raise exception

00:29:21,600 --> 00:29:25,169
and yield does is essentially it raises

00:29:23,639 --> 00:29:27,299
an exception another show in a second

00:29:25,169 --> 00:29:31,110
what it does and after that it does a

00:29:27,299 --> 00:29:33,629
yield by throwing and Java Script

00:29:31,110 --> 00:29:37,350
exception so again we are trying to

00:29:33,629 --> 00:29:39,179
throw a Java exception by doing some

00:29:37,350 --> 00:29:41,429
code and then throwing a JavaScript

00:29:39,179 --> 00:29:44,399
exception if you can still follow me at

00:29:41,429 --> 00:29:46,830
this point your you re brave the reason

00:29:44,399 --> 00:29:49,710
we are doing this is that Java is fully

00:29:46,830 --> 00:29:51,330
synchronous language this is very

00:29:49,710 --> 00:29:53,159
different from JavaScript we're really

00:29:51,330 --> 00:29:55,350
one of the prime directives of

00:29:53,159 --> 00:29:57,539
javascript is try to run as little code

00:29:55,350 --> 00:29:59,669
as possible in your event loop and don't

00:29:57,539 --> 00:30:02,129
hog the event loop run small snippets of

00:29:59,669 --> 00:30:06,450
code in a lot of system to run events as

00:30:02,129 --> 00:30:08,970
well the way we implement this this

00:30:06,450 --> 00:30:10,980
discrepancy is that we have an outer

00:30:08,970 --> 00:30:13,110
loop that you can see here in context

00:30:10,980 --> 00:30:15,840
prototype execute and it's basically a

00:30:13,110 --> 00:30:18,389
loop where if the code that you run in

00:30:15,840 --> 00:30:21,809
vm execute throws this specific

00:30:18,389 --> 00:30:23,879
exception of vm pause or vm yield where

00:30:21,809 --> 00:30:25,860
this code does ability jumps up and goes

00:30:23,879 --> 00:30:27,210
back to the event handler returns to the

00:30:25,860 --> 00:30:29,850
event loop and then next time we come

00:30:27,210 --> 00:30:32,220
around we've a run code again so this is

00:30:29,850 --> 00:30:35,100
essentially how we implement the ability

00:30:32,220 --> 00:30:36,749
to take a job of thread and at any time

00:30:35,100 --> 00:30:39,419
we can d schedule it so the system can

00:30:36,749 --> 00:30:41,490
do something else and of course this is

00:30:39,419 --> 00:30:43,830
also how to implement multitasking Java

00:30:41,490 --> 00:30:45,600
a multi-threaded system all you have to

00:30:43,830 --> 00:30:46,889
do is basically several of these things

00:30:45,600 --> 00:30:48,330
post it and then you essentially have

00:30:46,889 --> 00:30:53,130
several threats that are running at the

00:30:48,330 --> 00:30:54,630
same time all right

00:30:53,130 --> 00:30:56,370
I promise that you will look at raise

00:30:54,630 --> 00:30:58,800
exception and don't very most of this is

00:30:56,370 --> 00:31:00,510
not interesting the only piece of really

00:30:58,800 --> 00:31:02,760
interesting is the very bottom of this

00:31:00,510 --> 00:31:04,260
if you look at the integer array the you

00:31:02,760 --> 00:31:06,480
and eight array that we are generating

00:31:04,260 --> 00:31:09,180
there what you're actually seeing there

00:31:06,480 --> 00:31:12,330
is that your hand assembling some byte

00:31:09,180 --> 00:31:15,030
code inside that method so when we are

00:31:12,330 --> 00:31:17,430
trying to raise an exception it actually

00:31:15,030 --> 00:31:19,620
turns out we cannot directly raise the

00:31:17,430 --> 00:31:22,170
exception instead they're generating a

00:31:19,620 --> 00:31:24,660
fake java method that we put onto our

00:31:22,170 --> 00:31:27,900
java stack that we implementing in

00:31:24,660 --> 00:31:29,970
javascript the reason you have to do

00:31:27,900 --> 00:31:33,300
that is that there are several steps

00:31:29,970 --> 00:31:37,560
necessary to throw an exception and each

00:31:33,300 --> 00:31:39,540
of these steps can fail individually the

00:31:37,560 --> 00:31:41,540
only way I can handle that for example

00:31:39,540 --> 00:31:44,520
the only way I can properly handle

00:31:41,540 --> 00:31:47,910
throwing an exception while throwing an

00:31:44,520 --> 00:31:50,280
exception is if I have a second method

00:31:47,910 --> 00:31:52,020
in between there so what for example can

00:31:50,280 --> 00:31:54,420
happen is let's say you're trying to

00:31:52,020 --> 00:31:58,020
throw a specific exception with a name

00:31:54,420 --> 00:31:59,340
acts and that name doesn't exist then in

00:31:58,020 --> 00:32:01,890
that case the vm would throw an

00:31:59,340 --> 00:32:04,440
exception telling you that a class could

00:32:01,890 --> 00:32:05,850
not be found and when you're throwing

00:32:04,440 --> 00:32:07,500
that exception you might want out of

00:32:05,850 --> 00:32:09,780
memory which case the vm is going to

00:32:07,500 --> 00:32:11,430
throw a lot of memory exception so you

00:32:09,780 --> 00:32:13,230
have to have this cascading the assault

00:32:11,430 --> 00:32:15,270
in essence this thing this is synthetic

00:32:13,230 --> 00:32:17,750
methods that we are throwing in between

00:32:15,270 --> 00:32:20,010
the stack this is very neat because on

00:32:17,750 --> 00:32:21,320
the simple structure of JavaScript

00:32:20,010 --> 00:32:23,700
allows us to do is very efficiently

00:32:21,320 --> 00:32:26,240
because we're using this UN day to race

00:32:23,700 --> 00:32:28,530
to actually store the stack frames I

00:32:26,240 --> 00:32:31,350
mentioned a couple minutes ago the

00:32:28,530 --> 00:32:34,140
concept of natives natives are in Java a

00:32:31,350 --> 00:32:36,600
way to call to the operating system or

00:32:34,140 --> 00:32:38,220
the underlying code in JavaScript of

00:32:36,600 --> 00:32:41,550
course there's no notion of that we

00:32:38,220 --> 00:32:42,930
simply call the Dom or or into functions

00:32:41,550 --> 00:32:46,410
that implement it in a JavaScript

00:32:42,930 --> 00:32:48,720
library so freely for this VM native

00:32:46,410 --> 00:32:53,280
methods are essentially implementations

00:32:48,720 --> 00:32:56,490
of code in JavaScript in throw cc or C++

00:32:53,280 --> 00:32:59,010
of course it is a very simple Vater

00:32:56,490 --> 00:33:00,930
implementers what we essentially do is

00:32:59,010 --> 00:33:03,360
when you're calling a method you supply

00:33:00,930 --> 00:33:05,250
the name in the bytecode and we have a

00:33:03,360 --> 00:33:06,970
little override list where we look into

00:33:05,250 --> 00:33:09,429
do we have a native

00:33:06,970 --> 00:33:12,070
his name and if the is so they execute

00:33:09,429 --> 00:33:14,380
that JavaScript code instead of trying

00:33:12,070 --> 00:33:15,880
to call a java method in interpreter you

00:33:14,380 --> 00:33:17,799
can see a couple of moment a shins here

00:33:15,880 --> 00:33:20,049
we essentially just calls on native

00:33:17,799 --> 00:33:24,850
JavaScript written code that implements

00:33:20,049 --> 00:33:31,049
those Java functions all right almost

00:33:24,850 --> 00:33:34,270
done one thing we did not expect is that

00:33:31,049 --> 00:33:35,919
just how slow this would be so and if

00:33:34,270 --> 00:33:37,870
you get under this this point we're

00:33:35,919 --> 00:33:40,780
about 100 times slower than the

00:33:37,870 --> 00:33:45,159
application running on the future phone

00:33:40,780 --> 00:33:47,650
and that was really unexpected because

00:33:45,159 --> 00:33:49,990
most of time if you look at Java it

00:33:47,650 --> 00:33:52,929
really runs a lot of the complex

00:33:49,990 --> 00:33:55,030
operations in native code the reason for

00:33:52,929 --> 00:33:58,600
this is that back when was Java was

00:33:55,030 --> 00:34:00,940
first written there were no comparison

00:33:58,600 --> 00:34:02,470
for java it's a lot of the lot of the

00:34:00,940 --> 00:34:05,380
drama programs could not do a lot of

00:34:02,470 --> 00:34:07,150
heavy computation in Java itself so the

00:34:05,380 --> 00:34:11,200
Java language started to provide a lot

00:34:07,150 --> 00:34:13,149
of native see implementations of very

00:34:11,200 --> 00:34:15,639
complex functionality to compensate for

00:34:13,149 --> 00:34:17,169
the fact that Java was so slow so we

00:34:15,639 --> 00:34:20,349
really expected that even if you have a

00:34:17,169 --> 00:34:24,609
slow vm for java you should be a little

00:34:20,349 --> 00:34:26,139
closer to usable than 100 x away it

00:34:24,609 --> 00:34:28,780
turns out that the main reason for this

00:34:26,139 --> 00:34:30,760
being this slow is that there's some

00:34:28,780 --> 00:34:33,159
very frequently called things in any

00:34:30,760 --> 00:34:35,200
programming language let's say comparing

00:34:33,159 --> 00:34:39,460
two strings this is called in java

00:34:35,200 --> 00:34:42,639
equals in java all these things are

00:34:39,460 --> 00:34:44,740
implemented in Java itself so if you're

00:34:42,639 --> 00:34:46,389
comparing two strings you have to call

00:34:44,740 --> 00:34:47,859
this function here and don't worry I

00:34:46,389 --> 00:34:49,629
will not try to read through this what

00:34:47,859 --> 00:34:51,849
this does all you have to remember is

00:34:49,629 --> 00:34:53,619
that there's like 80 bytes or so of

00:34:51,849 --> 00:34:56,290
instructions in here and I highlighted

00:34:53,619 --> 00:34:58,119
is read a loop that's inside of this so

00:34:56,290 --> 00:34:59,890
what this code does it has a whole bunch

00:34:58,119 --> 00:35:03,250
of checking with its video string and

00:34:59,890 --> 00:35:04,900
then it goes to that loop and it for

00:35:03,250 --> 00:35:06,790
every single character it individually

00:35:04,900 --> 00:35:09,160
compares whether it matches the other

00:35:06,790 --> 00:35:11,650
string or not and then returns true or

00:35:09,160 --> 00:35:14,980
false and of course each of these steps

00:35:11,650 --> 00:35:18,550
in this program or Java VM written

00:35:14,980 --> 00:35:20,650
JavaScript has to interpret so comparing

00:35:18,550 --> 00:35:23,559
two strings in this Java

00:35:20,650 --> 00:35:26,410
em with this role is horribly slow we

00:35:23,559 --> 00:35:27,910
did a low profile using using the dev

00:35:26,410 --> 00:35:30,010
tools and you could you need to see that

00:35:27,910 --> 00:35:33,970
most of the time was spent in five or

00:35:30,010 --> 00:35:35,980
six functions like this so a very easy

00:35:33,970 --> 00:35:37,869
way to fix that of course is to use the

00:35:35,980 --> 00:35:39,880
same mechanism we just solve as native

00:35:37,869 --> 00:35:41,680
methods a native method again is

00:35:39,880 --> 00:35:44,140
something that we implemented JavaScript

00:35:41,680 --> 00:35:46,630
instead of in Java so they can simply

00:35:44,140 --> 00:35:49,150
take shortcuts so I have a little native

00:35:46,630 --> 00:35:51,220
method that overrides the pure Java

00:35:49,150 --> 00:35:52,779
implementation and it goes ahead and

00:35:51,220 --> 00:35:54,849
simply check that it's a string and if

00:35:52,779 --> 00:35:56,619
so it has a string compare at a

00:35:54,849 --> 00:35:58,960
JavaScript level that's of course

00:35:56,619 --> 00:36:01,119
massively faster because the JavaScript

00:35:58,960 --> 00:36:02,470
vm in the browser knows how is that very

00:36:01,119 --> 00:36:04,359
efficiently you don't have to be like

00:36:02,470 --> 00:36:07,630
circle that interpreter loop all the

00:36:04,359 --> 00:36:10,289
time so after the dis work of course we

00:36:07,630 --> 00:36:13,630
expected things to get a lot better and

00:36:10,289 --> 00:36:16,660
it did get a lot better it got like ten

00:36:13,630 --> 00:36:19,599
times faster or so but it was still kind

00:36:16,660 --> 00:36:21,640
of painfully slow to use and the reason

00:36:19,599 --> 00:36:23,470
for that probably is that actually Java

00:36:21,640 --> 00:36:26,079
has advanced fight a bit since it's

00:36:23,470 --> 00:36:28,029
early days and today most of time when

00:36:26,079 --> 00:36:31,660
you run Java programs you actually also

00:36:28,029 --> 00:36:34,299
compile them over to an x86 or arm

00:36:31,660 --> 00:36:36,309
machine code so even on this simple

00:36:34,299 --> 00:36:38,109
feature phones this lecture compiler

00:36:36,309 --> 00:36:39,369
built in that takes the bytecode and

00:36:38,109 --> 00:36:41,260
then instead of just running an

00:36:39,369 --> 00:36:42,819
interpreter it generates machine code

00:36:41,260 --> 00:36:44,740
from the by code and then runs that

00:36:42,819 --> 00:36:47,079
machine code and since we still had an

00:36:44,740 --> 00:36:49,299
interpreter we were slower than the

00:36:47,079 --> 00:36:54,309
teacher phone systems to the point where

00:36:49,299 --> 00:36:55,779
the app was not really usable so the the

00:36:54,309 --> 00:37:00,849
next step of course is how to compile

00:36:55,779 --> 00:37:02,859
Java in JavaScript and this seemed like

00:37:00,849 --> 00:37:05,020
a really daunting task for anyone was

00:37:02,859 --> 00:37:07,960
written compilers so for those of you at

00:37:05,020 --> 00:37:09,520
the the the curse or privilege whichever

00:37:07,960 --> 00:37:12,160
way you want to see it to have written a

00:37:09,520 --> 00:37:14,500
compiler generating code in a compiler

00:37:12,160 --> 00:37:16,390
it's like the most painful part of

00:37:14,500 --> 00:37:19,359
compilers because machine code is so

00:37:16,390 --> 00:37:21,490
hard to read and very hard to target and

00:37:19,359 --> 00:37:23,710
it's also the most exciting thing to

00:37:21,490 --> 00:37:25,329
debug like this does you have not debug

00:37:23,710 --> 00:37:26,890
in your life until you have trying to

00:37:25,329 --> 00:37:28,990
debug some machine code that goes wrong

00:37:26,890 --> 00:37:30,910
on you you try to understand what the

00:37:28,990 --> 00:37:32,710
hell happens there in some like binary

00:37:30,910 --> 00:37:34,630
machine code you're looking at

00:37:32,710 --> 00:37:36,250
so they go to this point just seemed

00:37:34,630 --> 00:37:39,490
pretty scary quite honestly because

00:37:36,250 --> 00:37:42,960
every time I had done it before it was a

00:37:39,490 --> 00:37:47,050
really daunting task to deal with

00:37:42,960 --> 00:37:49,300
fortunately this is JavaScript right and

00:37:47,050 --> 00:37:51,880
it is it is not machine language it's

00:37:49,300 --> 00:37:53,320
not x86 and it's not armed and it's a

00:37:51,880 --> 00:37:55,869
lot easier to do this in JavaScript and

00:37:53,320 --> 00:37:58,089
this was almost unexpected for us if you

00:37:55,869 --> 00:38:01,270
look at the compiler that is in j2me

00:37:58,089 --> 00:38:04,540
DOJ's that is probably the smallest java

00:38:01,270 --> 00:38:06,580
compiler i've ever seen if you think

00:38:04,540 --> 00:38:08,140
about it for a moment what it does it

00:38:06,580 --> 00:38:10,810
takes a Java code and of course emits

00:38:08,140 --> 00:38:11,859
javascript code from it it all the

00:38:10,810 --> 00:38:13,690
sudden of course makes a lot of sense

00:38:11,859 --> 00:38:15,700
that it's a very small compiler because

00:38:13,690 --> 00:38:17,770
what you're doing is almost like an

00:38:15,700 --> 00:38:19,720
inversion javascript is actually a much

00:38:17,770 --> 00:38:21,339
more semantically rich language than

00:38:19,720 --> 00:38:23,140
Java and there's much more powerful

00:38:21,339 --> 00:38:25,750
primitives what we're doing is you're

00:38:23,140 --> 00:38:29,740
busy taking Java and we are lowering it

00:38:25,750 --> 00:38:32,230
to this much higher representation this

00:38:29,740 --> 00:38:35,820
is very easy because many things where

00:38:32,230 --> 00:38:38,349
you have to painfully assemble in on

00:38:35,820 --> 00:38:41,740
machine code instructions for Java are

00:38:38,349 --> 00:38:42,970
very very trivial to do in javascript we

00:38:41,740 --> 00:38:45,030
also harnessed a couple of other tricks

00:38:42,970 --> 00:38:48,130
to make this process particularly easy

00:38:45,030 --> 00:38:51,430
when you're trying to compile Java over

00:38:48,130 --> 00:38:55,240
to JavaScript we try to use edge as much

00:38:51,430 --> 00:38:57,520
of the JavaScript semantics itself so

00:38:55,240 --> 00:39:00,580
for example Java objects are represented

00:38:57,520 --> 00:39:01,869
through one JavaScript object they're

00:39:00,580 --> 00:39:03,670
not trying to implement our own garbage

00:39:01,869 --> 00:39:07,270
collector we are not trying to implement

00:39:03,670 --> 00:39:08,770
many other pieces of the Java VM but

00:39:07,270 --> 00:39:10,990
traditionally you have to implement in

00:39:08,770 --> 00:39:12,580
some native language so by making our

00:39:10,990 --> 00:39:14,470
Java implementation match very very

00:39:12,580 --> 00:39:16,420
closely what the JavaScript language

00:39:14,470 --> 00:39:19,960
does the actual compilation approach

00:39:16,420 --> 00:39:21,040
itself becomes really trivial so this

00:39:19,960 --> 00:39:23,230
what compilation looks like and this

00:39:21,040 --> 00:39:25,780
will look eerie familiar to you if you

00:39:23,230 --> 00:39:27,820
remember the execute loop it essentially

00:39:25,780 --> 00:39:29,290
does the same thing that the execute

00:39:27,820 --> 00:39:31,750
function did there's a compile function

00:39:29,290 --> 00:39:34,270
you go over the bike code in sequence

00:39:31,750 --> 00:39:36,520
and for every byte code operation you

00:39:34,270 --> 00:39:38,530
simply omit some code and code in this

00:39:36,520 --> 00:39:40,390
case is simply a string if we define up

00:39:38,530 --> 00:39:43,270
there and we concatenate into that

00:39:40,390 --> 00:39:45,250
string operations in JavaScript that

00:39:43,270 --> 00:39:46,390
basically emulate the stack nature of

00:39:45,250 --> 00:39:48,609
Java

00:39:46,390 --> 00:39:51,039
execute operations that Java is

00:39:48,609 --> 00:39:54,760
executing this turned out to be really a

00:39:51,039 --> 00:39:56,710
very easy way to compile code this part

00:39:54,760 --> 00:40:00,760
was really easy but was a lot less easy

00:39:56,710 --> 00:40:02,710
is actually trying to run that code we

00:40:00,760 --> 00:40:04,690
are running the stuff in an environment

00:40:02,710 --> 00:40:06,940
where content security policies are

00:40:04,690 --> 00:40:08,529
enforced and if you don't know what it

00:40:06,940 --> 00:40:09,549
is I recommend you go and read right

00:40:08,529 --> 00:40:13,059
after this talk because it's very

00:40:09,549 --> 00:40:15,130
important that you know what it is photo

00:40:13,059 --> 00:40:19,119
so you don't know yet CSP survey how you

00:40:15,130 --> 00:40:21,970
can restrict web applications from doing

00:40:19,119 --> 00:40:23,440
dangerous things NFL is one of those

00:40:21,970 --> 00:40:25,750
things that pretty dangerous because if

00:40:23,440 --> 00:40:28,299
you have stuff coming in from the user

00:40:25,750 --> 00:40:30,099
and it somehow gets into Avelle that's

00:40:28,299 --> 00:40:32,200
usually where things go wrong and some

00:40:30,099 --> 00:40:34,329
someone is going to take over your code

00:40:32,200 --> 00:40:35,619
and inject some code so we are in an

00:40:34,329 --> 00:40:38,170
environment where we can actually not

00:40:35,619 --> 00:40:40,359
use a vowel so we can compile it a Java

00:40:38,170 --> 00:40:42,339
program just find a JavaScript but then

00:40:40,359 --> 00:40:45,720
we cannot actually a valid because the

00:40:42,339 --> 00:40:47,859
eval function itself is disallowed I

00:40:45,720 --> 00:40:49,930
unfortunately don't have time to go all

00:40:47,859 --> 00:40:51,099
the evil details but it takes to bypass

00:40:49,930 --> 00:40:54,490
that but essentially what we are doing

00:40:51,099 --> 00:40:56,170
is we are firing up a new iframe and you

00:40:54,490 --> 00:40:58,450
load the code in that you I frame and

00:40:56,170 --> 00:41:01,750
that iframe kind of post messages us

00:40:58,450 --> 00:41:05,140
back and forth um as we execute code and

00:41:01,750 --> 00:41:06,940
it actually even works so um this was in

00:41:05,140 --> 00:41:09,099
surprising to me one of the other

00:41:06,940 --> 00:41:10,930
authors Nick on this project came up

00:41:09,099 --> 00:41:12,490
with this idea and it's pretty insane if

00:41:10,930 --> 00:41:14,049
you really would like to see some fun

00:41:12,490 --> 00:41:18,369
code or recommend you take a look at

00:41:14,049 --> 00:41:21,160
that all right now we had a demo part of

00:41:18,369 --> 00:41:22,990
this it seems that the convention is

00:41:21,160 --> 00:41:24,849
when missoula comes to demo or at least

00:41:22,990 --> 00:41:27,519
when a muscle as CTO comes to demo

00:41:24,849 --> 00:41:29,970
something at a jsf conference you have

00:41:27,519 --> 00:41:31,930
to show some sort of live demo and

00:41:29,970 --> 00:41:33,839
Brandon already set the precedent that

00:41:31,930 --> 00:41:37,059
it usually is a game that you're playing

00:41:33,839 --> 00:41:39,849
there is no quake for j2me as far as i

00:41:37,059 --> 00:41:42,369
know so i picked the second closest

00:41:39,849 --> 00:41:43,990
thing I could find and this is a live

00:41:42,369 --> 00:41:50,799
demo so if it doesn't work I'm very

00:41:43,990 --> 00:41:55,869
sorry let's see where my bookmarks there

00:41:50,799 --> 00:41:58,000
we go so this is the asteroids java game

00:41:55,869 --> 00:42:00,330
that is common on these on these phones

00:41:58,000 --> 00:42:03,600
and great there's a loose

00:42:00,330 --> 00:42:09,450
is screwing here I cannot get to my

00:42:03,600 --> 00:42:11,450
storage button see that's great slive

00:42:09,450 --> 00:42:13,830
debugging here all right now it works

00:42:11,450 --> 00:42:15,150
all right so I can go to menu here so

00:42:13,830 --> 00:42:16,590
this is all the java stuff it's running

00:42:15,150 --> 00:42:18,900
this is the interpreter loop running

00:42:16,590 --> 00:42:21,590
here running this asteroid game this is

00:42:18,900 --> 00:42:24,810
a jar file is that you an open source

00:42:21,590 --> 00:42:26,730
j2me game you can find on the web GPL

00:42:24,810 --> 00:42:28,620
it's really great if you have to get

00:42:26,730 --> 00:42:30,900
back a vm if you have a program you have

00:42:28,620 --> 00:42:32,100
the source code for find try to debug

00:42:30,900 --> 00:42:35,280
with something that you only have to buy

00:42:32,100 --> 00:42:36,960
quote for its really painful so here

00:42:35,280 --> 00:42:40,560
this is this a touch events from the

00:42:36,960 --> 00:42:42,720
browser that are sent over to the Java

00:42:40,560 --> 00:42:44,460
VM and I can go ahead here and start

00:42:42,720 --> 00:42:46,950
this everything you see here like this

00:42:44,460 --> 00:42:49,020
this very ugly yellow you I this is all

00:42:46,950 --> 00:42:51,450
rendered in Java unlike 14 year old Java

00:42:49,020 --> 00:42:57,810
code that runs on these phones and I can

00:42:51,450 --> 00:42:59,700
start this and then I'm live demo I can

00:42:57,810 --> 00:43:01,740
I move my ship so this is unfortunate um

00:42:59,700 --> 00:43:06,060
let's see if you if you can do this

00:43:01,740 --> 00:43:07,290
we'll start this again no I cannot all

00:43:06,060 --> 00:43:08,700
right I cannot tell you why I cannot

00:43:07,290 --> 00:43:10,980
move my ship right now it worked in a

00:43:08,700 --> 00:43:12,750
room there you can believe me or not but

00:43:10,980 --> 00:43:14,370
in theory I would we give you like live

00:43:12,750 --> 00:43:17,040
demo right now next time I'm definitely

00:43:14,370 --> 00:43:23,460
record this not show this life alright

00:43:17,040 --> 00:43:25,650
let's go back to our slides all right

00:43:23,460 --> 00:43:27,030
before I don't have time first of all

00:43:25,650 --> 00:43:29,790
thank you very much for listening to me

00:43:27,030 --> 00:43:31,950
going on about Java and JavaScript and

00:43:29,790 --> 00:43:34,020
VMS Whitney JavaScript I would like to

00:43:31,950 --> 00:43:36,660
acknowledge a couple people that have

00:43:34,020 --> 00:43:38,970
worked on this project as many of the

00:43:36,660 --> 00:43:41,220
other projects that are started in the

00:43:38,970 --> 00:43:43,440
past it's usually me who gets to do the

00:43:41,220 --> 00:43:44,700
first fun couple of weeks and a bunch of

00:43:43,440 --> 00:43:46,200
people have to come in who have to like

00:43:44,700 --> 00:43:48,300
do months of hard work to actually make

00:43:46,200 --> 00:43:49,950
it work so there's a whole bunch of

00:43:48,300 --> 00:43:51,900
people for missoula and also outside

00:43:49,950 --> 00:43:53,790
contributors to help the j2me get it to

00:43:51,900 --> 00:43:56,220
the point where it can run java

00:43:53,790 --> 00:43:57,270
applications and i recommend you look up

00:43:56,220 --> 00:43:58,710
their names since you're interested in

00:43:57,270 --> 00:44:02,580
the code for this it's all up on github

00:43:58,710 --> 00:44:06,140
and check it out and run some j2me stuff

00:44:02,580 --> 00:44:06,140

YouTube URL: https://www.youtube.com/watch?v=I7hZ8I9G5KA


