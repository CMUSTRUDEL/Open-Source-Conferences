Title: Marijn Haverbeke: Salvaging contentEditable: Building a Robust WYSIWYG Editor | JSConf EU 2015
Publication date: 2015-10-18
Playlist: JSConf EU 2015
Description: 
	Web-based WYSIWYG editors are notorious for spitting out a distasteful HTML soup. In this talk Iâ€™ll show how I implemented an editor that, instead of trying to filter and clean this soup, takes control away from the browserâ€™s contentEditable implementation, and reinterpret user actions as operations on our own semantic document model (i.e. not HTML). The result is a WYSIWYM (what you see is what you mean) editor, more predictable than classic WYSIWYG, and just as user friendly.

Intro music by @halfbyte
Captions: 
	00:00:26,640 --> 00:00:38,070
Thank you, so what I am going to talk about here today is how to build a WYSIWYM editor

00:00:38,070 --> 00:00:41,230
in the browser.

00:00:41,230 --> 00:00:46,390
By what you see is what you mean, we usually mean something like what you see is what you

00:00:46,390 --> 00:00:52,530
get, WYSIWYG where you have a visual representation of you content and can just edit that in the

00:00:52,530 --> 00:01:00,260
obvious classical way, but instead of editing things like

00:01:00,260 --> 00:01:08,890
font size margins you are editing semantic information so you get reduced cleaner representation

00:01:08,890 --> 00:01:15,910
of the document where you say this is a paragraph, this is a link, and not this is Georgia 15

00:01:15,910 --> 00:01:19,270
pixels italic.

00:01:19,270 --> 00:01:25,280
This is usually beneficial when you want to have users edit content and you then later

00:01:25,280 --> 00:01:31,320
want to use it in a different layout in a different context or you want to inspect it,

00:01:31,320 --> 00:01:37,990
and transform it somehow, it's very useful to have semantic information about the content

00:01:37,990 --> 00:01:41,660
rather than just layout information.

00:01:41,660 --> 00:01:49,950
So, my newest project is called ProseMirror I am going to be talking about CodeMirror

00:01:49,950 --> 00:01:58,640
and ProseMirror you shouldn't confuse them, ProseMirror is a semantic rich text editor,

00:01:58,640 --> 00:02:04,710
so something like a WYSIWYG but for clean content.

00:02:04,710 --> 00:02:12,930
This was recently launched and open sourced and it's my attempt to build an editor where

00:02:12,930 --> 00:02:20,070
you can define a schema for you content and have the editor automatically enforce that

00:02:20,070 --> 00:02:25,910
and provide the user with editing actions that stay within your schema so if you have

00:02:25,910 --> 00:02:32,070
for example your Github you have you document model that includes references to issues and

00:02:32,070 --> 00:02:38,130
commits you can't extend your document model to have first clause now it's links to commits

00:02:38,130 --> 00:02:45,750
or links to users or whatever and have your users actually be working with a data model

00:02:45,750 --> 00:02:50,209
that corresponds to what you actually want to work with.

00:02:50,209 --> 00:02:59,010
ProseMirror also supports collaborative editing and is generally I hope the future of in-browser

00:02:59,010 --> 00:03:01,959
prose writing.

00:03:01,959 --> 00:03:08,180
So yeah I am going to be talking about how it's implemented and a major factor in any

00:03:08,180 --> 00:03:17,290
kind of rich text editing implementation is the browser API called contentEditable.

00:03:17,290 --> 00:03:26,500
This is what enables many browser almost all in-browser WYSIWYGs to exist at all if you

00:03:26,500 --> 00:03:35,790
talk to people who have worked with it you will get complaints and lots of horrible stories.

00:03:35,790 --> 00:03:40,129
So let me give a bit of background history.

00:03:40,129 --> 00:03:47,620
So the year is 1979, Microsoft is on a roll when it comes to browser they just ported

00:03:47,620 --> 00:03:53,569
JavaScript, introduced dynamic DOM manipulation then I guess I don't really know what happened

00:03:53,569 --> 00:03:59,010
but assume someone there said let's make our browser and editor so people can write HTML

00:03:59,010 --> 00:04:02,760
in the browser it's a very commendable idea.

00:04:02,760 --> 00:04:11,440
What they ended up doing in IE 4 is introducing a feature called designMode a property you

00:04:11,440 --> 00:04:18,669
set on your document which makes the whole document editable what it means is still not

00:04:18,669 --> 00:04:25,289
completely clear there's no spec that covers this you can type into it you can back space

00:04:25,289 --> 00:04:35,530
out stuff and a companion to this API is document.exec command which your scripts can call string

00:04:35,530 --> 00:04:44,000
like bold or italic or insert ordered list or delete to perform other editing actions

00:04:44,000 --> 00:04:45,750
on the document.

00:04:45,750 --> 00:04:54,830
What you could do since IE 4 is create a frame, set to it be editable and then bind some key

00:04:54,830 --> 00:05:04,300
binding and buttons some various exec command codes you would have a basic WYSIWYG editor.

00:05:04,300 --> 00:05:11,130
This has worked since 1997, then in 2000 they added a second feature very simple to that

00:05:11,130 --> 00:05:17,280
called contentEditable this is the same as designMode but per DOM node instead of the

00:05:17,280 --> 00:05:18,590
whole document.

00:05:18,590 --> 00:05:24,700
You don't have to create an iFrame you can just in your existing content set the switch

00:05:24,700 --> 00:05:30,349
to make it editable to let your users add something to a piece of your page then save

00:05:30,349 --> 00:05:33,390
it somehow.

00:05:33,390 --> 00:05:34,390
Other

00:05:34,390 --> 00:05:40,159
important thing you could do since this feature was introduced was set pieces of an editable

00:05:40,159 --> 00:05:46,849
DOM node to be non editable you could set it back to false to be inside of the node,

00:05:46,849 --> 00:05:53,270
that means that well the users can edit text round it but they can't move their cursor

00:05:53,270 --> 00:05:55,570
into that node and start editing there.

00:05:55,570 --> 00:06:00,280
This is also a big improvement, it allows you to protect some part of your document

00:06:00,280 --> 00:06:06,760
or insert widgets that are not necessarily editable.

00:06:06,760 --> 00:06:12,810
So, this was pretty much before the big JavaScript boom but people were slowly starting to use

00:06:12,810 --> 00:06:21,810
this at some point it become really wide spread, I think CK editors from the early 2000s not

00:06:21,810 --> 00:06:28,200
sure when tiny MC started they were libraries reping this and people using content management

00:06:28,200 --> 00:06:30,270
systems.

00:06:30,270 --> 00:06:39,520
At Mozilla there was a feeling we have to do something like this, it's a useful feature,

00:06:39,520 --> 00:06:44,730
but they didn't quite like what Microsoft had done, and this was the browser war so

00:06:44,730 --> 00:06:50,200
it was not like there was a very good communication of standards process.

00:06:50,200 --> 00:06:55,279
They spent sometime trying to come up with a better solution but they never really agreed

00:06:55,279 --> 00:06:56,880
on something.

00:06:56,880 --> 00:07:02,140
So in the end they said ok we'll just do what Internet Explorer does so we're no longer

00:07:02,140 --> 00:07:05,750
left out when it comes to rich text editor in-browser.

00:07:05,750 --> 00:07:12,930
So they copied this feature, of course it didn't exactly copy it they some parts of

00:07:12,930 --> 00:07:17,830
it were no use they left those out, they thought they knew better solutions for some other

00:07:17,830 --> 00:07:23,740
parts for example where IE would add text if you made something bold, they said no we

00:07:23,740 --> 00:07:27,539
have CSS that font width on them.

00:07:27,539 --> 00:07:38,550
IE had the feature on both major browsers then and a few years later, actually took

00:07:38,550 --> 00:07:47,830
until 2007 which is past the JavaScript boom that Firefox also added support for contentEditable,

00:07:47,830 --> 00:07:54,240
and then the other browsers Safari, Chrome, Opera, all also took up the feature and implemented

00:07:54,240 --> 00:08:02,050
it one way or another and now it's kind of considered part of the expected API in a modern

00:08:02,050 --> 00:08:07,620
graphical browser.

00:08:07,620 --> 00:08:11,090
So why is this a good thing?

00:08:11,090 --> 00:08:16,650
The other controls that we have to implement editing in a browser are text area and text

00:08:16,650 --> 00:08:17,830
input.

00:08:17,830 --> 00:08:25,010
Both of which are constrained to atomic blobs of plain text you can't really do many of

00:08:25,010 --> 00:08:31,480
the things you want to do with them like doing rich text in them is a non starter and even

00:08:31,480 --> 00:08:36,830
adding some helpful widgets or syntax highlighting is almost impossible to do on top of text

00:08:36,830 --> 00:08:39,200
area.

00:08:39,200 --> 00:08:45,580
So it's great then we have an alternative that we can do solid rich text editing or

00:08:45,580 --> 00:08:51,810
more or less solid rich text editing in a browser, things like content management systems

00:08:51,810 --> 00:08:59,050
that exist entirely online, earlier code editors were also based on this.

00:08:59,050 --> 00:09:02,690
This is wonderful.

00:09:02,690 --> 00:09:14,910
Except of course, it has problems a major thing HTML scope is not gigantic, you might

00:09:14,910 --> 00:09:25,130
not want that whole scope for example, first version of CodeMirror it was based on contentEditable

00:09:25,130 --> 00:09:31,710
images links whole tables into the editor I had to somehow deal with this.

00:09:31,710 --> 00:09:38,450
So you can do that you can filter content, you properly want to filter the content anyway,

00:09:38,450 --> 00:09:44,020
it comes out of this by default, it's very, very ugly.

00:09:44,020 --> 00:09:52,550
So that modern WYSIWYG browsers have pretty advanced mechanisms for cleaning out the HTML

00:09:52,550 --> 00:09:59,980
inside of the editor, but then there's still all the browser differences, there's no spec,

00:09:59,980 --> 00:10:01,220
each browser.

00:10:01,220 --> 00:10:07,830
This is a very big scope of what editing HTML really means, there's cursor motion through

00:10:07,830 --> 00:10:13,130
tables, adding columns to table, what happens when you present enter in a definition list,

00:10:13,130 --> 00:10:18,110
what exactly is the cursor position if it's moving across the boundaries of block elements,

00:10:18,110 --> 00:10:19,920
what is a valid cursor position.

00:10:19,920 --> 00:10:27,830
These are all valid questions, they came up with slightly different answers to them.

00:10:27,830 --> 00:10:29,580
Then there's bugs.

00:10:29,580 --> 00:10:30,580
Many

00:10:30,580 --> 00:10:31,580
bugs.

00:10:31,580 --> 00:10:36,640
The feeling I get is that no-one really maybe except for the few engineers that started

00:10:36,640 --> 00:10:41,550
this thing, no-one really felt like implementing this but it was something that is needed and

00:10:41,550 --> 00:10:47,000
expected and so all the browser vendors had to somehow ad this dragon of a sub browser

00:10:47,000 --> 00:10:54,470
that interacted with everything in all kinds of horrible ways, bugs with language and bug

00:10:54,470 --> 00:11:00,050
trackers for years an years it seems no-one really cared all that much.

00:11:00,050 --> 00:11:06,560
The situation has recently improved, currently on modern browsers you can really make some

00:11:06,560 --> 00:11:11,800
assumptions about what is going to happen to your HTML as the user is editing it, didn't

00:11:11,800 --> 00:11:17,320
used to be the case in CodeMirror 1, I have just piles and piles of workarounds to deal

00:11:17,320 --> 00:11:19,030
with all these weird issues.

00:11:19,030 --> 00:11:27,690
It was only a text editor, it will be a lot worse if you actually support rich content.

00:11:27,690 --> 00:11:36,680
So, people really got annoyed with this and then there is a generation of editors, it

00:11:36,680 --> 00:11:43,460
started with code editors, who just say, "Ok, we're not going to touch this at all, we'll

00:11:43,460 --> 00:11:50,190
figure something out ourselves, we implement everything, so we implement our own selection,

00:11:50,190 --> 00:11:56,920
just the DOM is not actually editable, we pretend it is by capturing events and changing

00:11:56,920 --> 00:12:04,620
your documents you see on the screen in response to these events."

00:12:04,620 --> 00:12:11,800
The first one to pull this off was the Ace code editor at that point I was still messing

00:12:11,800 --> 00:12:18,120
about with contentEditable in my own code editing, I thought ok this is clearly superior,

00:12:18,120 --> 00:12:24,790
I just dropped content editor and never went back.

00:12:24,790 --> 00:12:32,810
Google docs, uses this, what you see blinking on the green is a little gif that's hidden

00:12:32,810 --> 00:12:40,610
and shown periodically, you can very far, on desk top browsers you can get a good editing

00:12:40,610 --> 00:12:45,560
experience using this technique.

00:12:45,560 --> 00:12:51,550
At some point you do run into problems, if you maintain your own selection entirely,

00:12:51,550 --> 00:12:57,490
you get all the complexity of bi directional text on your plate you have to implement what

00:12:57,490 --> 00:13:02,600
the cursor is supposed to be doing, if it moves right to left, then enters left to right

00:13:02,600 --> 00:13:12,960
text and there is an island of... if you are mixing Arabic or Hebrew or other scripts you

00:13:12,960 --> 00:13:19,040
get islands inside of your paragraphs that are running in different directions, people

00:13:19,040 --> 00:13:20,040
need like this.

00:13:20,040 --> 00:13:25,360
Like Arabic or Hebrew writers really need this to be work, you can't do much with your

00:13:25,360 --> 00:13:32,030
editor if it doesn't work, it's gigantically difficult to get it right.

00:13:32,030 --> 00:13:37,779
The content menu should shows cut and paste, if you click on it, if you have a non-editable

00:13:37,779 --> 00:13:45,350
gif there, it won't know.

00:13:45,350 --> 00:13:50,050
You can find the hex for this, the hex for this is to pop-up a tiny transparent text

00:13:50,050 --> 00:13:56,490
area under the cursor when the user right clicks and hooks up the right thing when he

00:13:56,490 --> 00:14:03,480
cuts or pastes, you can get it to work but it's painful or awkward.

00:14:03,480 --> 00:14:10,410
Then, mobile interfaces, touch interfaces became widespread and the integration Between

00:14:10,410 --> 00:14:20,840
the selection and touch interface is very deep and very subtle, producing a native selection,

00:14:20,840 --> 00:14:25,400
a native field to manipulate the selection when you are not actually letting the browser

00:14:25,400 --> 00:14:32,320
know about the selection is almost impossible, I don't think anyone has pulled it off yet.

00:14:32,320 --> 00:14:36,300
So this may not be the right solution either.

00:14:36,300 --> 00:14:43,380
So maybe let's meet in the middle and this is the idea that prompted ProseMirror, give

00:14:43,380 --> 00:14:51,710
the editor the visible DOM, when the user does something and it generates an event,

00:14:51,710 --> 00:15:01,270
we step in and say doing do anything browser, we'll handle this and get - isolate this from

00:15:01,270 --> 00:15:08,740
a lot of the horrors of contentEditable, the random manipulation by the DOM is no longer

00:15:08,740 --> 00:15:15,380
happens, it allows us to define the model and be the

00:15:15,380 --> 00:15:23,390
only one touching that, in the older approach the DOM is your document model.

00:15:23,390 --> 00:15:30,160
You don't keep your own copy of the data you let the DOM determine what the document looks

00:15:30,160 --> 00:15:35,150
like, you don't know what the browser will do with this, it's like building on quicksand,

00:15:35,150 --> 00:15:41,680
things might change, notes that you somehow depending on existing might be replaced by

00:15:41,680 --> 00:15:53,790
a copy, having full control offer your document model is a very useful thing to do and I think

00:15:53,790 --> 00:16:04,779
some of the other WYSIWYGs that have cropped up recently are also moving in this direction.

00:16:04,779 --> 00:16:05,779
.

00:16:05,779 --> 00:16:09,390
Yeah, ProseMirror is designed from the ground up with the assumption that we have a document

00:16:09,390 --> 00:16:16,160
model and then there is a DOM, the DOM is a view on the document model, the document

00:16:16,160 --> 00:16:23,420
is solid we have it entirely, when it's changed we update the DOM ourselves and show the user

00:16:23,420 --> 00:16:34,250
the pseudo editable thing, it's supposed to be editable but we don't let them edict directly,

00:16:34,250 --> 00:16:41,130
the selection is not a real selection you can manipulate on a touch interface, bi directional

00:16:41,130 --> 00:16:45,410
cursor motion by bi directional text can be left through the browser, we dent want to

00:16:45,410 --> 00:16:49,270
think about that, that saves complexity.

00:16:49,270 --> 00:16:54,620
Of course implementing our own document model and all possible changes is also a lot of

00:16:54,620 --> 00:17:00,620
complexity, but this is complexity I think you want as a text editor, you want to define

00:17:00,620 --> 00:17:04,020
it in one predictable, well-defined way.

00:17:04,020 --> 00:17:12,930
You want to make them customisable, you want to cut out the browser when it comes to that.

00:17:12,930 --> 00:17:20,130
So I'm going to go into ProseMirror document model for a bit, three base much like the

00:17:20,130 --> 00:17:28,240
DOM, if you have a document with a list of three items, it looks something like this.

00:17:28,240 --> 00:17:35,590
You get a list now or three item notes, paragraph notes with some text content in it.

00:17:35,590 --> 00:17:40,730
One thing that it does very differently from the DOM it's a persistent data structure,

00:17:40,730 --> 00:17:46,400
so if you update it you create a new version and the old version is untouched, so you just

00:17:46,400 --> 00:17:48,929
don't go in there and start adding children, I don't know where.

00:17:48,929 --> 00:17:58,530
There is a well-defined set of possible updates and you apply an update to get a new document.

00:17:58,530 --> 00:18:03,000
This is not as expensive as it sounds, it can do data sharing if you an item to this

00:18:03,000 --> 00:18:11,090
list here, you just reuse the old item notes and make a copy of the document and the list

00:18:11,090 --> 00:18:16,630
notes, the fourth child in the list notes, you are only copying two notes rather than

00:18:16,630 --> 00:18:20,550
your whole document structure.

00:18:20,550 --> 00:18:25,830
Another thing that ProseMirror does differently from the DOM, when you have in line content

00:18:25,830 --> 00:18:34,250
this is how you represent a paragraph with a bees of link and note text in it, you create

00:18:34,250 --> 00:18:40,900
a subtree with for example a strong note and you put the content that's strong under that.

00:18:40,900 --> 00:18:47,380
ProseMirror actually makes linear, where in line paragraph content is always a sequence

00:18:47,380 --> 00:18:54,270
of pieces of text with styling information and images or notes that can appear here,

00:18:54,270 --> 00:18:58,880
they don't nest, beyond the paragraph level there is no nesting you can see how this is

00:18:58,880 --> 00:19:00,770
harder to read than this.

00:19:00,770 --> 00:19:05,950
It's the same when you are dealing with it in code, a lot of the things you want to do

00:19:05,950 --> 00:19:10,900
are much easier on this, for example, verifying that you are not emphasising a piece of text

00:19:10,900 --> 00:19:18,320
twice, it's trivial and this tree representation is a pain in the... tree representation similarly

00:19:18,320 --> 00:19:25,460
if we want to represent positions in the paragraph we can just a character offset and we

00:19:25,460 --> 00:19:28,520
don't have to worry about tree relations.

00:19:28,520 --> 00:19:35,800
So this was a big win and made it easier to define a lot of things.

00:19:35,800 --> 00:19:39,190
So let's see what happens when ProseMirror captures events.

00:19:39,190 --> 00:19:45,080
You have your editor, it's rendered a piece of editable DOM corresponding to the document

00:19:45,080 --> 00:19:52,590
it has itself in memory software, and someone presses 'A', we capture an event for that

00:19:52,590 --> 00:19:55,920
and create a change object.

00:19:55,920 --> 00:20:02,390
Changes in ProseMirror are first class objects which you can store and pass around and we'll

00:20:02,390 --> 00:20:04,000
come back to that later.

00:20:04,000 --> 00:20:08,990
Then we apply the change object to our current documents, get the new documents, make that

00:20:08,990 --> 00:20:16,600
the current documents and schedule a DOM update, similarly if you press 'Backspace', you just

00:20:16,600 --> 00:20:22,650
compute what you want to be deleting with backspace, create a change, take the content

00:20:22,650 --> 00:20:29,260
of the clipboard, pass it into our document format and replace the selection with this

00:20:29,260 --> 00:20:35,260
document fragment to get another change object.

00:20:35,260 --> 00:20:40,429
Updating the DOM is then done by, as I scheduling updates using request information frames,

00:20:40,429 --> 00:20:46,799
the next time the browser does an actual redraw it will first run are code which is responsible

00:20:46,799 --> 00:20:52,390
for making sure the DOM reflects the current document the nice thing about the persistent

00:20:52,390 --> 00:20:59,130
dock searches we can do pretty much react, we can div the document with the current document

00:20:59,130 --> 00:21:04,540
and make the changes only that are necessary to the DOM to move to the new document, this

00:21:04,540 --> 00:21:13,559
is insanely efficient and fast, we can just do one point to compare, ok, nothing changed

00:21:13,559 --> 00:21:16,240
here and move on to the next note.

00:21:16,240 --> 00:21:28,420
Of course it's not entirely perfect, in some cases parses do not fire good events, - you

00:21:28,420 --> 00:21:35,580
write click and choose another spelling of this world, then it will just modify the DOM

00:21:35,580 --> 00:21:40,700
and then say, "Input", meaning something changed, you don't know anything about it.

00:21:40,700 --> 00:21:46,300
So, we have to deal with that and in this case we just take the part of the DOM, like

00:21:46,300 --> 00:21:51,559
the block elements around the cursor, reparse those, div those with our understanding of

00:21:51,559 --> 00:21:57,559
what those parts of that document look like and arrive at change from that, fortunately

00:21:57,559 --> 00:22:04,740
I've only run into this problem for simple textual changes and deriving a simple text

00:22:04,740 --> 00:22:13,210
change is safe, nothing weird can happen there, so far this is working well I'm still expecting

00:22:13,210 --> 00:22:17,400
at some point to run into more problems here.

00:22:17,400 --> 00:22:28,100
So, having all these persistent objects representing everything in a nice value way, we can define

00:22:28,100 --> 00:22:36,410
a kind of algebra of changes, the basic operation is applying the change to a document.

00:22:36,410 --> 00:22:41,780
Here we have a blue thing for a document and an orange thing for a change and we apply

00:22:41,780 --> 00:22:48,290
that getting a new document, in this case we delete the part in 0 paragraph between

00:22:48,290 --> 00:22:58,809
character off set 2 and 8, we get a new document object and also a map.

00:22:58,809 --> 00:23:06,340
A map is a position map, it's a way to associate positions in the pre-change version of the

00:23:06,340 --> 00:23:11,470
document with positions in the post change document, in this case we can query this map

00:23:11,470 --> 00:23:18,630
to ask cursor position in the first paragraph at position 11 in the old document, where

00:23:18,630 --> 00:23:19,750
is this in the new document.

00:23:19,750 --> 00:23:26,160
It will say, "It's positioned 05", meaning the fifth character in the first... this is

00:23:26,160 --> 00:23:31,470
mainly used for making the cursor move as the document changes, so it shouldn't jump

00:23:31,470 --> 00:23:33,640
around but stay in its position.

00:23:33,640 --> 00:23:36,720
There is a bunch of nice things you can

00:23:36,720 --> 00:23:42,560
do with this, like checking pieces of the document you just create two positions in

00:23:42,560 --> 00:23:48,059
the document around the part you are interested in, you keep mapping those to the new document

00:23:48,059 --> 00:23:54,780
and you end up knowing where the text you are checking ended up, it's also essential

00:23:54,780 --> 00:24:01,430
for collaborative editing, it allows us by mapping the positions associated with the

00:24:01,430 --> 00:24:07,490
change object to move changes from one document to another version of that document.

00:24:07,490 --> 00:24:15,700
So, for example, if we had beyond this delete operation we had another change object saying,

00:24:15,700 --> 00:24:25,220
"Insert a character at position 11", we can now say that same change but applied to the

00:24:25,220 --> 00:24:32,450
second document is, insert the same character at position 5, so if you have a collaborative

00:24:32,450 --> 00:24:40,360
editing set up and two users make it concurrently, one of them will end up going first and the

00:24:40,360 --> 00:24:46,780
other one will have this change that they have made, but that they're not able to apply

00:24:46,780 --> 00:24:49,940
to the current document because the document changed in the meantime.

00:24:49,940 --> 00:24:55,670
They can use this approach to take the change that the other user made, move their own changeover

00:24:55,670 --> 00:25:01,770
it and then apply it and retry pushing it to the server, so it's kind of like, get to

00:25:01,770 --> 00:25:07,350
base, you try to push, you get a conflict, you try to rebase locally and then you try

00:25:07,350 --> 00:25:12,770
to repush again, it works quite well, there is quite a bit to it actually, you can find

00:25:12,770 --> 00:25:20,222
a long discrimination on my blog, it works quite well, it's a relatively simple and solid

00:25:20,222 --> 00:25:21,780
way to do collaborative editing.

00:25:21,780 --> 00:25:28,340
There is more applications of this, say change tracking, if you just keep a history of all

00:25:28,340 --> 00:25:32,929
your changes, you can always find out where a piece of the document originated, stuff

00:25:32,929 --> 00:25:34,470
like that.

00:25:34,470 --> 00:25:40,270
I'm sure there is more, we haven't really explored this far yet, but it's a nice place

00:25:40,270 --> 00:25:42,280
to, nice basis to build on.

00:25:42,280 --> 00:25:47,770
Then I want to, very briefly talk about the future.

00:25:47,770 --> 00:25:55,090
So, the W 3 C is working on an update to this contentEditable standard which would allow

00:25:55,090 --> 00:26:01,330
a new mode of contentEditable, where you are supposed to do exactly this, the document

00:26:01,330 --> 00:26:08,570
isn't editable, you are supposed to capture events and edit the inventory yourself, then

00:26:08,570 --> 00:26:12,820
they will also have to define a few more events for stuff like the spell checking issue that

00:26:12,820 --> 00:26:20,960
I showed before and a bunch more like this, but yeah, that would be nice because it relives

00:26:20,960 --> 00:26:28,500
the browser vendors of maintaining this whole horrible blob of code and it gives editor

00:26:28,500 --> 00:26:34,730
implementers a view of how to implement a robust solid editor, without going insane

00:26:34,730 --> 00:26:37,750
in the process.

00:26:37,750 --> 00:26:42,410
Of course, you never know when W 3 C standard will actually end up in browsers, but I'm

00:26:42,410 --> 00:26:46,809
told that browsers are enthusiastic about this, probably for the reasons I mentioned,

00:26:46,809 --> 00:26:51,080
it will probably be happening, but the specification isn't finished yet, it will probably be a

00:26:51,080 --> 00:26:53,380
long time.

00:26:53,380 --> 00:27:00,420
This is the URLs, the ProseMirror.net and Github.com/ProseMirror.

00:27:00,420 --> 00:27:11,679
Feel free to play with it, it's not finished yet but it works as it is, the major big thing

00:27:11,679 --> 00:27:18,030
that has to improve is the API or language for defining your own document schemers and

00:27:18,030 --> 00:27:24,020
having flexible for all the things you might want in your document schemer.

00:27:24,020 --> 00:27:31,200
We are having a meet up on Monday around this project here in Berlin, if you think you might

00:27:31,200 --> 00:27:38,760
be interested, go to discuss.ProseMirror.net, a discussion forum and one of the topics is

00:27:38,760 --> 00:27:39,760
this

00:27:39,760 --> 00:27:42,650
meet up, you are welcome to apply as well.

00:27:42,650 --> 00:27:44,710
That's it, thank you for listening.

00:27:44,710 --> 00:27:44,880

YouTube URL: https://www.youtube.com/watch?v=EEF2DlOUkag


