Title: Olga Madejska: Breaking Bad - Web Components in production, what worked for us | JSConf EU 2015
Publication date: 2015-10-07
Playlist: JSConf EU 2015
Description: 
	Imagine many teams distributed over the globe working on different services. Each team is small enough to be fed with two large pizzas. Got that? Welcome to AWS! This is what makes us successful, but it also brings its own challenges. One of them is ensuring accessibility, performance, and consistency across all our UIs. Because of this we chose to explore Web Components in the last year and I want to share what we have learned. I will go over the current state and support of all Web Components building blocks. It will get technical fast as I tell you why polyfills did not work for us. We continued to investigate the underlying technology and wrote our own library that I want to share with you. As no goal can be achieved by ‘only’ producing code, I will also explain what I did in addition.

Intro music by @halfbyte
Captions: 
	00:00:23,170 --> 00:00:32,070
Hi, guys, my name is Olga,i'm UX the designer at AWS, this is my colleague Thomas, we create

00:00:32,070 --> 00:00:39,199
the team responsible for making developer enslavers easier. We did that beginning last

00:00:39,199 --> 00:00:44,970
year, this year, sorry, last year for me, no, this year and we want to tell you what

00:00:44,970 --> 00:00:49,750
we learned along the way in the last couple of months and we want to talk about the first

00:00:49,750 --> 00:00:58,400
project we actually did in AWS, and I will start by explaining why there's a big challenge

00:00:58,400 --> 00:01:04,190
to create user interfaces on a large scale. So, you probably kind of have used some of

00:01:04,190 --> 00:01:09,960
our services before, they're pretty massi, but there's also a ‑‑ massive, there's

00:01:09,960 --> 00:01:16,640
creative aspecting in creating use erspaces. After that, Olga will continue with the Web

00:01:16,640 --> 00:01:24,560
Components part of the talk, why that failed, and what we did instead. Let me start with

00:01:24,560 --> 00:01:33,109
talking about Amazon web services, we, as an organization, are splitted into very small

00:01:33,109 --> 00:01:38,039
different independent teams, and each team can work independently of each other. And

00:01:38,039 --> 00:01:44,759
the purpose of each team is to create a service for our customers or for other teams internally.

00:01:44,759 --> 00:01:53,009
And the challenge there is how all of these build their products, and we don't have any

00:01:53,009 --> 00:01:58,939
speaker notes. But, there's also an upside to kind of the structure, so there's a couple

00:01:58,939 --> 00:02:04,380
of different things that make us stick to this operational structure, which is kind

00:02:04,380 --> 00:02:09,429
of each team can inindependently decide on what they do and what technologies they use

00:02:09,429 --> 00:02:18,610
to solve that problem. And ‑‑ sorry, we're having technical difficulties here.

00:02:18,610 --> 00:02:20,860
If you already would see the next slide, I can continue probably.

00:02:20,860 --> 00:02:23,990
Sorry. Now, that's the speaker notes, that's cheating,

00:02:23,990 --> 00:02:29,950
don't read this. (Laughing). There we go. All right. So, the next slide.

00:02:29,950 --> 00:02:37,730
Awesome. Kind of we measure the success, for example also in our output, last year, not

00:02:37,730 --> 00:02:44,930
sure if you're following what we're doing, last year we launched 516 larger interface

00:02:44,930 --> 00:02:51,700
features or port features, or even completely new services that kind of comes down to one

00:02:51,700 --> 00:03:00,640
and half large deployment store interface, which you might have seen. I'm not talking

00:03:00,640 --> 00:03:05,670
about all the other small deployments we're doing, if you follow other talks or seen other

00:03:05,670 --> 00:03:09,959
talks, like, just the amount of deployments we do every day is just blind blowing, just

00:03:09,959 --> 00:03:14,750
don't really get how you do that. Part of the organizational structure where you have

00:03:14,750 --> 00:03:19,689
all these tiny dependent teams can decide on the technology completely the frameworks

00:03:19,689 --> 00:03:25,079
whatever they want to use to be most effective. The thing is thatment cos with a challenge,

00:03:25,079 --> 00:03:30,250
like most large companies we have a design, but we don't have a design guide on one team

00:03:30,250 --> 00:03:47,819
implementing, we have a ton of different teams trying to implement the design guide. We talked about that ‑‑

00:03:47,819 --> 00:03:55,030
like not all designers understand how time me meant that, not everyone that implements

00:03:55,030 --> 00:04:01,709
understand designs, that's actual live examples, we thought, we have to do something about

00:04:01,709 --> 00:04:11,129
that, and the first project we're creating, designer as code, and I wanted to improve

00:04:11,129 --> 00:04:16,220
on that, the idea was to build something in code that was always in line with design guides

00:04:16,220 --> 00:04:24,150
and works across all different frameworks, our reality is they use GOT ‑‑ whatever,

00:04:24,150 --> 00:04:28,590
they pick their tools, and it needs to be easy to integrate on whatever's being used

00:04:28,590 --> 00:04:36,940
inindependent of the teams are using. This is how we started our first experiment.

00:04:36,940 --> 00:04:42,950
Okay, so when you think about these requirements what comes to your mind immediately is, Ooohh

00:04:42,950 --> 00:04:50,660
we're going to use web components, Web Components are a series of technology, Shadow DOM, HTML

00:04:50,660 --> 00:04:58,330
imports and templates you can think of them as reusable interface widgets that are encapsulated

00:04:58,330 --> 00:05:03,040
and basically reusable, so this is what we would like to use, the two most interesting

00:05:03,040 --> 00:05:08,750
technologies that are part of Web Components is for Shadow DOM and Custom Elements, this

00:05:08,750 --> 00:05:13,200
is exactly what we would like to use when building our components, this basically solves

00:05:13,200 --> 00:05:19,330
our problem. So what is Shadow DOM? Shadow DOM offers encapsulation of CSS templates

00:05:19,330 --> 00:05:25,290
and JavaScript in a download, this is pretty cool. Now we have custom Elements, which basically

00:05:25,290 --> 00:05:34,510
allow you to create your own HTML tags, so, looking at the custom Elements, what can you

00:05:34,510 --> 00:05:41,500
do with them? So basically you can say, instead of a select you can create an AWS UI select

00:05:41,500 --> 00:05:46,470
and that select can behave in a completely different way. I side that select, you can

00:05:46,470 --> 00:05:50,350
have, instead of normal options that behave and look in a given way, you can have AWS

00:05:50,350 --> 00:05:57,090
U I options that is pretty cool. You might think, okay, why did we actually need those

00:05:57,090 --> 00:06:03,960
Custom Elements, it was already possible beforehand to add your own custom tags to HTML and your

00:06:03,960 --> 00:06:08,780
browser would render them and they would behave in a given way and you would be able to style

00:06:08,780 --> 00:06:15,060
them even (AWSUI) the real cool thing about using Custom Elements, by using them you get

00:06:15,060 --> 00:06:21,060
life cycle call backs. That are they, actually life cycle call backs notify you when something

00:06:21,060 --> 00:06:26,060
happens to your Element. When you Element is created you get a created call back, when

00:06:26,060 --> 00:06:30,460
you Element is added to the together, you get an attached call back, and at that point

00:06:30,460 --> 00:06:35,000
you might want to add event listeners, notify the Element's parent that the Element has

00:06:35,000 --> 00:06:40,520
been created and so on. Also, same thing happens when you remove your Element from view, you

00:06:40,520 --> 00:06:45,270
get a detach call back, you might handle garage collection at this point, you might want to

00:06:45,270 --> 00:06:50,680
memory management, you night want to remove the event handlers that you created. It's

00:06:50,680 --> 00:06:56,400
all cool. And this actually you get only when you use Custom Elements, what happens when

00:06:56,400 --> 00:07:02,270
you register an Element in the browser is that it uses the HTML Element interface instead

00:07:02,270 --> 00:07:08,110
of using the HTML unknown Element interface when you actually don't use Custom Elements,

00:07:08,110 --> 00:07:16,710
so this is what makes it so cool. We look at browser ‑‑ Shadow DOM and Elements

00:07:16,710 --> 00:07:24,460
are support in the Chrome, we can see that the standard is just not there yet. So what

00:07:24,460 --> 00:07:29,660
we tried doings was using polyfills to basically back fill the missing browser function faulty,

00:07:29,660 --> 00:07:36,270
you probably know web component JS polyfill for all technologies that are under Web Components,

00:07:36,270 --> 00:07:41,110
if you tonight want the use a full polyfill, you can use a smaller one, so we chose to

00:07:41,110 --> 00:07:47,690
use document register Elements as a polyfill for Custom Elements. Those polyfills are really

00:07:47,690 --> 00:07:52,840
good, I mean they work great, but mostly when they're used as a mainframe work in your application,

00:07:52,840 --> 00:07:58,090
if you tray using them with different frameworks, in our case we tried using them with Angular,

00:07:58,090 --> 00:08:05,940
you run into all sorts of problems with those polyfills. So what are those problems? Basically

00:08:05,940 --> 00:08:14,920
all polyfills use mow take observers check that has been change in the your component.

00:08:14,920 --> 00:08:24,260
How it works in practice is if your component changes you want to be notified. It doesn't

00:08:24,260 --> 00:08:38,440
just observe components it observes the whole DOM. This has an impact on performance. ‑‑ you'll

00:08:38,440 --> 00:08:43,820
get notified about it, but maybe a bit later, once you call a function you get notified

00:08:43,820 --> 00:08:48,899
immediately, it works a little bit difficultly and can cause a lot of problems when using

00:08:48,899 --> 00:08:54,160
that together with frameworks that rely on certain things being done at certain points.

00:08:54,160 --> 00:09:00,959
Also, the implementation doviers per browser, so not all browsers support mutation observers,

00:09:00,959 --> 00:09:06,069
some of them support an older technology that's called mutation events, and those mutation

00:09:06,069 --> 00:09:12,500
events work synchronously, not only do we have to care about if you do the native thing

00:09:12,500 --> 00:09:17,819
or if we use mutation observers, but also about the version of the browser that we're

00:09:17,819 --> 00:09:24,779
actually using because we might end up using something completely different. So to summarize,

00:09:24,779 --> 00:09:29,339
web components are not there yet, we can't use them to solve our problems, we were also

00:09:29,339 --> 00:09:34,939
unable to use the polyfills because they didn'tplay play nasally with the frameworks we were using.

00:09:34,939 --> 00:09:39,629
What we found out is the concept they're using in Web Components are really good concepts

00:09:39,629 --> 00:09:46,629
we started looking into actually using those concepts to build our own Custom Elements.

00:09:46,629 --> 00:09:54,850
And this is how our second experiment started. . So let's build a component together. This

00:09:54,850 --> 00:10:01,870
is a native AWSUI alert, you see them quite often, notify your user about something in

00:10:01,870 --> 00:10:06,019
your application, in terms of the verbals, this is how we could the ‑‑ of the verbals

00:10:06,019 --> 00:10:11,329
we can use them for alert, this is what our design guide says an alert should look like.

00:10:11,329 --> 00:10:16,860
Let's build an alert, the first thing we need to do is create the Elements, but we would

00:10:16,860 --> 00:10:21,740
like to be able to use exactly in the same way as we would use a Custom Element, so we

00:10:21,740 --> 00:10:29,370
would like to get life cycle call backs. So what we need to do fist is ‑‑ el, append

00:10:29,370 --> 00:10:33,970
that Element to the body, because we don't have Element ‑‑ have to call has been

00:10:33,970 --> 00:10:43,730
attached. At the end we only get a download, so we get ‑‑ something to this. That's

00:10:43,730 --> 00:10:49,060
cool, now we would like to be able to interact with our components somehow, we would like

00:10:49,060 --> 00:10:55,430
to maybe be able to change how it looks and how it behaves. So for that we have to find

00:10:55,430 --> 00:11:00,120
two properties, we have a type and dismissible, the type defines the nature of the order to

00:11:00,120 --> 00:11:06,899
be displayed, success, info, warning, that ever we want, dismissible if you set it, it

00:11:06,899 --> 00:11:11,660
shows a little controller in the UI that allows the user to dismiss the alert. Let's have

00:11:11,660 --> 00:11:18,379
a look at actually interacting with the components, let's say we don't want to have an info alert,

00:11:18,379 --> 00:11:23,430
instead of blue box, we would like it to be red. Let's say it's report .

00:11:23,430 --> 00:11:28,470
So the component changed the component to red, from blue, so we can see ‑‑ we can

00:11:28,470 --> 00:11:34,019
say we have an error alert, what if we want to make it dismissible, we say alert.dismissible

00:11:34,019 --> 00:11:45,269
is true. There we go it gets the little icon, so now the user can dismiss our alert: Speaking

00:11:45,269 --> 00:11:51,149
of interacting with components, actually, maybe in our UI you would like to be able

00:11:51,149 --> 00:11:57,560
to dismiss the alerts, if a user clicks an acknowledge button, let's say, we would like

00:11:57,560 --> 00:12:03,910
to be able to do something similar to this. So for that, we have defined a dismiss function

00:12:03,910 --> 00:12:13,589
that basically removes the alert from view once the user clicks it. But in, like it's

00:12:13,589 --> 00:12:18,980
also super cool, right, it works, but, you would like to be able not only to pass properties

00:12:18,980 --> 00:12:26,230
and strings, but maybe also be able to pass an HTML to elder right. Maybe you want to

00:12:26,230 --> 00:12:34,730
say, I want to set the header and say is header is rocks. And the content of your alert might

00:12:34,730 --> 00:12:46,199
be something using HTML so I'm going to say it minerals involved. How did we do it? We

00:12:46,199 --> 00:12:52,529
added support for regions, what the regions do is basically instead of just taking' string

00:12:52,529 --> 00:12:57,559
they take a whole download and render the down hold as is. So thanks to that you can

00:12:57,559 --> 00:13:09,699
actually enter HTML to work components. Then, obviously, maybe you would like to get notified

00:13:09,699 --> 00:13:14,459
if something happens to your alert, so when the user dismisses it, maybe you would like

00:13:14,459 --> 00:13:19,629
to know about it, maybe to store it somewhere as a preference that a certain user has dismissed

00:13:19,629 --> 00:13:24,689
this type of alert, to never show it again, or maybe if somebody clicks a button you would

00:13:24,689 --> 00:13:32,199
also like to notify, be notified about that. So we ‑‑ you can basically add event

00:13:32,199 --> 00:13:38,149
listeners to our Elements this is pretty easy, so let me demo that, so let's say if a user

00:13:38,149 --> 00:13:42,420
dismisses this alert, we would like to see the browser native alert on the screen and

00:13:42,420 --> 00:13:49,189
it should say, Ooops, so, exactly what the function says, okay, that worked. So you can

00:13:49,189 --> 00:13:54,399
interact with our Element ‑‑ with our components. So, to summarize, we have a complete

00:13:54,399 --> 00:13:59,220
component now, we deal with the life cycle, we create the Elements, we append it to the

00:13:59,220 --> 00:14:05,559
body, we call the life cycle call back, then we set the type of alert, maybe we say success,

00:14:05,559 --> 00:14:10,540
maybe the alert is dismissible if we want the users to dismiss the alert, then we say

00:14:10,540 --> 00:14:16,800
regions, pass in him that. Him set the header and then we add some eventers to our Elements

00:14:16,800 --> 00:14:24,089
(HTML) how do we make sure that the component is being rendered on the page? So for that,

00:14:24,089 --> 00:14:32,749
we use Reactive DOM rendering, so, looking at our alert, let's say it ‑‑ would like

00:14:32,749 --> 00:14:37,170
to ‑‑ it has some content in it, right, but we would like to also be able to set the

00:14:37,170 --> 00:14:42,220
header, but we don't want to render the header if it's not there. So, what we want to do

00:14:42,220 --> 00:14:47,019
is, if the user sets a header, in our alert, we would like to render an icon, we would

00:14:47,019 --> 00:14:53,889
like to show the header text, right? Let me download exactly what we would like to do.

00:14:53,889 --> 00:15:03,329
So as you can see in the demo, the icon class and the header appeared only after I have'ded

00:15:03,329 --> 00:15:08,949
the header, let me remove it and try it again. This is cool, we only ma nip late the Element

00:15:08,949 --> 00:15:13,110
when it's actually ‑‑ manipulate the Element when it's actually needed. We insert

00:15:13,110 --> 00:15:20,550
those things when they're not ‑‑ we don't insert the things when they're not needed.

00:15:20,550 --> 00:15:25,369
It also needed styles, it has to look in a certain way, what we know about our users

00:15:25,369 --> 00:15:31,930
is they're not going to rebuild their whole applications from scratch, the if they want

00:15:31,930 --> 00:15:36,339
to use their components, they won't build a whole new thing, we have to integrate with

00:15:36,339 --> 00:15:41,850
their existing code. What it means for us is that that we can't break people with our

00:15:41,850 --> 00:15:48,449
components, if they want to use our components, we can't bring their code and introduce some

00:15:48,449 --> 00:15:53,899
weird behaviors, what it also means for us is that people are going to have styles that

00:15:53,899 --> 00:15:58,929
might link into our components, that might break our components, so how did we deal with

00:15:58,929 --> 00:16:04,139
this? So basically we have two rules, one rule is if you want to use our component you

00:16:04,139 --> 00:16:10,759
need to guess it in a <div> or Element, basically in your application that use AWSUI class,

00:16:10,759 --> 00:16:16,999
so that way you can use your Element quite safely because if there is a place in your

00:16:16,999 --> 00:16:21,709
App that is obviously broken, if you either Element or ‑‑ anotherrer an Element or

00:16:21,709 --> 00:16:27,879
style, this wouldn't happen. One thing is using our Elements in a given scope. The second

00:16:27,879 --> 00:16:33,529
thing we, do and you can see that here is that, for example, let's say, you use an icon

00:16:33,529 --> 00:16:41,569
class in your CSS, and obviously that icon class has some style tied to it. What we don't

00:16:41,569 --> 00:16:46,470
want to do is we don't want to break your icon class, so if we add our own styles, we

00:16:46,470 --> 00:16:51,759
tonight want the break the code for you, so what we the in the component, in this case

00:16:51,759 --> 00:16:57,309
it's an alert, we free fission all class name in the component with the name of the component,

00:16:57,309 --> 00:17:00,899
that way we can make sure that felon of our styles actually leek out of the component

00:17:00,899 --> 00:17:08,429
and we don't break your code. So, looking at the component, again, this is what you

00:17:08,429 --> 00:17:12,300
would have to write in order to use our component, you would have to create the Element, append

00:17:12,300 --> 00:17:18,809
to the body and then code has been attacheds so on and so on. While this works, I wouldn't

00:17:18,809 --> 00:17:22,240
call it super easy to use, I wouldn't want to use that, but asan Angular developer or

00:17:22,240 --> 00:17:26,809
something you ‑‑ as an Angular developer you would want to write something like this.

00:17:26,809 --> 00:17:35,450
I would love to use this instead of the thing on the top, it's so much easier we created

00:17:35,450 --> 00:17:41,510
frame word wrappers, what are these wrappers, they allow to be able to use the component

00:17:41,510 --> 00:17:47,450
natively in any framework, because the life cycle management is complicated you tonight

00:17:47,450 --> 00:17:51,650
want to do it manually, you don't want to call has been attached or detached when you

00:17:51,650 --> 00:17:58,770
delete the component, what happens is the wrapper code gets like take cares of that

00:17:58,770 --> 00:18:05,610
logic. What we currently have is an Angular GWT, and we're planning on adding more wrappers

00:18:05,610 --> 00:18:12,530
like for React and also for Web Components. How much overmade is that? How much work do

00:18:12,530 --> 00:18:16,620
I need to do to add this wrapper? Well those wrappers are actually quite small and compact,

00:18:16,620 --> 00:18:21,730
it's only a couple hundred of lines of codes for every wrapper, it adds the support to

00:18:21,730 --> 00:18:30,420
use the component natively. Wrappers are not done manually, so they're actually generated

00:18:30,420 --> 00:18:36,410
automatically out of the component code. So how do we do that? Component has an official

00:18:36,410 --> 00:18:42,800
description, that description we call a component definition in the component definition, we

00:18:42,800 --> 00:18:47,700
talk about all the properties, functions, events and regions 245 a single component

00:18:47,700 --> 00:18:53,580
has, and we also add some useful typing information. So for example if you haven't defined the

00:18:53,580 --> 00:18:58,730
property and this prop is required, you'd gel warned about it, it's not that it will

00:18:58,730 --> 00:19:04,650
fail silently and you wouldn't know. These component definitions they're used to generate

00:19:04,650 --> 00:19:10,200
the framework wrappers, we can do more with the component definitions, we use them to

00:19:10,200 --> 00:19:18,140
generate documentation for every component as well as generate tests. So now to evaluate

00:19:18,140 --> 00:19:25,180
our experiments has it been successful? Do we think that designers code has worked for

00:19:25,180 --> 00:19:33,830
us? We think it has, so, since I think July 29th, teams have been using our components in production

00:19:33,830 --> 00:19:39,120
and they're actually liking our components, there's an actual quote from a developer,

00:19:39,120 --> 00:19:43,010
the person claimed we have helped their team to write recodeble ‑‑ reusable code and

00:19:43,010 --> 00:19:51,570
style, they're now also one hundred percent compatible with the AWS design guide. What

00:19:51,570 --> 00:19:58,630
you can see is the graph that shows interaction of customers with our components you can see

00:19:58,630 --> 00:20:05,410
the tendency is growing, that looks pretty good to me. But, we're not going to stop here,

00:20:05,410 --> 00:20:12,530
so, yeah, we're not going to stop here, saying thank you, but it's not a thank you yet. We

00:20:12,530 --> 00:20:18,010
have a lot more frameworks to support and a lot more components to add. And, actually

00:20:18,010 --> 00:20:23,090
we're hoping you'll be able to give us also feedback on the components, and that you'll

00:20:23,090 --> 00:20:29,120
be able to use the components very soon because we're planning to Open Source them. If you

00:20:29,120 --> 00:20:33,440
have any questions, we'd ‑‑ or would like to talk to us about the components, please

00:20:33,440 --> 00:20:39,060
do, we're available during the breaks and also later tonight. And, Thomas is showing

00:20:39,060 --> 00:20:45,870
the little chocolate guy, so the Orange dude, try to look for the Orange dude during the

00:20:45,870 --> 00:20:47,650

YouTube URL: https://www.youtube.com/watch?v=cRTko6m6U4A


