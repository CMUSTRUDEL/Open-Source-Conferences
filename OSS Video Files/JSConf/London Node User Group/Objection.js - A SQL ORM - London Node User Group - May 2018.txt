Title: Objection.js - A SQL ORM - London Node User Group - May 2018
Publication date: 2018-06-04
Playlist: London Node User Group
Description: 
	Objection.js, a SQL ORM - Paul Jensen

Objection.js is a SQL ORM (Object Relational mapping) for Node.js.

In this talk, I will walk you through how the module works, show live examples of it in action, and present the case for considering it in your Node.js projects.

Things that we'll cover are:

Quick setup
- Creating the underlying database schema for your models via Knex.js
- Creating models and executing SQL queries via the models
- Implementing validation in your models with JSON schema
- Defining relationships between models
- Doing graph inserts and updates
- Setting up a GraphQL API with the objection-graphql plugin
- Other interesting objection.js plugins

_

My name is Paul Jensen, I'm the author of Manning's "Cross Platform Desktop Applications - Using Node, Electron, and NW.js". You can find me on Twitter and Github.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:03,990
hi my school I'm just actually going to

00:00:02,669 --> 00:00:05,120
swap timer as well I just forgot about

00:00:03,990 --> 00:00:08,880
that

00:00:05,120 --> 00:00:10,710
20:46 okay cool so I'm gonna give a talk

00:00:08,880 --> 00:00:12,120
today about a RM called

00:00:10,710 --> 00:00:14,460
objections yes and for those of you

00:00:12,120 --> 00:00:15,980
we're here last month hello it's me

00:00:14,460 --> 00:00:21,810
again

00:00:15,980 --> 00:00:23,250
so no jess has plenty of orm s sequel

00:00:21,810 --> 00:00:26,789
eyes is one that comes to mind up so

00:00:23,250 --> 00:00:30,300
using MongoDB using Mongoose and so you

00:00:26,789 --> 00:00:32,219
know why consider another sometimes a

00:00:30,300 --> 00:00:34,860
fresh take on an existing challenge can

00:00:32,219 --> 00:00:37,250
offer something better and so for your

00:00:34,860 --> 00:00:40,260
consideration I would like to suggest

00:00:37,250 --> 00:00:44,579
objections yes you can find it at Vince

00:00:40,260 --> 00:00:46,110
it's /a objection Jeff so github so some

00:00:44,579 --> 00:00:48,960
of the things that it has as an ORM

00:00:46,110 --> 00:00:50,640
unless you create models for tables with

00:00:48,960 --> 00:00:53,219
es6 classes and defined relationships

00:00:50,640 --> 00:00:55,649
between them you can make queries with

00:00:53,219 --> 00:00:57,510
nodes async/await style which is really

00:00:55,649 --> 00:01:00,030
nice you can add validation to your

00:00:57,510 --> 00:01:01,530
models using json schema you can do

00:01:00,030 --> 00:01:03,719
eager loading transactions with your

00:01:01,530 --> 00:01:06,210
models in what with nested documents in

00:01:03,719 --> 00:01:09,479
rows if you're using Postgres it's got h

00:01:06,210 --> 00:01:11,520
store feature you can do graph inserts

00:01:09,479 --> 00:01:14,010
and updates I'll show you a graph

00:01:11,520 --> 00:01:16,080
inserts later on and you can do some

00:01:14,010 --> 00:01:18,060
more stuff but let's get cracking okay

00:01:16,080 --> 00:01:19,110
so the way you install it is you've got

00:01:18,060 --> 00:01:21,869
to install two dependencies you could

00:01:19,110 --> 00:01:23,880
install next and objection so next J is

00:01:21,869 --> 00:01:26,460
I think it's called next it could be

00:01:23,880 --> 00:01:30,229
called connects I don't know basically

00:01:26,460 --> 00:01:32,280
is a really old-school battle-hardened

00:01:30,229 --> 00:01:35,040
sequel builder that's used in a whole

00:01:32,280 --> 00:01:36,840
bunch of different our rooms so rather

00:01:35,040 --> 00:01:39,090
than reinvent the wheel object said

00:01:36,840 --> 00:01:41,009
we're going to use next you can also use

00:01:39,090 --> 00:01:42,780
it to do database connections pooling

00:01:41,009 --> 00:01:45,360
connections and managing database

00:01:42,780 --> 00:01:47,009
schemas through database migrations

00:01:45,360 --> 00:01:48,390
you'll also need to install a database

00:01:47,009 --> 00:01:50,520
driver as well for whatever sequel

00:01:48,390 --> 00:01:53,909
database you want to use and those are

00:01:50,520 --> 00:01:56,040
some various options so kick off with

00:01:53,909 --> 00:01:58,549
look at a little bit what next does in

00:01:56,040 --> 00:02:00,869
terms of managing database schemas so

00:01:58,549 --> 00:02:02,969
migrations are really good pan for being

00:02:00,869 --> 00:02:05,009
able to manage a databases schema over

00:02:02,969 --> 00:02:07,140
time as you introduce new features and

00:02:05,009 --> 00:02:08,970
as you sort of realize that the first

00:02:07,140 --> 00:02:12,030
initial attempt at a database schema had

00:02:08,970 --> 00:02:13,770
some changes that needed to be made

00:02:12,030 --> 00:02:16,110
later on you've got to

00:02:13,770 --> 00:02:18,570
evolve the database schema so this is

00:02:16,110 --> 00:02:22,110
able to do that straight away and so if

00:02:18,570 --> 00:02:25,200
you just kick off a little script create

00:02:22,110 --> 00:02:27,930
database what it has is two ideas of

00:02:25,200 --> 00:02:31,170
applying migrations up rolling them back

00:02:27,930 --> 00:02:33,030
you climbed down and so the good thing

00:02:31,170 --> 00:02:34,470
of using this approach is that actually

00:02:33,030 --> 00:02:36,360
you can keep the version of your

00:02:34,470 --> 00:02:38,340
database schema and alongside your

00:02:36,360 --> 00:02:40,050
source code and get so you've actually

00:02:38,340 --> 00:02:42,240
got an idea of exactly what the database

00:02:40,050 --> 00:02:47,100
schema was like a particular git commit

00:02:42,240 --> 00:02:49,350
in your project's history and objects

00:02:47,100 --> 00:02:50,340
uses next is built-in support so I'll

00:02:49,350 --> 00:02:52,980
just quickly show you what that looks

00:02:50,340 --> 00:02:56,190
like so you can just run MPX next

00:02:52,980 --> 00:02:57,540
migrate make create tasks table what it

00:02:56,190 --> 00:03:00,600
will go off and do is it will actually

00:02:57,540 --> 00:03:03,570
go and create a migration in the

00:03:00,600 --> 00:03:05,220
migrations folder you'll then have a

00:03:03,570 --> 00:03:09,180
file in there with that name that you

00:03:05,220 --> 00:03:10,470
supplied and then from there you can see

00:03:09,180 --> 00:03:12,750
a timestamp in there so you can organize

00:03:10,470 --> 00:03:14,700
migrations in chronological time order

00:03:12,750 --> 00:03:15,900
rather than just using a integer count

00:03:14,700 --> 00:03:17,700
if you've got loads of developers

00:03:15,900 --> 00:03:18,600
working on a project at same time you

00:03:17,700 --> 00:03:19,920
don't want to use that patent you want

00:03:18,600 --> 00:03:22,590
to use time stamps and that's what it

00:03:19,920 --> 00:03:24,150
does what it shows you in the file is a

00:03:22,590 --> 00:03:25,590
little bit of something like this and

00:03:24,150 --> 00:03:27,420
what you can do is you can just plop in

00:03:25,590 --> 00:03:29,100
some here that just creates a table

00:03:27,420 --> 00:03:30,630
straightaway so we're going to create

00:03:29,100 --> 00:03:33,420
tasks a table so we're creating a task

00:03:30,630 --> 00:03:35,250
so you can say let's have an

00:03:33,420 --> 00:03:37,110
incrementing ID field that's our primary

00:03:35,250 --> 00:03:39,930
key let's have a string field for the

00:03:37,110 --> 00:03:42,420
name the dates the Dubai we're gonna

00:03:39,930 --> 00:03:44,670
have a boolean flag default it to false

00:03:42,420 --> 00:03:47,130
straightaway add some timestamps and

00:03:44,670 --> 00:03:48,840
keeping unique index on the name and

00:03:47,130 --> 00:03:52,500
then the down one is just literally

00:03:48,840 --> 00:03:54,750
let's drop the table unless it exists

00:03:52,500 --> 00:03:57,150
already or if it doesn't and so you've

00:03:54,750 --> 00:03:58,620
got those two existing and you've got

00:03:57,150 --> 00:04:01,530
one that creates one that drops down so

00:03:58,620 --> 00:04:03,930
it's a reverse of your up and then if

00:04:01,530 --> 00:04:06,330
you want to run them you run it you get

00:04:03,930 --> 00:04:08,910
your migration run you'll start you'll

00:04:06,330 --> 00:04:11,430
see at a stable straight away you want

00:04:08,910 --> 00:04:12,720
to roll it back and then you'll see it's

00:04:11,430 --> 00:04:14,670
gone and it's actually really good

00:04:12,720 --> 00:04:15,780
practice to just do this locally often

00:04:14,670 --> 00:04:17,720
so that you can just double check that

00:04:15,780 --> 00:04:20,580
everything works exactly as you expect

00:04:17,720 --> 00:04:22,380
so that when you do in production it's

00:04:20,580 --> 00:04:24,000
less daunting it's just when you've done

00:04:22,380 --> 00:04:26,130
many times before

00:04:24,000 --> 00:04:27,340
some models some models or wrappers

00:04:26,130 --> 00:04:30,160
around database tables

00:04:27,340 --> 00:04:32,860
they help you turn capsule Adak that you

00:04:30,160 --> 00:04:34,660
have within those tables and you can

00:04:32,860 --> 00:04:37,180
create them with ESS classes so good

00:04:34,660 --> 00:04:39,940
example here really nice and simple

00:04:37,180 --> 00:04:41,830
we have you basically get the model from

00:04:39,940 --> 00:04:44,470
objection you've got a database

00:04:41,830 --> 00:04:47,080
connection you pass it in detail model

00:04:44,470 --> 00:04:49,000
to link back through next and then

00:04:47,080 --> 00:04:51,100
you've got this task class extends model

00:04:49,000 --> 00:04:53,760
all you've got to do from the start is

00:04:51,100 --> 00:04:57,580
just tell it what table in the database

00:04:53,760 --> 00:05:01,870
that model links to and that's it and

00:04:57,580 --> 00:05:03,790
then exported jets from there you can

00:05:01,870 --> 00:05:04,960
start to do some math queries so if you

00:05:03,790 --> 00:05:07,000
just want to select everything the task

00:05:04,960 --> 00:05:10,630
table that's what you got to do it's

00:05:07,000 --> 00:05:12,400
just a nice clean simple again same for

00:05:10,630 --> 00:05:13,930
if you want to do a more typical select

00:05:12,400 --> 00:05:17,710
query you just start to use a little bit

00:05:13,930 --> 00:05:19,570
of chaining logic and then that's really

00:05:17,710 --> 00:05:22,120
nice simple again if you want to do an

00:05:19,570 --> 00:05:24,850
insert or that's what you've got to do

00:05:22,120 --> 00:05:28,300
and if you want to delete or do an

00:05:24,850 --> 00:05:31,060
update in this case you just call patch

00:05:28,300 --> 00:05:32,800
instead of swinging like update and then

00:05:31,060 --> 00:05:36,270
if you want to delete it you can do it

00:05:32,800 --> 00:05:38,740
just like that in terms of relationships

00:05:36,270 --> 00:05:40,000
objection dress provides a way to define

00:05:38,740 --> 00:05:42,340
relationships between models that's

00:05:40,000 --> 00:05:44,080
really powerful and flexible and then

00:05:42,340 --> 00:05:45,910
relationships allow you to do other

00:05:44,080 --> 00:05:49,479
things like do eager loading and support

00:05:45,910 --> 00:05:50,710
objects and Jessa's graph QL plug-in so

00:05:49,479 --> 00:05:53,500
here's an example so say you've got a

00:05:50,710 --> 00:05:57,010
toss table and your tasks joins table

00:05:53,500 --> 00:06:00,340
and a task can have many dependencies

00:05:57,010 --> 00:06:02,410
and a task can have many dependents and

00:06:00,340 --> 00:06:05,680
actually it's just a sort of self

00:06:02,410 --> 00:06:07,270
referential join table what we could

00:06:05,680 --> 00:06:10,510
have here is for example we've got a

00:06:07,270 --> 00:06:12,099
separate model for the tasks join there

00:06:10,510 --> 00:06:15,700
is to find it defines its table name and

00:06:12,099 --> 00:06:18,039
then what we can supply in this bit and

00:06:15,700 --> 00:06:21,190
I wonder if I'd there we go yeah that

00:06:18,039 --> 00:06:23,430
little bit you define a function bit

00:06:21,190 --> 00:06:26,110
that you just go relational mappings and

00:06:23,430 --> 00:06:28,539
then you say return an object and your

00:06:26,110 --> 00:06:30,940
objects you can define dependence and

00:06:28,539 --> 00:06:32,919
dependencies that point to the model

00:06:30,940 --> 00:06:35,080
class here so we're just linking it to

00:06:32,919 --> 00:06:36,789
that model we're defining the nature of

00:06:35,080 --> 00:06:40,210
the relation so has many relation comes

00:06:36,789 --> 00:06:41,150
from objection and then on the join we

00:06:40,210 --> 00:06:42,890
just say

00:06:41,150 --> 00:06:44,570
go from the tasks ID and then go to this

00:06:42,890 --> 00:06:45,890
other field inside the table so you just

00:06:44,570 --> 00:06:47,300
to find the two table points there and

00:06:45,890 --> 00:06:49,250
then you've got that available straight

00:06:47,300 --> 00:06:51,200
away and you can also specify

00:06:49,250 --> 00:06:53,780
relationships through join tables so

00:06:51,200 --> 00:06:55,250
this is a little bit more of a using

00:06:53,780 --> 00:06:58,550
that table to then link back to the

00:06:55,250 --> 00:07:00,020
tasks so you thinkin though okay I want

00:06:58,550 --> 00:07:04,010
to go from the tasks ID I want to find

00:07:00,020 --> 00:07:06,560
all of its dependent tasks so we go from

00:07:04,010 --> 00:07:08,830
this and then we go through a another

00:07:06,560 --> 00:07:12,650
table and we'd find in the fruit table

00:07:08,830 --> 00:07:14,360
toss joins a dependency ID to a

00:07:12,650 --> 00:07:17,180
dependent ID and then back to the tasks

00:07:14,360 --> 00:07:20,300
ID and then we just do the inverse for

00:07:17,180 --> 00:07:21,500
the other type of relationship right and

00:07:20,300 --> 00:07:24,860
my example just totally free this is

00:07:21,500 --> 00:07:26,690
doing the dishes so say for example I'm

00:07:24,860 --> 00:07:28,640
using this to manage my life and right

00:07:26,690 --> 00:07:30,470
now I've got four tasks I've got to do

00:07:28,640 --> 00:07:33,320
dishes I've got to buy some dishwashing

00:07:30,470 --> 00:07:34,730
soap by dishcloth and by a good you look

00:07:33,320 --> 00:07:36,830
little yellow sponge with the rough

00:07:34,730 --> 00:07:39,590
green stuff on the top and there's my

00:07:36,830 --> 00:07:41,150
tasks and I realize that I it's not just

00:07:39,590 --> 00:07:42,410
a you know simple list I've actually got

00:07:41,150 --> 00:07:44,450
a link some of the relationships between

00:07:42,410 --> 00:07:46,880
these things so I realize that what I

00:07:44,450 --> 00:07:50,360
want to do is I want to basically link

00:07:46,880 --> 00:07:52,880
the do the dishes to buying a dish

00:07:50,360 --> 00:07:56,120
washing soap by the dishcloth buy a good

00:07:52,880 --> 00:07:58,820
yellow sponge and then I can then do the

00:07:56,120 --> 00:08:01,940
dishes anyway so I have this table join

00:07:58,820 --> 00:08:04,670
I've got the relationship I can then

00:08:01,940 --> 00:08:07,430
just quickly find out what tasks on that

00:08:04,670 --> 00:08:10,580
doing the dishes do I need to do or get

00:08:07,430 --> 00:08:13,220
out before I can do that and so in this

00:08:10,580 --> 00:08:15,890
career I can literally just go I've got

00:08:13,220 --> 00:08:18,380
one of the task elements returned just

00:08:15,890 --> 00:08:19,640
do related query dependent tasks it will

00:08:18,380 --> 00:08:24,500
walk for the chain it will give me back

00:08:19,640 --> 00:08:27,880
the tasks and I do have a simple example

00:08:24,500 --> 00:08:32,660
if I just swap out so look here we go

00:08:27,880 --> 00:08:33,140
now do I go which code I go to crockery

00:08:32,660 --> 00:08:39,920
here we go

00:08:33,140 --> 00:08:42,380
so just quickly punch this way and there

00:08:39,920 --> 00:08:43,850
we go boom so as you can see in this

00:08:42,380 --> 00:08:47,810
I'll just make it a little bit bigger

00:08:43,850 --> 00:08:50,480
because imagine looks tiny there we go

00:08:47,810 --> 00:08:52,910
so I just ran that query and it's given

00:08:50,480 --> 00:08:54,680
me back the free things I need to do my

00:08:52,910 --> 00:08:55,010
dishwashing soap by the dishcloth by

00:08:54,680 --> 00:08:56,720
your life

00:08:55,010 --> 00:08:59,000
plunge so I've got I've bent the

00:08:56,720 --> 00:09:04,130
straightaway back to the presentation

00:08:59,000 --> 00:09:06,740
and then here we go

00:09:04,130 --> 00:09:09,880
so then eager loading eager loading you

00:09:06,740 --> 00:09:12,500
all you've got to do is this you just go

00:09:09,880 --> 00:09:14,450
give me my dependent tasks and give my

00:09:12,500 --> 00:09:17,120
dependency tasks if I want to just see

00:09:14,450 --> 00:09:22,400
the whole graph relationship between my

00:09:17,120 --> 00:09:25,900
tasks I can again go to here we are this

00:09:22,400 --> 00:09:28,070
a little bit chop it in quickly through

00:09:25,900 --> 00:09:31,220
there we go so what you can see here

00:09:28,070 --> 00:09:33,020
you've got three tasks in the very top

00:09:31,220 --> 00:09:35,900
tasks that it are its dependent tasks

00:09:33,020 --> 00:09:37,580
and then the dependency tasks are just

00:09:35,900 --> 00:09:38,750
the ones in the other three so you can

00:09:37,580 --> 00:09:42,230
see those two relationships to find

00:09:38,750 --> 00:09:46,480
their straightaway and then if I now go

00:09:42,230 --> 00:09:50,510
on to so look

00:09:46,480 --> 00:09:52,520
so that's eager loading lifecycle

00:09:50,510 --> 00:09:54,410
functions so lifecycle functions there

00:09:52,520 --> 00:09:56,480
are a way to trigger functions when a

00:09:54,410 --> 00:09:59,120
record ends and so updated deleted

00:09:56,480 --> 00:10:01,070
fetched or validated and they follow a

00:09:59,120 --> 00:10:04,090
pattern of before the action after the

00:10:01,070 --> 00:10:06,500
action so these are the ones that exist

00:10:04,090 --> 00:10:09,860
and you can use them and just to show

00:10:06,500 --> 00:10:12,830
you how they're used so in this case I

00:10:09,860 --> 00:10:16,700
actually get it to set some time stamps

00:10:12,830 --> 00:10:20,210
with JavaScript dates before insert and

00:10:16,700 --> 00:10:23,030
before update just apply those values to

00:10:20,210 --> 00:10:24,290
those fields and then I can set that the

00:10:23,030 --> 00:10:26,390
really cool example I wanted to do that

00:10:24,290 --> 00:10:29,060
in get time was actually to have a

00:10:26,390 --> 00:10:30,590
little web app showing some tasks and in

00:10:29,060 --> 00:10:33,470
the model will do something which would

00:10:30,590 --> 00:10:34,940
like say update tasks in here you know

00:10:33,470 --> 00:10:36,680
send a message on to some queue like in

00:10:34,940 --> 00:10:38,000
Redis that then gets read by something

00:10:36,680 --> 00:10:39,470
that's actually connected WebSockets

00:10:38,000 --> 00:10:41,750
that sends a WebSocket back up to the

00:10:39,470 --> 00:10:44,090
web app that then updates the UI you

00:10:41,750 --> 00:10:45,350
have all this potential to like use

00:10:44,090 --> 00:10:47,450
these and really interesting different

00:10:45,350 --> 00:10:47,900
ways so that's another option you've got

00:10:47,450 --> 00:10:49,220
there

00:10:47,900 --> 00:10:53,000
with using this sort of lifecycle

00:10:49,220 --> 00:10:54,710
functions and the validations so

00:10:53,000 --> 00:10:57,590
objection allows you to add validation

00:10:54,710 --> 00:11:01,910
logic to your those models using JSON

00:10:57,590 --> 00:11:03,500
schema and the validation logic will

00:11:01,910 --> 00:11:05,570
raise errors which can then be incepted

00:11:03,500 --> 00:11:07,850
which I catch so here's a good example

00:11:05,570 --> 00:11:09,139
from one of our internal projects at

00:11:07,850 --> 00:11:12,139
Stockholm

00:11:09,139 --> 00:11:14,720
so basically here you say the schema is

00:11:12,139 --> 00:11:16,910
it's an object for a particular model it

00:11:14,720 --> 00:11:20,980
requires a particular field called batch

00:11:16,910 --> 00:11:23,810
ID you then define what properties exist

00:11:20,980 --> 00:11:27,170
what their types are what formats they

00:11:23,810 --> 00:11:29,629
need if they read only or not and then

00:11:27,170 --> 00:11:31,850
that is used when you're trying to

00:11:29,629 --> 00:11:34,910
create any kind of records or update

00:11:31,850 --> 00:11:37,069
records to then perform validation logic

00:11:34,910 --> 00:11:39,199
for you and it's JSON schema so this is

00:11:37,069 --> 00:11:41,629
actually standard that's out there and

00:11:39,199 --> 00:11:43,610
if you add JSON schema to your models

00:11:41,629 --> 00:11:45,920
you get to do some really cool plugins

00:11:43,610 --> 00:11:48,769
later on so one example I'm gonna show

00:11:45,920 --> 00:11:50,269
you that isn't to do a JSON schema but

00:11:48,769 --> 00:11:52,339
it's cool it's graph inserts Graaf

00:11:50,269 --> 00:11:52,610
inserts are cool just to show you what I

00:11:52,339 --> 00:11:55,399
mean

00:11:52,610 --> 00:11:58,970
my example is again managing my life

00:11:55,399 --> 00:12:00,079
making a nice meal so I will quickly

00:11:58,970 --> 00:12:03,290
actually I don't

00:12:00,079 --> 00:12:06,110
I can code with 100 that's fine so here

00:12:03,290 --> 00:12:07,459
I've got example make a nice meal I've

00:12:06,110 --> 00:12:09,889
got two dependent tasks on that making

00:12:07,459 --> 00:12:11,569
that nice meal decide what to eat get

00:12:09,889 --> 00:12:12,620
recipe and buy the ingredients aren't

00:12:11,569 --> 00:12:15,470
technically that's free ok we're just

00:12:12,620 --> 00:12:17,930
gonna link it to one and then let's make

00:12:15,470 --> 00:12:19,550
the recipe with the ingredients so we've

00:12:17,930 --> 00:12:21,290
got these two dependent tasks that I

00:12:19,550 --> 00:12:24,529
need to do before I can have my master

00:12:21,290 --> 00:12:26,449
no but anyway so quick demo I'm just

00:12:24,529 --> 00:12:29,810
gonna switch out of this and I'm gonna

00:12:26,449 --> 00:12:33,410
go back to where are you graph insert

00:12:29,810 --> 00:12:35,980
here we go so I've got this code nice

00:12:33,410 --> 00:12:39,560
and ready do I need to make a bigger ok

00:12:35,980 --> 00:12:42,139
grab that I'm gonna slide it right in

00:12:39,560 --> 00:12:45,529
here I'll just get that clear boom

00:12:42,139 --> 00:12:49,370
that's what you run and if I now go back

00:12:45,529 --> 00:12:56,199
to this database here what you will see

00:12:49,370 --> 00:12:59,000
is it has credit those three tasks and

00:12:56,199 --> 00:13:00,860
it's done the tasks drawings for me

00:12:59,000 --> 00:13:04,339
these are new there these are all here

00:13:00,860 --> 00:13:06,680
so I didn't have to try and worry about

00:13:04,339 --> 00:13:08,870
the insertion order of all those things

00:13:06,680 --> 00:13:11,990
I could let just go here's a graph work

00:13:08,870 --> 00:13:13,939
how dependencies just insert everything

00:13:11,990 --> 00:13:15,800
and then it just goes and populates it

00:13:13,939 --> 00:13:18,860
and that's quite nice that just saves a

00:13:15,800 --> 00:13:21,699
little bit of time and thinking and then

00:13:18,860 --> 00:13:25,119
if we go to

00:13:21,699 --> 00:13:27,489
okay plugins so there are two really

00:13:25,119 --> 00:13:30,309
cool plugins that are worth checking out

00:13:27,489 --> 00:13:32,169
one of them is objection graph QL and

00:13:30,309 --> 00:13:34,389
the other one is objection password so

00:13:32,169 --> 00:13:35,619
objection password quickly adds local

00:13:34,389 --> 00:13:38,169
authentication to your application using

00:13:35,619 --> 00:13:41,109
bcrypt to apply the salting and the

00:13:38,169 --> 00:13:42,309
hashing setting up is really simple just

00:13:41,109 --> 00:13:46,419
to make sure you've got a password field

00:13:42,309 --> 00:13:47,739
in your database table specified number

00:13:46,419 --> 00:13:50,679
of hashing rounds when encrypting

00:13:47,739 --> 00:13:52,929
password and then make your user model

00:13:50,679 --> 00:13:55,449
an extended class and password class so

00:13:52,929 --> 00:13:57,549
to give an example here so you've got

00:13:55,449 --> 00:13:59,019
this class user extends password model

00:13:57,549 --> 00:14:00,549
so rather than just extending model

00:13:59,019 --> 00:14:03,639
straight away what you want to do is

00:14:00,549 --> 00:14:05,350
pass model into password password is

00:14:03,639 --> 00:14:07,269
required from objection password though

00:14:05,350 --> 00:14:10,449
at the top just specify a number of

00:14:07,269 --> 00:14:12,160
rounds that you want to put in the more

00:14:10,449 --> 00:14:14,529
the more round to put in the more longer

00:14:12,160 --> 00:14:18,220
it will take to sort and hash button

00:14:14,529 --> 00:14:19,689
theory the more securities so here's an

00:14:18,220 --> 00:14:24,089
example of just doing like an insert

00:14:19,689 --> 00:14:27,129
you've got a user name email a password

00:14:24,089 --> 00:14:29,470
when it then gets ya inserted the

00:14:27,129 --> 00:14:32,439
passwords just sorted in hash hash there

00:14:29,470 --> 00:14:33,970
and then when you want to do any

00:14:32,439 --> 00:14:36,009
querying back to sort of doing your

00:14:33,970 --> 00:14:38,139
authentication you can just let you do

00:14:36,009 --> 00:14:40,720
it like this and its really nice and

00:14:38,139 --> 00:14:43,269
simple and that's just like

00:14:40,720 --> 00:14:45,039
authentication just handled at least

00:14:43,269 --> 00:14:46,569
that bit there is many aspects of

00:14:45,039 --> 00:14:49,149
indication but this is like at least

00:14:46,569 --> 00:14:51,369
that bit taken care of and then the

00:14:49,149 --> 00:14:54,939
second plug-in that I'm really really

00:14:51,369 --> 00:14:57,039
enjoying is objection graph QL so

00:14:54,939 --> 00:14:59,739
objection graph QL allows you to put a

00:14:57,039 --> 00:15:02,619
graph QL API on top of your objection

00:14:59,739 --> 00:15:04,539
J's models with a few lines of code and

00:15:02,619 --> 00:15:06,009
you will need to have your models using

00:15:04,539 --> 00:15:08,619
JSON schema in order to get the benefits

00:15:06,009 --> 00:15:11,319
of this so to show you what I mean I'm

00:15:08,619 --> 00:15:14,439
gonna go to a quick little demo again

00:15:11,319 --> 00:15:17,109
another project at star count that we

00:15:14,439 --> 00:15:19,859
did was actually I'll show the project

00:15:17,109 --> 00:15:24,129
quickly because it's cool make a page

00:15:19,859 --> 00:15:27,429
here we are was this no not that this so

00:15:24,129 --> 00:15:30,009
this is a customer dashboard we built

00:15:27,429 --> 00:15:31,539
this for CEOs of companies to basically

00:15:30,009 --> 00:15:33,789
work out what's going on in their

00:15:31,539 --> 00:15:34,630
business from a very top down sales

00:15:33,789 --> 00:15:37,330
custom

00:15:34,630 --> 00:15:38,920
customer segmentations key performance

00:15:37,330 --> 00:15:41,830
indicators that are used to evaluate

00:15:38,920 --> 00:15:43,930
they're mainly retail businesses and we

00:15:41,830 --> 00:15:45,430
basically have this like storing loads

00:15:43,930 --> 00:15:47,650
data and objections used in this case

00:15:45,430 --> 00:15:50,950
and as you click on update it will do

00:15:47,650 --> 00:15:53,260
stuff or not they'll get boom so it's a

00:15:50,950 --> 00:15:55,150
nice way for them to filter in terms of

00:15:53,260 --> 00:15:58,030
the code repo there's all these models

00:15:55,150 --> 00:15:59,860
here there's about 21 models I think off

00:15:58,030 --> 00:16:01,510
the top of my head there's lots of

00:15:59,860 --> 00:16:04,600
models but the really interesting thing

00:16:01,510 --> 00:16:05,680
is I was running a little API for it and

00:16:04,600 --> 00:16:09,370
then I thought well if I can use graph

00:16:05,680 --> 00:16:12,520
QL it turns out you can so to use graph

00:16:09,370 --> 00:16:13,660
QL schema all you've got to do say this

00:16:12,520 --> 00:16:17,320
is all your models you've got a load

00:16:13,660 --> 00:16:19,390
graph cure builder here then you require

00:16:17,320 --> 00:16:22,870
all your models there's nice long list

00:16:19,390 --> 00:16:24,400
and then you pass them in here

00:16:22,870 --> 00:16:25,660
now the reason I do the field name and

00:16:24,400 --> 00:16:27,940
list field name here is because there's

00:16:25,660 --> 00:16:29,770
actually a pluralization bug in the

00:16:27,940 --> 00:16:31,470
plugin at the moment it just adds an

00:16:29,770 --> 00:16:34,840
extra s rather than doing proper

00:16:31,470 --> 00:16:36,700
pluralization but you can basically

00:16:34,840 --> 00:16:41,530
specify this and tell it okay these are

00:16:36,700 --> 00:16:43,330
the different models that I have and

00:16:41,530 --> 00:16:46,300
then you go click build and we just

00:16:43,330 --> 00:16:50,260
export that schema here and then to load

00:16:46,300 --> 00:16:53,380
it in I lift you just had graphic you LS

00:16:50,260 --> 00:16:55,540
there Express Express graphic you are

00:16:53,380 --> 00:16:59,230
passing schemas pass and graph QL build

00:16:55,540 --> 00:17:01,960
up the app load up the options here just

00:16:59,230 --> 00:17:07,600
specify the endpoints API is up there

00:17:01,960 --> 00:17:12,310
and straight away I have basically a

00:17:07,600 --> 00:17:15,569
graph QL API we're just the models so it

00:17:12,310 --> 00:17:19,260
becomes really simple to then just start

00:17:15,569 --> 00:17:21,490
doing queries and like getting data and

00:17:19,260 --> 00:17:24,880
even just seeing what actual fields

00:17:21,490 --> 00:17:27,610
exist on all of the different schemas

00:17:24,880 --> 00:17:30,160
and there's lots of schemas and that's

00:17:27,610 --> 00:17:31,630
really powerful like I literally all I

00:17:30,160 --> 00:17:34,510
could do is write the models write my

00:17:31,630 --> 00:17:37,810
business logic pokrovsky on top and I've

00:17:34,510 --> 00:17:39,430
got an API so that's really cool so

00:17:37,810 --> 00:17:41,740
that's why I really really was sort of

00:17:39,430 --> 00:17:45,550
like this is a really good library

00:17:41,740 --> 00:17:47,050
anyway back to the presentation in terms

00:17:45,550 --> 00:17:49,060
of performance

00:17:47,050 --> 00:17:50,620
because they when asked about ORM Segoe

00:17:49,060 --> 00:17:54,100
what Aram's usually put on a sort of

00:17:50,620 --> 00:17:55,660
payload legacy to being able to do the

00:17:54,100 --> 00:17:58,150
fetching and then instantiating all the

00:17:55,660 --> 00:18:00,550
objects in memory and all that do

00:17:58,150 --> 00:18:03,610
benchmark it and see what the benchmark

00:18:00,550 --> 00:18:06,040
impact is like because that is usually a

00:18:03,610 --> 00:18:09,900
good way to evaluate what the cost of

00:18:06,040 --> 00:18:14,230
using an ORM is for your Paris projects

00:18:09,900 --> 00:18:18,100
so to wrap up we basically have

00:18:14,230 --> 00:18:19,210
objections yes we have necks I'll just

00:18:18,100 --> 00:18:22,540
quickly go back you from kiss on one

00:18:19,210 --> 00:18:26,140
takes notes we have the next Jess we

00:18:22,540 --> 00:18:29,790
have objection password and we also have

00:18:26,140 --> 00:18:33,880
objection graph cure and one more thing

00:18:29,790 --> 00:18:36,310
happy to announce now that's official so

00:18:33,880 --> 00:18:38,520
after two and a half glorious years at

00:18:36,310 --> 00:18:41,460
star count helping them to become a

00:18:38,520 --> 00:18:44,860
consumer insights consultancy from the

00:18:41,460 --> 00:18:47,710
Phoenix origins of a social media

00:18:44,860 --> 00:18:51,070
startup I'm going to launch my own

00:18:47,710 --> 00:18:53,050
consultancy called an Phoenix and I'm

00:18:51,070 --> 00:18:56,290
available for contracting from mid-june

00:18:53,050 --> 00:19:01,460
and that is it thank you very much

00:18:56,290 --> 00:19:01,460

YouTube URL: https://www.youtube.com/watch?v=RyQ1MTVjYK8


