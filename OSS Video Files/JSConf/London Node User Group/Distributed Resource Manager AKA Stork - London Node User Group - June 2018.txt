Title: Distributed Resource Manager AKA Stork - London Node User Group - June 2018
Publication date: 2018-07-04
Playlist: London Node User Group
Description: 
	Presented by Stephen Young.

At EVRYTHNG we had to a build a number of Node.js applications that required managing multiple resources in a distributed environment. For example, handling real-time connections to other clouds such as Nest and Honeywell and sending notifications to IFTTT applets. What if there was a library that handled the allocation and distribution of these resources so developers could focus on the core business logic of their application?

The EVRYTHNG distributed resource manager is a Node.js library that solves this problem. Developers don’t need to worry about maintaining real-time connections when new nodes are added to the system or if one of them goes down.

In this talk I would demonstrate the resource manager so attendees will see what problems it solves for us at EVRYTHNG. In addition, they will gain an understanding of how we use Node.js at our company and how it helps us scale. Please note that this library is not currently open source but it should be in the next 1-2 months.

About the speaker:

I work as a Technical Lead for EVRYTHNG who provide an IoT platform for businesses around the world. It’s my role to decide on the architecture for various parts of the platform and how we will build these components using Node.js. I’ve been programming in Node for five years.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,609
hi everyone my name's Steven I'm a 10

00:00:02,850 --> 00:00:07,820
khalida everything everything have a

00:00:05,609 --> 00:00:14,490
platform for the Internet of Things

00:00:07,820 --> 00:00:17,580
unfortunately we're not hiring so I'm

00:00:14,490 --> 00:00:19,109
going to talk about a library we've been

00:00:17,580 --> 00:00:23,130
building at everything over the last few

00:00:19,109 --> 00:00:26,310
months that I call the distributed

00:00:23,130 --> 00:00:30,449
resource manager that's a bit wordy so

00:00:26,310 --> 00:00:33,300
we sort of codenamed it's talk but I've

00:00:30,449 --> 00:00:35,730
I've done the I've polished it to NPM as

00:00:33,300 --> 00:00:39,800
distributed resource manager so this is

00:00:35,730 --> 00:00:39,800
free for you to download and use now so

00:00:40,190 --> 00:00:46,980
what is the distributed resource manager

00:00:43,789 --> 00:00:49,469
so it allows you to manage real time

00:00:46,980 --> 00:00:53,489
cloud resources in a distributed and

00:00:49,469 --> 00:00:55,920
fault tolerant manner a resource can be

00:00:53,489 --> 00:00:57,870
a real time connection to another to

00:00:55,920 --> 00:01:00,210
another cloud or a URL that needs to be

00:00:57,870 --> 00:01:04,890
cauldron of it when an event occurs it

00:01:00,210 --> 00:01:06,840
can also be used for polling the

00:01:04,890 --> 00:01:08,909
distributed resource manager allocates

00:01:06,840 --> 00:01:11,970
these resources to instances of the

00:01:08,909 --> 00:01:13,710
manager and assures their reallocated

00:01:11,970 --> 00:01:17,909
when an instance goes down or new

00:01:13,710 --> 00:01:19,710
instances are added users of the library

00:01:17,909 --> 00:01:23,189
supply function they want to be called

00:01:19,710 --> 00:01:24,720
when a new resource is allocated so the

00:01:23,189 --> 00:01:27,090
idea behind the library is that it

00:01:24,720 --> 00:01:29,430
abstracts away the problem of the

00:01:27,090 --> 00:01:33,180
allocation and distribution of resources

00:01:29,430 --> 00:01:37,560
so that you as a user can just write the

00:01:33,180 --> 00:01:39,360
business logic for your application so

00:01:37,560 --> 00:01:43,380
when when would you use something like

00:01:39,360 --> 00:01:45,509
this so as I see it you want to use it

00:01:43,380 --> 00:01:47,729
when the following are true you need to

00:01:45,509 --> 00:01:50,369
manage a set of resources that connects

00:01:47,729 --> 00:01:52,470
with third-party service in some way so

00:01:50,369 --> 00:01:55,350
you need to set up website connections

00:01:52,470 --> 00:01:56,880
you need to pole another cloud or you

00:01:55,350 --> 00:02:01,740
need to subscribe to something like

00:01:56,880 --> 00:02:03,479
Redis for events these resources need to

00:02:01,740 --> 00:02:06,960
be handled in a distributed environment

00:02:03,479 --> 00:02:09,239
and also you need to ensure that if a

00:02:06,960 --> 00:02:12,860
node handling a resource goes down that

00:02:09,239 --> 00:02:12,860
it's then reallocated somewhere else

00:02:14,209 --> 00:02:19,969
so before I go into a demo I just wanted

00:02:17,159 --> 00:02:23,909
to talk about you know why we build this

00:02:19,969 --> 00:02:26,879
so we had a couple of integrations that

00:02:23,909 --> 00:02:29,700
we had to build in the everything

00:02:26,879 --> 00:02:31,829
platform to the nest cloud and to the

00:02:29,700 --> 00:02:33,329
Honeywell cloud so you're probably

00:02:31,829 --> 00:02:35,519
pretty mostly familiar with nest

00:02:33,329 --> 00:02:41,430
Honeywell it's also an IOT device

00:02:35,519 --> 00:02:43,939
company just very quickly before I talk

00:02:41,430 --> 00:02:46,260
about these integrations it's probably

00:02:43,939 --> 00:02:48,060
easier just to understand the everything

00:02:46,260 --> 00:02:50,609
data model so you can create various

00:02:48,060 --> 00:02:52,560
entities in the everything platform so

00:02:50,609 --> 00:02:54,840
the main ones are things so this can be

00:02:52,560 --> 00:02:57,750
a device like a nest device or a

00:02:54,840 --> 00:03:00,000
Honeywell device properties that

00:02:57,750 --> 00:03:03,060
represent the state of this device and

00:03:00,000 --> 00:03:07,799
then actions which are events that occur

00:03:03,060 --> 00:03:11,220
on the device so for the nest

00:03:07,799 --> 00:03:14,129
integration with the EBT platform this

00:03:11,220 --> 00:03:16,260
was the basic user flow a user wants to

00:03:14,129 --> 00:03:19,290
synchronize their nest thermostat with

00:03:16,260 --> 00:03:20,639
the everything platform when a

00:03:19,290 --> 00:03:22,799
temperature change on the thermostat

00:03:20,639 --> 00:03:26,299
occurs it should trigger a property

00:03:22,799 --> 00:03:28,500
update in the everything platform and

00:03:26,299 --> 00:03:30,479
when a user wants to update the

00:03:28,500 --> 00:03:32,849
temperature through the EBT platform and

00:03:30,479 --> 00:03:35,010
actions created and this data is then

00:03:32,849 --> 00:03:38,190
sent to nest so the thermostat is

00:03:35,010 --> 00:03:39,389
updated and that will in turn then cause

00:03:38,190 --> 00:03:45,150
a temperature change event and

00:03:39,389 --> 00:03:47,659
everything platform so this is a basic

00:03:45,150 --> 00:03:51,299
diagram of the user flow so you've got

00:03:47,659 --> 00:03:54,419
you know number of users they will say I

00:03:51,299 --> 00:03:57,560
want to synchronize the data in the

00:03:54,419 --> 00:04:00,000
everything platform with my nest devices

00:03:57,560 --> 00:04:02,220
so then the everything platform creates

00:04:00,000 --> 00:04:04,590
WebSocket connections to the nest

00:04:02,220 --> 00:04:06,689
platform for each of the thermostats

00:04:04,590 --> 00:04:10,079
there's also some other devices in there

00:04:06,689 --> 00:04:12,000
like nest structures as well but yeah

00:04:10,079 --> 00:04:20,459
the WebSockets are then created and

00:04:12,000 --> 00:04:23,110
handled by the DVT platform so

00:04:20,459 --> 00:04:25,540
we needed to make sure we were going to

00:04:23,110 --> 00:04:27,630
have you know thousands of these website

00:04:25,540 --> 00:04:30,250
and connections that we need to create

00:04:27,630 --> 00:04:33,190
so we need to distribute these

00:04:30,250 --> 00:04:35,830
connections amongst multiple nodes and

00:04:33,190 --> 00:04:37,810
also at the same time we were doing the

00:04:35,830 --> 00:04:41,410
nest integration we had to do a very

00:04:37,810 --> 00:04:43,360
similar a very similar integration with

00:04:41,410 --> 00:04:45,220
the Honeywell the only difference is

00:04:43,360 --> 00:04:48,130
that rather than a WebSocket connection

00:04:45,220 --> 00:04:52,150
with Honeywell you poll their cloud API

00:04:48,130 --> 00:04:53,979
for updates so it basically made sense

00:04:52,150 --> 00:04:57,220
for us then to have a common library

00:04:53,979 --> 00:04:59,860
that abstracts away the problem of these

00:04:57,220 --> 00:05:02,380
resource allocations so that then a user

00:04:59,860 --> 00:05:04,150
all they need to do is just write the

00:05:02,380 --> 00:05:07,570
logic for connecting to the third-party

00:05:04,150 --> 00:05:09,010
cloud and then they can just build that

00:05:07,570 --> 00:05:14,169
on top of the resource manager and the

00:05:09,010 --> 00:05:15,700
resource manager does everything else so

00:05:14,169 --> 00:05:19,180
then this is basically the final

00:05:15,700 --> 00:05:20,950
architecture so the distributed resource

00:05:19,180 --> 00:05:23,919
manager will pull the everything

00:05:20,950 --> 00:05:27,580
platform for new resources that need to

00:05:23,919 --> 00:05:29,770
be handled and then the manager sets up

00:05:27,580 --> 00:05:36,820
the real time connections to the the

00:05:29,770 --> 00:05:38,620
thermostats or or any other device so

00:05:36,820 --> 00:05:41,650
yeah as I was saying we use this library

00:05:38,620 --> 00:05:43,750
for Honeywell this also came in useful

00:05:41,650 --> 00:05:45,850
for an integration we did with if this

00:05:43,750 --> 00:05:48,340
then that so I don't know how familiar

00:05:45,850 --> 00:05:50,470
with familiar you are with with IFFT but

00:05:48,340 --> 00:05:53,020
it allows you to do mashups between

00:05:50,470 --> 00:05:56,250
various services unit so you can say you

00:05:53,020 --> 00:05:58,419
know if somebody tweets send me an email

00:05:56,250 --> 00:06:02,710
you know if I post something on Twitter

00:05:58,419 --> 00:06:05,320
trigger something on my Alexa device so

00:06:02,710 --> 00:06:07,300
the user flow for IFFT was a bit

00:06:05,320 --> 00:06:11,530
different but the principle is still the

00:06:07,300 --> 00:06:14,289
same we had to subscribe to where we had

00:06:11,530 --> 00:06:16,360
to manage a set of resources which in

00:06:14,289 --> 00:06:19,300
this case were events and the everything

00:06:16,360 --> 00:06:21,160
platforms and then make sure we we

00:06:19,300 --> 00:06:26,650
triggered the the IFFT actions when

00:06:21,160 --> 00:06:29,289
those occurred so I'm going to give a

00:06:26,650 --> 00:06:30,970
quick demo of the resource manager now

00:06:29,289 --> 00:06:32,400
so as it's the World Cup I thought I'd

00:06:30,970 --> 00:06:35,820
do a shameless tie-in

00:06:32,400 --> 00:06:38,520
a time with the World Cup so the

00:06:35,820 --> 00:06:40,590
scenario is that as a user I want to see

00:06:38,520 --> 00:06:44,389
my favorite players shots visualized

00:06:40,590 --> 00:06:46,800
during a match there's an external

00:06:44,389 --> 00:06:49,650
real-time API that you can subscribe to

00:06:46,800 --> 00:06:51,060
you for when shots occur and the

00:06:49,650 --> 00:06:53,729
distribution Resource Manager will

00:06:51,060 --> 00:06:55,410
manage the players the user select and

00:06:53,729 --> 00:07:07,010
then I'll set up real time connections

00:06:55,410 --> 00:07:14,690
to this API so this is my server and

00:07:07,010 --> 00:07:14,690
then I've got a basic front-end here

00:07:16,850 --> 00:07:21,660
right so you can see the key at the top

00:07:19,979 --> 00:07:25,050
that shows the type of shot that was

00:07:21,660 --> 00:07:27,240
taken so I've I've chosen to demo this

00:07:25,050 --> 00:07:32,610
using the Columbia V Poland match that

00:07:27,240 --> 00:07:34,979
was on about a week ago so I've loaded

00:07:32,610 --> 00:07:38,669
in all of the players for each team on

00:07:34,979 --> 00:07:41,610
the on the right there so now I'm going

00:07:38,669 --> 00:07:49,260
to start two instances of the resource

00:07:41,610 --> 00:07:51,060
manager and then I'm going to choose my

00:07:49,260 --> 00:07:54,800
favorite players and I want to see their

00:07:51,060 --> 00:08:00,169
shots visualized so I'm gonna choose

00:07:54,800 --> 00:08:00,169
Rodriguez cow

00:08:02,330 --> 00:08:10,230
Juan cuadrado Poland I'm going to choose

00:08:06,180 --> 00:08:14,730
11 dove ski I'm a bit clueless about any

00:08:10,230 --> 00:08:19,250
of the other Poland players so I would

00:08:14,730 --> 00:08:19,250
seize piss check I think piss jokes good

00:08:19,400 --> 00:08:26,250
now just choose another Colombian player

00:08:21,810 --> 00:08:28,410
so I visualize the resource nose on the

00:08:26,250 --> 00:08:31,770
right so you can see that as I selected

00:08:28,410 --> 00:08:33,570
the player one of the instances of the

00:08:31,770 --> 00:08:35,580
resource marriage then picks up that

00:08:33,570 --> 00:08:39,210
player the resource in this particular

00:08:35,580 --> 00:08:41,400
case so now let's say the match is

00:08:39,210 --> 00:08:42,950
starting so I'm going to click this

00:08:41,400 --> 00:08:47,250
which will actually play out the match

00:08:42,950 --> 00:08:50,520
so rather than 90 minutes this is two

00:08:47,250 --> 00:08:52,440
minutes so you should start to see some

00:08:50,520 --> 00:08:55,710
of the shots come through at some point

00:08:52,440 --> 00:08:57,180
I think I think in this match it took

00:08:55,710 --> 00:09:00,060
quite a while before there was a first

00:08:57,180 --> 00:09:03,680
shot oh yeah yes so you can see levin

00:09:00,060 --> 00:09:03,680
dosti had a shot blocked

00:09:06,170 --> 00:09:11,840
and then cuadrado had a shot off target

00:09:19,459 --> 00:09:23,629
nothing seems to have happened for a

00:09:21,199 --> 00:09:25,790
while oh yeah so now some more shots

00:09:23,629 --> 00:09:28,339
coming in so let's say we've had a lot

00:09:25,790 --> 00:09:30,860
of users you know wanting to see their

00:09:28,339 --> 00:09:34,779
favorite players so we're going to start

00:09:30,860 --> 00:09:34,779
another instance of the resource manager

00:09:39,550 --> 00:09:43,279
so you'll see now that excited another

00:09:42,050 --> 00:09:45,920
one all the players have been

00:09:43,279 --> 00:09:47,929
reallocated but we still maintained all

00:09:45,920 --> 00:09:50,119
of the connections to the shot server

00:09:47,929 --> 00:09:51,470
that's sending through the shots so you

00:09:50,119 --> 00:09:53,740
can still see some of the shots coming

00:09:51,470 --> 00:09:57,559
through so cuadrado just scored a goal

00:09:53,740 --> 00:10:01,879
Rodriguez just had a shot and then if I

00:09:57,559 --> 00:10:07,220
take out one of the instances so let's

00:10:01,879 --> 00:10:09,829
say one of the nodes goes down the

00:10:07,220 --> 00:10:13,389
players then get reallocated and you can

00:10:09,829 --> 00:10:13,389
see the shots are still coming through

00:10:14,829 --> 00:10:18,819
yeah and that's the end of match

00:10:23,310 --> 00:10:29,910
so how does the resource manager work so

00:10:27,199 --> 00:10:32,939
it's built on top of a library called

00:10:29,910 --> 00:10:36,389
Ring Pop so Ring Pop was developed by

00:10:32,939 --> 00:10:38,850
uber and it's a scaleable fault an

00:10:36,389 --> 00:10:41,430
application layer sharding for nodejs

00:10:38,850 --> 00:10:43,410
applications so there's three main

00:10:41,430 --> 00:10:46,519
components to Ring Pop there's the

00:10:43,410 --> 00:10:49,680
membership protocol the hash ring and

00:10:46,519 --> 00:10:53,009
forwarding so in the membership protocol

00:10:49,680 --> 00:10:56,339
when Ring Pop starts it will create a

00:10:53,009 --> 00:10:59,399
distributed application and all of the

00:10:56,339 --> 00:11:03,059
nodes in this application all know about

00:10:59,399 --> 00:11:09,449
each other through TCP communication and

00:11:03,059 --> 00:11:12,870
a gossiping protocol so if a node goes

00:11:09,449 --> 00:11:16,499
down and the application knows that an

00:11:12,870 --> 00:11:20,279
instance is no longer available it will

00:11:16,499 --> 00:11:24,089
then also set up a hash ring so the way

00:11:20,279 --> 00:11:27,779
this works is ring pop divides a key

00:11:24,089 --> 00:11:30,959
space up between all of the nodes and

00:11:27,779 --> 00:11:34,170
hash ring and then if you give ring pop

00:11:30,959 --> 00:11:35,879
an ID it will then say this resource

00:11:34,170 --> 00:11:39,089
should be allocated to this node or

00:11:35,879 --> 00:11:40,949
should be allocated to this node and

00:11:39,089 --> 00:11:43,680
then finally there's the forwarding so

00:11:40,949 --> 00:11:49,139
if ring pop instance receives a request

00:11:43,680 --> 00:11:50,970
and the ID of that request doesn't hash

00:11:49,139 --> 00:11:54,089
to that node then it will then be

00:11:50,970 --> 00:11:55,350
forwarded to another node so the

00:11:54,089 --> 00:12:00,209
resource manager basically takes

00:11:55,350 --> 00:12:01,529
advantage of these the reasons when I

00:12:00,209 --> 00:12:06,750
say it's a bunch of these things to be

00:12:01,529 --> 00:12:09,089
able to do what it needs to do so when

00:12:06,750 --> 00:12:10,290
you start an instance of the resource

00:12:09,089 --> 00:12:12,389
manager it goes through the following

00:12:10,290 --> 00:12:15,870
steps so first of all it joins the ring

00:12:12,389 --> 00:12:18,120
pop hash ring once it joins the hash

00:12:15,870 --> 00:12:22,319
ring it fetches a set of resources by

00:12:18,120 --> 00:12:23,999
default this is fire HTTP for each

00:12:22,319 --> 00:12:26,129
resource it will check if the resource

00:12:23,999 --> 00:12:27,600
should be assigned to itself if not it

00:12:26,129 --> 00:12:32,370
then gets forwarded to another instance

00:12:27,600 --> 00:12:34,110
of the manager and then it will call a

00:12:32,370 --> 00:12:36,089
user-supplied function for each

00:12:34,110 --> 00:12:37,150
resources should be handling and this

00:12:36,089 --> 00:12:38,770
provides the business

00:12:37,150 --> 00:12:43,330
for the application such as opening our

00:12:38,770 --> 00:12:44,740
web sockets or or whatever and then if

00:12:43,330 --> 00:12:47,020
any other instances of the manageress

00:12:44,740 --> 00:12:48,970
started the existing resources get

00:12:47,020 --> 00:12:51,910
rebalanced amongst all the instances and

00:12:48,970 --> 00:12:53,920
if any SS are removed the resources also

00:12:51,910 --> 00:13:00,220
will be rebalanced to see you saw you

00:12:53,920 --> 00:13:03,640
saw that during the World Cup demo so

00:13:00,220 --> 00:13:06,220
the user supplied function it's it's

00:13:03,640 --> 00:13:08,560
actually a object that a user supplies

00:13:06,220 --> 00:13:10,750
in the config when they start the

00:13:08,560 --> 00:13:14,260
resource manager so this is basically a

00:13:10,750 --> 00:13:16,030
typescript definition of what that types

00:13:14,260 --> 00:13:18,790
with interface a definition of what that

00:13:16,030 --> 00:13:20,860
objection that like so there's the

00:13:18,790 --> 00:13:23,350
handle resource function which is your

00:13:20,860 --> 00:13:26,290
main function for setting up your

00:13:23,350 --> 00:13:28,480
real-time connection handle failed

00:13:26,290 --> 00:13:30,720
resource is called if there's an error

00:13:28,480 --> 00:13:34,270
when you try to handle the resource

00:13:30,720 --> 00:13:36,610
terminate resource that will be called

00:13:34,270 --> 00:13:39,670
when the resource needs to be terminated

00:13:36,610 --> 00:13:41,380
so that's usually called when the

00:13:39,670 --> 00:13:43,930
resource need to be rebalanced in the

00:13:41,380 --> 00:13:47,860
hash ring and then handle failed

00:13:43,930 --> 00:13:49,660
termination which is called when there

00:13:47,860 --> 00:13:58,980
was a error trying to terminate the

00:13:49,660 --> 00:13:58,980
resource so just very quickly I'll go to

00:13:59,850 --> 00:14:05,130
the world cup demo that I thought I'd

00:14:02,740 --> 00:14:05,130
demoed earlier

00:14:11,370 --> 00:14:15,850
so this is the resource handler

00:14:13,930 --> 00:14:18,180
definition here so you can see I've

00:14:15,850 --> 00:14:21,430
defined this handle resource function

00:14:18,180 --> 00:14:23,620
so there's MQ secret connect this is

00:14:21,430 --> 00:14:26,950
what connects to the World Cup shot

00:14:23,620 --> 00:14:27,970
server you can ignore this WebSocket

00:14:26,950 --> 00:14:29,890
connection because that was just

00:14:27,970 --> 00:14:36,400
something I was using to post updates to

00:14:29,890 --> 00:14:37,870
the to the front-end so when the when

00:14:36,400 --> 00:14:40,420
the client connects to the WebSocket

00:14:37,870 --> 00:14:42,370
server it subscribes to the player

00:14:40,420 --> 00:14:46,660
that's been assigned to this resource

00:14:42,370 --> 00:14:52,690
manager and when it receives an event it

00:14:46,660 --> 00:14:54,010
posts that shot to to the server and

00:14:52,690 --> 00:14:55,870
then the rest of its not particularly

00:14:54,010 --> 00:14:57,820
important in in a terminator resource

00:14:55,870 --> 00:15:01,090
I'm just making sure that I close the

00:14:57,820 --> 00:15:06,360
WebSocket connection when when the

00:15:01,090 --> 00:15:08,860
resource is terminated and then this is

00:15:06,360 --> 00:15:12,280
how you start the resource manager so

00:15:08,860 --> 00:15:15,700
you need to provide the Ring Pop options

00:15:12,280 --> 00:15:17,290
for your for your application so you

00:15:15,700 --> 00:15:20,200
need to provide an app name and the host

00:15:17,290 --> 00:15:23,530
and port that the app runs on and then

00:15:20,200 --> 00:15:27,550
also the Ring Pop hosts that this is an

00:15:23,530 --> 00:15:30,340
array of hosts that this instance of the

00:15:27,550 --> 00:15:31,690
mayor should connect to and then there's

00:15:30,340 --> 00:15:33,700
various other options in there like

00:15:31,690 --> 00:15:37,270
you've got options for the for fetching

00:15:33,700 --> 00:15:39,010
the resource by HTTP and whether you

00:15:37,270 --> 00:15:43,570
want to poll for new resources and that

00:15:39,010 --> 00:15:49,540
sort of thing so that's a quick walk

00:15:43,570 --> 00:15:53,290
through so there's also a plug-in

00:15:49,540 --> 00:15:55,330
architecture for the resource manager so

00:15:53,290 --> 00:15:58,570
it might be that you don't actually want

00:15:55,330 --> 00:16:00,670
to fetch your resource as far HTTP maybe

00:15:58,570 --> 00:16:02,470
you want to get them from a database or

00:16:00,670 --> 00:16:04,480
you want to get them from from a queue

00:16:02,470 --> 00:16:07,120
or something like that so you can define

00:16:04,480 --> 00:16:10,420
your own plugin that will handle the the

00:16:07,120 --> 00:16:15,160
resource fetching logic so again this is

00:16:10,420 --> 00:16:17,080
another interface definition for the for

00:16:15,160 --> 00:16:20,190
the plugin so there's three methods you

00:16:17,080 --> 00:16:22,180
have to define the setup function which

00:16:20,190 --> 00:16:24,740
you might hear you might just want to

00:16:22,180 --> 00:16:27,300
set up the database connection

00:16:24,740 --> 00:16:29,790
then the fetch resources which is the

00:16:27,300 --> 00:16:32,730
main function for fetching the resources

00:16:29,790 --> 00:16:36,180
so this might be a database core to get

00:16:32,730 --> 00:16:37,589
the resources and then teardown where

00:16:36,180 --> 00:16:38,970
here you might want to close the

00:16:37,589 --> 00:16:44,579
database connection or something like

00:16:38,970 --> 00:16:48,149
that yeah so that's about it and as I

00:16:44,579 --> 00:16:49,589
said it's available at NPM yeah if

00:16:48,149 --> 00:16:51,500
you've got any more questions speak to

00:16:49,589 --> 00:16:57,059
me after this Thanks

00:16:51,500 --> 00:16:57,059

YouTube URL: https://www.youtube.com/watch?v=eVnLbeQHiMs


