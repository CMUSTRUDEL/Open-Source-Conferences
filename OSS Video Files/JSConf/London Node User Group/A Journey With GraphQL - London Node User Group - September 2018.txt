Title: A Journey With GraphQL - London Node User Group - September 2018
Publication date: 2018-10-02
Playlist: London Node User Group
Description: 
	Presented by Michelle and Faduma.

You've heard of GraphQL. But what kind of problems can it solve? This is the story of why we chose GraphQL to power the Vogue and GQ websites, and how it helped us get the data we needed for our frontend. You'll learn about some ways in which GraphQL can improve your application, and understand how you might implement it.

About the Speakers:

Faduma and Michelle are Software Engineers at CondÃ© Nast International.

https://twitter.com/FadumaFaralacag
https://twitter.com/msmichellegar
https://github.com/msmichellegar

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:06,299
yeah welcome to our talk journey with

00:00:02,310 --> 00:00:07,020
graph girl I'm Fatima and this is

00:00:06,299 --> 00:00:08,849
Michelle

00:00:07,020 --> 00:00:11,309
and we both software engineers that

00:00:08,849 --> 00:00:14,190
continent international and we love

00:00:11,309 --> 00:00:15,599
graph Corral and this is our handles if

00:00:14,190 --> 00:00:19,500
you want to tweet graph kill things to

00:00:15,599 --> 00:00:20,820
us so what are we going to talk about

00:00:19,500 --> 00:00:22,500
today so we're gonna talk about two

00:00:20,820 --> 00:00:24,720
things I'm gonna give you a sort of

00:00:22,500 --> 00:00:28,859
history on a sort of got girl journey

00:00:24,720 --> 00:00:32,430
and decisions that we made and general

00:00:28,859 --> 00:00:45,930
use cases reasons why you could use goth

00:00:32,430 --> 00:00:49,379
girl so we own GQ burg next slide so

00:00:45,930 --> 00:00:56,219
this is our beautiful big website and we

00:00:49,379 --> 00:01:03,270
made this so a bit of history on what I

00:00:56,219 --> 00:01:05,250
used to look like yes thank you I used

00:01:03,270 --> 00:01:09,510
to look like this where we used to get a

00:01:05,250 --> 00:01:12,780
data form a content API and we served up

00:01:09,510 --> 00:01:15,710
using a happy server we had a meet-up

00:01:12,780 --> 00:01:21,720
saw where we would put data in and

00:01:15,710 --> 00:01:25,799
server-side render application so while

00:01:21,720 --> 00:01:27,240
the problems we had okay so here's what

00:01:25,799 --> 00:01:32,009
our application used to look like

00:01:27,240 --> 00:01:33,689
as Fatima showed and after we've been

00:01:32,009 --> 00:01:35,729
building this for a couple of months we

00:01:33,689 --> 00:01:37,020
had a retrospective where we talked

00:01:35,729 --> 00:01:38,280
about the things that we liked and

00:01:37,020 --> 00:01:40,079
things that we didn't like about our

00:01:38,280 --> 00:01:43,740
code base and here are some of the

00:01:40,079 --> 00:01:46,409
problems that we identified the first

00:01:43,740 --> 00:01:48,780
problem is that a lot of our components

00:01:46,409 --> 00:01:55,110
were tied very specifically to the API

00:01:48,780 --> 00:01:56,520
response so this is what a component

00:01:55,110 --> 00:01:58,049
this is a dramatic example of what a

00:01:56,520 --> 00:02:01,079
component might have looked like for a

00:01:58,049 --> 00:02:04,290
title instead of just passing in the

00:02:01,079 --> 00:02:06,960
title we would pass in the

00:02:04,290 --> 00:02:11,210
Tai API response and just get the title

00:02:06,960 --> 00:02:11,210
especially destruction but ignore that

00:02:13,430 --> 00:02:20,550
well this is bad because if the API

00:02:18,840 --> 00:02:23,460
changes you have to update your

00:02:20,550 --> 00:02:26,610
components so if the API developer

00:02:23,460 --> 00:02:28,830
changed the field name from title to

00:02:26,610 --> 00:02:31,170
heads we would have to update our title

00:02:28,830 --> 00:02:34,260
component which is very inconvenient and

00:02:31,170 --> 00:02:37,110
could be avoided it's also less readable

00:02:34,260 --> 00:02:40,530
because it's not clear what data your

00:02:37,110 --> 00:02:42,840
component needs so if I was a new

00:02:40,530 --> 00:02:44,820
developer joining a project and I looked

00:02:42,840 --> 00:02:47,280
at this title component it would not be

00:02:44,820 --> 00:02:51,050
clear to me what data I need to pass it

00:02:47,280 --> 00:02:53,760
in order for it to render successfully

00:02:51,050 --> 00:02:58,260
our components also know way too much

00:02:53,760 --> 00:03:00,690
about their context by a context I mean

00:02:58,260 --> 00:03:02,640
where the data comes from the structure

00:03:00,690 --> 00:03:07,170
that it's fetched in and all the data

00:03:02,640 --> 00:03:09,600
that is available ideally we would have

00:03:07,170 --> 00:03:11,190
a few components that know about context

00:03:09,600 --> 00:03:14,220
while most of our reactive components

00:03:11,190 --> 00:03:16,290
have no idea so this would be following

00:03:14,220 --> 00:03:19,620
the structure of presentational vs.

00:03:16,290 --> 00:03:23,549
container components so presentational

00:03:19,620 --> 00:03:25,380
components know nothing about the

00:03:23,549 --> 00:03:28,049
context they have no state or

00:03:25,380 --> 00:03:31,890
dependencies they just take in data and

00:03:28,049 --> 00:03:34,140
display it so if we were to refactor our

00:03:31,890 --> 00:03:35,970
component to be more presentational it

00:03:34,140 --> 00:03:38,850
might look something like this meanwhile

00:03:35,970 --> 00:03:41,310
we have our container components which

00:03:38,850 --> 00:03:43,470
do you know about context that often

00:03:41,310 --> 00:03:45,900
generated by higher-order components and

00:03:43,470 --> 00:03:48,720
they provide data to presentational

00:03:45,900 --> 00:03:50,430
components and render them so an example

00:03:48,720 --> 00:03:53,840
of a presentational component would be

00:03:50,430 --> 00:03:57,239
something like this for an article page

00:03:53,840 --> 00:03:59,160
which gets all the data from its

00:03:57,239 --> 00:04:01,170
generated by this higher-order component

00:03:59,160 --> 00:04:04,830
with article data which gives all the

00:04:01,170 --> 00:04:06,209
data from the API response and then it

00:04:04,830 --> 00:04:08,310
renders the title and the byline

00:04:06,209 --> 00:04:09,130
component and just passes them the data

00:04:08,310 --> 00:04:12,490
that they need

00:04:09,130 --> 00:04:15,460
and nothing wrong this is a great

00:04:12,490 --> 00:04:17,320
pattern but unfortunately we did not

00:04:15,460 --> 00:04:19,720
enforce this strictly enough in our code

00:04:17,320 --> 00:04:22,570
base and a lot of our components and you

00:04:19,720 --> 00:04:26,110
way too much about the API and what was

00:04:22,570 --> 00:04:27,520
going on in an ideal world even our

00:04:26,110 --> 00:04:30,250
container components would not know

00:04:27,520 --> 00:04:34,060
about a third party API more on this

00:04:30,250 --> 00:04:38,680
later basically our components needed a

00:04:34,060 --> 00:04:40,900
lot of refactoring total number two we

00:04:38,680 --> 00:04:44,770
sent a lot of data that we went using to

00:04:40,900 --> 00:04:48,430
the client into our Redux store so this

00:04:44,770 --> 00:04:51,430
is the full set of data that we would

00:04:48,430 --> 00:04:54,310
get back when making a request to the

00:04:51,430 --> 00:05:01,930
content API for an article it's a lot of

00:04:54,310 --> 00:05:03,850
data and a lot of this data not all of

00:05:01,930 --> 00:05:12,130
it made it to the client but a lot of it

00:05:03,850 --> 00:05:14,410
did this is bad festival because of

00:05:12,130 --> 00:05:18,190
confusing clutter we don't need all this

00:05:14,410 --> 00:05:19,240
data so why is it bad it can also affect

00:05:18,190 --> 00:05:21,400
performance

00:05:19,240 --> 00:05:24,760
because the browser is downloading

00:05:21,400 --> 00:05:27,130
unnecessary stuff it could also be a

00:05:24,760 --> 00:05:29,110
security risk what if the API developer

00:05:27,130 --> 00:05:31,630
introduces a sensitive field like

00:05:29,110 --> 00:05:33,850
password and then because we're not

00:05:31,630 --> 00:05:35,890
filtering the API response we just send

00:05:33,850 --> 00:05:38,400
it to the client in our redox tour we're

00:05:35,890 --> 00:05:40,960
exposing sensitive data up to our users

00:05:38,400 --> 00:05:44,550
well the story is we should not be

00:05:40,960 --> 00:05:48,010
sending all of this data to the client

00:05:44,550 --> 00:05:50,140
third problem if we switch data sources

00:05:48,010 --> 00:05:52,390
we would have to completely rewrite our

00:05:50,140 --> 00:05:53,950
entire application pretty much

00:05:52,390 --> 00:05:56,590
everything in our app was closely tied

00:05:53,950 --> 00:05:57,490
to the API from the components that we

00:05:56,590 --> 00:05:59,710
were talking about before

00:05:57,490 --> 00:06:00,350
also our analytics and the metadata that

00:05:59,710 --> 00:06:02,120
will render

00:06:00,350 --> 00:06:05,420
on the page that will very closely

00:06:02,120 --> 00:06:06,890
linked to the API and for example if we

00:06:05,420 --> 00:06:07,970
switch to WordPress we would have to

00:06:06,890 --> 00:06:11,660
throw away our app and completely

00:06:07,970 --> 00:06:15,770
rewrite it so if our pink API changed to

00:06:11,660 --> 00:06:17,840
a rainbow API ilac would kind of be

00:06:15,770 --> 00:06:26,090
redundant in a little ways which is not

00:06:17,840 --> 00:06:28,130
good this is bad because technology

00:06:26,090 --> 00:06:30,590
changes and your app should be resilient

00:06:28,130 --> 00:06:34,160
it is a business risk to couple your

00:06:30,590 --> 00:06:37,720
application to a third-party service we

00:06:34,160 --> 00:06:37,720
needed to consciously do :

00:06:37,900 --> 00:06:43,940
probably number four the API was

00:06:42,380 --> 00:06:45,590
difficult to work with and it had some

00:06:43,940 --> 00:06:46,940
quirks that we did not understand

00:06:45,590 --> 00:06:50,690
because we were not the ones that built

00:06:46,940 --> 00:06:52,730
it disclaimer this is the case with all

00:06:50,690 --> 00:06:54,800
third party API is not specifically the

00:06:52,730 --> 00:06:57,170
third party API that we were working

00:06:54,800 --> 00:06:59,150
with and if you work with third party

00:06:57,170 --> 00:07:01,430
API eyes you will probably experience a

00:06:59,150 --> 00:07:03,080
lot of these issues like first of all it

00:07:01,430 --> 00:07:04,720
was not dealt with our specific use case

00:07:03,080 --> 00:07:06,950
in mind can you believe that

00:07:04,720 --> 00:07:08,870
unbelievable

00:07:06,950 --> 00:07:10,940
the field names did not always make

00:07:08,870 --> 00:07:13,280
sense to us there was some weird

00:07:10,940 --> 00:07:15,170
publishers speed it's the old names that

00:07:13,280 --> 00:07:17,990
people would join our project you don't

00:07:15,170 --> 00:07:21,110
know what they are there's also so much

00:07:17,990 --> 00:07:25,040
data more than we needed as you saw

00:07:21,110 --> 00:07:26,440
earlier and some data new believe it was

00:07:25,040 --> 00:07:29,060
not in the format that we were acquired

00:07:26,440 --> 00:07:32,120
so for example the article body would

00:07:29,060 --> 00:07:34,040
come back to us in markdown which is

00:07:32,120 --> 00:07:37,070
convenient for the content management

00:07:34,040 --> 00:07:38,690
system but not so convenient for us when

00:07:37,070 --> 00:07:42,860
we don't want to render hashes

00:07:38,690 --> 00:07:45,830
everywhere on the page and also those

00:07:42,860 --> 00:07:47,300
not always documentation for the API and

00:07:45,830 --> 00:07:49,010
you'll probably experience this when you

00:07:47,300 --> 00:07:50,840
use their party ap is because

00:07:49,010 --> 00:07:53,660
documentation is hard when it's done by

00:07:50,840 --> 00:07:56,540
humans and sometimes we would not know

00:07:53,660 --> 00:07:59,060
which parameters which query parameter

00:07:56,540 --> 00:08:04,100
pass or what options we could send with

00:07:59,060 --> 00:08:07,419
the SDK request and I was hard third

00:08:04,100 --> 00:08:10,070
party API is will never be perfect

00:08:07,419 --> 00:08:12,050
probably number five we were fetching

00:08:10,070 --> 00:08:13,610
data in complicated ways from deep trees

00:08:12,050 --> 00:08:17,000
and the API every time

00:08:13,610 --> 00:08:19,449
in our main application so if we wanted

00:08:17,000 --> 00:08:22,090
to render an article about Megan buckle

00:08:19,449 --> 00:08:25,430
here are the requests that we would make

00:08:22,090 --> 00:08:28,189
in our main application there would be a

00:08:25,430 --> 00:08:30,110
request to get the megamouth little

00:08:28,189 --> 00:08:32,300
article then the published history of

00:08:30,110 --> 00:08:34,550
that article to get the pub date about

00:08:32,300 --> 00:08:36,529
the analytics required have to look up

00:08:34,550 --> 00:08:38,240
the contributor shell Garrett you'd have

00:08:36,529 --> 00:08:40,010
to look up the fashion category to get

00:08:38,240 --> 00:08:42,110
information about that you'd have to

00:08:40,010 --> 00:08:44,360
look up recommendations for the article

00:08:42,110 --> 00:08:46,070
from the recommendations API and then

00:08:44,360 --> 00:08:47,329
with the IDs that that returns look up

00:08:46,070 --> 00:08:50,209
every single one of those articles

00:08:47,329 --> 00:08:53,180
individually and then your talk to smush

00:08:50,209 --> 00:09:01,910
all of that data together to render this

00:08:53,180 --> 00:09:03,589
article this is bad because it was

00:09:01,910 --> 00:09:05,930
cognitive overload trying to remember

00:09:03,589 --> 00:09:09,170
Wed get which data every time we needed

00:09:05,930 --> 00:09:11,029
it we had some really complex

00:09:09,170 --> 00:09:14,600
relationships between objects that we

00:09:11,029 --> 00:09:16,190
have to navigate frequently like getting

00:09:14,600 --> 00:09:17,870
the recommendations we would have to get

00:09:16,190 --> 00:09:21,110
those IDs and then like embed those

00:09:17,870 --> 00:09:22,370
recommendations objects and we have to

00:09:21,110 --> 00:09:24,140
make multiple requests in our main

00:09:22,370 --> 00:09:27,140
application to get the data we wanted

00:09:24,140 --> 00:09:28,940
and we would service side rendering but

00:09:27,140 --> 00:09:31,540
if we're making multiple requests client

00:09:28,940 --> 00:09:34,040
science it would not be in performing

00:09:31,540 --> 00:09:35,510
it's also harder to debug because when

00:09:34,040 --> 00:09:37,910
something goes wrong in this process

00:09:35,510 --> 00:09:42,220
it's hard to track down where exactly

00:09:37,910 --> 00:09:46,130
the problem is it was a lot to deal with

00:09:42,220 --> 00:09:50,149
clear we had issues but how do we solve

00:09:46,130 --> 00:09:53,209
these problems yes how did we solve

00:09:50,149 --> 00:09:55,730
these problems so we had a retrospective

00:09:53,209 --> 00:09:58,250
where we sort of defined the good things

00:09:55,730 --> 00:10:00,829
and bad things and application and came

00:09:58,250 --> 00:10:03,470
up with two different ideas to explore

00:10:00,829 --> 00:10:08,360
one of them was Rothwell and the other

00:10:03,470 --> 00:10:12,949
was a pure domain driven design idea

00:10:08,360 --> 00:10:14,300
spoil alert will work for guac well so

00:10:12,949 --> 00:10:17,000
if you remember this is how the

00:10:14,300 --> 00:10:18,220
application used to look like so we were

00:10:17,000 --> 00:10:21,850
making requests to

00:10:18,220 --> 00:10:23,920
yeah we had a happy server we had a

00:10:21,850 --> 00:10:27,520
readout store and we were server-side

00:10:23,920 --> 00:10:29,530
rendering our applications and now this

00:10:27,520 --> 00:10:31,060
is how our application looks like so

00:10:29,530 --> 00:10:33,250
we're still making requests to the

00:10:31,060 --> 00:10:37,870
content API but essentially we've added

00:10:33,250 --> 00:10:41,140
a graphical layer and we're still using

00:10:37,870 --> 00:10:44,350
--happy and using a polo client to make

00:10:41,140 --> 00:10:47,260
requests to our graph pool server which

00:10:44,350 --> 00:10:50,770
we use pull the server to do this keeper

00:10:47,260 --> 00:10:52,840
we still react server-side rendering on

00:10:50,770 --> 00:10:55,240
react application so essentially we've

00:10:52,840 --> 00:10:56,940
just we've got rid of three dots and we

00:10:55,240 --> 00:10:59,740
have this graphical layer that sort of

00:10:56,940 --> 00:11:02,650
protects our application and all the

00:10:59,740 --> 00:11:07,360
business logic has moved from this side

00:11:02,650 --> 00:11:11,440
to the graph Google Earth so what did

00:11:07,360 --> 00:11:14,890
the goth girl give us firstly he gave us

00:11:11,440 --> 00:11:16,930
instant documentation so this is a

00:11:14,890 --> 00:11:19,240
screenshot of another application you

00:11:16,930 --> 00:11:23,620
can query a graph to life API is called

00:11:19,240 --> 00:11:27,000
a graphical playground and you see here

00:11:23,620 --> 00:11:29,410
this is how our schema looks like and

00:11:27,000 --> 00:11:33,520
you can see clearly all the queries that

00:11:29,410 --> 00:11:35,950
you can make or the arguments that the

00:11:33,520 --> 00:11:38,100
query requires and their types which

00:11:35,950 --> 00:11:41,320
one's required and which ones are not

00:11:38,100 --> 00:11:43,510
you can see all the data thus you can

00:11:41,320 --> 00:11:47,080
fetch so you can fetch one or more those

00:11:43,510 --> 00:11:47,920
data so now our documentation is

00:11:47,080 --> 00:11:51,810
actually useful

00:11:47,920 --> 00:11:54,880
it saves up to date with no effort

00:11:51,810 --> 00:11:57,250
another great thing that we found with

00:11:54,880 --> 00:11:59,980
graph guys that we learned we no longer

00:11:57,250 --> 00:12:03,850
have to fetch data with multi multiple

00:11:59,980 --> 00:12:05,890
requests in our main application so if

00:12:03,850 --> 00:12:08,980
you remember the Megan Markel article

00:12:05,890 --> 00:12:14,830
and those chain of forecasts we had to

00:12:08,980 --> 00:12:16,330
make now we just make one query we still

00:12:14,830 --> 00:12:19,540
have to make the same risk or the

00:12:16,330 --> 00:12:21,490
request but they essentially move to our

00:12:19,540 --> 00:12:24,610
graph through a layer and as developers

00:12:21,490 --> 00:12:25,600
we just have to think about when we're

00:12:24,610 --> 00:12:28,839
building our clients

00:12:25,600 --> 00:12:32,500
application just one query so it kinda

00:12:28,839 --> 00:12:35,529
helps clear your mind a little bit so

00:12:32,500 --> 00:12:39,399
now we can fetch data in a clear

00:12:35,529 --> 00:12:42,670
consistent way all the logic for gluing

00:12:39,399 --> 00:12:46,709
that data together has moved to our sort

00:12:42,670 --> 00:12:46,709
of graph QR and it does it seamlessly

00:12:47,040 --> 00:12:54,100
example of this is our recommendation

00:12:49,750 --> 00:12:58,120
component which lives in the article

00:12:54,100 --> 00:13:01,990
page and the gallery page so the logic

00:12:58,120 --> 00:13:06,339
to get this recommendations data lives

00:13:01,990 --> 00:13:09,910
in a graph called vis-a-vis Alba so we

00:13:06,339 --> 00:13:13,509
can we use it here in the after page and

00:13:09,910 --> 00:13:15,759
the Gallagher page in a similar way so

00:13:13,509 --> 00:13:18,370
we can get we can use a saved query to

00:13:15,759 --> 00:13:20,980
fetch those two theta and if we change

00:13:18,370 --> 00:13:23,889
our sort of the function that resolves

00:13:20,980 --> 00:13:25,839
this from their content API it happens

00:13:23,889 --> 00:13:27,940
seamlessly on both articles but

00:13:25,839 --> 00:13:30,069
previously we would have to sort of

00:13:27,940 --> 00:13:33,910
replicate the business logic on both of

00:13:30,069 --> 00:13:35,439
those pages so I live so much easier now

00:13:33,910 --> 00:13:38,819
we'd have to think about where anything

00:13:35,439 --> 00:13:42,130
we only have to think about one query

00:13:38,819 --> 00:13:43,839
another great thing another like huge

00:13:42,130 --> 00:13:46,389
benefit that we've got with graphical

00:13:43,839 --> 00:13:50,649
eyes that it colleges good patterns of

00:13:46,389 --> 00:13:53,740
structuring our application we started

00:13:50,649 --> 00:13:55,389
fetching only the data we needed we

00:13:53,740 --> 00:13:57,490
stripped out all our business logic out

00:13:55,389 --> 00:14:00,579
of our components and we start to have

00:13:57,490 --> 00:14:02,920
true separation of concerns we use

00:14:00,579 --> 00:14:05,290
sorting using fill names actually meant

00:14:02,920 --> 00:14:11,769
something to us not just what the API

00:14:05,290 --> 00:14:16,480
gave us and now our UI is no longer tied

00:14:11,769 --> 00:14:18,250
to this IPI disclaimer we could have

00:14:16,480 --> 00:14:21,399
done this without great graph color and

00:14:18,250 --> 00:14:23,139
you can do it without after all with

00:14:21,399 --> 00:14:26,110
more discipline we could have avoided

00:14:23,139 --> 00:14:28,959
some of these problems and if we also

00:14:26,110 --> 00:14:30,660
enact this on these patterns we could

00:14:28,959 --> 00:14:32,819
have had this similar better

00:14:30,660 --> 00:14:35,220
so with domain-driven design and

00:14:32,819 --> 00:14:37,439
hexagonal architecture they both have

00:14:35,220 --> 00:14:40,410
the same principles where you would have

00:14:37,439 --> 00:14:43,980
a separate your user interface from your

00:14:40,410 --> 00:14:48,720
business logic so Gothel will not fix

00:14:43,980 --> 00:14:50,790
everything but with graphic you are in

00:14:48,720 --> 00:14:52,769
ecology suggestion or programming

00:14:50,790 --> 00:14:58,019
pattern with that requiring developers

00:14:52,769 --> 00:14:59,459
to please each other so Brasco allows

00:14:58,019 --> 00:15:00,809
you to follow these patterns without

00:14:59,459 --> 00:15:02,790
even having to think about it it's just

00:15:00,809 --> 00:15:07,139
that's how you do it that's the graph go

00:15:02,790 --> 00:15:09,509
away graph go has a huge community you

00:15:07,139 --> 00:15:10,949
can go to these talks watch videos about

00:15:09,509 --> 00:15:12,720
graphic you are and learn about these

00:15:10,949 --> 00:15:15,119
patterns not a lot of people know about

00:15:12,720 --> 00:15:22,559
domain driven design or hexagonal

00:15:15,119 --> 00:15:25,019
architecture yay graph girl so the one

00:15:22,559 --> 00:15:27,360
of the hugest benefit from like using

00:15:25,019 --> 00:15:29,699
graphical is that now we have insurance

00:15:27,360 --> 00:15:32,910
that if we change our third party API

00:15:29,699 --> 00:15:38,669
our application won't be affected as

00:15:32,910 --> 00:15:40,259
much so changing our data source would

00:15:38,669 --> 00:15:41,759
only affect the graphical layer an

00:15:40,259 --> 00:15:45,169
application doesn't really know about

00:15:41,759 --> 00:15:49,470
that so it shielded for that change

00:15:45,169 --> 00:15:55,379
so situations that might occur so if we

00:15:49,470 --> 00:15:57,569
switched CMS's to word for example so

00:15:55,379 --> 00:16:00,480
here are our pink API and we change it

00:15:57,569 --> 00:16:03,209
to a rainbow API really our graphical

00:16:00,480 --> 00:16:05,309
layer knows about this so those fields

00:16:03,209 --> 00:16:07,499
would resolve to a different API and

00:16:05,309 --> 00:16:09,809
this react allocation really would have

00:16:07,499 --> 00:16:12,029
known about by change it would be making

00:16:09,809 --> 00:16:15,899
the same queries and going on with its

00:16:12,029 --> 00:16:21,110
business so you just need to update

00:16:15,899 --> 00:16:24,329
function in the resolver in the schema

00:16:21,110 --> 00:16:27,119
another example is what if the business

00:16:24,329 --> 00:16:30,629
say now invoke a website we want to show

00:16:27,119 --> 00:16:32,810
shoe content we need to make queries to

00:16:30,629 --> 00:16:36,440
we need to make request to a show

00:16:32,810 --> 00:16:41,360
API how about life so if we have these

00:16:36,440 --> 00:16:43,820
two API pays our graph QL layer would

00:16:41,360 --> 00:16:47,029
just resolve those fields from the the

00:16:43,820 --> 00:16:49,310
relevant API so if it was getting shoes

00:16:47,029 --> 00:16:53,000
you want to go to the rainbow API in

00:16:49,310 --> 00:16:56,089
issues if it was just the normal content

00:16:53,000 --> 00:16:58,130
it would go to our CMS and get it from

00:16:56,089 --> 00:16:59,570
there but are we a complication would

00:16:58,130 --> 00:17:02,270
just it wouldn't really know about this

00:16:59,570 --> 00:17:04,510
complication it would it's just really

00:17:02,270 --> 00:17:08,510
on the gospel layers

00:17:04,510 --> 00:17:11,540
so our application is resilient to any

00:17:08,510 --> 00:17:13,730
change that the API developers or the

00:17:11,540 --> 00:17:18,410
business decide to do so if I a PR

00:17:13,730 --> 00:17:20,270
changes our application is resilient and

00:17:18,410 --> 00:17:22,670
we can react to any sort of technical

00:17:20,270 --> 00:17:27,290
changes that happen and we won't be

00:17:22,670 --> 00:17:31,130
devastated devastated by it so why might

00:17:27,290 --> 00:17:33,110
you use Baskerville so this is why we

00:17:31,130 --> 00:17:35,030
use graph UL but here are some use cases

00:17:33,110 --> 00:17:38,660
that we're imagining that you might want

00:17:35,030 --> 00:17:41,600
to use graphic UL for use case number

00:17:38,660 --> 00:17:44,300
one you're building an API that has

00:17:41,600 --> 00:17:46,400
multiple consumers and by this I mean

00:17:44,300 --> 00:17:48,650
what if you have an API that serves

00:17:46,400 --> 00:17:51,770
different applications like it might be

00:17:48,650 --> 00:17:54,350
serving both the vogue web application

00:17:51,770 --> 00:17:58,490
and also a native application and native

00:17:54,350 --> 00:18:01,850
apps evoke the good thing is that graph

00:17:58,490 --> 00:18:03,410
QL is what I call product friendly by

00:18:01,850 --> 00:18:07,310
which I mean there's a lower barrier to

00:18:03,410 --> 00:18:09,170
entry for new consumers to an API it

00:18:07,310 --> 00:18:11,330
reduces the burden on consumers to

00:18:09,170 --> 00:18:13,880
perform logic because it's all done in

00:18:11,330 --> 00:18:16,670
the graph QL layer which shields

00:18:13,880 --> 00:18:19,610
consumers from all the gluing together

00:18:16,670 --> 00:18:21,770
of requests it does not enforce a

00:18:19,610 --> 00:18:23,510
specific way to consume an API which

00:18:21,770 --> 00:18:25,460
gives consumers the flexibility to

00:18:23,510 --> 00:18:29,990
request data in the way that they want

00:18:25,460 --> 00:18:31,880
it so if if we're rendering a beauty

00:18:29,990 --> 00:18:34,340
category page and our web application

00:18:31,880 --> 00:18:36,860
and we want 10 articles this is what

00:18:34,340 --> 00:18:38,410
query would look like we all saw 10

00:18:36,860 --> 00:18:41,020
articles and we want

00:18:38,410 --> 00:18:42,730
title and an image for both of them but

00:18:41,020 --> 00:18:46,870
then if we want to render a beauty

00:18:42,730 --> 00:18:48,550
category in our native application but

00:18:46,870 --> 00:18:51,370
we only want images we don't have to be

00:18:48,550 --> 00:18:53,770
burdened with those articles so we can

00:18:51,370 --> 00:18:58,720
just ask for the images that we want and

00:18:53,770 --> 00:19:00,100
that's all we will get back so you will

00:18:58,720 --> 00:19:02,290
improve the experience of other

00:19:00,100 --> 00:19:07,720
developers using your API if it is craft

00:19:02,290 --> 00:19:09,760
well you save number two you're building

00:19:07,720 --> 00:19:12,850
an application which has multiple data

00:19:09,760 --> 00:19:14,980
sources so you can use graph QL as a

00:19:12,850 --> 00:19:17,710
layer that allows you to get data from

00:19:14,980 --> 00:19:20,350
many different places you can combine

00:19:17,710 --> 00:19:22,480
data from pretty much anywhere but only

00:19:20,350 --> 00:19:25,990
interact with one interface in your main

00:19:22,480 --> 00:19:29,170
application for example you could get

00:19:25,990 --> 00:19:32,590
data from a REST API a graph QL API and

00:19:29,170 --> 00:19:33,760
a database and smoosh it all together so

00:19:32,590 --> 00:19:37,690
it would look like this

00:19:33,760 --> 00:19:39,040
so our app is getting data the craft QL

00:19:37,690 --> 00:19:41,350
layer is getting data from three

00:19:39,040 --> 00:19:45,850
different places to different api's and

00:19:41,350 --> 00:19:47,440
one database and I'll react application

00:19:45,850 --> 00:19:48,910
which is serving the website has no idea

00:19:47,440 --> 00:19:52,060
because it's just interacting with graph

00:19:48,910 --> 00:19:53,590
QL and it has a consistent schema it

00:19:52,060 --> 00:19:57,070
doesn't care where the data comes from

00:19:53,590 --> 00:19:59,470
behind the scenes nodes graph QL and

00:19:57,070 --> 00:20:00,850
breast and not mutually exclusive what

00:19:59,470 --> 00:20:03,310
we've described in this talk is you

00:20:00,850 --> 00:20:08,260
think graph QL as a layer on top of a

00:20:03,310 --> 00:20:10,540
REST API and you can do the same so you

00:20:08,260 --> 00:20:14,950
can put graph QL as a layer over REST

00:20:10,540 --> 00:20:17,710
API elder graph QL API is a JSON file a

00:20:14,950 --> 00:20:21,280
database random things in your file

00:20:17,710 --> 00:20:23,230
system and your main application where

00:20:21,280 --> 00:20:25,170
it care what's happening behind the

00:20:23,230 --> 00:20:27,580
scenes

00:20:25,170 --> 00:20:30,910
you'll have your resolve functions we'll

00:20:27,580 --> 00:20:33,430
handle all of the complication you say

00:20:30,910 --> 00:20:35,230
Samba 3 you want to enforce structure in

00:20:33,430 --> 00:20:38,080
your crew base where there was no

00:20:35,230 --> 00:20:40,720
structure before graph 2 L encourages

00:20:38,080 --> 00:20:43,750
good habits it will help you to separate

00:20:40,720 --> 00:20:45,340
your concerns and it will encourage you

00:20:43,750 --> 00:20:47,890
to remove logic that is specific to

00:20:45,340 --> 00:20:49,799
third party api's from your client

00:20:47,890 --> 00:20:55,080
application yay

00:20:49,799 --> 00:20:57,239
Kewell and then before you filt your

00:20:55,080 --> 00:21:00,539
rest api like a pseudo graph QL api

00:20:57,239 --> 00:21:02,749
anyway do you have one endpoint which

00:21:00,539 --> 00:21:05,429
fetches fields based on a query per on

00:21:02,749 --> 00:21:07,980
it might look well it's basically

00:21:05,429 --> 00:21:09,570
already graph QL if you've seen an API

00:21:07,980 --> 00:21:12,989
that looks like this where there's one

00:21:09,570 --> 00:21:14,850
endpoint content and then there's a

00:21:12,989 --> 00:21:17,460
query parameter

00:21:14,850 --> 00:21:20,039
you want so say I want title author and

00:21:17,460 --> 00:21:21,989
body this is familiar because it's kind

00:21:20,039 --> 00:21:29,489
of graph QL so if you have an API like

00:21:21,989 --> 00:21:31,830
that just make it graph QL lean in use

00:21:29,489 --> 00:21:34,859
case number five because it's fun and

00:21:31,830 --> 00:21:36,119
everybody else is doing it no this is

00:21:34,859 --> 00:21:38,369
not the only reason that you should

00:21:36,119 --> 00:21:40,259
choose a tool but combined with all the

00:21:38,369 --> 00:21:42,239
other amazing factors that make graph QL

00:21:40,259 --> 00:21:45,269
so lovable I think it's another great

00:21:42,239 --> 00:21:48,480
reason to use graph QL note we are not

00:21:45,269 --> 00:21:54,680
sponsored by graph QL we're just really

00:21:48,480 --> 00:22:00,069
big fan thank you and long live graph QL

00:21:54,680 --> 00:22:00,069

YouTube URL: https://www.youtube.com/watch?v=pdBJ8EnLGEI


