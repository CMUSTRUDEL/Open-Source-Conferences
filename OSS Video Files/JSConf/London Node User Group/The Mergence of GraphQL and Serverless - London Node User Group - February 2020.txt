Title: The Mergence of GraphQL and Serverless - London Node User Group - February 2020
Publication date: 2020-03-17
Playlist: London Node User Group
Description: 
	The Mergence of Graphql and Serverless

Speaker: Tatenda Chawanzwa

In this talk we'll go over why these two technologies (Graphql & Serverless) have drastically gained popularity and what problems they were made to solve. Then we'll go through how the two can be used together and I'll do a little demo with the Serverless framework

I've been a professional developer for about 3 years. In that time I've worked for small startups to large corporations. List includes Ruuby, Sky and Eurostar to name a few.
Twitter handle is @shadrech17

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,120 --> 00:00:06,509
hello yup so my name is Teton de

00:00:03,689 --> 00:00:08,730
Carranza I've been a developer for what

00:00:06,509 --> 00:00:11,820
three years and so forth so I've used

00:00:08,730 --> 00:00:13,860
the minute and technologies which today

00:00:11,820 --> 00:00:15,990
I want to share with you two which I

00:00:13,860 --> 00:00:17,699
really enjoy using and so forth which is

00:00:15,990 --> 00:00:19,410
graphical and service

00:00:17,699 --> 00:00:21,210
these are I've been gaining headway

00:00:19,410 --> 00:00:23,640
throughout the industry and I thought

00:00:21,210 --> 00:00:25,470
maybe since I used some less a lot

00:00:23,640 --> 00:00:27,420
because it's a nice entry level in the

00:00:25,470 --> 00:00:29,010
backend and graph qo for fun and it

00:00:27,420 --> 00:00:31,349
makes it much easier to actually deploy

00:00:29,010 --> 00:00:32,700
a back-end service so today I wanna talk

00:00:31,349 --> 00:00:35,250
of how these two can be combined

00:00:32,700 --> 00:00:36,989
together in one service so before we

00:00:35,250 --> 00:00:39,030
start maybe it's I thought I'd do a

00:00:36,989 --> 00:00:41,399
recap on like what is graphed well and

00:00:39,030 --> 00:00:43,320
what is serviced because before we dive

00:00:41,399 --> 00:00:44,520
into how they can work together find out

00:00:43,320 --> 00:00:48,899
how what they are exactly

00:00:44,520 --> 00:00:50,250
so maybe was always service and the main

00:00:48,899 --> 00:00:52,410
the main thing to understand about

00:00:50,250 --> 00:00:54,899
service is that you to understand why is

00:00:52,410 --> 00:00:56,329
there so many like so I should note

00:00:54,899 --> 00:00:58,500
developers we live in a world where

00:00:56,329 --> 00:01:00,030
frameworks are coming up left right and

00:00:58,500 --> 00:01:02,359
center like if your front-end developer

00:01:00,030 --> 00:01:05,339
was backbone than it was view is what

00:01:02,359 --> 00:01:06,390
angular then react was so there's a

00:01:05,339 --> 00:01:07,979
purpose and a reason why these

00:01:06,390 --> 00:01:09,750
frameworks are there and there's a

00:01:07,979 --> 00:01:11,100
reason why service is there there's a

00:01:09,750 --> 00:01:14,760
reason why it won't work unless you

00:01:11,100 --> 00:01:17,189
serving us and the first thing to

00:01:14,760 --> 00:01:20,670
realize our service is that service is

00:01:17,189 --> 00:01:23,520
not serving us so by that I mean that we

00:01:20,670 --> 00:01:25,290
we all need service so either way this

00:01:23,520 --> 00:01:27,600
you're gonna have this so servile is

00:01:25,290 --> 00:01:29,369
that don't mean you don't have data

00:01:27,600 --> 00:01:30,840
centers so either way you can have a

00:01:29,369 --> 00:01:32,610
place actually host your code in fact

00:01:30,840 --> 00:01:33,960
you're gonna have more fit because now

00:01:32,610 --> 00:01:37,020
many providers

00:01:33,960 --> 00:01:39,180
okay so service it's not service in the

00:01:37,020 --> 00:01:42,450
internet state that there's no physical

00:01:39,180 --> 00:01:44,579
service but a definition Wikipedia sort

00:01:42,450 --> 00:01:46,590
of for truth which service computing is

00:01:44,579 --> 00:01:48,659
a cloud computing execution model in

00:01:46,590 --> 00:01:50,759
which the cloud provider runs the server

00:01:48,659 --> 00:01:53,399
and dynamically manages the allocation

00:01:50,759 --> 00:01:55,710
of machine resources so before imagine

00:01:53,399 --> 00:01:58,950
you had to deploy a service you deploy a

00:01:55,710 --> 00:02:00,210
server or an API you had to have the

00:01:58,950 --> 00:02:02,189
infrastructure so you had to had like

00:02:00,210 --> 00:02:03,509
maybe a physical machines yet you had to

00:02:02,189 --> 00:02:05,369
actually have like a datacenter to

00:02:03,509 --> 00:02:06,840
actually deploy your code and by that

00:02:05,369 --> 00:02:08,550
connect that server to the Internet and

00:02:06,840 --> 00:02:10,170
so forth and the answer like host this

00:02:08,550 --> 00:02:13,239
and he had to maintain his hardware and

00:02:10,170 --> 00:02:15,930
the entry level to actually produce

00:02:13,239 --> 00:02:18,129
as API for sample was high but now

00:02:15,930 --> 00:02:20,439
service computing allows you just to

00:02:18,129 --> 00:02:23,920
write a piece of code and basically you

00:02:20,439 --> 00:02:26,319
take that code and you you uploaded your

00:02:23,920 --> 00:02:27,939
uploaded to any provider so now there's

00:02:26,319 --> 00:02:30,099
the landscape is vast

00:02:27,939 --> 00:02:32,859
so now providers can be a double yes but

00:02:30,099 --> 00:02:33,609
the leader this as your there's a Google

00:02:32,859 --> 00:02:35,049
and so forth

00:02:33,609 --> 00:02:36,370
so that all these providers they

00:02:35,049 --> 00:02:39,069
basically take your piece of code and

00:02:36,370 --> 00:02:40,930
basically they using various gateways

00:02:39,069 --> 00:02:44,049
like for Amazon am I talking but based

00:02:40,930 --> 00:02:46,209
mostly on Amazon's as a provider Amazon

00:02:44,049 --> 00:02:48,400
there's an API gateway as workers one so

00:02:46,209 --> 00:02:51,400
you like you can basically vote your

00:02:48,400 --> 00:02:53,709
routes and say slash whatever query go

00:02:51,400 --> 00:02:56,230
and execute this function and basically

00:02:53,709 --> 00:02:58,780
the good thing about service is that the

00:02:56,230 --> 00:03:00,670
Vantage's are that firstly cost so

00:02:58,780 --> 00:03:03,180
imagine before when you had a physical

00:03:00,670 --> 00:03:06,250
server and he had a physical machine

00:03:03,180 --> 00:03:10,599
even when your traffic even if it be

00:03:06,250 --> 00:03:12,040
produced and unpopular sites even if

00:03:10,599 --> 00:03:13,599
your traffic was down you still pay for

00:03:12,040 --> 00:03:15,189
that server you still pay for the

00:03:13,599 --> 00:03:16,810
yeasterday view you still pay for that

00:03:15,189 --> 00:03:17,949
cost of actually running a server but

00:03:16,810 --> 00:03:20,859
the good thing about lambda and/or

00:03:17,949 --> 00:03:23,709
service is that when the traffic is low

00:03:20,859 --> 00:03:26,260
basically you don't pay for it so you

00:03:23,709 --> 00:03:28,239
only pay for the minutes and and the

00:03:26,260 --> 00:03:29,739
amount of power that your your lambda

00:03:28,239 --> 00:03:33,579
function or your your piece of code

00:03:29,739 --> 00:03:35,319
actually executes so that's the one

00:03:33,579 --> 00:03:37,090
advantage the good thing is scalability

00:03:35,319 --> 00:03:39,340
at all so like what I mentioned that

00:03:37,090 --> 00:03:41,079
it's not just about one server it's

00:03:39,340 --> 00:03:43,479
about not this would be multiple this

00:03:41,079 --> 00:03:46,810
more than just one because now with

00:03:43,479 --> 00:03:48,400
hittable yes in a way the bad thing

00:03:46,810 --> 00:03:50,169
about this in a way is that it's very

00:03:48,400 --> 00:03:52,479
much inventor locked and you don't know

00:03:50,169 --> 00:03:54,549
what's happening under the hood so have

00:03:52,479 --> 00:03:55,599
very basic I don't claim to actually

00:03:54,549 --> 00:03:58,239
know how they implement this under the

00:03:55,599 --> 00:04:00,220
hood but I'd imagine that whenever your

00:03:58,239 --> 00:04:02,769
code once you get executed let's say a

00:04:00,220 --> 00:04:04,900
query comes basically I think docker and

00:04:02,769 --> 00:04:08,290
containers a container is basically

00:04:04,900 --> 00:04:10,780
sprung up basically within Linux Linux

00:04:08,290 --> 00:04:12,370
environment and basically it downloads

00:04:10,780 --> 00:04:14,530
your so imagine server this is basically

00:04:12,370 --> 00:04:16,269
you take your code your function your

00:04:14,530 --> 00:04:18,669
package intercept file and your plugs on

00:04:16,269 --> 00:04:20,889
to some sort of bucket like s3 example

00:04:18,669 --> 00:04:23,520
and then order a service when a request

00:04:20,889 --> 00:04:26,650
comes in maybe it instantiates a

00:04:23,520 --> 00:04:30,610
container with Linux and so forth it

00:04:26,650 --> 00:04:32,680
loads if ow and I'm packages it then you

00:04:30,610 --> 00:04:36,310
want the code and so forth so you can

00:04:32,680 --> 00:04:38,800
imagine that now with AWS with cloud for

00:04:36,310 --> 00:04:41,770
example with s3 that can distribute your

00:04:38,800 --> 00:04:44,020
function the code around the world so

00:04:41,770 --> 00:04:45,789
it's easily when someone requests let's

00:04:44,020 --> 00:04:50,889
say your server from India

00:04:45,789 --> 00:04:52,570
the closest region with the with the AWS

00:04:50,889 --> 00:04:54,910
later zone can actually run your code

00:04:52,570 --> 00:04:57,370
and procurement action matters in this

00:04:54,910 --> 00:04:58,870
in this case so it'll be much faster so

00:04:57,370 --> 00:05:00,580
it's scalable and this is something that

00:04:58,870 --> 00:05:03,039
you get up you get under the hood as and

00:05:00,580 --> 00:05:04,630
you get it with no extra extra cost I

00:05:03,039 --> 00:05:05,710
mean there's you do pay for it but in

00:05:04,630 --> 00:05:07,449
this something that you use it not to

00:05:05,710 --> 00:05:09,460
like configure yourself it comes just by

00:05:07,449 --> 00:05:11,320
the vendor and in the development so

00:05:09,460 --> 00:05:14,889
before as a back in there that may be

00:05:11,320 --> 00:05:16,180
yet to like like configure Linux

00:05:14,889 --> 00:05:18,699
environment you will configure the

00:05:16,180 --> 00:05:20,229
server nginx the item cook considered

00:05:18,699 --> 00:05:21,669
black security you had to consider

00:05:20,229 --> 00:05:24,910
networking you had to consider this and

00:05:21,669 --> 00:05:27,610
like it was just headache but now all

00:05:24,910 --> 00:05:29,259
that is taken away and AWS Bezos just

00:05:27,610 --> 00:05:30,760
says don't about it I'm bridge I'm

00:05:29,259 --> 00:05:32,740
taking care of it you just worry about

00:05:30,760 --> 00:05:34,449
you you've run your code you run your

00:05:32,740 --> 00:05:36,940
code give it to me and I'll put it on to

00:05:34,449 --> 00:05:38,050
s3 and I run it so that's a good thing

00:05:36,940 --> 00:05:40,180
about service is that the ease of

00:05:38,050 --> 00:05:41,560
development now we see that many fun and

00:05:40,180 --> 00:05:44,199
developers actually getting into

00:05:41,560 --> 00:05:47,680
back-end because of service and so forth

00:05:44,199 --> 00:05:49,360
so that's the one of the main reasons

00:05:47,680 --> 00:05:51,310
the good thing reasons about service and

00:05:49,360 --> 00:05:53,380
it maybe begs the question that you know

00:05:51,310 --> 00:05:54,760
maybe that's several as all things let's

00:05:53,380 --> 00:05:57,610
forget about containers let's forget

00:05:54,760 --> 00:06:00,880
about it and just so then there is a

00:05:57,610 --> 00:06:02,590
caveat the are disadvantages so one such

00:06:00,880 --> 00:06:05,099
advantage of cerberus is that code

00:06:02,590 --> 00:06:07,479
execution so that's my example of

00:06:05,099 --> 00:06:10,240
containers so imagine when the container

00:06:07,479 --> 00:06:12,460
first springs up that time it takes a

00:06:10,240 --> 00:06:14,860
spring up and then download your code

00:06:12,460 --> 00:06:17,320
and when you code that time is time that

00:06:14,860 --> 00:06:19,150
it actually make a request longer so

00:06:17,320 --> 00:06:21,220
therefore there is what the cool code

00:06:19,150 --> 00:06:22,900
starts in the world of surfing is so

00:06:21,220 --> 00:06:24,970
basically when your foot with the first

00:06:22,900 --> 00:06:26,560
your first first request that comes in

00:06:24,970 --> 00:06:29,289
it actually has to find a container

00:06:26,560 --> 00:06:31,300
spring it up burn your code and money so

00:06:29,289 --> 00:06:33,310
that that code store can actually delay

00:06:31,300 --> 00:06:34,810
your request for a bit but now there is

00:06:33,310 --> 00:06:36,940
like so the good thing is after that

00:06:34,810 --> 00:06:38,889
first initial code start after the

00:06:36,940 --> 00:06:40,360
container runs your code like it AWS

00:06:38,889 --> 00:06:42,310
they actually keep the container

00:06:40,360 --> 00:06:43,750
warm state so they don't don't shut it

00:06:42,310 --> 00:06:45,550
down for time being they keep it a warm

00:06:43,750 --> 00:06:46,930
state and maybe for like ten minutes if

00:06:45,550 --> 00:06:50,289
any request comes in you can basically

00:06:46,930 --> 00:06:52,449
reuse that same that same that container

00:06:50,289 --> 00:06:54,189
then it's quicker so they are like

00:06:52,449 --> 00:06:55,719
waiting around it but yeah that's

00:06:54,189 --> 00:06:57,610
something to consider and then resource

00:06:55,719 --> 00:07:01,210
limitation so a lambda function I think

00:06:57,610 --> 00:07:03,939
a double yes the limit of there is the

00:07:01,210 --> 00:07:07,389
limit the mana commuting computing power

00:07:03,939 --> 00:07:09,069
that you can put but you can have in a

00:07:07,389 --> 00:07:11,770
container so I think for Tom before Ram

00:07:09,069 --> 00:07:14,409
you can have a lot to gig max RAM and

00:07:11,770 --> 00:07:16,900
the memory is all so you need to learn

00:07:14,409 --> 00:07:19,030
the function come be above 50 MB so yeah

00:07:16,900 --> 00:07:22,240
they are like limitations so if you're

00:07:19,030 --> 00:07:24,069
building like later on I will what are

00:07:22,240 --> 00:07:26,409
the one of the uses of serving us on

00:07:24,069 --> 00:07:27,789
Netflix but not in no in the way that

00:07:26,409 --> 00:07:29,650
you think they will use it but I mean

00:07:27,789 --> 00:07:31,539
and okay the second thought or third

00:07:29,650 --> 00:07:33,460
point is vendor lock so here you're like

00:07:31,539 --> 00:07:37,599
tides you're tied to a specific vendor

00:07:33,460 --> 00:07:39,039
so I mean like you're tied to AWS if AWS

00:07:37,599 --> 00:07:41,620
fail basically you failed

00:07:39,039 --> 00:07:43,840
basically if Bezos gets broke you broke

00:07:41,620 --> 00:07:45,520
so basically you canít idea tighter

00:07:43,840 --> 00:07:48,669
vendor and so forth so that's the

00:07:45,520 --> 00:07:50,680
disadvantage and privacy so I mean right

00:07:48,669 --> 00:07:53,620
now Microsoft and Amazon were fighting

00:07:50,680 --> 00:07:55,240
for a contract with with I think

00:07:53,620 --> 00:07:57,849
Ministry of Defense America and so forth

00:07:55,240 --> 00:08:00,879
so it definitely they didn't pitch

00:07:57,849 --> 00:08:02,589
service I I don't think they paid

00:08:00,879 --> 00:08:04,210
service conserve this kind of you know

00:08:02,589 --> 00:08:05,379
it means that their code is kind of

00:08:04,210 --> 00:08:07,270
cause I I think the container the kind

00:08:05,379 --> 00:08:09,969
of shared environments of course I don't

00:08:07,270 --> 00:08:11,620
they pitch didn't pitch service I don't

00:08:09,969 --> 00:08:14,229
think because it's like their code is

00:08:11,620 --> 00:08:15,400
maybe in a shared hosting whereas for

00:08:14,229 --> 00:08:18,940
that maybe you want like your own

00:08:15,400 --> 00:08:20,409
dedicated like like hosting kind of so

00:08:18,940 --> 00:08:24,069
yeah privacy as always want to consider

00:08:20,409 --> 00:08:25,449
and then so who's using it so yeah it's

00:08:24,069 --> 00:08:28,210
more or less who's not using it I think

00:08:25,449 --> 00:08:30,069
everyone now is using it from code pants

00:08:28,210 --> 00:08:33,310
de vocht Netflix coca-cola company I

00:08:30,069 --> 00:08:34,659
mean there David did they spoke at a AWS

00:08:33,310 --> 00:08:37,209
summit and they've been said that how

00:08:34,659 --> 00:08:38,560
they're saving more than 60 or kind of

00:08:37,209 --> 00:08:41,560
money by saving by his in service

00:08:38,560 --> 00:08:43,539
because before they were paying for

00:08:41,560 --> 00:08:45,339
every hour that that the SL was up but

00:08:43,539 --> 00:08:47,860
now I do any paying for execution

00:08:45,339 --> 00:08:50,290
Netflix some Netflix what I spoke about

00:08:47,860 --> 00:08:51,819
and Netflix there are new service for

00:08:50,290 --> 00:08:53,920
their data crunching so you can imagine

00:08:51,819 --> 00:08:56,259
Netflix like the

00:08:53,920 --> 00:08:58,119
the speaker spoke of how when a video

00:08:56,259 --> 00:08:59,589
when you when they first receive a video

00:08:58,119 --> 00:09:01,389
from a vendor whatever they are

00:08:59,589 --> 00:09:03,399
basically splitted and then they convert

00:09:01,389 --> 00:09:05,109
it into many different formats I like

00:09:03,399 --> 00:09:05,470
for small screens for bug screen and so

00:09:05,109 --> 00:09:07,720
forth

00:09:05,470 --> 00:09:09,459
so therefore in that model if you use

00:09:07,720 --> 00:09:11,949
services you're limited in the computer

00:09:09,459 --> 00:09:13,660
and the computing power so for them is

00:09:11,949 --> 00:09:15,970
more or less he said he stated that how

00:09:13,660 --> 00:09:18,459
they split the video into five minute

00:09:15,970 --> 00:09:20,739
chunks and basically they then they

00:09:18,459 --> 00:09:23,079
encoded separately and basically they're

00:09:20,739 --> 00:09:24,819
serving us to then have an event to say

00:09:23,079 --> 00:09:28,329
when all these five minute chunks I

00:09:24,819 --> 00:09:29,379
actually encoded then I don't under

00:09:28,329 --> 00:09:31,359
function then comes together and then

00:09:29,379 --> 00:09:33,160
combine them together so the saw the

00:09:31,359 --> 00:09:35,499
service you really have to know your use

00:09:33,160 --> 00:09:37,600
case so it's not a matter of cerberus

00:09:35,499 --> 00:09:38,679
all things it's more of the into study

00:09:37,600 --> 00:09:40,809
and I actually found out was the best

00:09:38,679 --> 00:09:43,660
use case because for necklace no Netflix

00:09:40,809 --> 00:09:45,249
maybe running as no more server an ec2

00:09:43,660 --> 00:09:47,589
instance is the best for them from the

00:09:45,249 --> 00:09:49,809
encoding so that's the that's the so you

00:09:47,589 --> 00:09:52,239
need to understand like what's the best

00:09:49,809 --> 00:09:55,389
way around it so now that leads us to so

00:09:52,239 --> 00:09:57,699
that's serving us done now to go after

00:09:55,389 --> 00:10:00,100
all so go after all another Wikipedia

00:09:57,699 --> 00:10:01,660
source of all truth golf call it so I

00:10:00,100 --> 00:10:05,169
think I want me to go deep into it but

00:10:01,660 --> 00:10:07,329
just cover just a highlights so golf

00:10:05,169 --> 00:10:09,579
claw is an open source data query and

00:10:07,329 --> 00:10:11,799
manipulation language for AP eyes and a

00:10:09,579 --> 00:10:13,929
runtime for fulfilling queries with the

00:10:11,799 --> 00:10:15,790
existing data golf Keo has developed and

00:10:13,929 --> 00:10:17,649
wasn't developed internally by Facebook

00:10:15,790 --> 00:10:19,809
in twenty twenty twelve before being

00:10:17,649 --> 00:10:21,850
publicly released in 2015 so you can

00:10:19,809 --> 00:10:23,799
imagine what's the old school the old

00:10:21,850 --> 00:10:26,499
school was basically they've been many

00:10:23,799 --> 00:10:28,809
soap rest so rest rest what is it it's

00:10:26,499 --> 00:10:30,819
like a paradigm that we all that we've

00:10:28,809 --> 00:10:32,709
all basically agreed upon house

00:10:30,819 --> 00:10:36,009
different servers can communicate and

00:10:32,709 --> 00:10:38,259
actually retrieve and give data or

00:10:36,009 --> 00:10:39,910
communicate with other servers so

00:10:38,259 --> 00:10:42,970
basically arrest you have the you have

00:10:39,910 --> 00:10:45,429
the fat or the the the part of the right

00:10:42,970 --> 00:10:47,079
you have get we're gonna get you if I

00:10:45,429 --> 00:10:50,079
get information you actually do a get

00:10:47,079 --> 00:10:52,359
request we have post you have so yeah so

00:10:50,079 --> 00:10:54,399
basically the best way to understand

00:10:52,359 --> 00:10:56,739
golf-ball is to do like a comparison of

00:10:54,399 --> 00:10:57,970
rest and graph QL that's the best words

00:10:56,739 --> 00:11:01,179
can understand the two and so forth

00:10:57,970 --> 00:11:03,279
sorry the best way to do it may be to

00:11:01,179 --> 00:11:06,369
analyze twitter twitter use graph cool

00:11:03,279 --> 00:11:08,050
but then imagine if this Twitter site if

00:11:06,369 --> 00:11:09,610
you're basically hosting

00:11:08,050 --> 00:11:12,570
and you had to do this in a REST API

00:11:09,610 --> 00:11:16,090
service I imagine maybe for this main

00:11:12,570 --> 00:11:17,980
main blog post Oh tweets

00:11:16,090 --> 00:11:19,540
yeah maybe a tweet endpoint so maybe you

00:11:17,980 --> 00:11:22,090
have so in verse you have get post put

00:11:19,540 --> 00:11:24,520
delete so maybe for the first to get all

00:11:22,090 --> 00:11:26,530
the tweets you have a you have a get

00:11:24,520 --> 00:11:28,540
tweets request so in that get tweets

00:11:26,530 --> 00:11:30,820
maybe I'll give you a tweets and it's a

00:11:28,540 --> 00:11:32,560
way of objects and in there you get all

00:11:30,820 --> 00:11:34,450
the different tweet data so basically

00:11:32,560 --> 00:11:36,760
for each tweet I can give you the idea

00:11:34,450 --> 00:11:39,160
that tweets like the content the user

00:11:36,760 --> 00:11:42,070
Diana burn off if you don't know him but

00:11:39,160 --> 00:11:44,950
I spot his name wrong how there are di

00:11:42,070 --> 00:11:47,020
but yeah but yeah that I'm more sorry it

00:11:44,950 --> 00:11:49,600
basically you can get get the trees into

00:11:47,020 --> 00:11:51,580
objects and an array of objects of all

00:11:49,600 --> 00:11:53,170
the tweets and not a nut basically get

00:11:51,580 --> 00:11:54,880
requests so let's say they come again

00:11:53,170 --> 00:11:57,430
the front-end team coming in again and

00:11:54,880 --> 00:12:00,370
say oh crap Anderson now we want another

00:11:57,430 --> 00:12:02,350
request for when we click on the Twitter

00:12:00,370 --> 00:12:04,630
when I click on a tweet I wanna be able

00:12:02,350 --> 00:12:06,520
to basically have another API call where

00:12:04,630 --> 00:12:08,620
I actually have more data so I want the

00:12:06,520 --> 00:12:10,630
comments of that tweet so maybe we go we

00:12:08,620 --> 00:12:12,760
go okay so I can find maybe we have

00:12:10,630 --> 00:12:16,420
another get request to tweet slash ID

00:12:12,760 --> 00:12:18,820
which is a parameter can use and I

00:12:16,420 --> 00:12:20,830
request and then we actually just return

00:12:18,820 --> 00:12:23,260
a tree to the object and we return more

00:12:20,830 --> 00:12:25,360
info so now we return the comments and

00:12:23,260 --> 00:12:27,460
basically it's an array of objects or

00:12:25,360 --> 00:12:29,560
comments or the different thing so now

00:12:27,460 --> 00:12:31,510
we're now have two bureaus and then we

00:12:29,560 --> 00:12:34,030
would actually erratic brother we've had

00:12:31,510 --> 00:12:36,310
to bother the backend team again and

00:12:34,030 --> 00:12:38,680
they maybe next week locker listen I

00:12:36,310 --> 00:12:40,270
want to click on Dan Abramov and I want

00:12:38,680 --> 00:12:41,860
or maybe to hop over him and when I

00:12:40,270 --> 00:12:46,090
hover over him I wanted a brief outline

00:12:41,860 --> 00:12:48,100
of his of its profile that maybe you

00:12:46,090 --> 00:12:51,010
create another another endpoint say ok

00:12:48,100 --> 00:12:52,030
find user slash ID then a birth and they

00:12:51,010 --> 00:12:53,620
come again next week sidewalk fight

00:12:52,030 --> 00:12:56,710
listen I want another request and this

00:12:53,620 --> 00:12:59,110
time I want our when I hover over his

00:12:56,710 --> 00:13:00,370
whatever and it's a back and forth back

00:12:59,110 --> 00:13:03,250
and forth back and she'll just be like

00:13:00,370 --> 00:13:05,080
listen dude do yourself basically that's

00:13:03,250 --> 00:13:07,560
the area that can that's how the

00:13:05,080 --> 00:13:09,520
connection I get getting frustrated so

00:13:07,560 --> 00:13:11,110
let's think of how connection change

00:13:09,520 --> 00:13:14,440
this and actually implement this with

00:13:11,110 --> 00:13:16,540
graph QL so graph Q or the schema

00:13:14,440 --> 00:13:19,840
language is basically it words by types

00:13:16,540 --> 00:13:21,180
so basically it's one where well so what

00:13:19,840 --> 00:13:22,410
in this one year old

00:13:21,180 --> 00:13:24,900
basically making you can make anything

00:13:22,410 --> 00:13:26,790
you want slash query and in this one

00:13:24,900 --> 00:13:29,190
year L you can basically have a query

00:13:26,790 --> 00:13:33,150
and in this query is you can name it

00:13:29,190 --> 00:13:35,280
tweets and basically by saying tweets

00:13:33,150 --> 00:13:38,430
and then it can give it whatever

00:13:35,280 --> 00:13:40,470
arguments you want limit at some point

00:13:38,430 --> 00:13:42,810
if I don't limit which I have so I

00:13:40,470 --> 00:13:45,660
thought about having slash tweets isn't

00:13:42,810 --> 00:13:48,270
get I can have this tweets query and

00:13:45,660 --> 00:13:49,980
then this ending array is basically have

00:13:48,270 --> 00:13:52,070
a turn statement so if anyone has used

00:13:49,980 --> 00:13:55,830
tab script how many of you stab scripts

00:13:52,070 --> 00:13:57,960
yeah exactly the same so tab script you

00:13:55,830 --> 00:14:00,210
can say this this function returns

00:13:57,960 --> 00:14:02,340
whatever so whatever semicolon then

00:14:00,210 --> 00:14:04,470
whatever it returns same thing is so

00:14:02,340 --> 00:14:06,450
here you basically saying that basically

00:14:04,470 --> 00:14:09,240
these tweets will return an array of

00:14:06,450 --> 00:14:11,880
tweet and basically a tweet is basically

00:14:09,240 --> 00:14:15,330
a a type so it stays do the mistake a

00:14:11,880 --> 00:14:20,520
medium because tweet they should be at a

00:14:15,330 --> 00:14:21,960
type there should be a type mark name

00:14:20,520 --> 00:14:24,900
space so basically a tweet of the type

00:14:21,960 --> 00:14:28,740
so its type tweet and they shouldn't be

00:14:24,900 --> 00:14:30,540
a semicolon to type scripts Kafka yep

00:14:28,740 --> 00:14:30,780
what maybe should be I don't know damn

00:14:30,540 --> 00:14:34,020
it

00:14:30,780 --> 00:14:35,700
oh but anyway uh so basically I I define

00:14:34,020 --> 00:14:37,620
what this object is so I tweet is

00:14:35,700 --> 00:14:39,480
basically ID has a tweet which is a

00:14:37,620 --> 00:14:47,180
string and basically them there are many

00:14:39,480 --> 00:14:49,170
base base base courage like base

00:14:47,180 --> 00:14:51,840
statements things you can actually turn

00:14:49,170 --> 00:14:54,870
like dead dead objects so the string is

00:14:51,840 --> 00:14:56,340
int there's ID is one way just a tidy so

00:14:54,870 --> 00:14:58,260
basically and then you can also have

00:14:56,340 --> 00:15:00,540
custom custom types so basically if I

00:14:58,260 --> 00:15:04,140
say user I can say a user object and

00:15:00,540 --> 00:15:06,810
basically add in the same schema I can

00:15:04,140 --> 00:15:08,520
basically say type user that should be

00:15:06,810 --> 00:15:10,080
type in front of us I do apologize so a

00:15:08,520 --> 00:15:13,230
type of user and a type of user is

00:15:10,080 --> 00:15:17,670
basically as ID and name followers and

00:15:13,230 --> 00:15:19,080
yep so it can have basically it anything

00:15:17,670 --> 00:15:21,420
you want you declare it using the user

00:15:19,080 --> 00:15:22,500
and this will basically map to what the

00:15:21,420 --> 00:15:24,120
data you have in your database or

00:15:22,500 --> 00:15:25,860
whatever and so forth so you declare

00:15:24,120 --> 00:15:31,100
your types and your maybe even your

00:15:25,860 --> 00:15:33,630
comments and so forth and then now now

00:15:31,100 --> 00:15:34,320
on the front end they only have two cool

00:15:33,630 --> 00:15:39,180
tweets

00:15:34,320 --> 00:15:41,880
and they only have two cool tweets and

00:15:39,180 --> 00:15:42,990
then the tweets itself they can they can

00:15:41,880 --> 00:15:45,269
choose what they want from the tweet

00:15:42,990 --> 00:15:48,750
object so maybe for here it's okay

00:15:45,269 --> 00:15:51,480
how kind of jumping I think I okay so

00:15:48,750 --> 00:15:54,779
okay so think and let's forget about

00:15:51,480 --> 00:15:58,440
this the filters for time being just

00:15:54,779 --> 00:16:00,180
just think on the front end I can

00:15:58,440 --> 00:16:02,519
basically say code tweets and then

00:16:00,180 --> 00:16:04,740
tweets give me a back ID tweet and

00:16:02,519 --> 00:16:06,300
comments and basically now that the

00:16:04,740 --> 00:16:07,529
front end now control what they want so

00:16:06,300 --> 00:16:09,690
the front end can say Oh fine give me

00:16:07,529 --> 00:16:11,910
the whole three object and basically

00:16:09,690 --> 00:16:13,709
take whatever the one or or they can say

00:16:11,910 --> 00:16:17,190
go fine I just give me ID I'll give you

00:16:13,709 --> 00:16:18,000
whatever so now imagine how that's very

00:16:17,190 --> 00:16:21,149
dynamic

00:16:18,000 --> 00:16:24,569
so now instead of about having another

00:16:21,149 --> 00:16:26,670
endpoint so imagine now the the the the

00:16:24,569 --> 00:16:28,290
backend the financial financing come

00:16:26,670 --> 00:16:31,860
back in second listen I want to be able

00:16:28,290 --> 00:16:34,019
to click on a tweet and then have more

00:16:31,860 --> 00:16:36,720
data like comments on what so maybe for

00:16:34,019 --> 00:16:38,490
the for the for the for the in for the

00:16:36,720 --> 00:16:40,290
initial call I'd go in the comments when

00:16:38,490 --> 00:16:43,230
I wanted to tweet it's basically this

00:16:40,290 --> 00:16:44,850
dog is happy the fun and Timur is Omid

00:16:43,230 --> 00:16:46,649
comments and basically in the back end

00:16:44,850 --> 00:16:48,240
won't get in comments and so forth but

00:16:46,649 --> 00:16:50,339
but now if there weren't comments

00:16:48,240 --> 00:16:52,139
basically you could go get the dude

00:16:50,339 --> 00:16:55,170
basically add comments and basically say

00:16:52,139 --> 00:16:59,310
what they want and another cool thing

00:16:55,170 --> 00:17:03,149
which original talk was was supposed to

00:16:59,310 --> 00:17:05,880
be about like custom custom directors so

00:17:03,149 --> 00:17:08,850
with regard to all you can have like

00:17:05,880 --> 00:17:11,130
custom directives okay so okay so for

00:17:08,850 --> 00:17:13,140
example here let's say they want their

00:17:11,130 --> 00:17:14,850
they now want to have a specific to each

00:17:13,140 --> 00:17:18,630
so basically they want to implement the

00:17:14,850 --> 00:17:20,339
slash tweet /id arrest API so now they

00:17:18,630 --> 00:17:23,699
want to have one tweet and that one

00:17:20,339 --> 00:17:26,130
tweet basically has comments and maybe

00:17:23,699 --> 00:17:27,630
in those comments you want to have the

00:17:26,130 --> 00:17:30,360
comments limited to a certain number of

00:17:27,630 --> 00:17:32,610
comments and so forth so maybe now you

00:17:30,360 --> 00:17:34,770
can introduce a control filters so now

00:17:32,610 --> 00:17:37,080
for twist instead of you giving back

00:17:34,770 --> 00:17:40,620
just a limit given that object which is

00:17:37,080 --> 00:17:42,840
basically or input or filters into tweet

00:17:40,620 --> 00:17:45,090
at we filter and the filter is biscuit

00:17:42,840 --> 00:17:46,950
input which basically you can define

00:17:45,090 --> 00:17:48,060
whatever you want them to actually

00:17:46,950 --> 00:17:49,530
request for me so

00:17:48,060 --> 00:17:52,080
limit can be the amount of tweets that

00:17:49,530 --> 00:17:53,850
you want IDs so maybe you can say go

00:17:52,080 --> 00:17:55,830
fine if you give me IDs I would

00:17:53,850 --> 00:17:58,260
basically give you a backdoor that's

00:17:55,830 --> 00:18:00,330
this array of ID's if you give me these

00:17:58,260 --> 00:18:02,820
array of ID's I'll give you back the

00:18:00,330 --> 00:18:04,740
specific tweets of those IDs and so

00:18:02,820 --> 00:18:07,200
forth so that can be the filter and then

00:18:04,740 --> 00:18:10,230
imagine now this I could find we also

00:18:07,200 --> 00:18:11,760
want to have to like have limit amount

00:18:10,230 --> 00:18:13,620
of tweets we have all the more comments

00:18:11,760 --> 00:18:15,270
web for each tweet you can have a custom

00:18:13,620 --> 00:18:17,310
a custom directive so custom directives

00:18:15,270 --> 00:18:19,740
and graph qo is that whenever year you

00:18:17,310 --> 00:18:20,790
request a certain certain object or

00:18:19,740 --> 00:18:22,230
certain field

00:18:20,790 --> 00:18:25,680
it's basically we've said that okay a

00:18:22,230 --> 00:18:27,660
tweet has got a ID as good a to has got

00:18:25,680 --> 00:18:29,700
a tweet for the string of the data and

00:18:27,660 --> 00:18:32,460
so forth let's go comments some comments

00:18:29,700 --> 00:18:34,530
can be can be an array of of common

00:18:32,460 --> 00:18:36,360
objects then in there you can actually

00:18:34,530 --> 00:18:38,430
have a custom directive which basically

00:18:36,360 --> 00:18:43,610
you can actually override the default is

00:18:38,430 --> 00:18:43,610
over so okay so in the land of graph qo

00:18:43,940 --> 00:18:48,540
this is how this is the basic the

00:18:46,830 --> 00:18:49,740
contract we have with the front end so

00:18:48,540 --> 00:18:52,950
the front end was a calf and there's a

00:18:49,740 --> 00:18:55,890
query and then in this query there's

00:18:52,950 --> 00:18:58,260
tweets and basically us in the backend

00:18:55,890 --> 00:19:00,390
who basically have to write a resolver

00:18:58,260 --> 00:19:03,270
and a resolver what it is is a function

00:19:00,390 --> 00:19:05,160
so for every single query you have you

00:19:03,270 --> 00:19:07,320
basically have to have a function on the

00:19:05,160 --> 00:19:08,640
back end which is named exactly exactly

00:19:07,320 --> 00:19:10,890
the same as a query which basically

00:19:08,640 --> 00:19:13,110
resolves what data the data that is

00:19:10,890 --> 00:19:15,870
returned so let's say I have a twist

00:19:13,110 --> 00:19:17,880
tweets resolver is basically a function

00:19:15,870 --> 00:19:20,520
a Bakley maybe makes a cool film

00:19:17,880 --> 00:19:22,170
database and it retrieves these tweets

00:19:20,520 --> 00:19:23,790
and basically returns it to you and so

00:19:22,170 --> 00:19:27,270
forth so you can fight you can tweak

00:19:23,790 --> 00:19:28,950
these tweets or you can tweak the fields

00:19:27,270 --> 00:19:31,260
that you actually get for from the

00:19:28,950 --> 00:19:32,760
database depending on the query actually

00:19:31,260 --> 00:19:35,070
got from from the front end and so forth

00:19:32,760 --> 00:19:37,110
so imagine here you can actually use an

00:19:35,070 --> 00:19:40,200
custom custom directors you can actually

00:19:37,110 --> 00:19:43,110
take over write these override there is

00:19:40,200 --> 00:19:45,630
over so now let's say in this fool to

00:19:43,110 --> 00:19:48,180
imagine in this comment filter they can

00:19:45,630 --> 00:19:50,700
say okay fine give me a limit of 10 and

00:19:48,180 --> 00:19:52,350
then now when it comes to actually

00:19:50,700 --> 00:19:55,040
resolve comments you can write your own

00:19:52,350 --> 00:19:59,100
custom like resolver which basically

00:19:55,040 --> 00:20:01,200
resolves the comments comments variable

00:19:59,100 --> 00:20:01,860
and in they and we only fetch the first

00:20:01,200 --> 00:20:04,379
10 comment

00:20:01,860 --> 00:20:07,080
and then if you want you can change it

00:20:04,379 --> 00:20:10,980
so that they can fix the next 20 maybe I

00:20:07,080 --> 00:20:14,100
have have another filter there that's

00:20:10,980 --> 00:20:15,840
offset so you can even like make them

00:20:14,100 --> 00:20:17,909
they can be able to even implement the

00:20:15,840 --> 00:20:19,679
old pagination and so forth and all this

00:20:17,909 --> 00:20:22,139
is in one URL and so forth

00:20:19,679 --> 00:20:25,379
so now using one implementation we

00:20:22,139 --> 00:20:28,080
basically covered maybe what we were

00:20:25,379 --> 00:20:29,610
covered with like four of five-year-olds

00:20:28,080 --> 00:20:32,009
the rest Rios and so forth

00:20:29,610 --> 00:20:34,830
so this is the main benefit of graph QL

00:20:32,009 --> 00:20:37,309
so the ones is that so good for complex

00:20:34,830 --> 00:20:39,779
data systems so you can imagine like

00:20:37,309 --> 00:20:42,419
many people they're coming from a

00:20:39,779 --> 00:20:44,070
Mundell system where is just like one

00:20:42,419 --> 00:20:46,679
server and its massive then they're

00:20:44,070 --> 00:20:48,570
gonna take the system and changing into

00:20:46,679 --> 00:20:51,509
more from macro services where it's like

00:20:48,570 --> 00:20:54,029
the like each each function or H like

00:20:51,509 --> 00:20:55,320
purpose or it's like business

00:20:54,029 --> 00:20:57,629
requirement has got its own like a

00:20:55,320 --> 00:21:00,779
server like each container like and so

00:20:57,629 --> 00:21:03,119
forth so Corrib plays a really good role

00:21:00,779 --> 00:21:04,320
in that it can be like the middleware

00:21:03,119 --> 00:21:06,450
between the front end and the back end

00:21:04,320 --> 00:21:08,460
and that you can make it make one query

00:21:06,450 --> 00:21:10,649
and then bit by bit you can make one

00:21:08,460 --> 00:21:12,539
macro service to actually collect

00:21:10,649 --> 00:21:14,129
comments comments and so forth and then

00:21:12,539 --> 00:21:15,989
you take away that you delegate a way

00:21:14,129 --> 00:21:17,609
that you delegate that that work away

00:21:15,989 --> 00:21:19,830
from the monolith and you delegate it to

00:21:17,609 --> 00:21:22,769
that container and they all it is in

00:21:19,830 --> 00:21:25,220
your comments and your comments resolver

00:21:22,769 --> 00:21:28,649
you just point that is over to the new

00:21:25,220 --> 00:21:30,779
to the new container so that way you can

00:21:28,649 --> 00:21:32,340
slowly move away from a Mundell of

00:21:30,779 --> 00:21:34,049
application and interamerican serves

00:21:32,340 --> 00:21:35,669
macro services mapping service

00:21:34,049 --> 00:21:37,200
application without disrupting the

00:21:35,669 --> 00:21:38,489
front-end but that's a good thing about

00:21:37,200 --> 00:21:40,799
graph qo

00:21:38,489 --> 00:21:45,720
there's no of no over-and-under fetching

00:21:40,799 --> 00:21:48,720
so imagine maybe with rest you can not

00:21:45,720 --> 00:21:51,629
to do it I mean so so a rest I can have

00:21:48,720 --> 00:21:53,129
query params like queries in the URL

00:21:51,629 --> 00:21:55,100
where I said limit in some point so

00:21:53,129 --> 00:21:57,450
forth but then after while doing that

00:21:55,100 --> 00:22:01,169
fine-grain control but you get put like

00:21:57,450 --> 00:22:02,399
a nicely schema of the nice schema you

00:22:01,169 --> 00:22:04,320
can't get that the way you can't but

00:22:02,399 --> 00:22:05,909
then you more more messy and then so

00:22:04,320 --> 00:22:07,710
here and the front-end control what they

00:22:05,909 --> 00:22:09,029
fetch so the phonic the sacrified I want

00:22:07,710 --> 00:22:10,529
this I want that they can cherry pick

00:22:09,029 --> 00:22:12,119
what they want and it's almost like the

00:22:10,529 --> 00:22:14,190
front-end can control the back end and

00:22:12,119 --> 00:22:14,790
the back end team can do less work and

00:22:14,190 --> 00:22:17,220
actually

00:22:14,790 --> 00:22:19,650
back and forth like euro in creating

00:22:17,220 --> 00:22:21,630
yours and it's a sub documentation so we

00:22:19,650 --> 00:22:23,310
rest now the technology that that I've

00:22:21,630 --> 00:22:24,870
come about like swagger

00:22:23,310 --> 00:22:26,670
so a swagger people have seen that you

00:22:24,870 --> 00:22:27,990
can put the rest the API but then how do

00:22:26,670 --> 00:22:31,170
you communicate with the Funyun and

00:22:27,990 --> 00:22:35,280
second this this URL does this and this

00:22:31,170 --> 00:22:37,800
rule accepts this basically by having us

00:22:35,280 --> 00:22:41,490
swagger is basically a documentation

00:22:37,800 --> 00:22:43,950
where you can basically have like a

00:22:41,490 --> 00:22:46,440
website which basically documents your

00:22:43,950 --> 00:22:49,530
whole your whole website and each each

00:22:46,440 --> 00:22:52,200
each and every euro is busy

00:22:49,530 --> 00:22:53,580
documented and that's not a temptation

00:22:52,200 --> 00:22:55,560
so imagine yeah

00:22:53,580 --> 00:22:57,480
for me I've actually worked with many

00:22:55,560 --> 00:22:58,860
projects with swagger and the modern

00:22:57,480 --> 00:23:01,440
world that's required you do your work

00:22:58,860 --> 00:23:02,670
you do your work and then afterwards you

00:23:01,440 --> 00:23:04,650
have to go and actually update this

00:23:02,670 --> 00:23:07,200
message to a go file and for me was a

00:23:04,650 --> 00:23:09,000
headache and many times it's out of sync

00:23:07,200 --> 00:23:11,130
and so forth but the cooking Warcraft

00:23:09,000 --> 00:23:13,920
card is by defining the schema that's

00:23:11,130 --> 00:23:16,290
basically a documentation by itself so

00:23:13,920 --> 00:23:19,230
it's sort of the document soft

00:23:16,290 --> 00:23:21,720
documentation and then one advantage is

00:23:19,230 --> 00:23:23,820
subscriptions so a nice little feature

00:23:21,720 --> 00:23:25,950
of Tokyo is that you can now view

00:23:23,820 --> 00:23:27,930
subscriptions are basically real time

00:23:25,950 --> 00:23:30,390
real time updates so you can even maybe

00:23:27,930 --> 00:23:33,030
have some sort of like a Chat Chat Chat

00:23:30,390 --> 00:23:34,500
app where basically by using graphic you

00:23:33,030 --> 00:23:36,330
owe subscriptions you can I wrote on a

00:23:34,500 --> 00:23:38,190
real-time communication between two

00:23:36,330 --> 00:23:40,320
different clients sorry may many

00:23:38,190 --> 00:23:42,000
advantages to it and obviously there are

00:23:40,320 --> 00:23:43,470
disadvantages like the time to learn I

00:23:42,000 --> 00:23:45,420
mean this is a different paradigm to

00:23:43,470 --> 00:23:47,160
your rest so you know time to learn it

00:23:45,420 --> 00:23:49,320
and the our performance issues when you

00:23:47,160 --> 00:23:51,420
have complex complex like multi nested

00:23:49,320 --> 00:23:52,920
queries and so forth I mean now the web

00:23:51,420 --> 00:23:57,960
that actually they've actually

00:23:52,920 --> 00:24:00,420
implemented stuff like I did a data

00:23:57,960 --> 00:24:02,820
loader because sometimes you can you can

00:24:00,420 --> 00:24:04,950
end up making multiple requests and so

00:24:02,820 --> 00:24:07,140
forth which yeah which basically makes

00:24:04,950 --> 00:24:08,970
it makes your powerful and like brings

00:24:07,140 --> 00:24:10,830
on your performance that's something for

00:24:08,970 --> 00:24:13,320
another talk and so forth basically the

00:24:10,830 --> 00:24:16,310
N one n plus one problem is one problem

00:24:13,320 --> 00:24:19,530
that can exist which has been solved by

00:24:16,310 --> 00:24:21,360
70 P and so forth so yet it can have

00:24:19,530 --> 00:24:23,220
like performance issues and so forth so

00:24:21,360 --> 00:24:25,140
it is something to consider but who's

00:24:23,220 --> 00:24:27,180
who's using it literally it's more or

00:24:25,140 --> 00:24:28,800
less who's not using it so yeah Facebook

00:24:27,180 --> 00:24:31,020
Instagram because

00:24:28,800 --> 00:24:32,790
Microsoft so yeah the many companies

00:24:31,020 --> 00:24:35,520
which are adopted this technology and

00:24:32,790 --> 00:24:37,770
the more people use it it's open source

00:24:35,520 --> 00:24:39,630
so many people use it I if you need help

00:24:37,770 --> 00:24:43,380
there's tons of resources that's the

00:24:39,630 --> 00:24:45,660
good thing the good thing about it so

00:24:43,380 --> 00:24:48,750
now into the why I think these are a

00:24:45,660 --> 00:24:49,740
good fit together so imagine with so

00:24:48,750 --> 00:24:51,750
with the rest

00:24:49,740 --> 00:24:54,840
there are many rels but then with

00:24:51,750 --> 00:24:57,300
servantis I would graph QL you only have

00:24:54,840 --> 00:24:59,490
one one request so you can imagine you

00:24:57,300 --> 00:25:01,020
have one request slash query and in

00:24:59,490 --> 00:25:03,840
there you have you define all your

00:25:01,020 --> 00:25:05,750
different queries and I mean one thing I

00:25:03,840 --> 00:25:09,030
didn't mention is oh there's also like

00:25:05,750 --> 00:25:12,320
mutations so I mean for this talk I

00:25:09,030 --> 00:25:14,820
thought maybe I won't dive into the deep

00:25:12,320 --> 00:25:16,230
deep concept of growth kill teach but

00:25:14,820 --> 00:25:17,580
about the hard they work together and so

00:25:16,230 --> 00:25:20,610
forth but yeah but then yeah

00:25:17,580 --> 00:25:23,610
basically one URL does everything for

00:25:20,610 --> 00:25:25,530
you so one URL covers your fetch you

00:25:23,610 --> 00:25:27,540
will post your creation and so forth so

00:25:25,530 --> 00:25:29,460
you better make sure that one that even

00:25:27,540 --> 00:25:32,790
one euro is always up she has to be

00:25:29,460 --> 00:25:34,590
scalable one and also it it can't fail

00:25:32,790 --> 00:25:36,450
so if it fellas internet a back-up plan

00:25:34,590 --> 00:25:38,160
and that's where so let's continue serve

00:25:36,450 --> 00:25:38,910
this one it gives you scalability

00:25:38,160 --> 00:25:41,910
out-of-the-box

00:25:38,910 --> 00:25:44,100
so whenever a request comes in it can

00:25:41,910 --> 00:25:46,860
just spring up and you know a lot run

00:25:44,100 --> 00:25:48,570
the function and also the good thing

00:25:46,860 --> 00:25:52,050
about it is it scalable so you know

00:25:48,570 --> 00:25:54,750
whether you have one user or yeah ten

00:25:52,050 --> 00:25:56,670
billion you know the amount of work

00:25:54,750 --> 00:26:00,960
that's required basically lambda

00:25:56,670 --> 00:26:05,820
basically scare was a accordingly and so

00:26:00,960 --> 00:26:08,400
forth so I think okay to it to get to my

00:26:05,820 --> 00:26:10,910
so now I'm public do you my next talk

00:26:08,400 --> 00:26:13,680
what we're gonna go into a little demo

00:26:10,910 --> 00:26:15,720
with the service so basically to work

00:26:13,680 --> 00:26:18,390
with service there many things you can

00:26:15,720 --> 00:26:21,450
you can use service some people

00:26:18,390 --> 00:26:25,860
basically for me my talk I'm gonna major

00:26:21,450 --> 00:26:27,350
on AWS we so what a double yes there's

00:26:25,860 --> 00:26:29,580
something cool you can you can basically

00:26:27,350 --> 00:26:31,100
make all yeah you will learn the

00:26:29,580 --> 00:26:32,490
functions and package them using

00:26:31,100 --> 00:26:34,650
CloudFormation

00:26:32,490 --> 00:26:36,540
so confirmation scripts are basically if

00:26:34,650 --> 00:26:39,030
you view styrofoam is exactly the same

00:26:36,540 --> 00:26:40,560
thing is basically this infrastructure

00:26:39,030 --> 00:26:42,660
as code where you can basically define

00:26:40,560 --> 00:26:45,090
all your resources like lambda function

00:26:42,660 --> 00:26:48,600
you can define an API gateway with an

00:26:45,090 --> 00:26:52,170
API gateways basically how you your

00:26:48,600 --> 00:26:54,720
router so to sort think basically is

00:26:52,170 --> 00:26:56,910
think of Express and go slash whatever

00:26:54,720 --> 00:26:59,280
that declaration basically at the role

00:26:56,910 --> 00:27:01,140
of a tie gateway so if I get ready takes

00:26:59,280 --> 00:27:02,850
your URL and basically revolves to

00:27:01,140 --> 00:27:05,700
whatever learn the function that you

00:27:02,850 --> 00:27:09,120
assigned to it but then nowadays do not

00:27:05,700 --> 00:27:11,180
write manually or do not buy do not go

00:27:09,120 --> 00:27:13,740
into the console and basically right

00:27:11,180 --> 00:27:15,180
under functions there's now many tools

00:27:13,740 --> 00:27:17,130
out there and my favorite which I'm

00:27:15,180 --> 00:27:19,830
gonna showcase here the 7s framework

00:27:17,130 --> 00:27:21,630
so this basically a way to actually a

00:27:19,830 --> 00:27:24,360
nice framework where you can actually

00:27:21,630 --> 00:27:28,140
write a proper API a fully-fledged

00:27:24,360 --> 00:27:29,580
api using just a Yama file and you may

00:27:28,140 --> 00:27:31,740
be your JavaScript code so basically

00:27:29,580 --> 00:27:33,360
this solution it's open source and it

00:27:31,740 --> 00:27:35,580
takes care everything so you can imagine

00:27:33,360 --> 00:27:36,810
after your budget on the function you

00:27:35,580 --> 00:27:40,380
can have many plugins which can take

00:27:36,810 --> 00:27:42,300
take your functions maybe even minify

00:27:40,380 --> 00:27:46,590
them how to minimize them you really

00:27:42,300 --> 00:27:48,510
like it can even define then then of the

00:27:46,590 --> 00:27:50,370
I'll go fire then zip it up and then

00:27:48,510 --> 00:27:51,930
upload into you into the pen into the

00:27:50,370 --> 00:27:53,460
cloud and even provision your API

00:27:51,930 --> 00:27:57,060
Gateway provision everything for you

00:27:53,460 --> 00:27:58,830
just by you're running yarn install so I

00:27:57,060 --> 00:28:05,880
think now it's best I would do a live

00:27:58,830 --> 00:28:07,860
demo of of the service framework so the

00:28:05,880 --> 00:28:11,730
first thing means to you is actually

00:28:07,860 --> 00:28:13,830
install NPM install service so I

00:28:11,730 --> 00:28:15,870
actually have it installed on my machine

00:28:13,830 --> 00:28:19,040
so I actually won't bother but all you

00:28:15,870 --> 00:28:19,040
have to know is that the server is

00:28:19,310 --> 00:28:28,650
basically on spell so this service

00:28:26,850 --> 00:28:30,900
basically gives you certain commands and

00:28:28,650 --> 00:28:35,570
these commands are basically what you

00:28:30,900 --> 00:28:35,570
use to actually zoom in yep

00:28:38,740 --> 00:28:51,790
yep yes oh yes so these commands yeah at

00:28:47,080 --> 00:28:53,620
the back yeah yeah thanks yeah so yeah

00:28:51,790 --> 00:28:55,630
so these are the commands that the

00:28:53,620 --> 00:28:57,700
surplus prema gives you at the box

00:28:55,630 --> 00:28:59,309
so obviously this configure scene to

00:28:57,700 --> 00:29:02,140
make sure that you actually have a valid

00:28:59,309 --> 00:29:06,040
AWS account and then he basically run

00:29:02,140 --> 00:29:08,950
AWS eight obvious configure so basically

00:29:06,040 --> 00:29:11,860
gold on it obvious

00:29:08,950 --> 00:29:13,780
install the the command-line client then

00:29:11,860 --> 00:29:16,510
one does configure and basically our

00:29:13,780 --> 00:29:19,240
basic configure basically integrate have

00:29:16,510 --> 00:29:22,990
a user which basically you collect the

00:29:19,240 --> 00:29:26,020
the the access access ID and the secret

00:29:22,990 --> 00:29:28,450
Access ID basically and basically that's

00:29:26,020 --> 00:29:31,480
what you use to put to configure so that

00:29:28,450 --> 00:29:33,490
this this this just basically use

00:29:31,480 --> 00:29:37,179
that information to upload to your

00:29:33,490 --> 00:29:41,980
specific hey doubles account so what so

00:29:37,179 --> 00:29:47,530
okay so with service let's say so it

00:29:41,980 --> 00:29:51,130
service if you wanna so with service if

00:29:47,530 --> 00:29:52,030
you wanna Institute install start a new

00:29:51,130 --> 00:29:54,070
service framework

00:29:52,030 --> 00:29:55,840
you basically say serve this install and

00:29:54,070 --> 00:29:57,100
okay so we serve it as you can have

00:29:55,840 --> 00:29:59,200
that's a good thing about it it's open

00:29:57,100 --> 00:30:01,120
source so you can have many templates

00:29:59,200 --> 00:30:02,620
it's obviously these templates are

00:30:01,120 --> 00:30:05,140
basically a little blueprint you can

00:30:02,620 --> 00:30:07,750
start your project with so you can

00:30:05,140 --> 00:30:10,240
imagine here I'm using this under me and

00:30:07,750 --> 00:30:13,870
none anomaly whatever this function food

00:30:10,240 --> 00:30:15,730
is the service service no J startup so

00:30:13,870 --> 00:30:18,670
it's good to mention that what several

00:30:15,730 --> 00:30:20,320
is you can use many languages so lambda

00:30:18,670 --> 00:30:22,780
you can use gold Lang is gaining

00:30:20,320 --> 00:30:25,690
popularity Python you can use net don't

00:30:22,780 --> 00:30:28,929
do it don't net is not yeah it's not the

00:30:25,690 --> 00:30:30,760
best for service and then so you can

00:30:28,929 --> 00:30:33,370
basically here I'm using the node G a

00:30:30,760 --> 00:30:37,330
starter pack and the name maybe I'll say

00:30:33,370 --> 00:30:40,500
it's Ovilus API and by doing that it'll

00:30:37,330 --> 00:30:40,500
basically create for me

00:30:43,000 --> 00:30:56,650
basically creep from me and not Cerberus

00:30:47,080 --> 00:30:58,539
project out the box so yep so basically

00:30:56,650 --> 00:31:00,309
what I have here it gives me tests of

00:30:58,539 --> 00:31:02,140
which today I won't cover test so I can

00:31:00,309 --> 00:31:03,610
delete that but the main thing you have

00:31:02,140 --> 00:31:06,460
to develop myself is favor because that

00:31:03,610 --> 00:31:08,110
everything this is where basically the

00:31:06,460 --> 00:31:10,090
magic happens it's basically this server

00:31:08,110 --> 00:31:11,500
is like ammo and the service that llamo

00:31:10,090 --> 00:31:14,289
is basically where they actually

00:31:11,500 --> 00:31:17,169
configure like what Lander function

00:31:14,289 --> 00:31:19,150
actually what lambda function is

00:31:17,169 --> 00:31:20,950
actually used for what route and so

00:31:19,150 --> 00:31:23,740
forth so maybe first of all you give her

00:31:20,950 --> 00:31:25,299
the service but service is kind of

00:31:23,740 --> 00:31:28,030
happens so you give the name of your app

00:31:25,299 --> 00:31:29,740
just serving this API for thumb pool you

00:31:28,030 --> 00:31:31,240
can have many options like package I

00:31:29,740 --> 00:31:32,650
mean dev with documentation on the

00:31:31,240 --> 00:31:34,330
website so if int repeated yourself so

00:31:32,650 --> 00:31:36,940
what it's a packaged individually this

00:31:34,330 --> 00:31:39,280
means that for each so basically imagine

00:31:36,940 --> 00:31:42,220
this this sort of framework this sudden

00:31:39,280 --> 00:31:44,260
like plugin i used basically it uses web

00:31:42,220 --> 00:31:45,610
pack so if you've used fondant web pack

00:31:44,260 --> 00:31:47,080
is basically a nice bundler which you

00:31:45,610 --> 00:31:49,120
can use to actually bundle your code and

00:31:47,080 --> 00:31:50,520
so forth so using webpack web pack will

00:31:49,120 --> 00:31:52,960
actually bundle each function

00:31:50,520 --> 00:31:55,360
individually and make it so that it uses

00:31:52,960 --> 00:31:57,370
the libraries that that that are

00:31:55,360 --> 00:31:58,960
actually required or imported within

00:31:57,370 --> 00:32:00,039
that lambda function and so forth so

00:31:58,960 --> 00:32:02,350
yeah you can many have many options

00:32:00,039 --> 00:32:04,030
plugins there are many plugins so I mean

00:32:02,350 --> 00:32:05,470
today I put my heart the surplus offline

00:32:04,030 --> 00:32:07,120
plugin and so forth but there many

00:32:05,470 --> 00:32:09,210
plugins you can use here the service

00:32:07,120 --> 00:32:11,740
bundles basically the what what's used

00:32:09,210 --> 00:32:14,770
is there is a web pack bundler basically

00:32:11,740 --> 00:32:17,650
and then providers basically the name so

00:32:14,770 --> 00:32:20,530
basically there's a there's a double yes

00:32:17,650 --> 00:32:22,030
maybe you can have as your Microsoft you

00:32:20,530 --> 00:32:24,760
can have Google and so forth so yeah and

00:32:22,030 --> 00:32:25,870
then one time is basically node.js 10 so

00:32:24,760 --> 00:32:28,510
basically can have different on time so

00:32:25,870 --> 00:32:31,090
maybe I think the the latest actually

00:32:28,510 --> 00:32:33,250
support is no 12 I think and stage

00:32:31,090 --> 00:32:37,030
region the region of where you want to

00:32:33,250 --> 00:32:38,880
approach your code on in name in lbs and

00:32:37,030 --> 00:32:41,260
so forth so yeah the mini the many

00:32:38,880 --> 00:32:43,539
providers you can options you can have

00:32:41,260 --> 00:32:45,100
for that but the main thing is functions

00:32:43,539 --> 00:32:46,539
so functions are basically are the

00:32:45,100 --> 00:32:48,730
function that you want to run for a

00:32:46,539 --> 00:32:50,440
specific route so imagine you you say

00:32:48,730 --> 00:32:52,360
functions and then you declare let's say

00:32:50,440 --> 00:32:54,669
this one's quit hello madanpal it's

00:32:52,360 --> 00:32:55,630
critical to know maybe a holographic you

00:32:54,669 --> 00:32:57,460
all

00:32:55,630 --> 00:32:59,110
the name of this thing doesn't matter

00:32:57,460 --> 00:33:01,420
that much and the handle is basically

00:32:59,110 --> 00:33:06,580
the handle is basically the path to your

00:33:01,420 --> 00:33:08,740
handler so in this case that is this so

00:33:06,580 --> 00:33:11,830
basically what what I'm saying is that

00:33:08,740 --> 00:33:13,530
the handler is basically $100 hello so

00:33:11,830 --> 00:33:17,140
basically in this in this Java to encode

00:33:13,530 --> 00:33:18,970
hello is basically my on lock for sample

00:33:17,140 --> 00:33:20,380
and then events events are basically

00:33:18,970 --> 00:33:22,750
like your your bottom

00:33:20,380 --> 00:33:25,390
so basically saying whenever an HTTP

00:33:22,750 --> 00:33:29,490
request comes in the path and the part

00:33:25,390 --> 00:33:34,180
is is slash hello and the method is get

00:33:29,490 --> 00:33:36,730
that matches you run this code 100 ago

00:33:34,180 --> 00:33:40,930
and that's as simple as simple simple as

00:33:36,730 --> 00:33:42,700
and so forth so for us this is nice and

00:33:40,930 --> 00:33:46,600
so far but we want to change this so

00:33:42,700 --> 00:33:48,190
that it uses this service and due to

00:33:46,600 --> 00:33:53,110
this there's one there's one lab we will

00:33:48,190 --> 00:33:55,120
need which is basically I don't know if

00:33:53,110 --> 00:33:57,610
anyone has used Apollo server but they

00:33:55,120 --> 00:34:00,100
also have a a different frame which is

00:33:57,610 --> 00:34:01,510
basically a polar serve lambda and

00:34:00,100 --> 00:34:03,250
basically Apollo server lambda is

00:34:01,510 --> 00:34:05,440
basically the offering for Lander

00:34:03,250 --> 00:34:08,590
functions so in a way when you have your

00:34:05,440 --> 00:34:10,330
handler you can take you this away so we

00:34:08,590 --> 00:34:14,530
can say Oh fine for part we want it to

00:34:10,330 --> 00:34:16,210
be query and then ok this I will skip

00:34:14,530 --> 00:34:25,200
this per time being but in the end we

00:34:16,210 --> 00:34:28,900
can say import a polar server from

00:34:25,200 --> 00:34:32,890
Apollo server Wow it downloads the

00:34:28,900 --> 00:34:37,440
entire internet no yeah you call me okay

00:34:32,890 --> 00:34:37,440
put a server lambda

00:34:51,140 --> 00:34:55,830
yep okay and then basically this we had

00:34:54,210 --> 00:34:58,110
to create our handler

00:34:55,830 --> 00:35:00,300
so basically well it would put a server

00:34:58,110 --> 00:35:04,050
is very simple you say a handler and you

00:35:00,300 --> 00:35:05,820
say equals new Apollo server and then

00:35:04,050 --> 00:35:07,830
they it can take so if you've used up on

00:35:05,820 --> 00:35:09,330
a server like without serving us exactly

00:35:07,830 --> 00:35:10,800
the same thing so obviously it expects

00:35:09,330 --> 00:35:12,990
type tests which are basically your

00:35:10,800 --> 00:35:16,500
schema type definitions so this is like

00:35:12,990 --> 00:35:18,960
I if you think of the query and so forth

00:35:16,500 --> 00:35:21,540
that's where you inter provided a a

00:35:18,960 --> 00:35:24,330
basically a file where all the tablets

00:35:21,540 --> 00:35:27,540
are Tversky it's X type deaths in the

00:35:24,330 --> 00:35:28,860
inspects resolvers so basically every

00:35:27,540 --> 00:35:31,230
single query that what I said scream

00:35:28,860 --> 00:35:33,180
query has to have a subsequent resolver

00:35:31,230 --> 00:35:36,000
which resolves that that query and

00:35:33,180 --> 00:35:38,520
returns data for it then a problem that

00:35:36,000 --> 00:35:42,450
can also have a context so context is

00:35:38,520 --> 00:35:43,980
that if you want to have so context is a

00:35:42,450 --> 00:35:46,710
function basically if you want to have

00:35:43,980 --> 00:35:49,140
data to be persisted I mean I'll show

00:35:46,710 --> 00:35:51,240
you the resolver code

00:35:49,140 --> 00:35:52,920
there's over code to fully explain this

00:35:51,240 --> 00:35:56,400
but if you want to have data to be

00:35:52,920 --> 00:35:57,870
persisted through different rows overs

00:35:56,400 --> 00:35:59,790
you can basically pass a context object

00:35:57,870 --> 00:36:01,920
and this is where for example if you

00:35:59,790 --> 00:36:03,720
have some sort of like a library to

00:36:01,920 --> 00:36:06,300
actually fetch data from a database you

00:36:03,720 --> 00:36:09,120
basically add that model whatever to the

00:36:06,300 --> 00:36:11,730
context so basically I think here for

00:36:09,120 --> 00:36:15,900
service you get the event so event is

00:36:11,730 --> 00:36:17,310
basically the and and the a SS event so

00:36:15,900 --> 00:36:19,920
when the request comes in you can get a

00:36:17,310 --> 00:36:21,600
vendor body but then for service lovely

00:36:19,920 --> 00:36:23,070
matter because we use something else for

00:36:21,600 --> 00:36:25,650
that you can have quantum okay memory

00:36:23,070 --> 00:36:28,370
but you can have many things there then

00:36:25,650 --> 00:36:28,370
all it is you can

00:36:32,900 --> 00:36:51,240
then basically this basically returns

00:36:34,980 --> 00:36:52,680
object so in this case so okay so in

00:36:51,240 --> 00:36:54,329
this case we have to create type tears

00:36:52,680 --> 00:36:56,040
and these type deaths are basically our

00:36:54,329 --> 00:36:58,380
declaration for our server so I mean

00:36:56,040 --> 00:37:00,869
before I actually prepared a small

00:36:58,380 --> 00:37:03,500
little tab death

00:37:00,869 --> 00:37:08,160
so maybe ecologist I don't know type def

00:37:03,500 --> 00:37:11,190
CAS then in there we basically have our

00:37:08,160 --> 00:37:13,770
schema declaration say okay this this

00:37:11,190 --> 00:37:15,060
was basically Elias to make it easier

00:37:13,770 --> 00:37:16,680
there's nothing to do a service

00:37:15,060 --> 00:37:18,210
it's basically an alliance that I made

00:37:16,680 --> 00:37:19,980
so that instead of tapping everything I

00:37:18,210 --> 00:37:25,530
just this copy is code for somewhere

00:37:19,980 --> 00:37:27,750
yeah but anyway basically this is

00:37:25,530 --> 00:37:29,880
basically mo so basically a producer of

00:37:27,750 --> 00:37:33,150
a lambda basically provides you this

00:37:29,880 --> 00:37:37,079
service gql which basically convert a

00:37:33,150 --> 00:37:38,819
basic converts SQL as this into a schema

00:37:37,079 --> 00:37:40,829
declaration basically so basically I

00:37:38,819 --> 00:37:45,630
mean the good thing about having webpack

00:37:40,829 --> 00:37:47,430
so he is it is a JS file but the good

00:37:45,630 --> 00:37:49,079
thing is observer this is that for

00:37:47,430 --> 00:37:51,150
sample you can have like a bundler

00:37:49,079 --> 00:37:53,579
number would webpack there's some even

00:37:51,150 --> 00:37:55,349
like other other libraries or plugins

00:37:53,579 --> 00:37:58,770
where you can actually have a physical

00:37:55,349 --> 00:37:59,880
web backdoor config in your file and in

00:37:58,770 --> 00:38:02,040
there you can do whatever you want you

00:37:59,880 --> 00:38:03,839
can install a tab screen Oda attached

00:38:02,040 --> 00:38:05,010
Ghidorah and basically and basically

00:38:03,839 --> 00:38:06,839
have touched good throughout your code

00:38:05,010 --> 00:38:08,700
you can just or maybe even there's a

00:38:06,839 --> 00:38:10,740
draft or loader where you can actually

00:38:08,700 --> 00:38:12,210
instead of having a judge JS file for

00:38:10,740 --> 00:38:14,760
you for your schema you can basically

00:38:12,210 --> 00:38:16,619
say type dev graph 0 and basically it

00:38:14,760 --> 00:38:18,450
can be a full-fledged off your you can

00:38:16,619 --> 00:38:21,800
basically import a full-fledged go off

00:38:18,450 --> 00:38:24,240
to oh wow and so forth so yeah the the

00:38:21,800 --> 00:38:28,470
landscape is this vast and so forth but

00:38:24,240 --> 00:38:30,089
in this case I just use this gql from

00:38:28,470 --> 00:38:33,270
uploads over lambda and basically I

00:38:30,089 --> 00:38:35,930
baked it just declared my tab desk and

00:38:33,270 --> 00:38:35,930
it's a matter of just

00:38:37,240 --> 00:38:48,830
importing them have this so now not I've

00:38:47,300 --> 00:38:52,520
got my type deaths which I've got here

00:38:48,830 --> 00:38:54,680
then now well what I need now is now my

00:38:52,520 --> 00:38:59,800
my resolvers so basically maybe here

00:38:54,680 --> 00:39:02,060
I'll create a resolvers file but yes

00:38:59,800 --> 00:39:05,540
then like I said so resolve was

00:39:02,060 --> 00:39:08,180
basically functions that map to your to

00:39:05,540 --> 00:39:10,850
to tab just so imagine here I've

00:39:08,180 --> 00:39:14,090
basically declared like a fine I have a

00:39:10,850 --> 00:39:15,950
query and that query uh you can

00:39:14,090 --> 00:39:18,260
basically ask for a worker so this is

00:39:15,950 --> 00:39:20,360
this is a different talk that I made for

00:39:18,260 --> 00:39:22,100
the front-end but yeah basically I can

00:39:20,360 --> 00:39:23,780
basically declare a worker and basically

00:39:22,100 --> 00:39:25,790
you can get back a worker and the work

00:39:23,780 --> 00:39:26,990
is basically object with the ID of the

00:39:25,790 --> 00:39:29,240
worker the first name the last and the

00:39:26,990 --> 00:39:31,400
email and so forth and that that's what

00:39:29,240 --> 00:39:32,330
it is so basically I can say worker

00:39:31,400 --> 00:39:34,610
workers and so forth

00:39:32,330 --> 00:39:36,860
and then basically my career Amira's

00:39:34,610 --> 00:39:40,010
overs have a query and basically I need

00:39:36,860 --> 00:39:42,470
to have a a resolver function which

00:39:40,010 --> 00:39:44,390
basically resolves to the last specific

00:39:42,470 --> 00:39:47,480
query today I have a worker and

00:39:44,390 --> 00:39:49,880
basically here oh this is every total

00:39:47,480 --> 00:39:52,550
function you get about four four

00:39:49,880 --> 00:39:56,990
parameters or arguments which is the

00:39:52,550 --> 00:39:58,610
route which is basically the data that

00:39:56,990 --> 00:40:00,770
the the the better that that's been

00:39:58,610 --> 00:40:03,170
collected already is basically okay so

00:40:00,770 --> 00:40:04,370
when the request comes in and it's

00:40:03,170 --> 00:40:06,560
basically hearing all the different

00:40:04,370 --> 00:40:08,150
solvers in the basic collect collate all

00:40:06,560 --> 00:40:09,710
the data and route is basically the

00:40:08,150 --> 00:40:11,030
collection of all this data then

00:40:09,710 --> 00:40:12,410
arguments are the arguments that they

00:40:11,030 --> 00:40:18,290
use again the user can actually give you

00:40:12,410 --> 00:40:21,320
some example ID ID can be part of odds

00:40:18,290 --> 00:40:24,140
so here I say August odd ID then the

00:40:21,320 --> 00:40:28,700
work is basically here when I declared

00:40:24,140 --> 00:40:35,140
my context right I can basically person

00:40:28,700 --> 00:40:37,640
like like I can pass a certain set of

00:40:35,140 --> 00:40:39,740
models and leave the basically maybe

00:40:37,640 --> 00:40:41,780
crosses to actually communicate with my

00:40:39,740 --> 00:40:44,440
back-end so for example if I create a

00:40:41,780 --> 00:40:44,440
model here

00:40:45,320 --> 00:40:51,040
and there may be so this is a very

00:40:48,200 --> 00:40:53,660
simple model where basically I used

00:40:51,040 --> 00:40:56,960
DynamoDB so basically I'm connected to

00:40:53,660 --> 00:40:59,750
you yeah okay so yeah so I'm basically

00:40:56,960 --> 00:41:02,600
connecting to two to dynamodb and

00:40:59,750 --> 00:41:09,620
basically I'm collecting data from from

00:41:02,600 --> 00:41:11,630
from from DynamoDB and so forth from

00:41:09,620 --> 00:41:23,360
them by TV and basically I can basically

00:41:11,630 --> 00:41:26,960
import I can import that and basically

00:41:23,360 --> 00:41:28,760
give it their worker and then basically

00:41:26,960 --> 00:41:30,740
when I put in the context is basically

00:41:28,760 --> 00:41:32,930
available and every single resolver so

00:41:30,740 --> 00:41:35,090
the third argument is visited contacts

00:41:32,930 --> 00:41:37,220
and as the result of object so basically

00:41:35,090 --> 00:41:38,330
I've worker dog fetch for sample and

00:41:37,220 --> 00:41:39,920
basically if I look at the models is

00:41:38,330 --> 00:41:42,830
basically fetch is basically a command

00:41:39,920 --> 00:41:45,800
we're just basically fetch data from the

00:41:42,830 --> 00:41:49,760
from the food that DynamoDB DynamoDB

00:41:45,800 --> 00:41:52,010
table and that's it and then I basically

00:41:49,760 --> 00:41:54,860
have many more here but yeah time

00:41:52,010 --> 00:41:57,500
actually go into it but yeah so so now

00:41:54,860 --> 00:42:01,780
that by doing that then output allowed

00:41:57,500 --> 00:42:09,430
to do it is say exports exports dot

00:42:01,780 --> 00:42:13,280
handler equals maybe cool this server

00:42:09,430 --> 00:42:17,690
because server don't create create

00:42:13,280 --> 00:42:19,370
handler and then that's it then here in

00:42:17,690 --> 00:42:21,950
your service llamo you take a fine

00:42:19,370 --> 00:42:26,330
whenever a function comes in go into a

00:42:21,950 --> 00:42:28,430
handler and then one handle at the

00:42:26,330 --> 00:42:30,500
handler yes bad naming but anyway they

00:42:28,430 --> 00:42:33,740
know so okay fine then I say that okay

00:42:30,500 --> 00:42:36,680
fine I can actually emit method because

00:42:33,740 --> 00:42:38,720
for some point if you use a pull of

00:42:36,680 --> 00:42:40,460
server you can have a playground which

00:42:38,720 --> 00:42:43,190
you can you can play with locally and so

00:42:40,460 --> 00:42:45,350
forth by saying true so basically a

00:42:43,190 --> 00:42:47,870
playground when you hit slash query

00:42:45,350 --> 00:42:49,850
slash get you can basically have this

00:42:47,870 --> 00:42:51,560
program playground where you can

00:42:49,850 --> 00:42:54,140
basically play with your with your with

00:42:51,560 --> 00:42:56,000
your server and in the meantime so for

00:42:54,140 --> 00:42:57,640
post it'll basically be achieving the

00:42:56,000 --> 00:43:00,489
data and for for for

00:42:57,640 --> 00:43:02,920
to basically host this server so when

00:43:00,489 --> 00:43:06,130
you had that saved literally Oh

00:43:02,920 --> 00:43:07,480
so using I said as I said the the

00:43:06,130 --> 00:43:09,039
marketplace is vast

00:43:07,480 --> 00:43:10,869
so there's the plugin i used a which is

00:43:09,039 --> 00:43:11,980
selfless offline and so the good thing

00:43:10,869 --> 00:43:13,749
about it's obvious offline you can

00:43:11,980 --> 00:43:16,210
actually a host without deploying you

00:43:13,749 --> 00:43:18,190
can ask your host self host you your

00:43:16,210 --> 00:43:21,190
selfless function or framework api

00:43:18,190 --> 00:43:26,759
locally so if I just run service or SLS

00:43:21,190 --> 00:43:26,759
for short offline start

00:43:39,970 --> 00:43:44,369
I do apologize

00:44:08,920 --> 00:44:19,910
okay sorry

00:44:16,760 --> 00:44:22,850
okay so permitted it needs argument so

00:44:19,910 --> 00:44:28,310
from method we say hey I'm saying that

00:44:22,850 --> 00:44:31,340
for method any any so so any HTTP on

00:44:28,310 --> 00:44:33,110
slash query just go to them what this

00:44:31,340 --> 00:44:34,880
post or get just go and run this

00:44:33,110 --> 00:44:36,980
function and and then this create random

00:44:34,880 --> 00:44:39,710
sort allowed so now if I go to local

00:44:36,980 --> 00:44:49,520
always mm nothing is there but if I say

00:44:39,710 --> 00:44:53,120
slash since that's query lab coding is

00:44:49,520 --> 00:44:56,210
actually it is actually actual beast so

00:44:53,120 --> 00:45:01,100
okay so my bad so you have to have here

00:44:56,210 --> 00:45:04,340
for the models I'm using the the AWS SDK

00:45:01,100 --> 00:45:07,190
so I actual question to know that so

00:45:04,340 --> 00:45:09,500
yeah so yeah basically once you have

00:45:07,190 --> 00:45:15,970
that SDK installed you can basically

00:45:09,500 --> 00:45:15,970
have your function running

00:45:22,060 --> 00:45:27,890
yep you basically have yep so now

00:45:25,430 --> 00:45:29,330
imagine with this locally we had your

00:45:27,890 --> 00:45:32,900
function running and let's say you here

00:45:29,330 --> 00:45:35,570
have a workers query if I call that they

00:45:32,900 --> 00:45:37,790
go so in the dynamo DB table it may

00:45:35,570 --> 00:45:39,860
let's actually have pre formatted data

00:45:37,790 --> 00:45:41,480
and basically you can get that data so

00:45:39,860 --> 00:45:42,140
imagine in the in just like five minutes

00:45:41,480 --> 00:45:46,010
10 minutes

00:45:42,140 --> 00:45:48,260
I basically fresh API so I mean one

00:45:46,010 --> 00:45:50,330
thing I was gonna I don't know much time

00:45:48,260 --> 00:45:52,460
we have one thing I was gonna mention is

00:45:50,330 --> 00:45:54,080
that if you wanna save money this will

00:45:52,460 --> 00:45:58,190
save you money but this is important

00:45:54,080 --> 00:46:01,100
important so a really good I discovered

00:45:58,190 --> 00:46:02,780
just I want to go okay so API gateway

00:46:01,100 --> 00:46:03,950
can get expensive so if I gave ways what

00:46:02,780 --> 00:46:05,300
they used to actually had the routing

00:46:03,950 --> 00:46:06,950
system and the value system actually

00:46:05,300 --> 00:46:08,750
goes to your different lambda functions

00:46:06,950 --> 00:46:10,430
it can get expensive so I mean there's

00:46:08,750 --> 00:46:12,650
there's one like Auto code that that

00:46:10,430 --> 00:46:14,870
this dude made where he actually

00:46:12,650 --> 00:46:17,000
compares API gateway and the application

00:46:14,870 --> 00:46:19,430
load balancer so a load balancer I mean

00:46:17,000 --> 00:46:21,800
if you use in the water surface you can

00:46:19,430 --> 00:46:23,150
use like a sample an internet server to

00:46:21,800 --> 00:46:25,280
actually have a proxy which basically

00:46:23,150 --> 00:46:27,470
routes to different different servers so

00:46:25,280 --> 00:46:29,180
you can take in distribute use your a

00:46:27,470 --> 00:46:30,650
load between different servers say

00:46:29,180 --> 00:46:32,300
they've had traffic that load is

00:46:30,650 --> 00:46:34,370
distributed between different servers

00:46:32,300 --> 00:46:35,570
and so forth so the application load

00:46:34,370 --> 00:46:37,610
balancer place the same thing but then

00:46:35,570 --> 00:46:39,290
it's a it's a it's a ADA place offering

00:46:37,610 --> 00:46:41,870
so here you actually compares the the

00:46:39,290 --> 00:46:44,420
prices so when you have many requests

00:46:41,870 --> 00:46:46,520
per second the money that the amount of

00:46:44,420 --> 00:46:47,750
money you pay for a pack gateway so for

00:46:46,520 --> 00:46:51,440
the route actually hitting API gateway

00:46:47,750 --> 00:46:54,080
it's like it's way more compared to just

00:46:51,440 --> 00:46:55,850
so your course won't be won't be to

00:46:54,080 --> 00:46:58,310
actually binding demo DB overlander

00:46:55,850 --> 00:46:59,390
functions the mostly the API gateway and

00:46:58,310 --> 00:47:03,140
he was saying that if you switch

00:46:59,390 --> 00:47:05,450
checkout API gateway and some student

00:47:03,140 --> 00:47:09,350
with a load balancer you can save about

00:47:05,450 --> 00:47:13,610
say 5% varies but then you can say a lot

00:47:09,350 --> 00:47:14,630
more so and the good thing is now AWS

00:47:13,610 --> 00:47:17,570
introduced a future where you can

00:47:14,630 --> 00:47:18,020
actually you can actually reroute a load

00:47:17,570 --> 00:47:19,700
balancer

00:47:18,020 --> 00:47:21,710
you can you can actually be about routes

00:47:19,700 --> 00:47:23,900
from a load balancer and it can be about

00:47:21,710 --> 00:47:25,790
them to learn the functions and so forth

00:47:23,900 --> 00:47:27,350
so therefore it's something that's to

00:47:25,790 --> 00:47:30,710
consider that if you think if you have a

00:47:27,350 --> 00:47:32,450
high voltage of request throw a best

00:47:30,710 --> 00:47:34,099
track to do that and then one thing and

00:47:32,450 --> 00:47:38,210
then this is

00:47:34,099 --> 00:47:39,799
we've used cloud formation so in your

00:47:38,210 --> 00:47:42,200
service function you can have a

00:47:39,799 --> 00:47:43,549
resources and resources is basically a

00:47:42,200 --> 00:47:45,380
cloud formation scripts of how to

00:47:43,549 --> 00:47:47,539
configure so you can configure anything

00:47:45,380 --> 00:47:49,339
servers land the functions and load

00:47:47,539 --> 00:47:51,430
balancer so if you want this is

00:47:49,339 --> 00:47:53,989
basically the script actually I have a

00:47:51,430 --> 00:47:55,430
load balancer and basically in to

00:47:53,989 --> 00:47:57,979
interpret a load balancer basically if

00:47:55,430 --> 00:47:59,839
you never use transformation scripts you

00:47:57,979 --> 00:48:02,089
think of this way you basically here the

00:47:59,839 --> 00:48:04,160
top half a basic created load balancer

00:48:02,089 --> 00:48:09,170
and basically I create and listener and

00:48:04,160 --> 00:48:10,309
listen is basically a fine this listener

00:48:09,170 --> 00:48:12,529
is basically a confined whenever

00:48:10,309 --> 00:48:13,130
whenever I get a request basically we

00:48:12,529 --> 00:48:14,720
monitor here

00:48:13,130 --> 00:48:16,009
and then basically I'm saying I can find

00:48:14,720 --> 00:48:18,619
whenever I get a request to listener

00:48:16,009 --> 00:48:20,839
reverted to this specific target group

00:48:18,619 --> 00:48:23,210
and that target group down near is

00:48:20,839 --> 00:48:25,789
basically it's basically a target group

00:48:23,210 --> 00:48:27,440
which basically is points to lambda

00:48:25,789 --> 00:48:29,359
functions saying that the target type is

00:48:27,440 --> 00:48:31,460
it'll run the functions and in then

00:48:29,359 --> 00:48:33,229
example in your functions U sub should

00:48:31,460 --> 00:48:36,829
go after all and for events instead of

00:48:33,229 --> 00:48:40,160
HTTP use a or b and the a will be all it

00:48:36,829 --> 00:48:43,969
requires is a listener Erin so the

00:48:40,160 --> 00:48:46,789
familiar with AWS Ariens the basically

00:48:43,969 --> 00:48:48,410
the unique unique unique identifier for

00:48:46,789 --> 00:48:50,690
each resource it doesn't give that the

00:48:48,410 --> 00:48:52,099
listener rin and basically the priority

00:48:50,690 --> 00:48:56,210
the conditions in the path and basically

00:48:52,099 --> 00:48:58,249
you basically say this off 3000 which I

00:48:56,210 --> 00:49:00,619
would want a portion of because I just

00:48:58,249 --> 00:49:04,749
told you this photo hack so yeah so

00:49:00,619 --> 00:49:04,749

YouTube URL: https://www.youtube.com/watch?v=r9RyedEUkuY


