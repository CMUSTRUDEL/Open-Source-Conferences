Title: QEWD-JSdb: It's a Database, Jim, but not as we know it! - London Node User Group - January 2020
Publication date: 2020-02-17
Playlist: London Node User Group
Description: 
	QEWD-JSdb: It's a Database, Jim, but not as we know it!
robtweed

QEWD-JSdb is a new concept for databases in Node.js. Although it's implemented on top of two incredibly fast, industrial-strength (though little-known) physical database technologies (the Open Source YottaDB and the proprietary IRIS databases), QEWD-JSdb abstracts their underlying hierarchical physical storage as on-disk JavaScript objects, blurring the boundary between what's in-memory and what's on-disk.

Rob Tweed (@rtweed) is a Director of M/Gateway Developments Ltd, and has been part of the LNUG scene since its earliest days - he was one of the speakers at its inaugural meeting, and has given a number of talks over the years, mainly focused on his Node.js-based QEWD technology/platform.

Rob has several decades of experience, developing and advising on real-world complex, business-critical applications around the world, in sectors such as healthcare IT, financial services and retail systems. He's specialised in database integration for Web and Internet technologies since the early days in the mid-90s, and has been immersed in Node.js since its earliest days in 2011!

A keen proponent of Open Source software, you can find all his work (including QEWD-JSdb) at @robtweed

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,460
so this talk is about something I've

00:00:02,550 --> 00:00:07,290
called QJ s DB and basically what I'm

00:00:05,460 --> 00:00:09,510
gonna try and get across is what is it

00:00:07,290 --> 00:00:13,070
and why should you be interested in it

00:00:09,510 --> 00:00:16,070
and this is this is a shout out to

00:00:13,070 --> 00:00:18,840
someone who many of you know Simon leg

00:00:16,070 --> 00:00:20,279
who in November put out a couple of

00:00:18,840 --> 00:00:23,220
tweets which kind of grabbed my

00:00:20,279 --> 00:00:25,949
attention and and for one reason or

00:00:23,220 --> 00:00:29,250
another they they just provided a focus

00:00:25,949 --> 00:00:32,340
to this work that I've actually been

00:00:29,250 --> 00:00:34,320
involved in for like 10 years now and

00:00:32,340 --> 00:00:36,930
I've been kind of struggling with with

00:00:34,320 --> 00:00:37,770
with how to get the message across about

00:00:36,930 --> 00:00:39,719
what it is

00:00:37,770 --> 00:00:43,350
and it was just in these two two tweets

00:00:39,719 --> 00:00:46,020
that it sparked I think and this this

00:00:43,350 --> 00:00:50,460
talk is the result of their Simon's so

00:00:46,020 --> 00:00:53,940
I'm eternally grateful to him so I want

00:00:50,460 --> 00:00:55,379
to talk about databases in my view my

00:00:53,940 --> 00:00:58,530
experience they're pretty much an

00:00:55,379 --> 00:01:01,350
unavoidable part of a back-end of an

00:00:58,530 --> 00:01:04,140
application and I just wanted to get a

00:01:01,350 --> 00:01:05,939
quick show of hands here about how many

00:01:04,140 --> 00:01:07,979
of you use databases for example how

00:01:05,939 --> 00:01:10,100
many of you have to access a relational

00:01:07,979 --> 00:01:12,990
database like Oracle or sequel server

00:01:10,100 --> 00:01:15,710
quite a few post careers and so on

00:01:12,990 --> 00:01:18,390
how about document databases like

00:01:15,710 --> 00:01:21,689
Couchbase me a lot yeah yeah

00:01:18,390 --> 00:01:24,780
key value stores like Redis yeah again

00:01:21,689 --> 00:01:28,049
quite a lot graph databases anyone use a

00:01:24,780 --> 00:01:30,119
graph database yeah a few and finally

00:01:28,049 --> 00:01:33,229
how many of you use multiple databases

00:01:30,119 --> 00:01:35,790
you have two yeah yeah interesting

00:01:33,229 --> 00:01:39,360
thinking about databases is the so down

00:01:35,790 --> 00:01:41,310
many of them you know every week we seem

00:01:39,360 --> 00:01:43,409
to see a new one I've seen a new one

00:01:41,310 --> 00:01:47,220
lately called fauna DB being tweeted

00:01:43,409 --> 00:01:49,439
about you know there's there's loads of

00:01:47,220 --> 00:01:51,060
choice with databases as we've seen

00:01:49,439 --> 00:01:53,220
there's loads of different models of

00:01:51,060 --> 00:01:55,200
database and even within those models

00:01:53,220 --> 00:01:58,200
there's a lot of choice you know do you

00:01:55,200 --> 00:02:00,540
go for Couchbase or or whatever

00:01:58,200 --> 00:02:03,750
you know relational as hundreds of them

00:02:00,540 --> 00:02:05,070
and that in the way you end up dealing

00:02:03,750 --> 00:02:07,380
with them in nodejs

00:02:05,070 --> 00:02:08,910
is typically over over a network

00:02:07,380 --> 00:02:11,500
connection so you've got the nodejs

00:02:08,910 --> 00:02:14,140
environment

00:02:11,500 --> 00:02:15,490
/ and you've then got your database over

00:02:14,140 --> 00:02:18,340
here at the other end of the network

00:02:15,490 --> 00:02:21,010
connection and if you're really lucky

00:02:18,340 --> 00:02:23,380
you've got multiple ones and so you've

00:02:21,010 --> 00:02:26,230
got multiple guys to to deal with across

00:02:23,380 --> 00:02:29,170
your network so let's dig it a little

00:02:26,230 --> 00:02:32,320
deeper into these database technologies

00:02:29,170 --> 00:02:34,209
and see what they're all about you know

00:02:32,320 --> 00:02:36,130
most of this is probably second nature

00:02:34,209 --> 00:02:38,170
to you but I think I just want to build

00:02:36,130 --> 00:02:41,560
up a picture here I think it's it kind

00:02:38,170 --> 00:02:43,720
of creates an interesting message so the

00:02:41,560 --> 00:02:45,100
main thing about why why do you use a

00:02:43,720 --> 00:02:48,459
database in the first place it's all

00:02:45,100 --> 00:02:50,440
about persistence right your data stays

00:02:48,459 --> 00:02:52,239
there it doesn't you don't lose it when

00:02:50,440 --> 00:02:55,150
you switch off the system or when your

00:02:52,239 --> 00:02:57,459
code goes out of scope or whatever it

00:02:55,150 --> 00:02:59,280
you you bring back the system and there

00:02:57,459 --> 00:03:01,780
there's your data that's still there

00:02:59,280 --> 00:03:04,840
well couldn't you just use a file for

00:03:01,780 --> 00:03:07,060
that well arguably you could but one of

00:03:04,840 --> 00:03:09,010
the features of a database is that you

00:03:07,060 --> 00:03:13,900
want to be able to query it or search it

00:03:09,010 --> 00:03:16,269
right and typically what you're trying

00:03:13,900 --> 00:03:18,489
to do is specifying a way of extracting

00:03:16,269 --> 00:03:20,230
a subset of the data it's often known as

00:03:18,489 --> 00:03:22,420
a result set you know get me the

00:03:20,230 --> 00:03:26,140
addresses of all those subscribers in a

00:03:22,420 --> 00:03:27,940
particular area if you're in medical

00:03:26,140 --> 00:03:29,950
work you know get me the names of all

00:03:27,940 --> 00:03:32,890
the patients under 20 with us well yeah

00:03:29,950 --> 00:03:34,930
that kind of thing and you usually

00:03:32,890 --> 00:03:36,220
express these queries either through a

00:03:34,930 --> 00:03:38,739
query language if you're using

00:03:36,220 --> 00:03:40,540
relational you'll probably be using SQL

00:03:38,739 --> 00:03:43,660
for that but some of the other databases

00:03:40,540 --> 00:03:46,079
you may use at api's instead provide you

00:03:43,660 --> 00:03:49,329
the basis to navigate through the

00:03:46,079 --> 00:03:50,680
database to access what what you need

00:03:49,329 --> 00:03:53,829
and then you kind of marshal all the

00:03:50,680 --> 00:03:55,660
data and assemble it to meet the query

00:03:53,829 --> 00:03:58,239
that you're you're actually expressing

00:03:55,660 --> 00:03:59,860
third feature of a database is the model

00:03:58,239 --> 00:04:01,600
and we've already seen there's a whole

00:03:59,860 --> 00:04:04,870
bunch of different models you know

00:04:01,600 --> 00:04:07,570
relational and so on and that's all

00:04:04,870 --> 00:04:12,459
about how the data items are organized

00:04:07,570 --> 00:04:14,530
within that technology so relational is

00:04:12,459 --> 00:04:17,709
one of the most common of course and in

00:04:14,530 --> 00:04:20,530
relational data is expressed as one or

00:04:17,709 --> 00:04:24,070
more two-dimensional tables with links

00:04:20,530 --> 00:04:25,090
between them and typically the SQL query

00:04:24,070 --> 00:04:26,980
language to

00:04:25,090 --> 00:04:30,340
provide you with the basis to search

00:04:26,980 --> 00:04:33,280
across those tables and then we've got

00:04:30,340 --> 00:04:35,740
these interesting databases known

00:04:33,280 --> 00:04:38,230
generically as the no SQL databases and

00:04:35,740 --> 00:04:40,810
we mentioned a few of them in the show

00:04:38,230 --> 00:04:42,940
of hands your key value document

00:04:40,810 --> 00:04:45,040
columnar graph you've you've even got

00:04:42,940 --> 00:04:48,930
something called a native XML database

00:04:45,040 --> 00:04:51,370
they're fairly obscure these days but

00:04:48,930 --> 00:04:55,540
MarkLogic is is probably the best

00:04:51,370 --> 00:04:58,330
example of that and as part of the model

00:04:55,540 --> 00:05:00,340
you typically have within the database a

00:04:58,330 --> 00:05:02,770
schema you have to define a schema and

00:05:00,340 --> 00:05:04,540
that will either be explicit you'll have

00:05:02,770 --> 00:05:06,850
to define it explicitly typically in a

00:05:04,540 --> 00:05:09,040
relational database you'll have to do

00:05:06,850 --> 00:05:11,260
that well in some of the new SQL ones

00:05:09,040 --> 00:05:12,729
it's kind of implicit in just the way

00:05:11,260 --> 00:05:14,710
the data is organized anywhere you've

00:05:12,729 --> 00:05:18,430
got kind of no you know key value store

00:05:14,710 --> 00:05:21,010
is key value that's it so let's go back

00:05:18,430 --> 00:05:22,510
to that thing about a file could you use

00:05:21,010 --> 00:05:24,639
a file for the kind of this kind of

00:05:22,510 --> 00:05:26,740
stuff well the the main problem with a

00:05:24,639 --> 00:05:29,110
file of course is yes you could if you

00:05:26,740 --> 00:05:31,140
only had a few data records probably be

00:05:29,110 --> 00:05:34,000
pretty fast you know but if you've got

00:05:31,140 --> 00:05:36,870
gigabytes of data or terabytes or beyond

00:05:34,000 --> 00:05:38,740
that and clearly a file just becomes

00:05:36,870 --> 00:05:40,630
nonsensical you would have to load all

00:05:38,740 --> 00:05:42,610
that data into memory you'd probably run

00:05:40,630 --> 00:05:47,140
out of memory in the first place but you

00:05:42,610 --> 00:05:50,110
know you just wouldn't work so and even

00:05:47,140 --> 00:05:53,260
within the databases you need a way to

00:05:50,110 --> 00:05:55,210
avoid just exhaustively plowing your way

00:05:53,260 --> 00:05:59,889
through you know a terabyte of data to

00:05:55,210 --> 00:06:01,270
find us the result set that you want and

00:05:59,889 --> 00:06:04,090
that then brings in the fourth feature

00:06:01,270 --> 00:06:06,820
of in databases which is indexing and

00:06:04,090 --> 00:06:09,700
all databases will have some form of

00:06:06,820 --> 00:06:11,320
indexing within them and they they're

00:06:09,700 --> 00:06:13,870
there to provide you with an optimized

00:06:11,320 --> 00:06:17,729
way to get the subset that you want

00:06:13,870 --> 00:06:21,789
without traipsing through the entire

00:06:17,729 --> 00:06:23,830
database so why is there all this choice

00:06:21,789 --> 00:06:25,419
of databases you know surely the

00:06:23,830 --> 00:06:28,600
industry could have come up with a you

00:06:25,419 --> 00:06:32,139
know one-size-fits-all way of expressing

00:06:28,600 --> 00:06:36,070
data well to look at that we've got to

00:06:32,139 --> 00:06:38,400
go back in time really databases have

00:06:36,070 --> 00:06:40,440
been around for a long long time so

00:06:38,400 --> 00:06:42,990
you may be surprised to learn that they

00:06:40,440 --> 00:06:48,120
were around even before I started to

00:06:42,990 --> 00:06:50,930
become a developer you know so pre-1970

00:06:48,120 --> 00:06:53,580
really there were two types of database

00:06:50,930 --> 00:06:55,710
though the hierarchical ones IBM had a

00:06:53,580 --> 00:06:57,990
thing called IMS and then there were

00:06:55,710 --> 00:06:59,460
generically things called navigational

00:06:57,990 --> 00:07:00,720
databases I won't go into what they're

00:06:59,460 --> 00:07:04,320
about if you're interested have a look

00:07:00,720 --> 00:07:06,780
on Wikipedia General Electric had a

00:07:04,320 --> 00:07:10,289
database called IDs and ID IBM had one

00:07:06,780 --> 00:07:12,240
called IDMS and the IDs one became the

00:07:10,289 --> 00:07:14,310
basis of something called codasyl which

00:07:12,240 --> 00:07:19,770
was an attempt in those days to provide

00:07:14,310 --> 00:07:21,449
a standard for databases and then along

00:07:19,770 --> 00:07:24,690
came a guy called Edgar Codd who worked

00:07:21,449 --> 00:07:28,910
at IBM and in 1970 he published this

00:07:24,690 --> 00:07:31,050
paper which was really a landmark paper

00:07:28,910 --> 00:07:33,599
should probably all go off and read it

00:07:31,050 --> 00:07:35,699
actually and and it set the scene for

00:07:33,599 --> 00:07:38,960
the relational database model where he

00:07:35,699 --> 00:07:41,580
said that you know this was a

00:07:38,960 --> 00:07:43,800
one-size-fits-all solution you can

00:07:41,580 --> 00:07:46,229
express all your data as sets of

00:07:43,800 --> 00:07:49,229
two-dimensional tables and then it was

00:07:46,229 --> 00:07:51,300
all about the calculus and algebra that

00:07:49,229 --> 00:07:53,070
would allow you to get the intersections

00:07:51,300 --> 00:07:55,190
of these or the unions and although this

00:07:53,070 --> 00:07:58,560
guy very very much based on set theory

00:07:55,190 --> 00:08:01,349
he actually produced a query language

00:07:58,560 --> 00:08:03,180
but it wasn't adopted by IBM funnily

00:08:01,349 --> 00:08:06,930
enough they came up with something they

00:08:03,180 --> 00:08:11,580
called sequel fully spelt out and it was

00:08:06,930 --> 00:08:14,280
rebranded as SQL or sequel and Larry

00:08:11,580 --> 00:08:16,919
Ellison from Oracle in 1979 decided to

00:08:14,280 --> 00:08:20,659
copy that and then the rest really is

00:08:16,919 --> 00:08:23,729
history because from the 1970s to 2009

00:08:20,659 --> 00:08:27,800
relational just became the dominant

00:08:23,729 --> 00:08:31,800
database I mean there were plenty of

00:08:27,800 --> 00:08:33,990
products out there but you know ingress

00:08:31,800 --> 00:08:36,029
was one of the first IBM had db2

00:08:33,990 --> 00:08:37,320
Microsoft sequel server you know some of

00:08:36,029 --> 00:08:41,490
these are still around some have gone

00:08:37,320 --> 00:08:45,600
and but really the the the position was

00:08:41,490 --> 00:08:47,130
in in that period of time if you weren't

00:08:45,600 --> 00:08:49,589
using a relational database you weren't

00:08:47,130 --> 00:08:51,720
using a database period you know that

00:08:49,589 --> 00:08:55,069
was it and then some something

00:08:51,720 --> 00:08:58,949
very interesting happened in 2009 and

00:08:55,069 --> 00:09:00,660
that was this thing called no SQL when

00:08:58,949 --> 00:09:04,290
it burst onto the scene why did it do

00:09:00,660 --> 00:09:06,930
that it was all to do with what was

00:09:04,290 --> 00:09:11,699
known then as internet scale or web

00:09:06,930 --> 00:09:13,949
scale and this emerging view that these

00:09:11,699 --> 00:09:16,110
relational databases really just weren't

00:09:13,949 --> 00:09:20,579
suitable they couldn't hack it for that

00:09:16,110 --> 00:09:23,670
scale of database and activity for

00:09:20,579 --> 00:09:25,920
example you needed something that could

00:09:23,670 --> 00:09:28,410
be fast moving and changing all the time

00:09:25,920 --> 00:09:29,519
and once you're locked into a schema it

00:09:28,410 --> 00:09:30,870
becomes very difficult with the

00:09:29,519 --> 00:09:34,170
relational database particularly if

00:09:30,870 --> 00:09:36,779
you've got a lot of data you know mapped

00:09:34,170 --> 00:09:39,000
to that schema to adapt that schema and

00:09:36,779 --> 00:09:41,490
change it becomes a real big problem and

00:09:39,000 --> 00:09:44,939
also the performance of SQL people were

00:09:41,490 --> 00:09:47,040
finding at this internet scale you know

00:09:44,939 --> 00:09:49,709
the massive databases massive number of

00:09:47,040 --> 00:09:52,290
users the performance just wasn't up to

00:09:49,709 --> 00:09:56,160
to the kind of level that people were

00:09:52,290 --> 00:09:58,500
needing and so as a result we saw the

00:09:56,160 --> 00:10:01,410
emergence of much simpler models and

00:09:58,500 --> 00:10:03,540
schema free models emerging that could

00:10:01,410 --> 00:10:08,129
adapt very quickly to changing

00:10:03,540 --> 00:10:10,079
circumstances and so on and also faster

00:10:08,129 --> 00:10:12,600
alternative to SQL so we saw things like

00:10:10,079 --> 00:10:15,809
MapReduce appearing which really hadn't

00:10:12,600 --> 00:10:18,959
been around or it certainly hadn't been

00:10:15,809 --> 00:10:20,339
used very much until then now the

00:10:18,959 --> 00:10:22,920
interesting thing about this was

00:10:20,339 --> 00:10:25,319
although the arguments about it were

00:10:22,920 --> 00:10:28,079
related to internet scale where you've

00:10:25,319 --> 00:10:31,709
got you know exabytes of data or you

00:10:28,079 --> 00:10:34,470
know ludicrous scale these know SQL

00:10:31,709 --> 00:10:36,209
databases started getting adopted for

00:10:34,470 --> 00:10:38,160
normal scale where you've got you know

00:10:36,209 --> 00:10:40,139
megabytes of data or whatever you know I

00:10:38,160 --> 00:10:42,629
would imagine a lot of you who are using

00:10:40,139 --> 00:10:44,610
these notes of SQL databases some of you

00:10:42,629 --> 00:10:46,559
might be on internet scale but I would

00:10:44,610 --> 00:10:49,620
guess that some of you are fairly what

00:10:46,559 --> 00:10:52,110
I'd call normal scale and it was

00:10:49,620 --> 00:10:56,759
interesting the way that no SQL managed

00:10:52,110 --> 00:11:00,149
to break that monopoly of the relational

00:10:56,759 --> 00:11:02,009
world and so here we are today with all

00:11:00,149 --> 00:11:05,459
this choice of all these different kinds

00:11:02,009 --> 00:11:07,350
of databases now clearly how they all

00:11:05,459 --> 00:11:09,839
work will be different even if you take

00:11:07,350 --> 00:11:12,149
a relational model how all the different

00:11:09,839 --> 00:11:14,100
relational databases work internally is

00:11:12,149 --> 00:11:15,959
going to be very different and you know

00:11:14,100 --> 00:11:20,100
proprietary ones they'll keep that very

00:11:15,959 --> 00:11:23,879
secret how they they actually work but

00:11:20,100 --> 00:11:26,550
one of the interesting things is across

00:11:23,879 --> 00:11:28,679
the board pretty much all are modelled

00:11:26,550 --> 00:11:31,769
ultimately on a hierarchical structure

00:11:28,679 --> 00:11:34,379
that underpins them and a lot of them

00:11:31,769 --> 00:11:36,749
use something known as a b-tree which

00:11:34,379 --> 00:11:39,689
allows you to construct hierarchical

00:11:36,749 --> 00:11:41,699
structures on top and here's one of the

00:11:39,689 --> 00:11:45,660
interesting things about databases is

00:11:41,699 --> 00:11:49,220
that you can model any type of database

00:11:45,660 --> 00:11:52,110
on top of a hierarchical data structure

00:11:49,220 --> 00:11:54,990
okay now the reverse isn't true once

00:11:52,110 --> 00:11:57,480
you've gone to some other model by

00:11:54,990 --> 00:12:00,259
abstracting from that hierarchical

00:11:57,480 --> 00:12:02,910
structure you can't necessarily then

00:12:00,259 --> 00:12:06,629
model other databases on the top of that

00:12:02,910 --> 00:12:10,230
so if you like the hierarchical model is

00:12:06,629 --> 00:12:12,569
the kind of rosetta stone database the

00:12:10,230 --> 00:12:16,980
proto database that you want to build

00:12:12,569 --> 00:12:19,290
any other database models on top of now

00:12:16,980 --> 00:12:21,749
if you've decided to go for a particular

00:12:19,290 --> 00:12:24,389
database model like a like a key value

00:12:21,749 --> 00:12:27,509
store or a document database or a

00:12:24,389 --> 00:12:29,579
columnar one or whatever then it's fine

00:12:27,509 --> 00:12:33,629
so long as all your data requirements

00:12:29,579 --> 00:12:36,420
fit that model it's great perfect if

00:12:33,629 --> 00:12:39,740
everything you need to do fits with the

00:12:36,420 --> 00:12:43,619
relational world then that's great but

00:12:39,740 --> 00:12:45,389
you end up often having to use these

00:12:43,619 --> 00:12:48,480
things inappropriately because your data

00:12:45,389 --> 00:12:50,279
doesn't quite fit you know so here's

00:12:48,480 --> 00:12:53,220
Perl Scotties having to do a job with

00:12:50,279 --> 00:12:55,889
with what he's got or you end up

00:12:53,220 --> 00:12:58,170
fighting it you expend more energy

00:12:55,889 --> 00:13:00,240
trying to fight your database model to

00:12:58,170 --> 00:13:04,889
make it work with the data that you're

00:13:00,240 --> 00:13:08,009
dealing with then you know so it just

00:13:04,889 --> 00:13:14,339
ruins your productivity and as we saw in

00:13:08,009 --> 00:13:16,470
the hands before what you otherwise end

00:13:14,339 --> 00:13:18,490
up with is having to go from multiple

00:13:16,470 --> 00:13:21,940
databases

00:13:18,490 --> 00:13:24,339
so so now you've got to deal with the

00:13:21,940 --> 00:13:26,260
you know the learning curve and the

00:13:24,339 --> 00:13:28,779
support and the maintenance and

00:13:26,260 --> 00:13:32,279
management of several different database

00:13:28,779 --> 00:13:37,180
technologies just to meet your needs and

00:13:32,279 --> 00:13:39,790
really that's not ideal and there has to

00:13:37,180 --> 00:13:43,170
be a better way in my opinion than

00:13:39,790 --> 00:13:46,089
having to deal with this kind of thing

00:13:43,170 --> 00:13:48,610
so let's now forget about databases for

00:13:46,089 --> 00:13:51,160
a while and look at how you as nodejs

00:13:48,610 --> 00:13:53,050
developers JavaScript developers handle

00:13:51,160 --> 00:13:57,040
data you're in handling data all the

00:13:53,050 --> 00:13:59,350
time you know it as JavaScript objects

00:13:57,040 --> 00:14:00,550
or JSON I'm gonna use those too I know

00:13:59,350 --> 00:14:02,080
there's a difference between them but

00:14:00,550 --> 00:14:04,180
I'm going to use the two terms JSON

00:14:02,080 --> 00:14:08,529
JavaScript objects kind of synonymously

00:14:04,180 --> 00:14:12,910
in this talk you probably spend some

00:14:08,529 --> 00:14:15,399
time modeling data in other words you

00:14:12,910 --> 00:14:18,399
know your I would imagine quite happy

00:14:15,399 --> 00:14:23,860
designing objects JSON structures that

00:14:18,399 --> 00:14:27,279
fit your needs you probably even create

00:14:23,860 --> 00:14:29,589
indexes for those objects like using

00:14:27,279 --> 00:14:32,350
objects as hashes to provide pointers so

00:14:29,589 --> 00:14:36,310
that you can go directly to parts of

00:14:32,350 --> 00:14:37,750
your main data objects so you're

00:14:36,310 --> 00:14:42,370
actually doing everything a database

00:14:37,750 --> 00:14:45,060
does apart from two things your objects

00:14:42,370 --> 00:14:47,230
from Jason aren't persistent clearly

00:14:45,060 --> 00:14:49,329
they're destroyed if you go out of scope

00:14:47,230 --> 00:14:52,390
or your process stops or you turn off

00:14:49,329 --> 00:14:53,950
the machine and of course you're only

00:14:52,390 --> 00:14:56,070
dealing with small data sets you're not

00:14:53,950 --> 00:14:58,690
dealing you know you can't deal with

00:14:56,070 --> 00:15:01,200
terabytes of data in memory and you know

00:14:58,690 --> 00:15:03,820
you know in a no process but otherwise

00:15:01,200 --> 00:15:06,279
you're dealing with data and you're

00:15:03,820 --> 00:15:08,500
effectively doing stuff in your I would

00:15:06,279 --> 00:15:13,810
imagine perfectly happy doing all of

00:15:08,500 --> 00:15:17,500
those things and so because you need

00:15:13,810 --> 00:15:19,779
that persistence and you've got a lot of

00:15:17,500 --> 00:15:22,209
information you're only dealing with

00:15:19,779 --> 00:15:24,160
subsets you have to do it this way you

00:15:22,209 --> 00:15:26,640
need a database at the other end of a

00:15:24,160 --> 00:15:26,640
connection

00:15:26,980 --> 00:15:33,630
and my guess would be that about 80% of

00:15:29,680 --> 00:15:36,399
your work is this it's moving data from

00:15:33,630 --> 00:15:38,769
Jason into some other format maybe it's

00:15:36,399 --> 00:15:40,990
another Jason structure maybe it's some

00:15:38,769 --> 00:15:43,480
other structure your marshalling your

00:15:40,990 --> 00:15:45,760
data into and sending it across through

00:15:43,480 --> 00:15:47,800
an API or a query or whatever to the

00:15:45,760 --> 00:15:49,779
database which then saves it and then

00:15:47,800 --> 00:15:51,310
the reverse and then your having to get

00:15:49,779 --> 00:15:53,019
what the database serves up in the

00:15:51,310 --> 00:15:55,600
format it serves it up and turn it into

00:15:53,019 --> 00:16:00,310
marshal it into the structure that you

00:15:55,600 --> 00:16:03,310
want and again that's you know do we

00:16:00,310 --> 00:16:07,510
really should we really be doing that is

00:16:03,310 --> 00:16:10,980
that really what we're employed to do so

00:16:07,510 --> 00:16:14,620
here's the here's the suggestion imagine

00:16:10,980 --> 00:16:19,899
that you had objects JSON that were

00:16:14,620 --> 00:16:20,949
persistent that were persistent okay now

00:16:19,899 --> 00:16:24,010
here's the interesting thing

00:16:20,949 --> 00:16:27,449
Jason is inherently at an hierarchical

00:16:24,010 --> 00:16:29,889
structure remember what I said

00:16:27,449 --> 00:16:32,019
any and all database models can be

00:16:29,889 --> 00:16:35,470
implemented on top of hierarchical data

00:16:32,019 --> 00:16:43,420
structure so from Jason you could model

00:16:35,470 --> 00:16:46,839
any database model you liked you could

00:16:43,420 --> 00:16:48,940
design your data to work the way you

00:16:46,839 --> 00:16:50,649
want you could implement the indices

00:16:48,940 --> 00:16:54,610
that you need not the ones that you're

00:16:50,649 --> 00:16:56,050
stuck with and you could even implement

00:16:54,610 --> 00:16:59,260
a query language if you wanted to write

00:16:56,050 --> 00:17:04,390
it in JavaScript right if you knew that

00:16:59,260 --> 00:17:07,120
you had instead of this you had this

00:17:04,390 --> 00:17:09,689
idea so imagine you could get from

00:17:07,120 --> 00:17:13,750
JavaScript to either in-memory objects

00:17:09,689 --> 00:17:15,730
or to their equivalents on disk as if

00:17:13,750 --> 00:17:21,459
they were pretty much the same things

00:17:15,730 --> 00:17:26,169
and that's what the concept of QJ SDB is

00:17:21,459 --> 00:17:28,320
all about okay so how could that even be

00:17:26,169 --> 00:17:31,919
possible how could you possibly do that

00:17:28,320 --> 00:17:35,010
well of course like everything in IT

00:17:31,919 --> 00:17:37,390
it's always an illusion and if you know

00:17:35,010 --> 00:17:39,370
how to create the right right illusion

00:17:37,390 --> 00:17:41,070
then then you can do it so how's the

00:17:39,370 --> 00:17:44,320
illusion created

00:17:41,070 --> 00:17:47,830
well the first thing is it has to use a

00:17:44,320 --> 00:17:49,270
database QJ s DB does use a database

00:17:47,830 --> 00:17:50,740
because at the end of the day you can't

00:17:49,270 --> 00:17:55,150
defy the laws of physics you've got to

00:17:50,740 --> 00:17:56,590
have a database to do this but the trick

00:17:55,150 --> 00:17:58,500
is that you need to have a database

00:17:56,590 --> 00:18:03,130
that's got some very specific

00:17:58,500 --> 00:18:05,740
characteristics essentially the same

00:18:03,130 --> 00:18:06,480
characteristics of JSON so what are

00:18:05,740 --> 00:18:10,060
those

00:18:06,480 --> 00:18:12,280
it's got to be hierarchical it's got to

00:18:10,060 --> 00:18:13,960
be schema free and it's got to be

00:18:12,280 --> 00:18:15,820
dynamic in other words no pre

00:18:13,960 --> 00:18:19,540
declaration of anything if you want to

00:18:15,820 --> 00:18:21,580
add a property add a sub objects merge

00:18:19,540 --> 00:18:25,030
stuff in you should be able to just do

00:18:21,580 --> 00:18:28,090
that okay and there's not many databases

00:18:25,030 --> 00:18:31,450
around that can do that the other thing

00:18:28,090 --> 00:18:34,090
is that what I call the unit of storage

00:18:31,450 --> 00:18:36,730
in that database has to be the

00:18:34,090 --> 00:18:39,700
individual key value pair at any depth

00:18:36,730 --> 00:18:41,920
within that hierarchy not the complete

00:18:39,700 --> 00:18:45,370
JSON document so you couldn't do what

00:18:41,920 --> 00:18:47,590
I'm describing with QJ s DB with say

00:18:45,370 --> 00:18:50,230
MongoDB where the unit of storage is a

00:18:47,590 --> 00:18:54,790
document not the collection of

00:18:50,230 --> 00:18:57,130
individual key value pairs there's

00:18:54,790 --> 00:19:00,220
really only one database technology out

00:18:57,130 --> 00:19:03,040
there that meets these requirements and

00:19:00,220 --> 00:19:04,600
you'll almost I pretty much can

00:19:03,040 --> 00:19:06,850
guarantee you'll have never ever heard

00:19:04,600 --> 00:19:10,510
of them I have because I have the

00:19:06,850 --> 00:19:12,280
advantage of age coming from a time when

00:19:10,510 --> 00:19:15,790
hierarchical databases did actually

00:19:12,280 --> 00:19:18,460
exist I've spent an entire career using

00:19:15,790 --> 00:19:21,850
these databases and generically they're

00:19:18,460 --> 00:19:24,370
known as global storage databases there

00:19:21,850 --> 00:19:26,320
are two main implementations around

00:19:24,370 --> 00:19:29,260
these days there used to be lots but

00:19:26,320 --> 00:19:32,320
it's all kind of filtered down one is an

00:19:29,260 --> 00:19:34,210
open source one called yata DB and the

00:19:32,320 --> 00:19:35,710
other is a proprietary database called

00:19:34,210 --> 00:19:37,210
iris they used to have this and a

00:19:35,710 --> 00:19:38,920
company called inter systems they used

00:19:37,210 --> 00:19:41,020
to have a product called cachet no

00:19:38,920 --> 00:19:44,050
they've they've they're very red they're

00:19:41,020 --> 00:19:45,790
marketing their product as iris these

00:19:44,050 --> 00:19:47,920
two products although they look very

00:19:45,790 --> 00:19:49,480
similar if it looked very different and

00:19:47,920 --> 00:19:53,440
you'll see them marketed very very

00:19:49,480 --> 00:19:57,460
differently inside underneath the covers

00:19:53,440 --> 00:20:01,390
they are instances of this global

00:19:57,460 --> 00:20:04,300
storage database so they're very

00:20:01,390 --> 00:20:07,990
little-known they date from the late 60s

00:20:04,300 --> 00:20:11,560
early 70s and they actually dominate a

00:20:07,990 --> 00:20:15,970
couple of sectors and one is healthcare

00:20:11,560 --> 00:20:18,490
and across the world there are two major

00:20:15,970 --> 00:20:22,030
vendors of health care systems that

00:20:18,490 --> 00:20:25,630
hospitals buy one is called Cerner the

00:20:22,030 --> 00:20:29,790
other is called epic epic uses cachet

00:20:25,630 --> 00:20:32,170
and migrating to iris and and they're a

00:20:29,790 --> 00:20:34,870
multi-billion dollar company they're

00:20:32,170 --> 00:20:39,730
they're massive worldwide pretty much

00:20:34,870 --> 00:20:43,960
dominate the healthcare sector Yatta DB

00:20:39,730 --> 00:20:47,050
is derived from it's a fork of something

00:20:43,960 --> 00:20:48,880
called GTM which has actually grown up

00:20:47,050 --> 00:20:52,810
around banking systems so some of the

00:20:48,880 --> 00:20:54,550
major banks in the world their core

00:20:52,810 --> 00:20:57,130
banking system the stuff that you don't

00:20:54,550 --> 00:20:59,980
see kind of the retail side the internal

00:20:57,130 --> 00:21:05,530
stuff is built on GTM and yata DB is an

00:20:59,980 --> 00:21:07,360
open source fork of of that database but

00:21:05,530 --> 00:21:11,620
as I say the the interesting thing is

00:21:07,360 --> 00:21:13,810
that I am I've yet to meet anyone really

00:21:11,620 --> 00:21:17,410
in these kind of conferences who's oh

00:21:13,810 --> 00:21:19,230
yeah is that all the time one of the

00:21:17,410 --> 00:21:23,320
things about these databases is they are

00:21:19,230 --> 00:21:26,380
incredibly fast ludicrously fast even on

00:21:23,320 --> 00:21:31,180
this laptop I could run iris or otter DB

00:21:26,380 --> 00:21:34,300
and I could write or read readers even

00:21:31,180 --> 00:21:38,170
faster over a million key value pairs a

00:21:34,300 --> 00:21:40,120
second and tris my colleague who's here

00:21:38,170 --> 00:21:43,030
he he told me recently that he's been

00:21:40,120 --> 00:21:44,560
dealing with a very large Linux system

00:21:43,030 --> 00:21:47,860
whereas over three million is that

00:21:44,560 --> 00:21:50,590
rectoress yeah I mean these these are

00:21:47,860 --> 00:21:53,260
near in memory performance levels and

00:21:50,590 --> 00:21:54,130
also they are not toi databases they

00:21:53,260 --> 00:21:55,600
have all the you know

00:21:54,130 --> 00:21:56,890
industrial-strength they've got the

00:21:55,600 --> 00:21:59,050
scalability they've got all the

00:21:56,890 --> 00:22:02,140
management systems you can you can

00:21:59,050 --> 00:22:04,649
replicate them and all that kind of unit

00:22:02,140 --> 00:22:10,149
that just goes with them so

00:22:04,649 --> 00:22:12,219
so that's what I'm building on top of so

00:22:10,149 --> 00:22:14,859
the way where it's architected is that

00:22:12,219 --> 00:22:17,499
we've got no js' over here with with the

00:22:14,859 --> 00:22:21,879
JavaScript environment and we've got the

00:22:17,499 --> 00:22:24,070
yatta DB or iris database first trick is

00:22:21,879 --> 00:22:26,349
and this is Kara courtesy of my

00:22:24,070 --> 00:22:28,629
colleague Chris anyone who's interested

00:22:26,349 --> 00:22:32,590
in how this actually works and talk to

00:22:28,629 --> 00:22:36,519
him later we've got a connecting module

00:22:32,590 --> 00:22:38,529
called M gdb X which creates an in

00:22:36,519 --> 00:22:40,359
process connection so this isn't an this

00:22:38,529 --> 00:22:42,129
isn't a network connection this is an

00:22:40,359 --> 00:22:45,849
improved connection in process

00:22:42,129 --> 00:22:47,200
connection to a sea level at the sea

00:22:45,849 --> 00:22:49,419
level interface that both those

00:22:47,200 --> 00:22:51,099
databases provide so basically going

00:22:49,419 --> 00:22:54,399
straight into the core of the database

00:22:51,099 --> 00:22:56,619
engine at the lowest level that's a very

00:22:54,399 --> 00:22:58,779
low level API so then the other thing

00:22:56,619 --> 00:23:01,149
that I've provided on top of that is an

00:22:58,779 --> 00:23:04,690
abstraction layer which does this trick

00:23:01,149 --> 00:23:09,190
of then making these api's appear to

00:23:04,690 --> 00:23:14,259
behave as persistent JSON objects

00:23:09,190 --> 00:23:16,989
persistent JavaScript objects and so

00:23:14,259 --> 00:23:19,179
that creates the illusion because it's

00:23:16,989 --> 00:23:21,929
in process not across a network because

00:23:19,179 --> 00:23:24,940
of that abstraction you appear to have

00:23:21,929 --> 00:23:27,849
both in memory objects and they're on

00:23:24,940 --> 00:23:29,619
disk counterparts and you do everything

00:23:27,849 --> 00:23:33,789
as far as you're concerned you're

00:23:29,619 --> 00:23:36,039
dealing with Jason and some years ago

00:23:33,789 --> 00:23:38,379
it's actually soon after the whole know

00:23:36,039 --> 00:23:39,849
SQL thing burst onto the scene I wrote a

00:23:38,379 --> 00:23:42,729
paper with a colleague called George

00:23:39,849 --> 00:23:45,190
James about how this might be possible

00:23:42,729 --> 00:23:49,719
to map than these other databases on top

00:23:45,190 --> 00:23:53,529
of global storage and it was this is

00:23:49,719 --> 00:23:56,769
what then was stimulated by those tweets

00:23:53,529 --> 00:23:58,839
from Simon leg was I decided well okay

00:23:56,769 --> 00:24:02,200
the time has come not only do I provide

00:23:58,839 --> 00:24:04,570
the document database basic structure I

00:24:02,200 --> 00:24:06,940
decided okay well I'll build all these

00:24:04,570 --> 00:24:09,399
other database models and I did that

00:24:06,940 --> 00:24:10,599
during November and December so not only

00:24:09,399 --> 00:24:11,739
do you have the document database

00:24:10,599 --> 00:24:13,989
capability

00:24:11,739 --> 00:24:16,230
you've got Redis like key value store

00:24:13,989 --> 00:24:18,480
capability you've got lists

00:24:16,230 --> 00:24:20,610
I've even implemented a native XML

00:24:18,480 --> 00:24:23,370
database which basically implements this

00:24:20,610 --> 00:24:27,899
persistent XML Dom if you know the XML

00:24:23,370 --> 00:24:30,840
Dom it'sit's the w3c standard it's it's

00:24:27,899 --> 00:24:34,289
you know an in-memory way of breaking

00:24:30,840 --> 00:24:36,149
down an XML document yeah actually can

00:24:34,289 --> 00:24:38,909
be applied to any hierarchical structure

00:24:36,149 --> 00:24:40,679
you like but then an XML document into

00:24:38,909 --> 00:24:42,870
the document object model it's got a

00:24:40,679 --> 00:24:45,539
counterpart the HTML DOM and you all be

00:24:42,870 --> 00:24:48,240
familiar with get get elements by tag

00:24:45,539 --> 00:24:49,529
name get noticed by ID create elements

00:24:48,240 --> 00:24:52,350
and all that kind of stuff that's the

00:24:49,529 --> 00:24:56,490
DOM and and normally it works in memory

00:24:52,350 --> 00:24:58,649
in this it works on disk okay so it's

00:24:56,490 --> 00:25:02,909
effectively saying well let's just have

00:24:58,649 --> 00:25:05,940
this XML document persistent and I've

00:25:02,909 --> 00:25:08,880
plugged in XPath query is the really

00:25:05,940 --> 00:25:12,990
cool thing about the XPath query is that

00:25:08,880 --> 00:25:17,510
I took the standard nodejs XPath module

00:25:12,990 --> 00:25:21,419
which which expects an in-memory Dom and

00:25:17,510 --> 00:25:24,510
I just plugged my on disk Dom into it

00:25:21,419 --> 00:25:26,460
and bang it just worked it was fantastic

00:25:24,510 --> 00:25:30,779
and so I didn't have to worry about

00:25:26,460 --> 00:25:32,730
writing an XPath pose or whatever I just

00:25:30,779 --> 00:25:35,669
plugged it in and I'll show you later I

00:25:32,730 --> 00:25:38,039
think we've got time that it does

00:25:35,669 --> 00:25:41,279
actually work and again courtesy of

00:25:38,039 --> 00:25:45,750
Chris my colleague I've also implemented

00:25:41,279 --> 00:25:48,480
a relational model as well with SQL and

00:25:45,750 --> 00:25:51,210
so at the same time you can you can you

00:25:48,480 --> 00:25:52,830
can have relational databases modeled on

00:25:51,210 --> 00:25:56,190
top of this so I've done this really as

00:25:52,830 --> 00:25:59,220
a showcase to show what's possible that

00:25:56,190 --> 00:26:01,500
these things can be done but also then

00:25:59,220 --> 00:26:03,960
you can take this and you can build on

00:26:01,500 --> 00:26:05,370
top of it whatever other models you want

00:26:03,960 --> 00:26:07,980
for example I'd love someone to do a

00:26:05,370 --> 00:26:10,440
graph database on top of it that would

00:26:07,980 --> 00:26:12,120
be I wouldn't say it was very

00:26:10,440 --> 00:26:13,559
straightforward this structure

00:26:12,120 --> 00:26:15,269
structurally it'd be straightforward it

00:26:13,559 --> 00:26:18,659
like all these things it's the querying

00:26:15,269 --> 00:26:21,570
that's the that's the the problem so

00:26:18,659 --> 00:26:24,510
let's start with this guy here what of

00:26:21,570 --> 00:26:26,789
what I've tried trying to do here is to

00:26:24,510 --> 00:26:28,350
demonstrate a few of the capabilities so

00:26:26,789 --> 00:26:29,940
on the right here I've got a

00:26:28,350 --> 00:26:32,860
browser-based application

00:26:29,940 --> 00:26:36,490
which allows me to play around with the

00:26:32,860 --> 00:26:42,250
basic JSON storage so here I've got just

00:26:36,490 --> 00:26:45,310
this example Jason and over here in this

00:26:42,250 --> 00:26:47,080
area you're seeing a view in real time

00:26:45,310 --> 00:26:49,480
there's a WebSocket application on the

00:26:47,080 --> 00:26:51,820
Left which is waiting for changes to

00:26:49,480 --> 00:26:53,590
occur within the actual global storage

00:26:51,820 --> 00:26:54,880
database and as soon as it changes it's

00:26:53,590 --> 00:26:58,330
going to it's going to render it and

00:26:54,880 --> 00:27:02,500
show you what's in there so I could take

00:26:58,330 --> 00:27:05,500
this object here and I could say set

00:27:02,500 --> 00:27:08,620
document bang there it is it's taken

00:27:05,500 --> 00:27:10,390
that JSON and it's mapped it into the

00:27:08,620 --> 00:27:13,930
database and here's the the hierarchical

00:27:10,390 --> 00:27:18,520
structure that it's created and if I if

00:27:13,930 --> 00:27:21,430
I scroll across here you will see the

00:27:18,520 --> 00:27:24,040
JSON abstraction of it so I could

00:27:21,430 --> 00:27:26,050
retrieve that this is basically which

00:27:24,040 --> 00:27:28,420
should retrieve that in real time and

00:27:26,050 --> 00:27:30,880
displaying it then as as the JSON and

00:27:28,420 --> 00:27:35,980
it's exactly the same JSON that I put in

00:27:30,880 --> 00:27:38,650
and here it is oops now the if you look

00:27:35,980 --> 00:27:41,350
at this hierarchy you'll see here these

00:27:38,650 --> 00:27:43,540
are the what are called sub scripts in

00:27:41,350 --> 00:27:46,600
the database and they map one to one

00:27:43,540 --> 00:27:48,400
onto the keys of the of the JSON so it's

00:27:46,600 --> 00:27:50,770
actually this this very nice one-to-one

00:27:48,400 --> 00:27:53,740
mapping that it just gives you

00:27:50,770 --> 00:27:55,510
automatically so for example I can say

00:27:53,740 --> 00:27:56,980
get document here and it'll pull back

00:27:55,510 --> 00:28:02,590
there that's pulled it all back from the

00:27:56,980 --> 00:28:04,060
database again I could I can then but I

00:28:02,590 --> 00:28:06,130
don't have to just go for the entire

00:28:04,060 --> 00:28:07,690
object I can pull out section so if I

00:28:06,130 --> 00:28:09,760
click on this it's going to just give me

00:28:07,690 --> 00:28:12,670
the this section here the contact

00:28:09,760 --> 00:28:16,600
section now is that subset I can drill

00:28:12,670 --> 00:28:20,380
down or further go down to the next

00:28:16,600 --> 00:28:22,780
level the next level and the next level

00:28:20,380 --> 00:28:25,030
and you can see I'm just right down to

00:28:22,780 --> 00:28:28,300
this subset so you've got random access

00:28:25,030 --> 00:28:30,970
to the to the adjacent in storage you're

00:28:28,300 --> 00:28:33,370
not having to pull an entire document

00:28:30,970 --> 00:28:34,150
out of off the disk and into memory and

00:28:33,370 --> 00:28:36,220
manipulate it

00:28:34,150 --> 00:28:38,800
this is manipulating pulling directly

00:28:36,220 --> 00:28:41,530
from the disk and creating just you know

00:28:38,800 --> 00:28:43,600
the subsets that we want I could delete

00:28:41,530 --> 00:28:48,190
a section so I could say let's

00:28:43,600 --> 00:28:50,740
let's get the let's just get the that

00:28:48,190 --> 00:28:58,090
main view back again if I say get

00:28:50,740 --> 00:29:00,010
document here right if I do that that'll

00:28:58,090 --> 00:29:01,750
bring back there's the whole thing and

00:29:00,010 --> 00:29:05,490
you'll see here we've got subscripts

00:29:01,750 --> 00:29:14,740
like demo contact okay so I could say

00:29:05,490 --> 00:29:20,830
here delete demo dot contact and bang

00:29:14,740 --> 00:29:23,080
it's gone see it's disappeared what else

00:29:20,830 --> 00:29:33,150
have I got down here and I can add stuff

00:29:23,080 --> 00:29:42,130
I could add hello world that's right

00:29:33,150 --> 00:29:49,179
hello : world and I could say I want add

00:29:42,130 --> 00:29:49,510
that to demo dot ABC and bingo there it

00:29:49,179 --> 00:29:51,940
is

00:29:49,510 --> 00:29:55,900
it's added it up he riously just like

00:29:51,940 --> 00:29:58,990
that so that's all very well so now

00:29:55,900 --> 00:30:04,840
let's have a look at lists so this is a

00:29:58,990 --> 00:30:07,179
this is a Redis like list API so let's

00:30:04,840 --> 00:30:10,480
just clear down the that view in there

00:30:07,179 --> 00:30:13,929
and I can say so so this is going to

00:30:10,480 --> 00:30:16,030
come up with test data here every time I

00:30:13,929 --> 00:30:18,010
add an object onto disk it will bring up

00:30:16,030 --> 00:30:19,600
another record so I've got a few can

00:30:18,010 --> 00:30:22,150
kind of records so here's mine first

00:30:19,600 --> 00:30:24,789
name last name city gender and I can say

00:30:22,150 --> 00:30:29,020
right I want to I don't know if you know

00:30:24,789 --> 00:30:31,690
reddest lists you've got L push an hour

00:30:29,020 --> 00:30:34,570
push and L pop and our pop stuff like

00:30:31,690 --> 00:30:36,070
that so let's do an L push bang and

00:30:34,570 --> 00:30:38,289
you'll see what it's done here with that

00:30:36,070 --> 00:30:43,030
just that express through that API it's

00:30:38,289 --> 00:30:45,850
created a data structure from this

00:30:43,030 --> 00:30:48,370
record that is providing me with the

00:30:45,850 --> 00:30:52,960
linked list so that if I do another L

00:30:48,370 --> 00:30:54,820
push and another one then it's we you

00:30:52,960 --> 00:30:57,040
can see you've got these previous node

00:30:54,820 --> 00:31:02,200
and the next node pointers

00:30:57,040 --> 00:31:04,960
so that when I do in it I can do a pop

00:31:02,200 --> 00:31:09,010
for example and it'll pull pull me back

00:31:04,960 --> 00:31:11,470
that that that record and delete it from

00:31:09,010 --> 00:31:13,060
the database or I could do an hour pop

00:31:11,470 --> 00:31:15,610
and it'll get get it from the other end

00:31:13,060 --> 00:31:17,620
of the list so that's all very

00:31:15,610 --> 00:31:21,340
interesting you can play around with

00:31:17,620 --> 00:31:25,120
that about the relational database so I

00:31:21,340 --> 00:31:26,980
can clear down that again and again same

00:31:25,120 --> 00:31:29,320
idea I've got these test objects that

00:31:26,980 --> 00:31:31,030
are going to like an add-in to the thing

00:31:29,320 --> 00:31:32,800
so I'm going to create a table and this

00:31:31,030 --> 00:31:36,190
is going to use SQL so it's going to use

00:31:32,800 --> 00:31:40,810
a create table SQL command to create the

00:31:36,190 --> 00:31:43,390
table that's created that and let's

00:31:40,810 --> 00:31:50,400
create an index I'm gonna call it by

00:31:43,390 --> 00:31:52,720
city and oops right wrong way around

00:31:50,400 --> 00:31:57,010
it's the city field and I'm going to

00:31:52,720 --> 00:32:00,930
call the index by city so let's create

00:31:57,010 --> 00:32:04,900
that index and now I'll insert a record

00:32:00,930 --> 00:32:06,880
and insert another record user it

00:32:04,900 --> 00:32:09,970
another one and you can see they've been

00:32:06,880 --> 00:32:14,260
added into the database here that's

00:32:09,970 --> 00:32:16,930
using SQL inserts and now I could get

00:32:14,260 --> 00:32:26,710
them back select star from this guy

00:32:16,930 --> 00:32:28,180
oops other case there does that work

00:32:26,710 --> 00:32:30,970
sorry I don't know what happened there

00:32:28,180 --> 00:32:33,430
so there it is it's pulled back the the

00:32:30,970 --> 00:32:36,400
records the results set with all the

00:32:33,430 --> 00:32:41,190
fields and I could be some more

00:32:36,400 --> 00:32:49,140
selective I could say select last name

00:32:41,190 --> 00:32:49,140
where City equals Red Hill

00:32:52,980 --> 00:32:57,690
okay it's not playing ball dad don't lie

00:32:59,790 --> 00:33:05,970
quite sure why another well there we are

00:33:02,470 --> 00:33:09,480
and there we go it's pulled back the

00:33:05,970 --> 00:33:12,730
records where the last name was Red Hill

00:33:09,480 --> 00:33:15,070
so we've got and I could do the delete

00:33:12,730 --> 00:33:17,280
as well let's have a look at the XML

00:33:15,070 --> 00:33:21,040
down this one this one's my favorite

00:33:17,280 --> 00:33:25,210
most spectacular so here I've got an XML

00:33:21,040 --> 00:33:30,490
document it's all about pubs and let's

00:33:25,210 --> 00:33:32,400
clear down the why is there not clearing

00:33:30,490 --> 00:33:38,080
down

00:33:32,400 --> 00:33:42,490
let's just reload dad there we are

00:33:38,080 --> 00:33:47,320
okay so I'll pause as XML now the the

00:33:42,490 --> 00:33:51,100
parsing uses the the standard node sax

00:33:47,320 --> 00:33:52,810
poser and then it uses the Dom the XML

00:33:51,100 --> 00:33:55,480
Dom API is that are implemented in this

00:33:52,810 --> 00:33:57,190
too to save the rep the record so as it

00:33:55,480 --> 00:33:59,290
does it so far as the document there it

00:33:57,190 --> 00:34:03,250
is it spars that entire document and now

00:33:59,290 --> 00:34:06,400
it's representing it as effectively as a

00:34:03,250 --> 00:34:08,710
persistent Dom but the way you access

00:34:06,400 --> 00:34:11,260
this then is through the through the API

00:34:08,710 --> 00:34:14,020
is the Dom API is which are all

00:34:11,260 --> 00:34:16,870
implemented exactly as per the w3c spec

00:34:14,020 --> 00:34:19,000
so for example first thing I can do I

00:34:16,870 --> 00:34:22,390
can output that XML again there there it

00:34:19,000 --> 00:34:25,500
is it's retrieved it as XML okay I could

00:34:22,390 --> 00:34:28,770
do this I could put it a tag name foo

00:34:25,500 --> 00:34:31,930
and it'll do get elements by tag name

00:34:28,770 --> 00:34:36,340
and back it comes here are the nodes

00:34:31,930 --> 00:34:43,180
that there are food nodes get element by

00:34:36,340 --> 00:34:46,000
ID I could put an ID of wins by ID there

00:34:43,180 --> 00:34:48,340
it is found that in the document I can

00:34:46,000 --> 00:34:51,250
also run an XPath query I could say

00:34:48,340 --> 00:34:53,470
slash slash foo for example run the

00:34:51,250 --> 00:34:55,720
XPath and now they are there's the foo

00:34:53,470 --> 00:35:01,210
nodes come back through XPath as I say

00:34:55,720 --> 00:35:03,609
that's using the this standard nodejs

00:35:01,210 --> 00:35:05,470
XPath module which assumes

00:35:03,609 --> 00:35:09,730
in memory implementation is actually

00:35:05,470 --> 00:35:11,079
getting it off disk here it just doesn't

00:35:09,730 --> 00:35:13,119
know the difference can't see any

00:35:11,079 --> 00:35:16,660
difference we can even do something

00:35:13,119 --> 00:35:17,049
really cool here if I've got a few more

00:35:16,660 --> 00:35:21,880
minutes

00:35:17,049 --> 00:35:24,579
Adam three more minutes okay we can what

00:35:21,880 --> 00:35:28,269
we can actually do here is dynamically

00:35:24,579 --> 00:35:31,359
build an XML document of this so I could

00:35:28,269 --> 00:35:38,890
say I'll start with the document tag and

00:35:31,359 --> 00:35:41,230
I'll say that it is Rob append append

00:35:38,890 --> 00:35:48,579
the element it's added it to the Dom and

00:35:41,230 --> 00:35:51,430
if I go up here and I say output as XML

00:35:48,579 --> 00:35:54,819
there we are it's coming back as Rob and

00:35:51,430 --> 00:35:59,829
now I could go down and I could say what

00:35:54,819 --> 00:36:06,509
I want here is slash slash Rob and I'm

00:35:59,829 --> 00:36:13,450
going to append a tag called from hello

00:36:06,509 --> 00:36:14,589
with a piece of text inside world and

00:36:13,450 --> 00:36:17,470
append that element

00:36:14,589 --> 00:36:20,829
it's added that into the Dom and I can

00:36:17,470 --> 00:36:24,069
go up here and I'd put letters and there

00:36:20,829 --> 00:36:25,900
we are it's all and that's on disk so

00:36:24,069 --> 00:36:28,660
you could use this to dynamically build

00:36:25,900 --> 00:36:29,670
on disk directly on disk this isn't

00:36:28,660 --> 00:36:32,349
going through memory and this is

00:36:29,670 --> 00:36:40,960
physically writing it to the disk as an

00:36:32,349 --> 00:36:43,210
XML Dom so that is jsd be if you're

00:36:40,960 --> 00:36:45,069
interested in it have a look on the

00:36:43,210 --> 00:36:47,499
github sites all open source if you use

00:36:45,069 --> 00:36:50,470
the got a DB version it's all open

00:36:47,499 --> 00:36:54,069
source free to use all the code is there

00:36:50,470 --> 00:36:54,640
it's all docker eyes a lot so just give

00:36:54,069 --> 00:36:58,440
it a try

00:36:54,640 --> 00:37:00,640
and that's jst beer I hope you find that

00:36:58,440 --> 00:37:01,310
interesting a good way to stir the

00:37:00,640 --> 00:37:06,179
decade

00:37:01,310 --> 00:37:06,179

YouTube URL: https://www.youtube.com/watch?v=mmnutDw9FiE


