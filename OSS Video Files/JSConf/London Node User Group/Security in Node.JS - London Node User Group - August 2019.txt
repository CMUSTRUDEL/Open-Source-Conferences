Title: Security in Node.JS - London Node User Group - August 2019
Publication date: 2019-09-06
Playlist: London Node User Group
Description: 
	Presented by Forbes Lindesay

While working on large node.js projects, I’ve noticed that there is no clear answer to common questions like “how do I securely store passwords”. I’ve also noticed that all the popular frameworks lack key security features such as CSRF protection and Rate Limiting by default. It’s really easy to get security wrong, and it’s not your fault that this is so difficult.

In this talk, I’ll present some practical steps you can take to secure your applications, including protecting against some of the most common attack vectors. I’ll also attempt to inspire you to think differently about what the defaults should be when you build new applications and libraries. We can make our code default to security; it doesn’t have to be this way.

ABOUT ME
I'm a tech lead at Threads Styling and maintain several large open source projects, such as Pug, atauthentication.com and atdatabases.org. My twitter handle is @ForbesLindesay.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:04,650
I'm going to be talking about security

00:00:01,140 --> 00:00:06,299
in nodejs and we're going to cover some

00:00:04,650 --> 00:00:09,030
things to think about when you're

00:00:06,299 --> 00:00:11,790
thinking about security and then a

00:00:09,030 --> 00:00:14,130
couple of few specific examples there's

00:00:11,790 --> 00:00:16,710
some key issues to look out for in web

00:00:14,130 --> 00:00:19,949
apps there are others but these are some

00:00:16,710 --> 00:00:22,710
of the most common are cross-site

00:00:19,949 --> 00:00:25,109
request forgery SQL injection cross-site

00:00:22,710 --> 00:00:30,359
scripting people guessing or stealing

00:00:25,109 --> 00:00:32,369
passwords and click jacking now SQL

00:00:30,359 --> 00:00:34,829
injection and cross-site scripting are

00:00:32,369 --> 00:00:36,329
basically the same attack just on two

00:00:34,829 --> 00:00:38,550
different technologies so cross-site

00:00:36,329 --> 00:00:41,730
scripting is where someone injects

00:00:38,550 --> 00:00:44,160
malicious HTML into your page

00:00:41,730 --> 00:00:47,340
SQL injection is where someone injects

00:00:44,160 --> 00:00:49,950
malicious SQL code into your back-end so

00:00:47,340 --> 00:00:52,320
different text acts different locations

00:00:49,950 --> 00:00:55,520
in the tech stack but the same style of

00:00:52,320 --> 00:00:59,280
attack I don't have time to cover

00:00:55,520 --> 00:01:01,109
everything related to node security so

00:00:59,280 --> 00:01:04,229
I'm going to focus on a few things

00:01:01,109 --> 00:01:06,000
we're going to look at how to properly

00:01:04,229 --> 00:01:07,320
handle session storage so you don't get

00:01:06,000 --> 00:01:10,530
vulnerable to cross-site scripting

00:01:07,320 --> 00:01:11,909
cross-site request forgery sorry we're

00:01:10,530 --> 00:01:13,950
going to look at how to prevent SQL

00:01:11,909 --> 00:01:16,229
injection and we're also going to look

00:01:13,950 --> 00:01:17,820
at a little bit about passwords and

00:01:16,229 --> 00:01:20,790
specifically we're going to talk about

00:01:17,820 --> 00:01:22,409
rate limiting as a way of making it

00:01:20,790 --> 00:01:26,610
harder for people to steal your

00:01:22,409 --> 00:01:28,650
passwords so starting with passwords the

00:01:26,610 --> 00:01:31,049
first question you always need to ask

00:01:28,650 --> 00:01:33,900
yourself whenever you are setting up a

00:01:31,049 --> 00:01:35,700
new password system is do I really need

00:01:33,900 --> 00:01:38,930
passwords because as soon as you decide

00:01:35,700 --> 00:01:42,450
that yes you absolutely must have

00:01:38,930 --> 00:01:44,340
password-based authentication you are

00:01:42,450 --> 00:01:47,670
setting yourself up to need to do secure

00:01:44,340 --> 00:01:50,490
storage secure validation handling

00:01:47,670 --> 00:01:52,020
password resets dealing with customers

00:01:50,490 --> 00:01:53,369
getting phishing attacks which is almost

00:01:52,020 --> 00:01:57,719
like completely out of your control

00:01:53,369 --> 00:01:59,969
that's very you can do about it and

00:01:57,719 --> 00:02:03,960
there's great alternatives so there's

00:01:59,969 --> 00:02:06,630
two kind of top line great alternatives

00:02:03,960 --> 00:02:08,940
to passwords the first is what's been

00:02:06,630 --> 00:02:11,970
called password lists which is where you

00:02:08,940 --> 00:02:13,260
use either an email address or a phone

00:02:11,970 --> 00:02:17,069
number

00:02:13,260 --> 00:02:19,950
as the authentication approach you send

00:02:17,069 --> 00:02:22,860
the user a message with a one-time code

00:02:19,950 --> 00:02:24,799
say six digit code they type that into

00:02:22,860 --> 00:02:27,659
your site and then you grant them access

00:02:24,799 --> 00:02:30,269
it's great because if that code gets

00:02:27,659 --> 00:02:31,950
stolen or typed into the different sites

00:02:30,269 --> 00:02:33,840
or something like that it's only got a

00:02:31,950 --> 00:02:37,049
short lifespan it's only got a single

00:02:33,840 --> 00:02:41,430
use it's not a permanent threat to your

00:02:37,049 --> 00:02:44,250
users security the other option is go

00:02:41,430 --> 00:02:46,620
off which is where you offload handling

00:02:44,250 --> 00:02:48,359
all of those annoying things that you

00:02:46,620 --> 00:02:51,109
need to deal with with passwords to some

00:02:48,359 --> 00:02:54,780
third party like Facebook Twitter Google

00:02:51,109 --> 00:02:58,379
Apple etc they all offer a service like

00:02:54,780 --> 00:03:01,230
this where you say look all of my users

00:02:58,379 --> 00:03:03,629
go and sign up over there I'll rely on

00:03:01,230 --> 00:03:07,440
that service to authenticate them and

00:03:03,629 --> 00:03:09,540
then I'll just trust that service if you

00:03:07,440 --> 00:03:12,569
have decided you absolutely must use

00:03:09,540 --> 00:03:15,389
passwords then your first step is going

00:03:12,569 --> 00:03:16,530
to be how do I store them securely I'm

00:03:15,389 --> 00:03:18,239
not going to cover this in loads of

00:03:16,530 --> 00:03:20,760
detail because lots of other online

00:03:18,239 --> 00:03:24,720
tutorials and other talks have covered

00:03:20,760 --> 00:03:27,090
this in lots of detail but the basic

00:03:24,720 --> 00:03:29,730
approach is to take a password and some

00:03:27,090 --> 00:03:31,650
randomly generated salt you pass it

00:03:29,730 --> 00:03:36,389
through a hash function that is a a

00:03:31,650 --> 00:03:39,209
one-way expensive function and you store

00:03:36,389 --> 00:03:40,470
that hash in the salt and the password

00:03:39,209 --> 00:03:42,209
hashing function there needs to be

00:03:40,470 --> 00:03:49,889
something designed for storing parts

00:03:42,209 --> 00:03:52,349
words not md5 not sha-1 not sha-512 then

00:03:49,889 --> 00:03:54,480
you've got these stored passwords you

00:03:52,349 --> 00:03:55,889
need to validate them in some way what

00:03:54,480 --> 00:03:57,870
you do is you take the exact same

00:03:55,889 --> 00:04:00,120
approach again except this time you're

00:03:57,870 --> 00:04:01,590
using the salts you stored from earlier

00:04:00,120 --> 00:04:03,599
the random string that you stored from

00:04:01,590 --> 00:04:06,090
earlier rather than generating a fresh

00:04:03,599 --> 00:04:08,129
one and you hash the incoming password

00:04:06,090 --> 00:04:11,069
from the user and you can then compare

00:04:08,129 --> 00:04:12,659
that hash with the stored hash that the

00:04:11,069 --> 00:04:15,750
hash that is stored from the previous

00:04:12,659 --> 00:04:18,150
thing that gives you a result that says

00:04:15,750 --> 00:04:19,829
either yes this this password matches

00:04:18,150 --> 00:04:23,010
the one that you were given before or no

00:04:19,829 --> 00:04:25,169
this one doesn't so I've got a library

00:04:23,010 --> 00:04:26,060
called at authentication slash secure

00:04:25,169 --> 00:04:28,910
hash

00:04:26,060 --> 00:04:32,510
that helps take care of this for you and

00:04:28,910 --> 00:04:35,330
the key thing that we do is we set it up

00:04:32,510 --> 00:04:36,290
with sensible defaults and that's going

00:04:35,330 --> 00:04:38,540
to be something that I come back to a

00:04:36,290 --> 00:04:40,990
couple of times in this talk a lot of

00:04:38,540 --> 00:04:44,150
libraries in the node world have

00:04:40,990 --> 00:04:48,070
ridiculous nonsensical defaults where

00:04:44,150 --> 00:04:50,810
out of the box they are not secure this

00:04:48,070 --> 00:04:53,120
defaults to settings that will make it

00:04:50,810 --> 00:04:56,360
take about one second to hash a password

00:04:53,120 --> 00:04:58,610
on a typical computer which should be

00:04:56,360 --> 00:05:01,280
reasonably secure for the majority of

00:04:58,610 --> 00:05:02,840
use cases and you can make it more

00:05:01,280 --> 00:05:04,610
secure if you need to and if for some

00:05:02,840 --> 00:05:06,320
reason you really need less security you

00:05:04,610 --> 00:05:08,419
can you can tweak it to make it less

00:05:06,320 --> 00:05:11,150
secure but out of the box it has

00:05:08,419 --> 00:05:11,540
sensible defaults if you decide to go

00:05:11,150 --> 00:05:15,139
down the Oh

00:05:11,540 --> 00:05:16,880
oh sorry it's not the size about Google

00:05:15,139 --> 00:05:20,690
Authenticator is another great option

00:05:16,880 --> 00:05:23,180
for increasing password security so the

00:05:20,690 --> 00:05:25,639
idea here is in addition to having your

00:05:23,180 --> 00:05:29,020
users log in with a password you support

00:05:25,639 --> 00:05:32,150
them using some second factor either

00:05:29,020 --> 00:05:34,460
sending them a code on an SMS or or an

00:05:32,150 --> 00:05:36,710
email or using something like Google

00:05:34,460 --> 00:05:38,470
Authenticator where they have an app on

00:05:36,710 --> 00:05:40,940
their phone that generates a one-time

00:05:38,470 --> 00:05:43,280
passcode and then you validate that on

00:05:40,940 --> 00:05:44,810
the server the great thing about this is

00:05:43,280 --> 00:05:46,940
actually a completely open protocol

00:05:44,810 --> 00:05:50,210
completely free anyone can use it no

00:05:46,940 --> 00:05:53,150
cost associated with it and this Google

00:05:50,210 --> 00:05:55,120
Authenticator library makes that super

00:05:53,150 --> 00:05:59,600
duper easy you just generate a random

00:05:55,120 --> 00:06:03,050
secure string that is the effectively

00:05:59,600 --> 00:06:05,419
the the cryptographic key on the server

00:06:03,050 --> 00:06:07,520
you store that and then that allows you

00:06:05,419 --> 00:06:09,380
to easily validate the incoming numbers

00:06:07,520 --> 00:06:12,470
and they change every 30 seconds so that

00:06:09,380 --> 00:06:14,539
if there ever leaked they don't have

00:06:12,470 --> 00:06:16,370
long-term validity and you might think

00:06:14,539 --> 00:06:19,820
that most of your users don't need this

00:06:16,370 --> 00:06:21,289
level of security but pretty much mark

00:06:19,820 --> 00:06:22,940
no matter what you're building there is

00:06:21,289 --> 00:06:26,510
some chance that you have at least some

00:06:22,940 --> 00:06:28,820
users who do you know most of your users

00:06:26,510 --> 00:06:31,970
might be fine but some of them might

00:06:28,820 --> 00:06:38,740
live in oppressive regimes and have to

00:06:31,970 --> 00:06:38,740
deal with really advanced adversaries

00:06:39,410 --> 00:06:45,270
so let's say you've done all of that the

00:06:42,870 --> 00:06:46,919
next problem is if you allow people to

00:06:45,270 --> 00:06:48,870
just keep attempting to guess the

00:06:46,919 --> 00:06:50,970
password sooner or later someone will

00:06:48,870 --> 00:06:53,520
guess the correct password so you need

00:06:50,970 --> 00:06:58,620
some way to limit the number of password

00:06:53,520 --> 00:07:01,680
attempts now one option is to just put a

00:06:58,620 --> 00:07:04,560
hard limit on how many times someone can

00:07:01,680 --> 00:07:06,570
try each password for a given user the

00:07:04,560 --> 00:07:09,270
problem with this is it makes it super

00:07:06,570 --> 00:07:12,600
easy for someone who's malicious to lock

00:07:09,270 --> 00:07:15,150
someone else out of their account so we

00:07:12,600 --> 00:07:17,630
want to prevent that we want to be able

00:07:15,150 --> 00:07:21,120
to to make sure that a malicious user

00:07:17,630 --> 00:07:22,979
both struggles to make lots of attempts

00:07:21,120 --> 00:07:24,870
so that at some point they they aren't

00:07:22,979 --> 00:07:28,169
able to keep making more more attempts

00:07:24,870 --> 00:07:30,750
at guessing the password but also you

00:07:28,169 --> 00:07:32,789
want to make sure that both that both of

00:07:30,750 --> 00:07:34,400
the malicious user can't easily lock

00:07:32,789 --> 00:07:37,470
someone out of their account permanently

00:07:34,400 --> 00:07:40,380
and also that an honest user who's just

00:07:37,470 --> 00:07:41,850
forgotten their password can keep trying

00:07:40,380 --> 00:07:44,820
until they figure out what their

00:07:41,850 --> 00:07:47,580
password is so an alternative that works

00:07:44,820 --> 00:07:50,490
better is exponential delay and then a

00:07:47,580 --> 00:07:53,690
thing about this is that in addition to

00:07:50,490 --> 00:07:56,789
taking longer with each password attempt

00:07:53,690 --> 00:07:57,930
it's so the idea here is you know it

00:07:56,789 --> 00:07:59,490
takes maybe a second for the first

00:07:57,930 --> 00:08:01,020
attempt two seconds for the next attempt

00:07:59,490 --> 00:08:02,639
four seconds for the next attempt in

00:08:01,020 --> 00:08:05,099
addition to taking longer for each

00:08:02,639 --> 00:08:06,750
attempt it also takes longer if you are

00:08:05,099 --> 00:08:10,380
trying to maliciously increase that to

00:08:06,750 --> 00:08:13,349
life so for example if we had one second

00:08:10,380 --> 00:08:15,810
for the delay for the first attempt and

00:08:13,349 --> 00:08:17,910
then we double the delay with each

00:08:15,810 --> 00:08:19,860
attempt so so say we allow the first

00:08:17,910 --> 00:08:21,750
attempt goes through completely fine

00:08:19,860 --> 00:08:23,729
still a one-second delay before you can

00:08:21,750 --> 00:08:26,280
make a second attempt and then we

00:08:23,729 --> 00:08:27,510
doubled the delay with each attempt with

00:08:26,280 --> 00:08:30,930
those numbers that seemed pretty

00:08:27,510 --> 00:08:34,320
reasonable if you're imagining being a

00:08:30,930 --> 00:08:36,390
normal user of this site it takes eight

00:08:34,320 --> 00:08:40,589
minutes to make ten guesses of the

00:08:36,390 --> 00:08:43,860
password and six days to make twenty

00:08:40,589 --> 00:08:47,579
attempts and that number scales like

00:08:43,860 --> 00:08:49,079
crazy so the point of which you've made

00:08:47,579 --> 00:08:52,170
enough attempts to actually brute-force

00:08:49,079 --> 00:08:57,180
that password the the universe

00:08:52,170 --> 00:09:00,480
ended there are some limits though to

00:08:57,180 --> 00:09:02,760
this exponential delay approach the

00:09:00,480 --> 00:09:05,089
problem is that we have to reset it on a

00:09:02,760 --> 00:09:07,490
successful attempt we can't treat a

00:09:05,089 --> 00:09:10,410
successful attempt and just carry on

00:09:07,490 --> 00:09:12,480
because if I if I just carry on

00:09:10,410 --> 00:09:15,720
increasing that limit and I never reset

00:09:12,480 --> 00:09:17,910
it then maybe the first time I login I

00:09:15,720 --> 00:09:20,519
forget the password a couple of times I

00:09:17,910 --> 00:09:23,579
have a couple of goes four or five

00:09:20,519 --> 00:09:26,250
seconds delay the next time I log in I

00:09:23,579 --> 00:09:28,380
forget the password again but if I'm

00:09:26,250 --> 00:09:30,720
still increasing the delay then I've got

00:09:28,380 --> 00:09:33,740
eight seconds delay sixteen seconds

00:09:30,720 --> 00:09:35,880
delay thirty-two seconds delay and so on

00:09:33,740 --> 00:09:38,610
and that's going to get painful really

00:09:35,880 --> 00:09:40,829
fast so what we normally do of

00:09:38,610 --> 00:09:43,230
exponential delay is say as soon as we

00:09:40,829 --> 00:09:49,889
get a successful login attempt we reset

00:09:43,230 --> 00:09:51,870
that counter so the upshot of this is it

00:09:49,889 --> 00:09:54,420
can also only be per account you can't

00:09:51,870 --> 00:09:57,589
do this per IP address you can't do this

00:09:54,420 --> 00:10:00,029
by some other metric it has to be

00:09:57,589 --> 00:10:02,100
associated with the specific email

00:10:00,029 --> 00:10:06,390
address that is logging in you know if

00:10:02,100 --> 00:10:08,790
you had it site wide then um a user

00:10:06,390 --> 00:10:10,620
failing to log out their log in to their

00:10:08,790 --> 00:10:12,000
account would be delaying everybody else

00:10:10,620 --> 00:10:16,500
logging into the site so that doesn't

00:10:12,000 --> 00:10:17,730
work so this is where we come on to to

00:10:16,500 --> 00:10:19,560
what people traditionally think of as

00:10:17,730 --> 00:10:22,290
rate limiting I'd kind of bundle them

00:10:19,560 --> 00:10:27,570
together exponential delay as a form of

00:10:22,290 --> 00:10:30,390
rate limiting without rate limits if you

00:10:27,570 --> 00:10:33,660
don't have a rate limit you are using

00:10:30,390 --> 00:10:36,000
your your CPUs and your memory your

00:10:33,660 --> 00:10:38,760
hardware that you're paying for to crack

00:10:36,000 --> 00:10:41,190
your own users passwords so someone else

00:10:38,760 --> 00:10:42,480
can go in and go Erik and someone on

00:10:41,190 --> 00:10:45,810
this site would have been stupid enough

00:10:42,480 --> 00:10:47,790
to use the password password so what

00:10:45,810 --> 00:10:49,920
I'll try I know that there's this

00:10:47,790 --> 00:10:52,620
exponential delay so I can't try brute

00:10:49,920 --> 00:10:54,120
forcing one users password but if

00:10:52,620 --> 00:10:55,889
there's no other form of rate limiting I

00:10:54,120 --> 00:10:58,230
can try the password password against

00:10:55,889 --> 00:11:01,110
every user on your site and it's up to

00:10:58,230 --> 00:11:02,819
you or your site then to do the hashing

00:11:01,110 --> 00:11:05,600
and verification all the expensive work

00:11:02,819 --> 00:11:07,930
of checking that password

00:11:05,600 --> 00:11:11,690
so you need some sort of rate limiting

00:11:07,930 --> 00:11:14,180
the simplest and I'd say most commonly

00:11:11,690 --> 00:11:16,820
implemented but also worst form of rate

00:11:14,180 --> 00:11:19,640
limiting is fixed window rate limiting

00:11:16,820 --> 00:11:23,120
which is where you say you can make ten

00:11:19,640 --> 00:11:25,420
requests per hour and once you've made

00:11:23,120 --> 00:11:28,460
those ten requests I'll make you wait

00:11:25,420 --> 00:11:30,710
and that leads to stuff like this that's

00:11:28,460 --> 00:11:34,490
really frustrating where you go wow

00:11:30,710 --> 00:11:38,900
we've hit the next slide rate limit so

00:11:34,490 --> 00:11:41,810
try again in a minute I guess not only

00:11:38,900 --> 00:11:44,870
is it frustrating because of that it's

00:11:41,810 --> 00:11:47,360
also unfair so if you happen to get

00:11:44,870 --> 00:11:50,210
there just before the window closes you

00:11:47,360 --> 00:11:51,920
can make ten requests and then just one

00:11:50,210 --> 00:11:53,990
second later make another ten requests

00:11:51,920 --> 00:11:56,300
but if you have them to arrive just as

00:11:53,990 --> 00:11:57,680
the window is starting you make ten

00:11:56,300 --> 00:12:00,650
requests and in the end can't make any

00:11:57,680 --> 00:12:02,510
more requests for a whole hour so a

00:12:00,650 --> 00:12:05,210
slightly fairer but still rubbish

00:12:02,510 --> 00:12:07,730
approach a sliding window rate limiting

00:12:05,210 --> 00:12:09,650
and this is where you say in any rolling

00:12:07,730 --> 00:12:12,680
hour-long period that a number of

00:12:09,650 --> 00:12:17,060
requests can't go over ten but it has

00:12:12,680 --> 00:12:18,950
this problem so one of the biggest

00:12:17,060 --> 00:12:20,900
problems with this is it forces us to

00:12:18,950 --> 00:12:22,130
keep track of every single request and

00:12:20,900 --> 00:12:24,350
when it happened so if we want to

00:12:22,130 --> 00:12:26,000
implement this accurately we have to

00:12:24,350 --> 00:12:27,680
keep a complete record of all of the

00:12:26,000 --> 00:12:29,870
requests that are within the last hour

00:12:27,680 --> 00:12:31,370
and every time we want to know whether

00:12:29,870 --> 00:12:33,980
someone has hit the rate limit we've got

00:12:31,370 --> 00:12:37,220
to count up all of those requests see if

00:12:33,980 --> 00:12:39,350
there's one left available so it's

00:12:37,220 --> 00:12:42,020
expensive in terms of storage it's

00:12:39,350 --> 00:12:43,640
expensive in terms of computation given

00:12:42,020 --> 00:12:46,520
that one of the core things we're trying

00:12:43,640 --> 00:12:49,420
to do is is prevent someone abusing our

00:12:46,520 --> 00:12:52,430
servers and and locking everyone out by

00:12:49,420 --> 00:12:55,460
eating up all of our CPU power that's

00:12:52,430 --> 00:12:56,990
not really viable plus it has most of

00:12:55,460 --> 00:12:58,460
the problems with a fixed window rate

00:12:56,990 --> 00:12:59,930
limiting in terms of being really

00:12:58,460 --> 00:13:03,650
frustrating when you're a legitimate

00:12:59,930 --> 00:13:05,930
user but you accidentally use more than

00:13:03,650 --> 00:13:07,760
the expected number of requests in a

00:13:05,930 --> 00:13:10,580
certain amount of time so a better

00:13:07,760 --> 00:13:11,720
approach is known as token bucket rate

00:13:10,580 --> 00:13:15,080
limiting and this is the one I want to

00:13:11,720 --> 00:13:17,390
really focus on so the idea behind this

00:13:15,080 --> 00:13:19,240
is if you this is also sometimes called

00:13:17,390 --> 00:13:20,980
leaky bucket rate limit

00:13:19,240 --> 00:13:23,140
which is a much more confusing metaphor

00:13:20,980 --> 00:13:26,860
but if you see that referenced online

00:13:23,140 --> 00:13:29,170
this is the same thing so token bucket

00:13:26,860 --> 00:13:31,240
rate-limiting the idea is you start out

00:13:29,170 --> 00:13:32,710
with a bucket of tokens and every time

00:13:31,240 --> 00:13:34,450
you want to perform an action you have

00:13:32,710 --> 00:13:36,460
to take a token out of the bucket and

00:13:34,450 --> 00:13:39,250
feed it into the machine to make your

00:13:36,460 --> 00:13:41,860
request and it starts off you can keep

00:13:39,250 --> 00:13:44,050
making lots of requests until the bucket

00:13:41,860 --> 00:13:46,330
is empty and once the bucket is empty

00:13:44,050 --> 00:13:50,350
you can't make any more requests you're

00:13:46,330 --> 00:13:51,700
right limited but to mean so to ensure

00:13:50,350 --> 00:13:54,880
that the bucket doesn't ever run out

00:13:51,700 --> 00:13:57,460
permanently there's on some interval

00:13:54,880 --> 00:14:00,820
there's a new token being added to the

00:13:57,460 --> 00:14:02,320
bucket say once per second and each time

00:14:00,820 --> 00:14:04,630
a new token is added you can take the

00:14:02,320 --> 00:14:07,540
token out and make a request another one

00:14:04,630 --> 00:14:09,970
added you can take token again and if

00:14:07,540 --> 00:14:12,460
you stop making requests for a while the

00:14:09,970 --> 00:14:14,950
bucket will eventually fill up at which

00:14:12,460 --> 00:14:17,760
point new tokens that try to get added

00:14:14,950 --> 00:14:22,690
will overflow and fall out of the bucket

00:14:17,760 --> 00:14:25,690
the nice thing about this is as a

00:14:22,690 --> 00:14:29,560
legitimate user you're able to make a

00:14:25,690 --> 00:14:32,050
burst of requests for a while and and

00:14:29,560 --> 00:14:34,480
not have any rate limiting but if you go

00:14:32,050 --> 00:14:37,600
over that rate limiting over that rate

00:14:34,480 --> 00:14:38,830
limit then yes you get rate limited but

00:14:37,600 --> 00:14:40,390
only for the minimum amount of time

00:14:38,830 --> 00:14:42,760
before it's okay to make the next

00:14:40,390 --> 00:14:44,260
request so as a malicious user long term

00:14:42,760 --> 00:14:45,850
you're only going to be able to make

00:14:44,260 --> 00:14:48,040
requests at the level of the interval

00:14:45,850 --> 00:14:50,500
but as a legitimate user you can have

00:14:48,040 --> 00:14:53,460
bursty traffic and generally not be

00:14:50,500 --> 00:14:58,000
waiting too long for the next request

00:14:53,460 --> 00:14:59,890
now how am i doing for time I've got a

00:14:58,000 --> 00:15:01,030
few slides on implementing this I'm

00:14:59,890 --> 00:15:02,530
gonna try and run through these very

00:15:01,030 --> 00:15:04,030
quickly there's a lot of code but the

00:15:02,530 --> 00:15:04,900
slides will definitely be available so

00:15:04,030 --> 00:15:08,710
if you want to look at this in more

00:15:04,900 --> 00:15:10,930
detail you can so to implement token

00:15:08,710 --> 00:15:13,600
bucket rate-limiting the first thing we

00:15:10,930 --> 00:15:14,920
have is an update function we take the

00:15:13,600 --> 00:15:16,690
number of counts that are currently in

00:15:14,920 --> 00:15:18,430
the that we're in the bucket at some

00:15:16,690 --> 00:15:19,750
given time stamp in the pot and this

00:15:18,430 --> 00:15:22,030
time stamp could be in the past or in

00:15:19,750 --> 00:15:23,830
the future and the settings for the

00:15:22,030 --> 00:15:25,240
bucket which are the interval at which a

00:15:23,830 --> 00:15:31,270
token gets added and the buckets

00:15:25,240 --> 00:15:32,209
capacity we increase we figure out how

00:15:31,270 --> 00:15:34,220
many

00:15:32,209 --> 00:15:36,679
Coons should have been added to the

00:15:34,220 --> 00:15:38,860
bucket since the timestamp at which we

00:15:36,679 --> 00:15:41,569
knew how many tokens were in the bucket

00:15:38,860 --> 00:15:43,490
which gives us the new token count which

00:15:41,569 --> 00:15:45,980
is the minimum of the maximum capacity

00:15:43,490 --> 00:15:50,110
and the old quantity of tokens in the

00:15:45,980 --> 00:15:53,420
bucket plus the increase we then have

00:15:50,110 --> 00:15:55,129
the new timestamp which is not

00:15:53,420 --> 00:15:56,509
necessarily the current timestamp shows

00:15:55,129 --> 00:15:58,850
the current timestamp if the bucket

00:15:56,509 --> 00:16:00,470
would be overflowing but it's all a

00:15:58,850 --> 00:16:04,459
little bit of time in the past

00:16:00,470 --> 00:16:05,869
potentially if we in it's in that it's

00:16:04,459 --> 00:16:09,619
the point at which the last token was

00:16:05,869 --> 00:16:11,240
added if the bucket is not full this

00:16:09,619 --> 00:16:12,980
gives us a new token count or a new

00:16:11,240 --> 00:16:15,769
timestamp that effectively normalizes

00:16:12,980 --> 00:16:18,100
the state of the bucket we then have a

00:16:15,769 --> 00:16:22,360
function to take a token from a bucket

00:16:18,100 --> 00:16:26,839
that first calls our update bucket state

00:16:22,360 --> 00:16:28,189
two to add any more tokens that should

00:16:26,839 --> 00:16:30,559
have been added to the bucket since we

00:16:28,189 --> 00:16:33,980
last took a token and then if the token

00:16:30,559 --> 00:16:36,679
count is greater than zero and the

00:16:33,980 --> 00:16:38,809
timestamp is in the past then we can

00:16:36,679 --> 00:16:41,869
take a token out and not change the

00:16:38,809 --> 00:16:45,769
timestamp and in this situation the

00:16:41,869 --> 00:16:49,309
request can happen immediately if the

00:16:45,769 --> 00:16:51,290
token count is zero then we can keep the

00:16:49,309 --> 00:16:54,529
token count at zero and increment the

00:16:51,290 --> 00:16:56,990
timestamp by the interval effectively

00:16:54,529 --> 00:16:58,399
set the timestamp to a time in the

00:16:56,990 --> 00:17:03,740
future when the number of tokens will be

00:16:58,399 --> 00:17:05,209
zero and then to use this we simply you

00:17:03,740 --> 00:17:08,029
know get the current state of the rate

00:17:05,209 --> 00:17:11,480
limit take a token out of the bucket and

00:17:08,029 --> 00:17:15,409
then update the state in the database

00:17:11,480 --> 00:17:22,220
and then wait for that timestamp to be

00:17:15,409 --> 00:17:24,980
in the past exponential delay is even

00:17:22,220 --> 00:17:26,720
simpler so simply track how many

00:17:24,980 --> 00:17:31,130
attempts there have been that gives you

00:17:26,720 --> 00:17:33,649
the delay per attempt which is the base

00:17:31,130 --> 00:17:37,730
delay times some factor to the power of

00:17:33,649 --> 00:17:42,470
the number of attempts and then again to

00:17:37,730 --> 00:17:46,080
take a token we increment the attempt

00:17:42,470 --> 00:17:49,460
number and the timestamp

00:17:46,080 --> 00:17:52,559
is the the old timestamp plus the the

00:17:49,460 --> 00:17:55,980
delay for the next attempt and then we

00:17:52,559 --> 00:17:57,779
can use it in the same way the neat

00:17:55,980 --> 00:17:59,279
thing about both of these and the reason

00:17:57,779 --> 00:18:02,730
I did put the implementations on the

00:17:59,279 --> 00:18:04,169
slides there is for both of these you

00:18:02,730 --> 00:18:08,850
actually are left with just two numbers

00:18:04,169 --> 00:18:11,010
to store per rate-limiting ID so if it's

00:18:08,850 --> 00:18:12,269
accounts if it's a count based rate

00:18:11,010 --> 00:18:14,580
limiting you've got two numbers per

00:18:12,269 --> 00:18:16,049
account if you want to do IP based rate

00:18:14,580 --> 00:18:19,169
limiting you're storing two numbers per

00:18:16,049 --> 00:18:21,120
IP address so for exponential delay it's

00:18:19,169 --> 00:18:23,519
the timestamp of the last attempt and

00:18:21,120 --> 00:18:26,669
the number of attempts number of failed

00:18:23,519 --> 00:18:29,010
attempts that you're storing and for

00:18:26,669 --> 00:18:31,350
token bucket rate limiting it is the

00:18:29,010 --> 00:18:33,419
timestamp when the token count was last

00:18:31,350 --> 00:18:37,830
updated and the number of tokens

00:18:33,419 --> 00:18:39,720
currently in the bucket if you want to

00:18:37,830 --> 00:18:41,700
use these two approaches to rate

00:18:39,720 --> 00:18:45,269
limiting they are both wrapped up neatly

00:18:41,700 --> 00:18:46,649
in at authentication / rate limit ready

00:18:45,269 --> 00:18:49,620
to ready to be used

00:18:46,649 --> 00:18:51,059
and they're simple standalone

00:18:49,620 --> 00:18:52,980
implementation so you can use them

00:18:51,059 --> 00:18:56,039
regardless of what frameworks and what

00:18:52,980 --> 00:18:57,659
have you are using I said I was going to

00:18:56,039 --> 00:19:01,309
talk about session storage as a way of

00:18:57,659 --> 00:19:03,360
avoiding cross-site request forgery

00:19:01,309 --> 00:19:07,559
quick summary of cross-site request

00:19:03,360 --> 00:19:10,740
forgery a user authenticates with a good

00:19:07,559 --> 00:19:11,880
website which sets a cookie on their

00:19:10,740 --> 00:19:14,570
browser

00:19:11,880 --> 00:19:17,510
they are then tricked into visiting a

00:19:14,570 --> 00:19:19,649
hackers website a malicious website

00:19:17,510 --> 00:19:22,559
usually to see some good pictures of

00:19:19,649 --> 00:19:24,960
cats or something like that the hackers

00:19:22,559 --> 00:19:28,049
website tricks them into tricks their

00:19:24,960 --> 00:19:30,870
browser into making a request to the

00:19:28,049 --> 00:19:32,700
good site and their browser foolishly

00:19:30,870 --> 00:19:34,470
sends the same cookie that it would

00:19:32,700 --> 00:19:39,929
normally sent at a good site along with

00:19:34,470 --> 00:19:42,380
that request so the good site sees a

00:19:39,929 --> 00:19:44,159
request with an authentication

00:19:42,380 --> 00:19:46,950
authenticated session stored in the

00:19:44,159 --> 00:19:50,120
cookie and goes okay that's this user I

00:19:46,950 --> 00:19:52,950
trust them they can perform this action

00:19:50,120 --> 00:19:55,500
the this is where I come back to that

00:19:52,950 --> 00:19:57,899
thing about defaults and secure defaults

00:19:55,500 --> 00:19:59,050
the cookie NPM package does a great job

00:19:57,899 --> 00:20:01,809
of implement

00:19:59,050 --> 00:20:03,490
handling of parsing and and and writing

00:20:01,809 --> 00:20:06,850
headers for cookies and it's therefore

00:20:03,490 --> 00:20:09,610
incredibly popular but it has these

00:20:06,850 --> 00:20:14,710
three options which really frustrate me

00:20:09,610 --> 00:20:16,120
so HTTP only which has the words HTTP in

00:20:14,710 --> 00:20:19,059
it because they've copied it direct from

00:20:16,120 --> 00:20:21,700
the spec but actually that's not saying

00:20:19,059 --> 00:20:24,490
don't use this on HTTP that's saying

00:20:21,700 --> 00:20:25,809
don't access this from JavaScript and it

00:20:24,490 --> 00:20:27,220
defaults to false which is the least

00:20:25,809 --> 00:20:31,000
secure of the two options it could be

00:20:27,220 --> 00:20:32,740
set to same site which would prevent

00:20:31,000 --> 00:20:35,470
cross-site request forgery in modern

00:20:32,740 --> 00:20:37,390
browsers defaults to false that's the

00:20:35,470 --> 00:20:41,620
least secure option it could default to

00:20:37,390 --> 00:20:44,770
and secure which requires it to be HTTPS

00:20:41,620 --> 00:20:48,100
and not HTTP again defaults to false

00:20:44,770 --> 00:20:50,080
which is the least secure option so this

00:20:48,100 --> 00:20:51,880
really frustrates me yeah if there are

00:20:50,080 --> 00:20:54,700
reasons why you might want to turn all

00:20:51,880 --> 00:20:56,290
three of these off but there is no

00:20:54,700 --> 00:21:00,280
reason why off should be the default

00:20:56,290 --> 00:21:03,070
threat any of these three I mentioned

00:21:00,280 --> 00:21:06,340
same site policy as a thing that

00:21:03,070 --> 00:21:07,660
prevents CSRF in modern browsers these

00:21:06,340 --> 00:21:10,900
are the modern browsers that I'm talking

00:21:07,660 --> 00:21:12,370
about as of I created this slide about a

00:21:10,900 --> 00:21:19,179
month ago so it could already be out of

00:21:12,370 --> 00:21:22,210
date but partial support there is pretty

00:21:19,179 --> 00:21:23,740
close to happening and then across most

00:21:22,210 --> 00:21:31,330
of the other browsers actually it's it's

00:21:23,740 --> 00:21:32,770
there so the cookie package instead of

00:21:31,330 --> 00:21:34,990
that you could use that authentication

00:21:32,770 --> 00:21:37,210
slash cookie which has secure defaults

00:21:34,990 --> 00:21:40,179
and the other thing it does is polyfill

00:21:37,210 --> 00:21:42,040
the same site policy pala fine poly

00:21:40,179 --> 00:21:43,480
filling the same site policy is actually

00:21:42,040 --> 00:21:45,820
pretty easy because you can just look at

00:21:43,480 --> 00:21:48,580
the headers that the request is sent

00:21:45,820 --> 00:21:52,420
from and see where it was coming from

00:21:48,580 --> 00:21:54,220
where it's going to the other thing it

00:21:52,420 --> 00:21:57,520
does is signing an encryption so by

00:21:54,220 --> 00:22:00,010
default the user can see and edit any

00:21:57,520 --> 00:22:03,910
state you put in cookies so you have to

00:22:00,010 --> 00:22:06,550
be very careful with that this comes

00:22:03,910 --> 00:22:08,380
from NPM having this sort of small

00:22:06,550 --> 00:22:09,820
modules philosophy all right node rather

00:22:08,380 --> 00:22:11,260
having this small modules philosophy

00:22:09,820 --> 00:22:12,350
each thing does one thing and does it

00:22:11,260 --> 00:22:14,510
well

00:22:12,350 --> 00:22:17,090
which is great for reusability of

00:22:14,510 --> 00:22:20,780
software and is I think a big part of

00:22:17,090 --> 00:22:24,770
why node as an ecosystem has thrived but

00:22:20,780 --> 00:22:26,960
it can be bad for security because a lot

00:22:24,770 --> 00:22:28,970
of libraries say ah we do this one thing

00:22:26,960 --> 00:22:31,789
we do it well and it's like well yes

00:22:28,970 --> 00:22:33,230
except everyone that uses this all also

00:22:31,789 --> 00:22:36,530
needs to implement these other four

00:22:33,230 --> 00:22:38,539
things in order to use it securely if

00:22:36,530 --> 00:22:40,400
you use cookie session which is probably

00:22:38,539 --> 00:22:42,470
the most popular way of using cookie

00:22:40,400 --> 00:22:44,630
there's at authentication slash cookie

00:22:42,470 --> 00:22:48,380
session which has an exact API

00:22:44,630 --> 00:22:51,140
compatible implementation of cookie

00:22:48,380 --> 00:22:53,120
session but with better signing and

00:22:51,140 --> 00:22:54,919
encryption and secure defaults for

00:22:53,120 --> 00:22:57,049
things like same site policies and all

00:22:54,919 --> 00:22:58,580
the polyfills nice to it the last thing

00:22:57,049 --> 00:23:00,799
I said I was going to talk about is SQL

00:22:58,580 --> 00:23:03,940
injection so the problem with SQL

00:23:00,799 --> 00:23:07,340
injection comes from SQL mixed with

00:23:03,940 --> 00:23:08,990
mixing both data and code if anyone

00:23:07,340 --> 00:23:10,549
thinks this isn't still a problem

00:23:08,990 --> 00:23:13,970
I encourage you to check out Stack

00:23:10,549 --> 00:23:18,860
Overflow say the 8 most recent SQL

00:23:13,970 --> 00:23:20,299
related questions and answers' a quick

00:23:18,860 --> 00:23:22,400
summary then of the problem imagine

00:23:20,299 --> 00:23:24,679
you've written this code in certain two

00:23:22,400 --> 00:23:27,650
posts the body and the author the author

00:23:24,679 --> 00:23:31,190
is presumably your authenticated user

00:23:27,650 --> 00:23:32,870
their username and the body is the

00:23:31,190 --> 00:23:38,059
content of the message that they would

00:23:32,870 --> 00:23:40,549
like to post the where you might naively

00:23:38,059 --> 00:23:42,710
turn this into code is to say well I've

00:23:40,549 --> 00:23:44,510
got the the SQL and then here are my two

00:23:42,710 --> 00:23:47,900
bits of data so I'll concatenate this

00:23:44,510 --> 00:23:49,610
string together the problem is that

00:23:47,900 --> 00:23:50,510
someone can create an SQL string that

00:23:49,610 --> 00:23:52,549
looks like this

00:23:50,510 --> 00:23:54,830
where that bit highlighted in green is

00:23:52,549 --> 00:23:57,169
the body of the message that they've

00:23:54,830 --> 00:23:59,419
asked to send but the SQL we end up

00:23:57,169 --> 00:24:01,970
running looks like this where what we're

00:23:59,419 --> 00:24:04,549
inserting is my post written by somebody

00:24:01,970 --> 00:24:08,480
else and then a little comment about who

00:24:04,549 --> 00:24:11,090
the original author was so the SQL

00:24:08,480 --> 00:24:13,460
server sees it like this our code

00:24:11,090 --> 00:24:16,730
intended it to be read like this with

00:24:13,460 --> 00:24:20,240
that whole thing as the body this is a

00:24:16,730 --> 00:24:22,309
really common problem one fairly

00:24:20,240 --> 00:24:25,159
foolproof solution to this is to use an

00:24:22,309 --> 00:24:26,330
ORM which stands for object relational

00:24:25,159 --> 00:24:29,420
mapping

00:24:26,330 --> 00:24:31,940
the idea here is you take your database

00:24:29,420 --> 00:24:35,420
and you generate some API that makes

00:24:31,940 --> 00:24:37,310
sense in JavaScript to use this is

00:24:35,420 --> 00:24:40,100
effective there are a few examples of

00:24:37,310 --> 00:24:41,960
the of ORM s for JavaScript and as far

00:24:40,100 --> 00:24:45,320
as I know they're all not vulnerable to

00:24:41,960 --> 00:24:47,480
any kind of SQL injection attack the

00:24:45,320 --> 00:24:49,400
problem for me though is I quite like

00:24:47,480 --> 00:24:52,340
writing SQL and the more I've written it

00:24:49,400 --> 00:24:54,790
the less painful it's become there's a

00:24:52,340 --> 00:24:57,860
lot of added power to writing actual SQL

00:24:54,790 --> 00:25:00,580
rather than using some ORM when it comes

00:24:57,860 --> 00:25:03,560
to doing things like up certs or

00:25:00,580 --> 00:25:05,200
multiple complicated joins it's really

00:25:03,560 --> 00:25:06,980
frustrating to be using an ORM and

00:25:05,200 --> 00:25:09,620
sooner or later you're going to need to

00:25:06,980 --> 00:25:11,480
drop down into actual SQL so the

00:25:09,620 --> 00:25:14,810
approach that people generally recommend

00:25:11,480 --> 00:25:20,050
for doing this is to separate your data

00:25:14,810 --> 00:25:22,490
from the code of SQL so replacing the

00:25:20,050 --> 00:25:25,280
place where my parameters are with two

00:25:22,490 --> 00:25:26,510
question marks and then in the actual

00:25:25,280 --> 00:25:28,580
JavaScript this would look something

00:25:26,510 --> 00:25:32,090
like this where I query and I pass in a

00:25:28,580 --> 00:25:34,160
string that is just the SQL and an array

00:25:32,090 --> 00:25:38,210
which is my two parameters the body and

00:25:34,160 --> 00:25:40,670
the author now this works this code is

00:25:38,210 --> 00:25:43,070
good in the sense that it is not

00:25:40,670 --> 00:25:45,350
vulnerable to SQL injection but in my

00:25:43,070 --> 00:25:49,070
opinion it is bad in that it is harder

00:25:45,350 --> 00:25:51,740
to read by a considerable margin and the

00:25:49,070 --> 00:25:53,480
more that this code grows the more of a

00:25:51,740 --> 00:25:56,210
problem that will become you know if

00:25:53,480 --> 00:25:58,970
this query was thirty lines long and

00:25:56,210 --> 00:26:01,610
there were 40 parameters at the bottom

00:25:58,970 --> 00:26:03,310
then good luck pairing up the correct

00:26:01,610 --> 00:26:07,400
parameter with the correct question mark

00:26:03,310 --> 00:26:09,500
and whilst that might not always be a

00:26:07,400 --> 00:26:12,680
security issue and it will rarely be an

00:26:09,500 --> 00:26:15,080
SQL injection issue it can still be a

00:26:12,680 --> 00:26:16,520
security issue getting parameters mixed

00:26:15,080 --> 00:26:19,060
up getting the wrong parameter in the

00:26:16,520 --> 00:26:19,060
wrong place

00:26:19,780 --> 00:26:23,030
recent versions of JavaScript actually

00:26:21,830 --> 00:26:25,580
have something which gives us a

00:26:23,030 --> 00:26:29,030
brilliant solution to this and that is

00:26:25,580 --> 00:26:30,590
tagged template literals so tag template

00:26:29,030 --> 00:26:33,350
literals let us write code that looks

00:26:30,590 --> 00:26:38,390
like this which is much closer to what

00:26:33,350 --> 00:26:40,100
the naive initial version looked like so

00:26:38,390 --> 00:26:42,590
I've got my insert in

00:26:40,100 --> 00:26:44,809
two posts body or four values and then

00:26:42,590 --> 00:26:48,020
I've got inline the body and the author

00:26:44,809 --> 00:26:50,450
parameter and all that's doing all

00:26:48,020 --> 00:26:52,400
that's needed to make this safe and make

00:26:50,450 --> 00:26:55,010
this safe from SQL injection is that

00:26:52,400 --> 00:26:56,980
little SQL before the tag template

00:26:55,010 --> 00:27:01,910
literal begins before the backticks

00:26:56,980 --> 00:27:06,280
and what that what that does is SQL gets

00:27:01,910 --> 00:27:11,270
given the raw strings of your sequel and

00:27:06,280 --> 00:27:15,049
the parameters as separate arguments to

00:27:11,270 --> 00:27:17,780
a function and it returns an SQL query

00:27:15,049 --> 00:27:19,549
instance which has separately a string

00:27:17,780 --> 00:27:23,570
with placeholders with question marks

00:27:19,549 --> 00:27:25,760
and an array of your parameters and then

00:27:23,570 --> 00:27:28,309
that gets passed to the query function

00:27:25,760 --> 00:27:31,490
now the only problem with this approach

00:27:28,309 --> 00:27:32,630
is if you forget the SQL bit then you're

00:27:31,490 --> 00:27:36,169
back to being vulnerable to SQL

00:27:32,630 --> 00:27:40,460
injection and the way to avoid that is

00:27:36,169 --> 00:27:42,320
to use a library that only supports SQL

00:27:40,460 --> 00:27:45,260
queries that have been constructed via

00:27:42,320 --> 00:27:48,289
that tags template literal so at

00:27:45,260 --> 00:27:51,289
databases /pg at databases MySQL and

00:27:48,289 --> 00:27:52,929
that databases slash SQLite are my

00:27:51,289 --> 00:27:56,240
database wrappers that I maintain that

00:27:52,929 --> 00:28:02,360
support only tags template literals as

00:27:56,240 --> 00:28:04,130
as queries and that SQL tag has all of

00:28:02,360 --> 00:28:05,480
the kind of query building functionality

00:28:04,130 --> 00:28:07,520
you would need in terms of being able to

00:28:05,480 --> 00:28:10,760
do things like join arrays of queries

00:28:07,520 --> 00:28:13,520
together to make larger queries pass

00:28:10,760 --> 00:28:16,669
identify as in as strings as parameters

00:28:13,520 --> 00:28:20,419
and it even has the ability to give you

00:28:16,669 --> 00:28:22,280
a raw string and and treat that as SQL

00:28:20,419 --> 00:28:23,929
but if you want to take a raw string and

00:28:22,280 --> 00:28:26,030
treat it as SQL with one of these

00:28:23,929 --> 00:28:28,400
libraries your code will say something

00:28:26,030 --> 00:28:30,500
along the lines of SQL Door underscore

00:28:28,400 --> 00:28:32,210
underscore dangerously use raw value

00:28:30,500 --> 00:28:34,400
underscore underscore open brackets and

00:28:32,210 --> 00:28:37,340
then the string of SQL which hopefully

00:28:34,400 --> 00:28:39,440
is enough to mean that you and anyone

00:28:37,340 --> 00:28:41,809
reviewing your code knows that you've

00:28:39,440 --> 00:28:44,179
done something dangerous and probably

00:28:41,809 --> 00:28:46,730
wrong in that location so it should get

00:28:44,179 --> 00:28:48,350
reviewed carefully every time and if

00:28:46,730 --> 00:28:50,000
there are injection SQL injection

00:28:48,350 --> 00:28:52,700
vulnerabilities in that code it should

00:28:50,000 --> 00:28:53,929
be caught and they're rare I haven't

00:28:52,700 --> 00:28:55,759
seen anybody yet with

00:28:53,929 --> 00:28:58,970
example of something where they actually

00:28:55,759 --> 00:29:01,639
needed to take that approach so that's

00:28:58,970 --> 00:29:03,460
it for what actually had to talk about I

00:29:01,639 --> 00:29:07,129
have a couple of quick things to plug

00:29:03,460 --> 00:29:10,490
firstly I work at threads and we are

00:29:07,129 --> 00:29:14,049
having a meet-up on it's got the date on

00:29:10,490 --> 00:29:16,519
there somewhere the 17th of September

00:29:14,049 --> 00:29:18,110
that is the JavaScript open source

00:29:16,519 --> 00:29:20,119
meetup so probably relevant to lots of

00:29:18,110 --> 00:29:23,240
people here and guys is going to be

00:29:20,119 --> 00:29:24,799
talking about his open source journey in

00:29:23,240 --> 00:29:30,200
general and how he got into open source

00:29:24,799 --> 00:29:32,240
and what he's taken out of it and we're

00:29:30,200 --> 00:29:34,519
hiring we're hiring node and react

00:29:32,240 --> 00:29:36,049
developers and full-stack JavaScript

00:29:34,519 --> 00:29:38,419
people in general and we do like

00:29:36,049 --> 00:29:42,049
typescript and all sorts of good modern

00:29:38,419 --> 00:29:46,340
stuff so do grab me if you're at all

00:29:42,049 --> 00:29:47,509
interested in a new job I maintain at

00:29:46,340 --> 00:29:49,850
authentication which I talked about

00:29:47,509 --> 00:29:52,460
earlier and at databases which I also

00:29:49,850 --> 00:29:53,720
talked about earlier and I have stickers

00:29:52,460 --> 00:29:56,600
as you can see on the front of my laptop

00:29:53,720 --> 00:29:58,070
and they're at the front here grab me at

00:29:56,600 --> 00:29:59,360
any point if you want a sticker and I'm

00:29:58,070 --> 00:30:00,230
also going to leave someone a table up

00:29:59,360 --> 00:30:03,289
there at some point

00:30:00,230 --> 00:30:05,029
and I also maintain pug and I also have

00:30:03,289 --> 00:30:07,639
stickers for that so if you'd like a pug

00:30:05,029 --> 00:30:11,029
sticker also grab me my twitter handle

00:30:07,639 --> 00:30:12,160
is forbes lindsay and that's all I had

00:30:11,029 --> 00:30:18,579
thank you

00:30:12,160 --> 00:30:18,579

YouTube URL: https://www.youtube.com/watch?v=IgHWp-Tkgd8


