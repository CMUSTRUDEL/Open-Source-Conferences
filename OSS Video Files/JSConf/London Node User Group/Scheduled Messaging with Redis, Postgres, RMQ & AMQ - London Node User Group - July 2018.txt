Title: Scheduled Messaging with Redis, Postgres, RMQ & AMQ - London Node User Group - July 2018
Publication date: 2018-08-03
Playlist: London Node User Group
Description: 
	Presented by Bartlomiej Specjalny.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,040
hi this gonna be talked about very

00:00:02,879 --> 00:00:07,230
tedious problem that actually have found

00:00:05,040 --> 00:00:09,690
solution last week so gonna be there's a

00:00:07,230 --> 00:00:13,019
happy end to the story scheduled

00:00:09,690 --> 00:00:16,230
messaging using credits Postgres RM Q&A

00:00:13,019 --> 00:00:18,270
mq not necessarily in this order we're

00:00:16,230 --> 00:00:20,130
going to go through it in order that I

00:00:18,270 --> 00:00:22,800
actually try to resolve the particular

00:00:20,130 --> 00:00:24,449
business problem this is like logical

00:00:22,800 --> 00:00:27,000
proposition when you actually try to

00:00:24,449 --> 00:00:28,619
create a scheduled queue but so my name

00:00:27,000 --> 00:00:32,430
is Bart and I'm a software engineer at

00:00:28,619 --> 00:00:34,140
company called Bisbee if you wanna look

00:00:32,430 --> 00:00:36,210
the source files now for this

00:00:34,140 --> 00:00:40,020
presentation there is the link if

00:00:36,210 --> 00:00:42,329
somebody is on HPC will be doing some

00:00:40,020 --> 00:00:44,969
small code stuff here as well so you'll

00:00:42,329 --> 00:00:47,489
be able to see how it works so the

00:00:44,969 --> 00:00:51,210
business case it's very simple yet very

00:00:47,489 --> 00:00:52,980
annoying you need to you have a prop

00:00:51,210 --> 00:00:57,000
tech business so somebody enters a

00:00:52,980 --> 00:01:00,059
tenancy agreement and suddenly in nine

00:00:57,000 --> 00:01:02,039
months you need to revisit his contract

00:01:00,059 --> 00:01:05,850
you need to send notifications you need

00:01:02,039 --> 00:01:08,580
to send a cleaning group like there is a

00:01:05,850 --> 00:01:13,650
lot of stuff happening but it's not

00:01:08,580 --> 00:01:16,080
immediate so I would try to of course

00:01:13,650 --> 00:01:17,640
first connects you to the queuing system

00:01:16,080 --> 00:01:21,060
that I was using on every day so it

00:01:17,640 --> 00:01:23,909
would be rmq and we'll get to that in a

00:01:21,060 --> 00:01:25,710
second but found out that is not as

00:01:23,909 --> 00:01:28,650
simple as you might think it is it

00:01:25,710 --> 00:01:31,409
should be in 2018 and it's actually

00:01:28,650 --> 00:01:34,560
quite hilarious what's the state of the

00:01:31,409 --> 00:01:37,290
technology in this manner so what is a

00:01:34,560 --> 00:01:38,759
scheduled message in this use case what

00:01:37,290 --> 00:01:41,400
it have to do so a piece of information

00:01:38,759 --> 00:01:43,979
that we can put into action our

00:01:41,400 --> 00:01:45,869
arbitrary number of time we don't want

00:01:43,979 --> 00:01:48,000
to do chrome tabs we don't want to every

00:01:45,869 --> 00:01:49,439
day to see if this is the time when we

00:01:48,000 --> 00:01:52,170
need to send a cleaning team

00:01:49,439 --> 00:01:53,880
notification we would like probably

00:01:52,170 --> 00:01:57,960
published consume behaviors to avoid

00:01:53,880 --> 00:01:59,820
Polar's respect the order but not in

00:01:57,960 --> 00:02:02,040
terms of fee for spur the order in terms

00:01:59,820 --> 00:02:04,860
of the chronology like when we set the

00:02:02,040 --> 00:02:07,409
messages in and probably at least

00:02:04,860 --> 00:02:10,099
quality of service one so we know where

00:02:07,409 --> 00:02:13,900
we actually took Fink out of killers

00:02:10,099 --> 00:02:15,610
just literally you see QoS

00:02:13,900 --> 00:02:18,549
zero one and two and this refers

00:02:15,610 --> 00:02:21,549
basically to how the acknowledgement is

00:02:18,549 --> 00:02:25,810
handle which q0 being basically no

00:02:21,549 --> 00:02:28,060
acknowledgement qsa being one being

00:02:25,810 --> 00:02:30,250
server saying hey I've seen this process

00:02:28,060 --> 00:02:32,590
we can take this Q out and Q s 2 being

00:02:30,250 --> 00:02:36,760
like a at least four messages between

00:02:32,590 --> 00:02:38,680
the server and the client so to get to

00:02:36,760 --> 00:02:41,909
the queueing we need to do think how we

00:02:38,680 --> 00:02:44,470
used to do architecture previously so we

00:02:41,909 --> 00:02:46,540
wished we started with client-server

00:02:44,470 --> 00:02:49,299
right it's like the oldest story in the

00:02:46,540 --> 00:02:52,209
world and then somebody was smart enough

00:02:49,299 --> 00:02:54,700
to say hey we can do Ajax and we started

00:02:52,209 --> 00:02:57,280
doing short pulling and stuff like this

00:02:54,700 --> 00:02:58,989
so we remember first time Facebook was

00:02:57,280 --> 00:03:02,620
on and this new chart and doing all

00:02:58,989 --> 00:03:05,620
these nice things and basically work at

00:03:02,620 --> 00:03:07,359
the time at the scales but as time

00:03:05,620 --> 00:03:08,769
progressed the scales just become

00:03:07,359 --> 00:03:11,049
unbearable to do stuff like this and

00:03:08,769 --> 00:03:13,420
then the third finger on poling who just

00:03:11,049 --> 00:03:19,150
sent a request and way too got her nose

00:03:13,420 --> 00:03:22,030
long to get requests back yeah and then

00:03:19,150 --> 00:03:24,250
we again kind of rediscovered sockets

00:03:22,030 --> 00:03:26,859
and we can do this in the browser so we

00:03:24,250 --> 00:03:29,590
can send stuff in send stuff out cost

00:03:26,859 --> 00:03:31,060
only one HTTP frame and then we can

00:03:29,590 --> 00:03:34,209
broadcast stuff and it's like whoa

00:03:31,060 --> 00:03:36,780
groundbreaking provide back again we are

00:03:34,209 --> 00:03:38,949
sending messages on the sockets and

00:03:36,780 --> 00:03:41,889
straight after that we went to into

00:03:38,949 --> 00:03:44,709
micro services and we wait we went there

00:03:41,889 --> 00:03:47,349
usually with like idea that yeah let's

00:03:44,709 --> 00:03:50,049
do this interest this is this in crud

00:03:47,349 --> 00:03:52,209
let's do eleven waterfalls calls and

00:03:50,049 --> 00:03:54,970
let's hope something not break because

00:03:52,209 --> 00:03:56,500
if it breaks you don't know where you

00:03:54,970 --> 00:03:58,629
are on me know where you are but you

00:03:56,500 --> 00:04:03,220
were trying the same request basically

00:03:58,629 --> 00:04:04,959
not ever clearing your memory and just

00:04:03,220 --> 00:04:07,540
using your resources there's the very

00:04:04,959 --> 00:04:10,989
smart way to do so a logical progression

00:04:07,540 --> 00:04:14,139
from this was to introduce idea of a

00:04:10,989 --> 00:04:15,940
queue which would be separate service

00:04:14,139 --> 00:04:18,489
that basically you would take your

00:04:15,940 --> 00:04:20,940
message in and then when somebody wants

00:04:18,489 --> 00:04:24,550
to read it to take this message out

00:04:20,940 --> 00:04:26,349
persist failover load balance all of

00:04:24,550 --> 00:04:27,430
this stuff that we previously have to

00:04:26,349 --> 00:04:29,229
think about it when the

00:04:27,430 --> 00:04:33,720
sighing car collector kindly kind of

00:04:29,229 --> 00:04:38,699
went away what went away also was or

00:04:33,720 --> 00:04:38,699
actually changed a bit of paradigm was

00:04:38,759 --> 00:04:45,160
the way you think about asking like we

00:04:42,610 --> 00:04:47,139
in JavaScript we are actually quite good

00:04:45,160 --> 00:04:49,570
in a sink like the way of thinking about

00:04:47,139 --> 00:04:52,090
parallel not ideally because we always

00:04:49,570 --> 00:04:53,680
usually on one fret hands up if

00:04:52,090 --> 00:04:57,460
somebody's doing here like a parallel

00:04:53,680 --> 00:05:00,580
workers in note no nobody's doing

00:04:57,460 --> 00:05:01,570
parallel processing cool so we are quite

00:05:00,580 --> 00:05:04,270
good at it

00:05:01,570 --> 00:05:06,550
to certain degree like if you come to

00:05:04,270 --> 00:05:09,220
like to asking from different languages

00:05:06,550 --> 00:05:13,120
it's it's much harder but what's

00:05:09,220 --> 00:05:14,770
happened here is it actually have

00:05:13,120 --> 00:05:17,020
another dimension because at this point

00:05:14,770 --> 00:05:18,699
you there is no like you know even loop

00:05:17,020 --> 00:05:20,259
chronology you don't know what's

00:05:18,699 --> 00:05:21,759
happening in other services you need to

00:05:20,259 --> 00:05:24,849
think about your architecture bit

00:05:21,759 --> 00:05:26,949
differently and yeah so what you need

00:05:24,849 --> 00:05:29,050
for as I said for the simplest queueing

00:05:26,949 --> 00:05:30,910
system some network implementations so

00:05:29,050 --> 00:05:34,889
the way to actually speak with a mover

00:05:30,910 --> 00:05:38,560
server some way of storing the messages

00:05:34,889 --> 00:05:40,360
ordering them routing and the next

00:05:38,560 --> 00:05:42,669
progression in those systems was

00:05:40,360 --> 00:05:45,820
actually creating exchanges would

00:05:42,669 --> 00:05:48,159
actually be the routing part so you can

00:05:45,820 --> 00:05:50,050
offload the queue in the in the time and

00:05:48,159 --> 00:05:53,349
manner that you think it's all rights

00:05:50,050 --> 00:05:56,169
and basically do the do everything you

00:05:53,349 --> 00:05:58,419
want with it without actually having to

00:05:56,169 --> 00:06:01,240
put too much thought on how it works in

00:05:58,419 --> 00:06:03,039
a broader sense out-of-the-box solution

00:06:01,240 --> 00:06:03,810
for things that is actually quite

00:06:03,039 --> 00:06:06,430
complex

00:06:03,810 --> 00:06:11,470
so here be dragons we are approaching

00:06:06,430 --> 00:06:14,560
the first set of problems which is try

00:06:11,470 --> 00:06:19,389
to put the damn notification in in a few

00:06:14,560 --> 00:06:23,139
seconds instead of now rabbit and q1 I

00:06:19,389 --> 00:06:25,840
think the most popular clients still if

00:06:23,139 --> 00:06:30,639
you check the NPM it has the the library

00:06:25,840 --> 00:06:32,909
the AMQP lib has six hundred thousand

00:06:30,639 --> 00:06:35,229
downloads every week something like this

00:06:32,909 --> 00:06:38,289
not something like jQuery this has four

00:06:35,229 --> 00:06:40,750
millions but getting their basic quite

00:06:38,289 --> 00:06:44,680
solved piece of software and

00:06:40,750 --> 00:06:47,500
quite reliable but completely but for

00:06:44,680 --> 00:06:49,600
this case and I don't know like I tried

00:06:47,500 --> 00:06:51,340
talking with them and they just they

00:06:49,600 --> 00:06:52,870
think their architecture is perfect and

00:06:51,340 --> 00:06:56,460
I'll show you why in a second why it's

00:06:52,870 --> 00:06:59,740
not so there are two ways to basically

00:06:56,460 --> 00:07:02,140
do this there is a dead-letter exchange

00:06:59,740 --> 00:07:05,380
so what exchanges are as I told you it

00:07:02,140 --> 00:07:07,030
is basically like a extra abstraction

00:07:05,380 --> 00:07:10,990
over the queueing itself over routing

00:07:07,030 --> 00:07:13,150
and what data exchange is means in our

00:07:10,990 --> 00:07:15,640
case will be were message times out on

00:07:13,150 --> 00:07:18,270
one of the queues it's automatically put

00:07:15,640 --> 00:07:21,940
to the other and this was basically the

00:07:18,270 --> 00:07:24,310
the first way that are the people for

00:07:21,940 --> 00:07:26,230
rabbits and he actually advise you to do

00:07:24,310 --> 00:07:28,860
this and the agar the other was a

00:07:26,230 --> 00:07:32,260
plug-in that basically has his own

00:07:28,860 --> 00:07:34,810
implementation of some indexing and when

00:07:32,260 --> 00:07:36,460
I was actually reading at the time the

00:07:34,810 --> 00:07:38,200
information about it you would see that

00:07:36,460 --> 00:07:39,970
some people were complaining for example

00:07:38,200 --> 00:07:42,010
when they would purge the cute messages

00:07:39,970 --> 00:07:44,410
who were still appearing so it's not

00:07:42,010 --> 00:07:46,090
really a nice thing in such a system you

00:07:44,410 --> 00:07:50,620
would expect it to kind of work out of

00:07:46,090 --> 00:07:59,260
the box yeah we can go to the first demo

00:07:50,620 --> 00:08:03,120
now with the rabbit in here who I'm

00:07:59,260 --> 00:08:08,350
using typescript for last four years

00:08:03,120 --> 00:08:10,300
helpful limits errors it's that the

00:08:08,350 --> 00:08:12,820
types of course are only one level of

00:08:10,300 --> 00:08:14,590
translations of the checks is there it's

00:08:12,820 --> 00:08:17,650
not not mutable but if you go with like

00:08:14,590 --> 00:08:19,570
protobuf afterwards with connection with

00:08:17,650 --> 00:08:23,590
withdraw group you can get actually like

00:08:19,570 --> 00:08:25,960
mutable structures so the case we're

00:08:23,590 --> 00:08:28,720
gonna change it a bit so let's comment

00:08:25,960 --> 00:08:33,150
this stuff out for now this is actually

00:08:28,720 --> 00:08:33,150
the error case and let's go with

00:08:33,570 --> 00:08:40,390
something really simple right so I'm

00:08:37,000 --> 00:08:43,330
scheduling one message maybe before even

00:08:40,390 --> 00:08:45,940
we go there so what's happening here I

00:08:43,330 --> 00:08:48,520
have derived classes with publisher and

00:08:45,940 --> 00:08:50,560
subscribers this is like a small

00:08:48,520 --> 00:08:51,880
wrappers over there and cue really that

00:08:50,560 --> 00:08:55,389
allows you to just put to multiple

00:08:51,880 --> 00:08:59,240
queues we can we can view them

00:08:55,389 --> 00:09:01,730
basically get config in connect create a

00:08:59,240 --> 00:09:03,170
channel assert a queue

00:09:01,730 --> 00:09:05,660
who gets to assert what's what is

00:09:03,170 --> 00:09:07,810
missing a second basically just a bit of

00:09:05,660 --> 00:09:10,370
infrastructure for you to be able to

00:09:07,810 --> 00:09:14,959
basically do this instead of having to

00:09:10,370 --> 00:09:18,350
worry how it works so why there is this

00:09:14,959 --> 00:09:21,319
conditional attached and and attach

00:09:18,350 --> 00:09:24,259
exchange here idea is that basically

00:09:21,319 --> 00:09:26,329
you're recreating if somebody goes to

00:09:24,259 --> 00:09:27,560
our mq and just flashes it and goes to

00:09:26,329 --> 00:09:29,870
your queue and purchase it and

00:09:27,560 --> 00:09:32,300
disappears the idea is that you create

00:09:29,870 --> 00:09:36,410
from the code also if there's an other

00:09:32,300 --> 00:09:38,240
service using the same queue if you give

00:09:36,410 --> 00:09:41,230
it a different set of settings it will

00:09:38,240 --> 00:09:43,819
alarm somebody it will crush will say hi

00:09:41,230 --> 00:09:48,740
this queue was supposed to durable but

00:09:43,819 --> 00:09:52,579
it's not and if you look at test 1 which

00:09:48,740 --> 00:09:55,759
are the queues so you see it's basically

00:09:52,579 --> 00:09:59,569
saying it's work exchange that is

00:09:55,759 --> 00:10:01,639
described below and to use routing here

00:09:59,569 --> 00:10:04,910
key one if something goes wrong and the

00:10:01,639 --> 00:10:07,720
maxis priority is 10 then you have the

00:10:04,910 --> 00:10:11,810
test two and then you have the actual

00:10:07,720 --> 00:10:15,170
exchange that says basically the routing

00:10:11,810 --> 00:10:18,350
key key one is just do so without

00:10:15,170 --> 00:10:21,110
further ado let's go of this so we sent

00:10:18,350 --> 00:10:23,480
the queue I sent some messages before so

00:10:21,110 --> 00:10:25,040
they just came in so after more or less

00:10:23,480 --> 00:10:29,269
than seconds the message should appear

00:10:25,040 --> 00:10:32,630
in the console that yeah some other

00:10:29,269 --> 00:10:36,230
stuff it's not safe that's why okay

00:10:32,630 --> 00:10:38,990
we're starting I mean just testing this

00:10:36,230 --> 00:10:42,230
like because those libraries are

00:10:38,990 --> 00:10:44,329
basically extracted for some of my

00:10:42,230 --> 00:10:48,110
products like from different places so

00:10:44,329 --> 00:10:51,560
just to make sure it works so yeah and

00:10:48,110 --> 00:10:54,410
this basically was the message that we

00:10:51,560 --> 00:10:59,630
described here so it took 10 seconds for

00:10:54,410 --> 00:11:04,160
it if you would look at not here if you

00:10:59,630 --> 00:11:07,269
would look at the day to day what's

00:11:04,160 --> 00:11:09,020
happening in rabbit and queue overview

00:11:07,269 --> 00:11:11,630
why not

00:11:09,020 --> 00:11:14,930
because it's just in seconds like

00:11:11,630 --> 00:11:20,110
strangest queues if you look at the

00:11:14,930 --> 00:11:20,110
queue let's restart it

00:11:26,930 --> 00:11:30,080
come on

00:11:31,330 --> 00:11:34,959
it's really taken down but based

00:11:33,040 --> 00:11:36,790
basically this appears here you can see

00:11:34,959 --> 00:11:39,370
this is moving from one queue to another

00:11:36,790 --> 00:11:41,260
base taking from the top of the stack if

00:11:39,370 --> 00:11:45,430
it's expired moving to the other right

00:11:41,260 --> 00:11:51,040
so seems like it works till now now we

00:11:45,430 --> 00:11:55,540
do something more fancy so we sent those

00:11:51,040 --> 00:11:58,089
messages like this which first is how do

00:11:55,540 --> 00:12:01,060
you expect they should come back is the

00:11:58,089 --> 00:12:04,450
question the first one delay is 10

00:12:01,060 --> 00:12:08,290
seconds the other delays 8 3 1 4 and the

00:12:04,450 --> 00:12:10,720
last one is 1 would you expect should

00:12:08,290 --> 00:12:13,480
have before you should happen if you do

00:12:10,720 --> 00:12:16,120
stuff like this well you kind of have

00:12:13,480 --> 00:12:18,850
your answer about you need to kind of

00:12:16,120 --> 00:12:20,860
look and focus what's happening so I

00:12:18,850 --> 00:12:23,410
just restarted it it sent three messages

00:12:20,860 --> 00:12:27,990
first one is supposed to timeout after 1

00:12:23,410 --> 00:12:31,810
seconds but nothing is happening and

00:12:27,990 --> 00:12:33,430
suddenly they all come they all come in

00:12:31,810 --> 00:12:35,940
a completely different order that you

00:12:33,430 --> 00:12:39,180
expect them to come and why is that

00:12:35,940 --> 00:12:43,570
orangey the way rmq basically implements

00:12:39,180 --> 00:12:45,880
the queues if the item is not like

00:12:43,570 --> 00:12:48,339
touched from the top of the stack from

00:12:45,880 --> 00:12:50,500
the last item in the queue it will not

00:12:48,339 --> 00:12:52,660
do anything with it so when we first

00:12:50,500 --> 00:12:55,329
send the item that has to wait 10

00:12:52,660 --> 00:12:59,140
seconds everything behind basically is

00:12:55,329 --> 00:13:01,300
waiting kinda I can't go with the

00:12:59,140 --> 00:13:02,950
business case exists because if you send

00:13:01,300 --> 00:13:04,660
something half a year in advance

00:13:02,950 --> 00:13:06,930
it would just be stuck there forever and

00:13:04,660 --> 00:13:09,130
you won't ever do anything with it

00:13:06,930 --> 00:13:11,440
sucks right

00:13:09,130 --> 00:13:14,130
you can play with priorities I was going

00:13:11,440 --> 00:13:17,860
to but I don't think I will have time so

00:13:14,130 --> 00:13:20,529
priorities in rmq when you look at what

00:13:17,860 --> 00:13:22,270
priorities are and how they are

00:13:20,529 --> 00:13:24,370
described in the article documentation

00:13:22,270 --> 00:13:27,820
it looks like a leaflet of a really bad

00:13:24,370 --> 00:13:29,589
drug like there is so many things to not

00:13:27,820 --> 00:13:31,300
to do and why not to do that you

00:13:29,589 --> 00:13:31,839
basically feel like you shouldn't even

00:13:31,300 --> 00:13:35,709
touch it

00:13:31,839 --> 00:13:38,709
there's limitation of 256 priority

00:13:35,709 --> 00:13:40,779
levels every priority kinda creates its

00:13:38,709 --> 00:13:43,720
internal cue and there is meeting the

00:13:40,779 --> 00:13:44,860
memory limitation and thing goes on and

00:13:43,720 --> 00:13:47,110
on and on

00:13:44,860 --> 00:13:49,930
and to tell the truth it still doesn't

00:13:47,110 --> 00:13:51,850
solve the fact that if you if you're

00:13:49,930 --> 00:13:53,410
stuck on the first elements you just

00:13:51,850 --> 00:13:57,670
basically gonna be stuck there until it

00:13:53,410 --> 00:13:59,590
pops out so rmq is not a tool for the

00:13:57,670 --> 00:14:01,660
job and at the time when I was checking

00:13:59,590 --> 00:14:03,630
everything actually there wasn't

00:14:01,660 --> 00:14:06,760
anything good and this was kind of

00:14:03,630 --> 00:14:09,490
mind-boggling that you use Google as

00:14:06,760 --> 00:14:11,110
like overflow and it's like yeah just go

00:14:09,490 --> 00:14:13,420
to cough can do your own consumer and

00:14:11,110 --> 00:14:16,390
stuff like this but it's like guys this

00:14:13,420 --> 00:14:18,370
is a very simple problem like and you

00:14:16,390 --> 00:14:20,920
would watch actually like Google and big

00:14:18,370 --> 00:14:23,550
guys saying oh yeah we do basically this

00:14:20,920 --> 00:14:25,960
post rest here and there and it's like

00:14:23,550 --> 00:14:28,780
2018 we shouldn't be doing stuff like

00:14:25,960 --> 00:14:32,890
this manually it's it's just ridiculous

00:14:28,780 --> 00:14:34,480
so this was me at the time so but what

00:14:32,890 --> 00:14:36,640
we get with rmq because this is the

00:14:34,480 --> 00:14:38,470
point we got we gotta we avoiding the

00:14:36,640 --> 00:14:41,350
chrome right it's like you we have

00:14:38,470 --> 00:14:44,470
published consumed completely breakdown

00:14:41,350 --> 00:14:46,930
if you do if you do the order what is

00:14:44,470 --> 00:14:49,420
interesting if the delays are the same

00:14:46,930 --> 00:14:51,400
the same amount of time you two of

00:14:49,420 --> 00:14:53,590
course will work but as soon as you have

00:14:51,400 --> 00:14:56,140
like a different amount of times on the

00:14:53,590 --> 00:14:58,120
queue completely breaks down confirm or

00:14:56,140 --> 00:15:01,030
prefetch works prefetch means how many

00:14:58,120 --> 00:15:03,220
you're telling to the to the broker how

00:15:01,030 --> 00:15:04,570
many you want items receive from the

00:15:03,220 --> 00:15:07,570
queue at the same time so can process

00:15:04,570 --> 00:15:10,840
ten in your one worker multiple

00:15:07,570 --> 00:15:13,000
consumers avoiding polling of course can

00:15:10,840 --> 00:15:14,710
store data persistently arm Hiro allows

00:15:13,000 --> 00:15:16,870
you to like two gigabyte messages if

00:15:14,710 --> 00:15:20,940
you're crazy enough to do this out of

00:15:16,870 --> 00:15:24,520
the book rep Lucas priority sucks

00:15:20,940 --> 00:15:31,540
indexing methods well it kind of goes

00:15:24,520 --> 00:15:33,070
with priorities really so yeah as I said

00:15:31,540 --> 00:15:35,530
this is like the biggest the biggest

00:15:33,070 --> 00:15:37,390
imitation of it it's like the way it's

00:15:35,530 --> 00:15:41,140
internally implemented and it's unlikely

00:15:37,390 --> 00:15:43,540
to change so what do software engineer

00:15:41,140 --> 00:15:45,970
do and he just finds problem that's

00:15:43,540 --> 00:15:49,360
nobody done this right it's like Fink's

00:15:45,970 --> 00:15:53,350
oh let's go bro Freddy's so anybody use

00:15:49,360 --> 00:15:55,660
Redis most of the guys nice piece of

00:15:53,350 --> 00:15:57,059
software in store key value with

00:15:55,660 --> 00:16:01,549
persistence

00:15:57,059 --> 00:16:04,469
the cassettes features features features

00:16:01,549 --> 00:16:07,669
what I used for this is 0 inch and 0 M

00:16:04,469 --> 00:16:12,209
so basically we have we have indexed

00:16:07,669 --> 00:16:15,539
range of objects where the int that is a

00:16:12,209 --> 00:16:17,399
timestamp is basically deciding on the

00:16:15,539 --> 00:16:20,789
order and then 0 m to actually do the

00:16:17,399 --> 00:16:22,919
acknowledge to remove stuff from this if

00:16:20,789 --> 00:16:28,379
you want to see the demo its der we will

00:16:22,919 --> 00:16:33,179
just prove that it works so if you look

00:16:28,379 --> 00:16:38,819
at the Redis basically the same stuff 20

00:16:33,179 --> 00:16:41,009
seconds delight 10 seconds delay first

00:16:38,819 --> 00:16:42,389
message that came message to so the

00:16:41,009 --> 00:16:45,109
message that was 10 seconds the other

00:16:42,389 --> 00:16:49,409
message will come in the message with

00:16:45,109 --> 00:16:50,969
woof 2012 20 seconds nice right so

00:16:49,409 --> 00:16:53,519
basically we solve the problem well not

00:16:50,969 --> 00:16:57,359
really and I think it's all nothing is

00:16:53,519 --> 00:17:00,989
that simple so what happens is let's

00:16:57,359 --> 00:17:06,269
starts to think about it in terms of our

00:17:00,989 --> 00:17:09,329
business go yeah we're avoiding from top

00:17:06,269 --> 00:17:12,480
as fine right we do publish consume more

00:17:09,329 --> 00:17:14,490
or less we are emulating this respect

00:17:12,480 --> 00:17:17,009
order and it's not FIFO because we have

00:17:14,490 --> 00:17:20,009
the arbitrary index we can emulate the

00:17:17,009 --> 00:17:21,539
qsr we can email with the prefetch in

00:17:20,009 --> 00:17:22,980
the working example that you have there

00:17:21,539 --> 00:17:24,360
it's only working for one consumer

00:17:22,980 --> 00:17:26,699
because I didn't bother to do

00:17:24,360 --> 00:17:28,740
transactions and stuff for business case

00:17:26,699 --> 00:17:30,419
like this if you have one consumer that

00:17:28,740 --> 00:17:32,549
uploads everything and ships its to

00:17:30,419 --> 00:17:36,029
proprietary it probably would be enough

00:17:32,549 --> 00:17:38,700
but you can do this we cannot avoid

00:17:36,029 --> 00:17:42,539
polling it's the nature of its that you

00:17:38,700 --> 00:17:45,899
can't get around polling can store data

00:17:42,539 --> 00:17:46,639
persistently for a long time well not

00:17:45,899 --> 00:17:48,809
really

00:17:46,639 --> 00:17:51,149
everything is memory so even if you

00:17:48,809 --> 00:17:53,669
persist something you the Redis crush's

00:17:51,149 --> 00:17:55,200
load up everything goes to memory it

00:17:53,669 --> 00:17:58,110
might not be problem if you're like

00:17:55,200 --> 00:18:00,539
storing IDs what if it starts start

00:17:58,110 --> 00:18:02,039
store object suddenly you're running out

00:18:00,539 --> 00:18:03,659
of room and especially if there's

00:18:02,039 --> 00:18:05,850
something else working on the on the

00:18:03,659 --> 00:18:08,759
same instance it's basically can you can

00:18:05,850 --> 00:18:10,559
kill yourself with this you have out the

00:18:08,759 --> 00:18:13,080
box replicas and

00:18:10,559 --> 00:18:15,840
no way to the priorities and indexing

00:18:13,080 --> 00:18:17,490
Polly works very nicely as I said there

00:18:15,840 --> 00:18:19,980
is very good alternative to this there

00:18:17,490 --> 00:18:21,990
is a project called our DB I think

00:18:19,980 --> 00:18:23,580
Netflix guys both of them and uses them

00:18:21,990 --> 00:18:25,769
to like some of their solutions

00:18:23,580 --> 00:18:28,559
it's basically Reddy's protocol but the

00:18:25,769 --> 00:18:30,419
store is all on the drive so we kinda

00:18:28,559 --> 00:18:33,899
eliminate the problem of in memory and

00:18:30,419 --> 00:18:35,999
this kind of allows you to work but you

00:18:33,899 --> 00:18:40,200
need to host it and I hate to take care

00:18:35,999 --> 00:18:42,090
of it and we're lazy 2018 so and as I

00:18:40,200 --> 00:18:44,779
said multiple consumers you need to

00:18:42,090 --> 00:18:48,210
basically run your write your own

00:18:44,779 --> 00:18:51,179
transactions and logs and we are not

00:18:48,210 --> 00:18:54,600
avoiding polling so okay not ready

00:18:51,179 --> 00:18:58,549
sports breath another tool only buddy

00:18:54,600 --> 00:19:02,429
use post miss yes this is what I like so

00:18:58,549 --> 00:19:12,090
an impeccable reputation I would say if

00:19:02,429 --> 00:19:13,350
it goes to databases and example the

00:19:12,090 --> 00:19:14,909
same example do you want to see

00:19:13,350 --> 00:19:18,539
consumers and publishers more or less

00:19:14,909 --> 00:19:19,460
what was used to to emulate this are you

00:19:18,539 --> 00:19:27,210
interested

00:19:19,460 --> 00:19:30,629
yes no all right so so let's go with

00:19:27,210 --> 00:19:37,590
publisher standard Fink connects to

00:19:30,629 --> 00:19:39,480
Tourette to post breast then publish

00:19:37,590 --> 00:19:41,610
method that kind of creates like this

00:19:39,480 --> 00:19:43,980
whole structure previously it's all

00:19:41,610 --> 00:19:46,789
emulated rmq so they all kind of emulate

00:19:43,980 --> 00:19:49,080
multiple channels to which you can send

00:19:46,789 --> 00:19:51,539
creating that the table that actually

00:19:49,080 --> 00:19:53,759
holds this it's just Jason B and time

00:19:51,539 --> 00:19:56,190
index it is big and we're not using IDs

00:19:53,759 --> 00:19:59,129
to create any holes and allow posters to

00:19:56,190 --> 00:20:02,850
actually efficiently process the deletes

00:19:59,129 --> 00:20:06,389
and stuff like this and you can forget

00:20:02,850 --> 00:20:08,129
about this if it's about unique readies

00:20:06,389 --> 00:20:11,100
has this thing that's that you can set

00:20:08,129 --> 00:20:12,779
that compactor it is for a second does

00:20:11,100 --> 00:20:14,399
you can have unique entries in the queue

00:20:12,779 --> 00:20:16,610
which means if you ever want to replace

00:20:14,399 --> 00:20:18,740
this the

00:20:16,610 --> 00:20:20,529
the information and put it to like

00:20:18,740 --> 00:20:22,789
different timestamp it's doable so

00:20:20,529 --> 00:20:25,190
because this was a next step I kind of

00:20:22,789 --> 00:20:28,669
do the same but it's it's you'd like

00:20:25,190 --> 00:20:32,809
it's not necessary so very simple insert

00:20:28,669 --> 00:20:35,510
into your message and delay of time and

00:20:32,809 --> 00:20:40,370
the consumer basically that is polling

00:20:35,510 --> 00:20:42,529
and executing select on IDs where time

00:20:40,370 --> 00:20:45,730
index right nothing more simpler than

00:20:42,529 --> 00:20:50,480
that on acknowledge what we do is delete

00:20:45,730 --> 00:20:53,720
which is that now what is in I what is

00:20:50,480 --> 00:20:56,149
nice here with post-arrest we're

00:20:53,720 --> 00:20:58,640
actually using the types that are

00:20:56,149 --> 00:21:00,860
provided to the PG library to say what

00:20:58,640 --> 00:21:04,549
item s so if you like go to query

00:21:00,860 --> 00:21:07,070
results see what's the interface well

00:21:04,549 --> 00:21:10,490
this is not too much but you'll see

00:21:07,070 --> 00:21:12,620
there's like rows and other stuff makes

00:21:10,490 --> 00:21:17,620
makes hearts to make errors to when

00:21:12,620 --> 00:21:17,620
you're writing something so further you

00:21:28,090 --> 00:21:33,200
as you expect the first message would

00:21:31,220 --> 00:21:38,240
appear with message to write it works

00:21:33,200 --> 00:21:40,730
right well avoiding Kron we have

00:21:38,240 --> 00:21:42,590
published order we do confirm file

00:21:40,730 --> 00:21:45,890
profit multiple consumers we need to do

00:21:42,590 --> 00:21:47,570
our own transaction implementation can

00:21:45,890 --> 00:21:50,510
store data persistently for a long time

00:21:47,570 --> 00:21:52,520
very good large messages whatever

00:21:50,510 --> 00:21:55,669
message size we can go with it out of

00:21:52,520 --> 00:21:59,210
the box replicas call indexing superb

00:21:55,669 --> 00:22:01,669
priorities not there but if you add

00:21:59,210 --> 00:22:06,260
extra field there and then you sort by

00:22:01,669 --> 00:22:09,500
it works what we are still missing here

00:22:06,260 --> 00:22:11,480
is polling we're still poet we can't get

00:22:09,500 --> 00:22:14,650
around it really when you because

00:22:11,480 --> 00:22:17,390
effectively what we're doing here is

00:22:14,650 --> 00:22:21,260
we're actually creating a broker which

00:22:17,390 --> 00:22:23,030
is we're creating our mq or rabbit or 0

00:22:21,260 --> 00:22:24,679
mq this is what what basically what

00:22:23,030 --> 00:22:26,660
those two solutions were basically

00:22:24,679 --> 00:22:30,350
create your own broker that does this

00:22:26,660 --> 00:22:32,240
one simple thing but we don't want to be

00:22:30,350 --> 00:22:34,700
in the business of creating broker so

00:22:32,240 --> 00:22:38,030
you'd rather utilize it whatever is

00:22:34,700 --> 00:22:40,760
there and here's enters the active and

00:22:38,030 --> 00:22:42,679
queue which is you can get it on Amazon

00:22:40,760 --> 00:22:46,490
and queue it's like few other hosting

00:22:42,679 --> 00:22:48,320
services very nice tool to tell the

00:22:46,490 --> 00:22:50,450
truth I've discovered this last week and

00:22:48,320 --> 00:22:51,710
I literally like tested this last week

00:22:50,450 --> 00:22:55,070
when I was just doing class business

00:22:51,710 --> 00:22:58,970
pieces for the presentation so what they

00:22:55,070 --> 00:23:01,850
give you that I am QP one is your

00:22:58,970 --> 00:23:04,250
protocol this will not work with our mq

00:23:01,850 --> 00:23:06,169
clients the rabbit clients because our

00:23:04,250 --> 00:23:08,900
MQ is using zero nine one and they are

00:23:06,169 --> 00:23:11,360
inherently different so there is this

00:23:08,900 --> 00:23:14,809
libraries we use which is called RIA and

00:23:11,360 --> 00:23:17,660
seems quite promising year ago with

00:23:14,809 --> 00:23:20,900
total it was bad

00:23:17,660 --> 00:23:23,600
like we're ago when it's actually was

00:23:20,900 --> 00:23:25,190
released on the market and the main

00:23:23,600 --> 00:23:26,929
advice people were giving here if you're

00:23:25,190 --> 00:23:29,120
using Java go active I'm here if you

00:23:26,929 --> 00:23:31,309
don't use Javas just just do something

00:23:29,120 --> 00:23:34,370
else but during this year a lot of

00:23:31,309 --> 00:23:36,530
changes so I am QP that we used and ktt

00:23:34,370 --> 00:23:38,270
stomp open wire this is all like tools

00:23:36,530 --> 00:23:40,250
to connect to this queue and basically

00:23:38,270 --> 00:23:41,690
gives you freedom of how you interact

00:23:40,250 --> 00:23:44,660
with it also

00:23:41,690 --> 00:23:46,340
exposes different potential different

00:23:44,660 --> 00:23:49,820
functionalities in the queuing system

00:23:46,340 --> 00:23:51,680
itself so I want to go back to the code

00:23:49,820 --> 00:23:55,910
because this is this is most interesting

00:23:51,680 --> 00:23:58,480
but I need to create and and this I

00:23:55,910 --> 00:23:58,480
found

00:24:09,510 --> 00:24:16,230
[Music]

00:24:11,040 --> 00:24:17,880
if we go yeah five minutes ago where did

00:24:16,230 --> 00:24:27,320
this very fast today

00:24:17,880 --> 00:24:27,320
where was this util source MQ example

00:24:39,240 --> 00:24:42,980
[Music]

00:24:53,160 --> 00:25:07,620
very important so let's go to the last

00:24:58,919 --> 00:25:10,110
part which is this stuff basically

00:25:07,620 --> 00:25:13,289
they're from version find five point

00:25:10,110 --> 00:25:17,070
five point four there is something which

00:25:13,289 --> 00:25:20,280
is called scheduler plugin that allows

00:25:17,070 --> 00:25:22,919
you to send arbitrary fields that

00:25:20,280 --> 00:25:25,140
actually has the delay like like you

00:25:22,919 --> 00:25:27,600
would expect to have and this can be

00:25:25,140 --> 00:25:30,960
whatever big image that you can think of

00:25:27,600 --> 00:25:40,159
so well basically works how is it

00:25:30,960 --> 00:25:40,159
supposed to work TS know this is a MQ

00:25:44,299 --> 00:26:00,059
didn't save the NY right so what we did

00:25:54,539 --> 00:26:03,630
here was sent buffer sent object and

00:26:00,059 --> 00:26:05,039
sent text and in a second like when the

00:26:03,630 --> 00:26:08,460
older message come back I would just put

00:26:05,039 --> 00:26:10,830
it here on the under in the screen just

00:26:08,460 --> 00:26:13,679
copy it over and this is what actually

00:26:10,830 --> 00:26:15,809
appeared in the console after they come

00:26:13,679 --> 00:26:18,320
back and they were read back to the

00:26:15,809 --> 00:26:18,320
consumer

00:26:24,180 --> 00:26:29,550
the first one that came back was the

00:26:26,730 --> 00:26:32,400
message for this has 5 seconds for 5

00:26:29,550 --> 00:26:36,350
seconds delay that was a string and damn

00:26:32,400 --> 00:26:38,370
then came back the message which was it

00:26:36,350 --> 00:26:40,110
then they came back in the order that

00:26:38,370 --> 00:26:42,360
they were received so from one to free

00:26:40,110 --> 00:26:46,350
the first one was buffered the other was

00:26:42,360 --> 00:26:48,510
object fun think you I don't have time

00:26:46,350 --> 00:26:51,120
now I was going to show you you can

00:26:48,510 --> 00:26:53,070
hooked protobuf to it in a matter of 10

00:26:51,120 --> 00:26:56,250
minutes and basically send put above

00:26:53,070 --> 00:26:59,720
messages like this there is no type

00:26:56,250 --> 00:27:02,130
conversion between like between

00:26:59,720 --> 00:27:05,100
publisher or consumer you basically do

00:27:02,130 --> 00:27:06,630
protobuf encode and pass it to the to

00:27:05,100 --> 00:27:08,820
the RIA and they will do the whole job

00:27:06,630 --> 00:27:12,950
for you like this is really cool stuff

00:27:08,820 --> 00:27:15,840
so we've got the demo nailed it

00:27:12,950 --> 00:27:17,820
basically what we needed the Amazon one

00:27:15,840 --> 00:27:20,880
use the cardi B as the store quite

00:27:17,820 --> 00:27:23,340
performant questions which I think we

00:27:20,880 --> 00:27:28,470
don't do and thank you

00:27:23,340 --> 00:27:28,470

YouTube URL: https://www.youtube.com/watch?v=NEdf_OLAtu0


