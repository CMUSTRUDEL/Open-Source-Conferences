Title: Async Iterators - London Node User Group - February 2019
Publication date: 2019-03-11
Playlist: London Node User Group
Description: 
	Jamie McCrindle

An exploration of async iterators in NodeJS including when and why to use them, how they compare to other reactive libraries, how they perform and what to look out for when you do use them.

JavaScript enthusiast, Open Source Contributor, Co-founder of a number of successful startups, OpenBankHack17 hackathon winner, Head of Technology for Business Banking at Investec. You can find me at https://jamie.mccrindle.org
_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,060 --> 00:00:05,339
my name is Jamie McCrystal and I work

00:00:03,419 --> 00:00:07,200
for investment invest act Bank I'm the

00:00:05,339 --> 00:00:11,130
head of engineering there

00:00:07,200 --> 00:00:13,889
I enjoy JavaScript and typescript and I

00:00:11,130 --> 00:00:16,830
quite like a singular writers who here

00:00:13,889 --> 00:00:23,400
has used async iterators old generators

00:00:16,830 --> 00:00:24,660
in anger okay so so I hope it's not too

00:00:23,400 --> 00:00:27,000
boring for you guys

00:00:24,660 --> 00:00:29,010
for everyone else let me tell you a

00:00:27,000 --> 00:00:31,740
little bit about async iterators why

00:00:29,010 --> 00:00:33,390
you'd want to use them so why you think

00:00:31,740 --> 00:00:35,460
generators a little bit about async

00:00:33,390 --> 00:00:39,960
iterators which is the mechanism that

00:00:35,460 --> 00:00:41,390
lies under a sink generators like what

00:00:39,960 --> 00:00:44,309
to think about when you're using them

00:00:41,390 --> 00:00:48,059
I'll show you a little bit of code node

00:00:44,309 --> 00:00:49,739
and oh no QA that storm slides but no

00:00:48,059 --> 00:00:53,699
questions you can ask me questions in

00:00:49,739 --> 00:00:57,030
the break so just a little history of

00:00:53,699 --> 00:01:00,270
async iterators first proposed proposal

00:00:57,030 --> 00:01:00,660
in 2014 Babel was pretty quick off the

00:01:00,270 --> 00:01:03,780
mark

00:01:00,660 --> 00:01:07,260
then typescript available in 2017 in

00:01:03,780 --> 00:01:08,970
node 8 at the beginning of last year

00:01:07,260 --> 00:01:12,360
they became part of the ECMO script

00:01:08,970 --> 00:01:17,070
standard and last year around April time

00:01:12,360 --> 00:01:18,409
they're available in node 10 so why

00:01:17,070 --> 00:01:21,060
would you want to use them

00:01:18,409 --> 00:01:24,890
so I guess hopefully everyone knows

00:01:21,060 --> 00:01:26,909
about generators so this is a bit of a

00:01:24,890 --> 00:01:28,350
manufacturing example but imagine you

00:01:26,909 --> 00:01:30,720
wanted to get an infinite stream of

00:01:28,350 --> 00:01:33,000
numbers and you didn't have generators

00:01:30,720 --> 00:01:34,110
you might write code that well hopefully

00:01:33,000 --> 00:01:37,740
you guys wouldn't write code that looks

00:01:34,110 --> 00:01:41,159
like that but it is way easier to do

00:01:37,740 --> 00:01:45,750
with generators so here we're returning

00:01:41,159 --> 00:01:48,450
a KO routine and we can essentially for

00:01:45,750 --> 00:01:49,979
loop through the natural numbers for as

00:01:48,450 --> 00:01:54,780
long as we're interested in natural

00:01:49,979 --> 00:01:56,549
numbers and then we can stop this this

00:01:54,780 --> 00:01:58,500
is my favorite way to answer Fibonacci

00:01:56,549 --> 00:02:02,840
is an interview question using generator

00:01:58,500 --> 00:02:06,030
so infinite list of Bonacci numbers here

00:02:02,840 --> 00:02:08,399
I also really like the in-place

00:02:06,030 --> 00:02:10,590
swap over there to avoid the temporary

00:02:08,399 --> 00:02:12,390
variable although I would say that I

00:02:10,590 --> 00:02:13,560
wouldn't be surprised if it transpires

00:02:12,390 --> 00:02:19,830
out

00:02:13,560 --> 00:02:22,050
a single weight is pretty cool so pre

00:02:19,830 --> 00:02:24,840
async/await if you wanted to do any

00:02:22,050 --> 00:02:27,930
async code and use promises you would

00:02:24,840 --> 00:02:31,739
have to you'd have to chain together

00:02:27,930 --> 00:02:34,020
your fins and this codes not too bad but

00:02:31,739 --> 00:02:36,450
I tend to find as soon as you got a lot

00:02:34,020 --> 00:02:37,709
of code you'd have to kind of thread

00:02:36,450 --> 00:02:39,480
your state through all the various

00:02:37,709 --> 00:02:42,690
callbacks and it became a little bit

00:02:39,480 --> 00:02:43,770
more difficult to read so I find this a

00:02:42,690 --> 00:02:46,650
little easier to read a little bit more

00:02:43,770 --> 00:02:50,970
imperative so we just go and fetch a

00:02:46,650 --> 00:02:55,440
result a weight turning it into Jason

00:02:50,970 --> 00:02:56,760
and then we can return the USD I think

00:02:55,440 --> 00:03:02,550
it might be obvious by now that I work

00:02:56,760 --> 00:03:04,800
in banking so why not both I actually

00:03:02,550 --> 00:03:07,140
couldn't decide on an image here so one

00:03:04,800 --> 00:03:11,430
of both generators and async await so

00:03:07,140 --> 00:03:16,590
you get all my options and that is a

00:03:11,430 --> 00:03:19,140
crocodile with butterflies on it so here

00:03:16,590 --> 00:03:22,019
is live rates again written are using an

00:03:19,140 --> 00:03:24,450
async generator it returns an infinite

00:03:22,019 --> 00:03:25,890
list or inference sequence of live rates

00:03:24,450 --> 00:03:28,320
so I've got a while true at the top

00:03:25,890 --> 00:03:29,790
there but fortunately the calling code

00:03:28,320 --> 00:03:34,290
will decide when it's tired of receiving

00:03:29,790 --> 00:03:37,470
live rates we we make a call using fetch

00:03:34,290 --> 00:03:39,329
we get to JSON out we return dollars and

00:03:37,470 --> 00:03:41,790
because we're gonna be nice to we want

00:03:39,329 --> 00:03:49,590
to be nice to exchange rates API dot IO

00:03:41,790 --> 00:03:52,160
we then delay for 24 hours so that was

00:03:49,590 --> 00:03:55,160
kind of how to write the async generator

00:03:52,160 --> 00:03:57,720
in this case it's how you'd use it and

00:03:55,160 --> 00:04:02,340
it's a similar for loop you've got a for

00:03:57,720 --> 00:04:06,620
await and essentially you'd stream your

00:04:02,340 --> 00:04:06,620
async results through this for loop

00:04:09,680 --> 00:04:18,769
Oh oh yeah so so this was gonna be my

00:04:16,280 --> 00:04:20,449
original example not banking related I

00:04:18,769 --> 00:04:22,009
don't know if anyone knows what a sleep

00:04:20,449 --> 00:04:23,180
sword is but it's a it's a cunning way

00:04:22,009 --> 00:04:25,250
to sort way essentially if you've got a

00:04:23,180 --> 00:04:27,410
stream of numbers and you multiply it

00:04:25,250 --> 00:04:30,470
multiply them by some constant waiting

00:04:27,410 --> 00:04:32,270
time then as they come in they'll come

00:04:30,470 --> 00:04:34,610
back in an order and that's how you

00:04:32,270 --> 00:04:42,590
write a sleep sleep sleep sort using

00:04:34,610 --> 00:04:45,650
async generators so so basic generators

00:04:42,590 --> 00:04:47,630
he's easy to mix them up so there is an

00:04:45,650 --> 00:04:49,880
underlying mechanism behind async

00:04:47,630 --> 00:04:51,500
generators and that's this async

00:04:49,880 --> 00:04:52,970
iterators interface over here I won't

00:04:51,500 --> 00:04:55,250
spend too long in it but essentially

00:04:52,970 --> 00:04:56,780
it's very similar to how you implement

00:04:55,250 --> 00:04:59,180
an iterator and they're just there

00:04:56,780 --> 00:05:01,070
certain cases where using the for white

00:04:59,180 --> 00:05:04,099
syntax won't quite work for you and

00:05:01,070 --> 00:05:08,060
you'll need to use the underlying async

00:05:04,099 --> 00:05:09,680
iterator interface so this is interval

00:05:08,060 --> 00:05:12,650
as an async iterator if anybody's used

00:05:09,680 --> 00:05:15,010
rx it's got a method called interval and

00:05:12,650 --> 00:05:17,930
all that does is returns a value after

00:05:15,010 --> 00:05:20,750
or continuous stream of values in fact

00:05:17,930 --> 00:05:22,580
after with a fixed delay right so we

00:05:20,750 --> 00:05:24,159
have the fixed delay in milliseconds

00:05:22,580 --> 00:05:27,830
right at the top

00:05:24,159 --> 00:05:30,500
the you're obliged to put the symbol to

00:05:27,830 --> 00:05:33,349
an async iterator function in there and

00:05:30,500 --> 00:05:34,699
then we've got next is called every time

00:05:33,349 --> 00:05:37,940
you want ever seek and retrieve the next

00:05:34,699 --> 00:05:41,120
value and we were kind of delaying with

00:05:37,940 --> 00:05:43,610
a promise style then and we also also

00:05:41,120 --> 00:05:45,560
have the option to react if something

00:05:43,610 --> 00:05:49,280
goes wrong so for example say somebody's

00:05:45,560 --> 00:05:51,110
wrapped this in a 408 and an exception

00:05:49,280 --> 00:05:53,780
is thrown you can track that in your

00:05:51,110 --> 00:05:55,159
async iterator and at the bottom if say

00:05:53,780 --> 00:05:56,810
somebody returns in the middle of your

00:05:55,159 --> 00:05:59,900
for loop you can also track that so this

00:05:56,810 --> 00:06:01,729
is both throwing throwing return are

00:05:59,900 --> 00:06:03,349
very useful for closing off resources so

00:06:01,729 --> 00:06:04,430
if you're pulling results from a

00:06:03,349 --> 00:06:07,130
database and you want to close the

00:06:04,430 --> 00:06:08,960
connection afterwards you can use throw

00:06:07,130 --> 00:06:14,449
a return to kind of track the fact that

00:06:08,960 --> 00:06:16,220
you broke out of your for loop and this

00:06:14,449 --> 00:06:17,810
is live right send calls we saw before

00:06:16,220 --> 00:06:20,270
only this time written as an async

00:06:17,810 --> 00:06:23,460
iterator I think hopefully you'd agree

00:06:20,270 --> 00:06:24,960
that this is well the previous

00:06:23,460 --> 00:06:32,910
example this code was slightly easier to

00:06:24,960 --> 00:06:35,069
read so like I've been using async

00:06:32,910 --> 00:06:37,319
iterators quite a lot I wasn't expecting

00:06:35,069 --> 00:06:40,410
to use them as much as I have been I

00:06:37,319 --> 00:06:43,680
really enjoy the fact that they feel a

00:06:40,410 --> 00:06:46,590
bit more imperative and so here's here's

00:06:43,680 --> 00:06:48,660
how you'd use a kind of a line reader in

00:06:46,590 --> 00:06:51,539
classic node now I think probably by now

00:06:48,660 --> 00:06:54,030
most people don't use streams quite like

00:06:51,539 --> 00:06:56,970
this but if you're using a line reader

00:06:54,030 --> 00:06:58,349
from the node standard library you'd

00:06:56,970 --> 00:07:03,389
write code a little bit like this and

00:06:58,349 --> 00:07:05,370
you can kind of see that like you can

00:07:03,389 --> 00:07:07,139
kind of read where it's going but I

00:07:05,370 --> 00:07:08,820
could quite easily swap those swap those

00:07:07,139 --> 00:07:11,009
two blocks of code around and it would

00:07:08,820 --> 00:07:12,660
still behave in the same way so you kind

00:07:11,009 --> 00:07:15,150
of you can't rely on the sequence of

00:07:12,660 --> 00:07:18,800
your code to give you a clue as to

00:07:15,150 --> 00:07:18,800
what's going to happen in what order

00:07:19,130 --> 00:07:24,900
instead you could use from line reader

00:07:21,810 --> 00:07:26,669
over here and we'll talk a little bit

00:07:24,900 --> 00:07:29,669
about the implementation of from line

00:07:26,669 --> 00:07:33,060
reader but this turns a line reader into

00:07:29,669 --> 00:07:40,919
a series of async promises that we can

00:07:33,060 --> 00:07:42,389
read with a 408 loop so so interesting

00:07:40,919 --> 00:07:44,550
enough like the code for this seems

00:07:42,389 --> 00:07:47,659
seems really simple actually I'm not

00:07:44,550 --> 00:07:49,530
going to jump to the next slide yes but

00:07:47,659 --> 00:07:51,479
there's a there's a whole bunch of

00:07:49,530 --> 00:07:53,310
things with just pure async generators

00:07:51,479 --> 00:07:55,590
there that make them slightly hard to

00:07:53,310 --> 00:07:58,080
use in this case and essentially the the

00:07:55,590 --> 00:08:02,789
problem is is when you turn that series

00:07:58,080 --> 00:08:05,039
of events into an async stream the kind

00:08:02,789 --> 00:08:09,000
of your consumption model changes a

00:08:05,039 --> 00:08:12,719
little bit right so say for example say

00:08:09,000 --> 00:08:14,880
for example you you have a delay while

00:08:12,719 --> 00:08:17,460
consuming so say we had that delay for

00:08:14,880 --> 00:08:19,770
like a day that we saw in the example

00:08:17,460 --> 00:08:21,719
before I next we've got something in

00:08:19,770 --> 00:08:23,460
from rot line reader to slow the

00:08:21,719 --> 00:08:24,509
underlying line reader down you could

00:08:23,460 --> 00:08:26,909
run it on a memory because it could

00:08:24,509 --> 00:08:28,590
consume all of the lines before it

00:08:26,909 --> 00:08:30,150
processes the next line and you also

00:08:28,590 --> 00:08:32,039
have to deal with a case where for

00:08:30,150 --> 00:08:34,589
example you just started trying to

00:08:32,039 --> 00:08:36,089
realign but your underlying file hasn't

00:08:34,589 --> 00:08:38,330
opened yet or your network connection

00:08:36,089 --> 00:08:41,430
hasn't been made

00:08:38,330 --> 00:08:43,500
so you can borrow a fortune

00:08:41,430 --> 00:08:46,110
rxjs has something to solve this problem

00:08:43,500 --> 00:08:47,820
called the subject and so yeah if you're

00:08:46,110 --> 00:08:50,220
using a singular rate of the generators

00:08:47,820 --> 00:08:52,380
it's useful to have a library that

00:08:50,220 --> 00:08:54,120
provides something like a subject and

00:08:52,380 --> 00:08:56,880
what that'll do is that'll just track

00:08:54,120 --> 00:08:58,860
you know it'll track into both sides of

00:08:56,880 --> 00:09:02,840
that so it'll queue things up before

00:08:58,860 --> 00:09:09,330
they're read and it'll delay a promise

00:09:02,840 --> 00:09:10,920
until some data is available so this is

00:09:09,330 --> 00:09:12,360
the implementation of flump from from

00:09:10,920 --> 00:09:14,400
line reader so this is this is how I

00:09:12,360 --> 00:09:18,440
turn something that produces a series of

00:09:14,400 --> 00:09:22,380
events into an async iterator I am using

00:09:18,440 --> 00:09:24,950
this magical subject library and so

00:09:22,380 --> 00:09:27,900
essentially every time you get a line

00:09:24,950 --> 00:09:29,670
you call on next in the subject when it

00:09:27,900 --> 00:09:31,290
closes down you let the subject know

00:09:29,670 --> 00:09:33,810
it's completed and you can just return

00:09:31,290 --> 00:09:37,560
the underlying iterable from the subject

00:09:33,810 --> 00:09:40,500
I did happen to write a library called

00:09:37,560 --> 00:09:42,360
axe axe which happens to have a subject

00:09:40,500 --> 00:09:46,310
in it and a few of the other functions

00:09:42,360 --> 00:09:48,180
you'll you'll see today this yeah

00:09:46,310 --> 00:09:49,380
there's not that many of what libraries

00:09:48,180 --> 00:09:50,670
out there that people where people have

00:09:49,380 --> 00:09:52,830
been solving these problems for acing

00:09:50,670 --> 00:09:54,950
generators yet but they are being

00:09:52,830 --> 00:09:59,070
they'll be using the wild probably the

00:09:54,950 --> 00:10:02,040
problem cases meaning anybodies used as

00:09:59,070 --> 00:10:05,340
the client or the server is a graph QL

00:10:02,040 --> 00:10:06,900
client library for publish/subscribe

00:10:05,340 --> 00:10:13,080
users async inner artists to get the

00:10:06,900 --> 00:10:15,210
notifications now when you start using

00:10:13,080 --> 00:10:17,400
them a lot one of the things that does

00:10:15,210 --> 00:10:20,160
happen is that you can get into

00:10:17,400 --> 00:10:23,340
situations where your your stream of

00:10:20,160 --> 00:10:24,990
events gets deadlocked or stuck and this

00:10:23,340 --> 00:10:26,820
is the simplest example I could make of

00:10:24,990 --> 00:10:30,450
that so what you've got at the top is

00:10:26,820 --> 00:10:35,280
you've got a an async generator that

00:10:30,450 --> 00:10:38,220
just never ends and we've got a 408 over

00:10:35,280 --> 00:10:41,280
there which essentially gets stuck

00:10:38,220 --> 00:10:42,510
waiting for that result and this can

00:10:41,280 --> 00:10:44,130
happen in weight situations it doesn't

00:10:42,510 --> 00:10:45,810
have to never end but say for example

00:10:44,130 --> 00:10:48,750
you've got you know some socket that

00:10:45,810 --> 00:10:51,210
doesn't close or doesn't return data you

00:10:48,750 --> 00:10:53,490
can you can have issues and essentially

00:10:51,210 --> 00:10:57,420
the solution to this or a potential

00:10:53,490 --> 00:11:00,120
solution to this is a cancellation the

00:10:57,420 --> 00:11:01,920
ability to cancel promises or

00:11:00,120 --> 00:11:07,680
cancellation generators but that's still

00:11:01,920 --> 00:11:16,920
being debated on tc39 all right let's

00:11:07,680 --> 00:11:19,110
see some code dark mode sorry if I

00:11:16,920 --> 00:11:22,920
blinded everyone I left to remember that

00:11:19,110 --> 00:11:24,350
if I if I present something else can

00:11:22,920 --> 00:11:26,760
everyone see that

00:11:24,350 --> 00:11:29,880
bigger feel like you should be able to

00:11:26,760 --> 00:11:32,550
okay hopefully everyone can read that so

00:11:29,880 --> 00:11:34,470
at the top there I've had to wrap

00:11:32,550 --> 00:11:39,830
everything in an async function because

00:11:34,470 --> 00:11:42,390
we don't have a weight at top level so

00:11:39,830 --> 00:11:44,460
kind of ignore the async function run if

00:11:42,390 --> 00:11:45,840
you can and just look at look at what's

00:11:44,460 --> 00:11:48,780
happening in the middle so we've got a

00:11:45,840 --> 00:11:51,920
for weight loop I'm just turning an

00:11:48,780 --> 00:11:56,520
array of dates with one date into

00:11:51,920 --> 00:11:58,770
actually an async generator and that

00:11:56,520 --> 00:12:00,690
lets me put in a weight in a for loop

00:11:58,770 --> 00:12:02,370
right this is this is not the best

00:12:00,690 --> 00:12:07,380
example but I wanted to go for the the

00:12:02,370 --> 00:12:11,520
simplest case so if I go node simple dot

00:12:07,380 --> 00:12:15,710
J yes I remember that I'm not connected

00:12:11,520 --> 00:12:15,710
to the Internet that's inconvenient

00:12:16,280 --> 00:12:31,080
who's the Wi-Fi password yeah perfect

00:12:23,970 --> 00:12:33,390
oh no all right I've given my VPN also

00:12:31,080 --> 00:12:34,740
has to wake up I might I might I might

00:12:33,390 --> 00:12:35,280
avoid running the code and I'll just

00:12:34,740 --> 00:12:40,500
show you the code

00:12:35,280 --> 00:12:42,290
right so believe me when I say that when

00:12:40,500 --> 00:12:45,240
Ike's

00:12:42,290 --> 00:12:47,250
when I make this call it will go away to

00:12:45,240 --> 00:12:52,800
exchange rate IO and go and get me the

00:12:47,250 --> 00:12:54,930
pound dollar exchange rate so imagine

00:12:52,800 --> 00:12:57,330
now I had a giant file of data whatever

00:12:54,930 --> 00:12:58,860
look at historical rates over time and

00:12:57,330 --> 00:13:00,600
I've got this huge file over here and

00:12:58,860 --> 00:13:02,220
perhaps I want to go through that file

00:13:00,600 --> 00:13:06,840
line-by-line

00:13:02,220 --> 00:13:08,970
and call that same API endpoint so I'm

00:13:06,840 --> 00:13:11,280
using that that from line reader that we

00:13:08,970 --> 00:13:15,330
saw before so you've got lines from line

00:13:11,280 --> 00:13:17,010
reader I'm going and creating a read

00:13:15,330 --> 00:13:20,520
line library so that just creates that

00:13:17,010 --> 00:13:23,160
underlying node streams line reader and

00:13:20,520 --> 00:13:27,270
we can see the code remains pretty much

00:13:23,160 --> 00:13:30,270
the same I can just iterate through that

00:13:27,270 --> 00:13:33,000
async stream of lines and so this is

00:13:30,270 --> 00:13:34,560
pretty handy if it's a giant file I can

00:13:33,000 --> 00:13:37,860
just process that asynchronously as it

00:13:34,560 --> 00:13:40,020
comes in so and I find this kind of

00:13:37,860 --> 00:13:42,990
imperative syntax again a lot easier to

00:13:40,020 --> 00:13:44,400
read and then finally I don't know if

00:13:42,990 --> 00:13:46,980
anybody's done this but I needed to do

00:13:44,400 --> 00:13:49,740
this before but sometimes you may want

00:13:46,980 --> 00:13:51,540
to call some Ural endpoint in parallel

00:13:49,740 --> 00:13:52,950
but you don't wanna hit it too hard so

00:13:51,540 --> 00:13:54,810
perhaps you want to only hit it you know

00:13:52,950 --> 00:13:57,570
with two concurrent threads so we've got

00:13:54,810 --> 00:14:00,210
this concurrent map over here so same

00:13:57,570 --> 00:14:01,950
code again only this time I put a

00:14:00,210 --> 00:14:05,100
concurrent map in the middle of it all

00:14:01,950 --> 00:14:06,930
that does is returns an async generator

00:14:05,100 --> 00:14:11,220
where it will run that mapping function

00:14:06,930 --> 00:14:13,470
kind of concurrently so I have right

00:14:11,220 --> 00:14:15,090
over here said that I want a concurrency

00:14:13,470 --> 00:14:18,570
level of two but I could say you know

00:14:15,090 --> 00:14:22,520
I'd like ten to run in parallel it'll

00:14:18,570 --> 00:14:26,280
then call that API asynchronously in

00:14:22,520 --> 00:14:30,120
parallel will concurrently at least with

00:14:26,280 --> 00:14:32,610
well ten of them concurrently and return

00:14:30,120 --> 00:14:36,810
the same data or they don't do this to

00:14:32,610 --> 00:14:44,610
exchange rates API dot IO because you

00:14:36,810 --> 00:14:46,050
pre blow them up after a while I don't

00:14:44,610 --> 00:14:50,090
know how I'm doing for time I feel like

00:14:46,050 --> 00:14:52,860
I rushed through that but yeah that's it

00:14:50,090 --> 00:14:53,230
thank you very much everyone I hope that

00:14:52,860 --> 00:14:59,710
was interesting

00:14:53,230 --> 00:14:59,710

YouTube URL: https://www.youtube.com/watch?v=9-yBcIDMjdw


