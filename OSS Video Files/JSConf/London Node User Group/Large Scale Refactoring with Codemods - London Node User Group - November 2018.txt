Title: Large Scale Refactoring with Codemods - London Node User Group - November 2018
Publication date: 2018-12-03
Playlist: London Node User Group
Description: 
	Presented by Edd Yerburgh

Refactoring is part of the process of maintaining an application, but large scale refactoring that are more complicated than a find and replace are time consuming.

Codemods are a tool to refactor code by manipulating the abstract syntax tree (AST). In this talk I'll teach you what ASTs are, why we use ASTs in tools like Babel and eslint, and how to write a codemod that manipulates an AST.

About me I'm a Vue core contributor, and software engineer at the BBC. https://twitter.com/EddYerburgh

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,370
so large-scale refactoring with code

00:00:01,890 --> 00:00:09,870
mods as I said my name is Ed Yarbrough

00:00:05,370 --> 00:00:11,969
and I work at BBC iplayer we're hiring

00:00:09,870 --> 00:00:15,599
if you want to work at scale come and

00:00:11,969 --> 00:00:19,430
talk to me and also part of the view

00:00:15,599 --> 00:00:21,990
core team so yeah this talk is about

00:00:19,430 --> 00:00:26,490
refactoring and refactoring effectively

00:00:21,990 --> 00:00:27,810
because as JavaScript developers we're

00:00:26,490 --> 00:00:32,399
working with the language that moves

00:00:27,810 --> 00:00:34,070
very quickly so often we find that apps

00:00:32,399 --> 00:00:37,020
that we wrote three or four years ago

00:00:34,070 --> 00:00:40,469
starts with it very outdated and they

00:00:37,020 --> 00:00:43,050
use maybe old hacks or old syntax that

00:00:40,469 --> 00:00:44,850
could be updated to improve the speed

00:00:43,050 --> 00:00:51,539
our apps and to improve the readability

00:00:44,850 --> 00:00:54,059
of our code so I saw this mean the other

00:00:51,539 --> 00:00:57,600
day on Twitter and I found it quite

00:00:54,059 --> 00:00:59,280
funny but it's kind of true like if you

00:00:57,600 --> 00:01:02,820
look at code from five years ago it

00:00:59,280 --> 00:01:04,920
looks like a horrible pile of hacks and

00:01:02,820 --> 00:01:08,430
and that's just because the language is

00:01:04,920 --> 00:01:10,140
evolving so if you want to make sure

00:01:08,430 --> 00:01:11,909
that your code base is up-to-date and

00:01:10,140 --> 00:01:14,310
modern then you need to find a way to

00:01:11,909 --> 00:01:16,710
perform reef actors and to change that

00:01:14,310 --> 00:01:18,979
code efficiently without spending too

00:01:16,710 --> 00:01:23,520
much of your development time doing it

00:01:18,979 --> 00:01:25,200
so to talk about how you can use code

00:01:23,520 --> 00:01:29,340
mods to do that I'm going to use an

00:01:25,200 --> 00:01:33,659
example of replacing a flattened utility

00:01:29,340 --> 00:01:38,460
method so flatten is a method in lodash

00:01:33,659 --> 00:01:45,210
that takes a nested array and flattens

00:01:38,460 --> 00:01:47,399
it by one depth into into an array so

00:01:45,210 --> 00:01:51,450
this is a really common utility and tc39

00:01:47,399 --> 00:01:53,960
decided to add it to the standards so

00:01:51,450 --> 00:01:57,350
they're going to they're adding a

00:01:53,960 --> 00:01:59,460
flatten method to the array prototype

00:01:57,350 --> 00:02:02,820
unfortunately there are some issues with

00:01:59,460 --> 00:02:07,290
the flatten method and it broke a

00:02:02,820 --> 00:02:11,170
website so now it's called flat but

00:02:07,290 --> 00:02:12,790
that's fine so

00:02:11,170 --> 00:02:14,650
in this talk I'm going to show you how

00:02:12,790 --> 00:02:19,209
we would refactor an app that uses

00:02:14,650 --> 00:02:22,270
flatten to use the flat prototype rotor

00:02:19,209 --> 00:02:25,870
type method instead and the way we would

00:02:22,270 --> 00:02:29,170
do this is remove all imports of flatten

00:02:25,870 --> 00:02:33,550
from the app and convert all the calls

00:02:29,170 --> 00:02:39,520
of flatten into an array flat prototype

00:02:33,550 --> 00:02:41,500
method cool so if you've decided to do

00:02:39,520 --> 00:02:43,650
this refactoring the the first approach

00:02:41,500 --> 00:02:46,600
you might take is to do it all manually

00:02:43,650 --> 00:02:49,660
and and that works fine on a small app

00:02:46,600 --> 00:02:52,950
but you might do a fine to replace and

00:02:49,660 --> 00:02:55,750
discover that you have thousands of

00:02:52,950 --> 00:02:58,330
thousands of instances of using flatten

00:02:55,750 --> 00:02:59,800
in your application and doing it

00:02:58,330 --> 00:03:04,120
manually it's going to take a long time

00:02:59,800 --> 00:03:10,090
it's hard to justify it's just not going

00:03:04,120 --> 00:03:13,360
to work so you do some googling and you

00:03:10,090 --> 00:03:15,400
find this library called code mod and so

00:03:13,360 --> 00:03:18,190
as far as I can tell this is actually

00:03:15,400 --> 00:03:20,739
where the term code mods comes from code

00:03:18,190 --> 00:03:23,739
mod is an old Facebook library from

00:03:20,739 --> 00:03:27,489
about ten years ago and the way that it

00:03:23,739 --> 00:03:30,579
works is you pass it in regex for it to

00:03:27,489 --> 00:03:33,130
match and the second argument you give

00:03:30,579 --> 00:03:36,610
it a replacement regex it's a bit like a

00:03:33,130 --> 00:03:38,489
fancy find in replace and you can run

00:03:36,610 --> 00:03:41,980
this on a project and it will go through

00:03:38,489 --> 00:03:44,980
find every instance and prompt you on

00:03:41,980 --> 00:03:49,079
whether you want to replace the matching

00:03:44,980 --> 00:03:53,230
instance with your replacement regex and

00:03:49,079 --> 00:03:54,880
this works fine until you discover that

00:03:53,230 --> 00:03:57,310
people have been using flatten in

00:03:54,880 --> 00:03:59,970
strange ways and you're not actually as

00:03:57,310 --> 00:04:02,530
good as regex as you originally thought

00:03:59,970 --> 00:04:04,860
and then also you still have these

00:04:02,530 --> 00:04:07,170
import statements so even if you do that

00:04:04,860 --> 00:04:09,630
you're going to have to go through and

00:04:07,170 --> 00:04:12,579
manually remove these import statements

00:04:09,630 --> 00:04:14,350
and yeah you probably you could write

00:04:12,579 --> 00:04:16,890
some regex to do this but it would be

00:04:14,350 --> 00:04:20,859
very difficult I wouldn't want to

00:04:16,890 --> 00:04:25,070
attempt that so regex doesn't work

00:04:20,859 --> 00:04:27,380
either and and so you do some more glue

00:04:25,070 --> 00:04:31,340
and you'll find this library called Jas

00:04:27,380 --> 00:04:35,570
code shift so J s Co Tift is a CLI tool

00:04:31,340 --> 00:04:39,730
and the way it works is that you use it

00:04:35,570 --> 00:04:43,040
to modify JavaScript by editing the ast

00:04:39,730 --> 00:04:46,970
so if you like me you would probably

00:04:43,040 --> 00:04:50,920
Google what a s tears and discover the

00:04:46,970 --> 00:04:53,750
ast stands for abstract syntax tree and

00:04:50,920 --> 00:04:56,330
if you read the Wikipedia page you'll

00:04:53,750 --> 00:04:58,760
see that an abstract syntax tree is a

00:04:56,330 --> 00:05:02,570
tree representation of the syntactic

00:04:58,760 --> 00:05:03,890
structure of a source code and if you

00:05:02,570 --> 00:05:08,210
also like me that probably won't make

00:05:03,890 --> 00:05:11,540
much sense to you so I'll show you an

00:05:08,210 --> 00:05:14,930
example of an AST using some JavaScript

00:05:11,540 --> 00:05:17,150
source code up in the Left we have some

00:05:14,930 --> 00:05:22,100
source code it's a sum function with

00:05:17,150 --> 00:05:25,250
take some parameters and returns the sum

00:05:22,100 --> 00:05:29,660
of its parameters I've just realized

00:05:25,250 --> 00:05:35,240
that it's invalid JavaScript and then we

00:05:29,660 --> 00:05:37,340
have a a call to sum and the

00:05:35,240 --> 00:05:40,520
representation of this is an abstract

00:05:37,340 --> 00:05:42,830
syntax tree is that you have a root

00:05:40,520 --> 00:05:46,550
program node that represents the entire

00:05:42,830 --> 00:05:51,200
script or module and then you have a

00:05:46,550 --> 00:05:53,120
function declaration note that function

00:05:51,200 --> 00:05:55,430
declaration nodes contains a block

00:05:53,120 --> 00:05:59,870
statement nodes which is the the code

00:05:55,430 --> 00:06:01,130
inside the curly braces and inside the

00:05:59,870 --> 00:06:06,260
block statement you have a return

00:06:01,130 --> 00:06:08,780
statement and then the next node in the

00:06:06,260 --> 00:06:12,860
tree is an expression statement we're

00:06:08,780 --> 00:06:16,850
actually calling some and so this is a

00:06:12,860 --> 00:06:20,570
this is a tree and in JavaScript so you

00:06:16,850 --> 00:06:24,350
can represent trees using an object so

00:06:20,570 --> 00:06:29,270
here we have the same tree but in an

00:06:24,350 --> 00:06:32,690
object rather than a diagram so you see

00:06:29,270 --> 00:06:34,850
we have a type program so the program is

00:06:32,690 --> 00:06:38,510
the root node and that has a body

00:06:34,850 --> 00:06:41,450
property which is an array of

00:06:38,510 --> 00:06:44,120
child nodes then you have a function

00:06:41,450 --> 00:06:46,810
declaration node and inside the function

00:06:44,120 --> 00:06:50,450
declaration body is the block statement

00:06:46,810 --> 00:06:55,280
and so you can represent that diagram

00:06:50,450 --> 00:07:00,430
with this javascript code and the point

00:06:55,280 --> 00:07:03,350
of AST is that it describes source code

00:07:00,430 --> 00:07:05,060
effectively obviously this example

00:07:03,350 --> 00:07:10,070
doesn't have all the information that we

00:07:05,060 --> 00:07:12,880
need to rebuild source code so this is a

00:07:10,070 --> 00:07:15,380
stripped down version and I'll show you

00:07:12,880 --> 00:07:19,070
what the function declaration a looks

00:07:15,380 --> 00:07:20,270
like in more detail so if you take a

00:07:19,070 --> 00:07:24,820
closer look at the function declaration

00:07:20,270 --> 00:07:29,420
node we have properties like ID which

00:07:24,820 --> 00:07:32,810
itself is an ast node so that's an

00:07:29,420 --> 00:07:35,900
identifier with the name of some and

00:07:32,810 --> 00:07:39,290
then there's a parameter array which is

00:07:35,900 --> 00:07:43,310
an array of ast nodes so there's an

00:07:39,290 --> 00:07:45,590
identifier with the name of a and we

00:07:43,310 --> 00:07:48,800
have some boolean values like a sync set

00:07:45,590 --> 00:07:50,240
to false and generator set to false and

00:07:48,800 --> 00:07:52,370
then the actual body array which will

00:07:50,240 --> 00:07:55,670
contain more nodes like the block

00:07:52,370 --> 00:07:57,290
statement node so you can see that we're

00:07:55,670 --> 00:08:01,390
starting to get the information that

00:07:57,290 --> 00:08:05,240
we'd need to describe the original

00:08:01,390 --> 00:08:08,120
source code and you can imagine that if

00:08:05,240 --> 00:08:10,550
we had a way of modifying this and then

00:08:08,120 --> 00:08:15,950
converting it back into source code we

00:08:10,550 --> 00:08:18,380
could safely make changes to code to our

00:08:15,950 --> 00:08:21,320
source code so by changing the params

00:08:18,380 --> 00:08:23,720
name to Arg 1 and setting a sync to true

00:08:21,320 --> 00:08:27,170
and then converting this back into

00:08:23,720 --> 00:08:29,980
source code somehow we would get a new a

00:08:27,170 --> 00:08:34,580
sync function with a different pram name

00:08:29,980 --> 00:08:37,849
and there's a spec for this yes tree

00:08:34,580 --> 00:08:42,050
spec so st's are everywhere in

00:08:37,849 --> 00:08:45,260
JavaScript babel uses them to transpire

00:08:42,050 --> 00:08:50,450
your code pretty uses them to format

00:08:45,260 --> 00:08:51,560
your codes typescript uses a STS in the

00:08:50,450 --> 00:08:54,860
compiler

00:08:51,560 --> 00:08:59,240
es Flynt uses STS to perform static

00:08:54,860 --> 00:09:02,420
analysis on your code and even view uses

00:08:59,240 --> 00:09:04,490
STS as part of the compilation process

00:09:02,420 --> 00:09:09,949
to generate render functions from

00:09:04,490 --> 00:09:12,920
template strings so STS are super useful

00:09:09,949 --> 00:09:16,519
and they're the core part of how J's

00:09:12,920 --> 00:09:20,689
code ship works so the way that Jesco

00:09:16,519 --> 00:09:22,910
shift works it's a CLI tool I think

00:09:20,689 --> 00:09:25,519
there's a JavaScript API as well but the

00:09:22,910 --> 00:09:29,300
way the I work with is is you run it and

00:09:25,519 --> 00:09:33,709
it will find all of the files matching a

00:09:29,300 --> 00:09:36,079
glob pattern that you give it and it

00:09:33,709 --> 00:09:39,680
will parse each of those files it will

00:09:36,079 --> 00:09:44,089
find the file parse that file into ast

00:09:39,680 --> 00:09:49,459
and then perform a transform to generate

00:09:44,089 --> 00:09:52,939
new ast before printing it back in

00:09:49,459 --> 00:09:58,939
source code and effectively making and

00:09:52,939 --> 00:10:01,339
changing the source code in place so the

00:09:58,939 --> 00:10:05,449
key part of Jesco shift is this

00:10:01,339 --> 00:10:08,629
transform that's the the codes that you

00:10:05,449 --> 00:10:12,129
can write yourself that will modify the

00:10:08,629 --> 00:10:18,559
ast before it's transformed back into

00:10:12,129 --> 00:10:20,809
source code so the transform itself is

00:10:18,559 --> 00:10:23,899
pretty simple jazz coat it has really

00:10:20,809 --> 00:10:27,019
nice syntax a really nice API for

00:10:23,899 --> 00:10:31,670
performing these transforms so for

00:10:27,019 --> 00:10:33,649
example to find all of the to replace

00:10:31,670 --> 00:10:36,339
all of our calls of flattened we would

00:10:33,649 --> 00:10:41,540
first find all of the ast nodes that

00:10:36,339 --> 00:10:44,420
were a call expression that have a

00:10:41,540 --> 00:10:48,920
collie with the name of flatten so

00:10:44,420 --> 00:10:51,860
that's all all of the calls to flatten

00:10:48,920 --> 00:10:56,589
and then for each of those nodes run an

00:10:51,860 --> 00:11:02,059
update function so the update function

00:10:56,589 --> 00:11:04,910
takes a path which is like a wrapper of

00:11:02,059 --> 00:11:09,830
an ast node and

00:11:04,910 --> 00:11:11,630
and then here we're going to get the

00:11:09,830 --> 00:11:18,770
array so the array is the first argument

00:11:11,630 --> 00:11:22,940
of the the cool expression and then

00:11:18,770 --> 00:11:25,580
we'll call this replace function to

00:11:22,940 --> 00:11:29,390
replace the node with a new node that we

00:11:25,580 --> 00:11:31,390
build and you can build nodes in J's

00:11:29,390 --> 00:11:33,920
code shift using these builder functions

00:11:31,390 --> 00:11:40,040
so here you see we're making a new call

00:11:33,920 --> 00:11:45,350
expression which it includes a member

00:11:40,040 --> 00:11:54,320
expression with the array and then we

00:11:45,350 --> 00:11:56,900
have the method name which is flat so by

00:11:54,320 --> 00:11:58,880
running this this transform we would

00:11:56,900 --> 00:12:01,360
find all of the cases where we were

00:11:58,880 --> 00:12:07,430
calling flatten and then convert it into

00:12:01,360 --> 00:12:12,590
an array or a method call of the array

00:12:07,430 --> 00:12:15,110
that flatten was called with so I will

00:12:12,590 --> 00:12:21,830
show you what the process of writing

00:12:15,110 --> 00:12:23,450
these transforms looks like oops so if

00:12:21,830 --> 00:12:29,660
you do any work with a SCS

00:12:23,450 --> 00:12:36,830
ast Explorer is a vital tool so air-sea

00:12:29,660 --> 00:12:40,310
Explorer just gives you a way of seeing

00:12:36,830 --> 00:12:43,900
what effect your transform has on some

00:12:40,310 --> 00:12:46,280
code so in the top left segment we have

00:12:43,900 --> 00:12:53,770
the source code that you want to perform

00:12:46,280 --> 00:12:58,580
a transform on and then to the right we

00:12:53,770 --> 00:13:00,560
have the ast representation so you can

00:12:58,580 --> 00:13:03,080
have it in tree mode which is handy

00:13:00,560 --> 00:13:04,550
because you can click on a node in the

00:13:03,080 --> 00:13:07,400
part of the source code and it will take

00:13:04,550 --> 00:13:09,680
you to the relevant ast node and you

00:13:07,400 --> 00:13:13,010
could also see it in Jason which is less

00:13:09,680 --> 00:13:15,440
useful but yeah you can see the amount

00:13:13,010 --> 00:13:18,280
of information that we have to describe

00:13:15,440 --> 00:13:18,280
this source code

00:13:20,660 --> 00:13:27,230
and then down here we have the actual

00:13:24,320 --> 00:13:29,180
transform so there's loads of different

00:13:27,230 --> 00:13:33,140
transforms that you can run in ASDA

00:13:29,180 --> 00:13:35,690
Explorer you can write Babel transforms

00:13:33,140 --> 00:13:37,880
or es Flint transforms we're going to

00:13:35,690 --> 00:13:40,490
write a J's code shift transform and

00:13:37,880 --> 00:13:45,590
then finally have the result of the

00:13:40,490 --> 00:13:47,300
transform and up here you can see just

00:13:45,590 --> 00:13:50,570
how many other languages are supported

00:13:47,300 --> 00:13:55,430
so ast is everywhere it's not just a

00:13:50,570 --> 00:14:00,170
JavaScript phenomenon so you can use St

00:13:55,430 --> 00:14:02,600
Explorer to write a CSS transform maybe

00:14:00,170 --> 00:14:04,930
with post CSS and there's tons of

00:14:02,600 --> 00:14:07,640
different parses as well so

00:14:04,930 --> 00:14:10,510
Babylon's the babel parser which we will

00:14:07,640 --> 00:14:18,740
be using but there's typescript parser

00:14:10,510 --> 00:14:21,110
flow parser tons of parsers so what I

00:14:18,740 --> 00:14:24,200
want to show you is how we would find

00:14:21,110 --> 00:14:27,320
all of the instances of flatten all of

00:14:24,200 --> 00:14:30,680
the imports of flatten and remove them

00:14:27,320 --> 00:14:34,250
from the source code so down here I have

00:14:30,680 --> 00:14:37,670
my find call where I'm going to find all

00:14:34,250 --> 00:14:41,330
of the import declarations and I'm going

00:14:37,670 --> 00:14:45,110
to use this this filter object to only

00:14:41,330 --> 00:14:52,630
match import declarations with the

00:14:45,110 --> 00:14:55,790
source value of lodash so you can see

00:14:52,630 --> 00:15:00,440
that an import declaration has a source

00:14:55,790 --> 00:15:09,430
node and the value is low - or whatever

00:15:00,440 --> 00:15:12,320
you're importing so I want to remove any

00:15:09,430 --> 00:15:19,400
instances of flatten any imports of

00:15:12,320 --> 00:15:21,230
flatten so the way that it generally

00:15:19,400 --> 00:15:22,610
goes when you're developing with ASDs is

00:15:21,230 --> 00:15:27,280
you have to find out the name of the

00:15:22,610 --> 00:15:30,430
node first so here this is an identifier

00:15:27,280 --> 00:15:32,150
but it's inside an import specifier

00:15:30,430 --> 00:15:33,890
which is on the import

00:15:32,150 --> 00:15:37,220
declaration so the import that creation

00:15:33,890 --> 00:15:40,580
has an array of specifiers so I'm going

00:15:37,220 --> 00:15:46,660
to create some new specifiers by

00:15:40,580 --> 00:15:46,660
filtering the current specifiers

00:15:54,250 --> 00:16:06,990
and so a specifier has imported property

00:16:01,350 --> 00:16:11,710
with a name so I'm going to filter and

00:16:06,990 --> 00:16:16,990
get all specifies that aren't that don't

00:16:11,710 --> 00:16:25,300
have a name of flatten and then I can

00:16:16,990 --> 00:16:29,470
update the specifiers whoops with my

00:16:25,300 --> 00:16:32,860
filter specifiers and remove that import

00:16:29,470 --> 00:16:35,890
so that's really cool obviously I've got

00:16:32,860 --> 00:16:39,970
this input low - I don't want that so I

00:16:35,890 --> 00:16:44,710
could just add some extra code to check

00:16:39,970 --> 00:16:54,670
that specifies has a length greater than

00:16:44,710 --> 00:16:58,680
zero and then if it doesn't then I just

00:16:54,670 --> 00:17:07,450
want to remove the node from the tree so

00:16:58,680 --> 00:17:10,540
path prune cool so that's how easy it is

00:17:07,450 --> 00:17:13,900
to write a transform to do something

00:17:10,540 --> 00:17:14,560
that's pretty complex like it's quite

00:17:13,900 --> 00:17:18,280
difficult

00:17:14,560 --> 00:17:19,420
there's lots different things that you

00:17:18,280 --> 00:17:22,810
need to consider if you're trying to

00:17:19,420 --> 00:17:25,300
write this with the regex but if you

00:17:22,810 --> 00:17:27,550
were editing the ast directly the posit

00:17:25,300 --> 00:17:31,480
does all of the hard work it converts it

00:17:27,550 --> 00:17:33,850
into this ast and you can just do the

00:17:31,480 --> 00:17:36,600
relatively easy work of changing some

00:17:33,850 --> 00:17:41,700
values in it so you can perform these

00:17:36,600 --> 00:17:41,700
three factors safely

00:17:44,789 --> 00:17:53,190
so if you decide to write a chance form

00:17:48,450 --> 00:17:55,929
JH coach it has awesome testing utils so

00:17:53,190 --> 00:17:57,490
testing is always difficult but with

00:17:55,929 --> 00:18:00,100
Jesco shift it's kind of a solved

00:17:57,490 --> 00:18:03,490
problem they export this test utils

00:18:00,100 --> 00:18:06,580
library and you simply define a test

00:18:03,490 --> 00:18:10,750
pass it in the current directory name

00:18:06,580 --> 00:18:15,039
and the name of your transform and then

00:18:10,750 --> 00:18:16,750
you just write a input file that has all

00:18:15,039 --> 00:18:20,590
of the source code that you want to

00:18:16,750 --> 00:18:23,980
input into your transform and then

00:18:20,590 --> 00:18:26,289
create an output file that has the

00:18:23,980 --> 00:18:31,000
desired output of your transform and

00:18:26,289 --> 00:18:33,549
then when you run the test your J's code

00:18:31,000 --> 00:18:35,980
shift is going to perform a transform on

00:18:33,549 --> 00:18:39,100
your input and then compare it against

00:18:35,980 --> 00:18:45,759
this output and error if it doesn't

00:18:39,100 --> 00:18:48,639
match so yet jerez code shift is a great

00:18:45,759 --> 00:18:52,029
tool to write code mods by editing the

00:18:48,639 --> 00:18:55,389
AST and there's loads of uses for it so

00:18:52,029 --> 00:18:57,279
internal refractor inc is it's a lot

00:18:55,389 --> 00:19:00,370
quicker and safer if you have large code

00:18:57,279 --> 00:19:03,600
bases and you've written a transform

00:19:00,370 --> 00:19:07,750
it's really quick to just run it and

00:19:03,600 --> 00:19:11,259
update all your code and do a quick

00:19:07,750 --> 00:19:12,820
refactor on a large code base another

00:19:11,259 --> 00:19:15,279
use of them is to improve migration

00:19:12,820 --> 00:19:19,929
paths so the way I actually discovered

00:19:15,279 --> 00:19:22,919
transforms is when I moved my tests from

00:19:19,929 --> 00:19:25,809
maka over to jest and Jess has a load of

00:19:22,919 --> 00:19:29,559
code mods the designed specifically to

00:19:25,809 --> 00:19:31,330
transform codes written like your test

00:19:29,559 --> 00:19:34,899
written with maka or another testing

00:19:31,330 --> 00:19:37,690
framework in de Geste and that meant

00:19:34,899 --> 00:19:40,600
that I could move all of my tests over

00:19:37,690 --> 00:19:42,779
from using maka digest in a couple of

00:19:40,600 --> 00:19:44,889
hours which was amazing

00:19:42,779 --> 00:19:46,990
and the other thing about writing

00:19:44,889 --> 00:19:50,049
transforms is you learn a st's which is

00:19:46,990 --> 00:19:52,090
a really cool power because once you

00:19:50,049 --> 00:19:55,269
know how to write once you understand

00:19:52,090 --> 00:19:57,370
Orestes and you know how to use esti

00:19:55,269 --> 00:19:57,639
Explorer to write your transforms you

00:19:57,370 --> 00:19:59,859
can

00:19:57,639 --> 00:20:02,559
really quickly right yes Linton plugins

00:19:59,859 --> 00:20:05,919
custom air slim plugins or custom Babel

00:20:02,559 --> 00:20:07,450
plugins so you could have rules

00:20:05,919 --> 00:20:10,869
yes minute rules that are specific to

00:20:07,450 --> 00:20:16,599
your codebase just by writing a quick

00:20:10,869 --> 00:20:18,159
transform using air sea explorer so yeah

00:20:16,599 --> 00:20:22,149
thanks guys that's about all I had to

00:20:18,159 --> 00:20:24,070
say about JSK shift and hopefully that's

00:20:22,149 --> 00:20:26,919
inspired some of you to go and give it a

00:20:24,070 --> 00:20:28,690
try oh I've added some resources here so

00:20:26,919 --> 00:20:34,089
I think we'll get the slides sent round

00:20:28,690 --> 00:20:38,850
maybe on the meetup group and yeah go

00:20:34,089 --> 00:20:44,380
and do some refactoring with J's code

00:20:38,850 --> 00:20:44,380

YouTube URL: https://www.youtube.com/watch?v=1X9p-RUUkak


