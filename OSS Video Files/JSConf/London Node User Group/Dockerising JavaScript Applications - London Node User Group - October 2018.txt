Title: Dockerising JavaScript Applications - London Node User Group - October 2018
Publication date: 2018-11-02
Playlist: London Node User Group
Description: 
	Presented by Daniel Li.

Docker is an ecosystem that allows you to work with containers. Whilst the initial learning curve can be steep, it can ultimately make your development and deployment cycles much faster.

In this talk, I will show you how to deploy a simple front- and back-end application using Docker, and show how much faster it is than the traditional, more manual approach.
_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:03,899
so yes you know I'm gonna talk to you

00:00:01,770 --> 00:00:06,180
about dr. Isaac Jaffee applications a

00:00:03,899 --> 00:00:08,700
bit about me and what come next mo

00:00:06,180 --> 00:00:12,300
we provide api's for you guys to send

00:00:08,700 --> 00:00:14,940
SMS to do voice calls to do verification

00:00:12,300 --> 00:00:16,680
via SMS in like Facebook messages

00:00:14,940 --> 00:00:21,390
anything you can think of communication

00:00:16,680 --> 00:00:23,580
we can do it I wrote a book it basically

00:00:21,390 --> 00:00:25,500
guides you through how to do TDD C I

00:00:23,580 --> 00:00:27,150
continue ization orchestration from

00:00:25,500 --> 00:00:29,580
scratch so you build a very simple

00:00:27,150 --> 00:00:32,730
application and it uses all these tools

00:00:29,580 --> 00:00:36,630
to help you make it for a robust you can

00:00:32,730 --> 00:00:41,070
you can buy here I don't have that much

00:00:36,630 --> 00:00:43,320
money so any royalties is cool so what

00:00:41,070 --> 00:00:44,730
we're going to go through today so first

00:00:43,320 --> 00:00:46,530
we're just gonna build a very simple

00:00:44,730 --> 00:00:49,320
application we're going to deploy the

00:00:46,530 --> 00:00:51,059
traditional manual way and then we're

00:00:49,320 --> 00:00:53,489
going to discuss what problem this poses

00:00:51,059 --> 00:00:57,180
and then I'm going to introduce you to

00:00:53,489 --> 00:01:00,030
containers and docker and deploy the

00:00:57,180 --> 00:01:01,739
same application using docker and then

00:01:00,030 --> 00:01:04,830
we're going to look at what problems

00:01:01,739 --> 00:01:05,939
this souls and the second half the last

00:01:04,830 --> 00:01:09,600
ten minutes of the talk is going to be

00:01:05,939 --> 00:01:11,790
about optimizing the docker image so

00:01:09,600 --> 00:01:13,950
this is the application I'm going to be

00:01:11,790 --> 00:01:15,390
building so basically has the front end

00:01:13,950 --> 00:01:16,049
a back end in the database using

00:01:15,390 --> 00:01:19,020
elasticsearch

00:01:16,049 --> 00:01:21,210
in the front end it's basically just a

00:01:19,020 --> 00:01:23,400
text area you press a button it

00:01:21,210 --> 00:01:24,869
generates a JSON object you submit it it

00:01:23,400 --> 00:01:28,950
goes to the backend which saves in a

00:01:24,869 --> 00:01:31,290
database so this is how you would deploy

00:01:28,950 --> 00:01:33,540
it manually first you have to install

00:01:31,290 --> 00:01:34,979
node then you have to install a

00:01:33,540 --> 00:01:39,000
elasticsearch which is based in java

00:01:34,979 --> 00:01:42,329
which is a space in java and then you

00:01:39,000 --> 00:01:43,670
download the repository run the

00:01:42,329 --> 00:01:50,820
installation script and then run your

00:01:43,670 --> 00:01:56,490
application so this is what you have to

00:01:50,820 --> 00:02:03,110
do so first you have to start

00:01:56,490 --> 00:02:03,110
elasticsearch and get the password right

00:02:05,229 --> 00:02:12,800
and then you run the front end I don't

00:02:10,910 --> 00:02:20,569
have internet but it should be cached I

00:02:12,800 --> 00:02:22,580
hope and then you run the back end so to

00:02:20,569 --> 00:02:25,370
make sure that it works let's send a car

00:02:22,580 --> 00:02:30,680
request to the back end and I should

00:02:25,370 --> 00:02:33,230
just return with JSON array of all the

00:02:30,680 --> 00:02:35,930
objects that we have and then if we open

00:02:33,230 --> 00:02:38,120
the browser we can see that the same

00:02:35,930 --> 00:02:42,680
object is there we can generate a new

00:02:38,120 --> 00:02:47,540
one summit it generate a new one submit

00:02:42,680 --> 00:02:53,989
it and we go back to the backend can't

00:02:47,540 --> 00:02:56,269
really we curl it again and you can see

00:02:53,989 --> 00:02:58,310
is updated so basically this

00:02:56,269 --> 00:02:59,569
demonstration just shows that the phone

00:02:58,310 --> 00:03:02,780
and can talk to the backend can touch

00:02:59,569 --> 00:03:06,769
with the debate the database so what was

00:03:02,780 --> 00:03:09,019
wrong with that approach first there's a

00:03:06,769 --> 00:03:10,519
lot of consistency right it works on my

00:03:09,019 --> 00:03:12,889
machine because I use Linux because it's

00:03:10,519 --> 00:03:14,630
good but then if you give it to other

00:03:12,889 --> 00:03:17,870
people they use Mac for some reason and

00:03:14,630 --> 00:03:19,870
then it doesn't work so that's a problem

00:03:17,870 --> 00:03:22,609
lack of independence

00:03:19,870 --> 00:03:24,799
so my application uses elasticsearch

00:03:22,609 --> 00:03:26,480
right what if I have two applications

00:03:24,799 --> 00:03:28,910
one uses it lasted step six point three

00:03:26,480 --> 00:03:30,650
point two and then another one uses six

00:03:28,910 --> 00:03:33,680
point four point two or something right

00:03:30,650 --> 00:03:36,799
do I have to change the path or like

00:03:33,680 --> 00:03:39,500
uninstall reinstall elasticsearch to to

00:03:36,799 --> 00:03:44,470
work on different projects that sounds

00:03:39,500 --> 00:03:46,940
really backwards it's time-consuming I

00:03:44,470 --> 00:03:48,440
did a lot of installation before already

00:03:46,940 --> 00:03:50,690
but if you have to do it from scratch

00:03:48,440 --> 00:03:52,160
installing node installing Java that's

00:03:50,690 --> 00:03:54,829
going to take at least ten minutes even

00:03:52,160 --> 00:03:57,079
if you do it every day it's error-prone

00:03:54,829 --> 00:03:58,609
I'm so glad I didn't make a mistake for

00:03:57,079 --> 00:04:01,370
like in previous runtime Middle's

00:03:58,609 --> 00:04:04,609
mistakes because I'm human and everyone

00:04:01,370 --> 00:04:07,549
makes mistakes it's difficult to

00:04:04,609 --> 00:04:10,189
maintain right now it's only in the

00:04:07,549 --> 00:04:12,290
development environment what if you have

00:04:10,189 --> 00:04:13,370
one in production in staging you

00:04:12,290 --> 00:04:15,569
shouldn't have staging but if you do

00:04:13,370 --> 00:04:18,690
staging playground environment

00:04:15,569 --> 00:04:21,449
and then if you want to upgrade a piece

00:04:18,690 --> 00:04:22,740
of software or library you do that for

00:04:21,449 --> 00:04:26,310
every single environment and that's

00:04:22,740 --> 00:04:28,110
going to be a hassle right now I'm

00:04:26,310 --> 00:04:30,270
running it on my machine or you can run

00:04:28,110 --> 00:04:32,940
it in a server and if the server goes

00:04:30,270 --> 00:04:36,630
down everything goes down right and

00:04:32,940 --> 00:04:37,500
lastly we can we firstly control

00:04:36,630 --> 00:04:39,810
everything with version control

00:04:37,500 --> 00:04:43,169
application so why don't we first and

00:04:39,810 --> 00:04:45,360
control our deployment as well so this

00:04:43,169 --> 00:04:48,030
is where container comes in containers

00:04:45,360 --> 00:04:49,949
are a method of virtualization this kind

00:04:48,030 --> 00:04:52,080
of like you have this little kind of

00:04:49,949 --> 00:04:54,120
confined space and then you can run

00:04:52,080 --> 00:04:56,160
everything inside it if you're familiar

00:04:54,120 --> 00:04:58,380
with virtual machines is kind of like

00:04:56,160 --> 00:05:00,449
that but a lighter version of it

00:04:58,380 --> 00:05:02,550
it uses Linux containers which is like a

00:05:00,449 --> 00:05:05,630
feature that is built into the Linux

00:05:02,550 --> 00:05:07,470
kernel like just over a decade ago

00:05:05,630 --> 00:05:11,009
internally you just see groups of

00:05:07,470 --> 00:05:14,130
namespaces so all that does is it groups

00:05:11,009 --> 00:05:18,660
processes processes together and then a

00:05:14,130 --> 00:05:22,590
package resources like memory CPU time

00:05:18,660 --> 00:05:25,199
and process IDs the packages all that

00:05:22,590 --> 00:05:28,229
stuff in underneath presents to this

00:05:25,199 --> 00:05:30,870
group of processes and from the

00:05:28,229 --> 00:05:33,120
viewpoint of these processes this pack

00:05:30,870 --> 00:05:35,909
this packet of resources or you can see

00:05:33,120 --> 00:05:38,759
so even if my computer has 24 gigabytes

00:05:35,909 --> 00:05:41,880
of RAM which it does if I just present

00:05:38,759 --> 00:05:47,310
four gigabytes to my container you can

00:05:41,880 --> 00:05:48,599
only use that for gigabit of around what

00:05:47,310 --> 00:05:50,400
you can do a containers is you can

00:05:48,599 --> 00:05:53,220
package everything or your dependencies

00:05:50,400 --> 00:05:55,169
inside a container so that when you run

00:05:53,220 --> 00:05:56,460
your application all you have to do is

00:05:55,169 --> 00:05:59,340
run the container you don't have to

00:05:56,460 --> 00:06:01,020
install any additional libraries so this

00:05:59,340 --> 00:06:02,520
is just a diagram I got from somewhere I

00:06:01,020 --> 00:06:05,930
should really actually put the image but

00:06:02,520 --> 00:06:08,789
I didn't of the difference between a

00:06:05,930 --> 00:06:13,400
running applications on your machine

00:06:08,789 --> 00:06:16,259
versus in containers so what is docker

00:06:13,400 --> 00:06:18,990
people think docker is a container

00:06:16,259 --> 00:06:21,659
format but is not the latest container

00:06:18,990 --> 00:06:24,000
is a feature that was only implemented

00:06:21,659 --> 00:06:27,449
ten years ago so in the grand scheme of

00:06:24,000 --> 00:06:29,100
thing is quite new so Dockers not trying

00:06:27,449 --> 00:06:31,620
to reinvent the wheel

00:06:29,100 --> 00:06:34,890
does is is provide a standard way of

00:06:31,620 --> 00:06:36,810
defining and running the containers so

00:06:34,890 --> 00:06:40,550
for defining it has the docker file

00:06:36,810 --> 00:06:44,310
format if you use that format you can

00:06:40,550 --> 00:06:46,740
you can run you can use docker built to

00:06:44,310 --> 00:06:48,600
build any image using that format and if

00:06:46,740 --> 00:06:50,340
I have a docker image I can give it to

00:06:48,600 --> 00:06:52,470
you and as long as you have darker

00:06:50,340 --> 00:06:55,350
installed on your machine you can run

00:06:52,470 --> 00:06:57,750
the image as well so just standard way

00:06:55,350 --> 00:07:00,360
of doing things it also provides the

00:06:57,750 --> 00:07:03,090
ecosystem so it has Tucker hub which is

00:07:00,360 --> 00:07:04,950
like the NPM registry for docker images

00:07:03,090 --> 00:07:09,420
it's just upload your image from that if

00:07:04,950 --> 00:07:10,880
people like it they will use it so how

00:07:09,420 --> 00:07:13,560
do you work with docker

00:07:10,880 --> 00:07:15,810
so before in the manual approach we run

00:07:13,560 --> 00:07:17,850
everything on the command line with

00:07:15,810 --> 00:07:20,100
docker you specify all your commands in

00:07:17,850 --> 00:07:22,830
a docker file so instead of running NPM

00:07:20,100 --> 00:07:24,990
installing the command line you you you

00:07:22,830 --> 00:07:30,390
add a line in the in your doctor file to

00:07:24,990 --> 00:07:32,820
say run npm install then you use the dr

00:07:30,390 --> 00:07:35,400
CLI to to build an image and all that

00:07:32,820 --> 00:07:38,370
does is it goes through each line of

00:07:35,400 --> 00:07:41,340
your docker file and line by line it

00:07:38,370 --> 00:07:44,340
will build up a layer to build up your

00:07:41,340 --> 00:07:46,110
image so at the end of the build the

00:07:44,340 --> 00:07:47,970
image is basically what would have

00:07:46,110 --> 00:07:51,060
happened if you run it manually anyways

00:07:47,970 --> 00:07:57,050
and then you use docker run to run your

00:07:51,060 --> 00:07:59,160
image so let's go back to our

00:07:57,050 --> 00:08:03,630
application and see how we can deploy it

00:07:59,160 --> 00:08:04,980
using docker and as you can see like all

00:08:03,630 --> 00:08:10,770
you need to do is dock a build and

00:08:04,980 --> 00:08:12,660
docker run so instead of using a instead

00:08:10,770 --> 00:08:15,330
of running all the node installation

00:08:12,660 --> 00:08:18,150
script yourself you can just pull in one

00:08:15,330 --> 00:08:19,950
that it's already made for you from the

00:08:18,150 --> 00:08:21,780
docker hub the same thing for your

00:08:19,950 --> 00:08:26,760
lastik search you don't need to do

00:08:21,780 --> 00:08:29,550
anything just pull it down and yeah i'll

00:08:26,760 --> 00:08:32,180
show you how to do it in my other

00:08:29,550 --> 00:08:32,180
workspace

00:08:33,280 --> 00:08:51,970
so and I'll ignore that so I pull the

00:08:45,400 --> 00:08:55,530
image beforehand yeah okay this is the

00:08:51,970 --> 00:08:55,530
cleanup step we shall have them run

00:09:05,990 --> 00:09:14,070
right so everything we did before was

00:09:09,060 --> 00:09:19,230
finished and I'll run it again again I

00:09:14,070 --> 00:09:24,029
don't need to set anything up because

00:09:19,230 --> 00:09:31,950
I'm already running it this is why you

00:09:24,029 --> 00:09:34,880
don't do live demos it's better when

00:09:31,950 --> 00:09:34,880
you're drunk okay

00:09:35,840 --> 00:09:39,839
[Music]

00:09:37,130 --> 00:09:42,060
right so I don't do anything I just put

00:09:39,839 --> 00:09:45,330
on the image and I'm running it dr. pol

00:09:42,060 --> 00:09:47,940
and dr. on again for the backhand I

00:09:45,330 --> 00:09:49,320
don't you do anything just pretend the

00:09:47,940 --> 00:10:02,000
network is working and you're pulling it

00:09:49,320 --> 00:10:07,529
down so again it's just docker build and

00:10:02,000 --> 00:10:14,540
docker run right same thing for the

00:10:07,529 --> 00:10:14,540
front end docker build and dr. run

00:10:18,780 --> 00:10:22,980
if we curl again this time because it's

00:10:21,360 --> 00:10:28,760
a new container and everything is an

00:10:22,980 --> 00:10:28,760
empty array if we go to the browser

00:10:29,990 --> 00:10:38,910
generate something we submit something

00:10:32,900 --> 00:10:42,030
it should come back on the back end so

00:10:38,910 --> 00:10:42,750
basically everything we did before we

00:10:42,030 --> 00:10:46,350
just did it again

00:10:42,750 --> 00:10:49,580
but with containers and it wasn't very

00:10:46,350 --> 00:10:52,950
hard it was just docket build docker run

00:10:49,580 --> 00:10:56,430
so why is this better than a previous

00:10:52,950 --> 00:10:59,970
approach it provides consistency through

00:10:56,430 --> 00:11:02,250
portability because the docker image can

00:10:59,970 --> 00:11:04,440
be run anywhere the house doctor

00:11:02,250 --> 00:11:07,140
installed if it wasn't my machine you

00:11:04,440 --> 00:11:08,790
will work on your machine it provides

00:11:07,140 --> 00:11:11,400
independence if I want to run multiple

00:11:08,790 --> 00:11:14,130
instances or different projects using

00:11:11,400 --> 00:11:17,190
different elasticsearch versions I can

00:11:14,130 --> 00:11:20,640
just have two different elasticsearch

00:11:17,190 --> 00:11:23,160
images it saves time and it reduces

00:11:20,640 --> 00:11:25,770
error because I took the human side out

00:11:23,160 --> 00:11:28,680
of it I have to do is doctoral dr. bill

00:11:25,770 --> 00:11:31,620
docker run so all the logic of the

00:11:28,680 --> 00:11:34,860
deployment is specified in the code it's

00:11:31,620 --> 00:11:36,750
easier to maintain editing out docker

00:11:34,860 --> 00:11:40,830
file is much easier than go into every

00:11:36,750 --> 00:11:44,490
single server and running the upgrade it

00:11:40,830 --> 00:11:47,870
doesn't eliminate downtime but us Beth

00:11:44,490 --> 00:11:52,200
and sorry I forgot the other IVM people

00:11:47,870 --> 00:11:54,600
but they've said like for you to use

00:11:52,200 --> 00:11:56,970
like orchestration tools like cuban at

00:11:54,600 --> 00:11:58,860
ease then you have to kind of

00:11:56,970 --> 00:12:01,050
containerize your application

00:11:58,860 --> 00:12:02,730
so although containerized in your

00:12:01,050 --> 00:12:05,460
application doesn't eliminate downtime

00:12:02,730 --> 00:12:07,620
it allows you to later on deploy

00:12:05,460 --> 00:12:09,960
application on the cluster which will

00:12:07,620 --> 00:12:13,950
eliminate downtime and ensure high

00:12:09,960 --> 00:12:15,690
availability last but definitely not

00:12:13,950 --> 00:12:20,280
least it allows you to first and control

00:12:15,690 --> 00:12:24,060
your deployment process so it can be a

00:12:20,280 --> 00:12:26,339
collaborative process and more people

00:12:24,060 --> 00:12:28,770
can keep an eye on it and make it better

00:12:26,339 --> 00:12:31,339
I don't know how much time I have but

00:12:28,770 --> 00:12:34,939
I'm I don't care

00:12:31,339 --> 00:12:38,579
so the last time it is going to be about

00:12:34,939 --> 00:12:40,079
optimizing your docker images so this is

00:12:38,579 --> 00:12:42,089
the one I want to pick the front end

00:12:40,079 --> 00:12:44,639
because it's easier to demonstrate stuff

00:12:42,089 --> 00:12:47,730
so this is a docker file half at the

00:12:44,639 --> 00:12:50,730
moment basically it's just copying

00:12:47,730 --> 00:12:54,269
everything into the container installing

00:12:50,730 --> 00:12:56,189
it building it and then serving it so

00:12:54,269 --> 00:12:59,069
the first thing the first thing you

00:12:56,189 --> 00:13:01,889
should know is that in inside docker

00:12:59,069 --> 00:13:04,379
file you can specify a command using two

00:13:01,889 --> 00:13:06,449
different syntax the first is a shell

00:13:04,379 --> 00:13:08,220
form which that we have already and then

00:13:06,449 --> 00:13:12,239
the other one is the exact form which is

00:13:08,220 --> 00:13:14,939
this so difference between them is when

00:13:12,239 --> 00:13:17,999
you specify using the shell phone dr.

00:13:14,939 --> 00:13:21,359
will run first a shell and then you use

00:13:17,999 --> 00:13:24,209
that shell to run your command with the

00:13:21,359 --> 00:13:26,549
exact form it will it will execute your

00:13:24,209 --> 00:13:29,910
command directly as the first process

00:13:26,549 --> 00:13:32,220
with PID 1 so why does that matter it

00:13:29,910 --> 00:13:35,249
just seems like we save one process and

00:13:32,220 --> 00:13:37,739
use this slightly less memory it's not

00:13:35,249 --> 00:13:45,319
really important what's important is the

00:13:37,739 --> 00:13:48,179
signaling so so the PID one in any any

00:13:45,319 --> 00:13:53,279
PID namespace or on your machine has a

00:13:48,179 --> 00:13:56,610
special role it's there it's the first

00:13:53,279 --> 00:14:00,989
process so if it shuts down every other

00:13:56,610 --> 00:14:03,419
processes gets killed so when we run

00:14:00,989 --> 00:14:05,610
docker stop for example what the what

00:14:03,419 --> 00:14:08,610
the docker Damon does is it sends a sick

00:14:05,610 --> 00:14:12,809
term signal to the PID one process which

00:14:08,610 --> 00:14:15,089
is the shell the thing is with this the

00:14:12,809 --> 00:14:16,019
shadow doesn't do anything it doesn't

00:14:15,089 --> 00:14:17,879
propagate that error

00:14:16,019 --> 00:14:21,660
it doesn't probably get a signal onto

00:14:17,879 --> 00:14:25,829
the NPM or the node process it just sits

00:14:21,660 --> 00:14:29,699
there so you can see here if I try to

00:14:25,829 --> 00:14:32,279
run docker stop on this shell from this

00:14:29,699 --> 00:14:35,399
image that was built using our current

00:14:32,279 --> 00:14:39,209
docker image file it takes ten seconds

00:14:35,399 --> 00:14:41,730
for it to shut down and that's because

00:14:39,209 --> 00:14:44,549
after a receiver sick terms you know it

00:14:41,730 --> 00:14:45,020
just hangs there and docker waits for

00:14:44,549 --> 00:14:47,750
about ten

00:14:45,020 --> 00:14:49,190
seconds until it gives up and say you're

00:14:47,750 --> 00:14:51,770
not doing anything let's kill it with a

00:14:49,190 --> 00:14:54,140
sick kill and if you sick kill a process

00:14:51,770 --> 00:14:56,090
it doesn't it cannot handle it right

00:14:54,140 --> 00:14:59,690
because the cure is done by the kernel

00:14:56,090 --> 00:15:01,190
and so your process exits in gracefully

00:14:59,690 --> 00:15:04,610
and then clean II cannot clean up after

00:15:01,190 --> 00:15:09,140
yourself if you use the exact form

00:15:04,610 --> 00:15:10,670
however the sick term is sent to the PID

00:15:09,140 --> 00:15:15,770
one process which in this case is the

00:15:10,670 --> 00:15:19,070
npm process a node has a has default

00:15:15,770 --> 00:15:22,400
signal handlers and so this will shut

00:15:19,070 --> 00:15:24,050
down like immediately almost and so

00:15:22,400 --> 00:15:30,110
instead of waiting for 10 seconds for it

00:15:24,050 --> 00:15:31,790
to stop it takes just half a second so

00:15:30,110 --> 00:15:39,620
now we're using the exec form what else

00:15:31,790 --> 00:15:43,910
can we do so a lot of us run our surf

00:15:39,620 --> 00:15:47,390
script using MPM scripts and what that

00:15:43,910 --> 00:15:50,200
does is npm runs and then it spawns the

00:15:47,390 --> 00:15:54,710
sub shell which then runs your actual

00:15:50,200 --> 00:15:57,170
application so the first two processes

00:15:54,710 --> 00:15:59,480
doesn't it's not actually needed to run

00:15:57,170 --> 00:16:01,940
your application and if you look at the

00:15:59,480 --> 00:16:04,520
amount of resources they use is about

00:16:01,940 --> 00:16:06,740
half of what has been using the

00:16:04,520 --> 00:16:11,240
container so at this one calculation and

00:16:06,740 --> 00:16:15,980
it takes about 50 - maybe bytes to run

00:16:11,240 --> 00:16:19,040
npm s section node commands however if

00:16:15,980 --> 00:16:22,510
we just run the node everyone just if we

00:16:19,040 --> 00:16:25,010
just run the HTTP server directly then

00:16:22,510 --> 00:16:29,750
only that process is run in the

00:16:25,010 --> 00:16:32,510
container and that only takes 36 maybe

00:16:29,750 --> 00:16:33,530
bytes so it doesn't sound like a lot but

00:16:32,510 --> 00:16:37,070
if you're running thousands of these

00:16:33,530 --> 00:16:40,750
containers all the time then us that can

00:16:37,070 --> 00:16:40,750
be like hundreds of gigabytes of RAM

00:16:40,840 --> 00:16:50,960
next as Beth mentioned docker caches

00:16:46,660 --> 00:16:52,790
images when you build them but it can

00:16:50,960 --> 00:16:55,010
only do that up to the point where I

00:16:52,790 --> 00:16:57,270
sees a difference so let's say we make a

00:16:55,010 --> 00:17:00,779
small change in our repository

00:16:57,270 --> 00:17:02,450
let's just like a typo change I spell

00:17:00,779 --> 00:17:08,429
generate wrong and once it's about right

00:17:02,450 --> 00:17:10,290
so in our current version because in the

00:17:08,429 --> 00:17:12,990
copy instruction dr. noticed something

00:17:10,290 --> 00:17:15,720
has changed so so it will invalidate the

00:17:12,990 --> 00:17:18,480
cache for all the subsequent steps so

00:17:15,720 --> 00:17:20,640
and they can only make use of the cache

00:17:18,480 --> 00:17:23,670
in the second step which is a very light

00:17:20,640 --> 00:17:25,949
step so basically it's building

00:17:23,670 --> 00:17:27,900
everything from scratch and ten seconds

00:17:25,949 --> 00:17:30,420
is how long it takes and this is using

00:17:27,900 --> 00:17:33,360
like the one gigabit connection in my

00:17:30,420 --> 00:17:35,280
office and if I try to run it in my in

00:17:33,360 --> 00:17:38,400
my home network it will take about 30

00:17:35,280 --> 00:17:41,429
seconds or a minute so that stuff is not

00:17:38,400 --> 00:17:43,530
good for development so instead of

00:17:41,429 --> 00:17:46,320
copying everything we should just copy

00:17:43,530 --> 00:17:48,840
what we need for the next step to run so

00:17:46,320 --> 00:17:50,490
npm install we don't really need the

00:17:48,840 --> 00:17:52,200
source code so we'll just leave it out

00:17:50,490 --> 00:17:57,030
we just need a package.json and the

00:17:52,200 --> 00:18:00,120
package lot of JSON so now docker can

00:17:57,030 --> 00:18:02,130
cache more things so instead of running

00:18:00,120 --> 00:18:05,360
npm install again which is arguably the

00:18:02,130 --> 00:18:07,950
the longest process in the whole thing

00:18:05,360 --> 00:18:09,840
it can just skip that step and use the

00:18:07,950 --> 00:18:14,670
cache instead and all i have to do is

00:18:09,840 --> 00:18:17,130
run npm build we still take some time

00:18:14,670 --> 00:18:25,950
but we went down from 10 seconds to 3

00:18:17,130 --> 00:18:28,440
seconds next removing obsolete files so

00:18:25,950 --> 00:18:31,220
right now our docker image is 700 and 4

00:18:28,440 --> 00:18:33,929
megabytes which is huge

00:18:31,220 --> 00:18:36,059
but if we go inside the container we can

00:18:33,929 --> 00:18:38,210
see that a lot of the stuff is not

00:18:36,059 --> 00:18:39,870
actually needed right with builds our

00:18:38,210 --> 00:18:42,090
application we don't need the source

00:18:39,870 --> 00:18:44,580
code anymore right we don't need this

00:18:42,090 --> 00:18:47,850
MPM cache anymore all we need is the

00:18:44,580 --> 00:18:52,380
thing that's highlighted in red so how

00:18:47,850 --> 00:18:55,140
can we remove everything else a naive

00:18:52,380 --> 00:18:58,980
approach would be to add a new layer to

00:18:55,140 --> 00:19:01,650
remove unnecessary files but if we do

00:18:58,980 --> 00:19:04,080
that we'll see that the image didn't

00:19:01,650 --> 00:19:07,020
decrease in size and that's because each

00:19:04,080 --> 00:19:10,580
layer in the docker image is a diff from

00:19:07,020 --> 00:19:12,590
the previous layer so as if

00:19:10,580 --> 00:19:15,110
the image if the file is already inside

00:19:12,590 --> 00:19:19,280
the image you cannot really delete it

00:19:15,110 --> 00:19:21,580
any layer on top of it is going to even

00:19:19,280 --> 00:19:26,780
up to the file size of the image

00:19:21,580 --> 00:19:31,220
so another naive approach is to have the

00:19:26,780 --> 00:19:33,730
installation script the build script and

00:19:31,220 --> 00:19:36,530
the cleanup script in the same step and

00:19:33,730 --> 00:19:39,050
that does reduce the file size of the

00:19:36,530 --> 00:19:41,060
image but then it also induce or the

00:19:39,050 --> 00:19:42,220
caching stuff with them in the previous

00:19:41,060 --> 00:19:47,960
step

00:19:42,220 --> 00:19:50,720
so what docker I think it's a weak last

00:19:47,960 --> 00:19:54,380
year's done is it allows for multi stage

00:19:50,720 --> 00:19:56,710
builds so in a multi stage build you

00:19:54,380 --> 00:19:58,880
have you can have multiple from

00:19:56,710 --> 00:20:02,030
instructions inside the same docker file

00:19:58,880 --> 00:20:05,600
and each from instruction defines a new

00:20:02,030 --> 00:20:08,750
stage inside a docker file and you can

00:20:05,600 --> 00:20:11,830
copy artifacts from previous stages into

00:20:08,750 --> 00:20:14,870
your stage so here we're just building

00:20:11,830 --> 00:20:17,240
everything and deleting the files we

00:20:14,870 --> 00:20:18,890
don't need we're not actually going to

00:20:17,240 --> 00:20:20,900
use that image we're just going to use

00:20:18,890 --> 00:20:25,070
this image and we're just going to copy

00:20:20,900 --> 00:20:29,420
stuff from the previous stage into this

00:20:25,070 --> 00:20:32,900
stage and running our application so

00:20:29,420 --> 00:20:36,590
here we have all the benefits of caching

00:20:32,900 --> 00:20:40,520
we have our docker file is super

00:20:36,590 --> 00:20:42,170
readable but our image has reduce in

00:20:40,520 --> 00:20:47,570
size by 10 megabytes

00:20:42,170 --> 00:20:53,210
right so the last step

00:20:47,570 --> 00:20:57,830
I mean 694 is still pretty big so and

00:20:53,210 --> 00:21:00,260
that's because underneath the hood the

00:20:57,830 --> 00:21:02,960
node image the node based image is based

00:21:00,260 --> 00:21:05,210
on Debian and it's not just a Debian

00:21:02,960 --> 00:21:07,790
image it has all these build

00:21:05,210 --> 00:21:09,470
dependencies and build tools and it adds

00:21:07,790 --> 00:21:12,890
up to about six hundred and seventy four

00:21:09,470 --> 00:21:15,650
megabytes just for the node itself so

00:21:12,890 --> 00:21:18,230
instead of using Debian which itself is

00:21:15,650 --> 00:21:23,090
one hundred and one megabytes we can use

00:21:18,230 --> 00:21:24,390
a lighter version of Linux which is four

00:21:23,090 --> 00:21:27,930
point four one and thus out

00:21:24,390 --> 00:21:32,210
fine Linux and that doesn't have all the

00:21:27,930 --> 00:21:37,580
build tools it doesn't even have bash

00:21:32,210 --> 00:21:41,550
but it's much lighter so 717 instead of

00:21:37,580 --> 00:21:43,740
674 so all we have to do is basically

00:21:41,550 --> 00:21:47,340
specify different different tag to the

00:21:43,740 --> 00:21:49,500
node image and that will reduce the size

00:21:47,340 --> 00:21:50,970
from what we had originally which is

00:21:49,500 --> 00:21:56,550
seven hundred and something to ninety

00:21:50,970 --> 00:21:58,860
point three so that's like some very

00:21:56,550 --> 00:22:01,470
basic optimization steps there's a lot

00:21:58,860 --> 00:22:03,390
more we wish do and one thing with

00:22:01,470 --> 00:22:06,990
definitely neat to do is to make sure

00:22:03,390 --> 00:22:10,410
that container is secure even inside

00:22:06,990 --> 00:22:12,330
this optimized docker file we're running

00:22:10,410 --> 00:22:15,150
everything as root and you should never

00:22:12,330 --> 00:22:17,010
run anything as root so the next step

00:22:15,150 --> 00:22:19,500
would be to secure your container by

00:22:17,010 --> 00:22:22,770
using a non privileged user there's lots

00:22:19,500 --> 00:22:25,140
of tools online that helps you audit

00:22:22,770 --> 00:22:28,910
your container and find steps you can

00:22:25,140 --> 00:22:31,500
optimize but that's one of the talk and

00:22:28,910 --> 00:22:35,310
just to put everything back into

00:22:31,500 --> 00:22:36,810
perspective if you do want to tip if you

00:22:35,310 --> 00:22:40,380
do want to make use of other cloud

00:22:36,810 --> 00:22:44,150
native stuff like kubernetes and

00:22:40,380 --> 00:22:46,950
Prometheus then the first step is

00:22:44,150 --> 00:22:48,810
containerization this is a trail map

00:22:46,950 --> 00:22:52,440
published by the cloud native computing

00:22:48,810 --> 00:22:53,880
foundation the CN CF and the basic

00:22:52,440 --> 00:22:56,880
guides you through the steps you should

00:22:53,880 --> 00:23:01,080
take to make your application cloud

00:22:56,880 --> 00:23:03,450
native and yeah first thing is

00:23:01,080 --> 00:23:05,550
continuation the second step of CI CD if

00:23:03,450 --> 00:23:06,860
your test doesn't work or you know you

00:23:05,550 --> 00:23:09,600
don't have confident in your test then

00:23:06,860 --> 00:23:13,320
doing orchestration is gonna be painful

00:23:09,600 --> 00:23:14,430
because you're going to apply something

00:23:13,320 --> 00:23:16,740
it's going to fail you don't know it

00:23:14,430 --> 00:23:18,540
don't know why so CI CD comes before

00:23:16,740 --> 00:23:20,490
orchestration and then once you have

00:23:18,540 --> 00:23:21,660
orchestration you should observe it so

00:23:20,490 --> 00:23:24,540
that when something goes wrong you're

00:23:21,660 --> 00:23:27,480
north how it goes wrong but everything

00:23:24,540 --> 00:23:31,170
begins with containerization so continue

00:23:27,480 --> 00:23:33,420
eyes your application lastly it talks

00:23:31,170 --> 00:23:37,930
about my book talks about communities

00:23:33,420 --> 00:23:40,510
and docker and stuff so here's the link

00:23:37,930 --> 00:23:45,660
thank you

00:23:40,510 --> 00:23:45,660

YouTube URL: https://www.youtube.com/watch?v=96KtwRdszuE


