Title: Async Generators in Real Life - London Node User Group - October 2019
Publication date: 2019-11-13
Playlist: London Node User Group
Description: 
	@diogofcunha Async generators in real life

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,250
hi everyone my name is Diogo I'm a

00:00:03,090 --> 00:00:07,379
senior software engineer at Restylane

00:00:05,250 --> 00:00:09,809
and today I'm here to talk to you about

00:00:07,379 --> 00:00:12,719
something I really like which are

00:00:09,809 --> 00:00:19,619
generators does everyone know what the

00:00:12,719 --> 00:00:21,180
generator is ok that's fine so I'm gonna

00:00:19,619 --> 00:00:23,279
give a quick recap about these

00:00:21,180 --> 00:00:27,180
generators and iterators and iterables

00:00:23,279 --> 00:00:29,490
and all these things so an iterator

00:00:27,180 --> 00:00:31,199
basically is something that you can

00:00:29,490 --> 00:00:33,840
iterate over is an object that you can

00:00:31,199 --> 00:00:36,420
iterate over and this fifth feature

00:00:33,840 --> 00:00:38,790
landed on JavaScript a few years ago I

00:00:36,420 --> 00:00:41,520
think two or three years ago and you can

00:00:38,790 --> 00:00:43,649
either define an iteration protocol for

00:00:41,520 --> 00:00:46,620
your objects you can tell it how it

00:00:43,649 --> 00:00:50,969
needs to iterate and or there are some

00:00:46,620 --> 00:00:54,480
newer data structures like maps or sets

00:00:50,969 --> 00:00:56,280
or generators that implement iterator

00:00:54,480 --> 00:00:59,039
behavior this means that you can put a

00:00:56,280 --> 00:01:02,309
for loop in these objects and it will

00:00:59,039 --> 00:01:05,960
just loop over them so it's a narrator

00:01:02,309 --> 00:01:08,820
basically a generator is a function that

00:01:05,960 --> 00:01:11,430
something that functions don't do which

00:01:08,820 --> 00:01:14,070
is to return multiple values on demand a

00:01:11,430 --> 00:01:16,530
function can only return one value a

00:01:14,070 --> 00:01:18,869
normal function which is can be a

00:01:16,530 --> 00:01:22,130
different types but it's just one value

00:01:18,869 --> 00:01:24,780
while generators can yield up to n

00:01:22,130 --> 00:01:28,500
values really up to infinite rounds and

00:01:24,780 --> 00:01:31,890
there is this property that all

00:01:28,500 --> 00:01:34,920
generators are writable by default so

00:01:31,890 --> 00:01:37,799
let's just look at some code this is a

00:01:34,920 --> 00:01:40,409
code for a simple generator so this is a

00:01:37,799 --> 00:01:42,270
generator function the property of this

00:01:40,409 --> 00:01:45,000
function is that when you invoke this

00:01:42,270 --> 00:01:48,299
function won't run this function will in

00:01:45,000 --> 00:01:50,310
reality just create an object which is

00:01:48,299 --> 00:01:52,110
the generator object this is the

00:01:50,310 --> 00:01:54,540
interface that if we use typescript

00:01:52,110 --> 00:01:58,710
because I like Ryan I also like to use

00:01:54,540 --> 00:02:02,460
typescript because it's cool and this is

00:01:58,710 --> 00:02:04,950
what's gonna return so today I'm gonna

00:02:02,460 --> 00:02:09,360
base my talking to things which are the

00:02:04,950 --> 00:02:11,879
next and iterator so let's look at this

00:02:09,360 --> 00:02:13,780
function when we are in the call stack

00:02:11,879 --> 00:02:18,360
executing the first argument

00:02:13,780 --> 00:02:18,360
does anyone know what this will return

00:02:19,470 --> 00:02:28,300
so it returns zero in the value property

00:02:24,190 --> 00:02:31,300
and done as false next statement more or

00:02:28,300 --> 00:02:36,250
less the same thing it goes there value

00:02:31,300 --> 00:02:39,310
one done false next statement poly -

00:02:36,250 --> 00:02:41,200
don't force and for the last statement

00:02:39,310 --> 00:02:43,540
is gonna tell us that the value is three

00:02:41,200 --> 00:02:46,600
and that it is done when you iterate

00:02:43,540 --> 00:02:50,230
over you don't get this done you only

00:02:46,600 --> 00:02:53,320
get the value directly so when you do

00:02:50,230 --> 00:02:57,010
this as synchronously this is this I

00:02:53,320 --> 00:03:00,400
think landed one year ago I'm not sure

00:02:57,010 --> 00:03:02,110
but to be honest I used easy notate just

00:03:00,400 --> 00:03:04,990
by using typescript and poly filling

00:03:02,110 --> 00:03:06,520
everything so this is the same but

00:03:04,990 --> 00:03:08,650
instead of returning a value this

00:03:06,520 --> 00:03:11,380
returns a promise of a value so it's

00:03:08,650 --> 00:03:13,150
exactly the same code and doing it in a

00:03:11,380 --> 00:03:14,740
for loop and yielding in the for loop is

00:03:13,150 --> 00:03:18,100
exact same thing as we were doing before

00:03:14,740 --> 00:03:20,800
just now this is a synchronous and you

00:03:18,100 --> 00:03:22,300
call it with the nice await keywords and

00:03:20,800 --> 00:03:23,920
now you look at this and say yeah I'm

00:03:22,300 --> 00:03:25,959
not impressed what this is good for

00:03:23,920 --> 00:03:27,430
because that's what most people think

00:03:25,959 --> 00:03:29,410
and that's what I thought when I look

00:03:27,430 --> 00:03:31,150
into this I thought oh this is just one

00:03:29,410 --> 00:03:33,600
more shiny object that we are adding to

00:03:31,150 --> 00:03:37,150
JavaScript that no one will actually use

00:03:33,600 --> 00:03:39,610
so let's get to some practical examples

00:03:37,150 --> 00:03:42,250
so let's talk a little bit about streams

00:03:39,610 --> 00:03:44,739
if you ask me what if stream is or

00:03:42,250 --> 00:03:46,390
almost any one strings are really wild

00:03:44,739 --> 00:03:48,700
and no one really knows what they are

00:03:46,390 --> 00:03:51,160
except for a few selected individuals

00:03:48,700 --> 00:03:54,250
but they are just the collection of data

00:03:51,160 --> 00:03:57,070
as strings and as numbers and the only

00:03:54,250 --> 00:03:59,230
difference is that you can they don't

00:03:57,070 --> 00:04:02,620
need memory allocation when they are

00:03:59,230 --> 00:04:05,080
running and they are not always

00:04:02,620 --> 00:04:07,030
available so this makes them a really

00:04:05,080 --> 00:04:09,640
really good fit for synchronous

00:04:07,030 --> 00:04:12,130
generators and I think that the future

00:04:09,640 --> 00:04:14,410
of strings in ojs will come through a

00:04:12,130 --> 00:04:16,780
sync generators because they are so much

00:04:14,410 --> 00:04:19,600
easier to reason about them to write

00:04:16,780 --> 00:04:23,050
code with so let's get the quick example

00:04:19,600 --> 00:04:24,130
I had a link to code sandbox if you want

00:04:23,050 --> 00:04:25,660
to play around with it

00:04:24,130 --> 00:04:30,190
for most of the examples you can do it

00:04:25,660 --> 00:04:32,860
later so in this example we can just

00:04:30,190 --> 00:04:35,470
create a simple wrapper around the

00:04:32,860 --> 00:04:38,650
string so this generator function

00:04:35,470 --> 00:04:40,960
receives a string loops to the stream

00:04:38,650 --> 00:04:43,270
while we pass data and then in the

00:04:40,960 --> 00:04:45,940
finally because we are professionals it

00:04:43,270 --> 00:04:51,490
releases the lock so what is this good

00:04:45,940 --> 00:04:54,550
for let's give a practical example so in

00:04:51,490 --> 00:04:56,800
this example we are performing a it's

00:04:54,550 --> 00:04:59,320
not a full-text search it's just a word

00:04:56,800 --> 00:05:01,660
search on a document there is a question

00:04:59,320 --> 00:05:03,850
on the mouth what this means is that if

00:05:01,660 --> 00:05:06,490
this document has four Jiggs I'm gonna

00:05:03,850 --> 00:05:09,670
download it over fetch all by the way

00:05:06,490 --> 00:05:12,310
sorry fat response the body is a

00:05:09,670 --> 00:05:16,270
readable string is a stream that you can

00:05:12,310 --> 00:05:18,130
read from so in this example we just do

00:05:16,270 --> 00:05:21,130
a fetch to a file on the internet

00:05:18,130 --> 00:05:24,460
somewhere that can be many Meg's long we

00:05:21,130 --> 00:05:26,470
iterate over the stream until we find

00:05:24,460 --> 00:05:28,330
the word this is a little bit more

00:05:26,470 --> 00:05:30,160
detailed in the example like with the

00:05:28,330 --> 00:05:32,740
proper implementation that search on the

00:05:30,160 --> 00:05:34,540
bytes and matches it against words but

00:05:32,740 --> 00:05:36,100
what this means is that you without

00:05:34,540 --> 00:05:37,960
downloading the full file without

00:05:36,100 --> 00:05:40,960
reading it and putting it on your

00:05:37,960 --> 00:05:43,030
computer you can just loop over it and

00:05:40,960 --> 00:05:44,680
if you find it in the first chunk of the

00:05:43,030 --> 00:05:46,030
stream is going to return straight away

00:05:44,680 --> 00:05:48,400
and you know if you have a word in the

00:05:46,030 --> 00:05:52,990
document I think this is cool and I

00:05:48,400 --> 00:05:55,090
heard that this might actually come as a

00:05:52,990 --> 00:05:56,770
spec to JavaScript that you can read

00:05:55,090 --> 00:06:00,610
these strings we're gonna sync iterator

00:05:56,770 --> 00:06:02,440
by default without doing this roughly so

00:06:00,610 --> 00:06:04,840
another thing is load on demand is also

00:06:02,440 --> 00:06:07,210
cool you can start downloading a file

00:06:04,840 --> 00:06:09,940
you can show it to the user straight

00:06:07,210 --> 00:06:13,450
away and then just wipe the rest while

00:06:09,940 --> 00:06:15,040
it's coming yeah I think this is the

00:06:13,450 --> 00:06:17,560
clearest case you can do it on click you

00:06:15,040 --> 00:06:20,740
can do it however you want really and

00:06:17,560 --> 00:06:22,570
the interface is actually much nicer in

00:06:20,740 --> 00:06:24,460
my opinion because you just you with a

00:06:22,570 --> 00:06:26,020
loop over it or you do a no wait that's

00:06:24,460 --> 00:06:29,680
next you don't need to worry about

00:06:26,020 --> 00:06:32,350
knowing the exact source strings so

00:06:29,680 --> 00:06:36,780
another and this is one of my favorite

00:06:32,350 --> 00:06:36,780
examples is to crawl external API

00:06:36,800 --> 00:06:43,880
we we did this a little bit at work and

00:06:39,560 --> 00:06:46,039
this example is something that is very

00:06:43,880 --> 00:06:49,069
useful for us to do in our day to day

00:06:46,039 --> 00:06:51,919
lives this is an example that fetches

00:06:49,069 --> 00:06:55,280
the entire permit history of a repo from

00:06:51,919 --> 00:06:58,340
github and these youths commits one by

00:06:55,280 --> 00:07:00,410
one so what this means is that the

00:06:58,340 --> 00:07:03,139
consumer wouldn't care about how github

00:07:00,410 --> 00:07:05,360
does paginate so anytime it calls away

00:07:03,139 --> 00:07:07,699
it will get the next commit you could

00:07:05,360 --> 00:07:09,590
integrate this however you wanted so for

00:07:07,699 --> 00:07:11,630
example you could basically put the

00:07:09,590 --> 00:07:14,569
committee in a database that you own one

00:07:11,630 --> 00:07:17,780
by one without putting a range and

00:07:14,569 --> 00:07:21,530
destroying it and this would all work

00:07:17,780 --> 00:07:23,810
for free the way you use this API would

00:07:21,530 --> 00:07:25,159
be your Creator generator you say for

00:07:23,810 --> 00:07:27,139
example that you want to fetch all

00:07:25,159 --> 00:07:32,090
commits from nodejs

00:07:27,139 --> 00:07:33,650
and you could just do a for loop and it

00:07:32,090 --> 00:07:36,139
would loop to all the commits that ever

00:07:33,650 --> 00:07:39,470
been in that repository in the for loop

00:07:36,139 --> 00:07:42,110
you could do whatever you wanted or you

00:07:39,470 --> 00:07:44,180
could just get him on the man by the way

00:07:42,110 --> 00:07:47,240
someone what if you wanted to build a

00:07:44,180 --> 00:07:50,080
client for Fergie table that should come

00:07:47,240 --> 00:07:53,539
it's on demand this this could be away

00:07:50,080 --> 00:07:55,340
just before this we actually run one of

00:07:53,539 --> 00:07:58,699
these in production when we were

00:07:55,340 --> 00:08:01,759
migrating hundred thousand items from

00:07:58,699 --> 00:08:03,590
elasticsearch to our database we run it

00:08:01,759 --> 00:08:06,500
with a generator where we paginate it

00:08:03,590 --> 00:08:10,310
over the collection on on elasticsearch

00:08:06,500 --> 00:08:12,110
we run it against it like seven times

00:08:10,310 --> 00:08:14,000
maybe counting all the different

00:08:12,110 --> 00:08:15,409
environments it never failed and we have

00:08:14,000 --> 00:08:18,319
all the data that we need in our

00:08:15,409 --> 00:08:20,960
database without destroying it doing a

00:08:18,319 --> 00:08:22,940
puzzle or without writing a massive

00:08:20,960 --> 00:08:26,900
piece of code just to handle this this

00:08:22,940 --> 00:08:29,360
migration so another cool one that I

00:08:26,900 --> 00:08:32,899
really like is who as implemented

00:08:29,360 --> 00:08:33,560
infinite loaders here in react or view

00:08:32,899 --> 00:08:36,680
or whatever

00:08:33,560 --> 00:08:38,180
Easy's it's a mess right it's like when

00:08:36,680 --> 00:08:40,399
you start to scroll down if you don't

00:08:38,180 --> 00:08:44,690
pay attention to things like did my

00:08:40,399 --> 00:08:46,190
search parameters change did my did do

00:08:44,690 --> 00:08:47,839
the requests arrive in the right order

00:08:46,190 --> 00:08:49,360
because we don't have any guarantees

00:08:47,839 --> 00:08:52,390
that the requests arriving the right

00:08:49,360 --> 00:08:54,190
order I found that we implemented we had

00:08:52,390 --> 00:08:56,170
a few implementations of infinite

00:08:54,190 --> 00:08:58,390
loaders they were pretty much all broken

00:08:56,170 --> 00:09:00,700
to be honest we reimplemented them with

00:08:58,390 --> 00:09:04,000
the sink generators we never have that

00:09:00,700 --> 00:09:05,860
your times so this could be a way you

00:09:04,000 --> 00:09:07,600
basically create a scene a signal

00:09:05,860 --> 00:09:11,079
because we are professionals we want to

00:09:07,600 --> 00:09:13,630
cancel the requests when someone for

00:09:11,079 --> 00:09:15,250
example changes the the search

00:09:13,630 --> 00:09:16,600
parameters you want to cancel the

00:09:15,250 --> 00:09:18,010
request because you don't want to set

00:09:16,600 --> 00:09:21,130
state to something that is no longer

00:09:18,010 --> 00:09:23,410
there and you can basically just curl if

00:09:21,130 --> 00:09:27,220
you use cursor fascination you can look

00:09:23,410 --> 00:09:30,070
while the cursor is there then you can

00:09:27,220 --> 00:09:31,990
basically request it on demand as for

00:09:30,070 --> 00:09:35,290
example your component asks for more

00:09:31,990 --> 00:09:37,390
data you just click awake next then set

00:09:35,290 --> 00:09:39,459
the state if you if your search

00:09:37,390 --> 00:09:41,050
parameter st. for example you just call

00:09:39,459 --> 00:09:43,329
a board to make sure that you don't have

00:09:41,050 --> 00:09:46,149
any race conditions and you just

00:09:43,329 --> 00:09:49,920
recreate a generator with a loader your

00:09:46,149 --> 00:09:53,079
API loader and the search parameters and

00:09:49,920 --> 00:09:56,760
that's it really a few examples I hope

00:09:53,079 --> 00:10:01,299
you guys used it in production tomorrow

00:09:56,760 --> 00:10:01,299

YouTube URL: https://www.youtube.com/watch?v=Pk92pHuiFfs


