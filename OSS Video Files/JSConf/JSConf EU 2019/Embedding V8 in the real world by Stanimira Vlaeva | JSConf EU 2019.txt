Title: Embedding V8 in the real world by Stanimira Vlaeva | JSConf EU 2019
Publication date: 2019-06-18
Playlist: JSConf EU 2019
Description: 
	V8 is the JavaScript engine powering Google Chrome, Node.js and NativeScript. NativeScript embeds V8 to process JavaScript and dynamically call Android APIs. This enables developers to write Android applications in JavaScript and directly access the underlying OS. Come to this session to learn what challenges the NativeScript team met embedding V8 in a mobile framework and how you can power any C++ based application with one of the most sophisticated JavaScript engines.

https://2019.jsconf.eu/stanimira-vlaeva/embedding-v8-in-the-real-world.html
Captions: 
	00:00:13,650 --> 00:00:14,650
And welcome to my session.

00:00:14,650 --> 00:00:20,640
I'm going to be talking about V8 in the real world, or more specifically in the native

00:00:20,640 --> 00:00:21,860
script framework.

00:00:21,860 --> 00:00:29,150
I'm Stanimira Vlaeva, I'm a software engineer and work on this cool open source project,

00:00:29,150 --> 00:00:30,279
NativeScript.

00:00:30,279 --> 00:00:36,860
And I'm with web technologies, and find me on Twitter, the best place.

00:00:36,860 --> 00:00:40,610
Or in the karaoke after.

00:00:40,610 --> 00:00:42,820
So, NativeScript.

00:00:42,820 --> 00:00:47,810
Our main topic today after V8, of course.

00:00:47,810 --> 00:00:48,810
What is it?

00:00:48,810 --> 00:00:49,810
What is it?

00:00:49,810 --> 00:00:52,980
How many people here have heard about NativeScript?

00:00:52,980 --> 00:00:54,770
Awesome.

00:00:54,770 --> 00:00:56,560
Okay.

00:00:56,560 --> 00:01:02,300
NativeScript is a framework for building native mobile applications for Android and iOS using

00:01:02,300 --> 00:01:03,730
web technologies.

00:01:03,730 --> 00:01:06,680
Like Angular, Vue, or just plain JavaScript.

00:01:06,680 --> 00:01:12,100
In short, it is a way to execute JavaScript in the mobile world.

00:01:12,100 --> 00:01:15,020
And build mobile applications with it.

00:01:15,020 --> 00:01:19,020
We will take a short overview of the architecture of the framework.

00:01:19,020 --> 00:01:24,540
At the bottom, of course, we have Android and iOS.

00:01:24,540 --> 00:01:26,760
Operating systems.

00:01:26,760 --> 00:01:32,070
On top of that we have the NativeScript run times for Android and for iOS which provide

00:01:32,070 --> 00:01:36,130
the 100% native API access.

00:01:36,130 --> 00:01:41,300
But if you have had to build a native application for Android or iOS, you may have noticed the

00:01:41,300 --> 00:01:43,820
way to do that is quite different.

00:01:43,820 --> 00:01:48,550
The APIs are different and the way to build your user interface is different.

00:01:48,550 --> 00:01:53,060
Everything is completely different because they are two different worlds.

00:01:53,060 --> 00:01:57,890
That's why NativeScript provides a common abstraction for these APIs.

00:01:57,890 --> 00:02:03,870
It is part of the framework and the NativeScript developer cans use that in order to build

00:02:03,870 --> 00:02:10,250
layouts or build user interface or even style their applications with CSS and this layer

00:02:10,250 --> 00:02:15,950
is written in JavaScript and you can use that so that you can have a single codebase and

00:02:15,950 --> 00:02:20,910
have different applications for Android and iOS.

00:02:20,910 --> 00:02:26,420
NativeScript also has a very light application framework which provides us with native bindings,

00:02:26,420 --> 00:02:29,370
navigations and some other cool things.

00:02:29,370 --> 00:02:34,200
And if you need something a bit more sophisticated while building your applications, NativeScript

00:02:34,200 --> 00:02:38,950
also supports Angular and Vue JS.

00:02:38,950 --> 00:02:42,390
Today we're gonna talk about the bottom most levels.

00:02:42,390 --> 00:02:44,370
The deep stuff.

00:02:44,370 --> 00:02:48,150
And more specifically, we're gonna talk about the Android runtime.

00:02:48,150 --> 00:02:50,319
The two runtimes are quite similar.

00:02:50,319 --> 00:02:55,319
And the biggest difference between them is that the Android runtime uses V8 under the

00:02:55,319 --> 00:02:59,959
hood whereas the iOS run time uses another JavaScript engine.

00:02:59,959 --> 00:03:02,140
JavaScript Core.

00:03:02,140 --> 00:03:07,560
But the principle of how they work is quite similar.

00:03:07,560 --> 00:03:11,550
We're gonna start by explaining how the native API access works.

00:03:11,550 --> 00:03:16,180
As you make have guessed from the name ""NativeScript,"" this is kind of what we mostly brag about

00:03:16,180 --> 00:03:20,340
because we have 100% API access.

00:03:20,340 --> 00:03:29,810
And this is why you should be using NativeScript instead of whatever  anything else you choose.

00:03:29,810 --> 00:03:32,200
The main advantage.

00:03:32,200 --> 00:03:34,800
How it works.

00:03:34,800 --> 00:03:38,670
We'll start with the look at the application package of our NativeScript application.

00:03:38,670 --> 00:03:45,840
So, we have Android, some phone or some device that is running the Android operating system.

00:03:45,840 --> 00:03:50,099
And the NativeScript application is just a regular Android application and which has

00:03:50,099 --> 00:03:53,370
some NativeScript magic inside it.

00:03:53,370 --> 00:03:57,239
And the first part of the magic is, of course, the JavaScript code that the NativeScript

00:03:57,239 --> 00:04:00,590
developer wrote and shipped inside that application.

00:04:00,590 --> 00:04:07,099
The JavaScript code is not cross compiled or converted or anything like that, it stays

00:04:07,099 --> 00:04:13,780
JavaScript during the whole life cycle while the application is running.

00:04:13,780 --> 00:04:17,489
We also have the NativeScript run time, both in the Java part.

00:04:17,489 --> 00:04:22,639
We're going to talk about them shipped together inside the application.

00:04:22,639 --> 00:04:27,470
And the last part, almost, is V8.

00:04:27,470 --> 00:04:31,110
Why do we need to ship V8 inside an Android application?

00:04:31,110 --> 00:04:34,400
Well, to execute JavaScript.

00:04:34,400 --> 00:04:37,229
V8 is a JavaScript engine.

00:04:37,229 --> 00:04:39,330
It executes JavaScript.

00:04:39,330 --> 00:04:45,839
It is embedded in Chrome, Note, even Microsoft nowadays and of course in NativeScript.

00:04:45,839 --> 00:04:47,809
It was developed by Google.

00:04:47,809 --> 00:04:52,199
It was created from the Chrome browser and it's one of the fastest JavaScript engines

00:04:52,199 --> 00:04:53,199
out there.

00:04:53,199 --> 00:04:58,800
Another reason why we chose V8 is because it has a cool API that we can use and plug

00:04:58,800 --> 00:05:03,539
into the runtime.

00:05:03,539 --> 00:05:08,020
If you want to read a bit more about V8 and how it works, I highly recommend these two

00:05:08,020 --> 00:05:10,139
resources.

00:05:10,139 --> 00:05:18,389
The first one is a really amazing popup series which is a crash course just in time compilers.

00:05:18,389 --> 00:05:22,139
And the other one is a video which is very recent.

00:05:22,139 --> 00:05:23,409
It's called why the script?

00:05:23,409 --> 00:05:30,199
And describes the optimizations under the hood while it executes your JavaScript code.

00:05:30,199 --> 00:05:32,350
It's from the V8 team.

00:05:32,350 --> 00:05:37,619
If you want to learn about modern JavaScript engines, these are two great resources to

00:05:37,619 --> 00:05:41,169
get started.

00:05:41,169 --> 00:05:42,919
The next part of the NativeScript magic.

00:05:42,919 --> 00:05:45,699
The metadata generator.

00:05:45,699 --> 00:05:51,009
This is one of the very, very valid JavaScript code inside of NativeScript.

00:05:51,009 --> 00:05:56,659
But we have something that is not usually in the JavaScript language, right?

00:05:56,659 --> 00:05:57,659
Android.

00:05:57,659 --> 00:05:59,879
Where does this come from?

00:05:59,879 --> 00:06:05,150
Well, let's imagine that when your computer, you have some native library.

00:06:05,150 --> 00:06:07,659
For example, Android SDK.

00:06:07,659 --> 00:06:11,309
And you use that inside your NativeScript application.

00:06:11,309 --> 00:06:18,020
While your application is being built, NativeScript runs a special tool called the metadata generator

00:06:18,020 --> 00:06:23,150
which traverses that native library and gets information about the APIs.

00:06:23,150 --> 00:06:28,710
It gets information about all the global packages, about every single class, about how these

00:06:28,710 --> 00:06:34,889
classes can be instantiated, about every method in these classes and what are the meta signatures.

00:06:34,889 --> 00:06:44,419
Basically, it gets information how every single method and API can be used.

00:06:44,419 --> 00:06:50,250
That is saved inside a compact runtime binary which is, again, shipped inside the application.

00:06:50,250 --> 00:06:59,249
So, we have information about how we can create stuff in Java inside the metadata.

00:06:59,249 --> 00:07:05,229
And the metadata of course is shipped together with the whole application as well?

00:07:05,229 --> 00:07:06,879
And what happens at launch time?

00:07:06,879 --> 00:07:10,529
We initialize V8 which can execute the JavaScript code.

00:07:10,529 --> 00:07:15,659
We load the metadata from the files saved inside the application and we attach source

00:07:15,659 --> 00:07:18,449
and callbacks.

00:07:18,449 --> 00:07:23,839
And the callbacks are the most important part about embedding V8.

00:07:23,839 --> 00:07:31,250
They are our way to plug into the JavaScript code and do all sorts of stuff.

00:07:31,250 --> 00:07:35,729
Let's start by explaining some stuff about these callbacks and how they actually work

00:07:35,729 --> 00:07:42,289
together with the metadata to provide access with the native APIs.

00:07:42,289 --> 00:07:46,270
Okay, we have this expression, Android media recorder.

00:07:46,270 --> 00:07:50,669
We are trying to execute that JavaScript code.

00:07:50,669 --> 00:07:56,439
The NativeScript runtime has read the metadata and found out that there is an Android global

00:07:56,439 --> 00:07:58,129
package.

00:07:58,129 --> 00:08:05,800
That's why it has created a global object inside the running V8 instance for Android.

00:08:05,800 --> 00:08:09,509
It also has attached some callbacks to that object.

00:08:09,509 --> 00:08:16,129
Like the package getter callback so that when we query for Android.media, the NativeScript

00:08:16,129 --> 00:08:18,430
runtime plugs in with that callback.

00:08:18,430 --> 00:08:20,369
The callback will be executed.

00:08:20,369 --> 00:08:25,409
And inside the callback the NativeScript runtime will try to find Android.media inside the

00:08:25,409 --> 00:08:27,339
metadata.

00:08:27,339 --> 00:08:32,960
It returns something, some information, for example, some information that Android.media

00:08:32,960 --> 00:08:35,190
has some media recorder.

00:08:35,190 --> 00:08:38,080
And it also has a package getter callback attached.

00:08:38,080 --> 00:08:43,830
So, when that callback is called, we find the media recorder inside the Android media

00:08:43,830 --> 00:08:46,530
package in the metadata.

00:08:46,530 --> 00:08:52,850
And this time we return a constructer function because this is actually a class.

00:08:52,850 --> 00:08:54,980
And why is this constructer function so important?

00:08:54,980 --> 00:09:00,880
Well, because when it's invoked with new, it actually contains a constructer callback.

00:09:00,880 --> 00:09:04,950
Again, attached by the NativeScript runtime.

00:09:04,950 --> 00:09:07,100
And this is where the actual magic happens.

00:09:07,100 --> 00:09:12,860
Because the NativeScript runtime creates a native Java object.

00:09:12,860 --> 00:09:14,920
But how does that happen?

00:09:14,920 --> 00:09:23,450
Well, we use JNA, Java native interface, and this is a bridge between V8 and the running

00:09:23,450 --> 00:09:24,930
Android runtime.

00:09:24,930 --> 00:09:29,940
So, we can save functions back and forth between the two.

00:09:29,940 --> 00:09:34,400
So, we create a native object.

00:09:34,400 --> 00:09:38,590
Then we create the JavaScript proxy object that we're going to discuss a bit later and

00:09:38,590 --> 00:09:43,590
we return the proxy object to the JavaScript world.

00:09:43,590 --> 00:09:49,580
If it's right to access something inside that proxy, well, actually this proxy object is

00:09:49,580 --> 00:09:51,250
not very simple.

00:09:51,250 --> 00:09:54,140
It's not a plain object.

00:09:54,140 --> 00:09:56,200
It creates some callbacks.

00:09:56,200 --> 00:09:57,690
Contains some callbacks as well.

00:09:57,690 --> 00:10:03,181
So, when we try to access this random field, we know that this field exists in the Java

00:10:03,181 --> 00:10:07,810
world so that we have attached a field getter callback.

00:10:07,810 --> 00:10:12,990
And the field getter callback actually queries the original Java object.

00:10:12,990 --> 00:10:14,610
But there is a slight complication here.

00:10:14,610 --> 00:10:17,890
Okay, we can get the result from the Java world.

00:10:17,890 --> 00:10:22,260
But the data type is different from the JavaScript data type, right?

00:10:22,260 --> 00:10:27,890
So, Java run string is not something we can assign to a JavaScript variable.

00:10:27,890 --> 00:10:31,840
And that is why there is a marshaling service.

00:10:31,840 --> 00:10:36,140
To convert it from Java so to JavaScript and vice versa.

00:10:36,140 --> 00:10:42,820
At this point, you would say, wouldn't that be terribly slow to convert everything?

00:10:42,820 --> 00:10:48,800
Obviously, it will be, if it's to convert object, it's not a good idea.

00:10:48,800 --> 00:10:52,200
This is another reason why proxies are quite useful.

00:10:52,200 --> 00:10:58,840
So, for objects, we just create a plain JavaScript object which has the same methods with the

00:10:58,840 --> 00:11:01,490
same signatures.

00:11:01,490 --> 00:11:06,010
And the same members as well.

00:11:06,010 --> 00:11:08,200
And inside that we have callbacks.

00:11:08,200 --> 00:11:13,180
So, that when you call some method with the same name on the JavaScript object, the callback

00:11:13,180 --> 00:11:21,350
will be called and the NativeScript runtime will call the original Java method for JNA.

00:11:21,350 --> 00:11:23,870
And this is a very cheap operation.

00:11:23,870 --> 00:11:25,750
Creating new JavaScript objects.

00:11:25,750 --> 00:11:29,460
Instead of converting data.

00:11:29,460 --> 00:11:31,850
If you call a method, same story.

00:11:31,850 --> 00:11:34,810
A method callback is triggered.

00:11:34,810 --> 00:11:37,470
We call the original Java method.

00:11:37,470 --> 00:11:42,090
The result is marshallized again and returned back to the JavaScript world.

00:11:42,090 --> 00:11:48,240
If we have arguments in that method, the arguments will be converted to Java data format.

00:11:48,240 --> 00:11:53,750
And then they will be  the Java method will be called with deconverted arguments.

00:11:53,750 --> 00:11:55,290
Okay.

00:11:55,290 --> 00:12:03,020
Let's see just a quick overview of all these callbacks, if they are confused you so far.

00:12:03,020 --> 00:12:08,450
We try to instantiate new object and assign that to a JavaScript variable.

00:12:08,450 --> 00:12:09,950
We call the constructer callback.

00:12:09,950 --> 00:12:17,200
If you want to create a new instance of the class through JNA.

00:12:17,200 --> 00:12:19,190
The instance is returned.

00:12:19,190 --> 00:12:25,540
And because it's an object, the NativeScript runtime creates a JavaScript proxy object.

00:12:25,540 --> 00:12:29,350
Then we try to call some methods on that proxy.

00:12:29,350 --> 00:12:33,150
We call actually the method callback without knowing that we are calling it.

00:12:33,150 --> 00:12:34,150
Everything is hidden.

00:12:34,150 --> 00:12:35,510
It happens behind the scenes.

00:12:35,510 --> 00:12:40,430
But the method callback then calls the original Java method.

00:12:40,430 --> 00:12:46,060
The result that we can get is returned through JNA and marshallized and returned back to

00:12:46,060 --> 00:12:48,680
the JavaScript world.

00:12:48,680 --> 00:12:53,070
That's all the communication magic that happens.

00:12:53,070 --> 00:12:57,770
What you may be wondering at this point what happens with these objects.

00:12:57,770 --> 00:12:59,690
Like we create JavaScript objects.

00:12:59,690 --> 00:13:01,460
We also create Java objects.

00:13:01,460 --> 00:13:03,020
They are collected in some way.

00:13:03,020 --> 00:13:08,020
So, we actually have to take care of their life cycle.

00:13:08,020 --> 00:13:12,710
And in JavaScript we don't have to manually manage the memory.

00:13:12,710 --> 00:13:15,110
There is a garbage collector that runs.

00:13:15,110 --> 00:13:20,820
And it's always to retrieve the memory of the unused objects.

00:13:20,820 --> 00:13:23,480
It also has a nondeterministic nature.

00:13:23,480 --> 00:13:27,750
We can't be sure when the garbage collector will run.

00:13:27,750 --> 00:13:32,280
And the other kind of complication is that, well, the Android runtime also has a garbage

00:13:32,280 --> 00:13:34,700
collector.

00:13:34,700 --> 00:13:35,700
It's pretty funny.

00:13:35,700 --> 00:13:36,700
So, we have two garbage collectors running.

00:13:36,700 --> 00:13:38,970
We have objects in both worlds.

00:13:38,970 --> 00:13:42,640
And that's one of the biggest challenges of the NativeScript runtime.

00:13:42,640 --> 00:13:47,470
We have to kind of try to synchronize that.

00:13:47,470 --> 00:13:54,290
We have to ensure that no object is collected if there is a living counterpart.

00:13:54,290 --> 00:14:00,370
For example, if you create some Java object through JavaScript, and then try to access

00:14:00,370 --> 00:14:05,940
it, if the Android garbage collector collected the native Java object, that sounds really

00:14:05,940 --> 00:14:10,480
cool because you will try to access something is that doesn't exist, and the application

00:14:10,480 --> 00:14:12,230
will crash.

00:14:12,230 --> 00:14:15,150
Like, it will crash.

00:14:15,150 --> 00:14:16,150
Yeah.

00:14:16,150 --> 00:14:22,310
You're running a mobile application and it's not really cool user experience.

00:14:22,310 --> 00:14:23,720
Okay.

00:14:23,720 --> 00:14:31,390
In order to plugin into the life cycle, we use finalizer callbacks so that when the garbage

00:14:31,390 --> 00:14:36,980
collector of V8 marks something that  for collecting, says that some object doesn't

00:14:36,980 --> 00:14:43,110
have living instances anywhere and it should be collected, the finalize of the callback

00:14:43,110 --> 00:14:44,240
will be called.

00:14:44,240 --> 00:14:50,500
And this is the place where the script runtime is plugged into.

00:14:50,500 --> 00:14:52,420
We have strong and weak references.

00:14:52,420 --> 00:14:54,880
Let's see how these actually look like.

00:14:54,880 --> 00:14:58,060
We have the same example as before.

00:14:58,060 --> 00:15:02,110
First, we create the native object.

00:15:02,110 --> 00:15:05,370
Then we create the JavaScript proxy.

00:15:05,370 --> 00:15:07,960
And then the NativeScript runtime has two collections.

00:15:07,960 --> 00:15:12,890
One for strong references and one for weak references.

00:15:12,890 --> 00:15:18,730
When the objects are first created, we create a strong reference or a link, if you would

00:15:18,730 --> 00:15:22,840
like to call that, between the two objects.

00:15:22,840 --> 00:15:27,750
And if that's confusing, okay, the proxy lives inside V8.

00:15:27,750 --> 00:15:33,610
The original object lives inside the Android runtime and the references live inside the

00:15:33,610 --> 00:15:34,790
NativeScript runtime.

00:15:34,790 --> 00:15:36,430
All right.

00:15:36,430 --> 00:15:38,460
Time to collect stuff.

00:15:38,460 --> 00:15:40,070
Some garbage collector runs.

00:15:40,070 --> 00:15:45,170
We can't really say for sure if it's gonna be the V8 garbage collector or the Android

00:15:45,170 --> 00:15:46,170
runtime garbage collector.

00:15:46,170 --> 00:15:51,930
But say in this example that V8 will decide to collect the memory first.

00:15:51,930 --> 00:15:58,770
So, there is no one in the JavaScript world using the JavaScript proxy recorder.

00:15:58,770 --> 00:16:00,620
And that's why it's marked for collection.

00:16:00,620 --> 00:16:04,610
But at this point the finalizer callback is called.

00:16:04,610 --> 00:16:09,529
And the NativeScript runtime sees that there is a living strong reference.

00:16:09,529 --> 00:16:13,300
That's why the strong reference is turned into a weak reference.

00:16:13,300 --> 00:16:18,920
And we instruct V8 not to collect that object.

00:16:18,920 --> 00:16:24,590
The next time when the Android garbage collector runs, it decides to mark the recorder object

00:16:24,590 --> 00:16:28,050
for collection because no one in the Java world is using it.

00:16:28,050 --> 00:16:30,910
And sees there's a weak reference.

00:16:30,910 --> 00:16:35,630
And because it's a weak reference, this object will be collected.

00:16:35,630 --> 00:16:42,730
So, let's say that at some time the V8 garbage collector runs again.

00:16:42,730 --> 00:16:45,670
Well, now there is a weak reference.

00:16:45,670 --> 00:16:48,620
And the weak reference doesn't point to anything.

00:16:48,620 --> 00:16:53,870
And because we don't have anything out there in the Java world, this object can also be

00:16:53,870 --> 00:16:54,870
collected.

00:16:54,870 --> 00:16:58,130
It's marked for collection and now we can collect it.

00:16:58,130 --> 00:17:05,399
But if we had two consecutive garbage collector collection runs inside V8 and we still had

00:17:05,399 --> 00:17:11,159
a weak reference to a living object that wasn't created by the Java garbage collector, the

00:17:11,159 --> 00:17:15,539
V8 object wouldn't have been collected as well.

00:17:15,539 --> 00:17:19,970
So, this is a normal cycle.

00:17:19,970 --> 00:17:27,369
And as you could imagine, there are some challenges that happen because we have two running garbage

00:17:27,369 --> 00:17:28,529
collectors.

00:17:28,529 --> 00:17:32,419
Well, we could get out of memory exceptions.

00:17:32,419 --> 00:17:36,700
Usually the objects that were created in the Android application are not really big.

00:17:36,700 --> 00:17:43,230
So, we wouldn't have that happening for a hello world application, right?

00:17:43,230 --> 00:17:49,149
But the problem is that, of course, yeah, we have a few garbage collection cycles that

00:17:49,149 --> 00:17:53,770
should be run in order for some memory to be retrieved back.

00:17:53,770 --> 00:17:58,280
And if we create some big objects, this can cause problems.

00:17:58,280 --> 00:18:02,679
Because the memory is not retrieved on time.

00:18:02,679 --> 00:18:06,980
For example, we can have images.

00:18:06,980 --> 00:18:12,669
And an image  let's say that this Java array in the Java world.

00:18:12,669 --> 00:18:14,789
The Java array is quite big.

00:18:14,789 --> 00:18:16,940
Whereas the JavaScript proxy is not so big.

00:18:16,940 --> 00:18:20,690
It's actually just a plain object with some callbacks attached.

00:18:20,690 --> 00:18:24,690
So, it actually looks like that, memorywise.

00:18:24,690 --> 00:18:27,419
We have a lot of memory in the Java world.

00:18:27,419 --> 00:18:30,830
We have a really plain JavaScript proxy.

00:18:30,830 --> 00:18:36,669
And the Java  the Android garbage collector is actually dependent on the V8 garbage collector

00:18:36,669 --> 00:18:41,950
in order to retrieve this huge chunk of memory.

00:18:41,950 --> 00:18:49,309
So, at this point the V8 garbage collector, even if you have tens of thousands of these

00:18:49,309 --> 00:18:53,820
small, plain proxies, it doesn't have pressure to be run.

00:18:53,820 --> 00:19:00,509
Because we don't really take a lot of memory in the running JavaScript virtual machine.

00:19:00,509 --> 00:19:04,490
So, V8 doesn't really have a reason to trigger garbage collection.

00:19:04,490 --> 00:19:12,130
If that doesn't happen on time, well, we may cause out of memory exceptions.

00:19:12,130 --> 00:19:18,049
Because we're taking too much space in the Java virtual machine.

00:19:18,049 --> 00:19:22,200
Some solutions or more like strategies to overcome this.

00:19:22,200 --> 00:19:25,960
Because there is no straightforward deterministic solution.

00:19:25,960 --> 00:19:27,620
Because of the nature of the problem.

00:19:27,620 --> 00:19:38,799
The first one, there is an API provided by V8 that lets us instruct V8 about the memory

00:19:38,799 --> 00:19:41,320
that is allocated inside of it.

00:19:41,320 --> 00:19:47,210
So, in our case we can say to V8, okay, the Android application that is running actually

00:19:47,210 --> 00:19:49,100
uses this amount of memory.

00:19:49,100 --> 00:19:53,039
And this memory is used because you have created some JavaScript objects.

00:19:53,039 --> 00:19:58,070
And the JavaScript objects are still pointing to living instances in the Java world.

00:19:58,070 --> 00:20:03,970
So, this should hint V8 to garbage collection more often because it's aware that there is

00:20:03,970 --> 00:20:05,309
more memory freed.

00:20:05,309 --> 00:20:14,499
I mean, it works in practice, but we can still get out of memory exceptions.

00:20:14,499 --> 00:20:18,470
Another important thing, we are doing this internally inside of a NativeScript runtime

00:20:18,470 --> 00:20:22,429
so the NativeScript developers don't have to use that.

00:20:22,429 --> 00:20:26,299
And it is a technique used internally.

00:20:26,299 --> 00:20:28,470
Another solution.

00:20:28,470 --> 00:20:30,369
We can force garbage collection, of course.

00:20:30,369 --> 00:20:34,429
We can say, V8, come on, run garbage collection.

00:20:34,429 --> 00:20:37,809
Mark these objects as free to be retrieved.

00:20:37,809 --> 00:20:40,090
Make these strong references weak.

00:20:40,090 --> 00:20:43,149
Then we can run the Android garbage collector.

00:20:43,149 --> 00:20:46,169
And then run the V8 garbage collector again.

00:20:46,169 --> 00:20:50,429
This is not the best thing ever because it doesn't guarantee that the garbage collection

00:20:50,429 --> 00:20:51,429
will be run.

00:20:51,429 --> 00:20:54,809
It kind of schedules it or hints it that it will be run.

00:20:54,809 --> 00:20:57,360
But we don't have a guarantee that it will be run.

00:20:57,360 --> 00:21:01,210
And you don't have a guarantee that it will be run in that order as well.

00:21:01,210 --> 00:21:05,080
And it's not the cheapest option out there.

00:21:05,080 --> 00:21:09,900
You are checking the objects and seeing if they have living references.

00:21:09,900 --> 00:21:12,580
It may have the opposite effect.

00:21:12,580 --> 00:21:17,419
So, this is not the best solution ever.

00:21:17,419 --> 00:21:18,419
You can do it.

00:21:18,419 --> 00:21:24,080
It is some strategy, but we don't really recommend using that.

00:21:24,080 --> 00:21:26,110
Okay.

00:21:26,110 --> 00:21:27,860
Let's take a look at this again.

00:21:27,860 --> 00:21:29,140
We have a strong reference.

00:21:29,140 --> 00:21:31,899
What didn't have references?

00:21:31,899 --> 00:21:39,070
And what if we had the control over things like this Java object can't be collected because

00:21:39,070 --> 00:21:40,259
I'm not using it anymore, it can be collected.

00:21:40,259 --> 00:21:43,129
I'm not using it in the JavaScript world.

00:21:43,129 --> 00:21:50,470
Well, the NativeScript runtime releases a function, release native counterpart and we

00:21:50,470 --> 00:21:56,840
need to run the object, and it basically destroys all these references.

00:21:56,840 --> 00:21:59,169
So, we invoke that.

00:21:59,169 --> 00:22:05,290
We basically instruct that we're no longer using this native object and it can be retrieved.

00:22:05,290 --> 00:22:12,529
So, whenever the next Android garbage collector runs, it is no longer dependent on V8's garbage

00:22:12,529 --> 00:22:13,539
collector.

00:22:13,539 --> 00:22:19,809
It can mark this object and say retrieve it.

00:22:19,809 --> 00:22:25,610
And as the last part of the presentation, something like a bit simpler.

00:22:25,610 --> 00:22:28,289
What is the point?

00:22:28,289 --> 00:22:33,429
Well, the JavaScript code in NativeScript is run and executed from a single thread.

00:22:33,429 --> 00:22:37,330
Which actually happens to be the main user interface thread.

00:22:37,330 --> 00:22:42,840
And if you see where I'm going, this can cause some problems with log and junk.

00:22:42,840 --> 00:22:49,769
So, you can see some glitches while your mobile application is being used.

00:22:49,769 --> 00:22:53,710
And this is not the best experience for a native mobile application as well.

00:22:53,710 --> 00:22:58,049
So, first you know what is junk, probably.

00:22:58,049 --> 00:23:04,770
It is the percentage of frames that are dropped while you are doing some calculations.

00:23:04,770 --> 00:23:07,429
We're not gonna focus on that.

00:23:07,429 --> 00:23:10,649
It's important to know that in the NativeScript application, if you are just building user

00:23:10,649 --> 00:23:15,309
interface, you are creating native Android and iOS widgets.

00:23:15,309 --> 00:23:20,869
So, you shouldn't experience junk in a native list view when scrolling, for example.

00:23:20,869 --> 00:23:24,769
If you are creating animations, same thing.

00:23:24,769 --> 00:23:29,850
You have many ways of creating in NativeScript, with Angular, CSS, with JavaScript.

00:23:29,850 --> 00:23:34,760
But internally it's actually creating native applications.

00:23:34,760 --> 00:23:39,039
So, you shouldn't have any problem while running animations.

00:23:39,039 --> 00:23:44,639
The other thing that is commonly  we're commonly asked for.

00:23:44,639 --> 00:23:50,359
If you're creating an HTTP request, the plugin that you're gonna use creates a background

00:23:50,359 --> 00:23:56,009
thread in the Java world which wouldn't freeze the main UI thread.

00:23:56,009 --> 00:24:01,160
But you may see some junk when you're executing CPUintensive operations.

00:24:01,160 --> 00:24:05,179
And the same thing would happen if you are executing CPUintensive Java code in an Android

00:24:05,179 --> 00:24:07,360
application.

00:24:07,360 --> 00:24:08,360
What is the solution?

00:24:08,360 --> 00:24:09,409
Well, worker threads.

00:24:09,409 --> 00:24:18,679
Essentially background threads to unlock the main thread.

00:24:18,679 --> 00:24:22,909
We don't have JavaScript memory sharing, but we have a way to communicate between the worker

00:24:22,909 --> 00:24:25,789
thread and the main UI thread.

00:24:25,789 --> 00:24:27,879
And the final thing, I'm going to ask you a question.

00:24:27,879 --> 00:24:30,309
You have to be patient for 30 more seconds.

00:24:30,309 --> 00:24:34,450
What is a worker thread in NativeScript?

00:24:34,450 --> 00:24:37,409
Two hints.

00:24:37,409 --> 00:24:39,179
Is it an isolate?

00:24:39,179 --> 00:24:44,659
Isolate is V8's way to isolate and executes some memory  sorry  to isolate some memory

00:24:44,659 --> 00:24:47,359
for a code that's being executed.

00:24:47,359 --> 00:24:52,320
They can run in parallel and we don't have memory sharing.

00:24:52,320 --> 00:24:53,529
Context.

00:24:53,529 --> 00:24:58,139
One isolate can have multiple contexts.

00:24:58,139 --> 00:25:02,139
We don't have member isolation and we can't run contexts in parallel.

00:25:02,139 --> 00:25:08,489
Also, you have to explicitly specify the context that some code is being executed on.

00:25:08,489 --> 00:25:10,250
Isolates or context?

00:25:10,250 --> 00:25:11,299
Isolates.

00:25:11,299 --> 00:25:12,350
Contexts.

00:25:12,350 --> 00:25:13,400
Okay.

00:25:13,400 --> 00:25:15,500
That's okay.

00:25:15,500 --> 00:25:16,559
Isolates.

00:25:16,559 --> 00:25:17,610
Okay.

00:25:17,610 --> 00:25:19,710
So, isolate.

00:25:19,710 --> 00:25:21,809
All right.

00:25:21,809 --> 00:25:25,190
So, this was about NativeScript and V8.

00:25:25,190 --> 00:25:31,830
If you want to meet me afterwards, you can find me in Twitter, and I'll be coming to

00:25:31,830 --> 00:25:32,830
you.

00:25:32,830 --> 00:25:37,250
And I also want to thank my colleague who helped me with this presentation.

00:25:37,250 --> 00:25:40,450
And this is his handle on Twitter as well.

00:25:40,450 --> 00:25:47,409
So, thanks a lot.

00:25:47,409 --> 00:25:49,159

YouTube URL: https://www.youtube.com/watch?v=wz7Znu6tqFw


