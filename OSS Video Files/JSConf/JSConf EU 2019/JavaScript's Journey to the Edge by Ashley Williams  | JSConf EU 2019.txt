Title: JavaScript's Journey to the Edge by Ashley Williams  | JSConf EU 2019
Publication date: 2019-06-03
Playlist: JSConf EU 2019
Description: 
	In September of 2008, Google’s Chromium Project released V8, a JavaScript engine, as part of a browser optimization wave that heralded the era of JavaScript browser applications that we both love, and love to hate. Less than a year later, in 2009, Ryan Dahl announced (at this very conference!) a way to run the V8 browser environment outside of the browser- Node.js, a platform that held the promise of unifying web application development, where both client and server side development could happen in the same language - JavaScript.

A decade later, V8, JavaScript, and its new buddy WebAssembly, have expanded to lands charted only a few years after Node.js debuted- known (confusingly) as the “Edge”. In this talk, we’ll introduce what the “Edge” is and why we are excited for it to revolutionize computation on the web. We’ll explore how this adventurous JavaScript engine, V8, is so well suited to tasks previously limited to Virtual Machines, Containers, or even simply Operating Systems. Finally, we’ll talk about security, Spectre, and ask ourselves the age old question, “You can do it, but should you?”.

In true JSConf EU tradition, this talk itself is going be an exciting announcement. You should come if you want to be there for the beginning of a new era of the Internet.

https://2019.jsconf.eu/ashley-williams/javascripts-journey-to-the-edge.html
Captions: 
	00:00:08,370 --> 00:00:13,750
>> Hello, everyone, welcome to my awesome talk.

00:00:13,750 --> 00:00:16,610
My name is Ashley Williams.

00:00:16,610 --> 00:00:26,720
You may know me as AB.Dubs from the internet, I'm sorry!

00:00:26,720 --> 00:00:28,009
What is this talk about?

00:00:28,009 --> 00:00:30,029
This talk is about a couple of things.

00:00:30,029 --> 00:00:32,180
The first thing is it about is performance.

00:00:32,180 --> 00:00:37,900
More importantly, performance that makes things more accessible, and, unlike a lot of the

00:00:37,900 --> 00:00:43,239
talks that we've seen at this conference, this talk is also about infrastructure.

00:00:43,239 --> 00:00:46,579
Can I get a shout out from any of the ops people in the room?

00:00:46,579 --> 00:00:47,579
Come on!

00:00:47,579 --> 00:00:49,570
Who is on pager duty right now!

00:00:49,570 --> 00:00:51,700
Someone, I'm so sorry.

00:00:51,700 --> 00:00:55,249
That sucks!

00:00:55,249 --> 00:01:01,050
I want this talk to be a little bit about how the internet works, and potentially, how

00:01:01,050 --> 00:01:03,660
the internet could work.

00:01:03,660 --> 00:01:08,600
And so this talk is called "JavaScript's journey to the edge" and so there's a little bit of

00:01:08,600 --> 00:01:09,770
journeying.

00:01:09,770 --> 00:01:14,090
Perhaps you're more familiar with these journeys if you're from the United States, but I just

00:01:14,090 --> 00:01:21,550
wanted to say a small thing, as this is JSConf about how important this conference has been

00:01:21,550 --> 00:01:22,550
to me.

00:01:22,550 --> 00:01:31,280
I spoke at the last Reject JS in 2015, and I was the second-to-last reject only to Marika

00:01:31,280 --> 00:01:34,430
who was the last reject.

00:01:34,430 --> 00:01:36,420
It was one of the most amazing conferences.

00:01:36,420 --> 00:01:42,740
The next day I went to JSConf EU and saw someone wearing a shirt with my face on it which was

00:01:42,740 --> 00:01:45,490
a fascinating surprise.

00:01:45,490 --> 00:01:50,370
This was from a musical number they had done using quotes from a previous talks of mine,

00:01:50,370 --> 00:01:56,810
and they did that again in 2017, or 2016, with the classic "people got mad" which was

00:01:56,810 --> 00:02:01,720
an auto tune of my voice talking about how people get mad if you put all of your code

00:02:01,720 --> 00:02:03,050
in one file!

00:02:03,050 --> 00:02:07,000
They do get mad!

00:02:07,000 --> 00:02:11,510
But then I spoke at JSConf EU in 2017 and I wore an Antifa shirt.

00:02:11,510 --> 00:02:16,460
It was a super fun talk.

00:02:16,460 --> 00:02:19,209
Man, I have so many friends at this conference.

00:02:19,209 --> 00:02:25,060
The last time I was here was last year where I did an impromptu Rust and WebAssembly workshop

00:02:25,060 --> 00:02:34,150
for 100 people from the Mozilla booth, and it's cool.

00:02:34,150 --> 00:02:36,959
This conference is super awesome, so can we give it a round of applause?

00:02:36,959 --> 00:02:44,049
I love this place.

00:02:44,049 --> 00:02:48,989
But this talk is obviously not about my journey, this talk is about JavaScript's journey, so

00:02:48,989 --> 00:02:53,799
I'm about to show you some very scientific timelines that I made using Wikipedia and

00:02:53,799 --> 00:02:56,389
Keynote.

00:02:56,389 --> 00:03:03,120
JavaScript has had a fascinating history, and people talk about history, about this

00:03:03,120 --> 00:03:08,470
one being the tenth one, and Node being announced in 2009.

00:03:08,470 --> 00:03:17,110
We've seen a lot of development from JavaScript, and we've seen it develop really, really quickly,

00:03:17,110 --> 00:03:20,989
and I think it's kind of developed in one particular way, so here we see the first website

00:03:20,989 --> 00:03:26,069
in 1991, and then we end with Wasm up in 2017.

00:03:26,069 --> 00:03:29,150
Wasm was only born in 2017?

00:03:29,150 --> 00:03:30,150
Amazing.

00:03:30,150 --> 00:03:36,629
But, we saw the appearance of a fair number of things, including a lot of browser engines,

00:03:36,629 --> 00:03:37,959
and a lot of frameworks.

00:03:37,959 --> 00:03:42,920
And I think one of the most pivotal things in this timeline that people don't usually

00:03:42,920 --> 00:03:49,680
see is the emergence much Google Maps in 2004 really motivated people to see what you could

00:03:49,680 --> 00:03:55,730
do inside of a website, and made it so that we started developing all of these things

00:03:55,730 --> 00:03:59,650
that you could do browser computations so much faster.

00:03:59,650 --> 00:04:02,669
So if we put these graphs together and take a look at this, what is happening is that

00:04:02,669 --> 00:04:08,279
the speed of computation in the browser is just exponentially growing, and that is so

00:04:08,279 --> 00:04:13,170
awesome, and I'm a big WebAssembly fan, I'm super here for this.

00:04:13,170 --> 00:04:19,120
However, because the browser has become such a computationally awesome agent, we've run

00:04:19,120 --> 00:04:21,630
into some costs.

00:04:21,630 --> 00:04:24,440
How much does doing this cost?

00:04:24,440 --> 00:04:28,360
And fundamentally, this comes back to the idea of accessibility, and it's spelled wrong

00:04:28,360 --> 00:04:31,889
here, but it really comes down to the fact that what we are talking about is the ability

00:04:31,889 --> 00:04:36,170
for people even to access content.

00:04:36,170 --> 00:04:44,530
Mani in his talk the Cost of JavaScript in 2018 said the web is bloated by user experience.

00:04:44,530 --> 00:04:46,840
And he's genuinely completely right.

00:04:46,840 --> 00:04:50,400
So how many people here have ever checked out HTTP Archive?

00:04:50,400 --> 00:04:53,750
If you haven't, it's amazing, and you could loan at these numbers.

00:04:53,750 --> 00:04:55,600
This is just one of the graphs.

00:04:55,600 --> 00:05:02,580
What this graph is showing is the median size of desktop and mobile applications with the

00:05:02,580 --> 00:05:08,861
JavaScript bytes that are being downloaded to the device, and we have seen a 353 per

00:05:08,861 --> 00:05:16,680
cent increase for desktop, and it's worse for mobile - 577 per cent growth in how much

00:05:16,680 --> 00:05:18,180
here sending to the browser.

00:05:18,180 --> 00:05:23,990
It's cool because the browser can take that stuff and use it really fast.

00:05:23,990 --> 00:05:28,569
Moving those bytes over the wire takes a lot of time.

00:05:28,569 --> 00:05:33,330
So, on average, remember, this is on average, there are people who are on the really bad

00:05:33,330 --> 00:05:39,250
end of this, mobile loading time for an average website takes nine seconds.

00:05:39,250 --> 00:05:42,210
All right?

00:05:42,210 --> 00:05:44,500
That's unacceptable.

00:05:44,500 --> 00:05:49,180
So this is going to be part of the problem we are going to solve in my talk today.

00:05:49,180 --> 00:05:55,569
So, my intro did not entirely say this but I'm a systems engineer for a big orange cloud,

00:05:55,569 --> 00:06:00,750
not to be confused with a big orange website which I'm not a fan of, or SoundCloud which

00:06:00,750 --> 00:06:02,810
has a surprisingly spectacular logo.

00:06:02,810 --> 00:06:08,319
I work for Cloudflare, I know it doesn't look super big here.

00:06:08,319 --> 00:06:11,470
What does it do?

00:06:11,470 --> 00:06:14,070
Cloudflare is an infrastructure company.

00:06:14,070 --> 00:06:18,340
Cloudflare is not super good at actually defining what it does, but the thing you definitely

00:06:18,340 --> 00:06:23,490
don't call it is a DNS company, because also, I mean, no-one likes DNS.

00:06:23,490 --> 00:06:24,670
I can't figure that out.

00:06:24,670 --> 00:06:27,939
I work at a DNS now.

00:06:27,939 --> 00:06:33,319
But we call ourselves an infrastructure company, and sometimes, I describe Cloudflare as a

00:06:33,319 --> 00:06:40,520
hardware company, and that is because our primary asset is this, and this is a map of

00:06:40,520 --> 00:06:46,460
180 data centres and growing all over the world.

00:06:46,460 --> 00:06:53,220
And so, this set of data centres contains something which is called "the Edge", and

00:06:53,220 --> 00:06:54,310
this is a terrible name.

00:06:54,310 --> 00:06:56,819
It doesn't make any sense to most people.

00:06:56,819 --> 00:06:58,300
Someone said there's a wrestler called the Edge.

00:06:58,300 --> 00:06:59,669
I don't know who that is, whatever.

00:06:59,669 --> 00:07:06,280
To talk to you about what the Edge is, we will talk about the classic dichotomies in

00:07:06,280 --> 00:07:09,150
web programming: client and server.

00:07:09,150 --> 00:07:12,050
To do so, let's talk about pizza.

00:07:12,050 --> 00:07:13,270
Who likes pizza?

00:07:13,270 --> 00:07:15,490
All right, there we go!

00:07:15,490 --> 00:07:18,520
I'm originally from New York, so pizza is cool, right?

00:07:18,520 --> 00:07:22,569
We are going to talk about pizza delivery, and I want you to view that in the eyes of

00:07:22,569 --> 00:07:27,160
pizza accessibility, because it would be terrible to deny people pizza, right?

00:07:27,160 --> 00:07:29,199
Especially, warm, fresh pizza.

00:07:29,199 --> 00:07:33,789
So obviously, you guys smoosh them together for pizza accessibility, all one word.

00:07:33,789 --> 00:07:39,610
Here is animation mere HP your JavaScript programmer will be represented by this lovely

00:07:39,610 --> 00:07:41,860
chef.

00:07:41,860 --> 00:07:46,449
The JavaScript's generated output is a pizza.

00:07:46,449 --> 00:07:52,259
Your end using is a super hero because this is how we should think about our users, and

00:07:52,259 --> 00:07:55,740
we are going to have this interesting thing that is a basket, and so there you can think

00:07:55,740 --> 00:07:59,770
of that as a data centre, a point of presence, or a cache node.

00:07:59,770 --> 00:08:02,520
Let's take a look at what client-side rendering looks like.

00:08:02,520 --> 00:08:07,860
With client-side rendering, what we do is we have our chef in New York, and we have

00:08:07,860 --> 00:08:10,590
our person who wants to eat pizza in Australia.

00:08:10,590 --> 00:08:16,699
When we render on the client, we send the chef to Australia.

00:08:16,699 --> 00:08:17,900
That's a lot, right?

00:08:17,900 --> 00:08:21,800
And then, what the chef has to do is then the chef has to cook.

00:08:21,800 --> 00:08:25,570
And then, at that point, you have delivered your pizza in Australia.

00:08:25,570 --> 00:08:28,620
But that's a little concerning, right?

00:08:28,620 --> 00:08:34,159
Like, maybe the person in Australia doesn't have like a whole room with an oven for a

00:08:34,159 --> 00:08:36,280
<to move in and start cooking.

00:08:36,280 --> 00:08:40,260
Like maybe they have a flip phone that literally can't do that.

00:08:40,260 --> 00:08:43,300
This is a little bit after complicated situation.

00:08:43,300 --> 00:08:45,690
So, of course be what do we do?

00:08:45,690 --> 00:08:46,690
Let's throw a cache on it.

00:08:46,690 --> 00:08:48,850
That should make it better, right?

00:08:48,850 --> 00:08:55,820
Instead, with our cache, we send our chef to a basket, you know, and the Pacific Ocean,

00:08:55,820 --> 00:08:57,380
South Pacific.

00:08:57,380 --> 00:09:04,380
We send the whole chef and then we still have to send the whole chef to Australia where

00:09:04,380 --> 00:09:06,380
they cook and they make their pizza.

00:09:06,380 --> 00:09:10,350
Again, we still have this situation, even with the cache, where the chef is travelling

00:09:10,350 --> 00:09:14,820
for maybe a closer location, but these still have to go into that person's house and make

00:09:14,820 --> 00:09:15,820
that pizza.

00:09:15,820 --> 00:09:17,940
That's pretty invasive be think.

00:09:17,940 --> 00:09:19,360
All right?

00:09:19,360 --> 00:09:23,000
So we can keep sending those chefs, but, yes.

00:09:23,000 --> 00:09:24,820
Again, we have another option, right?

00:09:24,820 --> 00:09:29,630
We have server-side rendering, and of course as everyone said, ten years ago at JSConf

00:09:29,630 --> 00:09:37,970
you, Ryan Dahl announced node.js and it was cool because it promised to unify web development

00:09:37,970 --> 00:09:39,530
on the client side and the server.

00:09:39,530 --> 00:09:41,760
It's like why do it in two languages?

00:09:41,760 --> 00:09:43,710
Let's do it in one.

00:09:43,710 --> 00:09:47,850
That made the server accessible to JavaScript developers.

00:09:47,850 --> 00:09:52,870
Maybe not for the first time, but for the first time for fin who didn't want to learn

00:09:52,870 --> 00:09:54,130
a new language.

00:09:54,130 --> 00:09:58,030
So let's take a look at what server-side rendering looks like.

00:09:58,030 --> 00:10:01,800
We got our chef in New York and our super hero in Australia.

00:10:01,800 --> 00:10:03,120
They're going to cook in New York.

00:10:03,120 --> 00:10:05,680
No more moving into the house to make pizza.

00:10:05,680 --> 00:10:07,120
They're going to send that right on over.

00:10:07,120 --> 00:10:10,660
Not bad, but that's a pretty long trip for some pizza, right?

00:10:10,660 --> 00:10:12,260
I'm not sure that's going to hold up.

00:10:12,260 --> 00:10:14,970
Fresh pizza's very important, right?

00:10:14,970 --> 00:10:18,139
So maybe that's not the freshest of pizzas.

00:10:18,139 --> 00:10:19,560
Let's throw a cache on it, right?

00:10:19,560 --> 00:10:21,380
Cool, we will throw a cache on it.

00:10:21,380 --> 00:10:22,449
So cool.

00:10:22,449 --> 00:10:27,500
The chef can still make their pizza in New York, and now they can just send it on over

00:10:27,500 --> 00:10:33,200
to that cache and the pizza can hang out there, and then our Australia person can happily

00:10:33,200 --> 00:10:36,610
eat all the pizza they would like.

00:10:36,610 --> 00:10:39,080
But that pizza maybe, it's a little old.

00:10:39,080 --> 00:10:40,080
I don't know.

00:10:40,080 --> 00:10:41,810
What if they wanted an extra topping on something?

00:10:41,810 --> 00:10:45,190
They would have to go all the way back, and that's really not efficient.

00:10:45,190 --> 00:10:50,220
So, when we talk about the client and server, and we've heard other people talk about this

00:10:50,220 --> 00:10:55,420
at this conference already, is that we are seeing frameworks realise they have to negotiate

00:10:55,420 --> 00:10:57,300
this boundary better.

00:10:57,300 --> 00:11:02,310
But that's really only just starting, and we are still genuinely talking about these

00:11:02,310 --> 00:11:08,209
trade-offs between the client and the server, and they're tricky trade-offs.

00:11:08,209 --> 00:11:12,670
Now, it wouldn't be an Ashley Williams talk if, when I said "trade doc" I didn't immediately

00:11:12,670 --> 00:11:16,149
start talking about dialectics.

00:11:16,149 --> 00:11:23,880
Who here knows what a dialectics is?

00:11:23,880 --> 00:11:24,880
Dia what?

00:11:24,880 --> 00:11:26,560
It is super foreign.

00:11:26,560 --> 00:11:32,780
There's an idea of formal logic where you say A equals A. This is a thing, and then

00:11:32,780 --> 00:11:35,240
that thing is always equal to this thing.

00:11:35,240 --> 00:11:36,500
We use this a lot in science.

00:11:36,500 --> 00:11:43,410
We say when we reach a contradiction, maybe where A doesn't equal A, we are wrong, right?

00:11:43,410 --> 00:11:49,320
A does not equal A. However, I think that this is completely backwards.

00:11:49,320 --> 00:11:57,300
In fact, the dialectical method, in contrast of formal logic, challenges to contradictions.

00:11:57,300 --> 00:12:03,949
Fundamentally, the idea of dialectics is that the motor of history is these oppositions,

00:12:03,949 --> 00:12:09,370
and that resolving those oppositions and pushing them forward as the synthesis of the oppositions

00:12:09,370 --> 00:12:14,690
is what makes things happen, and I get so excited about this because I am a giant philosophy

00:12:14,690 --> 00:12:20,190
nerd, so this is the philosophy nerd version of the diagram but this one will go over a

00:12:20,190 --> 00:12:21,720
little bit better.

00:12:21,720 --> 00:12:23,200
Just wait for it.

00:12:23,200 --> 00:12:27,529
This will explain everything.

00:12:27,529 --> 00:12:29,120
There we go!

00:12:29,120 --> 00:12:31,820
Dialectics, right?

00:12:31,820 --> 00:12:36,550
I want to see here we've been kind of assuming this trade-off between client and server for

00:12:36,550 --> 00:12:41,570
a very long time, and then maybe dichotomy is the problem.

00:12:41,570 --> 00:12:47,190
All right, so, we've got this problem, stuff is slow, we've got the client, we've got the

00:12:47,190 --> 00:12:49,600
server, they seem to be in opposition, we have no way to resolve them.

00:12:49,600 --> 00:12:51,470
What is to be done?

00:12:51,470 --> 00:12:55,759
As I told you, I work to of a big orange cloud, and this big orange cloud has a ton of baskets

00:12:55,759 --> 00:12:57,240
all over the earth.

00:12:57,240 --> 00:13:02,300
One day, they were like what should we do with all these bassets?

00:13:02,300 --> 00:13:06,110
We've been storing static assets in them but maybe we could do something cooler.

00:13:06,110 --> 00:13:07,220
This is a direct quote.

00:13:07,220 --> 00:13:11,029
Just kidding, it's not a direct quote at all!

00:13:11,029 --> 00:13:18,040
What this became was like we have the client and the server, let's kind of take those oppositions,

00:13:18,040 --> 00:13:22,120
synthesise them, and create the Edge.

00:13:22,120 --> 00:13:23,880
So let's take a look at what that looks like.

00:13:23,880 --> 00:13:25,829
We are back to pizza, all.

00:13:25,829 --> 00:13:27,680
I hope you're into it.

00:13:27,680 --> 00:13:31,180
So with Edge-side rendering, we have the basket and the chef.

00:13:31,180 --> 00:13:34,490
The chef lives in the basket.

00:13:34,490 --> 00:13:39,280
In our previous examples, no-one could cook in the basket.

00:13:39,280 --> 00:13:42,810
But with Edge-side rendering, you can cook in the basket!

00:13:42,810 --> 00:13:46,810
And so, now the chef doesn't have to move into your house and make pizza, they can hang

00:13:46,810 --> 00:13:52,310
out in the basket that's near your house, make you pizza, and then deliver it to you.

00:13:52,310 --> 00:13:53,459
That's pretty sweet.

00:13:53,459 --> 00:13:58,680
But, this kind of looks a lot like server-side rendering, a little bit, right?

00:13:58,680 --> 00:14:00,300
Like, it's just one.

00:14:00,300 --> 00:14:05,569
But the real trick is, remember, we don't just have one basket, we have a lot of baskets.

00:14:05,569 --> 00:14:11,930
So, at any point in time, these chefs can be making pizza and sending them to people

00:14:11,930 --> 00:14:17,019
all over the world so everybody can have pizza that is nice and fresh without someone messing

00:14:17,019 --> 00:14:19,399
up their kitchen.

00:14:19,399 --> 00:14:22,730
That's what the Edge is.

00:14:22,730 --> 00:14:25,200
You might be asking this is a talk about performance.

00:14:25,200 --> 00:14:27,160
How fast are you?

00:14:27,160 --> 00:14:28,160
Right?

00:14:28,160 --> 00:14:32,010
So benchmarks are done and I'm going to show you some.

00:14:32,010 --> 00:14:33,279
Your mileage may vary.

00:14:33,279 --> 00:14:36,710
These were done yesterday in who knows what will happen tomorrow?

00:14:36,710 --> 00:14:40,120
These are good representative benchmarks of what we have.

00:14:40,120 --> 00:14:49,360
There is something called serverlessbenchmark.com, but these are competitive numbers.

00:14:49,360 --> 00:14:52,210
I don't want to do a product talk where I compete against other products.

00:14:52,210 --> 00:14:57,790
I want to skip over that one and do what I call big numbers are big, small numbers are

00:14:57,790 --> 00:15:00,860
small, all numbers on small.

00:15:00,860 --> 00:15:08,139
These are numbers for response times, in Cape Town, and, so worker are respond in about

00:15:08,139 --> 00:15:14,589
143 milliseconds, and a GitHub pages is going to respond in 591.

00:15:14,589 --> 00:15:25,730
In Doha, worker will respond in 44 milliseconds, in GitHub pages, 497 milliseconds.

00:15:25,730 --> 00:15:27,360
What about Australia?

00:15:27,360 --> 00:15:31,690
A worker, 208 milliseconds, GitHub pages 624.

00:15:31,690 --> 00:15:35,120
Those are some big numbers.

00:15:35,120 --> 00:15:38,110
Remember, these are people accessing the internet.

00:15:38,110 --> 00:15:41,720
Maybe you'll call me a millennial, but if I don't have access to the internet, I actually

00:15:41,720 --> 00:15:42,720
get nervous.

00:15:42,720 --> 00:15:44,280
Emotional health.

00:15:44,280 --> 00:15:46,480
Also, it's all of this information.

00:15:46,480 --> 00:15:51,680
All of the ability to prosper currently on earth is largely driven by the internet, and

00:15:51,680 --> 00:15:52,829
so this axis matters.

00:15:52,829 --> 00:15:57,760
Could you imagine having to wait that much more time just to get, I don't know, you probably

00:15:57,760 --> 00:15:58,760
read Reddit.

00:15:58,760 --> 00:16:04,850
You would have to wait so long, it'll be terrible.

00:16:04,850 --> 00:16:09,670
Reykjavik Iceland, 170 milliseconds.

00:16:09,670 --> 00:16:13,329
Now you're probably asking me how do you do that?

00:16:13,329 --> 00:16:16,639
That is very interesting, or hopefully you think it's interesting.

00:16:16,639 --> 00:16:18,500
Let's talk a little bit about it.

00:16:18,500 --> 00:16:23,019
We have all of these baskets, and it turns out that trying to cook pizza on these baskets

00:16:23,019 --> 00:16:27,580
actually has a lot of fascinating constraints, and so the first thing we can think about

00:16:27,580 --> 00:16:28,580
is scaleability.

00:16:28,580 --> 00:16:33,899
So, for Cloudflare, scaleability, traffic, or requests, they're super easy, never gets

00:16:33,899 --> 00:16:34,899
huge.

00:16:34,899 --> 00:16:37,720
I think it can take over 30 terabytes of traffic over it.

00:16:37,720 --> 00:16:40,290
It's a lot, and it's continuing to grow.

00:16:40,290 --> 00:16:46,759
However, for this model to work, this idea of tenants, or how many apps we can put in

00:16:46,759 --> 00:16:49,510
the basket is super hard.

00:16:49,510 --> 00:16:55,339
Every app needs to be in some location, and some places are very small.

00:16:55,339 --> 00:17:01,290
We are looking at a need for 100 times efficiency than what you usually see on a server-side

00:17:01,290 --> 00:17:02,820
offering.

00:17:02,820 --> 00:17:04,790
We came one a set of constraints.

00:17:04,790 --> 00:17:09,950
The first was for the code footprint, the base amount of what the app needs to be, a

00:17:09,950 --> 00:17:17,760
VM requires ten gigabytes, a container around 100 and then what we needed was less than

00:17:17,760 --> 00:17:19,490
one.

00:17:19,490 --> 00:17:20,490
Less than one.

00:17:20,490 --> 00:17:21,490
That's a pretty big deal.

00:17:21,490 --> 00:17:22,490
All right?

00:17:22,490 --> 00:17:27,050
And then from memory usage, a VM is going to require at least one gig a container, again,

00:17:27,050 --> 00:17:31,919
around the same that had for the footprint but we needed to do under five.

00:17:31,919 --> 00:17:32,919
All right?

00:17:32,919 --> 00:17:36,950
And this is fundamentally because the Edge is not a large place, or like here, the kids

00:17:36,950 --> 00:17:40,650
call it, the Edge is not thick at all.

00:17:40,650 --> 00:17:42,420
It's very small.

00:17:42,420 --> 00:17:48,150
We have to get everyone's apps on here because we want everyone to be super fast, all right?

00:17:48,150 --> 00:17:53,150
Additionally, because of the needs that we have, context-switching is very interesting

00:17:53,150 --> 00:17:54,150
thing.

00:17:54,150 --> 00:17:56,820
For a VM, very low context-switching is needed.

00:17:56,820 --> 00:17:59,490
Maybe for a container, a little bit more.

00:17:59,490 --> 00:18:10,520
We need context switching because the apps only run local to it.

00:18:10,520 --> 00:18:13,870
We don't need to be running that app all the time.

00:18:13,870 --> 00:18:18,480
We need to be able to switch back and forth between apps incredibly quickly, like to the

00:18:18,480 --> 00:18:23,810
point where switching processes would be too much overhead.

00:18:23,810 --> 00:18:28,760
That's a pretty big constraint, all right?

00:18:28,760 --> 00:18:30,710
Start-up time is a fascinating constraint.

00:18:30,710 --> 00:18:36,490
A VM is going to take around ten seconds, a container 500 milliseconds.

00:18:36,490 --> 00:18:44,760
We need it to be less than someone will notice - around one 50th of the blink of an eye.

00:18:44,760 --> 00:18:46,350
Why do we need that?

00:18:46,350 --> 00:18:50,580
If people start using too many resources on our Edge, we need to be able to kick them

00:18:50,580 --> 00:18:52,110
out quick.

00:18:52,110 --> 00:18:57,440
But, if they get another request in, we need to be able to start them back up quickly again

00:18:57,440 --> 00:19:00,320
in a way that the user never would notice, all right?

00:19:00,320 --> 00:19:03,640
These are some pretty serious constraints, right?

00:19:03,640 --> 00:19:08,330
But, there's other things that also have these same constraints.

00:19:08,330 --> 00:19:14,289
For example, certain APIs, particularly APIs that speak to our APIs may need to run client

00:19:14,289 --> 00:19:18,720
code directly on the server, because it needs to be more efficient.

00:19:18,720 --> 00:19:20,510
Similar with big-data processing.

00:19:20,510 --> 00:19:25,919
With big data, you can't bring the data to the app, you bring the app to the data.

00:19:25,919 --> 00:19:28,460
It's similar constraints to what we have.

00:19:28,460 --> 00:19:34,559
Also, web browsers also have the exact same constraints.

00:19:34,559 --> 00:19:38,929
They need to be constantly running all of that code from all of those websites that

00:19:38,929 --> 00:19:42,880
you go to that all of you are writing.

00:19:42,880 --> 00:19:47,000
This is where I say web browsers are freaking awesome.

00:19:47,000 --> 00:19:54,230
We have actually already solved this that is namespacing server-side need with a client-side

00:19:54,230 --> 00:19:55,270
technology.

00:19:55,270 --> 00:20:00,340
Like server technology is actually too slow, and building out server-side technology, have

00:20:00,340 --> 00:20:07,440
we overlooked the fact that we have this beautiful technology that is our client for the web?

00:20:07,440 --> 00:20:11,730
Browsers are optimised for exactly the types of things that we need in a type of serverless

00:20:11,730 --> 00:20:14,260
properly.

00:20:14,260 --> 00:20:17,860
They've got fast start-ups, someone is literally there waiting for it.

00:20:17,860 --> 00:20:19,240
They're going to be moving quick.

00:20:19,240 --> 00:20:23,510
Remember, we talked about computation in the browser and how optimising rates has been

00:20:23,510 --> 00:20:24,510
getting, all right?

00:20:24,510 --> 00:20:30,510
I don't know about you, but I usually have around 100 tabs open at once, and that's a

00:20:30,510 --> 00:20:31,809
lot of processes.

00:20:31,809 --> 00:20:37,539
You also have to remember that a single page is not always a single website.

00:20:37,539 --> 00:20:38,950
There are plenty of iFrames.

00:20:38,950 --> 00:20:45,530
That like button is its own context and the browser is orchestrating all of that.

00:20:45,530 --> 00:20:51,520
Additionally, and I know people will fight me on this, browsers are optimised for secure

00:20:51,520 --> 00:20:52,520
isolation.

00:20:52,520 --> 00:20:57,760
When you go to a website, if it was able to leak all that stuff out to your other websites,

00:20:57,760 --> 00:21:00,850
we would be in a big, big problem.

00:21:00,850 --> 00:21:08,679
So, the architect of this run time said web browsers has been the most hostile security

00:21:08,679 --> 00:21:11,750
environment for quite some time.

00:21:11,750 --> 00:21:14,360
And I'm inclined to agree with him on this.

00:21:14,360 --> 00:21:16,090
I think this makes sense.

00:21:16,090 --> 00:21:24,100
So, with deciding what we were going to do for a serverless run time, we picked V8.

00:21:24,100 --> 00:21:26,670
Come on!

00:21:26,670 --> 00:21:41,460
We chose to run the serverless run time on V8 using this class of V8 isolate.

00:21:41,460 --> 00:21:47,470
You could traditionally think of this more like a VM but the word "VM" has kind of changed

00:21:47,470 --> 00:21:51,179
so this is more of a JVM which is not the same.

00:21:51,179 --> 00:21:58,940
You can understand it as a light weight context sandbox, so why is this better an VMs or containers?

00:21:58,940 --> 00:22:02,309
It is basically because you get to share more.

00:22:02,309 --> 00:22:05,100
It's like a little bit more communist, right?

00:22:05,100 --> 00:22:10,320
VMs, you get the hardware virtualised, and then you've not to bring everything else on

00:22:10,320 --> 00:22:11,320
your own.

00:22:11,320 --> 00:22:15,940
Containers, all right, you get the operating system, but again, bringing everything else

00:22:15,940 --> 00:22:16,970
on your own.

00:22:16,970 --> 00:22:23,370
With isolates, you get web platform APIs, the JS run time, and operating system, hardware,

00:22:23,370 --> 00:22:27,850
and you just show up with your application and maybe a couple of weird libraries you

00:22:27,850 --> 00:22:34,230
wrote, and that's freaking awesome, and, because we can share so much, we can very efficiently

00:22:34,230 --> 00:22:35,440
use resources.

00:22:35,440 --> 00:22:39,789
And so just to take a kind of look at what this is, in a virtual machine you can see

00:22:39,789 --> 00:22:44,600
that the process overhead is one-to-one with the user code, whereas with the isolate model,

00:22:44,600 --> 00:22:47,490
you can see that it is definitely many to one.

00:22:47,490 --> 00:22:51,110
This is how we are getting those benchmarks that we are talking about.

00:22:51,110 --> 00:22:57,159
So, in addition to using V8, we have built a coding environment for you that uses the

00:22:57,159 --> 00:23:01,159
Fetch API and the service worker API.

00:23:01,159 --> 00:23:04,650
You can build it out in a UI that looks a little bit like this.

00:23:04,650 --> 00:23:09,159
You literally just have to have something for fetch events, and then you write a function

00:23:09,159 --> 00:23:10,820
that can handle requests.

00:23:10,820 --> 00:23:15,190
You can do plenty of other things but this is the bare minimum worker in what is looks

00:23:15,190 --> 00:23:16,779
like.

00:23:16,779 --> 00:23:20,240
Because we're using V8, we get ... for free.

00:23:20,240 --> 00:23:27,400
If JavaScript is not your jam, feel free to use a target for WebAssembly and we can use

00:23:27,400 --> 00:23:28,980
that.

00:23:28,980 --> 00:23:35,360
You might be thinking this looks like a lot like an operating system, and, man, I would

00:23:35,360 --> 00:23:39,600
like to talk about how that is true but I have literally no time left.

00:23:39,600 --> 00:23:43,800
I would recommend that you check this out if you want to learn about how we've tried

00:23:43,800 --> 00:23:47,960
to tame the um killer, that's really fun.

00:23:47,960 --> 00:23:52,179
Before I finish up, I do want to say, is this a good idea?

00:23:52,179 --> 00:23:56,300
Right, like, oh, cool, you can do it, but like should you?

00:23:56,300 --> 00:24:03,039
So a lot people will be like, yes, there is a spectre haunting this architecture.

00:24:03,039 --> 00:24:04,230
Right?

00:24:04,230 --> 00:24:07,799
Wrong talk, sorry!

00:24:07,799 --> 00:24:08,799
This one!

00:24:08,799 --> 00:24:09,799
Spectre!

00:24:09,799 --> 00:24:11,860
It's a fascinating memory bug.

00:24:11,860 --> 00:24:14,679
I don't have time to go into explaining it.

00:24:14,679 --> 00:24:19,890
What I will tell you is that we've made some mitigations to attempt to avoid it.

00:24:19,890 --> 00:24:24,290
Spectre is a bug that goes all the way down to the depths of the stack, and many of us

00:24:24,290 --> 00:24:27,649
are just trying to cope as you pop up it.

00:24:27,649 --> 00:24:32,220
This is it what we've been doing so far.. primarily, we are letting you avoiding the

00:24:32,220 --> 00:24:33,890
any sort of timer.

00:24:33,890 --> 00:24:40,620
If you use date.now in a worker, it will tell you the same time every time.

00:24:40,620 --> 00:24:44,390
We don't allow local concurrency because that's a timer in disguise.

00:24:44,390 --> 00:24:50,059
But one of the things that we are also able to do is we have the freedom to reschedule.

00:24:50,059 --> 00:24:53,150
We can take the look at someone who is kind of looking a little weird, a worker that is

00:24:53,150 --> 00:24:59,289
behaving funny, and we can say, "Hey, let's kick you out, keep an eye on you, stick you

00:24:59,289 --> 00:25:00,419
in your own little box."

00:25:00,419 --> 00:25:05,929
Hopefully, I have encouraged you to think that is it a somewhat cool technology, and

00:25:05,929 --> 00:25:10,110
that it's fast, and maybe you want to use it because you want to get fresh pizza to

00:25:10,110 --> 00:25:11,720
everybody in the world.

00:25:11,720 --> 00:25:16,210
But, let's talk about how you can actually use it, because, accessible isn't just about

00:25:16,210 --> 00:25:20,559
receiving content, it's about building content that other people can receive.

00:25:20,559 --> 00:25:26,450
I joined Cloudflare two months ago and it was like oh, shoot, we've got to make this

00:25:26,450 --> 00:25:28,490
developer experience way better.

00:25:28,490 --> 00:25:31,820
People do not like curl commands and API keys in them.

00:25:31,820 --> 00:25:34,440
That's not cool, all right?

00:25:34,440 --> 00:25:39,059
So, you may have seen me on a couch yesterday, but I've been working on this tool called

00:25:39,059 --> 00:25:40,059
Wrangler.

00:25:40,059 --> 00:25:44,080
It was originally released for building Rust WebAssembly workers in Cloudflare but now

00:25:44,080 --> 00:25:48,179
a fully fledged CLI for loading any type of worker you like.

00:25:48,179 --> 00:25:53,150
I found this picture of a crab with a cowboy hat on it.

00:25:53,150 --> 00:25:56,900
You can npm install it, and it will just work for you.

00:25:56,900 --> 00:25:59,250
It looks a little bit like this.

00:25:59,250 --> 00:26:01,350
I couldn't speed this gif up.

00:26:01,350 --> 00:26:02,350
Boom.

00:26:02,350 --> 00:26:04,610
So, if you like emojis, there are a lot of them.

00:26:04,610 --> 00:26:08,520
If your terminal doesn't support them, we have fallback.

00:26:08,520 --> 00:26:12,110
We've set up a template gallery because maybe you don't note what you want to build with

00:26:12,110 --> 00:26:16,179
something like this, so you can just generate one of these templates and get going with

00:26:16,179 --> 00:26:17,179
it.

00:26:17,179 --> 00:26:21,059
Each one will create a functional work I don't remember er for you, and so that is pretty

00:26:21,059 --> 00:26:22,059
awesome.

00:26:22,059 --> 00:26:27,529
So you can run this, command, and just publish, and it will be successfully published at this

00:26:27,529 --> 00:26:29,260
fascinating URL.

00:26:29,260 --> 00:26:34,520
How many people here signed up for workers.dev subdomain?

00:26:34,520 --> 00:26:35,520
We've got three.

00:26:35,520 --> 00:26:39,950
Here's the thing: remember that fucking DNS tweet?

00:26:39,950 --> 00:26:41,529
I hate setting up DNS.

00:26:41,529 --> 00:26:42,529
Maybe you too.

00:26:42,529 --> 00:26:47,770
To get started playing with this kind of thing, you do not need to set up any sort of DNS.

00:26:47,770 --> 00:26:53,330
We will give you a free subdomain on workers.dev you can get it by running the wranglers subdomain

00:26:53,330 --> 00:26:59,390
command, snag that for you, and you can put the apps and workers you would like on it.

00:26:59,390 --> 00:27:02,050
Finally, we've got cool new docs.

00:27:02,050 --> 00:27:04,130
They are also written as a worker.

00:27:04,130 --> 00:27:07,350
So, that is good.

00:27:07,350 --> 00:27:10,351
And the big announcement here is you probably like why do I care about this?

00:27:10,351 --> 00:27:19,669
This is a company, corporate product announcement, but today we are making it free.

00:27:19,669 --> 00:27:23,730
[Cheering and applause].

00:27:23,730 --> 00:27:29,180
I'm really excited because Cloudflare workers are actually the first free Edge serverless

00:27:29,180 --> 00:27:30,180
platform.

00:27:30,180 --> 00:27:35,020
You cannot put something on the Edge, be it our Edge or someone else's Edge without paying

00:27:35,020 --> 00:27:36,490
money.

00:27:36,490 --> 00:27:41,712
I'm excited to get people playing in this awesome spot because I think it will change

00:27:41,712 --> 00:27:49,380
how we think about applications, particularly as a more distributed thing across the world,

00:27:49,380 --> 00:27:51,460
and not having to think about server and client.

00:27:51,460 --> 00:27:55,380
So we have a free tier, this is some stuff about it.

00:27:55,380 --> 00:28:00,190
Again, go forth and build, but I have one final message for you, because I'm not done,

00:28:00,190 --> 00:28:06,630
and I am almost certainly over time, but, it's an Ashley talk, so we are going to go

00:28:06,630 --> 00:28:07,630
over.

00:28:07,630 --> 00:28:11,370
I want us to do some thinking, like, it's cool, this Edge thing.

00:28:11,370 --> 00:28:16,710
It's free, and I want you to go and use it and build awesome accessibility apps, but,

00:28:16,710 --> 00:28:20,720
the real point of this talk is that I want people to think more radically, and, with

00:28:20,720 --> 00:28:27,250
more people who don't look like us about how the internet works, and how it could work.

00:28:27,250 --> 00:28:28,250
Right?

00:28:28,250 --> 00:28:33,539
When we encounter trade-offs like the client and the server, I think a lot of people think

00:28:33,539 --> 00:28:34,539
that's how it is.

00:28:34,539 --> 00:28:35,850
That's what we've to do, right?

00:28:35,850 --> 00:28:38,539
We have the client server, we can't change that.

00:28:38,539 --> 00:28:42,840
What I want to encourage you to find oppositions like that and challenge them because those

00:28:42,840 --> 00:28:49,880
oppositions are opportunities for making strides in accessibility for the web, like what we

00:28:49,880 --> 00:28:51,480
are doing today.

00:28:51,480 --> 00:28:55,450
And so, again, we've talked about journeys, we've talked about performance, we've talked

00:28:55,450 --> 00:29:01,201
about accessibility, the web is the primary place that new developers go to learn, so

00:29:01,201 --> 00:29:03,640
let's make sure we can get there fast.

00:29:03,640 --> 00:29:08,230
The future with the .just community which is representative of the whole world literally

00:29:08,230 --> 00:29:10,130
cannot come soon enough.

00:29:10,130 --> 00:29:11,130
Thanks!

00:29:11,130 --> 00:29:11,230

YouTube URL: https://www.youtube.com/watch?v=MBndZddVQdw


