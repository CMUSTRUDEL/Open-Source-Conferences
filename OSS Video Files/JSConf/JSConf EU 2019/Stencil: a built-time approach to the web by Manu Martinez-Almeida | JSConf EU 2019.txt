Title: Stencil: a built-time approach to the web by Manu Martinez-Almeida | JSConf EU 2019
Publication date: 2019-06-07
Playlist: JSConf EU 2019
Description: 
	This is "Stencil: a built-time approach to the web". Sorry, we messed up the title of the talk in the intro. 

We all know and love framework-like features such as hot module replacement, reactive properties, templating, CSS-in-JS, lazy-loaded bundling, etc. Stencil is a new approach, a build-time abstraction with framework-level productivity, that generates hand-optimized components using future-proof web APIs. Weâ€™ll discuss the architecture of Stencil and the innovations a compiler can introduce to your apps and design systems!

https://2019.jsconf.eu/manu-martinez-almeida/stencil-a-built-time-approach-to-the-web.html
Captions: 
	00:00:00,760 --> 00:00:06,289
[Music]

00:00:10,099 --> 00:00:17,850
hello when I star this hi everyone I'm

00:00:14,940 --> 00:00:19,590
so excited to be here I hope you like my

00:00:17,850 --> 00:00:22,380
talk is the last one we had everyone a

00:00:19,590 --> 00:00:24,240
little bit tired but - today I'm going

00:00:22,380 --> 00:00:26,010
to talk about the stencil which is this

00:00:24,240 --> 00:00:29,220
open-source project we have been working

00:00:26,010 --> 00:00:31,830
for the last few years and in general I

00:00:29,220 --> 00:00:34,530
have a compiler can help you build

00:00:31,830 --> 00:00:37,469
better applications and in general most

00:00:34,530 --> 00:00:39,090
specifically based design systems so my

00:00:37,469 --> 00:00:42,030
name is manu and i work as a server

00:00:39,090 --> 00:00:43,440
engineer at ionic which is the the team

00:00:42,030 --> 00:00:46,980
that builds ionic framework and a

00:00:43,440 --> 00:00:48,719
stencil itself so we basically are a

00:00:46,980 --> 00:00:51,149
company a tooling company at one - bill

00:00:48,719 --> 00:00:54,800
to help web developers build

00:00:51,149 --> 00:00:57,750
applications 100% based in western ology

00:00:54,800 --> 00:01:00,570
so okay so before getting into much

00:00:57,750 --> 00:01:03,719
detail I want to start with true history

00:01:00,570 --> 00:01:05,760
is that 12 years ago JavaScript was not

00:01:03,719 --> 00:01:07,260
what it is today it was a mess

00:01:05,760 --> 00:01:10,260
different browsers have different

00:01:07,260 --> 00:01:13,680
behavior Internet Explorer an escape and

00:01:10,260 --> 00:01:16,320
JavaScript itself like the high level

00:01:13,680 --> 00:01:17,700
API is that today we consider basic so

00:01:16,320 --> 00:01:21,930
it was really hard to break complex

00:01:17,700 --> 00:01:23,880
application on top of it then something

00:01:21,930 --> 00:01:25,560
happened chicory appear and he came to

00:01:23,880 --> 00:01:27,509
solve all the problems that JavaScript

00:01:25,560 --> 00:01:29,250
had at that time it normalized the

00:01:27,509 --> 00:01:32,939
behavior between browsers and provide a

00:01:29,250 --> 00:01:34,619
higher set of API so that actually some

00:01:32,939 --> 00:01:37,290
of them are part of the of the web today

00:01:34,619 --> 00:01:39,090
like curry selector so but the biggest

00:01:37,290 --> 00:01:41,790
innovation is that it allows Java Script

00:01:39,090 --> 00:01:43,409
to grow as a language and allowed to to

00:01:41,790 --> 00:01:45,750
be used for more complex application

00:01:43,409 --> 00:01:48,810
that just like some simple formalization

00:01:45,750 --> 00:01:50,899
and in fact my company bill Kodaka was

00:01:48,810 --> 00:01:53,640
one was one of the first Design Systems

00:01:50,899 --> 00:01:56,280
sorry drag and drop tools for UI

00:01:53,640 --> 00:01:58,979
components and it was based in jQuery

00:01:56,280 --> 00:02:01,079
Mobile so in order to instantiate and

00:01:58,979 --> 00:02:04,649
create these components you will have to

00:02:01,079 --> 00:02:08,310
use the imperative API of query so it

00:02:04,649 --> 00:02:08,700
work but it was not great and some years

00:02:08,310 --> 00:02:11,489
later

00:02:08,700 --> 00:02:13,350
ungulate years appear and the geo versus

00:02:11,489 --> 00:02:15,450
Java JavaScript

00:02:13,350 --> 00:02:18,570
system was a little bit healthier so the

00:02:15,450 --> 00:02:21,690
problem is that JavaScript had angularjs

00:02:18,570 --> 00:02:23,070
had to solve was not the same ones it

00:02:21,690 --> 00:02:25,890
doesn't only provide a higher layer of

00:02:23,070 --> 00:02:27,690
higher-level ap is by the way of working

00:02:25,890 --> 00:02:29,550
now we are organizing a set of good

00:02:27,690 --> 00:02:32,370
defaults but today we know has a

00:02:29,550 --> 00:02:34,830
framework so that help javascript to

00:02:32,370 --> 00:02:36,480
grow even more and introduce the country

00:02:34,830 --> 00:02:39,180
of directives that that was mine lying

00:02:36,480 --> 00:02:41,400
to us and it was closer at our idea of

00:02:39,180 --> 00:02:44,430
components so we were so excited about

00:02:41,400 --> 00:02:47,820
it that we decided to port everything we

00:02:44,430 --> 00:02:50,430
got into into this new system because it

00:02:47,820 --> 00:02:54,450
was a big step forward and that's how

00:02:50,430 --> 00:02:56,340
ionic was born then angular ideas the

00:02:54,450 --> 00:02:58,680
angular team announced angular 2 and it

00:02:56,340 --> 00:03:01,500
was going to be faster smaller mobile

00:02:58,680 --> 00:03:03,060
first everything so angularjs worked so

00:03:01,500 --> 00:03:06,090
great for us that we just decided to

00:03:03,060 --> 00:03:09,750
make the investment and that's how ionic

00:03:06,090 --> 00:03:11,670
2 ionic 3 bounce poor so even though the

00:03:09,750 --> 00:03:14,010
name is the same it will require a

00:03:11,670 --> 00:03:16,140
complete refactor and think about that

00:03:14,010 --> 00:03:19,800
this is already the third time that we

00:03:16,140 --> 00:03:22,560
have to go the same components and today

00:03:19,800 --> 00:03:23,820
well the ecosystem is completely

00:03:22,560 --> 00:03:25,800
different there are many frameworks and

00:03:23,820 --> 00:03:28,080
alternatives and all of them are great

00:03:25,800 --> 00:03:30,900
it just depends on your own preferences

00:03:28,080 --> 00:03:33,180
your team your team your skills your

00:03:30,900 --> 00:03:36,360
product or even was just easier for

00:03:33,180 --> 00:03:38,370
hiring in a specific country so going

00:03:36,360 --> 00:03:41,250
back to our mission as a company that we

00:03:38,370 --> 00:03:44,700
want to help all the web developers not

00:03:41,250 --> 00:03:46,050
the ones using a specific framework so

00:03:44,700 --> 00:03:48,780
we start thinking about how we could

00:03:46,050 --> 00:03:51,930
achieve that how we could if we have to

00:03:48,780 --> 00:03:53,850
port this 100 components through every

00:03:51,930 --> 00:03:56,250
popular framework of today and maybe

00:03:53,850 --> 00:03:58,290
tomorrow and of course the answer is not

00:03:56,250 --> 00:04:00,360
we know that we have to go through this

00:03:58,290 --> 00:04:01,890
refactor many many times and we know

00:04:00,360 --> 00:04:03,570
that that's not going to happen it's so

00:04:01,890 --> 00:04:04,920
time consuming it's and we quickly

00:04:03,570 --> 00:04:06,690
realize this is not going to be the

00:04:04,920 --> 00:04:10,560
solution so we have to think about

00:04:06,690 --> 00:04:14,340
something else and think like frameworks

00:04:10,560 --> 00:04:16,680
are great for building final products

00:04:14,340 --> 00:04:18,930
even if you say that reacts not a

00:04:16,680 --> 00:04:20,520
framework it is they built a framework

00:04:18,930 --> 00:04:24,300
on around it and that's not a bad thing

00:04:20,520 --> 00:04:26,730
it's inclusive create react app a router

00:04:24,300 --> 00:04:28,320
away of organized in a way of testing

00:04:26,730 --> 00:04:31,320
a set of good defaults and that makes

00:04:28,320 --> 00:04:33,660
sense because that allows you to focus

00:04:31,320 --> 00:04:35,520
into building your product you don't

00:04:33,660 --> 00:04:40,500
have to make these hundreds of micro

00:04:35,520 --> 00:04:42,240
decisions every single time so so yeah

00:04:40,500 --> 00:04:44,250
I'm not remain tabled in the wheel every

00:04:42,240 --> 00:04:46,710
time so but at the same time they are

00:04:44,250 --> 00:04:48,660
terrible for building reusable

00:04:46,710 --> 00:04:51,150
components and you might say that this

00:04:48,660 --> 00:04:53,880
is working for you today I mean it did

00:04:51,150 --> 00:04:56,550
for us but at some point you might want

00:04:53,880 --> 00:04:59,010
to use a different technology or the use

00:04:56,550 --> 00:05:01,740
cases change or you just want to serve

00:04:59,010 --> 00:05:04,010
your component with more people and not

00:05:01,740 --> 00:05:08,100
only people will use the same framework

00:05:04,010 --> 00:05:10,380
so the point of building reusable

00:05:08,100 --> 00:05:12,870
components is to last in time right so

00:05:10,380 --> 00:05:15,000
it's pretty much like investment you

00:05:12,870 --> 00:05:17,760
make to allow you to build faster in the

00:05:15,000 --> 00:05:19,440
future so you should build them on top

00:05:17,760 --> 00:05:21,840
of future proof technology as the web

00:05:19,440 --> 00:05:23,880
there's the web that doesn't change so

00:05:21,840 --> 00:05:25,650
the solution of this problem of course

00:05:23,880 --> 00:05:27,420
is where components but again this is

00:05:25,650 --> 00:05:29,310
very important web component doesn't not

00:05:27,420 --> 00:05:31,800
not solve any other problem yes

00:05:29,310 --> 00:05:34,350
universal model of components and even

00:05:31,800 --> 00:05:36,420
if you like it or not it will work so

00:05:34,350 --> 00:05:38,730
I'm sorry for real kites sometimes but

00:05:36,420 --> 00:05:43,500
this is will work you can go around it

00:05:38,730 --> 00:05:44,190
so but I'd say it doesn't handle

00:05:43,500 --> 00:05:47,070
anything else

00:05:44,190 --> 00:05:48,450
so you still I believe that frameworks

00:05:47,070 --> 00:05:51,060
policies forever they will not be

00:05:48,450 --> 00:05:53,400
replaced in the same way that angular

00:05:51,060 --> 00:05:55,890
and react and view does not replace the

00:05:53,400 --> 00:05:59,010
API is the Web API of today we just live

00:05:55,890 --> 00:06:02,310
together and of course we know in the

00:05:59,010 --> 00:06:04,710
past that some API is web api they break

00:06:02,310 --> 00:06:07,140
they remove sometimes but there is

00:06:04,710 --> 00:06:10,440
something in common for APS that have a

00:06:07,140 --> 00:06:13,080
full consensus across browsers as is

00:06:10,440 --> 00:06:16,650
that they will be around forever so even

00:06:13,080 --> 00:06:18,840
if yeah so think about the website you

00:06:16,650 --> 00:06:20,820
build 20 years ago is still worse today

00:06:18,840 --> 00:06:23,970
because the web can break I mean a

00:06:20,820 --> 00:06:26,040
banker can break but the web can't so if

00:06:23,970 --> 00:06:29,490
you will a web component with it it will

00:06:26,040 --> 00:06:34,230
still work in the future framework so

00:06:29,490 --> 00:06:35,970
around that idea of we want we don't

00:06:34,230 --> 00:06:37,830
want to make the decision of the frame

00:06:35,970 --> 00:06:39,330
where you have to use because you we

00:06:37,830 --> 00:06:40,319
don't know your product we just build

00:06:39,330 --> 00:06:43,050
the components

00:06:40,319 --> 00:06:45,629
so I run that idea we create ironically

00:06:43,050 --> 00:06:47,999
to the lightest ionic ionic for is based

00:06:45,629 --> 00:06:50,460
on web components and this fourth

00:06:47,999 --> 00:06:52,919
refactor is very different because this

00:06:50,460 --> 00:06:55,050
time we didn't build on top of the

00:06:52,919 --> 00:06:58,110
angularjs directives or the angular

00:06:55,050 --> 00:07:00,089
components this time is built on top of

00:06:58,110 --> 00:07:05,219
a standard way ap is they are just web

00:07:00,089 --> 00:07:07,349
components that stay in the HTML so but

00:07:05,219 --> 00:07:09,389
when before doing that we found that as

00:07:07,349 --> 00:07:11,189
I said like web components a very little

00:07:09,389 --> 00:07:14,669
label API that says it doesn't solve any

00:07:11,189 --> 00:07:18,089
other thing so what happens when a sober

00:07:14,669 --> 00:07:20,009
engineer has to deal with a you know

00:07:18,089 --> 00:07:22,469
with a low-level API well they just

00:07:20,009 --> 00:07:25,589
create an abstraction and that usually

00:07:22,469 --> 00:07:27,180
comes with a new problem and the safe of

00:07:25,589 --> 00:07:28,080
overhead but I'm not saying is a

00:07:27,180 --> 00:07:31,529
performance overhead

00:07:28,080 --> 00:07:33,330
it's a knowledge is a runtime locking

00:07:31,529 --> 00:07:35,639
you are not reading you are not longer

00:07:33,330 --> 00:07:37,589
building on top of this fix it

00:07:35,639 --> 00:07:39,919
Web API you are building on top of

00:07:37,589 --> 00:07:42,719
something else that can break and change

00:07:39,919 --> 00:07:44,909
so we are start thinking about what will

00:07:42,719 --> 00:07:47,399
be the sweet spot here

00:07:44,909 --> 00:07:49,169
what if the obstruction is a compiler

00:07:47,399 --> 00:07:51,779
time meaning that there is not any

00:07:49,169 --> 00:07:53,610
specific framework any specific runtime

00:07:51,779 --> 00:07:56,099
so you sip your component but the design

00:07:53,610 --> 00:07:57,809
comes with a well-defined runtime

00:07:56,099 --> 00:07:59,729
instead the compiler will take your

00:07:57,809 --> 00:08:02,309
components and generate the best

00:07:59,729 --> 00:08:04,069
possible source code I mean and it will

00:08:02,309 --> 00:08:06,269
generate the best possible component

00:08:04,069 --> 00:08:09,050
this has worked for decades like

00:08:06,269 --> 00:08:12,240
compiled languages like C and rest and

00:08:09,050 --> 00:08:14,969
they they don't have to care when

00:08:12,240 --> 00:08:17,879
interval this is a new CPU or they have

00:08:14,969 --> 00:08:19,860
to target a different CPU architecture

00:08:17,879 --> 00:08:22,649
instead they just use a different

00:08:19,860 --> 00:08:26,580
compiler or they upgrade the existing

00:08:22,649 --> 00:08:29,459
one and that exactly will stem sleights

00:08:26,580 --> 00:08:33,689
it's a build time abstraction it's a

00:08:29,459 --> 00:08:35,849
compiler for the well as knology the web

00:08:33,689 --> 00:08:39,630
will be this always moving target

00:08:35,849 --> 00:08:41,639
sorry the the web will be the hardware

00:08:39,630 --> 00:08:44,519
this always moving target and stencil

00:08:41,639 --> 00:08:47,480
the compiler taking your components and

00:08:44,519 --> 00:08:49,500
using the newest new newest api's

00:08:47,480 --> 00:08:52,980
without developers having to make any

00:08:49,500 --> 00:08:54,150
single change so the idea is that we are

00:08:52,980 --> 00:08:55,920
not only able to

00:08:54,150 --> 00:08:58,620
highly optimized components we will see

00:08:55,920 --> 00:09:00,960
later but avoid making any kind of

00:08:58,620 --> 00:09:03,660
breaking change and this is really

00:09:00,960 --> 00:09:06,750
important for us its main use case

00:09:03,660 --> 00:09:10,020
because we are we have already go

00:09:06,750 --> 00:09:11,700
through all these three factors and our

00:09:10,020 --> 00:09:13,740
main use case is to build reusable

00:09:11,700 --> 00:09:16,200
components decided implement design

00:09:13,740 --> 00:09:19,290
systems and being future proof so we

00:09:16,200 --> 00:09:22,910
have the same design the API a compiler

00:09:19,290 --> 00:09:26,040
of stencil to restrict ourselves to

00:09:22,910 --> 00:09:28,950
stand our interfaces like classes

00:09:26,040 --> 00:09:31,080
properties HTML attributes and Dom

00:09:28,950 --> 00:09:37,350
events we are don't try to have a

00:09:31,080 --> 00:09:39,210
stencil way of doing things so this way

00:09:37,350 --> 00:09:42,810
we can keep changing how the compiler

00:09:39,210 --> 00:09:45,810
works the mutations we apply and using

00:09:42,810 --> 00:09:47,280
new new API s without requiring

00:09:45,810 --> 00:09:49,920
developers to make any change so for

00:09:47,280 --> 00:09:52,500
example let's say that next year Chrome

00:09:49,920 --> 00:09:55,440
zips a new feature that this a built-in

00:09:52,500 --> 00:09:57,450
baton or some kind of template system

00:09:55,440 --> 00:09:59,490
this is going to be built into the

00:09:57,450 --> 00:10:03,000
browser and it's going to be much faster

00:09:59,490 --> 00:10:07,320
because well it's probably programming

00:10:03,000 --> 00:10:09,900
in C++ or wherever it is and you don't

00:10:07,320 --> 00:10:12,450
have to see any other script right so in

00:10:09,900 --> 00:10:13,920
a stencil that could happen and you will

00:10:12,450 --> 00:10:17,070
not have to make any change we will just

00:10:13,920 --> 00:10:19,530
tell your component and change how that

00:10:17,070 --> 00:10:21,900
thing works so even there is not a

00:10:19,530 --> 00:10:23,610
specific render like even you know like

00:10:21,900 --> 00:10:29,190
we are using some a specific rental

00:10:23,610 --> 00:10:30,900
render we could change it so in addition

00:10:29,190 --> 00:10:34,530
we can support our browsers in the same

00:10:30,900 --> 00:10:36,240
the same idea like like a cig compiler

00:10:34,530 --> 00:10:38,370
can different can generate different

00:10:36,240 --> 00:10:40,500
targets for a different browser after a

00:10:38,370 --> 00:10:42,540
sec Impaler can differ can generate code

00:10:40,500 --> 00:10:44,540
for different architectures we can do

00:10:42,540 --> 00:10:46,740
the same for different browsers without

00:10:44,540 --> 00:10:49,350
developers having to think about it

00:10:46,740 --> 00:10:51,390
so for example the molar bill the most

00:10:49,350 --> 00:10:55,380
of your users actually using Chrome

00:10:51,390 --> 00:10:57,450
Firefox Safari modern browsers will get

00:10:55,380 --> 00:11:00,750
the smallest bundle without any kind of

00:10:57,450 --> 00:11:04,320
polyfill without using modern JavaScript

00:11:00,750 --> 00:11:07,769
features like native async/await or ES

00:11:04,320 --> 00:11:10,290
modules and all browsers well if you had

00:11:07,769 --> 00:11:12,509
to support them like inference floor

00:11:10,290 --> 00:11:14,699
dibbles I get a little bit bigger es5

00:11:12,509 --> 00:11:17,639
angles and this is an example of the

00:11:14,699 --> 00:11:20,160
same component it's I am button

00:11:17,639 --> 00:11:23,819
it's Batum as a button with material

00:11:20,160 --> 00:11:25,739
design and iOS styles the stencil the

00:11:23,819 --> 00:11:29,480
compiler generates up to eight different

00:11:25,739 --> 00:11:31,529
versions but that doesn't mean that the

00:11:29,480 --> 00:11:33,540
that the client will have to download

00:11:31,529 --> 00:11:35,759
all these six files in fat is just going

00:11:33,540 --> 00:11:39,059
to download one of them so we can see

00:11:35,759 --> 00:11:42,029
that some files have the es5 prefix or

00:11:39,059 --> 00:11:46,139
yeah so that means that it's cs5 is all

00:11:42,029 --> 00:11:48,209
the code SC means that for browser that

00:11:46,139 --> 00:11:50,100
doesn't support out on but in any case

00:11:48,209 --> 00:11:52,350
this way we can cover the whole spectrum

00:11:50,100 --> 00:11:56,040
of browsers in the most efficient way

00:11:52,350 --> 00:11:58,739
and we can provide that and we can do it

00:11:56,040 --> 00:12:00,509
with the vests developer experience the

00:11:58,739 --> 00:12:02,429
one you are used to it because think

00:12:00,509 --> 00:12:05,189
about it we build a stencil for us and

00:12:02,429 --> 00:12:06,720
obviously we use frameworks before so we

00:12:05,189 --> 00:12:07,589
wanted to be productive in the same way

00:12:06,720 --> 00:12:09,360
we are not yet

00:12:07,589 --> 00:12:13,040
tell me now we're engineers too bright

00:12:09,360 --> 00:12:14,939
you know like assembly you know like

00:12:13,040 --> 00:12:18,689
assembly free well that will be that

00:12:14,939 --> 00:12:20,220
about components but having this this

00:12:18,689 --> 00:12:23,100
services like serviceworker generation

00:12:20,220 --> 00:12:24,540
pre-rendering fast incremental builds

00:12:23,100 --> 00:12:27,749
like a deep integration with typescript

00:12:24,540 --> 00:12:29,759
and their types and you know dogs

00:12:27,749 --> 00:12:32,009
generation we take the static analysis

00:12:29,759 --> 00:12:33,480
of this component and we can even

00:12:32,009 --> 00:12:35,939
generate outer regenerate that read me

00:12:33,480 --> 00:12:38,519
that you know yes deployed your ducks in

00:12:35,939 --> 00:12:41,939
the in github having to make any change

00:12:38,519 --> 00:12:44,540
or we have valuation output where we can

00:12:41,939 --> 00:12:46,980
integrate with things like storybook or

00:12:44,540 --> 00:12:50,669
your houston web generator so for

00:12:46,980 --> 00:12:53,309
example for the ducts of ionic in the

00:12:50,669 --> 00:12:56,309
web site we use a JSON target that puts

00:12:53,309 --> 00:12:59,160
all the information and even like as a

00:12:56,309 --> 00:13:01,410
bonus we even part the CSS and we

00:12:59,160 --> 00:13:03,569
extract the CSS variables that you might

00:13:01,410 --> 00:13:06,929
use because this was a big deal for us

00:13:03,569 --> 00:13:09,269
and you know like we have peaceful DF

00:13:06,929 --> 00:13:11,339
testing we use puppeteer under the hood

00:13:09,269 --> 00:13:14,549
everything this is already done you

00:13:11,339 --> 00:13:16,740
don't have to implement these things and

00:13:14,549 --> 00:13:20,009
configure these things so we have built

00:13:16,740 --> 00:13:20,920
this in the example Michael eat Randy

00:13:20,009 --> 00:13:24,560
they

00:13:20,920 --> 00:13:26,510
some issues with that I am an input and

00:13:24,560 --> 00:13:29,420
here's the diff and we can review that

00:13:26,510 --> 00:13:31,279
previously and but the idea is that we

00:13:29,420 --> 00:13:34,790
can have web components and still have

00:13:31,279 --> 00:13:36,740
framework level features today I'm

00:13:34,790 --> 00:13:38,980
announcing a big milestone in

00:13:36,740 --> 00:13:42,589
development or development of a stencil

00:13:38,980 --> 00:13:45,170
stencil one and you might have II wonder

00:13:42,589 --> 00:13:49,010
we are using we are not using numbers

00:13:45,170 --> 00:13:50,900
just like 1.0 but because essential one

00:13:49,010 --> 00:13:53,660
is a sanction mental it's not an

00:13:50,900 --> 00:13:55,940
incremental release it's a consolidation

00:13:53,660 --> 00:13:58,430
consolidation of the API since L was

00:13:55,940 --> 00:14:01,190
initially built to solve the problems at

00:13:58,430 --> 00:14:03,350
ionic but it an app solving a lot more

00:14:01,190 --> 00:14:04,490
problems for a lot more people so during

00:14:03,350 --> 00:14:06,230
the last six months we have been

00:14:04,490 --> 00:14:08,900
collecting all this big pad for

00:14:06,230 --> 00:14:11,480
thousands of developers and use need to

00:14:08,900 --> 00:14:13,910
consolidate this API that we that we are

00:14:11,480 --> 00:14:19,450
proud of in addition we have a new

00:14:13,910 --> 00:14:21,740
random new compiler so one of the most

00:14:19,450 --> 00:14:24,770
interesting things about the stencil is

00:14:21,740 --> 00:14:26,540
that when you instance this about

00:14:24,770 --> 00:14:30,680
components right so you're not using it

00:14:26,540 --> 00:14:32,240
muscle time to create an app right so

00:14:30,680 --> 00:14:33,350
how will you handle the list logging

00:14:32,240 --> 00:14:36,290
because most of the time is about

00:14:33,350 --> 00:14:39,200
routing it's a routing based list loaded

00:14:36,290 --> 00:14:40,700
but here we can have that so instead we

00:14:39,200 --> 00:14:43,310
took a different approach is a component

00:14:40,700 --> 00:14:45,350
based lazy loading because we want to

00:14:43,310 --> 00:14:46,640
use a stencil to build this components

00:14:45,350 --> 00:14:49,310
but they will be used in different

00:14:46,640 --> 00:14:50,410
places they will may be used in react we

00:14:49,310 --> 00:14:53,870
have Bionic react

00:14:50,410 --> 00:14:56,900
Yanik angular they have different ways

00:14:53,870 --> 00:14:58,850
of lace noise so in order to do that in

00:14:56,900 --> 00:15:01,670
stencil is able to perform the static

00:14:58,850 --> 00:15:03,860
analysis of how the components depend on

00:15:01,670 --> 00:15:05,630
each other and apply the best

00:15:03,860 --> 00:15:10,430
optimizations and the real person things

00:15:05,630 --> 00:15:12,440
have to deal with it so in sensor one we

00:15:10,430 --> 00:15:14,240
have a new algorithm in spiral a

00:15:12,440 --> 00:15:15,470
matching learning technique called war

00:15:14,240 --> 00:15:17,839
embeddings and I'm going to explain

00:15:15,470 --> 00:15:21,950
because kind of weird but the thing is

00:15:17,839 --> 00:15:24,500
that our use case all the components are

00:15:21,950 --> 00:15:28,190
entry points because we don't know how

00:15:24,500 --> 00:15:30,890
they are going to be used so like

00:15:28,190 --> 00:15:33,860
traditional tacking algorithms like the

00:15:30,890 --> 00:15:35,360
one using webpack or or OLAP give

00:15:33,860 --> 00:15:36,920
generate a different bundle for this

00:15:35,360 --> 00:15:39,410
application for each component if you

00:15:36,920 --> 00:15:41,060
want to lazy low them so if you have 20

00:15:39,410 --> 00:15:42,860
different components at the same time

00:15:41,060 --> 00:15:46,730
you will have to download 20 different

00:15:42,860 --> 00:15:50,269
files so we come up with a new guram to

00:15:46,730 --> 00:15:52,220
to make this feature so in this image we

00:15:50,269 --> 00:15:54,589
have nine components and we use numbers

00:15:52,220 --> 00:15:56,269
to name them but you could imagine Deng

00:15:54,589 --> 00:15:59,120
has paid login base tutorial I button

00:15:56,269 --> 00:16:01,100
wherever so thanks to the static

00:15:59,120 --> 00:16:03,050
analysis I said before like of how

00:16:01,100 --> 00:16:04,700
components depend of each other like how

00:16:03,050 --> 00:16:07,190
they are using the templates we can

00:16:04,700 --> 00:16:09,170
extract information of the dependencies

00:16:07,190 --> 00:16:12,589
which are components and that's what

00:16:09,170 --> 00:16:14,870
these lines represent alright so the

00:16:12,589 --> 00:16:17,990
next step is to resolve the transitive

00:16:14,870 --> 00:16:21,170
dependencies so for example if we know

00:16:17,990 --> 00:16:23,450
that the component 1 depends on 3 and if

00:16:21,170 --> 00:16:26,390
3 depends on 6 that means that by the

00:16:23,450 --> 00:16:29,649
transitive property that 1 also depends

00:16:26,390 --> 00:16:33,820
on 6 oh damn it

00:16:29,649 --> 00:16:38,570
ok make sense everyone yes

00:16:33,820 --> 00:16:42,170
ok so we keep we basically do the same

00:16:38,570 --> 00:16:44,060
with all the components ok so let's

00:16:42,170 --> 00:16:46,760
focus and then a component number 9 it

00:16:44,060 --> 00:16:48,640
has a lot of arrows pointing to it that

00:16:46,760 --> 00:16:51,769
means that it has a lot of dependence

00:16:48,640 --> 00:16:55,399
but some component like 5 doesn't have

00:16:51,769 --> 00:16:57,800
any okay let's focus again in the

00:16:55,399 --> 00:17:01,220
component 9 as I said each arrow

00:16:57,800 --> 00:17:03,529
represents dependent so in this case we

00:17:01,220 --> 00:17:05,620
collect the dependence of nine so in

00:17:03,529 --> 00:17:09,079
yeah it's three one six four and two

00:17:05,620 --> 00:17:12,709
right where these lines are coming from

00:17:09,079 --> 00:17:15,919
and we do the same with all of them

00:17:12,709 --> 00:17:20,689
understood yeah yes

00:17:15,919 --> 00:17:22,579
ok so let's focus again in the component

00:17:20,689 --> 00:17:26,449
number nine there were just four

00:17:22,579 --> 00:17:31,309
examples so we have let's get the

00:17:26,449 --> 00:17:33,559
dependencies so we go we get already all

00:17:31,309 --> 00:17:35,960
the data but we just have to encode it

00:17:33,559 --> 00:17:38,630
in different data structure so what if

00:17:35,960 --> 00:17:40,730
we could what if we can convert these

00:17:38,630 --> 00:17:42,890
dependencies of each component into a

00:17:40,730 --> 00:17:47,130
vector just like word embeddings will do

00:17:42,890 --> 00:17:49,410
with words so we have

00:17:47,130 --> 00:17:52,200
so for example the component number

00:17:49,410 --> 00:17:54,390
let's let's encode one let's put a 1

00:17:52,200 --> 00:17:58,380
when it's a dependent and nasarah when

00:17:54,390 --> 00:18:02,429
it's not so 1 it's a component it's a

00:17:58,380 --> 00:18:07,289
dependent or not it is right yeah ok so

00:18:02,429 --> 00:18:10,679
one two three four years or well but

00:18:07,289 --> 00:18:14,580
five five is not we don't have any arrow

00:18:10,679 --> 00:18:20,669
pointing to 6 so we linked all with 0 6

00:18:14,580 --> 00:18:22,350
it is and 7 8 9 is not okay well we do

00:18:20,669 --> 00:18:27,059
the same with all the components and we

00:18:22,350 --> 00:18:29,070
get an array of vectors so what we had

00:18:27,059 --> 00:18:30,539
friends file and transfer our components

00:18:29,070 --> 00:18:33,059
director of coordinates we could imagine

00:18:30,539 --> 00:18:35,059
their hands points in a space in here is

00:18:33,059 --> 00:18:38,429
a 3d space but you could imagine then as

00:18:35,059 --> 00:18:40,320
you know with more dimensions the core

00:18:38,429 --> 00:18:43,320
idea is to group together the components

00:18:40,320 --> 00:18:44,340
that are close enough in this space but

00:18:43,320 --> 00:18:45,750
in order to know if they are close

00:18:44,340 --> 00:18:48,000
enough or not we just have to calculate

00:18:45,750 --> 00:18:50,309
the distance and how do we calculate the

00:18:48,000 --> 00:18:52,110
distance well here's my friend guitarist

00:18:50,309 --> 00:18:54,299
philosopher mathematician the answering

00:18:52,110 --> 00:18:57,000
trick used to following hims really

00:18:54,299 --> 00:18:59,250
smart guy came up with this famous

00:18:57,000 --> 00:19:02,940
algorithm that you probably remember

00:18:59,250 --> 00:19:04,650
from school that relates the legs of a

00:19:02,940 --> 00:19:07,559
triangle with hypotenuse I have

00:19:04,650 --> 00:19:09,690
practiced this war a lot so in this in

00:19:07,559 --> 00:19:11,730
this example the hypothenuse is exactly

00:19:09,690 --> 00:19:15,630
a distance between the two blue circles

00:19:11,730 --> 00:19:17,460
okay well I'm not here to scare you

00:19:15,630 --> 00:19:19,770
promise but in our case I leave it more

00:19:17,460 --> 00:19:22,230
complicated well there's more than two

00:19:19,770 --> 00:19:25,140
dimensions by the ideas the same turns

00:19:22,230 --> 00:19:26,549
out we can use the generalization of the

00:19:25,140 --> 00:19:28,650
Pythagorean theorem to solve this

00:19:26,549 --> 00:19:32,370
problem and that's exactly where this

00:19:28,650 --> 00:19:35,400
 is sorry so we calculate the

00:19:32,370 --> 00:19:37,980
distance between all the points even if

00:19:35,400 --> 00:19:41,429
it runs 100 dimensions so going back

00:19:37,980 --> 00:19:43,049
here we just bundle everything and this

00:19:41,429 --> 00:19:44,850
we had test this approach in both

00:19:43,049 --> 00:19:46,230
internal and external apps and we have

00:19:44,850 --> 00:19:48,450
found that it's much better than

00:19:46,230 --> 00:19:49,740
anything we have try in the past in in

00:19:48,450 --> 00:19:51,690
big app generates

00:19:49,740 --> 00:19:54,539
bundles better that if a developer will

00:19:51,690 --> 00:19:55,770
have to try to bundle this 100

00:19:54,539 --> 00:19:57,990
components in most efficient way because

00:19:55,770 --> 00:19:59,990
most of the things such the conditions

00:19:57,990 --> 00:20:03,870
are changing

00:19:59,990 --> 00:20:05,880
so this time in addition you know like

00:20:03,870 --> 00:20:08,880
now emerging that preferably optimized

00:20:05,880 --> 00:20:12,929
bundles and we can even generate hints

00:20:08,880 --> 00:20:16,340
so browser can download and parts all

00:20:12,929 --> 00:20:18,600
the assets that your application need

00:20:16,340 --> 00:20:21,419
yeah in the critical path so in this

00:20:18,600 --> 00:20:22,710
example we have the module preload for

00:20:21,419 --> 00:20:26,279
all the JavaScript because we use

00:20:22,710 --> 00:20:29,149
modules natively so all the JavaScript

00:20:26,279 --> 00:20:31,860
require in a critical path is download

00:20:29,149 --> 00:20:36,539
read like yeah in parallel I was saying

00:20:31,860 --> 00:20:38,909
yeah so nothing is a faster random we

00:20:36,539 --> 00:20:41,009
have profile and refactor to random to

00:20:38,909 --> 00:20:44,399
be much smaller and faster institution

00:20:41,009 --> 00:20:46,470
time so the new ran time about pattern

00:20:44,399 --> 00:20:50,220
like optimization killers and pro the

00:20:46,470 --> 00:20:52,740
async away racing schedule we use new

00:20:50,220 --> 00:20:56,970
API like constructible stylesheet we use

00:20:52,740 --> 00:20:59,039
native insuk SE modules async await so

00:20:56,970 --> 00:21:01,710
in this benchmark we have eight hundred

00:20:59,039 --> 00:21:03,870
eight thousand item buttons component

00:21:01,710 --> 00:21:06,240
and you might look like it's a simple

00:21:03,870 --> 00:21:07,559
component but in the hood it has a lot

00:21:06,240 --> 00:21:09,539
of classes a lot of nested components

00:21:07,559 --> 00:21:11,490
that will try to replicate them at

00:21:09,539 --> 00:21:13,220
release on an iOS designs

00:21:11,490 --> 00:21:16,190
so in this stress test we actually

00:21:13,220 --> 00:21:18,629
having two hundred thousand nodes at all

00:21:16,190 --> 00:21:21,230
historically it took six seconds to

00:21:18,629 --> 00:21:23,940
fully initialize that withstands e1 it's

00:21:21,230 --> 00:21:27,430
three seconds and it uses pretty much

00:21:23,940 --> 00:21:32,700
half a memory which is yeah

00:21:27,430 --> 00:21:36,030
[Applause]

00:21:32,700 --> 00:21:39,210
so 2 times faster and yeah hologram

00:21:36,030 --> 00:21:40,890
okay let's continue another advantage of

00:21:39,210 --> 00:21:43,650
fusion a compiler is that we are not

00:21:40,890 --> 00:21:45,540
longer limited by our by the you know by

00:21:43,650 --> 00:21:48,510
3 second to remove part of self code

00:21:45,540 --> 00:21:50,370
that are not required so instead we can

00:21:48,510 --> 00:21:52,920
compile all this metadata that we have

00:21:50,370 --> 00:21:56,880
with 3 second in order to heavy

00:21:52,920 --> 00:21:59,490
optimized components so a hello world

00:21:56,880 --> 00:22:03,360
app compiled with a stencil it's so a

00:21:59,490 --> 00:22:06,930
small you can barely see it it's yes 133

00:22:03,360 --> 00:22:08,460
bytes and compress well why it's so

00:22:06,930 --> 00:22:10,350
small because it doesn't have any I mean

00:22:08,460 --> 00:22:14,460
what it's a hello world right it doesn't

00:22:10,350 --> 00:22:18,450
need any random so the the compress is

00:22:14,460 --> 00:22:20,690
even smaller but here the important idea

00:22:18,450 --> 00:22:24,120
is that while a hello world example

00:22:20,690 --> 00:22:25,830
isn't really an artificial example we

00:22:24,120 --> 00:22:27,750
are really proud about the power of a

00:22:25,830 --> 00:22:30,150
compiler can do applying heavy

00:22:27,750 --> 00:22:32,160
optimizations and completely remove what

00:22:30,150 --> 00:22:34,020
is not needed in a specific route

00:22:32,160 --> 00:22:38,700
brushes if it's needing some brush it

00:22:34,020 --> 00:22:40,760
will also include that so these

00:22:38,700 --> 00:22:44,070
optimizations can also apply to bigger

00:22:40,760 --> 00:22:47,280
use cases like a complex application

00:22:44,070 --> 00:22:51,660
built with ionic or the like almost like

00:22:47,280 --> 00:22:56,430
a stander to do MVC so in our case it's

00:22:51,660 --> 00:22:59,970
just two point four kilobytes and to put

00:22:56,430 --> 00:23:01,560
a little bit more context well in the

00:22:59,970 --> 00:23:03,750
same application with with different

00:23:01,560 --> 00:23:07,110
technology we feel really proud about

00:23:03,750 --> 00:23:10,500
what we have achieved and all of this

00:23:07,110 --> 00:23:11,910
without messing with your no modules you

00:23:10,500 --> 00:23:13,560
probably have seen this image before I

00:23:11,910 --> 00:23:16,380
think yeah and the first talk we also

00:23:13,560 --> 00:23:19,440
see it but you know it's a good example

00:23:16,380 --> 00:23:21,210
it's usually no modules is heavier than

00:23:19,440 --> 00:23:23,370
a supermassive level when you're

00:23:21,210 --> 00:23:26,040
installing it we might take a couple of

00:23:23,370 --> 00:23:28,260
minutes okay so this is but in general

00:23:26,040 --> 00:23:30,420
it's a big trial today not only because

00:23:28,260 --> 00:23:32,130
there is a dependency help in every

00:23:30,420 --> 00:23:34,680
campaign every project you don't know

00:23:32,130 --> 00:23:37,350
which code is running actually there

00:23:34,680 --> 00:23:40,980
isn't healthy dependency in practice in

00:23:37,350 --> 00:23:43,860
package package manager like I'm I have

00:23:40,980 --> 00:23:46,380
nightmares with like npm apocalypse or

00:23:43,860 --> 00:23:48,630
something like you can download anymore

00:23:46,380 --> 00:23:50,370
so yeah there is many things moving on

00:23:48,630 --> 00:23:53,730
like moving parts in our web projects

00:23:50,370 --> 00:23:55,890
and developers already find creative

00:23:53,730 --> 00:23:59,760
ways to get around and get some space in

00:23:55,890 --> 00:24:01,680
their computer so sorry

00:23:59,760 --> 00:24:04,320
so one of the design principles have a

00:24:01,680 --> 00:24:07,110
stencil is to keep dependencies to the

00:24:04,320 --> 00:24:09,750
minimum so it doesn't not only make the

00:24:07,110 --> 00:24:12,750
Italians installing Sprint's much faster

00:24:09,750 --> 00:24:16,440
but your project more future-proof and

00:24:12,750 --> 00:24:18,960
stable it's not if it's not the first

00:24:16,440 --> 00:24:21,720
time at least for us that a dependency

00:24:18,960 --> 00:24:23,880
of that dependency change and finding a

00:24:21,720 --> 00:24:28,470
solution becomes a problem for example I

00:24:23,880 --> 00:24:30,330
think for notes as you update to note 12

00:24:28,470 --> 00:24:31,770
and indeed stopped working so yeah it's

00:24:30,330 --> 00:24:34,260
this kind of thing like don't see

00:24:31,770 --> 00:24:36,300
dependencies so for instance if you open

00:24:34,260 --> 00:24:39,150
node modules in a stems your starter you

00:24:36,300 --> 00:24:42,690
will define two folders a stencil and

00:24:39,150 --> 00:24:45,360
I've escaped here at the line' we have

00:24:42,690 --> 00:24:49,260
the largest stencil drawing the world

00:24:45,360 --> 00:24:52,230
the cosmonaut stencil is a tool you use

00:24:49,260 --> 00:24:54,440
to paint something but it's not longer

00:24:52,230 --> 00:24:57,300
there right you can use the same stencil

00:24:54,440 --> 00:24:59,460
many times but it's never part of the

00:24:57,300 --> 00:25:01,800
final product and that's why a stencil

00:24:59,460 --> 00:25:07,650
has the name it has it's like treat me

00:25:01,800 --> 00:25:10,230
my max my CEO said it's like written in

00:25:07,650 --> 00:25:14,040
stencil four components and we said

00:25:10,230 --> 00:25:16,740
that's it when you build a component

00:25:14,040 --> 00:25:18,990
with their stencil I mean sorry when you

00:25:16,740 --> 00:25:21,600
build a component with a delivery lead

00:25:18,990 --> 00:25:24,270
element react angular view your

00:25:21,600 --> 00:25:26,130
components you upload to MPN have a

00:25:24,270 --> 00:25:28,470
strong dependency in this in this

00:25:26,130 --> 00:25:31,320
framework and in this particular person

00:25:28,470 --> 00:25:33,930
of the framework right but the

00:25:31,320 --> 00:25:36,180
components you generate with the stencil

00:25:33,930 --> 00:25:39,110
they are not essential components they

00:25:36,180 --> 00:25:42,810
don't have a dependency on in stencil so

00:25:39,110 --> 00:25:46,500
they so they don't even depend on it now

00:25:42,810 --> 00:25:49,050
I if I have time I really with everyone

00:25:46,500 --> 00:25:56,130
yeah so I have a quick demo of how easy

00:25:49,050 --> 00:26:05,910
it is let's see if I can

00:25:56,130 --> 00:26:08,210
see very quickly I know no meat love it

00:26:05,910 --> 00:26:08,210
okay

00:26:09,880 --> 00:26:22,419
all right okay so uh yeah so we have the

00:26:16,960 --> 00:26:25,780
terminal we just run MP in it stencil we

00:26:22,419 --> 00:26:27,400
run it we select we're going to create a

00:26:25,780 --> 00:26:29,110
simple app but most of the times is

00:26:27,400 --> 00:26:32,679
component a nap

00:26:29,110 --> 00:26:35,110
yes humph done

00:26:32,679 --> 00:26:36,700
yes it's already downloaded you don't

00:26:35,110 --> 00:26:38,830
have to it's already downloaded the

00:26:36,700 --> 00:26:41,919
started and we run npm install for you

00:26:38,830 --> 00:26:43,780
so when you'd select the start there we

00:26:41,919 --> 00:26:45,429
also you start so while you was typing

00:26:43,780 --> 00:26:50,650
the name we already start downloading

00:26:45,429 --> 00:27:00,880
everything so now we just go here MPM

00:26:50,650 --> 00:27:02,650
start I'm using it actually so uh so for

00:27:00,880 --> 00:27:05,919
example I hear we have a very simple

00:27:02,650 --> 00:27:08,799
application we can we have this these

00:27:05,919 --> 00:27:11,080
features I talked before about I like

00:27:08,799 --> 00:27:12,909
thing more level features so if I open

00:27:11,080 --> 00:27:14,799
the code and I try to make any change

00:27:12,909 --> 00:27:19,659
even though these are web components I

00:27:14,799 --> 00:27:23,830
can have like code mode module

00:27:19,659 --> 00:27:25,570
replacement so for example here I'm just

00:27:23,830 --> 00:27:28,650
going to make a GUI just going to make

00:27:25,570 --> 00:27:36,309
the change button from profile page to

00:27:28,650 --> 00:27:38,409
hallow page safe and you know you may

00:27:36,309 --> 00:27:42,159
want to run the the docs

00:27:38,409 --> 00:27:45,610
well you yes we'll go here and in the

00:27:42,159 --> 00:27:50,980
configuration and you will create an

00:27:45,610 --> 00:27:53,559
output target like type ducks I say we

00:27:50,980 --> 00:27:55,570
have dogs Jason job read mean so if you

00:27:53,559 --> 00:27:58,630
have that and you run the bill it will

00:27:55,570 --> 00:28:00,520
generate as a readme file in every like

00:27:58,630 --> 00:28:02,530
in here in this folder in this folder in

00:28:00,520 --> 00:28:04,780
this folder with study and analysis of

00:28:02,530 --> 00:28:08,140
these components let's say you want to

00:28:04,780 --> 00:28:09,309
pre render the page well this is this is

00:28:08,140 --> 00:28:11,350
something that you will not spec with

00:28:09,309 --> 00:28:14,500
five components but here you will just

00:28:11,350 --> 00:28:16,570
let me see if I this is running

00:28:14,500 --> 00:28:19,299
no it's stopped all right here okay

00:28:16,570 --> 00:28:25,090
let's stop it so it will say NPN van

00:28:19,299 --> 00:28:26,530
built pre-render in this case it will

00:28:25,090 --> 00:28:29,200
run out drop bill and it will yes

00:28:26,530 --> 00:28:31,690
actually create different readme file

00:28:29,200 --> 00:28:33,970
and it retains two pages well we have

00:28:31,690 --> 00:28:38,799
remember that profile page another one

00:28:33,970 --> 00:28:42,520
and yeah I I think that's pretty much it

00:28:38,799 --> 00:28:46,210
okay yeah so you I really encourage you

00:28:42,520 --> 00:28:48,010
to check it out the stencil yes calm or

00:28:46,210 --> 00:28:52,450
just npm in it the stencil I'll give you

00:28:48,010 --> 00:28:57,000
a try yeah it's like magic

00:28:52,450 --> 00:28:57,000
so thank you

00:28:58,520 --> 00:29:04,049

YouTube URL: https://www.youtube.com/watch?v=M1F81V-NhP0


