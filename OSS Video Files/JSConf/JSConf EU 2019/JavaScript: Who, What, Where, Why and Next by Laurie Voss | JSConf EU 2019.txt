Title: JavaScript: Who, What, Where, Why and Next by Laurie Voss | JSConf EU 2019
Publication date: 2019-06-10
Playlist: JSConf EU 2019
Description: 
	npm has more data than anyone about who JavaScript developers are and what we’re up to. Using registry stats and the results of our 2019 ecosystem survey of over 30,000 developers, I break down the current state of JavaScript and where trends look like they’re headed, so you can make more informed technical choices.

https://2019.jsconf.eu/laurie-voss/javascript-who-what-where-why-and-next.html
Captions: 
	00:00:12,139 --> 00:00:16,470
>> Hello, JSConf holy Cow!

00:00:16,470 --> 00:00:19,359
There are so many of you.

00:00:19,359 --> 00:00:24,789
This is the biggest conference I've ever been to, and it is also, I'm embarrassed to say,

00:00:24,789 --> 00:00:27,480
this is my first JSConf EU.

00:00:27,480 --> 00:00:33,390
I kept trying to come but I had immigration issues and all sorts of stuff, and I made

00:00:33,390 --> 00:00:35,780
it just in lime for the last one.

00:00:35,780 --> 00:00:42,500
I'm extra specially thrilled to be here and be invited to speak, but before we get started,

00:00:42,500 --> 00:00:48,160
the way that I don't die of nervousness is I always take a speaker selfie, but there

00:00:48,160 --> 00:00:53,309
are millions of you, so I'm going to take a bunch.

00:00:53,309 --> 00:00:54,950
Look happy!

00:00:54,950 --> 00:00:58,289
Like you just heard the best talk of your life!

00:00:58,289 --> 00:00:59,620
Amazing.

00:00:59,620 --> 00:01:02,280
All right.

00:01:02,280 --> 00:01:07,090
With that important business out of the way, hello, everybody, I'm Laurie.

00:01:07,090 --> 00:01:13,310
I'm one of the co-founders of npm Inc, one of the chief data officers there, but what

00:01:13,310 --> 00:01:19,820
I really am is a web developer, making the web bigger, and better, and more accessible

00:01:19,820 --> 00:01:26,680
to everyone is what drives me, and it's been driving me for 23 years now, which means sometimes

00:01:26,680 --> 00:01:31,500
I meet people who are younger than my web development career!

00:01:31,500 --> 00:01:32,710
Which is weird.

00:01:32,710 --> 00:01:37,030
And, today, I'm here to talk about JavaScript.

00:01:37,030 --> 00:01:40,930
I'm going to talk about who we are, the people who write JavaScript.

00:01:40,930 --> 00:01:46,940
I'm talking about where we use JavaScript, and what we are doing with it today, and also

00:01:46,940 --> 00:01:51,369
I'm going to talk about why, the forces that are driving us to the state that we are in

00:01:51,369 --> 00:01:52,509
right now.

00:01:52,509 --> 00:01:55,950
Finally, I'm going to talk about what comes next.

00:01:55,950 --> 00:02:00,350
Looking at current trends, and guessing where they're going.

00:02:00,350 --> 00:02:06,610
The goal of this talk is to give you a sense of perspective about the state of JavaScript

00:02:06,610 --> 00:02:09,940
as a whole and where you sit in it.

00:02:09,940 --> 00:02:17,480
So many developers work in a vacuum, not knowing whether it is best practice, a fad, or this

00:02:17,480 --> 00:02:21,730
hopelessly out-of-date thing that nobody does any more.

00:02:21,730 --> 00:02:27,010
I hope you leave this talk knowing the one thing you're using is a really good thing

00:02:27,010 --> 00:02:33,220
with feeling that you should move away from one thing that you're using, and also excited

00:02:33,220 --> 00:02:37,160
about learning one new thing that you hadn't heard about or you hadn't decided to get into

00:02:37,160 --> 00:02:39,510
before.

00:02:39,510 --> 00:02:42,390
But before I say all of that stuff, it's worth asking how I know?

00:02:42,390 --> 00:02:44,530
Where did I get all of this information?

00:02:44,530 --> 00:02:48,150
We have three main sources for the stuff I'm about to present.

00:02:48,150 --> 00:02:51,970
The first is the npm registry statistics.

00:02:51,970 --> 00:02:56,600
The npm registry contains amazing data about what JavaScript developers are up to and what

00:02:56,600 --> 00:03:00,120
they're using, and we also did a survey.

00:03:00,120 --> 00:03:06,090
Our first annual survey got 1,600 responses, and our second got 33,000 responses.

00:03:06,090 --> 00:03:09,879
We have an enormous amount of information of people telling us what you're up to and

00:03:09,879 --> 00:03:11,340
why you're doing it.

00:03:11,340 --> 00:03:16,110
I also supplemented and double-checked our numbers using the excellent State of JavaScript

00:03:16,110 --> 00:03:17,970
Survey run by the community.

00:03:17,970 --> 00:03:27,600
I also have one final surprise source which is ten years of JSConf EU talk proposals!

00:03:27,600 --> 00:03:28,600
Ten years!

00:03:28,600 --> 00:03:29,600
My goodness.

00:03:29,600 --> 00:03:30,600
That is so much work.

00:03:30,600 --> 00:03:35,550
Can we have another round of applause for ten years?

00:03:35,550 --> 00:03:38,780
[Applause].

00:03:38,780 --> 00:03:44,989
As part of the celebration of the tenth year of JSConf EU, the organisers asked me to analyse

00:03:44,989 --> 00:03:45,989
the data.

00:03:45,989 --> 00:03:49,950
They gave me all of the titles and descriptions of all of the talks that have ever been submitted

00:03:49,950 --> 00:03:54,550
to JSConf EU and they asked could I find something interesting in this?

00:03:54,550 --> 00:03:57,400
Boy, I found interesting things in this.

00:03:57,400 --> 00:04:01,820
First off, there are so many talks this year.

00:04:01,820 --> 00:04:11,599
The first JSConf EU had 44 talks submitted, and this year, there were 932.

00:04:11,599 --> 00:04:22,030
In 2012, someone had the bright idea that someone submit their talks at JSON which was

00:04:22,030 --> 00:04:28,060
a goddamned nightmare to parse back into text and sentences, so thank you whose ever bright

00:04:28,060 --> 00:04:31,210
idea that was.

00:04:31,210 --> 00:04:42,600
The single most common phrase in the last ten years has been "in this talk we will ...", and

00:04:42,600 --> 00:04:50,719
the second most common phrase was "learn how to", and sometimes, it was both.

00:04:50,719 --> 00:04:56,760
But there's something much more interesting which is the JSConf hype meter.

00:04:56,760 --> 00:05:05,520
I wanted to track how popular various technologies were, and technologies get mentioned more

00:05:05,520 --> 00:05:06,720
and more often.

00:05:06,720 --> 00:05:08,890
Everything is going up and to the right.

00:05:08,890 --> 00:05:15,020
Instead, I measured how many talks contain a word as a percentage of all of the talks

00:05:15,020 --> 00:05:16,330
submitted.

00:05:16,330 --> 00:05:19,409
This is an example one before it's of Node and npm.

00:05:19,409 --> 00:05:24,580
We're talking about Node last time much less than we used to but talking about npm about

00:05:24,580 --> 00:05:27,820
as much as the same as we ever did.

00:05:27,820 --> 00:05:33,820
All through this talk, I will weave in the JSConf data and if what we are talking about

00:05:33,820 --> 00:05:36,790
lines up with the reality of what we're doing.

00:05:36,790 --> 00:05:43,130
But, l Laurie, you had a huge corpus of text.

00:05:43,130 --> 00:05:45,849
You could have built a markup generate colour.

00:05:45,849 --> 00:05:49,510
You bet your ass I built up a markup generator.

00:05:49,510 --> 00:05:58,520
Here is a machine-generate the titles based on past submissions to use for your future

00:05:58,520 --> 00:06:00,740
consequences.

00:06:00,740 --> 00:06:04,350
Train your next-level sequential arts.

00:06:04,350 --> 00:06:10,680
This is definitely going to be done by Jenn Schiffer.

00:06:10,680 --> 00:06:12,550
Talk about tools for capitalism!

00:06:12,550 --> 00:06:18,310
I think it's possible that CJ has already written this talk!

00:06:18,310 --> 00:06:21,360
Distributed computing in the world of CSS and JS.

00:06:21,360 --> 00:06:24,430
It is possible they did this yesterday!

00:06:24,430 --> 00:06:26,250
I wasn't here yet!

00:06:26,250 --> 00:06:30,200
AMP for why you're being an Eyebrow.

00:06:30,200 --> 00:06:34,330
Martin is going to handle this one.

00:06:34,330 --> 00:06:36,660
Serverless.

00:06:36,660 --> 00:06:40,909
I don't know what this means but I bet somebody could talk for 25 minutes and persuade me

00:06:40,909 --> 00:06:43,840
it's true!

00:06:43,840 --> 00:06:47,050
Go Node and JavaScript Crypto.

00:06:47,050 --> 00:06:52,649
I don't know what it is but it's probably a bad idea, and I'm looking forward to seeing

00:06:52,649 --> 00:06:56,080
these conference talks in future.

00:06:56,080 --> 00:07:00,410
Before we dive in, a couple of disclaimers, some of what I'm presenting here are facts,

00:07:00,410 --> 00:07:05,040
and some of what I'm presenting are opinions, and I'm trying to be as clear as possible.

00:07:05,040 --> 00:07:12,599
Sometimes, you're going to see a graph that says that your favourite technology is getting

00:07:12,599 --> 00:07:18,250
less popular, and what I'm asking is that you don't get mad about that.

00:07:18,250 --> 00:07:19,390
Don't get mad about facts.

00:07:19,390 --> 00:07:24,969
I have so many terrible opinions that you can get mad about, but try not to get mad

00:07:24,969 --> 00:07:26,660
about the facts.

00:07:26,660 --> 00:07:28,770
I do not have a horse in this race.

00:07:28,770 --> 00:07:33,650
Apart from npm, I'm not a contributor to any of the technologies I'm discussing, I'm just

00:07:33,650 --> 00:07:36,080
presenting the facts.

00:07:36,080 --> 00:07:41,060
Secondly, a lot of what I'm talking about involves relative popularity of technologies,

00:07:41,060 --> 00:07:45,589
and I want to make clear that, just because a technology is popular doesn't mean that

00:07:45,589 --> 00:07:46,589
it is good.

00:07:46,589 --> 00:07:47,770
It doesn't mean that it's the best technology.

00:07:47,770 --> 00:07:50,950
I don't know what the best technology means.

00:07:50,950 --> 00:07:56,130
But for technology, popularity is useful in and of itself.

00:07:56,130 --> 00:07:59,930
If there are a lot of people using your technology, then there will be a lot of people find and

00:07:59,930 --> 00:08:04,020
fix bugs, there will be a lot of tutorials, there will be a lot of Stack Overflow questions

00:08:04,020 --> 00:08:05,880
answered for you.

00:08:05,880 --> 00:08:10,650
If you work with something popular, it often makes your work easier regardless of how good

00:08:10,650 --> 00:08:12,540
it really is.

00:08:12,540 --> 00:08:20,050
Finally, I really love what I talk about, and I'm going to get excited towards the end

00:08:20,050 --> 00:08:27,780
and swear like an absolute fucking sailor, so I have no intention of toning that down

00:08:27,780 --> 00:08:33,279
in any way, so apologies in advance.

00:08:33,279 --> 00:08:35,779
Who are we, JavaScript developers?

00:08:35,779 --> 00:08:40,709
The answer is at this point, we're pretty much like everyone else.

00:08:40,709 --> 00:08:45,210
If you look at our demographics, the same age distribution, same instrument profile,

00:08:45,210 --> 00:08:49,130
we live in all the same countries as all of the other software developers and the reason

00:08:49,130 --> 00:08:53,320
for that is because we nearly are all software developers.

00:08:53,320 --> 00:08:58,330
We are 11 million developers now writing JavaScript every day.

00:08:58,330 --> 00:09:04,030
And those 11 million developers are using more open-source software than any other language

00:09:04,030 --> 00:09:05,030
community.

00:09:05,030 --> 00:09:11,270
The npm registry is now the largest repository of open source of any kind, by any measure,

00:09:11,270 --> 00:09:16,050
by number of modules, by lines of code, number of users - what are you want to pick.

00:09:16,050 --> 00:09:18,720
It's more than twice as big as the next registry.

00:09:18,720 --> 00:09:23,130
You could fold all the other registries into our registry if you wanted.

00:09:23,130 --> 00:09:29,050
Does having a big registry of open source software translate to activity?

00:09:29,050 --> 00:09:35,870
On GitHub, JavaScript is the biggest repository by numbers of line of code, and it has been

00:09:35,870 --> 00:09:38,160
in seven years in a row.

00:09:38,160 --> 00:09:43,390
In stack overflow's huge developer survey of 80,000 people, JavaScript was the most

00:09:43,390 --> 00:09:48,860
popular language with 68 per cent of all developers saying they write JavaScript at least some

00:09:48,860 --> 00:09:50,210
of the time.

00:09:50,210 --> 00:09:54,280
Of course, you're all at a JavaScript conference, so that you knew that JavaScript was popular

00:09:54,280 --> 00:10:00,750
already, but here is the truth: JavaScript is the most popular programming language in

00:10:00,750 --> 00:10:07,170
the world right now, and there are more developers than ever before, so JavaScript is really

00:10:07,170 --> 00:10:10,500
the most popular programming language there has ever been.

00:10:10,500 --> 00:10:16,810
And as JavaScript continues to grow, the JavaScript community is changing.

00:10:16,810 --> 00:10:22,550
One thing we noticed that has changed between our survey in 2018 and the last one we did,

00:10:22,550 --> 00:10:26,020
is that JavaScript developers are getting more experienced.

00:10:26,020 --> 00:10:29,240
They've been writing JavaScript for longer.

00:10:29,240 --> 00:10:31,920
We especially noticed this with npm itself.

00:10:31,920 --> 00:10:36,950
A year ago, half of our npm users were new, which is to say they had been using npm for

00:10:36,950 --> 00:10:41,800
less than two years, and this year, only about 36 per cent of people are.

00:10:41,800 --> 00:10:49,190
Around about 2014, and 2015, there was a massive spike in the number of npm users - around

00:10:49,190 --> 00:10:55,650
about that time, it's when JavaScript - existing JavaScript developers tuned into npm and the

00:10:55,650 --> 00:11:00,690
existing pool of JavaScript developers all sort of adopted npm en masse.

00:11:00,690 --> 00:11:07,120
But, today, the number of new npm users and the number of new JavaScript users, they look

00:11:07,120 --> 00:11:12,870
about the same, because, basically, anybody who learns JavaScript in 2019 is learning

00:11:12,870 --> 00:11:15,070
npm at the same time.

00:11:15,070 --> 00:11:22,830
So now believe that about 99 per cent of JavaScript developers are using npm, and that's part

00:11:22,830 --> 00:11:29,550
of why npm has so much information about what JavaScript developers are up to at the.

00:11:29,550 --> 00:11:33,860
This ever-growing pool of increasingly experienced JavaScript developers means that we've also

00:11:33,860 --> 00:11:34,860
seen a shift?

00:11:34,860 --> 00:11:37,730
In what JavaScript developers care about.

00:11:37,730 --> 00:11:42,850
We knew from analysing last year's data that more experienced developers care more about

00:11:42,850 --> 00:11:43,900
best practices.

00:11:43,900 --> 00:11:48,900
They do more testing, they use more linters and bundlers, they care more about security,

00:11:48,900 --> 00:11:53,490
and so now the whole community is getting more experienced, and so everybody is caring

00:11:53,490 --> 00:11:56,480
more about those sorts of things.

00:11:56,480 --> 00:12:01,790
Since last year's survey, the number of people who said they were concerned about the security

00:12:01,790 --> 00:12:05,960
of the open-source modules that they use, has increased.

00:12:05,960 --> 00:12:12,100
In the last two years, npm has added two-parking auth to protect publishers from account theft

00:12:12,100 --> 00:12:19,750
as well as security teams to detect and flag malicious packages.

00:12:19,750 --> 00:12:22,790
Malicious packages aren't the good threat model.

00:12:22,790 --> 00:12:26,420
Accidental vulnerabilities are much, much more common.

00:12:26,420 --> 00:12:32,450
So, last year, we introduced the npm audit command which will find and fix security vulnerabilities

00:12:32,450 --> 00:12:38,240
in your application by upgrading to more secure versions of the packages that are out there.

00:12:38,240 --> 00:12:45,279
We have performed 335 million security audits in the last 30 days.

00:12:45,279 --> 00:12:48,350
If you think that your company should be doing more about security, you will forgive me if

00:12:48,350 --> 00:12:53,690
I mention we have a booth at this conference and we have a product called npm Enterprise,

00:12:53,690 --> 00:13:00,810
and it can help your company do more about JavaScript security than it's currently doing.

00:13:00,810 --> 00:13:06,820
That brings us to the first visit of the hype meter.

00:13:06,820 --> 00:13:08,370
Are we talking more about security?

00:13:08,370 --> 00:13:09,370
No.

00:13:09,370 --> 00:13:12,590
The thing that we talk about is performance.

00:13:12,590 --> 00:13:16,660
We talk about performance three times more than security.

00:13:16,660 --> 00:13:21,420
If we care about security, we should be talking more about it.

00:13:21,420 --> 00:13:27,630
Another aspect of our increasingly experienced user base is that people actually care what

00:13:27,630 --> 00:13:29,500
software licence they use.

00:13:29,500 --> 00:13:30,740
That was a big surprise to me.

00:13:30,740 --> 00:13:33,770
I like to throw it in there without thinking about it.

00:13:33,770 --> 00:13:41,470
58 per cent of developers say that the software licence affects their decision to use a piece

00:13:41,470 --> 00:13:47,370
of open-source software, and of those, 55 per cent say that their company prevents them

00:13:47,370 --> 00:13:55,550
using certain open-source software licences means 45 per cent of people can't use them

00:13:55,550 --> 00:13:56,750
overall.

00:13:56,750 --> 00:13:57,950
Which?

00:13:57,950 --> 00:14:02,950
The GPL and the APL are unpopular because of the restrictions they place on commercial

00:14:02,950 --> 00:14:07,550
use of software, but much bigger than that was unrecognised licences.

00:14:07,550 --> 00:14:12,510
Basically, anybody who cares about software licences has had to hire a lawyer to tell

00:14:12,510 --> 00:14:16,980
them which software licences are okay, so, if you use some software license that they've

00:14:16,980 --> 00:14:21,910
never heard of before, they have to hire the lawyer again, and they don't want to do that,

00:14:21,910 --> 00:14:24,020
so they just don't use your software.

00:14:24,020 --> 00:14:29,089
So, if you're licensing your share, please put a licence on your software, and please

00:14:29,089 --> 00:14:33,400
pick a big popular licence that people have heard of.

00:14:33,400 --> 00:14:41,980
The second is a consequence of how ubiquitous JavaScript has become in 2019.

00:14:41,980 --> 00:14:49,980
26 per cent of JavaScript developers say that JavaScript is not their primary language.

00:14:49,980 --> 00:14:55,090
JavaScript is so popular it's become inescapable which means there are lots of JavaScript developers

00:14:55,090 --> 00:15:00,230
who aren't writing JavaScript by choice, they're writing it because they have to, and that

00:15:00,230 --> 00:15:05,390
is going to show up in a bunch of places in this data I'm about to present.

00:15:05,390 --> 00:15:09,110
So what are these other languages that the non-primary JavaScript developers are writing?

00:15:09,110 --> 00:15:11,430
Well, top of the list is TypeScript.

00:15:11,430 --> 00:15:17,190
We are going to talk more about TypeScript in a bit but there's lots of Python, Java,

00:15:17,190 --> 00:15:19,290
C++ in there.

00:15:19,290 --> 00:15:25,380
A fun fact is that 12 per cent of JavaScript developers don't write any other languages,

00:15:25,380 --> 00:15:30,660
they're just all JavaScript all the time, but 88 per cent of us are writing JavaScript

00:15:30,660 --> 00:15:33,620
and some other language - at least one more.

00:15:33,620 --> 00:15:39,950
So, now we have covered who we are, we are all over the world, we are every age and experience,

00:15:39,950 --> 00:15:44,779
increasingly sophisticated, we care more about licensing and security, where are rewriting

00:15:44,779 --> 00:15:45,779
this JavaScript?

00:15:45,779 --> 00:15:51,470
The answer is every goddamned place you can imagine.

00:15:51,470 --> 00:15:53,360
Let's go to the hype meter.

00:15:53,360 --> 00:16:00,150
Do they talk more about front-end or back-end at JSConf?

00:16:00,150 --> 00:16:06,240
For the last three years, front-end has been winning HP how does that stack up to the facts?

00:16:06,240 --> 00:16:07,350
Pretty well.

00:16:07,350 --> 00:16:12,110
97 per cent of JavaScript developers are writing code for browsers.

00:16:12,110 --> 00:16:17,940
77 per cent of JavaScript developers are also writing code for servers, so node.js is still

00:16:17,940 --> 00:16:19,160
a big deal in the community.

00:16:19,160 --> 00:16:25,360
There are two big surprises in here, and the first is that 46 per cent of JavaScript developers

00:16:25,360 --> 00:16:27,270
are writing native apps.

00:16:27,270 --> 00:16:32,580
I don't mean progressive web apps, a short cut to a web app that you put on a home screen,

00:16:32,580 --> 00:16:37,230
but they're compiling it down to another thing or running natively on a desktop or running

00:16:37,230 --> 00:16:38,890
natively on a phone.

00:16:38,890 --> 00:16:45,740
13 per cent of us are writing embedded applications, stuff that runs on handsets, watches, stuff

00:16:45,740 --> 00:16:47,440
that you wear.

00:16:47,440 --> 00:16:49,670
Let's dig more into all of these numbers.

00:16:49,670 --> 00:16:54,800
First off, when people write for browsers, do they target the mobile web or do they target

00:16:54,800 --> 00:16:56,160
the desktop web?

00:16:56,160 --> 00:17:01,910
The overwhelming majority of us target both, but despite all our talk about mobile first,

00:17:01,910 --> 00:17:05,270
only two per cent of us target exclusively mobile.

00:17:05,270 --> 00:17:10,040
But 27 per cent of us are getting away without thinking about the mobile web at all, which

00:17:10,040 --> 00:17:11,309
is probably legitimate.

00:17:11,309 --> 00:17:16,000
There are probably a bunch of web apps that are never going to run on a phone, and that's

00:17:16,000 --> 00:17:17,180
fine.

00:17:17,180 --> 00:17:19,560
But now let's talk about native apps.

00:17:19,560 --> 00:17:23,780
46 per cent of JavaScript developers are writing native apps.

00:17:23,780 --> 00:17:29,860
As you can see, the biggest group is mobile developers - 35 per cent of us are writing

00:17:29,860 --> 00:17:34,350
native mobile apps, and 26 per cent of us are writing native desktop apps.

00:17:34,350 --> 00:17:36,860
A big chunk of us are doing both.

00:17:36,860 --> 00:17:38,950
So what are we using to do that?

00:17:38,950 --> 00:17:44,530
First, let's look at the desktop developers: 26 per cent of developers say they write native

00:17:44,530 --> 00:17:47,750
desktop apps but here we have a bit of a puzzle.

00:17:47,750 --> 00:17:52,420
You've all probably heard of Electron which is a way of writing native desktop apps but

00:17:52,420 --> 00:17:58,670
only 28 per cent of us say we use it which means there are 5 per cent of us writing native

00:17:58,670 --> 00:18:01,920
applications in JavaScript using something other than Electron.

00:18:01,920 --> 00:18:04,179
I don't know what it is!

00:18:04,179 --> 00:18:10,030
That 1 per cent of electron uses is down to 24 per cent of users.

00:18:10,030 --> 00:18:15,260
Not only is it that queer not using electron, we're using less Electron than before.

00:18:15,260 --> 00:18:16,260
Where are they going?

00:18:16,260 --> 00:18:20,170
Let's ask the meter about it.

00:18:20,170 --> 00:18:26,050
It says interest has peaked since 2017 and going down since then?

00:18:26,050 --> 00:18:27,700
What is up?

00:18:27,700 --> 00:18:28,700
Somebody needs to tell me.

00:18:28,700 --> 00:18:32,660
If you know what they're doing, please come and talk to me after this.

00:18:32,660 --> 00:18:36,580
Let's look at mobile app developers.

00:18:36,580 --> 00:18:42,620
I measured the popularity of a bunch of - don't pay too much attention to how I measured it.

00:18:42,620 --> 00:18:45,650
The green line is all native app frameworks.

00:18:45,650 --> 00:18:50,370
So native development has been staying pretty much as popular as before, but the tools have

00:18:50,370 --> 00:18:51,920
fragmented.

00:18:51,920 --> 00:18:57,770
The most popular framework I can find is React Native which is the red line and then Cordova

00:18:57,770 --> 00:19:09,900
which used to be the only game in town for mobile apps but now little less popular

00:19:09,900 --> 00:19:11,580
of React Native.

00:19:11,580 --> 00:19:17,870
Ex-extrapolating, about 19 per cent are using React Native, and those two add up to about

00:19:17,870 --> 00:19:22,500
the 35 per cent of us who are writing native mobile apps, but if you're using some other

00:19:22,500 --> 00:19:25,190
framework, I want to know.

00:19:25,190 --> 00:19:29,510
The final "where" question I want to answer is about server-side apps.

00:19:29,510 --> 00:19:32,250
Where are we deploying them?

00:19:32,250 --> 00:19:37,250
Unsurprisingly, Docker and Kubernetes is everybody's jam these days.

00:19:37,250 --> 00:19:40,190
They're the dominant way we deploy.

00:19:40,190 --> 00:19:44,380
Deployment platforms like Heroku and Netlify are surprisingly unpopular.

00:19:44,380 --> 00:19:54,880
VMs are the way I that considered - the real number here is serverless.

00:19:54,880 --> 00:19:58,370
33 per cent of us are deploying on serverless platforms.

00:19:58,370 --> 00:20:05,590
That's not some early adaptor shit any more, that's some mainstream technology.

00:20:05,590 --> 00:20:09,640
It's part of a broader trend in ten providing that I'm going to touch on later.

00:20:09,640 --> 00:20:12,600
Let's check out the hype meter.

00:20:12,600 --> 00:20:20,520
I decided to look at serverless, micro services, and Docker.

00:20:20,520 --> 00:20:26,920
Docker came strong out of the gate in 2015 and you has slowed down recently, but serverless

00:20:26,920 --> 00:20:28,020
is on the up and up.

00:20:28,020 --> 00:20:30,270
That's the blue line.

00:20:30,270 --> 00:20:34,980
But isn't serverless just like a microservice that one else is running for you?

00:20:34,980 --> 00:20:37,220
I don't know.

00:20:37,220 --> 00:20:38,870
That brings us to the end of where.

00:20:38,870 --> 00:20:40,080
Now let's talk about what.

00:20:40,080 --> 00:20:42,010
What are we doing?

00:20:42,010 --> 00:20:46,700
What are we doing with all of this stuff?

00:20:46,700 --> 00:20:51,309
I'm going to try and keep this section also as factual as possible, and keep my opinions

00:20:51,309 --> 00:20:52,309
out of it.

00:20:52,309 --> 00:20:56,260
To measure this stuff, I use a metric called "shared registry".

00:20:56,260 --> 00:20:59,160
I used it in that graph a little while.

00:20:59,160 --> 00:21:03,620
It's a very useful metric but it's also a kind of confusing metric so I'm going to explain

00:21:03,620 --> 00:21:05,179
it a bit.

00:21:05,179 --> 00:21:09,500
This is a graph of the weekly downloads from the npm registry.

00:21:09,500 --> 00:21:13,730
We do nearly 12 billion downloads every week.

00:21:13,730 --> 00:21:19,100
This has grown.

00:21:19,100 --> 00:21:24,581
This presents a popular if you're trying to present how popular something is by download

00:21:24,581 --> 00:21:29,340
numbers, because download numbers always go up.

00:21:29,340 --> 00:21:34,090
Here's a graph of downloads from major front-end frameworks and they're all growing pretty

00:21:34,090 --> 00:21:36,080
fast in absolute terms.

00:21:36,080 --> 00:21:39,510
In fact, everything in the registry grows super fast.

00:21:39,510 --> 00:21:45,299
Even the shittiest package is constantly acquire new users because there are so many people

00:21:45,299 --> 00:21:52,700
showing up all the time say I don't know what to use, I'm going to use evil package JS.

00:21:52,700 --> 00:21:54,610
Absolute growth won't work.

00:21:54,610 --> 00:21:59,520
So just like with the JSConf submissions, we're using relative popularity.

00:21:59,520 --> 00:22:04,750
We use the percentage of downloads of a pack garage as a percentage of all of the downloads,

00:22:04,750 --> 00:22:06,740
and that is what we call a shared registry.

00:22:06,740 --> 00:22:11,110
Here's the same graph again using the shared registry metric instead.

00:22:11,110 --> 00:22:16,751
Suddenly, what is going on is a lot more clear - some stuff is going up, some stuff is staying

00:22:16,751 --> 00:22:23,730
flat, some stuff is going down, but it's important to remember that going down is not actually

00:22:23,730 --> 00:22:28,390
declining, it's just meaning that it is going up more slowly.

00:22:28,390 --> 00:22:34,080
Staying flat on this graph means that you grew 25,000 per cent, and, if you're going

00:22:34,080 --> 00:22:39,870
up on this graph, it means that you are growing faster than 25,000 per cent.

00:22:39,870 --> 00:22:44,940
Growing up is growing incredibly fast.

00:22:44,940 --> 00:22:46,870
So now let's talk about these frameworks.

00:22:46,870 --> 00:22:53,790
The story of front-end face, in 2019 is pretty simple, and it is that React has conquered

00:22:53,790 --> 00:22:56,070
the web.

00:22:56,070 --> 00:23:00,250
React has more than four times as many downloads as the next most popular framework.

00:23:00,250 --> 00:23:05,320
There hasn't been a framework anything like this popular, and part of the reason for that

00:23:05,320 --> 00:23:07,429
is that it's not just a front-end framework.

00:23:07,429 --> 00:23:10,880
In fact, it's not even a front-end framework.

00:23:10,880 --> 00:23:16,000
React is just a component model, and that component model is used in web apps, in React

00:23:16,000 --> 00:23:19,630
Native apps, and also in desktop apps.

00:23:19,630 --> 00:23:21,940
This is the download data.

00:23:21,940 --> 00:23:24,790
What about the survey where we asked actual people?

00:23:24,790 --> 00:23:33,660
In our survey, 63 per cent of JavaScript developers say they're using React, but "using" is a

00:23:33,660 --> 00:23:34,660
vague term, right?

00:23:34,660 --> 00:23:36,070
It can be anything.

00:23:36,070 --> 00:23:38,190
We asked a specific question.

00:23:38,190 --> 00:23:43,040
57 per cent of people say they write React themselves and 67 per cent said they use it

00:23:43,040 --> 00:23:45,130
written by other people.

00:23:45,130 --> 00:23:52,070
15 per cent of us say we don't use React yet but we are considering it, so React already

00:23:52,070 --> 00:23:58,000
a ridiculously dominant framework still has room to grow, apparently.

00:23:58,000 --> 00:24:03,250
Although the shared registry appears to be slowing down, so, we don't know it yet which

00:24:03,250 --> 00:24:05,520
one of those things is going to happen.

00:24:05,520 --> 00:24:10,049
To dig even further, we asked people how much they write React.

00:24:10,049 --> 00:24:15,090
Inside the 57 per cent of people who write React, 49 per cent of people say they primarily

00:24:15,090 --> 00:24:24,960
write React, and which means 26 per cent of all npm users are primarily building React,

00:24:24,960 --> 00:24:29,330
and, if you add in the people who write it only sometimes, that means that 57 per cent

00:24:29,330 --> 00:24:36,720
- near half of all JavaScript developers - are writing React some or most of the time.

00:24:36,720 --> 00:24:39,900
There has never been a framework of which that is true.

00:24:39,900 --> 00:24:45,390
That is a strange and new situation for JavaScript to be in.

00:24:45,390 --> 00:24:46,840
Moving on to the other frameworks.

00:24:46,840 --> 00:24:51,840
Last year, I got into some trouble because I took Angular version 1 and Angular version

00:24:51,840 --> 00:24:57,020
2 onwards and treated them as a single framework called Angular, and I was strenuously informed

00:24:57,020 --> 00:25:00,200
that that is incorrect.

00:25:00,200 --> 00:25:03,030
Angular version 1 is called Angular JS now.

00:25:03,030 --> 00:25:12,980
Angular version 2 is unrelated to the first one also called Angular which I think is still

00:25:12,980 --> 00:25:16,580
kind of confusing.

00:25:16,580 --> 00:25:23,669
Angular JS has been in decline since 2016, and 2 since 2017.

00:25:23,669 --> 00:25:28,410
It's important to keep it in mind this is relative popularity.

00:25:28,410 --> 00:25:33,630
In absolute terms, both of these frameworks are growing up, both of these frameworks have

00:25:33,630 --> 00:25:37,100
more users than they've ever had before.

00:25:37,100 --> 00:25:38,720
Angular is extremely popular.

00:25:38,720 --> 00:25:44,260
37 per cent of npm users say they use some flavour of Angular, 29 per cent say they use

00:25:44,260 --> 00:25:46,360
the current version of Angular.

00:25:46,360 --> 00:25:51,010
That means there's probably about three million people using Angular which is definitely nothing

00:25:51,010 --> 00:25:55,300
to sneeze at, and Angular is not going anywhere.

00:25:55,300 --> 00:25:57,371
Let's look at one more framework of note which is Vue.

00:25:57,371 --> 00:26:02,299
Vue is the only major framework other than React showing strong positive growth, but

00:26:02,299 --> 00:26:04,320
it is very positive growth.

00:26:04,320 --> 00:26:08,970
Its share of registry has doubled in the last two years which means that it its downloads

00:26:08,970 --> 00:26:11,100
grew 10x in that time.

00:26:11,100 --> 00:26:16,250
Our survey data backs that up.

00:26:16,250 --> 00:26:21,679
Up from 24 per cent last year, which means almost as many people use Vue as use the current

00:26:21,679 --> 00:26:24,290
version of Angular.

00:26:24,290 --> 00:26:28,179
Let's swing by the hype meter are and he and see what they said about front-end frameworks.

00:26:28,179 --> 00:26:32,370
In 2009, of course was talking about Dojo and jQuery.

00:26:32,370 --> 00:26:39,960
You can see the trajectories.

00:26:39,960 --> 00:26:44,120
They react well to share share of registry which is nice.

00:26:44,120 --> 00:26:47,210
Angular's decline starts in 2015.

00:26:47,210 --> 00:26:52,370
Amber is flat, and yellow, and React in blue is continuing to grow, just like it is in

00:26:52,370 --> 00:26:54,669
the registry data.

00:26:54,669 --> 00:26:58,970
One thing I haven't talked about in terms of front-end frameworks is web components,

00:26:58,970 --> 00:27:03,700
and part of that is they're built into browsers so there is no shared registry to track.

00:27:03,700 --> 00:27:06,260
Nobody's downloading them.

00:27:06,260 --> 00:27:09,730
The other reason is they don't seem to be very popular.

00:27:09,730 --> 00:27:15,120
We didn't ask about npm survey, which is embarrassing, but the State of JS people did.

00:27:15,120 --> 00:27:19,190
They allowed people to volunteer if they used web components but less than one per cent

00:27:19,190 --> 00:27:21,679
of deem did.

00:27:21,679 --> 00:27:26,280
I'm not ignoring web components, I don't have gad data about them.

00:27:26,280 --> 00:27:30,090
The people who build web components in browsers, they tell me that web components are a lot

00:27:30,090 --> 00:27:34,590
more popular than they think they are, and you but of course they would say that.

00:27:34,590 --> 00:27:40,280
Moving from the front-end to the back-end, there has been a real revolution.

00:27:40,280 --> 00:27:44,410
Previously, if I was talking about back-end frameworks, I would have talked about stuff

00:27:44,410 --> 00:27:46,480
like Sales, and Amber.

00:27:46,480 --> 00:27:52,440
>> Happy, and they have still around about flat growth.

00:27:52,440 --> 00:27:55,880
They're not going anywhere.

00:27:55,880 --> 00:27:59,929
Everybody's right rich front-end apps and frameworks like those that produce static

00:27:59,929 --> 00:28:03,799
views are not as useful for that use case any more.

00:28:03,799 --> 00:28:09,419
So, instead, what has happened, is front-end framework enthusiasts realise that they needed

00:28:09,419 --> 00:28:15,260
no deliver pre-rendered HTML for performance reasons and they called it "server-side rendering"

00:28:15,260 --> 00:28:16,440
or SSV.

00:28:16,440 --> 00:28:22,020
They invented stuff to do that which is is to say they invented back-ends.

00:28:22,020 --> 00:28:27,790
The front-end frameworks are also back-end frameworks, collections of servers and routers

00:28:27,790 --> 00:28:32,039
that make it easy to build a full server using your favourite framework.

00:28:32,039 --> 00:28:36,580
I don't know about you, but the idea that I can just write components and then throw

00:28:36,580 --> 00:28:41,090
them into an existing framework and not have - that does the serving and the parsing and

00:28:41,090 --> 00:28:45,200
that pain-in-the-ass stuff for me is great but super familiar.

00:28:45,200 --> 00:28:49,280
I'm sure that's how PHP used to work!

00:28:49,280 --> 00:28:54,750
Some day soon, someone will tell me I can FTP my React components on a server and then

00:28:54,750 --> 00:28:57,580
the circle will be complete!

00:28:57,580 --> 00:28:59,340
[Laughter].

00:28:59,340 --> 00:29:03,840
Before I talk about these SSR frameworks, it's important to know they're all still pretty

00:29:03,840 --> 00:29:04,840
small.

00:29:04,840 --> 00:29:10,000
Here for comparison is Express, which is a goddamned monster of a package.

00:29:10,000 --> 00:29:16,070
It used to be 1.5 per cent of the registry all by itself, and it is still enormous.

00:29:16,070 --> 00:29:19,730
All of the other frameworks that I'm about to talk about are that flat line at the bottom

00:29:19,730 --> 00:29:22,260
of the graft that you can barely see.

00:29:22,260 --> 00:29:28,950
But, when you take Express out of the picture, something very interesting is happening.

00:29:28,950 --> 00:29:31,570
At the top of our list is Gatsby.

00:29:31,570 --> 00:29:36,070
It uses React and provides a whole set of tools for hooking it up to back-ends and deploying

00:29:36,070 --> 00:29:37,070
it.

00:29:37,070 --> 00:29:39,330
It snuck up on us.

00:29:39,330 --> 00:29:48,960
Eight per cent of people are using it.

00:29:48,960 --> 00:29:53,400
Sales of Amber and Happy are all around the four to five per cent area, and Gatsby is

00:29:53,400 --> 00:30:00,419
bigger than that now, it's huge, and real, and growing like gang busters.

00:30:00,419 --> 00:30:08,190
The others I want to talk about are a trio of products that nearly have the same name.

00:30:08,190 --> 00:30:13,789
Next is NextJS.

00:30:13,789 --> 00:30:16,350
Our survey respondents were big on that.

00:30:16,350 --> 00:30:18,200
Nine per cent said they use it.

00:30:18,200 --> 00:30:24,700
Share of registry is giving Gatsby the edge but clearly both very popular.

00:30:24,700 --> 00:30:32,500
Then there's NuxtJS which is like NextJS which is for Vue instead of React.

00:30:32,500 --> 00:30:40,980
Then NestJS which is like NextJS except it's for Angular.

00:30:40,980 --> 00:30:43,289
I know very little about it.

00:30:43,289 --> 00:30:47,520
I didn't ask about it in our survey, but extrapolating it from our survey, two per cent of people

00:30:47,520 --> 00:30:52,590
are using NestJS and showing healthy growth.

00:30:52,590 --> 00:30:55,620
What about the hype?

00:30:55,620 --> 00:30:57,140
It's super frustrating.

00:30:57,140 --> 00:30:58,980
"Next" is just a word.

00:30:58,980 --> 00:31:02,290
They say it all the time, don't mean the framework.

00:31:02,290 --> 00:31:08,820
And "nest" shows up all the time because people talk about nested code and loops, and this

00:31:08,820 --> 00:31:17,130
is a graph about Gatsby.

00:31:17,130 --> 00:31:23,440
Closely related to these front-end frameworks which are now back-end frameworks is GraphQL,

00:31:23,440 --> 00:31:27,720
which is the hot new way of building an API to power all of this stuff.

00:31:27,720 --> 00:31:32,370
As you can see, GraphQL's core library and two of its most popular client libraries are

00:31:32,370 --> 00:31:37,940
growing off the chart super fast in share of registry, and that climb is reflected in

00:31:37,940 --> 00:31:38,940
the survey data.

00:31:38,940 --> 00:31:44,351
22 per cent of our respondents say they're using GraphQL but 49 per cent say that they

00:31:44,351 --> 00:31:48,240
are considering using GraphQL which is an enormous number.

00:31:48,240 --> 00:31:52,919
It means that 2019 is going to be the year of GraphQL when everybody gets on board the

00:31:52,919 --> 00:31:53,919
train.

00:31:53,919 --> 00:31:58,620
And the final set of trend data we're going to look at is the hottest trend of all which

00:31:58,620 --> 00:32:02,870
is not writing JavaScript any more.

00:32:02,870 --> 00:32:06,530
Remember all those non-primary JavaScript developers that I was talking about?

00:32:06,530 --> 00:32:11,950
Especially the ones coming from typed languages like Java, C#, and C++?

00:32:11,950 --> 00:32:15,240
This is how their influence is showing up.

00:32:15,240 --> 00:32:17,780
The biggest part of this trend is TypeScript.

00:32:17,780 --> 00:32:23,260
Last year, we were caught by surprise when 49 per cent of people - sorry, 46 per cent

00:32:23,260 --> 00:32:28,240
of people said they used TypeScript, and this year, that number is up to 63 per cent.

00:32:28,240 --> 00:32:29,710
But what does "using" mean?

00:32:29,710 --> 00:32:33,900
Are you using it, writing it, what are you doing with it exactly?

00:32:33,900 --> 00:32:38,419
It turns out 15 per cent of people are just using things that are written in TypeScript,

00:32:38,419 --> 00:32:40,330
and the main culprit there is Angular.

00:32:40,330 --> 00:32:44,330
Angular is written in TypeScript, so everybody who uses Angular reports themselves as a TypeScript

00:32:44,330 --> 00:32:45,330
user.

00:32:45,330 --> 00:32:48,620
In fact, React and Amber have TypeScript in them.

00:32:48,620 --> 00:32:54,030
Now the only major framework that doesn't have TypeScript in it is Vue.

00:32:54,030 --> 00:32:58,450
Even if you say you write TypeScript, do you mean you write it all the time, or just to

00:32:58,450 --> 00:32:59,450
try it out?

00:32:59,450 --> 00:33:03,320
Are you a TypeScript dev or dabbler.

00:33:03,320 --> 00:33:10,950
52 per cent of them primarily write TypeScript, and another 34 per cent are writing TypeScript

00:33:10,950 --> 00:33:17,970
some of the time which means 36 per cent of npm users are writing TypeScript most or all

00:33:17,970 --> 00:33:24,580
of the time which is a tremendous change - a third of JavaScript users don't write JavaScript

00:33:24,580 --> 00:33:26,020
any more.

00:33:26,020 --> 00:33:28,220
That's amazing.

00:33:28,220 --> 00:33:32,600
Incidentally, one of the features of TypeScript is that it has these typed definition files,

00:33:32,600 --> 00:33:36,920
and those typed definition files are hosted on the registry.

00:33:36,920 --> 00:33:42,720
The last time I checked, 2.5 per cent of all registry downloads are Type definitions.

00:33:42,720 --> 00:33:48,130
The most downloaded - they are mostly downloaded automatically, so we should have a chat with

00:33:48,130 --> 00:33:50,890
Microsoft about that.

00:33:50,890 --> 00:33:51,890
But what about the hype?

00:33:51,890 --> 00:33:53,809
The hype is doing fine.

00:33:53,809 --> 00:33:56,630
For fun, I through in Coffee Script which is the last time somebody tried to replace

00:33:56,630 --> 00:33:59,260
JavaScript with something that looked like JavaScript.

00:33:59,260 --> 00:34:03,299
We don't talk about that any more!

00:34:03,299 --> 00:34:08,820
The other part of the not-writing-JavaScript trend is Web Assembly.

00:34:08,820 --> 00:34:17,710
It lets you run it on the web at near native speeds.

00:34:17,710 --> 00:34:22,149
The first interesting thing is the speed, and the second is the people who write WebAssembly

00:34:22,149 --> 00:34:26,119
say that is less interesting than the second part which is the ability to use existing

00:34:26,119 --> 00:34:29,460
code written in other languages directly on the web.

00:34:29,460 --> 00:34:33,990
To me, one of the most exciting features of WebAssembly is that you can write modules

00:34:33,990 --> 00:34:38,069
to it and publish them to the npm registry and install them into your app and use them

00:34:38,069 --> 00:34:40,289
seamlessly without knowing they're there.

00:34:40,289 --> 00:34:43,960
The way I know that you can do that is that it has already happened.

00:34:43,960 --> 00:34:46,019
Our stats say that WebAssembly is very knew.

00:34:46,019 --> 00:34:52,909
Only three per cent of people say they use it, but that's 300,000 people, and only 0.6

00:34:52,909 --> 00:34:59,190
per cent of the packages in the registry with Wasm, but those packages are cool, but the

00:34:59,190 --> 00:35:03,349
big number for WebAssembly is 54 per cent - that's how many people say they consider

00:35:03,349 --> 00:35:08,170
they're using it which means the interest in WebAssembly is enormous.

00:35:08,170 --> 00:35:14,160
So, now we know what we are and what we are using, and those facts together can point

00:35:14,160 --> 00:35:16,779
us towards an explanation as to why.

00:35:16,779 --> 00:35:21,509
This is where I switch from facts to analysis, which is to say opinions, which is to say

00:35:21,509 --> 00:35:22,569
I am wrong.

00:35:22,569 --> 00:35:28,050
Before I do that, I need to split the room up into two teams.

00:35:28,050 --> 00:35:32,790
Everybody on this side of the room is Team A. Everybody on this side of the room is Team

00:35:32,790 --> 00:35:36,999
B. Let me hear it from Team A. Team B!

00:35:36,999 --> 00:35:38,450
[Cheering].

00:35:38,450 --> 00:35:41,359
Team A!

00:35:41,359 --> 00:35:42,359
Team B!

00:35:42,359 --> 00:35:43,359
Great.

00:35:43,359 --> 00:35:44,829
I wasn't using that for anything.

00:35:44,829 --> 00:35:49,619
Just to wake you up after 30 minutes of graphs.

00:35:49,619 --> 00:35:54,910
The first question to answer is why is JavaScript the most popular programming language?

00:35:54,910 --> 00:36:00,130
I think we can discard the idea that it is the best-designed programming language.

00:36:00,130 --> 00:36:02,109
One answer is the npm registry.

00:36:02,109 --> 00:36:07,109
A guy did a study where he researched why people use programming languages.

00:36:07,109 --> 00:36:10,539
Is it the features, the speed, or because their boss forced them to?

00:36:10,539 --> 00:36:15,569
The number-one reason was the existence of open-source libraries in that language.

00:36:15,569 --> 00:36:20,270
If there is a library that helps you get the job done, you adopt the language of the library,

00:36:20,270 --> 00:36:25,099
and because there are so many libraries in JavaScript already, it keeps sucking people

00:36:25,099 --> 00:36:27,779
in.

00:36:27,779 --> 00:36:31,960
Once about every 15 minutes, somebody sends me this picture thinking that it is super

00:36:31,960 --> 00:36:33,859
hilarious and I won't have seen it before.

00:36:33,859 --> 00:36:36,180
It's not a bad metaphor.

00:36:36,180 --> 00:36:41,710
Every time somebody adds another package to the pile, it increases - another developer

00:36:41,710 --> 00:36:47,220
gets sucked in, and that developer increases the pull even further.

00:36:47,220 --> 00:36:52,230
And this has created a new type of JavaScript developer: the reluctant JavaScripter.

00:36:52,230 --> 00:36:56,599
They were once a really small group but now there are quarter, or possibly even more of

00:36:56,599 --> 00:36:58,059
the JavaScript population.

00:36:58,059 --> 00:37:02,279
They don't write JavaScript because they like it, they write JavaScript because they have

00:37:02,279 --> 00:37:04,099
to, and that's bad.

00:37:04,099 --> 00:37:07,981
That's bad for them, because they hate it, and it's bad for us because people who hate

00:37:07,981 --> 00:37:09,539
JavaScript won't write it well.

00:37:09,539 --> 00:37:12,579
Why are we forcing people to write JavaScript?

00:37:12,579 --> 00:37:14,599
This happened one time before.

00:37:14,599 --> 00:37:20,059
A few years ago Ruby developers found themselves sucked into the JavaScript world, and they

00:37:20,059 --> 00:37:21,059
hated it.

00:37:21,059 --> 00:37:26,369
They hate JavaScript, and they keep telling me they hate it in their survey results.

00:37:26,369 --> 00:37:31,390
Some of them attempted to resolve that problem by inventing Copy Script but the Ruby folks

00:37:31,390 --> 00:37:33,900
mostly won.

00:37:33,900 --> 00:37:40,109
JavaScript is full of features that we used to have in Ruby, and TypeScript is something

00:37:40,109 --> 00:37:41,469
like that pattern.

00:37:41,469 --> 00:37:44,089
Remember all of those non-primary JavaScript developers?

00:37:44,089 --> 00:37:47,869
A bunch of people from typed languages, in particular from Java and C#?

00:37:47,869 --> 00:37:49,469
They miss the types.

00:37:49,469 --> 00:37:51,920
JavaScript is giving them the type back.

00:37:51,920 --> 00:37:54,960
That's what they like about it.

00:37:54,960 --> 00:37:59,240
Given the popularity of TypeScript, and types, and Microsoft's backing in particular, it's

00:37:59,240 --> 00:38:02,020
unlikely to go anywhere.

00:38:02,020 --> 00:38:06,019
In our survey, 17 per cent of people who heard of WebAssembly said part of the reason they

00:38:06,019 --> 00:38:12,550
were interested in it means they wouldn't have to write JavaScript any more.

00:38:12,550 --> 00:38:16,940
WebAssembly frees developers from JavaScript, and the result will be that a lot of people

00:38:16,940 --> 00:38:19,559
will stop writing JavaScript.

00:38:19,559 --> 00:38:21,130
That is not something to be worried about.

00:38:21,130 --> 00:38:23,839
First, not everybody is going to stop.

00:38:23,839 --> 00:38:27,519
Just the folks who hated writing it, and, second, when people writing WebAssembly are

00:38:27,519 --> 00:38:33,859
looking for a way to share code, the in registry is the natural way for them to do that.

00:38:33,859 --> 00:38:38,509
WebAssembly will make JavaScript stronger by giving it access to the best libraries

00:38:38,509 --> 00:38:43,650
from every other language, which is a tremendously exciting idea.

00:38:43,650 --> 00:38:48,390
The next question we're touching on is what the hell is going on with React?

00:38:48,390 --> 00:38:50,960
Part of the explanation is that React isn't a full web framework.

00:38:50,960 --> 00:38:56,160
It has no opinions about routing, or data models and other frameworks do, so as models

00:38:56,160 --> 00:39:01,680
change, it means that people can keep using the React components and shift and go and

00:39:01,680 --> 00:39:03,539
change within that group.

00:39:03,539 --> 00:39:08,229
It's just a component model and it creates truly reusable useful components.

00:39:08,229 --> 00:39:13,849
These are two examples that I particularly like: a colour-picker, and a date-picker.

00:39:13,849 --> 00:39:16,330
I hate installing those.

00:39:16,330 --> 00:39:21,089
That's been the dream for 20 years.

00:39:21,089 --> 00:39:24,049
Other projects provide libraries of excellent prebuilt components.

00:39:24,049 --> 00:39:27,450
This is one that does it for Google's Material UI.

00:39:27,450 --> 00:39:32,589
Reach UI makes React components more accessible.

00:39:32,589 --> 00:39:36,950
React can go further with React hooks which are a way of handling state that you can just

00:39:36,950 --> 00:39:40,289
npm-install into your application.

00:39:40,289 --> 00:39:45,279
React Use is a library that gives you a whole bunch of really cool stuff that uses the web

00:39:45,279 --> 00:39:47,660
APIs without you having to write a bunch of code.

00:39:47,660 --> 00:39:51,480
You can just import it and start using it in your React app.

00:39:51,480 --> 00:39:57,099
This suggests an enticing future where we can build web apps as a new and higher level

00:39:57,099 --> 00:39:58,099
of abstraction.

00:39:58,099 --> 00:40:02,920
We won't have to think too hard about the server but put existing components together

00:40:02,920 --> 00:40:07,300
instead of building them from scratch for each project, especially components that we

00:40:07,300 --> 00:40:14,400
add will create the same feedback loop as npm itself, the more components there are,

00:40:14,400 --> 00:40:18,119
the stronger the gravity well, and the stronger the users will be in that community.

00:40:18,119 --> 00:40:25,180
It could make React an unstoppable force that changes web development forever.

00:40:25,180 --> 00:40:26,880
It's not guaranteed.

00:40:26,880 --> 00:40:36,430
React is slowing down and Vue is showing strong growth.

00:40:36,430 --> 00:40:40,029
In the next couple of years we get to find out if React fades.

00:40:40,029 --> 00:40:45,099
React's dominance on the front-end has totally changed the back-end.

00:40:45,099 --> 00:40:49,519
Frameworks that enable server-side rendering of React apps are now more popular than traditional

00:40:49,519 --> 00:40:51,020
back-end frameworks.

00:40:51,020 --> 00:40:55,329
Instead of writing code for client and server, we just write code for the client and we get

00:40:55,329 --> 00:40:58,539
the server to deal with it and figure it out.

00:40:58,539 --> 00:41:00,680
Is that a good idea?

00:41:00,680 --> 00:41:04,599
Is building all web apps as rich front-end apps and getting the server to do the work

00:41:04,599 --> 00:41:05,599
a good idea?

00:41:05,599 --> 00:41:06,599
I don't know.

00:41:06,599 --> 00:41:11,359
It's certainly a popular idea, and popularity has its own momentum.

00:41:11,359 --> 00:41:17,779
At least one browser maker is already working on specific optimisations to make React apps

00:41:17,779 --> 00:41:20,749
faster at the browser level.

00:41:20,749 --> 00:41:26,259
Last year, I made the case that React components should become part of the web API, and I stand

00:41:26,259 --> 00:41:29,140
by that.

00:41:29,140 --> 00:41:35,069
Let's take these trends and analyses and weave them together and make guesses about the future.

00:41:35,069 --> 00:41:38,289
I'm going to go from slightly wrong to completely wrong.

00:41:38,289 --> 00:41:47,859
The first is npm Tink, it's an tremendously exciting thing that I don't have time to demo.

00:41:47,859 --> 00:41:55,519
Dan Abramov tweeted this, and it's exactly what this looks like where it might be going:

00:41:55,519 --> 00:42:01,249
imagine a world where you can build a web app without needing to know all the details

00:42:01,249 --> 00:42:03,440
of how your components work.

00:42:03,440 --> 00:42:08,970
People hate VB6 but at one point, it was the world's most popular programming language.

00:42:08,970 --> 00:42:10,770
That's us now.

00:42:10,770 --> 00:42:16,839
VB6 unlocked and created a whole generation of programmers by reducing the barrier to

00:42:16,839 --> 00:42:18,440
entry.

00:42:18,440 --> 00:42:23,950
Think how many more people could get involved if you could build a real useful web app by

00:42:23,950 --> 00:42:28,420
just dragging and dropping open-source components into your application.

00:42:28,420 --> 00:42:32,539
This wouldn't make your job obsolete, we would still need everyone in this room to be writing

00:42:32,539 --> 00:42:38,039
components but we would need a room ten times this size to hold all the people who would

00:42:38,039 --> 00:42:40,259
be using those components.

00:42:40,259 --> 00:42:45,849
A whole new level of abstraction, a whole new kind of web developer.

00:42:45,849 --> 00:42:49,700
That is a tremendously exciting idea.

00:42:49,700 --> 00:42:54,210
And then you add to that mix WebAssembly which is early days now but you could bringing every

00:42:54,210 --> 00:43:01,229
other library from the JavaScript world and make them interoperable.

00:43:01,229 --> 00:43:05,260
Not only is it easy to build apps but what you can build is vastly expanded.

00:43:05,260 --> 00:43:12,089
The last piece of the puzzle is the native app developers, nearly half of us, take highly

00:43:12,089 --> 00:43:17,690
performant rich web apps and suddenly don't run them on the browser but run them on your

00:43:17,690 --> 00:43:22,510
phone, shoes, VR headset - wherever.

00:43:22,510 --> 00:43:26,970
JavaScript running everywhere, absorbing every language into a unified world of open source

00:43:26,970 --> 00:43:34,200
components built by an ever expanding and increased community of diverse developers.

00:43:34,200 --> 00:43:36,430
I can imagine a world where it happens.

00:43:36,430 --> 00:43:41,719
After watching 23 years of watching the web grow, no time has ever been more exciting

00:43:41,719 --> 00:43:46,589
right now, and you, my friends and colleagues, are perfectly placed.

00:43:46,589 --> 00:43:50,190
You're in the right place at the right time to participate in that.

00:43:50,190 --> 00:43:54,369
The web is an amazing force for good and evil.

00:43:54,369 --> 00:43:56,220
It is a toy, and it's a tool.

00:43:56,220 --> 00:43:58,130
It's a playground, and it's a marketplace.

00:43:58,130 --> 00:44:01,970
It's ultimately amazing and terrifying in the power that it gives us.

00:44:01,970 --> 00:44:06,229
We can do so much good and so much harm.

00:44:06,229 --> 00:44:10,690
But I choose to believe that, in the long run, we will collectively decide to do more

00:44:10,690 --> 00:44:13,739
things that help the world than hurt it.

00:44:13,739 --> 00:44:15,809
We've all made mistakes that hurt the world.

00:44:15,809 --> 00:44:17,660
I know that I have.

00:44:17,660 --> 00:44:24,680
But I believe that, in the course of time, our good decisions will outweigh our mistakes,

00:44:24,680 --> 00:44:27,910
and the web will grow forever.

00:44:27,910 --> 00:44:32,119
I hope what I've shared with you today that is helped you see where you are, and what

00:44:32,119 --> 00:44:37,670
you're doing, and I hope it's helped motivate you, and made you curious, and I hope you

00:44:37,670 --> 00:44:44,079
all have a fantastic JSConf and thank you so much for your time and attention.

00:44:44,079 --> 00:44:48,839

YouTube URL: https://www.youtube.com/watch?v=gChULw-uEjY


