Title: CSSconf EU 2017 | Patrick Hamann: CSS and the first meaningful paint
Publication date: 2017-05-22
Playlist: CSSconf EU 2017
Description: 
	http://2017.cssconf.eu/speakers/patrick-hamann.html

To render a webpage browsers needs to go through the complex dance of networking, parsing and painting before any content can be displayed to your user. Over the years, we've developed mechanisms and hacks to aid the browser at each stage of this process, but these have always come at some cost or trade-off.

How can we utilize modern web platform features to load our CSS as fast as possible? Should we still be inlining our critical content into the document or instead, how can HTTP/2 server push and Service Workers help us?

In this talk we will take a journey exploring the current, past, and future best-practices for loading CSS in the browser and how we can achieve a first meaningful paint within 1000ms. Ultimately creating a faster, more resilient experience for our users.
Captions: 
	00:00:00,750 --> 00:00:09,169
[Music]

00:00:09,889 --> 00:00:20,220
hello so thank you very much for having

00:00:18,270 --> 00:00:21,900
me it's a pleasure to be back here in

00:00:20,220 --> 00:00:24,330
Berlin as Tim just said this is actually

00:00:21,900 --> 00:00:25,920
my second time on this stage and it's a

00:00:24,330 --> 00:00:28,080
conference that as everyone's already

00:00:25,920 --> 00:00:30,660
mentioned this morning has a community

00:00:28,080 --> 00:00:32,430
that is dear to my heart and so it's

00:00:30,660 --> 00:00:33,780
actually an honor to be able to be back

00:00:32,430 --> 00:00:35,910
here speaking against it Thank You

00:00:33,780 --> 00:00:37,320
Chrissy calling you Kevin and the rest

00:00:35,910 --> 00:00:38,969
of the team and this awesome work that

00:00:37,320 --> 00:00:41,460
they've done and especially for it even

00:00:38,969 --> 00:00:43,200
allowing me to bring my child here I've

00:00:41,460 --> 00:00:44,969
got a one-year-old baby here with me

00:00:43,200 --> 00:00:47,460
Freddie come and say hello to him

00:00:44,969 --> 00:00:50,399
afterwards I'm trying to get them on the

00:00:47,460 --> 00:00:52,829
CSS party pack later on to do some

00:00:50,399 --> 00:00:54,690
obnoxious CSS animations as well so

00:00:52,829 --> 00:00:58,050
we'll be kind of live coding over there

00:00:54,690 --> 00:00:59,460
with Freddie if you want to join in so

00:00:58,050 --> 00:01:02,430
my name is Pat you come in you can catch

00:00:59,460 --> 00:01:05,280
me on Twitter there and I work at fastly

00:01:02,430 --> 00:01:06,840
we're an edge cloud provider that

00:01:05,280 --> 00:01:09,510
specializes in real-time content

00:01:06,840 --> 00:01:11,369
delivery and my role there is a web

00:01:09,510 --> 00:01:13,320
performance engineer where I spend a lot

00:01:11,369 --> 00:01:15,780
of time thinking about how we can

00:01:13,320 --> 00:01:18,270
improve the speed of one our network but

00:01:15,780 --> 00:01:20,939
most importantly delivering content for

00:01:18,270 --> 00:01:22,799
our customers and their users as fast as

00:01:20,939 --> 00:01:24,090
possible and so some of which of that

00:01:22,799 --> 00:01:25,229
I'm going to talk about today and show

00:01:24,090 --> 00:01:29,159
you some of the research that I've been

00:01:25,229 --> 00:01:31,470
doing so why am I here and you're

00:01:29,159 --> 00:01:33,630
probably wondering what the title CSS

00:01:31,470 --> 00:01:36,030
and the first meaningful paint even

00:01:33,630 --> 00:01:38,790
means and so hopefully all will come

00:01:36,030 --> 00:01:41,610
true shortly so I want to ask you a

00:01:38,790 --> 00:01:44,490
question of how do you measure the

00:01:41,610 --> 00:01:48,090
performance of your website what does

00:01:44,490 --> 00:01:50,280
being fast even mean is it how long it

00:01:48,090 --> 00:01:52,140
takes to get to a load event is it how

00:01:50,280 --> 00:01:55,200
many bytes you send down the wire or how

00:01:52,140 --> 00:01:56,700
many requests but I would say I would

00:01:55,200 --> 00:01:58,500
argue that it shouldn't be any of these

00:01:56,700 --> 00:02:00,899
things ultimately we are building web

00:01:58,500 --> 00:02:03,149
sites for our users or our customers

00:02:00,899 --> 00:02:06,409
users and it should be about how they

00:02:03,149 --> 00:02:09,119
perceive the speed of your website

00:02:06,409 --> 00:02:13,350
should we even have a golden performance

00:02:09,119 --> 00:02:16,400
metric does it even exist I would

00:02:13,350 --> 00:02:19,260
that shouldn't and for years we've been

00:02:16,400 --> 00:02:22,410
optimizing our pages to be built for

00:02:19,260 --> 00:02:24,390
these metrics that don't directly

00:02:22,410 --> 00:02:26,370
correlate to how our websites are built

00:02:24,390 --> 00:02:28,020
but not the user experience and how

00:02:26,370 --> 00:02:30,540
users are perceiving these things so

00:02:28,020 --> 00:02:32,910
time to first byte or document complete

00:02:30,540 --> 00:02:35,220
load event how many requests I sent none

00:02:32,910 --> 00:02:38,100
of these correlates to a good user

00:02:35,220 --> 00:02:39,600
experience and that as I can't stress

00:02:38,100 --> 00:02:42,000
enough at the end of the day we are

00:02:39,600 --> 00:02:44,010
building our websites for real users and

00:02:42,000 --> 00:02:45,840
they are coming here to do something and

00:02:44,010 --> 00:02:48,240
so fortunately we're seeing rise of a

00:02:45,840 --> 00:02:50,400
whole new collection of metrics focused

00:02:48,240 --> 00:02:52,200
around user experience such as the speed

00:02:50,400 --> 00:02:53,400
index and the first meaningful paint

00:02:52,200 --> 00:02:58,020
which we're going to talk about today

00:02:53,400 --> 00:02:58,830
and time to interactivity and we're also

00:02:58,020 --> 00:03:00,780
seeing writer

00:02:58,830 --> 00:03:02,820
being thinking about custom metrics

00:03:00,780 --> 00:03:05,730
specific to our needs maybe for a search

00:03:02,820 --> 00:03:07,350
results on a search pages how long it

00:03:05,730 --> 00:03:08,910
took the user to be able to find what

00:03:07,350 --> 00:03:10,830
they were looking for or a news

00:03:08,910 --> 00:03:12,570
organization is how long it took the

00:03:10,830 --> 00:03:14,370
user to find an article and read it we

00:03:12,570 --> 00:03:16,950
should be thinking more about metrics

00:03:14,370 --> 00:03:20,610
specific to our users needs and not

00:03:16,950 --> 00:03:23,370
focusing on how we delivered that and

00:03:20,610 --> 00:03:25,740
built our technology and so we're going

00:03:23,370 --> 00:03:27,510
to focus a bit on time to first

00:03:25,740 --> 00:03:31,380
meaningful paint today so what does that

00:03:27,510 --> 00:03:33,210
even mean if it simply the first

00:03:31,380 --> 00:03:35,700
meaningful paint is the time when it

00:03:33,210 --> 00:03:36,630
pages primary content appeared on the

00:03:35,700 --> 00:03:38,910
screen ie

00:03:36,630 --> 00:03:41,090
put simply the time when the thing that

00:03:38,910 --> 00:03:43,620
the user actually came to that website

00:03:41,090 --> 00:03:45,540
appeared on the screen more detailed

00:03:43,620 --> 00:03:47,880
it's the first paint after which the

00:03:45,540 --> 00:03:50,400
biggest above the fold so we only care

00:03:47,880 --> 00:03:51,690
about the viewport if you can imagine on

00:03:50,400 --> 00:03:53,970
a mobile screen that's only what

00:03:51,690 --> 00:03:57,240
appeared in the first viewport has

00:03:53,970 --> 00:03:59,040
happened and so layout is when the

00:03:57,240 --> 00:04:01,830
browser converts all of your elements

00:03:59,040 --> 00:04:03,570
and your CSS queries into an X and y

00:04:01,830 --> 00:04:04,770
coordinate are you where that element is

00:04:03,570 --> 00:04:07,050
going to be painted on the screen and

00:04:04,770 --> 00:04:08,730
its width and its height so we have the

00:04:07,050 --> 00:04:10,140
browser has to perform layout of all of

00:04:08,730 --> 00:04:12,660
the elements in that above the world

00:04:10,140 --> 00:04:15,540
view and paint them to the screen and

00:04:12,660 --> 00:04:18,450
most importantly TTS MP also takes into

00:04:15,540 --> 00:04:20,070
consideration when custom web fonts have

00:04:18,450 --> 00:04:22,049
loaded because I've heard that we all

00:04:20,070 --> 00:04:23,669
like to add custom web fonts to our

00:04:22,049 --> 00:04:26,020
websites these days much to my

00:04:23,669 --> 00:04:28,569
discomfort and disagreement but

00:04:26,020 --> 00:04:31,090
maybe this is better represented rigidly

00:04:28,569 --> 00:04:33,550
how does what does TT SMP actually mean

00:04:31,090 --> 00:04:35,470
so T definite be exactly a very new

00:04:33,550 --> 00:04:37,120
metric we've only started using it since

00:04:35,470 --> 00:04:39,520
last year some folks at Google wrote an

00:04:37,120 --> 00:04:41,410
amazing white paper I'll release the

00:04:39,520 --> 00:04:43,810
slides later where they detailed how we

00:04:41,410 --> 00:04:45,610
can go about ascertaining the time to

00:04:43,810 --> 00:04:47,860
first meaningful paint and unfortunately

00:04:45,610 --> 00:04:49,630
it's not exposed via JavaScript API yet

00:04:47,860 --> 00:04:52,270
though we are talking about it and you

00:04:49,630 --> 00:04:54,430
have to be able to use for instance

00:04:52,270 --> 00:04:56,139
clones internal tracing to be able to do

00:04:54,430 --> 00:04:58,900
this but on the top here we have a graph

00:04:56,139 --> 00:05:00,699
that represents how many layout objects

00:04:58,900 --> 00:05:03,250
are actually painted to the screen so

00:05:00,699 --> 00:05:05,409
that's time on the x-axis and the amount

00:05:03,250 --> 00:05:07,330
of objects on the y-axis and how that

00:05:05,409 --> 00:05:09,130
correlates to the user experience below

00:05:07,330 --> 00:05:10,750
and as you can see here Google do

00:05:09,130 --> 00:05:13,479
something very clever that they flush

00:05:10,750 --> 00:05:15,849
the head of their document way before

00:05:13,479 --> 00:05:18,370
they even send the search queries back

00:05:15,849 --> 00:05:20,530
to the database and so it paints very

00:05:18,370 --> 00:05:22,419
quickly on a 3G and emerging marketing

00:05:20,530 --> 00:05:24,909
network you've got a paint at 1.5

00:05:22,419 --> 00:05:26,530
seconds but actually the meaningful

00:05:24,909 --> 00:05:29,919
paints the thing that the user actually

00:05:26,530 --> 00:05:31,479
came here for is at 1.9 and we can see

00:05:29,919 --> 00:05:32,710
how that directly correlates to the

00:05:31,479 --> 00:05:35,139
amount of objects that painted the

00:05:32,710 --> 00:05:36,729
screen and hopefully you've now got a

00:05:35,139 --> 00:05:38,650
much better indication of this ISM a

00:05:36,729 --> 00:05:41,650
metric that's much more useful than

00:05:38,650 --> 00:05:43,870
start render or your time to person time

00:05:41,650 --> 00:05:45,490
to first byte because we've given the

00:05:43,870 --> 00:05:47,020
user what they came here for and this is

00:05:45,490 --> 00:05:48,550
the type of metric that we should be

00:05:47,020 --> 00:05:51,300
focusing on and talking about and

00:05:48,550 --> 00:05:54,159
building and trying to optimize for and

00:05:51,300 --> 00:05:55,780
maybe this is a better representative

00:05:54,159 --> 00:05:58,960
like this so this is the SD comm

00:05:55,780 --> 00:06:00,909
homepage and who here thinks the time to

00:05:58,960 --> 00:06:08,020
first meaningful paint is three point

00:06:00,909 --> 00:06:09,870
five four five four point five five so

00:06:08,020 --> 00:06:13,330
yeah the TTS MP here is actually five

00:06:09,870 --> 00:06:14,530
seconds on a 3G connection so you're

00:06:13,330 --> 00:06:16,840
probably wondering how you can measure

00:06:14,530 --> 00:06:18,819
your TT FMP yourselves fortunately

00:06:16,840 --> 00:06:20,590
Google have open sourced and built you

00:06:18,819 --> 00:06:21,789
can contribute to this lighthouse which

00:06:20,590 --> 00:06:24,310
is they actually built this tool is

00:06:21,789 --> 00:06:26,289
there an auditing tool to audit how your

00:06:24,310 --> 00:06:27,490
new progressive shiny web app was

00:06:26,289 --> 00:06:29,590
performing against some of the best

00:06:27,490 --> 00:06:31,690
practices but it turns out that some of

00:06:29,590 --> 00:06:33,789
the audits in it are actually very good

00:06:31,690 --> 00:06:35,260
just for any web site you don't have to

00:06:33,789 --> 00:06:36,699
use service workers or progressive web

00:06:35,260 --> 00:06:38,560
apps to use lighthouse to audit your

00:06:36,699 --> 00:06:39,520
tool and using a lot of hosts you can

00:06:38,560 --> 00:06:41,740
install it via

00:06:39,520 --> 00:06:43,660
a browser plug-in or CLI and have it

00:06:41,740 --> 00:06:47,350
part of your build process you can

00:06:43,660 --> 00:06:49,120
expose the TT FNP of your own websites I

00:06:47,350 --> 00:06:51,520
urge you to go home in and check this

00:06:49,120 --> 00:06:53,410
out and try it out on your own so let's

00:06:51,520 --> 00:06:57,220
dive straight in of how we can optimize

00:06:53,410 --> 00:07:00,099
our own websites for that TT FMP metric

00:06:57,220 --> 00:07:02,349
and how this relates and it's extremely

00:07:00,099 --> 00:07:05,979
tightly coupled to CSS and obviously

00:07:02,349 --> 00:07:08,380
this is CSS comps but it's unsurprising

00:07:05,979 --> 00:07:11,259
hopefully to most of you that CSS is so

00:07:08,380 --> 00:07:13,389
critical to how we deliver a good user

00:07:11,259 --> 00:07:14,919
experience to our users and so we're

00:07:13,389 --> 00:07:17,919
going to look at past present and future

00:07:14,919 --> 00:07:19,930
best practices for how we deliver CSS

00:07:17,919 --> 00:07:20,380
and the assets that are related to it in

00:07:19,930 --> 00:07:21,940
the browser

00:07:20,380 --> 00:07:24,639
and hopefully you'll be able to apply

00:07:21,940 --> 00:07:27,250
some of these methodologies at home now

00:07:24,639 --> 00:07:31,060
to do this it's very easy to create a

00:07:27,250 --> 00:07:32,020
test case study using a to do MVC app

00:07:31,060 --> 00:07:34,659
sorry

00:07:32,020 --> 00:07:39,550
addy if you're in the room but it's much

00:07:34,659 --> 00:07:41,229
better I find to show we'll use real

00:07:39,550 --> 00:07:43,389
websites to optimize for because

00:07:41,229 --> 00:07:46,060
ultimately we are again all building

00:07:43,389 --> 00:07:47,949
real websites and not just to do MVC app

00:07:46,060 --> 00:07:51,460
they're delivered in two files and we

00:07:47,949 --> 00:07:53,380
decide to throw a metric crap kind of

00:07:51,460 --> 00:07:55,780
JavaScript down the pipe at the same

00:07:53,380 --> 00:07:57,909
time and this is using real-world

00:07:55,780 --> 00:07:59,620
conditions is when we can really see how

00:07:57,909 --> 00:08:00,820
the optimizations have effects so

00:07:59,620 --> 00:08:02,949
therefore for the purpose of the talk

00:08:00,820 --> 00:08:04,690
and the research I'm going to use the FT

00:08:02,949 --> 00:08:07,090
com home page and we're going to apply

00:08:04,690 --> 00:08:08,469
some optimizations together to it to see

00:08:07,090 --> 00:08:10,180
how we can improve the times first

00:08:08,469 --> 00:08:12,219
meaningful paint so just a disclaimer

00:08:10,180 --> 00:08:13,900
here I used to work for the Financial

00:08:12,219 --> 00:08:16,539
Times so I chose it that because I know

00:08:13,900 --> 00:08:18,460
how the page is built and they've given

00:08:16,539 --> 00:08:20,050
me permission to do this and in fact I

00:08:18,460 --> 00:08:24,340
think some of these developers are still

00:08:20,050 --> 00:08:26,259
who still wet they're in the rim and but

00:08:24,340 --> 00:08:28,539
you know it is actually a very good fast

00:08:26,259 --> 00:08:29,740
website but it we can probably improve

00:08:28,539 --> 00:08:31,719
it and that's what going to try and do

00:08:29,740 --> 00:08:33,700
and so for each optimization we're going

00:08:31,719 --> 00:08:35,289
to be testing on a real device and I

00:08:33,700 --> 00:08:37,779
can't stress this enough and to do this

00:08:35,289 --> 00:08:39,250
we're going to use web page test if you

00:08:37,779 --> 00:08:41,020
haven't used web page test before I urge

00:08:39,250 --> 00:08:44,079
you to go and do it is the number one

00:08:41,020 --> 00:08:45,579
tool box in my arsenal of tools because

00:08:44,079 --> 00:08:47,949
it allows me one to test on real devices

00:08:45,579 --> 00:08:50,350
there is a real moto G sitting at the

00:08:47,949 --> 00:08:52,870
end of this form and allows me to shape

00:08:50,350 --> 00:08:54,610
to a real network condition that

00:08:52,870 --> 00:08:58,029
again we are building websites for real

00:08:54,610 --> 00:09:00,310
users okay it contrary to popular belief

00:08:58,029 --> 00:09:03,400
the shiny iPhone that you have in your

00:09:00,310 --> 00:09:05,589
pocket is not a real-world device and

00:09:03,400 --> 00:09:08,200
actually the average device globally is

00:09:05,589 --> 00:09:10,690
a low to mid n speck Android that has a

00:09:08,200 --> 00:09:13,420
very terrible CPU performance and very

00:09:10,690 --> 00:09:14,950
low memory so webpagetest allows us to

00:09:13,420 --> 00:09:16,930
actually test on these physical devices

00:09:14,950 --> 00:09:19,210
for each test we're going to run nine

00:09:16,930 --> 00:09:20,860
tests and choose the median result of

00:09:19,210 --> 00:09:22,600
them and we're going to use three

00:09:20,860 --> 00:09:25,270
Network conditions which I'll chat about

00:09:22,600 --> 00:09:27,700
later my friend Ben is actually going to

00:09:25,270 --> 00:09:30,190
be talking about this kind of data of

00:09:27,700 --> 00:09:32,380
real-world devices and what is the real

00:09:30,190 --> 00:09:35,410
network at J's comp this weekend so I

00:09:32,380 --> 00:09:36,880
urge you to go and look at his talk so

00:09:35,410 --> 00:09:39,160
we need to ask ourselves these questions

00:09:36,880 --> 00:09:41,620
first of to be working out what our

00:09:39,160 --> 00:09:44,350
average user profile is where are your

00:09:41,620 --> 00:09:47,350
users based what is their device

00:09:44,350 --> 00:09:49,630
landscape in what context are they using

00:09:47,350 --> 00:09:51,760
your website and I would be very

00:09:49,630 --> 00:09:53,650
surprised if you can one of you can tell

00:09:51,760 --> 00:09:55,240
me that you have a single context for

00:09:53,650 --> 00:09:57,339
your users because that that just

00:09:55,240 --> 00:10:00,430
doesn't exist the same person might be

00:09:57,339 --> 00:10:02,890
accessing your website on a flaky mobile

00:10:00,430 --> 00:10:04,959
connection in the morning and then goes

00:10:02,890 --> 00:10:07,690
at lunch time to use that same website

00:10:04,959 --> 00:10:09,670
on their fast a iMac with their fast

00:10:07,690 --> 00:10:12,130
cable connection there is not this

00:10:09,670 --> 00:10:14,950
single context what is their network

00:10:12,130 --> 00:10:16,510
profile and what did specifically did

00:10:14,950 --> 00:10:18,430
they come here for and that's what you

00:10:16,510 --> 00:10:20,230
should be optimizing for so for the

00:10:18,430 --> 00:10:22,029
purpose of the test we're going to be

00:10:20,230 --> 00:10:24,430
trying to deliver a first meaningful

00:10:22,029 --> 00:10:26,440
paint in three seconds on a emerging

00:10:24,430 --> 00:10:28,360
market network which has a 400

00:10:26,440 --> 00:10:29,680
millisecond round-trip time so that's

00:10:28,360 --> 00:10:31,540
the time a textual request to go from

00:10:29,680 --> 00:10:34,720
the client to the server and back again

00:10:31,540 --> 00:10:35,800
400 milliseconds just on an emerging

00:10:34,720 --> 00:10:37,029
marketing connection and we're going to

00:10:35,800 --> 00:10:39,370
try and optimize for a thousand

00:10:37,029 --> 00:10:41,080
milliseconds on cable but I can't stress

00:10:39,370 --> 00:10:43,540
this enough that you shouldn't be taking

00:10:41,080 --> 00:10:44,440
my base lines as well at home on what

00:10:43,540 --> 00:10:47,200
you should be using you should be

00:10:44,440 --> 00:10:54,520
thinking about what your user profile is

00:10:47,200 --> 00:10:57,279
and setting budgets for those and so

00:10:54,520 --> 00:10:59,800
that we can measure the impact of our

00:10:57,279 --> 00:11:02,680
tests and optimizations we can set a

00:10:59,800 --> 00:11:04,240
baseline and so this hopefully will look

00:11:02,680 --> 00:11:06,010
very familiar to all of you this is a

00:11:04,240 --> 00:11:07,270
hex ml document that

00:11:06,010 --> 00:11:10,240
right near the top we have a link

00:11:07,270 --> 00:11:12,940
element referencing our compiled main

00:11:10,240 --> 00:11:14,770
CSS file I don't care how that was

00:11:12,940 --> 00:11:17,440
compiled or if it was offered in DES

00:11:14,770 --> 00:11:19,270
or whatever as long as you're delivering

00:11:17,440 --> 00:11:21,130
your CSS like this this is probably how

00:11:19,270 --> 00:11:24,790
we have been delivering CSS since the

00:11:21,130 --> 00:11:26,230
birth of cascading style sheets is

00:11:24,790 --> 00:11:28,300
probably how most of you in the room are

00:11:26,230 --> 00:11:30,100
still delivering your CSS so if we were

00:11:28,300 --> 00:11:33,160
to run that in web page test this is the

00:11:30,100 --> 00:11:34,870
waterfall result we've got so hands up

00:11:33,160 --> 00:11:37,420
if you use have seen Network waterfalls

00:11:34,870 --> 00:11:39,190
before use them on daily basis awesome

00:11:37,420 --> 00:11:42,400
so it doesn't matter if you haven't so

00:11:39,190 --> 00:11:45,700
say the wire the x axis here is time and

00:11:42,400 --> 00:11:47,380
the y axis axis is the network request

00:11:45,700 --> 00:11:48,700
that the browser is making and the

00:11:47,380 --> 00:11:51,220
priority and the order in which that

00:11:48,700 --> 00:11:53,260
happened web page test fortunately gives

00:11:51,220 --> 00:11:56,110
us mine types here so we've got pixels

00:11:53,260 --> 00:11:58,870
blue CSS is green images of purple

00:11:56,110 --> 00:12:00,400
javascript is orange and fonts are red

00:11:58,870 --> 00:12:02,890
and for each one of these segments

00:12:00,400 --> 00:12:05,470
there's two shades of color that when

00:12:02,890 --> 00:12:06,970
that we have resent the request and then

00:12:05,470 --> 00:12:10,120
the waiting period and then the download

00:12:06,970 --> 00:12:12,460
process and how long it took so here we

00:12:10,120 --> 00:12:14,470
can see that we requested our HTML file

00:12:12,460 --> 00:12:16,810
it found the link element because it

00:12:14,470 --> 00:12:18,550
paused the document incrementally that's

00:12:16,810 --> 00:12:20,560
great thing about HTML spec is it can be

00:12:18,550 --> 00:12:23,320
pausing clementa ly it found the link

00:12:20,560 --> 00:12:25,480
element quite soon during their download

00:12:23,320 --> 00:12:27,820
of the HTML and triggered request and

00:12:25,480 --> 00:12:29,380
then the green line here is our start

00:12:27,820 --> 00:12:31,150
render so that's not our x first

00:12:29,380 --> 00:12:32,620
meaningful paint but that's when we

00:12:31,150 --> 00:12:35,050
started painting on a free G

00:12:32,620 --> 00:12:38,260
emerging-market so that gives us a

00:12:35,050 --> 00:12:42,420
baseline around 8,000 milliseconds

00:12:38,260 --> 00:12:45,850
TTFN p on 3g in emerging market and

00:12:42,420 --> 00:12:48,610
around 2000 fur cable - way out of our

00:12:45,850 --> 00:12:49,930
budget so now we've set a baseline so

00:12:48,610 --> 00:12:53,170
the first experiment we want to do is we

00:12:49,930 --> 00:12:54,370
want to inline our critical CSS and

00:12:53,170 --> 00:12:56,230
hopefully many of you heard this

00:12:54,370 --> 00:12:58,510
technique this is what I you came to

00:12:56,230 --> 00:13:00,610
this very stage to talk about in 2014

00:12:58,510 --> 00:13:02,980
and in since then it's become quite a

00:13:00,610 --> 00:13:05,530
common practice and so let's have a

00:13:02,980 --> 00:13:06,880
quick recap of that the first thing we

00:13:05,530 --> 00:13:10,090
need to do is we have to look at our

00:13:06,880 --> 00:13:12,400
critical rendering path of our page this

00:13:10,090 --> 00:13:14,830
is the single path that a browser must

00:13:12,400 --> 00:13:17,800
do to be all the steps it has to do

00:13:14,830 --> 00:13:19,000
before it can paint to a screen so first

00:13:17,800 --> 00:13:21,340
we have to

00:13:19,000 --> 00:13:23,710
I'm make the get HTTP request of our

00:13:21,340 --> 00:13:25,270
index file we get the response to that

00:13:23,710 --> 00:13:26,950
we can start building the document

00:13:25,270 --> 00:13:28,600
object model this is the Dom that we

00:13:26,950 --> 00:13:30,970
will interact with in JavaScript which

00:13:28,600 --> 00:13:33,010
is a tree like structure representing

00:13:30,970 --> 00:13:35,050
the parent-child relationship so I have

00:13:33,010 --> 00:13:38,260
a body tag inside that has a div which

00:13:35,050 --> 00:13:40,810
has a key which has a span and we pass

00:13:38,260 --> 00:13:43,330
we can construct the Dom as we parse the

00:13:40,810 --> 00:13:45,610
HTML incrementally so we don't need to

00:13:43,330 --> 00:13:47,320
wait for all of the bytes of our HTML

00:13:45,610 --> 00:13:50,020
file to be downloaded before we can

00:13:47,320 --> 00:13:52,420
construct the Dom which is an often

00:13:50,020 --> 00:13:54,760
overlooked but amazing feature of the

00:13:52,420 --> 00:13:56,770
HTML specification we find the link

00:13:54,760 --> 00:13:59,590
elements we then have to go and stop

00:13:56,770 --> 00:14:01,590
constructing our Dom because CSS is

00:13:59,590 --> 00:14:03,820
known as a render blocking resource and

00:14:01,590 --> 00:14:06,430
we have to go and perform the networking

00:14:03,820 --> 00:14:08,170
for that get that and then we can

00:14:06,430 --> 00:14:11,140
construct our CSS object model which is

00:14:08,170 --> 00:14:13,870
exactly the same as the Dom and but note

00:14:11,140 --> 00:14:16,330
the idle time here we've wasted a lot of

00:14:13,870 --> 00:14:19,690
time on our network connection waiting

00:14:16,330 --> 00:14:22,180
for that CSS file and also note the fact

00:14:19,690 --> 00:14:23,950
that imagine if I was on a train I was

00:14:22,180 --> 00:14:26,920
looking at Twitter I clicked on the link

00:14:23,950 --> 00:14:29,800
to the FT I downloaded the HTML and then

00:14:26,920 --> 00:14:31,839
I go into a tunnel and so I have no

00:14:29,800 --> 00:14:33,400
network and now I don't have enough

00:14:31,839 --> 00:14:35,589
network to perform that CSS but actually

00:14:33,400 --> 00:14:37,120
I've got all of the content I could just

00:14:35,589 --> 00:14:38,620
paint to the screen so what we've

00:14:37,120 --> 00:14:40,720
actually done here is we've created a

00:14:38,620 --> 00:14:43,870
single point of failure by delivering

00:14:40,720 --> 00:14:45,730
our CSS as a separate object whereas we

00:14:43,870 --> 00:14:48,550
do have all of the information so that

00:14:45,730 --> 00:14:52,270
the theory here is what if we were to

00:14:48,550 --> 00:14:54,370
inline the critical CSS just required to

00:14:52,270 --> 00:14:56,170
render that first viewport the one that

00:14:54,370 --> 00:14:59,850
we care about for our first meaningful

00:14:56,170 --> 00:15:02,200
paint into the head of our document then

00:14:59,850 --> 00:15:03,850
declare the rest of it as I synchronous

00:15:02,200 --> 00:15:05,980
telling rather I don't care about this

00:15:03,850 --> 00:15:08,260
for the first paint and so now we have

00:15:05,980 --> 00:15:10,390
all of the information we need probably

00:15:08,260 --> 00:15:12,190
within the first round trip of a network

00:15:10,390 --> 00:15:15,150
connection so then we can construct the

00:15:12,190 --> 00:15:17,500
render tree and render to the page so

00:15:15,150 --> 00:15:19,570
going back to our experiment this is now

00:15:17,500 --> 00:15:21,250
what it looks like we now have a Spile

00:15:19,570 --> 00:15:22,360
element in the head of our document this

00:15:21,250 --> 00:15:24,520
moves against everything we've been

00:15:22,360 --> 00:15:27,580
taught about separation of concerns of

00:15:24,520 --> 00:15:29,740
styles in our scholar sheets behavior in

00:15:27,580 --> 00:15:31,480
our java scripts and then we're using a

00:15:29,740 --> 00:15:32,650
new friend the link preload

00:15:31,480 --> 00:15:34,810
element which we can talk about later

00:15:32,650 --> 00:15:36,400
and here I'm using the filament groups

00:15:34,810 --> 00:15:38,590
load CSS function to do this I think

00:15:36,400 --> 00:15:40,390
this is for me that the best way about

00:15:38,590 --> 00:15:42,430
doing this at the moment and it's got a

00:15:40,390 --> 00:15:45,820
little polyfill for browsers that don't

00:15:42,430 --> 00:15:47,530
support this so what if we were to run

00:15:45,820 --> 00:15:49,360
this in web page there so let's recap

00:15:47,530 --> 00:15:53,740
this as our baseline remember we're the

00:15:49,360 --> 00:15:56,890
start render line is there and now with

00:15:53,740 --> 00:15:59,020
in line look we've instantly got

00:15:56,890 --> 00:16:00,820
painting as soon as we've started to

00:15:59,020 --> 00:16:02,980
parse the HTML document we no longer

00:16:00,820 --> 00:16:05,620
have to wait for our CSS because we've

00:16:02,980 --> 00:16:07,090
declared that as asynchronous and so you

00:16:05,620 --> 00:16:09,610
can imagine this is going to have a very

00:16:07,090 --> 00:16:14,440
dramatic effect on our times first

00:16:09,610 --> 00:16:17,080
meaningful paint metric and so here you

00:16:14,440 --> 00:16:19,990
can see we now have a 63% improvement on

00:16:17,080 --> 00:16:21,430
our baseline we've got 1300 millisecond

00:16:19,990 --> 00:16:24,430
times first meaningful paint on cable

00:16:21,430 --> 00:16:26,080
and 3200 so we basically have dit which

00:16:24,430 --> 00:16:29,800
is extremely impressive just using one

00:16:26,080 --> 00:16:31,780
technique but this comes with some pros

00:16:29,800 --> 00:16:33,790
and cons we now no longer have that

00:16:31,780 --> 00:16:37,540
single point of failure we've eliminated

00:16:33,790 --> 00:16:38,680
all of the blocking resources but the

00:16:37,540 --> 00:16:40,300
eagle-eyed in the room would notice that

00:16:38,680 --> 00:16:42,760
probably because we've declared our

00:16:40,300 --> 00:16:44,590
other CSS as asynchronous that still has

00:16:42,760 --> 00:16:47,110
to be loaded and we still have to apply

00:16:44,590 --> 00:16:49,420
it to to be able to paint to the dom so

00:16:47,110 --> 00:16:51,090
it causes a reflow and that's why it's

00:16:49,420 --> 00:16:54,100
really really important that you

00:16:51,090 --> 00:16:55,570
separate your truly critical everything

00:16:54,100 --> 00:16:57,850
in that first viewport from the non

00:16:55,570 --> 00:16:59,410
because if you were to have stuff that

00:16:57,850 --> 00:17:00,610
within the top of the viewport inside

00:16:59,410 --> 00:17:02,650
your known asynchronous stuff you're

00:17:00,610 --> 00:17:05,110
going to cause reflow and actually have

00:17:02,650 --> 00:17:06,340
a jarring user experience the most

00:17:05,110 --> 00:17:08,500
important point to note here though is

00:17:06,340 --> 00:17:10,960
we've made it not too cacheable by

00:17:08,500 --> 00:17:13,360
aligning our CSS into the document every

00:17:10,960 --> 00:17:14,920
time we change that CSS we're

00:17:13,360 --> 00:17:16,930
essentially invalidating the cache for

00:17:14,920 --> 00:17:19,150
all of our HTML files so if you can

00:17:16,930 --> 00:17:20,770
imagine something like the FT com

00:17:19,150 --> 00:17:22,270
that's a very large cache that we're

00:17:20,770 --> 00:17:24,760
going to be in validating every time we

00:17:22,270 --> 00:17:27,460
change some CSS and we don't benefit

00:17:24,760 --> 00:17:28,690
from the browser caching that object and

00:17:27,460 --> 00:17:30,970
then we're actually going to be sending

00:17:28,690 --> 00:17:32,980
more bytes down the wire every time

00:17:30,970 --> 00:17:35,320
which is completely unnecessary

00:17:32,980 --> 00:17:38,590
it's also very hard to maintain a very

00:17:35,320 --> 00:17:40,930
hard to automate inline CSS and I've

00:17:38,590 --> 00:17:43,810
worked on some very large scale websites

00:17:40,930 --> 00:17:44,750
and it's become a pain that we there's

00:17:43,810 --> 00:17:48,920
no optimal

00:17:44,750 --> 00:17:51,740
way of doing this so we've been able to

00:17:48,920 --> 00:17:54,320
get our CSS down as soon as possible but

00:17:51,740 --> 00:17:56,150
how can we then prioritize the delivery

00:17:54,320 --> 00:17:58,850
of the other sub resources that our CSS

00:17:56,150 --> 00:18:01,270
requires to achieve that time - first

00:17:58,850 --> 00:18:03,620
meaningful paint I use the critical

00:18:01,270 --> 00:18:05,780
resources for our page so I want to ask

00:18:03,620 --> 00:18:08,480
you a question of can you think about

00:18:05,780 --> 00:18:09,770
what are the critical resources that you

00:18:08,480 --> 00:18:11,540
have on the website that you were

00:18:09,770 --> 00:18:14,270
building yesterday or today even for

00:18:11,540 --> 00:18:15,740
your customer or your company can you

00:18:14,270 --> 00:18:17,780
think about those right now top of your

00:18:15,740 --> 00:18:20,810
head the resources that if the networks

00:18:17,780 --> 00:18:22,670
failed I only need these one two or

00:18:20,810 --> 00:18:24,410
three resources to be able to deliver a

00:18:22,670 --> 00:18:26,660
good user experience the rest of them

00:18:24,410 --> 00:18:28,700
that adds code for the JavaScript that

00:18:26,660 --> 00:18:31,010
can all be left behind have a think

00:18:28,700 --> 00:18:32,780
about that so let's identify the

00:18:31,010 --> 00:18:37,670
resources together for the ft.com page

00:18:32,780 --> 00:18:40,010
is it a logo is it the custom web fonts

00:18:37,670 --> 00:18:41,270
and we know that TTS MP has to use the

00:18:40,010 --> 00:18:43,520
custom web fonts and actually we're

00:18:41,270 --> 00:18:45,650
delivering the news the user needs to be

00:18:43,520 --> 00:18:48,500
able to read it or is it the hero image

00:18:45,650 --> 00:18:51,710
to give some context and a very sorry

00:18:48,500 --> 00:18:53,210
here for the Theresa May photo bomb I'm

00:18:51,710 --> 00:18:55,490
actually really annoyed with myself but

00:18:53,210 --> 00:18:57,490
I've included her in this ditch doesn't

00:18:55,490 --> 00:19:00,560
deserve it

00:18:57,490 --> 00:19:02,300
so what how can we go about automating

00:19:00,560 --> 00:19:04,850
the process of choosing these critical

00:19:02,300 --> 00:19:07,250
resources fortunately again lighthouse

00:19:04,850 --> 00:19:08,510
has got our back and they do this with

00:19:07,250 --> 00:19:11,600
an audit that they call the critical

00:19:08,510 --> 00:19:12,590
request change so here running ft.com

00:19:11,600 --> 00:19:15,470
for lighthouse

00:19:12,590 --> 00:19:17,570
we've identified a critical question of

00:19:15,470 --> 00:19:18,920
five resources so you can do this even

00:19:17,570 --> 00:19:20,720
though I just asked you to do that in

00:19:18,920 --> 00:19:22,220
your head work out what your critical

00:19:20,720 --> 00:19:25,130
resources are you can automate this

00:19:22,220 --> 00:19:26,960
process and if I was to you were to take

00:19:25,130 --> 00:19:31,730
away one thing from this talk today

00:19:26,960 --> 00:19:33,650
please let it be this that you need to

00:19:31,730 --> 00:19:36,530
be able to be optimizing this critical

00:19:33,650 --> 00:19:38,810
request path eliminate every asset that

00:19:36,530 --> 00:19:40,640
is in it that is not critical to the

00:19:38,810 --> 00:19:43,400
core user experience of your website and

00:19:40,640 --> 00:19:45,740
then optimize the remaining ones make

00:19:43,400 --> 00:19:48,380
them as small as possible and prioritize

00:19:45,740 --> 00:19:50,660
the delivery of those assets over the

00:19:48,380 --> 00:19:52,580
network and that is how you will achieve

00:19:50,660 --> 00:19:56,450
a very fast time to first meaningful

00:19:52,580 --> 00:19:58,530
paint with your CSS so if we remember

00:19:56,450 --> 00:20:00,090
the methodology for

00:19:58,530 --> 00:20:03,450
meaning the times first meaningful paint

00:20:00,090 --> 00:20:06,480
we also block on our metric waiting for

00:20:03,450 --> 00:20:08,850
web fonts because they are delivering

00:20:06,480 --> 00:20:11,610
the user experience after all and so

00:20:08,850 --> 00:20:15,090
look how low down in our waterfall our

00:20:11,610 --> 00:20:16,860
web font delivery is much much lower

00:20:15,090 --> 00:20:20,610
than the CSS it's around the 20th

00:20:16,860 --> 00:20:23,010
request now why is this if there's such

00:20:20,610 --> 00:20:25,410
an important critical resource why is

00:20:23,010 --> 00:20:27,690
the breyer browser prioritizing that

00:20:25,410 --> 00:20:30,660
network request so low compared to some

00:20:27,690 --> 00:20:33,240
of our imagery answer to do this we need

00:20:30,660 --> 00:20:34,410
to take a look back at how browsers know

00:20:33,240 --> 00:20:37,110
about painting again

00:20:34,410 --> 00:20:39,990
first the browser discovers the H then

00:20:37,110 --> 00:20:42,930
makes a network request for the HTML

00:20:39,990 --> 00:20:47,160
document it begins pausing that document

00:20:42,930 --> 00:20:48,600
it finds there discovers the CSS maybe

00:20:47,160 --> 00:20:52,380
some JavaScript if you haven't declared

00:20:48,600 --> 00:20:54,360
it as asynchronous then we have to CSS

00:20:52,380 --> 00:20:56,670
can't unlike HTML can't be paused

00:20:54,360 --> 00:20:59,790
incrementally ie we have to wait for all

00:20:56,670 --> 00:21:01,560
of the bytes of CSS to come in before we

00:20:59,790 --> 00:21:02,610
can construct the CSS object model and

00:21:01,560 --> 00:21:04,710
there's a very good reason for this

00:21:02,610 --> 00:21:06,510
because of the nature of the Cascade in

00:21:04,710 --> 00:21:08,670
cascading style sheets that you might

00:21:06,510 --> 00:21:09,870
have a style declaration down the bottom

00:21:08,670 --> 00:21:11,760
of your file that is overwritten

00:21:09,870 --> 00:21:13,020
something at the top and if we were to

00:21:11,760 --> 00:21:15,210
part it incrementally and pink

00:21:13,020 --> 00:21:17,190
incorrectly you might probably have some

00:21:15,210 --> 00:21:19,470
stuff moving around so it's a very good

00:21:17,190 --> 00:21:21,240
reason that CSS can't be parsley

00:21:19,470 --> 00:21:22,830
incrementally you have to wait we can

00:21:21,240 --> 00:21:25,830
get the CSS object model and these two

00:21:22,830 --> 00:21:28,140
trees are joined together to form the

00:21:25,830 --> 00:21:30,780
render tree and so it's exactly like the

00:21:28,140 --> 00:21:32,520
Dom but it only contains the elements

00:21:30,780 --> 00:21:34,140
that are going to be displayed on the

00:21:32,520 --> 00:21:35,970
screen because you might have other

00:21:34,140 --> 00:21:37,980
elements in your Dom that you've done

00:21:35,970 --> 00:21:39,750
display:none on you've hidden them so

00:21:37,980 --> 00:21:41,970
why does the browser need to try and

00:21:39,750 --> 00:21:44,820
compute the layouts objects for those

00:21:41,970 --> 00:21:46,680
when it's not going to paint them so the

00:21:44,820 --> 00:21:48,540
render tree is actually what is used to

00:21:46,680 --> 00:21:50,580
rasterize the page and send it and it's

00:21:48,540 --> 00:21:52,680
only at this point why have I even gone

00:21:50,580 --> 00:21:55,050
them on this own digression to tell you

00:21:52,680 --> 00:21:58,200
this because it's only at this point

00:21:55,050 --> 00:22:00,720
that the font files are found and the

00:21:58,200 --> 00:22:03,270
networking for them is sense and that's

00:22:00,720 --> 00:22:05,580
because you may have a whole block a

00:22:03,270 --> 00:22:07,470
whole paragraph of text that have a font

00:22:05,580 --> 00:22:09,240
that you've declared but you've

00:22:07,470 --> 00:22:10,710
displayed none on that why should we go

00:22:09,240 --> 00:22:12,540
and perform the networking for that

00:22:10,710 --> 00:22:15,030
variant files by their pure nature

00:22:12,540 --> 00:22:17,190
very expensive they sometimes megabytes

00:22:15,030 --> 00:22:18,810
in size why should the browser perform

00:22:17,190 --> 00:22:20,460
the networking for them if we're not

00:22:18,810 --> 00:22:22,650
going to display them and so it's this

00:22:20,460 --> 00:22:25,500
reason that the browser doesn't perform

00:22:22,650 --> 00:22:27,210
networking for front until the render

00:22:25,500 --> 00:22:29,400
tree is constructed but you'll notice

00:22:27,210 --> 00:22:31,980
here though we've wasted an extremely

00:22:29,400 --> 00:22:35,760
large amount of time waiting for that

00:22:31,980 --> 00:22:38,340
period so what if we were able to hint

00:22:35,760 --> 00:22:40,110
to the browser these are my critical

00:22:38,340 --> 00:22:41,820
resources you're not going to find them

00:22:40,110 --> 00:22:44,160
for ages because they are hidden sub

00:22:41,820 --> 00:22:46,920
resource with inside the render tree but

00:22:44,160 --> 00:22:49,310
I know as the author they are extremely

00:22:46,920 --> 00:22:51,900
important so if you imagine the five

00:22:49,310 --> 00:22:53,850
resources that lighthouse identified for

00:22:51,900 --> 00:22:54,930
ft.com they're the things that we should

00:22:53,850 --> 00:22:56,970
be hinting to the browser and so

00:22:54,930 --> 00:22:58,950
fortunately the web performance working

00:22:56,970 --> 00:23:02,010
group have defined a new API called

00:22:58,950 --> 00:23:03,690
preload which allows us as the authors

00:23:02,010 --> 00:23:06,960
of the page to indicate to the browser

00:23:03,690 --> 00:23:08,820
the critical or safe hidden resources so

00:23:06,960 --> 00:23:11,250
it can then prioritize a networking for

00:23:08,820 --> 00:23:14,190
them so to put simply it provides a

00:23:11,250 --> 00:23:16,560
derrick declarative fetch primitive that

00:23:14,190 --> 00:23:19,170
initiates an early fetch this is the

00:23:16,560 --> 00:23:21,810
most important bit separating fetch from

00:23:19,170 --> 00:23:24,150
resource execution so I can now say go

00:23:21,810 --> 00:23:25,350
and download this javascript file but

00:23:24,150 --> 00:23:26,760
don't execute it because that would

00:23:25,350 --> 00:23:28,800
probably be bad but perform the

00:23:26,760 --> 00:23:31,170
networking for it because it's extremely

00:23:28,800 --> 00:23:33,690
important delivery of my good user

00:23:31,170 --> 00:23:36,900
experience so this is what it looks like

00:23:33,690 --> 00:23:38,910
we now have three new primitives in HTML

00:23:36,900 --> 00:23:41,880
at the top via the link element with a

00:23:38,910 --> 00:23:43,320
rel preload attribute I think this is

00:23:41,880 --> 00:23:44,790
extremely powerful we can do it

00:23:43,320 --> 00:23:46,980
dynamically with JavaScript so you can

00:23:44,790 --> 00:23:49,590
imagine if a user is hovering over a

00:23:46,980 --> 00:23:52,080
button to open up a carousel with images

00:23:49,590 --> 00:23:54,360
at that point as they hover you can

00:23:52,080 --> 00:23:56,460
inject link preload elements to preload

00:23:54,360 --> 00:23:57,420
all of the images so when they do click

00:23:56,460 --> 00:23:59,700
on it you're going to have a

00:23:57,420 --> 00:24:02,220
lightning-fast experience and finally my

00:23:59,700 --> 00:24:04,710
favorite which is the preload link

00:24:02,220 --> 00:24:08,910
header that often forgotten HTTP header

00:24:04,710 --> 00:24:11,400
we can declare link elements essentially

00:24:08,910 --> 00:24:13,980
but as headers so here with a HTTP

00:24:11,400 --> 00:24:16,800
header on the response of our HTML file

00:24:13,980 --> 00:24:18,780
we're telling the browser that go and

00:24:16,800 --> 00:24:21,930
preload this CSS file is extremely

00:24:18,780 --> 00:24:24,240
important and so going back to our

00:24:21,930 --> 00:24:26,530
experiment on ftom we identified those

00:24:24,240 --> 00:24:28,720
five resources so we're now going to set

00:24:26,530 --> 00:24:31,180
the link preload header on the response

00:24:28,720 --> 00:24:32,580
of the HTML and hit note here there's

00:24:31,180 --> 00:24:34,990
two interesting points to note here that

00:24:32,580 --> 00:24:37,170
fonts have to be declared as cross

00:24:34,990 --> 00:24:40,420
origin even if they're on the same

00:24:37,170 --> 00:24:43,120
origin or hosts because some genius

00:24:40,420 --> 00:24:44,950
person many years ago deemed that all

00:24:43,120 --> 00:24:46,720
fonts should be treated as crossed

00:24:44,950 --> 00:24:48,970
origin for security purposes and the

00:24:46,720 --> 00:24:50,440
important thing is the no push attribute

00:24:48,970 --> 00:24:53,020
here I just want you to remember that

00:24:50,440 --> 00:24:54,580
for later on so okay so we've applied

00:24:53,020 --> 00:24:55,900
these linked headers what impact does

00:24:54,580 --> 00:24:59,890
this have on our times first meaningful

00:24:55,900 --> 00:25:02,080
paint so this is our waterfall before we

00:24:59,890 --> 00:25:03,640
apply them remember the how the fonts

00:25:02,080 --> 00:25:04,900
are so lowdown because they're not

00:25:03,640 --> 00:25:08,050
discovered until the render tree

00:25:04,900 --> 00:25:09,730
construction and by applying the link

00:25:08,050 --> 00:25:12,190
headers we've been able to tell the

00:25:09,730 --> 00:25:14,680
browser these are my critical resources

00:25:12,190 --> 00:25:16,270
and we've instantly shifted them up so

00:25:14,680 --> 00:25:17,740
hopefully you're now beginning to

00:25:16,270 --> 00:25:19,050
understand what impact is going to have

00:25:17,740 --> 00:25:22,030
on our time too first meaningful paint

00:25:19,050 --> 00:25:24,430
that's given us a 64 percent improvement

00:25:22,030 --> 00:25:26,830
on our baseline now we've hit our budget

00:25:24,430 --> 00:25:29,410
for cable over thousand milliseconds and

00:25:26,830 --> 00:25:33,700
we're very very close now on 3G on an

00:25:29,410 --> 00:25:37,660
emerging market connection so again this

00:25:33,700 --> 00:25:39,280
comes of some pros and cons it gives us

00:25:37,660 --> 00:25:42,460
a way of indicating the hidden resources

00:25:39,280 --> 00:25:43,630
we can now dictate the priority by order

00:25:42,460 --> 00:25:46,540
sorry that's a very important thing to

00:25:43,630 --> 00:25:50,650
note is that the order of these headers

00:25:46,540 --> 00:25:52,420
also dictates their priority in which

00:25:50,650 --> 00:25:55,570
the browser will perform the networking

00:25:52,420 --> 00:26:01,840
for them so does their relation of style

00:25:55,570 --> 00:26:03,400
and font and the con here though is very

00:26:01,840 --> 00:26:05,200
easy to create contention on the network

00:26:03,400 --> 00:26:08,320
with great power comes great

00:26:05,200 --> 00:26:10,600
responsibility if you were just to set a

00:26:08,320 --> 00:26:12,850
preload header for every single asset on

00:26:10,600 --> 00:26:14,590
your page you're actually not allowing

00:26:12,850 --> 00:26:16,810
the browser to do what it's very good at

00:26:14,590 --> 00:26:18,700
doing using its preload scanner or

00:26:16,810 --> 00:26:21,730
speculative posture to go and find and

00:26:18,700 --> 00:26:23,740
prioritize assets so only use this

00:26:21,730 --> 00:26:26,770
technique for your critical resources

00:26:23,740 --> 00:26:29,830
that you've identified so we could just

00:26:26,770 --> 00:26:33,250
stop there right we've improved our TTS

00:26:29,830 --> 00:26:36,190
MP by 64 percent but surely we can do

00:26:33,250 --> 00:26:38,160
more and this is where HTTP 2 new

00:26:36,190 --> 00:26:41,910
feature could serve a push come

00:26:38,160 --> 00:26:43,950
to play but it is now over 20 years it's

00:26:41,910 --> 00:26:45,600
the first time in over 20 years that we

00:26:43,950 --> 00:26:47,550
have a new version of the underlying

00:26:45,600 --> 00:26:50,070
transfer protocol of the internet called

00:26:47,550 --> 00:26:52,860
HSB 2 and I could literally do a whole

00:26:50,070 --> 00:26:54,960
talk just on H 2 and push in itself and

00:26:52,860 --> 00:26:56,700
but I don't have the time to the up for

00:26:54,960 --> 00:26:58,050
one but I urge you to go and check it

00:26:56,700 --> 00:27:02,820
out and the question on rely class who

00:26:58,050 --> 00:27:04,740
is using HP 2 in production ok so it's

00:27:02,820 --> 00:27:07,590
about 30% of the room from looks things

00:27:04,740 --> 00:27:11,130
which is bit lower than I was hoping but

00:27:07,590 --> 00:27:15,300
that's still very good so to understand

00:27:11,130 --> 00:27:17,730
well that was a bit weird I've broken an

00:27:15,300 --> 00:27:19,380
animation so and to understand what push

00:27:17,730 --> 00:27:21,360
does let's look at again how your

00:27:19,380 --> 00:27:23,700
average web page is constructed first we

00:27:21,360 --> 00:27:26,100
make the get request to the index file

00:27:23,700 --> 00:27:27,660
the server responds with the response

00:27:26,100 --> 00:27:29,640
for that index file we pause the

00:27:27,660 --> 00:27:31,080
document we find the link element we go

00:27:29,640 --> 00:27:37,350
and make the request for the CSS file

00:27:31,080 --> 00:27:40,590
and the server response of that but what

00:27:37,350 --> 00:27:43,110
if we the server knows as the authors of

00:27:40,590 --> 00:27:45,750
the website we know that the next item

00:27:43,110 --> 00:27:47,550
or sorry resource that the client is

00:27:45,750 --> 00:27:48,810
going to request is that CSS file

00:27:47,550 --> 00:27:51,150
because we know it has the highest

00:27:48,810 --> 00:27:54,570
priorities so what as an author we could

00:27:51,150 --> 00:27:56,910
dictate to the client I am going to push

00:27:54,570 --> 00:27:58,860
you these with the CSS file you don't

00:27:56,910 --> 00:28:00,630
need to request it and this is where the

00:27:58,860 --> 00:28:03,210
push promise frame comes in so it's a

00:28:00,630 --> 00:28:05,340
data payload on a HTTP 2 connection that

00:28:03,210 --> 00:28:06,810
the server says I am going to send you

00:28:05,340 --> 00:28:09,270
the bytes for the CSS file you don't

00:28:06,810 --> 00:28:11,430
need to request this then we can push

00:28:09,270 --> 00:28:13,320
the index file and push the CSS down so

00:28:11,430 --> 00:28:16,680
we're eliminating the round-trip

00:28:13,320 --> 00:28:18,090
completely to request that CSS file so

00:28:16,680 --> 00:28:22,350
now we can do this with h2

00:28:18,090 --> 00:28:24,440
programmatically using our friend the

00:28:22,350 --> 00:28:26,910
link preload header here this is the

00:28:24,440 --> 00:28:29,520
semantics that we've decided upon as an

00:28:26,910 --> 00:28:32,280
industry so now if going back to our SD

00:28:29,520 --> 00:28:34,590
comm example we can remove our inline

00:28:32,280 --> 00:28:36,420
CSS now and we can declare it just as a

00:28:34,590 --> 00:28:38,460
normal style sheet that declared the

00:28:36,420 --> 00:28:41,160
secondary the non-critical CSS is

00:28:38,460 --> 00:28:43,560
asynchronous using preload and then tell

00:28:41,160 --> 00:28:45,630
our hb2 server you have to have a h2

00:28:43,560 --> 00:28:48,210
server enabled for this behavior to work

00:28:45,630 --> 00:28:49,830
that I want you to push the critical CSS

00:28:48,210 --> 00:28:50,950
and how we're doing that it's just we've

00:28:49,830 --> 00:28:52,299
removed that no

00:28:50,950 --> 00:28:54,789
push directive that I told you to

00:28:52,299 --> 00:28:56,889
remember about earlier on so hex to

00:28:54,789 --> 00:28:58,630
server will see this response it would

00:28:56,889 --> 00:29:00,669
say right that author wants me to push

00:28:58,630 --> 00:29:04,149
all of these resources and it will push

00:29:00,669 --> 00:29:05,769
the critical CSS bytes down so let's

00:29:04,149 --> 00:29:08,320
take a closer look at what's actually

00:29:05,769 --> 00:29:10,929
happening on the network before we apply

00:29:08,320 --> 00:29:14,260
this optimization and note that we have

00:29:10,929 --> 00:29:15,820
idle time before we get our HTML bytes

00:29:14,260 --> 00:29:17,559
that's when the browser has made the

00:29:15,820 --> 00:29:19,899
request but we're waiting for the server

00:29:17,559 --> 00:29:21,730
to respond of it at the beginning then

00:29:19,899 --> 00:29:24,789
we have a very fast start render because

00:29:21,730 --> 00:29:26,590
we've in lined our critical CSS then the

00:29:24,789 --> 00:29:28,480
browser has some think time again it

00:29:26,590 --> 00:29:31,230
then requests the main CSS file and

00:29:28,480 --> 00:29:33,070
there's our x first meaningful paint now

00:29:31,230 --> 00:29:34,299
then what you're going to think is going

00:29:33,070 --> 00:29:36,700
to happen here but you may be a little

00:29:34,299 --> 00:29:38,710
bit surprised as the impact of pushing

00:29:36,700 --> 00:29:43,090
our critical CSS says removing it from

00:29:38,710 --> 00:29:45,070
inline and pushing it we've actually had

00:29:43,090 --> 00:29:50,679
a negative impact on the x first

00:29:45,070 --> 00:29:52,210
meaningful paint and why is this we're

00:29:50,679 --> 00:29:53,950
not using the idle time at the beginning

00:29:52,210 --> 00:29:55,450
of the connection and to understand why

00:29:53,950 --> 00:29:56,980
this is we have to have a bit of better

00:29:55,450 --> 00:29:59,710
understanding what's actually happening

00:29:56,980 --> 00:30:02,799
on the HTTP 2 server here HT servers use

00:29:59,710 --> 00:30:04,960
a prioritization tree to determine which

00:30:02,799 --> 00:30:07,029
the order of which the packets is going

00:30:04,960 --> 00:30:09,580
to send down the connection and even

00:30:07,029 --> 00:30:12,970
though we told our Haiti to server to

00:30:09,580 --> 00:30:15,130
push the CSS via our link header because

00:30:12,970 --> 00:30:18,220
we actually did it on the response of

00:30:15,130 --> 00:30:20,320
the HTML document the server had all of

00:30:18,220 --> 00:30:23,559
the HTML and HTML has a much higher

00:30:20,320 --> 00:30:25,480
priority than CSS does so of course it's

00:30:23,559 --> 00:30:27,309
going to flush all of the HTML bytes

00:30:25,480 --> 00:30:29,559
down the connection before it did our

00:30:27,309 --> 00:30:32,019
critical CSS even though actually what

00:30:29,559 --> 00:30:33,970
we wanted it to do is flush the CSS in

00:30:32,019 --> 00:30:36,279
our idle time whilst we were waiting for

00:30:33,970 --> 00:30:37,510
our HTML connection and I must stress

00:30:36,279 --> 00:30:40,120
here that this behavior is slightly

00:30:37,510 --> 00:30:42,279
different depending on your HDTV server

00:30:40,120 --> 00:30:44,799
implementation but all of the major h2

00:30:42,279 --> 00:30:47,769
service at the moment prioritize and

00:30:44,799 --> 00:30:50,440
quite rightly prioritized HTML over CSS

00:30:47,769 --> 00:30:52,450
on the connection and so this is the

00:30:50,440 --> 00:30:53,740
impact it has on our waterfall now it's

00:30:52,450 --> 00:30:56,350
really interesting thing here to note is

00:30:53,740 --> 00:30:58,840
the critical CSS doesn't have a light

00:30:56,350 --> 00:31:00,490
green segment beforehand because it

00:30:58,840 --> 00:31:02,320
didn't need to send the request and

00:31:00,490 --> 00:31:04,270
therefore was there was no waiting for

00:31:02,320 --> 00:31:06,160
it so this is the benefit that we get

00:31:04,270 --> 00:31:07,630
from push is that we're reducing the

00:31:06,160 --> 00:31:10,210
idler time from the request to the

00:31:07,630 --> 00:31:12,280
response but it's we're not getting our

00:31:10,210 --> 00:31:14,590
CSS delivered at the point that we want

00:31:12,280 --> 00:31:18,790
it to in the light blue area of our HTML

00:31:14,590 --> 00:31:22,059
and it's also important to note if you

00:31:18,790 --> 00:31:23,290
weren't in lining your CSS and many of

00:31:22,059 --> 00:31:24,820
you probably aren't this is still quite

00:31:23,290 --> 00:31:30,040
a very good technique because you are

00:31:24,820 --> 00:31:31,929
saving that that request time so we've

00:31:30,040 --> 00:31:33,850
had a negative impact on our time to

00:31:31,929 --> 00:31:35,290
first meaningful paint here only 43

00:31:33,850 --> 00:31:40,929
percent improvement on our baseline

00:31:35,290 --> 00:31:43,540
we've gone back to 5,000 milliseconds so

00:31:40,929 --> 00:31:45,730
the question I'm asking is should we be

00:31:43,540 --> 00:31:48,100
using server push at all actually we're

00:31:45,730 --> 00:31:51,220
having a negative impact and most

00:31:48,100 --> 00:31:53,920
importantly is using the link header

00:31:51,220 --> 00:31:56,650
with a rel preload actually much too

00:31:53,920 --> 00:31:58,990
late in the connection state for us to

00:31:56,650 --> 00:32:02,620
indicate the CSS that we want you to

00:31:58,990 --> 00:32:04,960
push and so how can we actually achieve

00:32:02,620 --> 00:32:07,360
that holy grail of pushing our critical

00:32:04,960 --> 00:32:09,520
CSS only in the server idle time and

00:32:07,360 --> 00:32:12,309
this is what firstly at fastly sorry

00:32:09,520 --> 00:32:14,200
we're calling async push so let's look

00:32:12,309 --> 00:32:16,150
at that network utilization again from

00:32:14,200 --> 00:32:18,490
my experiment and note at the beginning

00:32:16,150 --> 00:32:19,960
we have that idle time waiting for the

00:32:18,490 --> 00:32:22,150
server to respond it's probably

00:32:19,960 --> 00:32:23,620
performing the templating going and

00:32:22,150 --> 00:32:26,110
requesting your user data from your

00:32:23,620 --> 00:32:28,510
database is that this server think time

00:32:26,110 --> 00:32:31,000
that we want to be using to be pushing

00:32:28,510 --> 00:32:32,559
our static assets and so a much more

00:32:31,000 --> 00:32:34,720
common architecture that probably many

00:32:32,559 --> 00:32:36,309
in the you in the room are using is that

00:32:34,720 --> 00:32:39,130
you have your application server is

00:32:36,309 --> 00:32:41,320
actually separate from your HTTP server

00:32:39,130 --> 00:32:43,870
think you probably use nginx or Apache

00:32:41,320 --> 00:32:46,150
you might use a CDN for instance and so

00:32:43,870 --> 00:32:47,830
this is the request flow that the index

00:32:46,150 --> 00:32:51,280
file goes through and then we get

00:32:47,830 --> 00:32:53,200
response and what if that server was

00:32:51,280 --> 00:32:56,320
able during an application think time

00:32:53,200 --> 00:32:58,330
was able to push the critical resource

00:32:56,320 --> 00:33:00,100
at that time this is the think time that

00:32:58,330 --> 00:33:02,500
we want to be using so here's an example

00:33:00,100 --> 00:33:05,530
of doing that using an Express style

00:33:02,500 --> 00:33:07,690
request handler using HC and knows HTTP

00:33:05,530 --> 00:33:09,160
- implementation the important point to

00:33:07,690 --> 00:33:11,050
note here is not the implementation of

00:33:09,160 --> 00:33:12,910
but what we're doing at the beginning of

00:33:11,050 --> 00:33:16,240
the request the first thing we're doing

00:33:12,910 --> 00:33:18,130
is flushing our critical CSS via push

00:33:16,240 --> 00:33:20,590
down the network connection

00:33:18,130 --> 00:33:23,200
then we go and do our templating and

00:33:20,590 --> 00:33:25,330
fetching from our rendering and then we

00:33:23,200 --> 00:33:27,580
respond with our link headers and this

00:33:25,330 --> 00:33:30,100
is how we can utilize that idle

00:33:27,580 --> 00:33:32,559
connection time and so what happens to

00:33:30,100 --> 00:33:35,320
our connection state here now is we've

00:33:32,559 --> 00:33:37,570
we've reached the holy grail we've been

00:33:35,320 --> 00:33:40,030
able to push our critical CSS in the

00:33:37,570 --> 00:33:41,950
light blue area whilst the server is

00:33:40,030 --> 00:33:45,070
still thinking we've given the browser

00:33:41,950 --> 00:33:48,250
everything it needs way before it even

00:33:45,070 --> 00:33:51,809
gets any HTML to style and paint your

00:33:48,250 --> 00:33:54,370
entire document so now we have a 65%

00:33:51,809 --> 00:33:56,650
improvement on our baseline we've

00:33:54,370 --> 00:33:58,600
reached that holy grail so this comes of

00:33:56,650 --> 00:34:00,429
some pros and some cons obviously that

00:33:58,600 --> 00:34:02,350
we're using that idle time but it's very

00:34:00,429 --> 00:34:04,030
easy to create contention with push and

00:34:02,350 --> 00:34:05,950
there's limited availability of this

00:34:04,030 --> 00:34:07,330
because you have to have access to the

00:34:05,950 --> 00:34:11,560
network connection within your server to

00:34:07,330 --> 00:34:13,179
be able to do this and hopefully many of

00:34:11,560 --> 00:34:15,340
the room thinking but what about the

00:34:13,179 --> 00:34:18,609
repeat view every one of our tests has

00:34:15,340 --> 00:34:20,169
been the first view the uncashed the

00:34:18,609 --> 00:34:21,820
browser doesn't have anything cached and

00:34:20,169 --> 00:34:23,260
that's what we should be optimizing for

00:34:21,820 --> 00:34:26,230
for our time first meaningful paint but

00:34:23,260 --> 00:34:28,030
with push if I was the user was then to

00:34:26,230 --> 00:34:29,679
visit the next page on my website and I

00:34:28,030 --> 00:34:31,690
was going to push those bytes we've

00:34:29,679 --> 00:34:33,609
actually the browser's probably got that

00:34:31,690 --> 00:34:36,280
asset cached already but we've got no

00:34:33,609 --> 00:34:38,619
way of indicating to the server that we

00:34:36,280 --> 00:34:41,409
have that CSS so please don't push it to

00:34:38,619 --> 00:34:42,760
me and I did want to show you how to do

00:34:41,409 --> 00:34:45,010
this using new technology such as

00:34:42,760 --> 00:34:47,409
serviceworkers and the purple pattern

00:34:45,010 --> 00:34:49,840
but unfortunately I've ran out of time

00:34:47,409 --> 00:34:52,030
today but the good news is adios money

00:34:49,840 --> 00:34:53,679
is from Google is going to be talking

00:34:52,030 --> 00:34:55,659
exactly about these types of patterns

00:34:53,679 --> 00:34:57,880
and how you can optimize for time to add

00:34:55,659 --> 00:35:00,700
interactivity on your repeats view at

00:34:57,880 --> 00:35:02,800
jazzpunk for this weekend so let's look

00:35:00,700 --> 00:35:05,320
at the final results and I think it's

00:35:02,800 --> 00:35:06,940
better to show you to them as how the

00:35:05,320 --> 00:35:09,040
user is perceiving this now with our

00:35:06,940 --> 00:35:10,840
async push example down the bottom all

00:35:09,040 --> 00:35:13,210
the way up to the baseline we've been

00:35:10,840 --> 00:35:16,240
able to improve the delivery on a 3G

00:35:13,210 --> 00:35:17,590
emerging-market connection by over 3,000

00:35:16,240 --> 00:35:20,910
milliseconds which is staggering

00:35:17,590 --> 00:35:20,910
improvement for our performance

00:35:26,950 --> 00:35:30,500
okay so finally I just wanted to leave

00:35:29,240 --> 00:35:32,030
you with some glimpse of what the future

00:35:30,500 --> 00:35:35,540
is happening we've now got strong

00:35:32,030 --> 00:35:37,730
toolbox of AP is preload HTTP push and

00:35:35,540 --> 00:35:39,470
inlining but there's still some issues

00:35:37,730 --> 00:35:42,410
of each of those that I outlined the

00:35:39,470 --> 00:35:44,330
biggest weakness of server push as we

00:35:42,410 --> 00:35:46,550
mentioned is that by indicating that

00:35:44,330 --> 00:35:48,440
push via link preload header is that

00:35:46,550 --> 00:35:49,880
that initiation of the push is much too

00:35:48,440 --> 00:35:51,710
late in the network connection and we

00:35:49,880 --> 00:35:54,500
end up in just in the network and this

00:35:51,710 --> 00:35:56,450
is where my colleague Kazuo firstly we

00:35:54,500 --> 00:36:00,470
now have a working draft in the ITF of

00:35:56,450 --> 00:36:02,060
the 103 early hint status code the 100

00:36:00,470 --> 00:36:04,160
range a lot of people didn't even know

00:36:02,060 --> 00:36:05,720
existed it's the information status code

00:36:04,160 --> 00:36:07,400
range and we can now have this pattern

00:36:05,720 --> 00:36:09,410
where the client requested something

00:36:07,400 --> 00:36:11,450
from the server and whilst the server is

00:36:09,410 --> 00:36:14,810
generating the response it can flush an

00:36:11,450 --> 00:36:16,490
early hint response containing link

00:36:14,810 --> 00:36:18,380
headers to all of your critical sub

00:36:16,490 --> 00:36:20,180
resources and then the browser can go

00:36:18,380 --> 00:36:22,910
and prioritize the networking for them

00:36:20,180 --> 00:36:24,680
and finally the cache digest

00:36:22,910 --> 00:36:27,200
specification remember I mentioned that

00:36:24,680 --> 00:36:29,060
the repeat view of push we have no way

00:36:27,200 --> 00:36:31,670
of indicating to the browser what we

00:36:29,060 --> 00:36:35,060
have in a cache for our CSS for that

00:36:31,670 --> 00:36:37,040
domain and so now on a h2 connection the

00:36:35,060 --> 00:36:40,010
client is going to be able to send via

00:36:37,040 --> 00:36:41,750
cache digest frame or a header all of

00:36:40,010 --> 00:36:43,940
the files that it has for that host name

00:36:41,750 --> 00:36:45,650
and then the server can decide ok I'm

00:36:43,940 --> 00:36:47,360
not going to send you that CSS file

00:36:45,650 --> 00:36:49,550
because I know you already have it in

00:36:47,360 --> 00:36:50,780
its cache and I think this in itself is

00:36:49,550 --> 00:36:52,850
going to be one of the most powerful

00:36:50,780 --> 00:36:54,170
performance optimizations in the future

00:36:52,850 --> 00:36:57,230
of the next five years as it gets

00:36:54,170 --> 00:36:58,790
implemented in browsers so that's been a

00:36:57,230 --> 00:37:00,140
whirlwind tour I've gone five minutes

00:36:58,790 --> 00:37:02,420
over my slots

00:37:00,140 --> 00:37:04,670
I'm very sorry my lovely CSS conference

00:37:02,420 --> 00:37:06,800
organizers so I just wanted to leave you

00:37:04,670 --> 00:37:08,810
for the last points and takeaways and

00:37:06,800 --> 00:37:11,210
that is that hopefully you found that

00:37:08,810 --> 00:37:13,610
resource loading in the browser is hard

00:37:11,210 --> 00:37:15,800
it's much harder than you probably

00:37:13,610 --> 00:37:18,440
thought it was bandwidth is often

00:37:15,800 --> 00:37:20,990
underutilized but we have technologies

00:37:18,440 --> 00:37:23,570
now emerging to enable us to give that

00:37:20,990 --> 00:37:25,190
utilization to the browser identify your

00:37:23,570 --> 00:37:28,040
critical resources and your request

00:37:25,190 --> 00:37:29,360
chains use preload to indicate those

00:37:28,040 --> 00:37:31,670
critical resources to the browser

00:37:29,360 --> 00:37:34,160
especially your fonts if you're using

00:37:31,670 --> 00:37:36,740
custom web fonts and push your critical

00:37:34,160 --> 00:37:39,020
CSS but only in first view and please

00:37:36,740 --> 00:37:41,270
try and only used within that idle

00:37:39,020 --> 00:37:44,210
connection time but most importantly

00:37:41,270 --> 00:37:46,610
always be testing it's the most

00:37:44,210 --> 00:37:47,940
important thing to leave you with thank

00:37:46,610 --> 00:37:50,040
you very much

00:37:47,940 --> 00:37:51,140
[Applause]

00:37:50,040 --> 00:37:53,980
[Music]

00:37:51,140 --> 00:37:56,040
[Applause]

00:37:53,980 --> 00:37:56,040

YouTube URL: https://www.youtube.com/watch?v=4pQ2byAoIX0


