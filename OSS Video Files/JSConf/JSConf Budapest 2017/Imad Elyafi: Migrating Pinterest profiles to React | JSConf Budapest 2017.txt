Title: Imad Elyafi: Migrating Pinterest profiles to React | JSConf Budapest 2017
Publication date: 2017-12-01
Playlist: JSConf Budapest 2017
Description: 
	We all have been in situation when we were in one platform and had to move to another. While it’s relatively easy to build a new web app in React, migrating a service that’s constantly changing and used by millions of people is a much more complicated challenge. It’s like changing the engines of an airplane while mid-flight. The talk is about techniques we tried and challenges we faced while migrating to React at Pinterest.

http://jsconfbp.com/speakers/imad-elyafi/
Captions: 
	00:00:02,480 --> 00:00:09,030
hello everyone thank you all for coming

00:00:05,970 --> 00:00:12,150
I'm so excited to be here Budapest is a

00:00:09,030 --> 00:00:14,099
beautiful city I'm from San Francisco my

00:00:12,150 --> 00:00:15,870
name is Ahmad le - I'm software engineer

00:00:14,099 --> 00:00:18,060
and web / experienced team at Pinterest

00:00:15,870 --> 00:00:20,580
and one of the projects that I've been

00:00:18,060 --> 00:00:23,310
working on last year is react migration

00:00:20,580 --> 00:00:25,890
and today I'm going to tell you a story

00:00:23,310 --> 00:00:27,630
about our journey to react we'll take a

00:00:25,890 --> 00:00:29,160
look into challenges we faced and

00:00:27,630 --> 00:00:31,650
techniques we used while migrating

00:00:29,160 --> 00:00:33,390
pinterest profiles to react if you have

00:00:31,650 --> 00:00:35,690
any questions please make a note and

00:00:33,390 --> 00:00:38,370
i'll be happy to answer them in the end

00:00:35,690 --> 00:00:41,280
so today's presentation is broke into

00:00:38,370 --> 00:00:43,890
four major parts and the first one is

00:00:41,280 --> 00:00:45,870
about how we why we decided to migrate

00:00:43,890 --> 00:00:49,559
to react at all and not any other

00:00:45,870 --> 00:00:51,420
library the second part is about how we

00:00:49,559 --> 00:00:53,760
had to prepare on our infrastructure

00:00:51,420 --> 00:00:56,640
first before we were able to build

00:00:53,760 --> 00:01:00,840
something in reality the third part is

00:00:56,640 --> 00:01:02,640
about measuring the impact and this

00:01:00,840 --> 00:01:04,500
pretty important part because during

00:01:02,640 --> 00:01:06,689
migrations like that you may introduce

00:01:04,500 --> 00:01:08,820
bugs or break something and you'll never

00:01:06,689 --> 00:01:11,340
know if you're not measuring the things

00:01:08,820 --> 00:01:13,770
that you're building and the last part I

00:01:11,340 --> 00:01:16,439
will share you the details how our life

00:01:13,770 --> 00:01:22,680
and engineering life has changed after

00:01:16,439 --> 00:01:25,049
adoption of react so first of all why we

00:01:22,680 --> 00:01:27,240
had to move away from the existing

00:01:25,049 --> 00:01:29,689
framework at all and the existing

00:01:27,240 --> 00:01:32,610
framework Denzel which was built into

00:01:29,689 --> 00:01:35,040
2013 served us well until a certain

00:01:32,610 --> 00:01:37,560
period of time but nowadays it's

00:01:35,040 --> 00:01:39,360
outdated it's very common to many other

00:01:37,560 --> 00:01:42,090
frameworks that were introduced during

00:01:39,360 --> 00:01:45,240
the time three four five years ago and

00:01:42,090 --> 00:01:47,490
it's based on object-oriented JavaScript

00:01:45,240 --> 00:01:53,430
paradigm and it uses components based

00:01:47,490 --> 00:01:55,890
here are key so one of the most common

00:01:53,430 --> 00:01:58,740
questions is why we decided to move to

00:01:55,890 --> 00:02:01,950
react and not to angular ember or meteor

00:01:58,740 --> 00:02:03,780
or anything else and on this slide you

00:02:01,950 --> 00:02:07,259
can see a list of requirements that we

00:02:03,780 --> 00:02:09,330
head to our new framework and we want to

00:02:07,259 --> 00:02:11,970
have a framework with a large developer

00:02:09,330 --> 00:02:13,170
community and react has a huge developer

00:02:11,970 --> 00:02:14,640
community and

00:02:13,170 --> 00:02:18,300
to take advantage of these developer

00:02:14,640 --> 00:02:21,239
community another requirement is design

00:02:18,300 --> 00:02:24,930
patterns and react is very compatible

00:02:21,239 --> 00:02:27,180
with our legacy stack and it makes the

00:02:24,930 --> 00:02:31,770
emigration to many other frameworks much

00:02:27,180 --> 00:02:33,959
easier the third requirement is solution

00:02:31,770 --> 00:02:36,450
for isomorphism or so-called Universal

00:02:33,959 --> 00:02:39,900
rendering and now we'll tell you later

00:02:36,450 --> 00:02:42,150
why this is so important for us and in

00:02:39,900 --> 00:02:43,980
that requirement is performance and

00:02:42,150 --> 00:02:45,660
react is well known for its performance

00:02:43,980 --> 00:02:48,180
benefits you probably heard about

00:02:45,660 --> 00:02:51,540
virtual Dom and reconciliation algorithm

00:02:48,180 --> 00:02:55,410
and so and so forth and the last thing

00:02:51,540 --> 00:02:58,260
is developer experience and this is our

00:02:55,410 --> 00:03:00,090
old legacy stack and you might have

00:02:58,260 --> 00:03:02,760
something similar in your project we

00:03:00,090 --> 00:03:04,860
have Python junga web server ginger

00:03:02,760 --> 00:03:07,790
renderer on the back end nine checks on

00:03:04,860 --> 00:03:11,489
the client and it's old as well but

00:03:07,790 --> 00:03:13,319
being on board with all of these like

00:03:11,489 --> 00:03:16,410
mojo bundler Redux

00:03:13,319 --> 00:03:18,930
just unit tests and many other tools and

00:03:16,410 --> 00:03:23,220
features has completely changed the way

00:03:18,930 --> 00:03:25,079
we develop our modern web apps so just

00:03:23,220 --> 00:03:28,260
to give you an idea of scale that we

00:03:25,079 --> 00:03:31,530
operated we have 200 200 millions of

00:03:28,260 --> 00:03:33,420
monthly active users which is more than

00:03:31,530 --> 00:03:38,340
population of the biggest country in the

00:03:33,420 --> 00:03:43,890
world Russia we serve more than 150,000

00:03:38,340 --> 00:03:46,560
requests per second and since we

00:03:43,890 --> 00:03:48,900
constantly ship new features we run

00:03:46,560 --> 00:03:51,630
hundreds of experiments we can't just

00:03:48,900 --> 00:03:53,489
simply freeze our product development in

00:03:51,630 --> 00:03:55,500
order to rebuild the new web app from

00:03:53,489 --> 00:03:57,510
scratch and react and while it's

00:03:55,500 --> 00:04:00,810
relatively easy to build a new web app

00:03:57,510 --> 00:04:02,670
in react changing a service immigrating

00:04:00,810 --> 00:04:04,769
service that is constantly changing is

00:04:02,670 --> 00:04:07,640
like changing engines of an airplane

00:04:04,769 --> 00:04:07,640
while mid-flight

00:04:07,940 --> 00:04:15,180
so how how many of you have tried to

00:04:12,209 --> 00:04:19,320
rewrite your web app from from scratch

00:04:15,180 --> 00:04:22,320
in any other framework again we see a

00:04:19,320 --> 00:04:25,169
lot of hands and I try to do this before

00:04:22,320 --> 00:04:27,270
and ended up in situation when I had old

00:04:25,169 --> 00:04:29,819
web app which is still in production

00:04:27,270 --> 00:04:32,009
and many almost hundreds of engineers

00:04:29,819 --> 00:04:34,560
were completely changing it adding new

00:04:32,009 --> 00:04:36,479
features and had me new one which is

00:04:34,560 --> 00:04:38,520
still under development and I had to

00:04:36,479 --> 00:04:40,680
port all these features back to the to

00:04:38,520 --> 00:04:42,569
the new one and it's like the constant

00:04:40,680 --> 00:04:43,819
race condition not the best situation to

00:04:42,569 --> 00:04:47,009
be in

00:04:43,819 --> 00:04:49,110
so now how can we avoid this and the

00:04:47,009 --> 00:04:52,050
only way to avoid this is to rewrite our

00:04:49,110 --> 00:04:54,090
web app part by part while there the

00:04:52,050 --> 00:04:57,900
rest is still run by the old framework

00:04:54,090 --> 00:05:01,440
and now we're coming to this idea of

00:04:57,900 --> 00:05:03,419
so-called hybrid app it's an app where

00:05:01,440 --> 00:05:05,580
we have two frameworks and they plug

00:05:03,419 --> 00:05:08,310
this together together for the time of

00:05:05,580 --> 00:05:10,710
the migration and thus our engineers

00:05:08,310 --> 00:05:12,599
will not have to write everything at

00:05:10,710 --> 00:05:16,169
once they will be able to migrate it

00:05:12,599 --> 00:05:18,750
piece by piece so now we want to ask

00:05:16,169 --> 00:05:21,180
question how can we make a hybrid app

00:05:18,750 --> 00:05:23,310
and the very first thought maybe it's

00:05:21,180 --> 00:05:25,379
not that complicated but let's take a

00:05:23,310 --> 00:05:29,310
look at the list of the all possible

00:05:25,379 --> 00:05:32,340
challenges and the very first challenge

00:05:29,310 --> 00:05:34,919
is that react is obviously JavaScript

00:05:32,340 --> 00:05:39,509
framework and how many of you have

00:05:34,919 --> 00:05:41,669
JavaScript on the server side I can see

00:05:39,509 --> 00:05:44,310
a little bit of hands but obviously not

00:05:41,669 --> 00:05:45,900
everyone and having JavaScript on the

00:05:44,310 --> 00:05:48,360
server side is not a very common thing

00:05:45,900 --> 00:05:51,060
but having javascript in Python PHP or

00:05:48,360 --> 00:05:54,840
Java or many other server-side languages

00:05:51,060 --> 00:05:58,039
is very rare it's obviously not a common

00:05:54,840 --> 00:06:00,060
at all so in order to enable our

00:05:58,039 --> 00:06:02,039
JavaScript rendering on the server side

00:06:00,060 --> 00:06:04,740
we had to prepare infrastructure first

00:06:02,039 --> 00:06:06,779
and some of you may ask the question why

00:06:04,740 --> 00:06:09,870
do I actually need so-called Universal

00:06:06,779 --> 00:06:10,590
or isomorphic rendering and there is two

00:06:09,870 --> 00:06:12,900
reasons for that

00:06:10,590 --> 00:06:15,060
first of all our engineers they will not

00:06:12,900 --> 00:06:17,460
have to write their templates twice so

00:06:15,060 --> 00:06:18,719
we're saving their work in time and the

00:06:17,460 --> 00:06:21,990
other reason is yes here

00:06:18,719 --> 00:06:25,080
and even though nowadays search engines

00:06:21,990 --> 00:06:27,330
they can execute JavaScript and parse

00:06:25,080 --> 00:06:29,940
page that is rendered on the client-side

00:06:27,330 --> 00:06:32,069
we run a bunch of experiments it's still

00:06:29,940 --> 00:06:37,020
better to serve the initial markup as a

00:06:32,069 --> 00:06:39,779
string as an HTML string so the second

00:06:37,020 --> 00:06:41,400
challenge is rendering react components

00:06:39,779 --> 00:06:44,400
inside of the old

00:06:41,400 --> 00:06:46,199
and while react is pretty flexible in

00:06:44,400 --> 00:06:48,930
terms of rendering as long as you can

00:06:46,199 --> 00:06:51,300
provide it a container Dom element there

00:06:48,930 --> 00:06:53,280
still might be some challenges and for

00:06:51,300 --> 00:06:55,620
example what if your template files are

00:06:53,280 --> 00:06:58,020
stored your what if your templates are

00:06:55,620 --> 00:07:00,090
started in separate files or what if

00:06:58,020 --> 00:07:02,219
your templates using a custom made

00:07:00,090 --> 00:07:04,620
template language and such example is

00:07:02,219 --> 00:07:08,580
ginger templates in Python and non Dex

00:07:04,620 --> 00:07:11,520
in JavaScript so the third challenge is

00:07:08,580 --> 00:07:14,669
dealing with the old resources and more

00:07:11,520 --> 00:07:17,219
likely in your your your project you

00:07:14,669 --> 00:07:19,860
have a resource layer which does all the

00:07:17,219 --> 00:07:21,389
communication with the API and probably

00:07:19,860 --> 00:07:23,279
you want to reuse it at least for the

00:07:21,389 --> 00:07:26,099
first period of time unless you want to

00:07:23,279 --> 00:07:28,680
really rebuild everything from scratch

00:07:26,099 --> 00:07:31,110
in react and you have to Web Apps as we

00:07:28,680 --> 00:07:34,560
discussed before so dealing with the old

00:07:31,110 --> 00:07:37,379
resources is another challenge and the

00:07:34,560 --> 00:07:39,960
last challenge is how can we make sure

00:07:37,379 --> 00:07:41,400
that newly created UI and components

00:07:39,960 --> 00:07:44,009
they're actually performing better than

00:07:41,400 --> 00:07:46,529
the old ones what if we introduced a bar

00:07:44,009 --> 00:07:49,800
for performance issues and something is

00:07:46,529 --> 00:07:51,779
going wrong with the users so here we

00:07:49,800 --> 00:07:54,259
outline our four main challenges and now

00:07:51,779 --> 00:07:56,879
let's dive deeper into each of those and

00:07:54,259 --> 00:08:03,839
before let me give you a high-level

00:07:56,879 --> 00:08:06,240
overview of our web app architecture as

00:08:03,839 --> 00:08:09,180
you can see on this slide there is

00:08:06,240 --> 00:08:13,199
nothing crazy we have a client-side web

00:08:09,180 --> 00:08:16,680
app Python junga web server and we have

00:08:13,199 --> 00:08:19,250
pack an API and when a user agent sends

00:08:16,680 --> 00:08:22,770
a request to the to the server the

00:08:19,250 --> 00:08:25,259
server renders HTML with ginger render

00:08:22,770 --> 00:08:27,960
in Python and sends back all this HTML

00:08:25,259 --> 00:08:31,169
to the client which spawns a bunch of

00:08:27,960 --> 00:08:33,810
requests for CSS images in JavaScript

00:08:31,169 --> 00:08:37,079
and many other assets it initializes the

00:08:33,810 --> 00:08:39,539
app and after that our subsequent

00:08:37,079 --> 00:08:41,760
requests are handled only only for

00:08:39,539 --> 00:08:43,860
retrieving the additional data so there

00:08:41,760 --> 00:08:46,110
is no more subsequent renders on the on

00:08:43,860 --> 00:08:48,540
the server side all the renders are

00:08:46,110 --> 00:08:50,699
happening on the client side and because

00:08:48,540 --> 00:08:54,300
of that we had so-called isomorphic

00:08:50,699 --> 00:08:54,690
rendering so now let me give you a

00:08:54,300 --> 00:08:57,330
little bit

00:08:54,690 --> 00:09:00,720
contacts about ginger rendering engine

00:08:57,330 --> 00:09:03,420
and Python and nunchucks in JavaScript

00:09:00,720 --> 00:09:06,480
and these templating languages are very

00:09:03,420 --> 00:09:08,730
similar almost identical and because of

00:09:06,480 --> 00:09:11,220
that we had so-called isomorphic

00:09:08,730 --> 00:09:13,320
rendering and the only one caveat in

00:09:11,220 --> 00:09:15,120
this approach was that we had to have

00:09:13,320 --> 00:09:17,820
two sets of utils you can see there is

00:09:15,120 --> 00:09:19,590
one set youtubes in libraries for python

00:09:17,820 --> 00:09:22,590
and another one for nunchucks in

00:09:19,590 --> 00:09:24,960
javascript not the best approach because

00:09:22,590 --> 00:09:28,560
you have to run tests and do all these

00:09:24,960 --> 00:09:30,720
things that are not the best how many of

00:09:28,560 --> 00:09:35,730
you are familiar with nunchucks or

00:09:30,720 --> 00:09:38,940
ginger at all not that many people but

00:09:35,730 --> 00:09:40,800
that's fine because I'm gonna go into a

00:09:38,940 --> 00:09:43,770
high-level overview of this templating

00:09:40,800 --> 00:09:46,470
language and it's pretty common similar

00:09:43,770 --> 00:09:48,060
to many other languages on this slide

00:09:46,470 --> 00:09:51,420
you can see small code snippet we are

00:09:48,060 --> 00:09:54,390
initializing three variables very common

00:09:51,420 --> 00:09:56,940
to many template templating languages on

00:09:54,390 --> 00:10:01,710
this line you can see that we are

00:09:56,940 --> 00:10:04,770
executing our template and if creating a

00:10:01,710 --> 00:10:09,990
name is empty the render hello guest

00:10:04,770 --> 00:10:12,750
welcome to Pinterest and finally on this

00:10:09,990 --> 00:10:16,380
slide we are rendering a module called

00:10:12,750 --> 00:10:18,450
home feed and module is a function call

00:10:16,380 --> 00:10:20,220
in Java C it will be converted to

00:10:18,450 --> 00:10:22,830
function call in JavaScript which will

00:10:20,220 --> 00:10:25,500
file home feed module and it will render

00:10:22,830 --> 00:10:29,490
for us passing all the options as a

00:10:25,500 --> 00:10:37,230
properties does it look familiar for you

00:10:29,490 --> 00:10:39,270
know any react people so it seems like

00:10:37,230 --> 00:10:42,360
this architecture fits very well into

00:10:39,270 --> 00:10:45,690
each other this is a react code snippet

00:10:42,360 --> 00:10:48,330
and we reading properties with calling

00:10:45,690 --> 00:10:50,040
home feed module we passing all the

00:10:48,330 --> 00:10:51,990
options of the properties as well and

00:10:50,040 --> 00:10:56,700
home field is not is another function

00:10:51,990 --> 00:10:58,380
call in react so this looks very it

00:10:56,700 --> 00:10:59,490
seems like these architectures fits very

00:10:58,380 --> 00:11:01,310
well into each other

00:10:59,490 --> 00:11:04,170
but the only one issue is that

00:11:01,310 --> 00:11:06,740
JavaScript and Python is not commenting

00:11:04,170 --> 00:11:10,880
at all or any other server-side language

00:11:06,740 --> 00:11:13,100
because of that is a very first step we

00:11:10,880 --> 00:11:16,670
enabled non Jax rendering on a

00:11:13,100 --> 00:11:18,140
standalone node.js server that enables

00:11:16,670 --> 00:11:21,770
JavaScript rendering on the on the

00:11:18,140 --> 00:11:23,840
server side this will unblock nunchuks

00:11:21,770 --> 00:11:27,020
rendering and our engineers would have

00:11:23,840 --> 00:11:28,940
to rebuild the whole thing at once

00:11:27,020 --> 00:11:31,070
but they will be able to migrate

00:11:28,940 --> 00:11:36,470
incrementally rewriting our web app

00:11:31,070 --> 00:11:38,690
piece by piece as a bonus we can reuse

00:11:36,470 --> 00:11:40,790
the same youtubes and libraries so there

00:11:38,690 --> 00:11:45,050
is no more duplicating libraries only in

00:11:40,790 --> 00:11:47,930
JavaScript no more in Python so now we

00:11:45,050 --> 00:11:50,840
have a plan for our migration at first

00:11:47,930 --> 00:11:53,390
will migrate from Gingin Python and X on

00:11:50,840 --> 00:11:57,530
the client tune and X on the on the

00:11:53,390 --> 00:11:59,330
server and on the client and now let's

00:11:57,530 --> 00:12:01,460
take a look how our rendering used to

00:11:59,330 --> 00:12:04,850
work before we introduced node.js

00:12:01,460 --> 00:12:07,250
sidebar as I mentioned before our

00:12:04,850 --> 00:12:10,010
templates are structured as a trees a

00:12:07,250 --> 00:12:11,510
root module can have children module and

00:12:10,010 --> 00:12:14,720
children modules can have more children

00:12:11,510 --> 00:12:17,090
modules and a renderer pass traverses

00:12:14,720 --> 00:12:20,440
the tree rendering each of these node

00:12:17,090 --> 00:12:23,920
and combining them into resulting HTML

00:12:20,440 --> 00:12:28,550
so a user agent sends a request to the

00:12:23,920 --> 00:12:30,380
to the Python jungle web server then we

00:12:28,550 --> 00:12:31,940
send a request to the backend API in

00:12:30,380 --> 00:12:35,330
order to retrieve the initial data for

00:12:31,940 --> 00:12:38,000
the template and we start rendering our

00:12:35,330 --> 00:12:40,190
templating tree so we render it as far

00:12:38,000 --> 00:12:45,230
as we can go until additional data is

00:12:40,190 --> 00:12:47,660
needed at this point worst to mention

00:12:45,230 --> 00:12:49,190
that this process is CPU blocking so

00:12:47,660 --> 00:12:52,970
nothing else can be rendered in this

00:12:49,190 --> 00:12:54,890
process and this happens serially at

00:12:52,970 --> 00:12:58,520
this point we'll request additional data

00:12:54,890 --> 00:13:01,490
from the back in API and we continue our

00:12:58,520 --> 00:13:02,870
rendering as far as we can go until

00:13:01,490 --> 00:13:05,600
additional data needed and we're

00:13:02,870 --> 00:13:08,300
requesting additional data and in the

00:13:05,600 --> 00:13:12,170
end after the whole template is rendered

00:13:08,300 --> 00:13:14,510
with sending the resulting HTML now

00:13:12,170 --> 00:13:17,540
let's take a look what happened after we

00:13:14,510 --> 00:13:19,900
introduced a node.js sidecar as you can

00:13:17,540 --> 00:13:22,330
see the Harket texture is

00:13:19,900 --> 00:13:24,820
similar to what we had before but now we

00:13:22,330 --> 00:13:28,330
have injects proxy layer for load

00:13:24,820 --> 00:13:34,090
balancing and we have a set of node.js

00:13:28,330 --> 00:13:38,950
workers as it was before we're sending a

00:13:34,090 --> 00:13:40,540
request from the user agent and we're

00:13:38,950 --> 00:13:45,610
requesting the additional data from the

00:13:40,540 --> 00:13:48,400
API after that we're sending a request

00:13:45,610 --> 00:13:51,580
over network to our node.js server in

00:13:48,400 --> 00:13:53,800
order to render our nunchuks template so

00:13:51,580 --> 00:13:55,690
here where it becomes different we're

00:13:53,800 --> 00:13:58,840
starting rendering with node.js server

00:13:55,690 --> 00:14:01,360
over network and that's we were able to

00:13:58,840 --> 00:14:04,840
enable JavaScript rendering on the

00:14:01,360 --> 00:14:06,850
server side is it first before it

00:14:04,840 --> 00:14:10,420
renders the template as far as it is it

00:14:06,850 --> 00:14:12,490
can go until additional data is needed

00:14:10,420 --> 00:14:14,020
and at this point it returns back

00:14:12,490 --> 00:14:17,680
partially rendered template as a

00:14:14,020 --> 00:14:19,390
response and our Python Django web

00:14:17,680 --> 00:14:24,360
server requests more data from the

00:14:19,390 --> 00:14:27,580
backend API so now we repeat the process

00:14:24,360 --> 00:14:30,610
but the only difference is now we can

00:14:27,580 --> 00:14:33,550
send multiple requests one for each sub

00:14:30,610 --> 00:14:37,390
tree in order to paralyze rendering

00:14:33,550 --> 00:14:41,890
process and we rendered it as far as we

00:14:37,390 --> 00:14:48,580
can go again and this process is not CPU

00:14:41,890 --> 00:14:50,680
blocking anymore so after a both sub

00:14:48,580 --> 00:14:53,440
trees are rendered in parallel we send

00:14:50,680 --> 00:14:55,900
back independent responses to the to the

00:14:53,440 --> 00:14:58,320
passenger junga web server and we

00:14:55,900 --> 00:15:00,460
continue process again and again

00:14:58,320 --> 00:15:05,500
requesting additional data if it's

00:15:00,460 --> 00:15:06,970
needed we send multiple requests and we

00:15:05,500 --> 00:15:10,090
continue rendering until the tree is

00:15:06,970 --> 00:15:14,890
fully rendered and at this point we send

00:15:10,090 --> 00:15:16,630
the resulting HTML to the user agent so

00:15:14,890 --> 00:15:18,520
if you can see the approach is very

00:15:16,630 --> 00:15:20,800
similar to what we had before but now

00:15:18,520 --> 00:15:24,090
we're rendering JavaScript templates on

00:15:20,800 --> 00:15:26,830
a standalone node.js servers server and

00:15:24,090 --> 00:15:29,260
you can use this approach in many

00:15:26,830 --> 00:15:32,680
different languages we use it in iPhone

00:15:29,260 --> 00:15:35,529
but if you are in Java or PHP or you

00:15:32,680 --> 00:15:39,220
something else even like cold fusion

00:15:35,529 --> 00:15:43,450
someone is using it still then you can

00:15:39,220 --> 00:15:45,190
use the same approach so now at this

00:15:43,450 --> 00:15:49,630
point we were able to solve our first

00:15:45,190 --> 00:15:51,040
challenge and we can render nunchucks

00:15:49,630 --> 00:15:53,680
templates on the client and on the

00:15:51,040 --> 00:16:05,470
server and now we can go ahead and solve

00:15:53,680 --> 00:16:07,060
our second challenge let me provide a

00:16:05,470 --> 00:16:11,320
little bit of context about the old

00:16:07,060 --> 00:16:12,790
framework Denzel Denzel is very very

00:16:11,320 --> 00:16:14,830
similar to many other frameworks that

00:16:12,790 --> 00:16:18,820
were introduced three four or five years

00:16:14,830 --> 00:16:21,399
ago its component based framework and

00:16:18,820 --> 00:16:24,060
uses object-oriented inheritance

00:16:21,399 --> 00:16:28,930
approach and on this slide you can see

00:16:24,060 --> 00:16:32,080
two nunchuks statements and one of them

00:16:28,930 --> 00:16:35,980
is old denzel module code and another

00:16:32,080 --> 00:16:38,500
one is new react component code and as I

00:16:35,980 --> 00:16:41,650
mentioned before module is a function

00:16:38,500 --> 00:16:43,930
call it basically converts to JavaScript

00:16:41,650 --> 00:16:46,930
call which will render for us Oh Denzel

00:16:43,930 --> 00:16:49,180
component since it the same applies to

00:16:46,930 --> 00:16:50,980
the component called component calls

00:16:49,180 --> 00:16:53,950
another function call but it falls back

00:16:50,980 --> 00:16:56,020
to react rendering so in order to

00:16:53,950 --> 00:16:58,839
empower our engineers to migrate our

00:16:56,020 --> 00:17:01,570
service incrementally with tweak than

00:16:58,839 --> 00:17:04,030
Jax code and we introduced a new keyword

00:17:01,570 --> 00:17:06,900
component which represents the bridge

00:17:04,030 --> 00:17:11,319
between Denzel and react

00:17:06,900 --> 00:17:13,030
so once nunchuks rendering its component

00:17:11,319 --> 00:17:15,730
keyword it will render it Denzel react

00:17:13,030 --> 00:17:18,880
bridge instead and on the slide you can

00:17:15,730 --> 00:17:21,610
see a simplified version of Denzel reg

00:17:18,880 --> 00:17:26,530
bridge which is a Denzel module which

00:17:21,610 --> 00:17:27,550
will render for us react component let's

00:17:26,530 --> 00:17:32,260
take a look how it works

00:17:27,550 --> 00:17:35,890
so once the component is added to the

00:17:32,260 --> 00:17:37,660
Dom it will read its own options and it

00:17:35,890 --> 00:17:42,070
will figure out the name of the react

00:17:37,660 --> 00:17:44,050
component that they want to render and

00:17:42,070 --> 00:17:46,100
it will render this component passing

00:17:44,050 --> 00:17:48,140
all the options to the properties

00:17:46,100 --> 00:17:52,970
the rendering will happen in its own

00:17:48,140 --> 00:17:55,520
container Dom element so this is pretty

00:17:52,970 --> 00:17:57,860
simple but pretty powerful technique and

00:17:55,520 --> 00:17:59,570
you can use it in many other JavaScript

00:17:57,860 --> 00:18:02,030
libraries if you want to migrate from

00:17:59,570 --> 00:18:04,850
one library to react and you want to use

00:18:02,030 --> 00:18:09,440
the same libraries together during

00:18:04,850 --> 00:18:12,200
period of migration some of you may ask

00:18:09,440 --> 00:18:14,870
a really good question how react will

00:18:12,200 --> 00:18:18,050
reuse the services rendered markup on

00:18:14,870 --> 00:18:21,140
the client-side and this is a really

00:18:18,050 --> 00:18:23,180
cool feature of react because once the

00:18:21,140 --> 00:18:26,330
HTML is rendered on the server-side

00:18:23,180 --> 00:18:30,470
react to automatically add a checksum to

00:18:26,330 --> 00:18:33,950
it and after the web app is initialized

00:18:30,470 --> 00:18:37,040
react to render the HTML in its own

00:18:33,950 --> 00:18:39,500
virtual Dom not a real dumb but virtual

00:18:37,040 --> 00:18:41,780
Dom and will generate another checksum

00:18:39,500 --> 00:18:43,700
and if this checks I'm sorry the same

00:18:41,780 --> 00:18:45,740
that means that we can reuse the

00:18:43,700 --> 00:18:48,380
existing HTML and will not have to

00:18:45,740 --> 00:18:50,330
change the Dom elements at all this is

00:18:48,380 --> 00:18:53,840
pretty important for many performance

00:18:50,330 --> 00:18:56,450
optimizations and also it reduces UI

00:18:53,840 --> 00:18:58,970
flickering that you might see when Dom

00:18:56,450 --> 00:19:01,520
has changed after javascript is

00:18:58,970 --> 00:19:07,460
initialized think it's one of the really

00:19:01,520 --> 00:19:09,140
cool features of react so now since we

00:19:07,460 --> 00:19:11,390
can render react components inside of

00:19:09,140 --> 00:19:14,600
the old framework we can deal with the

00:19:11,390 --> 00:19:18,530
old resource later and more likely in

00:19:14,600 --> 00:19:21,290
your project you have ajax library or

00:19:18,530 --> 00:19:23,540
library that is building on top of ajax

00:19:21,290 --> 00:19:25,730
request that does all the communication

00:19:23,540 --> 00:19:28,250
to the api for you and certain serves

00:19:25,730 --> 00:19:30,200
all the data from the server to to the

00:19:28,250 --> 00:19:31,880
client and probably at least for the

00:19:30,200 --> 00:19:34,460
first period of time of migration you

00:19:31,880 --> 00:19:36,800
really want to reuse this library and

00:19:34,460 --> 00:19:40,250
for that purpose we use powder

00:19:36,800 --> 00:19:42,110
components as adaptors if you don't know

00:19:40,250 --> 00:19:44,630
how the component is a very powerful

00:19:42,110 --> 00:19:46,280
technique that helps you to reuse

00:19:44,630 --> 00:19:49,400
components logic while remaining

00:19:46,280 --> 00:19:51,110
components composable it's a function

00:19:49,400 --> 00:19:53,450
that takes a component and returns

00:19:51,110 --> 00:19:55,130
another component I know it may sound a

00:19:53,450 --> 00:19:56,900
little bit confusing but let's take a

00:19:55,130 --> 00:19:58,750
look to the example and I think

00:19:56,900 --> 00:20:01,580
everything will be clear

00:19:58,750 --> 00:20:05,600
so on this slide you can see on the left

00:20:01,580 --> 00:20:09,110
side it's a hoc with the resource that

00:20:05,600 --> 00:20:11,809
helps us to communicate with the API and

00:20:09,110 --> 00:20:13,549
with the older resource layer and on the

00:20:11,809 --> 00:20:17,990
right side you can see the example of

00:20:13,549 --> 00:20:24,679
usage of hoc with resource so what

00:20:17,990 --> 00:20:27,080
happens on component it mount when the

00:20:24,679 --> 00:20:30,909
component is already in the Dom it will

00:20:27,080 --> 00:20:34,669
send a request to the resource layer and

00:20:30,909 --> 00:20:37,700
once the data comes back it will change

00:20:34,669 --> 00:20:41,870
its own state thus it will render its

00:20:37,700 --> 00:20:45,590
own components and no trigger rendering

00:20:41,870 --> 00:20:47,539
of the of the child this is pretty

00:20:45,590 --> 00:20:50,330
simple but pretty powerful technique

00:20:47,539 --> 00:20:52,340
that helps a lot in migrations like that

00:20:50,330 --> 00:20:54,620
and you can use it for many other things

00:20:52,340 --> 00:20:56,870
not only for dealing with resources but

00:20:54,620 --> 00:21:00,070
this one is the main one for example if

00:20:56,870 --> 00:21:03,049
you have some experiments layer or

00:21:00,070 --> 00:21:06,110
something else you can always make sure

00:21:03,049 --> 00:21:08,120
that the newly created reaction ponents

00:21:06,110 --> 00:21:13,639
and architecture are always in sync with

00:21:08,120 --> 00:21:16,850
the with the with this layer so now we

00:21:13,639 --> 00:21:19,190
can render nunchuks on the server we can

00:21:16,850 --> 00:21:22,070
render react on the server on the client

00:21:19,190 --> 00:21:32,090
and now we can move forward and solve

00:21:22,070 --> 00:21:34,309
our last and fourth challenge so now

00:21:32,090 --> 00:21:37,029
we're talking about UI experiments and

00:21:34,309 --> 00:21:40,639
this is the most exciting part for me

00:21:37,029 --> 00:21:42,889
with more than 200 200 millions of

00:21:40,639 --> 00:21:44,870
monthly active users we have to roll out

00:21:42,889 --> 00:21:47,539
things very carefully because we have to

00:21:44,870 --> 00:21:49,039
make sure that our newly created UI is

00:21:47,539 --> 00:21:51,850
actually performing better than the old

00:21:49,039 --> 00:21:54,679
one and for that purpose we use

00:21:51,850 --> 00:21:55,789
gatekeeper a be testing framework and if

00:21:54,679 --> 00:21:59,750
you have something similar in your

00:21:55,789 --> 00:22:01,610
project it's super handy normally maybe

00:21:59,750 --> 00:22:03,620
testing frameworks are used to compare

00:22:01,610 --> 00:22:04,669
different UIs and see how they behave

00:22:03,620 --> 00:22:07,519
and measure

00:22:04,669 --> 00:22:11,090
the data and impact but you can use

00:22:07,519 --> 00:22:14,419
these frameworks as well for for

00:22:11,090 --> 00:22:17,629
migrations or factoring like that so on

00:22:14,419 --> 00:22:20,149
this slide you can see there is a very

00:22:17,629 --> 00:22:22,669
simplified version of forking logic

00:22:20,149 --> 00:22:25,369
based off on experiment check and if

00:22:22,669 --> 00:22:27,679
user is in the react experiment then we

00:22:25,369 --> 00:22:29,950
render newly created react component and

00:22:27,679 --> 00:22:34,659
otherwise we'll fall back to the old

00:22:29,950 --> 00:22:37,519
Denzel module now let's take a look

00:22:34,659 --> 00:22:40,129
deeper at the experiment setup you can

00:22:37,519 --> 00:22:45,320
see component tree or module tree on the

00:22:40,129 --> 00:22:47,690
right side and this component tree at

00:22:45,320 --> 00:22:49,369
some node something zell node you can

00:22:47,690 --> 00:22:52,519
see that we are forking our experiment

00:22:49,369 --> 00:22:55,070
logic and the whole right subtree is

00:22:52,519 --> 00:22:59,149
still rendered in in denzel but the left

00:22:55,070 --> 00:23:03,230
one is in react so worse to mention that

00:22:59,149 --> 00:23:05,840
once a node is converted to component

00:23:03,230 --> 00:23:08,840
call old children and descendants are

00:23:05,840 --> 00:23:11,359
necessarily in reality basically there

00:23:08,840 --> 00:23:13,129
is call of react inside of Denzel but

00:23:11,359 --> 00:23:15,799
there is no call of the ins on one side

00:23:13,129 --> 00:23:18,320
of react and this is done on purpose

00:23:15,799 --> 00:23:21,019
because it helps you to move faster and

00:23:18,320 --> 00:23:23,480
also it will be total mess if you start

00:23:21,019 --> 00:23:25,399
calling react inside of themselves and

00:23:23,480 --> 00:23:27,139
then downside of react and vice-versa

00:23:25,399 --> 00:23:33,619
you don't want to you really don't want

00:23:27,139 --> 00:23:36,320
to do this because of that we had to

00:23:33,619 --> 00:23:39,019
convert our components from the very

00:23:36,320 --> 00:23:43,399
leaves moving to the very top and we

00:23:39,019 --> 00:23:45,950
call it bottom-up approach also it's

00:23:43,399 --> 00:23:48,289
worse to mention that you probably want

00:23:45,950 --> 00:23:50,480
to run your experiments at maximum per

00:23:48,289 --> 00:23:53,179
page level and you don't want to compare

00:23:50,480 --> 00:23:55,340
your old web up to the new one otherwise

00:23:53,179 --> 00:23:57,590
you have too many factors affecting your

00:23:55,340 --> 00:24:00,379
data and you'll never be able to figure

00:23:57,590 --> 00:24:04,429
out why you have metrics drops or why I

00:24:00,379 --> 00:24:06,049
have maybe metric improvements also it's

00:24:04,429 --> 00:24:08,950
forced to mention that you really want

00:24:06,049 --> 00:24:10,850
to run your experiments exclusively and

00:24:08,950 --> 00:24:12,559
otherwise you'll have the same issue

00:24:10,850 --> 00:24:16,690
because different experiments will

00:24:12,559 --> 00:24:16,690
affect the same metrics

00:24:21,840 --> 00:24:28,720
later on you can login into your

00:24:25,660 --> 00:24:31,179
experiments dashboard and see different

00:24:28,720 --> 00:24:33,160
metrics so while we were running

00:24:31,179 --> 00:24:35,350
immigration like that we were comparing

00:24:33,160 --> 00:24:37,809
reacting Denzel to many different

00:24:35,350 --> 00:24:40,179
metrics like engagement metrics or error

00:24:37,809 --> 00:24:42,250
rate performance metrics and so on and

00:24:40,179 --> 00:24:45,429
so forth on this slide you can see a

00:24:42,250 --> 00:24:46,870
screenshot of the dashboard and you can

00:24:45,429 --> 00:24:48,850
see there is a bunch of metrics on the

00:24:46,870 --> 00:24:51,280
left side and there is a bunch of

00:24:48,850 --> 00:24:53,230
squares on the right side the ones that

00:24:51,280 --> 00:24:56,380
without color they actually gray and

00:24:53,230 --> 00:24:59,049
means that there is no not enough data

00:24:56,380 --> 00:25:00,700
to calculate the numbers so they will be

00:24:59,049 --> 00:25:03,929
statistically significant

00:25:00,700 --> 00:25:06,130
the red ones means there is a drop and

00:25:03,929 --> 00:25:09,730
the blue ones means there is improvement

00:25:06,130 --> 00:25:11,169
if there is a job you probably really

00:25:09,730 --> 00:25:13,030
want to investigate it and figure out

00:25:11,169 --> 00:25:14,650
maybe you introduced a bug or maybe

00:25:13,030 --> 00:25:18,370
there is a performance issues that

00:25:14,650 --> 00:25:21,309
affecting your user it's important to

00:25:18,370 --> 00:25:23,470
say that during migrations like that you

00:25:21,309 --> 00:25:25,840
may have a bunch of outta task unit

00:25:23,470 --> 00:25:28,450
tests manual testing and things like

00:25:25,840 --> 00:25:31,830
that but unlikely they will cover all

00:25:28,450 --> 00:25:34,120
the edge cases for example what if your

00:25:31,830 --> 00:25:36,580
well what if in your web app there is

00:25:34,120 --> 00:25:39,429
something going on wrong in in different

00:25:36,580 --> 00:25:42,250
language or what if people with poor

00:25:39,429 --> 00:25:44,200
internet connection they having some

00:25:42,250 --> 00:25:47,140
issues and it's really hard to catch

00:25:44,200 --> 00:25:49,660
things like that using unit tests or out

00:25:47,140 --> 00:25:51,340
a test or anything else but maybe

00:25:49,660 --> 00:25:53,440
testing frameworks and measuring that

00:25:51,340 --> 00:25:54,790
your data will always give you a signal

00:25:53,440 --> 00:26:01,240
that something is going wrong and you

00:25:54,790 --> 00:26:03,970
can start investigating so interest

00:26:01,240 --> 00:26:05,919
profiles were the first user heavy page

00:26:03,970 --> 00:26:09,130
that was successful immigrated to

00:26:05,919 --> 00:26:10,870
reality and during react migration we've

00:26:09,130 --> 00:26:13,179
seen consistent performance and

00:26:10,870 --> 00:26:15,760
engagement improvements for example

00:26:13,179 --> 00:26:19,480
metrics like Dom interactive or board

00:26:15,760 --> 00:26:22,090
page views were up to 20% and we got

00:26:19,480 --> 00:26:24,220
this 20% just from changing the gears

00:26:22,090 --> 00:26:27,250
and infrastructure without actually

00:26:24,220 --> 00:26:30,250
changing UI adult I think this is pretty

00:26:27,250 --> 00:26:31,500
cool getting 20% from without changing

00:26:30,250 --> 00:26:34,570
the

00:26:31,500 --> 00:26:36,340
during migration our engineers our

00:26:34,570 --> 00:26:39,040
product engineers they were able to

00:26:36,340 --> 00:26:41,290
continue changing the service and they

00:26:39,040 --> 00:26:43,570
were able to ship different features and

00:26:41,290 --> 00:26:49,960
run different experiments in the rest of

00:26:43,570 --> 00:26:52,559
the website and finally all these leads

00:26:49,960 --> 00:26:57,010
to completely new developer experience

00:26:52,559 --> 00:27:00,549
now we don't have duplicating nunchucks

00:26:57,010 --> 00:27:03,160
and ginger libraries there is no need to

00:27:00,549 --> 00:27:06,370
learn nunchucks at all that makes the

00:27:03,160 --> 00:27:08,140
onboarding process much easier there is

00:27:06,370 --> 00:27:10,150
single language on the client and on the

00:27:08,140 --> 00:27:14,080
server side which makes life of our

00:27:10,150 --> 00:27:15,880
engineers even more easier and finally

00:27:14,080 --> 00:27:18,040
we are part of the large developer

00:27:15,880 --> 00:27:19,990
community and there is no need in wiki

00:27:18,040 --> 00:27:23,440
pages there is a lot of well-crafted

00:27:19,990 --> 00:27:25,450
examples and documentation online it's

00:27:23,440 --> 00:27:29,470
been a long journey but we're excited to

00:27:25,450 --> 00:27:31,240
be part of react community thank you and

00:27:29,470 --> 00:27:33,809
if you have any questions feel free to

00:27:31,240 --> 00:27:33,809
find me in

00:27:41,120 --> 00:27:43,180

YouTube URL: https://www.youtube.com/watch?v=dLmLNlLlHkM


