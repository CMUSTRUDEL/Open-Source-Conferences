Title: Stefan Judis: Watch your back, Browser! You're being observed | JSConf Budapest 2017
Publication date: 2017-12-01
Playlist: JSConf Budapest 2017
Description: 
	Keeping track of Browser APIs is tough. Even experienced developers tend to solve the same problems with the same old solutions. What if I could tell you that common problems can be solved with new APIs? Letâ€™s have a look at the Observer/Observable APIs and see how these could make our life easier.

http://jsconfbp.com/speakers/stefan-judis/
Captions: 
	00:00:03,680 --> 00:00:12,030
hello everybody I was gone that's the

00:00:09,510 --> 00:00:14,870
most beautiful venue ever but probably

00:00:12,030 --> 00:00:16,800
every speaker will tell that

00:00:14,870 --> 00:00:21,920
watch your back brows are you being

00:00:16,800 --> 00:00:25,380
observed let me quickly introduce myself

00:00:21,920 --> 00:00:29,130
I'm Stefan sometimes I look like that

00:00:25,380 --> 00:00:31,320
who has been at CSS comp yesterday yeah

00:00:29,130 --> 00:00:33,180
this is an initiative that is called one

00:00:31,320 --> 00:00:37,010
zjs so if you want to join us feel free

00:00:33,180 --> 00:00:39,719
it's a lot of fun it's a very fluffy so

00:00:37,010 --> 00:00:41,040
definitely really cool thing I'm a

00:00:39,719 --> 00:00:43,500
front-end developer from Berlin

00:00:41,040 --> 00:00:46,170
I'm occasionally teaching CSS and node

00:00:43,500 --> 00:00:48,480
and I'm organizing the web performance

00:00:46,170 --> 00:00:50,969
meetup in Berlin and my main focus these

00:00:48,480 --> 00:00:53,430
days is open source performance where

00:00:50,969 --> 00:00:55,020
performance and accessibility and I work

00:00:53,430 --> 00:00:58,109
for a company that is called contentful

00:00:55,020 --> 00:00:59,910
so we are a content management system in

00:00:58,109 --> 00:01:03,300
the cloud this means that if you need a

00:00:59,910 --> 00:01:05,040
CMS you can simply register give your

00:01:03,300 --> 00:01:06,780
editors or non-technical people a web

00:01:05,040 --> 00:01:10,350
interface and you as a developer then

00:01:06,780 --> 00:01:13,770
only have to work with a with an API and

00:01:10,350 --> 00:01:15,390
this is what you do anyways and with

00:01:13,770 --> 00:01:17,310
content all we always say editors get a

00:01:15,390 --> 00:01:18,780
CMS and we as developers don't actually

00:01:17,310 --> 00:01:22,560
have to work with one which is really

00:01:18,780 --> 00:01:26,780
really nice and last fact about myself

00:01:22,560 --> 00:01:29,040
is I'm really excited about conferences

00:01:26,780 --> 00:01:31,140
because you can learn so much stuff and

00:01:29,040 --> 00:01:32,909
you can meet a lot of new people you can

00:01:31,140 --> 00:01:35,100
have an excellent time you can make new

00:01:32,909 --> 00:01:39,630
friends and these conferences helped me

00:01:35,100 --> 00:01:43,140
to stay up-to-date because the web

00:01:39,630 --> 00:01:46,110
platform today involves really really

00:01:43,140 --> 00:01:48,479
fast and we are finally yearly egg must

00:01:46,110 --> 00:01:52,100
releases new API browser api's are

00:01:48,479 --> 00:01:55,979
coming out every day and we finally have

00:01:52,100 --> 00:01:56,700
evergreen browsers right I'm really

00:01:55,979 --> 00:02:01,950
happy about that

00:01:56,700 --> 00:02:05,310
and staying up to date is kind of part

00:02:01,950 --> 00:02:07,560
of our job and I personally have a hate

00:02:05,310 --> 00:02:09,190
love relationship with that because

00:02:07,560 --> 00:02:14,650
every day

00:02:09,190 --> 00:02:17,410
we're dealing with this a new tool every

00:02:14,650 --> 00:02:19,930
week but then the same time browser

00:02:17,410 --> 00:02:21,520
api's adapt to common use cases right

00:02:19,930 --> 00:02:23,710
let's think of jQuery and the dollar

00:02:21,520 --> 00:02:25,870
selector today we've got document query

00:02:23,710 --> 00:02:28,150
selector all and the browser api's are

00:02:25,870 --> 00:02:32,140
slowly moving from a pool model where we

00:02:28,150 --> 00:02:37,150
have to ask for information to push

00:02:32,140 --> 00:02:41,700
model and what I want to show you today

00:02:37,150 --> 00:02:44,460
is what that actually means but first I

00:02:41,700 --> 00:02:46,930
think we should celebrate

00:02:44,460 --> 00:02:51,250
because we've got a lot of cool new

00:02:46,930 --> 00:02:53,830
stuff today and we're here and I believe

00:02:51,250 --> 00:02:55,960
we will have two excellent days so what

00:02:53,830 --> 00:02:58,360
I did is I took the J's computer pest

00:02:55,960 --> 00:03:03,480
website this is how it looks like this

00:02:58,360 --> 00:03:07,720
is the schedule looks good to me

00:03:03,480 --> 00:03:12,040
but I think we can bring a little bit

00:03:07,720 --> 00:03:16,209
more celebration in there so I spice it

00:03:12,040 --> 00:03:18,190
up a little bit with a fancy lazy

00:03:16,209 --> 00:03:19,330
loading effect in case you don't know

00:03:18,190 --> 00:03:23,020
that one that's the Twitter heart

00:03:19,330 --> 00:03:25,959
animation and I stole it from a nap

00:03:23,020 --> 00:03:28,959
tutor who does crazy stuff in CSS and

00:03:25,959 --> 00:03:31,090
this is done with one element so how

00:03:28,959 --> 00:03:33,100
would you usually achieve this kind of

00:03:31,090 --> 00:03:34,390
effect but first you have to figure out

00:03:33,100 --> 00:03:36,580
if something is visible in the viewport

00:03:34,390 --> 00:03:42,970
right so how do you do that

00:03:36,580 --> 00:03:45,660
well I'd Google huh and then you sorry

00:03:42,970 --> 00:03:48,810
and then you end up at Stack Overflow

00:03:45,660 --> 00:03:52,060
who's guilty of copying this snippet

00:03:48,810 --> 00:03:54,100
come on probably more people here and

00:03:52,060 --> 00:03:57,280
then there's this piece of logic in

00:03:54,100 --> 00:04:00,310
there which I I'm always too lazy to

00:03:57,280 --> 00:04:04,180
think about that but this one got shot

00:04:00,310 --> 00:04:06,640
with this though this is calling element

00:04:04,180 --> 00:04:09,190
get bounding client rect and this

00:04:06,640 --> 00:04:10,239
function on and anuman at Dom element

00:04:09,190 --> 00:04:12,340
can trigger the browser to

00:04:10,239 --> 00:04:15,040
asynchronously Nino to synchronously

00:04:12,340 --> 00:04:17,169
calculate style and layout this happens

00:04:15,040 --> 00:04:19,710
when something changed like adding in

00:04:17,169 --> 00:04:21,930
class or something and this is a an

00:04:19,710 --> 00:04:23,220
expensive operation

00:04:21,930 --> 00:04:25,800
when you use this you should always

00:04:23,220 --> 00:04:28,370
batch all the reads and then write stuff

00:04:25,800 --> 00:04:31,710
but this is actually not cool because

00:04:28,370 --> 00:04:34,259
well we have to pull for information

00:04:31,710 --> 00:04:36,720
right we have to ask s Blissett li if

00:04:34,259 --> 00:04:38,400
you understand shion's are good to use

00:04:36,720 --> 00:04:41,759
performance wise Paul Irish is

00:04:38,400 --> 00:04:44,580
maintaining this document here and when

00:04:41,759 --> 00:04:46,139
you're doing these kind of things having

00:04:44,580 --> 00:04:51,630
a look there it's definitely a big help

00:04:46,139 --> 00:04:55,349
so what is next then well we define a

00:04:51,630 --> 00:04:57,479
scroll handler right which fires 1,000

00:04:55,349 --> 00:04:58,860
times when you scroll through a page and

00:04:57,479 --> 00:05:02,550
there's also something wrong with that

00:04:58,860 --> 00:05:04,530
because scroll or scroll handlers are

00:05:02,550 --> 00:05:08,460
really expensive operation by default

00:05:04,530 --> 00:05:11,639
and when we want to build great you eyes

00:05:08,460 --> 00:05:13,949
that stick under our fingers when we

00:05:11,639 --> 00:05:17,810
play around with our phones we always

00:05:13,949 --> 00:05:20,220
have to aim for 60 frames per second

00:05:17,810 --> 00:05:22,440
dividing one second by 60 means that we

00:05:20,220 --> 00:05:25,320
have 16 millisecond but this is actually

00:05:22,440 --> 00:05:27,870
not true because the browser has to do

00:05:25,320 --> 00:05:31,020
some other same things then just dealing

00:05:27,870 --> 00:05:34,130
with our JavaScript so in real time we

00:05:31,020 --> 00:05:37,800
have around 10 milliseconds to avoid

00:05:34,130 --> 00:05:39,659
janky scrolling this means that we want

00:05:37,800 --> 00:05:43,139
to do as less as possible in a scroll

00:05:39,659 --> 00:05:46,199
handler so what I did next is well I had

00:05:43,139 --> 00:05:49,020
to my developer tools of choice and I

00:05:46,199 --> 00:05:51,690
monitored the whole thing right these

00:05:49,020 --> 00:05:55,139
are the chrome dev tools and first thing

00:05:51,690 --> 00:05:57,300
I did is I throttled the CPU because

00:05:55,139 --> 00:05:59,639
this device here and we heard that

00:05:57,300 --> 00:06:04,050
yesterday already is not your average

00:05:59,639 --> 00:06:06,509
user not everybody has this kind of

00:06:04,050 --> 00:06:10,349
device and also not everybody has a

00:06:06,509 --> 00:06:13,889
latest or recent phone and then I

00:06:10,349 --> 00:06:19,080
checked the framerate of my cool lazy

00:06:13,889 --> 00:06:20,550
loading effect and well it was not that

00:06:19,080 --> 00:06:22,949
good right

00:06:20,550 --> 00:06:26,430
and when we look a little bit deeper we

00:06:22,949 --> 00:06:29,940
see that element get found inclined rect

00:06:26,430 --> 00:06:31,919
takes big part of that and in this

00:06:29,940 --> 00:06:33,210
example it took actually 12 milliseconds

00:06:31,919 --> 00:06:34,300
which means that we already hit the

00:06:33,210 --> 00:06:37,509
budget

00:06:34,300 --> 00:06:41,199
and this is firing on every scroll frame

00:06:37,509 --> 00:06:43,979
right this is really expensive so let me

00:06:41,199 --> 00:06:47,020
show you one solution to this problem

00:06:43,979 --> 00:06:48,610
the intersection observer the

00:06:47,020 --> 00:06:50,620
intersection observer is a method to s

00:06:48,610 --> 00:06:52,990
on personnel s synchronously query the

00:06:50,620 --> 00:06:55,949
position of an element with respect to

00:06:52,990 --> 00:06:59,259
other elements or the global viewport

00:06:55,949 --> 00:07:01,900
this means with this we don't have to do

00:06:59,259 --> 00:07:03,669
costly dumb and Styler queries and we

00:07:01,900 --> 00:07:06,250
don't have to pause for information

00:07:03,669 --> 00:07:10,090
using something like this helps us to

00:07:06,250 --> 00:07:13,449
reduce CPU GPU and energy costs to

00:07:10,090 --> 00:07:14,580
figure out if something is visible so

00:07:13,449 --> 00:07:16,719
how does that work

00:07:14,580 --> 00:07:19,960
here you see an intersection observer

00:07:16,719 --> 00:07:21,849
implementation first you have to define

00:07:19,960 --> 00:07:23,710
a threshold and in this case I'm going

00:07:21,849 --> 00:07:27,729
with one point zero which means that I

00:07:23,710 --> 00:07:30,280
want to get notified when an element is

00:07:27,729 --> 00:07:32,139
completely visible then you have to

00:07:30,280 --> 00:07:33,909
initialize a new intersection observer

00:07:32,139 --> 00:07:36,699
and this is then called with several

00:07:33,909 --> 00:07:39,009
intersection entries and these then have

00:07:36,699 --> 00:07:40,240
a intersecting property and then I'm

00:07:39,009 --> 00:07:40,930
adding a class that is called

00:07:40,240 --> 00:07:43,360
party-party

00:07:40,930 --> 00:07:45,699
and then I'm I'm observing the given

00:07:43,360 --> 00:07:48,759
element because well my job is done here

00:07:45,699 --> 00:07:51,750
and then I can just grab all the

00:07:48,759 --> 00:07:56,560
elements and can tell the observer hey

00:07:51,750 --> 00:08:00,009
can you please watch out here cool so in

00:07:56,560 --> 00:08:04,810
with an implementation like that we see

00:08:00,009 --> 00:08:07,419
that a now there is no get bound

00:08:04,810 --> 00:08:10,210
inclined direct anymore and this is not

00:08:07,419 --> 00:08:12,219
called onscroll and when we check the

00:08:10,210 --> 00:08:14,259
framerate we see that at least for

00:08:12,219 --> 00:08:17,469
figuring out if something is visible we

00:08:14,259 --> 00:08:19,509
end up at 60 frames per second I think

00:08:17,469 --> 00:08:21,159
this is really really cool so we're

00:08:19,509 --> 00:08:24,460
building these kind of things I always

00:08:21,159 --> 00:08:28,150
what I always try to do is take a moment

00:08:24,460 --> 00:08:29,830
and measure it measured using the dev

00:08:28,150 --> 00:08:33,669
tools of your choice use web page test

00:08:29,830 --> 00:08:36,159
or lighthouse and maybe try it on a real

00:08:33,669 --> 00:08:39,269
device which is not a six month old

00:08:36,159 --> 00:08:42,430
MacBook Pro so what options do we have

00:08:39,269 --> 00:08:45,100
for an intersection observer where we

00:08:42,430 --> 00:08:47,110
can define a different route element we

00:08:45,100 --> 00:08:47,640
can tell the intersection observer how

00:08:47,110 --> 00:08:50,370
this is

00:08:47,640 --> 00:08:52,529
and then we can define a threshold with

00:08:50,370 --> 00:08:54,510
which is a single value or several

00:08:52,529 --> 00:08:57,000
values and this is actually really

00:08:54,510 --> 00:09:00,360
really cool because when you define

00:08:57,000 --> 00:09:03,060
several values so in this example zero

00:09:00,360 --> 00:09:06,089
and one I get notified when something

00:09:03,060 --> 00:09:08,190
enters the viewport I get notified when

00:09:06,089 --> 00:09:09,779
it's completely visible I get notified

00:09:08,190 --> 00:09:11,940
when it starts leaving and when it's

00:09:09,779 --> 00:09:15,540
gone and this is only a few lines of

00:09:11,940 --> 00:09:20,220
JavaScript so let's have a look how this

00:09:15,540 --> 00:09:22,230
entry looks like that that I get when

00:09:20,220 --> 00:09:24,769
I'm notified that something becomes

00:09:22,230 --> 00:09:28,170
visible so here we see the viewport and

00:09:24,769 --> 00:09:30,930
here we see what happens when the

00:09:28,170 --> 00:09:32,880
element enters the viewport so the entry

00:09:30,930 --> 00:09:35,790
then has an is intersecting property

00:09:32,880 --> 00:09:37,640
which is true in this case and an

00:09:35,790 --> 00:09:41,850
intersection ratio which is something

00:09:37,640 --> 00:09:44,279
around zero here why something because

00:09:41,850 --> 00:09:46,890
the intersection observer works a sync

00:09:44,279 --> 00:09:49,829
so the browser figures out when it has

00:09:46,890 --> 00:09:52,440
time to figure out if something is

00:09:49,829 --> 00:09:54,269
visible so what happens when it leaves

00:09:52,440 --> 00:09:56,399
the viewport again we've got it

00:09:54,269 --> 00:09:58,380
intersecting faults and then we've got

00:09:56,399 --> 00:10:00,240
the intersection ratio of zero which

00:09:58,380 --> 00:10:03,360
makes sense because there's no value

00:10:00,240 --> 00:10:05,459
below zero right there was one thing

00:10:03,360 --> 00:10:08,550
though that surprised me so let's go

00:10:05,459 --> 00:10:12,089
with a value that is bigger than zero so

00:10:08,550 --> 00:10:15,329
when we have an in ratio or a threshold

00:10:12,089 --> 00:10:17,790
of 0.5 so something is entering the

00:10:15,329 --> 00:10:19,890
viewport so we can have is intersecting

00:10:17,790 --> 00:10:22,860
true and an intersection ratio again

00:10:19,890 --> 00:10:26,160
something around 0.5 but when it's now

00:10:22,860 --> 00:10:28,529
leaving the viewport roof cut is

00:10:26,160 --> 00:10:30,779
intersecting so true this surprised me

00:10:28,529 --> 00:10:33,600
initially because I was expecting it to

00:10:30,779 --> 00:10:35,490
be false but it's intersecting tells you

00:10:33,600 --> 00:10:36,990
if it's still in the viewport right and

00:10:35,490 --> 00:10:38,490
when we go with the threshold of 0.5

00:10:36,990 --> 00:10:40,290
this actually makes sense

00:10:38,490 --> 00:10:43,980
and the ratio then is something around

00:10:40,290 --> 00:10:47,190
0.5 and with the intersection observer

00:10:43,980 --> 00:10:49,260
then we can build really nice interfaces

00:10:47,190 --> 00:10:51,269
like something like that make stuff

00:10:49,260 --> 00:10:53,760
appear dissipate peer when something

00:10:51,269 --> 00:10:55,949
else changed in in the cutout of the

00:10:53,760 --> 00:11:00,000
viewport and this is 10 lines of

00:10:55,949 --> 00:11:00,550
JavaScript without googling I think this

00:11:00,000 --> 00:11:03,060
is real

00:11:00,550 --> 00:11:05,440
really cool and you can also use it for

00:11:03,060 --> 00:11:12,580
figuring out if something is visible in

00:11:05,440 --> 00:11:15,310
responsive web design so there are a lot

00:11:12,580 --> 00:11:15,940
of use cases for for the intersection

00:11:15,310 --> 00:11:18,579
observer

00:11:15,940 --> 00:11:25,810
so how's their support today after the

00:11:18,579 --> 00:11:29,529
section observer well it's not too bad I

00:11:25,810 --> 00:11:31,029
would say but there was one culture

00:11:29,529 --> 00:11:34,450
though when I started playing around

00:11:31,029 --> 00:11:37,240
with this I discovered that they have

00:11:34,450 --> 00:11:39,850
been incompatibilities between spec and

00:11:37,240 --> 00:11:41,200
vendors and people got together and were

00:11:39,850 --> 00:11:46,050
like okay we have to figure that out

00:11:41,200 --> 00:11:49,630
because some yeah let's figure that out

00:11:46,050 --> 00:11:53,980
but these are resolved since October 17

00:11:49,630 --> 00:11:56,320
with the release of edge 16 so it's now

00:11:53,980 --> 00:11:58,360
ready to go the only thing I would want

00:11:56,320 --> 00:12:00,220
to tell you is when you use this without

00:11:58,360 --> 00:12:02,769
a polyfill or something just watch out

00:12:00,220 --> 00:12:05,050
and read maybe the issues and see if

00:12:02,769 --> 00:12:10,300
there are issues or if you run into

00:12:05,050 --> 00:12:11,470
these but how's the polyfill is this

00:12:10,300 --> 00:12:14,440
poly fillable at all

00:12:11,470 --> 00:12:16,930
it is and the polyfill also takes care

00:12:14,440 --> 00:12:20,920
of this incompatibilities so this is

00:12:16,930 --> 00:12:23,290
usable in production today so we

00:12:20,920 --> 00:12:27,550
celebrated every talk here now I think

00:12:23,290 --> 00:12:31,740
we can do more so let's celebrate the

00:12:27,550 --> 00:12:31,740
whole schedule ready

00:12:42,950 --> 00:12:46,760
if you get in case you don't know that

00:12:44,779 --> 00:12:50,209
there's a third-party library that is

00:12:46,760 --> 00:12:53,329
called cornified so I highly recommend

00:12:50,209 --> 00:12:56,000
it so not got the problem the

00:12:53,329 --> 00:12:57,139
intersection observer code was wrapped

00:12:56,000 --> 00:12:59,389
in and immediately invoked function

00:12:57,139 --> 00:13:01,220
expression so if no idea when something

00:12:59,389 --> 00:13:03,199
changed or there are no callbacks no

00:13:01,220 --> 00:13:07,519
events or something how could I now

00:13:03,199 --> 00:13:08,440
figure out that my party party class was

00:13:07,519 --> 00:13:13,010
added

00:13:08,440 --> 00:13:14,990
well let's need another observer here

00:13:13,010 --> 00:13:16,699
the a beautician observer provides

00:13:14,990 --> 00:13:20,889
developers with a way to react to

00:13:16,699 --> 00:13:22,790
changes in the Dom so how does that work

00:13:20,889 --> 00:13:25,760
so here we see a basic implementation

00:13:22,790 --> 00:13:28,100
and what I do is I grab the whole

00:13:25,760 --> 00:13:32,779
schedule then I grab all the speaker's

00:13:28,100 --> 00:13:34,519
then I define a config object which that

00:13:32,779 --> 00:13:35,300
the which defines that the mutation

00:13:34,519 --> 00:13:38,630
observers should watch out for

00:13:35,300 --> 00:13:41,029
attributes and the whole subtree then I

00:13:38,630 --> 00:13:44,920
initialize a new mutation observer and

00:13:41,029 --> 00:13:47,990
then I get notified when there was a a

00:13:44,920 --> 00:13:49,550
in na a net will change and then I'm

00:13:47,990 --> 00:13:52,399
just checking if the element now

00:13:49,550 --> 00:13:54,589
includes the class party party and then

00:13:52,399 --> 00:13:58,459
I'm counting up and if this is done I'm

00:13:54,589 --> 00:14:00,170
calling Korn if I edge and then well I'm

00:13:58,459 --> 00:14:03,560
just telling the mutation observer all

00:14:00,170 --> 00:14:07,010
right please check out or watch out for

00:14:03,560 --> 00:14:08,930
or observe this element what options do

00:14:07,010 --> 00:14:11,740
we have for mutation observer we can

00:14:08,930 --> 00:14:15,320
define if we want to observe children

00:14:11,740 --> 00:14:17,870
attributes whole sub trees and they are

00:14:15,320 --> 00:14:20,690
way way way more options to define so

00:14:17,870 --> 00:14:24,529
you can check out the spec or the mdn

00:14:20,690 --> 00:14:31,339
entry for that how is the supporter for

00:14:24,529 --> 00:14:32,990
the mutation observer pretty green you

00:14:31,339 --> 00:14:36,140
might not meet this observer very often

00:14:32,990 --> 00:14:39,290
but if so this is extremely helpful and

00:14:36,140 --> 00:14:41,810
I use cornified here now and I'm also

00:14:39,290 --> 00:14:43,519
I'm kind of a web performance person and

00:14:41,810 --> 00:14:45,589
when you do something like that what I

00:14:43,519 --> 00:14:48,170
want to tell you also is but let's

00:14:45,589 --> 00:14:50,000
always watch out for performance right

00:14:48,170 --> 00:14:50,389
and measuring performance can be done in

00:14:50,000 --> 00:14:53,480
two ways

00:14:50,389 --> 00:14:55,860
there is synthetic monitoring this

00:14:53,480 --> 00:15:00,570
basically means that you send a robot

00:14:55,860 --> 00:15:03,930
your sites gather some metrics and see

00:15:00,570 --> 00:15:05,670
how you're doing that way on there's

00:15:03,930 --> 00:15:08,720
also real user monitoring which means

00:15:05,670 --> 00:15:11,490
that you implement some JavaScript and

00:15:08,720 --> 00:15:16,280
you get the metrics right off out of the

00:15:11,490 --> 00:15:16,280
browser's or of your visitors or users

00:15:16,370 --> 00:15:21,840
for synthetic monitoring in case you

00:15:19,680 --> 00:15:22,890
don't know it really handy tool is

00:15:21,840 --> 00:15:27,720
called webpagetest

00:15:22,890 --> 00:15:29,820
and what you can do there is you can

00:15:27,720 --> 00:15:35,450
enter a website can define a connection

00:15:29,820 --> 00:15:38,880
speed a location and then you get get

00:15:35,450 --> 00:15:40,890
metrics afterwards if you wonder how

00:15:38,880 --> 00:15:43,440
people make these kind of comparison

00:15:40,890 --> 00:15:46,200
videos compare videos of two websites to

00:15:43,440 --> 00:15:48,810
see what is loading when this is all

00:15:46,200 --> 00:15:51,990
done with web page tests and this also

00:15:48,810 --> 00:15:54,570
then gives you turned on and on tips and

00:15:51,990 --> 00:15:56,610
tricks and a lot of useful stuff so if

00:15:54,570 --> 00:16:01,140
you haven't used that yet give it a try

00:15:56,610 --> 00:16:03,450
it's a really really powerful tool but

00:16:01,140 --> 00:16:06,120
this is only one moment in time if you

00:16:03,450 --> 00:16:07,500
look for constant or continuous and

00:16:06,120 --> 00:16:09,540
performance measurements

00:16:07,500 --> 00:16:12,060
tools like speed curve or calibre can

00:16:09,540 --> 00:16:14,400
help you out there but I want to

00:16:12,060 --> 00:16:15,840
actually talk about our real user

00:16:14,400 --> 00:16:17,820
metrics and what we have there today is

00:16:15,840 --> 00:16:21,630
the navigation timing API the resource

00:16:17,820 --> 00:16:24,060
timing API and the user timing API so

00:16:21,630 --> 00:16:26,280
let's have a quick look at what we get

00:16:24,060 --> 00:16:29,310
out of these api's so the navigation

00:16:26,280 --> 00:16:31,380
timing API is available via our window

00:16:29,310 --> 00:16:33,150
dot performance stop timing and this is

00:16:31,380 --> 00:16:35,070
an interface for a web application to

00:16:33,150 --> 00:16:39,090
access the complete timing information

00:16:35,070 --> 00:16:41,940
for the navigation of the document so

00:16:39,090 --> 00:16:44,070
what do we get here well there's a lot

00:16:41,940 --> 00:16:47,160
of stuff included this can be really

00:16:44,070 --> 00:16:49,800
useful information if you measure web

00:16:47,160 --> 00:16:50,550
performance there are stuff like how

00:16:49,800 --> 00:16:54,330
long did it

00:16:50,550 --> 00:16:56,580
TNS take how long did TCP take when did

00:16:54,330 --> 00:16:59,220
Dom content loaded all these kind of

00:16:56,580 --> 00:17:02,460
things are accessible via the navigation

00:16:59,220 --> 00:17:04,440
timing API and then there's also the

00:17:02,460 --> 00:17:06,300
resource timing API which is an

00:17:04,440 --> 00:17:08,040
interface for web applications to access

00:17:06,300 --> 00:17:09,960
the complete timing information for

00:17:08,040 --> 00:17:12,570
resources in a dark

00:17:09,960 --> 00:17:14,790
and you got more or less similar data

00:17:12,570 --> 00:17:16,560
there a few entries are missing but

00:17:14,790 --> 00:17:18,240
let's think of style sheets right style

00:17:16,560 --> 00:17:22,830
sheets are render blocking resources

00:17:18,240 --> 00:17:25,740
maybe you want to know when a style

00:17:22,830 --> 00:17:27,660
sheet is hanging around or not loading

00:17:25,740 --> 00:17:31,530
for 3 seconds because this is directly

00:17:27,660 --> 00:17:35,940
impacting user experience and then

00:17:31,530 --> 00:17:38,280
there's also the user timing API which

00:17:35,940 --> 00:17:41,850
is an interface to create application

00:17:38,280 --> 00:17:43,800
specific time stamps and you can measure

00:17:41,850 --> 00:17:45,300
for example navigations in a single page

00:17:43,800 --> 00:17:48,210
application something like that so let's

00:17:45,300 --> 00:17:51,030
measure how long my Corning fication

00:17:48,210 --> 00:17:54,020
took so here we see what happens when

00:17:51,030 --> 00:17:57,900
all talks have been seen and I can now

00:17:54,020 --> 00:18:00,060
set marks so I'm setting a mark before

00:17:57,900 --> 00:18:02,280
and right after and then I'm defining a

00:18:00,060 --> 00:18:05,820
measure which is the combination of both

00:18:02,280 --> 00:18:08,250
marks how can I access this information

00:18:05,820 --> 00:18:10,080
then how long it took well--there's

00:18:08,250 --> 00:18:13,020
window dot performance get entries by

00:18:10,080 --> 00:18:16,200
type mark and you see when it happened

00:18:13,020 --> 00:18:19,140
there and by using get entries pad type

00:18:16,200 --> 00:18:21,660
measure you see how long it took and you

00:18:19,140 --> 00:18:25,980
see in this example was 6 milliseconds

00:18:21,660 --> 00:18:29,550
which kind of fits into my budgets so

00:18:25,980 --> 00:18:32,190
real user metrics right today exists we

00:18:29,550 --> 00:18:33,840
can set mark measures so we've got marks

00:18:32,190 --> 00:18:36,600
measures and navigation resources and

00:18:33,840 --> 00:18:38,670
these are accessible via get entries get

00:18:36,600 --> 00:18:43,320
entries by type and get entries by name

00:18:38,670 --> 00:18:46,050
and that's pretty cool but this is not

00:18:43,320 --> 00:18:48,210
what we want because using this we have

00:18:46,050 --> 00:18:50,160
to pull for information we have to

00:18:48,210 --> 00:18:52,740
detect when there are new metrics we

00:18:50,160 --> 00:18:57,000
have to duplicate logic to figure out

00:18:52,740 --> 00:19:01,680
what is new so let me tell you the third

00:18:57,000 --> 00:19:03,330
one here the performance observer so

00:19:01,680 --> 00:19:05,250
this is how it works so you have to

00:19:03,330 --> 00:19:07,740
initialize a new performance observer

00:19:05,250 --> 00:19:09,390
and then you can define what you want to

00:19:07,740 --> 00:19:11,390
watch out for right in this case it's

00:19:09,390 --> 00:19:16,920
type measure and then you get notified

00:19:11,390 --> 00:19:19,210
and this is really cool because this way

00:19:16,920 --> 00:19:21,850
measurements are pushed toward

00:19:19,210 --> 00:19:23,710
me so I and I also had a look at the

00:19:21,850 --> 00:19:25,690
stack man and it was like what was

00:19:23,710 --> 00:19:27,490
written in there all right developers

00:19:25,690 --> 00:19:31,059
today are encouraged to use the

00:19:27,490 --> 00:19:31,659
performance observer all right I can

00:19:31,059 --> 00:19:32,980
deal with that

00:19:31,659 --> 00:19:35,590
but then there was also an interesting

00:19:32,980 --> 00:19:38,950
sentence which was like further new

00:19:35,590 --> 00:19:40,419
performance AP isometrics may only be

00:19:38,950 --> 00:19:47,020
available through the performance

00:19:40,419 --> 00:19:50,230
observer interface what new metrics are

00:19:47,020 --> 00:19:53,710
we talking about here so there is for

00:19:50,230 --> 00:19:56,860
example the paint timing API and this

00:19:53,710 --> 00:19:58,419
API gives us information for example

00:19:56,860 --> 00:20:00,429
when the first paint which means any

00:19:58,419 --> 00:20:02,409
painted pixel or when the first

00:20:00,429 --> 00:20:05,260
contentful paint happened which means

00:20:02,409 --> 00:20:08,409
that any text image non white canvas or

00:20:05,260 --> 00:20:11,380
SVG is rendered and this is shipping in

00:20:08,409 --> 00:20:14,260
chrome for example since chrome 60 and

00:20:11,380 --> 00:20:17,200
we're currently on chrome 61 this is

00:20:14,260 --> 00:20:20,620
also available using get entries by type

00:20:17,200 --> 00:20:22,779
and then there's also the long task API

00:20:20,620 --> 00:20:25,059
which tells us when JavaScript

00:20:22,779 --> 00:20:28,179
operations took longer than 50

00:20:25,059 --> 00:20:30,520
milliseconds and with these kind of

00:20:28,179 --> 00:20:32,409
things I've kept the metrics right at my

00:20:30,520 --> 00:20:34,960
fingertips right so this is for example

00:20:32,409 --> 00:20:36,640
my personal website and what you see

00:20:34,960 --> 00:20:42,429
there is that I have a local storage

00:20:36,640 --> 00:20:45,090
flag and with this this I get the

00:20:42,429 --> 00:20:47,830
information how long something took

00:20:45,090 --> 00:20:50,590
right on my face and I'm also relying on

00:20:47,830 --> 00:20:54,010
the content API here so I also see how

00:20:50,590 --> 00:20:56,500
long the API calls take but let's have a

00:20:54,010 --> 00:20:59,710
look at another example here so this is

00:20:56,500 --> 00:21:03,309
the Lando and what's the most important

00:20:59,710 --> 00:21:05,890
thing here well I would say it's the

00:21:03,309 --> 00:21:08,770
image right it's been 50% of the screen

00:21:05,890 --> 00:21:12,490
so how hard can it be to measure when

00:21:08,770 --> 00:21:14,169
this thing is rendered well today we

00:21:12,490 --> 00:21:17,260
have to do this we have to define the

00:21:14,169 --> 00:21:20,529
image with an onload handler this clears

00:21:17,260 --> 00:21:21,730
navigation timing API marks then inside

00:21:20,529 --> 00:21:23,590
the new mark and then we've got an

00:21:21,730 --> 00:21:25,270
inline script afterwards so what this

00:21:23,590 --> 00:21:26,630
basically does is whatever happens last

00:21:25,270 --> 00:21:29,480
is the right

00:21:26,630 --> 00:21:33,440
but this is not good experience at least

00:21:29,480 --> 00:21:36,290
in my mind so there are also new specs

00:21:33,440 --> 00:21:38,000
in the making for example like hero

00:21:36,290 --> 00:21:39,710
element timing this is currently really

00:21:38,000 --> 00:21:41,390
only in spec writing and discussing how

00:21:39,710 --> 00:21:42,770
we could implement that but with

00:21:41,390 --> 00:21:45,830
something like that we can get

00:21:42,770 --> 00:21:48,230
information when something crucial is

00:21:45,830 --> 00:21:49,760
rendered or laid out for example Twitter

00:21:48,230 --> 00:21:52,640
is constantly monitoring how long it

00:21:49,760 --> 00:21:54,470
takes until the first tweet is loading

00:21:52,640 --> 00:21:56,720
and this is really valuable information

00:21:54,470 --> 00:21:57,770
so let's see where this goes and just

00:21:56,720 --> 00:22:00,250
for the sake of completeness

00:21:57,770 --> 00:22:04,820
there's also server timing which rates

00:22:00,250 --> 00:22:08,030
which the server can set via an header a

00:22:04,820 --> 00:22:09,800
header and then this values can are

00:22:08,030 --> 00:22:13,370
easily accessible via the performance

00:22:09,800 --> 00:22:15,680
observer this only works in Canary

00:22:13,370 --> 00:22:18,350
though today if you're interested in

00:22:15,680 --> 00:22:19,790
more metrics regarding rep performance

00:22:18,350 --> 00:22:21,410
there's this excellent talk that is

00:22:19,790 --> 00:22:23,570
called leveraging the metrics that most

00:22:21,410 --> 00:22:27,380
affect user experience I'm highly

00:22:23,570 --> 00:22:32,390
recommended so what's the support for

00:22:27,380 --> 00:22:33,860
the performance observer today I just

00:22:32,390 --> 00:22:35,240
covered last week actually that Safari

00:22:33,860 --> 00:22:38,570
joined the party which was surprising

00:22:35,240 --> 00:22:42,050
though so it's not that bad is this poly

00:22:38,570 --> 00:22:43,430
fillable well if browser vendors at some

00:22:42,050 --> 00:22:45,170
point decide that they only want to push

00:22:43,430 --> 00:22:47,870
metrics through the performance observer

00:22:45,170 --> 00:22:49,910
the gern is more or less over but so far

00:22:47,870 --> 00:22:51,920
the metrics are also available via get

00:22:49,910 --> 00:22:54,350
entries by type so you can do a feature

00:22:51,920 --> 00:22:58,220
detection check and then you are ready

00:22:54,350 --> 00:23:00,640
to go so what we have now is a lazy

00:22:58,220 --> 00:23:02,690
loading effect we've got unicorns and

00:23:00,640 --> 00:23:07,430
unicorns are pretty gate great but

00:23:02,690 --> 00:23:14,210
what's better than unicorns once this

00:23:07,430 --> 00:23:18,170
again anyone what was that I didn't

00:23:14,210 --> 00:23:27,230
understand it all right I'll give you a

00:23:18,170 --> 00:23:29,570
hint and now did I did a glitter but all

00:23:27,230 --> 00:23:32,120
right so I'm from Berlin I'm mostly into

00:23:29,570 --> 00:23:34,880
indie music but I also like electronic

00:23:32,120 --> 00:23:35,190
music and a good over near sunshine good

00:23:34,880 --> 00:23:37,860
news

00:23:35,190 --> 00:23:41,070
take dancing just forgetting the day

00:23:37,860 --> 00:23:44,850
it's perfect to me so what I implemented

00:23:41,070 --> 00:23:46,290
next was confetti and to do that I have

00:23:44,850 --> 00:23:48,900
to cheat a little bit but I think that's

00:23:46,290 --> 00:24:00,450
alright let's assume there's a slide up

00:23:48,900 --> 00:24:04,110
and down thing in the website this makes

00:24:00,450 --> 00:24:08,250
me really happy so how could we now

00:24:04,110 --> 00:24:14,130
figure out if something changed its size

00:24:08,250 --> 00:24:16,950
any guesses well there's also the resize

00:24:14,130 --> 00:24:18,660
observer so how does that work so we

00:24:16,950 --> 00:24:20,580
have to initialize a new resize observer

00:24:18,660 --> 00:24:23,340
which then gets called with several

00:24:20,580 --> 00:24:24,630
entries and then we're just telling hey

00:24:23,340 --> 00:24:26,220
alright can you please watch out for

00:24:24,630 --> 00:24:27,950
these elements cool I want to do

00:24:26,220 --> 00:24:30,540
something I want to draw confetti then

00:24:27,950 --> 00:24:33,870
you might ask yourself though okay a fan

00:24:30,540 --> 00:24:36,150
but when is this firing the resize

00:24:33,870 --> 00:24:38,550
observer fires when elements gets

00:24:36,150 --> 00:24:41,340
inserted and removed from Dom when they

00:24:38,550 --> 00:24:43,980
get set to display:none they are not

00:24:41,340 --> 00:24:46,740
triggering on CSS transforms though and

00:24:43,980 --> 00:24:50,930
with this information further I have to

00:24:46,740 --> 00:24:57,150
tell you my implementation was broken so

00:24:50,930 --> 00:24:59,970
triggers on on load that's not so cool

00:24:57,150 --> 00:25:02,490
it's drawing and closing I mean confetti

00:24:59,970 --> 00:25:04,730
is great but it's not really accurate

00:25:02,490 --> 00:25:08,490
here and it's also triggering on on

00:25:04,730 --> 00:25:10,860
horizontal resizing but I think it was

00:25:08,490 --> 00:25:13,260
OK at that point right so one where

00:25:10,860 --> 00:25:15,060
could we use the resize observer well

00:25:13,260 --> 00:25:18,300
for drag and drop interfaces this can

00:25:15,060 --> 00:25:20,130
become really handy this is six lines of

00:25:18,300 --> 00:25:21,720
JavaScript and I can maybe a just scroll

00:25:20,130 --> 00:25:26,220
positioning or something like that

00:25:21,720 --> 00:25:28,860
and we are all waiting for element

00:25:26,220 --> 00:25:31,440
queries right maybe they will be there

00:25:28,860 --> 00:25:32,850
at some point the JavaScript

00:25:31,440 --> 00:25:35,700
implementations are polyfill for this

00:25:32,850 --> 00:25:38,400
are also considering using the resize

00:25:35,700 --> 00:25:42,030
observer and to figure out if something

00:25:38,400 --> 00:25:45,140
changed its size so all the support of

00:25:42,030 --> 00:25:45,140
the resize observer today

00:25:47,169 --> 00:25:54,739
we're entering cutting edge here I would

00:25:51,499 --> 00:25:59,840
say is this poly fillable and usable in

00:25:54,739 --> 00:26:01,429
production I would say so so they are

00:25:59,840 --> 00:26:03,799
polyfills for the Wizards observer out

00:26:01,429 --> 00:26:07,700
there and these use mutation observers

00:26:03,799 --> 00:26:10,309
and they aren't they're not covering

00:26:07,700 --> 00:26:12,110
everything so you might want to consider

00:26:10,309 --> 00:26:18,470
if you want to really want to use that

00:26:12,110 --> 00:26:22,369
today but we're still not really happy

00:26:18,470 --> 00:26:25,220
so let's face the resize problem here

00:26:22,369 --> 00:26:26,960
and let's take a step back

00:26:25,220 --> 00:26:29,119
and let's see what we're actually

00:26:26,960 --> 00:26:31,879
dealing with so here we've got an

00:26:29,119 --> 00:26:34,220
element and this is a simplified version

00:26:31,879 --> 00:26:35,570
for one element so what are we dealing

00:26:34,220 --> 00:26:38,659
with we're dealing with this initial

00:26:35,570 --> 00:26:41,149
call we're dealing with several opening

00:26:38,659 --> 00:26:43,700
calls and we're dealing with several

00:26:41,149 --> 00:26:45,169
closing calls and what we actually want

00:26:43,700 --> 00:26:47,509
to do is we want to get rid of the first

00:26:45,169 --> 00:26:50,239
one and of the closing ones so how could

00:26:47,509 --> 00:26:54,559
we do this well here we have to call

00:26:50,239 --> 00:26:59,600
back that is triggered on resize so well

00:26:54,559 --> 00:27:02,690
we could soar boolean and toggle that

00:26:59,600 --> 00:27:07,850
and how could we figure out if it's

00:27:02,690 --> 00:27:12,590
getting bigger and smaller well we could

00:27:07,850 --> 00:27:14,509
store the last run and then compare but

00:27:12,590 --> 00:27:16,700
this code for me is not really readable

00:27:14,509 --> 00:27:19,340
and it's also hard to maintain and it

00:27:16,700 --> 00:27:22,369
has side effects outside of the event

00:27:19,340 --> 00:27:26,359
handler and if you have several entries

00:27:22,369 --> 00:27:32,119
that gets more more complicated so let's

00:27:26,359 --> 00:27:35,119
enter the final topic observables just

00:27:32,119 --> 00:27:37,789
because the name is fitting observables

00:27:35,119 --> 00:27:40,129
are a collection that arrives over time

00:27:37,789 --> 00:27:41,600
and currently they're only in spec but

00:27:40,129 --> 00:27:44,090
they have already a widespread usage

00:27:41,600 --> 00:27:46,749
thanks to our X and libraries like that

00:27:44,090 --> 00:27:49,759
and they're definitely a talk on its own

00:27:46,749 --> 00:27:51,200
so again observables a collection that

00:27:49,759 --> 00:27:53,809
arrives over time so let's have a look

00:27:51,200 --> 00:27:56,720
at an observable implementation so here

00:27:53,809 --> 00:27:58,580
you see a function that is called get

00:27:56,720 --> 00:27:59,760
observable with three values it's

00:27:58,580 --> 00:28:02,040
initializing in Europe so

00:27:59,760 --> 00:28:04,680
observable then it's calling next and

00:28:02,040 --> 00:28:07,290
pushing values into this collection and

00:28:04,680 --> 00:28:10,290
then it's completing at some point then

00:28:07,290 --> 00:28:13,170
we're defining handlers for given events

00:28:10,290 --> 00:28:15,810
of this collection and then we just

00:28:13,170 --> 00:28:18,420
subscribe to that and then we get next 1

00:28:15,810 --> 00:28:22,680
2 3 and yeah we're done when I saw this

00:28:18,420 --> 00:28:23,430
for the first time I was like what's the

00:28:22,680 --> 00:28:26,210
deal here

00:28:23,430 --> 00:28:28,410
let's just shifting around callbacks now

00:28:26,210 --> 00:28:29,820
but now we're dealing with the

00:28:28,410 --> 00:28:31,560
collection which means that we have

00:28:29,820 --> 00:28:33,720
stuff available that like maps will the

00:28:31,560 --> 00:28:38,520
reduce and this makes it possible to

00:28:33,720 --> 00:28:40,410
write rate cleaner code so this was the

00:28:38,520 --> 00:28:42,330
initial implementation and let's change

00:28:40,410 --> 00:28:46,800
that to use for example something like

00:28:42,330 --> 00:28:49,830
Rx and new observable comes rx create

00:28:46,800 --> 00:28:54,180
here and what I now have is a collection

00:28:49,830 --> 00:28:58,200
of events over time and this gives me

00:28:54,180 --> 00:29:00,120
collection superpowers so let's have a

00:28:58,200 --> 00:29:02,040
look at the timeline again so this is

00:29:00,120 --> 00:29:03,570
what we're dealing with and I'm calling

00:29:02,040 --> 00:29:05,130
get resize string here which gives me

00:29:03,570 --> 00:29:07,980
this collection that arrives over time

00:29:05,130 --> 00:29:08,790
how can I get rid of the first one well

00:29:07,980 --> 00:29:13,140
skip it

00:29:08,790 --> 00:29:15,630
cool how can I figure out if it's how

00:29:13,140 --> 00:29:18,570
the last run was well there's a function

00:29:15,630 --> 00:29:23,400
for that pairwise cool how can I not

00:29:18,570 --> 00:29:26,130
drop the closing ones filtering maybe

00:29:23,400 --> 00:29:29,910
and how can I get rid of the previous

00:29:26,130 --> 00:29:32,550
ones now map it back and then call the

00:29:29,910 --> 00:29:34,230
stuff that I want to do this is pure

00:29:32,550 --> 00:29:35,910
functional code without side effects

00:29:34,230 --> 00:29:39,450
that's easy to read maintainable and

00:29:35,910 --> 00:29:48,410
testable I really really like that so

00:29:39,450 --> 00:29:48,410
with that my implementation was bug free

00:29:53,940 --> 00:29:58,540
so what would so what we talked about

00:29:56,380 --> 00:30:00,130
was the intersection observer to figure

00:29:58,540 --> 00:30:01,690
out if something enters the viewport the

00:30:00,130 --> 00:30:03,850
mutation observer to figure out if

00:30:01,690 --> 00:30:05,470
something changed in the Dom the

00:30:03,850 --> 00:30:07,660
performance observer to not ask for

00:30:05,470 --> 00:30:09,040
matrix but rather get notified the

00:30:07,660 --> 00:30:10,380
resize observer to figure out if

00:30:09,040 --> 00:30:13,060
something changes in size and

00:30:10,380 --> 00:30:15,820
observables which are a completely

00:30:13,060 --> 00:30:17,740
different way of thinking and it takes a

00:30:15,820 --> 00:30:21,630
while to get it I'm still freaking

00:30:17,740 --> 00:30:21,630
freaking things out with observables and

00:30:21,780 --> 00:30:28,780
I'm in the web development industry for

00:30:24,370 --> 00:30:31,510
seven years now and oh well so much has

00:30:28,780 --> 00:30:34,600
changed and web dot web development is

00:30:31,510 --> 00:30:37,380
still fun it's probably we're a big love

00:30:34,600 --> 00:30:41,440
in my life today but yeah we all have to

00:30:37,380 --> 00:30:43,930
to admit and probably all know that so

00:30:41,440 --> 00:30:47,460
much will still change and even if it's

00:30:43,930 --> 00:30:49,870
exhausting I really really love that and

00:30:47,460 --> 00:30:51,790
yeah we're all here in this really

00:30:49,870 --> 00:30:54,760
beautiful when the venue and we have

00:30:51,790 --> 00:30:57,170
really good time so let's all celebrate

00:30:54,760 --> 00:31:04,049
I ready

00:30:57,170 --> 00:31:04,049
[Music]

00:31:05,149 --> 00:31:11,500
you

00:31:05,610 --> 00:31:11,500

YouTube URL: https://www.youtube.com/watch?v=GP7U6LW2zDY


