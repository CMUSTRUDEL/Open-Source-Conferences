Title: Dan Callahan: Practical WebAssembly | JSConf Budapest 2017
Publication date: 2017-12-01
Playlist: JSConf Budapest 2017
Description: 
	WebAssembly is a new low-level, high-performance complement to JavaScript on the Web. As an open standard developed by Mozilla, Google, Microsoft, and Apple, WebAssembly runs everywhere that JavaScript does: in every major Web browser, and in runtimes like Node.js and Electron. This talk examines WebAssembly from a practical standpoint, answering why it was created, what itâ€™s good for, how it works, and how you can use it today.

http://jsconfbp.com/speakers/dan-callahan/
Captions: 
	00:00:01,070 --> 00:00:04,920
thank you so much

00:00:03,330 --> 00:00:07,220
so the title of this talk in the

00:00:04,920 --> 00:00:09,420
schedule is practical web assembly

00:00:07,220 --> 00:00:12,120
unfortunately since this technology is

00:00:09,420 --> 00:00:13,530
only six months nine months old it's

00:00:12,120 --> 00:00:15,719
much more reasonable to talk about

00:00:13,530 --> 00:00:17,220
possible web assembly because everything

00:00:15,719 --> 00:00:19,890
I show you is possible today but the

00:00:17,220 --> 00:00:20,850
tooling is still somewhat rough so I

00:00:19,890 --> 00:00:23,699
don't want to focus too much on the

00:00:20,850 --> 00:00:26,130
specifics of how to to build a web

00:00:23,699 --> 00:00:28,349
assembly module but rather give you the

00:00:26,130 --> 00:00:30,929
conceptual understanding of what I would

00:00:28,349 --> 00:00:32,730
simply can do what it's good at when you

00:00:30,929 --> 00:00:35,850
should think about using it versus when

00:00:32,730 --> 00:00:37,649
you should stick to JavaScript my name

00:00:35,850 --> 00:00:40,350
is Dan Callahan I'm Callahan on Twitter

00:00:37,649 --> 00:00:42,660
I work for Mozilla and Mozilla works for

00:00:40,350 --> 00:00:44,940
the web and what I mean by that is that

00:00:42,660 --> 00:00:48,629
Mozilla is the only major browser vendor

00:00:44,940 --> 00:00:49,980
that's a non-profit and we exist and we

00:00:48,629 --> 00:00:51,539
create the Firefox family of web

00:00:49,980 --> 00:00:54,270
browsers so that we can act as a

00:00:51,539 --> 00:00:56,160
counterbalance against the world's three

00:00:54,270 --> 00:00:57,780
largest publicly traded for-profit

00:00:56,160 --> 00:00:59,910
companies who control the other major

00:00:57,780 --> 00:01:02,820
browsers and that we can make sure that

00:00:59,910 --> 00:01:05,100
we advocate for the web that respects

00:01:02,820 --> 00:01:06,960
human interest public interests that's

00:01:05,100 --> 00:01:09,450
based on standards that's interoperable

00:01:06,960 --> 00:01:12,350
that's open and by implementing the web

00:01:09,450 --> 00:01:15,060
itself we can do that advocacy as a peer

00:01:12,350 --> 00:01:17,580
rather than purely from a kind of

00:01:15,060 --> 00:01:20,490
theoretical standpoint or ideological

00:01:17,580 --> 00:01:24,330
standpoint we make other things to rust

00:01:20,490 --> 00:01:25,770
servo pocket we just acquired mdn but

00:01:24,330 --> 00:01:27,299
today I'm going to be talking about a

00:01:25,770 --> 00:01:30,450
technology that Mozilla's helps create

00:01:27,299 --> 00:01:32,759
called web assembly web assembly is a

00:01:30,450 --> 00:01:34,110
direct successor to a technology and

00:01:32,759 --> 00:01:36,270
experimental technology Mozilla built

00:01:34,110 --> 00:01:39,119
called as MJS where we're trying to

00:01:36,270 --> 00:01:43,229
build a higher performance lower level

00:01:39,119 --> 00:01:44,640
version of javascript and and I only

00:01:43,229 --> 00:01:46,649
have 30 minutes and I'm going to go

00:01:44,640 --> 00:01:48,990
along and I apologize it's it should

00:01:46,649 --> 00:01:50,610
only be by five or ten minutes but if

00:01:48,990 --> 00:01:51,630
you want to spend time reading about

00:01:50,610 --> 00:01:53,340
whether somebody and really kind of

00:01:51,630 --> 00:01:56,040
digesting what this is and how it works

00:01:53,340 --> 00:01:58,710
I strongly recommend looking into the

00:01:56,040 --> 00:02:00,060
articles and the talks by Lynn Clark you

00:01:58,710 --> 00:02:02,189
can find her Twitter as Lynn Clark she's

00:02:00,060 --> 00:02:04,560
done Illustrated introductions to web

00:02:02,189 --> 00:02:05,880
assembly to shared array buffer she give

00:02:04,560 --> 00:02:08,099
a talk on what web assembly means for

00:02:05,880 --> 00:02:10,080
react all these are phenomenal resources

00:02:08,099 --> 00:02:11,540
she's an excellent engineer and even

00:02:10,080 --> 00:02:14,689
better educator

00:02:11,540 --> 00:02:17,390
check out her work so what is

00:02:14,689 --> 00:02:19,430
webassembly at its core whether somebody

00:02:17,390 --> 00:02:21,739
is a compiler target for programs on the

00:02:19,430 --> 00:02:23,930
web and we'll get into what that means

00:02:21,739 --> 00:02:26,510
in a second but but what this is useful

00:02:23,930 --> 00:02:29,540
for is it opens up new avenues of

00:02:26,510 --> 00:02:31,280
portability and performance both in the

00:02:29,540 --> 00:02:34,459
browser and in server-side runtimes like

00:02:31,280 --> 00:02:35,959
node when we talk about portability

00:02:34,459 --> 00:02:37,549
we're typically referring to source

00:02:35,959 --> 00:02:40,189
level portability so you write a program

00:02:37,549 --> 00:02:41,719
in portable C and you can compile it to

00:02:40,189 --> 00:02:44,480
Windows or to Mac or to Linux without

00:02:41,719 --> 00:02:46,579
having to change your code and that's

00:02:44,480 --> 00:02:52,340
really great because we can do things

00:02:46,579 --> 00:02:54,409
like did you this terminal hang on

00:02:52,340 --> 00:02:58,069
that's a binary I don't want to edit

00:02:54,409 --> 00:03:00,109
that like this program which I found I

00:02:58,069 --> 00:03:02,840
don't I don't know C and I don't know if

00:03:00,109 --> 00:03:05,840
in GL but I found this 12-year old file

00:03:02,840 --> 00:03:08,180
it's it's open source and it sets up a

00:03:05,840 --> 00:03:10,489
3d cube it makes it rotate and it's all

00:03:08,180 --> 00:03:16,900
colorful it's about 100 lines of code

00:03:10,489 --> 00:03:19,340
and if I compile that that's legible

00:03:16,900 --> 00:03:24,349
pass up the source code say spit out a

00:03:19,340 --> 00:03:28,819
binary I get a fifth power 14 kilobyte

00:03:24,349 --> 00:03:31,669
file that's a Macchio 64-bit executable

00:03:28,819 --> 00:03:32,930
and so I can take this this binary I can

00:03:31,669 --> 00:03:37,190
give it to anyone else that has a Mac

00:03:32,930 --> 00:03:40,579
and it'll run and it'll show you a

00:03:37,190 --> 00:03:42,169
little spinning cube and that's exciting

00:03:40,579 --> 00:03:44,239
to me because my educational background

00:03:42,169 --> 00:03:46,340
is in geology and so all of this is just

00:03:44,239 --> 00:03:48,319
a wizardry like I do I understand the

00:03:46,340 --> 00:03:50,150
rocks that go into the silicon on the

00:03:48,319 --> 00:03:52,609
chip I don't understand the computer

00:03:50,150 --> 00:03:54,169
itself but it made us spinning cube and

00:03:52,609 --> 00:03:55,609
that was neat and I can recompile that

00:03:54,169 --> 00:03:57,139
and I can run it on Linux and I can

00:03:55,609 --> 00:03:59,930
recompile it and I can run it on Windows

00:03:57,139 --> 00:04:01,159
and you don't have to have a C compiler

00:03:59,930 --> 00:04:04,519
installed you just you can take this

00:04:01,159 --> 00:04:08,180
binary and just run it but the platform

00:04:04,519 --> 00:04:10,009
I care about is the web and and up until

00:04:08,180 --> 00:04:11,629
recently I couldn't take this code and

00:04:10,009 --> 00:04:14,900
put it on the web I'd have to redevelop

00:04:11,629 --> 00:04:17,329
it I'd have to re-implement it well the

00:04:14,900 --> 00:04:19,459
simply fixes that so if I say make wasm

00:04:17,329 --> 00:04:23,040
I'm going to use a different compiler

00:04:19,459 --> 00:04:25,140
and scriptum instead of playing

00:04:23,040 --> 00:04:26,210
pass it the same source file and this

00:04:25,140 --> 00:04:30,630
time I'm going to tell it to spit out

00:04:26,210 --> 00:04:35,130
kind of an HTML shim if they look at

00:04:30,630 --> 00:04:38,880
that I have a 15 kilobyte webassembly

00:04:35,130 --> 00:04:43,320
binary if I look inside that I mean this

00:04:38,880 --> 00:04:44,820
is just absolute gobbledygook and we're

00:04:43,320 --> 00:04:47,040
gonna feed that to the browser and good

00:04:44,820 --> 00:04:49,350
things are gonna happen which is not

00:04:47,040 --> 00:04:57,930
usually what happens with things that

00:04:49,350 --> 00:04:59,730
look like that build HTML same exact

00:04:57,930 --> 00:05:02,340
program no changes to my source and now

00:04:59,730 --> 00:05:03,810
I can run it in the browser and it's not

00:05:02,340 --> 00:05:08,330
just in Firefox this is a technology

00:05:03,810 --> 00:05:13,830
that also works in browsers like Safari

00:05:08,330 --> 00:05:16,590
and in Chrome and an edge and because

00:05:13,830 --> 00:05:18,720
it's it's a it's for the web it doesn't

00:05:16,590 --> 00:05:20,400
matter that I'm on Windows or a Mac or

00:05:18,720 --> 00:05:22,590
on Linux the same webassembly file can

00:05:20,400 --> 00:05:24,390
go anywhere talk a little bit about that

00:05:22,590 --> 00:05:26,580
later but the important thing is that I

00:05:24,390 --> 00:05:30,470
now have a compiler which lets me take

00:05:26,580 --> 00:05:32,510
existing code and run it on the web and

00:05:30,470 --> 00:05:34,680
so game engines have started

00:05:32,510 --> 00:05:42,030
implementing export to web assembly so

00:05:34,680 --> 00:05:45,930
this is a unity demo that and drive

00:05:42,030 --> 00:05:47,190
around in and I can win because I have

00:05:45,930 --> 00:05:50,370
web assembly and I didn't need any

00:05:47,190 --> 00:05:52,560
plugins I didn't need any any downloads

00:05:50,370 --> 00:05:54,420
or any native binaries I can just go to

00:05:52,560 --> 00:05:58,830
URL and play a game and it runs about

00:05:54,420 --> 00:06:00,510
native speed thank you for the AV people

00:05:58,830 --> 00:06:03,000
for turning that down I'm sorry I didn't

00:06:00,510 --> 00:06:05,360
do that for you so those the Unreal

00:06:03,000 --> 00:06:07,590
Engine and some people complained or the

00:06:05,360 --> 00:06:09,030
the Unity engine some people complain

00:06:07,590 --> 00:06:11,340
that it's not a real engine because it's

00:06:09,030 --> 00:06:14,610
started as a browser plug-in and this

00:06:11,340 --> 00:06:17,340
and that so the Unreal Engine has also

00:06:14,610 --> 00:06:18,720
added support for web assembly where

00:06:17,340 --> 00:06:20,670
just like you can export from these

00:06:18,720 --> 00:06:23,250
engines to Windows or to Mac OS or to

00:06:20,670 --> 00:06:25,860
Xbox or to PlayStation you can now also

00:06:23,250 --> 00:06:28,260
export to the web and again I can just

00:06:25,860 --> 00:06:30,570
visit URL and it takes a minute to

00:06:28,260 --> 00:06:33,030
launch because it's a modern game engine

00:06:30,570 --> 00:06:35,790
but this is the full Unreal Engine

00:06:33,030 --> 00:06:36,510
rendering in real time in my browser

00:06:35,790 --> 00:06:38,190
with

00:06:36,510 --> 00:06:39,990
any plugins without any modifications

00:06:38,190 --> 00:06:42,360
and if I you know click the cell

00:06:39,990 --> 00:06:50,220
interactive so once the camera finishes

00:06:42,360 --> 00:06:51,930
panning zoom in on the fishpond and

00:06:50,220 --> 00:06:55,890
probably swarming algorithm will kind of

00:06:51,930 --> 00:06:56,940
follow my cursor and all this again

00:06:55,890 --> 00:06:59,010
these are experiences that the web

00:06:56,940 --> 00:07:00,270
previously hadn't hadn't been capable of

00:06:59,010 --> 00:07:01,860
just this level of performance in the

00:07:00,270 --> 00:07:03,960
fidelity and not having to invent it

00:07:01,860 --> 00:07:06,180
twice once for the web and once for

00:07:03,960 --> 00:07:10,350
desktop we can now just do it once and

00:07:06,180 --> 00:07:10,950
export for the web so I think that's

00:07:10,350 --> 00:07:15,870
pretty cool

00:07:10,950 --> 00:07:18,210
I talked about compiling for Windows or

00:07:15,870 --> 00:07:20,070
Mac or Linux and and how that meant

00:07:18,210 --> 00:07:23,220
source level portability but not binary

00:07:20,070 --> 00:07:24,300
level portability but it's more complex

00:07:23,220 --> 00:07:26,850
than that because you're not just

00:07:24,300 --> 00:07:28,320
compiling for Windows or Linux you're

00:07:26,850 --> 00:07:30,570
compiling for a specific CPU

00:07:28,320 --> 00:07:32,040
architecture on one of these operating

00:07:30,570 --> 00:07:36,120
systems so you might be compiling for

00:07:32,040 --> 00:07:37,830
32-bit windows and Intel 32-bit Linux

00:07:36,120 --> 00:07:41,370
and you might also compile for armed on

00:07:37,830 --> 00:07:42,960
Linux which is the the CPU architecture

00:07:41,370 --> 00:07:45,780
on your phone it's what's in a Raspberry

00:07:42,960 --> 00:07:48,180
Pi and so if I want to support all these

00:07:45,780 --> 00:07:50,510
platforms I can but I have to recompile

00:07:48,180 --> 00:07:52,830
dozens of times to cover every possible

00:07:50,510 --> 00:07:58,170
CPU that exists now or might exist in

00:07:52,830 --> 00:08:00,060
the future let's talk about sass CSS

00:07:58,170 --> 00:08:03,840
conference yesterday who here likes and

00:08:00,060 --> 00:08:05,580
loves and uses sass half the hands there

00:08:03,840 --> 00:08:07,860
should be more it's great absolutely

00:08:05,580 --> 00:08:09,870
great library it it's a preprocessor for

00:08:07,860 --> 00:08:12,420
CSS that lets you write shorthand and

00:08:09,870 --> 00:08:14,610
and more humanely manage a lot of your

00:08:12,420 --> 00:08:16,350
style sheets the problem was it was

00:08:14,610 --> 00:08:19,350
written in Ruby and Ruby is a great

00:08:16,350 --> 00:08:20,550
language like JavaScript but it's a

00:08:19,350 --> 00:08:22,620
dynamic language it's a high-level

00:08:20,550 --> 00:08:24,390
language it requires its own runtime I

00:08:22,620 --> 00:08:26,160
can't just send somebody sass dot exe

00:08:24,390 --> 00:08:28,080
and have them run it they also need to

00:08:26,160 --> 00:08:29,550
install Ruby and if I'm writing a

00:08:28,080 --> 00:08:31,890
JavaScript program and I want to use

00:08:29,550 --> 00:08:33,030
sass well now I have to manage a program

00:08:31,890 --> 00:08:34,560
written in JavaScript I'm program

00:08:33,030 --> 00:08:38,460
written in Ruby and it just it gets

00:08:34,560 --> 00:08:40,530
complicated so some people rewrote sass

00:08:38,460 --> 00:08:42,210
they were implemented as libsass in C

00:08:40,530 --> 00:08:44,850
and C++ because these lower-level

00:08:42,210 --> 00:08:47,610
languages don't make as many assumptions

00:08:44,850 --> 00:08:49,980
about where and how they'll be running

00:08:47,610 --> 00:08:51,690
in this case you can compile Assaf saath

00:08:49,980 --> 00:08:53,700
exe and pass it around and it'll work

00:08:51,690 --> 00:08:55,500
and because it's written in this the

00:08:53,700 --> 00:08:57,330
level language it's easier to call it

00:08:55,500 --> 00:08:59,900
from other languages so there are

00:08:57,330 --> 00:09:02,250
bindings from Java to sass from

00:08:59,900 --> 00:09:05,820
JavaScript to sass from Lua to sass from

00:09:02,250 --> 00:09:09,030
Python to Ruby etc and I want to look at

00:09:05,820 --> 00:09:11,370
the node version node sass great project

00:09:09,030 --> 00:09:12,840
tries to create this conceptual model

00:09:11,370 --> 00:09:16,800
where you have a JavaScript API but at

00:09:12,840 --> 00:09:17,820
the core is libsass C and you don't have

00:09:16,800 --> 00:09:18,960
to know that because you're just

00:09:17,820 --> 00:09:20,940
interacting with the JavaScript layer

00:09:18,960 --> 00:09:22,440
but they didn't have to rewrite sass in

00:09:20,940 --> 00:09:23,630
JavaScript they could just reuse that c

00:09:22,440 --> 00:09:26,310
version

00:09:23,630 --> 00:09:28,830
the problem is sass is only libsass and

00:09:26,310 --> 00:09:30,150
only portable at the source level so if

00:09:28,830 --> 00:09:31,710
you go to the github release page for

00:09:30,150 --> 00:09:34,800
notes fast they've got this matrix of

00:09:31,710 --> 00:09:37,740
operating systems CPU architectures and

00:09:34,800 --> 00:09:39,750
node versions and for every release of

00:09:37,740 --> 00:09:42,090
libsass they have to build a separate

00:09:39,750 --> 00:09:45,480
copy of that library for each of these

00:09:42,090 --> 00:09:47,580
these platforms and each one's a couple

00:09:45,480 --> 00:09:49,890
megabytes and it just goes on and on and

00:09:47,580 --> 00:09:51,300
on so every release is hundreds of

00:09:49,890 --> 00:09:53,130
megabytes binaries and you can't put

00:09:51,300 --> 00:09:55,380
that in your npm module nobody would npm

00:09:53,130 --> 00:09:57,360
install that so we knew npm install node

00:09:55,380 --> 00:10:00,840
sass it goes out to the web and tries to

00:09:57,360 --> 00:10:02,310
fetch the right binding for you the

00:10:00,840 --> 00:10:04,230
trick is something really important's

00:10:02,310 --> 00:10:07,800
missing they don't build for arm

00:10:04,230 --> 00:10:09,750
I knit libsass builds on arm but they

00:10:07,800 --> 00:10:11,070
don't provide the binary and so if I'm

00:10:09,750 --> 00:10:13,410
trying to install this on a Raspberry Pi

00:10:11,070 --> 00:10:14,910
I also need to install a C compiler I

00:10:13,410 --> 00:10:16,740
also need to install a bunch of headers

00:10:14,910 --> 00:10:19,260
and there's a pre-installed hook that

00:10:16,740 --> 00:10:20,730
tries to compile it for me and that's

00:10:19,260 --> 00:10:22,200
kind of a pain in the button that's not

00:10:20,730 --> 00:10:23,910
that's not what I love about jobs here

00:10:22,200 --> 00:10:26,460
boy I love about JavaScript is it's

00:10:23,910 --> 00:10:28,260
universal and it works everywhere and so

00:10:26,460 --> 00:10:30,900
what they were trying to create was was

00:10:28,260 --> 00:10:34,950
that experience of one library shared

00:10:30,900 --> 00:10:36,570
core across multiple languages etc but

00:10:34,950 --> 00:10:39,930
what actually happens is you have 70

00:10:36,570 --> 00:10:41,250
different compiled binaries depending on

00:10:39,930 --> 00:10:42,180
what platform you're looking for and

00:10:41,250 --> 00:10:43,800
like I said that doesn't cover

00:10:42,180 --> 00:10:45,270
everything who knows what the next

00:10:43,800 --> 00:10:47,250
version of node will do in terms of ABI

00:10:45,270 --> 00:10:48,690
changes who knows what the next CPU

00:10:47,250 --> 00:10:50,940
architecture that becomes popular will

00:10:48,690 --> 00:10:57,150
be I don't think anyone predicted the

00:10:50,940 --> 00:10:58,740
rise of arm over Intel ten years ago so

00:10:57,150 --> 00:11:01,390
we've got this combinatoric explosion

00:10:58,740 --> 00:11:03,720
source level compatibility is great

00:11:01,390 --> 00:11:05,830
but you have to compile a lot of times

00:11:03,720 --> 00:11:08,350
what webassembly does is it introduces

00:11:05,830 --> 00:11:11,890
another architecture a virtual

00:11:08,350 --> 00:11:13,090
architecture and I know what some of you

00:11:11,890 --> 00:11:14,920
are thinking because you've told me this

00:11:13,090 --> 00:11:16,690
as I was rehearsing your think about

00:11:14,920 --> 00:11:19,570
this xkcd about I know will create

00:11:16,690 --> 00:11:21,520
another standard and now we have another

00:11:19,570 --> 00:11:22,710
standard instead of one standard to rule

00:11:21,520 --> 00:11:24,730
them all

00:11:22,710 --> 00:11:26,730
the reason this is difference is

00:11:24,730 --> 00:11:29,680
different is because webassembly isn't a

00:11:26,730 --> 00:11:31,090
physical processor specification it's

00:11:29,680 --> 00:11:34,180
not a real architecture it's a virtual

00:11:31,090 --> 00:11:35,800
architecture and the the basic

00:11:34,180 --> 00:11:39,250
instruction set and web assembly is

00:11:35,800 --> 00:11:41,140
designed to be kind of the the least

00:11:39,250 --> 00:11:44,500
common denominator all the commonalities

00:11:41,140 --> 00:11:46,240
of the popular real world silicon CPUs

00:11:44,500 --> 00:11:49,930
that are out there so we take things

00:11:46,240 --> 00:11:52,840
that are common to x86 - arm - MIPS and

00:11:49,930 --> 00:11:54,310
we've kind of abstracted that out which

00:11:52,840 --> 00:11:56,050
means it's really easy to go from web

00:11:54,310 --> 00:11:59,110
assembly to any of those other

00:11:56,050 --> 00:12:03,340
instruction sets just like you might

00:11:59,110 --> 00:12:05,980
think about a you know a flash movie or

00:12:03,340 --> 00:12:07,360
a Java jar we have a bytecode that the

00:12:05,980 --> 00:12:10,810
end computer is responsible for

00:12:07,360 --> 00:12:13,870
translating down to whatever the

00:12:10,810 --> 00:12:15,460
physical hardware is but it's low-level

00:12:13,870 --> 00:12:21,250
so that it's a very quick and efficient

00:12:15,460 --> 00:12:23,470
translation webassembly is supported by

00:12:21,250 --> 00:12:25,660
default in node 8 which means for for

00:12:23,470 --> 00:12:27,580
libsass for node SAS instead of shipping

00:12:25,660 --> 00:12:30,250
these eight different binaries for node

00:12:27,580 --> 00:12:32,710
eight and then eight more for node nine

00:12:30,250 --> 00:12:34,360
then eight more for node ten they really

00:12:32,710 --> 00:12:37,060
could replace that with a single libsass

00:12:34,360 --> 00:12:39,580
tile Azzam maintain the same javascript

00:12:37,060 --> 00:12:41,950
api your code has no no need to know

00:12:39,580 --> 00:12:44,590
that the implementation is in something

00:12:41,950 --> 00:12:45,850
anything other than JavaScript but now

00:12:44,590 --> 00:12:47,380
they could shift X would be a single

00:12:45,850 --> 00:12:49,240
file and it worked everywhere and it

00:12:47,380 --> 00:12:51,040
works wherever no it goes because it's

00:12:49,240 --> 00:12:52,180
implemented on top of that VM it's

00:12:51,040 --> 00:12:56,410
implemented kind of on top of the the

00:12:52,180 --> 00:12:59,620
JavaScript runtime I think someone

00:12:56,410 --> 00:13:01,960
should do this I want to do that but

00:12:59,620 --> 00:13:03,190
then I got busy so I'm starting to put

00:13:01,960 --> 00:13:04,390
in my talks and hopes that someone else

00:13:03,190 --> 00:13:06,490
will do it

00:13:04,390 --> 00:13:10,270
file a bug show someone the recording

00:13:06,490 --> 00:13:11,800
this this potential to start taking

00:13:10,270 --> 00:13:13,750
these native libraries and bringing them

00:13:11,800 --> 00:13:14,680
to the server side in an easy way you

00:13:13,750 --> 00:13:16,149
don't have to worry about

00:13:14,680 --> 00:13:18,910
you don't have to worry about compiler

00:13:16,149 --> 00:13:20,320
tool chains I think holds a lot of

00:13:18,910 --> 00:13:25,390
promise because it means that all of a

00:13:20,320 --> 00:13:26,649
sudden the the whole web ecosystem not

00:13:25,390 --> 00:13:30,670
just on the server side not just know

00:13:26,649 --> 00:13:33,580
but also the browser has access to this

00:13:30,670 --> 00:13:35,440
universe of of new libraries and when I

00:13:33,580 --> 00:13:36,310
say sit it's an open standard I say well

00:13:35,440 --> 00:13:37,899
this simply is an open standard

00:13:36,310 --> 00:13:40,300
supported by all major browsers I mean

00:13:37,899 --> 00:13:43,089
it as of this month even edge is

00:13:40,300 --> 00:13:45,580
shipping whether simply on by default in

00:13:43,089 --> 00:13:47,290
their current release Safari on iOS if

00:13:45,580 --> 00:13:49,180
shipping love is simply on by default in

00:13:47,290 --> 00:13:51,970
their current release this is real it's

00:13:49,180 --> 00:13:53,890
here it only appeared in March and yet

00:13:51,970 --> 00:13:57,520
we now have cross browser adoption in

00:13:53,890 --> 00:14:00,550
every major platform the web is not used

00:13:57,520 --> 00:14:01,630
to moving this fast and and that's why

00:14:00,550 --> 00:14:03,279
I'm giving this talk today is to

00:14:01,630 --> 00:14:07,390
hopefully inspire you and make you aware

00:14:03,279 --> 00:14:08,589
of this new capability that exists so we

00:14:07,390 --> 00:14:09,700
have a new universe of portable

00:14:08,589 --> 00:14:11,680
libraries there's no need to

00:14:09,700 --> 00:14:13,980
re-implement Sasuke s to bring it to the

00:14:11,680 --> 00:14:16,690
browser we can just recompile the C++

00:14:13,980 --> 00:14:19,029
and that's that's cool but how does it

00:14:16,690 --> 00:14:21,880
do it what is web assembly doing what

00:14:19,029 --> 00:14:23,500
makes it fast what makes it useful the

00:14:21,880 --> 00:14:25,060
key to all this is that web assembly in

00:14:23,500 --> 00:14:26,740
contrast to JavaScript Java scripts a

00:14:25,060 --> 00:14:28,630
very high level text based format it's

00:14:26,740 --> 00:14:30,520
meant to be read and edited and used by

00:14:28,630 --> 00:14:32,709
humans and written by humans

00:14:30,520 --> 00:14:35,020
well of assembly is a low-level binary

00:14:32,709 --> 00:14:37,360
format it's you're not intended to write

00:14:35,020 --> 00:14:38,230
whether assembly by hand instead you're

00:14:37,360 --> 00:14:40,180
supposed to write in a language a

00:14:38,230 --> 00:14:43,779
low-level language like C or C++ or rust

00:14:40,180 --> 00:14:44,740
and compile that to web assembly so

00:14:43,779 --> 00:14:51,420
let's do some of that and see if the

00:14:44,740 --> 00:14:55,180
network holds up so if I go to also

00:14:51,420 --> 00:15:00,250
tabby cat the best extension randomly

00:14:55,180 --> 00:15:04,150
generated cats so have a little tool

00:15:00,250 --> 00:15:06,730
called the lazarum explorer which lets

00:15:04,150 --> 00:15:09,400
you kind of type in C they make this a

00:15:06,730 --> 00:15:11,980
little more visible for people and it

00:15:09,400 --> 00:15:13,029
will compile it to web assembly in in

00:15:11,980 --> 00:15:14,560
the browser we're not actually shipping

00:15:13,029 --> 00:15:17,320
the compiler to the browser though

00:15:14,560 --> 00:15:18,339
that's possible but it'll post your C to

00:15:17,320 --> 00:15:20,440
a back-end that will compile it and

00:15:18,339 --> 00:15:23,920
it'll give you either simply back so I'm

00:15:20,440 --> 00:15:27,370
gonna write a c function called foo that

00:15:23,920 --> 00:15:28,800
takes an int X and returns X divided by

00:15:27,370 --> 00:15:32,560
00:15:28,800 --> 00:15:34,060
and when I compiled that I get the

00:15:32,560 --> 00:15:35,710
webassembly representation this is this

00:15:34,060 --> 00:15:38,080
is a text form and for reading but the

00:15:35,710 --> 00:15:41,590
actual web assembly itself is in binary

00:15:38,080 --> 00:15:44,530
and then this column over here on the

00:15:41,590 --> 00:15:46,030
right is the native code so you give the

00:15:44,530 --> 00:15:49,000
browser the middle column and say here's

00:15:46,030 --> 00:15:52,000
this intermediate virtual instruction

00:15:49,000 --> 00:15:55,360
set this virtual program please compile

00:15:52,000 --> 00:15:58,540
it that last mile - to the native

00:15:55,360 --> 00:15:59,440
silicon on this computer as a developer

00:15:58,540 --> 00:16:02,170
this is kind of like minification

00:15:59,440 --> 00:16:04,810
uglification you'll never actually deal

00:16:02,170 --> 00:16:05,830
with these day-to-day but it's

00:16:04,810 --> 00:16:07,360
interesting to know that they're there

00:16:05,830 --> 00:16:08,620
and see what what they're doing you'll

00:16:07,360 --> 00:16:11,770
Smoove us your time in the in the

00:16:08,620 --> 00:16:12,550
high-level language on the left so

00:16:11,770 --> 00:16:14,650
whether somebody's a stack-based

00:16:12,550 --> 00:16:17,170
language it also has static imports and

00:16:14,650 --> 00:16:18,750
exports and it's strongly typed so in

00:16:17,170 --> 00:16:21,940
here we can see we have a function foo

00:16:18,750 --> 00:16:23,650
that takes a parameter that's a 32-bit

00:16:21,940 --> 00:16:26,110
end and it returns a result that's also

00:16:23,650 --> 00:16:27,730
a 32-bit end and the way it works is it

00:16:26,110 --> 00:16:30,430
gets that first parameter it gets X puts

00:16:27,730 --> 00:16:32,710
it on the stack it gets four puts that

00:16:30,430 --> 00:16:34,720
on the stack and then calls divided

00:16:32,710 --> 00:16:36,790
underscore s which is a signed integer

00:16:34,720 --> 00:16:38,350
division so it pops those off divides

00:16:36,790 --> 00:16:42,310
them puts the result back on the stack

00:16:38,350 --> 00:16:45,430
and you're done the interesting thing

00:16:42,310 --> 00:16:47,200
about about getting to here from a lower

00:16:45,430 --> 00:16:49,030
level languages we can add more type

00:16:47,200 --> 00:16:50,920
information Java Script is a really

00:16:49,030 --> 00:16:52,510
dynamic language and so when you're

00:16:50,920 --> 00:16:53,920
running JavaScript if you employed the

00:16:52,510 --> 00:16:55,330
same function in JavaScript your browser

00:16:53,920 --> 00:16:56,920
wouldn't know going in is this an

00:16:55,330 --> 00:16:58,900
integer or is it a floating-point number

00:16:56,920 --> 00:17:00,130
or is it a string I don't I don't know

00:16:58,900 --> 00:17:02,470
and I'd have to check and I'd have to do

00:17:00,130 --> 00:17:04,839
a lot of profiling and and the browsers

00:17:02,470 --> 00:17:06,339
JIT compiler kind of guesses at these

00:17:04,839 --> 00:17:07,780
optimizations and then every time you

00:17:06,339 --> 00:17:10,060
call the function it tries to validate

00:17:07,780 --> 00:17:11,589
was i right about this optimization know

00:17:10,060 --> 00:17:13,750
all right throw it out profile it again

00:17:11,589 --> 00:17:15,339
but if we have this type information

00:17:13,750 --> 00:17:16,870
upfront for instance if we say these are

00:17:15,339 --> 00:17:19,540
unsigned integers they're always going

00:17:16,870 --> 00:17:23,020
to be positive then instead of a divided

00:17:19,540 --> 00:17:25,030
by four I shift right by two because for

00:17:23,020 --> 00:17:28,270
positive integer if you move all the

00:17:25,030 --> 00:17:30,340
bits over by two places that's the same

00:17:28,270 --> 00:17:32,050
as dividing by two each each place you

00:17:30,340 --> 00:17:35,020
move so if you move twice it's dividing

00:17:32,050 --> 00:17:36,730
by four and this is a much more

00:17:35,020 --> 00:17:39,120
efficient operation a much simpler

00:17:36,730 --> 00:17:41,610
operation for your CPU to implement

00:17:39,120 --> 00:17:45,210
so that's cool let's go ahead and

00:17:41,610 --> 00:17:47,600
download that just for kicks you can

00:17:45,210 --> 00:17:52,559
also look at this if I change this to a

00:17:47,600 --> 00:17:54,200
floating-point number you'll see it

00:17:52,559 --> 00:17:57,090
instead of a 32s we're now dealing with

00:17:54,200 --> 00:18:02,490
64-bit floating-point numbers f/64 x'

00:17:57,090 --> 00:18:03,990
and we're multiplying X by 0.25 what

00:18:02,490 --> 00:18:06,510
assembly only knows about numbers it's a

00:18:03,990 --> 00:18:08,640
really low-level language you've got 32

00:18:06,510 --> 00:18:09,720
and 64-bit floats and ents and that's it

00:18:08,640 --> 00:18:11,760
whether somebody doesn't know about

00:18:09,720 --> 00:18:15,240
strings it doesn't know about objects it

00:18:11,760 --> 00:18:16,559
doesn't really know about arrays but if

00:18:15,240 --> 00:18:18,419
you're doing computation this actually

00:18:16,559 --> 00:18:20,340
you don't need those things and you can

00:18:18,419 --> 00:18:22,260
can have this really thin layer between

00:18:20,340 --> 00:18:24,360
the web assembly world in the JavaScript

00:18:22,260 --> 00:18:26,820
world and the way I do that over my

00:18:24,360 --> 00:18:31,130
browser if I say if I say fetch test

00:18:26,820 --> 00:18:33,240
azzam and then that's going to return

00:18:31,130 --> 00:18:39,559
that visible here I'll move it a little

00:18:33,240 --> 00:18:39,559
little higher on the screen there we go

00:18:41,360 --> 00:18:45,480
so I do that and then I get a result and

00:18:43,980 --> 00:18:49,649
I'll turn that result into an array

00:18:45,480 --> 00:18:54,120
buffer and then with that buffer I'm

00:18:49,649 --> 00:18:57,450
going to call web assembly dot

00:18:54,120 --> 00:18:58,649
instantiate buffer so all I'm doing is

00:18:57,450 --> 00:19:01,230
I'm going in downloading this binary

00:18:58,649 --> 00:19:02,970
file turn you into a byte array and

00:19:01,230 --> 00:19:05,340
passing that byte array to the web

00:19:02,970 --> 00:19:08,159
assembly instantiate function it gives

00:19:05,340 --> 00:19:10,169
me a promise that eventually gets

00:19:08,159 --> 00:19:13,260
fulfilled into an object with two

00:19:10,169 --> 00:19:16,730
properties the web assembly instance in

00:19:13,260 --> 00:19:20,070
a web assembly module the instance is

00:19:16,730 --> 00:19:22,679
this is the running copy of the code the

00:19:20,070 --> 00:19:23,820
module is this right side so the module

00:19:22,679 --> 00:19:25,590
is kind of here's your compiled

00:19:23,820 --> 00:19:27,360
executable the instances

00:19:25,590 --> 00:19:29,010
here's that but it's running it has

00:19:27,360 --> 00:19:31,140
memory it has state it's kind of the

00:19:29,010 --> 00:19:33,899
difference between an exe and something

00:19:31,140 --> 00:19:35,399
in your process manager let's go ahead

00:19:33,899 --> 00:19:38,429
and pop this instance out into a global

00:19:35,399 --> 00:19:40,710
variable so we can get it more easily it

00:19:38,429 --> 00:19:43,500
has a property on it called exports and

00:19:40,710 --> 00:19:48,539
on that as our function foo and so if I

00:19:43,500 --> 00:19:51,030
call foo of 64 I get back 16 and that's

00:19:48,539 --> 00:19:52,409
that's the C we wrote over here running

00:19:51,030 --> 00:20:01,659
in the browser

00:19:52,409 --> 00:20:04,029
and if I go and look at this this is the

00:20:01,659 --> 00:20:06,519
binary that we sent to the browser it's

00:20:04,029 --> 00:20:08,769
tiny it doesn't know anything there's no

00:20:06,519 --> 00:20:10,209
JavaScript here and yet we're able to

00:20:08,769 --> 00:20:11,679
call that function as though a were a

00:20:10,209 --> 00:20:13,209
JavaScript function and we're able to

00:20:11,679 --> 00:20:15,759
pass it data and it's able to return

00:20:13,209 --> 00:20:16,959
information completely transparently you

00:20:15,759 --> 00:20:19,089
don't have to know and you wouldn't know

00:20:16,959 --> 00:20:21,879
unless I told you that the

00:20:19,089 --> 00:20:24,729
implementation of foo was in a language

00:20:21,879 --> 00:20:26,259
other than JavaScript which is cool cuz

00:20:24,729 --> 00:20:28,389
it gives you that ability to take that

00:20:26,259 --> 00:20:30,399
common core that common library wrap it

00:20:28,389 --> 00:20:31,599
in the JavaScript API and now you can

00:20:30,399 --> 00:20:36,369
reuse the core you get some more

00:20:31,599 --> 00:20:39,700
performance out of it those those

00:20:36,369 --> 00:20:42,549
performance things like doing the you

00:20:39,700 --> 00:20:44,049
know the unsigned integer again your

00:20:42,549 --> 00:20:45,729
your browser may eventually arrive at

00:20:44,049 --> 00:20:47,139
that if you wrote it in JavaScript but

00:20:45,729 --> 00:20:48,820
with web assembly you can compile that

00:20:47,139 --> 00:20:52,989
in up front and hand the browser

00:20:48,820 --> 00:20:53,979
optimize code at the start this is

00:20:52,989 --> 00:20:55,809
really useful if you have something

00:20:53,979 --> 00:20:57,249
that's CPU bound or something that's

00:20:55,809 --> 00:20:59,109
really performance intensive because you

00:20:57,249 --> 00:21:01,119
have complete manual control over how

00:20:59,109 --> 00:21:02,919
you use memory and that's really

00:21:01,119 --> 00:21:06,219
important for game engines for audio

00:21:02,919 --> 00:21:07,599
codecs video codecs things where it's

00:21:06,219 --> 00:21:09,190
much better for instance it's better if

00:21:07,599 --> 00:21:12,369
a game engine runs at a steady 30 frames

00:21:09,190 --> 00:21:13,899
a second but if it's sways between you

00:21:12,369 --> 00:21:16,269
know five frames a second sometimes and

00:21:13,899 --> 00:21:18,969
120 other times because as humans we

00:21:16,269 --> 00:21:20,529
perceive the differences and we see that

00:21:18,969 --> 00:21:23,769
stuttering and it becomes really

00:21:20,529 --> 00:21:25,209
uncomfortable but there's no way around

00:21:23,769 --> 00:21:26,619
it because JavaScript such a high level

00:21:25,209 --> 00:21:28,809
language you can't opt out of garbage

00:21:26,619 --> 00:21:30,279
collection you can't opt out of how

00:21:28,809 --> 00:21:31,899
javascript represents things in memory

00:21:30,279 --> 00:21:36,369
you don't have that low level control

00:21:31,899 --> 00:21:39,879
you do with web assembly it's an

00:21:36,369 --> 00:21:41,559
interesting example of this there's a

00:21:39,879 --> 00:21:43,989
program called web or a library called

00:21:41,559 --> 00:21:47,320
web DSP that implemented a whole bunch

00:21:43,989 --> 00:21:51,729
of different video filters identically

00:21:47,320 --> 00:21:54,609
in JavaScript and in C++ and they just

00:21:51,729 --> 00:21:56,229
do a feature detection query does web

00:21:54,609 --> 00:21:58,450
assembly exist in browser okay use the

00:21:56,229 --> 00:22:00,279
web assembly version otherwise use the

00:21:58,450 --> 00:22:01,929
JavaScript version and in most cases

00:22:00,279 --> 00:22:03,369
javascript is fast enough but if you're

00:22:01,929 --> 00:22:04,809
doing a lot of computation on each frame

00:22:03,369 --> 00:22:07,629
like trying to do edge to

00:22:04,809 --> 00:22:11,350
detection it's pretty Jinky we're taking

00:22:07,629 --> 00:22:14,409
about 250 milliseconds every frame so

00:22:11,350 --> 00:22:15,429
we're getting four frames a second but

00:22:14,409 --> 00:22:17,440
if I switch over to the webassembly

00:22:15,429 --> 00:22:19,870
version because it's able to reuse

00:22:17,440 --> 00:22:21,999
memory it's able to control exactly how

00:22:19,870 --> 00:22:24,419
memory is allocated and freed we're

00:22:21,999 --> 00:22:26,499
running a steady 60 frames a second

00:22:24,419 --> 00:22:27,610
again you may not need this in many

00:22:26,499 --> 00:22:29,080
areas but if you have a performance

00:22:27,610 --> 00:22:31,389
bottleneck in your JavaScript

00:22:29,080 --> 00:22:32,799
application you now finally have the

00:22:31,389 --> 00:22:36,999
opportunity to drop down to a lower

00:22:32,799 --> 00:22:38,889
level language to address that does that

00:22:36,999 --> 00:22:47,110
make sense to people I can see some

00:22:38,889 --> 00:22:49,990
nodding some nodding all right things

00:22:47,110 --> 00:22:51,519
could go fast now but why do we need it

00:22:49,990 --> 00:22:53,499
we need it because plugins were the only

00:22:51,519 --> 00:22:54,999
way you could do this before and they

00:22:53,499 --> 00:22:57,730
were dying because plugins were an awful

00:22:54,999 --> 00:23:00,100
security situation and they didn't have

00:22:57,730 --> 00:23:01,570
a replacement and we couldn't just say

00:23:00,100 --> 00:23:03,009
compile everything to JavaScript because

00:23:01,570 --> 00:23:05,049
JavaScript was hostile to certain types

00:23:03,009 --> 00:23:06,490
of optimizations javascript is is a

00:23:05,049 --> 00:23:08,110
really lovely language it's a very

00:23:06,490 --> 00:23:10,149
expressive language but that extra civet

00:23:08,110 --> 00:23:11,529
e in that dynamism in it makes it hard

00:23:10,149 --> 00:23:13,720
to run quickly it makes it hard to

00:23:11,529 --> 00:23:15,159
compile ahead of time and that meant

00:23:13,720 --> 00:23:16,869
that we couldn't effectively reuse

00:23:15,159 --> 00:23:20,559
existing code on the web so things like

00:23:16,869 --> 00:23:22,720
Adobe's PDF Reader I don't know how many

00:23:20,559 --> 00:23:26,740
human years have been invested into that

00:23:22,720 --> 00:23:28,240
that engine it doesn't make sense to

00:23:26,740 --> 00:23:29,320
rebuild it for the web it makes sense to

00:23:28,240 --> 00:23:32,049
take that code and bring it to the web

00:23:29,320 --> 00:23:34,059
in a way that like Java Script is safe

00:23:32,049 --> 00:23:35,889
and Universal but that runs as quickly

00:23:34,059 --> 00:23:37,539
as native code and that provides

00:23:35,889 --> 00:23:38,529
consistent predictable performance so

00:23:37,539 --> 00:23:40,210
those those were our goals were

00:23:38,529 --> 00:23:41,769
webassembly and trying to do this in a

00:23:40,210 --> 00:23:43,360
way that allowed code reuse between the

00:23:41,769 --> 00:23:46,210
web and native platforms and we did it

00:23:43,360 --> 00:23:48,190
it worked and so so if you're interested

00:23:46,210 --> 00:23:50,499
in this anyhow performance problems or

00:23:48,190 --> 00:23:51,909
or you want to reuse code between two

00:23:50,499 --> 00:23:53,009
libraries or you want portability

00:23:51,909 --> 00:23:55,299
between platforms

00:23:53,009 --> 00:23:57,129
you may not have there may not be a

00:23:55,299 --> 00:23:58,960
libsass that you can import but you may

00:23:57,129 --> 00:24:01,659
want to code the core logic of your app

00:23:58,960 --> 00:24:03,279
in in a language like rust and compile

00:24:01,659 --> 00:24:05,230
that to web assembly and also compile it

00:24:03,279 --> 00:24:07,269
to other languages or to run on other

00:24:05,230 --> 00:24:08,649
platforms and now you can share that

00:24:07,269 --> 00:24:12,070
common core between the front-end in the

00:24:08,649 --> 00:24:14,049
backend and native and web and that's

00:24:12,070 --> 00:24:15,549
really exciting and we're starting to

00:24:14,049 --> 00:24:18,029
see this technology be picked up by game

00:24:15,549 --> 00:24:20,279
engines Mozilla is using both assembly

00:24:18,029 --> 00:24:22,229
prototype a new browser our new codec

00:24:20,279 --> 00:24:25,229
for videos in the browser so we can

00:24:22,229 --> 00:24:27,419
actually ship the the video decoder as a

00:24:25,229 --> 00:24:28,279
wasm file and render it out to a canvas

00:24:27,419 --> 00:24:31,349
and it works

00:24:28,279 --> 00:24:33,719
AutoCAD can run the browser now through

00:24:31,349 --> 00:24:36,299
web assembly all sorts of crazy things

00:24:33,719 --> 00:24:37,379
and it's it's possible because we've

00:24:36,299 --> 00:24:38,759
designed web assembly as a

00:24:37,379 --> 00:24:40,559
general-purpose virtual architecture

00:24:38,759 --> 00:24:43,619
there's despite the name web there's

00:24:40,559 --> 00:24:45,179
nothing specifically webby about it what

00:24:43,619 --> 00:24:46,590
we did is we we looked at the way

00:24:45,179 --> 00:24:47,940
JavaScript engines are currently

00:24:46,590 --> 00:24:49,289
constructed in there they're really

00:24:47,940 --> 00:24:52,499
complex virtual machines where you've

00:24:49,289 --> 00:24:54,119
got a JavaScript engine v8 or or spider

00:24:52,499 --> 00:24:55,799
monkey that comes with a garbage

00:24:54,119 --> 00:24:57,869
collector it comes with a JIT compiler

00:24:55,799 --> 00:24:59,489
it comes with all these these capability

00:24:57,869 --> 00:25:01,349
that kind of is a virtual architecture

00:24:59,489 --> 00:25:02,789
unto itself and the way it interacts

00:25:01,349 --> 00:25:04,649
with the outside world or through API is

00:25:02,789 --> 00:25:08,460
so the browser provides things like

00:25:04,649 --> 00:25:11,609
WebGL WebRTC and X DB node provides

00:25:08,460 --> 00:25:14,009
things like sockets and and file system

00:25:11,609 --> 00:25:16,769
access but we had this really good VM

00:25:14,009 --> 00:25:20,309
and had the JIT compiler and had the

00:25:16,769 --> 00:25:21,690
profilers and it had the optimizers but

00:25:20,309 --> 00:25:23,489
javascript is really hard language to

00:25:21,690 --> 00:25:25,109
work with and the the whole purpose of

00:25:23,489 --> 00:25:27,239
something like v8 or spider monkey is to

00:25:25,109 --> 00:25:29,009
take JavaScript and try to get it as

00:25:27,239 --> 00:25:31,499
close to native code as possible and

00:25:29,009 --> 00:25:33,570
then for things that are constantly and

00:25:31,499 --> 00:25:36,719
frequently called to compile just those

00:25:33,570 --> 00:25:37,950
bits into native code and so with

00:25:36,719 --> 00:25:39,359
weather symbol we can actually just put

00:25:37,950 --> 00:25:40,469
it right alongside JavaScript and say

00:25:39,359 --> 00:25:41,969
well hey you're trying to get to this

00:25:40,469 --> 00:25:44,159
point anyways we've done it for you we

00:25:41,969 --> 00:25:45,869
did it ahead of time I compile it on my

00:25:44,159 --> 00:25:48,960
laptop it's already optimized just run

00:25:45,869 --> 00:25:50,399
this and it works because we can reuse

00:25:48,960 --> 00:25:52,049
the existing architecture this also

00:25:50,399 --> 00:25:53,879
means that web assembly is running with

00:25:52,049 --> 00:25:55,889
the same sort of security properties as

00:25:53,879 --> 00:25:58,080
any other JavaScript running in the

00:25:55,889 --> 00:25:59,759
browser or on node where you don't have

00:25:58,080 --> 00:26:01,109
access to raw sockets you don't have

00:25:59,759 --> 00:26:02,789
access to to things that the web

00:26:01,109 --> 00:26:05,009
platform doesn't give you access to and

00:26:02,789 --> 00:26:06,809
and that's okay because web platform is

00:26:05,009 --> 00:26:08,279
capable and because this also minimizes

00:26:06,809 --> 00:26:10,289
the attack surface you don't have to

00:26:08,279 --> 00:26:12,839
worry about like when I go to a random

00:26:10,289 --> 00:26:14,009
web site I trust my browser to prevent

00:26:12,839 --> 00:26:15,239
the code running on that site from

00:26:14,009 --> 00:26:17,639
deleting all the files on my hard drive

00:26:15,239 --> 00:26:19,349
I don't have that same trust if I

00:26:17,639 --> 00:26:22,679
download a random binary from somewhere

00:26:19,349 --> 00:26:23,759
and run that but webassembly kind of

00:26:22,679 --> 00:26:26,369
splits the difference you get a binary

00:26:23,759 --> 00:26:29,269
but it runs in the browser sandbox it's

00:26:26,369 --> 00:26:29,269
fast it's safe

00:26:30,059 --> 00:26:35,830
so so what is all this

00:26:33,359 --> 00:26:37,049
at its core web assembly is a compiler

00:26:35,830 --> 00:26:39,580
target for the web

00:26:37,049 --> 00:26:42,039
it's a low-level binary format for

00:26:39,580 --> 00:26:44,529
programs built on an open standard with

00:26:42,039 --> 00:26:46,029
cross browser support it's a direct

00:26:44,529 --> 00:26:47,769
successor of Mozilla's experience with

00:26:46,029 --> 00:26:50,289
Azam's yes and it's a general-purpose

00:26:47,769 --> 00:26:52,989
virtual architecture so much like node

00:26:50,289 --> 00:26:54,429
took a JavaScript engine and took away

00:26:52,989 --> 00:26:55,479
the browser layer and just said well we

00:26:54,429 --> 00:26:57,359
can take this engine when you put some

00:26:55,479 --> 00:26:59,559
different api's on it and that's great

00:26:57,359 --> 00:27:01,029
well obviously works in both node in the

00:26:59,559 --> 00:27:03,609
browser and someone could conceivably

00:27:01,029 --> 00:27:05,139
build another runtime that's derived

00:27:03,609 --> 00:27:07,479
from neither of those that's tailored

00:27:05,139 --> 00:27:10,210
just to web assembly it's truly a

00:27:07,479 --> 00:27:13,419
general-purpose virtual architecture to

00:27:10,210 --> 00:27:14,919
target programs ad and this is

00:27:13,419 --> 00:27:16,899
interesting because well it doesn't

00:27:14,919 --> 00:27:18,940
replace JavaScript like not everyone is

00:27:16,899 --> 00:27:21,399
going to go and write C++ today because

00:27:18,940 --> 00:27:23,559
they saw this in the same way that node

00:27:21,399 --> 00:27:25,210
actually exists despite the option to

00:27:23,559 --> 00:27:26,739
write C++ on the server different tools

00:27:25,210 --> 00:27:28,839
are good for different different tasks

00:27:26,739 --> 00:27:30,639
but this expands what the web can do

00:27:28,839 --> 00:27:33,339
because previously the web only allowed

00:27:30,639 --> 00:27:34,869
you to to act at the high level and now

00:27:33,339 --> 00:27:37,239
we can have these hybrid designs where

00:27:34,869 --> 00:27:38,950
the core logic the core functionality

00:27:37,239 --> 00:27:41,529
might be in a lower level language like

00:27:38,950 --> 00:27:44,049
web assembly but the application logic

00:27:41,529 --> 00:27:45,519
might live in JavaScript it means that

00:27:44,049 --> 00:27:48,609
for compilers the web is just another

00:27:45,519 --> 00:27:52,659
platform it's here today it really works

00:27:48,609 --> 00:27:53,440
and it's got a bright future we're

00:27:52,659 --> 00:27:55,239
working on adding things like

00:27:53,440 --> 00:27:58,719
multi-threading garbage collection

00:27:55,239 --> 00:28:00,249
better tooling sem d support many other

00:27:58,719 --> 00:28:02,619
things to webassembly over the next next

00:28:00,249 --> 00:28:06,070
few years I think the ability for us to

00:28:02,619 --> 00:28:09,070
go from zero browsers supporting it to

00:28:06,070 --> 00:28:11,169
all browsers supporting it within the

00:28:09,070 --> 00:28:14,349
space of a year is really encouraging

00:28:11,169 --> 00:28:15,759
and I think I think speaks to the fact

00:28:14,349 --> 00:28:17,139
that this will continue to evolve and

00:28:15,759 --> 00:28:22,149
you'll be able to use the things that

00:28:17,139 --> 00:28:23,080
come out in the future a couple of

00:28:22,149 --> 00:28:25,589
questions that people have asked me that

00:28:23,080 --> 00:28:27,489
I want to want to cover before I close

00:28:25,589 --> 00:28:29,200
people here about this like I can

00:28:27,489 --> 00:28:32,200
finally stop using javascript or is

00:28:29,200 --> 00:28:35,499
JavaScript dead and no Java scripts

00:28:32,200 --> 00:28:37,960
alive but it's client-side monopoly is

00:28:35,499 --> 00:28:40,330
dead the the notion that you can only

00:28:37,960 --> 00:28:41,380
use javascript in the browser is no

00:28:40,330 --> 00:28:45,309
longer true you can use

00:28:41,380 --> 00:28:47,860
any language that you can compile but

00:28:45,309 --> 00:28:49,299
these complement each other well this

00:28:47,860 --> 00:28:51,009
simply is low-level it's binary

00:28:49,299 --> 00:28:55,059
javascript is high level in its textual

00:28:51,009 --> 00:28:57,159
there's a place for both makes new

00:28:55,059 --> 00:28:58,600
things possible what about older

00:28:57,159 --> 00:29:03,399
browsers well I said that web assembly

00:28:58,600 --> 00:29:05,919
started as a direct successor to as MJS

00:29:03,399 --> 00:29:09,490
as MJS is just JavaScript but with some

00:29:05,919 --> 00:29:12,130
weird little annotations that let

00:29:09,490 --> 00:29:15,309
certain engines edge Firefox etc run it

00:29:12,130 --> 00:29:16,990
faster but it still is JavaScript so it

00:29:15,309 --> 00:29:19,600
does work everywhere and so you can use

00:29:16,990 --> 00:29:21,309
it as a fallback the most common

00:29:19,600 --> 00:29:25,139
compiler chain right now they use dim

00:29:21,309 --> 00:29:27,549
script them take C or C++ or rust

00:29:25,139 --> 00:29:31,899
compile it to as MJS and then compiles

00:29:27,549 --> 00:29:33,970
the azzam js2 web assembly you can just

00:29:31,899 --> 00:29:35,529
save them and you know inscription does

00:29:33,970 --> 00:29:37,299
the first step in re n does the second

00:29:35,529 --> 00:29:39,600
step we're working on adding native

00:29:37,299 --> 00:29:43,120
support to web for web assembly to LLVM

00:29:39,600 --> 00:29:44,980
should be coming soon ish but for now

00:29:43,120 --> 00:29:46,330
you can just save the as MJS and the web

00:29:44,980 --> 00:29:48,039
assembly and say well do you support web

00:29:46,330 --> 00:29:49,450
symbol use that if not use azzam j/s

00:29:48,039 --> 00:29:52,600
it'll still work it just won't be as

00:29:49,450 --> 00:29:53,919
fast other people ask well web

00:29:52,600 --> 00:29:55,870
assemblies so fast can I compile my

00:29:53,919 --> 00:30:01,419
JavaScript for my typescript - what

00:29:55,870 --> 00:30:02,860
assembly no don't do that just like if

00:30:01,419 --> 00:30:04,360
you wrote a program in JavaScript or a

00:30:02,860 --> 00:30:05,679
program in Ruby or a program in Python

00:30:04,360 --> 00:30:08,049
you have to distribute the runtime with

00:30:05,679 --> 00:30:10,659
it compared to a program in C where you

00:30:08,049 --> 00:30:12,009
can just send the binary around you'd

00:30:10,659 --> 00:30:13,360
have to ship your own JavaScript runtime

00:30:12,009 --> 00:30:15,700
you'd have to ship your own equivalent

00:30:13,360 --> 00:30:17,080
to v8 or spider monkey if you did this

00:30:15,700 --> 00:30:18,669
cuz well as immed uhz n't know anything

00:30:17,080 --> 00:30:20,559
about java javascript it doesn't know

00:30:18,669 --> 00:30:23,620
anything about modules or arrays or

00:30:20,559 --> 00:30:25,240
objects and your browser already has a

00:30:23,620 --> 00:30:28,090
really good runtime for javascript it

00:30:25,240 --> 00:30:29,289
knows all the dirty tricks so so trying

00:30:28,090 --> 00:30:31,179
to re-implement that isn't going to get

00:30:29,289 --> 00:30:32,470
you very far but what web assembly is

00:30:31,179 --> 00:30:35,230
good at is different from what java

00:30:32,470 --> 00:30:36,899
scripts good at other people ask what

00:30:35,230 --> 00:30:41,379
about type errors so web this simply has

00:30:36,899 --> 00:30:44,289
the the well defined by 32 I 64 F 32 f

00:30:41,379 --> 00:30:45,970
64 types well I can JavaScript the

00:30:44,289 --> 00:30:48,159
browser courses types at that boundary

00:30:45,970 --> 00:30:49,360
and a compile time you can check to make

00:30:48,159 --> 00:30:53,379
sure there are no tight mismatches

00:30:49,360 --> 00:30:54,960
within web assembly Eckler script has

00:30:53,379 --> 00:30:56,190
really well-defined rules for what

00:30:54,960 --> 00:30:57,630
if you passed the wrong type to a

00:30:56,190 --> 00:30:58,890
function that is expecting something

00:30:57,630 --> 00:31:00,600
else so in the same way that you're not

00:30:58,890 --> 00:31:02,010
worried about like calling the square

00:31:00,600 --> 00:31:03,600
root of hello world crashing your

00:31:02,010 --> 00:31:05,640
browser it's not gonna crash a web

00:31:03,600 --> 00:31:07,200
assembly program either that string is

00:31:05,640 --> 00:31:08,640
going to get turned into a number that's

00:31:07,200 --> 00:31:12,419
gonna be passed to a function if it

00:31:08,640 --> 00:31:15,200
wants a number it works there are rules

00:31:12,419 --> 00:31:17,100
you can learn them it's fine

00:31:15,200 --> 00:31:19,350
but I've been talked about about these

00:31:17,100 --> 00:31:22,049
interesting hybrid applications a lot of

00:31:19,350 --> 00:31:27,240
a lot of the initial work in web

00:31:22,049 --> 00:31:35,250
assembly has gone into trying to take

00:31:27,240 --> 00:31:37,169
desktop apps game engines import them to

00:31:35,250 --> 00:31:38,340
the web and they can just render on a

00:31:37,169 --> 00:31:42,809
canvas you don't have to really care

00:31:38,340 --> 00:31:45,120
about anything in terms of I guess web

00:31:42,809 --> 00:31:46,710
enos it's kind of like flash it's not

00:31:45,120 --> 00:31:49,950
accessible it's not indexable but it

00:31:46,710 --> 00:31:51,059
works and you can play it the web's

00:31:49,950 --> 00:31:53,240
getting more capable and some really

00:31:51,059 --> 00:31:56,460
interesting things are happening so so

00:31:53,240 --> 00:31:58,649
something I saw that is webby in a

00:31:56,460 --> 00:32:04,140
different way this may take a minute to

00:31:58,649 --> 00:32:07,679
boot some folks built DOSBox

00:32:04,140 --> 00:32:12,419
which is a window or which is a 16-bit

00:32:07,679 --> 00:32:15,149
Intel emulator runs Doss they ported

00:32:12,419 --> 00:32:18,659
that to web assembly they got it to

00:32:15,149 --> 00:32:21,029
render to a canvas they're using that

00:32:18,659 --> 00:32:25,710
canvas as a texture inside a webview our

00:32:21,029 --> 00:32:28,169
environment so while this boots you know

00:32:25,710 --> 00:32:30,000
I can look around and it's actually

00:32:28,169 --> 00:32:31,440
fully multi-user so that that little

00:32:30,000 --> 00:32:33,120
smartphone you see flying there is

00:32:31,440 --> 00:32:36,120
another tab I have open in case the

00:32:33,120 --> 00:32:40,679
internet didn't work so this is gonna

00:32:36,120 --> 00:32:44,299
finish loading and let's see so it's

00:32:40,679 --> 00:32:44,299
gonna try to make a dial-up connection

00:32:44,809 --> 00:32:56,640
do to do come on windsock so we'll mute

00:32:54,179 --> 00:32:58,590
that but so so the person that built

00:32:56,640 --> 00:33:01,950
this demo has this talking over a

00:32:58,590 --> 00:33:03,960
WebSocket emulating tcp/ip so you can

00:33:01,950 --> 00:33:05,480
actually get to the outside world but

00:33:03,960 --> 00:33:11,090
for now I can do things like I can run

00:33:05,480 --> 00:33:11,090
solitaire and I can

00:33:11,180 --> 00:33:18,150
to do paintbrush and this is running on

00:33:14,730 --> 00:33:20,520
a Windows emulator on a 16-bit Intel

00:33:18,150 --> 00:33:21,750
emulator in my browser so we all

00:33:20,520 --> 00:33:23,520
compiled web assembly so it works

00:33:21,750 --> 00:33:25,410
anywhere like my computer is Intel based

00:33:23,520 --> 00:33:26,700
but it also works on my phone which is a

00:33:25,410 --> 00:33:29,040
completely different architecture which

00:33:26,700 --> 00:33:31,380
which gives you that magic that the web

00:33:29,040 --> 00:33:32,880
is supposed to work everywhere and you

00:33:31,380 --> 00:33:38,430
know this works I can say hello

00:33:32,880 --> 00:33:42,740
Jas comp Budapest and yeah go spray

00:33:38,430 --> 00:33:49,770
paint tool give it some some sparkles

00:33:42,740 --> 00:33:51,150
yay but we can we can preserve some of

00:33:49,770 --> 00:33:52,470
our digital Heritage's this way which i

00:33:51,150 --> 00:33:54,750
think is also really really fascinating

00:33:52,470 --> 00:33:56,550
but you can take all these existing

00:33:54,750 --> 00:33:57,930
programs and all this existing software

00:33:56,550 --> 00:34:00,210
and you can bring it to the web and it's

00:33:57,930 --> 00:34:01,500
not locked into a platform specific

00:34:00,210 --> 00:34:07,050
binary anymore if you can bring the

00:34:01,500 --> 00:34:08,550
platform itself to the web and so I look

00:34:07,050 --> 00:34:10,770
at this and I think about the potential

00:34:08,550 --> 00:34:12,780
here it takes way too long to load you

00:34:10,770 --> 00:34:16,520
can also load Netscape which is kind of

00:34:12,780 --> 00:34:16,520
ironic running Netscape inside Firefox

00:34:17,210 --> 00:34:26,530
it'll take a minute but

00:34:20,239 --> 00:34:28,730
[Applause]

00:34:26,530 --> 00:34:32,300
but I look at this and I think about the

00:34:28,730 --> 00:34:33,619
potential that we have in terms of we in

00:34:32,300 --> 00:34:35,839
the web community in the JavaScript

00:34:33,619 --> 00:34:37,399
community learning from and leveraging

00:34:35,839 --> 00:34:38,599
all of the software and all the

00:34:37,399 --> 00:34:41,780
knowledge that's out there in the C and

00:34:38,599 --> 00:34:43,040
C++ worlds and then creating new things

00:34:41,780 --> 00:34:44,480
with them and teaching them about the

00:34:43,040 --> 00:34:46,129
web and creating these hybrid

00:34:44,480 --> 00:34:48,349
experiences that leverage the strengths

00:34:46,129 --> 00:34:49,849
of both platforms there's a great

00:34:48,349 --> 00:34:52,220
initiative right now on the rust foreign

00:34:49,849 --> 00:34:55,069
language to make web assembly one of

00:34:52,220 --> 00:34:56,149
rusts primary tier one platforms so that

00:34:55,069 --> 00:34:58,609
if you want to build for the web you

00:34:56,149 --> 00:35:01,160
build in rust and compile it to web

00:34:58,609 --> 00:35:02,770
assembly and I think that'll be again a

00:35:01,160 --> 00:35:04,970
really positive development if we can

00:35:02,770 --> 00:35:06,589
can manage to come together and bridge

00:35:04,970 --> 00:35:08,329
these these two communities because we

00:35:06,589 --> 00:35:10,849
know things that they don't I mean the

00:35:08,329 --> 00:35:12,500
Unity engine knows a little bit about

00:35:10,849 --> 00:35:14,599
the web the Unreal Engine they're used

00:35:12,500 --> 00:35:16,609
to being able to come on DVDs or come on

00:35:14,599 --> 00:35:18,800
like massive Steam downloads or a

00:35:16,609 --> 00:35:19,849
multi-gigabyte you can't do that on the

00:35:18,800 --> 00:35:21,829
web you have to be able to stream your

00:35:19,849 --> 00:35:23,869
assets you have to be a smaller smaller

00:35:21,829 --> 00:35:27,980
package and we can teach them how to do

00:35:23,869 --> 00:35:31,400
that obviously home DM kaam kaam is not

00:35:27,980 --> 00:35:34,280
going to load and also anything over SSL

00:35:31,400 --> 00:35:38,359
is not going to work because we don't

00:35:34,280 --> 00:35:38,980
support TLS 1.1 Netscape 3 but you get

00:35:38,359 --> 00:35:41,720
the idea right

00:35:38,980 --> 00:35:45,410
brand-new things are possible web

00:35:41,720 --> 00:35:47,480
assembly is here it's real please come

00:35:45,410 --> 00:35:52,390
talk to me please experiment this keep

00:35:47,480 --> 00:35:56,790
your eyes out the web is it's just

00:35:52,390 --> 00:36:02,890
amazing today thank you so much

00:35:56,790 --> 00:36:06,100
[Applause]

00:36:02,890 --> 00:36:06,100

YouTube URL: https://www.youtube.com/watch?v=bac0dGQbUto


