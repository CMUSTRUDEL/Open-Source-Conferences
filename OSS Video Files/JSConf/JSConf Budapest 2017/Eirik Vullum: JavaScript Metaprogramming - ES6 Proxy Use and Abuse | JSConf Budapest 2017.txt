Title: Eirik Vullum: JavaScript Metaprogramming - ES6 Proxy Use and Abuse | JSConf Budapest 2017
Publication date: 2017-12-01
Playlist: JSConf Budapest 2017
Description: 
	This non-polyfillable / non-transpilable feature now has first class support in all the latest browsers and node.js!

But what is it even? And why do I need it?

Letâ€™s take a closer look at this metaprogramming feature with some useful, abuseful and just plain fun uses of ES6 Proxy.

http://jsconfbp.com/speakers/eirik-vullum/
Captions: 
	00:00:00,030 --> 00:00:07,639
- sound yeah okay yeah thanks so much

00:00:05,609 --> 00:00:10,800
for having me

00:00:07,639 --> 00:00:12,750
just to get a slight feel how many of

00:00:10,800 --> 00:00:18,240
you have ever done any metaprogramming

00:00:12,750 --> 00:00:20,520
show me a hand so it's sort of a trick

00:00:18,240 --> 00:00:22,680
question because I'm I'm pretty sure if

00:00:20,520 --> 00:00:25,859
you've ever programmed in JavaScript

00:00:22,680 --> 00:00:29,460
you've done some meta programming just

00:00:25,859 --> 00:00:31,949
don't know it I'm Eric I'm an

00:00:29,460 --> 00:00:35,489
independent consultant and JavaScript

00:00:31,949 --> 00:00:37,649
trainer from Oslo and I spent most of my

00:00:35,489 --> 00:00:40,860
days either building things in

00:00:37,649 --> 00:00:44,760
JavaScript or teaching JavaScript and

00:00:40,860 --> 00:00:47,690
the react stack and for a while now I've

00:00:44,760 --> 00:00:51,449
been pretty hung up on meta programming

00:00:47,690 --> 00:00:55,110
and when I think about meta programming

00:00:51,449 --> 00:00:58,590
I think about these guys Wizards doing

00:00:55,110 --> 00:01:01,010
wizard II things because at first at

00:00:58,590 --> 00:01:03,290
least it feels a lot of it feels

00:01:01,010 --> 00:01:08,040
indistinguishable from magic

00:01:03,290 --> 00:01:11,760
but what is meta programming so I try to

00:01:08,040 --> 00:01:14,220
ask Wikipedia and ditka pedia says that

00:01:11,760 --> 00:01:18,630
meta programming is the ability to treat

00:01:14,220 --> 00:01:21,960
programs as data and the ability to read

00:01:18,630 --> 00:01:24,180
generate analyze or transform other

00:01:21,960 --> 00:01:27,659
programs and even modify itself while

00:01:24,180 --> 00:01:31,710
running so I think I'll go with that

00:01:27,659 --> 00:01:36,170
and there's two main branches of meta

00:01:31,710 --> 00:01:40,320
programming one of them is macros and

00:01:36,170 --> 00:01:44,630
macros enables you to create your own

00:01:40,320 --> 00:01:47,460
syntax so here's an example where we use

00:01:44,630 --> 00:01:50,159
sweet J's which is a macro system for

00:01:47,460 --> 00:01:53,759
JavaScript to create some custom syntax

00:01:50,159 --> 00:01:56,600
so I'll make my own syntax here and I

00:01:53,759 --> 00:01:59,460
can use that syntax in my code and

00:01:56,600 --> 00:02:01,640
before that code actually runs it gets

00:01:59,460 --> 00:02:07,020
compiled to whatever that syntax means

00:02:01,640 --> 00:02:09,509
and you can also make your own operators

00:02:07,020 --> 00:02:12,450
so let's say that I'm really tired of

00:02:09,509 --> 00:02:13,290
saying dot then I don't like writing dot

00:02:12,450 --> 00:02:15,540
then

00:02:13,290 --> 00:02:19,950
chaining promises so I'm making my own

00:02:15,540 --> 00:02:23,069
operator for that so now I can use that

00:02:19,950 --> 00:02:25,290
operator in my code and before that code

00:02:23,069 --> 00:02:29,959
actually runs its compiled down to

00:02:25,290 --> 00:02:33,209
actual promise chaining so you can use

00:02:29,959 --> 00:02:35,040
macros then to sort of extend your

00:02:33,209 --> 00:02:37,680
language create your own dream language

00:02:35,040 --> 00:02:41,849
and all of this stuff happens during

00:02:37,680 --> 00:02:44,489
compile time or possibly and something

00:02:41,849 --> 00:02:48,389
called macro expansion time at least it

00:02:44,489 --> 00:02:52,579
happens before your code runs and that

00:02:48,389 --> 00:02:55,980
second branch is reflection and

00:02:52,579 --> 00:02:58,530
reflection has some sub branches where

00:02:55,980 --> 00:03:01,709
one of them is introspection meaning

00:02:58,530 --> 00:03:03,079
that you can the code connects inspect

00:03:01,709 --> 00:03:06,120
itself during runtime

00:03:03,079 --> 00:03:08,310
you have self modification meaning that

00:03:06,120 --> 00:03:11,340
you can change your code during runtime

00:03:08,310 --> 00:03:13,980
and then you have this thing called

00:03:11,340 --> 00:03:18,239
inner session meaning that the code can

00:03:13,980 --> 00:03:20,370
intercept and intervene with itself so a

00:03:18,239 --> 00:03:22,440
simple example of introspection would be

00:03:20,370 --> 00:03:26,099
let's say we have an object with some

00:03:22,440 --> 00:03:27,989
properties here and I use object keys to

00:03:26,099 --> 00:03:31,379
check which properties exist on this

00:03:27,989 --> 00:03:34,620
object and it gives me a result back so

00:03:31,379 --> 00:03:38,430
this is some of the one of the simplest

00:03:34,620 --> 00:03:40,889
examples of introspection and then you

00:03:38,430 --> 00:03:44,669
have self modification let's say that I

00:03:40,889 --> 00:03:48,060
have a function I have a grumpy some

00:03:44,669 --> 00:03:53,579
function that usually returns the sum of

00:03:48,060 --> 00:03:55,290
a and B but if you ever pass an A that's

00:03:53,579 --> 00:03:58,919
larger than five it'll just rewrite

00:03:55,290 --> 00:04:01,229
itself to just return zero so if I pass

00:03:58,919 --> 00:04:03,150
one plus one that's two if I pass ten

00:04:01,229 --> 00:04:07,379
plus one that's eleven but then it just

00:04:03,150 --> 00:04:09,439
starts returning zero so we've actually

00:04:07,379 --> 00:04:11,729
changed the functionality here during

00:04:09,439 --> 00:04:16,939
the runtime while our code is running

00:04:11,729 --> 00:04:16,939
and then we have inner session

00:04:17,449 --> 00:04:23,669
intercession is something that you can

00:04:19,799 --> 00:04:26,640
do in JavaScript already sort of by

00:04:23,669 --> 00:04:29,710
using object defined property

00:04:26,640 --> 00:04:32,350
so let's say we have a hero here and he

00:04:29,710 --> 00:04:35,500
has a health property but we also want

00:04:32,350 --> 00:04:38,740
to have a status field that is somehow

00:04:35,500 --> 00:04:42,550
based on his health so we'll define a

00:04:38,740 --> 00:04:45,010
new property status and we'll define a

00:04:42,550 --> 00:04:48,010
getter for that saying that if his

00:04:45,010 --> 00:04:51,040
health is larger than 50 he is fit like

00:04:48,010 --> 00:04:53,710
a champ otherwise he's badly hurt so

00:04:51,040 --> 00:04:58,330
here we have a property which functions

00:04:53,710 --> 00:05:01,510
based on the runtime conditions but this

00:04:58,330 --> 00:05:06,310
sort of of intercession in JavaScript is

00:05:01,510 --> 00:05:08,920
pretty limited so all of this reflection

00:05:06,310 --> 00:05:12,130
stuff happens during runtime while our

00:05:08,920 --> 00:05:15,100
code is running and that brings us over

00:05:12,130 --> 00:05:18,310
to it's a very natural question now is

00:05:15,100 --> 00:05:23,460
why is all of this useful why do we need

00:05:18,310 --> 00:05:27,010
this so I went and asked Wikipedia again

00:05:23,460 --> 00:05:29,350
and Wikipedia's answer is in some cases

00:05:27,010 --> 00:05:32,230
this allows programmers to minimize the

00:05:29,350 --> 00:05:33,820
number of lines of code to express a

00:05:32,230 --> 00:05:39,460
solution and thus reducing the

00:05:33,820 --> 00:05:41,530
development time I think I think I'd

00:05:39,460 --> 00:05:45,040
rather say that the reason why this is

00:05:41,530 --> 00:05:47,770
very useful is because we want as much

00:05:45,040 --> 00:05:52,060
expressivity as possible to model our

00:05:47,770 --> 00:05:54,010
problems and what we want is these

00:05:52,060 --> 00:06:00,100
elegant and developer friendly

00:05:54,010 --> 00:06:04,060
interfaces and this brings me to an

00:06:00,100 --> 00:06:06,960
interface that I'm pretty sure that a

00:06:04,060 --> 00:06:13,420
lot of you are familiar with which is

00:06:06,960 --> 00:06:18,370
proxies in the form of proxies on the

00:06:13,420 --> 00:06:21,190
web so a proxy is usually a server

00:06:18,370 --> 00:06:24,390
placed in front of one or more servers

00:06:21,190 --> 00:06:27,400
and this is to abstract the way

00:06:24,390 --> 00:06:31,030
complexity and to provide a single

00:06:27,400 --> 00:06:35,120
interface for the consumer so this

00:06:31,030 --> 00:06:39,940
enables you to actually intercept any

00:06:35,120 --> 00:06:44,330
any interaction with the interface and

00:06:39,940 --> 00:06:46,820
the use cases might be load balancing it

00:06:44,330 --> 00:06:50,389
might be delegating based on where the

00:06:46,820 --> 00:06:52,220
resources are and so on but the main

00:06:50,389 --> 00:06:54,320
thing is that you're providing a single

00:06:52,220 --> 00:06:57,100
unified interface for the consumer

00:06:54,320 --> 00:06:59,960
hiding all these implementation details

00:06:57,100 --> 00:07:02,530
and we can apply this concept more

00:06:59,960 --> 00:07:07,190
generally it doesn't have to be servers

00:07:02,530 --> 00:07:10,400
so we could instead place a proxy in

00:07:07,190 --> 00:07:12,620
front of a set of objects we can

00:07:10,400 --> 00:07:15,260
intercept any type of access to these

00:07:12,620 --> 00:07:20,030
objects and provide an abstraction to

00:07:15,260 --> 00:07:22,340
hide implementation details and this is

00:07:20,030 --> 00:07:29,020
what is made possible with proxies that

00:07:22,340 --> 00:07:31,970
was introduced in es6 and what this

00:07:29,020 --> 00:07:34,850
enables is a much more powerful form of

00:07:31,970 --> 00:07:40,070
intercession among other things in

00:07:34,850 --> 00:07:44,300
JavaScript and generally this means that

00:07:40,070 --> 00:07:46,940
we are now able to intercept and define

00:07:44,300 --> 00:07:49,400
custom behavior for fundamental

00:07:46,940 --> 00:07:53,289
operations on objects so that means

00:07:49,400 --> 00:07:57,320
properly lookup assignment enumeration

00:07:53,289 --> 00:08:00,590
even function invocation and so on and

00:07:57,320 --> 00:08:02,900
this is a very interesting feature for

00:08:00,590 --> 00:08:07,340
another reason as well because this is

00:08:02,900 --> 00:08:10,610
one of the few features that essentially

00:08:07,340 --> 00:08:13,760
requires engine support unlike most of

00:08:10,610 --> 00:08:16,639
use six which is syntax sugar that can

00:08:13,760 --> 00:08:21,310
be transpiled using Babel for example

00:08:16,639 --> 00:08:25,280
this isn't actually viable with proxies

00:08:21,310 --> 00:08:29,830
but thankfully the support has become

00:08:25,280 --> 00:08:35,560
pretty good except ie

00:08:29,830 --> 00:08:35,560
which hopefully yeah doesn't stop you

00:08:38,789 --> 00:08:46,420
so the proxy in JavaScript has its own

00:08:43,149 --> 00:08:50,339
constructor and the constructor takes a

00:08:46,420 --> 00:08:53,680
target object and a handler object and

00:08:50,339 --> 00:08:55,660
this target object can be any type of

00:08:53,680 --> 00:08:58,600
object it can be a plane object it can

00:08:55,660 --> 00:09:00,639
be an array it can be a function because

00:08:58,600 --> 00:09:04,180
functions are objects in JavaScript

00:09:00,639 --> 00:09:07,990
it can even be another proxy so you can

00:09:04,180 --> 00:09:10,180
proxy a proxy another important thing

00:09:07,990 --> 00:09:12,970
about proxies is that they're completely

00:09:10,180 --> 00:09:14,529
transparent so if I say that I'm

00:09:12,970 --> 00:09:18,939
creating a proxy here with a plain

00:09:14,529 --> 00:09:21,670
object as the target if I check type of

00:09:18,939 --> 00:09:24,629
of this proxy it'll give me object so

00:09:21,670 --> 00:09:29,500
there's no such thing as a proxy type

00:09:24,629 --> 00:09:32,680
it's entirely transparent and then

00:09:29,500 --> 00:09:35,620
there's the handler object and this is

00:09:32,680 --> 00:09:37,329
where we define so-called traps for all

00:09:35,620 --> 00:09:40,750
of these operations that you can do on

00:09:37,329 --> 00:09:43,839
objects and here's an example with a

00:09:40,750 --> 00:09:46,750
getter trap where we say that if you

00:09:43,839 --> 00:09:52,899
ever try to get a property from this

00:09:46,750 --> 00:09:54,790
object we'll just return 37 so we can

00:09:52,899 --> 00:09:58,389
create a new proxy using that Handler

00:09:54,790 --> 00:10:00,339
and if I try to access a from this

00:09:58,389 --> 00:10:04,180
object or B from this object it'll just

00:10:00,339 --> 00:10:06,730
keep returning 37 and for any available

00:10:04,180 --> 00:10:09,189
fundamental operation there is a

00:10:06,730 --> 00:10:13,209
corresponding trap so you have a getter

00:10:09,189 --> 00:10:16,930
trap you have a setter has apply and so

00:10:13,209 --> 00:10:21,910
on and you also have this accompanying

00:10:16,930 --> 00:10:24,040
new api called the reflect api which can

00:10:21,910 --> 00:10:28,839
be used to perform all of these

00:10:24,040 --> 00:10:30,850
operations on objects and an example of

00:10:28,839 --> 00:10:34,660
this is let's say we have an object here

00:10:30,850 --> 00:10:36,279
with a property we can use reflect get

00:10:34,660 --> 00:10:41,439
to say that we want to get the health

00:10:36,279 --> 00:10:44,230
property from this hero object so in the

00:10:41,439 --> 00:10:47,370
same way that there is a trap for every

00:10:44,230 --> 00:10:51,029
operation there is

00:10:47,370 --> 00:10:54,779
a corresponding method in the reflect

00:10:51,029 --> 00:10:58,589
API so if we do a complete one-to-one

00:10:54,779 --> 00:11:01,080
mapping here you'll get a proxy that is

00:10:58,589 --> 00:11:04,050
just a pure relay it doesn't do anything

00:11:01,080 --> 00:11:06,870
it'll behave the object will behave just

00:11:04,050 --> 00:11:10,290
as it would have if you didn't wrap it

00:11:06,870 --> 00:11:12,600
in a proxy so the nice thing now is that

00:11:10,290 --> 00:11:14,400
as I said you can have overload a lot of

00:11:12,600 --> 00:11:16,529
these fundamental operations like the

00:11:14,400 --> 00:11:21,900
dot operator the equals and the function

00:11:16,529 --> 00:11:23,940
call and one example of this is let's

00:11:21,900 --> 00:11:26,700
say we wanted to add some

00:11:23,940 --> 00:11:28,140
instrumentation to our code so we'll

00:11:26,700 --> 00:11:30,180
create a function that's called log

00:11:28,140 --> 00:11:34,560
access to properties it takes an object

00:11:30,180 --> 00:11:38,130
and we return a proxy with that object

00:11:34,560 --> 00:11:40,950
as the target object and then we pass it

00:11:38,130 --> 00:11:43,290
a handler object with a getter trap

00:11:40,950 --> 00:11:44,970
saying that ok if you ever try to get

00:11:43,290 --> 00:11:47,310
something from this object I'll log out

00:11:44,970 --> 00:11:50,150
whatever you try to get and then I'll

00:11:47,310 --> 00:11:52,740
return a result of actually getting that

00:11:50,150 --> 00:11:54,570
and we can also add a setter trap saying

00:11:52,740 --> 00:11:58,440
that if you try to set something will

00:11:54,570 --> 00:12:02,010
log out whatever you try to set and then

00:11:58,440 --> 00:12:04,320
we'll set that on the object and the

00:12:02,010 --> 00:12:06,209
nice thing here is that the object that

00:12:04,320 --> 00:12:08,490
is being wrapped in a proxy doesn't know

00:12:06,209 --> 00:12:10,500
about it and the proxy doesn't have to

00:12:08,490 --> 00:12:15,839
know anything about the object it's

00:12:10,500 --> 00:12:18,000
wrapping so it's completely decoupled so

00:12:15,839 --> 00:12:22,980
if you use this now we can create an

00:12:18,000 --> 00:12:26,040
object a bit like here we can create an

00:12:22,980 --> 00:12:29,250
object with some properties and then we

00:12:26,040 --> 00:12:32,970
can create a proxy using this function

00:12:29,250 --> 00:12:35,670
log access to properties so whenever I

00:12:32,970 --> 00:12:37,620
try to access a property here now it'll

00:12:35,670 --> 00:12:40,080
log out the access and if I try to

00:12:37,620 --> 00:12:46,230
change something it'll log out whatever

00:12:40,080 --> 00:12:50,900
you changed and we can also use proxies

00:12:46,230 --> 00:12:53,520
to make observable objects pretty easily

00:12:50,900 --> 00:12:55,800
so let's say we create us as a function

00:12:53,520 --> 00:12:58,800
called observable which takes an object

00:12:55,800 --> 00:13:00,660
that you want to observe and then it

00:12:58,800 --> 00:13:03,650
takes an unchanged function

00:13:00,660 --> 00:13:07,260
we'll call whenever something changes

00:13:03,650 --> 00:13:09,360
we'll return a new proxy put the object

00:13:07,260 --> 00:13:11,820
in the target putting a handler which

00:13:09,360 --> 00:13:14,190
has a set trap so whenever you try to

00:13:11,820 --> 00:13:16,230
set something on this object will

00:13:14,190 --> 00:13:18,000
actually set it and then afterwards

00:13:16,230 --> 00:13:22,470
we'll call the unchanged method with

00:13:18,000 --> 00:13:26,010
whatever you updated so if you want to

00:13:22,470 --> 00:13:29,000
use this this isn't actually as useful

00:13:26,010 --> 00:13:33,030
as true observables because we have to

00:13:29,000 --> 00:13:35,280
overwrite the original object but now we

00:13:33,030 --> 00:13:38,400
can create an object here that is

00:13:35,280 --> 00:13:40,260
observable so if I ever change if I

00:13:38,400 --> 00:13:41,880
change the name here it'll log out name

00:13:40,260 --> 00:13:47,070
change to Frank if I change the age

00:13:41,880 --> 00:13:50,040
it'll log out the age change to 40 so

00:13:47,070 --> 00:13:53,970
all of this is nice but it's not really

00:13:50,040 --> 00:13:57,690
something that would revolutionize how

00:13:53,970 --> 00:13:59,520
you write code in JavaScript so I tried

00:13:57,690 --> 00:14:00,750
to I try to think about I didn't really

00:13:59,520 --> 00:14:04,980
want to do this talk before I had

00:14:00,750 --> 00:14:09,180
something useful to do do you use

00:14:04,980 --> 00:14:10,860
proxies for so for the last year I've

00:14:09,180 --> 00:14:13,800
been working on a client project with a

00:14:10,860 --> 00:14:15,180
lot of people where we have a large

00:14:13,800 --> 00:14:19,830
amount of real-time data

00:14:15,180 --> 00:14:21,480
think something like firebase and we

00:14:19,830 --> 00:14:25,250
have a lot of data that looks like this

00:14:21,480 --> 00:14:29,850
let's say we have we have a collection

00:14:25,250 --> 00:14:32,730
we have a collection of stories and

00:14:29,850 --> 00:14:35,160
every story has an ID it has a title it

00:14:32,730 --> 00:14:37,530
has an author it has a list of people

00:14:35,160 --> 00:14:39,900
that have liked this story that have

00:14:37,530 --> 00:14:42,720
read this story and so on and what you

00:14:39,900 --> 00:14:49,590
can see here is that it's just

00:14:42,720 --> 00:14:52,400
references and we can also imagine that

00:14:49,590 --> 00:14:56,280
we have another list here of people and

00:14:52,400 --> 00:15:01,880
these people have authored books they

00:14:56,280 --> 00:15:04,140
have read books they have liked books so

00:15:01,880 --> 00:15:05,700
what we see here is that these

00:15:04,140 --> 00:15:08,940
references are actually pointing to

00:15:05,700 --> 00:15:11,890
different objects so the person one here

00:15:08,940 --> 00:15:14,800
is pointing to person one in our

00:15:11,890 --> 00:15:19,120
in our people collection and story one

00:15:14,800 --> 00:15:23,520
here is are all pointing to the first

00:15:19,120 --> 00:15:27,490
story so what we really have here is

00:15:23,520 --> 00:15:29,890
it's sort of a graph so if we just

00:15:27,490 --> 00:15:31,750
consolidate this into an object we have

00:15:29,890 --> 00:15:34,020
a collection of stories and we have a

00:15:31,750 --> 00:15:39,010
collection of people and they're all

00:15:34,020 --> 00:15:41,410
connected together in different ways so

00:15:39,010 --> 00:15:43,450
what does it look like if you want to

00:15:41,410 --> 00:15:45,850
traverse this thing let's say you want

00:15:43,450 --> 00:15:49,450
you need to traverse this thing very

00:15:45,850 --> 00:15:52,000
deeply so we can start out then let's

00:15:49,450 --> 00:15:55,780
say we want to find we want to find the

00:15:52,000 --> 00:15:58,810
name of the first person that liked the

00:15:55,780 --> 00:16:01,630
first story so we'll go into the graph

00:15:58,810 --> 00:16:04,300
we'll pull out the first story we'll

00:16:01,630 --> 00:16:06,610
pull out the array of references but to

00:16:04,300 --> 00:16:09,730
people who have liked it we'll have to

00:16:06,610 --> 00:16:14,740
map it so that we can actually map it

00:16:09,730 --> 00:16:17,560
over to the actual objects and then

00:16:14,740 --> 00:16:19,300
you'll have to choose the first element

00:16:17,560 --> 00:16:23,470
of that and then we can pull out the

00:16:19,300 --> 00:16:26,080
name or if you want to find the title of

00:16:23,470 --> 00:16:29,050
the first like story by the author this

00:16:26,080 --> 00:16:31,390
is getting pretty deep now we'll have to

00:16:29,050 --> 00:16:34,830
get the right collection based on this

00:16:31,390 --> 00:16:38,320
reference we'll have to find the correct

00:16:34,830 --> 00:16:43,030
author and then we can pull out the

00:16:38,320 --> 00:16:48,270
title from there this gets really

00:16:43,030 --> 00:16:51,400
tedious it would be so much better if we

00:16:48,270 --> 00:16:54,550
could just access this like it was a

00:16:51,400 --> 00:16:58,390
plain object so that we can go into the

00:16:54,550 --> 00:17:01,990
first story we can go into the like by

00:16:58,390 --> 00:17:04,530
list and then just assume that that's

00:17:01,990 --> 00:17:08,580
the actual object not just a reference

00:17:04,530 --> 00:17:11,920
and the same thing with the title here

00:17:08,580 --> 00:17:13,720
so this is really this would be a much

00:17:11,920 --> 00:17:17,740
better interface to interact with this

00:17:13,720 --> 00:17:21,400
graph so what we really want our data to

00:17:17,740 --> 00:17:24,670
look like is something like this because

00:17:21,400 --> 00:17:26,049
what we have is just a reference here we

00:17:24,670 --> 00:17:29,789
are

00:17:26,049 --> 00:17:32,259
we're in story one and it has an author

00:17:29,789 --> 00:17:35,440
but what we really want is that author

00:17:32,259 --> 00:17:37,779
to be that object and again that has a

00:17:35,440 --> 00:17:41,830
list of stories that the author has

00:17:37,779 --> 00:17:46,389
liked and we would just rather have that

00:17:41,830 --> 00:17:49,090
be the actual story and so on

00:17:46,389 --> 00:17:53,559
and this goes on infinitely right

00:17:49,090 --> 00:17:57,099
because this is circular so we need some

00:17:53,559 --> 00:17:59,379
kind of way of transforming this object

00:17:57,099 --> 00:18:03,849
that contains only references to an

00:17:59,379 --> 00:18:05,589
actually populated object here so let's

00:18:03,849 --> 00:18:09,149
imagine that we could create an

00:18:05,589 --> 00:18:13,839
interface a function called populate

00:18:09,149 --> 00:18:16,330
which would take the graph as an

00:18:13,839 --> 00:18:19,539
argument and then the node you wanted to

00:18:16,330 --> 00:18:22,869
populate so as an example we we would

00:18:19,539 --> 00:18:27,940
want to have a populated version of the

00:18:22,869 --> 00:18:30,219
first story in our list but how could we

00:18:27,940 --> 00:18:34,659
ever implement this so the naive

00:18:30,219 --> 00:18:36,429
approach would be that okay I'll just

00:18:34,659 --> 00:18:39,009
use something like object a sign and

00:18:36,429 --> 00:18:41,889
just I don't know just keep filling this

00:18:39,009 --> 00:18:43,629
in recursively and until something just

00:18:41,889 --> 00:18:46,419
blows up right because it's infinite

00:18:43,629 --> 00:18:50,589
it's not possible it's just not possible

00:18:46,419 --> 00:18:55,839
to to do this in something that needs to

00:18:50,589 --> 00:18:59,909
evaluate upfront but this is a really

00:18:55,839 --> 00:18:59,909
nice use case for proxies

00:19:00,389 --> 00:19:07,869
so with proxies you can actually make

00:19:03,639 --> 00:19:11,169
this work because even if it seems like

00:19:07,869 --> 00:19:15,940
we have to do this upfront really really

00:19:11,169 --> 00:19:20,589
don't have to because with proxies just

00:19:15,940 --> 00:19:23,409
like with proxy web servers we could

00:19:20,589 --> 00:19:26,379
just say that okay I'm in story zero and

00:19:23,409 --> 00:19:28,210
I access the author but instead of

00:19:26,379 --> 00:19:31,239
actually returning the reference we

00:19:28,210 --> 00:19:34,839
could just redirect you to that actual

00:19:31,239 --> 00:19:38,859
object in the people collection and if

00:19:34,839 --> 00:19:39,070
you then access the story there we would

00:19:38,859 --> 00:19:45,460
just

00:19:39,070 --> 00:19:49,570
we direct you back so now using proxies

00:19:45,460 --> 00:19:52,590
we can actually have this nice interface

00:19:49,570 --> 00:19:56,950
by pretending that this is an infinitely

00:19:52,590 --> 00:20:01,059
nested object except it's just too flat

00:19:56,950 --> 00:20:02,799
lists in JSON and I'm wanted to show

00:20:01,059 --> 00:20:05,049
some code examples for how to do this

00:20:02,799 --> 00:20:08,139
but they just did not fit in to the

00:20:05,049 --> 00:20:10,470
slides in any a reasonable way so if

00:20:08,139 --> 00:20:16,029
anyone wants to take a look there's a

00:20:10,470 --> 00:20:21,610
open-source version of this and now I

00:20:16,029 --> 00:20:25,120
felt really excited because for the

00:20:21,610 --> 00:20:26,860
first time I felt that I had some proper

00:20:25,120 --> 00:20:28,539
use case for proxies because this was

00:20:26,860 --> 00:20:31,539
something that you couldn't do without

00:20:28,539 --> 00:20:34,559
proxies so I started to think about

00:20:31,539 --> 00:20:38,110
other things that I could use this for

00:20:34,559 --> 00:20:41,649
and thing I got a really good idea

00:20:38,110 --> 00:20:48,279
because we all have a beef with

00:20:41,649 --> 00:20:50,620
JavaScript right undefined it's not a

00:20:48,279 --> 00:20:53,259
function and cannot read properties

00:20:50,620 --> 00:20:56,259
something something of undefined and and

00:20:53,259 --> 00:21:01,570
yes I know about typescript and flow but

00:20:56,259 --> 00:21:06,220
there's no fun in that so with this as a

00:21:01,570 --> 00:21:08,440
starting point I figured all right I'm

00:21:06,220 --> 00:21:13,440
done with undefined not being a function

00:21:08,440 --> 00:21:17,110
so first up I want to redefine undefined

00:21:13,440 --> 00:21:19,149
so this is my own undefined and it's

00:21:17,110 --> 00:21:22,590
actually going to be a function the

00:21:19,149 --> 00:21:25,720
target object is a function just the

00:21:22,590 --> 00:21:29,679
empty function and I'll declare that

00:21:25,720 --> 00:21:31,450
this is gonna have a getter trap so

00:21:29,679 --> 00:21:35,740
whenever I try to get something from

00:21:31,450 --> 00:21:38,799
undefined notice that there's one kind

00:21:35,740 --> 00:21:41,889
of Lee key thing here is that functions

00:21:38,799 --> 00:21:43,750
need to have names so I had to kind of

00:21:41,889 --> 00:21:47,049
shim the name in here so that if you

00:21:43,750 --> 00:21:49,779
ever access name this doesn't you can't

00:21:47,049 --> 00:21:52,210
change any further on that but I'll just

00:21:49,779 --> 00:21:52,930
return undefined again so if you try to

00:21:52,210 --> 00:21:55,710
access something

00:21:52,930 --> 00:21:58,570
and then just get another undefined and

00:21:55,710 --> 00:22:00,040
if you ever tried to call undefined as a

00:21:58,570 --> 00:22:05,080
function I'll just return undefined

00:22:00,040 --> 00:22:09,880
again so now I figured we just need to

00:22:05,080 --> 00:22:12,730
make some seat belts for JavaScript so

00:22:09,880 --> 00:22:16,750
we have a function here that takes an

00:22:12,730 --> 00:22:20,590
object and it returns a proxy of that

00:22:16,750 --> 00:22:23,350
object and says that if you ever try to

00:22:20,590 --> 00:22:26,020
get something from this object will

00:22:23,350 --> 00:22:30,550
check does this property actually exist

00:22:26,020 --> 00:22:33,390
if it does if it doesn't it's an object

00:22:30,550 --> 00:22:37,240
will return another seat belt wrapped

00:22:33,390 --> 00:22:40,570
version of that object so that you can

00:22:37,240 --> 00:22:42,460
get this recursively but if that

00:22:40,570 --> 00:22:44,770
property doesn't exist meaning that it's

00:22:42,460 --> 00:22:47,620
undefined or no we'll just return our

00:22:44,770 --> 00:22:50,050
new undefined here and if it does exist

00:22:47,620 --> 00:22:56,590
we'll return the property that you tried

00:22:50,050 --> 00:22:58,750
to get so we can create a an object here

00:22:56,590 --> 00:23:00,430
now using the seat belt function just a

00:22:58,750 --> 00:23:06,220
plane object that has some properties

00:23:00,430 --> 00:23:10,030
with some values seems to work fine I

00:23:06,220 --> 00:23:16,300
can access foo I can access this nested

00:23:10,030 --> 00:23:19,630
field I can access name and so on but I

00:23:16,300 --> 00:23:22,900
can also do this now I can access

00:23:19,630 --> 00:23:25,060
something that's not here and something

00:23:22,900 --> 00:23:27,340
other that's not here that definitely

00:23:25,060 --> 00:23:30,790
isn't a function call that as a function

00:23:27,340 --> 00:23:33,160
and then pull out something else and you

00:23:30,790 --> 00:23:37,330
know what function is not undefined it's

00:23:33,160 --> 00:23:40,390
actually a function so now you can do

00:23:37,330 --> 00:23:45,610
things like this so no more crashing

00:23:40,390 --> 00:23:47,230
you've got seat belts but as I was I was

00:23:45,610 --> 00:23:51,030
pretty pleased with myself this was I

00:23:47,230 --> 00:23:51,030
don't know 4 a.m. some

00:23:51,659 --> 00:24:02,110
but there's just one bump in the road

00:23:55,929 --> 00:24:03,909
and that is I figured so this is nice

00:24:02,110 --> 00:24:05,529
but I still have to use this seatbelt

00:24:03,909 --> 00:24:08,139
thing I don't want to do that I want

00:24:05,529 --> 00:24:13,600
this to be automatic so I tried to do

00:24:08,139 --> 00:24:20,289
this I wanted to set the prototype as a

00:24:13,600 --> 00:24:24,159
seatbelt object and it turns out that it

00:24:20,289 --> 00:24:26,289
turns out that someone smart had figured

00:24:24,159 --> 00:24:31,480
out that this is not good

00:24:26,289 --> 00:24:33,850
and now this prototype object the bottom

00:24:31,480 --> 00:24:35,950
level prototype is a so-called exotic

00:24:33,850 --> 00:24:38,889
object so you cannot override the

00:24:35,950 --> 00:24:41,590
prototype I even tried to look for any

00:24:38,889 --> 00:24:45,669
version that implemented proxies but not

00:24:41,590 --> 00:24:48,580
this exotic object and I even considered

00:24:45,669 --> 00:24:51,039
compiling my own v8 for node and then

00:24:48,580 --> 00:24:52,500
making this work but I figured I'm just

00:24:51,039 --> 00:24:56,379
too far down the rabbit hole this is

00:24:52,500 --> 00:25:02,639
ridiculous so I figured I'm taking it

00:24:56,379 --> 00:25:08,440
too far but it would have been fun so

00:25:02,639 --> 00:25:14,399
with this I was really sad about that

00:25:08,440 --> 00:25:16,990
but in conclusion you can use proxies

00:25:14,399 --> 00:25:20,590
for a lot of good things you can make

00:25:16,990 --> 00:25:23,639
really powerful abstractions and you can

00:25:20,590 --> 00:25:26,350
add a lot of functionality transparently

00:25:23,639 --> 00:25:28,919
but the bad thing is that you can also

00:25:26,350 --> 00:25:31,799
just mangle things completely and

00:25:28,919 --> 00:25:34,149
introduce a lot of magic so that

00:25:31,799 --> 00:25:39,070
JavaScript doesn't really behave like

00:25:34,149 --> 00:25:41,470
JavaScript anymore but all in all I

00:25:39,070 --> 00:25:44,039
think this is another great tool in your

00:25:41,470 --> 00:25:47,649
toolbox to build your dream interfaces

00:25:44,039 --> 00:25:49,690
so you should go ahead and figure out if

00:25:47,649 --> 00:25:52,960
you have some kind of thing you want to

00:25:49,690 --> 00:25:55,240
solve that just doesn't work in plain

00:25:52,960 --> 00:25:58,470
JavaScript you should try to see if

00:25:55,240 --> 00:26:01,500
proxies can help you with that and

00:25:58,470 --> 00:26:05,990
that's it

00:26:01,500 --> 00:26:05,990
[Applause]

00:26:08,970 --> 00:26:11,030

YouTube URL: https://www.youtube.com/watch?v=_5X2aB_mNp4


