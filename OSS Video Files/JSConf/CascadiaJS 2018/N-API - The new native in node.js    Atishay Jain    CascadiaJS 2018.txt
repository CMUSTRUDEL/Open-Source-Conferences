Title: N-API - The new native in node.js    Atishay Jain    CascadiaJS 2018
Publication date: 2018-12-10
Playlist: CascadiaJS 2018
Description: 
	Ever tried calling C++ from Node or Electron. Hate native modules because of the compilation and maintenance issues. This talk is all about the solution to this problem - N-API that is stable with node 10. C++ to Node.js interop is a lot of fun.

https://2018.cascadiajs.com/
Captions: 
	00:00:00,110 --> 00:00:07,980
hello Cascadia welcome to the N API

00:00:05,160 --> 00:00:11,130
session my name is Etta Shea and I'm a

00:00:07,980 --> 00:00:13,139
developer at Adobe I'm here today to get

00:00:11,130 --> 00:00:16,320
you all excited about writing native

00:00:13,139 --> 00:00:18,539
modules in no js' in building

00:00:16,320 --> 00:00:21,720
functionality that would bridge the

00:00:18,539 --> 00:00:28,050
grand old C++ language with the modern

00:00:21,720 --> 00:00:31,199
the hip the class II JavaScript a few

00:00:28,050 --> 00:00:34,200
tidbits about me I work in San Francisco

00:00:31,199 --> 00:00:43,230
and I am co-located with most of the

00:00:34,200 --> 00:00:46,219
former flash team here's a view of this

00:00:43,230 --> 00:00:48,600
San Francisco skyline right from my desk

00:00:46,219 --> 00:00:51,180
over the years I've worked with a

00:00:48,600 --> 00:00:53,239
variety of technology stacks I've worked

00:00:51,180 --> 00:00:55,949
on flagship desktop applications

00:00:53,239 --> 00:00:58,739
award-winning mobile software but my

00:00:55,949 --> 00:01:01,079
heart still lies with the vamp the first

00:00:58,739 --> 00:01:03,870
website that I worked on was all in

00:01:01,079 --> 00:01:09,270
flash and the lamp stack we cared a lot

00:01:03,870 --> 00:01:12,049
about ie6 back then over time I have

00:01:09,270 --> 00:01:15,509
moved on and covered up the HTML

00:01:12,049 --> 00:01:16,740
progression with that I've been

00:01:15,509 --> 00:01:18,900
rewriting my website

00:01:16,740 --> 00:01:21,570
the latest rewrite happened just a month

00:01:18,900 --> 00:01:26,759
ago when I moved off bootstrap on to CSS

00:01:21,570 --> 00:01:29,340
grid and Adobe I work on a background

00:01:26,759 --> 00:01:31,380
process this process synchronizes all

00:01:29,340 --> 00:01:33,030
the network i/o that adobe applications

00:01:31,380 --> 00:01:35,280
due to the cloud

00:01:33,030 --> 00:01:37,829
since it is i/o heavy the best

00:01:35,280 --> 00:01:41,130
technology to write this in is no js'

00:01:37,829 --> 00:01:43,560
and adobe this ship a node.js based

00:01:41,130 --> 00:01:45,899
process a node.js based background

00:01:43,560 --> 00:01:47,820
process to millions of customers that

00:01:45,899 --> 00:01:49,829
run our products if you've used

00:01:47,820 --> 00:01:51,450
Photoshop in the last three four years

00:01:49,829 --> 00:01:54,630
you would have interacted with this

00:01:51,450 --> 00:01:55,920
process in the background since we

00:01:54,630 --> 00:01:58,530
shipped to a variety of machine

00:01:55,920 --> 00:02:01,110
configurations and node.js is really

00:01:58,530 --> 00:02:03,329
built for the server side there are some

00:02:01,110 --> 00:02:05,250
issues that node doesn't solve and for

00:02:03,329 --> 00:02:08,129
that we need to go down to the native

00:02:05,250 --> 00:02:12,180
layer and to go down to the native layer

00:02:08,129 --> 00:02:13,379
means working in C++ I am the go-to guy

00:02:12,180 --> 00:02:17,579
in my team to

00:02:13,379 --> 00:02:20,310
with C++ and I've been doing it for the

00:02:17,579 --> 00:02:22,980
last three years in this talk today

00:02:20,310 --> 00:02:25,739
we'll talk about why we should write or

00:02:22,980 --> 00:02:27,659
when we should write native code we will

00:02:25,739 --> 00:02:32,159
talk about the various ways to interact

00:02:27,659 --> 00:02:34,409
with native code from Vidin nodejs we

00:02:32,159 --> 00:02:38,310
will go through a running example of a n

00:02:34,409 --> 00:02:41,370
a n n API based plugin to node.js a

00:02:38,310 --> 00:02:44,340
module that looks like JavaScript but is

00:02:41,370 --> 00:02:47,069
written in C++ we will do a synchronous

00:02:44,340 --> 00:02:48,750
asynchronous version as well and then

00:02:47,069 --> 00:02:51,359
we'll be also running it in electron

00:02:48,750 --> 00:02:53,549
I'll share some tips and tricks to be

00:02:51,359 --> 00:02:55,980
successful in the native world and leave

00:02:53,549 --> 00:02:57,659
you all with a bunch of resources to

00:02:55,980 --> 00:03:01,349
play with at the end of the conference

00:02:57,659 --> 00:03:04,739
as JavaScript developers we are like

00:03:01,349 --> 00:03:07,260
astronauts we fly in the space and don't

00:03:04,739 --> 00:03:12,180
really care about what happens down at

00:03:07,260 --> 00:03:14,639
the mother earth actually sometimes we

00:03:12,180 --> 00:03:16,650
do have to sometimes each Iowa script

00:03:14,639 --> 00:03:20,090
developers do have to go down a layer

00:03:16,650 --> 00:03:23,459
into the world of unmanaged memory of

00:03:20,090 --> 00:03:30,900
multi-threaded architectures and my

00:03:23,459 --> 00:03:32,459
favorite segmentation faults this what

00:03:30,900 --> 00:03:37,169
let me talk about what this talk is not

00:03:32,459 --> 00:03:39,209
about this talk is not about the v8

00:03:37,169 --> 00:03:41,940
engine the engine that's used to build

00:03:39,209 --> 00:03:43,650
node.js we will not be going into the v8

00:03:41,940 --> 00:03:46,829
internals or learning how it works

00:03:43,650 --> 00:03:48,659
this talk is also not about the C++

00:03:46,829 --> 00:03:51,030
programming language why we will be

00:03:48,659 --> 00:03:55,590
using C++ there are better ways to learn

00:03:51,030 --> 00:03:57,449
C++ this talk is also not about

00:03:55,590 --> 00:03:59,840
improving the performance of your node

00:03:57,449 --> 00:04:02,430
based application frankly speaking

00:03:59,840 --> 00:04:04,439
poorly written native code would be a

00:04:02,430 --> 00:04:09,989
lot worse than average JavaScript code

00:04:04,439 --> 00:04:12,090
it would crash your app what this talk

00:04:09,989 --> 00:04:14,340
is really about is about building

00:04:12,090 --> 00:04:16,409
modules it's about extending the node

00:04:14,340 --> 00:04:18,209
ecosystem with the functionality that

00:04:16,409 --> 00:04:20,130
was not practically or efficiently

00:04:18,209 --> 00:04:22,680
possible with the current state of

00:04:20,130 --> 00:04:25,380
JavaScript it's about writing a module

00:04:22,680 --> 00:04:26,780
that looks and behaves just like any

00:04:25,380 --> 00:04:28,790
other module in the node

00:04:26,780 --> 00:04:34,190
ecosystem but in from the insight is

00:04:28,790 --> 00:04:36,560
written in a very different way so let's

00:04:34,190 --> 00:04:38,690
get started why would we write native

00:04:36,560 --> 00:04:40,460
code that's a big question that comes up

00:04:38,690 --> 00:04:44,780
whenever we talk about native code

00:04:40,460 --> 00:04:47,210
javascript has everything well there are

00:04:44,780 --> 00:04:49,630
a few things that make JavaScript

00:04:47,210 --> 00:04:53,540
slightly difficult to write for example

00:04:49,630 --> 00:04:55,340
your OSS are mostly written in C C++ or

00:04:53,540 --> 00:04:57,800
expose their functionality in those

00:04:55,340 --> 00:05:00,470
languages something new came out the

00:04:57,800 --> 00:05:02,240
dark mode in Mohave what do you do do

00:05:00,470 --> 00:05:05,180
you wait for it to be standardized to

00:05:02,240 --> 00:05:08,330
use it in a node app you could directly

00:05:05,180 --> 00:05:10,520
include it for in C++ in electron you

00:05:08,330 --> 00:05:12,470
could write C++ code to read the current

00:05:10,520 --> 00:05:13,690
state or the dark mode and show it to

00:05:12,470 --> 00:05:16,040
the user

00:05:13,690 --> 00:05:18,800
the second big reason to write native

00:05:16,040 --> 00:05:22,840
code is if you have some C++ code lying

00:05:18,800 --> 00:05:26,210
around C++ is a thirty-year-old

00:05:22,840 --> 00:05:28,460
developed very values language we have

00:05:26,210 --> 00:05:31,720
tons of production ready code in C++ and

00:05:28,460 --> 00:05:34,760
not all of that compiles to webassembly

00:05:31,720 --> 00:05:35,900
so kind we are kind of forced if you

00:05:34,760 --> 00:05:38,390
want to do you want to rewrite

00:05:35,900 --> 00:05:40,130
everything in jeaious or maybe just for

00:05:38,390 --> 00:05:42,169
this case let's use what we have and

00:05:40,130 --> 00:05:45,979
that is a very good use case for going

00:05:42,169 --> 00:05:47,690
down native another important case where

00:05:45,979 --> 00:05:51,410
we actually have to go down native is

00:05:47,690 --> 00:05:53,270
when we need to crunch numbers now

00:05:51,410 --> 00:05:55,460
javascript is the best language for

00:05:53,270 --> 00:05:57,350
doing i/o if you have to communicate

00:05:55,460 --> 00:05:59,510
over the network or file system is your

00:05:57,350 --> 00:06:02,900
main mode of communication right yes

00:05:59,510 --> 00:06:04,850
don't go native but then if you have to

00:06:02,900 --> 00:06:07,850
do heavy number crunching something that

00:06:04,850 --> 00:06:10,100
would burn the CPU hot it's better to go

00:06:07,850 --> 00:06:14,539
down to the native layer you'll save

00:06:10,100 --> 00:06:16,580
quite a lot of dollars in summary the

00:06:14,539 --> 00:06:19,400
only reason to write native code is that

00:06:16,580 --> 00:06:21,770
we are not JavaScript developers we are

00:06:19,400 --> 00:06:22,760
solution providers to a problem and we

00:06:21,770 --> 00:06:25,640
are building race cars

00:06:22,760 --> 00:06:27,979
we love the metal too much but then in a

00:06:25,640 --> 00:06:31,280
race car we do need some plastic we do

00:06:27,979 --> 00:06:35,690
need some rubber and therefore to build

00:06:31,280 --> 00:06:37,220
a race car let's assemble everything so

00:06:35,690 --> 00:06:40,249
let's talk about the various ways to

00:06:37,220 --> 00:06:42,529
communicate with native code in node.js

00:06:40,249 --> 00:06:44,029
process that's my favorite and I think

00:06:42,529 --> 00:06:46,999
that's the one that most of you would

00:06:44,029 --> 00:06:49,369
have already used child process comes

00:06:46,999 --> 00:06:51,499
natively in node you can just require

00:06:49,369 --> 00:06:54,559
child process from any of your modules

00:06:51,499 --> 00:06:56,719
and huge trial process child process

00:06:54,559 --> 00:07:00,289
runs in its own process and therefore

00:06:56,719 --> 00:07:02,239
you can write typical Nord code your no

00:07:00,289 --> 00:07:04,879
thread would not be blocked when a child

00:07:02,239 --> 00:07:07,309
process is running you can get it to run

00:07:04,879 --> 00:07:10,189
asynchronously pass it arguments and

00:07:07,309 --> 00:07:13,639
take that as a result a process it's

00:07:10,189 --> 00:07:15,469
perfect perfect for what it does but it

00:07:13,639 --> 00:07:17,149
does have a few limitations and there

00:07:15,469 --> 00:07:19,879
are a few cases where it does not work

00:07:17,149 --> 00:07:22,249
that well what if the functionality that

00:07:19,879 --> 00:07:24,229
you want is not natively available or

00:07:22,249 --> 00:07:26,929
easily possible with a shell script or a

00:07:24,229 --> 00:07:30,110
bad script or direct command line are

00:07:26,929 --> 00:07:32,149
you willing to ship another binary will

00:07:30,110 --> 00:07:33,829
that binary work well given the

00:07:32,149 --> 00:07:38,899
antivirus that some user has installed

00:07:33,829 --> 00:07:41,119
somewhere in Japan how do I know and

00:07:38,899 --> 00:07:43,039
that is a big reason to be careful with

00:07:41,119 --> 00:07:45,079
child processes you're writing into

00:07:43,039 --> 00:07:48,289
shell directly and there are cases where

00:07:45,079 --> 00:07:50,269
it's not a good idea especially if stdio

00:07:48,289 --> 00:07:52,159
is not enough the communication with

00:07:50,269 --> 00:07:54,709
child processes normally happens to the

00:07:52,159 --> 00:07:56,869
standard input output and error ports

00:07:54,709 --> 00:07:58,729
now the problem with that is it's good

00:07:56,869 --> 00:08:00,289
if you want to work with that but say

00:07:58,729 --> 00:08:02,149
you're passing a large amount of image

00:08:00,289 --> 00:08:06,829
data you'll have to go down to the file

00:08:02,149 --> 00:08:09,379
system which is very complicated child

00:08:06,829 --> 00:08:11,479
process is like a tow-truck it can get

00:08:09,379 --> 00:08:17,959
you to your destination but I would

00:08:11,479 --> 00:08:20,809
never want to talk about that let's talk

00:08:17,959 --> 00:08:23,179
about something better FFI or foreign

00:08:20,809 --> 00:08:25,489
function injection FFI is not really a

00:08:23,179 --> 00:08:28,129
node concept it is a concept that's

00:08:25,489 --> 00:08:29,719
there in all programming languages the

00:08:28,129 --> 00:08:32,779
binary interface of the C programming

00:08:29,719 --> 00:08:34,519
languages has been standardized as the

00:08:32,779 --> 00:08:38,120
interface for information exchange

00:08:34,519 --> 00:08:40,610
between languages in short if you have a

00:08:38,120 --> 00:08:42,379
C style library then any language can

00:08:40,610 --> 00:08:44,449
read through the binary and directly

00:08:42,379 --> 00:08:46,399
call into the functionality so if a

00:08:44,449 --> 00:08:49,370
method is exporting a C style library

00:08:46,399 --> 00:08:50,269
you can directly read it from nodejs and

00:08:49,370 --> 00:08:53,990
call into it

00:08:50,269 --> 00:08:56,450
no writing C++ no writing C you are

00:08:53,990 --> 00:08:58,790
still in GS and there is a native module

00:08:56,450 --> 00:09:01,570
available in node called f fi or f fi

00:08:58,790 --> 00:09:04,610
napi in node 10-plus which can do that

00:09:01,570 --> 00:09:06,740
it is actually the best approach if you

00:09:04,610 --> 00:09:07,160
have a library with C style code lying

00:09:06,740 --> 00:09:10,100
there

00:09:07,160 --> 00:09:12,740
the reason you can use it in multiple

00:09:10,100 --> 00:09:15,620
languages your C guy can write the C

00:09:12,740 --> 00:09:18,860
code and you can focus on Jas but it has

00:09:15,620 --> 00:09:23,420
its own set of disadvantages for example

00:09:18,860 --> 00:09:25,370
the J's bridge to C++ is still slow the

00:09:23,420 --> 00:09:28,310
other big disadvantage which affects GS

00:09:25,370 --> 00:09:31,370
developers is that C developers like to

00:09:28,310 --> 00:09:33,200
take on the main thread if the C library

00:09:31,370 --> 00:09:34,550
is actually slow and you're actually

00:09:33,200 --> 00:09:36,440
doing number crunching you would want to

00:09:34,550 --> 00:09:38,450
do this in a background thread don't

00:09:36,440 --> 00:09:41,320
stall my application while this thing is

00:09:38,450 --> 00:09:44,000
running and you cannot do that with FF I

00:09:41,320 --> 00:09:46,370
for doing something like that you need

00:09:44,000 --> 00:09:48,470
more something more advanced FF I is

00:09:46,370 --> 00:09:50,660
more like a toy it works for what it

00:09:48,470 --> 00:09:55,190
works but if it doesn't look for a

00:09:50,660 --> 00:09:58,730
better solution now note is build in v8

00:09:55,190 --> 00:10:02,450
v8 is a C++ based library and what that

00:09:58,730 --> 00:10:04,250
means is you can directly call C++ why

00:10:02,450 --> 00:10:06,890
are the v8 API is excellent and extend

00:10:04,250 --> 00:10:09,560
node so simple you'll get the full

00:10:06,890 --> 00:10:12,620
performance of v8 you can extend v8 and

00:10:09,560 --> 00:10:17,810
write new JavaScript maybe write es 2019

00:10:12,620 --> 00:10:18,520
in your module but then there is one big

00:10:17,810 --> 00:10:21,320
problem

00:10:18,520 --> 00:10:23,390
v8 releases a new version every month

00:10:21,320 --> 00:10:25,399
and they cannot guarantee the

00:10:23,390 --> 00:10:28,310
compatibility of their API across

00:10:25,399 --> 00:10:30,560
releases what that means is that if I

00:10:28,310 --> 00:10:34,370
write a node module using the v8 API is

00:10:30,560 --> 00:10:36,620
next month I'm I need to rewrite it no

00:10:34,370 --> 00:10:39,170
one can maintain that and that node team

00:10:36,620 --> 00:10:41,690
realized it very early that is why they

00:10:39,170 --> 00:10:44,420
created na N and wrapper over the v8 API

00:10:41,690 --> 00:10:47,300
which hides the changes as v8 changes

00:10:44,420 --> 00:10:49,370
and if you use any and you can recompile

00:10:47,300 --> 00:10:52,130
your module across various versions of

00:10:49,370 --> 00:10:55,130
node and it will continue to run nor

00:10:52,130 --> 00:10:57,320
rewriting needed NN was built as a

00:10:55,130 --> 00:11:00,920
specific solution to a very specific

00:10:57,320 --> 00:11:03,170
problem that was to hide v8 and it does

00:11:00,920 --> 00:11:05,529
the job perfectly but it was never

00:11:03,170 --> 00:11:07,680
thought out to be a very well-defined

00:11:05,529 --> 00:11:09,839
C++ interface

00:11:07,680 --> 00:11:12,630
jiae's communication and it starts to

00:11:09,839 --> 00:11:15,600
show its age for example you need to

00:11:12,630 --> 00:11:18,680
understand v8 to use any and properly

00:11:15,600 --> 00:11:21,360
you need to recompile with every release

00:11:18,680 --> 00:11:23,160
people who use multiple versions of

00:11:21,360 --> 00:11:25,740
north would have seen this error at some

00:11:23,160 --> 00:11:28,980
point or the other this error comes in

00:11:25,740 --> 00:11:32,130
because of any n n n is highly tied to a

00:11:28,980 --> 00:11:33,810
version of node and so if you want to

00:11:32,130 --> 00:11:36,870
switch your node version there are

00:11:33,810 --> 00:11:39,120
problems more than that if you happen to

00:11:36,870 --> 00:11:41,370
be writing electron and have your unit

00:11:39,120 --> 00:11:47,490
tests in node you will only be

00:11:41,370 --> 00:11:49,440
recompiling for the entire day another

00:11:47,490 --> 00:11:51,690
issue with any n is that it's so

00:11:49,440 --> 00:11:53,250
complicated to set up any n that you

00:11:51,690 --> 00:11:56,250
will be actually ending up setting up

00:11:53,250 --> 00:11:59,100
your production machine to have a C

00:11:56,250 --> 00:12:00,839
compiler a Python compiler and the

00:11:59,100 --> 00:12:03,630
JavaScript runtime just to use

00:12:00,839 --> 00:12:06,570
JavaScript in production which is not

00:12:03,630 --> 00:12:08,940
really a good thing to do any n is like

00:12:06,570 --> 00:12:10,470
manual transmission you need to know

00:12:08,940 --> 00:12:12,779
what gear to go into for your

00:12:10,470 --> 00:12:16,470
application to work otherwise this error

00:12:12,779 --> 00:12:20,160
awaits now if any n is manual let's talk

00:12:16,470 --> 00:12:23,010
about the automatic the n API the N API

00:12:20,160 --> 00:12:26,160
has been marked stable with no ten and

00:12:23,010 --> 00:12:28,800
for the last 15 days no 10 has been the

00:12:26,160 --> 00:12:31,920
LTS version of node so n API is

00:12:28,800 --> 00:12:35,670
production-ready n api has a very

00:12:31,920 --> 00:12:39,779
well-defined binary interface that is it

00:12:35,670 --> 00:12:41,430
is a bi-stable in short the node team

00:12:39,779 --> 00:12:44,220
guarantees that if you write something

00:12:41,430 --> 00:12:46,680
using the N API you can not only use it

00:12:44,220 --> 00:12:49,020
in the past versions of node node eight

00:12:46,680 --> 00:12:51,329
where it was experimental and no 10 but

00:12:49,020 --> 00:12:53,430
also in the future versions the node a

00:12:51,329 --> 00:12:55,440
node team will gain will try to make

00:12:53,430 --> 00:12:57,000
sure that your napi mod you stays

00:12:55,440 --> 00:12:59,730
relevant and you do not need to

00:12:57,000 --> 00:13:01,740
recompile across your users n api

00:12:59,730 --> 00:13:05,430
provides a full set of utility methods

00:13:01,740 --> 00:13:07,680
to communicate with c++ in a proper JS

00:13:05,430 --> 00:13:10,230
way for example it hides all the

00:13:07,680 --> 00:13:12,270
complications around pointers it hides

00:13:10,230 --> 00:13:15,540
how to create a background thread in a

00:13:12,270 --> 00:13:18,420
very simple method and electron rebuild

00:13:15,540 --> 00:13:20,710
is officially dead once we have all

00:13:18,420 --> 00:13:23,200
plugins that have moved to the N API

00:13:20,710 --> 00:13:25,240
now before I talk about how to write

00:13:23,200 --> 00:13:27,520
some napi code I would like to know how

00:13:25,240 --> 00:13:31,810
many if you've heard about C++ before my

00:13:27,520 --> 00:13:35,800
talk everyone how many of you actually

00:13:31,810 --> 00:13:39,040
used C++ or written C++ code it's quite

00:13:35,800 --> 00:13:43,660
a few how many of you will love C++ love

00:13:39,040 --> 00:13:45,970
it more than JavaScript again at your

00:13:43,660 --> 00:13:47,950
question because C++ is much more

00:13:45,970 --> 00:13:49,990
difficult to write and unless you really

00:13:47,950 --> 00:13:53,410
need to I would prefer to stay in the

00:13:49,990 --> 00:13:56,440
jail and less socials to show some

00:13:53,410 --> 00:13:59,470
sample an API based code so I have a es6

00:13:56,440 --> 00:14:01,950
module that exports a property X which

00:13:59,470 --> 00:14:05,130
is a function that returns hello world

00:14:01,950 --> 00:14:10,270
this is what it would look like in es5

00:14:05,130 --> 00:14:13,149
slightly more verbose but look at C++ it

00:14:10,270 --> 00:14:15,370
looks very complicated but actually it's

00:14:13,149 --> 00:14:18,100
very simple from the C++ standards at

00:14:15,370 --> 00:14:20,980
the bottom of the file we have this node

00:14:18,100 --> 00:14:23,050
API module which is declaring that the

00:14:20,980 --> 00:14:25,270
module dot exports come from the export

00:14:23,050 --> 00:14:27,220
method and the name of the module comes

00:14:25,270 --> 00:14:29,050
from the JIP file the JIP file is

00:14:27,220 --> 00:14:31,630
equivalent to packet or JSON in the

00:14:29,050 --> 00:14:34,900
native world in the exports method we

00:14:31,630 --> 00:14:36,820
are setting a property X to be the Foo

00:14:34,900 --> 00:14:39,400
function which has been converted from a

00:14:36,820 --> 00:14:40,870
c function to a JS function and in the

00:14:39,400 --> 00:14:44,260
Foo function we are returning a string

00:14:40,870 --> 00:14:46,500
hello world at the top of the file there

00:14:44,260 --> 00:14:49,180
is any P I dot H which we are including

00:14:46,500 --> 00:14:51,700
include is kind of like imports I think

00:14:49,180 --> 00:14:53,339
most of us are C++ developers so I don't

00:14:51,700 --> 00:14:55,470
need to go into details for all of that

00:14:53,339 --> 00:14:58,330
now what we'll be doing today is

00:14:55,470 --> 00:15:00,700
building or showing a running native

00:14:58,330 --> 00:15:03,370
module let's go to a hypothetical

00:15:00,700 --> 00:15:05,850
situation that I have been very lucky in

00:15:03,370 --> 00:15:05,850
Vegas

00:15:05,920 --> 00:15:13,990
and not only that all of you have been

00:15:10,810 --> 00:15:16,600
luckier so while I get some cash you get

00:15:13,990 --> 00:15:18,640
to drive a brand new car and as you

00:15:16,600 --> 00:15:21,280
drive through the Vegas Strip you see me

00:15:18,640 --> 00:15:23,260
in your sideview mirror and for another

00:15:21,280 --> 00:15:28,180
lucky break it's actually raining in

00:15:23,260 --> 00:15:31,420
Vegas and that is what we would be doing

00:15:28,180 --> 00:15:33,550
we'll be taking an image adding a rain

00:15:31,420 --> 00:15:35,830
effect to it overlaying it with another

00:15:33,550 --> 00:15:37,680
image and fitting it inside a frame we

00:15:35,830 --> 00:15:40,810
are doing all of this using imagemagick

00:15:37,680 --> 00:15:43,990
image magic is an open source C++ API

00:15:40,810 --> 00:15:45,430
for image manipulation very popular on

00:15:43,990 --> 00:15:47,290
the server side very popular on the

00:15:45,430 --> 00:15:49,530
command line you can read all about it

00:15:47,290 --> 00:15:54,970
it's all over the Internet

00:15:49,530 --> 00:15:58,900
so let's get started and I'm here in the

00:15:54,970 --> 00:16:02,040
middle of a test file where I'm loading

00:15:58,900 --> 00:16:05,170
a module called version dot node in

00:16:02,040 --> 00:16:07,030
version dot node we export a method

00:16:05,170 --> 00:16:10,420
called version which returns the current

00:16:07,030 --> 00:16:12,760
node version as a string and I'm logging

00:16:10,420 --> 00:16:15,250
it onto the console let's look at

00:16:12,760 --> 00:16:17,920
binding dot chip which represents the

00:16:15,250 --> 00:16:19,540
packet or JSON for this module it has

00:16:17,920 --> 00:16:21,580
the similar things just like packet or

00:16:19,540 --> 00:16:23,530
JSON the name is called target name

00:16:21,580 --> 00:16:27,550
because we are C++ developers you want

00:16:23,530 --> 00:16:30,160
to make it a bit more confusing than it

00:16:27,550 --> 00:16:32,380
has dependencies which is an array and

00:16:30,160 --> 00:16:35,020
it can run some shell scripts or note

00:16:32,380 --> 00:16:36,730
scripts directly we have some flags to

00:16:35,020 --> 00:16:40,420
tell the compiler how to compile it and

00:16:36,730 --> 00:16:42,610
we have some OS specific stuff and that

00:16:40,420 --> 00:16:44,410
is all there is to it when node would

00:16:42,610 --> 00:16:45,940
read this file it would understand that

00:16:44,410 --> 00:16:48,370
it is native code and compile this

00:16:45,940 --> 00:16:51,490
binary let's go into the binary version

00:16:48,370 --> 00:16:53,650
or the C++ version of this module this

00:16:51,490 --> 00:16:56,440
looks exactly like the demo that a

00:16:53,650 --> 00:16:58,000
sample code that I just showed so at the

00:16:56,440 --> 00:17:00,250
bottom of the file we again have known

00:16:58,000 --> 00:17:02,860
API module the name comes from the JIP

00:17:00,250 --> 00:17:04,690
file there is a method called init which

00:17:02,860 --> 00:17:07,870
has a property called version which is

00:17:04,690 --> 00:17:09,550
the function get version in the get

00:17:07,870 --> 00:17:11,470
version function we are returning a

00:17:09,550 --> 00:17:13,570
string which we are instead of

00:17:11,470 --> 00:17:15,880
hard-coding hello world getting from the

00:17:13,570 --> 00:17:19,000
imagemagick api which we've included by

00:17:15,880 --> 00:17:19,630
a magic plus plus dot h now as i execute

00:17:19,000 --> 00:17:21,160
this and my

00:17:19,630 --> 00:17:23,920
a console I think it's slightly

00:17:21,160 --> 00:17:26,890
difficult to see we have image magic

00:17:23,920 --> 00:17:28,390
version 7 being logged that is the

00:17:26,890 --> 00:17:30,910
version of image magic that's installed

00:17:28,390 --> 00:17:33,100
on my machine now that we've gone

00:17:30,910 --> 00:17:34,630
through a hello world I will like you to

00:17:33,100 --> 00:17:37,360
go through something a little more

00:17:34,630 --> 00:17:39,160
complicated so in this second example we

00:17:37,360 --> 00:17:42,580
are reading a file called photos or JPEG

00:17:39,160 --> 00:17:44,170
which is a binary image file please

00:17:42,580 --> 00:17:48,340
don't point at read file sync I know

00:17:44,170 --> 00:17:52,090
it's bad code once we get the image file

00:17:48,340 --> 00:17:54,550
we load the info dot node info provider

00:17:52,090 --> 00:17:56,080
native module which exports a method

00:17:54,550 --> 00:18:00,160
process image which is going to process

00:17:56,080 --> 00:18:02,740
this image and return a.j saab jekt this

00:18:00,160 --> 00:18:04,540
object I am logging on to console many

00:18:02,740 --> 00:18:06,310
JavaScript developers don't know that

00:18:04,540 --> 00:18:08,920
JSON dot stringify actually can take

00:18:06,310 --> 00:18:10,690
more than one argument the third

00:18:08,920 --> 00:18:13,570
argument of JSON dot stringify is

00:18:10,690 --> 00:18:15,220
extremely useful this is the number of

00:18:13,570 --> 00:18:18,220
white spaces so you can get a pretty

00:18:15,220 --> 00:18:20,260
fide JSON string from a JavaScript

00:18:18,220 --> 00:18:22,650
object directly without going to J's

00:18:20,260 --> 00:18:25,810
beautify or whatever you guys are using

00:18:22,650 --> 00:18:28,570
coming back to native code let's look at

00:18:25,810 --> 00:18:31,090
info dot CC the code for the info dot

00:18:28,570 --> 00:18:33,160
node module the bottom of the file looks

00:18:31,090 --> 00:18:35,440
exactly like I've just shown to you all

00:18:33,160 --> 00:18:38,080
of you the name comes from the JIP file

00:18:35,440 --> 00:18:40,090
the init method provides the exports the

00:18:38,080 --> 00:18:42,160
expose is actually a property called

00:18:40,090 --> 00:18:45,070
process image which comes from the

00:18:42,160 --> 00:18:47,260
process image C++ function now let's get

00:18:45,070 --> 00:18:48,880
into the process image function the

00:18:47,260 --> 00:18:51,070
first thing to note is that it doesn't

00:18:48,880 --> 00:18:53,590
take multiple arguments it takes an info

00:18:51,070 --> 00:18:55,900
object this info object is very similar

00:18:53,590 --> 00:18:58,320
to the arguments object in Jas or the

00:18:55,900 --> 00:19:00,940
triple dot args like you write in es6

00:18:58,320 --> 00:19:03,070
then from this info object we can verify

00:19:00,940 --> 00:19:05,200
that the parameters being passed are

00:19:03,070 --> 00:19:07,690
correct and if they are not we throw a

00:19:05,200 --> 00:19:09,550
JS exception why we want to do that

00:19:07,690 --> 00:19:11,620
they're still living in the world of

00:19:09,550 --> 00:19:14,020
segmentation false if we make a mistake

00:19:11,620 --> 00:19:17,200
our program would crash and therefore we

00:19:14,020 --> 00:19:18,820
want to be extra careful it's better to

00:19:17,200 --> 00:19:21,130
get into the unhandled exception in the

00:19:18,820 --> 00:19:25,270
notes place rather than crashing here in

00:19:21,130 --> 00:19:27,970
C once we know that it is a buffer we

00:19:25,270 --> 00:19:29,920
can convert it from a raw JSON buffer

00:19:27,970 --> 00:19:31,450
typescript folks would understand that

00:19:29,920 --> 00:19:33,400
this looks very close to typescript

00:19:31,450 --> 00:19:35,530
and generic since

00:19:33,400 --> 00:19:37,390
plus plus have been an inspiration for a

00:19:35,530 --> 00:19:39,730
lot of languages including typescript

00:19:37,390 --> 00:19:41,890
once we converted to a buffer we have

00:19:39,730 --> 00:19:44,680
direct access to the raw binary data and

00:19:41,890 --> 00:19:46,600
the length of the buffer we can use this

00:19:44,680 --> 00:19:49,180
to pass on and create an image magic

00:19:46,600 --> 00:19:50,620
image now from the image I'm not doing

00:19:49,180 --> 00:19:52,900
much I'm reading the width and the

00:19:50,620 --> 00:19:55,750
height of the image a few attributes and

00:19:52,900 --> 00:19:58,810
then creating a JS object creating a J's

00:19:55,750 --> 00:20:02,140
in C++ is a little more verbose than

00:19:58,810 --> 00:20:03,820
creating it is in GS so I need to create

00:20:02,140 --> 00:20:06,160
an object with the width height created

00:20:03,820 --> 00:20:07,840
and modified parameters which I again

00:20:06,160 --> 00:20:11,230
get from the number in string tied data

00:20:07,840 --> 00:20:13,750
and then I return it back to node now as

00:20:11,230 --> 00:20:15,280
I executed in my debug console you

00:20:13,750 --> 00:20:17,800
should see that I'm loading a full at

00:20:15,280 --> 00:20:20,230
the image the mod if the Creator time is

00:20:17,800 --> 00:20:22,800
actually right now and that is because I

00:20:20,230 --> 00:20:25,150
passed on a binary image to image magic

00:20:22,800 --> 00:20:26,830
image magic did not get to read a file

00:20:25,150 --> 00:20:28,420
from disk and that is why it was just

00:20:26,830 --> 00:20:30,430
created when the binary editor was

00:20:28,420 --> 00:20:33,820
provided and it did not have a modified

00:20:30,430 --> 00:20:36,340
time the demo that I just showed was

00:20:33,820 --> 00:20:37,990
kind of a example that we would not like

00:20:36,340 --> 00:20:40,900
to use in production it's doing

00:20:37,990 --> 00:20:44,860
processing in the main thread right and

00:20:40,900 --> 00:20:47,050
main thread stalls and our application

00:20:44,860 --> 00:20:48,610
stops working so let's do something

00:20:47,050 --> 00:20:51,250
where it goes to a background thread

00:20:48,610 --> 00:20:54,400
takes a callback gives us the processed

00:20:51,250 --> 00:20:58,150
image in our callback now we pass it on

00:20:54,400 --> 00:21:01,690
and save the file as edit dot JPEG on to

00:20:58,150 --> 00:21:04,780
our console let's look at the code for

00:21:01,690 --> 00:21:06,430
edit dot C C now this also starts just

00:21:04,780 --> 00:21:08,800
like the code that I showed for the

00:21:06,430 --> 00:21:10,750
previous two examples we again get the

00:21:08,800 --> 00:21:13,150
name from the Gipp file the init method

00:21:10,750 --> 00:21:15,850
provides a method called edit which is

00:21:13,150 --> 00:21:17,770
the function edit in the function edit

00:21:15,850 --> 00:21:20,110
we validate the arguments just like we

00:21:17,770 --> 00:21:22,210
did in the previous example and then

00:21:20,110 --> 00:21:24,550
instead of doing some calculation we

00:21:22,210 --> 00:21:26,950
create a worker called image modifier

00:21:24,550 --> 00:21:29,830
which takes the buffer and they call

00:21:26,950 --> 00:21:32,170
back and then we queue that worker on a

00:21:29,830 --> 00:21:34,750
background thread we are not creating

00:21:32,170 --> 00:21:36,340
background threads manually oh god it's

00:21:34,750 --> 00:21:40,960
so difficult to create background

00:21:36,340 --> 00:21:41,890
threads things like deadlocks they stall

00:21:40,960 --> 00:21:45,580
your application

00:21:41,890 --> 00:21:47,080
do not waste CPU but you don't run this

00:21:45,580 --> 00:21:50,019
is so much better

00:21:47,080 --> 00:21:51,909
and API provides direct access to run

00:21:50,019 --> 00:21:54,309
stuff in a background thread and it

00:21:51,909 --> 00:21:58,299
manages the thread pool now let's look

00:21:54,309 --> 00:21:59,980
at the image modifier class event

00:21:58,299 --> 00:22:01,179
modifier derived from an async worker

00:21:59,980 --> 00:22:03,549
which and capsule eights all the

00:22:01,179 --> 00:22:05,980
background thread calculations a sync

00:22:03,549 --> 00:22:10,510
worker takes a callback and it ensures

00:22:05,980 --> 00:22:12,039
the unmanaged memory part of C++ so when

00:22:10,510 --> 00:22:14,470
we need the koala back back again after

00:22:12,039 --> 00:22:15,850
execution in the background thread the

00:22:14,470 --> 00:22:17,919
async worker will ensure that the

00:22:15,850 --> 00:22:23,019
callback has not been garbage collected

00:22:17,919 --> 00:22:24,940
by v8 and we can use it again we can

00:22:23,019 --> 00:22:27,370
directly copy in values that we get like

00:22:24,940 --> 00:22:29,710
numbers and strings but in this case I

00:22:27,370 --> 00:22:31,389
am passing a lot of binary data and we

00:22:29,710 --> 00:22:33,639
don't want to copy the binary data in

00:22:31,389 --> 00:22:36,370
the J's thread and that is why we are

00:22:33,639 --> 00:22:38,409
using the node buffer despite the

00:22:36,370 --> 00:22:41,620
presence of array buffers nor buffer is

00:22:38,409 --> 00:22:44,169
not dead because of a reason node buffer

00:22:41,620 --> 00:22:46,809
is a very special object the binary data

00:22:44,169 --> 00:22:49,360
of node buffer is accessible even from

00:22:46,809 --> 00:22:52,990
background threads and that is why node

00:22:49,360 --> 00:22:54,220
buffer still exists and to do that what

00:22:52,990 --> 00:22:56,409
we are doing is you're marking it

00:22:54,220 --> 00:22:58,600
persistent so that accidentally the node

00:22:56,409 --> 00:23:01,899
buffer does not get deleted it will get

00:22:58,600 --> 00:23:04,870
garbage collected once this class object

00:23:01,899 --> 00:23:06,730
is destroyed and then we are keeping a

00:23:04,870 --> 00:23:08,590
reference to the actual binary data and

00:23:06,730 --> 00:23:11,980
the length of the data to pass on to

00:23:08,590 --> 00:23:13,659
image magic and API will ensure that my

00:23:11,980 --> 00:23:15,909
execute method is actually called in the

00:23:13,659 --> 00:23:18,100
background thread now in the execute

00:23:15,909 --> 00:23:20,980
method I am passing on that image data

00:23:18,100 --> 00:23:25,240
to image magic I'm loading a few images

00:23:20,980 --> 00:23:28,090
I specified array in effect I overlay it

00:23:25,240 --> 00:23:33,240
with my water image and then change its

00:23:28,090 --> 00:23:35,980
dimension to fit it inside the car frame

00:23:33,240 --> 00:23:38,440
once I am done I can write this output

00:23:35,980 --> 00:23:41,740
to another variable we don't have to

00:23:38,440 --> 00:23:44,260
write to disk now note is happy passing

00:23:41,740 --> 00:23:47,200
this variable directly to the J's land

00:23:44,260 --> 00:23:50,019
we do not need to copy it over or waste

00:23:47,200 --> 00:23:52,690
our memory or CPU doing things with the

00:23:50,019 --> 00:23:54,789
data we can directly use it in Jas but

00:23:52,690 --> 00:23:56,770
unfortunately event magic does not allow

00:23:54,789 --> 00:23:59,139
me to and therefore I need to copy this

00:23:56,770 --> 00:24:01,059
data into a binary object into a basic

00:23:59,139 --> 00:24:02,919
object now to do that

00:24:01,059 --> 00:24:05,019
I'm using this but this is not really

00:24:02,919 --> 00:24:06,370
stalling your JavaScript read all this

00:24:05,019 --> 00:24:08,830
code is running in your background

00:24:06,370 --> 00:24:11,230
thread in the execute method so your JS

00:24:08,830 --> 00:24:13,419
code will still be performant once that

00:24:11,230 --> 00:24:15,220
method executes we get to the on ok

00:24:13,419 --> 00:24:17,889
method which is again called in the J's

00:24:15,220 --> 00:24:20,350
thread where we can execute JavaScript

00:24:17,889 --> 00:24:23,019
and this method what we are doing is

00:24:20,350 --> 00:24:24,820
getting a callback and calling it with

00:24:23,019 --> 00:24:27,669
undefined as the error argument and D

00:24:24,820 --> 00:24:28,990
buffer as the success argument now

00:24:27,669 --> 00:24:31,929
there's one more thing that we need to

00:24:28,990 --> 00:24:34,779
remember and that is this line which is

00:24:31,929 --> 00:24:36,669
not really declaring a c++ variable that

00:24:34,779 --> 00:24:39,549
we are not going to use this is actually

00:24:36,669 --> 00:24:42,580
creating a J scope all functions in J s

00:24:39,549 --> 00:24:44,080
are automatically having a scope but

00:24:42,580 --> 00:24:45,549
since we are not creating a function we

00:24:44,080 --> 00:24:48,190
directly calling a function we need to

00:24:45,549 --> 00:24:50,230
create a scope manually and once the

00:24:48,190 --> 00:24:52,240
scope is destroyed if any of the objects

00:24:50,230 --> 00:24:52,869
created in the scope are not referenced

00:24:52,240 --> 00:24:55,509
anywhere

00:24:52,869 --> 00:24:57,070
there could be garbage collected now

00:24:55,509 --> 00:24:59,289
let's see how I create the buffer to

00:24:57,070 --> 00:25:00,519
pass on the buffer is again created by

00:24:59,289 --> 00:25:02,980
the buffer new just like you were using

00:25:00,519 --> 00:25:05,200
string new or a number new a buffer is

00:25:02,980 --> 00:25:07,869
slightly more complicated in sense that

00:25:05,200 --> 00:25:10,869
it takes this an asynchronous function

00:25:07,869 --> 00:25:14,289
called a C++ lambda we need to do this

00:25:10,869 --> 00:25:16,480
because C++ still has managed doesn't

00:25:14,289 --> 00:25:18,129
have managed memory so for unmanaged

00:25:16,480 --> 00:25:20,110
memory when this buffer is actually

00:25:18,129 --> 00:25:21,669
garbage collected we will need to free

00:25:20,110 --> 00:25:25,720
the internal data and that is what we

00:25:21,669 --> 00:25:27,460
are doing now as I execute this you

00:25:25,720 --> 00:25:30,100
won't see anything in the console but

00:25:27,460 --> 00:25:32,230
will successfully log done and instead

00:25:30,100 --> 00:25:33,999
of showing what I was doing since I'm

00:25:32,230 --> 00:25:36,429
running out of time I'll show you

00:25:33,999 --> 00:25:38,860
something cooler now what I'm going to

00:25:36,429 --> 00:25:41,379
do is without recompiling I'm going to

00:25:38,860 --> 00:25:44,710
load it in electron and as I click on

00:25:41,379 --> 00:25:48,070
this here it is the same code running an

00:25:44,710 --> 00:25:50,289
electron no recompilation and i am going

00:25:48,070 --> 00:25:52,029
to make a fool of myself now as i take a

00:25:50,289 --> 00:25:54,910
selfie of myself in front of all of you

00:25:52,029 --> 00:25:57,340
on the stage yeah

00:25:54,910 --> 00:26:05,380
and it does that processing and it's

00:25:57,340 --> 00:26:07,900
instantly available for me to save now

00:26:05,380 --> 00:26:10,200
the same thing is available at napi dot

00:26:07,900 --> 00:26:14,200
efficient dot me feel free to try it out

00:26:10,200 --> 00:26:16,960
after my speech and have a souvenir for

00:26:14,200 --> 00:26:18,640
the conference and I'm already out of

00:26:16,960 --> 00:26:21,220
time so I'll just make it quick

00:26:18,640 --> 00:26:24,670
the best tips to work with native code

00:26:21,220 --> 00:26:27,610
are actually three things rule number

00:26:24,670 --> 00:26:29,650
one do not write native code try to see

00:26:27,610 --> 00:26:32,320
if something that is not native can

00:26:29,650 --> 00:26:33,910
solve the problem for you because child

00:26:32,320 --> 00:26:36,850
processes are good for a lot of cases

00:26:33,910 --> 00:26:40,450
and so is FFI and unless you really need

00:26:36,850 --> 00:26:42,490
native code do not write native code the

00:26:40,450 --> 00:26:44,850
second rule of writing native code is do

00:26:42,490 --> 00:26:47,500
not give it to a native developer

00:26:44,850 --> 00:26:50,230
because they don't understand Jas

00:26:47,500 --> 00:26:53,230
they'll hog your main thread write it

00:26:50,230 --> 00:26:57,490
like beautiful Jas and ugly C++ and you

00:26:53,230 --> 00:27:00,340
will be successful the third rule of

00:26:57,490 --> 00:27:03,750
writing native code is again to remember

00:27:00,340 --> 00:27:06,190
the first rule don't write native god if

00:27:03,750 --> 00:27:08,620
you have it in some native code just

00:27:06,190 --> 00:27:10,720
evaluate if you need it Jas is evolving

00:27:08,620 --> 00:27:13,120
and over time more and more stuff is

00:27:10,720 --> 00:27:16,300
moving to Jas what you needed in native

00:27:13,120 --> 00:27:19,570
a year back may be redundant now keep

00:27:16,300 --> 00:27:22,720
yourself up to date the code for all of

00:27:19,570 --> 00:27:25,150
my demos are available at napi in my

00:27:22,720 --> 00:27:27,420
github repo the sample service is

00:27:25,150 --> 00:27:30,460
available at n API dot Atisha dot me

00:27:27,420 --> 00:27:32,470
that's all I have to say drive safely

00:27:30,460 --> 00:27:34,620
if you're going to use native code thank

00:27:32,470 --> 00:27:34,620

YouTube URL: https://www.youtube.com/watch?v=E0w7Tc0f2fA


