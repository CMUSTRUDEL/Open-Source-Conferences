Title: How Linters, Compilers & Other Cool Things Work    Will Klein    CascadiaJS 2018
Publication date: 2018-12-10
Playlist: CascadiaJS 2018
Description: 
	Step inside your everyday JavaScript tools, and you’ll find the abstract syntax tree. With the AST, let’s discover how our tools work, how we can extend them, and build a better understanding of computer language along the way.

https://2018.cascadiajs.com/
Captions: 
	00:00:00,359 --> 00:00:07,440
hi everyone today we're gonna talk about

00:00:03,240 --> 00:00:11,070
tools but first let me tell you about my

00:00:07,440 --> 00:00:13,530
dad my dad was a tool maker and what

00:00:11,070 --> 00:00:16,680
that meant in his context was he worked

00:00:13,530 --> 00:00:18,660
in a machine shop and he went to school

00:00:16,680 --> 00:00:21,140
for an extra year to learn some advanced

00:00:18,660 --> 00:00:24,510
techniques so that he could make tools

00:00:21,140 --> 00:00:26,760
the tools he made were used to make

00:00:24,510 --> 00:00:30,470
parts or make it easier to make parts

00:00:26,760 --> 00:00:33,510
that any other machinist could make and

00:00:30,470 --> 00:00:34,829
there was two reasons why he was called

00:00:33,510 --> 00:00:37,200
a tool maker as opposed to just a

00:00:34,829 --> 00:00:38,550
machinist first was that he just went to

00:00:37,200 --> 00:00:39,149
school for an extra year and learned

00:00:38,550 --> 00:00:41,489
some things

00:00:39,149 --> 00:00:43,320
the second was those tools well they

00:00:41,489 --> 00:00:44,820
were very important to the manufacturing

00:00:43,320 --> 00:00:48,030
process it was they're also very

00:00:44,820 --> 00:00:50,489
important to saving time making some of

00:00:48,030 --> 00:00:52,860
these parts so I want to think about

00:00:50,489 --> 00:00:54,719
that a little bit today is there

00:00:52,860 --> 00:00:57,449
anything that we do as developers that

00:00:54,719 --> 00:01:00,980
we could save time that could be easier

00:00:57,449 --> 00:01:04,470
that we could be more effective at and

00:01:00,980 --> 00:01:06,420
to do that let's first discuss how

00:01:04,470 --> 00:01:09,360
linters compilers and other cool things

00:01:06,420 --> 00:01:09,990
work I'm will Klein I'm from Longmont

00:01:09,360 --> 00:01:12,720
Colorado

00:01:09,990 --> 00:01:15,840
I work in Boulder as an engineer at

00:01:12,720 --> 00:01:19,350
workday and today we're going to talk

00:01:15,840 --> 00:01:21,330
about four things first what are our

00:01:19,350 --> 00:01:24,290
problems what are the things that we

00:01:21,330 --> 00:01:26,520
might be able to think about and improve

00:01:24,290 --> 00:01:29,610
second I'm going to talk about compilers

00:01:26,520 --> 00:01:31,200
because compilers are just really

00:01:29,610 --> 00:01:32,970
awesome and typically you'll only learn

00:01:31,200 --> 00:01:34,860
about that and peer science at a

00:01:32,970 --> 00:01:36,900
university but I think there's some

00:01:34,860 --> 00:01:40,170
really essential things that we can all

00:01:36,900 --> 00:01:43,049
gather very quickly today and there's a

00:01:40,170 --> 00:01:46,259
key piece of compilers that we're gonna

00:01:43,049 --> 00:01:48,180
really dive into and make our best

00:01:46,259 --> 00:01:50,280
friend and then we're going to look at

00:01:48,180 --> 00:01:52,020
how that key piece can be applied to

00:01:50,280 --> 00:01:55,259
those problems and hopefully come up

00:01:52,020 --> 00:01:57,450
with some solutions so the first problem

00:01:55,259 --> 00:01:58,560
that I run into a lot is with code

00:01:57,450 --> 00:02:00,509
review and I don't have a problem code

00:01:58,560 --> 00:02:03,000
of you I love code review I've worked in

00:02:00,509 --> 00:02:07,500
a really lovely code review rich culture

00:02:03,000 --> 00:02:09,739
for the past five years but but there's

00:02:07,500 --> 00:02:11,670
some things I see in code review that

00:02:09,739 --> 00:02:13,600
could be better

00:02:11,670 --> 00:02:15,190
I love getting feedback I love giving

00:02:13,600 --> 00:02:16,420
feedback I love asking questions and

00:02:15,190 --> 00:02:18,730
learning about code just to the code

00:02:16,420 --> 00:02:22,030
review but when something comes up that

00:02:18,730 --> 00:02:24,010
is I'll just say tribal knowledge I'll

00:02:22,030 --> 00:02:26,140
submit my first PR to a project and

00:02:24,010 --> 00:02:27,340
they'll say oh yeah that's great but

00:02:26,140 --> 00:02:28,870
when you work in this part of the

00:02:27,340 --> 00:02:31,140
codebase there's these other things you

00:02:28,870 --> 00:02:33,730
can use that you didn't know about and

00:02:31,140 --> 00:02:35,530
here's where they are so there's all

00:02:33,730 --> 00:02:37,060
these things that we can only learn from

00:02:35,530 --> 00:02:39,580
code review or from pairing with another

00:02:37,060 --> 00:02:41,590
developer that I kind of wonder is there

00:02:39,580 --> 00:02:43,330
a better way than waiting until we get

00:02:41,590 --> 00:02:44,380
to code review to find out about those

00:02:43,330 --> 00:02:46,240
things and then going back to the

00:02:44,380 --> 00:02:50,680
drawing board or re rewriting our code

00:02:46,240 --> 00:02:52,780
and the second thing that is actually

00:02:50,680 --> 00:02:56,290
really awesome are changing language

00:02:52,780 --> 00:02:58,090
features we have since es6 we have had

00:02:56,290 --> 00:02:59,590
so many iterations in the language all

00:02:58,090 --> 00:03:02,320
these awesome new features that have

00:02:59,590 --> 00:03:04,240
come about but I wonder is there an

00:03:02,320 --> 00:03:07,420
easier way to apply those to our

00:03:04,240 --> 00:03:09,820
existing code to bring these new awesome

00:03:07,420 --> 00:03:11,230
things into our code bases and take

00:03:09,820 --> 00:03:14,320
advantage of them without having to

00:03:11,230 --> 00:03:17,290
change everything manually and the last

00:03:14,320 --> 00:03:19,030
piece is very relate to that API changes

00:03:17,290 --> 00:03:22,000
or even changing libraries and

00:03:19,030 --> 00:03:24,550
frameworks we've seen plenty of change

00:03:22,000 --> 00:03:26,920
and I've largely embraced it and enjoyed

00:03:24,550 --> 00:03:28,840
it but when I need to switch from one

00:03:26,920 --> 00:03:31,300
library to another and change all the

00:03:28,840 --> 00:03:32,980
syntax so potentially hundreds of

00:03:31,300 --> 00:03:35,260
changes in the code base and it's just a

00:03:32,980 --> 00:03:40,780
lot of tedium and I wonder can we also

00:03:35,260 --> 00:03:42,790
improve that cool so to do that we're

00:03:40,780 --> 00:03:45,360
gonna take a step over to compiler land

00:03:42,790 --> 00:03:48,460
and talk about compilers really briefly

00:03:45,360 --> 00:03:50,140
so how do we turn this into something

00:03:48,460 --> 00:03:52,870
that the machine can understand how we

00:03:50,140 --> 00:03:54,550
turn a variable declaration into ones

00:03:52,870 --> 00:03:57,040
and zeros that can be put through the

00:03:54,550 --> 00:04:00,850
CPU and have awesome things happen in

00:03:57,040 --> 00:04:03,280
our browsers there's a little bit of

00:04:00,850 --> 00:04:07,980
magic but hopefully less less of that

00:04:03,280 --> 00:04:10,780
after today Babel gives us an awesome

00:04:07,980 --> 00:04:13,690
reference point Babel is a type of

00:04:10,780 --> 00:04:15,790
compiler that takes in source does some

00:04:13,690 --> 00:04:18,910
stuff with it and then spits back out

00:04:15,790 --> 00:04:21,040
JavaScript source a transpiler

00:04:18,910 --> 00:04:23,470
technically is what type of compiler it

00:04:21,040 --> 00:04:24,470
is and it actually has everything we

00:04:23,470 --> 00:04:28,340
need to

00:04:24,470 --> 00:04:30,410
you to understand compilers and there's

00:04:28,340 --> 00:04:32,720
this really awesome definition of a

00:04:30,410 --> 00:04:35,060
compiler that I'm going to borrow Jamie

00:04:32,720 --> 00:04:37,550
builds on Twitter and github writes this

00:04:35,060 --> 00:04:40,010
in the super tiny compiler most

00:04:37,550 --> 00:04:43,790
compilers break down into three primary

00:04:40,010 --> 00:04:47,080
stages parsing transformation and

00:04:43,790 --> 00:04:50,090
cogeneration okay let's dive in each one

00:04:47,080 --> 00:04:52,460
parsing is taking raw code turning it

00:04:50,090 --> 00:04:54,890
into a more abstract representation of

00:04:52,460 --> 00:04:56,660
the code okay it's taking that

00:04:54,890 --> 00:05:00,620
JavaScript code and turning into

00:04:56,660 --> 00:05:02,990
something else that's more abstract the

00:05:00,620 --> 00:05:04,820
second part is transformation that's

00:05:02,990 --> 00:05:06,500
taking the abstract representation and

00:05:04,820 --> 00:05:07,730
and changing it to do whatever the

00:05:06,500 --> 00:05:10,460
compiler wants it to do

00:05:07,730 --> 00:05:13,160
so in the case of babel it wants to take

00:05:10,460 --> 00:05:16,970
potentially a javascript with es2016

00:05:13,160 --> 00:05:18,470
2017-2018 features and so on and do

00:05:16,970 --> 00:05:20,960
something with that trees so that when

00:05:18,470 --> 00:05:23,810
it spits it back out it's going to be in

00:05:20,960 --> 00:05:26,200
something like closer to es 5 that more

00:05:23,810 --> 00:05:28,490
browsers can support out of the box and

00:05:26,200 --> 00:05:30,890
that's the cogeneration is spitting that

00:05:28,490 --> 00:05:32,690
code back out and other compilers might

00:05:30,890 --> 00:05:36,830
spit out something else but Babel just

00:05:32,690 --> 00:05:39,110
it's JavaScript back out cool so we're

00:05:36,830 --> 00:05:41,240
going to focus on one piece of this the

00:05:39,110 --> 00:05:43,370
abstract representation because this is

00:05:41,240 --> 00:05:46,610
where all the magic that we really care

00:05:43,370 --> 00:05:50,030
about happens so going back to our code

00:05:46,610 --> 00:05:52,160
example the first thing with parsing

00:05:50,030 --> 00:05:54,290
that we mentioned is breaking this down

00:05:52,160 --> 00:05:56,240
into tokens and there's just what are

00:05:54,290 --> 00:05:58,669
those discrete pieces of code in this

00:05:56,240 --> 00:06:01,940
line that stand on their own the atoms

00:05:58,669 --> 00:06:04,190
in the molecule and this is just a array

00:06:01,940 --> 00:06:06,860
of these tokens but from here we need to

00:06:04,190 --> 00:06:08,750
figure out how to relate these tokens to

00:06:06,860 --> 00:06:10,610
each other how does the VAR and the

00:06:08,750 --> 00:06:13,100
answer bond to each other what are the

00:06:10,610 --> 00:06:14,780
what is their connection and the 6 and

00:06:13,100 --> 00:06:16,400
the x and the 7 what how are they

00:06:14,780 --> 00:06:20,210
related and how does that tie back to

00:06:16,400 --> 00:06:21,800
the variable it's being declared so to

00:06:20,210 --> 00:06:23,780
do that we need some type of

00:06:21,800 --> 00:06:24,229
representation that representation is

00:06:23,780 --> 00:06:27,200
called

00:06:24,229 --> 00:06:29,120
the ast and ast does not stand for

00:06:27,200 --> 00:06:31,729
whatever Marcy said it is actually an

00:06:29,120 --> 00:06:34,039
arc abstract syntax tree and that sounds

00:06:31,729 --> 00:06:36,979
very a computer science e and or D but

00:06:34,039 --> 00:06:37,520
it's just a tree we don't talk about

00:06:36,979 --> 00:06:41,550
trees

00:06:37,520 --> 00:06:43,680
but we actually work with them a ton the

00:06:41,550 --> 00:06:45,810
Dom is probably the best example we have

00:06:43,680 --> 00:06:48,180
our HTML document and that has a head

00:06:45,810 --> 00:06:50,580
and a body the head has a title and meta

00:06:48,180 --> 00:06:51,840
tags and the body has divs and those

00:06:50,580 --> 00:06:54,240
divs have their own divs

00:06:51,840 --> 00:06:55,290
so what a tree is essentially is just a

00:06:54,240 --> 00:06:57,390
node at the top

00:06:55,290 --> 00:06:59,850
it's weird trees are like upside down in

00:06:57,390 --> 00:07:01,830
computer science world because just the

00:06:59,850 --> 00:07:03,450
node of the top there's a root and then

00:07:01,830 --> 00:07:06,030
it can have any number of children and

00:07:03,450 --> 00:07:07,860
then they can in turn have children and

00:07:06,030 --> 00:07:11,100
they can also have properties on them

00:07:07,860 --> 00:07:12,870
that describe them so we're gonna look

00:07:11,100 --> 00:07:16,200
at this in a just another view in a

00:07:12,870 --> 00:07:19,170
moment let me show you something called

00:07:16,200 --> 00:07:22,640
ast explore so this is a really awesome

00:07:19,170 --> 00:07:25,200
tool that's up at h to explore dotnet

00:07:22,640 --> 00:07:28,800
check it out we're gonna play with it

00:07:25,200 --> 00:07:31,050
today and show you how it works it's a

00:07:28,800 --> 00:07:32,940
little bit tricky to present with though

00:07:31,050 --> 00:07:36,360
there's a lot of options and it doesn't

00:07:32,940 --> 00:07:41,400
quite scale very well so I made a

00:07:36,360 --> 00:07:43,980
special version a Cascadia jason cool so

00:07:41,400 --> 00:07:46,530
right here we just have an empty program

00:07:43,980 --> 00:07:48,420
file that's the same thing and there's

00:07:46,530 --> 00:07:51,480
nothing here but already we have a tree

00:07:48,420 --> 00:07:53,310
and right off we can see that it has a

00:07:51,480 --> 00:07:56,400
program node this is the root node in

00:07:53,310 --> 00:07:58,710
every program every file that's that's

00:07:56,400 --> 00:07:59,760
parsed and it has three types of

00:07:58,710 --> 00:08:02,190
properties that we're going to talk

00:07:59,760 --> 00:08:04,590
about the first is its type and every

00:08:02,190 --> 00:08:06,900
every node always has a type and this

00:08:04,590 --> 00:08:09,480
will differ program at the top here and

00:08:06,900 --> 00:08:11,700
the second type of property is where the

00:08:09,480 --> 00:08:13,920
children live in this case there's a

00:08:11,700 --> 00:08:15,810
body there's nothing there yet but there

00:08:13,920 --> 00:08:18,390
will be and the third type is a

00:08:15,810 --> 00:08:20,640
descriptive property describing that

00:08:18,390 --> 00:08:24,180
node itself in this case it's describing

00:08:20,640 --> 00:08:26,870
it as a source type of module alright

00:08:24,180 --> 00:08:29,850
let's look at another example

00:08:26,870 --> 00:08:32,160
let's look at those variables again so

00:08:29,850 --> 00:08:35,099
now we can see that the program has two

00:08:32,160 --> 00:08:37,320
children it has two elements here if we

00:08:35,099 --> 00:08:39,289
expand that they are our two variable

00:08:37,320 --> 00:08:42,870
declarations asu's are awesome and

00:08:39,289 --> 00:08:44,010
Cascadia Jess is love so the first

00:08:42,870 --> 00:08:45,480
available declaration there's a little

00:08:44,010 --> 00:08:47,150
bit of a hint here say in the grey

00:08:45,480 --> 00:08:50,750
saying hey as a typist

00:08:47,150 --> 00:08:53,330
and as kind so the type we're familiar

00:08:50,750 --> 00:08:54,980
with the declarations this is what the

00:08:53,330 --> 00:08:56,300
children look like on a variable

00:08:54,980 --> 00:08:59,270
declaration there could be more than

00:08:56,300 --> 00:09:01,520
once there's just one here it also has a

00:08:59,270 --> 00:09:03,080
kind and the kind is kind of cool

00:09:01,520 --> 00:09:09,170
because it's describing whether it's a

00:09:03,080 --> 00:09:12,140
Const or a let which the VAR that looks

00:09:09,170 --> 00:09:14,120
pretty familiar let's dive deeper down

00:09:12,140 --> 00:09:16,580
the rabbit hole for a moment looking at

00:09:14,120 --> 00:09:18,170
the variable declared er this has two

00:09:16,580 --> 00:09:19,760
properties besides the type it has an ID

00:09:18,170 --> 00:09:21,740
and an it doesn't have any descriptive

00:09:19,760 --> 00:09:24,140
properties but it's got two places where

00:09:21,740 --> 00:09:26,779
children live it's good it has its

00:09:24,140 --> 00:09:28,640
identifier for a STS and then it

00:09:26,779 --> 00:09:32,990
initializes that to this string little

00:09:28,640 --> 00:09:35,900
for awesome so every node in the ast for

00:09:32,990 --> 00:09:36,860
JavaScript looks like this the node type

00:09:35,900 --> 00:09:38,180
might be a little bit different its

00:09:36,860 --> 00:09:39,890
children might live in a different place

00:09:38,180 --> 00:09:40,820
or it might not have children and I

00:09:39,890 --> 00:09:43,010
might have different descriptive

00:09:40,820 --> 00:09:46,790
properties but every node in JavaScript

00:09:43,010 --> 00:09:49,940
and the ast can be related to this

00:09:46,790 --> 00:09:52,610
example let's take it one step further

00:09:49,940 --> 00:09:54,920
so I was talking about automating code

00:09:52,610 --> 00:09:59,510
reviews before who here has seen code

00:09:54,920 --> 00:10:06,050
like this who has seen code like this on

00:09:59,510 --> 00:10:08,000
one line yeah that's a lot of hands yeah

00:10:06,050 --> 00:10:11,270
so tools like es line are great for this

00:10:08,000 --> 00:10:14,540
to look for patterns and language and

00:10:11,270 --> 00:10:17,959
help us help us warn us when we're doing

00:10:14,540 --> 00:10:20,510
things we probably shouldn't we're gonna

00:10:17,959 --> 00:10:22,100
write insolent role for this so I'm

00:10:20,510 --> 00:10:24,410
gonna go over to transform on ESP

00:10:22,100 --> 00:10:27,560
explorer and pull up the latest version

00:10:24,410 --> 00:10:29,750
of Uslan and let me explain this for a

00:10:27,560 --> 00:10:31,610
moment so every is lint roll is

00:10:29,750 --> 00:10:35,180
essentially a function this function

00:10:31,610 --> 00:10:37,430
returns an object this object is where

00:10:35,180 --> 00:10:39,860
you can say hey whenever there's a note

00:10:37,430 --> 00:10:42,020
of a given type I care about that and

00:10:39,860 --> 00:10:45,490
whenever you find it yes lint passed

00:10:42,020 --> 00:10:48,230
that into my function here so this

00:10:45,490 --> 00:10:50,900
example is looking for temple literals

00:10:48,230 --> 00:10:54,410
we don't have any what do we care about

00:10:50,900 --> 00:10:57,500
here let me go back to the Explorer if I

00:10:54,410 --> 00:10:59,089
click here cool so I see conditional

00:10:57,500 --> 00:11:00,620
expression a bunch of times

00:10:59,089 --> 00:11:02,540
pretty sure that's what turn Aries are

00:11:00,620 --> 00:11:07,370
called so that's the type so let's grab

00:11:02,540 --> 00:11:12,079
that and let's yell if anyone uses a

00:11:07,370 --> 00:11:14,120
ternary cool so over on this bottom

00:11:12,079 --> 00:11:15,439
right we see that it's hade you have a

00:11:14,120 --> 00:11:17,449
turn right here you have turnout here

00:11:15,439 --> 00:11:19,579
there's three turn Aries awesome

00:11:17,449 --> 00:11:20,959
cool I don't need Turner's that much I

00:11:19,579 --> 00:11:22,579
think they're great when they're

00:11:20,959 --> 00:11:25,059
appropriate and they're just a single

00:11:22,579 --> 00:11:27,170
one so let's narrow this down and

00:11:25,059 --> 00:11:28,579
everyone will do this they'll say hey I

00:11:27,170 --> 00:11:31,309
care about this note type but I'm gonna

00:11:28,579 --> 00:11:34,730
look for a pattern and so what do we

00:11:31,309 --> 00:11:36,769
need to look for so we talked about

00:11:34,730 --> 00:11:39,139
being nested and that's where the the

00:11:36,769 --> 00:11:42,230
node is the node of the same type is on

00:11:39,139 --> 00:11:43,459
the on the child and there's three

00:11:42,230 --> 00:11:46,249
things on this node there's the test

00:11:43,459 --> 00:11:48,290
this is the condition it executes and if

00:11:46,249 --> 00:11:50,329
that conditions truthy it returns the

00:11:48,290 --> 00:11:52,279
consequent if it's false it returns the

00:11:50,329 --> 00:11:53,629
alternate these consequence and these

00:11:52,279 --> 00:11:55,309
alternates these are the children we

00:11:53,629 --> 00:11:58,699
care about and these are the ones that

00:11:55,309 --> 00:11:59,899
have that nested type so oh lord what

00:11:58,699 --> 00:12:04,399
happened to the bottom there it is okay

00:11:59,899 --> 00:12:07,100
so let's grab that we need to write a

00:12:04,399 --> 00:12:08,720
check just a little bit logic here so we

00:12:07,100 --> 00:12:13,490
need to look at the node and look at its

00:12:08,720 --> 00:12:18,860
consequent and check its type and if it

00:12:13,490 --> 00:12:22,429
equals a conditional expression or if we

00:12:18,860 --> 00:12:24,970
copy this if that alternate is a

00:12:22,429 --> 00:12:24,970
conditional expression

00:12:27,690 --> 00:12:35,390
that's a little bit smaller Oh Lord

00:12:31,080 --> 00:12:37,680
don't don't no no don't leave five codes

00:12:35,390 --> 00:12:41,100
it's fine I'll just give a quick reload

00:12:37,680 --> 00:12:45,000
it is crashing hard cool we make this

00:12:41,100 --> 00:12:51,030
bigger again cool so I just have to fix

00:12:45,000 --> 00:12:54,900
a little bit of code here my cursor is

00:12:51,030 --> 00:12:58,560
like not where I think it is it's not

00:12:54,900 --> 00:13:00,570
prettier there it goes oh yeah this is

00:12:58,560 --> 00:13:02,040
not because of ASC xplornet this is cuz

00:13:00,570 --> 00:13:04,440
I hacked this like in the past week

00:13:02,040 --> 00:13:07,530
instead of working on my presentation at

00:13:04,440 --> 00:13:09,720
like the wrong hours of the day cool so

00:13:07,530 --> 00:13:12,030
so now we're looking for a conditional

00:13:09,720 --> 00:13:13,800
expression on either of the children and

00:13:12,030 --> 00:13:15,660
now it's only warning us about one thing

00:13:13,800 --> 00:13:17,600
and this is actually in fact the

00:13:15,660 --> 00:13:21,510
insolent rule for nested turn Aries

00:13:17,600 --> 00:13:24,810
let's look at one more example let's

00:13:21,510 --> 00:13:29,040
look at transforms so focus up here for

00:13:24,810 --> 00:13:31,230
a minute and we have two objects they're

00:13:29,040 --> 00:13:33,660
essentially the same when you have the

00:13:31,230 --> 00:13:35,700
key and the value is the the same thing

00:13:33,660 --> 00:13:38,130
in this case X they can be represented

00:13:35,700 --> 00:13:42,810
as X : X or in a shorthand version

00:13:38,130 --> 00:13:46,470
that's just X super convenient what I

00:13:42,810 --> 00:13:49,710
would like to do is try to implement the

00:13:46,470 --> 00:13:51,630
Babel transform that would make this

00:13:49,710 --> 00:13:53,700
first one with the shorthand output the

00:13:51,630 --> 00:13:56,340
same so we want to change this part in

00:13:53,700 --> 00:13:59,010
the bottom right if we look at a Babel

00:13:56,340 --> 00:14:01,050
transform the boilerplate is a little

00:13:59,010 --> 00:14:03,900
bit different there's a function that

00:14:01,050 --> 00:14:06,570
returns an object again but that object

00:14:03,900 --> 00:14:08,280
has a name and a visitor this visitor is

00:14:06,570 --> 00:14:10,460
actually the same as that object in the

00:14:08,280 --> 00:14:12,510
eslint so we're going to dive into that

00:14:10,460 --> 00:14:14,040
it cares about an identifier right now

00:14:12,510 --> 00:14:16,500
in the boilerplate it's reversing the

00:14:14,040 --> 00:14:20,880
the identifiers making them backwards

00:14:16,500 --> 00:14:25,670
that's funny so let's change that to be

00:14:20,880 --> 00:14:25,670
what do we need to be so if we look at X

00:14:25,700 --> 00:14:30,610
try this again

00:14:28,000 --> 00:14:33,220
well we got this and never seen this

00:14:30,610 --> 00:14:35,259
happen of course it's live so if I look

00:14:33,220 --> 00:14:36,370
at this we've got an object expression

00:14:35,259 --> 00:14:40,110
this is the object itself

00:14:36,370 --> 00:14:42,910
it's got properties okay the properties

00:14:40,110 --> 00:14:45,129
the object property has a short head

00:14:42,910 --> 00:14:46,899
value this is the descriptive property

00:14:45,129 --> 00:14:49,540
that we care about and it's false right

00:14:46,899 --> 00:14:53,129
now so what do we need to do we first

00:14:49,540 --> 00:14:53,129
need to care about object properties

00:14:53,610 --> 00:14:59,139
it's not prettier we first need to care

00:14:56,980 --> 00:15:01,870
about object properties and then when we

00:14:59,139 --> 00:15:05,350
run into them we need to do something

00:15:01,870 --> 00:15:08,259
with that node so that node has the

00:15:05,350 --> 00:15:13,269
shorthand value and we can just set it

00:15:08,259 --> 00:15:14,740
to be false so is it was true before on

00:15:13,269 --> 00:15:17,769
the other one and now we're changing it

00:15:14,740 --> 00:15:19,269
to false now the output matches there's

00:15:17,769 --> 00:15:23,250
one more thing we don't want to do this

00:15:19,269 --> 00:15:25,750
for my lord we don't want to do this for

00:15:23,250 --> 00:15:28,540
for every node so what we normally do is

00:15:25,750 --> 00:15:30,250
to student if check and check the path

00:15:28,540 --> 00:15:36,639
no touch for him if it's true thee only

00:15:30,250 --> 00:15:38,649
then mutate the tree cool all right so

00:15:36,639 --> 00:15:40,540
that is actually the all there is to the

00:15:38,649 --> 00:15:42,610
object property or the object shorthand

00:15:40,540 --> 00:15:44,920
property transform in Babel and this is

00:15:42,610 --> 00:15:46,899
a plug-in in the insolent not the

00:15:44,920 --> 00:15:51,009
insolent the babble plug in the source

00:15:46,899 --> 00:15:53,439
code stop here for a moment because this

00:15:51,009 --> 00:15:55,329
concept of transforming the tree and

00:15:53,439 --> 00:15:57,610
outputting something else also applies

00:15:55,329 --> 00:16:01,029
to another tool called code mods with

00:15:57,610 --> 00:16:02,980
code mods are is taking in some syntax

00:16:01,029 --> 00:16:05,589
and changing it to some updated syntax

00:16:02,980 --> 00:16:07,269
so we talked about new a new features in

00:16:05,589 --> 00:16:08,829
JavaScript and we talked about API

00:16:07,269 --> 00:16:11,589
changes and changing libraries and

00:16:08,829 --> 00:16:13,899
frameworks we could do transforms like

00:16:11,589 --> 00:16:16,209
this to take old syntax that we want to

00:16:13,899 --> 00:16:20,730
update and automate the conversion

00:16:16,209 --> 00:16:20,730
across our code base to the newer syntax

00:16:21,059 --> 00:16:26,079
there's one more thing I'll point you to

00:16:23,519 --> 00:16:29,410
this is website that just put up

00:16:26,079 --> 00:16:32,410
yesterday called a STS are awesome comm

00:16:29,410 --> 00:16:34,660
and it has full background of everything

00:16:32,410 --> 00:16:37,240
we've been talking about with links to

00:16:34,660 --> 00:16:39,670
examples super setting the compilers in

00:16:37,240 --> 00:16:40,760
there and some other things so check it

00:16:39,670 --> 00:16:46,090
out after this

00:16:40,760 --> 00:16:46,090
for more information cool

00:16:46,150 --> 00:16:50,660
so I know we all heard neo say and the

00:16:48,890 --> 00:16:53,180
matrix I know kung fu

00:16:50,660 --> 00:16:55,280
but if Neil is a programmer and the

00:16:53,180 --> 00:16:57,830
matrix is essentially made of code and

00:16:55,280 --> 00:16:59,270
he's bending the matrix to as well what

00:16:57,830 --> 00:17:04,610
I think he really meant to say is I know

00:16:59,270 --> 00:17:07,550
some really sick ast transforms try it

00:17:04,610 --> 00:17:10,459
pull up ast xplornet and start typing

00:17:07,550 --> 00:17:12,220
code paste stuff from from your project

00:17:10,459 --> 00:17:14,420
and see what it looks like

00:17:12,220 --> 00:17:16,970
and the next time you're in code review

00:17:14,420 --> 00:17:18,380
and you see something like oh I need to

00:17:16,970 --> 00:17:21,230
tell you about this thing that you

00:17:18,380 --> 00:17:23,510
couldn't otherwise know about think

00:17:21,230 --> 00:17:26,089
about whether that was that can be

00:17:23,510 --> 00:17:28,280
discerned filtered down into a pattern

00:17:26,089 --> 00:17:31,760
that you can automate that you can write

00:17:28,280 --> 00:17:33,920
in the estimate rule for here's actually

00:17:31,760 --> 00:17:36,610
the first es lint rule I wrote was for

00:17:33,920 --> 00:17:39,710
this code we had this API request

00:17:36,610 --> 00:17:43,730
function that would get data from the

00:17:39,710 --> 00:17:45,890
server and it had a way of saying how

00:17:43,730 --> 00:17:47,960
many records it wanted to retrieve you

00:17:45,890 --> 00:17:50,510
know maybe like 50 or 100 something

00:17:47,960 --> 00:17:52,970
reasonable but we had cases in our code

00:17:50,510 --> 00:17:56,600
base that looked passed in the count of

00:17:52,970 --> 00:17:59,750
infinity which would get all the records

00:17:56,600 --> 00:18:01,910
and that sounds okay right

00:17:59,750 --> 00:18:03,680
except users with lots of data you know

00:18:01,910 --> 00:18:07,670
our big customers that love us so much

00:18:03,680 --> 00:18:09,620
they would make this request on in the

00:18:07,670 --> 00:18:11,300
browser and it would take forever and

00:18:09,620 --> 00:18:13,190
after three seconds in a timeout and

00:18:11,300 --> 00:18:15,290
they would just get a really bad screen

00:18:13,190 --> 00:18:17,930
that didn't help them at all

00:18:15,290 --> 00:18:20,000
so we we need to fix this but we had

00:18:17,930 --> 00:18:22,010
something like sixty plus developers in

00:18:20,000 --> 00:18:24,680
the front end code across all the teams

00:18:22,010 --> 00:18:26,570
and this was like a it's kept popping up

00:18:24,680 --> 00:18:28,760
here and there and we could tell

00:18:26,570 --> 00:18:30,230
everyone but like how do you just like

00:18:28,760 --> 00:18:32,450
tell everyone and then tell the new

00:18:30,230 --> 00:18:33,920
person all that so we automated this so

00:18:32,450 --> 00:18:36,020
we wrote an excellent rule that looked

00:18:33,920 --> 00:18:38,660
for any invocations the API dot request

00:18:36,020 --> 00:18:40,730
and looked at the parameters passed in

00:18:38,660 --> 00:18:42,170
and then looked at that that

00:18:40,730 --> 00:18:43,820
configuration object and looked at the

00:18:42,170 --> 00:18:45,500
count and made sure it was something

00:18:43,820 --> 00:18:48,230
reasonable and if it was something crazy

00:18:45,500 --> 00:18:50,970
like infinity we would warn them nicely

00:18:48,230 --> 00:18:53,320
before code review

00:18:50,970 --> 00:18:56,650
let's talk about API changes can we

00:18:53,320 --> 00:18:58,750
automate those we had been using

00:18:56,650 --> 00:19:01,300
glamorous in a project time on now and

00:18:58,750 --> 00:19:03,120
this is basically styled components CSS

00:19:01,300 --> 00:19:05,590
and Jas actually is great great lately

00:19:03,120 --> 00:19:07,179
and Kent C Dodds he we talked about him

00:19:05,590 --> 00:19:09,100
yesterday he worked on this and he was

00:19:07,179 --> 00:19:11,620
the first to say hey everyone

00:19:09,100 --> 00:19:13,360
glamorous this glamorous is great but

00:19:11,620 --> 00:19:16,420
emotions even better we should just

00:19:13,360 --> 00:19:19,540
deprecated and move to that so we have

00:19:16,420 --> 00:19:21,090
lots of CSS lots of components we've got

00:19:19,540 --> 00:19:24,580
to change everything in our code base

00:19:21,090 --> 00:19:27,550
and it looks something like this this is

00:19:24,580 --> 00:19:30,610
just glamorous takes in some some CSS

00:19:27,550 --> 00:19:33,010
and generates an element with that style

00:19:30,610 --> 00:19:36,690
applied we need to change the syntax

00:19:33,010 --> 00:19:38,980
from using glamorous to using styled and

00:19:36,690 --> 00:19:40,420
instead of taking an object and it

00:19:38,980 --> 00:19:41,800
needed to be passed a string literal

00:19:40,420 --> 00:19:43,840
which is great because then you just

00:19:41,800 --> 00:19:46,240
write real CSS and not like JavaScript

00:19:43,840 --> 00:19:50,050
to fly it turned out there was a

00:19:46,240 --> 00:19:52,000
community effort to transform all the

00:19:50,050 --> 00:19:54,040
instances of glamorous to emotion we

00:19:52,000 --> 00:19:57,130
applied this in our code base and change

00:19:54,040 --> 00:20:04,240
hundreds of wines and just a click of a

00:19:57,130 --> 00:20:04,960
button and it was fantastic cool let me

00:20:04,240 --> 00:20:08,679
tell you one more story

00:20:04,960 --> 00:20:10,450
I was at a Jess coffe in Florida just

00:20:08,679 --> 00:20:11,800
conf u.s. 2015 and there was a young

00:20:10,450 --> 00:20:13,480
developer they got on stage and he was

00:20:11,800 --> 00:20:15,429
telling his story and we're something

00:20:13,480 --> 00:20:18,700
like this there was this new thing

00:20:15,429 --> 00:20:20,800
called es6 there was a large gap of my

00:20:18,700 --> 00:20:22,679
knowledge on parsers compilers and

00:20:20,800 --> 00:20:25,330
generally the intricacies of JavaScript

00:20:22,679 --> 00:20:29,200
so I decided to make an es6 transpiler

00:20:25,330 --> 00:20:31,929
to learn it called six-to-five this was

00:20:29,200 --> 00:20:35,740
Sebastian McKenzie and 65 is now known

00:20:31,929 --> 00:20:37,720
as Babel now I am not encouraging you

00:20:35,740 --> 00:20:40,900
all to go out write your own compiler we

00:20:37,720 --> 00:20:43,480
don't need to but given Babel given is

00:20:40,900 --> 00:20:46,090
lint given some libraries for code mods

00:20:43,480 --> 00:20:48,550
and given equivalents and typescript we

00:20:46,090 --> 00:20:50,500
don't have to we can build plug-ins for

00:20:48,550 --> 00:20:52,630
these tools we can write our own

00:20:50,500 --> 00:20:55,150
limiting plugins that look like what I

00:20:52,630 --> 00:20:59,169
showed you we can write transforms that

00:20:55,150 --> 00:21:03,200
can update our code we can harness the

00:20:59,169 --> 00:21:06,500
ast and I encourage everyone here this

00:21:03,200 --> 00:21:08,149
is something for you to try I'm here to

00:21:06,500 --> 00:21:11,690
answer questions on the internet or

00:21:08,149 --> 00:21:14,450
after this I encourage you all to build

00:21:11,690 --> 00:21:16,490
your own tools to help you and help

00:21:14,450 --> 00:21:19,549
everyone else the right JavaScript be

00:21:16,490 --> 00:21:21,289
more effective JavaScript developers my

00:21:19,549 --> 00:21:24,940
name is will Klein I'm on twitter at

00:21:21,289 --> 00:21:24,940

YouTube URL: https://www.youtube.com/watch?v=JMqZgUNkqgk


