Title: Introducing and Scaling a GraphQL BFF - JS Roundabout - February 2020
Publication date: 2020-03-08
Playlist: The JS Roundabout
Description: 
	Presented by Michelle Garrett, Software Engineer at Condé Nast.

'Introducing and Scaling a GraphQL BFF'.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:08,940
I'm here today to talk about introducing

00:00:01,680 --> 00:00:11,370
and scaling a graph QL BSF sir we're

00:00:08,940 --> 00:00:14,610
gonna be talking about growing an API

00:00:11,370 --> 00:00:16,800
like a plant growing an API in

00:00:14,610 --> 00:00:20,400
production over the course of a few

00:00:16,800 --> 00:00:21,990
years specifically a graph QL API and

00:00:20,400 --> 00:00:25,010
I'm gonna tell you the story of a graph

00:00:21,990 --> 00:00:27,119
QL API that I built at condé nast and

00:00:25,010 --> 00:00:27,990
basically what happened to over the

00:00:27,119 --> 00:00:31,949
course of two years

00:00:27,990 --> 00:00:33,510
and where the architecture is going and

00:00:31,949 --> 00:00:37,050
I wanted to talk about this because

00:00:33,510 --> 00:00:38,760
graph QL has been around for a few years

00:00:37,050 --> 00:00:41,219
now but it's only really just hitting

00:00:38,760 --> 00:00:42,930
the big time now but there are people

00:00:41,219 --> 00:00:45,750
and companies that have been using it

00:00:42,930 --> 00:00:47,520
for over a year at this point and might

00:00:45,750 --> 00:00:49,829
be looking to scale the architecture

00:00:47,520 --> 00:00:51,480
beyond a certain point and they're also

00:00:49,829 --> 00:00:54,180
as still people who are looking to

00:00:51,480 --> 00:00:58,949
introduce graph QL so hopefully this can

00:00:54,180 --> 00:01:00,300
satisfy all of these people so this one

00:00:58,949 --> 00:01:02,280
I'm going to talk about I'm gonna give a

00:01:00,300 --> 00:01:04,830
quick one-minute crash course and what

00:01:02,280 --> 00:01:07,220
graph QL is just in case you know you

00:01:04,830 --> 00:01:08,430
you need to know I'm gonna talk about

00:01:07,220 --> 00:01:11,280
BFFs

00:01:08,430 --> 00:01:13,140
not best friends forever the backend for

00:01:11,280 --> 00:01:15,570
front-end software pattern we're going

00:01:13,140 --> 00:01:17,580
to talk about that what it is I'm going

00:01:15,570 --> 00:01:20,070
to talk about building and scaling a BFF

00:01:17,580 --> 00:01:24,930
and what we learnt on this whole process

00:01:20,070 --> 00:01:27,390
and this is a photo of me as you can see

00:01:24,930 --> 00:01:29,790
if you want to I'm a software engineer

00:01:27,390 --> 00:01:31,590
at Conde Nast which is a publishing

00:01:29,790 --> 00:01:33,600
company in London and if you want to

00:01:31,590 --> 00:01:38,070
tweet me it's MS Michele golf you can

00:01:33,600 --> 00:01:43,079
tweet me about graph QL anytime the

00:01:38,070 --> 00:01:44,909
let's do our graph QL crash course she

00:01:43,079 --> 00:01:47,520
said JavaScript meetup and graph QL is

00:01:44,909 --> 00:01:50,220
not a JavaScript specific thing it could

00:01:47,520 --> 00:01:51,930
be used in many languages but there are

00:01:50,220 --> 00:01:54,750
a lot of JavaScript enthusiasts of graph

00:01:51,930 --> 00:01:59,250
QL how many people here have used graph

00:01:54,750 --> 00:02:05,280
QL okay so lit where people who are

00:01:59,250 --> 00:02:07,049
graph QL curious yeah good okay all

00:02:05,280 --> 00:02:09,300
right here's our crash course what is

00:02:07,049 --> 00:02:11,700
graph QL so the official graph QL

00:02:09,300 --> 00:02:13,620
website will tell you that it is a query

00:02:11,700 --> 00:02:15,510
language for API is

00:02:13,620 --> 00:02:19,709
you also might say that it is a language

00:02:15,510 --> 00:02:21,629
for requesting remote data and when you

00:02:19,709 --> 00:02:23,730
hear it spoken about you probably hear

00:02:21,629 --> 00:02:26,549
it spoken about as the cool new

00:02:23,730 --> 00:02:32,069
alternative to rest api's the new way

00:02:26,549 --> 00:02:34,500
that api is are being built and let's do

00:02:32,069 --> 00:02:37,530
a quick comparison of rest and graph QL

00:02:34,500 --> 00:02:39,120
I will say rest is rest is fine they're

00:02:37,530 --> 00:02:41,220
not mutually exclusive you can use both

00:02:39,120 --> 00:02:43,700
you don't have to change your whole life

00:02:41,220 --> 00:02:46,980
to graph QL unless you want to

00:02:43,700 --> 00:02:50,010
so with rest you will often have

00:02:46,980 --> 00:02:53,370
multiple endpoints so for example if

00:02:50,010 --> 00:02:55,379
it's a publishing website's API you

00:02:53,370 --> 00:02:57,420
might have an article endpoint and a

00:02:55,379 --> 00:02:59,220
video endpoint the article endpoint will

00:02:57,420 --> 00:03:02,730
give you article data the video endpoint

00:02:59,220 --> 00:03:04,829
will give you video data graph QL has a

00:03:02,730 --> 00:03:07,440
single endpoint that can provide old

00:03:04,829 --> 00:03:11,489
data so it's one multi-purpose endpoint

00:03:07,440 --> 00:03:13,680
it's usually / graphic UL and with a

00:03:11,489 --> 00:03:16,140
REST API you get the same set of fields

00:03:13,680 --> 00:03:18,950
from the endpoint every single time so

00:03:16,140 --> 00:03:21,239
even if you only need the title if you

00:03:18,950 --> 00:03:23,069
go to the article endpoint you'll always

00:03:21,239 --> 00:03:25,290
get the exact same set of information

00:03:23,069 --> 00:03:28,049
about that article regardless of how

00:03:25,290 --> 00:03:31,530
much of that data you actually use in

00:03:28,049 --> 00:03:33,989
graph QL you specify what what specific

00:03:31,530 --> 00:03:36,419
fields you want and then you get exactly

00:03:33,989 --> 00:03:40,829
the data you asked for no more and no

00:03:36,419 --> 00:03:43,440
less and the key concepts in graph QL

00:03:40,829 --> 00:03:45,359
there is a schema that tells you what

00:03:43,440 --> 00:03:48,150
fields you can request from the API and

00:03:45,359 --> 00:03:49,980
then you write a graph QL query that

00:03:48,150 --> 00:03:53,099
describes the data fields that you want

00:03:49,980 --> 00:03:54,900
and so you get back exactly the data

00:03:53,099 --> 00:03:57,599
that you asked for in your graph QL

00:03:54,900 --> 00:04:03,060
query it's kind of like a shopping list

00:03:57,599 --> 00:04:07,290
for API fields so bffs let's talk about

00:04:03,060 --> 00:04:10,919
BFFs BFF stands for the backend for

00:04:07,290 --> 00:04:12,780
front-end API which is a software patent

00:04:10,919 --> 00:04:16,949
that was originally popularized by

00:04:12,780 --> 00:04:19,289
SoundCloud a few years ago and it's a

00:04:16,949 --> 00:04:22,079
pattern that specifically for internal

00:04:19,289 --> 00:04:25,050
organization api's by which I mean API

00:04:22,079 --> 00:04:26,969
is that are not widely available for

00:04:25,050 --> 00:04:27,570
public consumption by internal to one

00:04:26,969 --> 00:04:31,380
particular

00:04:27,570 --> 00:04:33,260
organization and let's talk about what

00:04:31,380 --> 00:04:35,850
this is offering an alternative to you

00:04:33,260 --> 00:04:37,140
so the alternative or what existed

00:04:35,850 --> 00:04:41,520
before this pattern is the

00:04:37,140 --> 00:04:44,190
one-size-fits-all API and this is a API

00:04:41,520 --> 00:04:46,410
that's a monolithic API that is shared

00:04:44,190 --> 00:04:48,900
between multiple applications or

00:04:46,410 --> 00:04:50,310
front-ends it probably wraps the main

00:04:48,900 --> 00:04:52,590
data sources that are used by a

00:04:50,310 --> 00:04:56,460
particular organization like the common

00:04:52,590 --> 00:04:57,840
database something like that and you

00:04:56,460 --> 00:05:00,420
might have a scenario like this where

00:04:57,840 --> 00:05:03,810
you have the Shedd API and it's being

00:05:00,420 --> 00:05:05,580
consumed by multiple applications and

00:05:03,810 --> 00:05:07,770
these applications might have different

00:05:05,580 --> 00:05:10,500
user experiences and they might use

00:05:07,770 --> 00:05:13,440
different parts of that shared API but

00:05:10,500 --> 00:05:16,140
because this API is shared they this API

00:05:13,440 --> 00:05:19,320
must serve all of those UIs and

00:05:16,140 --> 00:05:21,150
applications equally it's it's a common

00:05:19,320 --> 00:05:26,940
denominator between all of the different

00:05:21,150 --> 00:05:29,760
platforms so it's not necessarily a bad

00:05:26,940 --> 00:05:32,190
idea to have a common shared API it

00:05:29,760 --> 00:05:34,550
happens frequently but there are some

00:05:32,190 --> 00:05:38,430
common pain points that occur with a

00:05:34,550 --> 00:05:40,500
one-size-fits-all API architecture the

00:05:38,430 --> 00:05:46,050
first one being that different clients

00:05:40,500 --> 00:05:48,780
need different sets of data so it's it's

00:05:46,050 --> 00:05:50,490
impossible for one API to have the

00:05:48,780 --> 00:05:53,220
perfect endpoint for every single

00:05:50,490 --> 00:05:55,590
application giving it exactly the the

00:05:53,220 --> 00:05:57,450
article data that it needs and if the

00:05:55,590 --> 00:05:59,090
one-size-fits-all API tries to do this

00:05:57,450 --> 00:06:01,800
it will probably become really bloated

00:05:59,090 --> 00:06:04,410
the article endpoint will have thousands

00:06:01,800 --> 00:06:07,170
of fields talking from personal

00:06:04,410 --> 00:06:10,380
experience yes and it's gonna become

00:06:07,170 --> 00:06:12,300
increasingly unruly and the second thing

00:06:10,380 --> 00:06:14,040
is that the Shedd api becomes a

00:06:12,300 --> 00:06:17,880
bottleneck when rolling out new features

00:06:14,040 --> 00:06:19,830
so say there's a new feature and the UI

00:06:17,880 --> 00:06:21,480
developer the front-end developer they

00:06:19,830 --> 00:06:23,970
need to put in a feature request to the

00:06:21,480 --> 00:06:26,220
back-end team or the API team saying hey

00:06:23,970 --> 00:06:27,630
I need this new set of data and they're

00:06:26,220 --> 00:06:30,440
unable to proceed until that feature

00:06:27,630 --> 00:06:34,110
request is has gone through and

00:06:30,440 --> 00:06:35,730
meanwhile the back-end team they have to

00:06:34,110 --> 00:06:37,350
juggle the priorities of multiple

00:06:35,730 --> 00:06:38,820
different applications which means that

00:06:37,350 --> 00:06:41,510
your feature request might not always be

00:06:38,820 --> 00:06:41,510
at the top of the pile

00:06:42,439 --> 00:06:49,499
so this is where the back end the front

00:06:45,629 --> 00:06:52,229
end pattern comes in so it's in order to

00:06:49,499 --> 00:06:54,659
solve the pain points of having multiple

00:06:52,229 --> 00:06:58,499
applications putting a burden on one

00:06:54,659 --> 00:07:01,529
single fit sole API it the BFF pattern

00:06:58,499 --> 00:07:04,710
recommends building one API service per

00:07:01,529 --> 00:07:06,300
user experience or front-end so that

00:07:04,710 --> 00:07:08,939
means that each front-end has

00:07:06,300 --> 00:07:10,800
essentially has its own custom API that

00:07:08,939 --> 00:07:13,680
is built specifically to serve the needs

00:07:10,800 --> 00:07:15,149
of that user experience and crucially

00:07:13,680 --> 00:07:18,599
it's maintained by the same team that

00:07:15,149 --> 00:07:21,479
builds the front-end so it might look

00:07:18,599 --> 00:07:23,879
like this so a BFF is created as a sort

00:07:21,479 --> 00:07:26,789
of translation layout in between a shed

00:07:23,879 --> 00:07:30,539
API or data source which means each

00:07:26,789 --> 00:07:36,029
application can specifically tailor the

00:07:30,539 --> 00:07:39,360
API for their needs clients might also

00:07:36,029 --> 00:07:40,979
be using multiple API is so more than

00:07:39,360 --> 00:07:43,619
just that one particular shared data

00:07:40,979 --> 00:07:47,879
source so a BFF API can act as a sort of

00:07:43,619 --> 00:07:49,979
a single application api gateway which

00:07:47,879 --> 00:07:54,800
aggregates all of the different API s

00:07:49,979 --> 00:07:54,800
into a single back-end for front-end API

00:07:55,849 --> 00:08:02,129
so let's talk the benefits number one is

00:07:59,519 --> 00:08:05,039
that it's easier to adopt the API as UI

00:08:02,129 --> 00:08:06,749
requirements change so now if a new

00:08:05,039 --> 00:08:08,580
feature requirement comes in or if your

00:08:06,749 --> 00:08:10,019
feature has to change instead of waiting

00:08:08,580 --> 00:08:12,389
for the backend team to do all the work

00:08:10,019 --> 00:08:14,129
to implement that data set they can just

00:08:12,389 --> 00:08:17,339
go ahead and implement that themselves

00:08:14,129 --> 00:08:19,379
in the BFF secondly it simplifies the

00:08:17,339 --> 00:08:22,199
process of lining up client and server

00:08:19,379 --> 00:08:25,379
releases so now that one team is

00:08:22,199 --> 00:08:26,729
managing both the UI and the API they

00:08:25,379 --> 00:08:30,990
don't have to release it exactly the

00:08:26,729 --> 00:08:34,079
same time also because it's focus the

00:08:30,990 --> 00:08:35,789
BFF API will inevitably be smaller than

00:08:34,079 --> 00:08:37,649
a shared single purpose API it'll

00:08:35,789 --> 00:08:40,709
probably have smaller payloads you're

00:08:37,649 --> 00:08:42,479
not getting unnecessary data and finally

00:08:40,709 --> 00:08:45,319
you're able to aggregate multiple calls

00:08:42,479 --> 00:08:49,380
to downstream services into a single

00:08:45,319 --> 00:08:51,300
interface that is used by that UI which

00:08:49,380 --> 00:08:54,140
is a lot simpler and probably in most

00:08:51,300 --> 00:08:57,180
cases more performant

00:08:54,140 --> 00:08:59,820
so if you're a graphical enthusiast

00:08:57,180 --> 00:09:02,190
you might be thinking BFFs in graph QL

00:08:59,820 --> 00:09:04,260
they might have some crossover some

00:09:02,190 --> 00:09:07,560
similar benefits in which case you would

00:09:04,260 --> 00:09:11,370
be correct because the the BFF pattern

00:09:07,560 --> 00:09:14,370
was created before graph QL became

00:09:11,370 --> 00:09:19,740
popular and the BFF pattern and graph QL

00:09:14,370 --> 00:09:23,490
do solve many of the same problems so if

00:09:19,740 --> 00:09:24,930
we do a comparison bffs provide only the

00:09:23,490 --> 00:09:26,760
data that is needed by the client

00:09:24,930 --> 00:09:29,279
because it's specific for that UI and

00:09:26,760 --> 00:09:31,110
meanwhile graph QL allows clients the

00:09:29,279 --> 00:09:33,180
flexibility to define their own daily

00:09:31,110 --> 00:09:36,690
needs so you can specify exactly what

00:09:33,180 --> 00:09:38,310
data they want BFFs reduce over fetching

00:09:36,690 --> 00:09:40,500
because they return only the data for

00:09:38,310 --> 00:09:42,779
one client rather than multiple clients

00:09:40,500 --> 00:09:45,510
and graph QL does the thing does the

00:09:42,779 --> 00:09:48,390
same thing since it's returning only the

00:09:45,510 --> 00:09:50,339
data that is requested

00:09:48,390 --> 00:09:52,560
finally BFFs allow you to combine

00:09:50,339 --> 00:09:55,350
multiple data sources into a single BFF

00:09:52,560 --> 00:09:57,360
interface and graph QL also allows you

00:09:55,350 --> 00:10:04,020
to aggregate multiple data sources into

00:09:57,360 --> 00:10:05,580
a single graph QL schema or interface so

00:10:04,020 --> 00:10:09,060
there's definitely a lot of shared

00:10:05,580 --> 00:10:10,530
ground between BFFs and graph QL but

00:10:09,060 --> 00:10:13,320
they're definitely not equivalent to one

00:10:10,530 --> 00:10:15,510
another back-end for front-end is a

00:10:13,320 --> 00:10:18,210
design pattern that could be used with

00:10:15,510 --> 00:10:21,270
any kind of API a REST API or a graph QL

00:10:18,210 --> 00:10:23,280
API and graph QL api's I not always

00:10:21,270 --> 00:10:25,680
designed to be bffs sometimes they are

00:10:23,280 --> 00:10:28,520
designed for multiple applications

00:10:25,680 --> 00:10:30,540
rather than just a single application

00:10:28,520 --> 00:10:33,750
but the reason that I'm talking about

00:10:30,540 --> 00:10:36,270
BFFs and graph QL together is that in my

00:10:33,750 --> 00:10:38,400
experience bffs a very common way to

00:10:36,270 --> 00:10:41,130
introduce graph QL in inside

00:10:38,400 --> 00:10:43,200
organizations and I'm not just saying

00:10:41,130 --> 00:10:46,709
that because I built one but I have had

00:10:43,200 --> 00:10:48,240
many stories of this being the case and

00:10:46,709 --> 00:10:51,240
I've heard of many teams introducing

00:10:48,240 --> 00:10:54,300
graph QL to that company or project in

00:10:51,240 --> 00:10:57,080
the form of a BFF that will frequently

00:10:54,300 --> 00:10:59,820
wrap legacy api's it'll frequently

00:10:57,080 --> 00:11:02,760
aggregate multiple data sources ease a

00:10:59,820 --> 00:11:05,610
transition to micro services or be a

00:11:02,760 --> 00:11:07,680
bridge as but when there's a migration

00:11:05,610 --> 00:11:11,880
between different api's

00:11:07,680 --> 00:11:14,490
and my theory on why a graph QL bffs a

00:11:11,880 --> 00:11:16,140
so common is that I think that a BFF is

00:11:14,490 --> 00:11:19,320
a really low stakes way to introduce

00:11:16,140 --> 00:11:21,510
graph QL to an organization especially

00:11:19,320 --> 00:11:24,450
when graph QL was not as popular as it

00:11:21,510 --> 00:11:27,180
is now its surface area is limited to a

00:11:24,450 --> 00:11:28,800
single application and it does not

00:11:27,180 --> 00:11:35,339
require you to actually rewrite any

00:11:28,800 --> 00:11:37,410
downstream services in graph QL so now

00:11:35,339 --> 00:11:40,290
I'm going to tell you about a real life

00:11:37,410 --> 00:11:44,160
graph QL BFF that I built and what

00:11:40,290 --> 00:11:46,680
happened to it the first in context I

00:11:44,160 --> 00:11:49,920
work for conde nast which is a

00:11:46,680 --> 00:11:51,149
publishing company lots people haven't

00:11:49,920 --> 00:11:52,920
heard of the parent company a bit of

00:11:51,149 --> 00:11:55,800
probably heard of the brands such as

00:11:52,920 --> 00:11:58,800
Varrick magazine and GQ magazine which

00:11:55,800 --> 00:11:59,970
are the two brands that I work on and I

00:11:58,800 --> 00:12:01,950
always say this when I give graphical

00:11:59,970 --> 00:12:05,760
talks but GQ is not a magazine about

00:12:01,950 --> 00:12:08,130
graph QL it is if it is a magazine about

00:12:05,760 --> 00:12:11,040
men's fashion just want to make that

00:12:08,130 --> 00:12:15,150
clear although I would look I would I

00:12:11,040 --> 00:12:17,279
would read that so for three years I've

00:12:15,150 --> 00:12:20,190
been on the team that builds the

00:12:17,279 --> 00:12:22,560
International Vogue and GQ websites so

00:12:20,190 --> 00:12:25,140
currently we my team is responsible for

00:12:22,560 --> 00:12:26,940
21 different international Vogue and GQ

00:12:25,140 --> 00:12:29,760
websites and they're all served by a

00:12:26,940 --> 00:12:33,089
single platform so it's a multi-tenant

00:12:29,760 --> 00:12:36,209
react application and these sites are

00:12:33,089 --> 00:12:37,950
currently fully powered by graph QL all

00:12:36,209 --> 00:12:40,800
of that data need to serve by graph QL

00:12:37,950 --> 00:12:42,750
and they have been since early 2018

00:12:40,800 --> 00:12:47,730
which is when we made the switch to

00:12:42,750 --> 00:12:49,610
graph QL and you might have seen one of

00:12:47,730 --> 00:12:51,810
these before a content management system

00:12:49,610 --> 00:12:54,930
specifically a custom content management

00:12:51,810 --> 00:12:57,750
system this is where all the data comes

00:12:54,930 --> 00:13:01,589
from for the variant DQ websites it's

00:12:57,750 --> 00:13:03,540
internally built CMS and so this is

00:13:01,589 --> 00:13:07,589
where the data comes from for our react

00:13:03,540 --> 00:13:10,290
application and copilot has a REST API

00:13:07,589 --> 00:13:12,899
it did not have a graph QL API when we

00:13:10,290 --> 00:13:17,640
first started building with it

00:13:12,899 --> 00:13:20,010
and we're very dependent on this API so

00:13:17,640 --> 00:13:21,570
before we had graph QL our API

00:13:20,010 --> 00:13:24,060
architecture looked a bit like this

00:13:21,570 --> 00:13:26,190
so we have a react application it's a

00:13:24,060 --> 00:13:29,250
very simplified version of elk attack

00:13:26,190 --> 00:13:30,930
you see react application and we were

00:13:29,250 --> 00:13:33,990
speaking pretty much directly to

00:13:30,930 --> 00:13:36,360
multiple rest api's the most significant

00:13:33,990 --> 00:13:39,870
being the content API full that CMS

00:13:36,360 --> 00:13:42,630
copilot and here are some of the

00:13:39,870 --> 00:13:44,850
problems we had so the REST API that we

00:13:42,630 --> 00:13:47,390
used was not intuitive some of the

00:13:44,850 --> 00:13:50,850
fields were named kind of weird things

00:13:47,390 --> 00:13:52,740
some of the data took multiple requests

00:13:50,850 --> 00:13:54,870
to get some of the data was really

00:13:52,740 --> 00:13:57,630
deeply nested in ways that did not

00:13:54,870 --> 00:13:59,160
really make sense to us so that was the

00:13:57,630 --> 00:14:01,200
first problem

00:13:59,160 --> 00:14:04,170
secondly we were massively over fetching

00:14:01,200 --> 00:14:07,560
data there was just so much data when

00:14:04,170 --> 00:14:09,300
you get a single article and a lot of

00:14:07,560 --> 00:14:12,360
this was making its way to the clients

00:14:09,300 --> 00:14:14,100
so we just had way too much data and

00:14:12,360 --> 00:14:15,990
finally our react components were

00:14:14,100 --> 00:14:18,780
littered with so much API related

00:14:15,990 --> 00:14:21,300
business logic because we were speaking

00:14:18,780 --> 00:14:23,820
to the REST API is pretty much directly

00:14:21,300 --> 00:14:26,940
from the rest application that the react

00:14:23,820 --> 00:14:29,760
application so early last year we

00:14:26,940 --> 00:14:32,520
introduced graph QL in in the form of a

00:14:29,760 --> 00:14:35,040
BFF so you see this is out architecture

00:14:32,520 --> 00:14:37,530
and we're still speaking to the exact

00:14:35,040 --> 00:14:41,450
same REST API s but we introduced this

00:14:37,530 --> 00:14:45,480
graph QL BFF in the middle as a sort of

00:14:41,450 --> 00:14:46,830
common interface or shields that sits in

00:14:45,480 --> 00:14:50,190
between the react application and the

00:14:46,830 --> 00:14:52,830
rest API is providing a single interface

00:14:50,190 --> 00:14:55,020
that the react application now queries

00:14:52,830 --> 00:14:57,510
so all of that business logic that was

00:14:55,020 --> 00:15:01,790
previously in the react application has

00:14:57,510 --> 00:15:05,520
now moved into this graph QL BFF layout

00:15:01,790 --> 00:15:09,150
and it took us about three months to

00:15:05,520 --> 00:15:11,520
fully switch over to graph QL most of

00:15:09,150 --> 00:15:14,850
that was taken up by writing acceptance

00:15:11,520 --> 00:15:16,680
tests we integrated out our new API

00:15:14,850 --> 00:15:19,980
incrementally so we did it page by page

00:15:16,680 --> 00:15:22,440
we started with a category page and then

00:15:19,980 --> 00:15:26,120
finally did did releases week by week

00:15:22,440 --> 00:15:29,300
until we made it to the home page and

00:15:26,120 --> 00:15:31,740
here's what graph QL gave us a beautiful

00:15:29,300 --> 00:15:33,950
intuitively designed API that actually

00:15:31,740 --> 00:15:35,459
made sense to us with relationships

00:15:33,950 --> 00:15:37,800
designed in a way that

00:15:35,459 --> 00:15:39,360
made sense to us it gave us the ability

00:15:37,800 --> 00:15:41,790
to fetch only the data that we actually

00:15:39,360 --> 00:15:42,990
needed rather than a lot of unnecessary

00:15:41,790 --> 00:15:44,610
data

00:15:42,990 --> 00:15:46,199
it gave us a single interface to

00:15:44,610 --> 00:15:49,410
interact with multiple downstream

00:15:46,199 --> 00:15:51,569
services and finally it kept out

00:15:49,410 --> 00:15:53,879
components free of API related business

00:15:51,569 --> 00:15:59,610
logic that was previously cluttering up

00:15:53,879 --> 00:16:02,040
the application and honestly we just

00:15:59,610 --> 00:16:04,040
loved graph QL we over obsessed with

00:16:02,040 --> 00:16:06,119
graph QL and it was really successful

00:16:04,040 --> 00:16:09,240
development in our architecture that

00:16:06,119 --> 00:16:12,720
made everyone working in the application

00:16:09,240 --> 00:16:14,279
super happy new developers who joined

00:16:12,720 --> 00:16:17,939
the codebase were thrilled to work with

00:16:14,279 --> 00:16:20,660
graph QL but for now this API was just

00:16:17,939 --> 00:16:23,279
being used by owl owl single application

00:16:20,660 --> 00:16:25,319
and we'd created our own personal graph

00:16:23,279 --> 00:16:28,889
QL schema wrapping ap eyes that were

00:16:25,319 --> 00:16:30,839
used by other other teams and just to

00:16:28,889 --> 00:16:33,029
foreshadow the next the next bit of my

00:16:30,839 --> 00:16:35,730
talk we did always have a slight feeling

00:16:33,029 --> 00:16:38,339
as we were building our graph QL vff

00:16:35,730 --> 00:16:40,139
that perhaps someday this scheme would

00:16:38,339 --> 00:16:41,970
be useful beyond the confines of just

00:16:40,139 --> 00:16:43,829
our application and maybe we could share

00:16:41,970 --> 00:16:49,470
it someday with other teams in the

00:16:43,829 --> 00:16:52,679
organization and I'm going to stop here

00:16:49,470 --> 00:16:55,470
and talk about one of the issues with

00:16:52,679 --> 00:16:58,679
bffs which is duplication which is

00:16:55,470 --> 00:16:59,730
something that comes up a lot and in the

00:16:58,679 --> 00:17:01,499
scenario that I have just described

00:16:59,730 --> 00:17:03,689
there's already some risk of duplication

00:17:01,499 --> 00:17:07,409
because we're essentially re

00:17:03,689 --> 00:17:08,880
implementing a common shed API and if

00:17:07,409 --> 00:17:12,899
another application or another team

00:17:08,880 --> 00:17:15,539
decides to wrap the exact same API which

00:17:12,899 --> 00:17:18,569
did happen then that code would look

00:17:15,539 --> 00:17:20,579
pretty similar to ours and I think that

00:17:18,569 --> 00:17:23,549
as developers we are naturally adverse

00:17:20,579 --> 00:17:26,309
to duplication we're obsessed with

00:17:23,549 --> 00:17:28,950
making things super dry and getting rid

00:17:26,309 --> 00:17:31,230
of duplication and so for many of us

00:17:28,950 --> 00:17:33,659
BFFs will feel really counterintuitive

00:17:31,230 --> 00:17:38,669
because duplication is really inherent

00:17:33,659 --> 00:17:41,610
to the pattern so Sam Newman wrote the

00:17:38,669 --> 00:17:43,110
iconic blog post about BFFs if you

00:17:41,610 --> 00:17:46,500
google back-end for front-end patents

00:17:43,110 --> 00:17:48,720
the first result and he said one of the

00:17:46,500 --> 00:17:49,440
concerns of having a single BFF per user

00:17:48,720 --> 00:17:50,759
interface

00:17:49,440 --> 00:17:53,190
is that you can end up with lots of

00:17:50,759 --> 00:17:56,220
duplication between the BFFs themselves

00:17:53,190 --> 00:17:58,470
they men but end up performing the same

00:17:56,220 --> 00:17:59,879
types of aggregation or have the same or

00:17:58,470 --> 00:18:02,700
similar code for interfacing with

00:17:59,879 --> 00:18:04,049
downstream services some people react to

00:18:02,700 --> 00:18:06,269
this by wanting to merge these back

00:18:04,049 --> 00:18:08,759
together and have a general-purpose

00:18:06,269 --> 00:18:10,799
aggregating edge API service but this

00:18:08,759 --> 00:18:12,480
model has proven time and time again to

00:18:10,799 --> 00:18:15,049
lead to highly bloated code with

00:18:12,480 --> 00:18:19,320
multiple concerns squashed together

00:18:15,049 --> 00:18:22,710
damning review and the next query which

00:18:19,320 --> 00:18:24,899
I love is duplication is cheaper than

00:18:22,710 --> 00:18:27,629
the wrong abstraction so this is a quote

00:18:24,899 --> 00:18:28,980
from a developer called Sandi Metz and I

00:18:27,629 --> 00:18:33,059
really love this quote and I think about

00:18:28,980 --> 00:18:34,559
it all the time when I write code and I

00:18:33,059 --> 00:18:36,240
really believe that when we design

00:18:34,559 --> 00:18:38,399
curtain services you should always start

00:18:36,240 --> 00:18:40,799
from a place of duplication wherever

00:18:38,399 --> 00:18:42,360
wherever possible and optimize later

00:18:40,799 --> 00:18:43,769
down the line once you actually have

00:18:42,360 --> 00:18:47,340
validated the need for a particular

00:18:43,769 --> 00:18:50,940
abstraction and can see that it is the

00:18:47,340 --> 00:18:53,429
right one so I'm talking about this

00:18:50,940 --> 00:18:56,700
philosophy of duplication and

00:18:53,429 --> 00:18:59,759
abstraction because ultimately we did go

00:18:56,700 --> 00:19:01,139
on to create an obstruction to try and

00:18:59,759 --> 00:19:03,509
fix some of the duplication that was

00:19:01,139 --> 00:19:05,639
inherent to our BFF but I don't suggest

00:19:03,509 --> 00:19:07,889
you do this without really questioning

00:19:05,639 --> 00:19:10,740
first if your abstraction is really

00:19:07,889 --> 00:19:12,840
necessary or if it is the right one

00:19:10,740 --> 00:19:14,879
so don't build a shed microservice

00:19:12,840 --> 00:19:16,889
before you know that you actually need

00:19:14,879 --> 00:19:21,809
this shared micro service or it is the

00:19:16,889 --> 00:19:26,580
correct micro service so let's talk

00:19:21,809 --> 00:19:29,279
about our BFF version two so early last

00:19:26,580 --> 00:19:31,769
year the question came up of what to do

00:19:29,279 --> 00:19:34,889
with our graph QL API and what the next

00:19:31,769 --> 00:19:36,450
step in our architecture was and we've

00:19:34,889 --> 00:19:40,740
been using our API in production for

00:19:36,450 --> 00:19:42,600
about a year and hear the numbers so

00:19:40,740 --> 00:19:45,629
we're serving 21 different websites with

00:19:42,600 --> 00:19:47,789
this API so folks in cheek use in 10

00:19:45,629 --> 00:19:50,549
different countries and we have about

00:19:47,789 --> 00:19:52,860
200 million users each month across all

00:19:50,549 --> 00:19:56,070
these websites which is a pretty big

00:19:52,860 --> 00:19:59,789
number and I should think about that

00:19:56,070 --> 00:20:03,179
when I deploy my code so our API is

00:19:59,789 --> 00:20:03,420
doing well it's managing to serve the

00:20:03,179 --> 00:20:07,230
new

00:20:03,420 --> 00:20:12,000
of this many uses and applications but

00:20:07,230 --> 00:20:14,549
we felt the need to scale and one of the

00:20:12,000 --> 00:20:16,410
reasons one of the reasons that we felt

00:20:14,549 --> 00:20:19,320
the need to scale is first of all when

00:20:16,410 --> 00:20:22,590
we built our graph QL API in 2018 we

00:20:19,320 --> 00:20:26,010
were kind of like rebels it was cool too

00:20:22,590 --> 00:20:27,990
it was bleeding edge even just two years

00:20:26,010 --> 00:20:31,500
ago graph QL was not as popular as it is

00:20:27,990 --> 00:20:33,030
now and we really what we were doing was

00:20:31,500 --> 00:20:34,500
considered experimental than the

00:20:33,030 --> 00:20:36,720
organization and people were quite

00:20:34,500 --> 00:20:39,510
suspicious of it and we really had to

00:20:36,720 --> 00:20:41,130
prove we had to fight against the

00:20:39,510 --> 00:20:43,200
perception that we were just introducing

00:20:41,130 --> 00:20:46,919
graph QL for vanity reasons that didn't

00:20:43,200 --> 00:20:50,460
actually provide technical value and we

00:20:46,919 --> 00:20:53,910
really yeah we had to prove that what we

00:20:50,460 --> 00:20:55,440
were doing was legit but now in 2020

00:20:53,910 --> 00:20:58,410
it's a very different world for graph QL

00:20:55,440 --> 00:21:01,620
it's taken off usage of graph QL

00:20:58,410 --> 00:21:03,750
skyrocketed and we started hearing from

00:21:01,620 --> 00:21:06,390
other teams at Conde Nast that they also

00:21:03,750 --> 00:21:08,460
wanted to build a graph QL API possibly

00:21:06,390 --> 00:21:11,669
wrapping the exact same API that we had

00:21:08,460 --> 00:21:14,490
already wrapped so yeah people were very

00:21:11,669 --> 00:21:17,610
interested in graph QL

00:21:14,490 --> 00:21:21,120
so we'd wrapped this rest graph QL this

00:21:17,610 --> 00:21:22,860
REST API in graph QL with design schema

00:21:21,120 --> 00:21:26,280
that we really loved and enjoyed using

00:21:22,860 --> 00:21:27,780
just for ourselves but yeah we

00:21:26,280 --> 00:21:30,240
discovered that other people wanted the

00:21:27,780 --> 00:21:31,770
same API wrapped in graph QL and there

00:21:30,240 --> 00:21:33,690
was even one team that did wrap it in

00:21:31,770 --> 00:21:35,370
graph QL and looking at that schema was

00:21:33,690 --> 00:21:38,400
a very eerie experience because it was

00:21:35,370 --> 00:21:40,830
very similar to else and so with this in

00:21:38,400 --> 00:21:42,809
mind it became it became time to think

00:21:40,830 --> 00:21:45,540
seriously about abstracting out that

00:21:42,809 --> 00:21:48,450
commonality between between the

00:21:45,540 --> 00:21:51,500
different teams and builds a shed

00:21:48,450 --> 00:21:55,260
microservice which is when we introduced

00:21:51,500 --> 00:21:58,860
this architecture so we decided to split

00:21:55,260 --> 00:22:01,650
our BFF API into two so first of all

00:21:58,860 --> 00:22:03,870
there's the core content API so it's the

00:22:01,650 --> 00:22:05,910
REST API that we had originally wrapped

00:22:03,870 --> 00:22:09,080
for ourselves but now I made available

00:22:05,910 --> 00:22:11,340
for other teams and applications to use

00:22:09,080 --> 00:22:16,260
but we did still feel that there was a

00:22:11,340 --> 00:22:17,230
need for the BFF sir because I'll the

00:22:16,260 --> 00:22:20,380
BFF

00:22:17,230 --> 00:22:22,720
it represents data more than just

00:22:20,380 --> 00:22:24,190
content so we also had integrations with

00:22:22,720 --> 00:22:26,710
third party API is we had a

00:22:24,190 --> 00:22:29,410
configuration API it's a bunch of other

00:22:26,710 --> 00:22:32,080
stuff in that BFF and so the core

00:22:29,410 --> 00:22:33,520
content API could not single-handedly

00:22:32,080 --> 00:22:36,370
represent all the data needs of our

00:22:33,520 --> 00:22:40,780
application so we decided to keep the

00:22:36,370 --> 00:22:42,010
BFF for now and here's what I'll so this

00:22:40,780 --> 00:22:46,120
is what our architecture looked like

00:22:42,010 --> 00:22:48,750
before we split out the content API so

00:22:46,120 --> 00:22:52,570
you see we have the graph QL BFF and

00:22:48,750 --> 00:22:56,110
here's the change that took place so we

00:22:52,570 --> 00:23:01,090
created this graph QL content API that

00:22:56,110 --> 00:23:03,669
wraps the rest content API and the graph

00:23:01,090 --> 00:23:10,000
QL BFF speaks to this graph QL content

00:23:03,669 --> 00:23:11,890
API that graph QL microservice can now

00:23:10,000 --> 00:23:14,500
be used by other applications in place

00:23:11,890 --> 00:23:16,030
of the REST API so the content

00:23:14,500 --> 00:23:19,240
management system can now be considered

00:23:16,030 --> 00:23:21,880
to have an officially published graph QL

00:23:19,240 --> 00:23:26,290
API that anyone can use which was not

00:23:21,880 --> 00:23:27,610
the case three years ago and a big part

00:23:26,290 --> 00:23:29,559
of the dream of this architecture is

00:23:27,610 --> 00:23:32,020
that we would be consuming graph QL all

00:23:29,559 --> 00:23:34,179
the way down so instead of carrying the

00:23:32,020 --> 00:23:36,910
complexity of wrapping the rest content

00:23:34,179 --> 00:23:44,140
API inside our BFF we've delegated that

00:23:36,910 --> 00:23:47,620
responsibility elsewhere and so this new

00:23:44,140 --> 00:23:49,600
graph QL microservice building it was a

00:23:47,620 --> 00:23:51,610
was a challenge all of its own and I was

00:23:49,600 --> 00:23:53,590
on the team that was building this new

00:23:51,610 --> 00:23:54,880
micro service and I have to say as a

00:23:53,590 --> 00:23:57,070
developer it's quite rather that you're

00:23:54,880 --> 00:23:58,840
given the opportunity to really improve

00:23:57,070 --> 00:24:01,900
upon something that you've built and

00:23:58,840 --> 00:24:04,000
make it available for other people and

00:24:01,900 --> 00:24:05,650
the challenge this time around was to

00:24:04,000 --> 00:24:07,990
ensure that the schema that we had built

00:24:05,650 --> 00:24:09,910
just for our application would be

00:24:07,990 --> 00:24:14,700
generic enough to be used by other

00:24:09,910 --> 00:24:17,740
applications and teams and although this

00:24:14,700 --> 00:24:19,950
this schema is representing pretty much

00:24:17,740 --> 00:24:22,540
the same data as the first time around

00:24:19,950 --> 00:24:24,900
we now have the license to make

00:24:22,540 --> 00:24:28,090
improvements with with hindsight in mind

00:24:24,900 --> 00:24:31,350
so because we have hindsight we can

00:24:28,090 --> 00:24:31,350
ultimately build a better API

00:24:31,739 --> 00:24:37,330
so the final challenge was to integrate

00:24:33,970 --> 00:24:43,450
this BFF integrates this new graph QL

00:24:37,330 --> 00:24:45,539
micro service into our BFF and as a

00:24:43,450 --> 00:24:50,980
reminder this is what our new

00:24:45,539 --> 00:24:52,509
architecture looks like and here's what

00:24:50,980 --> 00:24:54,999
we need in order to integrate with this

00:24:52,509 --> 00:24:57,489
new microservice we need a way to

00:24:54,999 --> 00:25:01,350
forward or proxy content queries through

00:24:57,489 --> 00:25:03,759
to our new content API via the BFF and

00:25:01,350 --> 00:25:06,429
we also need the ability to integrate

00:25:03,759 --> 00:25:08,980
with the new content API incrementally

00:25:06,429 --> 00:25:10,720
because we need to support a production

00:25:08,980 --> 00:25:14,169
application throughout the entire

00:25:10,720 --> 00:25:19,509
process and not break 21 websites

00:25:14,169 --> 00:25:22,049
ideally and there are a couple of

00:25:19,509 --> 00:25:23,830
options for getting graph QL

00:25:22,049 --> 00:25:26,470
micro-services to speak to each other

00:25:23,830 --> 00:25:28,450
the first talk mentioned a polar

00:25:26,470 --> 00:25:32,259
Federation which is the cool new way to

00:25:28,450 --> 00:25:33,850
have graphical micro services so we we

00:25:32,259 --> 00:25:35,710
looked at the different options and the

00:25:33,850 --> 00:25:38,649
polar Federation ID we weren't quite

00:25:35,710 --> 00:25:41,109
ready for it it would can it would take

00:25:38,649 --> 00:25:42,700
a bit of an architectural shift for us I

00:25:41,109 --> 00:25:44,619
won't go into all the details if you're

00:25:42,700 --> 00:25:46,749
interested come and talk to me but

00:25:44,619 --> 00:25:49,480
ultimately what we went with was schema

00:25:46,749 --> 00:25:52,749
delegation which essentially allows you

00:25:49,480 --> 00:25:54,669
to create a reference to a remote schema

00:25:52,749 --> 00:25:58,419
so a schema which lives somewhere else

00:25:54,669 --> 00:26:00,460
and get that schema to resolve resolve

00:25:58,419 --> 00:26:03,070
queries for you for a part of your

00:26:00,460 --> 00:26:06,489
schema so you see we have the BFF schema

00:26:03,070 --> 00:26:08,679
and any queries to the content schema

00:26:06,489 --> 00:26:13,600
get delegated and resolved by the

00:26:08,679 --> 00:26:15,489
content graph QL microservice so this

00:26:13,600 --> 00:26:18,669
approach was a little messy schema

00:26:15,489 --> 00:26:20,200
delegation is not the ideal solution but

00:26:18,669 --> 00:26:23,230
we really wanted a way to get up and

00:26:20,200 --> 00:26:27,279
running quickly and a way to make

00:26:23,230 --> 00:26:29,049
incremental change and possibly replace

00:26:27,279 --> 00:26:34,179
it with something better like a polar

00:26:29,049 --> 00:26:36,249
Federation later down the line and the

00:26:34,179 --> 00:26:39,009
result of all of this is that we have a

00:26:36,249 --> 00:26:42,149
very article which looks exactly the

00:26:39,009 --> 00:26:42,149
same Wow

00:26:42,360 --> 00:26:47,190
but little do you know that beneath the

00:26:44,370 --> 00:26:49,620
surface the data is now coming from a

00:26:47,190 --> 00:26:51,690
different place and the readers might

00:26:49,620 --> 00:26:54,269
not appreciate this while they're

00:26:51,690 --> 00:26:58,140
catching up on the German Fashion Week

00:26:54,269 --> 00:27:00,870
news but behind the scenes developers

00:26:58,140 --> 00:27:03,390
are much happier because they don't have

00:27:00,870 --> 00:27:06,480
to deal with the complexity that was

00:27:03,390 --> 00:27:07,590
being carried in that BFF and also maybe

00:27:06,480 --> 00:27:10,080
now that they don't have to maintain

00:27:07,590 --> 00:27:12,179
that graph QL schema maybe they will

00:27:10,080 --> 00:27:14,250
have more time to work on those features

00:27:12,179 --> 00:27:17,360
that they would actually see and would

00:27:14,250 --> 00:27:19,500
actually make an impact on their lives

00:27:17,360 --> 00:27:22,200
the cavea is that this is still in

00:27:19,500 --> 00:27:24,440
process in progress so the perfect

00:27:22,200 --> 00:27:27,210
fantasy is not quite here yet

00:27:24,440 --> 00:27:30,690
including the additional time to work on

00:27:27,210 --> 00:27:33,720
new feature requests so the process of

00:27:30,690 --> 00:27:36,690
migrating to this new content API is

00:27:33,720 --> 00:27:39,630
currently underway but in the meantime

00:27:36,690 --> 00:27:41,220
and this is quite cool to see several

00:27:39,630 --> 00:27:43,799
other teams within the organization have

00:27:41,220 --> 00:27:45,419
adopted the new graph QL API and is

00:27:43,799 --> 00:27:46,799
starting to use in production so there

00:27:45,419 --> 00:27:55,380
are now three different teams using the

00:27:46,799 --> 00:27:56,460
API which is quite cool so beyond MVP so

00:27:55,380 --> 00:27:58,500
thinking back to what I said earlier

00:27:56,460 --> 00:28:01,230
about graph QL bffs here's what I think

00:27:58,500 --> 00:28:03,059
now about graph QL bffs

00:28:01,230 --> 00:28:06,059
so graph QL is not a like-for-like

00:28:03,059 --> 00:28:07,500
replacement for a BFF but I think that

00:28:06,059 --> 00:28:09,240
it solves enough of the same problems

00:28:07,500 --> 00:28:11,340
that if you evolve your architecture

00:28:09,240 --> 00:28:13,260
towards consuming purely graph your

00:28:11,340 --> 00:28:17,340
micro services you might find that you

00:28:13,260 --> 00:28:18,960
no longer need a BFF and with that in

00:28:17,340 --> 00:28:21,899
mind personally I'd really love to see

00:28:18,960 --> 00:28:24,539
our organization's API architecture move

00:28:21,899 --> 00:28:27,899
towards more of a gateway model which is

00:28:24,539 --> 00:28:31,139
ultimately where the industry is leading

00:28:27,899 --> 00:28:33,210
is as we saw in the first talk so I'd

00:28:31,139 --> 00:28:35,269
like to get to a point where we could

00:28:33,210 --> 00:28:39,029
remove the existing BFF and speak

00:28:35,269 --> 00:28:42,000
directly to conde nast organization-wide

00:28:39,029 --> 00:28:46,139
graph QL gateway that is backed by graph

00:28:42,000 --> 00:28:49,440
QL micro services so I don't want to

00:28:46,139 --> 00:28:50,789
rush the process like this Tuttle I want

00:28:49,440 --> 00:28:52,740
to be thoughtful about how we scale our

00:28:50,789 --> 00:28:55,429
architecture and not create abstractions

00:28:52,740 --> 00:29:00,619
too soon

00:28:55,429 --> 00:29:03,799
and what did I learn festival focus on

00:29:00,619 --> 00:29:05,659
incremental change you might dream of

00:29:03,799 --> 00:29:08,299
having an amazing graph QL gateway of

00:29:05,659 --> 00:29:10,519
micro services to start with but

00:29:08,299 --> 00:29:11,979
unfortunately if you're evolving the

00:29:10,519 --> 00:29:14,559
architecture of a production application

00:29:11,979 --> 00:29:17,779
that's not always where you can start

00:29:14,559 --> 00:29:19,369
and if you build something for too long

00:29:17,779 --> 00:29:21,649
in isolation you might build the wrong

00:29:19,369 --> 00:29:24,559
thing so try and build things

00:29:21,649 --> 00:29:26,149
incrementally think about small areas of

00:29:24,559 --> 00:29:27,799
the schema that you can optimize or pull

00:29:26,149 --> 00:29:31,639
out as a micro service before you pull

00:29:27,799 --> 00:29:34,309
out everything and as the first talk

00:29:31,639 --> 00:29:36,320
also said during optimize to le so we

00:29:34,309 --> 00:29:38,719
could have built a generic API to start

00:29:36,320 --> 00:29:40,849
with but we didn't and I think that we

00:29:38,719 --> 00:29:42,619
ultimately built a better generic API

00:29:40,849 --> 00:29:44,389
because of this because we had a year of

00:29:42,619 --> 00:29:49,639
product weddings that could actually

00:29:44,389 --> 00:29:50,510
make it better and that is the end thank

00:29:49,639 --> 00:29:57,380
you

00:29:50,510 --> 00:29:57,380

YouTube URL: https://www.youtube.com/watch?v=qaQEioKovCg


