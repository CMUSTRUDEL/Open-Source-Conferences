Title: Static Typing Gone Mad - JS Roundabout - September 2018
Publication date: 2018-10-02
Playlist: The JS Roundabout
Description: 
	Presented by Jan Molak - https://janmolak.com

Jan will introduce you to Tiny Types - a mini-pattern and a TypeScript library that can help you design more meaningful domain models for a full-stack distributed system.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:03,810
alright guys so Johnny already tells you

00:00:02,040 --> 00:00:05,430
what type soup it's all about right

00:00:03,810 --> 00:00:07,140
that's pretty was pretty cool so now

00:00:05,430 --> 00:00:09,300
let's think about how we can actually

00:00:07,140 --> 00:00:13,670
take it to a whole new level and make

00:00:09,300 --> 00:00:16,289
your static typing go a little bit mad

00:00:13,670 --> 00:00:18,510
my name is Ian Malik I'm an independent

00:00:16,289 --> 00:00:20,250
consultant and technical coach helping

00:00:18,510 --> 00:00:22,619
teams around the world deliver better

00:00:20,250 --> 00:00:24,810
software now what I really like to do is

00:00:22,619 --> 00:00:27,420
I like to spot things that work I like

00:00:24,810 --> 00:00:29,519
to distill them into patterns and move

00:00:27,420 --> 00:00:31,410
community often in the form of

00:00:29,519 --> 00:00:33,899
open-source projects such as the build

00:00:31,410 --> 00:00:36,809
my turf or Jenkins or serenity Jes my

00:00:33,899 --> 00:00:38,370
acceptance testing framework but tonight

00:00:36,809 --> 00:00:42,690
we won't be talking about any of those

00:00:38,370 --> 00:00:45,690
things instead I would like to introduce

00:00:42,690 --> 00:00:48,510
you to a little design pattern actually

00:00:45,690 --> 00:00:52,379
quite tiny one and excuse my terrible

00:00:48,510 --> 00:00:56,850
pun so have any one of you ever heard

00:00:52,379 --> 00:00:58,910
about tiny types marvelous you're in for

00:00:56,850 --> 00:00:58,910
a treat

00:00:59,570 --> 00:01:02,699
brilliant okay yeah it's pretty much the

00:01:02,160 --> 00:01:06,090
same thing

00:01:02,699 --> 00:01:09,299
so the pattern itself has been around

00:01:06,090 --> 00:01:11,159
for quite a long time so I've learned

00:01:09,299 --> 00:01:13,590
about it from a friend of mine and the

00:01:11,159 --> 00:01:17,549
partner who pointed me to this article

00:01:13,590 --> 00:01:20,070
by mr. Darin Hobbs from 2007 where he

00:01:17,549 --> 00:01:22,890
describes the pattern in well as pretty

00:01:20,070 --> 00:01:25,020
much one-liner so it's basically the

00:01:22,890 --> 00:01:27,210
idea is to encapsulate the simple

00:01:25,020 --> 00:01:30,299
building types such as string or number

00:01:27,210 --> 00:01:33,450
or array for example within

00:01:30,299 --> 00:01:35,790
domain-specific classes now the concept

00:01:33,450 --> 00:01:38,100
itself is not particularly new so I

00:01:35,790 --> 00:01:40,799
managed to trace it back all the way to

00:01:38,100 --> 00:01:44,310
around what 1994 which is like ages ago

00:01:40,799 --> 00:01:47,399
in the JavaScript space where what

00:01:44,310 --> 00:01:49,020
cunningham described it on the c2 wiki

00:01:47,399 --> 00:01:50,790
so that was the one for the chrysler

00:01:49,020 --> 00:01:53,579
project one of the very significant ones

00:01:50,790 --> 00:01:55,680
in there in the address space now Eric

00:01:53,579 --> 00:01:58,729
Evans describes a very similar idea in

00:01:55,680 --> 00:02:01,860
his book from 2003 domain driven design

00:01:58,729 --> 00:02:03,149
now von Vernon talks about it as well

00:02:01,860 --> 00:02:06,030
same as Martin Fowler

00:02:03,149 --> 00:02:07,829
so you think about it if this pattern is

00:02:06,030 --> 00:02:11,670
so simple why would so many people

00:02:07,829 --> 00:02:15,580
actually describe it yes that's one line

00:02:11,670 --> 00:02:17,440
but what's really cool about tiny types

00:02:15,580 --> 00:02:19,930
is even though the pattern itself is

00:02:17,440 --> 00:02:23,560
quite tiny the benefits of using it can

00:02:19,930 --> 00:02:25,780
be quite huge but the patent is owned

00:02:23,560 --> 00:02:27,520
patents on their own are great but what

00:02:25,780 --> 00:02:29,200
really matters is how we actually apply

00:02:27,520 --> 00:02:32,590
them how you implement them yeah so

00:02:29,200 --> 00:02:38,050
let's talk about tiny types using a

00:02:32,590 --> 00:02:40,780
concrete example so let's say we wanted

00:02:38,050 --> 00:02:42,370
to implement a say online banking

00:02:40,780 --> 00:02:44,680
platform I tend to work a lot with with

00:02:42,370 --> 00:02:48,340
clients in the financial space so it's

00:02:44,680 --> 00:02:50,170
quite a family your domain to me so

00:02:48,340 --> 00:02:52,390
let's say we want to enable our

00:02:50,170 --> 00:02:56,320
customers to be able to make payments

00:02:52,390 --> 00:02:57,820
online crazy functionality right so what

00:02:56,320 --> 00:02:59,290
we need to do is we need to build some

00:02:57,820 --> 00:03:01,989
sort of front-end probably you know to

00:02:59,290 --> 00:03:04,030
capture the data about about the payment

00:03:01,989 --> 00:03:07,180
about the accounts and so on send it to

00:03:04,030 --> 00:03:09,580
the bike back-end and process it so at

00:03:07,180 --> 00:03:13,600
some point we'll probably to write a

00:03:09,580 --> 00:03:19,540
function along those lines yeah make a

00:03:13,600 --> 00:03:22,540
payment from to reference amount so

00:03:19,540 --> 00:03:26,079
here's a quiz for you if you need to

00:03:22,540 --> 00:03:27,970
call this function from your code what

00:03:26,079 --> 00:03:37,260
will be the format of arguments easy to

00:03:27,970 --> 00:03:42,820
provide it's not that obvious is it here

00:03:37,260 --> 00:03:44,410
not at all no what often happens when we

00:03:42,820 --> 00:03:46,570
when we write code is certain with the

00:03:44,410 --> 00:03:48,670
intention is very clear to us when we

00:03:46,570 --> 00:03:51,459
write it but it's not at all clear to

00:03:48,670 --> 00:03:53,140
the readers of this code and quite often

00:03:51,459 --> 00:03:57,310
those readers of the same code could be

00:03:53,140 --> 00:03:59,530
asked as a few months later so now what

00:03:57,310 --> 00:04:01,600
is the from what is the to all those the

00:03:59,530 --> 00:04:05,200
account details the Iban number the

00:04:01,600 --> 00:04:06,459
address well it's hard to tell even the

00:04:05,200 --> 00:04:08,440
reference yeah oh that could probably be

00:04:06,459 --> 00:04:12,430
could be quite simple probably a string

00:04:08,440 --> 00:04:15,220
maybe what we not sure now my absolute

00:04:12,430 --> 00:04:17,859
favorite the amount was this number a

00:04:15,220 --> 00:04:21,220
string a string in what format hell

00:04:17,859 --> 00:04:23,740
knows so let's use typescript to make

00:04:21,220 --> 00:04:24,580
some magic happen and make it all way

00:04:23,740 --> 00:04:26,979
better

00:04:24,580 --> 00:04:30,939
and we introduce types and now we've got

00:04:26,979 --> 00:04:33,520
oh I'm so sorry didn't quite go as well

00:04:30,939 --> 00:04:35,500
as planned so you see even though we've

00:04:33,520 --> 00:04:37,990
got types here that didn't really help

00:04:35,500 --> 00:04:40,479
much yeah everything is still a string

00:04:37,990 --> 00:04:43,509
so we've kind of captured the types of

00:04:40,479 --> 00:04:45,969
the primitives here but what we didn't

00:04:43,509 --> 00:04:47,650
do is we didn't capture the opportunity

00:04:45,969 --> 00:04:49,689
to actually express our intent clearly

00:04:47,650 --> 00:04:52,000
to help the developers who'll be working

00:04:49,689 --> 00:04:53,409
with this code well we're actually not

00:04:52,000 --> 00:04:55,960
being too nice to the compiler either

00:04:53,409 --> 00:04:57,520
because if we just mark a property as a

00:04:55,960 --> 00:04:59,590
string the compiler won't be able to

00:04:57,520 --> 00:05:01,419
help us they still very easy to make

00:04:59,590 --> 00:05:05,020
silly mistakes I get the order of

00:05:01,419 --> 00:05:07,000
parameters wrong yeah I could quite

00:05:05,020 --> 00:05:12,219
easily he confused the reference with an

00:05:07,000 --> 00:05:16,050
amount so how about you actually give

00:05:12,219 --> 00:05:20,500
typescript a chance to help us how about

00:05:16,050 --> 00:05:23,949
we try to capture those domain concepts

00:05:20,500 --> 00:05:27,279
and treat them as first-class citizens

00:05:23,949 --> 00:05:29,440
in our system how about we expressed it

00:05:27,279 --> 00:05:31,060
from us no player account details now

00:05:29,440 --> 00:05:34,930
it's quite clear yeah you know what it

00:05:31,060 --> 00:05:36,669
is the - hey account details now the

00:05:34,930 --> 00:05:38,740
first benefit straightaway is that well

00:05:36,669 --> 00:05:41,080
we can't rican fuse the from in the two

00:05:38,740 --> 00:05:43,180
account numbers it's so at least I'd

00:05:41,080 --> 00:05:46,690
better look at the same thing for the

00:05:43,180 --> 00:05:49,569
payment reference same for the money now

00:05:46,690 --> 00:05:51,909
with this approach the intent becomes

00:05:49,569 --> 00:05:53,409
much more clear so much more obvious

00:05:51,909 --> 00:05:55,150
what we would be as an implement of this

00:05:53,409 --> 00:05:57,250
method intended to Express

00:05:55,150 --> 00:05:59,650
we also provide additional help to the

00:05:57,250 --> 00:06:01,389
compiler now if think about it if you

00:05:59,650 --> 00:06:02,770
wanted to refactor and change the name

00:06:01,389 --> 00:06:04,150
of this class for you just use your

00:06:02,770 --> 00:06:07,389
tools here the compiled compiler can

00:06:04,150 --> 00:06:09,039
very easy support you on the other hand

00:06:07,389 --> 00:06:11,080
if you had tried to find usages of a

00:06:09,039 --> 00:06:12,569
string in a large code base you know

00:06:11,080 --> 00:06:16,120
what I'm talking about

00:06:12,569 --> 00:06:17,229
so another good thing about this is that

00:06:16,120 --> 00:06:19,000
you know we could use those two main

00:06:17,229 --> 00:06:21,069
types on both front end and back end

00:06:19,000 --> 00:06:22,750
because actually reuse the same code we

00:06:21,069 --> 00:06:27,339
could take full advantage of using the

00:06:22,750 --> 00:06:29,500
same language in in those two places so

00:06:27,339 --> 00:06:33,550
how do we actually implement those those

00:06:29,500 --> 00:06:35,860
tiny types so the way I'd like to do

00:06:33,550 --> 00:06:36,820
this I like to implement those things us

00:06:35,860 --> 00:06:41,350
as classes

00:06:36,820 --> 00:06:44,080
and I'll explain that in explain why in

00:06:41,350 --> 00:06:46,270
in a second so here you see at the

00:06:44,080 --> 00:06:48,370
payment reference for example is just a

00:06:46,270 --> 00:06:49,840
really lightweight wrapper around the

00:06:48,370 --> 00:06:53,290
string just an object

00:06:49,840 --> 00:06:55,690
take the string in so how would we

00:06:53,290 --> 00:06:57,040
implement it well the probably creative

00:06:55,690 --> 00:06:59,080
class would call them payment reference

00:06:57,040 --> 00:07:00,670
to capture the domain meaning would

00:06:59,080 --> 00:07:03,070
create a single argument constructor

00:07:00,670 --> 00:07:06,120
that takes a reference drink assigns it

00:07:03,070 --> 00:07:10,180
to a field so what's so cool about it

00:07:06,120 --> 00:07:12,010
absolutely nothing what we can actually

00:07:10,180 --> 00:07:15,430
do with this one is we can actually a

00:07:12,010 --> 00:07:18,790
capture couple of opportunities so first

00:07:15,430 --> 00:07:22,540
of all we could make our object unit a

00:07:18,790 --> 00:07:25,150
book and there's a nice modifier in

00:07:22,540 --> 00:07:27,370
typescript code called read-only if we

00:07:25,150 --> 00:07:28,830
mark our fields as read-only it means

00:07:27,370 --> 00:07:30,850
that they cannot be changed or

00:07:28,830 --> 00:07:33,880
reassigned after the objects already

00:07:30,850 --> 00:07:36,390
being constructed now there's other

00:07:33,880 --> 00:07:40,510
little trick we can use so types treat

00:07:36,390 --> 00:07:42,580
allows you to specify the parameters as

00:07:40,510 --> 00:07:45,370
properties when you create the object so

00:07:42,580 --> 00:07:47,500
this syntax here will define a class

00:07:45,370 --> 00:07:50,020
that has one field called reference

00:07:47,500 --> 00:07:52,060
that's also immutable so as you can see

00:07:50,020 --> 00:07:56,770
here I can actually express this type in

00:07:52,060 --> 00:07:59,170
just a few lines of code but that's not

00:07:56,770 --> 00:08:02,440
the main benefit of of tiny types or

00:07:59,170 --> 00:08:06,300
micro types one thing that this can give

00:08:02,440 --> 00:08:09,450
you there is an opportunity to introduce

00:08:06,300 --> 00:08:12,430
consolidated validation big words here

00:08:09,450 --> 00:08:14,050
so think about all the different places

00:08:12,430 --> 00:08:17,970
in your system where you need to

00:08:14,050 --> 00:08:20,230
validate data very big user input okay

00:08:17,970 --> 00:08:21,580
so when you think about validation we

00:08:20,230 --> 00:08:23,380
often think about the user interface

00:08:21,580 --> 00:08:26,050
obviously you know someone enters the

00:08:23,380 --> 00:08:27,940
value deform we have to violate it but

00:08:26,050 --> 00:08:30,970
all about the what about all the other

00:08:27,940 --> 00:08:33,340
places where we need to read some some

00:08:30,970 --> 00:08:36,340
value for from a CSV file or from Jason

00:08:33,340 --> 00:08:38,169
where we got the HTTP API that receives

00:08:36,340 --> 00:08:39,820
a JSON payload over the wire from a

00:08:38,169 --> 00:08:41,830
message bus there's quite a few places

00:08:39,820 --> 00:08:44,500
were actually to make sure that whatever

00:08:41,830 --> 00:08:47,710
data would be sent is valid that we can

00:08:44,500 --> 00:08:49,660
use it so think about all the different

00:08:47,710 --> 00:08:51,810
very data type we've got in our code

00:08:49,660 --> 00:08:51,810
base

00:08:52,890 --> 00:08:58,990
now how could you improve that so let's

00:08:57,850 --> 00:09:01,990
think about this whole payment reference

00:08:58,990 --> 00:09:03,520
for a minute so right now the payment

00:09:01,990 --> 00:09:06,490
reference I just lighted right with

00:09:03,520 --> 00:09:09,990
wrapper around this drink but now is

00:09:06,490 --> 00:09:14,320
payment reference really just any string

00:09:09,990 --> 00:09:16,779
well it's not right for example but it

00:09:14,320 --> 00:09:18,670
has to be defined yeah it could be empty

00:09:16,779 --> 00:09:19,540
but has to be defined if we get a null

00:09:18,670 --> 00:09:22,320
or an undefined

00:09:19,540 --> 00:09:26,260
that's not invalid state of our system

00:09:22,320 --> 00:09:27,670
also in in most banking systems those

00:09:26,260 --> 00:09:30,160
payment references they can't be longer

00:09:27,670 --> 00:09:31,390
than 18 characters so if we ever get a

00:09:30,160 --> 00:09:34,240
value that's longer than 80 characters

00:09:31,390 --> 00:09:35,920
does not divide state either so what we

00:09:34,240 --> 00:09:38,470
could do if we represented those

00:09:35,920 --> 00:09:41,500
concepts as as classes we could actually

00:09:38,470 --> 00:09:45,130
implement a validation right there in

00:09:41,500 --> 00:09:47,050
the constructor what this gives us is an

00:09:45,130 --> 00:09:49,660
opportunity to ensure runtime

00:09:47,050 --> 00:09:51,130
correctness of our system it's virtually

00:09:49,660 --> 00:09:53,350
impossible to construct an invalid

00:09:51,130 --> 00:09:59,140
payment reference because this thing

00:09:53,350 --> 00:10:01,060
will throw an exception or error now we

00:09:59,140 --> 00:10:03,940
could apply the same logic to composite

00:10:01,060 --> 00:10:06,100
types so you remember I told you about

00:10:03,940 --> 00:10:07,540
money being one of my absolute favorite

00:10:06,100 --> 00:10:09,850
types because it's just represented this

00:10:07,540 --> 00:10:15,130
represented so many different ways in so

00:10:09,850 --> 00:10:17,260
many different systems now in 2003 in

00:10:15,130 --> 00:10:20,589
his book really called patterns of

00:10:17,260 --> 00:10:22,480
enterprise architecture of enterprise

00:10:20,589 --> 00:10:24,640
application architecture Fowler proposed

00:10:22,480 --> 00:10:26,709
that money should be represented as a

00:10:24,640 --> 00:10:29,050
composite type of amount and currency

00:10:26,709 --> 00:10:30,970
now we could do this quite easily with

00:10:29,050 --> 00:10:32,950
tiny types here I've defined a class

00:10:30,970 --> 00:10:35,350
called money it's called two properties

00:10:32,950 --> 00:10:38,680
amount and currency and they both have

00:10:35,350 --> 00:10:41,770
their own respective types now I could

00:10:38,680 --> 00:10:43,750
also say that it's incorrect in my

00:10:41,770 --> 00:10:45,550
system to have a representation of money

00:10:43,750 --> 00:10:47,230
that doesn't have currency or an amount

00:10:45,550 --> 00:10:52,570
they both have to be present in order

00:10:47,230 --> 00:10:54,520
for this thing to work now this gives me

00:10:52,570 --> 00:10:56,470
another opportunity if I describe the

00:10:54,520 --> 00:10:58,660
amount of a separate type I could say us

00:10:56,470 --> 00:11:01,720
its invited in my system to have a

00:10:58,660 --> 00:11:03,699
negative amount of money for instance so

00:11:01,720 --> 00:11:05,829
well the input this logic

00:11:03,699 --> 00:11:09,579
oh I'm good a class for that that's

00:11:05,829 --> 00:11:11,769
quite easy now if we decide to use this

00:11:09,579 --> 00:11:13,720
sort of pattern and then use those

00:11:11,769 --> 00:11:15,639
classes consistently on both front and

00:11:13,720 --> 00:11:17,799
back enter whatever micro services we

00:11:15,639 --> 00:11:19,329
are using then it's almost impossible

00:11:17,799 --> 00:11:21,939
for the entire system to ever be in

00:11:19,329 --> 00:11:26,589
invalid state which is quite big if you

00:11:21,939 --> 00:11:28,119
think about it but that's not just that

00:11:26,589 --> 00:11:29,970
nothing not only about throwing the

00:11:28,119 --> 00:11:32,679
arrows

00:11:29,970 --> 00:11:34,779
another thing that time types give us is

00:11:32,679 --> 00:11:38,589
a natural place to put the low-level

00:11:34,779 --> 00:11:40,239
domain logic okay so think about this

00:11:38,589 --> 00:11:44,169
this whole class of money again

00:11:40,239 --> 00:11:46,499
what about low-level operations like

00:11:44,169 --> 00:11:49,259
adding or subtracting here or

00:11:46,499 --> 00:11:51,910
calculating a percentage discount

00:11:49,259 --> 00:11:52,089
where should we pull it well there you

00:11:51,910 --> 00:11:54,220
go

00:11:52,089 --> 00:11:55,449
that's your place no now I'm gonna need

00:11:54,220 --> 00:11:57,189
to put it in some sort of a separate

00:11:55,449 --> 00:11:59,319
validator or data service or anything

00:11:57,189 --> 00:12:03,309
like that that's my domain type that's

00:11:59,319 --> 00:12:06,189
its logic the metals themselves can

00:12:03,309 --> 00:12:10,959
benefit from rotation as well so for

00:12:06,189 --> 00:12:13,089
example we could say that it's

00:12:10,959 --> 00:12:17,289
impossible in our system to add two

00:12:13,089 --> 00:12:19,720
amounts in different currencies so this

00:12:17,289 --> 00:12:21,369
way we can build very strict domain

00:12:19,720 --> 00:12:24,609
models that are particularly well suited

00:12:21,369 --> 00:12:29,429
to domains that actually care about snow

00:12:24,609 --> 00:12:32,079
being correct like functional space now

00:12:29,429 --> 00:12:33,999
if you see the trick are you used here

00:12:32,079 --> 00:12:36,429
I'm actually still using immutable

00:12:33,999 --> 00:12:38,379
objects so when you add one instance of

00:12:36,429 --> 00:12:40,059
money to another I'm just returning a

00:12:38,379 --> 00:12:42,879
new instance so all my instances are

00:12:40,059 --> 00:12:45,189
immutable now the cool thing about this

00:12:42,879 --> 00:12:46,720
is that no systems of relying on

00:12:45,189 --> 00:12:48,850
immutable data structures are much

00:12:46,720 --> 00:12:51,459
easier to reason about the much easier

00:12:48,850 --> 00:12:54,389
to debug there there's no no mutation of

00:12:51,459 --> 00:12:54,389
state anywhere yeah

00:12:54,770 --> 00:12:57,890
well you can also do those things you

00:12:56,630 --> 00:13:00,700
can send them over the wire you can

00:12:57,890 --> 00:13:04,310
reuse them in front and back and so on

00:13:00,700 --> 00:13:06,560
no I tend to use this pattern quite

00:13:04,310 --> 00:13:08,959
often I mean I've used it in in Java in

00:13:06,560 --> 00:13:11,570
Scala in JavaScript and recently in

00:13:08,959 --> 00:13:13,670
typescript and some languages are

00:13:11,570 --> 00:13:15,770
obviously more better suited for it than

00:13:13,670 --> 00:13:19,370
others yes I am looking at your Java

00:13:15,770 --> 00:13:22,850
with 40 lines of code per type yeah

00:13:19,370 --> 00:13:26,149
exactly so what I did in typescript I'll

00:13:22,850 --> 00:13:28,010
create a little library so you can

00:13:26,149 --> 00:13:31,540
implement this pattern with no libraries

00:13:28,010 --> 00:13:34,760
whatsoever you don't have to use it so

00:13:31,540 --> 00:13:36,589
the one I created has no dependencies it

00:13:34,760 --> 00:13:41,589
was a fairly decent cold coverage and so

00:13:36,589 --> 00:13:44,240
on so what does this thing give you I

00:13:41,589 --> 00:13:45,770
notice that no I actually to do this

00:13:44,240 --> 00:13:47,750
whole validation of stating quite a few

00:13:45,770 --> 00:13:51,980
places I do in constructors I do in in

00:13:47,750 --> 00:13:54,470
methods so I created predicates what

00:13:51,980 --> 00:13:55,970
predicates are they are a little DSL a

00:13:54,470 --> 00:13:58,279
little domain-specific language that

00:13:55,970 --> 00:14:02,089
allow me to express their constraints

00:13:58,279 --> 00:14:04,579
around specific domain objects or

00:14:02,089 --> 00:14:05,959
specific item types so if you run this

00:14:04,579 --> 00:14:09,110
whole payment reference from the earlier

00:14:05,959 --> 00:14:11,570
example here I've replaced my bunch of

00:14:09,110 --> 00:14:13,279
if statements this will ensure about so

00:14:11,570 --> 00:14:15,260
here I say at work I want to ensure that

00:14:13,279 --> 00:14:17,600
the reference is defined that was the

00:14:15,260 --> 00:14:20,810
property of length that's less than 18

00:14:17,600 --> 00:14:22,670
now all this stuff is typesafe so I

00:14:20,810 --> 00:14:24,380
wouldn't be able to say in my DSL that

00:14:22,670 --> 00:14:25,820
the length is less than another string

00:14:24,380 --> 00:14:30,160
you actually verifies that this is a

00:14:25,820 --> 00:14:33,140
number now what this gives me it also

00:14:30,160 --> 00:14:35,630
produces quite sensible error messages

00:14:33,140 --> 00:14:38,360
for example if I want to create a

00:14:35,630 --> 00:14:41,649
payment reference with no argument I'll

00:14:38,360 --> 00:14:44,060
get an error reference should be defined

00:14:41,649 --> 00:14:45,950
if I try to put too many characters

00:14:44,060 --> 00:14:48,050
well reference would have a language

00:14:45,950 --> 00:14:49,970
less than 18 and so on and it's very

00:14:48,050 --> 00:14:53,649
easy to extend those predicates with the

00:14:49,970 --> 00:14:53,649
ones you you need for your domain

00:14:56,340 --> 00:15:00,090
so let's talk about comparing those

00:14:58,620 --> 00:15:01,770
values because one of the things with

00:15:00,090 --> 00:15:03,240
representing those primitive types as

00:15:01,770 --> 00:15:04,590
compressible how do you actually compare

00:15:03,240 --> 00:15:06,570
them here because you can no longer use

00:15:04,590 --> 00:15:08,490
the triple equals operator that will not

00:15:06,570 --> 00:15:10,560
work because that compares objects by

00:15:08,490 --> 00:15:13,350
reference here we want to compare them

00:15:10,560 --> 00:15:19,290
by value just a slightly different thing

00:15:13,350 --> 00:15:21,660
so what I do here is I I use a little

00:15:19,290 --> 00:15:24,510
equals function that comes with the time

00:15:21,660 --> 00:15:26,850
types library so what this thing does it

00:15:24,510 --> 00:15:28,529
will go from four all the significant

00:15:26,850 --> 00:15:30,390
fields so to throw the different number

00:15:28,529 --> 00:15:32,339
fields of your objects and then compare

00:15:30,390 --> 00:15:36,000
those things by value rather than by

00:15:32,339 --> 00:15:38,430
reference now if you don't like

00:15:36,000 --> 00:15:39,690
extending any framework classes you

00:15:38,430 --> 00:15:41,490
don't have to you can just go grab a

00:15:39,690 --> 00:15:43,980
function and use that an existing type

00:15:41,490 --> 00:15:45,300
if you prefer to have less boilerplate

00:15:43,980 --> 00:15:48,500
you can just say that this particular

00:15:45,300 --> 00:15:53,970
type extends tiny type and you get the

00:15:48,500 --> 00:15:55,740
equals function now the way the equals

00:15:53,970 --> 00:15:58,800
function works is let me show you an

00:15:55,740 --> 00:16:02,100
example so here you see I'm creating two

00:15:58,800 --> 00:16:04,290
different objects so I creating too many

00:16:02,100 --> 00:16:07,950
objects both of them have an amount both

00:16:04,290 --> 00:16:09,960
of them are the currency so I can

00:16:07,950 --> 00:16:11,550
actually compile them and the equal

00:16:09,960 --> 00:16:13,320
functions will go recursively through

00:16:11,550 --> 00:16:16,200
them comparing the different properties

00:16:13,320 --> 00:16:18,050
to ensure that both values are are the

00:16:16,200 --> 00:16:22,110
same

00:16:18,050 --> 00:16:24,270
now what about this realization another

00:16:22,110 --> 00:16:25,560
thing we were building distributed

00:16:24,270 --> 00:16:28,200
system so especially in the

00:16:25,560 --> 00:16:30,870
microservices era is how do we actually

00:16:28,200 --> 00:16:32,430
send the a given object over the wire

00:16:30,870 --> 00:16:33,810
how do we ensure that now it remains

00:16:32,430 --> 00:16:34,350
intact that we know serialize and

00:16:33,810 --> 00:16:40,430
deserialize

00:16:34,350 --> 00:16:43,140
correctly so the typical way to do it in

00:16:40,430 --> 00:16:45,089
in our JavaScript world is to our the to

00:16:43,140 --> 00:16:48,180
jason methods on those classes you can

00:16:45,089 --> 00:16:51,360
do it as well now what you can see I'm

00:16:48,180 --> 00:16:53,490
doing here is basically the JSON method

00:16:51,360 --> 00:16:55,650
from the time type will go through all

00:16:53,490 --> 00:16:57,150
the different member fields and if you

00:16:55,650 --> 00:16:59,490
remember if it happens to be a class and

00:16:57,150 --> 00:17:01,560
by being just one primitive it will

00:16:59,490 --> 00:17:03,209
realize it to that one primitive so you

00:17:01,560 --> 00:17:04,490
get a fairly nice and clean jason

00:17:03,209 --> 00:17:08,720
structures

00:17:04,490 --> 00:17:11,530
of this implementation but I think the

00:17:08,720 --> 00:17:14,980
one I'm actually most most happy with is

00:17:11,530 --> 00:17:18,980
no more object object if you ever try to

00:17:14,980 --> 00:17:19,820
console.log a type in JavaScript you

00:17:18,980 --> 00:17:25,040
know what I'm talking about

00:17:19,820 --> 00:17:26,180
yeah I see some smiles brilliant so

00:17:25,040 --> 00:17:27,410
that's actually one one of the first

00:17:26,180 --> 00:17:30,080
things I ever faced

00:17:27,410 --> 00:17:32,690
so what this one does it will actually

00:17:30,080 --> 00:17:34,430
again go through through all your

00:17:32,690 --> 00:17:38,020
significant fields figure out the types

00:17:34,430 --> 00:17:40,460
and tell you what whether the values are

00:17:38,020 --> 00:17:42,320
but I came across another interesting

00:17:40,460 --> 00:17:45,590
use case for the functionality of

00:17:42,320 --> 00:17:49,910
writing to string GDP our data

00:17:45,590 --> 00:17:53,030
protection so if we represent it let's

00:17:49,910 --> 00:17:54,590
say a card number as a time type we

00:17:53,030 --> 00:17:56,750
could override the tostring method on it

00:17:54,590 --> 00:18:00,700
we could ensure that whenever we print

00:17:56,750 --> 00:18:00,700
someone's card number we always mask it

00:18:01,840 --> 00:18:06,260
so there's a quite a surprising use case

00:18:04,520 --> 00:18:11,900
that one of my students came up with a

00:18:06,260 --> 00:18:14,120
recent project which is pretty cool okay

00:18:11,900 --> 00:18:18,050
so let's talk about the big benefits of

00:18:14,120 --> 00:18:20,660
tiny types I think one of my favorites

00:18:18,050 --> 00:18:22,790
is there is a clarity of intent I really

00:18:20,660 --> 00:18:25,160
like being able to use the full power of

00:18:22,790 --> 00:18:27,830
the Type C to express what I meant by

00:18:25,160 --> 00:18:31,790
the specific piece of code and I like

00:18:27,830 --> 00:18:33,710
the code to be obvious to me as well now

00:18:31,790 --> 00:18:35,810
if think about it that the code that you

00:18:33,710 --> 00:18:37,580
write is much more often read then it is

00:18:35,810 --> 00:18:43,220
written so it's actually quite important

00:18:37,580 --> 00:18:45,380
to optimize it for readability but a

00:18:43,220 --> 00:18:46,670
tooling support I mean good compilers

00:18:45,380 --> 00:18:48,890
actually pretty amazing you know tools

00:18:46,670 --> 00:18:51,050
like the visual studio code or IntelliJ

00:18:48,890 --> 00:18:52,970
or or or webstorm they're very good at

00:18:51,050 --> 00:18:54,230
supporting our development efforts but

00:18:52,970 --> 00:18:56,240
we need to help them out a little bit as

00:18:54,230 --> 00:18:58,130
well if we just represent our types of

00:18:56,240 --> 00:19:03,710
strings and numbers they won't be able

00:18:58,130 --> 00:19:04,730
to do as good of a job usability so I

00:19:03,710 --> 00:19:07,270
like to ensure that all the data

00:19:04,730 --> 00:19:11,440
structures I work with are immutable and

00:19:07,270 --> 00:19:11,440
this pattern helps me that as well

00:19:12,270 --> 00:19:18,690
the validation is quite a big plus as

00:19:14,670 --> 00:19:20,430
well so this way I ensure that it's

00:19:18,690 --> 00:19:23,310
impossible in my system to construct an

00:19:20,430 --> 00:19:24,930
invalid type this means that if I use

00:19:23,310 --> 00:19:27,240
the same classes on both front end and

00:19:24,930 --> 00:19:31,520
back end all the different parts of my

00:19:27,240 --> 00:19:34,020
system ensure that the type is correct

00:19:31,520 --> 00:19:36,060
and the better encapsulation so let's

00:19:34,020 --> 00:19:38,820
think about this one for a moment so

00:19:36,060 --> 00:19:40,800
let's say I wanted to suddenly change

00:19:38,820 --> 00:19:44,430
how I represent money in my system from

00:19:40,800 --> 00:19:47,640
a number to a string or you use a new

00:19:44,430 --> 00:19:50,280
library like a big number or bjs what

00:19:47,640 --> 00:19:52,860
would I do it well if I had a type

00:19:50,280 --> 00:19:55,260
representing the amount I could just no

00:19:52,860 --> 00:19:56,340
use no big J s under the hood right easy

00:19:55,260 --> 00:20:00,210
right I don't have to change the

00:19:56,340 --> 00:20:02,460
interface of my clients are using so it

00:20:00,210 --> 00:20:04,680
gives us know quite a few opportunities

00:20:02,460 --> 00:20:07,680
that can help us build you know better

00:20:04,680 --> 00:20:14,370
more reliable systems that express their

00:20:07,680 --> 00:20:15,830
intent in a much cleaner manner thank

00:20:14,370 --> 00:20:21,800
you so much for your attention

00:20:15,830 --> 00:20:21,800

YouTube URL: https://www.youtube.com/watch?v=u1az7XNPCPk


