Title: The JS Roundabout, Time to React to Testing, January 2018
Publication date: 2018-01-31
Playlist: The JS Roundabout
Description: 
	Talk presented by ClÃ©ment Pasteau & Ben Ellerby (Theodo).

More about The JS Roundabout: https://www.meetup.com/The-JS-Roundabout
Captions: 
	00:00:00,000 --> 00:00:03,750
hi yes so and I'm bandhas Clem um we're

00:00:02,370 --> 00:00:05,940
software developers working at Theodore

00:00:03,750 --> 00:00:07,170
which is a start-up working with other

00:00:05,940 --> 00:00:09,210
startups to build products really

00:00:07,170 --> 00:00:11,190
quickly and for large corporates to work

00:00:09,210 --> 00:00:12,630
it sort of startup speed as we are from

00:00:11,190 --> 00:00:14,400
working quite fast to develop new

00:00:12,630 --> 00:00:15,540
products testing 20 points to make sure

00:00:14,400 --> 00:00:17,190
we're not breaking the features we're

00:00:15,540 --> 00:00:19,650
building and as things work once we

00:00:17,190 --> 00:00:21,390
leave the project so we like to think of

00:00:19,650 --> 00:00:23,100
testing sort of as a pyramid as lots of

00:00:21,390 --> 00:00:24,930
people do so going from the bottom which

00:00:23,100 --> 00:00:27,359
is the least complex more libery applied

00:00:24,930 --> 00:00:29,550
stuff like static analysis to the top

00:00:27,359 --> 00:00:30,960
where the more complex end-to-end tests

00:00:29,550 --> 00:00:32,940
which take a lot of time to writes but

00:00:30,960 --> 00:00:34,829
you need on your critical paths so we

00:00:32,940 --> 00:00:36,660
start in react switch the talk is about

00:00:34,829 --> 00:00:39,870
what your purposes are said so testing

00:00:36,660 --> 00:00:42,149
and reacts static analysis we use flow

00:00:39,870 --> 00:00:44,760
and es Lintz flow for type checking and

00:00:42,149 --> 00:00:46,469
es lint for style checking then up to UI

00:00:44,760 --> 00:00:48,360
regression tests so checking that things

00:00:46,469 --> 00:00:50,910
don't disappear from the front end where

00:00:48,360 --> 00:00:52,770
we use jess snapshot tests up to unit

00:00:50,910 --> 00:00:54,930
tests which again we use jest which is a

00:00:52,770 --> 00:00:57,329
tester on a certain library and snapshot

00:00:54,930 --> 00:00:59,129
tool from Facebook to run our unit tests

00:00:57,329 --> 00:01:00,989
traditional and once where we actually

00:00:59,129 --> 00:01:03,270
mount components and play with the UI

00:01:00,989 --> 00:01:08,189
and then for the end-to-end tests we use

00:01:03,270 --> 00:01:09,930
WD i/o or also Nightwatch to run a

00:01:08,189 --> 00:01:12,450
selenium server and actually simulate

00:01:09,930 --> 00:01:15,090
actions on a browser for those complex

00:01:12,450 --> 00:01:16,860
paths that we want to check work so

00:01:15,090 --> 00:01:20,040
starting from the bottom up static

00:01:16,860 --> 00:01:21,390
analysis normally in JavaScript is quite

00:01:20,040 --> 00:01:24,090
a liberal language we're used to

00:01:21,390 --> 00:01:26,939
catching problems in runtime or in code

00:01:24,090 --> 00:01:29,340
review or on production but we can fail

00:01:26,939 --> 00:01:30,900
earlier fail faster by using static

00:01:29,340 --> 00:01:33,479
analysis tools to build upon the type

00:01:30,900 --> 00:01:36,509
checking in JavaScript and also more

00:01:33,479 --> 00:01:38,159
enforcement on what syntax is allowed so

00:01:36,509 --> 00:01:40,500
it class example adding a number to a

00:01:38,159 --> 00:01:41,970
string it works in JavaScript but you

00:01:40,500 --> 00:01:45,659
shouldn't be able to make 12 from one

00:01:41,970 --> 00:01:47,430
and two so when it comes to static

00:01:45,659 --> 00:01:50,159
analysis what are your options and you

00:01:47,430 --> 00:01:51,689
can check a style you can make sure that

00:01:50,159 --> 00:01:52,979
you're not building very complex code so

00:01:51,689 --> 00:01:54,420
you don't have too many variables don't

00:01:52,979 --> 00:01:56,340
have so many too many nested if

00:01:54,420 --> 00:01:58,049
statements you can get rid of code

00:01:56,340 --> 00:02:00,479
duplication by making sure that it's

00:01:58,049 --> 00:02:01,829
detected and fails you're built and then

00:02:00,479 --> 00:02:03,930
type checking which is why we're using

00:02:01,829 --> 00:02:05,670
flow to make sure that you always making

00:02:03,930 --> 00:02:07,439
the right operations and you expect the

00:02:05,670 --> 00:02:10,319
parameters that you get and finally

00:02:07,439 --> 00:02:11,489
there are some security linters which is

00:02:10,319 --> 00:02:12,380
static analysis to make sure you're not

00:02:11,489 --> 00:02:14,060
using anti pass

00:02:12,380 --> 00:02:16,700
on security there aren't actually any

00:02:14,060 --> 00:02:20,210
good ones for react yet but for the

00:02:16,700 --> 00:02:23,090
backends OpenStack bandit is good for

00:02:20,210 --> 00:02:23,960
Python and then for the style complexity

00:02:23,090 --> 00:02:26,510
and duplication

00:02:23,960 --> 00:02:29,780
yes Lintz is a standard with different

00:02:26,510 --> 00:02:32,110
plugins and packages and four types flow

00:02:29,780 --> 00:02:34,820
as a tool we found most useful for react

00:02:32,110 --> 00:02:36,890
so yes Lin is really easy to install

00:02:34,820 --> 00:02:38,570
it's just a yarn dependency there are

00:02:36,890 --> 00:02:40,550
two things with the eslint configs and

00:02:38,570 --> 00:02:41,780
plugins so conflicts say which rooms are

00:02:40,550 --> 00:02:44,540
turned on and which rules are turned off

00:02:41,780 --> 00:02:45,800
and plugins define new rules a B and

00:02:44,540 --> 00:02:48,110
we've come out with a really good es

00:02:45,800 --> 00:02:49,490
link config for react projects so

00:02:48,110 --> 00:02:50,930
includes several dependencies which make

00:02:49,490 --> 00:02:52,370
sure you've got all the plugins and

00:02:50,930 --> 00:02:55,490
configurations set for the best

00:02:52,370 --> 00:02:57,500
practices and reacts some examples from

00:02:55,490 --> 00:02:59,270
that so forbid certain prop types prop

00:02:57,500 --> 00:03:01,910
types away define what your component

00:02:59,270 --> 00:03:03,850
expects to get a prevents duplication of

00:03:01,910 --> 00:03:05,870
prototypes and it makes you write

00:03:03,850 --> 00:03:09,530
components as functions when you don't

00:03:05,870 --> 00:03:11,000
need the more complex code for flow and

00:03:09,530 --> 00:03:12,800
where we're applying types to JavaScript

00:03:11,000 --> 00:03:14,600
it's a static type checker for Java

00:03:12,800 --> 00:03:16,250
scripts you have to run your code

00:03:14,600 --> 00:03:17,690
through babel first to make sure that

00:03:16,250 --> 00:03:19,670
you remove these types before runtime

00:03:17,690 --> 00:03:22,940
and then you can just add it with a flow

00:03:19,670 --> 00:03:25,910
so add it with the yarn dependency run

00:03:22,940 --> 00:03:27,200
flow and you can see the code passes for

00:03:25,910 --> 00:03:28,690
people familiar with react you've

00:03:27,200 --> 00:03:31,490
probably seen we already have prop types

00:03:28,690 --> 00:03:31,940
in react so why do we need more type

00:03:31,490 --> 00:03:33,620
checking

00:03:31,940 --> 00:03:35,330
well flow is more powerful because we

00:03:33,620 --> 00:03:38,000
can do type checking on all of our

00:03:35,330 --> 00:03:40,520
services and all of the other logic of

00:03:38,000 --> 00:03:42,830
our code also we can apply types to the

00:03:40,520 --> 00:03:44,570
state as well as the props and because

00:03:42,830 --> 00:03:48,200
we can infer types it means we get more

00:03:44,570 --> 00:03:50,750
out of what we specify a classic example

00:03:48,200 --> 00:03:52,700
of flow not in react but just in simple

00:03:50,750 --> 00:03:56,270
java scripts if we're the function to

00:03:52,700 --> 00:03:58,220
square a number we can see that here

00:03:56,270 --> 00:03:59,870
we're saying the N is a number and then

00:03:58,220 --> 00:04:02,270
we're multiplying its and if we try use

00:03:59,870 --> 00:04:03,560
a string we'll get an error the nice

00:04:02,270 --> 00:04:06,250
thing about flow which you don't get

00:04:03,560 --> 00:04:08,000
with typescript is that it can

00:04:06,250 --> 00:04:09,950
automatically figure out what your type

00:04:08,000 --> 00:04:11,120
should be and infer types so you

00:04:09,950 --> 00:04:12,770
shouldn't have to specify the types or

00:04:11,120 --> 00:04:14,870
everything so here we're not specifying

00:04:12,770 --> 00:04:16,370
the type but flow is still going to fire

00:04:14,870 --> 00:04:21,950
an error because it knows we shouldn't

00:04:16,370 --> 00:04:24,050
be using a number in multiplication so

00:04:21,950 --> 00:04:25,540
in react if this is a traditional sort

00:04:24,050 --> 00:04:27,580
of components so using a class

00:04:25,540 --> 00:04:28,900
extending react components we're

00:04:27,580 --> 00:04:30,610
importing prop types from its own

00:04:28,900 --> 00:04:32,830
library has that changed in reacts and

00:04:30,610 --> 00:04:33,910
then we're saying the prop types we've

00:04:32,830 --> 00:04:36,070
got foo which is a number that's

00:04:33,910 --> 00:04:37,660
required bar which is a string that's

00:04:36,070 --> 00:04:41,170
not required and they've got a simple

00:04:37,660 --> 00:04:45,580
render method if we flow if I this we

00:04:41,170 --> 00:04:47,620
can define a type object at the top with

00:04:45,580 --> 00:04:49,450
foo being a number and bar being a

00:04:47,620 --> 00:04:51,100
string which isn't required shown by the

00:04:49,450 --> 00:04:53,080
question mark and we can also define

00:04:51,100 --> 00:04:55,150
types for our states where you've got

00:04:53,080 --> 00:04:58,030
counts as a number and then in the

00:04:55,150 --> 00:04:59,830
angular brackets just after the class

00:04:58,030 --> 00:05:00,940
definition we can specify the types of

00:04:59,830 --> 00:05:04,840
the props and then the type of the

00:05:00,940 --> 00:05:07,090
states and four functional components as

00:05:04,840 --> 00:05:09,550
it's just a normal function we can say

00:05:07,090 --> 00:05:13,260
props is of type props and props as a

00:05:09,550 --> 00:05:13,260
type we've defined with foo and bar

00:05:14,280 --> 00:05:20,200
Thanks so now you've seen static

00:05:18,430 --> 00:05:23,110
analysis so basically once you've

00:05:20,200 --> 00:05:25,870
configured your ear skin you can use it

00:05:23,110 --> 00:05:27,640
on every new project so on on all the

00:05:25,870 --> 00:05:30,100
theater projects on all new projects now

00:05:27,640 --> 00:05:31,390
we have a nice feed configured so that

00:05:30,100 --> 00:05:34,480
when you start a project you have just

00:05:31,390 --> 00:05:35,890
static analysis ready for you then you

00:05:34,480 --> 00:05:37,330
can implement flow as well but you have

00:05:35,890 --> 00:05:40,600
to configure it for every file for every

00:05:37,330 --> 00:05:43,030
component something really like to do as

00:05:40,600 --> 00:05:45,490
well that is cheap it's the UI

00:05:43,030 --> 00:05:49,720
regression test and for this we use the

00:05:45,490 --> 00:05:52,360
snapshot so this is way cheaper than

00:05:49,720 --> 00:05:54,010
doing end-to-end test and this allows

00:05:52,360 --> 00:05:56,950
you to prevent any unwanted UI

00:05:54,010 --> 00:05:59,020
modification this is what I like to call

00:05:56,950 --> 00:06:00,520
unit tests in your UI so basically you

00:05:59,020 --> 00:06:02,830
have a component you tell it this is how

00:06:00,520 --> 00:06:05,530
it should render so if you've got deals

00:06:02,830 --> 00:06:07,450
and the span inside this should render

00:06:05,530 --> 00:06:11,290
as deals and span inside so how does it

00:06:07,450 --> 00:06:13,540
work we use just so this is a tool

00:06:11,290 --> 00:06:15,610
provided by Facebook frame or as

00:06:13,540 --> 00:06:17,410
Facebook it's really quick to implement

00:06:15,610 --> 00:06:19,570
you do it on our chest you have it and

00:06:17,410 --> 00:06:20,050
to run it then you use the unjust and

00:06:19,570 --> 00:06:21,490
that's it

00:06:20,050 --> 00:06:24,820
you can configure it in your package of

00:06:21,490 --> 00:06:27,310
JSON to specify the coverage the

00:06:24,820 --> 00:06:28,840
threshold and some other things like

00:06:27,310 --> 00:06:32,200
which files you want to extrude from

00:06:28,840 --> 00:06:34,470
your coverage this is really useful to

00:06:32,200 --> 00:06:36,910
catch at say most of your regressions

00:06:34,470 --> 00:06:38,150
while you are cutting because let's say

00:06:36,910 --> 00:06:40,250
you touch a button you

00:06:38,150 --> 00:06:42,380
brought to your button and you realized

00:06:40,250 --> 00:06:45,020
while running your test because your

00:06:42,380 --> 00:06:46,730
test can run automatically like you are

00:06:45,020 --> 00:06:48,050
watching your test we brake

00:06:46,730 --> 00:06:49,940
automatically telling you that this

00:06:48,050 --> 00:06:51,980
button was used on another page so that

00:06:49,940 --> 00:06:55,340
you don't forget that you should add

00:06:51,980 --> 00:06:57,980
these props in this new page as well and

00:06:55,340 --> 00:07:00,920
it's also useful at code review because

00:06:57,980 --> 00:07:02,780
when you create a snapshot this will

00:07:00,920 --> 00:07:05,900
create a new file explaining how this

00:07:02,780 --> 00:07:07,790
component should render and you commit

00:07:05,900 --> 00:07:11,210
this file so that then the people who

00:07:07,790 --> 00:07:14,270
review will be able to catch if there is

00:07:11,210 --> 00:07:16,750
any issue it's also a good practice for

00:07:14,270 --> 00:07:19,460
you to structure your code because

00:07:16,750 --> 00:07:20,780
snapshot can become a real pain if it

00:07:19,460 --> 00:07:24,350
gets really big if your components are

00:07:20,780 --> 00:07:26,330
will be so it forces you to have really

00:07:24,350 --> 00:07:28,730
small components so structuring your

00:07:26,330 --> 00:07:30,350
code having really small components and

00:07:28,730 --> 00:07:32,180
for instance if you're using if you're

00:07:30,350 --> 00:07:34,610
familiar with atomic design is really

00:07:32,180 --> 00:07:36,550
good too because you structure your

00:07:34,610 --> 00:07:39,320
components inside the different folders

00:07:36,550 --> 00:07:41,750
so how does this work let's take an

00:07:39,320 --> 00:07:44,270
example of a footer so it's really

00:07:41,750 --> 00:07:46,670
simple this is a div it has an ID footer

00:07:44,270 --> 00:07:49,670
and I'm using start component this time

00:07:46,670 --> 00:07:53,300
I deal with a color black how do I

00:07:49,670 --> 00:07:56,180
snapshot this simple I use render I

00:07:53,300 --> 00:07:58,030
create my footer and then I expect this

00:07:56,180 --> 00:08:00,140
element to much a snapshot and

00:07:58,030 --> 00:08:02,050
automatically what it will create what

00:08:00,140 --> 00:08:05,630
just will do when you run your gist is

00:08:02,050 --> 00:08:08,060
create a snapshot file explaining how

00:08:05,630 --> 00:08:11,000
this component should render it will

00:08:08,060 --> 00:08:12,920
look like this so it will tell you for

00:08:11,000 --> 00:08:14,960
photo renderer component correctly if we

00:08:12,920 --> 00:08:17,120
create a class with color black inside

00:08:14,960 --> 00:08:19,610
and a div with the class name in the ID

00:08:17,120 --> 00:08:22,040
and that's it thanks to two packages

00:08:19,610 --> 00:08:23,780
enzyme done JSON and just style

00:08:22,040 --> 00:08:26,140
components which allows you to simplify

00:08:23,780 --> 00:08:28,910
this snapshot otherwise it's a bit messy

00:08:26,140 --> 00:08:31,660
and thanks to this you can have a track

00:08:28,910 --> 00:08:36,260
a trace of how it should look like when

00:08:31,660 --> 00:08:37,580
it fails it will look like this so yeah

00:08:36,260 --> 00:08:38,900
let's say I change the class name

00:08:37,580 --> 00:08:40,310
because I'm you're not using style

00:08:38,900 --> 00:08:42,260
components and change the class name of

00:08:40,310 --> 00:08:45,110
the photo to header then you will see

00:08:42,260 --> 00:08:49,070
directly and you can assume whether I

00:08:45,110 --> 00:08:50,800
did it intentionally or Anita changes so

00:08:49,070 --> 00:08:53,050
these are snapshots test

00:08:50,800 --> 00:08:55,830
some developers don't think it's real

00:08:53,050 --> 00:08:59,200
test because it's really cheap to do and

00:08:55,830 --> 00:09:02,170
it actually doesn't allow you to catch

00:08:59,200 --> 00:09:03,940
any problems for instance when you click

00:09:02,170 --> 00:09:06,310
on a button if your button doesn't work

00:09:03,940 --> 00:09:08,290
the snapshot will not catch this if

00:09:06,310 --> 00:09:09,970
you're all your logic doesn't work the

00:09:08,290 --> 00:09:12,370
snapshots will not catch this but it's

00:09:09,970 --> 00:09:14,590
so cheap to do in two lines you can't

00:09:12,370 --> 00:09:17,980
have this that we usually do it on every

00:09:14,590 --> 00:09:19,960
component then you want to test all your

00:09:17,980 --> 00:09:24,640
logic with unit tests so how does it

00:09:19,960 --> 00:09:26,910
work in react obviously you want to test

00:09:24,640 --> 00:09:29,320
really small things with unit tests and

00:09:26,910 --> 00:09:31,570
why do we do this because it allows you

00:09:29,320 --> 00:09:33,430
to understand directly the route of the

00:09:31,570 --> 00:09:35,260
bus whereas if you have an end-to-end

00:09:33,430 --> 00:09:36,550
test maybe it breaks when you click on a

00:09:35,260 --> 00:09:38,350
button and then you have to investigate

00:09:36,550 --> 00:09:41,710
why it breaks what's happening and it

00:09:38,350 --> 00:09:43,030
takes you time and if you have a really

00:09:41,710 --> 00:09:44,980
good coverage and everything is tested

00:09:43,030 --> 00:09:47,590
then you are more confident to cut

00:09:44,980 --> 00:09:50,260
faster it's really good for us

00:09:47,590 --> 00:09:52,990
developers to know that if you work on a

00:09:50,260 --> 00:09:56,200
feature all the tests will catch what

00:09:52,990 --> 00:09:58,060
may happen so that's a big question do

00:09:56,200 --> 00:09:59,800
should we aim for 100% or not I think it

00:09:58,060 --> 00:10:03,100
really depends on a project we can

00:09:59,800 --> 00:10:04,420
debate about this I don't know if you're

00:10:03,100 --> 00:10:07,630
familiar with Redux

00:10:04,420 --> 00:10:10,870
in theater we are familiar a lot with it

00:10:07,630 --> 00:10:13,840
because all our projects use it and why

00:10:10,870 --> 00:10:16,570
do we use it because basically it's

00:10:13,840 --> 00:10:18,870
really useful to debug an application so

00:10:16,570 --> 00:10:22,440
if you are not familiar with it quickly

00:10:18,870 --> 00:10:24,700
the view represent your components and

00:10:22,440 --> 00:10:28,840
the view will be render based on the

00:10:24,700 --> 00:10:30,610
store which is like a storage and the

00:10:28,840 --> 00:10:35,980
only way you can modify this store is by

00:10:30,610 --> 00:10:38,290
dispatching an action ok and when the

00:10:35,980 --> 00:10:40,540
store catches the action it will update

00:10:38,290 --> 00:10:44,970
and then the view will say all the

00:10:40,540 --> 00:10:47,350
stores updated so if the props I'm using

00:10:44,970 --> 00:10:49,390
has been updated as well then I will

00:10:47,350 --> 00:10:51,190
rerender so this is the flow that's

00:10:49,390 --> 00:10:52,960
happening in the videos I want to focus

00:10:51,190 --> 00:10:55,690
on this to explain you how how it has

00:10:52,960 --> 00:10:59,320
this so basically what we want to do

00:10:55,690 --> 00:11:01,330
what we want to test is the view is

00:10:59,320 --> 00:11:03,089
correctly instantiated based on the

00:11:01,330 --> 00:11:05,069
store so if you have got a component

00:11:03,089 --> 00:11:08,160
that is receiving props we want to be

00:11:05,069 --> 00:11:09,870
sure it's accentuated correctly then

00:11:08,160 --> 00:11:12,180
when you click on a button the correct

00:11:09,870 --> 00:11:15,149
action is triggered to be sure that it

00:11:12,180 --> 00:11:18,120
will reach the actions and then you want

00:11:15,149 --> 00:11:20,459
to test as well that once an action is

00:11:18,120 --> 00:11:22,319
dispatched the store updates correctly

00:11:20,459 --> 00:11:25,410
then you've got the whole cycle and you

00:11:22,319 --> 00:11:27,389
can understand how this works so how do

00:11:25,410 --> 00:11:29,100
we do that we're going to test logic

00:11:27,389 --> 00:11:30,870
functions business logic functions

00:11:29,100 --> 00:11:31,290
really simple they can be used

00:11:30,870 --> 00:11:33,899
everywhere

00:11:31,290 --> 00:11:36,139
you're gonna test selectors as well so

00:11:33,899 --> 00:11:39,660
for instance your component is using

00:11:36,139 --> 00:11:41,639
some computed data from the store via a

00:11:39,660 --> 00:11:43,699
selector then you want to test this to

00:11:41,639 --> 00:11:46,800
ensure this data is in a correct format

00:11:43,699 --> 00:11:48,569
you want to test the register actions to

00:11:46,800 --> 00:11:50,579
be sure that the stories of data

00:11:48,569 --> 00:11:52,529
correctly in depending when once an

00:11:50,579 --> 00:11:54,029
action is dispatched and then the

00:11:52,529 --> 00:11:56,699
components behavior once you click on a

00:11:54,029 --> 00:11:58,620
button something happens so what do we

00:11:56,699 --> 00:12:01,220
use for this just again because it's

00:11:58,620 --> 00:12:05,579
really powerful and easy to use and

00:12:01,220 --> 00:12:09,089
enzyme a tool created by our B&B that

00:12:05,579 --> 00:12:12,240
allows you to how can I say this to

00:12:09,089 --> 00:12:14,279
create a component either by shallowing

00:12:12,240 --> 00:12:16,439
it which is really simple you create a

00:12:14,279 --> 00:12:17,790
small components and it will render it

00:12:16,439 --> 00:12:21,420
with props and then you can manipulate

00:12:17,790 --> 00:12:24,870
it all by mounting it where it will

00:12:21,420 --> 00:12:27,509
trigger the whole redox flow which is

00:12:24,870 --> 00:12:30,050
mounting the elements and then you can

00:12:27,509 --> 00:12:33,120
fetch in another tutorial

00:12:30,050 --> 00:12:35,790
let's take a really classic example I've

00:12:33,120 --> 00:12:37,499
got a function get highest number which

00:12:35,790 --> 00:12:40,100
is a service that takes an array returns

00:12:37,499 --> 00:12:43,499
a number how do we test this we've got

00:12:40,100 --> 00:12:46,649
here got my array I expect my function

00:12:43,499 --> 00:12:48,509
to return the correct value and then I

00:12:46,649 --> 00:12:51,929
have an edge case it returns nil if I

00:12:48,509 --> 00:12:53,939
give it an empty array obviously if it

00:12:51,929 --> 00:12:56,100
passes the news it green and then if it

00:12:53,939 --> 00:12:58,499
breaks if someone breaks it that is not

00:12:56,100 --> 00:13:01,139
the one who developed it he will see oh

00:12:58,499 --> 00:13:03,089
I was expected to see no they receive an

00:13:01,139 --> 00:13:05,339
empty area so then you can understand

00:13:03,089 --> 00:13:06,959
what's happening just is really useful

00:13:05,339 --> 00:13:09,629
because it gives you a lot of functions

00:13:06,959 --> 00:13:11,459
like this that you can use on all your

00:13:09,629 --> 00:13:13,410
cases for instance to be in a little bit

00:13:11,459 --> 00:13:15,900
fruity you can set if your function

00:13:13,410 --> 00:13:20,460
froze correctly or passive

00:13:15,900 --> 00:13:24,000
correctly that's the basics of just then

00:13:20,460 --> 00:13:26,610
you want to test that your components if

00:13:24,000 --> 00:13:29,730
it uses selectors to get data from the

00:13:26,610 --> 00:13:31,950
store do it correctly so you want to

00:13:29,730 --> 00:13:34,500
test the selectors for instance I've got

00:13:31,950 --> 00:13:37,770
a selector that from the state returned

00:13:34,500 --> 00:13:39,750
a number which is in a sub register so

00:13:37,770 --> 00:13:43,530
how do we test this while you mop the

00:13:39,750 --> 00:13:45,420
stage you create the fake state with the

00:13:43,530 --> 00:13:47,250
server disown your number inside you

00:13:45,420 --> 00:13:49,470
test your function and it you expect it

00:13:47,250 --> 00:13:53,460
to return the correct value and then if

00:13:49,470 --> 00:13:57,300
it changes it will break then I mention

00:13:53,460 --> 00:13:59,220
it's too shallow up component let's say

00:13:57,300 --> 00:14:01,260
I've got a component that once you click

00:13:59,220 --> 00:14:04,560
on it it should do something you want to

00:14:01,260 --> 00:14:10,050
be sure that it does it so what I will

00:14:04,560 --> 00:14:11,670
do is shallow my element and I will

00:14:10,050 --> 00:14:12,390
create a function as well there is a

00:14:11,670 --> 00:14:14,880
mock function

00:14:12,390 --> 00:14:16,440
thanks to Jess you can't read just @fn

00:14:14,880 --> 00:14:18,330
choose a function you can manipulate

00:14:16,440 --> 00:14:20,010
afterwards I will give it to my

00:14:18,330 --> 00:14:22,470
components and then I will simulate a

00:14:20,010 --> 00:14:26,850
kick thanks to the wrapper and I expect

00:14:22,470 --> 00:14:29,760
my the mock to be called at least once a

00:14:26,850 --> 00:14:31,500
little higher if you mount it then you

00:14:29,760 --> 00:14:33,270
can test functions like component did

00:14:31,500 --> 00:14:35,370
mount so it's something that happens

00:14:33,270 --> 00:14:37,350
only once the component is mounted I

00:14:35,370 --> 00:14:39,360
want to be sure that this function is

00:14:37,350 --> 00:14:40,650
triggered so I do the same but you get

00:14:39,360 --> 00:14:42,570
need to give it a bit more data I need

00:14:40,650 --> 00:14:46,110
to give it the store and everything so

00:14:42,570 --> 00:14:48,390
that I create again my function here I

00:14:46,110 --> 00:14:52,710
create the store with my function inside

00:14:48,390 --> 00:14:55,560
and then once I run just by mounting it

00:14:52,710 --> 00:14:57,360
my function should be called so

00:14:55,560 --> 00:15:00,420
basically we tested the whole flow the

00:14:57,360 --> 00:15:02,250
radix flow what we could do is also test

00:15:00,420 --> 00:15:04,110
the middleware for instant yuccas test

00:15:02,250 --> 00:15:06,210
sagas it's really straightforward to

00:15:04,110 --> 00:15:07,770
test because a gas can be declare really

00:15:06,210 --> 00:15:09,990
easily so you expect with time you

00:15:07,770 --> 00:15:12,780
create a generator you do an X and you

00:15:09,990 --> 00:15:18,440
expect the values to be the one you

00:15:12,780 --> 00:15:18,440
expect that's it for yeah unit test

00:15:19,970 --> 00:15:22,369
yes we've worked our way up to the top

00:15:21,229 --> 00:15:24,709
of the pyramid as I mentioned at the

00:15:22,369 --> 00:15:26,059
start the ones at the bottom of the

00:15:24,709 --> 00:15:27,709
easiest to implement and the ones you

00:15:26,059 --> 00:15:29,359
should have more liberally and the ones

00:15:27,709 --> 00:15:30,949
at the top are the ones you should use

00:15:29,359 --> 00:15:32,629
less but for the most important parts

00:15:30,949 --> 00:15:34,579
and end-to-end testing is the most

00:15:32,629 --> 00:15:37,609
significant one for this so it's the

00:15:34,579 --> 00:15:39,199
things you never want to fail we use WD

00:15:37,609 --> 00:15:41,839
IO and Night Watch for some of our

00:15:39,199 --> 00:15:43,599
projects it's not really react specific

00:15:41,839 --> 00:15:46,069
the only react specific element of it is

00:15:43,599 --> 00:15:47,749
some components can take a while to

00:15:46,069 --> 00:15:49,159
mount onto the page and in those

00:15:47,749 --> 00:15:50,929
instances you might need to do some

00:15:49,159 --> 00:15:54,319
weird timeouts stuff other than that

00:15:50,929 --> 00:15:57,109
it's like testing any other websites so

00:15:54,319 --> 00:15:59,689
WD IO provides a test runner and also

00:15:57,109 --> 00:16:01,789
supports multiple test frameworks to run

00:15:59,689 --> 00:16:04,279
on top of a selenium server to integrate

00:16:01,789 --> 00:16:05,809
with your websites a browser and the

00:16:04,279 --> 00:16:07,459
important thing is do this for your

00:16:05,809 --> 00:16:08,419
critical paths so if your Amazon you

00:16:07,459 --> 00:16:10,069
want to make sure someone can put

00:16:08,419 --> 00:16:12,319
something in a basket and you want to

00:16:10,069 --> 00:16:13,699
make sure they can buy it but mainly you

00:16:12,319 --> 00:16:15,019
want to test the happy cases for that

00:16:13,699 --> 00:16:16,909
and not every different error message

00:16:15,019 --> 00:16:19,189
your application will have and only it's

00:16:16,909 --> 00:16:19,939
expensive to write but all these tests

00:16:19,189 --> 00:16:21,889
will be on your continuous integration

00:16:19,939 --> 00:16:25,039
if it takes 30 minutes for every build

00:16:21,889 --> 00:16:26,089
to surpass or even to fail your

00:16:25,039 --> 00:16:27,919
developers are gonna be slowed down a

00:16:26,089 --> 00:16:32,029
lot and these tests can break very

00:16:27,919 --> 00:16:33,979
easily and sometimes not even because

00:16:32,029 --> 00:16:36,649
something's broken just they can fail

00:16:33,979 --> 00:16:37,939
randomly quite easily so the testing

00:16:36,649 --> 00:16:40,669
framer they went over from static

00:16:37,939 --> 00:16:42,439
analysis up to UI regression tests unit

00:16:40,669 --> 00:16:44,419
tests and the unit tests that mounts and

00:16:42,439 --> 00:16:47,029
interact with the UI and then up to the

00:16:44,419 --> 00:16:48,439
end-to-end tests the final thing is it's

00:16:47,029 --> 00:16:50,629
important these are all in a continuous

00:16:48,439 --> 00:16:53,509
integration so they're on every build

00:16:50,629 --> 00:16:55,279
and staging or UAT and into production

00:16:53,509 --> 00:16:56,779
all these different checks should pass

00:16:55,279 --> 00:16:59,569
your linter should pass on all your

00:16:56,779 --> 00:17:01,009
files including your test files and all

00:16:59,569 --> 00:17:03,379
the different tests and that pyramid

00:17:01,009 --> 00:17:04,789
should pass we use circle CI which we've

00:17:03,379 --> 00:17:07,009
seen to be quite fast especially since

00:17:04,789 --> 00:17:10,100
circle CI 2 but Travis and many of the

00:17:07,009 --> 00:17:11,899
things are quite easy to use yeah that's

00:17:10,100 --> 00:17:14,589
everything if anyone's got any questions

00:17:11,899 --> 00:17:14,589
please yeah

00:17:16,179 --> 00:17:18,240

YouTube URL: https://www.youtube.com/watch?v=tL2UpJQtLPQ


