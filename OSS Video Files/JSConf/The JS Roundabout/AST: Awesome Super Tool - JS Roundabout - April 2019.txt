Title: AST: Awesome Super Tool - JS Roundabout - April 2019
Publication date: 2019-04-05
Playlist: The JS Roundabout
Description: 
	Presented by Leonardo Crespo.

It’s always good to understand how things work under the hood. Not only because it allows you to understand how to properly use things or how things may fail, but also to add that knowledge to your toolkit when needing to solve a problem.

How does Babel work? And ESLint? What about Prettier? Oh, and codemods? They all share a common concept which will unlock a world of possibilities if you understand it: the AST (stands for Abstract Syntax Tree).

Let’s learn a bit about yet another acronym, in order to learn how we can use it to bend the code to our will, and also have fun experimenting.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,190
I'm Lenny my real name is Leonardo but

00:00:02,790 --> 00:00:07,290
everyone call me calls me Lenny first of

00:00:05,190 --> 00:00:09,330
all thank you both Tom and Guillaume for

00:00:07,290 --> 00:00:11,730
like organizing and coordinating this

00:00:09,330 --> 00:00:13,320
entire event and for all of you two to

00:00:11,730 --> 00:00:17,990
come here and obviously for Twitter to

00:00:13,320 --> 00:00:21,180
host it so yeah here we are

00:00:17,990 --> 00:00:24,420
so yeah I'm a front-end developer I work

00:00:21,180 --> 00:00:27,570
here Twitter I joined a year ago very

00:00:24,420 --> 00:00:29,490
happy working at the at a project for a

00:00:27,570 --> 00:00:31,769
called TweetDeck which is like a

00:00:29,490 --> 00:00:35,480
separate client for Twitter which some

00:00:31,769 --> 00:00:38,370
like you might some may know already so

00:00:35,480 --> 00:00:40,890
I'm originally for from Argentina so I

00:00:38,370 --> 00:00:45,600
moved for the job a year ago and I'm

00:00:40,890 --> 00:00:48,059
living here now so today I would like to

00:00:45,600 --> 00:00:50,219
talk about a tool that may help you like

00:00:48,059 --> 00:00:52,320
the idea of this dog is like to to teach

00:00:50,219 --> 00:00:54,270
you about some tool that you could use

00:00:52,320 --> 00:00:58,410
in your projects to improve your

00:00:54,270 --> 00:01:00,600
productivity or to like maybe like

00:00:58,410 --> 00:01:02,100
increase your kid creativity with things

00:01:00,600 --> 00:01:05,369
that you can do to automate more stuff

00:01:02,100 --> 00:01:08,909
in your day to day work so let's start

00:01:05,369 --> 00:01:11,820
with these two things so a quick show of

00:01:08,909 --> 00:01:16,020
hands who knows about these two tools

00:01:11,820 --> 00:01:20,790
babble NES lint or and/or so yeah most

00:01:16,020 --> 00:01:23,130
of you and from from all of you like how

00:01:20,790 --> 00:01:24,960
many of you have gone beyond configuring

00:01:23,130 --> 00:01:27,500
them like how many of you have actually

00:01:24,960 --> 00:01:31,920
built a Babel plug-in or a nice lint

00:01:27,500 --> 00:01:33,900
rule cool okay so remember those who

00:01:31,920 --> 00:01:41,250
raise your hands I usually ask questions

00:01:33,900 --> 00:01:43,530
to them after the talk cool so let's

00:01:41,250 --> 00:01:45,990
begin with Babel like for like Jessica

00:01:43,530 --> 00:01:48,270
let's go back to the basics so what does

00:01:45,990 --> 00:01:53,130
bubble do bubble is a JavaScript library

00:01:48,270 --> 00:01:55,320
that receives some source code in the

00:01:53,130 --> 00:01:57,540
form like in some syntax like depending

00:01:55,320 --> 00:02:02,030
like on the on the thing that we write

00:01:57,540 --> 00:02:05,759
it may be like yes 2015 it es 2016-17

00:02:02,030 --> 00:02:10,170
whatever like any any syntax that we

00:02:05,759 --> 00:02:12,569
that we provide by writing and it

00:02:10,170 --> 00:02:13,950
outputs the same like a problem with the

00:02:12,569 --> 00:02:17,489
same behavior but

00:02:13,950 --> 00:02:18,840
in terms of difference in tax and that's

00:02:17,489 --> 00:02:22,620
depending on how we configure it so

00:02:18,840 --> 00:02:24,180
maybe in terms of the same syntax or in

00:02:22,620 --> 00:02:27,200
terms of like syntax that is supported

00:02:24,180 --> 00:02:29,910
for older browsers in order to work in

00:02:27,200 --> 00:02:33,780
on them so we can still write modern

00:02:29,910 --> 00:02:35,310
like JavaScript but still using in

00:02:33,780 --> 00:02:38,700
browsers that don't yet support those

00:02:35,310 --> 00:02:40,250
those index that syntax but that's not

00:02:38,700 --> 00:02:43,349
really the only thing that bubble does

00:02:40,250 --> 00:02:46,890
so bubble is a bit more general than

00:02:43,349 --> 00:02:49,950
that more generic it really is a tool

00:02:46,890 --> 00:02:53,489
that allows you to transform that that

00:02:49,950 --> 00:02:54,870
source code into anything and that's

00:02:53,489 --> 00:02:58,620
beyond like implementing the same

00:02:54,870 --> 00:03:00,569
behavior in terms of older syntax for

00:02:58,620 --> 00:03:04,440
browsers so let's look at some examples

00:03:00,569 --> 00:03:07,200
so there's this library called IDX

00:03:04,440 --> 00:03:09,360
which was created by Facebook which

00:03:07,200 --> 00:03:11,880
works similarly to those of you familiar

00:03:09,360 --> 00:03:14,430
with lodash they get method that allows

00:03:11,880 --> 00:03:16,380
you to like access nested properties and

00:03:14,430 --> 00:03:19,530
verify that without actually checking

00:03:16,380 --> 00:03:24,120
for existence of each of the in-between

00:03:19,530 --> 00:03:27,530
properties but in a probably more type

00:03:24,120 --> 00:03:32,280
check cobble or statically typed manner

00:03:27,530 --> 00:03:35,190
it does it that way so it works in the

00:03:32,280 --> 00:03:36,840
same way so if any thing in between the

00:03:35,190 --> 00:03:40,590
thing that we're trying to access is no

00:03:36,840 --> 00:03:42,359
or undefined it returns undefined and it

00:03:40,590 --> 00:03:44,700
but it also comes with a bubble plug-in

00:03:42,359 --> 00:03:47,760
that actually transformed that code into

00:03:44,700 --> 00:03:50,430
what we would actually write manually by

00:03:47,760 --> 00:03:52,739
hand if we wanted to check for the

00:03:50,430 --> 00:03:55,769
existence or not of each of the nested

00:03:52,739 --> 00:03:58,319
properties this is a bit better than a

00:03:55,769 --> 00:04:02,040
in terms of performance in production

00:03:58,319 --> 00:04:04,920
for because the runt the the other one

00:04:02,040 --> 00:04:07,349
deal relies on handling exceptions and

00:04:04,920 --> 00:04:09,450
trying and catching and handling

00:04:07,349 --> 00:04:10,680
whatever is thrown which may be a bit

00:04:09,450 --> 00:04:14,819
slower than actually just checking for

00:04:10,680 --> 00:04:16,530
anything else but it's a bit tedious to

00:04:14,819 --> 00:04:17,880
write so we don't want to write that we

00:04:16,530 --> 00:04:21,329
still want to write the other way and

00:04:17,880 --> 00:04:25,050
have something to be automated for us so

00:04:21,329 --> 00:04:26,580
this is what it does there's another

00:04:25,050 --> 00:04:29,520
example

00:04:26,580 --> 00:04:32,759
this is a bubble plugin that provides

00:04:29,520 --> 00:04:36,360
you with this magic function called pre

00:04:32,759 --> 00:04:38,610
Val which is like a implemented name in

00:04:36,360 --> 00:04:41,550
a typed literal form so this is actually

00:04:38,610 --> 00:04:44,580
a kind of a function call which receives

00:04:41,550 --> 00:04:48,300
a string and you can see that inside the

00:04:44,580 --> 00:04:50,639
string there's actually code that when

00:04:48,300 --> 00:04:53,340
we run the plug in with with with this

00:04:50,639 --> 00:04:56,250
like source file it will execute that

00:04:53,340 --> 00:04:57,810
code inside and it will like replace it

00:04:56,250 --> 00:05:00,900
with the actual evaluation of the code

00:04:57,810 --> 00:05:02,639
so it will it will return at that so

00:05:00,900 --> 00:05:05,129
this is also handy when we want to like

00:05:02,639 --> 00:05:07,409
do some pre pre computations at compile

00:05:05,129 --> 00:05:09,960
time but we still want to write a more

00:05:07,409 --> 00:05:12,539
readable format for things that should

00:05:09,960 --> 00:05:14,849
be like but yeah the things that are

00:05:12,539 --> 00:05:20,159
more readable in the expression form is

00:05:14,849 --> 00:05:23,099
certified the final value okay so now

00:05:20,159 --> 00:05:26,129
let's look at es lint yes neend again is

00:05:23,099 --> 00:05:29,940
a tool that also receives source code as

00:05:26,129 --> 00:05:33,719
input in different syntax so it accepts

00:05:29,940 --> 00:05:35,580
various kinds of syntax capabilities but

00:05:33,719 --> 00:05:38,159
in this case what it outputs is actually

00:05:35,580 --> 00:05:41,969
a report of warnings and errors of

00:05:38,159 --> 00:05:44,580
things that that is the text and it can

00:05:41,969 --> 00:05:46,919
be any kind of rules actually they it

00:05:44,580 --> 00:05:49,169
provides a bunch of them so some some

00:05:46,919 --> 00:05:51,870
are like stylistic rules so if you're

00:05:49,169 --> 00:05:53,789
like misaligning like indentation like

00:05:51,870 --> 00:05:54,960
it will raise an error saying hey or a

00:05:53,789 --> 00:05:58,169
warning depending on how you configure

00:05:54,960 --> 00:06:00,659
it hey this is not aligned if you are

00:05:58,169 --> 00:06:03,419
like using arrow functions or normal

00:06:00,659 --> 00:06:05,039
function declarations depending on how

00:06:03,419 --> 00:06:07,860
you configure it it made like say hey

00:06:05,039 --> 00:06:09,690
you prefer to write arrow functions

00:06:07,860 --> 00:06:12,060
versus function declarations for example

00:06:09,690 --> 00:06:13,919
so that will also be an error but also

00:06:12,060 --> 00:06:16,020
you know improvised with some like help

00:06:13,919 --> 00:06:17,789
for J's catches like I don't know

00:06:16,020 --> 00:06:20,250
forgetting to declare variable and E

00:06:17,789 --> 00:06:23,460
trying to use it that's also where yes

00:06:20,250 --> 00:06:25,289
lint is very helpful with and some other

00:06:23,460 --> 00:06:27,210
things like in general like depending

00:06:25,289 --> 00:06:28,830
like for example module resolution when

00:06:27,210 --> 00:06:31,889
we are trying to import or require some

00:06:28,830 --> 00:06:34,710
stuff from a command J as noted a

00:06:31,889 --> 00:06:37,649
node.js module with common J's but again

00:06:34,710 --> 00:06:39,509
this is not entirely what IES lint is

00:06:37,649 --> 00:06:40,410
capable of it's a bit more generic than

00:06:39,509 --> 00:06:42,840
that

00:06:40,410 --> 00:06:45,030
so you can actually do any kind of

00:06:42,840 --> 00:06:49,950
reporting that we want so you can build

00:06:45,030 --> 00:06:52,950
your own stuff with it for example there

00:06:49,950 --> 00:06:57,330
is a es lint rule like you can find and

00:06:52,950 --> 00:06:58,950
github or Indian TM that it's priced

00:06:57,330 --> 00:07:01,500
with more suited for people that have a

00:06:58,950 --> 00:07:03,090
more functional taste for for the code

00:07:01,500 --> 00:07:06,170
and they want to make everything

00:07:03,090 --> 00:07:09,210
immutable which is like disallowing

00:07:06,170 --> 00:07:11,820
mutations in their objects so whenever

00:07:09,210 --> 00:07:13,650
you find like an assignment to an object

00:07:11,820 --> 00:07:16,020
it will be like an error in the incident

00:07:13,650 --> 00:07:21,060
so you should prefer like the immutable

00:07:16,020 --> 00:07:24,660
way of changing things there's another

00:07:21,060 --> 00:07:27,650
yes lint play rule out there that allows

00:07:24,660 --> 00:07:30,180
you that helps you to detect like legacy

00:07:27,650 --> 00:07:32,550
that allows you to define legacy methods

00:07:30,180 --> 00:07:34,740
that you no longer want to call in your

00:07:32,550 --> 00:07:37,020
code and even suggest with like an

00:07:34,740 --> 00:07:40,440
alternative and every time you try to

00:07:37,020 --> 00:07:41,820
use that it will pray it will like raise

00:07:40,440 --> 00:07:43,830
an error or a warning depending on how

00:07:41,820 --> 00:07:47,400
you configure it and I suggest the

00:07:43,830 --> 00:07:50,430
alternative so you can change it that's

00:07:47,400 --> 00:07:53,430
really cool but how do they really work

00:07:50,430 --> 00:07:55,320
I mean how are they is so like generic

00:07:53,430 --> 00:07:58,740
but at the same time people are actually

00:07:55,320 --> 00:08:00,750
wanting to build plug-ins and rules on a

00:07:58,740 --> 00:08:03,150
tiger and it's not like an entangled

00:08:00,750 --> 00:08:08,700
mess of code of like dealing with the

00:08:03,150 --> 00:08:11,160
Reg X's and strings and all that so yeah

00:08:08,700 --> 00:08:14,910
obviously it works with magic everything

00:08:11,160 --> 00:08:18,300
that we don't really understand must be

00:08:14,910 --> 00:08:20,820
that but in reality that magic comes

00:08:18,300 --> 00:08:24,300
from a thing that is called it's also

00:08:20,820 --> 00:08:28,170
like mysterious for most of us that is

00:08:24,300 --> 00:08:30,660
called a parser so what it ultimately is

00:08:28,170 --> 00:08:32,250
doing is like at some point these tools

00:08:30,660 --> 00:08:34,590
are parsing this source code into

00:08:32,250 --> 00:08:38,520
something that is more useful usable for

00:08:34,590 --> 00:08:41,820
for us to deal with but how do parcels

00:08:38,520 --> 00:08:45,830
really work how they're built so it's

00:08:41,820 --> 00:08:47,910
really easy again just two simple steps

00:08:45,830 --> 00:08:49,710
the thing is that we don't really care

00:08:47,910 --> 00:08:51,960
too much about how parser is actually

00:08:49,710 --> 00:08:53,790
implemented and it's actually probably a

00:08:51,960 --> 00:08:56,190
very difficult thing to

00:08:53,790 --> 00:08:57,510
they'll delve into the good thing is

00:08:56,190 --> 00:08:59,040
that in the world of JavaScript there's

00:08:57,510 --> 00:09:03,450
a very like a bunch of JavaScript

00:08:59,040 --> 00:09:08,040
parsers probably too many but this is a

00:09:03,450 --> 00:09:09,900
solved thing so we wish for these

00:09:08,040 --> 00:09:12,660
purposes we only care about what

00:09:09,900 --> 00:09:15,210
actually a parser - conceptually so what

00:09:12,660 --> 00:09:18,120
does it do so a parser again it's a tool

00:09:15,210 --> 00:09:21,020
that receives source code as input

00:09:18,120 --> 00:09:24,060
something similar to this for example

00:09:21,020 --> 00:09:28,260
and it returns a data structure that is

00:09:24,060 --> 00:09:31,590
called an abstract syntax tree or an AST

00:09:28,260 --> 00:09:33,240
that looks like this so an ST is nothing

00:09:31,590 --> 00:09:37,080
scary it's just like an JavaScript

00:09:33,240 --> 00:09:39,420
object which is nested so it's actually

00:09:37,080 --> 00:09:40,830
a tree it is implemented as a data

00:09:39,420 --> 00:09:43,490
structure there is a tree so that means

00:09:40,830 --> 00:09:46,500
that it's just a a nested object with no

00:09:43,490 --> 00:09:50,640
references to other parts of this always

00:09:46,500 --> 00:09:53,550
note cycle cyclic references so yeah it

00:09:50,640 --> 00:09:55,260
really looks like this just like starts

00:09:53,550 --> 00:09:57,690
with a node and some associations to

00:09:55,260 --> 00:09:59,460
other nodes and as you can see back here

00:09:57,690 --> 00:10:02,750
some of the node like the notes

00:09:59,460 --> 00:10:06,780
themselves of the objects themselves are

00:10:02,750 --> 00:10:09,690
constructs of the language that kind of

00:10:06,780 --> 00:10:13,590
are like useful or like identifiable

00:10:09,690 --> 00:10:15,630
enough so for example we can see in the

00:10:13,590 --> 00:10:17,490
in the source code we see like a Const

00:10:15,630 --> 00:10:19,440
hello equals 4 which is a variable

00:10:17,490 --> 00:10:22,470
declaration and we see some stuff like

00:10:19,440 --> 00:10:25,740
that represented here a variable

00:10:22,470 --> 00:10:29,010
declaration of kind Const that holds two

00:10:25,740 --> 00:10:32,580
things well one thing sorry which holds

00:10:29,010 --> 00:10:34,680
two parts like the ID and the in it so

00:10:32,580 --> 00:10:36,270
the initial value and the ID of how to

00:10:34,680 --> 00:10:39,420
identify that variable which themselves

00:10:36,270 --> 00:10:40,770
are also our other nodes so we can see

00:10:39,420 --> 00:10:44,280
that all the information from the source

00:10:40,770 --> 00:10:45,420
code is there or at least the useful

00:10:44,280 --> 00:10:48,660
information from the source code is

00:10:45,420 --> 00:10:51,810
there and once we have this tree is

00:10:48,660 --> 00:10:53,700
actually very easy to do things with it

00:10:51,810 --> 00:10:56,460
more easy than just dealing with the

00:10:53,700 --> 00:10:59,430
strings themselves so what can we do

00:10:56,460 --> 00:11:03,960
with an ast well we can do a lot of

00:10:59,430 --> 00:11:06,930
things we can first write something that

00:11:03,960 --> 00:11:07,720
traverses that tree and starts running

00:11:06,930 --> 00:11:10,329
the code for

00:11:07,720 --> 00:11:12,790
temple so we can interpret every note

00:11:10,329 --> 00:11:14,589
every every construct of the of the of

00:11:12,790 --> 00:11:16,899
the source code of the of the tree and

00:11:14,589 --> 00:11:21,629
then do something with the data as it

00:11:16,899 --> 00:11:24,550
flows we can also analyze it we can like

00:11:21,629 --> 00:11:26,649
detect some patterns statically by it by

00:11:24,550 --> 00:11:29,620
like looking at relationships between

00:11:26,649 --> 00:11:31,509
the nodes and get some like reports some

00:11:29,620 --> 00:11:34,420
stuff you know how many times this thing

00:11:31,509 --> 00:11:36,850
is used can this you can this thing be

00:11:34,420 --> 00:11:38,410
used without this other node being

00:11:36,850 --> 00:11:40,180
declared for example like a missing

00:11:38,410 --> 00:11:43,660
variable declaration that's very easy to

00:11:40,180 --> 00:11:45,879
do with with with the tree shape but

00:11:43,660 --> 00:11:49,959
given that it's a tree we can also like

00:11:45,879 --> 00:11:52,600
manipulated so we can also change it you

00:11:49,959 --> 00:11:55,449
know like however we want as long as the

00:11:52,600 --> 00:11:58,449
result is still a valid ast so it's

00:11:55,449 --> 00:12:00,250
still like syntactically valid that

00:11:58,449 --> 00:12:03,129
means that some nodes are not sometimes

00:12:00,250 --> 00:12:04,990
allowed as Charles of some other nodes

00:12:03,129 --> 00:12:09,610
so as long as we're careful with that

00:12:04,990 --> 00:12:12,069
that's perfectly possible and we can

00:12:09,610 --> 00:12:13,480
also do the inverse of that of the of

00:12:12,069 --> 00:12:15,670
the process that we did in the beginning

00:12:13,480 --> 00:12:19,839
so we can also convert that back to a

00:12:15,670 --> 00:12:21,759
string okay so now that we know that

00:12:19,839 --> 00:12:24,220
lets could go back and see how bubble

00:12:21,759 --> 00:12:26,110
actually works and this is like the

00:12:24,220 --> 00:12:29,769
pipeline for what bubble actually does

00:12:26,110 --> 00:12:34,029
so it receives again a source code as an

00:12:29,769 --> 00:12:36,220
input it's a string of text it parses it

00:12:34,029 --> 00:12:38,319
and converts it into into an ast which

00:12:36,220 --> 00:12:41,559
is then fed into like a set of plugins

00:12:38,319 --> 00:12:45,790
which are things that transform that

00:12:41,559 --> 00:12:47,439
tree somehow and then bubble takes that

00:12:45,790 --> 00:12:49,509
final string resulting of applying that

00:12:47,439 --> 00:12:52,420
those plugins do to the same ast and

00:12:49,509 --> 00:12:55,769
converts that back to a string which is

00:12:52,420 --> 00:12:58,509
again a program that will eventually be

00:12:55,769 --> 00:13:00,850
fed into the browser which will like in

00:12:58,509 --> 00:13:04,689
turn parse a parse it again and execute

00:13:00,850 --> 00:13:08,470
it in this time and in a similar fashion

00:13:04,689 --> 00:13:10,149
yes lint again graphs works by grabbing

00:13:08,470 --> 00:13:12,399
the the source code which is a string

00:13:10,149 --> 00:13:14,709
parses it and compress it into an AST

00:13:12,399 --> 00:13:17,319
this time it runs it through a set of

00:13:14,709 --> 00:13:20,009
rules which again are functions that

00:13:17,319 --> 00:13:21,370
deal with the AST but in this case they

00:13:20,009 --> 00:13:23,680
try to the

00:13:21,370 --> 00:13:25,360
take some patterns and I'll report some

00:13:23,680 --> 00:13:29,050
warnings or errors and that's the final

00:13:25,360 --> 00:13:31,750
output of the of the tool

00:13:29,050 --> 00:13:35,290
I mean I'm ignoring this case the fixing

00:13:31,750 --> 00:13:37,690
because it also allows to fix rules

00:13:35,290 --> 00:13:39,790
which in turn in that case it may be a

00:13:37,690 --> 00:13:41,740
bit more like similar to what bubble

00:13:39,790 --> 00:13:45,670
actually does but for simplicity's sake

00:13:41,740 --> 00:13:51,370
we're like focusing on the detection of

00:13:45,670 --> 00:13:54,820
rule of warnings or errors cool so now

00:13:51,370 --> 00:13:57,310
let's go and look at a demo okay so I

00:13:54,820 --> 00:14:00,970
mean probably you can see the URL

00:13:57,310 --> 00:14:04,390
because that doesn't go bigger but this

00:14:00,970 --> 00:14:06,279
site is called ast explorer dotnet which

00:14:04,390 --> 00:14:08,860
to me is like the de-facto place were

00:14:06,279 --> 00:14:11,050
like where you can work with ASDs and

00:14:08,860 --> 00:14:14,470
like it's actually really cool has a lot

00:14:11,050 --> 00:14:16,240
of like interactivity so you yeah it has

00:14:14,470 --> 00:14:20,500
two panels so in the left hand side

00:14:16,240 --> 00:14:23,260
panel you write the source code and you

00:14:20,500 --> 00:14:25,930
can see that as I type as I click and as

00:14:23,260 --> 00:14:29,290
I write the thing on the right updates

00:14:25,930 --> 00:14:31,990
and highlights that like the interesting

00:14:29,290 --> 00:14:33,010
parts of of the thing and what it's

00:14:31,990 --> 00:14:36,970
actually on the right hand side is the

00:14:33,010 --> 00:14:39,010
ast we can actually see that here for

00:14:36,970 --> 00:14:41,790
example we have an if statement which

00:14:39,010 --> 00:14:44,500
the condition is a binary expression

00:14:41,790 --> 00:14:46,839
where the left-hand side of the binary

00:14:44,500 --> 00:14:48,760
expression is a member expression which

00:14:46,839 --> 00:14:54,250
actually is a nested member expression

00:14:48,760 --> 00:14:57,070
where we see like process then and and

00:14:54,250 --> 00:14:59,290
then no down and then that's equal to

00:14:57,070 --> 00:15:02,650
something on the right which is a string

00:14:59,290 --> 00:15:04,750
literal so it's pretty clear it's very

00:15:02,650 --> 00:15:06,040
easy to see the source code and est at

00:15:04,750 --> 00:15:09,910
the same time and like to make sense of

00:15:06,040 --> 00:15:13,029
it so this is why in general like this

00:15:09,910 --> 00:15:14,410
is the best place to to work with ASDs

00:15:13,029 --> 00:15:16,870
because it's very easy to see what's

00:15:14,410 --> 00:15:21,279
going on but this is not the only thing

00:15:16,870 --> 00:15:22,900
that this tool does actually is not even

00:15:21,279 --> 00:15:24,700
like tied to JavaScript you can use any

00:15:22,900 --> 00:15:26,290
other language because it parses and

00:15:24,700 --> 00:15:29,589
shows I guess these four different

00:15:26,290 --> 00:15:33,250
languages but to for our purposes it

00:15:29,589 --> 00:15:34,990
also allows us to run transforms in this

00:15:33,250 --> 00:15:38,079
case we can even like

00:15:34,990 --> 00:15:39,879
run Babel plugins with it or ears link

00:15:38,079 --> 00:15:41,860
rules with it in this case we're gonna

00:15:39,879 --> 00:15:44,259
be running a battle plugin we're gonna

00:15:41,860 --> 00:15:46,149
be writing our own plugin so when you

00:15:44,259 --> 00:15:50,470
click on transform and you select act

00:15:46,149 --> 00:15:53,740
with let's use bubble v7 we have two

00:15:50,470 --> 00:15:55,660
more panels at the bottom the one on the

00:15:53,740 --> 00:15:57,220
left is the actual plugin the actual

00:15:55,660 --> 00:15:59,139
implementation which is what we're going

00:15:57,220 --> 00:16:02,019
to be working with and the thing on the

00:15:59,139 --> 00:16:05,769
right is the output of running the

00:16:02,019 --> 00:16:09,449
plug-in - in the in the code that was in

00:16:05,769 --> 00:16:13,269
the upper left side so it comes with an

00:16:09,449 --> 00:16:14,709
built-in example that we can see like

00:16:13,269 --> 00:16:16,839
from the output we are actually

00:16:14,709 --> 00:16:23,740
understanding what's going on that seems

00:16:16,839 --> 00:16:27,459
to be reversing every identifier that we

00:16:23,740 --> 00:16:31,089
have in the code so this is like still

00:16:27,459 --> 00:16:32,920
valid JavaScript but we will probably

00:16:31,089 --> 00:16:34,959
fail at runtime if we use like some

00:16:32,920 --> 00:16:37,629
built-in method because it will reverse

00:16:34,959 --> 00:16:39,009
that nothing that won't exist but it's

00:16:37,629 --> 00:16:41,610
worth noticing that in practically

00:16:39,009 --> 00:16:45,339
speaking is still valid JavaScript

00:16:41,610 --> 00:16:48,160
okay so cool so now let's see what are

00:16:45,339 --> 00:16:51,939
the parts of like a bubble plugin so to

00:16:48,160 --> 00:16:54,209
write a bubble plugin it's just like

00:16:51,939 --> 00:16:56,920
exporting a function that will be called

00:16:54,209 --> 00:16:58,689
with a bubble object which is actually

00:16:56,920 --> 00:17:02,019
the API that were allowed to work with

00:16:58,689 --> 00:17:05,740
and in general the thing that were

00:17:02,019 --> 00:17:09,399
interested about from this object is the

00:17:05,740 --> 00:17:11,470
types like bubble the types and for

00:17:09,399 --> 00:17:13,990
convention and this is what a is to

00:17:11,470 --> 00:17:17,260
explore does by default it LS is that -

00:17:13,990 --> 00:17:20,589
at the T variable so but in general the

00:17:17,260 --> 00:17:21,909
T is just bubbled out types but all the

00:17:20,589 --> 00:17:23,350
types is something that you can look at

00:17:21,909 --> 00:17:25,959
the India document in that orientation

00:17:23,350 --> 00:17:31,029
so if you go to the bubble docs in

00:17:25,959 --> 00:17:36,760
bubble Jas dot IO talks you have the

00:17:31,029 --> 00:17:38,500
types here at the bottom that when you

00:17:36,760 --> 00:17:40,270
click you have like the documentation

00:17:38,500 --> 00:17:46,120
for all of the things that it provides

00:17:40,270 --> 00:17:47,830
which are like a bunch cool so we're

00:17:46,120 --> 00:17:48,500
gonna be seeing those some of those in a

00:17:47,830 --> 00:17:51,350
while

00:17:48,500 --> 00:17:52,790
and then the thing that needs to return

00:17:51,350 --> 00:17:56,780
like that that function needs to return

00:17:52,790 --> 00:17:58,570
in again like this away this comment and

00:17:56,780 --> 00:18:01,070
since it's not required let's remove it

00:17:58,570 --> 00:18:03,680
you need to return an object that has a

00:18:01,070 --> 00:18:04,940
field called visitor and that that is

00:18:03,680 --> 00:18:07,670
the interesting part of like that's the

00:18:04,940 --> 00:18:10,040
meat of the of the plug-in itself that

00:18:07,670 --> 00:18:12,350
visitor is actually an object that will

00:18:10,040 --> 00:18:14,120
be called in each node and will be

00:18:12,350 --> 00:18:15,770
executing some functions that we define

00:18:14,120 --> 00:18:20,870
on it based on the type of the node that

00:18:15,770 --> 00:18:22,330
were visiting so in this case this this

00:18:20,870 --> 00:18:24,560
method will be called for all the

00:18:22,330 --> 00:18:26,600
identifier nodes that we find in our I

00:18:24,560 --> 00:18:29,090
inner ast for the for the code that we

00:18:26,600 --> 00:18:31,550
wrote so this is an identifier this is

00:18:29,090 --> 00:18:33,770
an identifier this is also an identifier

00:18:31,550 --> 00:18:36,800
this is not an identifier this is a

00:18:33,770 --> 00:18:39,590
string literal the if statement is not

00:18:36,800 --> 00:18:44,060
identifier as an if statement so you can

00:18:39,590 --> 00:18:45,670
you can can probably see what's what's

00:18:44,060 --> 00:18:48,980
actually can I do

00:18:45,670 --> 00:18:50,810
and the identifier will receive another

00:18:48,980 --> 00:18:52,760
object which is the path which is

00:18:50,810 --> 00:18:54,860
actually a wrapper of the node itself

00:18:52,760 --> 00:18:57,320
it's a wrapper because it also provides

00:18:54,860 --> 00:19:01,250
you with some helpful methods for

00:18:57,320 --> 00:19:06,080
example like the the most common one

00:19:01,250 --> 00:19:10,340
probably is like path dot replace with

00:19:06,080 --> 00:19:12,920
and we can replace the the node with

00:19:10,340 --> 00:19:14,690
anything we want and for that we're

00:19:12,920 --> 00:19:17,810
probably when we using like a function

00:19:14,690 --> 00:19:19,130
from the T of T variable which is to

00:19:17,810 --> 00:19:22,580
create a new node for example let's

00:19:19,130 --> 00:19:28,060
replace every identifier with a string

00:19:22,580 --> 00:19:28,060
literal this probably won't work because

00:19:28,210 --> 00:19:33,380
some some cases like some things are not

00:19:30,860 --> 00:19:36,560
allowed to be yeah so let's replace it

00:19:33,380 --> 00:19:42,110
with another identifier that has a word

00:19:36,560 --> 00:19:43,490
hello okay so let's do something else

00:19:42,110 --> 00:19:48,310
let's not replace identifiers with the

00:19:43,490 --> 00:19:51,020
interface race the Member expressions

00:19:48,310 --> 00:19:52,880
okay yeah so we grabbing stuff running

00:19:51,020 --> 00:19:55,880
all the enterprise because that may run

00:19:52,880 --> 00:19:57,260
into some syntactic error like the thing

00:19:55,880 --> 00:20:00,560
that I mentioned before that not every

00:19:57,260 --> 00:20:02,360
tree manipulation is actually valid but

00:20:00,560 --> 00:20:05,570
replacing member expressions

00:20:02,360 --> 00:20:09,050
or like simplifying for example this to

00:20:05,570 --> 00:20:10,370
this is actually valid so here what

00:20:09,050 --> 00:20:12,260
we're doing is like replacing every

00:20:10,370 --> 00:20:15,410
instance of member expression which are

00:20:12,260 --> 00:20:18,830
like calls to like a nested object like

00:20:15,410 --> 00:20:20,360
an object calling a member of it will be

00:20:18,830 --> 00:20:22,240
replaced by an identifier that's called

00:20:20,360 --> 00:20:24,890
hello so you can see here like hello

00:20:22,240 --> 00:20:27,890
hello here when we had process that I am

00:20:24,890 --> 00:20:32,720
but also here and also here

00:20:27,890 --> 00:20:34,280
like not in this case because it's not

00:20:32,720 --> 00:20:39,320
this is not a member expression is just

00:20:34,280 --> 00:20:40,910
an identifier cool so now let's work on

00:20:39,320 --> 00:20:43,400
what we actually want to do we want to

00:20:40,910 --> 00:20:46,370
build a babel plugin in this example

00:20:43,400 --> 00:20:51,020
that works similarly to what the define

00:20:46,370 --> 00:20:52,460
plugin web pack does so probably not

00:20:51,020 --> 00:20:54,890
everyone is familiar with what that

00:20:52,460 --> 00:20:58,250
thing does so what we want to do is like

00:20:54,890 --> 00:21:00,410
replace some expression in the code with

00:20:58,250 --> 00:21:02,690
some like constant like literal thing

00:21:00,410 --> 00:21:04,550
that will be like replaced like with the

00:21:02,690 --> 00:21:07,610
literal so in this case we want to

00:21:04,550 --> 00:21:09,500
inline the process that am no down to

00:21:07,610 --> 00:21:12,140
the actual know them when we compile the

00:21:09,500 --> 00:21:14,600
code for example so we can see here that

00:21:12,140 --> 00:21:17,720
we want to actually convert this if

00:21:14,600 --> 00:21:19,700
expression for example into production

00:21:17,720 --> 00:21:21,890
like we want to replace process em down

00:21:19,700 --> 00:21:23,660
them to production if the node amp is

00:21:21,890 --> 00:21:25,310
production like imagine that we want to

00:21:23,660 --> 00:21:27,470
replace that with development if the

00:21:25,310 --> 00:21:29,390
node n bits development this is good for

00:21:27,470 --> 00:21:30,830
production like it helps with

00:21:29,390 --> 00:21:33,500
performance and both the sides because

00:21:30,830 --> 00:21:36,050
when we run this final code through a

00:21:33,500 --> 00:21:38,510
mini fire those will be like optimize

00:21:36,050 --> 00:21:40,430
and will be like strip like that we will

00:21:38,510 --> 00:21:42,980
run like that code elimination like in

00:21:40,430 --> 00:21:44,750
the sense that the branches that will

00:21:42,980 --> 00:21:47,030
actually always be false will be

00:21:44,750 --> 00:21:48,890
stripped out of the code so that's less

00:21:47,030 --> 00:21:52,730
code and less checks to to do when

00:21:48,890 --> 00:21:55,610
everything runs faster so another

00:21:52,730 --> 00:21:57,860
example here want to do this in this

00:21:55,610 --> 00:22:00,320
case again replace replace process n

00:21:57,860 --> 00:22:02,480
million but we don't want to replace

00:22:00,320 --> 00:22:04,160
this one because this is not process dot

00:22:02,480 --> 00:22:06,080
m dot no them this is just process the

00:22:04,160 --> 00:22:09,100
lamp and also we don't want to change

00:22:06,080 --> 00:22:12,530
anything that has nothing to do with

00:22:09,100 --> 00:22:14,260
that not M so the first thing to write a

00:22:12,530 --> 00:22:15,860
plug-in is to actually identify what

00:22:14,260 --> 00:22:19,669
pattern in the

00:22:15,860 --> 00:22:21,320
we want to identify so in this case we

00:22:19,669 --> 00:22:24,409
know we want to replace process that M

00:22:21,320 --> 00:22:27,559
don't know them so we just click on that

00:22:24,409 --> 00:22:30,649
in the source code and see if we can

00:22:27,559 --> 00:22:33,110
find the thing that highlights the whole

00:22:30,649 --> 00:22:35,500
thing cool so it seems that it's a

00:22:33,110 --> 00:22:38,779
member expression

00:22:35,500 --> 00:22:40,610
let's move this a little bit down so

00:22:38,779 --> 00:22:43,640
it's a member expression where the

00:22:40,610 --> 00:22:45,140
object is also a member expression so we

00:22:43,640 --> 00:22:48,529
see like there's a nesting of member

00:22:45,140 --> 00:22:51,620
expressions where the inner one has the

00:22:48,529 --> 00:22:54,320
object to the object is an identifier

00:22:51,620 --> 00:22:57,679
with name process and the property is

00:22:54,320 --> 00:23:00,289
another identifier with name M and the

00:22:57,679 --> 00:23:06,860
outer property so the the property of

00:23:00,289 --> 00:23:08,740
the whole process dot M thing here is

00:23:06,860 --> 00:23:11,870
also an identifier with the node M

00:23:08,740 --> 00:23:14,990
string literal so that's what we want to

00:23:11,870 --> 00:23:17,750
detect and then the other part of like

00:23:14,990 --> 00:23:20,330
writing a plug-in is seeing what we want

00:23:17,750 --> 00:23:22,190
to compare that to so basically we want

00:23:20,330 --> 00:23:25,429
to convert that to the production string

00:23:22,190 --> 00:23:26,450
literal so we click on any other similar

00:23:25,429 --> 00:23:28,880
thing that we have in the code or

00:23:26,450 --> 00:23:34,039
rewrite it if we don't have it so that's

00:23:28,880 --> 00:23:38,360
literally string literal with the value

00:23:34,039 --> 00:23:40,580
that we want so basically we pretty much

00:23:38,360 --> 00:23:42,440
have this here like this is what we want

00:23:40,580 --> 00:23:43,700
to do like we want to identify member

00:23:42,440 --> 00:23:46,250
expressions and replace them with

00:23:43,700 --> 00:23:50,899
identifiers so let's define let's

00:23:46,250 --> 00:23:54,320
imagine that we have let's imagine that

00:23:50,899 --> 00:23:58,730
we're in production and then we want to

00:23:54,320 --> 00:24:01,580
replace that with whatever no them does

00:23:58,730 --> 00:24:03,080
and instead of an identifier we want to

00:24:01,580 --> 00:24:05,419
we said we wanted to replace it with a

00:24:03,080 --> 00:24:07,909
string literal so we're using that T dot

00:24:05,419 --> 00:24:09,830
string literal function from T so you

00:24:07,909 --> 00:24:14,419
can you can see now that T provides you

00:24:09,830 --> 00:24:17,299
with a way to create nodes by passing

00:24:14,419 --> 00:24:20,149
some some arguments to each type of node

00:24:17,299 --> 00:24:21,320
and it has methods for each type that

00:24:20,149 --> 00:24:23,630
you want to create this is all

00:24:21,320 --> 00:24:28,130
documented in here so if you say for

00:24:23,630 --> 00:24:29,600
example string literal yeah this is like

00:24:28,130 --> 00:24:30,800
what we're using so

00:24:29,600 --> 00:24:33,920
there also that there are some like

00:24:30,800 --> 00:24:36,050
helpful methods to check if some node is

00:24:33,920 --> 00:24:39,920
of certain type which is something that

00:24:36,050 --> 00:24:43,250
we're going to be using now okay so we

00:24:39,920 --> 00:24:45,140
are now transforming stuff to what we

00:24:43,250 --> 00:24:46,550
want but it's not really exactly

00:24:45,140 --> 00:24:48,320
everything that we want to transform

00:24:46,550 --> 00:24:50,690
what's transforming more things than we

00:24:48,320 --> 00:24:53,480
want in this code base so this is okay

00:24:50,690 --> 00:24:55,460
this is what we want this is also okay

00:24:53,480 --> 00:24:57,280
this is what we want but this is not

00:24:55,460 --> 00:25:00,890
okay so we don't want to actually

00:24:57,280 --> 00:25:02,300
transform this and yeah I think that's

00:25:00,890 --> 00:25:04,760
it for this example

00:25:02,300 --> 00:25:07,400
this is already not changed because

00:25:04,760 --> 00:25:10,880
we're not detecting early checking for

00:25:07,400 --> 00:25:12,860
member expressions and this is not a

00:25:10,880 --> 00:25:15,470
member expression this is an identifier

00:25:12,860 --> 00:25:18,010
directly okay so let's look at the

00:25:15,470 --> 00:25:21,500
pattern we said that we wanted to have

00:25:18,010 --> 00:25:24,890
we want we had a nested member

00:25:21,500 --> 00:25:27,860
expression that we wanted to look so

00:25:24,890 --> 00:25:31,660
let's check for that so to get tagged to

00:25:27,860 --> 00:25:35,870
get an access to the node we just use

00:25:31,660 --> 00:25:37,610
path we use path dot node path that node

00:25:35,870 --> 00:25:38,960
will return us that the object that we

00:25:37,610 --> 00:25:41,000
saw in the example before which is like

00:25:38,960 --> 00:25:44,540
just a literal plain JavaScript object

00:25:41,000 --> 00:25:46,430
with these properties so we can get past

00:25:44,540 --> 00:25:48,860
that note that object path the note that

00:25:46,430 --> 00:25:50,360
property another so since we know that

00:25:48,860 --> 00:25:52,370
is a member expression we have those two

00:25:50,360 --> 00:25:58,430
fields being the object and property so

00:25:52,370 --> 00:26:02,750
we can say okay I want the inner member

00:25:58,430 --> 00:26:04,580
and this is path that noted object but I

00:26:02,750 --> 00:26:10,820
actually want to check that the inner

00:26:04,580 --> 00:26:19,270
object is a member expression so if is

00:26:10,820 --> 00:26:19,270
not a member member member

00:26:21,940 --> 00:26:28,280
we just bail out so we don't care about

00:26:26,380 --> 00:26:30,320
member expressions that don't have a

00:26:28,280 --> 00:26:32,179
nested member expression because we are

00:26:30,320 --> 00:26:33,559
looking for that pattern so not finally

00:26:32,179 --> 00:26:36,169
what we need to check is that all the

00:26:33,559 --> 00:26:40,030
properties the property identifiers have

00:26:36,169 --> 00:26:43,490
the right values so in the inner member

00:26:40,030 --> 00:26:45,860
here we want to check that the object is

00:26:43,490 --> 00:26:47,990
of has a name process and the property

00:26:45,860 --> 00:26:50,090
has the name end and for the outer

00:26:47,990 --> 00:26:52,130
member expression we want to check that

00:26:50,090 --> 00:26:54,740
the property has the name node and so

00:26:52,130 --> 00:27:01,179
let's write that so let's call this

00:26:54,740 --> 00:27:04,970
create a variable called is process and

00:27:01,179 --> 00:27:07,850
it will be like a set of conditions so

00:27:04,970 --> 00:27:13,600
let's say okay so in our member dot

00:27:07,850 --> 00:27:19,669
object dot name should be equal to

00:27:13,600 --> 00:27:25,610
process and inner member dot property

00:27:19,669 --> 00:27:28,850
dot name should be equal to and and the

00:27:25,610 --> 00:27:33,620
outer one which is in path dot node path

00:27:28,850 --> 00:27:43,789
to note that property dot name should be

00:27:33,620 --> 00:27:46,700
equal to node and and again this cool

00:27:43,789 --> 00:27:52,340
and finally we need to make the check so

00:27:46,700 --> 00:27:55,030
if it is a process and node and we do

00:27:52,340 --> 00:27:55,030
the replacement

00:27:58,440 --> 00:28:04,059
cool so yeah we seen an that now that

00:28:01,960 --> 00:28:06,730
worked so we see that the process dot M

00:28:04,059 --> 00:28:07,929
didn't change these two still changed

00:28:06,730 --> 00:28:10,929
and this one since we were never

00:28:07,929 --> 00:28:12,909
detecting for it don't do anything so

00:28:10,929 --> 00:28:15,429
yep that's it that's how we write a

00:28:12,909 --> 00:28:17,980
plug-in obviously there are some

00:28:15,429 --> 00:28:21,489
probably add some extra edge cases that

00:28:17,980 --> 00:28:24,909
we need to take care of but for the most

00:28:21,489 --> 00:28:26,320
part this is how you once you find an

00:28:24,909 --> 00:28:27,610
edge case it's just the detect in the

00:28:26,320 --> 00:28:37,409
pattern of the edge case and adding more

00:28:27,610 --> 00:28:37,409
conditions to not detect that education

00:28:37,440 --> 00:28:44,279
okay so as I mentioned before ast is not

00:28:42,669 --> 00:28:46,690
only up here up here in these two tools

00:28:44,279 --> 00:28:49,450
you will see them in the wild in price

00:28:46,690 --> 00:28:51,789
tool that you use nowadays like in the

00:28:49,450 --> 00:28:53,710
day in your day to day work they are all

00:28:51,789 --> 00:28:56,739
over the place for example for type

00:28:53,710 --> 00:28:59,919
checking type suite or flow the type

00:28:56,739 --> 00:29:05,139
checking is actually done by it like

00:28:59,919 --> 00:29:06,940
that detecting patterns in the ast post

00:29:05,139 --> 00:29:10,989
CSS for example that's a good one that

00:29:06,940 --> 00:29:13,179
we all use probably is the same thing as

00:29:10,989 --> 00:29:16,269
bubble but for CSS it allows us to use

00:29:13,179 --> 00:29:19,480
new CSS features and implement them in

00:29:16,269 --> 00:29:21,970
terms of like normal CSS that browsers

00:29:19,480 --> 00:29:24,279
understand and there are some other

00:29:21,970 --> 00:29:26,799
different usages of AST s for example

00:29:24,279 --> 00:29:28,419
prettier it's like an automated call

00:29:26,799 --> 00:29:31,239
formatting tool that probably some of

00:29:28,419 --> 00:29:33,070
you use and that the way that it works

00:29:31,239 --> 00:29:35,409
is that it takes your the source code it

00:29:33,070 --> 00:29:38,259
parses and transforms it into an AST and

00:29:35,409 --> 00:29:40,389
then prints it in an opinionated way so

00:29:38,259 --> 00:29:42,759
that it's always the same based on some

00:29:40,389 --> 00:29:45,220
configuration so that's how it achieves

00:29:42,759 --> 00:29:48,249
the like whatever you write in any way

00:29:45,220 --> 00:29:50,080
you write it and printed that back to

00:29:48,249 --> 00:29:56,830
something that is stable and consistent

00:29:50,080 --> 00:29:59,739
for all the team cool so I think well I

00:29:56,830 --> 00:30:02,470
hope that knowing about the STS will

00:29:59,739 --> 00:30:04,929
will sparkle some ideas for you so in

00:30:02,470 --> 00:30:06,940
general so for example like you could

00:30:04,929 --> 00:30:08,940
write a nice lean rule as we saw before

00:30:06,940 --> 00:30:11,380
to validate the deprecated component

00:30:08,940 --> 00:30:12,610
that is not using your app that's

00:30:11,380 --> 00:30:16,200
probably functions but he could also

00:30:12,610 --> 00:30:19,270
weave files or UI components or whatever

00:30:16,200 --> 00:30:20,890
you can also write a bubble plug-in to

00:30:19,270 --> 00:30:22,960
add contact context well debug

00:30:20,890 --> 00:30:25,059
parameters so every time you call an API

00:30:22,960 --> 00:30:27,429
or a function in development for trading

00:30:25,059 --> 00:30:30,400
the like extra information for for you

00:30:27,429 --> 00:30:32,470
to debug stuff you could use Babylon

00:30:30,400 --> 00:30:35,770
which is the bubbles parser to parse

00:30:32,470 --> 00:30:38,140
your application and extract I 18 I 18

00:30:35,770 --> 00:30:41,890
end messages statically written in your

00:30:38,140 --> 00:30:43,900
code like as variables for example and

00:30:41,890 --> 00:30:45,159
extract those into a file in a format

00:30:43,900 --> 00:30:46,780
that is suitable for you to send to a

00:30:45,159 --> 00:30:47,980
translation service for example in an

00:30:46,780 --> 00:30:51,070
automated way so you don't have to

00:30:47,980 --> 00:30:52,360
actually write them twice so in general

00:30:51,070 --> 00:30:54,669
whenever you have something that is

00:30:52,360 --> 00:30:56,710
readable that that should be readable in

00:30:54,669 --> 00:30:59,200
development but should be optimized for

00:30:56,710 --> 00:31:01,450
production that's usually probably a

00:30:59,200 --> 00:31:04,179
good use case for writing an ast plug-in

00:31:01,450 --> 00:31:05,650
if it's not written already whenever you

00:31:04,179 --> 00:31:10,210
want to generate some artifacts from the

00:31:05,650 --> 00:31:13,000
code like type definitions from a DSL

00:31:10,210 --> 00:31:16,929
like graph QL or or any other like

00:31:13,000 --> 00:31:18,340
you're wrong even your own or sometimes

00:31:16,929 --> 00:31:20,169
if you want to automate or factors like

00:31:18,340 --> 00:31:24,039
you can specify how to manipulate that

00:31:20,169 --> 00:31:26,740
they are Steve from the original code to

00:31:24,039 --> 00:31:28,179
the like migration code and you can

00:31:26,740 --> 00:31:32,650
automate that with a with any of these

00:31:28,179 --> 00:31:34,570
tools so and if and if anything if you

00:31:32,650 --> 00:31:36,309
don't find that useful at all at least

00:31:34,570 --> 00:31:39,100
knowing about the STS will help you

00:31:36,309 --> 00:31:41,890
Google for things better so once you

00:31:39,100 --> 00:31:45,130
know that type of constructs for example

00:31:41,890 --> 00:31:46,330
this new proposal for optional like the

00:31:45,130 --> 00:31:49,990
thing that we saw in the beginning for

00:31:46,330 --> 00:31:52,000
the iidx library that's a proposal for

00:31:49,990 --> 00:31:55,539
in that that feature in JavaScript like

00:31:52,000 --> 00:31:57,520
the existential chain operator and

00:31:55,539 --> 00:31:59,289
that's in entertainment in an ast

00:31:57,520 --> 00:32:01,510
appears as an optional member expression

00:31:59,289 --> 00:32:03,700
so if you want to write it and find it

00:32:01,510 --> 00:32:05,919
as a hey what's the question mark after

00:32:03,700 --> 00:32:08,950
an identifier in JavaScript you will

00:32:05,919 --> 00:32:10,659
find lots of like confusing things but

00:32:08,950 --> 00:32:13,510
if you actually find for loop for that

00:32:10,659 --> 00:32:16,390
type of node in the SC you will probably

00:32:13,510 --> 00:32:20,370
find useful thing even like the proposal

00:32:16,390 --> 00:32:20,370
itself so you can find more information

00:32:20,610 --> 00:32:24,760
when I will be sharing the slides

00:32:22,809 --> 00:32:26,590
hopefully and a

00:32:24,760 --> 00:32:29,560
these are like the resources that I used

00:32:26,590 --> 00:32:31,930
to create this thing to learn about the

00:32:29,560 --> 00:32:34,930
SDS and to build it like to get the data

00:32:31,930 --> 00:32:37,960
for this talk you should follow these

00:32:34,930 --> 00:32:40,420
three people for sure they that they

00:32:37,960 --> 00:32:42,190
like shared a lot of kondal relate to

00:32:40,420 --> 00:32:46,450
this probably you should follow some of

00:32:42,190 --> 00:32:49,930
them already so I hope that next time

00:32:46,450 --> 00:32:54,160
that you are in like using any of these

00:32:49,930 --> 00:32:56,280
tools you look like this and yeah that's

00:32:54,160 --> 00:33:03,160
about it thank you

00:32:56,280 --> 00:33:03,160

YouTube URL: https://www.youtube.com/watch?v=N5v8Ul6ph90


