Title: Reason ML & React Native, Why Should I Bother - JS Roundabout - January 2020
Publication date: 2020-02-08
Playlist: The JS Roundabout
Description: 
	Sam Rowe from Red Badger. Talking about using ReasonML with React Native. ReasonML is a statically typed language that compiles to Javascript created by the original author of React. It provides a much safer and faster React development experience that we can make use of in React Native to produce apps with fewer bugs more quickly.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,310
all right hello everyone I'm Sam row and

00:00:02,790 --> 00:00:07,220
I work at red badger today we're going

00:00:05,310 --> 00:00:09,929
to be talking about what reason ml is

00:00:07,220 --> 00:00:15,929
and why might it be interesting for a

00:00:09,929 --> 00:00:17,970
reactor developer so reason ml is a new

00:00:15,929 --> 00:00:20,550
language we've really good react

00:00:17,970 --> 00:00:22,439
integration it's developed by Facebook

00:00:20,550 --> 00:00:25,410
and was actually created by Jordan walk

00:00:22,439 --> 00:00:28,380
the the same guy who created react

00:00:25,410 --> 00:00:30,179
originally so reason promises to give a

00:00:28,380 --> 00:00:32,600
much nicer and simpler development

00:00:30,179 --> 00:00:35,460
experience than JavaScript or typescript

00:00:32,600 --> 00:00:36,899
so now reason is actually a new syntax

00:00:35,460 --> 00:00:39,360
for a language that already exists

00:00:36,899 --> 00:00:42,960
called our camel and our camel is a

00:00:39,360 --> 00:00:44,520
functional programming language that's

00:00:42,960 --> 00:00:47,960
been around since the 90s and it

00:00:44,520 --> 00:00:50,250
compiles down to really fast native code

00:00:47,960 --> 00:00:52,020
now you might be thinking oh camel

00:00:50,250 --> 00:00:54,690
sounds like an odd choice for writing

00:00:52,020 --> 00:00:57,239
react apps but there's actually a tool

00:00:54,690 --> 00:01:00,059
made by bloomberg called buckle script

00:00:57,239 --> 00:01:03,960
that compels that camel down to light

00:01:00,059 --> 00:01:05,280
weight javascript so odds are though

00:01:03,960 --> 00:01:08,340
you've probably never heard of buckle

00:01:05,280 --> 00:01:10,830
script even if you have haven't if you

00:01:08,340 --> 00:01:12,450
have an encountered reason already as it

00:01:10,830 --> 00:01:14,520
hasn't seen that much adoption on its

00:01:12,450 --> 00:01:17,220
own

00:01:14,520 --> 00:01:20,310
and the reason for this is most likely

00:01:17,220 --> 00:01:22,080
that Oh camel has a very alien syntax

00:01:20,310 --> 00:01:25,080
compared to what most JavaScript

00:01:22,080 --> 00:01:29,280
developers are used to and this is where

00:01:25,080 --> 00:01:31,380
and this is where reason fits in so

00:01:29,280 --> 00:01:34,350
reason tries to smooth over the syntax

00:01:31,380 --> 00:01:36,450
and tooling to make oh camel and buckle

00:01:34,350 --> 00:01:40,350
script ecosystem a lot more accessible

00:01:36,450 --> 00:01:42,119
to JavaScript developers so all that

00:01:40,350 --> 00:01:44,850
this sounds like a lot of faff why would

00:01:42,119 --> 00:01:48,840
we bother what is what is there to like

00:01:44,850 --> 00:01:50,130
about reason ml well first of all you

00:01:48,840 --> 00:01:52,649
can actually get you a much simpler

00:01:50,130 --> 00:01:55,200
development experience much simpler

00:01:52,649 --> 00:01:56,640
tooling setup at the moment you probably

00:01:55,200 --> 00:01:59,820
have to work with a load of different

00:01:56,640 --> 00:02:03,180
tools like babel flow prettier

00:01:59,820 --> 00:02:04,799
typescript es lin we've reason their

00:02:03,180 --> 00:02:07,740
mouths these are all consolidated into

00:02:04,799 --> 00:02:09,179
one tool chain that does all of these

00:02:07,740 --> 00:02:10,830
tasks better than the individual

00:02:09,179 --> 00:02:12,420
JavaScript tools can on their own

00:02:10,830 --> 00:02:12,950
because they're all integrated into the

00:02:12,420 --> 00:02:14,840
language

00:02:12,950 --> 00:02:18,590
so let's run through these and see what

00:02:14,840 --> 00:02:20,750
the benefits are we get so flow in

00:02:18,590 --> 00:02:22,700
typescript both layer types on top of

00:02:20,750 --> 00:02:24,739
JavaScript I'm sure we've all had plenty

00:02:22,700 --> 00:02:27,200
of errors like undefined is not a

00:02:24,739 --> 00:02:30,350
function cannot read property X of

00:02:27,200 --> 00:02:32,510
undefined and in a dynamic language like

00:02:30,350 --> 00:02:36,110
JavaScript these kind of errors are very

00:02:32,510 --> 00:02:37,760
hard to avoid in a large code base now

00:02:36,110 --> 00:02:40,190
obviously not only is this bad for users

00:02:37,760 --> 00:02:43,099
who have to suffer suffer buggy Act but

00:02:40,190 --> 00:02:44,690
it also sucks for developers if every

00:02:43,099 --> 00:02:48,590
time you make a mistake you get an error

00:02:44,690 --> 00:02:50,780
in a far-off part of your app that you

00:02:48,590 --> 00:02:52,069
then have to work backwards from in

00:02:50,780 --> 00:02:53,870
order to find out where you actually

00:02:52,069 --> 00:02:56,230
went wrong that's going to slow down

00:02:53,870 --> 00:02:58,610
your development experience quite a bit

00:02:56,230 --> 00:03:00,590
so not to mention the time wasted

00:02:58,610 --> 00:03:02,299
debugging error reports like they're

00:03:00,590 --> 00:03:04,760
like well I press this button in the app

00:03:02,299 --> 00:03:07,340
and then it crashed and all of this

00:03:04,760 --> 00:03:10,549
slows down our developer expert and

00:03:07,340 --> 00:03:13,430
velocity so having a lot of unit and

00:03:10,549 --> 00:03:15,739
integration tests can help but again you

00:03:13,430 --> 00:03:17,390
have to take time to write write all

00:03:15,739 --> 00:03:20,200
these tests and they tend to be quite

00:03:17,390 --> 00:03:21,829
brittle so often you have to spend time

00:03:20,200 --> 00:03:26,930
updating them when you change the

00:03:21,829 --> 00:03:29,750
functionality of your app so now a good

00:03:26,930 --> 00:03:31,700
type system can help a lot for a small

00:03:29,750 --> 00:03:35,329
amount of effort adding type annotations

00:03:31,700 --> 00:03:37,850
to your code base can catch a large

00:03:35,329 --> 00:03:40,850
number of these errors at the source as

00:03:37,850 --> 00:03:42,680
you're coding without you having to wait

00:03:40,850 --> 00:03:46,489
for your code to run or your twist test

00:03:42,680 --> 00:03:50,030
suite to run to catch the bugs now both

00:03:46,489 --> 00:03:51,829
flow and tight script helping out here

00:03:50,030 --> 00:03:52,660
by letting you add types to good old

00:03:51,829 --> 00:03:55,190
JavaScript

00:03:52,660 --> 00:03:58,579
however javascript is a dynamic language

00:03:55,190 --> 00:04:00,260
and all the beats API is an idioms play

00:03:58,579 --> 00:04:03,260
to the strengths of a dynamic language

00:04:00,260 --> 00:04:04,609
not a statically typed bond so while

00:04:03,260 --> 00:04:06,950
they make it possible to achieve a lot

00:04:04,609 --> 00:04:09,709
of tight safety that doesn't they

00:04:06,950 --> 00:04:11,600
doesn't mean they make it easy the type

00:04:09,709 --> 00:04:16,780
system tends to be only as strong as you

00:04:11,600 --> 00:04:16,780
make it so you i've end up with a lot of

00:04:17,440 --> 00:04:22,360
lot of bose annotations or a lot of

00:04:20,180 --> 00:04:24,560
variables are implicitly tight as any

00:04:22,360 --> 00:04:25,830
which partially defeats the point of

00:04:24,560 --> 00:04:28,139
having a tight system in the first

00:04:25,830 --> 00:04:29,639
place so because it's a language

00:04:28,139 --> 00:04:32,520
designed for the ground up to support

00:04:29,639 --> 00:04:35,069
static types and exploit the benefits of

00:04:32,520 --> 00:04:38,039
them reason gives you a much more solid

00:04:35,069 --> 00:04:39,719
type system for a lot less typing being

00:04:38,039 --> 00:04:41,370
able to get instant feedback when you've

00:04:39,719 --> 00:04:43,229
made a mistake or forgotten something

00:04:41,370 --> 00:04:45,870
without having to switch out of your

00:04:43,229 --> 00:04:50,069
code editor can be a big productivity

00:04:45,870 --> 00:04:51,599
boost so another tool you've probably

00:04:50,069 --> 00:04:55,379
spent too much time configuring and

00:04:51,599 --> 00:04:56,729
setting up is Babel so reason ml is a

00:04:55,379 --> 00:04:59,550
compiled language that outputs

00:04:56,729 --> 00:05:01,770
JavaScript JSX is built into the

00:04:59,550 --> 00:05:04,500
language there's no syntax plugins or

00:05:01,770 --> 00:05:06,479
browser support lists to set up there's

00:05:04,500 --> 00:05:08,879
just one tool that type checks your code

00:05:06,479 --> 00:05:12,449
and then compiles it to some JavaScript

00:05:08,879 --> 00:05:15,960
that's widely supported so we can ditch

00:05:12,449 --> 00:05:17,219
Babel prettier is another great tool

00:05:15,960 --> 00:05:20,279
that you should all use if you don't

00:05:17,219 --> 00:05:22,319
already if you're not familiar it

00:05:20,279 --> 00:05:23,939
automatically formats your code so you

00:05:22,319 --> 00:05:25,770
don't so it saves you a bunch of typing

00:05:23,939 --> 00:05:28,919
and pointless arguments with your

00:05:25,770 --> 00:05:30,300
colleagues about formatting but again

00:05:28,919 --> 00:05:33,270
this is another tool you have to install

00:05:30,300 --> 00:05:35,610
configure self and editor plugin for the

00:05:33,270 --> 00:05:38,669
reason tool chain has a tool for this

00:05:35,610 --> 00:05:42,240
called reformat built in that also

00:05:38,669 --> 00:05:44,069
formats your code but it's included in

00:05:42,240 --> 00:05:47,069
the reason language server plug-in for

00:05:44,069 --> 00:05:49,949
your code editor so if you're using the

00:05:47,069 --> 00:05:52,169
reason vs code plug-in for example that

00:05:49,949 --> 00:05:54,419
single plug-in will handle syntax

00:05:52,169 --> 00:05:56,580
highlighting type checking compiling

00:05:54,419 --> 00:05:59,279
your code formatting your code all in

00:05:56,580 --> 00:06:00,479
one place rather than like you and

00:05:59,279 --> 00:06:02,879
everyone on your team having to install

00:06:00,479 --> 00:06:06,330
like eight different plugins to achieve

00:06:02,879 --> 00:06:08,699
the same thing and now when you have

00:06:06,330 --> 00:06:10,680
solid type checking automatic code

00:06:08,699 --> 00:06:13,349
formatting you don't really need a tool

00:06:10,680 --> 00:06:16,379
like yes Lynn checks for uninitialized

00:06:13,349 --> 00:06:18,509
variables and bad formatting are already

00:06:16,379 --> 00:06:20,400
handled by everything else it's and

00:06:18,509 --> 00:06:26,099
that's another config file and editor

00:06:20,400 --> 00:06:27,270
plugin we can get rid of so so now we

00:06:26,099 --> 00:06:28,789
have all these tools that are required

00:06:27,270 --> 00:06:32,250
for modern JavaScript development

00:06:28,789 --> 00:06:34,259
provided in one cohesive bundle now

00:06:32,250 --> 00:06:38,120
another benefit of reason ml is that

00:06:34,259 --> 00:06:38,120
it's a functional language by default

00:06:40,070 --> 00:06:44,600
so almost all the types and data

00:06:42,200 --> 00:06:46,220
structures in reason are immutable to

00:06:44,600 --> 00:06:48,620
fight by default and this plays really

00:06:46,220 --> 00:06:51,830
nicely with react where generally we

00:06:48,620 --> 00:06:52,910
only want to use immutable data but if

00:06:51,830 --> 00:06:56,210
you do find yourself in a situation

00:06:52,910 --> 00:07:00,410
where you need to use a little bit of

00:06:56,210 --> 00:07:03,920
mutation you can explicitly mark

00:07:00,410 --> 00:07:07,580
variables or field in an object as being

00:07:03,920 --> 00:07:09,530
mutable we can use a for loop if you

00:07:07,580 --> 00:07:13,070
want to avoid drawing some crazy reduce

00:07:09,530 --> 00:07:15,680
function so all of this is a very prime

00:07:13,070 --> 00:07:17,990
at pragmatic approach especially for

00:07:15,680 --> 00:07:19,940
beginners to functional programming so

00:07:17,990 --> 00:07:23,170
having all our variables and data

00:07:19,940 --> 00:07:25,730
immutable by default prevents a lot of

00:07:23,170 --> 00:07:28,040
accidental errors where we can still use

00:07:25,730 --> 00:07:30,020
mutations if we have to and it's

00:07:28,040 --> 00:07:32,810
explicitly signposted in our code when

00:07:30,020 --> 00:07:36,650
we do so another really cool feature of

00:07:32,810 --> 00:07:38,690
reason ml is variants the reason to swap

00:07:36,650 --> 00:07:41,390
Doc's describe them best

00:07:38,690 --> 00:07:44,080
so most most favorite structures in most

00:07:41,390 --> 00:07:46,730
languages are about having this and that

00:07:44,080 --> 00:07:50,030
whereas a variant allows us to express

00:07:46,730 --> 00:07:52,640
this or that so here's an example of

00:07:50,030 --> 00:07:54,740
what a variant looks like at the top and

00:07:52,640 --> 00:07:58,610
that says the any variable which has the

00:07:54,740 --> 00:08:02,900
type my response variant is either going

00:07:58,610 --> 00:08:04,670
to be a yes a no or pretty much now to

00:08:02,900 --> 00:08:06,800
do something useful with a variant we

00:08:04,670 --> 00:08:09,680
use probably the best feature of reason

00:08:06,800 --> 00:08:12,080
ml which simply doesn't exist in

00:08:09,680 --> 00:08:15,560
JavaScript typescript or flow which is

00:08:12,080 --> 00:08:19,340
pattern matching it looks similar to a

00:08:15,560 --> 00:08:23,420
switch statement in JavaScript both much

00:08:19,340 --> 00:08:26,210
more concise so we just list out all the

00:08:23,420 --> 00:08:28,580
constructors in our variant and then we

00:08:26,210 --> 00:08:31,760
can specify what we want to do with each

00:08:28,580 --> 00:08:34,190
in each case if we forget to handle one

00:08:31,760 --> 00:08:36,500
of the options then the compiler will

00:08:34,190 --> 00:08:38,060
automatically catch the mistake and give

00:08:36,500 --> 00:08:42,650
us an error telling us to add the

00:08:38,060 --> 00:08:44,570
missing constructors also each

00:08:42,650 --> 00:08:47,900
constructor in our variants can hold

00:08:44,570 --> 00:08:50,250
extra data that we can then extract and

00:08:47,900 --> 00:08:52,500
use when pattern matching

00:08:50,250 --> 00:08:56,960
so here Instagram holds a string

00:08:52,500 --> 00:09:00,630
Facebook holds a string and an integer

00:08:56,960 --> 00:09:06,210
so let's see a real-world example of a

00:09:00,630 --> 00:09:08,150
very commonly variant called option so

00:09:06,210 --> 00:09:10,800
this is used to model nullable types

00:09:08,150 --> 00:09:14,640
where in JavaScript you might use null

00:09:10,800 --> 00:09:16,590
or undefined for example it's so if we

00:09:14,640 --> 00:09:18,960
do have a value then we store it as a

00:09:16,590 --> 00:09:22,590
sum if we don't have a value restore as

00:09:18,960 --> 00:09:25,260
a none as reason forces you to handle

00:09:22,590 --> 00:09:27,750
both of these cases we can never get a

00:09:25,260 --> 00:09:29,580
null error this is how reason could save

00:09:27,750 --> 00:09:33,930
you from a lot of cannot read property X

00:09:29,580 --> 00:09:35,810
of undefined errors now variants are a

00:09:33,930 --> 00:09:39,300
really great tool for modeling state

00:09:35,810 --> 00:09:41,400
often different fields in your state are

00:09:39,300 --> 00:09:46,170
only meaningful when your app is in a

00:09:41,400 --> 00:09:48,120
particular state so they're so variants

00:09:46,170 --> 00:09:50,580
let you only keep the field they're

00:09:48,120 --> 00:09:53,790
actually meaningful when your app is in

00:09:50,580 --> 00:09:55,620
a particular state and the compilers

00:09:53,790 --> 00:09:57,330
type checking will always make sure you

00:09:55,620 --> 00:10:01,770
handle every possible state your app is

00:09:57,330 --> 00:10:03,690
in so and bad state is a huge source of

00:10:01,770 --> 00:10:06,030
bugs which can be mostly eliminated

00:10:03,690 --> 00:10:08,670
using variance and it's also a much

00:10:06,030 --> 00:10:10,380
nicer way to model your state so that's

00:10:08,670 --> 00:10:12,960
a high-level overview of the main

00:10:10,380 --> 00:10:15,570
benefits of reason ml hopefully that's

00:10:12,960 --> 00:10:17,100
piqued your interest hopefully you might

00:10:15,570 --> 00:10:20,270
see if it's good fit to your team so

00:10:17,100 --> 00:10:20,270
thanks any questions

00:10:24,810 --> 00:10:32,769
how easy is it to keep existing code

00:10:27,670 --> 00:10:37,269
base yeah it's really straightforward so

00:10:32,769 --> 00:10:40,500
the reason compiler will convert each

00:10:37,269 --> 00:10:42,570
reason file into one corresponding

00:10:40,500 --> 00:10:45,639
javascript file is a one-to-one mapping

00:10:42,570 --> 00:10:48,240
in line with where your reason files are

00:10:45,639 --> 00:10:51,480
kept so if you have like module dot

00:10:48,240 --> 00:10:53,709
reason that will then become module

00:10:51,480 --> 00:10:57,550
JavaScript and then you can just

00:10:53,709 --> 00:11:04,360
implement code import module JavaScript

00:10:57,550 --> 00:11:06,040
as you would usually know just played

00:11:04,360 --> 00:11:08,139
around with it whilst on the bench but

00:11:06,040 --> 00:11:11,610
to see if it would be a good fit for a

00:11:08,139 --> 00:11:11,610
project so what you're not

00:11:12,370 --> 00:11:15,460
[Music]

00:11:21,190 --> 00:11:25,540
fair enough I mean it is so he's a quite

00:11:23,290 --> 00:11:30,000
new language things only like three four

00:11:25,540 --> 00:11:32,920
years old perhaps I mean I can't really

00:11:30,000 --> 00:11:34,570
say for sure why it's not more widely

00:11:32,920 --> 00:11:36,370
used

00:11:34,570 --> 00:11:38,589
I think perhaps because it's still in

00:11:36,370 --> 00:11:41,230
early moment there's still rough edges I

00:11:38,589 --> 00:11:46,269
did find it overall pretty good to use

00:11:41,230 --> 00:11:48,490
when I tried it out but there definitely

00:11:46,269 --> 00:11:49,630
are some rough edges like certain tools

00:11:48,490 --> 00:11:51,250
like webpack you still have to use

00:11:49,630 --> 00:11:53,440
webpack set that up to compile your

00:11:51,250 --> 00:11:54,940
reason so it's not quite fully there

00:11:53,440 --> 00:11:58,860
when there's like I think an all-in-one

00:11:54,940 --> 00:12:01,870
tool that compiles your reason and

00:11:58,860 --> 00:12:04,089
reason code and bundles it and does the

00:12:01,870 --> 00:12:06,250
fool like producing a bundle for

00:12:04,089 --> 00:12:09,990
production I think Matt's when it would

00:12:06,250 --> 00:12:09,990
probably become a lot more popular

00:12:22,740 --> 00:12:30,520
yeah I find it fairly straightforward to

00:12:25,150 --> 00:12:32,680
create my own toppings for indexdb so

00:12:30,520 --> 00:12:35,310
they're also there's like community

00:12:32,680 --> 00:12:38,260
packages out there for like sort of like

00:12:35,310 --> 00:12:40,570
reason react native which can provides

00:12:38,260 --> 00:12:48,760
like types for a lot of the built in

00:12:40,570 --> 00:12:52,150
react native code I guess but yet so

00:12:48,760 --> 00:12:55,150
generally usually they'll be for a big

00:12:52,150 --> 00:12:58,390
plug for big projects they'll usually be

00:12:55,150 --> 00:13:00,310
something like called like BS whatever

00:12:58,390 --> 00:13:03,360
the name of the packages which is the

00:13:00,310 --> 00:13:06,220
buccal scripts tight for that package

00:13:03,360 --> 00:13:08,050
similar to how you have like definitely

00:13:06,220 --> 00:13:10,240
types types for typescript it's a

00:13:08,050 --> 00:13:13,570
similar sort of thing there it's not too

00:13:10,240 --> 00:13:17,170
hard to write your own I would say but

00:13:13,570 --> 00:13:20,320
yeah also you can just use JavaScript

00:13:17,170 --> 00:13:23,460
I'm tight if you want to but obviously

00:13:20,320 --> 00:13:23,460
there you're giving up type safety

00:13:24,460 --> 00:13:27,469

YouTube URL: https://www.youtube.com/watch?v=Pqs81Vj8ZH8


