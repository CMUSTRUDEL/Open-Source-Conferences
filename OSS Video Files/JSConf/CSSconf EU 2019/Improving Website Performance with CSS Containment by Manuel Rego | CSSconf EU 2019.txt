Title: Improving Website Performance with CSS Containment by Manuel Rego | CSSconf EU 2019
Publication date: 2019-07-10
Playlist: CSSconf EU 2019
Description: 
	CSS Containment (https://drafts.csswg.org/css-contain) is a new standard focused on improving the rendering performance of web pages by allowing the isolation of a subtree from the rest of the page. User agents that implement the “contain” property take advantage of this feature to apply strong optimizations therefore significantly boosting the performance of the web page. In this talk we will provide an introduction to this specification, explaining the types of containment available and the different use cases for each of them.

We will also take a look at some examples of optimizations implemented in the rendering engine based on css-contain. Finally, we will review the status of CSS containment on the different browsers and future plans regarding this new feature.
Captions: 
	Hello everyone andThanks the organization for giving me the chance to give this talk here, in the last CSSconf edition in this type or whateverSo it's really a pleasure and an honor to be here in this great conferenceSo the title of my talk is "Improving Website Performance with CSS Containment"So quite a long title even doesn't fit on the slide, so I will go over it slowlySo first, let's explain a little bit about me. I'm Manuel RegoI'm part of Igalia Web Pplatform team. Igalia is an open source consultancy thathas aCooperative like structure, so we have people all around the globedespite the headquarter are in Spain andwe have a large team working on browsers and we having implementing in several CSSspecifications and other things on browsersI have been working on Grid Layout mostly for several yearsAnd also other specs in Blink and WebKit and now I'm working also in the CSS ContainmentAnd as part of all these work I having interacting more and more with the CSS Working Group peoplePutting issues participating in discussions and finally joined the group like two years agoSoYeah the spec I mean the talk is about CSS Containment. This is a CSS specthis spec has a property that is called "contain" and it has four values "layout", "paint", "size" and "style" and that's allWe are almost doneI mean, it's very simple in theoryBut I think is going to be tricky to explainMaybe you watched some of my talks about Grid Layout or read some of my blog post about it.I meanGrid has tons of properties, many different values for each of them and all thatBut I believe it's easier to understand that maybe CSS ContainmentSo let's see if I manage to do it properly and you don't get very boredSo the other part of the title was improving website performanceSo basically you can improve the performance of a website in many different partsYou can improve how images are loaded or the resources or whatever. In this case is more about the rendering pipelineThese are somehow the main phases from a very nice article by Lin ClarkSo you have like where you compute the style you do the layout where you arePositioning the things then you paint and then you composite the layersAnd basically with CSS Containment you're going to be able to get performance benefits in this pipelineSo, let's go to the spec, the spec is now candidate recommendationSo it's quite a stable at this stageAnd we will explain how it works and try to explain the different options and all that. So basically the main goal ofCSS Containment is to improve the performance of a website byidentifying theindependent parts of a website which areparts of the DOM tree that doesn't have to interact with the rest, so somehow it's like isolatingthat subtree from the rest of the pageIn a way that if you do modifications inside that subtreethey don't get propagated outside so you don't need to do work in theancestors and all thatOne confusing thing about containment when you first read about it or you hear about it is thatis not that things outside cannot affect the elements inside, is not top to bottom. But is the other way aroundThings inside that element are not going to affect anything outsideSo this is a sentenceBy Tab Atkins, one of the spec editors, that he usually needs to repeat over a over in the CSS Working Group meetings"contain" property doesn't block things going into the subtree, it blocks things leaking outSo it's quite relevant for all the containment stuffSo yeah, I already say that. This spec only introduces a new property, which name is "contain"So it's very easy to remember and this property has four values, main values, or types of containmentslayout, paint, size, style. You can just put one or put two combine or combine the four, you can do whatever you want therestyle is red in the slides because it's market as at risk now in the spec, so we will talk more later about thatSo imagine this is a website. You have some content, some text, the header, whatever andyou know that you have a component, maybe in the top left cornerFor example that you are showing some live information that you are getting or showingan animation or whatever, but you know that's totally independent from the rest of the pageSo you identify that part, mark it like a contained elementAnd when the browser does work there, it doesn't need to care about the rest of the pagesThe page is very big or very complex DOM tree or whateverThe browser doesn't need to spend any single time in doing other stuffSo basically what web authors will need to do is to identifywhich are that independent parts of a website and mark them with the "contain" property and thenThe browser engine needs to dosomething because it's not just parse the property andimplement the restrictions but also it needs to implement some optimizations and avoid doing extra work. Browser engines usuallyTry to do as less work as possibleWhen you do a change in a website, they have some kind of heuristics in order to achieve thatBut still there are many corner cases and many combinations of thingsSo when you do a change on a single element that you believe isNot going to affect anything elseThe browser still needs to maybeCheck all the siblings just in case your overflowing content and you need to paint something in other parts of whateverAnd when you use containment, you have some kind of restrictions or implications of using itso you cannot just put "contain" to all the elements and you are done you need toTo put it when it makes senseso there areLike this four type of containers we are going to reviewFirst one for example layout containment. Basically here that means that the internal layout of the isolated subtreeIs totally isolated from the rest of the tree. So the element where you put "contain: layout"The layout of that element is totally independent of the ancestorso these are the effects it takes to element. Any overflow on that element is treated as ink overflow flowlike shadows for example, I'll show an example laterThat element becomes a containing block for absolute and fixed position and descendantsit also creates a new stacking context and independent formating context like display flow-root andAlso that the element has no baseline. So why theseRestrictions when you use it. So let's see an example of this ink overflow thing. We have here twodivs that one has"contain: none" the other "contain: layout", is the magenta dotted border the element that has the "contain: none" or "contain: layout"So if the size of the text is changing here you see that anscrollbar is appearing on the parent element. So the browserSomething changes inside and needs to do work outside like painting this scrollbarBut with "contain: layout" it doesn't need to do anything outsidethis istreated as ink overflow, like shadowsYou cannot access it actuallyBut I mean the browser can avoid doing any work in the parents checking if there are overflow and it needs to paintto show a scrollbar like hereSimilar is for baseline. I say that when you use layout containment the element is considered to have no baselineSo basically is the same, here in the "contain: none"you see that the "foo" is aligned with the "bar" in the other one if use thesynthesized baseline that is the underline in this case, if the size changes inside the browser needs to move foo alittle bit belowhowever with "contain: layout" something changes inside but the browserDoesn't care. I mean it can save time and avoid that kind of operationsSo another type of containment is paint containment, which is pretty similar to "overflow: hidden," but also has someEffects so basically the descendants cannot be displayed outside of the boundaries of that elementBut again it has some effects, contents are clipped like with "overflow: hidden", but also it becomes the containing block forpositioned descendants/children, it also creates a stacking content and independent formatting context. So let's see another exampleSo we have "contain: none" again in the dotted magentaelement and "contain: paint" and we have an absolute positioned at the element that has-So it's positioned against the parent, it means the viewport or whateverAnd in the other case is positioned against the container element is moved a little bit leftand top and alsotheoverflowing things are clippedSo when you change the colorHere the browser needs to paint also things outside that element but here the browser needs to paintthings insideso againIf you have an element with content paint that is not in the viewport the browser can avoiddoing work on it doing, doing any painting becausethe browser is sure that there are notsomething overflowing that that is painted in the viewport or whatever, they know that they can save that the timeSize containment is about how the browser computes the size of an elementBasically, if you put "contain: size" is going to ignore the childrenso the element is treated as having no contents, only things like padding add space orcolumn-gap if you have multi column or the tracks in grid something like thatyou already defined, but not the contents itself. And also it's monolithicThat means that you cannot split it when you print it or it's in multi column or things like that.So again, this is the same example again. So the first elementThe size depends on the contents is "Hello World!"andwhen the contents change the size changesbut in this case, only is the padding the one that is defining the size of that element, if thecontents change it doesn't care. You see that it's overflowingThe thing is that when you combine this with the other ones, the browser can say, okayI know for sure that nothing is going to change outside, even the size isn't going to affect anything outside and all thatAnd then last one is style containmentThis is somehow special because it only affects counters and quotes.I don't know if you use them a lot. I guess no because it's not very common, butat least is on the spec andIt's currently market as at risk, because the scope is maybe too narrow only counter and quotesSo there are some discussions about if it's worth. Firefox for example is not implementing this so farSo that's another reason why is at risk in the spec? Because they don't see the benefitAnd also chroming implementation of style containment is pretty broken so only works for the very simple casesso if any of you find a use case thatCan get performances benefit with style containment share with the CSS Working Group at the GitHub repositoryBecause that will be valuable information to know if we need to keep or not this valueso basically the effects are that the counters and quotes are scoped to the subtree andThat when you try to increment a counter you actually are creating a new one instead of incrementing itSo basically, just an example with countersThis is a class that is incrementing this counter "n" and this is just an element that paints the counterSo we are here creating this counter "n" and increment it to then we have a"contain: style" element, so this counter inside cannot increment the one outside so it creates a new oneso we have here When we print it after outside of the contained element, this doesn't know anything of what happened inside with the counterSo that's what's isolated, so still Then with quotes, quotes are I think even aless common use caseSo you can defineWhich symbols are you using when you havenested quotes. So this is double first and then single or whatever and then we are opening a quote hereWe have "foo" then we have the style containment element and we open another quotewe have the text "bar" and then we closethe quote. When we close this, it doesn't know that a new one was opening inside the style containment elementSo it just closes the initial openingWe are not closing both in this case, but they mean basically that the changes here doesn't affect anything outsideSo, okayWe have aliases in the spec so you can say "contain: content" and that implies layout and paintOr you can say "contain: strict" and that implies layout, paint and sizeThis used to include style too, but like style is market at risk and Firefox was planning to shipCSS Containment, it was removed from the spec at this stage. If in the future style is implemented by all the browsers probablyThere will be a new alias like "all" or whatever that will include style tooSo let's just check the status of thingsThis is not a new spec. Maybe it's the first time you've heard about itBut if has been shipping for three years already in Chromium, so it's not an new spec at alland Google has been using it in their products like YouTube or Gmail, even in the Chrome Dev Tools, things like thatBut during past year there has been quite a lot of work in the in the specFlorian Rivoal one of the spec editors has been working quite a lotin pushing the spec to candidate recommendationAlso the test suite in Web Platform Tests repository has been completed by Gérard Talbot and with contributors from Mozilla and Chromiumwhile we were working in the implementationsWe at Igalia having fixing the implementation in Chromium. So it's aligned with the spec and we can start to implement optimizations based on thatAnd that was causing us to be breaking most of the sitesI mean, we broke YouTube for a whilewe broke Gmail, we broke Dev Tools several times because maybe they were using "contain: layout" for example in many places and nowthe overflow is treated as ink overflow so you can access it, things like that, or now that is a containing block forthe positioned descendants, so everything is positioned wrongly, so you need to or stop using contain layout orChange how things work inside that elementandThen Firefox is also working on the implementationThey are targeting FirefoxAnd meanwhile Chromium has been implementing some optimizations based on css-containSo like I say you can just parse the property in the browser implement the restrictions and you arepassing all the tests of CSS Containment so you are totally spec on clientBut maybe you don't have any optimization in the browser so is not useful at all at the endSo then when the browser has that information it needs to still implement someoptimizationsandIf we look at "Can I use" like Microsoft is moving to Chromium/Blinkit's getting support for this, all the Chromium browsers has support for this, and Firefox is about to ship in a few releases andand then regarding Safari/WebKit there are no public signals yetSo let's show some examples to try to understand this a little bit betterThis is one example from a blog post I published aboutContainment is very simple and not cool at all. But I believe it's the best want to understand how how it worksso imagine that we have a very big DOM tree, like ten thousand elements like this item that has all of them haveone child andWe are modifying the content of that child over and over or whatever. So we have a DOM tree like thisWe have many many elements here, but we are only doing changes in this greendivBut still the browser needs to do work in the rest, not a lot of work maybe justTraversing the whole DOM tree to do some checks or whatever but it's doing work in all of them, so we can say okayThis has "contain: strict". We cannot affect anything outside. We are just changing things inside here, the browser can avoidNavigating the rest of the thingsSo this example is, I mean not cool at all, is changing the the text in the firstelementit actually goes from changing is taking six milliseconds without containment to takequite a bit differenceThis is another example is the same one, but I'm using grid layout in the items because I know thatgrid layout has all these track sizing algorithms. So it'ssomehow costlyif we think about performance, so it takes a while andOn the left we have Chromium on the right we have Firefoxthat's because I was crafting this example for this talk andI realize it we were not getting very good results in ChromiumSo I was checking Firefox and Firefox was much better and it makes actually sense the resultsWe are getting in FirefoxFor example with these which is quite a lot but in Firefox is likeInstead of just doing it in one. It's suspected that it's very very fast when you just have thisstrict containment in that element, that you just do it thereSoWe have been working on this at Igalia as part of our ongoing collaboration with Bloomberg in which we implementedCSS Grid Layout in the past years or we have been implementing things in JavaScript like async/await or BigInt latelyandBloomberg has some quite complex UIs and then we're getting benefit of using CSS Containment in some of themSo this is one of the stress cases we had this is like a hugetable like layout or grid like layout. It doesn't have to be a table or gridIt doesn't matter but it has like but we actually know that we are just changing one number by another numberthat the number is going to fit in the size we are providing, we know that for sureSo we don't needWe can say to the browser. Okay, this element has"contain: layout size" and you can avoid doing the layout of thetext you are changing there ,because if you are adding a long sentence or whatever the browser needs to do line breaking, all that andCalculate some things, so we are saying okayYou can save all that time if we have "contain: layout size"because we know that we are just changing one number way another and it's going to fit inside andThen this stress test with This is the still to ported to LayoutNG, which is new thing that Chromium is shipping really soon. SoIt will be like similar thingsThis was another one pretty similar again very big table or whatever. Here are some of theProgress bars are moving are changing size. We're not changing the contents like that. But something is changing size inside each of themBut the thing is that in the use case each of these cells were absolute positioned. So we have likeEach of them has its own layerSo the browser when something was changing inside one. It was traversing the whole layer threeand depending on the size of the DOM, that was taking a while in some phases and then we "contain: strict"and a very big stress we get like Probably we were respecting more, but maybe there are room for more things yetSo let's talk about the future of all theseWe can expect better browser support Firefox is shipping really soon. We don't know Safari butWe hope that, I mean, we never heard complaints from Apple about this spec. So it seemsMaybe at some point they will have itOther thing that we can expect is more optimizations based on css-containBasically when people are start to use it, they will say okay like this example, I just did in ChromiumOk, this will be much faster than what we are seeing. I mean I'm changing just one elementIt should be almost as fast as having just one element in the DOM despite I have a ton ofSo you can report a bug and probably the browser will try toimprove that use case with someoptimization because maybe, I mean this is somehow it's not new because it has been there for a while butThere has not being a lot of workSo there are still a lot of room for improvement here in a lot of optimizations to be done in the browserAnd also there are some new featuresor proposals that some browsers are working on, that are based on this specSo, I don't know if you have heard about Display Locking proposal from Google. Google isexperimenting with this and have some experimental implementation already in ChromiumMain idea of display locking is that in a DOM tree you can lock an element of the DOMThen you do manipulation in JavaScript you modifyWhatever you need there without blocking the main thread and then when everything is ready you unlock it and show it in the screenBut for that you need that the element is independent of the rest and that's where containmentcomes to the rescue. And I mean you mark that element with "contain" and then you can do thatso things like thisin the future will appear maybe display locking is not the the feature that is finally standardizedBut it's one of these ideasAnd that's all from my side. I hope you understand a little bit betterNow what this spec is about you can start experimenting with it and report bugs about itin my blog you can readI just only have one article about this but maybe in the futureI will have more, I've been writing articles about grid and things we are working on for a whileAnd I will be around the whole day. Feel free to talk to me about CSS Containment, CSS Grid, what it takes to implement aCSS spec in a browser or things like that or even ask me about Igalia and the things we doSo, that's all. Thank you
YouTube URL: https://www.youtube.com/watch?v=iqcO-5_KkJ4


