Title: Craig Spence - Fantastic ASTs and where to find them
Publication date: 2018-04-11
Playlist: JSConf Australia 2018
Description: 
	Oh no! Harry Potter, the hero from the J K Rowlingâ€™s wizarding universe, has been cursed by the super-villain, Lord Voldemort, and now he is trapped inside the Internet! 

Harry knows Parseltongue, which means that he can talk to snakes. Incredibly, Parseltongue also happens to be a Turing complete programming language! In order for Harry to escape from the Internet, we need to transpile Parseltongue into JavaScript. In order to do that we need to learn all about Abstract Syntax Trees and how to use them to manipulate code. 

This talk goes through the details of these magical data-structures, and all about language transformation, including lexing, parsing, code generation and creating source maps.By the end of the talk, attendants should have an idea of how ASTs work, how they are used in code transformation, and how they can be used to manipulate and interrogate code at a structural level.
Captions: 
	00:00:09,750 --> 00:00:15,700
builder hi everyone I'm so so stoked to

00:00:14,260 --> 00:00:17,070
be here thank you for having me this is

00:00:15,700 --> 00:00:21,130
already been an awesome day and

00:00:17,070 --> 00:00:25,990
hopefully it gets interesting now um I'm

00:00:21,130 --> 00:00:28,600
Craig I do JavaScript at trade me in New

00:00:25,990 --> 00:00:30,520
Zealand I work in a big angular code

00:00:28,600 --> 00:00:32,920
base but I really like working on tools

00:00:30,520 --> 00:00:36,730
and stuff and so this talk has come from

00:00:32,920 --> 00:00:38,980
some things I've learnt there um we're

00:00:36,730 --> 00:00:40,270
gonna start with the story and to make

00:00:38,980 --> 00:00:42,489
this story happen as you need some

00:00:40,270 --> 00:00:45,670
participation from the audience just to

00:00:42,489 --> 00:00:49,000
shake your awake so I need everyone to

00:00:45,670 --> 00:00:51,309
close their eyes and all together we're

00:00:49,000 --> 00:00:55,390
gonna say the magic words

00:00:51,309 --> 00:01:01,589
so one two three the magic words okay

00:00:55,390 --> 00:01:01,589
great and just like that you're a wizard

00:01:03,600 --> 00:01:10,840
this is Hagrid he's a good guy

00:01:06,750 --> 00:01:13,570
you went to Hogwarts the school of

00:01:10,840 --> 00:01:16,240
witchcraft in Ruby it's where all the

00:01:13,570 --> 00:01:18,450
stuff happens in Harry Potter you can do

00:01:16,240 --> 00:01:18,450
magic

00:01:18,630 --> 00:01:23,890
that's a Patronus

00:01:20,200 --> 00:01:28,859
that'll be important later you know

00:01:23,890 --> 00:01:32,799
Dumbledore he's also a good guy and

00:01:28,859 --> 00:01:33,520
Harry Potter is your best friend that's

00:01:32,799 --> 00:01:35,890
Harry Potter

00:01:33,520 --> 00:01:41,789
he's the manga guy in case you didn't

00:01:35,890 --> 00:01:41,789
know but there's a problem

00:01:43,409 --> 00:01:55,110
there's a snake he's a bit questionable

00:01:46,220 --> 00:01:57,950
Voldemort is back again and he's put a

00:01:55,110 --> 00:01:57,950
curse on Harry

00:01:59,899 --> 00:02:06,470
and now Harry's trapped in the Internet

00:02:14,120 --> 00:02:26,580
all right cool this is Harry and he's

00:02:19,080 --> 00:02:29,280
trapped in the Internet if we don't save

00:02:26,580 --> 00:02:31,819
him in the next 25 minutes Voldemort is

00:02:29,280 --> 00:02:33,709
going to kill him

00:02:31,819 --> 00:02:38,549
this is bad

00:02:33,709 --> 00:02:44,400
our friend Terry is gone and time is

00:02:38,549 --> 00:02:46,430
running out but there is a bit of good

00:02:44,400 --> 00:02:46,430
news

00:02:49,340 --> 00:02:56,209
Harry speaks Parseltongue he can talk to

00:02:54,480 --> 00:02:59,810
snakes

00:02:56,209 --> 00:03:02,700
and I'm sure as everyone here knows

00:02:59,810 --> 00:03:08,820
Parseltongue just so happens to be a

00:03:02,700 --> 00:03:10,079
turing-complete programming language so

00:03:08,820 --> 00:03:12,870
I'm gonna introduce you to pass it down

00:03:10,079 --> 00:03:14,400
assuming you don't already know it this

00:03:12,870 --> 00:03:16,650
isn't important that it'll give you in

00:03:14,400 --> 00:03:19,109
that area where we going so it's a

00:03:16,650 --> 00:03:21,200
weakly typed language it's a functional

00:03:19,109 --> 00:03:24,450
language it's an interpreted language

00:03:21,200 --> 00:03:26,549
it's a garbage plate to the language it

00:03:24,450 --> 00:03:32,700
has significant whitespace so I kind of

00:03:26,549 --> 00:03:34,650
like Python or something it has some

00:03:32,700 --> 00:03:36,000
variable declarations and so here I'm

00:03:34,650 --> 00:03:38,040
gonna use javascript is a reference for

00:03:36,000 --> 00:03:41,209
all of us so on the Left we have some

00:03:38,040 --> 00:03:41,209
Parseltongue hopefully

00:03:44,190 --> 00:03:51,130
and on the left on the right sorry we

00:03:46,840 --> 00:03:52,209
have some JavaScript there's only one

00:03:51,130 --> 00:03:53,200
type of verbal we don't have to worry

00:03:52,209 --> 00:03:55,990
about anything

00:03:53,200 --> 00:04:00,489
constantly or anything and they always

00:03:55,990 --> 00:04:02,230
start with obviously and you notice the

00:04:00,489 --> 00:04:04,300
assignment operator is that little arrow

00:04:02,230 --> 00:04:07,540
with a squiggly next to it that comes

00:04:04,300 --> 00:04:10,840
back later too there's also function

00:04:07,540 --> 00:04:13,510
expressions again Parseltongue on the

00:04:10,840 --> 00:04:15,130
Left JavaScript on the right you create

00:04:13,510 --> 00:04:18,040
it with kind of an array and then a

00:04:15,130 --> 00:04:21,760
return to the parameters they're defined

00:04:18,040 --> 00:04:24,580
with an array and return is also just a

00:04:21,760 --> 00:04:26,020
signing back out and you'll notice the

00:04:24,580 --> 00:04:27,850
significant whitespace you always have

00:04:26,020 --> 00:04:31,600
to have that and in inside your block of

00:04:27,850 --> 00:04:34,930
your function we also have call

00:04:31,600 --> 00:04:37,600
expressions so we can call a function

00:04:34,930 --> 00:04:39,060
like multiply you get a product out kind

00:04:37,600 --> 00:04:41,290
of looks how you expect

00:04:39,060 --> 00:04:45,340
and again arguments there to clear

00:04:41,290 --> 00:04:46,900
Berlin array so again we use the

00:04:45,340 --> 00:04:48,760
assignment operator to pass the

00:04:46,900 --> 00:04:51,150
arguments into the function and then to

00:04:48,760 --> 00:04:56,169
assign the result back out to a variable

00:04:51,150 --> 00:05:01,390
it has control flow so f is else f is

00:04:56,169 --> 00:05:04,180
and else's which is good and it looks

00:05:01,390 --> 00:05:05,890
like they have in JavaScript so you can

00:05:04,180 --> 00:05:07,210
see if you haven't gotten the arguments

00:05:05,890 --> 00:05:14,620
you function you just pass in the empty

00:05:07,210 --> 00:05:17,650
in array head loops is a loop obviously

00:05:14,620 --> 00:05:19,120
and the range operator is just the

00:05:17,650 --> 00:05:20,039
assignment operator flip back the other

00:05:19,120 --> 00:05:23,200
way

00:05:20,039 --> 00:05:25,900
so all that comes together and allows

00:05:23,200 --> 00:05:28,390
Harry to come up with big spells that he

00:05:25,900 --> 00:05:30,729
writes in pass the time and on the right

00:05:28,390 --> 00:05:32,229
you can see the equivalent JavaScript so

00:05:30,729 --> 00:05:34,180
this is a spell that we need to help

00:05:32,229 --> 00:05:37,450
Harry use to break out of the internet

00:05:34,180 --> 00:05:39,430
and escape from Baltimore oh yeah also

00:05:37,450 --> 00:05:40,840
this is oh if you can't read that if

00:05:39,430 --> 00:05:44,200
you're at the front there's a magical

00:05:40,840 --> 00:05:45,729
variable called cast which is just some

00:05:44,200 --> 00:05:47,260
big global and a base if it becomes

00:05:45,729 --> 00:05:53,099
alert you'll see why that's important

00:05:47,260 --> 00:05:53,099
later so we're gonna check on Harry

00:05:53,940 --> 00:05:59,380
who's just hanging out here he's go to

00:05:56,020 --> 00:06:02,470
spell and if we run it we can't get what

00:05:59,380 --> 00:06:04,750
we'd expect oh no something zero and

00:06:02,470 --> 00:06:06,070
identifier is because we just dumped a

00:06:04,750 --> 00:06:11,350
bunch of parcels hang in the browser and

00:06:06,070 --> 00:06:13,420
expected it to do something so again

00:06:11,350 --> 00:06:15,610
this is hairy spell it's kind of pretty

00:06:13,420 --> 00:06:16,210
basic it assigns a variable for expecto

00:06:15,610 --> 00:06:17,860
patronum

00:06:16,210 --> 00:06:20,020
it makes a Patronus like we talked about

00:06:17,860 --> 00:06:22,120
before and we're just going to loop over

00:06:20,020 --> 00:06:24,040
a bunch of stuff and add a bunch of

00:06:22,120 --> 00:06:25,660
exclamation marks to it so that he can

00:06:24,040 --> 00:06:29,590
yell it more vigorously and hopefully

00:06:25,660 --> 00:06:31,570
escape the internet but obviously

00:06:29,590 --> 00:06:34,450
internet browsers don't understand

00:06:31,570 --> 00:06:36,430
hassle time it's kind of the first

00:06:34,450 --> 00:06:40,050
problem we have to face will you run it

00:06:36,430 --> 00:06:44,620
and we just get an unexpected identifier

00:06:40,050 --> 00:06:49,270
so we somehow need to translate Harry's

00:06:44,620 --> 00:06:52,600
Parseltongue it's a JavaScript so we're

00:06:49,270 --> 00:06:54,040
going to do something like this start

00:06:52,600 --> 00:06:55,390
with Parseltongue there's something in

00:06:54,040 --> 00:07:01,180
the middle and we're going to end up

00:06:55,390 --> 00:07:04,690
with JavaScript so how could we try to

00:07:01,180 --> 00:07:06,520
make this work um regex is a reasonable

00:07:04,690 --> 00:07:10,360
solution and we saw that this morning

00:07:06,520 --> 00:07:12,060
when passing out IDs let's have a go and

00:07:10,360 --> 00:07:16,090
see what happens with it

00:07:12,060 --> 00:07:19,000
so to begin with we can kind of just go

00:07:16,090 --> 00:07:21,100
a line at a time we can pull down our

00:07:19,000 --> 00:07:24,280
script and we can just split it on a new

00:07:21,100 --> 00:07:29,470
line and that'll give us something like

00:07:24,280 --> 00:07:31,180
like this not nothing too scary event if

00:07:29,470 --> 00:07:32,980
we wanted to start looking at converting

00:07:31,180 --> 00:07:36,330
like a variable declaration that we had

00:07:32,980 --> 00:07:39,760
before we would just loop over each line

00:07:36,330 --> 00:07:41,020
with the regex and try to match anything

00:07:39,760 --> 00:07:42,910
that kind of looks like a variable

00:07:41,020 --> 00:07:45,400
assignment and then we could just print

00:07:42,910 --> 00:07:47,740
out the JavaScript that is equivalent to

00:07:45,400 --> 00:07:51,040
that at the bottom that's not too bad

00:07:47,740 --> 00:07:52,840
it's kind of a reasonable thing to do at

00:07:51,040 --> 00:07:56,560
that point you get what you expected at

00:07:52,840 --> 00:08:01,870
the outcome so what about what about for

00:07:56,560 --> 00:08:03,220
loops that's pretty dark the the ridging

00:08:01,870 --> 00:08:06,330
he gets a little bit more gnarly

00:08:03,220 --> 00:08:07,800
you kind of look for that thing

00:08:06,330 --> 00:08:09,330
and look for the operators and kind of

00:08:07,800 --> 00:08:11,610
pull some stuff out and then you try to

00:08:09,330 --> 00:08:13,470
print out some JavaScript and stuff kind

00:08:11,610 --> 00:08:17,969
of gets a little bit weird like you have

00:08:13,470 --> 00:08:19,379
this dangling bracket at the end kind of

00:08:17,969 --> 00:08:21,419
don't know what blocks are or anything

00:08:19,379 --> 00:08:23,129
like that so it's not great it's still

00:08:21,419 --> 00:08:26,430
kind of do something with this now but

00:08:23,129 --> 00:08:29,849
not great and kind of the same thing for

00:08:26,430 --> 00:08:31,620
functions you can read them in run a

00:08:29,849 --> 00:08:33,300
regex over them and you end up in a

00:08:31,620 --> 00:08:36,180
similar situation where you've just got

00:08:33,300 --> 00:08:39,539
this dangling dangling brace and the

00:08:36,180 --> 00:08:41,789
rejecters are pretty horrible as well so

00:08:39,539 --> 00:08:45,269
kind of to sum it up you don't have a

00:08:41,789 --> 00:08:45,779
pretty bad time but we can see what that

00:08:45,269 --> 00:08:52,350
looks like

00:08:45,779 --> 00:08:54,720
so we run it and we kind of get some

00:08:52,350 --> 00:08:56,339
JavaScript out it's not actual

00:08:54,720 --> 00:08:58,320
JavaScript time and it definitely won't

00:08:56,339 --> 00:08:59,820
run you can kind of see that if you

00:08:58,320 --> 00:09:06,779
tried really hard you might actually end

00:08:59,820 --> 00:09:08,279
up with something working there so we're

00:09:06,779 --> 00:09:10,079
gonna step back just a little bit and

00:09:08,279 --> 00:09:11,910
kind of ask a bit more of a meta

00:09:10,079 --> 00:09:15,089
question of like what we're really

00:09:11,910 --> 00:09:19,740
trying to do and we're trying to

00:09:15,089 --> 00:09:22,440
transform one language into another and

00:09:19,740 --> 00:09:25,649
this is something we already do quite a

00:09:22,440 --> 00:09:27,839
lot like it's a self problem I don't

00:09:25,649 --> 00:09:33,570
know if any of you use typescript or

00:09:27,839 --> 00:09:36,470
Babel or Elm sass CoffeeScript but these

00:09:33,570 --> 00:09:36,470
are things that we already do

00:09:37,670 --> 00:09:42,269
transpiling is quite a specific term

00:09:39,720 --> 00:09:44,430
it's not compiling and I asked Google

00:09:42,269 --> 00:09:46,800
and Google said that transpiling

00:09:44,430 --> 00:09:48,570
is taking source code written in one

00:09:46,800 --> 00:09:50,459
language and transforming it into

00:09:48,570 --> 00:09:53,370
another language that has a similar

00:09:50,459 --> 00:09:55,920
level of abstraction and so if we're

00:09:53,370 --> 00:09:58,649
thinking about Parseltongue as like

00:09:55,920 --> 00:10:00,209
JavaScript for snakes it's kind of a

00:09:58,649 --> 00:10:05,490
similar level of abstraction just with

00:10:00,209 --> 00:10:08,970
some weird syntax on top of it so where

00:10:05,490 --> 00:10:10,230
do we start let's look at some

00:10:08,970 --> 00:10:11,339
JavaScript now and we're gonna start

00:10:10,230 --> 00:10:14,550
looking at some of the building blocks

00:10:11,339 --> 00:10:16,430
of JavaScript so that in the middle

00:10:14,550 --> 00:10:18,700
there is a string literal I'm sure we

00:10:16,430 --> 00:10:22,210
hopefully know what those are

00:10:18,700 --> 00:10:24,640
we have identifiers we have function

00:10:22,210 --> 00:10:28,000
calls and then the whole thing is

00:10:24,640 --> 00:10:28,930
wrapped up in an expression and I don't

00:10:28,000 --> 00:10:30,940
know if you noticed but I've been using

00:10:28,930 --> 00:10:32,470
some pretty specific terms for this like

00:10:30,940 --> 00:10:35,020
call it's pression or variable

00:10:32,470 --> 00:10:38,110
declaration and that's because they have

00:10:35,020 --> 00:10:40,390
meaning they're they're quite well

00:10:38,110 --> 00:10:42,570
defined and they're well defined and

00:10:40,390 --> 00:10:45,310
this thing called the es tree

00:10:42,570 --> 00:10:47,320
specification it's not a real spec it's

00:10:45,310 --> 00:10:50,140
kind of growing over the years after

00:10:47,320 --> 00:10:54,310
someone at Mozilla whipped it up but it

00:10:50,140 --> 00:10:56,560
kind of defines how these bits of code

00:10:54,310 --> 00:10:59,980
are made up and so if we have this bit

00:10:56,560 --> 00:11:03,580
of JavaScript code it can be converted

00:10:59,980 --> 00:11:05,740
into a structure like this history is on

00:11:03,580 --> 00:11:08,500
github you can look at some stuff with

00:11:05,740 --> 00:11:11,680
them and then there's a tool called

00:11:08,500 --> 00:11:12,760
esprima there are bunch of tools built

00:11:11,680 --> 00:11:15,550
on top of the history spec you've

00:11:12,760 --> 00:11:17,980
probably all use them but es prima is

00:11:15,550 --> 00:11:19,930
one of my favorite it gives us the

00:11:17,980 --> 00:11:22,150
ability to pass a string of JavaScript

00:11:19,930 --> 00:11:24,640
code into a description of those

00:11:22,150 --> 00:11:27,910
building blocks and that is what's known

00:11:24,640 --> 00:11:30,370
as the AST so super easy to use just

00:11:27,910 --> 00:11:37,660
give it a string of stuff and up pops

00:11:30,370 --> 00:11:42,760
this AST so what is an answer it's an

00:11:37,660 --> 00:11:44,800
abstract syntax tree this is also quite

00:11:42,760 --> 00:11:51,490
an abstract description of what that is

00:11:44,800 --> 00:11:54,070
so I went to Google and I looked for

00:11:51,490 --> 00:11:57,310
cool stuff about trees which wasn't very

00:11:54,070 --> 00:11:59,920
helpful and then I looked for cool stuff

00:11:57,310 --> 00:12:02,020
about abstract syntax trees and I got

00:11:59,920 --> 00:12:05,890
down to what I think is a bit more of a

00:12:02,020 --> 00:12:07,630
understandable definition so an ast is a

00:12:05,890 --> 00:12:10,120
data structure that represents the

00:12:07,630 --> 00:12:13,750
structure of code without any actual

00:12:10,120 --> 00:12:17,920
syntax so for example if you have this

00:12:13,750 --> 00:12:20,910
bit of JavaScript and this bit of some

00:12:17,920 --> 00:12:24,400
kind of list B language and this bit of

00:12:20,910 --> 00:12:29,910
Parseltongue they can all be described

00:12:24,400 --> 00:12:29,910
by the same ast which is pretty cool

00:12:30,010 --> 00:12:36,340
so what that means think about it is

00:12:33,400 --> 00:12:40,330
that if we can get from Parseltongue to

00:12:36,340 --> 00:12:45,820
na st we can get from Nasty to

00:12:40,330 --> 00:12:47,410
JavaScript so we tried this it was I

00:12:45,820 --> 00:12:49,720
mean we could've got its work if we

00:12:47,410 --> 00:12:51,160
really tried really hard but let's try a

00:12:49,720 --> 00:12:54,490
new idea and see what that might look

00:12:51,160 --> 00:12:59,170
like this is probably gonna be a couple

00:12:54,490 --> 00:13:01,870
more steps involved here to figure them

00:12:59,170 --> 00:13:04,900
out let's go back to esprima for just a

00:13:01,870 --> 00:13:07,030
second so what we really want to know is

00:13:04,900 --> 00:13:09,400
what javascript we want to end up with

00:13:07,030 --> 00:13:14,560
at the end because then we can just

00:13:09,400 --> 00:13:17,250
write it out ourselves in theory and so

00:13:14,560 --> 00:13:21,210
if we just kind of pipe it into esprima

00:13:17,250 --> 00:13:25,350
like we did before with the javascript

00:13:21,210 --> 00:13:25,350
we can actually get out an AST

00:13:25,500 --> 00:13:31,360
and so this prima is taking code that's

00:13:29,680 --> 00:13:33,490
written in a specific language in this

00:13:31,360 --> 00:13:37,000
case JavaScript and turning it into an

00:13:33,490 --> 00:13:42,270
AST and so we need to make our own

00:13:37,000 --> 00:13:42,270
esprima kind of thing for parcels them

00:13:43,590 --> 00:13:50,050
so how do we do that that's a question

00:13:47,580 --> 00:13:50,940
thankfully again it's a kind of solved

00:13:50,050 --> 00:13:55,810
problem

00:13:50,940 --> 00:13:58,120
yes prima does it obviously so under the

00:13:55,810 --> 00:14:00,400
hood all passes as these things are

00:13:58,120 --> 00:14:01,900
called doing three phases and the first

00:14:00,400 --> 00:14:04,030
phase of this is a thing called lexing

00:14:01,900 --> 00:14:10,330
and the end result of that is going to

00:14:04,030 --> 00:14:12,640
be tokens so lexing or tokenizing as

00:14:10,330 --> 00:14:14,260
it's sometimes called is the process of

00:14:12,640 --> 00:14:16,210
breaking down source code into words

00:14:14,260 --> 00:14:20,110
that are relevant to that language which

00:14:16,210 --> 00:14:22,240
they're called tokens in JavaScript we

00:14:20,110 --> 00:14:24,760
have tokens obviously so we have

00:14:22,240 --> 00:14:27,010
identifiers and keywords and literals

00:14:24,760 --> 00:14:29,110
and punctuate errs into file as a token

00:14:27,010 --> 00:14:33,220
we have regular expressions and we have

00:14:29,110 --> 00:14:35,080
templates in Parseltongue we kind of

00:14:33,220 --> 00:14:36,760
have the same thing the only main

00:14:35,080 --> 00:14:38,530
difference here is that because we're a

00:14:36,760 --> 00:14:40,720
Weiss basically there be a language we

00:14:38,530 --> 00:14:42,170
have tokens for the indentation and we

00:14:40,720 --> 00:14:46,250
have tokens four spaces

00:14:42,170 --> 00:14:48,350
stuff like that so for any given chunk

00:14:46,250 --> 00:14:50,839
of Parseltongue such as this variable

00:14:48,350 --> 00:14:52,639
declaration we would go over it

00:14:50,839 --> 00:14:55,459
character by character and see we've got

00:14:52,639 --> 00:14:57,050
some identified characters and then we

00:14:55,459 --> 00:14:58,910
go to space and we've got some

00:14:57,050 --> 00:15:02,810
punctuated characters in another space

00:14:58,910 --> 00:15:05,120
the punctuate ER and the quote there's a

00:15:02,810 --> 00:15:07,370
string quote the punch Raider again and

00:15:05,120 --> 00:15:10,430
for each of those we would build up

00:15:07,370 --> 00:15:11,690
these tokens so any if we had had

00:15:10,430 --> 00:15:14,209
something that wasn't meant to be there

00:15:11,690 --> 00:15:16,339
we would throw in here and so we can

00:15:14,209 --> 00:15:20,980
apply that process to a whole passel

00:15:16,339 --> 00:15:25,880
time spell so we can jump back over here

00:15:20,980 --> 00:15:28,010
and see where that might look like so

00:15:25,880 --> 00:15:29,930
kind of ran some stuff we called the

00:15:28,010 --> 00:15:33,230
Lexx function and we ended up with a

00:15:29,930 --> 00:15:34,990
bunch of tokens so the kind of what you

00:15:33,230 --> 00:15:38,209
might expect if you couldn't see that

00:15:34,990 --> 00:15:40,639
you know identify spaces and string

00:15:38,209 --> 00:15:42,230
literals and blind terminators and add

00:15:40,639 --> 00:15:44,839
more identifiers all this kind of stuff

00:15:42,230 --> 00:15:45,980
so they're the chunks that make up the

00:15:44,839 --> 00:15:57,320
things that we care about in the

00:15:45,980 --> 00:15:59,410
language so we've already got some

00:15:57,320 --> 00:16:02,959
tokens and now we need to get you an AST

00:15:59,410 --> 00:16:04,250
M again after lexing most passes they

00:16:02,959 --> 00:16:08,180
use a process which is that you're

00:16:04,250 --> 00:16:11,149
passing step and passing is pretty

00:16:08,180 --> 00:16:12,769
similar to mixing it's the process of

00:16:11,149 --> 00:16:14,660
taking these lexical tokens as they're

00:16:12,769 --> 00:16:17,089
called and applying the grammar of the

00:16:14,660 --> 00:16:18,470
language to them so instead of going

00:16:17,089 --> 00:16:20,720
character by character

00:16:18,470 --> 00:16:22,940
we now go token by token and try to

00:16:20,720 --> 00:16:28,160
build up things that actually matter to

00:16:22,940 --> 00:16:30,649
our language so again in the case of our

00:16:28,160 --> 00:16:32,600
variable declaration we would start with

00:16:30,649 --> 00:16:34,640
our identifier character and go yep we

00:16:32,600 --> 00:16:37,399
expect that and then we'd expect a space

00:16:34,640 --> 00:16:38,630
and then that specific punctuate err so

00:16:37,399 --> 00:16:40,250
now instead of just talking about the

00:16:38,630 --> 00:16:42,920
idea of a punctuate ER we're talking

00:16:40,250 --> 00:16:46,430
about specific ones we care about penis

00:16:42,920 --> 00:16:48,980
space then a string literal and that

00:16:46,430 --> 00:16:50,209
would give us an ast like we have on the

00:16:48,980 --> 00:16:52,630
right hand side so you can kind of build

00:16:50,209 --> 00:16:55,130
up that tree as you find these tokens

00:16:52,630 --> 00:16:56,560
kind of works similarly for a function

00:16:55,130 --> 00:17:00,800
declaration

00:16:56,560 --> 00:17:04,250
so we have this magic function and we

00:17:00,800 --> 00:17:07,180
have an identifier in a space then again

00:17:04,250 --> 00:17:11,570
specific punctuate er another identifier

00:17:07,180 --> 00:17:15,260
kind of so on and so forth to the end of

00:17:11,570 --> 00:17:18,440
a line and then we have our indent which

00:17:15,260 --> 00:17:20,450
tells us that we own again in a correct

00:17:18,440 --> 00:17:24,080
amount of indentation for it to be valid

00:17:20,450 --> 00:17:25,760
language and we use that on that block

00:17:24,080 --> 00:17:27,020
that's really the indent to figure out

00:17:25,760 --> 00:17:30,170
where we are for the block of this

00:17:27,020 --> 00:17:32,360
function so the correct sequence of

00:17:30,170 --> 00:17:36,470
tokens here would produce this following

00:17:32,360 --> 00:17:40,460
AST the blocks comments out but

00:17:36,470 --> 00:17:42,020
basically something like that so it's

00:17:40,460 --> 00:17:44,740
kind of most of it we should be able to

00:17:42,020 --> 00:17:44,740
get an AST now

00:17:57,430 --> 00:18:06,160
so now instead of just calling Lex we're

00:18:03,910 --> 00:18:08,590
calling Lex and then pass and we've

00:18:06,160 --> 00:18:09,910
ended up with us here program so you can

00:18:08,590 --> 00:18:14,410
see we've got a variable declaration

00:18:09,910 --> 00:18:16,510
which is the string at the top then

00:18:14,410 --> 00:18:18,790
we've got the function declaration and

00:18:16,510 --> 00:18:21,190
then we've got our four got our four

00:18:18,790 --> 00:18:29,980
statement which is for the loop so

00:18:21,190 --> 00:18:31,300
that's pretty cool this is my favorite

00:18:29,980 --> 00:18:35,770
gift for the whole slideshow I don't

00:18:31,300 --> 00:18:37,090
know if it's from the movie but so would

00:18:35,770 --> 00:18:38,410
that whole thing we kind of ended up

00:18:37,090 --> 00:18:39,910
with something like this I'd only speak

00:18:38,410 --> 00:18:41,230
to you better see it but the general

00:18:39,910 --> 00:18:43,780
thing is that you can see this tree

00:18:41,230 --> 00:18:45,370
structure and so there's no cycles or

00:18:43,780 --> 00:18:50,680
anything it's just this nice tree that

00:18:45,370 --> 00:18:52,780
goes in and then comes back out so now

00:18:50,680 --> 00:18:56,200
we just need to get from that ast and we

00:18:52,780 --> 00:18:59,110
need to get back to JavaScript and so

00:18:56,200 --> 00:19:01,870
it's just cogeneration snip which kind

00:18:59,110 --> 00:19:04,420
of sounds pretty easy um but essentially

00:19:01,870 --> 00:19:06,090
you're really really hard and I wouldn't

00:19:04,420 --> 00:19:10,600
really want to try to do it myself

00:19:06,090 --> 00:19:15,280
again this is JavaScript so there's a

00:19:10,600 --> 00:19:19,110
library for that this is a library Cody

00:19:15,280 --> 00:19:22,780
Asche Oh Jim again really simple API

00:19:19,110 --> 00:19:29,140
tags in an ast and produces JavaScript

00:19:22,780 --> 00:19:36,010
at the end that's pretty cool so all of

00:19:29,140 --> 00:19:38,520
that is working together we should be

00:19:36,010 --> 00:19:38,520
able to get

00:19:38,650 --> 00:19:45,190
some JavaScript and so that is the spell

00:19:43,120 --> 00:19:47,170
that we hit before transpired in

00:19:45,190 --> 00:19:48,520
JavaScript with the source map which you

00:19:47,170 --> 00:19:58,480
scare for free if you use this stuff

00:19:48,520 --> 00:20:00,250
which is pretty cool so we've got a

00:19:58,480 --> 00:20:04,780
spell and we've kind of turned it from

00:20:00,250 --> 00:20:07,240
past clang into JavaScript and we kind

00:20:04,780 --> 00:20:09,010
of did a bunch of stuff so we started

00:20:07,240 --> 00:20:10,840
with Pascal Sun and we licks it and we

00:20:09,010 --> 00:20:12,970
got some tokens and then we pass them

00:20:10,840 --> 00:20:15,850
and we got out an ast and then we use

00:20:12,970 --> 00:20:18,580
ast and we generated some JavaScript and

00:20:15,850 --> 00:20:21,340
so we're actually almost ready to save

00:20:18,580 --> 00:20:22,540
Harry we could just run us code and it

00:20:21,340 --> 00:20:25,420
would do everything we hope in the

00:20:22,540 --> 00:20:31,000
browser and he'd be able get out but oh

00:20:25,420 --> 00:20:37,200
no Voldemort can also speak past the

00:20:31,000 --> 00:20:37,200
time got a snake for Australia good

00:20:37,710 --> 00:20:45,330
Voldemort is gonna try and stop Harry

00:20:40,990 --> 00:20:52,780
from escaping and he might even use the

00:20:45,330 --> 00:20:54,610
unforgivable functions so handily for us

00:20:52,780 --> 00:20:56,500
these happen to be global functions in

00:20:54,610 --> 00:21:00,730
Parseltongue because that's a good

00:20:56,500 --> 00:21:03,100
design decision and these spells are

00:21:00,730 --> 00:21:05,100
really bad so you can like just hurt

00:21:03,100 --> 00:21:07,420
someone or you can control their actions

00:21:05,100 --> 00:21:09,540
or you could even kill them which is how

00:21:07,420 --> 00:21:12,190
told them what would try to kill Harry

00:21:09,540 --> 00:21:17,080
so we need to come up with a way to stop

00:21:12,190 --> 00:21:18,190
Baltimore from using those functions so

00:21:17,080 --> 00:21:19,540
we've kind of got this step in the

00:21:18,190 --> 00:21:23,290
middle here now that we didn't expect to

00:21:19,540 --> 00:21:24,760
have before but that's ok and we're

00:21:23,290 --> 00:21:30,490
going to do some inspecting how about

00:21:24,760 --> 00:21:32,830
AST so this to me is kind of the most

00:21:30,490 --> 00:21:35,470
powerful thing about a SDS and it's kind

00:21:32,830 --> 00:21:37,990
of the best trick of all so we can

00:21:35,470 --> 00:21:40,990
completely transform the AST we can

00:21:37,990 --> 00:21:43,300
validate that it looks a certain way we

00:21:40,990 --> 00:21:45,070
can even mutate it and there are a bunch

00:21:43,300 --> 00:21:48,850
of tools that do stuff like this already

00:21:45,070 --> 00:21:51,640
so you got like weird pack which is just

00:21:48,850 --> 00:21:52,570
pulling about your ASC code and wishing

00:21:51,640 --> 00:21:54,460
it back together in different ways

00:21:52,570 --> 00:21:56,590
you've got your saloon which is kind of

00:21:54,460 --> 00:21:57,880
looking at stuff and validating that you

00:21:56,590 --> 00:22:00,340
know you haven't used debugger and

00:21:57,880 --> 00:22:02,440
production code or whatever you've got

00:22:00,340 --> 00:22:05,530
prettier which is just like reformatting

00:22:02,440 --> 00:22:06,940
it in a nice way and it's all because

00:22:05,530 --> 00:22:10,060
they can kind of look at the ASC and

00:22:06,940 --> 00:22:11,770
then do cool stuff with it and once

00:22:10,060 --> 00:22:14,650
again there's a library for that

00:22:11,770 --> 00:22:16,630
so yes query is another really really

00:22:14,650 --> 00:22:19,600
great one and it gives us a bunch of

00:22:16,630 --> 00:22:24,580
tools for querying the ast just like we

00:22:19,600 --> 00:22:25,750
would the Dom it's on github so what we

00:22:24,580 --> 00:22:29,260
kind of want to do is we want to learn

00:22:25,750 --> 00:22:32,530
our code and we needed to take the bad

00:22:29,260 --> 00:22:34,420
stuff the unforgivable functions so we

00:22:32,530 --> 00:22:37,210
need to detect whenever Voldemort is

00:22:34,420 --> 00:22:40,630
using one of them and then do something

00:22:37,210 --> 00:22:43,390
reasonable so a square lets us to write

00:22:40,630 --> 00:22:44,740
our these kind of query expressions so

00:22:43,390 --> 00:22:46,890
here we're looking for any call

00:22:44,740 --> 00:22:49,690
expression which is the function call

00:22:46,890 --> 00:22:50,169
where the name of the corley the thing

00:22:49,690 --> 00:22:51,909
that has been

00:22:50,169 --> 00:22:53,799
old matches one of those three things

00:22:51,909 --> 00:22:56,919
and then we're going to grab the

00:22:53,799 --> 00:22:59,169
identifier out of that and so if we come

00:22:56,919 --> 00:23:01,779
across any of those in a code we can

00:22:59,169 --> 00:23:03,609
just go call the query function find any

00:23:01,779 --> 00:23:05,230
of them and if we've got any weakness go

00:23:03,609 --> 00:23:09,039
black now era you're not going to work

00:23:05,230 --> 00:23:10,899
that's not going to happen but we can

00:23:09,039 --> 00:23:13,779
actually kind of go a step further and

00:23:10,899 --> 00:23:15,609
we can actually fix some of the stuff so

00:23:13,779 --> 00:23:18,249
we could take those unforgivable

00:23:15,609 --> 00:23:20,799
functions query for them and then just

00:23:18,249 --> 00:23:24,340
replace the thing gets called with this

00:23:20,799 --> 00:23:25,929
other spell rictusempra which is just

00:23:24,340 --> 00:23:34,499
the tech linker which is a little bit

00:23:25,929 --> 00:23:34,499
better so let's check that we're safe

00:23:41,030 --> 00:23:46,370
cool so we have Voldemort's pretty good

00:23:44,000 --> 00:23:49,490
spell I guess and we're gonna run that

00:23:46,370 --> 00:23:51,470
oh cool so now we have the original

00:23:49,490 --> 00:23:53,990
parcel thing at the top we have our

00:23:51,470 --> 00:23:59,150
alerts that happened and if we run this

00:23:53,990 --> 00:24:02,350
we should hopefully see three alerts in

00:23:59,150 --> 00:24:07,520
a row which is pretty great

00:24:02,350 --> 00:24:09,830
and it means the hair is a bit safer so

00:24:07,520 --> 00:24:12,020
we started with Parseltongue we lik set

00:24:09,830 --> 00:24:15,890
to get tokens we passed those tokens

00:24:12,020 --> 00:24:20,150
into an AST we've been inspected those

00:24:15,890 --> 00:24:21,770
to the AST and we modified it then we

00:24:20,150 --> 00:24:25,460
passed the ast that the code generator

00:24:21,770 --> 00:24:32,210
and we ended up with some JavaScript so

00:24:25,460 --> 00:24:38,090
we are now ready and they see if they

00:24:32,210 --> 00:24:40,190
can all work together so if we remember

00:24:38,090 --> 00:24:42,410
from before what we expect is Harry

00:24:40,190 --> 00:24:44,810
Potter to just scream expecto patronum a

00:24:42,410 --> 00:24:49,190
number of times in the row with way more

00:24:44,810 --> 00:24:54,770
exclamation marks each time if we hit

00:24:49,190 --> 00:24:56,360
run cool so there's a debugger at the

00:24:54,770 --> 00:24:58,730
start here because this is my final and

00:24:56,360 --> 00:25:01,850
most amazing trick if I hit the next

00:24:58,730 --> 00:25:03,860
thing I'm in a source map and now I'm

00:25:01,850 --> 00:25:07,900
debugging and running Parseltongue in

00:25:03,860 --> 00:25:07,900
the browser which is pretty funny

00:25:08,100 --> 00:25:16,620
[Applause]

00:25:12,750 --> 00:25:21,000
we didn't attorney and it happens a

00:25:16,620 --> 00:25:22,370
whole bunch of times a whole bunch of

00:25:21,000 --> 00:25:28,620
times

00:25:22,370 --> 00:25:29,010
cool so we escaped that's great um we

00:25:28,620 --> 00:25:32,580
did it

00:25:29,010 --> 00:25:39,480
Harry's safe another great gift look at

00:25:32,580 --> 00:25:45,510
these cool old as well a game with

00:25:39,480 --> 00:25:47,730
creepy old Harry now that kind of leaves

00:25:45,510 --> 00:25:50,130
us with a question like saving Harry

00:25:47,730 --> 00:25:57,450
Potter is all well and good but when you

00:25:50,130 --> 00:25:58,740
actually use these ASDs always so have

00:25:57,450 --> 00:26:01,220
you ever had to change every file in

00:25:58,740 --> 00:26:04,260
your Kobus like we recently upgraded

00:26:01,220 --> 00:26:05,730
rxjs and we changed all of our files

00:26:04,260 --> 00:26:08,100
from using their like in portable

00:26:05,730 --> 00:26:11,790
operators to the paper ball ones and we

00:26:08,100 --> 00:26:13,050
use the sts for that if you'd like to

00:26:11,790 --> 00:26:14,820
generate a bunch of boilerplate code

00:26:13,050 --> 00:26:16,890
like so if we've got a new feature that

00:26:14,820 --> 00:26:18,690
we're spinning up we'll spin up a module

00:26:16,890 --> 00:26:20,820
and some components and reducers and

00:26:18,690 --> 00:26:22,350
actions and we'll build them from an ast

00:26:20,820 --> 00:26:25,560
and just modify them to set the

00:26:22,350 --> 00:26:27,990
particular feature we're building or

00:26:25,560 --> 00:26:30,720
have you ever had to like extract some

00:26:27,990 --> 00:26:32,640
information from from your code we we

00:26:30,720 --> 00:26:34,230
pull our component library apart and we

00:26:32,640 --> 00:26:35,940
rip out all the inputs and outputs and

00:26:34,230 --> 00:26:40,200
the dependency structure and we do all

00:26:35,940 --> 00:26:41,100
that with a nasty as well if you've ever

00:26:40,200 --> 00:26:43,080
done anything like that

00:26:41,100 --> 00:26:44,550
if you've ever passed a string you

00:26:43,080 --> 00:26:46,560
downloaded from the internet to try to

00:26:44,550 --> 00:26:48,750
read an ad out of it you could and

00:26:46,560 --> 00:26:53,090
possibly should use a nasty for that

00:26:48,750 --> 00:26:53,090
it's a bit more robust than using orig

00:26:53,360 --> 00:26:57,570
they're really really really magical

00:26:55,560 --> 00:26:59,730
basically they kind of help us with a

00:26:57,570 --> 00:27:01,850
whole bunch of stuff like performance if

00:26:59,730 --> 00:27:04,950
it's you know minification or

00:27:01,850 --> 00:27:06,240
maintenance if it's code formatting or

00:27:04,950 --> 00:27:08,700
you know stopping us using certain

00:27:06,240 --> 00:27:10,080
operators or functions and their buffer

00:27:08,700 --> 00:27:11,400
rustles that comes along with that and

00:27:10,080 --> 00:27:13,830
the consistency you know if you've got

00:27:11,400 --> 00:27:15,840
one format for your whole code base they

00:27:13,830 --> 00:27:17,960
help us with analyzing our code because

00:27:15,840 --> 00:27:20,970
we can you know pull out that API data

00:27:17,960 --> 00:27:22,680
and my favorite thing is they help us

00:27:20,970 --> 00:27:26,090
with a whole bunch of automation and a

00:27:22,680 --> 00:27:26,090
bunch of really repetitive tasks

00:27:26,640 --> 00:27:31,230
so they're everywhere

00:27:31,320 --> 00:27:44,440
they're really powerful and they're

00:27:39,250 --> 00:27:46,770
incredibly useful once you know how to

00:27:44,440 --> 00:27:46,770
find them

00:27:47,010 --> 00:27:58,750
so thanks all of this is online

00:27:57,100 --> 00:28:03,330
you're welcome to go and look at it it's

00:27:58,750 --> 00:28:03,330
terrible code yeah thank you very much

00:28:09,280 --> 00:28:11,340

YouTube URL: https://www.youtube.com/watch?v=UKCoRKzRqN4


