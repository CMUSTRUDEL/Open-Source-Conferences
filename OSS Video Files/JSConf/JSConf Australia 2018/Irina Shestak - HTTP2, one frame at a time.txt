Title: Irina Shestak - HTTP2, one frame at a time
Publication date: 2018-04-11
Playlist: JSConf Australia 2018
Description: 
	Node Files.
Take #1337.
~ * Action! * ~

INT. JSCONF AU CONFERENCE VENUE

The camera zooms in on an intense discussion between Scully and Mulder. Both are huddled around a terminal, both are uncertain about the next steps. Ghosts of old TCP connections wail in the background.
Scully is frantically typing. The left hand side shows a new session starting. Soon a new stream created. Multiple requests come in and Scully and Mulder frantically look at each other with a single face expression -- what. do. we. do. now? A minute passes. Scully looks like she has an idea.

~ * Scene * ~

In this fresh off the press episode of Node Files, I will take you to a set of Node.js' implementation of HTTP2. Its quirks, its benefits, and its workings explained and illustrated. How do we get from an established connection to TLS decryption? How does the concept of session come in to play? How does node handle memory usage when it comes to HTTP2? And what are these frame things everyone keeps talking about? This and more explained in HTTP2, one frame at a time. Coming to theatre near you from JSConf AU in March 2018.
Captions: 
	00:00:10,740 --> 00:00:18,660
hey everyone hello this computer that

00:00:16,290 --> 00:00:21,570
says hello so I'm here to talk about

00:00:18,660 --> 00:00:24,810
HTTP to the Critias the critics have

00:00:21,570 --> 00:00:26,699
spoken the critics have said it's a

00:00:24,810 --> 00:00:29,869
major protocol shipped with a potential

00:00:26,699 --> 00:00:32,489
to accelerate the web that is the HTTP -

00:00:29,869 --> 00:00:34,290
it's enough it's supposed to make our

00:00:32,489 --> 00:00:36,120
applications faster simpler and more

00:00:34,290 --> 00:00:39,030
robust Google folks at web fundamentals

00:00:36,120 --> 00:00:41,250
have mentioned that as well people who

00:00:39,030 --> 00:00:43,680
have put together 8gb - you said it's

00:00:41,250 --> 00:00:45,600
more efficient to parse more compact on

00:00:43,680 --> 00:00:48,210
the wire and most importantly there are

00:00:45,600 --> 00:00:52,140
much less error-prone compared to

00:00:48,210 --> 00:00:54,210
textual export protocols like HTTP 1x so

00:00:52,140 --> 00:00:55,890
lots of people are talking about HTTP 2

00:00:54,210 --> 00:00:59,550
and how it's a lot more performance than

00:00:55,890 --> 00:01:01,920
it is with HTTP 1 but what is it

00:00:59,550 --> 00:01:04,050
actually so I'm here my name is erina

00:01:01,920 --> 00:01:06,630
I work for a Morgan DB I'm an engineer

00:01:04,050 --> 00:01:08,090
there these are my two friends who will

00:01:06,630 --> 00:01:12,630
help me out today

00:01:08,090 --> 00:01:15,270
- right slides and I'm gonna talk to you

00:01:12,630 --> 00:01:16,860
about HTTP 2 and I'm gonna take it

00:01:15,270 --> 00:01:20,880
slowly and that take it one frame at a

00:01:16,860 --> 00:01:23,000
time this joke will be funny in like two

00:01:20,880 --> 00:01:23,000
minutes

00:01:24,049 --> 00:01:30,030
all right so this has got it's got this

00:01:26,939 --> 00:01:31,860
talks got a bit of a theater wipe so

00:01:30,030 --> 00:01:35,700
we're gonna take it in Acts and I'll

00:01:31,860 --> 00:01:38,430
walk you through a bunch of them so the

00:01:35,700 --> 00:01:44,100
first one's a bit of a like a prelude so

00:01:38,430 --> 00:01:46,470
previously on HTTP files things that you

00:01:44,100 --> 00:01:49,079
have missed if you're familiar with a

00:01:46,470 --> 00:01:51,390
bit of like how hep-2 works this is a

00:01:49,079 --> 00:01:54,659
refresher but those who those of you who

00:01:51,390 --> 00:01:56,460
aren't this is a good kind of getting to

00:01:54,659 --> 00:01:58,560
know you before we dive a little bit

00:01:56,460 --> 00:02:02,460
deeper into the specifics of the spec

00:01:58,560 --> 00:02:04,500
and how it works and I know Jess so the

00:02:02,460 --> 00:02:07,680
primarily focus the primary focus of the

00:02:04,500 --> 00:02:09,869
protocol is on performance so we want to

00:02:07,680 --> 00:02:12,690
make sure that our web transfers are a

00:02:09,869 --> 00:02:14,730
lot faster so specifically its focuses

00:02:12,690 --> 00:02:16,470
on end-user perceived latency Network

00:02:14,730 --> 00:02:21,390
and server resource usage these are the

00:02:16,470 --> 00:02:22,600
people that maintain the HTTP - so HTTP

00:02:21,390 --> 00:02:25,720
00:02:22,600 --> 00:02:28,240
was put together in 1999 I did I had

00:02:25,720 --> 00:02:30,490
like internet quite once a week maybe in

00:02:28,240 --> 00:02:34,300
1999 so I don't know I don't remember

00:02:30,490 --> 00:02:36,760
Internet in 1999 but I wanted to look at

00:02:34,300 --> 00:02:39,940
like okay so what did Internet look like

00:02:36,760 --> 00:02:41,170
in the time that I remember and how how

00:02:39,940 --> 00:02:42,820
many requests are coming through

00:02:41,170 --> 00:02:44,950
whatever transfers and there's like this

00:02:42,820 --> 00:02:49,360
interesting tool called the HTTP archive

00:02:44,950 --> 00:02:51,280
and it's showing you kind of like the

00:02:49,360 --> 00:02:54,190
number of requests a number of transfers

00:02:51,280 --> 00:02:56,770
made it goes and looks into the top 500

00:02:54,190 --> 00:03:00,420
websites over time I think they started

00:02:56,770 --> 00:03:03,280
in 2010 so I got the the data from 2010

00:03:00,420 --> 00:03:05,740
which is when I remembered the internet

00:03:03,280 --> 00:03:07,090
I don't remember it in 1999 maybe I'm

00:03:05,740 --> 00:03:07,750
just one of those Millennials I don't

00:03:07,090 --> 00:03:14,500
know

00:03:07,750 --> 00:03:15,810
so in 98 in 2010 speeds were great we

00:03:14,500 --> 00:03:18,160
weren't doing too many transfers

00:03:15,810 --> 00:03:19,990
probably one TCP connection was enough

00:03:18,160 --> 00:03:23,920
to be able to send one or two requests

00:03:19,990 --> 00:03:25,890
over but in the previous year in the

00:03:23,920 --> 00:03:30,190
previous year we've obviously increased

00:03:25,890 --> 00:03:34,060
all of our traffic so with working with

00:03:30,190 --> 00:03:37,360
HTTP 1 what happens is that given a

00:03:34,060 --> 00:03:39,610
particular request we one request

00:03:37,360 --> 00:03:42,400
happens over a single TCP connection

00:03:39,610 --> 00:03:45,640
which means that anytime we need to be

00:03:42,400 --> 00:03:47,680
making multiple TCP connections or

00:03:45,640 --> 00:03:49,090
multiple requests we run them

00:03:47,680 --> 00:03:51,190
concurrently we'll need to make multiple

00:03:49,090 --> 00:03:52,690
connections so eventually we're just

00:03:51,190 --> 00:03:55,900
gonna have connection after connection

00:03:52,690 --> 00:03:59,200
after connection you can only deliver

00:03:55,900 --> 00:04:02,950
one request at a time rather than

00:03:59,200 --> 00:04:05,980
multiple and to be able to achieve power

00:04:02,950 --> 00:04:09,340
parallel parallel requests you'll need

00:04:05,980 --> 00:04:12,820
to have multiple TCP connections so what

00:04:09,340 --> 00:04:14,440
that causes is your first packet will be

00:04:12,820 --> 00:04:16,720
kind of in queue to be able to be

00:04:14,440 --> 00:04:18,450
processed but all the other packets will

00:04:16,720 --> 00:04:21,070
not be able to be processed afterwards

00:04:18,450 --> 00:04:23,140
so they're kind of blocked so you end up

00:04:21,070 --> 00:04:25,060
in this head-of-line blocking situation

00:04:23,140 --> 00:04:26,860
where you can process your requests and

00:04:25,060 --> 00:04:31,750
obviously we're doing that a lot more

00:04:26,860 --> 00:04:33,729
than we were in 1999 or 2010 but let's

00:04:31,750 --> 00:04:34,950
look at what an HTTP 1 server looks like

00:04:33,729 --> 00:04:37,260
it's pretty easy

00:04:34,950 --> 00:04:39,110
node we just create server we handle the

00:04:37,260 --> 00:04:41,490
server we've got a request response

00:04:39,110 --> 00:04:45,120
again a single one happens over a single

00:04:41,490 --> 00:04:47,720
TCP connection and there we are and we

00:04:45,120 --> 00:04:51,990
get a protocol HTTP point one point one

00:04:47,720 --> 00:04:54,510
so what it's gp2 happened is we wanted

00:04:51,990 --> 00:04:56,010
to increase the number of requests we

00:04:54,510 --> 00:04:57,990
were able to make over a single TCP

00:04:56,010 --> 00:04:59,580
connection because obviously the

00:04:57,990 --> 00:05:02,160
head-of-line blocking doesn't work very

00:04:59,580 --> 00:05:04,800
well so what happens with HTTP T's you

00:05:02,160 --> 00:05:06,840
have a single connection that takes in

00:05:04,800 --> 00:05:09,240
multiple streams and multiple streams

00:05:06,840 --> 00:05:11,610
are able to handle multiple connections

00:05:09,240 --> 00:05:13,470
at the given time but more on that later

00:05:11,610 --> 00:05:15,120
this is like a little bit of an overview

00:05:13,470 --> 00:05:16,620
and we're gonna dive deep as to what

00:05:15,120 --> 00:05:20,220
these streams actually are and what they

00:05:16,620 --> 00:05:21,540
do and what is a notion of request and

00:05:20,220 --> 00:05:24,270
response and they should be - because

00:05:21,540 --> 00:05:26,730
it's a little bit different so an HTTP

00:05:24,270 --> 00:05:29,280
tea server and node since version 8.4

00:05:26,730 --> 00:05:32,880
you're able to work with a create secure

00:05:29,280 --> 00:05:35,040
service so you need a key and a cert and

00:05:32,880 --> 00:05:38,790
this one is meant to be incompatible

00:05:35,040 --> 00:05:40,560
mode and you're able to you create a

00:05:38,790 --> 00:05:42,600
stream and kind of respond with the same

00:05:40,560 --> 00:05:44,670
kind of aspect and works the same way

00:05:42,600 --> 00:05:45,900
maybe needs a little bit more code but

00:05:44,670 --> 00:05:49,170
it works the same way and you get an

00:05:45,900 --> 00:05:51,630
HTTP - protocol response when you get

00:05:49,170 --> 00:05:53,310
stuff back so it's it's a little bit

00:05:51,630 --> 00:05:55,440
more complicated and we kind of see

00:05:53,310 --> 00:05:57,840
these new concepts of there's this

00:05:55,440 --> 00:05:59,970
stream that we're not quite sure about

00:05:57,840 --> 00:06:04,770
and the stream duct responds which is

00:05:59,970 --> 00:06:06,750
not response and in particular or rispa

00:06:04,770 --> 00:06:10,860
you start fried head or anything like

00:06:06,750 --> 00:06:14,970
that which is the usual HTTP 1 node API

00:06:10,860 --> 00:06:17,610
so this one was allowing HTTP 1 to

00:06:14,970 --> 00:06:20,670
happen which means it's compatible with

00:06:17,610 --> 00:06:21,900
both HTTP 1 and CP 2 but there's also a

00:06:20,670 --> 00:06:23,880
combat mode that looks a lot more

00:06:21,900 --> 00:06:26,460
something that we're used to so you're

00:06:23,880 --> 00:06:27,900
still getting requests a response you're

00:06:26,460 --> 00:06:31,200
still able to create a secure server

00:06:27,900 --> 00:06:32,790
with a key and assert to sign and you

00:06:31,200 --> 00:06:36,690
still get their response at end and that

00:06:32,790 --> 00:06:41,370
gets us the same result and they kind of

00:06:36,690 --> 00:06:45,180
look similar and you're still able to

00:06:41,370 --> 00:06:47,070
get the same HTTP protocol so htv-2

00:06:45,180 --> 00:06:49,370
brings a couple of little winds a little

00:06:47,070 --> 00:06:49,370
winds

00:06:49,690 --> 00:06:54,590
that once you concentrate as we walk

00:06:53,090 --> 00:06:57,860
through the stock one of them is stream

00:06:54,590 --> 00:06:59,660
prioritization the other one is being

00:06:57,860 --> 00:07:02,030
able to do something that's called

00:06:59,660 --> 00:07:05,420
server push and another one is

00:07:02,030 --> 00:07:07,160
compressing into TP headers so ATP 2 is

00:07:05,420 --> 00:07:09,320
a binary protocol so you don't have the

00:07:07,160 --> 00:07:12,170
textual responses that you would have

00:07:09,320 --> 00:07:13,910
with HTTP 1 and so compression of HTTP 2

00:07:12,170 --> 00:07:16,250
headers comes in and it gets utilized

00:07:13,910 --> 00:07:19,130
and very efficiently and helps us with

00:07:16,250 --> 00:07:20,870
the binary protocol all right so let's

00:07:19,130 --> 00:07:23,990
talk about the connection and actually

00:07:20,870 --> 00:07:25,640
how that happens with HTTP - so you

00:07:23,990 --> 00:07:27,820
start off with a single connection so

00:07:25,640 --> 00:07:31,400
this is kind of what makes up an HTTP 2

00:07:27,820 --> 00:07:34,190
client was a client-server kind of

00:07:31,400 --> 00:07:35,630
relationship you start off with a

00:07:34,190 --> 00:07:38,300
connection a connection can have

00:07:35,630 --> 00:07:40,160
multiple streams and these multiple

00:07:38,300 --> 00:07:42,410
streams will have several frames and

00:07:40,160 --> 00:07:45,050
frames are the unit of measure of HTTP 2

00:07:42,410 --> 00:07:46,610
so instead of having a request response

00:07:45,050 --> 00:07:48,440
all the data gets passed in through

00:07:46,610 --> 00:07:50,150
frames and we'll talk about frames a

00:07:48,440 --> 00:07:51,800
little bit further on and kind of talk

00:07:50,150 --> 00:07:53,570
of a little bit more detail as to what's

00:07:51,800 --> 00:07:55,010
going on there so instead a request

00:07:53,570 --> 00:07:58,010
response all the data gets passed

00:07:55,010 --> 00:08:00,830
through mr frames and frames are part of

00:07:58,010 --> 00:08:03,590
your streams and those streams are part

00:08:00,830 --> 00:08:05,930
of a TCP connection so that's already a

00:08:03,590 --> 00:08:07,370
lot more kind of from the overview it

00:08:05,930 --> 00:08:12,860
looks a lot more efficient than it would

00:08:07,370 --> 00:08:14,570
with HTTP 1 so clients won't always know

00:08:12,860 --> 00:08:17,140
ahead of time whether they can accept

00:08:14,570 --> 00:08:20,450
whether the server can accept an HTTP 2

00:08:17,140 --> 00:08:23,390
request so how will this kind of

00:08:20,450 --> 00:08:24,890
connection work with the two clients so

00:08:23,390 --> 00:08:27,770
what you start off with for the client

00:08:24,890 --> 00:08:31,580
is you say hey I might want to I would

00:08:27,770 --> 00:08:33,230
like to upgrade to a TP 2 if I can let's

00:08:31,580 --> 00:08:35,810
do this and you'll pass in the

00:08:33,230 --> 00:08:38,110
connection header as part of that and

00:08:35,810 --> 00:08:42,890
you say that I would like to upgrade

00:08:38,110 --> 00:08:44,720
you'll do this some alp and negotiations

00:08:42,890 --> 00:08:46,820
on whether or not you can connect over H

00:08:44,720 --> 00:08:48,920
if you want or HCP - I keep calling it

00:08:46,820 --> 00:08:51,110
ALPA Alpine connection but I know it's a

00:08:48,920 --> 00:08:54,890
LPN I just want to go to mountains maybe

00:08:51,110 --> 00:08:56,930
I miss mountains then the server will

00:08:54,890 --> 00:09:00,320
say that hey I can actually upgrade I

00:08:56,930 --> 00:09:01,800
can take an HCP - we can make this an

00:09:00,320 --> 00:09:03,779
HTTP 2 connection

00:09:01,800 --> 00:09:06,240
I'm gonna upgrade I'm gonna send you a

00:09:03,779 --> 00:09:11,160
101 and you can keep sending me stuff in

00:09:06,240 --> 00:09:13,529
HTTP to rather than HTTP 1 the to the to

00:09:11,160 --> 00:09:17,220
acknowledge there's a lot of like it's a

00:09:13,529 --> 00:09:19,140
very kind of acknowledgment based

00:09:17,220 --> 00:09:21,000
situation where the to acknowledge

00:09:19,140 --> 00:09:22,290
server in the client and whether or not

00:09:21,000 --> 00:09:25,050
something can be done or something

00:09:22,290 --> 00:09:27,300
cannot be done it's very healthy and

00:09:25,050 --> 00:09:28,800
then the client can then send over the

00:09:27,300 --> 00:09:34,380
settings frame and say what it exactly

00:09:28,800 --> 00:09:35,910
once in terms of I kind of anything that

00:09:34,380 --> 00:09:37,620
it would require eventually from the

00:09:35,910 --> 00:09:39,300
server it's going to let oh no in this

00:09:37,620 --> 00:09:41,190
sitting stream so now I've talked about

00:09:39,300 --> 00:09:43,709
frames a few times and we'll get to them

00:09:41,190 --> 00:09:45,930
I promise in a little bit but that's

00:09:43,709 --> 00:09:47,190
kind of how the negotiations happens and

00:09:45,930 --> 00:09:48,540
I said I will talk about them when they

00:09:47,190 --> 00:09:50,250
knew I would talk about him

00:09:48,540 --> 00:09:52,589
so frames we're gonna talk about frames

00:09:50,250 --> 00:09:55,709
so the single unit of measure and frames

00:09:52,589 --> 00:09:57,420
lots of frames because that's how a CB 2

00:09:55,709 --> 00:10:01,740
protocol works is that you just keep

00:09:57,420 --> 00:10:04,019
sending over frames so that's how you

00:10:01,740 --> 00:10:05,670
communicate between two endpoints you

00:10:04,019 --> 00:10:12,089
send one over you send one back you some

00:10:05,670 --> 00:10:14,610
went over a some one back so data and

00:10:12,089 --> 00:10:18,029
headers are kind of the two you the two

00:10:14,610 --> 00:10:19,770
that kind of come up can over and over

00:10:18,029 --> 00:10:21,390
again eventually you might have

00:10:19,770 --> 00:10:23,760
something like settings or window

00:10:21,390 --> 00:10:25,800
updates that lets the client know but

00:10:23,760 --> 00:10:28,920
one thing or another but everything gets

00:10:25,800 --> 00:10:31,140
passed over from one to the other but if

00:10:28,920 --> 00:10:32,430
the header block is they afford the one

00:10:31,140 --> 00:10:34,920
and that's the one that gets compressed

00:10:32,430 --> 00:10:36,390
that I mentioned earlier and this one

00:10:34,920 --> 00:10:37,860
gets bundled up with a few different

00:10:36,390 --> 00:10:39,600
ones so like the headers or the push

00:10:37,860 --> 00:10:44,250
promise but we'll talk in a little bit

00:10:39,600 --> 00:10:46,709
or the continuation frames so when I've

00:10:44,250 --> 00:10:49,110
talked about the little ones compressing

00:10:46,709 --> 00:10:50,730
HTTP headers was one of them so what

00:10:49,110 --> 00:10:53,240
happens with the compression is that

00:10:50,730 --> 00:10:55,730
like you would send over a couple of

00:10:53,240 --> 00:10:58,380
[Music]

00:10:55,730 --> 00:11:01,170
sorry so what happens with the

00:10:58,380 --> 00:11:02,790
compression is that it kind of optimizes

00:11:01,170 --> 00:11:06,000
instead of getting sent in plain text

00:11:02,790 --> 00:11:07,769
and what people have discovered is that

00:11:06,000 --> 00:11:11,220
if you keep sending them in plain text

00:11:07,769 --> 00:11:13,170
you kind of use 500 to 800 bytes every

00:11:11,220 --> 00:11:15,360
time but if you have cookies and a lot

00:11:13,170 --> 00:11:19,140
of the times we'll we'll have cookies

00:11:15,360 --> 00:11:20,760
to be sent over the wire as well it ends

00:11:19,140 --> 00:11:23,610
up being in kilobytes so that's quite a

00:11:20,760 --> 00:11:27,630
bit of that's kind of kind of cut a bit

00:11:23,610 --> 00:11:28,890
of traffic to be dealing with so when

00:11:27,630 --> 00:11:31,440
you set off headers you send them in a

00:11:28,890 --> 00:11:33,060
like a list I'll be content type it'll

00:11:31,440 --> 00:11:34,860
be some cookies and things like that you

00:11:33,060 --> 00:11:36,930
send them in the list and then get put

00:11:34,860 --> 00:11:40,140
together by the protocol in a little

00:11:36,930 --> 00:11:42,899
block and then that block uses Huffman

00:11:40,140 --> 00:11:44,640
encoding and I won't talk about Huffman

00:11:42,899 --> 00:11:47,399
encoding here but that Huffman encoding

00:11:44,640 --> 00:11:49,800
gets put together compressed in an octet

00:11:47,399 --> 00:11:51,360
block and it's Huffman encoded so it's a

00:11:49,800 --> 00:11:53,640
lots more smaller and it's binary

00:11:51,360 --> 00:11:55,620
instead of being textual which is a lot

00:11:53,640 --> 00:11:57,959
better and then like I've mentioned

00:11:55,620 --> 00:11:59,880
previously it gets put together with the

00:11:57,959 --> 00:12:01,860
headers the push promise or the

00:11:59,880 --> 00:12:04,170
continuation frames there are just the

00:12:01,860 --> 00:12:06,510
type of frames that could be sent over

00:12:04,170 --> 00:12:08,279
by the client or the server but you

00:12:06,510 --> 00:12:09,839
won't necessarily have to deal with them

00:12:08,279 --> 00:12:13,440
directly when you build out your

00:12:09,839 --> 00:12:15,690
application so we talked about streams

00:12:13,440 --> 00:12:18,600
we talked about the fact that a TCP

00:12:15,690 --> 00:12:20,730
connection can have multiple streams it

00:12:18,600 --> 00:12:23,100
we talked about the fact that streams

00:12:20,730 --> 00:12:26,100
can handle frames as we've just

00:12:23,100 --> 00:12:30,390
mentioned in the previous scene so let's

00:12:26,100 --> 00:12:32,339
talk about streams I I don't usually

00:12:30,390 --> 00:12:34,140
like reading specs because I think it's

00:12:32,339 --> 00:12:35,399
a lot of wording and like I don't like

00:12:34,140 --> 00:12:38,699
what they put together but this is a

00:12:35,399 --> 00:12:40,709
really good explanation from the spec so

00:12:38,699 --> 00:12:43,829
streams are independent bi-directional

00:12:40,709 --> 00:12:45,510
sequence of frames so frames being part

00:12:43,829 --> 00:12:47,339
of the stream exchanged between the

00:12:45,510 --> 00:12:49,769
client and the server was in a given

00:12:47,339 --> 00:12:52,769
HTTP 2 connection so that's a really

00:12:49,769 --> 00:12:54,720
good definition from a spec I like it so

00:12:52,769 --> 00:12:58,829
a stream can have a couple of states

00:12:54,720 --> 00:13:01,260
that it just keeps rotating over so it

00:12:58,829 --> 00:13:03,480
can be an idle stream a reserved open

00:13:01,260 --> 00:13:06,140
stream meaning a stream that is being

00:13:03,480 --> 00:13:08,940
prepared to receive or send over data

00:13:06,140 --> 00:13:11,070
and a stream that's half closed that has

00:13:08,940 --> 00:13:14,430
finished sending over data or a closed

00:13:11,070 --> 00:13:16,410
stream that is no longer in use so you

00:13:14,430 --> 00:13:18,269
kind of keep moving over to those and

00:13:16,410 --> 00:13:20,250
frames keep coming through and coming

00:13:18,269 --> 00:13:24,390
through and eventually it gets closed

00:13:20,250 --> 00:13:26,699
off again multiple streams exist for a

00:13:24,390 --> 00:13:28,629
single connection instead of with HTTP

00:13:26,699 --> 00:13:30,850
one just being the one

00:13:28,629 --> 00:13:34,600
we've seen that before multiple streams

00:13:30,850 --> 00:13:37,540
one connection and once you get them

00:13:34,600 --> 00:13:40,360
through your endpoint you'll get several

00:13:37,540 --> 00:13:42,550
frames from several streams and they can

00:13:40,360 --> 00:13:45,179
be combined from different streams when

00:13:42,550 --> 00:13:47,290
you receive them instead of being

00:13:45,179 --> 00:13:51,069
instead of just being taken from the

00:13:47,290 --> 00:13:53,529
single stream so stream prioritization I

00:13:51,069 --> 00:13:54,670
wanted to briefly mention this a lot of

00:13:53,529 --> 00:13:56,350
the time is when you're actually working

00:13:54,670 --> 00:13:57,699
with a cheapy - you won't have to deal

00:13:56,350 --> 00:13:59,350
with this unless you want to build out

00:13:57,699 --> 00:14:00,579
your own kind of server in the client

00:13:59,350 --> 00:14:04,629
but it's kind of interesting to know

00:14:00,579 --> 00:14:07,059
which is why I kind of dived in deep

00:14:04,629 --> 00:14:10,119
into this topic so because you have

00:14:07,059 --> 00:14:12,369
multiple streams and you'll want to be

00:14:10,119 --> 00:14:14,410
able to not have them come in at the

00:14:12,369 --> 00:14:17,369
same time and resolve at the same time

00:14:14,410 --> 00:14:19,899
you'll want to be prioritizing them and

00:14:17,369 --> 00:14:21,970
that's one of the really cool things

00:14:19,899 --> 00:14:24,339
about HTTP - is that you can prioritize

00:14:21,970 --> 00:14:26,769
which resources you want to use where

00:14:24,339 --> 00:14:29,230
and which ones you want to prioritize

00:14:26,769 --> 00:14:31,449
over other ones so certain pieces of

00:14:29,230 --> 00:14:35,230
data can be sent over faster than other

00:14:31,449 --> 00:14:37,389
pieces of data and to be able to deal

00:14:35,230 --> 00:14:39,100
with that what you do is you assign

00:14:37,389 --> 00:14:42,069
string dependencies to different

00:14:39,100 --> 00:14:44,259
portions of your of your connection and

00:14:42,069 --> 00:14:47,589
then different weights and weights are

00:14:44,259 --> 00:14:50,049
the ones that resolve the streams faster

00:14:47,589 --> 00:14:53,649
so if something has a higher weight so

00:14:50,049 --> 00:14:55,990
we have four streams here and stream 2

00:14:53,649 --> 00:14:58,839
in steam 3 are dependent on stream 1

00:14:55,990 --> 00:15:01,360
stream 4 is dependent on steams stream 3

00:14:58,839 --> 00:15:05,259
so see stream 4 will not resolve before

00:15:01,360 --> 00:15:07,929
stream 3 but since steam 3 and stream 2

00:15:05,259 --> 00:15:10,990
on the same level or like they they're

00:15:07,929 --> 00:15:14,410
both dependent on stream 1 they're gonna

00:15:10,990 --> 00:15:17,110
like compete for resources but because

00:15:14,410 --> 00:15:19,389
we've assigned weights to them we know

00:15:17,110 --> 00:15:21,819
that stream 3 is more important with a

00:15:19,389 --> 00:15:23,980
better weight or like a higher weight so

00:15:21,819 --> 00:15:26,319
a resolved faster and then they don't

00:15:23,980 --> 00:15:29,529
compete for the resources and in streams

00:15:26,319 --> 00:15:31,809
2 will resolve after that so that's how

00:15:29,529 --> 00:15:37,720
HCP two handles kind of resources a lot

00:15:31,809 --> 00:15:38,709
better and a lot smarter than 81 so we

00:15:37,720 --> 00:15:40,600
kind of talked about stream

00:15:38,709 --> 00:15:41,310
prioritization and talked about how

00:15:40,600 --> 00:15:44,279
we're

00:15:41,310 --> 00:15:46,620
resources and another way of managing

00:15:44,279 --> 00:15:48,960
resources that http/2 has is flow

00:15:46,620 --> 00:15:50,760
control and this one's a kind of

00:15:48,960 --> 00:15:52,950
interesting and then you're able to kind

00:15:50,760 --> 00:15:55,380
of solve this between the client and the

00:15:52,950 --> 00:15:58,230
server so because we have multiplex

00:15:55,380 --> 00:16:01,500
streams over a single TCP connection

00:15:58,230 --> 00:16:04,170
sometimes because we multiplex them that

00:16:01,500 --> 00:16:06,450
can cause congestion on a given TCP

00:16:04,170 --> 00:16:08,610
connection so too many of them and a

00:16:06,450 --> 00:16:10,560
single TCP connection we need to be able

00:16:08,610 --> 00:16:14,670
to communicate to the client as to how

00:16:10,560 --> 00:16:19,110
many or what are the important resources

00:16:14,670 --> 00:16:21,120
so multiplexing them helps so this

00:16:19,110 --> 00:16:25,020
because the streams have several states

00:16:21,120 --> 00:16:26,730
that they go through idle reserved open

00:16:25,020 --> 00:16:28,860
have closed and closed there's only

00:16:26,730 --> 00:16:33,750
certain ones that count towards this

00:16:28,860 --> 00:16:35,940
flow control flow control markings and

00:16:33,750 --> 00:16:37,940
there are the reserved open and half

00:16:35,940 --> 00:16:40,490
closed so closed and idle don't count

00:16:37,940 --> 00:16:43,710
but what happens is that when you send

00:16:40,490 --> 00:16:46,170
data specifically the data frames they

00:16:43,710 --> 00:16:48,720
count towards the number that the server

00:16:46,170 --> 00:16:51,240
will have so server has a number that it

00:16:48,720 --> 00:16:53,820
specifically sends over to the client

00:16:51,240 --> 00:16:56,040
and says I can only handle this much I

00:16:53,820 --> 00:16:58,020
can only spend or give you this many

00:16:56,040 --> 00:17:00,600
resources at the same time so I'm gonna

00:16:58,020 --> 00:17:02,970
let you know how are you doing it's a

00:17:00,600 --> 00:17:04,620
credit-based system so data and headers

00:17:02,970 --> 00:17:06,600
are the only ones that affect this and

00:17:04,620 --> 00:17:08,699
only the streams that are reserved open

00:17:06,600 --> 00:17:10,980
or half closed to count towards this and

00:17:08,699 --> 00:17:13,730
every time it's like you've used parts

00:17:10,980 --> 00:17:16,079
of that particular flow control number

00:17:13,730 --> 00:17:17,850
sir we'll send you a window update

00:17:16,079 --> 00:17:21,089
letting you know that hey you're kind of

00:17:17,850 --> 00:17:23,670
you're using stuff up so it will

00:17:21,089 --> 00:17:25,140
communicate to the client how well

00:17:23,670 --> 00:17:27,209
you're doing in terms of you like your

00:17:25,140 --> 00:17:29,190
credit based system and it works like a

00:17:27,209 --> 00:17:31,800
credit-based system so you take away you

00:17:29,190 --> 00:17:35,520
put back especially you put back when

00:17:31,800 --> 00:17:37,050
the stream is closed so flow control

00:17:35,520 --> 00:17:40,440
helps you prioritize streams so they

00:17:37,050 --> 00:17:42,870
don't block and so you're able to not

00:17:40,440 --> 00:17:45,990
over utilize and not congest your TCP

00:17:42,870 --> 00:17:48,690
connection all right so we talked about

00:17:45,990 --> 00:17:51,720
kind of the general concepts of HTTP -

00:17:48,690 --> 00:17:54,000
and this will all of this applies to no

00:17:51,720 --> 00:17:54,750
js' but I wanted to like walk you

00:17:54,000 --> 00:17:56,310
through how

00:17:54,750 --> 00:17:59,820
this works in nodejs and kind of what

00:17:56,310 --> 00:18:02,790
the flow of data is between when you

00:17:59,820 --> 00:18:04,260
receive a request from the clients and

00:18:02,790 --> 00:18:06,890
when you send back their response so

00:18:04,260 --> 00:18:10,410
what does know do so you start off with

00:18:06,890 --> 00:18:13,890
having an incoming call an incoming

00:18:10,410 --> 00:18:15,990
secure connection that comes in to your

00:18:13,890 --> 00:18:18,540
server to your node up to your node

00:18:15,990 --> 00:18:22,470
server what happens is that libuv will

00:18:18,540 --> 00:18:25,020
handle parts of that i/o you will then

00:18:22,470 --> 00:18:28,680
open up a stream in a session it's taken

00:18:25,020 --> 00:18:31,260
the data and libous a cell will decrypt

00:18:28,680 --> 00:18:33,390
that connection what will happen after

00:18:31,260 --> 00:18:35,820
the connection is decrypted is TLS

00:18:33,390 --> 00:18:38,130
termination and after that you're able

00:18:35,820 --> 00:18:40,680
to get through and restart receiving

00:18:38,130 --> 00:18:42,000
frames from the client including the

00:18:40,680 --> 00:18:44,160
settings frame which I mentioned a

00:18:42,000 --> 00:18:47,370
little bit earlier so once you start

00:18:44,160 --> 00:18:51,800
coming once request started coming in in

00:18:47,370 --> 00:18:56,280
forms of frames a package called a dingy

00:18:51,800 --> 00:18:57,930
http/2 it's a c++ bucket it will start

00:18:56,280 --> 00:19:01,260
parsing the request into frames

00:18:57,930 --> 00:19:04,680
specifically and then those frames will

00:19:01,260 --> 00:19:08,100
be able to send events and raw data

00:19:04,680 --> 00:19:10,200
once those are parsed into that they are

00:19:08,100 --> 00:19:12,180
now able to be put together in your

00:19:10,200 --> 00:19:14,580
node.js application that you can work

00:19:12,180 --> 00:19:16,980
with because you can't work with that

00:19:14,580 --> 00:19:18,630
beforehand so once those events and raw

00:19:16,980 --> 00:19:20,310
data and they're part of your node.js

00:19:18,630 --> 00:19:23,700
application and then you as a developer

00:19:20,310 --> 00:19:25,230
are able to handle particular things you

00:19:23,700 --> 00:19:27,510
want to do and send back the response

00:19:25,230 --> 00:19:30,090
back to the client so all of these

00:19:27,510 --> 00:19:32,490
happen before you're able to actually

00:19:30,090 --> 00:19:34,200
manipulate the response which is kind of

00:19:32,490 --> 00:19:36,570
interesting to know because he kind of

00:19:34,200 --> 00:19:39,030
just can work with the request response

00:19:36,570 --> 00:19:40,560
or you can also work with the request

00:19:39,030 --> 00:19:42,660
response and know a little bit more

00:19:40,560 --> 00:19:45,750
about how no it handles these particular

00:19:42,660 --> 00:19:48,120
things one of the things we talked about

00:19:45,750 --> 00:19:49,830
that was parts of the little wins is

00:19:48,120 --> 00:19:51,600
server push and server push is an

00:19:49,830 --> 00:19:54,420
interesting one and then something that

00:19:51,600 --> 00:19:56,370
was put together with HTTP 2 and I'll do

00:19:54,420 --> 00:20:07,800
a little bit of example when we get to

00:19:56,370 --> 00:20:08,470
this as a server push allows you to

00:20:07,800 --> 00:20:11,530
preempt

00:20:08,470 --> 00:20:14,320
we send data to the client before it

00:20:11,530 --> 00:20:17,080
needs it so this puts it into the

00:20:14,320 --> 00:20:18,370
clients cache and then once the client

00:20:17,080 --> 00:20:20,409
needs it it doesn't have to make a

00:20:18,370 --> 00:20:23,620
request to the server it already has the

00:20:20,409 --> 00:20:26,169
data which is really cool so I'm gonna

00:20:23,620 --> 00:20:27,370
use a package cause called TLS keygen I

00:20:26,169 --> 00:20:30,130
really wanted to give a shout out to

00:20:27,370 --> 00:20:31,900
this one because developing in localhost

00:20:30,130 --> 00:20:34,480
and creating secure service is a little

00:20:31,900 --> 00:20:37,390
bit hard so this package allows you to

00:20:34,480 --> 00:20:38,919
be able to do that on localhost so you

00:20:37,390 --> 00:20:40,929
still have the key in the cert and

00:20:38,919 --> 00:20:44,169
you're able to create a secure server on

00:20:40,929 --> 00:20:45,789
that I think sub for building it this

00:20:44,169 --> 00:20:47,380
human lives in Singapore and I met them

00:20:45,789 --> 00:20:49,600
there that was cool

00:20:47,380 --> 00:20:51,370
so we're gonna do is streamed up push

00:20:49,600 --> 00:20:52,900
and I will actually pull up my terminal

00:20:51,370 --> 00:21:03,850
because it might be a little bit easier

00:20:52,900 --> 00:21:06,700
than just on the slide so this is the

00:21:03,850 --> 00:21:09,760
parts of the TLS key gen package that

00:21:06,700 --> 00:21:11,799
handles your keys in the certs but what

00:21:09,760 --> 00:21:15,549
we'll do is we'll just create a secure

00:21:11,799 --> 00:21:17,919
server using the key in the cert and

00:21:15,549 --> 00:21:19,960
will allow for HTTP 1 which is the

00:21:17,919 --> 00:21:25,059
compatible mode so we can take both HTTP

00:21:19,960 --> 00:21:27,100
1 and GPT request and what we'll do is

00:21:25,059 --> 00:21:31,150
we'll push certain parts of data and I

00:21:27,100 --> 00:21:33,490
thought like the the more interesting

00:21:31,150 --> 00:21:37,090
one to do is bundle dot CSS because I

00:21:33,490 --> 00:21:40,510
feel like with what this is useful for

00:21:37,090 --> 00:21:41,530
is especially CSS when you're working

00:21:40,510 --> 00:21:42,850
with a particular part of the

00:21:41,530 --> 00:21:45,250
application and you're loading

00:21:42,850 --> 00:21:47,380
pre-loading parts of it of the CSS that

00:21:45,250 --> 00:21:51,370
you'll need later on is super fast and

00:21:47,380 --> 00:21:54,070
super efficient so we're gonna do a push

00:21:51,370 --> 00:21:56,289
stream and it takes some headers and we

00:21:54,070 --> 00:22:00,370
know that we want to send the path

00:21:56,289 --> 00:22:03,059
that's bundle dot CSS and when we send

00:22:00,370 --> 00:22:06,460
back the response from the server we'll

00:22:03,059 --> 00:22:08,590
make sure that this server actually is

00:22:06,460 --> 00:22:11,730
sorry the client actually wants the CSS

00:22:08,590 --> 00:22:16,150
so make sure that the stylesheet is

00:22:11,730 --> 00:22:20,169
there and what push stream will do is

00:22:16,150 --> 00:22:21,940
they'll respond with 200 and it'll send

00:22:20,169 --> 00:22:24,310
back some background color

00:22:21,940 --> 00:22:28,900
that's hot pink to match the rest of the

00:22:24,310 --> 00:22:31,000
presentation I already had the server

00:22:28,900 --> 00:22:33,670
running so the next thing to do is just

00:22:31,000 --> 00:22:35,920
to actually see it I usually use a

00:22:33,670 --> 00:22:39,130
nightly but I'm gonna use Chrome for

00:22:35,920 --> 00:22:40,150
this because nightly has this weird

00:22:39,130 --> 00:22:47,980
thing where I can't even see the

00:22:40,150 --> 00:22:49,660
protocol inside of the network tab so it

00:22:47,980 --> 00:22:53,890
just has one line I don't think we need

00:22:49,660 --> 00:22:59,920
to see it any more so that's 8,000 and

00:22:53,890 --> 00:23:01,780
so the background color got pushed but

00:22:59,920 --> 00:23:04,390
the more interesting thing is to see the

00:23:01,780 --> 00:23:13,840
network tab so I'm just gonna show you

00:23:04,390 --> 00:23:17,410
that and refresh so we're getting to

00:23:13,840 --> 00:23:20,830
just the localhost and we're getting the

00:23:17,410 --> 00:23:23,080
protocol HTTP too and there's no

00:23:20,830 --> 00:23:30,190
particular initiator but once we get to

00:23:23,080 --> 00:23:34,510
bundle dot CSS we can see that it was

00:23:30,190 --> 00:23:36,400
pushed preemptively and we can see that

00:23:34,510 --> 00:23:39,730
it sent over the response that

00:23:36,400 --> 00:23:42,310
background color is pink and the

00:23:39,730 --> 00:23:44,940
interesting part is that regardless of

00:23:42,310 --> 00:23:47,140
whether or not the client has to ask

00:23:44,940 --> 00:23:48,820
you're still going to transfer the same

00:23:47,140 --> 00:23:52,090
amount of data it's just gonna be faster

00:23:48,820 --> 00:23:53,980
in terms of you won't have to have the

00:23:52,090 --> 00:23:56,200
client ask you for stuff instead you

00:23:53,980 --> 00:23:59,140
just have it there for them especially

00:23:56,200 --> 00:24:00,910
if you know it's already there it's

00:23:59,140 --> 00:24:04,050
something they will need so this is for

00:24:00,910 --> 00:24:07,240
you as a developer kind of to decide

00:24:04,050 --> 00:24:10,150
so that's server pushed and it's I think

00:24:07,240 --> 00:24:11,830
it's a pretty cool feature all right so

00:24:10,150 --> 00:24:13,150
the tail they are ie

00:24:11,830 --> 00:24:14,920
what have we learned in this

00:24:13,150 --> 00:24:18,160
presentation or hope that you've learned

00:24:14,920 --> 00:24:20,350
in this presentation so I wanted to

00:24:18,160 --> 00:24:21,880
mention we were talking about node HT p2

00:24:20,350 --> 00:24:24,580
is still under the experimental flag

00:24:21,880 --> 00:24:26,080
this is a and this is the first time I'm

00:24:24,580 --> 00:24:29,350
telling you this but it's under

00:24:26,080 --> 00:24:31,810
experimental tag there is like literally

00:24:29,350 --> 00:24:33,049
yesterday James put out a discussion

00:24:31,810 --> 00:24:36,590
issue

00:24:33,049 --> 00:24:38,299
the node repo saying though they're

00:24:36,590 --> 00:24:39,919
trying to get it out of the experimental

00:24:38,299 --> 00:24:40,999
 as soon as possible so if you're

00:24:39,919 --> 00:24:42,980
thinking I'm using it in production

00:24:40,999 --> 00:24:45,440
probably report some of the bugs do you

00:24:42,980 --> 00:24:47,059
have or if you are using it in

00:24:45,440 --> 00:24:48,919
production report the bugs you have so

00:24:47,059 --> 00:24:52,070
we can get it as experimental tagged as

00:24:48,919 --> 00:24:53,960
soon as possible but kind of the

00:24:52,070 --> 00:24:55,850
takeaways is the fact that you can use

00:24:53,960 --> 00:24:59,210
push and push allows you to preventively

00:24:55,850 --> 00:25:01,519
preemptively and proactively send a

00:24:59,210 --> 00:25:03,789
bunch of stuff to the client before it

00:25:01,519 --> 00:25:06,799
needs it and loaded into clients cache

00:25:03,789 --> 00:25:11,330
the fact that we have flow control and

00:25:06,799 --> 00:25:14,179
the fact that we have stream

00:25:11,330 --> 00:25:15,649
prioritization we're able to use the TCP

00:25:14,179 --> 00:25:18,200
connection better and have better

00:25:15,649 --> 00:25:20,570
performance gains which means you don't

00:25:18,200 --> 00:25:23,590
have to use a single TCP connection per

00:25:20,570 --> 00:25:26,450
request but instead you use multiple

00:25:23,590 --> 00:25:28,940
streams in a given a request unable to

00:25:26,450 --> 00:25:31,879
send frames over those and the fact that

00:25:28,940 --> 00:25:35,929
the combat mode exists in nodejs who are

00:25:31,879 --> 00:25:38,179
able to quite easily switch to http - in

00:25:35,929 --> 00:25:39,649
fact it looks very similar - the fact

00:25:38,179 --> 00:25:42,649
that you need the keys and certs which

00:25:39,649 --> 00:25:46,100
you'll need anyway in an HTTP server so

00:25:42,649 --> 00:25:50,720
it's quite easy to switch over and

00:25:46,100 --> 00:25:53,350
that's it for me today NOFA and today

00:25:50,720 --> 00:25:53,350
would say in the movie

00:25:56,290 --> 00:26:02,390
yeah thanks thanks so much and thanks to

00:26:00,049 --> 00:26:04,429
organizers and I think Lindsay is doing

00:26:02,390 --> 00:26:06,710
life captioning thank you for that and

00:26:04,429 --> 00:26:08,660
thank you for listening to my mumbles

00:26:06,710 --> 00:26:11,770
come say hi I'm on Twitter and you can

00:26:08,660 --> 00:26:11,770
email me thanks

00:26:18,100 --> 00:26:20,160

YouTube URL: https://www.youtube.com/watch?v=KpkTLmLTvAI


