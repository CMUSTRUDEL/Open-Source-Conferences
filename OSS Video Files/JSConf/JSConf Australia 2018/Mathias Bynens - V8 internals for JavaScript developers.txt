Title: Mathias Bynens - V8 internals for JavaScript developers
Publication date: 2018-04-11
Playlist: JSConf Australia 2018
Description: 
	This presentation demonstrates how learning just a little bit about JavaScript engine internals can help you improve the run-time performance of your JavaScript code — not just in V8 specifically, but across all JavaScript engines!

I’ll start by explaining how V8 handles arrays behind the scenes, and especially how it can optimize operations on them. I can do all of this with my “JS developer” hat on, i.e. without showing a single line of C++. This knowledge leads to useful insights for JavaScript developers wishing to improve their code’s run-time performance. In the end, the audience will walk away with several practical performance tips, and a deeper understanding of what’s going on under the hood.

Slides: https://slidr.io/mathiasbynens/v8-internals-for-javascript-developers#1
Writeup: https://v8project.blogspot.com.au/2017/09/elements-kinds-in-v8.html
Captions: 
	00:00:10,820 --> 00:00:16,710
hi everyone how's it going today we're

00:00:15,180 --> 00:00:18,600
gonna take a look behind the scenes of

00:00:16,710 --> 00:00:20,310
JavaScript engines and specifically

00:00:18,600 --> 00:00:22,260
we're gonna take a look at what that

00:00:20,310 --> 00:00:25,410
means for JavaScript developers like you

00:00:22,260 --> 00:00:27,029
and I now I work on the v8 team at

00:00:25,410 --> 00:00:28,919
Google and v8 is the JavaScript engine

00:00:27,029 --> 00:00:31,650
that's used within Google Chrome but

00:00:28,919 --> 00:00:33,570
also note yes and some other projects so

00:00:31,650 --> 00:00:35,610
let's just initialize this environment

00:00:33,570 --> 00:00:38,700
variable right there and update the

00:00:35,610 --> 00:00:41,100
slides and there we go yeah so

00:00:38,700 --> 00:00:44,310
disclaimer I am going to talk about some

00:00:41,100 --> 00:00:46,110
v8 specific internals but I guarantee

00:00:44,310 --> 00:00:47,580
that all the performance advice that

00:00:46,110 --> 00:00:49,830
will draw from this knowledge applies

00:00:47,580 --> 00:00:51,480
not just to v8 and Chrome but to all

00:00:49,830 --> 00:00:53,130
browsers and all JavaScript engines

00:00:51,480 --> 00:00:56,610
across the board and I think that's

00:00:53,130 --> 00:00:59,400
really important so let's get right into

00:00:56,610 --> 00:01:01,800
it javascript objects can have arbitrary

00:00:59,400 --> 00:01:03,900
properties associated with them the

00:01:01,800 --> 00:01:06,150
names of these properties can consist of

00:01:03,900 --> 00:01:08,280
alphanumeric characters or even weird

00:01:06,150 --> 00:01:10,049
Unicode characters as well but one

00:01:08,280 --> 00:01:11,549
specific case that JavaScript engines

00:01:10,049 --> 00:01:13,710
can choose to optimize for our

00:01:11,549 --> 00:01:17,130
properties whose names are entirely

00:01:13,710 --> 00:01:20,429
numeric more specifically array indexes

00:01:17,130 --> 00:01:22,409
in v8 array indexes are stored

00:01:20,429 --> 00:01:24,450
separately they're treated specially

00:01:22,409 --> 00:01:26,390
although in many circumstances these

00:01:24,450 --> 00:01:29,219
properties behave just like other

00:01:26,390 --> 00:01:31,499
properties v8 chooses to store them

00:01:29,219 --> 00:01:34,200
separately from non numeric properties

00:01:31,499 --> 00:01:36,329
for optimization purposes internally via

00:01:34,200 --> 00:01:39,270
v8 even gives these properties a name

00:01:36,329 --> 00:01:41,789
they're called elements so think of it

00:01:39,270 --> 00:01:45,329
this way objects have properties and

00:01:41,789 --> 00:01:47,999
values and arrays have indexes that map

00:01:45,329 --> 00:01:51,450
to elements it's just the names that we

00:01:47,999 --> 00:01:53,909
use in v8 now whenever you're running

00:01:51,450 --> 00:01:55,850
JavaScript code v8 keeps track of what

00:01:53,909 --> 00:01:58,590
kind of elements each array contains

00:01:55,850 --> 00:02:00,749
this information allows VA to optimize

00:01:58,590 --> 00:02:03,479
any operations on the array specifically

00:02:00,749 --> 00:02:05,819
for this type of elements so for example

00:02:03,479 --> 00:02:07,649
when you call reduce or map or for each

00:02:05,819 --> 00:02:09,539
on an array if yet can use that

00:02:07,649 --> 00:02:13,050
information to optimize those calls

00:02:09,539 --> 00:02:15,690
now take this array for example what

00:02:13,050 --> 00:02:18,000
kind of elements does it contain well if

00:02:15,690 --> 00:02:19,409
you were to ask the typeof operator in

00:02:18,000 --> 00:02:22,230
JavaScript it will tell you that all

00:02:19,409 --> 00:02:23,160
these three elements are numbers at the

00:02:22,230 --> 00:02:24,990
JavaScript language

00:02:23,160 --> 00:02:27,780
that's all you'll get JavaScript doesn't

00:02:24,990 --> 00:02:30,180
distinguish between integers floats and

00:02:27,780 --> 00:02:31,920
doubles but behind the scenes in the

00:02:30,180 --> 00:02:35,880
JavaScript engine itself we can make

00:02:31,920 --> 00:02:38,130
this more precise distinction so the

00:02:35,880 --> 00:02:41,130
elements count for this array is packed

00:02:38,130 --> 00:02:42,810
my elements and we'll get to the packed

00:02:41,130 --> 00:02:47,250
part in a minute so ignore that for now

00:02:42,810 --> 00:02:50,670
for now focus on the my part in v8 smile

00:02:47,250 --> 00:02:52,770
is a smile refers to the particular

00:02:50,670 --> 00:02:54,870
format that we use to store small

00:02:52,770 --> 00:02:58,320
integers that's what it stands for small

00:02:54,870 --> 00:03:00,510
integer later adding a floating-point

00:02:58,320 --> 00:03:03,290
number to the same array transitions the

00:03:00,510 --> 00:03:07,740
elements kinds to a more generic version

00:03:03,290 --> 00:03:09,420
packed double elements now adding a

00:03:07,740 --> 00:03:13,830
string literal to the array changes the

00:03:09,420 --> 00:03:15,990
elements kind once again v8 assigns and

00:03:13,830 --> 00:03:17,580
elements kind to each array and as we've

00:03:15,990 --> 00:03:19,500
seen the elements kind of an array is

00:03:17,580 --> 00:03:21,930
not stat in stone it can change at

00:03:19,500 --> 00:03:23,940
runtime in this case we transitions all

00:03:21,930 --> 00:03:28,140
the way from packets my elements to

00:03:23,940 --> 00:03:30,090
packed elements so far we've seen three

00:03:28,140 --> 00:03:33,270
distinct elements kinds there's one for

00:03:30,090 --> 00:03:35,160
smize doubles and regular elements you

00:03:33,270 --> 00:03:36,360
can think of this as a pyramid because

00:03:35,160 --> 00:03:38,850
the set of numbers that can be

00:03:36,360 --> 00:03:40,320
represented as a smile is a subset of

00:03:38,850 --> 00:03:41,640
the numbers that can be represented as a

00:03:40,320 --> 00:03:44,760
double and the same thing goes for

00:03:41,640 --> 00:03:45,930
doubles versus regular elements but

00:03:44,760 --> 00:03:48,000
what's important here is that these

00:03:45,930 --> 00:03:50,100
element kind transitions can only occur

00:03:48,000 --> 00:03:52,440
in one direction you go from a very

00:03:50,100 --> 00:03:54,420
specific one like the ones at the top to

00:03:52,440 --> 00:03:56,940
one that is more general like the ones

00:03:54,420 --> 00:03:59,970
at the bottom it only goes downwards and

00:03:56,940 --> 00:04:01,830
once we transition to packed elements

00:03:59,970 --> 00:04:03,840
which is for regular elements we can

00:04:01,830 --> 00:04:05,760
never transition upwards again we can

00:04:03,840 --> 00:04:09,600
never go back up to packed double

00:04:05,760 --> 00:04:12,600
elements for example now going back to

00:04:09,600 --> 00:04:15,540
that array that we had before the array

00:04:12,600 --> 00:04:18,090
contains five elements what happens if

00:04:15,540 --> 00:04:19,980
we assign a value to do the index that

00:04:18,090 --> 00:04:22,080
is far outside of the arrays boundaries

00:04:19,980 --> 00:04:25,680
for example if we assign a value at

00:04:22,080 --> 00:04:28,440
position nine in the array while doing

00:04:25,680 --> 00:04:30,570
this creates holes in the array the

00:04:28,440 --> 00:04:34,200
holes are at positions five until eight

00:04:30,570 --> 00:04:35,839
the array is now sparse or holy as we

00:04:34,200 --> 00:04:37,919
call it in v8

00:04:35,839 --> 00:04:39,990
so creating holes in the array

00:04:37,919 --> 00:04:42,479
downgrades the elements guides to it's a

00:04:39,990 --> 00:04:45,990
holy variant in this case we went from

00:04:42,479 --> 00:04:47,669
packed elements to holy elements now

00:04:45,990 --> 00:04:49,469
there are other ways of creating holes

00:04:47,669 --> 00:04:51,689
for example if you use the delete

00:04:49,469 --> 00:04:53,879
operator on an indexed element that also

00:04:51,689 --> 00:04:56,249
creates a hole or if you have an array

00:04:53,879 --> 00:04:58,080
literal and you just forget to assign a

00:04:56,249 --> 00:04:59,969
value like for example if you have two

00:04:58,080 --> 00:05:03,629
commas and there is no value in between

00:04:59,969 --> 00:05:05,490
them that would also create a hole so

00:05:03,629 --> 00:05:07,800
why does Fiat care so much about whether

00:05:05,490 --> 00:05:09,210
there's a hole in an array or not why

00:05:07,800 --> 00:05:11,879
does it care so much that it has a

00:05:09,210 --> 00:05:15,050
separate elements kind for holes let's

00:05:11,879 --> 00:05:17,610
find out by taking a look at an example

00:05:15,050 --> 00:05:18,719
just pretend that you're a JavaScript

00:05:17,610 --> 00:05:19,349
engine for the next couple of minutes

00:05:18,719 --> 00:05:21,569
okay

00:05:19,349 --> 00:05:24,689
and you're getting the element at index

00:05:21,569 --> 00:05:26,009
eight what's the value for the element

00:05:24,689 --> 00:05:28,199
at index eight that's the question that

00:05:26,009 --> 00:05:30,270
we need to answer you can't just give

00:05:28,199 --> 00:05:32,460
the answer right away you have to do

00:05:30,270 --> 00:05:36,719
some work you have to follow the spec to

00:05:32,460 --> 00:05:39,149
get the answer so v8 starts off by doing

00:05:36,719 --> 00:05:41,310
a bounced check on the array index is

00:05:39,149 --> 00:05:44,159
this index between zero inclusive and

00:05:41,310 --> 00:05:46,649
the length of the array exclusive and in

00:05:44,159 --> 00:05:47,939
this case the bounds check succeeds but

00:05:46,649 --> 00:05:50,039
we still cannot really answer the

00:05:47,939 --> 00:05:53,729
question of what the result is more work

00:05:50,039 --> 00:05:56,310
is needed so now we look up the property

00:05:53,729 --> 00:05:57,839
named eight on the array itself but in

00:05:56,310 --> 00:06:01,259
this case that property doesn't exist

00:05:57,839 --> 00:06:03,749
because all that's there is a hole so we

00:06:01,259 --> 00:06:06,479
still cannot answer the question we have

00:06:03,749 --> 00:06:08,039
to take a little deeper now because the

00:06:06,479 --> 00:06:10,110
property is not present on the array

00:06:08,039 --> 00:06:12,719
itself we have to grow up the prototype

00:06:10,110 --> 00:06:15,870
chain until either a value is found or

00:06:12,719 --> 00:06:17,309
the prototype chain ends and the first

00:06:15,870 --> 00:06:19,169
thing we check in a prototype chain is

00:06:17,309 --> 00:06:22,289
array the prototype because that's the

00:06:19,169 --> 00:06:24,449
prototype for any array and this does

00:06:22,289 --> 00:06:27,809
not have a product this does not have a

00:06:24,449 --> 00:06:29,669
property named 8 defined on it so at

00:06:27,809 --> 00:06:31,770
this point we still do not know what the

00:06:29,669 --> 00:06:34,889
answer is we have to continue to follow

00:06:31,770 --> 00:06:36,719
the prototype chain now the next item in

00:06:34,889 --> 00:06:38,430
a prototype chain is object or prototype

00:06:36,719 --> 00:06:40,860
because that's the prototype of a radar

00:06:38,430 --> 00:06:44,939
prototype and we check if the property

00:06:40,860 --> 00:06:47,009
eight exists there but it doesn't and in

00:06:44,939 --> 00:06:49,200
this case the prototype chain ends after

00:06:47,009 --> 00:06:51,060
reaching object dot prototype

00:06:49,200 --> 00:06:52,980
it could be even longer in case someone

00:06:51,060 --> 00:06:54,600
extended it that is a totally valid

00:06:52,980 --> 00:06:56,640
thing to do in JavaScript you can muck

00:06:54,600 --> 00:06:59,550
with built-in prototypes and we'd say

00:06:56,640 --> 00:07:00,960
it's probably a bad practice but as a

00:06:59,550 --> 00:07:02,550
JavaScript engine you have to support

00:07:00,960 --> 00:07:05,520
these cases because it can happen in the

00:07:02,550 --> 00:07:07,530
real world now in this case because the

00:07:05,520 --> 00:07:09,360
chain ends we cannot continue searching

00:07:07,530 --> 00:07:12,600
for the property which means we can now

00:07:09,360 --> 00:07:15,570
finally answer our question the hole at

00:07:12,600 --> 00:07:19,470
position 8 in the array is undefined yay

00:07:15,570 --> 00:07:21,510
finally well from a JavaScript engines

00:07:19,470 --> 00:07:23,580
perspective that's a lot of work that we

00:07:21,510 --> 00:07:27,240
just did just to get an undefined value

00:07:23,580 --> 00:07:29,640
right now if you compare that to a

00:07:27,240 --> 00:07:32,070
packed array which is an array that is

00:07:29,640 --> 00:07:33,600
guaranteed to have no holes in it it

00:07:32,070 --> 00:07:36,570
turns out that we don't actually have to

00:07:33,600 --> 00:07:38,520
do up a lot of this work if the array

00:07:36,570 --> 00:07:40,650
index is within bounds then the

00:07:38,520 --> 00:07:43,200
JavaScript engine can already return the

00:07:40,650 --> 00:07:44,550
value no other checks or expensive

00:07:43,200 --> 00:07:47,700
lookups on the prototype chain are

00:07:44,550 --> 00:07:50,670
needed at all now if we go back to a

00:07:47,700 --> 00:07:52,920
holy array even if we get a property

00:07:50,670 --> 00:07:55,230
that does exist within a holy array

00:07:52,920 --> 00:07:57,930
there's still a bit more work that we

00:07:55,230 --> 00:07:59,910
have to do we have to check if the

00:07:57,930 --> 00:08:03,060
property exists first because we know

00:07:59,910 --> 00:08:04,260
there are holes in this array so vhx if

00:08:03,060 --> 00:08:06,960
the index is within the bounds of the

00:08:04,260 --> 00:08:08,670
array and it is but it still doesn't

00:08:06,960 --> 00:08:12,000
have enough information to return the

00:08:08,670 --> 00:08:14,400
results so we must check if the property

00:08:12,000 --> 00:08:16,440
actually exists in the array just in

00:08:14,400 --> 00:08:19,320
case there is a hole at this position in

00:08:16,440 --> 00:08:22,140
this case a property exists so we can

00:08:19,320 --> 00:08:23,670
finally return its value now if the

00:08:22,140 --> 00:08:25,110
property didn't exist we would be back

00:08:23,670 --> 00:08:26,760
in the situation from before where I

00:08:25,110 --> 00:08:28,740
would have to look up prototype chain

00:08:26,760 --> 00:08:31,560
which is very expensive and bad for

00:08:28,740 --> 00:08:34,170
performance now this is the very best

00:08:31,560 --> 00:08:36,210
case scenario for a holy array and it's

00:08:34,170 --> 00:08:39,210
still one more operation compared to a

00:08:36,210 --> 00:08:42,030
packed array and this is why in general

00:08:39,210 --> 00:08:45,060
packed arrays are preferred over holy

00:08:42,030 --> 00:08:46,710
arrays operations on packed arrays can

00:08:45,060 --> 00:08:48,570
just be optimized in a much more

00:08:46,710 --> 00:08:50,790
aggressive way than operations on holy

00:08:48,570 --> 00:08:52,200
arrays for optimal performance you

00:08:50,790 --> 00:08:55,440
should try and avoid creating holes

00:08:52,200 --> 00:08:57,150
whenever you can so we looked at this

00:08:55,440 --> 00:08:59,790
pyramid before with this list of

00:08:57,150 --> 00:09:01,680
elements kinds there's smize doubles and

00:08:59,790 --> 00:09:02,730
regular elements and we knew that we can

00:09:01,680 --> 00:09:05,220
transition

00:09:02,730 --> 00:09:06,990
downwards throughout this pyramid but

00:09:05,220 --> 00:09:08,610
now we learned that it turns out there's

00:09:06,990 --> 00:09:10,350
actually two flavors for each of these

00:09:08,610 --> 00:09:12,269
elements kinds there's the packed

00:09:10,350 --> 00:09:14,610
version and there's a Holi version and

00:09:12,269 --> 00:09:16,680
not only can we transition downwards we

00:09:14,610 --> 00:09:19,769
can also transition from left to right

00:09:16,680 --> 00:09:21,329
we can go from packed to holy so instead

00:09:19,769 --> 00:09:22,800
of two separate pyramids it's probably a

00:09:21,329 --> 00:09:25,500
little bit easier to think of elements

00:09:22,800 --> 00:09:27,389
kinds as a lattice and that is in fact

00:09:25,500 --> 00:09:29,100
how v8 implements the system around

00:09:27,389 --> 00:09:31,440
elements kinds and the transitions

00:09:29,100 --> 00:09:32,360
between them more concretely it looks

00:09:31,440 --> 00:09:35,730
something like this

00:09:32,360 --> 00:09:37,620
so we have our smile double and regular

00:09:35,730 --> 00:09:38,070
elements and each of those comes in two

00:09:37,620 --> 00:09:40,110
flavors

00:09:38,070 --> 00:09:42,269
there's the pact and the holy version

00:09:40,110 --> 00:09:44,910
now these are the most common array

00:09:42,269 --> 00:09:46,649
elements kinds but v8 distinguishes

00:09:44,910 --> 00:09:48,810
about twenty different elements kinds

00:09:46,649 --> 00:09:51,300
for other things like typed arrays as

00:09:48,810 --> 00:09:52,980
well and you can only transition

00:09:51,300 --> 00:09:54,660
downwards throughout this lattice it's

00:09:52,980 --> 00:09:56,760
kind of like that pokemon blue tower

00:09:54,660 --> 00:09:58,139
puzzle where all the tiles have like an

00:09:56,760 --> 00:09:59,820
arrow drawn on the floor and when you

00:09:58,139 --> 00:10:01,740
step on a tile you can only move in that

00:09:59,820 --> 00:10:03,269
direction the same goes here you can

00:10:01,740 --> 00:10:05,670
only follow the arrows throughout the

00:10:03,269 --> 00:10:07,949
lattice which means you can never go

00:10:05,670 --> 00:10:10,079
back up once a single floating-point

00:10:07,949 --> 00:10:12,269
number is added to an array it is marked

00:10:10,079 --> 00:10:15,329
as double even if it later consists of

00:10:12,269 --> 00:10:17,519
Smiles only and similarly once you

00:10:15,329 --> 00:10:22,170
create a hole in an array it has marked

00:10:17,519 --> 00:10:24,029
as holy now in general more specific

00:10:22,170 --> 00:10:26,160
elements kinds enable more fine-grained

00:10:24,029 --> 00:10:28,139
optimizations the further down the

00:10:26,160 --> 00:10:30,209
elements kindness in this lattice the

00:10:28,139 --> 00:10:33,029
slower manipulations and operations on

00:10:30,209 --> 00:10:34,589
that object might be so for optimal

00:10:33,029 --> 00:10:36,990
performance it makes sense to needlessly

00:10:34,589 --> 00:10:39,000
to avoid needlessly transitioning

00:10:36,990 --> 00:10:41,310
between these elements kinds and stick

00:10:39,000 --> 00:10:44,310
to the most specific elements kinds that

00:10:41,310 --> 00:10:46,500
applies to your use case let's look at

00:10:44,310 --> 00:10:48,930
an example for that for each unique

00:10:46,500 --> 00:10:50,880
elements kind v8 can apply specific of

00:10:48,930 --> 00:10:53,100
image optimizations when performing

00:10:50,880 --> 00:10:55,560
operations on the array whenever you're

00:10:53,100 --> 00:10:57,180
using for each for example v8 can

00:10:55,560 --> 00:10:59,699
optimize this call based on this

00:10:57,180 --> 00:11:02,130
knowledge about the elements kind we can

00:10:59,699 --> 00:11:04,260
have one set of for each optimizations

00:11:02,130 --> 00:11:06,510
specifically for packets my elements

00:11:04,260 --> 00:11:10,019
another set of optimizations for packed

00:11:06,510 --> 00:11:12,269
double elements and so on and over time

00:11:10,019 --> 00:11:15,149
we can add more and more of these

00:11:12,269 --> 00:11:16,510
optimizations so if you look at chrome

00:11:15,149 --> 00:11:18,970
59 for example this

00:11:16,510 --> 00:11:21,310
when we just shipped a new pipeline in

00:11:18,970 --> 00:11:23,590
v8 we had ignition our new interpreter

00:11:21,310 --> 00:11:25,840
and turbofan our new optimizing compiler

00:11:23,590 --> 00:11:27,280
and at the time we didn't really do

00:11:25,840 --> 00:11:29,650
anything special with this information

00:11:27,280 --> 00:11:31,720
for for each so while we renew the

00:11:29,650 --> 00:11:33,700
elements kinds of these arrays we didn't

00:11:31,720 --> 00:11:36,370
specifically optimize any of these

00:11:33,700 --> 00:11:38,710
elements kinds but by the time chrome 61

00:11:36,370 --> 00:11:41,350
was released we had optimized for each

00:11:38,710 --> 00:11:45,280
in turbofan for all packed elements

00:11:41,350 --> 00:11:47,020
kinds and more recently in chrome 64 we

00:11:45,280 --> 00:11:49,360
added support for the holy elements

00:11:47,020 --> 00:11:51,280
kinds as well four for each specifically

00:11:49,360 --> 00:11:53,470
so this is a pattern that you'll see

00:11:51,280 --> 00:11:55,870
repeated over time over time we will add

00:11:53,470 --> 00:11:57,520
more and more fine-grain and specific

00:11:55,870 --> 00:11:59,980
optimizations for different elements

00:11:57,520 --> 00:12:01,740
kinds for specific array functionality

00:11:59,980 --> 00:12:05,620
so you could say the same thing about

00:12:01,740 --> 00:12:06,880
rate of prototype dot map for example we

00:12:05,620 --> 00:12:10,810
support all these different elements

00:12:06,880 --> 00:12:15,340
kinds for map in chrome 64 as well same

00:12:10,810 --> 00:12:17,680
goes for filter some every reduce reduce

00:12:15,340 --> 00:12:20,740
right and then there's some other array

00:12:17,680 --> 00:12:22,480
methods like find and find index and

00:12:20,740 --> 00:12:24,190
these two are a little bit special if

00:12:22,480 --> 00:12:26,470
you look them up in the spec you'll find

00:12:24,190 --> 00:12:27,910
that these Street holes in erase a

00:12:26,470 --> 00:12:29,710
little bit differently than all of the

00:12:27,910 --> 00:12:32,380
other array methods because they turn

00:12:29,710 --> 00:12:33,550
holes into explicit undefined values

00:12:32,380 --> 00:12:35,890
which makes things a little bit

00:12:33,550 --> 00:12:38,770
complicated for us and for that reason

00:12:35,890 --> 00:12:41,500
we haven't yet been able to optimize a

00:12:38,770 --> 00:12:42,700
holy double elements so far but like I

00:12:41,500 --> 00:12:44,350
said before this is something that we're

00:12:42,700 --> 00:12:46,480
working on and over time you can expect

00:12:44,350 --> 00:12:49,540
to see more green in these lattices for

00:12:46,480 --> 00:12:53,380
any given array method so very soon it

00:12:49,540 --> 00:12:55,540
will look like this now let's look at

00:12:53,380 --> 00:12:57,550
another example this piece of code

00:12:55,540 --> 00:13:00,240
creates an array of length 3

00:12:57,550 --> 00:13:03,730
but what values does the array contain

00:13:00,240 --> 00:13:06,250
it just has three holes in it so the

00:13:03,730 --> 00:13:08,530
array is sparse at this point so it gets

00:13:06,250 --> 00:13:11,410
the element kind holy smile

00:13:08,530 --> 00:13:13,240
holy is my elements because that's the

00:13:11,410 --> 00:13:16,210
most specific possibility given the

00:13:13,240 --> 00:13:18,280
currently available information now

00:13:16,210 --> 00:13:20,770
let's assign a value to position zero in

00:13:18,280 --> 00:13:23,080
the array well wait a minute that's a

00:13:20,770 --> 00:13:25,360
string instead of a small integer so in

00:13:23,080 --> 00:13:30,460
this case the elements kinds transitions

00:13:25,360 --> 00:13:32,380
to holy elements now we add a value

00:13:30,460 --> 00:13:34,150
to position one in the array and the

00:13:32,380 --> 00:13:36,610
elements kinds remains unchanged in this

00:13:34,150 --> 00:13:40,120
case and finally we sign another value

00:13:36,610 --> 00:13:41,650
to the last position in the array now at

00:13:40,120 --> 00:13:43,990
this point all three positions in the

00:13:41,650 --> 00:13:47,170
array are filled so the array is packed

00:13:43,990 --> 00:13:49,090
and no longer sparse however we cannot

00:13:47,170 --> 00:13:51,310
transition to a more specific kind as

00:13:49,090 --> 00:13:54,640
packed elements as we saw after we seen

00:13:51,310 --> 00:13:56,860
earlier so unfortunately the elements

00:13:54,640 --> 00:13:59,380
kind remains holy elements at this point

00:13:56,860 --> 00:14:01,660
once an array is marked as holy it is

00:13:59,380 --> 00:14:04,960
holy forever I believe that's how

00:14:01,660 --> 00:14:06,880
sainthood works as well now in this

00:14:04,960 --> 00:14:08,560
scenario a better solution is of course

00:14:06,880 --> 00:14:10,690
to use an array literal instead if you

00:14:08,560 --> 00:14:12,460
know all the values ahead of time then

00:14:10,690 --> 00:14:15,070
why not just add them in an array

00:14:12,460 --> 00:14:16,990
literal but if you don't know all the

00:14:15,070 --> 00:14:18,940
values ahead of time you can still use a

00:14:16,990 --> 00:14:20,710
technique that is similar you can start

00:14:18,940 --> 00:14:22,000
off with an empty array or with an array

00:14:20,710 --> 00:14:24,400
that contains some of the values that

00:14:22,000 --> 00:14:26,470
you already know and then you can push

00:14:24,400 --> 00:14:28,030
more values to it as you dynamically

00:14:26,470 --> 00:14:30,460
compute them or get them from some

00:14:28,030 --> 00:14:32,260
external source that way you avoid

00:14:30,460 --> 00:14:34,360
creating holes in the array at any given

00:14:32,260 --> 00:14:37,120
time and the array will never get marked

00:14:34,360 --> 00:14:39,340
as holy this approach ensures that v8

00:14:37,120 --> 00:14:43,240
optimizes any future operations on the

00:14:39,340 --> 00:14:46,210
array to the best of its abilities life

00:14:43,240 --> 00:14:47,950
is easier without poles JavaScript

00:14:46,210 --> 00:14:50,590
engines can deal with packed arrays much

00:14:47,950 --> 00:14:51,970
more efficiently in general if you need

00:14:50,590 --> 00:14:54,400
to perform lots of operations on an

00:14:51,970 --> 00:14:58,330
array try and avoid creating holes in it

00:14:54,400 --> 00:15:00,400
and similarly you should avoid reading

00:14:58,330 --> 00:15:03,250
beyond the length of the array because

00:15:00,400 --> 00:15:04,600
there's nothing there anyway so for

00:15:03,250 --> 00:15:07,180
example don't write your loops like this

00:15:04,600 --> 00:15:10,600
this loop reads all the elements in the

00:15:07,180 --> 00:15:12,400
array and then one more it only stops

00:15:10,600 --> 00:15:14,800
when it finds an undefined or null

00:15:12,400 --> 00:15:16,540
element so this also means that it would

00:15:14,800 --> 00:15:20,380
only work for arrays that don't contain

00:15:16,540 --> 00:15:23,020
undefined or no now this kind of pattern

00:15:20,380 --> 00:15:24,600
is just as bad as hitting a hole it's a

00:15:23,020 --> 00:15:27,220
different scenario but it's very similar

00:15:24,600 --> 00:15:29,620
because in this case the bounds check

00:15:27,220 --> 00:15:31,260
that we did before fails the check to

00:15:29,620 --> 00:15:33,460
see if the property is present fails and

00:15:31,260 --> 00:15:35,380
then we need to look up the prototype

00:15:33,460 --> 00:15:38,620
chain just like before and as we've

00:15:35,380 --> 00:15:40,420
learned that is very expensive so don't

00:15:38,620 --> 00:15:42,760
do this and instead keep your loop

00:15:40,420 --> 00:15:44,270
simple if you have to write out your own

00:15:42,760 --> 00:15:46,550
loop you can do

00:15:44,270 --> 00:15:48,440
do it the simple way you can keep track

00:15:46,550 --> 00:15:51,260
of the index and keep iterating until

00:15:48,440 --> 00:15:52,550
you hit the last element when the

00:15:51,260 --> 00:15:54,560
collection you're looping over is

00:15:52,550 --> 00:15:56,750
iterable which is the case for arrays

00:15:54,560 --> 00:15:59,090
and node lists for example then that's

00:15:56,750 --> 00:16:01,310
even better you can just use for off and

00:15:59,090 --> 00:16:03,020
this is my favorite way of looping over

00:16:01,310 --> 00:16:06,320
any kind of collection in JavaScript

00:16:03,020 --> 00:16:08,030
because it's so simple now for arrays

00:16:06,320 --> 00:16:10,280
specifically of course you can also use

00:16:08,030 --> 00:16:12,830
array dot prototype out for each that

00:16:10,280 --> 00:16:15,560
also works and the good news today is

00:16:12,830 --> 00:16:18,250
that whether you want to use for each or

00:16:15,560 --> 00:16:20,150
write your own for loop or use for off

00:16:18,250 --> 00:16:21,980
performance-wise it doesn't matter

00:16:20,150 --> 00:16:23,930
anymore which means you can just make

00:16:21,980 --> 00:16:26,180
that decision and pick your favorite

00:16:23,930 --> 00:16:27,950
without performance being a factor in

00:16:26,180 --> 00:16:33,410
that decision I think that's pretty

00:16:27,950 --> 00:16:35,870
great now avoid creating avoid reading

00:16:33,410 --> 00:16:37,640
beyond the end of the array in summary

00:16:35,870 --> 00:16:41,000
so doing so is just as bad as hitting a

00:16:37,640 --> 00:16:43,520
hole now before we move on to some more

00:16:41,000 --> 00:16:46,070
performance advice here's a fun facts

00:16:43,520 --> 00:16:48,500
javascript has two zeros there's the

00:16:46,070 --> 00:16:49,960
regular zero which is positive but

00:16:48,500 --> 00:16:52,550
there's also a negative zero and

00:16:49,960 --> 00:16:53,060
although these values are strictly equal

00:16:52,550 --> 00:16:54,850
to each other

00:16:53,060 --> 00:16:56,600
because of course why wouldn't they be

00:16:54,850 --> 00:16:58,640
it turns out that they're actually

00:16:56,600 --> 00:17:00,520
observably different in some cases and

00:16:58,640 --> 00:17:02,840
object op is is an example of that

00:17:00,520 --> 00:17:05,000
because they behave differently

00:17:02,840 --> 00:17:07,339
it means javascript engines has have to

00:17:05,000 --> 00:17:09,440
store these values separately as well in

00:17:07,339 --> 00:17:11,510
different ways and the reason I'm

00:17:09,440 --> 00:17:16,100
telling you this is because this has an

00:17:11,510 --> 00:17:17,780
impact on elements kinds I mentioned

00:17:16,100 --> 00:17:19,790
earlier that a piece of advice when it

00:17:17,780 --> 00:17:21,290
comes to elements kind is to avoid

00:17:19,790 --> 00:17:23,930
transitioning to a less specific

00:17:21,290 --> 00:17:25,970
elements kind whenever you can and this

00:17:23,930 --> 00:17:28,820
is actually harder than it seems for

00:17:25,970 --> 00:17:31,130
example just adding minus 0 to an array

00:17:28,820 --> 00:17:33,110
of small integers is enough to

00:17:31,130 --> 00:17:35,720
transition it to packed double elements

00:17:33,110 --> 00:17:37,250
any future operations on this array will

00:17:35,720 --> 00:17:39,020
now be optimized in a completely

00:17:37,250 --> 00:17:41,690
different way and they would be for

00:17:39,020 --> 00:17:43,820
smiles specifically so that's just one

00:17:41,690 --> 00:17:45,830
more reason to avoid negative 0 in

00:17:43,820 --> 00:17:47,180
general unless of course you need to

00:17:45,830 --> 00:17:49,520
explicitly differentiate between

00:17:47,180 --> 00:17:53,090
negative and positive 0 in your code but

00:17:49,520 --> 00:17:55,550
you probably don't now the same thing

00:17:53,090 --> 00:17:57,520
goes for nan and infinity these values

00:17:55,550 --> 00:17:59,380
are stored as a double

00:17:57,520 --> 00:18:01,330
which means that adding a single lamp to

00:17:59,380 --> 00:18:03,640
an array of smile elements transitions

00:18:01,330 --> 00:18:04,660
it to double elements so if you're

00:18:03,640 --> 00:18:06,880
planning on performing lots of

00:18:04,660 --> 00:18:08,740
operations on an array of integers you

00:18:06,880 --> 00:18:10,390
should consider normalizing the values

00:18:08,740 --> 00:18:13,330
before you're adding them to the array

00:18:10,390 --> 00:18:15,700
so normalize minus zero to positive zero

00:18:13,330 --> 00:18:18,010
and block-man and infinity when you're

00:18:15,700 --> 00:18:20,110
initializing the values this way the

00:18:18,010 --> 00:18:22,180
array sticks to the packets my elements

00:18:20,110 --> 00:18:24,220
kind and of course there's a one time

00:18:22,180 --> 00:18:25,600
normalization cost involved there for

00:18:24,220 --> 00:18:27,610
all the extra text that you do when

00:18:25,600 --> 00:18:30,850
you're initializing the array but it can

00:18:27,610 --> 00:18:32,200
be worth the later optimizations in fact

00:18:30,850 --> 00:18:34,480
if you're doing lots of mathematical

00:18:32,200 --> 00:18:35,950
operations on an array of numbers should

00:18:34,480 --> 00:18:38,170
probably look into using type arrays

00:18:35,950 --> 00:18:39,850
because v8 has specific elements guides

00:18:38,170 --> 00:18:43,030
for those as well and they're kind of

00:18:39,850 --> 00:18:44,560
optimized for this kind of thing in

00:18:43,030 --> 00:18:46,750
general if you need to perform lots of

00:18:44,560 --> 00:18:48,610
operations on an array try sticking to

00:18:46,750 --> 00:18:51,220
an elements kind that's as specific as

00:18:48,610 --> 00:18:55,300
possible so that v8 can optimize it as

00:18:51,220 --> 00:18:58,030
much as possible some objects in

00:18:55,300 --> 00:19:00,250
JavaScript especially in the Dom look

00:18:58,030 --> 00:19:02,440
like arrays although there aren't proper

00:19:00,250 --> 00:19:03,910
arrays it's possible to create array

00:19:02,440 --> 00:19:06,070
like objects yourself which is what I'm

00:19:03,910 --> 00:19:08,740
doing here this object has a length

00:19:06,070 --> 00:19:11,530
property and it supports indexed element

00:19:08,740 --> 00:19:13,870
access just like a real array but it

00:19:11,530 --> 00:19:16,300
lacks array methods like for each on its

00:19:13,870 --> 00:19:18,220
prototype it's still possible to call

00:19:16,300 --> 00:19:21,490
these array methods on this object

00:19:18,220 --> 00:19:23,590
though here we're calling the array for

00:19:21,490 --> 00:19:27,310
each built-in on the array like object

00:19:23,590 --> 00:19:29,590
and that works as expected however this

00:19:27,310 --> 00:19:31,750
is going to be slower than calling array

00:19:29,590 --> 00:19:34,750
than calling for each on a proper array

00:19:31,750 --> 00:19:36,280
which is highly optimized in v8 so if

00:19:34,750 --> 00:19:37,900
you plan on using array built-ins on

00:19:36,280 --> 00:19:40,120
this object more than once

00:19:37,900 --> 00:19:43,480
consider turning it into an actual array

00:19:40,120 --> 00:19:45,100
beforehand so that v8 can optimize these

00:19:43,480 --> 00:19:49,030
operations to the best of its abilities

00:19:45,100 --> 00:19:50,980
and here we're using slice to do that so

00:19:49,030 --> 00:19:54,580
of course there is a one-time cost of

00:19:50,980 --> 00:19:56,050
doing the actual slice call but this

00:19:54,580 --> 00:19:57,790
cost can be worth the later

00:19:56,050 --> 00:19:59,410
optimizations especially if you plan on

00:19:57,790 --> 00:20:03,550
performing lots of operations on the

00:19:59,410 --> 00:20:05,950
array and a specific example of this is

00:20:03,550 --> 00:20:07,750
the arguments object this is an array

00:20:05,950 --> 00:20:10,060
like object so when you call array

00:20:07,750 --> 00:20:11,380
built-in such as for each on it it works

00:20:10,060 --> 00:20:13,090
but it won't be fully up to

00:20:11,380 --> 00:20:16,210
that's the way it could be for a proper

00:20:13,090 --> 00:20:17,710
airing so nowadays I think there is a

00:20:16,210 --> 00:20:21,070
better solution to this in the form of

00:20:17,710 --> 00:20:22,930
es2015 rest parameters they produce

00:20:21,070 --> 00:20:25,330
proper arrays that can be used instead

00:20:22,930 --> 00:20:27,490
of the array like arguments objects in a

00:20:25,330 --> 00:20:28,960
very elegant way so nowadays I think

00:20:27,490 --> 00:20:30,220
there is no good reason to use the

00:20:28,960 --> 00:20:32,740
arguments object anymore

00:20:30,220 --> 00:20:34,810
use rest parameters it will make your

00:20:32,740 --> 00:20:38,130
code more elegant and more optimizable

00:20:34,810 --> 00:20:41,770
in various JavaScript engines as well

00:20:38,130 --> 00:20:43,330
this is not a real crocodile and it's

00:20:41,770 --> 00:20:46,210
not gonna have the same performance as a

00:20:43,330 --> 00:20:49,630
real crocodile the same thing goes for

00:20:46,210 --> 00:20:51,760
arrays in general you should avoid array

00:20:49,630 --> 00:20:56,260
like objects whenever possible and use

00:20:51,760 --> 00:20:57,580
real arrays instead now after all this

00:20:56,260 --> 00:20:59,380
talk about elements kinds you may be

00:20:57,580 --> 00:21:01,360
wondering how you can identify the

00:20:59,380 --> 00:21:03,010
elements kinds of a given array in your

00:21:01,360 --> 00:21:04,600
code base maybe you're debugging a

00:21:03,010 --> 00:21:05,950
performance issue or maybe you just want

00:21:04,600 --> 00:21:09,190
to have a deeper understanding of what

00:21:05,950 --> 00:21:10,900
I'm talking about well you can run you

00:21:09,190 --> 00:21:14,950
can compile v8 from source in a debug

00:21:10,900 --> 00:21:17,770
build and run the d8 binary d8 stands

00:21:14,950 --> 00:21:19,240
for developer shell or debug build no

00:21:17,770 --> 00:21:23,020
one on the v8 team really knows what it

00:21:19,240 --> 00:21:24,670
stands for actually it's a mystery D but

00:21:23,020 --> 00:21:27,880
what I do know is that you have to pass

00:21:24,670 --> 00:21:29,680
in the allow native syntax flag doing so

00:21:27,880 --> 00:21:31,750
enables access to some internal v8

00:21:29,680 --> 00:21:34,120
functionality from within JavaScript

00:21:31,750 --> 00:21:37,600
it's very powerful especially if you

00:21:34,120 --> 00:21:39,280
combine this with a debug build of v8 so

00:21:37,600 --> 00:21:40,990
entering that command opens up a wrapper

00:21:39,280 --> 00:21:42,520
which is very similar to what you get if

00:21:40,990 --> 00:21:44,620
you just type node on your command line

00:21:42,520 --> 00:21:47,980
except this way we can run some code

00:21:44,620 --> 00:21:50,500
directly in v8 so now it's time to write

00:21:47,980 --> 00:21:53,680
some code first we create the array that

00:21:50,500 --> 00:21:55,660
we want to test and then we call one of

00:21:53,680 --> 00:21:58,090
those special v8 internal functions on

00:21:55,660 --> 00:21:59,260
it in this case debug print and you see

00:21:58,090 --> 00:22:01,870
how the name there starts with a

00:21:59,260 --> 00:22:04,540
percentage sign yeah that's not actually

00:22:01,870 --> 00:22:06,010
valid JavaScript and the reason why we

00:22:04,540 --> 00:22:07,510
do this is because we don't want people

00:22:06,010 --> 00:22:08,980
to use this in production it doesn't

00:22:07,510 --> 00:22:11,530
make sense to use it in production and

00:22:08,980 --> 00:22:13,840
by making it invalid javascript we kind

00:22:11,530 --> 00:22:16,150
of force it on people that they cannot

00:22:13,840 --> 00:22:18,190
use this in production this would only

00:22:16,150 --> 00:22:20,350
work in this particular built of v8

00:22:18,190 --> 00:22:24,100
anyway so doesn't make sense to try to

00:22:20,350 --> 00:22:25,360
use it elsewhere now running this code

00:22:24,100 --> 00:22:27,100
prints a lot of output

00:22:25,360 --> 00:22:28,930
even more than what is shown here in the

00:22:27,100 --> 00:22:30,820
slide but in this case what we're

00:22:28,930 --> 00:22:32,790
looking for is the elements kind of the

00:22:30,820 --> 00:22:37,830
array which is listed on this line the

00:22:32,790 --> 00:22:40,090
elements kind is holy smile elements cow

00:22:37,830 --> 00:22:42,190
now that cow does not refer to the

00:22:40,090 --> 00:22:44,350
animal it stands for copy-on-write which

00:22:42,190 --> 00:22:46,390
is yet another internal optimization but

00:22:44,350 --> 00:22:48,190
don't worry about that for now we can

00:22:46,390 --> 00:22:50,190
talk about it in another presentation or

00:22:48,190 --> 00:22:52,870
just come talk to me later

00:22:50,190 --> 00:22:54,940
let's recap what we've seen so far we've

00:22:52,870 --> 00:22:56,800
explored what elements kinds are and how

00:22:54,940 --> 00:22:59,170
they work and as a result we were able

00:22:56,800 --> 00:23:02,560
to identify some practical tips that can

00:22:59,170 --> 00:23:06,310
help us boost performance avoid creating

00:23:02,560 --> 00:23:09,940
holes in arrays don't access array

00:23:06,310 --> 00:23:11,740
indexes beyond the arrays length try to

00:23:09,940 --> 00:23:13,690
keep the elements kind of your array as

00:23:11,740 --> 00:23:17,320
specific as possible by sticking to a

00:23:13,690 --> 00:23:19,330
single value type for each array avoid

00:23:17,320 --> 00:23:21,010
using array like objects and when you

00:23:19,330 --> 00:23:23,110
have to use them consider converting

00:23:21,010 --> 00:23:25,060
them into proper arrays before

00:23:23,110 --> 00:23:28,150
performing any expensive operations on

00:23:25,060 --> 00:23:30,700
them now although this presentation

00:23:28,150 --> 00:23:32,830
covered some v8 specific internals these

00:23:30,700 --> 00:23:34,420
tips don't just apply to v8 other

00:23:32,830 --> 00:23:36,580
JavaScript engines can benefit from them

00:23:34,420 --> 00:23:38,110
as well and by following this advice I

00:23:36,580 --> 00:23:39,670
guarantee you that your code is not

00:23:38,110 --> 00:23:41,410
going to get slower in any of the other

00:23:39,670 --> 00:23:45,010
engines in fact it will probably get

00:23:41,410 --> 00:23:46,270
faster across the board now there is one

00:23:45,010 --> 00:23:48,910
more thing that I quickly wanted to

00:23:46,270 --> 00:23:50,980
mention we went to an example like this

00:23:48,910 --> 00:23:53,140
before where we have an array and it has

00:23:50,980 --> 00:23:54,910
some values in it and if you know the

00:23:53,140 --> 00:23:56,800
values beforehand it makes sense to

00:23:54,910 --> 00:23:59,080
hard-code them into an array literal

00:23:56,800 --> 00:24:01,450
like this but things get more

00:23:59,080 --> 00:24:02,560
interesting for larger arrays especially

00:24:01,450 --> 00:24:04,450
if you don't know all the values

00:24:02,560 --> 00:24:06,160
beforehand maybe you're computing the

00:24:04,450 --> 00:24:08,470
values dynamically or you're fetching

00:24:06,160 --> 00:24:12,040
them from some third party source or

00:24:08,470 --> 00:24:14,110
whatever and if you know the length of

00:24:12,040 --> 00:24:16,360
this array ahead of time especially if

00:24:14,110 --> 00:24:17,650
the array is very large it makes sense

00:24:16,360 --> 00:24:20,440
to pass it through the array constructor

00:24:17,650 --> 00:24:22,270
like this and doing so ensures that

00:24:20,440 --> 00:24:25,510
JavaScript engines can pre allocate

00:24:22,270 --> 00:24:28,960
space for all the 9001 elements the

00:24:25,510 --> 00:24:30,340
array will hold the downside is as we've

00:24:28,960 --> 00:24:32,230
seen before that the array will be

00:24:30,340 --> 00:24:35,740
marked as holy from the moment it's

00:24:32,230 --> 00:24:38,050
created so there's some ups and some

00:24:35,740 --> 00:24:39,080
downs here when using the array

00:24:38,050 --> 00:24:40,880
constructor like this

00:24:39,080 --> 00:24:42,260
javascript engines can pre allocate the

00:24:40,880 --> 00:24:43,880
space that they need for the correct

00:24:42,260 --> 00:24:46,370
number of needed elements behind the

00:24:43,880 --> 00:24:48,260
scenes especially for large arrays this

00:24:46,370 --> 00:24:51,019
might speed up the actual creation of

00:24:48,260 --> 00:24:53,269
the array however the array is marked as

00:24:51,019 --> 00:24:55,880
holy from the beginning so there's

00:24:53,269 --> 00:24:58,909
potentially slower array operations on

00:24:55,880 --> 00:25:00,620
the array compared to packed arrays it

00:24:58,909 --> 00:25:02,210
depends on which you know what you want

00:25:00,620 --> 00:25:04,789
to optimize the creation or the

00:25:02,210 --> 00:25:06,890
operations of the array to avoid going

00:25:04,789 --> 00:25:08,720
holy we discussed this pattern where you

00:25:06,890 --> 00:25:10,429
start with an empty array and then as

00:25:08,720 --> 00:25:12,830
you get more values you just push them

00:25:10,429 --> 00:25:14,779
to the array now when you create an

00:25:12,830 --> 00:25:16,880
array the JavaScript engine creates a

00:25:14,779 --> 00:25:18,860
buffer in the backing store to hold all

00:25:16,880 --> 00:25:21,200
this array elements and for an empty

00:25:18,860 --> 00:25:23,600
array that we already initialize a

00:25:21,200 --> 00:25:26,269
buffer of 16 elements in v8 to give it

00:25:23,600 --> 00:25:27,860
some room to grow now when a new element

00:25:26,269 --> 00:25:30,200
is added that doesn't fit in the buffer

00:25:27,860 --> 00:25:31,820
anymore we have to create a new buffer

00:25:30,200 --> 00:25:33,340
in the backing store and then copy over

00:25:31,820 --> 00:25:35,240
all the elements from the old array

00:25:33,340 --> 00:25:37,429
behind the scenes and this is an

00:25:35,240 --> 00:25:40,340
expensive operation and this is called

00:25:37,429 --> 00:25:42,230
reallocation now if you start off with

00:25:40,340 --> 00:25:45,919
an empty array for example and then you

00:25:42,230 --> 00:25:47,510
push 9001 items to it one by one then v8

00:25:45,919 --> 00:25:49,899
will reallocate the buffer in the

00:25:47,510 --> 00:25:52,130
backing store for a total of 16 times

00:25:49,899 --> 00:25:55,370
which is not too bad but this number

00:25:52,130 --> 00:25:57,230
grows as the array gets larger so

00:25:55,370 --> 00:25:59,360
especially for large arrays you might

00:25:57,230 --> 00:26:01,340
want to consider this starting from an

00:25:59,360 --> 00:26:02,899
empty array and continuously pushing to

00:26:01,340 --> 00:26:05,269
it ensures we never create any holes

00:26:02,899 --> 00:26:08,149
which is good the array remains packed

00:26:05,269 --> 00:26:10,549
and any future operations on the array

00:26:08,149 --> 00:26:13,610
can be fully optimized but the downside

00:26:10,549 --> 00:26:16,549
of continuously pushing to an array that

00:26:13,610 --> 00:26:18,980
is continuously pushing to an array is

00:26:16,549 --> 00:26:20,809
that behind the scenes engines need to

00:26:18,980 --> 00:26:23,600
reallocate the space as the array grows

00:26:20,809 --> 00:26:25,940
all the time and for a large race maybe

00:26:23,600 --> 00:26:28,760
not 9001 elements may be millions of

00:26:25,940 --> 00:26:32,630
elements this might slow down the actual

00:26:28,760 --> 00:26:34,190
creation of the array so either you

00:26:32,630 --> 00:26:37,130
choose to optimize the array creation

00:26:34,190 --> 00:26:39,260
itself by using new array passing in the

00:26:37,130 --> 00:26:41,539
length if you know it so that it can be

00:26:39,260 --> 00:26:43,639
pre-allocated behind the scenes or you

00:26:41,539 --> 00:26:46,010
choose to optimize the later operations

00:26:43,639 --> 00:26:48,980
on the array in this case it makes sense

00:26:46,010 --> 00:26:50,840
to avoid holy elements kinds and it's a

00:26:48,980 --> 00:26:51,990
trade-off for sure and which of these

00:26:50,840 --> 00:26:53,460
two you pick depends

00:26:51,990 --> 00:26:57,420
on the use case that you have in your

00:26:53,460 --> 00:26:59,010
specific code finally the last piece of

00:26:57,420 --> 00:27:01,260
advice I'd like to give is to write

00:26:59,010 --> 00:27:02,820
modern idiomatic JavaScript without

00:27:01,260 --> 00:27:05,700
worrying about performance too much

00:27:02,820 --> 00:27:07,790
because that way JavaScript engines can

00:27:05,700 --> 00:27:09,700
make it fast for you

00:27:07,790 --> 00:27:17,410
thank you

00:27:09,700 --> 00:27:17,410
[Applause]

00:27:22,720 --> 00:27:24,780

YouTube URL: https://www.youtube.com/watch?v=m9cTaYI95Zc


