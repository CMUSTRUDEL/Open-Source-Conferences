Title: Crafting Stateful Styles with State Machines by David Khourshid | CSSConf BP 2019
Publication date: 2019-10-31
Playlist: CSSConf Budapest 2019
Description: 
	http://cssconfbp.rocks/speakers/david/

User interfaces are highly dynamic and complex, and structuring stylesheets for every possible state of every component can be a challenge. In this talk, we will explore innovative ways of organizing our styles, adding complex interactivity and meaningful transitions, and comprehensively test UIs through a decades-old concept – finite state machines. With ARIA, data-attributes, and CSS variables, state machines can bring a new level of maintainability, testability, and interactivity to your styles.

David Khourshid is a software engineer for Microsoft, a tech author, and speaker. Also a fervent open-source contributor, he is passionate about statecharts and software modeling, reactive animations, innovative user interfaces, and cutting-edge front-end technologies. When not behind a computer keyboard, he’s behind a piano keyboard or traveling.
Captions: 
	00:00:05,210 --> 00:00:11,160
hello everyone I'm really excited to be

00:00:08,340 --> 00:00:13,170
here because the first international

00:00:11,160 --> 00:00:17,520
conference talk that I ever gave was

00:00:13,170 --> 00:00:20,880
actually right here on this stage I came

00:00:17,520 --> 00:00:23,670
in 2016 for I think it was the very

00:00:20,880 --> 00:00:27,510
first CSS company the past and what I

00:00:23,670 --> 00:00:30,480
talked about was actually styling using

00:00:27,510 --> 00:00:32,759
just CSS and HTML but now today we're

00:00:30,480 --> 00:00:34,590
gonna bring CSS HTML in the little bit

00:00:32,759 --> 00:00:36,870
of JavaScript together and see how we

00:00:34,590 --> 00:00:38,790
could craft stateful styles with state

00:00:36,870 --> 00:00:41,640
machines which Mike talked about at the

00:00:38,790 --> 00:00:44,460
very beginning so basically the hello

00:00:41,640 --> 00:00:46,920
world of any design system any component

00:00:44,460 --> 00:00:48,899
library is of course your button so

00:00:46,920 --> 00:00:52,140
imagine we have this button you get this

00:00:48,899 --> 00:00:54,899
design you're happy it looks good but

00:00:52,140 --> 00:00:57,120
there's many different variants like

00:00:54,899 --> 00:00:59,160
Mike talked about that this button can

00:00:57,120 --> 00:01:01,289
be in so we have to consider what

00:00:59,160 --> 00:01:04,140
happens if you hover the button what

00:01:01,289 --> 00:01:05,850
happens if the button is active and what

00:01:04,140 --> 00:01:08,340
happens that the button is disabled so

00:01:05,850 --> 00:01:10,470
you might be thinking we're done here

00:01:08,340 --> 00:01:12,840
but we have to also think about the

00:01:10,470 --> 00:01:15,090
application states that this button can

00:01:12,840 --> 00:01:17,520
be into for example if we're fetching

00:01:15,090 --> 00:01:20,790
data we might want to fade it out if

00:01:17,520 --> 00:01:23,009
it's a success we might want to have it

00:01:20,790 --> 00:01:25,830
be green and say hey we've got your data

00:01:23,009 --> 00:01:30,689
or if it's an error you might want it to

00:01:25,830 --> 00:01:32,970
be a different variants such as red but

00:01:30,689 --> 00:01:35,610
looking at application behavior and

00:01:32,970 --> 00:01:37,890
component Styles this way is very

00:01:35,610 --> 00:01:39,840
limited because we also have to think

00:01:37,890 --> 00:01:41,759
about how we transition between these

00:01:39,840 --> 00:01:43,409
states to illustrate this problem let's

00:01:41,759 --> 00:01:46,079
say we have this fetch button user

00:01:43,409 --> 00:01:47,460
clicks it we're waiting for data and we

00:01:46,079 --> 00:01:49,470
eventually get it that's great

00:01:47,460 --> 00:01:52,200
but what happens if the data takes a

00:01:49,470 --> 00:01:55,409
long time to load then maybe we want to

00:01:52,200 --> 00:01:59,969
show a spinner and eventually we get our

00:01:55,409 --> 00:02:02,610
data but if you're like me then you'll

00:01:59,969 --> 00:02:04,380
get frustrated after a while and start

00:02:02,610 --> 00:02:06,149
clicking this button a few times and

00:02:04,380 --> 00:02:09,090
this is gonna make a lot of unnecessary

00:02:06,149 --> 00:02:12,239
API requests until you finally get your

00:02:09,090 --> 00:02:14,380
data but you're a developer and you're

00:02:12,239 --> 00:02:16,540
smart you think you know what

00:02:14,380 --> 00:02:18,790
I'm going to disable the button and that

00:02:16,540 --> 00:02:20,620
way they could only click it once they

00:02:18,790 --> 00:02:23,140
have to wait for the data and then it

00:02:20,620 --> 00:02:25,600
comes back successfully but guess what

00:02:23,140 --> 00:02:28,030
I'm a developer too I know chrome dev

00:02:25,600 --> 00:02:30,160
tools so I could just go in under Sabol

00:02:28,030 --> 00:02:33,760
that button and make as many requests as

00:02:30,160 --> 00:02:36,100
I want so I ran into this problem a lot

00:02:33,760 --> 00:02:38,500
of times and I wasn't always good at

00:02:36,100 --> 00:02:41,080
JavaScript which is why at the very

00:02:38,500 --> 00:02:44,200
beginning I decided to see how much I

00:02:41,080 --> 00:02:45,820
could do with just HTML and CSS this was

00:02:44,200 --> 00:02:48,430
one of the very first code pens that I

00:02:45,820 --> 00:02:50,650
made using hover States to just go

00:02:48,430 --> 00:02:54,610
between the days and recreate this

00:02:50,650 --> 00:02:58,240
dribble by 2bic studio as well as this

00:02:54,610 --> 00:03:00,850
one now to do to do complex animations

00:02:58,240 --> 00:03:03,010
like this you sort of have to use a few

00:03:00,850 --> 00:03:05,410
hacks if you're not going to use

00:03:03,010 --> 00:03:07,810
JavaScript and so that's exactly what I

00:03:05,410 --> 00:03:10,750
did just like was talked about in the

00:03:07,810 --> 00:03:13,540
very first talk I used check boxes

00:03:10,750 --> 00:03:16,810
because check boxes can represent States

00:03:13,540 --> 00:03:19,540
and radio buttons as well so what I did

00:03:16,810 --> 00:03:21,460
here was if you have a checkbox and it

00:03:19,540 --> 00:03:23,140
sort of lives outside the app you could

00:03:21,460 --> 00:03:25,390
use the squiggly selector a tilde

00:03:23,140 --> 00:03:27,430
selector which is more formally known as

00:03:25,390 --> 00:03:29,650
the adjutant sibling selector but I mean

00:03:27,430 --> 00:03:32,380
no one's gonna remember that and you

00:03:29,650 --> 00:03:34,900
could apply a label inside the app that

00:03:32,380 --> 00:03:39,790
labels are great because they magically

00:03:34,900 --> 00:03:41,260
map the the check box over to the label

00:03:39,790 --> 00:03:43,570
in your app so when you click the label

00:03:41,260 --> 00:03:45,760
it doesn't matter where it is it will

00:03:43,570 --> 00:03:47,290
check that checkbox and so what happens

00:03:45,760 --> 00:03:49,930
is when you click that label which could

00:03:47,290 --> 00:03:51,610
be a button or anything else then that

00:03:49,930 --> 00:03:53,140
check box is going to be checked you

00:03:51,610 --> 00:03:56,020
could use the squiggly selector and

00:03:53,140 --> 00:03:57,730
select that box and make it change

00:03:56,020 --> 00:04:00,190
styles and you could also do this with

00:03:57,730 --> 00:04:01,840
more than one check box which gives you

00:04:00,190 --> 00:04:04,810
sort of that dynamic behavior and

00:04:01,840 --> 00:04:06,430
dynamic styling now like I mentioned you

00:04:04,810 --> 00:04:09,520
could do this with both check boxes and

00:04:06,430 --> 00:04:11,590
radios with one distinction with check

00:04:09,520 --> 00:04:13,630
boxes you could have zero or more check

00:04:11,590 --> 00:04:15,910
boxes checked but while I found myself

00:04:13,630 --> 00:04:18,130
using more and more for radio buttons

00:04:15,910 --> 00:04:20,410
because it enforced the idea that you

00:04:18,130 --> 00:04:23,740
could have only one of them checked at a

00:04:20,410 --> 00:04:25,330
time so I was playing around with this

00:04:23,740 --> 00:04:27,700
and I was playing around with crazier

00:04:25,330 --> 00:04:28,030
things like this CSS only dog animation

00:04:27,700 --> 00:04:30,760
that I

00:04:28,030 --> 00:04:36,370
showed at the very first CSS company the

00:04:30,760 --> 00:04:38,560
pest that I was at and I decided to go

00:04:36,370 --> 00:04:40,720
with my friends sha and we do this

00:04:38,560 --> 00:04:42,610
weekly livestream called the key framers

00:04:40,720 --> 00:04:45,760
in which we bring imaginative user

00:04:42,610 --> 00:04:48,100
interfaces to like using HTML CSS and a

00:04:45,760 --> 00:04:51,220
little bit of JavaScript so what we do

00:04:48,100 --> 00:04:53,860
is we take these really complex

00:04:51,220 --> 00:04:56,410
animations from Tribble and we try to

00:04:53,860 --> 00:04:58,510
recreate them live on the air in under

00:04:56,410 --> 00:05:00,730
two hours but what we found ourselves

00:04:58,510 --> 00:05:02,830
seeing more and more is that a lot of

00:05:00,730 --> 00:05:04,810
these animations are States based and

00:05:02,830 --> 00:05:07,750
not just two states so we can't use a

00:05:04,810 --> 00:05:10,540
checkbox but three states where you

00:05:07,750 --> 00:05:12,460
click and you know you might go back or

00:05:10,540 --> 00:05:18,160
you might have this play button and then

00:05:12,460 --> 00:05:20,919
you go to something else so that's more

00:05:18,160 --> 00:05:23,470
easily illustrated here because we have

00:05:20,919 --> 00:05:25,900
this plateless state at the top which

00:05:23,470 --> 00:05:27,810
shows what state our app is in and you

00:05:25,900 --> 00:05:30,460
could scroll through these albums and

00:05:27,810 --> 00:05:32,500
this is another recreation of a dribble

00:05:30,460 --> 00:05:35,050
and so you could drag back and forth and

00:05:32,500 --> 00:05:38,050
you could see that the state of our

00:05:35,050 --> 00:05:41,229
entire application changes as the user

00:05:38,050 --> 00:05:46,419
interacts with this application so you

00:05:41,229 --> 00:05:48,100
could see those moving side to side so

00:05:46,419 --> 00:05:50,260
this sort of illustrates the problem

00:05:48,100 --> 00:05:51,850
that we have with our currents design

00:05:50,260 --> 00:05:55,300
systems in the current way that we

00:05:51,850 --> 00:05:59,380
develop is that a designer might present

00:05:55,300 --> 00:06:01,960
you a very high fidelity mock-up or you

00:05:59,380 --> 00:06:05,520
know just like a simple prototype but

00:06:01,960 --> 00:06:08,229
that mock-up represents only one of

00:06:05,520 --> 00:06:10,690
potentially many if not hundreds

00:06:08,229 --> 00:06:13,390
thousands of possible states that your

00:06:10,690 --> 00:06:15,160
app of your components can be in and so

00:06:13,390 --> 00:06:17,650
the problem I'm sorry the problem is

00:06:15,160 --> 00:06:20,680
that this Ireson cycle is a bit slow

00:06:17,650 --> 00:06:23,110
because not only does a designer have to

00:06:20,680 --> 00:06:25,870
make all of those changes in all of

00:06:23,110 --> 00:06:27,940
those different screens but if the logic

00:06:25,870 --> 00:06:29,320
changes of the design changes you have

00:06:27,940 --> 00:06:31,630
to go through all of those possible

00:06:29,320 --> 00:06:37,539
changes or all those possible screens

00:06:31,630 --> 00:06:39,729
and apply those changes so what what we

00:06:37,539 --> 00:06:41,229
do currently today and I'm sure most of

00:06:39,729 --> 00:06:41,800
you are guilty of this I know I was

00:06:41,229 --> 00:06:44,229
guilty of the

00:06:41,800 --> 00:06:46,270
for the longest time is we apply classes

00:06:44,229 --> 00:06:48,340
we're like okay if this button is in the

00:06:46,270 --> 00:06:51,550
loading state then we have a class of

00:06:48,340 --> 00:06:53,979
loading of course so we could do the

00:06:51,550 --> 00:06:56,289
same with success but the problem with

00:06:53,979 --> 00:06:59,409
classes we can't enforce that we only

00:06:56,289 --> 00:07:02,080
have one possible value so we might have

00:06:59,409 --> 00:07:04,419
a button that shows loading and success

00:07:02,080 --> 00:07:07,240
and some of you might think like I'm I'm

00:07:04,419 --> 00:07:09,159
smart enough not to do this I have class

00:07:07,240 --> 00:07:11,919
list I could remove the loading class

00:07:09,159 --> 00:07:14,050
and then at the success class by this

00:07:11,919 --> 00:07:17,110
many of you know this does happen in the

00:07:14,050 --> 00:07:20,530
real world and this is something that we

00:07:17,110 --> 00:07:22,780
wants to avoid so is there a better way

00:07:20,530 --> 00:07:25,629
that we could model the state for our

00:07:22,780 --> 00:07:28,659
dynamic UI's and have it in a way that

00:07:25,629 --> 00:07:31,360
we could visualize it and easily see all

00:07:28,659 --> 00:07:34,479
these possible states and be able to

00:07:31,360 --> 00:07:36,969
know how states change from one state to

00:07:34,479 --> 00:07:38,710
another in our app and can we do it in a

00:07:36,969 --> 00:07:41,469
more formal way that designers and

00:07:38,710 --> 00:07:43,090
developers can understand equally so I

00:07:41,469 --> 00:07:46,779
looked at a lot of different prototyping

00:07:43,090 --> 00:07:49,000
apps like origami design envision app

00:07:46,779 --> 00:07:51,069
which you define each of the different

00:07:49,000 --> 00:07:53,650
states in it smoothly transitions

00:07:51,069 --> 00:07:56,319
between each of them prototype does the

00:07:53,650 --> 00:07:58,150
same thing where it's sort of like magic

00:07:56,319 --> 00:08:00,400
move for designers because you could

00:07:58,150 --> 00:08:03,669
define shapes and it will magically

00:08:00,400 --> 00:08:05,469
transform then scale them translate them

00:08:03,669 --> 00:08:07,630
into the shape that they're supposed to

00:08:05,469 --> 00:08:10,779
be and you could add triggers and then

00:08:07,630 --> 00:08:13,300
there's more formal user flow tools such

00:08:10,779 --> 00:08:15,279
as overflowed IO in which you could

00:08:13,300 --> 00:08:18,789
design each of these screens and add

00:08:15,279 --> 00:08:20,650
these custom triggers so what I realized

00:08:18,789 --> 00:08:23,469
was common between all of these tools

00:08:20,650 --> 00:08:25,539
and more is that user flows are these

00:08:23,469 --> 00:08:27,759
transitions between these user interface

00:08:25,539 --> 00:08:30,430
States and these transitions could be

00:08:27,759 --> 00:08:33,130
caused based on either user events or

00:08:30,430 --> 00:08:36,820
other external events such as a timer an

00:08:33,130 --> 00:08:39,279
API requests coming in etc and so this

00:08:36,820 --> 00:08:41,529
brings me to the topic of finite state

00:08:39,279 --> 00:08:43,120
machines and state charts which I mean

00:08:41,529 --> 00:08:44,980
if you know me long enough you know that

00:08:43,120 --> 00:08:46,990
this is what I talked about you could

00:08:44,980 --> 00:08:49,390
type state machine on Twitter and I will

00:08:46,990 --> 00:08:51,250
find you and I will respond to you it's

00:08:49,390 --> 00:08:53,440
just my thing one of my favorite

00:08:51,250 --> 00:08:55,420
definitions of the states is

00:08:53,440 --> 00:08:58,240
actually in the Aria guidelines in the

00:08:55,420 --> 00:09:00,010
w3.org website where a States is a

00:08:58,240 --> 00:09:03,430
dynamic property that expresses the

00:09:00,010 --> 00:09:05,980
characteristics of an object in a

00:09:03,430 --> 00:09:08,380
certain point of time so this point of

00:09:05,980 --> 00:09:11,470
time can be in response to a user action

00:09:08,380 --> 00:09:13,660
or other automated processes or external

00:09:11,470 --> 00:09:16,240
events that come in and so this is a

00:09:13,660 --> 00:09:19,120
distinction between properties such as

00:09:16,240 --> 00:09:23,320
like an anchor might have an H ref tag

00:09:19,120 --> 00:09:24,850
or an href attribute or a button can

00:09:23,320 --> 00:09:27,280
have a variant where you know that

00:09:24,850 --> 00:09:30,160
that's not going to change but state is

00:09:27,280 --> 00:09:33,070
different state describes at one point

00:09:30,160 --> 00:09:36,100
in time this represents my component and

00:09:33,070 --> 00:09:38,200
that could change at any time and area

00:09:36,100 --> 00:09:41,110
also has all of these builds and

00:09:38,200 --> 00:09:45,310
attributes for states that they describe

00:09:41,110 --> 00:09:48,550
a stateful attributes which describe you

00:09:45,310 --> 00:09:52,150
know certain finite states of components

00:09:48,550 --> 00:09:57,090
such as invalid valid disabled currents

00:09:52,150 --> 00:10:00,670
and yeah so finite state machines are

00:09:57,090 --> 00:10:02,530
pretty much the same concept where it

00:10:00,670 --> 00:10:04,210
has five parts I'm gonna review finite

00:10:02,530 --> 00:10:06,190
state machines real briefly there's a

00:10:04,210 --> 00:10:08,350
ton of resources on this though but the

00:10:06,190 --> 00:10:10,750
finite state machine is one that has an

00:10:08,350 --> 00:10:12,760
initial state it has a finite number of

00:10:10,750 --> 00:10:15,130
states which means we could only be in

00:10:12,760 --> 00:10:16,930
one of those states at a time it has a

00:10:15,130 --> 00:10:18,970
finite number of vents and these are the

00:10:16,930 --> 00:10:21,310
signals that cause transitions between

00:10:18,970 --> 00:10:23,740
those states it has a mapping of

00:10:21,310 --> 00:10:26,410
transitions that go between those states

00:10:23,740 --> 00:10:28,270
so for example for an idle and the user

00:10:26,410 --> 00:10:30,130
makes a fetch request by pressing a

00:10:28,270 --> 00:10:32,440
button now we're in the pending States

00:10:30,130 --> 00:10:34,840
and it also has a finite number of final

00:10:32,440 --> 00:10:38,430
states which represent the app being

00:10:34,840 --> 00:10:41,320
done there being no more left to do so

00:10:38,430 --> 00:10:43,000
the beauty of these finite state

00:10:41,320 --> 00:10:45,550
machines is number one they could be

00:10:43,000 --> 00:10:49,750
visualized such as this state diagram

00:10:45,550 --> 00:10:52,150
and number two they outline just all the

00:10:49,750 --> 00:10:54,490
possible transitions and what's not

00:10:52,150 --> 00:10:57,940
possible as well so if we do a search

00:10:54,490 --> 00:11:00,280
action on the searching state we realize

00:10:57,940 --> 00:11:02,830
that there is no transition outgoing

00:11:00,280 --> 00:11:04,810
from the searching State so that search

00:11:02,830 --> 00:11:06,700
should have no effect and this is

00:11:04,810 --> 00:11:07,440
exactly what we wants to occur so that

00:11:06,700 --> 00:11:09,510
the user isn't

00:11:07,440 --> 00:11:15,960
keep making all of these different API

00:11:09,510 --> 00:11:17,610
requests so to do this in CSS in HTML

00:11:15,960 --> 00:11:20,460
and to do it in a scalable way I

00:11:17,610 --> 00:11:23,160
employed the use of data attributes so

00:11:20,460 --> 00:11:25,680
whereas we can't use Aria attributes for

00:11:23,160 --> 00:11:29,220
everything we could use data attributes

00:11:25,680 --> 00:11:31,200
to describe a more colorful and more

00:11:29,220 --> 00:11:34,530
varied way of describing all of the

00:11:31,200 --> 00:11:37,500
possible states of our application or of

00:11:34,530 --> 00:11:39,330
the individual components as well the

00:11:37,500 --> 00:11:42,990
other attributes are something that are

00:11:39,330 --> 00:11:45,600
very underused but this goes back to the

00:11:42,990 --> 00:11:47,880
beginning of HTML and I highly encourage

00:11:45,600 --> 00:11:51,750
you to use it because they end up being

00:11:47,880 --> 00:11:53,250
a lot simpler than class names to use so

00:11:51,750 --> 00:11:55,470
for example we could have a data state

00:11:53,250 --> 00:11:58,410
equals loading and we could target that

00:11:55,470 --> 00:12:01,170
using an attribute selector in CSS data

00:11:58,410 --> 00:12:03,570
state equals loading and so in

00:12:01,170 --> 00:12:08,010
JavaScript it actually makes it really

00:12:03,570 --> 00:12:10,830
easy to to change the the data attribute

00:12:08,010 --> 00:12:12,600
of whatever you're working with so we

00:12:10,830 --> 00:12:14,370
could have a data state and we could say

00:12:12,600 --> 00:12:17,730
you know it's loading your success and

00:12:14,370 --> 00:12:20,730
then we could change that or we could

00:12:17,730 --> 00:12:23,220
delete it completely and then it's gone

00:12:20,730 --> 00:12:25,350
and so changing it is just setting that

00:12:23,220 --> 00:12:27,420
attribute and deleting it is just

00:12:25,350 --> 00:12:30,000
deleting so there's no weird api's like

00:12:27,420 --> 00:12:32,160
classless dot add class list that has

00:12:30,000 --> 00:12:34,890
class lists that remove that you have to

00:12:32,160 --> 00:12:37,500
worry about it's just JavaScript so

00:12:34,890 --> 00:12:40,440
these data attributes represents each

00:12:37,500 --> 00:12:42,390
one of these finite States in your

00:12:40,440 --> 00:12:44,400
components or your application for

00:12:42,390 --> 00:12:46,020
example this button we could have data

00:12:44,400 --> 00:12:46,620
state of idle which means nothing

00:12:46,020 --> 00:12:48,780
happened yet

00:12:46,620 --> 00:12:51,570
we could have loading we could have a

00:12:48,780 --> 00:12:55,110
success and we could have a failure so

00:12:51,570 --> 00:12:56,910
you could also imagine that you you can

00:12:55,110 --> 00:12:58,200
name these states whatever you want and

00:12:56,910 --> 00:13:02,280
that's the beauty of these data

00:12:58,200 --> 00:13:04,620
attributes so how do we implement data

00:13:02,280 --> 00:13:07,260
attributes with these finite States

00:13:04,620 --> 00:13:09,300
traditionally finite state machines

00:13:07,260 --> 00:13:11,400
especially in other languages can be

00:13:09,300 --> 00:13:14,250
done using switch case statements where

00:13:11,400 --> 00:13:16,290
you would first figure out what state

00:13:14,250 --> 00:13:17,820
you're in and you would switch on that

00:13:16,290 --> 00:13:20,010
so for example for in the searching

00:13:17,820 --> 00:13:20,540
state we go to the key statement for

00:13:20,010 --> 00:13:22,730
search

00:13:20,540 --> 00:13:25,160
and then we switch on what events

00:13:22,730 --> 00:13:26,630
occurred so if you're used to Redux on

00:13:25,160 --> 00:13:30,200
them getting into JavaScript a little

00:13:26,630 --> 00:13:32,990
bit here by Redux or ng rx or any of

00:13:30,200 --> 00:13:35,240
those reducers then typically you would

00:13:32,990 --> 00:13:37,250
do action first but now we're doing it

00:13:35,240 --> 00:13:39,710
the other way around we're looking at

00:13:37,250 --> 00:13:42,470
what state were on first and then we're

00:13:39,710 --> 00:13:43,910
going to the event I call it embeds

00:13:42,470 --> 00:13:47,240
instead of action because that's a more

00:13:43,910 --> 00:13:49,100
accurate term but we check what events

00:13:47,240 --> 00:13:51,770
just happened and what state we should

00:13:49,100 --> 00:13:55,250
go to next based on that event such as

00:13:51,770 --> 00:13:56,570
success and of course if that is not

00:13:55,250 --> 00:13:59,210
handled by the switch case statement

00:13:56,570 --> 00:14:01,790
then you just default to the same state

00:13:59,210 --> 00:14:03,800
now personally I find switch case

00:14:01,790 --> 00:14:06,530
statements a little bit verbose so I

00:14:03,800 --> 00:14:08,180
like to do object mapping instead and so

00:14:06,530 --> 00:14:10,340
this is just you it looks like a big

00:14:08,180 --> 00:14:13,790
JSON object and it's essentially the

00:14:10,340 --> 00:14:17,270
same idea where you have a state such as

00:14:13,790 --> 00:14:19,370
searching you look at the on property to

00:14:17,270 --> 00:14:21,950
see which events just occurred and if

00:14:19,370 --> 00:14:24,350
there's a mapping between the events and

00:14:21,950 --> 00:14:26,090
the next state that should happen and if

00:14:24,350 --> 00:14:29,630
there isn't you just default to the

00:14:26,090 --> 00:14:31,730
current state so I also wrote a library

00:14:29,630 --> 00:14:34,880
for this called XE which you do not have

00:14:31,730 --> 00:14:36,350
to use it doesn't apply directly to what

00:14:34,880 --> 00:14:38,660
I'm talking about because you could do

00:14:36,350 --> 00:14:41,030
this today without any JavaScript

00:14:38,660 --> 00:14:42,410
library but I just felt like mentioning

00:14:41,030 --> 00:14:45,020
it because it does have a lot of these

00:14:42,410 --> 00:14:48,740
things built in to use x8 you would just

00:14:45,020 --> 00:14:51,440
have a machine function which takes in

00:14:48,740 --> 00:14:54,460
that object configuration and it gives

00:14:51,440 --> 00:14:56,870
you a few nice things such as automatic

00:14:54,460 --> 00:14:58,730
transitions so you don't need to code

00:14:56,870 --> 00:15:01,010
that transition function yourself and

00:14:58,730 --> 00:15:04,760
you could say if I'm in the idle State

00:15:01,010 --> 00:15:06,590
and these search events happens then we

00:15:04,760 --> 00:15:10,420
should go to the searching State that's

00:15:06,590 --> 00:15:14,270
actually wrong I'll correct that but

00:15:10,420 --> 00:15:16,580
yeah so here's an example over here have

00:15:14,270 --> 00:15:19,490
you ever wondered how how they implement

00:15:16,580 --> 00:15:22,460
sort of a drag-and-drop type of thing I

00:15:19,490 --> 00:15:24,560
mean it looks pretty simple but then you

00:15:22,460 --> 00:15:26,600
get around to trying to implement it and

00:15:24,560 --> 00:15:28,880
seeing okay which event listeners do I

00:15:26,600 --> 00:15:31,100
need to listen to what do I have to do

00:15:28,880 --> 00:15:32,460
when do I stop listening to these event

00:15:31,100 --> 00:15:34,290
listener

00:15:32,460 --> 00:15:36,450
and it just gets really confusing so you

00:15:34,290 --> 00:15:38,640
probably reach for a library but it's

00:15:36,450 --> 00:15:40,710
actually a lot simpler than it seems if

00:15:38,640 --> 00:15:43,860
you think about drag-and-drop as two

00:15:40,710 --> 00:15:46,290
states either idle or dragging anything

00:15:43,860 --> 00:15:48,630
about four properties the X and y which

00:15:46,290 --> 00:15:51,300
represents the position of the object

00:15:48,630 --> 00:15:54,150
and the dxdy which represents how far

00:15:51,300 --> 00:15:56,790
you move the object then it becomes

00:15:54,150 --> 00:15:59,160
pretty easy to visualize this as two

00:15:56,790 --> 00:16:01,470
states idle and then when you pick

00:15:59,160 --> 00:16:03,570
something up like this that's like

00:16:01,470 --> 00:16:06,270
you're dragging state's own I'm changing

00:16:03,570 --> 00:16:08,430
the dxdy properties and then I would

00:16:06,270 --> 00:16:10,860
move it somewhere and then once I stop

00:16:08,430 --> 00:16:14,100
now I'm in the idle State again

00:16:10,860 --> 00:16:17,160
and so we could visualize this here once

00:16:14,100 --> 00:16:20,310
I start dragging you see those dxdy

00:16:17,160 --> 00:16:23,580
properties moving and then I drop it and

00:16:20,310 --> 00:16:26,880
then now I change those to x and y and

00:16:23,580 --> 00:16:29,580
then I could do it again and so you can

00:16:26,880 --> 00:16:33,030
see it's very easy to visualize these

00:16:29,580 --> 00:16:35,490
two states within the context of your

00:16:33,030 --> 00:16:37,340
application in your animations and this

00:16:35,490 --> 00:16:46,220
on this playing by the way using those

00:16:37,340 --> 00:16:48,390
data attributes as well so we could also

00:16:46,220 --> 00:16:50,970
if you want to do more advanced

00:16:48,390 --> 00:16:53,940
animations based on what state you're on

00:16:50,970 --> 00:16:55,700
and what state you came from because the

00:16:53,940 --> 00:16:58,140
different actions that could happen

00:16:55,700 --> 00:17:01,500
depend on which state that you may have

00:16:58,140 --> 00:17:04,350
come from and so that's why using a data

00:17:01,500 --> 00:17:07,560
pre state attribute stands for previous

00:17:04,350 --> 00:17:09,000
state can be useful as well because you

00:17:07,560 --> 00:17:13,050
know we could have two different things

00:17:09,000 --> 00:17:15,330
for example if we're coming to a loading

00:17:13,050 --> 00:17:16,620
state from an idle state that might do

00:17:15,330 --> 00:17:18,630
one thing but if we're coming from an

00:17:16,620 --> 00:17:21,209
error state then maybe we want to show

00:17:18,630 --> 00:17:23,760
an error gone animation and then we're

00:17:21,209 --> 00:17:25,709
back to loading and then so in our same

00:17:23,760 --> 00:17:28,200
function where we apply those data

00:17:25,709 --> 00:17:29,760
attributes we would just set the

00:17:28,200 --> 00:17:32,070
previous state to whatever the state was

00:17:29,760 --> 00:17:34,860
before and we could target those right

00:17:32,070 --> 00:17:39,840
in our CSS just by combining those

00:17:34,860 --> 00:17:43,770
selectors like so and so this if it ever

00:17:39,840 --> 00:17:45,660
loads is an example of that so we have

00:17:43,770 --> 00:17:48,240
different behaviors based on whether

00:17:45,660 --> 00:17:50,850
going up for example and then we have a

00:17:48,240 --> 00:17:52,550
difference animation over here and then

00:17:50,850 --> 00:17:55,320
going down it does something different

00:17:52,550 --> 00:17:58,710
so we do want to keep track of which

00:17:55,320 --> 00:18:01,820
state that we came from and so again

00:17:58,710 --> 00:18:09,420
this is using data attributes to change

00:18:01,820 --> 00:18:11,040
which state were in so so as I started

00:18:09,420 --> 00:18:13,080
playing around more with this idea of

00:18:11,040 --> 00:18:15,180
using finite state machines for

00:18:13,080 --> 00:18:17,340
animations I saw more and more complex

00:18:15,180 --> 00:18:19,170
animations on Tribble that I really want

00:18:17,340 --> 00:18:22,320
to recreate such as this one by Cal

00:18:19,170 --> 00:18:25,110
shear which lets you extend your weekend

00:18:22,320 --> 00:18:26,390
which I really hope I was I want to do

00:18:25,110 --> 00:18:29,580
this weekend

00:18:26,390 --> 00:18:31,380
so I broke this animation down and I

00:18:29,580 --> 00:18:33,990
start to see all of the different states

00:18:31,380 --> 00:18:37,470
of it so at the beginning when the user

00:18:33,990 --> 00:18:39,690
starts dragging their mouse then we

00:18:37,470 --> 00:18:42,360
start searching or sorry we start

00:18:39,690 --> 00:18:44,010
selecting each of the days and then once

00:18:42,360 --> 00:18:47,250
the user let's go now we're in the

00:18:44,010 --> 00:18:48,330
selected state so now a mouse movement

00:18:47,250 --> 00:18:50,460
is going to mean something different

00:18:48,330 --> 00:18:52,230
because then we're in the dragging state

00:18:50,460 --> 00:18:55,680
and we could move those states around

00:18:52,230 --> 00:18:57,960
and then we're in the disposed dates so

00:18:55,680 --> 00:18:59,790
once we start grabbing now the mouse

00:18:57,960 --> 00:19:02,640
movement means something different it

00:18:59,790 --> 00:19:04,980
means we're extending a day so the exact

00:19:02,640 --> 00:19:06,750
same events can mean something different

00:19:04,980 --> 00:19:08,700
depending on what state you're on and I

00:19:06,750 --> 00:19:13,080
think that that's a really important

00:19:08,700 --> 00:19:16,170
point so just to show you over here if I

00:19:13,080 --> 00:19:18,210
start dragging and selecting remember

00:19:16,170 --> 00:19:20,400
mouse movement means one thing so I

00:19:18,210 --> 00:19:23,130
could start dragging over here and if I

00:19:20,400 --> 00:19:25,050
don't go to the trash can then it just

00:19:23,130 --> 00:19:27,540
goes back there and back to that state

00:19:25,050 --> 00:19:30,300
and so I could drag it all the way here

00:19:27,540 --> 00:19:32,520
disposes and then now I'm in the

00:19:30,300 --> 00:19:34,080
grabbing state which means that if I

00:19:32,520 --> 00:19:36,270
move my mouse and I start dragging

00:19:34,080 --> 00:19:37,830
outside it's not gonna have that initial

00:19:36,270 --> 00:19:40,080
behavior of showing the selection

00:19:37,830 --> 00:19:44,250
rectangle because I'm not in that state

00:19:40,080 --> 00:19:46,380
where that behavior is defined so that's

00:19:44,250 --> 00:19:49,410
an important point when dealing with

00:19:46,380 --> 00:19:53,820
application state is not just mapping an

00:19:49,410 --> 00:19:56,700
event to an action or to side effects

00:19:53,820 --> 00:19:57,120
but instead mapping it to what state

00:19:56,700 --> 00:19:59,070
you're in

00:19:57,120 --> 00:20:01,830
and what events just have

00:19:59,070 --> 00:20:03,600
mapping those two together so using the

00:20:01,830 --> 00:20:05,460
state machine which I created using x8

00:20:03,600 --> 00:20:07,200
but of course you don't need to you

00:20:05,460 --> 00:20:09,419
could also automatically generate

00:20:07,200 --> 00:20:12,480
visualizations such as this which

00:20:09,419 --> 00:20:14,820
explained the whole process of the logic

00:20:12,480 --> 00:20:16,590
of you know how the app is supposed to

00:20:14,820 --> 00:20:21,210
behave once you're dragging and dropping

00:20:16,590 --> 00:20:24,870
certain things so does this scale that's

00:20:21,210 --> 00:20:27,299
a big problem which which we have to

00:20:24,870 --> 00:20:29,759
talk about because of course once you

00:20:27,299 --> 00:20:32,009
have so many different combinations like

00:20:29,759 --> 00:20:33,960
Mike was talking about then we could

00:20:32,009 --> 00:20:36,149
have an exponentially large number of

00:20:33,960 --> 00:20:40,590
states and we sort of need to manage

00:20:36,149 --> 00:20:42,360
that thankfully a solution in 1987 by a

00:20:40,590 --> 00:20:44,909
computer scientist by the name of David

00:20:42,360 --> 00:20:46,980
Harrell sort of solved that for us it

00:20:44,909 --> 00:20:49,019
says 1997 there but it was actually a

00:20:46,980 --> 00:20:52,080
decade earlier so these are really

00:20:49,019 --> 00:20:54,149
really old ideas state charts extend the

00:20:52,080 --> 00:20:56,190
idea of state machines by adding things

00:20:54,149 --> 00:20:58,559
such as actions whether you're entering

00:20:56,190 --> 00:21:01,289
state exiting a state or performing a

00:20:58,559 --> 00:21:03,059
transition between states it has guards

00:21:01,289 --> 00:21:06,000
so you can make sure that transitions

00:21:03,059 --> 00:21:08,700
only occur when a condition based on the

00:21:06,000 --> 00:21:10,559
state is met there's also the idea of

00:21:08,700 --> 00:21:12,690
hierarchy so you could have nested

00:21:10,559 --> 00:21:16,139
states you can think of those as sub

00:21:12,690 --> 00:21:18,179
routes or if you're in one state and you

00:21:16,139 --> 00:21:21,330
could be in a sub state of that state

00:21:18,179 --> 00:21:24,000
also orthogonality which represents two

00:21:21,330 --> 00:21:26,370
different ideas of states which don't

00:21:24,000 --> 00:21:27,929
really have too much to do to each with

00:21:26,370 --> 00:21:29,070
each other but you want to represent

00:21:27,929 --> 00:21:31,230
them both equally

00:21:29,070 --> 00:21:33,720
and the idea of history States as well

00:21:31,230 --> 00:21:36,899
so hierarchical states can really help

00:21:33,720 --> 00:21:39,000
simplify how we combine States and make

00:21:36,899 --> 00:21:40,980
the logic easier so we see in the

00:21:39,000 --> 00:21:44,100
success and failure state the search

00:21:40,980 --> 00:21:45,480
events can occur from both of them so

00:21:44,100 --> 00:21:47,730
instead we could group those two

00:21:45,480 --> 00:21:49,409
together and make it so that whether

00:21:47,730 --> 00:21:51,600
we're in the success or failure state

00:21:49,409 --> 00:21:54,000
that search events can take us back to

00:21:51,600 --> 00:21:56,340
the searching State so in X state that's

00:21:54,000 --> 00:21:58,590
done just by nesting those states within

00:21:56,340 --> 00:22:00,750
the search State over there and then we

00:21:58,590 --> 00:22:04,259
could see that when we perform the

00:22:00,750 --> 00:22:06,480
search event on any of those states then

00:22:04,259 --> 00:22:11,279
we go back to the searching State so it

00:22:06,480 --> 00:22:12,610
really simplifies the design of these of

00:22:11,279 --> 00:22:15,220
the logic

00:22:12,610 --> 00:22:18,010
now to represent these nested states and

00:22:15,220 --> 00:22:20,289
hierarchical states in CSS we have to

00:22:18,010 --> 00:22:23,140
get a little bit into the weeds of data

00:22:20,289 --> 00:22:25,570
attribute selectors so of course we have

00:22:23,140 --> 00:22:28,210
the existence selector which just checks

00:22:25,570 --> 00:22:30,580
if it exists we have the data attribute

00:22:28,210 --> 00:22:34,330
selector of if it's exactly equal to if

00:22:30,580 --> 00:22:37,059
it contains anywhere at all if it starts

00:22:34,330 --> 00:22:39,159
with something such as idle if it

00:22:37,059 --> 00:22:43,210
contains or if it ends with something

00:22:39,159 --> 00:22:46,750
such as error or this is the one we want

00:22:43,210 --> 00:22:50,049
if our data state or our data attribute

00:22:46,750 --> 00:22:52,720
contains the string passed in such as

00:22:50,049 --> 00:22:54,610
idle error but that string is basically

00:22:52,720 --> 00:22:57,100
a word that's separated by whitespace

00:22:54,610 --> 00:22:59,139
and this makes it acts just like a class

00:22:57,100 --> 00:23:00,580
now this isn't the same as saying that

00:22:59,139 --> 00:23:02,529
we're in two states at the same time

00:23:00,580 --> 00:23:05,470
we're really in this idle dot error

00:23:02,529 --> 00:23:07,600
state but we want that idle just to let

00:23:05,470 --> 00:23:09,700
CSS know that we are in that parent

00:23:07,600 --> 00:23:12,490
state and so we could use data

00:23:09,700 --> 00:23:16,149
attributes as like even further like

00:23:12,490 --> 00:23:18,070
data show and data hide and use that to

00:23:16,149 --> 00:23:20,320
show which elements are active based on

00:23:18,070 --> 00:23:21,639
which state we're on and so that's just

00:23:20,320 --> 00:23:22,929
with a little bit of JavaScript you

00:23:21,639 --> 00:23:27,039
don't need to read this code right now

00:23:22,929 --> 00:23:29,159
but just know that by by just figuring

00:23:27,039 --> 00:23:32,559
out what state were in we could show

00:23:29,159 --> 00:23:34,659
elements based on what state we're on

00:23:32,559 --> 00:23:36,399
and so you could play around with the

00:23:34,659 --> 00:23:38,590
idea you don't have to use data show

00:23:36,399 --> 00:23:40,840
where dala hide you could just use

00:23:38,590 --> 00:23:42,519
whatever you want to use but the idea is

00:23:40,840 --> 00:23:45,309
that you're not directly toggling

00:23:42,519 --> 00:23:48,460
classes are talking attributes on each

00:23:45,309 --> 00:23:51,639
of these states so for the final example

00:23:48,460 --> 00:23:54,220
here's this password form and you can

00:23:51,639 --> 00:23:56,649
see that there's this idol and Idol dot

00:23:54,220 --> 00:24:00,039
normal sub state that we're in because

00:23:56,649 --> 00:24:03,010
if I enter a password incorrectly and it

00:24:00,039 --> 00:24:05,289
validates now we go to isle dot error

00:24:03,010 --> 00:24:08,409
and eventually it goes back to idle dot

00:24:05,289 --> 00:24:12,100
normal because we want those two states

00:24:08,409 --> 00:24:14,049
to be similar but also we want them to

00:24:12,100 --> 00:24:16,330
be distinct enough so that we could

00:24:14,049 --> 00:24:18,070
group its similar characteristics and

00:24:16,330 --> 00:24:21,159
its unique characteristics such as

00:24:18,070 --> 00:24:23,679
showing the red outline when when the

00:24:21,159 --> 00:24:26,400
password is incorrect then we eventually

00:24:23,679 --> 00:24:28,660
have a success date as well

00:24:26,400 --> 00:24:30,100
so the main idea that I want to bring

00:24:28,660 --> 00:24:32,590
home to you is that you should think in

00:24:30,100 --> 00:24:34,750
states and events and not just events

00:24:32,590 --> 00:24:37,240
and the reason for doing this is because

00:24:34,750 --> 00:24:39,190
once you define your application in your

00:24:37,240 --> 00:24:42,250
components as a finite state machine or

00:24:39,190 --> 00:24:44,230
a state chart and you model it in a very

00:24:42,250 --> 00:24:47,080
explicit way you could do some really

00:24:44,230 --> 00:24:49,929
cool things such as visualize these and

00:24:47,080 --> 00:24:52,630
so just to show you that animation I

00:24:49,929 --> 00:24:55,510
just showed you can be visualized right

00:24:52,630 --> 00:24:57,160
over here so I copied and pasted of the

00:24:55,510 --> 00:24:59,500
machine used to define and we could see

00:24:57,160 --> 00:25:01,750
that we're in the Isle States but we're

00:24:59,500 --> 00:25:03,940
also in the normal state as well and so

00:25:01,750 --> 00:25:06,159
when we change now we go to the

00:25:03,940 --> 00:25:08,440
validating state in if it's an error

00:25:06,159 --> 00:25:11,159
then it's invalid and then we go back to

00:25:08,440 --> 00:25:14,789
the normal States just like that

00:25:11,159 --> 00:25:18,190
now so there's a lot of powerful

00:25:14,789 --> 00:25:20,470
applications of this such as analysis

00:25:18,190 --> 00:25:23,919
automatic testing and other things that

00:25:20,470 --> 00:25:26,169
I talked about but there's also other

00:25:23,919 --> 00:25:28,929
tools that could do this for you sketch

00:25:26,169 --> 00:25:31,210
systems is a very useful tool for

00:25:28,929 --> 00:25:34,030
prototyping your applications and your

00:25:31,210 --> 00:25:36,280
designs using these AI same ideas of

00:25:34,030 --> 00:25:37,929
finite state machines and state charts

00:25:36,280 --> 00:25:40,090
because you could write it in this

00:25:37,929 --> 00:25:43,030
pseudo syntax and be able to play around

00:25:40,090 --> 00:25:45,070
with it in a little prototype editor at

00:25:43,030 --> 00:25:47,200
the bottom so I highly encourage you to

00:25:45,070 --> 00:25:49,270
check that out there's a lot of

00:25:47,200 --> 00:25:51,940
advantages to using state charts NASA

00:25:49,270 --> 00:25:54,730
use them that their selves with the Mars

00:25:51,940 --> 00:25:57,750
rover which I mean honestly if you have

00:25:54,730 --> 00:26:01,419
one shot at going to production with a

00:25:57,750 --> 00:26:02,830
multi hundred billion dollar thing you

00:26:01,419 --> 00:26:05,860
don't want to it up

00:26:02,830 --> 00:26:08,530
so I mean imagine doing this in

00:26:05,860 --> 00:26:11,409
JavaScript it would it would go nowhere

00:26:08,530 --> 00:26:13,870
so there's a lot of advantages to this

00:26:11,409 --> 00:26:15,820
they had visualized modeling precise

00:26:13,870 --> 00:26:17,679
diagrams they were able to use those

00:26:15,820 --> 00:26:20,260
state charts to generate code

00:26:17,679 --> 00:26:22,750
automatically and also to make sure that

00:26:20,260 --> 00:26:25,450
every single possible thing that could

00:26:22,750 --> 00:26:28,030
happen to this Mars rover was tested and

00:26:25,450 --> 00:26:30,159
was covered and also when requirements

00:26:28,030 --> 00:26:32,470
changed they didn't have to go into code

00:26:30,159 --> 00:26:34,299
to figure out what needs to change but

00:26:32,470 --> 00:26:38,470
instead they could just go to the

00:26:34,299 --> 00:26:40,150
diagram and see okay this is now this so

00:26:38,470 --> 00:26:43,000
now we have to have an arrow

00:26:40,150 --> 00:26:45,280
here and this goes here and so it's a

00:26:43,000 --> 00:26:47,470
lot easier to to deal with these

00:26:45,280 --> 00:26:50,230
automatic late-breaking changes with

00:26:47,470 --> 00:26:52,000
visual diagrams instead of code now of

00:26:50,230 --> 00:26:54,190
course there are disadvantages because

00:26:52,000 --> 00:26:56,230
as you could tell there is a huge

00:26:54,190 --> 00:26:58,570
learning curve and modeling these day

00:26:56,230 --> 00:27:01,000
charts requires planning ahead you can't

00:26:58,570 --> 00:27:04,450
just put your head down in code you need

00:27:01,000 --> 00:27:06,310
to actually stop and plan it and draw

00:27:04,450 --> 00:27:08,470
those boxes and draw those arrows and

00:27:06,310 --> 00:27:11,260
give it to your developers and designers

00:27:08,470 --> 00:27:13,300
and say is this a correct behavior in

00:27:11,260 --> 00:27:14,770
our application and of course you can't

00:27:13,300 --> 00:27:16,660
just use finite state machines for

00:27:14,770 --> 00:27:18,820
everything but they could be a very good

00:27:16,660 --> 00:27:20,800
abstraction for the overall logic of

00:27:18,820 --> 00:27:22,900
your applications there are also

00:27:20,800 --> 00:27:25,450
complexity trade-offs where you might

00:27:22,900 --> 00:27:27,730
say I don't need state charts because my

00:27:25,450 --> 00:27:29,230
application is so simple and that's when

00:27:27,730 --> 00:27:32,350
you might use finite state machines

00:27:29,230 --> 00:27:33,730
whereas normal code which I call

00:27:32,350 --> 00:27:35,860
bottom-up code because we're putting

00:27:33,730 --> 00:27:38,830
everything in the event listeners

00:27:35,860 --> 00:27:41,770
instead of instead of structuring it in

00:27:38,830 --> 00:27:43,840
a nice modeled way it increases linearly

00:27:41,770 --> 00:27:46,600
but as we saw finite state machines can

00:27:43,840 --> 00:27:48,190
increase exponentially state charts

00:27:46,600 --> 00:27:50,920
however might seem more complex at first

00:27:48,190 --> 00:27:53,710
but they manage complexity at scale and

00:27:50,920 --> 00:27:56,890
this is why I love using them because no

00:27:53,710 --> 00:27:58,990
trivial app ever stays trivial once more

00:27:56,890 --> 00:28:00,790
features come in it becomes so much more

00:27:58,990 --> 00:28:03,430
complex and you want a good way to

00:28:00,790 --> 00:28:05,080
manage that complexity there's a lot of

00:28:03,430 --> 00:28:06,970
resources online for learning about

00:28:05,080 --> 00:28:08,860
state machines and state charts which I

00:28:06,970 --> 00:28:11,530
encourage you to check out there's a

00:28:08,860 --> 00:28:13,360
community on spectrum Piazza de chartes

00:28:11,530 --> 00:28:15,640
and there's the world of state charts

00:28:13,360 --> 00:28:18,280
which just explains in the very easy to

00:28:15,640 --> 00:28:20,110
read way how to get started with stage

00:28:18,280 --> 00:28:20,650
arts and what kinds of problems they

00:28:20,110 --> 00:28:22,720
solve

00:28:20,650 --> 00:28:24,730
so in general I want to make your code

00:28:22,720 --> 00:28:27,010
do more than just applying the

00:28:24,730 --> 00:28:30,150
application logic I want you to be able

00:28:27,010 --> 00:28:32,260
to visualize automatically test analyze

00:28:30,150 --> 00:28:34,600
simulate your applications in your

00:28:32,260 --> 00:28:37,060
components and be able to visualize all

00:28:34,600 --> 00:28:39,700
the possible states and transitions

00:28:37,060 --> 00:28:42,220
between your components and applications

00:28:39,700 --> 00:28:49,529
thank you very much CSS contest

00:28:42,220 --> 00:28:49,529

YouTube URL: https://www.youtube.com/watch?v=0cqeGeC98MA


