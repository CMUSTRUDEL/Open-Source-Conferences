Title: Testing in production: Ideas, experiences, limits, roadblocks by Jorge Marin | JSConf Budapest 2019
Publication date: 2019-10-17
Playlist: JSConf Budapest 2019
Description: 
	https://2019.jsconfbp.com/speakers/jorge_marin

Are you afraid of testing in production? Do you test in production? Do you use real data? By definition testing in production is hard. This talk puts together my experience testing in production a large scale system that affects millions of users. Experience, ideas, limits, roadblocks, tips and more.

Jorge Marín is an engineer passionate about robotics, automation, statistics and mountains. With a degree on Telecommunications Engineering he tried to help drones to navigate indoors where GPS position is not available or inaccurate. Got dragged to `the cloud` afterwards and has been working since then automating the hell of anything he touches. Currently he is taking over Dyson's testing strategy for cloud services.
Captions: 
	00:00:00,050 --> 00:00:11,000
[Applause]

00:00:06,080 --> 00:00:15,269
hello your réguel keeper knock I'll try

00:00:11,000 --> 00:00:17,430
sir good morning my name is Jorge and

00:00:15,269 --> 00:00:20,850
today I'm going to talk about testing in

00:00:17,430 --> 00:00:22,590
production with JavaScript welcome two

00:00:20,850 --> 00:00:25,380
years conf Budapest and thank you for

00:00:22,590 --> 00:00:27,689
coming to my talk hidden slide doesn't

00:00:25,380 --> 00:00:32,210
matter I promise the talk it's not gonna

00:00:27,689 --> 00:00:34,980
be too heavy and let's get started so

00:00:32,210 --> 00:00:37,290
quick about me my name is Jorge I'm an

00:00:34,980 --> 00:00:40,770
engineer I'm from Spain and I'm

00:00:37,290 --> 00:00:42,719
currently working in Bristol started

00:00:40,770 --> 00:00:45,960
working on autonomous indoor navigation

00:00:42,719 --> 00:00:48,510
new abs and money area baekho's fronts

00:00:45,960 --> 00:00:50,850
and then got back to the cloud space for

00:00:48,510 --> 00:00:52,770
years working at I start back called

00:00:50,850 --> 00:00:54,899
bitNami that just got acquired by BM

00:00:52,770 --> 00:00:58,680
words so kudos to my team and now

00:00:54,899 --> 00:01:01,559
currently working at Dyson so I always

00:00:58,680 --> 00:01:04,979
like to store the talks with a quick

00:01:01,559 --> 00:01:07,830
poll to know how the audience is doing

00:01:04,979 --> 00:01:11,580
on on this topic I want to know how many

00:01:07,830 --> 00:01:13,380
of you know what javascript is okay

00:01:11,580 --> 00:01:17,280
thank you you know raising the hands

00:01:13,380 --> 00:01:19,710
over there are here for the city the

00:01:17,280 --> 00:01:22,729
food the party and just a bit of

00:01:19,710 --> 00:01:26,490
JavaScript okay that's fine

00:01:22,729 --> 00:01:29,759
know what testing is we're raising the

00:01:26,490 --> 00:01:31,170
bar know about the testing pyramid or

00:01:29,759 --> 00:01:33,930
any other way of classifying the

00:01:31,170 --> 00:01:36,960
different testing levels yeah most of

00:01:33,930 --> 00:01:39,990
you thank you who has a production

00:01:36,960 --> 00:01:44,130
environment again every one of you

00:01:39,990 --> 00:01:48,869
amazing who is afraid of testing in

00:01:44,130 --> 00:01:52,409
production who is not afraid of testing

00:01:48,869 --> 00:01:55,200
in production good give this is coming

00:01:52,409 --> 00:01:59,159
so are you testing your services in

00:01:55,200 --> 00:02:01,829
production not so many but there are

00:01:59,159 --> 00:02:05,670
quite a few that's great the final

00:02:01,829 --> 00:02:07,470
preferred spaces two tops yes spaces

00:02:05,670 --> 00:02:10,560
right

00:02:07,470 --> 00:02:13,280
so this this talk about this talk is

00:02:10,560 --> 00:02:16,980
about I'm gonna try to answer some

00:02:13,280 --> 00:02:20,610
frequently asked questions about testing

00:02:16,980 --> 00:02:22,680
and your production workloads not going

00:02:20,610 --> 00:02:25,620
to be too technical and not going too

00:02:22,680 --> 00:02:27,330
deep inside any JavaScript code and it's

00:02:25,620 --> 00:02:29,280
all based on the experience I gained

00:02:27,330 --> 00:02:31,140
working I dance at Dyson I've been

00:02:29,280 --> 00:02:35,160
working at Dyson for almost two years

00:02:31,140 --> 00:02:36,330
now and Anna has been great and we have

00:02:35,160 --> 00:02:39,930
learned a lot about testing in

00:02:36,330 --> 00:02:42,960
production so this is a quick summary of

00:02:39,930 --> 00:02:44,430
where I'm going I'm going to answer why

00:02:42,960 --> 00:02:48,210
do you need testing testing production

00:02:44,430 --> 00:02:51,000
was the right testing level how can you

00:02:48,210 --> 00:02:53,820
escape or noise no js' work help with

00:02:51,000 --> 00:02:55,380
this how to avoid disrupting the real

00:02:53,820 --> 00:02:58,500
users because if you're testing in

00:02:55,380 --> 00:03:00,420
production you're gonna be part of your

00:02:58,500 --> 00:03:04,200
users and you're going to be using

00:03:00,420 --> 00:03:05,880
production systems how to keep how to

00:03:04,200 --> 00:03:09,030
keep your tests out of the statistics

00:03:05,880 --> 00:03:12,270
reports and out of metrics so when you

00:03:09,030 --> 00:03:16,910
report your to your manager to hire the

00:03:12,270 --> 00:03:20,310
business didn't get you results and then

00:03:16,910 --> 00:03:22,680
why you should clean up and what happens

00:03:20,310 --> 00:03:27,480
if you don't because that happened to us

00:03:22,680 --> 00:03:29,760
so yeah let's dive in a bit why do you

00:03:27,480 --> 00:03:31,860
need testing in production well that's a

00:03:29,760 --> 00:03:34,920
good question by how most of you can

00:03:31,860 --> 00:03:36,989
answer that but really what do I mean

00:03:34,920 --> 00:03:39,330
why what do I mean by testing in

00:03:36,989 --> 00:03:41,910
production when you deploy your

00:03:39,330 --> 00:03:43,860
application it could be an application a

00:03:41,910 --> 00:03:46,290
service could be a lambda whatever thing

00:03:43,860 --> 00:03:49,260
you deploy to production and has so the

00:03:46,290 --> 00:03:53,400
public has access to is you need to

00:03:49,260 --> 00:03:56,760
guarantee it's continues to work over

00:03:53,400 --> 00:03:59,280
the days and over the hours and it's not

00:03:56,760 --> 00:04:01,530
just it passed the unit test it passed

00:03:59,280 --> 00:04:03,900
the service level test or whatever and

00:04:01,530 --> 00:04:05,370
then I deploy and I don't care about my

00:04:03,900 --> 00:04:07,050
service the service is running in

00:04:05,370 --> 00:04:10,320
production and if something happens to

00:04:07,050 --> 00:04:14,910
it you want to get notified not at the

00:04:10,320 --> 00:04:17,280
user but by some automated system so the

00:04:14,910 --> 00:04:20,190
idea about this is to have some kind of

00:04:17,280 --> 00:04:21,410
testing tool that runs on a scheduled

00:04:20,190 --> 00:04:24,750
basis

00:04:21,410 --> 00:04:27,479
so it's testing your service like it was

00:04:24,750 --> 00:04:29,759
a real user and if something happens so

00:04:27,479 --> 00:04:32,400
the tests fail it means that a real user

00:04:29,759 --> 00:04:33,840
wasn't able to do one of the actions you

00:04:32,400 --> 00:04:36,030
have defined for your production

00:04:33,840 --> 00:04:38,699
services and and then you get a

00:04:36,030 --> 00:04:42,810
notification so let's let's dive into it

00:04:38,699 --> 00:04:44,940
a bit why really do you need a testing

00:04:42,810 --> 00:04:47,910
you need testing in production so here's

00:04:44,940 --> 00:04:49,620
a quick sample it might seem dumb but it

00:04:47,910 --> 00:04:51,199
can happen so imagine you have a lambda

00:04:49,620 --> 00:04:55,130
function that we change the current date

00:04:51,199 --> 00:04:57,930
right and it doesn't cut it for the year

00:04:55,130 --> 00:05:02,120
2038 problem which is when you are

00:04:57,930 --> 00:05:05,520
storing your date in a sign it 32-bits

00:05:02,120 --> 00:05:08,520
variable you've run out of space to

00:05:05,520 --> 00:05:13,490
store the date and then you overflow

00:05:08,520 --> 00:05:16,680
right on the 16th of january 2038

00:05:13,490 --> 00:05:19,139
so yeah you do your deployment you write

00:05:16,680 --> 00:05:21,389
unit tests for it issue which on a date

00:05:19,139 --> 00:05:22,979
if you query for the date again you

00:05:21,389 --> 00:05:25,830
should return a different number should

00:05:22,979 --> 00:05:26,729
return a different date yeah do you know

00:05:25,830 --> 00:05:28,800
unit tests are fine

00:05:26,729 --> 00:05:32,639
do you deploy it and after a handful of

00:05:28,800 --> 00:05:35,550
years is stuff failing and it's because

00:05:32,639 --> 00:05:40,110
a it has dynamic input/output it depends

00:05:35,550 --> 00:05:42,240
on the current time on how the users are

00:05:40,110 --> 00:05:44,970
interacting with the service or what the

00:05:42,240 --> 00:05:48,330
service is returning dynamically but

00:05:44,970 --> 00:05:50,340
going to a more real situation imagine

00:05:48,330 --> 00:05:52,560
one of your stateful services so it's a

00:05:50,340 --> 00:05:55,889
service that store some state on your

00:05:52,560 --> 00:05:58,590
users or in your database or on the

00:05:55,889 --> 00:06:01,050
state of your system then suddenly by a

00:05:58,590 --> 00:06:02,820
bug or whatever becomes inconsistent and

00:06:01,050 --> 00:06:06,750
then starts failing for all the

00:06:02,820 --> 00:06:10,860
customers then when you have is a horde

00:06:06,750 --> 00:06:14,090
of customers chasing you angry customers

00:06:10,860 --> 00:06:17,090
saying this is not working I pay for it

00:06:14,090 --> 00:06:19,560
but you don't want that you want

00:06:17,090 --> 00:06:22,259
something that it's not going to get

00:06:19,560 --> 00:06:25,020
angry at you and it's a robot an

00:06:22,259 --> 00:06:27,300
automated process that's gonna behave

00:06:25,020 --> 00:06:29,760
like a user it's going to test your

00:06:27,300 --> 00:06:31,919
things your services in production and

00:06:29,760 --> 00:06:34,050
tell you when something bad happens so

00:06:31,919 --> 00:06:39,479
you don't get the feedback

00:06:34,050 --> 00:06:41,729
from the users and so if you compare

00:06:39,479 --> 00:06:43,319
these two situations so imagine you are

00:06:41,729 --> 00:06:44,849
in the first situation where you don't

00:06:43,319 --> 00:06:47,250
have an automated test system in

00:06:44,849 --> 00:06:49,349
production and then something bad

00:06:47,250 --> 00:06:51,440
happens and all your customers come to

00:06:49,349 --> 00:06:55,830
you saying this is no working and

00:06:51,440 --> 00:06:58,289
claiming back the money it's gonna take

00:06:55,830 --> 00:07:00,240
some time for the users to report to you

00:06:58,289 --> 00:07:04,800
that I know is happening and they have

00:07:00,240 --> 00:07:07,020
to go to your service helpdesk or log an

00:07:04,800 --> 00:07:09,210
issue or log a ticket or send you an

00:07:07,020 --> 00:07:12,090
email or whatever so it's slow you don't

00:07:09,210 --> 00:07:15,719
know your service is failing until you

00:07:12,090 --> 00:07:17,520
get the feedback from the users but if

00:07:15,719 --> 00:07:19,830
you have an automated system that runs

00:07:17,520 --> 00:07:22,620
every minute every 10 minute every 20

00:07:19,830 --> 00:07:24,090
minutes every 30 minute you can

00:07:22,620 --> 00:07:27,810
notifications about your system not

00:07:24,090 --> 00:07:30,659
working like this and also if you're in

00:07:27,810 --> 00:07:33,509
the first situation you're losing money

00:07:30,659 --> 00:07:35,400
because then the more time you last in

00:07:33,509 --> 00:07:37,740
detecting that your systems are not

00:07:35,400 --> 00:07:40,380
working that's money that you are losing

00:07:37,740 --> 00:07:43,800
and and also you're paying the support

00:07:40,380 --> 00:07:45,900
the supporting a lot for dealing with

00:07:43,800 --> 00:07:49,650
those things while you could have catch

00:07:45,900 --> 00:07:52,800
the Europe beforehand and also the final

00:07:49,650 --> 00:07:55,259
the final comparison is about the

00:07:52,800 --> 00:07:57,330
company reputation so if you have all

00:07:55,259 --> 00:07:58,830
the users coming back at you and saying

00:07:57,330 --> 00:08:00,840
this is not working this is a high pay

00:07:58,830 --> 00:08:03,449
for this blah blah blah your company

00:08:00,840 --> 00:08:06,449
reputation is over the over the floor

00:08:03,449 --> 00:08:10,500
and then if you have an automated system

00:08:06,449 --> 00:08:12,150
that notifies you by the way of an issue

00:08:10,500 --> 00:08:16,289
in your production systems

00:08:12,150 --> 00:08:18,810
nobody needs to notice it and then you

00:08:16,289 --> 00:08:21,930
fix it quickly and then customers are

00:08:18,810 --> 00:08:25,860
happy so that's the comparison and why

00:08:21,930 --> 00:08:28,409
do you need testing in production so

00:08:25,860 --> 00:08:29,639
what really is the right level of

00:08:28,409 --> 00:08:32,849
testing you want to perform in

00:08:29,639 --> 00:08:35,399
production because you don't want to

00:08:32,849 --> 00:08:38,789
mess with real data but you're using

00:08:35,399 --> 00:08:41,399
real systems yeah so this is a the

00:08:38,789 --> 00:08:47,140
testing pyramid well one of the many

00:08:41,399 --> 00:08:49,630
testing permits are but let me focus

00:08:47,140 --> 00:08:52,090
let me focus on this one because it's

00:08:49,630 --> 00:08:54,880
one of the simplest that I found it

00:08:52,090 --> 00:08:56,320
comes from Superman article in from

00:08:54,880 --> 00:09:00,310
ultimate from their website ultimate

00:08:56,320 --> 00:09:02,770
home automation Panda and at the bottom

00:09:00,310 --> 00:09:05,110
you have unit test then integration test

00:09:02,770 --> 00:09:06,550
or service level test however you want

00:09:05,110 --> 00:09:10,240
to call them and then the end-to-end

00:09:06,550 --> 00:09:12,250
test so what happens when you have a

00:09:10,240 --> 00:09:14,260
unit test you want a unit test before

00:09:12,250 --> 00:09:16,000
you deploy your application so you test

00:09:14,260 --> 00:09:17,980
a single functions of your application

00:09:16,000 --> 00:09:19,960
or your service and then you deploy your

00:09:17,980 --> 00:09:21,790
application because you are confident

00:09:19,960 --> 00:09:25,240
that your application is working fine

00:09:21,790 --> 00:09:28,480
because you have unit tested it but then

00:09:25,240 --> 00:09:30,310
when you deploy you perform some

00:09:28,480 --> 00:09:32,620
integration tests or service level tests

00:09:30,310 --> 00:09:35,800
so you're focusing on a single service

00:09:32,620 --> 00:09:37,870
the single service is the minimum unit

00:09:35,800 --> 00:09:41,020
after deployment for us the engineers

00:09:37,870 --> 00:09:43,780
you deploy several services and so this

00:09:41,020 --> 00:09:46,210
end-to-end test so this integration test

00:09:43,780 --> 00:09:49,270
or survey level test for those single

00:09:46,210 --> 00:09:52,150
units from the engineering side but what

00:09:49,270 --> 00:09:54,760
the user sees is like the whole system

00:09:52,150 --> 00:09:57,600
and the user has user intense user

00:09:54,760 --> 00:10:00,460
actions or also called user journeys

00:09:57,600 --> 00:10:03,250
they are testing things across all the

00:10:00,460 --> 00:10:06,460
system across all your services so

00:10:03,250 --> 00:10:07,750
that's the kind of level I'm referring

00:10:06,460 --> 00:10:09,970
when I'm talking about testing in

00:10:07,750 --> 00:10:11,920
production you want to become a real

00:10:09,970 --> 00:10:14,560
user you want to be in the skin of a

00:10:11,920 --> 00:10:16,480
user and try all the possible actions a

00:10:14,560 --> 00:10:21,420
user can do to make sure your system

00:10:16,480 --> 00:10:21,420
still works as expected

00:10:22,320 --> 00:10:29,230
how can JavaScript or Nadia's help with

00:10:25,510 --> 00:10:33,040
that well this is where my example comes

00:10:29,230 --> 00:10:36,430
into into show so at the moment I'm

00:10:33,040 --> 00:10:38,260
working at Tyson and we have more than 1

00:10:36,430 --> 00:10:41,110
million connected machine performing

00:10:38,260 --> 00:10:43,030
actions against the cloud and calling

00:10:41,110 --> 00:10:46,150
our services calling our Web API or

00:10:43,030 --> 00:10:49,450
lambdas blah blah blah and and also uses

00:10:46,150 --> 00:10:51,400
all around the globe doing actions and

00:10:49,450 --> 00:10:54,460
performing actions just like renaming

00:10:51,400 --> 00:11:00,220
your robot from Dyson 360 i2 mega ii

00:10:54,460 --> 00:11:01,000
9000 whatever and then what happens is

00:11:00,220 --> 00:11:04,870
that

00:11:01,000 --> 00:11:07,180
it's a big system it's a form of several

00:11:04,870 --> 00:11:09,310
moving parts and I want to make sure

00:11:07,180 --> 00:11:11,500
that users can change the name of the

00:11:09,310 --> 00:11:15,819
robot and don't get an error right so I

00:11:11,500 --> 00:11:18,879
need a tool that's fast that's easy to

00:11:15,819 --> 00:11:21,819
run in production so when I want to

00:11:18,879 --> 00:11:23,860
verify that all the user actions all the

00:11:21,819 --> 00:11:26,860
user journeys are working in production

00:11:23,860 --> 00:11:28,540
I run the tool like this docker

00:11:26,860 --> 00:11:31,050
container whatever it's not difficult to

00:11:28,540 --> 00:11:33,670
deploy I want it to be extendable also

00:11:31,050 --> 00:11:37,000
so when I write new services I write new

00:11:33,670 --> 00:11:39,550
web api's whatever I can add new

00:11:37,000 --> 00:11:44,319
libraries or new files and having those

00:11:39,550 --> 00:11:46,689
testing situations and also I would like

00:11:44,319 --> 00:11:49,810
to have the ability to write behavior

00:11:46,689 --> 00:11:53,350
driven development tests if you want to

00:11:49,810 --> 00:11:56,949
call them like that so really what I

00:11:53,350 --> 00:11:59,529
want to find what they a scenario for

00:11:56,949 --> 00:12:01,360
real user is what real users gonna how I

00:11:59,529 --> 00:12:05,589
really use is going to interact with my

00:12:01,360 --> 00:12:08,829
systems and and then try to reproduce

00:12:05,589 --> 00:12:11,500
that automated simulating those paid to

00:12:08,829 --> 00:12:13,449
a user simulating everything but no

00:12:11,500 --> 00:12:17,920
emulates in the cloud emulating my

00:12:13,449 --> 00:12:22,059
services the solution that we come to a

00:12:17,920 --> 00:12:26,019
place was a tool written in JavaScript

00:12:22,059 --> 00:12:28,839
using nodejs and the main libraries that

00:12:26,019 --> 00:12:31,420
we are using are koo kumba a Jas and the

00:12:28,839 --> 00:12:35,259
request library was also a bit of the

00:12:31,420 --> 00:12:38,350
user library and basically what we try

00:12:35,259 --> 00:12:41,230
to define a lot of singular steps a lot

00:12:38,350 --> 00:12:44,019
of single actions and then using koo

00:12:41,230 --> 00:12:46,569
kumba areas and then putting all those

00:12:44,019 --> 00:12:51,009
actions together into a group to form an

00:12:46,569 --> 00:12:53,019
x scenario you're gonna see now and yeah

00:12:51,009 --> 00:12:55,959
then using the request library just to

00:12:53,019 --> 00:12:58,629
make requests over the Internet HTTP or

00:12:55,959 --> 00:13:00,279
HTTPS requests and the SL library to

00:12:58,629 --> 00:13:03,870
assert that the values we are getting

00:13:00,279 --> 00:13:08,259
back are they the ones that we expect

00:13:03,870 --> 00:13:10,839
this is an example of of the cucumber of

00:13:08,259 --> 00:13:13,689
a scenario written in cucumber yes or

00:13:10,839 --> 00:13:14,440
what our next scenario really I want to

00:13:13,689 --> 00:13:16,930
test

00:13:14,440 --> 00:13:19,389
that given an existing user with this

00:13:16,930 --> 00:13:21,879
configuration and the user locks in and

00:13:19,389 --> 00:13:24,310
the user changes the robot name to

00:13:21,879 --> 00:13:26,589
whatever then the one the robot name has

00:13:24,310 --> 00:13:29,170
changed I want to test that that's a

00:13:26,589 --> 00:13:29,740
it's an user action I'm not testing one

00:13:29,170 --> 00:13:31,209
service

00:13:29,740 --> 00:13:33,759
I'm not test I'm not testing one

00:13:31,209 --> 00:13:36,939
function I'm testing the use of uranium

00:13:33,759 --> 00:13:41,199
testing the user intent and that's what

00:13:36,939 --> 00:13:43,420
we want we want to try and do what the

00:13:41,199 --> 00:13:47,800
users will be doing in in production

00:13:43,420 --> 00:13:50,589
with our systems this is a very simple

00:13:47,800 --> 00:13:53,139
schema of how it works

00:13:50,589 --> 00:13:55,480
we have the users the users at the

00:13:53,139 --> 00:13:58,660
moment interact with a smartphone

00:13:55,480 --> 00:14:01,029
application that smartphone application

00:13:58,660 --> 00:14:03,250
sends commands to the cloud and then the

00:14:01,029 --> 00:14:05,170
cloud communicates the comments back to

00:14:03,250 --> 00:14:08,439
the to the robot to the cleaning robot

00:14:05,170 --> 00:14:14,379
for example and I was testing to and

00:14:08,439 --> 00:14:16,600
Mason tested to a ki ATT has built well

00:14:14,379 --> 00:14:18,819
users because there are no real users

00:14:16,600 --> 00:14:21,399
have a world a smartphone app and

00:14:18,819 --> 00:14:24,329
that's making the calls to the cloud and

00:14:21,399 --> 00:14:27,880
back and it's also emulating the robot

00:14:24,329 --> 00:14:30,339
so we are simulating all the points in

00:14:27,880 --> 00:14:32,290
production except the cloud our services

00:14:30,339 --> 00:14:41,069
in production does we want to behave

00:14:32,290 --> 00:14:43,300
like users but if you test in production

00:14:41,069 --> 00:14:45,279
basically you are stressing your

00:14:43,300 --> 00:14:47,350
production systems you are becoming a

00:14:45,279 --> 00:14:49,389
user and if you run your testing

00:14:47,350 --> 00:14:52,660
production very fast or you do a lot of

00:14:49,389 --> 00:14:55,209
actions you become like a million users

00:14:52,660 --> 00:14:58,240
talking to your services at a given time

00:14:55,209 --> 00:15:01,509
and you don't want that so you need to

00:14:58,240 --> 00:15:03,100
keep a balance between what you are

00:15:01,509 --> 00:15:07,750
testing in production and what you want

00:15:03,100 --> 00:15:09,819
to assert you don't want it's good that

00:15:07,750 --> 00:15:11,800
you are very close to the to the user

00:15:09,819 --> 00:15:15,220
and to the real actions but you need to

00:15:11,800 --> 00:15:18,879
to balance it right so for it as an

00:15:15,220 --> 00:15:20,580
example of this when we were writing the

00:15:18,879 --> 00:15:23,640
test and

00:15:20,580 --> 00:15:26,910
we started doing tests like every five

00:15:23,640 --> 00:15:28,190
minutes I guess if I recall and what

00:15:26,910 --> 00:15:31,380
happened is that we started getting

00:15:28,190 --> 00:15:33,269
getting slowdowns on our web api because

00:15:31,380 --> 00:15:35,070
we were quite in the way API so every

00:15:33,269 --> 00:15:37,170
five minutes doing a lot of tests and

00:15:35,070 --> 00:15:39,510
then it was a slowing down our

00:15:37,170 --> 00:15:41,519
productions services and we don't want

00:15:39,510 --> 00:15:43,470
we don't want that for the users and

00:15:41,519 --> 00:15:46,740
also we experienced it

00:15:43,470 --> 00:15:49,500
some DynamoDB throttling so database

00:15:46,740 --> 00:15:52,440
throttling as I was testing was doing

00:15:49,500 --> 00:15:55,890
cost to the API very fast and and today

00:15:52,440 --> 00:15:58,709
and read and write to DynamoDB or the

00:15:55,890 --> 00:16:01,920
database then we got throttle and that

00:15:58,709 --> 00:16:04,050
was affecting users so you need to be

00:16:01,920 --> 00:16:07,920
careful about that you need to a space a

00:16:04,050 --> 00:16:09,630
bit your end-to-end test so the more

00:16:07,920 --> 00:16:11,010
things you run them the faster you're

00:16:09,630 --> 00:16:15,329
going to realize that you have an issue

00:16:11,010 --> 00:16:17,399
if there's an issue but then you get

00:16:15,329 --> 00:16:19,620
more noise because you get more noise

00:16:17,399 --> 00:16:22,279
unless you get more noise on the matrix

00:16:19,620 --> 00:16:23,519
you get motion more noise everywhere and

00:16:22,279 --> 00:16:26,160
slowdowns

00:16:23,519 --> 00:16:29,329
it slows down your production system and

00:16:26,160 --> 00:16:32,970
so you want to keep a balance about that

00:16:29,329 --> 00:16:37,680
and and just this is another another

00:16:32,970 --> 00:16:42,060
quick bit when for this testing tool we

00:16:37,680 --> 00:16:43,890
are simulating these users so we have

00:16:42,060 --> 00:16:44,399
code in JavaScript how a user will

00:16:43,890 --> 00:16:47,490
behave

00:16:44,399 --> 00:16:50,190
what API schooled the user hit and what

00:16:47,490 --> 00:16:52,140
does the user want to do like for

00:16:50,190 --> 00:16:55,470
example changing the name of the robot

00:16:52,140 --> 00:17:02,579
and yeah as I said we want to test a

00:16:55,470 --> 00:17:04,949
real user behavior okay so basically

00:17:02,579 --> 00:17:08,459
yeah again when you run your test in

00:17:04,949 --> 00:17:13,640
production you are becoming another user

00:17:08,459 --> 00:17:19,110
you are becoming part of the system and

00:17:13,640 --> 00:17:20,429
equal skew your matrix for example the

00:17:19,110 --> 00:17:22,620
number of users are interacting with

00:17:20,429 --> 00:17:25,350
your system you want to report to your

00:17:22,620 --> 00:17:27,900
manager or to the business how many

00:17:25,350 --> 00:17:29,850
users are using your your production

00:17:27,900 --> 00:17:32,790
services but if you have this end-to-end

00:17:29,850 --> 00:17:34,370
test running in production then that's

00:17:32,790 --> 00:17:37,309
giving your result also

00:17:34,370 --> 00:17:41,029
if you want to know how many calls to an

00:17:37,309 --> 00:17:42,830
API and also the error count so for

00:17:41,029 --> 00:17:46,730
example you are very interested on how

00:17:42,830 --> 00:17:48,890
many times your API switch on in a 500

00:17:46,730 --> 00:17:50,809
or switch on in a 400 if you have the

00:17:48,890 --> 00:17:53,390
end-to-end test that's gonna skew your

00:17:50,809 --> 00:17:56,029
whistle so you need a way of keeping

00:17:53,390 --> 00:17:57,650
those tests that you know about them

00:17:56,029 --> 00:18:00,830
that you are generating them keeping

00:17:57,650 --> 00:18:02,630
them out of the statistics and you could

00:18:00,830 --> 00:18:04,730
also get mixed locks so if you have a

00:18:02,630 --> 00:18:09,140
login utility that's put that puts all

00:18:04,730 --> 00:18:13,610
the locks together like plank or

00:18:09,140 --> 00:18:15,919
elasticsearch how do you discern which

00:18:13,610 --> 00:18:18,590
locks were part of the end-to-end tests

00:18:15,919 --> 00:18:22,580
or which locks were power of real users

00:18:18,590 --> 00:18:26,539
doing real actions so yeah you need to

00:18:22,580 --> 00:18:28,730
be careful with that how can we how can

00:18:26,539 --> 00:18:31,640
we keep our test out of the stylistics

00:18:28,730 --> 00:18:35,299
we could use a correlation ID so with

00:18:31,640 --> 00:18:37,490
every request we would send as part of

00:18:35,299 --> 00:18:40,010
the request a correlation ID or we will

00:18:37,490 --> 00:18:42,169
generate a correlation ID that's going

00:18:40,010 --> 00:18:45,110
to be pass between the different

00:18:42,169 --> 00:18:47,059
services internally so every service if

00:18:45,110 --> 00:18:50,899
they see the correlation idea starting

00:18:47,059 --> 00:18:53,809
by end-to-end ffffff' they gonna know

00:18:50,899 --> 00:18:56,330
it's part of the test they shouldn't

00:18:53,809 --> 00:18:58,340
behave differently but at least not log

00:18:56,330 --> 00:19:00,950
in matrix for example or log in matrix

00:18:58,340 --> 00:19:03,799
to a different name space we could also

00:19:00,950 --> 00:19:08,169
change the user alien in case of web api

00:19:03,799 --> 00:19:12,649
s-- by yeah specifying instead of being

00:19:08,169 --> 00:19:14,750
mozilla gecko whatever you have your

00:19:12,649 --> 00:19:17,360
application and twin test and the

00:19:14,750 --> 00:19:22,250
version and finally you can also add new

00:19:17,360 --> 00:19:24,500
HTTP headers that nobody is gonna freak

00:19:22,250 --> 00:19:27,320
about that you just put test to version

00:19:24,500 --> 00:19:31,909
one point one point two or whatever and

00:19:27,320 --> 00:19:33,770
then you treat them differently you not

00:19:31,909 --> 00:19:35,570
treat them differently you don't lock

00:19:33,770 --> 00:19:40,940
the metrics if you see the header coming

00:19:35,570 --> 00:19:45,080
in into your production systems right so

00:19:40,940 --> 00:19:46,789
after everything this this was a quick

00:19:45,080 --> 00:19:48,350
introduction to how to run end-to-end

00:19:46,789 --> 00:19:50,870
test and production

00:19:48,350 --> 00:19:53,059
you now have you end-to-end test running

00:19:50,870 --> 00:19:55,480
in production they are executing every

00:19:53,059 --> 00:19:59,950
15 minutes every 20 minutes 30 minutes

00:19:55,480 --> 00:20:02,450
and they are passing that's great but

00:19:59,950 --> 00:20:05,960
what about all the fake that they have

00:20:02,450 --> 00:20:08,510
generated so they they were built well

00:20:05,960 --> 00:20:10,820
users or built on machines built or

00:20:08,510 --> 00:20:14,210
smartphone apps that were creating new

00:20:10,820 --> 00:20:18,400
users that were creating new cleans new

00:20:14,210 --> 00:20:21,710
new data to our production systems and

00:20:18,400 --> 00:20:25,880
that's fake data with them really wanted

00:20:21,710 --> 00:20:28,460
into in the system and it's making some

00:20:25,880 --> 00:20:33,740
it's it's it's going to cause a problem

00:20:28,460 --> 00:20:38,929
in the long run so for example we were

00:20:33,740 --> 00:20:42,500
login when you register a machine into

00:20:38,929 --> 00:20:46,160
the cloud into the services we store a

00:20:42,500 --> 00:20:49,130
row in the database saying this machine

00:20:46,160 --> 00:20:53,000
is now just now six and belongs to this

00:20:49,130 --> 00:20:54,380
user so as we were executing the

00:20:53,000 --> 00:20:56,179
end-to-end test in production we were

00:20:54,380 --> 00:20:58,790
creating new machines with new user

00:20:56,179 --> 00:20:58,970
random machines random users bla bla bla

00:20:58,790 --> 00:21:03,080
bla

00:20:58,970 --> 00:21:04,760
we were filling the database and what

00:21:03,080 --> 00:21:06,200
happened was that our services in

00:21:04,760 --> 00:21:12,290
production were querying the database

00:21:06,200 --> 00:21:14,510
and and getting all those users and the

00:21:12,290 --> 00:21:19,010
services were expecting to find between

00:21:14,510 --> 00:21:21,170
one and ninety and twist different

00:21:19,010 --> 00:21:23,150
entries in production but we were

00:21:21,170 --> 00:21:25,250
generating a lot of entries every single

00:21:23,150 --> 00:21:28,100
day so the entries ended up like being

00:21:25,250 --> 00:21:29,660
in the order of thousand entries what

00:21:28,100 --> 00:21:32,600
happened that our service was not

00:21:29,660 --> 00:21:34,550
prepared to do any pagination and then

00:21:32,600 --> 00:21:36,710
it started failing for the customers

00:21:34,550 --> 00:21:39,170
because we couldn't find their entries

00:21:36,710 --> 00:21:41,480
because they were in their page six or

00:21:39,170 --> 00:21:43,040
page seven because all the tests all the

00:21:41,480 --> 00:21:45,740
testing production were generating more

00:21:43,040 --> 00:21:50,720
data and filling up the database under

00:21:45,740 --> 00:21:54,470
sub problems so yeah you need to clean

00:21:50,720 --> 00:21:57,140
that data it's very important and you

00:21:54,470 --> 00:22:01,370
want to do that automatically if

00:21:57,140 --> 00:22:05,520
possible after every single test run

00:22:01,370 --> 00:22:07,620
so it it helps to to keep your

00:22:05,520 --> 00:22:09,840
environment clean it helps to start the

00:22:07,620 --> 00:22:13,590
test the next test to start them from a

00:22:09,840 --> 00:22:17,660
clean state avoid cluttering your your

00:22:13,590 --> 00:22:20,550
databases or cluttering your services or

00:22:17,660 --> 00:22:26,130
exhausting any of the limited resources

00:22:20,550 --> 00:22:28,050
like IDs or yeah any any any other

00:22:26,130 --> 00:22:31,020
limited resources you you could have in

00:22:28,050 --> 00:22:34,320
your production system and and also

00:22:31,020 --> 00:22:36,570
avoid as an example I just put about

00:22:34,320 --> 00:22:43,020
it's making weird hm more difficult to

00:22:36,570 --> 00:22:45,990
query to retrieve and to search so as a

00:22:43,020 --> 00:22:48,330
recap testing in production is good and

00:22:45,990 --> 00:22:51,840
necessary please do it if you are not

00:22:48,330 --> 00:22:53,760
doing it you need to think as a real use

00:22:51,840 --> 00:22:56,640
it to put yourself in in the skin of a

00:22:53,760 --> 00:22:58,680
user and act like a user so that you

00:22:56,640 --> 00:23:01,620
have really testing your your system

00:22:58,680 --> 00:23:04,200
then using the framework cucumber yes

00:23:01,620 --> 00:23:07,650
it's a good start and we found that it

00:23:04,200 --> 00:23:09,120
work for us and it's it's amazing you

00:23:07,650 --> 00:23:12,480
need to think also about your system

00:23:09,120 --> 00:23:14,970
capacity so if your system cannot handle

00:23:12,480 --> 00:23:16,950
a thousand requests per second then you

00:23:14,970 --> 00:23:19,920
shouldn't be doing that many end to end

00:23:16,950 --> 00:23:24,900
test space them a bit every half an hour

00:23:19,920 --> 00:23:27,990
every 45 minutes whatever fits you you

00:23:24,900 --> 00:23:30,420
also want to mark your test intents to

00:23:27,990 --> 00:23:32,880
differentiate them from the from the

00:23:30,420 --> 00:23:35,790
production load from the real users with

00:23:32,880 --> 00:23:39,030
a correlation ID or with the HTTP header

00:23:35,790 --> 00:23:41,220
or any other any other solution and

00:23:39,030 --> 00:23:44,430
after that you want to clean your test

00:23:41,220 --> 00:23:47,310
data and we set every connections or

00:23:44,430 --> 00:23:52,380
every any status you might have changed

00:23:47,310 --> 00:23:56,750
after after this test and the so

00:23:52,380 --> 00:23:58,890
basically thank you for for listening

00:23:56,750 --> 00:24:01,080
one more thing I would like to take a

00:23:58,890 --> 00:24:04,350
bit boring job I will smile for the gram

00:24:01,080 --> 00:24:11,130
selfie and then ever now because I have

00:24:04,350 --> 00:24:13,610
plenty of spare time so now smile I hope

00:24:11,130 --> 00:24:18,140
I can fit everyone

00:24:13,610 --> 00:24:18,140
amazing and way

00:24:18,740 --> 00:24:25,679
thank you but just wait are you brave

00:24:22,169 --> 00:24:30,840
enough to test in production are you can

00:24:25,679 --> 00:24:31,440
I hear you well yeah so now the applause

00:24:30,840 --> 00:24:40,219
thank you

00:24:31,440 --> 00:24:40,219

YouTube URL: https://www.youtube.com/watch?v=1l55ZH3pm_E


