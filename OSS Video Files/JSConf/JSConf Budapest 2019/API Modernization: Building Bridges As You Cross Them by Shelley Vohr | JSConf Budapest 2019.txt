Title: API Modernization: Building Bridges As You Cross Them by Shelley Vohr | JSConf Budapest 2019
Publication date: 2019-10-17
Playlist: JSConf Budapest 2019
Description: 
	https://2019.jsconfbp.com/speakers/shelley_vohr

In an ecosystem undergoing constant flux, what does it mean for an API to be modern? In this talk, I'll discuss the work that's taken place over the last year to deliver modern JavaScript APIs to developers in the Electron project, and the obstacles we encountered along the way.

We'll discuss updates ranging from asynchronous JS to idiomatic getters and setters, as well as allowing developers to access new platform-dependent functionalities. Our APIs can and often are implemented across two or more languages on their way to the end user, and so we'll walk through some examples of how to effectively gather context and write reusable code to make updating simpler.

You'll come away with a deeper understanding of how open source projects can more effectively balance innovation with maintenance, as well as perspectives on how to appropriately consider end-users and their needs when modernization affects the code they use.

Shelley is a software engineer on the Electron team at GitHub who loves figuring out how to make things work. She's passionate about clean code & diving deep into tricky problems. She's also a runner, explorer, and crossword puzzle fan powered by more coffee than a human should probably drink.
Captions: 
	00:00:06,140 --> 00:00:11,940
hey everybody I'm Shelly 4 and today I'm

00:00:10,320 --> 00:00:16,080
gonna talk a little bit about the

00:00:11,940 --> 00:00:18,660
process of API and modernization for a

00:00:16,080 --> 00:00:21,000
little brief background on me I work

00:00:18,660 --> 00:00:23,640
full-time on the electron project on

00:00:21,000 --> 00:00:27,060
behalf of github where I've been for the

00:00:23,640 --> 00:00:30,119
past about two and a half years this

00:00:27,060 --> 00:00:32,730
work has also allowed me to explore and

00:00:30,119 --> 00:00:34,950
actively contribute to a pretty wide

00:00:32,730 --> 00:00:37,680
range of open-source projects and

00:00:34,950 --> 00:00:41,340
committees including node chromium and

00:00:37,680 --> 00:00:42,960
tc39 I'm based in San Francisco drink a

00:00:41,340 --> 00:00:47,809
lot of coffee and do a lot of crossword

00:00:42,960 --> 00:00:50,940
puzzles so what is modernization

00:00:47,809 --> 00:00:54,260
modernization means very little out of

00:00:50,940 --> 00:00:57,930
context especially in the software world

00:00:54,260 --> 00:01:00,750
it's a fun fancy buzzword but I can't

00:00:57,930 --> 00:01:03,120
really give a whole presentation on how

00:01:00,750 --> 00:01:05,549
you can apply its principles to your own

00:01:03,120 --> 00:01:08,970
organization without first establishing

00:01:05,549 --> 00:01:12,380
some shared context for what I mean

00:01:08,970 --> 00:01:15,119
when I say it in service of that goal

00:01:12,380 --> 00:01:17,729
let's start with the most basic

00:01:15,119 --> 00:01:22,009
definition of the term I could find as

00:01:17,729 --> 00:01:24,860
it applies to software so as we see here

00:01:22,009 --> 00:01:29,130
modernization can be understood as the

00:01:24,860 --> 00:01:32,270
conversion rewriting or porting of a

00:01:29,130 --> 00:01:36,060
legacy system to a modern language

00:01:32,270 --> 00:01:40,229
software library protocol or hardware

00:01:36,060 --> 00:01:41,790
platform that's an OK start but it still

00:01:40,229 --> 00:01:44,670
leaves us with quite a lot of unanswered

00:01:41,790 --> 00:01:47,549
questions what does it mean for

00:01:44,670 --> 00:01:49,259
something to even be modern there's

00:01:47,549 --> 00:01:52,380
still a lot of wiggle room in that

00:01:49,259 --> 00:01:54,540
definition that I just gave and even

00:01:52,380 --> 00:01:56,700
some of its different components might

00:01:54,540 --> 00:02:00,210
not all be understood in the same way

00:01:56,700 --> 00:02:02,880
even amongst you the audience for

00:02:00,210 --> 00:02:05,520
example a highly doubt that we all

00:02:02,880 --> 00:02:09,509
understand modern language to be the

00:02:05,520 --> 00:02:12,480
same thing for example beyond the Erb

00:02:09,509 --> 00:02:13,170
sorry beyond that can modernization even

00:02:12,480 --> 00:02:16,830
be universe

00:02:13,170 --> 00:02:19,590
we understood across contexts the answer

00:02:16,830 --> 00:02:23,160
to that question for better or worse is

00:02:19,590 --> 00:02:24,510
that it depends and I know that's

00:02:23,160 --> 00:02:27,540
probably not something a lot of you

00:02:24,510 --> 00:02:29,550
really love to hear it's kind of like

00:02:27,540 --> 00:02:32,520
running a non-deterministic software

00:02:29,550 --> 00:02:36,030
program it doesn't really inspire a

00:02:32,520 --> 00:02:37,650
whole lot of confidence but I'm not

00:02:36,030 --> 00:02:40,890
really here today to give you 30 minutes

00:02:37,650 --> 00:02:44,250
worth of maybe so let's unpack that a

00:02:40,890 --> 00:02:46,230
little bit further modernization is

00:02:44,250 --> 00:02:49,860
something that takes on different

00:02:46,230 --> 00:02:52,980
meanings in different contexts and so

00:02:49,860 --> 00:02:55,880
for you to really understand and gain

00:02:52,980 --> 00:02:59,250
concrete lessons from its discussion I'm

00:02:55,880 --> 00:03:02,010
going to ground it in practical examples

00:02:59,250 --> 00:03:05,519
from something I work on every day the

00:03:02,010 --> 00:03:06,660
electron framework modernization as

00:03:05,519 --> 00:03:10,739
we'll soon see

00:03:06,660 --> 00:03:12,450
can also feel a little bit like this but

00:03:10,739 --> 00:03:15,630
there's not always an obvious path to

00:03:12,450 --> 00:03:20,130
take and whichever one you do take can

00:03:15,630 --> 00:03:22,070
often lay waste your best laid plans you

00:03:20,130 --> 00:03:24,660
may now be wondering why is

00:03:22,070 --> 00:03:27,260
modernization even something that we

00:03:24,660 --> 00:03:29,940
actively want to do in the first place I

00:03:27,260 --> 00:03:32,570
haven't exactly opened with the most

00:03:29,940 --> 00:03:36,600
shiny and positive take on the thing

00:03:32,570 --> 00:03:40,470
some principle we modernize in order to

00:03:36,600 --> 00:03:43,530
retain and extend the value of a legacy

00:03:40,470 --> 00:03:47,519
investment which is an investment that

00:03:43,530 --> 00:03:50,730
continues to provide core services to an

00:03:47,519 --> 00:03:53,280
organization there's a lot of different

00:03:50,730 --> 00:03:55,650
reasons that you as a developer might

00:03:53,280 --> 00:03:58,230
want to do this but for better or worse

00:03:55,650 --> 00:04:02,970
it's something that almost all of us

00:03:58,230 --> 00:04:04,859
will at some point need to do now some

00:04:02,970 --> 00:04:06,870
of you might be familiar with electron

00:04:04,859 --> 00:04:08,910
but before you really get to the good

00:04:06,870 --> 00:04:11,700
stuff I think I'm gonna do a brief

00:04:08,910 --> 00:04:14,160
overview just to make sure that we all

00:04:11,700 --> 00:04:18,150
have the same base understanding of what

00:04:14,160 --> 00:04:20,630
it is electron is the JavaScript

00:04:18,150 --> 00:04:23,460
framework that allows you to write

00:04:20,630 --> 00:04:26,889
desktop applications with web

00:04:23,460 --> 00:04:31,090
technologies like JavaScript HTML

00:04:26,889 --> 00:04:34,919
and CSS it can be used on Windows Mac

00:04:31,090 --> 00:04:37,900
and Linux as well as a variety of other

00:04:34,919 --> 00:04:42,370
architectures and platforms like Windows

00:04:37,900 --> 00:04:45,090
on arm and even Raspberry Pi it works by

00:04:42,370 --> 00:04:47,979
integrating chromium and node in

00:04:45,090 --> 00:04:51,550
addition to a layer of C++

00:04:47,979 --> 00:04:56,889
an objective-c which allows it to create

00:04:51,550 --> 00:04:59,650
fully formed GUI GUIs as well as take

00:04:56,889 --> 00:05:04,659
advantage of file system and networking

00:04:59,650 --> 00:05:07,750
capabilities with node typically desktop

00:05:04,659 --> 00:05:10,750
applications for an operating system are

00:05:07,750 --> 00:05:16,180
written in the native language for each

00:05:10,750 --> 00:05:18,580
if we take Windows Mac and Linux that

00:05:16,180 --> 00:05:20,740
now means that you have three teams

00:05:18,580 --> 00:05:23,169
writing three different desktop

00:05:20,740 --> 00:05:27,159
applications to do functionally the same

00:05:23,169 --> 00:05:29,800
thing this can be pretty costly both in

00:05:27,159 --> 00:05:31,839
terms of monetary resources feature and

00:05:29,800 --> 00:05:35,169
development and velocity and developer

00:05:31,839 --> 00:05:37,659
hours with electron you will only need

00:05:35,169 --> 00:05:42,819
to write your app once and then it will

00:05:37,659 --> 00:05:44,409
work on all applicable platforms and we

00:05:42,819 --> 00:05:47,529
can't really understand how

00:05:44,409 --> 00:05:52,330
modernization affects users without

00:05:47,529 --> 00:05:56,919
first discussing API versioning an API

00:05:52,330 --> 00:06:00,370
is fundamentally a contract that you as

00:05:56,919 --> 00:06:03,520
a maintainer establish with the people

00:06:00,370 --> 00:06:08,800
consuming your API about how it's going

00:06:03,520 --> 00:06:12,310
to behave when developers have their API

00:06:08,800 --> 00:06:16,180
is consumed the consumers are implicitly

00:06:12,310 --> 00:06:19,300
signing their end of a contract and you

00:06:16,180 --> 00:06:23,500
as the maintainer are implicitly signing

00:06:19,300 --> 00:06:26,949
your end you can think of an API a

00:06:23,500 --> 00:06:29,169
little bit like buying a new car when

00:06:26,949 --> 00:06:31,990
you buy that car you've probably got a

00:06:29,169 --> 00:06:34,779
set of expectations for how that car is

00:06:31,990 --> 00:06:37,180
going to behave and how various controls

00:06:34,779 --> 00:06:38,169
on the car or going to affect that cars

00:06:37,180 --> 00:06:40,509
movement

00:06:38,169 --> 00:06:43,030
now let's say you've bought that car and

00:06:40,509 --> 00:06:44,710
it's pretty it's shiny and you get on

00:06:43,030 --> 00:06:46,930
the highway and you're going 80 and then

00:06:44,710 --> 00:06:49,900
suddenly the accelerator and the brake

00:06:46,930 --> 00:06:52,659
they switch now I don't know about you I

00:06:49,900 --> 00:06:54,430
love a good adventure but I really like

00:06:52,659 --> 00:06:57,849
knowing what my gas pedal is gonna do a

00:06:54,430 --> 00:07:01,449
hundred percent of the time your users

00:06:57,849 --> 00:07:03,729
are the same they don't want to risk

00:07:01,449 --> 00:07:08,020
their app on something they don't feel

00:07:03,729 --> 00:07:09,879
like they can trust so now back to one

00:07:08,020 --> 00:07:13,020
of the questions I had on an earlier

00:07:09,879 --> 00:07:16,270
slide how do you set these expectations

00:07:13,020 --> 00:07:19,330
one of the more common ways to set

00:07:16,270 --> 00:07:22,509
expectations for an API contract is

00:07:19,330 --> 00:07:26,319
known as semantic versioning or cember

00:07:22,509 --> 00:07:29,139
in this approach to versioning a version

00:07:26,319 --> 00:07:32,939
is specified with three numeric

00:07:29,139 --> 00:07:37,870
components first major then minor

00:07:32,939 --> 00:07:40,900
finally patch as its name suggests each

00:07:37,870 --> 00:07:44,409
one of these components confers semantic

00:07:40,900 --> 00:07:47,139
meaning and allows a consumer to quickly

00:07:44,409 --> 00:07:49,300
understand how updating their app to a

00:07:47,139 --> 00:07:52,719
new version is going to affect their

00:07:49,300 --> 00:07:55,599
apps potential behavior major version

00:07:52,719 --> 00:07:59,469
bumps are made when you add incompatible

00:07:55,599 --> 00:08:02,229
or braking API changes minor bumps

00:07:59,469 --> 00:08:05,349
indicate new but backwards compatible

00:08:02,229 --> 00:08:08,169
functionality and then finally patch

00:08:05,349 --> 00:08:12,189
updates indicate fixes to existing

00:08:08,169 --> 00:08:15,159
functionality but nothing new for our

00:08:12,189 --> 00:08:18,580
purposes today I'm gonna focus on three

00:08:15,159 --> 00:08:21,460
main buckets modernization spurned by

00:08:18,580 --> 00:08:24,779
updates to platform modernization

00:08:21,460 --> 00:08:27,250
related to dependencies and then finally

00:08:24,779 --> 00:08:30,839
modernization related to programming

00:08:27,250 --> 00:08:35,260
language specification first off

00:08:30,839 --> 00:08:39,329
platform modernization operating systems

00:08:35,260 --> 00:08:42,430
maintain their own unique API surfaces

00:08:39,329 --> 00:08:45,930
which don't always adhere to the kind of

00:08:42,430 --> 00:08:48,430
API contract you might be accustomed to

00:08:45,930 --> 00:08:50,350
platforms can't really adhere to

00:08:48,430 --> 00:08:51,410
something like cember when they're

00:08:50,350 --> 00:08:54,440
versioning

00:08:51,410 --> 00:08:57,530
so instead they often choose to make

00:08:54,440 --> 00:08:59,930
updates to their API surface area based

00:08:57,530 --> 00:09:03,260
on updates with their operating system

00:08:59,930 --> 00:09:05,660
versions as you might imagine this can

00:09:03,260 --> 00:09:08,350
create some mismatches with libraries

00:09:05,660 --> 00:09:12,400
which often need to work across multiple

00:09:08,350 --> 00:09:15,860
versions of a single operating system

00:09:12,400 --> 00:09:18,830
one example of this is Apple's App Gate

00:09:15,860 --> 00:09:21,230
framework which contains all the objects

00:09:18,830 --> 00:09:23,870
that a developer needs in order to

00:09:21,230 --> 00:09:28,040
implement the user interface for a Mac

00:09:23,870 --> 00:09:30,500
OS app like Windows panels menus

00:09:28,040 --> 00:09:34,430
scrollers text fields you get the idea

00:09:30,500 --> 00:09:36,080
as such frameworks like electron which

00:09:34,430 --> 00:09:39,500
hook into you and depend on this

00:09:36,080 --> 00:09:42,320
framework need to monitor and adapt for

00:09:39,500 --> 00:09:46,370
changes as Apple releases new versions

00:09:42,320 --> 00:09:49,610
of its operating system the question we

00:09:46,370 --> 00:09:53,570
then want to ask ourselves is what's the

00:09:49,610 --> 00:09:55,550
optimal way to account for this let's

00:09:53,570 --> 00:09:58,790
look at how electron handled a recent

00:09:55,550 --> 00:10:01,130
snafu with just such an issue if you've

00:09:58,790 --> 00:10:04,490
used Mac OS you'll know that there's a

00:10:01,130 --> 00:10:07,280
tree bar at the top of the screen the

00:10:04,490 --> 00:10:10,280
tree bar can contain individual elements

00:10:07,280 --> 00:10:15,140
which are known to Apple as NS status

00:10:10,280 --> 00:10:17,530
items electron exposes a module that

00:10:15,140 --> 00:10:20,240
enables you to create and control

00:10:17,530 --> 00:10:23,720
individual instances of these elements

00:10:20,240 --> 00:10:27,920
through the tree module from the very

00:10:23,720 --> 00:10:31,400
first release of Mac OS until 10.14

00:10:27,920 --> 00:10:34,670
mojave developers could use instance

00:10:31,400 --> 00:10:37,600
properties on these NS status items to

00:10:34,670 --> 00:10:41,720
customize their appearance and behavior

00:10:37,600 --> 00:10:44,210
then in Mac OS 10 point 10 they

00:10:41,720 --> 00:10:46,670
introduced a new instance property the

00:10:44,210 --> 00:10:48,830
button property which also allows you to

00:10:46,670 --> 00:10:52,190
customize the appearance and behavior of

00:10:48,830 --> 00:10:54,380
the items at the same time they

00:10:52,190 --> 00:10:57,850
deprecated the previous instance

00:10:54,380 --> 00:10:59,570
properties and then finally in Mac OS

00:10:57,850 --> 00:11:01,570
10.15 katalina

00:10:59,570 --> 00:11:04,070
these deprecated instance properties

00:11:01,570 --> 00:11:06,470
finally ceased to work

00:11:04,070 --> 00:11:08,930
an electron this created some pretty

00:11:06,470 --> 00:11:11,990
nasty consequences we've been using the

00:11:08,930 --> 00:11:14,329
previous instance properties up until

00:11:11,990 --> 00:11:15,829
then and only actually realize this

00:11:14,329 --> 00:11:17,570
issue had happened because the tray

00:11:15,829 --> 00:11:19,699
issues when we are testing our catalina

00:11:17,570 --> 00:11:22,730
literally just stopped showing up which

00:11:19,699 --> 00:11:25,339
is you can imagine was pretty awesome so

00:11:22,730 --> 00:11:28,190
as a result we had to quickly and

00:11:25,339 --> 00:11:30,980
efficiently modernize our own code for

00:11:28,190 --> 00:11:34,399
these new constraints but there is one

00:11:30,980 --> 00:11:37,180
catch the button property no longer

00:11:34,399 --> 00:11:39,850
allowed developers to manually manage

00:11:37,180 --> 00:11:42,380
highlighting of NS status items

00:11:39,850 --> 00:11:44,029
highlighting in this case is the way

00:11:42,380 --> 00:11:46,670
that the icon appears when you click on

00:11:44,029 --> 00:11:48,709
it previously you could set it to always

00:11:46,670 --> 00:11:51,050
appear highlighted only appear

00:11:48,709 --> 00:11:53,839
highlighted when clicked or never appear

00:11:51,050 --> 00:11:56,600
highlighted so how do we handle this

00:11:53,839 --> 00:12:00,290
change by necessity this is a breaking

00:11:56,600 --> 00:12:03,230
change what we chose to do is to remove

00:12:00,290 --> 00:12:06,290
this method from electron version 7

00:12:03,230 --> 00:12:09,139
without replacement since at the time it

00:12:06,290 --> 00:12:12,490
was in an early beta and so we wouldn't

00:12:09,139 --> 00:12:15,440
be breaking our API contract by doing so

00:12:12,490 --> 00:12:18,170
we then noted that the tray would

00:12:15,440 --> 00:12:20,510
experience display issues in older

00:12:18,170 --> 00:12:25,130
versions of electron and encouraged

00:12:20,510 --> 00:12:28,149
users to update where they could as you

00:12:25,130 --> 00:12:30,980
consider your own apps platform

00:12:28,149 --> 00:12:32,990
modernization strategies there are some

00:12:30,980 --> 00:12:36,470
things I think that electrons experience

00:12:32,990 --> 00:12:38,959
demonstrates here we don't always make

00:12:36,470 --> 00:12:41,779
the right choices and so we want to

00:12:38,959 --> 00:12:44,720
share both our successes and the things

00:12:41,779 --> 00:12:46,639
that we think we can do better we

00:12:44,720 --> 00:12:49,040
determined these breaking changes in

00:12:46,639 --> 00:12:51,380
practice because one of the core team

00:12:49,040 --> 00:12:53,839
was doing some testing on Mac OS

00:12:51,380 --> 00:12:56,480
Catalina but this change was ultimately

00:12:53,839 --> 00:13:00,050
more reactionary than I think we wanted

00:12:56,480 --> 00:13:02,089
it to be it's important to strategize

00:13:00,050 --> 00:13:04,939
research around upcoming platform

00:13:02,089 --> 00:13:07,009
changes in advance so that you don't end

00:13:04,939 --> 00:13:10,850
up scrambling to minimize and user

00:13:07,009 --> 00:13:12,740
changes in the same way that we did how

00:13:10,850 --> 00:13:16,070
do we done that we could have avoided

00:13:12,740 --> 00:13:18,320
users experiencing any braking changes

00:13:16,070 --> 00:13:21,800
more than one supportive version of

00:13:18,320 --> 00:13:25,010
electron next up is language

00:13:21,800 --> 00:13:27,230
modernization language modernization is

00:13:25,010 --> 00:13:30,320
that relating to the programming

00:13:27,230 --> 00:13:33,350
language in which a framework or library

00:13:30,320 --> 00:13:36,560
is consumed that's important in the case

00:13:33,350 --> 00:13:38,750
of electron because while electron is a

00:13:36,560 --> 00:13:41,060
JavaScript framework its underlying

00:13:38,750 --> 00:13:44,150
architecture is actually written in a

00:13:41,060 --> 00:13:48,040
combination of Objective C and C++ and

00:13:44,150 --> 00:13:50,750
so modernization and electron is

00:13:48,040 --> 00:13:53,530
modernization that allows developers to

00:13:50,750 --> 00:13:56,570
use new additions or changes to

00:13:53,530 --> 00:13:58,700
JavaScript as they are added to the

00:13:56,570 --> 00:14:00,320
JavaScript frame or to the JavaScript

00:13:58,700 --> 00:14:03,350
language through the Ekman script

00:14:00,320 --> 00:14:06,830
specification a variety of these are

00:14:03,350 --> 00:14:10,220
outlined here some you might be more

00:14:06,830 --> 00:14:12,440
familiar with include promises async

00:14:10,220 --> 00:14:15,650
await optional catch binding our

00:14:12,440 --> 00:14:18,380
knowledge coalescing some of these

00:14:15,650 --> 00:14:21,590
capabilities get to electron for free

00:14:18,380 --> 00:14:24,440
when we update our dependencies like v8

00:14:21,590 --> 00:14:26,660
but we'll save that for later and focus

00:14:24,440 --> 00:14:30,380
on the more costly updates right now

00:14:26,660 --> 00:14:33,500
a notable effort in the electron

00:14:30,380 --> 00:14:36,590
codebase this past spring was known as

00:14:33,500 --> 00:14:40,090
the promise of vacation initiative which

00:14:36,590 --> 00:14:42,860
took most of our asynchronous api's and

00:14:40,090 --> 00:14:46,250
transformed their usage from call back

00:14:42,860 --> 00:14:48,530
to promise based we undertook this

00:14:46,250 --> 00:14:51,230
initiative for a variety of the reasons

00:14:48,530 --> 00:14:54,350
I've already outlined call backs have

00:14:51,230 --> 00:14:56,720
their place undoubtedly but developers

00:14:54,350 --> 00:15:00,320
can write arguably simpler and more

00:14:56,720 --> 00:15:02,480
elegant code and open the doors to even

00:15:00,320 --> 00:15:06,290
more functionality when they can write

00:15:02,480 --> 00:15:08,960
promise based code so how do we do this

00:15:06,290 --> 00:15:11,630
and then how did we communicate this to

00:15:08,960 --> 00:15:14,000
our users we actually chose to do it

00:15:11,630 --> 00:15:15,470
natively and I can see some of you look

00:15:14,000 --> 00:15:18,050
a little bit confused by that aren't

00:15:15,470 --> 00:15:19,730
promises a JavaScript thing so the

00:15:18,050 --> 00:15:23,930
answer to that is actually yes but also

00:15:19,730 --> 00:15:27,620
know to do this we actually used an

00:15:23,930 --> 00:15:28,750
engine called v8 which Google wrote for

00:15:27,620 --> 00:15:31,839
Google Chrome

00:15:28,750 --> 00:15:35,949
it implements the same specification as

00:15:31,839 --> 00:15:38,319
JavaScript but in C++ by writing a

00:15:35,949 --> 00:15:41,829
wrapper over its promise functionality

00:15:38,319 --> 00:15:44,709
we could enable our api's to cleanly

00:15:41,829 --> 00:15:48,009
return promises at the C++ an

00:15:44,709 --> 00:15:51,160
objective-c level without needing to

00:15:48,009 --> 00:15:53,350
paper over them at the JavaScript level

00:15:51,160 --> 00:15:57,040
with something from node like util dot

00:15:53,350 --> 00:15:59,620
promise fie so basically promises but

00:15:57,040 --> 00:16:01,750
with surprise multi-threading this looks

00:15:59,620 --> 00:16:04,209
a little horrifying I recognize but

00:16:01,750 --> 00:16:07,149
honestly it was pretty fun and arguably

00:16:04,209 --> 00:16:10,600
a lot better for consumers we also

00:16:07,149 --> 00:16:13,480
created a document to track progress of

00:16:10,600 --> 00:16:16,389
this migration and conform to our own

00:16:13,480 --> 00:16:18,970
cember contract by ensuring that the

00:16:16,389 --> 00:16:21,550
changes were backwards compatible where

00:16:18,970 --> 00:16:23,970
possible which means that they supported

00:16:21,550 --> 00:16:26,949
both callbacks and promises

00:16:23,970 --> 00:16:30,129
simultaneously for at least one major

00:16:26,949 --> 00:16:31,990
version to ensure the developers had

00:16:30,129 --> 00:16:36,160
enough lead time to make necessary

00:16:31,990 --> 00:16:38,559
changes we also logged these backwards

00:16:36,160 --> 00:16:42,279
compatible functions with deprecation

00:16:38,559 --> 00:16:45,879
warnings at runtime so is this a totally

00:16:42,279 --> 00:16:48,879
smooth process also no on a high level

00:16:45,879 --> 00:16:51,250
we accomplished our goal with relatively

00:16:48,879 --> 00:16:54,129
few hiccups but that's not to say we

00:16:51,250 --> 00:16:56,170
didn't hit any snags and one of our more

00:16:54,129 --> 00:16:58,689
fun bugs we actually found that if you

00:16:56,170 --> 00:17:01,329
called one API in just the right way a

00:16:58,689 --> 00:17:03,819
native promise chain would trigger an

00:17:01,329 --> 00:17:06,069
uncatchable promise rejection that the

00:17:03,819 --> 00:17:08,319
user would only ever see as a silent

00:17:06,069 --> 00:17:11,799
failure because we'd actually introduced

00:17:08,319 --> 00:17:15,850
a way to write non typesafe C++ Jeff

00:17:11,799 --> 00:17:17,500
Goldblum was ashamed of us for that so

00:17:15,850 --> 00:17:20,789
what have we learned from that adventure

00:17:17,500 --> 00:17:24,789
and what can you take away from it

00:17:20,789 --> 00:17:28,360
for starters deprecating methods well is

00:17:24,789 --> 00:17:32,230
a non-trivial task that shouldn't be

00:17:28,360 --> 00:17:37,070
done haphazardly we should have been

00:17:32,230 --> 00:17:40,010
more clear upfront that all changes what

00:17:37,070 --> 00:17:42,680
be taking place in one major version

00:17:40,010 --> 00:17:45,190
since we occasionally still get issues

00:17:42,680 --> 00:17:47,930
saying that a promise based function

00:17:45,190 --> 00:17:50,840
didn't work for promises when it hadn't

00:17:47,930 --> 00:17:52,820
yet been converted we're looking towards

00:17:50,840 --> 00:17:55,610
our docks to help us better fill that

00:17:52,820 --> 00:17:59,210
gap we do want to continue our

00:17:55,610 --> 00:18:01,460
transition path pattern however feedback

00:17:59,210 --> 00:18:03,670
from our users indicated that they felt

00:18:01,460 --> 00:18:06,410
we provided clear context and

00:18:03,670 --> 00:18:07,880
information on how to upgrade methods

00:18:06,410 --> 00:18:11,990
that they were already using in

00:18:07,880 --> 00:18:15,410
production finally we move to dependency

00:18:11,990 --> 00:18:17,480
modernization this is modernization that

00:18:15,410 --> 00:18:19,850
enables access to more modern

00:18:17,480 --> 00:18:23,450
capabilities through dependencies and

00:18:19,850 --> 00:18:26,570
not through code we wrote ourselves for

00:18:23,450 --> 00:18:31,490
electron three key dependencies of this

00:18:26,570 --> 00:18:34,520
nature our chromium v8 and node updating

00:18:31,490 --> 00:18:37,700
each of these gives users access to new

00:18:34,520 --> 00:18:40,580
features but also brings with them

00:18:37,700 --> 00:18:42,440
potentially breaking changes and so we

00:18:40,580 --> 00:18:47,120
need to be very mindful about how we

00:18:42,440 --> 00:18:50,480
coordinate these upgrades upgrading node

00:18:47,120 --> 00:18:52,850
for example gives us access to new file

00:18:50,480 --> 00:18:56,870
system and networking capabilities like

00:18:52,850 --> 00:19:00,140
for example or cursive RM der since node

00:18:56,870 --> 00:19:03,080
also adheres December minor bumps in

00:19:00,140 --> 00:19:05,510
node also necessitate minor bumps an

00:19:03,080 --> 00:19:09,140
electron and major bumps in node

00:19:05,510 --> 00:19:11,720
necessitate major bumps an electron by

00:19:09,140 --> 00:19:13,910
upgrading node we ensure that we stay on

00:19:11,720 --> 00:19:15,830
top of security updates and see

00:19:13,910 --> 00:19:17,510
performance improvements thanks to the

00:19:15,830 --> 00:19:20,870
great work of the benchmarking working

00:19:17,510 --> 00:19:23,060
group within notes governance chromium

00:19:20,870 --> 00:19:25,670
is a bit of a different story and that

00:19:23,060 --> 00:19:28,190
they don't really adhere to the same API

00:19:25,670 --> 00:19:30,260
contract we do and they don't support

00:19:28,190 --> 00:19:33,710
older versions passed a fairly short

00:19:30,260 --> 00:19:37,070
tail we're therefore always chasing the

00:19:33,710 --> 00:19:39,500
tip of chromium source tree security and

00:19:37,070 --> 00:19:41,840
performance are our primary forcing

00:19:39,500 --> 00:19:44,570
functions here as the most secure

00:19:41,840 --> 00:19:47,210
chromium is always going to be the

00:19:44,570 --> 00:19:50,570
latest chromium and the performance of

00:19:47,210 --> 00:19:51,110
chromium and therefore electron is also

00:19:50,570 --> 00:19:53,330
going to be

00:19:51,110 --> 00:19:56,809
better the more recent a version of

00:19:53,330 --> 00:19:58,880
chromium that we're using we also do get

00:19:56,809 --> 00:20:01,640
some upgrades and new capabilities for

00:19:58,880 --> 00:20:04,160
free from chromium like for example the

00:20:01,640 --> 00:20:06,640
wick lock API that allows you to control

00:20:04,160 --> 00:20:09,290
screen sleep on different platforms

00:20:06,640 --> 00:20:11,870
these capabilities are still a work in

00:20:09,290 --> 00:20:14,210
progress and are constantly being scoped

00:20:11,870 --> 00:20:18,080
out and experimented on through what's

00:20:14,210 --> 00:20:22,340
known as the fugu initiative finally v8

00:20:18,080 --> 00:20:24,410
I mentioned v8 a bit earlier on as

00:20:22,340 --> 00:20:26,390
Google's JavaScript engine that

00:20:24,410 --> 00:20:30,380
implements the equi script specification

00:20:26,390 --> 00:20:32,900
but in C++ for electrons purposes it's

00:20:30,380 --> 00:20:35,179
also very important that we try to use

00:20:32,900 --> 00:20:38,330
the latest compatible version that we

00:20:35,179 --> 00:20:40,390
can this enables us to access the latest

00:20:38,330 --> 00:20:42,440
features of the JavaScript spec

00:20:40,390 --> 00:20:45,919
including some that you can see on the

00:20:42,440 --> 00:20:47,809
slide here on the left-hand portion v8

00:20:45,919 --> 00:20:50,450
also works extremely hard to be

00:20:47,809 --> 00:20:53,360
performin and so as we look to make

00:20:50,450 --> 00:20:55,669
electron faster and less costly it's

00:20:53,360 --> 00:20:59,410
also in our best interest to track v8 as

00:20:55,669 --> 00:21:01,910
closely as we can and now to the lessons

00:20:59,410 --> 00:21:04,160
we've managed to consistently be

00:21:01,910 --> 00:21:07,700
updating against chromium's tip of tree

00:21:04,160 --> 00:21:10,160
and the latest stable node but our newly

00:21:07,700 --> 00:21:13,700
short feedback loop was not without a

00:21:10,160 --> 00:21:15,470
few difficult lessons sometimes your

00:21:13,700 --> 00:21:17,690
dependencies won't all play nicely in

00:21:15,470 --> 00:21:18,830
the sandbox together and if you know

00:21:17,690 --> 00:21:21,260
that's gonna be the case

00:21:18,830 --> 00:21:24,220
it's best to make your version bundling

00:21:21,260 --> 00:21:26,540
decisions as far in advance as possible

00:21:24,220 --> 00:21:28,790
we didn't really do that well for

00:21:26,540 --> 00:21:31,010
electron version 6 and so at one point

00:21:28,790 --> 00:21:33,380
we ended up having to scramble a little

00:21:31,010 --> 00:21:35,570
bit and had to use a slowly less than

00:21:33,380 --> 00:21:38,090
stable version of node version 12

00:21:35,570 --> 00:21:42,350
because we were releasing slowly before

00:21:38,090 --> 00:21:43,910
went stable this was unfortunate as it

00:21:42,350 --> 00:21:46,820
didn't really change too much from the

00:21:43,910 --> 00:21:48,620
consumer end but it did mildly change

00:21:46,820 --> 00:21:54,169
some of their dependency modernization

00:21:48,620 --> 00:21:56,360
expectations you as a developer probably

00:21:54,169 --> 00:21:58,429
want to give your users the ability to

00:21:56,360 --> 00:22:01,460
use whatever you've defined as the

00:21:58,429 --> 00:22:04,040
latest and the greatest and your users

00:22:01,460 --> 00:22:04,550
want to access these spicey latest and

00:22:04,040 --> 00:22:07,940
greatest

00:22:04,550 --> 00:22:10,700
without communication however these two

00:22:07,940 --> 00:22:13,100
converging desires are like a chemical

00:22:10,700 --> 00:22:15,560
reaction that given just the wrong

00:22:13,100 --> 00:22:18,470
measurement of a single ingredient can

00:22:15,560 --> 00:22:20,540
accidentally explode the whole lab what

00:22:18,470 --> 00:22:23,230
if you and your users have different

00:22:20,540 --> 00:22:25,600
understandings of latest and greatest

00:22:23,230 --> 00:22:27,620
that's a non-trivial possibility

00:22:25,600 --> 00:22:29,900
considering that you need to take into

00:22:27,620 --> 00:22:32,480
account different platforms opinions

00:22:29,900 --> 00:22:35,330
conventions and what you yourselves are

00:22:32,480 --> 00:22:38,540
functionally capable of delivering the

00:22:35,330 --> 00:22:40,730
only way to set expectations and ensure

00:22:38,540 --> 00:22:43,040
that your users are aligned with your

00:22:40,730 --> 00:22:45,650
efforts is to communicate with them as

00:22:43,040 --> 00:22:49,750
far in advance and with this high a

00:22:45,650 --> 00:22:52,670
degree of detail as possible to that end

00:22:49,750 --> 00:22:56,300
optimal communication can be understood

00:22:52,670 --> 00:22:58,640
to fall into three big buckets ensuring

00:22:56,300 --> 00:23:02,570
redundancy communicating early and

00:22:58,640 --> 00:23:04,700
providing context your users aren't and

00:23:02,570 --> 00:23:06,520
shouldn't be responsible for digging

00:23:04,700 --> 00:23:08,750
into the deep dark depths of your

00:23:06,520 --> 00:23:11,750
documentation to figure out what's

00:23:08,750 --> 00:23:15,380
coming up soon that burden is on you the

00:23:11,750 --> 00:23:17,960
maintainer upcoming changes especially

00:23:15,380 --> 00:23:20,660
those that break or alter existing

00:23:17,960 --> 00:23:23,450
functionality should be as discoverable

00:23:20,660 --> 00:23:26,930
and as context rich as you can make them

00:23:23,450 --> 00:23:29,630
if there's only a single place that your

00:23:26,930 --> 00:23:31,930
users can go to determine upcoming

00:23:29,630 --> 00:23:34,490
changes that's a single point of failure

00:23:31,930 --> 00:23:38,090
they missed that and they might get

00:23:34,490 --> 00:23:40,430
blindsided in my opinion the opposite of

00:23:38,090 --> 00:23:43,430
a single point of failure is not

00:23:40,430 --> 00:23:46,570
necessarily no points of failure instead

00:23:43,430 --> 00:23:49,490
its multiple discrete points of failure

00:23:46,570 --> 00:23:53,090
we want to ensure that your users can

00:23:49,490 --> 00:23:55,310
miss one or even two notices and still

00:23:53,090 --> 00:23:57,980
be made aware of changes which can only

00:23:55,310 --> 00:24:00,310
happen if you saturate the information

00:23:57,980 --> 00:24:03,460
in as many places as possible

00:24:00,310 --> 00:24:05,840
and next communicating early

00:24:03,460 --> 00:24:08,330
communication is always great on

00:24:05,840 --> 00:24:11,090
principle but not all communication

00:24:08,330 --> 00:24:13,490
benefits users equally telling your

00:24:11,090 --> 00:24:14,990
consumers about a change right as it is

00:24:13,490 --> 00:24:16,420
about to affect them

00:24:14,990 --> 00:24:18,230
is for all intents and purposes

00:24:16,420 --> 00:24:21,200
indistinguishable from not telling them

00:24:18,230 --> 00:24:23,480
at all to that end you should look

00:24:21,200 --> 00:24:26,330
towards informing your users of upcoming

00:24:23,480 --> 00:24:28,520
changes as soon as plans are clear

00:24:26,330 --> 00:24:32,179
enough that it's unlikely you'll need to

00:24:28,520 --> 00:24:34,850
alter or recant them your users should

00:24:32,179 --> 00:24:37,010
also be made aware of when a change is

00:24:34,850 --> 00:24:39,230
scheduled to take effect on what

00:24:37,010 --> 00:24:42,350
versions that change is going to take

00:24:39,230 --> 00:24:45,320
effect and what their need going to need

00:24:42,350 --> 00:24:46,280
to consider in doing work for dealing

00:24:45,320 --> 00:24:48,710
with your changes

00:24:46,280 --> 00:24:51,110
a team of five might and probably is

00:24:48,710 --> 00:24:52,760
going to be incredible but they're gonna

00:24:51,110 --> 00:24:54,800
have to consider this work in a

00:24:52,760 --> 00:25:00,350
fundamentally different way than a team

00:24:54,800 --> 00:25:02,540
of say 50 might and finally context when

00:25:00,350 --> 00:25:04,790
you make changes to your API surface

00:25:02,540 --> 00:25:07,340
there's going to be a reason that you're

00:25:04,790 --> 00:25:09,800
doing so unless there's a security

00:25:07,340 --> 00:25:12,650
related or similar concern requiring

00:25:09,800 --> 00:25:14,780
discretion why not share that context

00:25:12,650 --> 00:25:16,850
with your users it'll help them

00:25:14,780 --> 00:25:19,960
understand your processes more and

00:25:16,850 --> 00:25:23,210
likely foster better community relations

00:25:19,960 --> 00:25:25,490
when providing that context there's four

00:25:23,210 --> 00:25:28,520
main questions I think are important to

00:25:25,490 --> 00:25:31,220
ask yourself why are you making these

00:25:28,520 --> 00:25:35,179
changes how does this benefit your users

00:25:31,220 --> 00:25:38,270
how might this hurt them and then how

00:25:35,179 --> 00:25:41,000
can they prepare answering these and

00:25:38,270 --> 00:25:43,100
provide a strong contextual base for

00:25:41,000 --> 00:25:47,559
smoother updates as your project

00:25:43,100 --> 00:25:49,460
continues to grow unfortunately

00:25:47,559 --> 00:25:52,429
communication can help against some

00:25:49,460 --> 00:25:54,880
limits you can communicate your list of

00:25:52,429 --> 00:25:58,040
breaking changes really far in advance

00:25:54,880 --> 00:26:00,290
but if every major version has a hundred

00:25:58,040 --> 00:26:02,809
breaking changes it's gonna be difficult

00:26:00,290 --> 00:26:05,480
to keep up and the cost of updating your

00:26:02,809 --> 00:26:08,660
library might become too high for some

00:26:05,480 --> 00:26:10,970
of your users to that end it's important

00:26:08,660 --> 00:26:13,400
to be intentional about minimizing churn

00:26:10,970 --> 00:26:15,170
where possible you don't want to throw

00:26:13,400 --> 00:26:17,530
your users onto an endless hamster wheel

00:26:15,170 --> 00:26:20,660
of Terror because as we see here

00:26:17,530 --> 00:26:23,240
everyone suffers and you don't want that

00:26:20,660 --> 00:26:25,430
your consumers don't want that nobody

00:26:23,240 --> 00:26:28,030
wants that

00:26:25,430 --> 00:26:30,890
and as vital as modernization can be

00:26:28,030 --> 00:26:33,910
sometimes the best choice can be either

00:26:30,890 --> 00:26:36,230
to defer or not to modernize in

00:26:33,910 --> 00:26:38,750
considering whether this is the decision

00:26:36,230 --> 00:26:40,190
best for you and your team there are

00:26:38,750 --> 00:26:43,100
several things you're going to want to

00:26:40,190 --> 00:26:44,390
take into account chiefly as I've said

00:26:43,100 --> 00:26:48,200
over and over again through this

00:26:44,390 --> 00:26:50,780
presentation context is key the

00:26:48,200 --> 00:26:52,010
information you have today might guide

00:26:50,780 --> 00:26:53,810
you towards a slightly different

00:26:52,010 --> 00:26:56,240
decision than the information you have

00:26:53,810 --> 00:26:59,060
six months from now or the information

00:26:56,240 --> 00:27:01,520
you had six months ago code base is live

00:26:59,060 --> 00:27:03,410
and breathe and your decision now

00:27:01,520 --> 00:27:05,960
doesn't mean you can't take a different

00:27:03,410 --> 00:27:08,060
path down the road you want to ensure

00:27:05,960 --> 00:27:11,570
that this change will have veritable

00:27:08,060 --> 00:27:14,120
positive impact on your project perhaps

00:27:11,570 --> 00:27:15,860
end-users won't see a change but it'll

00:27:14,120 --> 00:27:18,770
decrease maintenance burden across big

00:27:15,860 --> 00:27:21,620
parts of your codebase the real danger

00:27:18,770 --> 00:27:25,490
lies in modernization for its own sake

00:27:21,620 --> 00:27:27,350
if you can't prove impact to some part

00:27:25,490 --> 00:27:29,630
of your ecosystem you should ask

00:27:27,350 --> 00:27:31,910
yourself are these developer hours gonna

00:27:29,630 --> 00:27:33,890
be worth it if it would increase

00:27:31,910 --> 00:27:36,230
maintenance cost or increased technical

00:27:33,890 --> 00:27:40,160
debt that would also likely be a vote

00:27:36,230 --> 00:27:43,040
against electron has learned a lot from

00:27:40,160 --> 00:27:45,710
both its successes and its failures on

00:27:43,040 --> 00:27:48,740
all these fronts these examples are

00:27:45,710 --> 00:27:50,900
provided in light of our experiences can

00:27:48,740 --> 00:27:53,240
hopefully help you to shed light on how

00:27:50,900 --> 00:27:55,580
to make better choices in your own code

00:27:53,240 --> 00:27:58,100
bases but our constraints and

00:27:55,580 --> 00:28:00,980
considerations are going to be different

00:27:58,100 --> 00:28:04,010
than yours and so it follows that your

00:28:00,980 --> 00:28:06,260
decisions may also be when you return to

00:28:04,010 --> 00:28:08,300
your code bases next week I encourage

00:28:06,260 --> 00:28:11,030
you to view these as heuristics rather

00:28:08,300 --> 00:28:13,730
than rules heuristics require

00:28:11,030 --> 00:28:17,450
situational interpretation but rules

00:28:13,730 --> 00:28:19,700
hold fast across contexts you also have

00:28:17,450 --> 00:28:22,820
primary responsibility for the success

00:28:19,700 --> 00:28:24,950
of you users you should want the barrier

00:28:22,820 --> 00:28:28,030
to their success and using your library

00:28:24,950 --> 00:28:30,980
or framework to be as low as possible

00:28:28,030 --> 00:28:33,650
finally all modernization requires

00:28:30,980 --> 00:28:35,420
non-trivial work if this is something

00:28:33,650 --> 00:28:38,360
that matters to you it should never be

00:28:35,420 --> 00:28:39,140
planned as an afterthought and finally I

00:28:38,360 --> 00:28:40,760
want to hear from

00:28:39,140 --> 00:28:43,370
you do you have thoughts on the future

00:28:40,760 --> 00:28:45,140
of electron the boundary between web and

00:28:43,370 --> 00:28:47,180
desktop or what it's like to work

00:28:45,140 --> 00:28:48,620
full-time on open source I'll be around

00:28:47,180 --> 00:28:50,390
for the next two days and be more than

00:28:48,620 --> 00:28:52,020
happy to answer any of your questions

00:28:50,390 --> 00:29:02,750
thank you very much

00:28:52,020 --> 00:29:02,750

YouTube URL: https://www.youtube.com/watch?v=GI2Vo-UQG5w


