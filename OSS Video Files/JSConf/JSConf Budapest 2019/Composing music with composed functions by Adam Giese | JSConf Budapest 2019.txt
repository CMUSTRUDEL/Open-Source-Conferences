Title: Composing music with composed functions by Adam Giese | JSConf Budapest 2019
Publication date: 2019-10-28
Playlist: JSConf Budapest 2019
Description: 
	https://2019.jsconfbp.com/speakers/adam_giese

Functional programming can be difficult to learn. Although there are many practical lessons, they are often hidden through academic lingo and dry examples. What if these basics could be livened up and taught through the lens of music? Together, we will go over some of the basics of functional programming including functional array manipulation, closure, immutability, and composing functions. As I go through these, I will show how they can be applied to the creation of music and musical instruments using the web audio API.

Adam Giese is a software engineer in Austin, TX. He has a passion for music and the web and believes that the marriage of the two can lead to great outcomes. Outside of computers, Adam enjoys exploring the many sides of Austin with his family.
Captions: 
	00:00:00,070 --> 00:00:02,280
[Applause]

00:00:05,270 --> 00:00:10,050
all right good afternoon everybody I

00:00:07,859 --> 00:00:11,639
hope everyone's having a great time at

00:00:10,050 --> 00:00:15,179
Gia's computer pest

00:00:11,639 --> 00:00:17,430
my name is Adam DC I'm Adam DC dev on

00:00:15,179 --> 00:00:19,760
Twitter and before I was a software

00:00:17,430 --> 00:00:23,039
engineer I did attend school for music

00:00:19,760 --> 00:00:25,289
specifically music composition and I was

00:00:23,039 --> 00:00:28,289
always drawn to the analytical thinking

00:00:25,289 --> 00:00:30,480
aspect of music theory and perhaps

00:00:28,289 --> 00:00:33,960
surprising nobody I had a tough time

00:00:30,480 --> 00:00:35,460
finding a job in music and so I went

00:00:33,960 --> 00:00:38,100
into programming which I had some

00:00:35,460 --> 00:00:39,750
experience with and years later when I

00:00:38,100 --> 00:00:42,360
started to learn a functional

00:00:39,750 --> 00:00:45,329
programming I found that the same itch

00:00:42,360 --> 00:00:48,690
was scratched regarding the analytical

00:00:45,329 --> 00:00:52,140
thinking so when I started to try to get

00:00:48,690 --> 00:00:54,870
back into music as a hobby I decided to

00:00:52,140 --> 00:00:57,449
use functional programming so here's my

00:00:54,870 --> 00:00:58,469
introduction to programming my

00:00:57,449 --> 00:01:03,120
introduction to functional programming

00:00:58,469 --> 00:01:05,850
from a musical perspective so first we

00:01:03,120 --> 00:01:09,270
must ask the question what is functional

00:01:05,850 --> 00:01:13,140
programming my answer is its programming

00:01:09,270 --> 00:01:15,090
with functions just like object-oriented

00:01:13,140 --> 00:01:16,680
programs are oriented around objects

00:01:15,090 --> 00:01:18,869
functions are the building block of

00:01:16,680 --> 00:01:20,960
functional programming but that

00:01:18,869 --> 00:01:25,409
naturally leads to the next question

00:01:20,960 --> 00:01:27,540
what is a function a non functional

00:01:25,409 --> 00:01:30,090
programming definition might be

00:01:27,540 --> 00:01:34,170
something like a sequence of commands

00:01:30,090 --> 00:01:36,869
abstract into a reusable unit but a more

00:01:34,170 --> 00:01:39,479
functional definition is a relationship

00:01:36,869 --> 00:01:43,079
between a set of inputs and outputs and

00:01:39,479 --> 00:01:45,240
this is sometimes referred to as a pure

00:01:43,079 --> 00:01:47,189
function and it comes from the

00:01:45,240 --> 00:01:50,700
mathematical definition of a function

00:01:47,189 --> 00:01:52,799
and these so-called pure functions are

00:01:50,700 --> 00:01:55,320
the building block of functional

00:01:52,799 --> 00:02:00,030
programming so what makes a function

00:01:55,320 --> 00:02:02,850
pure well there's two main aspects given

00:02:00,030 --> 00:02:05,610
the same arguments in it will return the

00:02:02,850 --> 00:02:09,319
same value that means it shouldn't rely

00:02:05,610 --> 00:02:11,940
on anything outside of itself such as a

00:02:09,319 --> 00:02:12,819
random number generator or the current

00:02:11,940 --> 00:02:15,249
time or

00:02:12,819 --> 00:02:17,950
read from the database it also means it

00:02:15,249 --> 00:02:20,590
shouldn't affect anything outside of its

00:02:17,950 --> 00:02:22,859
return value such as manipulating the

00:02:20,590 --> 00:02:26,099
Dom or writing to a database and

00:02:22,859 --> 00:02:28,989
together this makes the function

00:02:26,099 --> 00:02:31,180
referentially transparent this means

00:02:28,989 --> 00:02:33,549
that a function call with the same

00:02:31,180 --> 00:02:39,400
parameters can be replaced by its return

00:02:33,549 --> 00:02:42,549
value so here we are defining middle c

00:02:39,400 --> 00:02:44,260
with a name and an octave and increment

00:02:42,549 --> 00:02:47,469
- octave here is a pure function it

00:02:44,260 --> 00:02:51,069
takes a note and it returns a new note

00:02:47,469 --> 00:02:54,159
with the octave incremented by one and I

00:02:51,069 --> 00:02:57,040
see here is the result of that pure

00:02:54,159 --> 00:02:59,290
function playing here is a function that

00:02:57,040 --> 00:03:00,159
is an impure function because it has a

00:02:59,290 --> 00:03:04,689
side-effect

00:03:00,159 --> 00:03:07,060
it sends music to the browser you can

00:03:04,689 --> 00:03:08,769
pass an either high C or increment

00:03:07,060 --> 00:03:11,049
octave middle C and I'll have the same

00:03:08,769 --> 00:03:13,780
effect because of the referential

00:03:11,049 --> 00:03:18,129
transparency of the increment octave

00:03:13,780 --> 00:03:21,009
function so we decided to learn

00:03:18,129 --> 00:03:24,930
functional programming remove all side

00:03:21,009 --> 00:03:27,250
effects and now your program is useless

00:03:24,930 --> 00:03:30,340
it's important to note that side effects

00:03:27,250 --> 00:03:32,769
are not bad HTTP requests Dom

00:03:30,340 --> 00:03:35,859
manipulation or playing music are all

00:03:32,769 --> 00:03:37,840
side effects they are not bad but they

00:03:35,859 --> 00:03:40,989
are unpredictable and they are harder to

00:03:37,840 --> 00:03:42,549
test so you so you need to use your

00:03:40,989 --> 00:03:46,209
impure functions carefully and

00:03:42,549 --> 00:03:48,250
predictably so now that we know what

00:03:46,209 --> 00:03:52,750
functional programming is and what a

00:03:48,250 --> 00:03:54,819
function is what are some tools one of

00:03:52,750 --> 00:03:57,609
the main ones is immutability and that's

00:03:54,819 --> 00:04:00,430
the idea that a variable state cannot be

00:03:57,609 --> 00:04:06,129
modified after creation and you might be

00:04:00,430 --> 00:04:07,870
thinking why why would you like to tie

00:04:06,129 --> 00:04:10,989
one arm behind your back

00:04:07,870 --> 00:04:13,060
but there is a reason for this there are

00:04:10,989 --> 00:04:16,599
some advantages of immutability such as

00:04:13,060 --> 00:04:18,489
it's less for your brain to track humans

00:04:16,599 --> 00:04:22,389
have a working memory it's the

00:04:18,489 --> 00:04:25,060
biological equivalent to RAM and if your

00:04:22,389 --> 00:04:26,490
brain has to keep track of what state a

00:04:25,060 --> 00:04:30,060
current variable is in

00:04:26,490 --> 00:04:32,100
it's more time that your brain is

00:04:30,060 --> 00:04:33,030
working on that and not spending on the

00:04:32,100 --> 00:04:36,389
rest of your program

00:04:33,030 --> 00:04:37,889
it also immutability prevents

00:04:36,389 --> 00:04:40,229
unintentional side-effects you

00:04:37,889 --> 00:04:42,840
accidentally changing a variable in a

00:04:40,229 --> 00:04:46,710
function can be a really hard bug to

00:04:42,840 --> 00:04:48,990
track down and it preserves state I like

00:04:46,710 --> 00:04:51,120
to think of it as your bank account

00:04:48,990 --> 00:04:53,160
balance when you sign into your bank

00:04:51,120 --> 00:04:56,130
account you don't just see your single

00:04:53,160 --> 00:04:57,569
balance you see your current balance

00:04:56,130 --> 00:04:59,490
which is derived from the starting

00:04:57,569 --> 00:05:03,599
balance and then the withdrawals and

00:04:59,490 --> 00:05:05,669
deposits another technique of functional

00:05:03,599 --> 00:05:07,289
programming is higher-order functions

00:05:05,669 --> 00:05:10,590
and that's a function that either

00:05:07,289 --> 00:05:13,770
accepts an argument in a function as an

00:05:10,590 --> 00:05:15,720
argument or returns a function you might

00:05:13,770 --> 00:05:19,380
be thinking this is something along the

00:05:15,720 --> 00:05:23,340
lines of but here's an example that

00:05:19,380 --> 00:05:25,259
might help here tone j/s is a framework

00:05:23,340 --> 00:05:28,020
that's built on top of the Web Audio API

00:05:25,259 --> 00:05:32,340
and playing out here is a higher order

00:05:28,020 --> 00:05:37,440
function it accepts a note and it

00:05:32,340 --> 00:05:41,520
returns a function play middle C here is

00:05:37,440 --> 00:05:45,599
the result of that that function being

00:05:41,520 --> 00:05:49,199
called with C for add eventlistener here

00:05:45,599 --> 00:05:50,699
accepts a function as an argument so add

00:05:49,199 --> 00:05:52,500
eventlistener and play note are both

00:05:50,699 --> 00:05:55,710
higher-order play note because it

00:05:52,500 --> 00:06:00,870
returns a function and add eventlistener

00:05:55,710 --> 00:06:03,060
because it accepts a function now

00:06:00,870 --> 00:06:05,969
manipulating arrays is an important part

00:06:03,060 --> 00:06:07,380
of all paradigms and functional

00:06:05,969 --> 00:06:10,560
programming has a lot of really great

00:06:07,380 --> 00:06:12,150
tools for dealing with arrays and

00:06:10,560 --> 00:06:13,560
there's two concepts that we already

00:06:12,150 --> 00:06:15,030
cover that are important the

00:06:13,560 --> 00:06:17,130
higher-order functions because each of

00:06:15,030 --> 00:06:18,960
these methods accept a function and

00:06:17,130 --> 00:06:22,979
immutability because each of these

00:06:18,960 --> 00:06:25,710
methods that I'm mentioning will return

00:06:22,979 --> 00:06:29,150
a new value rather than manipulating the

00:06:25,710 --> 00:06:31,500
current one so array that filter it

00:06:29,150 --> 00:06:34,080
accepts a function that's run against

00:06:31,500 --> 00:06:36,930
every element that function receives the

00:06:34,080 --> 00:06:40,729
element the index and the array and it

00:06:36,930 --> 00:06:45,870
returns a subset of the original array

00:06:40,729 --> 00:06:48,720
so we define a melody and we define a

00:06:45,870 --> 00:06:52,139
function is high which takes a note and

00:06:48,720 --> 00:06:54,539
returns a boolean if that value is equal

00:06:52,139 --> 00:06:59,430
to or above middle C it is considered

00:06:54,539 --> 00:07:02,699
high otherwise it is considered low so

00:06:59,430 --> 00:07:06,300
high notes is the melody filtered to is

00:07:02,699 --> 00:07:10,139
high and we get only the elements that

00:07:06,300 --> 00:07:18,780
return a truth eval you so here we have

00:07:10,139 --> 00:07:28,159
our unfiltered melody and when we filter

00:07:18,780 --> 00:07:30,120
to just the high notes a regular map

00:07:28,159 --> 00:07:32,639
accepts a function that's run against

00:07:30,120 --> 00:07:34,830
every element as well it also accepts

00:07:32,639 --> 00:07:37,379
the element index and array within that

00:07:34,830 --> 00:07:40,050
flat function but rather than returning

00:07:37,379 --> 00:07:42,270
a subset of the original array it

00:07:40,050 --> 00:07:48,000
returns an array of the same length with

00:07:42,270 --> 00:07:50,159
new values so we have our melody here

00:07:48,000 --> 00:07:54,659
and we have our increment octave

00:07:50,159 --> 00:07:57,270
function and then we map our melody to

00:07:54,659 --> 00:08:00,270
increment Optive and now we have the a

00:07:57,270 --> 00:08:10,560
copy of the array but with each note

00:08:00,270 --> 00:08:12,949
incremented by one octave or the high

00:08:10,560 --> 00:08:12,949
melody

00:08:13,080 --> 00:08:22,530
and the last one I'll cover today is a

00:08:16,949 --> 00:08:24,000
radar reduce and a radar reduced also

00:08:22,530 --> 00:08:26,400
accepts a function that's run against

00:08:24,000 --> 00:08:29,789
every element but in addition to the

00:08:26,400 --> 00:08:31,800
accumulator I in addition to the element

00:08:29,789 --> 00:08:35,250
index and array it also accepts an

00:08:31,800 --> 00:08:38,729
accumulator value and it will return the

00:08:35,250 --> 00:08:40,950
total accumulated value after passing

00:08:38,729 --> 00:08:42,690
through every element and in some

00:08:40,950 --> 00:08:47,220
languages this is known as fold and

00:08:42,690 --> 00:08:49,310
accumulate and it is a more generic tool

00:08:47,220 --> 00:08:52,380
than filter or map I often hear that

00:08:49,310 --> 00:08:56,220
reduce takes an array and returns a

00:08:52,380 --> 00:08:58,250
single value and this is true but I

00:08:56,220 --> 00:09:01,589
don't consider it to be a terribly

00:08:58,250 --> 00:09:04,769
useful distinction because all functions

00:09:01,589 --> 00:09:07,649
in JavaScript return a single value so I

00:09:04,769 --> 00:09:10,130
like to think of it as a generic utility

00:09:07,649 --> 00:09:14,190
function that can return any type

00:09:10,130 --> 00:09:17,390
whether it be another array in fact you

00:09:14,190 --> 00:09:20,370
can write filter or map using a reduce

00:09:17,390 --> 00:09:26,790
or it can return a single string or a

00:09:20,370 --> 00:09:32,420
single integer so I find the best way to

00:09:26,790 --> 00:09:36,120
learn reduce is really by by example

00:09:32,420 --> 00:09:39,209
so here we are defining this melody with

00:09:36,120 --> 00:09:41,940
note names and length then we have our

00:09:39,209 --> 00:09:44,880
two length function that is going to be

00:09:41,940 --> 00:09:48,750
passed to reduce total is the

00:09:44,880 --> 00:09:52,649
accumulator and note is the array

00:09:48,750 --> 00:09:59,000
element and then the function adds the

00:09:52,649 --> 00:09:59,000
total to the value of the notes length

00:09:59,959 --> 00:10:07,019
so length are a reduced accepts of

00:10:03,959 --> 00:10:09,589
function and an initial value and then

00:10:07,019 --> 00:10:13,370
the return value is the end accumulation

00:10:09,589 --> 00:10:16,019
so starting with the initial value of 0

00:10:13,370 --> 00:10:19,050
we go through and each notes length

00:10:16,019 --> 00:10:25,790
that's added to the total so 0 plus

00:10:19,050 --> 00:10:26,850
0.125 0.125 plus 0.125 is 0.25 0.375

00:10:25,790 --> 00:10:28,620
until

00:10:26,850 --> 00:10:31,740
we get to the total length of one point

00:10:28,620 --> 00:10:36,209
six to five seconds so here with our

00:10:31,740 --> 00:10:41,160
melody we get one point six two five

00:10:36,209 --> 00:10:44,130
seconds all right now that we're done

00:10:41,160 --> 00:10:46,079
with arrays partial application is an

00:10:44,130 --> 00:10:50,790
incredibly useful tool for writing

00:10:46,079 --> 00:10:53,220
reusable and generic functions and it is

00:10:50,790 --> 00:10:56,610
technique to preset or fix some of the

00:10:53,220 --> 00:10:59,730
arguments of a function so here we have

00:10:56,610 --> 00:11:03,380
a transpose function it takes a

00:10:59,730 --> 00:11:07,380
direction either up or down in interval

00:11:03,380 --> 00:11:11,930
such as a major third or a minor seventh

00:11:07,380 --> 00:11:15,899
and a note which will be transposed a

00:11:11,930 --> 00:11:19,350
major third is a function that is a

00:11:15,899 --> 00:11:24,360
partially applied transpose we set up

00:11:19,350 --> 00:11:28,079
and we set major third but we wait to

00:11:24,360 --> 00:11:31,230
receive the note so here when passing in

00:11:28,079 --> 00:11:35,930
C for AB major third will return an e

00:11:31,230 --> 00:11:40,529
for or a B flat two will return a d3 and

00:11:35,930 --> 00:11:45,660
there is a way in stage one of the tc39

00:11:40,529 --> 00:11:48,769
there's a there is a syntax for native

00:11:45,660 --> 00:11:52,800
partial application that will let you to

00:11:48,769 --> 00:11:55,680
partially apply partially apply

00:11:52,800 --> 00:11:57,660
arguments to a function by using the

00:11:55,680 --> 00:12:01,439
question mark for what you don't want to

00:11:57,660 --> 00:12:03,990
apply so down minor seventh can be a

00:12:01,439 --> 00:12:08,639
partially pi transpose by leaving the

00:12:03,990 --> 00:12:12,389
note as a question mark so here we can

00:12:08,639 --> 00:12:14,160
map these partially applied functions to

00:12:12,389 --> 00:12:16,850
an array of notes and here the

00:12:14,160 --> 00:12:16,850
transposition

00:12:17,880 --> 00:12:26,700
or up a major third or transpose down a

00:12:25,660 --> 00:12:30,420
minor seventh

00:12:26,700 --> 00:12:33,850
[Music]

00:12:30,420 --> 00:12:36,870
so partial application is a great tool

00:12:33,850 --> 00:12:41,440
for writing reusable functions that are

00:12:36,870 --> 00:12:44,790
partially applied but the real bread and

00:12:41,440 --> 00:12:48,700
butter of functional programming is

00:12:44,790 --> 00:12:51,280
composition and composition is a

00:12:48,700 --> 00:12:55,000
technique to combine multiple functions

00:12:51,280 --> 00:12:57,640
into a new function so here we're going

00:12:55,000 --> 00:13:01,540
to take a note name and we'll return the

00:12:57,640 --> 00:13:03,610
frequency but detuned slightly so we

00:13:01,540 --> 00:13:08,500
have a function converting a note name

00:13:03,610 --> 00:13:11,440
to a frequency for example an input of a

00:13:08,500 --> 00:13:15,640
four would return a number of four three

00:13:11,440 --> 00:13:21,790
which is the frequency in Hertz of in a

00:13:15,640 --> 00:13:23,650
four D tune-up will be defined a

00:13:21,790 --> 00:13:29,320
function to multiply by a small

00:13:23,650 --> 00:13:34,360
percentage so an input of 440 Hertz

00:13:29,320 --> 00:13:37,240
would return 444 0.4 and then compose

00:13:34,360 --> 00:13:41,680
here takes two functions and calls them

00:13:37,240 --> 00:13:45,070
from right to left so get detuned

00:13:41,680 --> 00:13:50,530
frequency is a function that is created

00:13:45,070 --> 00:13:56,230
by composing D tune-up and frequency so

00:13:50,530 --> 00:14:01,330
an input of a four would return 444

00:13:56,230 --> 00:14:03,160
point four and there's a pipeline

00:14:01,330 --> 00:14:07,420
operator that's currently in stage one

00:14:03,160 --> 00:14:09,760
of the tc39 spec as well that would

00:14:07,420 --> 00:14:13,240
allow for easier function composition

00:14:09,760 --> 00:14:16,480
through piping so here you can write a

00:14:13,240 --> 00:14:19,900
get detuned frequency by piping the note

00:14:16,480 --> 00:14:25,390
first to frequency and then to D tune-up

00:14:19,900 --> 00:14:33,160
so here we can hear our a4

00:14:25,390 --> 00:14:36,190
and the same note but detuned so now

00:14:33,160 --> 00:14:38,650
putting it all together we are going to

00:14:36,190 --> 00:14:42,250
be writing a function that converts a

00:14:38,650 --> 00:14:45,790
human-readable shorthand into a computer

00:14:42,250 --> 00:14:49,540
readable array so everyone able to read

00:14:45,790 --> 00:14:52,630
that all right just kidding

00:14:49,540 --> 00:14:55,450
so first we'll be importing some

00:14:52,630 --> 00:14:59,310
dependencies from RAM des and ton Jas

00:14:55,450 --> 00:15:06,010
and this might seem like a lot of

00:14:59,310 --> 00:15:14,300
functions that we're my computer just

00:15:06,010 --> 00:15:16,079
fell asleep sorry all right

00:15:14,300 --> 00:15:19,709
because that means I'm about halfway

00:15:16,079 --> 00:15:21,149
through cuz I thinks it's a 15 minute so

00:15:19,709 --> 00:15:25,259
first we're importing some dependencies

00:15:21,149 --> 00:15:28,949
from Ramdan tone j s and we're going to

00:15:25,259 --> 00:15:32,430
define some functions by function

00:15:28,949 --> 00:15:36,240
composition so here parse name takes a

00:15:32,430 --> 00:15:40,199
shorthand note and it returns a name for

00:15:36,240 --> 00:15:43,019
example c4 at a 10 would return a string

00:15:40,199 --> 00:15:48,269
of see it pipes the input through two

00:15:43,019 --> 00:15:50,310
other functions match which is which

00:15:48,269 --> 00:15:54,600
will return an array of matching strings

00:15:50,310 --> 00:15:57,149
that that match the regex and head which

00:15:54,600 --> 00:16:00,569
will return just the first string so

00:15:57,149 --> 00:16:02,670
when passing c4 at a 10 the match

00:16:00,569 --> 00:16:04,649
function would return in the array of

00:16:02,670 --> 00:16:07,110
the string of C and then the head

00:16:04,649 --> 00:16:09,029
function will take that array of the

00:16:07,110 --> 00:16:14,610
string of C and returns just the string

00:16:09,029 --> 00:16:19,079
of C so C for add a 10 to a ray of C for

00:16:14,610 --> 00:16:21,899
to just to just see parse octave here

00:16:19,079 --> 00:16:26,069
works similarly it takes a short hand

00:16:21,899 --> 00:16:29,220
note and it returns an octave so C for

00:16:26,069 --> 00:16:31,709
at a 10 will return an array of the

00:16:29,220 --> 00:16:36,300
string of 4 which will return the number

00:16:31,709 --> 00:16:39,329
4 and parse duration takes a short hand

00:16:36,300 --> 00:16:43,579
note and returns the duration it splits

00:16:39,329 --> 00:16:48,360
at the a symbol and it takes the last

00:16:43,579 --> 00:16:50,939
string so in this case in 8m first time

00:16:48,360 --> 00:16:53,459
here is a little bit more complicated it

00:16:50,939 --> 00:16:56,939
takes a note and it's context within the

00:16:53,459 --> 00:17:02,339
array and it will return a scheduled

00:16:56,939 --> 00:17:05,130
time so it takes the array of notes it

00:17:02,339 --> 00:17:09,179
slices the array to only those notes

00:17:05,130 --> 00:17:11,220
preceding that your current element it

00:17:09,179 --> 00:17:14,900
maps each of those notes to their length

00:17:11,220 --> 00:17:18,480
and it reduces them to a single value in

00:17:14,900 --> 00:17:21,839
this case of bird so as all together

00:17:18,480 --> 00:17:26,459
this lets the Web Audio API know when to

00:17:21,839 --> 00:17:28,050
play each note by adding the the time of

00:17:26,459 --> 00:17:31,440
all of the previous notes

00:17:28,050 --> 00:17:35,940
and now purse shorthand is a composition

00:17:31,440 --> 00:17:38,700
of compositions it accepts a string and

00:17:35,940 --> 00:17:40,700
it returns an array of objects that is

00:17:38,700 --> 00:17:45,000
able to be consumed by the Web Audio API

00:17:40,700 --> 00:17:49,620
through the the tone j/s first we split

00:17:45,000 --> 00:17:53,610
a tall white space this turns the the

00:17:49,620 --> 00:17:58,410
string into an array of strings and then

00:17:53,610 --> 00:18:02,000
array map we use two we pass it the

00:17:58,410 --> 00:18:07,320
array of strings and that converts it to

00:18:02,000 --> 00:18:10,020
of an object so apply spec takes an

00:18:07,320 --> 00:18:12,540
object shape with functions and each

00:18:10,020 --> 00:18:15,210
string in the array will be passed into

00:18:12,540 --> 00:18:17,840
each of these functions and it will be

00:18:15,210 --> 00:18:22,230
mapped to an object of a matching shape

00:18:17,840 --> 00:18:26,270
so what will be returned is an object

00:18:22,230 --> 00:18:29,510
with a name with with the value that

00:18:26,270 --> 00:18:32,070
were takes each of those strings and

00:18:29,510 --> 00:18:34,200
passes it to parse name for the name

00:18:32,070 --> 00:18:36,480
parse octave for the octave purse

00:18:34,200 --> 00:18:39,840
duration for the length and parse time

00:18:36,480 --> 00:18:44,550
for the time so with our purse shorthand

00:18:39,840 --> 00:18:47,610
function this input string becomes this

00:18:44,550 --> 00:18:50,610
array of strings past our PI spec

00:18:47,610 --> 00:18:52,800
becomes this array of note objects where

00:18:50,610 --> 00:18:58,800
we have the name the octave the length

00:18:52,800 --> 00:19:11,730
and the time so this string can become

00:18:58,800 --> 00:19:14,820
this music or this string can become

00:19:11,730 --> 00:19:24,770
this music

00:19:14,820 --> 00:19:24,770
[Music]

00:19:24,820 --> 00:19:31,730
so why should you care about functional

00:19:28,850 --> 00:19:33,740
programming I like functional

00:19:31,730 --> 00:19:35,960
programming because it forces you to

00:19:33,740 --> 00:19:40,000
break down problems into their smallest

00:19:35,960 --> 00:19:42,980
parts when converting a string into

00:19:40,000 --> 00:19:45,170
music we had to think of how to parse

00:19:42,980 --> 00:19:47,300
this shorthand in a way that a human

00:19:45,170 --> 00:19:50,660
that the computer could read it and

00:19:47,300 --> 00:19:52,550
there's a lot of parts there but we

00:19:50,660 --> 00:19:54,020
didn't write very many functions we

00:19:52,550 --> 00:19:56,930
there was only one function that was

00:19:54,020 --> 00:19:59,330
actually written most of the functions

00:19:56,930 --> 00:20:03,860
were defined by just piping together

00:19:59,330 --> 00:20:09,350
very small functions like like regex

00:20:03,860 --> 00:20:14,000
match or a or a first or a conversion

00:20:09,350 --> 00:20:15,830
from a string to a number or an ad so it

00:20:14,000 --> 00:20:20,480
forces you to break down problems into

00:20:15,830 --> 00:20:21,950
their smallest parts so if you found

00:20:20,480 --> 00:20:23,330
this interesting and would like to go

00:20:21,950 --> 00:20:26,110
further in functional programming

00:20:23,330 --> 00:20:29,090
there's some really great resources

00:20:26,110 --> 00:20:31,840
professor frisbees mostly advocate guide

00:20:29,090 --> 00:20:34,910
to functional programming it is

00:20:31,840 --> 00:20:37,370
definitely a more than adequate guide is

00:20:34,910 --> 00:20:40,670
available for free online Professor

00:20:37,370 --> 00:20:43,940
frisbee is known as doctor boolean on

00:20:40,670 --> 00:20:47,750
Twitter he's got some great great video

00:20:43,940 --> 00:20:49,910
resources as well also I would highly

00:20:47,750 --> 00:20:53,210
suggest looking into a functional

00:20:49,910 --> 00:20:58,220
utility library in in this case I used

00:20:53,210 --> 00:21:02,030
random lodash FP is a branch of lodash

00:20:58,220 --> 00:21:04,820
that has a lot of really great utility

00:21:02,030 --> 00:21:08,210
functions that have a functional

00:21:04,820 --> 00:21:11,360
programming perspective and lambda cast

00:21:08,210 --> 00:21:14,120
is a really great podcast for going over

00:21:11,360 --> 00:21:17,720
the fundamentals of functional

00:21:14,120 --> 00:21:19,640
programming much more in depth thank you

00:21:17,720 --> 00:21:21,170
so much for your time if you have any

00:21:19,640 --> 00:21:24,620
questions feel free to catch me

00:21:21,170 --> 00:21:27,639
afterwards or message me at Adam DC dev

00:21:24,620 --> 00:21:30,820
on Twitter thank you

00:21:27,639 --> 00:21:30,820
take mine

00:21:31,970 --> 00:21:35,380

YouTube URL: https://www.youtube.com/watch?v=boQhrk-AKMM


